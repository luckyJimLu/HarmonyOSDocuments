# 合并文件
合并时间: 2025-04-28 18:49:12

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/system-network-V14
爬取时间: 2025-04-28 07:08:19
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/connectivity-kit-V14
爬取时间: 2025-04-28 07:08:32
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/connectivity-kit-intro-V14
爬取时间: 2025-04-28 07:08:45
来源: Huawei Developer
Connectivity Kit开发概述
移动终端设备已经深入人民日常生活的方方面面，如连接蓝牙耳机听音乐、连接WIFI上网、使用NFC进行一碰开门等已成为终端用户日常生活中常见的行为。
当用户处于这些丰富的使用场景中时，蓝牙提供基于蓝牙连接的基础能力，如音乐/通话/分享等，WIFI提供基础的无线连接能力，NFC提供基础的靠近刷卡和读卡能力。
对于开发者，设计基础通信的体验服务，可以使应用的使用体验更贴近每个终端用户的日常生活。
蓝牙简介
蓝牙技术是一种无线通信技术，可以在短距离内传输数据。可以用于连接手机、耳机、音箱、键盘、鼠标、打印机等各种设备。特点是低功耗、低成本、简单易用。目前已经发展到了第五代，支持更高的数据传输速率和更广的覆盖范围。
下面简介几种常见的蓝牙涉及的模块：
-  ACCESS接入模块 蓝牙接入模块，提供了开关蓝牙以及获取蓝牙开关状态等接口功能。使用蓝牙功能需要通过该模块打开蓝牙，在蓝牙开关状态正确的条件下使用其他功能。 详情请参考@ohos.bluetooth.access API参考。
-  CONNECTION连接模块 蓝牙连接模块，提供了设备发现、配对连接、获取本端及外设信息的接口功能。使用和外设交互的功能，需要使用该模块提供的能力和外设配对、连接成功，才能继续进行后续的数据传输等功能。 详情请参考@ohos.bluetooth.connection API参考。
-  BLE模块（低功耗蓝牙） BLE是Bluetooth Low Energy的缩写，意为“低功耗蓝牙”。它是一种能够在低功耗情况下进行通信的蓝牙技术，与传统蓝牙相比，BLE的功耗更低，适用于需要长时间运行的低功耗设备，如智能手表、健康监测设备、智能家居等。 详情请参考@ohos.bluetooth.ble API参考。
-  SOCKET模块（串口协议） SPP是Serial Port Profile（串口协议）的缩写，是一种蓝牙协议，用于在蓝牙设备之间建立串行通信连接。通过SPP，蓝牙设备可以像使用串口一样进行数据传输，例如传输文件、文本等。 详情请参考@ohos.bluetooth.socket API参考。
-  A2DP模块（高级音频分发配置文件） A2DP是Advanced Audio Distribution Profile的缩写，即高级音频分发配置文件。它是一种蓝牙协议，允许无线传输高品质音频流，例如音乐或语音通话，同时支持双向通信，因此可以用于耳机、扬声器、汽车音响等设备。 详情请参考@ohos.bluetooth.a2dp API参考。
-  HFP模块（免提模式） HFP模块是指蓝牙耳机或车载蓝牙设备中的Hands-Free Profile，即“免提模式”。HFP允许用户通过蓝牙连接手机或其他蓝牙设备，实现免提通话和语音控制等功能。 详情请参考@ohos.bluetooth.hfp API参考。
-  HID模块（人机接口设备） HID是Human Interface Device的缩写，即人机接口设备。在蓝牙中，HID模块是一种允许用户通过蓝牙连接键盘、鼠标、游戏手柄等人机接口设备的模块。用户可以通过HID模块将这些设备连接到蓝牙主机上，实现无线控制和输入。 详情请参考@ohos.bluetooth.hid API参考。
-  PAN模块（个人区域网络） PAN（Personal Area Network）是个人区域网络的缩写，是一种无线通信技术，用于将设备连接到一个小范围的网络中。例如可以将手机、电脑、打印机等设备连接到一个PAN网络中，实现文件的共享和打印。 详情请参考@ohos.bluetooth.pan API参考。
相关开发指南可参考：蓝牙开发指南。
WLAN简介
无线局域网（Wireless Local Area Networks，WLAN），是通过无线电、红外光信号或者其他技术发送和接收数据的局域网，用户可以通过WLAN实现结点之间无物理连接的网络通讯。常用于用户携带可移动终端的办公、公众环境中。
WLAN系统为用户提供接入WLAN网络功能（STA模式）、点对点的数据传输功能（P2P模式）和热点分享功能（AP模式），让应用可以通过WLAN和其他设备互联互通。
-  STA模式 STA模式即工作站模式，可以理解为某网络中的一个工作站即客户端。当某设备具备该功能时，它可以连到另外的一个路由网络中，如家用路由器，通常用于提供网络的数据上行服务。 详情请参考@ohos.wifiManager API参考。
-  P2P模式 P2P模式也为Wi-Fi Direct；Wi-Fi Direct 是一种点对点连接技术，它可以在两台 STA 之间直接建立 TCP/IP 链接，并不需要AP的参与；其中一台STA会起到传统意义上的AP的作用，称为Group Owner(GO),另外一台station则称为Group Client(GC)，像连接AP一样连接到GO。 详情请参考@ohos.wifiManager API参考。
-  AP模式 AP模式为加入无线局域网的成员设备（即客户端）提供下行数据业务，它提供以无线方式组建无线局域网WLAN，相当于WLAN的中心设备。 详情请参考@ohos.wifiManager API参考。
NFC简介
NFC英文全称Near Field Communication，近距离无线通信。NFC服务提供NFC开关控制、NFC标签读写、NFC卡模拟等业务功能。
-  NFC开关 NFC开关模块，提供了打开NFC和关闭NFC功能。打开或关闭NFC的应用程序，需要声明权限"ohos.permission.MANAGE_SECURE_SETTINGS"，该权限只有系统应用才能声明。因此，只有系统应用才能打开或关闭NFC。 详情请参考@ohos.nfc.controller API参考。
-  NFC标签读写 NFC标签读写模块，提供了NFC标签的发现和分发给应用程序，以及应用程序通过NFC标签读写接口访问NFC标签的能力。应用程序需要按照规定的格式来声明NFC标签读写能力，只有声明后应用程序才能收到NFC标签的分发。 详情请参考@ohos.nfc.tag API参考。
-  NFC卡模拟 NFC卡模拟模块，提供了NFC的刷卡业务，电子设备和读卡器触碰完成刷卡。应用程序需要按照规定的格式来声明NFC卡模拟能力，只有声明后应用程序才能够具备刷卡能力。 详情请参考@ohos.nfc.cardEmulation API参考。
运作机制
Connectivity能力作为系统为应用提供的一种基础通信服务，需要在应用使用场景中打开相应开关/连接等处理，在业务结束时主动结束连接等。
约束与限制
使用设备的相关能力，需要用户主动授权打开开关。否则系统不会向三方应用提供服务。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/bluetooth-V14
爬取时间: 2025-04-28 07:08:58
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/br-development-guide-V14
爬取时间: 2025-04-28 07:11:04
来源: Huawei Developer
简介
蓝牙设置主要提供了开启蓝牙、关闭蓝牙、获取蓝牙状态的方法，帮助开发者实现基本蓝牙功能。
场景介绍
主要场景有：
接口说明
完整的 JS API 说明以及实例代码请参考：access 接口。
具体接口说明如下表。
| 接口名 | 功能描述 |
| --- | --- |
| enableBluetooth() | 开启蓝牙。 |
| disableBluetooth() | 关闭蓝牙。 |
| getState() | 获取蓝牙开关状态。 |
| on(type: 'stateChange') | 订阅蓝牙设备开关状态事件。 |
| off(type: 'stateChange') | 取消订阅蓝牙设备开关状态事件。 |
主要场景开发步骤
开启、关闭蓝牙
1.  import需要的access模块。
2.  需要SystemCapability.Communication.Bluetooth.Core系统能力。
3.  开启蓝牙。
4.  关闭蓝牙。
5.  示例代码：
```typescript
import { access } from '@kit.ConnectivityKit';
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
// 开启蓝牙
access.enableBluetooth();
access.on('stateChange', (data) => {
let btStateMessage = '';
switch (data) {
case 0:
btStateMessage += 'STATE_OFF';
break;
case 1:
btStateMessage += 'STATE_TURNING_ON';
break;
case 2:
btStateMessage += 'STATE_ON';
break;
case 3:
btStateMessage += 'STATE_TURNING_OFF';
break;
case 4:
btStateMessage += 'STATE_BLE_TURNING_ON';
break;
case 5:
btStateMessage += 'STATE_BLE_ON';
break;
case 6:
btStateMessage += 'STATE_BLE_TURNING_OFF';
break;
default:
btStateMessage += 'unknown status';
break;
}
if (btStateMessage == 'STATE_ON') {
access.off('stateChange');
}
console.info('bluetooth statues: ' + btStateMessage);
})
// 关闭蓝牙
access.disableBluetooth();
access.on('stateChange', (data) => {
let btStateMessage = '';
switch (data) {
case 0:
btStateMessage += 'STATE_OFF';
break;
case 1:
btStateMessage += 'STATE_TURNING_ON';
break;
case 2:
btStateMessage += 'STATE_ON';
break;
case 3:
btStateMessage += 'STATE_TURNING_OFF';
break;
case 4:
btStateMessage += 'STATE_BLE_TURNING_ON';
break;
case 5:
btStateMessage += 'STATE_BLE_ON';
break;
case 6:
btStateMessage += 'STATE_BLE_TURNING_OFF';
break;
default:
btStateMessage += 'unknown status';
break;
}
if (btStateMessage == 'STATE_OFF') {
access.off('stateChange');
}
console.info("bluetooth statues: " + btStateMessage);
})
```
6.  错误码请参见蓝牙服务子系统错误码。
7.  如何验证： 执行开启蓝牙代码，记录日志“bluetooth statues: STATE_ON”，则表示开启蓝牙成功。执行关闭蓝牙代码，记录日志“bluetooth statues: STATE_OFF”，则表示蓝牙关闭成功。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ble-development-guide-V14
爬取时间: 2025-04-28 07:11:17
来源: Huawei Developer
简介
广播与扫描，主要提供了蓝牙设备的开启广播、关闭广播、开启扫描、关闭扫描方法，通过广播和扫描发现对端蓝牙设备，实现低功耗的通信。
场景介绍
主要场景有：
接口说明
完整的 JS API 说明以及实例代码请参考：BLE 接口。
具体接口说明如下表。
| 接口名 | 功能描述 |
| --- | --- |
| startBLEScan() | 发起BLE扫描流程。 |
| stopBLEScan() | 停止BLE扫描流程。 |
| startAdvertising() | 开始发送BLE广播。 |
| disableAdvertising() | 临时停止BLE广播。 |
| enableAdvertising() | 临时启动BLE广播。 |
| stopAdvertising() | 停止发送BLE广播。 |
| on(type: 'advertisingStateChange') | 订阅BLE广播状态。 |
| off(type: 'advertisingStateChange') | 取消订阅BLE广播状态。 |
| on(type: 'BLEDeviceFind') | 订阅BLE设备发现上报事件。 |
| off(type: 'BLEDeviceFind') | 取消订阅BLE设备发现上报事件。 |
主要场景开发步骤
开启、关闭广播
1.  import需要的ble模块。
2.  开启设备的蓝牙。
3.  需要SystemCapability.Communication.Bluetooth.Core系统能力。
4.  开启广播，对端设备扫描该广播。
5.  关闭广播。
6.  示例代码：
```typescript
import { ble } from '@kit.ConnectivityKit';
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
const TAG: string = 'BleAdvertisingManager';
export class BleAdvertisingManager {
private advHandle: number = 0xFF; // default invalid value
// 1 订阅广播状态
public onAdvertisingStateChange() {
try {
ble.on('advertisingStateChange', (data: ble.AdvertisingStateChangeInfo) => {
console.info(TAG, 'bluetooth advertising state = ' + JSON.stringify(data));
AppStorage.setOrCreate('advertiserState', data.state);
});
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 2 首次启动广播
public async startAdvertising() {
// 2.1 设置广播发送的参数
let setting: ble.AdvertiseSetting = {
interval: 160,
txPower: 0,
connectable: true
};
// 2.2 构造广播数据
let manufactureValueBuffer = new Uint8Array(4);
manufactureValueBuffer[0] = 1;
manufactureValueBuffer[1] = 2;
manufactureValueBuffer[2] = 3;
manufactureValueBuffer[3] = 4;
let serviceValueBuffer = new Uint8Array(4);
serviceValueBuffer[0] = 5;
serviceValueBuffer[1] = 6;
serviceValueBuffer[2] = 7;
serviceValueBuffer[3] = 8;
let manufactureDataUnit: ble.ManufactureData = {
manufactureId: 4567,
manufactureValue: manufactureValueBuffer.buffer
};
let serviceDataUnit: ble.ServiceData = {
serviceUuid: "00001888-0000-1000-8000-00805f9b34fb",
serviceValue: serviceValueBuffer.buffer
};
let advData: ble.AdvertiseData = {
serviceUuids: ["00001888-0000-1000-8000-00805f9b34fb"],
manufactureData: [manufactureDataUnit],
serviceData: [serviceDataUnit],
includeDeviceName: false // 表示是否携带设备名，可选参数。注意带上设备名时广播包长度不能超出31个字节。
};
let advResponse: ble.AdvertiseData = {
serviceUuids: ["00001888-0000-1000-8000-00805f9b34fb"],
manufactureData: [manufactureDataUnit],
serviceData: [serviceDataUnit]
};
// 2.3 构造广播启动完整参数AdvertisingParams
let advertisingParams: ble.AdvertisingParams = {
advertisingSettings: setting,
advertisingData: advData,
advertisingResponse: advResponse,
duration: 0 // 可选参数，若大于0，则广播发送一段时间后，则会临时停止，可重新启动发送
}
// 2.4 首次启动广播，且获取所启动广播的标识ID
try {
this.onAdvertisingStateChange();
this.advHandle = await ble.startAdvertising(advertisingParams);
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 4 临时停止广播，该广播资源仍然存在
public async disableAdvertising() {
// 4.1 构造临时停止广播参数
let advertisingDisableParams: ble.AdvertisingDisableParams = {
advertisingId: this.advHandle // 使用首次启动广播时获取到的广播标识ID
}
// 4.2 临时停止
try {
await ble.disableAdvertising(advertisingDisableParams);
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 5 再次启动广播
public async enableAdvertising(enableDuration: number) {
// 5.1 构造临时启动广播参数
let advertisingEnableParams: ble.AdvertisingEnableParams = {
advertisingId: this.advHandle, // 使用首次启动广播时获取到的广播标识ID
duration: enableDuration
}
// 5.2 再次启动
try {
await ble.enableAdvertising(advertisingEnableParams);
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 6 完全关闭广播，释放广播资源
public async stopAdvertising() {
try {
await ble.stopAdvertising(this.advHandle);
ble.off('advertisingStateChange', (data: ble.AdvertisingStateChangeInfo) => {
console.info(TAG, 'bluetooth advertising state = ' + JSON.stringify(data));
});
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
}
let bleAdvertisingManager = new BleAdvertisingManager();
export default bleAdvertisingManager as BleAdvertisingManager;
```
7.  错误码请参见蓝牙服务子系统错误码。
开启、关闭扫描
1.  import需要的ble模块。
2.  开启设备的蓝牙。
3.  需要SystemCapability.Communication.Bluetooth.Core系统能力。
4.  对端设备开启广播。
5.  本端设备开启扫描，获取扫描结果。
6.  关闭扫描。
7.  示例代码:
```typescript
import { ble } from '@kit.ConnectivityKit';
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
const TAG: string = 'BleScanManager';
const BLE_ADV_TYPE_FLAG = 0x01;
const BLE_ADV_TYPE_16_BIT_SERVICE_UUIDS_INCOMPLETE = 0x02;
const BLE_ADV_TYPE_16_BIT_SERVICE_UUIDS_COMPLETE = 0x03;
const BLE_ADV_TYPE_32_BIT_SERVICE_UUIDS_INCOMPLETE = 0x04;
const BLE_ADV_TYPE_32_BIT_SERVICE_UUIDS_COMPLETE = 0x05;
const BLE_ADV_TYPE_128_BIT_SERVICE_UUIDS_INCOMPLETE = 0x06;
const BLE_ADV_TYPE_128_BIT_SERVICE_UUIDS_COMPLETE = 0x07;
const BLE_ADV_TYPE_LOCAL_NAME_SHORT = 0x08;
const BLE_ADV_TYPE_LOCAL_NAME_COMPLETE = 0x09;
const BLE_ADV_TYPE_TX_POWER_LEVEL = 0x0A;
const BLE_ADV_TYPE_16_BIT_SERVICE_SOLICITATION_UUIDS = 0x14;
const BLE_ADV_TYPE_128_BIT_SERVICE_SOLICITATION_UUIDS = 0x15;
const BLE_ADV_TYPE_32_BIT_SERVICE_SOLICITATION_UUIDS = 0x1F;
const BLE_ADV_TYPE_16_BIT_SERVICE_DATA = 0x16;
const BLE_ADV_TYPE_32_BIT_SERVICE_DATA = 0x20;
const BLE_ADV_TYPE_128_BIT_SERVICE_DATA = 0x21;
const BLE_ADV_TYPE_MANUFACTURER_SPECIFIC_DATA = 0xFF;
const BLUETOOTH_UUID_16_BIT_LENGTH = 2;
const BLUETOOTH_UUID_32_BIT_LENGTH = 4;
const BLUETOOTH_UUID_128_BIT_LENGTH = 16;
const BLUETOOTH_MANUFACTURE_ID_LENGTH = 2;
export class BleScanManager {
// 1 订阅扫描结果
public onScanResult() {
ble.on('BLEDeviceFind', (data: Array<ble.ScanResult>) => {
if (data.length > 0) {
console.info(TAG, 'BLE scan result = ' + data[0].deviceId);
this.parseScanResult(data[0].data);
}
});
}
private parseScanResult(data: ArrayBuffer) {
let advData = new Uint8Array(data);
if (advData.byteLength == 0) {
console.warn(TAG, 'nothing, adv data length is 0');
return;
}
console.info(TAG, 'advData: ' + JSON.stringify(advData));
let advFlags: number = -1;
let txPowerLevel: number = -1;
let localName: string = "";
let serviceUuids: string[] = [];
let serviceSolicitationUuids: string[] = [];
let serviceDatas: Record<string, Uint8Array> = {};
let manufactureSpecificDatas: Record<number, Uint8Array> = {};
let curPos = 0;
while (curPos < advData.byteLength) {
let length = advData[curPos++];
if (length == 0) {
break;
}
let advDataLength = length - 1;
let advDataType = advData[curPos++];
switch (advDataType) {
case BLE_ADV_TYPE_FLAG:
advFlags = advData[curPos];
break;
case BLE_ADV_TYPE_LOCAL_NAME_SHORT:
case BLE_ADV_TYPE_LOCAL_NAME_COMPLETE:
localName = advData.slice(curPos, curPos + advDataLength).toString();
break;
case BLE_ADV_TYPE_TX_POWER_LEVEL:
txPowerLevel = advData[curPos];
break;
case BLE_ADV_TYPE_16_BIT_SERVICE_UUIDS_INCOMPLETE:
case BLE_ADV_TYPE_16_BIT_SERVICE_UUIDS_COMPLETE:
this.parseServiceUuid(BLUETOOTH_UUID_16_BIT_LENGTH, curPos, advDataLength, advData, serviceUuids);
break;
case BLE_ADV_TYPE_32_BIT_SERVICE_UUIDS_INCOMPLETE:
case BLE_ADV_TYPE_32_BIT_SERVICE_UUIDS_COMPLETE:
this.parseServiceUuid(BLUETOOTH_UUID_32_BIT_LENGTH, curPos, advDataLength, advData, serviceUuids);
break;
case BLE_ADV_TYPE_128_BIT_SERVICE_UUIDS_INCOMPLETE:
case BLE_ADV_TYPE_128_BIT_SERVICE_UUIDS_COMPLETE:
this.parseServiceUuid(BLUETOOTH_UUID_128_BIT_LENGTH, curPos, advDataLength, advData, serviceUuids);
break;
case BLE_ADV_TYPE_16_BIT_SERVICE_SOLICITATION_UUIDS:
this.parseServiceSolicitationUuid(BLUETOOTH_UUID_16_BIT_LENGTH, curPos, advDataLength,
advData, serviceSolicitationUuids);
break;
case BLE_ADV_TYPE_32_BIT_SERVICE_SOLICITATION_UUIDS:
this.parseServiceSolicitationUuid(BLUETOOTH_UUID_32_BIT_LENGTH, curPos, advDataLength,
advData, serviceSolicitationUuids);
break;
case BLE_ADV_TYPE_128_BIT_SERVICE_SOLICITATION_UUIDS:
this.parseServiceSolicitationUuid(BLUETOOTH_UUID_128_BIT_LENGTH, curPos, advDataLength,
advData, serviceSolicitationUuids);
break;
case BLE_ADV_TYPE_16_BIT_SERVICE_DATA:
this.parseServiceData(BLUETOOTH_UUID_16_BIT_LENGTH, curPos, advDataLength, advData, serviceDatas);
break;
case BLE_ADV_TYPE_32_BIT_SERVICE_DATA:
this.parseServiceData(BLUETOOTH_UUID_32_BIT_LENGTH, curPos, advDataLength, advData, serviceDatas);
break;
case BLE_ADV_TYPE_128_BIT_SERVICE_DATA:
this.parseServiceData(BLUETOOTH_UUID_128_BIT_LENGTH, curPos, advDataLength, advData, serviceDatas);
break;
case BLE_ADV_TYPE_MANUFACTURER_SPECIFIC_DATA:
this.parseManufactureData(curPos, advDataLength, advData, manufactureSpecificDatas);
break;
default:
break;
}
curPos += advDataLength;
}
}
private parseServiceUuid(uuidLength: number, curPos: number, advDataLength: number,
advData: Uint8Array, serviceUuids: string[]) {
while (advDataLength > 0) {
let tmpData: Uint8Array = advData.slice(curPos, curPos + uuidLength);
serviceUuids.push(this.getUuidFromUint8Array(uuidLength, tmpData));
advDataLength -= uuidLength;
curPos += uuidLength;
}
}
private parseServiceSolicitationUuid(uuidLength: number, curPos: number, advDataLength: number,
advData: Uint8Array, serviceSolicitationUuids: string[]) {
while (advDataLength > 0) {
let tmpData: Uint8Array = advData.slice(curPos, curPos + uuidLength);
serviceSolicitationUuids.push(this.getUuidFromUint8Array(uuidLength, tmpData));
advDataLength -= uuidLength;
curPos += uuidLength;
}
}
private getUuidFromUint8Array(uuidLength: number, uuidData: Uint8Array): string {
let uuid = "";
let temp: string = "";
for (let i = uuidLength - 1; i > -1; i--) {
temp += uuidData[i].toString(16).padStart(2, "0");
}
switch (uuidLength) {
case BLUETOOTH_UUID_16_BIT_LENGTH:
uuid = `0000${temp}-0000-1000-8000-00805F9B34FB`;
break;
case BLUETOOTH_UUID_32_BIT_LENGTH:
uuid = `${temp}-0000-1000-8000-00805F9B34FB`;
break;
case BLUETOOTH_UUID_128_BIT_LENGTH:
uuid = `${temp.substring(0, 8)}-${temp.substring(8, 12)}-${temp.substring(12, 16)}-${temp.substring(16, 20)}-${temp.substring(20, 32)}`;
break;
default:
break;
}
return uuid;
}
private parseServiceData(uuidLength: number, curPos: number, advDataLength: number,
advData: Uint8Array, serviceDatas: Record<string, Uint8Array>) {
let tmpUuid: Uint8Array = advData.slice(curPos, curPos + uuidLength);
let tmpValue: Uint8Array = advData.slice(curPos + uuidLength, curPos + advDataLength);
serviceDatas[tmpUuid.toString()] = tmpValue;
}
private parseManufactureData(curPos: number, advDataLength: number,
advData: Uint8Array, manufactureSpecificDatas: Record<number, Uint8Array>) {
let manufactureId: number = (advData[curPos + 1] << 8) + advData[curPos];
let tmpValue: Uint8Array = advData.slice(curPos + BLUETOOTH_MANUFACTURE_ID_LENGTH, curPos + advDataLength);
manufactureSpecificDatas[manufactureId] = tmpValue;
}
// 2 开启扫描
public startScan() {
// 2.1 构造扫描过滤器，需要能够匹配预期的广播包内容
let manufactureId = 4567;
let manufactureData: Uint8Array = new Uint8Array([1, 2, 3, 4]);
let manufactureDataMask: Uint8Array = new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF]);
let scanFilter: ble.ScanFilter = { // 根据业务实际情况定义过滤器
manufactureId: manufactureId,
manufactureData: manufactureData.buffer,
manufactureDataMask: manufactureDataMask.buffer
};
// 2.2 构造扫描参数
let scanOptions: ble.ScanOptions = {
interval: 0,
dutyMode: ble.ScanDuty.SCAN_MODE_LOW_POWER,
matchMode: ble.MatchMode.MATCH_MODE_AGGRESSIVE
}
try {
this.onScanResult(); // 订阅扫描结果
ble.startBLEScan([scanFilter], scanOptions);
console.info(TAG, 'startBleScan success');
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 3 关闭扫描
public stopScan() {
try {
ble.off('BLEDeviceFind', (data: Array<ble.ScanResult>) => { // 取消订阅扫描结果
console.info(TAG, 'off success');
});
ble.stopBLEScan();
console.info(TAG, 'stopBleScan success');
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
}
let bleScanManager = new BleScanManager();
export default bleScanManager as BleScanManager;
```
8.  错误码请参见蓝牙服务子系统错误码。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/gatt-development-guide-V14
爬取时间: 2025-04-28 07:11:31
来源: Huawei Developer
简介
通用属性协议是GATT（Generic Attribute）的缩写，它是一种用于在蓝牙低功耗设备之间传输数据的协议，定义了一套通用的属性和服务框架。通过GATT协议，蓝牙设备可以向其他设备提供服务，也可以从其他设备获取服务。
场景介绍
主要场景有：
接口说明
完整的 JS API 说明以及实例代码请参考：GATT 接口。
具体接口说明如下表。
| 接口名 | 功能描述 |
| --- | --- |
| connect() | client端发起连接远端蓝牙低功耗设备。 |
| disconnect() | client端断开与远端蓝牙低功耗设备的连接。 |
| close() | 关闭客户端功能，注销client在协议栈的注册，调用该接口后GattClientDevice实例将不能再使用。 |
| getDeviceName() | client获取远端蓝牙低功耗设备名。 |
| getServices() | client端获取蓝牙低功耗设备的所有服务，即服务发现 。 |
| readCharacteristicValue() | client端读取蓝牙低功耗设备特定服务的特征值。 |
| readDescriptorValue() | client端读取蓝牙低功耗设备特定的特征包含的描述符。 |
| writeCharacteristicValue() | client端向低功耗蓝牙设备写入特定的特征值。 |
| writeDescriptorValue() | client端向低功耗蓝牙设备特定的描述符写入二进制数据。 |
| getRssiValue() | client获取远端蓝牙低功耗设备的信号强度 (Received Signal Strength Indication, RSSI)，调用connect接口连接成功后才能使用。 |
| setBLEMtuSize() | client协商远端蓝牙低功耗设备的最大传输单元（Maximum Transmission Unit, MTU），调用connect接口连接成功后才能使用。 |
| setCharacteristicChangeNotification() | 向服务端发送设置通知此特征值请求。 |
| setCharacteristicChangeIndication() | 向服务端发送设置通知此特征值请求。 |
| on(type: 'BLECharacteristicChange') | 订阅蓝牙低功耗设备的特征值变化事件。需要先调用setNotifyCharacteristicChanged接口才能接收server端的通知。 |
| off(type: 'BLECharacteristicChange') | 取消订阅蓝牙低功耗设备的特征值变化事件。 |
| on(type: 'BLEConnectionStateChange') | client端订阅蓝牙低功耗设备的连接状态变化事件。 |
| off(type: 'BLEConnectionStateChange') | 取消订阅蓝牙低功耗设备的连接状态变化事件。 |
| on(type: 'BLEMtuChange') | client端订阅MTU状态变化事件。 |
| off(type: 'BLEMtuChange') | client端取消订阅MTU状态变化事件。 |
| addService() | server端添加服务。 |
| removeService() | 删除已添加的服务。 |
| close() | 关闭服务端功能，去注销server在协议栈的注册，调用该接口后GattServer实例将不能再使用。 |
| notifyCharacteristicChanged() | server端特征值发生变化时，主动通知已连接的client设备。 |
| sendResponse() | server端回复client端的读写请求。 |
| on(type: 'characteristicRead') | server端订阅特征值读请求事件。 |
| off(type: 'characteristicRead') | server端取消订阅特征值读请求事件。 |
| on(type: 'characteristicWrite') | server端订阅特征值写请求事件。 |
| off(type: 'characteristicWrite') | server端取消订阅特征值写请求事件。 |
| on(type: 'descriptorRead') | server端订阅描述符读请求事件。 |
| off(type: 'descriptorRead') | server端取消订阅描述符读请求事件。 |
| on(type: 'descriptorWrite') | server端订阅描述符写请求事件。 |
| off(type: 'descriptorWrite') | server端取消订阅描述符写请求事件。 |
| on(type: 'connectionStateChange') | server端订阅BLE连接状态变化事件。 |
| off(type: 'connectionStateChange') | server端取消订阅BLE连接状态变化事件。 |
| on(type: 'BLEMtuChange') | server端订阅MTU状态变化事件。 |
| off(type: 'BLEMtuChange') | server端取消订阅MTU状态变化事件。 |
主要场景开发步骤
连接server端读取和写入信息
1.  import需要的ble模块。
2.  创建gattClient实例对象。
3.  连接gattServer。
4.  读取gattServer的特征值和描述符。
5.  向gattServer写入特征值和描述符。
6.  断开连接，销毁gattClient实例。
7.  示例代码:
```typescript
import { ble } from '@kit.ConnectivityKit';
import { constant } from '@kit.ConnectivityKit';
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
const TAG: string = 'GattClientManager';
export class GattClientManager {
device: string | undefined = undefined;
gattClient: ble.GattClientDevice | undefined = undefined;
connectState: ble.ProfileConnectionState = constant.ProfileConnectionState.STATE_DISCONNECTED;
myServiceUuid: string = '00001810-0000-1000-8000-00805F9B34FB';
myCharacteristicUuid: string = '00001820-0000-1000-8000-00805F9B34FB';
myFirstDescriptorUuid: string = '00002902-0000-1000-8000-00805F9B34FB'; // 2902一般用于notification或者indication
mySecondDescriptorUuid: string = '00002903-0000-1000-8000-00805F9B34FB';
found: boolean = false;
// 构造BLEDescriptor
private initDescriptor(des: string, value: ArrayBuffer): ble.BLEDescriptor {
let descriptor: ble.BLEDescriptor = {
serviceUuid: this.myServiceUuid,
characteristicUuid: this.myCharacteristicUuid,
descriptorUuid: des,
descriptorValue: value
};
return descriptor;
}
// 构造BLECharacteristic
private initCharacteristic(): ble.BLECharacteristic {
let descriptors: Array<ble.BLEDescriptor> = [];
let descBuffer = new ArrayBuffer(2);
let descValue = new Uint8Array(descBuffer);
descValue[0] = 11;
descValue[1] = 12;
descriptors[0] = this.initDescriptor(this.myFirstDescriptorUuid, new ArrayBuffer(2));
descriptors[1] = this.initDescriptor(this.mySecondDescriptorUuid, descBuffer);
let charBuffer = new ArrayBuffer(2);
let charValue = new Uint8Array(charBuffer);
charValue[0] = 1;
charValue[1] = 2;
let characteristic: ble.BLECharacteristic = {
serviceUuid: this.myServiceUuid,
characteristicUuid: this.myCharacteristicUuid,
characteristicValue: charBuffer,
descriptors: descriptors
};
return characteristic;
}
private logCharacteristic(char: ble.BLECharacteristic) {
let message = 'logCharacteristic uuid:' + char.characteristicUuid + '\n';
let value = new Uint8Array(char.characteristicValue);
message += 'logCharacteristic value: ';
for (let i = 0; i < char.characteristicValue.byteLength; i++) {
message += value[i] + ' ';
}
console.info(TAG, message);
}
private logDescriptor(des: ble.BLEDescriptor) {
let message = 'logDescriptor uuid:' + des.descriptorUuid + '\n';
let value = new Uint8Array(des.descriptorValue);
message += 'logDescriptor value: ';
for (let i = 0; i < des.descriptorValue.byteLength; i++) {
message += value[i] + ' ';
}
console.info(TAG, message);
}
private checkService(services: Array<ble.GattService>): boolean {
for (let i = 0; i < services.length; i++) {
if (services[i].serviceUuid != this.myServiceUuid) {
continue;
}
for (let j = 0; j < services[i].characteristics.length; j++) {
if (services[i].characteristics[j].characteristicUuid != this.myCharacteristicUuid) {
continue;
}
for (let k = 0; k < services[i].characteristics[j].descriptors.length; k++) {
if (services[i].characteristics[j].descriptors[k].descriptorUuid == this.myFirstDescriptorUuid) {
console.info(TAG, 'find expected service from server');
return true;
}
}
}
}
console.error(TAG, 'no expected service from server');
return false;
}
// 1. 订阅连接状态变化事件
public onGattClientStateChange() {
if (!this.gattClient) {
console.error(TAG, 'no gattClient');
return;
}
try {
this.gattClient.on('BLEConnectionStateChange', (stateInfo: ble.BLEConnectionChangeState) => {
let state = '';
switch (stateInfo.state) {
case 0:
state = 'DISCONNECTED';
break;
case 1:
state = 'CONNECTING';
break;
case 2:
state = 'CONNECTED';
break;
case 3:
state = 'DISCONNECTING';
break;
default:
state = 'undefined';
break;
}
console.info(TAG, 'onGattClientStateChange: device=' + stateInfo.deviceId + ', state=' + state);
if (stateInfo.deviceId == this.device) {
this.connectState = stateInfo.state;
}
});
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 2. client端主动连接时调用
public startConnect(peerDevice: string) { // 对端设备一般通过ble scan获取到
if (this.connectState != constant.ProfileConnectionState.STATE_DISCONNECTED) {
console.error(TAG, 'startConnect failed');
return;
}
console.info(TAG, 'startConnect ' + peerDevice);
this.device = peerDevice;
// 2.1 使用device构造gattClient，后续的交互都需要使用该实例
this.gattClient = ble.createGattClientDevice(peerDevice);
try {
this.onGattClientStateChange(); // 2.2 订阅连接状态
this.gattClient.connect(); // 2.3 发起连接
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 3. client端连接成功后，需要进行服务发现
public discoverServices() {
if (!this.gattClient) {
console.info(TAG, 'no gattClient');
return;
}
console.info(TAG, 'discoverServices');
try {
this.gattClient.getServices().then((result: Array<ble.GattService>) => {
console.info(TAG, 'getServices success: ' + JSON.stringify(result));
this.found = this.checkService(result); // 要确保server端的服务内容有业务所需要的服务
});
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 4. 在确保拿到了server端的服务结果后，读取server端特定服务的特征值时调用
public readCharacteristicValue() {
if (!this.gattClient || this.connectState != constant.ProfileConnectionState.STATE_CONNECTED) {
console.error(TAG, 'no gattClient or not connected');
return;
}
if (!this.found) { // 要确保server端有对应的characteristic
console.error(TAG, 'no characteristic from server');
return;
}
let characteristic = this.initCharacteristic();
console.info(TAG, 'readCharacteristicValue');
try {
this.gattClient.readCharacteristicValue(characteristic).then((outData: ble.BLECharacteristic) => {
this.logCharacteristic(outData);
})
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 5. 在确保拿到了server端的服务结果后，写入server端特定服务的特征值时调用
public writeCharacteristicValue() {
if (!this.gattClient || this.connectState != constant.ProfileConnectionState.STATE_CONNECTED) {
console.error(TAG, 'no gattClient or not connected');
return;
}
if (!this.found) { // 要确保server端有对应的characteristic
console.error(TAG, 'no characteristic from server');
return;
}
let characteristic = this.initCharacteristic();
console.info(TAG, 'writeCharacteristicValue');
try {
this.gattClient.writeCharacteristicValue(characteristic, ble.GattWriteType.WRITE, (err) => {
if (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
return;
}
console.info(TAG, 'writeCharacteristicValue success');
});
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 6. 在确保拿到了server端的服务结果后，读取server端特定服务的描述符时调用
public readDescriptorValue() {
if (!this.gattClient || this.connectState != constant.ProfileConnectionState.STATE_CONNECTED) {
console.error(TAG, 'no gattClient or not connected');
return;
}
if (!this.found) { // 要确保server端有对应的descriptor
console.error(TAG, 'no descriptor from server');
return;
}
let descBuffer = new ArrayBuffer(0);
let descriptor = this.initDescriptor(this.mySecondDescriptorUuid, descBuffer);
console.info(TAG, 'readDescriptorValue');
try {
this.gattClient.readDescriptorValue(descriptor).then((outData: ble.BLEDescriptor) => {
this.logDescriptor(outData);
});
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 7. 在确保拿到了server端的服务结果后，写入server端特定服务的描述符时调用
public writeDescriptorValue() {
if (!this.gattClient || this.connectState != constant.ProfileConnectionState.STATE_CONNECTED) {
console.error(TAG, 'no gattClient or not connected');
return;
}
if (!this.found) { // 要确保server端有对应的descriptor
console.error(TAG, 'no descriptor from server');
return;
}
let descBuffer = new ArrayBuffer(2);
let descValue = new Uint8Array(descBuffer);
descValue[0] = 11;
descValue[1] = 12;
let descriptor = this.initDescriptor(this.mySecondDescriptorUuid, descBuffer);
console.info(TAG, 'writeDescriptorValue');
try {
this.gattClient.writeDescriptorValue(descriptor, (err) => {
if (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
return;
}
console.info(TAG, 'writeDescriptorValue success');
});
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 8.client端主动断开时调用
public stopConnect() {
if (!this.gattClient || this.connectState != constant.ProfileConnectionState.STATE_CONNECTED) {
console.error(TAG, 'no gattClient or not connected');
return;
}
console.info(TAG, 'stopConnect ' + this.device);
try {
this.gattClient.disconnect(); // 8.1 断开连接
this.gattClient.off('BLEConnectionStateChange', (stateInfo: ble.BLEConnectionChangeState) => {
});
this.gattClient.close() // 8.2 如果不再使用此gattClient，则需要close
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
}
let gattClientManager = new GattClientManager();
export default gattClientManager as GattClientManager;
```
8.  错误码请参见蓝牙服务子系统错误码。
server端操作services和通知客户端信息
1.  import需要的ble模块。
2.  创建gattServer实例对象。
3.  添加services信息。
4.  当向gattServer写入特征值通知gattClient。
5.  移除services信息。
6.  注销gattServer实例。
7.  示例代码:
```typescript
import { ble } from '@kit.ConnectivityKit';
import { constant } from '@kit.ConnectivityKit';
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
const TAG: string = 'GattServerManager';
export class GattServerManager {
gattServer: ble.GattServer | undefined = undefined;
connectState: ble.ProfileConnectionState = constant.ProfileConnectionState.STATE_DISCONNECTED;
myServiceUuid: string = '00001810-0000-1000-8000-00805F9B34FB';
myCharacteristicUuid: string = '00001820-0000-1000-8000-00805F9B34FB';
myFirstDescriptorUuid: string = '00002902-0000-1000-8000-00805F9B34FB'; // 2902一般用于notification或者indication
mySecondDescriptorUuid: string = '00002903-0000-1000-8000-00805F9B34FB';
// 构造BLEDescriptor
private initDescriptor(des: string, value: ArrayBuffer): ble.BLEDescriptor {
let descriptor: ble.BLEDescriptor = {
serviceUuid: this.myServiceUuid,
characteristicUuid: this.myCharacteristicUuid,
descriptorUuid: des,
descriptorValue: value
};
return descriptor;
}
// 构造BLECharacteristic
private initCharacteristic(): ble.BLECharacteristic {
let descriptors: Array<ble.BLEDescriptor> = [];
let descBuffer = new ArrayBuffer(2);
let descValue = new Uint8Array(descBuffer);
descValue[0] = 31;
descValue[1] = 32;
descriptors[0] = this.initDescriptor(this.myFirstDescriptorUuid, new ArrayBuffer(2));
descriptors[1] = this.initDescriptor(this.mySecondDescriptorUuid, descBuffer);
let charBuffer = new ArrayBuffer(2);
let charValue = new Uint8Array(charBuffer);
charValue[0] = 21;
charValue[1] = 22;
let characteristic: ble.BLECharacteristic = {
serviceUuid: this.myServiceUuid,
characteristicUuid: this.myCharacteristicUuid,
characteristicValue: charBuffer,
descriptors: descriptors
};
return characteristic;
}
// 1. 订阅连接状态变化事件
public onGattServerStateChange() {
if (!this.gattServer) {
console.error(TAG, 'no gattServer');
return;
}
try {
this.gattServer.on('connectionStateChange', (stateInfo: ble.BLEConnectionChangeState) => {
let state = '';
switch (stateInfo.state) {
case 0:
state = 'DISCONNECTED';
break;
case 1:
state = 'CONNECTING';
break;
case 2:
state = 'CONNECTED';
break;
case 3:
state = 'DISCONNECTING';
break;
default:
state = 'undefined';
break;
}
console.info(TAG, 'onGattServerStateChange: device=' + stateInfo.deviceId + ', state=' + state);
});
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 2. server端注册服务时调用
public registerServer() {
let characteristics: Array<ble.BLECharacteristic> = [];
let characteristic = this.initCharacteristic();
characteristics.push(characteristic);
let gattService: ble.GattService = {
serviceUuid: this.myServiceUuid,
isPrimary: true,
characteristics: characteristics
};
console.info(TAG, 'registerServer ' + this.myServiceUuid);
try {
this.gattServer = ble.createGattServer(); // 2.1 构造gattServer，后续的交互都需要使用该实例
this.onGattServerStateChange(); // 2.2 订阅连接状态
this.gattServer.addService(gattService);
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 3. 订阅来自gattClient的读取特征值请求时调用
public onCharacteristicRead() {
if (!this.gattServer) {
console.error(TAG, 'no gattServer');
return;
}
console.info(TAG, 'onCharacteristicRead');
try {
this.gattServer.on('characteristicRead', (charReq: ble.CharacteristicReadRequest) => {
let deviceId: string = charReq.deviceId;
let transId: number = charReq.transId;
let offset: number = charReq.offset;
console.info(TAG, 'receive characteristicRead');
let rspBuffer = new ArrayBuffer(2);
let rspValue = new Uint8Array(rspBuffer);
rspValue[0] = 21;
rspValue[1] = 22;
let serverResponse: ble.ServerResponse = {
deviceId: deviceId,
transId: transId,
status: 0, // 0表示成功
offset: offset,
value: rspBuffer
};
try {
this.gattServer.sendResponse(serverResponse);
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
});
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 4. 订阅来自gattClient的写入特征值请求时调用
public onCharacteristicWrite() {
if (!this.gattServer) {
console.error(TAG, 'no gattServer');
return;
}
console.info(TAG, 'onCharacteristicWrite');
try {
this.gattServer.on('characteristicWrite', (charReq: ble.CharacteristicWriteRequest) => {
let deviceId: string = charReq.deviceId;
let transId: number = charReq.transId;
let offset: number = charReq.offset;
console.info(TAG, 'receive characteristicWrite: needRsp=' + charReq.needRsp);
if (!charReq.needRsp) {
return;
}
let rspBuffer = new ArrayBuffer(0);
let serverResponse: ble.ServerResponse = {
deviceId: deviceId,
transId: transId,
status: 0, // 0表示成功
offset: offset,
value: rspBuffer
};
try {
this.gattServer.sendResponse(serverResponse);
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
});
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 5. 订阅来自gattClient的读取描述符请求时调用
public onDescriptorRead() {
if (!this.gattServer) {
console.error(TAG, 'no gattServer');
return;
}
console.info(TAG, 'onDescriptorRead');
try {
this.gattServer.on('descriptorRead', (desReq: ble.DescriptorReadRequest) => {
let deviceId: string = desReq.deviceId;
let transId: number = desReq.transId;
let offset: number = desReq.offset;
console.info(TAG, 'receive descriptorRead');
let rspBuffer = new ArrayBuffer(2);
let rspValue = new Uint8Array(rspBuffer);
rspValue[0] = 31;
rspValue[1] = 32;
let serverResponse: ble.ServerResponse = {
deviceId: deviceId,
transId: transId,
status: 0, // 0表示成功
offset: offset,
value: rspBuffer
};
try {
this.gattServer.sendResponse(serverResponse);
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
});
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 6. 订阅来自gattClient的写入描述符请求时调用
public onDescriptorWrite() {
if (!this.gattServer) {
console.error(TAG, 'no gattServer');
return;
}
console.info(TAG, 'onDescriptorWrite');
try {
this.gattServer.on('descriptorWrite', (desReq: ble.DescriptorWriteRequest) => {
let deviceId: string = desReq.deviceId;
let transId: number = desReq.transId;
let offset: number = desReq.offset;
console.info(TAG, 'receive descriptorWrite: needRsp=' + desReq.needRsp);
if (!desReq.needRsp) {
return;
}
let rspBuffer = new ArrayBuffer(0);
let serverResponse: ble.ServerResponse = {
deviceId: deviceId,
transId: transId,
status: 0, // 0表示成功
offset: offset,
value: rspBuffer
};
try {
this.gattServer.sendResponse(serverResponse);
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
});
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
// 7. server端删除服务，不再使用时调用
public unRegisterServer() {
if (!this.gattServer) {
console.error(TAG, 'no gattServer');
return;
}
console.info(TAG, 'unRegisterServer ' + this.myServiceUuid);
try {
this.gattServer.removeService(this.myServiceUuid); // 7.1 删除服务
this.gattServer.off('connectionStateChange', (stateInfo: ble.BLEConnectionChangeState) => { // 7.2 取消订阅连接状态
});
this.gattServer.close() // 7.3 如果不再使用此gattServer，则需要close
} catch (err) {
console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
}
let gattServerManager = new GattServerManager();
export default gattServerManager as GattServerManager;
```
8.  错误码请参见蓝牙服务子系统错误码。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/spp-development-guide-V14
爬取时间: 2025-04-28 07:11:44
来源: Huawei Developer
简介
SPP是Serial Port Profile（串口协议）的缩写，是一种蓝牙协议，用于在蓝牙设备之间建立串行通信连接。通过SPP，蓝牙设备可以像使用串口一样进行数据传输，例如传输文件、文本等。
场景介绍
主要场景有：
接口说明
完整的 JS API 说明以及实例代码请参考：SPP 接口。
具体接口说明如下表。
| 接口名 | 功能描述 |
| --- | --- |
| sppListen() | 创建一个服务端监听socket。 |
| sppAccept() | 服务端监听socket等待客户端连接。 |
| sppConnect() | 客户端向远端设备发起spp连接。 |
| sppCloseServerSocket() | 关闭服务端监听socket。 |
| sppCloseClientSocket() | 关闭客户端socket。 |
| sppWrite() | 通过socket向远端发送数据。 |
| on(type: 'sppRead') | 订阅spp读请求事件。 |
| off(type: 'sppRead') | 取消订阅spp读请求事件。 |
主要场景开发步骤
服务端向客户端写入数据
1.  import需要的socket模块。
2.  需要SystemCapability.Communication.Bluetooth.Core系统能力。
3.  开启设备蓝牙。
4.  创建服务端socket，返回serverId。
5.  服务端等待客户端连接，返回clientId。
6.  服务端向客户端写入数据。
7.  （可选）服务端订阅客户端写入的数据。
8.  注销服务端socket。
9.  注销客户端socket。
10.  示例代码：
```typescript
import { socket } from '@kit.ConnectivityKit';
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
// 创建服务器监听Socket, 返回serverId
let serverNumber = -1;
let sppOption: socket.SppOptions = {
uuid: '00001101-0000-1000-8000-00805f9b34fb',
secure: true,
type: 0
};
socket.sppListen('server1', sppOption, (code, serverSocketID) => {
if (code != null) {
console.error('sppListen error, code is ' + (code as BusinessError).code);
return;
} else {
serverNumber = serverSocketID;
console.info('sppListen success, serverNumber = ' + serverNumber);
}
});
// socket等待客户端连接，连接成功返回clientId
let clientNumber = -1;
socket.sppAccept(serverNumber, (code, clientSocketID) => {
if (code != null) {
console.error('sppAccept error, code is ' + (code as BusinessError).code);
return;
} else {
clientNumber = clientSocketID;
console.info('accept the client success');
}
})
console.info('waiting for client connection');
// 向客户端写入数据
let array = new Uint8Array(990);
array[0] = 'A'.charCodeAt(0);
array[1] = 'B'.charCodeAt(0);
array[2] = 'C'.charCodeAt(0);
array[3] = 'D'.charCodeAt(0);
socket.sppWrite(clientNumber, array.buffer);
console.info('sppWrite success');
// 订阅读请求事件
socket.on('sppRead', clientNumber, (dataBuffer: ArrayBuffer) => {
const data = new Uint8Array(dataBuffer);
if (data != null) {
console.info('sppRead success, data = ' + JSON.stringify(data));
} else {
console.error('sppRead error, data is null');
}
});
// 取消订阅读请求事件
socket.off('sppRead', clientNumber, (dataBuffer: ArrayBuffer) => {
const data = new Uint8Array(dataBuffer);
if (data != null) {
console.info('offSppRead success, data = ' + JSON.stringify(data));
} else {
console.error('offSppRead error, data is null');
}
});
// 注销服务端socket
socket.sppCloseServerSocket(serverNumber);
console.info('sppCloseServerSocket success');
// 注销客户端socket
socket.sppCloseClientSocket(clientNumber);
console.info('sppCloseClientSocket success');
```
11.  错误码请参见蓝牙服务子系统错误码。
通过socket连接对端设备
1.  import需要的socket模块。
2.  需要SystemCapability.Communication.Bluetooth.Core系统能力。
3.  开启设备蓝牙。
4.  开启ble扫描，获取对端设备mac地址。
5.  连接对端设备。
6.  示例代码：
```typescript
import { socket } from '@kit.ConnectivityKit';
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
// 开启ble扫描，获取对端设备mac地址
let deviceId = 'xx:xx:xx:xx:xx:xx';
// 连接对端设备
socket.sppConnect(deviceId, {
uuid: '00001101-0000-1000-8000-00805f9b34fb',
secure: true,
type: 0
}, (code, socketID) => {
if (code != null) {
console.error('sppConnect error, code = ' + (code as BusinessError).code);
return;
}
console.info('sppConnect success, socketId = ' + socketID);
})
```
7.  错误码请参见蓝牙服务子系统错误码。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/nfc-V14
爬取时间: 2025-04-28 07:11:57
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/nfc-tag-access-guide-V14
爬取时间: 2025-04-28 07:12:11
来源: Huawei Developer
简介
近场通信(Near Field Communication，NFC)是一种短距高频的无线电技术，在13.56MHz频率运行，通信距离一般在10厘米距离内。电子设备可以通过NFC通信技术和NFC标签通信，从标签中读取数据，或写入数据到标签。
NFC标签可能会支持一种或多种通信技术，具体技术如下：
场景介绍
电子设备通过NFC天线位置触碰NFC标签卡片，完成NFC标签卡片的读取或写入。从使用场景上，可以分成NFC标签前台读写，和NFC标签后台读写。
-  NFC标签前台读写 前台读写是指在触碰NFC标签之前，用户先在电子设备上打开特定的应用程序，用户明确想使用所打开的应用程序和NFC标签进行读写操作。用户打开应用程序在前台，并且进入应用的刷卡页面之后，电子设备触碰NFC标签，只会把读取到的卡片分发给前台应用。
-  NFC标签后台读写 后台读写是指不打开特定的NFC标签应用程序，电子设备触碰发现NFC标签后，根据NFC标签的技术类型，分发给能够处理的应用程序。如果能匹配到多个应用程序，则弹出应用选择器列举出应用列表给用户手动选择。用户选择指定的应用后，自动跳转到应用程序的NFC标签读写卡页面。
-  标签读写约束条件 不管是前台读写，还是后台读写，电子设备能够发现NFC标签的前提条件是设备必须是亮屏和解锁状态。
接口说明
NFC标签读写完整的JS API说明以及实例代码请参考：NFC标签接口。
获取不同技术类型标签对象的接口说明如下表，根据不同技术的标签对象来执行NFC标签的读写。
| 接口名 | 功能描述 |
| --- | --- |
| getNfcA(tagInfo: TagInfo): NfcATag | 获取NfcA技术类型的标签对象。 |
| getNfcB(tagInfo: TagInfo): NfcBTag | 获取NfcB技术类型的标签对象。 |
| getNfcF(tagInfo: TagInfo): NfcFTag | 获取NfcF技术类型的标签对象。 |
| getNfcV(tagInfo: TagInfo): NfcVTag | 获取NfcV技术类型的标签对象。 |
| getIsoDep(tagInfo: TagInfo): IsoDepTag | 获取IsoDep技术类型的标签对象。 |
| getNdef(tagInfo: TagInfo): NdefTag | 获取NDEF技术类型的标签对象。 |
| getMifareClassic(tagInfo: TagInfo): MifareClassicTag | 获取MifareClassic技术类型的标签对象。 |
| getMifareUltralight(tagInfo: TagInfo): MifareUltralightTag | 获取MifareUltralight技术类型的标签对象。 |
开发步骤
前台读取标签
```typescript
"abilities": [
{
"name": "EntryAbility",
"srcEntry": "./ets/entryability/EntryAbility.ts",
"description": "$string:EntryAbility_desc",
"icon": "$media:icon",
"label": "$string:EntryAbility_label",
"startWindowIcon": "$media:icon",
"startWindowBackground": "$color:start_window_background",
"exported": true,
"skills": [
{
"entities": [
"entity.system.home"
],
"actions": [
"action.system.home",
// Add the nfc tag action to filter out for this application.
"ohos.nfc.tag.action.TAG_FOUND"
]
}
]
}
],
"requestPermissions": [
{
// Add the permission for nfc tag operations.
"name": "ohos.permission.NFC_TAG",
"reason": "$string:app_name",
}
]
```
```typescript
import { tag } from '@kit.ConnectivityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { AbilityConstant, UIAbility, Want, bundleManager } from '@kit.AbilityKit';
let nfcTagElementName: bundleManager.ElementName;
let foregroundRegister: boolean;
async function readerModeCb(error : BusinessError, tagInfo : tag.TagInfo) {
if (!error) {
// 获取特定技术类型的NFC标签对象
if (tagInfo == null || tagInfo == undefined) {
hilog.error(0x0000, 'testTag', 'readerModeCb tagInfo is invalid');
return;
}
if (tagInfo.uid == null || tagInfo.uid == undefined) {
hilog.error(0x0000, 'testTag', 'readerModeCb uid is invalid');
return;
}
if (tagInfo.technology == null || tagInfo.technology == undefined || tagInfo.technology.length == 0) {
hilog.error(0x0000, 'testTag', 'readerModeCb technology is invalid');
return;
}
// 执行读写接口完成标签数据的读取或写入数据到标签
// use the IsoDep technology to access this nfc tag.
let isoDep : tag.IsoDepTag | null = null;
for (let i = 0; i < tagInfo.technology.length; i++) {
if (tagInfo.technology[i] == tag.ISO_DEP) {
try {
isoDep = tag.getIsoDep(tagInfo);
} catch (error) {
hilog.error(0x0000, 'testTag', 'readerModeCb getIsoDep error = %{public}s', JSON.stringify(error));
return;
}
}
// use other technology to access this nfc tag if necessary.
}
if (isoDep == undefined) {
hilog.error(0x0000, 'testTag', 'readerModeCb getIsoDep is invalid');
return;
}
// connect to this nfc tag using IsoDep technology.
try {
isoDep.connect();
} catch (error) {
hilog.error(0x0000, 'testTag', 'readerModeCb isoDep.connect() error = %{public}s', JSON.stringify(error));
return;
}
if (!isoDep.isConnected()) {
hilog.error(0x0000, 'testTag', 'readerModeCb isoDep.isConnected() false.');
return;
}
// transmit data to the connected tag.
let cmdData = [0x01, 0x02, 0x03, 0x04]; // please change the raw data to be correct.
try {
isoDep.transmit(cmdData).then((response : number[]) => {
hilog.info(0x0000, 'testTag', 'readerModeCb isoDep.transmit() response = %{public}s.', JSON.stringify(response));
}).catch((err : BusinessError)=> {
hilog.error(0x0000, 'testTag', 'readerModeCb isoDep.transmit() err = %{public}s.', JSON.stringify(err));
return;
});
} catch (businessError) {
hilog.error(0x0000, 'testTag', 'readerModeCb isoDep.transmit() businessError = %{public}s.', JSON.stringify(businessError));
return;
}
} else {
hilog.info(0x0000, 'testTag', 'readerModeCb readerModeCb error %{public}s', JSON.stringify(error));
}
}
export default class EntryAbility extends UIAbility {
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
// 判断设备是否支持NFC能力
if (!canIUse("SystemCapability.Communication.NFC.Core")) {
hilog.error(0x0000, 'testTag', 'nfc unavailable.');
return;
}
nfcTagElementName = {
bundleName: want.bundleName ?? '',
abilityName: want.abilityName ?? '',
moduleName: want.moduleName,
}
}
onForeground() {
// Ability has brought to foreground
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
if (nfcTagElementName != undefined) {
// 调用tag模块中前台优先的接口，使能前台应用程序优先处理所发现的NFC标签功能
let techList : number[] = [tag.NFC_A, tag.NFC_B, tag.NFC_F, tag.NFC_V];
try {
tag.on('readerMode', nfcTagElementName, techList, readerModeCb);
foregroundRegister = true;
} catch (error) {
hilog.error(0x0000, 'testTag', 'on readerMode error = %{public}s', JSON.stringify(error));
}
}
}
onBackground() {
// Ability has back to background
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
// 退出应用程序NFC标签页面时，调用tag模块退出前台优先功能
if (foregroundRegister) {
foregroundRegister = false;
try {
tag.off('readerMode', nfcTagElementName);
} catch (error) {
hilog.error(0x0000, 'testTag', 'off readerMode error = %{public}s', JSON.stringify(error));
}
}
}
}
```
后台读取标签
```typescript
"abilities": [
{
"name": "EntryAbility",
"srcEntry": "./ets/entryability/EntryAbility.ts",
"description": "$string:EntryAbility_desc",
"icon": "$media:icon",
"label": "$string:EntryAbility_label",
"startWindowIcon": "$media:icon",
"startWindowBackground": "$color:start_window_background",
"exported": true,
"skills": [
{
"entities": [
"entity.system.home"
],
"actions": [
"action.system.home",
// Add the nfc tag action to filter out for this application.
"ohos.nfc.tag.action.TAG_FOUND"
],
"uris": [
{
"type":"tag-tech/NfcA"
},
{
"type":"tag-tech/IsoDep"
}
// Add other technologies if necessary,
// such as: NfcB/NfcF/NfcV/Ndef/MifareClassic/MifareUL/NdefFormatable
]
}
]
}
],
"requestPermissions": [
{
// Add the permission for nfc tag operations.
"name": "ohos.permission.NFC_TAG",
"reason": "$string:app_name",
}
]
```
```typescript
import { tag } from '@kit.ConnectivityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
export default class EntryAbility extends UIAbility {
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
// 获取特定技术类型的NFC标签对象
let tagInfo : tag.TagInfo;
try {
tagInfo = tag.getTagInfo(want);
} catch (error) {
hilog.error(0x0000, 'testTag', 'getTagInfo error = %{public}s', JSON.stringify(error));
return;
}
if (tagInfo == null || tagInfo == undefined) {
hilog.error(0x0000, 'testTag', 'tagInfo is invalid');
return;
}
if (tagInfo.uid == null || tagInfo.uid == undefined) {
hilog.error(0x0000, 'testTag', 'uid is invalid');
return;
}
if (tagInfo.technology == null || tagInfo.technology == undefined || tagInfo.technology.length == 0) {
hilog.error(0x0000, 'testTag', 'technology is invalid');
return;
}
// 执行读写接口完成标签数据的读取或写入数据到标签
// use the IsoDep technology to access this nfc tag.
let isoDep : tag.IsoDepTag | null = null;
for (let i = 0; i < tagInfo.technology.length; i++) {
if (tagInfo.technology[i] == tag.ISO_DEP) {
try {
isoDep = tag.getIsoDep(tagInfo);
} catch (error) {
hilog.error(0x0000, 'testTag', 'getIsoDep error = %{public}s', JSON.stringify(error));
return;
}
}
// use other technology to access this nfc tag if necessary.
}
if (isoDep == undefined) {
hilog.error(0x0000, 'testTag', 'getIsoDep is invalid');
return;
}
// connect to this nfc tag using IsoDep technology.
try {
isoDep.connect();
} catch (error) {
hilog.error(0x0000, 'testTag', 'isoDep.connect() error = %{public}s', JSON.stringify(error));
return;
}
if (!isoDep.isConnected()) {
hilog.error(0x0000, 'testTag', 'isoDep.isConnected() false.');
return;
}
// transmit data to the connected tag.
let cmdData = [0x01, 0x02, 0x03, 0x04]; // please change the raw data to be correct.
try {
isoDep.transmit(cmdData).then((response : number[]) => {
hilog.info(0x0000, 'testTag', 'isoDep.transmit() response = %{public}s.', JSON.stringify(response));
}).catch((err : BusinessError)=> {
hilog.error(0x0000, 'testTag', 'isoDep.transmit() err = %{public}s.', JSON.stringify(err));
return;
});
} catch (businessError) {
hilog.error(0x0000, 'testTag', 'isoDep.transmit() businessError = %{public}s.', JSON.stringify(businessError));
return;
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/nfc-hce-guide-V14
爬取时间: 2025-04-28 07:12:24
来源: Huawei Developer
简介
近场通信(Near Field Communication，NFC)是一种短距高频的无线电技术，在13.56MHz频率运行，通信距离一般在10厘米距离内。HCE(Host Card Emulation)，称为基于主机的卡模拟，表示不依赖安全单元芯片，电子设备上的应用程序模拟NFC卡片和NFC读卡器通信，实现NFC刷卡业务。
场景介绍
应用程序模拟NFC卡片，和NFC读卡器通信完成NFC刷卡业务。从使用场景上，可以分成HCE应用前台刷卡，和HCE应用后台刷卡。
-  HCE应用前台刷卡 前台刷卡是指在触碰NFC读卡器之前，用户先在电子设备上打开特定的应用程序，用户明确想使用所打开的应用程序和NFC读卡器进行刷卡操作。用户打开应用程序在前台，并且进入应用的刷卡页面之后，电子设备触碰NFC读卡器，只会把刷卡交易数据分发给前台应用。
-  HCE应用后台刷卡 后台刷卡是指不打开特定的HCE应用程序，电子设备触碰NFC读卡器后，根据NFC读卡器选择的应用ID（AID）匹配到HCE应用程序，并自动和匹配的HCE应用程序通信完成刷卡交易。如果匹配到多个HCE应用程序时，说明存在冲突，需要用户打开指定的应用才能完成刷卡。
-  HCE应用刷卡的约束条件 1、不管是HCE应用前台还是后台刷卡，能够完成HCE应用程序NFC刷卡的条件是电子设备需要亮屏解锁。 2、module.json5文件中需要声明nfc卡模拟权限，具体见示例。 3、前台应用时需要调用start和stop注册和去注册AID，具体见示例。
接口说明
NFC卡模拟完整的JS API说明以及实例代码请参考：NFC卡模拟接口。
完成HCE卡模拟功能，可能使用到下面的接口。
| 接口名 | 功能描述 |
| --- | --- |
| start(elementName: ElementName, aidList: string[]): void | 启动HCE业务功能。包括设置当前应用为前台优先，动态注册AID列表。 |
| stop(elementName: ElementName): void | 停止HCE业务功能。包括取消APDU数据接收的订阅，退出当前应用前台优先，释放动态注册的AID列表。 |
| on(type: 'hceCmd', callback: AsyncCallback<number[]>): void | 订阅回调，用于接收对端读卡设备发送的APDU数据。 |
| transmit(response: number[]): Promise<void> | 发送APDU数据到对端读卡设备。 |
开发步骤
HCE应用前台刷卡
```typescript
"abilities": [
{
"name": "EntryAbility",
"srcEntry": "./ets/entryability/EntryAbility.ts",
"description": "$string:EntryAbility_desc",
"icon": "$media:icon",
"label": "$string:EntryAbility_label",
"startWindowIcon": "$media:icon",
"startWindowBackground": "$color:start_window_background",
"exported": true,
"skills": [
{
"entities": [
"entity.system.home"
],
"actions": [
"action.system.home",
// Add the nfc card emulation action to filter out for this application.
"ohos.nfc.cardemulation.action.HOST_APDU_SERVICE"
]
}
]
}
],
"requestPermissions": [
{
// Add the permission for nfc card emulation.
"name": "ohos.permission.NFC_CARD_EMULATION",
"reason": "$string:app_name",
}
]
```
```typescript
import { cardEmulation } from '@kit.ConnectivityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { AsyncCallback } from '@kit.BasicServicesKit';
import { AbilityConstant, UIAbility, Want, bundleManager } from '@kit.AbilityKit';
let hceElementName: bundleManager.ElementName;
let hceService: cardEmulation.HceService;
const hceCommandCb : AsyncCallback<number[]> = (error : BusinessError, hceCommand : number[]) => {
if (!error) {
if (hceCommand == null || hceCommand == undefined) {
hilog.error(0x0000, 'testTag', 'hceCommandCb has invalid hceCommand.');
return;
}
// check the command, then transmit the response.
hilog.info(0x0000, 'testTag', 'hceCommand = %{public}s', JSON.stringify(hceCommand));
let responseData = [0x90, 0x00]; // change the response depend on different received command.
hceService.transmit(responseData).then(() => {
hilog.info(0x0000, 'testTag', 'hceService transmit Promise success.');
}).catch((err: BusinessError) => {
hilog.error(0x0000, 'testTag', 'hceService transmit Promise error = %{public}s', JSON.stringify(err));
});
} else {
hilog.error(0x0000, 'testTag', 'hceCommandCb error %{public}s', JSON.stringify(error));
}
}
export default class EntryAbility extends UIAbility {
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
// 判断设备是否支持NFC能力和HCE能力
if (!canIUse("SystemCapability.Communication.NFC.Core")) {
hilog.error(0x0000, 'testTag', 'nfc unavailable.');
return;
}
if (!cardEmulation.hasHceCapability()) {
hilog.error(0x0000, 'testTag', 'hce unavailable.');
return;
}
hceElementName = {
bundleName: want.bundleName ?? '',
abilityName: want.abilityName ?? '',
moduleName: want.moduleName,
}
hceService = new cardEmulation.HceService();
}
onForeground() {
// Ability has brought to foreground
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
if (hceElementName != undefined) {
try {
// 调用接口使能前台HCE应用程序优先处理NFC刷卡功能
let aidList = ["A0000000031010", "A0000000031011"]; // change aid tobe correct.
hceService.start(hceElementName, aidList);
// 订阅HCE APDU数据的接收
hceService.on('hceCmd', hceCommandCb);
} catch (error) {
hilog.error(0x0000, 'testTag', 'hceService.start error = %{public}s', JSON.stringify(error));
}
}
}
onBackground() {
// Ability has back to background
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
// 退出应用程序NFC标签页面时，调用tag模块退出前台优先功能
if (hceElementName != undefined) {
try {
hceService.stop(hceElementName);
} catch (error) {
hilog.error(0x0000, 'testTag', 'hceService.stop error = %{public}s', JSON.stringify(error));
}
}
}
}
```
HCE应用后台刷卡
```typescript
"abilities": [
{
"name": "EntryAbility",
"srcEntry": "./ets/entryability/EntryAbility.ts",
"description": "$string:EntryAbility_desc",
"icon": "$media:icon",
"label": "$string:EntryAbility_label",
"startWindowIcon": "$media:icon",
"startWindowBackground": "$color:start_window_background",
"exported": true,
"skills": [
{
"entities": [
"entity.system.home"
],
"actions": [
"action.system.home",
// Add the nfc card emulation action to filter out for this application.
"ohos.nfc.cardemulation.action.HOST_APDU_SERVICE"
]
}
],
"metadata": [
{
"name": "payment-aid",
"value": "A0000000031010" // change it tobe correct
},
{
"name": "other-aid",
"value": "A0000000031011" // change it tobe correct
}
]
}
],
"requestPermissions": [
{
// Add the permission for nfc card emulation.
"name": "ohos.permission.NFC_CARD_EMULATION",
"reason": "$string:app_name",
}
]
```
```typescript
import { cardEmulation } from '@kit.ConnectivityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { AsyncCallback } from '@kit.BasicServicesKit';
import { AbilityConstant, UIAbility, Want, bundleManager } from '@kit.AbilityKit';
let hceElementName : bundleManager.ElementName;
let hceService: cardEmulation.HceService;
const hceCommandCb : AsyncCallback<number[]> = (error : BusinessError, hceCommand : number[]) => {
if (!error) {
if (hceCommand == null || hceCommand == undefined) {
hilog.error(0x0000, 'testTag', 'hceCommandCb has invalid hceCommand.');
return;
}
// check the command, then transmit the response.
hilog.info(0x0000, 'testTag', 'hceCommand = %{public}s', JSON.stringify(hceCommand));
let responseData = [0x90, 0x00]; // change the response depend on different received command.
hceService.transmit(responseData).then(() => {
hilog.info(0x0000, 'testTag', 'hceService transmit Promise success.');
}).catch((err: BusinessError) => {
hilog.error(0x0000, 'testTag', 'hceService transmit Promise error = %{public}s', JSON.stringify(err));
});
} else {
hilog.error(0x0000, 'testTag', 'hceCommandCb error %{public}s', JSON.stringify(error));
}
}
export default class EntryAbility extends UIAbility {
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
// 判断设备是否支持NFC能力和HCE能力
if (!canIUse("SystemCapability.Communication.NFC.Core")) {
hilog.error(0x0000, 'testTag', 'nfc unavailable.');
return;
}
if (!cardEmulation.hasHceCapability()) {
hilog.error(0x0000, 'testTag', 'hce unavailable.');
return;
}
hceElementName = {
bundleName: want.bundleName ?? '',
abilityName: want.abilityName ?? '',
moduleName: want.moduleName,
}
hceService = new cardEmulation.HceService();
hceService.on('hceCmd', hceCommandCb);
}
onForeground() {
// Ability has brought to foreground
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
}
onDestroy() {
// Ability has back to destroy
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
// 退出应用程序NFC标签页面时，调用tag模块退出前台优先功能
if (hceElementName != undefined) {
try {
hceService.stop(hceElementName);
} catch (error) {
hilog.error(0x0000, 'testTag', 'hceService.stop error = %{public}s', JSON.stringify(error));
}
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/nfc-se-access-guide-V14
爬取时间: 2025-04-28 07:12:37
来源: Huawei Developer
简介
安全单元（SecureElement，简称SE），电子设备上可能存在一个或多个安全单元，比如有eSE(Embedded SE)和SIM卡。能够充当安全单元的SIM卡，要求具备NFC功能。
场景介绍
应用程序可以通过接口访问安全单元，比如往安全单元里面写入数据，实现在电子设备上模拟一张NFC卡片的目的。该卡片数据可能存储在eSE安全单元，或在SIM卡安全单元上。安全单元上一般会预置有访问控制规则，应用程序需要具备对应的权限，也就是通过安全单元的访问控制权限校验之后，才能正常访问安全单元。
接口说明
完整的JS API说明以及实例代码请参考：安全单元接口。
实现安全单元的访问，可能使用到下面的接口。
| 接口名 | 功能描述 |
| --- | --- |
| createService(): Promise<SEService> | 建立一个可用于连接到系统中所有可用SE的新连接。 |
| getReaders(): Reader[] | 返回可用SE Reader的数组，包含该设备上支持的所有的安全单元。 |
| openSession(): Session | 在SE Reader实例上创建连接会话，返回Session实例。 |
| openLogicalChannel(aid: number[]): Promise<Channel> | 打开逻辑通道，返回逻辑Channel实例对象。 |
| transmit(command: number[]): Promise<number[]> | 向SE发送APDU数据 |
| close(): void | 关闭Channel。 |
主要场景开发步骤
应用程序访问安全单元
```typescript
import { omapi } from '@kit.ConnectivityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
let seService : omapi.SEService;
let seReaders : omapi.Reader[];
let seSession : omapi.Session;
let seChannel : omapi.Channel;
let aidArray : number[] = [0xA0, 0x00, 0x00, 0x00, 0x03, 0x10, 0x10];
let p2 : number = 0x00;
export default class EntryAbility extends UIAbility {
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
// 判断设备是否支持安全单元能力
if (!canIUse("SystemCapability.Communication.SecureElement")) {
hilog.error(0x0000, 'testTag', 'secure element unavailable.');
return;
}
hilog.info(0x0000, 'testTag', 'secure element available.');
this.omaTest();
}
private async omaTest () {
// get the service
await omapi.createService().then((data) => {
if (data == undefined || !data.isConnected()) {
hilog.error(0x0000, 'testTag', 'secure element service disconnected.');
return;
}
seService = data;
hilog.info(0x0000, 'testTag', 'secure element service connected.');
}).catch((error: BusinessError) => {
hilog.error(0x0000, 'testTag', 'createService error %{public}s', JSON.stringify(error));
return;
});
// get readers
try {
seReaders = seService.getReaders();
} catch (error) {
hilog.error(0x0000, 'testTag', 'getReaders error %{public}s', JSON.stringify(error));
}
if (seReaders == undefined || seReaders.length == 0) {
hilog.error(0x0000, 'testTag', 'no valid reader found.');
seService.shutdown();
return;
}
let reader: (omapi.Reader | undefined);
for (let i = 0; i < seReaders.length; ++i) {
let r = seReaders[i];
if (r.getName().includes("SIM")) {
reader = r;
break;
}
}
if (reader == undefined) {
hilog.error(0x0000, 'testTag', 'no valid sim reader.');
return;
}
hilog.info(0x0000, 'testTag', 'reader is %{public}s', reader?.getName());
// get session
try {
seSession = reader?.openSession() as omapi.Session;
} catch (error) {
hilog.error(0x0000, 'testTag', 'openSession error %{public}s', JSON.stringify(error));
}
if (seSession == undefined) {
hilog.error(0x0000, 'testTag', 'seSession invalid.');
seService.shutdown();
return;
}
// get channel
try {
// change the aid value for open logical channel.
seChannel = await seSession.openLogicalChannel(aidArray, p2);
} catch (exception) {
hilog.error(0x0000, 'testTag', 'openLogicalChannel exception %{public}s', JSON.stringify(exception));
}
if (seChannel == undefined) {
hilog.error(0x0000, 'testTag', 'seChannel invalid.');
return;
}
// transmit data
let cmdData = [0x01, 0x02, 0x03, 0x04]; // please change the raw data to be correct.
try {
let response: number[] = await seChannel.transmit(cmdData)
hilog.info(0x0000, 'testTag', 'seChannel.transmit() response = %{public}s.', JSON.stringify(response));
} catch (exception) {
hilog.error(0x0000, 'testTag', 'seChannel.transmit() exception = %{public}s.', JSON.stringify(exception));
}
// close channel. must make sure the channel is closed at last.
try {
seChannel.close();
} catch (exception) {
hilog.error(0x0000, 'testTag', 'seChannel.close() exception = %{public}s.', JSON.stringify(exception));
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/wlan-V14
爬取时间: 2025-04-28 07:12:50
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/wlan-overview-V14
爬取时间: 2025-04-28 07:13:04
来源: Huawei Developer
概述
无线局域网（Wireless Local Area Networks，WLAN），是通过无线电、红外光信号或者其他技术发送和接收数据的局域网，用户可以通过WLAN实现结点之间无物理连接的网络通讯。常用于用户携带可移动终端的办公、公众环境中。
Wi-Fi（Wireless Fidelity），是一种基于无线电波的通信技术，用于设备之间传输数据，使得用户可以无需使用有线连接即可访问互联网和共享数据。
WLAN系统为用户提供接入WLAN网络功能（STA模式）、点对点的数据传输功能（P2P模式）和热点分享功能（AP模式），让应用可以通过WLAN和其他设备互联互通。
实现原理
WLAN的实现原理是通过无线电磁波在空间中传输信息，当前使用的频段是2.4GHz或者5GHz频段。WLAN网络架构分有线侧和无线侧两部分，有线侧是指AP上行到Internet的网络使用以太网协议，无线侧是指STA到AP之间的网络，使用802.11协议。
模式介绍
-  STA模式（工作站模式）：STA模式即工作站模式，可以理解为某网络中的一个工作站即客户端。当某设备具备该功能时，它可以连到另外的一个路由网络中，如家用路由器，通常用于提供网络的数据上行服务。详情请参考@ohos.wifiManager API参考。
-  P2P模式（Wi-Fi直连）：P2P模式也为Wi-Fi Direct；Wi-Fi Direct 是一种点对点连接技术，它可以在两台 STA 之间直接建立 TCP/IP 链接，并不需要AP的参与；其中一台STA会起到传统意义上的AP的作用，称为Group Owner(GO),另外一台station则称为Group Client(GC)，像连接AP一样连接到GO。详情请参考@ohos.wifiManager API参考。
-  AP模式（热点模式）：AP模式为加入无线局域网的成员设备（即客户端）提供下行数据业务，它提供以无线方式组建无线局域网WLAN，相当于WLAN的中心设备。详情请参考@ohos.wifiManager API参考。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/p2p-development-guide-V14
爬取时间: 2025-04-28 07:13:17
来源: Huawei Developer
简介
P2P模式，主要提供了wlan设备的一种点对点连接技术，它可以在两台 STA 之间直接建立 TCP/IP 链接，并不需要AP的参与。
场景介绍
主要场景有：
接口说明
完整的 JS API 说明以及实例代码请参考：P2P 接口。
具体接口说明如下表。
| 接口名 | 功能描述 |
| --- | --- |
| createGroup() | 创建群组。 |
| removeGroup() | 删除群组。 |
| startDiscoverDevices() | 开始发现设备。 |
| getP2pPeerDevices() | 获取P2P对端设备列表信息。 |
| p2pConnect() | 执行P2P连接。 |
| getP2pLinkedInfo() | 获取P2P连接信息。 |
| on(type: 'p2pPersistentGroupChange') | 注册P2P永久组状态改变事件。 |
| off(type: 'p2pPersistentGroupChange') | 取消注册P2P永久组状态改变事件。 |
| on(type: 'p2pPeerDeviceChange') | 注册P2P对端设备状态改变事件。 |
| off(type: 'p2pPeerDeviceChange') | 取消注册P2P对端设备状态改变事件。 |
| on(type: 'p2pConnectionChange') | 注册P2P连接状态改变事件。 |
| off(type: 'p2pConnectionChange') | 取消注册P2P连接状态改变事件。 |
主要场景开发步骤
创建/删除P2P群组
```typescript
import { wifiManager } from '@kit.ConnectivityKit';
// 创建群组，将当前设备当做GO使用时，需要该步骤
// netId：-1表示创建临时组，下次和已连接过的设备连接，需要重新进行GO协商，以及wps秘钥协商;
//        -2表示创建永久组，下次和已连接过的设备连接，不需要重新进行GO和wps秘钥协商;
let recvP2pPersistentGroupChangeFunc = () => {
console.info("p2p persistent group change receive event");
// 永久组创建好后需要处理的业务
}
// 创建永久组，需要注册永久组状态改变事件回调
wifiManager.on("p2pPersistentGroupChange", recvP2pPersistentGroupChangeFunc);
try {
let config:wifiManager.WifiP2PConfig = {
deviceAddress: "00:11:22:33:44:55",
deviceAddressType: 1,
netId: -2,
passphrase: "12345678",
groupName: "testGroup",
goBand: 0
}
wifiManager.createGroup(config);
}catch(error){
console.error("failed:" + JSON.stringify(error));
}
// 删除群组
try {
wifiManager.removeGroup();
}catch(error){
console.error("failed:" + JSON.stringify(error));
}
```
建立P2P连接
```typescript
import { wifiManager } from '@kit.ConnectivityKit';
let recvP2pConnectionChangeFunc = (result:wifiManager.WifiP2pLinkedInfo) => {
console.info("p2p connection change receive event: " + JSON.stringify(result));
wifiManager.getP2pLinkedInfo((err, data) => {
if (err) {
console.error('failed to get getP2pLinkedInfo: ' + JSON.stringify(err));
return;
}
console.info("get getP2pLinkedInfo: " + JSON.stringify(data));
// 添加P2P连接成功或者失败场景的业务处理
});
}
// P2P连接完成，会调用"p2pConnectionChange"事件回调
wifiManager.on("p2pConnectionChange", recvP2pConnectionChangeFunc);
let recvP2pPeerDeviceChangeFunc = (result:wifiManager.WifiP2pDevice[]) => {
console.info("p2p peer device change receive event: " + JSON.stringify(result));
wifiManager.getP2pPeerDevices((err, data) => {
if (err) {
console.error('failed to get peer devices: ' + JSON.stringify(err));
return;
}
console.info("get peer devices: " + JSON.stringify(data));
let len = data.length;
for (let i = 0; i < len; ++i) {
// 选择符合条件的对端P2P设备
if (data[i].deviceName === "my_test_device") {
console.info("p2p connect to test device: " + data[i].deviceAddress);
let config:wifiManager.WifiP2PConfig = {
deviceAddress:data[i].deviceAddress,
deviceAddressType: 1,
netId:-2,
passphrase:"",
groupName:"",
goBand:0,
}
// 执行P2P连接，作为GO时不能主动发起连接
wifiManager.p2pConnect(config);
}
}
});
}
// P2P扫描结果上报时会调用"p2pPeerDeviceChange"事件回调
wifiManager.on("p2pPeerDeviceChange", recvP2pPeerDeviceChangeFunc);
setTimeout(() => {wifiManager.off("p2pConnectionChange", recvP2pConnectionChangeFunc);}, 125 * 1000);
setTimeout(() =>  {wifiManager.off("p2pPeerDeviceChange", recvP2pPeerDeviceChangeFunc);}, 125 * 1000);
// 开始发现P2P设备，即，开始P2P扫描
console.info("start discover devices -> " + wifiManager.startDiscoverDevices());
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/distributed-service-kit-V14
爬取时间: 2025-04-28 07:13:30
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/distributedservice-kit-intro-V14
爬取时间: 2025-04-28 07:13:43
来源: Huawei Developer
Distributed Service Kit（分布式管理服务）实现了分布式设备管理、分布式硬件管理、分布式键鼠穿越等能力。
应用开发者可以通过分布式设备管理进行周边设备的发现、认证、信息查询、状态监听等，该能力是分布式业务的入口功能，即只有完成认证后的设备之间才可以进行分布式业务。
运作机制
分布式设备管理能力作为系统为应用提供的一种基础服务，需要应用在所使用的业务场景，向系统主动发起请求，完成设备间的发现、认证、查询、监听等功能。
约束与限制
使用分布式设备管理，需要用户进行相关权限的申请。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicemanager-guidelines-V14
爬取时间: 2025-04-28 07:13:57
来源: Huawei Developer
分布式设备管理简介
随着用户不同种类的终端设备数量不断增多，将不同设备作为本端设备能力的扩展，使设备之间协同合作完成各种复杂场景即为设备的分布式业务。
分布式设备管理是分布式业务入口，在分布式业务中对周边可信和非可信设备进行统一管理。
分布式设备管理提供如下四大功能：
-  发现 发现周围终端设备并上报。周围设备需要连接同局域网或者同时打开蓝牙，可以根据设备类型、距离、设备是否可信等进行筛选。
-  绑定 不同设备协同合作完成分布式业务的前提是设备间可信，对于周边发现的不可信设备，可通过绑定使彼此建立可信关系，提供pin码、碰、扫、靠等设备认证框架，支持对接各种认证交互接口。
-  查询 查询功能包含：查询本机设备信息、查询周围的在线的可信设备、查询可信设备信息。
-  监听 监听设备上、下线。设备上线表示设备间已经可信，业务可以发起分布式操作；设备下线表示分布业务不可用。
运作机制
设备管理作为分布式业务入口，需要应用在所使用的业务场景，向发现设备主动发起绑定建立可信关系；业务结束后由业务自主判断是否解除绑定关系，设备间可信关系的解除由业务自己控制。
约束与限制
使用设备管理能力，需要用户确认不同设备已连接同一局域网或者蓝牙开关已开启，否则该能力不可用。
设备信息属于用户敏感数据，所以即使用户已连接同一局域网或者蓝牙开关已开启，应用在获取设备位置前仍需向用户申请数据同步权限。在用户确认允许后，系统才会向应用提供设备管理能力。
申请分布式数据同步权限开发指导
场景概述
应用在使用分布式设备管理系统能力前，需要检查是否已经获取用户授权访问分布式数据同步信息。如未获得授权，可以向用户申请需要的分布式数据同步权限。
ohos.permission.DISTRIBUTED_DATASYNC：分布式数据同步权限
使用设备管理能力，必须申请权限，并且获得用户授权。
开发步骤
适用于Stage应用模型。
1.  在module.json5配置文件中配置分布式数据同步权限ohos.permission.DISTRIBUTED_DATASYNC。
```typescript
{
"module" : {
"requestPermissions":[
{
"name" : "ohos.permission.DISTRIBUTED_DATASYNC",
"reason": "$string:distributed_permission",
"usedScene": {
"abilities": [
"MainAbility"
],
"when": "inuse"
}
}
]
}
}
```
2.  导入common和abilityAccessCtrl模块，用于获取权限申请的能力。
```typescript
import { common, abilityAccessCtrl } from '@kit.AbilityKit';
```
3.  分布式数据同步权限的授权方式为user_grant，因此需要调用requestPermissionsFromUser接口，以动态弹窗的方式向用户申请授权。
```typescript
let context = getContext(this) as common.UIAbilityContext;
let atManager = abilityAccessCtrl.createAtManager();
try {
atManager.requestPermissionsFromUser(context, ['ohos.permission.DISTRIBUTED_DATASYNC']).then((data) => {
console.log('data: ' + JSON.stringify(data));
}).catch((err: object) => {
console.log('err: ' + JSON.stringify(err));
})
} catch (err) {
console.log('catch err->' + JSON.stringify(err));
}
```
设备发现开发指导
场景概述
开发者可以调用DeviceManager设备发现相关接口，获取周边可用的设备。
接口说明
startDiscovering(discoverParam: {[key: string]: Object;} , filterOptions?: {[key: string]: Object;} ): void;
发现周边同局域网或者开启蓝牙的设备。详细信息参见：startDiscovering。
开发步骤
1.  申请分布式数据同步权限。
2.  导入distributedDeviceManager模块，所有与设备管理相关的功能API，都是通过该模块提供的。
```typescript
import { distributedDeviceManager } from '@kit.DistributedServiceKit';
```
3.  导入BusinessError模块，用于获取distributedDeviceManager模块相关接口抛出的错误码。
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
```
4.  创建设备管理实例，设备管理实例是分布式设备管理方法的调用入口，并注册发现设备的回调。
```typescript
try {
let dmInstance = distributedDeviceManager.createDeviceManager('ohos.samples.jsHelloWorld');
dmInstance.on('discoverSuccess', data => console.log('discoverSuccess on:' + JSON.stringify(data)));
dmInstance.on('discoverFailure', data => console.log('discoverFailure on:' + JSON.stringify(data)));
} catch(err) {
let e: BusinessError = err as BusinessError;
console.error('createDeviceManager errCode:' + e.code + ',errMessage:' + e.message);
}
```
5.  发现周边设备。发现状态持续两分钟，超过两分钟，会停止发现，最大发现数量99个。
```typescript
interface DiscoverParam {
discoverTargetType: number;
}
interface FilterOptions {
availableStatus: number;
discoverDistance: number;
authenticationStatus: number;
authorizationType: number;
}
let discoverParam: Record<string, number> = {
'discoverTargetType': 1
};
let filterOptions: Record<string, number> = {
'availableStatus': 0
};
try {
dmInstance.startDiscovering(discoverParam, filterOptions);
} catch (err) {
let e: BusinessError = err as BusinessError;
console.error('startDiscovering errCode:' + e.code + ',errMessage:' + e.message);
}
```
设备绑定开发指导
场景概述
开发者发现周边不可信设备后，通过绑定接口建立可信关系。
接口说明
bindTarget(deviceId: string, bindParam: {[key: string]: Object;} , callback: AsyncCallback<{deviceId: string;}>): void;
设备绑定。详细信息参见：bindTarget。
开发步骤
1.  申请分布式数据同步权限。
2.  发现周边不可信设备。
3.  选择不可信设备id，发起设备绑定。
```typescript
class Data {
deviceId: string = '';
}
let deviceId = 'XXXXXXXX';
let bindParam: Record<string, string | number> = {
'bindType': 1,
'targetPkgName': 'xxxx',
'appName': 'xxxx',
'appOperation': 'xxxx',
'customDescription': 'xxxx'
};
try {
dmInstance.bindTarget(deviceId, bindParam, (err: BusinessError, data: Data) => {
if (err) {
console.error('bindTarget errCode:' + err.code + ',errMessage:' + err.message);
return;
}
console.info('bindTarget result:' + JSON.stringify(data));
});
} catch (err) {
let e: BusinessError = err as BusinessError;
console.error('bindTarget errCode:' + e.code + ',errMessage:' + e.message);
}
```
设备信息查询开发指导
场景概述
设备与周边设备建立可信关系后，通过设备信息查询接口可以获取所有上线并且可信的设备。
接口说明
getAvailableDeviceListSync(): Array<DeviceBasicInfo>;
设备信息查询。详细信息参见：getAvailableDeviceListSync。
开发步骤
1.  申请分布式数据同步权限。
2.  发现周边不可信设备。
3.  建立设备间的可信关系。
4.  查询周围上线并且可信的设备。
```typescript
try {
let deviceInfoList: Array<distributedDeviceManager.DeviceBasicInfo> = dmInstance.getAvailableDeviceListSync();
} catch (err) {
let e: BusinessError = err as BusinessError;
console.error('getAvailableDeviceListSync errCode:' + e.code + ',errMessage:' + e.message);
}
```
设备上下线监听开发指导
场景概述
周边可信设备可用后会给业务报上线通知，当设备不可用时会给业务报下线通知。
接口说明
on(type: 'deviceStateChange', callback: Callback<{ action: DeviceStateChange; device: DeviceBasicInfo; }>): void;
设备上下线监听。详细信息参见：on('deviceStateChange')。
开发步骤
1.  申请分布式数据同步权限。
2.  导入distributedDeviceManager模块，所有与设备管理相关的功能API，都是通过该模块提供的。
```typescript
import { distributedDeviceManager } from '@kit.DistributedServiceKit';
```
3.  导入BusinessError模块，用于获取distributedDeviceManager模块相关接口抛出的错误码。
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
```
4.  创建设备管理实例，设备管理实例是分布式设备管理方法的调用入口，并注册设备上下线回调。
```typescript
try {
let dmInstance = distributedDeviceManager.createDeviceManager('ohos.samples.jsHelloWorld');
dmInstance.on('deviceStateChange', data => console.log('deviceStateChange on:' + JSON.stringify(data)));
} catch(err) {
let e: BusinessError = err as BusinessError;
console.error('createDeviceManager errCode:' + e.code + ',errMessage:' + e.message);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/nearlink-kit-guide-V14
爬取时间: 2025-04-28 07:14:10
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/nearlink-introduction-V14
爬取时间: 2025-04-28 07:14:23
来源: Huawei Developer
NearLink Kit（星闪服务）提供一种低功耗、高速率的短距离通信服务，支持星闪设备之间的连接、数据交互。
中心设备可以通过扫描发现外围设备，并发起连接。外围设备可以通过发送广播的方式被中心设备发现，和中心设备连接之后可以进行相应的数据传输。
可能的使用场景有：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/nearlink-preparations-V14
爬取时间: 2025-04-28 07:14:36
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/nearlink-getstate-V14
爬取时间: 2025-04-28 07:14:50
来源: Huawei Developer
场景介绍
使用星闪前需要在设置应用里手动打开星闪。可以通过主动查询或订阅通知方式获取星闪状态，星闪状态变化为STATE_ON时可以进行相应的业务流程。
接口说明
提供2种获取星闪开关状态的方式，主动查询和订阅状态变化。
| 接口名 | 描述 |
| --- | --- |
| getState(): NearlinkState | 主动查询星闪开关状态。 |
| on(type: 'stateChange', callback: Callback<NearlinkState>): void | 订阅星闪开关状态变化事件。 |
| off(type: 'stateChange', callback?: Callback<NearlinkState>): void | 取消订阅星闪开关状态变化事件。 |
接口名
描述
getState(): NearlinkState
主动查询星闪开关状态。
on(type: 'stateChange', callback: Callback<NearlinkState>): void
订阅星闪开关状态变化事件。
off(type: 'stateChange', callback?: Callback<NearlinkState>): void
取消订阅星闪开关状态变化事件。
开发步骤
可以在设备“设置 > 多设备协同 > 星闪”路径下，打开或关闭星闪，触发开关状态的变化。
1.
2.
3.
4.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/nearlink-send-advertising-V14
爬取时间: 2025-04-28 07:15:03
来源: Huawei Developer
场景介绍
发送星闪广播，广播数据可以被支持星闪能力的中心设备扫描到。
接口说明
| 接口名 | 描述 |
| --- | --- |
| startAdvertising(advertisingParams: AdvertisingParams): Promise<number> | 启动星闪广播。 |
| stopAdvertising(advertisingId: number): Promise<void> | 停止星闪广播。 |
| on(type: 'advertisingStateChange', callback: Callback<AdvertisingStateChangeInfo>): void | 订阅星闪广播状态变化事件。 |
| off(type: 'advertisingStateChange', callback?: Callback<AdvertisingStateChangeInfo>): void | 取消订阅星闪广播状态变化事件。 |
接口名
描述
startAdvertising(advertisingParams: AdvertisingParams): Promise<number>
启动星闪广播。
stopAdvertising(advertisingId: number): Promise<void>
停止星闪广播。
on(type: 'advertisingStateChange', callback: Callback<AdvertisingStateChangeInfo>): void
订阅星闪广播状态变化事件。
off(type: 'advertisingStateChange', callback?: Callback<AdvertisingStateChangeInfo>): void
取消订阅星闪广播状态变化事件。
开发步骤
1.
2.
3.
4.
```typescript
let advId = -1;
try {
advertising.startAdvertising(advertisingParams).then((advertisingId:number) => {
advId = advertisingId;
console.info('advertising id:'+ JSON.stringify(advId));
});
} catch (err) {
console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
```
5.
6.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/nearlink-start-scan-V14
爬取时间: 2025-04-28 07:15:16
来源: Huawei Developer
场景介绍
发起星闪扫描，可以扫描到正在发送星闪广播的外围设备。
接口说明
| 接口名 | 描述 |
| --- | --- |
| startScan(filters: Array<ScanFilters>, options?: ScanOptions): Promise<void> | 启动星闪扫描。 |
| stopScan(): Promise<void> | 停止星闪扫描。 |
| on(type: 'deviceFound', callback: Callback<Array<ScanResults>>): void | 订阅扫描结果。 |
| off(type: 'deviceFound', callback?: Callback<Array<ScanResults>>): void | 取消订阅扫描结果。 |
接口名
描述
startScan(filters: Array<ScanFilters>, options?: ScanOptions): Promise<void>
启动星闪扫描。
stopScan(): Promise<void>
停止星闪扫描。
on(type: 'deviceFound', callback: Callback<Array<ScanResults>>): void
订阅扫描结果。
off(type: 'deviceFound', callback?: Callback<Array<ScanResults>>): void
取消订阅扫描结果。
开发步骤
1.
2.
3.
4.
5.
6.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/nearlink-ssap-connect-V14
爬取时间: 2025-04-28 07:15:29
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/nearlink-ssap-server-connect-V14
爬取时间: 2025-04-28 07:15:43
来源: Huawei Developer
提供SSAP（SparkLink Service Access Protocol）服务端相关的连接、数据传输和服务管理功能。
场景介绍
支持应用基于Nearlink技术进行数据传输，设备作为服务端，客户端可连接该服务端进行数据传输。
接口说明
| 接口名 | 描述 |
| --- | --- |
| createServer(): Server | 创建ssap服务端实例。 |
| addService(service: Service): void | 服务端添加服务。 |
| on(type: 'connectionStateChange', callback: Callback<ConnectionChangeState>): void | 订阅连接状态变化事件。 |
| on(type: 'propertyRead', callback: Callback<PropertyReadRequest>): void | 订阅客户端的读请求事件。 |
| sendResponse(response: ServerResponse): void | 回复客户端读/写请求。 |
| notifyPropertyChanged(address: string, property: Property): Promise<void> | 通知客户端property值更新。 |
接口名
描述
createServer(): Server
创建ssap服务端实例。
addService(service: Service): void
服务端添加服务。
on(type: 'connectionStateChange', callback: Callback<ConnectionChangeState>): void
订阅连接状态变化事件。
on(type: 'propertyRead', callback: Callback<PropertyReadRequest>): void
订阅客户端的读请求事件。
sendResponse(response: ServerResponse): void
回复客户端读/写请求。
notifyPropertyChanged(address: string, property: Property): Promise<void>
通知客户端property值更新。
开发步骤
1.
2.
3.
4.
5.
6.
7.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/nearlink-ssap-client-connect-V14
爬取时间: 2025-04-28 07:15:57
来源: Huawei Developer
提供SSAP（SparkLink Service Access Protocol）客户端相关的连接、数据传输和服务操作功能。
场景介绍
提供设备作为客户端的能力，客户端可连接服务端进行数据传输。
接口说明
| 接口名 | 描述 |
| --- | --- |
| createClient(address: string): Client | 创建ssap客户端实例。 |
| connect(): Promise<void> | 向服务端发起连接。 |
| getServices(): Promise<Array<Service>> | 获取服务端支持的服务列表。 |
| readProperty(property: Property): Promise<Property> | 读取服务端property。 |
| writeProperty(property: Property, writeType: PropertyWriteType): Promise<void> | 写入服务端property。 |
| setPropertyNotification(property: Property, enable: boolean): Promise<void> | 启用/禁用某个property变化的通知。 |
| on(type: 'propertyChange', callback: Callback<Property>): void | 订阅property变化事件。 |
| on(type: 'connectionStateChange', callback: Callback<ConnectionChangeState>): void | 订阅连接状态变化事件。 |
接口名
描述
createClient(address: string): Client
创建ssap客户端实例。
connect(): Promise<void>
向服务端发起连接。
getServices(): Promise<Array<Service>>
获取服务端支持的服务列表。
readProperty(property: Property): Promise<Property>
读取服务端property。
writeProperty(property: Property, writeType: PropertyWriteType): Promise<void>
写入服务端property。
setPropertyNotification(property: Property, enable: boolean): Promise<void>
启用/禁用某个property变化的通知。
on(type: 'propertyChange', callback: Callback<Property>): void
订阅property变化事件。
on(type: 'connectionStateChange', callback: Callback<ConnectionChangeState>): void
订阅连接状态变化事件。
开发步骤
1.
2.
```typescript
try {
let addr: string = '00:11:22:33:AA:FF'; // 扫描获取到的远端设备地址
let client: ssap.Client = ssap.createClient(addr);
console.info('client: ' + JSON.stringify(client));
} catch (err) {
console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
```
3.
4.
5.
6.
7.
8.
9.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/network-kit-V14
爬取时间: 2025-04-28 07:16:10
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/net-mgmt-overview-V14
爬取时间: 2025-04-28 07:16:24
来源: Huawei Developer
Network Kit（网络服务）主要提供以下功能：
约束与限制
使用网络管理模块的相关功能时，需要请求相应的权限。
在申请权限前，请保证符合权限使用的基本原则。然后参考访问控制-声明权限声明对应权限。
| 权限名 | 说明 |
| --- | --- |
| ohos.permission.GET_NETWORK_INFO | 获取网络连接信息。 |
| ohos.permission.INTERNET | 允许程序打开网络套接字，进行网络连接。 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/network-kit-data-transmission-V14
爬取时间: 2025-04-28 07:16:38
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/http-request-V14
爬取时间: 2025-04-28 07:16:52
来源: Huawei Developer
场景介绍
应用通过HTTP发起一个数据请求，支持常见的GET、POST、OPTIONS、HEAD、PUT、DELETE、TRACE、CONNECT方法。
接口说明
HTTP数据请求功能主要由http模块提供。
使用该功能需要申请ohos.permission.INTERNET权限。
权限申请请参考声明权限。
涉及的接口如下表，具体的接口说明请参考API文档。
| 接口名 | 描述 |
| --- | --- |
| createHttp() | 创建一个http请求。 |
| request() | 根据URL地址，发起HTTP网络请求。 |
| requestInStream()10+ | 根据URL地址，发起HTTP网络请求并返回流式响应。 |
| destroy() | 中断请求任务。 |
| on(type: 'headersReceive') | 订阅HTTP Response Header 事件。 |
| off(type: 'headersReceive') | 取消订阅HTTP Response Header 事件。 |
| once('headersReceive')8+ | 订阅HTTP Response Header 事件，但是只触发一次。 |
| on('dataReceive')10+ | 订阅HTTP流式响应数据接收事件。 |
| off('dataReceive')10+ | 取消订阅HTTP流式响应数据接收事件。 |
| on('dataEnd')10+ | 订阅HTTP流式响应数据接收完毕事件。 |
| off('dataEnd')10+ | 取消订阅HTTP流式响应数据接收完毕事件。 |
| on('dataReceiveProgress')10+ | 订阅HTTP流式响应数据接收进度事件。 |
| off('dataReceiveProgress')10+ | 取消订阅HTTP流式响应数据接收进度事件。 |
| on('dataSendProgress')11+ | 订阅HTTP网络请求数据发送进度事件。 |
| off('dataSendProgress')11+ | 取消订阅HTTP网络请求数据发送进度事件。 |
request接口开发步骤
```typescript
// 引入包名
import { http } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
// 每一个httpRequest对应一个HTTP请求任务，不可复用
let httpRequest = http.createHttp();
// 用于订阅HTTP响应头，此接口会比request请求先返回。可以根据业务需要订阅此消息
// 从API 8开始，使用on('headersReceive', Callback)替代on('headerReceive', AsyncCallback)。 8+
httpRequest.on('headersReceive', (header) => {
console.info('header: ' + JSON.stringify(header));
});
httpRequest.request(
// 填写HTTP请求的URL地址，可以带参数也可以不带参数。URL地址需要开发者自定义。请求的参数可以在extraData中指定
"EXAMPLE_URL",
{
method: http.RequestMethod.POST, // 可选，默认为http.RequestMethod.GET
// 开发者根据自身业务需要添加header字段
header: {
'Content-Type': 'application/json'
},
// 当使用POST请求时此字段用于传递请求体内容，具体格式与服务端协商确定
extraData: "data to send",
expectDataType: http.HttpDataType.STRING, // 可选，指定返回数据的类型
usingCache: true, // 可选，默认为true
priority: 1, // 可选，默认为1
connectTimeout: 60000, // 可选，默认为60000ms
readTimeout: 60000, // 可选，默认为60000ms
usingProtocol: http.HttpProtocol.HTTP1_1, // 可选，协议类型默认值由系统自动指定
usingProxy: false, // 可选，默认不使用网络代理，自API 10开始支持该属性
caPath:'/path/to/cacert.pem', // 可选，默认使用系统预制证书，自API 10开始支持该属性
clientCert: { // 可选，默认不使用客户端证书，自API 11开始支持该属性
certPath: '/path/to/client.pem', // 默认不使用客户端证书，自API 11开始支持该属性
keyPath: '/path/to/client.key', // 若证书包含Key信息，传入空字符串，自API 11开始支持该属性
certType: http.CertType.PEM, // 可选，默认使用PEM，自API 11开始支持该属性
keyPassword: "passwordToKey" // 可选，输入key文件的密码，自API 11开始支持该属性
},
multiFormDataList: [ // 可选，仅当Header中，'content-Type'为'multipart/form-data'时生效，自API 11开始支持该属性
{
name: "Part1", // 数据名，自API 11开始支持该属性
contentType: 'text/plain', // 数据类型，自API 11开始支持该属性
data: 'Example data', // 可选，数据内容，自API 11开始支持该属性
remoteFileName: 'example.txt' // 可选，自API 11开始支持该属性
}, {
name: "Part2", // 数据名，自API 11开始支持该属性
contentType: 'text/plain', // 数据类型，自API 11开始支持该属性
// data/app/el2/100/base/com.example.myapplication/haps/entry/files/fileName.txt
filePath: `${getContext(this).filesDir}/fileName.txt`, // 可选，传入文件路径，自API 11开始支持该属性
remoteFileName: 'fileName.txt' // 可选，自API 11开始支持该属性
}
]
}, (err: BusinessError, data: http.HttpResponse) => {
if (!err) {
// data.result为HTTP响应内容，可根据业务需要进行解析
console.info('Result:' + JSON.stringify(data.result));
console.info('code:' + JSON.stringify(data.responseCode));
// data.header为HTTP响应头，可根据业务需要进行解析
console.info('header:' + JSON.stringify(data.header));
console.info('cookies:' + JSON.stringify(data.cookies)); // 8+
// 当该请求使用完毕时，调用destroy方法主动销毁
httpRequest.destroy();
} else {
console.error('error:' + JSON.stringify(err));
// 取消订阅HTTP响应头事件
httpRequest.off('headersReceive');
// 当该请求使用完毕时，调用destroy方法主动销毁
httpRequest.destroy();
}
}
);
```
requestInStream接口开发步骤
```typescript
// 引入包名
import { http } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
// 每一个httpRequest对应一个HTTP请求任务，不可复用
let httpRequest = http.createHttp();
// 用于订阅HTTP响应头事件
httpRequest.on('headersReceive', (header: Object) => {
console.info('header: ' + JSON.stringify(header));
});
// 用于订阅HTTP流式响应数据接收事件
let res = new ArrayBuffer(0);
httpRequest.on('dataReceive', (data: ArrayBuffer) => {
const newRes = new ArrayBuffer(res.byteLength + data.byteLength);
const resView = new Uint8Array(newRes);
resView.set(new Uint8Array(res));
resView.set(new Uint8Array(data), res.byteLength);
res = newRes;
console.info('res length: ' + res.byteLength);
});
// 用于订阅HTTP流式响应数据接收完毕事件
httpRequest.on('dataEnd', () => {
console.info('No more data in response, data receive end');
});
// 用于订阅HTTP流式响应数据接收进度事件
class Data {
receiveSize: number = 0;
totalSize: number = 0;
}
httpRequest.on('dataReceiveProgress', (data: Data) => {
console.log("dataReceiveProgress receiveSize:" + data.receiveSize + ", totalSize:" + data.totalSize);
});
let streamInfo: http.HttpRequestOptions = {
method: http.RequestMethod.POST,  // 可选，默认为http.RequestMethod.GET
// 开发者根据自身业务需要添加header字段
header: {
'Content-Type': 'application/json'
},
// 当使用POST请求时此字段用于传递请求体内容，具体格式与服务端协商确定
extraData: "data to send",
expectDataType:  http.HttpDataType.STRING,// 可选，指定返回数据的类型
usingCache: true, // 可选，默认为true
priority: 1, // 可选，默认为1
connectTimeout: 60000, // 可选，默认为60000ms
readTimeout: 60000, // 可选，默认为60000ms。若传输的数据较大，需要较长的时间，建议增大该参数以保证数据传输正常终止
usingProtocol: http.HttpProtocol.HTTP1_1 // 可选，协议类型默认值由系统自动指定
}
// 填写HTTP请求的URL地址，可以带参数也可以不带参数。URL地址需要开发者自定义。请求的参数可以在extraData中指定
httpRequest.requestInStream("EXAMPLE_URL", streamInfo).then((data: number) => {
console.info("requestInStream OK!");
console.info('ResponseCode :' + JSON.stringify(data));
// 取消订阅HTTP响应头事件
httpRequest.off('headersReceive');
// 取消订阅HTTP流式响应数据接收事件
httpRequest.off('dataReceive');
// 取消订阅HTTP流式响应数据接收进度事件
httpRequest.off('dataReceiveProgress');
// 取消订阅HTTP流式响应数据接收完毕事件
httpRequest.off('dataEnd');
// 当该请求使用完毕时，调用destroy方法主动销毁
httpRequest.destroy();
}).catch((err: Error) => {
console.info("requestInStream ERROR : err = " + JSON.stringify(err));
});
```
证书锁定
可以通过预置应用级证书，或者预置证书公钥哈希值的方式来进行证书锁定，即只有开发者特别指定的证书才能正常建立https连接。
两种方式都是在配置文件中配置的，配置文件在APP中的路径是：src/main/resources/base/profile/network_config.json。在该配置中，可以为预置的证书与网络服务器建立对应关系。
如果不知道服务器域名的证书，可以通过以下方式访问该域名获取证书，注意把www.example.com改成想要获取域名证书的域名，www.example.com.pem改成想保存的证书文件名：
如果你的环境是Windows系统，需要注意：
预置应用级证书
直接把证书原文件预置在APP中。目前支持crt和pem格式的证书文件。
当前ohos.net.http和Image组件的证书锁定，会匹配证书链上所有证书的哈希值，如果服务器更新了任意一本证书，都会导致校验失败。如果服务器出现了更新证书的情况，APP版本应当随之更新并推荐消费者尽快升级APP版本，否则可能导致联网失败。
预置证书公钥哈希值
通过在配置中指定域名证书公钥的哈希值来只允许使用公钥哈希值匹配的域名证书访问此域名。
域名证书的公钥哈希值可以用如下的命令计算，这里假设域名证书是通过上面的OpenSSL命令获得的，并保存在www.example.com.pem文件。#开头的行是注释，可以不用输入：
JSON配置文件示例
预置应用级证书的配置例子如下：
```json
{
"network-security-config": {
"base-config": {
"trust-anchors": [
{
"certificates": "/etc/security/certificates"
}
]
},
"domain-config": [
{
"domains": [
{
"include-subdomains": true,
"name": "example.com"
}
],
"trust-anchors": [
{
"certificates": "/data/storage/el1/bundle/entry/resources/resfile"
}
]
}
]
}
}
```
预置证书公钥哈希值的配置例子如下:
各个字段含义:
| 字段 | 类型 | 说明 |
| --- | --- | --- |
| network-security-config | object | 网络安全配置。可包含0或者1个base-config，必须包含1个domain-config。 |
| base-config | object | 指示应用程序范围的安全配置。必须包含1个trust-anchors。 |
| domain-config | array | 指示每个域的安全配置。可以包含任意个item。item必须包含1个domains，可以包含0或者1个trust-anchors，可以包含0个或者1个pin-set。 |
| trust-anchors | array | 受信任的CA。可以包含任意个item。item必须包含1个certificates。 |
| certificates | string | CA证书路径。 |
| domains | array | 域。可以包含任意个item。item必须包含1个name(string:指示域名)，可以包含0或者1个include-subdomains。 |
| include-subdomains | boolean | 指示规则是否适用于子域。 |
| pin-set | object | 证书公钥哈希设置。必须包含1个pin，可以包含0或者1个expiration。 |
| expiration | string | 指示证书公钥哈希的过期时间。 |
| pin | array | 证书公钥哈希。可以包含任意个item。item必须包含1个digest-algorithm，item必须包含1个digest。 |
| digest-algorithm | string | 指示用于生成哈希的摘要算法。目前只支持sha256。 |
| digest | string | 指示公钥哈希。 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/websocket-connection-V14
爬取时间: 2025-04-28 07:17:05
来源: Huawei Developer
场景介绍
使用WebSocket建立服务器与客户端的双向连接，需要先通过createWebSocket()方法创建WebSocket对象，然后通过connect()方法连接到服务器。当连接成功后，客户端会收到open事件的回调，之后客户端就可以通过send()方法与服务器进行通信。当服务器发信息给客户端时，客户端会收到message事件的回调。当客户端不要此连接时，可以通过调用close()方法主动断开连接，之后客户端会收到close事件的回调。
若在上述任一过程中发生错误，客户端会收到error事件的回调。
websocket支持心跳检测机制，在客户端和服务端建立WebSocket连接之后，每间隔一段时间会客户端会发送Ping帧给服务器，服务器收到后应立即回复Pong帧。
接口说明
WebSocket连接功能主要由webSocket模块提供。使用该功能需要申请ohos.permission.INTERNET权限。具体接口说明如下表。
| 接口名 | 描述 |
| --- | --- |
| createWebSocket() | 创建一个WebSocket连接。 |
| connect() | 根据URL地址，建立一个WebSocket连接。 |
| send() | 通过WebSocket连接发送数据。 |
| close() | 关闭WebSocket连接。 |
| on(type: 'open') | 订阅WebSocket的打开事件。 |
| off(type: 'open') | 取消订阅WebSocket的打开事件。 |
| on(type: 'message') | 订阅WebSocket的接收到服务器消息事件。 |
| off(type: 'message') | 取消订阅WebSocket的接收到服务器消息事件。 |
| on(type: 'close') | 订阅WebSocket的关闭事件。 |
| off(type: 'close') | 取消订阅WebSocket的关闭事件 |
| on(type: 'error') | 订阅WebSocket的Error事件。 |
| off(type: 'error') | 取消订阅WebSocket的Error事件。 |
开发步骤
1.  导入需要的webSocket模块。
2.  创建一个WebSocket连接，返回一个WebSocket对象。
3.  （可选）订阅WebSocket的打开、消息接收、关闭、Error事件。
4.  根据URL地址，发起WebSocket连接。
5.  使用完WebSocket连接之后，主动断开连接。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/native-websocket-guidelines-V14
爬取时间: 2025-04-28 07:17:19
来源: Huawei Developer
场景介绍
通过WebSocket模块可以建立服务器与客户端的双向连接。
接口说明
WebSocket常用接口如下表所示，详细的接口说明请参考net_websocket.h。
| 接口名 | 描述 |
| --- | --- |
| OH_WebSocketClient_Constructor(WebSocket_OnOpenCallback onOpen, WebSocket_OnMessageCallback onMessage, WebSocket_OnErrorCallback onError, WebSocket_OnCloseCallback onclose) | Websocket客户端的构造函数。 |
| OH_WebSocketClient_AddHeader(struct WebSocket *client, struct WebSocket_Header header) | 将header头信息添加到client客户端request中。 |
| OH_WebSocketClient_Connect(struct WebSocket *client, const char *url, struct WebSocket_RequestOptions options) | 客户端连接服务端。 |
| OH_WebSocketClient_Send(struct WebSocket *client, char *data, size_t length) | 客户端向服务端发送数据。 |
| OH_WebSocketClient_Close(struct WebSocket *client, struct WebSocket_CloseOption options) | 客户端主动关闭websocket连接。 |
| OH_WebSocketClient_Destroy(struct WebSocket *client) | 释放websocket连接上下文和资源。 |
WebSocket接口开发示例
开发步骤
使用本文档涉及接口创建并连接到WebSocket服务器时，需先创建Native C++工程，在源文件中将相关接口封装，再在ArkTS层对封装的接口进行调用，使用hilog或者console.log等手段选择打印在控制台或者生成设备日志。
本文以实现建立与WebSocket服务器的连接、发送消息给WebSocket服务器、关闭WebSocket连接为例，给出具体的开发指导。
添加开发依赖
添加动态链接库
CMakeLists.txt中添加以下lib:
头文件
构建工程
1、在源文件中编写调用该API的代码，接受ArkTS传递过来的url字符串参数，创建WebSocket对象指针后，检查连接到服务器是否成功。
简要说明：ConnectWebsocket函数接收一个WebSocket URL，并尝试连接，如果能连接成功，则返回true，否则返回false。在创建WebSocket结构体指针代表WebSocket客户端前，需要定义好该客户端在接收连接开启消息时的回调onOpen、接收到普通消息的回调onMessage、接收到错误消息时的回调onError、接收到关闭消息时的回调onClose。在示例代码中，还调用了OH_WebSocketClient_Send、OH_WebSocketClient_Close等函数向服务器发送消息，主动关闭WebSocket连接。
2、将通过napi封装好的napi_value类型对象初始化导出，通过外部函数接口，将函数暴露给JavaScript使用。示例代码中，ConnectWebsocket函数就会作为外部函数Connect暴露出去；SendMessage函数作为外部函数Send暴露出去；CloseWebsocket函数作为外部函数Close暴露出去。
3、将上一步中初始化成功的对象通过RegisterEntryModule函数，使用napi_module_register函数将模块注册到 Node.js 中。
4、在工程的index.d.ts文件中定义函数的类型。比如，Connect函数接受一个string参数作为入参，并返回boolean值指示WebSocket连接是否能成功建立。
```typescript
export const Connect: (url: string) => boolean;
export const Send: (data: string) => number;
export const Close: () => number;
```
5、在index.ets文件中对上述封装好的接口进行调用。
```typescript
import testWebsocket from 'libentry.so'
@Entry
@Component
struct Index {
@State wsUrl: string = ''
@State content: string = ''
@State connecting: boolean = false
build() {
Navigation() {
Column() {
Column() {
Text("WebSocket address: ")
.fontColor(Color.Gray)
.textAlign(TextAlign.Start)
.width('100%')
TextInput()
.width('100%')
.onChange((value) => {
this.wsUrl = value
})
}
.margin({
bottom: 16
})
.padding({
left: 16,
right: 16
})
Column() {
Text("Content: ")
.fontColor(Color.Gray)
.textAlign(TextAlign.Start)
.width('100%')
TextInput()
.width('100%')
.enabled(this.connecting)
.onChange((value) => {
this.content = value
})
}
.margin({
bottom: 16
})
.padding({
left: 16,
right: 16
})
Blank()
Column({ space: 12 }) {
Button('Connect')
.enabled(!this.connecting)
.onClick(() => {
let connRet = testWebsocket.Connect(this.wsUrl)
if (connRet) {
this.connecting = true;
}
})
Button('Send')
.enabled(this.connecting)
.onClick(() => {
testWebsocket.Send(this.content)
})
Button('Close')
.enabled(this.connecting)
.onClick(() => {
let closeResult = testWebsocket.Close()
if (closeResult != -1) {
this.connecting = false
}
})
}
}
}
}
}
```
6、配置CMakeLists.txt，本模块需要用到的共享库是libnet_websocket.so，在工程自动生成的CMakeLists.txt中的target_link_libraries中添加此共享库。
注意：如图所示，在add_library中的entry是工程自动生成的modename，若要做修改，需和步骤3中.nm_modname保持一致；
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170500.56171819468961910159312630103879:50001231000000:2800:B5F57EC2899C0A7BD24383B2D06309A6573690836D040AC859725319CDE024C7.png)
7、调用WebSocket C API接口要求应用拥有ohos.permission.INTERNET权限，在module.json5中的requestPermissions项添加该权限。
经过以上步骤，整个工程的搭建已经完成，接下来就可以连接设备运行工程进行日志查看了。
测试步骤
1、连接设备，使用DevEco Studio打开搭建好的工程。
2、运行工程，设备上会弹出以下图片所示界面：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170500.28355783814772340416694427949351:50001231000000:2800:822562D78E723B0AC8427704C4845276F6100764C965A0E0ADC460318CECF7D2.jpg)
简要说明：
-  在第一行的输入框中，输入ws://或wss://开头的WebSocket URL。
-  在输入完WebSocket URL，点击Connect按钮后，如果访问成功，会触发onOpen的回调，打印日志。
-  在Content输入框里输入要发送给服务器的内容，点击Send按钮发送。如果服务器返回消息，会触发onMessage回调，打印日志。
-  点击Close按钮，WebSocket连接释放，可以重新输入新的WebSocket URL。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170500.44183698568562182043280181779252:50001231000000:2800:A6542E3A8A356D23630DE23881A32F2C53B2589CC1D59723DC921519EA698DFE.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170501.79952661102357925085499147855420:50001231000000:2800:04389321267253350DCC18BE4D51CD5C45FD6571D4EBC5507F592E37EC6498DF.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/socket-connection-V14
爬取时间: 2025-04-28 07:17:33
来源: Huawei Developer
简介
Socket 连接主要是通过 Socket 进行数据传输，支持 TCP/UDP/Multicast/TLS 协议。
应用退后台又切回前台后，需要对网络通信做失败重试，通信失败后匹配错误码并重新创建新的TCP/UDP连接对象。
基本概念
场景介绍
应用通过 Socket 进行数据传输，支持 TCP/UDP/Multicast/TLS 协议。主要场景有：
接口说明
完整的 API 说明以及实例代码请参考：Socket 连接。
Socket 连接主要由 socket 模块提供。具体接口说明如下表。
| 接口名 | 描述 |
| --- | --- |
| constructUDPSocketInstance() | 创建一个 UDPSocket 对象。 |
| constructTCPSocketInstance() | 创建一个 TCPSocket 对象。 |
| constructTCPSocketServerInstance() | 创建一个 TCPSocketServer 对象。 |
| constructMulticastSocketInstance() | 创建一个 MulticastSocket 对象。 |
| constructLocalSocketInstance() | 创建一个 LocalSocket 对象。 |
| constructLocalSocketServerInstance() | 创建一个 LocalSocketServer 对象。 |
| listen() | 绑定、监听并启动服务，接收客户端的连接请求。（仅 TCP/LocalSocket 支持）。 |
| bind() | 绑定 IP 地址和端口，或是绑定本地套接字路径。 |
| send() | 发送数据。 |
| close() | 关闭连接。 |
| getState() | 获取 Socket 状态。 |
| connect() | 连接到指定的 IP 地址和端口，或是连接到本地套接字（仅 TCP/LocalSocket 支持）。 |
| getRemoteAddress() | 获取对端 Socket 地址（仅 TCP 支持，需要先调用 connect 方法）。 |
| setExtraOptions() | 设置 Socket 连接的其他属性。 |
| getExtraOptions() | 获取 Socket 连接的其他属性（仅 LocalSocket 支持）。 |
| addMembership() | 加入到指定的多播组 IP 中 (仅 Multicast 支持)。 |
| dropMembership() | 从指定的多播组 IP 中退出 (仅 Multicast 支持)。 |
| setMulticastTTL() | 设置数据传输跳数 TTL (仅 Multicast 支持)。 |
| getMulticastTTL() | 获取数据传输跳数 TTL (仅 Multicast 支持)。 |
| setLoopbackMode() | 设置回环模式，允许主机在本地循环接收自己发送的多播数据包 (仅 Multicast 支持)。 |
| getLoopbackMode() | 获取回环模式开启或关闭的状态 (仅 Multicast 支持)。 |
| on(type: 'message') | 订阅 Socket 连接的接收消息事件。 |
| off(type: 'message') | 取消订阅 Socket 连接的接收消息事件。 |
| on(type: 'close') | 订阅 Socket 连接的关闭事件。 |
| off(type: 'close') | 取消订阅 Socket 连接的关闭事件。 |
| on(type: 'error') | 订阅 Socket 连接的 Error 事件。 |
| off(type: 'error') | 取消订阅 Socket 连接的 Error 事件。 |
| on(type: 'listening') | 订阅 UDPSocket 连接的数据包消息事件（仅 UDP 支持）。 |
| off(type: 'listening') | 取消订阅 UDPSocket 连接的数据包消息事件（仅 UDP 支持）。 |
| on(type: 'connect') | 订阅 Socket 的连接事件（仅 TCP/LocalSocket 支持）。 |
| off(type: 'connect') | 取消订阅 Socket 的连接事件（仅 TCP/LocalSocket 支持）。 |
TLS Socket 连接主要由 tls_socket 模块提供。具体接口说明如下表。
| 接口名 | 功能描述 |
| --- | --- |
| constructTLSSocketInstance() | 创建一个 TLSSocket 对象。 |
| bind() | 绑定 IP 地址和端口号。 |
| close(type: 'error') | 关闭连接。 |
| connect() | 连接到指定的 IP 地址和端口。 |
| getCertificate() | 返回表示本地证书的对象。 |
| getCipherSuite() | 返回包含协商的密码套件信息的列表。 |
| getProtocol() | 返回包含当前连接协商的 SSL/TLS 协议版本的字符串。 |
| getRemoteAddress() | 获取 TLSSocket 连接的对端地址。 |
| getRemoteCertificate() | 返回表示对等证书的对象。 |
| getSignatureAlgorithms() | 在服务器和客户端之间共享的签名算法列表，按优先级降序排列。 |
| getState() | 获取 TLSSocket 连接的状态。 |
| off(type: 'close') | 取消订阅 TLSSocket 连接的关闭事件。 |
| off(type: 'error') | 取消订阅 TLSSocket 连接的 Error 事件。 |
| off(type: 'message') | 取消订阅 TLSSocket 连接的接收消息事件。 |
| on(type: 'close') | 订阅 TLSSocket 连接的关闭事件。 |
| on(type: 'error') | 订阅 TLSSocket 连接的 Error 事件。 |
| on(type: 'message') | 订阅 TLSSocket 连接的接收消息事件。 |
| send() | 发送数据。 |
| setExtraOptions() | 设置 TLSSocket 连接的其他属性。 |
应用 TCP/UDP 协议进行通信
UDP 与 TCP 流程大体类似，下面以 TCP 为例：
1.  import 需要的 socket 模块。
2.  创建一个 TCPSocket 连接，返回一个 TCPSocket 对象。
3.  （可选）订阅 TCPSocket 相关的订阅事件。
4.  绑定 IP 地址和端口，端口可以指定或由系统随机分配。
5.  连接到指定的 IP 地址和端口。
6.  发送数据。
7.  Socket 连接使用完毕后，主动关闭。
```typescript
import { socket } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
class SocketInfo {
message: ArrayBuffer = new ArrayBuffer(1);
remoteInfo: socket.SocketRemoteInfo = {} as socket.SocketRemoteInfo;
}
// 创建一个TCPSocket连接，返回一个TCPSocket对象。
let tcp: socket.TCPSocket = socket.constructTCPSocketInstance();
tcp.on('message', (value: SocketInfo) => {
console.log("on message");
let buffer = value.message;
let dataView = new DataView(buffer);
let str = "";
for (let i = 0; i < dataView.byteLength; ++i) {
str += String.fromCharCode(dataView.getUint8(i));
}
console.log("on connect received:" + str);
});
tcp.on('connect', () => {
console.log("on connect");
});
tcp.on('close', () => {
console.log("on close");
});
// 绑定本地IP地址和端口。
let ipAddress : socket.NetAddress = {} as socket.NetAddress;
ipAddress.address = "192.168.xxx.xxx";
ipAddress.port = 1234;
tcp.bind(ipAddress, (err: BusinessError) => {
if (err) {
console.log('bind fail');
return;
}
console.log('bind success');
// 连接到指定的IP地址和端口。
ipAddress.address = "192.168.xxx.xxx";
ipAddress.port = 5678;
let tcpConnect : socket.TCPConnectOptions = {} as socket.TCPConnectOptions;
tcpConnect.address = ipAddress;
tcpConnect.timeout = 6000;
tcp.connect(tcpConnect).then(() => {
console.log('connect success');
let tcpSendOptions: socket.TCPSendOptions = {
data: 'Hello, server!'
}
tcp.send(tcpSendOptions).then(() => {
console.log('send success');
}).catch((err: BusinessError) => {
console.log('send fail');
});
}).catch((err: BusinessError) => {
console.log('connect fail');
});
});
// 连接使用完毕后，主动关闭。取消相关事件的订阅。
setTimeout(() => {
tcp.close().then(() => {
console.log('close success');
}).catch((err: BusinessError) => {
console.log('close fail');
});
tcp.off('message');
tcp.off('connect');
tcp.off('close');
}, 30 * 1000);
```
应用通过 TCP Socket Server 进行数据传输
服务端 TCP Socket 流程：
```typescript
import { socket } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
// 创建一个TCPSocketServer连接，返回一个TCPSocketServer对象。
let tcpServer: socket.TCPSocketServer = socket.constructTCPSocketServerInstance();
// 绑定本地IP地址和端口，进行监听
let ipAddress : socket.NetAddress = {} as socket.NetAddress;
ipAddress.address = "192.168.xxx.xxx";
ipAddress.port = 4651;
tcpServer.listen(ipAddress).then(() => {
console.log('listen success');
}).catch((err: BusinessError) => {
console.log('listen fail');
});
class SocketInfo {
message: ArrayBuffer = new ArrayBuffer(1);
remoteInfo: socket.SocketRemoteInfo = {} as socket.SocketRemoteInfo;
}
// 订阅TCPSocketServer的connect事件
tcpServer.on("connect", (client: socket.TCPSocketConnection) => {
// 订阅TCPSocketConnection相关的事件
client.on("close", () => {
console.log("on close success");
});
client.on("message", (value: SocketInfo) => {
let buffer = value.message;
let dataView = new DataView(buffer);
let str = "";
for (let i = 0; i < dataView.byteLength; ++i) {
str += String.fromCharCode(dataView.getUint8(i));
}
console.log("received message--:" + str);
console.log("received address--:" + value.remoteInfo.address);
console.log("received family--:" + value.remoteInfo.family);
console.log("received port--:" + value.remoteInfo.port);
console.log("received size--:" + value.remoteInfo.size);
});
// 向客户端发送数据
let tcpSendOptions : socket.TCPSendOptions = {} as socket.TCPSendOptions;
tcpSendOptions.data = 'Hello, client!';
client.send(tcpSendOptions).then(() => {
console.log('send success');
}).catch((err: Object) => {
console.error('send fail: ' + JSON.stringify(err));
});
// 关闭与客户端的连接
client.close().then(() => {
console.log('close success');
}).catch((err: BusinessError) => {
console.log('close fail');
});
// 取消TCPSocketConnection相关的事件订阅
setTimeout(() => {
client.off("message");
client.off("close");
}, 10 * 1000);
});
// 取消TCPSocketServer相关的事件订阅
setTimeout(() => {
tcpServer.off("connect");
}, 30 * 1000);
```
应用通过 Multicast Socket 进行数据传输
1.  import 需要的 socket 模块。
2.  创建 multicastSocket 多播对象。
3.  指定多播 IP 与端口，加入多播组。
4.  开启消息 message 监听。
5.  发送数据，数据以广播的形式传输，同一多播组中已经开启消息 message 监听的多播对象都会接收到数据。
6.  关闭 message 消息的监听。
7.  退出多播组。
```typescript
import { socket } from '@kit.NetworkKit';
// 创建Multicast对象
let multicast: socket.MulticastSocket = socket.constructMulticastSocketInstance();
let addr : socket.NetAddress = {
address: '239.255.0.1',
port: 32123,
family: 1
}
// 加入多播组
multicast.addMembership(addr).then(() => {
console.log('addMembership success');
}).catch((err: Object) => {
console.log('addMembership fail');
});
// 开启监听消息数据，将接收到的ArrayBuffer类型数据转换为String
class SocketInfo {
message: ArrayBuffer = new ArrayBuffer(1);
remoteInfo: socket.SocketRemoteInfo = {} as socket.SocketRemoteInfo;
}
multicast.on('message', (data: SocketInfo) => {
console.info('接收的数据: ' + JSON.stringify(data))
const uintArray = new Uint8Array(data.message)
let str = ''
for (let i = 0; i < uintArray.length; ++i) {
str += String.fromCharCode(uintArray[i])
}
console.info(str)
})
// 发送数据
multicast.send({ data:'Hello12345', address: addr }).then(() => {
console.log('send success');
}).catch((err: Object) => {
console.log('send fail, ' + JSON.stringify(err));
});
// 关闭消息的监听
multicast.off('message')
// 退出多播组
multicast.dropMembership(addr).then(() => {
console.log('drop membership success');
}).catch((err: Object) => {
console.log('drop membership fail');
});
```
应用通过 LocalSocket 进行数据传输
1.  import 需要的 socket 模块。
2.  使用 constructLocalSocketInstance 接口，创建一个 LocalSocket 客户端对象。
3.  注册 LocalSocket 的消息(message)事件，以及一些其它事件(可选)。
4.  连接到指定的本地套接字文件路径。
5.  发送数据。
6.  Socket 连接使用完毕后，取消事件的注册，并关闭套接字。
```typescript
import { socket } from '@kit.NetworkKit';
// 创建一个LocalSocket连接，返回一个LocalSocket对象。
let client: socket.LocalSocket = socket.constructLocalSocketInstance();
client.on('message', (value: socket.LocalSocketMessageInfo) => {
const uintArray = new Uint8Array(value.message)
let messageView = '';
for (let i = 0; i < uintArray.length; i++) {
messageView += String.fromCharCode(uintArray[i]);
}
console.log('total receive: ' + JSON.stringify(value));
console.log('message information: ' + messageView);
});
client.on('connect', () => {
console.log("on connect");
});
client.on('close', () => {
console.log("on close");
});
// 传入指定的本地套接字路径，连接服务端。
let sandboxPath: string = getContext(this).filesDir + '/testSocket'
let localAddress : socket.LocalAddress = {
address: sandboxPath
}
let connectOpt: socket.LocalConnectOptions = {
address: localAddress,
timeout: 6000
}
let sendOpt: socket.LocalSendOptions = {
data: 'Hello world!'
}
client.connect(connectOpt).then(() => {
console.log('connect success')
client.send(sendOpt).then(() => {
console.log('send success')
}).catch((err: Object) => {
console.log('send failed: ' + JSON.stringify(err))
})
}).catch((err: Object) => {
console.log('connect fail: ' + JSON.stringify(err));
});
// 当不需要再连接服务端，需要断开且取消事件的监听时
client.off('message');
client.off('connect');
client.off('close');
client.close().then(() => {
console.log('close client success')
}).catch((err: Object) => {
console.log('close client err: ' + JSON.stringify(err))
})
```
应用通过 Local Socket Server 进行数据传输
服务端 LocalSocket Server 流程：
1.  import 需要的 socket 模块。
2.  使用 constructLocalSocketServerInstance 接口，创建一个 LocalSocketServer 服务端对象。
3.  启动服务，绑定本地套接字路径，创建出本地套接字文件，监听客户端的连接请求。
4.  注册 LocalSocket 的客户端连接(connect)事件，以及一些其它事件(可选)。
5.  在客户端连接上来时，通过连接事件的回调函数，获取连接会话对象。
6.  给会话对象 LocalSocketConnection 注册消息(message)事件，以及一些其它事件(可选)。
7.  通过会话对象主动向客户端发送消息。
8.  结束与客户端的通信，主动断开与客户端的连接。
9.  取消 LocalSocketConnection 和 LocalSocketServer 相关事件的订阅。
```typescript
import { socket } from '@kit.NetworkKit';
// 创建一个LocalSocketServer连接，返回一个LocalSocketServer对象。
let server: socket.LocalSocketServer = socket.constructLocalSocketServerInstance();
// 创建并绑定本地套接字文件testSocket，进行监听
let sandboxPath: string = getContext(this).filesDir + '/testSocket'
let listenAddr: socket.LocalAddress = {
address: sandboxPath
}
server.listen(listenAddr).then(() => {
console.log("listen success");
}).catch((err: Object) => {
console.log("listen fail: " + JSON.stringify(err));
});
// 订阅LocalSocketServer的connect事件
server.on('connect', (connection: socket.LocalSocketConnection) => {
// 订阅LocalSocketConnection相关的事件
connection.on('error', (err: Object) => {
console.log("on error success");
});
connection.on('message', (value: socket.LocalSocketMessageInfo) => {
const uintArray = new Uint8Array(value.message);
let messageView = '';
for (let i = 0; i < uintArray.length; i++) {
messageView += String.fromCharCode(uintArray[i]);
}
console.log('total: ' + JSON.stringify(value));
console.log('message information: ' + messageView);
});
connection.on('error', (err: Object) => {
console.log("err:" + JSON.stringify(err));
})
// 向客户端发送数据
let sendOpt : socket.LocalSendOptions = {
data: 'Hello world!'
};
connection.send(sendOpt).then(() => {
console.log('send success');
}).catch((err: Object) => {
console.log('send failed: ' + JSON.stringify(err));
})
// 关闭与客户端的连接
connection.close().then(() => {
console.log('close success');
}).catch((err: Object) => {
console.log('close failed: ' + JSON.stringify(err));
});
// 取消LocalSocketConnection相关的事件订阅
connection.off('message');
connection.off('error');
});
// 取消LocalSocketServer相关的事件订阅
server.off('connect');
server.off('error');
```
应用通过 TLS Socket 进行加密数据传输
客户端 TLS Socket 流程：
1.  import 需要的 socket 模块。
2.  绑定服务器 IP 和端口号。
3.  双向认证上传客户端 CA 证书及数字证书；单向认证上传客户端 CA 证书。
4.  创建一个 TLSSocket 连接，返回一个 TLSSocket 对象。
5.  （可选）订阅 TLSSocket 相关的订阅事件。
6.  发送数据。
7.  TLSSocket 连接使用完毕后，主动关闭。
```typescript
import { socket } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
class SocketInfo {
message: ArrayBuffer = new ArrayBuffer(1);
remoteInfo: socket.SocketRemoteInfo = {} as socket.SocketRemoteInfo;
}
// 创建一个（双向认证）TLS Socket连接，返回一个TLS Socket对象。
let tlsTwoWay: socket.TLSSocket = socket.constructTLSSocketInstance();
// 订阅TLS Socket相关的订阅事件
tlsTwoWay.on('message', (value: SocketInfo) => {
console.log("on message");
let buffer = value.message;
let dataView = new DataView(buffer);
let str = "";
for (let i = 0; i < dataView.byteLength; ++i) {
str += String.fromCharCode(dataView.getUint8(i));
}
console.log("on connect received:" + str);
});
tlsTwoWay.on('connect', () => {
console.log("on connect");
});
tlsTwoWay.on('close', () => {
console.log("on close");
});
// 绑定本地IP地址和端口。
let ipAddress : socket.NetAddress = {} as socket.NetAddress;
ipAddress.address = "192.168.xxx.xxx";
ipAddress.port = 4512;
tlsTwoWay.bind(ipAddress, (err: BusinessError) => {
if (err) {
console.log('bind fail');
return;
}
console.log('bind success');
});
ipAddress.address = "192.168.xxx.xxx";
ipAddress.port = 1234;
let tlsSecureOption : socket.TLSSecureOptions = {} as socket.TLSSecureOptions;
tlsSecureOption.key = "xxxx";
tlsSecureOption.cert = "xxxx";
tlsSecureOption.ca = ["xxxx"];
tlsSecureOption.password = "xxxx";
tlsSecureOption.protocols = [socket.Protocol.TLSv12];
tlsSecureOption.useRemoteCipherPrefer = true;
tlsSecureOption.signatureAlgorithms = "rsa_pss_rsae_sha256:ECDSA+SHA256";
tlsSecureOption.cipherSuite = "AES256-SHA256";
let tlsTwoWayConnectOption : socket.TLSConnectOptions = {} as socket.TLSConnectOptions;
tlsSecureOption.key = "xxxx";
tlsTwoWayConnectOption.address = ipAddress;
tlsTwoWayConnectOption.secureOptions = tlsSecureOption;
tlsTwoWayConnectOption.ALPNProtocols = ["spdy/1", "http/1.1"];
// 建立连接
tlsTwoWay.connect(tlsTwoWayConnectOption).then(() => {
console.log("connect successfully");
}).catch((err: BusinessError) => {
console.log("connect failed " + JSON.stringify(err));
});
// 连接使用完毕后，主动关闭。取消相关事件的订阅。
tlsTwoWay.close((err: BusinessError) => {
if (err) {
console.log("close callback error = " + err);
} else {
console.log("close success");
}
tlsTwoWay.off('message');
tlsTwoWay.off('connect');
tlsTwoWay.off('close');
});
// 创建一个（单向认证）TLS Socket连接，返回一个TLS Socket对象。
let tlsOneWay: socket.TLSSocket = socket.constructTLSSocketInstance(); // One way authentication
// 订阅TLS Socket相关的订阅事件
tlsTwoWay.on('message', (value: SocketInfo) => {
console.log("on message");
let buffer = value.message;
let dataView = new DataView(buffer);
let str = "";
for (let i = 0; i < dataView.byteLength; ++i) {
str += String.fromCharCode(dataView.getUint8(i));
}
console.log("on connect received:" + str);
});
tlsTwoWay.on('connect', () => {
console.log("on connect");
});
tlsTwoWay.on('close', () => {
console.log("on close");
});
// 绑定本地IP地址和端口。
ipAddress.address = "192.168.xxx.xxx";
ipAddress.port = 5445;
tlsOneWay.bind(ipAddress, (err:BusinessError) => {
if (err) {
console.log('bind fail');
return;
}
console.log('bind success');
});
ipAddress.address = "192.168.xxx.xxx";
ipAddress.port = 8789;
let tlsOneWaySecureOption : socket.TLSSecureOptions = {} as socket.TLSSecureOptions;
tlsOneWaySecureOption.ca = ["xxxx", "xxxx"];
tlsOneWaySecureOption.cipherSuite = "AES256-SHA256";
let tlsOneWayConnectOptions: socket.TLSConnectOptions = {} as socket.TLSConnectOptions;
tlsOneWayConnectOptions.address = ipAddress;
tlsOneWayConnectOptions.secureOptions = tlsOneWaySecureOption;
// 建立连接
tlsOneWay.connect(tlsOneWayConnectOptions).then(() => {
console.log("connect successfully");
}).catch((err: BusinessError) => {
console.log("connect failed " + JSON.stringify(err));
});
// 连接使用完毕后，主动关闭。取消相关事件的订阅。
tlsTwoWay.close((err: BusinessError) => {
if (err) {
console.log("close callback error = " + err);
} else {
console.log("close success");
}
tlsTwoWay.off('message');
tlsTwoWay.off('connect');
tlsTwoWay.off('close');
});
```
应用通过将 TCP Socket 升级为 TLS Socket 进行加密数据传输
客户端 TCP Socket 升级为 TLS Socket 流程：
1.  import 需要的 socket 模块。
2.  参考应用 TCP/UDP 协议进行通信，创建一个 TCPSocket 连接。
3.  确保 TCPSocket 已连接后，使用该 TCPSocket 对象创建 TLSSocket 连接，返回一个 TLSSocket 对象。
4.  双向认证上传客户端 CA 证书及数字证书；单向认证上传客户端 CA 证书。
5.  （可选）订阅 TLSSocket 相关的订阅事件。
6.  发送数据。
7.  TLSSocket 连接使用完毕后，主动关闭。
```typescript
import { socket } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
class SocketInfo {
message: ArrayBuffer = new ArrayBuffer(1);
remoteInfo: socket.SocketRemoteInfo = {} as socket.SocketRemoteInfo;
}
// 创建一个TCPSocket连接，返回一个TCPSocket对象。
let tcp: socket.TCPSocket = socket.constructTCPSocketInstance();
tcp.on('message', (value: SocketInfo) => {
console.log("on message");
let buffer = value.message;
let dataView = new DataView(buffer);
let str = "";
for (let i = 0; i < dataView.byteLength; ++i) {
str += String.fromCharCode(dataView.getUint8(i));
}
console.log("on connect received:" + str);
});
tcp.on('connect', () => {
console.log("on connect");
});
// 绑定本地IP地址和端口。
let ipAddress: socket.NetAddress = {} as socket.NetAddress;
ipAddress.address = "192.168.xxx.xxx";
ipAddress.port = 1234;
tcp.bind(ipAddress, (err: BusinessError) => {
if (err) {
console.log('bind fail');
return;
}
console.log('bind success');
// 连接到指定的IP地址和端口。
ipAddress.address = "192.168.xxx.xxx";
ipAddress.port = 443;
let tcpConnect: socket.TCPConnectOptions = {} as socket.TCPConnectOptions;
tcpConnect.address = ipAddress;
tcpConnect.timeout = 6000;
tcp.connect(tcpConnect, (err: BusinessError) => {
if (err) {
console.log('connect fail');
return;
}
console.log('connect success');
// 确保TCPSocket已连接后，将其升级为TLSSocket连接。
let tlsTwoWay: socket.TLSSocket = socket.constructTLSSocketInstance(tcp);
// 订阅TLSSocket相关的订阅事件。
tlsTwoWay.on('message', (value: SocketInfo) => {
console.log("tls on message");
let buffer = value.message;
let dataView = new DataView(buffer);
let str = "";
for (let i = 0; i < dataView.byteLength; ++i) {
str += String.fromCharCode(dataView.getUint8(i));
}
console.log("tls on connect received:" + str);
});
tlsTwoWay.on('connect', () => {
console.log("tls on connect");
});
tlsTwoWay.on('close', () => {
console.log("tls on close");
});
// 配置TLSSocket目的地址、证书等信息。
ipAddress.address = "192.168.xxx.xxx";
ipAddress.port = 1234;
let tlsSecureOption: socket.TLSSecureOptions = {} as socket.TLSSecureOptions;
tlsSecureOption.key = "xxxx";
tlsSecureOption.cert = "xxxx";
tlsSecureOption.ca = ["xxxx"];
tlsSecureOption.password = "xxxx";
tlsSecureOption.protocols = [socket.Protocol.TLSv12];
tlsSecureOption.useRemoteCipherPrefer = true;
tlsSecureOption.signatureAlgorithms = "rsa_pss_rsae_sha256:ECDSA+SHA256";
tlsSecureOption.cipherSuite = "AES256-SHA256";
let tlsTwoWayConnectOption: socket.TLSConnectOptions = {} as socket.TLSConnectOptions;
tlsSecureOption.key = "xxxx";
tlsTwoWayConnectOption.address = ipAddress;
tlsTwoWayConnectOption.secureOptions = tlsSecureOption;
tlsTwoWayConnectOption.ALPNProtocols = ["spdy/1", "http/1.1"];
// 建立TLSSocket连接
tlsTwoWay.connect(tlsTwoWayConnectOption, () => {
console.log("tls connect success");
// 连接使用完毕后，主动关闭。取消相关事件的订阅。
tlsTwoWay.close((err: BusinessError) => {
if (err) {
console.log("tls close callback error = " + err);
} else {
console.log("tls close success");
}
tlsTwoWay.off('message');
tlsTwoWay.off('connect');
tlsTwoWay.off('close');
});
});
});
});
```
应用通过 TLS Socket Server 进行加密数据传输
服务端 TLS Socket Server 流程：
1.  import 需要的 socket 模块。
2.  启动服务，绑定 IP 和端口号，监听客户端连接，创建并初始化 TLS 会话，加载证书密钥并验证。
3.  订阅 TLSSocketServer 的连接事件。
4.  收到客户端连接，通过回调得到 TLSSocketConnection 对象。
5.  订阅 TLSSocketConnection 相关的事件。
6.  发送数据。
7.  TLSSocketConnection 连接使用完毕后，断开连接。
8.  取消订阅 TLSSocketConnection 以及 TLSSocketServer 的相关事件。
```typescript
import { socket } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
let tlsServer: socket.TLSSocketServer = socket.constructTLSSocketServerInstance();
let netAddress: socket.NetAddress = {
address: '192.168.xx.xxx',
port: 8080
}
let tlsSecureOptions: socket.TLSSecureOptions = {
key: "xxxx",
cert: "xxxx",
ca: ["xxxx"],
password: "xxxx",
protocols: socket.Protocol.TLSv12,
useRemoteCipherPrefer: true,
signatureAlgorithms: "rsa_pss_rsae_sha256:ECDSA+SHA256",
cipherSuite: "AES256-SHA256"
}
let tlsConnectOptions: socket.TLSConnectOptions = {
address: netAddress,
secureOptions: tlsSecureOptions,
ALPNProtocols: ["spdy/1", "http/1.1"]
}
tlsServer.listen(tlsConnectOptions).then(() => {
console.log("listen callback success");
}).catch((err: BusinessError) => {
console.log("failed" + err);
});
class SocketInfo {
message: ArrayBuffer = new ArrayBuffer(1);
remoteInfo: socket.SocketRemoteInfo = {} as socket.SocketRemoteInfo;
}
let callback = (value: SocketInfo) => {
let messageView = '';
for (let i: number = 0; i < value.message.byteLength; i++) {
let uint8Array = new Uint8Array(value.message)
let messages = uint8Array[i]
let message = String.fromCharCode(messages);
messageView += message;
}
console.log('on message message: ' + JSON.stringify(messageView));
console.log('remoteInfo: ' + JSON.stringify(value.remoteInfo));
}
tlsServer.on('connect', (client: socket.TLSSocketConnection) => {
client.on('message', callback);
// 发送数据
client.send('Hello, client!').then(() => {
console.log('send success');
}).catch((err: BusinessError) => {
console.log('send fail');
});
// 断开连接
client.close().then(() => {
console.log('close success');
}).catch((err: BusinessError) => {
console.log('close fail');
});
// 可以指定传入on中的callback取消一个订阅，也可以不指定callback清空所有订阅。
client.off('message', callback);
client.off('message');
});
// 取消订阅tlsServer的相关事件
tlsServer.off('connect');
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/net-mdns-V14
爬取时间: 2025-04-28 07:17:46
来源: Huawei Developer
简介
MDNS即多播DNS（Multicast DNS），提供局域网内的本地服务添加、移除、发现、解析等能力。
MDNS管理的典型场景有：
为了保证应用的运行效率，大部分API调用都是异步的，对于异步调用的API均提供了callback和Promise两种方式，以下示例均采用promise函数，更多方式可以查阅MDNS管理-API参考。
以下分别介绍具体开发方式。
接口说明
完整的JS API说明以及实例代码请参考：MDNS管理-API参考。
| 接口名 | 描述 |
| --- | --- |
| addLocalService(context: Context, serviceInfo: LocalServiceInfo, callback: AsyncCallback<LocalServiceInfo>): void | 添加一个MDNS服务，使用callback方式作为异步方法。 |
| removeLocalService(context: Context, serviceInfo: LocalServiceInfo, callback: AsyncCallback<LocalServiceInfo>): void | 移除一个MDNS服务，使用callback方式作为异步方法。 |
| createDiscoveryService(context: Context, serviceType: string): DiscoveryService | 返回一个DiscoveryService对象，该对象用于发现指定服务类型的MDNS服务。 |
| resolveLocalService(context: Context, serviceInfo: LocalServiceInfo, callback: AsyncCallback<LocalServiceInfo>): void | 解析一个MDNS服务，使用callback方式作为异步方法。 |
| startSearchingMDNS(): void | 开始搜索局域网内的MDNS服务。 |
| stopSearchingMDNS(): void | 停止搜索局域网内的MDNS服务。 |
| on(type: 'discoveryStart', callback: Callback<{serviceInfo: LocalServiceInfo, errorCode?: MdnsError}>): void | 订阅开启监听MDNS服务的通知。 |
| off(type: 'discoveryStart', callback?: Callback<{ serviceInfo: LocalServiceInfo, errorCode?: MdnsError }>): void | 取消开启监听MDNS服务的通知。 |
| on(type: 'discoveryStop', callback: Callback<{serviceInfo: LocalServiceInfo, errorCode?: MdnsError}>): void | 订阅停止监听MDNS服务的通知。 |
| off(type: 'discoveryStop', callback?: Callback<{ serviceInfo: LocalServiceInfo, errorCode?: MdnsError }>): void | 取消停止监听MDNS服务的通知。 |
| on(type: 'serviceFound', callback: Callback<LocalServiceInfo>): void | 订阅发现MDNS服务的通知。 |
| off(type: 'serviceFound', callback?: Callback<LocalServiceInfo>): void | 取消发现MDNS服务的通知。 |
| on(type: 'serviceLost', callback: Callback<LocalServiceInfo>): void | 订阅移除MDNS服务的通知。 |
| off(type: 'serviceLost', callback?: Callback<LocalServiceInfo>): void | 取消移除MDNS服务的通知。 |
管理本地服务
```typescript
// 从@kit.NetworkKit中导入mdns命名空间
import { mdns } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { featureAbility } from '@kit.AbilityKit';
let context = getContext(this) as Context;
class ServiceAttribute {
key: string = "111"
value: Array<number> = [1]
}
// 建立LocalService对象
let localServiceInfo: mdns.LocalServiceInfo = {
serviceType: "_print._tcp",
serviceName: "servicename",
port: 5555,
host: {
address: "10.14.**.***"
},
serviceAttribute: [{key: "111", value: [1]}]
}
// addLocalService添加本地服务
mdns.addLocalService(context, localServiceInfo).then((data: mdns.LocalServiceInfo) => {
console.log(JSON.stringify(data));
});
// resolveLocalService解析本地服务对象（非必要，根据需求使用）
mdns.resolveLocalService(context, localServiceInfo).then((data: mdns.LocalServiceInfo) => {
console.log(JSON.stringify(data));
});
// removeLocalService移除本地服务
mdns.removeLocalService(context, localServiceInfo).then((data: mdns.LocalServiceInfo) => {
console.log(JSON.stringify(data));
});
```
发现本地服务
```typescript
// 从@kit.NetworkKit中导入mdns命名空间
import { common, featureAbility, UIAbility } from '@kit.AbilityKit';
import { mdns } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { window } from '@kit.ArkUI';
// 构造单例对象
export class GlobalContext {
private constructor() {}
private static instance: GlobalContext;
private _objects = new Map<string, Object>();
public static getContext(): GlobalContext {
if (!GlobalContext.instance) {
GlobalContext.instance = new GlobalContext();
}
return GlobalContext.instance;
}
getObject(value: string): Object | undefined {
return this._objects.get(value);
}
setObject(key: string, objectClass: Object): void {
this._objects.set(key, objectClass);
}
}
// Stage模型获取context
class EntryAbility extends UIAbility {
value:number = 0;
onWindowStageCreate(windowStage: window.WindowStage): void{
GlobalContext.getContext().setObject("value", this.value);
}
}
let context = GlobalContext.getContext().getObject("value") as common.UIAbilityContext;
// 创建DiscoveryService对象，用于发现指定服务类型的MDNS服务
let serviceType = "_print._tcp";
let discoveryService = mdns.createDiscoveryService(context, serviceType);
// 订阅MDNS服务发现相关状态变化
discoveryService.on('discoveryStart', (data: mdns.DiscoveryEventInfo) => {
console.log(JSON.stringify(data));
});
discoveryService.on('discoveryStop', (data: mdns.DiscoveryEventInfo) => {
console.log(JSON.stringify(data));
});
discoveryService.on('serviceFound', (data: mdns.LocalServiceInfo) => {
console.log(JSON.stringify(data));
});
discoveryService.on('serviceLost', (data: mdns.LocalServiceInfo) => {
console.log(JSON.stringify(data));
});
// 启动搜索局域网内的MDNS服务
discoveryService.startSearchingMDNS();
// 停止搜索局域网内的MDNS服务
discoveryService.stopSearchingMDNS();
// 取消订阅的MDNS服务
discoveryService.off('discoveryStart', (data: mdns.DiscoveryEventInfo) => {
console.log(JSON.stringify(data));
});
discoveryService.off('discoveryStop', (data: mdns.DiscoveryEventInfo) => {
console.log(JSON.stringify(data));
});
discoveryService.off('serviceFound', (data: mdns.LocalServiceInfo) => {
console.log(JSON.stringify(data));
});
discoveryService.off('serviceLost', (data: mdns.LocalServiceInfo) => {
console.log(JSON.stringify(data));
});
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/network-kit-network-management-V14
爬取时间: 2025-04-28 07:18:00
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/net-connection-manager-V14
爬取时间: 2025-04-28 07:18:13
来源: Huawei Developer
简介
网络连接管理提供管理网络一些基础能力，包括WiFi/蜂窝/Ethernet等多网络连接优先级管理、网络质量评估、订阅默认/指定网络连接状态变化、查询网络连接信息、DNS解析等功能。
为了保证应用的运行效率，大部分API调用都是异步的，对于异步调用的API均提供了callback和Promise两种方式，以下示例均采用promise函数，更多方式可以查阅API参考。
基本概念
约束
场景介绍
网络连接管理的典型场景如下所示。
具体开发方式介绍如下。
接口说明
完整的JS API说明以及实例代码请参考：网络连接管理。
| 接口名 | 描述 |
| --- | --- |
| getDefaultNet(callback: AsyncCallback<NetHandle>): void; | 获取一个含有默认网络的netId的NetHandle对象，使用callback回调。 |
| setAppHttpProxy(httpProxy: HttpProxy): void; | 设置网络应用级Http代理配置信息。 |
| getAppNet(callback: AsyncCallback<NetHandle>): void; | 获取一个App绑定的包含了网络netId的NetHandle对象，使用callback回调。 |
| setAppNet(netHandle: NetHandle, callback: AsyncCallback<void>): void; | 绑定App到指定网络，绑定后的App只能通过指定网络访问外网。使用callback回调。 |
| getDefaultNetSync(): NetHandle; | 使用同步方法获取默认激活的数据网络。可以使用getNetCapabilities去获取网络的类型、拥有的能力等信息。 |
| hasDefaultNet(callback: AsyncCallback<boolean>): void; | 检查默认数据网络是否被激活，使用callback回调。 |
| getAllNets(callback: AsyncCallback<Array<NetHandle>>): void; | 获取所处于连接状态的网络的NetHandle对象列表，使用callback回调。 |
| getConnectionProperties(netHandle: NetHandle, callback: AsyncCallback<ConnectionProperties>): void; | 查询netHandle对应的网络的连接信息，使用callback回调。 |
| getNetCapabilities(netHandle: NetHandle, callback: AsyncCallback<NetCapabilities>): void; | 获取netHandle对应的网络的能力信息，使用callback回调。 |
| isDefaultNetMetered(callback: AsyncCallback<boolean>): void; | 检查当前网络上的数据流量使用是否被计量，使用callback方式作为异步方法。 |
| reportNetConnected(netHandle: NetHandle, callback: AsyncCallback<void>): void; | 向网络管理报告网络处于可用状态，调用此接口说明应用程序认为网络的可用性(ohos.net.connection.NetCap.NET_CAPABILITY_VAILDATED)与网络管理不一致。使用callback回调。 |
| reportNetDisconnected(netHandle: NetHandle, callback: AsyncCallback<void>): void; | 向网络管理报告网络处于不可用状态，调用此接口说明应用程序认为网络的可用性(ohos.net.connection.NetCap.NET_CAPABILITY_VAILDATED)与网络管理不一致。使用callback回调。 |
| getAddressesByName(host: string, callback: AsyncCallback<Array<NetAddress>>): void; | 使用对应网络解析域名，获取所有IP，使用callback回调。 |
| createNetConnection(netSpecifier?: NetSpecifier, timeout?: number): NetConnection; | 返回一个NetConnection对象，netSpecifier指定关注的网络的各项特征。timeout是超时时间(单位：毫秒)，netSpecifier是timeout的必要条件，两者都没有则表示关注默认网络。 |
| bindSocket(socketParam: TCPSocket | UDPSocket, callback: AsyncCallback<void>): void; | 将TCPSocket或UDPSockett绑定到当前网络，使用callback回调。 |
| getAddressesByName(host: string, callback: AsyncCallback<Array<NetAddress>>): void; | 使用对应网络解析域名，获取所有IP，使用callback回调。 |
| getAddressByName(host: string, callback: AsyncCallback<NetAddress>): void; | 使用对应网络解析域名，获取一个IP，调用callback。 |
| on(type: 'netAvailable', callback: Callback<NetHandle>): void; | 订阅网络可用事件。 |
| on(type: 'netCapabilitiesChange', callback: Callback<NetCapabilityInfo>): void; | 订阅网络能力变化事件。 |
| on(type: 'netConnectionPropertiesChange', callback: Callback<{ netHandle: NetHandle, connectionProperties: ConnectionProperties }>): void; | 订阅网络连接信息变化事件。 |
| on(type: 'netBlockStatusChange', callback: Callback<{ netHandle: NetHandle, blocked: boolean }>): void; | 订阅网络阻塞状态事件，使用callback方式作为异步方法。 |
| on(type: 'netLost', callback: Callback<NetHandle>): void; | 订阅网络丢失事件。 |
| on(type: 'netUnavailable', callback: Callback<void>): void; | 订阅网络不可用事件。 |
| register(callback: AsyncCallback<void>): void; | 订阅指定网络状态变化的通知。 |
| unregister(callback: AsyncCallback<void>): void; | 取消订阅默认网络状态变化的通知。 |
接收指定网络的状态变化通知
1.  声明接口调用所需要的权限：ohos.permission.GET_NETWORK_INFO。 此权限级别为normal，在申请权限前，请保证符合权限使用的基本原则。然后参考访问控制-声明权限声明对应权限。
2.  从@kit.NetworkKit中导入connection命名空间。
3.  调用createNetConnection方法，指定网络能力、网络类型和超时时间(可选，如不传入代表默认网络；创建不同于默认网络时可通过指定这些参数完成)，创建一个NetConnection对象。
4.  调用该对象的on()方法，传入type和callback，订阅关心的事件。
5.  调用该对象的register()方法，订阅指定网络状态变化的通知。
6.  当网络可用时，会收到netAvailable事件的回调；当网络不可用时，会收到netUnavailable事件的回调。
7.  当不使用该网络时，可以调用该对象的unregister()方法，取消订阅。
```typescript
// 引入包名。
import { connection } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
let netSpecifier: connection.NetSpecifier = {
netCapabilities: {
// 假设当前默认网络是WiFi，需要创建蜂窝网络连接，可指定网络类型为蜂窝网。
bearerTypes: [connection.NetBearType.BEARER_CELLULAR],
// 指定网络能力为Internet。
networkCap: [connection.NetCap.NET_CAPABILITY_INTERNET]
},
};
// 指定超时时间为10s(默认值为0)。
let timeout = 10 * 1000;
// 创建NetConnection对象。
let conn = connection.createNetConnection(netSpecifier, timeout);
// 订阅指定网络状态变化的通知。
conn.register((err: BusinessError, data: void) => {
console.log(JSON.stringify(err));
});
// 订阅事件，如果当前指定网络可用，通过on_netAvailable通知用户。
conn.on('netAvailable', ((data: connection.NetHandle) => {
console.log("net is available, netId is " + data.netId);
}));
// 订阅事件，如果当前指定网络不可用，通过on_netUnavailable通知用户。
conn.on('netUnavailable', ((data: void) => {
console.log("net is unavailable, data is " + JSON.stringify(data));
}));
// 当不使用该网络时，可以调用该对象的unregister()方法，取消订阅。
conn.unregister((err: BusinessError, data: void) => {
});
```
监控默认网络变化并主动重建网络连接
根据当前网络状态及网络质量情况，默认网络可能会发生变化，如下所示。
本节旨在介绍监控默认网络的变化后，应用报文能够快速迁移到新默认网络上，具体做法如下。
监控默认网络变化
```typescript
import { connection } from '@kit.NetworkKit';
async function test() {
const netConnection = connection.createNetConnection();
/* 监听默认网络改变。 */
netConnection.on('netAvailable', (data: connection.NetHandle) => {
console.log(JSON.stringify(data));
});
}
```
默认网络变化后重新建立网络连接
原网络连接使用http模块建立网络连接
如果您使用了http模块建立网络连接，由于该模块没有提供Close接口用于关闭Socket，在切换默认网络并建立新的网络连接后原有Socket不会立即关闭。因此请切换使用Remote Communication Kit建立网络连接。
原网络连接使用Remote Communication Kit建立网络连接
```typescript
import { rcp } from '@kit.RemoteCommunicationKit';
import { connection } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
let session = rcp.createSession();
async function useRcp() {
/* 建立rcp请求。 */
try {
const request = await session.get('https://www.example.com');
console.info(request.statusCode.toString());
} catch (e) {
console.error(e.code.toString());
}
}
async function rcpTest() {
const netConnection = connection.createNetConnection();
netConnection.on('netAvailable', async (netHandle: connection.NetHandle) => {
/* 发生默认网络切换，重新建立session。 */
session.close();
session = rcp.createSession();
useRcp();
});
try {
netConnection.register(() => {
});
useRcp();
} catch (e) {
console.error(e.code.toString());
}
}
```
原网络连接使用Socket模块建立连接
```typescript
import { connection, socket } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
let sock: socket.TCPSocket = socket.constructTCPSocketInstance();
async function useSocket() {
let tcpConnectOptions: socket.TCPConnectOptions = {
address: {
address: '192.168.xx.xxx',
port: 8080
},
timeout: 6000
}
/* 建立socket连接。 */
sock.connect(tcpConnectOptions, (err: BusinessError) => {
if (err) {
console.error('connect fail');
return;
}
console.log('connect success');
/* 通过socket发送数据。 */
let tcpSendOptions: socket.TCPSendOptions = {
data: 'Hello, server!'
}
sock.send(tcpSendOptions).then(() => {
console.log('send success');
}).catch((err: BusinessError) => {
console.error('send fail');
});
})
}
async function socketTest() {
const netConnection = connection.createNetConnection();
netConnection.on('netAvailable', async (netHandle: connection.NetHandle) => {
console.log('default network changed');
await sock.close();
sock = socket.constructTCPSocketInstance();
useSocket();
});
try {
netConnection.register(() => {
});
useSocket();
} catch (e) {
console.error(e.code.toString());
}
}
```
原网络连接使用Socket Library建立网络连接
请在监控到默认网络变化后关闭原有Socket并重新建立Socket连接。
获取所有注册的网络
1.  声明接口调用所需要的权限：ohos.permission.GET_NETWORK_INFO。 此权限级别为normal，在申请权限前，请保证符合权限使用的基本原则。然后参考访问控制-声明权限声明对应权限。
2.  从@kit.NetworkKit中导入connection命名空间。
3.  调用getAllNets方法，获取所有处于连接状态的网络列表。
```typescript
// 引入包名。
import { connection } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
// 构造单例对象。
export class GlobalContext {
public netList: connection.NetHandle[] = [];
private constructor() {}
private static instance: GlobalContext;
private _objects = new Map<string, Object>();
public static getContext(): GlobalContext {
if (!GlobalContext.instance) {
GlobalContext.instance = new GlobalContext();
}
return GlobalContext.instance;
}
getObject(value: string): Object | undefined {
return this._objects.get(value);
}
setObject(key: string, objectClass: Object): void {
this._objects.set(key, objectClass);
}
}
// 获取所有处于连接状态的网络列表。
connection.getAllNets().then((data: connection.NetHandle[]) => {
console.info("Succeeded to get data: " + JSON.stringify(data));
if (data) {
GlobalContext.getContext().netList = data;
}
});
```
根据数据网络查询网络的能力信息及连接信息
1.  声明接口调用所需要的权限：ohos.permission.GET_NETWORK_INFO。 此权限级别为normal，在申请权限前，请保证符合权限使用的基本原则。然后参考访问控制-声明权限声明对应权限。
2.  从@kit.NetworkKit中导入connection命名空间。
3.  通过调用getDefaultNet方法，获取默认的数据网络(NetHandle)；或者通过调用getAllNets方法，获取所有处于连接状态的网络列表(Array<NetHandle>)。
4.  调用getNetCapabilities方法，获取NetHandle对应网络的能力信息。能力信息包含了网络类型(蜂窝网络、Wi-Fi网络、以太网网络等)、网络具体能力等网络信息。
5.  调用getConnectionProperties方法，获取NetHandle对应网络的连接信息。
```typescript
import { connection } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
// 构造单例对象。
export class GlobalContext {
public netList: connection.NetHandle[] = [];
public netHandle: connection.NetHandle|null = null;
private constructor() {}
private static instance: GlobalContext;
private _objects = new Map<string, Object>();
public static getContext(): GlobalContext {
if (!GlobalContext.instance) {
GlobalContext.instance = new GlobalContext();
}
return GlobalContext.instance;
}
getObject(value: string): Object | undefined {
return this._objects.get(value);
}
setObject(key: string, objectClass: Object): void {
this._objects.set(key, objectClass);
}
}
// 调用getDefaultNet方法，获取默认的数据网络(NetHandle)。
connection.getDefaultNet().then((data:connection.NetHandle) => {
if (data.netId == 0) {
// 当前无默认网络时，获取的netHandler的netid为0,属于异常情况，需要额外处理。
return;
}
if (data) {
console.info("getDefaultNet get data: " + JSON.stringify(data));
GlobalContext.getContext().netHandle = data;
// 获取netHandle对应网络的能力信息。能力信息包含了网络类型、网络具体能力等网络信息。
connection.getNetCapabilities(GlobalContext.getContext().netHandle).then(
(data: connection.NetCapabilities) => {
console.info("getNetCapabilities get data: " + JSON.stringify(data));
// 获取网络类型(bearerTypes)。
let bearerTypes: Set<number> = new Set(data.bearerTypes);
let bearerTypesNum = Array.from(bearerTypes.values());
for (let item of bearerTypesNum) {
if (item == 0) {
// 蜂窝网络。
console.log(JSON.stringify("BEARER_CELLULAR"));
} else if (item == 1) {
// Wi-Fi网络。
console.log(JSON.stringify("BEARER_WIFI"));
} else if (item == 3) {
// 以太网网络。
console.log(JSON.stringify("BEARER_ETHERNET"));
}
}
// 获取网络具体能力(networkCap)。
let itemNumber : Set<number> = new Set(data.networkCap);
let dataNumber = Array.from(itemNumber.values());
for (let item of dataNumber) {
if (item == 0) {
// 表示网络可以访问运营商的MMSC(Multimedia Message Service，多媒体短信服务)发送和接收彩信。
console.log(JSON.stringify("NET_CAPABILITY_MMS"));
} else if (item == 11) {
// 表示网络流量未被计费。
console.log(JSON.stringify("NET_CAPABILITY_NOT_METERED"));
} else if (item == 12) {
// 表示该网络应具有访问Internet的能力，该能力由网络提供者设置。
console.log(JSON.stringify("NET_CAPABILITY_INTERNET"));
} else if (item == 15) {
// 表示网络不使用VPN(Virtual Private Network，虚拟专用网络)。
console.log(JSON.stringify("NET_CAPABILITY_NOT_VPN"));
} else if (item == 16) {
// 表示该网络访问Internet的能力被网络管理成功验证，该能力由网络管理模块设置。
console.log(JSON.stringify("NET_CAPABILITY_VALIDATED"));
}
}
})
}
});
// 获取netHandle对应网络的连接信息。连接信息包含了链路信息、路由信息等。
connection.getConnectionProperties(GlobalContext.getContext().netHandle).then((data: connection.ConnectionProperties) => {
console.info("getConnectionProperties get data: " + JSON.stringify(data));
})
// 调用getAllNets,获取所有处于连接状态的网络列表(Array<NetHandle>)。
connection.getAllNets().then((data: connection.NetHandle[]) => {
console.info("getAllNets get data: " + JSON.stringify(data));
if (data) {
GlobalContext.getContext().netList = data;
let itemNumber : Set<connection.NetHandle> = new Set(GlobalContext.getContext().netList);
let dataNumber = Array.from(itemNumber.values());
for (let item of dataNumber) {
// 循环获取网络列表每个netHandle对应网络的能力信息。
connection.getNetCapabilities(item).then((data: connection.NetCapabilities) => {
console.info("getNetCapabilities get data: " + JSON.stringify(data));
})
// 循环获取网络列表每个netHandle对应的网络的连接信息。
connection.getConnectionProperties(item).then((data: connection.ConnectionProperties) => {
console.info("getConnectionProperties get data: " + JSON.stringify(data));
})
}
}
})
```
使用对应网络解析域名，获取所有IP
1.  声明接口调用所需要的权限：ohos.permission.INTERNET 此权限级别为normal，在申请权限前，请保证符合权限使用的基本原则。然后参考访问控制-声明权限声明对应权限。
2.  从@kit.NetworkKit中导入connection命名空间。
3.  调用getAddressesByName方法，使用默认网络解析主机名以获取所有IP地址。
```typescript
// 引入包名。
import { connection } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
// 使用默认网络解析主机名以获取所有IP地址。
connection.getAddressesByName("xxxx").then((data: connection.NetAddress[]) => {
console.info("Succeeded to get data: " + JSON.stringify(data));
});
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/native-netmanager-guidelines-V14
爬取时间: 2025-04-28 07:18:27
来源: Huawei Developer
场景介绍
NetConnection模块提供了常用网络信息查询的能力。
接口说明
NetConnection常用接口如下表所示，详细的接口说明请参考NetConnection
| 接口名 | 描述 |
| --- | --- |
| OH_NetConn_HasDefaultNet(int32_t *hasDefaultNet) | 检查默认数据网络是否被激活，判断设备是否有网络连接，以便在应用程序中采取相应的措施。 |
| OH_NetConn_GetDefaultNet(NetConn_NetHandle *netHandle) | 获得默认激活的数据网络。 |
| OH_NetConn_IsDefaultNetMetered(int32_t *isMetered) | 检查当前网络上的数据流量使用是否被计量 |
| OH_NetConn_GetConnectionProperties(NetConn_NetHandle *netHandle, NetConn_ConnectionProperties *prop) | 获取netHandle对应的网络的连接信息。 |
| OH_NetConn_GetNetCapabilities (NetConn_NetHandle *netHandle, NetConn_NetCapabilities *netCapacities) | 获取netHandle对应的网络的能力信息。 |
| OH_NetConn_GetDefaultHttpProxy (NetConn_HttpProxy *httpProxy) | 获取网络默认的代理配置信息。 如果设置了全局代理，则会返回全局代理配置信息。如果进程已经绑定到指定netHandle对应的网络，则返回网络句柄对应网络的代理配置信息。在其它情况下，将返回默认网络的代理配置信息。 |
| OH_NetConn_GetAddrInfo (char *host, char *serv, struct addrinfo *hint, struct addrinfo **res, int32_t netId) | 通过netId获取DNS结果。 |
| OH_NetConn_FreeDnsResult(struct addrinfo *res) | 释放DNS结果内存。 |
| OH_NetConn_GetAllNets(NetConn_NetHandleList *netHandleList) | 获取所有处于连接状态的网络列表。 |
| OHOS_NetConn_RegisterDnsResolver(OH_NetConn_CustomDnsResolver resolver) | 注册自定义dns解析器。 弃用： 从API version 13开始废弃。 替代： 推荐使用OH_NetConn_RegisterDnsResolver。 |
| OHOS_NetConn_UnregisterDnsResolver(void) | 去注册自定义dns解析器。 弃用： 从API version 13开始废弃。 替代： 推荐使用OH_NetConn_UnregisterDnsResolver。 |
| OH_NetConn_RegisterDnsResolver(OH_NetConn_CustomDnsResolver resolver) | 注册自定义dns解析器。 |
| OH_NetConn_UnregisterDnsResolver(void) | 去注册自定义dns解析器。 |
接口名
描述
OH_NetConn_HasDefaultNet(int32_t *hasDefaultNet)
检查默认数据网络是否被激活，判断设备是否有网络连接，以便在应用程序中采取相应的措施。
OH_NetConn_GetDefaultNet(NetConn_NetHandle *netHandle)
获得默认激活的数据网络。
OH_NetConn_IsDefaultNetMetered(int32_t *isMetered)
检查当前网络上的数据流量使用是否被计量
OH_NetConn_GetConnectionProperties(NetConn_NetHandle *netHandle, NetConn_ConnectionProperties *prop)
获取netHandle对应的网络的连接信息。
OH_NetConn_GetNetCapabilities (NetConn_NetHandle *netHandle, NetConn_NetCapabilities *netCapacities)
获取netHandle对应的网络的能力信息。
OH_NetConn_GetDefaultHttpProxy (NetConn_HttpProxy *httpProxy)
获取网络默认的代理配置信息。 如果设置了全局代理，则会返回全局代理配置信息。如果进程已经绑定到指定netHandle对应的网络，则返回网络句柄对应网络的代理配置信息。在其它情况下，将返回默认网络的代理配置信息。
OH_NetConn_GetAddrInfo (char *host, char *serv, struct addrinfo *hint, struct addrinfo **res, int32_t netId)
通过netId获取DNS结果。
OH_NetConn_FreeDnsResult(struct addrinfo *res)
释放DNS结果内存。
OH_NetConn_GetAllNets(NetConn_NetHandleList *netHandleList)
获取所有处于连接状态的网络列表。
OHOS_NetConn_RegisterDnsResolver(OH_NetConn_CustomDnsResolver resolver)
注册自定义dns解析器。
弃用：从API version 13开始废弃。
替代：推荐使用OH_NetConn_RegisterDnsResolver。
OHOS_NetConn_UnregisterDnsResolver(void)
去注册自定义dns解析器。
弃用：从API version 13开始废弃。
替代：推荐使用OH_NetConn_UnregisterDnsResolver。
OH_NetConn_RegisterDnsResolver(OH_NetConn_CustomDnsResolver resolver)
注册自定义dns解析器。
OH_NetConn_UnregisterDnsResolver(void)
去注册自定义dns解析器。
网络管理接口开发示例
开发步骤
使用本文档涉及接口获取网络相关信息时，需先创建Native C++工程，在源文件中将相关接口封装，再在ArkTs层对封装的接口进行调用，使用hilog或者console.log等手段选择打印在控制台或者生成设备日志。
本文以实现获取默认激活的数据网络为例，给出具体的开发指导。
其他接口开发请参考：示例代码。
添加开发依赖
添加动态链接库
CMakeLists.txt中添加以下lib:
头文件
构建工程
1、在源文件中编写调用该API的代码，并将结果封装成一个napi_value类型的值返回给 Node.js 环境。
简要说明：这两个函数是用于获取系统默认网络连接的相关信息的。其中，GetDefaultNet是接收ArkTs端传入的测试参数，返回调用接口后对应的返回值，param可以自行调整；如果返回值为0，代表获取成功，401代表参数错误，201代表没有权限；而NetId函数则用于获取默认网络连接的ID。这些信息可以用于进一步的网络操作。
2、将通过napi封装好的napi_value类型对象初始化导出，通过外部函数接口，将以上两个函数暴露给JavaScript使用。
3、将上一步中初始化成功的对象通过RegisterEntryModule函数，使用napi_module_register函数将模块注册到 Node.js 中。
4、在工程的index.d.ts文件中定义两个函数的类型。
```typescript
export const GetDefaultNet: (code: number) => number;
export const NetId: () => number;
```
5、在index.ets文件中对上述封装好的接口进行调用。
```typescript
import testNetManager from 'libentry.so';
@Entry
@Component
struct Index {
@State message: string = '';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Button('GetDefaultNet').onClick(event => {
this.GetDefaultNet();
})
Button('CodeNumber').onClick(event =>{
this.CodeNumber();
})
}
.width('100%')
}
.height('100%')
}
GetDefaultNet() {
let netid = testNetManager.NetId();
console.log("The defaultNetId is [" + netid + "]");
}
CodeNumber() {
let testParam = 0;
let codeNumber = testNetManager.GetDefaultNet(testParam);
if (codeNumber === 0) {
console.log("Test success. [" + codeNumber + "]");
} else if (codeNumber === 201) {
console.log("Missing permissions. [" + codeNumber + "]");
} else if (codeNumber === 401) {
console.log("Parameter error. [" + codeNumber + "]");
}
}
}
```
6、配置CMakeLists.txt，本模块需要用到的共享库是libnet_connection.so，在工程自动生成的CMakeLists.txt中的target_link_libraries中添加此共享库。
注意：如图所示，在add_library中的entry是工程自动生成的modename，若要做修改，需和步骤3中.nm_modname保持一致；
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250328150005.62127375802465169992670056255834:50001231000000:2800:EE76FF839CA7D63FEEEBE6F10A54D40B10F528F510E87D538DA5FD6A30CCBEA5.png)
经过以上步骤，整个工程的搭建已经完成，接下来就可以连接设备运行工程进行日志查看了。
测试步骤
1、连接设备，使用DevEco Studio打开搭建好的工程。
2、运行工程，设备上会弹出以下所示图片：
简要说明：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250328150005.04813874723957190159712317913632:50001231000000:2800:F6BA7F1BB1944670E6767BCF6E69B0CAA999C47003F89D05281EDE790BA1ED9E.png)
3、点击 GetDefaultNet 按钮，控制台会打印日志：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250328150005.54148342471112776904105305726528:50001231000000:2800:89D859A36144ACC998AE1186F060BD0B06B69AC94A2F70D867B2A3BAC4219583.png)
4、点击 codeNumber 按钮，控制台会打印相应的响应状态码：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250328150005.12745540744535739072768176710457:50001231000000:2800:F3FD209B9CB566C806C8014D0DF07DAA887AD4629FF380877D537822A6E04BB7.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/net-statistics-V14
爬取时间: 2025-04-28 07:18:41
来源: Huawei Developer
简介
流量管理提供了基于物理网络的数据流量统计能力，支持基于网卡/UID 的流量统计。
流量管理主要实现功能有：
为了保证应用的运行效率，大部分 API 调用都是异步的，对于异步调用的 API 均提供了 callback 和 Promise 两种方式，以下示例均采用 Promise 函数，更多方式可以查阅API 参考。
以下分别介绍具体开发方式。
接口说明
完整的 JS API 说明以及实例代码请参考：statistics 链接。
| 接口名 | 描述 |
| --- | --- |
| getIfaceRxBytes(nic: string, callback: AsyncCallback<number>): void; | 获取指定网卡实时下行流量数据。 |
| getIfaceTxBytes(nic: string, callback: AsyncCallback<number>): void; | 获取指定网卡实时上行流量数据。 |
| getCellularRxBytes(callback: AsyncCallback<number>): void; | 获取蜂窝实时下行流量数据。 |
| getCellularTxBytes(callback: AsyncCallback<number>): void; | 获取蜂窝实时上行流量数据。 |
| getAllRxBytes(callback: AsyncCallback<number>): void; | 获取所有网卡实时下行流量数据。 |
| getAllTxBytes(callback: AsyncCallback<number>): void; | 获取所有网卡实时上行流量数据。 |
| getUidRxBytes(uid: number, callback: AsyncCallback<number>): void; | 获取指定应用实时下行流量数据。 |
| getUidTxBytes(uid: number, callback: AsyncCallback<number>): void; | 获取指定应用实时上行流量数据。 |
| getSockfdRxBytes(sockfd: number, callback: AsyncCallback<number>): void; | 获取指定socket实时下行流量数据。 |
| getSockfdTxBytes(sockfd: number, callback: AsyncCallback<number>): void; | 获取指定socket实时上行流量数据。 |
获取网卡/UID 的实时流量统计数据
```typescript
// 从@kit.NetworkKit中导入statistics命名空间
import { statistics, socket } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
// 获取指定网卡实时下行流量数据。
statistics.getIfaceRxBytes("wlan0").then((stats: number) => {
console.log(JSON.stringify(stats));
});
// 获取指定网卡实时上行流量数据。
statistics.getIfaceTxBytes("wlan0").then((stats: number) => {
console.log(JSON.stringify(stats));
});
// 获取蜂窝实时下行流量数据。
statistics.getCellularRxBytes().then((stats: number) => {
console.log(JSON.stringify(stats));
});
// 获取蜂窝实时上行流量数据。
statistics.getCellularTxBytes().then((stats: number) => {
console.log(JSON.stringify(stats));
});
// 获取所有网卡实时下行流量数据。
statistics.getAllRxBytes().then((stats: number) => {
console.log(JSON.stringify(stats));
});
// 获取所有网卡实时上行流量数据。
statistics.getAllTxBytes().then((stats: number) => {
console.log(JSON.stringify(stats));
});
// 获取指定应用实时下行流量数据。
let uid = 20010038;
statistics.getUidRxBytes(uid).then((stats: number) => {
console.log(JSON.stringify(stats));
});
// 获取指定应用实时上行流量数据。
let uids = 20010038;
statistics.getUidTxBytes(uids).then((stats: number) => {
console.log(JSON.stringify(stats));
});
// 获取指定socket实时下行流量数据。
let tcp: socket.TCPSocket = socket.constructTCPSocketInstance();
tcp.getSocketFd().then((sockfd: number) => {
statistics.getSockfdRxBytes(sockfd).then((stats: number) => {
console.log(JSON.stringify(stats));
}).catch((err: BusinessError) => {
console.error(JSON.stringify(err));
});
});
// 获取指定socket实时上行流量数据。
tcp.getSocketFd().then((sockfd: number) => {
statistics.getSockfdTxBytes(sockfd).then((stats: number) => {
console.log(JSON.stringify(stats));
}).catch((err: BusinessError) => {
console.error(JSON.stringify(err));
});
});
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/net-vpnextension-V14
爬取时间: 2025-04-28 07:18:54
来源: Huawei Developer
简介
VPN，即虚拟专用网络（Virtual Private Network），是在公用网络上建立专用网络的一种技术。在VPN网络中，任意两个节点间的连接并非依赖传统专用网络所需要的端到端的物理链路，而是构建在公用网络服务商提供的平台（如Internet）之上的逻辑网络。用户数据在这一逻辑链路中进行传输。
HarmonyOS为开发者提供了用于创建VPN的API解决方案。本文将指导您如何开发自己的VPN客户端。
为了保证应用的运行效率，所有API调用都是异步的，对于异步调用的API均提供了Promise的方式，以下示例均采用Promise方式，更多方式可以查阅API参考。
VPN应用的显示体验
借助系统提供的VPN Extension接口开发者可以构建支持不同协议的VPN服务。HarmonyOS系统提供了界面 (UI) 使用户可以了解当前VPN应用服务的启动和连接：
为了使用户可以方便的查看和配置，您的VPN应用还需要提供以下界面：
接口说明
完整的JS API说明以及示例代码请参考：VPN扩展应用API。
创建VPN Extension Ability
如果想使您的应用支持VPN能力，首先您需要创建一个继承于VpnExtensionAbility的extensionAbilities。
```typescript
// 举例：在应用的module.json5中定义MyVpnExtAbility
"extensionAbilities": [
{
"name": "MyVpnExtAbility",
"description": "vpnservice",
"type": "vpn",
"srcEntry": "./ets/serviceextability/MyVpnExtAbility.ts"
}
]
```
如果DevEco Studio工具提示不能识别"type": "vpn"，需要您手动在SDK的toolchains\modulecheck\module.json文件中，给extensionAbilities对应的type枚举添加"vpn"定义，并清除build缓存。
接下来您需要在创建的VpnExtensionAbility中实现VPN的配置、启动和停止操作：
启动VPN Extension Ability
当VPN应用启动VPN连接时，需要调用startVpnExtensionAbility接口，携带需要启动的VpnExtensionAbility信息，其中bundleName需要与您的VPN应用bundleName一致，abilityName为您在前面创建的VpnExtensionAbility名。您可参考如下示例：
```typescript
import { common, Want } from '@kit.AbilityKit';
import { vpnExtension } from '@kit.NetworkKit';
let context = getContext(this) as common.VpnExtensionContext;
let want: Want = {
deviceId: "",
bundleName: "com.example.myvpndemo",
abilityName: "MyVpnExtAbility",
};
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold).onClick(() => {
console.info("btn click") })
Button('Start Extension').onClick(() => {
vpnExtension.startVpnExtensionAbility(want);
}).width('70%').fontSize(45).margin(16)
}.width('100%')
}.height('100%')
}
}
```
如果您的VPN应用未获取用户信任，系统将弹出VPN连接的授权对话框，当获取用户授权后，系统将自动调用并启动您实现的VPN Extension Ability的onCreate方法将被调用。
目前系统仅支持启动一个VPN连接服务，当VPN已经启动时应用新调用启动接口会收到系统拒绝错误，此时建议您的应用可以提醒用户先断开当前已经激活的VPN应用连接。
停止VPN Extension Ability
当VPN应用需要停止VPN连接时，需要调用stopVpnExtensionAbility接口，携带需要停止的VpnExtensionAbility信息。系统会对调用方做权限校验，stopVpnExtensionAbility的调用方应用必须获取了用户的VPN信任授权，且只允许停止应用自己启动的VpnExtensionAbility，所以接口传入的参数中bundleName需要与您的VPN应用bundleName一致，abilityName为指定停止VPN的VpnExtensionAbility名。
您可参考如下示例：
```typescript
import { common, Want } from '@kit.AbilityKit';
import { vpnExtension } from '@kit.NetworkKit';
let context = getContext(this) as common.VpnExtensionContext;
let want: Want = {
deviceId: "",
bundleName: "com.example.myvpndemo",
abilityName: "MyVpnExtAbility",
};
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold).onClick(() => {
console.info("btn click") })
Button('Start Extension').onClick(() => {
vpnExtension.startVpnExtensionAbility(want);
}).width('70%').fontSize(45).margin(16)
Button('Stop Extension').onClick(() => {
console.info("btn end")
vpnExtension.stopVpnExtensionAbility(want);
}).width('70%').fontSize(45).margin(16)
}.width('100%')
}.height('100%')
}
}
```
stopVpnExtensionAbility后，您的VPN Extension Ability的onDestroy方法将被调用，您可在此时destroy vpn连接。
```typescript
import { vpnExtension, VpnExtensionAbility } from '@kit.NetworkKit';
import { common, Want } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
let context: vpnExtension.VpnExtensionContext;
export default class MyVpnExtAbility extends VpnExtensionAbility {
onDestroy() {
let VpnConnection : vpnExtension.VpnConnection = vpnExtension.createVpnConnection(context);
console.info("vpn createVpnConnection: " + JSON.stringify(VpnConnection));
VpnConnection.destroy().then(() => {
console.info("destroy success.");
}).catch((error : BusinessError) => {
console.error("destroy fail" + JSON.stringify(error));
});
}
}
```
服务生命周期
为了保障设备的网络连接，当系统观察到VPN相关应用出现异常时会主动停止VPN连接：
VPN Config参数说明
| 名称 | 类型 | 必填 | 说明 |
| --- | --- | --- | --- |
| addresses | Array<LinkAddress> | 是 | VPN虚拟网卡的IP地址。 |
| routes | Array<RouteInfo> | 否 | VPN虚拟网卡的路由信息(目前最多可配置1024条路由)。 |
| dnsAddresses | Array<string> | 否 | DNS服务器地址信息。配置后VPN白名单的应用访问网络时使用这些DNS服务器，不配置则使用系统分配的DNS服务器地址。 |
| searchDomains | Array<string> | 否 | DNS的搜索域列表。 |
| mtu | number | 否 | 最大传输单元MTU值(单位:字节)。 |
| isIPv4Accepted | boolean | 否 | 是否支持IPV4，默认值为true。 |
| isIPv6Accepted | boolean | 否 | 是否支持IPV6，默认值为false。 |
| isInternal | boolean | 否 | 是否支持内置VPN，默认值为false。 |
| isBlocking | boolean | 否 | 是否阻塞模式，默认值为false。 |
| trustedApplications | Array<string> | 否 | VPN生效的应用白名单信息，string类型表示的包名。 |
| blockedApplications | Array<string> | 否 | 不生效VPN的应用黑名单信息，string类型表示的包名。 |
名称
类型
必填
说明
addresses
Array<LinkAddress>
是
VPN虚拟网卡的IP地址。
routes
Array<RouteInfo>
否
VPN虚拟网卡的路由信息(目前最多可配置1024条路由)。
dnsAddresses
Array<string>
否
DNS服务器地址信息。配置后VPN白名单的应用访问网络时使用这些DNS服务器，不配置则使用系统分配的DNS服务器地址。
searchDomains
Array<string>
否
DNS的搜索域列表。
mtu
number
否
最大传输单元MTU值(单位:字节)。
isIPv4Accepted
boolean
否
是否支持IPV4，默认值为true。
isIPv6Accepted
boolean
否
是否支持IPV6，默认值为false。
isInternal
boolean
否
是否支持内置VPN，默认值为false。
isBlocking
boolean
否
是否阻塞模式，默认值为false。
trustedApplications
Array<string>
否
VPN生效的应用白名单信息，string类型表示的包名。
blockedApplications
Array<string>
否
不生效VPN的应用黑名单信息，string类型表示的包名。
示例：
VPN Demo示例
OpenHarmony开源项目包含一个名为VPN的示例应用。此应用展示了如何设置和连接 VPN 服务。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/network-boost-kit-guide-V14
爬取时间: 2025-04-28 07:19:08
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/networkboost-introduction-V14
爬取时间: 2025-04-28 07:19:21
来源: Huawei Developer
Network Boost Kit（网络加速服务）提供网络加速能力以及网络感知、网络质量预测等能力，通过软、硬、芯、端、管、云等全方位的协同解决方案实现网络资源的调优和加速，从而构筑更可靠、更流畅、更高速的上网体验。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/networkboost-preparations-V14
爬取时间: 2025-04-28 07:19:35
来源: Huawei Developer
申请权限
场景概述
应用在使用Network Boost Kit能力前需要检查是否已经获取对应权限。如未获得授权，需要声明对应权限。
Network Boost Kit所需权限有：
ohos.permission.GET_NETWORK_INFO：用户获取设备网络信息。
必须手动配置上述权限后才能使用，详细配置参见申请权限步骤。
申请权限步骤
需要在entry/src/main路径下的module.json5中配置所需申请的权限。示例代码如下所示：
```typescript
{
"module": {
"requestPermissions": [
{
"name": "ohos.permission.GET_NETWORK_INFO"
}
]
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/networkboost-netqualityguide-V14
爬取时间: 2025-04-28 07:19:49
来源: Huawei Developer
系统提供网络质量评估、网络场景识别、弱信号预测等网络质量的相关能力，应用可以根据网络质量信息快速调整应用数传策略（缓存、调速等），实现网络自适应。同时应用还可以通过系统的传输体验反馈接口将应用传输体验告知系统，系统综合决策后进行网络加速，从而提升用户的上网体验。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/networkboost-qoscallback-V14
爬取时间: 2025-04-28 07:20:02
来源: Huawei Developer
场景介绍
应用在订阅网络质量Qos评估后，系统按照一定的周期或Qos变化后回调给应用。回调的Qos信息包括数据传输的链路类型、上下行空口实时带宽、上下行空口实时速率、RTT时延等。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| on(type: 'netQosChange', callback: Callback<Array<NetworkQos>>): void | 订阅Qos信息状态变化。 |
| off(type: 'netQosChange', callback?: Callback<Array<NetworkQos>>): void | 取消订阅Qos信息状态变化。 |
接口名
描述
on(type: 'netQosChange', callback: Callback<Array<NetworkQos>>): void
订阅Qos信息状态变化。
off(type: 'netQosChange', callback?: Callback<Array<NetworkQos>>): void
取消订阅Qos信息状态变化。
开发步骤
1.
```typescript
import { netQuality } from '@kit.NetworkBoostKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.
```typescript
try {
netQuality.on('netQosChange', (list: Array<netQuality.NetworkQos>) => {
if (list.length > 0) {
list.forEach((qos) => {
// 回调信息处理
console.info(`数据链路类型: ${JSON.stringify(qos.pathType )}.` );
console.info(`该数据链路类型的上行带宽: ${JSON.stringify(qos.linkUpBandwidth)}.` );
console.info(`该数据链路类型的下行带宽: ${JSON.stringify(qos.linkDownBandwidth)}.` );
// 单位为bps，若需转化为B/s，数值需要除以8
console.info(`该数据链路类型的上行速率: ${JSON.stringify(qos.linkUpRate)}.` );
// 单位为bps，若需转化为B/s，数值需要除以8
console.info(`该数据链路类型的下行速率: ${JSON.stringify(qos.linkDownRate)}.` );
// 实时速率为上行速率和下行速率之和
console.info(`该数据链路类型的实时速率(B/s): ${JSON.stringify((qos.linkUpRate+ qos.linkDownRate) / 8)}.`);
console.info(`该数据链路类型的RTT时延: ${JSON.stringify(qos.rttMs)}.` );
console.info(`该数据链路类型的上行发送空口缓冲时延: ${JSON.stringify(qos.linkUpBufferDelayMs )}.`);
});
}
});
} catch (err) {
console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
```
3.
```typescript
try {
netQuality.off('netQosChange');
} catch (err) {
console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/networkboost-scenecallback-V14
爬取时间: 2025-04-28 07:20:16
来源: Huawei Developer
场景介绍
应用在订阅网络场景识别后，系统在网络场景实时信息或预测信息发生变化后回调给应用，回调的网络场景信息包括数据传输的链路类型、网络场景类型、数传策略建议、弱信号信息等。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| on(type: 'netSceneChange', callback: Callback<Array<NetworkScene>>): void | 订阅网络场景信息状态变化。 |
| off(type: 'netSceneChange', callback?: Callback<Array<NetworkScene>>): void | 取消订阅网络场景信息状态变化。 |
接口名
描述
on(type: 'netSceneChange', callback: Callback<Array<NetworkScene>>): void
订阅网络场景信息状态变化。
off(type: 'netSceneChange', callback?: Callback<Array<NetworkScene>>): void
取消订阅网络场景信息状态变化。
开发步骤
1.
```typescript
import { netQuality } from '@kit.NetworkBoostKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.
```typescript
try {
netQuality.on('netSceneChange', (list: Array<netQuality.NetworkScene>) => {
if (list.length > 0) {
list.forEach((sceneInfo) => {
// 网络场景识别回调信息处理
if (sceneInfo.scene == 'congestion') {
// 网络拥塞分支处理
}
if (sceneInfo.weakSignalPrediction) {
// 存在弱信号预测信息，对弱信号预测信息进行处理
}
});
}
});
} catch (err) {
console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
```
3.
```typescript
try {
netQuality.off('netSceneChange');
} catch (err) {
console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/networkboost-appreportqoe-V14
爬取时间: 2025-04-28 07:20:29
来源: Huawei Developer
场景介绍
当应用传输体验发生变化时，应用将传输体验和传输的业务类型信息通过实时反馈接口传输给系统网络业务模块，系统网络业务模块进行精细化调度，实现网络加速。
例如：视频类App播放过程中卡顿，将卡顿信息上报后，Network Boost Kit将信息反馈给系统网络加速模块，该模块会记录播放卡顿信息，并根据当前网络情况，启用网络加速能力。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| reportQoe(appQoe: AppQoe): void | 应用反馈传输体验信息。 |
接口名
描述
reportQoe(appQoe: AppQoe): void
应用反馈传输体验信息。
开发步骤
1.
```typescript
import { netQuality } from '@kit.NetworkBoostKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.
```typescript
try{
let serviceType: netQuality.ServiceType = 'shortVideo';
let qoeType: netQuality.BadQoeCause = 'serverErr';
let appQoE: netQuality.AppQoe = {
serviceType,
qoeType
};
netQuality.reportQoe(appQoE);
} catch (err) {
console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/networkboost-weaksignaljudge-V14
爬取时间: 2025-04-28 07:20:43
来源: Huawei Developer
通过网络质量评估和网络场景识别章节，弱网感知判决可归纳为3种方式获取：
方法1（监听系统实时判决）：
根据网络场景识别信息，如NetworkScene.scene(weakSignal/congestion)系统直接判决为弱网。
方法2（监听系统预测判决）：
根据网络场景识别中的弱信号预测信息，如NetworkScene.weakSignalPrediction系统预测即将进入弱网区域。
方法3（应用自定义判决）：
根据网络质量评估信息，如NetworkQos(linkUpBandwidth/linkDownBandwidth/rttMs/linkUpBufferDelayMs/linkUpBufferCongestionPercent)，应用自定义门限来判决为弱网。
应用可根据自身业务特点，选择其中一种或多种使用。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/networkboost-nethandoverguide-V14
爬取时间: 2025-04-28 07:21:37
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/networkboost-nethandovercallback-V14
爬取时间: 2025-04-28 07:21:50
来源: Huawei Developer
场景介绍
在弱网环境下，系统发起多网迁移（WiFi<->蜂窝，主卡<->副卡等）的过程中，给应用提供连接迁移开始和完成通知，应用根据连接迁移通知的建议进行重建，快速恢复业务，给用户带来平滑、高速、低时延的上网体验。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| on(type: 'handoverChange', callback: Callback<HandoverInfo>): void | 订阅连接迁移。 |
| off(type: 'handoverChange', callback?: Callback<HandoverInfo>): void | 取消订阅连接迁移。 |
接口名
描述
on(type: 'handoverChange', callback: Callback<HandoverInfo>): void
订阅连接迁移。
off(type: 'handoverChange', callback?: Callback<HandoverInfo>): void
取消订阅连接迁移。
开发步骤
1.
```typescript
import { netHandover } from '@kit.NetworkBoostKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.
```typescript
try {
netHandover.on('handoverChange', (info: netHandover.HandoverInfo) => {
if (info.handoverStart) {
// 连接迁移开始回调，应用按照HandoverStart的建议调整数传策略
console.info('handover start');
} else if (info.handoverComplete) {
// 连接迁移完成回调，应用按照HandoverComplete的建议进行调速和重建恢复
console.info('handover complete');
}
});
} catch (err) {
console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
```
3.
```typescript
try {
netHandover.off('handoverChange');
} catch (err) {
console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/networkboost-reporthandovermode-V14
爬取时间: 2025-04-28 07:22:04
来源: Huawei Developer
场景介绍
应用可通过该接口变更连接迁移模式，包括委托模式由系统发起连接迁移，和自主模式由应用发起连接迁移。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| setHandoverMode(mode: HandoverMode): void | 应用设置迁移模式，默认为委托模式。 |
接口名
描述
setHandoverMode(mode: HandoverMode): void
应用设置迁移模式，默认为委托模式。
开发步骤
1.
```typescript
import { netHandover} from '@kit.NetworkBoostKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.
```typescript
try{
let mode: netHandover.HandoverMode = netHandover.HandoverMode.DISCRETION;
netHandover.setHandoverMode(mode);
} catch (err) {
console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-kit-guide-V14
爬取时间: 2025-04-28 07:22:17
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-introduction-V14
爬取时间: 2025-04-28 07:22:31
来源: Huawei Developer
概述
Remote Communication Kit提供了网络数据请求功能，相较于Network Kit中HTTP请求能力，更具易用性，且拥有更多的功能，见与相关Kit的关系。在开发过程中，如果有些场景使用Network Kit中HTTP请求能力达不到预期或无法实现，那么就可以尝试使用Remote Communication Kit中的数据请求功能来实现。
Remote Communication Kit还提供了URPC（Unified Remote Procedure Call）高性能rpc通信库，拥有构筑远程函数调用能力，具有抗弱网传输、多径传输（5G和Wifi）等特征。应用可以通过URPC完成简单方便的远程过程调用。
基本概念
HTTP（Hypertext Transfer Protocol）是一种用于传输数据的协议，它是基于客户端-服务器模型的，客户端向服务器发出请求，服务器返回响应。
HTTP请求是客户端向服务器发送请求的过程，包括以下基本概念：
| 请求类型  | 说明  |
| --- | --- |
| GET  | 获取资源，用于请求特定资源的表示形式。 常用场景：用于获取资源，如网页、图片、视频等。  |
| POST  | 提交资源，用于提交实体，通常用于提交表单数据。 常用场景：用于提交数据，如表单数据、上传文件等。  |
| OPTIONS  | 获取资源支持的HTTP方法，用于请求有关目标资源的通信选项。 常用场景：用于获取资源支持的HTTP方法，如获取某个API支持的请求方式。  |
| HEAD  | 获取资源的元数据，与GET方法类似，但不返回资源的主体部分，只返回资源的元数据，如响应头。 常用场景：用于获取资源的头部信息，如文件大小、修改时间等。  |
| PUT  | 更新资源，用于修改已经存在服务器上的资源。对指定URL路径上的资源进行完全替换。 常用场景：用于更新资源，如更新文件、修改数据库记录等。  |
| DELETE  | 删除资源，用于删除目标资源。 常用场景：用于删除资源的操作，比如删除用户、删除文章等。  |
| PATCH  | 更新资源的一部分，用于对资源进行局部修改。 常用场景：更新服务器局部资源，比如资源的某些属性和字段，因此不需要替换整个资源。  |
请求类型
说明
GET
获取资源，用于请求特定资源的表示形式。
常用场景：用于获取资源，如网页、图片、视频等。
POST
提交资源，用于提交实体，通常用于提交表单数据。
常用场景：用于提交数据，如表单数据、上传文件等。
OPTIONS
获取资源支持的HTTP方法，用于请求有关目标资源的通信选项。
常用场景：用于获取资源支持的HTTP方法，如获取某个API支持的请求方式。
HEAD
获取资源的元数据，与GET方法类似，但不返回资源的主体部分，只返回资源的元数据，如响应头。
常用场景：用于获取资源的头部信息，如文件大小、修改时间等。
PUT
更新资源，用于修改已经存在服务器上的资源。对指定URL路径上的资源进行完全替换。
常用场景：用于更新资源，如更新文件、修改数据库记录等。
DELETE
删除资源，用于删除目标资源。
常用场景：用于删除资源的操作，比如删除用户、删除文章等。
PATCH
更新资源的一部分，用于对资源进行局部修改。
常用场景：更新服务器局部资源，比如资源的某些属性和字段，因此不需要替换整个资源。
与相关Kit的关系
为了方便了解Remote Communication Kit与NetWork Kit的区别，可以从功能分类、功能名称和功能描述这三个方面进行对比，主要区别如下：
| 功能分类  | 功能名称  | 功能描述  | NetWork Kit  | Remote Communication Kit  |
| --- | --- | --- | --- | --- |
| 基础功能  | 发送PATCH类型请求  | 以PATCH的方式请求。  | 不支持  | 支持  |
| 基础功能  | 设置会话中URL的基地址  | 会话中URL的基地址将自动加在URL前面，除非URL是一个绝对的URL。  | 不支持  | 支持  |
| 基础功能  | 取消自动重定向  | HTTP请求自动重定向。  | 不支持  | 支持  |
| 基础功能  | 拦截请求和响应  | 在请求后或响应前进行拦截。  | 不支持  | 支持  |
| 基础功能  | 取消请求  | 发送请求前取消、发送请求过程中取消、请求接收后取消。  | 不支持  | 支持  |
| 基础功能  | 响应缓存  | 是否使用缓存，请求时优先读取缓存。缓存跟随当前进程生效，新缓存会替换旧缓存  | 不支持  | 支持  |
| 基础功能  | 设置响应数据的类型  | 设置数据以何种方式返回，将要响应的数据类型可设置为string、object、arraybuffer等类型。  | 支持  | 不支持  |
| 基础功能  | 定义允许的HTTP响应内容的最大字节数  | 服务器成功响应时，在获取数据前校验响应内容的最大字节数。  | 支持  | 不支持  |
| 证书验证  | 自定义证书校验  | 自定义逻辑校验客户端和服务端的证书，判断是否可以连接。  | 不支持  | 支持  |
| 证书验证  | 忽略SSL校验  | 在建立SSL连接时不验证服务器端的SSL证书。  | 不支持  | 支持  |
| DNS  | 自定义DNS解析  | 包括自定义DNS服务器或静态DNS规则  | 不支持  | 支持  |
| Remote Communication Kit特有  | 捕获详细的跟踪信息  | 在会话中的HTTP请求期间捕获详细的跟踪信息。跟踪有助于调试、性能分析和深入了解通信过程中的数据流。  | 不支持  | 支持  |
| Remote Communication Kit特有  | 数据打点，获取HTTP请求的具体数据  | HTTP请求各阶段的定时信息。  | 不支持  | 支持  |
功能分类
功能名称
功能描述
NetWork Kit
Remote Communication Kit
基础功能
发送PATCH类型请求
以PATCH的方式请求。
不支持
支持
基础功能
设置会话中URL的基地址
会话中URL的基地址将自动加在URL前面，除非URL是一个绝对的URL。
不支持
支持
基础功能
取消自动重定向
HTTP请求自动重定向。
不支持
支持
基础功能
拦截请求和响应
在请求后或响应前进行拦截。
不支持
支持
基础功能
取消请求
发送请求前取消、发送请求过程中取消、请求接收后取消。
不支持
支持
基础功能
响应缓存
是否使用缓存，请求时优先读取缓存。缓存跟随当前进程生效，新缓存会替换旧缓存
不支持
支持
基础功能
设置响应数据的类型
设置数据以何种方式返回，将要响应的数据类型可设置为string、object、arraybuffer等类型。
支持
不支持
基础功能
定义允许的HTTP响应内容的最大字节数
服务器成功响应时，在获取数据前校验响应内容的最大字节数。
支持
不支持
证书验证
自定义证书校验
自定义逻辑校验客户端和服务端的证书，判断是否可以连接。
不支持
支持
证书验证
忽略SSL校验
在建立SSL连接时不验证服务器端的SSL证书。
不支持
支持
DNS
自定义DNS解析
包括自定义DNS服务器或静态DNS规则
不支持
支持
Remote Communication Kit特有
捕获详细的跟踪信息
在会话中的HTTP请求期间捕获详细的跟踪信息。跟踪有助于调试、性能分析和深入了解通信过程中的数据流。
不支持
支持
Remote Communication Kit特有
数据打点，获取HTTP请求的具体数据
HTTP请求各阶段的定时信息。
不支持
支持

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-preparations-V14
爬取时间: 2025-04-28 07:22:45
来源: Huawei Developer
申请权限
应用在使用Remote Communication Kit能力前，需要检查是否已经获取对应权限。如未获得授权，需要声明对应权限。
除取消网络请求，关闭会话，其余请求都需要权限Remote Communication kit所需权限有：
必须手动配置上述权限后才能使用，详细配置参见申请权限步骤。
申请权限步骤
需要在entry/src/main路径下的module.json5中配置所需申请的权限。示例代码如下所示：
C API开发准备
除上述权限配置外，C API使用时还需要在CMakeLists.txt中设置动态库路径及头文件路径，并进行链接。
如编译target为entry，则添加如下命令：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-netcom-V14
爬取时间: 2025-04-28 07:22:58
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-netinit-V14
爬取时间: 2025-04-28 07:23:12
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-netsend-arkts-V14
爬取时间: 2025-04-28 07:23:25
来源: Huawei Developer
如何使用FETCH发起网络请求
发送一个HTTP请求，也可以设置请求头和请求体等参数，并返回来自服务器的HTTP响应。使用Promise异步回调。常用于获取资源，支持流处理和通过拦截器来处理请求和响应。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| fetch(request: Request): Promise<Response> | 发送一个HTTP请求，并返回来自服务器的HTTP响应。使用Promise异步回调。 |
接口名
描述
fetch(request: Request): Promise<Response>
发送一个HTTP请求，并返回来自服务器的HTTP响应。使用Promise异步回调。
使用示例
1.
```typescript
import { rcp } from '@kit.RemoteCommunicationKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.
```typescript
const kHttpServerAddress = "https://www.example.com/fetch";
const request = new rcp.Request(kHttpServerAddress, 'GET');
```
3.
```typescript
const session = rcp.createSession();
```
4.
```typescript
session.fetch(request).then((rep: rcp.Response) => {
console.info(`Response succeeded: ${rep}`);
}).catch((err: BusinessError) => {
// 错误处理，通过catch块，捕获error，并对error进行处理，本示例中会将错误信息展现到打印台上。
console.error(`Response err: Code is ${JSON.stringify(err.code)}, message is ${JSON.stringify(err)}`);
});
```
如何发起GET网络请求
HTTP GET请求是常用的通信方式之一。为了有效地实现这一目标，RemoteCommunicationKit采用了Promise和异步回调的组合策略，不仅可以高效地从服务器获取数据，还可以提高代码的可读性和可维护性。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| get(url: URLOrString, destination?: ResponseBodyDestination): Promise<Response> | 发送一个带有默认HTTP参数的HTTP GET请求，参数为开发者需要请求的地址及响应的目标，并返回来自服务器的HTTP响应。使用Promise异步回调。 |
接口名
描述
get(url:URLOrString, destination?:ResponseBodyDestination): Promise<Response>
发送一个带有默认HTTP参数的HTTP GET请求，参数为开发者需要请求的地址及响应的目标，并返回来自服务器的HTTP响应。使用Promise异步回调。
使用示例
1.
```typescript
import { rcp } from '@kit.RemoteCommunicationKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.
```typescript
// 1、定义请求URL，此处只给出示例，还请根据实际情况将其替换为需要请求的URL
const getURL = "http://www.example.com/get";
// 2、创建session
const session = rcp.createSession();
// 3、使用session.get发起请求，以getURL为入参，使用Promise进行异步回调。
session.get(getURL).then((response) => {
console.info(`Response succeeded: ${response}`);
}).catch((err: BusinessError) => {
// 4、错误处理，通过catch块，捕获error，并对error进行处理，本示例中会将错误信息展现到打印台上。
console.error(`Response err: Code is ${JSON.stringify(err.code)}, message is ${JSON.stringify(err)}`);
});
```
如何发起POST网络请求
发送一个带有默认HTTP参数的HTTP POST请求，并返回来自服务器的HTTP响应。使用Promise异步回调。常用于向服务器提交数据。与GET请求不同，POST请求将参数包含在请求主体中，适用于创建新资源、提交表单数据或执行某些操作。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| post(url: URLOrString, content?: RequestContent, destination?: ResponseBodyDestination): Promise<Response> | 发送一个带有默认HTTP参数的HTTP POST请求，并返回来自服务器的HTTP响应。使用Promise异步回调。 |
接口名
描述
post(url:URLOrString, content?:RequestContent, destination?:ResponseBodyDestination): Promise<Response>
发送一个带有默认HTTP参数的HTTP POST请求，并返回来自服务器的HTTP响应。使用Promise异步回调。
使用示例
1.
```typescript
import { rcp } from '@kit.RemoteCommunicationKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.
如何发起PUT网络请求
在远场通信服务的框架中，当需要对服务器上存储的特定资源进行更新操作时，通常采用HTTP PUT请求。作为一种幂等操作，确保了每次请求都不会对除目标资源以外的任何状态产生影响。在实现这一功能时，我们通常利用Promise这一异步编程模型，以确保请求的执行流程能够被有效地管理和控制，它提供了一种结构化的方式来处理异步操作，无论请求成功还是失败，都能确保适当的反馈被正确地处理。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| put(url: URLOrString, content?: RequestContent, destination?: ResponseBodyDestination): Promise<Response> | 发送一个带有默认HTTP参数的HTTP PUT请求，并返回来自服务器的HTTP响应。使用Promise异步回调。 |
接口名
描述
put(url:URLOrString, content?:RequestContent, destination?:ResponseBodyDestination): Promise<Response>
发送一个带有默认HTTP参数的HTTP PUT请求，并返回来自服务器的HTTP响应。使用Promise异步回调。
使用示例
1.
```typescript
import { rcp } from '@kit.RemoteCommunicationKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.
```typescript
// 创建会话
const session = rcp.createSession();
// 定义content，请根据实际情况选择
const postContent: rcp.RequestContent = {
fields: {
'key1': 'value1',
'key2': 'value2',
'key3': 'value3'
}
}
// 会话发起PUT请求，"http://www.example.com"请根据实际情况替换为想要请求的URL地址。
session.put("http://www.example.com/put", postContent).then((response) => {
// 对响应的处理，此处为示例，只做打印处理
console.info(`Response succeeded: ${response}`);
}).catch((err: BusinessError) => {
// 请求错误处理
console.error(`Response err: Code is ${JSON.stringify(err.code)}, message is ${JSON.stringify(err)}`);
});
```
如何发起HEAD网络请求
涉及到对服务器资源的高效访问时，HTTP HEAD请求是一种非常有用的操作。它与GET请求类似，但主要的区别在于，HEAD请求只返回响应头，而不返回实体内容，这使得其在获取资源的元信息，如文件大小、修改日期等，以及检查资源是否已更改等方面更加有效。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| head(url: URLOrString): Promise<Response> | 发送一个带有默认HTTP参数的HTTP HEAD请求，并返回来自服务器的HTTP响应。使用Promise异步回调。 |
接口名
描述
head(url:URLOrString): Promise<Response>
发送一个带有默认HTTP参数的HTTP HEAD请求，并返回来自服务器的HTTP响应。使用Promise异步回调。
使用示例
1.
```typescript
import { rcp } from '@kit.RemoteCommunicationKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.
```typescript
// 1、创建会话
const session = rcp.createSession();
// 2、会话发起HEAD请求，"http://www.example.com"请根据实际情况替换为想要请求的URL地址。
session.head("http://www.example.com/head").then((response) => {
// 3、对响应的处理，此处为示例，只做打印处理
console.info(`Response succeeded: ${response}`);
}).catch((err: BusinessError) => {
// 4、请求错误处理
console.error(`Response err: Code is ${JSON.stringify(err.code)}, message is ${JSON.stringify(err)}`);
});
```
如何发起DELETE网络请求
在远场通信服务的框架中，Remote Communication Kit采用了一种结合发起 HTTP DELETE 请求与 Promise 异步处理的方法。具体操作如下：通过向预定义的 URL 发送一个包含默认 HTTP 参数的 HTTP DELETE 请求，即可实现对目标 URL 上相关资源的有效删除。这种机制不仅简化了请求的发送过程，还增强了异步处理的效率，确保了资源管理的灵活性和响应速度。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| delete(url: URLOrString): Promise<Response> | 发送一个带有默认HTTP参数的HTTP DELETE请求，并返回来自服务器的HTTP响应。使用Promise异步回调。 |
接口名
描述
delete(url:URLOrString): Promise<Response>
发送一个带有默认HTTP参数的HTTP DELETE请求，并返回来自服务器的HTTP响应。使用Promise异步回调。
使用示例
1.
```typescript
import { rcp } from '@kit.RemoteCommunicationKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.
```typescript
const session = rcp.createSession();
session.delete("http://www.example.com/delete").then((response) => {
console.info(`Response succeeded: ${response}`);
}).catch((err: BusinessError) => {
console.error(`Response err: Code is ${JSON.stringify(err.code)}, message is ${JSON.stringify(err)}`);
});
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-netcancle-arkts-V14
爬取时间: 2025-04-28 07:23:39
来源: Huawei Developer
在远场通信服务的框架中，没有明确指定任何 request 的情况下，通过调用 session.cancel，可以取消所有正在进行的网络请求。当开发者需要取消特定的一个网络请求时，可以使用 session.cancel 方法，并传入需要取消的请求，以实现这一目标。这样，开发者们就能根据具体需求，灵活地管理和控制网络请求的执行。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| cancel(requestToCancel?: Request| Request[]): void |   取消指定网络请求：传入需要取消的请求，返回值为空。 取消所有网络请求：无需传入参数，直接调用，返回值为空。  |
接口名
描述
cancel(requestToCancel?:Request|Request[]): void
使用示例
1.
```typescript
import { rcp } from '@kit.RemoteCommunicationKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-netclose-arkts-V14
爬取时间: 2025-04-28 07:23:53
来源: Huawei Developer
当一个HTTP请求完成，即数据已经成功发送并收到确认，或者在某些情况下，由于超时或其他错误原因，通信尝试失败，此时应立即调用相应的“关闭会话”或“释放资源”方法。这一操作的主要目的是：
在请求结束后，及时关闭会话并释放相关资源是保持系统健康和高效运行的关键步骤。这不仅有助于优化资源利用，还能提高系统的稳定性和可靠性。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| close(): void | 关闭会话。返回为空。 |
接口名
描述
close(): void
关闭会话。返回为空。
使用示例
1.
```typescript
import { rcp } from '@kit.RemoteCommunicationKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.
```typescript
// 1、创建会话
const session = rcp.createSession();
// 2、创建Request，"http://www.example.com"请根据实际情况替换为想要请求的URL地址。
let req = new rcp.Request("http://www.example.com/fetch", "GET");
// 3、利用fetch发起网络请求
session.fetch(req).then((response) => {
// 4、对响应的处理，此处为示例，只做打印处理
console.info(`Response succeeded: ${response}`);
}).catch((err: BusinessError) => {
// 5、请求错误处理
console.error(`Response err: Code is ${JSON.stringify(err.code)}, message is ${JSON.stringify(err)}`);
});
session.close();
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-netsend-c-V14
爬取时间: 2025-04-28 07:24:06
来源: Huawei Developer
如何使用fetchsync发起网络请求
发送一个同步HTTP请求，也可以设置请求头和请求体等参数，并返回来自服务器的HTTP响应。常用于获取资源，支持通过拦截器来处理请求和响应。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| Rcp_Response *HMS_Rcp_FetchSync(Rcp_Session *session, Rcp_Request *request, uint32_t *errCode); | 发送一个HTTP请求，并直接返回来自服务器的HTTP响应。 |
接口名
描述
Rcp_Response *HMS_Rcp_FetchSync(Rcp_Session *session, Rcp_Request *request, uint32_t *errCode);
发送一个HTTP请求，并直接返回来自服务器的HTTP响应。
使用示例
1.
2.
3.
4.
5.
6.
如何使用fetch发起异步网络请求
发送一个异步HTTP请求，也可以设置请求头和请求体等参数，并返回来自服务器的HTTP响应。常用于获取资源，支持通过拦截器来处理请求和响应。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| uint32_t HMS_Rcp_Fetch(Rcp_Session *session, Rcp_Request *request, const Rcp_ResponseCallbackObject *responseCallback); | 发送一个HTTP请求，并返回来自服务器的HTTP响应。使用responseCallback异步回调。 |
接口名
描述
uint32_t HMS_Rcp_Fetch(Rcp_Session *session, Rcp_Request *request, const Rcp_ResponseCallbackObject *responseCallback);
发送一个HTTP请求，并返回来自服务器的HTTP响应。使用responseCallback异步回调。
使用示例
1.
2.
3.
4.
5.
如何使用get发送网络请求
发送一个带有默认HTTP参数的HTTP GET请求，并返回来自服务器的HTTP响应。采用异步回调的方式进行处理，提高应用的响应性和效率。常用于从服务器获取数据。
使用示例
1.
2.
3.
如何使用post发送网络请求
发送一个带有默认HTTP参数的HTTP POST请求，并返回来自服务器的HTTP响应。使用异步回调。常用于向服务器提交数据。与GET请求不同，POST请求将参数包含在请求主体中，适用于创建新资源、提交表单数据或执行某些操作。
使用示例
1.
2.
3.
如何使用put发送网络请求
发送一个带有默认HTTP参数的HTTP PUT请求，并返回来自服务器的HTTP响应。使用异步回调。常用于向服务器更新资源。PUT请求将更新的数据发送到特定的URL，用于替换指定资源的全部内容。
使用示例
1.
2.
3.
如何使用head发送网络请求
发送一个带有默认HTTP参数的HTTP HEAD请求，并返回来自服务器的HTTP响应。使用异步回调。类似GET请求，但只返回相应头，不返回实体内容。可以获取资源的元信息，如文件大小、修改日期等。
使用示例
1.
2.
3.
如何使用delete发送网络请求
发送一个带有默认HTTP参数的HTTP DELETE请求，并返回来自服务器的HTTP响应，用于从服务器删除资源，通过向指定URL发送DELETE请求，可以删除该URL上对应的资源。使用异步回调。
使用示例
1.
2.
3.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-netcancle-c-V14
爬取时间: 2025-04-28 07:24:20
来源: Huawei Developer
在远场通信服务的框架中，没有明确指定任何 request 的情况下，可以取消所有正在进行的网络请求。如果开发者需要取消特定的一个网络请求，可以使用HMS_Rcp_CancelRequest方法，并传入需要取消的请求，以实现这一目标。开发者们可以根据具体需求，灵活地管理和控制网络请求的执行。总之，HMS_Rcp_CancelRequest方法的灵活运用，不仅能够优化网络资源的使用，还能提升应用程序的用户体验。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| uint32_t HMS_Rcp_CancelRequest(Rcp_Session *session, const Rcp_Request *request); | 取消指定或所有正在进行的会话请求。返回为空。 |
接口名
描述
uint32_t HMS_Rcp_CancelRequest(Rcp_Session *session, const Rcp_Request *request);
取消指定或所有正在进行的会话请求。返回为空。
使用示例
1.
2.
3.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-netclose-c-V14
爬取时间: 2025-04-28 07:24:34
来源: Huawei Developer
当一个远场通信请求完成，即数据已经成功发送并收到确认，或者在某些情况下，由于超时或其他错误原因，通信尝试失败，此时应立即调用相应的“关闭会话”或“释放资源”方法。这一操作的主要目的是：
在请求结束后，及时关闭会话并释放相关资源是保持系统健康和高效运行的关键步骤。这不仅有助于优化资源利用，还能提高系统的稳定性和可靠性。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| uint32_t HMS_Rcp_CloseSession(Rcp_Session **session); | 关闭会话。 |
接口名
描述
uint32_t HMS_Rcp_CloseSession(Rcp_Session **session);
关闭会话。
使用示例
1.
2.
3.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-customhttp-V14
爬取时间: 2025-04-28 07:24:47
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-customconfig-V14
爬取时间: 2025-04-28 07:25:01
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-customdnsconfig-V14
爬取时间: 2025-04-28 07:25:16
来源: Huawei Developer
场景介绍
在远程通信服务框架中，Remote Communicaiton Kit提供了一套高度可定制的 DNS（Domain Name System）请求规则服务，这一服务允许开发者根据自身需求调整 DNS 查询行为。此外，我们还支持用户自定义 DNS 服务器设置，开发者能够根据具体的网络环境或安全需求，选择最适合的 DNS 服务器进行配置。通过这些功能，开发者不仅能够实现网络管理的高效性，还能增强网络的安全性，确保数据传输的稳定与安全。DnsConfiguration中可设置dnsRules、dnsOverHttps。
-  自定义DNS服务器（DnsServers）：可指定自定义的DNS服务器提供解析服务。 自定义静态DNS（StaticDnsRules）：当默认的DNS不能正常解析部分域名，就需要手动添加静态DNS。添加静态DNS后，如果hostname匹配，则优先使用指定的地址。 自定义动态DNS（DynamicDnsRules）：除了添加静态DNS外，还可以添加动态DNS。动态DNS可看作一个可以根据hostname和port直接返回IP地址的函数，如果设置，则优先使用函数中返回的地址。 针对同一域名配置多个静态或者动态DNS规则后，Remote Communication Kit将按照配置的规则轮询服务器。
-  DNS over HTTPS配置（DnsOverHttpsConfiguration）：配置HTTPS上的DNS（DOH）设置，以加密的HTTPS协议进行DNS解析请求，避免原始DNS协议中用户的DNS解析请求被窃听或者修改的问题，实现保护用户隐私的目的。如果设置，则优先使用DNS服务器解析的地址。
使用示例
下面以定制DNS服务器、重写DNS解析函数两个示例来说明如何进行DNS的定制，从而获取最佳的DNS性能体验。
定制DNS服务器
1.
2.
3.
4.
定制DNS解析函数
1.
2.
3.
4.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-customtranferconfig-V14
爬取时间: 2025-04-28 07:25:30
来源: Huawei Developer
场景介绍
在远场通信框架中，开发者们利用 TransferConfiguration，可以对 HTTP请求期间的数据传输行为进行精细化管理和定制化调整。 TransferConfiguration提供了自动重定向策略、超时时间设定以及链接层 HTTP/3支持等关键功能的配置选项。通过理解和灵活运用这些属性，开发者可以根据项目需求，实现数据传输策略的个性化定制，从而获得更高效、更可靠的数据传输体验。
使用示例
下面会介绍超时重试场景下TransferConfiguration如何去使用。
超时重试
1.
2.
3.
```typescript
async function retryRequest(url: string, retryCount: number, attempt: number): Promise<rcp.Response | undefined> {
return new Promise((resolve, reject) => {
// 在最后一次重试时，等待一段时间后再发送请求
const delay = attempt === retryCount - 1 ? 3000 : 0; // 如果是最后一次重试，延迟3秒，否则不延迟
setTimeout(() => {
session.get(url)
.then(response => {
if (response.statusCode === 200) {
logI(`Request successful on attempt ${attempt}.`); // 记录请求成功信息
resolve(response); // 请求成功，Promise resolve
} else {
logE(`Request failed on attempt ${attempt}, statusCode: ${response.statusCode}`); // 记录请求失败信息
if (attempt < retryCount) { // 如果还未达到重试次数
retryRequest(url, retryCount, attempt + 1); // 进行下一次重试
} else { // 如果已经达到重试次数
logE(`All retries failed.`); // 记录所有重试失败信息
reject(new Error('All retries failed')); // 所有重试失败，Promise reject
}
}
})
.catch((err: BusinessError) => { // 请求的catch块，处理请求过程中抛出的错误
logE(`Request error on attempt ${attempt}, error: ${JSON.stringify(err)}`); // 记录请求错误信息
if (attempt < retryCount) { // 如果还未达到重试次数
retryRequest(url, retryCount, attempt + 1); // 进行下一次重试
} else { // 如果已经达到重试次数
logE(`All retries failed.`); // 记录所有重试失败信息
reject(new Error('All retries failed')); // 所有重试失败，Promise reject
}
});
}, delay); // 延迟指定时间后再发送请求
});
}
```
4.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-customproxyconfig-V14
爬取时间: 2025-04-28 07:25:43
来源: Huawei Developer
场景介绍
在远场通信框架中，ProxyConfiguration配置会话代理设置，提供system、no-proxy和WebProxy三种选项。
使用示例
下面将对框架提供的三种选项（'system'，'no-proxy'，'WebProxy'）以示例代码的方式进行说明。
'no-proxy'
1.
2.
3.
4.
'system'
1.
2.
3.
4.
webProxy（自定义代理设置）
1.
2.
3.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-customsecurityconfig-V14
爬取时间: 2025-04-28 07:25:57
来源: Huawei Developer
场景介绍
在软件开发中，安全性是一个非常重要的方面。 Remote Communication Kit 提供的SecurityConfiguration是一个用于定制安全传输行为的工具，可以帮助开发者更好地保护其开发的应用程序。通过合理的配置和使用，可以大大降低应用程序受到攻击的风险。下面将会通过如何使用自定义证书校验来说明。
使用示例
自定义证书校验
Remote Communication Kit会将服务器证书传递给调用方，调用方可以根据自身业务需要，对证书进行校验。例如：证书过期，但客户端不关注日期，此时可以只校验证书的内容，不校验日期。
1.
2.
3.
双向证书校验
是一种加密通信机制，用于在客户端和服务器之间建立可信的连接。通过交换证书和公钥来验证双方的身份，并确保数据的完整性和隐私。
1.
2.
```typescript
let readSyn = async () => {
// 定义文件路径，请根据业务自行定义
let pathDir = "/path/files/";
// 定义文件路径，请根据业务自行定义
let filePath = pathDir + "/client.crt";
// 使用 fileIo.open 方法打开文件，返回一个 Promise
fileIo.open(filePath, fileIo.OpenMode.READ_WRITE).then((file: fileIo.File) => {
// 打印成功打开的文件描述符
console.info(`readxx the file is: ${file.fd}`);
// 创建一个 4096 字节的缓冲区用于存储读取的数据
let buf = new ArrayBuffer(4096);
// 使用 fileIo.read 方法读取文件内容，返回一个 Promise
fileIo.read(file.fd, buf, (err: BusinessError, readLen: number) => {
// 如果读取过程中发生错误
if (err) {
// 打印错误信息
console.error(`readxx failed with error message: Code is ${err.code}, message is ${err.message}`);
} else {
// 如果读取成功
// 打印成功信息
console.info(`readxx file data succeed`);
// 打印读取的数据
console.info(`readxx: ${String.fromCharCode(...new Uint8Array(buf.slice(0, readLen)))}`);
// 将读取的数据转换为字符串
let content = String.fromCharCode(...new Uint8Array(buf.slice(0, readLen)));
// 打印证书内容
console.info(`this.cert.data: ${content}`);
// 同步关闭文件
fileIo.closeSync(file);
}
});
}).catch((err: BusinessError) => {
// 如果打开文件过程中发生错误
// 打印错误信息
console.error(`readxx Open failed errInfo: Code is ${err.code}, message is ${err.message}`);
})
}
```
3.
```typescript
let getCertSyn = async (content: string) => {
// 定义服务器地址：
let kHttpServerAddress = "https://www.example.com/fetch";
// 创建会话并发送请求：
try {
const session = rcp.createSession();
const request = new rcp.Request(kHttpServerAddress, "GET");
request.configuration = {
security: {
certificate: {
content: content,
type: "PEM",
key: " ",
keyPassword: " "
}
}
}
const response = await session.fetch(request);
console.info(`${kHttpServerAddress} certificate verification succeeded, message is ${response}`);
} catch (err) {
console.error(`${kHttpServerAddress} certificate verification failed: Code is ${err.code}, message is ${err.message}`);
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-customprocessconfig-V14
爬取时间: 2025-04-28 07:26:10
来源: Huawei Developer
场景介绍
ProcessingConfiguration 是 Remote Communication Kit 中用于定制响应处理行为的一个重要组件。它允许你在消息被分发到不同的处理器之前或之后执行一些自定义的逻辑。场景如检验响应状态是否为成功即响应码是否为200。
使用示例
1.
2.
3.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-interceptconfig-V14
爬取时间: 2025-04-28 07:26:24
来源: Huawei Developer
使用拦截器可以方便的对HTTP的请求与响应进行修改，您可以创建拦截器链，按需定制一组拦截器对您的网络请求/响应进行修改。Remote Communication Kit模块提供了拦截器能力，在SessionConfiguration中添加Interceptors参数，传入自定义的拦截器，即可在HTTP请求和响应的过程中添加拦截器功能。
拦截器工作原理
客户端发送HTTP请求，到达目标服务器之前，可以使用拦截器对HTTP的请求进行修改。如下图，定义了链式拦截器，RequestUrlChangeInterceptor拦截器（下文以拦截器1代替）和ResponseHeaderRemoveInterceptor拦截器（下文以拦截器2代替）。拦截器1会将请求先拦截，该拦截器可以实现当网络质量差时，通过修改HTTP请求中的URL，来调整请求资源的大小。然后经过拦截器2，最后到达Internet。当请求到达目标服务器，服务器返回请求响应的结果给客户端之前，可以使用拦截器对HTTP的响应进行修改。响应先被拦截器2拦截，在响应返回给应用前检查和修改服务器的请求头。然后经过拦截器1，最后客户端接收响应结果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170503.62965524868551906393072276141906:50001231000000:2800:018E06C89662A459B662D0FA6C94FD515E0F0BB9D7C3E628D92F02716FA4BC96.png)
RequestUrlChangeInterceptor拦截器和ResponseHeaderRemoveInterceptor拦截器都是自定义拦截器，需要开发者通过代码去实现内部逻辑。
拦截器的定义和使用
下面将介绍如何自定义拦截器，定义RequestUrlChangeInterceptor拦截器和ResponseHeaderRemoveInterceptor拦截器实现Interceptors，可在intercept()方法中根据业务需求自定义处理逻辑，实现对请求/响应的修改。以下示例模拟网络质量不佳的情况。
1.
2.
3.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-filetransfer-V14
爬取时间: 2025-04-28 07:26:37
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-filetransferfast-V14
爬取时间: 2025-04-28 07:26:51
来源: Huawei Developer
Remote Communication Kit 结合 Core File Kit 可以实现基于文件、目录、对象的快速上传和下载功能。 Remote Communication Kit 提供了远程通信的功能，包括远程连接、数据传输等 API 接口。而 Core File Kit 则提供了文件管理的功能，包括文件读取、写入等 API 接口。结合起来使用，可以通过 Remote Communication Kit 实现文件、目录、对象的远程传输，并且由于 Core File Kit 的高效文件处理能力，可以实现快速的上传和下载功能。
下载功能实现
1.
2.
3.
上传功能实现
1.
2.
3.
```typescript
class FdReadFile {
readonly fd: number;
constructor(fd: number) {
this.fd = fd;
}
async read(buffer: ArrayBuffer): Promise<number> {
return fileIo.read(this.fd, buffer);
}
}
```
4.
5.
6.
7.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-pauseresume-V14
爬取时间: 2025-04-28 07:27:05
来源: Huawei Developer
请求暂停、恢复
场景介绍
Remote Communicaiton Kit提供了完善的功能，其中包括对请求的暂停和恢复的支持。这不仅包括接收暂停，也涵盖了发送暂停。
使用实例
1.
2.
3.
4.
实现断点续传
场景介绍
在处理多任务并发或网络中断后需要接续上次任务的场景中，用户可以通过定义TransferRange对象的from和to属性来控制数据的截取范围。下载的内容可以被准确地截取并拼接到目标文件中，确保数据的完整性和一致性，提高了任务的可靠性，开发者可以灵活地管理和恢复下载过程。
使用示例
1.
```typescript
import { rcp } from '@kit.RemoteCommunicationKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.
3.
4.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-streamreq-V14
爬取时间: 2025-04-28 07:27:18
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-syncstreamreq-V14
爬取时间: 2025-04-28 07:27:32
来源: Huawei Developer
场景介绍
HTTP流式传输（Streaming）允许客户端与服务器之间以流的形式进行数据交互，而无需等待所有数据准备完毕，能显著提升用户体验。流式传输适用于大文件的上传下载、直播、实时数据更新等场景。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| write(buffer: string | ArrayBuffer): void | 将一段数据写入队列当中，框架的IO线程会在合适的时候把该数据发送出去。 |
| read(buffer: ArrayBuffer): Promise<number> | 从文件中读取数据。 |
接口名
描述
write(buffer: string | ArrayBuffer): void
将一段数据写入队列当中，框架的IO线程会在合适的时候把该数据发送出去。
read(buffer: ArrayBuffer): Promise<number>
从文件中读取数据。
使用示例
1.
```typescript
import { rcp } from '@kit.RemoteCommunicationKit';
import { expect } from '@ohos/hypium';
```
2.
```typescript
const testNetworkInputQueue = async (done: Function): Promise<void> => {
// 创建同步写队列对象
const NetworkInputQueue = rcp.NetworkInputQueue;
const networkInputQueue = new NetworkInputQueue();
// 模拟文件分批上传场景
let counter = 0;
const interval = setInterval(() => {
// 添加数据到同步写队列
networkInputQueue.write('a counter ' + counter++);
if (counter === 10) {
clearInterval(interval);
// 关闭同步写队列
networkInputQueue.close();
}
}, 100);
// 创建session 开发者根据需要实际情况设置远程校验方式
const session = rcp.createSession({
requestConfiguration: {
security: {
remoteValidation: 'skip',
},
},
});
// 发起请求
const response = await session.post('https://example.org/post', networkInputQueue);
// 校验返回结果
expect(response.statusCode).assertEqual(200);
const obj = response.toJSON();
if (obj) {
expect(obj['data']).assertEqual(
'a counter 0a counter 1a counter 2a counter 3a counter 4a counter 5a counter 6a counter 7a counter 8a counter 9',
);
} else {
expect().assertFail();
}
// 关闭session
session.close();
done();
}
```
3.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-hpp-V14
爬取时间: 2025-04-28 07:27:46
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-tpms-V14
爬取时间: 2025-04-28 07:27:59
来源: Huawei Developer
捕获有关HTTP请求/响应流的详细信息
当需要进行性能维测时，可以采集应用中HTTP请求的详细跟踪信息时，利用TracingConfiguration进行相关配置。TracingConfiguration中可以设置verbose（启用详细跟踪）、infoToCollect（配置要收集的特定类型的信息事件）、collectTimeInfo（在跟踪过程中是否应收集与时间相关的信息）、httpEventsHandler（为HTTP请求/响应过程中的特定操作定义响应处理程序的回调）四个参数。
下面将以获取HTTP请求/响应时的数据接收时、请求头接收时、数据传输完成时等详细信息为例，进行介绍。
1.
2.
3.
4.
HTTP请求过程中各时间点详解
在实施性能维测的过程中，HTTP请求的各个时间点至关重要。借助TimeInfo提供的详细字段，可以精准控制请求过程，无论是直接利用这些字段，还是通过它们之间的运算，都能准确获取所需的时间点，从而提升测试效率。
下面，我们将通过图片、时间线及一段示例代码，详细解析请求过程中的关键时间点。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170504.67446597975834478362402681316079:50001231000000:2800:51858752CA07B8B6DA37C7128CE4650A7AD40AB2AED1D0502B18AF5F7302BD15.png)
从图中可以看到HTTP请求过程的基本过程，并且有一些关键的时间点，下面将以时间线的方式对其进行说明：
TimeInfo时间线
请求开始 （0时刻） -> nameLookupTimeMs（DNS解析）-> connectTimeMs（建立连接）-> tlsHandshakeTimeMs（TLS握手）-> preTransferTimeMs（请求业务数据发送到服务器的时间点） -> startTransferTimeMs（从服务器接收到首包数据的时间点）。
各时间节点所显示的时间均相对于0时刻，即从0时刻开始计时的时间。例如tlsHandshakeTimeMs为150.1ms，指从发起请求时间0开始，直到TLS握手结束所花费的时间为150.1ms。
网络请求过程中关键节点时间计算方法：
示例代码
这段代码在使用过程中会将上述说明中三个比较关键的时间点打印出来，开发者可以根据获取到的时间对应用性能实现动态调整，获取最佳体验。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-cpo-V14
爬取时间: 2025-04-28 07:28:13
来源: Huawei Developer
请求预处理阶段
DNS阶段
应用可定制DNS请求规则，如定制DNS服务器、重写DNS解析函数，从而获取最佳的DNS性能体验。
```typescript
// 定制DNS解析函数
const session = rcp.createSession();
const request = new rcp.Request('https://example.com');
request.configuration = {
dns: {
dnsRules: (host: string, port: number): IpAddress[] => {
if (host === 'example.com') {
return ['7.128.8.45', '7.128.8.46'];
}
return [];
}
}
};
session.fetch(request);
```
连接阶段
根据资源特征动态调整连接池大小
HTTP请求阶段
HTTP响应阶段
获取响应各阶段耗时动态判断网络质量，动态调整请求（请求不同质量的资源、降低资源缓存数量）。更详细的示例请移步HTTP请求过程中各时间点详解。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-urpc-V14
爬取时间: 2025-04-28 07:28:27
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/remote-communication-urpccall-V14
爬取时间: 2025-04-28 07:28:40
来源: Huawei Developer
场景介绍
发送一个URPC请求，也可以设置优先级等参数，并返回来自远程服务器的URPC响应。当发起请求后，可以选择取消指定或正在进行的URPC请求。当完成请求后，需要关闭请求来释放与此URPC关联的资源。
接口说明
具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| call: (funcName: string, request: object, returnValue: object, config?: CallingOption) => UrpcPromise | 发送一个URPC请求，并返回来自服务器的HTTP响应。使用Promise异步回调。 |
| cancel: (callingId?: number | number[]) => void | 取消指定或所有正在进行的URPC请求，返回值为空。 |
| destroy: () => void | 销毁UrpcStub实例 |
接口名
描述
call: (funcName: string, request: object, returnValue: object, config?: CallingOption) => UrpcPromise
发送一个URPC请求，并返回来自服务器的HTTP响应。使用Promise异步回调。
cancel: (callingId?: number | number[]) => void
取消指定或所有正在进行的URPC请求，返回值为空。
destroy: () => void
销毁UrpcStub实例
使用示例
创建urpcStub
1.
2.
```typescript
// 定义调用方法的入参类示例
export class MediaTaskRequestMessage {
RequestMessage: urpc.FlowbufElement<string>;
constructor() {
this.RequestMessage = {type: 'STRING', value: "", name: ""};
}
setRequestMessage(RequestMessage: string) {
this.RequestMessage.value = RequestMessage;
}
getRequestMessage(): string {
return this.RequestMessage.value;
}
}
// 定义用于接收调用方法返回值的类示例
export class MediaTaskResponseMessage {
ResponseMessage: urpc.FlowbufElement<string>;
constructor() {
this.ResponseMessage = {type: 'STRING', value: "", name: ""};
}
setResponseMessage(ResponseMessage: string) {
this.ResponseMessage.value = ResponseMessage;
}
getResponseMessage(): string {
return this.ResponseMessage.value;
}
}
```
3.
4.
使用call收发网络请求
（可选）使用cancel取消网络请求
当调用call发起一次urpc收发请求后，根据业务需要，不用接收响应时，可调用cancel取消指定callingId的请求；若不指定callingId，则取消UrpcStub发起的全部请求。
使用destroy关闭URPC
当完成所有urpc收发网络请求后，需调用destroy释放并销毁UrpcStub相关的资源。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/service-collaboration-kit-guide-V14
爬取时间: 2025-04-28 07:28:54
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/servicecollaborationkit-introduction-V14
爬取时间: 2025-04-28 07:29:07
来源: Huawei Developer
Service Collaboration Kit（协同服务）提供了同账号下多端设备协同的能力。
场景介绍
| 场景分类  | 场景说明  |
| --- | --- |
| 跨设备互通场景  | 用户通过此能力实现跨设备交互，可以使用其他设备的相机、扫描和图库功能。  |
场景分类
场景说明
跨设备互通场景
用户通过此能力实现跨设备交互，可以使用其他设备的相机、扫描和图库功能。
基本概念
跨设备互通提供跨设备的相机、扫描、图库访问能力，平板或2in1设备可以调用手机的相机、扫描、图库等功能。
功能使用限制
| 能力  | 限制条件  |
| --- | --- |
| 跨设备互通能力  | 双端设备需要登录同一华为账号；双端设备需要打开WLAN和蓝牙开关。本端设备为HarmonyOS版本为HarmonyOS NEXT及以上的平板或2in1设备， 远端设备：HarmonyOS版本为HarmonyOS NEXT及以上、具有相机能力的手机或平板设备。跨设备互通API支持根据特定调用策略调用设备。调用策略：2in1设备可以调用平板和手机，平板可以调用手机，同类型设备不可调用。  |
能力
限制条件
跨设备互通能力

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/servicecollaboration-service-V14
爬取时间: 2025-04-28 07:29:21
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/servicecollaboration-service-overview-V14
爬取时间: 2025-04-28 07:29:35
来源: Huawei Developer
跨设备互通提供跨设备的相机、扫描、图库访问能力，平板或2in1设备可以调用手机的相机、扫描、图库等功能。
本章节以拍照为例展开介绍，扫描、图库功能的使用与拍照类似。
用户在平板或2in1设备上使用富文本类编辑应用（如：备忘录、邮件、笔记等）时，想要拍摄一些照片作为素材，但是当前设备拍摄不太方便。通过跨设备互通-拍照，用户可以在当前设备的应用中指定平板或手机设备，并打开平板或手机的相机来拍摄所需的素材。通过手机或者平板设备拍摄，移动更便利、取景更灵巧、相机能力也更强大。拍摄的照片将实现快速回传到平板或2in1设备的应用中，帮助用户高效完成图文并茂的文档设计。
如果同一组网下有多台手机或平板设备，用户可以选择不同的设备进行拍摄。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170504.39534755990292130334486538425599:50001231000000:2800:60A82FBC761BB6AAA48F59DC7BC60D433A5559997BBE0A61A5B37F40FDE4D02C.gif)
运作机制
基于分布式协同框架面向跨设备拍照的业务场景，为您提供了createCollaborationServiceMenuItems（相机设备列表组件）和CollaborationServiceStateDialog（远端相机状态弹窗组件）两个组件。应用只需要调用这两个组件，即可完成跨端拍照，无需关注分布式场景下数据传输、指令控制等具体细节。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170504.36001977408023440313994257334886:50001231000000:2800:6F5AA64A82AF425C33FC25C3CE50413697399298F1FA5830A2916E70EF66EC9B.png)
跨设备互通-拍照的具体流程如上图所示。
1.  通过系统的分布式协同框架，同账号下的本端设备（2in1设备/平板）与远端设备（手机/平板）自动建立连接。系统将自动完成设备的发现、连接、认证等流程，将可用的具有相机能力的远端设备信息提供给应用，并通过createCollaborationServiceMenuItems（相机设备列表组件）展示。 createCollaborationServiceMenuItems（相机设备列表组件）将展示附近可用的设备信息。当附近一个或两个可用设备时，将直接显示该设备信息；当附近有两个以上可用设备时，将自动创建子菜单项，层叠显示多个设备信息。 附近仅有一个或两个可用设备 附近有两个以上可用设备
2.  拍摄状态可能为：对端设备拍摄中、图片导入中、协同失败、本端WLAN未开启、对端WLAN未开启。 对端设备拍摄中 图片导入中 协同失败 本端WLAN未开启 对端WLAN未开启 当提示失败（包括协同失败、本端WLAN未开启、对端WLAN未开启）时，需要用户根据提示打开对应设备的WLAN，然后重新点击createCollaborationServiceMenuItems（相机设备列表组件）触发流程。
3.  拍摄状态可能为：对端设备拍摄中、图片导入中、协同失败、本端WLAN未开启、对端WLAN未开启。 对端设备拍摄中 图片导入中 协同失败 本端WLAN未开启 对端WLAN未开启 当提示失败（包括协同失败、本端WLAN未开启、对端WLAN未开启）时，需要用户根据提示打开对应设备的WLAN，然后重新点击createCollaborationServiceMenuItems（相机设备列表组件）触发流程。
| 附近仅有一个或两个可用设备 | 附近有两个以上可用设备 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170504.32598982007575997922083093587072:50001231000000:2800:580811F01CD935919B84091F8E0DFF6BB2D6C11AED11502314F465319C6A747A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170504.34969805756049566801165671105115:50001231000000:2800:9D20988F5C8ADB8FF31AA3B15C7F79FD2A2EE65B3FA144D7BA87F2CB24580973.png)
1.  拍摄状态可能为：对端设备拍摄中、图片导入中、协同失败、本端WLAN未开启、对端WLAN未开启。 对端设备拍摄中 图片导入中 协同失败 本端WLAN未开启 对端WLAN未开启 当提示失败（包括协同失败、本端WLAN未开启、对端WLAN未开启）时，需要用户根据提示打开对应设备的WLAN，然后重新点击createCollaborationServiceMenuItems（相机设备列表组件）触发流程。
| 对端设备拍摄中 | 图片导入中 | 协同失败 | 本端WLAN未开启 | 对端WLAN未开启 |
| --- | --- | --- | --- | --- |
|  |  |  |  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170504.54371875648656623723673120793487:50001231000000:2800:7DBA63E1D23A663BBBFC75A1CECF09AAD9F57C985575CA75F5870C30F7782A6B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170505.23770103496503251937182855236014:50001231000000:2800:4855DC38A3DD63378F716BF8D09D119C3E00CD376B17BCAA3946F56EA36785F9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170505.03372174737148495780217039344019:50001231000000:2800:30C51EA8C50D27117C25125450E81B3EC3889DE7B73F7D6DFDE75A803D995855.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170505.08703172576798412926468743669344:50001231000000:2800:E4F50A557144A20E057B02CBB952BCF5029416B8B7F34E8B7BB3EFCB942F242F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170505.73358525194852400080652312839491:50001231000000:2800:1F199096DC45DF6FC866B968E79C8A62EE270E141408D8D7E3366131DF4A4AD0.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/servicecollaboration-dev-guides-V14
爬取时间: 2025-04-28 07:29:48
来源: Huawei Developer
跨设备互通提供跨设备的相机、扫描、图库访问能力，平板或2in1设备可以调用手机的相机、扫描、图库等功能。
场景介绍
您通过此能力实现跨设备交互，可以使用其他设备的相机、扫描和图库功能。
约束与限制
需同时满足以下条件，才能使用该功能：
-  条件允许时，建议双端设备接入同一个局域网，可提升唤醒相机的速度。
-  条件允许时，建议双端设备接入同一个局域网，可提升唤醒相机的速度。
-  条件允许时，建议双端设备接入同一个局域网，可提升唤醒相机的速度。
接口说明
在开发具体功能前，请先查阅参考文档。
| 接口名 | 描述 |
| --- | --- |
| createCollaborationServiceMenuItems | 设备列表选择器，用于获取组网内具有对应相机能力的设备列表。 |
| CollaborationServiceStateDialog | 弹窗组件，用于提示对端相机拍摄状态。 |
接口名
描述
createCollaborationServiceMenuItems
设备列表选择器，用于获取组网内具有对应相机能力的设备列表。
CollaborationServiceStateDialog
弹窗组件，用于提示对端相机拍摄状态。
开发步骤
1.  createCollaborationServiceMenuItems是设备列表菜单项模块，传入CollaborationServiceFilter的能力枚举值；CollaborationServiceStateDialog是状态提示框模块。
```typescript
import { createCollaborationServiceMenuItems, CollaborationServiceStateDialog, CollaborationServiceFilter } from '@kit.ServiceCollaborationKit';
```
2.  在调用createCollaborationServiceMenuItems前，需了解：
```typescript
@Builder
MyTestMenu() {
Menu() {
createCollaborationServiceMenuItems([CollaborationServiceFilter.ALL])
}
}
```
3.  回调函数的传入参数stateCode是完成状态，buffer是回传的图片数据，可通过状态和图片数据结合自身的业务逻辑实现onState方法。
```typescript
CollaborationServiceStateDialog({
onState: (stateCode: number, bufferType: string, buffer: ArrayBuffer):void => this.doInsertPicture(stateCode, bufferType, buffer)
})
```
完整示例
通过以下示例，您可以完成一次调用对端相机拍摄的操作。
```typescript
import {
createCollaborationServiceMenuItems,
CollaborationServiceStateDialog,
CollaborationServiceFilter
} from '@kit.ServiceCollaborationKit';
import { image } from '@kit.ImageKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
@Entry
@Component
struct Index {
@State picture: PixelMap | undefined = undefined;
@Builder
MyTestMenu() {
Menu() {
createCollaborationServiceMenuItems([CollaborationServiceFilter.ALL])
}
}
build() {
Column({ space: 20 }) {
CollaborationServiceStateDialog({
onState: (stateCode: number, bufferType: string, buffer: ArrayBuffer): void => this.doInsertPicture(stateCode, bufferType, buffer)
})
Button('使用远端设备进行拍照')
.type(ButtonType.Normal)
.borderRadius(10)
.bindMenu(this.MyTestMenu)
if (this.picture) {
Image(this.picture)
.borderStyle(BorderStyle.Dotted)
.borderWidth(1)
.objectFit(ImageFit.Contain)
.height('80%')
.onComplete((event) => {
if (event != undefined) {
hilog.info(0, "MEMOMOCK", "onComplete " + event.loadingStatus)
}
})
}
}
.padding(20)
.width('100%')
.alignItems(HorizontalAlign.Center)
}
doInsertPicture(stateCode: number, bufferType: string, buffer: ArrayBuffer): void {
if (stateCode != 0) {
return
}
if (bufferType == "general.image") {
let imageSource = image.createImageSource(buffer)
imageSource.createPixelMap().then((pixelMap) => {
this.picture = pixelMap;
})
}
}
}
```
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/servicecollaboration-servicendk-V14
爬取时间: 2025-04-28 07:30:02
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/servicecollaboration-servicendk-description-V14
爬取时间: 2025-04-28 07:30:18
来源: Huawei Developer
跨设备互通提供跨设备的相机、扫描、图库访问能力，平板或2in1设备可以调用手机的相机、扫描、图库等功能。
本章节以拍照为例展开介绍，扫描、图库功能的使用与拍照类似。
用户在平板或2in1设备上使用富文本类编辑应用（如：备忘录、邮件、笔记等）时，想要拍摄一些照片作为素材，但是当前设备拍摄不太方便。通过跨设备互通-拍照，用户可以在当前设备的应用中指定平板或手机设备，并打开平板或手机的相机来拍摄所需的素材。通过手机或者平板设备拍摄，移动更便利、取景更灵巧、相机能力也更强大。拍摄的照片将实现快速回传到平板或2in1设备的应用中，帮助用户高效完成图文并茂的文档设计。
如果同一组网下有多台手机或平板设备，用户可以选择不同的设备进行拍摄。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170505.40760253072984977965512547842849:50001231000000:2800:AE956D6D69ED86E12A88F6549FF5B3DB300073506174B4835FAEDD932603037E.gif)
运作机制
基于分布式协同框架面向跨设备拍照的业务场景，为您提供了HMS_ServiceCollaboration_GetCollaborationDeviceInfos（列表设备接口）、HMS_ServiceCollaboration_StartCollaboration（跨设备互通拉起）和HMS_ServiceCollaboration_StopCollaboration（终止跨设备互通）三个接口。只需要调用这三个接口，即可完成跨端拍照，无需关注分布式场景下数据传输、指令控制等具体细节。
1.  通过系统的分布式协同框架，同账号下的本端设备（2in1设备/平板）与远端设备（手机/平板）自动建立连接。系统将自动完成设备的发现、连接、认证等流程，通过HMS_ServiceCollaboration_GetCollaborationDeviceInfos接口提供可用的具有相机、扫描和图库能力的远端设备信息，通过HMS_ServiceCollaboration_StartCollaboration拉起对应跨设备互通能力，通过HMS_ServiceCollaboration_StopCollaboration终止跨设备互通能力。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/servicecollaboration-servicendk-guide-V14
爬取时间: 2025-04-28 07:30:32
来源: Huawei Developer
跨设备互通提供跨设备的相机、扫描、图库访问能力，平板或2in1设备可以调用手机的相机、扫描、图库等功能。
场景介绍
您通过此能力实现跨设备交互，可以使用其他设备的相机、扫描和图库功能。
约束与限制
需同时满足以下条件，才能使用该功能：
-  条件允许时，建议双端设备接入同一个局域网，可提升唤醒相机的速度。
-  条件允许时，建议双端设备接入同一个局域网，可提升唤醒相机的速度。
-  条件允许时，建议双端设备接入同一个局域网，可提升唤醒相机的速度。
业务流程
接口说明
在开发具体功能前，请先查阅参考文档。
| 接口名 | 描述 |
| --- | --- |
| HMS_ServiceCollaboration_GetCollaborationDeviceInfos | 获取跨设备互通可用的设备信息。 |
| HMS_ServiceCollaboration_StartCollaboration | 拉起跨设备互通能力。 |
| HMS_ServiceCollaboration_StopCollaboration | 取消跨设备互通能力。 |
接口名
描述
HMS_ServiceCollaboration_GetCollaborationDeviceInfos
获取跨设备互通可用的设备信息。
HMS_ServiceCollaboration_StartCollaboration
拉起跨设备互通能力。
HMS_ServiceCollaboration_StopCollaboration
取消跨设备互通能力。
开发步骤
1.引入头文件
```typescript
#include "service_collaboration/service_collaboration_api.h"
```
```typescript
find_library(
# Sets the name of the path variable.
service_collaboration-lib
# Specifies the name of the NDK library that
# you want CMake to locate.
libservice_collaboration_ndk.z.so
)
target_link_libraries(entry PUBLIC
${service_collaboration-lib}
)
```
3.实例代码调用接口，分为以下三步。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/servicecollaboration-richeditor-title-V14
爬取时间: 2025-04-28 07:30:46
来源: Huawei Developer
富文本控件已经集成跨设备互通能力，通过使用富文本控件RichEditor的右键菜单即可使用跨设备互通能力。跨设备互通提供跨设备的相机、扫描、图库访问能力，平板或2in1设备可以调用手机的相机、扫描、图库等功能。
场景介绍
您通过此能力实现跨设备交互，可以使用其他设备的相机、扫描和图库功能。
约束与限制
需同时满足以下条件，才能使用该功能：
-  条件允许时，建议双端设备接入同一个局域网，可提升唤醒相机的速度。
-  条件允许时，建议双端设备接入同一个局域网，可提升唤醒相机的速度。
-  条件允许时，建议双端设备接入同一个局域网，可提升唤醒相机的速度。
开发步骤
使用流程如下：
1.在富文本区域右键。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170505.27000367309693203337510480337031:50001231000000:2800:E662AF3413B1A8DEA0F2F1C487E96626A406D0306509B3F0D10506B157C69C6F.png)
2.选择想要使用的能力。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170505.17466569066672317447352232607137:50001231000000:2800:BC70B0DB08C56F83325A294F890F24B93D7F2F34EA7352CA94D6D71A6F4BF54F.png)
3.等待对端设备拍照回传。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170505.27468852158304562681646225720953:50001231000000:2800:C0A997AEBCD98B501A1EA2C4CBA337DA3FB8F980E9CB32BDF959CC4F8A9CF2ED.png)
4.图片回传后
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170505.00711027612256646618479175348660:50001231000000:2800:F78D690522CEE68A3F3715545352F5BCD03573F5706DEC84D4636A13F1244100.png)
关闭富文本跨设备互通能力
如果需要关闭富文本右键菜单跨设备互通能力，可通过editMenuOptions属性自定义菜单内容去除跨设备互通菜单项即可规避，示例如下：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/servicecollaboration-faq-V14
爬取时间: 2025-04-28 07:30:59
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/servicecollaboration-faq-1-V14
爬取时间: 2025-04-28 07:31:13
来源: Huawei Developer
跨设备互通API支持根据特定调用策略调用设备。调用策略：2in1设备可以调用平板和手机，平板可以调用手机，同类型设备不可调用。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/telephony-kit-V14
爬取时间: 2025-04-28 07:31:27
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/telephony-overview-V14
爬取时间: 2025-04-28 07:31:42
来源: Huawei Developer
Telephony Kit（蜂窝通信服务）提供一系列API帮助开发者开发通讯类应用，包括：
-  call模块（拨打电话）：系统应用可以直接拨打电话，在应用界面显示通话；三方应用可以拉起系统电话应用，跳转至拨号界面，从而实现拨打电话的功能，具体可参考拨打电话开发指导。除此之外，应用还可以通过call模块，实现格式化电话号码、判断是否紧急号码等功能，详情请参考@ohos.telephony.call API参考。
-  sms模块（短信服务）：应用可以实现创建、发送短信消息的功能，具体可参考发送短信开发指导。除此之外，应用还可以实现获取、设置短信服务中心地址，和检查当前设备是否具备短信发送和接收能力等功能，详情请参考@ohos.telephony.sms API参考。
-  radio模块（网络搜索）：应用可以调用API获取当前注册网络名称、网络服务状态以及信号强度相关信息，详情请参考@ohos.telephony.radio API参考。
-  data模块（蜂窝数据）：蜂窝数据是无线通讯技术标准的一种，从数据的传输到交换都采用分组技术（Packet Switch），能够为移动设备提供话音、数据、视频图像等业务，经常用于支持用户在智能设备上使用应用程序，以及在移动网络上浏览网页，详情请参考@ohos.telephony.data API参考。
-  sim模块（SIM卡管理）：应用可以调用API获取SIM卡相关信息，如服务提供商、ISO（International Organization for Standardization，国际标准化组织）国家码、归属PLMN（Public Land Mobile Network，公共陆地移动网络）号等，详情请参考@ohos.telephony.sim API参考。
-  esim模块（eSIM卡管理）：穿戴设备支持eSIM，电话服务提供API给eSIM卡管理和eSIM卡服务使用等，详情请参考@ohos.telephony.esim API参考。
约束与限制
在调用电话服务API前，请确保使用的硬件设备有可以独立蜂窝通信的Modem和SIM卡。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/telephony-call-V14
爬取时间: 2025-04-28 07:31:55
来源: Huawei Developer
场景介绍
开发者可以通过以下方式实现拨打电话的功能：
基本概念
-  通话状态码 将当前的通话状态上报给app，可以根据当前的通话状态去做一些逻辑处理。例如在当前没有正在进行呼叫的时候，可以正常拨打新的一通电话。
| 名称 | 值 | 说明 |
| --- | --- | --- |
| CALL_STATE_UNKNOWN | -1 | 无效状态，当获取呼叫状态失败时返回。 |
| CALL_STATE_IDLE | 0 | 表示没有正在进行的呼叫。 |
| CALL_STATE_RINGING | 1 | 表示来电正在振铃或等待。 |
| CALL_STATE_OFFHOOK | 2 | 表示至少有一个呼叫处于拨号、通话中或呼叫保持状态，并且没有新的来电振铃或等待。 |
约束与限制
接口说明
为了保证应用的运行效率，大部分API调用都是异步的，对于异步调用的API均提供了callback和Promise两种方式，以下示例均采用callback函数，更多方式可以查阅API参考。
| 接口名 | 描述 |
| --- | --- |
| hasVoiceCapability(): boolean; | 判断是否具有语音功能。 |
| makeCall(phoneNumber: string, callback: AsyncCallback<void>): void; | 转到拨号屏幕，显示被叫号码。 |
observer模块为开发者提供订阅和取消订阅通话业务状态的功能。具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| on(type: 'callStateChange', options: { slotId: number }, callback: Callback<{ state: CallState, number: string }>): void; | 监听通话状态变化。 |
开发步骤
使用makeCall拨打电话
1.  导入call和observer模块。
2.  调用hasVoiceCapability，确认当前设备是否支持拨号。
3.  调用makeCall接口，跳转到拨号界面并显示待拨号的号码。
4.  （可选）订阅通话业务状态变化。
```typescript
// import需要的模块
import { call, observer } from '@kit.TelephonyKit';
import { BusinessError } from '@kit.BasicServicesKit';
// 调用查询能力接口
let isSupport = call.hasVoiceCapability();
if (isSupport) {
// 如果设备支持呼叫能力，则继续跳转到拨号界面，并显示拨号的号码
call.makeCall("13xxxx", (err: BusinessError) => {
if (!err) {
console.log("make call success.");
} else {
console.log("make call fail, err is:" + JSON.stringify(err));
}
});
// 订阅通话业务状态变化（可选）
class SlotId {slotId: number = 0}
class CallStateCallback {
state: call.CallState = call.CallState.CALL_STATE_UNKNOWN;
number: string = "";
}
let slotId: SlotId = {slotId: 0}
observer.on("callStateChange", slotId, (data: CallStateCallback) => {
console.log("call state change, data is:" + JSON.stringify(data));
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/telephony-sms-V14
爬取时间: 2025-04-28 07:32:09
来源: Huawei Developer
场景介绍
短信服务模块提供了管理短信的一些基础能力，包括创建、发送短信，获取、设置发送短信的默认SIM卡槽ID，获取、设置短信服务中心地址，以及检查当前设备是否具备短信发送和接收能力等。
基本概念
-  短信服务 即SMS（Short Messaging Service），是一种存储和转发服务。用户的移动电话可以通过它进行相互收发短信，内容以文本、数字或二进制非文本数据为主。发送方的信息通过短信服务中心进行储存并转发给接收方。
-  短信服务中心 即SMSC（Short Message Service Center），负责在基站和移动设备间中继、储存或转发短消息。移动设备到短信服务中心的协议能传输来自移动设备或朝向移动设备的短消息，协议内容遵从GSM 03.40协议。
-  协议数据单元 即PDU（Protocol Data Unit），PDU模式收发短信可以使用3种编码：7-bit、8-bit和UCS-2编码。7-bit编码用于发送普通的ASCII字符，8-bit编码通常用于发送数据短信，UCS-2编码用于发送Unicode字符。
约束与限制
接口说明
为了保证应用的运行效率，大部分API调用都是异步的，对于异步调用的API均提供了callback和Promise两种方式，以下示例均采用callback函数，更多方式可以查阅API参考。
| 接口名 | 描述 |
| --- | --- |
| sendShortMessage(options: SendMessageOptions, callback: AsyncCallback<void>): void | 发送文本或数据SMS消息。需要配置ohos.permission.SEND_MESSAGES权限，该权限仅系统应用可申请。 |
| createMessage(pdu: Array<number>, specification: string, callback: AsyncCallback<ShortMessage>): void | 基于协议数据单元（PDU）和指定的SMS协议创建SMS消息实例。 |
| getDefaultSmsSlotId(callback: AsyncCallback<number>): void | 获取用于发送短信的默认SIM卡。 |
开发步骤
发送短信的接口需要系统权限才可调用，三方应用如果有发送短信需求，需要在应用内实现跳转到短信编辑的功能，并且需要携带编辑内容和收件人号码，可以通过调用元能力startAbility接口指定号码并跳转到发送短信页面的方式实现。
```typescript
// 示例代码
import { common, Want } from '@kit.AbilityKit';
const MMS_BUNDLE_NAME = "com.ohos.mms";
const MMS_ABILITY_NAME = "com.ohos.mms.MainAbility";
const MMS_ENTITIES = "entity.system.home";
export class Contact {
contactsName: string;
telephone: number;
constructor(contactsName: string, telephone: number) {
this.contactsName = contactsName;
this.telephone = telephone;
}
}
@Entry
@Component
struct JumpMessage {
private context = getContext(this) as common.UIAbilityContext;
startMMSAbilityExplicit() {
// 这里完善联系人和号码；姓名主要是通过手机号来查询实际联系人名称，因此这种方式还是以手机号码为主。
let params: Array<Object> = [new Contact("张三", 13344556677)];
let want: Want = {
bundleName: "com.ohos.mms",
abilityName: "com.ohos.mms.MainAbility",
parameters: {
contactObjects: JSON.stringify(params),
pageFlag: "conversation",
// 这里填写短信内容。
content: "我是短信具体内容"
}
};
this.context.startAbilityForResult(want).then((data) => {
console.log("Success" + JSON.stringify(data));
}).catch(() => {
console.log("error");
});
}
build() {
Row() {
Column() {
Button('发送短信')
.onClick(() => {
this.startMMSAbilityExplicit();
})
}
.width('100%')
}
.height('100%')
}
}
```


URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-custom-keyboard
爬取时间: 2025-05-08 03:33:38
来源: Huawei Developer


概述


自定义键盘是一种简易的键盘替换系统默认键盘，允许用户根据实际业务场景和习惯偏好，调整键盘的布局和位置、添加额外的功能键，使输入更加便捷和舒适，从而提升整体的用户体验。同时自定义键盘也可以增强用户输入的安全性，避免敏感信息被截取或者泄露。


本文将从以下几个方面介绍自定义键盘的实现和使用：

- 自定义键盘的实现
- 自定义键盘和系统键盘的切换
- 自定义键盘的布局避让
- 自定义键盘实现防截屏

自定义键盘的实现


自定义键盘的实现包括以下几个步骤：

- 自定义键盘布局实现
- 输入控件绑定自定义键盘布局
- 自定义键盘输入控制
- 自定义键盘光标控制
- 自定义键盘弹出与收起

自定义键盘布局实现


自定义键盘的布局以自定义组件的方式呈现，根据具体业务场景由开发者实现。自定义键盘的高度通过自定义组件根节点的height属性设置，宽度不可设置，默认铺满屏幕。


```less
// entry/src/main/ets/view/CustomKeyboard.ets
@Component
export struct CustomKeyboard {
  // ...


  build() {
    Column() {
      // ...
    }
    // 修改自定义组件根节点的height属性
    .height($r('app.float.keyboard_total_height'))
    // ...
  }
}
```


以Grid方式实现数字键盘布局示例：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152933.52488271185715059612659998326304:50001231000000:2800:A52EAA90F5EEBC736E3326B9397EE19F34C52B70BFFEBBAC50909579F429DED3.gif)

```typescript
// entry/src/main/ets/view/NumberKeyboard.ets
@Component
export struct NumberKeyboard {
  @Consume inputText: string;
  @Consume keyBoardController: KeyboardController;
  layoutOptions: GridLayoutOptions = {
    regularSize: [1, 1],
    irregularIndexes: [14, 16],
    onGetIrregularSizeByIndex: (index: number) => {
      if (index === 14) {
        return [2, 1];
      }
      return [1, 2];
    }
  }


  build() {
    Grid(undefined, this.layoutOptions) {
      ForEach(numberKeyboardData, (item: Menu) => {
        GridItem() {
          Button(item.text, { type: ButtonType.Normal })
            .onClick(() => {
              this.inputText = this.keyBoardController.onInput(item.text);
            })
            .fontColor(Color.Black)
            .backgroundColor(item.backgroundColor)
            .borderRadius(Constants.KEYBOARD_BUTTON_RADIUS)
            .fontSize(Constants.KEYBOARD_BUTTON_FONTSIZE_18)
            .padding(0)
            .width(item.width)
            .height(item.height)
        }
      }, (item: string) => JSON.stringify(item))
    }
    .columnsTemplate('1fr 1fr 1fr 1fr 1fr')
    .rowsGap($r('app.float.number_keyboard_grid_gap'))
    .columnsGap($r('app.float.number_keyboard_grid_gap'))
  }
}
```


输入控件绑定自定义键盘布局


输入控件（TextArea、TextInput、RichEditor、Search）支持通过customKeyboard属性绑定自定义键盘布局。绑定自定义键盘后，输入控件获取焦点时，不会拉起系统键盘，而是加载指定的自定义键盘。本文后续以TextInput控件为例进行介绍。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152933.83085568386604613290450621161961:50001231000000:2800:40BE5B0F564DE398026249731B0C8E4F1B0A7F578DBF34E9B89C39F7C176C1FB.gif)

代码示例如下：


```less
build() {
  Column() {
    TextInput({
      placeholder: '绑定自定义键盘',
      text: this.inputText,
      controller: this.textInputController
    })
      // 绑定自定义键盘布局
      .customKeyboard(this.customKeyboard())
      // ...
  }
}


@Builder
customKeyboard() {
  CustomKeyboard()
}
```


自定义键盘输入控制


自定义键盘可以拦截手势事件，通过对状态变量的修改，实现文本的输入。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152933.96290573092895277147026868418499:50001231000000:2800:FCCD6174BEE875E508D67AFF612812FE8DFACC79384298B9B74FEC13074AD04E.gif)

以英文键盘为例，监听EnglishButton的onClick事件，修改状态变量。


```less
// entry/src/main/ets/view/EnglishKeyboard.ets
@Component
struct EnglishButton {
  @Consume inputText: string;
  // ...


  build() {
    Button(this.getEnglishText(this.item), { type: ButtonType.Normal })
      // ...
      .onClick(() => {
        // 拦截自定义键盘按钮的点击事件，根据业务场景修改状态变量
        this.inputText = this.keyBoardController.onInput(this.getEnglishText(this.item));
      })
  }
}
```


通过对状态变量inputText的修改，实现文本输入。


```less
// entry/src/main/ets/view/TextInputComponent.ets
@Component
export struct TextInputComponent {
  @Provide inputText: string = '';
  // ...


  build() {
    Column() {
      TextInput({
        placeholder: '绑定自定义键盘',
        text: this.inputText,
        controller: this.textInputController
      })
      // ...
    }
  }


  // ...
}
```


自定义键盘光标控制


通过监听TextInput的onTextSelectionChange生命周期，获取初始光标位置、文本输入后，调用TextInputController的caretPosition方法，设置最终光标位置。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152933.17922718828744793583081336003567:50001231000000:2800:53D3579CC645A78F1E3E60FFDE088C79EAA6C419EA9047C667DAC6624820E3BB.gif)

获取光标位置：


```less
// entry/src/main/ets/view/TextInputComponent.ets
TextInput({
  placeholder: '绑定自定义键盘',
  text: this.inputText,
  controller: this.textInputController
})
  // 监听光标位置变化
  .onTextSelectionChange((start: number, end: number) => {
    this.keyBoardController.setCaretPosition(start, end);
  })
  // ...
```


设置光标位置：


```less
// entry/src/main/ets/model/KeyboardController.ets
onChange(value: string) {
  this.text = value;
  if (this.keyBoardType !== Constants.SYSTEM_KEYBOARD) {
    // 设置光标位置
    this.textInputController?.caretPosition(this.targetCaretPos);
  }
}
```


自定义键盘弹出与收起


通过对焦点进行控制，可以实现键盘的弹出和收起，参考软键盘的弹出收起和监听。


开发者也可以通过TextInputController的stopEditing方法控制键盘关闭，下面的自定义键盘示例中，点击确认按键关闭自定义键盘。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152933.84522794793343789545932424241558:50001231000000:2800:11F15D0B3913E627B0053BBDFE48D8D526A93AE68881A6D92E889B2806A308D2.gif)

```less
// entry/src/main/ets/model/KeyboardController.ets
onInput(value: string): string {
  switch (value) {
    // ...
    case '确定':
      this.textInputController?.stopEditing();
      break;
    // ...
  }
  return this.text;
}
```


自定义键盘和系统键盘的切换


当需要实现同一个输入框内可以切换自定义键盘和系统键盘时，可以通过如下方式实现：


Tab栏点击“123”、“ABC”按钮，this.isCustomKeyboardAttach为true，TextInput绑定自定义键盘；点击“中文”按钮，this.isCustomKeyboardAttach为false，切换系统键盘。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152934.98968686338829511071317603160455:50001231000000:2800:7FD8D8D8327846786C87BF2B058DAC1DB5A81C6F6A67D0D52C89A8D1A8064924.gif)

```less
// entry/src/main/ets/view/TextInputComponent.ets
TextInput({
  placeholder: '绑定自定义键盘',
  text: this.inputText,
  controller: this.textInputController
})
  .customKeyboard(this.isCustomKeyboardAttach ? this.customKeyboard() : null)
  // ...
```


自定义键盘的布局避让


使用系统提供的自定义键盘避让功能


为了确保输入框不被自定义键盘挡住，系统默认提供了输入框避让自定义键盘的能力。在TextInput组件的customKeyboard属性设置supportAvoidance为true，开启系统提供的自定义键盘避让功能。键盘的避让机制和常见问题的解决方法，可以参考软键盘布局适配场景介绍。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152934.10499225024958077274164348193591:50001231000000:2800:B5D0E9D9A59702845045839C7C5A2BA99C2C09B47EDCB2F726943F0B5227728B.gif)

```less
// entry/src/main/ets/view/TextInputComponent.ets
TextInput({
  placeholder: '绑定自定义键盘',
  text: this.inputText,
  controller: this.textInputController
})
  .customKeyboard(this.customKeyboard(), { supportAvoidance: true })
  // ...
```


系统默认的自定义键盘避让功能只能保证输入框不被遮挡，输入框下方的组件可能会被自定义键盘挡住，如上图中所示，输入框下方的tab栏被自定义键盘挡住。为解决这一问题，需要开发者自己实现自定义键盘的避让功能。


开发者自己实现自定义键盘的避让功能


开发者需要监听自定义键盘根节点的onAreaChange生命周期，获取自定义键盘的高度，根据实际场景设置布局的避让。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152934.40050614596389020150826202695611:50001231000000:2800:8E7E43ACD16802B77BB063A85AAA0D9A133CBACD8A08E415C7D9D2EFEFA23040.gif)

监听自定义键盘布局的onAreaChange生命周期，通过newValue.height获取自定义键盘弹出时的高度，根据实际业务场景计算布局避让高度avoidHeight。


```typescript
// entry/src/main/ets/view/CustomKeyboard.ets
@Component
export struct CustomKeyboard {
  // ...


  build() {
    Column() {
      // ...
    }
    .onAreaChange((oldValue: Area, newValue: Area) => {
      this.customKeyboardHeight = Number(newValue.height);
      let avoidHeight: number = (this.isCustomKeyboardAttach ? this.customKeyboardHeight : this.systemKeyboardHeight)
        - this.bottomRectHeight;
      this.keyBoardController.changeAvoidHeight(avoidHeight);
    })
    // ...
  }
}
```


通过emitter的方式，发送自定义键盘高度变化的通知。


```less
// entry/src/main/ets/model/KeyboardController.ets
// 以公共事件的形式，通知布局高度变化
changeAvoidHeight(value: number) {
  let event: emitter.InnerEvent = {
    eventId: Constants.AVOID_EVENT_ID
  };
  let eventData: emitter.EventData = {
    data: {
      'avoidHeight': value
    }
  };
  emitter.emit(event, eventData);
}
```


接收到高度变化通知后，根据实际业务场景，设置页面的避让高度。


```less
// entry/src/main/ets/pages/MainPage.ets
@Entry
@Component
struct MainPage {
  @State bottomPadding: number = Constants.MAIN_PAGE_INITIAL_PADDING;


  aboutToAppear(): void {
    let event: emitter.InnerEvent = {
      eventId: Constants.AVOID_EVENT_ID
    };
    emitter.on(event, (eventData: emitter.EventData) => {
      if (eventData.data) {
        let avoidHeight: number = eventData.data['avoidHeight'];
        if (avoidHeight === 0) {
          this.bottomPadding = Constants.MAIN_PAGE_INITIAL_PADDING;
        } else {
          this.bottomPadding = avoidHeight;
        }
      }
    });
  }


  build() {
    Navigation() {
      Column() {
        // ...
      }
      .padding({ bottom: this.bottomPadding })
      // ...
    }
    .mode(NavigationMode.Stack)
    .titleMode(NavigationTitleMode.Full)
    .title($r('app.string.main_page_title'))
  }
}
```


自定义键盘实现防截屏


用户使用自定义键盘输入敏感信息时，可以设置禁止截屏，有效防止他人在未经许可的情况下获取用户的敏感信息，从而保护用户的隐私安全。具体实现参考如何实现防截屏功能。


示例代码

- 自定义键盘案例

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-local-file
爬取时间: 2025-05-08 03:33:45
来源: Huawei Developer

- 多线程操作密集型关系型数据库和文件读写

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-local-file-and-data-multithreaded-io
爬取时间: 2025-05-08 03:33:52
来源: Huawei Developer


概述


应用中的每个进程都会有一个主线程，主线程主要承担执行UI绘制操作、管理ArkTS引擎实例的创建和销毁、分发和处理事件、管理Ability生命周期等职责，具体可参见线程模型概述。在主线程中执行耗时操作将会引起UI绘制卡顿，因此，开发应用时应当尽量避免将耗时的操作放在主线程中执行。ArkTS提供了多线程并发能力，多线程并发允许在同一时间段内同时执行多段代码，本文介绍如何利用多线程解决密集型文件和数据库读写时造成主线程阻塞的问题。


实现原理


在密集型读写操作时，由于系统会进行大量任务分发和数据拷贝，这两项任务均会阻塞主线程，系统提供了TaskPool和Sendable避免阻塞。


其中，任务池（TaskPool）旨在为应用程序构建多线程运行环境，它具有易用性，并且可以避免对于主线程的占用；Sendable对象则提供了并发实例间高效的通信效率，凭借其引用传递的能力，在多并发实例的数据交互等场景中可避免传统通信方式的效率低下问题，从而进一步提升系统在密集型读写这类复杂场景下的性能表现，为系统的高效稳定运行提供有力支持。


使用TaskPool进行读写


本章介绍使用TaskPool进行读写的方案，以及讨论其对于性能的提升。


实现原理


任务池（TaskPool）作用是为应用程序提供一个多线程的运行环境，降低整体资源的消耗、提高系统的整体性能，且开发者无需关心线程实例的生命周期。更多原理请详见TaskPool简介。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152934.78973702783850893532382866216159:50001231000000:2800:B65C8238AB2E8F51DCAB60837B5BBABDCAF81D368C12DE375FB8E6B46A57CD85.png)

TaskPool在执行密集型I/O读写方面具有以下优势：


TaskPool文件读写


开发步骤


```less
@Concurrent
function writeFile(fd: number[], content: string, times: number) {
  for (let i: number = 0; i < times; i++) {
    fileIo.write(fd[i], content);
  }
}
```


```less
@Concurrent
function readFile(fd: number[], path: string, fileName: string, times: number): Array<Array<ArrayBuffer>> {
  let result: Array<Array<ArrayBuffer>> = [];
  for (let i = 0; i < times; i++) {
    let buffSize: number = 4096;
    let state = fileIo.statSync(path + fileName + JSON.stringify(i) + '.txt');
    let buffer: ArrayBuffer = new ArrayBuffer(Math.min(buffSize, state.size));
    let off: number = 0;
    let len: number = fileIo.readSync(fd[i], buffer, { offset: off, length: buffSize });
    let readLen: number = 0;
    let bufferList: Array<ArrayBuffer> = [];
    while (len > 0) {
      readLen += len;
      bufferList.push(buffer)
      off = off + len;
      if ((state.size - readLen) < buffSize) {
        buffSize = state.size - readLen;
      }
      len = fileIo.readSync(fd[i], buffer, { offset: off, length: buffSize });
    }
    result.push(bufferList);
  }
  return result;
}
```


```less
async write(): Promise<void> {
  await taskpool.execute(writeFile, this.fd, this.content, this.times);
  // ...
}


async read(): Promise<void> {
  await taskpool.execute(readFile, this.path, this.fileName, this.times);
  // ...
}
```


TaskPool关系型数据库读写


开发步骤


```less
@Concurrent
async function insert(context: common.UIAbilityContext, valueBucket: Array<relationalStore.ValuesBucket>,
  config: relationalStore.StoreConfig) {
  const store = await relationalStore.getRdbStore(context, config);
  store.batchInsert('EMPLOYEE', valueBucket);
}
```


```less
@Concurrent
async function read(context: common.UIAbilityContext, config: relationalStore.StoreConfig) {
  const store = await relationalStore.getRdbStore(context, config);
  const predicates = new relationalStore.RdbPredicates('EMPLOYEE');
  const resultSet = store.querySync(predicates)
  let ValuesBucketArray: ValuesBucket[] = [];
  resultSet.goToFirstRow();
  do {
    const ValuesBucket = resultSet.getRow() as ValuesBucket;
    ValuesBucketArray.push(ValuesBucket)
  } while (resultSet.goToNextRow());
  resultSet.close();
  return ValuesBucketArray;
}
```


```less
async insertRDB(): Promise<void> {
  await taskpool.execute(insert, this.context, this.valueBucketArray, STORE_CONFIG);
  return;
}
```


使用Sendable进一步提升性能


在上一章节中介绍了如何使用TaskPool进行读写，解决了密集型读写场景下任务分发的的问题，但是实际开发中还面临密集的数据传递问题，系统提供了@Sendable进行解决，本章我们介绍如何在TaskPool基础上使用@Sendable。


实现原理


为了实现Sendable数据在不同并发实例间的引用传递，Sendable共享对象会分配在共享堆中，以实现跨并发实例的内存共享。


共享堆（SharedHeap）是进程级别的堆空间，与虚拟机本地堆（LocalHeap）不同的是，LocalHeap只能被单个并发实例访问，而SharedHeap可以被所有线程访问。一个Sendable共享对象的跨线程行为是引用传递。因此，Sendable可能被多个并发实例引用，判断Sendable共享对象是否存活，取决于所有并发实例的对象是否存在对此Sendable共享对象的引用，更多原理请见Sendable的实现原理。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152934.33566004920199653807559295194421:50001231000000:2800:EBD374A5EEF1AA6F9A402CCC3F7BC892F658052C62014FC9498448CE716FC626.png)

在密集型I/O处理场景中，文件读写会涉及大量数据的传输，而数据库读写则通常被封装成class进行传递，Sendable用引用代替拷贝，可以有效的降低序列化时间，从而提升性能，Sendable主要可以解决两个场景的问题：

- 跨并发实例传输大数据（例如可能达到100KB以上的数据）。
- 跨并发实例传递带方法的class实例对象。

文件读写大数据使用@Sendable传输


开发步骤


```typescript
@Sendable
class Content {
  content: string;


  constructor(content: string) {
    this.content = content;
  }
}
```


```less
@Concurrent
function readFile(fd: number[], path: string, fileName: string,
  times: number): collections.Array<collections.Array<collections.ArrayBuffer>> {
  let result: collections.Array<collections.Array<collections.ArrayBuffer>> =
    new collections.Array<collections.Array<collections.ArrayBuffer>>();
  for (let i = 0; i < times; i++) {
    let buffSize: number = 4096;
    let state = fileIo.statSync(path + fileName + JSON.stringify(i) + '.txt');
    let buffer: collections.ArrayBuffer = new collections.ArrayBuffer(Math.min(buffSize, state.size));
    let off: number = 0;
    let len: number = fileIo.readSync(fd[i], buffer as ArrayBuffer, { offset: off, length: buffSize });
    let readLen: number = 0;
    let bufferList: collections.Array<collections.ArrayBuffer> = new collections.Array<collections.ArrayBuffer>();
    while (len > 0) {
      readLen += len;
      bufferList.push(buffer);
      off = off + len;
      if ((state.size - readLen) < buffSize) {
        buffSize = state.size - readLen;
      }
      len = fileIo.readSync(fd[i], buffer as ArrayBuffer, { offset: off, length: buffSize });
    }
    result.push(bufferList);
  }
  return result;
}
```


```less
async write(): Promise<void> {
  await taskpool.execute(writeFile, this.fd, this.content, this.times);
  // ...
}


async read(): Promise<void> {
  await taskpool.execute(readFile, this.path, this.fileName, this.times);
  // ...
}
```


关系型数据库读写使用@Sendable


开发步骤


```less
@Sendable
class SharedValuesBucket {
  NAME: string;
  AGE: number;
  SALARY: number;


  constructor(NAME: string, AGE: number, SALARY: number) {
    this.NAME = NAME;
    this.AGE = AGE;
    this.SALARY = SALARY;
  }
}
```


```less
@Concurrent
async function read(context: common.UIAbilityContext, config: relationalStore.StoreConfig) {
  const store = await relationalStore.getRdbStore(context, config);
  const predicates = new relationalStore.RdbPredicates('EMPLOYEE');
  const resultSet = store.querySync(predicates)
  let ValuesBucketArray: sendableRelationalStore.ValuesBucket[] = [];
  resultSet.goToFirstRow();
  do {
    const ValuesBucket = resultSet.getSendableRow();
    ValuesBucketArray.push(ValuesBucket)
  } while (resultSet.goToNextRow());
  resultSet.close();
  return ValuesBucketArray;
}
```


```less
async insertRDB(): Promise<void> {
  await taskpool.execute(insert, this.context, this.valueBucketArray, STORE_CONFIG);
}


async readRDB(): Promise<void> {
  await taskpool.execute(read, this.context, STORE_CONFIG).then((values: object) => {
  })
}
```


URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-ndk-development
爬取时间: 2025-05-08 03:33:58
来源: Huawei Developer

- Native侧实现文件访问开发实践
- 跨语言调用复杂参数传递开发实践
- Native侧跨HAR/HSP模块接口调用开发实践
- 三方动态链接库（.so）集成开发实践
- 高负载场景下线程优先级设置防止中断关键线程
- Native侧子线程与UI主线程通信开发

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-file-native-side
爬取时间: 2025-05-08 03:34:04
来源: Huawei Developer


概述


在对文件处理性能要求高的场景中，Native侧访问文件处理数据比在ArkTS侧操作文件有更高的效率和更快的响应，例如处理大文件、复杂的文件操作以及实时通信等低时延场景。根据文件位置的不同，应用在Native侧访问文件可以分为以下三种类型：

- 类型一：访问应用沙箱内的文件进行读写操作，主要是通过沙箱路径进行访问；
- 类型二：访问应用资源文件进行读操作，可以通过传递资源管理器进行访问；
- 类型三：访问系统公共目录中的文件进行读写操作，可以使用文件picker来获取文件描述符。

本文将针对这三种场景给出具体的实现方案。


访问应用沙箱文件


应用沙箱是一种以安全防护为目的的隔离机制，避免数据受到恶意路径穿越访问。在这种沙箱的保护机制下，应用可见的目录范围即为“应用沙箱目录”，沙箱中的文件就需要通过沙箱路径去进行访问。Native侧获取沙箱路径的方案有两种：

- 方案一：ArkTS侧获取沙箱路径传递给Native侧访问文件。
- 方案二：Native侧直接拼接沙箱路径访问文件。

方案一：ArkTS侧获取沙箱路径传递给Native侧访问文件

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152934.18475202064108363544360557253262:50001231000000:2800:6C1ACC807316D492BDAF6192F0D0C1444DA49CAD9E0504FCBADF90B8A0EA40CC.png)

实现方案


这里以访问沙箱文件并写入文本的场景为例，实现方案分为Native侧定义操作文件的方法和ArkTS侧调用该方法两部分。


第一部分：在Native侧定义一个方法，用于接收沙箱路径并将文本写入到文件中。


```less
napi_get_value_string_utf8(env, argv[0], pathBuf, sizeof(pathBuf), &pathSize);
napi_get_value_string_utf8(env, argv[1], contentsBuf, sizeof(contentsBuf), &contentsSize);
```


```less
FILE *fp;
fp = fopen(pathBuf, "w");
```


```less
fprintf(fp, "%s", contentsBuf);
```


```less
// entry/src/main/cpp/FileAccessMethods.cpp
static napi_value TransferSandboxPath(napi_env env, napi_callback_info info) {
    size_t argc = 2;
    napi_value argv[2] = {nullptr};
    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr);


    //将沙箱路径和要写入文本的内容通过Node-API接口转换成C侧变量
    size_t pathSize, contentsSize;
    char pathBuf[256], contentsBuf[256];
    napi_get_value_string_utf8(env, argv[0], pathBuf, sizeof(pathBuf), &pathSize);
    napi_get_value_string_utf8(env, argv[1], contentsBuf, sizeof(contentsBuf), &contentsSize);


    //通过指定的路径打开文件
    snprintf(pathBuf, sizeof(pathBuf), "%s/TransferSandboxPath.txt", pathBuf);
    FILE *fp;
    fp = fopen(pathBuf, "w");
    if (fp == nullptr) {
        OH_LOG_Print(LOG_APP, LOG_ERROR, DOMAIN, TAG, "open file error!");
        return nullptr;
    }
    //使用C标准库的文件操作函数写入文件
    fprintf(fp, "%s", contentsBuf);
    fclose(fp);
    return nullptr;
}
```


```typescript
export const transferSandboxPath: (path: string, contents: string) => void;
```


第二部分：在Native侧访问沙箱文件写数据的功能实现后，在ArkTS侧调用该方法。


```less
import FileAccess from 'libfile_access.so';
```


```less
private sandboxFilesDir: string = getContext(this).filesDir;
```


```less
FileAccess.transferSandboxPath(this.sandboxFilesDir, content);
```


通过上述步骤，实现了在Native侧通过ArkTS侧传递的沙箱路径访问与操作应用沙箱文件的方案。


效果展示

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152934.32204932569615696877229481682510:50001231000000:2800:91BB66F34F56E44BF095B8C2D08F9CDBF24C221107E47C1BFD91EFE3A8EB019C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152934.37400988172642155532075072886004:50001231000000:2800:17E1B7B53775851E832BB6E1E88BB425717152E73C592CA605FB1D90C2C9C615.png)

方案二：Native侧直接拼接沙箱路径访问文件

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152934.63762317747294539428346941945825:50001231000000:2800:63F649193325EB6396937182E97F02185C0FF9B22B079711CB01C13ACD3B0CF3.png)

实现方案


这里同样以访问沙箱文件并写入文本的场景为例，实现方案分为Native侧定义操作文件的方法和ArkTS侧调用该方法两部分。


第一部分：在Native侧定义一个方法，用于拼接沙箱路径并将文本写入到文件中。


```less
char pathBuf[256] = "/data/storage/el2/base/haps/entry/files/SplicePath.txt";
```


```less
napi_get_value_string_utf8(env, argv[0], contentsBuf, sizeof(contentsBuf), &contentsSize);
```


```less
FILE *fp;
fp = fopen(pathBuf, "w");
```


```less
fprintf(fp, "%s", contentsBuf);
```


```less
// entry/src/main/cpp/FileAccessMethods.cpp
static napi_value SplicePath(napi_env env, napi_callback_info info) {
    size_t argc = 1;
    napi_value argv[1] = {nullptr};
    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr);


    //根据实际文件位置拼接沙箱路径
    size_t contentsSize;
    char pathBuf[256] = "/data/storage/el2/base/haps/entry/files/SplicePath.txt";
    //将要写入文本的内容通过Node-API接口转换成C侧变量
    char contentsBuf[256];
    napi_get_value_string_utf8(env, argv[0], contentsBuf, sizeof(contentsBuf), &contentsSize);


    //通过指定的路径打开文件
    FILE *fp;
    fp = fopen(pathBuf, "w");
    if (fp == nullptr) {
        OH_LOG_Print(LOG_APP, LOG_ERROR, DOMAIN, TAG, "open file error!");
        return nullptr;
    }
    //使用C标准库的文件操作函数写入文件
    fprintf(fp, "%s", contentsBuf);
    fclose(fp);
    return nullptr;
}
```


```typescript
export const splicePath: (contents: string) => void;
```


第二部分：Native侧访问沙箱文件写数据的功能实现后，在ArkTS侧调用该方法。


```less
import FileAccess from 'libfile_access.so';
```


```less
FileAccess.splicePath(content);
```


通过上述步骤，实现了在Native侧通过拼接沙箱路径访问与操作应用沙箱文件的方案。


效果展示

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152934.26120008780712147791476939654856:50001231000000:2800:ADE4577E998E6838644CC04A34EDD88AE515F225935870A30C4BCD7FA54B3CD9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152935.43860876291280417555571388183548:50001231000000:2800:826481E3B93367E990468FE054B108F4FA98B05227339DCBAEFD7ECE139A5CA1.png)

访问应用包内资源文件


Native侧可以通过Resource Manager操作应用资源文件中的Rawfile目录和文件，这里以Native侧读取Rawfile文件内容的场景为例介绍该方案。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152935.48816575987720079918803034115257:50001231000000:2800:9890D6311E7DAB9CEF612FA4DF78C748D346BF7151CBC4CF76CF5B9D3909C462.png)

实现方案


实现方案分为Native侧定义操作文件的方法和ArkTS侧调用该方法两部分。


第一部分：在Native侧定义一个读取文件的方法，注意使用Resource Manager需要引用头文件rawfile/raw_file_manager.h，并在工程的cmakelists.txt文件中链接动态库librawfile.z.so。


```less
NativeResourceManager *mNativeResMgr = OH_ResourceManager_InitNativeResourceManager(env, argv[0]);
```


```less
napi_get_value_string_utf8(env, argv[0], contentsBuf, sizeof(contentsBuf), &contentsSize);
```


```less
RawFile *rawFile = OH_ResourceManager_OpenRawFile(mNativeResMgr, fileNameBuf);
```


```less
long len = OH_ResourceManager_GetRawFileSize(rawFile);
std::unique_ptr<char[]> data = std::make_unique<char[]>(len);
OH_ResourceManager_ReadRawFile(rawFile, data.get(), len);
```


```less
// entry/src/main/cpp/FileAccessMethods.cpp
static napi_value TransferResourceMgr(napi_env env, napi_callback_info info) {
    size_t argc = 2;
    napi_value argv[2] = {nullptr};
    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr);


    //将传入的resource manager对象转换为Native对象
    NativeResourceManager *mNativeResMgr = OH_ResourceManager_InitNativeResourceManager(env, argv[0]);
    size_t fileNameSize;
    char fileNameBuf[256];
    //将传入的文件名通过Node-API接口转换成C侧变量
    napi_get_value_string_utf8(env, argv[1], fileNameBuf, sizeof(fileNameBuf), &fileNameSize);
    //通过资源对象打开文件
    RawFile *rawFile = OH_ResourceManager_OpenRawFile(mNativeResMgr, fileNameBuf);
    if (rawFile != nullptr) {
        OH_LOG_Print(LOG_APP, LOG_INFO, DOMAIN, TAG, "OH_ResourceManager_OpenRawFile success.");
    }


    //通过资源对象读取文件内容
    long len = OH_ResourceManager_GetRawFileSize(rawFile);
    std::unique_ptr<char[]> data = std::make_unique<char[]>(len);
    OH_ResourceManager_ReadRawFile(rawFile, data.get(), len);
    OH_ResourceManager_CloseRawFile(rawFile);
    OH_ResourceManager_ReleaseNativeResourceManager(mNativeResMgr);
    napi_value contents;
    napi_create_string_utf8(env, data.get(), len, &contents);
    return contents;
}
```


```typescript
export const transferResourceMgr: (resMgr: resourceManager.ResourceManager, path: string) => string;
```


第二部分：Native侧访问Rawfile文件读数据的功能实现后，在ArkTS侧调用该方法。


```less
import FileAccess from 'libfile_access.so';
```


```less
private resMgr: resourceManager.ResourceManager = getContext().resourceManager;
```


```less
let rawfileContext = FileAccess.transferResourceMgr(this.resMgr, FileNameList[2]);
```


通过上述步骤，实现了在Native侧通过ArkTS侧传递的Resource Manager访问与读取应用资源文件的方案。


效果展示

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152935.44657672740730290372345928857723:50001231000000:2800:1425AEF5D87B03F51151280962410E1E4F8D29993DCA4DA9F3255E24C38EFF7C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152935.75524422826487709891271829307219:50001231000000:2800:94A78BED5BD20638D1FC4BD5732A76A92932CD695095DA470D0455816085B3F7.png)

访问公共目录文件


系统公共目录下储存的是用户文件，应用对用户文件的操作需要提前获取用户授权，或由用户操作完成。我们可以通过系统预置的文件选择器（FilePicker）实现该能力，目前主要有创建文件、写入和读取三类操作，创建文件可以直接使用picker，针对Native侧，有如下两种场景：

- 场景一：写数据到公共目录文件；
- 场景二：从公共目录文件中读取数据。

场景一：写数据到公共目录文件


场景描述


ArkTS侧通过文件picker在公共目录下创建文件，并传递文件描述符到Native侧，Native侧通过文件描述符打开文件并将数据写入到文件中。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152935.25383503061729600355157571873458:50001231000000:2800:6F1D6920D24D2CE499539E1376881868AB6FE246B56DEEBDC51084904A7D03A9.png)

实现方案


实现方案分为Native侧定义操作文件的方法和ArkTS侧调用该方法两部分。


第一部分：在Native侧定义一个方法，用于接收文件描述符并将数据写入到文件中，注意使用文件描述符操作文件需要引用头文件unistd.h。


```less
napi_get_value_uint32(env, argv[0], &fd);
napi_get_value_string_utf8(env, argv[1], contentsBuf, sizeof(contentsBuf), &contentsSize);
```


```less
size_t buffSize = write(fd, contentsBuf, contentsSize);
```


```less
std::string res;
napi_value contents;
if (buffSize == -1) {
    res = "Write File Failed!";
    OH_LOG_Print(LOG_APP, LOG_INFO, DOMAIN, TAG, "%s", res.c_str());
} else {
    res = "Write File Successfully!!!";
    OH_LOG_Print(LOG_APP, LOG_INFO, DOMAIN, TAG, "%s", res.c_str());
}
napi_create_string_utf8(env, res.c_str(), sizeof(res), &contents);
return contents;
```


```less
// entry/src/main/cpp/FileAccessMethods.cpp
static napi_value WriteFileUsingPickerFd(napi_env env, napi_callback_info info) {
    size_t argc = 2;
    napi_value argv[2] = {nullptr};
    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr);


    unsigned int fd = -1;   
    size_t contentsSize;
    char contentsBuf[256];
    //将传入的文件描述符和要写入文件的内容转换成C侧变量
    napi_get_value_uint32(env, argv[0], &fd);
    napi_get_value_string_utf8(env, argv[1], contentsBuf, sizeof(contentsBuf), &contentsSize);


    ftruncate(fd, 0);
    //使用C标准库的文件操作函数写入文件
    size_t buffSize = write(fd, contentsBuf, contentsSize);
    std::string res;
    //根据write函数的返回值判断操作是否成功返回结果
    napi_value contents;
    if (buffSize == -1) {
        res = "Write File Failed!";
        OH_LOG_Print(LOG_APP, LOG_INFO, DOMAIN, TAG, "%s", res.c_str());
    } else {
        res = "Write File Successfully!!!";
        OH_LOG_Print(LOG_APP, LOG_INFO, DOMAIN, TAG, "%s", res.c_str());
    }
    napi_create_string_utf8(env, res.c_str(), sizeof(res), &contents);
    return contents;
}
```


```typescript
export const writeFileUsingPickerFd: (fd: number, contents: string) => string;
```


第二部分：Native侧访问公共目录文件写数据的功能实现后，在ArkTS侧调用该方法。


```less
import FileAccess from 'libfile_access.so';
```


```typescript
// entry/src/main/ets/common/utils/FileOperate.ets
async function WriteFileByPicker(contents: string): Promise<string> {
  //配置picker选择信息
  const documentSelectOptions = new picker.DocumentSelectOptions();
  documentSelectOptions.maxSelectNumber = 1;
  documentSelectOptions.fileSuffixFilters = ['.txt'];


  let uris: Array<string> = [];
  const documentViewPicker = new picker.DocumentViewPicker();
  //拉起picker选择文件
  return await documentViewPicker.select(documentSelectOptions).then((documentSelectResult: Array<string>) => {
    uris = documentSelectResult;
    let uri: string = uris[0];
    let path: string = new fileUri.FileUri(uri).path;
    console.info(`Open The File path is [${uri}]`);
    let file = fs.openSync(path, fs.OpenMode.WRITE_ONLY);
    //调用native方法写文件
    let res = FileAccess.writeFileUsingPickerFd(file.fd, contents);
    fs.closeSync(file.fd);
    return res;
  }).catch((error: BusinessError) => {
    console.error(`Open The file failed, error code is [${error.code}], error message is [${error.message}]`);
    return 'Write Failed by Picker';
  })
}
```


通过上述步骤，实现了在Native侧通过ArkTS侧picker传递的文件资源描述符访问公共目录文件并写入内容的方案。


效果展示

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152935.95555991108597099328255084945819:50001231000000:2800:B5B88BA839C526BCDAF429EA5C63B2E1AC66EE4F1B1600578126446139636881.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152935.21968318135922494067671501303429:50001231000000:2800:2A84BEB7927AC1E4785328665914DAA15170FC8082F426E504EEBC0F389E1E54.png)

场景二：从公共目录文件中读取数据


场景描述


ArkTS侧通过文件picker选择文件，并传递文件描述符到Native侧，Native侧通过文件描述符打开文件并读取文件数据。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152935.75138499389994029089484621163291:50001231000000:2800:016F0ED74ABFD3C063EACDC2601FF3BD7ACC9E9F333B8DED8EAE5A6A1E66D0D6.png)

实现方案


实现方案分为Native侧定义操作文件的方法和ArkTS侧调用该方法两部分。


第一部分：在Native侧定义一个方法，用于接收文件描述符并将数据写入到文件中，注意使用文件描述符操作文件需要引用头文件unistd.h。


```less
napi_get_value_uint32(env, argv[0], &fd);
```


```less
char buff[1000];
size_t buffSize = read(fd, buff, sizeof(buff));
```


```less
napi_value contents;
if (buffSize == -1) {
    OH_LOG_Print(LOG_APP, LOG_INFO, DOMAIN, TAG, "Read File Failed!!!");
} else {
    OH_LOG_Print(LOG_APP, LOG_INFO, DOMAIN, TAG, "Read File Successfully!!!");
    napi_create_string_utf8(env, buff, buffSize, &contents);
}
return contents;
```


```less
// entry/src/main/cpp/FileAccessMethods.cpp
static napi_value ReadFileUsingPickerFd(napi_env env, napi_callback_info info) {
    size_t argc = 1;
    napi_value argv[1] = {nullptr};
    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr);


    unsigned int fd = -1;
    //将传入的文件描述符转换成C侧变量
    napi_get_value_uint32(env, argv[0], &fd);


    //使用C标准库的文件操作函数读取文件
    char buff[1000];
    size_t buffSize = read(fd, buff, sizeof(buff));
    //判断读取是否成功并返回文件内容
    napi_value contents;
    if (buffSize == -1) {
        OH_LOG_Print(LOG_APP, LOG_INFO, DOMAIN, TAG, "Read File Failed!!!");
    } else {
        OH_LOG_Print(LOG_APP, LOG_INFO, DOMAIN, TAG, "Read File Successfully!!!");
        napi_create_string_utf8(env, buff, buffSize, &contents);
    }
    return contents;
}
```


```typescript
export const readFileUsingPickerFd: (fd: number) => string;
```


第二部分：Native侧访问公共目录文件读数据的功能实现后，在ArkTS侧调用该方法。


```less
import FileAccess from 'libfile_access.so';
```


```typescript
// entry/src/main/ets/common/utils/FileOperate.ets
async function ReadFileByPicker(): Promise<string> {
  //配置picker选择信息
  const documentSelectOptions = new picker.DocumentSelectOptions();
  documentSelectOptions.maxSelectNumber = 1;
  documentSelectOptions.fileSuffixFilters = ['.txt'];


  //拉起picker选择文件
  let uris: Array<string> = [];
  const documentViewPicker = new picker.DocumentViewPicker();
  return await documentViewPicker.select(documentSelectOptions).then((documentSelectResult: Array<string>) => {
    uris = documentSelectResult;
    let uri: string = uris[0];
    let path: string = new fileUri.FileUri(uri).path;
    console.info(`The Opened File path is [${uri}]`);
    let file = fs.openSync(path, fs.OpenMode.READ_ONLY);
    //调用native方法读文件
    let res = FileAccess.readFileUsingPickerFd(file.fd);
    fs.closeSync(file.fd);
    return res;
  }).catch((error: BusinessError) => {
    console.error(`Open The file failed, error code is [${error.code}], error message is [${error.message}]`);
    return 'Read Failed by Picker!';
  })
}
```


通过上述步骤，实现了在Native侧通过ArkTS侧picker传递的文件资源描述符访问公共目录文件并读取内容的方案。


效果展示

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152935.74526210089205401825498406893238:50001231000000:2800:355582B7E3A02D4854763D6E86C60014E7FDF368F6505D97F07E392BDBC113C5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152935.36684080273045198537693273296377:50001231000000:2800:A3B9E854279C739EDD3053AF2FDA76E2EE81C0D834765280766AE594C96A09A3.png)

示例代码

- Native侧实现文件访问

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-complex-type-pass
爬取时间: 2025-05-08 03:34:11
来源: Huawei Developer


概述


开发者为了提高程序运行效率，通常需要将一些运算量较大的内容放在C++环境中运行，因此经常需要进行ArkTS与C++之间的数据传递。本文以常见的五种数据类型：Array(uint8Array)、Object、HashMap、PixelMap、Class为例，向开发者介绍如何进行复杂参数的跨语言传递。


在开始介绍不同场景的开发流程之前，请注意，跨语言数据传递，需要使用Node-API。因此，在新建项目后，请手动新建Native模块，方法如图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152935.24695697330559971109525436493087:50001231000000:2800:BE4D3CE2E9AEC9F057AA4A1FB40EFE69D8E34193F874E3101B570C904B0C6879.png)

场景案例


arrayBuffer类型数据交互


本章以简单的数组传递场景为例，在ArkTS侧输入一个Uint8Array数组，传递到C++侧，再构造另一个数组，并返回ArkTS侧。


以此为例，介绍ArrayBuffer类型的数据如何相互传递使用。除数组外，string等连续数据类型也可参考本段。


实现原理


ArrayBuffer是一种用于表示通用的、固定长度的原始二进制数据缓冲区的对象。在C++侧接受该类型参数时一般会通过Node-API提供的函数（如napi_get_arraybuffer_info）获取到ArrayBuffer的数据指针和长度，从而可以访问和操作这些数据。


从C++侧传递ArrayBuffer数据到ArkTS侧时，通常会在C++层创建出一个数据缓冲区（如std::vector<uint8_t>）并填充所需的数据。然后使用Node-API提供的函数（如napi_create_arraybuffer和napi_create_typedarray）在ArkTS侧创建一个新的ArrayBuffer对象，并将其与C++层的数据缓冲区关联起来。最后传递该对象到ArkTS侧。


开发步骤

1.  使用时将Uint8Array类型的数据作为参数传入uint8ArrayPassing函数即可。

```less
export const uint8ArrayPassing: (input: Uint8Array) => Uint8Array;
```

2.  在这段代码中，先用三个函数获取关键信息： napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_get_typedarray_info：用于在Node-API模块中获得某个TypedArray的各种属性。 napi_get_arraybuffer_info：获取ArrayBuffer的底层数据缓冲区和长度。 之后，通过循环配合指针和偏移量，读取其中的数据，并将其存入inputArray中。 在这段代码中，先用两个函数构建buffer和array： 之后，通过循环，将数据压入output_buffer，再返回output_array，即完成了uint8Array类型数据向ArkTS的传递。

```less
// entry\src\main\cpp\napi_init.cpp
static napi_value uint8ArrayPassing(napi_env env, napi_callback_info info) {
    vector<uint8_t> num_array = {};
    uint8ArrayPassingTs2Napi(env, info, num_array);
    return uint8ArrayPassingNapi2Ts(env, num_array);
}
```


```less
static napi_value Init(napi_env env, napi_value exports) {
    napi_property_descriptor desc[] = {
        {"uint8ArrayPassing", nullptr, uint8ArrayPassing, nullptr, nullptr, nullptr, napi_default, nullptr},
        // ...
    };
    // ...
}
```

- napi_create_arraybuffer：负责构建buffer。
- napi_create_typedarray：负责构建array。

实现效果

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152936.06424388175673004531804325105135:50001231000000:2800:5D3C91C251C5C8483EB27E9F4463959B434A2258EA29F89456448E3F19B1ABBC.png)

object类型数据交互


本章通过模拟一个“排号机”应用，向开发者介绍如何进行object数据类型的相互传递，以及如何解析、修改其中的数据。


实现原理


Object类是所有其他类型的基类。在C++侧接收该类型参数时一般会通过Node-API提供的函数（如napi_get_named_property）来获取object对象的某个属性，从而操作其属性值。


从C++侧传递object类型到ArkTS侧时，可以利用Node-API封装好的接口（napi_create_object_with_named_properties）直接通过传递参数数组的方式构建出一个带有给定属性值的object类型对象。


开发步骤

1.  特别的，此处还需定义需要使用的object数据类型。

```less
// entry/src/main/ets/model/SampleObject.ts
export type SampleInputObject = {
  age: number;
  name: string;
}


export type SampleOutputObject = {
  isAdult: boolean;
  code: number;
  age: number;
  name: string;
}
```

2.  napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_get_named_property：负责获取并储存inputObj中的属性。 napi_get_value_int32：负责将获取到的inputAge属性解析为int32数据，并存入age中。 napi_get_boolean：负责将需要返回的boolean属性写入对应的napi_value量中。 napi_create_int32：负责将需要返回的int32属性写入对应的napi_value量中。 napi_create_object_with_named_properties：负责构造需要返回的object。

```less
// entry\src\main\cpp\napi_init.cpp
static napi_value objectPassing(napi_env env, napi_callback_info info) {
    return objectPassingNapi2Ts(env, objectPassingTs2Napi(env, info));
}
```


实现效果

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152936.57737551098545892666565652313727:50001231000000:2800:7ACEC0FBF7E0342F52D4D202702C872F1889F0284680699F90463B7E523E29F1.png)

hashMap类型数据交互


本章通过模拟一个“积分累计”应用，每次输入对象的本次积分，并返回所有对象的累积积分。向开发者介绍如何进行hashMap数据类型的相互传递，以及如何解析、修改其中的数据。


实现原理


hashMap是一种基于哈希表的Map接口实现的数据结构。在C++侧接受改类型参数时，由于C++没有可以直接接收该类型参数的数据类型，所以一般采用两种方式进行传递。


1.传递数组：分别将HashMap的key、value作为数组取出，然后将两个数组传递至C++侧并组装成Map进行数据处理。


2.传递JSON：将HashMap转为Json字符串传递至C++侧，在C++侧通过反序列化的方式构造成Map类型数据进行处理。


同样的，从C++侧传递Map类型到ArkTS侧时，需要将Map序列化成Json字符串传递到ArkTS，然后在ArkTS侧进行反序列化获取对应参数。


开发步骤

1.  此外，由于程序不支持直接传递hashMap类型，因此需要使用其他数据类型作为媒介。 有两种主流方案： 本文以前者为例，后者可参考：如何实现ArkTS与C/C++的HashMap转换 之后，将Record类型数据通过JSON.stringify序列化后即可传入C++侧。

```less
// entry/src/main/ets/pages/HashMapPage.ets
hashMap2Rec(map: HashMap<string, Object>): Record<string, Object> {
  let Rec: Record<string, Object> = {}
  map.forEach((value: Object, key: string) => {
    // value may also be HashMap
    if (value instanceof HashMap) {
      let vRec: Record<string, Object> = this.hashMap2Rec(value);
      value = vRec;
    }
    Rec[key] = value;
  })
  return Rec;
}
```

2.  其中hashMapPassingNapi2Ts与hashMapPassingTs2Napi分别负责数据从ArkTS至C++传递与反向传递。同时，在C++侧，也需完成序列化和反序列化，本文采用nlohmann三方库完成此操作。 napi_get_cb_info：负责从ArkTS侧获取输入参数。 value2String：将napi_value数据解析为string的过程包装为一个函数，方便多次调用。 nlohmann::json::parse：负责将string反序列化为map<string, int>类型数据。 此处stringSize需要+1，这是因为napi_value是一个C的结构体指针，C语言的字符串实际上是使用空字符 \0 结尾的一维字符数组。而napi_get_value_string_utf8返回的stringSize，其长度不含结尾的\0。为了保证写入valueString的内容包含结尾的\0，所以需要+1。 nlohmann::ordered_json：负责将map序列化。 dump：负责将序列化后的数据转换为string类型。 string2value：将string转换为napi_value的过程包装为一个函数，方便多次调用。 napi_create_string_utf8：负责将string类型数据转换为napi_value类型。

```less
// entry\src\main\cpp\napi_init.cpp
static napi_value hashMapPassing(napi_env env, napi_callback_info info) {
    return hashMapPassingNapi2Ts(env, hashMapPassingTs2Napi(env, info));
}
```

3.  JSON.parse：此函数只能将string反序列化为object，因此还需额外一步将其转换为hashMap类型。

```typescript
// entry/src/main/ets/pages/HashMapPage.ets
let receiveObj: object = JSON.parse(receiveStr);
let receiveMap: HashMap<string, number> = new HashMap();
Object.entries(receiveObj).forEach((value: [string, number]) => {
  receiveMap.set(value[0], value[1]);
})
```


实现效果

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152936.62314420784254159592826537364171:50001231000000:2800:3DAF9BD3609824E1E04FF7B087513A44649D0B2BB8A12804A7CC05773D16D565.png)

pixelMap类型数据交互


本章以图片处理应用为例，介绍如何进行pixelMap类型数据交互。


除本文介绍的方法外，也可通过readPixelsToBuffer将其转换为Uint8Array类型，进行处理。此方案可以参考arrayBuffer类型数据交互，本文不作介绍。


在进行应用开发之前，开发者需要打开native工程的src/main/cpp/CMakeLists.txt，在target_link_libraries依赖中添加image的libpixelmap_ndk.z.so


```less
// entry/src/main/cpp/CMakeLists.txt
target_link_libraries(entry PUBLIC libace_napi.z.so libhilog_ndk.z.so libpixelmap_ndk.z.so)
```


实现原理


PixelMap 是一种用于显示图像的数据结构。在C++侧接收该类型参数的时候，可以直接调用libpixelmap.so库中的函数直接通过ArkTS侧的pixelmap对象构造出Native侧的pixelmap类型对象（NativePixelMap），进而对其进行数据处理。


由于pixelMap类似一个C++语言中的指针，通过上述操作之后更改了其指向的内容，因此在ArkTS侧通过设定延迟可以直接触发ArkTS侧的图像自渲染，从而实现ArkTS页面刷新，直接显示修改后的图像。


开发步骤

1.  createPixelMap：负责将从imageResource加载的图片解码为pixelMap格式。

```less
// entry/src/main/ets/pages/PixelMapPage.ets
async loadPixelMap(): Promise<void> {
  let resourceManager = getContext(this).resourceManager;
  let imageArray = await resourceManager.getMediaContent($r('app.media.SampleImage'));
  let imageResource = image.createImageSource(imageArray.buffer);
  let opts: image.DecodingOptions = { editable: true, desiredPixelFormat: image.PixelMapFormat.BGRA_8888 };
  imageResource.createPixelMap(opts).then((pixelMap) => {
    this.pixelMap = pixelMap;
    this.loadComplete = true;
  })
}


aboutToAppear(): void {
  this.loadPixelMap();
}
```

2.  napi_get_cb_info：负责从ArkTS侧获取输入参数。 OH_PixelMap_InitNativePixelMap：负责初始化NativePixelMap对象。 OH_PixelMap_SetOpacity：负责修改NativePixelMap中的不透明度。 其他诸如旋转、缩放等操作可以参考使用Image处理PixelMap数据。 输入的TSPixelMap与生成的NativePixelMap共享内存空间，因此直接调用相关方法修改NativePixelMap对象，即可同步影响TSPixelMap对象。所以此处无需回传数据。

```less
// entry\src\main\cpp\napi_init.cpp
static napi_value pixelMapPassing(napi_env env, napi_callback_info info) {
    size_t argc = 1;
    napi_value ts_pixel_map;
    // Gets detailed information about the function call, such as input parameters.
    napi_get_cb_info(env, info, &argc, &ts_pixel_map, nullptr, nullptr);


    // Initialize the NativePixelMap object.
    // NativePixelMap and ArkTSPixelMap share memory space.
    // That is, modifications to NativePixelMap also affect ArkTSPixelMap.
    NativePixelMap *native_pixel_map = OH_PixelMap_InitNativePixelMap(env, ts_pixel_map);


    float opacity = 0.5;
    OH_PixelMap_SetOpacity(native_pixel_map, opacity);


    return nullptr;
}
```

3.  这是因为pixelMap类似一个C语言指针，只更改其指向的内容，其本身值未变，不会引发自动重渲染。此处设定的延迟也是为了确保重渲染可以触发。

```less
// entry/src/main/ets/pages/PixelMapPage.ets
if (this.loadComplete) {
  Image(this.pixelMap)
    .height(400)
} else {
  Image($r('app.media.loading'))
    .height(400)
}
```


实现效果

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152936.66673898324973056382858122271025:50001231000000:2800:6950AE7DE116CBDCDCE89145A154A535EB1E3941A10309DDC0495DE7495EE6CC.png)

class类型数据，ArkTS传递至C++


本章以简单的计算器为例，介绍如何进行class类型数据交互。由于两侧传递方式差异较大，因此分为两章讲解。


本章讲解ArkTS传递至C++。


实现原理


ArkTS语言中，class（类）是用于定义对象的模板，并拥有特有的属性和方法。在C++侧接收该类型时与object类型基本一致，一般会通过Node-API提供的函数（如napi_get_named_property）来获取到的class对象的某个属性，从而操作其属性值。


开发步骤


```less
// entry/src/main/cpp/types/libentry/Index.d.ts
export interface SampleClassTs2Napi {
  result: string;


  add(a: number, b: number): string;
}
```

1.  classPassingTs2Napi：负责将class从ArkTS传递至Napi，之后返回一个string作为结果。 napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_get_named_property：第一次调用，负责将方法名为"add"的方法存入变量add中。 napi_create_int32：负责将入参解析为int32，并存入数组arr中。 napi_call_function：负责在C++工程中调用从ArkTS传入的class的方法，需要使用上两步获得的入参数组arr和方法add。 napi_get_named_property：第二次调用，负责将名为"result"的属性存入param_result中。 value2String、string2value：负责napi_value与string类型之间的相互转换，实现方法详见hashMap类型数据交互。

```less
// entry\src\main\cpp\napi_init.cpp
napi_value classPassingTs2Napi(napi_env env, napi_callback_info info) {
    size_t argc = 1;
    napi_value args;
    // Gets detailed information about the function call, such as input parameters.
    napi_get_cb_info(env, info, &argc, &args, nullptr, nullptr);


    // Retrieve the method named "add" from the parameter object and store it in the "add" variable.
    napi_value add;
    napi_get_named_property(env, args, "add", &add);


    // Create parameter array
    napi_value arr[2];
    napi_create_int32(env, 114, &arr[0]);
    napi_create_int32(env, 514, &arr[1]);
    // Call the "add" method of the parameter object, pass this array as a parameter,
    // and store the result in the funcResult variable.
    napi_value func_result;
    napi_call_function(env, args, add, 2, arr, &func_result);


    // Retrieve the property values named "result" from the parameter object
    // using the napi_get_named_property function, and store them in the param_result variables.
    napi_value param_result;
    napi_get_named_property(env, args, "result", &param_result);


    string resultStr = value2String(env, func_result) + value2String(env, param_result);
    return string2value(env, resultStr);
}
```


实现效果

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152936.05423490438594142616842403506037:50001231000000:2800:69C1DB8B91CBEEFD01B9598735EC12E27F50DBB42545377E2A4FE503B1E50E2E.png)

class类型数据，C++传递至ArkTS


本章仍以简单的计算器为例，介绍class类型数据如何从C++传递至ArkTS。


实现原理


从C++侧传递class类型到ArkTS侧时，需要在C++侧对C++类方法进行Napi适配，然后再init函数中通过napi_define_class建立ArkTS类方法与C++侧方法的映射关系，然后将对应的class对象挂载到export上导出。注意：需要在index.d.ts文件中声明需要传递的class。


开发步骤

1.  此处需要使用get和set关键字定义访问器，不能直接引用、修改属性。

```typescript
// entry/src/main/cpp/types/libentry/Index.d.ts
export class SampleClassNapi2Ts {
  private _hintStr: string;


  constructor(hintStr: string);


  times(a: number, b: number): string;
  public get hintStr();
  public set hintStr(value:string);
}
```

2.  在调用时，用法与其他寻常的ArkTS的class一样。无需特别注意。

```less
// entry/src/main/ets/pages/ClassPage.ets
let napiClass: ParamPassing.SampleClassNapi2Ts = new ParamPassing.SampleClassNapi2Ts(HINT_STRING);
napiClass.hintStr += 'modify by ArkTS: \n';
this.printStr = napiClass.hintStr + napiClass.times(6, 9);
```

3.  此处使用ostringstream输出流，以便完成字符串的构造。因此需要提前导入sstream。 同时，还需依次完成供ArkTS调用的访问器、构造函数和方法。 napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_unwrap：负责解析ArkTS class中包装的C++ class，并使用指针c_class_obj进行储存。 string2value：负责将obj->hintStr转换为napi_value，作为输出。此函数的实现方法详见hashMap类型数据交互。 ArkTS侧调用hintStr的值的时候，需要调用此函数，从而获得C++侧的hintStr的值。 初始化阶段的访问器，napi_unwrap后获得的c_class_obj可能为空指针，所以必须验空。下同。 napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_unwrap：负责将传入的ArkTS class解包，获取与其绑定的C++ class，并使用指针c_class_obj进行储存。 napi_get_value_int32：负责将入参解析为int32并存入value0/value1中。 napi_get_cb_info：负责从ArkTS侧获取输入参数。 value2String：负责将入参转换为string。此函数的实现方法详见hashMap类型数据交互。 napi_set_named_property：负责对指定的object加入一个新属性，并指定属性名。ArkTS侧调用的时候，将使用此处指定的名称。

```less
// entry\src\main\cpp\napi_init.cpp
class SampleClassNapi2Ts {
public:
    std::string hint_str;
    SampleClassNapi2Ts(string str) { this->hint_str = str; };
    std::string times(int a, int b) {
        std::ostringstream ost;
        ost << a << " × " << b << " = " << a * b;
        return ost.str();
    };
};
```


```less
// entry\src\main\cpp\napi_init.cpp
static napi_value getHintStr(napi_env env, napi_callback_info info) {
    napi_value ts_class_obj;
    // Gets detailed information about the function call, such as input parameters.
    napi_get_cb_info(env, info, nullptr, nullptr, &ts_class_obj, nullptr);


    SampleClassNapi2Ts *c_class_obj;
    // Retrieve and manipulate the C++object previously bound to jsThis using napi_unwrap
    napi_unwrap(env, ts_class_obj, reinterpret_cast<void **>(&c_class_obj));
    if (c_class_obj) {
        return string2value(env, c_class_obj->hint_str);
    } else {
        return nullptr;
    }
}
```


```less
// entry\src\main\cpp\napi_init.cpp
static napi_value setHintStr(napi_env env, napi_callback_info info) {
    // Obtain parameters transmitted from the TS layer
    size_t argc = 1;
    napi_value value;
    napi_value ts_class_obj;
    // Gets detailed information about the function call, such as input parameters.
    napi_get_cb_info(env, info, &argc, &value, &ts_class_obj, nullptr);


    SampleClassNapi2Ts *c_class_obj;
    // Retrieve and manipulate the C++object previously bound to jsThis using napi_unwrap
    napi_unwrap(env, ts_class_obj, reinterpret_cast<void **>(&c_class_obj));


    if (c_class_obj) {
        c_class_obj->hint_str = value2String(env, value);
    }


    return nullptr;
}
```

4.  napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_unwrap：负责将传入的ArkTS class解包，获取与其绑定的C++ class，并使用指针c_class_obj进行储存。 napi_get_value_int32：负责将入参解析为int32并存入value0/value1中。

```less
// entry\src\main\cpp\napi_init.cpp
static napi_value TSTimes(napi_env env, napi_callback_info info) {
    size_t argc = 2;
    napi_value args[2] = {nullptr};
    napi_value ts_class_obj = nullptr;
    // Gets detailed information about the function call, such as input parameters.
    napi_get_cb_info(env, info, &argc, args, &ts_class_obj, nullptr);
    SampleClassNapi2Ts *c_class_obj = nullptr;
    // Convert ArkTS object to C++ object
    napi_unwrap(env, ts_class_obj, (void **)&c_class_obj);
    // Get parameters passed by ArkTS
    int value0;
    napi_get_value_int32(env, args[0], &value0);
    int value1;
    napi_get_value_int32(env, args[1], &value1);
    string c_result = c_class_obj->times(value0, value1);
    return string2value(env, c_result);
}
```

5.  napi_get_cb_info：负责从ArkTS侧获取输入参数。 value2String：负责将入参转换为string。此函数的实现方法详见hashMap类型数据交互。 napi_set_named_property：负责对指定的object加入一个新属性，并指定属性名。ArkTS侧调用的时候，将使用此处指定的名称。

```less
// entry\src\main\cpp\napi_init.cpp
static napi_value TsConstructor(napi_env env, napi_callback_info info) {
    // Create Napi object
    napi_value ts_class_obj;
    size_t argc = 1;
    napi_value args[1] = {nullptr};
    // Gets detailed information about the function call, such as input parameters.
    napi_get_cb_info(env, info, &argc, args, &ts_class_obj, nullptr);
    string hint_str = value2String(env, args[0]);
    // Create C++ object
    SampleClassNapi2Ts *c_class_obj = new SampleClassNapi2Ts(hint_str);
    // Set the JS object hintStr attribute
    napi_set_named_property(env, ts_class_obj, "hintStr", args[0]);
    // Binding JS objects with C++objects
    napi_wrap(
        env, ts_class_obj, c_class_obj,
        // Define callback function for recycling JS objects, used to destroy C++objects and prevent memory leaks
        [](napi_env env, void *finalize_data, void *finalize_hint) {
            SampleClassNapi2Ts *c_class_obj = (SampleClassNapi2Ts *)finalize_data;
            delete c_class_obj;
            c_class_obj = nullptr;
        },
        nullptr, nullptr);
    return ts_class_obj;
}
```

6.  需要先在DevEco Studio预生成的Init函数中，定义一个classProp，并写入class对应的访问器与方法 并调用napi_define_class和napi_set_named_property完成ArkTS class 与C++ class的关联与设置。从而令ArkTS可以调用C++中的class。

```less
// entry\src\main\cpp\napi_init.cpp
EXTERN_C_START
static napi_value Init(napi_env env, napi_value exports) {
    // ...


    napi_property_descriptor class_prop[] = {
        {"hintStr", 0, 0, getHintStr, setHintStr, 0, napi_default, 0},
        {"times", nullptr, TSTimes, nullptr, nullptr, nullptr, napi_default, nullptr}};
    napi_value sample_class = nullptr;
    const char *class_name = "SampleClassNapi2Ts";
    // Establish the association between ArkTS constructor and C++ methods
    napi_define_class(env, class_name, sizeof(class_name), TsConstructor, nullptr,
                      sizeof(class_prop) / sizeof(class_prop[0]), class_prop, &sample_class);
    napi_set_named_property(env, exports, class_name, sample_class);


    return exports;
}
EXTERN_C_END
```


```less
// entry\src\main\cpp\napi_init.cpp
static napi_value getHintStr(napi_env env, napi_callback_info info) {
    napi_value ts_class_obj;
    // Gets detailed information about the function call, such as input parameters.
    napi_get_cb_info(env, info, nullptr, nullptr, &ts_class_obj, nullptr);


    SampleClassNapi2Ts *c_class_obj;
    // Retrieve and manipulate the C++object previously bound to jsThis using napi_unwrap
    napi_unwrap(env, ts_class_obj, reinterpret_cast<void **>(&c_class_obj));
    if (c_class_obj) {
        return string2value(env, c_class_obj->hint_str);
    } else {
        return nullptr;
    }
}
```


```less
// entry\src\main\cpp\napi_init.cpp
static napi_value setHintStr(napi_env env, napi_callback_info info) {
    // Obtain parameters transmitted from the TS layer
    size_t argc = 1;
    napi_value value;
    napi_value ts_class_obj;
    // Gets detailed information about the function call, such as input parameters.
    napi_get_cb_info(env, info, &argc, &value, &ts_class_obj, nullptr);


    SampleClassNapi2Ts *c_class_obj;
    // Retrieve and manipulate the C++object previously bound to jsThis using napi_unwrap
    napi_unwrap(env, ts_class_obj, reinterpret_cast<void **>(&c_class_obj));


    if (c_class_obj) {
        c_class_obj->hint_str = value2String(env, value);
    }


    return nullptr;
}
```

1.  napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_unwrap：负责将传入的ArkTS class解包，获取与其绑定的C++ class，并使用指针c_class_obj进行储存。 napi_get_value_int32：负责将入参解析为int32并存入value0/value1中。

```less
// entry\src\main\cpp\napi_init.cpp
static napi_value TSTimes(napi_env env, napi_callback_info info) {
    size_t argc = 2;
    napi_value args[2] = {nullptr};
    napi_value ts_class_obj = nullptr;
    // Gets detailed information about the function call, such as input parameters.
    napi_get_cb_info(env, info, &argc, args, &ts_class_obj, nullptr);
    SampleClassNapi2Ts *c_class_obj = nullptr;
    // Convert ArkTS object to C++ object
    napi_unwrap(env, ts_class_obj, (void **)&c_class_obj);
    // Get parameters passed by ArkTS
    int value0;
    napi_get_value_int32(env, args[0], &value0);
    int value1;
    napi_get_value_int32(env, args[1], &value1);
    string c_result = c_class_obj->times(value0, value1);
    return string2value(env, c_result);
}
```

1.  napi_get_cb_info：负责从ArkTS侧获取输入参数。 value2String：负责将入参转换为string。此函数的实现方法详见hashMap类型数据交互。 napi_set_named_property：负责对指定的object加入一个新属性，并指定属性名。ArkTS侧调用的时候，将使用此处指定的名称。

```less
// entry\src\main\cpp\napi_init.cpp
static napi_value TsConstructor(napi_env env, napi_callback_info info) {
    // Create Napi object
    napi_value ts_class_obj;
    size_t argc = 1;
    napi_value args[1] = {nullptr};
    // Gets detailed information about the function call, such as input parameters.
    napi_get_cb_info(env, info, &argc, args, &ts_class_obj, nullptr);
    string hint_str = value2String(env, args[0]);
    // Create C++ object
    SampleClassNapi2Ts *c_class_obj = new SampleClassNapi2Ts(hint_str);
    // Set the JS object hintStr attribute
    napi_set_named_property(env, ts_class_obj, "hintStr", args[0]);
    // Binding JS objects with C++objects
    napi_wrap(
        env, ts_class_obj, c_class_obj,
        // Define callback function for recycling JS objects, used to destroy C++objects and prevent memory leaks
        [](napi_env env, void *finalize_data, void *finalize_hint) {
            SampleClassNapi2Ts *c_class_obj = (SampleClassNapi2Ts *)finalize_data;
            delete c_class_obj;
            c_class_obj = nullptr;
        },
        nullptr, nullptr);
    return ts_class_obj;
}
```


实现效果

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152936.46398564850614322020091194540016:50001231000000:2800:28B29F6E508D93D70CA64BDD8B5DB0B6989140BE7A5BF82A0EBBF87E1352CD3F.png)

示例代码

- 跨语言复杂参数交互

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-cross-module-reference
爬取时间: 2025-05-08 03:34:17
来源: Huawei Developer


概述


在大型应用开发中，应用通常会分为多个业务模块，业务模块常会以HSP或HAR包的形式提供SDK能力，这些SDK往往会提供Native接口给HAP模块的Native层直接调用，从而实现应用的复杂功能。而如何在Native侧跨HAR/HSP模块进行接口调用，是开发者经常遇到的问题。本文将介绍Native侧跨HAR/HSP模块调用两种典型场景，包括调用Native方法和调用ArkTS方法，以方便开发者更好的掌握Native侧跨模块调用的能力。

- Native侧跨HAR/HSP模块调用Native方法
- Native侧跨HAR/HSP模块调用ArkTS方法

实现原理


如图1所示，Native侧跨HAR/HSP模块调用原理主要包括以下步骤。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152936.07989172719746480461300630209521:50001231000000:2800:C5421D0851E1463CFE9D650CE580FB309AE039046C509CFD637C1CD99DBBD40D.png)

Native侧跨HAR/HSP模块调用Native方法


如下图所示，Native侧跨HAR/HSP模块调用Native方法的调用链路为Module1 ArkTS -> Module1 Native -> Module2 Native。在HarmonyOS项目中，Native侧跨模块调用Native方法实际就是C++侧调用，需要配置编译链接依赖。其实现的关键是在Module2（HSP/HAR）模块的build-profile.json5中配置头文件导出，并在CMakeLists.txt中进行配置，将源文件配置到so中。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152936.16118944468627855279566142915028:50001231000000:2800:F14261E41EA3192F1E18DAE677B4A6C0A47C3E22FDB072E2A5AA91D4A9ED5BD0.png)

开发流程


在Native侧跨HAR/HSP模块调用Native方法中，需要实现Module1（HAP）的ArkTS 侧调用Module1（HSP/HAR）的Native 侧、Module1（HAP）的Native 侧调用Module2（HSP/HAR）的Native 侧。在当前场景下，跨模块调用HAR模块和HSP模块的方式相同，当前以跨模块调用HAR模块为例，详细流程如下所示。

1.  napi_har.cpp代码如下所示。 napi_har.h代码如下所示。

```less
// staticModule\src\main\cpp\napi_har.cpp
#include "napi/native_api.h"
#include "napi_har.h"


double harNativeAdd(double a, double b) {
    return a + b;
}
```


```less
{
  "apiType": "stageMode",
  "buildOption": {
    "externalNativeOptions": {
      "path": "./src/main/cpp/CMakeLists.txt",
      "arguments": "",
      "cppFlags": "",
      "abiFilters": ["x86_64", "arm64-v8a"]
    },
    "nativeLib": {
      "headerPath": "./src/main/cpp"
    },
    // ...
}
```


```less
# staticModule\src\main\cpp\CMakeLists.txt
add_library(add SHARED napi_init.cpp napi_har.cpp)
```


```less
// entry\oh-package.json5
{
  "name": "entry",
  "version": "1.0.0",
  "description": "Please describe the basic information.",
  "main": "",
  "author": "",
  "license": "",
  "dependencies": {
    "libentry.so": "file:./src/main/cpp/types/libentry",
    // 配置har的依赖
    "static_module": "file:../staticModule",
    // ...
  }
}
```

1.  static_module::add中第一个参数static_module是module2的模块名称，第二个参数add是module2编译出来的so名称（不需要带上lib）。默认情况下，module2的模块名称与so名称相同，为了方便说明，在本案例中将so名称修改成了add。

```less
# entry\src\main\cpp\CMakeLists.txt
target_link_libraries(entry PUBLIC libace_napi.z.so static_module::add shared_module::calc)
```


```less
// entry\src\main\cpp\napi_init.cpp
static napi_value invokeHarNative(napi_env env, napi_callback_info info)
{
    size_t argc = 2;
    napi_value args[2] = {nullptr};


    napi_get_cb_info(env, info, &argc, args , nullptr, nullptr);


    napi_valuetype valuetype0;
    napi_typeof(env, args[0], &valuetype0);


    napi_valuetype valuetype1;
    napi_typeof(env, args[1], &valuetype1);


    double value0;
    napi_get_value_double(env, args[0], &value0);


    double value1;
    napi_get_value_double(env, args[1], &value1);


    napi_value sum;


    napi_create_double(env, harNativeAdd(value0, value1), &sum);


    return sum;
}
```


```less
Button($r('app.string.call_har_native_method'))
  .fontSize(16)
  .width('100%')
  .margin({ top: 12 })
  .onClick(() => {
    promptAction.showToast({
      message: 'HarNative method call succeed, result is ' + napi.invokeHarNative(2, 3).toString()
    });
  })
```


实现效果

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152936.48691438225057009645088775489212:50001231000000:2800:C85CB23AE2CBEE930A8AB9B21A2B24E4ADE1698C64671B1ED8400DF3AAD88B3D.gif)

Native侧跨HAR/HSP模块调用ArkTS方法


如下图所示，Native侧跨HAR/HSP模块调用ArkTS方法是Native侧跨HAR/HSP模块调用Native方法的基础上调用ArkTS方法。其关键是在Module2中获取Module1中的上下文napi_env，并根据上下文napi_env加载模块、调用对应的ArkTS方法。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152937.14898109618835698699382365664251:50001231000000:2800:01125D54E49E18DF27C185CE787B0E6D31B913F0645784D939B19FFA01034162.png)

开发流程


Native侧跨HAR/HSP模块调用ArkTS方法具体实现方法如下所示。

1.  napi_har.h代码如下所示。 napi_har.cpp代码如下所示。

```less
// staticModule\src\main\cpp\napi_har.h
#ifndef CROSSMODULEREFERENCE_NAPI_HAR_H
#define CROSSMODULEREFERENCE_NAPI_HAR_H
#include <js_native_api_types.h>
napi_env g_main_env;
void setHarEnv(napi_env env);
double harNativeAdd(double a, double b);
napi_value harArkTSAdd(double a, double b);
#endif //CROSSMODULEREFERENCE_NAPI_HAR_H
```


```less
// entry\src\main\cpp\napi_init.cpp
EXTERN_C_START
static napi_value Init(napi_env env, napi_value exports)
{
    napi_property_descriptor desc[] = {
        { "add", nullptr, Add, nullptr, nullptr, nullptr, napi_default, nullptr },
        { "invokeHarNative", nullptr, invokeHarNative, nullptr, nullptr, nullptr, napi_default, nullptr },
        { "invokeHarArkTS", nullptr, invokeHarArkTS, nullptr, nullptr, nullptr, napi_default, nullptr },
        { "invokeHspNative", nullptr, invokeHspNative, nullptr, nullptr, nullptr, napi_default, nullptr },
        { "invokeHspArkTS", nullptr, invokeHspArkTS, nullptr, nullptr, nullptr, napi_default, nullptr }
    };
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
    // 设置har模块napi_env
    setHarEnv(env);
    // ...
    return exports;
}
EXTERN_C_END
```


```typescript
// staticModule\src\main\ets\utils\Util.ets
export function add(a: number, b: number): number {
  return a + b;
}
```


```less
{
  "apiType": "stageMode",
  "buildOption": {
    // ...
    "arkOptions" : {
      "runtimeOnly" : {
        "sources": [
          "./src/main/ets/utils/Util.ets"
        ]
      }
    }
  },
  // ...
}
```

1.  napi_har.cpp代码如下所示。

```less
// staticModule\src\main\cpp\napi_har.cpp
napi_value harArkTSAdd(double a, double b) {
    napi_env env = g_main_env;
    napi_value module;
    napi_status status = napi_load_module_with_info(env, "static_module/src/main/ets/utils/Util", "com.example.crossmodulereference/entry", &module);
    if (napi_ok != status) {
        return 0;
    }
    
    napi_value addFunc;
    napi_get_named_property(env, module, "add", &addFunc);
    
    napi_value addResult;
    napi_value argv[2] = {nullptr, nullptr};
    napi_create_double(env, a, &argv[0]);
    napi_create_double(env, b, &argv[1]);
    napi_call_function(env, module, addFunc, 2, argv, &addResult);
    
    return addResult;
}
```


```less
// entry\src\main\cpp\napi_init.cpp
static napi_value invokeHarArkTS(napi_env env, napi_callback_info info)
{
    size_t argc = 2;
    napi_value args[2] = {nullptr};


    napi_get_cb_info(env, info, &argc, args , nullptr, nullptr);


    napi_valuetype valuetype0;
    napi_typeof(env, args[0], &valuetype0);


    napi_valuetype valuetype1;
    napi_typeof(env, args[1], &valuetype1);


    double value0;
    napi_get_value_double(env, args[0], &value0);


    double value1;
    napi_get_value_double(env, args[1], &value1);
    
    return harArkTSAdd(value0, value1);
}
```


```less
Button($r('app.string.call_har_ArkTS_method'))
  .fontSize(16)
  .width('100%')
  .margin({ top: 12 })
  .onClick(() => {
    promptAction.showToast({ message: 'HarArkTS method call succeed, result is '
      + napi.invokeHarArkTS(2, 3).toString() });
  })
```


实现效果

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152937.79803020710254860847983952152730:50001231000000:2800:CCCC58A7FF1119721ABD35AB1765A67F19A6CD096D2916577F1C55A098D76277.gif)

常见问题


跨HSP模块调用和跨HAR模块调用的区别


HSP模块和HAR模块被调用时，主要的区别在Module2 Native调用Module2 ArkTS中，在调用napi_load_module_with_info加载模块时的入参有一些区别，其他的流程都是一样的。


如图所示，编译构建后，HAR模块被打包到各个模块之中，所以其入口模块仍然是HAP模块，napi_load_module_with_info中第2个参数的模块名称要填HAP模块中oh-package.json5中定义的依赖HAR的名称，而不是HAR模块的实际名称。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152937.15345642164878585691573277855227:50001231000000:2800:1632D9067B64AA91BD5026C0C0617CC6C5B79400A5C823C5207E5AD582628138.png)

当被调用模块Module2是HSP，HSP是独立的模块，其入口模块就是HSP本模块，所以napi_load_module_with_info第2个参数的模块名就是他自己的模块名。


是否支持直接依赖HAR模块和HSP模块的三方so（即依赖传递问题）？


当前HAR模块和HSP模块都不支持依赖传递。


多包依赖同一so时，最终打包后的so有多少份？


如果多个HAR模块同时依赖commonHar的so，同一模块的同名so在打包后可以通过覆盖策略只保留一份。


如果多个HSP模块同时依赖commonHar的so，在编译构建的时，会将依赖的so编译打包到最终的编译产物里，所以每一个.hsp文件都会有一个so。


报错找不到HAR/HSP模块的ArkTS文件


问题现象


调用HAR/HSP模块的ArkTS文件时，可能会遇到以下报错：


```less
Error message:Cannot find module 'staticModule/src/main/ets/utils/Util' imported from 'com.xxxx.crossmodulereference/entry'.
```


可能原因


可能原因是工程级的build-profile.json5中的useNormalizedOHMUrl设置参数为false。


解决措施


在调用模块Module1的build-profile.json5里面添加如下配置。


```less
// entry\build-profile.json5
// ...
"buildOption": {
  // ...
  "arkOptions" : {
    "runtimeOnly" : {
      "packages": [
        "static_module"
      ]
    }
  }
},
// ...
```


示例代码

- Native侧跨HAR/HSP模块调用

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-dynamic-link-library
爬取时间: 2025-05-08 03:34:25
来源: Huawei Developer


概述


在实际项目中，业务功能可能由不同“团队/组织”提供，如：团队A开发功能编译生成so库，团队B引用so库进行后续开发。so库可以将项目的不同功能模块化，提升代码的复用性和工程的可维护性。团队开发过程中引用三方so库的场景可分为两种：


下面针对这两种场景给出具体的实现方案。


Native侧引用三方so库


按照实际开发场景可分为两部分：编译生成so库和在Native侧引用so库。


第一部分：开发功能函数，编译生成so库。具体操作可参考：使用命令行CMake构建NDK工程。


第二部分：在Native侧引用so库调用功能函数。可以采用如下两种方案：

- 方案一：通过编译动态链接库的方式引用。
- 方案二：通过调用dlopen的方式引用。

通过编译动态链接库的方式引用


实现原理


将so库加入到工程中，在Native侧使用CMake编译动态链接库，通过include引用头文件调用功能函数。


开发步骤


以引用一个加法计算so库为例，具体实现步骤如下：

1. 

```less
# Compile and link third-party SO libraries
target_link_libraries(entry PUBLIC ${NATIVERENDER_ROOT_PATH}/../../../libs/${OHOS_ARCH}/libnativeAdd.so)
```


```less
// src/main/cpp/napi_init.cpp
#include "add/add.h"


static napi_value NAPI_Global_nativeAdd(napi_env env, napi_callback_info info) {
    size_t argc = 2;
    napi_value args[2] = {nullptr};


    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);


    napi_valuetype valuetype0;
    napi_typeof(env, args[0], &valuetype0);


    napi_valuetype valuetype1;
    napi_typeof(env, args[1], &valuetype1);


    double value0;
    napi_get_value_double(env, args[0], &value0);


    double value1;
    napi_get_value_double(env, args[1], &value1);


    napi_value ret;
    napi_create_double(env, add(value0, value1), &ret);


    return ret;
}


EXTERN_C_START
static napi_value Init(napi_env env, napi_value exports) {
    napi_property_descriptor desc[] = {
        // ...
        {"nativeAdd", nullptr, NAPI_Global_nativeAdd, nullptr, nullptr, nullptr, napi_default, nullptr},
        // ...
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
    return exports;
}
EXTERN_C_END
```

2.  在ArkTS侧调用Native侧提供的接口进行加法计算。

```typescript
// src/main/cpp/types/libentry/index.d.ts
// 导出Native侧提供的加法计算接口
export const nativeAdd: (a: number, b: number) => number;
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152937.17952829782349498774401924089144:50001231000000:2800:C1668B4D4561CD031C3EFA6366C44B346CADC4D78BDA643B6F21321869467C18.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152937.39424514355924034507514703572897:50001231000000:2800:0A5DDC39360BF7AD43CED2BB4A78B7C46C77132FAB364D6D940F369192AE5968.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152937.71868708159634792379822818319077:50001231000000:2800:CA4EDB8B974BD2ACF9DA93B2BA8918EB77BB8D1B1C00892C8627D36A4C4A2F9D.png)

通过调用dlopen的方式引用


实现原理


将so库加入到工程中，在ArkTS侧将so库的沙箱路径传递至Native侧，在Native侧使用dlopen解析so库调用功能函数。但是需要注意，该方案只能引用C语言编译模式生成的so库，因此用于生成so库的.h头文件需要用extern "C" {}包裹。


开发步骤


以引用一个减法计算so库为例，具体实现步骤如下：

1. 
2.  此处需要使用so库的沙箱路径，而不是其真实路径。

```less
// src/main/ets/pages/index.ets
import testNapi from 'libentry.so';


let projectPath = getContext(this).bundleCodeDir; // 获取项目路径
let abiPath = deviceInfo.abiList === 'x86_64' ? 'x86_64' : 'arm64';
let soLibPath = `${projectPath}/libs/${abiPath}/libnativeSub.so`; // 获取so库沙箱路径
```


```less
// src/main/cpp/napi_init.cpp
#include "dlfcn.h"


typedef double (*Sub)(double, double);
static napi_value NAPI_Global_nativeSub(napi_env env, napi_callback_info info) {
    size_t argc = 3;
    napi_value args[3] = {nullptr};
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    double value0;
    napi_get_value_double(env, args[0], &value0);
    double value1;
    napi_get_value_double(env, args[1], &value1);
    char *path = new char[1024];
    size_t size = 1024;
    napi_get_value_string_utf8(env, args[2], path, 255, &size); // 获取三方so库路径信息
    void *handle = dlopen(path, RTLD_LAZY);                     // 打开路径为path的三方so库
    napi_value result;
    Sub sub_func = (Sub)dlsym(handle, "sub"); // 获取命名为sub的函数
    napi_create_double(env, sub_func(value0, value1), &result);
    dlclose(handle); // 关闭so库
    return result;
}


EXTERN_C_START
static napi_value Init(napi_env env, napi_value exports) {
    napi_property_descriptor desc[] = {
        // ...
        {"nativeSub", nullptr, NAPI_Global_nativeSub, nullptr, nullptr, nullptr, napi_default, nullptr}};
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
    return exports;
}
EXTERN_C_END
```

3.  在ArkTS侧调用Native侧提供的接口进行减法计算。

```typescript
// src/main/cpp/types/libentry/index.d.ts
// 导出Native侧提供的减法计算接口
export const nativeSub: (a: number, b: number, path: string) => number;
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152937.85797857520234662782988084290144:50001231000000:2800:D9CC9804EC0F96DA64B5289F5B80C107C97EAEE0C4A2F6AE5E370E00159A432B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152937.93722173893411137957145237275596:50001231000000:2800:9B8B56B99C9480D5AF0FF135FBCC38C821678C3E8448F9E4D5445553CE0BDDD3.png)

ArkTS侧引用三方so库


按照实际开发场景可分为两部分：生成适配Native的so库和在ArkTS侧引用so库。


第一部分：开发功能函数，编译生成so库并适配Native。具体操作可参考：使用命令行CMake构建NDK工程。


第二部分：在ArkTS侧通过配置模块动态依赖的方式引用so库。


通过配置模块动态依赖引用


实现原理


将so库和对应的Native侧接口文件加入到工程中，在工程中配置so库对应的模块动态依赖，在ArkTS侧通过import引入依赖接口调用so库。但是需要注意该方案只能引用适配Native的so库，因此在编译生成so库时需要实现功能函数并向Napi注册其Native侧接口，提供对应的Native侧接口文件index.d.ts和配置文件oh-package.json5。


开发步骤


以引用一个乘法计算so库为例，具体实现步骤如下：

1. 
2. 

```less
// entry/oh-package.json5
{
  // ...
  "dependencies": {
    // ...
    // 声明的依赖名称应与引用的so库名称一致
    "libmultiply.so": "file:./src/main/cpp/types/libmultiply"
  }
}
```


```less
// entry/src/main/ets/pages/Index.ets
import multiplyNapi from 'libmultiply.so';


// 直接使用已经适配Native的so库进行乘法运算
let result = multiplyNapi.multiply(Number(this.paramX), Number(this.paramY));
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152937.59811573729681404071953328464297:50001231000000:2800:AFA784E0CF9DB494D3D2460B45E815A96CCDA9563ABED69CC618F3DBE2140488.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152937.01439001534448063179792069442555:50001231000000:2800:E1939699152BC0AC21D848C3A2A4A1878E43E4913BE53853A3BE03E80D119C7E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152937.25396862705611719405337685321306:50001231000000:2800:375C24CD16067642F5A0E50C705A39C92893C6EC826EC562A9661BF2BBD20D70.png)

常见问题


如何在同一个工程中实现三方so库的编译和引用？


可以在工程中创建两个Module，通过其中一个Module编译生成加法、减法和乘法运算so库，通过另外一个Module引用三方so库，进行结果验证。


参考链接

- 使用命令行CMake构建NDK工程
- 在NDK工程中使用预构建库

在集成三方so库时，.so库文件和.h头文件一定要置于上述方法的路径下吗？


不一定。原则上.so库文件和.h头文件可以置于需要引用so库的工程目录的任意位置，但是需要在工程的CMakeLists.txt文件中修改文件配置。如：将add.h头文件和libnativeAdd.so库文件放置在entry的根目录下，需要在CMakeLists.txt文件中通过include_directories命令添加entry的根目录作为头文件路径，并修改target_link_libraries命令中需要预加载的加法so库的路径，才能保证so库链接成功。


代码示例


```less
// src/main/cpp/CMakeLists.txt
include_directories(${NATIVERENDER_ROOT_PATH}/../../..)  // 添加entry根目录
target_link_libraries(entry PUBLIC ${NATIVERENDER_ROOT_PATH}/../../../libnativeAdd.so)  // 修改加法so库路径
```


在纯ArkTS工程中如何引用三方so库？


纯ArkTS工程可以通过配置模块动态依赖的方式引用so库。但是需要注意，在引用过程中除了将已经适配Native的xxx.so库文件置于entry/libs对应的架构目录下外，还需要将编译三方so库时配套产生的libc++_xxx.so库文件置于该目录下。


示例如下

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152937.31493561808023669521616800614655:50001231000000:2800:05AB55656C640BA67BA2854E8F2CD48A0C7BEE500EF75D4268B4E88183F23033.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152937.52395344418247620934493303459019:50001231000000:2800:16861DFDE24E9A012FDD3A9DC79D86ABEDB5DAAA4D7A7965D43019F8251E04B1.png)

示例代码

- 三方so库集成开发实践

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-thread-priority-setting
爬取时间: 2025-05-08 03:34:31
来源: Huawei Developer


概述


在现代软件开发中，多线程或多进程的并发处理已成为常态。在多线程环境中，不同线程执行的任务可能具有不同的重要性和紧急程度。在高负载情况下，系统资源（如CPU时间）变得尤为宝贵，此时若关键线程（例如UI渲染线程）因频繁被非关键线程抢占而无法获得足够的连续执行时间和资源保障，可能会导致画面卡顿、延迟等问题，从而严重影响用户体验。


解决思路


在负载较重的时候，为了让关键的任务能够拿到足够的资源，整机会依据任务的重要性，给任务分配相应的时间片，重要性越高的任务，可以分配到越多的时间片。那么开发者在可以识别自己应用中的关键线程的情况下，针对各个线程的任务紧急程度，给予关键线程相对较高的QoS等级以防止被其他线程打断，从而保证应用的流畅运行和更好的用户体验。


QoS


服务质量（QoS）一文介绍了QoS的基本概念、原理、各个QoS等级适用的场景及负载特征及相关接口的用法。


在操作系统层面，QoS等级是一种用于区分不同线程优先级和服务质量的技术。通常系统会自动识别主线程，并在前台焦点情况下为其配置高于开放给应用开发者调用的QoS等级，以确保其优先执行。


与ArkTS端taskpool.Priority的线程优先级类似，QoS提供的优先级等级也都会相对应的映射到内核的优先级上。不过QoS提供的等级更多，自适应调度策略更强，他们属于两套不同的逻辑。


FFRT（Function Flow运行时）的QoS提供了ffrt_qos_inherit（-1）到ffrt_qos_user_initiated（3）5个优先等级，它与当前的QoS接口有着同一套底层逻辑。差别在于当前开发所用的QoS接口是直接开放给应用线程的，而FFRT的QoS则是面向任务的优先级配置，关于线程编程模型和任务编程模型的对比详见FFRT 概述。


场景示例


下面是一个在高负载情况下，配置了不同QoS等级的两个关键线程完成相同计算任务所花时间的对比图，从界面的运行结果可以看到在高负载情况下，配置了高优先级的线程执行完计算所花的时间更少一些。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152938.04438319833875109265228294434724:50001231000000:2800:5B514FACE0ED87EE97E10CD5ECFB9773F6FC463DFF34811ADD0D05D1C8FABF54.gif)

具体实现步骤如下：


1、实现负载线程所要完成的任务。


```less
// the Load task
void AddLoads(int n) {
    if (!n) {
        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "QoS", "invalid input.");
        return;
    }


    // set QoS level
    int ret = OH_QoS_SetThreadQoS(QoS_Level::QOS_BACKGROUND);
    if (ret) {
        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "QoS", "set load thread QoS level failed.");
        return;
    }


    // bind cpu
    cpu_set_t mask;
    CPU_SET(*g_affinity, &mask);
    if (sched_setaffinity(0, sizeof(mask), &mask) != 0) {
        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "QoS", "bind load thread failed");
        return;
    }
    // Perform load calculation
    for (int i = 0; i < BOUND; i++) {
        for (int j = 0; j < BOUND; j++) {
            int x = (i + j) - n;
            printf("%d", x);
        }
    }
    // reset load flag
    g_addLoad = false;
}
```


2、实现高、低QoS等级计算线程（关键线程）所要完成的计算任务（斐波那契数列计算）。先通过OH_QoS_SetThreadQoS接口设置当前线程的QoS等级，再执行 DoFib() 斐波那契数列计算。


```less
// Perform Fibonacci sequence calculations
long long DoFib(double n) {
    if (n == ONE) {
        return ONE;
    }
    if (n == TWO) {
        return TWO;
    }
    return DoFib(n - ONE) + DoFib(n - TWO);
}


void SetQoS(QoS_Level level) {
    // set QoS level
    int ret = OH_QoS_SetThreadQoS(level);
    if (!ret) {
        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "QoS", "set qos level success.");
        //  query qos level
        QoS_Level queryLevel = QOS_DEFAULT;
        ret = OH_QoS_GetThreadQoS(&queryLevel);
        if (!ret) {
            OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "QoS", "the qos level of current thread : %{public}d",
                         queryLevel);
        } else {
            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "QoS", "get qos level failed.");
            return;
        }
    } else {
        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "QoS", "get level qos failed!");
        return;
    }


    // bind cpu
    cpu_set_t mask;
    CPU_SET(*g_affinity, &mask);
    if (sched_setaffinity(0, sizeof(mask), &mask) != 0) {
        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "QoS", "bind qos thread failed");
        return;
    }
    auto startTime = std::chrono::system_clock::now();
    // Execute computational tasks
    long long res = DoFib(DEPTH);
    auto endTime = std::chrono::system_clock::now();
    g_durationTime = std::chrono::duration<double, std::milli>(endTime - startTime).count();
    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "QoS", "calculate res is: %{public}llu", res);


    // Reset QoS level
    ret = OH_QoS_ResetThreadQoS();
    if (!ret) {
        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "QoS", "reset qos level success.");
    } else {
        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "QoS", "reset qos level failed!");
        return;
    }


    // after reset QoS, query QoS again will fail
    QoS_Level queryLevelTwo;
    ret = OH_QoS_GetThreadQoS(&queryLevelTwo);
    if (!ret) {
        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "QoS", "the qos level after: %{public}d", queryLevelTwo);
        return;
    } else {
        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "QoS", "query qos level failed after reset.");
        return;
    }
}
```


3、然后分别将计算线程（关键线程）设置低、高QoS等级来对比两者在相同的高负载情况下完成相同层级的斐波那契数列计算所花时间。

- 给计算线程配置低QoS等级

```less
static napi_value lowQoSCalculate(napi_env env, napi_callback_info info) {
    g_durationTime = 0;
    // Simulate system load
    if (!g_addLoad) {
        std::vector<std::thread> loadThreads;
        for (int i = 0; i < TASKS; i++) {
            // Activate threads to execute load tasks
            loadThreads.emplace_back(std::thread(AddLoads, TASKS));
            loadThreads[i].detach();
        }
        g_addLoad = true;
    }


    // set QOS_BACKGROUND level
    QoS_Level level = QoS_Level::QOS_BACKGROUND;
    std::thread task(SetQoS, level);
    task.join();


    // Return calculation time
    napi_value res;
    napi_create_double(env, g_durationTime, &res);
    return res;
}
```


计算线程（线程id：39260）设置低QoS等级trace图：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152938.51374160493157508667298436673372:50001231000000:2800:CE4CD9FD9B45C702DC52F10B3BF41CDE9BB39174C4FAFF709EBCCF088A4AB9B6.png)

如上图所示，计算线程执行完计算任务耗时726.8毫秒。

- 给计算线程配置高QoS等级

```less
static napi_value highQoSCalculate(napi_env env, napi_callback_info info) {
    g_durationTime = 0;
    // Simulate system load
    if (!g_addLoad) {
        std::vector<std::thread> loadThreads;
        for (int i = 0; i < TASKS; i++) {
            // Activate threads to execute load tasks
            loadThreads.emplace_back(std::thread(AddLoads, TASKS));
            loadThreads[i].detach();
        }
        g_addLoad = true;
    }
    // set QOS_USER_INTERACTIVE level
    QoS_Level level = QoS_Level::QOS_USER_INTERACTIVE;
    std::thread task(SetQoS, level);
    task.join();


    // Return calculation time
    napi_value res;
    napi_create_double(env, g_durationTime, &res);
    return res;
}
```


计算线程（线程id：39204）设置高QoS等级trace图：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152938.56223231919037520738985230858482:50001231000000:2800:7753BBD15936810D1910EEEE36708A828E90A034ABAEE46C43F77DABAC28533C.png)

如上图所示，计算线程执行完计算任务耗时323.9毫秒。


该示例只在高负载压力下有效。


在低负载情况下，由于系统资源相对充足，即使不进行特别的优先级设置，大多数线程也能够得到足够的cpu时间来完成任务，因而效果并不明显。


总结


| 方案  | 斐波那契数列项数  | 计算耗时  |
| --- | --- | --- |
| 低Qos等级 QOS_BACKGROUND  | 34  | 726.8毫秒  |
| 高Qos等级 QOS_USER_INTERACTIVE  | 34  | 323.9毫秒  |

方案


斐波那契数列项数


计算耗时


低Qos等级 QOS_BACKGROUND


34


726.8毫秒


高Qos等级 QOS_USER_INTERACTIVE


34


323.9毫秒


通过上述对比可以发现，高负载压力下，高QoS优先级的线程可以更快的执行完计算任务。因此在实践中我们通过合理设置线程优先级，给关键线程以相对较高的QoS等级可以有效地避免关键线程被打断，从而保证应用程序的稳定性和响应性。


由于整机资源有限，若应用内部方法均设置高QoS等级，将导致资源相互抢占。此外，高QoS等级线程会相比低等级线程获取更多资源，过度提升线程QoS等级可能引起其他线程饥饿，从而影响整个系统的稳定运行。因此，线程QoS等级的设置需要结合具体应用场景和需求。


示例代码

- 基于QoS设置线程优先级

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-native-sub-main-comm
爬取时间: 2025-05-08 03:34:38
来源: Huawei Developer


概述


开发者在Native侧进行开发实践时，经常会遇到一些耗时的任务，例如I/O操作、域名解析以及复杂计算等。这些任务如果直接在主线程中执行，将会严重阻塞主线程，影响后续任务的正常流程，进而导致用户界面响应延迟甚至卡顿。


为了提升代码性能，通常会将这类耗时任务放在Native子线程中执行。通常情况下，Native子线程可以独立完成自己的任务，但是很多时候需要将数据从主线程传递到Native子线程，或者将Native子线程的执行结果返回给主线程。


在多线程环境中，有一个关键问题是如何安全地在后台线程（Native侧子线程）和UI主线程之间进行通信。ArkTS函数通常只能在主线程里调用，如果Native侧通过std::thread或pthread创建了子线程，那么主线程中的上下文环境和数据（napi_env、napi_value以及napi_ref）是不能直接在子线程上下文中使用的。


为确保正确性，当Native侧在子线程完成其计算或处理后，若需要回调ArkTS函数，必须先通过线程同步机制将结果传递回主线程，然后才能安全地在主线程环境中调用ArkTS函数。针对这个问题，可以采用以下方案来解决。

- 基于线程安全函数机制实现
- 基于libuv异步库的uv_async_send方法实现

推荐开发者使用线程安全函数作为Native侧子线程与UI主线程的通信手段。


如果线程安全函数确实不能满足开发需要，开发者可以使用libuv库自定义Loop然后通过uv_async_send方法进行线程间通信。


另外，libuv库中的uv_queue_work接口也可以实现线程间通信，但存在以下弊端：

- 使用uv_queue_work作为线程间通信的手段时，execute回调中一般实现为空任务，没有任何维测信息，一旦异步任务不回调，定位将很困难。这种方式不仅低效，而且还增加了发生故障时定位问题的难度。
- 它会破坏底层的数据可信性，uv_queue_work函数仅用于抛异步任务，异步任务的execute回调被提交到线程池后会经过调度执行，因此并不保证多次提交的任务之间的时序关系。

更多libuv库的方案策略可以查看API参考：libuv。


实现原理


基于线程安全函数机制


HarmonyOS Node-API提供了一系列线程安全函数相关的接口，通过这些接口可以在Native侧创建一个可以在多线程间共享并安全使用的函数对象。在创建过程中，需要指定一些关键信息，如ArkTS回调函数、异步资源标识符、缓冲队列容量、初始线程数等。这些信息将用于确保函数在多线程环境下的正确性和安全性。通过这个机制，子线程可以将数据传递给主线程，主线程接收到数据后会调用ArkTS回调函数进行处理。


调用流程图

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152938.80019020639893121528071727338624:50001231000000:2800:2E11AF51FEC5B5B8D06779DBAE1BC92E5F8174FDB403A6129FD64913D6D39C82.png)

首先ArkTS侧会传递一个回调函数到Native侧，然后在Native侧创建一个线程安全函数，此线程安全函数会绑定一个回调函数（通过napi_call_threadsafe_function调用线程安全函数时，会触发该函数），接着需要保存后续需要用到的上下文信息及参数，然后拆分子线程（子线程绑定了要用到的上下文信息及参数）。


Native侧子线程分配到系统资源之后会执行对应的业务逻辑，通过Node-API提供的线程安全函数相关的接口调用前面声明的线程安全函数，该线程安全函数会被push到主线程的事件循环中等待事件调度执行。


线程安全函数在事件循环中得到调度后会通过napi_call_back接口调用ArkTS回调函数。


开发步骤


基于libuv异步库的uv_async_send方法


libuv库提供了一个函数uv_async_send，用于在非阻塞事件循环中异步发送信号。uv_async_send函数允许用户在不同的线程或者事件循环的不同部分之间发送信号，从而触发某些操作而不需要直接调用阻塞函数。uv_async_send的核心原理是利用事件循环（event-loop）和内部消息队列来实现线程间的通信。具体来说，它允许一个线程（通常是工作线程）发送信号给主线程上的事件循环，从而触发主线程上的某个回调函数。因此利用该原理可以在主线程中定义用于回调ArkTS侧函数的回调函数，待子线程中业务逻辑执行完成后通过uv_async_send接口实现在子线程中通知主线程执行回调，进而实现对ArkTS侧函数的调用。


调用流程图

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152938.71507632003451919798149132468115:50001231000000:2800:993C3551A3612ED094EA44AA71F41490B5AD357A5FDDC6D645C67B69F62DE207.png)

首先ArkTS侧会传递一个回调函数到Native侧，Native侧接收到后会保存后续需要用到的上下文信息及参数，接着自定义一个Loop，该Loop会在主线程中执行，然后初始化async句柄并绑定后续需要在主线程调用的回调函数，运行自定义Loop。接着拆分子线程（子线程绑定了要用到的上下文信息及参数）。


Native侧子线程分配到系统资源之后在子线程中调用uv_async_send方法通知主线程调用与async绑定的函数。


运行在主线程的自定义Loop接收到信号后，会调用之前async句柄绑定的回调函数，然后就可以在该函数中调用ArkTS回调函数。


开发步骤


场景案例


本节将以分别使用线程安全函数和libuv异步库实现以下操作，在Native侧拆分子线程执行业务逻辑，子线程业务逻辑完成之后回到主线程执行ArkTS侧传入的ArkTS回调函数，从而完成了对ArkTS端变量值的加30操作。


从ArkTS侧传递给Native侧的函数引用，其生命周期仅限于它所在的作用域内。若要确保在超出该作用域后仍能继续使用这个函数引用，需要采取适当的方法来延长其生命周期。可以通过调用napi_create_reference接口为ArkTS对象创建一个引用(reference)。这样可以避免对象因垃圾回收机制而被提前释放，从而有效地延长它的生命周期。然而，在创建引用之后，务必牢记要在不再需要该引用时，调用napi_delete_reference来释放引用，以防止内存泄漏问题的发生。


基于线程安全函数机制实现


```typescript
  // 声明ArkTS侧函数
  @State value: number = 0;
  work: Function = (param: number) => {
    param += 30;
    this.value = param;
    return param;
  }
```

1.  threadSafeCase接口接收到ArkTS传入的回调函数后通过napi_create_threadsafe_function创建一个线程安全函数tsFn，tsFn会回调主线程中的ThreadSafeCallJs方法，然后在ThreadSafeCallJs方法中调用ArkTS侧传入的回调函数。 在拆分子线程时，需要保存上下文信息及ArkTS函数引用，保存完之后拆分子线程。

```less
// 全局变量，tsFn用于存储线程安全函数，g_value代表计算最终结果
napi_threadsafe_function tsFn;
static int g_value = 0;


// 用于存储主线程上下文信息的结构体
struct CallbackContext {
    napi_env env = nullptr;
    napi_ref callbackRef = nullptr;
};
```

2.  在子线程中通过napi_call_threadsafe_function调用线程安全函数tsFn，把CallbackContext结构体数据作为参数传入线程安全函数。开发者可以根据自身实际需求在子线程中添加相应的业务操作。

```less
void SubThread(CallbackContext *asyncContext) {
    if (asyncContext == nullptr) {
        return;
    }
    napi_acquire_threadsafe_function(tsFn);
    OH_LOG_INFO(LOG_APP, "ThreadSafe ChildThread, value:[%{public}d]", g_value);
    // 调用线程安全函数，asyncContext为传递的参数数据
    napi_call_threadsafe_function(tsFn, asyncContext, napi_tsfn_nonblocking);
    napi_release_threadsafe_function(tsFn, napi_tsfn_release);
}
```

3.  通过上面保存的上下文信息及ArkTS函数引用回调ArkTS回调函数实现加30操作。

```less
static void ThreadSafeCallJs(napi_env env, napi_value js_callBack, void *context, void *data) {
    // 获取调用线程安全函数时传入的数据
    CallbackContext *argContext = reinterpret_cast<CallbackContext *>(data);
    if (argContext != nullptr) {
        // 获取ArkTS回调函数引用
        napi_get_reference_value(env, argContext->callbackRef, &js_callBack);
    } else {
        return;
    }


    napi_valuetype valueType = napi_undefined;
    napi_typeof(env, js_callBack, &valueType);
    if (valueType != napi_valuetype::napi_function) {
        napi_delete_reference(env, argContext->callbackRef);
        delete argContext;
        argContext = nullptr;
        return;
    }


    napi_value argv;
    napi_create_int32(env, g_value, &argv);
    napi_value result = nullptr;
    // 调用ArkTS侧回调函数并传递参数
    napi_call_function(env, nullptr, js_callBack, 1, &argv, &result);
    napi_get_value_int32(env, result, &g_value);
    OH_LOG_INFO(LOG_APP, "ThreadSafe CallArkTS end, value:[%{public}d]", g_value);
    // 清理资源
    napi_delete_reference(env, argContext->callbackRef);
    delete argContext;
    argContext = nullptr;
}
```


结果展示

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152938.90757327271228626780729967703514:50001231000000:2800:E38A6979D0AE4B898AB83F29C1FFC9294C06602D5861490E6E1538B74749E229.png)

基于libuv异步库的uv_async_send方法实现


使用libuv异步库需要在CMakeLists.txt文件中添加libuv.so依赖，并在使用libuv接口的代码文件中引用其头文件uv.h，例如这里我们在napi_init文件中引用。


```less
// CMakeLists.txt文件
target_link_libraries(entry PUBLIC libace_napi.z.so libhilog_ndk.z.so libuv.so)


// napi_init.cpp文件
#include <uv.h>
```

1.  在ArkTS侧实现一个回调函数，参数为param，函数体中对参数param加30后刷新变量value，并返回最新的param值。将回调函数作为参数调用Native侧的libUvCase接口。

```typescript
  // 声明ArkTS侧函数
  @State value: number = 0;
  work: Function = (param: number) => {
    param += 30;
    this.value = param;
    return param;
  }
```

2.  首先定义两个全局变量，用于存储Loop和async句柄。

```less
// 全局变量，用于存储loop信息和async句柄
uv_loop_t *loop = nullptr;
uv_async_t *async = nullptr;
```


```less
    // 初始化async句柄，绑定需要在主线程调用的回调函数
    loop = uv_default_loop();
    async = new uv_async_t;
    uv_async_init(loop, async, async_handler);


    // 创建子线程caseThread，CallbackUvWorkTest为其函数主体、asyncContext为传递的参数信息
    std::thread caseThread(CallbackUvWorkTest, asyncContext);
    caseThread.detach();
    uv_run(loop, UV_RUN_DEFAULT);
    return nullptr;
```


```less
void CallbackUvWorkTest(CallbackContext *context) {
    if (context == nullptr) {
        return;
    }
    OH_LOG_INFO(LOG_APP, "LibUV ChildThread, value:[%{public}d]", g_value);
    // 绑定数据信息
    async->data = reinterpret_cast<void *>(context);
    // 在任意子线程中调用uv_async_send，通知主线程调用与async绑定的回调函数
    uv_async_send(async);
}
```


```less
void async_handler(uv_async_t *handle) {
    CallbackContext *context = reinterpret_cast<CallbackContext *>(handle->data);
    napi_handle_scope scope = nullptr;
    // 打开handle_scope用于管理napi_value的生命周期，否则会内存泄露。
    napi_open_handle_scope(context->env, &scope);
    if (scope == nullptr) {
        napi_delete_reference(context->env, context->callbackRef);
        delete context;
        context = nullptr;
        if (handle != nullptr) {
            delete handle;
            handle = nullptr;
        }
        return;
    }
    napi_value callback = nullptr;
    // 获取ArkTS回调函数引用
    napi_get_reference_value(context->env, context->callbackRef, &callback);
    napi_value retArg;
    napi_create_int32(context->env, g_value, &retArg);
    napi_value result;
    // 调用ArkTS侧回调函数并传递参数
    napi_call_function(context->env, nullptr, callback, 1, &retArg, &result);
    napi_get_value_int32(context->env, result, &g_value);
    OH_LOG_INFO(LOG_APP, "LibUV CallArkTS end, value:[%{public}d]", g_value);
    // 关闭handle_scope释放napi_value
    napi_close_handle_scope(context->env, scope);
    // 清理资源
    napi_delete_reference(context->env, context->callbackRef);
    delete context;
    context = nullptr;
    // 调用uv_close关闭async，在主循环中释放内存
    uv_close((uv_handle_t *)async, [](uv_handle_t *handle) { delete (uv_async_t *)handle; });
}
```


结果展示

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152938.81568267117098076554104798263868:50001231000000:2800:226ED9BAF79CF1C3EE5C129F656447243A422365EC500098E144BDEC62690E7E.png)

常见问题


如何在Native侧调用ArkTS侧异步方法，并获取异步计算结果到Native侧


可以参考如下链接：在Native侧调用ArkTS侧异步方法。


示例代码

- 实现Native侧子线程与UI主线程通信

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-web-development-practices
爬取时间: 2025-05-08 03:34:44
来源: Huawei Developer

- 应用网络重连
- 基于RCP的网络请求开发实践
- 网络管理与状态监听开发实践
- 低功耗蓝牙开发实践
- 基于RCP的文件上传与下载
- 基于SFFT的大文件高速并发传输

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-network-reconnection
爬取时间: 2025-05-08 03:34:51
来源: Huawei Developer


概述


网络重连是指在网络连接出现中断或异常断开的情况下，设备或应用程序重新建立网络连接的过程。对于许多依赖网络的业务和应用来说，网络重连能够确保在网络出现短暂中断后，业务能够快速恢复，减少因网络故障导致的业务中断时间，提高业务的连续性和可靠性。例如，在线金融交易、远程医疗、音视频播放等对实时性和连续性要求较高的业务，网络重连功能至关重要。根据应用的实际场景，网络重连可以分为以下多种方式。

- 网络超时重连：客户端向服务器发送请求后，如果发生网络超时，那么客户端将自动尝试与服务器重新建立连接。
- 网络切换重连：当网络连接发生变化后，客户端应用可能会出现网络异常。应用需要检测网络状态变化，并根据网络状态进行连接。
- 应用前后台切换后重连：应用切换到后台一段时间后，网络资源会被冻结释放，需要客户端重新建立连接。

网络超时重连


场景描述


在网络请求中，经常会遇到网络波动、服务器宕机等情况，从而导致网络不可用、网络超时等问题。为了减少网络超时等带来的影响，在实际应用开发中经常使用超时机制和重试机制。如HTTP请求列表数据时，设置HTTP连接超时和请求重试。

- 网络超时机制是指在网络通信过程中，当一个操作在规定的时间内没有得到预期的响应或完成时，系统会自动判定该操作失败，并触发相应的处理逻辑。其原理是通过设置一个定时器，从网络操作开始时计时，一旦超过设定的时间阈值，就认为操作超时。
- 重试机制一般配合超时机制一起使用，指的是多次发送相同的请求来避免瞬态故障和偶然性故障。

实现原理


网络超时分为网络连接超时和网络读取超时。

- 网络连接超时就是在程序默认的等待时间内没有得到服务器的响应。
- 网络读取超时指客户端在读取服务器响应时等待的时间。

网络重试常用的策略有定时重试、指数退避重试、随机退避重试等。

- 定时重试：设定一个固定的重试次数，当网络请求失败时，在该次数范围内进行重试，每次重试之间的时间间隔可以是固定的，也可以根据具体情况进行调整。例如，设定重试次数为 3 次，每次重试间隔为 2 秒。
- 指数退避重试：每次重试的时间间隔按照指数级增长，如重试间隔时间依次为2、4、8、16等。
- 随机退避重试：每次重试的时间间隔在一个指定的范围内随机取值。例如，设定重试间隔时间在 1 秒到 5 秒之间随机，这样可以避免多个请求同时重试，分散服务器的负载压力，提高整体的重试成功率。

在设置重试策略时，需要根据实际的场景来进行设置，既要考虑网络超时的时间，还需要关注重试的次数和时间间隔，避免网络资源浪费。


开发步骤


在HarmonyOS中，在Http、RCP发生错误或者超时后，都可以使用网络超时重连的机制。HTTP超时重连的实现步骤如下所示。

- 设置HTTP请求的读取超时时间、连接超时时间。
- 可以根据网络状态进行判断，然后再进行重连。这样可以在非网络问题的情况下进行重试，可以更精准地控制重试行为，提高请求的成功率和效率。例如，对于一些表示服务错误的响应码（如 500 Internal Server Error、503 Service Unavailable 等），可以进行重试。
- 使用setTimeout进行函数执行延迟，配合使用Promise，进而同步获取网络请求结果。

HTTP超时重连的代码如下所示：


```typescript
// entry/src/main/ets/pages/HTTPReconnection
async getHttpRequest(url: string, retry: number): Promise<number | undefined> {
  try {
    return await this.httpRequest?.requestInStream(url,
      { method: http.RequestMethod.GET, connectTimeout: 6000, readTimeout: 60000 })
      .then((data: number) => {
        if (data === 408 || data === 500 && retry > 0) {
          return new Promise((resolve: Function) => {
            setTimeout(() => {
              resolve(this.getHttpRequest(url, retry - 1));
            }, 2000);
          });
        } else {
          return data;
        }
      });
  } catch (err) {
    this.isDownload = false;
    promptAction.showToast({ message: $r('app.string.download_error') });
    return;
  }
}
```


RCP超时重连的实现与HTTP的实现步骤类似，RCP超时重连的代码如下所示：


```less
// entry/src/main/ets/pages/RCPReconnection
createRCPSession(): rcp.Session {
  const customHttpEventsHandler: rcp.HttpEventsHandler = {
    onDownloadProgress: (totalSize: number, transferredSize: number) => {
      if (this.contentLength === -1) {
        this.contentLength = totalSize;
      }
      this.downloadSize = transferredSize;
      this.process = Math.floor(this.downloadSize / this.contentLength * 100);
    },


    onDataEnd: () => {
      this.contentLength = -1;
      this.downloadSize = 0;
    },
  };
  const sessionConfig: rcp.SessionConfiguration = {
    requestConfiguration: {
      transfer: {
        timeout: {
          connectMs: 6000,
          transferMs: 60000
        }
      },
      tracing: { httpEventsHandler: customHttpEventsHandler }
    }
  }
  return rcp.createSession(sessionConfig);
}


// ...


async getRcpRequest(url: string, retry: number): Promise<rcp.Response | undefined> {
  try {
    return await this.session.get(url)
      .then((response) => {
        if ((response.statusCode === 408 || response.statusCode === 500) && retry > 0) {
          return new Promise((resolve: Function) => {
            setTimeout(() => {
              resolve(this.getRcpRequest(url, retry - 1));
            }, 2000)
          })
        } else {
          return response;
        }
      })
  } catch (err) {
    promptAction.showToast({ message: $r('app.string.download_error') });
    this.isDownload = false;
    return;
  }
}
```


网络切换重连


场景描述


在当下这个数字化时代，大部分的应用确实离不开网络，网络已经深度渗透到各类应用场景之中。然而，在网络状态切换后，如何继续保持网络连接是许多应用需要处理的问题。


实现原理


网络切换主要分为网络类型切换和无网络与有网络之间的切换。针对网络切换的场景，HarmonyOS提供了网络连接管理能力，用于查询网络信息、监听网络连接的变化等。


在实现网络切换重连上，主要包含以下步骤。

- 使用网络连接管理的能力监听网络变化，并使用AppStorage存储应用全局网络状态。
- 使用@StorageProp，将AppStorage存储的网络状态与对应的属性建立单向数据同步。
- 使用@Watch监听状态变量的变化，当状态变量变化后，对网络进行关闭或重连。

开发步骤


调用connection的register方法订阅网络变化通知，同时，订阅netCapabilitiesChange网络能力变化事件，订阅netLost网络丢失事件。在设备从有网络到无网络状态会触发netLost事件，从无网络到有网络会触发netCapabilitiesChange事件。而在网络类型切换时，也会触发netLost事件和netCapabilitiesChange事件，开发者可以根据实际场景需要在netCapabilitiesChange事件中，将网络类型及网络状态存储在AppStorage中。


```typescript
// entry/src/main/ets/utils/ConnectionUtil
private netCon: connection.NetConnection = connection.createNetConnection();


register() {
  this.netCon.register((error: BusinessError) => {
    Logger.error('net register:' + JSON.stringify(error));
  });
}


netCapabilitiesChange() {
  this.netCon.on('netCapabilitiesChange', (data: connection.NetCapabilityInfo) => {
    let netAvailable = false;
    data.netCap.networkCap?.forEach((value) => {
      if (value === connection.NetCap.NET_CAPABILITY_INTERNET) {
        netAvailable = true;
      }
    })
    Logger.info('ConnectionUtil.netAvailable:' + netAvailable);
    AppStorage.setOrCreate('netAvailable', netAvailable);
  })


  this.netCon.on('netLost', (data: connection.NetHandle) => {
    AppStorage.setOrCreate('netAvailable', false);
    Logger.info("WifiChangeListen-- Succeeded to get data: " + JSON.stringify(data));
  });
}
```


使用AppStorage存储应用全局网络状态。


```less
// entry/src/main/ets/pages/SocketReconnection
@StorageProp('netAvailable') @Watch('onSocketUpdated') netAvailable: boolean = true;
```


使用@Watch监听状态变量的变化，并根据对应的变化和实际应用场景重新连接网络。


```less
// entry/src/main/ets/pages/SocketReconnection
onSocketUpdated() {
  this.netAvailable ? this.tcpSocketConnect() : this.tcpSocketDisconnect();
  Logger.info('netAvailable:' + this.netAvailable);
}


// ...
tcpSocketConnect() {
  if (!this.netAvailable) {
    promptAction.showToast({ message: $r('app.string.connect_error') });
    return;
  }


  this.tcp = socket.constructTCPSocketInstance();
  this.tcp.on('connect', () => {
    Logger.info('on connect');
  });
  this.tcp.on('close', () => {
    Logger.info('on close');
  });
  const clientIpAddress: socket.NetAddress = {
    address: CommonConstants.IP_ADDRESS,
    port: CommonConstants.CLIENT_IP_PORT
  } as socket.NetAddress;


  this.tcp.bind(clientIpAddress, (err: BusinessError) => {
    if (err) {
      Logger.error('bind fail' + JSON.stringify(err));
      promptAction.showToast({ message: $r('app.string.connect_error') });
      return;
    }


    let tcpConnect: socket.TCPConnectOptions = {} as socket.TCPConnectOptions;
    const serverIpAddress: socket.NetAddress = {
      address: CommonConstants.IP_ADDRESS,
      port: CommonConstants.IP_PORT
    } as socket.NetAddress;
    tcpConnect.address = serverIpAddress;
    tcpConnect.timeout = 3000;
    this.tcp?.connect(tcpConnect, (err: BusinessError) => {
      if (err) {
        Logger.error('connect fail');
        promptAction.showToast({ message: $r('app.string.connect_error') });
        return;
      }
    });
  });
}
```


无网络切换有网络后重连下载效果图如下。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153219.63519080082488557598045240776788:50001231000000:2800:EAB135E3E7F50C4ED522B1B5DFC154ED1F6910DFA9E03E68B9F5BC470AFC01E8.gif)

应用前后台切换后重连


场景描述


应用在使用TCPSocket、UDPSocket等通信时，如果未申请长时任务或短时任务，当应用退到后台一段时间后，可能遇到网络不可用或网络资源异常的情况，并且将应用切回前台后，继续使用之前的TCPSocket、UDPSocket等连接对象继续和服务器通信也可能出现网络异常。


实现原理


在HarmonyOS中，应用切换到后台2秒后，应用的网络资源会被冻结，并且在12秒后进行释放。此时，再继续使用网络资源，就会出现网络不可用的情况。如果应用有后台使用网络资源的场景，可以使用短时任务或长时任务。


由于Socket通信是基于IP和端口进行通信的，在应用退到后台后，网络资源被冻结时会清空TCP、UDP连接对象的IP和端口，但是不会释放连接对象。在应用切换到前台后，系统会给连接对象重新分配新的IP和端口，继续使用之前的连接对象与服务器进行通信时，服务器会认为同一个连接对象前后IP和端口不一致，从而导致通信不可信、网络异常。


应用前后台切换后网络重连在实现上有以下两个关键部分。

- 结合UIAbility组件生命周期onForeground和onBackground，在前后台切换时，将应用前后台的状态存储在AppStorage中。
- 使用@StorageProp将AppStorage存储的前后台状态与对应的属性建立单向数据同步。并使用@Watch监听状态变量的变化，当前后台变化后，关闭或重新连接。

开发步骤


前后台切换时，在UIAbility组件生命周期中存储前后台状态。


```less
// entry/src/main/ets/entryablity/EntryAbility
export default class EntryAbility extends UIAbility {
  // ...


  onForeground(): void {
    // Ability has brought to foreground
    // ...
    AppStorage.setOrCreate('onForeground', true);
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
  }


  onBackground(): void {
    // Ability has back to background
    // ...
    AppStorage.setOrCreate('onForeground', false);
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
  }
}
```


使用@StorageProp同步前后台状态，并使用@Watch监听状态变化。


```less
// entry/src/main/ets/pages/SocketReconnection
@StorageProp('onForeground') @Watch('onForegroundChange') onForeground: boolean = true;
// ...
onForegroundChange(): void {
  this.onForeground ? this.tcpSocketConnect() : this.tcpSocketDisconnect();
}
```


前后台切换网络重连实现效果如下：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153219.06090121643254740485066905412603:50001231000000:2800:3D081D438615243613F4D2C277AE4415F160585D1B230F0418976EB4221D4631.gif)

示例代码

- 实现应用网络重连功能

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-rcp-based-network-request
爬取时间: 2025-05-08 03:34:58
来源: Huawei Developer


概述


Remote Communication Kit中的@hms.collaboration.rcp(后续简称RCP）指的是远程通信平台（remote communication platform），RCP提供了网络数据请求功能，相较于Network Kit中HTTP请求能力，RCP更具易用性，且拥有更多的功能。在开发过程中，如果有些场景使用Network Kit中HTTP请求能力达不到预期或无法实现，那么就可以尝试使用RCP中的数据请求功能来实现。


接下来，本文将先介绍RCP与HTTP的区别，然后从使用RCP实现基础的网络请求、多表单提交、双向证书校验、DNS的相关设置、请求与响应拦截和捕获有关HTTP请求/响应流的详细信息等几个场景来介绍RCP拥有的能力。


RCP与HTTP的区别


为了方便了解RCP与HTTP的区别，可以从功能分类、功能名称和功能描述这三个方面进行对比，主要区别如下：


| 功能分类  | 功能名称  | 功能描述  | HTTP  | RCP  |
| --- | --- | --- | --- | --- |
| 基础功能  | 发送PATCH类型请求  | 以PATCH的方式请求  | 不支持  | 支持  |
| 基础功能  | 设置会话中URL的基地址  | 会话中URL的基地址将自动加在URL前面，除非URL是一个绝对的URL  | 不支持  | 支持  |
| 基础功能  | 取消自动重定向  | HTTP请求不会自动重定向  | 不支持  | 支持  |
| 基础功能  | 拦截请求和响应  | 在请求后或响应前进行拦截  | 不支持  | 支持  |
| 基础功能  | 取消请求  | 发送请求前取消、发送请求过程中取消、请求接收后取消  | 不支持  | 支持  |
| 基础功能  | 响应缓存  | 是否使用缓存，请求时优先读取缓存。缓存跟随当前进程生效，新缓存会替换旧缓存  | 不支持  | 支持  |
| 基础功能  | 设置响应数据的类型  | 设置数据以何种方式返回，将要响应的数据类型可设置为string、object、arraybuffer等类型  | 支持  | 不支持  |
| 基础功能  | 定义允许的HTTP响应内容的最大字节数  | 服务器成功响应时，在获取数据前校验响应内容的最大字节数  | 支持  | 不支持  |
| 证书验证  | 自定义证书校验  | 自定义逻辑校验客户端和服务端的证书，判断是否可以连接  | 不支持  | 支持  |
| 证书验证  | 忽略SSL校验  | 在建立SSL连接时不验证服务器端的SSL证书  | 不支持  | 支持  |
| DNS  | 自定义DNS解析  | 包括自定义DNS服务器或静态DNS规则  | 不支持  | 支持  |
| RCP特有  | 捕获详细的跟踪信息  | 在会话中的HTTP请求期间捕获详细的跟踪信息。跟踪有助于调试、性能分析和深入了解通信过程中的数据流  | 不支持  | 支持  |
| RCP特有  | 数据打点，获取HTTP请求的具体数据  | HTTP请求各阶段的定时信息  | 不支持  | 支持  |

功能分类


功能名称


功能描述


HTTP


RCP


基础功能


发送PATCH类型请求


以PATCH的方式请求


不支持


支持


基础功能


设置会话中URL的基地址


会话中URL的基地址将自动加在URL前面，除非URL是一个绝对的URL


不支持


支持


基础功能


取消自动重定向


HTTP请求不会自动重定向


不支持


支持


基础功能


拦截请求和响应


在请求后或响应前进行拦截


不支持


支持


基础功能


取消请求


发送请求前取消、发送请求过程中取消、请求接收后取消


不支持


支持


基础功能


响应缓存


是否使用缓存，请求时优先读取缓存。缓存跟随当前进程生效，新缓存会替换旧缓存


不支持


支持


基础功能


设置响应数据的类型


设置数据以何种方式返回，将要响应的数据类型可设置为string、object、arraybuffer等类型


支持


不支持


基础功能


定义允许的HTTP响应内容的最大字节数


服务器成功响应时，在获取数据前校验响应内容的最大字节数


支持


不支持


证书验证


自定义证书校验


自定义逻辑校验客户端和服务端的证书，判断是否可以连接


不支持


支持


证书验证


忽略SSL校验


在建立SSL连接时不验证服务器端的SSL证书


不支持


支持


DNS


自定义DNS解析


包括自定义DNS服务器或静态DNS规则


不支持


支持


RCP特有


捕获详细的跟踪信息


在会话中的HTTP请求期间捕获详细的跟踪信息。跟踪有助于调试、性能分析和深入了解通信过程中的数据流


不支持


支持


RCP特有


数据打点，获取HTTP请求的具体数据


HTTP请求各阶段的定时信息


不支持


支持


实现基础的网络请求


发送请求


通过RCP模块能够发起基础的网络请求，如GET、POST、HEAD、PUT、DELETE、PATCH、OPTIONS等请求。以PATCH请求为例，开发过程中经常会遇到发送请求修改资源的场景，假设有一个UserInfo，里面有userId、userName、 userGender等10个字段。可编辑功能因为需求，在某个特别的页面里只能修改userName，这时就可以用PATCH请求，来更新局部资源。


实现思路


在创建session会话后，通过创建请求对象并传入第二个参数且指定为PATCH，然后通过session.fetch()发起请求即可。


核心代码


```less
// 定义请求头
let headers: rcp.RequestHeaders = {
  'accept': 'application/json'
};
// 定义要修改的内容
let modifiedContent: UserInfo = {
  'userName': 'xxxxxx'
};
const securityConfig: rcp.SecurityConfiguration = {
  tlsOptions: {
    tlsVersion: 'TlsV1.3'
  }
};
// 创建通信会话对象
const session = rcp.createSession({ requestConfiguration: { security: securityConfig } });
// 定义请求对象rep
let req = new rcp.Request('http://example.com/fetch', 'PATCH', headers, modifiedContent);
// 发起请求
session.fetch(req).then((response) => {
  Logger.info(`Request succeeded, message is ${JSON.stringify(response)}`);
}).catch((err: BusinessError) => {
  Logger.error(`err: err code is ${err.code}, err message is ${JSON.stringify(err)}`);
});
```


设置会话中URL的基地址


会话中URL的基地址是在发起请求时用作请求地址的前缀。 当我们向服务器发起请求时，该请求的最终的请求地址由会话中URL的基地址与请求路径来构建的。 这使得我们可以将服务器的主机地址与公共路径隔离开来，方便管理和维护。


实现思路


会话中URL的基地址可通过RCP模块中的SessionConfiguration来进行设置，在sessionConfig对象中设置“baseAddress：'http://api.example.com' ”即可。


核心代码


```less
// 定义sessionConfig对象
const sessionConfig: rcp.SessionConfiguration = {
  baseAddress: 'http://api.example.com',
  headers: {
    'authorization': 'Bearer YOUR_ACCESS_TOKEN',
    'content-type': 'application/json'
  },
  requestConfiguration:{
    security:{
      tlsOptions: {
        tlsVersion: 'TlsV1.3'
      }
    }
  }
};
// 创建通信会话对象，并传入sessionConfig
const session = rcp.createSession(sessionConfig);
```


实现多表单提交


开发过程中时常会遇到多表单提交的场景，例如在同页面下tab栏可切换多个Form表单组件，但只有一个提交按钮，各组件下的表单数据需要被一起提交。此时可以使用RCP模块中的MultipartForm来实现多表单提交的场景。


实现思路


在创建session会话后，通过new rcp.Request()的第四个参数传入MultipartForm，然后通过rcp.fetch()发起POST请求将多个表单数据携带上传至服务端。


核心代码


```less
// 定义请求头类型
let headers: rcp.RequestHeaders = {
  'accept': 'application/json'
};
// 配置HTTP请求的超时值
let configuration: rcp.Configuration = {
  transfer: {
    timeout: {
      connectMs: 60000,
      transferMs: 60000
    }
  }
};
// HTTP请求中的Cookie
let cookies: rcp.RequestCookies = {
  'name1': 'value1',
  'name2': 'value2',
};
// 设置数据传输范围
let transferRange: rcp.TransferRange = {
  from: 100,
  to: 200
};


// 设置multipartFrom数据
const multiForm = new rcp.MultipartForm({
  'Form1': this.name, // string
  'Form2': this.hobbies, // string
  'Form3': {
    contentType: 'text/plain',
    remoteFileName: 'RemoteFileName',
    contentOrPath: '/file/to/Path'
  } // object
});


const securityConfig: rcp.SecurityConfiguration = {
  tlsOptions: {
    tlsVersion: 'TlsV1.3'
  }
};
// 创建通信会话对象
const session = rcp.createSession({ requestConfiguration: { security: securityConfig } });
// 定义请求对象req
let req =
  new rcp.Request('https://www.example.com', 'POST', headers, multiForm, cookies, transferRange, configuration);
req.content = multiForm;


// 发起请求
session.fetch(req).then((response) => {
  Logger.info(`Request succeeded, message is ${JSON.stringify(response)}`);
}).catch((err: BusinessError) => {
  Logger.error(`err: err code is ${err.code}, err message is ${JSON.stringify(err)}`);
});
```


实现双向证书校验


为验证服务端和客户端之间的身份和数据完整性，确保通信的安全性，可使用RCP接口能力实现双向证书校验能力。


详情请参见：双向证书校验


实现对DNS的定制设置


通过RCP模块，能够实现对DNS的定制设置。开发人员可以按自己的需要配置DNS，包括自定义DNS服务器、自定义静态DNS规则和配置HTTPS上的DNS，都可以通过DnsConfiguration设置。DnsConfiguration中可设置dnsRules、dnsOverHttps。

-  自定义DNS服务器（DnsServers）：可指定自定义的DNS服务器提供解析服务。 自定义静态DNS（StaticDnsRules）：有些时候，默认的DNS不能正常解析部分域名，就需要手动添加静态DNS。添加静态DNS后，如果hostname匹配，则优先使用指定的地址。 自定义动态DNS（DynamicDnsRules）：除了添加静态DNS外，还可以添加动态DNS。动态DNS可看作一个可以根据hostname和port直接返回IP地址的函数，如果设置，则优先使用函数中返回的地址。
-  DNS over HTTPS配置（DnsOverHttpsConfiguration）：配置HTTPS上的DNS（DOH）设置，以加密的HTTPS协议进行DNS解析请求，避免原始DNS协议中用户的DNS解析请求被窃听或者修改的问题，来达到保护用户隐私的目的。如果设置，则优先使用DNS服务器解析的地址。

自定义DNS服务器


实现思路


先配置自定义的DNS服务器customDnsServers，在创建session会话时，通过requestConfiguration传入dns对象，指定dns对象中的dnsRules为customDnsServers。


核心代码


```less
// 配置自定义DNS服务器
const customDnsServers: rcp.DnsServers = [
  { ip: '8.8.8.8' },
  { ip: '8.8.4.4', port: 53 }
];
// 创建通信会话对象
const sessionWithCustomDns = rcp.createSession({
  requestConfiguration: {
    dns: {
      dnsRules: customDnsServers
    },
    security: {
      tlsOptions: {
        tlsVersion: 'TlsV1.3'
      }
    }
  }
});
// 发起请求
sessionWithCustomDns.get('http://www.example.com').then((response) => {
  Logger.info(`Request succeeded, message is ${JSON.stringify(response)}`);
}).catch((err: BusinessError) => {
  Logger.error(`err: err code is ${err.code}, err message is ${JSON.stringify(err)}`);
});
```


自定义静态DNS


实现思路


先配置静态DNS规则staticDnsRules，在创建session会话时，通过requestConfiguration传入dns对象，指定dns对象中的dnsRules为staticDnsRules 。


```less
// 当匹配到hostname时，优先使用指定的地址
const staticDnsRules: rcp.StaticDnsRules = [
  {
    host: 'example.com',
    port: 80,
    ipAddresses: ['192.168.1.1', '192.168.1.2']
  }
];
// 创建通信会话对象
const sessionWithCustomDns = rcp.createSession({
  requestConfiguration: {
    dns: {
      dnsRules: staticDnsRules
    },
    security: {
      tlsOptions: {
        tlsVersion: 'TlsV1.3'
      }
    }
  }
});
// 发起请求
sessionWithCustomDns.get('http://www.example.com').then((response) => {
  Logger.info(`Request succeeded, message is ${JSON.stringify(response)}`);
}).catch((err: BusinessError) => {
  Logger.error(`err: err code is ${err.code}, err message is ${JSON.stringify(err)}`);
});
```


配置HTTPS上的DNS


实现思路


先创建HTTPS上的DNS对象dohConfig，在创建session会话时，通过requestConfiguration传入dns对象，指定dns对象中的dnsOverHttps为dohConfig 。


```less
// DNS over HTTPS配置
const dohConfig: rcp.DnsOverHttpsConfiguration = {
  url: 'https://dns.example.com/dns-query',
  skipCertificatesValidation: true
};
// 创建通信会话对象
const sessionWithCustomDns = rcp.createSession({
  requestConfiguration: {
    dns: {
      dnsOverHttps: dohConfig
    },
    security: {
      tlsOptions: {
        tlsVersion: 'TlsV1.3'
      }
    }
  }
});
// 发起请求
sessionWithCustomDns.get('http://www.example.com').then((response) => {
  Logger.info(`Request succeeded, message is ${JSON.stringify(response)}`);
}).catch((err: BusinessError) => {
  Logger.error(`err: err code is ${err.code}, err message is ${JSON.stringify(err)}`);
});
```


实现请求与响应拦截


使用拦截器可以方便的对HTTP的请求与响应进行修改，您可以创建拦截器链，按需定制一组拦截器对您的网络请求/响应进行修改。RCP模块提供了拦截器能力，在SessionConfiguration中添加Interceptors参数，传入自定义的拦截器，即可在HTTP请求和响应的过程中添加拦截器功能。


拦截器工作原理


客户端发送HTTP请求，到达目标服务器之前，可以使用拦截器对HTTP的请求进行修改。如下图，定义了链式拦截器，ResponseCachingInterceptor拦截器（下文以拦截器1代替）和ResponseHeaderRemoveInterceptor拦截器（下文以拦截器2代替）。请求先被拦截器1拦截，该拦截器中可以对请求的响应结果进行缓存。然后经过拦截器2，最后到达Internet。当请求到达目标服务器，服务器返回请求响应的结果给客户端之前，可以使用拦截器对HTTP的响应进行修改。如下图，响应先被拦截器2拦截，在响应返回给应用前检查和修改服务器的请求头。然后经过拦截器1，最后客户端接收响应结果。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153219.26783500041568538022015438489888:50001231000000:2800:B8FFC3D2C32D7FCC7C5CEBBB96EC991DE4283AACCBF61D4B5ED338E4505D3D8B.png)

ResponseCachingInterceptor拦截器和ResponseHeaderRemoveInterceptor拦截器都是自定义拦截器，需要开发者通过代码去实现内部逻辑。


拦截器的定义和使用


下面将介绍如何自定义拦截器，定义ResponseCachingInterceptor拦截器和ResponseHeaderRemoveInterceptor拦截器实现rcp.Interceptor，可在intercept()方法中根据业务需求自定义处理逻辑，实现对请求/响应的修改。


核心代码


```less
import { rcp } from '@kit.RemoteCommunicationKit';
import Logger from '../common/Logger';


export class ResponseCache {
  public readonly cache: Record<string, rcp.Response> = {};


  getResponse(url: string): rcp.Response {
    return this.cache[url];
  }


  setResponse(url: string, response: rcp.Response): void {
    this.cache[url] = response;
  }
}


// Define the ResponseCachingInterceptor interceptor
export class ResponseCachingInterceptor implements rcp.Interceptor {
  public readonly cache: ResponseCache;


  constructor(cache: ResponseCache) {
    this.cache = cache;
  }


  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {
    const url = context.request.url.href;
    const responseFromCache = this.cache.getResponse(url);
    if (responseFromCache) {
      return Promise.resolve(responseFromCache);
    }
    AppStorage.setOrCreate('ReplacedInfo',
      `[ResponseCachingInterceptor]: Request URL is "${context.request.url.href}"`);
    const promise = next.handle(context);
    promise.then((resp) => {
      resp.statusCode;
      this.cache.setResponse(url, resp);
    });
    return promise;
  }
}


// Define the ResponseHeaderRemoveInterceptor interceptor
export class ResponseHeaderRemoveInterceptor implements rcp.Interceptor {
  // Custom Response processing Logic
  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {
    const response = await next.handle(context);
    const toReturn: rcp.Response = {
      request: response.request,
      statusCode: response.statusCode,
      httpVersion: response.httpVersion,
      headers: {
        'content-range': response.headers['content-range']
      },
      effectiveUrl: response.effectiveUrl,
      timeInfo: response.timeInfo,
      toJSON: () => null
    };
    Logger.info('[ResponseHeaderRemoveInterceptor]: Response was modified');
    return toReturn;
  }
}
```


下面将介绍如何使用拦截器，可通过RCP模块中的SessionConfiguration来进行设置，在sessionConfig对象中设置interceptors，即可在请求/响应中添加拦截器。


核心代码


```less
const cache = new ResponseCache();
const sessionConfig: rcp.SessionConfiguration = {
  interceptors: [
    new ResponseCachingInterceptor(cache),
    new ResponseHeaderRemoveInterceptor()
  ],
  requestConfiguration: {
    security: {
      tlsOptions: {
        tlsVersion: 'TlsV1.3'
      }
    }
  }
};


const session = rcp.createSession(sessionConfig);
```


捕获有关HTTP请求/响应流的详细信息


当需要采集应用中HTTP请求的详细跟踪信息时，可以使用TracingConfiguration进行相关配置。TracingConfiguration中可以设置verbose（启用详细跟踪）、infoToCollect（配置要收集的特定类型的信息事件）、collectTimeInfo（在跟踪过程中是否应收集与时间相关的信息）、httpEventsHandler（为HTTP请求/响应过程中的特定操作定义响应处理程序的回调）四个参数。


下面将以获取HTTP请求/响应时的数据接收时、请求头接收时、数据传输完成时等详细信息为例，进行介绍。


实现思路


通过配置TracingConfiguration中的参数，来捕获HTTP请求/响应时的详细信息。


核心代码


```less
// 定义自定义响应处理程序
const customHttpEventsHandler: rcp.HttpEventsHandler = {
  onDataReceive: (incomingData: ArrayBuffer) => {
    // 用于处理传入数据的自定义逻辑
    Logger.info('Received data:', JSON.stringify(incomingData));
    return incomingData.byteLength;
  },
  onHeaderReceive: (headers: rcp.RequestHeaders) => {
    // 处理响应头的自定义逻辑
    Logger.info('Received headers:', JSON.stringify(headers));
  },
  onDataEnd: () => {
    // 用于处理数据传输完成的自定义逻辑
    Logger.info('Data transfer complete');
  }
};


// 配置跟踪设置
const tracingConfig: rcp.TracingConfiguration = {
  verbose: true,
  infoToCollect: {
    incomingHeader: true, // 收集传入的header信息事件
    outgoingHeader: true, // 收集传出的header信息事件
    incomingData: true, // 收集传入数据信息事件
    outgoingData: true // 收集传出数据信息事件
  },
  collectTimeInfo: true,
  httpEventsHandler: customHttpEventsHandler
};
const securityConfig: rcp.SecurityConfiguration = {
  tlsOptions: {
    tlsVersion: 'TlsV1.3'
  }
};
// 创建通信会话对象，并传入相关配置
const session = rcp.createSession({ requestConfiguration: { tracing: tracingConfig, security: securityConfig } });
session.get('http://developer.huawei.com').then((response) => {
  Logger.info(`Request succeeded, message is ${JSON.stringify(response)}`);
}).catch((err: BusinessError) => {
  Logger.error(`err: err code is ${err.code}, err message is ${JSON.stringify(err)}`);
});
```


本文主要介绍了基于RCP实现基础的网络请求、多表单提交、双向证书校验、DNS相关设置、请求与响应拦截、HTTP请求期间捕获详细的跟踪信息等。

- 调用rcp.createSession()创建通信会话对象，实现基础的网络请求能力。
- 对标HTTP的能力，通过new rcp.MultipartForm()可实现多表单提交的场景。
- 双向证书校验：用于验证服务端和客户端之间的身份和数据完整性，确保通信的安全性。
- 给HTTP请求配置域名系统（DNS），包括自定义DNS服务器、自定义静态DNS规则和配置HTTPS上的DNS。
- 定义拦截器对象实现高性能网络资源加载。
- 使用rcp.TracingConfiguration进行相关配置，在会话中的HTTP请求期间捕获详细的跟踪信息。

示例代码

- 基于RCP的网络请求能力

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-network-management
爬取时间: 2025-05-08 03:35:04
来源: Huawei Developer


概述


本章主要介绍了网络管理中网络连接管理、网络信息查询和网络状态监听等。

- 网络连接管理主要包括蜂窝网络和WiFi网络的连接管理，用户可以自行选择使用蜂窝网络或是使用WiFi网络。
- 网络信息查询主要针对蜂窝网络和WiFi网络的相关信息查询。
- 网络状态监听主要包含判断当前环境下网络是否可用以及是否处于弱网环境等情况。

在需要使用网络时，通常有两种选择：蜂窝网络或WiFi网络。当成功连接蜂窝网络或WiFi网络后，若应用需要区分当前连接的具体网络类型，可通过网络连接管理功能进行查询。当使用场景发生变化时，需要对网络状态进行监听，如查询当前网络是否可用、判断网络质量的优劣等，并据此做出切换网络或提示用户等操作，从而提升用户体验。


本文章是为了帮助开发者了解网络管理中常用的查询方式：

- 获取当前网络连接类型
- 判断当前网络是否可用
- 查询网络路由信息、网络链路信息
- 获取网络状态，包括蜂窝和WiFi等网络状态
- 查询蜂窝和WiFi使用相关的信息

帮助开发者了解如何进行网络状态变化的监听：

- 监听网络可用与丢失
- 监听弱网环境

网络管理


查询网络连接信息


获取当前网络连接类型


当需要判断当前使用的网络是蜂窝或者WiFi时，可以通过以下步骤实现：

1. 

```less
import { connection } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
```


核心代码


```less
getNetworkConnectionType() {
  try {
    let netHandle = connection.getDefaultNetSync();
    if (!netHandle || netHandle.netId === 0) {
      return;
    }
    let netCapability = connection.getNetCapabilitiesSync(netHandle);
    console.log('bearerTypes:', JSON.stringify(netCapability.bearerTypes));
  } catch (e) {
    let err = e as BusinessError;
    console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
  }
}
```


判断当前网络是否可用


使用网络前，例如打开一个应用时，需要检查当前连接的网络是否可用。如果可用，则正常进行网络请求；如果不可用，则需要提示用户网络不可用。判断当前连接的网络是否可用，可以通过以下步骤实现：


核心代码


```typescript
judgeHasNet(): boolean {
  try {
    let netHandle = connection.getDefaultNetSync();
    if (!netHandle || netHandle.netId === 0) {
      return false;
    }
    let netCapability = connection.getNetCapabilitiesSync(netHandle);
    let cap = netCapability.networkCap || [];
    if (cap.includes(connection.NetCap.NET_CAPABILITY_VALIDATED)) { 
      //connection.NetCap.NET_CAPABILITY_VALIDATED，该值代表网络是通的，能够发起HTTP和HTTPS的请求。
      // 网络信息变化，网络可用
      return true;
    } else {
      // 网络信息变化，网络不可用
      return false;
    }
  } catch (e) {
    let err = e as BusinessError;
    console.error("JudgeHasNet" + JSON.stringify(err));
  }
  return false;
}
```


查询网络路由信息、网络链路信息


当需要进行网络故障诊断、网络性能优化、考虑网络安全需求时，需要查询网络路由信息、网络链路信息等，可以通过以下步骤实现：


核心代码


```less
getRouteInfoAndLinkAddress() {
  connection.getDefaultNet().then((netHandle: connection.NetHandle) => {
    if (!netHandle || netHandle.netId === 0) {
      // 当前无默认网络时，获取的netHandler的netId为0，属于异常场景，此处可以实际情况自行添加一些处理机制。
      return;
    }
    connection.getConnectionProperties(netHandle, (error: BusinessError, data: connection.ConnectionProperties) => {
      if (error) {
        console.error(`Failed to get connection properties. Code:${error.code}, message:${error.message}`);
        return;
      }
      console.info("Succeeded to get data: " + JSON.stringify(data));
      let routeInfo = data.routes;
      let linkAddress = data.linkAddresses;
      console.info("routeInfo is: " + JSON.stringify(routeInfo));
      console.info("linkAddress is: " + JSON.stringify(linkAddress));
    })
  });
}
```


查询当前网络信息


蜂窝网络查询


下面将介绍蜂窝网络的相关查询，主要包括获取网络状态、查询当前网络是3G/4G/5G和判断主卡的Radio是否打开等。


获取网络状态


当需要查询手机卡注册网络的运营商名称、是否处于漫游状态、设备的网络注册状态等信息时，可以通过以下步骤实现：

1. 

```less
import { radio } from '@kit.TelephonyKit';
import { BusinessError } from '@kit.BasicServicesKit';
```


核心代码


```less
getNetworkStatus(){
  radio.getNetworkState((err: BusinessError, data: radio.NetworkState) => {
    if (err) {
      console.error(`getNetworkState failed, callback: err->${JSON.stringify(err)}`);
      return;
    }
    console.log(`getNetworkState success, callback: data->${JSON.stringify(data)}`);
  });
}
```


查询当前网络是3G/4G/5G


视频播放应用在5G网络下可以默认加载超高清视频，以充分利用高速带宽；在4G网络下加载高清视频；而在3G网络下，为了避免卡顿，可能只加载标清视频。如何控制加载对应清晰度的视频，就需要查询当前网络是3G/4G/5G，可以通过以下步骤实现：


signalType的值对应网络类型如下：


| 值  | 网络类型  |
| --- | --- |
| GSM  | 2G  |
| CDMA  | 2G  |
| WCDMA  | 3G  |
| TDSCDMA  | 3G  |
| LTE  | 4G  |
| NR  | 5G  |

值


网络类型


GSM


2G


CDMA


2G


WCDMA


3G


TDSCDMA


3G


LTE


4G


NR


5G


核心代码


```typescript
getSignalType(){
  let slotId: number = 0;
  radio.getSignalInformation(slotId, (err: BusinessError, data: Array<radio.SignalInformation>) => {
    if (err) {
      console.error(`getSignalInformation failed, callback: err->${JSON.stringify(err)}`);
      return;
    }
    console.log(`getSignalInformation success, callback: data->${JSON.stringify(data)}`);
    let signalType = data[0].signalType;
    console.log(`signalType is: ${signalType}`);
  });
}
```


判断主卡的Radio是否打开


当用户在国外或者其他运营商的网络覆盖区域时，主卡Radio打开可能会导致手机自动连接到其他网络并产生漫游费用。因此，判断主卡Radio的状态可以让用户提前做好防范措施。判断主卡的Radio是否打开，可以通过以下步骤实现：


核心代码


```typescript
getRadioStatus(){
  radio.isRadioOn((err: BusinessError, data: boolean) => {
    if (err) {
      console.error(`isRadioOn failed, callback: err->${JSON.stringify(err)}`);
      return;
    }
    console.log(`isRadioOn success, callback: data->${JSON.stringify(data)}`);
  });
}
```


WiFi查询


下面将介绍WiFi网络的相关查询，主要包括查询WLAN是否已使能、查询WLAN是否已连接、获取扫描到的热点列表、获取当前连接WiFi的信号强度和添加候选网络配置等。


查询WLAN是否已使能


查询WLAN是否已使能，可以帮助用户快速了解自己是否可以使用WiFi网络进行连接。并且当WiFi跟蜂窝同时存在时，有助于实现网络连接的无缝切换。查询WLAN是否已使能，可以通过以下步骤实现：

1. 

```less
import { wifiManager } from '@kit.ConnectivityKit';
```


核心代码


```less
getWifiStatus() {
  try {
    let isWifiActive = wifiManager.isWifiActive();
    console.info("isWifiActive:" + isWifiActive);
  } catch (error) {
    console.error("failed:" + JSON.stringify(error));
  }
}
```


查询WLAN是否已连接


查询WLAN是否已连接是判断能否通过WiFi 进行各种网络活动的直接方式。只有在 WLAN 连接成功后，用户才能利用 WiFi网络的带宽优势进行诸如高清视频播放、大文件下载、在线游戏等对网络带宽和稳定性要求较高的操作。查询WLAN是否已连接，可以通过以下步骤实现：


核心代码


```less
getWifiIsConnected() {
  try {
    let ret = wifiManager.isConnected();
    console.info("isConnected:" + ret);
  } catch (error) {
    console.error("failed:" + JSON.stringify(error));
  }
}
```


获取扫描到的热点列表


当用户想连接热点时，就需要通过获取扫描到的热点列表来查找对应热点。获取扫描到的热点列表，可以通过以下步骤实现：


核心代码


```less
getScanInfoList() {
  try {
    let scanInfoList = wifiManager.getScanInfoList();
    console.info("scanInfoList:" + JSON.stringify(scanInfoList));
  } catch (error) {
    console.error("failed:" + JSON.stringify(error));
  }
}
```


获取当前连接WiFi的信号强度


在下载大文件或观看高清视频时，如果WiFi信号强度不足，可能会导致下载速度缓慢、视频卡顿等问题。通过获取信号强度，用户可以初步判断当前网络是否能够满足其对速度的需求。获取当前连接WiFi的信号强度，可以通过以下步骤实现：


核心代码


```less
getSignalLevel() {
  try {
    let rssi = 0;
    let band = 0;
    let level = wifiManager.getSignalLevel(rssi, band);
    console.info("level:" + JSON.stringify(level));
  } catch (error) {
    console.error("failed:" + JSON.stringify(error));
  }
}
```


添加候选网络配置


添加候选网络配置可以让设备在当前连接的网络出现问题（如信号丢失、网络故障等）或者用户离开当前网络覆盖范围时，自动尝试连接其他预先配置的候选网络。添加候选网络配置，可以通过以下步骤实现：


核心代码


```typescript
addCandidateConfig() {
  try {
    let config: wifiManager.WifiDeviceConfig = {
      ssid: "****",
      preSharedKey: "****",
      securityType: 0
    }
    wifiManager.addCandidateConfig(config).then(result => {
      console.info("result:" + JSON.stringify(result));
    }).catch((err: number) => {
      console.error("failed:" + JSON.stringify(err));
    });
  } catch (error) {
    console.error("failed:" + JSON.stringify(error));
  }
}
```


网络状态监听


监听网络可用与丢失


在日常使用网络中，当使用WiFi或者蜂窝时，如果信号良好，且手机、电脑、平板等可以顺利连接到网络，并进行在线视频播放、浏览网页、下载文件等操作，这些就是网络可用的典型场景。


而设备故障、信号干扰、网络拥堵、网络服务提供商的服务器故障、维护或升级都可能会导致网络丢失。为了提升用户上网体验，就需要对网络是否可用、网络是否丢失等进行监听，然后做出相应的处理。


网络连接管理中提供了对网络状态监听的方法，开发时定义了相关的监听方法后，在不同场景下会触发不同的事件，如：

- on('netAvailable')：订阅网络可用事件，当网络可用时触发该事件。
- on('netBlockStatusChange')：订阅网络阻塞状态事件，当网络阻塞时，如网络性能下降、数据传输出现延迟等情况时，会触发该事件。
- on('netCapabilitiesChange')：订阅网络能力变化事件，当网络能力变化时，如网络从无网络到有网络、从4G切换到5G时，会触发该事件。
- on('netConnectionPropertiesChange')：订阅网络连接信息变化事件，当网络连接信息变化时，如从无网络到有网络、从WiFi切换到蜂窝时，会触发该事件。
- on('netLost')：订阅网络丢失事件，当网络严重中断或正常断开时触发该事件。
- on('netUnavailable')：订阅网络不可用事件，当网络不可用时触发该事件。

网络丢失和网络不可用并非是一个概念，网络丢失和网络不可用的区别如下：

- 网络丢失是指网络严重中断或正常断开事件，当断开WiFi时，是属于正常断开网络连接，会触发netLost事件。
- 网络不可用是指网络不可用事件，当连接的网络不能使用时，会触发netUnavailable事件。

在播放视频时，可能会遇到无网络的情况，此时需要监听网络是否可用或者丢失，来实现对视频无网络时暂停、有网络时自动播放的能力，提升用户播放视频时的体验。通过注册监听网络相关变化，注册监听步骤如下：


核心代码


```less
networkListen() {
  this.netCon = connection.createNetConnection();
  this.netCon.register((error: BusinessError) => {
    if (error) {
      console.log('networkListen fail' + JSON.stringify(error))
      return;
    }
  });


  this.netCon.on('netAvailable', (data: connection.NetHandle) => {
    console.info("Succeeded to get netAvailable: " + JSON.stringify(data));
    if (connection.hasDefaultNetSync()) {
      if (this.networkPause) {
        this.controller?.start();
        this.networkPause = false;
      }
    }
  });


  // 订阅网络丢失事件
  this.netCon.on('netLost', (data: connection.NetHandle) => {
    if (connection.getAllNetsSync().length == 0) {
      this.controller?.pause();
      this.networkPause = true;
    }
    console.info("Succeeded to get netLost: " + JSON.stringify(data));
  });


  this.netCon.on('netCapabilitiesChange', (data: connection.NetCapabilityInfo) => {
    console.info("Succeeded to get netCapabilitiesChange: " + JSON.stringify(data));
  });


  this.netCon.on('netUnavailable', () => {
    console.info("Succeeded to get unavailable net event");
  });
}
```


```less
aboutToDisappear(): void {
  this.netCon?.unregister((error: BusinessError) => {
    console.log(JSON.stringify(error));
  });
}
```


connection.createNetConnection()方法中有两个可选传入参，netSpecifier和timeout。其中netSpecifier指定关注的网络的各项特征；timeout是超时时间(单位是毫秒)；netSpecifier是timeout的必要条件，两者都没有则表示关注默认网络。


播放视频可使用Video组件实现，如果开发者想自定义视频播放，请参考视频播放。


```less
@Component
export struct VideoPlayer{
  private controller:VideoController | undefined;
  @State videoSrc: string= 'https://www.example.com/example.mp4' // 使用时请替换为实际视频加载网址
  build(){
    Column() {
      Video({
        src: this.videoSrc,
        controller: this.controller
      })
    }
  }
}
```


当网络不可用时，调用暂停方法，暂停视频播放。


```less
this.controller?.pause();
```


有网络后，调用播放方法，开始视频播放。


```less
this.controller?.start();
```


上述过程中可能会涉及到WiFi切换，当需要判断WiFi是否切换，需要监听WLAN状态改变事件和WLAN连接状态改变事件，步骤如下：


核心代码


```typescript
wifiChangeListen() {
  this.netCon = connection.createNetConnection({
    netCapabilities: {
      bearerTypes: [connection.NetBearType.BEARER_WIFI]
    }
  });
  // 先使用register接口注册订阅事件
  this.netCon.register((error: BusinessError) => {
    console.log(JSON.stringify(error));
  });


  // 订阅网络可用事件。调用register后，才能接收到此事件通知
  this.netCon.on('netAvailable', (data: connection.NetHandle) => {
    console.info("WifiChangeListen-- Succeeded to get data: " + JSON.stringify(data));
  });


  // 订阅网络丢失事件。调用register后，才能接收到此事件通知
  this.netCon.on('netLost', (data: connection.NetHandle) => {
    console.info("WifiChangeListen-- Succeeded to get data: " + JSON.stringify(data));
  });


  let recvPowerNotifyFunc = (result: number) => {
    console.info("WifiChangeListen-- Receive power state change event: " + result);
  }
  let recvWifiConnectionChangeFunc = (result: number) => {
    console.info("WifiChangeListen-- Receive wifi connection change event: " + result);
  }


  // 注册事件
  wifiManager.on("wifiStateChange", recvPowerNotifyFunc);
  wifiManager.on("wifiConnectionChange", recvWifiConnectionChangeFunc);
}
```


其中状态改变事件的枚举：


| 枚举值  | 说明  |
| --- | --- |
| 0  | 未激活。  |
| 1  | 已激活。  |
| 2  | 激活中。  |
| 3  | 去激活中。  |

枚举值


说明


0


未激活。


1


已激活。


2


激活中。


3


去激活中。


连接状态改变事件的枚举：


| 枚举值  | 说明  |
| --- | --- |
| 0  | 已断开。  |
| 1  | 已连接。  |

枚举值


说明


0


已断开。


1


已连接。


设备从无网络到有网络会触发netAvailable事件、netCapabilitiesChange事件和netConnectionPropertiesChange事件；


设备从有网络到无网络状态会触发netLost事件；


设备从WiFi切换到蜂窝会先触发netLost事件（WiFi丢失），之后触发 netAvailable事件（蜂窝可用）。


弱网下网络切换


在播放视频时，可能会遇到弱网的环境，如乘坐高铁时、人员密集的场所等。这个时候需要监听网络状态以及网络质量，来实现提示用户进行网络切换或者对视频的清晰度做出相应调整，如：


1）在WiFi弱信号的情况下，默认网络可能会切换到蜂窝网络。


2）在蜂窝网络弱信号的情况下，默认网络会优先切换到WiFi。


3）在网络质量低的环境下，自动降低并切换视频的清晰度。


判断是否是弱网环境的步骤如下：

1. 

```less
import { BusinessError } from '@kit.BasicServicesKit';
import { netQuality } from '@kit.NetworkBoostKit';
```


核心代码


```less
sceneChangeListen() {
  try {
    netQuality.on('netSceneChange', (list: Array<netQuality.NetworkScene>) => {
      if (list.length > 0) {
        list.forEach((networkScene) => {
          // 回调信息处理
          console.info(`Succeeded receive netSceneChange info`);
          if (networkScene.scene == 'weakSignal' || networkScene.scene == 'congestion') {
            // 表示为弱网场景
            console.info(`The current network is weak`);
            this.networkWeak();
          }
        });
      }
    });
  } catch (err) {
    console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
  }
}
```


```less
networkWeak() {
  promptAction.showToast({
    message: '当前处于弱网环境，建议您切换网络',
    duration: 2000
  });
}
```


判断是否为弱网可以通过下面3种方式：


```less
if (networkScene.scene == 'weakSignal' || networkScene.scene == 'congestion' ) {
  // 表示为弱网场景
}
```


```less
if (networkScene.weakSignalPrediction) {
  // 弱信号预测处理
}
```

-  根据网络质量评估信息，如NetworkQos(linkUpBandwidth/linkDownBandwidth/rttMs/linkUpBufferDelayMs/linkUpBufferCongestionPercent)，应用自定义门限来判决为弱网。

在弱网环境下，可以使用网络连接迁移能力，在通过系统发起多网迁移（WiFi<->蜂窝，主卡<->副卡等）的过程中，给应用提供连接迁移开始和完成通知，应用可根据连接迁移通知的建议进行重建，给用户带来平滑、高速、低时延的上网体验。

1. 

```less
import { BusinessError } from '@kit.BasicServicesKit';
import { netHandover } from '@kit.NetworkBoostKit';
```


核心代码


```less
handoverChangeListen(){
  try {
    netHandover.on('handoverChange', (info: netHandover.HandoverInfo) => {
      if (info.handoverStart) {
        // 连接迁移开始回调，应用按照HandoverStart的建议调整数传策略
        console.info('handover start');
      } else if (info.handoverComplete) {
        // 连接迁移完成回调，应用按照HandoverComplete的建议进行调速和重建恢复
        console.info('handover complete');
      }
    });
  } catch (err) {
    console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
  }
}
```


视频播放时，还可以通过判断当前网络质量来对视频的清晰度进行调整。若网络质量低，则切换视频到较低的清晰度。

1. 

```less
import { BusinessError } from '@kit.BasicServicesKit';
import { netQuality } from '@kit.NetworkBoostKit';
```


核心代码


```typescript
netQualityListen() {
  try {
    netQuality.on('netQosChange', (list: Array<netQuality.NetworkQos>) => {
      if (list.length > 0) {
        list.forEach((qos) => {
          // 回调信息处理
          console.info(`Succeeded receive netQosChange info`);
          let lowNetQuality: boolean = false;
          // 根据网络质量的相关信息，判断当前网络质量的高低。此处逻辑需要自定义实现，如果是低质量，则lowNetQuality为true。
          // 如果网络质量低，则切换视频清晰度。
          if(lowNetQuality){
            this.toggleLowDefinition();
          }
        });
      }
    });
  } catch (err) {
    console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
  }
}
```


```less
toggleLowDefinition(){
  this.innerResource = 'https://www.example.com/example_low_definition.mp4';
}
```


示例代码


网络管理与状态监听


URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-bluetooth-low-energy
爬取时间: 2025-05-08 03:35:11
来源: Huawei Developer


概述


蓝牙（Bluetooth）是一种无线通信技术，被广泛应用于各种电子设备之间的短距离数据传输和连接。而低功耗蓝牙（Bluetooth Low Energy，简称 BLE）是一种能够在低功耗情况下进行通信的蓝牙技术。与传统蓝牙相比，BLE的功耗更低，适用于需要长时间运行的低功耗设备，如智能手表、健康监测设备、智能家居等。


本文适用于低功耗蓝牙通信相关的开发，主要介绍了基于BLE进行蓝牙扫描管理、蓝牙连接状态管理、蓝牙设备特征值同步三个场景，并分别从服务端和客户端描述其相关实现。


实现原理


实现低功耗蓝牙通信的能力主要步骤如下：


首先服务端需要创建实例，成功创建后，需要添加对应服务，才能开启BLE广播，向客户端传递相关信息。当服务端开启BLE广播后，还需要订阅BLE连接状态，即对连接状态进行监听。当连接状态变化时，如断开连接，则此时需要关闭BLE广播。在服务端接收到客户端发起的连接请求和发起的特征值订阅请求后，才能向客户端传递特征值信息。


而客户端同样需要创建实例，并获取相关服务，才能通过蓝牙扫描到服务端，并发起连接请求和特征值订阅请求。客户端也需要监听连接状态，当断开连接时，关闭对应的监听能力。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153220.87625120502486134419803299903575:50001231000000:2800:EAA33B44BB2759E40AEF272CEA956DFE1CB70391E31B2EE98310D917F79BAF46.png)

关键技术


实现低功耗蓝牙通信能力需要使用@ohos.bluetooth.ble (蓝牙ble模块)中提供的API能力，服务端使用的API主要包括创建服务器实例、发送BLE广播、特征值变化通知等；客户端使用的API主要包括蓝牙连接、订阅蓝牙低功耗设备的特征值变化、订阅蓝牙低功耗设备的连接状态变化事件等。


开发流程


在需要使用低功耗蓝牙进行通信的场景中：


服务端


客户端


蓝牙扫描管理


场景描述


BLE扫描主要分为被动扫描和主动扫描两种模式。被动扫描是指设备监听周围的广播信息，不主动发起连接请求；而主动扫描则会在接收到广播的同时，向广播设备发送扫描请求，以获取更详尽的设备信息。


蓝牙扫描管理是在主动扫描中，对扫描出的结果进行管理。主动扫描时，不仅可以设置扫描参数，还能处理扫描结果。如扫描时设置扫描时间间隔、扫描持续时间等；扫描出结果后，可对设备列表更新，并过滤相关设备信息。


实现原理


蓝牙扫描步骤如下：


首先服务端需要检查蓝牙状态，如未开启蓝牙，则需要向用户申请开启蓝牙；如已开启，则开启广播。然后客户端也需要检查蓝牙状态，如未开启蓝牙，则需要向用户申请开启蓝牙；如已开启，则设置扫描参数，并启动蓝牙扫描。根据扫描结果来处理相关设备信息并展示，然后主动发起蓝牙连接请求，连接远端设备。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153220.84945082828373153448752269791596:50001231000000:2800:5830D29E84B3A8E365E719BCF49B7640CD3E2FD9702B64D051F675262B4C5F27.png)

关键技术


服务端：


客户端：


实现流程


服务端

1. 

```less
import { ble } from '@kit.ConnectivityKit';
import { access } from '@kit.ConnectivityKit';
```

2. 

```less
isBluetoothEnabled(): boolean {
  const state: access.BluetoothState = access.getState();
  if (state === access.BluetoothState.STATE_ON || state === access.BluetoothState.STATE_TURNING_ON) {
    return true;
  }
  return false;
}
```

3. 

```less
access.enableBluetooth();
```

4. 

```less
startAdvertiser(): boolean {
  if (!this.isBluetoothEnabled()) {
    this.enableBluetooth();
    promptAction.showToast({
      message: 'Bluetooth enabled, please wait...',
      duration: 2000
    })
    return false;
  }
  // Create a GattServer instance
  this.mGattServer = ble.createGattServer();


  // ...


  // Define the heart rate beating service
  const service: ble.GattService = {
    serviceUuid: '0000180D-0000-1000-8000-00805F9B34FB',
    isPrimary: true,
    characteristics: characteristics,
    includeServices: []
  }


  // Add a service
  this.mGattServer.addService(service);


  try {
    // The status of the subscription connection service
    this.onConnectStateChange();
    // ...


    // Start advertising
    ble.startAdvertising(setting, advData, advResponse);
    return true;
  } catch (err) {
    Logger.error(`startAdvertiser: err = ${JSON.stringify(err)}`);
  }
  return false
}
```


客户端

1. 

```less
import { ble } from '@kit.ConnectivityKit';
```

2. 

```less
startBLEScan(): boolean {
  if (!this.isBluetoothEnabled()) {
    this.enableBluetooth();
    promptAction.showToast({
      message: 'Bluetooth enabled, please wait...',
      duration: 2000
    })
    return false;
  }
  this.onBLEDeviceFind();
  const ret = this.startBLEScanInner();
  return ret;
}
```

3. 

```less
connectInner(gattClientDevice: ble.GattClientDevice): boolean {
  try {
    if (!gattClientDevice) {
      return false;
    }
    // The subscription connection status changes
    this.onBLEConnectionStateChange();
    // Subscription feature value changes
    this.onBLECharacteristicChange();
    // Start connecting
    gattClientDevice.connect();
    this.mConnectBluetoothDevice.connectionState = ConnectionState.STATE_CONNECTING;
    AppStorage.setOrCreate('connectBluetoothDevice', this.mConnectBluetoothDevice);
    return true;
  } catch (err) {
    Logger.error(`connectInner: err = ${JSON.stringify(err)}`);
  }
  return false;
}
```


蓝牙连接状态管理


蓝牙连接状态管理可实时监测蓝牙连接的质量，包括信号强度、数据传输速率、误码率等指标。在蓝牙设备连接后，经常会遇到服务端、客户端连接状态改变的情况，例如客户端连接后，服务端关闭广播导致连接断开。针对此问题，在进行蓝牙设备开发的时候，需要对蓝牙的连接进行管理。


实现原理


在服务端与客户端进行连接的相关操作时，注册对应的监听事件。如监听蓝牙设备开关状态、监听蓝牙状态变化等。当对应状态发生变化时，即可通过回调函数来处理相应逻辑。


关键技术


服务端：


1.调用on('stateChange')方法订阅蓝牙设备开关状态事件。


2.调用on('connectionStateChange')方法订阅蓝牙状态变化事件。


客户端：


1.订阅蓝牙设备开关状态事件，与服务端步骤1一致。


2.调用on('BLEConnectionStateChange')订阅蓝牙低功耗设备的连接状态变化事件。


实现流程


服务端

1. 

```less
import { ble } from '@kit.ConnectivityKit';
import { access } from '@kit.ConnectivityKit';
```

2.  （1）根据蓝牙的状态BluetoothState进行处理，如果当前蓝牙开启，AppStorage存储当前蓝牙状态为true，表示蓝牙可用，并开启广播。

```less
onBTStateChange() {
  try {
    access.on('stateChange', (data: access.BluetoothState) => {
      if (data === access.BluetoothState.STATE_ON) {
        AppStorage.setOrCreate('bluetoothEnable', true);
      } else if (data === access.BluetoothState.STATE_OFF) {
        AppStorage.setOrCreate('bluetoothEnable', false);
      }
    })
  } catch (err) {
    Logger.error(`onBTSateChange: err = ${JSON.stringify(err)}`);
  }
}
```

3.  （1）根据连接状态设置连接设备ID。

```less
onConnectStateChange() {
  if (!this.mGattServer) {
    return;
  }


  try {
    this.mGattServer.on('connectionStateChange', (data: ble.BLEConnectionChangeState) => {
      if (data) {
        if (data.state === constant.ProfileConnectionState.STATE_CONNECTED) {
          let deviceId = data.deviceId;
          AppStorage.setOrCreate('deviceId', deviceId);
        } else if (data.state === constant.ProfileConnectionState.STATE_DISCONNECTED) {
          AppStorage.setOrCreate('deviceId', '');
          this.stopAdvertiser();
        }
      }
    })
  } catch (err) {
    Logger.error(`connectInner: err = ${JSON.stringify(err)}`);
  }
}
```


客户端

1. 

```less
import { ble } from '@kit.ConnectivityKit';
import { access } from '@kit.ConnectivityKit';
```

2.  （1）根据蓝牙的状态BluetoothState进行处理，如果当前蓝牙开启，则发起BLE扫描流程。

```less
onBTStateChange() {
  try {
    access.on('stateChange', (data: access.BluetoothState) => {
      if (data === access.BluetoothState.STATE_ON) {
        this.startBLEScan();
      } else if (data === access.BluetoothState.STATE_OFF) {
        this.mAvailableDevices = [];
        AppStorage.setOrCreate('availableDevices', this.mAvailableDevices);
      }
    })
  } catch (err) {
    Logger.error(`onBTSateChange: err = ${JSON.stringify(err)}`);
  }
}
```

3. 

```less
onBLEConnectionStateChange() {
  if (!this.mGattClientDevice) {
    return;
  }


  try {
    this.mGattClientDevice.on('BLEConnectionStateChange', async (data: ble.BLEConnectionChangeState) => {


      let state: constant.ProfileConnectionState = data.state;
      if (data) {
        if (state === constant.ProfileConnectionState.STATE_CONNECTED) {
          this.mConnectBluetoothDevice.connectionState = ConnectionState.STATE_CONNECTED;
          AppStorage.setOrCreate('availableDevices', this.mAvailableDevices);
          // The connection is successful, and the service is obtained
          let services: Array<ble.GattService> | undefined = await this.mGattClientDevice?.getServices();
          let service: ble.GattService | undefined =
            services?.find(item => item.serviceUuid === '0000180D-0000-1000-8000-00805F9B34FB')
          let characteristics: Array<ble.BLECharacteristic> | undefined = service?.characteristics;
          let characteristic: ble.BLECharacteristic | undefined =
            characteristics?.find(item => item.characteristicUuid === '00002A37-0000-1000-8000-00805F9B34FB');
          // Sends a setup notification request for this feature value to the server
          this.mGattClientDevice?.setCharacteristicChangeNotification(characteristic, true);
          let descriptors: Array<ble.BLEDescriptor> | undefined = characteristic?.descriptors;
          let descriptor = descriptors?.find(item => item.descriptorUuid === '00002902-0000-1000-8000-00805F9B34FB')
          let descriptorValue = ArrayBufferUtils.byteArray2ArrayBuffer([0x01, 0x00]);
          let descriptorObj: BLEDescriptor = {
            serviceUuid: descriptor?.serviceUuid,
            characteristicUuid: descriptor?.characteristicUuid,
            descriptorValue: descriptorValue,
            descriptorUuid: descriptor?.descriptorUuid
          }
          // Writes binary data to a Bluetooth Low energy device-specific descriptor
          this.mGattClientDevice?.writeDescriptorValue(descriptorObj);
        } else if (state === constant.ProfileConnectionState.STATE_DISCONNECTED) {
          this.mConnectBluetoothDevice.connectionState = ConnectionState.STATE_DISCONNECTED;
          AppStorage.setOrCreate('availableDevices', []);
          if (this.getConnectionState() === ConnectionState.STATE_CONNECTING) {
            this.close();
          } else if (this.getConnectionState() === ConnectionState.STATE_CONNECTED ||
            this.getConnectionState() === ConnectionState.STATE_DISCONNECTING) {
            this.close();
          }
        }
      }
    })
  } catch (err) {
    Logger.error(`onBLEConnectionStateChange: err = ${JSON.stringify(err)}`);
  }
}
```


蓝牙设备特征值同步


在低功耗蓝牙通信中，特征值是数据的基本单元，它是一种用于存储或传输特定类型数据的实体。许多蓝牙设备需要实时传输数据，如运动传感器将加速度、陀螺仪等数据传输到手机应用。如果特征值不同步，数据可能会出现延迟、丢失或者错误的顺序，导致接收端（如手机应用）无法准确地对运动状态进行分析，像在运动步数统计中，可能会少计或多计步数。


实现原理


在服务端与客户端连接成功后，服务端通过调用相关接口，主动通知客户端特征值发生变化；而客户端需要调用接口向服务端来订阅特征值变化，当特征值变化时，客户端即可接收到相关变化信息。


关键技术


服务端：


1.调用notifyCharacteristicChanged方法主动通知已连接的客户端设备，特征值变化。


客户端：


1.调用setCharacteristicChangeNotification接口向服务端发送设置通知此特征值请求。


2.调用on('BLECharacteristicChange')订阅蓝牙低功耗设备的特征值变化事件。


（1）根据UUID对服务进行过滤，获取服务特征值配置。


（2）调用setCharacteristicChangeNotification，向服务端发送设置通知此特征值请求。


（3）调用writeDescriptorValue，向低功耗蓝牙设备特定的描述符写入二进制数据。


实现流程


服务端

1. 

```less
import { ble } from '@kit.ConnectivityKit';
```

2. 

```less
notifyCharacteristicChanged(deviceId: string, heartRate: number) {
  if (!deviceId) {
    return;
  }
  if (this.mGattServer) {
    try {
      let descriptors: Array<ble.BLEDescriptor> = [];
      let arrayBuffer = ArrayBufferUtils.byteArray2ArrayBuffer([11]);
      // Define descriptors
      let descriptor: ble.BLEDescriptor = {
        serviceUuid: '0000180D-0000-1000-8000-00805F9B34FB',
        characteristicUuid: '00002A37-0000-1000-8000-00805F9B34FB',
        descriptorUuid: '00002902-0000-1000-8000-00805F9B34FB',
        descriptorValue: arrayBuffer
      }
      descriptors[0] = descriptor;


      let arrayBufferC = ArrayBufferUtils.byteArray2ArrayBuffer([0x00, heartRate]);
      // Define characteristic
      let characteristic: CharacteristicModel = {
        serviceUuid: '0000180D-0000-1000-8000-00805F9B34FB',
        characteristicUuid: '00002A37-0000-1000-8000-00805F9B34FB',
        characteristicValue: arrayBufferC,
        descriptors: descriptors
      }


      // Define notifyCharacteristic
      let notifyCharacteristic: NotifyCharacteristicModel = {
        serviceUuid: '0000180D-0000-1000-8000-00805F9B34FB',
        characteristicUuid: '00002A37-0000-1000-8000-00805F9B34FB',
        characteristicValue: characteristic.characteristicValue,
        confirm: false
      }


      // Notifies the connected client of the change of the feature value
      this.mGattServer.notifyCharacteristicChanged(deviceId, notifyCharacteristic, (err: BusinessError) => {
        if (err) {
          Logger.error(`notifyCharacteristicChanged callback failed: err = ${JSON.stringify(err)}`);
        } else {
          Logger.info('notifyCharacteristicChanged callback success')
        }
      })
    } catch (err) {
      Logger.error(`notifyCharacteristicChanged: err = ${JSON.stringify(err)}`);
    }
  }
}
```


客户端

1. 

```less
import { ble } from '@kit.ConnectivityKit';
```

2. 

```less
onBLEConnectionStateChange() {
  if (!this.mGattClientDevice) {
    return;
  }


  try {
    this.mGattClientDevice.on('BLEConnectionStateChange', async (data: ble.BLEConnectionChangeState) => {


      let state: constant.ProfileConnectionState = data.state;
      if (data) {
        if (state === constant.ProfileConnectionState.STATE_CONNECTED) {
          this.mConnectBluetoothDevice.connectionState = ConnectionState.STATE_CONNECTED;
          AppStorage.setOrCreate('availableDevices', this.mAvailableDevices);
          // The connection is successful, and the service is obtained
          let services: Array<ble.GattService> | undefined = await this.mGattClientDevice?.getServices();
          let service: ble.GattService | undefined =
            services?.find(item => item.serviceUuid === '0000180D-0000-1000-8000-00805F9B34FB')
          let characteristics: Array<ble.BLECharacteristic> | undefined = service?.characteristics;
          let characteristic: ble.BLECharacteristic | undefined =
            characteristics?.find(item => item.characteristicUuid === '00002A37-0000-1000-8000-00805F9B34FB');
          // Sends a setup notification request for this feature value to the server
          this.mGattClientDevice?.setCharacteristicChangeNotification(characteristic, true);
          let descriptors: Array<ble.BLEDescriptor> | undefined = characteristic?.descriptors;
          let descriptor = descriptors?.find(item => item.descriptorUuid === '00002902-0000-1000-8000-00805F9B34FB')
          let descriptorValue = ArrayBufferUtils.byteArray2ArrayBuffer([0x01, 0x00]);
          let descriptorObj: BLEDescriptor = {
            serviceUuid: descriptor?.serviceUuid,
            characteristicUuid: descriptor?.characteristicUuid,
            descriptorValue: descriptorValue,
            descriptorUuid: descriptor?.descriptorUuid
          }
          // Writes binary data to a Bluetooth Low energy device-specific descriptor
          this.mGattClientDevice?.writeDescriptorValue(descriptorObj);
        } else if (state === constant.ProfileConnectionState.STATE_DISCONNECTED) {
          this.mConnectBluetoothDevice.connectionState = ConnectionState.STATE_DISCONNECTED;
          AppStorage.setOrCreate('availableDevices', []);
          if (this.getConnectionState() === ConnectionState.STATE_CONNECTING) {
            this.close();
          } else if (this.getConnectionState() === ConnectionState.STATE_CONNECTED ||
            this.getConnectionState() === ConnectionState.STATE_DISCONNECTING) {
            this.close();
          }
        }
      }
    })
  } catch (err) {
    Logger.error(`onBLEConnectionStateChange: err = ${JSON.stringify(err)}`);
  }
}
```

3. 

```less
onBLECharacteristicChange() {
  if (!this.mGattClientDevice) {
    return;
  }
  this.mGattClientDevice.on('BLECharacteristicChange', (data: ble.BLECharacteristic) => {
    let characteristicValue: ArrayBuffer = data.characteristicValue;
    let byteArr = ArrayBufferUtils.arrayBuffer2ByteArray(characteristicValue);
    let hearRate = byteArr[1];
    AppStorage.setOrCreate('heartRate', hearRate);
  })
}
```


常见问题


设备连接后调用getServices()获取不到数据


通过on('BLEConnectionStateChange')接口订阅连接状态，连接状态订阅中返回状态值为2的时候，表示连接成功，之后再调用getServices()获取数据。


扫描获取的deviceId与真实地址不同


基于信息安全考虑，此处获取的设备地址为随机MAC地址。配对成功后，该地址不会变更；已配对设备取消配对后重新扫描或蓝牙服务下电时，该随机地址会变更。


示例代码

- 低功耗蓝牙开发

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-rcp-file-transfer
爬取时间: 2025-05-08 03:35:20
来源: Huawei Developer


概述


Remote Communication Kit（远场通信服务）是HarmonyOS系统提供对HTTP发起数据请求的NAPI封装，通过@hms.collaboration.rcp（后续简称RCP）模块将相关能力开放给开发者。


在现代应用开发中，文件上传与下载是较为常见的需求，本文将通过对带进度的上传下载、断点续传、后台文件上传下载场景的详细讲解，为开发者提供基于RCP的文件上传与下载的开发实践。


关键技术说明


文件下载

- 推荐方式：使用RCP中提供封装好的Session.downloadToFile()方法进行文件下载，开发者只需提供下载到本地的文件地址，即可快速便捷实现下载请求。同时RCP提供Session.downloadToStream()方法实现流式下载。
- 自定义配置：若上述方法无法满足特定场景需求，开发者可使用Session.get()方法或Session.fetch()方法自行配置请求相关参数来实现文件下载。

文件上传

- 推荐方式：使用RCP中提供封装好的Session.uploadFromFile()方法进行文件上传，开发者只需提供本地要上传的文件地址，即可快速便捷实现文件上传请求。同时RCP提供Session.uploadFromStream()方法实现流式上传。
- 自定义配置：若上述方法无法满足特定场景需求，开发者可使用Session.post()方法或Session.fetch()方法自行配置请求相关参数来实现文件上传。
-  类型 可使用该类型的请求方法 对应原始http请求头和请求体类型 rcp.UploadFromFile Session.uploadFromFile()、Session.post()、Session.fetch() 请求头content-type为application/octet-stream；请求体使用binary二进制格式 rcp.UploadFromStream Session.uploadFromStream()、Session.post()、Session.fetch() 请求头content-type为application/octet-stream；请求体使用binary二进制格式 rcp.MultipartForm Session.post()、Session.fetch() 请求头content-type为multipart/form-data；请求体使用form-data格式

| 类型  | 可使用该类型的请求方法  | 对应原始http请求头和请求体类型  |
| --- | --- | --- |
| rcp.UploadFromFile  | Session.uploadFromFile()、Session.post()、Session.fetch()  | 请求头content-type为application/octet-stream；请求体使用binary二进制格式  |
| rcp.UploadFromStream  | Session.uploadFromStream()、Session.post()、Session.fetch()  | 请求头content-type为application/octet-stream；请求体使用binary二进制格式  |
| rcp.MultipartForm  | Session.post()、Session.fetch()  | 请求头content-type为multipart/form-data；请求体使用form-data格式  |

带进度的上传下载


场景描述


用户可选择服务器文件并点击下载，下载过程中能够显示下载进度。点击上传按钮，可拉起系统相册，选中相册文件并确认后，将其上传至服务器，并显示上传进度。


| 下载效果图  | 上传效果图  |
| --- | --- |
|   |   |

下载效果图


上传效果图

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153220.74523992330308321469773209924373:50001231000000:2800:9F5B65B29A59A081A540CB4CFAC7E4E7158D47387AC7833FEF6393411947C05F.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153220.69174816745438736534713237654350:50001231000000:2800:7D74459ECDFD3E037A7200B31B65A674BD4585EDEEC33230F85A9BBC534EE8C9.gif)

实现原理


关键技术

- 由于HarmonyOS系统的安全机制限制，RCP接口不能直接访问相册路径进行文件传输。可以先将相册文件拷贝到沙箱路径，然后从沙箱路径进行上传操作；下载时则可以先将文件下载到沙箱路径，再拷贝到相册文件中。
- 在创建http会话的rcp.sessionConfiguration参数类型中，可配置HTTP请求/响应过程中的特定操作，其中rcp.httpEventHandler属性可定义响应处理程序的回调函数来实现文件传输进度的监听。下载请求返回的响应头中需包含content-length字段，否则在下载进度的回调方法rcp.onDownloadProgress()中获取不到文件大小，无法计算下载进度。

下载流程


上传流程


开发步骤


在使用Remote Communication Kit相关能力前，需配置以下权限。详细参考申请权限步骤。

- ohos.permission.INTERNET：用于应用的权限，决定是否允许应用访问互联网。
- ohos.permission.GET_NETWORK_INFO：用于获取设备网络信息的 API 。

为避免在每个RCP发起请求的响应中重复判断状态码和处理异常情况，可利用rcp.Interceptor提供的拦截器对响应进行统一处理。对于非200、206状态码的响应， 使其返回失败的promise，并对请求失败情况进行统一的弹窗提示。具体的拦截逻辑可根据业务需求灵活设置。


```typescript
export class StatusCodeInterceptor implements rcp.Interceptor {
  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {
    const url = context.request.url;
    return next.handle(context).then((res: rcp.Response) => {
      if ([200, 206].includes(res.statusCode)) {
        return Promise.resolve(res);
      } else {
        const message = `Failed to ${url}: statusCode is ${res.statusCode}, message is ${res.toString()}`;
        Logger.error(message);
        showErrorMessage(message);
        return Promise.reject(new Error(message));
      }
    }).catch((err: BusinessError) => {
      Logger.error(`Failed to ${url}: Code is ${err.code}, message is ${err.data}`);
      // cancel request don't show err message prompt.
      if (err.code !== 1007900992) {
        showErrorMessage(JSON.stringify(err.data));
      }
      return Promise.reject(err);
    });
  }
}
```


在rcp.sessionConfiguration中配置请求的基地址baseAddress、相关拦截器interceptors、超时时间timeout和添加进度监听回调方法的对象httpEventsHandler。


```less
function genSessionConfig(httpEventsHandler?: rcp.HttpEventsHandler) {
  const config: rcp.SessionConfiguration = {
    baseAddress: BASE_URL,
    interceptors: [new StatusCodeInterceptor()],
    requestConfiguration: {
      tracing: { httpEventsHandler },
      transfer: {
        timeout: {
          connectMs: 1000 * 60 * 20,
          transferMs: 1000 * 60 * 20
        }
      }
    }
  };
  return config;
}
```


```less
export function download(fileName: string, httpEventsHandler: rcp.HttpEventsHandler) {
  const destPath = getSandboxPath(fileName);
  const rcpSession = rcp.createSession(genSessionConfig(httpEventsHandler));
  const downloadTo: rcp.DownloadToFile = {
    kind: 'file',
    file: destPath
  };
  return rcpSession.downloadToFile(`/${fileName}`, downloadTo)
    .then(() => destPath)
    .finally(() => {
      rcpSession.close();
    });
}
```


```less
export function download(fileName: string, httpEventsHandler: rcp.HttpEventsHandler) {
  const destPath = getSandboxPath(fileName);
  const rcpSession = rcp.createSession(genSessionConfig(httpEventsHandler));
  const downloadTo: rcp.DownloadToFile = {
    kind: 'file',
    file: destPath
  };
  return rcpSession.downloadToFile(`/${fileName}`, downloadTo)
    .then(() => destPath)
    .finally(() => {
      rcpSession.close();
    });
}
```


```less
export async function saveImageToAlbum(sandboxPath: string) {
  const phAccessHelper = photoAccessHelper.getPhotoAccessHelper(getContext());
  const fileNameExtension = sandboxPath.split('.').pop() || 'png';
  const photoCreationConfig: photoAccessHelper.PhotoCreationConfig = {
    fileNameExtension,
    photoType: getPhotoType(fileNameExtension),
  };
  const uri: string = fileUri.getUriFromPath(sandboxPath);
  const desFileUris: string[] = await phAccessHelper.showAssetsCreationDialog([uri], [photoCreationConfig]);
  const filePath = desFileUris[0];
  if (!filePath) throw new Error('photo assets permission denied');
  copyFileSync(sandboxPath, filePath);
  return filePath;
}
```


```less
export async function selectImagesFromAlbum(maxNumber: number = 1): Promise<string[]> {
  const photoPicker = new photoAccessHelper.PhotoViewPicker();
  const photoSelectOptions: photoAccessHelper.PhotoSelectOptions = {
    MIMEType: photoAccessHelper.PhotoViewMIMETypes.IMAGE_VIDEO_TYPE,
    maxSelectNumber: maxNumber
  };
  return photoPicker.select(photoSelectOptions).then((photoSelectResult: photoAccessHelper.PhotoSelectResult) => {
    const filePaths = photoSelectResult.photoUris;
    return filePaths.map(filePath => {
      const imageName = filePath.split('/').pop() || '';
      const sandboxPath = getSandboxPath(imageName);
      copyFileSync(filePath, sandboxPath);
      return sandboxPath;
    });
  });
}
```


```less
export async function selectImagesFromAlbum(maxNumber: number = 1): Promise<string[]> {
  const photoPicker = new photoAccessHelper.PhotoViewPicker();
  const photoSelectOptions: photoAccessHelper.PhotoSelectOptions = {
    MIMEType: photoAccessHelper.PhotoViewMIMETypes.IMAGE_VIDEO_TYPE,
    maxSelectNumber: maxNumber
  };
  return photoPicker.select(photoSelectOptions).then((photoSelectResult: photoAccessHelper.PhotoSelectResult) => {
    const filePaths = photoSelectResult.photoUris;
    return filePaths.map(filePath => {
      const imageName = filePath.split('/').pop() || '';
      const sandboxPath = getSandboxPath(imageName);
      copyFileSync(filePath, sandboxPath);
      return sandboxPath;
    });
  });
}
```


```less
export function upload(srcPath: string, httpEventsHandler: rcp.HttpEventsHandler) {
  const session = rcp.createSession(genSessionConfig(httpEventsHandler));
  const formData = new rcp.MultipartForm({
    file: {
      contentOrPath: srcPath
    }
  });
  return session.post('/', formData).finally(() => {
    session.close();
  });
}
```


```less
export function download(fileName: string, httpEventsHandler: rcp.HttpEventsHandler) {
  const destPath = getSandboxPath(fileName);
  const rcpSession = rcp.createSession(genSessionConfig(httpEventsHandler));
  const downloadTo: rcp.DownloadToFile = {
    kind: 'file',
    file: destPath
  };
  return rcpSession.downloadToFile(`/${fileName}`, downloadTo)
    .then(() => destPath)
    .finally(() => {
      rcpSession.close();
    });
}
```


```less
export async function saveImageToAlbum(sandboxPath: string) {
  const phAccessHelper = photoAccessHelper.getPhotoAccessHelper(getContext());
  const fileNameExtension = sandboxPath.split('.').pop() || 'png';
  const photoCreationConfig: photoAccessHelper.PhotoCreationConfig = {
    fileNameExtension,
    photoType: getPhotoType(fileNameExtension),
  };
  const uri: string = fileUri.getUriFromPath(sandboxPath);
  const desFileUris: string[] = await phAccessHelper.showAssetsCreationDialog([uri], [photoCreationConfig]);
  const filePath = desFileUris[0];
  if (!filePath) throw new Error('photo assets permission denied');
  copyFileSync(sandboxPath, filePath);
  return filePath;
}
```


```less
export async function selectImagesFromAlbum(maxNumber: number = 1): Promise<string[]> {
  const photoPicker = new photoAccessHelper.PhotoViewPicker();
  const photoSelectOptions: photoAccessHelper.PhotoSelectOptions = {
    MIMEType: photoAccessHelper.PhotoViewMIMETypes.IMAGE_VIDEO_TYPE,
    maxSelectNumber: maxNumber
  };
  return photoPicker.select(photoSelectOptions).then((photoSelectResult: photoAccessHelper.PhotoSelectResult) => {
    const filePaths = photoSelectResult.photoUris;
    return filePaths.map(filePath => {
      const imageName = filePath.split('/').pop() || '';
      const sandboxPath = getSandboxPath(imageName);
      copyFileSync(filePath, sandboxPath);
      return sandboxPath;
    });
  });
}
```


```less
export function upload(srcPath: string, httpEventsHandler: rcp.HttpEventsHandler) {
  const session = rcp.createSession(genSessionConfig(httpEventsHandler));
  const formData = new rcp.MultipartForm({
    file: {
      contentOrPath: srcPath
    }
  });
  return session.post('/', formData).finally(() => {
    session.close();
  });
}
```


断点续传


场景描述


在下载一些大文件时，可能会出现网络环境不稳定的情况，一旦网络波动导致传输中断，则需要从头开始重新下载，会极大浪费时间与流量，此时断点续传功能就显得尤为重要。本节通过手动暂停下载方式，讲解断点续传的关键原理和步骤。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153220.21891806445923472977557239477339:50001231000000:2800:9FEE7EDC9F034CB79AAD4AFBDFBC73DCA55B74BB2E59C0B069251FCF6291F27C.gif)

实现原理


关键技术

- 断点续传的基本原理就是利用http请求头中的range字段，对文件进行部分请求。
- 使用rcp.Request类型中的transferRange字段进行分片请求起始位置的配置。使用Session.fetch(request: Request)方法发送下载请求。
- 通过fs.writeSync()方法写入文件，利用offset参数保证每一块分片写入的顺序正确。
- 使用Session.cancel(request: Request)取消当前请求中断下载。

开发流程

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153220.92052645943447040056299623041473:50001231000000:2800:0BA0347CBD99A8F05EB9CB4C648A810029F7B426600AC86FF108F24D05803FDB.png)

开发步骤


```typescript
export function getFileSize(fileName: string): Promise<number> {
  const session = rcp.createSession(genSessionConfig());
  return session.head(`/${fileName}`).then(res => {
    const contentLength = res.headers['content-length'];
    return contentLength ? Number(contentLength): 0;
  }).finally(() => {
    session.close();
  });
}
```


```less
async start() {
  this.totalSize = this.totalSize || await getFileSize(this.url)
  const request = new rcp.Request(this.url);
  const writeSync: (buffer: ArrayBuffer) => void = buffer => {
    fileIo.writeSync(this.file.fd, buffer, { offset: this.downloadedSize })
    this.downloadedSize = fileIo.statSync(this.file.fd).size;
    this.onProgress(this.totalSize, this.downloadedSize);
  }
  request.destination = {
    kind: 'stream',
    stream: { writeSync }
  };
  request.transferRange = { from: this.downloadedSize };
  this.currentRequest = request;
  return this.session.fetch(request).then(() => {
    this.session.close();
    fileIo.close(this.file)
  });
}
```


```less
pause() {
  this.session.cancel(this.currentRequest);
}
```


后台文件上传下载


场景描述


在应用切换到后台时，需要继续保持文件上传或下载，在后台静默完成文件传输。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153220.32764607280873168281112481863804:50001231000000:2800:F83601F596D0E1AB98390BE6B8738D09FC2242973EEE6982D57A1DD3A5A72904.gif)

实现原理


关键技术

- 目前鸿蒙系统的规则是应用退到后台2s会被冻结，同时释放相关网络资源，上传下载请求会被中断。需使用backgroundTaskManager.startBackgroundRunning()方法申请长时任务。
- 使用backgroundTaskManager.stopBackgroundRunning()方法取消长时任务。

开发流程


开发步骤

- 在申请长时任务前，需配置相关权限，长时任务权限类型为网络类型。参考权限配置。

```less
async startBackgroundTask(task: () => Promise<void>) {
  try {
    const wantAgentObj = await wantAgent.getWantAgent(this.getWantAgentInfo());
    await backgroundTaskManager.startBackgroundRunning(
      getContext(this),
      backgroundTaskManager.BackgroundMode.DATA_TRANSFER,
      wantAgentObj
    );
    task().finally(() => {
      backgroundTaskManager.stopBackgroundRunning(getContext(this));
    });
  } catch (err) {
    Logger.error('Failed to start background task', JSON.stringify(err));
    showErrorMessage('A background task is running');
  }
}
```

- 上传下载请求的发送根据需求选择合适的方式即可。

示例代码

- 基于rcp实现文件上传下载功能

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-file-transmission-based-on-sfft
爬取时间: 2025-05-08 03:35:34
来源: Huawei Developer


概述


文件传输（包括上传和下载）是应用程序中极为常见的功能。然而，当应用使用HTTP协议传输长视频、数据集、压缩包等通常超过100MB的大文件时，由于网络不稳定等因素，传输过程可能会耗时较长或直接失败。因此，针对大文件传输的性能优化尤为必要，开发者需要采用特定的策略来确保传输的高效性和可靠性。


目前，super_fast_file_trans（以下简称SFFT）库提供了针对大文件传输过程中的多线程下载、分片上传、断点续传、断点续下及自动重试等特性的完整封装，帮助开发者快速实现大文件传输场景，提高开发效率，开发者可参考Sample工程进行安装配置与快速上手。下文将以上述SFFT支持的各个特性为例，介绍SFFT的使用。


多线程下载


场景描述


多线程下载是一种通过同时开启多个线程，并行下载文件不同部分的文件传输特性，能够充分利用带宽资源，显著提升下载速度，尤其适用于下载大文件或在网络带宽受限的环境下下载文件。其核心原理是将文件分割为多个小块，由多个线程同时下载这些部分，并发写入到本地文件中，从而实现高效、稳定的下载。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153220.45928123696643856981916642591536:50001231000000:2800:97F44710EC9D7B23C72F0420365D2BE37A64DB614D82E2994E05B2E0EA660485.png)

实现原理


SFFT基于TaskPool和@kit.RemoteCommunicationKit（后续简称RCP）实现了多线程下载，实现流程如下：


当使用多线程下载时：


开发步骤


SFFT三方库使用RCP发送HTTP请求，因此使用了以下权限。权限设置详情参考应用权限。

- ohos.permission.INTERNET：允许应用访问互联网。
- ohos.permission.GET_NETWORK_INFO：允许应用获取数据网络信息。

以下代码默认应用已经安装并导入了SFFT三方库，详细的三方库安装教程可以参考"如何使用ohpm引入三四方库"。


```less
await DownloadManager.getInstance().init(getContext() as common.UIAbilityContext);
let downloadConfig: DownloadConfig = {
  url: this.url, // 远端文件url地址
  fileName: this.fileName, // 本地文件名
  concurrency: this.concurrency, // 启用的线程数，concurrency为1~8的正整数
  // ...
};
// 根据配置创建下载任务，downloadListener为可选的下载过程回调
this.downloadInstance = DownloadManager.getInstance().createDownloadTask(downloadConfig, downloadListener);
// ...
await this.downloadInstance?.start(); // 启用多线程下载
```

- 当开发者未指定下载线程数（concurrency）时，SFFT会根据试连响应中的文件大小信息自动计算启用的线程数。详情可见Sample工程。

实现效果


当使用SFFT进行大文件多线程下载时，下载速率相比于单线程下的普通下载，可以得到明显地提升。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153221.79821327790173566453588928813378:50001231000000:2800:B6E765D22DC4B12D2B2BA31D90E0C40E17293B816AA75D124E3FBD22C78F7171.gif)

分片上传


场景描述


分片上传是一种将本地大文件分成多个小块（分片）后，分别上传的特性，可提升传输效率并减少网络波动的影响。若某个分片上传失败，只需重传该分片，无需重新上传整个文件。结合断点续传技术，即使传输被中断也能继续上传，确保上传过程的稳定性，特别适合复杂的网络环境。分片上传需要服务端支持将多个小文件合并成完整文件。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153221.05463069047960773508016002345428:50001231000000:2800:270E08AE49FA675EAE740FFE6CB633A6120FCA7F51995B84E4BD128A91526576.png)

实现原理


SFFT基于RCP实现了分片上传，实现步骤如下：


开发步骤


```less
await UploadManager.getInstance().init(getContext() as common.UIAbilityContext);
let uploadConfig: UploadConfig = {
  url: this.isChunk ? CONSTANTS_CONFIG.urls.chunkUploadUrl : CONSTANTS_CONFIG.urls.ordinaryUploadUrl, // 上传请求url
  filePath: this.filePath, // 本地文件地址
  isChunk: this.isChunk, // 是否启用分片上传，isChunk为true时启用，启用分片上传后将支持断点续传
  chunkSize: 1024 * 1024 * 10, // 分片大小指定为10MB，当isChunk为true时生效
  // ...
};
// 根据配置创建上传任务，uploadListener为可选的上传过程回调
this.uploadInstance = UploadManager.getInstance().createUploadTask(uploadConfig, uploadListener);
// ...
await this.uploadInstance?.start(); // 启用分片上传
```

- 当开发者开启分片上传（isChunk），但并未设置分片大小（chunkSize）时，SFFT会根据本地待上传文件的大小采用默认策略自动计算分片大小，详情可见Sample工程。

实现效果


当使用SFFT进行大文件分片上传时，上传速率相比于不使用分片上传，可以得到明显地提升。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153221.59294216849415459373855661831925:50001231000000:2800:9400401C6E7066D6A374CB6529B11DF48A2B52D4A1899BFF16DBF05F64AC4480.gif)

断点续传/断点续下


场景描述


断点续传/断点续下是指在文件下载或上传过程中，因网络中断、程序崩溃等异常导致传输中断后，应用能够从中断处继续传输剩余文件数据的特性。


这一特性尤其适用于大文件传输场景。在数据传输过程中，应用会周期性地自动保存断点信息，以应对突发中断。当应用再次恢复到正常运行状态时，即可从本地读取断点信息，继续传输文件的剩余部分。这种传输方式能有效应对网络不稳定的问题，减少因网络波动而造成的传输失败，节省流量消耗，为用户提供流畅、可靠的传输体验。


实现原理


断点续下


在SFFT中，断点续下基于上述多线程下载原理，结合关系型数据库RDB实现。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153221.54651326800153398984308847255989:50001231000000:2800:0FB44E5B74795487150EAAAA53EEAD0200902F4A8D099CF659C6A9CD4FB2EF8C.png)

当使用断点续下时：


断点续传


在SFFT中，断点续下基于上述分片上传原理，结合RDB实现。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153221.84793082769743504882808768463873:50001231000000:2800:05595D13C5223FA0B8F82E75E7BAAD6E64BDA69C7C6AD3BD2D4B7BE1B647C4BF.png)

当使用断点续传时：


开发步骤


```less
await DownloadManager.getInstance().init(getContext() as common.UIAbilityContext);
let downloadConfig: DownloadConfig = {
  url: this.url, // 远端文件url地址
  fileName: this.fileName, // 本地文件名
  concurrency: this.concurrency, // 启用的线程数，concurrency为1~8的正整数
  isBreakpointResume: this.isResumable, // 是否启用断点续下，isBreakpointResume为true时启用
  // ...
};
// 根据配置创建下载任务，downloadListener为可选的下载过程回调
this.downloadInstance = DownloadManager.getInstance().createDownloadTask(downloadConfig, downloadListener);
// ...
await this.downloadInstance?.start(); // 启用多线程下载
// ...
await this.downloadInstance?.pause(); // 手动暂停下载或其他原因使下载暂停
// ...
await this.downloadInstance?.resume(); // 断点续下
```


```less
await UploadManager.getInstance().init(getContext() as common.UIAbilityContext);
let uploadConfig: UploadConfig = {
  url: this.isChunk ? CONSTANTS_CONFIG.urls.chunkUploadUrl : CONSTANTS_CONFIG.urls.ordinaryUploadUrl, // 上传请求url
  filePath: this.filePath, // 本地文件地址
  isChunk: this.isChunk, // 是否启用分片上传，isChunk为true时启用，启用分片上传后将支持断点续传
  chunkSize: 1024 * 1024 * 10, // 分片大小指定为10MB，当isChunk为true时生效
  // ...
};
// 根据配置创建上传任务，uploadListener为可选的上传过程回调
this.uploadInstance = UploadManager.getInstance().createUploadTask(uploadConfig, uploadListener);
// ...
await this.uploadInstance?.start(); // 启用分片上传
// ...
await this.uploadInstance?.pause(); // 手动暂停上传或其他原因使上传暂停
// ...
await this.uploadInstance?.resume(); // 断点续传
```


实现效果


当使用SFFT进行大文件传输时，文件能从应用退出时的传输断点处重新传输。


| 断点续下  | 断点续传  |
| --- | --- |
|   |   |

断点续下


断点续传

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153221.76148467598779377117724811416969:50001231000000:2800:D6CE7EA6156A9AA2DD2D4CDE1265449A46D89C5442906D3C06AFD6F96BB02D8E.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153221.58112696398916584447851848322521:50001231000000:2800:29574685514AC8DDE9213DF0640C4A3B6824884CC48B98F6D2D466DE695F4EA3.gif)

自动重连


场景描述


自动重连是指当文件传输失败时，应用根据异常类型自动尝试重新连接服务端，并继续传输文件数据的特性，目的是为了减少异常情况下的人工干预，确保任务顺利完成。该特性需要断点续下或断点续传支持。


实现原理


当使用自动重连时：

- 若在文件传输时遇到网络波动、服务器宕机等导致传输中断的状况，SFFT会自动捕捉到异常。
- 根据异常的类型，SFFT会自动判断是否需要自动重连，并根据开发者设置的重试间隔、重试次数，周期性地尝试发起连接请求，从断点处继续传输。

开发步骤


```less
let downloadConfig: DownloadConfig = {
  url: this.url, // 远端文件url地址
  fileName: this.fileName, // 本地文件名
  concurrency: this.concurrency, // 启用的线程数，concurrency为1~8的正整数
  isBreakpointResume: this.isResumable, // 是否启用断点续下，isBreakpointResume为true时启用
  maxRetries: 3, // 重试次数为3次
  retryInterval: 2000, // 重试间隔为2000ms
  // ...
};
// 根据配置创建下载任务，downloadListener为可选的下载过程回调
this.downloadInstance = DownloadManager.getInstance().createDownloadTask(downloadConfig, downloadListener);
```


实现效果


当使用SFFT进行大文件传输时，应用能在网络条件恢复时自动重新连接。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153222.41697876175205172087053247931715:50001231000000:2800:504B9A5CAE3B4C4CF6F07DDABEF457B6695A1DEF6905463CD2953A1D2847A891.gif)

服务端要求


下载文件


SFFT依赖服务端支持实现多线程下载，因此服务端需满足以下要求：


上传文件


SFFT依赖服务端支持实现分片下载，因此服务端需满足以下要求：


示例代码

- 基于SFFT的大文件高速并发传输

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-third-party-camera
爬取时间: 2025-05-08 03:35:45
来源: Huawei Developer


概述


本文针对三方相机开发场景，基于HarmonyOS提供的相机开放能力，实现系统相机级别的效果和能力，比如分辨率、动图、视频防抖、连续变焦等。


效果展示


| 功能  | 系统相机  | 三方相机  |
| --- | --- | --- |
| 连续变焦  |   |   |
| 视频防抖：开启前  |    |
| 视频防抖：开启后  |   |   |
| 照片HDR：主摄  |   |   |
| 照片HDR：广角  |   |   |
| 照片HDR：长焦  |   |   |

功能


系统相机


三方相机


连续变焦

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152828.68965908128347633339716309995398:50001231000000:2800:552FDDD06749725D11C21709B4D147164F3239B0A5593745B0A82792A2569B5E.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152828.73225137987592534645627272113847:50001231000000:2800:FB4A888E8489EF61701A8F48FEA7B02343995ECC83581D9AEFB8FB6835F5ACE9.gif)

视频防抖：开启前

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152829.93009910124020826409234574438659:50001231000000:2800:98B160CA1CA97896FE7E2410E5585D88C82A53C50CE3BFE9A6685574E3C48B82.gif)

视频防抖：开启后

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152829.86431427194860144597696817567980:50001231000000:2800:74C03EC0BFE678338FAA76D82AABA6B0A61A9B5AFCAC308DC3C84D06949BA055.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152829.43428946661626712257718393863856:50001231000000:2800:8780200C6D40063BEF21331D295082CBC41C40EDFF9EAA0BF0EE13C904269885.gif)

照片HDR：主摄

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152829.18201326232234867308391660188736:50001231000000:2800:9CA4314C94CB446A8F598545358F2B0447E1269A96523124ACE8B521917D6F1B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152829.47587811434478529639795872326499:50001231000000:2800:B616481CF335C84280D5B5B7D1E5AFA8428A4B3FE58E3ADAE226A993E5370098.png)

照片HDR：广角

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152829.88680162606043443282123199562262:50001231000000:2800:1F4956D269D40251D01B142D693F2061B897E025B68DDBC5029EFBB49294529D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152829.23688317061573889076911512701121:50001231000000:2800:683E88409B7840B9FE45351621A7BC8F1A71FDAF3F6269C4ECEDEFF1794C2DE9.png)

照片HDR：长焦

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152829.40078389459146302589282514208725:50001231000000:2800:ABCD9E1C6280FA7083CCD95FDB0D610BC4E10E723C5CFF223798768310128162.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152829.13144613496245260373172241619306:50001231000000:2800:FE32A2EFD083FC439702B39DBB6E50A5126691EE00790B0CD127B9B04F85E7BC.png)

场景使用说明


适用范围


本场景主要适用于第三方应用调用系统相机能力，实现系统级相机效果。


限制版本Developer Beta1及以上。


场景优势


| 场景分类  | 三方相机  | 系统相机  |
| --- | --- | --- |
| 多摄连续变焦（画面亮度，颜色一致）  | 支持  | 支持  |
| 视频防抖  | 支持  | 支持  |
| 照片高动态HDR  | 支持  | 支持  |

场景分类


三方相机


系统相机


多摄连续变焦（画面亮度，颜色一致）


支持


支持


视频防抖


支持


支持


照片高动态HDR


支持


支持


场景分析


典型场景


| 场景名称  | 描述  | 实现方案  |
| --- | --- | --- |
| 拍照  | 照片拍摄  | Camera kit  |
| 录像  | 视频录制  | AVRecorder和Camera kit  |
| 动态照片  | 动态照片拍摄以及预览  | Camera kit和MovingPhotoView组件  |

场景名称


描述


实现方案


拍照


照片拍摄


Camera kit


录像


视频录制


AVRecorder和Camera kit


动态照片


动态照片拍摄以及预览


Camera kit和MovingPhotoView组件


场景实现


场景整体介绍


原理介绍


三方相机开放能力采用与系统相机统一底层接口调用方式，使最终的拍摄保持系统级效果。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152830.25092843124157367410803913312601:50001231000000:2800:4F0933AA0597FA77EE04D7AF4E1DDD204722652F22C717FC213B8E1403C63442.png)

整体流程


本场景解决方案按照如下流程实现三方相机效果，推荐开发者参考相同流程进行接入，以保证更好体验：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152830.34658287897465186455588961927302:50001231000000:2800:A52DBDE78A17982B3AB63924EED7342F69AD3CB1962498EFAC6C4BB332FA3145.png)

拍照


如图1所示，应用可以点击底部圆形按钮拍摄照片，同时可以调节变焦，闪光灯等参数。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152830.82881583256957461959337047043121:50001231000000:2800:F7B8017EB7DB5B833E1473551444C83BF9826F991A3EEB1EF2B69C1C4AC94815.png)

时序图

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152830.33017774273779354944199695648537:50001231000000:2800:EF8049527E1651A2EEC4CEA4D702F665F876AD97C90FED419C14BA690DF3EF42.png)

关键点说明


需要获得将照片存入图库的权限。


关键代码片段


1、创建CameraManager对象，需要通过UIContext创建，用来对相机进行操作。


```less
let cameraManager: camera.CameraManager = camera.getCameraManager(context);
```


2、获取相机列表，系统会提供前置和后置相机，供开发者选择切换。


```less
let cameraArray: camera.CameraDevice[] = cameraManager.getSupportedCameras();
```


3、选择摄像头，创建输入流，作为预览流和拍照流的提供方。


```less
cameraInput = cameraManager.createCameraInput(cameraArray[cameraPosition]);
await cameraInput.open();
```


4、获取相机设备支持的输出流能力，此处指定NORMAL_PHOTO获取的是照片流，用来创建拍照输出流和预览输出流。


```less
let cameraOutputCap: camera.CameraOutputCapability =
  cameraManager.getSupportedOutputCapability(cameraArray[cameraPosition], camera.SceneMode.NORMAL_PHOTO);
```


5、创建预览输出流，通过surfaceId绑定显示组件XComponent。


```less
let previewProfilesArray: camera.Profile[] = cameraOutputCap.previewProfiles;


previewOutput = cameraManager.createPreviewOutput(previewProfile, surfaceId);
```


6、创建拍照输出流，可以输出照片文件。


```less
let photoProfilesArray: camera.Profile[] = cameraOutputCap.photoProfiles;


photoOutPut = cameraManager.createPhotoOutput(photoProfile);
```


7、创建相机会话，用于控制修改拍照参数。


```less
photoSession = cameraManager.createSession(camera.SceneMode.NORMAL_PHOTO) as camera.PhotoSession;
```


8、开始配置会话，向会话中添加各路输入输出流，之后可以拍照。


```less
photoSession.beginConfig();
photoSession.addInput(cameraInput);
photoSession.addOutput(previewOutput);
photoSession.addOutput(photoOutPut);
await photoSession.commitConfig();
await photoSession.start();
```


9、调节闪光灯，通过FLASH_MODE_CLOSE设置为关闭，目前支持关闭，自动，常亮，打开。


```less
photoSession.setFlashMode(camera.FlashMode.FLASH_MODE_CLOSE);
```


10、调节自动变焦模式，通过FOCUS_MODE_CONTINUOUS_AUTO设置为自动模式。目前支持连续自动对焦、自动对焦、手动对焦。


```less
photoSession.setFocusMode(camera.FocusMode.FOCUS_MODE_CONTINUOUS_AUTO);
```


11、调节相机焦距，超出范围则只保留支持范围的值。


```less
photoSession.setZoomRatio(zoom);
```


12、点击拍照，通过QUALITY_LEVEL_HIGH选择高质量模式。


```less
let settings: camera.PhotoCaptureSetting = {
  quality: camera.QualityLevel.QUALITY_LEVEL_HIGH,
  rotation: camera.ImageRotation.ROTATION_0,
  mirror: isFront
};
photoOutPut.capture(settings);
```


13、保存图片，此处需要调用系统图库接口photoAccessHelper。


```less
function setPhotoOutputCb(photoOutput: camera.PhotoOutput): void {
  photoOutput.on('photoAssetAvailable',
    async (_err: BusinessError, photoAsset: photoAccessHelper.PhotoAsset): Promise<void> => {
      let accessHelper: photoAccessHelper.PhotoAccessHelper =
        photoAccessHelper.getPhotoAccessHelper(currentContext);
      let assetChangeRequest: photoAccessHelper.MediaAssetChangeRequest =
        new photoAccessHelper.MediaAssetChangeRequest(photoAsset);
      assetChangeRequest.saveCameraPhoto();
      await accessHelper.applyChanges(assetChangeRequest);
      uri = photoAsset.uri;
      AppStorage.setOrCreate('photoUri', await photoAsset.getThumbnail());
    });
}
```


14、预览图片，应用将跳转进入系统图库应用进行预览，需要传入对应的图库uri。


```less
export function previewPhoto(context: Context): void {
  let photoContext = context as common.UIAbilityContext;
  photoContext.startAbility({
    parameters: { uri: uri },
    action: 'ohos.want.action.viewData',
    bundleName: 'com.huawei.hmos.photos',
    abilityName: 'com.huawei.hmos.photos.MainAbility'
  })
}
```


API使用链接


相机管理


相册管理模块


录像


用户在应用界面上点击按钮开始录制，再次点击红色按钮结束录制，同时可以调节变焦，闪光灯，分辨率，视频防抖等参数

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152830.66819006327393422604776145597428:50001231000000:2800:6D160FB78B6CD93C1E52E7F0848D2D019D3208F6E1009EC4D4F5C233987D3B4A.png)

时序图

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152830.44273738495119691276946179180554:50001231000000:2800:9F809049563DDFA01B0D468AEDD3308A0A65EB57F5DAF199BC934260A9D09EF9.png)

关键点说明


需要获得将照片存入图库的权限。


关键代码片段


1、创建CameraManager对象，需要通过UIContext创建，用来对相机进行操作。


```less
let cameraManager: camera.CameraManager = camera.getCameraManager(context);
```


2、获取相机列表，系统会提供前置和后置相机，供开发者选择切换。


```less
let cameraArray: camera.CameraDevice[] = [];
cameraArray = cameraManager.getSupportedCameras();
```


3、选择摄像头，创建输入流，作为预览流和拍照流的提供方。


```less
cameraInput = cameraManager.createCameraInput(cameraArray[cameraPosition]);
// ...
await cameraInput.open();
```


4、获取相机设备支持的输出流能力，此处指定NORMAL_VIDEO获取的是视频流，用来创建视频输出流和视频预览输出流。


```less
let cameraOutputCap: camera.CameraOutputCapability =
  cameraManager.getSupportedOutputCapability(cameraArray[cameraPosition], camera.SceneMode.NORMAL_VIDEO);
```


5、创建预览输出流，通过surfaceId绑定显示组件XComponent。


```less
let previewProfilesArray: camera.Profile[] = cameraOutputCap.previewProfiles;


let previewOutput: camera.PreviewOutput | undefined = cameraManager.createPreviewOutput(previewProfile, surfaceId);
```


6、创建视频输出流，可以输出视频文件。


```less
let videoProfile: undefined | camera.VideoProfile = videoProfilesArray.find((profile: camera.VideoProfile) => {
  if (previewProfile && cameraPosition === 1) {
    return profile.size.width >= 1080 && profile.size.height >= 1080
      && profile.size.height === (foldAbleStatus === display.FoldStatus.FOLD_STATUS_EXPANDED ? 1 :
        (previewProfile.size.height / previewProfile.size.width)) * profile.size.width
      && profile.frameRateRange.max === 30;
  }
  if (previewProfile && qualityLevel === 0) {
    return profile.size.width <= 1920 && profile.size.width >= 1080 && profile.size.height >= 1080
      && profile.size.height === (foldAbleStatus === display.FoldStatus.FOLD_STATUS_EXPANDED ? 1 :
        (previewProfile.size.height / previewProfile.size.width)) * profile.size.width
      && profile.frameRateRange.max === 60;
  }
  if (previewProfile && qualityLevel === 1 && cameraPosition === 0) {
    return profile.size.width <= 4096 && profile.size.width >= 3000
      && profile.size.height === (foldAbleStatus === display.FoldStatus.FOLD_STATUS_EXPANDED ? 1 :
        (previewProfile.size.height / previewProfile.size.width)) * profile.size.width
      && profile.frameRateRange.max === 60;
  }
  return undefined;
})


videoOutput = cameraManager.createVideoOutput(videoProfile, videoSurfaceId);
```


7、创建相机会话，用于控制修改视频参数。


```less
videoSession = cameraManager.createSession(camera.SceneMode.NORMAL_VIDEO) as camera.VideoSession;
```


8、开始配置会话，向会话中添加各路输入输出流，之后可以开始录像。


```less
videoSession.beginConfig();


videoSession.addInput(cameraInput);


videoSession.addOutput(previewOutput);
videoSession.addOutput(videoOutput);
await videoSession.commitConfig();
// ...
await videoSession.start();
```


9、通过avRecorder开始录像。


```less
await avRecorder.start();
```


10、通过avRecorder停止录像。


```less
await avRecorder.stop();
```


11、保存视频，注意需要将文件uri转化为fd赋值给AVRecorderConfig。


```less
let options: photoAccessHelper.CreateOptions = {
  title: Date.now().toString()
};
let accessHelper: photoAccessHelper.PhotoAccessHelper = photoAccessHelper.getPhotoAccessHelper(context);
let videoUri: string = await accessHelper.createAsset(photoAccessHelper.PhotoType.VIDEO, 'mp4', options);
file = fileIo.openSync(videoUri, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
let aVRecorderConfig: media.AVRecorderConfig = {
  audioSourceType: media.AudioSourceType.AUDIO_SOURCE_TYPE_MIC,
  videoSourceType: media.VideoSourceType.VIDEO_SOURCE_TYPE_SURFACE_YUV,
  profile: aVRecorderProfile,
  url: `fd://${file.fd.toString()}`,
  // 文件需先由调用者创建，赋予读写权限，将文件fd传给此参数，eg.fd://45--file:///data/media/01.mp4
  rotation: cameraPosition === 0 ? 90 : 270,
  // 合理值0、90、180、270，非合理值prepare接口将报错
  location: { latitude: 30, longitude: 130 }
};
```


12、预览视频，应用将跳转进入系统图库应用进行预览，需要传入对应的图库uri。


```less
export function previewVideo(context: Context, videoUri: string): void {
  let videoContext = context as common.UIAbilityContext;
  videoContext.startAbility({
    parameters: { uri: videoUri },
    action: 'ohos.want.action.viewData',
    bundleName: 'com.huawei.hmos.photos',
    abilityName: 'com.huawei.hmos.photos.MainAbility'
  })
}
```


API使用链接


相机管理


相册管理模块


动态照片


拍照按钮触发动态照片拍摄，限制在3s，效果如下。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152830.20416804289398332169699629420473:50001231000000:2800:25E365EC9AA393C365C78553ABEEE39F73B95E03132E65DEDE66CCC103CAE3F3.gif)

时序图

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152830.13511033143166507171228020474413:50001231000000:2800:044F158A97B2A23B3070A1470B5AC3BE6B6B95BE5910DFAE38AF7A89ED0D77D0.png)

关键点说明


使能动态照片前需要分段式拍照能力。固定拍摄时间固3s。


关键代码片段


1、创建拍照输出流。


```less
let photoProfilesArray: camera.Profile[] = cameraOutputCap.photoProfiles;


photoOutPut = cameraManager.createPhotoOutput(photoProfile);
```


2、查询当前设备当前模式是否支持动态照片能力。


```less
let isSupported: boolean = photoOutPut.isMovingPhotoSupported();
```


3、使能动态照片拍照能力。


```less
if (isSupported) {
  photoOutPut.enableMovingPhoto(isMovingPhoto);
}
```


4、预览需要使用MovingPhotoView，长按图片会播放动图。


```less
@State src: photoAccessHelper.MovingPhoto | undefined = undefined;


controller: MovingPhotoViewController = new MovingPhotoViewController();
```


```less
MovingPhotoView({
  movingPhoto: this.src,
  controller: this.controller
})
```


API使用链接


相机管理


相册管理模块


动态照片


相关技术参考


相机服务


示例代码

- 生态应用相机实现系统级相机体验

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-camera-shot2see
爬取时间: 2025-05-08 03:35:51
来源: Huawei Developer


概述


相机拍照性能依赖算法处理的速度，而处理效果依赖算法的复杂度，算法复杂度越高的情况下会导致处理时间就越长。目前系统相机开发有两种相机拍照方案，分别是相机分段式拍照和相机单段式拍照：

- 分段式拍照是系统相机开发的重要功能之一，即相机拍照可输出低质量图用作缩略图，提升用户感知拍照速度，同时使用高质量图保证最后的成图质量达到系统相机的水平，既满足了后处理算法的需求，又不会阻塞前台的拍照速度，构筑相机性能竞争力，提升了用户的体验。
- 单段式拍照是指在拍照过程中通过多帧融合以及多个底层算法处理之后返回一张高质量图片，这样导致Shot2See（Shot2See指的是从用户点击拍照控件到在缩略图显示区域显示缩略图）完成时延比较长。

分段式拍照和单段式拍照返回的图片在全质量图的情况下图片质量是一致的，但是在低质量的情况下单段式拍照的图片质量要优于分段式拍照。如果开发者不需要获取全质量图并且也不考虑Shot2See的完成时延，建议使用单段式拍照，否则的话，建议使用分段式拍照。本篇文章主要以相机Shot2See场景为例，来展示分段式拍照Shot2See的完成时延要低于单段式拍照。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152830.32495698032709531114555970213760:50001231000000:2800:326AE65B2C8C4EB966D0A7B0D23E44A11140C05E13401ECCF76DD0A93137C62B.png)

效果展示

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152830.86220190154027225958448052415969:50001231000000:2800:6DCF3FD39935541C35570B7AA03827B48718BB074C30D02E07CD46BA0F16B898.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152830.53853495204569990014115942914687:50001231000000:2800:17DE4863D004EF5CFE3E74505C5B7C269C5446E957EE284D9A59C345E0D080F5.gif)

从上述效果图中可以看出，分段式拍照从用户点击拍照控件到在缩略图显示区域显示缩略图的耗时比单段式拍照要短。


性能对比分析方式


静态校验：在相机类应用中，如果使用单段式拍照，拍照过程中该场景下仅会返回一张图片，将图片用作Shot2See后的缩略图则会导致Shot2See完成时延比较长。


动态校验：开发者可以通过DevEco Studio中的Profiler工具去抓取Trace，获取到Trace之后，根据PhotoOutputNapi::Capture和OnBufferAvailable找到对应的Trace Marker，并通过两者之间的时间段来分析耗时，单段式拍照的时长为1900ms，而分段式拍照的时长为672.7ms。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152830.12397920388037521231160659111129:50001231000000:2800:9A86183F8A0EBCD8C525A17B1905CF926B15B67FCABA6C3FEA77A71BB751BA0E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152831.65917880228324935189644350217946:50001231000000:2800:D94D248DE9ABB47F11525179AE1183FEB1C80F65FDA0BC8C041C64B2AAAB01AF.png)

性能对比分析表


| 拍照实现方式  | 耗时(局限不同设备和场景，数据仅供参考)  |
| --- | --- |
| 单段式拍照  | 1900ms  |
| 分段式拍照  | 672.7ms  |

拍照实现方式


耗时(局限不同设备和场景，数据仅供参考)


单段式拍照


1900ms


分段式拍照


672.7ms


优化思路：在需要加快Shot2See完成时延的场景下，使用相机框架开发的分段式拍照方案，加快阶段一照片生成的速度。


场景示例


下面以应用中相机Shot2See（拍照之后自动跳转到照片编辑界面）为例，通过单段式拍照和分段式拍照的性能功耗对比，来展示两者的性能差异。


单段式拍照：


单段式拍照使用了on(type: 'photoAvailable', callback: AsyncCallback<Photo>): void接口注册了高质量图的监听，默认不使能分段式拍照。具体操作步骤如下所示：


1.相机媒体数据写入XComponent组件中，用来显示图像效果。具体代码如下所示：


```less
XComponent({
  type: XComponentType.SURFACE,
  controller: this.mXComponentController,
  imageAIOptions: this.options
})
  .onLoad(async () => {
    Logger.info(TAG, 'onLoad is called');
    this.surfaceId = this.mXComponentController.getXComponentSurfaceId();
    GlobalContext.get().setObject('cameraDeviceIndex', this.defaultCameraDeviceIndex);
    GlobalContext.get().setObject('xComponentSurfaceId', this.surfaceId);
    Logger.info(TAG, `onLoad surfaceId: ${this.surfaceId}`);
    await CameraService.initCamera(this.surfaceId, this.defaultCameraDeviceIndex);
  })
  .border({
    width: {
      top: Constants.X_COMPONENT_BORDER_WIDTH,
      bottom: Constants.X_COMPONENT_BORDER_WIDTH
    },
    color: Color.Black
  })
  .width('100%')
  .height(523)
  .margin({ top: 75, bottom: 72 })
```


2.initCamera函数完成一个相机生命周期初始化的过程。


(1)getCameraManager获取CameraMananger相机管理器类。


(2)getSupportedCameras和getSupportedOutputCapability方法获取支持的camera设备以及设备能力集。


(3)createPreviewOutput和createPhotoOutput方法创建预览输出和拍照输出对象。


(4) CameraInput的open方法打开相机输入。


(5) onCameraStatusChange函数创建CameraManager注册回调。


(6) 最后调用sessionFlowFn函数创建并开启Session。具体代码如下所示：


```less
/**
 * Initialize Camera Functions
 * @param surfaceId - Surface ID
 * @param cameraDeviceIndex - Camera Device Index
 * @returns No return value
 */
async initCamera(surfaceId: string, cameraDeviceIndex: number): Promise<void> {
  Logger.debug(TAG, `initCamera cameraDeviceIndex: ${cameraDeviceIndex}`);
  this.photoMode = AppStorage.get('photoMode');
  if (!this.photoMode) {
    return;
  }
  try {
    await this.releaseCamera();
    // Get Camera Manager Instance
    this.cameraManager = this.getCameraManagerFn();
    if (this.cameraManager === undefined) {
      Logger.error(TAG, 'cameraManager is undefined');
      return;
    }
    // Gets the camera device object that supports the specified
    this.cameras = this.getSupportedCamerasFn(this.cameraManager);
    if (this.cameras.length < 1 || this.cameras.length < cameraDeviceIndex + 1) {
      return;
    }
    this.curCameraDevice = this.cameras[cameraDeviceIndex];
    let isSupported = this.isSupportedSceneMode(this.cameraManager, this.curCameraDevice);
    if (!isSupported) {
      Logger.error(TAG, 'The current scene mode is not supported.');
      return;
    }
    let cameraOutputCapability =
      this.cameraManager.getSupportedOutputCapability(this.curCameraDevice, this.curSceneMode);
    let previewProfile = this.getPreviewProfile(cameraOutputCapability);
    if (previewProfile === undefined) {
      Logger.error(TAG, 'The resolution of the current preview stream is not supported.');
      return;
    }
    this.previewProfileObj = previewProfile;
    // Creates the previewOutput output object
    this.previewOutput = this.createPreviewOutputFn(this.cameraManager, this.previewProfileObj, surfaceId);
    if (this.previewOutput === undefined) {
      Logger.error(TAG, 'Failed to create the preview stream.');
      return;
    }
    // Listening for preview events
    this.previewOutputCallBack(this.previewOutput);
    let photoProfile = this.getPhotoProfile(cameraOutputCapability);
    if (photoProfile === undefined) {
      Logger.error(TAG, 'The resolution of the current photo stream is not supported.');
      return;
    }
    this.photoProfileObj = photoProfile;
    // Creates a photoOutPut output object
    this.photoOutput = this.createPhotoOutputFn(this.cameraManager, this.photoProfileObj);
    if (this.photoOutput === undefined) {
      Logger.error(TAG, 'Failed to create the photo stream.');
      return;
    }
    // Creates a cameraInput output object
    this.cameraInput = this.createCameraInputFn(this.cameraManager, this.curCameraDevice);
    if (this.cameraInput === undefined) {
      Logger.error(TAG, 'Failed to create the camera input.');
      return;
    }
    // Turn on the camera
    let isOpenSuccess = await this.cameraInputOpenFn(this.cameraInput);
    if (!isOpenSuccess) {
      Logger.error(TAG, 'Failed to open the camera.');
      return;
    }
    // Camera status callback
    this.onCameraStatusChange(this.cameraManager);
    // Listens to CameraInput error events
    this.onCameraInputChange(this.cameraInput, this.curCameraDevice);
    // Session Process
    await this.sessionFlowFn(this.cameraManager, this.cameraInput, this.previewOutput, this.photoOutput);
  } catch (error) {
    let err = error as BusinessError;
    Logger.error(TAG, `initCamera fail: ${JSON.stringify(err)}`);
  }
}
```


3.确定拍照输出流。通过cameraManager.createPhotoOutput方法创建拍照输出流，参数为CameraOutputCapability类中的photoProfiles属性。


```less
/**
 * Creates a photoOutPut output object
 */
createPhotoOutputFn(cameraManager: camera.CameraManager,
  photoProfileObj: camera.Profile): camera.PhotoOutput | undefined {
  let photoOutput: camera.PhotoOutput;
  try {
    photoOutput = cameraManager.createPhotoOutput(photoProfileObj);
    Logger.info(TAG, `createPhotoOutputFn success: ${photoOutput}`);
    return photoOutput;
  } catch (error) {
    let err = error as BusinessError;
    Logger.error(TAG, `createPhotoOutputFn failed: ${JSON.stringify(err)}`);
    return undefined;
  }
}
```


4.触发拍照。通过photoOutput类的capture方法，执行拍照任务。该方法有两个参数，分别为拍照设置参数的setting以及回调函数，setting中可以设置照片的质量和旋转角度。具体代码如下所示：


```less
/**
 * Trigger a photo taking based on the specified parameters
 */
async takePicture(): Promise<void> {
  Logger.info(TAG, 'takePicture start');
  let cameraDeviceIndex = GlobalContext.get().getT<number>('cameraDeviceIndex');
  let photoSettings: camera.PhotoCaptureSetting = {
    quality: camera.QualityLevel.QUALITY_LEVEL_HIGH,
    mirror: cameraDeviceIndex ? true : false
  };
  await this.photoOutput?.capture(photoSettings);
  Logger.info(TAG, 'takePicture end');
}
```


5.设置拍照photoAvailable的回调来获取Photo对象，点击拍照按钮，触发此回调函数，调用getComponent方法根据图像的组件类型从图像中获取组件缓存ArrayBuffer，使用createImageSource方法来创建图片源实例，最后通过createPixelMap获取PixelMap对象。注意:如果已经注册了photoAssetAvailable回调，并且在Session开始之后又注册了photoAvailable回调，会导致流被重启。不建议开发者同时注册photoAvailable和photoAssetAvailable。


```less
photoOutput.on('photoAvailable', (err: BusinessError, photo: camera.Photo) => {
  Logger.info(TAG, 'photoAvailable begin');
  if (err) {
    Logger.error(TAG, `photoAvailable err:${err.code}`);
    return;
  }
  let imageObj: image.Image = photo.main;
  imageObj.getComponent(image.ComponentType.JPEG, (err: BusinessError, component: image.Component) => {
    Logger.info(TAG, `getComponent start`);
    if (err) {
      Logger.error(TAG, `getComponent err:${err.code}`);
      return;
    }
    let buffer: ArrayBuffer = component.byteBuffer;
    let imageSource: image.ImageSource = image.createImageSource(buffer);
    imageSource.createPixelMap((err: BusinessError, pixelMap: image.PixelMap) => {
      if (err) {
        Logger.error(TAG, `createPixelMap err:${err.code}`);
        return;
      }
      this.handlePhotoAssetCb(pixelMap);
    });


  });
})
```


以上代码中执行handleImageInfo函数来对PixelMap进行全局存储并跳转到预览页面。具体代码如下所示：


```less
handleSavePicture = (photoAsset: photoAccessHelper.PhotoAsset | image.PixelMap): void => {
  Logger.info(TAG, 'handleSavePicture');
  this.setImageInfo(photoAsset);
  AppStorage.set<boolean>('isOpenEditPage', true);
  Logger.info(TAG, 'setImageInfo end');
}


setImageInfo(photoAsset: photoAccessHelper.PhotoAsset | image.PixelMap): void {
  Logger.info(TAG, 'setImageInfo');
  GlobalContext.get().setObject('photoAsset', photoAsset);
}
```


6.进入到预览界面，通过GlobalContext.get().getT<image.PixelMap>('imageInfo')方法获取PixelMap信息，并通过Image组件进行渲染显示。


分段式拍照：


分段式拍照是应用下发拍照任务后，系统将分多阶段上报不同质量的图片。在一阶段，系统快速上报低质量图，应用通过on(type: 'photoAssetAvailable', callback: AsyncCallback<photoAccessHelper.PhotoAsset>): void接口会收到一个PhotoAsset对象，通过该对象可调用媒体库接口，读取图片或落盘图片。在二阶段，分段式子服务会根据系统压力以及定制化场景进行调度，将后处理好的原图回传给媒体库，替换低质量图。具体操作步骤如下所示：


由于分段式拍照和单段式拍照步骤1-步骤4相同，就不再进行赘述。


5.设置拍照photoAssetAvailable的回调来获取photoAsset，点击拍照按钮，触发此回调函数，然后执行handlePhotoAssetCb函数来完成photoAsset全局的存储并跳转到预览页面。


```less
photoOutput.on('photoAssetAvailable', (err: BusinessError, photoAsset: photoAccessHelper.PhotoAsset) => {
  Logger.info(TAG, 'photoAssetAvailable begin');
  if (err) {
    Logger.error(TAG, `photoAssetAvailable err:${err.code}`);
    return;
  }
  this.handlePhotoAssetCb(photoAsset);
});
```


以上代码中执行handleImageInfo函数来对photoAsset进行全局存储并跳转到预览页面。具体代码如下所示：


```less
handleSavePicture = (photoAsset: photoAccessHelper.PhotoAsset | image.PixelMap): void => {
  Logger.info(TAG, 'handleSavePicture');
  this.setImageInfo(photoAsset);
  AppStorage.set<boolean>('isOpenEditPage', true);
  Logger.info(TAG, 'setImageInfo end');
}


setImageInfo(photoAsset: photoAccessHelper.PhotoAsset | image.PixelMap): void {
  Logger.info(TAG, 'setImageInfo');
  GlobalContext.get().setObject('photoAsset', photoAsset);
}
```


6.进入预览界面通过GlobalContext.get().getT<image.PixelMap>('imageInfo')方法获取PhotoAsset信息，执行requestImage函数中的photoAccessHelper.MediaAssetManager.requestImageData方法根据不同的策略模式，请求图片资源数据，这里的请求策略为均衡模式BALANCE_MODE， 最后分段式子服务会根据系统压力以及定制化场景进行调度，将后处理好的原图回传给媒体库来替换低质量图。具体代码如下所示：


```less
photoBufferCallback: (arrayBuffer: ArrayBuffer) => void = (arrayBuffer: ArrayBuffer) => {
  Logger.info(TAG, 'photoBufferCallback is called');
  let imageSource = image.createImageSource(arrayBuffer);
  imageSource.createPixelMap((err: BusinessError, data: image.PixelMap) => {
    if (err) {
      Logger.info(TAG, `createPixelMap err:${err.code}`);
      return;
    }
    Logger.info(TAG, 'createPixelMap is called');
    this.curPixelMap = data;
  });
};


requestImage(requestImageParams: RequestImageParams): void {
  try {
    class MediaDataHandler implements photoAccessHelper.MediaAssetDataHandler<ArrayBuffer> {
      onDataPrepared(data: ArrayBuffer, map: Map<string, string>): void {
        Logger.info(TAG, 'onDataPrepared map' + JSON.stringify(map));
        requestImageParams.callback(data);
        Logger.info(TAG, 'onDataPrepared end');
      }
    };
    let requestOptions: photoAccessHelper.RequestOptions = {
      deliveryMode: photoAccessHelper.DeliveryMode.BALANCE_MODE,
    };
    const handler = new MediaDataHandler();
    photoAccessHelper.MediaAssetManager.requestImageData(requestImageParams.context, requestImageParams.photoAsset,
      requestOptions, handler);
  } catch (error) {
    Logger.error(TAG, `Failed in requestImage, error code: ${error.code}`);
  }
}


aboutToAppear() {
  Logger.info(TAG, 'aboutToAppear begin');
  if (this.photoMode === Constants.SUBSECTION_MODE) {
    let curPhotoAsset = GlobalContext.get().getT<photoAccessHelper.PhotoAsset>('photoAsset');
    this.photoUri = curPhotoAsset.uri;
    let requestImageParams: RequestImageParams = {
      context: getContext(),
      photoAsset: curPhotoAsset,
      callback: this.photoBufferCallback
    };
    this.requestImage(requestImageParams);
    Logger.info(TAG, `aboutToAppear photoUri: ${this.photoUri}`);
  } else if (this.photoMode === Constants.SINGLE_STAGE_MODE) {
    this.curPixelMap = GlobalContext.get().getT<image.PixelMap>('photoAsset');
  }
}
```


7.将步骤6获取的PixelMap对象数据通过Image组件进行渲染显示。


总结


通过分段式拍照，确保低质量图可接受的基础上，加快了Shot2See的完成时延，同时第二段保证了高质量照片不损失图片效果，达到与系统相机一致的拍照质量。


示例代码

- 实现相机分段式拍照功能

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-audio-interaction-practice
爬取时间: 2025-05-08 03:36:01
来源: Huawei Developer


概述


对于音频播放类应用，除了歌曲播控的基础能力外，各种交互场景的设计也对用户体验有着重要的影响。本文以音乐播放器应用为例，从应用与用户、播放设备以及其他应用的交互三方面入手，分别对典型使用场景给出示例方案，为应用带来灵活多样、符合用户直觉的交互体验。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152831.13212732422838428246069895265677:50001231000000:2800:E025EDF8F375FFA0D987B74F8DF148039CC60809124B56501E1D84E1FE26D3CC.gif)

场景分析


根据当前HarmonyOS APP开发过程中遇到的实际音频类应用业务场景，总结提炼出如下典型场景，设计其交互功能与方案以供参考：


| 场景分类  | 典型场景  | 场景描述  |
| --- | --- | --- |
| 与用户交互  | 播控中心操控  | 无需进入应用直接通过播控中心操控歌曲状态  |
| 后台播放音乐  | 应用位于后台长时间持续播放音乐  |
| 与音频播放设备交互  | 播放设备的状态发生改变  | 新设备可用、旧设备不可用、用户切换设备场景的适配方案  |
| 响应播放设备的指令  | 蓝牙耳机控制应用播放状态  |
| 用户主动切换播放设备  | 通过投播组件选择播放设备  |
| 与其他应用交互  | 与其他应用音频冲突  | 被其他音频打断、与其他音频并发  |

场景分类


典型场景


场景描述


与用户交互


播控中心操控


无需进入应用直接通过播控中心操控歌曲状态


后台播放音乐


应用位于后台长时间持续播放音乐


与音频播放设备交互


播放设备的状态发生改变


新设备可用、旧设备不可用、用户切换设备场景的适配方案


响应播放设备的指令


蓝牙耳机控制应用播放状态


用户主动切换播放设备


通过投播组件选择播放设备


与其他应用交互


与其他应用音频冲突


被其他音频打断、与其他音频并发


与用户交互


播控中心控制音乐状态


在应用接入播控中心后，用户可以直接通过播控中心修改音频播放状态，如暂停/播放、下一首、切换播放模式、拖动进度条等，应用内的音频信息和状态也会同步显示在播控中心界面上，使得用户与应用的交互更加灵活易用。同时与播控中心交互使用的AVSession还管控着应用的后台播放能力，因此对于音乐类应用一般推荐接入播控中心，具体适用场景可以参考应用接入AVSession场景介绍。


应用与播控中心交互的过程如下图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152831.36569028218888626577580500045743:50001231000000:2800:7F4F751A189C847A208C159B5A37EA1BEB61E6E217826C63397B2E662EA46CE2.png)

由图可见，应用的接入流程可以主要分为三个部分：创建AVSession、监听播控中心通知以及向播控中心上报应用状态，以下分别给出具体实现：


```typescript
import { avSession } from '@kit.AVSessionKit';
// ...
export class AVSessionController {
  private context: common.UIAbilityContext | undefined = undefined;
  private AVSession: avSession.AVSession | undefined = undefined;
  private songList: SongItem[] = [];
  private musicIndex: number | undefined = undefined;
  private audioRendererController: AudioRendererController | undefined = undefined;
  // ...
  private async initAVSession() {
    this.context = AppStorage.get('context');
    if (!this.context) {
      Logger.info(TAG, `session create failed : conext is undefined`);
      return;
    }
    this.audioRendererController = AppStorage.get('audioRendererController');
    if (!this.audioRendererController) {
      Logger.info(TAG, `session create failed : audioRendererController is undefined`);
      return;
    }
    this.AVSession = await avSession.createAVSession(this.context, "PLAY_AUDIO", 'audio');
    await this.AVSession.activate();
    // ...
  }
  // ...
}
```


```less
// 监听播控中心的各种通知如播放、暂停、下一首、调整进度，调用应用对应的方法响应该通知
async setListenerForMesFromController() {
  if (!this.AVSession) {
    return;
  }
  this.AVSession.on('play', this.playCall);
  this.AVSession.on('pause', this.pauseCall);
  this.AVSession.on('playNext', this.playNextCall);
  this.AVSession.on('playPrevious', this.playPreviousCall);
  this.AVSession.on('seek', this.seekCall);
  this.AVSession.on('setLoopMode', this.setLoopModeCall);
  this.AVSession.on('toggleFavorite', this.toggleFavoriteCall);
}
```

1.  适配后效果如图，应用内的歌词、播放进度、收藏状态、循环模式、歌曲信息与播控中心展示状态一致：

```typescript
// 设置收藏状态
private setFavoriteState(isFavorite: boolean) {
  if (this.AVSession) {
    this.AVSession.setAVPlaybackState({ isFavorite }, (err: BusinessError) => {
      if (err) {
        Logger.error(TAG, `SetAVPlaybackState BusinessError: code: ${err.code}, message: ${err.message}`);
      } else {
        Logger.info(TAG, 'SetAVPlaybackState successfully');
      }
    });
  }
}


// 设置进度条状态
public setProgressState(ms: number) {
  if (this.AVSession) {
    this.AVSession.setAVPlaybackState({
      position: {
        elapsedTime: ms,
        updateTime: new Date().getTime()
      }
    }, (err: BusinessError) => {
      if (err) {
        Logger.error(TAG, `SetAVPlaybackState BusinessError: code: ${err.code}, message: ${err.message}`);
      } else {
        Logger.info(TAG, 'SetAVPlaybackState successfully');
      }
    });
  }
}


// 设置播放暂停状态
public setPlayState(isPlay: boolean) {
  if (this.AVSession) {
    this.AVSession.setAVPlaybackState({
      state: isPlay ? avSession.PlaybackState.PLAYBACK_STATE_PLAY : avSession.PlaybackState.PLAYBACK_STATE_PAUSE,
    }, (err: BusinessError) => {
      if (err) {
        Logger.error(TAG, `SetAVPlaybackState BusinessError: code: ${err.code}, message: ${err.message}`);
      } else {
        Logger.info(TAG, 'SetAVPlaybackState successfully');
      }
    });
  }
}
// ...
// 设置循环模式
public async setLoopModeState(AVSessionLoopMode: avSession.LoopMode) {
  if (this.AVSession) {
    this.AVSession.setAVPlaybackState({ loopMode: AVSessionLoopMode }, (err: BusinessError) => {
      if (err) {
        Logger.error(TAG, `SetAVPlaybackState BusinessError: code: ${err.code}, message: ${err.message}`);
      } else {
        Logger.info(TAG, 'SetAVPlaybackState successfully');
      }
    });
  }
}
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152831.23470840045594305546808917405847:50001231000000:2800:0E923097B5EF3D735161E402468E7930EAAC87D6DD7097E85D1A306A2AFF3F4E.png)

后台播放音乐


实现播控中心的接入后，解除了必须进入应用才能调整播放状态的限制，但应用退到后台状态后很快就会被挂起，导致歌曲中断。此时在接入AVSession的基础上还需要申请长时任务，保证歌曲能在后台一直保持播放状态，达到连贯的听歌体验，具体实现方式如下：


```typescript
import { wantAgent, common } from '@kit.AbilityKit';
import { backgroundTaskManager } from '@kit.BackgroundTasksKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { Logger } from './Logger';


const TAG = 'BackgroundUtil';


export class BackgroundUtil {
  // 申请长时后台任务
  public static startContinuousTask(context?: common.UIAbilityContext): void {
    if (!context) {
      Logger.error(TAG, 'startContinuousTask failed', `context undefined`);
      return;
    }
    let wantAgentInfo: wantAgent.WantAgentInfo = {
      wants: [
        {
          bundleName: context.abilityInfo.bundleName,
          abilityName: context.abilityInfo.name
        }
      ],
      operationType: wantAgent.OperationType.START_ABILITY,
      requestCode: 0,
      wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]
    };


    wantAgent.getWantAgent(wantAgentInfo).then((wantAgentObj: Object) => {
      try {
        backgroundTaskManager.startBackgroundRunning(context,
          backgroundTaskManager.BackgroundMode.AUDIO_PLAYBACK, wantAgentObj).then(() => {
          Logger.info('this audioRenderer: ', 'startBackgroundRunning succeeded');
        }).catch((error: BusinessError) => {
          Logger.error('this audioRenderer: ', `startBackgroundRunning failed Cause: code ${error.code}`);
        });
      } catch (error) {
        Logger.error(TAG, `startBackgroundRunning failed.message ${(error as BusinessError).message}`);
      }
    });
  }


  // 停止长时后台任务
  public static stopContinuousTask(context: common.UIAbilityContext): void {
    try {
      backgroundTaskManager.stopBackgroundRunning(context).then(() => {
        Logger.info('this audioRenderer: ', 'stopBackgroundRunning succeeded');
      }).catch((error: BusinessError) => {
        Logger.error('this audioRenderer: ', `stopBackgroundRunning failed Cause: code ${error.code}`);
      });
    } catch (error) {
      Logger.error(TAG, `stopBackgroundRunning failed. message ${(error as BusinessError).message}`);
    }
  }
}
```


```less
// 选歌播放
async play(musicIndex: number = this.musicIndex) {
  if (!this.audioRenderer) {
    return;
  }
  if (musicIndex >= this.songList.length) {
    Logger.error(TAG, `current musicIndex ${musicIndex}`);
    return;
  }
  BackgroundUtil.startContinuousTask(this.context);
  this.updateMusicIndex(musicIndex);
  if (this.isFirst) {
    this.isFirst = false;
    await this.loadSongAssent();
    await this.stop();
    await this.start();
  } else {
    await this.stop();
    this.updateIsPlay(false);
    await this.reset();
  }
}
// ...


// 开始播放
public async start() {
  if (this.audioRenderer) {
    try {
      await this.audioRenderer.start().catch((err: BusinessError) => {
        Logger.error(TAG, `start failed,code is ${err.code},message is ${err.message}}`);
      })
      this.updateIsPlay(true);
      BackgroundUtil.startContinuousTask(this.context);
      Logger.info(TAG, 'start success');
    } catch (e) {
      Logger.error(TAG, `start failed,audioRenderer is undefined`);
    }
  }
}
```


```typescript
// 释放audioRenderer
public async release() {
  if (this.audioRenderer && this.context) {
    try {
      await this.audioRenderer.release().catch((err: BusinessError) => {
        Logger.error(TAG, `release failed,code is ${err.code},message is ${err.message}}`);
      })
      this.avSessionController?.unregisterSessionListener();
      BackgroundUtil.stopContinuousTask(this.context);
      Logger.info(TAG, 'release success');
    } catch (e) {
      Logger.error(TAG, `release failed,audioRenderer is undefined`);
    }
  }
}
```


与播放设备交互


播放设备状态发生改变


当应用连接的播放设备状态发生改变时，需要及时做出对应的处理，从音频流输出目标的切换、音频播放状态的改变到应用界面的更新，都应该与系统行为以及用户直觉相符，来保证交互体验的一致性，以下分别对各种变更场景给出适配方案：

1.  新设备上线时，会触发播放设备自动切换，切换的优先级按下图所示，个人类设备高于公共类设备，同一优先级遵循后入优先原则。因此如果一开始通过扬声器播放，接入耳机后会自动切换至耳机播放，无需应用主动切换。 应用可以通过监听outputDeviceChangeWithInfo事件来感知外放设备的切换，新设备上线对应的变更原因是AudioStreamDeviceChangeReason.REASON_NEW_DEVICE_AVAILABLE，如上所述这种情况切换到新的设备播放的行为是系统行为，应用不需要主动改变输出设备；如果有特殊业务逻辑如接入新设备时暂停播放或者对新接入设备进行管理等，可在此类回调中进行处理。
2.  类型 处理建议 游戏场景 不进行暂停 音乐场景 根据回调进行暂停 听书场景 根据回调进行暂停 视频场景 根据回调进行暂停 应用同样可以监听设备变更事件并对AudioStreamDeviceChangeReason.REASON_OLD_DEVICE_UNAVAILABLE的场景进行处理，在回调中根据当前播放设备类型选择后续行为，例如为扬声器时暂停，为其他设备则继续播放。 注意具有佩戴检测能力的蓝牙耳机入耳、摘下时会通过播控中心分别对应用发送播放和暂停的通知，应用可以通过监听播控中心指令而非设备变更事件来适配此类操作。
3.  当用户通过投播组件主动切换输出设备时，系统会自动切换到新选择的设备播放音频，应用可以对变更原因为AudioStreamDeviceChangeReason.REASON_OVERRODE的事件处理自己的业务逻辑，接入投播组件可以参考主动切换播放设备。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152831.08883659872393287265559862183324:50001231000000:2800:252AFC0BCEE103C5D15AF8CC8590D67DBD1A843FF1CBF64FB3865929928FCCE5.png)

| 类型  | 处理建议  |
| --- | --- |
| 游戏场景  | 不进行暂停  |
| 音乐场景  | 根据回调进行暂停  |
| 听书场景  | 根据回调进行暂停  |
| 视频场景  | 根据回调进行暂停  |

示例代码如下，分别对各种类型的设备状态改变事件做出对应的处理：


```typescript
private setOutputDeviceChangeCallback() {
  if (!this.audioRenderer) {
    return;
  }
  this.audioRenderer.on('outputDeviceChangeWithInfo', this.outputDeviceChangeCallback);
}


private outputDeviceChangeCallback: (deviceChangeInfo: audio.AudioStreamDeviceChangeInfo) => void =
  (deviceChangeInfo: audio.AudioStreamDeviceChangeInfo) => {
    Logger.info(TAG, `DeviceInfo id: ${deviceChangeInfo.devices[0].id}`);
    Logger.info(TAG, `DeviceInfo name: ${deviceChangeInfo.devices[0].name}`);
    Logger.info(TAG, `DeviceInfo address: ${deviceChangeInfo.devices[0].address}`);
    Logger.info(TAG, `Device change reason: ${deviceChangeInfo.changeReason}`);
    if (deviceChangeInfo.changeReason === audio.AudioStreamDeviceChangeReason.REASON_NEW_DEVICE_AVAILABLE) {
      // 新设备可用，应用按需适配业务逻辑
    } else if (deviceChangeInfo.changeReason === audio.AudioStreamDeviceChangeReason.REASON_OLD_DEVICE_UNAVAILABLE) {
      // 旧设备不可用，暂停播放
      Logger.info(TAG, `Device change reason: ${deviceChangeInfo.changeReason}`);
      this.pause();
    } else if (deviceChangeInfo.changeReason === audio.AudioStreamDeviceChangeReason.REASON_OVERRODE) {
      // 用户强选设备，应用按需适配业务逻辑
    }
  }
```


响应播放设备指令


通过有线耳机、蓝牙耳机实现对音频的播放、暂停、上一首、下一首等基本操作，需要应用接入播控中心，并注册播控命令事件监听，以便响应播控中心下发的命令。应用通过蓝牙耳机发送指令与直接点击播控中心控制音频机制相同，因此接入播控中心监听播控指令即可，具体接入过程可参考播控中心控制音乐状态。


用户主动切换播放设备


```less
import { AVCastPicker } from '@kit.AVSessionKit';
import { StyleConstants } from '../common/constants/StyleConstants';
import { BreakpointType } from '../common/utils/BreakpointSystem';


@Component
export struct TopAreaComponent {
  @StorageProp('currentBreakpoint') currentBreakpoint: string = 'sm';


  build() {
    Row() {
      AVCastPicker()
        .width(new BreakpointType({
          sm: $r('app.float.common_image'),
          md: $r('app.float.common_image'),
          lg: $r('app.float.control_image_lg')
        }).getValue(this.currentBreakpoint))
        .height(new BreakpointType({
          sm: $r('app.float.common_image'),
          md: $r('app.float.common_image'),
          lg: $r('app.float.control_image_lg')
        }).getValue(this.currentBreakpoint))
    }
    .height($r('app.float.info_margin_top_sm'))
    .width(StyleConstants.FULL_WIDTH)
    .justifyContent(FlexAlign.End)
  }
}
```


将投播组件布局在页面的合理位置，点击选择音频输出设备，如图所示可以从本机扬声器切换到已连接的蓝牙耳机：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152831.63930978164210378330657901288489:50001231000000:2800:1E278E898F098E24A04B670425F6C365103EF6D6E22F3F0763C775A098B752DF.gif)

与其他应用交互


与其他应用音频冲突


当与其他应用的音频发生冲突，多个音频流同时播放时，系统预设了音频打断策略，对多音频的并发进行管控，只有持有音频焦点的音频流才可以正常播放，避免多个音频流无序并发播放的现象出现。为了维持应用和系统的状态一致性，保证符合用户直觉的交互体验，推荐应用处理音频焦点变化，并在收到音频打断事件（InterruptEvent）时做出相应处理。对于音乐类应用，被各种处理音频焦点变化类型的其他应用音频打断场景和效果如下表所示：


| 先播应用音频类型  | 后播应用音频类型  | 打断效果  |
| --- | --- | --- |
| 音乐  | 闹钟  | 后播应用播放时，先播应用暂停播放；后播应用停止播放后，先播应用恢复播放  |
| 电话  |
| 铃声  |
| VOIP 铃声(全屏呼叫/呼叫页面/横幅呼叫)  |
| VOIP 通话  |
| VOIP MESSAGE(微信语音/畅联)  |
| 导航  | 后播应用播放时，先播应用降低音量持续播放；后播应用停止播放后，先播应用恢复音量继续播放  |
| TextReader控件朗读语音  |
| 语音助手类短语音  |
| 音乐  | 后播应用播放时，先播应用停止播放；后播应用停止播放后，先播应用不再恢复播放  |
| 视频  |
| 游戏  | 先播、后播应用并发混音播放  |
| 系统音效(锁屏/按键)  |

先播应用音频类型


后播应用音频类型


打断效果


音乐


闹钟


后播应用播放时，先播应用暂停播放；后播应用停止播放后，先播应用恢复播放


电话


铃声


VOIP 铃声(全屏呼叫/呼叫页面/横幅呼叫)


VOIP 通话


VOIP MESSAGE(微信语音/畅联)


导航


后播应用播放时，先播应用降低音量持续播放；后播应用停止播放后，先播应用恢复音量继续播放


TextReader控件朗读语音


语音助手类短语音


音乐


后播应用播放时，先播应用停止播放；后播应用停止播放后，先播应用不再恢复播放


视频


游戏


先播、后播应用并发混音播放


系统音效(锁屏/按键)


如表所示，根据应用打断效果主要可以分为四个类型：暂停后恢复、降低音量后恢复、停止后不恢复和并发播放，以下分别对这四类场景给出适配方案：

1.  后播音频类型为闹钟/电话/铃声/VOIP音频时，先播音频暂停播放；待后播音频播放完毕后，先播音频恢复播放。应用可以注册焦点事件监听，当此类打断事件发生时，系统会自动暂停先播音频，应用侧会接收到INTERRUPT_HINT_PAUSE事件，此时只需更新播放和UI界面状态为暂停态即可，不需要主动停止音频流。当后播音频结束后，应用接收到INTERRUPT_HINT_RESUME事件，此时系统不会主动继续播放先播音频，应用需主动调用播放方法续播音频流。
2.  当后播应用音频类型为导航/TextReader语音/语音助手类语音播报时，先播音频应降低音量持续播放；后播音频播报结束后，先播音频恢复音量继续播放。注意此类打断事件的音量降低/恢复行为是系统行为，应用无需主动调整音量。在降低音量和恢复时会分别收到INTERRUPT_HINT_DUCK和INTERRUPT_HINT_UNDUCK回调，应用可以在回调中按需更新页面状态或处理其他业务逻辑。
3.  当后播应用音频类型为音乐/视频时，音乐终止播放；后播音频停止后，音乐不恢复播放。应用可以注册焦点事件监听，接收到INTERRUPT_HINT_STOP事件时，停止音乐播放，并更新UI界面。
- 当后播应用音频类型为游戏或系统提示音（锁屏、按键）时，先播音频不停止，与后播音频混音并发播放。此行为是系统默认行为，应用侧不需要适配。
- 如果是音乐音频于后台播放，前台音视频静音并发播放的场景，则需要前台应用使用setSilentModeAndMixWithOthers接口开启静音并发模式，否则系统会根据音频流类型默认触发对应打断场景。当前台音视频取消静音播放时，setSilentModeAndMixWithOthers()接口关闭静音并发模式，同时使用activateAudioSession激活音频会话（AudioSession）并指定音频会话策略为暂停模式（CONCURRENCY_PAUSE_OTHERS），使后台音频处于暂停模式，当前台再次开启静音并发模式时，可以使后台音频恢复播放。

综上四种情况，在audioRenderer.on('audioInterrupt')回调中分别对各种打断类型场景做出对应处理，并实现静音播放接口及设置音频会话策略为暂停模式，示例代码实现如下：


```typescript
// 监听音频打断事件
private setInterruptCallback() {
  if (!this.audioRenderer) {
    return;
  }
  this.audioRenderer.on('audioInterrupt', this.interruptCallback);
}


// 在回调中处理各类打断事件
private interruptCallback: (interruptEvent: audio.InterruptEvent) => void =
  (interruptEvent: audio.InterruptEvent) => {
    if (interruptEvent.forceType === audio.InterruptForceType.INTERRUPT_FORCE) {
      switch (interruptEvent.hintType) {
        case audio.InterruptHint.INTERRUPT_HINT_PAUSE:
          // 此分支表示系统已将音频流暂停（临时失去焦点），为保持状态一致，应用需切换至音频暂停状态
          // 临时失去焦点：待其他音频流释放音频焦点后，本音频流会收到resume对应的音频打断事件，到时可自行继续播放
          this.updateIsPlay(false);
          break;
        case audio.InterruptHint.INTERRUPT_HINT_STOP:
          // 此分支表示系统已将音频流停止（永久失去焦点），为保持状态一致，应用需切换至音频暂停状态
          // 永久失去焦点：后续不会再收到任何音频打断事件，若想恢复播放，需要用户主动触发。
          this.updateIsPlay(false);
          this.pause();
          break;
        case audio.InterruptHint.INTERRUPT_HINT_DUCK:
          // 此分支表示系统已将音频音量降低（默认降到正常音量的20%）
          // 此时应用可以处理当音量降低时的业务逻辑
          break;
        case audio.InterruptHint.INTERRUPT_HINT_UNDUCK:
          // 此分支表示系统已将音频音量恢复正常
          // 此时应用可以处理当音量恢复时的业务逻辑
          break;
        default:
          break;
      }
    } else if (interruptEvent.forceType === audio.InterruptForceType.INTERRUPT_SHARE) {
      switch (interruptEvent.hintType) {
        case audio.InterruptHint.INTERRUPT_HINT_RESUME:
          // 此分支表示临时失去焦点后被暂停的音频流此时可以继续播放，建议应用继续播放，切换至音频播放状态
          // 若应用此时不想继续播放，可以忽略此音频打断事件，不进行处理即可
          this.start();
          break;
        default:
          break;
      }
    }
  }
// ...
// 通过用户首选项数据设置静音并发模式
private async setSilentModeAndMixWithOthersFromPrefer() {
  if (!this.audioRenderer || !this.context) {
    return;
  }
  let formIds: string[] = await PreferencesUtil.getInstance().getFormIds(this.context);
  let isSupportSilent = false;
  if (formIds.includes(SILENT_ID)) {
    isSupportSilent = true;
  } else {
    isSupportSilent = false;
  }
  AppStorage.setOrCreate('isSilentMode', isSupportSilent);
  this.audioRenderer.setSilentModeAndMixWithOthers(isSupportSilent);
}


// 通过按钮设置静音并发模式
public async setSilentModeAndMixWithOthers(isSupportSilent: boolean = false) {
  if (!this.audioRenderer || !this.context) {
    return;
  }
  let audioManger = audio.getAudioManager();
  let audioSessionManager: audio.AudioSessionManager = audioManger.getSessionManager();
  let strategy: audio.AudioSessionStrategy = {
    concurrencyMode: audio.AudioConcurrencyMode.CONCURRENCY_PAUSE_OTHERS
  };


  let formIds: string[] = await PreferencesUtil.getInstance().getFormIds(this.context);
  if (isSupportSilent) {
    if (!formIds.includes(SILENT_ID)) {
      await PreferencesUtil.getInstance().addFormId(this.context, SILENT_ID);
    }
    this.audioRenderer.setSilentModeAndMixWithOthers(isSupportSilent);
    // 停用AudioSession后，系统发INTERRUPT_HINT_RESUME给之前被打断的音频流
    audioSessionManager.deactivateAudioSession().then(() => {
      Logger.info(TAG, 'deactivateAudioSession SUCCESS');
    }).catch((err: BusinessError) => {
      Logger.error(TAG, `ERROR: ${err}`);
    });
  } else {
    // 需要先激活AudioSession，再解除静音
    audioSessionManager.activateAudioSession(strategy).then(() => {
      Logger.info(TAG, 'activateAudioSession SUCCESS');
    }).catch((err: BusinessError) => {
      Logger.error(TAG, `ERROR: ${err}`);
    });
    if (formIds.includes(SILENT_ID)) {
      await PreferencesUtil.getInstance().removeFormId(this.context, SILENT_ID);
    }
    this.audioRenderer.setSilentModeAndMixWithOthers(isSupportSilent);
  }
  AppStorage.setOrCreate('isSilentMode', isSupportSilent);
}
```


检测应用音频冲突适配完整性


这里提供了一个音频检测应用，开发者可以用来检测自己开发的音频应用在不同场景下的功能完备度和准确性等，帮助开发者修复音频焦点类的应用功能问题。


示例代码

- 基于AudioRenderer的音频播控和多场景交互

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-video-playback-development-practice
爬取时间: 2025-05-08 03:36:07
来源: Huawei Developer


概述


本文适用于视频播放类应用的开发，针对市场上主流视频播放类应用的常见场景，介绍了如何基于HarmonyOS能力快速实现视频播放应用。


从用户交互和音频流状态变更两个维度，指导开发者基于HarmonyOS提供的媒体和ArkUI等能力，实现视频前后台播放控制、播放形态切换、音频焦点切换、播放设备切换等场景，可以为视频播放应用提供灵活的交互体验和良好的观看效果。


在阅读本文之前，建议开发者先熟悉视频播放器《AVPlayer实现》，如果应用希望实现短视频播放功能，还需要参考《在线短视频流畅切换》。


场景分析


| 场景名称  | 子场景名称  | 描述  | 实现方案  |
| --- | --- | --- | --- |
| 与用户交互   | 播放进度控制  | 进度条控制。  | 使用Slider组件实现进度条，在其onChange回调中触发进度调节。  |
| 手势调节播放进度。  | 通过给组件绑定手势识别，来实现手势调节播放进度。  |
| 显示进度条弹窗。  | 给进度条添加Popup弹窗。  |
| 播放形态切换  | 横竖屏切换。  | 基于窗口能力实现全屏播放。  |
| 悬浮窗播放。  | 应用布局适配智慧多窗。  |
| 播控中心控制视频状态  | 应用响应播控中心通知，向播控中心同步视频信息状态。  | 监听AVSession播放状态事件。  |
| 视频后台播放  | 应用至于后台时可以继续播放。  | 基于AVSession Kit和Background Tasks Kit申请长时任务。  |
| 滑动调节音量及亮度  | 视频全屏播放时，可以滑动屏幕调节音量及亮度。  | 使用AVVolumePanel组件控制音量，使用Slider组件及setWindowBrightness方法控制亮度。  |
| 音频流状态变更  | 多音频并发打断  | 视频应用被其他应用的音频打断做出对应的行为。  | AVPlayer监听音频打断事件。  |
| 播放设备切换  | 视频应用连接的播放设备状态发生变更时做出对应的行为。  | AVPlayer监听设备音频流输出变化。  |

场景名称


子场景名称


描述


实现方案


与用户交互


播放进度控制


进度条控制。


使用Slider组件实现进度条，在其onChange回调中触发进度调节。


手势调节播放进度。


通过给组件绑定手势识别，来实现手势调节播放进度。


显示进度条弹窗。


给进度条添加Popup弹窗。


播放形态切换


横竖屏切换。


基于窗口能力实现全屏播放。


悬浮窗播放。


应用布局适配智慧多窗。


播控中心控制视频状态


应用响应播控中心通知，向播控中心同步视频信息状态。


监听AVSession播放状态事件。


视频后台播放


应用至于后台时可以继续播放。


基于AVSession Kit和Background Tasks Kit申请长时任务。


滑动调节音量及亮度


视频全屏播放时，可以滑动屏幕调节音量及亮度。


使用AVVolumePanel组件控制音量，使用Slider组件及setWindowBrightness方法控制亮度。


音频流状态变更


多音频并发打断


视频应用被其他应用的音频打断做出对应的行为。


AVPlayer监听音频打断事件。


播放设备切换


视频应用连接的播放设备状态发生变更时做出对应的行为。


AVPlayer监听设备音频流输出变化。


与用户交互


播放进度控制


进度条控制


进度条作为视频应用的一个基础能力，可以通过点击或拖动进度条来调节视频播放进度。采用Slider组件实现进度条功能，根据Slider组件属性设置进度条样式，并在其onChange()事件中触发视频播放器AVPlayer的seek()方法，实现视频进度的控制。


```less
Slider({
  value: this.isSliderGesture ? this.panEndTime : this.avPlayerController.currentTime,
  step: 0.1,
  min: 0,
  max: this.avPlayerController.durationTime,
  style: this.sliderStyle
})
  // ...
  .trackColor($r('app.color.white_opacity_1_color')) // 滑轨背景颜色
  .showSteps(false) // 是否显示步长刻度
  .blockSize({ width: this.blockSize, height: this.blockSize }) // 滑块大小
  .blockColor($r('sys.color.background_primary')) // 滑块颜色
  .trackThickness(this.trackThicknessSize) // 滑轨粗细
  .trackBorderRadius(2) // 底板圆角半径
  .selectedBorderRadius(2) // 已滑动部分圆角半径
  // ...
  .onChange((value: number, mode: SliderChangeMode) => {
    this.sliderOnchange(value, mode); // 进度条变化接口
  })


sliderOnchange(seconds: number, mode: SliderChangeMode) {
  let seekTime: number = seconds * this.avPlayerController.duration / this.avPlayerController.durationTime;
  this.currentStringTime = secondToTime(Math.floor(seekTime / 1000));
  this.avPlayerController.setCurrentStringTime(this.currentStringTime);
  switch (mode) {
    case SliderChangeMode.Begin:
      break;
    case SliderChangeMode.Click:
      break;
    case SliderChangeMode.Moving:
      // ...
      break;
    case SliderChangeMode.End:
      this.avPlayerController.seek(seekTime); // 调用AVPlayer的seek方法控制播放进度
      // ...
      break;
    default:
      break;
  }
}
```


手势调节播放进度


通常视频播放应用还可以支持手势滑动来调节播放的进度，可以给组件绑定手势识别，来实现在视频界面左右滑动调节视频播放进度的能力，手势类型选择PanGesture（平移手势）。


```less
build() {
  Stack({ alignContent: Alignment.BottomEnd }) {
    // ...
    XComponent({
      id: 'XComponent',
      type: XComponentType.SURFACE,
      controller: this.xComponentController
    })
    // ...
  }
   // ...
  .gesture(
    PanGesture({ direction: PanDirection.Horizontal })
      .onActionStart((event: GestureEvent) => {
        this.isSliderGesture = true;
        this.panStartX = event.offsetX;
        this.panStartTime = this.avPlayerController.currentTime;
        this.sliderOnchange(this.panStartTime, SliderChangeMode.Begin);
      })
      .onActionUpdate((event: GestureEvent) => {
        this.isSliderGesture = true;
        let panTime =
          this.panStartTime +
            (this.panStartX + event.offsetX) / this.slideWidth * this.avPlayerController.durationTime;
        this.panEndTime = Math.min(Math.max(0, panTime), this.avPlayerController.durationTime);
        this.sliderOnchange(this.panEndTime, SliderChangeMode.Moving);
      })
      .onActionEnd(() => {
        this.sliderOnchange(this.panEndTime, SliderChangeMode.End);
        this.isSliderGesture = false;
      })
  )
}
```


显示进度条弹窗


在正常浏览视频的过程中，应用会记录用户的浏览历史，当再次切换到原视频时，根据历史数据在进度条上以弹窗的形式显示相关信息。并且让弹窗跟随滑块位置移动，弹窗保留1秒后消失。同时历史数据的保留跟随视频组件的生命周期存亡。


由于Slider自带的showTips无法对弹窗样式进行自定义，只支持圆形气泡，且无法自定义控制弹窗的显示时长和出现时机。所以我们通过创建一个和Slider滑块大小一致的透明Stack，并计算滑块在屏幕中的位置，将计算的位置数据同步设置给Stack，并给Stack绑定Popup弹窗跟随Slider滑块运动。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152831.03091812161107005842169212471555:50001231000000:2800:2E36A85226C91CB62559D113E1AF2874E02DFABB268CA761768FE60E329C4657.png)

关键代码：


通过给Slider组件绑定区域变化事件onAreaChange()，计算滑动位置信息。


```less
// Slider进度条
Slider({
  value: this.isSliderGesture ? this.panEndTime : this.avPlayerController.currentTime,
  step: 0.1,
  min: 0,
  max: this.avPlayerController.durationTime,
  style: this.sliderStyle
})
  // ...
  .blockSize({ width: this.blockSize, height: this.blockSize })
  // 计算滑块位置
  .onAreaChange(() => {
    let videoSlider: componentUtils.ComponentInfo = componentUtils.getRectangleById('video_slider')
    this.slideWidth = px2vp(videoSlider.size.width);
    // 计算offsetY：Slider滑块位置的纵坐标
    this.offsetY = px2vp(videoSlider.localOffset.y);
    this.beginX = px2vp(videoSlider.localOffset.x);
  })
  // 进度条变化时最终会调用avPlayer.seek()接口
  .onChange((value: number, mode: SliderChangeMode) => {
    this.sliderOnchange(value, mode);// 进度条变化时会调用avPlayer.seek()接口
  })
```


Stack透明块大小、位置设置以及给Stack绑定Popup弹窗。


```less
// 设置和Slider大小一样的透明stack块
Stack() {
}
.backgroundColor($r('sys.color.background_primary'))
.width(this.blockSize)
.height(this.blockSize)
.borderRadius($r('app.float.font_size_20'))
.visibility(this.isShowTips ? Visibility.Visible : Visibility.None)
.position({ x: this.tipsOffset, y: this.offsetY })
// 将Popup绑定到Stack块上，跟随Slider滑块运动
.bindPopup(this.isShowTips, {
  builder: this.popupBuilder,
  placement: Placement.Top,
  mask: false,
  arrowOffset: 0,
  popupColor: $r('sys.color.background_primary'),
  backgroundBlurStyle: BlurStyle.BACKGROUND_ULTRA_THICK,
  enableArrow: true,
  arrowPointPosition: ArrowPointPosition.CENTER,
  radius: this.blockSize,
})
```


播放形态切换


横竖屏切换


横竖屏切换是视频应用常见的功能，用户会根据自己喜好选择在横屏或竖屏模式下观看。


设置窗口旋转策略有两种方式：


这两种方式触发设置旋转的时机不同，module.json5文件中的字段在窗口启动时就会生效，对于应用启动时就需要设置横屏或者竖屏的应用，可以进行配置。而setPreferredOrientation()是在调用该方法时进行窗口方向的设置，用于在应用启动之后，还需要改变显示方向的场景。


本示例主要介绍通过使用窗口的setPreferredOrientation()方法来实现应用的横竖屏切换能力，下面给出具体实现方案，更多详情可参考横竖屏开发实践。

1.  当进入首页视频列表时，仅支持竖屏，要切换视频播放页面为横屏时，采用window窗口能力，通过setPreferredOrientation()将窗口显示的方向修改为横屏、竖屏的状态。在使用时，根据应用自身的旋转策略选择相应的参数。窗口显示方向类型枚举可以参考：window.Orientation。

```less
// 根据应用自身的旋转策略选择相应的参数
setMainWindowOrientation(orientation: window.Orientation, callback?: Function): void {
  // ...
  this.mainWindowClass.setPreferredOrientation(orientation).then(() => {
    callback?.();
  }).catch((err: BusinessError) => {
    hilog.error(0x0001, TAG, `Failed to set the ${orientation} of main window. Code:${err.code}, message:${err.message}`);
  });
}
```

2.  当用户手动设置窗口方向时，窗口的显示会发生变化，对应窗口的size也会发生改变，此时可以通过拿到窗口的宽高，并对宽高进行对比，判断当前显示是竖屏还是横屏状态，并利用该数据对布局进行适配。监听窗口尺寸的变化可以通过window.on('windowSizeChange')进行实现。

```less
// 在aboutToAppear中开启窗口尺寸监听
async aboutToAppear(): Promise<void> {
  let context = getContext(this);
  let windowClass = await window.getLastWindow(context);
  // ...
  // 注册窗口尺寸监听
  this.windowUtil.registerOnWindowSizeChange((size) => {
    if (size.width > size.height) {
      // 横屏逻辑
      this.isFullLandscapeScreen = true;
    } else {
      // 竖屏逻辑
      this.isFullLandscapeScreen = false;
    }
  });
}


registerOnWindowSizeChange(callback?: (size: window.Size) => void) {
  // ...
  this.mainWindowClass.on('windowSizeChange', (size) => {
    // 由于在手机中应用窗口真实宽度为屏幕宽度，故不需再改变宽度
    AppStorage.setOrCreate('deviceHeight', size.height);
    callback?.(size);
  });
}
```


悬浮窗播放


视频应用添加悬浮窗能力，可以让用户在观看视频时，临时处理另一个任务或短时间多任务并行使用，如边看视频边浏览网页等行为，更多可参考应用布局适配智慧多窗。

1.  首先需要通过对module.json5配置文件中abilities标签下的supportWindowMode属性增加“floating”字段或使用缺省值以声明应用支持悬浮窗。 因为本视频应用需要支持横向和竖向悬浮窗两种能力，所以还需对abilities标签下的preferMultiWindowOrientation属性设置为landscape_auto，来标识当前UIAbility组件多窗布局方向。

```less
"abilities": [
  {
    // ...
    "preferMultiWindowOrientation": "landscape_auto"
  }
]
```

2.  由于应用从全屏进入悬浮窗后，应用的窗口尺寸会发生变化，所以应用需要根据不同的窗口尺寸调整自身布局。可以通过窗口的on('windowSizeChange')方法实现对窗口尺寸大小变化的监听。再根据窗口的尺寸变化，更新调整自身应用布局以实现适配。

```less
onWindowStageCreate(windowStage: window.WindowStage): void {
  // ...
  WindowUtil.getInstance().setWindowStage(windowStage);
  // ...
}
```


```less
onWindowStageCreate(windowStage: window.WindowStage): void {
  // ...
  WindowUtil.getInstance().setWindowStage(windowStage);
  // ...
}
```


```typescript
public setWindowStage(windowStage: window.WindowStage): void {
  this.windowStage = windowStage;
  this.windowStage.getMainWindow((err, windowClass: window.Window) => {
    // ...
    this.mainWindowClass = windowClass;
    const properties = windowClass.getWindowProperties(); // 获取窗口信息
    // ...
    AppStorage.setOrCreate('deviceWidth', properties.windowRect.width); // 设置窗口宽度
    AppStorage.setOrCreate('deviceHeight', properties.windowRect.height); // 设置窗口高度
    // ...
  });
}
```


```less
registerOnWindowSizeChange(callback?: (size: window.Size) => void) {
  // ...
  this.mainWindowClass.on('windowSizeChange', (size) => {
    // 由于在手机中应用窗口真实宽度为屏幕宽度，故不需再改变宽度
    AppStorage.setOrCreate('deviceHeight', size.height);
    callback?.(size);
  });
}
```


```less
@Entry
@Component
struct IndexPage {
  @State isFloatWindow: boolean = false;
  @StorageProp('deviceHeight') @Watch('onWindowSizeChange') deviceHeight: number = AppStorage.get<number>('deviceHeight') || 0;
  // ...
}
```


```less
// 因为悬浮窗宽高为系统默认，所以此处只根据窗口高度来处理isFloatWindow（是否显示悬浮窗）的值，用来控制界面组件的显隐
onWindowSizeChange() {
  let deviceWidth = AppStorage.get<number>('deviceWidth') || 0;
  // 判断是否是横屏或竖屏悬浮窗
  if (this.isFullLandscapeScreen && Math.round((this.deviceHeight / deviceWidth) * 1000) / 1000 === 0.563) {
    this.isFloatWindow = true;
  } else if (this.isFullScreen &&
    (Math.round((deviceWidth / this.deviceHeight) * 1000) / 1000 === 0.563 || Math.round((deviceWidth / this.deviceHeight) * 10) / 10 === 0.6)) {
    this.isFloatWindow = true;
  } else {
    this.isFloatWindow = false;
  }
}
build() {
  // ...
  VideoPlayer({
    // ...
    isFloatWindow: this.isFloatWindow,
    // ...
  })
  // ...
}
```


```less
onWindowStageCreate(windowStage: window.WindowStage): void {
  // ...
  WindowUtil.getInstance().setWindowStage(windowStage);
  // ...
}
```


```typescript
public setWindowStage(windowStage: window.WindowStage): void {
  this.windowStage = windowStage;
  this.windowStage.getMainWindow((err, windowClass: window.Window) => {
    // ...
    this.mainWindowClass = windowClass;
    const properties = windowClass.getWindowProperties(); // 获取窗口信息
    // ...
    AppStorage.setOrCreate('deviceWidth', properties.windowRect.width); // 设置窗口宽度
    AppStorage.setOrCreate('deviceHeight', properties.windowRect.height); // 设置窗口高度
    // ...
  });
}
```


```less
registerOnWindowSizeChange(callback?: (size: window.Size) => void) {
  // ...
  this.mainWindowClass.on('windowSizeChange', (size) => {
    // 由于在手机中应用窗口真实宽度为屏幕宽度，故不需再改变宽度
    AppStorage.setOrCreate('deviceHeight', size.height);
    callback?.(size);
  });
}
```


```less
@Entry
@Component
struct IndexPage {
  @State isFloatWindow: boolean = false;
  @StorageProp('deviceHeight') @Watch('onWindowSizeChange') deviceHeight: number = AppStorage.get<number>('deviceHeight') || 0;
  // ...
}
```


```less
// 因为悬浮窗宽高为系统默认，所以此处只根据窗口高度来处理isFloatWindow（是否显示悬浮窗）的值，用来控制界面组件的显隐
onWindowSizeChange() {
  let deviceWidth = AppStorage.get<number>('deviceWidth') || 0;
  // 判断是否是横屏或竖屏悬浮窗
  if (this.isFullLandscapeScreen && Math.round((this.deviceHeight / deviceWidth) * 1000) / 1000 === 0.563) {
    this.isFloatWindow = true;
  } else if (this.isFullScreen &&
    (Math.round((deviceWidth / this.deviceHeight) * 1000) / 1000 === 0.563 || Math.round((deviceWidth / this.deviceHeight) * 10) / 10 === 0.6)) {
    this.isFloatWindow = true;
  } else {
    this.isFloatWindow = false;
  }
}
build() {
  // ...
  VideoPlayer({
    // ...
    isFloatWindow: this.isFloatWindow,
    // ...
  })
  // ...
}
```


播控中心控制视频状态


用户除了在视频界面控制视频状态外，还可以通过给应用接入AVSession播控中心，使用户在播控中心也能看到当前播放视频的信息，并通过播控中心直接对视频进行快进、快退、拖动进度、播放暂停、切换、调节音量等操作。同时应用内的视频状态与信息也会与播控中心相互同步，避免了只有在视频界面才能控制视频状态的单一场景，更多详情可参考应用接入AVSession场景介绍。

1.  在AvSessionController初始化时，通过createAVSession()创建AVSession实例并激活媒体会话，视频应用选择会话类型为video。开发者可根据应用的类型选择对应的会话。

```less
import { avSession } from '@kit.AVSessionKit';


export class AvSessionController {
  private avSession: avSession.AVSession | undefined = undefined;


  public initAvSession() {
    this.context = AppStorage.get('context');
    if (!this.context) {
      hilog.info(0x0001, TAG, "session create failed : context is undefined");
      return;
    }
    // 创建AVSession，会话类型设置为'video'
    avSession.createAVSession(this.context, "SHORT_AUDIO_SESSION", 'video').then(async (avSession) => {
      this.avSession = avSession;
      hilog.info(0x0001, TAG, `session create successed : sessionId : ${this.avSession.sessionId}`);
      // 设置用于被播控中心拉起的UIAbility
      this.setLaunchAbility();
      // 激活媒体会话
      this.avSession.activate();
    });
  }
}
```

2.  应用可以通过setAVMetadata()把会话的一些元数据信息设置给系统，从而在播控中心界面进行展示。如媒体ID（assetId）、标题（title）、播控中心显示的图片（mediaImage）、媒体时长（duration）等。

```less
public async setAVMetadata(curSource: VideoData, duration: number) {
  // ...
  const imagePixMap = await ImageUtil.getPixmapFromMedia(curSource.head);
  let metadata: avSession.AVMetadata = {
    assetId: `${curSource.index}`, // 媒体ID
    title: this.context?.resourceManager.getStringSync(curSource.name), // 标题
    mediaImage: imagePixMap, // 图片的像素数据或者图片路径地址
    duration: duration // 媒体时长，单位毫秒（ms）
  };
  if (this.avSession) {
    this.avSession.setAVMetadata(metadata).then(() => { // 调用设置会话元数据接口
      this.avSessionMetadata = metadata;
      hilog.info(0x0001, TAG, "SetAVMetadata successfully");
    }).catch((err: BusinessError) => {
      hilog.error(0x0001, TAG, `SetAVMetadata BusinessError: code: ${err.code}, message: ${err.message}`);
    });
  }
}
```

3.  当用户操作媒体会话控制方的界面时，例如点击播控中心的卡片，可以拉起此处配置的UIAbility。将封装的WantAgent通过setLaunchAbility()配置给媒体会话，更多关于WantAgent的信息请参考WantAgent。

```less
private setLaunchAbility() {
  // ...
  const wantAgentInfo: wantAgent.WantAgentInfo = {
    wants: [
      {
        bundleName: this.context.abilityInfo.bundleName, // 待启动Ability所在的应用Bundle名称
        abilityName: this.context.abilityInfo.name // 待启动Ability名称
      }
    ],
    operationType: wantAgent.OperationType.START_ABILITIES, // 动作类型，START_ABILITY 表示开启多个有页面的Ability
    requestCode: 0, // 使用者定义的一个私有值
    wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG] // 动作执行属性，UPDATE_PRESENT_FLAG 表示使用新的WantAgent的额外数据替换已存在的WantAgent中的额外数据
  };
  wantAgent.getWantAgent(wantAgentInfo).then((agent) => {
    if (this.avSession) {
      this.avSession.setLaunchAbility(agent);
    }
  });
}
```

4.  便于响应用户通过播控中心下发的播控命令，比如播放、暂停、停止、快进、快退等。同时只有设置了相关的事件回调，播控中心上对应的按钮才会亮起，否则为置灰状态。

```less
public async setAvSessionListener() {
  if (!this.avSessionController) {
    return;
  }
  this.avSessionController.getAvSession()?.on('play', () => this.sessionPlayCallback()); // 设置播放命令监听事件
  this.avSessionController.getAvSession()?.on('pause', () => this.sessionPauseCallback()); // 设置暂停命令监听事件
  this.avSessionController.getAvSession()?.on('stop', () => this.sessionStopCallback()); // 设置停止命令监听事件
  this.avSessionController.getAvSession()?.on('fastForward', (time?: number) => this.sessionFastForwardCallback(time)); // 设置快进命令监听事件
  this.avSessionController.getAvSession()?.on('rewind', (time?: number) => this.sessionRewindCallback(time)); // 设置快退命令监听事件
  this.avSessionController.getAvSession()?.on('seek', (seekTime: number) => this.sessionSeekCallback(seekTime)); // 设置跳转节点监听事件
}
```

5.  当视频状态发生改变时，需要通过setAVPlaybackState()向播控中心上报视频状态，来达到播控中心与应用的状态同步，包括播放状态（state）、播放位置（position）、当前媒体播放时长（duration）等。

```less
private updateIsPlay(isPlay: boolean) {
  if (this.curIndex !== this.curSource.index) {
    return;
  }
  this.isPlaying = isPlay;
  this.avSessionController.setAvSessionPlayState({
    state: isPlay ? avSession.PlaybackState.PLAYBACK_STATE_PLAY : avSession.PlaybackState.PLAYBACK_STATE_PAUSE, //播放状态
    position: { // 播放位置
      elapsedTime: this.currentTime * 1000, // 已用时间，单位毫秒（ms）
      updateTime: new Date().getTime() // 更新时间，单位毫秒（ms）
    },
    duration: this.duration // 当前媒体资源的时长
  });
}


public setAvSessionPlayState(playbackState: avSession.AVPlaybackState) {
  if (this.avSession) {
    this.avSession.setAVPlaybackState(playbackState, (err: BusinessError) => {
      if (err) {
        hilog.error(0x0001, TAG, `SetAVPlaybackState BusinessError: code: ${err.code}, message: ${err.message}`);
      } else {
        hilog.info(0x0001, TAG, "SetAVPlaybackState successfully");
      }
    });
  }
}
```


视频后台播放


用户在观看视频时，会遇到退出视频应用至后台的情况。当应用退到后台时，应用进程很快就会被挂机，所以为满足视频可以在后台持续播放的能力，需要对视频应用申请长时任务，来防止应用进程挂起。同时配合AVSession播控能力，用户可以做到在后台直接与视频应用进行交互，达到更加灵活的体验效果。更多可参考Background Tasks Kit。


只有使用了媒体会话服务（AVSession）的音视频应用，才能申请长时任务实现后台播放。


接入流程和关键代码

1.  在module.json5配置文件中申请ohos.permission.KEEP_BACKGROUND_RUNNING权限和配置后台模式audioPlayback。

```less
"requestPermissions": [
  {
    "name": "ohos.permission.KEEP_BACKGROUND_RUNNING",
    "reason": "$string:reason_background",
    "usedScene": {
      "abilities": [
        "EntryAbility"
      ],
      "when": "always"
    }
  }
],


"abilities": [
  {
    "backgroundModes": [
      "audioPlayback"
    ],
  }
],
```

2.  通过获取到的UIAbility上下文和wantAgent模块下getWantAgent()方法获取WantAgent对象，使用BackgroundTasksKit的startBackgroundRunning()、stopBackgroundRunning()方法分别申请和取消后台运行任务，长时任务类型选择AUDIO_PLAYBACK，表示视频后台播放。

```less
import { common, wantAgent } from '@kit.AbilityKit';
import { backgroundTaskManager } from '@kit.BackgroundTasksKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';


const TAG = '[BackgroundTaskManager]';


/**
 * Background task tool class.
 */
export class BackgroundTaskManager {
  public static startContinuousTask(context?: common.UIAbilityContext): void {
    if (!context) {
      return;
    }
    let wantAgentInfo: wantAgent.WantAgentInfo = {
      wants: [
        {
          bundleName: context.abilityInfo.bundleName,
          abilityName: context.abilityInfo.name
        }
      ],
      operationType: wantAgent.OperationType.START_ABILITY,
      requestCode: 0,
      wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]
    };


    wantAgent.getWantAgent(wantAgentInfo).then((wantAgentObj) => {
      backgroundTaskManager.startBackgroundRunning(context,
        backgroundTaskManager.BackgroundMode.AUDIO_PLAYBACK, wantAgentObj).then(() => {
        hilog.info(0x0001, TAG, "startBackgroundRunning succeeded");
      }).catch((err: BusinessError) => {
        hilog.error(0x0001, TAG, `startBackgroundRunning failed Cause:  ${JSON.stringify(err)}`);
      });
    });
  }


  public static stopContinuousTask(context?: common.UIAbilityContext): void {
    if (!context) {
      return;
    }
    backgroundTaskManager.stopBackgroundRunning(context).then(() => {
      hilog.info(0x0001, TAG, "stopBackgroundRunning succeeded");
    }).catch((err: BusinessError) => {
      hilog.error(0x0001, TAG, `stopBackgroundRunning failed Cause:  ${JSON.stringify(err)}`);
    });
  }
}
```

3.  在AVSession创建和释放时，分别申请和销毁后台长时任务。

```less
public initAvSession() {
  this.context = AppStorage.get('context');
  // ...
  avSession.createAVSession(this.context, "SHORT_AUDIO_SESSION", 'video').then(async (avSession) => {
    this.avSession = avSession;
    hilog.info(0x0001, TAG, `session create successed : sessionId : ${this.avSession.sessionId}`);
    // 申请后台长时任务
    BackgroundTaskManager.startContinuousTask(this.context);
    this.setLaunchAbility();
    this.avSession.activate();
  });
}


async unregisterSessionListener() {
  // ...
  // 销毁后台长时任务
  BackgroundTaskManager.stopContinuousTask(this.context);
}
```


滑动调节音量及亮度


在全屏播放视频的场景下，滑动调节音量及亮度是一项非常实用的功能，它允许用户在不离开视频播放界面的情况下，快速调整音量和亮度，展示音量及亮度大小，以获得更好的观影体验。该功能分为两部分，左侧滑动调整音量，右侧滑动调整亮度。


左侧滑动调节音量


在屏幕的左侧区域，使用AVVolumePanel组件显示系统音量面板，绑定PanGesture滑动手势事件，设置滑动方向为竖直方向，当Pan手势在移动过程中，上滑增加或者下滑减少音量，实现控制系统音量的功能。


```less
Column() {
  AVVolumePanel({
    volumeLevel: this.volume,
    volumeParameter: {
      position: {
        x: 150,
        y: 300
      }
    }
  })
}
.width('50%')
```


```less
.gesture(
  PanGesture({ direction: PanDirection.Vertical })
    .onActionStart(() => {
    })
    .onActionUpdate((event: GestureEvent) => {
      if (event.fingerList[0].globalX > (820 / 2)) {
        // 相对于应用窗口左上角的x轴坐标在屏幕右侧，调整亮度
        this.visible = true;
        let curBrightness = this.screenBrightness - vp2px(event.offsetY) / vp2px(this.screenHeight);
        curBrightness = curBrightness >= 1.0 ? 1.0 : curBrightness;
        curBrightness = curBrightness <= 0.0 ? 0.0 : curBrightness;
        this.screenBrightness = curBrightness;
        hilog.info(0x0000, 'AVPlayer', `this brightness is: ` + this.screenBrightness);


        try {
          this.mainWin.setWindowBrightness(this.screenBrightness, (err) => {
            if (err) {
              hilog.error(0x0000, 'AVPlayer', `Failed to set the brightness. Cause: ${JSON.stringify(err)}`);
              return;
            }
            hilog.info(0x0000, 'AVPlayer', `Succeeded in setting the brightness.`);
          });
        } catch (exception) {
          hilog.error(0x0000, 'AVPlayer', `Failed to set the brightness.`);
        }
      } else {
        // 相对于应用窗口左上角的x轴坐标在屏幕左侧，调整音量
        this.visible = false;
        let curVolume = this.volume - vp2px(event.offsetY) / this.screenHeight;
        curVolume = curVolume >= 15.0 ? 15.0 : curVolume;
        curVolume = curVolume <= 0.0 ? 0.0 : curVolume;
        this.volume = curVolume;
        hilog.info(0x0000, 'AVPlayer', `this volume is: ` + this.volume);
      }
    })
    .onActionEnd(() => {
      setTimeout(() => {
        this.visible = false;
      }, 3000)
    })
)
```


右侧滑动调节亮度


在屏幕的右侧区域，使用Slider组件设置一个亮度面板，绑定PanGesture滑动手势事件，设置滑动方向为竖直方向，当Pan手势在移动过程中调用setWindowBrightness方法，实现上滑增加或者下滑减少亮度的功能。


```less
Column() {
  Stack() {
    Slider({
      value: this.screenBrightness,
      min: 0,
      max: 1,
      step: 0.1,
      style: SliderStyle.NONE,
      direction: Axis.Vertical,
      reverse: true
    })
      .visibility(this.visible ? Visibility.Visible : Visibility.Hidden)
      .height(160)
      .selectedColor(Color.White)
      .trackColor(Color.Black)
      .trackThickness(40)


    Image($r('app.media.sun_max_fill'))
      .visibility(this.visible ? Visibility.Visible : Visibility.Hidden)
      .margin({ top: 120 })
      .width(20)
      .height(20)
  }
  .margin({
    top: 0,
    right: 0
  })
}
.alignItems(HorizontalAlign.End)
.justifyContent(FlexAlign.Center)
.padding({
  right: 30,
  bottom: 20
})
.height('100%')
.width('50%')
```


```less
.gesture(
  PanGesture({ direction: PanDirection.Vertical })
    .onActionStart(() => {
    })
    .onActionUpdate((event: GestureEvent) => {
      if (event.fingerList[0].globalX > (820 / 2)) {
        // 相对于应用窗口左上角的x轴坐标在屏幕右侧，调整亮度
        this.visible = true;
        let curBrightness = this.screenBrightness - vp2px(event.offsetY) / vp2px(this.screenHeight);
        curBrightness = curBrightness >= 1.0 ? 1.0 : curBrightness;
        curBrightness = curBrightness <= 0.0 ? 0.0 : curBrightness;
        this.screenBrightness = curBrightness;
        hilog.info(0x0000, 'AVPlayer', `this brightness is: ` + this.screenBrightness);


        try {
          this.mainWin.setWindowBrightness(this.screenBrightness, (err) => {
            if (err) {
              hilog.error(0x0000, 'AVPlayer', `Failed to set the brightness. Cause: ${JSON.stringify(err)}`);
              return;
            }
            hilog.info(0x0000, 'AVPlayer', `Succeeded in setting the brightness.`);
          });
        } catch (exception) {
          hilog.error(0x0000, 'AVPlayer', `Failed to set the brightness.`);
        }
      } else {
        // 相对于应用窗口左上角的x轴坐标在屏幕左侧，调整音量
        this.visible = false;
        let curVolume = this.volume - vp2px(event.offsetY) / this.screenHeight;
        curVolume = curVolume >= 15.0 ? 15.0 : curVolume;
        curVolume = curVolume <= 0.0 ? 0.0 : curVolume;
        this.volume = curVolume;
        hilog.info(0x0000, 'AVPlayer', `this volume is: ` + this.volume);
      }
    })
    .onActionEnd(() => {
      setTimeout(() => {
        this.visible = false;
      }, 3000)
    })
)
```


音频流状态交互


多音频并发打断


当多个音频流并发播放时，如果系统不加管控，会造成多音频流混音播放，容易让用户感到嘈杂，造成不好的用户体验。为了解决这个问题，系统预设了音频打断策略，对多音频播放的并发进行管控，只有持有音频焦点的音频流才可以正常播放，避免出现多个音频流无序并发播放的现象。当音频打断事件发生时，系统会根据预设策略，对音频流做出相应的操作，并向音频流状态变化的应用发送音频打断事件。更多详情可以参考处理音频焦点事件。


通过给AVPlayer设置on('audioInterrupt')函数进行监听，当收到音频打断事件（InterruptEvent）时，应用根据其内容做出相应的处理策略。


1、如果使用了AvPlayer播放视频，audioRendererInfo会被默认设置成Movie，应用无需处理。


2、使用on('audioInterrupt')监听音频打断时，要注意使用的视频资源必须有音频流，否则无法触发音频打断事件。


音频打断状态图

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152832.16265998975352176066975965610831:50001231000000:2800:CF6C6B1678FFA29A857B4EB34470A924DBBA445A0532356A4AE7303CCF598EA2.jpg)

以下分别对四种打断场景进行说明：


先暂停后恢复场景


场景描述：视频正常播放中，当后播应用音频类型为闹钟/电话/铃声时，视频暂停播放，待后播应用音频结束后，视频恢复播放。


降低音量后恢复场景


场景描述：视频正常播放中，当后播应用音频类型为导航/TextReader控件朗读语音/语音助手类短语音时，视频会降低音量持续播放，待后播应用音频结束后，视频音量恢复。


停止后不恢复场景


场景描述：视频正常播放中，当后播应用音频类型为音乐/视频/VOIP时，当前视频停止播放，且后播应用音频结束后，视频不会恢复。


后播应用响起时，视频应用会监听到音频打断类型为InterruptForceType.INTERRUPT_FORCE（强制打断），中断提示为InterruptHint.INTERRUPT_HINT_STOP（音频结束）事件，此时系统内部会自动停止视频播放，但AVPlayer播放器状态不会自动改变，应用需要根据自身需求做出相应处理，如主动调用AVPlayer的暂停接口保证视频状态。


并发混音场景


场景描述：视频正常播放中，当后播应用音频类型为游戏/系统音效(锁屏/按键)时，视频会与后播应用并发播放。此场景为系统默认行为，应用无需适配。


关键代码：


```less
private setInterruptCallback() {
  if (!this.avPlayer) {
    return;
  }
  this.avPlayer.on('audioInterrupt', async (interruptEvent: audio.InterruptEvent) => {
    if (interruptEvent.forceType === audio.InterruptForceType.INTERRUPT_FORCE) {
      // 强制打断类型（INTERRUPT_FORCE）：音频相关处理已由系统执行，应用需更新自身状态，做相应调整
      switch (interruptEvent.hintType) {
        case audio.InterruptHint.INTERRUPT_HINT_PAUSE:
          // 此分支表示系统已将音频流暂停（临时失去焦点），为保持状态一致，应用需切换至音频暂停状态
          // 临时失去焦点：待其他音频流释放音频焦点后，本音频流会收到resume对应的音频打断事件，到时可自行继续播放
          this.updateIsPlay(false);
          this.pauseVideo();
          break;
        case audio.InterruptHint.INTERRUPT_HINT_STOP:
          // 此分支表示系统已将音频流停止（永久失去焦点），为保持状态一致，应用需切换至音频暂停状态
          // 永久失去焦点：后续不会再收到任何音频打断事件，若想恢复播放，需要用户主动触发。
          this.updateIsPlay(false);
          this.pauseVideo();
          break;
        case audio.InterruptHint.INTERRUPT_HINT_DUCK:
          // 此分支表示系统自动将您的视频音量降低，应用无需处理
          // 若应用不接受降低音量播放，可在此处选择其他处理方式，如主动暂停等
          break;
        case audio.InterruptHint.INTERRUPT_HINT_UNDUCK:
          // 此分支表示系统已将音频音量恢复正常，应用无需处理
          break;
        default:
          break;
      }
    } else if (interruptEvent.forceType === audio.InterruptForceType.INTERRUPT_SHARE) {
      // 共享打断类型（INTERRUPT_SHARE）：应用可自主选择执行相关操作或忽略音频打断事件
      switch (interruptEvent.hintType) {
        case audio.InterruptHint.INTERRUPT_HINT_RESUME:
          // 此分支表示临时失去焦点后被暂停的音频流此时可以继续播放，建议应用继续播放，切换至音频播放状态
          // 若应用此时不想继续播放，可以忽略此音频打断事件，不进行处理即可
          // 继续播放，此处主动执行start()，以标识符变量started记录start()的执行结果
          this.playVideo();
          break;
        default:
          break;
      }
    }
  })
}
```


播放设备切换


当应用使用的播放设备状态发生改变时，需要根据不同的场景及时做出相应的处理，来保证视频状态与交互体验的一致，如：视频播放状态变化、目标设备切换、视频界面的更新等。


实现方式通过对AVPlayer注册on('audioOutputDeviceChangeWithInfo')监听事件，来感知播放设备的切换，并根据流设备的变更原因，实现对应的切换规则。


1、如果没有对AVPlayer注册on('audioOutputDeviceChangeWithInfo')监听，当识别到连接的播放设备时，音频流会自动切换到目标设备上。当播放设备断开时，播放器内部不会自动暂停。


2、如果应用想实现自己的设备切换规则，可以注册on('audioOutputDeviceChangeWithInfo')监听，交由应用自行处理业务逻辑。


播放设备切换场景：

-  新设备上线时，系统会触发播放设备自动切换，无需应用主动处理。例如当手机使用扬声器播放视频时，连接到耳机后，会自动选择连接的耳机作为播放设备。 新设备来连接时，应用通过注册的audioOutputDeviceChangeWithInfo监听事件，获取到播放设备变更的原因为AudioStreamDeviceChangeReason.REASON_NEW_DEVICE_AVAILABLE，同时系统会默认切换到新设备上继续播放。如果应用对改场景有特殊需求，可在回调中自行处理业务逻辑。

```less
this.avPlayer.on('audioOutputDeviceChangeWithInfo', (data: audio.AudioStreamDeviceChangeInfo) => {
  if (data.changeReason === audio.AudioStreamDeviceChangeReason.REASON_NEW_DEVICE_AVAILABLE) {
    hilog.info(0x0001, TAG, `Device connect: ${data.changeReason}`);
  }
});
```

-  当正在使用的播放设备断开时，应用可以根据使用场景选择暂停视频播放。例如：当断开连接的耳机时，视频暂停。 此时应用通过audioOutputDeviceChangeWithInfo监听事件，获取到设备变更原因为AudioStreamDeviceChangeReason.REASON_OLD_DEVICE_UNAVAILABLE，此处系统不会将播放器自动暂停，应用可以结合业务自行处理需求规则，如暂停视频播放。

```less
this.avPlayer.on('audioOutputDeviceChangeWithInfo', (data: audio.AudioStreamDeviceChangeInfo) => {
  if (data.changeReason === audio.AudioStreamDeviceChangeReason.REASON_OLD_DEVICE_UNAVAILABLE) {
    hilog.info(0x0001, TAG, `Device break: ${data.changeReason}`);
    this.pauseVideo();
  }
});
```

-  用户从界面选择切换音频流输出设备时，系统会自动选择新的设备播放，audioOutputDeviceChangeWithInfo监听事件获取到的变更原因为AudioStreamDeviceChangeReason.REASON_OVERRODE，应用结合业务自行处理。本篇示例未涉及该场景，只在此处进行说明，详情可以参考响应音频流输出设备变更。

示例代码

- 视频播放类应用

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-online-video-playback-lags-practice
爬取时间: 2025-05-08 03:36:14
来源: Huawei Developer


概述


在观看在线视频时，流畅播放是至关重要的。当使用AVPlayer+XComponent渲染播放在线视频时，有时会遇到在线视频播放卡顿的问题。这种情况可能是设备网络环境较差或需要加载高码率片源，导致视频缓冲时间不足，造成在线视频播放卡顿。当视频缓冲时间不足时，设备需要不断地从服务器上下载视频数据，这会导致视频播放卡顿或者停止播放。为了解决这个问题，通过合理地设置preferredBufferDuration属性可以增加视频缓冲时间，从而确保视频播放的流畅性。


实现原理


缓冲区工作过程


对于缓冲区而言，下载线程是生产端，读取线程则是消费端。生产端是将数据写入到缓冲区中，消费端则是从缓冲区读取数据，下面将介绍下缓冲区中的几个水线概念。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152832.31182603740217718614647279794250:50001231000000:2800:8C6C9F58D57C8614DAD8ADB0145F52AA5C0B829FDD389E94A135248E81CF9DBF.png)

如上图所示：

- 起播水线：限制消费方行为，限制最低消费额度的数值，只有缓冲区达到这个数值后，才允许（通知）读取线程进行数据读取。
- 止播水线：限制消费方行为，保留最低额度的数值（可以类比理解为账户最低余额），避免将缓冲区中的可用数据耗尽。
- 下载启动水线：限制生产方行为，当前读取位置的连续数据低于某个数值时，启动下载，确保消费的连续性。
- 下载暂停水线：限制生产方行为，在缓冲区写满时，暂停下载。

| 水线  | 默认值  | 说明  |
| --- | --- | --- |
| 起播水线  | 若下载速率 >= 码率场景，起播水线取值：0.3秒 * 码率 若下载速率 < 码率场景，起播水线取值：5秒 * 码率 若起播水线小于10KB，取10KB  | 在快速起播和顺滑播放间进行一个相对合理的分割。  |
| 止播水线  | 单次读取数据量，若小于5KB则取5KB  | 避免将缓冲区中的可用数据耗尽。  |
| 下载启动水线  | 480KB  | 降低线程启动频率，进行集中下载，降低cpu及指令书消耗。  |
| 下载暂停水线  | 缓冲区大小  | 当缓冲区写满时，停止下载，支持修改。  |

水线


默认值


说明


起播水线


若下载速率 >= 码率场景，起播水线取值：0.3秒 * 码率


若下载速率 < 码率场景，起播水线取值：5秒 * 码率


若起播水线小于10KB，取10KB


在快速起播和顺滑播放间进行一个相对合理的分割。


止播水线


单次读取数据量，若小于5KB则取5KB


避免将缓冲区中的可用数据耗尽。


下载启动水线


480KB


降低线程启动频率，进行集中下载，降低cpu及指令书消耗。


下载暂停水线


缓冲区大小


当缓冲区写满时，停止下载，支持修改。

- 下载速率：单位时间（不小于500ms）内写入缓冲区的数据。（下载速率统计的最小周期是500ms，也就是最少要500ms统计一次）
- 码率：通过码流描述信息解析出的媒体码率。
- 当缓冲区写满时，按读取先后顺序依次释放已读数据，可避免缓冲区数据写满造成数据无法下载到缓冲区内。

开发流程


setMediaSource中的preferredBufferDuration是AVPlayer的一个属性，用于设置播放器的缓冲区大小。AVPlayer会根据preferredBufferDuration属性的值来决定缓冲区的大小。preferredBufferDuration属性的实现原理是通过设置缓冲区大小来保证播放的流畅性和稳定性，在线视频播放流程如下：


合理设置缓冲区大小


为应对弱网及高码率片源的卡顿，用户需根据资源文件的大小设置尽可能大的缓冲区。这样在卡顿时，可以保证缓冲区能够缓存起播水线的数据量，从而避免卡成幻灯片的情况使用Drawing自绘制能力提升性能出现，保证卡顿后播放的连续性。


| 默认缓冲区大小  | 用户自定义缓冲区大小  |
| --- | --- |
| 20MB  | 5MB ~ 20MB  |

默认缓冲区大小


用户自定义缓冲区大小


20MB


5MB ~ 20MB


AVPlayer支持用户自定义缓冲区大小，可通过setMediaSource接口设置PlaybackStrategy中的preferredBufferDuration。


preferredBufferDuration的单位为秒，缓冲区大小将设置为preferredBufferDuration * 1MB。


例如，preferredBufferDuration设置为20秒，缓冲区大小将设置为20MB。示例可参考视频播放。缓冲区的大小是根据资源文件的大小来设置的，缓冲区大小需要大于整个媒体文件大小。如果媒体文件大小超过用户自定义缓冲区最大值20MB，此时可将缓冲区设置为最大值20MB。


```less
import { media } from '@kit.MediaKit';
// 创建avPlayer实例对象
let player = await media.createAVPlayer();
let headers: Record<string, string> = {"User-Agent" : "User-Agent-Value"};
let mediaSource : media.MediaSource = media.createMediaSourceWithUrl("http://xxx",  headers);
// 将preferredBufferDuration设置为最大值20MB；preferredWidth为播放策略首选宽度；preferredHeight为播放策略首选高度；preferredHdr为播放策略true是hdr，false非hdr
let playStrategy : media.PlaybackStrategy = {preferredWidth: 1, preferredHeight: 2, preferredBufferDuration: 20, preferredHdr: false};
// 设置媒体来源和播放策略
player.setMediaSource(mediaSource, playStrategy);
```


本文的测试场景为弱网条件下使用AVPlayer+XComponent渲染播放一个大小为56MB的在线视频。


| 用户自定义缓冲区大小  | 卡顿率（卡顿率=卡顿次数/播放时间）  |
| --- | --- |
| 5MB  | 65.79%  |
| 10MB  | 28.95%  |
| 20MB  | 5.26%  |

用户自定义缓冲区大小


卡顿率（卡顿率=卡顿次数/播放时间）


5MB


65.79%


10MB


28.95%


20MB


5.26%

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152832.92499069860730360333390753755769:50001231000000:2800:6BF92D7056067959560786975B105B9D3BFF2F3A92C1A19B7D925FCC5C7693E8.png)

从实验数据可以看出：


常见问题


设置preferredBufferDuration后，刚开始视频正常播放，但当用户拖动进度条后，为什么视频卡顿暂停播放？


读取尚未缓存位置的数据，包括用户拖动进度条，及部分特殊片源在播放过程中会来回跳跃下载数据。缓冲区中读取所需的数据量可能会低于止播水线，此时会暂停播放开始缓存数据，缓存至起播水线后继续播放，该缓存时间即为卡顿时间。如果媒体文件未大于20MB，可根据媒体文件的大小来这设置preferredBufferDuration的大小。如果媒体文件的大小大于20MB，只需要设置默认值20MB就能最大程度的减少卡顿。


因为缓冲区大小所占的是应用内存，假设同时创建10个实例，视频设置的缓冲区为20MB，此时缓冲区所占的应用内存为200MB，对应用性能会有影响。如果根据媒体文件大小设置缓冲区，可以最低程度的减少设置缓冲区对应用性能带来的影响。


URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-audio-video-synchronization
爬取时间: 2025-05-08 03:36:20
来源: Huawei Developer


概述


精确的音视频同步是媒体播放的关键性能指标之一。通常来说，录音设备上同时录制的音频和视频在播放设备（例如手机，电视，媒体播放器）上播放的时候也需要做到同步。目前手机播放器在输出设备为蓝牙耳机时会出现严重音视频不同步现象，严重影响用户体验。


本文旨在指导第三方视频播放应用正确获取并使用音频相关信息来保证播放时的音视频同步。


如果开发者使用自研播放器引擎而非AVPlayer，也可以参考该解决方案思路实现优化。

- PTS（送显时间戳）指音视频数据在播放时应该显示给用户的时间戳。它表示解码后的音视频数据在播放时应该出现在屏幕上或传递给音频输出设备的时间点。PTS用于控制音视频的播放顺序和时序，以确保音视频在正确的时间点进行显示或播放。
- DTS（解码时间戳）指音视频数据在解码器中开始解码的时间戳。它表示解码器应该从输入数据流中读取和解码的特定时间点。DTS用于控制解码器的解码顺序，确保音视频数据按照正确的顺序解码。

| 帧  | 解释  |
| --- | --- |
| I帧(I-frame)  | 内部画面（intra picture）或关键帧（key frame）。I帧是一个全帧压缩的编码帧，包含了一幅完整的图像数据。  |
| P帧(P-frame)  | 前向预测编码帧（predictive-frame）。P帧不是完整的数据帧，而是只包含与前面I帧或P帧的差异数据。  |
| B帧(B-frame)  | 双向预测内插编码帧（bi-directional interpolated prediction frame）。B帧也是一个压缩帧，它同时参考前面的I帧或P帧和后面的P帧来进行编码。  |

帧


解释


I帧(I-frame)


内部画面（intra picture）或关键帧（key frame）。I帧是一个全帧压缩的编码帧，包含了一幅完整的图像数据。


P帧(P-frame)


前向预测编码帧（predictive-frame）。P帧不是完整的数据帧，而是只包含与前面I帧或P帧的差异数据。


B帧(B-frame)


双向预测内插编码帧（bi-directional interpolated prediction frame）。B帧也是一个压缩帧，它同时参考前面的I帧或P帧和后面的P帧来进行编码。


实现原理


音视频数据的最小处理单元称为帧。音频流和视频流都被分割成帧，所有帧都被标记为需要按特定的时间戳显示。音频和视频可以独立下载和解码，但具有匹配时间戳的音频和视频帧应同时呈现，以达到音视频（A/V）同步的效果。


音画同步标准


| 时间差范围  | 主观体验  |
| --- | --- |
| [-80ms,25ms]  | 无法察觉  |
| [-125ms,45ms]  | 能够察觉  |
| [-185ms,90ms]  | 无法接受  |

时间差范围


主观体验


[-80ms,25ms]


无法察觉


[-125ms,45ms]


能够察觉


[-185ms,90ms]


无法接受


以上标准基于一倍速场景。


理论上，因为音频通路存在时延，要保证播放时的音视频同步，有三种解决方案可用：

- 连续播放音频帧：使用音频播放位置作为主时间参考，并将视频播放位置与其匹配。
- 使用系统时间作为参考：将音频和视频播放与系统时间匹配。
- 使用视频播放作为参考：让音频匹配视频。

三种方案的优缺点对比如下：


| 方案名称  | 优点  | 缺点  |
| --- | --- | --- |
| 连续播放音频帧  | 用户肉眼的敏感度较弱，不易察觉视频微小的调整。视频刷新时间的调整相对便捷。  | 如果视频帧率不稳定或渲染延迟大，可能导致视频卡顿或跳帧。  |
| 使用系统时间作为参考  | 可以最大限度的保证音频和视频都不发生跳帧行为。  | 需要额外依赖系统时钟，增加了系统复杂性和维护成本。系统时钟的准确性对同步效果影响较大，如果系统时钟不准确，可能导致同步效果大打折扣。  |
| 使用视频播放作为参考  | 音频可根据视频帧进行调整，减少音频跳帧的情况。  | 音频播放可能会出现等待或加速的情况，相较于视频会对用户的影响更为严重和明显。如果视频帧率不稳定，可能导致音频同步困难。  |

方案名称


优点


缺点


连续播放音频帧


如果视频帧率不稳定或渲染延迟大，可能导致视频卡顿或跳帧。


使用系统时间作为参考


可以最大限度的保证音频和视频都不发生跳帧行为。


使用视频播放作为参考


音频可根据视频帧进行调整，减少音频跳帧的情况。


第一个方案是唯一一个具有连续音频数据流的选项，其没有对音频帧的显示时间、播放速度或持续时间进行任何调整。这些参数的任何调整都很容易被人耳注意到，并导致音频干扰故障。处理这些故障需要对音频重新采样，然而重新采样会导致音调的改变。


因此，一般的多媒体应用多使用音频播放位置作为主时间参考。以下章节主要以此解决方案进行说明（其他两个选项不在本文档的范围内）。


连续播放音帧方案示意图

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152832.86648551482670949345279358377537:50001231000000:2800:B3494F77064028FFCC110B38B63E5165EF4FEC978E473E49217DC8338A787495.png)

音频和视频的管道必须同时以相同的时间戳呈现每帧数据。音频播放位置用作主时间参考，而视频管道只输出与最新渲染音频帧匹配的视频帧。对于所有可能的实现，精确计算最后一次呈现的音频时间戳是至关重要的。OH_AudioRenderer_GetTimestamp()接口用以查询音频管道各个阶段的音频时间戳和延迟信息，此信息可用于控制视频管道，使视频帧与音频帧匹配。


基于以上示意图，具体来说，在监听到视频帧的时候，首先去获取当前音频渲染位置，在获取成功的情况下计算该视频帧PTS与当前音频渲染位置的延迟时间，对延迟时间进行如下判断确定送显策略。

- 视频帧相较于音频渲染位置过早时，视频帧则等待一段时间再送显。
- 延迟时间在可接受的延迟范围内该视频帧立即送显。
- 当视频帧相较于音频渲染位置过晚时则丢弃该视频帧。

连续播放音频帧方案


场景描述


综合上述三种方案的优缺点对比，此处采用主流的连续播放音频帧方案。使用音频播放位置作为主时间参考，并将视频播放位置与其匹配，使音画同步指标达到用户无法察觉的[-80ms,25ms]范围。


该解决方案使用：

- 视频同步到音频（主流方案）。
- 获取音频渲染进度，动态调整视频渲染进度。

最终实现音画同步[-80ms,25ms]的效果。


开发步骤


```less
// get audio render position
int64_t framePosition = 0;
int64_t timeStamp = 0;
int32_t ret = OH_AudioRenderer_GetTimestamp(audioRenderer, CLOCK_MONOTONIC, &framePosition, &timeStamp);
AVCODEC_SAMPLE_LOGI("VD framePosition: %{public}ld, nowTimeStamp: %{public}ld", framePosition, nowTimeStamp);
audioTimeStamp = timeStamp;
```

1.  音频启动前，timestamp和framePosition返回结果为0。为避免出现卡顿等问题，暂不同步，视频帧直接送显。

```less
// audio render getTimeStamp error, render it
if (ret != AUDIOSTREAM_SUCCESS || (timeStamp == 0) || (framePosition == 0)) {
    // first frame, render without wait
    videoDecoder->FreeOutputBuffer(bufferInfo.bufferIndex, true);
    std::this_thread::sleep_until(lastPushTime + std::chrono::microseconds(sampleInfo.frameInterval));
    lastPushTime = std::chrono::system_clock::now();
    continue;
}
```


```less
// after seek, audio render flush, framePosition = 0, then writtenSampleCnt = 0
int64_t latency = (writtenSampleCnt - framePosition) * 1000 * 1000 / sampleInfo.audioSampleRate;
AVCODEC_SAMPLE_LOGI("VD latency: %{public}ld writtenSampleCnt: %{public}ld", latency, writtenSampleCnt);


nowTimeStamp = GetCurrentTime();
int64_t anchorDiff = (nowTimeStamp - audioTimeStamp) / 1000;
int64_t audioPlayedTime = audioBufferPts - latency + anchorDiff; // us, audio buffer accelerate render time
int64_t videoPlayedTime = bufferInfo.attr.pts;                   // us, video buffer expected render time


// audio render timeStamp and now timeStamp diff
int64_t waitTimeUs = videoPlayedTime - audioPlayedTime;
```


```less
// video buffer is too late, drop it
if (waitTimeUs < WAIT_TIME_US_THRESHOLD_WARNING) {
    dropFrame = true;
    AVCODEC_SAMPLE_LOGE("VD buffer is too late");
} else {
    AVCODEC_SAMPLE_LOGE("VD buffer is too early waitTimeUs: %{public}ld", waitTimeUs);
    // [0, ), render it with waitTimeUs, max 1s
    // [-40,0), render it
    if (waitTimeUs > WAIT_TIME_US_THRESHOLD) {
        waitTimeUs = WAIT_TIME_US_THRESHOLD;
    }
    // per frame render time reduced by 33ms
    if (waitTimeUs > sampleInfo.frameInterval + PER_SINK_TIME_THRESHOLD) {
        waitTimeUs = sampleInfo.frameInterval + PER_SINK_TIME_THRESHOLD;
        AVCODEC_SAMPLE_LOGE("VD buffer is too early and reduced 33ms, waitTimeUs: %{public}ld", waitTimeUs);
    }
}
```

2.  视频帧较早时，等待一段时间送显。

```less
if (waitTimeUs > 0) {
    std::this_thread::sleep_for(std::chrono::microseconds(waitTimeUs));
}
lastPushTime = std::chrono::system_clock::now();
ret = videoDecoder->FreeOutputBuffer(bufferInfo.bufferIndex, !dropFrame);        
```

- OH_AudioRenderer_Start()接口执行后到真正写入硬件有一定延迟，因此该接口在调用OH_AudioRenderer_Start()接口之后过一会才会拿到有效值，期间音频未发声时建议画面帧先按照正常速度播放，后续再逐步追赶音频位置从而提升用户看到画面的起播时延。
- 当framePosition和timestamp以稳定的速度前进后，建议调用OH_AudioRenderer_GetTimestamp()接口的频率不要太频繁。推荐200ms一次，可以每分钟一次，最好不要低于200ms一次。频繁调用可能会带来功耗问题，因此在能保证音画同步效果的情况下，不需要频繁的查询时间戳。
- OH_AudioRenderer_Flush()接口执行后，framePosition返回值会重新（从0）开始计算。
- OH_AudioRenderer_GetFramesWritten()接口在Flush时候不会清空，该接口和OH_AudioRenderer_GetTimestamp()接口并不建议配合使用。
- 音频设备切换过程中OH_AudioRenderer_GetTimestamp()接口返回的framePosition和timestamp保证不会倒退，但由于新设备写入有时延，会出现短暂时间内音频进度无增长，建议画面帧保持流畅播放不要产生卡顿。
- OH_AudioRenderer_GetTimestamp()接口获取的是实际写到硬件的采样帧数，不受倍速影响。对AudioRenderer设置了倍速的场景下，播放进度计算需要特殊处理，系统保证应用设置完倍速接口后，新写入AudioRenderer的采样点才会做倍速处理。
- audioPlayedTime: 音频帧期望渲染时间。
- videoPlayedTime: 视频帧期望送显时间。
- waitTimeUs : 视频帧相对于音频帧延迟时间。
- [ , -40ms)  视频帧较晚时，丢弃此帧。
- [-40ms, 0ms) 视频帧直接送显。
- [0ms, ) 视频帧较早，根据业务需要选择渐进同步。

示例代码

- 实现音画同步播放效果

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-deal-stride-solution
爬取时间: 2025-05-08 03:36:26
来源: Huawei Developer


概述


开发者在使用相机服务时，如果仅用于预览流展示，通常使用XComponent组件实现，如果需要获取每帧图像做二次处理（例如获取每帧图像完成二维码识别或人脸识别场景），可以通过ImageReceiver中imageArrival事件监听预览流每帧数据，解析图像内容。在解析图像内容时，如果未考虑stride，直接通过使用width*height读取图像内容去解析图像，会导致相机预览异常，从而出现相机预览花屏的现象。


当开发者获取预览流每帧图像buffer后，若发现图片内容出现花屏堆叠状，出现“相机预览花屏”现象，此时需要排查解析每帧图像，当预览流图像stride与width不一致时，需要对stride进行无效像素的去除处理。


实现原理


在计算机图形学和图像处理中，stride通常指的是在内存中存储多维数组（如图像或纹理）时，行与行之间的字节间隔，即每一行的起始地址与下一行的起始地址之间的距离，在本文中stride指的是图像的一行数据在内存中实际占用的字节数，为了内存对齐和提高读取效率的要求，通常大于图像的宽度。


stride在不同的平台底层上报的值不同，开发者需根据实际业务获取stride后做处理适配。在本文中通过预览流帧数据的返回值image.Component.rowStride获取stride。


如下图：在一个width为3，height为3，stride为4的图片上（例如定义了一个480*480分辨率的图像），实际分配内存并不是width*height即3*3（此处为定义的预览流分辨率的宽高比，即实际分配内存不是480*480），而是stride*height即4*3，这样实现了内存对齐，方便硬件处理。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152833.89811659221011430239462395900073:50001231000000:2800:88DFFF78613855C3AF4756D870A2E86A794BC48EEB5FE44CB97325FE4CBDEC38.png)

如果开发者根据width和height数据去处理像素数据，即把0x00-0x09地址的数据当做像素去处理，就会出现解析了错误的像素数据的问题，并且使用了无效的像素0x03，0x07，会导致图片无法正常显示导致“相机花屏”现象。因此，要根据stride值处理预览数据流，去除无效的像素后送显，才能获取正确的预览流图像。


场景案例


以一种高频的用户使用场景为例，应用需要定义一个1080*1080分辨率的预览流图像，此时的stride在相关平台的返回值为1088，此时需要对stride进行处理，处理无效像素后解析出正确的像素数据，避免出现预览流花屏。


【反例】未处理stride：当开发者创建PixelMap解析buffer时，直接按照宽去读取每行数据，没有处理stride，此时若解析了无效像素数据并传给Image组件直接送显，可能会出现预览流花屏现象。


以下为部分示例代码：


```less
onImageArrival(receiver: image.ImageReceiver): void {
  receiver.on('imageArrival', () => {
    receiver.readNextImage((err: BusinessError, nextImage: image.Image) => {
      if (err || nextImage === undefined) {
        Logger.error(TAG, `requestPermissionsFromUser call Failed! error: ${err.code}`);
        return;
      }
      if (nextImage) {
        nextImage.getComponent(image.ComponentType.JPEG, async (_err, component: image.Component) => {
          let width = 1080; // width为应用创建预览流分辨率对应的宽
          let height = 1080; // height为应用创建预览流分辨率对应的高
          // component.byteBuffer为相机返回的预览流数据，其中包含了stride对齐数据
          let pixelMap = await image.createPixelMap(component.byteBuffer, {
            size: {
              height: height,
              width: width
            },
            // 反例：width没有处理stride值，创建PixelMap解析buffer时直接按照宽去读取每行数据，可能使用了无效像素数据，导致预览流花屏。
            srcPixelFormat: image.PixelMapFormat.NV21
          })
          AppStorage.setOrCreate('stridePixel', pixelMap); // 将创建出的PixelMap存储到全局变量stridePixel中并传给Image组件送显。
          nextImage.release();
        })
      }
    });
  })
}
```


```less
@Component
export struct PageThree {
  pathStack: NavPathStack = new NavPathStack();
  @State isShowStridePixel: boolean = false;
  @StorageLink('stridePixel') @Watch('onStridePixel') stridePixel: image.PixelMap | undefined = undefined;
  @State imageWidth: number = 1080;
  @State imageHeight: number = 1080;
  @StorageLink('previewRotation') previewRotate: number = 0;


  onStridePixel(): void {
    this.isShowStridePixel = true;
  }


  aboutToAppear(): void {
    CameraService.initCamera(0);
  }


  aboutToDisappear(): void {
    CameraService.releaseCamera();
  }


  // ...


  build() {
    NavDestination() {
      // ...
      Column() {
        if (this.isShowStridePixel) {
          Image(this.stridePixel) // 反例：解析了错误的像素数据，并存储到全局变量stridePixel中，传给Image送显，会导致相机预览流花屏。
            .width(px2vp(this.imageWidth))
            .height(px2vp(this.imageHeight))
            .margin({ top: 150 })
            .rotate({
              z: 0.5,
              angle: this.previewRotate
            })
        }
        // ...
      }
      .justifyContent(FlexAlign.Center)
      .height('90%')
      .width('100%')
    }
    .backgroundColor(Color.White)
    .hideTitleBar(true)
    .onBackPressed(() => {
      this.pathStack.pop();
      return true;
    })
    .onReady((context: NavDestinationContext) => {
      this.pathStack = context.pathStack;
    })
  }
}
```


【正例一】开发者使用width，height，stride三个值，处理相机预览流数据，处理stride方法一如下。


分两种情况：


```less
onImageArrival(receiver: image.ImageReceiver): void {
  receiver.on('imageArrival', () => {
    receiver.readNextImage((err: BusinessError, nextImage: image.Image) => {
      // ...
      if (nextImage) {
        nextImage.getComponent(image.ComponentType.JPEG,
          async (err, component: image.Component) => {
            let width = 1080; // width为应用创建预览流分辨率对应的宽
            let height = 1080; // height为应用创建预览流分辨率对应的高
            let stride = component.rowStride; // 通过component.rowStride获取stride
            // 正例：情况1. 当图片的width等于相机预览流返回的行跨距stride，此时无需处理stride，通过width和height直接创建pixelMap,
            // 并存储到全局变量stridePixel中，传给Image送显。
            if (stride === width) {
              let pixelMap = await image.createPixelMap(component.byteBuffer, {
                size: { height: height, width: width },
                srcPixelFormat: image.PixelMapFormat.NV21,
              })
              AppStorage.setOrCreate('stridePixel', pixelMap);
            } else {
              // 正例：情况2. 当图片的width不等于相机预览流返回的行跨距stride，
              // 此时将相机返回的预览流数据component.byteBuffer去除掉stride，拷贝得到新的dstArr数据，数据处理后传给其他不支持stride的接口处理。
              const dstBufferSize = width * height * 1.5; // 创建一个width * height * 1.5的dstBufferSize空间，此处为NV21数据格式。
              const dstArr = new Uint8Array(dstBufferSize); // 存放去掉stride后的buffer。
              // 读取每行数据，相机支持的profile宽高均为偶数，不涉及取整问题。
              for (let j = 0; j < height * 1.5; j++) { // 循环dstArr的每一行数据。
                // 拷贝component.byteBuffer的每行数据前width个字节到dstArr中(去除无效像素，刚好每行得到一个width*height的八字节数组空间)。
                const srcBuf = new Uint8Array(component.byteBuffer, j * stride,
                  width); // 将component.byteBuffer返回的buffer，每行遍历，从首位开始，每行截取出width字节。
                dstArr.set(srcBuf, j * width); // 将width*height大小的数据存储到dstArr中。
              }
              let pixelMap = await image.createPixelMap(dstArr.buffer, {
                // 将处理后的dstArr数组buffer，通过width和height直接创建pixelMap,并存储到全局变量stridePixel中，传给Image送显。
                size: { height: height, width: width },
                srcPixelFormat: image.PixelMapFormat.NV21,
              })
              AppStorage.setOrCreate('stridePixel', pixelMap);
            }
            nextImage.release();
          })
      }
    });
  })
}
```


【正例二】开发者使用width，height，stride三个值，处理相机预览流数据，处理stride方法二如下。


分两种情况：


```less
onImageArrival(receiver: image.ImageReceiver): void {
  receiver.on('imageArrival', () => {
    receiver.readNextImage((err: BusinessError, nextImage: image.Image) => {
      // ...
      if (nextImage) {
        nextImage.getComponent(image.ComponentType.JPEG, async (_err, component: image.Component) => {
          let width = 1080; // width为应用创建预览流分辨率对应的宽
          let height = 1080; // height为应用创建预览流分辨率对应的高
          let stride = component.rowStride; // 通过component.rowStride获取stride
          Logger.info(TAG, `receiver getComponent width:${width} height:${height} stride:${stride}`);
          // stride和width相等，按宽读取buffer不影响结果
          if (stride === width) {
            let pixelMap = await image.createPixelMap(component.byteBuffer, {
              size: { height: height, width: width },
              srcPixelFormat: image.PixelMapFormat.NV21,
            })
            AppStorage.setOrCreate('stridePixel', pixelMap);
          } else {
            let pixelMap = await image.createPixelMap(component.byteBuffer, {
              // 正例：1、创建PixelMap时width传stride，
              size: { height: height, width: stride },
              srcPixelFormat: 8,
            })
            // 2、然后调用PixelMap的cropSync方法裁剪掉多余的像素。
            pixelMap.cropSync({
              size: { width: width, height: height },
              x: 0,
              y: 0
            }) // 根据输入的尺寸裁剪图片,从(0,0)开始，裁剪width*height字节的区域。
            let pixelBefore: PixelMap | undefined = AppStorage.get('stridePixel');
            await pixelBefore?.release();
            AppStorage.setOrCreate('stridePixel', pixelMap);
          }
          nextImage.release();
        })
      }
    });
  })
}
```


效果对比


| （反例）未处理stride  | （正例）处理stride的方案一  | （正例）处理stride的方案二  |
| --- | --- | --- |
|    |    |    |

（反例）未处理stride


（正例）处理stride的方案一


（正例）处理stride的方案二

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152833.02145907829877407974811291998465:50001231000000:2800:9C9D3277C4600848A74C834CBEDA6E7605259E72BD6D65A076F9E40E67C3F3D3.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152833.46776520540302288662660859671133:50001231000000:2800:8EFC188DB2C8EE6CFB9D09AAF626E1519A36D59AC4C72AC261A372FCB9683463.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152833.51225894505997935491940491216484:50001231000000:2800:89C156E43088549FC682A9BF9A6263A80A41EAA5BFA9EA3FF3B1843C7C0A718D.gif)

常见问题


如何获取相机预览流帧数据


通过ImageReceiver中imageArrival事件监听获取底层返回的图像数据，详细请参见双路预览(ArkTS)。


如何获取预览流图像的stride的值


可以通过预览流帧数据的返回值image.Component.rowStride获取stride。


示例代码

- 处理stride解决相机预览流花屏问题

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-video-thumbnail
爬取时间: 2025-05-08 03:36:35
来源: Huawei Developer


概述


视频缩略图是视频的静态预览图像，是从视频中截取的某一帧画面，经常用作视频的封面。在视频浏览、分享和管理等场景中使用可以帮助用户快速浏览和选择想要的内容，提高用户的使用体验。HarmonyOS提供了对应的模块能力，帮助开发者获取视频文件的缩略图。根据应用获取缩略图策略的不同，可以分为以下两种场景：

- 获取视频默认缩略图
- 选取视频帧作为缩略图

获取视频默认缩略图


实现原理


视频的默认缩略图一般为视频的第一帧，可以通过PhotoAsset类的getThumbnail()方法获取。这里以获取图库视频缩略图场景为例。


开发步骤


```less
//src/main/ets/common/utils/PhotoUtils.ets
/**
 * Pull up the gallery picker and select a video.
 * @returns The url of the selected video.
 */
async selectVideo(): Promise<string> {
  let photoViewPicker = new photoAccessHelper.PhotoViewPicker();
  return photoViewPicker.select({
    MIMEType: photoAccessHelper.PhotoViewMIMETypes.VIDEO_TYPE,
    maxSelectNumber: 1
  }).then((photoSelectResult: photoAccessHelper.PhotoSelectResult): string => {
    if (photoSelectResult.photoUris.length <= 0) {
      return '';
    }
    return photoSelectResult.photoUris[0];
  })
}
```


```less
//src/main/ets/common/utils/PhotoUtils.ets
// Obtain video resources.
let predicates: dataSharePredicates.DataSharePredicates = new dataSharePredicates.DataSharePredicates();
predicates.equalTo('uri', videoUrl);
let videoFetchResult: photoAccessHelper.FetchResult<photoAccessHelper.PhotoAsset> =
  await this.phAccessHelper.getAssets({
    fetchColumns: ['width', 'height', 'orientation'],
    predicates: predicates
  });
let photoAsset: photoAccessHelper.PhotoAsset = await videoFetchResult.getFirstObject();
```


```less
//src/main/ets/common/utils/PhotoUtils.ets
// Configure thumbnail parameters.
let thumbnailSize: Size = { width: 0, height: 0 };
if (photoAsset.get(photoAccessHelper.PhotoKeys.ORIENTATION) === 90 ||
  photoAsset.get(photoAccessHelper.PhotoKeys.ORIENTATION) === 270) {
  thumbnailSize.width = photoAsset.get(photoAccessHelper.PhotoKeys.HEIGHT) as number;
  thumbnailSize.height = photoAsset.get(photoAccessHelper.PhotoKeys.WIDTH) as number;
} else {
  thumbnailSize.width = photoAsset.get(photoAccessHelper.PhotoKeys.WIDTH) as number;
  thumbnailSize.height = photoAsset.get(photoAccessHelper.PhotoKeys.HEIGHT) as number;
}
return photoAsset.getThumbnail(thumbnailSize);
```


使用getAsset()和getThumbnail()方法需要申请受限开放权限'ohos.permission.READ_IMAGEVIDEO'，对于需要克隆、备份或同步图片/视频类文件的应用可申请获取该权限，并通过getAlbums()方法获取相册资源再调用这两个方法获取缩略图。或者通过picker的方式可以在不获取权限的情况下，使用这两个方法来访问用户指定的图库资源获取缩略图。本文中的示例使用的是第二种picker的方式。


实现效果

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152833.35815875246738108714314246754893:50001231000000:2800:853001971279D0F5E8BE73D84B063A6E329A1E3A556F8638276D8510D98660DF.gif)

选取视频帧作为缩略图


实现原理


HarmonyOS提供视频缩略图获取类AVImageGenerator用于选取视频指定时间的帧作为缩略图，这里以选取图库视频缩略图场景为例。


开发步骤


```typescript
//src/main/ets/pages/Index.ets
/**
 * Obtain video resources through AVImageGenerator.
 */
async imageGeneratorGetThumbnail() {
  this.photoUtils.selectVideo().then(async (result: string) => {
    // ...
    this.fileAlbum = fileIo.openSync(result, fileIo.OpenMode.READ_ONLY);
    this.avFileDescriptor = { fd: this.fileAlbum.fd };
    // ...
  }
  ).catch((error: BusinessError) => {
    hilog.error(0x0000, TAG,
      `Invoke imageGeneratorGetThumbnail failed!, error code: ${error.code}, message: ${error.message}`);
  })
}
```


```typescript
//src/main/ets/common/utils/PhotoUtils.ets
/**
 * Get video infos through video file descriptor.
 * @param avFileDescriptor AVFileDescriptor of video.
 * @returns the size infos of video.
 */
async getVideoData(avFileDescriptor: media.AVFileDescriptor): Promise<VideoSizeData> {
  let videoSize: VideoSizeData = new VideoSizeData();
  let avMetaDataExtractor: media.AVMetadataExtractor = await media.createAVMetadataExtractor();
  avMetaDataExtractor.fdSrc = avFileDescriptor;
  let metadata = await avMetaDataExtractor.fetchMetadata();
  videoSize.photoSize.width = parseInt(metadata.videoWidth as string);
  videoSize.photoSize.height = parseInt(metadata.videoHeight as string);
  if (metadata.duration) {
    videoSize.totalTime = parseInt(metadata.duration);
  }
  avMetaDataExtractor.release();
  return videoSize;
}
```


```less
//src/main/ets/pages/Index.ets
this.avImageGenerator = await media.createAVImageGenerator();
if (this.avImageGenerator) {
  this.avImageGenerator.fdSrc = this.avFileDescriptor;
} else {
  hilog.error(0X0000, TAG, 'Create AVImageGenerator failed!');
  return;
}
```


```typescript
//src/main/ets/pages/Index.ets
/**
 * Obtain a frame at a certain point in time of the video.
 * @param time A certain point in time of the video.
 */
async fetchFrameByTime(time: number) {
  this.pixelMap = await this.avImageGenerator?.fetchFrameByTime(time,
    media.AVImageQueryOptions.AV_IMAGE_QUERY_CLOSEST_SYNC, this.videoSize.photoSize);
}
```


实现效果

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152833.90544305050414537677212149409169:50001231000000:2800:8750E6799FDAA9C5705A28D6EE366F2B34DB29ED3AE07E0D117442FCB9D90F9D.gif)

示例代码

- 基于系统能力获取视频缩略图

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-hdrvivid
爬取时间: 2025-05-08 03:36:41
来源: Huawei Developer


概述


随着5G、光纤等网络技术的普及，终端显示能力进一步提升，“真实”、“沉浸”的超高清音视频体验时代已到来。高动态范围（High-Dynamic Range，简称HDR）作为超高清音视频产业的关键技术之一，比传统的标准动态范围（Standard Dynamic Range，简称SDR）拥有更广的色域和更高的动态范围（动态范围指的是亮度最大值和最小值的比值），为图像保留更多细节。超高清HDR加上宽色域能让视频亮度层次和色彩的呈现更真实、更自然。


HDRVivid是由华为主导开发的高动态范围视频技术标准，中文名为“菁彩影像”。它受亮度、对比度、色深、色域等因素影响，是一种提高画面亮度及对比度的画面处理技术。 其技术特点与优势为：


目前涉及到的HDR场景包括：HDR视频录制、HDR视频播放、视频转码（HDR2SDR）、HDR图片拍照等。本文旨在向开发者介绍，如何使用HarmonyOS的系统能力进行常用场景的开发：

- HDRVivid视频录制：主要使用场景为有HDRVivid视频录制需求的应用。
- HDRVivid视频播放：主要使用场景为有播放HDRVivid视频片源需求的应用。
- HDRVivid视频转码成SDR视频：主要使用场景为不支持HDRVivid视频播放的场景或其他特殊情况。

HDRVivid视频录制


HDRVivid视频录制是一种先进的视频录制技术，它基于动态元数据对亮度、对比度和颜色进行逐个场景优化，为显示终端提供更加准确的动态映射方式。


HDRVivid视频录制的开发和主流格式视频录制的开发基本一致，差异点体现在部分参数的配置上。


HarmonyOS上开发录制视频的功能一般有两个方案：

- 使用Camera配合系统级音视频录制类AVRecorder进行录制。
- 使用Camera配合系统编码器进行录制。

使用Camera+AVRecorder录制


实现原理


应用通过调用AVRecorder实现视频录制时，先通过Camera接口调用相机服务，通过视频HDI捕获图像数据送显至应用，同时送至AVRecorder的录制服务，录制服务将图像数据编码后封装至文件中，实现视频录制功能。流程图如下：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152833.79343937296427522685461736423646:50001231000000:2800:73506D7E40812EC73D187C0BAF2BF3BA6361349E2934C8BA8F75750DAE62AF50.png)

使用Camera+AVRecorder录制HDRVivid视频，与录制普通视频的区别主要在于：

- AVRecorderAVRecoder需要配置isHdr参数为true，对应的编码格式必须为video/hevc。
- AVRecoder需要配置isHdr参数为true，对应的编码格式必须为video/hevc。
- Camera相机创建video output实例时，选择yuv 10bit profile（CAMERA_FORMAT_YCRCB_P010）。HDR录像需要相机支持视频防抖功能。相机会话配置颜色空间为BT2020_HLG_LIMIT。
- 相机创建video output实例时，选择yuv 10bit profile（CAMERA_FORMAT_YCRCB_P010）。
- HDR录像需要相机支持视频防抖功能。
- 相机会话配置颜色空间为BT2020_HLG_LIMIT。

开发步骤


针对以上四点不同，开发视频录制功能时，可参考以下步骤（详细开发步骤可参考HDR Vivid相机录像(ArkTS)）：


```less
// 创建AVRecorder实例
try {
  this.avRecorder = await media.createAVRecorder();
} catch (error) {
  let err = error as BusinessError;
  Logger.error(TAG, `createAVRecorder call failed. error code: ${err.code}`);
}
```


```less
let videoSize: camera.Size = {
  width: 1280,
  height: 720
}
// 设置配置参数AVRecorderProfile中的变量isHdr和videoCodec
let avRecorderProfile: media.AVRecorderProfile = {
  // ...
  videoCodec: media.CodecMimeType.VIDEO_HEVC,
  // ...
  isHdr: true
};
```


```less
let videoProfile: undefined | camera.VideoProfile = videoProfilesArray.find((profile: camera.VideoProfile) => {
  return profile.size.width === videoSize.width && profile.size.height === videoSize.height &&
    profile.format === camera.CameraFormat.CAMERA_FORMAT_YCRCB_P010;
});


let previewProfile: undefined | camera.Profile = previewProfilesArray.find((profile: camera.Profile) => {
  return profile.format === camera.CameraFormat.CAMERA_FORMAT_YCRCB_P010 &&
    profile.size.width === videoSize.width && profile.size.height == videoSize.height
});


// ...


let avRecorderConfig: media.AVRecorderConfig = {
  audioSourceType: media.AudioSourceType.AUDIO_SOURCE_TYPE_MIC,
  videoSourceType: media.VideoSourceType.VIDEO_SOURCE_TYPE_SURFACE_YUV,
  profile: avRecorderProfile,
  url: this.url,
  rotation: 0,
  location: {
    latitude: 30,
    longitude: 130
  }
};


// ...


try {
  await this.avRecorder.prepare(avRecorderConfig);
} catch (error) {
  let err = error as BusinessError;
  Logger.error(TAG, `prepare call failed. error code: ${err.code}`);
}


let videoSurfaceId: string | undefined = undefined;
try {
  videoSurfaceId = await this.avRecorder.getInputSurface();
} catch (error) {
  let err = error as BusinessError;
  Logger.error(TAG, `getInputSurface call failed. error code: ${err.code}`);
}
if (videoSurfaceId === undefined) {
  return;
}


try {
  this.videoOutput = this.cameraManager.createVideoOutput(videoProfile, videoSurfaceId);
} catch (error) {
  let err = error as BusinessError;
  Logger.error(TAG, `Failed to create the videoOutput instance. error: ${JSON.stringify(err)}`);
}
```


```typescript
// 创建并配置相机会话
try {
  this.captureSession = this.cameraManager.createSession(camera.SceneMode.NORMAL_VIDEO) as camera.VideoSession;
} catch (error) {
  // ...
}
// ...


try {
  this.captureSession.beginConfig();
} catch (error) {
  // ...
}


// ...


try {
  await this.captureSession.commitConfig();
} catch (error) {
  // ...
}


let mode: camera.VideoStabilizationMode = camera.VideoStabilizationMode.AUTO;
// 查询是否支持视频防抖
let isSupported: boolean = false;
try {
  isSupported = this.captureSession.isVideoStabilizationModeSupported(mode);
  Logger.info(TAG, `isVideoStabilizationModeSupported: ${JSON.stringify(isSupported)}`);
} catch (error) {
  // 失败返回错误码error.code并处理
  let err = error as BusinessError;
  Logger.error(`The isVideoStabilizationModeSupported call failed. error code: ${err.code}`);
}
if (isSupported) {
  // 设置视频防抖
  this.captureSession.setVideoStabilizationMode(mode);
  let activeVideoStabilizationMode = this.captureSession.getActiveVideoStabilizationMode();
  Logger.info(`activeVideoStabilizationMode: ${activeVideoStabilizationMode}`);
} else {
  Logger.error(`videoStabilizationMode: ${mode} is not support`);
}


// Camera Session配置颜色空间为BT2020_HLG_LIMIT
if (isSupported) {
  let colorSpace: colorSpaceManager.ColorSpace = colorSpaceManager.ColorSpace.BT2020_HLG_LIMIT;
  let colorSpaces: Array<colorSpaceManager.ColorSpace> = [];
  try {
    colorSpaces = this.captureSession.getSupportedColorSpaces();
  } catch (error) {
    let err = error as BusinessError;
    Logger.error(`The getSupportedColorSpaces call failed. error code: ${err.code}`);
  }
  let isSupportedColorSpaces = colorSpaces.indexOf(colorSpace) >= 0;
  if (isSupportedColorSpaces) {
    Logger.info(`setColorSpace: ${colorSpace}`);
    try {
      this.captureSession.setColorSpace(colorSpace);
    } catch (error) {
      let err = error as BusinessError;
      Logger.error(`The setColorSpace call failed, error code: ${err.code}`);
    }
    let activeColorSpace: colorSpaceManager.ColorSpace = this.captureSession.getActiveColorSpace();
    Logger.info(`activeColorSpace: ${activeColorSpace}`);
  } else {
    Logger.error(`colorSpace: ${colorSpace} is not support`);
  }
}


try {
  await this.captureSession.start();
} catch (error) {
  let err = error as BusinessError;
  Logger.error(TAG, `captureSession start error: ${JSON.stringify(err)}`);
}
```


```less
this.videoOutput.start((err: BusinessError) => {
  if (err) {
    Logger.error(TAG, `Failed to start the video output. error: ${JSON.stringify(err)}`);
    return;
  }
  Logger.info(TAG, 'Callback invoked to indicate the video output start success.');
});
```


```less
async startRecord() {
  if (this.avRecorder) {
    try {
      await this.avRecorder.start();
    } catch (error) {
      let err = error as BusinessError;
      Logger.error(TAG, `avRecorder start error: ${JSON.stringify(err)}`);
    }
  }
}
```


使用Camera+AVCodec录制


实现原理


应用通过调用AVCodec实现视频录制时，先通过Camera接口调用相机服务，通过视频HDI捕获图像数据送显至应用，同时送至AVCodec的编码模块将图像数据编码后封装至文件中，实现视频录制功能。流程图如下：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152833.50032007057749422153224789194550:50001231000000:2800:6CE884C310BEFA92E5B6359E222041FF123A6026413CF2DE7B6098138BD76151.png)

使用Camera+AVCodec录制HDRVivid视频，与录制普通视频的区别主要在于：

- AVCodec视频编码器AVCodec需要选择HEVC格式，并配置profile为HEVC_PROFILE_MAIN_10的相机底层。编码器AVCodec配置颜色相关参数为COLOR_PRIMARY_BT2020。
- 视频编码器AVCodec需要选择HEVC格式，并配置profile为HEVC_PROFILE_MAIN_10的相机底层。
- 编码器AVCodec配置颜色相关参数为COLOR_PRIMARY_BT2020。
- Camera相机在创建video output实例时，选择yuv 10bit profile。HDR录像需要相机支持视频防抖功能，并配置颜色空间为BT2020_HLG_LIMIT。
- 相机在创建video output实例时，选择yuv 10bit profile。
- HDR录像需要相机支持视频防抖功能，并配置颜色空间为BT2020_HLG_LIMIT。

开发步骤


针对以上四点不同，使用Camera+AVCodec开发HDRVivid视频录制功能时，可参考以下步骤（详细开发步骤可参考HDRVivid视频录制）：


```less
// 创建视频编码器并初始化
int32_t VideoEncoder::Create(const std::string &videoCodecMime)
{
    encoder_ = OH_VideoEncoder_CreateByMime(OH_AVCODEC_MIMETYPE_VIDEO_HEVC);
    CHECK_AND_RETURN_RET_LOG(encoder_ != nullptr, AVCODEC_SAMPLE_ERR_ERROR, "Create failed");
    return AVCODEC_SAMPLE_ERR_OK;
}
```


```less
int32_t VideoEncoder::Configure(const SampleInfo &sampleInfo)
{
    // ...
    // 配置HDRVivid相关参数
    if (sampleInfo.isHDRVivid) {
        OH_AVFormat_SetIntValue(format, OH_MD_KEY_PROFILE, sampleInfo.hevcProfile);
        OH_AVFormat_SetIntValue(format, OH_MD_KEY_I_FRAME_INTERVAL, sampleInfo.iFrameInterval);
        OH_AVFormat_SetIntValue(format, OH_MD_KEY_RANGE_FLAG, sampleInfo.rangFlag);
        OH_AVFormat_SetIntValue(format, OH_MD_KEY_COLOR_PRIMARIES, sampleInfo.primary);
        OH_AVFormat_SetIntValue(format, OH_MD_KEY_TRANSFER_CHARACTERISTICS, sampleInfo.transfer);
        OH_AVFormat_SetIntValue(format, OH_MD_KEY_MATRIX_COEFFICIENTS, sampleInfo.matrix);
    }
    // ...
}
```


```less
// 配置编码器
int ret = OH_VideoEncoder_Configure(encoder_, format);
```


```less
export function videoProfileCheck(cameraManager: camera.CameraManager,
  cameraData: CameraDataModel): undefined | camera.VideoProfile {
  let cameraDevices = cameraManager.getSupportedCameras();
  // ...


  let profiles: camera.CameraOutputCapability =
    cameraManager.getSupportedOutputCapability(cameraDevices[0], camera.SceneMode.NORMAL_VIDEO);
  // ...


  let videoProfiles: Array<camera.VideoProfile> = profiles.videoProfiles;
  // ...


  let videoProfile: undefined | camera.VideoProfile = videoProfiles.find((profile: camera.VideoProfile) => {
    if (cameraData.isHDRVivid) {
      // ...
        return profile.size.width === cameraData.cameraWidth &&
          profile.size.height === cameraData.cameraHeight &&
          profile.format === camera.CameraFormat.CAMERA_FORMAT_YCRCB_P010 &&
          profile.frameRateRange.min === 1 &&
          profile.frameRateRange.max === 30;
      // ...
    } else {
      // ...
    }
  });
  return videoProfile;
}
```


```less
function isVideoStabilizationModeSupported(session: camera.VideoSession, mode: camera.VideoStabilizationMode): boolean {
  let isSupported: boolean = false;
  try {
    isSupported = session.isVideoStabilizationModeSupported(mode);
  } catch (error) {
    // 失败返回错误码error.code并处理
    let err = error as BusinessError;
    console.error(`The isVideoStabilizationModeSupported call failed. error code: ${err.code}`);
  }
  return isSupported;
}


function setVideoStabilizationMode(session: camera.VideoSession): boolean {
  let mode: camera.VideoStabilizationMode = camera.VideoStabilizationMode.AUTO;
  // 查询是否支持视频防抖
  let isSupported: boolean = isVideoStabilizationModeSupported(session, mode);
  if (isSupported) {
    console.info(`setVideoStabilizationMode: ${mode}`);
    // 设置视频防抖
    session.setVideoStabilizationMode(mode);
    let activeVideoStabilizationMode = session.getActiveVideoStabilizationMode();
    console.info(`activeVideoStabilizationMode: ${activeVideoStabilizationMode}`);
  } else {
    console.info(`videoStabilizationMode: ${mode} is not support`);
  }
  return isSupported;
}


function getSupportedColorSpaces(session: camera.VideoSession): Array<colorSpaceManager.ColorSpace> {
  let colorSpaces: Array<colorSpaceManager.ColorSpace> = [];
  try {
    colorSpaces = session.getSupportedColorSpaces();
  } catch (error) {
    let err = error as BusinessError;
    console.error(`The getSupportedColorSpaces call failed. error code: ${err.code}`);
  }
  return colorSpaces;
}


// 设置色彩空间
function setColorSpaceBeforeCommitConfig(session: camera.VideoSession, isHdr: boolean): void {
  let colorSpace: colorSpaceManager.ColorSpace = isHdr? colorSpaceManager.ColorSpace.BT2020_HLG_LIMIT : colorSpaceManager.ColorSpace.BT709_LIMIT;
  let colorSpaces: Array<colorSpaceManager.ColorSpace> = getSupportedColorSpaces(session);
  let isSupportedColorSpaces = colorSpaces.indexOf(colorSpace) >= 0;
  if (isSupportedColorSpaces) {
    console.info(`setColorSpace: ${colorSpace}`);
    session.setColorSpace(colorSpace);
    let activeColorSpace:colorSpaceManager.ColorSpace = session.getActiveColorSpace();
    console.info(`activeColorSpace: ${activeColorSpace}`);
  } else {
    console.info(`colorSpace: ${colorSpace} is not support`);
  }
}
```


```less
let XComponentPreviewProfile: camera.Profile | undefined = previewProfileCameraCheck(cameraManager, params)
if (XComponentPreviewProfile === undefined) {
  Logger.error(TAG, 'XComponentPreviewProfile is not found');
  return;
}
// ...


// 创建会话流
try {
  videoSession = cameraManager.createSession(camera.SceneMode.NORMAL_VIDEO) as camera.VideoSession;
} catch (error) {
  let err = error as BusinessError;
  Logger.error(TAG, `Failed to create the session instance. error: ${JSON.stringify(err)}`);
}
// ...


// 开始配置会话
try {
  videoSession.beginConfig();
} catch (error) {
  // ...
}


try {
  videoSession.addInput(cameraInput);
} catch (error) {
  // ...
}


// 将XComponent预览流添加到会话中
try {
  videoSession.addOutput(XComponentPreviewOutput);
} catch (error) {
  // ...
}


try {
  videoSession.addOutput(encoderVideoOutput);
} catch (error) {
  // ...
}


try {
  await videoSession.commitConfig();
} catch (error) {
  // ...
}


// 设置视频防抖
if (setVideoStabilizationMode(videoSession)) {
  // 设置色彩空间
  setColorSpaceBeforeCommitConfig(videoSession, true);
}


try {
  await videoSession.start();
} catch (error) {
  // ...
}


// 启动视频输出流
encoderVideoOutput.start((err: BusinessError) => {
  // ...
});
```


```less
// 创建封装器实例对象，设置封装格式为mp4
int32_t Muxer::Create(int32_t fd)
{
    muxer_ = OH_AVMuxer_Create(fd, AV_OUTPUT_FORMAT_MPEG_4);
    CHECK_AND_RETURN_RET_LOG(muxer_ != nullptr, AVCODEC_SAMPLE_ERR_ERROR, "Muxer create failed, fd: %{public}d", fd);
    return AVCODEC_SAMPLE_ERR_OK;
}


int32_t Muxer::Config(SampleInfo &sampleInfo)
{
    CHECK_AND_RETURN_RET_LOG(muxer_ != nullptr, AVCODEC_SAMPLE_ERR_ERROR, "Muxer is null");


    OH_AVFormat *formatVideo = OH_AVFormat_CreateVideoFormat(sampleInfo.videoCodecMime.data(),
        sampleInfo.videoWidth, sampleInfo.videoHeight);
    CHECK_AND_RETURN_RET_LOG(formatVideo != nullptr, AVCODEC_SAMPLE_ERR_ERROR, "Create video format failed");


    OH_AVFormat_SetDoubleValue(formatVideo, OH_MD_KEY_FRAME_RATE, sampleInfo.frameRate);
    OH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_WIDTH, sampleInfo.videoWidth);
    OH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_HEIGHT, sampleInfo.videoHeight);
    OH_AVFormat_SetStringValue(formatVideo, OH_MD_KEY_CODEC_MIME, sampleInfo.videoCodecMime.data());
    if (sampleInfo.isHDRVivid) {
        OH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_VIDEO_IS_HDR_VIVID, 1);
        OH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_RANGE_FLAG, sampleInfo.rangFlag);
        OH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_COLOR_PRIMARIES, sampleInfo.primary);
        OH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_TRANSFER_CHARACTERISTICS, sampleInfo.transfer);
        OH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_MATRIX_COEFFICIENTS, sampleInfo.matrix);
    }
    
    int32_t ret = OH_AVMuxer_AddTrack(muxer_, &videoTrackId_, formatVideo);
    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, "AddTrack failed");
    OH_AVFormat_Destroy(formatVideo);
    OH_AVMuxer_SetRotation(muxer_, sampleInfo.videoHeight > sampleInfo.videoWidth ? VERTICAL_ANGLE : HORIZONTAL_ANGLE);
    return AVCODEC_SAMPLE_ERR_OK;
}
```


```less
// 启动编码器
int32_t VideoEncoder::Start()
{
    CHECK_AND_RETURN_RET_LOG(encoder_ != nullptr, AVCODEC_SAMPLE_ERR_ERROR, "Encoder is null");


    int ret = OH_VideoEncoder_Start(encoder_);
    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, "Start failed, ret: %{public}d", ret);
    return AVCODEC_SAMPLE_ERR_OK;
}
```


HDRVivid视频播放


要实现HDRVivid视频播放，通常需要在视频播放流程中进行特定的处理，这包括：视频文件解析、解码器配置和渲染处理。


相对于主流格式视频播放的开发，HDRVivid视频播放的开发与其流程基本一致，只在解码格式上有所区别。下面将从解码格式上来讲解在HarmonyOS上进行视频开发的主要两种方案：

- 使用系统播放器（已集成系统解码和渲染能力）进行开发。
- 基于系统解码和渲染能力开发应用级播放器。

使用系统播放器AVPlayer开发


实现原理


AVPlayer提供功能完善一体化播放能力，应用只需要提供流媒体来源，不负责数据解析和解码就可达成播放效果。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152834.05935253943583592399920530689306:50001231000000:2800:0A42562C5814B3D14D524441F11416148AF999B72FE7796F64575EE03DAF1466.png)

开发步骤


使用系统播放器AVPlayer开发视频播放功能，主要开发步骤为（详细开发步骤可参考使用AVPlayer播放视频（ArkTS））：


```typescript
// 创建AVPlayer实例
public initAVPlayer() {
  media.createAVPlayer().then((player: media.AVPlayer) => {
    if (player !== null) {
      this.avPlayer = player;
      // this.curSource.video为本地视频路径，this.curSource.url为网络视频路径
      if (this.curSource.video) {
        let fileDescriptor = this.context?.resourceManager.getRawFdSync(this.curSource.video);
        if (fileDescriptor) {
          let avFileDescriptor: media.AVFileDescriptor =
            { fd: fileDescriptor.fd, offset: fileDescriptor.offset, length: fileDescriptor.length };
          this.avPlayer.fdSrc = avFileDescriptor;
        }
      } else {
        this.avPlayer.url = this.curSource.url;
      }
      // ...
    } else {
      Logger.error(TAG, 'createAVPlayer fail');
    }
  }).catch((error: BusinessError) => {
    Logger.error(TAG, `AVPlayer catchCallback, error message:${error.message}`);
  });
}
```


```typescript
private setStateChangeCallback(avPlayer: media.AVPlayer) {
  avPlayer.on('stateChange', async (state: string) => {
    switch (state) {
      // ...
      case 'initialized':
        Logger.info(TAG, 'AVPlayer state initialized called.' + ` this.curIndex:${this.curIndex}`);
        avPlayer.surfaceId = this.surfaceID;
        avPlayer.prepare();
        break;
      case 'prepared':
        // ...
        break;
      // ...
    }
  })
}
```


```typescript
public playVideo() {
  // ...
}


public pauseVideo() {
  // ...
}


public stopVideo() {
  // ...
}


public seek(seekTime: number) {
  // ...
}
```


```less
public releaseVideo(index: number) {
  if (this.avPlayer) {
    Logger.info(TAG,
      `releaseVideo: state:${this.avPlayer.state} this.curIndex:${this.curIndex} this.index:${index}`);
    this.avPlayer.off('timeUpdate');
    this.avPlayer.off('seekDone');
    this.avPlayer.off('speedDone');
    this.avPlayer.off('error');
    this.avPlayer.off('stateChange');
    this.avPlayer.release();
    // ...
  }
}
```


使用系统解码器AVCodec开发


实现原理


AVCodec模块的Native API接口，可以完成视频解码功能，即将媒体数据在系统侧解码成YUV文件或送显至应用上。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152834.88283439916636866530823250149274:50001231000000:2800:0A153686F4CCEAEF8C2CF31B0F263579F0FE485E9ACB4008C4C1EA9154AE2E64.png)

开发步骤


使用系统解码器AVCodec开发HDRVivid视频播放功能，主要开发步骤为（详细开发步骤可参考HDR Vivid视频播放）：


```less
// 创建解码器实例对象
int32_t VideoDecoder::Create(const std::string &videoCodecMime) {
    decoder_ = OH_VideoDecoder_CreateByMime(OH_AVCODEC_MIMETYPE_VIDEO_HEVC);
    CHECK_AND_RETURN_RET_LOG(decoder_ != nullptr, AVCODEC_SAMPLE_ERR_ERROR, "Create failed");
    return AVCODEC_SAMPLE_ERR_OK;
}
```


```less
// 设置回调函数
int32_t VideoDecoder::SetCallback(CodecUserData *codecUserData) {
    int32_t ret = AV_ERR_OK;
    ret = OH_VideoDecoder_RegisterCallback(decoder_,
                                           {SampleCallback::OnCodecError, SampleCallback::OnCodecFormatChange,
                                            SampleCallback::OnNeedInputBuffer, SampleCallback::OnNewOutputBuffer},
                                           codecUserData);
    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, "Set callback failed, ret: %{public}d", ret);


    return AVCODEC_SAMPLE_ERR_OK;
}
```


```less
// 配置解码器
int32_t VideoDecoder::Configure(const SampleInfo &sampleInfo) {
    // ...
    int ret = OH_VideoDecoder_Configure(decoder_, format);
    // ...
}
```


```less
int32_t VideoDecoder::Config(const SampleInfo &sampleInfo, CodecUserData *codecUserData) {
    // ...
    // 设置Surface。本例中的nativeWindow，需要从XComponent组件获取
    if (sampleInfo.window != nullptr) {
        int ret = OH_VideoDecoder_SetSurface(decoder_, sampleInfo.window);
        CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK && sampleInfo.window, AVCODEC_SAMPLE_ERR_ERROR,
                                 "Set surface failed, ret: %{public}d", ret);
    }


    // ...
    
    // 解码器就绪
    {
        int ret = OH_VideoDecoder_Prepare(decoder_);
        CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, "Prepare failed, ret: %{public}d", ret);
    }


    return AVCODEC_SAMPLE_ERR_OK;
}
```


```less
// 启动解码器
int32_t VideoDecoder::Start() {
    CHECK_AND_RETURN_RET_LOG(decoder_ != nullptr, AVCODEC_SAMPLE_ERR_ERROR, "Decoder is null");


    int ret = OH_VideoDecoder_Start(decoder_);
    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, "Start failed, ret: %{public}d", ret);
    return AVCODEC_SAMPLE_ERR_OK;
}
```


```less
// 写入解码码流
int32_t VideoDecoder::PushInputBuffer(CodecBufferInfo &info) {
    CHECK_AND_RETURN_RET_LOG(decoder_ != nullptr, AVCODEC_SAMPLE_ERR_ERROR, "Decoder is null");
    int32_t ret = OH_VideoDecoder_PushInputBuffer(decoder_, info.bufferIndex);
    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, "Push input data failed");
    return AVCODEC_SAMPLE_ERR_OK;
}
```


```less
// 渲染并释放解码帧
int32_t VideoDecoder::FreeOutputBuffer(uint32_t bufferIndex, bool render) {
    CHECK_AND_RETURN_RET_LOG(decoder_ != nullptr, AVCODEC_SAMPLE_ERR_ERROR, "Decoder is null");


    int32_t ret = AVCODEC_SAMPLE_ERR_OK;
    if (render) {
        ret = OH_VideoDecoder_RenderOutputBuffer(decoder_, bufferIndex);
    } else {
        ret = OH_VideoDecoder_FreeOutputBuffer(decoder_, bufferIndex);
    }
    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, "Free output data failed");
    return AVCODEC_SAMPLE_ERR_OK;
}
```


```less
// 销毁解码器实例，释放资源
int32_t VideoDecoder::Release() {
    if (decoder_ != nullptr) {
        OH_VideoDecoder_Flush(decoder_);
        OH_VideoDecoder_Stop(decoder_);
        OH_VideoDecoder_Destroy(decoder_);
        decoder_ = nullptr;
    }
    return AVCODEC_SAMPLE_ERR_OK;
}
```


HDRVivid视频转码成SDR视频


实现原理


将HDRVivid视频转码成SDR视频是一个涉及多个技术要点的复杂过程。通过合理的转码处理，可以确保视频内容在不同设备上都能呈现出更好的效果，不仅优化了视频的播放体验，还可以满足更广泛受众的需求，提高市场影响力。


开发步骤


HarmonyOS提供了Native侧的VideoProcessing函数，可以将HDRVivid视频转码成SDR视频，主要的开发步骤为（详细开发步骤可参考视频色彩空间转换）：


```less
void PluginManager::PrepareSurface(){
    VideoProcessing_ErrorCode ret = OH_VideoProcessing_InitializeEnvironment();
    if (ret != VIDEO_PROCESSING_SUCCESS) {
        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager","OH_VideoProcessing_InitializeEnvironment %d",ret);
        return;
    }
    
    // 创建色彩空间转换模块
    ret = OH_VideoProcessing_Create(&processor, VIDEO_PROCESSING_TYPE_COLOR_SPACE_CONVERSION);
    if (ret != VIDEO_PROCESSING_SUCCESS) {
        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager","OH_VideoProcessing_Create %d",ret);
        return;
    }
    
    // ...
}
```


```less
void PluginManager::InitProcessing(SampleInfo &sampleInfo){
    int32_t err = 0;
    OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager","target colorspace %{public}d",sampleInfo.colorSpace);
    // 为OHNativeWindow设置元数据属性值、宽高、内容格式等
    if (sampleInfo.colorSpace == OH_COLORSPACE_BT709_LIMIT) {
        err = OH_NativeWindow_NativeWindowHandleOpt(PluginManager::GetInstance()->windowOut, SET_FORMAT, NATIVEBUFFER_PIXEL_FMT_YCBCR_420_SP);
        // ...
    } else if (sampleInfo.colorSpace == OH_COLORSPACE_BT2020_HLG_LIMIT) {
        err = OH_NativeWindow_SetMetadataValue(PluginManager::GetInstance()->windowOut, 
            OH_HDR_METADATA_TYPE, sizeof(uint8_t), (uint8_t *)&sampleInfo.metaData);
        // ...
        err = OH_NativeWindow_NativeWindowHandleOpt(PluginManager::GetInstance()->windowOut, SET_FORMAT, NATIVEBUFFER_PIXEL_FMT_RGBA_1010102);
        // ...
    } else if (sampleInfo.colorSpace == OH_COLORSPACE_BT2020_PQ_LIMIT) {
        err = OH_NativeWindow_SetMetadataValue(PluginManager::GetInstance()->windowOut, 
            OH_HDR_METADATA_TYPE, sizeof(uint8_t), (uint8_t *)&sampleInfo.metaData);
        // ...
        err = OH_NativeWindow_NativeWindowHandleOpt(PluginManager::GetInstance()->windowOut, SET_FORMAT, NATIVEBUFFER_PIXEL_FMT_RGBA_1010102);
        // ...
    }
    
    // 为OHNativeWindow设置颜色空间属性
    err = OH_NativeWindow_SetColorSpace(PluginManager::GetInstance()->windowOut, sampleInfo.colorSpace);
    // ...
    // 设置输出surface
    VideoProcessing_ErrorCode ret = OH_VideoProcessing_SetSurface(processor, PluginManager::GetInstance()->windowOut);
    // ...
}
```


```less
// 创建并绑定回调函数
ret = OH_VideoProcessingCallback_Create(&callback);
if (ret != VIDEO_PROCESSING_SUCCESS) {
    OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager","OH_VideoProcessingCallback_Create %d",ret);
    return;
}


ret = OH_VideoProcessingCallback_BindOnError(callback, OnError);
if (ret != VIDEO_PROCESSING_SUCCESS) {
    OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager","OH_VideoProcessingCallback_BindOnError %d",ret);
    return;
}
ret = OH_VideoProcessingCallback_BindOnState(callback, OnState);
if (ret != VIDEO_PROCESSING_SUCCESS) {
    OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager","OH_VideoProcessingCallback_BindOnState %d",ret);
    return;
}
ret = OH_VideoProcessingCallback_BindOnNewOutputBuffer(callback, OnNewOutputBuffer);
if (ret != VIDEO_PROCESSING_SUCCESS) {
    OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager","OH_VideoProcessingCallback_BindOnNewOutputBuffer %d",ret);
    return;
}
OH_VideoProcessing_RegisterCallback(processor, callback, nullptr);
OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "PluginManager","InitProcessing end");
```


```less
// 启动色彩空间转换处理
void PluginManager::StartProcessing(){
    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "PluginManager","StartProcessing ");
    VideoProcessing_ErrorCode ret = OH_VideoProcessing_Start(processor);
    if (ret != VIDEO_PROCESSING_SUCCESS) {
        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager","StartProcessing %d",ret);
        return;
    }
}
```


```less
// 停止色彩空间转换处理
void PluginManager::StopProcessing(){
    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "PluginManager","StopProcessing ");
    VideoProcessing_ErrorCode ret = OH_VideoProcessing_Stop(processor);
    if (ret != VIDEO_PROCESSING_SUCCESS) {
        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager","OH_VideoProcessing_Stop %d",ret);
        return;
    }
}
```


```less
// 释放处理实例和资源
void PluginManager::DestroyProcessing(){
    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "PluginManager","DestroyProcessing ");
    VideoProcessing_ErrorCode ret = OH_VideoProcessing_Destroy(processor);
    if (ret != VIDEO_PROCESSING_SUCCESS) {
       OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager","OH_VideoProcessing_Destroy %d",ret);
       return;
    }
    ret = OH_VideoProcessingCallback_Destroy(callback);
    if (ret != VIDEO_PROCESSING_SUCCESS) {
       OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager","OH_VideoProcessingCallback_Destroy %d",ret);
       return;
    }
    ret = OH_VideoProcessing_DeinitializeEnvironment();
    if (ret != VIDEO_PROCESSING_SUCCESS) {
       OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "PluginManager","OH_VideoProcessing_DeinitializeEnvironment %d",ret);
       return;
    }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-image_get_and_save
爬取时间: 2025-05-08 03:36:49
来源: Huawei Developer


概述


应用在业务流程中常常有获取设备图片用于编辑、分享等的需求，可能还需要读取图片信息、将图像保存到本地等。本文介绍了HarmonyOS上几种常见的获取图片的方式、获取后读取图片信息、以及将图片保存在本地的操作，可供开发者学习和参考。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152834.01191756986388265259882624399819:50001231000000:2800:7513223394D5B74DBEBE1230FE0FD303FA997A5DE69FC4694106B3C8B347F089.gif)

获取图片


在HarmonyOS上，从智能终端获取图片的方式主要有两种：

- 用户从系统相册中选择想要的图片
- 通过相机拍摄获取

以下针对两种场景分别进行介绍。


从相册获取图片


HarmonyOS提供了两种便捷方法来从相册中获取图片，一种是基于PhotoPickerComponent（下文统称PhotoPicker组件）来在应用中直接访问相册中的图片或视频，另一种是使用PhotoViewPicker接口拉起系统相册后选择图片或视频文件。


实现原理


PhotoPicker组件是一个ArkUI组件，应用在页面中嵌入该组件，可以直接展示系统相册中的图片或视频文件，无需额外申请权限。用户可以直接在组件中选择想要的图片或视频文件。PhotoViewPicker是图库选择器，应用使用此接口可以跳转到系统相册选择一个或多个图片/视频，然后将所选的图片/视频以uris的形式传递回应用。


因此，如果开发者接受在应用页面中直接显示系统相册，则推荐使用PhotoPicker组件；如果开发者不希望系统相册在应用页面中占据空间，则推荐使用PhotoViewPicker跳转到系统相册应用里去选择图片或视频。


开发步骤


基于PhotoPicker组件获取图片的开发步骤可以参考指南使用PhotoPicker组件访问图片/视频，使用PhotoViewPicker拉起系统相册获取图片的开发步骤可以参考指南使用Picker选择媒体库资源。


拍照获取图片


除了从相册获取图片外，应用还可以通过拍照来获取图片。对于拍照这一行为，HarmonyOS上提供了系统相机和自定义相机两种选项。应用可以通过拉起系统相机拍照并获得一张照片，也可以自行实现自定义相机来拍照获取照片


实现原理


CameraPicker是系统提供的相机选择器，可以拉起系统相机为应用提供拍照或录像功能，结果以uri的形式返回给应用。系统还提供了一整套相机服务接口（包含ArkTS API和C API）给开发者用于开发适合自身需求的自定义相机功能，对自定义相机开发有诉求的开发者可以参考Camera Kit，本文不再赘述。


开发步骤


使用CameraPicker的参考代码如下：


```less
try {
  let pickerProfile: cameraPicker.PickerProfile =
    { cameraPosition: camera.CameraPosition.CAMERA_POSITION_BACK };
  // 选择拉起相机动作为拍照
  let pickerResult: cameraPicker.PickerResult = await cameraPicker.pick(getContext(this),
    [cameraPicker.PickerMediaType.PHOTO], pickerProfile);
  // 将拍照uri返回给应用
  this.imageUri = pickerResult.resultUri ? pickerResult.resultUri : this.imageUri;
  hilog.info(0x0000, TAG, 'cameraPicker.pick succeed, uri: ' + JSON.stringify(pickerResult));
} catch (error) {
  let err = error as BusinessError;
  hilog.error(0x0000, TAG, `cameraPicker.pick failed, error: ${err.code}, ${err.message}`);
}
```


读取图片信息


实现原理


HarmonyOS提供了ImageSource图片源类用于获取图片相关信息，既可以读取图片大小、像素格式等基本信息，也可以读取EXIF信息，如曝光时间、光圈值等。


开发步骤


首先基于前文获得的图片uri，创建一个ImageSource实例，然后调用相关方法即可读取图片信息。


读取基本信息：


```less
this.imageSource = image.createImageSource(this.path);
this.imageSource.getImageInfo((error: BusinessError, imageInfo: image.ImageInfo) => {
  if (error) {
    hilog.error(0x0000, TAG, `getImageInfo failed, error: ${error.code}, ${error.message}`);
  } else {
    hilog.info(0x0000, TAG, 'getImageInfo succeed, info: ' + JSON.stringify(imageInfo));
  }
});
```


读取EXIF信息：


```less
let key = [image.PropertyKey.IMAGE_WIDTH, image.PropertyKey.IMAGE_LENGTH, image.PropertyKey.F_NUMBER];
this.imageSource.getImageProperties(key).then((data) => {
  hilog.info(0x0000, TAG, 'getImageProperties succeed, data: ' + JSON.stringify(data));
}).catch((error: BusinessError) => {
  hilog.error(0x0000, TAG, 'getImageProperties failed, error: ' + JSON.stringify(error));
});
```


保存图片


对于已经编辑处理后的PixelMap图像，如果想要保存到本地，可以选择保存到文件目录或者是系统相册中。


保存到文件目录


实现原理


ImagePacker是HarmonyOS提供的图片打包器类，可以用于图片压缩和打包。在创建ImagePacker实例后，可以调用packToFile方法将PixelMap对象编码打包进文件，保存的路径可以指定具有写权限的文件目录，具体可以参考指南使用ImagePacker完成图片编码。


保存到系统相册


实现原理


要将PixelMap保存到系统相册，可以通过先将pixelmap保存到文件目录的方法，获得图片uri后，使用安全控件或者弹窗授权的方式保存到系统相册，具体可参考保存媒体库资源开发指南。


示例代码

- 实现图片获取与保存功能

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-graphic-drawing-practices
爬取时间: 2025-05-08 03:36:55
来源: Huawei Developer

- 使用Drawing自绘制能力提升性能
- 水印添加开发实践

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-drawing-capability-improve-performance
爬取时间: 2025-05-08 03:37:01
来源: Huawei Developer


概述


Canvas画布组件是用来显示自绘内容的组件，它具有保留历史绘制内容、增量绘制的特点。Canvas有CanvasRenderingContext2D/OffscreenCanvasRenderingContext2D和DrawingRenderingContext两套API，应用使用两套绘制API绘制的内容都可以在绑定的Canvas组件上显示。其中CanvasRenderingContext2D按照W3C标准封装了Native Drawing接口，可以方便快速复用Web应用的绘制逻辑，因此非常适用于Web应用和游戏、快速原型设计、数据可视化、在线绘图板、教学工具或创意应用等场景。


为了遵循W3C标准，实现过程中进行了多层的封装，涉及一些数据结构的转换，不如原生API那样接近硬件，因此对于性能要求比较高绘制比较复杂或者硬件依赖性比较强的场景如高性能游戏开发、专业图形处理软件、桌面或移动应用等，使用Canvas CanvasRenderingContext2D绘制会存在一定的卡顿、掉帧等性能问题，此时可以直接使用Native Drawing接口自绘制替代Canvas CanvasRenderingContext2D绘制来提升绘制性能。


| 方案  | 适用场景  | 特点  |
| --- | --- | --- |
| 使用Canvas CanvasRenderingContext2D  | Web应用和游戏、快速原型设计、数据可视化、在线绘图板、教学工具、创意应用  | 场景简单、跨平台、快捷灵活、兼容性强、开发维护成本低、性能要求低。  |
| 使用Native Drawing  | 高性能游戏开发、专业图形处理软件、桌面或移动应用开发  | 场景复杂、资源管理精细、硬件依赖强、与平台深度集成、定制化、性能要求高。  |

方案


适用场景


特点


使用Canvas CanvasRenderingContext2D


Web应用和游戏、快速原型设计、数据可视化、在线绘图板、教学工具、创意应用


场景简单、跨平台、快捷灵活、兼容性强、开发维护成本低、性能要求低。


使用Native Drawing


高性能游戏开发、专业图形处理软件、桌面或移动应用开发


场景复杂、资源管理精细、硬件依赖强、与平台深度集成、定制化、性能要求高。


原理机制


由于Canvas CanvasRenderingContext2D绘制本质上是对Native Drawing接口的封装，相对于直接使用Native Drawing接口，Canvas CanvasRenderingContext2D在实现过程中进行了多层的封装，涉及一些数据结构的转换。如果图片绘制比较复杂，执行的绘制指令可能会成倍数的增长，进而绘制性能下降的更加严重，导致卡顿、掉帧等问题。下面以实现在背景图上绘制1000个透明空心圆的玻璃效果来对比两者的性能差异。


场景示例


下图是一个绘制1000个透明空心圆与背景图融合的绘制场景，下面分别使用Canvas CanvasRenderingContext2D和Native侧的Drawing来实现该场景，并分析两者的性能差异。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152824.38114879372357589389428958410148:50001231000000:2800:34B8DE0CED15147BF73CB1551BD676835B2A87E2505E380B991BBC6C6F1CBF24.gif)

使用Canvas CanvasRenderingContext2D绘制


Canvas CanvasRenderingContext2D使用globalCompositeOperation属性来实现各种图层混合模式，此处将该属性的值设置为destination-out来实现透明空心圆。具体实现步骤如下：


```less
// entry\src\main\ets\pages\Index.ets
import GlassCoverView from '../view/GlassCoverView';


@Entry
@Component
struct Index {
  @State pointsToDraw: number[][] = [];


  /**
   * 随机生成1000个0-1的位置列表，在对应的位置上绘制圆圈
   */
  startDraw(): void {
    this.pointsToDraw = [];
    for (let index = 0; index < 1000; index++) {
      this.pointsToDraw.push([Math.random(), Math.random()]);
    }
  }


  build() {
    Stack() {
      Image($r('app.media.drawImage'))
        .width('100%')
        .height('100%')
      // 透明圆圈自定义组件，在此组件中绘制1000个透明圆圈
      GlassCoverView({ pointsToDraw: this.pointsToDraw })
        .width('100%')
        .height('100%')
      Row() {
        Button('Begin Draw')
          .width('100%')
          .height(40)
      }
      .padding({
        right: 16,
        bottom: 16,
        left: 16
      })
      .onClick(() => {
        this.startDraw();
      })
    }
    .alignContent(Alignment.Bottom)
    .width('100%')
    .height('100%')
  }
}
```

1.  使用Canvas CanvasRenderingContext2D绘制的trace图，可以看到绘制1000个圆圈耗时14.9毫秒。

```typescript
// entry\src\main\ets\view\GlassCoverView.ets
import { hiTraceMeter } from '@kit.PerformanceAnalysisKit';


/**
 * 玻璃蒙层效果
 */
@Preview
@Component
export default struct GlassCoverView {
  @Prop @Watch('onDraw') pointsToDraw: number[][] = [];
  private settings = new RenderingContextSettings(true);
  private renderContext = new CanvasRenderingContext2D(this.settings);
  private viewWidth: number = 0;
  private viewHeight: number = 0;


  build() {
    Stack() {
      Canvas(this.renderContext)
        .width('100%')
        .height('100%')
        .onAreaChange((_: Area, newValue: Area) => {
          this.handleAreaChange(newValue);
        })
    }
    .height('100%')
    .width('100%')
  }


  private handleAreaChange(area: Area): void {
    this.viewWidth = parseInt(area.width.toString());
    this.viewHeight = parseInt(area.height.toString());
    this.onDraw();
  }


  private onDraw(): void {
    const canvas = this.renderContext;
    canvas.reset();
    if (canvas === undefined) {
      return;
    }
    // 空心透明圆圈
    hiTraceMeter.startTrace('slow', 1);
    console.info('debug: slow start');
    // 保存绘图上下文
    canvas.save();
    // 清空给定矩形内的指定像素
    canvas.clearRect(0, 0, this.viewWidth, this.viewHeight);
    // 指定绘制的填充色
    canvas.fillStyle = '#77CCCCCC';
    // 填充一个矩形
    canvas.fillRect(0, 0, this.viewWidth, this.viewHeight);
    // 绘制空心圆圈
    canvas.globalCompositeOperation = 'destination-out';
    canvas.fillStyle = '#CCCCCC';
    this.pointsToDraw.forEach((xy: number[]) => {
      this.drawOneCell(canvas, xy[0] * this.viewWidth, xy[1] * this.viewHeight, px2vp(15));
    })
    canvas.fill();
    // 对保存的绘图上下文进行恢复
    canvas.restore();
    console.info('debug: slow end');
    hiTraceMeter.finishTrace('slow', 1);
  }


  /**
   * 根据指定的位置及宽度绘制圆
   */
  private drawOneCell(canvas: CanvasRenderer, x: number, y: number, width: number): void {
    canvas.moveTo(x + width, y);
    canvas.arc(x, y, width, 0, Math.PI * 2);
  }
}
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152824.99702274493756971249008535855813:50001231000000:2800:9930217E1882686D28FF101652A9AE55E85FE41228B59F95D36320ACBE7CD3E7.png)

使用Native侧Drawing绘制


Native Drawing主要使用分层接口OH_Drawing_CanvasSaveLayer和融合接口OH_Drawing_BrushSetBlendMode来实现多图融合效果。通过在前端创建一个自绘制节点RenderNode，并将图形绘制上下文及背景图参数通过Native侧暴露的接口传入，由Native使用相应Drawing接口进行绘制。具体实现步骤如下：

1.  新建一个自绘制渲染节点，并定义一个NodeController，对该节点进行管理。

```less
// entry\src\main\ets\pages\Index.ets
// 定义一个RenderNode自绘制渲染节点MyRenderNode，以便使用Native的接口进行绘制
class MyRenderNode extends RenderNode {
  private drawType: DrawType = DrawType.NONE;
  private pMap: image.PixelMap | undefined = undefined; // 背景图


  draw(context: DrawContext): void {
    // 调用Native侧的nativeOnDraw接口进行绘制，将背景图 this.pMap 和图形绘制上下文 context 作为参数传入
    testNapi.nativeOnDraw(666, context, vp2px(this.size.width), vp2px(this.size.height), this.drawType, this.pMap);
  }


  // 设置绘制类型
  resetType(type: DrawType): void {
    this.drawType = type;
  }


  // 设置背景图
  setPixelMap(p: PixelMap): void {
    this.pMap = p;
  }
}
```


```less
// entry\src\main\ets\pages\Index.ets
@Entry
@Component
struct Index {
  private myNodeController: MyNodeController = new MyNodeController();


  aboutToAppear(): void {
    const context: Context = getContext(this);
    const resourceMgr: resourceManager.ResourceManager = context.resourceManager;
    resourceMgr.getRawFileContent('drawImage.jpg').then((fileData: Uint8Array) => {
      console.info('success in getRawFileContent');
      const buffer = fileData.buffer.slice(0);
      const imageSource: image.ImageSource = image.createImageSource(buffer);
      imageSource.createPixelMap().then((pMap: image.PixelMap) => {
        // 自绘制渲染节点背景图
        newNode.setPixelMap(pMap);
      }).catch((err: BusinessError) => {
        console.error(`fail to create PixelMap, err: ${err}`);
      }).catch((err: BusinessError) => {
        console.error(`fail to getRawFileContent, err: ${err}`);
      })
    })
  }


  build() {
    Stack() {
      // 将自绘制渲染节点挂载到 NodeContainer
      NodeContainer(this.myNodeController)
        .height('100%')
      Row() {
        Button('Begin Draw')
          .width('100%')
          .height(40)
          .onClick(() => {
            newNode.resetType(DrawType.IMAGE);
            newNode.invalidate();
          })
      }
      .padding({
        right: 16,
        bottom: 16,
        left: 16
      })
    }
    .alignContent(Alignment.Bottom)
    .width('100%')
    .height('100%')
  }
}
```


```less
// entry\src\main\cpp\native_bridge.cpp
EXTERN_C_START
static napi_value Init(napi_env env, napi_value exports) {
    napi_property_descriptor desc[] = {
        // 暴露 nativeOnDraw 接口供前端调用，绑定 Native 侧的 OnDraw 函数
        {"nativeOnDraw", nullptr, OnDraw, nullptr, nullptr, nullptr, napi_default, nullptr}};
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
    return exports;
}
EXTERN_C_END
```


```less
// entry\src\main\cpp\native_bridge.cpp
static napi_value OnDraw(napi_env env, napi_callback_info info) {
    size_t argc = 6;
    napi_value args[6] = {nullptr};


    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);


    int32_t id;
    napi_get_value_int32(env, args[0], &id);


    // 图形绘制上下文参数
    void *temp = nullptr;
    napi_unwrap(env, args[1], &temp);
    OH_Drawing_Canvas *canvas = reinterpret_cast<OH_Drawing_Canvas *>(temp);


    int32_t width;
    napi_get_value_int32(env, args[2], &width);


    int32_t height;
    napi_get_value_int32(env, args[3], &height);


    DRAWING_LOGI("OnDraw, width:%{public}d, height:%{public}d", width, height);
    int32_t drawOption;
    napi_get_value_int32(env, args[4], &drawOption);
    // 背景图参数
    NativePixelMap *nativePixelMap = OH_PixelMap_InitNativePixelMap(env, args[5]);
    if (drawOption == IMAGE) {
        // 调用融合绘图接口进行绘制
        NativeOnDrawPixelMap(canvas, nativePixelMap);
    }
    return nullptr;
}
```

2.  使用Native侧Drawing绘制trace图，可以看到绘制1000个圆圈耗时2.4毫秒，相较于Canvas CanvasRenderingContext2D绘制有较大的性能提升。

```less
// entry\src\main\cpp\native_bridge.cpp
enum DrawType { NONE, PATH, TEXT, IMAGE };
#define DRAW_MAX_NUM 1000 // 最大绘制圆圈数量


// 生成随机坐标
static int RangedRand(int range_min, int range_max) {
    int r = ((double)rand() / RAND_MAX) * (range_max - range_min) + range_min;
    return r;
}


void DrawCircle(OH_Drawing_Path *path, int x, int y, int width) {
    OH_Drawing_PathMoveTo(path, x + width, y);
    OH_Drawing_Rect *rect = OH_Drawing_RectCreate(x - width, y - width, x + width, y + width);
    OH_Drawing_PathAddArc(path, rect, 0, 360);
}


// 空心圆圈与背景图融合场景绘制
static void NativeOnDrawPixelMap(OH_Drawing_Canvas *canvas, NativePixelMap *nativeMap) {
    // 画背景图
    OH_Drawing_CanvasSave(canvas);
    OH_Drawing_PixelMap *pixelMap = OH_Drawing_PixelMapGetFromNativePixelMap(nativeMap);
    // 创建采样选项对象
    OH_Drawing_SamplingOptions *sampling = OH_Drawing_SamplingOptionsCreate(FILTER_MODE_NEAREST, MIPMAP_MODE_NONE);
    // 获取背景图绘制区域
    OH_Drawing_Rect *src = OH_Drawing_RectCreate(0, 0, 360, 693);
    // 创建渲染区域
    OH_Drawing_Rect *dst = OH_Drawing_RectCreate(0, 0, 1300, 2800);
    // 创建画刷
    OH_Drawing_Brush *brush = OH_Drawing_BrushCreate();
    OH_Drawing_CanvasAttachBrush(canvas, brush);
    // 将背景图渲染到画布指定区域
    OH_Drawing_CanvasDrawPixelMapRect(canvas, pixelMap, src, dst, sampling);
    OH_Drawing_CanvasDetachBrush(canvas);


    // 调用分层接口
    OH_Drawing_CanvasSaveLayer(canvas, dst, brush);


    // 画蒙层
    OH_Drawing_Rect *rect2 = OH_Drawing_RectCreate(0, 0, 1300, 2800);
    OH_Drawing_Brush *brush2 = OH_Drawing_BrushCreate();
    // 设置画刷颜色
    OH_Drawing_BrushSetColor(brush2, OH_Drawing_ColorSetArgb(0x77, 0xCC, 0xCC, 0xCC));
    OH_Drawing_CanvasAttachBrush(canvas, brush2);
    OH_Drawing_CanvasDrawRect(canvas, rect2);
    OH_Drawing_CanvasDetachBrush(canvas);


    OH_Drawing_Point *pointArray[DRAW_MAX_NUM];
    int x = 0;
    int y = 0;
    for (int i = 0; i < DRAW_MAX_NUM; i++) {
        // 生成随机坐标
        x = RangedRand(0, 1300);
        y = RangedRand(0, 2800);
        pointArray[i] = OH_Drawing_PointCreate(x, y);
    }


    OH_Drawing_Point *point = OH_Drawing_PointCreate(800, 1750);
    OH_Drawing_Brush *brush3 = OH_Drawing_BrushCreate();
    // 设置圆圈的画刷和混合模式
    OH_Drawing_BrushSetBlendMode(brush3, BLEND_MODE_DST_OUT);
    OH_Drawing_CanvasAttachBrush(canvas, brush3);
    // 画圈
    OH_Drawing_Path *path = OH_Drawing_PathCreate();
    for (int i = 0; i < DRAW_MAX_NUM; i++) {
        x = RangedRand(0, 1300);
        y = RangedRand(0, 2800);
        DrawCircle(path, x, y, 15);
    }
    OH_Drawing_CanvasDrawPath(canvas, path);


    // 销毁对象
    OH_Drawing_CanvasDetachBrush(canvas);
    OH_Drawing_RectDestroy(rect2);
    OH_Drawing_BrushDestroy(brush2);
    OH_Drawing_BrushDestroy(brush3);
    OH_Drawing_PointDestroy(point);
    OH_Drawing_BrushDestroy(brush);
    OH_Drawing_CanvasRestore(canvas);
    OH_Drawing_SamplingOptionsDestroy(sampling);
    OH_Drawing_RectDestroy(src);
    OH_Drawing_RectDestroy(dst);
}
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152824.91175022470435054133845888230938:50001231000000:2800:CF7D2ABC0CFC1607A79D85DCD621C4BB82F0E0272A52F19D8B63C814354E5FAD.png)

效果对比


| 方案  | 圆圈数量  | 耗时  |
| --- | --- | --- |
| Canvas CanvasRenderingContext2D 画透明圈  | 1000  | 14.9毫秒  |
| Native Drawing画透明圈  | 1000  | 2.4毫秒  |

方案


圆圈数量


耗时


Canvas CanvasRenderingContext2D 画透明圈


1000


14.9毫秒


Native Drawing画透明圈


1000


2.4毫秒


通过上述对比可以发现，在实现较大数量透明空心圆这样的复杂的绘制场景，相比于Canvas CanvasRenderingContext2D，使用NativeDrawing可以得到明显的性能提升。以上只是实现透明空心圆融合场景，针对实心圆及其他融合场景（如globalCompositeOperation属性的其他值），由于实现机制的不同，绘制指令数量也存在差异，从而性能数据会存在一些差异。实际应用中，可以根据实际情况，在对性能要求不高的情况采用Canvas CanvasRenderingContext2D，如果对性能要求比较高，建议使用NativeDrawing进行绘制。


URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-add-watermark
爬取时间: 2025-05-08 03:37:07
来源: Huawei Developer


概述


在软件开发中，水印是一种在应用页面、图片或文档中嵌入的标记，它通常采用文字或图案的形式展现。水印通常有以下用途：

- 标识来源：可用于标识应用、各种文件的来源或作者，确保产权的归属。
- 版权保护：可携带版权保护信息，有效防止他人篡改、盗用、非法复制。
- 艺术效果：可作为一种艺术效果，为图片或应用增添独特的风格。

本文通过图文与代码结合的方式，对以下几种常见的水印添加场景进行讲解，旨在让开发者理解水印添加的基本原理以及掌握开发的流程与细节。

- 页面上添加水印
- 图片上添加水印
- PDF文档添加水印

页面上添加水印


场景描述


某个页面背景上添加水印文字，实现效果图如下。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152824.79540885306872802358386292719049:50001231000000:2800:5D96A58A1DA692A2BA363791E15B8E603EA38B09101BE9DE0FA6151B8B9B74C9.png)

实现原理


关键技术


Canvas提供画布组件，用于自定义绘制图形。使用CanvasRenderingContext2D对象在Canvas组件上进行绘制，其中fillText()方法用于绘制文本，drawImage()方法用于图像绘制。


开发流程


开发步骤

1.  最终通过CanvasRenderingContext2D.fillText()方法进行水印文字的绘制。

```typescript
// entry/src/main/ets/component/Watermark.ets
@Component
export struct Watermark {
  private settings: RenderingContextSettings = new RenderingContextSettings(true);
  private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);
  // ...
  build() {
    Canvas(this.context)
      .width('100%')
      .height('100%')
      .hitTestBehavior(HitTestMode.Transparent)
      .onReady(() => this.draw())
  }
}
```


```typescript
// entry/src/main/ets/component/Watermark.ets
@Component
export struct Watermark {
  private settings: RenderingContextSettings = new RenderingContextSettings(true);
  private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);
  // ...
  build() {
    Canvas(this.context)
      .width('100%')
      .height('100%')
      .hitTestBehavior(HitTestMode.Transparent)
      .onReady(() => this.draw())
  }
}
```

2.  最终通过CanvasRenderingContext2D.fillText()方法进行水印文字的绘制。

```less
// entry/src/main/ets/component/Watermark.ets
@Prop watermarkWidth: number = 120;
@Prop watermarkHeight: number = 120;
@Prop watermarkText: string = this.getWatermarkText();
@Prop rotationAngle: number = -30;
@Prop fillColor: string | number | CanvasGradient | CanvasPattern = '#10000000';
@Prop font: string = '16vp';


draw() {
  this.context.fillStyle = this.fillColor;
  this.context.font = this.font;
  const colCount = Math.ceil(this.context.width / this.watermarkWidth);
  const rowCount = Math.ceil(this.context.height / this.watermarkHeight);
  for (let col = 0; col <= colCount; col++) {
    let row = 0;
    for (; row <= rowCount; row++) {
      const angle = this.rotationAngle * Math.PI / 180;
      this.context.rotate(angle);
      const positionX = this.rotationAngle > 0 ? this.watermarkHeight * Math.tan(angle) : 0;
      const positionY = this.rotationAngle > 0 ? 0 : this.watermarkWidth * Math.tan(-angle);
      this.context.fillText(this.watermarkText, positionX, positionY);
      this.context.rotate(-angle);
      this.context.translate(0, this.watermarkHeight);
    }
    this.context.translate(0, -this.watermarkHeight * row);
    this.context.translate(this.watermarkWidth, 0);
  }
}
```

3. 
4. 
5.  方式一：使用Stack将水印组件叠加在UI组件上层。 方式二：设置UI组件的overlay属性，使水印组件作为UI组件的浮层显示。

```less
// entry/src/main/ets/pages/WatermarkStackPage.ets
Stack({ alignContent: Alignment.Center }) {
  Column() {
    Image($r('app.media.empty'))
      .width(110)
      .height(88)
  }
  Watermark({ rotationAngle: 20 })
}
```


```typescript
// entry/src/main/ets/component/Watermark.ets
@Component
export struct Watermark {
  private settings: RenderingContextSettings = new RenderingContextSettings(true);
  private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);
  // ...
  build() {
    Canvas(this.context)
      .width('100%')
      .height('100%')
      .hitTestBehavior(HitTestMode.Transparent)
      .onReady(() => this.draw())
  }
}
```

1.  最终通过CanvasRenderingContext2D.fillText()方法进行水印文字的绘制。

```less
// entry/src/main/ets/component/Watermark.ets
@Prop watermarkWidth: number = 120;
@Prop watermarkHeight: number = 120;
@Prop watermarkText: string = this.getWatermarkText();
@Prop rotationAngle: number = -30;
@Prop fillColor: string | number | CanvasGradient | CanvasPattern = '#10000000';
@Prop font: string = '16vp';


draw() {
  this.context.fillStyle = this.fillColor;
  this.context.font = this.font;
  const colCount = Math.ceil(this.context.width / this.watermarkWidth);
  const rowCount = Math.ceil(this.context.height / this.watermarkHeight);
  for (let col = 0; col <= colCount; col++) {
    let row = 0;
    for (; row <= rowCount; row++) {
      const angle = this.rotationAngle * Math.PI / 180;
      this.context.rotate(angle);
      const positionX = this.rotationAngle > 0 ? this.watermarkHeight * Math.tan(angle) : 0;
      const positionY = this.rotationAngle > 0 ? 0 : this.watermarkWidth * Math.tan(-angle);
      this.context.fillText(this.watermarkText, positionX, positionY);
      this.context.rotate(-angle);
      this.context.translate(0, this.watermarkHeight);
    }
    this.context.translate(0, -this.watermarkHeight * row);
    this.context.translate(this.watermarkWidth, 0);
  }
}
```

2. 
3. 
- 
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152825.31346905850882191699398924596827:50001231000000:2800:38B994A4C8090C6F035A78C9FF8CAFDB276DD8A07F7FAF2E931D7BC8F98FA3B0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152825.22813785304164746922963945240978:50001231000000:2800:E3DECE199EE1C40B6E84B4033C4459CCA0C06B22EA5B777C7148CD80F137A579.png)

如果需要多个页面或应用全局添加水印，可将上述方式二中的watermarkBuilder封装到一个单独的文件，export出一个全局的watermarkBuilder。在需要添加水印页面的根节点上添加.overlay绑定watermarkBuilder即可。


图片上添加水印


场景描述


保存的图片、拍照生成的图片等场景，需要添加水印。实现效果图如下。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152825.40543155625716776715192504263789:50001231000000:2800:EC5E1323DF771DAD173728AEB16D4FE8DBAB09F4432EEF0A29F0A9DDD2EDF36B.png)

实现原理


关键技术


OffscreenCanvas提供离屏画布，与Canvas使用场景区别在于是否需要将画布渲染在屏幕上。使用OffscreenCanvasRenderingContext2D在OffscreenCanvas上进行离屏绘制，其中fillText()方法用于绘制文本，drawImage()方法用于图像绘制。


开发流程


开发步骤


```less
// entry/src/main/ets/pages/SaveImagePage.ets
async getImagePixelMap(resource: Resource): Promise<ImagePixelMap> {
  const data: Uint8Array = await getContext(this).resourceManager.getMediaContent(resource);
  const arrayBuffer: ArrayBuffer = data.buffer.slice(data.byteOffset, data.byteLength + data.byteOffset);
  const imageSource: image.ImageSource = image.createImageSource(arrayBuffer);
  return await imageSource2PixelMap(imageSource);
}
```


```less
// entry/src/main/ets/pages/SaveImagePage.ets
async getImagePixelMap(resource: Resource): Promise<ImagePixelMap> {
  const data: Uint8Array = await getContext(this).resourceManager.getMediaContent(resource);
  const arrayBuffer: ArrayBuffer = data.buffer.slice(data.byteOffset, data.byteLength + data.byteOffset);
  const imageSource: image.ImageSource = image.createImageSource(arrayBuffer);
  return await imageSource2PixelMap(imageSource);
}
```


```less
// entry/src/main/ets/constants/Utils.ets
export async function imageSource2PixelMap(imageSource: image.ImageSource): Promise<ImagePixelMap> {
  const imageInfo: image.ImageInfo = await imageSource.getImageInfo();
  const height = imageInfo.size.height;
  const width = imageInfo.size.width;
  const options: image.DecodingOptions = {
    editable: true,
    desiredSize: { height, width }
  };
  const pixelMap: PixelMap = await imageSource.createPixelMap(options);
  const result: ImagePixelMap = { pixelMap, width, height };
  return result;
}
```


```less
// entry/src/main/ets/constants/Utils.ets
export function addWatermark(
  imagePixelMap: ImagePixelMap,
  text: string = 'watermark',
  drawWatermark?: (OffscreenContext: OffscreenCanvasRenderingContext2D) => void
): image.PixelMap {
  const height = px2vp(imagePixelMap.height);
  const width = px2vp(imagePixelMap.width);
  const offScreenCanvas = new OffscreenCanvas(width, height);
  const offScreenContext = offScreenCanvas.getContext('2d');
  offScreenContext.drawImage(imagePixelMap.pixelMap, 0, 0, width, height);
  if (drawWatermark) {
    drawWatermark(offScreenContext);
  } else {
    const imageScale = width / px2vp(display.getDefaultDisplaySync().width);
    offScreenContext.textAlign = 'right';
    offScreenContext.fillStyle = '#A2FFFFFF';
    offScreenContext.font = 12 * imageScale + 'vp';
    const padding = 5 * imageScale;
    offScreenContext.fillText(text, width - padding, height - padding);
  }
  return offScreenContext.getPixelMap(0, 0, width, height);
}
```


```less
// entry/src/main/ets/constants/Utils.ets
export async function saveToFile(pixelMap: image.PixelMap, context: Context): Promise<void> {
  try {
    const phAccessHelper = photoAccessHelper.getPhotoAccessHelper(context);
    const filePath = await phAccessHelper.createAsset(photoAccessHelper.PhotoType.IMAGE, 'png');
    const imagePacker = image.createImagePacker();
    const imageBuffer = await imagePacker.packing(pixelMap, {
      format: 'image/png',
      quality: 100
    });
    const mode = fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE;
    fd = (await fileIo.open(filePath, mode)).fd;
    await fileIo.truncate(fd);
    await fileIo.write(fd, imageBuffer);
  } catch (err) {
    hilog.error(0x0000, TAG, 'saveToFile error：', JSON.stringify(err) ?? '');
  } finally {
    if (fd) {
      fileIo.close(fd);
    }
  }
}
```


```less
// entry/src/main/ets/pages/SaveImagePage.ets
async getImagePixelMap(resource: Resource): Promise<ImagePixelMap> {
  const data: Uint8Array = await getContext(this).resourceManager.getMediaContent(resource);
  const arrayBuffer: ArrayBuffer = data.buffer.slice(data.byteOffset, data.byteLength + data.byteOffset);
  const imageSource: image.ImageSource = image.createImageSource(arrayBuffer);
  return await imageSource2PixelMap(imageSource);
}
```


```less
// entry/src/main/ets/constants/Utils.ets
export async function imageSource2PixelMap(imageSource: image.ImageSource): Promise<ImagePixelMap> {
  const imageInfo: image.ImageInfo = await imageSource.getImageInfo();
  const height = imageInfo.size.height;
  const width = imageInfo.size.width;
  const options: image.DecodingOptions = {
    editable: true,
    desiredSize: { height, width }
  };
  const pixelMap: PixelMap = await imageSource.createPixelMap(options);
  const result: ImagePixelMap = { pixelMap, width, height };
  return result;
}
```


PDF文档添加水印


场景描述


在PDF预览页面点击添加水印按钮，生成带水印的PDF文档，并显示在预览页面中。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152825.24058222698263811004086620463423:50001231000000:2800:D9B11CA271384C46D8F28CBF4C43062FFDA5553B77469EBE70144250912FFF7D.png)

实现原理


关键技术


pdfService模块为应用提供统一管理PDF页面的页眉页脚、水印、背景、批注、书签的能力。pdfService.TextWatermarkInfo类和pdfService.ImageWatermarkInfo分别提供创建文本水印和图片水印的能力。pdfService.PdfDocument类提供与文档相关能力，其中addWatermark()方法用于添加水印。


开发流程


开发步骤


```less
// entry/src/main/ets/pages/WatermarkPdfPage.ets
savePdfToSandbox(): string {
  const filePath = this.getPdfSandboxPath();
  fileIo.accessSync(filePath);
  const content: Uint8Array = getContext().resourceManager.getRawFileContentSync('watermark.pdf');
  const file = fileIo.openSync(filePath, fileIo.OpenMode.WRITE_ONLY | fileIo.OpenMode.CREATE | fileIo.OpenMode.TRUNC);
  fileIo.writeSync(file.fd, content.buffer);
  fileIo.closeSync(file.fd);
  return filePath;
}
```


```less
// entry/src/main/ets/pages/WatermarkPdfPage.ets
private controller: pdfViewManager.PdfController = new pdfViewManager.PdfController();
// ...
aboutToAppear(): void {
  const filePath = this.savePdfToSandbox();
  this.controller.loadDocument(filePath);
}
// ...
build() {
  // ...
      PdfView({
        controller: this.controller,
        pageFit: pdfService.PageFit.FIT_WIDTH
      })
        // ...
}
```


```less
// entry/src/main/ets/pages/WatermarkPdfPage.ets
getWatermarkInfo() {
  const watermarkInfo: pdfService.TextWatermarkInfo = new pdfService.TextWatermarkInfo();
  watermarkInfo.watermarkType = pdfService.WatermarkType.WATERMARK_TEXT;
  watermarkInfo.content = 'This is Watermark';
  watermarkInfo.textSize = 32;
  watermarkInfo.textColor = 200;
  watermarkInfo.opacity = 0.3;
  watermarkInfo.rotation = 45;
  watermarkInfo.opacity = 0.3;
  return watermarkInfo;
}
```


```less
// entry/src/main/ets/pages/WatermarkPdfPage.ets
addWatermark() {
  const filePath = this.getPdfSandboxPath();
  let pdfDocument: pdfService.PdfDocument = new pdfService.PdfDocument();
  pdfDocument.loadDocument(filePath);
  pdfDocument.addWatermark(this.getWatermarkInfo(), 0, pdfDocument.getPageCount(), true, true);
  const watermarkFilePath = this.getAddedWatermarkPdfSandboxPath();
  pdfDocument.saveDocument(watermarkFilePath);
  this.showInPdfView(watermarkFilePath);
}
```


```typescript
// entry/src/main/ets/pages/WatermarkPdfPage.ets
async showInPdfView(filePath: string) {
  this.hasWatermark = true;
  this.controller.releaseDocument();
  await this.controller.loadDocument(filePath);
  this.controller.setPageFit(pdfService.PageFit.FIT_WIDTH);
}
```


示例代码

- 水印添加能力

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-image-processing-practices
爬取时间: 2025-05-08 03:37:13
来源: Huawei Developer

- 图像模糊动效优化：静态模糊与动态模糊的性能对比解析

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-fuzzy-scene-performance-optimization
爬取时间: 2025-05-08 03:37:20
来源: Huawei Developer


概述


模糊效果是一种常见的图像处理技术，它通过减弱图像细节，去除干扰，使焦点更加鲜明。如下图所示，模糊效果不仅能增强界面空间感，还能清晰区分元素层级，是图像处理领域中一项常用且重要的技术手段。但当这一效果融入动态变化，便催生了模糊动效。模糊动效被广泛应用于页面之间的转场、图像元素的缩放等需要突出内容或改变用户关注点的场景中。


由于模糊算法需要对组件进行精细的像素级处理，当组件需要实时刷新时，这要求在极短的单个视频帧周期内完成模糊化处理。若组件同时还承担着繁重的动画渲染任务，则会进一步加剧计算资源的消耗，容易导致模糊效果处理时间不足，无法按时完成模糊动效，最终引发卡顿、丢帧等不良现象。


因此，随着应用的广泛普及，模糊动效的性能优化愈发显得至关重要。鉴于系统为开发者提供的静态模糊和动态模糊两种动效能力，本文将对比静态与动态模糊在“转场结合图片模糊”的应用场景下的性能差异，建议开发者在组件背景和内容无需实时更新的场景中，推荐使用静态模糊，可以减少应用卡顿与丢帧，提升用户体验。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152825.29788564107668395716773078619778:50001231000000:2800:845C3D3FF803DE35F83AECA355B810DFF192509FA2048456B71CABAC2BED8424.png)

使用场景


在介绍静态模糊和动态模糊之前，需要说明动态模糊和静态模糊的区别在于要模糊的内容是不是动态更新的，如对视频做模糊就是动态模糊，对图片做模糊就是静态模糊。

- 静态模糊：静态模糊是指对输入的静态内容进行模糊处理并获取一张模糊后的图像的模糊。适用于需要为静态图像提供模糊化效果的场景。Effect Kit在Filter图像效果类中提供了blur接口，可用于定义模糊半径，数值越大模糊效果越明显。
- 动态模糊：动态模糊是指模糊效果会随着每帧模糊内容和模糊半径的变化，进行实时变化的模糊。适用于模糊内容需要实时刷新和更改的场景。系统针对组件内容、背景的动态模糊提供了两种实现动态模糊的方法：backgroundBlurStyle和foregroundBlurStyle。这两个方法不能指定模糊半径、提亮、饱和度、蒙版颜色等具体参数，只能调用底层将这些参数封装好的模糊样式来实现不同风格的模糊效果。同时系统也为开发者提供了能够自定义参数的backgroundEffect，可以对组件背景实现自定义模糊动效。如果只需要对组件进行简单的模糊处理，系统还提供了与静态模糊类似的简单方法blur和backdropBlur，只需要定义模糊半径即可。

场景示例


下面将在常见的“转场结合图片模糊”的应用场景下（全屏模态转场拉起一个图片设置模糊的模态页面)，分别采用动态模糊和静态模糊，进行性能分析对比。需要说明，由于静态模糊和动态模糊底层采用的算法不同，动态模糊blur和静态模糊blur设置的模糊半径数值并不等效。为了从效果一致性的维度来更准确的比较两者的性能差异，这里将动态模糊和静态模糊场景的模糊半径的数值尽可能的调整到类似的模糊效果来进行对比。动态模糊blur设置13，静态模糊blur设置3的图片模糊效果较为接近，作为本例中效果一致性较为近似的等效条件。


下面是使用动态模糊对图片进行模糊处理的场景示例。通过直接对Image组件设置blur，为Image添加模糊效果。


```typescript
import { window } from '@kit.ArkUI';


@Component
export struct MotionBlur {
  @Consume('navPathStack') navPathStack: NavPathStack;
  @State isShowMotionBlur: boolean = false;
  @State bottomSafeHeight: number = 0; // bottom navigation bar height


  aboutToAppear() {
    window.getLastWindow(getContext(this), (err, windowBar) => {
      if (err.code) {
        return;
      }
      // get the height of the bottom navigation bar
      this.bottomSafeHeight =
        px2vp(windowBar.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR).bottomRect.height);
      windowBar.setWindowLayoutFullScreen(true);
    });
  }


  // modal page with dynamically blurred image settings
  @Builder
  motionBlurBuilder() {
    Stack({ alignContent: Alignment.Bottom }) {
      Image($r('app.media.test'))
        .width('100%')
        .height('100%')
        .objectFit(ImageFit.Fill)
        .blur(13) // add motion blur effect
      Button('close')
        .width('90%')
        .height(40)
        .margin({ bottom: this.bottomSafeHeight + 16 })
        .onClick(() => {
          this.isShowMotionBlur = false;
        })
    }
    .width('100%')
    .height('100%')
  }


  build() {
    NavDestination() {
      Column() {
        Button('motion blur')
          .width('90%')
          .height(40)
          .onClick(() => {
            this.isShowMotionBlur = true;
          })
          .bindContentCover(this.isShowMotionBlur, this.motionBlurBuilder(), {
            modalTransition: ModalTransition.DEFAULT
          })
      }
      .padding({ bottom: this.bottomSafeHeight + 16 })
      .width('100%')
      .height('100%')
      .justifyContent(FlexAlign.End)
    }
    .hideTitleBar(true)
  }
}
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152825.72352766645839600129580700436997:50001231000000:2800:DC96B319D828053D0252A15BC85B63ACE40DE57DF0A5255103E2E88C8DBDEE3C.gif)

下面是使用静态模糊对图片进行模糊处理的场景示例。主要步骤如下：


```typescript
import { image } from '@kit.ImageKit';
import { effectKit } from '@kit.ArkGraphics2D';
import { window } from '@kit.ArkUI';


@Component
export struct StaticBlur {
  @Consume('navPathStack') navPathStack: NavPathStack;
  @State isShowStaticBlur: boolean = false;
  @State pixelMap: image.PixelMap | undefined = undefined;
  @State imgSource: image.ImageSource | undefined = undefined;
  @State bottomSafeHeight: number = 0; // bottom navigation bar height


  aboutToAppear() {
    window.getLastWindow(getContext(this), (err, windowBar) => {
      if (err.code) {
        return;
      }
      // get the height of the bottom navigation bar
      this.bottomSafeHeight =
        px2vp(windowBar.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR).bottomRect.height);
      windowBar.setWindowLayoutFullScreen(true);
    });
  }


  async staticBlur() {
    let context = getContext(this);
    let resourceMgr = context.resourceManager; // retrieve the resourceManager object
    const fileData = await resourceMgr.getRawFileContent('test.png'); // retrieve images from the rawfile directory
    let buffer: ArrayBuffer = fileData.buffer.slice(0); // create an ArrayBuffer instance
    this.imgSource = image.createImageSource(buffer); // create an image source instance
    // create attributes for pixels
    let opts: image.InitializationOptions = {
      editable: true, // is it editable
      pixelFormat: 3, // pixel format. 3 represents RGBA_8888
      size: {
        // create image size
        height: 4,
        width: 6
      }
    };
    // create PixelMap
    await this.imgSource.createPixelMap(opts).then((pixelMap: image.PixelMap) => {
      const blurRadius = 3;
      let headFilter = effectKit.createEffect(pixelMap); // create Filter Instance
      if (headFilter !== null) {
        headFilter.blur(blurRadius); // set static blur. Add the blur effect to the effect list
        // retrieve the image of the source image with the added linked list effect PixelMap
        headFilter.getEffectPixelMap().then((pixelMap: image.PixelMap) => {
          this.pixelMap = pixelMap;
        });
      }
    })
  }


  @Builder
  staticBlurBuilder() {
    Stack({ alignContent: Alignment.Bottom }) {
      Image(this.pixelMap)
        .width('100%')
        .height('100%')
        .objectFit(ImageFit.Fill)
      Button('close')
        .width('90%')
        .height(40)
        .margin({ bottom: this.bottomSafeHeight + 16 })
        .onClick(() => {
          this.isShowStaticBlur = false;
        })
    }
    .width('100%')
    .height('100%')
  }


  build() {
    NavDestination() {
      Column() {
        Button('static blur')
          .width('90%')
          .height(40)
          .onClick(() => {
            this.isShowStaticBlur = true;
            // set static blur
            this.staticBlur();
          })
          .bindContentCover(this.isShowStaticBlur, this.staticBlurBuilder(), {
            modalTransition: ModalTransition.DEFAULT
          })
      }
      .padding({ bottom: this.bottomSafeHeight + 16 })
      .width('100%')
      .height('100%')
      .justifyContent(FlexAlign.End)
    }
    .hideTitleBar(true)
  }
}
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152825.39229328531551242710116944936799:50001231000000:2800:F12B0F2D7865499E0FF790618C8B5137B50CC0ECE3BABADBD35F21C4D72DFAB0.gif)

效果对比


下面使用DevEco Studio内置的Profiler中的帧率分析工具Frame抓取点击按钮触发转场过程的trace来分析静态模糊和动态模糊场景下的性能差异。需要说明，由于场景示例通过点击按钮触发转场，所以可以通过User Events（用户输入事件）的Click标签定位到转场过程的起点为Click标签结束位置。转场过程的终点为连续的RenderFrame（执行GPU绘制）标签不再连续的位置。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152826.16870998628622636479868768822346:50001231000000:2800:6D97868B3A680D0F5CD8B6DDA216AA4862EFBC9B238E90473111EC648E339C19.png)

如上图所示，通过RenderFrame（执行GPU绘制）标签可以看出，动态模糊转场平均渲染耗时为6.113ms。同时从Present Fence（图形上屏信号）标签可以看出动态模糊转场平均帧率为108.0fps。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152826.51098565310599161939884651387529:50001231000000:2800:600060C33D3ED23CE2C8249343110EF245E011130DD87603EB459E00367473B9.png)

如上图所示，通过RenderFrame标签可以看出，静态模糊转场平均渲染耗时为3.357ms。同时从Present Fence标签可以看出静态模糊转场平均帧率为119.9fps。和动态模糊转场相比平均渲染耗时减少了约45%（性能耗时数据因应用场景、设备型号版本而异，以实测为准）。


由此可见，在模糊效果类似的条件下，静态模糊的性能要优于动态模糊。这源于底层实现机制的差异：静态模糊只需完成一次性的模糊处理，有效减轻了实时渲染的负担；而动态模糊则需要对每一帧进行连续的模糊计算，尽管在理想情况下能够营造出更为平滑和连贯的视觉过渡效果，但同时也显著增加了渲染的复杂度和资源消耗，若页面过于复杂，反而可能导致卡顿或丢帧现象的发生。


示例代码

- 图像模糊动效优化

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-gpu-acceleration-practices
爬取时间: 2025-05-08 03:37:25
来源: Huawei Developer

- 马良GPU最佳实践

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-maleoon-gpu-best-practices
爬取时间: 2025-05-08 03:37:32
来源: Huawei Developer


概述


本文档主要指导开发者如何在马良（Maleoon）GPU上达到最佳的性能表现，只针对Maleoon GPU的优化实践，帮助开发者高效完成渲染任务，如果想要达成该目标，首先需要通过Graphics Profiler等GPU分析工具，找到当前的能效瓶颈点，并遵循以下两个基本优化原则进行性能调优。本文所有优化建议，都将围绕这两个基本优化原则展开。


图形渲染的基本流程如下图所示。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152826.28125056465409782826927398304111:50001231000000:2800:0F21F8D758E6DED76A48136739315D3A3B2DDA1CD6751186F496CE4A01FE7AE0.jpg)

本文档主要适用于以下开发者：


熟悉图形标准API（Vulkan或OpenGL ES）、了解shader编码，有一定GPU性能优化基础。


CPU优化


Memory


仅适用于Vulkan。


vkAllocateMemory为了避免分配的内存没有真正被渲染线程使用，造成内存浪费，采用了延迟分配（protected memory除外）的处理。在调用vkBindImageMemory || vkBindBufferMemory || vkMapMemory（如果内存支持VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT属性）时会真正分配内存，但是需要在此之前调用vkAllocateMemory分配device memory对象。


【推荐】


根据资源需求，选择最为匹配的内存类型进行内存分配，相同类型的memory按照用户实际需求一次分配大块size用于不同类型的资源（比如index buffer、vertex buffer及uniform buffer），可以提升内存申请的效率。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152827.73981928101247667092470152111009:50001231000000:2800:2F5926127A37C24E3F1C24E63B8BA91EA514ADE4CE0428AFAA080BDEB5376995.jpg)
- vkFreeMemory一定要与vkAllocateMemory成对使用，避免内存泄露。
- 绑定的memory资源尽量分时复用。
- 如果存在CPU访问内存，建议使用VK_MEMORY_PROPERTY_HOST_CACHED_BIT进行申请。

【不推荐】


频繁使用vkAllocateMemory。设备内存申请次数支持的最大数量可以通过maxMemoryAllocationCount limits属性获取。


2. Device Memory访问


仅适用于Vulkan。


按照spec描述的内存类型范围支持4种类型：

- VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
- VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT
- VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT
- VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_PROTECTED_BIT

对于不同类型的memory资源，有不同的使用方法：

- DEVICE_LOCAL | HOST_VISIBLE | HOST_COHERENT类型：属于CPU non-cache的内存，最好是用于CPU只写的资源。
-  以上这两个操作对性能都有一定的消耗。
- vkFlushMappedMemoryRanges：CPU修改对GPU可见，CPU到GPU的同步。
- vkInvalidateMappedMemoryRanges：GPU对memory的更新对CPU可见，GPU到CPU的同步。
- DEVICE_LOCAL | LAZILY_ALLOCATED类型：此种类型的内存允许只分配虚拟地址空间而不分配物理页，如果存在内存访问，则按需分配更多的物理页，支持内存增长。
- DEVICE_LOCAL | PROTECTED类型：Protected Flag将内存分成了Protected device memory和Unprotected device memory两种。Protected device memory只对device（即GPU）可见，对host（即CPU）不可见。Unprotected device memory对device可见，也可以对host可见，取决于host visible属性。
- Protected device memory只对device（即GPU）可见，对host（即CPU）不可见。
- Unprotected device memory对device可见，也可以对host可见，取决于host visible属性。
- vkFlushMappedMemoryRanges：CPU修改对GPU可见，CPU到GPU的同步。
- vkInvalidateMappedMemoryRanges：GPU对memory的更新对CPU可见，GPU到CPU的同步。
- Protected device memory只对device（即GPU）可见，对host（即CPU）不可见。
- Unprotected device memory对device可见，也可以对host可见，取决于host visible属性。

【推荐】

- DEVICE_LOCAL | HOST_VISIBLE | HOST_COHERENT类型的内存用于CPU只写的资源。
- DEVICE_LOCAL | HOST_VISIBLE | HOST_CACHED类型的内存用于CPU回读的资源。
- DEVICE_LOCAL | LAZILY_ALLOCATED类型的内存只能用于TRANSIENT_ATTACHMENT用途的image。

【不推荐】


从CPU non-cache的内存中频繁回读数据，会影响性能。


Pipeline


仅适用于Vulkan。


Pipeline是整个渲染过程的状态集合，包括可编程的shader和不可编程的fixed function state，其参数配置影响整个渲染过程的执行效率。


1. Shader Stage


【推荐】


```less
vec2 baseCoord = ve2(0.0);
vec2 offset[4] = {...};
float weight[4] = {...};
vec4 color = vec4(0.0);
for (int i = 0; i < 4; i++) {
    color += weight[i] * texture(texSampler, baseCoord + offset[i]);
}
```

- shader中如果访问小批量的常量数据，推荐使用push constant。
- shader中访问uniform buffer array时，索引下标使用编译时常量。
- shader中访问uniform buffer时，访问的位置使用编译时常量。
- compute shader的一个workgroup size的三个维度的乘积为32的整数倍。
- fragment shader中，使用input attribute作为采样坐标去采样的次数小于等于8次，且所有采样用的texture和sampler都放到同一个descriptor set中。

【不推荐】

- 使用tessellation shader和geometry shader。
- create VkDevice时使能VkPhysicalDeviceProtectedMemoryFeatures::protectedMemory(或者VkPhysicalDeviceVulkan11Features::protectedMemory)。
- 需要使能depth test时，fragment shader中使用discard指令。
- 需要使能depth test时，fragment shader中写gl_FragDepth。
- 需要使能depth test时，fragment shader中写了storage image或者storage buffer。
- 需要使能depth test时，fragment shader中写了gl_SampleMask。
- fragment shader中使用highp。
- 需要使能blend时，fragment shader的输出color值与color attachment format的精度不匹配。例如color format是VK_FORMAT_B10G11R11_UFLOAT_PACK32，针对R通道，预期颜色在0.0~1.0f精度范围内时11bit的float可以表示较为精准，但是数值越大能够表示的精度越差。两个相邻像素本来预期的颜色假如是1024.0f和1024.1f，但是11bit可以精确表示1024.0f，但是无法精确表示1024.1f，所以1024.1f被存储成1040.0f，导致视觉效果上产生突变。

2. Fixed State


【推荐】

- 不同的vertex attribute在vertex buffer内连续排布。
- 不同的vertex attribute其所属的vertex buffer的binding号从0开始连续编排。比如有2个vertex buffer，其binding号配置为0和1性能较友好，配置为1和3性能不友好。
- App如果需要提前使用vkCreateGraphicsPipelines进行场景预热，建议create info中（主要是renderpass、pipeline layout、blend state、multisample count、alpha to coverage）要填充真实场景所使用的create info，因为这些info会影响shader的编译，如果预热时填充的create info与真实场景不一致，pipeline cache起不到作用，达不到预热的目的。

【不推荐】


使能depth test时，开启alpha to coverage。


【影响】


使能multisample，消耗多倍GPU运行资源，降低执行效率。


Shader编译


仅适用于OpenGL ES。


Shader的首次编译（glCompileShader，glLinkProgram）耗时长，若在应用运行时进行实时编译，容易引起卡顿和丢帧，影响用户体验。


【推荐】


建议将Shader编译提前至应用启动时进行。


【不推荐】


在应用运行时实时编译Shader。


Command Buffer


Command buffer usage flags会影响command buffer的执行性能。当使用了SIMULTANEOUS_USE_BIT时，会降低command buffer的执行性能。如果在renderpass内使用secondary command buffer，flags不会有影响。


【推荐】


使用ONE_TIME_SUBMIT_BIT flag创建Command Buffer。


【不推荐】


除了用在renderpass内的secondary command buffer，其他类型的command buffer使用SIMULTANEOUS_USE_BIT。


Draw Call Batching


游戏下发的draw call数量越多，带来的CPU开销越多，整体的性能越差，建议合并draw call来降低CPU侧的开销。


【推荐】


一些典型的Draw call Batching场景：

-  所使用的vertex buffers或者texture等资源变化，这些draw可以通过合并vertex buffer或使用texture arrays等方式来合并。
-  通常绘制石头、树、灌木丛等情况，游戏会使用多个相同几何形状的instance去绘制，这种情况建议使用instance draw来完成。
- 使用Multi-Draw indirect功能

【不推荐】

- 使用大量顶点数少的draw call。
- 频繁切换管线状态，例如program、uniform等，对应相同管线状态的draw call尽量集中处理。

GPU优化


Vertex shading


1. 精度


为了规避Vertex shader计算位置信息的偏差导致后续shader stage误差放大，Maleoon GPU上vertex shader精度统一按照highp实现。


【推荐】


建议使用highp设置。


2. InstanceID


InstanceID经常会参与uniform buffer索引值的计算，此种情况下，Maleoon GPU会根据是否能有效减小load mem的次数从而开启Single InstanceID优化。此优化可以保证每组任务运行时InstanceID一致，从而每组任务load mem只用执行first thread一次load即可拿到整组对应数据。进一步，如果此shader所有uniform不超过1024 bytes大小，此uniform buffer可以完全放在constant register里面，即可通过Maleoon GPU特有的relative constant register代替此load mem操作，性能最优。


【推荐】

- InstanceID参与uniform buffer索引值计算时，uniform buffer中尽量精简只保留有效数据。
- 条件允许下，InstanceID每个实例可以多画一些点，性能收益更大。
- InstanceID参与uniform buffer索引值计算时，尽量不要在复杂的嵌套之内。

【示例】


原始shader：


```less
struct unity_ Type {
    vec4 vecArrA[4];
    vec4 vecArrB[4];
};
layout(std140) uniform UnityInstancing_PerDraw0 {
    unity_Type unity_Array[32];
};
void main() {
    u_xlati0 = gl_InstanceID + unity_BaseInstanceID;
    u_xlati0 = u_xlati0 << 2;
    u_xlat1.yw = (-_mhyWorldOffset.zx) + unity_Array[u_xlati0 / 4].vecArrA[3].zx;
}
```


推荐shader：


```less
struct unity_ Type {
    vec4 vecArrA[4];
};
layout(std140) uniform UnityInstancing_PerDraw0 {
    unity_Type unity_Array[32];
};
void main() {
    u_xlati0 = gl_InstanceID + unity_BaseInstanceID;
    u_xlati0 = u_xlati0 << 2;
    u_xlat1.yw = (-_mhyWorldOffset.zx) + unity_Array[u_xlati0 / 4].vecArrA[3].zx;
}
```


3. 顶点排布


Maleoon GPU是Tile-Based架构的GPU，对于Tile-Based架构的GPU，有一个单独的pass（binning pass）仅用于计算顶点着色器的顶点位置。因此，如果输入的顶点位置相关属性与所有其他属性存储在同一个buffer中，则binning pass获取vertex shader输入时，由于memory的连续读取粒度较大，将会导致实际读取到较多对该shader无效的输入数据，内存带宽将会增加很多。


【推荐】


将顶点相关的属性存储在独立buffer中。


Per-Fragment Test


Overdraw


Overdraw作为影响GPU性能的核心问题之一，开发者可以对于不透明的primitive进行排序，让后面的primitive可以被剔除，GPU也在硬件层次上支持不依赖primitive排序的剔除方案。


Maleoon GPU内部有一套针对Depth Test的硬件优化，主要功能是对传统图形管线Depth Test的补充优化，目的是在更早期阶段，以较粗的粒度区块，提前剔除掉一些无效的绘制，从而更好的减少后级管线的开销。


Renderpass整体的CompareOp是以第一次满足“可进行深度剔除”时的Op为主要方向，例如，一段Renderpass有3个draw，它们的Depth Test通过条件分别为less (不满足剔除条件) 、 greater (满足剔除约束) 、 greater (不满足剔除约束)，则该段Renderpass以greater为主要方向进行深度剃除。


【推荐】

- 尽可能开启depth write enable。不开启会导致当下draw无法更新深度剔除值，从而产生overdraw。
- renderpass内各个draw的compareOp保持一致。当renderpass中，某个draw的compareOp与该renderpass的主要方向的compareOp相反。此时，当下draw无法进行深度剔除及深度更新，从而产生overdraw。
- Clear attachment尽可能放在renderpass的最开始或者是renderpass尚未赋予主要方向。若出现主要方向后，某draw有clear attachment操作，则从此draw开始无法进行深度剔除及深度值更新。

【不推荐】

- 当Draw的compareOp为equal、not_equal、always、never这些状态时，当下draw无法进行深度更新。
- 当renderpass已确定主要方向后，若之后的过程中出现compareOp为always或者是not_equal，从此always或not_equal的draw开始，包含之后所有的draw，无法进行深度剔除及更新深度剔除值。
- Draw同时使能depth bound enable和depth write enable。若出现此种情况，从此draw开始，无法进行深度剔除及深度值更新。
- Draw同时使能blend和depth write enable。若出现此种情况，从此draw开始，无法再更新深度剔除值，从而降低剔除率。
- shader使用discard、gl_SampleMask、gl_FragDepth、alpha2coverage等配置。若出现此种情况，当下draw的深度剔除值将无法更新。
- renderpass中绑定不同组pipeline，其PipelineColorBlendAttachmentState -> colorWriteMask会出现不一致的情况，当下的draw无法进行深度更新。若满足该条件且depth write enable，从此draw开始，无法进行深度剔除及深度值更新。

Fragment Shading


1. Renderpass


1.1 基本配置


Vulkan


Vulkan API明确定义了每个attachment在渲染开始和结束时行为，比如API接口中的loadOp定义了GPU如何在渲染开始时初始化片上内存，storeOp定义了渲染结束时是否需要写回主内存。


【推荐】

- 在不依赖于attachment初始内容的情况下，attachment的loadOp设置为LOAD_OP_NONE来初始化。
- Attachment的loadOp设置为LOAD_OP_CLEAR来清除内存。
- 不依赖的attachment，其storeOp设置为STORE_OP_NONE节省带宽。

【不推荐】

- 使用vkCmdClearColorImage或者vkCmdClearDepthStencilImage接口来清除作为attachment的image。
- 使用vkCmdClearAttachments接口来清除attachment。
- 使用shader写固定颜色来清除attachment。
- 在不依赖于attachment初始内容的情况下，attachment的loadOp设置为LOAD_OP_LOAD。
- 配置不需要的attachment。
- 不依赖的attachment，storeOp设置为STORE_OP_STORE。

OpenGL ES


OpenGL ES并没有明确的API来定义render pass的开始和结束，而是由GPU驱动根据framebuffer的绑定调用来推断的。


一个framebuffer的render pass通常开始于该framebuffer的target被绑定为GL_DRAW_FRAMEBUFFER，结束于换绑另一个framebuffer为GL_DRAW_FRAMEBUFFER。


【推荐】

- 全屏绘制的render pass，在render pass开头增加一个glClear操作。如果一个render pass前没有glClear操作，GPU将会在render pass的开始插入一个回读的操作从内存中读取attachment初始内容到GPU片上，带来不必要的带宽开销。
- 如果attachments的内容在接下来的渲染操作中将是不再需要的，调用glInvalidateFramebuffer通知GPU，GPU会做相应的优化处理。

【不推荐】

-  每次FBO切换GPU都需要完成上下文切换从而带来开销。通常开发者都注意不会频繁做不必要的FBO切换，然而有一些特殊场景比较容易忽略。 例如，用户先clear FBO A，然后在另一个FBO B上开始一个新的render pass，最后再回到FBO A上开始渲染。这样第一个clear操作将开始一个单独包含clear操作的render pass，最终实际上有3个render pass被执行，且第3个渲染过程将有额外的回读操作。如果将第一个clear操作往后移动到真正相关的FBO渲染之前，将仅生成2个render pass，并且不会出现额外的回读操作。
- 在一个render pass内部调用glFlush和glFinish，有性能开销。
- 使用glReadPixels，CPU会等GPU job执行完成，在这之前都是阻塞状态，破坏CPU和GPU的并行。

1.2 Multisample


对于MSAA的大多数场景，multisample attachment一般只需要保留在GPU内部的片上内存中，无需写回到主内存中，只需要解析为singlesample attachment，然后将singlesample attachment写回到主内存，即multisample attachment的额外带宽永远不会写回到主内存，可以提高效率。


Vulkan


【推荐】

- multisample attachment的loadOp设置为LOAD_OP_NONE或者LOAD_OP_CLEAR。
- multisample attachment的storeOp设置为STORE_OP_NONE。
- 通过在subpass中设置pResolveAttachments来将multisample解析为singlesample。

【不推荐】

- multisample attachment的loadOp设置为LOAD_OP_LOAD。
- multisample attachment的storeOp设置为STORE_OP_STORE。
- 使用vkCmdResolveImage接口将multisample image解析为singlesample image。
- 针对depth attachment进行resolve操作。

OpenGL ES


【推荐】


使用GL_EXT_multisampled_render_to_texture扩展，实现将GPU片上multisampled数据resolve后直接写回到一个非multisampled纹理中。


【不推荐】


先将multisampled数据写回内存中的multisampled纹理中，然后再通过调用glBlitFramebuffer来实现resolve。


2. Texture Prefetch


Texture Prefetch是Maleoon GPU上一种资源预读取的加速技术。通过在shader执行前，对采样操作进行预读取，可以加速shader执行。


【推荐】


shader中texture prefetch需要满足以下条件：

- 采样坐标为输入变量。如果在fragment shader中包含采样操作，其采样坐标是输入变量与立即数或输入变量与uniform线性运算的结果，可以尝试将线性运算放到vertex shader中执行，详见以下【示例】。
-  gvec4 texture(gsampler2D sampler, vec2 P, [float bias]); bias is imm value or some other uniform variable gvec4 textureLod(gsampler2D sampler, vec2 P, float lod); lod is imm value or some other uniform variable gvec4 textureProj(gsampler2D sampler, vec4(or vec3) P, [float bias]); bias = 0.0 (or no bias parameter) gvec4 textureLodOffset(gsampler2D sampler, vec2 P, float lod, ivec2 offset); lod is imm value or some other uniform variable

| gvec4 texture(gsampler2D sampler, vec2 P, [float bias]); bias is imm value or some other uniform variable  |
| --- |
| gvec4 textureLod(gsampler2D sampler, vec2 P, float lod); lod is imm value or some other uniform variable  |
| gvec4 textureProj(gsampler2D sampler, vec4(or vec3) P, [float bias]); bias = 0.0 (or no bias parameter)  |
| gvec4 textureLodOffset(gsampler2D sampler, vec2 P, float lod, ivec2 offset); lod is imm value or some other uniform variable  |

【不推荐】


在fragment shader中的if条件语句中直接使用来自vertex shader的坐标进行prefetch，以免带来不必要的带宽开销。


【示例】


```less
// Vertex shader
#version 300 es
in vec4 in_position;
in vec2 in_coord;
out vec2 texCoord; 
void main() {
    gl_Position = in_position;
    texCoord = in_coord;
}


// Fragment shader
#version 300 es
precision highp int;
precision highp float;
in vec2 texCoord;
uniform vec2 texOffset;
layout(location = 0) out highp vec4 fragColor0;
layout(location = 0) uniform highp sampler2D sampler0;
void main() {
    vec2 coord = texCoord + texOffset;
    fragColor0 = texture(sampler0, coord);
}
```


推荐shader：


```less
// Vertex shader
#version 300 es
in vec4 in_position;
in vec2 in_coord;
out vec2 texCoord; 
uniform vec2 texOffset;
void main() {
    gl_Position = in_position;
    texCoord = in_coord + texOffset;
}


// Fragment shader
#version 300 es
precision highp int;
precision highp float;
in vec2 texCoord;
uniform vec2 texOffset;
layout(location = 0) out highp vec4 fragColor0;
layout(location = 0) uniform highp sampler2D sampler0;
void main() {
    fragColor0 = texture(sampler0, texCoord);
}
```


3. Texture Reuse


Texture Reuse是一种指令的合并方法，因为在Fragment Shader中texture使用频率较高，且消耗的资源较大，所以Maleoon GPU使用了Texture Reuse来优化符合条件的2D Texture。


【推荐】


Texture Reuse可以分为三种模式：TSLOOP、POLOOP和OFFSETLOOP。

-  推荐shader：

```less
highp vec4 t0 = texture(texture_unit0, texcoord, bias);
highp vec4 t1 = texture(texture_unit1, texcoord, bias);
highp vec4 t2 = texture(texture_unit2, texcoord, bias);
highp vec4 t3 = texture(texture_unit3, texcoord, bias);
```

-  offset支持immediate。 推荐shader：

```less
vec4 t0 = texelFetchOffset(texture_unit0, texcoord0, lod, offset0);
vec4 t1 = texelFetchOffset(texture_unit0, texcoord0, lod, offset1);
vec4 t2 = texelFetchOffset(texture_unit0, texcoord0, lod, offset2);
vec4 t3 = texelFetchOffset(texture_unit0, texcoord0, lod, offset3);
```

-  offset支持immediate和uniform。 推荐shader：

```less
vec4 t0 = texture(texture_unit0, texcoord0 + vec2(-0.25, 0), bias0);
vec4 t1 = texture(texture_unit0, texcoord0 + vec2(0.0, 0.25), bias1);
vec4 t2 = texture(texture_unit0, texcoord0 + vec2(0.0, 0.0), bias2);
vec4 t3 = texture(texture_unit0, texcoord0 + vec2(-0.25, 0.25), bias3);
```


对于这三类texture，Maleoon GPU会对其进行reuse，减少传输的次数，降低功耗。


4. 高阶采样


基于Texture Reuse做进一步优化，可以在采样单元直接计算出运算结果，支持POLOOP和OFFSETLOOP。


【推荐】


根据texture reuse的不同使用场景加入了三种高阶采样优化：Convolution、Max和Min。

-  sampler支持lowp/mediump，weight支持mediump，可以为immediate或者uniform 推荐shader：

```less
uniform lowp/mediump sampler2D texture_unit0;
uniform highp float w[4];
vec4 t0 = texelFetchOffset(texture_unit0, texcoord0, lod, offset0);
vec4 t1 = texelFetchOffset(texture_unit0, texcoord0, lod, offset1);
vec4 t2 = texelFetchOffset(texture_unit0, texcoord0, lod, offset2);
vec4 t3 = texelFetchOffset(texture_unit0, texcoord0, lod, offset3);
vec4 conv_enable = w[0] * t0 + w[1] * t1 + w[2] * t2 + w[3] * t3;
```

-  sampler支持lowp/mediump 推荐shader：

```less
uniform lowp/mediump sampler2D texture_unit0;
vec4 t0 = texelFetchOffset(texture_unit0, texcoord0, lod, offset0);
vec4 t1 = texelFetchOffset(texture_unit0, texcoord0, lod, offset1);
vec4 t2 = texelFetchOffset(texture_unit0, texcoord0, lod, offset2);
vec4 t3 = texelFetchOffset(texture_unit0, texcoord0, lod, offset3);
vec4 max_enable = max(max(max(t0, t1), t2), t3);
```

-  sampler支持lowp/mediump 推荐shader：

```less
uniform lowp/mediump sampler2D texture_unit0;
vec4 t0 = texelFetchOffset(texture_unit0, texcoord0, lod, offset0);
vec4 t1 = texelFetchOffset(texture_unit0, texcoord0, lod, offset1);
vec4 t2 = texelFetchOffset(texture_unit0, texcoord0, lod, offset2);
vec4 t3 = texelFetchOffset(texture_unit0, texcoord0, lod, offset3);
vec4 min_enable = min(min(min(t0, t1), t2), t3);
```


对于这三类texture，Maleoon GPU在reuse基础上进一步减少传输的信息，降低功耗。


Blend


Maleoon GPU上，Blend可以通过Fixed Funcion（硬件加速）的方式，或者软件shader的方式实现，具体的影响因素包括采用的blend mode和进行blend的color attachment的format。


【推荐】

-  仅适用于Maleoon 910 GPU。
- App本身不需要使能blend时，如果color attachment为以下format时，建议VkPipelineColorBlendAttachmentState::colorWriteMask配置成0xf，并且fragment shader中对应attachment输出color的四个通道都有赋值。A2R10G10B10_UINT_PACK32A2R10G10B10_SINT_PACK32A2B10G10R10_UINT_PACK32A2B10G10R10_SINT_PACK32A2R10G10B10_UNORM_PACK32A2R10G10B10_SNORM_PACK32A2B10G10R10_UNORM_PACK32A2B10G10R10_SNORM_PACK32R5G6B5_UNORM_PACK16B5G6R5_UNORM_PACK16R5G5B5A1_UNORM_PACK16B5G5R5A1_UNORM_PACK16A1R5G5B5_UNORM_PACK16
- A2R10G10B10_UINT_PACK32
- A2R10G10B10_SINT_PACK32
- A2B10G10R10_UINT_PACK32
- A2B10G10R10_SINT_PACK32
- A2R10G10B10_UNORM_PACK32
- A2R10G10B10_SNORM_PACK32
- A2B10G10R10_UNORM_PACK32
- A2B10G10R10_SNORM_PACK32
- R5G6B5_UNORM_PACK16
- B5G6R5_UNORM_PACK16
- R5G5B5A1_UNORM_PACK16
- B5G5R5A1_UNORM_PACK16
- A1R5G5B5_UNORM_PACK16
- App本身不需要使能blend时，如果color attachment的format是B10G11R11_UFLOAT_PACK32，建议VkPipelineColorBlendAttachmentState::colorWriteMask配置成0x7，并且fragment shader中对应attachment的输出color 3个通道都有赋值。
- A2R10G10B10_UINT_PACK32
- A2R10G10B10_SINT_PACK32
- A2B10G10R10_UINT_PACK32
- A2B10G10R10_SINT_PACK32
- A2R10G10B10_UNORM_PACK32
- A2R10G10B10_SNORM_PACK32
- A2B10G10R10_UNORM_PACK32
- A2B10G10R10_SNORM_PACK32
- R5G6B5_UNORM_PACK16
- B5G6R5_UNORM_PACK16
- R5G5B5A1_UNORM_PACK16
- B5G5R5A1_UNORM_PACK16
- A1R5G5B5_UNORM_PACK16

【不推荐】

-  仅适用于Maleoon 910 GPU。
- App本身需要开启blend时，color attachment为以下format：R32_SFLOATR32G32_SFLOATR32G32B32_SFLOATR32G32B32A32_SFLOATR16_UNORMR16G16_UNORMR16G16B16_SNORMR16G16B16A16_UNORM
- R32_SFLOAT
- R32G32_SFLOAT
- R32G32B32_SFLOAT
- R32G32B32A32_SFLOAT
- R16_UNORM
- R16G16_UNORM
- R16G16B16_SNORM
- R16G16B16A16_UNORM
- 对于不透明的primitive，使能blend。
- R32_SFLOAT
- R32G32_SFLOAT
- R32G32B32_SFLOAT
- R32G32B32A32_SFLOAT
- R16_UNORM
- R16G16_UNORM
- R16G16B16_SNORM
- R16G16B16A16_UNORM
- Shader中大量使用EXT_shader_framebuffer_fetch，会影响GPU的执行效率。建议开发者识别如果是Maleoon GPU时，请关闭framebuffer fetch功能。说明仅适用于OpenGL ES。Maleoon 920及以上的GPU，在单个三角形覆盖全屏区域的场景下，推荐使用EXT_shader_framebuffer_fetch。
- 仅适用于OpenGL ES。
- Maleoon 920及以上的GPU，在单个三角形覆盖全屏区域的场景下，推荐使用EXT_shader_framebuffer_fetch。
- 仅适用于OpenGL ES。
- Maleoon 920及以上的GPU，在单个三角形覆盖全屏区域的场景下，推荐使用EXT_shader_framebuffer_fetch。

Transfer


仅适用于Vulkan。


通过transfer命令，用户可以执行GPU上数据的拷贝。在拷贝时，将数据对齐到合适的alignment以及适当合并拷贝的区域将有助于性能提升。


【推荐】

- 使用vkCmdCopyImageToBuffer/vkCmdCopyImageToBuffer2时，buffer的offset对应的地址建议对齐到optimalBufferCopyOffsetAlignment，单位为Byte。
- 使用vkCmdCopyImageToBuffer/vkCmdCopyImageToBuffer2时，buffer的rowStride建议对齐到optimalBufferCopyRowPitchAlignment，单位为Byte。
- 使用vkCmdCopyImage/vkCmdCopyImage2/vkCmdBlitImage/vkCmdBlitImage2时，如果image的format是FORMAT_D24_UNORM_S8_UINT，并且需要copy/blit depth和stencil两个aspect，那么建议使用一个region，aspectMask指定为VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT。

Compute


1. Compute Shading


1.1 Workgroup size


Workgroup size大小调优是一种简单有效的优化方法。


【推荐】

- 应用中的compute shader建议重新适配Maleoon GPU。
- Workgroup size为32/64，Maleoon GPU运行效率更佳。

1.2 Barrier


不管是数据并行和任务并行有时候不可避免存在相关性，需要等待其他任务或者数据才能进行下一步计算，这时要用到同步机制，OpenCL同步机制称为Barrier。


【推荐】


如果Workgroup size小于32(simd32)，硬件可以保证workgroup中的所有线程在一个warp中。因此开发者可以省略workgroup级别的Barrier，从而提升性能。


1.3 Loop Reduction


Loop Reduction是用OpenCL有效实现数组求和，Maleoon GPU支持Vulkan与OpenCL的subgroup特性。


【推荐】


尽量使用subgroup特性各类extension实现Loop reduction。


2. OpenCL


2.1 API使用


OpenCL作为一个支持多种计算设备的框架，提供了多个标准API以应对不同场景，使用具有很大的灵活性。为了引导OpenCL API使用者在Maleoon GPU上获取更好性能，给出以下OpenCL API的使用推荐。


【推荐】

-  OpenCL的算子在应用开始阶段，只编译一次，然后把binary保存下来，后面在应用中直接使用，减少多次编译引起的耗时。
-  GPU的shader优点是多核多线程操作，clEnqueueNDRangeKernel的work-items数量应该尽可能的大，充分发挥多warps的优势。
-  在调用一个或者多个clEnqueueNDRange()后，再执行clFlush()，最后调用clWaitForEvent()。同步操作需要在任务下发后在CPU侧进行等待，，阻塞CPU任务执行。
- 为了获取最优的性能，使用的workgroup size为32/64或者是32的倍数关系。
- 如果global size的值不能被workgroup size整除，需要补齐到workgroup size，或者使用non-uniform workgroup。
- 如果需要获得最优的OpenCL性能，需要去轮询workgroup size，使得并行度等最优，从而获取最优的性能。

```less
cl_mem clImportMemoryARM(cl_context context,
    cl_mem_flags flags,
    const cl_import_properties_arm *properties,
    void *memory,
    size_t size,
    cl_int *errorcode_ret);
```


2.2 Kernel算子


Kernel算子是OpenCL的核心模块，算子的写法会影响OpenCL程序的性能，体现在主机和设备间的数据传输、算子执行的并行度、内存的访问模式等。为了使OpenCL Kernel算子在Maleoon GPU上获取更好性能，给出以下Kernel算子的用法推荐。


【推荐】

-  通常在精度允许的情况下，可以使用half_or native_等内建函数版本，这样可以获取比数学函数更好的性能。

```less
native_sin();
native_cos();
native_tan();
native_divide();
native_exp();
native_sqrt();
half_sqrt();
```

-  对于精度不高，计算单元负载大的场景，可以使用-cl-fast-relaxed-math。
-  如果在流程中有一系列算子，算子的数据复合度很高，并且算子的逻辑很简单，考虑将小kernel进行适当的合并，但是如果数据没有依赖性的算子就尽可能不要合并。
-  如果一些算子逻辑中有大量的barrier，或者寄存器使用量太大，可以考虑对这类算子进行拆分，降低单个算子使用寄存器的数目，以提升warp的并行度。
-  使用向量化的逻辑提升数据加载的效率和EU的指令数目，可以考虑vload16()等操作。
- 使用正确的数据类型使用尽可能小的数据类型，使得加载的数据量小。如果精度允许，可以使用ushort或者uchar等替换int等类型。
- 使用尽可能小的数据类型，使得加载的数据量小。
- 如果精度允许，可以使用ushort或者uchar等替换int等类型。
-  需要避免在OpenCL算子中使用大量的临时变量，而且使用尽可能集中，减少寄存器的使用，汇编指令中寄存器的使用量超过64时，会大大降低warp的并行度。
-  算子中使用const关键字等，方便编译时优化为常量寄存器。
-  使用hv_clcc离线编译binary的方式替换在线编译的方式，减少编译器编译binary的时间，提升整体性能。
-  通过vload3加载global memory时，内存需要按照vector4的格式进行数据对齐。
-  针对uniform的buffer，使用constant和max_constant_size关键字，把相关参数存入到FAU常量寄存器中，节省多个线程加载数据的执行时间。
- 使用尽可能小的数据类型，使得加载的数据量小。
- 如果精度允许，可以使用ushort或者uchar等替换int等类型。

【不推荐】

-  在算子中对数据进行类型转换，可能会导致数据的对齐格式发生变化，那么在加载数据时需要额外的操作，会拉低执行效率。
-  对于global内存，不要在算法内部进行数据的转换。例如，输入的全局内存是int*或者short *，不要让它转换为char*再作一个偏移，然后又转换为int*或者short*的类型，这样只读buffer优化就无法使用，无法将只读buffer带宽大的优势体现出来。
-  Warp中的多个线程尽可能走同一跳转分支，如果算法中包含的分支数太多，例如switch，if，while等操作，使得warp中各个线程会走不同的分支逻辑。这样会导致ALU把所有的分支逻辑都走一遍，降低算子的性能。
-  在算子中使用大量global memory的atomic操作，会拉低warp的并行度，建议使用shared memory的atomic。

Window System Integration


仅适用于Vulkan。


通过vkCreateSwapchainKHR创建交换链，用于呈现绘制结果。用户可以通过VkSwapchainCreateInfoKHR-> minImageCount自定义交换链中可供使用的image的数量。App会通过vkAcquireNextImageKHR从交换链中申请出一个可用的image资源，执行绘制任务，然后通过vkQueuePresentKHR将完成绘制的image送回交换链并呈现绘制结果。


用户可以定义一个非常大的minImageCount来保证每次都能申请到可用的image资源，但若GPU能在远低于Vsync的时间内完成绘制，则该行为可能会导致画面存在撕裂感，并显著增加内存开销。若绘制任务负载很重，GPU无法在一个Vsync周期内完成绘制，则一个很小的minImageCount（例如2）会导致帧率的显著降低。


【推荐】

- 低负载模式下，将minImageCount配置为2。
- 重负载模式下，将minImageCount配置为3或4。
- 尽量把调用image的时机，延迟到本帧最后一个renderpass（该pass一般即是送显的renderpass）之前执行。
- 请确保交换链的preTransform与vkGetPhysicalDeviceSurfaceCapabilityKHR返回的currentTransform值匹配。
- 如果vkAcquireNextImageKHR或vkQueuePresentKHR返回VK_SUBOPTIMAL_KHR或VK_ERROR_OUT_OF_DATE_KHR，建议此时根据surface属性变化重建交换链。

Resource


1. Texture


1.1 HEBC


HEBC是Maleoon GPU独有的硬件压缩算法，纹理的数据以无损的压缩格式存储，降低了数据传输的功耗和带宽，需要参考以下条件来使能HEBC。


Vulkan


【推荐】

- Image tiling必须为optimal。
- Image type必须为IMAGE_TYPE_2D。
- Image usage只能包含以下取值：IMAGE_USAGE_COLOR_ATTACHMENT_BITIMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BITIMAGE_USAGE_SAMPLED_BITIMAGE_USAGE_TRANSFER_SRC_BITIMAGE_USAGE_INPUT_ATTACHMENT_BITIMAGE_USAGE_TRANSFER_DST_BIT
- IMAGE_USAGE_COLOR_ATTACHMENT_BIT
- IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
- IMAGE_USAGE_SAMPLED_BIT
- IMAGE_USAGE_TRANSFER_SRC_BIT
- IMAGE_USAGE_INPUT_ATTACHMENT_BIT
- IMAGE_USAGE_TRANSFER_DST_BIT
-  序号 可支持的format 1 FORMAT_A4B4G4R4_UNORM=2 2 FORMAT_A4R4G4B4_UNORM=3 3 FORMAT_B5G6R5_UNORM=4 4 FORMAT_R5G6B5_UNORM=5 5 FORMAT_A1B5G5R5_UNORM=6 6 FORMAT_A1R5G5B5_UNORM=7 7 FORMAT_B5G5R5A1_UNORM=8 8 FORMAT_R8_UNORM=9 9 FORMAT_R8_UINT=13 10 FORMAT_R8_SINT=14 11 FORMAT_R8G8_UNORM=16 12 FORMAT_R8G8_UINT=20 13 FORMAT_R8G8_SINT=21 14 FORMAT_R8G8B8_UNORM=23 15 FORMAT_R8G8B8_UINT=27 16 FORMAT_R8G8B8_SINT=28 17 FORMAT_R8G8B8_SRGB=29 18 FORMAT_B8G8R8_UNORM=30 19 FORMAT_B8G8R8_UINT=34 20 FORMAT_B8G8R8_SINT=35 21 FORMAT_B8G8R8_SRGB=36 22 FORMAT_R8G8B8A8_UNORM=37 23 FORMAT_R8G8B8A8_UINT=41 24 FORMAT_R8G8B8A8_SINT=42 25 FORMAT_R8G8B8A8_SRGB=43 26 FORMAT_B8G8R8A8_UNORM=44 27 FORMAT_B8G8R8A8_UINT=48 28 FORMAT_B8G8R8A8_SINT=49 29 FORMAT_B8G8R8A8_SRGB=50 30 FORMAT_B10G10R10A2_UNORM=58 31 FORMAT_B10G10R10A2_UINT=62 32 FORMAT_R10G10B10A2_UNORM=64 33 FORMAT_R10G10B10A2_UINT=68 34 FORMAT_R16_UINT=74 35 FORMAT_R16_SINT=75 36 FORMAT_R16_SFLOAT=76 37 FORMAT_R16G16_UINT=81 38 FORMAT_R16G16_SINT=82 39 FORMAT_R16G16_SFLOAT=83 40 FORMAT_R16G16B16_UINT=88 41 FORMAT_R16G16B16_SINT=89 42 FORMAT_R16G16B16_SFLOAT=90 43 FORMAT_R16G16B16A16_UINT=95 44 FORMAT_R16G16B16A16_SINT=96 45 FORMAT_R16G16B16A16_SFLOAT=97 46 FORMAT_R32_UINT=98 47 FORMAT_R32_SINT=99 48 FORMAT_R32_SFLOAT=100 49 FORMAT_R11G11B10_UFLOAT=122 50 FORMAT_D16_UNORM=124 51 FORMAT_D24_X8_UNORM=125 52 FORMAT_D32_SFLOAT=126 53 FORMAT_D24_UNORM_S8_UINT=129 54 FORMAT_D32_SFLOAT_S8_UINT=130
- IMAGE_USAGE_COLOR_ATTACHMENT_BIT
- IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
- IMAGE_USAGE_SAMPLED_BIT
- IMAGE_USAGE_TRANSFER_SRC_BIT
- IMAGE_USAGE_INPUT_ATTACHMENT_BIT
- IMAGE_USAGE_TRANSFER_DST_BIT

| 序号  | 可支持的format  |
| --- | --- |
| 1  | FORMAT_A4B4G4R4_UNORM=2  |
| 2  | FORMAT_A4R4G4B4_UNORM=3  |
| 3  | FORMAT_B5G6R5_UNORM=4  |
| 4  | FORMAT_R5G6B5_UNORM=5  |
| 5  | FORMAT_A1B5G5R5_UNORM=6  |
| 6  | FORMAT_A1R5G5B5_UNORM=7  |
| 7  | FORMAT_B5G5R5A1_UNORM=8  |
| 8  | FORMAT_R8_UNORM=9  |
| 9  | FORMAT_R8_UINT=13  |
| 10  | FORMAT_R8_SINT=14  |
| 11  | FORMAT_R8G8_UNORM=16  |
| 12  | FORMAT_R8G8_UINT=20  |
| 13  | FORMAT_R8G8_SINT=21  |
| 14  | FORMAT_R8G8B8_UNORM=23  |
| 15  | FORMAT_R8G8B8_UINT=27  |
| 16  | FORMAT_R8G8B8_SINT=28  |
| 17  | FORMAT_R8G8B8_SRGB=29  |
| 18  | FORMAT_B8G8R8_UNORM=30  |
| 19  | FORMAT_B8G8R8_UINT=34  |
| 20  | FORMAT_B8G8R8_SINT=35  |
| 21  | FORMAT_B8G8R8_SRGB=36  |
| 22  | FORMAT_R8G8B8A8_UNORM=37  |
| 23  | FORMAT_R8G8B8A8_UINT=41  |
| 24  | FORMAT_R8G8B8A8_SINT=42  |
| 25  | FORMAT_R8G8B8A8_SRGB=43  |
| 26  | FORMAT_B8G8R8A8_UNORM=44  |
| 27  | FORMAT_B8G8R8A8_UINT=48  |
| 28  | FORMAT_B8G8R8A8_SINT=49  |
| 29  | FORMAT_B8G8R8A8_SRGB=50  |
| 30  | FORMAT_B10G10R10A2_UNORM=58  |
| 31  | FORMAT_B10G10R10A2_UINT=62  |
| 32  | FORMAT_R10G10B10A2_UNORM=64  |
| 33  | FORMAT_R10G10B10A2_UINT=68  |
| 34  | FORMAT_R16_UINT=74  |
| 35  | FORMAT_R16_SINT=75  |
| 36  | FORMAT_R16_SFLOAT=76  |
| 37  | FORMAT_R16G16_UINT=81  |
| 38  | FORMAT_R16G16_SINT=82  |
| 39  | FORMAT_R16G16_SFLOAT=83  |
| 40  | FORMAT_R16G16B16_UINT=88  |
| 41  | FORMAT_R16G16B16_SINT=89  |
| 42  | FORMAT_R16G16B16_SFLOAT=90  |
| 43  | FORMAT_R16G16B16A16_UINT=95  |
| 44  | FORMAT_R16G16B16A16_SINT=96  |
| 45  | FORMAT_R16G16B16A16_SFLOAT=97  |
| 46  | FORMAT_R32_UINT=98  |
| 47  | FORMAT_R32_SINT=99  |
| 48  | FORMAT_R32_SFLOAT=100  |
| 49  | FORMAT_R11G11B10_UFLOAT=122  |
| 50  | FORMAT_D16_UNORM=124  |
| 51  | FORMAT_D24_X8_UNORM=125  |
| 52  | FORMAT_D32_SFLOAT=126  |
| 53  | FORMAT_D24_UNORM_S8_UINT=129  |
| 54  | FORMAT_D32_SFLOAT_S8_UINT=130  |

OpenGL ES


【推荐】

- 纹理尺寸大于32，小于等于8192。
-  序号 可支持的format 1 GL_RGB8_OES 2 GL_RGBA8_OES 3 GL_BGRA8_EXT 4 GL_RGBA4 5 GL_RGB565 6 GL_RGB5_A1 7 GL_DEPTH_COMPONENT16 8 GL_DEPTH_COMPONENT24_OES 9 GL_DEPTH24_STENCIL8_OES 10 GL_DEPTH_COMPONENT32F 11 GL_DEPTH32F_STENCIL8 12 GL_RGB10_EXT 13 GL_RGB10_A2_EXT 14 GL_R8_EXT 15 GL_RG8_EXT 16 GL_R16F 17 GL_RG16F 18 GL_RGBA16F 19 GL_R11F_G11F_B10F 20 GL_SRGB8_ALPHA8 21 GL_RGB10_A2UI 22 GL_RGBA16UI 23 GL_RGBA8UI 24 GL_RGBA16IGL_RGBA8I

| 序号  | 可支持的format  |
| --- | --- |
| 1  | GL_RGB8_OES  |
| 2  | GL_RGBA8_OES  |
| 3  | GL_BGRA8_EXT  |
| 4  | GL_RGBA4  |
| 5  | GL_RGB565  |
| 6  | GL_RGB5_A1  |
| 7  | GL_DEPTH_COMPONENT16  |
| 8  | GL_DEPTH_COMPONENT24_OES  |
| 9  | GL_DEPTH24_STENCIL8_OES  |
| 10  | GL_DEPTH_COMPONENT32F  |
| 11  | GL_DEPTH32F_STENCIL8  |
| 12  | GL_RGB10_EXT  |
| 13  | GL_RGB10_A2_EXT  |
| 14  | GL_R8_EXT  |
| 15  | GL_RG8_EXT  |
| 16  | GL_R16F  |
| 17  | GL_RG16F  |
| 18  | GL_RGBA16F  |
| 19  | GL_R11F_G11F_B10F  |
| 20  | GL_SRGB8_ALPHA8  |
| 21  | GL_RGB10_A2UI  |
| 22  | GL_RGBA16UI  |
| 23  | GL_RGBA8UI  |
| 24  | GL_RGBA16IGL_RGBA8I  |

【不推荐】


通过glBindImageTexture绑定到image unit的已经被压缩的纹理，在被imageLoad/imageStore访问时，驱动侧会触发解压缩流程。


解压缩后的纹理在之后的渲染过程中不会被重新压缩，都是以非压缩的状态存在。


1.2 Filtering


各向异性滤波（Anisotropic Filtering）被用来避免mip-map的过度模糊效应，然而各向异性滤波和三线性滤波会降低纹理采样的性能。Maleoon GPU上，YUV纹理暂不支持各向异性滤波。


【推荐】


为了在Maleoon GPU上获得更好的性能，我们建议：

- 仅在必要的情况下使用AF和三线性滤波。使用AF时，检查性能尽量达成性能和效果的平衡。
- 尽量避免将各向异性滤波和三线性滤波的结果应用于阶跃函数或控制代码端（if-else代码结构等）。
- 检查图像质量是否需要各向异性滤波或三线性滤波。

1.3 三通道Texture Buffer


仅适用于OpenGL ES。


使用GLSL texelFetch指令采样三通道的Texture Buffer，对性能有一定的影响，开发者尽量避免。


【不推荐】


使用GLSL texelFetch指令采样三通道的Texture Buffer。


1.4 Feedback Loops


一张纹理同时被采样和写出，spec定义该同读同写场景为feedback loops，feedback loops的结果未定义。


【不推荐】


使用feedback loops。


2. Buffer


仅适用于OpenGL ES。


如果glMapBufferRange包含MAP_UNSYNCHRONIZED_BIT 标记位，GPU驱动无需关注buffer内存状态，直接将该buffer地址返回给用户。即使buffer内存正在被使用，也不会报错，后续该buffer内存读写操作所导致的结果都是未定义的。这个标志允许开发者在不等待之前操作完成的情况下映射buffer，可能会提高性能，但同时也带来了数据错误的风险。


【推荐】


如果可以保证buffer没有任何的读写依赖，调用glMapBufferRange时包含MAP_UNSYNCHRONIZED_BIT标记位，有助于提升性能。


【不推荐】


不能保证buffer没有任何的读写依赖，调用glMapBufferRange时不要包含MAP_UNSYNCHRONIZED_BIT标记位，否则会有数据错误的风险。


Synchronization


仅适用于Vulkan。


Vulkan提供了多种不同的同步原语供App使用，用户可以用这些同步原语来保证GPU任务的执行时序，从而保证执行结果符合预期。其中Barrier、Event、Semaphore等同步原语都可以作为GPU任务间同步的工具，用户可以下发srcStageMask和dstStageMask来指定被等待的pipelineStages和等待的pipelineStages。


由于一般游戏应用中，graphics jobs是用来绘制游戏画面的，负载比较大且直接影响帧率。所以尽量不要让其他类型的Jobs（如Transfer、Compute）阻塞graphics jobs。如果有这类需要，应该尽量考虑消除或减少阻塞的时间。


【推荐】

- 尽量减少不必要的同步操作，同步操作中的srcStageMask应当包含尽量少的pipelineStages。
- graphics等待的transfer/compute jobs尽早提交、尽早解除对graphics的阻塞，且vkCmdPipelineBarrier()应当尽早下发。
- 等待transfer/compute jobs的graphics jobs尽量晚执行，避免graphics jobs被阻塞而导致GPU绘制性能下降。
- 如果compute/transfer jobs与某个graphics存在依赖，尽量使之与其他graphics jobs并发执行，从而提升graphics这类重载job的并发度。

例如以下序列，compute执行时graphics是闲置的，导致graphics并发度低。


```less
vkCmdBeginRenderPass(renderpass1)；
vkCmdDraw()；
vkCmdEndRenderPass()；
vkCmdPipelineBarrier(src: rendering, dst:compute)；
vkCmdDispatch()；
vkCmdPipelineBarrier(src: compute, dst:rendering)；
vkCmdBeginRenderPass(renderpass2)； 
vkCmdDraw()；
vkCmdEndRenderPass()；
```


Job的执行顺序如下图所示，可见graphics jobs之间存在较大空隙，compute和graphics jobs为串行执行。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152827.22425985006844454224427285360178:50001231000000:2800:C58ADB0E8C5E61077D62009051B60D285B8B1111BCEFE3F50949CD1094850BDB.jpg)

为了避免以上情况出现，compute执行时，尽量让可以并行的graphics任务与compute同时执行。API序列如下所示：


```less
vkCmdBeginRenderPass(renderpass1);
vkCmdDraw();
vkCmdEndRenderPass();
vkCmdPipelineBarrier(src:rendering, dst:compute);
vkCmdDispatch();
vkCmdBeginRenderPass(renderpass3);
vkCmdDraw();
vkCmdEndRenderPass();
vkCmdPipelineBarrier(src:compute, dst:rendering);
vkCmdBeginRenderPass(renderpass2);
vkCmdDraw();
vkCmdEndRenderPass();
```


Job的执行顺序如下图所示，此时compute和graphics jobs可以并发执行。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152828.59225568167751580410100742964026:50001231000000:2800:796140B0F5F86C78EE376CD8192526D79226E2B868F4FAE95C4E87E1D367ACB8.jpg)

【不推荐】

- DstStageMask中包含VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT、VK_PIPELINE_STAGE_VERTEX_*、VK_PIPELINE_STAGE_TESSELLATION_*或者VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT这些Bit。
- SrcStageMask中包含VK_PIPELINE_STAGE_VERTEX_* Bit。如果必须使用它们，需要尽早下发vkCmdPipelineBarrier()。

影响


不恰当的同步操作可能会使Maleoon GPU不同类型的Jobs并行度变差，从而导致GPU性能受损。


Subpass Merge


仅适用于Vulkan。


Vulkan支持多subpass渲染，该功能使得GPU能够从一个subpass获取color attachment和depthstencil attachment，无需写回到主内存，直接在片上将它们用作后续subpass中的input attachment，这个优化叫做subpass merge。


在一些应用场景下（例如延迟着色场景），通过多subpass配置，成功merge-subpass，则会大大提高效率。


Maleoon GPU硬件支持在满足以下条件时，允许后面的subpass按照合适的tiler粒度和执行顺序直接从tile buffer上读取前面的subpass的输出结果来使用，从而避免出现“写出到DDR”和“从DDR读回”这样一个来回高耗带宽的数据存取过程。


【推荐】


当merge-subpass满足以下条件，能够实现merge-subpass方案。

- Subpass总数大于1。
- 所有的attachment必须是singlesample。
- 第一个subpass最多有8个color attachment，其他subpass最多4个color attachment，所有subpass的color attachment总数不能超过8个。
- 所有subpass的depthstencil attachment如果存在，则必须是同一个。
- depthstencil attachment只能有一次写操作。
- 必须存在前面subpass的输出被后面subpass作为input attachment的情况。
-  仅适用于Maleoon 910 GPU。
- 非multiview和multilayer场景。
- SrcAccessMask和dstAccessMask只包含以下BIT:INPUT_ATTACHMENT_READ_BITCOLOR_ATTACHMENT_READ_BITCOLOR_ATTACHMENT_WRITE_BITDEPTH_STENCIL_ATTACHMENT_READ_BITDEPTH_STENCIL_ATTACHMENT_WRITE_BIT
- INPUT_ATTACHMENT_READ_BIT
- COLOR_ATTACHMENT_READ_BIT
- COLOR_ATTACHMENT_WRITE_BIT
- DEPTH_STENCIL_ATTACHMENT_READ_BIT
- DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
- INPUT_ATTACHMENT_READ_BIT
- COLOR_ATTACHMENT_READ_BIT
- COLOR_ATTACHMENT_WRITE_BIT
- DEPTH_STENCIL_ATTACHMENT_READ_BIT
- DEPTH_STENCIL_ATTACHMENT_WRITE_BIT

【不推荐】

- Input attachment的storeOp配置为STORE_OP_STORE。
- 在一个subpass内针对同一个attachment进行读写操作。

Shader编码优化


不要使用较复杂shader


相比于CPU优化，在做GPU优化时，需要特别关注shader并发执行的情况，发挥GPU并行计算的能力，这个比做好单个shader的优化更加重要。这种并发分两个层面，一方面是不同的shader之间，如果无依赖，要尽量并发的执行，另一方面是同一个shader，不同的线程（vertex/pixel…）要尽可能的并发执行。


Shader执行所需的资源，在GPC/EU等层级上可能会有独占的情况，即如果一个shader申请了过多的资源，那其它shader可能无法并发执行，例如如果一个shader使用了过多GPR资源，那么在一个EU里并发一个warp任务，导致GPU算力发挥不了。移动端GPU资源更加紧凑，需要更加注意。


【推荐】


建议不要使用超过800行的shader，如果确实需要如此复杂的计算量，可以尝试拆分为多个shader来执行。虽然相同计算量下拆分draw会有额外开销，但是可以提升EU并发度，避免GPU卡在个别的几个shader上，阻塞了其它shader的执行。总体而言性能更佳。


内存访问向量化


Maleoon GPU在内存访问操作上使用向量化是更加高效的行为，向量化的内存访问可以减少访问cycle和带宽。


【推荐】


推荐shader写法：


```less
struct FCocTileSample {
    vec4 Fgd;
};
void main() {
    uint u12 = 0u;
    FCocTileSample t10[3];
    while (u12 < 3u) {
        t10[int(u12)].Fgd = a;
        u12++;
    }
}
```


【不推荐】


原始shader写法：


```less
struct FCocTileSample {
    float FgdMinCoc;
    float FgdMaxCoc;
    float BgdMinCoc;
    float BgdMaxCoc;
};
void main() {
    uint u12 = 0u;
    FCocTileSample t10[3];
    while (u12 < 3u) {
        t10[int(u12)].FgdMinCoc = a;
        t10[int(u12)].FgdMaxCoc = b;
        t10[int(u12)].BgdMinCoc = c;
        t10[int(u12)].BgdMaxCoc = d;
        u12++;
    }
}
```


尽量使用低精度


Maleoon GPU同时支持高精度和低精度，并且在软硬件上对低精度运算进行了深度优化。


【推荐】

- shader内部使用低精度可以加快shader的执行速度，在input/output上使用低精度可以有效减少带宽。因此推荐开发者在不影响视觉效果的情况下，尽可能在fragment shader和compute shader中使用低精度。
- 在OpenGL ES和Vulkan GLSL上，可以通过将全局变量或者临时变量的精度修改为mediump使用低精度运算，在SPIR-V上，可以通过对变量或者result使用relaxed-precision decoration使用低精度运算。需要注意的是，Maleoon GPU上lowp会按照mediump实现。

推荐shader写法：


```less
precision highp float;
varying mediump vec4 in0;
mediump vec2 var0 = in0.xw;
mediump vec2 var1 = in0.zy;
mediump vec2 var2 = (var0 + var1) / 2.0f;
```


【不推荐】


以下场景不建议使用低精度运算：

- Position计算
- Coordinate计算，尤其是采样坐标

原始shader写法：


```less
precision highp float;
varying vec4 in0;
vec2 var0 = in0.xw;
vec2 var1 = in0.zy;
vec2 var2 = (var0 + var1) / 2.0f;
```


生成优化的SPIR-V


如果使用HLSL/GLSL开发vulkan应用，一般需要通过工具转换生成SPIR-V格式的shader，但是转换过程中可能与原本HLSL/GLSL有差异。


【推荐】


建议使用glslang 11.0及以上版本，并确认生成的SPIR-V包含了足够的优化信息，例如relaxed-precision描述等。


Uniforms


Maleoon GPU可以将部分uniform data转换成shader core的register，从而减少频繁的uniform data load。


【推荐】

- 一个shader内，使用不超过1024 bytes uniform data。
- 避免非必要的uniform dynamic indexing写法。
- 不相关的dynamic data请不要merge到uniform vector或者uniform matrix中。

【不推荐】


以下uniform data无法转换成register：

- Uniform data过多，导致shader core内部constant register用尽。
- 通过dynamic indexing的uniform data，且编译器无法通过loop unroll/动态索引寄存器等技术优化。

Uniform Expressions


Maleoon GPU通过协处理器，可以在draw call执行前，在协处理器上完成一部分标量运算，主要包括了uniform和立即数相关表达式的计算，计算结果提供给整个draw call使用。因此，在Maleoon GPU上uniform expressions不会占用GPU运行的时间。


【推荐】


通过调整计算顺序，合并uniform和立即数的计算过程，减少uniform计算和普通计算频繁交替。


Uniform Relative Indexing


Maleoon GPU对于Uniform relative indexing的一般做法为将动态索引的完整uniform buffer放在mem中，再通过运行时计算出来的index从mem中load出对应的uniform value。


【推荐】

- 从mem中load数据开销较大，因此避免非必要的uniform dynamic indexing写法。
- 如果有必要，可以通过向量化操作拉长整个变量的生命周期，减少load mem的次数。

【示例】


原始shader写法：


```less
if (_61.x) {
    vec3 _513 = (-_37.xyz) * _462._m0[_440 / 8]._m0.www + _462._m0[_440 / 8]._m0.xyz;
    _179.x = _516 + _462._m0[_440 / 8]._m3.w;
    _516 *= _462._m0[_440 / 8]._m2.x;
    _516 *= _462._m0[_440 / 8]._m3.w;
    _559 = dot(_462._m0[_440 / 8]._m3.xyz, _71.xyz);
    _559 = (_559 * _462._m0[_440 / 8]._m2.z) + _462._m0[_440 / 8]._m2.w;
}
```


推荐shader写法：


```less
if (_61.x) {
    vec4 ldubo_mo = _462._m0[_440 / 8]._m0.xyzw;
    vec4 ldubo_m2 = _462._m0[_440 / 8]._m2.xyzw;
    vec4 ldubo_m3 = _462._m0[_440 / 8]._m3.xyzw;
    vec3 _513 = (-_37.xyz) * ldubo_mo.www + ldubo_mo.xyz;
    _179.x = _516 + ldubo_m3.w;
    _516 *= ldubo_m2.x;
    _516 *= ldubo_m3.w;
    _559 = dot(ldubo_m3.xyz, _71.xyz);
    _559 = (_559 * ldubo_m2.z) + ldubo_m2.w;
}
```


Branch


分支（branching）在GPU上代价较大，原因如下：

- 分支使得一个warp内的线程会出现分叉，同一时刻可能只有一部分线程是active的，线程利用率降低。Maleoon GPU是大核结构（SIMD32/SIMD64），分支越多性能，利用率会越低。
- GPU硬件上需要额外的硬件单元记录branch和branch合并时的信息，这些资源是有限的，过多的branch可能导致warp并发度降低。
- 分支给编译器优化带来更多可变因子，而图形渲染大部分是在线编译，需要平衡优化效果和编译时间。
- uniform branch相比普通的branch，可以避免分叉的产生，但还是会有其它的影响。开发过程中还是要尽可能避免使用branch。

【推荐】

- 尽量减少复杂的分支结构，减少嵌套深度， 嵌套深度尽量控制在8层以内。
- 可以使用min()、max()、clamp()、mix()，三目运算符等方式减少简单的分支跳转。
- 如果冗余计算的代价不大，可以去掉分支结构保留冗余计算。
- 使用宏常量代替uniform变量。
- Vulkan使用push constant代替uniform变量。

【不推荐】


有些shader为了兼容性，会把memory的relative indexing改成if-else或者switch-case，这种太多分支操作写法对GPU不友好，导致性能很差。Maleoon GPU是支持所有memory类型的relative indexing，并且有些场景编译器还能优化，所以请保留relative indexing。


【示例】


原始shader写法：


```less
vec4 UniformArrayDynamicIndex(int i) {
    if (i <= 0) return UArray[0]; 
    else if (i == 1) return UArray[1];
    else if (i == 2) return UArray[2]; 
    else if (i == 3) return UArray[3];
    else if (i == 4) return UArray[4]; 
    else if (i == 5) return UArray[5];
    else if (i == 6) return UArray[6]; 
    else if (i == 7) return UArray[7];
    else if (i == 8) return UArray[8]; 
    else if (i == 9) return UArray[9];
    else if (i == 10) return UArray[10]; 
    else if (i == 11) return UArray[11];
    else if (i == 12) return UArray[12]; 
    else if (i == 13) return UArray[13];
    else if (i == 14) return UArray[14]; 
    else if (i == 15) return UArray[15];
    else if (i == 16) return UArray[16]; 
    else if (i == 17) return UArray[17];
    else if (i == 18) return UArray[18]; 
    else if (i == 19) return UArray[19];
    else if (i == 20) return UArray[20]; 
    else if (i == 21) return UArray[21];
    else if (i == 22) return UArray[22]; 
    else if (i == 23) return UArray[23];
    else if (i == 24) return UArray[24]; 
    else if (i == 25) return UArray[25];
    else if (i == 26) return UArray[26]; 
    else if (i == 27) return UArray[27];
    else if (i == 28) return UArray[28]; 
    else if (i == 29) return UArray[29];
    else if (i == 30) return UArray[30]; 
    else if (i == 31) return UArray[31];
    return UArray[0];
}
```


推荐shader写法：


```less
vec4 UniformArrayDynamicIndex(int i) {
    if (i <0 || i > 31)
        i = 0;
    return UArray[i];
}
```


Loop


Loop运行过程中，会产生较多的分叉，且会有大量的分支指令，性能在GPU上较差。


【推荐】


如果一定要使用loop，建议使用如下的for循环：

- for循环的循环次数优先使用常量，uniform变量次之。
- 简化for循环的条件，使得for循环的起始值、step值都是常量或者常量表达式。

推荐shader：


```less
for (i = 0; i < 2 ; i++) {
}
```


【不推荐】


原始shader：


```less
i = 0;
for (;;) {
    if (((i * 2 ) + 1 >=4)) {
        break;
    }
    i++;
}
```


URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-location-service
爬取时间: 2025-05-08 03:37:39
来源: Huawei Developer


概述


在实际应用开发过程中，经常需要用到移动终端设备的位置信息，比如查看所在城市天气、出行打车、旅行导航以及观察运动轨迹等。关于位置定位，位置服务提供了两种定位方式，分别为GNSS定位和网络定位，如下表所示：


| 定位方式  | 说明  | 优点  |
| --- | --- | --- |
| GNSS定位  | 基于全球导航卫星系统，包含GPS、GLONASS、北斗、Galileo等，通过导航卫星、设备芯片提供的定位算法，来确定设备准确位置。  | 定位精准  |
| 网络定位  | 通过网络进行定位，包括WLAN、蓝牙定位、基站定位。  | 定位速度快  |

定位方式


说明


优点


GNSS定位


基于全球导航卫星系统，包含GPS、GLONASS、北斗、Galileo等，通过导航卫星、设备芯片提供的定位算法，来确定设备准确位置。


定位精准


网络定位


通过网络进行定位，包括WLAN、蓝牙定位、基站定位。


定位速度快


利用系统的位置定位能力，可以在多种开发场景中获得实时准确的位置信息。本文将介绍如下四种常见的定位场景，并给出其具体实现方案，帮助开发者更好地掌握位置定位的基本原理和开发流程。

- 当前位置定位：获取设备的当前位置信息。开发者可以根据实际需求将其应用于多种业务场景，如外卖定位、打车定位等。
- 实时位置定位：持续获取设备的实时位置信息。开发者可以将此能力应用于需要实时定位的场景，如步行导航，驾车出行等。
- 应用后台定位：将应用切换到后台仍然可以持续获取位置信息。该能力可以用于实现后台应用实时记录运动轨迹等业务场景。
- 历史定位获取：获取系统缓存的最新位置，即最近一次的历史定位信息。该能力可以用于在设备网络信号较弱或对系统功耗比较敏感的场景下获取位置信息。

当前位置定位


开发者可以根据实际业务诉求，设置相应的定位策略获取设备的当前位置信息，不同定位策略对应表1 定位方式介绍中不同的定位方式。


实现原理


位置服务提供getCurrentLocation()接口来获取当前位置信息，该接口需要用户设置关键参数——定位请求信息。定位请求信息包含定位方式优先级、单次定位超时时间等，分为CurrentLocationRequest和SingleLocationRequest两种类型。两种类型对应的定位优先级分别为LocationRequestPriority和LocatingPriority。


开发步骤


```less
let request: geoLocationManager.SingleLocationRequest = {
  locatingPriority: geoLocationManager.LocatingPriority.PRIORITY_LOCATING_SPEED,
  locatingTimeoutMs: 10000
};
```


```less
geoLocationManager.getCurrentLocation(request).then((location: geoLocationManager.Location) => {
  // Receive the reported location through the promise.
  // ...
}).catch((err: BusinessError) => {
  hilog.error(0x0000, TAG, `getCurrentLocationPosition failed, code: ${err.code}, message: ${err.message}`);
  // ...
});
```


```less
geoLocationManager.getAddressesFromLocation(reverseGeocodeRequest, async (err, data) => {
  if (data) {
    this.address = data[0]?.placeName || '';
    // ...
  } else {
    hilog.error(0x0000, TAG, `getAddressesFromLocation failed, code: ${err.code}, message: ${err.message}`);
    // ...
  }
});
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152834.61071321176699437464121543002772:50001231000000:2800:D45CDF526D9A200D859A00E109B218C7548D8D8A825F3A7AA99951314BB0A01F.png)

实时位置定位


开发者可以根据实际用户活动场景或功耗场景，设置相应的定位策略持续获取设备的位置信息，不同定位策略对应表1 定位方式介绍中不同的定位方式。


实现原理


位置服务通过on('locationChange')接口订阅位置变化情况，实现持续获取设备位置信息的场景诉求。该订阅服务需要申请定位请求信息LocationRequest或者ContinuousLocationRequest，并在请求信息中设置定位场景类型和位置信息上报时间间隔。


开发步骤


```less
let request: geoLocationManager.ContinuousLocationRequest = {
  locationScenario: geoLocationManager.UserActivityScenario.NAVIGATION,
  interval: 1
};
```


```less
geoLocationManager.on('locationChange', request, this.locationChange);
```


```less
geoLocationManager.getAddressesFromLocation(reverseGeocodeRequest, async (err, data) => {
  if (data) {
    this.address = data[0]?.placeName || '';
    // ...
  } else {
    hilog.error(0x0000, TAG, `getAddressesFromLocation failed, code: ${err.code}, message: ${err.message}`);
    // ...
  }
});
```


```less
try {
  // The callback function must be the same as that of the on interface.
  geoLocationManager.off('locationChange', this.locationChange);
} catch (err) {
  hilog.error(0x0000, TAG, `offLocationChange failed, code: ${err.code}, message: ${err.message}`);
}
```

1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152834.68699267702833492582725087213136:50001231000000:2800:CA9A2872E0A1144D754ABB4706AC3EC79568A678DFC582ED8FED6433F0D18974.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152834.68078737764881212168808177101976:50001231000000:2800:71792340C5B1C966DBE64EB4DDDF4E0F6D4A857DD2851B60E8A72729B884D144.png)

应用后台定位


当用户将应用切至后台且依然需要获取设备的位置信息时，可以使用该方式进行后台定位。


实现原理


应用后台定位需要申请后台定位权限ohos.permission.LOCATION_IN_BACKGROUND和长时任务权限ohos.permission.KEEP_BACKGROUND_RUNNING。申请了相关权限后，开启任务模式为定位导航的长时任务，并在其回调接口中通过on('locationChange')订阅位置变化情况，在应用后台持续获取当前位置信息。


开发步骤

1.  申请长时任务权限 设置长时任务模式为定位导航类型

```less
{
  "name": "ohos.permission.KEEP_BACKGROUND_RUNNING",
  "reason": "$string:running_background",
  "usedScene": {
    "abilities": [
      "EntryAbility"
    ],
    "when": "always"
  }
},
```

2.  开启长时任务 订阅位置变化情况

```less
startContinuousTask(): void {
  let context = getContext(this) as common.UIAbilityContext;
  if (!context) {
    return;
  }
  let wantAgentInfo: wantAgent.WantAgentInfo = {
    wants: [
      {
        bundleName: context.abilityInfo.bundleName,
        abilityName: context.abilityInfo.name
      }
    ],
    operationType: wantAgent.OperationType.START_ABILITY,
    requestCode: 1,
    wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]
  };
  // Start a background task whose BackgroundMode is LOCATION.
  wantAgent.getWantAgent(wantAgentInfo).then((wantAgentObj) => {
    backgroundTaskManager.startBackgroundRunning(context,
      backgroundTaskManager.BackgroundMode.LOCATION, wantAgentObj).then(() => {
      this.onLocationChange();
      hilog.info(0x0000, TAG, 'startBackgroundRunning succeeded');
    }).catch((err: BusinessError) => {
      hilog.error(0x0000, TAG, `startBackgroundRunning failed, cause:  ${JSON.stringify(err)}`);
    });
  });
}
```


```less
geoLocationManager.getAddressesFromLocation(reverseGeocodeRequest, async (err, data) => {
  if (data) {
    this.address = data[0]?.placeName || '';
    // ...
  } else {
    hilog.error(0x0000, TAG, `getAddressesFromLocation failed, code: ${err.code}, message: ${err.message}`);
    // ...
  }
});
```

3.  关闭长时任务 关闭位置变化订阅

```less
stopContinuousTask(): void {
  let context = getContext(this) as common.UIAbilityContext;
  if (!context) {
    return;
  }
  backgroundTaskManager.stopBackgroundRunning(context).then(() => {
    if (!this.isOnLocationChange) {
      // Stop the Location Change Subscription
      this.offLocationChange();
    }
    hilog.info(0x0000, TAG, 'stopBackgroundRunning succeeded');
  }).catch((err: BusinessError) => {
    hilog.error(0x0000, TAG, `stopBackgroundRunning failed, cause:  ${JSON.stringify(err)}`);
  });
}
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152834.22702620707892646975552709058970:50001231000000:2800:7358F6E8DC8F88325EFC0EE55D2606A895C43A0143C7BDDE144D529744B2B524.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152835.03296356132280787514650879907157:50001231000000:2800:FE6DDA10C94A4A1FED4FDE0D48B28A4D08401CDB84AC11AB0A6F3AB595A71097.png)

历史定位获取


当用户设备网络信号较弱或者对系统功耗比较敏感时，可以先获取系统缓存的最新位置，即最近一次的历史定位信息。


实现原理


位置服务通过getLastLocation()接口来获取系统缓存的最新位置信息。该接口参数列表为空，返回值为Location位置信息。


开发步骤


```less
let location = geoLocationManager.getLastLocation();
```


```less
geoLocationManager.getAddressesFromLocation(reverseGeocodeRequest, async (err, data) => {
  if (data) {
    this.address = data[0]?.placeName || '';
    // ...
  } else {
    hilog.error(0x0000, TAG, `getAddressesFromLocation failed, code: ${err.code}, message: ${err.message}`);
    // ...
  }
});
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152835.34071847954576076588366624301563:50001231000000:2800:BCF98DC316FBE5B640711F5B7996192152B09DD4EBF6C73478AAA30A11F6156A.png)

常见问题


位置定位不准或者位置信息有偏差


问题现象


在定位过程中，获取的定位结果不准确，或者将定位结果标记在地图上时出现偏差。


可能原因

- 定位权限设置错误，例如设置的定位权限为模糊定位而非精准定位。
- 定位策略设置错误，例如设置的策略为快速获取位置优先（蓝牙、基站、WLAN等网络定位方式）而非精度优先（GNSS卫星定位方式）。
- 在获取定位结果后，未进行坐标转换就将结果标记在地图上。华为地图在中国大陆、中国香港和中国澳门使用的是GCJ02坐标系，而定位返回结果使用的是WGS84坐标系，若直接将结果标记在华为地图上，因坐标值不同，展示位置会有偏移。

解决措施

- 申请精准定位权限ohos.permission.LOCATION，并在应用中授权获取精准位置。
- 将定位策略设置为精度优先，采用GNSS卫星定位方式。
- 在中国大陆、中国香港和中国澳门如果使用WGS84坐标调用Map Kit服务，需要先将其转换为GCJ02坐标系再访问，详情见坐标转换。

位置定位失败


问题现象


无法使用定位功能获取位置信息。


可能原因

- 系统位置开关为关闭状态。
- 网络信号不佳，导致定位超时。
- 系统无缓存位置信息，导致获取上一次位置失败。

解决措施

- 打开系统位置开关。
- 检查设备是否联网、是否插入SIM卡、WiFi开关是否开启等。
- 移动至开阔地带再发起定位。
- 在系统无缓存位置的情况下，使用getCurrentLocation()接口获取当前位置信息。

系统缓存位置信息不准确


问题现象


使用getCurrentLocation()接口获取当前定位信息后，再使用getLastLocation()接口获取缓存定位信息，两次获取的定位信息不一致。


可能原因


所有应用公用系统中的同一份缓存定位信息，有可能在两次接口调用之间有其他应用发起定位，刷新了系统中的缓存定位信息。


解决措施


对比获取定位信息的时间，根据时间判断缓存定位信息是否更新。


示例代码

- 基于位置服务获取设备定位信息

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-intent-recommend-practice
爬取时间: 2025-05-08 03:37:46
来源: Huawei Developer


概述


意图框架是HarmonyOS系统级的意图标准体系。将应用和元服务的业务功能智慧分发给不同的系统入口，以“音乐播放”为例，HarmonyOS将业务分发给“小艺建议”，提供了桌面大流量曝光，同时为开发者实现业务增长。习惯推荐类别下典型场景主要分为常用接续、常用复访以及常用推新三大类。比如“音乐播放”就属于常用接续场景。具体可参考习惯推荐典型场景。

- 常用接续：涵盖长视频、音乐、有声以及课程等领域，接续指在某个时间节点进行续播。
- 常用复访：涵盖导航、打车以及小游戏等领域，推荐用户经常使用的应用并展示卡片入口。
- 常用推新：涵盖咨询及短视频等领域，推荐用户新的咨询或者视频。

接入意图框架首先需要确定特性类别和具体意图，详细请参见Intents Kit接入流程。


本文以“音乐播放”意图为例，详细讲解意图接入与开发全过程。


音乐播放开发


以“音乐播放”为例，从意图注册、意图共享以及意图调用三大块介绍意图运行的开发过程。如果应用支持播放功能并且需要实现推荐播放接续，例如音乐、长视频以及课程的播放接续，可以参考本文。首先需要在设置中开启意图框架调试，如下图所示。确保意图框架调试开启且在界面成功展示设备支测试应用。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152822.38975525932208476350178477233513:50001231000000:2800:D4953A818F7B7DC59AC5D48EBCC6D846EFC022EE0F8DA2A146F3459B30F8A887.png)

开发步骤

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152822.86219546434747241796355584084560:50001231000000:2800:14752FDA3826A2F6547FC5D00E5BEF706FEDCEA82CF29BF671B5EE34BDC9BA36.png)

```less
{
  "insightIntents": [
    {
      "intentName": "PlayMusic",
      "domain": "MusicDomain",
      "intentVersion": "1.0.1",
      "srcEntry": "./ets/entryability/InsightIntentExecutorImpl.ets",
      "uiAbility": {
        "ability": "EntryAbility",
        "executeMode": [
          "background",
          "foreground"
        ]
      }
    },
    {
      "intentName": "PlayMusicList",
      "domain": "MusicDomain",
      "intentVersion": "1.0.1",
      "srcEntry": "./ets/entryability/InsightIntentExecutorImpl.ets",
      "uiAbility": {
        "ability": "EntryAbility",
        "executeMode": [
          "background",
          "foreground"
        ]
      }
    }
  ]
}
```


```less
[
  {
    "intentName": "PlayMusic",
    "intentVersion": "1.0",
    "identifier": "52dac3b0-6520-4974-81e5-25f0879449b5",
    "intentActionInfo": {
      "actionMode": "EXECUTED",
      "executedTimeSlots": {
        "executedStartTime": 1637393212000,
        "executedEndTime": 1637393112000
      },
      "currentPercentage": 50
    },
    "intentEntityInfo": {
      "entityName": "Music",
      "entityId": "C10194368",
      "entityGroupId": "C10194321312",
      "displayName": "红颜如霜",
      "description": "NA",
      "logoURL": "https://www-file.huawei.com/-/media/corporate/images/home/logo/huawei_logo.png",
      "keywords": [
        "华为音乐",
        "化妆"
      ],
      "rankingHint": 99,
      "expirationTime": 1637393212000,
      "metadataModificationTime": 1637393212000,
      "activityType": [
        "1",
        "2",
        "3"
      ],
      "artist": [
        "测试歌手1",
        "测试歌手2"
      ],
      "lyricist": [
        "测试词作者1",
        "测试词作者2"
      ],
      "composer": [
        "测试曲作者1",
        "测试曲作者2"
      ],
      "albumName": "测试专辑",
      "duration": 244000,
      "playCount": 100000,
      "musicalGenre": [
        "流行",
        "话语",
        "抖音",
        "00后"
      ],
      "isPublicData": false
    }
  },
  {
    "intentName": "PlayMusicList",
    "intentVersion": "1.0",
    "identifier": "52dac3b0-6520-4974-81e5-25f0879449b5",
    "intentActionInfo": {
      "actionMode": "EXECUTED",
      "executedTimeSlots": {
        "executedStartTime": 1637393212000,
        "executedEndTime": 1637393112000
      },
      "currentPercentage": 50
    },
    "intentEntityInfo": {
      "entityName": "MusicList",
      "entityId": "C10194368",
      "entityGroupId": "C10194321312",
      "displayName": "测试歌单",
      "description": "这是xxx歌单",
      "logoURL": "https://www-file.huawei.com/-/media/corporate/images/home/logo/huawei_logo.png",
      "keyWords": [
        "抖音",
        "动感"
      ],
      "rankingHint": 99,
      "expirationTime": 1637393212000,
      "metadataModificationTime": 1637393212000,
      "activityType": [
        "1",
        "2",
        "3"
      ],
      "isPublicData": false,
      "briefDescription": "这是xxx歌单，来自xxx，是xxx风格",
      "artist": [
        "测试歌手1",
        "测试歌手2"
      ],
      "numberOfSongs": 20,
      "type": "1",
      "creator": "测试创建者",
      "createDate": "2023-10-08T08:00:00+08:00",
      "musicNameList": [
        "测试歌曲1",
        "测试歌曲2"
      ],
      "playCount": 30,
      "musicalGenre": [
        "流行",
        "话语",
        "抖音",
        "00后"
      ]
    }
  }
]
```

1. 

```typescript
static async shareIntent(context: Context, input: string): Promise<string> {
  Logger.debug(TAG, 'shareIntent');
  let insightIntents: insightIntent.InsightIntent[];
  try {
    let insightIntents: insightIntent.InsightIntent[] = JSON.parse(input);
    if (!insightIntents || insightIntents.length === 0){
      Logger.error(TAG, 'shareIntent: json invalid.');
      return 'shareIntent: json invalid.';
    }
    return await insightIntent.shareIntent(context, insightIntents).then(() => {
      Logger.info(TAG, 'shareIntent success');
      return 'share intent success';
    }, (err: BusinessError) => {
      Logger.error(TAG, `shareIntent error message: ${JSON.stringify(err)}`);
      return `shareIntent error message: ${JSON.stringify(err)}`;
    });
  } catch (err) {
    Logger.error(TAG, 'shareIntent fail', err);
  }
  return Promise.reject('shareIntent fail');
}
```

2.  前后台模式 启动模式 触发生命周期 foreground 冷启动 onCreate->onWindowStageCreate->onExecuteInUIAbilityForegroundMode 热启动 onNewWant->onExecuteInUIAbilityForegroundMode background 冷启动 onCreate->onExecuteInUIAbilityBackgroundMode 热启动 onExecuteInUIAbilityBackgroundMode 本示例中采取foreground模式，可以在onCreate()或者onNewWant()解析want和launchParam。通过launchReason区分是否是意图调用拉起的Ability，如果是则解析want中的参数，并且将参数result存储在AppStorage中。如果是在真实开发中意图调用传参字段可以在开发前和接口方协商。 want解析完毕后，会触发onExecuteInUIAbilityForegroundMode()方法进行真正逻辑处理，根据意图名称去分发处理方法并且返回一个Promise，成功调用code返回0，失败时返回-1。 如果想删除掉意图，可以调用insightIntent.deleteIntent()，在注册文件只有一个意图的情况下卡片入口会消失。运行效果如下图所示。

```less
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
  Logger.info(TAG, 'onCreate');
  if (launchParam.launchReason === AbilityConstant.LaunchReason.INSIGHT_INTENT && want && want.parameters) {
    this.result = want.parameters?.['result'] as string;
  }
}
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152824.09592549723587259803329927302762:50001231000000:2800:3CAA21B4D2ECA8BFC70C16149FE248109CCB84EAADF88C2A7AFFB60BC5053BC4.png)

| 前后台模式  | 启动模式  | 触发生命周期  |    |
| --- | --- | --- | --- |
| foreground  | 冷启动  | onCreate->onWindowStageCreate->onExecuteInUIAbilityForegroundMode  |    |
|    | 热启动  | onNewWant->onExecuteInUIAbilityForegroundMode  |    |
| background  | 冷启动  | onCreate->onExecuteInUIAbilityBackgroundMode  |    |
|    | 热启动  | onExecuteInUIAbilityBackgroundMode  |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507152824.78574732948465715662210533935124:50001231000000:2800:B2C5F85C7E2428AA0710EE259DA4E85B01FD81B5214D7AC692A356713F72591D.gif)

在真机设备上，小艺建议卡片不会实时刷新。可以通过点击卡片中的服务，重新返回到桌面后，进行卡片刷新。


示例代码

- 意图框架-音乐播放案例实践

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-gn-adapts-to-harmonyos
爬取时间: 2025-05-08 03:37:53
来源: Huawei Developer


概述


本文将介绍如何在GN工程中配置HarmonyOS工具链，然后通过HarmonyOS工具链编译出可以在HarmonyOS环境下使用的三方库。


HarmonyOS编译子系统是以GN和Ninja构建为基座，对构建和配置粒度进行部件化抽象、对内建模块进行功能增强、对业务模块进行功能扩展的系统，该系统提供以下基本功能：

- 以部件为最小粒度拼装产品和独立编译。
- 支持轻量、小型、标准三种系统的解决方案级版本构建，以及用于支撑应用开发者使用DevEco Studio开发的SDK开发套件的构建。
- 支持芯片解决方案厂商的灵活定制和独立编译。

Ninja：是一个专注于快速编译的小型构建系统。


GN：Generate Ninja的缩写，用于产生Ninja文件。


编译环境配置

1.  使用 WSL 在 Windows 上安装 Linux。 Ubuntu分发版本获取及安装说明。 编译环境目前主要支持Ubuntu18.04和Ubuntu20.04。
2.  从HarmonyOS官网门户选择Linux版本的Command Line Tools下载即可。 下载链接。
3.  任意位置创建工作目录depot_tools，cd到自己创建的目录，拉取工具（需要网络环境）： 将depot_tools的路径加到环境变量中： 编译.bashrc文件将depot_tools路径信息加到最后一行。 在.bashrc文件的最后添加下面一行代码。 此处需配置绝对路径信息，例如这里创建的本地路径是/mnt/d/my_code/depot_tools，故此处配置如上图。 刷新环境变量使其生效：

```less
mkdir depot_tools
cd depot_tools
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
```

4.  直接输入指令sudo apt install python可能会安装失败，需要先输入sudo apt update更新一下可用包的最新列表。 判断python是否安装成功： 输入python显示python版本即可。

```less
sudo apt update
sudo apt install python
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153222.07780300069284376424732088834425:50001231000000:2800:6C81EA119AE3C19067C14B1DA4CC65B6EA01AABB8D9422151A74706DB35DE806.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153222.06345469737106016960857710684158:50001231000000:2800:C75610E0E7ED645E723983659E1BB3C1F8C8A4711114FF99E21C0FBB2FACD1E0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153222.12756117632321132474608327207442:50001231000000:2800:EA961607E477BC41AA0F83714F180DFB4CBCBD0FE68D15E4AE7419C15243C915.png)

GN构建工程适配流程

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153222.97809750916328845651275214295742:50001231000000:2800:3B89CE9027E3787DB99CDDBB8C40607E23AFFE823904A0DA203E26B10EEBC3B6.png)

首先，需要添加HarmonyOS平台的宏定义；然后配置好HarmonyOS平台的工具链信息（包括clang工具链，sysroot以及clang版本）；接着需要在toolchain路径下配置各个架构的ohos_clang_toolchain；然后扩充gcc_toolchain模版功能，配置HarmonyOS用于启动引导程序的.o文件信息。剩下的就是需要设置一些HarmonyOS的编译参数（主要是基础的编译选项、宏定义等）；然后在BUILD.gn中不同架构平台的分支处，添加对应的HarmonyOS平台的分支，其中未适配HarmonyOS的三方库可以先走Linux分支的编译配置。更加详细的信息可参考下节的适配案例。


webRTC适配案例


本文将通过webRTC的GN构建工程案例来对上一章节的流程进行实操讲解。WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。下面我们来了解下如何通过GN构建工程将webRTC适配到HarmonyOS系统上。


适配流程

1.  这里主要在build/config/BUILDCONFIG.gn文件中适配HarmonyOS的default_compiler_configs和_default_toolchain。在GN工程里面，BUILDCONFIG.gn是第一位被解析的，里面定义的变量相当于全局变量，可以被后续所有的.gn文件使用。我们编译过程中可能会配置一些编译选项以及一些头文件搜索路径。default_compiler_configs指向的文件里面会包括一些默认的编译选项以及头文件搜索路径等等。_default_toolchain指向了一个工具链相关的函数。具体修改点如下：
2.  不同平台的工具链会有一些差别，所以需要使用HarmonyOS的工具链。这里主要修改config/clang/clang.gni文件。.gni文件类似于GN的头文件，会被import到各个.gn文件中使用其定义的一些变量。该文件中的核心修改点在于配置指向HarmonyOS SDK的工具链路径。另外还需修改clang_use_chrome_plugins的值为false，HarmonyOS中默认clang_use_chrome_plugins值为false，不设置可能会报错find-bad-constructs文件找不到。 此处ohos_sdk_native_root的值需要对应修改为自己本地HarmonyOS SDK中的native的路径。具体修改点如下：
3.  这里主要修改build/config/sysroot.gni文件，sysroot里面包含了许多头文件搜索路径，配置了sysroot之后，编译过程中会去该目录下搜索需要的头文件。SDK里面会提供大量的头文件，这些头文件都会放在sysroot目录下，所以我们需要引入HarmonyOS对应的sysroot。具体修改点如下：
4.  这里主要修改build/toolchain/toolchain.gni文件，在该文件中配置HarmonyOS对应的clang版本号。具体修改点如下：
5.  这里主要是在build/toolchain路径下新建一个ohos/BUILD.gn文件，用于配置ohos_clang_toolchain，里面主要配置了HarmonyOS用于启动引导程序的.o文件。同时设置HarmonyOS不同架构(主要包括ohos_clang_arm、ohos_clang_arm64、ohos_clang_x86_64)的ohos_clang_toolchain配置信息。具体添加内容如下：

```less
import("//build/config/sysroot.gni")
import("//build/toolchain/gcc_toolchain.gni")


declare_args() {
  # Whether unstripped binaries, i.e. compiled with debug symbols, should be
  # considered runtime_deps rather than stripped ones.
  ohos_unstripped_runtime_outputs = true
  ohos_extra_cflags = ""
  ohos_extra_cppflags = ""
  ohos_extra_cxxflags = ""
  ohos_extra_asmflags = ""
  ohos_extra_ldflags = ""
}


# The ohos clang toolchains share most of the same parameters, so we have this
# wrapper around gcc_toolchain to avoid duplication of logic.
#
# Parameters:
#  - toolchain_root
#      Path to cpu-specific toolchain within the ndk.
#  - sysroot
#      Sysroot for this architecture.
#  - lib_dir
#      Subdirectory inside of sysroot where libs go.
#  - binary_prefix
#      Prefix of compiler executables.
template("ohos_clang_toolchain") {
  gcc_toolchain(target_name) {
    assert(defined(invoker.toolchain_args),
           "toolchain_args must be defined for ohos_clang_toolchain()")
    toolchain_args = invoker.toolchain_args
    toolchain_args.current_os = "ohos"


    # Output linker map files for binary size analysis.
    enable_linker_map = true


    ohos_libc_dir =
        rebase_path(invoker.sysroot + "/" + invoker.lib_dir, root_build_dir)
    libs_section_prefix = "${ohos_libc_dir}/Scrt1.o"
    libs_section_prefix += " ${ohos_libc_dir}/crti.o"
    libs_section_postfix = "${ohos_libc_dir}/crtn.o"


    if (invoker.target_name == "ohos_clang_arm") {
      abi_target = "arm-linux-ohos"
    } else if (invoker.target_name == "ohos_clang_arm64") {
      abi_target = "aarch64-linux-ohos"
    } else if (invoker.target_name == "ohos_clang_x86_64") {
      abi_target = "x86_64-linux-ohos"
    }


    clang_rt_dir =
        rebase_path("${clang_lib_path}/${abi_target}/nanlegacy",
                    root_build_dir)
    print("ohos_libc_dir :", ohos_libc_dir)
    print("clang_rt_dir :", clang_rt_dir)
    solink_libs_section_prefix = "${ohos_libc_dir}/crti.o"
    solink_libs_section_prefix += " ${clang_rt_dir}/clang_rt.crtbegin.o"
    solink_libs_section_postfix = "${ohos_libc_dir}/crtn.o"
    solink_libs_section_postfix += " ${clang_rt_dir}/clang_rt.crtend.o"


    _prefix = rebase_path("${clang_base_path}/bin", root_build_dir)
    cc = "${_prefix}/clang"
    cxx = "${_prefix}/clang++"
    ar = "${_prefix}/llvm-ar"
    ld = cxx
    readelf = "${_prefix}/llvm-readobj"
    nm = "${_prefix}/llvm-nm"
    if (!is_debug) {
      strip = rebase_path("${clang_base_path}/bin/llvm-strip", root_build_dir)
      use_unstripped_as_runtime_outputs = ohos_unstripped_runtime_outputs
    }
    extra_cflags = ohos_extra_cflags
    extra_cppflags = ohos_extra_cppflags
    extra_cxxflags = ohos_extra_cxxflags
    extra_asmflags = ohos_extra_asmflags
    extra_ldflags = ohos_extra_ldflags
  }
}


ohos_clang_toolchain("ohos_clang_arm") {
  sysroot = "${sysroot}"
  lib_dir = "usr/lib/arm-linux-ohos"
  toolchain_args = {
    current_cpu = "arm"
  }
}


ohos_clang_toolchain("ohos_clang_arm64") {
  sysroot = "${sysroot}"
  lib_dir = "usr/lib/aarch64-linux-ohos"
  toolchain_args = {
    current_cpu = "arm64"
  }
}


ohos_clang_toolchain("ohos_clang_x86_64") {
  sysroot = "${sysroot}"
  lib_dir = "usr/lib/x86_64-linux-ohos"
  toolchain_args = {
    current_cpu = "x86_64"
  }
}
```

6.  主要修改/build/toolchain/gcc_toolchain.gni文件。GN工程里面默认会配置gcc_toolchain，里面会包括一些tool，例如tool("cc")、tool("cxx")、tool("tolink")等等，编译不同的内容时调用其对应的配置项。这里主要是需要修改tool("solink")、tool("solink_module")中的rspfile_content配置以及tool("link")中的link_comand配置。我们需要在gcc_toolchain.gni中template("gcc_toolchain")下添加几个参数（libs_section_prefix、libs_section_postfix 、solink_libs_section_prefix、solink_libs_section_postfix ）的识别。这几个参数是指向了上一步骤中配置的用于启动引导程序的.o文件。这些参数会在我们需要修改的rspfile_content、link_comand中用到。具体修改如下： 修改tool("solink")和tool("solink_module")中的rspfile_content为rspfile_content = "-Wl,--whole-archive {{inputs}} {{solibs}} -Wl,--no-whole-archive $solink_libs_section_prefix {{libs}} $solink_libs_section_postfix"，这里需要用到刚刚定义的参数信息。具体修改如下： 修改tool("link")中link_command为link_command = "$ld {{ldflags}}${extra_ldflags} -o \"$unstripped_outfile\" $libs_section_prefix $start_group_flag @\"$rspfile\" {{solibs}} {{libs}} $end_group_flag $libs_section_postfix"，这里需要用到刚刚定义的参数信息。
7.  这里需要在build/config路径下新建一个ohos/BUILD.gn文件，该文件主要是定义了一个config("compiler")，该config会被注册到所有的编译目标，该config里面主要设置了基础的编译选项、宏定义等。 此处ohos_clang_base_path  的值需要对应修改为自己本地HarmonyOS SDK中的llvm的路径。具体添加内容如下：

```less
import("//build/config/sysroot.gni")
assert(is_ohos)


ohos_clang_base_path = "/mnt/d/ohos/ohos-sdk/linux/native/llvm"
ohos_clang_version = "15.0.4"


if (is_ohos) {
  if (current_cpu == "arm") {
    abi_target = "arm-linux-ohos"
  } else if (current_cpu == "x86") {
    abi_target = ""
  } else if (current_cpu == "arm64") {
    abi_target = "aarch64-linux-ohos"
  } else if (current_cpu == "x86_64") {
    abi_target = "x86_64-linux-ohos"
  } else {
    assert(false, "Architecture not supported")
  }
}


config("compiler") {
  cflags = [
    "-ffunction-sections",
    "-fno-short-enums",
    "-fno-addrsig",
  ]


  cflags += [
    "-Wno-unknown-warning-option",
    "-Wno-int-conversion",
    "-Wno-unused-variable",
    "-Wno-misleading-indentation",
    "-Wno-missing-field-initializers",
    "-Wno-unused-parameter",
    "-Wno-c++11-narrowing",
    "-Wno-unneeded-internal-declaration",
    "-Wno-undefined-var-template",
    "-Wno-implicit-int-float-conversion",
  ]
  defines = [
    # The NDK has these things, but doesn't define the constants to say that it
    # does. Define them here instead.
    "HAVE_SYS_UIO_H",
  ]


  defines += [
    "OHOS",
    "__MUSL__",
    "_LIBCPP_HAS_MUSL_LIBC",
    "__BUILD_LINUX_WITH_CLANG",
    "__GNU_SOURCE",
    "_GNU_SOURCE",
  ]


  ldflags = [
    "-Wl,--no-undefined",
    "-Wl,--exclude-libs=libunwind_llvm.a",
    "-Wl,--exclude-libs=libc++_static.a",


    # Don't allow visible symbols from libraries that contain
    # assembly code with symbols that aren't hidden properly.
    # http://crbug.com/448386
    "-Wl,--exclude-libs=libvpx_assembly_arm.a",
  ]


  cflags += [ "--target=$abi_target" ]
  include_dirs = [
    "${sysroot}/usr/include/${abi_target}",
    "${ohos_clang_base_path}/lib/clang/${ohos_clang_version}/include",
  ]


  ldflags += [ "--target=$abi_target" ]


  # Assign any flags set for the C compiler to asmflags so that they are sent
  # to the assembler.
  asmflags = cflags
}
```

8.  保证可以正确走HarmonyOS支持的编译分支。这里主要是为了防止clang版本号校验失败导致异常。具体修改如下：
9.  当前部分三方库还未适配HarmonyOS，涉及到时可以先走linux的编译配置，例如：需要获取config.h文件时。 修改modules/video_capture的BUILD.gn。具体修改如下： 修改third_party/zlib的BUILD.gn。具体修改如下： 修改third_party/libevent中的BUILD.gn。HarmonyOS SDK中没有queue.h头文件，需要使用compat dir目录下的queue.h头文件。具体修改如下：
10.  先通过GN命令生成对应的ninja文件，然后使用ninja编译命令进行编译。 可以根据需要在编译指令中添加对应参数信息。 查看具体编译命令： 可以在gn gen命令中添加--ninja-args="-v -dkeeprsp"用于查看具体编译命令，这个命令将会在编译过程中打印详细的编译命令，并且保留编译过程中生成的rsp文件。 查看一个目标被谁依赖： 例如gn refs out/intermediate/arm64_72 //pc:rtc_pc_base。这个命令将显示与目标//pc:rtc_pc_base相关的所有依赖项并列出所有引用了该目标的其他目标或文件。

```less
gn gen ../out/xxx --args='is_clang=true target_os="ohos" target_cpu="arm64" xxx'  
ninja -v -C ../out/xxx ${target_name} -j16 
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153222.72147068549154354939340585625886:50001231000000:2800:017F4FCD7936C7ED098E124AFA99786811D6D1E5212E371F96599045EE490E30.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153222.93817436214906186112641046970631:50001231000000:2800:3FC9316BAA9F05FD4555273A511CB38F9A6F9A23D1B34A13465F313EDF9895C6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153222.25290989113657623820018466373076:50001231000000:2800:047892F4EA082E0297944CBA30CA28E752AD4996B5ED37ADECB9BD8A5D3FBA77.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153222.65424727768606013832608606884957:50001231000000:2800:A892663445DBC71A3AE04DD255CE3CE6BA14695AB487EEDBB74429CFDFCBE456.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.71794054802745311302721947817214:50001231000000:2800:BBF1795FE232386D8A6F509D35CC4DEFE65A0419A66E1D2FC4B0B6CFC5FCC661.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.70660021543601864142852038133281:50001231000000:2800:B746AD2DD9FB2CC624E4D7140A8BF7DF81BA9418E5E64CCD358D3FB8B7AA544B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.82690475721858603239623891698529:50001231000000:2800:3128BC6BF50E05547DB779EAB7DB63ED449B616D1089E05ABFDBEECB7D160859.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.92724273406979816452451726785082:50001231000000:2800:CE3F041C5484D0D84EBA84AB595872CCA36DC00AF01656B42ED18C5802B2ED3D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.61705814265782737095362714892121:50001231000000:2800:E670BAB8D4B855619FB5C8F63C7D201E36023837CC24B7CF4A031377B77BEC40.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.02944794540125116064380453107142:50001231000000:2800:41DF2557EE5BE4564A656806F02B9D121A0DC7CFC705666B6200146950578622.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.69198816899441087479018846305521:50001231000000:2800:B523F7FB225615E03261E56CAE30833F40CE65D9822943D7EF5EA9BABC223F0E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.00342613456808560924282919670195:50001231000000:2800:3EF718978F57E2AD3AFE43474C7696151A73CA1DAB59A2459A4BCBE0592CC5AD.png)

常见问题总结


在对webRTC的GN工程进行HarmonyOS工具链适配过程中，遇到了一些常见问题场景。下面针对这些问题做一个具体分析。

1.  问题详情： 问题原因/解决措施： 三方库内部没有做对is_ohos的判断，导致走到错误分支。当前很多业务模块还未适配HarmonyOS，暂时可以走linux分支以保证正常编译。 具体修改： 修改third_party/zlib的BUILD.gn文件。
2.  问题详情： 问题原因/解决措施： 缺少pkg-config插件，安装该插件。 具体指令：

```less
sudo apt-get install pkg-config
```

3.  问题详情： 问题原因/解决措施： 编译过程中会提示部分配置不识别，需要将这些配置项删除。 具体修改： 在build/config/compiler/BUILD.gn中删除以下配置。
4.  问题详情： 问题原因/解决措施： 编译器驱动程序有时（很少）会在调用之前发出警告。实际的链接器需要确保这些警告是否也被视为致命错误。为了避免编译中出现因警告而造成出错，可以添加编译参数treat_warnings_as_errors = false，或者去除config(treat_warnings_as_errors)中配置的“-Werror”，详情如下： 具体修改：
5. 
6. 
7.  问题详情： 问题原因/解决措施： rtc_base/platform_thread_types.cc未识别到is_ohos导致内部走错分支导致异常。目前HarmonyOS支持的接口是gettid()，rtc_base/platform_thread_types.cc需要识别到is_ohos然后调用gettid()。由于当前很多业务模块还未进行识别，暂时需要走linux分支，故需要保留linux的定义。 具体修改：
8. 
9. 
10.  fatal error: 'sys/queue.h' file not found 问题详情： 问题原因/解决措施： 找不到config.h头文件，libevent尚未适配HarmonyOS，需要添加is_ohos的判断并走linux的文件路径寻找config.h。 找不到'sys/queue.h'文件，HarmonyOS SDK中没有queue.h头文件，需要使用compat dir目录下的queue.h头文件。 具体修改： 修改third_party/libevent中的BUILD.gn。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.75909484956072148100355179993853:50001231000000:2800:617CED40B5617829022ADAC3B6F5DF1E637F20A05B88A218671A9D310F782A99.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.68857199347149889268080579004054:50001231000000:2800:39DFABB4FC63C97DEF1380C20EA0577F054CC2BE1F37ADB497352CDC66009BA2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.21287298130436007131238992701409:50001231000000:2800:2D47057D23180135EAAEC1173F4E9A5991BC6202EED850C0D5161697E39B679B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.71157835609859137217454358708023:50001231000000:2800:CEA32A70F36DEB03D606C651C81201F868B67F64662B10ED0B48B42E2915BBDB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.13550889190214230090587736755698:50001231000000:2800:5CF0FA205C29DBE3995544D7B3F1FDBDD630935955A96213E8777C2CE2B47108.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.12817006567633543247687967534735:50001231000000:2800:D60657BB285231EFA9D7A97DFA6E5DEA3AF86271AF785858A6463A5012017212.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.82252738577003166901808129843566:50001231000000:2800:7424F4F6C71BEAA53F87283CFEC441DDA27F4CF3023F9D4FC62243A96C024728.png)
- 
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153223.52113239189330210507319638363879:50001231000000:2800:E3DC9C00F3C818A467D31EA43F2CA7865AE87D5EFF170BAAA05B218899B706DE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153224.76012254165033557990994003450585:50001231000000:2800:5E88C66B00225A75BD0529E314C08191CC2E4546B127D812E36CE08093E62BCA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153224.11289931977837057628294839288224:50001231000000:2800:F95A65346ACE03EDDF8E9A9F19C8E2B0526E19A1651F9EBACAE2F62F185506EC.png)
- 
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153224.27170200040163903979341496183249:50001231000000:2800:7D05E37BD32AA9767CC6E7A3F2694E753B31FB786B661F425FFC1817C1A75D9F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153224.23289731085599359126347228613098:50001231000000:2800:6608004C9C03884BAE9A419B2B22AC7D47D964377A0851FC9266E951FFE63A49.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153224.02917494635836259828421403370296:50001231000000:2800:D6F5B859EFECC011859A2BDA4B56BFA590375C1858BC97EED9C853CC4E2C6635.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153224.67385212596152005026901433216784:50001231000000:2800:D48AAAA96A5D09E1E166DC886BCFE6583E25BB26B9ABA67A78A4D711102FE9FB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153224.98123813873408878151680679496767:50001231000000:2800:452F2258D0174337FBA55F9B9591A712F26D0D45D539D6F3F87B127EA3BECFE4.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-cmake-adapts-to-harmonyos
爬取时间: 2025-05-08 03:37:59
来源: Huawei Developer


概述


CMake是一个跨平台的构建工具，用于管理构建过程、编译、链接和打包软件项目，它可以生成Makefile等用于不同操作系统和编译器的构建脚本。CMake的配置过程是跨平台的，因此可以在不同的操作系统上运行，例如Linux、Windows和macOS。


CMake构建过程可分为以下三个主要步骤：

- 配置（Configuration）：配置阶段是CMake解析CMakeLists.txt文件的过程。在配置阶段，CMake会读取CMakeLists.txt文件，并执行其中的命令。CMakeLists.txt文件是CMake的核心，其定义了项目的构建规则和依赖关系。
- 生成（Generation）：生成阶段是CMake根据配置阶段的结果，生成实际构建文件的过程。在生成阶段，CMake会将CMakeLists.txt文件中定义的构建规则和依赖关系转为构建工具可以理解的形式。
- 构建（Build）：构建阶段是使用构建工具（如Make或DevEco Studio）根据生成的构建文件，编译源代码并链接生成目标文件的过程。在构建阶段，构建工具会读取生成的构建文件，按照其中定义的规则和依赖关系，执行实际的编译和链接操作。

CMake构建三方库适配流程


本小节介绍如何在Linux环境下，使用CMake构建工具通过ohos sdk编译cJSON三方库源码，生成ohos平台三方库的so及二进制文件。


环境准备

1.  开发者可以选择熟悉的发行版来进行环境搭建，这里以Ubuntu为例，Ubuntu目前主要支持Ubuntu18.04和Ubuntu20.04。

```less
owner@ubuntu:/mnt/e/ohosSDK$ tar -zxvf version-Master_Version-OpenHarmony_4.0.10.5-20230824_120921-ohos-sdk-public_monthly.tar.gz
```


```less
owner@ubuntu:/mnt/e/ohosSDK$ cd ohos-sdk/linux
owner@ubuntu:/mnt/e/ohosSDK/ohos-sdk/linux$ for i in *.zip;do unzip ${i};done                  # 通过for循环一次解压所有的工具包
owner@ubuntu:/mnt/e/ohosSDK/ohos-sdk/linux$ ls
ets                                 native                                    toolchains
ets-linux-x64-4.0.10.5-Release.zip  native-linux-x64-4.0.10.5-Release.zip     toolchains-linux-x64-4.0.10.5-Release.zip
js                                  previewer
js-linux-x64-4.0.10.5-Release.zip   previewer-linux-x64-4.0.10.5-Release.zip
```


```less
owner@ubuntu:/mnt/e/cmake$ git clone https://github.com/DaveGamble/cJSON.git -b v1.7.18        # 通过git下载指定版本的源码
Cloning into 'cJSON'...
remote: Enumerating objects: 4545, done.
remote: Total 4545 (delta 0), reused 0 (delta 0), pack-reused 4545
Receiving objects: 100% (4545/4545), 2.45 MiB | 1.65 MiB/s, done.
Resolving deltas: 100% (3026/3026), done.
Note: switching to 'd348621ca93571343a56862df7de4ff3bc9b5667'.


You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.


If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:


  git switch -c <new-branch-name>


Or undo this operation with:


  git switch -


Turn off this advice by setting config variable advice.detachedHead to false
```


编译三方库

1.  为防止污染源码目录文件，推荐在三方库源码目录新建一个编译目录，用于生成需要编译的配置文件。 本用例中在cJSON目录下新建一个build目录：

```less
owner@ubuntu:/mnt/e/cmake$ cd cJSON-1.7.18                                   # 进入cJSON目录
owner@ubuntu:/mnt/e/cmake/cJSON-1.7.18$ mkdir build && cd build              # 创建编译目录并进入到编译目录
owner@ubuntu:/mnt/e/cmake/cJSON-1.7.18/build$
```

2.  参数说明： 部分文件产物说明：

```less
owner@ubuntu:/mnt/e/cmake/cJSON-1.7.18/build$ /xxx/ohos-sdk/linux/native/build-tools/cmake/bin/cmake -DCMAKE_TOOLCHAIN_FILE=/xxx/ohos-sdk/linux/native/build/cmake/ohos.toolchain.cmake -DCMAKE_INSTALL_PREFIX=/xxx/cJSON -DOHOS_ARCH=arm64-v8a .. -L                                                   # 执行cmake命令
-- The C compiler identification is Clang 12.0.1
-- Check for working C compiler: /mnt/e/ohosSDK/ohos-sdk/linux/native/llvm/bin/clang   # 采用sdk内的编译器
-- Check for working C compiler: /mnt/e/ohosSDK/ohos-sdk/linux/native/llvm/bin/clang -- works
...
# 省略部分cmake信息
...
ENABLE_PUBLIC_SYMBOLS:BOOL=ON
ENABLE_SAFE_STACK:BOOL=OFF
ENABLE_SANITIZERS:BOOL=OFF
ENABLE_TARGET_EXPORT:BOOL=ON
ENABLE_VALGRIND:BOOL=OFF
owner@ubuntu:/mnt/e/cmake/cJSON-1.7.18/build$ ls                             # 执行完cmake成功后在当前目录生成Makefile文件
cJSONConfig.cmake  cJSONConfigVersion.cmake  CMakeCache.txt  CMakeFiles  cmake_install.cmake  CTestTestfile.cmake  fuzzing  libcjson.pc  Makefile  tests
```

3.  执行make对cJSON进行编译：

```less
owner@ubuntu:/mnt/e/cmake/cJSON-1.7.18/build$ make                  # 执行make命令进行编译
Scanning dependencies of target cjson
[  2%] Building C object CMakeFiles/cjson.dir/cJSON.c.o
clang: warning: argument unused during compilation: '--gcc-toolchain=/mnt/e/ohosSDK/ohos-sdk/linux/native/llvm' [-Wunused-command-line-argument]
  /mnt/e/cmake/cJSON-1.7.18/cJSON.c:561:9: warning: 'long long' is an extension when C99 mode is not enabled [-Wlong-long]
...
# 省略部分make信息
...
clang: warning: argument unused during compilation: '--gcc-toolchain=/mnt/e/ohosSDK/ohos-sdk/linux/native/llvm' [-Wunused-command-line-argument]
[ 97%] Building C object fuzzing/CMakeFiles/fuzz_main.dir/cjson_read_fuzzer.c.o
clang: warning: argument unused during compilation: '--gcc-toolchain=/mnt/e/ohosSDK/ohos-sdk/linux/native/llvm' [-Wunused-command-line-argument]
[100%] Linking C executable fuzz_main
[100%] Built target fuzz_main
```

4.  编译成功后开发者可以通过file命令查看文件的属性，以此判断交叉编译是否成功，如下信息显示libcjson.so为aarch64架构文件，即交叉编译成功：

```less
owner@ubuntu:/mnt/e/cmake/cJSON-1.7.18/cJSON/build$ file libcjson.so.1.7.18                     # 查看文件属性命令
libcjson.so.1.7.18: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, BuildID[sha1]=a79e4b52a332702b4853f2d6cac2fcd7dff95023, with debug_info, not stripped
```


```less
owner@ubuntu:/mnt/e/cmake/cJSON-1.7.18/cJSON/build$ make install                                # 执行安装命令
[  4%] Built target cjson
[  8%] Built target cJSON_test
...
# 省略部分make install信息
...
-- Installing: /mnt/e/cmake/cJSON-1.7.18/cJSON/lib/cmake/cJSON/cJSONConfig.cmake
-- Installing: /mnt/e/cmake/cJSON-1.7.18/cJSON/lib/cmake/cJSON/cJSONConfigVersion.cmake
owner@ubuntu:/mnt/e/cmake/cJSON-1.7.18/cJSON/build$
```

- CMAKE_TOOLCHAIN_FILE：交叉编译配置文件路径，设置为ohos工具链配置文件。
- CMAKE_INSTALL_PREFIX：配置安装三方库路径。
- OHOS_ARCH: 配置交叉编译的CPU架构，一般为arm64-v8a（编译64位的三方库）或armeabi-v7a（编译32位的三方库），本示例中设置编译为64位的cJSON库。
- -L: 显示cmake中可配置项目。
- Makefile：构建项目的Makefile文件，包含了编译、链接等指令。
- CMakeCache.txt：CMake的缓存文件，记录了CMake的配置选项和变量信息。
- CMakeFiles：CMake的临时文件目录，包含了一些中间文件和构建信息，方便后续重新生成Makefile时使用。
- cmake_install.cmake：安装规则文件，用于执行安装操作，将编译好的文件安装到指定的目录下。
- CTestTestfile.cmake：用于执行测试的CMake脚本文件，方便进行自动化测试。

应用中集成使用三方库


请参考：三方动态链接库（.so）集成开发实践。


URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-make-adapts-to-harmonyos
爬取时间: 2025-05-08 03:38:05
来源: Huawei Developer


概述


Make是一个标准的Unix构建工具，用于自动化编译过程。它可以读取Makefile中的规则和依赖项，并根据这些规则来构建源代码，Make会检查源代码文件的时间戳，以确定哪些文件需要重新编译。Make会自动解决依赖关系并按正确的顺序编译源文件，通过在终端中运行Make命令，Make将根据Makefile中的指令逐步构建代码，生成最终的可执行程序或库文件。


Makefile文件是一个文本文件，它定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，以及哪些文件需要重新编译。这些规则包括文件的编译方式、库文件的创建方法，以及最终生成的可执行文件的制作过程。Makefile文件描述了整个工程的编译、连接等规则，包括源文件的依赖关系和编译顺序。通过编写Makefile文件，开发者可以自动化地构建和管理工程项目，极大地提高了开发效率。


二者关系：


Makefile是Make工具的配置文件，用于描述项目的构建规则和依赖关系。Make工具则根据这些规则和依赖关系，来决定哪些文件需要重新构建，从而实现自动化构建过程。二者共同作用，提高了软件开发的效率和便利性。


Make构建三方库适配流程


本小节介绍如何在Linux环境下，使用Make构建工具通过ohos sdk编译bzip2三方库源码，生成ohos平台三方库的so及二进制文件。


环境准备


```less
owner@ubuntu:/mnt/e/make-makefile$ wget https://sourceforge.net/projects/bzip2/files/bzip2-1.0.6.tar.gz     # 下载源码包
```


```less
owner@ubuntu:/mnt/e/make-makefile$ tar -zxf bzip2-1.0.6.tar.gz                    # 解压源码包
owner@ubuntu:/mnt/e/make-makefile$
owner@ubuntu:/mnt/e/make-makefile$ cd bzip2-1.0.6/                                # 进入到bzip2源码目录
owner@ubuntu:/mnt/e/make-makefile/bzip2-1.0.6$
```


编译三方库

1.  因为需要适配ohos，所以需要将非ohos的工具链配置为ohos的工具链。 通过分析源库的Makefile文件可知，以下几个内容需要进行重新配置： 环境变量作用： 默认配置Linux下gcc的编译命令，编译时需要配置成HarmonyOS交叉编译命令。 PREFIX：用于指定安装路径的前缀。 默认配置的安装目录为系统的/usr/local/下，如果需要执行安装的话，需配置成用户目录下。

```less
# To assist in cross-compiling
CC=gcc 
AR=ar  
RANLIB=ranlib                                  
```

2.  环境变量作用： 默认配置Linux下gcc的编译命令，编译时需要配置成HarmonyOS交叉编译命令。

```less
# To assist in cross-compiling
CC=gcc 
AR=ar  
RANLIB=ranlib                                  
```

3.  PREFIX：用于指定安装路径的前缀。 默认配置的安装目录为系统的/usr/local/下，如果需要执行安装的话，需配置成用户目录下。

```less
# Where you want it installed when you do 'make install'
PREFIX=/usr/local                                          
```

4.  分析完Makefile后，即可配置交叉编译命令进行编译（xxx需要改为自己的文件路径）。 参数说明： 注：CC配置时，除了配置为交叉编译的clang外，还需要配置target的架构，即配置成aarch64位，按此配置编译出来的文件才能在64位设备上运行，如若需要编译32位的文件，则target配置成arm-linux-ohos即可。

```less
owner@ubuntu:/mnt/e/make-makefile/bzip2-1.0.6$ make CC="xxx/ohos-sdk/linux/native/llvm/bin/clang --target=aarch64-linux-ohos" AR=xxx/ohos-sdk/linux/native/llvm/bin/llvm-ar RANDLIB=xxx/ohos-sdk/linux/native/llvm/bin/llvm-ranlib -j4 libbz2.a bzip2 bzip2recover
xxx/ohos-sdk/linux/native/llvm/bin/clang --target=aarch64-linux-ohos -Wall -Winline -O2 -g -D_FILE_OFFSET_BITS=64 -c huffman.c
xxx/ohos-sdk/linux/native/llvm/bin/clang --target=aarch64-linux-ohos -Wall -Winline -O2 -g -D_FILE_OFFSET_BITS=64 -c crctable.c
...
# 省略部分make信息
...
xxx/ohos-sdk/linux/native/llvm/bin/llvm-ar cq libbz2.a blocksort.o huffman.o crctable.o randtable.o compress.o decompress.o bzlib.o
ranlib libbz2.a
1 warning generated.
xxx/ohos-sdk/linux/native/llvm/bin/clang --target=aarch64-linux-ohos -Wall -Winline -O2 -g -D_FILE_OFFSET_BITS=64  -o bzip2 bzip2.o -L. -lbz2
owner@ubuntu:~/workspace/bzip2-1.0.6$
```

5.  编译时配置了aarch64-linux-ohos，因此生成的文件属性为ARM aarch64，交叉编译成功。

```less
owner@ubuntu:/mnt/e/make-makefile/bzip2-1.0.6$ file bzip2             # 使用file查看生成的文件属性
bzip2: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-aarch64.so.1, with debug_info, not stripped
owner@ubuntu:/mnt/e/make-makefile/bzip2-1.0.6$
```

6.  通过之前分析Makefile可以知道，在安装时需要配置PREFIX这个安装路径的变量：

```less
owner@ubuntu:/mnt/e/make-makefile/bzip2-1.0.6$ make install PREFIX=xxx/bzip/                   # 执行make install安装
if ( test ! -d /mnt/e/make-makefile/bzip2-1.0.6/bzip/bin ) ; then mkdir -p /mnt/e/make-makefile/bzip2-1.0.6/bzip/bin ; fi
if ( test ! -d /mnt/e/make-makefile/bzip2-1.0.6/bzip/lib ) ; then mkdir -p /mnt/e/make-makefile/bzip2-1.0.6/bzip/lib ; fi
if ( test ! -d /mnt/e/make-makefile/bzip2-1.0.6/bzip/man ) ; then mkdir -p /mnt/e/make-makefile/bzip2-1.0.6/bzip/man ; fi
if ( test ! -d /mnt/e/make-makefile/bzip2-1.0.6/bzip/man/man1 ) ; then mkdir -p /mnt/e/make-makefile/bzip2-1.0.6/bzip/man/man1 ; fi
if ( test ! -d /mnt/e/make-makefile/bzip2-1.0.6/bzip/include ) ; then mkdir -p /mnt/e/make-makefile/bzip2-1.0.6/bzip/include ; fi
...
# 省略部分make install信息
...
cp -f bzgrep.1 bzmore.1 bzdiff.1 /mnt/e/make-makefile/bzip2-1.0.6/bzip/man/man1
chmod a+r /mnt/e/make-makefile/bzip2-1.0.6/bzip/man/man1/bzgrep.1
chmod a+r /mnt/e/make-makefile/bzip2-1.0.6/bzip/man/man1/bzmore.1
chmod a+r /mnt/e/make-makefile/bzip2-1.0.6/bzip/man/man1/bzdiff.1
echo ".so man1/bzgrep.1" > /mnt/e/make-makefile/bzip2-1.0.6/bzip/man/man1/bzegrep.1
echo ".so man1/bzgrep.1" > /mnt/e/make-makefile/bzip2-1.0.6/bzip/man/man1/bzfgrep.1
echo ".so man1/bzmore.1" > /mnt/e/make-makefile/bzip2-1.0.6/bzip/man/man1/bzless.1
echo ".so man1/bzdiff.1" > /mnt/e/make-makefile/bzip2-1.0.6/bzip/man/man1/bzcmp.1
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153224.47094064453557329145562162422435:50001231000000:2800:238F647BC5205D3734CED366FAAC6FAD668BF33FC798B72D80463AC1906932A2.png)
1.  环境变量作用： 默认配置Linux下gcc的编译命令，编译时需要配置成HarmonyOS交叉编译命令。

```less
# To assist in cross-compiling
CC=gcc 
AR=ar  
RANLIB=ranlib                                  
```

2.  PREFIX：用于指定安装路径的前缀。 默认配置的安装目录为系统的/usr/local/下，如果需要执行安装的话，需配置成用户目录下。

```less
# Where you want it installed when you do 'make install'
PREFIX=/usr/local                                          
```

- CC：用于指定C语言编译器。
- AR：用于指定归档工具。
- RANLIB：用于指定归档文件的索引命令。
- -j4：指定并行编译的作业数。
- libbz2.a：bzip2压缩库的静态链接库文件，包含了bzip2压缩和解压缩所需的函数和数据结构，供其它程序在链接时使用。
- bzip2：bzip2压缩算法的可执行文件，用于压缩文件或目录。
- bzip2recover：bzip2压缩算法的恢复工具，可以用于恢复由bzip2压缩产生的损坏的压缩文件。

应用中集成使用三方库


请参考：三方动态链接库（.so）集成开发实践。


URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-configure-adapts-to-harmonyos
爬取时间: 2025-05-08 03:38:12
来源: Huawei Developer


概述


Configure是一个用于自动化软件编译和安装的工具，它可以帮助开发者编译和安装源代码，以便生成可执行文件和库文件。在编译和安装软件时，通常需要一系列步骤，例如设置编译选项、检查依赖库、生成配置文件等，Configure可以通过读取软件的源代码，自动化这些步骤，简化软件的编译和安装过程。其原理是根据系统环境和用户设置来生成Makefile文件，Makefile文件是一个包含编译选项和依赖关系的脚本，可以自动化编译和安装软件。


Configure工具的主要作用：

- 配置检查：Configure脚本会检查系统是否具有编译软件所需的所有依赖项，如编译器、库文件等。
- 生成Makefile：根据系统的配置情况，Configure生成相应的Makefile，确保编译过程能够顺利进行。
- 提供命令行选项：Configure脚本支持大量的命令行选项，这些选项允许用户自定义编译选项，如安装路径、优化级别等。通过执行./configure --help可以查看所有可用的选项。
- 缓存机制：为提高后续配置的效率，Configure支持将测试结果缓存到一个文件中，避免重复进行相同的测试。

Configure构建三方库适配流程


本小节介绍如何在Linux环境下，使用Configure构建工具通过ohos sdk编译jpeg三方库源码，生成ohos平台三方库的so及二进制文件。


环境准备


```less
owner@ubuntu:/mnt/e/configure$ wget http://www.ijg.org/files/jpegsrc.v9e.tar.gz       # 下载三方库源码包
```


```less
owner@ubuntu:/mnt/e/configure$ tar -zxvf jpegsrc.v9e.tar.gz                           # 解压源码包
```


编译三方库

1.  由Configure的帮助信息可以知道，jpeg交叉编译需要配置主机（编译完后需要运行的系统机器）、交叉编译命令以及配置安装路径等选项。

```less
owner@ubuntu:/mnt/e/configure/$ cd jpeg-9e
owner@ubuntu:/mnt/e/configure/jpeg-9e$ ./configure --help                             # 查看configure配置项
`configure` configures libjpeg 9.5.0 to adapt to many kinds of systems.
Usage: ./configure [OPTION]... [VAR=VALUE]...
...
# 配置安装选项
Installation directories:
  --prefix=PREFIX         install architecture-independent files in PREFIX
[/usr/local]
...
# 配置编译的主机选项(--host)，默认配置为linux
System types:
  --build=BUILD     configure for building on BUILD [guessed]
  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
  --target=TARGET   configure for building compilers for TARGET [HOST]
# cJSON库配置可选项
Optional Features:
  --disable-option-checking  ignore unrecognized --enable/--with options
--disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
--enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
--enable-silent-rules   less verbose build output (undo: "make V=1")
--disable-silent-rules  verbose build output (undo: "make V=0")
--enable-maintainer-mode
enable make rules and dependencies not useful (and
sometimes confusing) to the casual installer
--enable-dependency-tracking
do not reject slow dependency extractors
--disable-dependency-tracking
speeds up one-time build
--enable-ld-version-script
enable linker version script (default is enabled
when possible)
--enable-shared[=PKGS]  build shared libraries [default=yes]
--enable-static[=PKGS]  build static libraries [default=yes]
--enable-fast-install[=PKGS]
optimize for fast installation [default=yes]
--disable-libtool-lock  avoid locking (might break parallel builds)
--enable-maxmem=N     enable use of temp files, set max mem usage to N MB
...
# 配置编译命令(默认使用linux gcc相关配置)
Some influential environment variables:
  CC          C compiler command
CFLAGS      C compiler flags
LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
nonstandard directory <lib dir>
  LIBS        libraries to pass to the linker, e.g. -l<library>
CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
you have headers in a nonstandard directory <include dir>
  CPP         C preprocessor
LT_SYS_LIBRARY_PATH
User-defined run-time library search path.


Use these variables to override the choices made by `configure` or to help
it to find libraries and programs with nonstandard names/locations.
Report bugs to the package provider.
```


```less
owner@ubuntu:/mnt/e/configure/jpeg-9e$ export OHOS_SDK=/xxx/ohos-sdk/linux/                                          # 配置SDK路径，此处需配置成自己的sdk解压目录
owner@ubuntu:/mnt/e/configure/jpeg-9e$ export AS=${OHOS_SDK}/native/llvm/bin/llvm-as
owner@ubuntu:/mnt/e/configure/jpeg-9e$ export CC="${OHOS_SDK}/native/llvm/bin/clang --target=aarch64-linux-ohos"     # 32bit的target需要配置成 --target=arm-linux-ohos
owner@ubuntu:/mnt/e/configure/jpeg-9e$ export CXX="${OHOS_SDK}/native/llvm/bin/clang++ --target=aarch64-linux-ohos"  # 32bit的target需要配置成 --target=arm-linux-ohos
owner@ubuntu:/mnt/e/configure/jpeg-9e$ export LD=${OHOS_SDK}/native/llvm/bin/ld.lld
owner@ubuntu:/mnt/e/configure/jpeg-9e$ export STRIP=${OHOS_SDK}/native/llvm/bin/llvm-strip
owner@ubuntu:/mnt/e/configure/jpeg-9e$ export RANLIB=${OHOS_SDK}/native/llvm/bin/llvm-ranlib
owner@ubuntu:/mnt/e/configure/jpeg-9e$ export OBJDUMP=${OHOS_SDK}/native/llvm/bin/llvm-objdump
owner@ubuntu:/mnt/e/configure/jpeg-9e$ export OBJCOPY=${OHOS_SDK}/native/llvm/bin/llvm-objcopy
owner@ubuntu:/mnt/e/configure/jpeg-9e$ export NM=${OHOS_SDK}/native/llvm/bin/llvm-nm
owner@ubuntu:/mnt/e/configure/jpeg-9e$ export AR=${OHOS_SDK}/native/llvm/bin/llvm-ar
owner@ubuntu:/mnt/e/configure/jpeg-9e$ export CFLAGS="-fPIC -D__MUSL__=1"                                             # 32bit需要增加配置 -march=armv7a
owner@ubuntu:/mnt/e/configure/jpeg-9e$ export CXXFLAGS="-fPIC -D__MUSL__=1"                                           # 32bit需要增加配置 -march=armv7a
```

2.  安装路径以及host配置可以在./configure时执行（xxx表示自定义安装路径），host此处以配置arm64位为例。 执行完./configure未提示任何错误，即说明配置成功，在当前目录会生成Makefile文件。

```less
owner@ubuntu:/mnt/e/configure/jpeg-9e$ ./configure --prefix=xxx/jpeg --host=aarch64-linux       # 执行configure命令配置交叉编译信息
checking build system type... x86_64-pc-linux-gnu
checking host system type... x86_64-pc-linux-gnu
checking target system type... x86_64-pc-linux-gnu
...
# 省略部分configure信息
...
configure: creating ./config.status
config.status: creating Makefile
config.status: creating libjpeg.pc
config.status: creating jconfig.h
config.status: executing depfiles commands
config.status: executing libtool commands
```


```less
owner@ubuntu:/mnt/e/configure/jpeg-9e$ make                       # 执行make编译命令
make  all-am
make[1]: Entering directory '/home/owner/workspace/jpeg-9e'
CC       cjpeg.o
CC       rdppm.o
...
# 省略部分make信息
...
CC       rdcolmap.o
CCLD     djpeg
CC       jpegtran.o
CC       transupp.o
CCLD     jpegtran
CC       rdjpgcom.o
CCLD     rdjpgcom
CC       wrjpgcom.o
CCLD     wrjpgcom
make[1]: Leaving directory '/home/owner/workspace/jpeg-9e'
```


```less
owner@ubuntu:/mnt/e/configure/jpeg-9e$ make install
make[1]: Entering directory '/mnt/e/configure/jpeg-9e'
  /usr/bin/mkdir -p '/mnt/e/configure/jpeg-9e/jpeg/lib'
  /bin/bash ./libtool   --mode=install /usr/bin/install -c   libjpeg.la '/mnt/e/configure/jpeg-9e/jpeg/lib'
libtool: install: /usr/bin/install -c .libs/libjpeg.so.9.5.0 /mnt/e/configure/jpeg-9e/jpeg/lib/libjpeg.so.9.5.0
...
# 省略部分make install信息
...
libtool: install: /usr/bin/install -c wrjpgcom /mnt/e/configure/jpeg-9e/jpeg/bin/wrjpgcom
  /bin/bash /mnt/e/configure/jpeg-9e/install-sh -d /mnt/e/configure/jpeg-9e/jpeg/include
  /usr/bin/install -c -m 644 jconfig.h /mnt/e/configure/jpeg-9e/jpeg/include/jconfig.h
  /usr/bin/mkdir -p '/mnt/e/configure/jpeg-9e/jpeg/include'
  /usr/bin/install -c -m 644 jerror.h jmorecfg.h jpeglib.h '/mnt/e/configure/jpeg-9e/jpeg/include'
  /usr/bin/mkdir -p '/mnt/e/configure/jpeg-9e/jpeg/share/man/man1'
  /usr/bin/install -c -m 644 cjpeg.1 djpeg.1 jpegtran.1 rdjpgcom.1 wrjpgcom.1 '/mnt/e/configure/jpeg-9e/jpeg/share/man/man1'
  /usr/bin/mkdir -p '/mnt/e/configure/jpeg-9e/jpeg/lib/pkgconfig'
  /usr/bin/install -c -m 644 libjpeg.pc '/mnt/e/configure/jpeg-9e/jpeg/lib/pkgconfig'
```


```less
owner@ubuntu:/mnt/e/configure/jpeg-9e$ cd xxx/jpeg
owner@ubuntu:/mnt/e/configure/jpeg-9e/jpeg$ ls
bin  include  lib  share
owner@ubuntu:/mnt/e/configure/jpeg-9e/jpeg$ ls lib
libjpeg.a  libjpeg.la  libjpeg.so  libjpeg.so.9  libjpeg.so.9.5.0  pkgconfig
owner@ubuntu:/mnt/e/configure/jpeg-9e/jpeg$ ls include/
jconfig.h  jerror.h  jmorecfg.h  jpeglib.h
owner@ubuntu:/mnt/e/configure/jpeg-9e/jpeg$ file lib/libjpeg.so.9.5.0
lib/libjpeg.so.9.5.0: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, with debug_info, not stripped
```


```less
owner@ubuntu:/mnt/e/configure$ mv jpeg-9e/jpeg/bin/* jpeg-9e/
```


应用中集成使用三方库


请参考：三方动态链接库（.so）集成开发实践。


URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-lycium-adapts-to-harmonyos
爬取时间: 2025-05-08 03:38:18
来源: Huawei Developer


概述


随着技术的不断发展，移动应用开发需求也越来越大，在传统移动应用开发过程中，开发者需要面对较为繁琐的配置和环境搭建，这使开发成本变得更高。为解决这类问题，通过使用lycium工具，可以帮助开发者实现快速开发，简化开发流程，减少开发耗时。


lycium是一款协助开发者通过shell语言实现C/C++三方库快速交叉编译，并在HarmonyOS上快速验证的编译框架工具。


开发者只需要设置对应C/C++三方库的编译方式以及编译参数，通过lycium就能快速的构建出能在HarmonyOS上运行的二进制文件。


本文将以openssl为例，介绍如何通过lycium工具快速编译三方库。


通过lycium工具快速编译三方库


本小节介绍如何在Linux环境下，使用lycium工具通过ohos sdk快速编译openssl三方库源码。


编译环境准备

1.  为简化开发中命令的配置，针对arm架构以及aarch64架构集成了几个编译命令，存放在lycium/Buildtools目录下。在使用lycium工具前，需要将这些编译命令拷贝到SDK对应的目录下，具体操作如下：

```less
owner@ubuntu:/mnt/e$ export OHOS_SDK=/xxx/ohos-sdk/linux # 此处SDK的路径需要开发者配置成自己的sdk解压目录
```


```less
owner@ubuntu:/mnt/e$ export OHOS_SDK=/xxx/ohos-sdk/linux # 此处SDK的路径需要开发者配置成自己的sdk解压目录
```

2.  为简化开发中命令的配置，针对arm架构以及aarch64架构集成了几个编译命令，存放在lycium/Buildtools目录下。在使用lycium工具前，需要将这些编译命令拷贝到SDK对应的目录下，具体操作如下：

```less
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master$ cd lycium/Buildtools # 进入到工具包目录
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master/lycium/Buildtools$ sha512sum -c SHA512SUM # 可校验工具包是否正常, 若输出"toolchain.tar.gz: OK"则说明工具包正常，否则说明工具包异常，需重新下载
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master/lycium/Buildtools$ tar -zxvf toolchain.tar.gz # 解压拷贝编译工具
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master/lycium/Buildtools$ cp toolchain/* ${OHOS_SDK}/native/llvm/bin # 将命令拷贝到工具链的native/llvm/bin目录下
```


```less
owner@ubuntu:/mnt/e$ export OHOS_SDK=/xxx/ohos-sdk/linux # 此处SDK的路径需要开发者配置成自己的sdk解压目录
```

1.  为简化开发中命令的配置，针对arm架构以及aarch64架构集成了几个编译命令，存放在lycium/Buildtools目录下。在使用lycium工具前，需要将这些编译命令拷贝到SDK对应的目录下，具体操作如下：

```less
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master$ cd lycium/Buildtools # 进入到工具包目录
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master/lycium/Buildtools$ sha512sum -c SHA512SUM # 可校验工具包是否正常, 若输出"toolchain.tar.gz: OK"则说明工具包正常，否则说明工具包异常，需重新下载
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master/lycium/Buildtools$ tar -zxvf toolchain.tar.gz # 解压拷贝编译工具
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master/lycium/Buildtools$ cp toolchain/* ${OHOS_SDK}/native/llvm/bin # 将命令拷贝到工具链的native/llvm/bin目录下
```


编译三方库

1.  lycium框架提供了HPKBUILD文件供开发者对相应的C/C++三方库的编译配置。 每个编译脚本都需要按照该规则定义相应的变量以及对应的5个函数，其中变量标明必填的，需要根据库信息正确填写，否则会导致编译失败。 填写示例参考如下： openssl的编译构建方式是configure编译构建，configure交叉编译是需要配置host类型，且需要配置对应的环境变量，框架中集成了环境变量设置的接口，封装在envset.sh中，因此除了基本信息外，还需要定义一个host变量以及导入envset.sh文件，基本变量配置参考如下： 在prepare()函数中创建编译目录，配置对应架构的环境变量： build()函数使用configure命令生成Makefile并执行make指令： openssl测试时需要单独通过编译目标depend生成测试用例，因此需要修改对应的check()函数。在check函数中执行make depend，并在执行完后清理对应的环境变量，以及在该函数后面通过注释说明该库在设备上的测试方法。 package()和cleanbuild()函数，使用模板默认的即可。

```less
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master/thirdparty$ mkdir openssl
```


```less
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master/thirdparty$ mkdir openssl
```


```less
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master/thirdparty$ cp /xxx/tpc_c_cplusplus-master/lycium/template/HPKBUILD openssl
```

2.  每个编译脚本都需要按照该规则定义相应的变量以及对应的5个函数，其中变量标明必填的，需要根据库信息正确填写，否则会导致编译失败。 填写示例参考如下： openssl的编译构建方式是configure编译构建，configure交叉编译是需要配置host类型，且需要配置对应的环境变量，框架中集成了环境变量设置的接口，封装在envset.sh中，因此除了基本信息外，还需要定义一个host变量以及导入envset.sh文件，基本变量配置参考如下： 在prepare()函数中创建编译目录，配置对应架构的环境变量： build()函数使用configure命令生成Makefile并执行make指令： openssl测试时需要单独通过编译目标depend生成测试用例，因此需要修改对应的check()函数。在check函数中执行make depend，并在执行完后清理对应的环境变量，以及在该函数后面通过注释说明该库在设备上的测试方法。 package()和cleanbuild()函数，使用模板默认的即可。

```less
pkgname=NAME # 库名(必填)
pkgver=VERSION # 库版本(必填)
source="https://downloads.sourceforge.net/$pkgname/$pkgname-$pkgver.tar.gz" # 库源码下载链接(必填)
buildtools= # 编译方法, 暂时支持cmake, configure, make等, 根据三方库的编译构建方式填写.(必填)
builddir= # 源码压缩包解压后目录名(必填)
# 省略部分配置项
# 编译前准备工作，如设置环境变量，创建编译目录等
prepare() {
}


# 执行编译构建的命令
build() {
}


# 安装打包
package() {
}


# 测试
check() {
}


# 清理环境
cleanbuild() {
}
```

3.  配置完三方库的编译方式参数后，在lycium目录执行./build.sh openssl（openssl即为创建的目录名称），进行自动编译三方库，并打包安装到当前目录的usr/pkgname/ARCH目录（pkgname为三方库名称，ARCH为架构名称）。 当未报错且日志打印ALL JOBS DONE!!!时，表示三方库编译成功。

```less
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master/lycium$ ./build.sh openssl # 默认编译thirdparty目录下的库
Build OS linux
OHOS_SDK=/mnt/e/ohos-sdk/linux
CLANG_VERSION=15.0.4
Build openssl OpenSSL_1_1_1u start!
  % Total % Received % Xferd Average Speed     Time    Time     Time Current
                             Dload  Upload    Total    Spent     Left Speed
100   222 0      222 0     0   457       0 --:--:-- --:--:-- --:--:--   456
100 11.3M 0    11.3M 0     0  958k       0 --:--:-- 0:00:12  --:--:-- 1802k
Compile HarmonyOS armeabi-v7a openssl OpenSSL_1_1_1u libs...
# 省略部分编译信息
ALL JOBS DONE!!!
```

4.  编译成功后进入lycium/usr目录下，可查看编译生成的文件。

```less
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master/thirdparty$ mkdir openssl
```


```less
owner@ubuntu:/mnt/e/tpc_c_cplusplus-master/thirdparty$ cp /xxx/tpc_c_cplusplus-master/lycium/template/HPKBUILD openssl
```

1.  每个编译脚本都需要按照该规则定义相应的变量以及对应的5个函数，其中变量标明必填的，需要根据库信息正确填写，否则会导致编译失败。 填写示例参考如下： openssl的编译构建方式是configure编译构建，configure交叉编译是需要配置host类型，且需要配置对应的环境变量，框架中集成了环境变量设置的接口，封装在envset.sh中，因此除了基本信息外，还需要定义一个host变量以及导入envset.sh文件，基本变量配置参考如下： 在prepare()函数中创建编译目录，配置对应架构的环境变量： build()函数使用configure命令生成Makefile并执行make指令： openssl测试时需要单独通过编译目标depend生成测试用例，因此需要修改对应的check()函数。在check函数中执行make depend，并在执行完后清理对应的环境变量，以及在该函数后面通过注释说明该库在设备上的测试方法。 package()和cleanbuild()函数，使用模板默认的即可。

```less
pkgname=NAME # 库名(必填)
pkgver=VERSION # 库版本(必填)
source="https://downloads.sourceforge.net/$pkgname/$pkgname-$pkgver.tar.gz" # 库源码下载链接(必填)
buildtools= # 编译方法, 暂时支持cmake, configure, make等, 根据三方库的编译构建方式填写.(必填)
builddir= # 源码压缩包解压后目录名(必填)
# 省略部分配置项
# 编译前准备工作，如设置环境变量，创建编译目录等
prepare() {
}


# 执行编译构建的命令
build() {
}


# 安装打包
package() {
}


# 测试
check() {
}


# 清理环境
cleanbuild() {
}
```


应用中集成使用三方库

1.  为更好管理应用集成的三方库，需要在应用工程的cpp目录新建一个thirdparty目录，将生成的二进制文件以及头文件拷贝到该目录下。 如下图所示，xxx代表三方库名称，xxx文件夹下包含了aarch64架构以及arm架构两种方式生成的二进制文件，每种架构目录下包含了该库的头文件目录include以及二进制文件目录lib。 如果三方库二进制文件为so文件，还需要将so文件拷贝到工程目录的entry/libs/${OHOS_ARCH}/目录下，如下图： 动态库引用注意事项： 拷贝方法：不通过压缩直接将so文件拷贝到windows，或将so文件压缩成.zip格式拷贝到windows，正确拷贝so文件后，so文件大小应该与原库实体文件大小一致。 如果将so文件以tar、gz、7z、bzip2等压缩方式拷贝到windows后在解压，其文件是实体库的软连接，大小和实体库大小不一致，文件也不能正常使用。
2. 
3.  拷贝方法：不通过压缩直接将so文件拷贝到windows，或将so文件压缩成.zip格式拷贝到windows，正确拷贝so文件后，so文件大小应该与原库实体文件大小一致。 如果将so文件以tar、gz、7z、bzip2等压缩方式拷贝到windows后在解压，其文件是实体库的软连接，大小和实体库大小不一致，文件也不能正常使用。
4.  配置链接只需要在cpp目录的CMakeLists.txt文件中添加对应target_link_libraries即可（动态库链接和静态库链接，只需填写一个）。

```less
target_link_libraries(entry PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/thirdparty/xxx/${OHOS_ARCH}/lib/libxxx.a)
```


```less
target_link_libraries(entry PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/thirdparty/xxx/${OHOS_ARCH}/lib/libxxx.a)
```


```less
target_link_libraries(entry PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/thirdparty/xxx/${OHOS_ARCH}/lib/libxxx.so)
```

5.  在cpp目录的CMakeLists.txt文件中添加对应target_include_directories即可：

```less
target_include_directories(entry PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/thirdparty/xxx/${OHOS_ARCH}/include)
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153224.64956224171591636826074825316046:50001231000000:2800:878887390D6281BC6945E9E838CC100344CAE3B0C42D5E4A180D4C9106C22725.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153224.11959043907655681359962179432482:50001231000000:2800:73193423431EA9C3E4C66E075AB295DCC42C47EF77F8D525BF659B51E81FD350.png)
1. 
2.  拷贝方法：不通过压缩直接将so文件拷贝到windows，或将so文件压缩成.zip格式拷贝到windows，正确拷贝so文件后，so文件大小应该与原库实体文件大小一致。 如果将so文件以tar、gz、7z、bzip2等压缩方式拷贝到windows后在解压，其文件是实体库的软连接，大小和实体库大小不一致，文件也不能正常使用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153224.80440511454958134904836566983640:50001231000000:2800:5EDDCEEE4574EB452187619122AD3E2D9C85B4C2A2EF6DE052F54CF874221EF4.png)

```less
target_link_libraries(entry PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/thirdparty/xxx/${OHOS_ARCH}/lib/libxxx.a)
```


```less
target_link_libraries(entry PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/thirdparty/xxx/${OHOS_ARCH}/lib/libxxx.so)
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153224.72253007037359468282461024646977:50001231000000:2800:765C3EB26009CB2DC2721EAF5522ACA4F37C245464398B28C6F21007440D73FE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153225.47823888227793822582052627683488:50001231000000:2800:42E916D04DAE082E7131A4FCB8E52656736F8D32B5D15893A867186DD0B5EC0F.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-custom-hvigor-plugin
爬取时间: 2025-05-08 03:38:24
来源: Huawei Developer


概述


在进行编译构建的过程中，开发者可以通过定制hvigor插件，扩展构建逻辑，实现个性化的打包流程。


定制hvigor插件，通常有以下目的：

-  每个项目可能有独特的构建需求和流程，定制插件可以根据项目的具体要求来扩展hvigor构建的功能。
-  定制插件可以将某些复杂的构建逻辑封装在同一个地方，使得项目的构建配置更加清晰和易于维护。可以自动化执行某些特定任务，减少手动干预，确保构建过程的一致可靠。
-  在团队开发中，定制插件可以确保所有团队成员使用相同的构建流程和标准，减少因个人配置差异导致的问题，从而提升团队协作的效率。

具体到应用场景上，定制插件可以根据不同的构建需求调整编译产物属性，从而实现灵活的构建管理。


本文以自定义编译产物的文件名及路径为案例来介绍如何定制hvigor插件。


基本概念


定制hvigor插件开发时，涉及以下概念：

- hvigor：基于TS实现的构建任务编排工具，主要提供任务管理机制，包括任务注册编排、工程模型管理、配置管理等关键能力。
- hvigor-ohos-plugin：hvigor默认提供的构建插件，利用hvigor的任务编排机制实现应用/元服务构建任务流的执行，完成HAP/App的构建打包，应用于应用/元服务的构建。
- Task：即构建任务，作为hvigor构建过程中的基本工作单元，构建项目的具体工作由Task描述表达，比如源码编译任务，打包任务或签名任务等。每一种任务的执行逻辑由plugin插件提供。
- 编译产物：即工程/模块编译后的目标，是项目打包生成的用于依赖或运行的包文件，包括HAP（应用安装运行的基本单位）、HAR（静态共享包）、HSP（动态共享包）以及App（可上架的完整应用程序）等多种类型。

实现原理


定制hvigor插件，就是在编译构建的过程中插入开发者需要的自定义任务，将这些自定义任务抽象后封装成可复用的部分，通过输出plugin插件的目标形式，实现编译构建个性化逻辑的复用和共享分发。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153225.29464843211842369381995249650290:50001231000000:2800:472944B129D310DB073C7D4FADAE8D3D2FD5F33F69EA78FA93670DFC52BE9F87.png)

如上图所示，hvigor插件的工作原理：


开发流程


hvigor主要提供了两种方式以实现插件的开发：

- 基于hvigorfile脚本开发
- 基于typescript项目开发

两种方式的核心逻辑实现类似，都是以TS文件编写Task任务方法，区别主要在共享和应用方式上。


二者对比如下：


|    | 插件项目  | 代码开发  | 共享方式  | 插件使用  | 特点总结  |
| --- | --- | --- | --- | --- | --- |
| 基于hvigorfile脚本  | 不创建项目  | 直接编辑工程/模块中hvigorfile.ts文件  | 不发布，复制代码实现共享  | 代码逻辑直接应用于编辑工程/模块  | 开发使用快速；共享复用不方便  |
| 基于typescript项目  | 新建npm项目  | 新建custom-plugin.ts文件  | npm打包发布共享，或离线包共享  | hvigor-config.json5中配置插件依赖，或安装离线包  | 易于分发、共享和维护；发布使用流程相对多  |

插件项目


代码开发


共享方式


插件使用


特点总结


基于hvigorfile脚本


不创建项目


直接编辑工程/模块中hvigorfile.ts文件


不发布，复制代码实现共享


代码逻辑直接应用于编辑工程/模块


开发使用快速；共享复用不方便


基于typescript项目


新建npm项目


新建custom-plugin.ts文件


npm打包发布共享，或离线包共享


hvigor-config.json5中配置插件依赖，或安装离线包


易于分发、共享和维护；发布使用流程相对多


下文的场景实例采用基于typescript项目开发的方法描述，开发者也可以将插件逻辑代码直接写于hvigorfile.ts中，切换为基于hvigorfile脚本开发的实现方式。


定制hvigor插件涉及的相关能力，可查阅扩展构建API。


自定义编译产物的文件名及路径


场景描述


以名为library的module生成HAR包为例，默认情况下，HAR包编译产物的生成路径在library/build/default/outputs/default目录下，文件名为library.har。


而开发者在用于生产的环境中，可能需要根据项目情况，使编译产物输出到指定路径，并更改其文件名，例如：带有版本号的文件名，或带有开发者名称等信息的文件名。


下面示例中用oh-package.json5中配置的属性修改HAR包文件名，同时将生成路径改为library/build/default/outputs/target。


开发步骤

1. 

```typescript
import fs from 'fs'


interface OhPackage {
    name: string;
    version: number;
    description: string;
    author: string;
}


export function renameHarTask(str?: string) {
    return {
        pluginId: 'RenameHarTaskID',
        apply(pluginContext) {
            pluginContext.registerTask({
                // 编写自定义任务
                name: 'renameHarTask',
                run: (taskContext) => {
                    // 读取oh-package.json5，解析出version
                    const packageFile = taskContext.modulePath+'\\oh-package.json5';
                    console.log('file: ', packageFile);
                    let fileContent = fs.readFileSync(packageFile, 'utf8');
                    console.log(fileContent);
                    const content: OhPackage = JSON.parse(fileContent);
                    const version = content.version;
                    const author = content.author;


                    console.log('renameHarTask: ', taskContext.moduleName, taskContext.modulePath);
                    const sourceFile = taskContext.modulePath + '\\build\\default\\outputs\\default\\' + taskContext.moduleName + '.har';
                    const targetPath = taskContext.modulePath + '\\build\\default\\outputs\\target\\';
                    const targetFile = targetPath
                        + taskContext.moduleName + '-' + version + '-' + author +'.har';
                    console.log('renameHarTask: sourceFile: ', sourceFile);
                    console.log('renameHarTask: targetFile: ', targetFile);


                    // 创建目录
                    fs.mkdir(targetPath, { recursive: true }, (err) => {
                        if (err) throw err;
                        // 移动并修改产物文件名
                        fs.rename(sourceFile, targetFile, (err)=> {
                            console.log('err: ' + err);
                        });
                    });
                },
                // 确认自定义任务插入位置
                dependencies: ['default@PackageHar'],
                postDependencies: ['assembleHar']
            })
        }
    }
}
```

2. 
3. 

```less
import { harTasks } from '@ohos/hvigor-ohos-plugin';
import { renameHarTask } from 'custom-plugin';


export default {
    system: harTasks,
    plugins:[renameHarTask()] // 应用自定义插件
}
```

4. 
- 发布插件：插件遵循npm发布规范，将其打包后发布到公共或自建的镜像仓库中。
- 共享离线包：将插件工程压缩打包后分享出去。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153225.08801485780415672185988039578740:50001231000000:2800:0392EBC343EFDCCA1D83C1029BA31016F8AD8A8AF27F807F7016FEE17CE07AFA.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-target
爬取时间: 2025-05-08 03:38:33
来源: Huawei Developer


概述


多目标产物在HarmonyOS系统中的应用主要体现在软件开发与分发方面，特别是针对不同用户群体、不同业务场景的需求进行定制化开发。多目标产物为开发者提供了更加灵活和高效的开发方式，使得应用能够更好地适应市场需求和变化。通过定制化开发，还可以更好地满足用户的个性化需求，提升用户体验。


基本概念

- target：对应HAR、HSP、HAP的多目标产物。工程内的每一个模块可以定义多个target，每个Target对应一个定制的HAP、HAR包，通过配置可以实现一个模块构建出不同的HAP、HAR包。
- product：对应App的多目标产物。一个HarmonyOS工程的构建产物为App包，一个工程可以定义多个product，每个product对应一个定制化应用包，通过配置可以实现一个工程构建出多个不同的应用包。

在构建过程中，鸿蒙构建系统会根据配置文件中定义的product和target信息，生成相应的构建产物。对于每个target，构建系统会生成一个对应的HAP/HSP/HAR。这个HAP/HSP/HAR包含了该target所需的所有代码和资源。对于每个product，构建系统会生成一个包含了其所有依赖的target的App包。这个App包可以用于发布和上架到应用市场。


应用场景


主要应用场景:

- 不同用户群体：针对不同的用户群体（如国内用户与国际用户等），HarmonyOS系统支持构建不同的应用版本。这些版本在功能、界面、语言等方面可能有所不同，以满足不同用户群体的需求。
- 不同业务场景：在不同的业务场景中，同一个应用可能需要提供不同的功能或资源。例如，一个在线教育应用可能需要为学生提供学习资料，而为教师提供教学资料。HarmonyOS系统支持通过配置不同的Target来实现这种差异化定制。

针对以上场景，开发者需要通过修改build-profile.json5、module.json5等配置文件，定义出不同的product和target。在这些配置文件中，开发者不仅可以为每个target指定不同的设备类型、源码集、资源等，并且还可以根据业务需要为不同的product分配不同的target。然后在构建过程中，构建工具会根据这些配置生成不同的target，然后通过不同的target搭配构建出不同的product产物。


本文将通过一个具体的案例来介绍如何配置不同资源以及如何构建出多目标产物。


实现原理


HarmonyOS多目标产物支持HAP（应用安装的基本单位，每个HAP都对应一个应用模块）、HAR（静态共享包）、HSP（动态共享包）以及App（由多个HAP打包一起上架的完整应用程序）包多种类型的包，以满足不同业务场景下的应用开发和定制需求。


多目标产物定制项


目前多目标产物支持的定制项信息如下表所示，表中已给出每一项的作用。详细的每一个定制项的配置方法可以参考：配置多目标产物。


| 多目标模块  | 定制项  | 作用  |
| --- | --- | --- |
| HAP  | HAP包名（artifactName）  | 产品生成的应用包名称，可由数字、英文字母、中划线、下划线和英文句号（.）组成，支持输入版本号。  |
| 设备类型（deviceType）  | 用于配置支持的设备类型，如Phone、Tablet等。  |
| 源码集（source）  | target的源码范围： pages：定制pages源码目录的page页面，数组长度至少为1。sourceRoots：定制差异化代码空间，数组长度至少为1。  |
| 资源（resource）  | 配置需要的资源文件路径，支持配置多个资源文件路径。  |
| 分发规则（distributionFilter）  | 针对多target存在相同设备类型deviceType的场景，相同设备类型的target需要指定分发规则distributionFilter。  |
| 产物分包（preloads）  | 对于元服务，每一个target均可以指定preloads的分包。  |
| abilities能力项（icon、label和launchType）  | 定制产物图标、名称、启动模式。  |
| so库依赖（nativeLib-filter）  | 定制打包so库的过滤规则。  |
| HAR/HSP  | 设备类型（deviceType）  | 用于配置支持的设备类型，如Phone、Tablet等。  |
| so库依赖（nativeLib-filter）  | 定制打包so库的过滤规则。  |
| 源码集（source）  | target的源码范围： pages：定制pages源码目录的page页面，数组长度至少为1。sourceRoots：定制差异化代码空间，数组长度至少为1。  |
| 资源（resource）  | 配置需要的资源文件路径，支持配置多个资源文件路径。  |
| App  | App包名和供应商名称(artifactName、vendor)  | 指定产物命名和供应商名称。  |
| bundleName  | 定义工程的bundleName信息，在签名的时候可以选择对应的bundleName进行签名。如果product未定义bundleName，则采用工程默认的bundleName。  |
| bundleType  | 定义产物类型： bundleType值为app，表示产物为应用；bundleType值为atomicService，表示产物为元服务。  |
| 签名配置信息(signingConfig)  | 为不同产物定制不同的签名文件。  |
| 应用图标、名称（icon、label）  | 为不同产物定制不同的图标和名称。  |
| 依赖的模块（modules）  | 定义product中包含的target，每个product可以指定一个或多个target。  |

多目标模块


定制项


作用


HAP


HAP包名（artifactName）


产品生成的应用包名称，可由数字、英文字母、中划线、下划线和英文句号（.）组成，支持输入版本号。


设备类型（deviceType）


用于配置支持的设备类型，如Phone、Tablet等。


源码集（source）


target的源码范围：

- pages：定制pages源码目录的page页面，数组长度至少为1。
- sourceRoots：定制差异化代码空间，数组长度至少为1。

资源（resource）


配置需要的资源文件路径，支持配置多个资源文件路径。


分发规则（distributionFilter）


针对多target存在相同设备类型deviceType的场景，相同设备类型的target需要指定分发规则distributionFilter。


产物分包（preloads）


对于元服务，每一个target均可以指定preloads的分包。


abilities能力项（icon、label和launchType）


定制产物图标、名称、启动模式。


so库依赖（nativeLib-filter）


定制打包so库的过滤规则。


HAR/HSP


设备类型（deviceType）


用于配置支持的设备类型，如Phone、Tablet等。


so库依赖（nativeLib-filter）


定制打包so库的过滤规则。


源码集（source）


target的源码范围：

- pages：定制pages源码目录的page页面，数组长度至少为1。
- sourceRoots：定制差异化代码空间，数组长度至少为1。

资源（resource）


配置需要的资源文件路径，支持配置多个资源文件路径。


App


App包名和供应商名称(artifactName、vendor)


指定产物命名和供应商名称。


bundleName


定义工程的bundleName信息，在签名的时候可以选择对应的bundleName进行签名。如果product未定义bundleName，则采用工程默认的bundleName。


bundleType


定义产物类型：

- bundleType值为app，表示产物为应用；
- bundleType值为atomicService，表示产物为元服务。

签名配置信息(signingConfig)


为不同产物定制不同的签名文件。


应用图标、名称（icon、label）


为不同产物定制不同的图标和名称。


依赖的模块（modules）


定义product中包含的target，每个product可以指定一个或多个target。


综上所述，App、HAP、HAR、HSP包目前并不支持配置所有配置项的差异化定制，开发者在开发过程中需要根据已支持的配置项合理的进行多目标定制。


构建原理图

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153225.30025103477910497165499500524372:50001231000000:2800:02476625DD622B5391D0EBB4620B8F0B53443C7CCBDA11EB169047BACF7738D0.png)

如图所示，在HarmonyOS应用开发过程中，一个应用通常包含多个HAR/HAP/HSP模块。每个HAR/HAP/HSP模块可以通过配置模块级的build-profile.json文件定义多个target，每个target可以定制不同的资源（具体可参考上文定制项介绍）。因此形成了具有差异性的target，如：Module A通过定制生成了TargetA-1、TargetA-2；Module B通过定制生成了TargetB-1、TargetB-2、TargetB-3；Module C通过定制生成了TargetC-1、TargetC-2。然后通过配置工程级的build-profile.json定义多个product，每个product可以依赖不同的Target并且配置不同的App产物定制项。因此形成了具有差异的product，如：依赖TargetA-1、TargetB-1、TargetC-1构建出App-product1；依赖TargetB-3、TargetC-2构建出App-product2。最终在构建工程时选择相应的product就可以显示出对应的定制效果。


开发流程


场景案例


本节主要根据一个案例介绍构建多目标产物的流程和方法，该案例可以由同一套源代码构建出Official版本（官方版）和Test版本（测试版）两个product工程。两个工程的实现效果如下：


Official版本：工程会在首页中显示Official版的资源以及一个页面跳转按钮，该页面是一个HAP模块页面。通过点击按钮可以跳转到Official版定制页面，该页面是一个HAR模块页面，其中包含了一个运算器。该运算器支持加法和减法。


Test版本：工程会在首页中显示Test版的资源以及一个页面跳转按钮，该页面是一个HAP模块页面。通过点击按钮可以跳转到Test版定制页面，该页面是一个HAR模块页面，其中包含了一个普通版的运算器。该运算器仅支持减法。


该案例包含了HAP、HAR、APP相关定制项，具体差异项信息如下：


| 定制模块  | Official版本定制项  | Test版本定制项  |
| --- | --- | --- |
| HAP模块(target)  | target名称officialsource源码集-pages资源文件目录source源码集-sourceRoots  | target名称testsource源码集-pages资源文件目录source源码集-sourceRoots  |
| HAR模块(target)  | target名称officialbuildProfileFields自定义参数产物名称source源码集-sourceRoots资源文件目录剔除的.so文件  | target名称testbuildProfileFields自定义参数产物名称source源码集-sourceRoots资源文件目录  |
| App工程（product）  | product名称official产物bundleName签名配置信息应用图标依赖的target  | product名称official产物bundleName签名配置信息应用图标依赖的target  |

定制模块


Official版本定制项


Test版本定制项


HAP模块(target)


HAR模块(target)


App工程（product）

1.  首先，根据上面案例设计和定制项表格可以确认我们需要定制两个product版本，即Official版本和Test版本。每个product需要依赖两个模块，即一个HAP模块和一个HAR模块。
2.  HAP模块：在模块级build-profile.json5文件中配置。 上述配置文件代码中，配置了official版本与test版本的target名称、source源码集-pages、source源码集-sourceRoots以及资源文件路径，因此我们需要在对应的目录结构下创建我们配置的文件以及目录。针对以上配置信息，我们需要创建pages目录下的Index.ets文件、src目录下的test_pages和official_pages目录以及src/main目录下的resource_test和resource_official目录。 在配置不同target的资源文件目录时，可以配置多个资源文件目录，建议将共有的资源文件放置到默认的资源文件目录中，将有差异的资源部分放置到定制的资源文件目录中，然后在配置资源目录时将默认的资源目录和定制的资源目录都加上。例如：案例中即给不同版本配置了两个资源目录，一个用于存放共有资源，一个存放不同target的差异性资源。 如果target引用的多个资源文件目录下，存在同名的资源，则在构建打包过程中，将按照配置的资源文件目录顺序进行选择。例如，上述official版target引用的资源中，resource_official和resource中存在同名的资源文件，则resource_official中的资源会被打包到HAP中。 * 配置文件中，default为创建工程时默认生成的target，一般无需特殊处理。 HAR模块：在模块级build-profile.json5文件中配置。 上述配置文件代码中，配置了official版本与test版本的target名称、buildProFields自定义参数、产物名称、source源码集-sourceRoots以及资源文件目录，并且在official版本中剔除了无需打包的.so文件。同样的，我们也需要创建我们需要的文件目录，因此我们需要在该HAR模块的src/main/目录下创建resources_test和resources_official文件夹，在src/目录下创建official_pages和test_pages文件夹。

```less
 "targets": [
   {
     "name": "official",                             // target名称official
     "source": {
       "pages": [
         "pages/Index"                               // source源码集-pages
       ],
       "sourceRoots": [
         "./src/official_pages"                      // source源码集-sourceRoots
       ]
     },
     "resource": {
       "directories": [
         "./src/main/official/resources",            // 资源文件目录，用于存放差异性资源
         "./src/main/resources"                      // 用于存放共有资源
       ]
     }
   },
   {
     "name": "test",                                 // target名称test
     "source": {
       "pages": [
         "pages/Index"                               // source源码集-pages
       ],
       "sourceRoots": [
         "./src/test_pages"                          // source源码集-sourceRoots
       ]
     },
     "resource": {
       "directories": [
         "./src/main/test/resources",                // 资源文件目录，用于存放差异性资源
         "./src/main/resources"                      // 用于存放共有资源
       ]
     }
   },
 ]
```

3.  App工程：在工程级build-profile.json5文件中配置。 在该配置文件中，配置了product名称、产物bundleName、签名配置信息、应用图标、依赖的target信息。这里需要注意的是，依赖的HAR模块需要在引用他的模块内配置依赖关系。我们的案例是在entry模块里调用的HAR包，所以需要在其对应的oh-package.json5文件中配置dependencies依赖。

```less
{
  "app": {
    "signingConfigs": [],
    "products": [
      {
        "name": "official",                               // product名称official
        "compatibleSdkVersion": "5.0.0(12)",
        "runtimeOS": "HarmonyOS",
        "buildOption": {
          "strictMode": {
            "caseSensitiveCheck": true,
            "useNormalizedOHMUrl": true
          }
        },
        "bundleName": "com.official.com",                 // 产物bundleName
        "bundleType": "app",
        "icon": "$media:startIcon",
        "label": "$string:official_app_name"              // 应用名称
      },
      {
        "name": "test",                                   // product名称test
        "compatibleSdkVersion": "5.0.0(12)",
        "runtimeOS": "HarmonyOS",
        "buildOption": {
          "strictMode": {
            "caseSensitiveCheck": true,
            "useNormalizedOHMUrl": true
          }
        },
        "bundleName": "com.test.com",                     // 产物bundleName
        "bundleType": "app",
        "icon": "$media:app_icon",
        "label": "$string:test_app_name"                  // 应用名称
      },
      {
        "name": "default",
        "compatibleSdkVersion": "5.0.0(12)",
        "runtimeOS": "HarmonyOS",
      }
    ],
    "buildModeSet": [
      {
        "name": "debug",
      },
      {
        "name": "release"
      }
    ]
  },
  "modules": [
    {
      "name": "entry",
      "srcPath": "./entry",
      "targets": [
        {
          "name": "official",
          "applyToProducts": [
            "official"                                    // HAP-target official依赖于product official
          ]
        },
        {
          "name": "test",
          "applyToProducts": [
            "test"                                        // HAP-target test依赖于product test
          ]
        }
      ]
    },
    {
      "name": "myhar",
      "srcPath": "./myhar",
      "targets": [
        {
          "name": "official",
          "applyToProducts": [
            "official"                                    // HAR-target official依赖于product official
          ]
        },
        {
          "name": "test",
          "applyToProducts": [
            "test"                                        // HAR-target test依赖于product test
          ]
        }
      ]
    }
  ]
}
```

4.  在上述配置文件中，配置了HAP模块的source源码集-sourceRoots目录，official版本与test版本分别对应src/official_pages和src/test_pages。 分别在对应的sourceRoots目录下创建同名ets文件并创建同名同类型的方法，例如：示例中创建的是VersionInfo.ets文件。添加如下代码： src/official_pages/VersionInfo.ets src/test_pages/VersionInfo.ets 在Index.ets文件中，通过import packageName的方式，省略sourceRoot，可以实现不同target下的差异化构建（ import xxx from '<packageName>/sourceFileName'）。该能力具体可参考：source源码集-sourceRoots配置。 在上述配置文件中，我们配置了HAR模块的资源文件路径，official版本和test版本分别对应src/main/resources_official和src/main/resources_test文件。 分别在对应的资源文件目录下添加同名图片资源和json字符串。例如：示例中分别在资源文件目录下的media文件中放入同名的HarImage.jpg图片（图片内容不同），并在element文件下的string.json中添加同名参数"title_description"（其对应的"value"值不相同）。 在页面中直接引用对应同名资源即可，代码如下： 在先前的案例中，已经介绍了如何在sourceRoot目录配置的差异性代码空间中实现对同名文件中的同名方法的调用。这里主要介绍在不同的target中如何调用不同名的文件中的不同方法。 首先，需要通过配置文件中配置的自定义参数生成相应的BuildProfile.ets文件。上述HAR模块的配置文件中，我们配置了buildProfileFields自定义参数"productName",在official和test版本中分别配置了不同的值"official"和"test"。这样我们构建不同的产物版本就会生成不同的"productName"值，用于在代码工程中区分不同的产物版本。 然后，分别在official和test的对应的sourceRoots目录下创建不同的ets文件，并导出相应的组件。如示例中在HAR模块的src/official_pages目录下创建了OfficialSecondPages.ets并export了一个OfficialSecond组件，然后在src/test_pages目录下创建了TestSecondPages.ets并export了一个TestSecond组件。这两个组件中分别包含了不同的页面信息。 最后在首页中import相应的方法实现跳转逻辑。具体代码如下： 导入方法及组件： 定义页面跳转逻辑：接收到不同的参数值跳转不同页面。 为按钮添加点击属性，并传递自定义参数，用于实现Navigation路由跳转：

```less
export const getName = () => "This is official version."
export const getTitleName = () => $r('app.string.title')
```

5.  在上述配置文件中，配置了HAP模块的source源码集-sourceRoots目录，official版本与test版本分别对应src/official_pages和src/test_pages。 分别在对应的sourceRoots目录下创建同名ets文件并创建同名同类型的方法，例如：示例中创建的是VersionInfo.ets文件。添加如下代码： src/official_pages/VersionInfo.ets src/test_pages/VersionInfo.ets 在Index.ets文件中，通过import packageName的方式，省略sourceRoot，可以实现不同target下的差异化构建（ import xxx from '<packageName>/sourceFileName'）。该能力具体可参考：source源码集-sourceRoots配置。

```less
export const getName = () => "This is official version."
export const getTitleName = () => $r('app.string.title')
```

6.  在上述配置文件中，我们配置了HAR模块的资源文件路径，official版本和test版本分别对应src/main/resources_official和src/main/resources_test文件。 分别在对应的资源文件目录下添加同名图片资源和json字符串。例如：示例中分别在资源文件目录下的media文件中放入同名的HarImage.jpg图片（图片内容不同），并在element文件下的string.json中添加同名参数"title_description"（其对应的"value"值不相同）。 在页面中直接引用对应同名资源即可，代码如下：

```less
TextArea({ text: $r('app.string.title_description') })
  .fontSize(16)
  .width('100%')
  .fontColor('#e6000000')
  .fontWeight(FontWeight.Normal)
  .borderRadius(16)
  .focusable(false)
Image($r('app.media.HarImage'))
  .width('100%')
  .borderRadius(12)
  .padding({ top: 16 })
```

7.  在先前的案例中，已经介绍了如何在sourceRoot目录配置的差异性代码空间中实现对同名文件中的同名方法的调用。这里主要介绍在不同的target中如何调用不同名的文件中的不同方法。 首先，需要通过配置文件中配置的自定义参数生成相应的BuildProfile.ets文件。上述HAR模块的配置文件中，我们配置了buildProfileFields自定义参数"productName",在official和test版本中分别配置了不同的值"official"和"test"。这样我们构建不同的产物版本就会生成不同的"productName"值，用于在代码工程中区分不同的产物版本。 然后，分别在official和test的对应的sourceRoots目录下创建不同的ets文件，并导出相应的组件。如示例中在HAR模块的src/official_pages目录下创建了OfficialSecondPages.ets并export了一个OfficialSecond组件，然后在src/test_pages目录下创建了TestSecondPages.ets并export了一个TestSecond组件。这两个组件中分别包含了不同的页面信息。 最后在首页中import相应的方法实现跳转逻辑。具体代码如下： 导入方法及组件： 定义页面跳转逻辑：接收到不同的参数值跳转不同页面。 为按钮添加点击属性，并传递自定义参数，用于实现Navigation路由跳转：

```less
import BuildProfile from '../../../../BuildProfile';
import { OfficialSecond } from '../../../official_pages/OfficialSecondPage';
import { TestSecond } from '../../../test_pages/TestSecondPage';
```

8.  首先点击DevEco Studio工具右上角的Product按钮，即图中的1号标识处，然后在2号标识处选择对应的product工程，选择完工程之后会自动映射出我们文件中已经依赖的target，最后点击Apply应用。上述操作完成之后就可以点击运行按钮查看多目标产物效果了。本案例运行效果图如下：
-  在上述配置文件中，配置了HAP模块的source源码集-sourceRoots目录，official版本与test版本分别对应src/official_pages和src/test_pages。 分别在对应的sourceRoots目录下创建同名ets文件并创建同名同类型的方法，例如：示例中创建的是VersionInfo.ets文件。添加如下代码： src/official_pages/VersionInfo.ets src/test_pages/VersionInfo.ets 在Index.ets文件中，通过import packageName的方式，省略sourceRoot，可以实现不同target下的差异化构建（ import xxx from '<packageName>/sourceFileName'）。该能力具体可参考：source源码集-sourceRoots配置。

```less
export const getName = () => "This is official version."
export const getTitleName = () => $r('app.string.title')
```

-  在上述配置文件中，我们配置了HAR模块的资源文件路径，official版本和test版本分别对应src/main/resources_official和src/main/resources_test文件。 分别在对应的资源文件目录下添加同名图片资源和json字符串。例如：示例中分别在资源文件目录下的media文件中放入同名的HarImage.jpg图片（图片内容不同），并在element文件下的string.json中添加同名参数"title_description"（其对应的"value"值不相同）。 在页面中直接引用对应同名资源即可，代码如下：

```less
TextArea({ text: $r('app.string.title_description') })
  .fontSize(16)
  .width('100%')
  .fontColor('#e6000000')
  .fontWeight(FontWeight.Normal)
  .borderRadius(16)
  .focusable(false)
Image($r('app.media.HarImage'))
  .width('100%')
  .borderRadius(12)
  .padding({ top: 16 })
```

-  在先前的案例中，已经介绍了如何在sourceRoot目录配置的差异性代码空间中实现对同名文件中的同名方法的调用。这里主要介绍在不同的target中如何调用不同名的文件中的不同方法。 首先，需要通过配置文件中配置的自定义参数生成相应的BuildProfile.ets文件。上述HAR模块的配置文件中，我们配置了buildProfileFields自定义参数"productName",在official和test版本中分别配置了不同的值"official"和"test"。这样我们构建不同的产物版本就会生成不同的"productName"值，用于在代码工程中区分不同的产物版本。 然后，分别在official和test的对应的sourceRoots目录下创建不同的ets文件，并导出相应的组件。如示例中在HAR模块的src/official_pages目录下创建了OfficialSecondPages.ets并export了一个OfficialSecond组件，然后在src/test_pages目录下创建了TestSecondPages.ets并export了一个TestSecond组件。这两个组件中分别包含了不同的页面信息。 最后在首页中import相应的方法实现跳转逻辑。具体代码如下： 导入方法及组件： 定义页面跳转逻辑：接收到不同的参数值跳转不同页面。 为按钮添加点击属性，并传递自定义参数，用于实现Navigation路由跳转：

```less
import BuildProfile from '../../../../BuildProfile';
import { OfficialSecond } from '../../../official_pages/OfficialSecondPage';
import { TestSecond } from '../../../test_pages/TestSecondPage';
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153225.65035318136108124967832709031605:50001231000000:2800:001532EEC4F66E8A0F0164467E6D83903175EFBF313E754ACE7BCAE63F9C918D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153225.75977786309507103048151703467008:50001231000000:2800:7256CB19B5BA68D50A1473F8C513960D734A6481098F73ED13ACF34785FE2F2E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153225.29415577672206035113740594210937:50001231000000:2800:B96CDBBABA72AE386811F7950BA4002884DB715561DA3754FB7552701C96F2BA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153225.30225271064373148728384801143966:50001231000000:2800:B5F777E16A19C7AB302B171DDF5C11F228E147DCCD08242C474886F0938112AB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153225.86516493854438828217598070157606:50001231000000:2800:42D0C98E1714C2F279B1F256312E59BA6762FD3AE6A73595B78D25665423C11E.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153225.16969740193519929632441555703465:50001231000000:2800:46EAA715AAC1D8314760F314D8BE6BC0B4637E78C4A6901997B1577A75DA2AEF.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153225.04692115479979027917207644852982:50001231000000:2800:3E1CE80D41A60BA8E84582ECD43DADB257068180A44A6A0F90DEE9CE477462E5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153225.68358043452260623129851635066051:50001231000000:2800:C1422BFCCB684F266D78992607E420A997AF060C1139CACAF8AD3F6E7FCA1035.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153226.39078008642411199720673128653959:50001231000000:2800:D0220960A6DF210E1B69CAD66FBA6C027A1FE08D70CBEFEF0548034015C25B33.gif)

常见问题


如何为不同的product产物配置签名信息？


配置工程级的build-porfile.json5文件.


首先需要在每个product下添加配置项"signingConfig"。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153226.82695982369994314506342047397380:50001231000000:2800:7FC7887FFA4A9B5F279DC4622183BE34ADDC22CFD1397436A3AA4A7EA200A1A2.png)

然后进入到签名配置页面，点击加号，添加签名信息：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153226.62635390028060753642903189032189:50001231000000:2800:CF6B7E51CEFC7F6910DEB05538EC677DD1B9344675376852E0F26F458649D3E6.png)

然后选择对应的bundle name，并填写上面配置的"signingConfig"信息（每个product产物都需要配置）：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153226.21540534987346005331236025064939:50001231000000:2800:F0D90A4E9AE13D9753FC030D8BFF31B54C0214C4EF7CE1963BC6428CA61A5DF8.png)

点击ok之后，进行签名即可。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507153226.26454469897054190405044691009351:50001231000000:2800:A9BBE0BFC80ADA2614DDFBC2F40BCC15167C2C3362059C4D17811FC2CA25229C.png)

示例代码

- 构建多目标产物工程

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/changelog
爬取时间: 2025-05-08 03:38:42
来源: Huawei Developer


2025年4月30日


新增文档


新增文档3篇，包括特性解决方案、系统和媒体。


特性解决方案

- 轻量级智能穿戴开发实践：介绍了以创建“Hello World”的轻量级智能穿戴应用为例，如何在应用中构建布局、绘制样式、添加组件、绑定事件、实现页面路由跳转等实践。

系统

- 基于SFFT的大文件高速并发传输：介绍了如何使用SFFT进行高效的文件传输。

媒体

- 音频焦点管理解决方案：介绍了系统音频焦点管理机制原理和典型问题场景的解决思路。

2025年3月26日


新增文档


新增文档2篇，包括特性解决方案和应用质量。


特性解决方案

- Pura X外屏开发实践：介绍了如何在应用程序中实现手机分屏功能。包括手机分屏功能的适用场景、实现原理等内容。

应用质量

- 不可见组件低功耗建议：介绍了如何优化应用程序以减少设备功耗的建议和指导。

删除文档


删除文档2篇。


特性解决方案

- 手机上下分屏开发实践：介绍如何在手机上实现应用的分屏显示，包括分屏模式的概念、分屏模式的适配要求、分屏模式的开发流程以及分屏模式的测试方法等内容。

应用质量

- 使用UBSan检测未定义行为：介绍了使用ubsan（Undefined Behavior Sanitizer）进行代码检测的方法和技巧。

2025年2月28日


目录结构变更


变更背景


为了更好地满足开发者在不同阶段的多样化需求，提升开发者的使用体验，对最佳实践目录结构进行了优化调整。最佳实践的目录结构从按照功能领域进行划分，优化为按照开发者旅程的维度进行分类。


无论是初学者还是有经验的开发者，都能够依据自身的开发进程快速定位到所需的最佳实践内容，更加直观地获取全面的指导信息，从而提高开发效率，加速HarmonyOS项目的开发进程。


变更内容


为了提升开发者的使用体验，对最佳实践的目录结构进行优化。


最佳实践结构目录优化调整：全文分为架构设计、功能开发、工具使用和文档变更说明四个类型。为给予开发者更好的文档阅读和使用体验，最佳实践按照架构设计、功能开发和工具使用三大类重新编排目录。变更前后如下图所指示：


变更效果


通过此次变更，实现了以下效果：

- 与开发指南和API文档架构相互对应，使得开发者能够快速定位所需文档位置，提高查找效率。
- 增加业务类型分类，使得最佳实践内容架构更加清晰，可有效降低开发者文档查找混乱，难以查询到所需文档的问题。
- 增加文档变更节点，使开发者可以明确感知到最佳实践文档的所有变更，包括文档新增、下线等，帮助用户了解最佳实践的发展历程。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.28225692930664389728998816228772:50001231000000:2800:BF04C32E7655274B2362200359865940C43E0E2B6CAB916E2808D9B46895E0A7.png)

新增文档


新增文档2篇，包括媒体和文档变更说明。


媒体

- 图片获取与保存实践：介绍HarmonyOS上常见的获取图片的方式、获取后读取图片信息、以及将图片保存在本地的操作。

文档变更说明

- 最佳实践文档变更说明：以月为维度，汇总最佳实践文档更新下架或架构变更信息，提升开发者内容更新感知。

删除文档


删除文档2篇。


应用质量

- 符号表归档：介绍release模式下调试信息文件的归档配置、路径等内容。

应用架构

- 应用导航设计：介绍应用程序导航设计的相关内容。内容涵盖了导航结构的设计、导航元素的选择和布局、导航交互的设计等方面。

2025年1月26日


新增文档


新增60篇文章，包括HarmonyOS特征、业务场景与解决方案、功耗、安全、稳定性和功能开发模块。


HarmonyOS特征

- 一多窗口适配开发实践：介绍因窗口类型及属性的差异产生的问题的说明及解决方案指导。
- Web适配一多开发实践：介绍Web侧如何进行多设备适配，结合Web组件实现在不同设备上的定制体验。
- 一多分级导航栏开发实践：本文提供分级导航栏的多端适配方案及指导，解决一多开发实现导航栏内的分级效果问题。
- 浏览进度接续：介绍如何在长列表进度、媒体播放进度以及Web浏览进度这三个场景，实现浏览进度无缝接续。

业务场景与解决方案

- 手机上下分屏开发实践：介绍如何在手机上实现应用的分屏显示，包括分屏模式的概念、分屏模式的适配要求、分屏模式的开发流程以及分屏模式的测试方法等内容。

功耗

- 应用功耗体验：介绍如何通过优化应用程序的设计和开发，减少应用程序对设备电池的消耗。
- 应用功耗检测与分析：介绍功耗体验指标的CPU耗电量进行检测与分析，帮助开发者降低应用运行时的总耗电量。
- 应用后台运行开发实践：介绍应用切后台各类常见的问题场景及对应解决方案。

安全

- 设备标识使用推荐：介绍设备ID的定义、使用场景、安全性和隐私保护等，以及使用设备ID的最佳实践建议。

稳定性

- 概述：介绍了在软件开发过程中确保稳定性的重要性。包括稳定性的定义、稳定性测试的重要性、稳定性测试的方法和策略等。
- 使用Asan检测内存错误：介绍了ASAN的原理、使用方法、常见的内存错误类型，示例代码和调试技巧。
- 使用HWAsan检测内存错误：介绍了如何使用HWASAN工具来检测和修复应用程序中的内存错误，以提高应用程序的稳定性。
- 使用UBSan检测未定义行为：介绍了使用ubsan（Undefined Behavior Sanitizer）进行代码检测的方法和技巧。
- 使用GWP-Asan检测内存错误：介绍了如何使用GWP-ASan来提高应用程序的稳定性。包括GWP-ASan的原理、使用方法以及示例代码。
- 内存泄漏检测：介绍了稳定性和内存泄漏检测方面的内容。其中包括了稳定性测试的重要性、测试方法和工具，以及如何进行内存泄漏检测和解决内存泄漏问题的技巧和建议。
- 基础内存检测：介绍了在开发过程中如何确保应用程序的稳定性和内存管理的重要性。包括稳定性测试、内存泄漏检测、内存优化等。
- 使用Tsan检测线程问题：介绍了如何提高应用程序的稳定性，并使用Thread Sanitizer（TSAN）工具来检测并解决多线程问题。
- 方舟运行时检测：介绍了如何使用方舟多线程检测应用程序的稳定性，包含详细的步骤和示例代码，帮助开发者了解如何使用方舟多线程检测来提高应用程序的稳定性。
- 使用方舟异常信息增强检测：介绍了在使用方舟时，如何进行异常检测以提高应用程序的稳定性。包括常见的异常类型和处理方法，以及如何使用华为提供的工具来进行异常检测和分析。
- 应用体检：介绍了应用与元服务体检工具（AppAnalyzer）的功能、安装和配置方法，以及如何使用应用与元服务体检工具进行应用程序的稳定性分析和优化。
- 使用DevEco Testing进行稳定性测试：介绍DevEco Testing为HarmonyOS NEXT应用开发者提供的稳定性测试服务，包括稳定性基础质量测试及应用探索测试。
- 故障类型：介绍了在软件开发过程中如何提高系统的稳定性，以及如何识别和处理不同类型的故障。
- 日志规格：介绍了稳定性日志规范的内容。旨在帮助开发者了解如何编写稳定性日志，以便更好地监控和调试应用程序的稳定性问题。
- 地址越界问题排查方法：介绍地址越界问题检测能力、地址越界问题定位分析思路。
- 地址越界问题案例分析：介绍地址越界问题典型案例分析。分别是stack-tag-mismatch（栈溢出）问题和heap-use-after-free问题。
- 资源泄漏问题排查方法：介绍资源泄漏检测能力、泄漏问题定位分析思路。
- 资源泄漏问题案例分析：介绍了在软件开发过程中，如何识别和解决资源泄漏问题，以提高应用程序的稳定性。包含了资源泄漏的定义、常见的资源泄漏类型、资源泄漏的危害以及如何通过代码分析和调试工具来定位和修复资源泄漏问题。
- 应用无响应问题排查方法：介绍了在开发应用程序时，如何应对应用卡顿的问题，以提高应用的稳定性。包含优化UI线程、合理使用异步任务、避免内存泄漏等。
- 应用无响应问题案例分析：介绍了应用程序稳定性的重要性，以及如何通过分析和解决应用程序冻结问题来提高应用程序的稳定性。包括常见的应用程序冻结案例，并给出了相应的解决方案和建议。
- 栈顶在方舟运行时的无响应问题定位实践：介绍如何定位定界栈顶在方舟运行时（libark_jsruntime.so、libace_napi.z.so）的应用无响应freeze问题。
- CppCrash问题排查方法：介绍了关于如何使用C++编程语言来编写稳定的应用程序的指导和建议。涵盖了崩溃原因的分析、崩溃日志的收集和分析、内存管理、异常处理、线程安全等方面的内容。
- CppCrash问题案例分析：本文从信号分类、问题场景分类和维测工具分类三个维度来对CppCrash典型问题进行分析和归纳。
- JS Crash问题排查方法：介绍JS Crash异常捕获场景，JS Crash故障分析思路。
- JS Crash问题案例分析：介绍了现在开发者所遇到的高频的两类JS Crash故障进行案例介绍，包含 TypeError 和 Error 类。
- NDK开发ArkTS侧编码规范：介绍了NDK开发ArkTS侧编码规范，包括import本模块的so和import其它模块的so。
- Node-API开发规范：介绍了在开发过程中如何编写稳定性高的代码，以确保应用程序的可靠性和稳定性，包括错误处理、资源管理、并发编程、日志记录等方面的建议和规范。
- C++编码规范及案例：介绍了使用C++编写稳定性代码的一些建议和规范，包括错误处理、内存管理、并发编程、异常处理、日志记录等。
- libuv使用规范及案例：介绍了稳定性编码规范和libuv库的使用。其中包括了稳定性编码的重要性、稳定性编码的原则和规范、如何使用libuv库来提高应用程序的稳定性等内容。
- 易错API的使用规范：介绍了在开发过程中如何确保代码的稳定性、遵循编码规范以及使用API的最佳实践。
- 使用IDE静态检测编码规范：介绍了在使用IDE进行开发过程中，如何通过静态检测来提高代码的稳定性。
- HiLog打印规范：介绍了什么是稳定性日志，为什么需要使用稳定性日志，以及如何使用HiLog进行日志记录和分析。
- APM能力建设：介绍如何通过HiAppEvent订阅接口采集系统事件。
- 应用事件：介绍如何使用HiAppEvent订阅和触发应用事件。
- 符号表归档：介绍release模式下调试信息文件的归档配置、路径等内容。

功能开发

- 跨模块资源访问：介绍如何实现跨模块访问HAR和HSP里面的资源。
- TaskPool使用规范和常见问题：介绍了什么是任务池，包括任务池的定义、使用场景、使用规范、任务池的创建和销毁、任务的提交和执行、任务池的监控和调优以及常见问题等内容。
- 基于StateStore的全局状态管理开发实践：介绍了全局状态管理和状态存储的相关内容，包括全局状态管理的概念、作用和优势、状态存储的不同方式和使用场景，以及如何选择适合的状态存储方案等内容。
- 图片预览器开发实践：介绍了在开发过程中如何实现高效的图片预览功能，包括使用异步加载和缓存技术来提高图片加载速度，使用合适的图片格式和压缩算法来减小图片文件大小，以及如何处理不同屏幕尺寸和分辨率的适配等内容。
- 页面亮度设置开发实践：介绍了在应用程序中如何设置页面亮度的方法，包括通过使用系统提供的API来控制页面亮度，以提供更好的用户体验和节省电池寿命。
- 常见列表流开发实践：介绍了常见列表流程的最佳实践，包括列表流程的设计原则、列表流程的类型、列表流程的实现方式以及列表流程的性能优化等方面的内容。
- 基于DialogHub的通用弹窗解决方案：介绍了DialogHub解决方案的概述、架构设计、开发流程、技术要点等。
- 长截图开发实践：本文以List组件和Web组件为例来介绍长截图功能的开发，分别通过控制器Scroller和WebviewController，结合组件截图模块componentSnapshot，实现长截图功能。
- 2in1异形窗口开发实践：介绍了在开发应用程序时如何适配2in1设备的窗口形状，以提供更好的用户体验。
- 基于Web页面的视频适配开发实践：介绍了如何在Web应用中实现视频自适应，以提供更好的用户体验。
- 应用网络重连：介绍了如何在移动应用开发中处理网络连接中断和重连。包括网络连接状态的监测、断线重连的策略、错误处理和用户体验优化等方面。
- 低功耗蓝牙开发实践：介绍了基于BLE进行蓝牙扫描管理、蓝牙连接状态管理、蓝牙设备特征值同步三个场景，并分别从服务端和客户端描述其相关实现。
- 基于rcp的文件上传与下载：介绍了如何实现带进度的上传下载、断点续传、后台文件上传下载场景，为开发者提供基于rcp的文件上传与下载的开发实践。
- 基于原生能力获取视频缩略图：介绍了如何使用视频处理服务生成视频缩略图。
- HDRVivid视频录制、播放与转码开发实践：介绍了HDRVivid解决方案的开发指南。包括视频解决方案的架构设计、开发流程、开发工具和技术要点等方面的内容。
- 位置定位开发实践：介绍了位置定位能力的使用方法和技巧，包括位置服务的概述、功能特点、开发流程、API调用示例以及常见问题解答等。

2024年12月27日


新增文档


新增11篇文章，包括HarmonyOS特征、业务场景与解决方案、功耗性能、安全和功能开发模块。


HarmonyOS特征

- 折叠屏悬停态开发实践：介绍折叠屏悬停态的三种实现方式，并根据其特点给出各自的适用场景。包括FoldStack、FoldSplitContainer和自定义实现悬停态。
- 一多交互事件开发实践：介绍一多开发过程中涉及到的常见交互事件，包含系统已提供默认实现的交互归一事件适配，以及需要开发者自行进行设计与代码实现的交互操作：焦点导航事件适配、键盘快捷键事件适配。
- 统一拖拽：介绍几种典型拖拽场景及其具体实现方案，包括拖拽图像增加水印、自定义拖拽背板图、AI识别拖拽内容、分屏拖拽、跨设备拖拽和拖入小艺和中转站。

业务场景与解决方案

- 音乐服务卡片：介绍了以音乐服务卡片场景为例，如何实现音乐播控、歌单推荐、心动歌词三种服务卡片，包括卡片设计和功能开发，以及开发中常见的一些问题。
- 平板和2in1开发实践：介绍开发平板和2in1应用过程中的常见问题，并提供推荐的解决方案或开发指导，以满足用户的最佳体验。

功耗性能

- 高效利用HWC的低功耗设计：介绍如何使系统能够充分发挥HWC的能效优势，降低对应操作场景的功耗，提升操作流畅性。

安全

- 加解密跨平台数据兼容性开发实践：介绍数据编码格式差异以及加解密算法使用差异导致加解密失败的可能原因，并提供相应的解决方案，

功能开发

- 一镜到底动效开发实践：介绍一镜到底的实现原理和两个典型场景案例。
- 卡片更新与数据交互：介绍如何在应用程序中实现卡片更新和数据交互的指导和建议。
- 相机预览花屏解决方案：介绍相机预览花屏的实现原理、场景案例。效果比对和常见问题，并提供相应的示例代码，助力开发者高效解决问题。
- 多线程操作密集型关系型数据库和文件读写：介绍如何使用多线程操作密集型关系型数据库和文件读写，包括TaskPool和Sendable的实现原理和使用方法。

2024年11月27日


性能目录结构优化


变更内容

- 优化“性能分析”章节，拆分部分内容到“性能最佳实践导读”和“性能检查”章节。
- 优化“性能分析”和“性能优化”目录结构，精细化子目录分类。
- 原“常见性能优化场景”章节更名为“性能场景优化案例”，修改文档标题，提升查找的准确性和效率。图2最佳实践性能目录变更对比
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.47210422198914674562674154201873:50001231000000:2800:629F7CE361515EBADC55A8A23944B262D180B7B584AFBB30980D7DDAA0487889.png)

新增文档


新增29篇文章，包括性能、安全、功能开发和工具开发模块。

- 性能最佳实践导读：提供了关于如何优化应用程序性能的实用建议和技巧。包括应用程序启动时间优化、内存管理、网络请求优化、图形渲染优化等。
- 性能检测简介：介绍调优的方法、常用的工具和详细的说明和指导，以帮助开发者了解如何使用这些工具和实践。
- 分析内存占用问题：介绍如何分析内存问题的方法和技巧，以提高应用程序的性能和稳定性。
- 控制渲染范围：介绍在开发过程中如何有效地控制渲染范围，优化应用程序的渲染过程，减少不必要的渲染操作，提高页面加载速度和响应性能。
- 减少布局节点：介绍如何在设计和开发过程中减少布局节点的数量，从而提高应用程序的性能和响应速度。
- 优化组件绘制：介绍如何优化组件绘制的方法和技巧，提高组件绘制的性能和效率。
- 控制状态刷新：介绍状态刷新的基本概念、常见问题和解决方案，助力开发者快速了解如何有效地管理和刷新应用程序的状态，从而提升应用程序的质量和用户满意度。
- 优化动画帧率：介绍如何使用动画帧来创建流畅的动画效果、常见问题的解答和注意事项。通过使用动画帧，开发者可以更好地控制动画的帧率和性能，从而提升用户体验。
- 使用并发能力：介绍如何提高应用程序并发能力的建议和指导，包括使用线程池、异步编程、并发数据结构等技术，使开发者了解如何优化应用程序的性能和响应能力，提高用户体验。
- 提前加载资源：介绍预加载资源的概念、作用以及实施方法。预加载资源可以提高网页的加载速度和用户体验，减少用户等待时间。
- 提高运行效率：介绍如何提高应用程序的运行效率。包括优化代码、减少资源消耗、合理使用内存和存储、优化网络请求等方面的建议和指导。
- 减少耗时操作：介绍如何减少耗时操作的方法，具体内容包括减少网络请求次数、优化代码、使用缓存等。
- 延时触发操作：介绍在开发过程中如何使用延迟触发操作来提高系统的性能和稳定性。
-  应用闪屏问题解决方案：介绍在开发过程中遇到屏幕闪烁问题的原因分析、解决方案的具体步骤和注意事项等。
- 网络连接安全配置开发实践：介绍网络通信和安全方面的内容。包括网络通信的最佳实践，如使用HTTPS协议进行数据传输，使用合适的加密算法保护数据安全，以及优化网络请求等。同时还介绍网络安全的最佳实践，如使用安全的认证和授权机制，防止网络攻击和数据泄露等。
- 桌面快捷方式开发实践：介绍如何创建桌面快捷方式、如何设置快捷方式图标和名称、如何使用快捷方式进行快速访问等内容。
- 跨语言调用复杂参数传递开发实践：介绍如何使用复杂类型传递数据的方法。通过详细的指导和示例，帮助开发者了解如何在应用程序中使用复杂类型进行数据传递。
- Native侧跨HAR/HSP模块接口调用开发实践：介绍Native侧跨HAR/HSP模块调用两种典型场景，包括调用Native方法和调用ArkTS方法，以方便开发者更好的掌握Native侧跨模块调用的能力。
- 三方动态链接库（.so）集成开发实践：介绍动态链接库（Dynamic Link Library，简称DLL）的定义、使用场景、优势以及开发和使用DLL的最佳实践建议。让开发者快速了解如何有效地使用DLL来提高软件的模块化、可维护性和重用性，从而提升开发效率和软件质量。
- Native侧子线程与UI主线程通信开发：介绍Native侧子线程与UI主线程通信开发的两种方案，即如何基于线程安全函数机制实现和基于libuv异步库的uv_async_send方法实现。
- 应用内组件冗余刷新优化指导：介绍冗余刷新的基本概念、冗余刷新的设计原则、冗余刷新的实施步骤以及常见问题和解决方案等。通过阅读该文档，开发者可以了解如何设计和实施一个可靠的冗余刷新系统，以提高系统的稳定性和可用性。
- Grid网格元素拖拽交换开发实践：介绍如何实现Grid网格拖拽交换的技术，如何实现网格拖拽交换功能。
- 沉浸式页面开发实践：介绍沉浸式体验设计原则和方法。包括了沉浸式设计的定义、设计原则、设计方法和实践建议等方面的内容。
- 深色模式适配：介绍如何在应用程序中实现暗黑模式，并提供了一些实用的技巧和建议。涵盖了暗黑模式的定义、适配的重要性、适配的步骤和注意事项等内容。
- 自定义键盘开发实践：介绍关于自定义键盘的详细指导，包括键盘的设计原则、开发流程、代码示例等内容。

开发工具

- 本地数据与文件调试：介绍本地文件和数据调试的方法和技巧。该指南提供了详细的步骤和示例，帮助开发者在本地环境中进行文件和数据的调试工作。
- 定制hvigor插件开发实践：介绍如何使用hvigor插件开发自定义功能，包括插件的基本结构、开发流程、插件的注册和调用等。
- 多目标产物构建开发实践：介绍多目标应用开发的相关内容。包括如何设计和构建多目标应用、如何处理不同目标设备的适配和优化、如何处理多目标应用的资源管理等方面的内容。

优化文档


设备运行效果图优化


本次最佳实践优化内容为最佳实践设备运行效果图优化。对文档中的手机、折叠屏、平板、2in1、智慧屏和手表设备运行效果图进行了整体的优化，均加上了对应的真机机框效果。


前后对比效果如表所示。


| 设备名称  | 优化前  | 优化后  |
| --- | --- | --- |
| 手机  |   |   |
| 折叠屏  |   |   |
| 平板  |   |   |
| 2in1  |   |   |
| 智慧屏  |   |   |
| 手表  |   |   |

设备名称


优化前


优化后


手机

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.31202619767909072270117669536932:50001231000000:2800:6F93C9627B2B026D499FEED9AA239216900488991CBDAE8901808D4AB5DF6ED8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.82875268576848101323635866638697:50001231000000:2800:E81FE3E4650DD2B5AC5937A9500B31137BB289D269B038B9B26CF02ECCCEC395.png)

折叠屏

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.94781095123165459693311649044581:50001231000000:2800:F35E56DF393373E1D610EAF00F9B8012AA09E408B5B7ADE4FB08F5F597014231.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.15469162836636372044811215389794:50001231000000:2800:CAF05FA7A1CE7C79AF5710C3B9F3F6C20D70A702B3A113731CBBB145A2346A42.png)

平板

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.30159188982110708325865290027400:50001231000000:2800:709D251308120F5875E51B8F17B90270A2AC0C80F3285928CA310CBD6F43BF8E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.71576486328039980768303436383497:50001231000000:2800:216C21E9EB88B944FEDFEF29BAD7AA2DAF2EDDA2A8F350652305CB0F5796CDF9.png)

2in1

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.05145112495156883009972446857180:50001231000000:2800:990E99E9B3F8B94DE87C4C3E4BB899AD51976C5412EAEC57EA63A2AC0F5212FE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.74080083649281865648971431764696:50001231000000:2800:E78D98B4AD399E91BCF78C196ED7F69F924F2F1256A925FCDF7D0E9EACA83D9F.png)

智慧屏

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171003.47659370297901890712414256725491:50001231000000:2800:A1D16FB2E4A1797BED9CA7C7551D09FA13E60037CE5FACE7D2284671D911433A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171003.45205396289175613794169241129885:50001231000000:2800:AC0F26439E96973124331F2228982A0776BBE0E48FE4077918F5F77387F3E80A.png)

手表

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171003.90177685961323949914061315302741:50001231000000:2800:844409E55FD9C93218A70CDB32942A056FD71570CC3FA3EF0356D25F541A78CB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171003.96261995619814516681054945430426:50001231000000:2800:D3729C730F3D7450696EB76CA9E21CA895A98C2081EBCC25A531F5F97C782401.png)

删除文档


删除文档2篇。


HarmonyOS特征

- 华为视频接入播控中心和投播实践：部分场景和使用方式过时，已上线新的接续文章应用接续提升内容发布体验。

性能

- 调优工具合集：跟随性能整体结构调整合入到性能手册中。

2024年10月31日


归一化模板


针对系统级解决方案和场景化解决方案进行重新设计。从本期开始，新增的最佳实践内容均会采用新的内容结构进行呈现。存量内容会在后续陆续进行完成优化。


新增文档


新增文档29篇，包括HarmonyOS特征、性能、功耗、安全、功能开发和工具开发。


HarmonyOS特征

- 一多分栏开发实践：介绍如何使用多列布局来创建响应式网页，涵盖了使用CSS Grid和Flexbox等技术来实现多列布局的方法，并提供了一些常见的布局模式和技巧。
- 应用接续提升内容发布体验：介绍在开发应用程序时，如何正确地管理和释放应用程序与其他设备或服务之间的连接，以提高应用程序的性能和稳定性。

性能

- Web加载完成时延分析：介绍Web页面的加载流程及关键Trace点、性能分析工具、加载完成时延分析方法、并总结了常见导致加载完成时延过高的原因与解决方案。
- 优化应用预置图片资源加载耗时问题：介绍纹理压缩的概念、原理和优势，并提供了一些在开发过程中使用纹理压缩的最佳实践建议。通过使用纹理压缩，开发者可以减少纹理资源的大小，提高应用程序的性能和加载速度。

功耗

- 音乐播放场景低功耗规则：介绍在华为设备上实现高质量音乐播放的最佳实践，包括音频焦点管理、音频输出选择、音频格式支持、音频播放控制等方面的内容。
- 导航定位场景低功耗规则：介绍如何实现低功耗的导航场景，包括实现的规则、开发步骤和调测验证。
- 静态场景低功耗规则：介绍如何在静态场景下实现低功耗，包括实现的规则、开发步骤和示例场景。
- 视频场景编解码低功耗规则：介绍如何在视屏场景编解码中实现低功耗，包括实现的规则、开发步骤和调测验证。
- 视频场景弹幕绘制低功耗规则：介绍视频弹幕的最佳实践方法。文档中包含了视频弹幕的定义、特点以及在不同场景下的应用案例。此外，文档还提供了视频弹幕的实现步骤和技术要点，帮助开发者更好地理解和应用视频弹幕技术。
- 视频场景ROM低功耗建议：介绍视频场景ROM（Read-Only Memory）如何实现低功耗的建议，包括设计原则、开发流程、测试。
- 视频场景图层低功耗建议：介绍视频场景图层功能如何实现低功耗的建议，包括设计原则、开发流程、测试。
- 视频场景Wi-Fi加载低功耗建议：介绍视频场景Wi-Fi加载功能如何实现低功耗的建议，包括开发流程和调测验证。
- 网络资源低功耗建议：介绍网络资源下载如何实现低功耗的建议和开发流程。

安全

- 应用权限申请开发实践：介绍在开发过程中如何正确处理和申请权限，以确保应用程序的安全性和用户体验。

功能开发

- 应用间跳转场景开发实践：介绍ArkTS页面拉起已安装应用的相关场景，包括拉起指定应用、拉起指定应用并获取返回结果、拉起指定类型应用、拉起系统应用。
- Web和应用的跳转与拉起开发实践：介绍ArkWeb页面跳转以及拉起应用相关的知识，包括ArkWeb页面与ArkTS页面互相跳转、ArkWeb页面指定应用跳转、ArkWeb页面指定类型跳转和ArkWeb页面跳转系统应用页面。
- Native侧实现文件访问开发实践：介绍三种Native侧访问文件的实现方案，包括访问应用沙箱内文件、访问应用资源文件和访问系统公共目录文件。
- 组件复用场景与方法详解：介绍组件复用的场景和方法。详细说明了什么是组件复用，为什么要进行组件复用，以及如何在开发过程中实现组件复用。
- Image白块问题解决方案：介绍如何应用沙箱提前缓存，减少Image白块出现时长的优化方案。
- 图文作品轮播开发实践：介绍轮播图形作品的定义、特点和使用场景，并提供了详细的操作步骤和示例代码，帮助开发者快速上手和使用该功能。
- 评论回复弹窗开发实践：介绍如何实现弹窗组件的选型以及最终方案的实现、软键盘和表情面板切换的适配、和编辑区域主要细节功能的实现三种评论列表上层弹出这种相对复杂的场景。
- 常见导航样式案例开发实践：介绍如何在应用程序中使用底部、顶部和侧边多标签功能，以提供更好的用户体验和功能。
- 智慧多窗开发实践：介绍悬浮窗/分屏布局适配方案，以及智慧多窗开发过程中的一些常见问题以及解决方案，来帮助开发者快速适配智慧多窗布局开发，提升用户使用体验。
- 网络管理与状态监听开发实践：介绍网络管理中网络连接管理、网络信息查询和网络状态监听等。帮助开发者了解网络管理中常用的查询方式和如何进行网络状态变化的监听。
- 视频播放开发实践：介绍如何基于HarmonyOS能力快速实现视频播放应用。
- 在线视频播放卡顿优化实践：介绍如何解决在线视频播放过程中可能遇到的卡顿问题。
- 音画同步最佳实践：介绍如何通过第三方视频播放应用正确获取并使用音频相关信息来保证播放时的音视频同步。
- 水印添加开发实践：介绍水印添加的基本原理以及掌握开发的流程与细节。包括页面上添加水印、图片上添加水印和PDF文档添加水印。

开发工具

- 使用lycium工具快速编译三方库：介绍如何在Linux环境下，使用lycium工具通过ohos sdk快速编译openssl三方库源码。

删除文档


删除文档1篇。


业务场景与解决方案

- 阅读器翻页效果实现

2024年9月27日


新增文档


新增文档7篇，包括HarmonyOS特征、功能开发和开发工具。


HarmonyOS特征：

- 多设备断点开发实践：介绍如何通过横向断点和纵向断点，让开发者可以结合窗口宽度与高度两个维度去适配HarmonyOS的1+8设备，解决多设备UX布局问题。通过该方法，开发者无需关注设备类型，即可达到多设备的自适应UI布局效果。

功能开发：

- 高负载场景下分帧渲染：介绍如何在转场场景和滑动场景中实现高负载组件渲染的方法。包括实现原理、解决思路和开发步骤等。
- 相机分段式拍照性能优化实践：介绍如何在相机Shot2See场景中实现分段式拍照Shot2See的完成时延低于单段式拍照。
- 音频播放类应用交互场景实践：介绍在音乐播放器应用中，如何从应用与用户、播放设备以及其他应用的交互三方面入手，为应用带来灵活多样、符合用户直觉的交互体验的示例方案。
- 使用Drawing自绘制能力提升性能：介绍如何通过绘图能力来提高性能的方法。文档中详细解释了绘图能力的重要性，以及如何使用绘图能力来优化应用程序的性能。
- 意图框架习惯推荐场景开发实践：介绍如何通过意图接入来开发“音乐播放”场景。

开发工具：

- Configure构建工程配置HarmonyOS编译工具链：介绍如何使用Configure构建工程配置HarmonyOS编译工具链，包括Configure构建三方库适配流程、环境准备和编译三方库。

删除文档


删除文档1篇。


功能开发

- 瀑布流页面滑动性能解决方案

2024年8月30日


新增文档


新增13篇文章，包括HarmonyOS特征、业务场景与解决方案、性能、安全、功能开发和工具开发模块。


HarmonyOS特征

- 一多开发实例（商务办公）：介绍“一多”在实际开发中的应用。主要包含入口、备忘录、笔记汇总、笔记、日历等典型页面，并分别从UX设计、架构设计、页面开发三个角度给出推荐的参考样例。

业务场景与解决方案

- 在线短视频流畅切换：介绍在应用程序中实现平滑切换的最佳实践和技巧。它涵盖了平滑切换的定义、原则和目标，以及在设计和开发过程中应该考虑的关键因素。

性能

- 调优工具合集：介绍调优的工具集合。
- 点击完成时延分析：介绍点击完成时延相关分析工具，点击完成时延问题定位流程以及常见问题根因分析。
- 分析跨线程序列化耗时问题：介绍如何使用DevEco Studio新增主线程序列化和反序列化检测能力分析跨线程序列化耗时问题，包括工具介绍和案例分析。

功能开发

- 全局自定义组件复用实现：介绍全局自定义组件的重用。文档中详细说明了如何创建和使用全局自定义组件，以及如何在不同页面之间共享和重用这些组件。通过使用全局自定义组件，开发者可以提高代码的复用性和可维护性，从而加快应用开发的速度。
- 瀑布流页面滑动性能解决方案：介绍瀑布流页面滑动相关的性能优化解决方案。
- 基于HMRouter路由框架的页面跳转开发实践：介绍HMRouter路由框架的使用，包括页面跳转、弹窗提示、转场动效、数据加载、维测场景等。
- 软键盘布局适配解决方案：介绍软键盘的弹出收起和监听、软键盘避让机制和软键盘避让常见问题，以帮助开发者了解软键盘的弹出和收起的控制、避让机制以及软键盘常见问题的解决方法。
- 使用同层渲染在Web组件上渲染原生组件：介绍什么是同层渲染，Web组件首次加载原生组件的方案比对和性能收益比对和列表滑动场景性能收益比对。
- 马良GPU最佳实践：介绍如何在马良（Maleoon）GPU上达到最佳的性能表现，只针对Maleoon GPU的优化实践，帮助开发者高效完成渲染任务。，

开发工具

- CMake构建工程配置HarmonyOS编译工具链：介绍如何在Linux环境下，使用CMake构建工具通过ohos sdk编译cJSON三方库源码，生成ohos平台三方库的so及二进制文件。
- Make构建工程配置HarmonyOS编译工具链：介绍如何在Linux环境下，使用Make构建工具通过ohos sdk编译bzip2三方库源码，生成ohos平台三方库的so及二进制文件。

删除文档


删除文档1篇。


功能开发

- 使用AOT进行性能优化

2024年7月30日


新增文档


新增11篇文章，包括业务场景与解决方案、性能、运维和功能开发模块。


业务场景与解决方案

- 折叠屏开发实践：介绍折叠屏的概述、UX体验标准、应用开发指导和多设备的应用案例等。

性能

- Web页面内点击响应时延分析：介绍如何通过分析点击响应延迟来优化网站性能，提高用户体验。包括点击响应延迟的定义、影响因素以及如何进行分析和优化。
- 优化Swiper组件加载慢丢帧问题：介绍Swiper性能优化的相关方法。包括懒加载、缓存数据项、提前加载数据和组件复用等。

运维

- 崩溃监测实践：介绍如何使用HiAppEvent订阅崩溃事件和使用AGC崩溃服务进行崩溃监测。
- 应用埋点开发实践：介绍如何进行应用埋点开发，包括埋点分类、埋点方案介绍、如何上传埋点数据等。

功能开发

- 高负载场景下线程优先级设置防止中断关键线程：介绍在开发过程中如何合理地设置线程的优先级，以提高应用程序的性能和稳定性。通过调整线程的优先级，可以确保关键任务得到优先处理，从而提高应用的响应速度和用户体验。
- 主线程耗时操作优化指导：介绍开发过程中常见的冗余操作，常见的高频回调场景以及其他主线程优化思路。
- 自定义弹窗开发实践：介绍自定义对话框开发的实践方法。提供了详细的步骤和示例，帮助开发者了解如何使用开发工具和技术来创建自定义对话框。
- 手势事件冲突解决方案：介绍手势触发的基本流程，执行原理、如何响应手势事件、如何解决冲突问题等。主要包括事件响应链收集、手势响应优先级、手势响应控制和常见手势冲突问题。
- 基于RCP的网络请求开发实践：介绍RCP与HTTP的区别，如何使用RCP实现基础的网络请求、多表单提交、双向证书校验、DNS的相关设置、请求与响应拦截和捕获有关HTTP请求/响应流。
- 图像模糊动效优化：静态模糊与动态模糊的性能对比解析：介绍如何在模糊场景下进行的性能优化，内容包括了对模糊场景的定义和分类，以及在这些场景下的性能优化技巧和注意事项。

2024年7月12日


新增文档


新增16篇文章，包括HarmonyOS特征、业务场景与解决方案、功耗和功能开发模块。


HarmonyOS特征

- 一多开发实例（便捷生活）：本文分别从UX设计、架构设计、页面开发三个角度给出符合“一多”的参考样例，介绍“一多”便捷生活应用在开发过程中的最佳实践。

业务场景与解决方案

- 阅读器翻页效果实现：已下架。
- AI辅助图文内容高效编创：介绍主要实现社交通讯类应用的图文内容编创流程，在该过程中接入自由流转、服务互动等HarmonyOS特性能力。
- 快捷触达的骑行体验：介绍共享租赁、即时配送等应用场景的解决方案，以共享单车为案例，如何使用实况窗、地图导航、原生扫码等技术，为消费者的整个骑行流程带来更好的体验。

功耗

- 合理使用后台任务：介绍在应用程序中使用后台任务的重要性和好处，并提供了一些实用的建议和示例代码。通过合理使用后台任务，开发者可以提高应用程序的性能和用户体验，同时避免一些常见的问题和错误。
- 控制后台进程CPU使用率：介绍什么是控制后台进程CPU使用率、约束与调测验证。
- 合理使用蓝牙资源：介绍如何合理使用蓝牙资源、蓝牙的约束与示例。
- 合理使用网络资源：介绍如何合理使用网络资源、约束与示例。
- 合理使用音频资源：介绍如何合理使用音频资源、约束与示例。
- 合理使用GPS资源：介绍如何合理使用GPS资源、约束与示例。
- 合理使用传感器资源：介绍如何合理使用传感器资源、约束与示例。
- 后台合理使用上传下载：介绍如何合理使用上传下载资源、约束与示例。
- 合理使用音频播放：介绍如何合理使用音频播放、约束与示例。
- 后台合理使用定位导航服务：介绍如何合理使用定位导航服务、约束与示例。
- 后台合理使用系统资源：介绍如何合理使用系统资源、约束与示例。

功能开发

- 组件嵌套优化：本文通过原理概念、优化场景和实践数据对比三个角度，详细介绍组件嵌套的优化，着重从优化场景角度为开发者阐明组件嵌套的优化场景以及优化策略。
- 横竖屏切换开发实践：介绍横竖屏功能的开发过程中需要关注的内容，包括窗口旋转策略的选择、常用应用类型的横竖屏开发和常见的横竖屏开发问题。
- 生态应用相机实现系统级相机体验：本文针对三方相机开发场景，基于HarmonyOS提供的相机开放能力，实现系统相机级别的效果和能力，比如分辨率、动图、视频防抖、连续变焦等。

2024年5月


新增文档


新增7篇文章，包括HarmonyOS特征、业务场景与解决方案、性能、功耗和功能开发模块。


HarmonyOS特征

- 一多开发实例（地图导航）：详细解释了多行程导航的概念、设计原则和实施步骤，并提供了示例代码和注意事项。通过阅读该文档，开发者可以了解如何在应用程序中实现多行程导航功能，以提升用户体验和功能完整性。

业务场景与解决方案

- 体验流畅的首页信息流：本文主要面向于新闻类页面开发人员，指导开发者从零开始构建一个新闻类的首页面。主要包含地址选择、tabs和tabContent切换的动态图标和流畅动效、下拉刷新上拉加载、首页feed流等常见功能的实现及流畅体验。

性能

- 优化应用内存占用问题：介绍如何在开发过程中进行内存优化，以提高应用程序的性能和效率。文档中包含了内存优化的原则、技巧和工具，帮助开发者更好地管理和优化应用程序的内存使用。

功耗

- 基于LTPO的低功耗设计：介绍LTPo技术的原理、特点以及应用场景和优势。通过阅读该文档，开发者可以了解如何在自己的应用中充分利用LTPo技术，提升用户体验并节省能源消耗。

功能开发

- 使用AOT进行性能优化：已下线。
- 组件复用最佳实践：介绍如何使用组件复用机制提升应用帧率。
- 使用懒加载优化性能：介绍如何通过懒加载技术来优化网页性能，提高用户体验。详细介绍懒加载的原理、实现方式和注意事项，并提供了示例代码和最佳实践建议。

2024年4月


新增文档


新增9篇文章，包括HarmonyOS特征、性能、安全、运维和功能开发模块。


HarmonyOS特征

- 一多开发实例（音乐）：介绍如何将“一次开发，多端部署”应用到音乐播放器的实际开发过程中，包括架构设计、UX设计和页面开发。
- 一多开发实例（旅行订票）：介绍“一多”在旅行订票垂类开发中的应用，包括首页、时间选择页、查询车票页、填写购票信息页、提交订单页等11个典型页面开发案例。

性能

- 性能分析简介：介绍调优的方法、常用的工具，便于开发者可以更好地分析和解决应用程序中的性能问题，提升用户体验，实现应用程序的高效稳定运行。
- 优化瀑布流加载慢丢帧问题：介绍如何进行流水线性能优化的方法和技巧。文档中包含了详细的步骤和示例，帮助开发者在开发过程中提高应用程序的性能和效率。
- 优化Grid组件加载慢丢帧问题：介绍如何提高网格性能的方法，包括减少布局层次、使用合适的布局管理器、使用ViewHolder模式、使用异步加载等。
- 优化应用包体积大小问题：介绍如何减小应用程序包的大小。包括使用资源压缩、代码混淆、资源合并等技术，以及减少不必要的依赖和资源文件等建议。

安全

- 应用代码混淆：介绍在开发应用程序时如何进行代码混淆的方法和技巧。包含了代码混淆的定义、原理和常见的混淆技术，以及如何使用混淆工具进行代码混淆的步骤和注意事项。

运维

- CppCrash故障定位指导：提供了关于如何在C++开发中处理崩溃和异常的指导，以及一些常见的最佳实践建议。它涵盖了崩溃的原因、调试技巧、日志记录和错误处理等方面的内容，旨在帮助开发者更好地处理和解决C++程序中的崩溃问题。

功能开发

- ArkWeb渲染框架适配方：介绍ARKWeb渲染框架的特点、使用方法和最佳实践，帮助开发者更好地利用该框架进行Web应用开发。

2024年3月


新增文档


新增12篇文章，包括HarmonyOS特征、架构、性能、安全、功能开发和开发工具模块。


HarmonyOS特征

- 一多开发实例（股票类）：介绍“一多”在股票类应用开发中的应用。主要包含首页、资讯、自选股、个股详情、行情等9个典型页面。
- 一多开发实例（移动支付）：介绍“一多”在移动支付应用开发中的应用。主要包含支付、收款、扫码等。

架构

- 应用导航设计：介绍应用程序导航设计的相关内容。内容涵盖了导航结构的设计、导航元素的选择和布局、导航交互的设计等方面。
- 应用并发设计：介绍应用在并行任务方案设计过程中，可能会遇到的典型场景以及对应的推荐设计方案，同时给出了方案的关键点及参考案例。
- 应用切面编程设计：介绍对应接口的基本原理，并针对以上业务场景，具体说明怎么利用运行时插桩的接口完成对类方法的埋点和加日志功能。

性能

- 优化web场景下的加载性能问题：介绍Web页面加载优化、JSBridge和同层渲染的优化方式。
- 优化应用冷启动时延问题：介绍应用冷启动流程、识别启动缓慢问题和提升应用冷启动速度，来帮助开发者提升应用的冷启动速度，避免卡顿感。
- 优化应用文件上传下载慢问题：介绍两种常见的上传下载传输和网络请求的关键技术：数据压缩和断点续传，可减少宽带占用，提高传输效率，从而达到提升数据交换性能。

安全

- 应用资产保护设计：介绍应用在资产保护方案设计过程中，可能会遇到的典型场景以及对应的推荐设计方案，同时给出了方案的关键点及参考案例。

功能开发

- 组件封装开发实践：介绍公用组件封装、弹窗组件封装和组件工厂类封装的业务场景，并具体说明了各场景及其实现方案
- 组件动态创建开发实践：介绍如何在用户界面中实现动态操作，设计和实现具有动态操作功能的用户界面。包括使用动态数据绑定、使用动态样式和主题、使用动态布局等。

开发工具

- GN构建工程配置HarmonyOS编译工具链：介绍如何在GN工程中配置HarmonyOS工具链，然后通过HarmonyOS工具链编译出可以在HarmonyOS环境下使用的三方库。

2024年1月


新增文档


新增9篇文章，包括HarmonyOS特征、性能、安全和功能开发模块。


HarmonyOS特征

- 一多开发实例（短视频）：介绍如何将“一次开发，多端部署”使用到短视频应用的实际开发过程中，包括首页、商品分类页、商品详情页、商品支付页、咨询客服页、直播间页等。
- 一多开发实例（购物比价）：介绍如何将“一次开发，多端部署”使用到购物比价应用的实际开发过程中，包括架构设计、UX设计和页面开发。
- 一多开发实例（新闻阅读）：介绍如何将“一次开发，多端部署”使用到新闻阅读应用的实际开发过程中，包含首页推荐、热门新闻、新闻详情、刷新闻、精选发现等。
- 一多开发实例（图片美化）：介绍如何将“一次开发，多端部署”使用到图片美化应用的实际开发过程中，包含相册，大图预览，图片编辑功能。
- 华为视频接入播控中心和投播实践：已下线。

性能

- 性能体验设计：介绍如何设计流畅的应用程序。包括减少应用程序的启动时间、优化界面渲染、合理使用内存和网络资源等方面的建议。
- 感知流畅：介绍如何通过优化应用程序的性能和交互体验，提高用户对应用程序的感知流畅度。其中包括了减少卡顿、提高响应速度、优化动画效果等方面的建议和技巧。

安全

- 应用安全编码实践：介绍如何保护应用程序免受安全威胁。包括应用程序的数据保护、用户隐私保护、网络安全、代码安全等方面的内容。

功能开发

- UI组件性能优化：介绍如何优化UI组件的性能，包括减少布局层级、使用合适的动画效果、优化图片加载、避免过度绘制等。

2023年11月


新增文档


新增11篇文章，包括HarmonyOS特征、性能、功耗、安全和功能开发模块。


HarmonyOS特征

- 一多开发实例（即时通讯）：介绍如何将““一多”使用到即时通讯应用的实际开发过程中，包括架构设计、UX设计和页面开发。
- 一多开发实例（社区评论）：介绍如何将“一多”使用社区评论行业应用的实际开发过程中，主要介绍关键布局能力的功能及实现。
- 一多开发实例（银行理财）：本文从架构设计、UX设计、页面开发三个角度，以银行理财应用作为作为典型案例详细介绍“一多”在实际开发中的应用。具体功能主要包含首页推荐、产品专题、产品详情、产品对比、收益明细等。

性能

- 点击响应时延分析：介绍点击到点击响应优化的方法和技巧，包括性能优化的重要性、优化的目标、优化的方法和技巧等。

功耗

- 省电和深色模式下低功耗设计：介绍关于如何在暗模式下优化应用程序的电池寿命的指导和建议。包括暗模式的概述，以及在设计和开发过程中需要考虑的关键因素，如颜色选择、图标设计、背光控制等。

安全

- 应用隐私保护：介绍开发者在应用开发过程中如何保护用户隐私的指导和建议。包括隐私政策的编写、数据收集和使用、权限管理、数据安全等方面的内容。
- 应用数据安全：介绍关于如何保护应用程序中的数据安全的指导和建议。包括使用加密算法保护敏感数据、使用安全存储保护数据、使用安全传输保护数据等。

功能开发

- ArkTS高性能编程：介绍开发过程中的一些高性能的写法和建议，包含变量声明、属性的访问、数值计算、数据结构的使用以及函数声明与使用等。
- TaskPool和Worker的对比实践：介绍TaskPool和Worker的概念、使用场景以及如何选择适合的方案。通过比较TaskPool和Worker的特点和优势，帮助开发者更好地理解和应用这两种技术，以提高工作效率和性能。
- 状态管理最佳实践：介绍状态管理的概念、原则和实施方法，包括状态管理的重要性、状态管理的基本原则、常见的状态管理模式和框架，以及实现状态管理的具体步骤和示例代码。
- 合理使用动画：介绍公平使用动画的技巧和方法，包含了一些关于动画设计原则、性能优化、交互设计和可访问性等方面的建议和技巧。

2023年9月


新增文档


新增8篇文章，包括HarmonyOS特征、架构、性能和功能开发模块。


HarmonyOS特征

- 一多开发实例（长视频）：本文分别从UX设计、工程管理、页面开发和功能开发四个角度给出符合“一多”的参考样例，介绍“一多”长视频应用在开发过程中的最佳实践。

架构

- 应用架构概述：介绍应用程序架构的重要性，以及如何设计和构建可扩展、可维护和高效的应用程序架构。
- 分层架构设计：介绍逻辑模型、开发模型和部署模型的应用分层架构设计规则。
- 模块化设计：介绍什么是模块化设计、为什么在软件开发中采用模块化设计和如何实施模块化设计。

性能

- 分析帧率问题：介绍什么是框架实践，包括网站结构、导航设计、内容布局、页面加载速度优化等方面。
- 优化长列表加载慢丢帧问题：介绍在开发过程中的一些最佳实践和长列表。包括了代码编写、测试、性能优化、安全性、用户体验等方面的最佳实践。

功能开发

- 合理使用布局：介绍如何提高布局性能，包括使用CSS Grid和Flexbox进行灵活布局、减少DOM元素的数量、合理使用CSS样式和动画、优化图片加载等。
- 合理使用页面间转场：介绍在开发网页时如何实现流畅的页面过渡效果，包括如何使用动画、过渡效果和预加载等技术来优化页面过渡。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ux-design
爬取时间: 2025-05-08 03:38:51
来源: Huawei Developer

- UI设计套件（UI Design）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ui-design
爬取时间: 2025-05-08 03:39:00
来源: Huawei Developer

- 怎么获取layeredDrawableDescriptor对象信息？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/ui-design-faq1
爬取时间: 2025-05-08 03:39:09
来源: Huawei Developer


应用配置的图标和名称信息，可以通过resourceManager.getDrawableDescriptor获取。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-business-scenarios-and-solutions
爬取时间: 2025-05-08 03:39:18
来源: Huawei Developer

- 多设备场景

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-multi-device-scenario
爬取时间: 2025-05-08 03:39:28
来源: Huawei Developer

- 手表／手环（Wear Engine）
- 手机

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-wear-engine
爬取时间: 2025-05-08 03:39:38
来源: Huawei Developer

- 如果工程已有APP ID，是否需要重新申请，填写新的APP ID
- 使用AppInfo时，如何获取应用身份标识
- 没有弹出用户授权界面
- 接口调用时返回App has not applied for the Wear Engine service错误信息
- 打开HR传感器后，没有立刻上报数据
- HR传感器数据中，有值为0或255的数据
- 手机和轻量级智能穿戴设备通信，提示错误码206
- 手机侧应用发送文件给穿戴设备侧应用时，提示错误码1008500011
- 更多：若以上FAQ仍不能解决，可通过在线提单反馈

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wearengine_faq-1
爬取时间: 2025-05-08 03:39:48
来源: Huawei Developer


只要是在华为联盟网站申请的，就可以用，不用重新申请。但是要确保应用的包名、APP ID及证书指纹是匹配的，即确保和申请账号服务时提供的一致。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wearengine_faq-9
爬取时间: 2025-05-08 03:39:58
来源: Huawei Developer


应用开发中需要使用AppInfo时，其中fingerprint可采用AppGallery Connect平台提供的应用APP ID值来标识应用的唯一身份。


可通过登录AppGallery Connect平台，在“我的项目”中选择目标应用，获取“项目设置 > 常规 > 应用”的APP ID。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160811.61253992695827142961746833671669:50001231000000:2800:EBBB3D29A2D8D54CB5BA9A6618EFEFA98EFDBBA8E636013EC2D734266F6888DB.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wearengine_faq-2
爬取时间: 2025-05-08 03:40:07
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wearengine_faq-3
爬取时间: 2025-05-08 03:40:16
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wearengine_faq-4
爬取时间: 2025-05-08 03:40:25
来源: Huawei Developer


设备底层计算HR数据需要一定的时间，不同的设备由于性能差异所需时间不同，等待一段时间后方可收到上报数据。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wearengine_faq-5
爬取时间: 2025-05-08 03:40:35
来源: Huawei Developer


0和255为瞬时异常数据，出现异常数据的原因可能是手表佩戴的位置有误或佩戴较松，请开发者对此异常数据进行过滤。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wearengine_faq-6
爬取时间: 2025-05-08 03:40:44
来源: Huawei Developer

- 手机和穿戴设备的包名或证书指纹不匹配轻量级智能穿戴设备侧：需要把手机的包名和指纹信息放到白名单中手机侧：需要把轻量级智能穿戴设备侧应用的包名和指纹信息配置正确
- 轻量级智能穿戴设备侧：需要把手机的包名和指纹信息放到白名单中
- 手机侧：需要把轻量级智能穿戴设备侧应用的包名和指纹信息配置正确
- 轻量级智能穿戴设备侧应用不在前台
- 手机或轻量级智能穿戴设备侧应用没有注册消息接收器
- 发送的消息为空
- 蓝牙未连接
- 轻量级智能穿戴设备侧：需要把手机的包名和指纹信息放到白名单中
- 手机侧：需要把轻量级智能穿戴设备侧应用的包名和指纹信息配置正确

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wearengine_faq-7
爬取时间: 2025-05-08 03:40:54
来源: Huawei Developer


手机侧应用发送文件需要文件访问权限，请检查应用是否具有相关文件的访问权限。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wearengine_faq-8
爬取时间: 2025-05-08 03:41:03
来源: Huawei Developer


打开华为开发者联盟的“在线提单”页面，根据遇到的问题情况填写“概述”，问题分类选择“HarmonyOS NEXT > 系统 > Wear Engine Kit”，描述问题详情并单击“提交问题”。提交问题后，有时需要您进一步澄清问题，请及时关注进展并予以回复，以便更好地解决问题。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-quality
爬取时间: 2025-05-08 03:41:13
来源: Huawei Developer

- 技术质量

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-technical-quality
爬取时间: 2025-05-08 03:41:23
来源: Huawei Developer

- 运维

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit
爬取时间: 2025-05-08 03:41:32
来源: Huawei Developer

- hilog日志如何落盘存储
- hilog日志如何设置为只打印当前应用的日志
- hilog日志出现乱码原因是什么，如何解决
- 如何解决hilog.debug日志无法打印
- 如何查询应用当前CPU占用
- 如何查询应用堆内存的已分配内存大小和堆内存的空闲内存大小
- 当应用发生故障时，如何获取系统日志
- 如何用hdc命令将本地文件发送至远端设备
- 如何查看应用是否为系统应用
- 如何实现crash堆栈抓取、crash回调
- 如何线上分析应用在CPU占用情况
- 如何获取设备的CPU信息
- 如何获取设备的SDK版本、产品版本、设备类型（平板、手机）、build版本等信息
- console.log和hilog的区别，如何选择使用
- 如何查看ArkCompiler出现Error日志时，具体的异常调用栈信息
- hdc工具导出/导入文件等常用hdc命令有哪些
- 如何解决设备无法识别问题
- 如何解决Connect server failed-注册表问题
- 如何解决单个设备连接设备管理器多出三个设备并无法识别的问题
- 如何解决hdc server和client版本不一致的问题
- 如何解决Kill server failed 的问题
- 是否有目录可以通过hdc file send写入可执行程序
- 如何解决Mac电脑不能识别hdc命令的问题
- 如何解决连接手机时，提示：“hdc server part 8710 has been used”的问题
- 如何通过hdc命令拉起指定的UIAbility
- 如何通过hdc命令关闭整个应用
- 如何在多设备情况下使用hdc
- 如何通过HDC命令截屏/获取相册
- 如何在HarmonyOS PC/2in1设备上查看MAC地址
- 如何通过hdc命令清除手机中应用的缓存
- 如何通过hdc命令唤醒设备和查看屏幕状态
- 是否支持通过HDC命令安装.app文件
- 如何选择收集崩溃的方式，ErrorManager、FaultLog、HiAppEvent在监听crash上的差异
- 使用HiLog打印日志是否有长度限制
- 如何通过hdc命令获取设备的udid
- 如何使用ErrorManager捕获异常

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-1
爬取时间: 2025-05-08 03:41:42
来源: Huawei Developer


使用命令：hilog -w start -f ckTest -l 1M -n 5 -m zlib -j 11


文件保存在目录：/data/log/hilog/


参数解释：


```less
-w 开启日志落盘任务,start表示开始，stop表示停止。 
-f 设置日志文件名 
-l 设置单个日志文件大小，单位可以是：B/K/M/G 
-n 设置最大日志文件编号，当文件计数超过此编号时，日志文件旋转。范围：【2,1000】 
-m 设置日志文件压缩算法 
-j 任务ID，范围：[10,0xffffffffff) 
更多参数含义请使用hilog --help查看。
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-2
爬取时间: 2025-05-08 03:41:52
来源: Huawei Developer


通过hilog命令行工具来过滤保留当前应用的日志。


```less
hilog -T xxx 按tag过滤; 
hilog –D xxx 按domain过滤; 
hilog -e 对日志内容匹配，支持正则表达式。支持tag, domain, pid等多重过滤,组合过滤以及反向过滤。
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-3
爬取时间: 2025-05-08 03:42:02
来源: Huawei Developer


当前hilog日志使用轻量化技术，以二进制落盘+数据字典的方式，不是明文落盘的，直接解压查看会出现乱码。


可以使用DevEco Studio\sdk\default\hms\toolchains目录下的hilogtool.exe工具，执行 hilogtool.exe parse命令进行解析。


```less
@set Ymd=%date:~0,4%_%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%%time:~6,2%
@set Ymd=%Ymd: =0% 
@set Dir=LOG_%YMD% md %Dir% hdc file recv /data/log/hilog/ .\%Dir%\ 
hilogtool parse -i .\%Dir% -d .\%Dir% 
pause
```


上述代码保存为get_hilog.bat文件，和hilogtool.exe存放于同一目录下，执行脚本文件下载所有日志文件，并进行解析。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-9
爬取时间: 2025-05-08 03:42:13
来源: Huawei Developer


通过hdc命令：


```less
hdc shell hilog -b D
```


开启调试开关。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-14
爬取时间: 2025-05-08 03:42:22
来源: Huawei Developer


目前有两种方式查询当前CPU占用，如下:


在代码中查询：


CPU占用可以用hidebug.getCpuUsage接口查询。参考代码如下：


```less
let cpuUsage: number = hidebug.getCpuUsage();
```


在命令行中查询：

- 根据hdc命令行工具指导，完成环境准备。

```less
hidumper --cpuusage <pid>
hidumper --cpuusage
```


参考链接


hidebug.getCpuUsage


hidumper


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-15
爬取时间: 2025-05-08 03:42:33
来源: Huawei Developer


目前有两种方式查询当前CPU占用，如下:


在代码中查询：


查询应用堆内存的已分配内存大小可以使用hidebug.getNativeHeapAllocatedSize，查询堆内存的空闲内存大小可以使用hidebug.getNativeHeapFreeSize。


参考代码如下：


```less
let nativeHeapAllocatedSize: bigint = hidebug.getNativeHeapAllocatedSize(); // 获取本应用堆内存的已分配内存大小 
let nativeHeapFreeSize: bigint = hidebug.getNativeHeapFreeSize(); // 获取本应用堆内存的空闲内存大小
```


在命令行中查询：


--mem pid获取总内存占用率；如果指定pid，则获取指定pid的内存占用率


```less
hidumper --mem pid
```


参考链接


hidebug.getNativeHeapFreeSize


hidebug.getNativeHeapAllocatedSize


hidumper


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-16
爬取时间: 2025-05-08 03:42:42
来源: Huawei Developer


通过faultLogger.query(faultType: FaultType, callback: AsyncCallback<Array<FaultLogInfo>>)接口可以对故障日志进行获取，其中FaultType是枚举类型，可选值如下所示：


| 名称  | 值  | 说明  |
| --- | --- | --- |
| NO_SPECIFIC  | 0  | 不区分故障类型  |
| CPP_CRASH  | 2  | C++程序故障类型  |
| JS_CRASH  | 3  | JS程序故障类型  |
| APP_FREEZE  | 4  | 应用程序卡死故障类型  |

名称


值


说明


NO_SPECIFIC


0


不区分故障类型


CPP_CRASH


2


C++程序故障类型


JS_CRASH


3


JS程序故障类型


APP_FREEZE


4


应用程序卡死故障类型


第二个参数是传入的callback回调函数，用来获取故障信息数组。


示例代码中FaultType取值为JS_CRASH，queryFaultLogCallback即传入的回调函数，用来打印相关日志信息。


```less
import { FaultLogger } from '@kit.LancetKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
function queryFaultLogCallback(error: BusinessError, value: Array<FaultLogger.FaultLogInfo>) { 
  if (error) { 
    console.info('error is ' + error); 
  } else { 
    console.info("value length is " + value.length); 
    let len: number = value.length; 
    for (let i = 0; i < len; i++) { 
      console.info("log: " + i); 
      console.info("Log pid: " + value[i].pid); 
      console.info("Log uid: " + value[i].uid); 
      console.info("Log type: " + value[i].type); 
      console.info("Log timestamp: " + value[i].timestamp); 
      console.info("Log reason: " + value[i].reason); 
      console.info("Log module: " + value[i].module); 
      console.info("Log summary: " + value[i].summary); 
      console.info("Log text: " + value[i].fullLog); 
    } 
  } 
} 
 
try { 
  FaultLogger.query(FaultLogger.FaultType.JS_CRASH, queryFaultLogCallback); 
} catch (err) { 
  console.error(`code: ${(err as BusinessError).code}, message: ${(err as BusinessError).message}`); 
}
```


参考链接


faultLogger


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-17
爬取时间: 2025-05-08 03:42:52
来源: Huawei Developer


从本地发送文件至远端设备，命令格式如下：


```less
hdc file send local remote
```


其中local表示本地待发送的文件路径，remote表示远程待接收的文件路径。


使用方法如下：


```less
hdc file send E:\example.txt /data/local/tmp/example.txt
```


参考链接


hdc-文件相关命令


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-18
爬取时间: 2025-05-08 03:43:02
来源: Huawei Developer


```less
hdc shell bm dump -n <Bundle Name>
```

1.  返回的部分结果如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160815.69367364397499361709112933593460:50001231000000:2800:8AD7A8A12C1CF3A232A668B4BFA8A9A4C6E237ADB43FCB8E7E069C78CAF59E35.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160816.83292241898830882859905547719621:50001231000000:2800:D94FE8DD91DECB382BC55F38FB35B70B4F6D8A0F10E583E90EC0167E3D4C602D.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-19
爬取时间: 2025-05-08 03:43:12
来源: Huawei Developer


可以使用faultLogger.querySelfFaultLog获取故障日志，可以抓取C++程序故障、JS程序故障类型、应用程序卡死故障，获取分析故障进程的进程id、故障进程的用户id、故障类型、日志生成时的秒级时间戳、发生故障的原因、发生故障的模块、故障的概要和故障日志全文。可参考以下示例代码：


```less
import { FaultLogger } from '@kit.PerformanceAnalysisKit'; 
import { BusinessError } from '@kit.BasicServicesKit' 
 
async function getLog() { 
  try { 
    let value: Array<FaultLogger.FaultLogInfo> = await FaultLogger.query(FaultLogger.FaultType.JS_CRASH); 
    if (value) { 
      console.info("value length is " + value.length); 
      let len: number = value.length; 
      for (let i = 0; i < len; i++) { 
        console.info("log: " + i); 
        console.info("Log pid: " + value[i].pid); 
        console.info("Log uid: " + value[i].uid); 
        console.info("Log type: " + value[i].type); 
        console.info("Log timestamp: " + value[i].timestamp); 
        console.info("Log reason: " + value[i].reason); 
        console.info("Log module: " + value[i].module); 
        console.info("Log summary: " + value[i].summary); 
        console.info("Log text: " + value[i].fullLog); 
      } 
    } 
  } catch (err) { 
    console.error(`code: ${(err as BusinessError).code}, message: ${(err as BusinessError).message}`); 
  } 
}
```


参考链接


@ohos.faultLogger (故障日志获取)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-20
爬取时间: 2025-05-08 03:43:22
来源: Huawei Developer


应用可能在发生卡顿、丢帧或者评估应用运行状态时，可以通过hidebug接口获取资源数据，检测当前应用的运行状态 。


利用@ohos.hidebug可以获取应用内存的使用情况，包括应用进程的静态堆内存（native heap）信息、应用进程内存占用PSS（Proportional Set Size）信息等；可以完成虚拟机内存切片导出、虚拟机CPU Profiling采集等操作。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-22
爬取时间: 2025-05-08 03:43:31
来源: Huawei Developer


可以通过如下命令来查看CPU信息：


```less
// 查看CPU信息  
hdc shell param get const.product.cpu.abilist
```


返回结果如下图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160816.14121115347314958053984324112811:50001231000000:2800:61C2A3311C7FFF987EF8E38BCEAE1A2112087B8BA0384DF2599EB87C6D6AFFD5.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-23
爬取时间: 2025-05-08 03:43:41
来源: Huawei Developer


应用所在设备的信息，可以通过@kit.BasicServicesKit的deviceInfo模块获取：

- SDK版本：deviceInfo.sdkApiVersion。
- 产品版本： deviceInfo.displayVersion。
- 设备类型（平板、手机）： deviceInfo.deviceType。
- build版本：deviceInfo.buildVersion。

更多请参见@ohos.deviceInfo (设备信息)。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-24
爬取时间: 2025-05-08 03:43:51
来源: Huawei Developer

- console.log是对hilog日志系统的封装，其采用默认参数，console.log的日志业务领域、日志TAG、日志级别是固定的，其中，日志业务领域为‘A0c0d0’，日志TAG为‘JSApp’，日志级别为info。
- hilog日志在打印的时候，会包含4部分内容：日志业务领域、日志TAG、日志级别、日志内容，可以自定义设置日志业务领域、日志TAG、日志级别。
- console主要用于应用开发调试阶段。
- 推荐使用hilog，可以对日志系统进行分类和统一处理，使用console.log打印日志，则不方便日志定位。

参考链接


Hilog


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-29
爬取时间: 2025-05-08 03:44:00
来源: Huawei Developer


Native抛异常，如果需要查看backtrace，需要运行如下命令。


打开异常栈：


```less
hdc shell param set persist.ark.properties 0x125c 
hdc shell reboot
```


恢复默认值：


```less
hdc shell param set persist.ark.properties 0x105c 
hdc shell  reboot
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-31
爬取时间: 2025-05-08 03:44:10
来源: Huawei Developer


导出文件：hdc file recv 手机路径


电脑路径导入文件：hdc file send 电脑路径


手机路径查看手机连接：hdc list targets


手机常亮：hdc shell power-shell setmode 602


查看OUC进程：ps -ef|grep com.huawei.hmos.ouccom.ohos.updateapp


查看DUE进程：ps -ef|grep updater_sa


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-32
爬取时间: 2025-05-08 03:44:19
来源: Huawei Developer


问题现象


执行 "hdc list targets"命令后结果为：[Empty]。


可能原因

- 原因一：设备无法识别。
- 原因二：插上USB设备后显示"HDC Device"警告图标。
- 原因三：HDC设备正常连接，执行hdc tmode port 8710切换为tcp模式，不能识别设备。
- 原因四：hdc与设备不匹配，端口被占用，adb和hdc冲突。

解决措施

1.  查看设备管理是否显示HDC设备。 若有"HDC Device"显示说明正常。 若有"HDC Interface"显示说明也正常（一般为复合端口设备）。 若没有显示HDC设备则说明识别不了设备，可以试试其它USB口、换USB线、或者插到其它电脑上试试、或者重新烧录对应镜像试试。 驱动损坏时，重新安装驱动 重新安装驱动方法： 打开zadig（zadig官网)/（zadig仓库下载），插入设备，Options里面打开List All Devices，下拉框找到HDC Device，然后点击Reinstall Driver。 命令行执行lsusb,查看是否有HDC Device/HDC Interface。若无该命令通过apt-get install usbutils安装usbtuils。 可使用“系统信息”或“系统概述”来查看MacOS能否识别连接到Mac的USB设备步骤： (1)按住键盘上的Option键，然后点按苹果菜单。 (2)选取“系统信息”或“系统概述”。 (3)在随后出现的窗口中，选择左边的“USB”。 (4)在随后显示的设备树查看是否有HDC Device/HDC Interface，如无显示，则可按照以下思路检查USB连接是否正常。
2.  查看设备管理是否显示HDC设备。 若有"HDC Device"显示说明正常。 若有"HDC Interface"显示说明也正常（一般为复合端口设备）。 若没有显示HDC设备则说明识别不了设备，可以试试其它USB口、换USB线、或者插到其它电脑上试试、或者重新烧录对应镜像试试。 驱动损坏时，重新安装驱动 重新安装驱动方法： 打开zadig（zadig官网)/（zadig仓库下载），插入设备，Options里面打开List All Devices，下拉框找到HDC Device，然后点击Reinstall Driver。
3.  命令行执行lsusb,查看是否有HDC Device/HDC Interface。若无该命令通过apt-get install usbutils安装usbtuils。
4.  可使用“系统信息”或“系统概述”来查看MacOS能否识别连接到Mac的USB设备步骤： (1)按住键盘上的Option键，然后点按苹果菜单。 (2)选取“系统信息”或“系统概述”。 (3)在随后出现的窗口中，选择左边的“USB”。 (4)在随后显示的设备树查看是否有HDC Device/HDC Interface，如无显示，则可按照以下思路检查USB连接是否正常。
1.  查看设备管理是否显示HDC设备。 若有"HDC Device"显示说明正常。 若有"HDC Interface"显示说明也正常（一般为复合端口设备）。 若没有显示HDC设备则说明识别不了设备，可以试试其它USB口、换USB线、或者插到其它电脑上试试、或者重新烧录对应镜像试试。 驱动损坏时，重新安装驱动 重新安装驱动方法： 打开zadig（zadig官网)/（zadig仓库下载），插入设备，Options里面打开List All Devices，下拉框找到HDC Device，然后点击Reinstall Driver。
2.  命令行执行lsusb,查看是否有HDC Device/HDC Interface。若无该命令通过apt-get install usbutils安装usbtuils。
3.  可使用“系统信息”或“系统概述”来查看MacOS能否识别连接到Mac的USB设备步骤： (1)按住键盘上的Option键，然后点按苹果菜单。 (2)选取“系统信息”或“系统概述”。 (3)在随后出现的窗口中，选择左边的“USB”。 (4)在随后显示的设备树查看是否有HDC Device/HDC Interface，如无显示，则可按照以下思路检查USB连接是否正常。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160816.35954221133758915458758575339898:50001231000000:2800:CBF2498FB16716EB3AD3939C7FC5DCB5A4654FC34797BDC8A3409758B03AD259.png)

| 排查项  | 正常内容  | 异常处理  |
| --- | --- | --- |
| USB接口  | 使用USB直连  | 如使用拓展坞无法识别请更换或尝试直连  |
| USB线 设备状态  | 使用原装配套USB连接线 设备处于开机状态，进入【系统设置>系统>开发人员选项】 "USB调试"开关处于常开  | 如使用其他第三方线材需要确认至少满足USB2.0标准 如USB调试开关非常开可以尝试重新插拔USB接口、重启设备或恢复出厂设备  |

排查项


正常内容


异常处理


USB接口


使用USB直连


如使用拓展坞无法识别请更换或尝试直连


USB线


设备状态


使用原装配套USB连接线


设备处于开机状态，进入【系统设置>系统>开发人员选项】 "USB调试"开关处于常开


如使用其他第三方线材需要确认至少满足USB2.0标准


如USB调试开关非常开可以尝试重新插拔USB接口、重启设备或恢复出厂设备

1. 
2. 

```less
adb kill-server
hdc kill
hdc start
```


```less
adb kill-server
hdc kill
hdc start
```

1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160816.95847107074780062436974284034827:50001231000000:2800:336949C97E0E7DC03CDE6DF68EBB587B55B70A7D9854D2A9E2999E439FA71E94.png)

```less
adb kill-server
hdc kill
hdc start
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-35
爬取时间: 2025-05-08 03:44:29
来源: Huawei Developer


问题现象


hdc server/其他USB设备冲突导致注册表异常，导致client端无法连接server端。


可能原因


本地注册表异常，常见于ADB设备和HDC设备同时连接到同一个设备的场景。


解决措施


```less
hdc kill
hdc -s 127.0.0.1:8710 -m
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160816.88765302713137340643892225291148:50001231000000:2800:A9E35EF4EACEDBB62F6B271942F59F98BD75F06454DA5FE138587C0E53D293F0.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-37
爬取时间: 2025-05-08 03:44:38
来源: Huawei Developer


问题现象


单个设备连接设备管理器多出三个设备并无法识别。


可能原因


驱动问题。


解决措施


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-38
爬取时间: 2025-05-08 03:44:47
来源: Huawei Developer


问题现象


hdc.log中报错信息为“Daemon Session Handshakefailed！”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160816.24384189370768515315897734664330:50001231000000:2800:52AEEBF5D05255DB5A60E093473CD85913E532A71960F35F359BC5291A9BBA52.png)

解决措施

1.  hdc checkserver
2.  hdc kill

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-40
爬取时间: 2025-05-08 03:44:55
来源: Huawei Developer


问题现象


执行hdc kill返回“Kill server failed operation not permitted”。


可能原因


其他程序后台启动了hdc server且权限高于当前执行hdc kill的命令行权限。


解决措施


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-41
爬取时间: 2025-05-08 03:45:04
来源: Huawei Developer


建议使用临时目录/data/local/tmp，适合临时测试可执行文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-42
爬取时间: 2025-05-08 03:45:15
来源: Huawei Developer

1. 
2. 
3.  export PATH=${PATH}: Sdk/default/base/toolchains 然后esc退出，并在下方输入:wq保存退出。
4.  export PATH=${PATH}: Sdk/default/base/toolchains 然后esc退出，并在下方输入:wq保存退出。
1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160816.82495608688302467155917106978526:50001231000000:2800:4CE98E4BA288E071A3CDBCD0B8C7E9113CFAEDF43E90F3E43038FA776EE4C0AD.png)
1.  export PATH=${PATH}: Sdk/default/base/toolchains 然后esc退出，并在下方输入:wq保存退出。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-43
爬取时间: 2025-05-08 03:45:23
来源: Huawei Developer

- 方式一：结束掉占用该端口的应用。运行cmd命令行工具，输入“netstat -ano | findstr 端口号”，查询占用端口号的进程PID。打开任务管理器，选择详细信息页签，查看此PID对应的应用。结束掉对应应用后，重启DevEco Studio。
- 运行cmd命令行工具，输入“netstat -ano | findstr 端口号”，查询占用端口号的进程PID。
- 打开任务管理器，选择详细信息页签，查看此PID对应的应用。
- 结束掉对应应用后，重启DevEco Studio。
-  在此电脑 -> 属性 -> 高级系统设置 -> 高级 -> 环境变量中添加hdc端口。变量名为：OHOS_HDC_SERVER_PORT，变量值可设置为任意未被占用的端口。 a.打开终端工具，执行echo $SHELL命令，根据输出结果分别执行不同命令: 如果输出结果为/bin/bash，则执行vi ~/.bash_profile命令，打开.bash_profile文件。 如果输出结果为/bin/zsh，则执行vi ~/.zshrc命令，打开.zshrc文件。 b.单击字母“i”，进入Insert模式。 c.输入以下内容，在PATH路径下添加OHOS_HDC_SERVER_PORT端口信息。 d.编辑完成后，单击Esc键，退出编辑模式，然后输入:wq，单击Enter键保存。 e.执行以下命令，使配置的环境变量生效： 如果步骤1打开的是.bash_profile文件，执行source ~/.bash_profile命令。 如果步骤1打开的是.zshrc文件，执行source ~/.zshrc命令。 f.环境变量配置完成后，关闭并重启DevEco Studio。

```less
OHOS_HDC_SERVER_PORT=端口号
launchctl setenv OHOS_HDC_SERVER_PORT $OHOS_HDC_SERVER_PORT
export OHOS_HDC_SERVER_PORT
```

-  在此电脑 -> 属性 -> 高级系统设置 -> 高级 -> 环境变量中添加hdc端口。变量名为：OHOS_HDC_SERVER_PORT，变量值可设置为任意未被占用的端口。
-  a.打开终端工具，执行echo $SHELL命令，根据输出结果分别执行不同命令: 如果输出结果为/bin/bash，则执行vi ~/.bash_profile命令，打开.bash_profile文件。 如果输出结果为/bin/zsh，则执行vi ~/.zshrc命令，打开.zshrc文件。 b.单击字母“i”，进入Insert模式。 c.输入以下内容，在PATH路径下添加OHOS_HDC_SERVER_PORT端口信息。 d.编辑完成后，单击Esc键，退出编辑模式，然后输入:wq，单击Enter键保存。 e.执行以下命令，使配置的环境变量生效： 如果步骤1打开的是.bash_profile文件，执行source ~/.bash_profile命令。 如果步骤1打开的是.zshrc文件，执行source ~/.zshrc命令。 f.环境变量配置完成后，关闭并重启DevEco Studio。

```less
OHOS_HDC_SERVER_PORT=端口号
launchctl setenv OHOS_HDC_SERVER_PORT $OHOS_HDC_SERVER_PORT
export OHOS_HDC_SERVER_PORT
```

1.  在此电脑 -> 属性 -> 高级系统设置 -> 高级 -> 环境变量中添加hdc端口。变量名为：OHOS_HDC_SERVER_PORT，变量值可设置为任意未被占用的端口。
2.  a.打开终端工具，执行echo $SHELL命令，根据输出结果分别执行不同命令: 如果输出结果为/bin/bash，则执行vi ~/.bash_profile命令，打开.bash_profile文件。 如果输出结果为/bin/zsh，则执行vi ~/.zshrc命令，打开.zshrc文件。 b.单击字母“i”，进入Insert模式。 c.输入以下内容，在PATH路径下添加OHOS_HDC_SERVER_PORT端口信息。 d.编辑完成后，单击Esc键，退出编辑模式，然后输入:wq，单击Enter键保存。 e.执行以下命令，使配置的环境变量生效： 如果步骤1打开的是.bash_profile文件，执行source ~/.bash_profile命令。 如果步骤1打开的是.zshrc文件，执行source ~/.zshrc命令。 f.环境变量配置完成后，关闭并重启DevEco Studio。

```less
OHOS_HDC_SERVER_PORT=端口号
launchctl setenv OHOS_HDC_SERVER_PORT $OHOS_HDC_SERVER_PORT
export OHOS_HDC_SERVER_PORT
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-45
爬取时间: 2025-05-08 03:45:33
来源: Huawei Developer


可以通过如下命令拉起指定UIAbility ：


```less
hdc shell aa start -a <UIAbility Name> -b <Bundle Name>
```


启动成功时，返回"start ability successfully."，启动失败时，返回"error: failed to start ability."，同时会包含相应的失败信息。


示例如下：


```less
hdc shell aa start -a EntryAbility -b com.example.myapplication
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160817.14226897076488207018816458846317:50001231000000:2800:567074AC0437476A166CCB84A74D5A3A6E17ACA617FD6D2B818193D9AD3738B9.png)

参考链接


aa工具


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-47
爬取时间: 2025-05-08 03:45:42
来源: Huawei Developer


可以通过如下命令结束应用：


```less
hdc shell aa force-stop <Bundle Name>
```


返回force stop process successfully，表示结束应用成功。


示例如下：


```less
hdc shell aa force-stop com.example.myapplication
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160817.10884695884366992742114084377795:50001231000000:2800:A2F293D0F0A36A809A097C37BB1F9DC6991A235FA7C9A9E17A3F4BA91A7CD2D8.png)

参考链接


aa工具


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-48
爬取时间: 2025-05-08 03:45:52
来源: Huawei Developer


问题场景


本机启动模拟器时，连接真机，然后调用hdc命令获取udid。此时仅打印一条模拟器的udid。


解决措施


多设备时执行hdc shell会失败，需要指定设备执行hdc -t xx shell，否则会报错。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-49
爬取时间: 2025-05-08 03:46:02
来源: Huawei Developer


```less
hdc shell snapshot_display -f /data/local/tmp/test111.jpeg // -f表示指定图片在设备上的存储路径，如不指定，会在命令执行完成后显示图片默认存储路径
hdc file recv /data/local/tmp/test111.jpeg ///data/local/tmp下，后缀为jpeg
```


```less
hdc file recv /storage/media/100/local/files/Photo // 拉取相册到命令执行时的目录
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-50
爬取时间: 2025-05-08 03:46:12
来源: Huawei Developer


问题场景


设置/关于里面没有找到查看MAC地址地方，请问怎样才能查看MAC地址？


解决措施


HarmonyOS PC/2in1中无法直接查看MAC地址，需要使用hdc shell ifconfig命令查看。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-51
爬取时间: 2025-05-08 03:46:22
来源: Huawei Developer


清除数据：hdc shell bm clean -d -n 应用包名。


清除缓存：hdc shell bm clean -c -n 应用包名。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-52
爬取时间: 2025-05-08 03:46:32
来源: Huawei Developer


唤醒设备：hdc shell power-shell wakeup


查看屏幕状态：hdc shell hidumper -s 3301 -a -a


查询手机IMEI：要先进入fastboot（hdc target boot bootloader），然后用fastboot的命令查询（fastboot oem get-psid）


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-53
爬取时间: 2025-05-08 03:46:42
来源: Huawei Developer


不支持直接安装.app文件，app是给到应用市场那边的包文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-57
爬取时间: 2025-05-08 03:46:51
来源: Huawei Developer


推荐使用HiAppEvent方式。


| 方式  | 作用范围  | 触发方式  | 场景  | 发生崩溃表现  |
| --- | --- | --- | --- | --- |
| ErrorManager  | js crash  | 调用者主动query当前进程故障数据，上报最多10份信息 （获取的数据会被FaultLog监听到，是FaultLog返回数据的子集）  | 错误通知  | 抛出错误信息，进程不退出  |
| FaultLog  | js crash，cpp crash，app freeze  | 观察者模式，先注册监听，系统回调后返回回调结果  | 日志查询，可以主动查询近期发生的故障日志  | 抛出错误日志，进程不退出  |
| HiAppEvent  | js crash，cpp crash，app freeze  | 观察者模式，先注册监听，系统回调后返回回调结果  | 事件记录和监听，可以监听行为、故障、统计、安全事件  | 进程退出，再次进入应用处理崩溃信息  |

方式


作用范围


触发方式


场景


发生崩溃表现


ErrorManager


js crash


调用者主动query当前进程故障数据，上报最多10份信息


（获取的数据会被FaultLog监听到，是FaultLog返回数据的子集）


错误通知


抛出错误信息，进程不退出


FaultLog


js crash，cpp crash，app freeze


观察者模式，先注册监听，系统回调后返回回调结果


日志查询，可以主动查询近期发生的故障日志


抛出错误日志，进程不退出


HiAppEvent


js crash，cpp crash，app freeze


观察者模式，先注册监听，系统回调后返回回调结果


事件记录和监听，可以监听行为、故障、统计、安全事件


进程退出，再次进入应用处理崩溃信息


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-58
爬取时间: 2025-05-08 03:47:02
来源: Huawei Developer


使用HiLog进行日志打印最多打印4096字节，超出限制文本将被截断。


可以利用HiLog封装log日志打印工具类，解决log信息太长打印不全的问题。


示例如下：


封装LogUtil类：


```typescript
import { hilog } from '@kit.PerformanceAnalysisKit';


class LogUtil {
  private static instance: LogUtil;
  private static DOMAIN: number = 0x0000;


  private constructor() {
    // 私有构造函数，防止外部实例化
  }


  public static getInstance(): LogUtil {
    if (!LogUtil.instance) {
      LogUtil.instance = new LogUtil();
    }
    return LogUtil.instance;
  }


  public logError(logTag: string, content: string) {
    const maxSize = 1024;
    if (content.length <= maxSize) {
      // 长度小于等于限制直接打印
    } else {
      while (content.length > maxSize) {
        // 循环分段打印
        let logContent = content.substring(0, maxSize);
        content = content.replace(logContent, '');
        hilog.error(LogUtil.DOMAIN, logTag, '%{public}s', logContent);
        // 打印剩余日志
      }
    }
    hilog.error(LogUtil.DOMAIN, logTag, '%{public}s', content);
  }


  public logDebug(logTag: string, content: string) {
    const maxSize = 1024;
    if (content.length <= maxSize) {
      // 长度小于等于限制直接打印
    } else {
      while (content.length > maxSize) {
        //循环分段打印
        let logContent = content.substring(0, maxSize);
        content = content.replace(logContent, '');
        hilog.debug(LogUtil.DOMAIN, logTag, '%{public}s', logContent);
        // 打印剩余日志
      }
    }
    hilog.debug(LogUtil.DOMAIN, logTag, '%{public}s', content);
  }


  public logInfo(logTag: string, content: string) {
    const maxSize = 1024;
    if (content.length <= maxSize) {
      // 长度小于等于限制直接打印
    } else {
      while (content.length > maxSize) {
        //循环分段打印
        let logContent = content.substring(0, maxSize);
        content = content.replace(logContent, '');
        hilog.info(LogUtil.DOMAIN, logTag, '%{public}s', logContent);
        // 打印剩余日志
      }
    }
    hilog.info(LogUtil.DOMAIN, logTag, '%{public}s', content);
  }
}


export default LogUtil;
```


使用：


```typescript
import LogUtil from './LogUtilClass';


@Entry
@Component
struct HiLogIsThereALengthLimit {
  build() {
    Row() {
      Column() {
        Button('hilog util')
          .onClick(() => {
          let str = '超长的日志内容';
          let utilInfo = LogUtil.getInstance();
          utilInfo.logInfo('testTag', str);
        })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-59
爬取时间: 2025-05-08 03:47:11
来源: Huawei Developer


可以通过如下命令之一，获取设备的udid：


```less
hdc shell bm get -u
hdc shell bm get --udid
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-analysis-kit-60
爬取时间: 2025-05-08 03:47:21
来源: Huawei Developer


ErrorManager可以提供对错误观察器的注册和注销的能力。


异常监听(ErrorObserver)接口功能介绍：


| 接口名称  | 说明  |
| --- | --- |
| onUnhandledException(errMsg: string): void  | 系统回调接口，应用注册后，当应用产生未捕获的异常时的回调。  |
| onException?(errObject: Error): void  | 系统回调接口，应用注册后，当应用产生异常上报JS层时的回调。  |

接口名称


说明


onUnhandledException(errMsg: string): void


系统回调接口，应用注册后，当应用产生未捕获的异常时的回调。


onException?(errObject: Error): void


系统回调接口，应用注册后，当应用产生异常上报JS层时的回调。


捕获异常代码参考：


Index.ets中：


```typescript
@Entry 
@Component 
struct Index { 
  @State message: string = '捕获异常'; 
 
  build() { 
    Row() { 
      Column() { 
        Button(this.message) 
          .onClick(() => { 
            let tempList = ['0', '1']; 
            tempList[5].toString(); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


EntryAbility.ets中：


```less
import { AbilityConstant, errorManager, UIAbility, Want } from '@kit.AbilityKit'; 
import { hilog } from '@kit.PerformanceAnalysisKit'; 
import { window } from '@kit.ArkUI'; 
 
let callback: errorManager.ErrorObserver = { 
  onUnhandledException: (errMsg) => { 
    console.log('产生未捕获异常时的回调，onUnhandledException:', errMsg); 
    }, 
  onException: (errorObj) => { 
    console.log('产生异常上报JS层时的回调，onException'); 
    console.log('onException, name: ', errorObj.name); 
    console.log('onException, message: ', errorObj.message); 
    if (typeof (errorObj.stack) === 'string') { 
      console.log('onException, stack: ', errorObj.stack); 
    } 
  } 
} 
let abilityWant: Want; 
let registerId = -1; 
 
export default class EntryAbility extends UIAbility { 
  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void { 
    console.log('[Demo] EntryAbility onCreate'); 
    registerId = errorManager.on('error', callback); 
    abilityWant = want; 
    console.log('registerId:', registerId); 
  } 
 
  onDestroy(): void { 
    console.log('[Demo] EntryAbility onDestroy'); 
    errorManager.off('error', registerId, (result) => { 
      console.log('[Demo] result' + result.code + ';' + result.message); 
    }); 
  } 
  // ... 
}
```


参考链接


@ohos.app.ability.errorManager


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-framework-development
爬取时间: 2025-05-08 03:47:30
来源: Huawei Developer

- 程序包结构
- 程序框架
- ArkTS语言
- NDK开发
- UI框架
- 输入法框架
- 本地数据和文件
- 无障碍和本地化
- Web框架

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure
爬取时间: 2025-05-08 03:47:40
来源: Huawei Developer

- HSP打包后，为什么会生成HAR包，它是否会导致App包大小膨胀
- 从包管理的角度，保证代码安全的措施有哪些
- 如何理解App、HAP、HAR的关系
- HSP/HAR包中如何引用外部编译的so库文件
- SharedLibrary能否在配置文件中声明abilities、extensionAbilities标签
- HAR包中使用window作为Toast时无法引入页面组件
- 业务模块HAR如何获取宿主HAP的数据
- 如何通过路由跳转到一个只有页面没有UIAbility的模块
- 如何安装打包出来的App包（通过什么命令安装）
- 如何判断应用可被卸载
- HAR、HSP不能支持ability、Page声明，限制的理由是什么？后续是否会支持
- 是否允许HAR的循环依赖
- HAP依赖HAR A，HAR A依赖HAR B，HAP能否调用HAR B提供的接口？如果不支持间接依赖HAR，这么设计的原因是什么？
- 通过resourceManager.getStringResource接口获取HSP资源文件报“Resource id invalid”错误
- HAP/HAR/HSP的关系是什么？是否都可以声明注册Ability和Page？三种类型分别推荐哪些的使用场景？选择原则是什么
- 如何正确引用HAR/HSP包模块
- 从HAP的拆包中，如何区分是HAR和HSP
- 在HAP中调用createModuleContext方法获取的Context是什么层级
- 如何获取当前HAP的BundleName
- 如何实现在不使用UIAbility的情况下，能够模块化管理代码，并且各个模块之间可以相互路由跳转
- Entry模块的HAP和Feature模块的HAP在使用和功能上的区别是什么
- 在HSP export类时，ts文件是按.d.ts导出还是.d.ets导出
- 如何避免module下文件打包进HAR包后，存在的不可预期的资料、配置或信息安全风险
- HAR包多帐号如何上传
- HSP包编译之后的.har文件的作用是什么
- 如何使HSP包版本号统一
- 如何将多工程的HAP打包成一个App
- 对于HAP包中引用的HSP包是否有数量限制
- har如何转换为hsp
- HAR包是否支持依赖传递
- 如何实现跨模块的页面跳转功能
- 如何卸载debug包
- 应用安装、卸载时是否有数据上报
- 如何解决依赖的版本冲突问题
- 为什么同一App下的HSP文件vendor参数不同时会安装失败
- 如何让两个HSP不相互依赖，使用对方的组件
- 应用安装到设备的方式有哪些
- HAR和HSP的使用场景介绍
- 一个HSP模块如何快速切换成HAR模块？
- 是否推荐使用bm quickfix 制造修复包
- 使用hdc命令安装release HAP包到设备时上报“INSTALL_FAILED_APP_SOURCE_NOT_TRUSTED”错误
- 如何查询应用包的名称、供应商、版本号、版本文本、安装时间、更新时间描述信息
- 如何安装打包出来的App包（通过什么命令安装）
- 如何判断应用可被卸载
- 应用免安装的限制、字段解释以及如何自测
- 安装HAP包报“failed to install bundle. install debug type not same”错误
- 除应用市场外，是否存在其它途径下载安装应用包
- 发布签名发生变更后，用户是否需要先卸载原来的应用才能安装签名变更的应用
- 在AGC平台生成新的profile签名文件(.p7b)，更新到HarmonyOS工程重新打包安装时提示：”code:9568322 error: signature verification failed due to not trusted app source”
- 如何判断当前应用程序是Debug包还是Release包
- 如何判断应用程序是否安装
- 如何跨HSP包调用rawfile目录下的文件
- 如何获取应用包的签名指纹信息，即“.p12文件”信息
- 使用发布证书进行调试时出现安装错误: Install Failed: error: failed to install bundle.
- 使用HSP的多包场景下，直接崩溃并产生cppcrash异常日志，错误信息为resolveBufferCallback get buffer failed
- HAP包中的“--Begin Certificate--”是什么格式的数据
- sign包和unsign包产物之间是否有差异
- 如何在应用内共享HSP

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-2
爬取时间: 2025-05-08 03:47:50
来源: Huawei Developer


HSP编译产生的HAR，只含有配置文件和接口定义，不含有代码逻辑，而且该HAR包仅用于开发态，并不会影响App包的大小。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-4
爬取时间: 2025-05-08 03:48:02
来源: Huawei Developer

- 编译：HAR、HSP在编译构建时支持代码混淆的功能。
- 打包：每个HSP/HAP单独签名，只有签名后的应用才允许安装。
- 安装：终端设备用户终端设备上需要使用应用市场进行安装和卸载，无法通过其他方式安装。
- 运行时：提供应用沙箱机制，它是一种以安全防护为目的的隔离机制，避免数据受到恶意路径穿越访问。

参考链接


代码混淆，Stage模型应用程序包结构，应用程序包安装卸载与更新，应用沙箱目录


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-5
爬取时间: 2025-05-08 03:48:11
来源: Huawei Developer

- App是发布上架到应用市场的基本单元，但是不能在设备上直接安装和运行。
- HAP（Harmony Ability Package）是应用安装和运行的基本单元。HAP包是由代码、资源、第三方库、配置文件等打包生成的模块包，其主要分为两种类型：entry和feature。
- HAR（Harmony Archive）是静态共享包，可以包含代码、C++库、资源和配置文件。通过HAR可以实现多个模块或多个工程共享ArkUI组件、资源等相关代码。
- HSP（Harmony Shared Package）是动态共享包，可以包含代码、C++库、资源和配置文件，通过HSP可以实现代码和资源的共享。HSP不支持独立发布，而是跟随其宿主应用的App包一起发布，与宿主应用同进程，具有相同的包名和生命周期。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-6
爬取时间: 2025-05-08 03:48:21
来源: Huawei Developer

1. 

```less
// CMakeLists.txt链接so库文件
target_link_libraries(entry PUBLIC libxxx)
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160817.27831922857076289761554890885197:50001231000000:2800:85B58CCF555A15C899CF1FD48D742E18DFC83F953452E9AB2B02D4523A001D27.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-7
爬取时间: 2025-05-08 03:48:31
来源: Huawei Developer


SharedLibrary创建的HSP包，当前不支持在配置文件中声明abilities、extensionAbilities标签。详细信息请参考以下链接。


参考链接


HSP


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-8
爬取时间: 2025-05-08 03:48:41
来源: Huawei Developer


问题现象


在HAR包中利用一个window作为弹窗，该window通过一个page页面实现，使用window.setUIContent方法引入page时，无法导入。


解决措施


参考链接


自定义弹窗


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-9
爬取时间: 2025-05-08 03:48:50
来源: Huawei Developer


把需要获取的信息当做参数传入，HAR提供方法给HAP，HAP调用HAR的接口把需要的HAP中的信息传入到HAR里面，这样HAR可以获取到HAP里面的数据。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-10
爬取时间: 2025-05-08 03:49:00
来源: Huawei Developer


问题现象


现在有模块A，B。A模块为Entry类型，其中有个UIAbility，有pages。B模块是Feature类型，没有UIAbility，但是有pages。整个App只想使用一个UIAbility的情况下，A模块怎么跳转到B模块的页面。


解决措施

- Module分为“Ability”和“Library”两种类型：“Ability”类型的Module对应于编译后的HAP；“Library”类型的Module对应于HAR或者HSP
- HAP可分为Entry和Feature两种类型：Entry类型的HAP是应用的主模块，通常用于实现应用的入口界面、入口图标、主特性功能等；Feature类型的HAP是应用的动态特性模块，通常用于实现应用的特性功能，可以配置成按需下载安装。
- HAR静态共享包，和HSP动态共享包，都是为了实现代码和资源的共享，都可以包含代码、C++库、资源和配置文件。其中HAR不支持在配置文件中声明pages页面，HSP支持配置pages页面。

对于没有UIAbility但依然提供可跳转页面的模块，应该考虑使用Library类型的HSP实现相应的功能，从UIAbility跳转HSP中的页面可参考：跨包路由。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-13
爬取时间: 2025-05-08 03:49:10
来源: Huawei Developer


App资源包是无法直接安装的，需要通过应用市场下载才能安装，最后通过解析App包安装的还是HAP包。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-14
爬取时间: 2025-05-08 03:49:20
来源: Huawei Developer


参考链接


ApplicationInfo


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-15
爬取时间: 2025-05-08 03:49:29
来源: Huawei Developer


Page：HAR和HSP支持page；只不过HAR中的page需要通过命名路由的方式跳转，详见下面的参考资料。


Ability：HAR和HSP不支持，后续也没有支持的计划，推荐在HAP中配置Ability。


参考链接


命名路由


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-16
爬取时间: 2025-05-08 03:49:39
来源: Huawei Developer


不允许循环依赖。可以把公共部分放到一个共享包中，或者使用动态import实现依赖解耦


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-17
爬取时间: 2025-05-08 03:49:49
来源: Huawei Developer


不支持传递依赖。


间接依赖的版本是不可控的，如果代码里使用到某个版本的间接依赖，不同时间安装的依赖可能版本不一致，程序运行可能出现意想不到的错误。举例说明：依赖关系：project->A(1.0.0)->B(^1.0.0)->C (latest)


在dependencies只声明了A，但是工程中import了B和C。而B和C的版本是不可控的，如果C的开发者发布了一个2.0.0的版本，下次安装依赖时，可能会安装C的2.0.0的版本。然后就有可能出现一些问题，例如：在代码没有任何改动的情况下，程序运行却出现报错，不同时间不同PC上构建的应用运行表现不一致等。


所以ohpm为了解决幽灵依赖的问题，设计了一个特殊的存储结构，从技术上进行限制、不允许引用间接依赖，从而避免出现幽灵依赖问题。在上面例子中表现就是：代码里只能引用A，引用B或C就会编译报错，提醒用户修改依赖配置。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-18
爬取时间: 2025-05-08 03:49:58
来源: Huawei Developer


问题现象


通过this.resourceManager.getStringResource($r('app.string.PlayCount').id)获取hsp资源文件报错：


Error message：Resource id invalid


Error code：9001001


SourceCode：returnResource = this.context.resourceManager.getStringSync(id)。


可能原因


未创建对应的context，传入的是一个不存在的id值。


解决措施


根据模块名创建上下文Context，然后通过getStringByNameSync获取指定资源名称对应的字符串，具体请参考示例代码：


```typescript
import { common, application } from '@kit.AbilityKit';
import { promptAction } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
import { JSON } from '@kit.ArkTS';


@Entry
@Component
struct Index {
  private context = getContext(this) as common.UIAbilityContext;


  build() {
    Column() {
      Button()
        .onClick(() => {
          // 根据模块名创建上下文Context
          let moduleName: string = 'library';
          application.createModuleContext(this.context, moduleName)
            .then((data: common.Context) => {
              console.info(`CreateModuleContext success, data: ${JSON.stringify(data)}`);
              if (data !== null) {
                promptAction.showToast({
                  message: ('成功获取Context')
                });
              }


              // 然后通过getStringByNameSync获取指定资源名称对应的字符串
              try {
                let str = data.resourceManager.getStringByNameSync('shared_desc');
                console.info(`getStringByNameSync, data: ${JSON.stringify(str)}`);
              } catch (error) {
                let code = (error as BusinessError).code;
                let message = (error as BusinessError).message;
                console.error(`getStringByNameSync failed, error code: ${code}, message: ${message}.`);
              }
            })
            .catch((err: BusinessError) => {
              console.error(`CreateModuleContext failed, err code:${err.code}, err msg: ${err.message}`);
            });
        })
    }
  }
}
```


参考链接


应用上下文Context、获取本应用中其他module的context、getStringByNameSync


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-19
爬取时间: 2025-05-08 03:50:07
来源: Huawei Developer


HAP：应用安装和运行的基本单元。支持在配置文件中声明abilities、extensionAbilities组件，支持在配置文件中声明pages页面。


主要使用场景：

- Entry：应用的主模块，用于实现应用的入口界面、入口图标、主特性功能等。
- Feature：应用的特性模块，用于实现应用的特性功能。

HAR：静态共享包。编译态复用，不支持在配置文件中声明abilities、extensionAbilities组件，不支持在配置文件中声明pages页面，支持Navigation组件导航。


主要使用场景：

- 作为二方库，发布到OHPM私仓，供公司内部其他应用依赖使用。
- 作为三方库，发布到OHPM中心仓，供其他应用依赖使用。

HSP：动态共享包。运行时复用，不支持在配置文件中声明abilities、extensionAbilities组件，支持在配置文件中声明pages页面。


主要使用场景：

- 多模块共用的代码、资源可以使用HSP，提高代码的可重用性和可维护性。
- 元服务分包预加载。

参考链接


Stage模型应用程序包结构


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-21
爬取时间: 2025-05-08 03:50:17
来源: Huawei Developer


在HarmonyOS应用开发过程中，处理包（HAR/HSP）模块间的依赖是一个常见的需求。正确的依赖处理方式不仅能确保代码的模块化和可维护性，还能减少团队开发中的管理和沟通成本。以下是关于如何引用包模块的推荐和不推荐做法。

-  import { add } from "library";
-  使用相对路径或绝对路径进行引用，虽然技术上可行，但这种做法不推荐。使用相对或绝对路径引用模块会破坏模块间的隔离性，增加团队开发的管理和沟通成本，且难以维护。例如： import { add } from "../../library/src/main/ets/page/Index";

总结来说，为了保持代码的模块化、提高可维护性以及降低团队协作的复杂度，推荐使用包名进行模块间的依赖引用。避免使用相对或绝对路径，以维护项目的结构清晰和高效的团队合作。更多请参见HAR包。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-23
爬取时间: 2025-05-08 03:50:26
来源: Huawei Developer


HAP包拆包只能在module.json文件的dependencies字段看到引用的HSP模块名，看不到引用的HAR。这是因为HAR在编译的时候已经打包在HAP包里了。HSP是单独成包的，.app文件安装时HSP与HAP是处于同一级别的。


参考链接


HAP、HAR、HSP


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-25
爬取时间: 2025-05-08 03:50:36
来源: Huawei Developer


参考链接


应用上下文Context


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-26
爬取时间: 2025-05-08 03:50:46
来源: Huawei Developer


通过bundleManager模块的getBundleInfoForSelf接口获取所有信息：


GET_BUNDLE_INFO_DEFAULT：接口默认的参数，返回结果的name字段对应BundleName。


GET_BUNDLE_INFO_WITH_APPLICATION：除基本字段外，能够额外获取到ApplicationInfo字段，ApplicationInfo的name字段也对应BundleName。


下面代码以GET_BUNDLE_INFO_DEFAULT为例：


```less
import { bundleManager } from '@kit.AbilityKit'; 
import { hilog } from '@kit.PerformanceAnalysisKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
let bundleFlags = bundleManager.BundleFlag.GET_BUNDLE_INFO_DEFAULT; 
try { 
    bundleManager.getBundleInfoForSelf(bundleFlags).then((data) => { 
        hilog.info(0x0000, 'testTag', 'getBundleInfoForSelf successfully. Data: %{public}s', JSON.stringify(data)); 
    }).catch((err: BusinessError) => { 
        hilog.error(0x0000, 'testTag', 'getBundleInfoForSelf failed. Cause: %{public}s', err.message); 
    }); 
} catch (err) { 
    let message = (err as BusinessError).message; 
    hilog.error(0x0000, 'testTag', 'getBundleInfoForSelf failed: %{public}s', message); 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-27
爬取时间: 2025-05-08 03:50:56
来源: Huawei Developer


采用HSP进行模块管理，可以实现页面之间的跳转，无需导入导包即可跳转，跳转方式如下：


方式一：所有跳转到HSP内的页面需要使用特定的格式跳转：’@bundle:包名（bundleName）/模块名（moduleName）/路径/页面所在的文件名(不加.ets后缀)’。


方式二：正常entry内模块路由跳转：‘pages/页面所在的文件名(不加.ets后缀)’。

- entry跳转到HSP页面：使用方式一。
- HSP跳转到entry页面：使用方式二。
- HSP跳转到HSP页面：使用方式一。

参考链接


HSP


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-28
爬取时间: 2025-05-08 03:51:07
来源: Huawei Developer

- Entry类型的HAP：是应用的主模块，在module.json5配置文件中的type标签配置为“entry”类型。在同一个应用中，同一设备类型只支持一个Entry类型的HAP，通常用于实现应用的入口界面、入口图标、主特性功能等。
- Feature类型的HAP：是应用的动态特性模块，在module.json5配置文件中的type标签配置为“feature”类型。一个应用程序包可以包含一个或多个Feature类型的HAP，也可以不包含；Feature类型的HAP通常用于实现应用的特性功能，可以配置成按需下载安装，也可以配置成随Entry类型的HAP一起下载安装。

参考链接


应用程序包结构


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-29
爬取时间: 2025-05-08 03:51:17
来源: Huawei Developer


在HSP export类时，若是ts文件则按照.d.ts导出。编译HSP模块后可在“build/default/outputs/default/xxx.har”中查看。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-31
爬取时间: 2025-05-08 03:51:26
来源: Huawei Developer

1.  需注意：更改.ohpmignore配置后，需要清空相应模块的build文件夹，或点击DevEco Studio的Build -> clean project后再打包。
2.  开启方式：打开模块级build-profile.json5文件，在“obfuscation”字段中配置混淆功能： 配置如下： 具体内容可参考链接：代码混淆。

```less
{
  "apiType": "stageMode",
  ...
  "buildOptionSet": [
    {
      "name": "release",
      "arkOptions": {
        "obfuscation": {
          "ruleOptions": {
            "enable": true, // true表示进行混淆，false表示不进行混淆。默认值为false
            "files": [
              "./obfuscation-rules.txt"  // 混淆规则文件
            ]
          }
        }
      }
    },
  ],
  ...
}
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160818.82682762098008416590101533561317:50001231000000:2800:134EC5A8F4DFF94BB51FEB26128E7DC7AF5A0E2B54CD3DC80E55B685F97F5874.png)
- "enable"：配置是否开启混淆。
- "files"：配置混淆规则文件路径。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-32
爬取时间: 2025-05-08 03:51:36
来源: Huawei Developer


HAR包一般只能第一任作者上传，如果新建的包，想要多帐户都能上传，需要在模块级oh-package.json5文件的name字段，配置<@group>/<package>类型的值，如"@hw-one/hhshs"。如果带有<@group>类型的值的包则需要在仓上先新建组织，再添加用户进组织才能上传。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-33
爬取时间: 2025-05-08 03:51:46
来源: Huawei Developer


HSP包编译后会有.hsp文件和.har文件，其中.hsp文件是用来安装的，.har文件很小，没有具体的实现，只暴露接口。


HSP包中导出的方法的头文件在.har文件里，实现在.hsp文件里。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-34
爬取时间: 2025-05-08 03:51:56
来源: Huawei Developer


问题场景


当开发模式是多个业务团队各自开发各自的模块时，很难保证每个团队的HSP版本号都是一致的，即使版本号起初一致，后续某个团队升级了版本号，那么其他没有修改代码的团队也要重新升级版本号重新打包。


解决措施


HSP和宿主HAP一起安装时，校验非常严格：包名、版本号、sdk版本号、releaseType这些全部需要一致。可以通过打包工具：版本归一指令（versionNormalize），将多个HAP、HSP的版本统一。


示例：


```less
java -jar path\app_packing_tool.jar --mode versionNormalize --input-list 1.hap,2.hsp --version-code 1000001 --version-name 1.0.1 --out-path path\out\
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-35
爬取时间: 2025-05-08 03:52:06
来源: Huawei Developer

1.  summary.app 为整个包的配置信息，保证唯一。summary.modules 和 packages 取模块级别 pack.info 文件中相对应的第1个值填入。

```less
{
  summary: {
    app: {
      bundleName: "bundleName",
      version: {
        name: "name",
        code: 0
      }
    },
    modules: []
  },
  packages: []
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-36
爬取时间: 2025-05-08 03:52:15
来源: Huawei Developer


目前没有数量限制。


但是由于每个加载的HSP都需要占用一定的系统资源，过多的HSP包会对应用的性能造成影响。


如果应用中HSP包数量过多，建议使用单HAP与多HAR方案，在动态加载场景中使用HSP。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-37
爬取时间: 2025-05-08 03:52:25
来源: Huawei Developer


HAR转为HSP主要是通过相关配置文件的修改实现的。具体方式可参考以下步骤：


配置更改完成后即可重新编译。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-38
爬取时间: 2025-05-08 03:52:35
来源: Huawei Developer


问题现象


例如有三个HAR分别为A、B、C，A依赖B，B依赖C。A是否可以引用C的资源？


解决措施


不支持A直接引用C的资源。A需要直接依赖C，即可引用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-39
爬取时间: 2025-05-08 03:52:45
来源: Huawei Developer


在业务体系庞大或复杂的情况下，通常会将业务拆分成多个子业务模块，单个子业务模块为一个har/hsp。在该场景下，通常存在从主业务入口跳转到不同子页面模块，或从一个子业务模块A页面跳转到另一个子业务模块B页面的需求。如，从应用首页跳转到登录子业务模块页面。 针对该场景，有以下三种解决方案：

-  参考地址：页面路由 (@ohos.router)
-  以从应用入口模块的页面NavigationPage跳转到Login子业务模块页面LoginPage为例。主要包含以下步骤： export { LoginPage } from './src/main/ets/pages/loginPage';

```typescript
@Component 
export struct LoginPage { 
  @Consume('pathStack') pathStack: NavPathStack; 
  @State message: string = 'Login Page'; 
 
  build() { 
    NavDestination() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
      } 
      .width('100%') 
      .height('100%') 
    } 
    .onBackPressed(() => { 
      this.pathStack.pop(); 
      return true; 
    }) 
  } 
}
```


```typescript
@Component 
export struct LoginPage { 
  @Consume('pathStack') pathStack: NavPathStack; 
  @State message: string = 'Login Page'; 
 
  build() { 
    NavDestination() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
      } 
      .width('100%') 
      .height('100%') 
    } 
    .onBackPressed(() => { 
      this.pathStack.pop(); 
      return true; 
    }) 
  } 
}
```

-  export { LoginPage } from './src/main/ets/pages/loginPage';

```less
{ 
  // ... 
  "dependencies": { 
    "@ohos/login": "file:../login" 
  } 
}
```


```typescript
// 导入Login模块自定义组件 
import { LoginPage } from '@ohos/login'; 
 
@Entry 
@Component 
struct NavigationPage { 
  @Provide('pathStack') pathStack: NavPathStack = new NavPathStack(); 
 
  @Builder 
  pageMap(name: string) { 
    if (name === 'loginPage') { 
      LoginPage() 
    } 
  } 
 
  build() { 
    Navigation(this.pathStack) { 
      Button('jump to login page') 
        .onClick(() => { 
          // NavPathInfo第二个参数为自定义参数，可用于信息传递 
          let pathInfo: NavPathInfo = new NavPathInfo('loginPage', new Object()); 
          this.pathStack.pushDestination(pathInfo, true); 
        }) 
    } 
    .navDestination(this.pageMap) 
  } 
}
```

-  方案二虽然可以实现跨模块跳转的功能，但当模块间跳转需求增多，各个模块间将存在非常复杂的依赖关系，甚至会导致多个har/hsp间循环依赖。为了解决模块间的强耦合关系，并且提升页面加载性能，推荐跨包动态路由。

```typescript
@Component 
export struct LoginPage { 
  @Consume('pathStack') pathStack: NavPathStack; 
  @State message: string = 'Login Page'; 
 
  build() { 
    NavDestination() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
      } 
      .width('100%') 
      .height('100%') 
    } 
    .onBackPressed(() => { 
      this.pathStack.pop(); 
      return true; 
    }) 
  } 
}
```

1.  export { LoginPage } from './src/main/ets/pages/loginPage';

```less
{ 
  // ... 
  "dependencies": { 
    "@ohos/login": "file:../login" 
  } 
}
```


```typescript
// 导入Login模块自定义组件 
import { LoginPage } from '@ohos/login'; 
 
@Entry 
@Component 
struct NavigationPage { 
  @Provide('pathStack') pathStack: NavPathStack = new NavPathStack(); 
 
  @Builder 
  pageMap(name: string) { 
    if (name === 'loginPage') { 
      LoginPage() 
    } 
  } 
 
  build() { 
    Navigation(this.pathStack) { 
      Button('jump to login page') 
        .onClick(() => { 
          // NavPathInfo第二个参数为自定义参数，可用于信息传递 
          let pathInfo: NavPathInfo = new NavPathInfo('loginPage', new Object()); 
          this.pathStack.pushDestination(pathInfo, true); 
        }) 
    } 
    .navDestination(this.pageMap) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-40
爬取时间: 2025-05-08 03:52:55
来源: Huawei Developer


可以通过以下两种方式：

- 方式一：执行”hdc shell bm uninstall -n bundleName”命令
- 方式二：直接点击图标进行卸载。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-41
爬取时间: 2025-05-08 03:53:05
来源: Huawei Developer


可以通过“下载安装”报表获取安装卸载量，“下载安装”报表默认展示当前应用在所有业务类型（AppGallery和AppTouch）下的“详情页转化率”、“总下载成功次数”、“新下载成功次数”、“更新下载成功次数”、“卸载次数”等重点指标概览、图表及详细数据，并提供表格下载功能。


参考链接


下载安装


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-43
爬取时间: 2025-05-08 03:53:15
来源: Huawei Developer


发生依赖的版本冲突时，可以给项目级别的oh-package.json5文件配置override字段统一版本。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-44
爬取时间: 2025-05-08 03:53:24
来源: Huawei Developer


因为安装时会有参数一致性的校验，需要保证module.json中app标签下的vendor字段一致。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-45
爬取时间: 2025-05-08 03:53:34
来源: Huawei Developer


可以将需要共用的组件抽离出来，然后放到一个共享包中使用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-47
爬取时间: 2025-05-08 03:53:44
来源: Huawei Developer


支持两种方式安装HAP包到设备：

- 通过hdc命令安装：hdc install xxx.hap
- 将.app文件上架到应用市场后，通过应用市场将HAP分发部署到设备中

参考链接


发布应用（APP）


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-48
爬取时间: 2025-05-08 03:53:54
来源: Huawei Developer


解决方案


HAR主要使用场景：二方库、三方库。


HSP主要使用场景：元服务分包预加载、按需加载。


参考资料


应用程序包开发与使用


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-49
爬取时间: 2025-05-08 03:54:03
来源: Huawei Developer


解决方案


1.在HSP下的module.json5中，把"type": "shared"修改为"type": "har"，删除"deliveryWithInstall"、"pages"字段；


2.删除HSP下的oh-package.json5中"packageType"字段；


3.删除HSP中的页面，如果要以页面的形式使用到的话，就需要改为命名路由的写法；


4.然后再找到HSP下的hvigorfile.ts文件，将里面的hspTasks改为harTasks；


5.最后编译该模块即可。


如编译过程中遇到其他错误，按照提示找到对应位置修改即可。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-50
爬取时间: 2025-05-08 03:54:13
来源: Huawei Developer


当前不推荐手动制作HQF包，推荐使用热重载能力。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-51
爬取时间: 2025-05-08 03:54:23
来源: Huawei Developer


问题现象


release hap包用hdc命令安装到手机上时报错:"INSTALL_FAILED_APP_SOURCE_NOT_TRUSTED"。


解决措施


AGC发布的证书不支持本地安装只能用于上架，签名中心只给预置应用申请Profile，不支持本地调试。


参考链接


调试概述


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-52
爬取时间: 2025-05-08 03:54:33
来源: Huawei Developer


首先通过bundleManager.getBundleInfoForSelf()接口获取应用包的名称（BundleName）、供应商、版本号、版本文本、安装时间、更新时间描述信息。具体可参考示例代码：


```less
import { bundleManager } from '@kit.AbilityKit'; 
 
// 申请获取bundleInfo和applicationInfo 
let bundleFlags = bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION; 
 
try { 
  bundleManager.getBundleInfoForSelf(bundleFlags, (err, data) => { 
    // 获取应用自身的bundleName 
    const bundleName = data.name; 
    // 获取应用的版本号（versionCode） 
    const versionCode = data.versionCode; 
    // 获取应用的版本名（versionName） 
    const versionName = data.versionName; 
 
    if (err) { 
      console.error(`getBundleInfoForSelf failed: ${err.message}`); 
    } else { 
      console.info(`get bundleName successfully: ${bundleName}`); 
      console.info(`get versionCode successfully: ${versionCode}`); 
      console.info(`get versionName successfully: ${versionName}`); 
      console.info(`getBundleInfoForSelf successfully: ${JSON.stringify(data)}`); 
    } 
  }); 
} catch (err) { 
  console.error(`getBundleInfoForSelf failed: ${JSON.stringify(err)}`); 
}
```


参考链接


getBundleInfoForSelf


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-54
爬取时间: 2025-05-08 03:54:43
来源: Huawei Developer


App资源包是无法直接安装的，需要通过应用市场下载才能安装，最后通过解析App包安装的还是HAP包。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-55
爬取时间: 2025-05-08 03:54:52
来源: Huawei Developer


参考链接


ApplicationInfo


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-56
爬取时间: 2025-05-08 03:55:02
来源: Huawei Developer

- 免安装限制：免安装HAP大小限制是10M。10M是针对所有要打进App的总大小，如果App内有多个HAP，是所有HAP加在一起。分包时，额外需要满足：每个文件的大小不能大于2M。
- DeliveryWithInstall：配置应用的可选安装功能。具体场景是，在应用市场下载安装时是否跟随应用一起安装。Entry模块的本字段允许设置为false。配置为True的HAP包也会被计算在免安装的10M限制中。
- InstallationFree：标识当前Module是否支持免安装特性。Entry模块也支持免安装，但当应用的Entry类型Module的该字段配置为true时，该应用的Feature类型的该字段也需要配置为true。
- 自测：需要开发者自己写一个服务中心，mock一个服务中心处理免安装请求。

参考链接


module.json5配置文件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-57
爬取时间: 2025-05-08 03:55:11
来源: Huawei Developer


可能原因


HAP包与设备上已安装的HAP包debug信息不一致导致。


解决措施

1. 
2. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160819.33354416043787185978746060875404:50001231000000:2800:F4D2E642A8D15D660AD51CCCCA69F3FA92825440921E28DBC890446EDC07E579.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160819.52098715659814511104595411315429:50001231000000:2800:74FBD04C17F91673C0E03B1441BB03FDD585C21E7449DA8487E475EE2092C419.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-58
爬取时间: 2025-05-08 03:55:21
来源: Huawei Developer


HarmonyOS NEXT版本普通应用用户有且仅可通过应用市场一个途径下载并安装应用包，不存在其他途径，仅支持通过应用市场下载并安装应用包。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-59
爬取时间: 2025-05-08 03:55:31
来源: Huawei Developer


需要，签名变化了就需要先卸载再安装。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-60
爬取时间: 2025-05-08 03:55:41
来源: Huawei Developer


.p7b的distribution-certificate字段内容在.cer文件中找不到，属于.p7b文件有误，在AGC平台正确操作后重新生成一份.p7b文件即可解决。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-61
爬取时间: 2025-05-08 03:55:50
来源: Huawei Developer


在编译构建时，Hvigor会生成BuildProfile类，可以通过该类在运行时获取编译构建参数，BuildProfile.BUILD_MODE_NAME即为编译模式。


参考链接


获取自定义编译参数-能力说明


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-62
爬取时间: 2025-05-08 03:55:59
来源: Huawei Developer


为了便于应用A判断设备上是否有安装应用B，从而决定是否引导用户去下载应用B，需要应用A、B做如下配置：


应用B配置，在entry模块的 module.json5文件中添加配置具体标签路径如下：module-> abilities -> skills-> 添加 uris


```less
{ 
  "abilities": [ 
    { 
      "skills": [ 
        { 
          "actions": [ 
            "ohos.want.action.home", 
            "ohos.want.action.viewData" 
          ], 
          "entities": [ 
            "entity.system.home" 
          ], 
          "uris": [ 
            { 
              "scheme":"schB", 
              "host":"com.example.test", 
              "path":"open", 
            } 
          ], 
        } 
      ] 
    } 
  ] 
}
```


应用A配置，在entry模块的module.json5文件中添加配置具体标签路径如下：module-> querySchemes


```json
"querySchemes": [ 
  "schB" 
]
```


应用A判断设备上是否安装了应用B


```typescript
import { hilog } from '@kit.PerformanceAnalysisKit'; 
import { bundleManager } from '@kit.AbilityKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
@Entry 
@Component 
struct Index { 
  // 应用A判断设备上是否安装了应用B 
  isAppBExist() { 
    let exist = false; 
    try { 
      let link = 'schB://com.example.test/open'; 
      let data: boolean = bundleManager.canOpenLink(link); 
      hilog.info(0x0000, 'testTag', 'canOpenLink successfully: %{public}s', JSON.stringify(data)); 
      exist = data; 
    } catch (err) { 
      let message = (err as BusinessError).message; 
      hilog.error(0x0000, 'testTag', 'canOpenLink failed: %{public}s', message); 
      exist = false; 
    } 
    console.info('是否安装了应用B：' + exist); 
  } 
 
  @State text: string = 'isAppBExist' 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.text) 
          .fontSize(30) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            this.isAppBExist(); 
          }); 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


bundleManager.canOpenLink


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-63
爬取时间: 2025-05-08 03:56:09
来源: Huawei Developer


解决方案


建议通过导出资源的方式给另外一个模块使用，详见参考资料中的“导出HSP中的资源”。


参考资料


导出HSP中的资源。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-64
爬取时间: 2025-05-08 03:56:19
来源: Huawei Developer


建议通过DevEco Studio自动化签名后，在.p12文件右侧有个指纹按钮进行复制获取。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-65
爬取时间: 2025-05-08 03:56:29
来源: Huawei Developer


应用市场发布的发布证书，无法通过非应用市场渠道安装，如果需要测试发布证书应用，请使用AGC->开放式测试。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-66
爬取时间: 2025-05-08 03:56:38
来源: Huawei Developer


该问题是由于HSP包解析失败导致，常见加载失败原因有安装失败、文件丢失、缺少权限、安全内存校验失败等，开发者可以根据关键日志进行排查。通常情况下，重新安装应用即可恢复。


| 已知关键错误日志  | 修改建议  |
| --- | --- |
| realHapPath is empty  | 路径查询失败，无法获取用户安装包信息。建议开发者重新安装应用。  |
| transform real path error: ERROR, pathName: PATH  | 使用realpath函数解析路径失败，ERROR表示错误信息，PATH表示hsp路径。建议开发者重新安装应用。  |
| CreateFileMapper, mmap failed, errno ERROR. fileName: FILENAME  | 使用mmap函数映射安全内存映射失败，ERROR表示错误信息，FILENAME表示文件名。常见原因是系统内存不足、文件未签名。  |

已知关键错误日志


修改建议


realHapPath is empty


路径查询失败，无法获取用户安装包信息。建议开发者重新安装应用。


transform real path error: ERROR, pathName: PATH


使用realpath函数解析路径失败，ERROR表示错误信息，PATH表示hsp路径。建议开发者重新安装应用。


CreateFileMapper, mmap failed, errno ERROR. fileName: FILENAME


使用mmap函数映射安全内存映射失败，ERROR表示错误信息，FILENAME表示文件名。常见原因是系统内存不足、文件未签名。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-67
爬取时间: 2025-05-08 03:56:47
来源: Huawei Developer


证书签名时，支持DER和PEM的格式，“--Begin Certificate--”是DER格式的数据，可以直接使用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-68
爬取时间: 2025-05-08 03:56:57
来源: Huawei Developer


包产物之间没有差异，签名信息是写在zip的格式里的，所以解压看到的是没区别的。可以用文本编辑器直接打开hap进行比较，打开后可以搜索一下 distribution-certificate，签名的包会把证书信息写进去。


有没有使用签名文件，主要在安装的时候有差异：

- 没有签名的包就需要在安装的时候配置签名信息。
- 有在线签名的，会绑定设备id，别的设备安装不了。
- 有自动签名的可以在别的设备安装

参考链接


应用/元服务签名


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-package-structure-69
爬取时间: 2025-05-08 03:57:07
来源: Huawei Developer


如需在应用内共享HSP，请将HSP共享包上传至私仓，HSP包不能直接发布在私仓内，需要先转化为.tgz包，请先按以下操作编译生成*.tgz包。

1. 
2. 
3. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160819.17602730580384584102121795411124:50001231000000:2800:68857DDBD29E2593BCF551C4ED2116D94909E6FA9C9F659126E3D5A67C7BF502.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160819.08442217290852744485626647340462:50001231000000:2800:CB3EAB7158A17DD34A7DD4E07658626AE34859577DB4A83932A63BE22661999E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160819.77652383431300026246530718514226:50001231000000:2800:34AB19A60F7DF452AD12E97B060BA68A392013C482F7BB3587072928FAE7B78C.png)

参考链接


编译HSP模块


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability
爬取时间: 2025-05-08 03:57:15
来源: Huawei Developer

- 程序框架（Ability）
- 后台任务开发（Background Tasks）
- 进程间通信（IPC）
- 卡片开发（Form）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-kit
爬取时间: 2025-05-08 03:57:25
来源: Huawei Developer

- 如何获取设备横竖屏的状态变化通知
- 如何使用AbilityStage的生命周期函数
- 如何在UIAbility调用terminateSelf()后设置不保留最近任务列表中的快照
- 如何主动退出整个应用
- 通过隐式Want拉起浏览器应用时报“16000050”错误
- 部署HAP时上报“Failure[INSTALL_FAILED_SIZE_TOO_LARGE] error while deploying hap”错误
- 如何获取当前应用程序缓存目录
- 如何获取应用级别的temp路径和files路径
- 服务卡片EntryFormAbility生命周期回调函数在哪个ArkTS文件中调用
- 多Module应用通过startAbility()启动时报错
- UIAbility在onBackground执行耗时操作时是否会影响另外一个UIAbility的onForeground
- getContext(this)能否在自定义类中使用
- 应用的进程启用过程是怎样的
- 是否允许三方应用在手机设备上Fork进程
- 两个UIAbility之间可通过哪些方法实现数据传递
- Extension类进程崩溃是否会导致主进程崩溃
- 多个UIAbility是运行在一个进程还是多个进程中？三方应用是否支持应用运行在多个进程下？主进程结束了，会影响子进程的运行吗？
- ExtensionAbility如何与主进程通信？
- 如何在页面中订阅UIAbility实例的生命周期变化
- onUnhandledException与onException回调分别什么时候触发
- TaskPool里面是否可以使用EventHub
- hdc shell命令是否支持schema uri模拟跳转
- 是否可以通过ApplicationContext启动UIAbility
- Stage模型与FA模型在进程内对象共享方面有哪些差异
- 如何实现通过调用其他已安装的应用来打开特定文件
- 如何拉起拨号界面并指定号码
- 如何拉起浏览器应用
- 如何拉起应用市场界面
- 如何拉起相机界面
- 从一个UIAbility跳转到另外一个Ability时，是否支持自定义转场动画的设置？怎么实现
- 应用级别的context和HSP级别的context冲突吗？HSP中不能通过getContext(this).resourceManager.getStringValue($r('app.string.test_string').id)的方式获取资源会报错，应该如何实现
- UIAbility和UIExtensionAbility有什么区别？分别推荐在什么场景使用
- UIAbility/Page/Component之间的关系？如何搭配使用
- 关于emitter、eventHub的使用场景
- 如何禁用窗口的全屏显示功能
- 如何获取App版本号，版本名，屏幕分辨率等信息
- 如何获取指定Bundle Name的Ability信息
- 如何在UIAbility、页面和组件中获取UIAbilityContext
- 如何在工具类中获取Context
- Applicationcontext、UIAbilitycontext、Context的区别是什么
- 在使用UIAbilityContext时报401“The context must be a valid Context”的Context类型错误
- 应用、元服务和卡片是什么关系
- 系统应用、三方应用、预置应用有什么差别
- 如何设置默认语言和应用名称为中文
- 如何查询应用进程的pid信息
- 有了代码签名特性后，开发者的so文件在调试，发布等阶段该如何部署
- app.json5文件与工程级build-profile.json5文件的区别
- 应用流转对账号有什么要求
- 如何在App启动时让各种权限弹窗的申请自动弹出
- 如果有多个UIAbility，如何判断应用进入后台
- 开发非UI功能，使用ts开发而非ets开发对应用有哪些影响（内存、CPU、hap大小等方面）
- 如何判断App的启动来源
- 如何获取当前页面对应的UIAbility名称
- 如何判断应用当前在前台/后台
- 如何设置应用自动重启
- 如何获取设备上安装的应用列表数据
- UIAbility在内存不足的情况下？是否会回收若回收是否支持页面栈恢复
- 如何通过resourceManager获取rawFile路径下的文件
- HarmonyOS是否限制App进程fork子进程，是否允许app里自带的可执行文件运行（fork+exec）执行，并通过ptrace方式读取自身进程？这种方式以后是否会限制并禁止
- HarmonyOS提供了两种页面加载方式，两者有何区别，怎么选择
- 如何跳转到系统文件管理App界面
- HarmonyOS Next系统属于大端还是小端

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-1
爬取时间: 2025-05-08 03:57:35
来源: Huawei Developer


可以通过以下几种方式来实现订阅系统环境变量的变化：

- 使用ApplicationContext订阅回调。
- 在AbilityStage组件容器中订阅回调。
- 在UIAbility组件中订阅回调。
- 在ExtensionAbility组件中订阅回调。

在onConfigurationUpdate()回调方法中订阅或监听系统环境变量的变化（包括语言，颜色模式，屏幕方向等）。


详细请参见订阅系统环境变量的变化。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-2
爬取时间: 2025-05-08 03:57:44
来源: Huawei Developer


DevEco Studio默认工程中未自动生成AbilityStage，如需要使用AbilityStage的能力，可以手动新建一个AbilityStage文件，具体步骤如下：


```less
import { AbilityStage, Want } from '@kit.AbilityKit';
 
export default class MyAbilityStage extends AbilityStage { 
  onCreate(): void { 
    // 应用的HAP在首次加载时，为该Module初始化操作 
  } 
 
  onAcceptWant(want: Want): string { 
    // 仅UIAbility配置为specified启动模式时触发 
    return 'MyAbilityStage'; 
  } 
}
```


```less
{ 
  "module": { 
    "name": "entry", 
    "type": "entry", 
    "srcEntry": "./ets/myabilitystage/MyAbilityStage.ets", 
    ... 
  } 
}
```


AbilityStage拥有onCreate()生命周期回调、onAcceptWant()、onConfigurationUpdated()和onMemoryLevel()等事件回调。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-4
爬取时间: 2025-05-08 03:57:54
来源: Huawei Developer


在HarmonyOS应用开发中，UIAbilityContext的terminateSelf()方法被用来结束当前的UIAbility实例。


如果希望在调用terminateSelf()后，让应用在最近任务列表中不保留快照，可以通过在module.json5配置文件中配置removeMissionAfterTerminate为true来实现。


```less
{ 
  "module": { 
    // ... 
    "abilities": [ 
      { 
        // ... 
        "removeMissionAfterTerminate": true, 
      } 
    ] 
  } 
}
```

- removeMissionAfterTerminate字段的默认值：该字段的默认值为false，意味着如果不进行配置，默认情况下应用会在最近任务列表中保留快照。
- 配置影响：仅当removeMissionAfterTerminate被设置为true时，调用terminateSelf()后应用才不会在最近任务列表中保留快照。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-5
爬取时间: 2025-05-08 03:58:04
来源: Huawei Developer


可以通过ApplicationContext的killAllProcesses()方法主动退出当前的应用。


调用killAllProcesses()方法后，会将应用中所有的进程逐个Kill掉。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-12
爬取时间: 2025-05-08 03:58:13
来源: Huawei Developer


可能原因


解决措施


参考链接


@ohos.app.ability.Want (Want)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-13
爬取时间: 2025-05-08 03:58:23
来源: Huawei Developer


问题现象


部署HAP时，上报如下错误：Failure[INSTALL_FAILED_SIZE_TOO_LARGE] error while deploying hap？


可能原因


这是单个HAP包太大导致的。


解决措施


将其拆分为多个HAP即可解决。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-14
爬取时间: 2025-05-08 03:58:32
来源: Huawei Developer


使用Context.cacheDir获取应用程序的缓存目录。代码示例如下：


```typescript
import { common } from '@kit.AbilityKit'; 
 
@Entry 
@Component 
export struct GetCacheDirectoryView { 
  private context = getContext(this) as common.UIAbilityContext; 
  @State cachePath: string = ''; 
 
  build() { 
    Column() { 
      Text(this.cachePath) 
        .margin({ bottom: 24 }) 
      Button() { 
        Text('获取应用程序缓存目录地址') 
      } 
      .onClick(() => { 
        const applicationContext = this.context.getApplicationContext(); 
        // 获取应用文件路径 
        const cacheDir = applicationContext.cacheDir; 
        this.cachePath = cacheDir + '/test.txt'; 
      }) 
      .width(300) 
      .height(50) 
    } 
    .justifyContent(FlexAlign.Center) 
    .width('100%') 
    .height('100%') 
  } 
}
```


参考链接


获取应用文件路径


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-15
爬取时间: 2025-05-08 03:58:42
来源: Huawei Developer


通过应用上下文context获取。例如：

- temp路径：可通过this.context.getApplicationContext().tempDir获取。
- files路径：可通过this.context.getApplicationContext().filesDir获取。

参考链接


获取应用文件路径


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-16
爬取时间: 2025-05-08 03:58:52
来源: Huawei Developer


新建卡片时会生成一个EntryFormAbility.ets文件，其中包含卡片对应的生命周期。


参考链接


FormExtensionAbility


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-20
爬取时间: 2025-05-08 03:59:01
来源: Huawei Developer


可能原因


同一个工程同一个设备存在多个模块，且存在模块间的调用，未将所有的HAP包安装到设备中。


解决措施


单击Run > Edit Configurations，设置指定模块的HAP安装方式，勾选“Keep Application Data”，则表示采用覆盖安装方式，保留应用/服务缓存数据。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160820.31652311639140756886152329263901:50001231000000:2800:D76441D002BC10432163B3F826ACFA99B421085C7A016CA340ABE901C8283D4A.png)

参考链接


设置HAP安装方式


module.json5配置文件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-26
爬取时间: 2025-05-08 03:59:10
来源: Huawei Developer

- 不同UIAbility生命周期是相互独立的，不会互相影响
- 同一个UIAbility生命周期中的耗时操作会触发系统监控并冻结，因此应用开发过程中应使用异步的方法处理耗时操作，避免影响UIAbility生命周期的流转。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-27
爬取时间: 2025-05-08 03:59:20
来源: Huawei Developer


getContext(this)中的this需要指向组件，所以只需确保自定义类在调用getContext时，传入的参数是指向组件的即可。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-28
爬取时间: 2025-05-08 03:59:30
来源: Huawei Developer

- 每个应用至多并存三类进程（主进程、Extension类进程、Render进程），应用中所有的进程都是由系统创建和管理的。
- 应用主进程中运行所有的UIAbility组件、页面和业务逻辑，它可以拥有多个UIAbility实例。
- 一个应用包含一个或者多个Module，Module分为“Ability”和“Library”两种类型，Ability类型的Module对应于编译后的HAP；Library类型的Module对应于HAR/HSP。
- HAP可分为Entry和Feature两种类型，同一个应用中，同一设备类型只支持一个Entry类型的HAP，是整个应用的入口模块。
- 进程启动过程：首先系统服务通过孵化进程拉起应用主进程并创建出相应的运行环境。应用再根据实际情况请求系统服务。启动应用所需的其他进程。
- 首先系统服务通过孵化进程拉起应用主进程并创建出相应的运行环境。
- 应用再根据实际情况请求系统服务。
- 启动应用所需的其他进程。
- 模块启动顺序：首先拉起应用的入口模块，该模块加载时会创建一个AbilityStage实例，可以对该模块进行初始化等操作。模块初始完成后，会拉起相应的入口UIAbility。UIAbility加载完成后会生成一个WindowStage类实例并与之绑定。WindowStage发挥了应用进程内窗口管理器的作用，UIAbility通过它持有一个窗口，在该窗口上加载出首个ArkUI页面，从而在设备上呈现。
- 首先拉起应用的入口模块，该模块加载时会创建一个AbilityStage实例，可以对该模块进行初始化等操作。
- 模块初始完成后，会拉起相应的入口UIAbility。
- UIAbility加载完成后会生成一个WindowStage类实例并与之绑定。WindowStage发挥了应用进程内窗口管理器的作用，UIAbility通过它持有一个窗口，在该窗口上加载出首个ArkUI页面，从而在设备上呈现。

参考链接


Stage模型开发概述


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-29
爬取时间: 2025-05-08 03:59:39
来源: Huawei Developer


当前不允许三方应用在手机设备上Fork进程。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-31
爬取时间: 2025-05-08 03:59:49
来源: Huawei Developer


两个UIAbility之间数据传递的方法如下，推荐优先使用排序靠前的方法。

- 方法一：调用startAbility接口启动另外一个UIAbility时，通过wantInfo添加启动参数。也可通过startAbilityForResult接口，获取被调用方UIAbility在关闭时返回的信息。
- 方法二：使用应用级别的状态管理AppStorage、PersistentStorage、Environment，实现应用级或者多个页面的状态数据共享。
- 方法三：同一个应用中UIAbility和UIAbility之间的数据传递，可以使用AppStorage/LocalStorage进行数据同步。
- 方法四：使用线程间通信工具Emitter、Worker进行通信。
- 方法五：使用进程间通信工具CES（公共事件服务）进行通信。
- 其他方法（系统应用）：通过Call调用实现UIAbility交互。

参考链接


启动应用内的UIAbility组件


管理应用拥有的状态概述


UIAbility组件与UI的数据同步


线程模型


公共事件简介


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-32
爬取时间: 2025-05-08 03:59:59
来源: Huawei Developer


子进程的崩溃不会直接导致父进程崩溃。只有当子进程的崩溃导致父进程在使用部分功能时抛出了未被应用捕获的异常，才会间接导致主进程崩溃。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-34
爬取时间: 2025-05-08 04:00:09
来源: Huawei Developer


PC/2in1设备

- 支持不同模块的UIAbility运行在不同的进程中。
- 多个进程间不会影响，其他进程退出不会影响当前进程。

其他设备

- 多个UIAbility运行在一个进程中。
- 三方应用的UIAbility不支持运行在多个进程，三方应用的Extension运行在独立的进程。
- 手机设备上应用开发的UIAbility都是运行在一个进程中，没有子进程。

参考链接


进程模型


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-35
爬取时间: 2025-05-08 04:00:19
来源: Huawei Developer


使用EventHub（事件通知），适用于同应用内的简单通信，通过事件订阅和发布机制实现。


实现步骤：


ExtensionAbility端发布事件：


```less
import { commonEventManager } from '@kit.BasicServicesKit';
import { BusinessError } from '@kit.BasicServicesKit';


// 发布公共事件回调
function publishCB(err: BusinessError) {
  if (err) {
    console.error(`Failed to publish common event. Code is ${err.code}, message is ${err.message}`);
  } else {
    console.info(`Succeeded in publishing common event.`);
  }
}
// 发布公共事件
try {
  commonEventManager.publish("event", publishCB);
} catch (error) {
  let err: BusinessError = error as BusinessError;
  console.error(`Failed to publish common event. Code is ${err.code}, message is ${err.message}`);
}
```


主进程端订阅事件：


```less
import { BusinessError } from '@kit.BasicServicesKit';


// 定义订阅者，用于保存创建成功的订阅者对象，后续使用其完成订阅及退订的动作
let subscriber: commonEventManager.CommonEventSubscriber;
// 订阅者信息
let subscribeInfo: commonEventManager.CommonEventSubscribeInfo = {
  events: ["event"]
};
// 订阅公共事件回调
function SubscribeCB(err: BusinessError, data: commonEventManager.CommonEventData) {
  if (err) {
    console.error(`Failed to subscribe. Code is ${err.code}, message is ${err.message}`);
  } else {
    console.info(`Succeeded in subscribing, data is ` + JSON.stringify(data));
  }
}
// 创建订阅者回调
function createCB(err: BusinessError, commonEventSubscriber: commonEventManager.CommonEventSubscriber) {
  if(!err) {
    console.info(`Succeeded in creating subscriber.`);
    subscriber = commonEventSubscriber;
    // 订阅公共事件
    try {
      commonEventManager.subscribe(subscriber, SubscribeCB);
    } catch (error) {
      let err: BusinessError = error as BusinessError;
      console.error(`Failed to subscribe. Code is ${err.code}, message is ${err.message}`);
    }
  } else {
    console.error(`Failed to create subscriber. Code is ${err.code}, message is ${err.message}`);
  }
}
// 创建订阅者
try {
  commonEventManager.createSubscriber(subscribeInfo, createCB);
} catch (error) {
  let err: BusinessError = error as BusinessError;
  console.error(`Failed to create subscriber. Code is ${err.code}, message is ${err.message}`);
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-36
爬取时间: 2025-05-08 04:00:28
来源: Huawei Developer


通过ApplicationContext模块提供的ApplicationContext.on()方法，可以订阅进程内UIAbility的生命周期变化。


参考链接


订阅进程内UIAbility生命周期变化，ApplicationContext.on


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-37
爬取时间: 2025-05-08 04:00:38
来源: Huawei Developer


```less
import { errorManager } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';


let observer: errorManager.ErrorObserver = {
  onUnhandledException(errorMsg) {
    console.error('onUnhandledException, errorMsg: ', errorMsg);
  }
};


try {
  errorManager.on('error', observer);
} catch (error) {
  console.error(`registerErrorObserver failed, error.code: ${(error as BusinessError).code}, error.message: ${(error as BusinessError).message}`);
}
```


```less
import { errorManager } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';


let observer: errorManager.ErrorObserver = {
  onUnhandledException(errorMsg) {
    console.error('onUnhandledException, errorMsg: ', errorMsg);
  },
  onException(errorObj) {
    console.log('onException, name: ', errorObj.name);
    console.log('onException, message: ', errorObj.message);
    if (typeof (errorObj.stack) === 'string') {
      console.log('onException, stack: ', errorObj.stack);
    }
  }
};


try {
  errorManager.on('error', observer);
} catch (error) {
  console.error(`registerErrorObserver failed, error.code: ${(error as BusinessError).code}, error.message: ${(error as BusinessError).message}`);
}
```


两个回调函数触发时机一致，会同时触发，区别在于onUnhandledException仅返回异常信息，onException返回完整异常对象。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-38
爬取时间: 2025-05-08 04:00:48
来源: Huawei Developer


目前EventHub只能在主线程使用，不支持在TaskPool中使用。


参考链接


使用EventHub进行数据通信


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-39
爬取时间: 2025-05-08 04:00:57
来源: Huawei Developer


不支持hdc shell命令根据schema uri模拟跳转。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-40
爬取时间: 2025-05-08 04:01:07
来源: Huawei Developer


不支持，可以通过UIAbilityContext的startAbility方法启动UIAbility。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-50
爬取时间: 2025-05-08 04:01:17
来源: Huawei Developer

- Stage模型中，多个应用组件共享同一个ArkTS引擎实例，因此在Stage模型中，应用组件之间可以方便的共享对象和状态，同时减少复杂应用运行对内存的占用。
- FA模型中，每个应用组件独享一个ArkTS引擎实例。

Stage模型作为主推的应用模型，开发者通过它能够更加便利地开发出分布式场景下的复杂应用。


参考链接


通过对比认识FA模型与Stage模型


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-54
爬取时间: 2025-05-08 04:01:27
来源: Huawei Developer


开发者可以通过使用隐式Want机制来调用其他应用打开文件。通过设置合适的携带的数据（uri）、MIME type类型（type）、处理Want的方式（flag）等字段，以便系统能够识别并弹出一个选择框，让用户选择合适的应用来打开文件，效果示意如下图所示。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160821.33157507359012959880268014526654:50001231000000:2800:36BFBB82958B73C2114F8C43128B2BECD7B525B4363187BB1885B151B76A74EE.jpg)

调用方


```less
// xxx.ets 
import common from '@ohos.app.ability.common'; 
import Want from '@ohos.app.ability.Want'; 
import wantConstant from '@ohos.app.ability.wantConstant'; 
import { BusinessError } from '@ohos.base';
```


```less
// xxx.ets 
// 构造请求数据Want，以打开word文件为例 
let wantInfo: Want = {
  uri: 'file://.../test.docx', // 表示待打开文件的URI路径，一般配合type使用 
  type: 'application/msword', // 表示待打开文件的类型 
  flags: wantConstant.Flags.FLAG_AUTH_WRITE_URI_PERMISSION, // 表示对URI执行写入操作的授权
}
```


```less
// xxx.ets 
// 调用startAbility接口进行文件打开 
context.startAbility(wantInfo).then(() => { 
  // ... 
}).catch((err: BusinessError) => { 
  // ... 
})
```


目标方


在module.json5配置文件中注册文件打开能力。


```less
{ 
  "module": { 
    // ... 
    "abilities": [ 
      { 
        // ... 
        "skills": [ 
          { 
            "actions": [ 
              "ohos.want.action.viewData" // 声明数据处理能力 
            ], 
            "uris": [ 
              { 
                // 允许打开uri中以file://协议开头标识本地的word文件 
                "scheme": "file", 
                "type": "application/msword", // 表示支持打开的文件类型 
                "linkFeature": "FileOpen" // 表示此URI的功能为文件打开 
              } 
              // ... 
            ] 
            // ... 
          } 
        ] 
      } 
    ] 
  } 
}
```


注册文件打开能力的目标方应用，在应用市场上架时会进行相应的审核。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-57
爬取时间: 2025-05-08 04:01:36
来源: Huawei Developer


开发者可以通过call.makeCall来拉起拨号界面。并在makeCall函数的第一个参数中指定电话号码，该功能代码在PC/2in1设备中不可用。具体可参考如下代码。


```typescript
import { call } from '@kit.TelephonyKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
function startCallDialog(): void { 
  let isSupport = call.hasVoiceCapability(); 
  if (!isSupport) { 
    console.error('Not support voice capability.'); 
    return; 
  } 
 
  call.makeCall('16888888888', (err: BusinessError) => { 
    if (err) { 
      console.error(`Failed to make call. Code is ${err.code}, Message is ${err.message}`); 
      return; 
    } 
    console.info('Succeeded in making call.'); 
  }) 
} 
 
@Entry 
@Component 
struct StartCallDialogView { 
  @State message: string = '如何拉起拨号界面并指定号码'; 
 
  build() { 
    Row() { 
      Column() { 
        Button(this.message) 
          .fontSize(24) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            startCallDialog(); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-58
爬取时间: 2025-05-08 04:01:46
来源: Huawei Developer


开发者可以通过隐式指定want参数中的action为ohos.want.action.viewData来拉起浏览器应用，并在want中的uri参数配置拉起后打开的网页链接，此时会拉起设备内的默认浏览器。若设备内存在多个浏览器应用，希望用户能自行选择要使用的浏览器，需配置parameters中的ohos.ability.params.showDefaultPicker为true。具体可参考如下代码。


```typescript
import { common, Want } from '@kit.AbilityKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
function startBrowsableAbility(context: common.UIAbilityContext): void { 
  let want: Want = { 
    action: 'ohos.want.action.viewData', 
    entities: ['entity.system.browsable'], 
    uri: 'https://www.huawei.com/',
    parameters: {
      'ohos.ability.params.showDefaultPicker': true
    }
  }; 
  context.startAbility(want) 
    .then(() => { 
      console.error('Start browsableAbility successfully.'); 
    }) 
    .catch((err: BusinessError) => { 
      console.error(`Failed to startAbility. Code: ${err.code}, message: ${err.message}`); 
    }); 
} 
 
@Entry 
@Component 
struct BrowsableAbilityView { 
  @State message: string = '拉起浏览器并打开华为官网'; 
 
  build() { 
    Row() { 
      Column() { 
        Button(this.message) 
          .fontSize(24) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            const context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext; 
            startBrowsableAbility(context); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-59
爬取时间: 2025-05-08 04:01:56
来源: Huawei Developer


开发者可以通过隐式指定want参数中的action为ohos.want.action.appdetail并配置uri为store://appgallery.huawei.com来单独拉起应用市场应用。如需拉起应用市场中某个具体应用的详情页面，开发者需要向uri参数中拼接/app/detail?id=bundleName，其中bundleName为具体需要打开的应用包名，代码参考如下。


```typescript
import { common, Want } from '@kit.AbilityKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
// 拉起应用市场对应的应用详情界面 
function startAppGalleryDetailAbility(context: common.UIAbilityContext, bundleName: string): void { 
  let want: Want = { 
    action: 'ohos.want.action.appdetail', 
    uri: 'store://appgallery.huawei.com/app/detail?id=' + bundleName, //  bundleName为需要打开应用详情的应用的包名 
  }; 
  context.startAbility(want).then(() => { 
    console.info('Start Ability successfully.'); 
  }).catch((err: BusinessError) => { 
    console.error(`Failed to startAbility. Code: ${err.code}, message: ${err.message}`); 
  }); 
} 
 
@Entry 
@Component 
struct StartAppGalleryDetailAbilityView { 
  @State message: string = '拉起应用市场详情页'; 
 
  build() { 
    Row() { 
      Column() { 
        Button(this.message) 
          .fontSize(24) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            const context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext; 
            const bundleName = 'com.example.xxx'; 
            startAppGalleryDetailAbility(context, bundleName); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-60
爬取时间: 2025-05-08 04:02:06
来源: Huawei Developer


开发者可以通过cameraPicker拉起相机应用，该picker提供拍照与录制的能力，应用可以自行配置pick方法第二个参数选择媒体类型实现拍照和录制的功能，如以下代码中提供了拍照和录像的能力。更多相关内容可以参见：相机选择器。


```typescript
import { common } from '@kit.AbilityKit'; 
import { camera, cameraPicker } from '@kit.CameraKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
let context = getContext(this) as common.Context; 
 
async function startCameraPicker() { 
  try { 
    let pickerProfile: cameraPicker.PickerProfile = { 
      cameraPosition: camera.CameraPosition.CAMERA_POSITION_BACK 
    }; 
    let pickerResult: cameraPicker.PickerResult = await cameraPicker.pick(context, 
      [cameraPicker.PickerMediaType.PHOTO, cameraPicker.PickerMediaType.VIDEO], pickerProfile); 
    console.log("the pick pickerResult is:" + JSON.stringify(pickerResult)); 
  } catch (error) { 
    let err = error as BusinessError; 
    console.error(`the pick call failed. error code: ${err.code}`); 
  } 
} 
 
@Entry 
@Component 
struct StartCameraPickerView { 
  build() { 
    Column() { 
      Button("点击拉起相机") 
        .onClick(() => startCameraPicker()) 
    } 
    .width("100%") 
    .height("100%") 
    .justifyContent(FlexAlign.Center) 
    .alignItems(HorizontalAlign.Center) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-62
爬取时间: 2025-05-08 04:02:16
来源: Huawei Developer


不支持自定义转场动画。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-64
爬取时间: 2025-05-08 04:02:25
来源: Huawei Developer


不冲突。先通过getContext()获取当前上下文，再通过createModuleContext()获取HSP模块的上下文，再获取HSP模块的resourceManager，然后再调用resourceManager的接口获取资源。


参考链接


引用HSP中的接口


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-65
爬取时间: 2025-05-08 04:02:35
来源: Huawei Developer


UIAbility用于独立界面，UIExtensionAbility用于功能扩展。


```less
import { UIAbility } from "@kit.AbilityKit";
import { window } from "@kit.ArkUI";


// MainAbility.ets
export default class MainAbility extends UIAbility {
  onWindowStageCreate(windowStage:  window.WindowStage) {
    windowStage.loadContent("pages/MainPage", (err) => {
      if (err) console.error("加载页面失败");
    });
  }
}
```


```less
import { UIExtensionAbility, AbilityConstant } from '@kit.AbilityKit';


export default class UIExtAbility extends UIExtensionAbility {
  onCreate(launchParam: AbilityConstant.LaunchParam) {
    console.log(`onCreate, launchParam: ${JSON.stringify(launchParam)}`);
  }
}
```


参考链接


UIAbility组件概述


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-66
爬取时间: 2025-05-08 04:02:43
来源: Huawei Developer


UIAbility是应用中的组件，一般建议一个Hap包中仅包含一个UIAbility。


Page是页面展示，一个UIAbility中可以有一个或多个Page，开发者可以根据系统提供的能力进行页面间跳转。


Component是页面组件的概念，例如Text组件、Button组件。一个Page里面可以有一个或多个Component，开发者通过不同的组件布局来实现不同的页面。


参考链接


程序框架服务


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-68
爬取时间: 2025-05-08 04:02:53
来源: Huawei Developer


Emitter主要提供线程间发送和处理事件的能力，包括对持续订阅事件或单次订阅事件的处理、取消订阅事件、发送事件到事件队列等。

1. 

```typescript
import { promptAction } from '@kit.ArkUI'; 
import { emitter } from '@kit.BasicServicesKit'; 
 
const TAG: string = 'ThreadModel';
```

2.  EventHub提供了线程内发送和处理事件的能力，包括对事件订阅、取消订阅、触发事件等。以UIAbility组件与UI之间的数据同步为例，具体使用方法可以参考UIAbility组件与UI的数据同步。 参考链接 UIAbility组件与UI的数据同步

```less
import { emitter } from '@kit.BasicServicesKit';
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-69
爬取时间: 2025-05-08 04:03:03
来源: Huawei Developer


可以在module.json5文件中通过配置abilities中的supportWindowMode字段去指定是否显示。


fullscreen表示支持全屏显示，split表示支持分屏显示，floating表示支持窗口化显示。


参考代码如下：


```less
"abilities": [ 
  { 
    "name": "EntryAbility", 
    "srcEntry": "./ets/entryability/EntryAbility.ets", 
    "description": "$string:EntryAbility_desc", 
    "icon": "$media:icon", 
    "label": "$string:EntryAbility_label", 
    "startWindowIcon": "$media:icon", 
    "startWindowBackground": "$color:start_window_background", 
    "exported": true, 
    "supportWindowMode": ["split", "floating"], 
    "skills": [ 
      { 
        "entities": [ 
          "entity.system.home" 
        ], 
        "actions": [ 
          "action.system.home" 
        ] 
      } 
    ] 
  } 
]
```


参考链接


module.json5配置文件-abilities


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-71
爬取时间: 2025-05-08 04:03:14
来源: Huawei Developer


```less
import { BusinessError } from '@kit.BasicServicesKit'; 
import { bundleManager } from '@kit.AbilityKit'; 
// ... 
bundleManager.getBundleInfoForSelf(bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION).then((bundleInfo)=>{ 
  let versionName = bundleInfo.versionName;//应用版本名 
  let versionNo = bundleInfo.versionCode;//应用版本号 
}).catch((error: BusinessError )=>{ 
  console.error("get bundleInfo failed,error is "+error) 
})
```


```less
import { common } from '@kit.AbilityKit'; 
// ... 
let context = getContext(this) as common.UIAbilityContext; 
let screenDensity = context.config.screenDensity;
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-72
爬取时间: 2025-05-08 04:03:24
来源: Huawei Developer


bundleManager.getBundleInfoForSelf :getBundleInfoForSelf(bundleFlags: number): Promise<BundleInfo>;


以异步方法根据给定的bundleFlags获取当前应用的BundleInfo，使用Promise形式返回结果。参考示例代码如下：


```less
// 获取带有metadataArray信息的appInfo 
import { bundleManager } from '@kit.AbilityKit'; 
import { hilog } from '@kit.PerformanceAnalysisKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
let bundleFlags = bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION | bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_METADATA; 
try { 
  bundleManager.getBundleInfoForSelf(bundleFlags).then((data) => { 
    hilog.info(0x0000, 'testTag', 'getBundleInfoForSelf successfully. Data: %{public}s', JSON.stringify(data)); 
  }).catch((err: BusinessError) => { 
    hilog.error(0x0000, 'testTag', 'getBundleInfoForSelf failed. Cause: %{public}s', err.message); 
  }); 
} catch (err) { 
  let message = (err as BusinessError).message; 
  hilog.error(0x0000, 'testTag', 'getBundleInfoForSelf failed: %{public}s', message); 
}
```


参考链接


bundleManager.getBundleInfoForSelf


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-73
爬取时间: 2025-05-08 04:03:33
来源: Huawei Developer


可以在UIAbility中或者页面中分别进行获取UIAbility实例的上下文信息（UIAbilityContext），详细请参见获取UIAbility的上下文信息。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-74
爬取时间: 2025-05-08 04:03:42
来源: Huawei Developer


工具类中无法直接获取context，可以在EntryAbility中获取Context后保存至AppStorage，然后在工具类中使用AppStorage获取。


参考链接


AppStorage：应用全局的UI状态存储


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-75
爬取时间: 2025-05-08 04:03:51
来源: Huawei Developer

- ApplicationContext和UIAbilitycontext都是继承自基类Context ，不同的Context有不同的属性和方法。
- ApplicationContext：应用级别的Context。ApplicationContext在基类Context的基础上提供了订阅应用内应用组件的生命周期的变化、订阅系统内存变化和订阅应用内系统环境的变化的能力，在UIAbility、ExtensionAbility、AbilityStage中均可以获取。
- UIAbilitycontext：每个UIAbility中都包含了一个Context属性，提供操作应用组件、获取应用组件的配置信息等能力。

参考链接


应用上下文Context


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-76
爬取时间: 2025-05-08 04:04:00
来源: Huawei Developer


401报错表示context无效，需要使用UIAbility的Context。获取UIAbilityContext的方式如下：


```less
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit'; 
 
export default class EntryAbility extends UIAbility { 
  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) { 
    let uiAbilityContext = this.context; 
    // ... 
  } 
}
```


参考链接


应用上下文Context


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-77
爬取时间: 2025-05-08 04:04:10
来源: Huawei Developer


元服务也是一种应用，只不过没有图标，可以执行免安装拉起而已。


应用和元服务，不能共享包名，它们得分别打包，元服务和应用之间是分割开的，也不能共享entry模块


应用与元服务都可以有卡片，而不是某一方特有的。


元服务的卡片在手机上的入口，就表现为桌面卡片；在桌面长按任何一张已经添加的卡片，比如：图库和备忘录，在弹出来的菜单中选择“卡片中心”，进入卡片中心页面，可以找到卡片来添加到桌面。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-78
爬取时间: 2025-05-08 04:04:20
来源: Huawei Developer

- 系统应用：profile证书中app-feature为hos_system_app的应用，系统应用能调用系统接口。
- 三方应用：profile证书中app-feature为hos_normal_app的应用，三方应用不能调用系统接口。
- 预置应用：厂商在出厂时预先安装在设备上的应用，可以是系统应用，也可以是三方应用。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-80
爬取时间: 2025-05-08 04:04:29
来源: Huawei Developer


系统默认语言为中文，不需要额外设置。 应用名称在resources/zh_CN/element/string.json文件中配置。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-81
爬取时间: 2025-05-08 04:04:39
来源: Huawei Developer


可以通过如下两种方式获取：

-  执行hdc shell命令，进入设备的shell命令行。在shell命令行中，执行“ps -ef”命令，可以查看所有正在运行的进程信息。

```less
import { process } from '@kit.ArkTS';
let pid = process.pid;
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-82
爬取时间: 2025-05-08 04:04:48
来源: Huawei Developer


安全原则：HarmonyOS NEXT版本上已部署强制代码签名机制，所有上架应用市场及开发者调试的应用，都需要使用合法证书对代码文件进行签名，才能在设备端正常执行。由开发者直接推送到设备端的so文件会因为端侧校验合法签名失败，而被系统拦截，从而导致加载失败。


针对开发者so文件的部署：

- 发布阶段：普通三方应用的所有so文件都需要打包在应用HAP包内，随应用一起上架应用市场做强制代码签名（通过热更新下载的so文件由于缺乏合法签名会被系统拦截）。
- 调试阶段：在开发态下，HAP文件及包内的so文件使用开发者证书做代码签名，并在安装时由包管理完成代码文件的代码签名使能。此外，最新的DevEco Studio提供热重载（Hot Reload）功能，支持将代码文件（包括so文件等）快速推送到设备端安装并做签名使能。具体而言，IDE支持将项目目录内新增/新修改的代码文件打包到hqf包，使用开发者证书对包进行签名，然后通过HDC推送到设备侧，最后通过包管理触发HQF的安装以及签名使能，从而完成了新代码文件到端侧的部署。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-88
爬取时间: 2025-05-08 04:04:58
来源: Huawei Developer


使用场景和优先级是有所不同的。

- app.json5文件主要用于定义应用的全局配置信息，包含应用的Bundle名称、开发厂商、版本号等基本信息。在应用中直接使用app.json5文件进行全局配置时，这些配置会被工程级build-profile.json5文件中的相同包名的配置所覆盖。
- 工程级build-profile.json5文件主要用于定义构建和部署相关的配置。它包含了应用的包名、版本号等元数据，这些元数据可以在构建过程中被使用。如果app.json5文件中定义了与工程级build-profile.json5文件中相同包名的配置项，那么build-profile.json5文件中的该配置项会将app.json5文件中的配置项覆盖。

建议以工程级build-profile.json5文件中的配置为主。因为在构建和部署过程中，系统通常会优先使用工程级build-profile.json5文件中的配置信息。


参考链接


app.json5配置文件标签


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-89
爬取时间: 2025-05-08 04:05:08
来源: Huawei Developer


应用流转仅支持同账号设备。推荐注册华为账号，使用华为账号进行登录和使用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-92
爬取时间: 2025-05-08 04:05:18
来源: Huawei Developer


把requestPermissionsFromUser接口放到EntryAbility.ets文件里loadContent的回调里面，参考代码如下：


```less
windowStage.loadContent('pages/Index', (err) => { 
  let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager(); 
  atManager.requestPermissionsFromUser(this.context, ['ohos.permission.ACCESS_BLUETOOTH']) 
    .then((data: PermissionRequestResult) => { 
      console.info('data:' + JSON.stringify(data)); 
      console.info('data permissions:' + data.permissions); 
      console.info('data authResults:' + data.authResults); 
    }).catch((err: BusinessError) => { 
    console.error('data:' + JSON.stringify(err)); 
  });
```


在设置文件中声明目标权限：


```less
"requestPermissions": [ 
  { 
    "name": "ohos.permission.ACCESS_BLUETOOTH", 
    "usedScene": { 
      "abilities": [ 
        "EntryAbility" 
      ], 
      "when": "inuse" 
    }, 
    "reason": "$string:app_name" 
  } 
]
```


参考链接


abilityAccessCtrl.createAtManager


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-93
爬取时间: 2025-05-08 04:05:28
来源: Huawei Developer


问题场景


这里的reason和usedScene如何填写，有参考资料吗？目前在网上找到的资料表示这两个字段不是必填的，但是如果真不填的话在IDE（Build Version: 4.1.3.600, built on February 22, 2024）上会编译报错：The reason and usedScene attributes are mandatory for user_grant permissions.


解决措施


具体配置可参考声明权限。


参考示例如下：


```less
// module.json5 
"requestPermissions": [ 
  { 
    "name": "ohos.permission.APP_TRACKING_CONSENT", 
    "reason": "$string:app_tracking_consent_reason", 
    "usedScene": { 
      "abilities": [ 
        "FormAbility" 
      ], 
      "when": "always" 
    } 
  } 
] 
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-94
爬取时间: 2025-05-08 04:05:38
来源: Huawei Developer


多UIAbility情况下，必须所有UIAbility都在后台时，应用才处于后台。


可以使用ApplicationContext.on()接口，该方法第一个参数可以设置监听的事件类型，第二个参数为一个回调函数，可以对应用前后台切换时进行监听。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-98
爬取时间: 2025-05-08 04:05:48
来源: Huawei Developer


一些基础的库可以用ts开发，ts文件无法引用ets文件，使用ts开发就无法使用系统能力了。


ArkTS通过规范强化静态检查和分析，使得在程序开发期能检测更多错误，提升程序稳定性，并实现更好的运行性能。使用ets在性能上会有优势。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-99
爬取时间: 2025-05-08 04:05:58
来源: Huawei Developer


通过startAbility()启动应用时，want参数中的parameters属性可以携带拉起方的信息，系统在parameters提供了一些预置的key，比如可以通过ohos.aafwk.param.callerBundleName获取拉起方的BundleName的值。


示例如下：


拉起端：


```typescript
import { common, Want } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';


@Entry
@Component
struct Index {
  build() {
    Row() {
      Column() {
        Button('open app')
          .onClick(() => {
            let want: Want = {
              action: 'ohos.want.action.viewData',
              entities: ['entity.system.home']
            }
            let context = getContext(this) as common.UIAbilityContext;
            context.startAbility(want, (err: BusinessError) => {
              if (err.code) {
                // 处理业务逻辑错误
                hilog.error(0x0000, 'testTag', `startAbility failed, code is ${err.code}, message is ${err.message}`);
                return;
              }
              // 执行正常业务
              hilog.info(0x0000, 'testTag', 'startAbility succeed');
            });
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


接收端：


```less
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';


export default class EntryAbility extends UIAbility {
  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    hilog.info(0x0000, 'testTag', `app resource is:${want.parameters?.['ohos.aafwk.param.callerBundleName']}`);
    // ...
  }


  // ...
}
```


参考链接


Want


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-100
爬取时间: 2025-05-08 04:06:08
来源: Huawei Developer


可以通过bundleManager的getBundleInfoForSelf()接口获取当前应用的AbilityInfo信息，其中参数bundleFlags需要包含GET_BUNDLE_INFO_WITH_HAP_MODULE和GET_BUNDLE_INFO_WITH_ABILITY。AbilityInfo中包含当前应用的Ability名称、Bundle名称等信息。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-101
爬取时间: 2025-05-08 04:06:17
来源: Huawei Developer


可以通过以下两种方式获取：

-  代码示例：

```less
// EntryAbility.ets 
onWindowStageCreate(windowStage: window.WindowStage): void { 
  // Main window is created, set main page for this ability 
  hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate'); 
  try { 
    windowStage.on('windowStageEvent', (data) => { 
      if (data === window.WindowStageEventType.SHOWN) { 
        hilog.info(0x0000, 'testTag', '%{public}s', 'window stage is shown'); 
      } else if (data === window.WindowStageEventType.HIDDEN) { 
        hilog.info(0x0000, 'testTag', '%{public}s', 'window stage is hidden'); 
      } 
    }); 
  } catch (err) { 
    hilog.error(0x0000, 'testTag', '%{public}s', 'Failed to enable the listener for ' + 
      'window stage event changes. Cause:' + JSON.stringify(err)); 
  } 
  windowStage.loadContent('pages/Index', (err, data) => { 
    if (err.code) { 
      hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? ''); 
      return; 
    } 
    hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? ''); 
  }); 
}
```

- 方案二：通过ApplicationContext的getRunningProcessInformation()方法，获取进程的信息，其中包含当前进程运行状态，可以判断是否处于前台。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-103
爬取时间: 2025-05-08 04:06:27
来源: Huawei Developer


可以通过ApplicationContext.restartApp实现，具体请参考示例代码：


```typescript
import { Want } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { common } from '@kit.AbilityKit';


@Entry
@Component
struct Index {
  @State message: string = 'Hello World';
  private context = getContext(this) as common.UIAbilityContext;


  build() {
    RelativeContainer() {
      Text(this.message)
        .id('HelloWorld')
        .fontSize(50)
        .fontWeight(FontWeight.Bold)
        .alignRules({
          center: { anchor: '__container__', align: VerticalAlign.Center },
          middle: { anchor: '__container__', align: HorizontalAlign.Center }
        })


      Button('RESTART').onClick(() => {
        let applicationContext = this.context.getApplicationContext();
        let want: Want = {
          bundleName: 'com.example.myapp',
          abilityName: 'EntryAbility'
        };
        try {
          applicationContext.restartApp(want);
          hilog.info(0x0000, 'testTag', '%{public}s', 'applicationContext.restartApp');
        } catch (error) {
          console.error(`restartApp fail, error: ${JSON.stringify(error)}`);
        }
      })
    }
    .height('100%')
    .width('100%')
  }
}
```


参考链接


ApplicationContext.restartApp


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-104
爬取时间: 2025-05-08 04:06:37
来源: Huawei Developer


不允许查询设备应用列表数据，相关权限无法申请。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-110
爬取时间: 2025-05-08 04:06:47
来源: Huawei Developer


解决方案


当前系统还不支持页面栈恢复。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-111
爬取时间: 2025-05-08 04:06:56
来源: Huawei Developer


解决方案


可以通过@ohos.resourceManager中的getRawFileList方法获取RawFile路径下的所有文件。参考代码如下：


```typescript
import { BusinessError } from '@kit.BasicServicesKit';


// 传入''表示获取rawfile根目录下的文件列表
try {
  this.context.resourceManager.getRawFileList('', (error: BusinessError, value: Array<string>) => {
    if (error != null) {
      console.error(`callback getRawFileList failed, error code: ${error.code}, message: ${error.message}.`);
    } else {
      let rawFile = value;
    }
  });
} catch (error) {
  let code = (error as BusinessError).code;
  let message = (error as BusinessError).message;
  console.error(`callback getRawFileList failed, error code: ${code}, message: ${message}.`);
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-112
爬取时间: 2025-05-08 04:07:06
来源: Huawei Developer


解决方案


系统会对普通应用直接进行Fork进程限制、管控；手机产品不允许普通应用直接创建进程，如需要，HarmonyOS要在配置文件中申明，并在上架审核的时候上传每个进程的必要性说明；当前应用如果使用了fork创建多进程，在HarmonyOS上需声明审核。审核通过后，手机侧也仅能使用fork，不能使用fork+exec。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-113
爬取时间: 2025-05-08 04:07:16
来源: Huawei Developer


问题描述


HarmonyOS提供了两种页面加载方式，一种是一个UIAbility绑定多个page页面，page页面之间实现跳转；一种是一个UIAbility绑定一个page页面，通过跳转UIAbility实现页面加载。请问这两种方式有什么区别？一般怎么做选择？


解决方案


区别：


一个UIAbility绑定多个page页面：资源占用少、切换速度快，page之间的跳转较为轻量，适合频繁切换的场景。


一个UIAbility绑定一个page页面：资源占用多、切换速度慢，适用于需要独立生命周期管理的复杂业务逻辑。


选择建议

- 选择一个UIAbility绑定多个Page页面。
- 适用于导航栏切换、Tab页切换等场景。
- 选择一个UIAbility绑定一个Page页面。
- 适用于独立功能模块、复杂业务逻辑等场景。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ability-116
爬取时间: 2025-05-08 04:07:26
来源: Huawei Developer


可以使用openLink的方式打开，在openLink接口的link字段中传入系统文件管理页面的URL信息，示例代码如下：


```typescript
import { common, OpenLinkOptions } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { BusinessError } from '@kit.BasicServicesKit';


const TAG: string = '[UIAbilityComponentsOpenLink]';
const DOMAIN_NUMBER: number = 0xFF00;


@Entry
@Component
struct Index {
  @State message: string = '拉起文件管理';


  build() {
    Row() {
      Column() {
        Button(this.message)
          .width('100%')
          .fontWeight(FontWeight.Bold)
          .onClick(() => {
            let context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
            let link: string = 'filemanager://openDirectory';
            let openLinkOptions: OpenLinkOptions = {
              parameters: {
                'fileUri': ''
              }
            };
            try {
              context.openLink(link, openLinkOptions)
                .then(() => {
                  hilog.info(DOMAIN_NUMBER, TAG, 'open link success.');
                }).catch((err: BusinessError) => {
                hilog.error(DOMAIN_NUMBER, TAG, `open link failed. Code is ${err.code}, message is ${err.message}`);
              });
            } catch (paramError) {
              hilog.error(DOMAIN_NUMBER, TAG,
                `Failed to start link. Code is ${paramError.code}, message is ${paramError.message}`);
            }
          })
      }
      .padding({ left: 16, right: 16 })
      .width('100%')
    }
    .height('100%')
  }
}
```


参考链接：


UIAbilityContext.openLink


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-background-tasks-kit
爬取时间: 2025-05-08 04:07:34
来源: Huawei Developer

- 如何在Stage模型中创建后台任务
- 应用在进行后台后，如何继续执行业务
- 如何申请多个长时任务
- 应用运行时进程资源使用规格
- 如何确认延迟任务是否申请成功
- 如何确认延迟任务WorkSchedulerExtensionAbility回调方法onWorkStart、onWorkStop实现是否正确、是否可以成功回调
- 如何查询后台任务中短时任务/长时任务/延迟任务/后台代理提醒相关的系统日志

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-background-tasks-1
爬取时间: 2025-05-08 04:07:43
来源: Huawei Developer


问题现象


Stage模型中的ServiceExtensionAbility是系统接口，第三方应用不支持调用，如何在Stage模型中创建后台任务？


解决措施


后台任务，包括短时任务、长时任务、延迟任务、代理提醒等，例如：在Stage模型中创建长时任务的步骤请参考长时任务开发步骤。


参考链接


后台任务


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-background-tasks-2
爬取时间: 2025-05-08 04:07:53
来源: Huawei Developer


应用切换至后台时，如果有需要继续执行或者后续执行的业务，可基于业务类型，申请短时任务延迟挂起（Suspend）或者长时任务避免进入挂起状态。


参考链接


短时任务，长时任务


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-background-tasks-4
爬取时间: 2025-05-08 04:08:02
来源: Huawei Developer


问题现象


应用在后台同时有多个任务运行，需要申请多个长时任务。


解决措施


同一时刻，一个UIAbility只能申请运行一个长时任务，需要创建多个UIAbility根据不同种类的长时任务分别申请；不同时刻可以申请不同种类的长时任务。


参考链接


长时任务


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-background-tasks-6
爬取时间: 2025-05-08 04:08:12
来源: Huawei Developer


内存：资源配额2G。当内存使用连续1分钟超过2G，前台告警，后台结束进程。


CPU:

- 后台10分钟单核平均使用率高于10%，结束进程。
- 后台20分钟单核平均使用率高于7.5%，结束进程。
- 后台60分钟单核平均使用率高于2.5%，结束进程。
- 后台120分钟单核平均使用率高于1.3%，结束进程。

IO：资源配额1G，进程重启后配额清零。


参考链接


Stage模型开发概述


Background Tasks Kit


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-background-tasks-7
爬取时间: 2025-05-08 04:08:22
来源: Huawei Developer


startWork成功之后，可以通过以下命令验证延迟任务是否申请成功，如果hidumper命令返回结果中包含对应应用的bundleName、abilityName、workId，说明对应workId的延迟任务申请成功。


```less
hdc shell hidumper -s 1904 -a '-a'
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160822.63068535757862133324604965158715:50001231000000:2800:FEBBFFBDF6AF468984E2327EDAB509D108F0B475F4C04AF4CFF07EDE3966C4DF.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-background-tasks-8
爬取时间: 2025-05-08 04:08:32
来源: Huawei Developer


延迟任务申请成功之后，执行延迟任务回调需要等到条件满足之后，为了快速验证延迟任务回调功能是否正确，可以通过以下hidumper命令手动触发延迟任务执行回调。


```less
hdc shell hidumper -s 1904 -a '-t com.hmos.workschedulerdemo MyWorkSchedulerExtensionAbility'
```


com.hmos.workschedulerdemo、MyWorkSchedulerExtensionAbility需要替换为需要查询应用的bundleName和abilityName。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160822.16455502268733245069067622020167:50001231000000:2800:09AFB930BBF07A125DA9885E2A72C2EE7E19CC27F6CFAB7409495B3D0C85CABF.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-background-tasks-9
爬取时间: 2025-05-08 04:08:42
来源: Huawei Developer


以后台任务中短时任务为例。可以在日志中通过过滤关键字“C01711/TRANSIENT_TASK”来查询短时任务的状态情况，包括查询申请短时任务状态、查询对应短时任务的剩余时间和取消短时任务状态等。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160822.74843710569575455590269086094059:50001231000000:2800:52A345CA182C568F3F97620F83B245D24CB55698B3E630D59EF2260CA46E49ED.png)
- “request suspend success ...”：表示短时任务申请成功。
- “get remain time pkg ...”：表示对应短时任务的剩余时间。
- “cancel suspend delay ...”：表示短时任务取消成功。

更多后台任务中日志标识：

- 短时任务：TRANSIENT_TASK
- 长时任务：CONTINUOUS_TASK
- 延迟任务：WORK_SCHEDULER
- 后台代理提醒：ANS_REMINDER

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ipc-kit
爬取时间: 2025-05-08 04:08:52
来源: Huawei Developer

- IPC跨进程通信中是否支持异步返回数据

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ipc-1
爬取时间: 2025-05-08 04:09:01
来源: Huawei Developer


支持，将服务端的onRemoteMessageRequest函数使用async设置为异步即可。具体可以参考：API参考onRemoteMessageRequest中的”重载onRemoteMessageRequest方法异步处理请求示例”。


参考代码如下：


```typescript
import { rpc } from '@kit.IPCKit'; 
 
class TestRemoteObject extends rpc.RemoteObject { 
  constructor(descriptor: string) { 
    super(descriptor); 
  } 
 
  async onRemoteMessageRequest(code: number, data: rpc.MessageSequence, reply: rpc.MessageSequence, option: rpc.MessageOption): Promise<boolean> { 
    if (code === 1) { 
      console.log("RpcServer: async onRemoteMessageRequest is called"); 
    } else { 
      console.log("RpcServer: unknown code: " + code); 
      return false; 
    } 
    await new Promise((resolve: (data: rpc.RequestResult) => void) => { 
      setTimeout(resolve, 100); 
    }) 
    return true; 
  } 
}
```


参考链接


IPC与RPC通信开发指导


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-form-kit
爬取时间: 2025-05-08 04:09:12
来源: Huawei Developer

- 点击服务卡片如何跳转至指定的页面
- 元服务与服务卡片的区别
- 在应用中如何刷新卡片

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-form-1
爬取时间: 2025-05-08 04:09:21
来源: Huawei Developer


配置卡片事件，指定需要跳转的目标UIAbility，

- 如果应用不在后台，可以通过在目标UIAbility的onWindowStageCreate()中调用loadContent加载指定的page页面。
- 如果应用已在后台，可以通过在目标UIAbility的onNewWant()中调用loadContent加载指定的page页面。

参考链接


启动UIAbility的指定页面


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-form-6
爬取时间: 2025-05-08 04:09:30
来源: Huawei Developer

- 元服务：是系统提供的一种面向未来的服务提供方式，是有独立入口的（用户可通过点击方式直接触发）、免安装的（无需显式安装，由系统程序框架后台安装后即可使用）、可为用户提供一个或多个便捷服务的用户应用程序形态。
- 服务卡片：是一种界面展示形式，可以将应用的重要信息或操作前置到卡片，以达到服务直达、减少体验层级的目的。卡片常用于嵌入到其他应用（当前卡片使用方只支持系统应用，如桌面）中作为其界面显示的一部分，并支持拉起页面、发送消息等基础的交互功能。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-form-7
爬取时间: 2025-05-08 04:09:40
来源: Huawei Developer

- 在应用页面操作触发卡片更新时，可以使用updateForm通知卡片进行刷新，例如天气应用设置显示地区后，通知卡片刷新显示数据。
- 点击卡片触发卡片更新，可以在卡片页面中通过postCardAction接口触发router事件或者call事件拉起UIAbility，然后由UIAbility刷新卡片内容。router事件：事件触发时拉起卡片对应应用的UIAbility至前台，在UIAbility的onCreate或者onNewWant生命周期中可以通过入参want获取卡片的formID和传递过来的参数信息，然后调用updateForm接口刷新卡片。常见场景例如：点击新闻卡片进入对应应用，应用推送最新数据通知卡片刷新。call事件：事件触发时拉起卡片对应应用的UIAbility至后台，在UIAbility的onCreate生命周期中监听call事件所需的方法，然后在对应方法中调用updateForm接口刷新卡片。要拉起UIAbility至后台，需要在module.json5配置文件中，配置ohos.permission.KEEP_BACKGROUND_RUNNING权限。常见场景例如：天气卡片点击刷新按钮，拉起应用UIAbility至后台更新卡片显示最新数据。
- router事件：事件触发时拉起卡片对应应用的UIAbility至前台，在UIAbility的onCreate或者onNewWant生命周期中可以通过入参want获取卡片的formID和传递过来的参数信息，然后调用updateForm接口刷新卡片。常见场景例如：点击新闻卡片进入对应应用，应用推送最新数据通知卡片刷新。
- call事件：事件触发时拉起卡片对应应用的UIAbility至后台，在UIAbility的onCreate生命周期中监听call事件所需的方法，然后在对应方法中调用updateForm接口刷新卡片。要拉起UIAbility至后台，需要在module.json5配置文件中，配置ohos.permission.KEEP_BACKGROUND_RUNNING权限。常见场景例如：天气卡片点击刷新按钮，拉起应用UIAbility至后台更新卡片显示最新数据。
- router事件：事件触发时拉起卡片对应应用的UIAbility至前台，在UIAbility的onCreate或者onNewWant生命周期中可以通过入参want获取卡片的formID和传递过来的参数信息，然后调用updateForm接口刷新卡片。常见场景例如：点击新闻卡片进入对应应用，应用推送最新数据通知卡片刷新。
- call事件：事件触发时拉起卡片对应应用的UIAbility至后台，在UIAbility的onCreate生命周期中监听call事件所需的方法，然后在对应方法中调用updateForm接口刷新卡片。要拉起UIAbility至后台，需要在module.json5配置文件中，配置ohos.permission.KEEP_BACKGROUND_RUNNING权限。常见场景例如：天气卡片点击刷新按钮，拉起应用UIAbility至后台更新卡片显示最新数据。

参考链接


通过router或call事件刷新卡片内容


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts
爬取时间: 2025-05-08 04:09:49
来源: Huawei Developer

- 方舟编程语言（ArkTS）
- ArkTS线程模型和并发

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-kit
爬取时间: 2025-05-08 04:09:59
来源: Huawei Developer

- 将rawfile中json格式的字符串转换成对应的object对象后，调用实例方法后程序崩溃
- 如何使用正则表达式
- 如何生成随机的uuid
- ArkTS中有类似java中的System.arraycopy数组复制的方法吗
- ArkTS文件后缀是否需要全部改成.ets
- 编译后生成的.abc文件存放路径在哪
- ArkTS文件和TS文件的区别
- 如何实现字符串编解码
- 如何生成UUID的字符串
- 使用NAPI扩展TS接口时，常用属性和实现接口的基本用法
- pthread创建的线程中如何读取rawfile
- ArkTS的SendableClass对象内存共享的原理和限制是什么
- synchronized在java中可以修饰方法，从而简单地实现函数的同步调用。在系统ets开发中，如何简单实现该功能
- ArkTS类的方法是否支持重载
- 如何将类Java语言的线程模型（内存共享）的实现方式转换成在ArkTS的线程模型下（内存隔离）的实现方式
- 以libstd为例，C++的标准库放在哪里了，有没有打到hap包中
- 如何开启AOT编译模式
- AOT编译模式的产物及ap、an、ai文件是什么
- .ets文件和.ts文件的区别及如何互相调用文件中定义的方法
- ArkTS中globalThis无法使用该如何替换
- ArkTS中this的常用场景及使用
- 如何访问类的静态变量和方法
- 如何合并两个对象
- 如何实现类似Java中的反射方法调用能力
- 系统使用了ArkTS作为开发语言，那这些代码在底层的解释运行的环境是自研的还是用的开源的，比如v8、jscore？另外系统也适配了React Native引擎，是不是也是复用的这个运行环境
- ArkTS里有哪些转换数据类型的方法
- 是否支持开发者自行管理线程数量
- 是否支持模块的动态加载？如何实现
- 如何实现AOP（代码插桩）能力
- 如何使用AOP接口实现重复插桩或替换
- 如何判断能否对接口进行插桩或替换
- 如何解析JSON字符串为实例对象
- 如何在ArkTS中实现运行时注解的能力
- 如何在ArkTS中实现自定义装饰器能力
- ArkTS是否支持解构
- 是否支持在TS文件中加载ArkTS文件，TS是否会被限制使用
- ArkTS是否支持反射调用类的静态成员函数和实例成员函数
- 如何通过Index获取ArrayList中的元素
- 如何将Map转换为JSON字符串
- 如何获取对象的类名
- 如何将JSON对象转换成HashMap
- 如何将ArrayBuffer转成string
- Uint8Array类型和String以及hex如何互相转换
- 如何进行base64编码
- 赋值和深/浅拷贝的区别
- ArkTS是否支持多继承
- ArkTS是否支持交叉类型
- ArkTS是否支持匿名内部类
- 如何使用Record
- 如何通过AOP统计方法执行时间
- 如何快速生成class的setter和getter方法
- 如何实现Sendable类型和JSON数据的转换
- 如何处理大整数
- 如何通过判断函数入参类型实现不同代码逻辑
- 如何使用工具库对JSON进行解析与生成
- A持有B，B引用A的场景会不会导致内存泄漏
- 如何通过key获取对象值
- ModuleManager模块加载流程是什么样的？
- 如何查看编译的详细过程
- 如何遍历JSON对象
- 如何判断对象的类型
- 如何在ArkTS使用Reflect正确绑定this指针
- 混淆后的映射文件具体在哪个路径下
- 如何获取对象的所有方法
- 如何使用内置的js引擎？JIT支持策略如何？
- 如何在ArkTS中使用闭包
- 是否支持通过动态import反射调用类的静态成员函数和实例成员函数？
- 如何获取环境变量信息
- 如何获取应用进程执行时间
- 如何指定对象某些属性参与序列化
- 对象反序列化时number类型丢失精度如何解决
- Array的长度上限是多少？
- 当前ArkTS是否采用类Node.js的异步I/O机制
- 对于网络请求这类I/O密集型任务是否需要使用多线程进行处理
- 对于@ohos.net.http网络框架是否需要使用TaskPool处理
- 模块间循环依赖导致运行时未初始化异常问题定位
- 编译异常，无具体错误日志，难以定位问题
- gbk字符串TextEncoder编码结果属性buffer长度为何比编码结果长度略大
- ArkTS如何定义callback函数
- 对象中函数的this如何指向外层
- 如何实现匿名内部类
- 如何定义一个未知类型的对象
- 如何在调用处实现接口中的方法？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-1
爬取时间: 2025-05-08 04:10:09
来源: Huawei Developer


问题现象


直接报错："jscrash happened in xxxxxxxxx"，crash日志中错误信息："Error message: Unexpected Object in JSON"。


解决措施


通过json解析字符串得到的对象的原型是object，其原型链中不存在自有的实例方法，故无法调用。


如需调用该方法，则有以下两种方式：

1.  JSON.parse方法会把 function 处理成字符串，直接调用的话会因该 function 不可调用从而 crash；为了能够继续使用，一般使用 eval 函数把字符串转成 function，但是 ArkTS 中会限制使用 eval 函数，所以该方法不可行，解决方案就是使用 class-transformer 的 plainToClass 方法； 具体可以参考以下两个链接： 如何传递带方法的对象 解析JSON字符串为实例对象

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-3
爬取时间: 2025-05-08 04:10:19
来源: Huawei Developer


首先使用new RegExp()定义一个正则表达式：


```less
const reg = new RegExp('ba');
```


然后，通过test() 方法检测字符串是否匹配，如果字符串中有匹配的值返回true，否则返回false：


```less
const res = reg.test('bar'); 
console.info('result', res);
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-5
爬取时间: 2025-05-08 04:10:29
来源: Huawei Developer


通过ohpm可以获取的三四方库在Gitee上做了汇总（OpenHarmony上可直接使用的三方组件汇总），针对于不同功能三方库内容做了分类，开发者可以根据需要进行参考。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-6
爬取时间: 2025-05-08 04:10:39
来源: Huawei Developer

-  cd entry ohpm install dayjs import dayjs from 'dayjs';
-  cd entry
-  ohpm install dayjs
-  import dayjs from 'dayjs';
-  cd entry ohpm install import dayjs from 'dayjs';

```less
{ 
  "dependencies": { 
    "dayjs": "^1.10.4", 
  } 
}
```

- 打开工程目录下的entry目录，找到该目录下的oh-package.json5文件。

```less
{ 
  "dependencies": { 
    "dayjs": "^1.10.4", 
  } 
}
```

-  cd entry
-  ohpm install
-  import dayjs from 'dayjs';
1.  cd entry
2.  ohpm install dayjs
3.  import dayjs from 'dayjs';

```less
{ 
  "dependencies": { 
    "dayjs": "^1.10.4", 
  } 
}
```

1.  cd entry
2.  ohpm install
3.  import dayjs from 'dayjs';

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-7
爬取时间: 2025-05-08 04:10:49
来源: Huawei Developer


在HarmonyOS 4.0 Canary2版本的2in1设备上，默认提供了用于测试键鼠穿越功能的应用“AssociateAssistant”，通过该应用可打开键鼠穿越功能开关，具体方法如下：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-8
爬取时间: 2025-05-08 04:10:59
来源: Huawei Developer


自定义构建函数（@Builder）和自定义组件的主要区别如下：

- 自定义构建函数（@Builder）更轻量，其作为UI元素抽象的方法，实现和调用相较于自定义组件比较简洁。
-  而自定义构建函数（@Builder）不支持定义状态变量和自定义生命周期。
-  而自定义构建函数（@Builder）默认的按值参数传递方式不支持动态改变组件，当传递的参数为状态变量时，状态变量的改变不会引起@Builder方法内的UI刷新，要实现UI动态刷新需要按引用传递参数。
-  具体实现可参考：@BuilderParam装饰器：引用@Builder函数。
- 自定义构建函数（@Builder）中使用了自定义组件，那么该方法每次被调用时，对应的自定义组件均会重新创建。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-11
爬取时间: 2025-05-08 04:11:09
来源: Huawei Developer


问题现象


例如：Text()组件的字符串变量拼接功能，如何实现？


```less
Text($r('app.string.EntryAbility_desc', 'Hello'))
```


解决措施


可以通过资源文件结合%d、%s的方式进行实现。


示例如下所示：

1.  修改"src/main/resources/en_US/element/string.json"文件，对其中的一个需要变量拼接内容增加%d拼接。

```less
{ 
  "string": [ 
    { 
      "name": "module_desc", 
      "value": "模块描述%d" 
    }, 
    { 
      "name": "EntryAbility_desc", 
      "value": "description" 
    }, 
    { 
      "name": "EntryAbility_label", 
      "value": "label" 
    } 
  ] 
}
```


```less
@Entry 
@Component 
struct Page1 { 
  @State num1: number = 100; 
 
  build() { 
    Row() { 
      Column() { 
        Text($r('app.string.module_desc', this.num1)) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


资源访问


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-12
爬取时间: 2025-05-08 04:11:19
来源: Huawei Developer


napi_wrap接口定义:


```less
napi_wrap(napi_env env, napi_value js_object, void* native_object, napi_finalize finalize_cb, void* finalize_hint, napi_ref* result);
```


使用napi_wrap接口，如果最后一个参数result传递不为nullptr，需要开发者在合适的时机调用napi_remove_wrap函数主动删除创建的napi_ref对象。


```less
// 用法1：napi_wrap不需要接收创建的napi_ref，最后一个参数传递nullptr，创建的napi_ref是弱引用，由系统管理，不需要用户手动释放 
napi_wrap(env, jsobject, nativeObject, cb,nullptr,nullptr); 
 
// 用法2：napi_wrap需要接收创建的napi_ref，最后一个参数不为nullptr，返回的napi_ref是强引用，需要用户手动释放，否则会内存泄漏 
napi_ref result; 
napi_wrap(env, jsobject, nativeObject, cb,nullptr,&result); 
// 当jsobject和result后续不再使用时，及时调用napi_remove_wrap释放result 
napi_value result1; 
napi_remove_wrap(env, jsobject, result1);
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-13
爬取时间: 2025-05-08 04:11:29
来源: Huawei Developer

1.  如下所示：

```less
"abilities": [ 
  { 
    "name": "EntryAbility", 
    "srcEntry": "./ets/entryability/EntryAbility.ets", 
    "description": "$string:EntryAbility_desc", 
    "icon": "$media:icon", 
    "label": "$string:EntryAbility_label", 
    "startWindowIcon": "$media:startIcon", 
    "startWindowBackground": "$color:start_window_background", 
    "exported": true, 
    "skills": [ 
      { 
        "entities": [ 
          "entity.system.home" 
        ], 
        "actions": [ 
          "action.system.home" 
        ] 
      } 
    ], 
    "orientation": "auto_rotation", // 随传感器旋转 
  } 
]
```


参考链接


abilities标签


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-14
爬取时间: 2025-05-08 04:11:38
来源: Huawei Developer


util工具函数中通过util.generateRandomUUID接口提供了生成uuid的相应功能，具体使用可参考如下链接：


参考链接


util.generateRandomUUID


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-15
爬取时间: 2025-05-08 04:11:48
来源: Huawei Developer


可以通过buffer.concat()方法，将数组中的内容复制指定字节长度到新的Buffer对象中并返回。参考代码如下：


```less
import { buffer } from '@kit.ArkTS';


let buf1 = buffer.from("1234");
let buf2 = buffer.from("abcd");
let buf = buffer.concat([buf1, buf2]);
console.info(buf.toString('hex'));
// 输出结果：3132333461626364
```


参考链接


buffer.concat


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-16
爬取时间: 2025-05-08 04:11:58
来源: Huawei Developer


API10之后官方建议使用ets后缀，业务将文件后缀ts改为ets的时候需要进行对应的代码适配。


参考链接


从TypeScript到ArkTS的适配规则


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-17
爬取时间: 2025-05-08 04:12:08
来源: Huawei Developer


执行编译操作后，abc文件存放路径为：“build/default/intermediates/loader_out/default/ets/modules.abc”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160823.53481191884172846957326272315566:50001231000000:2800:73E820CD316BF844140FC8BE32632D229ABDDB2E8165065D39F4C4408A60B443.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-18
爬取时间: 2025-05-08 04:12:17
来源: Huawei Developer


ArkTS基于并兼容了TS语法，保留了TS的大部分特性，当前，ArkTS在TS的基础上主要扩展了声明式UI能力，让开发者能够以更简洁、更自然的方式开发高性能应用。推荐用ArkTS开发UI相关内容，TS可以用来开发业务逻辑相关内容。


参考链接


学习ArkTS语言


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-19
爬取时间: 2025-05-08 04:12:27
来源: Huawei Developer


TextEncoder用于将字符串编码为字节数组，支持多种编码格式，包括utf-8、utf-16le/be等。


TextDecoder用于将字节数组解码为字符串，可以处理多种编码格式，包括utf-8、utf-16le/be、iso-8859和windows-1251等不同的编码格式。


示例代码


```less
import { util } from '@kit.ArkTS';
// 创建编码器
let textEncoder:util.TextEncoder = new util.TextEncoder('gbk');
let buffer:ArrayBuffer = new ArrayBuffer(20);
let encodeResult:Uint8Array = new Uint8Array(buffer);


// 编码
encodeResult = textEncoder.encodeInto('hello');
console.info('Encode result: ', encodeResult);


// 创建解码器
let textDecoder = util.TextDecoder.create('gbk');


// 解码
let decodeResult = textDecoder.decodeToString(encodeResult); 
console.info('Decode result: ', decodeResult);
```


参考链接


TextEncoder、TextDecoder


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-20
爬取时间: 2025-05-08 04:12:37
来源: Huawei Developer


使用util工具中的generateRandomUUID函数可以生成string类型UUID，示例如下：


```less
let uuid = util.generateRandomUUID(true);
console.info("RFC 4122 Version 4 UUID:" + uuid); // 输出随机生成的UUID
```


参考链接


util.generateRandomUUID


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-21
爬取时间: 2025-05-08 04:12:46
来源: Huawei Developer


```less
static napi_value CallNapi(napi_env env, napi_callback_info info) { 
    size_t argc = 1; 
    napi_value object = nullptr; 
    napi_status status; 
    status = napi_get_cb_info(env, info, &argc, &object, nullptr, nullptr); 
    return object; 
} 
NAPI_MODULE_INIT() { 
    napi_property_descriptor desc[] = { 
        { "callNapi", nullptr, CallNapi, nullptr, nullptr, nullptr, napi_default, nullptr } 
    }; 
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc); 
    return exports; 
}
```


```less
#include "napi/native_api.h" 
#include <assert.h> 
static napi_value NativeCall(napi_env env, napi_callback_info info) { 
    size_t argc = 1; 
    napi_value args[1] = { nullptr }; 
    napi_status status; 
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    assert(status == napi_ok); 
    napi_valuetype valuetype; 
    napi_typeof(env, args[0], &valuetype); 
    if (valuetype != napi_valuetype::napi_function) { 
        napi_throw_type_error(env, nullptr, "napi_function is expected"); 
    } 
    napi_value cb = args[0]; 
    napi_value undefined; 
    status = napi_get_undefined(env, &undefined); 
    assert(status == napi_ok); 
    napi_value argv[2] = { nullptr }; 
    status = napi_create_int32(env, 1, &argv[0]); 
    assert(status == napi_ok); 
    status = napi_create_int32(env, 2, &argv[1]); 
    assert(status == napi_ok); 
    napi_value result; 
    status = napi_call_function(env, undefined, cb, 2, argv, &result); 
    assert(status == napi_ok); 
    return nullptr; 
} 
EXTERN_C_START 
static napi_value Init(napi_env env, napi_value exports) { 
    napi_property_descriptor desc[] = { 
        { "nativeCall", nullptr, NativeCall, nullptr, nullptr, nullptr, napi_default, nullptr } 
    }; 
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc); 
    return exports; 
} 
EXTERN_C_END 
static napi_module module = { 
    .nm_version = 1, 
    .nm_flags = 0, 
    .nm_filename = nullptr, 
    .nm_register_func = Init, 
    .nm_modname = "callback", 
    .nm_priv = nullptr, 
    .reserved = { 0 }, 
}; 
extern "C" __attribute__((constructor)) void RegisterCallbackModule(void) { 
    napi_module_register(&module); 
}
```


```less
#include "napi/native_api.h" 
// Empty value so that macros here are able to return NULL or void 
#define NAPI_RETVAL_NOTHING  // Intentionally blank 
#define GET_AND_THROW_LAST_ERROR(env)                                                                    
    do {                                                                                               
        const napi_extended_error_info* errorInfo = nullptr;                                             
        napi_get_last_error_info((env), &errorInfo);                                                     
        bool isPending = false;                                                                          
        napi_is_exception_pending((env), &isPending);                                                    
        if (!isPending && errorInfo != nullptr) {                                                        
            const char* errorMessage =                                                                   
                errorInfo->error_message != nullptr ? errorInfo->error_message : "empty error message";  
            napi_throw_error((env), nullptr, errorMessage);                                              
        }                                                                                                
    } while (0) 
#define NAPI_ASSERT_BASE(env, assertion, message, retVal)                                     
    do {                                                                                      
        if (!(assertion)) {                                                                   
            napi_throw_error((env), nullptr, "assertion ("#assertion") failed:" message);  
            return retVal;                                                                    
        }                                                                                     
    } while (0) 
#define NAPI_ASSERT(env, assertion, message) NAPI_ASSERT_BASE(env, assertion, message, nullptr) 
#define NAPI_ASSERT_RETURN_VOID(env, assertion, message)  
        NAPI_ASSERT_BASE(env, assertion, message, NAPI_RETVAL_NOTHING) 
#define NAPI_CALL_BASE(env, theCall, retVal)  
    do {                                      
        if ((theCall) != napi_ok) {           
            GET_AND_THROW_LAST_ERROR((env));  
            return retVal;                    
        }                                     
    } while (0) 
#define NAPI_CALL(env, theCall) NAPI_CALL_BASE(env, theCall, nullptr) 
#define NAPI_CALL_RETURN_VOID(env, theCall) NAPI_CALL_BASE(env, theCall, NAPI_RETVAL_NOTHING) 
struct AsyncData { 
    napi_deferred deferred; 
    napi_async_work work; 
    int32_t arg; 
    double retVal; 
}; 
double DoSomething(int32_t val) { 
    if (val != 0) { 
        return 1.0 / val;  
    } 
    return 0; 
} 
void ExecuteCallback(napi_env env, void* data) { 
    AsyncData* asyncData = reinterpret_cast<AsyncData*>(data); 
    asyncData->retVal = DoSomething(asyncData->arg); 
} 
void CompleteCallback(napi_env env, napi_status status, void* data) { 
    AsyncData* asyncData = reinterpret_cast<AsyncData*>(data); 
    napi_value retVal; 
    if (asyncData->retVal == 0) { 
        NAPI_CALL_RETURN_VOID(env, napi_create_string_utf8(env, "arg can't be zero", NAPI_AUTO_LENGTH, &retVal)); 
        NAPI_CALL_RETURN_VOID(env, napi_reject_deferred(env, asyncData->deferred, retVal)); 
    } else { 
        NAPI_CALL_RETURN_VOID(env, napi_create_double(env, asyncData->retVal, &retVal)); 
        NAPI_CALL_RETURN_VOID(env, napi_resolve_deferred(env, asyncData->deferred, retVal)); 
    } 
    NAPI_CALL_RETURN_VOID(env, napi_delete_async_work(env, asyncData->work)); 
    asyncData->work = nullptr; 
    asyncData->deferred = nullptr; 
    delete asyncData; 
} 
static napi_value NativeCall(napi_env env, napi_callback_info info) { 
    size_t argc = 1; 
    napi_value args[1] = { nullptr }; 
    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr)); 
    int32_t arg; 
    NAPI_CALL(env, napi_get_value_int32(env, args[0], &arg)); 
    // Create promise 
    napi_deferred deferred; 
    napi_value promise; 
    NAPI_CALL(env, napi_create_promise(env, &deferred, &promise)); 
    AsyncData* data = new AsyncData; 
    data->deferred = deferred; 
    data->arg = arg; 
    napi_async_work work; 
    napi_value workName; 
    napi_create_string_utf8(env, "promise", NAPI_AUTO_LENGTH, &workName); 
    NAPI_CALL(env, napi_create_async_work(env, nullptr, workName,ExecuteCallback, CompleteCallback, data, &work)); 
    data->work = work; 
    NAPI_CALL(env, napi_queue_async_work(env, work)); 
    return promise; 
} 
EXTERN_C_START 
static napi_value Init(napi_env env, napi_value exports) { 
    napi_property_descriptor desc[] = { 
        { "nativeCall", nullptr, NativeCall, nullptr, nullptr, nullptr, napi_default, nullptr } 
    }; 
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc); 
    return exports; 
} 
EXTERN_C_END 
static napi_module demoModule = { 
    .nm_version = 1, 
    .nm_flags = 0, 
    .nm_filename = nullptr, 
    .nm_register_func = Init, 
    .nm_modname = "promise", 
    .nm_priv = nullptr, 
    .reserved = { 0 }, 
}; 
extern "C" __attribute__((constructor)) void RegisterPromiseModule(void) { 
    napi_module_register(&demoModule); 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-23
爬取时间: 2025-05-08 04:12:56
来源: Huawei Developer


可在线程安全函数中读取：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-38
爬取时间: 2025-05-08 04:13:06
来源: Huawei Developer


SendableClass是基于Actor内存隔离并发模型的扩展，Sendable对象的内存是线程间共享的，但是仍然需要满足单线程无锁化运行。因此，要保证同一个Sendable实例不能多线程并发访问，开发者需要通过同步机制保证线程安全。


Sendable对象需要满足一定的规格。


参考链接


多线程并发概述


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-44
爬取时间: 2025-05-08 04:13:15
来源: Huawei Developer


支持AsyncLock形式的同步机制，将需要同步的代码块放到异步代码块中。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-45
爬取时间: 2025-05-08 04:13:24
来源: Huawei Developer


当前ArkTS支持TS中的重载，即多个重载签名+实现签名+函数体的形式。函数签名只用在编译期进行类型检查，不保留到运行时。


ArkTS不支持多个函数体实现的重载。示例如下：


```less
// 声明 
function test(param: User): number; 
function test(param: number, flag: boolean): number; 
// 实现 
function test(param: User | number, flag?: boolean) { 
  if (typeof param === 'number') { 
    return param + (flag ? 1 : 0) 
  } else { 
    return param.age 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-46
爬取时间: 2025-05-08 04:13:34
来源: Huawei Developer


可以利用TaskPool接口转换，大概可以分为如下五个场景：

-  共享内存写法： ArkTS写法：

```less
class Task { 
  static run(args) { 
    // 做一些独立的任务 
  } 
} 
let thread = new Thread(() => { 
  let result = Task.run(args) 
  // deal with result 
})
```

-  共享内存写法： ArkTS写法：

```less
class Material { 
  action(args) { 
    // 做一些独立的任务 
  } 
} 
let material = new Material() 
let thread = new Thread(() => { 
  let result = material.action(args) 
  // deal with result 
})
```

-  共享内存写法： ArkTS写法：

```less
class Task { 
    run(args) { 
        // deal with result 
        runOnUiThread(() => { 
            UpdateUI(result) 
        }) 
    } 
} 
let task = new Task() 
let thread = new Thread(() => { 
    let result = task.run(args) 
    // 处理结果 
})
```

-  ArkTS写法：

```typescript
class SdkU3d { 
    static getInst() { 
        return SdkMgr.getInst(); 
    } 
    getPropStr(str: string) { 
        return xx; 
    } 
} 
let thread = new Thread(() => { 
    // 游戏线程 
    let sdk = SdkU3d.getInst() 
    let ret = sdk.getPropStr("xx") 
})
```


参考链接


并发概述


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-48
爬取时间: 2025-05-08 04:13:44
来源: Huawei Developer


libc++_shared.so被打包到应用目录下了，每个应用都有一份独立的libc++_shared.so (/data/storage/el1/bundle/libs/${arch})。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-51
爬取时间: 2025-05-08 04:13:54
来源: Huawei Developer


AOT（Ahead Of Time）即预先编译，在程序运行前，预先编译成高性能机器码，让程序在首次运行就能通过执行高性能机器码获得性能收益。


操作步骤如下：


```less
{ 
  "apiType": 'stageMode', 
  "buildOption": { 
    "arkOptions": { 
      "apPath": "./entry.ap" 
    } 
  }, 
}
```


```less
{ 
  "apiType": 'stageMode', 
  "buildOption": { 
    "arkOptions": { 
      "apPath": "./entry.ap" 
    } 
  }, 
}
```

1.  hdc shell param set ark.profile true

```less
{ 
  "apiType": 'stageMode', 
  "buildOption": { 
    "arkOptions": { 
      "apPath": "./entry.ap" 
    } 
  }, 
}
```


参考链接


开启AOT编译模式


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-52
爬取时间: 2025-05-08 04:14:03
来源: Huawei Developer


AOT编译模式的产物是可以直接执行的机器码。


ap文件：即ark profiler文件，是在方舟AOT编译器中，记录预先profiling运行时类型等信息的文件。


an、ai文件是字节码结合ap文件生成的机器码文件，an是arkcompiler native的缩写，ai是arkcompiler image的缩写。


参考链接


开启AOT编译模式


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-53
爬取时间: 2025-05-08 04:14:13
来源: Huawei Developer


ArkTS基于兼容了TS语法，继承了TS的所有特性，当前，ArkTS在TS的基础上主要扩展了声明式UI能力，让开发者能够以更简洁、更自然的方式开发高性能应用。推荐用ArKTS开发UI相关内容，TS可以用来开发业务逻辑相关内容。


ts文件不支持调用ets文件中定义的方法。


ets调用ts文件中定义的方法，可以使用ES6中import引入及export导出的语法，将ts文件中的方法进行export导出，在ets文件中import引入该方法进行调用。


可以参考如下示例：


```less
// 声明并导出方法test，以便外部文件引入调用   
export default function test() {    
  // to do something 
}
```


```typescript
// 引入ts文件中定义的方法 
import test from './xxx';  
 
@Entry 
@Component 
struct eventTestExample { 
  build() { 
    Button('test') 
      .onClick(() => { 
        test(); // 调用ts文件中定义的方法 
      }) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-54
爬取时间: 2025-05-08 04:14:23
来源: Huawei Developer


ArkTS不支持动态更改对象的布局，因此不支持全局作用域和globalThis。替换方案参考如下：


```typescript
import { common } from '@kit.AbilityKit';
 
// 构造单例对象
export class GlobalThis {
  private constructor() {};
  private static instance: GlobalThis;
  private _uiContexts = new Map<string, common.UIAbilityContext>();
  private value = '';
 
  public static getInstance(): GlobalThis {
    if (!GlobalThis.instance) {
      GlobalThis.instance = new GlobalThis();
    }
    return GlobalThis.instance;
  }
 
  getContext(key: string): common.UIAbilityContext | undefined {
    return this._uiContexts.get(key);
  }
 
  setContext(key: string, value: common.UIAbilityContext): void {
    this._uiContexts.set(key, value);
  }
 
  setValue(value:string){
    this.value = value
  }
 
  getValue():string{
    return this.value;
  }
}
```


```typescript
import { GlobalThis } from '../utils/globalThis';
 
@Entry
@Component
struct Index { 
  @State value: string = GlobalThis.getInstance().getValue();
 
  build() {
    Row() {
      Column() {
        Text(this.value)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
        Button("setValue")
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .onClick(() => {
            GlobalThis.getInstance().setValue("TEST");
          })
        Button("getValue")
          .fontSize(50)
          .fontWeight(FontWeight.Bold) 
          .onClick(() => {
            this.value = GlobalThis.getInstance().getValue();
          })
      }
      .width('100%') 
    }
    .height('100%')
  }
}
```


参考链接


arkts-no-globalthis


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-55
爬取时间: 2025-05-08 04:14:33
来源: Huawei Developer


在ArkTS中，this是常用于类中访问对象属性及方法或者自定义组件的回调中使用getContext(this)。


```typescript
class UserInfo { 
  name: string = 'xxx'; 
 
  getName() { 
    return this.name;
  } 
} 
 
const user: UserInfo = new UserInfo();
```

- 自定义组件中使用this，一般是在回调事件中使用，此时的this是指向自定义组件自身，一般用法是采用getContext(this)的方式。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-56
爬取时间: 2025-05-08 04:14:43
来源: Huawei Developer


在ArkTS中，静态变量和方法是属于类自身的，无法通过this访问，因为this是指向类的实例化对象。如果要在类中访问静态变量和静态方法，需要使用类名访问。


```less
// 访问静态变量或者执行静态方法 
class TestStatic { 
  static aaa: string = '3333'; 
 
  static getAAA () { 
    // console.log(this.aaa) 不能通过this访问静态变量，且静态变量只能在静态方法中使用 
    return TestStatic.aaa; 
  } 
} 
TestStatic.aaa;
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-61
爬取时间: 2025-05-08 04:14:52
来源: Huawei Developer


出于性能考虑，目前ArkTS限制了ES6的Object.assign()方法的使用。若需要在ets文件中扩展对象属性或合并两个对象时，可以自行实现assign方法。


```typescript
function assign(target: Record<string, Object>, ...source: Object[]): Record<string, Object> {
  for (const items of source) {
    for (const key of Object.keys(items)) {
      target[key] = Reflect.get(items, key)
    }
  }
  return target;
}
```


2. 使用assign方法


```less
interface IMergeSub {
  testString: string,
  testObject?: IMergeSub,
  testArray?: Array<number>
}


interface IMerge {
  a: IMergeSub,
  b: IMergeSub[],
  c: string[],
  d: number
}


export function testAssign() {
  let objectOne: IMerge =
    {
      a: {
        testString: 'objectOne-a-testString',
        testObject: {
          testString: 'objectOne-a-testObject-testString'
        },
        testArray: [1]
      },
      b: [{
        testString: 'objectOne-b-testString',
        testObject: {
          testString: 'objectOne-b-testObject-testString'
        },
        testArray: [2]
      }],
      c: ['objectOne-c'],
      d: 3
    }


  let objectTwo: Record<string, Object> = {
    'a': 'objectTwo-a',
    'c': ['objectTwo-c'],
    'e': 1
  }


  let objectThree: Record<string, Object> = {
    'f': ['objectThree-f']
  }


  // 合并多个对象，ObjectOne和ObjectTwo的属性都将附加到ObjectThree上，属性名相同时入参下标靠后的对象属性覆盖前面的对象属性 
  const multiObjectMerged = assign(objectThree, objectTwo, objectOne);
  console.log('multiObjectMerged is:' + JSON.stringify(multiObjectMerged));
  console.log('objectThree is:' + JSON.stringify(objectThree));


  // 合并ObjectOne的属性到ObjectTwo，ObjectTwo的值会改变，属性名称相同时ObjectOne会覆盖ObjectTwo的属性 
  const objectMerged = assign(objectTwo, objectOne);
  console.log('objectTwo is:' + JSON.stringify(objectTwo));
  console.log('objectMerged is:' + JSON.stringify(objectMerged));
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-62
爬取时间: 2025-05-08 04:15:02
来源: Huawei Developer


可以通过动态import的方式实现类似反射能力，具体实现可参考以下代码。


```less
// Index.ets 
import('./module').then( 
  module => { 
    const t = module.DataTable.tagName(); 
  }); 
 
// module.ets 
export class DataTable { 
  constructor() { 
  } 
  static tagName(){ 
    return 'data-table' 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-64
爬取时间: 2025-05-08 04:15:11
来源: Huawei Developer


1. 系统ArkTS语言运行在自研的方舟编译运行时，运行的是应用包中经过方舟编译工具链编译ArkTS/TS/JS源码后生成的字节码。


2. 系统适配的React Native引擎目前仍是运行JS源码，运行在系统提供的V8引擎。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-65
爬取时间: 2025-05-08 04:15:21
来源: Huawei Developer


ArkTS支持通过JavaScript/TypeScript的内置方法进行类型转换，例如Number(), String(), Boolean()等。


ArkTS支持TS语义的as类型转换，不支持使用<>运算符进行类型转换。当前as类型转换只用在编译时，无法通过as在运行时进行类型转换。


参考链接


从TypeScript到ArkTS的适配规则


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-69
爬取时间: 2025-05-08 04:15:29
来源: Huawei Developer


ArkTS侧不支持，Native侧无限制。


线程上限：

- taskpool的线程上限是一个重要的配置参数，需要根据系统资源、任务类型和性能需求进行合理设置。taskpool有着扩容机制，线程池可以根据任务负载动态调整线程数量，但不会超过最大线程数。
- Worker：开发者自行管理Worker的数量及生命周期，最多开启64个Worker，超出会报异常。
- C++创建线程无数量限制。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-70
爬取时间: 2025-05-08 04:15:40
来源: Huawei Developer


当前不支持动态加载设备侧的二进制包；可以使用动态import进行异步加载，达到类似于Class.forName()反射的效果。


示例如下，hap动态import harlibrary，并调用静态成员函数staticAdd()、实例成员函数instanceAdd()，以及全局方法addHarLibrary()。


```typescript
// harlibrary的src/main/ets/utils/Calc.ets 
export class Calc { 
  public constructor() { 
  } 
 
  public static staticAdd(a: number, b: number): number { 
    let c = a + b; 
    console.log("DynamicImport I'm harLibrary in staticAdd, %d + %d = %d", a, b, c); 
    return c; 
  } 
 
  public instanceAdd(a: number, b: number): number { 
    let c = a + b; 
    console.log("DynamicImport I'm harLibrary in instanceAdd, %d + %d = %d", a, b, c); 
    return c; 
  } 
} 
 
export function addHarLibrary(a: number, b: number): number { 
  let c = a + b; 
  console.log("DynamicImport I'm harLibrary in addHarLibrary, %d + %d = %d", a, b, c); 
  return c; 
} 
 
// harlibrary的index.ets 
export { Calc, addHarLibrary } from './src/main/ets/utils/Calc'; 
 
// hap的index.ets 
let harLibrary = 'harlibrary'; 
import(harLibrary).then((ns: ESObject) => { // 动态import变量是新增特性，入参换成字符串'harlibrary'是现有特性。也可使用await import方式。 
  ns.Calc.staticAdd(7, 8); // 反射调用静态成员函数staticAdd() 
  let calc: ESObject = new ns.Calc(); // 实例化类Calc 
  calc.instanceAdd(8, 9); // 调用实例成员函数instanceAdd() 
  ns.addHarLibrary(6, 7); // 调用全局方法addHarLibrary() 
});
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-71
爬取时间: 2025-05-08 04:15:50
来源: Huawei Developer


目前ArkTS的util工具库中提供了Aspect的能力，可以对类方法进行前后插桩以及替换实现。


具体可以参考：Aspect。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-72
爬取时间: 2025-05-08 04:16:00
来源: Huawei Developer


AOP提供的接口支持对方法重复插桩或替换的操作。


采用addBefore（编译前插桩）作为参考例子，重复插桩后，后插桩的代码段先执行。


```typescript
import { util } from '@kit.ArkTS'; 
 
class Test { 
  static data: string = "initData"; 
 
  static printData(): void { 
    console.log("execute original printData"); 
  } 
} 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            Test.printData(); 
            util.Aspect.addBefore(Test, "printData", true, (classObj: Test) => { 
              console.log("execute before 1"); 
            }); 
            Test.printData(); 
            util.Aspect.addBefore(Test, "printData", true, (classObj: Test) => { 
              console.log("execute before 2"); 
            }); 
            util.Aspect.addBefore(Test, "printData", true, (classObj: Test) => { 
              console.log("execute before 3"); 
            }); 
            Test.printData(); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-73
爬取时间: 2025-05-08 04:16:11
来源: Huawei Developer


ArkUI相关的接口会在编译时做转换，编辑态使用的对象或方法在运行时可能并不真实存在，因此Aspect类提供的插桩/替换接口不适用于ArkUI组件相关元素。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-74
爬取时间: 2025-05-08 04:16:21
来源: Huawei Developer


只要类和方法在运行时是实际存在的对象，并且方法的属性描述符的writable字段为true，就可以对接口进行插桩和替换。


获取方法的属性描述符的writable字段：


在创建ObjectUtil工具类，实现ObjectGetOwnPropertyDescriptor方法：


```less
export class ObjectUtil { 
  static ObjectGetOwnPropertyDescriptor(o: any, p: PropertyKey): PropertyDescriptor | undefined{ 
    return Object.getOwnPropertyDescriptor(o, p) 
  } 
}
```


调用工具类获取方法的属性描述符：


```typescript
import { ObjectUtil } from './ObjectUtil' 
 
class Test { 
  static data: string = "initData"; 
  static printData(): void { 
    console.log("execute original printData"); 
  } 
} 
 
@Entry 
@Component 
export  struct AOPReplaced { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            // 获取 myMethod 的属性描述符 
            let des = ObjectUtil.ObjectGetOwnPropertyDescriptor(Test, 'printData') 
            console.log('des',JSON.stringify(des)) 
            // 判断 writable 字段是否为 true 
            if (des && des.writable) { 
              console.log('Method is writable'); 
            } else { 
              console.log('Method is not writable or does not exist'); 
            } 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-75
爬取时间: 2025-05-08 04:16:31
来源: Huawei Developer


问题背景：


需要将JSON数据转换成ArkTS中类的实例对象，要求可以使用实例对象的属性，调用实例对象的方法，包括嵌套对象的场景。


对于这种情况需要借助三方库class-transformer和reflect-metadata实现（需通过ohpm install 安装后使用），通过@Type指定嵌套情况下的类型，并通过plainToClass转换创建对应实例对象。


完整示例如下：


```typescript
import { Type, plainToClass } from 'class-transformer' 
import "reflect-metadata" 
 
// 假设为接受的Json数据 
let testJSON: Record<string, ESObject> = { 
  'id': 1, 
  'firstName': "Johny", 
  'lastName': "Cage", 
  'age': 27, 
  'arr': [ 
    { 
      'name': 'john' 
    }, 
    { 
      'name': 'tom' 
    } 
  ], 
  'instanceA': { 
    'name': 'john' 
  }, 
} 
 
// 如果有对应嵌套结构，需要指定对应的类型 
class A { 
  name: string = 'john'; 
 
  getName(): string { 
    return this.name 
  } 
} 
 
// 当尝试转换具有嵌套对象的对象时，需要知道要转换的对象类型，使用@Type装饰器隐式地指定每个属性包含的对象类型 
class User { 
  id: number = 0; 
  firstName: string = ''; 
  lastName: string = ''; 
  age: number = 0; 
  @Type(() => A) 
  arr: A[] = [new A()] 
  @Type(() => A) 
  instanceA: A = new A(); 
 
  getName() { 
    return this.firstName + " " + this.lastName; 
  } 
 
  isAdult() { 
    return this.age > 36 && this.age < 60; 
  } 
} 
 
@Entry 
@Component 
struct parsingJSONStringsIntoInstanceObjects { 
  aboutToAppear(): void { 
    const instance = plainToClass(User, testJSON); 
    console.info('instance:' + JSON.stringify(instance)) 
  } 
 
  build() { 
 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-77
爬取时间: 2025-05-08 04:16:40
来源: Huawei Developer


可以使用TS三方库reflect-metadata获得类似java运行时注解的功能。参考reflect-metadata


reflect-metadata提供的装饰器允许对类和类属性和类方法做标记，并提供了接口可以在运行时获取标记的信息。


```less
import "reflect-metadata"; 
 
// 三方包的能力暴露在Reflect中 
@Reflect.metadata("TargetClass", 'classData') 
  // 标记类，key是"TargetClass", 数据是classData 
class MyClass { 
  @Reflect.metadata("TargetMethod", 'methodData') 
  // 标记方法，key是"TargetMethod", 数据是methodData 
  myMethod() { 
  } 
 
  @Reflect.metadata("Static", 'staticData') 
  static invoke() { 
  } 
} 
 
// 运行时获取标记信息 
console.info(Reflect.getMetadata("TargetClass", MyClass)); //classData 
console.info(Reflect.getMetadata("TargetMethod", new MyClass(), "myMethod")); //methodData 
console.info(Reflect.getMetadata("Static", MyClass, "invoke")); // staticData
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-78
爬取时间: 2025-05-08 04:16:50
来源: Huawei Developer


ArkTS支持TS5.0之前的TS装饰器语法。关于装饰器的定义和运行时行为，可以参考TS官方文档。


注意，如果在.ets文件中定义装饰器，则需要同时满足ArkTS的语法规则，比如不能使用any等。


参考代码如下：


```typescript
function MyDescriptor(target: Object, key: string, descriptor: PropertyDescriptor) { 
  const originalMethod: Function = descriptor.value 
  descriptor.value = (...args: Object[]) => { 
    // 获取被装饰方法的名称、入参、返回值 
    console.log(`Calling ${target.constructor.name} method ${key} with argument: ${args}`) 
    const result: Object = originalMethod(...args) 
    console.log(`Method ${key} returned: ${result}`) 
    return result 
  } 
  return descriptor 
} 
 
@Entry 
@Component 
export  struct MyDescriptorCom { 
  @State message: string = 'Hello World'; 
 
  @MyDescriptor 
  demoFunc(str:string) { 
    return str 
  } 
 
  aboutToAppear(): void { 
    this.demoFunc('DemoTest') 
  } 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-80
爬取时间: 2025-05-08 04:16:59
来源: Huawei Developer


不支持。ArkTS是静态类型，而解构是依赖于结构兼容性的动态特性并且解构声明中的名称必须和解构对象中的属性名称一致，因此不支持解构。

- 不支持解构赋值：ArkTS不支持解构赋值。可使用其他替代方法，例如，使用临时变量。
- 不支持解构变量声明：依赖于结构兼容性的动态特性并且解构声明中的名称必须和被解构对象中的属性名称一致。
- 不支持参数解构的函数声明：ArkTS要求实参必须直接传递给函数，且必须指定到形参。

参考链接


从TypeScript到ArkTS的适配规则


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-82
爬取时间: 2025-05-08 04:17:09
来源: Huawei Developer


不支持在TS文件中调用ArkTS文件，对于某些在ArkTS中禁用的语法，例如：with语句等，可以考虑在TS文件中进行编写，再在ArkTS文件中调用的方式实现。


不会限制使用TS/JS文件，只会限制在TS/JS文件中import ets文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-83
爬取时间: 2025-05-08 04:17:18
来源: Huawei Developer


ArkTS可以通过动态import的方式实现反射功能，通过类名和方法名调用类中的静态成员函数和实例成员函数。示例如下：


在harlibrary中定义类和成员函数、全局函数，同时进行导出。


```typescript
// harlibrary's src/main/ets/utils/Calc.ets 
export class Calc { 
  public static staticAdd(a:number, b:number):number { 
    let c = a + b; 
    console.log('DynamicImport I am harlibrary in staticAdd, %d + %d = %d', a, b, c); 
    return c; 
  } 
  public instanceAdd(a:number, b:number):number { 
    let c = a + b; 
    console.log('DynamicImport I am harlibrary in instanceAdd, %d + %d = %d', a, b, c); 
    return c; 
  } 
} 
export function addHarlibrary(a:number, b:number):number { 
  let c = a + b; 
  console.log('DynamicImport I am harlibrary in addHarlibrary, %d + %d = %d', a, b, c); 
  return c; 
}
```


```less
// harlibrary's Index.ets 
export { Calc, addHarlibrary } from './src/main/ets/utils/Calc'
```


在hap中对harlibrary模块添加依赖，动态import harlibrary，并调用静态成员函数staticAdd()、实例成员函数instanceAdd()，以及全局方法addHarLibrary()。


```less
// HAP's oh-package.json5 
"dependencies": { 
  "harlibrary": "file:../harlibrary" 
}
```


```less
// HAP's Index.ets 
import('harlibrary').then((ns:ESObject) => { 
  ns.Calc.staticAdd(8, 9);  // 调用静态成员函数staticAdd() 
  let calc:ESObject = new ns.Calc();  // 实例化类Calc 
  calc.instanceAdd(10, 11);  // 调用成员函数instanceAdd() 
  ns.addHarlibrary(6, 7);  // 调用全局方法addHarlibrary() 
   
  // 使用类、成员函数和方法的字符串名字进行反射调用 
  let className = 'Calc'; 
  let methodName = 'instanceAdd'; 
  let staticMethod = 'staticAdd'; 
  let functionName = 'addHarlibrary'; 
  ns[className][staticMethod](12, 13);  // 调用静态成员函数staticAdd() 
  let calc1:ESObject = new ns[className]();  // 实例化类Calc 
  calc1[methodName](14, 15);  // 调用成员函数instanceAdd() 
  ns[functionName](16, 17);  // 调用全局方法addHarlibrary() 
});
```


具体可以参考：业务扩展场景介绍。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-85
爬取时间: 2025-05-08 04:17:28
来源: Huawei Developer

-  JS语法基础中可以通过数组元素下标直接访问数组中对象。示例如下：

```typescript
import { ArrayList } from '@kit.ArkTS'; 
 
let arrayList: ArrayList<number> = new ArrayList(); 
arrayList.add(0); 
arrayList.add(1); 
arrayList.add(2); 
arrayList.add(3); 
arrayList.add(4); 
arrayList.add(5); 
arrayList.add(6); 
arrayList.add(7); 
arrayList.add(8); 
arrayList.add(9); 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'get arrayList value'; 
 
  build() { 
    Row() { 
      Column() { 
        Button(this.message)
          .onClick(() => { 
            console.info('arrayList[6]:', arrayList[6]); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```

-  使用subArrayList，subArrayList可以截取ArrayList中的一段元素，并返回这一段ArrayList实例。示例如下：

```typescript
import { ArrayList } from '@kit.ArkTS'; 
 
let arrayList: ArrayList<number> = new ArrayList(); 
arrayList.add(0); 
arrayList.add(1); 
arrayList.add(2); 
arrayList.add(3); 
arrayList.add(4); 
arrayList.add(5); 
arrayList.add(6); 
arrayList.add(7); 
arrayList.add(8); 
arrayList.add(9); 
 
let result: ArrayList<number> = arrayList.subArrayList(2, 4); 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'subArrayList result'; 
 
  build() { 
    Row() { 
      Column() { 
        Button(this.message)
          .onClick(() => { 
            console.info('subArrayList result:', JSON.stringify(result)); // subArrayList result {"0":"2","1":"3"} 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-86
爬取时间: 2025-05-08 04:17:38
来源: Huawei Developer


可以将Map转成Record后，再通过JSON.stringify()转为JSON字符串。示例如下：


```typescript
let mapSource = new Map<string, string>(); 
mapSource.set('name', 'name1'); 
mapSource.set('width', '100'); 
mapSource.set('height', '50'); 
 
let jsonObject: Record<string, Object> = {}; 
mapSource.forEach((value, key) => { 
  if (key !== undefined && value !== undefined) { 
    jsonObject[key] = value; 
  } 
}) 
let jsonInfo: string = JSON.stringify(jsonObject); 
 
@Entry 
@Component 
struct Index { 
  build() { 
    Column() { 
      Button('Map to JSON') 
        .onClick(() => { 
          console.log('jsonInfo:', jsonInfo); // jsonInfo: {"name":"name1","width":"100","height":"50"} 
        }) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-87
爬取时间: 2025-05-08 04:17:48
来源: Huawei Developer


可以先获取类的实例，然后通过constructor的name属性获取类名。


示例如下：


```typescript
class TestClass { 
  a: string = 'A'; 
  b: string = 'B'; 
} 
 
let testClassObj: TestClass = new TestClass(); 
 
@Entry 
@Component 
struct Index { 
  build() { 
    Row() { 
      Column() { 
        Button('get Class Name') 
          .onClick(() => { 
            console.log('TestClass Name:', testClassObj.constructor.name); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-89
爬取时间: 2025-05-08 04:17:58
来源: Huawei Developer


可以参考如下示例代码：


```typescript
import { HashMap } from '@kit.ArkTS'; 
 
let str: string = '{\"common_params\": {' + 
  '\"city_id\": 1,' + 
  '\"nav_id_list\": \"\",' + 
  '\"show_hook_card\": 2,' + 
  '\"use_one_stop_structure\": 1,' + 
  '\"version_tag\": \"homepageonestop\"' + 
  '}' + 
  '}'; 
 
let jsonObj: Object = JSON.parse(str); 
let commObj = (jsonObj as Record<string, Object>); 
let commRecord = (commObj['common_params'] as Record<string, Object>); 
let keyStr = Object.keys(commRecord); 
 
for (let index: number = 0; index < keyStr.length; index++) { 
  commRecord[keyStr[index].toString()].toString(); 
} 
 
let hashMapData: HashMap<string, Object> = new HashMap(); 
hashMapData.set('common_params', commRecord); 
 
@Entry 
@Component 
struct Index { 
  build() { 
    Row() { 
      Column() { 
        Button('JSON to HashMap') 
          .onClick(() => { 
            // common_params: {"city_id":1,"nav_id_list":"","show_hook_card":2,"use_one_stop_structure":1,"version_tag":"homepageonestop"} 
            console.log('common_params:', JSON.stringify(hashMapData.get('common_params'))); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-90
爬取时间: 2025-05-08 04:18:08
来源: Huawei Developer


可以通过util.TextDecoder.create()方法创建一个工具类，再通过decodeToString()方法进行转化。


```less
let decoder = util.TextDecoder.create('utf-8'); 
let str = decoder.decodeToString(new Uint8Array(arrayBuffer));
```


如将proArrayBuffer返回的ArrayBuffer类型的数据arrayBufferVal转为string：


```less
import { util, buffer } from '@kit.ArkTS'; 
 
let blobValue: buffer.Blob = new buffer.Blob(['name', 'age', 'sex']); 
let proArrayBuffer = blobValue.arrayBuffer(); 
 
proArrayBuffer.then((arrayBufferVal: ArrayBuffer) => { 
  let decoder = util.TextDecoder.create('utf-8'); 
  let stringData = decoder.decodeToString(new Uint8Array(arrayBufferVal)); 
  console.log('stringData:', stringData); 
});
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-91
爬取时间: 2025-05-08 04:18:17
来源: Huawei Developer


Uint8Array类型和String以及hex实现互相转换，可参考如下代码：


```typescript
import { buffer, util } from '@kit.ArkTS';


// 字符串转成字节流
function stringToUint8Array(str: string) {
  console.info('字符串转成字节流:' + new Uint8Array(buffer.from(str, 'utf-8').buffer));
  return new Uint8Array(buffer.from(str, 'utf-8').buffer);
}


// 字节流转成可理解的字符串
function uint8ArrayToString(array: Uint8Array) {
  let textDecoderOptions: util.TextDecoderOptions = {
    fatal: false,
    ignoreBOM: true
  }
  let decodeToStringOptions: util.DecodeToStringOptions = {
    stream: false
  }
  let textDecoder = util.TextDecoder.create('utf-8', textDecoderOptions);
  let retStr = textDecoder.decodeToString(array, decodeToStringOptions);
  console.info('字节流转成可理解的字符串：' + retStr);
  return retStr;
}


//十六进制转Uint8Array
function HexStrTouint8Array(data: string): Uint8Array {
  console.info('十六进制转Uint8Array:' + new Uint8Array(buffer.from(data, 'hex').buffer));
  return new Uint8Array(buffer.from(data, 'hex').buffer);
}


// Uint8Array转十六进制
function uint8ArrayToHexStr(data: Uint8Array): string {
  let hexString = '';
  let i: number;
  for (i = 0; i < data.length; i++) {
    let char = ('00' + data[i].toString(16)).slice(-2);
    hexString += char;
  }
  console.info('Uint8Array转十六进制:' + hexString);
  return hexString;
}


let uint8Array: Uint8Array;


@Entry
@Component
struct TypeConversion {
  build() {
    Column({ space: 12 }) {
      Button('字符串转成字节流')
        .onClick(() => {
          let str = 'hello';
          uint8Array = stringToUint8Array(str);
        })
      Button('字节流转字符串')
        .onClick(() => {
          if (uint8Array) {
            uint8ArrayToString(uint8Array);
          }
        })
      Button('十六进制转Uint8Array')
        .onClick(() => {
          let data = '05160b22';
          HexStrTouint8Array(data);
        })
      Button('Uint8Array转十六进制')
        .onClick(() => {
          let uint8Array = new Uint8Array([5, 22, 11, 34]);
          uint8ArrayToHexStr(uint8Array);
        })
    }
    .width('100%')
    .justifyContent(FlexAlign.Center)
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-92
爬取时间: 2025-05-08 04:18:27
来源: Huawei Developer


可使用util中的Base64Helper()方法进行base64编码，参考代码如下：


```typescript
import { util } from '@kit.ArkTS'; 
 
@Entry 
@Component 
struct Base64Encode { 
  @State message: string = 'base64编码'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            let base64 = new util.Base64Helper(); 
            let arr = new Uint8Array([48, 49, 2, 1, 1, 4, 32, 115, 56]); 
            let base64Str = base64.encodeToStringSync(arr); // Uint8Array转base64 
            console.log('encodeToStringSync',base64Str); 
            // base64.decodeSync(''); // base64转Uint8Array 
            // console.log('decodeSync',base64.decodeSync('')); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-93
爬取时间: 2025-05-08 04:18:37
来源: Huawei Developer


浅拷贝：

- 在堆中为新对象重新创建内存空间。
- 基本数据类型的值被直接拷贝，互不影响。
- 引用类型的内存地址被拷贝，因此拷贝前后的对象共享相同的引用类型数据。
- 修改共享引用类型的数据会影响所有指向该数据的对象。

深拷贝：

- 完整地从内存中拷贝一个对象，包括其所有属性和嵌套的对象。
- 在堆内存中开辟新的区域来存储新对象，确保新对象和原始对象完全独立。
- 修改新对象不会影响原始对象，反之亦然。

对象赋值：

- 当一个对象赋值给新变量时，实际上复制的是对象在栈中的内存地址，而不是堆中的数据。
- 两个变量指向同一个堆内存空间，对一个变量的修改会影响另一个变量，因为它们共享存储空间。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-95
爬取时间: 2025-05-08 04:18:46
来源: Huawei Developer


接口支持多继承，类不支持，只支持单继承。示例如下：


```less
class TestClassA { 
  address: string = ''; 
} 
 
class TestClassB { 
  name: string = ''; 
} 
 
class TestClassC extends TestClassA, TestClassB { // 报错：Classes can only extend a single class. 
} 
 
interface AreaSize { 
  calculateAreaSize(): number; 
} 
 
interface Cal { 
  Sub(a: number, b: number): number; 
} 
 
interface Area extends AreaSize, Cal { 
  areaName: string; 
  length: number; 
  width: number; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-96
爬取时间: 2025-05-08 04:18:56
来源: Huawei Developer


交叉类型会导致性能下降，类型推断变得复杂和不确定。


因此ArkTS不支持intersection type，可以使用继承作为替代方案。


参考链接


使用继承而非intersection type


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-97
爬取时间: 2025-05-08 04:19:06
来源: Huawei Developer


ArkTS不支持匿名类，建议使用嵌套类实现。


因为使用匿名类创建的对象类型未知，这与ArkTS不支持structural typing和对象字面量的类型冲突。限制主要是考虑运行时的性能开销，需要显示声明类。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-98
爬取时间: 2025-05-08 04:19:16
来源: Huawei Developer


构造一个对象类型，其属性键为 "Keys" ，其属性值为 "Type"，可用于将一种类型的属性映射到另一种类型。


示例如下：


```less
// 定义课程类型
type Course = 'Math' | 'Chinese' | 'English';


// 定义成绩类型
type Grade = number;


// 定义学生成绩记录类型
type StudentGrades = Record<Course, Grade>;


// 定义班级成绩记录类型，键是学生ID，值是该学生的成绩记录
type ClassGrades = Record<string, StudentGrades>;


interface StudentCourseGrade {
  Math: number,
  Chinese: number,
  English: number
}


let student1: StudentCourseGrade = {
  Math: 90,
  Chinese: 85,
  English: 92
}
let student2: StudentCourseGrade = {
  Math: 78,
  Chinese: 82,
  English: 85
}
let student3: StudentCourseGrade = {
  Math: 95,
  Chinese: 89,
  English: 90
}


// 初始化班级成绩
const classGrades: ClassGrades = {
  '001': student1,
  '002': student2,
  '003': student3
};


@Entry
@Component
struct Index {
  // 获取某个学生的平均成绩
  getAverageGrade(studentId: string, grades: ClassGrades): number | null {
    const studentGrades = grades[studentId]; // 获取学生对应成绩数据
    if (!studentGrades) {
      console.log(`Student with ID ${studentId} not found.`);
      return null;
    }


    const courses = Object.keys(studentGrades) as Course[]; // 课程类型数组
    // 计算课程总成绩
    const total = courses.reduce((sum, course) => sum + studentGrades[course], 0);
    return total / courses.length; // 平均成绩
  }


  build() {
    Row() {
      Column() {
        Button('getAverageGrade')
          .onClick(() => {
            // 输出: 89
            console.log('student average grade is:', this.getAverageGrade('001', classGrades));
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-99
爬取时间: 2025-05-08 04:19:26
来源: Huawei Developer


对于执行时间的统计，可以利用addBefore记录开始时间，用addAfter记录结束时间。


示例如下：


```typescript
import { util } from '@kit.ArkTS'; 
import { systemDateTime } from '@kit.BasicServicesKit'; 
 
class Utils { 
  Add(len: number): number { 
    let num = 0; 
    for (let index = 1; index <= len; index++) { 
      num += index; 
    } 
    return num; 
  } 
} 
 
let startTime = 0; // 初始化开始时间 
let endTime = 0; // 初始化结束时间 
 
util.Aspect.addBefore(Utils, 'Add', false, () => { 
  startTime = systemDateTime.getTime(true); // 以纳秒数返回开始时间 
}) 
 
util.Aspect.addAfter(Utils, 'Add', false, () => { 
  endTime = systemDateTime.getTime(true); // 以纳秒数返回结束时间 
}) 
 
let utilsObj = new Utils(); 
utilsObj.Add(1000); 
 
@Entry 
@Component 
struct Index { 
  build() { 
    Row() { 
      Column() { 
        Button('get execution time') 
          .onClick(() => { 
            console.log('startTime:', startTime); 
            console.log('endTime:', endTime); 
            console.log('endTime - startTime = ', endTime - startTime); 
          }) 
      } 
      .width('100%') 
    }.height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-101
爬取时间: 2025-05-08 04:19:35
来源: Huawei Developer

1. 
2. 
3. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160825.22875439989882166907531982328152:50001231000000:2800:705445C3F850D8152B3A8D8B61C158F31D943C2FAF22D99FEE458D526C90E26F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160825.78798907070587913290079104957868:50001231000000:2800:64AE81E232966F3C192738819F253C4B52FC30D309E5E380761B670C28EE7D64.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160825.56208707850267936329542379783320:50001231000000:2800:EAB9A409E6D45CA513033F54CE4B970BEAECC21769F11E457DE6B5121FD492B8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160825.66519821641394935882429318275518:50001231000000:2800:0089AADDE1E63603AAD78FDE8B589B58978F05701DD5E95AAA03AFBAA566371D.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-102
爬取时间: 2025-05-08 04:19:44
来源: Huawei Developer


可以通过从API version 12开始支持的，ArkTS新增的ASON工具实现。


ASON支持开发者解析JSON字符串，并生成共享数据进行跨并发域传输，同时ASON也支持将共享数据转换成JSON字符串。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-104
爬取时间: 2025-05-08 04:19:53
来源: Huawei Developer


使用BigInt。


BigInt可以表示任意大小的整数，使用BigInt时，需要在整数字面量后面添加n后缀或者使用BigInt()构造函数。


示例如下：


```typescript
@Entry
@Component
struct BigIntNum {
  build() {
    Row() {
      Column() {
        Button('BigInt num')
          .onClick(() => {
            let bigIntNum: bigint = 12345678901234567890n; // 整数后添加n后缀
            let anotherBigInt: bigint = BigInt(9007199254740992); // 使用BigInt()构造函数
            let sumBigInt: bigint = bigIntNum + anotherBigInt;
            console.info('bigIntNum:' + bigIntNum);
            console.info('anotherBigInt:' + anotherBigInt);
            console.info('bigIntNum + anotherBigInt:' + sumBigInt);
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-105
爬取时间: 2025-05-08 04:20:03
来源: Huawei Developer


可参考如下示例：


```typescript
class Game {
}


function solve(message: number | string | boolean | Map<string, number> | Record<string, number> | Game) {
  // Game：类型判断
  if (message instanceof Game) {
    console.info('Game');
    return;
  }


  // 获取参数对应的构造函数转为字符串，并对截取字符串
  let typeStr: string = message.constructor.toString().substring(9, 12);
  // 判断typeStr对应的类型
  switch (typeStr) {
    case 'Num':
      console.info('number type');
      break;
    case 'Str':
      console.info('string type');
      break;
    case 'Boo':
      console.info('boolean type');
      break;
    case 'Map':
      console.info('Map type');
      break;
    case 'Obj':
      console.info('Record type');
      break;
  }
}


let gameVal: Game = '';
let mapVal = new Map<string, number>();
mapVal.set('width', 100);
mapVal.set('height', 100);
let recordVal: Record<string, number> = { 'wight': 100, 'score': 100 };


@Entry
@Component
struct ParamsType {
  build() {
    Row() {
      Column() {
        Button('get params type')
          .onClick(() => {
            solve(100);
            solve('100');
            solve(true);
            solve(mapVal);
            solve(recordVal);
            solve(gameVal);
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-106
爬取时间: 2025-05-08 04:20:13
来源: Huawei Developer


从API version 12开始支持@ohos.util.json，能够实现将JSON文本转换为JSON对应对象或值，以及将对象转换为JSON字符串等功能。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-107
爬取时间: 2025-05-08 04:20:22
来源: Huawei Developer


方舟虚拟机的内存管理和GC采用的是根可达算法，根可达算法可以解决循环引用问题，不会导致A引用B，B引用A的内存泄漏。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-108
爬取时间: 2025-05-08 04:20:32
来源: Huawei Developer


ArkTS中不支持通过索引访问字段，要使用索引的话可以考虑Record<key, value>，参考代码如下：


```typescript
class Student {
  data: Record<string, string> = { 'name': 'aaa', 'age': 'bbb' };
}


@Entry
@Component
struct KeyObject {
  build() {
    Column() {
      Button('点击')
        .onClick(() => {
          let student = new Student();
          console.info(`${student.data['name']}`);
        })
    }
    .justifyContent(FlexAlign.Center)
    .alignItems(HorizontalAlign.Center)
    .width('100%')
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-109
爬取时间: 2025-05-08 04:20:41
来源: Huawei Developer


napi_module为结构体，包含了模块注册时需要的一些信息，具体定义如下：


```less
static napi_module demoModule = {
  .nm_version = 1, // nm版本号，默认值为1，类型为int
  .nm_flags = 0, // nm标识符，类型为unsigned int
  .nm_filename = nullptr, // 文件名，暂不关注，使用默认值即可，类型为char*
  .nm_register_func = Init, // 指定nm的入口函数，类型为napi_addon_register_func
  .nm_modname = "entry", // 指定TS页面导入的模块名，类型为char*
  .nm_priv = ((void*)0),  // 暂不关注，使用默认即可，类型为void*
  .reserved = { 0 } // 暂不关注，使用默认值即可，类型为void*
};
```


在requireNapi中，loadNativeModule加载模块，会先通过FindNativeModuleByCache在缓存中寻找目标module，如果在缓存中找到，使用GetNativeModulePath拼接so路径，最后用LoadModuleLibrary打开so；如果没有在缓存中没有找到，则要先查找dlopen打开对应so，打开so后，native中的extern "C" __attribute__((constructor)) void RegisterModule(void)函数进行NativeModule加载，然后完成static napi_value Init(napi_env env, napi_value export)中的实际注册动作，返回一个js对象export，该js对象上挂载了开发者提供的native方法，以便于开发者在js侧调用。模块加载流程简介如下图：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160825.91763565841412723471562312259335:50001231000000:2800:1EDEB244A097D104ED231260AFA48BA68E672DDD81B9E407D509F89D1179076A.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-110
爬取时间: 2025-05-08 04:20:52
来源: Huawei Developer


在hvigor->hvigor-config.json5中"logging": { //"level": "info" }的注释取消 ，改为debug，改完后的结果为"logging": { "level": "debug" }，在编译时就可以看到编译的详细过程。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-111
爬取时间: 2025-05-08 04:21:01
来源: Huawei Developer


具体请参考如下示例代码：


```typescript
import { ArrayList } from '@kit.ArkTS';


interface Winner { num: number };
let tmpStr: Record<string, Winner> = JSON.parse('{ "0": {"num": 1}, "1": {"num": 2} }');
const arrayList: ArrayList<Winner> = new ArrayList();
Object.entries(tmpStr).forEach((item) => {
  const value = item[1];
  arrayList.add(value);
})
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-112
爬取时间: 2025-05-08 04:21:11
来源: Huawei Developer


在代码开发中，如果需要对对象的类型做判断，调用不同类的方法，可以使用instanceof进行判断来得知对象的类型，参考代码如下：


```typescript
class BaseClass {
  value: number = 0;


  printf() {
    console.info('base value:' + this.value);
  }


  setValue(val: number) {
    this.value = val;
  }
}


class AClass extends BaseClass {
  value: number = 1;


  setValue(val: number) {
    this.value = val;
  }


  getValue(): number {
    return this.value;
  }
}


class BClass extends BaseClass {
  value: number = 2;


  setValue(val: number) {
    this.value = val;
  }
}


function printValue(base: BaseClass) {
  base.printf();
  let flag = base instanceof AClass;
  console.info('printValue flag:' + flag);
  if (flag) {
    let val = (base as AClass).getValue();
    console.info('printValue val:' + val);
  }
}


@Entry
@Component
struct DetermineObjectType {
  aboutToAppear(): void {
    printValue(new AClass());
    printValue(new BClass());
  }


  build() {
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-113
爬取时间: 2025-05-08 04:21:21
来源: Huawei Developer


可参考如下示例代码，注意只有对象的get/set方法才能绑定this指针。


```typescript
class ReflectClass {
  private a = 'a';


  get getA() {
    return () => {
      return this.a;
    };
  }


  set setA(a: string) {
    this.a = a;
  }
}


function testInvoke() {
  const reflectClass = new ReflectClass();
  const fn: Function = Reflect.get(reflectClass, 'getA', reflectClass);
  console.info(fn());
}


@Entry
@Component
struct ReflectBoundThis {
  aboutToAppear(): void {
    testInvoke();
  }


  build() {
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-114
爬取时间: 2025-05-08 04:21:31
来源: Huawei Developer

1.  目录：build/default/intermediates/obfuscation/default/obfuscation.txt
2.  目录：build/default/cache/default/default@CompileArkTS/esmodule/release/obfuscation/nameCache.json
3.  目录：build/default/intermediates/loader_out/default/...
4.  目录：build/default/cache/default/default@CompileArkTS/esmodule/release/sourceMaps.json

参考链接：


ArkGuard混淆原理及功能


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-115
爬取时间: 2025-05-08 04:21:41
来源: Huawei Developer


可以使用Object.getOwnPropertyNames获取所有方法的字符串数组，注意获取对象的原型prototype需要文件后缀为.ts的文件，参考代码如下：


1. 定义需要获取方法的class文件，testClass.ts：


```less
export class testClass {
  public test(): string {
    return "ArkUI Web Component";
  }


  public toString(): void {
    console.log('Web Component toString');
  }


  public FunToString(): void {
    console.log('Web Component toString');
  }
}
```


2. 获取文件中的方法：


```typescript
import { testClass } from './testClass';


let protoType = testClass.prototype;
let methodsName: string[] = Object.getOwnPropertyNames(protoType);
console.info(methodsName.toString());


@Entry
@Component
struct GetObjectAllFun {
  @State message: string = 'Hello World';


  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-116
爬取时间: 2025-05-08 04:21:50
来源: Huawei Developer


使用内置的js引擎可以参考：JSVM，推荐使用自带JS引擎，不禁止使用三方引擎，但禁止三方引擎的JIT能力。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-117
爬取时间: 2025-05-08 04:22:00
来源: Huawei Developer


问题描述


ArkTS是否支持TypeScript中的闭包函数，即函数嵌套函数的形式？


解决措施


ArkTS不支持在函数内声明函数，但可以改用lambda函数来代替内部函数声明。


参考链接


不支持在函数内声明函数


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-118
爬取时间: 2025-05-08 04:22:09
来源: Huawei Developer


目前支持通过动态import反射调用类的静态成员函数、实例成员函数以及全局方法，具体请查看参考链接。


参考链接


业务扩展场景介绍


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-124
爬取时间: 2025-05-08 04:22:19
来源: Huawei Developer


可以通过设备信息模块deviceInfo查询，常见的版本号获取方式如下：

- 系统软件API版本：deviceInfo.sdkApiVersion
- 首个版本系统软件API版本：deviceInfo.firstApiVersion
- 发行版系统api版本：deviceInfo.distributionOSApiVersion

参考链接


@ohos.deviceInfo (设备信息)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-125
爬取时间: 2025-05-08 04:22:29
来源: Huawei Developer


可以通过getEnvironmentVar接口获取环境变量对应的值。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-126
爬取时间: 2025-05-08 04:22:39
来源: Huawei Developer


属于小端序，可以通过以下代码验证：


```typescript
@Entry
@Component
struct Index {
  @State message: string = 'Hello World';


  isLittleEndian(): boolean {
    const buffer = new ArrayBuffer(2);
    const uint8Array = new Uint8Array(buffer);
    const uint16Array = new Uint16Array(buffer);
    // 将 0xAA 和 0xBB 写入 buffer
    uint8Array[0] = 0xAA;
    uint8Array[1] = 0xBB;
    // 如果以小端序读取，0xBBAA 将被解释为 48042
    // 如果以大端序读取，0xAABB 将被解释为 43707
    return uint16Array[0] === 0xBBAA;
  }


  aboutToAppear() {
    if (this.isLittleEndian()) {
      console.log('小端');
    } else {
      console.log('大端');
    }
  }


  build() {
    RelativeContainer() {
      Text(this.message)
        .id('HelloWorld')
        .fontSize(50)
        .fontWeight(FontWeight.Bold)
        .alignRules({
          center: { anchor: '__container__', align: VerticalAlign.Center },
          middle: { anchor: '__container__', align: HorizontalAlign.Center }
        })
    }
    .height('100%')
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-127
爬取时间: 2025-05-08 04:22:49
来源: Huawei Developer


可以通过process.getPastCpuTime接口获取进程启动到当前时间的CPU时间。


参考链接


process.getPastCpuTime


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-128
爬取时间: 2025-05-08 04:22:59
来源: Huawei Developer


可以通过JSON.stringify()接口实现，stringify(value: Object, replacer?: (number | string)[] | null, space?: string | number): string中，当replacer为数组时，只有包含在这个数组中的属性名才会被序列化到最终的JSON字符串中；当参数为null或者未提供时，则对象所有的属性都会被序列化。


示例代码参考如下：


```typescript
import { JSON } from '@kit.ArkTS';


interface Person {
  name: string;
  age: number;
  city: string;
}


let obj: Person = { name: 'John', age: 30, city: 'ChongQing' };


@Entry
@Component
struct JSONDemo {
  @State str: string = 'to json';


  build() {
    Row() {
      Column() {
        Button(this.str)
          .onClick(() => {
            let jsonStr1 = JSON.stringify(obj); // 所有属性都进行序列化
            console.info('jsonStr1：', jsonStr1); // jsonStr1： {"name":"John","age":30,"city":"ChongQing"}
            let jsonStr2 = JSON.stringify(obj, ['name']); // 指定name属性，进行序列化
            console.info('jsonStr2：', jsonStr2); // jsonStr2： {"name":"John"}
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-129
爬取时间: 2025-05-08 04:23:09
来源: Huawei Developer

1.  示例代码参考如下：

```typescript
import { JSON } from '@kit.ArkTS';


let options: JSON.ParseOptions = {
  bigIntMode: JSON.BigIntMode.PARSE_AS_BIGINT,
}
let numberText = '{"largeNumber":1122333444455556666677777888889}';
let numberObj = JSON.parse(numberText, (key: string, value: Object | undefined | null): Object | undefined | null => {
  if (key === "largeNumber") {
    return value;
  }
  return value;
}, options) as Object;


@Entry
@Component
struct BigIntDemo {
  @State str: string = 'bigint num';


  build() {
    Row() {
      Column() {
        Button(this.str)
          .onClick(() => {
            console.info((numberObj as object)?.["largeNumber"]); // 1122333444455556666677777888889
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-131
爬取时间: 2025-05-08 04:23:19
来源: Huawei Developer


ECMAScript标准中定义的是2^32-1，超过该值会抛出RangeError。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-132
爬取时间: 2025-05-08 04:23:28
来源: Huawei Developer


是的。Node.js使用了事件循环机制来处理异步操作，在Node.js中，异步操作通过回调函数或Promise来处理。ArkTS使用了基于协程的异步I/O机制，I/O事件会分发到I/O线程，不阻塞JS线程，可以通过回调函数或Promise/async/await语法来处理异步操作。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-133
爬取时间: 2025-05-08 04:23:38
来源: Huawei Developer


根据具体业务场景和实现决定。若I/O操作不频繁，对UI主线程其他业务没有影响，则无需使用多线程。若有频繁I/O请求导致UI主线程分发请求的耗时过长，则需要使用多线程用以提高程序的性能和响应速度，具体需要根据Profiler情况决定。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-134
爬取时间: 2025-05-08 04:23:48
来源: Huawei Developer


根据具体业务场景和实现决定。如果业务的网络请求较少或者后续网络数据的处理耗时不长，则无需使用TaskPool去承担额外的线程开启回收及数据传递耗时。如果业务中需要处理大量的网络请求并且对获取的数据进行二次加工耗时长，可以使用TaskPool进行网络请求及数据处理，降低UI主线程负载。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-135
爬取时间: 2025-05-08 04:23:58
来源: Huawei Developer


问题场景


模块间循环依赖可能导致应用运行时模块依赖的变量未初始化，如下示例。index.ets文件执行前，会先执行依赖的page.ets文件，page.ets文件执行时又循环依赖了index.ets导出的foo符号。此时index.ets文件未执行，foo变量尚未完成初始化，会导致运行时异常。


```less
// index.ets
import { bar } from './page'


export function foo() {
  bar()
}


// page.ets
import { foo } from './index'


export function bar() {
  foo()
}
bar()
```


问题现象


运行时发生js crash, crash日志中报错信息为：Error message: foo is not initialized


解决措施


开发者可以通过DevEco Studio中Code Linter检查工具识别应用代码中的循环依赖并进行代码重构，消除循环依赖影响，工具详情请参考代码Code Linter检查。操作步骤如下：


```less
{
  "files": [ // 用于表示配置适用的文件范围的 glob 模式数组。
  "**/*.js",
  "**/*.ts",
  "**/*.ets"
  ],
  "rules": {
  "@security/no-cycle": "error" // 配置循环依赖检查规则。
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-136
爬取时间: 2025-05-08 04:24:08
来源: Huawei Developer


问题现象


出现Failed to execute es2abc. 但是没有具体的错误日志，难以对问题进行定位以及原因分析。


问题场景


场景：开发者在源码中使用大量深度嵌套的代码，比如几百层的if-else，as转换，括号嵌套等，在编译的时候由于递归调用导致超出栈容量上限，引发es2abc的闪退，并且没有相关的错误日志。


定位方案


在windows上，可以打开事件管理器，Windows日志，应用程序，找到对应的时间，如果能找到es2abc.exe的崩溃日志，同时异常代码为 0xc00000fd, 那么表示该编译由于爆栈导致崩溃。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160826.54506058842796303772080949056502:50001231000000:2800:1A864AE27CBD6FB5F6770C32319B8D69B60CD51942218BA578E1A59869D6D701.png)

在mac上，可以进入控制台，点击崩溃报告，找到es2abc,双击查看崩溃日志。


如果出现下图中所示，调用栈出现大量反复的调用相同的函数，那么极有可能是出现了大量递归导致爆栈。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160826.80718969456695840632542286942736:50001231000000:2800:16B5E8590527C0C134292B4E75C5EC584E1B8BB22245638FEDB27E5C49BB878F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160826.14668909541190662695563987677816:50001231000000:2800:3E34328D77C78A969472258344D87A553A0A3F8644D0726F6120524AB0C3B18F.png)

解决措施


排查代码中有无大量重复嵌套的场景，比如几百层if-else，as转换，括号嵌套等，对其进行拆分或者优化。


问题代码示例


包括但不限于以下问题场景


```less
if (condition) {
     if (condition) {
         if (condition) {
             if (condition) {
                 if (condition) {
                     if (condition) {
                         ...
                     }
                 }
             }
         }
     }
 } 
[
     [
         [
             [
                 [
                     [
                         [
                             [
                                 ... 
                            ]
                         ]
                     ]
                 ]
             ]
         ]
     ]
 ] 

```


```less
!!!!!!!!!! 
!!!!!!!!!! 
... 
!!!!!a 
```


```less
var a = 1
a as Int as Int as Int as Int as Int ...
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-137
爬取时间: 2025-05-08 04:24:17
来源: Huawei Developer


问题现象


TextEncoder编码字符串‘你好abc’，格式是gbk，分别获取编码结果长度和编码结果属性buffer的长度。如下图显示TextEncoder编码结果属性buffer的长度比编码结果的长度略大。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160826.59308179124978244325843738082151:50001231000000:2800:2934201CA639D489D3288962B7F38C77AA96B20D20F97DADBE951237043ED0F4.png)

原因解释


在TextEncoder编码底层代码逻辑中，需要创建arraybuffer，通过分析创建的arraybuffer长度就是编码结果buffer属性的长度。


其创建的arraybuffer是用来存放编码结果的，在编码结果未解析时需要提前创建arraybuffer，而创建arraybuffer的长度是未知的，为了保证arraybuffer长度能够存放编码结果，其长度是取编码字符串中单个字符占用的最大字节数乘以字符串长度来设置的，因此导致了TextEncoder编码结果buffer属性的byteLength比编码结果的长度略大。


解决措施


如果需要使用TextEncoder编码结果属性buffer的byteLength准确长度，可以通过buffer自带函数slice，依据TextEncoder编码结果长度获取buffer的byteLength准确长度。示例如下:


```less
let textEncoder = util.TextEncoder.create('gbk');
let rstEncodeData: Uint8Array = textEncoder.encodeInto('你好abc');
let length = rstEncodeData.length;
console.info("rstEncodeData.length = " + length);
let byteLength = rstEncodeData.buffer.byteLength;
console.info("rstEncodeData.buffer.byteLength = " + byteLength);
console.info("rstEncodeData.buffer.slice(0, length).byteLength = " + rstEncodeData.buffer.slice(0, length).byteLength);
// rstEncodeData.buffer.slice(0, length).byteLength = 7
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-138
爬取时间: 2025-05-08 04:24:27
来源: Huawei Developer


定义一个callback函数的样例，参考代码如下：

1. 

```typescript
// 页面中定义2个参数,空返回的callback函数 
myCallback: (a:number,b:string) => void
```

2. 

```less
aboutToAppear() { 
  // callback函数初始化 
  this.myCallback= (a,b)=>{ 
    console.info(`handle myCallback a=${a},b=${b}`) 
  }}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-139
爬取时间: 2025-05-08 04:24:37
来源: Huawei Developer


通过箭头函数实现。参考代码如下：


```less
@State num: number = 1 
interface T { 
  start: () => number 
} 
obj: T = { 
  start:() => { 
    return this.num 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-140
爬取时间: 2025-05-08 04:24:47
来源: Huawei Developer


ArkTS不支持匿名类，建议使用嵌套类实现。因为使用匿名类创建的对象类型未知，这与ArkTS不支持structural typing和对象字面量的类型冲突。代码示例如下：


```typescript
class A { 
  foo() { 
    class B { 
      v: number = 123; 
    } 
    let b = new B(); 
  } 
}
```


或者换成下面这种写法：


```typescript
export interface AnonymousInnerClass<T> { 
  onSuccess: (t: T) => void; 
  onFailed: (code: string, reason: string) => void; 
} 
 
let AnonymousInnerClassInstance: AnonymousInnerClass<void> = { 
  onSuccess: () => { 
    console.log('success'); 
  }, 
  onFailed: () => { 
    console.log('failed'); 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-141
爬取时间: 2025-05-08 04:24:57
来源: Huawei Developer


可使用Record类型，有几个变量就对应几个类型参数，参考代码如下：


```less
const asd: Record<string, number | string> = { 
  'name': 'xc', 
  'age': 29 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-142
爬取时间: 2025-05-08 04:25:06
来源: Huawei Developer


示例代码如下：


```typescript
// 自定义interface如下： 
export interface OnTrustListener { 
  OnSuccess: (data: string) => void; 
  OnError: (error: string) => void; 
} 
 
@Component 
export struct InterfaceUse { 
  private listener: OnTrustListener = { 
    OnSuccess: (data: string) => { 
      console.info('data is:' + data); 
    }, 
    OnError: (error: string) => { 
      console.info('error is:' + error); 
    } 
  }; 
 
  build() { 
    Column() { 
      Button('click me') 
        .onClick((event: ClickEvent) => { 
          this.listener.OnSuccess('success'); 
        }) 
    } 
    .width('100%') 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-threading-model
爬取时间: 2025-05-08 04:25:14
来源: Huawei Developer

- 有哪些创建线程的方式
- 应该如何设计大量线程并发方案
- 如何设置Task优先级
- 线程间JS对象通过序列化方式进行数据通信，是否存在性能问题
- TaskPool和Worker的异同点
- Worker和TaskPool的线程数量是否有限制
- JS线程通过napi创建的C++线程的处理结果，如何返回JS线程
- 系统多线程模型是什么样的
- 是否支持Context跨线程传递
- 在多线程并发场景中，如何实现安全访问同一块共享内存
- 子线程和主线程的优先级及任务执行策略是什么
- ArkTS中Worker线程、Taskpool线程如何与宿主线程通信
- ArkTS是否支持类似Java的共享内存模型进行多线程开发
- ArkTS的线程机制是怎么样的？每个线程是一个单独的JS引擎吗？如果每个线程开销比较小的话，为什么要限制线程数量
- TaskPool在任务执行过程中如何跟主线程进行通信？如何操作同一块内存变量
- 对于多线程操作首选项和数据库是不是线程安全的？还是每一个线程独立的
- 如果在ArkTS中大部分后台任务（计算、埋点、入库）都使用异步并发的方式，是否会使主线程越来越慢，引起卡顿丢帧问题？为什么
- 在ArkTS的主线程中使用await会堵塞主线程吗
- 是否可以在TaskPool中动态加载模块（HAR、HSP、SO）
- TaskPool线程内存如何共享
- TaskPool后台I/O任务池，应用能否自行做管控？有无方法开放管理机制
- 如何解决应用需要避免开辟过多线程，并发处理任务数量受限，无法充分发挥设备性能的问题
- Worker线程内存如何共享
- 如何判断是否为主线程
- 如何对异步方法进行插桩/替换
- ArkTS实现多Worker实例
- 如何使用TaskPool在子线程调用对象成员函数
- 如何在Worker中开启多级子线程
- 如何在TaskPool和Woker获取上下文Context
- 异步是否对主线程有影响

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-2
爬取时间: 2025-05-08 04:25:24
来源: Huawei Developer

- 在ArkTS中使用Worker创建线程，Worker线程在主线程中创建，与主线程相互独立，但不能直接操作UI，最多可以创建64个Worker线程。
- 在ArkTS中使用任务池（TaskPool）创建线程任务。
- 通过NAPI机制，在C代码中使用标准的线程API创建线程。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-25
爬取时间: 2025-05-08 04:25:33
来源: Huawei Developer


系统采用ArkTS作为开发语言，由于底层线程模型对接了libuv，因此在应用进程启动后，会有多个I/O线程用于I/O操作。JS线程的I/O异步操作，会在I/O线程执行，JS线程可以同时执行其他操作，不存在阻塞等待问题。同时，ArkTS提供了TaskPool并发API，类似GCD的线程池能力，可以执行任务，而且不需要开发者进行线程生命周期管理。因此针对需要大量线程的问题，开发建议如下：

- 将多线程任务转变为并发任务，通过TaskPool分发执行。
- I/O型任务不需要单独开启线程，而是在当前线程（可以是TaskPool线程）执行。
- 少量需要常驻的CPU密集型任务，采用Worker，并且需要控制在64个及以下。

参考链接


TaskPool和Worker的对比


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-26
爬取时间: 2025-05-08 04:25:43
来源: Huawei Developer


当前支持设置任务优先级，示例如下：


```typescript
import { taskpool } from '@kit.ArkTS'; 
 
@Concurrent 
function printArgs(args: number): number { 
  console.log("printArgs: " + args); 
  return args; 
} 
 
let task: taskpool.Task = new taskpool.Task(printArgs, 100); // 100: test number 
taskpool.execute(task, taskpool.Priority.HIGH).then((res) => { 
  console.log("taskpool result is :" + res); 
});
```

- HIGH：值为0，表示任务为高优先级。
- MEDIUM：值为1，任务为中优先级。
- LOW：值为2，任务为低优先级。

参考链接


Priority


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-24
爬取时间: 2025-05-08 04:25:52
来源: Huawei Developer


目前线程间对象的数据通信依赖序列化、反序列化，耗时与数据量相关，需要控制传输的数据量，或者采用ArrayBuffer或者SharedArrayBuffer的转移或者共享。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-27
爬取时间: 2025-05-08 04:26:01
来源: Huawei Developer

- 不同点：两者是不同颗粒度的并发API，Worker更像Thread或者Service维度，Task就是单一任务维度。同时TaskPool简化开发者开发并发程序，支持优先级和取消，并且通过统一管理节省系统资源优化调度。
- 相同点：在JS相关的线程间交互上，二者本质都是内存隔离模型，参数与范围值的限制是一致的，也有开销。

参考链接


TaskPool和Worker的对比


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-28
爬取时间: 2025-05-08 04:26:10
来源: Huawei Developer


TaskPool内部会动态调整线程个数，不支持设置数量，只需要往线程池中抛任务，确保高优先级任务的及时执行。


Worker的线程个数最多64个，如果Worker超过规定个数，会创建失败。


在使用时，TaskPool与Worker两者独立，不相互影响，因此Worker在达到上限数量时，不会影响TaskPool。Worker是固定数量，当前是64个。TaskPool线程池的数量会根据硬件条件、任务负载等情况动态调整。


参考链接


TaskPool和Worker的对比


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-30
爬取时间: 2025-05-08 04:26:20
来源: Huawei Developer


采用napi_create_threadsafe_function在JS线程创建可被任意线程调用的函数，在C++线程调用napi_call_threadsafe_function可以将结果回调给主线。


参考链接


使用Node-API接口进行线程安全开发


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-32
爬取时间: 2025-05-08 04:26:30
来源: Huawei Developer


ArkTS主要提供TaskPool API支持多线程开发，常驻耗时任务还可以使用Worker，但是Worker有数量限制，当前最大数量是64个Worker。


Native侧建议使用FFRT线程池，pthread暂无限制。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-33
爬取时间: 2025-05-08 04:26:39
来源: Huawei Developer


支持，可以直接将Context作为参数传递，参考链接：Native与ArkTS对象绑定。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-34
爬取时间: 2025-05-08 04:26:49
来源: Huawei Developer


可以使用共享对象SharedArrayBuffer实现。SharedArrayBuffer对象存储的数据在同时被修改时，需要通过Atomics原子操作保证其同步性，即下个操作开始之前务必需要等到上个操作已经结束。代码示例：


```less
// index.ets 
import { worker } from '@kit.ArkTS'; 
let sab = new SharedArrayBuffer(32); 
// int32 buffer view for sab 
let i32a = new Int32Array(sab); 
i32a[0] = 0; 
let producer = new worker.ThreadWorker("entry/ets/workers/worker_producer.ets") 
producer.postMessage(sab); 
let consumer = new worker.ThreadWorker("entry/ets/workers/worker_consumer.ets") 
consumer.postMessage(sab);
```


```less
// worker_producer.ets 
import { MessageEvents, worker } from '@kit.ArkTS'; 
 
const workerPort = worker.workerPort; 
workerPort.onmessage = (e: MessageEvents): void => { 
  let sab = e.data as SharedArrayBuffer; 
  // view sab buffer in int32 array 
  let i32a = new Int32Array(sab); 
  console.info("Producer: received sab"); 
  // 每2s唤醒consumer. 
  setInterval(() => { 
    let length = i32a.length; 
    for (let i = 1; i < length; i++) { 
      i32a[i] = Math.random() * length; 
    } 
    Atomics.notify(i32a, 0, 1); // 通知 customer 
  }, 2000); 
}
```


```less
// worker_consumer.ets 
import { MessageEvents, worker } from '@kit.ArkTS'; 
 
const workerPort = worker.workerPort; 
workerPort.onmessage = (e: MessageEvents) => { 
  let sab = e.data as SharedArrayBuffer; 
  let i32a = new Int32Array(sab); 
  console.info("Customer: received sab"); 
  while (true) { 
    Atomics.wait(i32a, 0, 0); // 这里到唤醒之前都会被阻塞 
    let length = i32a.length; 
    for (let i = length - 1; i > 0; i--) { 
      console.info("arraybuffer " + i + " value is " + i32a[i]); 
      i32a[i] = i; 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-35
爬取时间: 2025-05-08 04:26:59
来源: Huawei Developer


主线程作为UI线程，拥有最高优先级。在负载较高时，执行会更快；负载较低时，效率差别不大。


子线程可以通过优先级设置，任务优先级等影响调度。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-36
爬取时间: 2025-05-08 04:27:09
来源: Huawei Developer


Worker支持通过PostMessage往父线程抛任务。TaskPool支持通过sendData往父线程发消息，触发任务。


PostMessage接口示例如下：


```less
import { worker } from '@kit.ArkTS'; 
 
const workerInstance = new worker.ThreadWorker("entry/ets/workers/worker.ets"); 
let buffer = new ArrayBuffer(8); 
workerInstance.postMessage(buffer, [buffer]);
```


sendData接口示例如下：


```typescript
import { taskpool } from '@kit.ArkTS'; 


@Concurrent 
function ConcurrentFunc(num: number): number { 
  let res: number = num * 10; 
  taskpool.Task.sendData(res); 
  return num; 
}
```


参考链接


postMessage，sendData


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-37
爬取时间: 2025-05-08 04:27:19
来源: Huawei Developer


无法做到通过加锁的方式实现多个线程同时对同一个内存对象的同时操作。


ArkTS是Actor并发模型，线程间内存隔离，当前只支持SharedArrayBuffer或者Native层对象的共享。


参考链接


多线程并发概述


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-39
爬取时间: 2025-05-08 04:27:28
来源: Huawei Developer


设备的核数有限，线程数泛滥引起调度开销和内存开销。


HarmonyOS提供了ArkTS任务池和FFRT任务池支持系统统一调度。


系统ArkTS线程中JS部分是基于内存隔离的Actor模型实现，每个线程拥有单独的JS环境实例，因此开启线程会有较大的内存开销。


另外设备的核数有限，其他系统应用线程数开得过多是因为同步锁、同步I/O编程的方式导致。


HarmonyOS提供的异步I/O调用均分发到I/O线程池，不会阻塞应用线程，因此不需要独占线程调用I/O，所需的线程数量远小于其他操作系统。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-40
爬取时间: 2025-05-08 04:27:38
来源: Huawei Developer


TaskPool的任务支持通过sendData接口触发主线程的onReceiveData回调。


当前多个线程之间支持通过SharedArrayBuffer进行同一块内存的操作。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-41
爬取时间: 2025-05-08 04:27:48
来源: Huawei Developer


是线程安全的。

- 首选项默认是线程安全的，多个线程可以同时读取数据，写入操作需要同步控制，以避免数据不一致。
- 数据库SQLite和ORM框架均为线程安全，需要合理管理连接和操作。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-42
爬取时间: 2025-05-08 04:27:57
来源: Huawei Developer


ArkTS层接口的异步如果不涉及I/O操作，则异步任务会在主线程的微任务执行时机触发，仍然占用主线程。推荐使用TaskPool，分发到后台任务池进行。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-43
爬取时间: 2025-05-08 04:28:07
来源: Huawei Developer


不会。await会挂起当前异步任务，等异步任务满足条件后再唤醒执行，主线程可以处理其他任务。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-47
爬取时间: 2025-05-08 04:28:17
来源: Huawei Developer


可以，TaskPool动态加载能力跟主线程能力一致。但是TaskPool线程加载后，由于模块化线程隔离的缘故，不能给主线程复用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-58
爬取时间: 2025-05-08 04:28:27
来源: Huawei Developer


TaskPool底层模型为Actor模型，本身线程间隔离，内存不共享。目前可以通过传输可共享对象SharedArrayBuffer达到内存共享的目的。


但需要注意，SharedArrayBuffer对象存储的数据在同时被修改时，需要通过原子操作保证其同步性，即下个操作开始之前务必需要等到上个操作已经结束。


参考代码如下：


```less
import { taskpool } from '@kit.ArkTS'; 
 
@Concurrent 
function producer(ArrayBuffer: Int32Array): void { 
  let i32a = ArrayBuffer; 
  console.info("Producer: received sab"); 
  setInterval(() => { 
    let length = i32a.length; 
    for (let i = 1; i < length; i++) { 
      i32a[i] = Math.random() * length; 
    } 
    Atomics.notify(i32a, 0, 1); // notify customer 
  }, 2000); 
} 
 
@Concurrent 
function consumer(ArrayBuffer: Int32Array): void { 
  let i32a = ArrayBuffer; 
  console.info("Customer: received sab"); 
  while (true) { 
    Atomics.wait(i32a, 0, 0); 
    let length = i32a.length; 
    for (let i = length - 1; i > 0; i--) { 
      console.info("arraybuffer " + i + " value is " + i32a[i]); 
      i32a[i] = i; 
    } 
  } 
} 
 
function ArrayBufferShared(ArrayBuffer: Int32Array): void { 
  let group: taskpool.TaskGroup = new taskpool.TaskGroup(); 
  group.addTask(consumer, ArrayBuffer); 
  group.addTask(producer, ArrayBuffer); 
  taskpool.execute(group, taskpool.Priority.HIGH).then((res: Object) => { 
    // 结果数组汇总处理 
  }) 
} 
 
@Component 
export struct TestArrayBufferSharedView { 
  build() { 
    Row() { 
      Column() { 
        Text('Click') 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            let sab = new SharedArrayBuffer(32); 
            let i32a = new Int32Array(sab); 
            ArrayBufferShared(i32a); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


@ohos.taskpool（启动任务池）


多线程并发概述 (TaskPool和Worker)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-59
爬取时间: 2025-05-08 04:28:37
来源: Huawei Developer


1. TaskPool后台线程是根据负载及硬件决定的，无法开放管理，只能支持串行队列，任务组等机制进行任务管控。


2. I/O任务池有底层进行调度，无法自行管控。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-60
爬取时间: 2025-05-08 04:28:46
来源: Huawei Developer


当前ArkTS创建线程(worker)会创建一个新的ArkTS引擎实例，会占用额外的内存。同时，ArkTS提供了TaskPool并发API，类似GCD的线程池能力，可以执行任务，而且不需要开发者进行线程生命周期管理。Task会被调度到有限数量的工作线程执行，多个task会共享这些工作线程（ArkTS引擎实例），系统会根据负载情况扩容/缩容工作线程的数量，充分发挥硬性性能。


因此针对需要大量线程的问题，应用的开发建议如下：


将多线程任务转变为并发任务，通过TaskPool分发执行。I/O型任务不需要单独开启线程，而是在当前线程（可以是TaskPool线程）执行。少量需要常驻的CPU密集型任务，采用Worker，并且需要控制在64个及以下。


参考链接


TaskPool和Worker的对比


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-66
爬取时间: 2025-05-08 04:28:56
来源: Huawei Developer


Worker底层模型为Actor模型，本身线程间隔离，内存不共享。目前可以通过传输可共享对象SharedArrayBuffer达到内存共享的目的。


但需要注意，SharedArrayBuffer对象存储的数据在同时被修改时，需要通过原子操作保证其同步性，即下个操作开始之前务必需要等到上个操作已经结束。


参考代码如下：


1.在Index.ets中新建两个ThreadWorker。


```typescript
import { worker } from '@kit.ArkTS'; 
 
@Component 
export struct ThreadWorkerView { 
  build() { 
    Column() { 
      Button('测试Worker线程内存共享') 
        .width(200) 
        .onClick(() => { 
          let sab = new SharedArrayBuffer(32); 
          let i32a = new Int32Array(sab); 
          i32a[0] = 0; 
          let producer = new worker.ThreadWorker("entry/ets/pages/ThreadWorkerSharedArrayBuffer/WorkerProducer.ets"); 
          producer.postMessage(sab); 
          let consumer = new worker.ThreadWorker("entry/ets/pages/ThreadWorkerSharedArrayBuffer/WorkerConsumer.ets"); 
          consumer.postMessage(sab); 
        }) 
    } 
  } 
}
```


2.在 build-profile.json5的buildOption中添加字段。


```less
  "buildOption": { 
    "sourceOption": { 
      "workers": [ 
        "./src/main/ets/pages/ThreadWorkerSharedArrayBuffer/WorkerProducer.ets", 
        "./src/main/ets/pages/ThreadWorkerSharedArrayBuffer/WorkerConsumer.ets" 
      ] 
    } 
  },
```


3.编写worker_producer.ets脚本。


```less
import { MessageEvents, worker } from '@kit.ArkTS'; 
 
const workerPort = worker.workerPort; 
workerPort.onmessage = (e: MessageEvents): void => { 
  let i32a = new Int32Array(e.data); 
  console.info("Worker Producer: received sab"); 
  setInterval(() => { 
    let length = i32a.length; 
    for (let i = 1; i < length; i++) { 
      i32a[i] = Math.random() * length; 
    } 
    Atomics.notify(i32a, 0, 1); // notify customer 
  }, 2000); 
}
```


4.编写worker_consumer.ets脚本。


```less
import { MessageEvents, worker } from '@kit.ArkTS'; 
 
const workerPort = worker.workerPort; 
workerPort.onmessage = (e: MessageEvents): void => { 
  let i32a = new Int32Array(e.data); 
  console.info("Worker Customer: received sab"); 
  while (true) { 
    Atomics.wait(i32a, 0, 0); 
    let length = i32a.length; 
    for (let i = length - 1; i > 0; i--) { 
      console.info("arraybuffer " + i + " value is " + i32a[i]); 
      i32a[i] = i; 
    } 
  } 
}
```


参考链接


@ohos.worker (启动一个Worker)


多线程并发概述 (TaskPool和Worker)


Actor模型


内存共享模型


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-68
爬取时间: 2025-05-08 04:29:06
来源: Huawei Developer


通过Process可以获取当前的进程号和线程号，如果当前代码执行的进程号和线程号相同，则表示当前执行环境为主线程。


参考代码：


```less
import { process } from '@kit.ArkTS' 
 
function isMainThread(): boolean { 
  return process.pid == process.tid; 
}
```


对于Native侧，根据getpid()方法获取pid和syscall方式获取tid；


参考代码：


```less
#include <unistd.h> 
#include <thread> 
#include <sys/syscall.h> 
 
bool isMainThread() { 
  pid_t pid = getpid(); 
  pid_t tid = syscall(SYS_gettid); 
  if (pid == tid) { 
    return true; 
  } else { 
    return false; 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-100
爬取时间: 2025-05-08 04:29:16
来源: Huawei Developer


参考如下示例：


```typescript
import { util } from '@kit.ArkTS'; 
 
class Test1 { 
  static data: string = "initData"; 
 
  static async printData(arg: string) { // 异步方法 
    console.log("execute original printData"); 
    console.log("Test.data is" + Test1.data); 
    console.log('arg', arg); 
    return 0; 
  } 
} 
 
// 插桩 
util.Aspect.addBefore(Test1, "printData", true, 
  (classObj: Object, arg: string): void => { 
    console.log("execute before"); 
    Reflect.set(classObj, "data", "dataChangedByBefore"); 
    console.log("arg is " + arg); 
  } 
); 
 
Test1.printData("m1").then((res) => { 
  console.log("res = " + res.toString()); 
  console.log("Test.data = " + Test1.data); 
}); 
 
class Test2 { 
  static data: string = "initData"; 
 
  static async printData(arg: string) { // 异步方法 
    console.log("execute original printData"); 
    console.log("Test.data is" + Test2.data); 
    console.log('arg', arg); 
    return 0; 
  } 
} 
 
// 替换 
util.Aspect.replace(Test2, "printData", true, 
  // 替换成另外一个异步函数 
  async (classObj: Object, arg: string): Promise<number> => { 
    console.log("execute instead"); 
    Reflect.set(classObj, "data", "dataChangedByInstead"); 
    console.log("arg is " + arg); 
    return Promise.resolve(100); 
  }); 
 
Test2.printData("m1").then((res) => { 
  console.log("res = " + res.toString()); 
  console.log("Test.data = " + Test2.data); 
});
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-103
爬取时间: 2025-05-08 04:29:26
来源: Huawei Developer


实现多Worker并进行调用传递消息，利用registerGlobalCallObject传递对象及调用函数，获取buffer，注：callGlobalCallObjectMethod方法在主线程中运行。


```typescript
import { testMultyWorker } from './testWorker'; // 导入方法


@Entry
@Component
struct Index {
  build() {
    Row() {
      Column() {
        Button('test workers')
          .onClick(() => {
            testMultyWorker(); // 测试多worker
          })
      }.width('100%')
    }.height('100%')
  }
}
```


```typescript
import { MessageEvents, worker } from '@kit.ArkTS';


const mainThreadTag: string = 'mainthread';


// 初始化2个worker，如果close或者terminate就不能用了
let worker1: worker.ThreadWorker = new worker.ThreadWorker('entry/ets/workers/worker1.ets', { name: 'worker1' });
let worker2: worker.ThreadWorker = new worker.ThreadWorker('entry/ets/workers/worker2.ets', { name: 'worker2' });


// 自定义单例
class TestObj {
  private message: string = 'this is a message from TestObj';


  public getMessage(): string {
    console.log(mainThreadTag, 'worker call obj func: getMessage()');
    return this.message;
  }


  public getMessageWithInput(str: string): string {
    return this.message + 'with input:' + str;
  }


  public setSharedArrayBuffer() {
    let num = new Int16Array(this.sharedBuffer);
    num[0] = 20;
  }


  public getSharedArrayBuffer(): SharedArrayBuffer {
    return this.sharedBuffer;
  }


  static registerObj: TestObj = new TestObj();
  private sharedBuffer: SharedArrayBuffer = new SharedArrayBuffer(1024);
}


// worker 的otnMessage 监听
function onMessage(e: MessageEvents): void {
  switch (e.data.type as number) {
    case 0:
      console.log(mainThreadTag, 'received message type: 0, value is: %{public}s, next to post msg to worker2',
        e.data.value);
      worker2.postMessage('This is msg from mainthread switch');
      break;
    case 1:
      console.log(mainThreadTag, 'received message value %{public}d, next to post msg to worker1',
        e.data.value as number);
      worker1.postMessage({ 'type': 0 });
      break;
    default:
      console.log(mainThreadTag, 'invalid type, next to return');
    // 增加一个定时，体现worker运行
      setTimeout(() => {
        console.log(mainThreadTag, 'invalid type, next to return');
      }, 5000);
      break;
  }
}


// export 函数
export function testMultyWorker() {
  TestObj.registerObj.setSharedArrayBuffer();
  // 在ThreadWorker实例上注册registerObj
  worker2.registerGlobalCallObject('myObj', TestObj.registerObj);
  worker1.registerGlobalCallObject('myObj', TestObj.registerObj);


  console.log(mainThreadTag, 'this is a msg to start worker');
  worker1.postMessage('this is a msg to start worker1');


  worker1.onmessage = onMessage;
  worker2.onmessage = onMessage;


  console.log(mainThreadTag, 'end');
  worker1.onexit = () => {
    console.log('main thread terminate worker1');
  }
  worker2.onexit = () => {
    console.log('main thread terminate worker2');
  }
}
```

1.  Worker1.ets： Worker2.ets：

```typescript
import { ErrorEvent, MessageEvents, ThreadWorkerGlobalScope, worker, process } from '@kit.ArkTS';


const worker1: string = 'worker1';
const workerPort: ThreadWorkerGlobalScope = worker.workerPort;


workerPort.onmessage = (e: MessageEvents) => {
  console.log(worker1, 'enter worker1, process uid:%{public}d, pid:%{public}d, tid:%{public}d',
    process.uid, process.pid, process.tid);


  if (e.data.type === 0) {
    workerPort.postMessage({ 'type': 2 });
    console.log(worker1, 'begin to end worker1');
    // workerPort.close()  // close后不允许再使用，否则引发crash
    return;
  }


  try {
    let str1: string = workerPort.callGlobalCallObjectMethod('myObj', 'getMessage', 0) as string;
    console.log(worker1, 'call shared class to get func: getMessage(), return is: %{public}s', str1);
  } catch (e) {
    console.log(worker1, 'call shared class getMessage get this %{public}s ,errcode %{public}d', e.message, e.code);
  }


  try {
    let res: SharedArrayBuffer =
      workerPort.callGlobalCallObjectMethod('myObj', 'getSharedArrayBuffer', 0) as SharedArrayBuffer;
    let typedArr = new Int16Array(res);
    console.log(worker1, 'call shared class func: getSharedArrayBuffer(), return is: %{public}d', typedArr[0]);
    typedArr[0] = 25;
    console.log(worker1, 'work1 change the value to： %{public}d', typedArr[0]);
  } catch (e) {
    console.log(worker1, 'call shared class getSharedArrayBuffer get this %{public}s', e.message);
  }


  workerPort.postMessage({ 'type': 0, 'value': 'this is a msg from worker1 to main' });
}


workerPort.onmessageerror = (e: MessageEvents) => {
  console.log(worker1, 'received a message error');
}


workerPort.onerror = (e: ErrorEvent) => {
  console.log(worker1, 'worker1 error');
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-120
爬取时间: 2025-05-08 04:29:36
来源: Huawei Developer


通过将对象Sendable化来使用对象中的方法。具体可参考如下示例代码：


```typescript
// TestClass.ets
@Sendable
export class TestClass {
  value: number = 888;


  GetValue(): number {
    return this.value;
  }


  Print(): void {
    console.info('value:' + this.value);
  }
}
```


```typescript
// xxx.ets:
import { taskpool } from '@kit.ArkTS';
import { TestClass } from './TestClass'; // 返回静态句柄


// 步骤1: 定义并发函数，内部调用同步方法
@Concurrent
function func(num: number): number {
  // 调用静态类对象中实现的同步等待调用
  let testClass = new TestClass();
  let sum = testClass.GetValue() + num;
  return sum;
}


// 步骤2: 创建任务并执行
function asyncGet(): void {
  // 创建task并传入函数func
  let task: taskpool.Task = new taskpool.Task(func, 1);
  // 执行task任务并对同步逻辑后的结果进行操作
  taskpool.execute(task).then((result: object) => {
    console.info('testTag result:' + result);
  });
}


@Entry
@Component
struct Index {
  @State message: string = 'Hello World';


  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .onClick(() => {
            // 步骤3: 执行并发操作
            asyncGet();
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-121
爬取时间: 2025-05-08 04:29:46
来源: Huawei Developer


具体可参考如下示例代码：


```typescript
import { ErrorEvent, MessageEvents, worker } from '@kit.ArkTS';


const workerInstance = new worker.ThreadWorker('entry/ets/pages/Worker.ets');


// 主线程向worker线程传递信息
workerInstance.postMessage('123');


// 主线程接收worker线程信息
workerInstance.onmessage = (e: MessageEvents): void => {
  // data：worker线程发送的信息
  let data: string = e.data;
  console.info(`main thread onmessage, data:${data}`);
  const workerInstance1 = new worker.ThreadWorker('entry/ets/pages/Work.ets');
  workerInstance1.postMessage('123');
  workerInstance1.onmessage = (e: MessageEvents): void => {
    // data：worker线程发送的信息
    let data1: string = e.data;
    console.info(`main thread onmessage1, data:${data1}`);
    // 销毁Worker对象
    workerInstance1.terminate();
  }
  // 在调用terminate后，执行onexit
  workerInstance1.onexit = (code) => {
    console.info(`main thread terminate, code:${code}`);
  }
  // 销毁Worker对象
  workerInstance.terminate();


}
// 在调用terminate后，执行onexit
workerInstance.onexit = (code) => {
  console.info(`main thread terminate, code:${code}`);
}


workerInstance.onerror = (err: ErrorEvent) => {
  console.error('main error message ' + err.message);
}
```


```typescript
// Work.ets & Worker.ets
import { ErrorEvent, MessageEvents, worker } from '@kit.ArkTS';


// 创建worker线程中与主线程通信的对象
const workerPort = worker.workerPort;


// worker线程接收主线程信息
workerPort.onmessage = (e: MessageEvents): void => {
  // data：主线程发送的信息
  let data: string = e.data;
  console.info(`Work.ets onmessage: data ${data}`);


  // worker线程向主线程发送信息
  workerPort.postMessage('123');
}


// worker线程发生error的回调
workerPort.onerror = (err: ErrorEvent) => {
  console.info('worker.ets onerror' + err.message);
}
```


```less
// 模块级 build.profile.json5
"buildOption": {
  "sourceOption": {
    "workers": [
      "./src/main/ets/pages/Worker.ets",
      "./src/main/ets/pages/Work.ets"
    ]
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-122
爬取时间: 2025-05-08 04:29:56
来源: Huawei Developer


Worker线程和TaskPool线程中无法直接获取到组件级的Context 。可以通过主线程参数传递应用级Context，通过getContext接口获取Context上下文。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkts-150
爬取时间: 2025-05-08 04:30:05
来源: Huawei Developer


setInterval是异步的，是否影响主线程，要看setInterval的callback中做了什么，如果仅是少量数据处理，影响较小；如果是大量数据处理，建议使用worker或taskpool；如果是给页面显示的数据重新赋值，过于频繁的确会影响主线程，因为绘制是在主线程处理的。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk
爬取时间: 2025-05-08 04:30:15
来源: Huawei Developer

- NDK开发
- 任务并发调度（Function Flow Runtime）
- JSVM

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-development
爬取时间: 2025-05-08 04:30:25
来源: Huawei Developer

- 在Native侧如何精准获取ArkTS侧传入的字符串长度
- 在Native侧如何处理ArkTS侧传入的字符串被截断的异常场景
- 如何对多个C++源文件中接口进行导出声明
- ArkTS侧与Native侧分别如何动态加载SO库
- 在Native侧如何集成三方SO库
- ArkTS侧与Native侧如何进行map数据交互
- 如何导出C++自定义类，导出后如何在ArkTS侧进行类方法调用
- 如何修改代码工程所支持的C++语言版本
- 如何在Native侧获取屏幕亮度
- 如何在Native侧往用户目录写临时文件
- 如何在Native侧添加debug版本声明
- 如何在Native侧区分ArkTS侧创建的ArrayBuffer和Uint8Array对象
- 如何将Native侧的函数封装到类中导出到ArkTS侧使用
- 如何获取Native侧printf等方法打印的信息
- Native侧如何获取ArkTS侧的应用包名
- 如何在Native侧调用ArkTS侧的系统能力
- Native侧如何访问ArkTS侧系统定义的异步方法
- 如何在Native侧直接使用其他模块的ArkTS方法
- 如何在ArkTS侧引用其他三方so库
- 如何在Native侧访问应用包内Rawfile资源
- 如何在Native侧跨模块访问资源
- 如何在Native侧获取APP版本信息
- ArkTS的对象数据与Native的对象数据如何绑定，相互持有对象数据时内存如何管理
- NAPI执行上层回调时，如何获取env
- Native如何调ArkTS的方法
- 如何在Native侧集成三方库Curl，并进行HTTP数据请求
- 如何通过AKI三方库实现ArkTS与C/C++之间的跨语言调用
- Native工程中如何使用其他三方so库
- Native侧如何使用hilog打印出日志信息
- 如何使用后缀为so.x.y类型的so库，例如libxxx.so.3.1、libxxx.so.3.1.0
- napi_module结构体字段描述解析
- Native侧如何获取可操作的文件目录
- 新建工程如何使用已有工程中的so库函数
- ArkTS侧如何接收Native侧的键值对进行修改并返回到Native侧
- Native侧如何获取ArkTS侧Object对象及其成员变量
- 如何正确地在CMakeLists.txt文件中配置头文件搜索路径
- Native侧如何引入头文件deviceinfo.h
- 如何在Native侧构建一个ArkTS对象
- Native C++模版中，生成的so库的名称在哪里定义，需要与哪些内容保持一致
- Native侧如何打印char指针
- c++创建的（napi_create_object），或者作为参数传下来的js value，如果想持久持有，需要怎么做？以及怎么主动销毁或减少引用计数
- 在ArkTS层往C++层注册一个object或function，C++层可以按需往这个回调上进行扔消息同步到上层应用么，请提供示例？在注册object或function时，napi_env是否可以被长时持有？扔消息同步到上层应用时，是否需要在特定线程
- Cmake编译时如何显示不同级别的日志信息
- ArkTS侧如何释放绑定的C++侧对象
- Native侧如何获取ArkTS侧的Uint8Array实例
- Native侧如何获取ArkTS侧类实例
- 如何跨Hap模块调用C++ API
- HarmonyOS编译构建时如何指定编译架构信息
- 在ArkTS侧如何引用Native侧使用napi_create_buffer接口构造的对象
- Native侧如何通过char指针构造ArrayBuffer数组
- 在CMakeLists文件中如何获取模块版本信息
- 传入自定义类型对象到Native侧时，index.d.ts文件如何声明
- Native侧如何对ArkTS传递的Object类型的数据、属性进行修改
- 如何通过多个xxx.d.ts文件导出Native侧接口
- 如何在ArkTS侧监听Native侧日志信息
- 使用napi_run_script_path接口执行包内abc文件的使用限制
- 如何通过C接口使用网络相关功能
- 如何实现ArkTS与C/C++的HashMap转换
- napi_call_function调用时除了会有pending exception外，是否还有其他异常场景
- 在HSP/HAR包中支持导出C/C++的Native方法吗？如果不支持，替代方案是什么
- 多so相互依赖场景下如何解耦
- 如何在一个模块中使用另一个模块中编译出来的so
- napi_env禁止缓存的原因是什么
- 如何在ArkTS侧管理Native侧的C++对象
- har包的libc++版本与工程不一致时，程序如何兼容
- C侧如何打开文件
- Native侧如何合理管控对象的生命周期
- C/C++是否提供有OpenSSL库
- 如何在Native侧释放ArkTS对象

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-1
爬取时间: 2025-05-08 04:30:35
来源: Huawei Developer


问题现象


在Native侧，转换ArkTS侧的字符串到char[]数组时无法准确获取字符串长度，频繁使用NAPI_AUTO_LENGTH宏定义会增加内存开销，影响性能。


解决措施


可以使用napi_get_value_string_utf8的第五个参数来获取ArkTS层传入字符串的长度。这个参数是一个指向size_t类型的变量，它会在函数调用成功后被赋值为字符串的长度，可以根据这个长度来分配合适大小的char数组。具体操作为：先调用napi_get_value_string_utf8函数来获取字符串的长度，然后根据长度分配char数组的内存空间。最后，再次调用napi_get_value_string_utf8函数来获取字符串的内容。注意，在分配内存时，可以将长度+1，以便为字符串添加终止符'\0'。


参考代码如下：


```less
static napi_value TestFunc(napi_env env, napi_callback_info info) 
{ 
    size_t argc = 1; 
    napi_value args[1] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args , nullptr, nullptr); 
     
    size_t len = 0; 
    napi_get_value_string_utf8(env, args[0], nullptr, 0, &len);    // 获取字符串长度到len 
    char* buf = new char[len+1];                                   // 分配合适大小的char数组 
    napi_get_value_string_utf8(env, args[0], buf, len + 1, &len);  // 获取字符串 
    // ... 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-2
爬取时间: 2025-05-08 04:30:44
来源: Huawei Developer


问题现象


获取ArkTS侧传入的字符串到char[]数组时，字符串未完整获取，只获取到一部分。


可能原因


原因一：char数组长度不足。


原因二：使用接口napi_get_value_string_utf8()获取字符串时，第四个参数数值太小，没超过传入的字符串长度。


解决措施


假设info中存储的ArkTS侧参数为“abcdefghigk”。


原因一：char数组长度不足。


```less
static napi_value TestFunc(napi_env env, napi_callback_info info) 
{ 
    size_t argc = 1; 
    napi_value args[1] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args , nullptr, nullptr); 
     
    size_t len = 0; 
    char buf[5];                                                            // 分配长度为5的char数组 
    napi_get_value_string_utf8(env, args[0], buf, 1024, &len);  // 获取字符串，buf结果为"abcde" 
    // ... 
}
```


设置char数组长度为5，字符串被截断：buf为"abcde"。


原因二：使用接口napi_get_value_string_utf8()获取字符串时，第四个参数数值太小，没超过传入的字符串长度。


```less
static napi_value TestFunc(napi_env env, napi_callback_info info) 
{ 
    size_t argc = 1; 
    napi_value args[1] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args , nullptr, nullptr); 
     
    size_t len = 0; 
    char buf[1024];                                                 
    napi_get_value_string_utf8(env, args[0], buf, 5, &len);                    // 获取字符串，buf最终结果为"abcd" 
    // ... 
}
```


设置第四个参数值为5，字符串被截断：buf为"abcd"，终止符'\0'占一位。


保证char数组长度大于等于字符串本身长度，并且接口napi_get_value_string_utf8()获取字符串时，第四个参数数值够用。先调用napi_get_value_string_utf8函数来获取字符串的长度，然后根据长度动态分配char数组的内存空间。注意，我们在分配内存时，可以将长度+1，以便为字符串添加终止符'\0'。


参考代码如下：


```less
napi_value Test::TestFunc(napi_env env, napi_callback_info info) { 
    size_t argc = 1; 
    napi_value args[1] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
 
    size_t len = 0; 
    napi_get_value_string_utf8(env, args[0], nullptr, 0, &len);   // 获取字符串长度到len 
    char *buf = new char[len + 1];                                // 分配合适大小的char数组 
    napi_get_value_string_utf8(env, args[0], buf, len + 1, &len); // 获取字符串 
    OH_LOG_ERROR(LOG_APP, "result is:  b:%{public}s.", buf); 
    return nullptr; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-3
爬取时间: 2025-05-08 04:30:54
来源: Huawei Developer


问题现象


DevEco Studio创建的默认C++工程中是只有一个hello.cpp，想在C++侧加一个 a.cpp文件，并且希望可以从a.cpp文件中导出一个函数给ArkTS侧调用，具体如何实现？


解决措施


首先需要引入对应的a.cpp对应的头文件a.h，然后在初始化函数Init中进行接口映射，最后通过index.d.ts文件将接口导出。参考代码如下：


在NumberType.cpp文件中实现Add函数业务功能。


```less
// NumberType.cpp 
#include "NumberType.h"    // 引入头文件 
// NumberType是类名，Add是它的函数 
napi_value NumberType::Add(napi_env env, napi_callback_info info) { 
    // ... 业务功能实现代码 
}
```


在hello.cpp文件中引入头文件并初始化函数Init中进行接口映射。


```less
#include "NumberType.h" 
#include "napi/native_api.h" 
// ... 
EXTERN_C_START 
static napi_value Init(napi_env env, napi_value exports) { 
    /* Associate the externally provided interface with the written method, for example, associate add with the Add 
     * method. 
    */ 
    napi_property_descriptor desc[] = { 
        {"add", nullptr, NumberType::Add, nullptr, nullptr, nullptr, napi_default, nullptr}}; 
    // napi_define_properties construct a return value that contains a list of methods that correspond. 
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc); 
    return exports; 
} 
EXTERN_C_END 
// ...
```


在接口声明文件（index.d.ts）中对要传递给ArkTS侧的函数进行导出。


```typescript
// index.d.ts  
export const add: (a: number, b: number) => number;
```


参考链接


系统服务-Native XComponent组件的使用（ArkTS）


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-4
爬取时间: 2025-05-08 04:31:03
来源: Huawei Developer


解决措施


1.ArkTS可通过动态import的方式动态加载so库。


2.Native侧可通过dlopen动态加载so库。


参考代码如下：


1.ArkTS可通过动态import的方式动态加载so库。添加异步函数，在异步函数中通过let testNapi = await import（"libentry.so"）实现动态加载so库。


```typescript
import { hilog } from '@kit.PerformanceAnalysisKit'; 
// import testNapi from 'libentry.so'; 
 
@Entry 
@Component 
struct LoadSoLibrary { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(async() => { 
            let testNapi = await import("libentry.so")            // 加载so库 
            hilog.info(0x0000, 'testTag', 'Test NAPI 2 + 3 = %{public}d', testNapi.default.add(2, 3));   // 通过default调用库函数 
            // hilog.info(0x0000, 'testTag', 'Test NAPI 2 + 3 = %{public}d', testNapi.add(2, 3)); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


2.Native侧可通过dlopen动态加载so库。


假设这里我们需要调用liba.so中的add函数。

- 

```typescript
import { hilog } from '@kit.PerformanceAnalysisKit'; 
import testNapi from 'libentry.so'; 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            let path = getContext(this).bundleCodeDir;     // 获取项目路径 
            hilog.info(0x0000, 'testTag', 'Test NAPI 2 + 3 = %{public}d', testNapi.addByLibPath(2, 3, path + '/libs/arm64/liba.so'));   // 传递参数路径信息到Native侧 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


```less
#include "napi/native_api.h" 
#include <dlfcn.h> 
typedef double (*FUNC_ADD)(int, int); 
static napi_value Add(napi_env env, napi_callback_info info) { 
    size_t requireArgc = 3; 
    size_t argc = 3; 
    napi_value args[3] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    double value0; 
    napi_get_value_double(env, args[0], &value0); 
    double value1; 
    napi_get_value_double(env, args[1], &value1); 
    char path[255]; 
    size_t size = 255; 
    napi_get_value_string_utf8(env, args[2], path, 255, &size); // 获取动态库路径信息 
    void *handle = dlopen(path, RTLD_LAZY);                     // 打开一个动态链接库.路径为path 
    dlerror(); 
    FUNC_ADD add_func = (FUNC_ADD)dlsym(handle, "add"); // 获取函数名为add的函数 
    if (dlerror()) { 
        return nullptr; 
    } 
    double res = add_func(value0, value1);              // 调用add并传递参数信息 
    dlclose(handle);                                    // 最后记得close动态库 
    napi_value sum; 
    napi_create_double(env, res, &sum); 
    return sum; 
} 
// ...
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160828.74541534436906628659318927096160:50001231000000:2800:126D8F440760B0FB589337548A9E6491D9C633A44A016D2490227750DC745FFD.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-5
爬取时间: 2025-05-08 04:31:13
来源: Huawei Developer


按实际开发过程可分为两个部分：

1.  关于如何编译so库可以参考以下链接： 使用命令行CMake构建NDK工程
- 方式一：Native侧直接集成
- 方式二：Native侧通过dlopen方式集成

参考代码如下：


```less
// sub.h 
extern "C" {
double sub(double a, double b); 
}
// sub.cpp 
#include <iostream> 
#include "sub.h" 
double sub(double a, double b) 
{ 
    return a - b; 
} 
// CMakeLists.txt 
cmake_minimum_required(VERSION 3.4.1) 
project(libSub) 
#编译源码 
add_library(nativeSub SHARED sub.cpp)
```

1.  将上步生成的so库置于entry/libs对应架构的目录下，并将其对应的头文件放置到cpp目录下。修改CMakeLists.txt，将so库加入到工程中编译引用。然后在native侧引入头文件使用。 将上步生成的so库置于entry/libs目录下，通过ArkTS侧传递沙箱路径到native侧，然后直接在native侧使用dlopen方式调用。注意：该方式引用的so库源码在编译时必须使用extern "C" {}包裹起来，即函数必须是使用C编译模式编译的。

```less
# CMakeLists.txt 
cmake_minimum_required(VERSION 3.4.1) 
project(hello) 
set(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR}) 
include_directories(${NATIVERENDER_ROOT_PATH} 
                    ${NATIVERENDER_ROOT_PATH}/include) 
add_library(library SHARED hello.cpp) 
target_link_libraries(library PUBLIC libace_napi.z.so  libhilog_ndk.z.so) 
target_link_libraries(library PUBLIC ${NATIVERENDER_ROOT_PATH}/../../../libs/arm64-v8a/libnativeSub.so)
```

2.  将上步生成的so库置于entry/libs对应架构的目录下，并将其对应的头文件放置到cpp目录下。修改CMakeLists.txt，将so库加入到工程中编译引用。然后在native侧引入头文件使用。

```less
# CMakeLists.txt 
cmake_minimum_required(VERSION 3.4.1) 
project(hello) 
set(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR}) 
include_directories(${NATIVERENDER_ROOT_PATH} 
                    ${NATIVERENDER_ROOT_PATH}/include) 
add_library(library SHARED hello.cpp) 
target_link_libraries(library PUBLIC libace_napi.z.so  libhilog_ndk.z.so) 
target_link_libraries(library PUBLIC ${NATIVERENDER_ROOT_PATH}/../../../libs/arm64-v8a/libnativeSub.so)
```

3.  将上步生成的so库置于entry/libs目录下，通过ArkTS侧传递沙箱路径到native侧，然后直接在native侧使用dlopen方式调用。注意：该方式引用的so库源码在编译时必须使用extern "C" {}包裹起来，即函数必须是使用C编译模式编译的。

```typescript
import { hilog } from '@kit.PerformanceAnalysisKit'; 
import testNapi from 'libentry.so'; 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            let path = getContext(this).bundleCodeDir; // 获取项目路径 
            hilog.info(0x0000, 'testTag', 'Test NAPI 2 + 3 = %{public}d', testNapi.subSobyDlOpenSo(2, 3, path + '/libs/arm64/libnativeSub.so')); // 传递参数路径信息到Native侧 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```

-  将上步生成的so库置于entry/libs对应架构的目录下，并将其对应的头文件放置到cpp目录下。修改CMakeLists.txt，将so库加入到工程中编译引用。然后在native侧引入头文件使用。

```less
# CMakeLists.txt 
cmake_minimum_required(VERSION 3.4.1) 
project(hello) 
set(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR}) 
include_directories(${NATIVERENDER_ROOT_PATH} 
                    ${NATIVERENDER_ROOT_PATH}/include) 
add_library(library SHARED hello.cpp) 
target_link_libraries(library PUBLIC libace_napi.z.so  libhilog_ndk.z.so) 
target_link_libraries(library PUBLIC ${NATIVERENDER_ROOT_PATH}/../../../libs/arm64-v8a/libnativeSub.so)
```

-  将上步生成的so库置于entry/libs目录下，通过ArkTS侧传递沙箱路径到native侧，然后直接在native侧使用dlopen方式调用。注意：该方式引用的so库源码在编译时必须使用extern "C" {}包裹起来，即函数必须是使用C编译模式编译的。

```typescript
import { hilog } from '@kit.PerformanceAnalysisKit'; 
import testNapi from 'libentry.so'; 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            let path = getContext(this).bundleCodeDir; // 获取项目路径 
            hilog.info(0x0000, 'testTag', 'Test NAPI 2 + 3 = %{public}d', testNapi.subSobyDlOpenSo(2, 3, path + '/libs/arm64/libnativeSub.so')); // 传递参数路径信息到Native侧 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-6
爬取时间: 2025-05-08 04:31:23
来源: Huawei Developer


当前没有专门的接口进行map在ArkTS侧与Native侧的转换，想要实现map（二维数组）数据交互，可以将map中的数据读取出来，传递到Native侧进行map重组。


参考代码如下：


ArkTS侧声明hashmap，并获取数据并传递到Native侧。


```less
let hashmap: HashMap<string, number> = new HashMap()
hashmap.set("Abc", 123)
hashmap.set("Bcd", 234)
hashmap.set("Cde", 345)
for (let key of hashmap.keys()) {
  testNapi.mapDemo(key, hashmap.get(key))
  console.info(`key is ${key}, value is ${hashmap.get(key)}`)
}
```


Native侧获取数据并重组map


```less
#define LOG_DOMAIN 0x3200 // 全局domain宏，标识业务领域
#define LOG_TAG "MY_TAG"  // 全局tag宏，标识模块日志tag
#include "NativeMap.h"
#include "hilog/log.h"
#include <map>
#include <string>
std::map<std::string, int> testmap;
napi_value NativeMap::MapDemo(napi_env env, napi_callback_info info) {
    size_t requireArgc = 2;
    size_t argc = 2;
    napi_value args[2] = {nullptr};


    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    char str1[1024];
    size_t str1_len;
    napi_get_value_string_utf8(env, args[0], str1, 100, &str1_len);
    int num;
    napi_get_value_int32(env, args[1], &num);
    testmap.insert(std::make_pair(str1, num));
    for(auto e: testmap){
        OH_LOG_ERROR(LOG_APP, "key is: %{public}s, value is  %{public}d", (e.first).c_str(), e.second);
    }
    
    return nullptr;
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-7
爬取时间: 2025-05-08 04:31:33
来源: Huawei Developer


可以通过napi_define_class建立ArkTS类与C++侧的映射关系，然后将对应的对象挂载到export上导出。然后在index.d.ts文件中定义对应的ArkTS侧类接口，实现对class的调用。


参考代码如下：


C++侧定义类。


```less
// MyDemo.h 定义C++ 类 
class MyDemo { 
  public: 
    MyDemo(std::string m_name); 
    MyDemo(); 
    ~MyDemo();   
    std::string name; 
    int add(int a, int b); 
    int sub(int a, int b); 
};
```


hello.cpp中完成ArkTS类与C++侧的映射关系，并将其挂载到export上。


```less
// ArkTS对象构造函数 
static napi_value JsConstructor(napi_env env, napi_callback_info info) { 
    // 创建napi对象 
    napi_value jDemo = nullptr; 
    size_t argc = 0; 
    napi_value args[1] = {0}; 
    // 获取构造函数入参 
    napi_get_cb_info(env, info, &argc, args, &jDemo, nullptr); 
    // args[0] js传入的参数 
    char name[50]; 
    size_t result = 0; 
    napi_get_value_string_utf8(env, args[0], name, sizeof(name) + 1, &result); 
    // 创建C++对象 
    MyDemo *cDemo = new MyDemo(name); 
    OH_LOG_INFO(LOG_APP, "%{public}s", (cDemo->name).c_str()); 
    // 设置js对象name属性 
    napi_set_named_property(env, jDemo, "name", args[0]); 
    // 绑定JS对象与C++对象 
    napi_wrap( 
        env, jDemo, cDemo, 
        // 定义js对象回收时回调函数，用来销毁C++对象，防止内存泄漏 
        [](napi_env env, void *finalize_data, void *finalize_hint) { 
            MyDemo *cDemo = (MyDemo *)finalize_data; 
            delete cDemo; 
            cDemo = nullptr; 
        }, 
        nullptr, nullptr); 
    return jDemo; 
} 
// ArkTS对象add函数 
static napi_value JsAdd(napi_env env, napi_callback_info info) { 
    size_t argc = 2; 
    napi_value args[2] = {nullptr}; 
    napi_value jDemo = nullptr; 
    napi_get_cb_info(env, info, &argc, args, &jDemo, nullptr); 
    MyDemo *cDemo = nullptr; 
    // 将ArkTS对象转为c对象 
    napi_unwrap(env, jDemo, (void **)&cDemo); 
    // 获取ArkTS传递的参数 
    int value0; 
    napi_get_value_int32(env, args[0], &value0); 
    int value1; 
    napi_get_value_int32(env, args[1], &value1); 
    int cResult = cDemo->add(value0, value1); 
    napi_value jResult; 
    napi_create_int32(env, cResult, &jResult); 
    return jResult; 
} 
// ArkTS对象sub函数 
static napi_value JsSub(napi_env env, napi_callback_info info) { 
    size_t argc = 2; 
    napi_value args[2] = {nullptr}; 
    napi_value jDemo = nullptr; 
    napi_get_cb_info(env, info, &argc, args, &jDemo, nullptr); 
    MyDemo *cDemo = nullptr; 
    // 将ArkTS对象转为c对象 
    napi_unwrap(env, jDemo, (void **)&cDemo); 
    // 获取ArkTS传递的参数 
    int value0; 
    napi_get_value_int32(env, args[0], &value0); 
    int value1; 
    napi_get_value_int32(env, args[1], &value1); 
    int cResult = cDemo->sub(value0, value1); 
    napi_value jResult; 
    napi_create_int32(env, cResult, &jResult); 
    return jResult; 
} 
static napi_value Add(napi_env env, napi_callback_info info) { 
    size_t requireArgc = 2; 
    size_t argc = 2; 
    napi_value args[2] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    napi_valuetype valuetype0; 
    napi_typeof(env, args[0], &valuetype0); 
    napi_valuetype valuetype1; 
    napi_typeof(env, args[1], &valuetype1); 
    int value0; 
    napi_get_value_int32(env, args[0], &value0); 
    int value1; 
    napi_get_value_int32(env, args[1], &value1); 
    MyDemo *demo = new MyDemo(); 
    // 调用so中函数进行运算 
    int result = demo->add(value0, value1); 
    napi_value sum; 
    napi_create_int32(env, result, &sum); 
    delete demo; 
    return sum; 
} 
static napi_value Sub(napi_env env, napi_callback_info info) { 
    size_t argc = 2; 
    napi_value args[2] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    napi_valuetype valuetype0; 
    napi_typeof(env, args[0], &valuetype0); 
    napi_valuetype valuetype1; 
    napi_typeof(env, args[1], &valuetype1); 
    int value0; 
    napi_get_value_int32(env, args[0], &value0); 
    int value1; 
    napi_get_value_int32(env, args[1], &value1); 
    MyDemo *demo = new MyDemo(); 
    // 调用so中函数进行运算 
    int result = demo->sub(value0, value1); 
    napi_value num; 
    napi_create_int32(env, result, &num); 
    delete demo; 
    return num; 
} 
 
static napi_value Init(napi_env env, napi_value exports) { 
    // 定义模块需要对外暴露的方法 
    napi_property_descriptor desc[] = {{"add", nullptr, Add, nullptr, nullptr, nullptr, napi_default, nullptr}, 
                                       {"sub", nullptr, Sub, nullptr, nullptr, nullptr, napi_default, nullptr}}; 
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc); 
    // 通过napi_define_class建立ArkTS类与C++侧的映射关系，然后将对应的对象挂载到export上 
    napi_property_descriptor classProp[] = {{"add", nullptr, JsAdd, nullptr, nullptr, nullptr, napi_default, nullptr}, 
                                            {"sub", nullptr, JsSub, nullptr, nullptr, nullptr, napi_default, nullptr}}; 
    napi_value jDemo = nullptr; 
    const char *jDemoName = "MyDemo"; 
    // 建立ArkTS构造函数与C++方法的关联,指定2个prop 
    napi_define_class(env, jDemoName, sizeof(jDemoName), JsConstructor, nullptr, 
                      sizeof(classProp) / sizeof(classProp[0]), classProp, &jDemo); 
    napi_set_named_property(env, exports, jDemoName, jDemo); 
    return exports; 
}
```


index.d.ts文件中定义ArkTS类。


```less
declare namespace testNapi { 
  const add: (a: number, b: number) => number; 
  const sub: (a: number, b: number) => number; 
  // 定义ArkTS接口 
  class MyDemo { 
    constructor(name:string) 
    name: string 
    add(a: number, b: number): number 
    sub(a: number, b: number): number 
  } 
} 
export default testNapi;
```


ArkTS侧实现调用。


```less
import testNapi from 'libentry.so'; 
// ... 
    new testNapi.MyDemo('abc'); 
    hilog.info(0x0000, 'testTag', 'Test NAPI 2 + 3 = %{public}d', testNapi.add(2, 3)); 
    hilog.info(0x0000, 'testTag', 'Test NAPI 2 - 3 = %{public}d', testNapi.sub(2, 3)); 
// ... 
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-9
爬取时间: 2025-05-08 04:31:43
来源: Huawei Developer


问题详情


如何修改C++语言版本，现在支持哪些C++标准。


解决措施

-  从HarmonyOS 3.0开始，libc++使用clang/llvm 10.0.1版本。 从HarmonyOS 3.2开始，libc++升级到clang/llvm 12.0.1版本。 从HarmonyOS NEXT Developer Preview0开始，libc++升级到clang/llvm 15.0.4版本。
-  C++11、C++14标准已完全支持，C++17和C++20标准正在完善。
-  SDK默认C++版本是14，如若修改，参考以下两种方式：

```less
set(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR}) 
# 添加下面这行 
set(CMAKE_CXX_STANDARD 17)
```


```less
set(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR}) 
# 添加下面这行 
set(CMAKE_CXX_STANDARD 17)
```


```less
"buildOption": { 
  "externalNativeOptions": { 
    "path": "./src/main/cpp/CMakeLists.txt", 
    "arguments": "", 
    // 修改下面这一行 
    "cppFlags": "--std=c++17", 
  } 
}
```


```less
set(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR}) 
# 添加下面这行 
set(CMAKE_CXX_STANDARD 17)
```


```less
"buildOption": { 
  "externalNativeOptions": { 
    "path": "./src/main/cpp/CMakeLists.txt", 
    "arguments": "", 
    // 修改下面这一行 
    "cppFlags": "--std=c++17", 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-10
爬取时间: 2025-05-08 04:31:53
来源: Huawei Developer


问题详情


如何在native层获取屏幕亮度，请提供代码示例。


解决措施


Native侧可通过napi_load_module接口访问到获取屏幕亮度的模块，然后调用它的get_value函数获取屏幕亮度。


代码示例如下：


```typescript
// Screenbrightness/src/main/ets/pages/Index.ets
import testNapi from 'libscreenbrightness.so';


@Entry
@Component
struct Index {
  @State message: string = 'Get Screen Brightness';


  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .onClick(() => {
            testNapi.napiLoadModule("@system.brightness");
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


```less
// Screenbrightness/src/main/cpp/napi_init.cpp
#include "hilog/log.h"
#include "napi/native_api.h"
#include <string>


#define LOG_TAG "Pure"


static napi_value Success(napi_env env, napi_callback_info info) {
    size_t argc = 1;
    napi_value args[1] = {nullptr};
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    napi_value obj = args[0];
    napi_value key;
    napi_value rv;
    std::string x = "value";
    napi_create_string_utf8(env, x.c_str(), 5, &key);
    napi_get_property(env, obj, key, &rv);
    uint32_t result;
    napi_get_value_uint32(env, rv, &result);
    OH_LOG_INFO(LOG_APP, "napi get brightness %{public}d", result);
    return nullptr;
};
static napi_value Fail(napi_env env, napi_callback_info info) { return nullptr; };
static napi_value Complete(napi_env env, napi_callback_info info) { return nullptr; };
static napi_value NapiLoadModule(napi_env env, napi_callback_info info) {
    napi_value result;
    size_t argc = 1;
    napi_value args[1] = {nullptr};
    napi_status get = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    char path[64] = {0};
    size_t typeLen = 0;
    napi_get_value_string_utf8(env, args[0], path, sizeof(path), &typeLen);
    napi_status status = napi_load_module(env, path, &result);
    if (status != napi_ok) {
        OH_LOG_ERROR(LOG_APP, "napi_load_module failed");
        return nullptr;
    }
    napi_value outputObject;
    napi_get_named_property(env, result, "getValue", &outputObject);
    napi_value arg;
    napi_create_object(env, &arg);
    napi_property_descriptor desc[] = {
        {"success", nullptr, Success, nullptr, nullptr, nullptr, napi_default, nullptr},
        {"fail", nullptr, Fail, nullptr, nullptr, nullptr, napi_default, nullptr},
        {"complete", nullptr, Complete, nullptr, nullptr, nullptr, napi_default, nullptr}};
    napi_define_properties(env, arg, sizeof(desc) / sizeof(desc[0]), desc);
    napi_call_function(env, result, outputObject, 1, &arg, nullptr);
    return result;
};
EXTERN_C_START
static napi_value Init(napi_env env, napi_value exports) {
    napi_property_descriptor desc[] = {
        {"napiLoadModule", nullptr, NapiLoadModule, nullptr, nullptr, nullptr, napi_default, nullptr},
    };
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
    return exports;
}
EXTERN_C_END


static napi_module demoModule = {
    .nm_version = 1,
    .nm_flags = 0,
    .nm_filename = nullptr,
    .nm_register_func = Init,
    .nm_modname = "screenbrightness",
    .nm_priv = ((void *)0),
    .reserved = {0},
};
extern "C" __attribute__((constructor)) void RegisterScreenBrightnessModule(void) { napi_module_register(&demoModule); }
```


```typescript
// Screenbrightness/src/main/cpp/types/libscreenbrightness/Index.d.ts
export const napiLoadModule: (a: string) => object;
```


```less
# Screenbrightness/src/main/cpp/CMakeLists.txt
target_link_libraries(screenbrightness PUBLIC libace_napi.z.so libhilog_ndk.z.so)
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-11
爬取时间: 2025-05-08 04:32:03
来源: Huawei Developer


问题详情


应用目录下面，哪些目录用户可以往里面写临时文件。还请提供native层写文件代码示例。


解决措施


目前并无相关Native接口可以直接写文件，可以通过C++基础库结合沙箱路径实现写文件操作。


代码如下：


```less
#include "WriteFile.h" 
#include "napi/native_api.h" 
#include <fstream> 
napi_value WriteFile::WriteTemporaryFile(napi_env env, napi_callback_info info) { 
    std::ofstream file("data/storage/el2/base/temp/2.txt"); 
    if (file.is_open()) {        // 判断能否正常打开文件 
        file << "Hello, World!"; // 向文件写入内容 
        file.close();            // 关闭文件 
    } 
    return nullptr; 
} 


```


用户可访问的目录可参考以下链接：应用沙箱目录


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-12
爬取时间: 2025-05-08 04:32:12
来源: Huawei Developer


问题详情


尝试过在需要编译的库的build-profile.json5文件中，buildOptionSet字段中添加 { "name": "debug", "externalNativeOptions": { "arguments": "-DDEBUG=1" } } 或在buildOption.externalNativeOptions.arguments字段中设置"-DDEBUG=1"， 在使用debug模式运行时均不会执行#ifdef DEBUG中的语句。


解决措施


1.CMakeLists.txt文件中增加如下语句：


```less
if(CMAKE_BUILD_TYPE STREQUAL Debug) 
    add_definitions(-D_DEBUG) 
endif()
```


2.C++文件中增加如下代码运用：


```less
#include "napi/native_api.h" 
#include "hilog/log.h" 
#define LOG_TAG "Pure" 
 
static napi_value DefDebug(napi_env env, napi_callback_info info) { 
#ifdef _DEBUG 
    OH_LOG_INFO(LOG_APP, "debug enter Project"); 
#else 
    OH_LOG_INFO(LOG_APP, "release enter Project"); 
#endif 
    return nullptr; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-13
爬取时间: 2025-05-08 04:32:22
来源: Huawei Developer


问题详情


ArkTS层创建的ArrayBuffer和Uint8Array对象在Native层无法正确区分。


解决措施


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-15
爬取时间: 2025-05-08 04:32:31
来源: Huawei Developer


问题详情


现有一个C++库，提供的接口以类方法形式提供。Native侧是否只能封装成普通函数的形式供上层调用，无法以原有类方法的形式封装？


解决措施


Native侧可通过如下方法以类方法的形式供上层调用。


具体代码如下：


```less
#include "napi/native_api.h" 
#include <string> 
 
static napi_value Sub(napi_env env, napi_callback_info info) { 
    size_t requireArgc = 2; 
    size_t argc = 2; 
    napi_value args[2] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    napi_valuetype valuetype0; 
    napi_typeof(env, args[0], &valuetype0); 
    napi_valuetype valuetype1; 
    napi_typeof(env, args[1], &valuetype1); 
    double value0; 
    napi_get_value_double(env, args[0], &value0); 
    double value1; 
    napi_get_value_double(env, args[1], &value1); 
    napi_value sub; 
    napi_create_double(env, value0 - value1, &sub); 
    return sub; 
} 
static napi_value Sum(napi_env env, napi_callback_info info) { 
    size_t requireArgc = 2; 
    size_t argc = 2; 
    napi_value args[2] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    napi_valuetype valuetype0; 
    napi_typeof(env, args[0], &valuetype0); 
    napi_valuetype valuetype1; 
    napi_typeof(env, args[1], &valuetype1); 
    double value0; 
    napi_get_value_double(env, args[0], &value0); 
    double value1; 
    napi_get_value_double(env, args[1], &value1); 
    napi_value sum; 
    napi_create_double(env, value0 + value1, &sum); 
    return sum; 
} 
napi_value Constructor(napi_env env, napi_callback_info info) { return nullptr; } 
EXTERN_C_START 
static napi_value Init(napi_env env, napi_value exports) { 
    std::string class_name = "TestEntryA"; 
    napi_property_descriptor desc[] = {{"sub", nullptr, Sub, nullptr, nullptr, nullptr, napi_static, nullptr}, 
                                       {"sum", nullptr, Sum, nullptr, nullptr, nullptr, napi_static, nullptr}}; 
    napi_value defined_class = nullptr; 
    napi_define_class(env, class_name.c_str(), class_name.length(), Constructor, nullptr, 2, desc, &defined_class); 
    const napi_property_descriptor exports_desc[] = { 
        {class_name.c_str(), nullptr, nullptr, nullptr, nullptr, defined_class, napi_default, nullptr}, 
    }; 
    napi_define_properties(env, exports, 2, exports_desc); 
    return exports; 
} 
EXTERN_C_END
```


```less
export declare class TestEntryA { 
  static sub (a: number, b: number) : number; 
  static sum (a: number, b: number) : number; 
}
```


```typescript
import { TestEntryA } from 'libfuncencapsulation.so'; 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Function Encapsulation'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            console.info(`Test NAPI 2 + 3 = ${TestEntryA.sum(2, 3)}`); 
            console.info(`Test NAPI 2 - 3 = ${TestEntryA.sub(2, 3)}`); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-16
爬取时间: 2025-05-08 04:32:41
来源: Huawei Developer


问题详情


Native侧引用的三方库使用printf等方法打印到stdout、stderr的信息怎么获取？在三方库代码里有许多fprintf, std::cont printf 的标准日志打印log，在程序开发中无法查看这些日志。


解决措施


cout/printf是语言提供的打印函数，并不能填充到hilog日志中。可通过重定向的方法将日志打印到文件来获取打印信息。具体方法如下：


Native侧重定向方法主体。


```less
#include "napi/native_api.h" 
#include <hilog/log.h> 
#include <string> 
#include "iostream" 
#include "fstream" 
#define LOG_TAG "Pure" 
 
static napi_value Redirect(napi_env env, napi_callback_info info) { 
    // 获取函数的JS参数 
    size_t argc = 1; 
    napi_value argv[1] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr); 
    // 解析参数1，保存文件的目标目录 
    size_t targetDirectoryNameSize; 
    char targetDirectoryNameBuf[512]; 
    napi_get_value_string_utf8(env, argv[0], targetDirectoryNameBuf, sizeof(targetDirectoryNameBuf), 
                               &targetDirectoryNameSize); 
    std::string targetDirectoryName(targetDirectoryNameBuf, targetDirectoryNameSize); // 目标目录 
    OH_LOG_INFO(LOG_APP, "C++侧收到的目标路径 === %{public}s", targetDirectoryNameBuf); 
    std::string targetSandboxPath = targetDirectoryName + "/Log.log"; // 存入的文件路径 
     
    // 使用freopen函数把文件关联到标准输出 
    FILE *stdoutFile = NULL; 
    FILE *stderrFile = NULL; 
    stdoutFile = freopen(targetSandboxPath.c_str(), "a", stdout); 
    stderrFile = freopen(targetSandboxPath.c_str(), "a", stderr); 
    if (NULL == stdoutFile || NULL == stderrFile) { 
        OH_LOG_INFO(LOG_APP, "重创建！"); 
        // 打开沙箱文件的文件输出流，会创建出一个文件 
        std::ofstream outputFile(targetSandboxPath, std::ios::binary); 
        if (!outputFile) { 
            OH_LOG_ERROR(LOG_APP, "无法创建目标文件!"); 
            return nullptr; 
        } 
        stdoutFile = freopen(targetSandboxPath.c_str(), "a", stdout); 
        stderrFile = freopen(targetSandboxPath.c_str(), "a", stderr); 
        if (NULL == stdoutFile || NULL == stderrFile) { 
            OH_LOG_ERROR(LOG_APP, "失败!"); 
            return nullptr; 
        } 
    } 
    OH_LOG_WARN(LOG_APP, "重定向!"); 
    printf("\n*****************redirect分割线*****************\n"); 
    return 0; 
}
```


ArkTS侧调用并传入路径信息。


在EntryAbility的onCreate()方法中调用重定向。


```less
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void { 
  let file : string = this.context.getApplicationContext().filesDir; 
  testNapi.redirect(file); 
  hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate'); 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-17
爬取时间: 2025-05-08 04:32:50
来源: Huawei Developer


问题详情


ArkTS侧调用native开放的接口时，Native侧如何获取TS侧应用包名？


解决措施


Native可以使用Native Bundle接口获取应用自身相关信息，包括应用包名、appId等。使用时CMakeLists文件中需要添加依赖libbundle_ndk.z.so。


具体代码如下：


```less
#include "CGetAppPackageName.h" 
#include "napi/native_api.h" 
#include <bundle/native_interface_bundle.h> 
#include <cstdlib> 
#include "hilog/log.h" 
#define LOG_TAG "Pure" 
 
napi_value CGetAppPackageName::GetCurrentApplicationPackageName(napi_env env, napi_callback_info info) 
{ 
    // 调用Native接口获取应用信息 
    OH_NativeBundle_ApplicationInfo nativeApplicationInfo = OH_NativeBundle_GetCurrentApplicationInfo(); 
    // Native接口获取的应用包名转为js对象里的bundleName属性 
    napi_value bundleName; 
    napi_create_string_utf8(env, nativeApplicationInfo.bundleName, NAPI_AUTO_LENGTH, &bundleName); 
    OH_LOG_INFO(LOG_APP, "napi 获取应用包名： %{public}s", nativeApplicationInfo.bundleName); 
    // 最后为了防止内存泄漏，手动释放 
    free(nativeApplicationInfo.bundleName); 
    return nullptr; 
}
```


更多相关信息可参考链接：


NativeBundle开发指导


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-18
爬取时间: 2025-05-08 04:33:00
来源: Huawei Developer


问题详情


系统提供了ArkTS 接口，但未提供对应的NDK接口，当伙伴使用C++ 代码实现业务逻辑时，部分系统能力需要依赖系统ArkTS接口。


解决措施


具体方法可参考以下获取设备的屏幕宽高示例代码。


```less
#include "CallSystemModule.h" 
#include "napi/native_api.h" 
#include <hilog/log.h> 
#define LOG_TAG "Pure" 
 
napi_value CallSystemModule::GetDisplaySize(napi_env env, napi_callback_info info) { 
    // 获取arkts侧的系统库路径 
    char path[64] = "@ohos.display"; 
    size_t typeLen = 0; 
    napi_value string; 
    napi_create_string_utf8(env, path, typeLen, &string); 
    // 加载系统库 
    napi_value sysModule; 
    napi_load_module(env, path, &sysModule); 
    // 获取系统库中的"getDefaultDisplaySync"方法 
    napi_value func = nullptr; 
    napi_get_named_property(env, sysModule, "getDefaultDisplaySync", &func); 
    napi_value funcResult; 
    napi_call_function(env, sysModule, func, 0, nullptr, &funcResult); 
    napi_value widthValue = nullptr; 
    napi_get_named_property(env, funcResult, "width", &widthValue); 
    double width; 
    napi_get_value_double(env, widthValue, &width); 
    OH_LOG_INFO(LOG_APP, "width: %{public}f", width); 
    napi_value heightValue = nullptr; 
    napi_get_named_property(env, funcResult, "height", &heightValue); 
    double height; 
    napi_get_value_double(env, heightValue, &height); 
    OH_LOG_INFO(LOG_APP, "height: %{public}f", height); 
    // 业务拿到width 和 height，可以进一步处理具体业务逻辑 
    return nullptr; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-19
爬取时间: 2025-05-08 04:33:09
来源: Huawei Developer


问题详情


系统仅提供了ArkTS 异步接口，未提供对应的NDK接口，当伙伴使用C++ 代码实现业务逻辑时，部分系统能力需要依赖系统ArkTS 异步接口。


解决措施


可以通过创建线程安全函数的方式调用系统的异步接口。


具体方法可参考以下获取设备屏幕宽度示例代码。


Native侧代码实现：


```less
#include "napi/native_api.h" 
#include <future> 
#include <hilog/log.h> 
 
#define LOG_TAG "Pure" // 全局tag宏，标识模块日志tag 
 
// 上下文数据，用于线程间传递数据 
struct CallbackData { 
    napi_threadsafe_function tsfn; 
    napi_async_work work; 
    napi_deferred deferred = nullptr; 
    double res; 
}; 
static napi_value ResolvedCallback(napi_env env, napi_callback_info info) { 
    void *data = nullptr; 
    size_t argc = 1; 
    napi_value argv[1]; 
    napi_get_cb_info(env, info, &argc, argv, nullptr, &data); 
    napi_value widthProp = nullptr; 
    napi_get_named_property(env, argv[0], "width", &widthProp); 
    double result = 0; 
    napi_get_value_double(env, widthProp, &result); 
    OH_LOG_INFO(LOG_APP, "width in ResolvedCallback is %{public}f", result); 
    // data被重新解释为指向std::promise<double>的指针，并设置该promise的值为width 
    reinterpret_cast<std::promise<double> *>(data)->set_value(result); 
    return nullptr; 
} 
static void CallJs(napi_env env, napi_value jsCb, void *context, void *data) { 
    // 导入系统库模块，逐层向下调用到方法 
    napi_value systemModule; 
    napi_load_module(env, "@ohos.display", &systemModule); 
    napi_value displayFunc = nullptr; 
    napi_get_named_property(env, systemModule, "getDefaultDisplay", &displayFunc); 
    napi_value promise = nullptr; 
    napi_call_function(env, systemModule, displayFunc, 0, nullptr, &promise); 
    napi_value thenFunc = nullptr; 
    napi_get_named_property(env, promise, "then", &thenFunc); 
    napi_value resolvedCallback; 
    // promise resolve回调 
    napi_create_function(env, "resolvedCallback", NAPI_AUTO_LENGTH, ResolvedCallback, data, &resolvedCallback); 
    napi_value argv[] = {resolvedCallback}; 
    napi_call_function(env, promise, thenFunc, 1, argv, nullptr); 
} 
static void ExecuteWork(napi_env env, void *data) { 
    CallbackData *callbackData = reinterpret_cast<CallbackData *>(data); 
    std::promise<double> promise; 
    auto future = promise.get_future(); 
    napi_call_threadsafe_function(callbackData->tsfn, &promise, napi_tsfn_nonblocking); 
    try { 
        auto result = future.get(); 
        callbackData->res = result; 
        OH_LOG_INFO(LOG_APP, "width in ExecuteWork %{public}f", result); 
    } catch (const std::exception &e) { 
        OH_LOG_INFO(LOG_APP, "XXX, Result from JS %{public}s", e.what()); 
    } 
} 
static void WorkComplete(napi_env env, napi_status status, void *data) { 
    CallbackData *callbackData = reinterpret_cast<CallbackData *>(data); 
    // 回传业务代码计算结果给应用 
    napi_value result = nullptr; 
    napi_create_double(env, callbackData->res, &result); 
    napi_resolve_deferred(env, callbackData->deferred, result); 
    // 释放线程安全方法 
    napi_release_threadsafe_function(callbackData->tsfn, napi_tsfn_release); 
    // 删除异步工作项 
    napi_delete_async_work(env, callbackData->work); 
    callbackData->tsfn = nullptr; 
    callbackData->work = nullptr; 
} 
static napi_value getDisplayWidthAsync(napi_env env, napi_callback_info info) { 
    size_t argc = 1; 
    napi_value jsCb = nullptr; 
    CallbackData *callbackData = nullptr; 
    napi_get_cb_info(env, info, &argc, &jsCb, nullptr, reinterpret_cast<void **>(&callbackData)); 
     
    napi_value sysModule; 
    napi_load_module(env, "@ohos.display", &sysModule); 
    napi_value getDefaultDisplay; 
    napi_get_named_property(env, sysModule, "getDefaultDisplay", &getDefaultDisplay); 
    // 创建一个线程安全函数 
    napi_value resourceName = nullptr; 
    napi_create_string_utf8(env, "getDisplayWidthAsync", NAPI_AUTO_LENGTH, &resourceName); 
    napi_create_threadsafe_function(env, getDefaultDisplay, nullptr, resourceName, 0, 1, callbackData, nullptr, 
                                    callbackData, CallJs, &callbackData->tsfn); 
    // 创建一个异步任务 
    napi_create_async_work(env, nullptr, resourceName, ExecuteWork, WorkComplete, callbackData, &callbackData->work); 
    // 将异步任务加入到异步队列中,由底层调度执行 
    napi_queue_async_work(env, callbackData->work); 
    // 方法返回promise 
    napi_value result = nullptr; 
    napi_create_promise(env, &callbackData->deferred, &result); 
    return result; 
}
```


Index.d.ts文件声明接口：


```typescript
export const getDisplayWidthAsync: () => Promise<number>;
```


ArkTS侧代码实现：


```typescript
import testNapi from 'libcallsystemasyncwork.so'; 
import { promptAction } from '@kit.ArkUI'; 
 
@Entry 
@Component 
struct Index { 
  build() { 
    Row() { 
      Column() { 
        Text('c++异步调用ts') 
          .fontSize(40) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            testNapi.getDisplayWidthAsync().then((res: number) =>{ 
              console.info(`display width = ${res.toString()}`); 
              promptAction.showToast({ 
                message: "屏幕宽度：" + res.toString() 
              }) 
            }); 
          }) 
          .margin('30') 
      } 
      .width('100%') 
      .justifyContent(FlexAlign.SpaceBetween) 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-20
爬取时间: 2025-05-08 04:33:19
来源: Huawei Developer


问题详情


在ArkTS侧已经定义了接口，未实现对应的NDK接口，当使用C++代码实现业务逻辑时，想直接使用已有的ArkTS接口。


解决措施


可通过napi_load_module接口实现对ArkTS文件中的接口的调用。具体步骤如下：


具体方法可参考以下加载ArkTS文件中的模块使用示例代码。


声明ArkTS侧方法：


```less
// src/main/ets/pages/Test.ets 
let value = 123; 
function test() { 
  console.log('Hello HarmonyOS'); 
} 
export {value, test};
```


在模块级build-profile.json5文件中进行以下配置：


注意是在模块级的build-profile.json5文件中配置，而非工程级。同时需要确保"sources"配置项为正确的Test.ets文件路径。


```less
"buildOption": { 
  "externalNativeOptions": { 
    "path": "./src/main/cpp/CMakeLists.txt", 
    "arguments": "", 
    "cppFlags": "", 
  }, 
  "arkOptions": { 
    "runtimeOnly": { 
      "sources": [ 
        "./src/main/ets/pages/Test.ets" 
      ] 
    } 
  }, 
},
```


使用napi_load_module加载Test文件，调用函数test以及获取变量value。


```less
#include "napi/native_api.h" 
#include <string> 
 
static napi_value LoadModule(napi_env env, napi_callback_info info) { 
    napi_value result; 
    // 1. 使用napi_load_module加载Test文件中的模块 
    napi_status status = napi_load_module(env, "ets/pages/Test", &result); 
    napi_value testFn; 
    // 2. 使用napi_get_named_property获取test函数 
    napi_get_named_property(env, result, "test", &testFn); 
    // 3. 使用napi_call_function调用函数test 
    napi_call_function(env, result, testFn, 0, nullptr, nullptr); 
    napi_value value; 
    napi_value key; 
    std::string keyStr = "value"; 
    napi_create_string_utf8(env, keyStr.c_str(), keyStr.size(), &key); 
    // 4. 使用napi_get_property获取变量value 
    napi_get_property(env, result, key, &value); 
    return value; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-21
爬取时间: 2025-05-08 04:33:28
来源: Huawei Developer


解决措施


ArkTS侧引用三方库so必须具备xxx.so、Index.d.ts、oh-package.json5三个文件，Index.d.ts和oh-package.json5在C++模板中自带，也可以手动创建。在需要调用的模块根目录下的oh-package.json5中声明这个so库根目录路径。然后在代码中使用import引用oh-package.json5中声明的依赖名称。但是该方案只能引用已经适配了Native的so库，因此在编译生成so库时需要实现功能函数并注册其Native侧接口，提供对应的Native侧接口声明文件Index.d.ts和配置文件oh-package.json5。

1. 
2. 

```less
"dependencies": { 
  "libimportthirdpartylibraries.so": "file:./src/main/cpp/types/libimportthirdpartylibraries", 
  "libapplication.so": "file:./src/main/cpp/types/libapplication" 
}
```


```typescript
import testNapi from 'libimportthirdpartylibraries.so'; 
import myNapi from 'libapplication.so'; 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            console.info(`MyTest NAPI 2 + 3 = ${myNapi.add(2, 3)}`); 
            console.info(`MyTest NAPI 2 - 3 = ${testNapi.sub(2, 3)}`); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160828.25816022395803200497467958309290:50001231000000:2800:B3175506BD633BD37417E3B3420E226494AE7F56DB6EAA525B88E4175F223E3A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160828.47455429121756743315456200492944:50001231000000:2800:87D8E8FFF35CF9238CBB6B6A6484A14B51C3B838FFD7D89BAB169B431AED0365.png)

运行结果：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160828.34025201101271095535052985105420:50001231000000:2800:B21461AA877E1E64A9BD86E299EEF891DF532071C17C05832A1B70488B8B2A81.png)

参考链接


ArkTS侧引用三方库


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-22
爬取时间: 2025-05-08 04:33:38
来源: Huawei Developer


解决措施


可以使用Native Rawfile接口操作Rawfile目录和文件来访问应用包内资源。


具体使用方式可参考以下代码：

1.  target_link_libraries(nativeaccessres PUBLIC libace_napi.z.so libhilog_ndk.z.so librawfile.z.so)

```typescript
import { resourceManager } from "@kit.LocalizationKit"; 
export const getRawFileContent: (resMgr: resourceManager.ResourceManager, path: string) => Uint8Array;
```


```less
#include "napi/native_api.h" 
#include <rawfile/raw_file.h> 
#include <rawfile/raw_file_manager.h> 
#include "hilog/log.h" 
 
const int GLOBAL_RESMGR = 0xFF00; 
const char *TAG = "[Sample_rawfile]"; 
namespace { 
    napi_value CreateJsArrayValue(napi_env env, std::unique_ptr<uint8_t[]> &data, long length) 
    { 
        napi_value buffer; 
        napi_status status = napi_create_external_arraybuffer( 
            env, data.get(), length, 
            [](napi_env env, void *data, void *hint) { 
                delete[] static_cast<char *>(data); 
            }, 
            nullptr, &buffer); 
        if (status != napi_ok) { 
            OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, TAG, "Failed to create external array buffer"); 
            return nullptr; 
        } 
        napi_value result = nullptr; 
        status = napi_create_typedarray(env, napi_uint8_array, length, buffer, 0, &result); 
        if (status != napi_ok) { 
            OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, TAG, "Failed to create media typed array"); 
            return nullptr; 
        } 
        data.release(); 
        return result; 
    } 
} 
static napi_value GetRawFileContent(napi_env env, napi_callback_info info) 
{ 
    OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, TAG, "GetFileContent Begin"); 
    size_t requireArgc = 3; 
    size_t argc = 2; 
    napi_value argv[2] = { nullptr }; 
    // 获取参数信息 
    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr); 
    // argv[0]即为函数第一个参数Js资源对象，OH_ResourceManager_InitNativeResourceManager转为Native对象。 
    NativeResourceManager *mNativeResMgr = OH_ResourceManager_InitNativeResourceManager(env, argv[0]); 
    size_t strSize; 
    char strBuf[256]; 
    napi_get_value_string_utf8(env, argv[1], strBuf, sizeof(strBuf), &strSize); 
    std::string filename(strBuf, strSize); 
    // 获取rawfile指针对象 
    RawFile *rawFile = OH_ResourceManager_OpenRawFile(mNativeResMgr, filename.c_str()); 
    if (rawFile != nullptr) { 
        OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, TAG, "OH_ResourceManager_OpenRawFile success"); 
    } 
    // 获取rawfile大小并申请内存 
    long len = OH_ResourceManager_GetRawFileSize(rawFile); 
    std::unique_ptr<uint8_t[]> data= std::make_unique<uint8_t[]>(len); 
    // 一次性读取rawfile全部内容 
    int res = OH_ResourceManager_ReadRawFile(rawFile, data.get(), len); 
    // 关闭打开的指针对象 
    OH_ResourceManager_CloseRawFile(rawFile); 
    OH_ResourceManager_ReleaseNativeResourceManager(mNativeResMgr); 
    // 转为js对象 
    return CreateJsArrayValue(env, data, len); 
}
```


```typescript
import testNapi from 'libnativeaccessres.so'  // 导入so 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Native Access Resource'; 
  private resMgr = getContext().resourceManager;  // 获取本应用包的资源对象 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            let rawfileContext = testNapi.getRawFileContent(this.resMgr, 'rawfile.txt'); 
            console.log("rawfileContext" + rawfileContext); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


Rawfile开发指导


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-23
爬取时间: 2025-05-08 04:33:47
来源: Huawei Developer


解决措施


可以通过createModuleContext(moduleName)接口创建同应用中不同module的上下文，获取到resourceManager对象后，在Native侧使用Native Rawfile接口操作Rawfile目录和文件来跨模块访问资源。


具体使用方式可参考以下代码：

1.  target_link_libraries(nativecrossmoduleaccessres PUBLIC libace_napi.z.so libace_napi.z.so libhilog_ndk.z.so librawfile.z.so)

```typescript
import { resourceManager } from "@kit.LocalizationKit"; 
export const getRawFileContent: (resMgr: resourceManager.ResourceManager, path: string) => Uint8Array;
```


```less
#include "napi/native_api.h" 
#include <rawfile/raw_file.h> 
#include <rawfile/raw_file_manager.h> 
#include "hilog/log.h" 
 
const int GLOBAL_RESMGR = 0xFF00; 
const char *TAG = "[Sample_rawfile]"; 
namespace { 
    napi_value CreateJsArrayValue(napi_env env, std::unique_ptr<uint8_t[]> &data, long length) 
    { 
        napi_value buffer; 
        napi_status status = napi_create_external_arraybuffer( 
            env, data.get(), length, 
            [](napi_env env, void *data, void *hint) { 
                delete[] static_cast<char *>(data); 
            }, 
            nullptr, &buffer); 
        if (status != napi_ok) { 
            OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, TAG, "Failed to create external array buffer"); 
            return nullptr; 
        } 
        napi_value result = nullptr; 
        status = napi_create_typedarray(env, napi_uint8_array, length, buffer, 0, &result); 
        if (status != napi_ok) { 
            OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, TAG, "Failed to create media typed array"); 
            return nullptr; 
        } 
        data.release(); 
        return result; 
    } 
} 
static napi_value GetRawFileContent(napi_env env, napi_callback_info info) 
{ 
    OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, TAG, "GetFileContent Begin"); 
    size_t requireArgc = 3; 
    size_t argc = 2; 
    napi_value argv[2] = { nullptr }; 
    // 获取参数信息 
    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr); 
    // argv[0]即为函数第一个参数Js资源对象，OH_ResourceManager_InitNativeResourceManager转为Native对象。 
    NativeResourceManager *mNativeResMgr = OH_ResourceManager_InitNativeResourceManager(env, argv[0]); 
    size_t strSize; 
    char strBuf[256]; 
    napi_get_value_string_utf8(env, argv[1], strBuf, sizeof(strBuf), &strSize); 
    std::string filename(strBuf, strSize); 
    // 获取rawfile指针对象 
    RawFile *rawFile = OH_ResourceManager_OpenRawFile(mNativeResMgr, filename.c_str()); 
    if (rawFile != nullptr) { 
        OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, TAG, "OH_ResourceManager_OpenRawFile success"); 
    } 
    // 获取rawfile大小并申请内存 
    long len = OH_ResourceManager_GetRawFileSize(rawFile); 
    std::unique_ptr<uint8_t[]> data= std::make_unique<uint8_t[]>(len); 
    // 一次性读取rawfile全部内容 
    int res = OH_ResourceManager_ReadRawFile(rawFile, data.get(), len); 
    // 关闭打开的指针对象 
    OH_ResourceManager_CloseRawFile(rawFile); 
    OH_ResourceManager_ReleaseNativeResourceManager(mNativeResMgr); 
    // 转为js对象 
    return CreateJsArrayValue(env, data, len); 
}
```


```typescript
import testNapi from 'libnativecrossmoduleaccessres.so'; 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Native Cross Module Access Resource'; 
  private resMgr = getContext().createModuleContext('NativeAccessRes').resourceManager;  // 获取本应用包的资源对象 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            let rawfileContext = testNapi.getRawFileContent(this.resMgr, 'rawfile.txt'); 
            console.log("rawfileContext" + rawfileContext); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接：


Rawfile开发指导


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-24
爬取时间: 2025-05-08 04:33:57
来源: Huawei Developer


Native侧暂无可以获取APP版本信息的接口，如需获取APP版本信息可在ArkTS侧获取，然后传递到Native侧。


通过@kit.AbilityKit模块中的bundleManager查询bundleInfo。在bundleInfo中包含App版本号、版本名信息。


ArkTS侧获取版本信息参考代码如下：


```typescript
import { bundleManager } from '@kit.AbilityKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            bundleManager.getBundleInfoForSelf(bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION).then((bundleInfo)=>{ 
              let versionName = bundleInfo.versionName;//应用版本名 
              let versionNo = bundleInfo.versionCode;//应用版本号 
            }).catch((error : BusinessError)=>{ 
              console.error("get bundleInfo failed,error is "+error)}) 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


ArkTS侧传递数据到Natvie侧可参考链接：


使用Node-API实现跨语言交互开发流程


获取模块相关信息参考链接：


bundleInfo


bundleManager模块


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-28
爬取时间: 2025-05-08 04:34:07
来源: Huawei Developer


目前绑定方式是在JS侧调用C侧声明的ArkTS构造函数构造对象，在C侧解析构造函数的参数，构造对应的对象返回到ArkTS侧。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-29
爬取时间: 2025-05-08 04:34:17
来源: Huawei Developer


libuv处理方式是在注册JS回调时保存env。在callback中从env中获取对应的JS线程的loop，再调用libuv接口抛JS任务到loop中执行。


napi_create_thread_safe_function函数调用是会触发参数中的napi_threadsafe_function_call_js函数，该函数可以获取env在js线程中执行，可参考如下方式：


```less
#include "napi/native_api.h" 
#include <thread> 
#include "hilog/log.h" 
 
napi_ref cbObj = nullptr; 
// 线程安全函数 
napi_threadsafe_function tsfn; 
// Native侧Value值 
static int cValue; 
 
 
// 子线程运行函数 
static void CallJs(napi_env env, napi_value js_cb, void *context, void *data) { 
    std::thread::id this_id = std::this_thread::get_id(); 
    OH_LOG_INFO(LOG_APP, "threadId3 is +%{public}d", this_id); 
    // 获取引用值 
    napi_get_reference_value(env, cbObj, &js_cb); 
 
    // 创建一个ArkTS number作为ArkTS function的入参。 
    napi_value argv; 
    napi_create_int32(env, cValue, &argv); 
 
    napi_value result = nullptr; 
    napi_call_function(env, nullptr, js_cb, 1, &argv, &result); 
 
    napi_get_value_int32(env, result, &cValue); 
 
    napi_delete_reference(env, cbObj); 
} 
 
// Native 主线程 
static napi_value ThreadsTest(napi_env env, napi_callback_info info) { 
    // 从ArkTS侧获取的参数的数量 
    size_t argc = 1; 
    napi_value js_cb, work_name; 
 
    // 获取ArkTS参数 
    napi_get_cb_info(env, info, &argc, &js_cb, nullptr, nullptr); 
 
    // 指向napi_value js_cb 的 napi_ref cbObj 
    napi_create_reference(env, js_cb, 1, &cbObj); 
 
    // 通过UTF8编码的C字符串数据创建work_name 
    napi_create_string_utf8(env, "Work Item", NAPI_AUTO_LENGTH, &work_name); 
 
    // 创建线程安全函数 
    napi_create_threadsafe_function(env, js_cb, NULL, work_name, 0, 1, NULL, NULL, NULL, CallJs, &tsfn); 
 
    std::thread::id this_id = std::this_thread::get_id(); 
    OH_LOG_INFO(LOG_APP, "threadId1 is +%{public}d", this_id); 
 
    // 其他线程中调用线程安全函数 
    std::thread t([]() { 
        // 可获取线程ID 
        std::thread::id this_id = std::this_thread::get_id(); 
        OH_LOG_INFO(LOG_APP, "threadId2 is +%{public}d", this_id); 
        napi_acquire_threadsafe_function(tsfn); 
        napi_call_threadsafe_function(tsfn, NULL, napi_tsfn_blocking); 
    }); 
    t.detach(); 
 
    return NULL; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-30
爬取时间: 2025-05-08 04:34:26
来源: Huawei Developer


1. 在index.d.ts文件中，提供ArkTS侧的接口方法。


```typescript
export const nativeCallArkTS: (a: object) => number;
```


2. 实现Native侧的NativeCallArkTS接口，具体代码如下：


```less
static napi_value NativeCallArkTS(napi_env env, napi_callback_info info) 
{     
    size_t argc = 1; 
    // 声明参数数组 
    napi_value args[1] = { nullptr }; 
 
    // 获取传入的参数并依次放入参数数组中 
    napi_get_cb_info(env, info, &argc, args , nullptr, nullptr); 
 
    // 创建一个int，作为ArkTS的入参 
    napi_value argv = nullptr;     
    napi_create_int32(env, 2, &argv ); 
 
    // 调用传入的callback，并将其结果返回 
    napi_value result = nullptr; 
    napi_call_function(env, nullptr, args[0], 1, &argv, &result); 
    return result; 
}
```


3. 在ArkTS侧，通过nativeModule.nativeCallArkTS()方法传入方法。


entry/src/main/ets/pages/Index.ets


```typescript
// 通过import的方式，引入Native能力。
import nativeModule from 'libentry.so'


@Entry
@Component
struct InvokeArkTSMethod {
  @State message: string = 'Test Node-API nativeCallArkTS result: ';


  build() {
    Row() {
      Column() {
        // 调用nativeCallArkTS方法，对应到Native的NativeCallArkTS，在Native调用ArkTS function。
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .onClick(() => {
            this.message += nativeModule.nativeCallArkTS((a: number) => {
              return a * 2;
            });
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


参考链接


Node-API典型使用场景


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-31
爬取时间: 2025-05-08 04:34:36
来源: Huawei Developer


可以将Curl移植到HarmonyOS，然后在Native侧开发时直接使用Curl的C++库实现。具体HarmonyOS移植方法可参考链接。


具体使用步骤如下：

1. 
2. 
3. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160829.26523263548260104420982046676802:50001231000000:2800:378B95EE9CE4827CAC7FD8187DB7E514B21204941F9AE1C4D7988D52FE4B8566.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160829.63685614961011939402637433418730:50001231000000:2800:2376E53D45F55978D1B311FEB11390032EB7CCD6AB089425EAFAEDA13AD4725A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160829.95780141936048534911223176231925:50001231000000:2800:968BE707C275900DC1625AEA5EDB0CE955BA9FFB09260C59041B8350877E9848.png)

具体可参考以下代码：


```less
#include "curl/curl.h" 
// ... 
// get请求和post请求数据响应函数 
size_t ReqReply(void *ptr, size_t size, size_t nmemb, void *userdata) { 
    string *str = reinterpret_cast<string *>(userdata); 
    (*str).append((char *)ptr, size * nmemb); 
    return size * nmemb; 
} 
// http GET请求配置 
CURLcode CurlGetReq(const std::string &url, std::string &response) { 
    // curl初始化 
    CURL *curl = curl_easy_init(); 
    // curl返回值 
    CURLcode res; 
    if (curl) { 
        // 设置Curl的请求头 
        struct curl_slist *headers = NULL; 
        headers = curl_slist_append(headers, "Content-Type:application/json"); 
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers); 
        // 设置请求的URL地址 
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); 
        // 接收响应头数据，0代表不接收 1代表接收 
        curl_easy_setopt(curl, CURLOPT_HEADER, 1); 
        // 设置数据接收函数 
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, ReqReply); 
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&response); 
        // 设置不使用任何信号/警报处理程序 
        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1); 
        // 设置超时时间 
        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 10); 
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10); 
        // 开启请求 
        res = curl_easy_perform(curl); 
    } 
    // 释放curl 
    curl_easy_cleanup(curl); 
    return res; 
} 
 
static napi_value NatReq(napi_env env, napi_callback_info info) { 
    string getUrlStr = "http://app.huawei.com"; 
    string getResponseStr; 
    auto res = CurlGetReq(getUrlStr, getResponseStr); 
    if (res == CURLE_OK) { 
        OH_LOG_Print(LOG_APP, LOG_INFO, 0xFF00, "pure", "response: \n%{public}s", getResponseStr.c_str()); 
    } 
    // ... 
}
```


结果展示


与终端直接使用curl指令获取的网站信息一致。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160829.54175505572469765114370178239696:50001231000000:2800:22FEE8692992B4C207757C839AF94D2898F77978CF684B841B065E8A7BA70BC2.png)

参考链接


使用命令行CMake构建NDK工程


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-33
爬取时间: 2025-05-08 04:34:45
来源: Huawei Developer


ArkTS与C/C++之间交互，涉及到跨语言调用中数据转换，以及跨线程交互等内容。沿用Node-API标准实现，支持的Node-API接口可参见Node-API支持的数据类型和接口。


当前可以通过AKI三方库实现跨语言调用。AKI针对OpenHarmony上提供ArkTS与C/C++跨语言互调的场景提供解决方案，提供了极简语法糖使用方式，一行代码完成ArkTS与C/C++的无障碍跨语言互调，所见即所得。同时开发者无需关心Node-API的线程安全问题、Native对象GC问题，为开发者屏蔽Node-API内部复杂逻辑。

1.  指定路径下（如：项目根路径/entry），输入如下命令安装ohpm har包依赖。 CMakeLists.txt添加依赖（假定编译动态库名为：libhello.so）： 在右上角同步工程：

```less
cd entry 
ohpm install @ohos/aki
```


```less
#include <aki/jsbind.h> 
#include <string> 
// 1、用户自定义业务 
std::string SayHello(std::string msg){  return msg + " too.";}  
 
// 2、导出业务接口 
// Step 1 注册 AKI 插件 
JSBIND_ADDON(entry) // 注册 AKI 插件名: 即为编译*.so名称，规则与Node-API一致 
 
// Step 2 注册 FFI 特性 
JSBIND_GLOBAL() 
{ 
  JSBIND_FUNCTION(SayHello); 
}
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160829.99721323683067873334017357676791:50001231000000:2800:875352B952E68B10EC0744F1F2A700610C733630B5D3460B1DFE0C1923C38EB5.png)

注册的AKI插件名需要与模块级的oh-package.json5文件dependencies标签的“lib<AKI插件名>”（例如libentry.so）字段名称保持一致。

1.  export const SayHello: (msg: string) => string;

```typescript
import aki from 'libentry.so' // 工程编译出来的*.so 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            console.info(aki.SayHello("hello world")); // 调用.so文件中的代码接口 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


AKI项目介绍


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-34
爬取时间: 2025-05-08 04:34:55
来源: Huawei Developer


1.将编译好的so库放到Native工程的entry/libs/arm64-v8a/目录下，并将so库对应的头文件放到entry/src/main/cpp目录层级下（可以在cpp目录下增加一个文件夹专门存放三方so库的头文件）。


2.在CMakeList.txt文件中链入so库。


3.在Native侧 .cpp文件中引入头文件使用so库的相关能力。


示例如下：


在Native侧集成三方库Curl


1. 将移植后的Curl的so库放到Native工程的entry/libs/目录下，并将移植后生成的、包含头文件的include目录放到entry/src/main/cpp目录下。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160829.18287281381084745422150848990784:50001231000000:2800:9F559A4F37F9A096B6EC49A8DD5C20F56CFA4534570D948713C1E66ACE77C7D1.png)

2. 在CMakeLists.txt文件中链入Curl对应的so库。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160829.92640071450146121684923670016850:50001231000000:2800:A74964CD9F679BA7997E0675CF56D3EB138BCDFC78246466BF21D54794827022.png)

3. 在Native侧.cpp文件中通过引入头文件curl.h来使用Curl的相关能力。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160829.62738327471523394384031851699132:50001231000000:2800:EF31225B8DE1F01EC02C2961FE28E21C88B7F8F73C1CB2CCC096CE022A5E5691.png)

参考链接：


在NDK工程中使用预构建库


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-35
爬取时间: 2025-05-08 04:35:05
来源: Huawei Developer


1.在CMakeLists.txt中新增libhilog_ndk.z.so链接：


```less
target_link_libraries(entry PUBLIC libhilog_ndk.z.so)
```


2.在源文件中包含hilog头文件, 并定义domain、tag宏：


```less
#include "hilog/log.h" 
#undef LOG_DOMAIN 
#undef LOG_TAG 
#define LOG_DOMAIN 0x3200 // 全局domain宏，标识业务领域 
#define LOG_TAG "MY_TAG"  // 全局tag宏，标识模块日志tag
```


3.打印日志，以打印ERROR级别的日志为例：


注意这里需要加上{public}才可以显示打印出内容，不添加默认是{private}


```less
int a = 5, b = 10; 
OH_LOG_ERROR(LOG_APP, "Pure a:%{public}d b:%{private}d.", a, b);
```


结果展示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160829.35443973146532287061497374060260:50001231000000:2800:493F560CB7C33FC343C277A0814E74D42B6C9D21BF3B6E8A246D694662E27791.png)

参考链接：


使用HiLog打印日志(C/C++)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-36
爬取时间: 2025-05-08 04:35:15
来源: Huawei Developer


问题现象：


使用系统的工具链编译出opencv(3.1.0)的so库，由于生成的so的后缀为so.x.y.z，无法打进应用包使用。


解决措施：


当前应用的so是DevEco Studio侧打包带入的，允许应用通过 libxxx.so.x的方式提供so，如果需要同时带入两个版本的 so，real name 与 so name 名字要相同，明确到主版本号libxxx.so.x，不需要带上 .y.z；所以目前libxxx.so是能够使用的，libxxx.3.1以及libxxx.so.3.1.0需要改成libxxx.x的形式使用。然后需要在CMakeLists.txt文件中重新配置并编译。


例如：


当引用libxxx.so，libxxx.so.0等后缀类型的so库时，直接在CMakeLists.txt文件中配置即可；


当引用libxxx.so.1.2，libxxx.so.1.2.0等后缀类型的so库时，不能直接将其重命名为libxxx.so后使用，要重命名为libxxx.so.1（明确到主版本号libxxx.so.x），然后在CMakeLists.txt文件中配置使用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-37
爬取时间: 2025-05-08 04:35:25
来源: Huawei Developer


关于napi_module_register(napi_module* mod)方法的入参napi_module字段的详细描述如下：


```less
static napi_module demoModule = { 
    .nm_version = 1,                // nm版本号，默认值为1 
    .nm_flags = 0,                  // nm标识符 
    .nm_filename = nullptr,         // 文件名，暂不关注，使用默认值即可 
    .nm_register_func = Init,       // 指定nm的入口函数 
    .nm_modname = "entry",          // 指定ArkTS页面导入的模块名 
    .nm_priv = ((void *)0),         // 暂不关注，使用默认即可 
    .reserved = {0},                // 暂不关注，使用默认值即可 
};
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-38
爬取时间: 2025-05-08 04:35:35
来源: Huawei Developer


当前native侧暂无可直接获取文件目录的接口，可以通过ArkTS侧获取相关路径信息，然后传递到native侧使用。


ArkTS侧获取路径信息代码示例：


```less
import { common } from '@kit.AbilityKit'; 
let context = getContext(this) as common.UIAbilityContext; 
let filesDir = context.filesDir;
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-39
爬取时间: 2025-05-08 04:35:45
来源: Huawei Developer


可以将包含so库的工程编译成har包，然后在新工程中安装har包，在新工程中通过import对应的so库函数来使用。具体操作可参考链接指南。


参考链接：


HAR


开发及引用共享包


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-41
爬取时间: 2025-05-08 04:35:55
来源: Huawei Developer


示例代码如下：


ArkTS侧


```typescript
// index.ets 
import testNapi from 'libentry.so'; 
... 
build() { 
... 
  .onClick(() => { 
    let data: Record<string, number> = testNapi.callbackToArkTS((value: object) => { 
      let obj: Record<string, number> = value as Record<string, number>; 
      console.info("pre type:" + obj["type"].toString()) 
      console.info(JSON.stringify(value)) 
      obj["type"] += 10; 
      return value; 
    }); 
    console.info(JSON.stringify(data)) 
  }) 
}
```


Native侧


```less
#include "napi/native_api.h" 
#include "hilog/log.h" 
#undef LOG_DOMAIN 
#undef LOG_TAG 
#define LOG_DOMAIN 0x3200 
#define LOG_TAG "MY_TAG" 
 
static bool Napi_AddPropertyInt32(napi_env env, napi_value obj, const char *key, int32_t value) { 
    napi_value key_napi = nullptr; 
    napi_status status = napi_create_string_utf8(env, key, NAPI_AUTO_LENGTH, &key_napi); 
    napi_value value_napi = nullptr; 
    status = napi_create_int32(env, value, &value_napi); 
    status = napi_set_property(env, obj, key_napi, value_napi); 
    return true; 
} 
static  napi_value CallbackToArkTS(napi_env env, napi_callback_info info) { 
    size_t argc = 1; 
    napi_value args[1] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    // native回调到ArkTS层的object 
    napi_value argv = nullptr; 
    napi_create_object(env, &argv); 
    Napi_AddPropertyInt32(env, argv, "type", 1); 
    Napi_AddPropertyInt32(env, argv, "index", 2); 
    // native回调到ArkTS层 
    napi_value result = nullptr; 
    napi_call_function(env, NULL, args[0], 1, &argv, &result); 
    // 获取ArkTS修改后的object 
    napi_value typeNumber = nullptr; 
    napi_get_named_property(env, result, "type", &typeNumber); 
    int32_t number; 
    napi_get_value_int32(env, typeNumber, &number); 
    OH_LOG_INFO(LOG_APP, "ArkTS侧修改后的type：%{public}d", number); 
    // 返回修改后的object 
    return result; 
} 
EXTERN_C_START 
static napi_value Init(napi_env env, napi_value exports) 
{ 
    napi_property_descriptor desc[] = { 
        { "callbackToArkTS", nullptr, CallbackToArkTS, nullptr, nullptr, nullptr, napi_default, nullptr } 
    }; 
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc); 
    return exports; 
} 
EXTERN_C_END 
...
```


index.d.ts


```typescript
export const callbackToArkTS: (a: object) => Record<string, number>
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-42
爬取时间: 2025-05-08 04:36:05
来源: Huawei Developer


在ArkTS侧定义类，传递类到Native侧调用类函数。详情见示例代码。


ArkTS侧


```typescript
// index.ets 
import testNapi from 'libentry.so'; 
import { promptAction } from '@kit.ArkUI'; 
 
class A { 
  name:string ='username' 
  onCall() { 
    promptAction.showToast({ 
      message:'Message Info', 
      duration:2000 
    }); 
    console.log("testTag user onCall"); 
  } 
} 
build() { 
... 
  .onClick(() => { 
    testNapi.callFunction(new A()); 
  }) 
}
```


```typescript
// index.d.ts 
export const callFunction: (a:object) => void;
```


Native侧


```less
// 传入实例对象，在C++侧调用对象中的函数 
#include "napi/native_api.h" 
static napi_value CallFunction(napi_env env, napi_callback_info info) { 
    // 获取实例对象 
    size_t argc = 1; 
    napi_value args[1] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, NULL, NULL); 
    // 获取对象的方法 
    napi_value onCall; 
    napi_get_named_property(env, args[0], "onCall", &onCall); 
    // 调用对象中的函数 
    napi_value res; 
    napi_call_function(env, args[0], onCall, 0, nullptr, &res); 
    return onCall; 
} 
EXTERN_C_START 
static napi_value Init(napi_env env, napi_value exports) { 
    napi_property_descriptor desc[] = { 
        {"callFunction", nullptr, CallFunction, nullptr, nullptr, nullptr, napi_default, nullptr}}; 
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc); 
    return exports; 
} 
...
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-43
爬取时间: 2025-05-08 04:36:14
来源: Huawei Developer


请按照下述例子进行配置：


例1：


目录结构：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160830.85841290933751318437536825956533:50001231000000:2800:7F9D5B2E199591CC8EFFF846DED0790ECB691BFE377FAD635C45A5010FA85211.png)

CMakeLists.txt配置头文件搜索路径：


include_directories(${NATIVERENDER_ROOT_PATH}/include)


cpp文件中引用头文件:


#include 'test.h'


例2:


目录结构：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160830.27956258768805476936817615111002:50001231000000:2800:DAFB625DDD6023770275570F2B6C138822D3BE17C838C6018080CCAAEAF4663D.png)

CMakeLists.txt配置头文件搜索路径：


include_directories(${NATIVERENDER_ROOT_PATH})


cpp文件中引用头文件:


#include 'include/test/test.h'


例3:


目录结构：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160830.02695629309870054548108368928765:50001231000000:2800:6304362178D581007CC746A9C97BBC8149FBB0E2C21AE2EBAB32835A4A9CA3E1.png)

CMakeLists.txt配置头文件搜索路径：


include_directories(${NATIVERENDER_ROOT_PATH}/include)


cpp文件中引用头文件:


#include 'test/test.h'


例4:


目录：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160830.32290095962267146790785187294855:50001231000000:2800:E268055C31047672595A31C45EE6AA1956074BDFFBD6AD1A85CEB2EAA292BF90.png)

CMakeLists.txt配置头文件搜索路径:


include_directories(${NATIVERENDER_ROOT_PATH}/include/test)


cpp文件中引用头文件:


#include 'test.h'


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-44
爬取时间: 2025-05-08 04:36:23
来源: Huawei Developer


问题现象：


在C++文件中，参照官方指导文档，引入头文件#include "deviceinfo.h"文件后，编译时仍提示无法找到该头文件，日志提示未链接deviceinfo库。


解决措施：


当前public SDK 中没有deviceinfo.h头文件，full SDK中才可以使用该头文件，并且需要在CMakeLists.txt导入libdeviceinfo_ndk.z.so 库才能找到该头文件。方法如下：


```less
// CMakeLists.txt 
... 
target_link_libraries(entry PUBLIC libace_napi.z.so libdeviceinfo_ndk.z.so)
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-45
爬取时间: 2025-05-08 04:36:33
来源: Huawei Developer


```less
// native 层创建对象arg_object
napi_value arg_object;
napi_create_object(env, &arg_object);
```


```less
napi_value testNum, testString;
// 给上面创建的arg_object对象设置属性testNum并赋值123
napi_create_int32(env, 123, &testNum);
napi_set_named_property(env, arg_object, "testNum", testNum);
// 给上面创建的arg_object对象设置属性testString赋值"Pure"
napi_create_string_utf8(env, "Pure", NAPI_AUTO_LENGTH, &testString);
napi_set_named_property(env, arg_object, "testString", testString);
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-46
爬取时间: 2025-05-08 04:36:43
来源: Huawei Developer


导入使用的模块名和注册时的模块名大小写保持一致，如模块名为entry，则so的名字为libentry.so，napi_module中nm_modname字段应为entry，ArkTS侧使用时写作：import xxx from 'libentry.so'。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-47
爬取时间: 2025-05-08 04:36:52
来源: Huawei Developer


引入hilog库之后直接打印即可。打印时需要加{public}。


OH_LOG_INFO(LOG_APP, “%{public}s”,path); //可正常打印


OH_LOG_INFO(LOG_APP, “%s”,path); //不可正常打印


示例代码如下：


```less
char *path = "abc"; 
OH_LOG_INFO(LOG_APP, "path: %{public}s", path);
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-48
爬取时间: 2025-05-08 04:37:02
来源: Huawei Developer


持久持有一个对象，可以通过napi_create_reference创建一个强引用，然后将这个ref保存下来使用；主动销毁可以使用napi_delete_reference，减少或者增加引用计数可以通过napi_reference_unref或者napi_reference_ref。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-49
爬取时间: 2025-05-08 04:37:12
来源: Huawei Developer


纯在ArkTS侧不可以往C++层注册对象或者函数，开发者需要回到C++层自己处理；env可以长期持有，不过使用env时，需要在特定的线程，使用env时需要在创建该env的ArkTS线程使用。


参考链接


Native与ArkTS对象绑定


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-50
爬取时间: 2025-05-08 04:37:22
来源: Huawei Developer


在hvigor->hvigor-config.json5文件中修改"logging"字段的"level" 字段值。级别有"debug" | "info" | "warn" | "error"。修改完成后可以在run窗口查看CMakeLists.txt文件中message方法打印的日志信息。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-51
爬取时间: 2025-05-08 04:37:31
来源: Huawei Developer


问题现象


在java中，一般可以由垃圾回收机制进行对象的回收，那么，ArkTS对象内部创建绑定的c++对象，怎样通过类似java的 finalize时机自动执行内存回收，而不需要开发者主动调用。


解决措施


ArkTS无法直接回收C++对象，可以在ArkTS侧业务完成后，通过接口给Native侧信号，在Native侧释放对象。具体方式如下：


在使用napi_wrap绑定ArkTS对象与C++对象时通过定义回调函数来销毁C++对象，即接口的第四个参数。绑定完成后，在ArkTS对象被回收时会自动触发回调函数来销毁对应的C++侧对象。


具体接口使用示例如下：


```less
napi_wrap( 
    env, ArkTSDemo, CDemo, 
    // 定义ArkTS对象回收时回调函数，用来销毁C++对象，防止内存泄漏 
    [](napi_env env, void *finalize_data, void *finalize_hint) { 
        MyDemo *cDemo = (MyDemo *)finalize_data; 
        delete cDemo; 
        cDemo = nullptr; 
    }, 
    nullptr, nullptr);
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-52
爬取时间: 2025-05-08 04:37:41
来源: Huawei Developer


ArkTS Uint8Array的传递方式与其他类型相同。


```typescript
// ArkTS传递Uint8Array参数 
import testNapi from 'libentry.so'; 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            let temp = new Uint8Array(2); 
            temp[0] = 1; 
            temp[1] = 2; 
            console.info(`Pure inputBuffer length: ${temp.length}`); 
            let res = testNapi.uintArr(temp); 
            console.info(`Pure outputBuffer: ${res}`); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


Native侧可以使用napi_get_typedarray_info方法获取Uint8Array的详细信息。


```less
// Native侧获取Uint8Array参数并返回到ArkTS侧 
#include "UintArr.h" 
napi_value Demo1::UintArr(napi_env env, napi_callback_info info) { 
    size_t requireArgc = 1; 
    size_t argc = 1; 
    napi_value args[1] = {nullptr}; 
 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
 
    napi_value inputArray = args[0]; 
 
    // 获取ArrayBuffer类型 
    napi_typedarray_type type; 
    napi_value inArrayBuffer; 
    size_t byteOffset; 
    size_t length; 
    napi_get_typedarray_info(env, inputArray, &type, &length, nullptr, &inArrayBuffer, &byteOffset); 
    if (type != napi_uint8_array) { 
        return nullptr; 
    } 
     
    // 获取ArrayBuffer信息 
    void *data = nullptr; 
    size_t byte_length; 
    napi_get_arraybuffer_info(env, inArrayBuffer, &data, &byte_length); 
 
    // 构造ArrayBuffer并赋值 
    napi_value output_buffer; 
    void *output_ptr = nullptr; 
    napi_create_arraybuffer(env, byte_length, &output_ptr, &output_buffer); 
    napi_value outputArray; 
    napi_create_typedarray(env, type, length, output_buffer, byteOffset, &outputArray); 
    uint8_t *input_bytes = (uint8_t *)(data) + byteOffset; 
    uint8_t *array = (uint8_t *)(output_ptr); 
    for (size_t idx = 0; idx < length; idx++) { 
        array[idx] = 3; 
    } 
 
    return outputArray; 
}
```


index.d.ts声明接口。


```typescript
export const uintArr: (a: Uint8Array) => object;
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-53
爬取时间: 2025-05-08 04:37:51
来源: Huawei Developer


在ArkTS创建一个类并传递给Native侧，Native侧通过napi_call_function接口调用ArkTS侧的类函数。


```less
// 声明Demo类 
class Demo { 
  add(a: number, b: number): number { 
    return a + b; 
  } 
 
  sub(a: number, b: number): number { 
    return a - b; 
  } 
} 
 
export default new Demo();
```


ArkTS侧：


```typescript
// 传递参数到native侧 
import testNapi from 'libentry.so'; 
import demo from './interface/ClassDemo1' 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            let flag:Boolean = false; 
            console.info(`Test NAPI Result is ${testNapi.cal(2, 3, demo, true)}`) 
            console.info(`Num is  ${demo.add(3,2)}`) 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


Native侧：


```less
// 获取类信息并调用类函数 
#include "CGetArkTSObject.h" 
napi_value CGetArkTSObject::Cal(napi_env env, napi_callback_info info) { 
    size_t argc = 4; 
    napi_value args[4] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
 
    double value0; 
    napi_get_value_double(env, args[0], &value0); 
 
    double value1; 
    napi_get_value_double(env, args[1], &value1); 
 
    // 构造类实例 
    napi_value demo; 
    napi_create_object(env, &demo); 
    napi_coerce_to_object(env, args[2], &demo); 
 
    bool flag; 
    napi_get_value_bool(env, args[3], &flag); 
 
    // 获取类实例的add，sub函数 
    napi_value add, sub, num; 
    napi_get_named_property(env, demo, "add", &add); 
    napi_get_named_property(env, demo, "sub", &sub); 
 
    // 调用ArkTS函数 
    napi_value result; 
    if (flag) { 
        napi_call_function(env, nullptr, add, 2, args, &result); 
    } else { 
        napi_call_function(env, nullptr, sub, 2, args, &result); 
    } 
 
    return result; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-56
爬取时间: 2025-05-08 04:38:01
来源: Huawei Developer


问题现象


开发者使用Native Module做C++开发，不知道Native Module依赖怎么配置，即C++ NativeSDK Module A中的cpp调用C++ NativeSDK Module B中的cpp，并支持源码调试。


解决措施


此处以Modulea，Moduleb为例。Modulea中的C++代码想要引用Moduleb的C++ api接口。


首先创建模块Moduleb（File->New->Module...->Shared Library，输入模块名，勾选Enable native）。


Moduleb中配置：


```less
"nativeLib": {
  "debugSymbol": {
    "strip": true,
    "exclude": []
  },
  "headerPath": "src/main/cpp/include"
},
```


Modulea中配置：


```less
"dependencies": {
  "libmodulea.so": "file:./src/main/cpp/types/libmodulea",
  "moduleb": "file:../Moduleb"
}
```


```less
target_link_libraries(modulea PUBLIC libace_napi.z.so moduleb::moduleb)
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-57
爬取时间: 2025-05-08 04:38:11
来源: Huawei Developer


问题现象


webrtc gn里面通过binary_prefix来区分到底选择哪个架构下的编译工具。HarmonyOS系统如何设置target指定架构信息？


解决措施


HarmonyOS通过–target 来设置架构。--target aarch64-linux-ohos 和--target arm-linux-ohos 分别对应64位和32位的架构。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-58
爬取时间: 2025-05-08 04:38:20
来源: Huawei Developer


问题现象


napi_create_buffer接口如何使用，构建出来的结果如何在ArkTS与Native之间传递？


解决措施


可以参考以下代码：


```less
#include "CreatBuffer.h"
napi_value CreatBuffer::TestBuffer(napi_env env, napi_callback_info) {
    size_t length = 100;
    char *data = nullptr;
    napi_value result = nullptr;
    napi_create_buffer(env, length, reinterpret_cast<void **>(&data), &result);


    char buf[50] = {0};
    for (int i = 0; i < 50; i++) {
        buf[i] = i + 2;
    }
    napi_create_buffer_copy(env, 50, buf, reinterpret_cast<void **>(&data), &result);
    return result;
}
```


```less
export const testBuffer: () => ArrayBuffer;
```


```typescript
import testNapi from 'libentry.so';


@Entry
@Component
struct Index {
  @State message: string = 'Hello World';


  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .onClick(() => {
            let arr = testNapi.testBuffer();
            let result = new Uint8Array(arr);
            for (let index = 0; index < result.byteLength; index++) {
              console.info(`res[${index}] = ${result[index]}`)
            }
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-59
爬取时间: 2025-05-08 04:38:30
来源: Huawei Developer


可以通过napi_create_arraybuffer接口实现。


```less
#include "CharToArrBuffer.h" 
napi_value CharToArrBuffer::TestCharBuf(napi_env env, napi_callback_info info) { 
    napi_value result = nullptr; 
    char *buf = nullptr; 
    // 创建Arraybuffer 
    napi_create_arraybuffer(env, 100, reinterpret_cast<void **>(&buf), &result); 
    // 赋值ArrayBuffer 
    for (int i = 0; i < 100; i++) { 
        buf[i] = i + 2; 
    } 
    return result; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-60
爬取时间: 2025-05-08 04:38:40
来源: Huawei Developer


问题现象


有一个har模块，在 oh-package.json5 中配置了版本 1.0.0。模块内部有C++代码，其中某一个文件会根据版本变化，因此不同版本参与编译的都是不同的文件。通过CMAKE_VERSION变量可以获取Cmake的版本信息，但获取不到har的版本信息，如何在CMakeLists中获取当前har模块oh-package.json5中的version版本号，以匹配不同的cpp文件。


解决措施


可以尝试通过转JSON字符串与版本号比较的方式解决。


```less
cmake_minimum_required(VERSION 3.4.1) 
project(CmakeModuleInfo) 
 
set(JSON_FILE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/../../../oh-package.json5) 
file(READ ${JSON_FILE_PATH} JSON_STRING) 
message("json string:${JSON_STRING}") 
if("${JSON_STRING}" MATCHES "1.0.0") 
set(SRC_LIST napi_init.cpp) 
else() 
set(SRC_LIST hello.cpp) 
endif() 
message("src_file:${SRC_LIST}") 
 
set(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR}) 
include_directories(${NATIVERENDER_ROOT_PATH} 
                    ${NATIVERENDER_ROOT_PATH}/include) 
 
add_library(entry SHARED ${SRC_LIST}) 
target_link_libraries(entry PUBLIC libace_napi.z.so)
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-61
爬取时间: 2025-05-08 04:38:50
来源: Huawei Developer


此处以testCb为例


```less
class testCb { 
  testNum: number = 0; 
  testString: string = ""; 
}
```


方法一：


直接在index.d.ts文件中使用object类型声明。


```typescript
export const test: (a: object) => void;
```


方法二：


创建xx.ts文件，在xx.ts文件中将类export出来，并在index.d.ts文件中import并使用。


test.ts 导出声明接口。


```less
export class testCa { 
  testNum: number = 0; 
  testString: string = ""; 
}
```


index.d.ts import并使用。


```less
import { testCa } from "../../../ets/pages/interface/CustomObject" 
export const test1: (a: testCa) => void;
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-62
爬取时间: 2025-05-08 04:39:00
来源: Huawei Developer

1.  index.d.ts声明导出接口。

```less
import testNapi from 'libentry.so';


interface Obj1 {
  obj: Obj2,
  hello: String,
  arr: number[],
  typedArray: Uint8Array
}


interface Obj2 {
  str: string
}


@Entry
@Component
struct Index {
  @State message: string = 'Hello World';


  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .onClick(() => {
            const typedArr = new Uint8Array(3);
            typedArr[0] = 1;
            typedArr[1] = 2;
            typedArr[2] = 3;
            const obj: Obj1 = {
              obj: { str: 'obj in obj' },
              hello: 'world',
              arr: [94, 32, 43],
              typedArray: typedArr
            }
            console.info(`Test NAPI modifyObject result is ${JSON.stringify(testNapi.modifyObject(obj))}`)
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


```less
#include "RevArkTSObj.h"
napi_value RevArkTSObj::ModifyObject(napi_env env, napi_callback_info info) {
    size_t argc = 1;
    napi_value args[1] = {nullptr};
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);


    napi_value obj = args[0];


    napi_value obj1;
    napi_value hello1;
    napi_value arr1;
    napi_value typedArray1;


    napi_get_named_property(env, obj, "obj", &obj1);
    char *buf = "this is modified";
    napi_value str1;
    napi_create_string_utf8(env, buf, NAPI_AUTO_LENGTH, &str1);
    napi_set_named_property(env, obj1, "str", str1);
    napi_set_named_property(env, obj, "obj", obj1);


    napi_create_string_utf8(env, "world0", NAPI_AUTO_LENGTH, &hello1);
    napi_set_named_property(env, obj, "hello", hello1);


    napi_get_named_property(env, obj, "arr", &arr1);
    uint32_t arrLen;
    napi_get_array_length(env, arr1, &arrLen);
    for (int i = 0; i < arrLen; i++) {
        napi_value tmp;
        napi_create_uint32(env, i, &tmp);
        napi_set_element(env, arr1, i, tmp);
    }
    napi_delete_element(env, arr1, 2, nullptr);




    napi_get_named_property(env, obj, "typedArray", &typedArray1);
    bool is_typedArray;
    if (napi_ok != napi_is_typedarray(env, typedArray1, &is_typedArray)) {
        return nullptr;
    }
    napi_typedarray_type type;
    napi_value input_buffer;
    size_t length;
    size_t byte_offset;
    napi_get_typedarray_info(env, typedArray1, &type, &length, nullptr, &input_buffer, &byte_offset);
    // 获取 input_buffer 的基础数据缓冲区 data，和基础数据缓冲区的长度 byte_length。
    void *data;
    size_t byte_length;
    napi_get_arraybuffer_info(env, input_buffer, &data, &byte_length);
    // 创建新的ArrayBuffer，&output_ptr 指向 ArrayBuffer 的底层数据缓冲区的指针
    napi_value output_buffer;
    void *output_prt = nullptr;
    napi_create_arraybuffer(env, byte_length, &output_prt, &output_buffer);
    // 使用 output_buffer 创建 typedarray
    napi_value output_array;
    napi_create_typedarray(env, type, length, output_buffer, byte_offset, &output_array);
    // data 是由连续的内存位置组成，reinterpret_cast<uint8_t *>(data)  表示其第一个元素的内存地址。
    // data 是旧的 arraybuffer 数据指针
    uint8_t *input_bytes = reinterpret_cast<uint8_t *>(data) + byte_offset;
    // 把 output_ptr 指针赋值给 output_bytes
    // output_ptr 是新的 arraybuffer 数据指针
    uint8_t *output_bytes = reinterpret_cast<uint8_t *>(output_prt);
    for (int i = 0; i < length; i++) {
        // 将旧 arraybuffer 数据每一个元素乘 2，赋值给新 arraybuffer 数据
        output_bytes[i] = input_bytes[i] * 2;
    }
    // 将新 typedArray 赋值给 obj['typedArray']
    napi_set_named_property(env, obj, "typedArray", output_array);
    return obj;
}
```

2.  Test NAPI modifyObject result is {"obj":{"str":"this is modified"},"hello":"world0","arr":[0,1,null],"typedArray":{"0":2,"1":4,"2":6}}

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-63
爬取时间: 2025-05-08 04:39:10
来源: Huawei Developer


问题现象


因为底部C++库比较庞大，向外暴露的接口较多，希望能拆分成多个.d.ts方便归类。


解决措施


在oh-package.json5中的types字段只能指定唯一出口，如果想要实现多.d.ts文件封装接口可以使用重导出的方式。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160830.79726719354220128448057092521733:50001231000000:2800:FBD5BEB6C30747606D818C0B81FDA349636D634C9BB96869DC7CC322913C63E5.png)

实现方式如下：


在index1.d.ts文件中声明Native侧导出接口，然后通过index.d.ts文件重导出到ArkTS侧使用。


index1.d.ts文件中导出接口。


```typescript
export const sub: (a: number, b: number) => number;
```


index.d.ts文件重导出。


```typescript
export {sub} from './index1' 
export const add: (a: number, b: number) => number;
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-64
爬取时间: 2025-05-08 04:39:19
来源: Huawei Developer


问题现象


通过ArkTS侧向Native侧注册日志监听接口，当在Native侧任一业务中调用log接口时将日志通过回调上报ArkTS侧，是否可以提供一个类似示例？


解决措施


```typescript
import { hilog } from '@kit.PerformanceAnalysisKit';


export class GlobalThisAdapter {
  private constructor() {
  }


  private static instance: GlobalThisAdapter;
  private _logListener: LogsListener = new LogsListener();


  public static getInstance(): GlobalThisAdapter {
    if (!GlobalThisAdapter.instance) {
      GlobalThisAdapter.instance = new GlobalThisAdapter();
    }
    return GlobalThisAdapter.instance;
  }


  getLogsListener(): LogsListener | undefined {
    return this._logListener;
  }


  setLogsListener(value: LogsListener): void {
    this._logListener = value;
  }
}


export class LogsListener implements OnLogsListener {
  public constructor() {
  }


  onLogs(level: LogLevel, message: string): void {
    switch (level) {
      case LogLevel.DEBUG:
        hilog.debug(0x0000, 'debug', 'debug message is %{public}s', message);
        break;
      case LogLevel.INFO:
        hilog.info(0x0000, 'info', 'info message is %{public}s', message);
        break;
      case LogLevel.WARN:
        hilog.warn(0x0000, 'warn', 'warn message is %{public}s', message)
        break;
      case LogLevel.ERROR:
        hilog.error(0x0000, 'error', 'error message is %{public}s', message);
        break;
      case LogLevel.FATAL:
        hilog.fatal(0x0000, 'fatal', 'fatal message is %{public}s', message);
        break;
      default:
        hilog.info(0x0000, 'info', 'info message is %{public}s', message);
    }
  }
}


enum LogLevel {
  DEBUG = 3,
  INFO,
  WARN,
  ERROR,
  FATAL
}


export default interface OnLogsListener {
  onLogs(level: number, message: string): void;
}
```


```less
#include "napi/native_api.h"
#include <bits/alltypes.h>
#include <cstring>
#include <hilog/log.h>


napi_ref logListenerRef = nullptr;
napi_ref onLogsFuncRef = nullptr;
static napi_value RegisterLogListener(napi_env env, napi_callback_info info) {
    size_t argc = 1;
    napi_value globalThisAdapter = nullptr;
    napi_get_cb_info(env, info, &argc, &globalThisAdapter, nullptr, nullptr);


    napi_value getLogListenerFunc = nullptr;
    napi_get_named_property(env, globalThisAdapter, "getLogsListener", &getLogListenerFunc);


    napi_value logListener = nullptr;
    napi_call_function(env, globalThisAdapter, getLogListenerFunc, 0, nullptr, &logListener);


    napi_value onLogsFunc = nullptr;
    napi_get_named_property(env, logListener, "onLogs", &onLogsFunc);


    napi_create_reference(env, logListener, 1, &logListenerRef);
    napi_create_reference(env, onLogsFunc, 1, &onLogsFuncRef);


    return nullptr;
}
```


```less
EXTERN_C_START
static napi_value Init(napi_env env, napi_value exports) {
    napi_property_descriptor desc[] = {
        {"add", nullptr, Add, nullptr, nullptr, nullptr, napi_default, nullptr},
        {"registerLogListener", nullptr, RegisterLogListener, nullptr, nullptr, nullptr, napi_default, nullptr}};
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
    return exports;
}
EXTERN_C_END
```


```less
import { GlobalThisAdapter } from '../../../ets/interface/Log'
export const add: () => void;
export const registerLogListener: (a: GlobalThisAdapter) => void;
```


```less
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
  let globalThisAdapter: GlobalThisAdapter = GlobalThisAdapter.getInstance();
  testNapi.registerLogListener(globalThisAdapter);
  hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
}
```


```less
static void callOnLogs(napi_env env, LogLevel level, const char *message) {


    size_t argc = 2;
    napi_value argv[2] = {nullptr};


    int32_t tem = level;
    napi_create_int32(env, tem, &argv[0]);
    napi_create_string_utf8(env, message, strlen(message) + 1, &argv[1]);
    napi_value logListener = nullptr;
    napi_value onLogsFunc = nullptr;
    napi_get_reference_value(env, logListenerRef, &logListener);
    napi_get_reference_value(env, onLogsFuncRef, &onLogsFunc);


    napi_call_function(env, logListener, onLogsFunc, argc, argv, nullptr);
}
```


```less
static napi_value Add(napi_env env, napi_callback_info info) {
    callOnLogs(env, LogLevel::LOG_INFO, "execute  native Add function success");
    return nullptr;
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-65
爬取时间: 2025-05-08 04:39:29
来源: Huawei Developer


问题现象


解决措施

1.  针对包内abc文件接口路径说明： 目前仅接受rawfile文件夹下的abc文件。napi_run_script_path接口会直接拼接上当前hap所在的沙箱路径/data/storage/el1/bundle/。例如传入路径为entry/resources/rawfile/main.abc；则处理后的沙箱路径为/data/storage/el1/bundle/entry/resources/rawfile/main.abc。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-66
爬取时间: 2025-05-08 04:39:39
来源: Huawei Developer


目前提供了C接口的有如下几个模块：自定义DNS解析、证书校验、WebSocket。


未直接提供C接口的模块，可以通过AKI机制调用ArkTS接口。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-67
爬取时间: 2025-05-08 04:39:49
来源: Huawei Developer


问题详情：


如何实现将ArkTS的HashMap转至Native侧。


解决措施：

-  将HashMap的key、value作为数组取出，将两个数组传递至native侧并组装成Map。 ArkTS侧传递数组。 Native侧组装Map。

```typescript
let hashMap: HashMap<string, number> = new HashMap();
hashMap.set("Abc", 123);
hashMap.set("Bcd", 234)
hashMap.set("Cde", 345);


let keysArray: Array<string> = Array.from(hashMap.keys());
let valuesArray: Array<number> = Array.from(hashMap.values());
testNapi.tsPutMap(keysArray, valuesArray, hashMap.length);
```

-  将HashMap转为Json数据传至native侧，在native侧反序列化用Map承接。 ArkTS侧转JSON。 Native侧反序列化。 c++没有直接反序列化的接口，需要使用三方库，本demo采用lycium交叉编译工具编译json三方库。

```less
map2rec(map: HashMap<string, ESObject>): Record<string, ESObject> {
  // map转Record
  let Rec: Record<string, ESObject> = {};
  map.forEach((value: ESObject, key: string) => {
    if (value instanceof HashMap) {
      //value可能为HashMap
      let vRec: Record<string, ESObject> = this.map2rec(value);
      value = vRec;
    }
    Rec[key] = value;
  })
  return Rec;
}
```


```less
map2rec(map: HashMap<string, ESObject>): Record<string, ESObject> {
  // map转Record
  let Rec: Record<string, ESObject> = {};
  map.forEach((value: ESObject, key: string) => {
    if (value instanceof HashMap) {
      //value可能为HashMap
      let vRec: Record<string, ESObject> = this.map2rec(value);
      value = vRec;
    }
    Rec[key] = value;
  })
  return Rec;
}
```


```less
let myRec: Record<string, ESObject> = this.map2rec(hashMap);
let str: string = JSON.stringify(myRec);
testNapi.mapJson(str);
```


```less
map2rec(map: HashMap<string, ESObject>): Record<string, ESObject> {
  // map转Record
  let Rec: Record<string, ESObject> = {};
  map.forEach((value: ESObject, key: string) => {
    if (value instanceof HashMap) {
      //value可能为HashMap
      let vRec: Record<string, ESObject> = this.map2rec(value);
      value = vRec;
    }
    Rec[key] = value;
  })
  return Rec;
}
```


```less
let myRec: Record<string, ESObject> = this.map2rec(hashMap);
let str: string = JSON.stringify(myRec);
testNapi.mapJson(str);
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-69
爬取时间: 2025-05-08 04:39:58
来源: Huawei Developer


调用NAPI接口理论上都有可能产生异常，所以在业务的关键流程需要对接口调用的返回结果进行判断，查看是否有异常产生。比如：


```less
napi_status status = napi_create_object(env, &object); 
if (status != napi_ok) { 
  napi_throw_error(env, ...); 
  return; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-70
爬取时间: 2025-05-08 04:40:08
来源: Huawei Developer


目前支持在HSP/HAR包中导出C/C++的Native方法。


参考链接


HAR导出native方法、HSP导出native方法


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-71
爬取时间: 2025-05-08 04:40:18
来源: Huawei Developer


问题现象


A模块包含a.so，B模块包含b.so。a.so中有调用b.so的函数，b.so中也有调用a.so的函数。如果按照正常编译步骤，无论先编译哪个so，均会编译失败。


解决措施


通过dlopen和dlsym接口进行so编译依赖解耦，将隐式依赖转为显式依赖。具体可参考示例代码：

1.  （注意一定要用extern "C" {}括起来、不然不能识别到对应的函数导致编译出错）

```less
// a.cpp
extern "C" {     // 一定要用extern "C" {}括起来
#include "a.h"
#include <dlfcn.h>
#include "stdio.h"
typedef int (*FUNC_SUB)(int, int);
int add(int a, int b) { return a + b; }
int getb(char *path, int a, int b) {       // path:从ArkTS侧传递So文件的沙箱路径（注意路径要从arkts侧传递、不然有可能找不到路径、具体代码后续会列出）
    void *handle = dlopen(path, RTLD_LAZY);  // 打开一个动态链接库.路径为path
    if (!handle) {
        return 0;
    }
    FUNC_SUB sub_func = (FUNC_SUB)dlsym(handle, "sub"); // 获取函数名为sub的函数
    int res = sub_func(a, b);                           // 调用函数
    dlclose(handle);                                    // close动态链接库
    return res;
}
}
// a.h
extern "C" {
#ifndef DemoSO_a_H
#define DemoSO_a_H
int add(int a, int b);
int getb(char *path, int a, int b);
#endif // DemoSO_a_H
}
// b.cpp
extern "C" {     // 一定要用extern "C" {}括起来
#include "b.h"
#include <dlfcn.h>
#include "stdio.h"
typedef int (*FUNC_ADD)(int, int);
int sub(int a, int b) { return a - b; }
int geta(char *path, int a, int b) {    // path:从ArkTS侧传递So文件的沙箱路径（注意路径要从arkts侧传递、不然有可能找不到路径、具体代码后续会列出）
    void *handle = dlopen(path, RTLD_LAZY);    // 打开一个动态链接库.路径为path
    if (!handle) {
        return 0;
    }
    FUNC_ADD add_func = (FUNC_ADD)dlsym(handle, "add");      // 获取函数名为add的函数
    int res = add_func(a, b);                                // 调用函数
    dlclose(handle);                                         // close动态链接库
    return res;
}
}
// b.h
extern "C" {
#ifndef DemoSO_b_H
#define DemoSO_b_H
int sub(int a, int b);
int geta(char *path, int a, int b);
#endif // DemoSO_b_H
}
// CMakeLists.txt
cmake_minimum_required(VERSION 3.4.1)
project(liba)
add_library(a SHARED a.cpp)                  // 编译库liba.so
target_link_libraries(a PUBLIC libace_napi.z.so libhilog_ndk.z.so)
project(libb)
add_library(b SHARED b.cpp)                  // 编译库libb.so
target_link_libraries(b PUBLIC libace_napi.z.so libhilog_ndk.z.so)
```

2.  移动完之后的目录结构如下：

```typescript
// CMakeLists.txt
cmake_minimum_required(VERSION 3.4.1)
project(DemoSO)
set(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})
include_directories(${NATIVERENDER_ROOT_PATH}
                    ${NATIVERENDER_ROOT_PATH}/include)
add_library(demoso SHARED hello.cpp)                        // 添加libdemoso.so文件
// 添加依赖库liba.so、libb.so。 注意需要带上路径、不然无法找到对应的so库
target_link_libraries(demoso PUBLIC libace_napi.z.so ${CMAKE_CURRENT_SOURCE_DIR}/../../../libs/${OHOS_ARCH}/liba.so ${CMAKE_CURRENT_SOURCE_DIR}/../../../libs/${OHOS_ARCH}/libb.so)


// index.ets
import { hilog } from '@kit.LancetKit';
import testNapi from 'libdemoso.so';
@Entry
@Component
struct Index {
  @State message: string = 'Hello World';
  private path: string = '';


  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .onClick(() => {
            this.path = getContext(this).bundleCodeDir;   // 获取路径
            hilog.info(0x0000, 'testTag', 'Test NAPI 5 + 3 = %{public}d', testNapi.add(5, 3, this.path + '/libs/arm64/liba.so'));  // 调用native侧函数
            hilog.info(0x0000, 'testTag', 'Test NAPI 5 - 3 = %{public}d', testNapi.sub(5, 3, this.path + '/libs/arm64/libb.so'));
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}


// index.d.ts
export const add: (a: number, b: number, path: string) => number;
export const sub: (a: number, b: number, path: string) => number;


// hello.cpp
#include "a.h"
#include "b.h"
#include "napi/native_api.h"


static napi_value Add(napi_env env, napi_callback_info info) {
    size_t requireArgc = 3;
    size_t argc = 3;
    napi_value args[3] = {nullptr};
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    napi_valuetype valuetype0;
    napi_typeof(env, args[0], &valuetype0);
    napi_valuetype valuetype1;
    napi_typeof(env, args[1], &valuetype1);
    napi_valuetype valuetype2;
    napi_typeof(env, args[2], &valuetype2);
    int value0;
    napi_get_value_int32(env, args[0], &value0);
    int value1;
    napi_get_value_int32(env, args[1], &value1);
    char path[255];
    size_t size = 255;
    napi_get_value_string_utf8(env, args[2], path, 255, &size);
    int res = geta(path, value0, value1);                    // 调用函数并传递沙箱路径
    napi_value sum;
    napi_create_int32(env, res, &sum);
    return sum;
}
static napi_value Sub(napi_env env, napi_callback_info info) {
    size_t requireArgc = 3;
    size_t argc = 3;
    napi_value args[3] = {nullptr};
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    napi_valuetype valuetype0;
    napi_typeof(env, args[0], &valuetype0);
    napi_valuetype valuetype1;
    napi_typeof(env, args[1], &valuetype1);
    napi_valuetype valuetype2;
    napi_typeof(env, args[2], &valuetype2);
    int value0;
    napi_get_value_int32(env, args[0], &value0);
    int value1;
    napi_get_value_int32(env, args[1], &value1);
    char path[255];
    size_t size = 255;
    napi_get_value_string_utf8(env, args[2], path, 255, &size);
    int res = getb(path, value0, value1);                 // 调用函数并传递沙箱路径
    napi_value sum;
    napi_create_int32(env, res, &sum);
    return sum;
}
EXTERN_C_START
static napi_value Init(napi_env env, napi_value exports) {
    napi_property_descriptor desc[] = {{"add", nullptr, Add, nullptr, nullptr, nullptr, napi_default, nullptr},
                                       {"sub", nullptr, Sub, nullptr, nullptr, nullptr, napi_default, nullptr}};
    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
    return exports;
}
EXTERN_C_END


static napi_module demoModule = {
    .nm_version = 1,
    .nm_flags = 0,
    .nm_filename = nullptr,
    .nm_register_func = Init,
    .nm_modname = "demoso",
    .nm_priv = ((void *)0),
    .reserved = {0},
};
extern "C" __attribute__((constructor)) void RegisterDemosoModule(void) { napi_module_register(&demoModule); }
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160831.11871937522609642304197052545344:50001231000000:2800:83295A7CE52D7B3B796D1836E2A9CD88D1212D429478EDF3DD6B8DC1B2BDA52A.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-72
爬取时间: 2025-05-08 04:40:28
来源: Huawei Developer


问题场景


有a、b两个module，b module中会编译出来一个so，如何在a module的Native侧集成b module编译出来的so？a module可能会依赖b module。


解决措施


操作步骤

1.  buildOption: { nativeLib: { headerPath: "src/main/cpp/include" } }
2.  // oh-package.json dependencies: { curl: "1.0.0" }
3.  target_link_libraries(entry PUBLIC curl::curl)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-73
爬取时间: 2025-05-08 04:40:37
来源: Huawei Developer


napi_env表示程序的运行状态和上下文信息。napi_env的值可能会在不同的调用上下文、执行环境、NAPI模块初始化或销毁以及多线程环境中发生变化，使用时应通过NAPI提供的接口安全地访问和操作执行环境。


禁止缓存napi_env的主要原因如下：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-77
爬取时间: 2025-05-08 04:40:47
来源: Huawei Developer


问题现象


将C++层分配的对象在ArkTS层管理，ArkTS层通过接口访问C++层对象业务。


解决措施


C++层分配一个class对象，将该对象的地址返回给ArkTS层，ArkTS层通过自定义的class对象中的一个number属性存储C++层返回的地址。后续ArkTS层的对象涉及到对C++层的对象业务处理时，会调用接口将C++层对象的地址传递到C++层处理。


可参考以下代码实现。


声明TestClass：


```less
class TestClass { 
public: 
    int GetValue() { 
        return this->value; 
    } 
    void SetValue(int value) { 
        this->value = value; 
    } 
private: 
    int value = 999; 
};
```


C++层将定义的对象地址返回到ArkTS层：


```less
#include "napi/native_api.h" 
#include "TestClass.h" 
#include "hilog/log.h" 
#define LOG_TAG "MY_TAG"  
 
static napi_value DefineObject(napi_env env, napi_callback_info info) { 
    OH_LOG_INFO(LOG_APP, "enter DefineObject"); 
     
    napi_value result; 
    auto a = new TestClass(); 
    int64_t addrValue = (int64_t)a; 
    napi_create_bigint_int64(env, addrValue, &result); 
    OH_LOG_INFO(LOG_APP, "end DefineObject, addrValue:%{public}ld", addrValue); 
    return result; 
}
```


C++层接收ArkTS层传递过来的对象地址完成业务：


```less
static napi_value CallObject(napi_env env, napi_callback_info info) { 
    OH_LOG_INFO(LOG_APP, "enter CallObject"); 
    size_t argc = 1; 
    napi_value args[1] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    int64_t addrValue = 0; 
    bool flag = false; 
    napi_get_value_bigint_int64(env, args[0], &addrValue, &flag); 
    TestClass *a = (TestClass *)addrValue; 
    OH_LOG_INFO(LOG_APP, "CallObject, addrValue:%{public}ld", addrValue); 
    OH_LOG_INFO(LOG_APP, "CallObject, value:%{public}d", a->GetValue()); 
    a->SetValue(888); 
    return nullptr; 
}
```


ArkTS侧调用接口：


```less
import testNapi from 'libentry.so'; 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'DefineObject'; 
  @State message2: string = 'CallObject'; 
  addr: number = 0; 
 
  build() { 
    Column() { 
        Button(this.message) 
          .fontSize(16) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            this.addr = testNapi.defineObject(); 
            console.log('testTag:' + this.addr.toString()); 
          }) 
        Button(this.message2) 
          .fontSize(16) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            if (this.addr != 0) { 
              testNapi.callObject(this.addr); 
              this.message2 = 'CallObject'; 
            } else { 
              this.message2 = 'want define Object'; 
            } 
          }) 
    } 
    .justifyContent(FlexAlign.Center) 
    .height('100%') 
    .width('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-78
爬取时间: 2025-05-08 04:40:57
来源: Huawei Developer


问题现象


如果har包的libc++和工程的libc++版本不一致的情况是隔离的吗？还是不能共存，只能使用一个？


解决措施


对于har包：


如果其ohpm版本为1.5及以上，当项目同时依赖了某个三方库的不同版本时，ohpm将选择其中的最高版本进行安装。可参考resolve_conflict。


对于sdk：


sdk中是否导入libc++的库是由各sdk打包时决定的。可能会存在不同的sdk中存在不同版本的libc++库。使用时可以指定链接对应的libc++库。


可以使用set(CMAKE_CXX_STANDARD xxx)的方式指定版本，具体可参考如何修改代码工程所支持的C++语言版本。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-79
爬取时间: 2025-05-08 04:41:07
来源: Huawei Developer


目前手机上不支持在C侧打开公共路径，只支持在ArkTS侧打开之后获取到fd，再把fd传入到C侧再打开。参考如下：


1. 将公共路径下的图片转存到沙箱目录：


```typescript
import { fileIo, picker } from '@kit.CoreFileKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
import testNapi from 'libentry.so'; 
 
@Entry 
@Component 
struct Index { 
  @State message: string = '打开文件'; 
 
  async open() { 
    const photoSelectOptions = new picker.PhotoSelectOptions(); 
    photoSelectOptions.MIMEType = picker.PhotoViewMIMETypes.IMAGE_TYPE; // 过滤选择媒体文件类型为IMAGE 
    photoSelectOptions.maxSelectNumber = 5; // 选择媒体文件的最大数目 
    let uris: Array<string> = []; 
    const photoViewPicker = new picker.PhotoViewPicker(); 
    await photoViewPicker.select(photoSelectOptions).then((photoSelectResult: picker.PhotoSelectResult) => { 
      uris = photoSelectResult.photoUris; 
      console.info('photoViewPicker.select to file succeed and uris are:' + uris); 
    }).catch((err: BusinessError) => { 
      console.error(`Invoke photoViewPicker.select failed, code is ${err.code}, message is ${err.message}`); 
    }) 
    let uri: string = uris[0]; 
    let file = fileIo.openSync(uri, fileIo.OpenMode.READ_ONLY); 
    console.info('file fd: ' + file.fd); 
    let fd = file.fd 
    let filesDir = getContext(this).filesDir; 
    fileIo.copyFileSync(fd, filesDir + '/test2.jpg') 
    let file2 = fileIo.openSync(filesDir + '/test2.jpg', fileIo.OpenMode.READ_ONLY); 
    let file3 = fileIo.openSync(filesDir + '/test3.jpg', fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE); 
    testNapi.ReadFile(file2.fd, file3.fd) 
  } 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
      } 
      .onClick(() => { 
        this.open(); 
      }) 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


2. native操作如下，将沙箱目录的test2复制到test3：


```less
static napi_value OpenFile(unsigned int fd, unsigned int fd2) { 
    OH_LOG_INFO(LOG_APP, "OpenFile"); 
 
    if (fd != -1) { 
        char buffer[4096]; 
        ssize_t bytesRead; 
        // 读取文件内容到缓冲区中 
        bytesRead = read(fd, buffer, sizeof(buffer)); 
        if (bytesRead == -1) { 
            OH_LOG_INFO(LOG_APP, "读取文件失败"); 
            close(fd); // 关闭文件描述符 
            return nullptr; 
        } 
        while (bytesRead != 0) { 
            OH_LOG_INFO(LOG_APP, "读取文件大小 %{public}lu", bytesRead); 
            OH_LOG_INFO(LOG_APP, "读取文件cg"); 
            char *pData1 = buffer; 
            OH_LOG_INFO(LOG_APP, "文件内容: \n%{public}s", pData1); 
            ssize_t bytesWrite; 
            bytesWrite = write(fd2, pData1, bytesRead); 
            if (bytesWrite == -1) { 
                OH_LOG_INFO(LOG_APP, "写文件失败"); 
                close(fd2); // 关闭文件描述符 
                return nullptr; 
            } 
            bytesRead = read(fd, buffer, sizeof(buffer)); 
        } 
        // 关闭文件描述符 
        close(fd); 
        close(fd2); // 关闭文件描述符 
    } 
    return nullptr; 
} 
static napi_value ReadFile(napi_env env, napi_callback_info info) { 
    size_t argc = 2; 
    napi_value args[2] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    unsigned int fd = -1; 
    napi_get_value_uint32(env, args[0], &fd); 
    unsigned int fd2 = -1; 
    napi_get_value_uint32(env, args[1], &fd2); 
    OpenFile(fd, fd2); 
    return nullptr; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-80
爬取时间: 2025-05-08 04:41:17
来源: Huawei Developer


解决措施


在进行Node-API调用时，引擎堆中的对象的句柄（handle）会作为napi_value返回，这些对象的生命期由这些句柄控制。并且对象的句柄会与一个scope相关联，默认情况下，scope的生命期与native方法调用的生命期相关联。因此，与这些句柄关联的对象将在native方法调用的生命期内保持存活状态。


许多情况下，句柄必须在比native方法更短或更长的生命期内保持有效。下面描述如何管理对象的生命周期。

1.  例如： 考虑一个for循环的方法，该循环遍历大型数组中的元素。在该方法中将会创建大量的句柄，消耗大量的资源。 为了处理这种情况，Node-API提供了建立新scope的能力，新创建的句柄（handle）将与该scope关联。一旦不再需要这些句柄，scope就可以“关闭”，与scope关联的任何句柄都将无效。打开/关闭scope的方法有 napi_open_handle_scope 和 napi_close_handle_scope。 Node-API中scope的层次结构是一个嵌套的层次结构，任何时候只有一个活动scope，所有新句柄都将在该作用域处于活动状态时与之关联； scope必须按打开的相反顺序关闭，在native方法中创建的所有scope必须在该方法返回之前关闭。 关于句柄的相关代码使用可参考：生命周期管理 在嵌套作用域时，有时来自内部作用域的句柄需要超出该作用域的寿命。为了支持这种情况，Node-API支持"escapable scope"，允许一个句柄提升（promoted），以便它逃离当前作用域，将句柄的寿命从当前作用域更改为外部作用域。用于打开/关闭"escapable scope"的方法有napi_open_escapable_handle_scope和napi_close_escapable_handle_scope。 提升句柄的请求是通过只能调用一次的napi_escape_handle发出的。
2.  Node-API提供了创建对象持久引用的方法，适用于多线程的开发场景。普通句柄（handle）的生命周期由作用域管理，作用域会在native侧函数结束之前关闭。而每个引用都有一个大于等于0的计数，计数为0的引用会被收集，通常称为“弱”引用；大于0的计数将不会被收集。 例如：创建了一个构造器，想要在需要使用的时候再创建实例，因此需要为该构造对象创建引用。 napi_ref：指向napi_value，允许用户管理napi_value值的生命周期。 napi_create_reference(napi_env env, napi_value value, uint32_t initial_refcount, napi_ref* result); 为napi_value对象创建一个引用，以延长其生命周期。调用者需要自己管理引用的生命周期。 napi_delete_reference(napi_env env, napi_ref ref); 删除传入的引用。 napi_reference_ref(napi_env env, napi_ref ref, uint32_t *result); 增加传入的引用的引用计数，并获取新的计数。 napi_reference_unref(napi_env env, napi_ref ref, uint32_t *result); 减少传入的引用的引用计数，并获取新的计数。 napi_get_reference_value(napi_env env, napi_ref ref, napi_value *result); 获取与引用相关联的napi_value对象。 关于引用相关接口的使用可以参考：异步任务开发

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-81
爬取时间: 2025-05-08 04:41:27
来源: Huawei Developer


C/C++没有OpenSSL的接口，ArkTS提供的有JS OpenSSL的接口。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-function-flow-runtime
爬取时间: 2025-05-08 04:41:36
来源: Huawei Developer

- 如何在Native侧C++子线程直接调用ArkTS接口，不用通过ArkTS侧触发回调
- ArkTS层调用Native层接口时的线程相关问题
- Native侧获取env具有线程限制，如何在C++子线程触发ArkTS侧回调
- 如何在C++调用从ArkTS传递过来的function
- 如何在Native侧调用ArkTS侧异步方法，并获取异步计算结果到Native侧
- Native侧代码与ArkTS侧的代码线程关系以及线程使用限制
- napi_env、napi_value实例是否可以跨worker线程共享
- Native如何创建子线程，有什么约束，与主线程如何通信
- 如何利用worker子线程调用napi实现loop改写变量
- Native侧的napi_env是否支持延迟调用或者异步调用

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-8
爬取时间: 2025-05-08 04:41:46
来源: Huawei Developer


当前版本仅支持在ArkTS侧触发Native方法后回调ArkTS接口。具体使用方法可参考链接


参考链接


Node-API典型使用场景


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-14
爬取时间: 2025-05-08 04:41:56
来源: Huawei Developer


问题详情


解决措施


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-25
爬取时间: 2025-05-08 04:42:06
来源: Huawei Developer


可以通过线程安全函数实现在C++子线程触发ArkTS侧回调。native主线程外的其他线程通常不能直接使用需要napi_env、napi_value的NAPI函数，线程安全函数可以在其他线程中被调用，并回到主线程中执行。参考代码如下：


在Native入口定义线程安全函数，计算两数之和。


```less
static napi_value AddTSFCallback(napi_env env, napi_callback_info info) { 
    // ...  
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    auto contextData = new ContextData; 
    contextData->args = strBuff; 
    // 创建线程安全函数对象，注册绑定callback和call_js_cb回调 
    napi_create_threadsafe_function(env, args[2], nullptr, asyncName, MAX_MSG_QUEUE_SIZE, INITIAL_THREAD_COUNT, nullptr,nullptr, nullptr, CallJsFunction, &tsFun); 
    thread t(AddFunc, static_cast<void *>(contextData));   // 创建C++子线程，处理业务逻辑 
    t.detach(); 
    return nullptr; 
} 
 
static void AddFunc([[maybe_unused]] napi_env env, void *data) { 
    ContextData *contextData = static_cast<ContextData *>(data);       // 解析上下文，业务处理，两数相加 
    contextData->result = add(contextData->num1, contextData->num2);   // 将结果置入上下 
    napi_call_threadsafe_function(tsFun, data, napi_tsfn_blocking);    // 调用线程安全函数 
} 
 
static void CallJsFunction(napi_env env, napi_value callBack, [[maybe_unused]] void *context, void *data) { 
    ContextData *contextData = static_cast<ContextData *>(data); 
    // ...  
    napi_value callBackArgs = nullptr; 
    napi_create_double(env, contextData->result, &callBackArgs); 
    napi_value callBackResult = nullptr; 
    napi_call_function(env, undefined, callBack, 1, &callBackArgs, &callBackResult);    // 调用callback，反馈结果到ArkTS应用侧 
    DeleteContext(env, contextData); 
}
```


ArkTS侧调用接口。


```typescript
import testNapi from 'libentry.so'; 
@Entry 
@Component 
struct Index { 
  // ... 
  .onClick(() => { 
    testNapi.addTSFCallback(2, 3, (nativeResult: number) => { 
      this.result = nativeResult; 
    }); 
  }) 
  // ... 
}
```


参考链接


使用Node-API接口进行线程安全开发


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-26
爬取时间: 2025-05-08 04:42:15
来源: Huawei Developer

1.  export const nativeCallArkTS: (a: object) => number;

```less
static napi_value NativeCallArkTS(napi_env env, napi_callback_info info) 
{     
    size_t argc = 1; 
    // 声明参数数组 
    napi_value args[1] = {nullptr}; 
 
    // 获取传入的参数并依次放入参数数组中 
    napi_get_cb_info(env, info, &argc, args , nullptr, nullptr); 
 
    // 创建一个int，作为ArkTS的入参 
    napi_value argv = nullptr;     
    napi_create_int32(env, 2, &argv ); 
 
    // 调用传入的callback，并将其结果返回 
    napi_value result = nullptr; 
    napi_call_function(env, nullptr, args[0], 1, &argv, &result); 
    return result; 
}
```


```typescript
// entry/src/main/ets/pages/Index.ets 
// 通过import的方式，引入Native能力。 
import nativeModule from 'libentry.so' 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Test Node-API nativeCallArkTS result: '; 
  build() { 
    Row() { 
      Column() { 
        // 调用nativeCallArkTS方法，对应到Native的NativeCallArkTS，在Native调用ArkTS function。 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            this.message += nativeModule.nativeCallArkTS((a: number)=> { 
                return a * 2; 
            }); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


Native侧方法的实现


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-32
爬取时间: 2025-05-08 04:42:25
来源: Huawei Developer


该场景诉求可以通过在Native侧获取ArkTS侧Promise对象来实现。具体步骤如下：

- ArkTS侧实现：调用Native接口时，传入callback回调。在该回调中通过构造函数创建Promise对象；在Promise构造函数的参数回调中，实现异步操作，并根据操作结果，调用resolve或者reject接口，用以对Promise对象进行状态迁移。
- 调用Native接口时，传入callback回调。在该回调中通过构造函数创建Promise对象；
- 在Promise构造函数的参数回调中，实现异步操作，并根据操作结果，调用resolve或者reject接口，用以对Promise对象进行状态迁移。
- Native侧实现：定义Promise对象then属性的回调方法，用以处理ArkTS侧异步计算结果；定义Promise对象catch属性的回调方法，用以处理ArkTS侧异步计算异常信息；在Native接口实现中，通过napi_call_function接口执行ArkTS侧传入的callback回调，获取Promise对象；通过napi_get_named_property接口获取Promise对象中的then和catch属性；通过napi_create_function接口将上述定义的then和catch属性C++回调方法转换为ArkTS函数对象；通过napi_call_function接口执行then和catch属性对应ArkTS函数对象，用以处理ArkTS侧的异步计算结果和异常信息。类似于在ArkTS侧调用promise.then(()=>{}和promise.catch(()=>{}。
- 定义Promise对象then属性的回调方法，用以处理ArkTS侧异步计算结果；
- 定义Promise对象catch属性的回调方法，用以处理ArkTS侧异步计算异常信息；
- 在Native接口实现中，通过napi_call_function接口执行ArkTS侧传入的callback回调，获取Promise对象；
- 通过napi_get_named_property接口获取Promise对象中的then和catch属性；
- 通过napi_create_function接口将上述定义的then和catch属性C++回调方法转换为ArkTS函数对象；
- 通过napi_call_function接口执行then和catch属性对应ArkTS函数对象，用以处理ArkTS侧的异步计算结果和异常信息。类似于在ArkTS侧调用promise.then(()=>{}和promise.catch(()=>{}。

具体可参考以下示例代码：


（一）ArkTS侧实现


```typescript
// ... 
import testNapi from 'libentry.so'; 
 
@Entry 
@Component 
struct Index { 
  build() { 
    Row() { 
      Column() { 
        Text('testPromise') 
          // ... 
          .onClick(() => { 
            hilog.info(0x0000, 'testTag-ArkTS', 'Before calling the native interface.'); 
            // 调用Native接口，返回调用信息 
            testNapi.testPromise(() => { 
                // callback回调用于创建ArkTS侧Promise对象 
                return new Promise((resolve: Function, reject: Function) => { 
                  // 通过setTimeout接口模拟ArkTS侧异步方法 
                  // 场景：2秒后，触发setTimeout定时器回调，生产一个随机数randomNumber，通过判断随机数的大小，用于触发promise对象不同状态，继而进行不同回调处理 
                  setTimeout(()=>{ 
                    const randomNumber: number = 100 * Math.random(); 
                    if (randomNumber > 50) { 
                      // 如果randomNumber大于50，则调用resolve方法，将Promise对象的状态转移到fulfilled状态，并将随机数传递到Native侧，作为then方法的回调参数 
                      resolve(randomNumber); 
                    } else { 
                      // 如果randomNumber小于/等于50，则调用reject方法，将Promise对象的状态转移到rejected状态，并将异常信息传递到Native侧，作为catch方法的回调参数 
                      reject('The random number is less than 50, so the promise object is rejected.') 
                    } 
                  }, 2000); 
                }) 
              } 
            ) 
            hilog.info(0x0000, 'testTag-ArkTS', 'After the native interface is called.'); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


（二）Native侧实现


```less
#include "napi/native_api.h" 
#include "hilog/log.h" 
 
// 定义Promise对象then属性的回调方法 
// then属性的回调方法可以无返回值 
// 后文需要通过napi_create_function创建ArkTS函数对象，所以设置返回值为napi_value，并在函数末尾返回nullptr 
napi_value ThenCallBack(napi_env env, napi_callback_info info) { 
    size_t argc = 1; 
    napi_value args[1] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    int32_t asyncResult = 0; // ArkTS侧异步方法计算结果 
    napi_get_value_int32(env, args[0], &asyncResult); 
    OH_LOG_Print(LOG_APP, LOG_INFO, 0xFF00, "testTag-Native", "ArkTS Async Method Calculation Success, Result: %{public}d", 
                 asyncResult); 
    return nullptr; 
} 
// 定义Promise对象catch属性的回调方法 
// catch属性的回调方法可以无返回值 
// 后文需要通过napi_create_function创建ArkTS函数对象，所以设置返回值为napi_value，并在函数末尾返回nullptr 
napi_value CatchCallBack(napi_env env, napi_callback_info info) { 
    size_t argc = 1; 
    napi_value args[1] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    size_t strLen = 0; 
    napi_get_value_string_utf8(env, args[0], nullptr, 0, &strLen);            // 获取字符串长度到strLen 
    char *strBuffer = new char[strLen + 1];                                   // 分配合适大小的char数组 
    napi_get_value_string_utf8(env, args[0], strBuffer, strLen + 1, &strLen); // 获取字符串，表示ArkTS侧异步方法计算异常的信息 
    OH_LOG_Print(LOG_APP, LOG_INFO, 0xFF00, "testTag-Native", 
                 "ArkTS Async Method Calculation Exception: %{public}s", strBuffer); 
    return nullptr; 
} 
static napi_value TestPromise(napi_env env, napi_callback_info info) { 
    size_t argc = 1; 
    napi_value args[1] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); // 解析ArkTS侧传入的回调callback 
 
    napi_value arktsPromise = nullptr; 
    // 通过napi_call_function执行callback，返回ArkTS侧创建的promise对象 
    napi_call_function(env, nullptr, args[0], 0, nullptr, &arktsPromise); 
 
    // 获取promise对象的then属性，该属性的回调方法用于处理ArkTS侧异步计算结果 
    napi_value thenProperty = nullptr; 
    napi_get_named_property(env, arktsPromise, "then", &thenProperty); 
    // 将C++语言定义的then属性回调方法转换为ArkTS函数对象，即napi_value类型值 
    napi_value thenCallback = nullptr; 
    napi_create_function(env, "thenCallback", NAPI_AUTO_LENGTH, ThenCallBack, nullptr, &thenCallback); 
 
    // 获取promise对象的catch属性，该属性的回调方法用于处理ArkTS侧异步计算异常的信息 
    napi_value catchProperty = nullptr; 
    napi_get_named_property(env, arktsPromise, "catch", &catchProperty); 
    // 将C++语言定义的catch属性回调方法转换为ArkTS函数对象，即napi_value类型值 
    napi_value catchCallback = nullptr; 
    napi_create_function(env, "catchCallback", NAPI_AUTO_LENGTH, CatchCallBack, nullptr, &catchCallback); 
     
    // 通过napi_call_function执行then属性的回调，类似于ArkTS侧调用promise.then(()=>{}) 
    napi_call_function(env, arktsPromise, thenProperty, 1, &thenCallback, nullptr); 
    // 通过napi_call_function执行catch属性的回调，类似于ArkTS侧调用promise.catch(()=>{}) 
    napi_call_function(env, arktsPromise, catchProperty, 1, &catchCallback, nullptr); 
    return nullptr; 
}
```


运行结果

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160831.77808927418059376953804784396059:50001231000000:2800:308D5F335D3F1FAF521626458360D8D2AFAC9FC012016CADE836C7D745B5AA90.png)
- 结果（1）：表示ArkTS侧调用Native接口后，Native侧运行并未阻塞，直接返回。
- 结果（2）：表示ArkTS侧调用Native接口后，等待2秒（异步计算），因为异步操作中生产的随机数小于等于50，所以通过Promise对象的reject接口传入异常信息到Native侧，并通过catch回调进行显示处理。
- 结果（3）：表示ArkTS侧调用Native接口后，等待2秒（异步计算），因为异步操作中生产的随机数大于50，所以通过Promise对象的resolve接口传入随机数到Native侧，并通过then回调进行显示处理。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-54
爬取时间: 2025-05-08 04:42:35
来源: Huawei Developer


问题现象


解决措施


应用侧调用的ArkTS接口代码与Native接口代码均运行在ArkTS主线程中。在Native侧用户可以抛任务到TaskPool线程池中，TaskPool内部会根据硬件条件、任务负载等情况动态调整线程数量，以确保高优先级任务的及时执行。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-55
爬取时间: 2025-05-08 04:42:45
来源: Huawei Developer


问题现象


napi_env、napi_value这些实例跨worker应该都是不共享的吧？如果在Native侧静态持有这些对象，而且主线程和worker都会走到这段逻辑的话，那napi_env、napi_value不是会乱掉吗？


解决措施


napi_env、napi_value等实例在不同的worker中是不共享的。如果在C++ 中静态持有这些对象，并且主线程和worker都会访问这些对象，会出现混乱的情况。为了避免这种情况，建议在每个worker中使用独立的napi_env、napi_value等实例，而不是在C++ 代码中静态持有它们。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-68
爬取时间: 2025-05-08 04:42:54
来源: Huawei Developer


请参照下面的代码，通过C++子线程调用arkts侧的函数：


```less
#include "napi/native_api.h" 
#include "hilog/log.h" 
#include "thread" 
 
napi_ref cbObj = nullptr; 
napi_threadsafe_function tsfn; 
#define NUMBER 666 
static void CallJs(napi_env env, napi_value js_cb, void *context, void *data) { 
    napi_get_reference_value(env, cbObj, &js_cb); 
    napi_value argv; 
    napi_create_int32(env, NUMBER, &argv); 
    napi_value result = nullptr; 
    napi_call_function(env, nullptr, js_cb, 1, &argv, &result); 
} 
static napi_value ThreadsTest(napi_env env, napi_callback_info info) { 
    size_t argc = 1; 
    napi_value js_cb, work_name; 
    napi_status status; 
    status = napi_get_cb_info(env, info, &argc, &js_cb, nullptr, nullptr); 
    OH_LOG_INFO(LOG_APP, "ThreadSafeTest 0: %{public}d", status == napi_ok); 
    // Set initial_refcount to 0 for a weak reference, >0 for a strong reference. 
    status = napi_create_reference(env, js_cb, 1, &cbObj); 
    OH_LOG_INFO(LOG_APP, "napi_create_reference of js_cb to cbObj: %{public}d", status == napi_ok); 
    status = napi_create_string_utf8(env, "Work Item", NAPI_AUTO_LENGTH, &work_name); 
    status = napi_create_threadsafe_function(env, js_cb, NULL, work_name, 0, 1, NULL, NULL, NULL, CallJs, &tsfn); 
    OH_LOG_INFO(LOG_APP, "napi_create_threadsafe_function : %{public}d", status == napi_ok); 
    std::thread t([]() { 
        std::thread::id this_id = std::this_thread::get_id(); 
        OH_LOG_INFO(LOG_APP, "thread0 %{public}d.\n", this_id); 
        napi_status status; 
        status = napi_acquire_threadsafe_function(tsfn); 
        OH_LOG_INFO(LOG_APP, "thread : %{public}d", status == napi_ok); 
        napi_call_threadsafe_function(tsfn, NULL, napi_tsfn_blocking); 
    }); 
    t.detach(); 
    return NULL; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-76
爬取时间: 2025-05-08 04:43:04
来源: Huawei Developer


问题现象


在某些特定场景，需要用napi的loop完成消息循环，但是又不想阻塞UI主线程。


解决措施


可参考以下代码实现。


ArkTS侧：


创建worker并监听：


```typescript
import { MessageEvents, worker } from '@kit.ArkTS'; 
import { Prompt } from '@kit.ArkUI'; 
 
@Entry 
@Component 
struct Index { 
  @State progress: number = 0; 
  @State message: string = '0' 
  state: number = 0 
 
  build() { 
    Column() { 
      Row() { 
        Button("开始") 
          .fontSize(40) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            if (this.state == 1) { 
              Prompt.showToast({ message: "请勿重复点击" }) 
              return 
            } 
            this.state = 1 
            let worker1: worker.ThreadWorker = 
              new worker.ThreadWorker('entry/ets/workers/Worker.ets', { name: "worker1" }); 
            worker1.postMessage('this is a msg to start worker1'); 
            worker1.onmessage = (e: MessageEvents) => { 
              this.progress = e.data.data as number 
              this.message = String(this.progress) 
              console.log('=====js main, process is:' + this.message) 
 
              if (this.progress == 100) { 
                worker1.terminate() 
                this.state = 0 
              } 
            } 
          }); 
      } 
      .margin({ 
        top: 10, 
        bottom: 10, 
        left: 5, 
        right: 5 
      }) 
 
      Row() { 
        Text(this.message) 
          .fontSize(50) 
      } 
      .margin({ 
        top: 10, 
        bottom: 5, 
        left: 5, 
        right: 5 
      }) 
    } 
  } 
}
```


在worker中调用napi函数：


```less
import { ErrorEvent, MessageEvents, ThreadWorkerGlobalScope, worker } from '@kit.ArkTS'; 
import testNapi from 'libentry.so'; 
 
const workerPort: ThreadWorkerGlobalScope = worker.workerPort; 
 
workerPort.onmessage = (e: MessageEvents) => { 
  testNapi.mainThread((data:ESObject)=>{ 
    console.log("==worker func:data is :" + data); 
    workerPort.postMessage({ 'type': 1, "data": data }); 
  }); 
}
```


Native侧：


在Native侧利用loop完成消息循环：


```less
struct CallbackContext { 
    napi_env env = nullptr; 
    napi_ref callbackRef = nullptr; 
    int retData = 0; 
};
```


```less
#include "WorkerCallNapiLoop.h" 
#include <thread> 
#include <uv.h> 
 
void WorkerCallNapiLoop::SubThread(CallbackContext *context) { 
    uv_loop_s *loop = nullptr; 
    napi_get_uv_event_loop(context->env, &loop); 
    // uv_work_t 是关联 loop 和 线程池回调函数的结构体 
    uv_work_t *work = new uv_work_t; 
    work->data = (CallbackContext *)context; 
    uv_queue_work( 
        loop, work, [](uv_work_t *work) {}, 
        [](uv_work_t *work, int status) { 
            CallbackContext *context = (CallbackContext *)work->data; 
            napi_handle_scope scope = nullptr; 
            // 管理 napi_value 的生命周期，防止内存泄露 
            napi_open_handle_scope(context->env, &scope); 
            if (scope == nullptr) { 
                return; 
            } 
            napi_value callback = nullptr; 
            napi_get_reference_value(context->env, context->callbackRef, &callback); 
            while (context->retData < 100) { 
                context->retData += 1; 
                napi_value retArg; 
                napi_create_int32(context->env, context->retData, &retArg); 
                napi_value ret; 
                napi_call_function(context->env, nullptr, callback, 1, &retArg, &ret); 
                std::this_thread::sleep_for(std::chrono::milliseconds(100)); 
            } 
            napi_close_handle_scope(context->env, scope); 
            if (context->retData > 99) { 
                napi_delete_reference(context->env, context->callbackRef); 
                if (work != nullptr) { 
                    delete work; 
                } 
            } 
        }); 
}; 
napi_value WorkerCallNapiLoop::MainThread(napi_env env, napi_callback_info info) { 
        size_t argc = 1; 
    napi_value args[1] = {0}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    auto asyncContext = new CallbackContext(); 
    asyncContext->env = env; 
    napi_create_reference(env, args[0], 1, &asyncContext->callbackRef); 
    auto func = [](void *asyncContext) { 
        delete asyncContext; 
    }; 
    napi_add_env_cleanup_hook(asyncContext->env, func, asyncContext); 
    uv_loop_s *loop = nullptr; 
    napi_get_uv_event_loop(env, &loop); 
    // 启动子线程 
    std::thread testThread(SubThread, asyncContext); 
    testThread.detach(); 
    return nullptr; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-75
爬取时间: 2025-05-08 04:43:13
来源: Huawei Developer


问题现象


解决措施


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-jsvm
爬取时间: 2025-05-08 04:43:23
来源: Huawei Developer

- 如何管理JSVM_CallbackStruct生命周期
- 如何自排查_Bool类型没有找到的编译问题
- 如何正确使用OH_JSVM_Init
- 如何自排查OOM(v8::FatalProcessOutOfMemory)错误
- 如何正确使用OH_JSVM_GetValueStringUtf8获取字符串
- 如何解决Finalizer方法中执行JS代码崩溃问题
- 如何解决应用运行时OH_JSVM_CreateVM多线程创建发生竞争，导致VM内部的成员变量（array_buffer_allocator_）内存异常应用退出问题

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-jsvm-1
爬取时间: 2025-05-08 04:43:33
来源: Huawei Developer


问题现象


可能原因


由OH_JSVM_CreateFunction创建的Javascript函数，在使用时出现应用崩溃的问题，大概率是由于JSVM_CallbackStruct生命周期管理不正确，错误代码示例如下：


```less
JSVM_Value CreateFunction(JSVM_Env env) {
    JSVM_CallbackStruct callbackStruct;
    callbackStruct.data = nullptr;
    callbackStruct.callback = [](JSVM_Env env, JSVM_CallbackInfo info) -> JSVM_Value {
        return nullptr;
    };


    JSVM_Value result = nullptr;
    OH_JSVM_CreateFunction(env, "foo", JSVM_AUTO_LENGTH, &callbackStruct, &result);
    return result;
}
void SomeFunction() {
    char stack[] = "hello world";
}
```


当执行以下代码（省略了打开虚拟机的步骤），应用程序会崩溃。


```less
// ...


auto func = CreateFunction(env);
SomeFunction();


JSVM_Value undef = nullptr;
OH_JSVM_GetUndefined(env, &undef);


JSVM_Value result;
OH_JSVM_CallFunction(env, undef, func, 0, nullptr, &result);


// ...
```


在OH_JSVM_CallFunction时，callbackStruct为栈上变量，OH_JSVM_CreateFunction参数接收了栈内存地址（&callbackStruct）。调用SomeFunction后，栈内存被修改。在OH_JSVM_CallFunction中，执行JSVM_CallbackStruct中的回调函数，由于JSVM_CallbackStruct的内存被修改，造成了非法内存访问，应用崩溃。


解决措施


如果用OH_JSVM_CreateFunction创建的Javascript函数需要跨函数使用，JSVM_CallbackStruct要从堆上申请，并且在Javascript函数失效前不能被释放。JSVM_CallbackStruct的释放可以交给虚拟机垃圾回收。通过调用OH_JSVM_AddFinalizer，可以给Javascript函数设置Finalize方法，当Javascript函数被垃圾回收后，Finalize方法会被调用，同时释放JSVM_CallbackStruct。示例如下：


```less
JSVM_Value CreateFunction(JSVM_Env env) {
    JSVM_Callback cb = new JSVM_CallbackStruct;
    cb->data = nullptr;
    cb->callback = [](JSVM_Env env, JSVM_CallbackInfo info) -> JSVM_Value { return nullptr; };


    JSVM_Value result = nullptr;
    OH_JSVM_CreateFunction(env, "foo", JSVM_AUTO_LENGTH, cb, &result);
    OH_JSVM_AddFinalizer(
        env, result, reinterpret_cast<void *>(cb),
        [](JSVM_Env env, void *data, void *hint) -> void { 
            delete static_cast<JSVM_Callback>(data);
        }, nullptr, nullptr);


    return result;
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-jsvm-2
爬取时间: 2025-05-08 04:43:43
来源: Huawei Developer


问题现象


构建HAP工程时，编译工具报错：“error: unknown type name '_Bool'”，找不到_Bool类型错误，如下所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160832.41428992902847360832032140198564:50001231000000:2800:96C236CCC47541BB03C68837DB9E324220685364395381D35200B46A253CE422.png)

可能原因


JSVM-API提供的是基于C99标准的C-API，在C++工程中使用时需要注意与C-API的兼容性。


当前版本OpenHarmony SDK提供的C++编译工具链clang++的选项默认配置为-std=gnu++14，当额外指定-std=c++xx时会覆盖默认配置，此时Clang会指定strict ANSI的编译宏，这在C语言层面对应C90的标准，不包含GNU C的任何扩展，因此不兼容C99标准引入的_Bool。而-std=gnu++xx系列选项会使能对于GNU C扩展的支持，此时就不会产生编译报错。


解决措施


可以排查构建工程中的构建选项里有没有添加-std=c++xx系列的选项（xx可能为11，14，17等)。


如果存在，那么有以下三种方案可以解决这个问题：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-jsvm-3
爬取时间: 2025-05-08 04:43:52
来源: Huawei Developer


问题现象


同一个进程中OH_JSVM_Init多次调用会产生错误，导致fatal error从而触发abort，表现为cppcrash。


解决措施


函数OH_JSVM_Init会触发init机制，存在一个状态机处理init的状态。当一个进程在退出之前调用过OH_JSVM_Init之后，再次调用就会产生crash，需要增加当前进程是否已经init过的判断。如下面的代码所示，包装一个函数进行实际的OH_JSVM_Init调用，这样即使重复调用Init也不会产生问题。


```less
#include "jsvm_types.h"
#include "jsvm.h"


void Init(const JSVM_InitOptions* options) {
  static bool initialized = false;
  if (initialized) {
    return;
  }
  OH_JSVM_Init(options);
  initialized = true;
}
int main() {
  Init(nullptr);
  Init(nullptr);
}
```


通过上面的形式判断是否已经调用过OH_JSVM_Init，即可防止重复调用引起的crash。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-jsvm-4
爬取时间: 2025-05-08 04:44:02
来源: Huawei Developer


问题现象


当应用内部申请的内存达到v8内存上限时，会触发OOM(v8::FatalProcessOutOfMemory)问题。对应的Crash栈信息如下:


#00 pc 0000000001d28a24 /system/lib64/ndk/libjsvm.so(v8::base::OS::Abort()+28)#01 pc 00000000014102c0 /system/lib64/ndk/libjsvm.so(v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, v8::OOMDetails const&)+756)#02 pc 0000000001629960 /system/lib64/ndk/libjsvm.so(v8::internal::Heap::FatalProcessOutOfMemory(char const*)+28)#03 pc 00000000016284a4 /system/lib64/ndk/libjsvm.so(v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags)+2100)#04 pc 000000000161df8c /system/lib64/ndk/libjsvm.so(v8::internal::HeapAllocator::AllocateRawWithLightRetrySlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment)+1952)#05 pc 000000000161e810 /system/lib64/ndk/libjsvm.so(v8::internal::HeapAllocator::AllocateRawWithRetryOrFailSlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment)+68)#06 pc 0000000001602744 /system/lib64/ndk/libjsvm.so(v8::internal::Factory::AllocateRaw(int, v8::internal::AllocationType, v8::internal::AllocationAlignment)+724)#07 pc 00000000015f41dc /system/lib64/ndk/libjsvm.so(v8::internal::FactoryBase<v8::internal::Factory>::NewFixedArray(int, v8::internal::AllocationType)+96)#08 pc 00000000017e8698 /system/lib64/ndk/libjsvm.so#09 pc 00000000018d86a4 /system/lib64/ndk/libjsvm.so(v8::internal::Object::CreateListFromArrayLike(v8::internal::Isolate*, v8::internal::Handle<v8::internal::Object>, v8::internal::ElementTypes)+1168)#10 pc 0000000001a0dd9c /system/lib64/ndk/libjsvm.so(v8::internal::Runtime_CreateListFromArrayLike(int, unsigned long*, v8::internal::Isolate*)+48)#11 pc 0000000000f6d0b4 /system/lib64/ndk/libjsvm.so(Builtins_CEntry_Return1_ArgvOnStack_NoBuiltinExit+84)#12 pc 0000000000eddbac /system/lib64/ndk/libjsvm.so(Builtins_CallWithArrayLike+812)


解决措施


在OH_JSVM_Init中传入'max-semi-space-size'和'max-old-space-size'(单位均为 MB)的设置参数，扩大v8的内存上限。观测扩大v8内存上限之后，应用是否仍会crash。如果仍会crash，则需要借助内存泄漏检测手段来排查应用中是否存在内存泄漏问题。


```less
// ...
JSVM_InitOptions init_options;
init_options.argc = (int*)malloc(sizeof(int));
*init_options.argc = 3;
init_options.argv = (char**)malloc(3 * sizeof(char*));
init_options.argv[1] = "--max-semi-space-size=1024";
init_options.argv[2] = "--max-old-space-size=1024";
init_options.removeFlags = true;
init_options.externalReferences = nullptr;
      
JSVM_Status status = OH_JSVM_Init(&init_options);


if (status != JSVM_OK)  {
  // 若status不为JSVM_OK，则表明OH_JSVM_Init执行失败，init_options也并未设置成功。
}
// ...
```


JSVM中，内存默认值如下：

- max_semi_space_size: 16MB
- max_old_space_size: 1400MB
- initial_semispace_size: 1MB
- initial_old_space_size: 512MB

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-jsvm-5
爬取时间: 2025-05-08 04:44:12
来源: Huawei Developer


问题现象


解决措施


函数OH_JSVM_GetValueStringUtf8的第三个参数为字符串写入的内存地址，当该参数传入空指针时，该接口通过最后一个参数result返回字符串的长度（不包含终止符长度）。


```less
JSVM_EXTERN JSVM_Status OH_JSVM_GetValueStringUtf8(JSVM_Env env,
                                                   JSVM_Value value,
                                                   char* buf,
                                                   size_t bufsize,
                                                   size_t* result);
```


获取字符串可分为以下三步：


```less
std::string GetValueString(JSVM_Env env, JSVM_Value value) {
    constexpr size_t PREALLOC_SIZE = 256;
    char preallocMemory[PREALLOC_SIZE];


    char *buff = preallocMemory;
    
    // 获取长度
    size_t totalLen = 0;
    OH_JSVM_GetValueStringUtf8(env, value, nullptr, 0, &totalLen);
    size_t needed = totalLen + 1;


    if (needed > PREALLOC_SIZE) {
        // 分配空间，大小需包含终止字符
        buff = new char[needed];
    }
    // 获取字符串
    OH_JSVM_GetValueStringUtf8(env, value, buff, needed, nullptr);


    std::string ret(buff, totalLen);


    if (needed > PREALLOC_SIZE) {
        delete[] buff;
    }
    return ret;
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-jsvm-6
爬取时间: 2025-05-08 04:44:22
来源: Huawei Developer


问题现象


崩溃调用栈如下：


```less
#00 pc 0000000001d2cfa8 /system/lib64/ndk/libjsvm.so(v8::base::OS::Abort()+28)
#01 pc 0000000001d21bfc /system/lib64/ndk/libjsvm.so(V8_Fatal(char const*, ...)+384)
#02 pc 000000000159ba30 /system/lib64/ndk/libjsvm.so(v8::internal::(anonymous namespace)::Invoke(v8::internal::Isolate*, v8::internal::(anonymous namespace)::InvokeParams const&)+2952)
#03 pc 000000000159ae24 /system/lib64/ndk/libjsvm.so(v8::internal::Execution::Call(v8::internal::Isolate*, v8::internal::Handle<v8::internal::Object>, v8::internal::Handle<v8::internal::Object>, int, v8::internal::Handle<v8::internal::Object>*)+96)
#04 pc 0000000001432154 /system/lib64/ndk/libjsvm.so(v8::Function::Call(v8::Local<v8::Context>, v8::Local<v8::Value>, int, v8::Local<v8::Value>*)+384)
#05 pc 0000000000c6e3e0 /system/lib64/ndk/libjsvm.so(OH_JSVM_CallFunction+348)
........
#24 pc 0000000000c77df8 /system/lib64/ndk/libjsvm.so(JSVM_Env__::CallFinalizer(void (*)(JSVM_Env__*, void*, void*), void*, void*)+96)
#25 pc 0000000000c65f5c /system/lib64/ndk/libjsvm.so(non-virtual thunk to v8impl::Reference::Finalize()+108)
#26 pc 0000000000c65fdc /system/lib64/ndk/libjsvm.so(v8impl::Reference::WeakCallback(v8::WeakCallbackInfo<v8impl::Reference> const&)+76)
```


原因分析


目前JSVM注册的Finalizer方法中不允许JS代码的执行，在上述崩溃调用栈中，Finalizer方法中调用了OH_JSVM_CallFunction执行了JS代码。


解决措施


Finalizer中，只进行和JS对象生命周期绑定对象的清理，不调用JSVM API。如需实现JS对象生命周期结束后执行一段JS代码的功能，可在Finalizer方法中，将相关代码的执行加入到外层事件循环队列中，等待下次事件循环时调用相关代码，从而实现时间序列上的先后顺序。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-jsvm-7
爬取时间: 2025-05-08 04:44:32
来源: Huawei Developer


问题现象


崩溃调用栈如下：


```less
#00 pc 00000000017793f8 /system/lib64/ndk/libjsvm.so
#01 pc 000000000163cef4 /system/lib64/ndk/libjsvm.so(v8::internal::Heap::AllocateExternalBackingStore(std::__h::function<void* (unsigned long)> const&, unsigned long)+212)
#02 pc 0000000001777454 /system/lib64/ndk/libjsvm.so(v8::internal::BackingStore::Allocate(v8::internal::Isolate*, unsigned long, v8::internal::SharedFlag, v8::internal::InitializedFlag)+220)
#03 pc 000000000149e420 /system/lib64/ndk/libjsvm.so
#04 pc 000000000149d99c /system/lib64/ndk/libjsvm.so(v8::internal::Builtin_ArrayBufferConstructor(int, unsigned long*, v8::internal::Isolate*)+260)
#05 pc 0000000000f75984 /system/lib64/ndk/libjsvm.so(Builtins_CEntry_Return1_ArgvOnStack_BuiltinExit+100)
#06 pc 0000000000ee6e40 /system/lib64/ndk/libjsvm.so(Builtins_JSBuiltinsConstructStub+320)
#07 pc 000000000102eae4 /system/lib64/ndk/libjsvm.so(Builtins_ConstructHandler+644)
#08 pc 0000000000ee9b88 /system/lib64/ndk/libjsvm.so(Builtins_InterpreterEntryTrampoline+264)
#09 pc 0000000000ee9b88 /system/lib64/ndk/libjsvm.so(Builtins_InterpreterEntryTrampoline+264)
```


原因分析


从调用栈分析错误发生在 libjsvm.so 库中的 v8::internal::Heap::AllocateExternalBackingStore 函数。该函数尝试分配外部存储时，调用了 allocate 函数，并且在 allocate 函数中出现了空指针异常。


反解定位报错在 src\heap\heap.cc：3112行的 allocate 函数调用 void* result = allocate(byte_length);，其所在函数 AllocateExternalBackingStore 调用点 src\objects\backing-store.cc：


```less
std::unique_ptr<BackingStore> BackingStore::Allocate(
    Isolate* isolate, size_t byte_length, SharedFlag shared,
    InitializedFlag initialized) {
  ...
  auto allocator = isolate->array_buffer_allocator();
  ...
  auto allocate_buffer = [allocator, initialized](size_t byte_length) {
      if (initialized == InitializedFlag::kUninitialized) {
        return allocator->AllocateUninitialized(byte_length);
      }
      void* buffer_start = allocator->Allocate(byte_length);
      if (buffer_start) {
        // TODO(wasm): node does not implement the zero-initialization API.
        // Reenable this debug check when node does implement it properly.
        constexpr bool
            kDebugCheckZeroDisabledDueToNodeNotImplementingZeroInitAPI = true;
        if ((!(kDebugCheckZeroDisabledDueToNodeNotImplementingZeroInitAPI)) &&
            !v8_flags.mock_arraybuffer_allocator) {
          DebugCheckZero(buffer_start, byte_length);
        }
      }
      return buffer_start;
  };
  buffer_start = isolate->heap()->AllocateExternalBackingStore(
      allocate_buffer, byte_length);
  ...
}
```


根据代码逻辑推断出错误的根本原因是 allocator 为空。allocator 是由 Isolate 的 array_buffer_allocator() 方法返回的，而 Isolate 是在 OH_JSVM_CreateVM 函数中通过 v8::Isolate::New(create_params) 创建的。因此，array_buffer_allocator 的初始化过程可能存在问题。array_buffer_allocator 是在 OH_JSVM_CreateVM 函数中通过 GetOrCreateDefaultArrayBufferAllocator() 创建的。如果在多线程环境下，多个线程同时调用 OH_JSVM_CreateVM 函数，可能会导致 array_buffer_allocator 的创建过程出现竞争条件，从而引发内存异常。


所以根因为多线程环境下 OH_JSVM_CreateVM 函数的调用导致了 array_buffer_allocator 的创建过程出现竞争条件，进而使得 allocator 对象为空，最终 AllocateExternalBackingStore 函数中引发了空指针异常。


解决措施


应用方处理，加锁解决，确保 OH_JSVM_CreateVM 调用期间，其他线程无法同时进入该代码块，确保每次只有一个线程可以创建VM实例，从而避免竞争关系。示例如下：


```less
// Create an instance of JSVM.
const JSVM_CreateVMOptions* options = new JSVM_CreateVMOptions();
JSVM_Status res = USVM_OK;
{
  std::Lock_guard<std::mutex> Lock(create_jsym_mutex_);
  res = OH_JSVM_CreateVM(options, &vm_);
}
if (res != JSVN_OK vm_ == nullptr) {
  XLOG(ERROR) << "JSVM create vm failed";
}
// When we start, open vm scope.
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui
爬取时间: 2025-05-08 04:44:42
来源: Huawei Developer

- 方舟UI框架（ArkUI）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-kit
爬取时间: 2025-05-08 04:44:51
来源: Huawei Developer

- Image组件加载的图片，如何缓解图片在缩放时的锯齿问题
- 如何实现防截屏功能
- 如何在长按手势回调方法里获取手指触摸点的坐标
- 如何自定义Tabs页签导航栏及其对齐方式
- 如何封装一个自定义弹窗
- 如何在可滚动的容器组件中实现曝光埋点
- 如何给UI组件设置不同情况下的属性
- 如何在Navigation跳转页面时返回传参
- TextInput组件获取焦点的几种场景
- RichEditor组件如何设置光标的起始位置位于左上角
- 如何实现软键盘弹出后，整体布局不变
- 如何实现Tabs页签导航栏切换时，下划线也随之滑动
- 如何解决Web与List的嵌套滑动冲突
- 如何解决两层Tabs出现滑动冲突的情况？
- 如何主动清除控件的焦点
- 如何加载和使用自定义字体
- 如何选择图文混排的实现方案
- 如何实现分组列表的吸顶/吸底效果
- 如何解决List组件在不设置高度的情况下滑动不到底的问题
- List组件如何实现多列效果
- 如何设置分组列表的圆角和间距
- 如何获取UI组件的显示或隐藏状态
- 如何实现类似插槽的功能
- 如何解决子组件全屏后margin不会生效的问题
- 如何实现手指离开屏幕后的惯性滑动效果
- 如何监听当前屏幕的横竖屏状态？如何实现页面跟随屏幕横竖屏自动旋转
- 如何处理父子组件间的事件传递，例如，如何解决滑动冲突
- 使用ForEach&LazyForEach循环渲染时，会出现更改数据源时，界面不刷新的情况。如何解决
- 在使用Canvas的场景中，如何主动控制组件刷新UI
- 如何在键盘弹出时仅调整指定UI组件的位置，而不影响整体布局
- 组件支持的参数类型及参数单位类型：PX、 VP、 FP 、LPX、Percentage、Resource 详细区别是什么
- Text 组件如何加载Unicode字符
- 自定义字体的注册方式是什么，如何从资源存放路径中取出字体资源？
- AppStorage是否支持线程间共享对象，如果不支持，推荐替代方案是什么
- 如何在自定义组件的构建流程里跟踪组件数据或者状态，如在build里增加日志跟踪状态变量等
- 如何在键盘弹出时，让内容上移，而不是整个页面上移
- 输入框拉起键盘时，如何将底部布局弹起到键盘顶部
- 图片如何添加渐变模糊
- 如何去除Tabs组件两侧的蒙层
- 如何获取Text组件中文字的宽度
- 如何设置自定义组件height缺省
- 弹窗组件无法进入onPageShow方法
- Navigation的toolbar中设置大图标时被切断
- Image无法使用bindContextMenu
- 如何设置Tabs的末尾由透明到不透明的渐变效果
- SideBarContainer如何设置controlButton属性
- 如何监听屏幕旋转
- 如何设置窗口旋转
- 父组件如何与孙子组件进行状态同步
- 自定义弹窗能否在ts文件中定义和使用
- 自定义弹窗中的变量如何传递给页面
- 如何一键清空TextInput、TextArea组件内容
- 如何设置自定义弹窗位置
- 自定义弹窗大小如何自适应内容
- 如何理解自定义弹窗中的gridCount参数
- 如何去除自定义弹窗的白色背景
- TextInput组件密码模式下，右边的眼睛图标能否支持自定义
- TextInput的onSubmit事件如何使用
- TextInput在聚焦时如何使光标回到起点
- 如何获取组件的属性信息
- 如何获取可滚动组件的当前滚动偏移量
- 如何实现文本竖向排列
- TimePicker组件中文本的颜色和大小是否可以自定义
- ConstraintSize尺寸设置不生效
- 如何将背景颜色设置为透明
- 如何自定义Video组件控制栏样式
- 如何设置组件不同状态下的样式
- 如何主动拉起软键盘
- 如何在List组件中分组展示不同种类的数据
- 通过$r访问应用资源是否支持嵌套形式
- Button组件如何设置渐变背景色
- 滑动的页面软键盘挡住内容不能向上滑动
- TextInput如何限制输入字符为某些字符
- 如何根据组件内容大小修改浮动窗口
- List组件如何设置多列
- 如何设置区分TabBar和TabContent的分割线样式
- 为何RichText组件中内容可以滚动
- 如何设置List组件滑动到边缘无回弹效果
- ArkUI中icon资源锯齿感严重
- 如何实现多行输入
- 文本组件是否支持分段设置字体样式
- 如何修改状态栏字体颜色
- 弹窗弹出时，输入框如何用代码设置全选
- 文字空行高度与字体高度不一致
- TextInput组件包含英文和汉字时，如何设置全选
- Color支持哪些格式，使用color: 'rgba(0, 0, 255, .5)'格式不生效
- TextInput按压态背景色如何修改
- 组件最大和最小宽度和高度如何设置
- XComponent组件如何设置背景颜色
- 组件如何设置模糊效果
- UI布局默认是多少vp为基准，以达到不同机器自适应
- 如何使应用一键变灰
- 如何设置屏幕亮度
- TextInput是否能自定义hover效果
- 如何去除tabbar滑动到边缘时的蒙层效果
- 如何实现两层Tab嵌套滑动的效果
- Grid组件的scrollBar是否支持自定义
- List组件如何设置两端的渐变效果
- 过长文字如何滚动显示
- XComponent 怎么设置成透明
- 半模态转场如何控制固定高度
- 如何实现拖拽时列表项占位动画的效果
- ArkUI组件的字符串中如何实现字符串变量拼接
- 控制中心的下拉背景实时模糊是如何实现的
- 如何获取图片的宽高
- 如何解决Web页面输入框拉起键盘后，页面头部被截断的问题
- Navigation如何隐藏导航栏
- 如何设置子组件宽度使其不超过父组件的大小
- Image或者ImageSpan传入一个string类型的路径时无法加载图片
- Image组件如何读入沙箱内的图片
- 如何实现事件透传
- Text组件设置maxLines后如何确定文本是否被隐藏
- 如何实现类似keyframes的效果
- 外部容器Stack能否满足适应内部容器组件的圆角等样式
- Stack布局设置Alignment.BottomStart没有生效
- 布局是否支持css里的calc(100vh - 100px)类似能力
- 自定义弹窗CustomDialog的maskRect属性中x，y是否支持calc
- 如何获取router.back传递的参数
- 焦点事件onBlur/onFocus回调无法触发
- Scroll里面套一个grid，如何禁用grid的滑动事件
- 如何实现一个组件不停地旋转
- 键盘拉起时列表无法上下滑动
- 键盘移动焦点对象按下enter，为什么不会触发点击事件
- 多层组件嵌套button，如何阻止事件传递
- 使用Navigator实现页面跳转时，如何关闭页面间转场动效
- 在容器组件嵌套的场景下，如何解决手势拖拽事件出现错乱的问题
- 当父组件绑定了onTouch，其子组件Button绑定了onClick，如何做到点击Button只响应Button的onClick，而不用响应父组件的onTouch
- 点击文本输入框，如何屏蔽系统默认键盘弹起行为
- 如何阻止组件的鼠标事件冒泡到父组件
- 如何实现上下切换的页面间跳转动画
- 自定义组件间如何实现从底部滑入滑出的效果
- 子组件事件能否到传递父组件
- 文档中提到键鼠事件可以设置冒泡阻断，其他事件是否支持
- 组件被隐藏后 onVisibleAreaChange 事件触发了两次
- @Watch是否有粘性的概念
- 使用@Watch监听并在回调函数中调用其他异步接口时UI响应慢
- 如何移除页面上Video组件
- 触摸事件的TouchEvent调用stopPropagation时无法阻止事件分发
- 如何获取窗口的宽高信息
- 通用属性width是否支持设置变量
- 如何判断JS对象中是否存在某个值
- 应用如何设置隐藏顶部的状态栏
- 如何锁定设备竖屏，使得窗口不随屏幕旋转
- 调用window实例的setWindowSystemBarProperties接口设置窗口状态栏和导航栏的高亮属性时不生效
- 如何保持屏幕常亮
- 如何监听窗口大小的变化
- 如何获取屏幕的宽度、高度、分辨率和横竖屏等信息
- 如何设置沉浸式窗口
- 如何获取窗口的宽度
- 如何解决window创建的模态窗口默认焦点不在界面上，导致不响应返回事件的问题
- 如何获取状态栏和导航栏高度
- 如何实现Tabs组件的TabBar居左对齐
- 如何进行页面横竖屏切换
- 为什么componentUtils.getRectangleById在动画结束后才能获取组件最新位置
- 是否有处理"9图"（又称"draw9patch"、".9图"、"点9图"等）的平替方案
- ArkUI有没有在组件刷新后的回调事件
- 如何在自定义弹窗中再次弹窗
- Grid如何实现拖拽功能
- 如何设置沉浸式状态栏
- 如何动态控制键盘绑定在不同的TextInput上
- 如何使用iconfont
- Image组件是否有缓存机制
- 如何使当前页面弹窗在页面跳转返回之后还存在(隐私详情页场景)
- ForEach键值生成规则是怎样的
- Flex布局与w3c中的flex是否有差异
- ArkUI组件能否支持继承
- @Style 和 @Extend 是否支持export导出
- 如何自定义弹窗的弹出动画和关闭动画
- 如何实现弹窗和软键盘的避让
- Canvas绘制内容如何动态更新
- 组件是否支持泛型
- 自定义组件是否能通过容器保存
- 使用BuilderParam在父组件调用this的方法报错：Error message:is not callable
- Component如何监听应用前后台切换
- 自定义组件如何实现类似系统组件的链式调用
- 自定义组件在外部设置属性方法和在build方法内部设置有什么区别
- 如何实现页面加载的loading效果
- 使用Navigation跳转页面时如何传递带方法的对象
- 如何实现下拉刷新和上滑加载的效果
- 如何正确获取刘海区域的高度，topRect中的取值是height、top还是height+top
- 应用开启禁止截屏之后，用户进行截屏以及录屏后的行为是什么
- 在屏幕底部的组件的响应区域是否存在遮挡
- 如何获取设备屏幕横竖屏状态
- 创建subwindow默认是否铺满全屏，铺满全屏时如何隐藏状态栏
- 如何让Grid组件在高度不确定的情况下，实现自适应高度
- 如何获取手机屏幕信息
- 如何解决点击子组件模块区域会触发父组件的点击事件问题
- 当子组件触发触摸事件的时候，父组件如果设置触摸事件的话，如何解决父组件也会被触发的问题
- 使用0x八位颜色设置渐变透明度为什么与#八位资源颜色值不同
- 如何实现背景跟随文字大小改变
- ListItemGroup和LazyForEach如何结合使用
- 如何设置Text的字体，可以不受系统设置里显示字体大小的影响
- 如何获取底部手势横条的高度
- 如何实现列表既可以左右滑、又可以上下滑动
- 如何使用Swiper组件实现下拉刷新
- getContext传入this和不传入有什么区别
- 使用LazyForEach时滑动列表产生大量aboutToBeDeleted的函数调用，如何减少？
- 为什么px2vp返回的结果不正确
- 是否navigation有最大页面数量限制？router栈的栈最大是32个，超过32个是无响应还是报错？
- 如何使用Navigation的navPathStack参数
- Navigation容器中，如何设置子组件的高度为100%，撑满父容器
- Navigation中pushPathByName与pushDestinationByName的区别
- 如何实现点击输入框时会拉起软键盘，点击Button时软键盘关闭
- 如何获取屏幕顶部状态栏、底部导航栏和导航条的高度
- 如何实现文本展开收起功能
- List的下拉加载如何回滚到当前展示位置
- TextInput的visibility属性设置为Hide或者None之后是否可获焦
- 使用Navigation导航时，NavDestination页如何获取路由参数
- 如何实现跨文件样式复用
- 如何实现跨文件组件复用
- 如何在Navigation页面中实现侧滑事件拦截
- 如何完成挖孔屏的适配
- 如何实现页面统一置灰功能
- 如何实现List内拖拽交换子组件位置
- 如何将ListItem的swipeAction滑动效果恢复至未滑动
- 如何实现List/Swiper/Grid嵌套滚动的下拉刷新和上拉加载更多
- 如何在代码中触发应用后台运行
- 如何将Tab的边缘滑动效果关掉，不要回弹
- 自定义键盘和系统键盘如何切换
- CustomDialog自定义弹窗组件如何进行物理返回拦截
- struct和class的区别是什么
- 跳转页面如何实现页面级别的透明效果
- 如何实现二维数组的懒加载？
- 如何实现不关闭弹窗的情况下，跳转页面，并且返回时弹窗存在？
- 如何实现带图片的二维码效果？
- Scroll中嵌套List，可否设置事件响应顺序，让List不响应滚动事件，让外层的Scroll滚动整个布局?
- 如何清除输入框焦点？
- 如何进行截屏并获取截屏内容
- 如何在Page中获取WindowStage实例
- Navigation与Router对比和如何进行选择
- 如何获取组件渲染完成时间
- Toggle组件设置拖动的同时如何屏蔽其本身的点击手势
- 如何通过路由的方式打开半屏
- 如何识别双击手势时忽视单击手势?
- 如何查看触摸热区范围
- 如何将内容直接复制到剪贴板
- Grid onItemDragStart默认时间设置替代方案、以及多列GridItem实现通用示例
- 绑定类型的组件和ForEach的正确连用方式
- 如何使用canvas绘制圆角矩形
- 如何设置镜像语言的左右间距
- 如何实现Scroll、List单边回弹效果
- 如何合并两个列表并支持懒加载
- RelativeContainer组件height设置为auto，子组件以容器作为锚点，为什么auto不生效
- 如何设置禁止分屏
- 如何解决滚动类容器的滚动事件和手势之间的冲突
- 如何使用ListItemGroup和LazyForEach结合并实现组件复用
- 如何在Text组件关闭bindSelection自定义菜单时，取消文本的选中状态
- WaterFlow、Grid、List这些容器的使用区别是什么？
- 如何控制CustomDialog显示层级
- 如何处理ForEach第三个参数键值生成耗时久导致的卡顿问题
- Tab组件页面切换时，如何不显示中间过渡的tab页
- LocalStorage频繁读写复杂对象时性能变差原因是什么
- 如何给不同输入框绑定不同的自定义键盘
- 一个自定义组件内某一时机批量刷新多个@State修饰的状态变量，是否会影响性能
- List控件加载的数据如何判断是否超过一屏
- 常用可以设置'auto'的属性的组件及其含义的介绍
- 双层嵌套list,如何使用LazyForEach起作用
- Marquee组件的文字滚动，第一次滚动出现大量空白，如何避免空白出现
- 如何解决Web页上下滑动时会误触发tab页翻页手势及tab页切换时Web组件还可以上下滚动问题
- 如何判断当前设备是手机还是折叠屏手机
- 如何在使用子窗口时保持键盘获焦
- 如何实现直播评论场景中顶部渐变遮罩效果
- 如何在Tabs的tabBar中添加其他组件
- 使用Canvas如何实现部分区域镂空的效果
- 如何解决Text组件文本为中文、数字、英文混合时显示省略号截断异常的问题
- 如何实现List的折叠动画效果
- 如何修改bindPopup绑定的弹窗圆角大小和箭头颜色
- bindPopup适配Web组件长按菜单功能，如何设置offset控制弹窗的偏移
- 如何使用自定义弹窗实现分享弹窗
- Badge有数量与无数量切换时Image会发生闪动，怎么让它不闪动
- 目前Toggle组件响应点击之后会立刻渲染且立刻回调，如何延迟改变Toggle状态且延时回调？
- 如何在系统深色模式下使用getColorSync(resource)返回深色颜色值
- 汉字转拼音如何去掉音标
- 如何更改TextInput密码输入模式下passwordIcon的大小、颜色、位置
- 状态栏与页面内容发生重叠，如何解决？
- 如何实现状态栏背景颜色沉浸？
- 在深色模式切换下如何适配状态栏颜色？
- 进入全屏模式后隐藏状态栏，退出全屏模式如何显示状态栏？
- Button组件无法设置字体最大、最小值
- 如何实现折叠屏折叠态不适配旋转，展示态适配旋转
- 如何实现组件动态上下树
- Image组件长按和拖拽的系统手势和自定义手势冲突
- 如何实现通过侧滑手势关闭打开的悬浮框
- 如何获取状态管理框架代理前的原始对象
- 在display.on('change')监听回调中，无法使用Window实例获取更新后的窗口大小
- 如何同时获取屏幕方向orientation和系统规避区avoidAreaChange信息
- 如何实现沉浸式页面（包括沉浸式状态栏、沉浸式导航条）
- 如何理解AspectRatio对布局的影响
- 如何设置customspan不同位置的点击事件
- 窗口Orientation枚举值8~10或12和枚举值13~16的区别
- 如何实现应用的屏幕自动旋转
- 自定义构建函数Builder与自定义组件component的使用区别以及限制是什么
- 如何实现ArkUI组件字符串变量拼接
- 如何打开键鼠穿越功能开关
- 是否支持对页面等ArkUI组件相关元素进行插桩

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-1
爬取时间: 2025-05-08 04:45:01
来源: Huawei Developer


设置图片的插值效果属性Image中的interpolation，即缓解图片在缩放时的锯齿问题。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-3
爬取时间: 2025-05-08 04:45:11
来源: Huawei Developer


setWindowPrivacyMode设置窗口是否为隐私模式，设置为隐私模式的窗口，窗口内容将无法被截屏或录屏。此接口可用于禁止截屏/录屏的场景。


方式一：设置主窗口为隐私模式，具体可参考以下步骤：


首先，在module.json5文件中声明需要使用的ohos.permission.PRIVACY_WINDOW 权限。


```less
"requestPermissions": [
  {"name": "ohos.permission.PRIVACY_WINDOW"}
]
```


然后，在EntryAbility.ets文件中的onWindowStageCreate回调中设置主窗口为隐私模式，具体可参考示例代码：


```typescript
import { AbilityConstant, ConfigurationConstant, UIAbility, Want } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';


export default class EntryAbility extends UIAbility {
  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    this.context.getApplicationContext().setColorMode(ConfigurationConstant.ColorMode.COLOR_MODE_NOT_SET);
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
  }


  onDestroy(): void {
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
  }


  onWindowStageCreate(windowStage: window.WindowStage): void {
    // Main window is created, set main page for this ability
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
    // 获取主窗口
    windowStage.getMainWindow((err: BusinessError, data) => {
      let errCode: number = err.code;
      if (errCode) {
        console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err));
        return;
      }
      let windowClass: window.Window = data;
      console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(data));
      // 设置窗口隐私模式
      let isPrivacyMode: boolean = true;
      try {
        windowClass.setWindowPrivacyMode(isPrivacyMode, (err: BusinessError) => {
          const errCode: number = err.code;
          if (errCode) {
            console.error('Failed to set the window to privacy mode. Cause:' + JSON.stringify(err));
            return;
          }
          console.info('Succeeded in setting the window to privacy mode.');
        });
      } catch (exception) {
        console.error('Failed to set the window to privacy mode. Cause:' + JSON.stringify(exception));
      }
    })
    windowStage.loadContent('pages/Index', (err, data) => {
      if (err.code) {
        hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
        return;
      }
      hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
    });
  }


  onWindowStageDestroy(): void {
    // Main window is destroyed, release UI related resources
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
  }


  onForeground(): void {
    // Ability has brought to foreground
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
  }


  onBackground(): void {
    // Ability has back to background
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
  }
}
```


方式二：进入页面开启隐私模式，离开页面取消，具体可参考以下步骤：


首先，在module.json5文件中声明需要使用的ohos.permission.PRIVACY_WINDOW 权限


```less
"requestPermissions": [
  {"name": "ohos.permission.PRIVACY_WINDOW"}
]
```


然后，通过导航栏显示状态切换触发onNavBarStateChange回调，进入页面isVisible为true，调用setWindowPrivacyMode设置窗口为隐私模式，离开页面时isVisible为false，设置窗口为非隐私模式。参考示例代码如下：


```typescript
import { BusinessError } from '@kit.BasicServicesKit';
import { common } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';


class windowUtils {
  static setWindowPrivacyModeInPage(context: common.UIAbilityContext, isFlag: boolean) {
    window.getLastWindow(context).then((lastWindow) => {
      lastWindow.setWindowPrivacyMode(isFlag, (err: BusinessError) => {
        const errCode: number = err.code;
        if (errCode) {
          console.error('Failed to set the window to privacy mode. 1Cause:' + JSON.stringify(err));
          return;
        }
        console.info('Succeeded in setting the window to privacy mode.');
      });
    })
  }
}


@Entry
@Component
struct Index {
  @State message: string = 'hello world';
  @Provide('NavPathStack') pageStack: NavPathStack = new NavPathStack();


  @Builder
  PagesMap(name: string) {
    if (name === 'Index') {
      Index();
    } else if (name === 'PageOne') {
      PageOne();
    }
  }


  build() {
    Navigation(this.pageStack) {
      Column() {
        Button('pushPath', { stateEffect: true, type: ButtonType.Capsule })
          .width('80%')
          .height(40)
          .margin(20)
          .onClick(() => {
            this.pageStack.pushPath({ name: 'PageOne' }) //将name指定的NavDestination页面信息入栈
          })
      }
    }
    .navDestination(this.PagesMap)
    .onNavBarStateChange((isVisible: boolean) => {
      // 导航栏显示状态切换时触发该回调
      console.info('------>isVisible：' + isVisible)
      windowUtils.setWindowPrivacyModeInPage(getContext(this) as common.UIAbilityContext, isVisible);
    })
  }
}


@Component
struct PageOne {
  @Consume('NavPathStack') pageStack: NavPathStack;


  build() {
    NavDestination() {
      Column() {
        Text('PageOne')
      }
    }
    .title('pageOne')
    .onBackPressed(() => {
      const popDestinationInfo = this.pageStack.pop(); // 弹出路由栈栈顶元素
      return true;
    })
  }
}
```


参考链接


setWindowPrivacyMode、onNavBarStateChange


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-4
爬取时间: 2025-05-08 04:45:21
来源: Huawei Developer


使用组合手势的顺序识别，当长按手势事件结束后触发拖动手势事件。在手势回调方法里获取event（GestureEvent类型）的fingerList（FingerInfo[]类型），获取到localX和localY数值，表示相对于当前组件元素原始区域左上角的坐标地址。可参考如下代码：


```less
import { promptAction } from '@kit.ArkUI'; 
 
@Component 
struct CoordinatesOfTheFingerTouchPoint { 
  @State count: number = 0; 
  private touchAreaRight: number = 0; 
  private touchAreaBottom: number = 0; 
  @State positionX: number = 0; 
  @State positionY: number = 0; 
  @State gestureEventInfo: string = ''; 
 
  build() { 
    Column() { 
      Row() { 
        Column() { 
          Text('+') 
            .fontSize(28) 
            .position({ x: this.positionX, y: this.positionY }) 
        } 
        .height(200) 
        .width('100%') 
        .backgroundColor('#F1F3F5') 
        .onAreaChange((oldValue: Area, newValue: Area) => { 
          this.touchAreaRight = newValue.width as number; 
          this.touchAreaBottom = newValue.height as number; 
        }) 
        .gesture( 
          // 以下组合手势为顺序识别，当长按手势事件未正常触发时则不会触发拖动手势事件 
          GestureGroup(GestureMode.Sequence, 
            LongPressGesture({ repeat: true }) 
              .onAction((event: GestureEvent) => { 
                if (event.repeat) { 
                  this.count++; 
                } 
              }), 
            PanGesture() 
              .onActionStart(() => { 
                promptAction.showToast({ message: 'Pan start', duration: 1000 }); 
              }) 
              .onActionUpdate((event: GestureEvent) => { 
                for (let i = 0; i < event.fingerList.length; i++) { 
                  if (event.fingerList[i] == undefined 
                    || event.fingerList[i].localX < 0 
                    || event.fingerList[i].localY < 0 
                    || event.fingerList[i].localX > this.touchAreaRight 
                    || event.fingerList[i].localY > this.touchAreaBottom) { 
                    return; 
                  } 
                  this.positionX = event.fingerList[i].localX; 
                  this.positionY = event.fingerList[i].localY; 
                } 
                this.gestureEventInfo = 'sequence gesture\n' + 'LongPress onAction' + this.count 
                  + '\nX:' + this.positionX + '\nY:' + this.positionY; 
              }) 
              .onActionEnd(() => { 
                promptAction.showToast({ message: 'Pan end', duration: 1000 }); 
              }) 
          ) 
            .onCancel(() => { 
              promptAction.showToast({ message: '取消', duration: 1000 }); 
            }) 
        ) 
      } 
      .padding(12) 
      .borderRadius(24) 
      .backgroundColor(Color.White) 
 
      Text(this.gestureEventInfo) 
        .fontSize(18) 
        .width('100%') 
        .textAlign(TextAlign.Start) 
        .padding({ left: 18, top: 30 }) 
    } 
    .height('100%') 
    .width('100%') 
    .backgroundColor('#F1F3F5') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-5
爬取时间: 2025-05-08 04:45:31
来源: Huawei Developer


可以自定义页签，然后给页签一个对齐方式，具体可参考代码：


```less
@Entry
@Component
struct CustomizeTheTabsBarAndItsAlignment {
  @State focusIndex: number = 0;
  private controller: TabsController = new TabsController();
  tabArray = [0, 1];


  // 自定义页签
  @Builder
  Tab(tabName: string, tabItem: number, tabIndex: number) {
    Column({ space: 20 }) {
      Text(tabName).fontSize(18)
      Image($r('app.media.startIcon')).width(20).height(20)
    }
    .width(100)
    .height(60)
    .borderRadius({ topLeft: 10, topRight: 10 })
    .onClick(() => {
      this.controller.changeIndex(tabIndex);
      this.focusIndex = tabIndex;
    })
    .backgroundColor(tabIndex === this.focusIndex ? '#ffffffff' : '#ffb7b7b7')
  }


  build() {
    Column() {
      Column() {
        // 页签
        Row({ space: 6 }) {
          Scroll() {
            Row() {
              ForEach(this.tabArray, (item: number, index: number) => {
                this.Tab('页' + item, item, index);
              })
            }
            .justifyContent(FlexAlign.Start)
          }
          // 设置左对齐
          .align(Alignment.Start)
          .scrollable(ScrollDirection.Horizontal)
          .scrollBar(BarState.Off)
          .width('80%')
          .backgroundColor('#ffb7b7b7')
        }
        .width('100%')
        .backgroundColor('#ffb7b7b7')


        // tabs
        Tabs({ barPosition: BarPosition.Start, controller: this.controller }) {
          ForEach(this.tabArray, (item: number, index: number) => {
            TabContent() {
              Text('我是页面 ' + item + ' 的内容')
                .height(300)
                .width('100%')
                .fontSize(30)
            }
            .backgroundColor(Color.Pink)
          })
        }
        .barHeight(0)
        .animationDuration(100)
        .onContentWillChange((currentIndex, comingIndex) => {
          this.focusIndex = comingIndex;
          console.info('foo change' + this.focusIndex);
          return true;
        })
      }
      .alignItems(HorizontalAlign.Start)
      .width('100%')
    }
    .height('100%')
  }
}
```


参考链接


Tabs


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-6
爬取时间: 2025-05-08 04:45:41
来源: Huawei Developer


参照指南自定义弹窗（CustomDialog）中的示例可实现封装。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-7
爬取时间: 2025-05-08 04:45:50
来源: Huawei Developer

- 组件可见范围占比可以使用onVisibleAreaChange事件来监听组件可见区域变化事件。
- 停止滑动在scroll组件中有onScrollStop事件，可以获取组件的滑动状态scroll事件。
- 组件的布局改变可以使用onAreaChange事件来监听组件区域变化事件。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-8
爬取时间: 2025-05-08 04:46:00
来源: Huawei Developer


可以使用if/else条件渲染，对不同情况下的组件属性值进行设置。具体可参考示例代码：


```less
@Entry 
@Component 
struct TestHeightPage { 
  @State message: string = 'Hello World'; 
  @State myHeight1: number = 30; 
  @State myHeight2: number = 60; 
  @State flag: Boolean = false 
  build() { 
    Column() { 
      Text(this.message) 
        .fontSize(20) 
        .fontWeight(FontWeight.Bold) 
        .width('100%') 
        .height(this.flag ? this.myHeight1 : this.myHeight2) 
        .backgroundColor(Color.Orange) 
 
      Button('修改Text属性height').onClick(() => { 
        //1.if/else 
        if (this.flag) { 
          this.flag = false; 
        } else { 
          this.flag = true; 
        } 
        //2.取反 
        this.flag = !this.flag; 
      }).margin({ top: 12 }) 
    } 
    .height('100%') 
  } 
}
```


参考链接


if/else：条件渲染


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-12
爬取时间: 2025-05-08 04:46:15
来源: Huawei Developer


参考以下写法，参数类无法传递map等js对象。


```typescript
interface paramType { 
  param: string 
} 
 
let paramA: paramType = { 
  param: 'test1' 
} 
 
@Entry 
@Component 
struct Index { 
  @Provide('pathInfos') pathInfos: NavPathStack = new NavPathStack(); 
 
  @Builder 
  myRouter(name: string) { 
    if (name === 'MyFirstNavDestination') { 
      MyFirstNavDestination() 
    } else if (name === 'MySecondNavDestination') { 
      MySecondNavDestination() 
    } 
  } 
 
  build() { 
    Navigation(this.pathInfos) { 
      Row() { 
        Column() { 
          Text('hello world') 
        } 
        .height('100%') 
      } 
      .onClick(() => { 
        this.pathInfos.pushPathByName('MyFirstNavDestination', paramA); 
      }) 
    } 
    .navDestination(this.myRouter) 
  } 
} 
 
@Component 
export struct MyFirstNavDestination { 
  @Consume('pathInfos') pathInfos: NavPathStack; 
 
  getParamsPrint() { 
    console.info('xuerui', 'param is ' + JSON.stringify(this.pathInfos.getParamByName('MyFirstNavDestination'))); 
  } 
 
  build() { 
    NavDestination() { 
      Row() { 
        Column() { 
          Text('MyFirstNavDestination') 
        } 
        .width('100%') 
      } 
      .height('100%') 
      .onClick(() => { 
        this.pathInfos.pushPathByName('MySecondNavDestination', null); 
      }) 
    }.onShown(() => { 
      this.getParamsPrint(); 
    }) 
  } 
} 
 
@Component 
export struct MySecondNavDestination { 
  @Consume('pathInfos') pathInfos: NavPathStack; 
  private routerParams: paramType = { param: 'test 2' }; 
 
  build() { 
    NavDestination() { 
      Row() { 
        Text('MySecondNavDestination') 
      } 
      .height('100%') 
    }.onBackPressed(() => { 
      // pop B页面 
      this.pathInfos.pop(); 
 
      //获取当前栈顶页面名字（A页面） 
      let allPathName: Array<string> = this.pathInfos.getAllPathName(); 
      let pathNameA: string = allPathName[allPathName.length - 1]; 
 
      // pop A页面 
      this.pathInfos.pop(); 
 
      // 重新PUSH A页面 
      this.pathInfos.pushPath(new NavPathInfo(pathNameA, this.routerParams)) 
      return true; 
    }) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-13
爬取时间: 2025-05-08 04:46:24
来源: Huawei Developer

-  调用focusControl.requestFocus接口可以主动让焦点转移至参数指定的组件上。可参考如下代码：

```less
// xxx.ets
@Entry
@Component
struct TextInputExample {
  build() {
    Row() {
      Column() {
        Button('第二个获取焦点')
          .onClick(() => {
            focusControl.requestFocus('BBB'); // 让第二个输入框获取焦点
          })


        TextInput({ placeholder: 'Please enter the content.' })
          .showUnderline(true)
          .width(380)
          .height(60)
          .key('AAA')

        TextInput({ placeholder: 'Please enter the content.' })
          .showUnderline(true)
          .width(380)
          .height(60)
          .key('BBB')
      }
      .width('100%')
    }
    .height('100%')
  }
}
```

-  设置defaultFocus属性，defaultFocus可以使绑定的组件成为页面创建后首次获焦的焦点。可参考如下代码：

```less
// xxx.ets
@Entry
@Component
struct TextInputExample {
  build() {
    Row() {
      Column() {
        TextInput({ placeholder: 'Please enter the content.' })
          .showUnderline(true)
          .width(380)
          .height(60)


        TextInput({ placeholder: 'Please enter the content.' })
          .showUnderline(true)
          .defaultFocus(true) // 页面首次打开时，该TextInput获取焦点
          .width(380)
          .height(60)
      }
      .width('100%')
    }
    .height('100%')
  }
}
```

-  设置enableKeyboardOnFocus(false)，在页面进入后不弹出键盘。可参考如下代码：

```less
// xxx.ets
@Entry
@Component
struct TextInputExample {
  build() {
    Row() {
      Column() {
        TextInput({ placeholder: 'Please enter the content.' })
          .defaultFocus(true) // 页面首次打开时，该TextInput获取焦点
          .enableKeyboardOnFocus(false) // TextInput通过点击以外的方式获焦时，是否绑定输入法。
          .placeholderColor(Color.Grey)
          .placeholderFont({ size: 14, weight: 400 })
          .caretColor(Color.Blue)
          .width('95%')
          .height(40)
          .margin(20)
      }
      .width('100%')
    }
    .height('100%')
  }
}
```

-  TextInput默认不获取焦点，不弹出键盘。可参考如下代码：

```less
// xxx.ets
@Entry
@Component
struct TextInputExample {
  build() {
    Column() {
      TextInput({ placeholder: 'Please enter the content.' })
    }
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-14
爬取时间: 2025-05-08 04:46:34
来源: Huawei Developer


可以通过align属性传入参数Alignment.TopStart，来设置光标位置位于左上角。示例代码如下：


```less
// xxx.ets 
@Entry 
@Component 
struct RichEditorExample { 
  controller: RichEditorController = new RichEditorController(); 
 
  build() { 
    Column() { 
      RichEditor({ controller: this.controller }) 
        .align(Alignment.TopStart) // 设置光标的起始位置位于左上角 
        .height(200) 
        .borderWidth(1) 
        .borderColor(Color.Red) 
        .width('100%') 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-16
爬取时间: 2025-05-08 04:46:44
来源: Huawei Developer


通过expandSafeArea属性把组件扩展其安全区域，使页面整体布局保持不变，当type为SafeAreaType.KEYBOARD时默认生效，组件不避让键盘。可参考如下代码：


```less
// xxx.ets 
@Entry 
@Component 
struct TextInputExample { 
  scroller: Scroller = new Scroller(); 
  @State Text: string = ''; 
 
  build() { 
    Scroll(this.scroller) { 
      Column({ space: 20 }) { 
        TextInput({ placeholder: 'Please enter the content.' }) 
          .expandSafeArea([SafeAreaType.KEYBOARD]) 
          .type(InputType.Password) 
          .margin({ top: 200 }) 
        TextInput({ placeholder: 'Please enter the content.' }) 
          .expandSafeArea([SafeAreaType.KEYBOARD]) 
          .margin({ top: 200 }) 
        Text(`UserName：${this.Text}`) 
          .expandSafeArea([SafeAreaType.KEYBOARD]) 
          .width('80%') 
          .margin({ top: 200 }) 
        TextInput({ placeholder: 'Please enter a user name.', text: this.Text }) 
          .expandSafeArea([SafeAreaType.KEYBOARD]) 
          .margin({ top: 200 }) 
          .onChange((value: string) => { 
            this.Text = value; 
          }) 
      } 
      .width('100%') 
    } 
    .scrollBar(BarState.Off) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-17
爬取时间: 2025-05-08 04:46:54
来源: Huawei Developer


可以使用子页签样式SubTabBarStyle来实现，具体参考如下代码：


```less
@Entry
@Component
struct TabsBarUnderlineSwitching {
  private controller: TabsController = new TabsController();
  @State indicatorColor: Color = Color.Blue;
  @State indicatorWidth: number = 40;
  @State indicatorHeight: number = 5;
  @State indicatorBorderRadius: number = 5;
  @State indicatorSpace: number = 10;
  @State subTabBorderRadius: number = 20;
  @State selectedMode: SelectedMode = SelectedMode.INDICATOR;


  build() {
    Column() {
      Tabs({ barPosition: BarPosition.End, controller: this.controller }) {
        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Pink).borderRadius('12vp')
        }.tabBar(SubTabBarStyle.of('pink')
          .indicator({
            color: this.indicatorColor, // 下划线颜色
            height: this.indicatorHeight, // 下划线高度
            width: this.indicatorWidth, // 下划线宽度
            borderRadius: this.indicatorBorderRadius, // 下划线圆角半径
            marginTop: this.indicatorSpace // 下划线与文字间距
          })
          .selectedMode(this.selectedMode)
          .board({ borderRadius: this.subTabBorderRadius })
          .labelStyle({})
        )


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Yellow).borderRadius('12vp')
        }.tabBar(SubTabBarStyle.of('yellow')
          .indicator({
            color: this.indicatorColor, // 下划线颜色
            height: this.indicatorHeight, // 下划线高度
            width: this.indicatorWidth, // 下划线宽度
            borderRadius: this.indicatorBorderRadius, // 下划线圆角半径
            marginTop: this.indicatorSpace // 下划线与文字间距
          })
          .selectedMode(this.selectedMode)
          .board({ borderRadius: this.subTabBorderRadius })
          .labelStyle({})
        )


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Blue).borderRadius('12vp')
        }.tabBar(SubTabBarStyle.of('blue')
          .indicator({
            color: this.indicatorColor, // 下划线颜色
            height: this.indicatorHeight, // 下划线高度
            width: this.indicatorWidth, // 下划线宽度
            borderRadius: this.indicatorBorderRadius, // 下划线圆角半径
            marginTop: this.indicatorSpace // 下划线与文字间距
          })
          .selectedMode(this.selectedMode)
          .board({ borderRadius: this.subTabBorderRadius })
          .labelStyle({})
        )


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green).borderRadius('12vp')
        }.tabBar(SubTabBarStyle.of('green')
          .indicator({
            color: this.indicatorColor, // 下划线颜色
            height: this.indicatorHeight, // 下划线高度
            width: this.indicatorWidth, // 下划线宽度
            borderRadius: this.indicatorBorderRadius, // 下划线圆角半径
            marginTop: this.indicatorSpace // 下划线与文字间距
          })
          .selectedMode(this.selectedMode)
          .board({ borderRadius: this.subTabBorderRadius })
          .labelStyle({})
        )


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Gray).borderRadius('12vp')
        }.tabBar(SubTabBarStyle.of('gray')
          .indicator({
            color: this.indicatorColor, // 下划线颜色
            height: this.indicatorHeight, // 下划线高度
            width: this.indicatorWidth, // 下划线宽度
            borderRadius: this.indicatorBorderRadius, // 下划线圆角半径
            marginTop: this.indicatorSpace // 下划线与文字间距
          })
          .selectedMode(this.selectedMode)
          .board({ borderRadius: this.subTabBorderRadius })
          .labelStyle({})
        )


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Orange).borderRadius('12vp')
        }.tabBar(SubTabBarStyle.of('orange')
          .indicator({
            color: this.indicatorColor, // 下划线颜色
            height: this.indicatorHeight, // 下划线高度
            width: this.indicatorWidth, // 下划线宽度
            borderRadius: this.indicatorBorderRadius, // 下划线圆角半径
            marginTop: this.indicatorSpace // 下划线与文字间距
          })
          .selectedMode(this.selectedMode)
          .board({ borderRadius: this.subTabBorderRadius })
          .labelStyle({})
        )
      }
      .vertical(false)
      .scrollable(true)
      .fadingEdge(false)
      .barMode(BarMode.Scrollable)
      .barHeight(140)
      .animationDuration(400)
      .onChange((index: number) => {
        console.info(index.toString())
      })
      .backgroundColor(0xF5F5F5)
      .height(320)
    }.width('100%').height(250).padding({ top: '24vp', left: '24vp', right: '24vp' })
  }
}
```


参考链接


TabContent中的子页签样式SubTabBarStyle


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-18
爬取时间: 2025-05-08 04:47:05
来源: Huawei Developer


可以使用触摸测试控制来规避此种情况，参考代码如下：


```less
import { webview } from '@kit.ArkWeb'; 
 
@Entry 
@Component 
struct SlidingConflictBetweenWebAndList { 
  webviewController: webview.WebviewController = new webview.WebviewController(); 
 
  build() { 
    List() { 
      ListItem() { 
        Web({ 
          src: $rawfile('index.html'), 
          controller: this.webviewController 
        }) 
          .width('100%') 
          .height(220) 
      }.hitTestBehavior(HitTestMode.Block) 
      ListItem() { 
        Web({ 
          src: $rawfile('index.html'), 
          controller: this.webviewController 
        }) 
          .width('100%') 
          .height(220) 
      } 
      ListItem() { 
        Text('1') 
      } 
      .height(220) 
      ListItem() { 
        Text('2') 
      } 
      .height(220) 
    } 
    .backgroundColor(Color.Blue) 
    .width('100%') 
    .height('100%') 
  } 
}
```


参考链接


触摸测试控制


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-19
爬取时间: 2025-05-08 04:47:15
来源: Huawei Developer


通过给外层Tabs设置scrollable(false)实现两层Tabs嵌套底部导航+顶部导航的组合，参考代码如下：


```less
@Entry
@Component
struct TwoLayerTabNestedSliding {
  build() {
    Column() {
      Tabs({ barPosition: BarPosition.End }) {
        TabContent() {
          Column() {
            Tabs() {
              TabContent() {
                Text('关注的内容')
              }
              .tabBar('关注')
              TabContent() {
                Text('游戏的内容')
              }
              .tabBar('游戏')
            }
          }
          .backgroundColor('#f08a34')
          .width('100%')
        }
        .tabBar('首页')
        TabContent() {
          Column() {
            Tabs() {
              TabContent() {
                Text('科技的内容')
              }
              .tabBar('科技')
              TabContent() {
                Text('视频的内容')
              }
              .tabBar('视频')
            }
          }
          .backgroundColor('#f08a34')
          .width('100%')
        }
        .tabBar('发现')
      }
      .scrollable(false)
    }
    .width('100%')
    .height('100%')
  }
}
```


效果如图所示。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160833.77659342862390669509171554722423:50001231000000:2800:77CB9E9FB1B0805F93E2D02D6833ACD6F6B23C5A5E70B36565796ADDA31BFCC2.png)

参考链接


限制导航栏的滑动切换


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-20
爬取时间: 2025-05-08 04:47:25
来源: Huawei Developer


当某组件处于获焦状态时，将其的focusable属性或enabled属性设置为false，会自动使该组件失焦，然后焦点按照走焦规则将焦点转移给其他组件。参考代码如下：


```typescript
@Entry 
@Component 
struct ClearComponentFocus { 
  @State textFocusable: boolean = true; 
  @State text: string = '获得焦点'; 
 
  build() { 
    Column() { 
      TextInput({ text: this.text }) 
        .focusable(this.textFocusable) 
        .onFocus(() => { 
          this.text = '获得焦点'; 
        }) 
        .onBlur(() => { 
          this.text = '失去焦点'; 
        }) 
      Button('Button1') 
        .width(160) 
        .height(70) 
        .margin({ top: 20 }) 
        .onClick(() => { 
          this.textFocusable = !this.textFocusable; 
        }) 
    } 
    .width('100%') 
    .height('100%') 
  } 
}
```


参考链接


设置组件是否获焦


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-21
爬取时间: 2025-05-08 04:47:35
来源: Huawei Developer


```typescript
// xxx.ets 
import { font } from '@kit.ArkUI'; 
 
@Entry 
@Component 
struct FontExample { 
  @State message: string = 'Hello World'; 
 
  aboutToAppear() { 
    // 注册黑色字体 
    font.registerFont({ 
      familyName: 'Condensed_Black', // 注册的字体名称 
      familySrc: '/font/Sans_Condensed_Black.ttf' // font文件夹与pages目录同级 
    }) 
 
    // 注册黑色斜字体 
    font.registerFont({ 
      familyName: 'Condensed_Black_Italic', // 注册的字体名称 
      familySrc: '/font/Sans_Condensed_Black_Italic.ttf' // font文件夹与pages目录同级 
    }) 
  } 
 
  build() { 
    Column() { 
      Text(this.message) 
        .align(Alignment.Center) 
        .fontSize(50) 
        .fontFamily('Condensed_Black') // 使用黑色字体 
      Text(this.message) 
        .align(Alignment.Center) 
        .fontSize(50) 
        .fontFamily('Condensed_Black_Italic') // 使用黑色斜字体 
      Text(this.message) 
        .align(Alignment.Center) 
        .fontSize(50) 
    } 
    .width('100%') 
    .margin({ top: 30 }) 
  } 
}
```


效果如图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160833.22973556623042354928159025313789:50001231000000:2800:58861B341812CECF3CA3EC6090C1CBA2F31991DC77CE9C96A8B8BD98E8AD0D4E.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-23
爬取时间: 2025-05-08 04:47:44
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-25
爬取时间: 2025-05-08 04:47:54
来源: Huawei Developer


可通过List组件的sticky属性配合ListItemGroup组件来实现。通过给List组件设置sticky属性为StickyStyle.Header/StickyStyle.Footer。可参考如下代码：


```less
// xxx.ets 
@Entry 
@Component 
struct ListItemGroupExample { 
  private timeTable: TimeTable[] = [ 
    { 
      title: '星期一', 
      projects: ['语文', '数学', '英语'] 
    }, 
    { 
      title: '星期二', 
      projects: ['物理', '化学', '生物'] 
    }, 
    { 
      title: '星期三', 
      projects: ['历史', '地理', '政治'] 
    }, 
    { 
      title: '星期四', 
      projects: ['美术', '音乐', '体育'] 
    } 
  ] 
 
  @Builder 
  itemHead(text: string) { 
    Text(text) 
      .fontSize(20) 
      .backgroundColor(0xAABBCC) 
      .width("100%") 
      .padding(10) 
  } 
 
  @Builder 
  itemFoot(num: number) { 
    Text('共' + num + "节课") 
      .fontSize(16) 
      .backgroundColor(0xAABBCC) 
      .width("100%") 
      .padding(5) 
  } 
 
  build() { 
    Column() { 
      List({ space: 20 }) { 
        ForEach(this.timeTable, (item: TimeTable) => { 
          ListItemGroup({ header: this.itemHead(item.title), footer: this.itemFoot(item.projects.length) }) { 
            ForEach(item.projects, (project: string) => { 
              ListItem() { 
                Text(project) 
                  .width("100%") 
                  .height(100) 
                  .fontSize(20) 
                  .textAlign(TextAlign.Center) 
                  .backgroundColor(0xFFFFFF) 
              } 
            }, (item: string) => item) 
          } 
          .divider({ strokeWidth: 1, color: Color.Blue }) // 每行之间的分界线 
        }) 
      } 
      .width('90%') 
      .sticky(StickyStyle.Header | StickyStyle.Footer) 
      .scrollBar(BarState.Off) 
    } 
    .width('100%') 
    .height('100%') 
    .backgroundColor(0xDCDCDC) 
    .padding({ top: 5 }) 
  } 
} 
 
interface TimeTable { 
  title: string; 
  projects: string[]; 
}
```


效果如图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160833.73830782219044692472893349344310:50001231000000:2800:6DE708639D4FA7314055D524074757D0E5AC2F7D6E7E9A6BAA26BCF255A0872A.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-26
爬取时间: 2025-05-08 04:48:04
来源: Huawei Developer


可能原因


当List组件中的子项比较多时，同级有其它组件，会下压List，导致显示异常。


解决措施


给List组件设置layoutWeight()属性。layoutWeight()可以自适应占满剩余空间父容器尺寸。父容器确定时，设置了layoutWeight的子元素在主轴布局尺寸按照权重进行分配，忽略本身尺寸设置。可参考如下代码：


```less
// xxx.ets 
@Entry 
@Component 
struct ListExample { 
  @State arr: string[] = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15']; 
  scroller: Scroller = new Scroller(); 
 
  build() { 
    Column() { 
      RichText('') 
        .width('90%') 
        .height(300) 
        .backgroundColor(0XBDDB69) 
      List({ space: 22, initialIndex: 0, scroller: this.scroller }) { 
        ForEach(this.arr, (item: string) => { 
          ListItem() { 
            Text(item) 
              .width('100%') 
              .height(100) 
              .fontSize(16) 
              .textAlign(TextAlign.Center) 
              .borderRadius(10) 
              .backgroundColor(0xFFFFFF) 
          } 
        }, (item: string) => item) 
      } 
      .layoutWeight(1) // 自适应占满剩余空间 
      .listDirection(Axis.Vertical) // 排列方向 
      .divider({ strokeWidth: 2, color: 0xFFFFFF, startMargin: 20, endMargin: 20 }) // 每行之间的分界线 
      .edgeEffect(EdgeEffect.Spring) // 滑动到边缘无效果 
      .scrollBar(BarState.Off) // 设置滚动条 
      .margin({ top: 20 }) 
      .width('90%') 
    } 
    .width('100%') 
    .height('100%') 
    .backgroundColor(0xDCDCDC) 
  } 
}
```


效果如图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160833.85693946795344318415776787707644:50001231000000:2800:EEFE9B651705EE25AB4CC1DC7B9EA12827BD74141B9D0700E0E054E38DB2471A.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-27
爬取时间: 2025-05-08 04:48:14
来源: Huawei Developer


给List组件设置List组件的lanes属性，可设置List组件在交叉轴按几列布局。可参考如下代码：


```less
// xxx.ets 
@Entry 
@Component 
struct ListExample { 
  @State arr: string[] = ['1', '2', '3', '4', '5', '6', '7', '8', '9']; 
 
  build() { 
    Column() { 
      List() { 
        ForEach(this.arr, (item: string) => { 
          ListItem() { 
            Row() { 
              Text(item) 
                .fontColor(Color.Red) 
                .fontSize(40) 
            } 
          } 
          .width('100%') 
          .border({ 
            width: 1, 
            color: Color.Black, 
            radius: 5 
          }) 
        }) 
      } 
      .lanes(3) 
      .alignListItem(ListItemAlign.Center) 
    } 
    .padding({ top: 30 }) 
  } 
}
```


效果如图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160833.82554250111688365762280225687162:50001231000000:2800:038472A9B33EAF1DEDC8EBF677F7DD42CA16BE7905BF81248B9F69C02EE1E48B.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-28
爬取时间: 2025-05-08 04:48:23
来源: Huawei Developer


ListItemGroup中的ListItemGroupStyle设置分组列表的圆角，List的space设置间距。可参考如下代码：


```less
// xxx.ets 
@Entry 
@Component 
struct ListItemGroupExample { 
  private timeTable: TimeTable[] = [ 
    { projects: ['语文'] }, 
    { projects: ['数学', '英语'] }, 
    { projects: ['物理', '化学', '生物'] }, 
    { projects: ['美术', '音乐', '体育'] } 
  ] 
 
  build() { 
    Column() { 
      List({ space: 20 }) { // 设置分组列表的间距 
        ForEach(this.timeTable, (item: TimeTable) => { 
          ListItemGroup({ style: ListItemGroupStyle.CARD }) { // 设置分组列表的圆角 
            ForEach(item.projects, (project: string) => { 
              ListItem() { 
                Text(project) 
                  .width("100%") 
                  .height(100) 
                  .fontSize(20) 
                  .textAlign(TextAlign.Center) 
                  .backgroundColor(0xFFFFFF) 
              } 
            }, (item: string) => item) 
          } 
        }) 
      } 
      .width('90%') 
      .sticky(StickyStyle.Header | StickyStyle.Footer) 
      .scrollBar(BarState.Off) 
    } 
    .width('100%') 
    .height('100%') 
    .backgroundColor(0xDCDCDC) 
    .padding({ top: 5, bottom: 5 }) 
  } 
} 
 
interface TimeTable { 
  projects: string[]; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-30
爬取时间: 2025-05-08 04:48:33
来源: Huawei Developer

- 方法1：用if条件渲染，可以通过变量去控制显隐，然后使用@Watch监听变量就可以知道组件是否显示隐藏。
- 方法2：当组件显示或隐藏时，生命周期aboutToAppear()和aboutToDisappear()会生效，可以感知到组件是否显示隐藏。

具体可参考示例代码：


```typescript
@Component 
struct componentA { 
  aboutToAppear(): void { 
    // 感知组件显隐 
    console.log('A组件显示'); 
  } 
 
  aboutToDisappear(): void { 
    // 感知组件显隐 
    console.log('A组件隐藏'); 
  } 
 
  build() { 
    Column() { 
      Text('组件A').fontSize(16).fontColor(Color.Black); 
    } 
    .width(100) 
    .height(50) 
  } 
} 
 
@Entry 
@Component 
struct componentB { 
  @State @Watch('onCompAShowStatusChange') isShowA: boolean = false; 
  onCompAShowStatusChange() { 
    // 感知组件显隐 
    console.log('监听A组件：' + `${this.isShowA ? '显示' : '隐藏'}`); 
  } 
 
  build() { 
    Column() { 
      Button('切换显隐').type(ButtonType.Normal).width(100).height(50).onClick(() => { 
        this.isShowA = !this.isShowA; 
      }) 
      if (this.isShowA) { 
        componentA(); 
      } 
    } 
  } 
}
```


参考链接


@Watch装饰器：状态变量更改通知、if/else：条件渲染


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-31
爬取时间: 2025-05-08 04:48:42
来源: Huawei Developer

- ArkUI提供了一种更轻量的UI元素复用机制@Builder，@Builder所装饰的函数遵循build()函数语法规则，开发者可以将重复使用的UI元素抽象成一个方法，在build方法里调用。

```less
@Component
struct Child {
  @Builder FunABuilder0() {}
  @BuilderParam aBuilder0: () => void = this.FunABuilder0;


  build() {
    Column() {
      this.aBuilder0()
    }
  }
}


@Entry
@Component
struct Parent {
  @Builder componentBuilder() {
    Text(`Parent builder `)
  }


  build() {
    Column() {
      Child({ aBuilder0: this.componentBuilder })
    }
  }
}
```


参考链接


@Builder装饰器


@BuilderParam装饰器


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-32
爬取时间: 2025-05-08 04:48:52
来源: Huawei Developer


父组件全屏，子组件默认撑满，再设置左右margin值，实际上子组件会超出屏幕范围外边距。可以使用constraintSize属性来限制最大宽高。参考代码如下：


```less
@Entry 
@Component 
struct Index { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .textAlign(TextAlign.Center) 
          .width('100%') 
          .constraintSize({ maxWidth: '100%' }) 
          .backgroundColor(Color.Blue) 
          .margin({ left: 50, right: 50 }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


尺寸设置中的constraintSize


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-33
爬取时间: 2025-05-08 04:49:02
来源: Huawei Developer


使用PanGesture拖动手势事件结合animateTo显示动画可以实现惯性滑动效果，参考代码如下：


```less
@Entry
@Component
struct PanGestureExample {
  @State offsetX: number = 0;
  @State offsetY: number = 0;
  @State positionX: number = 0;
  @State positionY: number = 0;
  private panOption: PanGestureOptions = new PanGestureOptions({ direction: PanDirection.Up | PanDirection.Down });


  build() {
    Column() {
      Text('PanGesture offset:\nX: ' + this.offsetX + '\n' + 'Y: ' + this.offsetY)
    }
    .height(300)
    .width(300)
    .padding(20)
    .border({ width: 3 })
    .margin(30)
    .translate({ x: this.offsetX, y: this.offsetY, z: 0 }) // 以组件左上角为坐标原点进行移动
    // 上下拖动触发该手势事件
    .gesture(
      PanGesture(this.panOption)
        .onActionStart((event?: GestureEvent) => {
          console.info('Pan start');
        })
        .onActionUpdate((event?: GestureEvent) => {
          if (event) {
            animateTo({
              curve: Curve.LinearOutSlowIn,
              iterations: 1,
              tempo: 10000,
              playMode: PlayMode.Normal,
              onFinish: () => {
                console.info('play end');
              }
            }, () => {
              this.offsetX = this.positionX + event.offsetX;
              this.offsetY = this.positionY + event.offsetY;
            })
          }
        })
        .onActionEnd((event?: GestureEvent) => {
          if (event) {
            animateTo({
              curve: Curve.LinearOutSlowIn,
              iterations: 1,
              playMode: PlayMode.Normal,
              onFinish: () => {
                console.info('play end');
              }
            }, () => {
              this.offsetX = this.positionX + event.offsetX * 2;
              this.offsetY = this.positionY + event.offsetY * 2;
            })
          }
          this.positionX = this.offsetX;
          this.positionY = this.offsetY;
          console.info('Pan end');
        })
    )
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-34
爬取时间: 2025-05-08 04:49:12
来源: Huawei Developer


应用可以通过display.on监听屏幕状态改变。


实现页面跟随屏幕横竖屏自动旋转的方法：


1、Ability级别配置：在模块配置文件module.json5中将EntryAbility设置为"orientation"。


2、动态设置：使用window.setPreferredOrientation设置窗口方向。


```typescript
import { window, display } from '@kit.ArkUI'; 
 
const TAG = 'foo' 
const ORIENTATION: Array<string> = ['垂直', '水平', '反向垂直', '反向水平'] 
 
@Entry 
@Component 
struct ScreenTest { 
  @State rotation: number = 0 
  @State message: string = ORIENTATION[this.rotation] 
 
  aboutToAppear() { 
    this.setOrientation() 
 
    let callback = async () => { 
      // ... 
    } 
    try { 
      display.on("change", callback); // 监听屏幕状态改变 
    } catch (exception) { 
      console.error(TAG, 'Failed to register callback. Code: ' + JSON.stringify(exception)); 
    } 
  } 
 
  setOrientation() { 
    try { 
      window.getLastWindow(getContext(this), (err, data) => { // 获取window实例 
        if (err.code) { 
          console.error(TAG, 'Failed to obtain the top window. Cause: ' + JSON.stringify(err)); 
          return; 
        } 
        let windowClass = data; 
        console.info(TAG, 'Succeeded in obtaining the top window. Data: ' + JSON.stringify(data)); 
 
        let orientation = window.Orientation.AUTO_ROTATION; // 设置窗口方向为传感器自动旋转模式。 
        try { 
          windowClass.setPreferredOrientation(orientation, (err) => { 
            if (err.code) { 
              console.error(TAG, 'Failed to set window orientation. Cause: ' + JSON.stringify(err)); 
              return; 
            } 
            console.info(TAG, 'Succeeded in setting window orientation.'); 
          }); 
        } catch (exception) { 
          console.error(TAG, 'Failed to set window orientation. Cause: ' + JSON.stringify(exception)); 
        } 
        ; 
      }); 
    } catch (exception) { 
      console.error(TAG, 'Failed to obtain the top window. Cause: ' + JSON.stringify(exception)); 
    } 
    ; 
  } 
 
  build() { 
    Row() { 
      Column() { 
        Text(`${this.rotation}`).fontSize(25) 
        Text(`${this.message}`).fontSize(25) 
      } 
      .width("100%") 
    } 
    .height("100%") 
  } 
}
```


参考链接


display.on、设置窗口的显示方向属性


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-40
爬取时间: 2025-05-08 04:49:21
来源: Huawei Developer


1. 系统会基于触摸测试来收集需要响应事件的控件，测试的顺序由父组件向子组件蔓延，后续手势的识别和竞争都基于hittest结果进行；


2. 应用可通过改变组件上 hitTestBehavior 的值来改变系统对其的hittest结果；


3. 更进一步的可通过自定义事件和自定义手势判定能力来细化对手势识别和竞争结果的干预；


参考链接


触摸测试控制、自定义事件分发、自定义手势判定


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-41
爬取时间: 2025-05-08 04:49:31
来源: Huawei Developer


ForEach/LazyForEach刷新原理：如果开发者没有写keyGenerator，框架会自动基于item和index生成key， 如果函数缺省，框架默认的键值生成函数为(item: T, index: number) => { return index + '__' + JSON.stringify(item); }， 修改状态变量数据源时，要ForEach或LazyForEach会捕捉到key的变化，从而通过重建组件节点来刷新。


参考链接


LazyForEach：数据懒加载、ForEach：循环渲染


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-42
爬取时间: 2025-05-08 04:49:41
来源: Huawei Developer


Canvas组件最终的显示内容分两种：


一是组件通用属性的绘制内容，比如背景色，boarder等这类组件属性方法设置的渲染属性，这类属性是可以通过状态变量驱动更新的。


二是通过CanvasRenderingContext2D绘制接口由应用自行绘制的内容。该类命令绘制时接口不响应状态变量，只要调用就会在下一帧刷新绘制内容，不需要开发者主动控制刷新。


参考链接


CanvasRenderingContext2D


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-43
爬取时间: 2025-05-08 04:49:51
来源: Huawei Developer


键盘弹出时的避让可以利用安全区域接口expandSafeArea进行UI逻辑避让控制。


参考链接


安全区域


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-45
爬取时间: 2025-05-08 04:50:00
来源: Huawei Developer


屏幕像素单位：px。屏幕上的实际像素，1px代表手机屏幕上的一个像素点。


视窗逻辑像素单位：lpx。视窗逻辑像素单位，lpx单位为实际屏幕宽度与逻辑宽度（通过designWidth配置）的比值，designWidth默认值为720。当designWidth为720时，在实际宽度为1440物理像素的屏幕上，1lpx为2px大小。


虚拟像素单位：vp。屏幕密度相关像素，根据屏幕像素密度转换为屏幕物理像素，当数值不带单位时，默认单位vp。vp与px的比例与屏幕像素密度有关。


以屏幕相对像素为单位，是一台设备针对应用而言所具有的虚拟尺寸（区别于屏幕硬件本身的像素单位）。它提供了一种灵活的方式来适应不同屏幕密度的显示效果，使用虚拟像素，使元素在不同密度的设备上具有一致的视觉体量。


字体像素单位：fp。字体像素大小默认情况下与 vp 相同，即默认情况下 1 fp = 1vp。如果用户在设置中选择了更大的字体，字体的实际显示大小就会在vp的基础上乘以scale系数，即 1 fp = 1 vp * scale。


Percentage- 需要指定以%像素单位，如'10%'。


Resource- 资源引用类型，用于设置组件属性的值。


可以通过$r或者$rawfile创建Resource类型对象，不可以修改Resource中的各属性的值。


其他单位与px单位互相转换的方法请参见：像素单位转换


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-46
爬取时间: 2025-05-08 04:50:10
来源: Huawei Developer


在Text组件入参content中使用字符串，在字符串中转义Unicode编码，示例代码如下：


```less
@Entry 
@Component 
struct text { 
  build() { 
    Column() { 
      Text("\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}") 
        .width(100) 
        .height(100) 
        .fontSize(50) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-47
爬取时间: 2025-05-08 04:50:19
来源: Huawei Developer


在工程中存放开发者自定义字体资源文件，代码中通过registerFont接口进行自定义字体注册，便可以在文本组件中使用fontFamily属性使用。


推荐使用$rawfile方式引用自定义字体资源，资源可放在resources/rawfile目录下。


获取字体资源可参考如下代码：


```less
font.registerFont({ 
  familyName: 'Gealova', 
  familySrc: $rawfile('font/gealova.otf') 
})
```


参考链接


@ohos.font (注册自定义字体)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-49
爬取时间: 2025-05-08 04:50:29
来源: Huawei Developer


AppStorage支持应用的主线程内多个UIAbility实例间的状态共享。AppStorage是UI相关的数据，需要运行在UI线程，无法将对象共享到其他线程。目前暂无替代方案。


参考链接


AppStorage：应用全局的UI状态存储


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-50
爬取时间: 2025-05-08 04:50:39
来源: Huawei Developer


使用@Watch回调来监测状态变量的变化，如果执行回调函数，说明在下一次VSync信号发送时，使用该状态变量的UI会刷新绘制。


参考代码如下：


```typescript
@Component 
struct TotalView { 
  @Prop @Watch('onCountUpdated') count: number = 0; 
  @State total: number = 0; 
  // @Watch 回调 
  onCountUpdated(propName: string): void { 
    this.total += this.count; 
  } 
 
  build() { 
    Text(`Total: ${this.total}`) 
  } 
} 
 
@Entry 
@Component 
struct CountModifier { 
  @State count: number = 0; 
 
  build() { 
    Column() { 
      Button('add to basket') 
        .onClick(() => { 
          this.count++ 
        }) 
      TotalView({ count: this.count }) 
    } 
  } 
}
```


参考链接


watch和自定义组件更新


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-53
爬取时间: 2025-05-08 04:50:49
来源: Huawei Developer


可通过setKeyboardAvoidMode接口设置键盘避让模式为KeyboardAvoidMode.RESIZE，表示压缩模式。参考代码如下：


```less
// EntryAbility.ets
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { window, KeyboardAvoidMode, UIContext } from '@kit.ArkUI';


export default class EntryAbility extends UIAbility {
  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
  }


  onDestroy(): void {
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
  }
  onWindowStageCreate(windowStage: window.WindowStage) {
    // Main window is created, set main page for this ability
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');


    windowStage.loadContent('pages/Index', (err, data) => {
      let uiContext :UIContext = windowStage.getMainWindowSync().getUIContext();
      uiContext.setKeyboardAvoidMode(KeyboardAvoidMode.RESIZE);
      if (err.code) {
        hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
        return;
      }
      hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
    });
  }


  onWindowStageDestroy(): void {
    // Main window is destroyed, release UI related resources
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
  }


  onForeground(): void {
    // Ability has brought to foreground
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
  }


  onBackground(): void {
    // Ability has back to background
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
  }
}
```


参考链接


setKeyboardAvoidMode


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-54
爬取时间: 2025-05-08 04:50:59
来源: Huawei Developer


原因分析


软件盘弹出的时候默认是顶起输入框，对于输入框以下的显示组件将被遮挡。


解决措施


获取窗口内容规避的区域，规避区域的类型是软键盘区域TYPE_KEYBOARD，当软键盘弹出，获取规避区域的高度，通过margin-bottom来设置，顶起组件。参考代码如下：


```typescript
import { window } from '@kit.ArkUI'; 
 
@Entry 
struct BottomPopsUpAsTheTopOfKeyboard { 
  scroller: Scroller = new Scroller(); 
  private arr: number[] = [0, 1, 2, 3, 4, 5]; 
  @State scrollHeight: number = 0; 
  @State isRebuild: boolean = false; 
  @State keyHeight: number = 0; 
  @State text: string = ''; 
  aboutToAppear() { 
    window.getLastWindow(getContext(this)).then(currentWindow => { 
      // 设置窗口的布局为沉浸式布局 
      currentWindow.setWindowLayoutFullScreen(true); 
      let property = currentWindow.getWindowProperties(); 
      // 初始化窗口高度 
      let avoidArea = currentWindow.getWindowAvoidArea(window.AvoidAreaType.TYPE_KEYBOARD); 
      this.scrollHeight = px2vp(property.windowRect.height - avoidArea.bottomRect.height); 
      // 监听软键盘的隐藏和显示 
      currentWindow.on('avoidAreaChange', data => { 
        if (data.type == window.AvoidAreaType.TYPE_KEYBOARD) { 
          this.keyHeight = px2vp(data.area.bottomRect.height); 
          this.scrollHeight = 
            px2vp(currentWindow.getWindowProperties().windowRect.height - data.area.bottomRect.height); 
          return; 
        } 
      }) 
    }) 
  } 
  build() { 
    Stack({ alignContent: Alignment.TopStart }) { 
      Column() { 
        Scroll(this.scroller) { 
          Column() { 
            TextInput({ text: this.text, placeholder: 'input your word...' }) 
              .placeholderFont({ 
                size: 14, 
                weight: 400 
              }) 
              .width(320) 
              .height(40) 
              .margin(200) 
              .fontSize(14) 
              .fontColor(Color.Black) 
              .backgroundColor(Color.White) 
            ForEach(this.arr, (item: number) => { 
              Text(item.toString()) 
                .width('90%') 
                .height(150) 
                .backgroundColor(0xFFFFFF) 
                .borderRadius(15) 
                .fontSize(16) 
                .textAlign(TextAlign.Center) 
                .margin({ top: 10 }) 
            }) 
          } 
          .width('100%') 
        } 
        .width('100%') 
        .height(this.scrollHeight) 
        .layoutWeight(1) 
        Text('这是一个测试文本') 
          .width('100%') 
          .height(50) 
          .backgroundColor(Color.Red) 
          .margin({ bottom: this.keyHeight }) 
      } 
      .width('100%') 
      .height('100%') 
      .justifyContent(FlexAlign.Start) 
    } 
    .width('100%') 
    .height('100%') 
    .backgroundColor(0xDCDCDC) 
  } 
}
```


参考链接


内容规避区


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-55
爬取时间: 2025-05-08 04:51:09
来源: Huawei Developer


组件通用属性linearGradientBlur，可以为当前组件添加内容线性渐变模糊效果。参考代码如下：


```less
@Entry 
@Component 
struct ImageExample1 { 
  private_resource1: Resource = $r('app.media.icon'); 
  @State image_src: Resource = this.private_resource1; 
 
  build() { 
    Column() { 
      Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Start }) { 
        Row({ space: 5 }) { 
          Image(this.image_src) 
            .linearGradientBlur(60, { 
              fractionStops: [[0, 0], [0, 0.33], [1, 0.66], [1, 1]], 
              direction: GradientDirection.Bottom 
            }) 
        } 
      } 
    } 
  } 
}
```


参考链接


渐变模糊


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-56
爬取时间: 2025-05-08 04:51:19
来源: Huawei Developer


Tabs组件的fadingEdge属性表示页签超过容器宽度时是否渐隐消失，默认值为true，设置为false即可去除蒙层。


```less
// xxx.ets
@Entry
@Component
struct TabsOpaque {
  @State message: string = 'Hello World';
  private controller: TabsController = new TabsController();
  @State selfFadingFade: boolean = false; // 页签超过容器宽度时是否渐隐消失，默认值为true。


  build() {
    Column() {
      Tabs({ barPosition: BarPosition.End, controller: this.controller }) {
        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Pink)
        }.tabBar('pink')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Yellow)
        }.tabBar('yellow')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Blue)
        }.tabBar('blue')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green)
        }.tabBar('green')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green)
        }.tabBar('green')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green)
        }.tabBar('green')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green)
        }.tabBar('green')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green)
        }.tabBar('green')
      }
      .vertical(false)
      .scrollable(true)
      .barMode(BarMode.Scrollable)
      .barHeight(80)
      .animationDuration(400)
      .onChange((index: number) => {
        console.info(index.toString());
      })
      .fadingEdge(this.selfFadingFade)
      .height('30%')
      .width('100%')
    }
    .padding({ top: '24vp', left: '24vp', right: '24vp' })
  }
}
```


参考链接


Tabs组件-属性


子页签设置渐隐/不渐隐


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-57
爬取时间: 2025-05-08 04:51:28
来源: Huawei Developer


可以使用@ohos.measure中的接口MeasureText计算指定文本单行布局下的宽度，具体可参考如下代码：


```typescript
import { MeasureText } from '@kit.ArkUI' 
 
@Entry 
@Component 
struct Index { 
  @State textWidth: number = MeasureText.measureText({ 
    textContent: "Hello word", 
    fontSize: '50px' 
  }) 
 
  build() { 
    Row() { 
      Column() { 
        Text(`The width of 'Hello World': ${this.textWidth}`) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


@ohos.measure (文本计算)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-58
爬取时间: 2025-05-08 04:51:39
来源: Huawei Developer


布局会根据元素自身内容设置需要的高度，可以不设置缺省。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-59
爬取时间: 2025-05-08 04:51:48
来源: Huawei Developer


自定义弹窗作为自定义组件的一种，拥有自定义组件生命周期aboutToAppear和aboutToDisappear。


onPageShow和onPageHide仅作为页面生命周期提供，@Entry修饰的自定义组件定义为页面，不适用于自定义弹窗。


参考链接


页面和自定义组件生命周期


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-60
爬取时间: 2025-05-08 04:51:58
来源: Huawei Developer


尺寸大于toolbar底部高度的图片，可以使用scale属性进行设置。参考代码如下：


```less
@Entry 
@Component 
struct NavigationExample { 
  build() { 
    Column() { 
      Navigation() { 
      }.toolbarConfiguration(this.NavigationToolbar) 
    } 
    .height('100%') 
    .width('100%') 
    .backgroundColor(Color.Gray) 
  } 
 
  @Builder 
  NavigationToolbar() { 
    Row() { 
      Column() { 
        Image($r('app.media.icon')).width(24) 
      }.layoutWeight(1) 
 
      Column() { 
        Image($r('app.media.icon')).width(24).scale({ x: 2, y: 2 }) 
      }.layoutWeight(1) 
 
      Column() { 
        Image($r('app.media.icon')).width(24) 
      }.layoutWeight(1) 
    } 
    .height(34) 
    .width('100%').backgroundColor(Color.White) 
  } 
}
```


参考链接


图形变换


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-61
爬取时间: 2025-05-08 04:52:08
来源: Huawei Developer


Image有长按触发拖拽属性，和长按弹出菜单冲突，需要将图片的draggable属性设置为false。参考代码如下：


```less
@Entry 
@Component 
struct Index { 
  @Builder 
  MenuBuilder() { 
    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) { 
      Button('Test ContextMenu1') 
      Divider().strokeWidth(2).margin(5).color(Color.Black) 
      Button('Test ContextMenu2') 
      Divider().strokeWidth(2).margin(5).color(Color.Black) 
      Button('Test ContextMenu3') 
    } 
    .width(200) 
    .height(160) 
  } 
 
  build() { 
    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) { 
      Column() { 
        Image($r('app.media.icon')) 
          .draggable(false) 
          .width('100vp') 
      } 
      .bindContextMenu(this.MenuBuilder, ResponseType.LongPress) 
      .onDragStart(() => { 
        // 拖拽时关闭菜单 
        ContextMenu.close() 
      }) 
 
    } 
    .width('100%') 
    .height('100%') 
  } 
}
```


参考链接


菜单控制，Image组件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-62
爬取时间: 2025-05-08 04:52:17
来源: Huawei Developer


```less
@Entry
@Component
struct ListExample {
  @State arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];
  private scroller: Scroller = new Scroller();


  build() {
    Stack() {
      List({ space: 10 }) {
        ForEach(this.arr, (item: string) => {
          ListItem() {
            Text("中国潮色")
              .width(100)
              .height(64)
              .fontColor(Color.White)
              .backgroundColor(Color.Black)
              .textAlign(TextAlign.Center)
          }
        }, (item: string) => item);
      }
      .listDirection(Axis.Horizontal)
      .scrollBar(BarState.Off)
      .padding({ top: 20, bottom: 20 })
      .width("80%")
      .height("100%")


      Stack() {


      }
      .linearGradient({
        angle: 90,
        colors: [[0x000000, 0.0], ['rgba(0,0,0,0)', 0.1], ['rgba(0,0,0,0)', 0.9], [0x000000, 1.0]]
      })
      .width("80%")
      .height("100%")
      .hitTestBehavior(HitTestMode.None)
    }.height(100).width('100%').backgroundColor(Color.Black)
  }
}
```


```less
@Entry
@Component
struct TabsOpaque {
  @State message: string = 'Hello World';
  private controller: TabsController = new TabsController();
  private controller1: TabsController = new TabsController();
  @State selfFadingFade: boolean = true;


  build() {
    Column() {
      Button('子页签设置渐隐').width('100%').margin({ bottom: '12vp' })
        .onClick((event?: ClickEvent) => {
          this.selfFadingFade = true;
        })
      Button('子页签设置不渐隐').width('100%').margin({ bottom: '12vp' })
        .onClick((event?: ClickEvent) => {
          this.selfFadingFade = false;
        })
      Tabs({ barPosition: BarPosition.End, controller: this.controller }) {
        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Pink)
        }.tabBar('pink')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Yellow)
        }.tabBar('yellow')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Blue)
        }.tabBar('blue')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green)
        }.tabBar('green')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green)
        }.tabBar('green')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green)
        }.tabBar('green')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green)
        }.tabBar('green')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green)
        }.tabBar('green')
      }
      .vertical(false)
      .scrollable(true)
      .barMode(BarMode.Scrollable)
      .barHeight(80)
      .animationDuration(400)
      .onChange((index: number) => {
        console.info(index.toString());
      })
      .fadingEdge(this.selfFadingFade)
      .height('30%')
      .width('100%')


      Tabs({ barPosition: BarPosition.Start, controller: this.controller1 }) {
        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Pink)
        }.tabBar('pink')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Yellow)
        }.tabBar('yellow')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Blue)
        }.tabBar('blue')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green)
        }.tabBar('green')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green)
        }.tabBar('green')


        TabContent() {
          Column().width('100%').height('100%').backgroundColor(Color.Green)
        }.tabBar('green')
      }
      .vertical(true)
      .scrollable(true)
      .barMode(BarMode.Scrollable)
      .barHeight(200)
      .barWidth(80)
      .animationDuration(400)
      .onChange((index: number) => {
        console.info(index.toString());
      })
      .fadingEdge(this.selfFadingFade)
      .height('30%')
      .width('100%')
    }
    .padding({ top: '24vp', left: '24vp', right: '24vp' })
  }
}
```


参考链接


Tabs组件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-65
爬取时间: 2025-05-08 04:52:27
来源: Huawei Developer


SideBarContainer组件提供了侧边栏可以显示和隐藏的侧边栏容器，它的controlButton属性可以设置侧边栏控制按钮的属性。参考代码如下：


```less
@Entry 
@Component 
struct SideBarContainerExample { 
  normalIcon: Resource = $r("app.media.icon") 
  selectedIcon: Resource = $r("app.media.icon") 
  @State arr: number[] = [1, 2, 3] 
  @State current: number = 1 
 
  build() { 
    SideBarContainer(SideBarContainerType.Embed) { 
      Column() { 
        ForEach(this.arr, (item: number, index) => { 
          Column({ space: 5 }) { 
            Image(this.current === item ? this.selectedIcon : this.normalIcon).width(64).height(64) 
            Text("Index0" + item) 
              .fontSize(25) 
              .fontColor(this.current === item ? '#0A59F7' : '#999') 
              .fontFamily('source-sans-pro,cursive,sans-serif') 
          } 
          .onClick(() => { 
            this.current = item 
          }) 
        }) 
      }.width('100%') 
      .justifyContent(FlexAlign.SpaceEvenly) 
      .backgroundColor('#19000000') 
 
      Column() { 
        Text('SideBarContainer content text1').fontSize(25) 
        Text('SideBarContainer content text2').fontSize(25) 
      } 
      .margin({ top: 50, left: 20, right: 30 }) 
    } 
    .sideBarWidth(150) 
    .minSideBarWidth(50) 
    .controlButton({ 
      left: 32, 
      top: 32, 
      width: 32, 
      height: 32, 
      icons: { shown: $r("app.media.icon"), 
        hidden: $r("app.media.icon"), 
        switching: $r("app.media.icon") } 
    }) 
    .maxSideBarWidth(300) 
    .onChange((value: boolean) => { 
      console.info('status:' + value) 
    }) 
  } 
}
```


参考链接


SideBarContainer


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-66
爬取时间: 2025-05-08 04:52:37
来源: Huawei Developer


可以使用媒体查询接口监听屏幕旋转。参考代码如下：


```less
import { mediaquery } from '@kit.ArkUI'; 
let listener = mediaquery.matchMediaSync('(orientation: landscape)'); // 监听横屏事件 
function onPortrait(mediaQueryResult: mediaquery.MediaQueryResult) { 
  if (mediaQueryResult.matches) { 
   // do something here 
  } else { 
   // do something here 
  } 
} 
listener.on('change', onPortrait) // 注册回调 
listener.off('change', onPortrait) // 取消注册回调
```


参考链接


媒体查询


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-67
爬取时间: 2025-05-08 04:52:46
来源: Huawei Developer


步骤一：通过getLastWindow()、createWindow()、findWindow()中的任一方法获取到Window实例。


步骤二：通过设置setPreferredOrientation属性来设置窗口的显示方向属性，使用callback异步回调。参数Orientation提供了窗口显示方向类型枚举。


在EntryAbility.ets中的onWindowStageCreate方法中将WindowStage设置一个AppStorage。参考代码如下:


```less
AppStorage.setOrCreate('windowStage',windowStage);
```


通过setPreferredOrientation可以设置旋转模式。


```typescript
import { display, window } from '@kit.ArkUI'; 
 
@Component 
struct ScreenRotation { 
  windowStage: window.WindowStage = AppStorage.get('windowStage') as window.WindowStage; 
  // 获取主窗口的方式 
  mainWin: window.Window = this.windowStage.getMainWindowSync(); 
 
  onPageShow() { 
    // 获取最上层窗口的方式 
    window.getLastWindow(getContext(this)); 
    this.mainWin.setPreferredOrientation(window.Orientation.LANDSCAPE); 
    // 使用display接口获取当前旋转方向，可以放置在监听中持续获取 
    display.getDefaultDisplaySync().rotation; 
  } 
 
  build() { 
    Row() { 
      Column({ space: 10 }) { 
        Text('屏幕旋转demo') 
          .fontSize(25) 
          .margin(20) 
          .fontColor(0x3399FF) 
      }.width('100%') 
    }.height('100%').backgroundColor(Color.White) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-69
爬取时间: 2025-05-08 04:52:56
来源: Huawei Developer

- 方式一（推荐）：使用@Provider和@Consumer装饰器。在父组件使用@Provider，在孙子组件使用@Consumer，可以实现父组件和孙子组件进行双向数据绑定。
1. 

```less
@Entry
@ComponentV2
struct Father{
  @Provider("reviewVote") reviewVotes: number = 0;


  build() {
    Column() {
      Son()
      Button(`Father: ${this.reviewVotes}`)
    }
  }
}
```

2. 

```less
@ComponentV2
struct Son{
  build() {
    Column() {
      Grandson()
    }
  }
}
```

3. 

```less
@ComponentV2
struct Grandson{
  @Consumer("reviewVote") reviewVotes: number = 0;


  build() {
    Column() {
      Button(`Grandson: ${this.reviewVotes}`)
    }.width('100%')
  }
}
```

- 方式二：使用@Local和@Param装饰器。在父组件使用@Local，在每一层子组件（子组件和孙子组件）都使用@Param。
1. 

```less
@Entry
@ComponentV2
struct Father {
  @Local reviewVotes: number = 0;


  build() {
    Column() {
      Son({ reviewVotes: this.reviewVotes })
      Button(`Father: ${this.reviewVotes}`)
    }
  }
}
```

2. 

```less
@ComponentV2
struct Son {
  @Require @Param reviewVotes: number = 1;


  build() {
    Column() {
      Grandson({ reviewVotes: this.reviewVotes })
    }
  }
}
```

3. 

```less
@ComponentV2
struct Grandson {
  @Require @Param reviewVotes: number = 1;


  build() {
    Column() {
      Button(`Grandson: ${this.reviewVotes}`)
    }.width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-77
爬取时间: 2025-05-08 04:53:06
来源: Huawei Developer


自定义弹窗的定义和初始化需要用到属于ArkTS的语法内容，必须在ets后缀文件中定义使用，不能在ts后缀文件中定义使用。


参考链接


自定义弹窗


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-78
爬取时间: 2025-05-08 04:53:16
来源: Huawei Developer


```typescript
@CustomDialog
struct CustomDialog01 {
  @Link inputValue: string;
  controller: CustomDialogController;


  build() {
    Column() {
      Text('Change text')
        .fontSize(20)
        .margin({ top: 10, bottom: 10 })
      TextInput({ placeholder: '', text: this.inputValue })
        .height(60)
        .width('90%')
        .onChange((value: string) => {
          this.inputValue = value;
        })
    }
  }
}


@Entry
@Component
struct DialogDemo01 {
  @State inputValue: string = 'click me';
  dialogController: CustomDialogController = new CustomDialogController({
    builder: CustomDialog01({
      inputValue: $inputValue
    })
  })


  build() {
    Column() {
      Button(this.inputValue)
        .onClick(() => {
          this.dialogController.open();
        })
        .backgroundColor(0x317aff)
    }
    .width('100%')
    .margin({ top: 5 })
  }
}
```


```typescript
@CustomDialog
struct CustomDialog02 {
  private inputValue: string = '';
  changeInputValue: (val: string) => void = () => {
  };
  controller: CustomDialogController;


  build() {
    Column() {
      Text('Change text')
        .fontSize(20)
        .margin({ top: 10, bottom: 10 })
      TextInput({ placeholder: '', text: this.inputValue })
        .height(60)
        .width('90%')
        .onChange((value: string) => {
          this.changeInputValue(value);
        })
    }
  }
}


@Entry
@Component
struct DialogDemo02 {
  @State inputValue: string = 'click me';
  dialogController: CustomDialogController = new CustomDialogController({
    builder: CustomDialog02({
      inputValue: this.inputValue,
      changeInputValue: (val: string) => {
        this.inputValue = val;
      }
    })
  })


  build() {
    Column() {
      Button(this.inputValue)
        .onClick(() => {
          this.dialogController.open();
        })
        .backgroundColor(0x317aff)
    }
    .width('100%')
    .margin({ top: 5 })
  }
}
```


```typescript
let storage = LocalStorage.getShared();
@CustomDialog
struct CustomDialog03 {
  @LocalStorageLink('inputVal') inputValue: string = '';
  controller: CustomDialogController;


  build() {
    Column() {
      Text('Change text')
        .fontSize(20)
        .margin({ top: 10, bottom: 10 })
      TextInput({ placeholder: '', text: this.inputValue })
        .height(60)
        .width('90%')
        .onChange((value: string) => {
          this.inputValue = value;
        })
    }
  }
}


@Entry(storage)
@Component
struct DialogDemo03 {
  @LocalStorageLink('inputVal') inputValue: string = 'click me';
  dialogController: CustomDialogController = new CustomDialogController({
    builder: CustomDialog03()
  });


  build() {
    Column() {
      Button(this.inputValue)
        .onClick(() => {
          this.dialogController.open();
        })
        .backgroundColor(0x317aff)
    }
    .width('100%')
    .margin({ top: 5 })
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-80
爬取时间: 2025-05-08 04:53:25
来源: Huawei Developer


将状态变量赋值给TextInput或TextArea组件的text属性，在做点击清空事件时为状态变量赋值空字符串。参考代码如下：


```less
@Entry 
@Component 
struct Index { 
  @State text: string = 'Hello World'; 
  controller: TextInputController = new TextInputController(); 
 
  build() { 
    Row() { 
      Column() { 
        TextInput({ placeholder: 'Please input your words.', text: this.text, 
          controller:this.controller}).onChange((value) => { 
          this.text = value; 
        }) 
        Button('Clear TextInput').onClick(() => { 
          this.text = ''; 
        }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-81
爬取时间: 2025-05-08 04:53:35
来源: Huawei Developer


初始化自定义弹窗时，通过alignment参数设置对齐方式，通过offset设置弹窗偏移量。


参考链接


自定义弹窗 (CustomDialog)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-83
爬取时间: 2025-05-08 04:53:44
来源: Huawei Developer

- 方式一：采用弹窗容器默认样式。在默认样式中，弹窗容器高度自适应子节点，最大可为窗口高度的90%；弹窗容器的宽度根据栅格系统自适应，不跟随子节点变化
- 方式二：当显示设置customStyle为true时，弹窗宽高跟随子节点内容适应。

参考链接


自定义弹窗


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-84
爬取时间: 2025-05-08 04:53:55
来源: Huawei Developer


gridCount参数是指弹窗宽度占栅格列数的个数。系统把窗口宽等分，等分的份数即为栅格列数，不同设备栅格列数不同。比如手机屏幕密度值在320vp<=水平宽度<600vp，所以栅格列数是4，则gridCount的有效值在[1, 4]。


注意：仅采用弹窗默认样式时设置有效。


参考链接


自定义弹窗


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-85
爬取时间: 2025-05-08 04:54:04
来源: Huawei Developer


需要采用自定义样式来消除自定义弹窗的白色背景：


参考链接


自定义弹窗


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-86
爬取时间: 2025-05-08 04:54:13
来源: Huawei Developer


支持，可使用TextInput的passwordIcon设置输入框末尾的图标。


参考链接


TextInput


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-87
爬取时间: 2025-05-08 04:54:23
来源: Huawei Developer


onSubmit事件在外接键盘或软键盘回车时触发该回调，回调的参数为当前软键盘回车键类型。通过TextInput的enterKeyType属性可以设置输入法回车键类型，软键盘回车键样式需要输入法的支持。


参考链接


TextInput


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-88
爬取时间: 2025-05-08 04:54:33
来源: Huawei Developer


```less
@Entry 
@Component 
struct TextInputDemo { 
  controller: TextInputController = new TextInputController(); 
 
  build() { 
    Column() { 
      TextInput({ controller: this.controller }) 
        .onEditChange((isEditing: boolean) => { 
          if (isEditing) { 
            setTimeout(() => { 
              this.controller.caretPosition(0); 
            }, 100) 
          } 
        }) 
    } 
  } 
}
```


参考链接


TextInput


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-89
爬取时间: 2025-05-08 04:54:42
来源: Huawei Developer


组件所有属性信息可通过通用属性-组件标识内getInspectorByKey获取。


参考链接


组件标识


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-90
爬取时间: 2025-05-08 04:54:52
来源: Huawei Developer


参考链接


Scroll


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-91
爬取时间: 2025-05-08 04:55:02
来源: Huawei Developer


可以通过设置Text组件宽度width与字号一致的方式实现。参考代码如下：


```less
@Entry 
@Component 
struct Index { 
  private message: string = '本文档适用于应用开发的初学者。通过构建一个简单的具有页面跳转/返回功能的应用，快速了解工程目录的主要文件，熟悉应用开发流程。'; 
  build() { 
    Column() { 
      Text(this.message) 
        .fontSize(13) 
        .width(13) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-94
爬取时间: 2025-05-08 04:55:13
来源: Huawei Developer


支持通过TimePicker组件的textStyle属性、disappearTextStyle属性、selectedTextStyle属性设置相应文本颜色、字号、字体粗细。


参考链接


TimePicker组件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-95
爬取时间: 2025-05-08 04:55:22
来源: Huawei Developer


问题现象


constraintSize约束组件尺寸时，子组件内设置百分比宽度，例如width('100%')会采用constraintSize约束中的最大宽乘百分比，导致撑开组件，看起来constraintSize设置没生效。


解决措施


可以在外层使用Scroll组件，设置constraintSize，当子组件占用空间超过设置的约束值时，会显示滚动条。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-96
爬取时间: 2025-05-08 04:55:32
来源: Huawei Developer


将backgroundColor设置为 '#00000000'。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-97
爬取时间: 2025-05-08 04:55:41
来源: Huawei Developer


```typescript
@Entry 
@Component 
struct VideoCreateComponent { 
  @State videoSrc: Resource = $rawfile('xxx.mp4') 
  @State previewUri: Resource = $r('app.media.xxx') 
  @State curRate: PlaybackSpeed = PlaybackSpeed.Speed_Forward_1_00_X 
  @State isAutoPlay: boolean = false 
  @State showControls: boolean = true 
  controller: VideoController = new VideoController() 
 
  build() { 
    Column() { 
      Video({ 
        src: this.videoSrc, 
        previewUri: this.previewUri, 
        currentProgressRate: this.curRate, 
        controller: this.controller 
      }) 
        .width('100%') 
        .height(600) 
        .autoPlay(this.isAutoPlay) 
        .controls(this.showControls) 
        .onStart(() => { 
          console.info('onStart') 
        }) 
        .onPause(() => { 
          console.info('onPause') 
        }) 
        .onFinish(() => { 
          console.info('onFinish') 
        }) 
        .onError(() => { 
          console.info('onError') 
        }) 
        .onPrepared((e) => { 
          console.info('onPrepared is ' + e.duration) 
        }) 
        .onSeeking((e) => { 
          console.info('onSeeking is ' + e.time) 
        }) 
        .onSeeked((e) => { 
          console.info('onSeeked is ' + e.time) 
        }) 
        .onUpdate((e) => { 
          console.info('onUpdate is ' + e.time) 
        }) 
      Row() { 
        Button('src').onClick(() => { 
          this.videoSrc = $rawfile('xxx.mp4') // 切换视频源 
        }).margin(5) 
        Button('previewUri').onClick(() => { 
          this.previewUri = $r('app.media.xxx') // 切换视频预览海报 
        }).margin(5) 
 
        Button('controls').onClick(() => { 
          this.showControls = !this.showControls // 切换是否显示视频控制栏 
        }).margin(5) 
      } 
 
      Row() { 
        Button('start').onClick(() => { 
          this.controller.start() // 开始播放 
        }).margin(5) 
        Button('pause').onClick(() => { 
          this.controller.pause() // 暂停播放 
        }).margin(5) 
        Button('stop').onClick(() => { 
          this.controller.stop() // 结束播放 
        }).margin(5) 
        Button('setTime').onClick(() => { 
          this.controller.setCurrentTime(10, SeekMode.Accurate) // 精准跳转到视频的10s位置 
        }).margin(5) 
      } 
 
      Row() { 
        Button('rate 0.75').onClick(() => { 
          this.curRate = PlaybackSpeed.Speed_Forward_0_75_X // 0.75倍速播放 
        }).margin(5) 
        Button('rate 1').onClick(() => { 
          this.curRate = PlaybackSpeed.Speed_Forward_1_00_X // 原倍速播放 
        }).margin(5) 
        Button('rate 2').onClick(() => { 
          this.curRate = PlaybackSpeed.Speed_Forward_2_00_X // 2倍速播放 
        }).margin(5) 
      } 
    } 
  } 
}
```


参考链接


Video


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-98
爬取时间: 2025-05-08 04:55:51
来源: Huawei Developer


使用多态样式，在组件的StateStyles接口中，定义组件不同状态下的样式。参考代码如下：


```less
@Component
struct PolymorphicStyle {
  @Styles
  pressedStyles() {
    .backgroundColor('#ED6F21')
    .borderRadius(10)
    .borderStyle(BorderStyle.Dashed)
    .borderWidth(2)
    .borderColor('#33000000')
    .width(120)
    .height(30)
    .opacity(1)
  }


  build() {
    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center }) {
      Text('pressed')
        .backgroundColor('#0A59F7')
        .borderRadius(20)
        .borderStyle(BorderStyle.Dotted)
        .borderWidth(2)
        .borderColor(Color.Red)
        .width(100)
        .height(25)
        .opacity(1)
        .fontSize(14)
        .fontColor(Color.White)
        .stateStyles({
          pressed: this.pressedStyles
        })
        .margin({ bottom: 20 })
        .textAlign(TextAlign.Center)
    }
    .width(350)
    .height(300)
  }
}
```


参考链接


多态样式


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-100
爬取时间: 2025-05-08 04:56:00
来源: Huawei Developer


可以通过focusControl.requestFocus控制输入框获焦，组件获焦后会自动弹起软键盘。


参考链接


焦点控制


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-101
爬取时间: 2025-05-08 04:56:10
来源: Huawei Developer


问题现象


数据包含多个种类（例如标题、标题对应的子类等）的子数据，如何根据数据种类为ListItem设置不同的样式。


解决措施


可以通过在List组件中使用ListItemGroup组件来展示Listitem分组，可以单独设置ListItemGroup中的header参数自定义每组的头部组件样式。参考代码如下：


```less
// xxx.ets 
@Entry 
@Component 
struct ListItemGroupExample { 
  private timetable: TimeTable[] = [ 
    { 
      title: '星期一', 
      projects: ['语文', '数学', '英语'] 
    }, 
    { 
      title: '星期二', 
      projects: ['物理', '化学', '生物'] 
    }, 
    { 
      title: '星期三', 
      projects: ['历史', '地理', '政治'] 
    }, 
    { 
      title: '星期四', 
      projects: ['美术', '音乐', '体育'] 
    } 
  ] 
 
  @Builder 
  itemHead(text: string) { 
    Text(text) 
      .fontSize(20) 
      .backgroundColor(0xAABBCC) 
      .width('100%') 
      .padding(10) 
  } 
 
  @Builder 
  itemFoot(num: number) { 
    Text('共' + num + '节课') 
      .fontSize(16) 
      .backgroundColor(0xAABBCC) 
      .width('100%') 
      .padding(5) 
  } 
 
  build() { 
    Column() { 
      List({ space: 20 }) { 
        ForEach(this.timetable, (item: TimeTable) => { 
          ListItemGroup({ header: this.itemHead(item.title), footer: this.itemFoot(item.projects.length) }) { 
            ForEach(item.projects, (project: string) => { 
              ListItem() { 
                Text(project) 
                  .width('100%') 
                  .height(100) 
                  .fontSize(20) 
                  .textAlign(TextAlign.Center) 
                  .backgroundColor(0xFFFFFF) 
              } 
            }, (item: string) => item) 
          } 
          .divider({ strokeWidth: 1, color: Color.Blue }) // 每行之间的分界线 
        }) 
      } 
      .width('90%') 
      .height('100%') 
      .sticky(StickyStyle.Header | StickyStyle.Footer) 
      .scrollBar(BarState.Off) 
    }.width('100%').height('100%').backgroundColor(0xDCDCDC).padding({ top: 5 }) 
  } 
} 
 
interface TimeTable { 
  title: string; 
  projects: string[]; 
}
```


效果如图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160835.21813997236657463136404757102436:50001231000000:2800:848F5C56E253415A38BD53F93DE56682F7EC71ACA6F5F5755A7042F70C25EE3D.png)

参考链接


ListItemGroup


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-102
爬取时间: 2025-05-08 04:56:20
来源: Huawei Developer


$r当前不支持嵌套，第二个参数需要使用ResourceManager获取应用资源对应字符串赋值给$r第二个参数。参考代码如下：


```typescript
import { common } from '@kit.AbilityKit'; 
 
@Entry 
@Component 
struct Page16 { 
  private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext; 
 
  build() { 
    Row() { 
      Column() { 
        Text($r('app.string.EntryAbility1_label2', 
          this.context.resourceManager.getStringSync($r('app.string.EntryAbility_label'))))//resources\base\element\string.json 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


ResourceManager


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-103
爬取时间: 2025-05-08 04:56:29
来源: Huawei Developer


Button默认背景色挡住渐变颜色设置，需要将背景色backgroundColor设置成全透明才能正常加载渐变。参考代码如下：


```less
@Entry 
@Component 
struct Index { 
  build() { 
    Button('test') 
      .width(200) 
      .height(50) 
      .backgroundColor('#00000000') 
      .linearGradient({ 
        angle: 90, 
        colors: [[0xff0000, 0.0], [0x0000ff, 0.3], [0xffff00, 1.0]] 
      }) 
  } 
}
```


参考链接


Button


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-105
爬取时间: 2025-05-08 04:56:39
来源: Huawei Developer


计算软键盘的高度，然后将整体的margin-bottom设置为软键盘的高度 ，软键盘消失的时候 margin-bottom再设置为0。软键盘高度可以通过监听软键盘的显示事件获取。


参考链接


输入法框架


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-106
爬取时间: 2025-05-08 04:56:49
来源: Huawei Developer


TextInput的inputFilter属性，可以设置正则表达式参数，对输入的字符进行校验，校验不通过则输入无效。参考代码如下：


```typescript
@Entry 
@Component 
struct Index { 
  controller: TextInputController = new TextInputController(); 
 
  build() { 
    Column() { 
      TextInput({ placeholder: '请输入密码', text: '123456', controller: this.controller }) 
        .type(InputType.Password) 
        .placeholderColor(Color.Gray) 
        .inputFilter('[0-9]', (val) => { //只允许输入0-9这10个字符，其他字符输入无效 
          console.error('TextInputExample ： ' + val); 
          return 0; 
        }) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-107
爬取时间: 2025-05-08 04:56:58
来源: Huawei Developer


可以通过组件的onAreaChange方法监听组件区域变化并根据返回的内容大小修改浮动窗口大小。


参考链接


组件区域变化事件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-109
爬取时间: 2025-05-08 04:57:08
来源: Huawei Developer


以列模式为例(listDirection为Axis.Vertical):lanes用于决定List组件在交叉轴方向按几列布局。参考代码如下：


```less
@Entry 
@Component 
struct ListLanesExample { 
  @State arr: string[] = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19']; 
  @State alignListItem: ListItemAlign = ListItemAlign.Start; 
 
  build() { 
    Column() { 
      List({ space: 20, initialIndex: 0 }) { 
        ForEach(this.arr, (item: string) => { 
          ListItem() { 
            Text('' + item) 
              .width('100%') 
              .height(100) 
              .fontSize(16) 
              .textAlign(TextAlign.Center) 
              .borderRadius(10) 
              .backgroundColor(0xFFFFFF) 
          } 
          .border({ width: 2, color: Color.Green }) 
        }, (item: string) => item) 
      } 
      .height(300) 
      .width('90%') 
      .border({ width: 3, color: Color.Red }) 
      .lanes({ minLength: 40, maxLength: 40 }) 
      .alignListItem(this.alignListItem) 
 
      Button('点击更改alignListItem:' + this.alignListItem).onClick(() => { 
        if (this.alignListItem == ListItemAlign.Start) { 
          this.alignListItem = ListItemAlign.Center; 
        } else if (this.alignListItem == ListItemAlign.Center) { 
          this.alignListItem = ListItemAlign.End; 
        } else { 
          this.alignListItem = ListItemAlign.Start; 
        } 
      }) 
    }.width('100%').height('100%').backgroundColor(0xDCDCDC).padding({ top: 5 }) 
  } 
} 


```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-111
爬取时间: 2025-05-08 04:57:18
来源: Huawei Developer


Tab组件可以设置divider属性，该属性用于设置区分TabBar和TabContent的分割线样式，默认不显示分割线。


参考链接


Tabs


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-112
爬取时间: 2025-05-08 04:57:28
来源: Huawei Developer


当前richText底层由webview实现，所以与浏览器规格一致，若内容超出支持滚动。


参考链接


RichText组件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-113
爬取时间: 2025-05-08 04:57:38
来源: Huawei Developer


给List组件添加属性.edgeEffect(EdgeEffect.None)，设置为滑动到边缘无回弹效果。


参考链接


List组件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-114
爬取时间: 2025-05-08 04:57:47
来源: Huawei Developer


可能原因


由于Image组件的插值效果interpolation默认为ImageInterpolation.None（不使用插值图片数据），所以会出现锯齿问题。


解决方案


可以将值设置成High、Medium或者Low来减轻锯齿效果。


参考链接


插值效果


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-116
爬取时间: 2025-05-08 04:57:57
来源: Huawei Developer


多行输入使用TextArea。


参考链接


文本输入 (TextInput/TextArea)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-117
爬取时间: 2025-05-08 04:58:07
来源: Huawei Developer


单个组件只能设置一种字体样式，但是可以通过多个组件来实现一行文本展示不同样式。参考代码如下：


```less
@Entry 
@Component 
struct TestDemoPage { 
  @State message: string = "Hello World"; 
 
  build() { 
    Row() { 
      Column() { 
        Text() { 
          Span('测试文本: ') 
            .fontSize(20) 
            .fontWeight(FontWeight.Bolder) 
            .fontColor(Color.Black) 
          Span(this.message) 
            .fontSize(15) 
            .fontColor(Color.Red) 
        } 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


Text组件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-118
爬取时间: 2025-05-08 04:58:17
来源: Huawei Developer


setWindowSystemBarProperties可以用于设置窗口内导航栏、状态栏的属性，包括状态栏背景颜色、状态栏文字颜色等。


在EntryAbility.ets中的onWindowStageCreate方法中将WindowStage设置一个AppStorage。参考代码如下：


```less
AppStorage.setOrCreate('windowStage',windowStage);
```


通过setWindowSystemBarProperties可以设置状态栏样式。


```typescript
import { window } from '@kit.ArkUI'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
@Component 
struct ChangeStatusBar { 
  windowStage: window.WindowStage = AppStorage.get("windowStage") as window.WindowStage; 
  // 获取主窗口的方式 
  mainWin: window.Window = this.windowStage.getMainWindowSync(); 
 
  aboutToAppear(): void { 
    let sysBarProps: window.SystemBarProperties = { 
      statusBarColor: '#000000', 
      statusBarContentColor: '#ffffff' 
    }; 
    this.mainWin.setWindowSystemBarProperties(sysBarProps, (err: BusinessError) => { 
      let errCode: number = err.code; 
      if (errCode) { 
        console.error('[StaticUtils] Failed to set the system bar properties. Cause: ' + JSON.stringify(err)); 
        return; 
      } 
      console.info('[StaticUtils] Succeeded in setting the system bar properties.'); 
    }); 
  } 
 
  build() { 
    Row() { 
      Column({ space: 10 }) { 
        Text('状态栏修改demo') 
          .fontSize(25) 
          .margin(20) 
          .fontColor(0x3399FF) 
      }.width('100%') 
    }.height('100%').backgroundColor(Color.White) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-119
爬取时间: 2025-05-08 04:58:26
来源: Huawei Developer


TextInput组件的setTextSelection属性，可以设置文本选择区域并高亮显示。


参考链接


TextInput组件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-121
爬取时间: 2025-05-08 04:58:36
来源: Huawei Developer


换行的高度是默认的实现，不是以字体行高来决定空行的高度。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-122
爬取时间: 2025-05-08 04:58:45
来源: Huawei Developer


输入框中有内容时默认不会全选，设置全选需用输入框的控制器实现。


参考链接


controller.setTextSelection


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-123
爬取时间: 2025-05-08 04:58:55
来源: Huawei Developer


系统规格限制，正确使用rgba(0, 0, 255, 0.5)，rgba本身不可以省略0。


参考链接


ResourceColor


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-124
爬取时间: 2025-05-08 04:59:04
来源: Huawei Developer


可以使用ArkUI多态样式，修改按压态背景色。参考代码如下：


```less
@Entry 
@Component 
struct Index { 
  @Styles 
  pressedStyles() { 
    .backgroundColor(Color.White) 
  } 
 
  build() { 
    Row() { 
      Column() { 
        TextInput() 
          .backgroundColor(Color.White) 
          .stateStyles({ 
            pressed: this.pressedStyles, 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


多态样式


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-125
爬取时间: 2025-05-08 04:59:14
来源: Huawei Developer


使用通用属性中的constraintSize可以设置这四个属性。


参考链接


尺寸设置


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-126
爬取时间: 2025-05-08 04:59:24
来源: Huawei Developer


XComponent组件仅在type为TEXTURE时支持设置，SURFACE("surface")和COMPONENT("component")类型均不支持通用属性包括背景颜色设置，需采用EGL/OpenGLES或子组件内容设置。


参考链接


XComponent


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-128
爬取时间: 2025-05-08 04:59:33
来源: Huawei Developer


可以通过组件的通用属性backdropBlur，blur，backgroundBlurStyle，foregroundBlurStyle来设置组件的模糊效果。


参考链接


图像效果，组件内容模糊


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-129
爬取时间: 2025-05-08 04:59:43
来源: Huawei Developer


不管屏幕分辨率是多少，屏幕密度是多少，组件在视觉上呈现的效果是一致的。


vp具体计算公式为：vp= px/（DPI/160）


px就是屏幕真实物理像素值，densityPixels是屏幕密度，是和标准DPI的比例，常见取值有0.75，1.0，1.5，2.0，3.0等，在HarmonyOS中，标准DPI为160，以华为mate 40 pro为例，查询得到的densityPixels=3.5，densityDPI=560。densityDPI就是我们通常所说的系统屏幕密度，densityPixels就是屏幕密度和标准dpi(160)的比率。想要查看真机的dpi，可以调用屏幕属性中的display接口查询。


```less
import { display } from '@kit.ArkUI'; 
 
let displayClass: display.Display | null = null; 
try { 
  displayClass = display.getDefaultDisplaySync(); 
} catch (exception) { 
  console.error('Failed to obtain the default display object. Code: ' + JSON.stringify(exception)); 
}
```


如果原型图没有提供vp单位的布局，开发者可以根据densityPixel把px转为vp，HarmonyOS也封装了现成的接口px2vp()和vp2px()供开发者直接调用。


参考链接


像素单位，屏幕属性


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-131
爬取时间: 2025-05-08 04:59:53
来源: Huawei Developer


通过设置页面根容器的饱和度saturate来实现。参考代码如下：


```less
@Entry 
@Component 
struct Index { 
  @State message: string = 'Hello World' 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
 
        Image($r("app.media.icon")) 
          .autoResize(true) 
          .width(100) 
          .height(100) 
      } 
    } 
    .width('100%') 
    .height('100%') 
    .saturate(0) 
  } 
}
```


参考链接


图像效果


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-132
爬取时间: 2025-05-08 05:00:03
来源: Huawei Developer


setWindowBrightness可以用于设置屏幕亮度，屏幕亮度值，值为0-1之间。1表示最亮。


在EntryAbility.ets中的onWindowStageCreate方法中将WindowStage设置一个AppStorage，参考代码如下：


```less
AppStorage.setOrCreate('windowStage',windowStage);
```


通过setWindowBrightness可以设置屏幕亮度


```typescript
import { window } from '@kit.ArkUI' 
 
@Component 
struct SettingScreenBrightness { 
  windowStage: window.WindowStage = AppStorage.get('windowStage') as window.WindowStage; 
  // 获取主窗口的方式 
  mainWin: window.Window = this.windowStage.getMainWindowSync(); 
 
  aboutToAppear(): void { 
    // 修改brightness即可改变屏幕亮度 
    let brightness = 1; 
    this.windowStage = AppStorage.get('windowStage') as window.WindowStage; 
    // 获取主窗口的方式 
    this.mainWin = this.windowStage.getMainWindowSync(); 
    // 获取最上层窗口的方式 
    window.getLastWindow(getContext(this)); 
    try { 
      this.mainWin.setWindowBrightness(brightness, (err) => { 
        if (err.code) { 
          console.error('Failed to set the brightness. Cause: ' + JSON.stringify(err)); 
          return; 
        } 
        console.info('Succeeded in setting the brightness.'); 
      }); 
    } catch (exception) { 
      console.error('Failed to set the brightness. Cause: ' + JSON.stringify(exception)); 
    } 
  } 
 
  build() { 
    Row() { 
      Column({ space: 10 }) { 
        Text('屏幕亮度设置demo') 
          .fontSize(25) 
          .margin(20) 
          .fontColor(0x3399FF) 
      }.width('100%') 
    }.height('100%').backgroundColor(Color.White) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-133
爬取时间: 2025-05-08 05:00:14
来源: Huawei Developer


当前不支持，暂未提供相关接口。


参考链接


TextInput组件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-134
爬取时间: 2025-05-08 05:00:24
来源: Huawei Developer


在其父组件tabs上添加属性fadingEdge，并将值设置为false。


参考链接


Tabs开发指导


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-135
爬取时间: 2025-05-08 05:00:33
来源: Huawei Developer


问题描述


例如一级Tabs组件下嵌套二级的Tabs，二级Tabs第一个页面左滑或最后一个页面右滑不能切换一级Tabs标签，该问题如何解决。


解决措施


可以通过PanGesture结合TabsController的changeIndex方法实现一二级tab切换问题。给二级Tabs第一个页面和最后一个页面添加PanGesture事件，判断滑动方向，然后根据滑动方向，使用changeIndex来切换对应的一级Tabs页签。参考代码如下：


```less
@Entry 
@Component 
struct TestTabWithTab { 
  @State currentIndex: number = 1; 
  @State subCurrentIndex: number = 0; 
  private fontColor: string = '#182431'; 
  private selectedFontColor: string = '#007DFF'; 
  private controller: TabsController = new TabsController(); 
  private subController: TabsController = new TabsController(); 
  private panOptionLeft: PanGestureOptions = new PanGestureOptions({ direction: PanDirection.Left }); 
  private panOptionRight: PanGestureOptions = new PanGestureOptions({ direction: PanDirection.Right }); 
 
  @Builder 
  tabBuilder(index: number, name: string) { 
    Column() { 
      Text(name) 
        .fontColor(this.currentIndex === index ? this.selectedFontColor : this.fontColor) 
        .fontSize(16) 
        .fontWeight(this.currentIndex === index ? 500 : 400) 
        .lineHeight(22) 
        .margin({ top: 17, bottom: 7 }) 
      Divider() 
        .strokeWidth(2) 
        .color('#007DFF') 
        .opacity(this.currentIndex === index ? 1 : 0) 
    }.width('100%') 
  } 
 
  @Builder 
  subTabBuilder(index: number, name: string) { 
    Column() { 
      Text(name) 
        .fontColor(this.subCurrentIndex === index ? this.selectedFontColor : this.fontColor) 
        .fontSize(16) 
        .fontWeight(this.subCurrentIndex === index ? 500 : 400) 
        .lineHeight(22) 
        .margin({ top: 17, bottom: 7 }) 
      Divider() 
        .strokeWidth(2) 
        .color('#007DFF') 
        .opacity(this.subCurrentIndex === index ? 1 : 0) 
    }.width('100%') 
  } 
 
  build() { 
    Column() { 
      // 一级Tab 
      Tabs({ barPosition: BarPosition.Start, index: this.currentIndex, controller: this.controller }) { 
        TabContent() { 
          Column() { 
            Text('首页内容') 
          } 
          .width('100%') 
          .height('100%') 
          .backgroundColor('#ffb554d7') 
          .justifyContent(FlexAlign.Center) 
          .alignItems(HorizontalAlign.Center) 
        }.tabBar(this.tabBuilder(0, '首页')) 
 
        TabContent() { 
          Column() { 
            // 二级Tab 
            Tabs({ barPosition: BarPosition.Start, controller: this.subController }) { 
              TabContent() { 
                Column().width('100%').height('100%').backgroundColor('#00CB87') 
              }.tabBar(this.subTabBuilder(0, 'green')) 
              // 给二级Tab的第一个页签，添加向右的滑动手势，当向右滑该页签时，切换一级Tab页签
              .gesture( 
                PanGesture(this.panOptionRight) 
                  .onActionEnd(() => { 
                    this.controller.changeIndex(0) 
                  }) 
              ) 
 
              TabContent() { 
                Column().width('100%').height('100%').backgroundColor('#007DFF') 
              }.tabBar(this.subTabBuilder(1, 'blue')) 
 
              TabContent() { 
                Column().width('100%').height('100%').backgroundColor('#FFBF00') 
              }.tabBar(this.subTabBuilder(2, 'yellow')) 
 
              TabContent() { 
                Column().width('100%').height('100%').backgroundColor('#E67C92') 
              }.tabBar(this.subTabBuilder(3, 'pink')) 
              // 给二级Tab的最后一个页签，添加向左的滑动手势，当向左滑该页签时，切换一级Tab页签
              .gesture( 
                PanGesture(this.panOptionLeft) 
                  .onActionEnd(() => { 
                    this.controller.changeIndex(2) 
                  }) 
              ) 
            } 
            .vertical(false) 
            .barMode(BarMode.Fixed) 
            .barWidth(360) 
            .barHeight(56) 
            .animationDuration(400) 
            .onChange((index: number) => { 
              this.subCurrentIndex = index; 
            }) 
            .width(360) 
            .backgroundColor('#F1F3F5') 
          } 
          .width('100%').height('100%').backgroundColor('#00CB87') 
        }.tabBar(this.tabBuilder(1, '详情')) 
 
        TabContent() { 
          Column() { 
            Text('我的内容') 
          } 
          .width('100%') 
          .height('100%') 
          .backgroundColor('#ffc19757') 
          .justifyContent(FlexAlign.Center) 
          .alignItems(HorizontalAlign.Center) 
        }.tabBar(this.tabBuilder(2, '我的')) 
 
      } 
      .vertical(false) 
      .barMode(BarMode.Fixed) 
      .barWidth(360) 
      .barHeight(56) 
      .animationDuration(400) 
      .onChange((index: number) => { 
        this.currentIndex = index 
      }) 
      .width(360) 
      .height(296) 
      .backgroundColor('#F1F3F5') 
    }.width('100%') 
  } 
}
```


效果图如下

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160836.99156432003594601233577134487161:50001231000000:2800:16B8E135D7BEC9395068F432B27CDE68E7E3F2AD0A88CA0DEEB10EE286A7A899.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-136
爬取时间: 2025-05-08 05:00:43
来源: Huawei Developer


Grid组件的默认滑动条scrollBar不支持自定义样式。


但是可以通过隐藏默认滑动条，并绑定一个ScrollBar组件，就满足该场景。参考代码如下：


```less
@Entry 
@Component 
struct Index { 
  private scroller: Scroller = new Scroller() 
  private arr: number[] = []; 
 
  build() { 
    Column() { 
      Stack({ alignContent: Alignment.End }) { 
        Grid(this.scroller) { 
          ForEach(this.arr, (item: number) => { 
            GridItem() { 
              Text(item.toString()) 
                .width(100) 
                .height(50) 
                .backgroundColor('#3366CC') 
                .borderRadius(15) 
                .fontSize(16) 
                .textAlign(TextAlign.Center) 
            } 
          }) 
        } 
        .width('100%') 
        .columnsTemplate("1fr 1fr 1fr") 
        .columnsGap(5) 
        .rowsGap(5) 
        .scrollBar(BarState.Off) 
 
        ScrollBar({ scroller: this.scroller, direction: ScrollBarDirection.Vertical, state: BarState.Auto }) { 
          Text("A") 
            .width(20) 
            .height(50) 
            .borderRadius(10) 
            .backgroundColor('#C0C0C0') 
        }.width(20).backgroundColor('#ededed') 
      } 
    } 
  } 
 
  aboutToAppear() { 
    for (let i = 0; i < 100; i++) { 
      this.arr.push(i) 
    } 
  } 
}
```


参考链接


Grid开发指导，ScrollBar开发指导


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-137
爬取时间: 2025-05-08 05:00:53
来源: Huawei Developer


List组件本身不支持设置两端渐变，但是可以结合LinearGradient对象实现效果。参考代码如下：


```less
@Entry 
@Component 
struct ListExample { 
  @State arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9] 
  private scroller: Scroller = new Scroller() 
 
  build() { 
    Stack() { 
      List({ space: 10 }) { 
        ForEach(this.arr, (item: string) => { 
          ListItem() { 
            Text("Hello World") 
              .width(100) 
              .height(64) 
              .fontColor(Color.White) 
              .backgroundColor(Color.Black) 
              .textAlign(TextAlign.Center) 
          } 
        }, (item: string) => item) 
      } 
      .listDirection(Axis.Horizontal) 
      .scrollBar(BarState.Off) 
      .padding({ top: 20, bottom: 20 }) 
      .width("80%") 
      .height("100%") 
 
      Stack() { 
 
      } 
      .linearGradient({ 
        angle: 90, 
        colors: [[0x000000, 0.0], ['rgba(0,0,0,0)', 0.1], ['rgba(0,0,0,0)', 0.9], [0x000000, 1.0]] 
      }) 
      .width("80%") 
      .height("100%") 
      .hitTestBehavior(HitTestMode.None) 
    }.height(100).width('100%').backgroundColor(Color.Black) 
  } 
}
```


参考链接


颜色渐变


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-138
爬取时间: 2025-05-08 05:01:03
来源: Huawei Developer


跑马灯组件，用于滚动展示一段单行文本，仅当文本内容宽度超过跑马灯组件宽度时滚动。


参考链接


Marquee组件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-139
爬取时间: 2025-05-08 05:01:13
来源: Huawei Developer


XComponent显示的内容，可由开发者自定义绘制，通用属性中的背景设置、透明度设置和图像效果按照type类型有限支持。type为TEXTURE时通用属性可以支持背景颜色设置、透明度设置和图像效果中的shadow属性，建议使用EGL/OpenGLES提供的接口设置相关内容。


参考链接


XComponent，背景设置，透明度设置，图像效果


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-142
爬取时间: 2025-05-08 05:01:24
来源: Huawei Developer


通过设置bindSheet()的参数options对高度进行控制。参考代码如下：


```typescript
@Entry 
@Component 
struct SheetTransitionExample { 
  @State isShow: boolean = false; 
  @State sheetHeight: number = 300; 
 
  @Builder 
  myBuilder() { 
    Column() { 
      Button('change height') 
        .margin(10) 
        .fontSize(20) 
        .onClick(() => { 
          this.sheetHeight = 500; 
        }) 
 
      Button('Set Illegal height') 
        .margin(10) 
        .fontSize(20) 
        .onClick(() => { 
          this.sheetHeight = 0; 
        }) 
    } 
    .width('100%') 
    .height('100%') 
  } 
 
  build() { 
    Column() { 
      Button('transition modal 1') 
        .onClick(() => { 
          this.isShow = true; 
        }) 
        .fontSize(20) 
        .margin(10) 
        .bindSheet(this.isShow, this.myBuilder(), { height: this.sheetHeight, backgroundColor: Color.Green }) 
    } 
    .justifyContent(FlexAlign.Center) 
    .width('100%') 
    .height('100%') 
  } 
}
```


参考链接


半模态转场


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-143
爬取时间: 2025-05-08 05:01:34
来源: Huawei Developer


Grid拖拽时，列表项默认为占位动画效果。具体实现步骤如下：


```typescript
@Entry 
@Component 
struct GridExample { 
  @State numbers: String[] = []; 
  scroller: Scroller = new Scroller(); 
  @State text: string = 'drag'; 
 
  @Builder 
  pixelMapBuilder() { 
    Column() { 
      Text(this.text) 
        .fontSize(16) 
        .backgroundColor(0xF9CF93) 
        .width(80) 
        .height(80) 
        .textAlign(TextAlign.Center) 
    } 
  } 
 
  aboutToAppear() { 
    for (let i = 1; i <= 15; i++) { 
      this.numbers.push(i + ''); 
    } 
  } 
 
  changeIndex(index1: number, index2: number) { 
    // 交换数组位置 
    let temp = this.numbers[index1]; 
    this.numbers[index1] = this.numbers[index2]; 
    this.numbers[index2] = temp; 
  } 
 
  build() { 
    Column({ space: 5 }) { 
      Grid(this.scroller) { 
        ForEach(this.numbers, (day: string) => { 
          GridItem() { 
            Text(day) 
              .fontSize(16) 
              .backgroundColor(0xF9CF93) 
              .width(80) 
              .height(80) 
              .textAlign(TextAlign.Center) 
              .onTouch((event: TouchEvent) => { 
                if (event.type === TouchType.Up) { 
                  this.text = day; 
                } 
              }) 
          } 
        }) 
      } 
      .columnsTemplate('1fr 1fr 1fr') 
      .columnsGap(10) 
      .rowsGap(10) 
      .onScrollIndex((first: number) => { 
        console.info(first.toString()); 
      }) 
      .width('90%') 
      .backgroundColor(0xFAEEE0) 
      .height(300) 
      .editMode(true) // 设置Grid是否进入编辑模式，进入编辑模式可以拖拽Grid组件内部GridItem 
      .onItemDragStart((event: ItemDragInfo, itemIndex: number) => { // 第一次拖拽此事件绑定的组件时，触发回调。 
        return this.pixelMapBuilder(); //设置拖拽过程中显示的图片。 
      }) 
      // 绑定此事件的组件可作为拖拽释放目标，当在本组件范围内停止拖拽行为时，触发回调。 
      .onItemDrop((event: ItemDragInfo, itemIndex: number, insertIndex: number, isSuccess: boolean) => { 
        // itemIndex拖拽起始位置，insertIndex拖拽插入位置 
        this.changeIndex(itemIndex, insertIndex) 
      }) 
    }.width('100%').margin({ top: 5 }) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-144
爬取时间: 2025-05-08 05:01:43
来源: Huawei Developer


问题现象


ArkUI组件的字符串中如何实现字符串变量拼接，结合限定词目录的资源文件，例如语言切换时候，字符串内容自动跟随切换。例如实现Text()组件的字符串变量拼接功能，如何实现？


```less
Text($r('app.string.EntryAbility_desc', 'Hello'))
```


解决措施


可以结合资源文件结合%d、%s的方式进行实现。使用样例如下所示。

1.  修改"src/main/resources/en_US/element/string.json"文件，对其中的一个需要变量拼接内容增加%d拼接。

```json
{
  "string": [
    {
      "name": "module_desc",
      "value": "模块描述%d"
    },
    {
      "name": "EntryAbility_desc",
      "value": "description"
    },
    {
      "name": "EntryAbility_label",
      "value": "label"
    }
  ]
}
```


```typescript
@Entry
@Component
struct Page1 {
  @State num1: number = 100;


  build() {
    Row() {
      Column() {
        Text($r('app.string.module_desc', this.num1))
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


参考链接


资源分类与访问


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-145
爬取时间: 2025-05-08 05:01:53
来源: Huawei Developer


实时模糊，就是通过状态变量实时改变模糊值。实现模糊可以通过组件的通用属性backdropBlur来设置组件的模糊效果。参考代码如下：


```less
// xxx.ets
@Entry
@Component
struct BackGroundBlur {
  private imageSize: number = 150;
 
  build() {
    Column() {
      // backdropBlur 只能设置模糊半径和灰阶参数
      Stack() {
        Image($r('app.media.startIcon'))
          .width(this.imageSize)
          .height(this.imageSize)
        Column()
          .width(this.imageSize)
          .height(this.imageSize)
          .backdropBlur(20, { grayscale: [30, 50] })
      }
    }
    .width('100%')
    .padding({ top: 5 })
  }
}
```


参考链接


图像效果


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-146
爬取时间: 2025-05-08 05:02:03
来源: Huawei Developer


通过Image组件的onComplete事件，图片数据加载成功和解码成功时均触发该回调，返回成功加载的图片尺寸。参考代码如下：


```less
Image($r('app.media.startIcon'))
  .width(200)
  .height(200)
  .objectFit(ImageFit.Contain)
  .onComplete((event) => {
    let imageWidth = event?.width;
    let imageHeight = event?.height;
    console.info('imageWidth:'+imageWidth,'imageHeight:'+imageHeight);
  })
```


参考链接


Image组件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-148
爬取时间: 2025-05-08 05:02:13
来源: Huawei Developer


问题现象


解决措施


可以通过监听软键盘弹出和收起来解决此问题：当软键盘弹出时，子窗口高度设置为屏幕高度-软键盘高度；当软键盘收起时，弹出子窗口高度为屏幕高度。参考代码如下：


```typescript
// 子窗口页面布局 
import { webview } from '@kit.ArkWeb'; 
import { window } from '@kit.ArkUI'; 
 
@Entry 
@Component 
export struct SubWindowPage { 
  @State webViewVisibility: Visibility = Visibility.Visible; 
  private pageWidth = 320; 
  private pageHeight = 500; 
  private controller: webview.WebviewController = new webview.WebviewController(); 
  @State flexAlign: FlexAlign = FlexAlign.Center; 
  @State screenHeight: number | string = '100%'; 
 
  aboutToAppear() { 
    window.getLastWindow(getContext(this)).then(currentWindow => { 
      // 监视软键盘的弹出和收起 
      currentWindow.on('avoidAreaChange', async data => { 
        let property = currentWindow.getWindowProperties(); 
        let avoidArea = currentWindow.getWindowAvoidArea(window.AvoidAreaType.TYPE_KEYBOARD); 
        this.screenHeight = px2vp(property.windowRect.height - avoidArea.bottomRect.height); 
      }); 
    }) 
  } 
 
  build() { 
    Stack() { 
      Column() { 
        Web({ src: $rawfile('index.html'), controller: this.controller }) 
          .javaScriptAccess(true) 
          .fileAccess(false) 
          .zoomAccess(false) 
          .domStorageAccess(true) 
          .onlineImageAccess(true) 
          .horizontalScrollBarAccess(false) 
          .verticalScrollBarAccess(false) 
          .cacheMode(CacheMode.Online) 
          .width(this.pageWidth) 
          .height(this.pageHeight) 
          .border({ radius: 6 }) 
          .visibility(this.webViewVisibility) 
          .backgroundColor(Color.Pink) 
      } 
      .justifyContent(this.flexAlign) 
      .alignItems(HorizontalAlign.Center) 
      .width('100%') 
      .height('100%') 
    } 
    .width('100%') 
    .height(this.screenHeight) 
    .backgroundColor('#999955') 
    .alignContent(Alignment.Center) 
  } 
}
```


参考链接


on('avoidAreaChange')


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-149
爬取时间: 2025-05-08 05:02:22
来源: Huawei Developer


问题现象


Navigation设置了隐藏属性，仍然出现空白导航栏，跳转至新的页面后导航栏会重新出现。


解决措施


设置Navigation和NavDestination的属性hideTitleBar值为true。


参考链接


Navigation


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-152
爬取时间: 2025-05-08 05:02:32
来源: Huawei Developer


可以使用尺寸设置中的calc计算属性，对子组件的宽度进行判断，来设置子组件宽度。参考代码如下：


```less
@Entry 
@Component 
struct SizeExample { 
  @State flag:boolean = true; 
 
  build() { 
    Row() { 
      Text(this.flag ? '已关注' : '没有关注') 
        .fontSize(20) 
        .fontWeight(FontWeight.Bold) 
        .backgroundColor(0xFFFAF0) 
        .textAlign(TextAlign.Center) 
        .margin( 10) 
        .size({ width: this.flag ? 60 : 80 }) 
        .onClick(()=>{ 
          this.flag = !this.flag 
        }) 
      Text('HarmonyOS开发者社区') 
        .fontSize(20) 
        .fontWeight(FontWeight.Bold) 
        .backgroundColor(0xFFFAF0) 
        .size({width: this.flag ? 'calc(100% - 60vp)' : 'calc(100% - 80vp)'}) 
    }.width(500).margin({ top: 5 }) 
  } 
}
```


参考链接


尺寸设置


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-153
爬取时间: 2025-05-08 05:02:42
来源: Huawei Developer


目前规格上只支持常量，需要把string提取出来用$r( )包裹。如：


```less
localImageName = $r( 'app.media.icon' )
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-154
爬取时间: 2025-05-08 05:02:52
来源: Huawei Developer


Image组件不能直接传入应用沙箱路径，需要传入应用沙箱uri。


参考链接


fileuri (文件URI)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-155
爬取时间: 2025-05-08 05:03:01
来源: Huawei Developer


问题现象


例如在一个Stack中，有两个兄弟组件，组件A被组件B盖住，用户点击组件B时能否将点击事件透传至组件A，触发组件A的onClick回调而不触发组件B的onClick回调。


解决措施


组件B设置hitTestBehavior属性为HitTestMode.None即可。参考代码如下：


```typescript
@Entry 
@Component 
struct StackExample { 
  build() { 
    Stack({ alignContent: Alignment.Bottom }) { 
      Text('A') 
        .width('90%') 
        .height('100%') 
        .backgroundColor(0xd2cab3) 
        .align(Alignment.Top) 
        .onClick(() => { 
          console.log('11111') 
        }) 
      Text('B') 
        .width('70%') 
        .height('60%') 
        .backgroundColor(0xc1cbac) 
        .align(Alignment.Top) 
        .hitTestBehavior(HitTestMode.None) 
        .onClick(() => { 
          console.log('1111122222') 
        }) 
    }.width('100%').height(150).margin({ top: 5 }) 
  } 
}
```


参考链接


触摸测试控制


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-156
爬取时间: 2025-05-08 05:03:10
来源: Huawei Developer


可以通过MeasureText.measureTextSize来判断Text文本的高度是否超出maxLines设置的高度进行判断。参考代码如下：


```less
import { MeasureText } from '@kit.ArkUI' 
 
@Entry 
@Component 
struct TextInputExample { 
  @State text: string = ''; 
  @State truncatedHint: string = "文本未截断"; 
  controller: TextInputController = new TextInputController(); 
 
  build() { 
    Column() { 
      TextInput({ text: this.text, placeholder: 'input your word...', controller: this.controller }) 
        .placeholderColor(Color.Grey) 
        .placeholderFont({ size: 14, weight: 400 }) 
        .caretColor(Color.Blue) 
        .width(400) 
        .height(40) 
        .margin(20) 
        .fontSize(14) 
        .fontColor(Color.Black) 
        .onChange((value: string) => { 
          this.text = value; 
          let textSizeShow1: SizeOptions = MeasureText.measureTextSize({ 
            textContent: this.text, 
            constraintWidth: 100, 
            fontSize: 14, 
            overflow: TextOverflow.Ellipsis, 
            maxLines: 2 
          }) 
          let textSizeShow2: SizeOptions = MeasureText.measureTextSize({ 
            textContent: this.text + " ", 
            constraintWidth: 100, 
            fontSize: 14, 
            overflow: TextOverflow.Ellipsis, 
            maxLines: 2000000 
          }) 
          console.log("textSizeShow1.height=" + textSizeShow1.height); 
          console.log("textSizeShow2.height=" + textSizeShow2.height); 
 
          if (textSizeShow2 && textSizeShow1 && textSizeShow2?.height && textSizeShow1?.height && (textSizeShow2?.height > textSizeShow1?.height)) { 
            console.log("文本截断"); 
            this.truncatedHint = "文本截断"; 
          } else { 
            console.log("文本未截断"); 
            this.truncatedHint = "文本未截断"; 
          } 
        }) 
      Text(this.text) 
        .maxLines(2) 
        .width(100) 
        .textOverflow({ overflow: TextOverflow.Ellipsis }) 
        .border({ width: 1 }) 
        .minFontSize(14) 
        .maxFontSize(24) 
      Text(this.truncatedHint) 
 
    }.width('100%') 
  } 
}
```


参考链接


measure.measureTextSize


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-157
爬取时间: 2025-05-08 05:03:20
来源: Huawei Developer


可以通过delay的动画，或者onFinish里拉起新的动画实现类似效果。参考代码如下：


```less
@Entry 
@Component 
struct AnimateToExample { 
  @State widthSize: number = 250; 
  @State heightSize: number = 100; 
  @State rotateAngle: number = 0; 
  private flag: boolean = true; 
  @State opacityValue: number = 1; 
 
  build() { 
    Column() { 
      Button('change size') 
        .width(this.widthSize) 
        .height(this.heightSize) 
        .margin(30) 
        .opacity(this.opacityValue) 
        .onClick(() => { 
          if (this.flag) { 
            animateTo({ 
              duration: 2000, 
              curve: Curve.EaseOut, 
              iterations: 1, 
              playMode: PlayMode.Normal, 
              onFinish: () => { 
                animateTo({ 
                  duration: 2000, 
                  curve: Curve.EaseOut, 
                  iterations: 1, 
                  playMode: PlayMode.Normal, 
                  onFinish: () => { 
                  } 
                }, () => { 
                  this.opacityValue = 0.2; 
                }) 
              } 
            }, () => { 
              this.opacityValue = 0.5; 
            }) 
          } 
        }) 
    }.width('100%').margin({ top: 5 }) 
  } 
}
```


参考链接


显式动画


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-159
爬取时间: 2025-05-08 05:03:29
来源: Huawei Developer


目前不支持让父元素适应子元素的圆角。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-160
爬取时间: 2025-05-08 05:03:39
来源: Huawei Developer


问题现象


在build()中使用Stack作为容器，设置参数alignContent为Alignment.Bottom，且设置属性align为Alignment.Center，参数alignContent为Alignment.Bottom未生效。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160837.90937989642453825005248214208620:50001231000000:2800:583138CFA4CBFEB67916406F26F24BD075C059A4FA812083F6E72714062A5E9D.png)

解决措施


参数alignContent与属性align存在冲突，如果两个都设置，后设置会生效。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-161
爬取时间: 2025-05-08 05:03:48
来源: Huawei Developer


支持calc属性，具体可以参考文档示例代码中的calc使用方法。


参考链接


尺寸设置


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-163
爬取时间: 2025-05-08 05:03:58
来源: Huawei Developer


CustomDialogController在设置弹窗时，maskRect属性可以设置弹窗的偏移量和大小，其中x，y属性控制弹窗的偏移量。这两个属性目前不支持calc。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-164
爬取时间: 2025-05-08 05:04:08
来源: Huawei Developer


在onPageShow回调方法里通过router.getParams方法获取返回值。参考代码如下：


```less
import { router } from '@kit.ArkUI'; 
 
class InfoTmp { 
  age: number = 0 
} 
 
class RouTmp { 
  id: object = () => { 
  } 
  info: InfoTmp = new InfoTmp() 
} 
 
const params: RouTmp = router.getParams() as RouTmp; // 获取传递过来的参数对象 
const id: object = params.id // 获取id属性的值 
const age: number = params.info.age // 获取age属性的值
```


参考链接


页面跳转


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-165
爬取时间: 2025-05-08 05:04:17
来源: Huawei Developer


焦点事件默认情况下需要外接键盘的Tab键或方向键触发，点击触发焦点事件需要添加焦点控制属性focusOnTouch。


参考链接


焦点控制


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-166
爬取时间: 2025-05-08 05:04:27
来源: Huawei Developer


可以通过onScrollFrameBegin事件和scrollBy方法实现容器嵌套滚动。具体实现可以参考Scroll中的示例2。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-167
爬取时间: 2025-05-08 05:04:37
来源: Huawei Developer


可以通过属性动画的方式实现。


参考链接


属性动画


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-168
爬取时间: 2025-05-08 05:04:47
来源: Huawei Developer


需要在列表子项中添加focusable(true)进行获焦。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-169
爬取时间: 2025-05-08 05:04:57
来源: Huawei Developer


组件内置的点击事件和开发者自定义的onClick点击事件默认会和空格键绑定，并非与enter键绑定（UX规格）。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-170
爬取时间: 2025-05-08 05:05:06
来源: Huawei Developer


可以通过将button组件绑定参数stopPropagation来控制冒泡传递。


参考链接


按键事件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-171
爬取时间: 2025-05-08 05:05:16
来源: Huawei Developer


参考链接


页面间转场


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-172
爬取时间: 2025-05-08 05:05:27
来源: Huawei Developer


PanGesture用于触发拖动手势事件，滑动的最小距离distance默认为5vp时拖动手势识别成功。可以将distance值设为1，使拖动更灵敏，避免造成事件错乱。


参考链接


PanGesture


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-174
爬取时间: 2025-05-08 05:05:37
来源: Huawei Developer


可以在Button组件中绑定onTouch，并在onTouch中使用stopPropagation()阻止onTouch冒泡传递到父组件阻止冒泡传递。参考代码如下：


```less
@Entry 
@Component 
struct Index { 
 
  build() { 
    Row() { 
      Button('点击我') 
        .width(100) 
        .width(100) 
        .backgroundColor('#f00') 
        .onClick(() => { 
          console.log('Button onClick'); 
        }) 
        .onTouch((event) => { 
          console.log('Button onTouch'); 
          event.stopPropagation(); 
        }) 
    } 
    .onTouch(() => { 
      console.log('Row onTouch'); 
    }) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-176
爬取时间: 2025-05-08 05:05:47
来源: Huawei Developer


设置TextInput组件的focusable属性为false，此组件则不可获焦，就不会拉起系统默认的键盘。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-177
爬取时间: 2025-05-08 05:05:56
来源: Huawei Developer


在组件的onMouse回调中执行stopPropagation即可阻止鼠标事件冒泡到父组件。


参考链接


键鼠事件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-178
爬取时间: 2025-05-08 05:06:07
来源: Huawei Developer


可以使用pageTransition函数来实现页面转场效果，通过PageTransitionEnter和PageTransitionExit指定页面进入和退出的动画效果，将其slide属性设置为SlideEffect.Bottom，则页面入场时从下边划入，出场时滑出到下边，即可实现上下切换效果。参考代码如下：


```less
// Index.ets 
@Entry 
@Component 
struct PageTransition1 { 
  build() { 
    Stack({ alignContent: Alignment.Bottom }) { 
      Navigator({ target: 'pages/Page1'}) { 
        Image($r('app.media.ic_banner01')).width('100%').height(200) // 图片存放在media文件夹下 
      } 
    }.height('100%').width('100%') 
  } 
 
  pageTransition() { 
    PageTransitionEnter({ duration: 500, curve: Curve.Linear }).slide(SlideEffect.Bottom) 
    PageTransitionExit({ duration: 500, curve: Curve.Ease }).slide(SlideEffect.Bottom) 
  } 
}
```


```less
// Page1.ets 
@Entry 
@Component 
struct PageTransition2 { 
  build() { 
    Stack({ alignContent: Alignment.Bottom }) { 
      Navigator({ target: 'pages/Index'}) { 
        Image($r('app.media.ic_banner02')).width('100%').height(200) // 图片存放在media文件夹下 
      } 
    }.height('100%').width('100%') 
  } 
 
  pageTransition() { 
    PageTransitionEnter({ duration: 500, curve: Curve.Linear }).slide(SlideEffect.Bottom) 
    PageTransitionExit({ duration: 500, curve: Curve.Ease }).slide(SlideEffect.Bottom) 
  } 
}
```


参考链接


页面间转场


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-179
爬取时间: 2025-05-08 05:06:17
来源: Huawei Developer


问题现象


一个页面底部默认显示自定义组件A，点击自定义组件A，则A消失，自定义组件B从底部出现；点击自定义组件B，则组件B消失，A从底部出现。这个效果要如何实现？


解决措施


可以使用transition产生组件转场动画，其参数type用来设置组件变化场景，包括新增和删除；参数translate用来设置转场时的平移效果。注意transition需要配合animateTo才能生效，动效时长、曲线、延时跟随animateTo中的配置。参考代码如下：


```less
@Entry 
@Component 
struct ComponentTransition { 
  @State flag: boolean = true; 
 
  build() { 
    Stack({ alignContent: Alignment.Bottom }) { 
        if (this.flag) { 
          ComponentChild1({ flag: $flag }) 
            .transition({ type: TransitionType.Insert,translate: { x: 0, y: 200 } }) 
        } 
        if (!this.flag) { 
          ComponentChild2({ flag: $flag }) 
            .transition({ type: TransitionType.Insert, translate: { x: 0, y: 200 } }) 
        } 
    }.height('100%').width('100%') 
  } 
} 
 
@Component 
struct ComponentChild1 { 
  @Link flag: boolean 
 
  build() { 
    Column() { 
      Image($r('app.media.ic_banner01'))//resources\base\media路径 
        .width('100%') 
        .height(200) 
        .onClick(() => { 
          animateTo({ duration: 1000 }, () => { 
            this.flag = !this.flag; 
          }) 
        }) 
    } 
  } 
} 
 
@Component 
struct ComponentChild2 { 
  @Link flag: boolean 
 
  build() { 
    Column() { 
      Image($r('app.media.ic_banner02'))//resources\base\media路径 
        .width('100%') 
        .height(200) 
        .onClick(() => { 
          animateTo({ duration: 1000 }, () => { 
            this.flag = !this.flag; 
          }) 
        }) 
    } 
  } 
}
```


参考链接


组件内转场


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-180
爬取时间: 2025-05-08 05:06:26
来源: Huawei Developer


ArkUI目前不支持事件传递链，可通过状态同步@Link或@Provide和@Consume进行父子组件间的状态通知，结合@Watch可以将状态变量的修改在组件间传递，实现类似的功能。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-181
爬取时间: 2025-05-08 05:06:36
来源: Huawei Developer


若对应事件对象Event下存在stopPropagation方法，就可以调用 event.stopPropagation()来阻塞事件冒泡。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-183
爬取时间: 2025-05-08 05:06:46
来源: Huawei Developer


问题现象


在绑定ratios为[0, 1]的情况下，对于突然消失的组件会触发两次onVisibleAreaChange方法。


解决措施


规格就是如此，如果想只触发一次，就只能设置一个ratios。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-184
爬取时间: 2025-05-08 05:06:56
来源: Huawei Developer


不支持。在第一次初始化变量的时候，@Watch绑定的回调函数不会被调用，即认为初始化不是状态变量的改变。只有在后续变量改变时，才会调用@Watch回调方法。


参考链接


@Watch装饰器


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-185
爬取时间: 2025-05-08 05:07:05
来源: Huawei Developer


@Watch设计的用途是为了快速的计算，其在UI重新渲染之前执行，不建议在@Watch函数中调用async await，异步行为会延迟组件的重新渲染，可能会导致性能问题。


参考链接


@Watch装饰器


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-187
爬取时间: 2025-05-08 05:07:14
来源: Huawei Developer


先通过exitFullscreen()取消全屏展示，再移除Video组件。


参考链接


Video组件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-188
爬取时间: 2025-05-08 05:07:24
来源: Huawei Developer


问题现象


Button嵌套Button时，外部调用stopPropagation没有阻止内部Button触发onTouch事件。


```less
Button() { 
  Button() 
    .onTouch(xx) 
} 
.onTouch((event: TouchEvent) => { 
  // 没有阻止内部的button触发onTouch事件 
  event.stopPropagation(); 
})
```


解决措施


stopPropagation是阻止事件冒泡，事件冒泡是从里到外触发的，所以给外层按钮设置无效，如果想给外层按钮设置属性从而阻止里层按钮触发触摸事件，可以给外层按钮添加.hitTestBehavior(HitTestMode.Block)。


参考链接


触摸测试控制


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-190
爬取时间: 2025-05-08 05:07:34
来源: Huawei Developer


获取指定窗口对象Window后，在该对象上使用getWindowProperties()获取窗口各个属性，在属性windowRect中获取窗口宽高信息。如果要在页面中获取窗口宽高信息，需要注意获取的正确时机。页面生命周期aboutToAppear阶段，不代表此时窗口可见，仅代表当前组件已创建，此时获取到的窗口尺寸信息（windowRect）可能有误。建议在页面生命周期onPageShow阶段获取，该阶段会在窗口可见后调用，此时可以拿到窗口正确的宽高信息。参考代码如下：


```less
import { window } from '@kit.ArkUI'; 
import { BusinessError } from '@kit.BasicServicesKit' 
 
//如果需要在页面中获取窗口宽高信息，建议将以下代码放在页面生命周期onPageShow阶段，不要在页面生命周期aboutToAppear阶段中调用
let windowClass: window.Window | undefined = undefined; 
try { 
  let promise = window.getLastWindow(this.context); 
  promise.then((data)=> { 
    //获取窗口对象 
    windowClass = data; 
    try { 
      //获取窗口属性 
      let properties = windowClass.getWindowProperties(); 
      let rect = properties.windowRect; 
      //rect.width: 窗口宽度；rect.height: 窗口高度 
    } catch (exception) { 
      console.error('Failed to obtain the window properties. Cause: ' + JSON.stringify(exception)); 
    } 
    console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data)); 
  }).catch((err: BusinessError)=>{ 
    console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err)); 
  });} catch (exception) { 
  console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception)); 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-191
爬取时间: 2025-05-08 05:07:44
来源: Huawei Developer


通用属性width支持设置变量，示例如下：


```less
@Entry 
@Component 
struct Page1 { 
  @State message: string = 'Hello'; 
  @State widNum: number = 300; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .width(this.widNum) 
          .backgroundColor(Color.Blue) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


效果如下：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160838.10775761488354666584330059364799:50001231000000:2800:C445CBD9955D4B16C7C2116862707916A5E0E9BCC3D3B07C405E1083474F513C.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-192
爬取时间: 2025-05-08 05:07:53
来源: Huawei Developer


Object.values(对象名).indexOf(想要判断的值)，若返回-1表示不包含对应值，返回值不等于-1则表示包含。


```less
var res = array.indexOf(val)
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-193
爬取时间: 2025-05-08 05:08:03
来源: Huawei Developer


在UIAbility的onWindowStageCreate的生命周期中设置setWindowSystemBarEnable接口即可。


```less
onWindowStageCreate(windowStage){ 
  windowStage.getMainWindowSync().setWindowSystemBarEnable([]) 
  // ... 
}
```


参考链接


体验窗口沉浸式能力


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-194
爬取时间: 2025-05-08 05:08:13
来源: Huawei Developer


采用窗口的setPreferredOrientation方法可以实现该效果，将orientation参数设置为window.Orientation.PORTRAIT时，可锁定屏幕为竖屏。参考代码如下：


```typescript
import { BusinessError } from '@kit.BasicServicesKit'; 
import { window } from '@kit.ArkUI'; 
 
//1.获取窗口实例对象，新建窗口使用createWindow方法，获取已有的窗口使用findWindow方法 
let windowClass: window.Window | undefined = undefined; 
let config: window.Configuration = { 
  name: "alertWindow",  
  windowType: window.WindowType.TYPE_SYSTEM_ALERT,  
  ctx: this.context 
}; 
try { 
  let promise = window.createWindow(config); 
  promise.then((data)=> { 
    windowClass = data; 
    console.info('Succeeded in creating the window. Data:' + JSON.stringify(data)); 
  }).catch((err: BusinessError)=>{ 
    console.error('Failed to create the Window. Cause:' + JSON.stringify(err)); 
  });} catch (exception) { 
  console.error('Failed to create the window. Cause: ' + JSON.stringify(exception)); 
} 
//2.窗口实例使用setPreferredOrientation方法，设置窗口的显示方向，PORTRAIT为固定竖屏，其他方向可参照参考链接 
let orientation = window.Orientation.PORTRAIT; 
try { 
  let windowClass: window.Window = window.findWindow("test"); 
  windowClass.setPreferredOrientation(orientation, (err: BusinessError) => { 
    const errCode: number = err.code; 
    if (errCode) { 
      console.error('Failed to set window orientation. Cause: ' + JSON.stringify(err)); 
      return; 
    } 
    console.info('Succeeded in setting window orientation.'); 
  }); 
} catch (exception) { 
  console.error('Failed to set window orientation. Cause: ' + JSON.stringify(exception)); 
}
```


参考链接


window.Orientation


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-195
爬取时间: 2025-05-08 05:08:22
来源: Huawei Developer


问题现象


调用window实例的setWindowSystemBarProperties接口时，设置isStatusBarLightIcon和isNavigationBarLightIcon属性不生效。


解决措施


状态栏字体高亮属性的本质就只是让字体变成白色。调用window实例的setWindowSystemBarProperties接口时，如果设置了状态栏内容颜色statusBarContentColor，就以开发者设置的颜色为准，isStatusBarLightIcon状态栏字体高亮属性就不生效；同理，如果设置了导航栏内容颜色navigationBarContentColor，isNavigationBarLightIcon导航栏字体高亮属性就不生效。


参考链接


window.setWindowSystemBarProperties


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-196
爬取时间: 2025-05-08 05:08:32
来源: Huawei Developer


获取窗口实例对象后，调用setWindowKeepScreenOn方法可设置屏幕是否常亮。


```typescript
import { BusinessError } from '@kit.BasicServicesKit'; 
import { window } from '@kit.ArkUI'; 
 
let isKeepScreenOn: boolean = true; 
let windowClass: window.Window = window.findWindow("test"); 
try { 
  windowClass.setWindowKeepScreenOn(isKeepScreenOn, (err: BusinessError) => { 
    const errCode: number = err.code; 
    if (errCode) { 
      console.error('Failed to set the screen to be always on. Cause: ' + JSON.stringify(err)); 
      return; 
 
    } 
    console.info('Succeeded in setting the screen to be always on.'); 
  }); 
} catch (exception) { 
  console.error('Failed to set the screen to be always on. Cause: ' + JSON.stringify(exception)); 
}
```


参考链接


setWindowKeepScreenOn


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-197
爬取时间: 2025-05-08 05:08:42
来源: Huawei Developer


问题现象


监听窗口大小变化。


解决措施


获取窗口实例对象后，可以通过window.on('windowSizeChange')方法实现对窗口尺寸大小变化的监听。


需要注意的是，在window侧如果窗口大小没发生变化，此监听不会被触发。如直接旋转180度的情况下，窗口大小并没有改变，此时不会通知回调。在这种情况下，应用可以通过监听display.on('change')事件，在callback中通过display接口来获取窗口尺寸大小。


```less
try {
  windowClass.on('windowSizeChange', (data) => {
    console.info('Succeeded in enabling the listener for window size changes. Data: ' + JSON.stringify(data));
  });
} catch (exception) {
  console.error('Failed to enable the listener for window size changes. Cause: ' + JSON.stringify(exception));
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-198
爬取时间: 2025-05-08 05:08:51
来源: Huawei Developer


引入屏幕属性模块，可以通过调用display.getDefaultDisplaySync()方法获取display对象后，从而获取到屏幕的宽度、高度、分辨率和横竖屏等信息。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-199
爬取时间: 2025-05-08 05:09:01
来源: Huawei Developer


在EntryAbility的onWindowStageCreate方法中通过windowStage获取window，然后分别调用setWindowLayoutFullScreen和setWindowSystemBarEnable方法。参考代码如下：


```typescript
import { UIAbility } from '@kit.AbilityKit'; 
import { window } from '@kit.ArkUI'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
export default class EntryAbility extends UIAbility { 
  onWindowStageCreate(windowStage: window.WindowStage) { 
    // 1.获取应用主窗口。 
    let windowClass: window.Window | null = null; 
    windowStage.getMainWindow((err: BusinessError, data) => { 
      let errCode: number = err.code; 
      if (errCode) { 
        console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err)); 
        return; 
      } 
      windowClass = data; 
      console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(data)); 
 
      // 2.实现沉浸式效果。方式一：设置导航栏、状态栏不显示。 
      let names: Array<'status' | 'navigation'> = []; 
      windowClass.setWindowSystemBarEnable(names, (err: BusinessError) => { 
        let errCode: number = err.code; 
        if (errCode) { 
          console.error('Failed to set the system bar to be visible. Cause:' + JSON.stringify(err)); 
          return; 
        } 
        console.info('Succeeded in setting the system bar to be visible.'); 
      }); 
      // 2.实现沉浸式效果。方式二：设置窗口为全屏布局，配合设置导航栏、状态栏的透明度、背景/文字颜色及高亮图标等属性，与主窗口显示保持协调一致。 
      let isLayoutFullScreen = true; 
      windowClass.setWindowLayoutFullScreen(isLayoutFullScreen, (err: BusinessError) => { 
        let errCode: number = err.code; 
        if (errCode) { 
          console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err)); 
          return; 
        } 
        console.info('Succeeded in setting the window layout to full-screen mode.'); 
      }); 
      let sysBarProps: window.SystemBarProperties = { 
        statusBarColor: '#ff00ff', 
        navigationBarColor: '#00ff00', 
        statusBarContentColor: '#ffffff', 
        navigationBarContentColor: '#ffffff' 
      }; 
      windowClass.setWindowSystemBarProperties(sysBarProps, (err: BusinessError) => { 
        let errCode: number = err.code; 
        if (errCode) { 
          console.error('Failed to set the system bar properties. Cause: ' + JSON.stringify(err)); 
          return; 
        } 
        console.info('Succeeded in setting the system bar properties.'); 
      }); 
    }) 
    // 3.为沉浸式窗口加载对应的目标页面。 
    windowStage.loadContent("pages/page2", (err: BusinessError) => { 
      let errCode: number = err.code; 
      if (errCode) { 
        console.error('Failed to load the content. Cause:' + JSON.stringify(err)); 
        return; 
      } 
      console.info('Succeeded in loading the content.'); 
    }); 
  } 
};
```


参考链接


体验窗口沉浸式能力


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-200
爬取时间: 2025-05-08 05:09:11
来源: Huawei Developer


可以通过getWindowProperties这个接口获取窗口属性，窗口属性的windowRect是窗口的尺寸。参考代码如下：


```less
import { window } from '@kit.ArkUI'; 
 
// 获取窗口对象 
async getWindowProperties(){ 
  let windowClass = await window.getLastWindow(getContext()); 
  // 获取窗口属性 
  let properties = windowClass.getWindowProperties(); 
  // 获取窗口宽高 
  console.log("width: "+ properties.windowRect.width); 
  console.log("height: "+ properties.windowRect.height); 
}
```


参考链接


窗口属性


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-201
爬取时间: 2025-05-08 05:09:21
来源: Huawei Developer


问题现象


通过window创建的窗口默认焦点不在界面上，导致不响应返回事件。


解决措施


模态窗口是给系统权限申请弹窗用的，默认不能响应back手势事件。使用setDialogBackGestureEnabled接口设置模态窗口是否响应手势返回事件，设置为true时，模态窗口可响应onBackPress回调。参考代码如下：


```typescript
// EntryAbility.ets
import { UIAbility } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { window } from '@kit.ArkUI';


export default class EntryAbility extends UIAbility {
  onWindowStageCreate(windowStage: window.WindowStage): void {
    console.info('onWindowStageCreate');
    let windowClass: window.Window | undefined = undefined;
    let config: window.Configuration = {
      name: "test",
      windowType: window.WindowType.TYPE_DIALOG,
      ctx: this.context
    };
    try {
      window.createWindow(config, (err: BusinessError, data) => {
        const errCode: number = err.code;
        if (errCode) {
          console.error(`Failed to create the window. Cause code: ${err.code}, message: ${err.message}`);
          return;
        }
        windowClass = data;
        windowClass.setUIContent('pages/Index');
        let enabled = true;
        let promise = windowClass.setDialogBackGestureEnabled(enabled);
        promise.then(() => {
          console.info('Succeeded in setting dialog window to respond back gesture.');
        }).catch((err: BusinessError) => {
          console.error(`Failed to set dialog window to respond back gesture. Cause code: ${err.code}, message: ${err.message}`);
        });
      });
    } catch (exception) {
      console.error(`Failed to create the window. Cause code: ${exception.code}, message: ${exception.message}`);
    }
  }
}
```


参考链接


setDialogBackGestureEnabled


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-202
爬取时间: 2025-05-08 05:09:31
来源: Huawei Developer


获取系统状态栏，导航栏等避让区域，使用系统提供的getWindowAvoidArea获取系统规避区域，返回值中的topRect.height即为系统状态栏高度，单位为px。参考代码如下：


```less
// MainAbility.ets
import { common, UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';


/**
 * 获取系统状态栏，导航栏高度
 * @param context
 * @returns
 */
async function getWindowAvoidArea(context: common.UIAbilityContext): Promise<window.AvoidArea | null> {
  try {
    const mainWindow = await window.getLastWindow(context);
    const avoidAreaType = window.AvoidAreaType.TYPE_SYSTEM; // 系统默认区域，包括状态栏，导航栏
    const avoidArea = mainWindow.getWindowAvoidArea(avoidAreaType);
    const height = avoidArea.topRect.height;
    return avoidArea
  } catch (e) {
    console.log('getWindowAvoidArea fail');
    return null
  }
}


export default class MainAbility extends UIAbility {
  // do something
  async onWindowStageCreate(windowStage: window.WindowStage) {
    getWindowAvoidArea(this.context);
    windowStage.loadContent('pages/index');
  }
  // do something
}
```


参考链接


getWindowAvoidArea


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-205
爬取时间: 2025-05-08 05:09:41
来源: Huawei Developer


系统提供的Tabs组件的TabBar仅支持居中对齐。可以通过自定义方式实现：使用Scroll和Row组件实现一个页签，在onclick事件中通过修改索引值和Tabs组件的索引联动，实现切换效果，同时将Tabs的barHeight置为0。具体实现可参考如下示例代码：


```less
// xxx.ets 
@Entry 
@Component 
struct TabsExample { 
  @State tabArray: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; 
  @State focusIndex: number = 0; 
  private controller: TabsController = new TabsController(); 
 
  build() { 
    Column() { 
      // 使用自定义页签组件 
      Scroll() { 
        Row() { 
          ForEach(this.tabArray, (item: number, index: number) => { 
            Row({ space: 20 }) { 
              Text('页签' + item) 
                .fontWeight(index === this.focusIndex ? FontWeight.Bold : FontWeight.Normal) 
            } 
            .padding({ left: 10, right: 10 }) 
            .onClick(() => { 
              this.controller.changeIndex(index); 
              this.focusIndex = index; 
            }) 
          }) 
        } 
      } 
      .align(Alignment.Start) 
      .scrollable(ScrollDirection.Horizontal) 
      .scrollBar(BarState.Off) 
      .width('100%') 
 
      //tabs组件把tabbar隐藏 
      Tabs({ barPosition: BarPosition.Start, controller: this.controller }) { 
        ForEach(this.tabArray, (item: number, index: number) => { 
          TabContent() { 
            Text('我是页面 ' + item + " 的内容") 
              .fontSize(30) 
          } 
        }) 
      }.barHeight(0) 
    } 
    .height('100%') 
    .width('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-206
爬取时间: 2025-05-08 05:09:51
来源: Huawei Developer


设置方法：setPreferredOrientation(orientation: Orientation, callback: AsyncCallback<void>): void，Orientation取值为AUTO_ROTATION，表示传感器自动旋转模式。参考代码如下：


```less
import { BusinessError } from '@kit.BasicServicesKit'; 
 
let orientation = window.Orientation.AUTO_ROTATION; 
try{ 
  windowClass.setPreferredOrientation(orientation, (err) => { 
    if(err.code){ 
      console.error('Failed to set window orientation. Cause: ' + JSON.stringify(err)); 
      return; 
    } 
    console.info('Succeeded in setting window orientation.'); 
  }); 
}catch (exception) { 
  console.error('Failed to set window orientation. Cause: ' + JSON.stringify(exception)); 
}
```


参考链接


横竖屏切换API


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-207
爬取时间: 2025-05-08 05:10:00
来源: Huawei Developer


componentUtils.getRectangleById会根据组件ID获取组件实例对象, 通过组件实例对象将获取的坐标位置和大小同步返回，因此动画过程中没有回调通知到应用，需要动画结束后返回组件大小、位置、平移缩放旋转及仿射矩阵属性信息，如果每帧都频繁通知会影响性能和功耗。


参考链接


componentUtils.getRectangleById


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-208
爬取时间: 2025-05-08 05:10:10
来源: Huawei Developer


Image组件已经提供了与点九图相同功能的API设置，可以通过设置resizable属性来设置ResizableOptions，也就是图像拉伸时可调整大小的图像选项。ResizableOptions的参数slice是边框宽度类型，用于描述组件边框不同方向的宽度。slice中的top属性可设置图片顶部拉伸时保持不变的距离，right属性可设置图片右部拉伸时保持不变的距离，bottom属性可设置图片底部拉伸时保持不变的距离，left属性可设置图片左部拉伸时保持不变的距离。


参考代码如下：


```less
@Entry 
@Component 
struct NineMapPrinciple { 
  build() { 
    Row() { 
      Image($r('app.media.startIcon')) 
        .resizable({ slice: { top: 10, left: 10, bottom: 50, right: 50 } }) 
    } 
    .height('50%') 
  } 
}
```


九图的常见用法是实现聊天气泡拉伸的效果，参考代码如下：


```typescript
import { MeasureText } from '@kit.ArkUI';


@Entry
@Component
struct ChatBubbleStretchDemo {
  @State text: string = 'Hello World Hello World Hello World Hello World';
  @State left: number = 10;
  @State right: number = 10;
  @State top: number = 10;
  @State bottom: number = 10;
  @State line: number = 2;
  @State textSize: SizeOptions = MeasureText.measureTextSize({
    textContent: this.text
  });


  build() {
    Column() {
      Stack() {
        Image($r('app.media.lightBluexhdpi'))
          .width(px2vp(Number(`${this.textSize.width}`)) < 350 ? 60 + px2vp
          (Number(`${this.textSize.width}`)) : 350)
          .height(this.text.length < 40 ? 50 + px2vp(Number(`${this.textSize.height}`))
            : 50 + (px2vp(Number(`${this.textSize.height}`)) * this.line))
          .resizable({
            slice: {
              top: `${this.top}px`,
              left: `${this.left}px`,
              bottom: `${this.bottom}px`,
              right: `${this.right}px`
            }
          })
        Text(this.text)
      }
      .width(350)
      .height(200)
    }
    .height('100%')
    .width('100%')
  }
}
```


效果如图所示。


正常大小

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160838.28606814186435718832474716457342:50001231000000:2800:5B99B2B57CCF47DDE424FBD42CE1FF0CD03548DBEFA25F77B18B9873C208AE8F.png)

左右拉伸

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160838.15021493264298622046336877527206:50001231000000:2800:669DBA973CCEA138F592A90B3529396CC8908B2C45836E1A0609E247F4082842.png)

多行上下左右拉伸

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160838.34605855084021887783241720323666:50001231000000:2800:3255253BA8048D681C4C7E4FB620D501A4D4BC399BEA762896475D9CC6C3DFB4.png)

参考链接


ResizableOptions


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-209
爬取时间: 2025-05-08 05:10:20
来源: Huawei Developer


当组件状态变量改变时会刷新组件，可以分以下两种情况：


1.如果是组件的属性刷新，可将属性用状态变量储存，可以用watch监听状态变量的变化。


2.如果是组件大小变化，可以通过onSizeChange()，监听到组件区域的变化。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-210
爬取时间: 2025-05-08 05:10:30
来源: Huawei Developer


可参考示例代码：


```less
@CustomDialog 
struct CustomDialogExampleTwo { 
  controllerTwo?: CustomDialogController; 
 
  build() { 
    Column() { 
      Text('我是第二个弹窗') 
        .fontSize(30) 
        .height(100) 
      Button('点我关闭第二个弹窗') 
        .onClick(() => { 
          if (this.controllerTwo != undefined) { 
            this.controllerTwo.close(); 
          } 
        }) 
        .margin(20) 
    } 
  } 
} 
 
@CustomDialog 
struct CustomDialogExample { 
  @Link textValue: string; 
  @Link inputValue: string; 
  dialogControllerTwo: CustomDialogController | null = new CustomDialogController({ 
    builder: CustomDialogExampleTwo(), 
    alignment: DialogAlignment.Bottom, 
    offset: { dx: 0, dy: -25 } 
  }) 
  // 若需要自定义弹窗中传入多个其他弹窗的的Controller，当前自定义弹窗的controller定义需放在其他传入的controller后面 
  controller?: CustomDialogController; 
  cancel: () => void = () => { 
  } 
  confirm: () => void = () => { 
  } 
 
  build() { 
    Column() { 
      Text('Change text') 
        .fontSize(20) 
        .margin({ top: 10, bottom: 10 }) 
      TextInput({ placeholder: '', text: this.textValue }) 
        .height(60) 
        .width('90%') 
        .onChange((value: string) => { 
          this.textValue = value; 
        }) 
      Text('Whether to change a text?') 
        .fontSize(16) 
        .margin({ bottom: 10 }) 
      Flex({ justifyContent: FlexAlign.SpaceAround }) { 
        Button('cancel') 
          .onClick(() => { 
            if (this.controller != undefined) { 
              this.controller.close(); 
              this.cancel(); 
            } 
          }).backgroundColor(0xffffff).fontColor(Color.Black) 
        Button('confirm') 
          .onClick(() => { 
            if (this.controller != undefined) { 
              this.inputValue = this.textValue; 
              this.controller.close(); 
              this.confirm(); 
            } 
          }) 
          .backgroundColor(0xffffff) 
          .fontColor(Color.Red) 
      } 
      .margin({ bottom: 10 }) 
 
      Button('点我打开第二个弹窗') 
        .onClick(() => { 
          if (this.dialogControllerTwo != null) { 
            this.dialogControllerTwo.open(); 
          } 
        }) 
        .margin(20) 
    } 
    .borderRadius(10) 
  } 
} 
 
@Component 
export struct CustomDialogUser { 
  @State textValue: string = ''; 
  @State inputValue: string = 'click me'; 
  dialogController: CustomDialogController | null = new CustomDialogController({ 
    builder: CustomDialogExample({ 
      cancel: this.onCancel, 
      confirm: this.onAccept, 
      textValue: $textValue, 
      inputValue: $inputValue 
    }), 
    cancel: this.exitApp, 
    autoCancel: true, 
    alignment: DialogAlignment.Bottom, 
    offset: { dx: 0, dy: -20 }, 
    gridCount: 4, 
    customStyle: false, 
    backgroundColor: 0xd9ffffff, 
    cornerRadius: 10, 
  }) 
 
  // 在自定义组件即将析构销毁时将dialogController置空 
  aboutToDisappear() { 
    this.dialogController = null; // 将dialogController置空 
  } 
 
  onCancel() { 
    console.info('Callback when the first button is clicked'); 
  } 
 
  onAccept() { 
    console.info('Callback when the second button is clicked'); 
  } 
 
  exitApp() { 
    console.info('Click the callback in the blank area'); 
  } 
 
  build() { 
    Column() { 
      Button(this.inputValue) 
        .onClick(() => { 
          if (this.dialogController != null) { 
            this.dialogController.open(); 
          } 
        }) 
        .backgroundColor(0x317aff) 
    } 
    .width('100%') 
    .margin({ top: 5 }) 
  } 
}
```


详细内容可以参考自定义弹窗。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-211
爬取时间: 2025-05-08 05:10:40
来源: Huawei Developer


可以参考如下示例代码：


```typescript
@Component 
export struct GridExample { 
  @State numbers: string[] = []; 
  scroller: Scroller = new Scroller(); 
 
  // 拖拽过程样式 
  @Builder 
  pixelMapBuilder(text: string) { 
    Column() { 
      Text(text) 
        .fontSize(16) 
        .backgroundColor(0xF9CF93) 
        .width(80) 
        .height(80) 
        .textAlign(TextAlign.Center) 
    } 
  } 
 
  aboutToAppear() { 
    for (let i = 1; i <= 15; i++) { 
      this.numbers.push(i + ''); 
    } 
  } 
 
  // 交换数组位置 
  changeIndex(index1: number, index2: number) { 
    let temp: string; 
    temp = this.numbers[index1]; 
    this.numbers[index1] = this.numbers[index2]; 
    this.numbers[index2] = temp; 
  } 
 
  build() { 
    Column({ space: 5 }) { 
      Grid(this.scroller) { 
        ForEach(this.numbers, (day: string) => { 
          GridItem() { 
            this.pixelMapBuilder(day) 
          } 
        }) 
      } 
      .columnsTemplate('1fr 1fr 1fr') 
      .columnsGap(10) 
      .rowsGap(10) 
      .width('90%') 
      .backgroundColor(0xFAEEE0) 
      .height(500) 
      .editMode(true) // 设置Grid是否进入编辑模式，进入编辑模式可以拖拽Grid组件内部GridItem 
      .onItemDragStart((event: ItemDragInfo, itemIndex: number) => { // 第一次拖拽此事件绑定的组件时，触发回调。 
        // 设置拖拽过程中显示的图片 
        return this.pixelMapBuilder(this.numbers[itemIndex]); 
      }) 
      .onItemDrop((event: ItemDragInfo, itemIndex: number, insertIndex: number, isSuccess: boolean) => { 
        // 绑定此事件的组件可作为拖拽释放目标，当在本组件范围内停止拖拽行为时，触发回调。 
        // isSuccess=false时，说明drop的位置在grid外部；insertIndex > length时，说明有新增元素的事件发生 
        if (!isSuccess || insertIndex >= this.numbers.length) { 
          return; 
        } 
        this.changeIndex(itemIndex, insertIndex); 
      }) 
    } 
    .width('100%') 
    .margin({ top: 5 }) 
  } 
}
```


参考链接


Grid


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-214
爬取时间: 2025-05-08 05:10:49
来源: Huawei Developer


```less
import { UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';


export default class EntryAbility extends UIAbility {
  onWindowStageCreate(windowStage: window.WindowStage) {
    // 1.获取应用主窗口。
    let windowClass: window.Window | undefined = undefined;
    windowStage.getMainWindow((err: BusinessError, data) => {
      if (err.code) {
        console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err));
        return;
      }
      windowClass = data;
      console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(data));


      // 2.实现沉浸式效果。方式一：设置导航栏、状态栏不显示。
      let names = [];
      windowClass.setWindowSystemBarEnable(names, (err) => {
        if (err.code) {
          console.error('Failed to set the system bar to be visible. Cause:' + JSON.stringify(err));
          return;
        }
        console.info('Succeeded in setting the system bar to be visible.');
      });
      // 2.实现沉浸式效果。方式二：设置窗口为全屏布局，配合设置导航栏、状态栏的透明度、背景/文字颜色及高亮图标等属性，与主窗口显示保持协调一致。
      let isLayoutFullScreen = true;
      windowClass.setWindowLayoutFullScreen(isLayoutFullScreen, (err) => {
        if (err.code) {
          console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));
          return;
        }
        console.info('Succeeded in setting the window layout to full-screen mode.');
      });
      let sysBarProps: window.SystemBarProperties = {
        statusBarColor: '#ff00ff',
        navigationBarColor: '#00ff00',
        // 以下两个属性从API Version 8开始支持
        statusBarContentColor: '#ffffff',
        navigationBarContentColor: '#ffffff'
      };
      windowClass.setWindowSystemBarProperties(sysBarProps, (err) => {
        if (err.code) {
          console.error('Failed to set the system bar properties. Cause: ' + JSON.stringify(err));
          return;
        }
        console.info('Succeeded in setting the system bar properties.');
      });
    })
    // 3.为沉浸式窗口加载对应的目标页面。
    windowStage.loadContent("pages/page2", (err) => {
      if (err.code) {
        console.error('Failed to load the content. Cause:' + JSON.stringify(err));
        return;
      }
      console.info('Succeeded in loading the content.');
    });
  }
};
```

- 方式一：调用setWindowSystemBarEnable接口，设置导航栏、状态栏不显示，从而达到沉浸式效果。
- 方式二：调用setWindowLayoutFullScreen接口，设置应用主窗口为全屏布局；然后调用setWindowSystemBarProperties接口，设置导航栏、状态栏的透明度、背景/文字颜色以及高亮图标等属性，使之保持与主窗口显示协调一致，从而达到沉浸式效果。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-215
爬取时间: 2025-05-08 05:11:00
来源: Huawei Developer


软键盘的收起和弹出和输入框的获焦和失焦有关，可以通过focusControl动态的控制输入框焦点的转移，从而控制软键盘的收起和弹出。同时通过将焦点转移到目标输入框完成键盘的动态切换。参考代码如下：


```typescript
@Entry 
@Component 
struct DynamicControlKeyboard { 
  private flag: boolean = true; 
  @Builder 
  Kb() { 
    Row() { 
      Text('自定义键盘') 
    } 
    .justifyContent(FlexAlign.Center) 
    .width('1260px') 
    .height('1161px') 
    .backgroundColor(Color.Brown) 
  } 
  build() { 
    Column({space: 10}) { 
      TextInput() 
        .key('key1') 
        .onAppear(() => { 
          focusControl.requestFocus('key1'); 
        }) 
        .defaultFocus(true) 
      TextInput() 
        .key('key2') 
        .customKeyboard(this.Kb()) 
      Button('切换TextInput') 
        .onClick(() => { 
          if (this.flag) { 
            console.info('TextInput2 ==> ' + focusControl.requestFocus('key2')); 
          } else { 
            console.info('TextInput1 ==> ' + focusControl.requestFocus('key1')); 
          } 
          this.flag = !this.flag; 
        }) 
      Button() 
        .width(0) 
        .height(0) 
        .key('key3') 
    } 
    .padding({ top: 20 }) 
    .width('100%') 
    .height('100%') 
    .onClick(() => { 
      focusControl.requestFocus('key3'); 
    }) 
  } 
}
```


效果如图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160839.25963227102810279259688095821431:50001231000000:2800:2958B6A7BB7629CA64A8F721B457321B316CFF00903DABB7B5EAEA99D7839EEF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160839.07418304716135501847481830700508:50001231000000:2800:D62EA307BF4898F549879BBF5FBF5F59C6B9A456C3494E3AA7F05E47C954D2A1.png)

参考链接


focusControl


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-216
爬取时间: 2025-05-08 05:11:10
来源: Huawei Developer


使用iconfont开发者需要先拿到字体库对应的ttf文件，然后通过font.registerFont接口去注册，在Text上使用对应的unicode编码格式就可以使用了。参考代码如下：


```typescript
import { font } from '@kit.ArkUI' 
@Entry 
@Component 
struct UseIconFont { 
  // 假设0000为指定icon的Unicode，实际需要开发者从注册的iconFont的ttf文件里面获取Unicode 
  @State unicode: string = '\u0000'; 
  aboutToAppear(): void { 
    font.registerFont({ 
      familyName: 'iconfont', 
      familySrc: 'xxx.ttf' 
    }) 
  } 
  build() { 
    Row() { 
      Column() { 
        Text(this.unicode) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .fontFamily('iconfont') 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


font.registerFont


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-217
爬取时间: 2025-05-08 05:11:19
来源: Huawei Developer


1. Image的缓存策略


Image模块提供了三级Cache机制，解码后内存图片缓存、解码前数据缓存、物理磁盘缓存。在加载图片时会逐级查找，如果在Cache中找到之前加载过的图片则提前返回对应的结果。


2. Image组件如何配置打开和关闭缓存

- 内存图片缓存：通过setImageCacheCount接口打开缓存，如果希望每次联网都获取最新资源，可以不设置或设置为0不缓存。
- 磁盘缓存：磁盘缓存是默认开启的，默认值为100M，可以将setImageFileCacheSize的值设置为0关闭磁盘缓存。
- 解码前数据缓存：通过setImageRawDataCacheSize设置内存中缓存解码前图片数据的大小上限，单位为字节，提升再次加载同源图片的加载速度。如果不设置则默认为0，不进行缓存。

setImageCacheCount、setImageRawDataCacheSize、和setImageFileCacheSize这三个图片缓存接口并不灵活，且后续不继续演进，对于复杂情况，更推荐使用ImageKnife。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-218
爬取时间: 2025-05-08 05:11:29
来源: Huawei Developer


当前自定义弹窗的规格是在页面跳转之后，弹窗会消失。想要实现当前页面弹窗在页面跳转返回之后还存在，可以使用Stack组件模拟出Dialog弹窗，实现页面跳转之后返回Dialog依然显示的效果。代码如下所示：


1. 当前页面


```less
import { router } from '@kit.ArkUI'; 
 
@Component 
struct DialogJumpRetained { 
  @State visible: Visibility = Visibility.None; 
 
  build() { 
    Stack() { 
      Row() { 
        Column() { 
          Text('Hello World') 
            .fontSize(50) 
            .fontWeight(FontWeight.Bold) 
          Button('click') 
            .onClick(() => { 
              if (this.visible === Visibility.Visible) { 
                this.visible = Visibility.None; 
              } else { 
                this.visible = Visibility.Visible; 
              } 
            }) 
            .backgroundColor(0x777474) 
            .fontColor(0x000000) 
        } 
        .width('100%') 
      } 
      .height('100%') 
      .backgroundColor(Color.Orange) 
 
      Text('') 
        .onClick(() => { 
          if (this.visible == Visibility.Visible) { 
            this.visible = Visibility.None; 
          } else { 
            this.visible = Visibility.Visible; 
          } 
        }) 
        .width('100%') 
        .height('100%') 
        .opacity(0.5) 
        .backgroundColor(0x000000) 
        .visibility(this.visible) 
      Column() { 
        GridRow({ 
          columns: { 
            xs: 1, 
            sm: 4, 
            md: 8, 
            lg: 12 
          }, 
          breakpoints: { 
            value: ['400vp', '600vp', '800vp'], 
            reference: BreakpointsReference.WindowSize 
          } 
        }) { 
          GridCol({ 
            span: { 
              xs: 1, 
              sm: 2, 
              md: 4, 
              lg: 8 
            }, 
            offset: { 
              xs: 0, 
              sm: 1, 
              md: 2, 
              lg: 2 
            } 
          }) { 
            Column() { 
              Text('隐私弹窗') 
                .fontSize(20) 
                .margin({ 
                  top: 10, 
                  bottom: 10 
                }) 
              Text('是否查看隐私详情') 
                .fontSize(16) 
                .margin({ bottom: 10 }) 
              Flex({ justifyContent: FlexAlign.SpaceAround }) { 
                Button('关闭弹窗') 
                  .onClick(() => { 
                    if (this.visible === Visibility.Visible) { 
                      this.visible = Visibility.None; 
                    } else { 
                      this.visible = Visibility.Visible; 
                    } 
                  }).backgroundColor(0xffffff).fontColor(Color.Black) 
                Button('跳转详情页') 
                  .onClick(() => { 
                    router.pushUrl({ 
                      url: 'pages/Second' 
                    }); 
                  }) 
                  .backgroundColor(0xffffff) 
                  .fontColor(Color.Red) 
              } 
              .margin({ bottom: 10 }) 
            } 
            .backgroundColor(0xffffff) 
            .visibility(this.visible) 
            .clip(true) 
            .borderRadius(20) 
          } 
        } 
      } 
      .width('95%') 
    } 
  } 
}
```


2. 详情页面


```typescript
import { router } from '@kit.ArkUI'; 
 
@Entry 
@Component 
struct Second { 
  @State message: string = '隐私详情页'; 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
        Button('返回').onClick(() => { 
          router.back({ 
            url: 'pages/DialogJumpRetained' 
          }); 
        }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-219
爬取时间: 2025-05-08 05:11:39
来源: Huawei Developer


键值的生成规则和itemGenerator 、keyGenerator有关：


1.如果是keyGenerator这个函数缺省，此时生成规则由框架确定，生成规则为item和index拼接，(item: any, index: number)=>{ return index +“_”+ JSON.stringify(item); }。


2.如果keyGenerator没有缺省且未包含index，当itemGenerator中包含index，生成的规则是自定义键值与index拼接成的字符串，如(item)=>item+2 对应的键值是 index+'_'+(item+2)，如果itemGenerator中未包含index，此时keyGenerator的生成规则是由开发者自定义的键值生成规则。


3.如果keyGenerator没有缺省,且包含index，此时不管itemGenerator中是否包含index，生成的键值规则都是开发者自定义的键值生成规格，框架不会对去拼接index。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-220
爬取时间: 2025-05-08 05:11:48
来源: Huawei Developer


在w3c标准中，flex组件主轴的默认大小是由子组件决定的，但是flex的align-items的默认值是stretch，也就是拉伸，因此在父flex组件不设置align-items时，子flex组件会在主轴上填满父组件，而当将父组件的align-items设置为其他值时，子flex组件由他自己的子组件决定主轴的大小了。


在ArkTS上，Flex组件主轴的默认大小是由父组件决定的，即在主轴方向上填满父组件，因此在不设置flex组件主轴大小的情况下，对齐方式alignItems是不会影响Flex组件的主轴大小的，且ArkTS中Flex组件的alignItems属性的默认值为ItemAlign.Start，因此设置了ItemAlign.Start后，Flex组件仍然会在主轴上填满父组件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-221
爬取时间: 2025-05-08 05:11:57
来源: Huawei Developer


1.ArkUI是声明式的语法，对于组件来说是一个struct，组件是无法支持继承，后续也无支持继承相关需求规划。


2.基于开发者的场景，如果开发者对应继承的诉求，是想抽出公共的父类，方便做组件复用则可以考虑通过动态属性设置attributeModifier来实现组件复用扩展，attributeModifier已经实现一部分能力，还有部分能力，以需求跟踪。


3.如果开发者的诉求是想在基类页面的生命周期统一做一些业务处理，这可以通过observer的无感监听能力，监听页面的生命周期，实现统一生命周期的诉求。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-222
爬取时间: 2025-05-08 05:12:06
来源: Huawei Developer


1.@Styles或@Extend目前不支持export导出，后续这两个装饰器不会继续演进。


2.推荐开发者使用新的样式复用方法，通过attributeModifier属性动态的设置组件，通过自定义class继承对应基础组件的Modifier，在class中设置复用的属性，对应class也没有无法export的限制。但是attributeModifier的复用能力仍有缺陷，目前不支持事件手势，这两个能力已有需求跟踪。


参考链接


attributeModifier


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-223
爬取时间: 2025-05-08 05:12:16
来源: Huawei Developer


可以通过给弹窗设置组件转场动画transition来实现，参考代码如下：


```typescript
@CustomDialog 
struct CustomDialogExample { 
  controller: CustomDialogController; 
  @State showFlag: Visibility = Visibility.Visible; 
 
  build() { 
    Column() { 
      Button('关闭弹窗') 
    } 
    .width('100%') 
    .height(400) 
    .backgroundColor(Color.Gray) 
    .onClick(() => { 
      this.cancel(); 
    }) 
    .visibility(this.showFlag) 
    //核心代码 设置动画事件为200ms ，设置组件转场时插入的起点和删除的终点为屏幕以下100vp 
    .transition(TransitionEffect.OPACITY.animation({ duration: 200 }).combine(TransitionEffect.translate({ y: 100 }))) 
  } 
 
  //在删除的时候需要注意，如果弹窗直接关闭是没有转场效果的，可以先用显隐控制， 
  //设置弹窗为隐藏，此时弹出向下退出的动效生效，再设置延时关闭弹窗。 
  cancel() { 
    this.showFlag = Visibility.Hidden; 
    setTimeout(() => { 
      this.controller.close(); 
    }, 200) 
  } 
} 
 
@Entry 
@Component 
struct CustomDialogUser { 
  dialogController: CustomDialogController = new CustomDialogController({ 
    builder: CustomDialogExample(), 
    autoCancel: false, 
    customStyle: true 
  }) 
 
  build() { 
    Column() { 
      Button('click me') 
        .onClick(() => { 
          this.dialogController.open(); 
        }) 
    } 
    .width('100%') 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-224
爬取时间: 2025-05-08 05:12:25
来源: Huawei Developer


组件设置expandSafeArea属性可以控制组件扩展其安全区域，实现键盘避让，键盘拉起时布局不发生改变。参考代码如下：


```less
@Entry 
@Component 
struct AvoidDialogPage { 
  @State message: string = '打开弹窗'; 
  dialogController: CustomDialogController = new CustomDialogController({ 
    builder: CustomDialogExample() 
  }) 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            this.dialogController.open(); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
} 
 
@CustomDialog 
struct CustomDialogExample { 
  controller: CustomDialogController = new CustomDialogController({ 
    builder: CustomDialogExample({}) 
  }) 
 
  build() { 
    Column() { 
      TextInput({}) 
        .fontSize(20) 
        .margin({ top: 10, bottom: 10 }) 
        .expandSafeArea([SafeAreaType.KEYBOARD, SafeAreaType.SYSTEM]) 
        .borderWidth(0.5) 
        .borderRadius(4) 
        .height(40) 
        .defaultFocus(true) 
        .margin({ top: 30, left: 16, right: 16 }) 
    } 
  } 
}
```


参考链接


安全区域


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-225
爬取时间: 2025-05-08 05:12:35
来源: Huawei Developer


Canvas在声明式语法中是数据驱动UI进行刷新，可以将变化的数据通过@Watch监听，同时绑定一个自己封装的draw()方法，当数据刷新时就会调用Watch绑定的方法执行绘制逻辑。


参考代码如下：


```less
@Entry 
@Component 
struct CanvasContentUpdate { 
  private settings: RenderingContextSettings = new RenderingContextSettings(true); 
  private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings); 
  @State @Watch('draw')content: string = ''; 
 
  draw() { 
    this.context.clearRect(0, 0, 200, 200); // 清理画布内容 
    this.context.fillText(this.content, 50, 50); // 重新填充 
  } 
 
  build() { 
    Column() { 
      Canvas(this.context) 
        .width('100%') 
        .height('25%') 
        .backgroundColor('#F5DC62') 
        .onReady(() => { 
          //可以在这里绘制内容。 
          this.context.font = '55px sans-serif'; 
          this.context.fillText(this.content, 50, 50); 
        }) 
      TextInput({ 
        text:$$this.content 
      }) 
    } 
    .borderColor('#31525B') 
    .borderWidth(12) 
    .width('100%') 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-226
爬取时间: 2025-05-08 05:12:45
来源: Huawei Developer


自定义组件是一个struct不等同于class或者interface，无法使用泛型。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-228
爬取时间: 2025-05-08 05:12:55
来源: Huawei Developer


自定义组件是struct而不是class,无法储存在容器中。可以将自定义组件封装在Builder函数，通过Builder的封装来完成存储。


参考代码如下：


```typescript
@Component 
struct ComA { 
  build() { 
    Text('ComA').fontSize(50).fontWeight(FontWeight.Bold) 
  } 
} 
 
@Component 
struct ComB { 
  build() { 
    Text('ComB').fontSize(50).fontWeight(FontWeight.Bold) 
  } 
} 
 
@Component 
struct ComC { 
  build() { 
    Text('ComC').fontSize(50).fontWeight(FontWeight.Bold) 
  } 
} 
 
//if else逻辑分支写法 
@Builder 
function buildCom(param: string) { 
  if (param == 'ComA') { 
    ComA() 
  } else if (param == 'ComB') { 
    ComB() 
  } else if (param == 'ComC') { 
    ComC() 
  } 
} 
 
@Builder 
function buildComA() { 
  ComA() 
} 
 
@Builder 
function buildComB() { 
  ComB() 
} 
 
@Builder 
function buildComC() { 
  ComC() 
} 
 
//通过map封装在容器中 
let map: Map<string, WrappedBuilder<[]>> = new Map() 
map.set('ComA', wrapBuilder(buildComA)) 
map.set('ComB', wrapBuilder(buildComB)) 
map.set('ComC', wrapBuilder(buildComC)) 
 
@Component 
struct Page12 { 
  @State message: string = 'Hello World'; 
  @State arr: string[] = ['ComA', 'ComB', 'ComC']; 
 
  build() { 
    Column() { 
      ForEach(this.arr, (item: string) => { 
        //在使用时根据key去取 
        map.get(item)?.builder() 
      }) 
    } 
    .justifyContent(FlexAlign.Center) 
    .width('100%') 
    .height('100%') 
  } 
}
```


参考链接：


引用Builder函数


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-229
爬取时间: 2025-05-08 05:13:05
来源: Huawei Developer


问题场景：


子组件Child中有一个@BuilderParam参数，在父组件中使用子组件时将父组件中的builder函数传入子组件中。在builder函数中调用父组件中的方法时，出现报错Error message:is not callable。


问题代码如下：


```typescript
@Component 
struct Child { 
  @Builder FunABuilder0() {} 
  @BuilderParam aBuilder0: () => void = this.FunABuilder0; 
 
  build() { 
    Column() { 
      this.aBuilder0() 
    } 
  } 
} 
 
@Entry 
@Component 
struct Parent { 
  @Builder componentBuilder() { 
    Text('Parent builder') 
      .onClick(()=>{ 
        this.test1();
      }) 
  } 
 
  test1(): void { 
    console.log('test1');
  } 
 
  build() { 
    Column() { 
      Child({ aBuilder0: this.componentBuilder }) 
    } 
  } 
}
```


参考答复：


在js中调用this时需要注意this的指向。当前代码在子组件中声明builder方法时，this指向的是父组件，而@Builder componentBuilder()通过this.componentBuilder的形式传给子组件@BuilderParam customBuilderParam，this指向在Child的label，即“Child”，所以在点击事件响应的时候，this是指向Child而Child中没有test（）所以出现jscrash。需要在父组件中声明子组件时通过监听函数将this传递到子组件，应改为：


```less
Child({ aBuilder0:()=>{ this.componentBuilder() } }) 
```


参考链接


@BuilderParam装饰器


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-230
爬取时间: 2025-05-08 05:13:15
来源: Huawei Developer


前后台生命周期，是应用的生命周期，页面和组件并不感知，组件只有aboutToAppear和aboutToDisappear。如果组件需要感知应用切换前后台的生命周期变化，可以给组件设置一个应用前后台的变量，在应用前后台切换的时候，在UIAbility中对应的生命周期函数上更改此变量，在组件中获取AppStorage状态变量的改变并执行对应的逻辑。


参考代码如下：


```less
// EntryAbility中 
export default class EntryAbility extends UIAbility { 
  onWindowStageCreate(windowStage: window.WindowStage): void { 
    AppStorage.setOrCreate<boolean>('isOnForeground', true); 
  } 
 
  onForeground(): void { 
    AppStorage.set<boolean>('isOnForeground', true); 
  } 
 
  onBackground(): void { 
    AppStorage.set<boolean>('isOnForeground', false); 
 } 
}
```


```typescript
@Entry 
@Component 
struct ComponentListenFrontAndBack { 
  @State message: string = 'Hello World'; 
  @StorageLink('isOnForeground') isOnForeground: boolean = true; 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
        Vid({ isOnForeground: this.isOnForeground }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
} 
 
@Component 
struct Vid { 
  @Watch('change') @Link isOnForeground: boolean; 
  @State message: string = 'video'; 
 
  build() { 
    Text('message') 
      .fontSize(50) 
      .fontWeight(FontWeight.Bold) 
      .onClick(() => { 
        this.message += this.isOnForeground; 
        console.log('' + this.isOnForeground); 
      }) 
  } 
 
  change() { 
    if (this.isOnForeground) { 
      console.log('The component is on foreground.'); 
    } else { 
      console.log('The component is on background.'); 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-231
爬取时间: 2025-05-08 05:13:25
来源: Huawei Developer


目前ArkTs语法不支持这种链式调用，组件本身不是一个class对象，无法像普通对象一样调用方法，只能在组件声明的时候在参数里面，传递回调方法去修改组件的参数，无法直接通过链式调用方法。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-232
爬取时间: 2025-05-08 05:13:34
来源: Huawei Developer


自定义组件在创建之后，会默认给整个组件外面包裹一层不可见的容器。在声明自定义组件的时候，这些属性和样式是作用在这个不可见容器上。而不是自己作用在内部的根组件上，所以两者效果不同。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-233
爬取时间: 2025-05-08 05:13:44
来源: Huawei Developer


使用Stack堆叠组件和LoadingProgress加载组件来实现首次进入页面，页面加载的效果。参考代码如下：


```typescript
@Entry 
@Component 
struct PageLoading { 
  @State isLoading: Boolean = true; 
 
  aboutToAppear(): void { 
    // 模拟网络请求操作，请求网络3秒后得到数据，通知组件，变更列表数据 
    setTimeout(() => { 
      this.isLoading = false; 
    }, 3000); 
  } 
 
  build() { 
    Stack() { 
      if (this.isLoading) { 
        Column() { 
          LoadingProgress() 
            .color(Color.White) 
            .width(80).height(80) 
          Text('努力加载中..') 
            .fontSize(16) 
            .fontColor(Color.White) 
        } 
        .width('100%') 
        .height('100%') 
        .backgroundColor('#40000000') 
        .justifyContent(FlexAlign.Center) 
      } else { 
        Column(){ 
          Text('主页') 
        } 
      } 
    } 
    .width('100%') 
    .height('100%') 
    .backgroundColor(Color.White) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-234
爬取时间: 2025-05-08 05:13:54
来源: Huawei Developer


实现步骤如下：


1. 在oh-package.json5中添加第三方插件class-transformer的依赖；


2. 在使用第三方插件class-transformer的页面导入class-transformer库；


3. 定义要传递的类；


4. 在获取到其他页面传过来的参数后通过class-transformer的plainToClass方法转换成类对象；


5. 调用类对象的方法。


参考代码如下：


```less
import { PageOneTmp } from './PageOne' 
 
export class myInfo { 
  a: string = '123'; 
  getMyInfo(): void { 
    console.log('调用方法了') 
  } 
} 
 
@Entry 
@Component 
struct NavigationExample { 
  @Provide('pageInfo') pageInfo: NavPathStack = new NavPathStack(); 
 
  @Builder 
  PageMap(name: string) { 
    if (name === 'pageOne') { 
      PageOneTmp() 
    } 
  } 
 
  build() { 
    Navigation(this.pageInfo) { 
      Column() { 
        Button('点击跳转', { stateEffect: true, type: ButtonType.Capsule }) 
          .width('80%') 
          .height(40) 
          .margin(20) 
          .onClick(() => { 
            this.pageInfo.pushPath({ name: 'pageOne', param: new myInfo() }); 
          }) 
      } 
    }.title('NavIndex').navDestination(this.PageMap) 
  } 
}
```


```typescript
//pageOne 
import { myInfo } from './NavigationParameterTransferView' 
import { plainToClass } from "class-transformer"; 
 
@Component 
export struct PageOneTmp { 
  @Consume('pageInfo') pageInfo: NavPathStack; 
  @State info : myInfo = new myInfo(); 
 
  getParams(){ 
    const infoString = JSON.stringify(this.pageInfo.getParamByIndex(0)); 
    const infoTmp: myInfo = JSON.parse(infoString); 
    //通过调用第三方插件class-transformer的plainToClass方法转换成类对象, 
    //不进行转换直接使用userBookingTmp调用getUserInfo方法会造成crash 
    this.info = plainToClass(myInfo,infoTmp); 
  } 
 
  aboutToAppear(): void { 
    this.getParams(); 
  } 
 
  build() { 
    NavDestination() { 
      Column() { 
        Button('调用方法', { stateEffect: true, type: ButtonType.Capsule }) 
          .width('80%') 
          .height(40) 
          .margin(10) 
          .onClick(()=>{ 
            this.info.getMyInfo(); 
          }) 
      }.width('100%').height('100%') 
    }.title('pageOne') 
  } 
}
```


参考链接：


Navigation


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-235
爬取时间: 2025-05-08 05:14:04
来源: Huawei Developer


使用onTouch事件，在putDownPullUpRefresh方法里判断触摸事件是否满足下拉刷新和上滑加载的条件，同时使用条件渲染判断是否显示刷新和加载的布局。


参考代码如下：


```less
@Entry 
@Component 
struct PageToRefresh { 
  private currentOffsetY: number = 0; 
  @State refreshStatus: boolean = false; 
  @State refreshText: string = '正在刷新'; 
  @State pullUpText: string = '正在加载'; 
  private timer: number = 0; 
  @State isRefreshing: boolean = false; 
  @State isCanLoadMore: boolean = false; 
  @State ArrData: string[] = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']; 
  @State newArr: string [] = ['10', '11'] 
 
  putDownPullUpRefresh(event?: TouchEvent): void { 
    if (event === undefined) { 
      return; 
    } 
    switch (event.type) { 
      case TouchType.Down: 
        this.currentOffsetY = event.touches[0].y; 
        break; 
      case TouchType.Move: 
        let isDownPull = event.touches[0].y - this.currentOffsetY > 50; 
        if (isDownPull && this.isCanLoadMore === false) { 
          this.refreshStatus = true; 
        } 
 
        if (this.ArrData.length <= 11) { 
          this.isCanLoadMore = true; 
        } 
        break; 
      case TouchType.Cancel: 
        break; 
      case TouchType.Up: 
        if (this.refreshStatus) { 
          this.timer = setTimeout(() => { 
            this.refreshStatus = false; 
            this.ArrData = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']; 
          }, 1500) 
        } 
 
        if (this.isCanLoadMore) { 
          this.timer = setTimeout(() => { 
            this.isCanLoadMore = false; 
            this.newArr.forEach((item) => { 
              this.ArrData.push(item) 
            }) 
          }, 1000) 
        } 
 
        break; 
      default: 
        break; 
    } 
  } 
 
  @Builder 
  putDown() { 
    Row() { 
      Image($r('app.media.refreshing')) 
        .width(40) 
        .height(20) 
      Text(this.refreshText).fontSize(16) 
    } 
    .justifyContent(FlexAlign.Center) 
    .width('94%') 
    .height('10%') 
  } 
 
  @Builder 
  PullUp() { 
    Row() { 
      Image($r('app.media.refreshing')) 
        .width(40) 
        .height(40) 
      Text(this.pullUpText).fontSize(16) 
    } 
    .justifyContent(FlexAlign.Center) 
    .width('94%') 
    .height('5%') 
  } 
 
  build() { 
    Column() { 
      Scroll() { 
        Column() { 
          Text('商品') 
          if (this.refreshStatus) { 
            this.putDown() 
          } 
          ForEach(this.ArrData, (item: string) => { 
            ListItem() { 
              Text(item) 
                .height(100) 
            } 
          }, (item: string) => JSON.stringify(item)) 
          if (this.isCanLoadMore) { 
            this.PullUp() 
          } 
          if (!this.isCanLoadMore) { 
            Text('暂无更多数据') 
          } 
        } 
      } 
      .width('100%') 
      .onTouch((event?: TouchEvent) => { 
        this.putDownPullUpRefresh(event); 
      }) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-236
爬取时间: 2025-05-08 05:14:13
来源: Huawei Developer


通过Window.getWindowAvoidArea(window.AvoidAreaType.TYPE_CUTOUT).topRect来获取刘海的高度，在topRect中的取值中，top指刘海屏原点（矩形左上角）距离屏幕顶端的像素值，left为距屏幕左侧的像素值，width和height分别为刘海屏所在外包矩形的宽高。可根据语义进行计算，并以实际效果为准。


参考链接


@ohos.window (窗口)中的AvoidArea、窗口矩形区域Rect


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-237
爬取时间: 2025-05-08 05:14:23
来源: Huawei Developer


设置窗口为隐私模式后，截屏录屏或分享屏幕，屏幕会显示灰色蒙层（隐私窗口不允许这些操作）。


参考链接


@ohos.window (窗口)中的setWindowPrivacyMode


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-238
爬取时间: 2025-05-08 05:14:34
来源: Huawei Developer


问题现象


创建了一个window，加载自定义键盘后，发现底部按钮的下半部分不能响应点击事件。


解决措施


不存在，底部遮挡区域在20px左右，可以通过on('avoidAreaChange')获取，开发者也可以定义一个点击区域来测试点击事件能否触发，以下为代码示例：


```less
@Entry 
@Component 
struct Index { 
  build() { 
    Column() { 
      Column() { 
      } 
      .width('100%') 
      .height(5) // 5px点击范围 
      .backgroundColor(Color.Red) 
      .onClick(() => { 
        console.log("触发点击事件") 
      }) 
    } 
    .height('100%') 
    .width('100%') 
    .justifyContent(FlexAlign.End) 
  } 
}
```


参考链接


@ohos.window (窗口)中的on('avoidAreaChange')


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-239
爬取时间: 2025-05-08 05:14:43
来源: Huawei Developer


方法一：通过媒体查询


```typescript
import { mediaquery } from '@kit.ArkUI'; 
 
let listener = mediaquery.matchMediaSync('(orientation: landscape)'); //监听横屏事件 
function onPortrait(mediaQueryResult: mediaquery.MediaQueryResult) { 
  console.info('mediaQueryResult.matches:' + mediaQueryResult.matches) 
  if (mediaQueryResult.matches) { 
    // do something here 
  } else { 
    // do something here 
  } 
} 
listener.on('change', onPortrait) // 注册回调 
listener.off('change', onPortrait) // 取消注册回调 
 
@Entry 
@Component 
struct Index { 
  build() { 
    Column() { 
      Column() { 
        Text('test') 
      } 
      .width('100%') 
    } 
    .height('100%') 
    .width('100%') 
    .justifyContent(FlexAlign.End) 
  } 
}
```


方法二：


```typescript
import { display, window } from '@kit.ArkUI'; 
 
@Entry 
@Component 
struct windowRotation { 
  build() { 
    Text("Scroll Area") 
      .width("100%") 
      .height("100%") 
      .backgroundColor(0X330000FF) 
      .fontSize(16) 
      .textAlign(TextAlign.Center) 
      .onClick(() => { 
        window.getLastWindow(getContext(this), (err, win) => { 
          let cutOutInfo = win.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM_GESTURE) 
          console.log(JSON.stringify(cutOutInfo)) 
          if (window.Orientation.AUTO_ROTATION) { 
            let rotation: number = display.getDefaultDisplaySync().orientation // 获取当前屏幕的枚举值 
            console.log('' + rotation); 
            if (rotation == 0) { 
              console.log("CutOutInfo 竖屏数据： " + JSON.stringify(cutOutInfo)); 
            } else if (rotation == 1) { 
              console.log("CutOutInfo 横屏数据： " + JSON.stringify(cutOutInfo)); 
            } else if (rotation == 2) { 
              console.log("CutOutInfo 反向竖屏数据： " + JSON.stringify(cutOutInfo)); 
            } else { 
              console.log("CutOutInfo 反向横屏数据： " + JSON.stringify(cutOutInfo)); 
            } 
          } 
        }) 
      }) 
  }}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-240
爬取时间: 2025-05-08 05:14:53
来源: Huawei Developer


子窗口默认不会铺满全屏。使用setWindowSystemBarEnable设置窗口全屏模式时状态栏的可见模式，设置系统栏的API需要由主窗口调用。


参考链接


@ohos.window (窗口)中的setWindowSystemBarEnable


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-241
爬取时间: 2025-05-08 05:15:03
来源: Huawei Developer


问题现象


页面中使用Grid组件，因为GridItem数量不固定，且不允许滚动，理想中Grid组件高度会被GridItem内容自动撑起，实际体验中发现：


1. Grid必须显式设置固定height属性，这种由于GridItem数量不固定，且不允许出现滚动，不满足需求


2. 设置maxCount属性后，可以实现高度被撑起，但与文档的解释好像不符，且GridItem数量不固定，所以也不满足需求


3. Grid的height设置为auto时也不会被自动撑起。


可能原因


grid不会自适应子节点的高度，不设置高度就是和父组件一样高。


解决措施


目前有两个替代方案：


1.使用list替代，设置其lanes属性进行分列。


2.可以动态计算GridItem高度，然后给Grid的height设置高度。


参考代码如下：


```less
interface Item { 
  text: string 
  img: Resource 
} 
 
@Entry 
@Component 
struct Index { 
  data: Item[] = [ 
    { text: 'aaa', img: $r('app.media.app_icon') }, 
    { text: 'bbb', img: $r('app.media.app_icon') }, 
    { text: 'ccc', img: $r('app.media.app_icon') }, 
    { text: 'ddd', img: $r('app.media.app_icon') }, 
    { text: 'eee', img: $r('app.media.app_icon') }, 
    { text: 'fff', img: $r('app.media.app_icon') }, 
    { text: 'ggg', img: $r('app.media.app_icon') }, 
    { text: 'hhh', img: $r('app.media.app_icon') }, 
    { text: 'jjj', img: $r('app.media.app_icon') }, 
    { text: 'kkk', img: $r('app.media.app_icon') }] 
  // 计算Grid行数 
  getCategoryRowCount() { 
    return Math.ceil(this.data.length / 4); 
  } 
  // 根据item高度计算Grid的高度 
  getCategoryViewHeight() { 
    return `${68.33 * this.getCategoryRowCount()}vp`; 
  } 
 
  build() { 
    Column() { 
      Grid() { 
        ForEach(this.data, (item: Item) => { 
          GridItem() { 
            Column() { 
              Image(item.img) 
                .width(40) 
                .height(40) 
              Text(item.text) 
                .margin({ top: 2 }) 
                .fontSize(14) 
                .textAlign(TextAlign.Center) 
            } 
          } 
        }, (item: Item) => item.text) 
      } 
      .height(this.getCategoryViewHeight()) 
      .columnsTemplate('1fr 1fr 1fr 1fr') 
      .columnsGap(10) 
      .rowsGap(10) 
      .margin({ top: 10 }) 
    } 
    .padding(10) 
    .width('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-242
爬取时间: 2025-05-08 05:15:13
来源: Huawei Developer


可参考如下代码，获取了屏幕的宽和高，Display实例的所有属性见文档：@ohos.display (屏幕属性)。


```typescript
import { display } from '@kit.ArkUI'; 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'Hello World'; 
  private screenWidth: number = 0; 
  private screenHeight: number = 0; 
 
  aboutToAppear() { 
    try { 
      this.screenWidth = display.getDefaultDisplaySync().width; 
      this.screenHeight = display.getDefaultDisplaySync().height; 
    } catch (e) { 
      console.error('Fail with code: ' + JSON.stringify(e)); 
    } 
  } 
 
  build() { 
    Row() { 
      Column() { 
        Text('---->width: ' + this.screenWidth) 
        Text('---->height: ' + this.screenHeight) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-243
爬取时间: 2025-05-08 05:15:23
来源: Huawei Developer


问题现象


enabled的值为false时，点击Button按钮，会导致父组件的点击事件触发。


解决措施


对Button组件包裹一层容器组件，并设置hitTestBehavior属性， 属性值设置为HitTestMode.Block，可阻止事件的冒泡。具体可参考如下代码：


```less
@Entry 
@Component 
struct TouchExample { 
  @State text: string = '父组件' 
  @State parentComponentResponse: string = '父组件响应次数' 
  @State parentComponentResponseNum: number = 0 
 
  build() { 
    Column() { 
      Column(){ 
        Text(this.text).margin({bottom: 20}) 
        Text(this.parentComponentResponse + ':' + `${this.parentComponentResponseNum}`) 
        Row(){ 
          //对Button组件包裹一层容器组件，并设置hitTestBehavior属性， 属性值设置为HitTestMode.Block，可阻止事件的冒泡。 
          Button('disable的子组件').height(40).width(100).margin({top: 20}) 
        } 
        .hitTestBehavior(HitTestMode.Block) 
      }.onClick((e) => { 
        this.parentComponentResponseNum ++; 
      }) 
      .width('80%') 
      .height('30%') 
      .backgroundColor(Color.Gray) 
    } 
    .width('100%') 
    .padding(30) 
  } 
}
```


参考链接


触摸测试控制


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-244
爬取时间: 2025-05-08 05:15:32
来源: Huawei Developer


问题现象


触摸事件中，当子组件触发触摸事件的时候，父组件如果设置触摸事件的话，也会触发。


解决措施


在onTouch函数中执行event.stopPropagation()可阻止冒泡。具体可参考如下代码：


```less
@Entry 
@Component 
struct TouchExample { 
  @State text: string = '父组件' 
  @State parentComponentResponse: string = '父组件响应次数' 
  @State parentComponentResponseNum: number = 0 
  @State childComponentResponse: string = '子组件响应次数' 
  @State childComponentResponseNum: number = 0 
 
  build() { 
    Column() { 
      Column(){ 
        Text(this.text).margin({bottom: 20}) 
        Text(this.parentComponentResponse + ':' + `${this.parentComponentResponseNum}`) 
        Text(this.childComponentResponse + ':' + `${this.childComponentResponseNum}`) 
 
        Button('child').height(40).width(100).margin({top: 20}) 
          .onTouch((e) => { 
            this.childComponentResponseNum ++ 
            e.stopPropagation() 
          }) 
      } 
      .onTouch(() => { 
        this.parentComponentResponseNum ++ 
      }) 
    }.width('100%').padding(30) 
  } 
}
```


参考链接


触摸事件中的TouchEvent对象说明


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-245
爬取时间: 2025-05-08 05:15:47
来源: Huawei Developer


因为HarmonyOS支持0x+八位或六位的写法，因此在透明度设为00时，前两位透明度不再借位，即0x00333333=0x333333，相当于没有设置透明度，因此没有透明效果。建议使用rgba方式明确颜色。参考代码如下：


```less
@Entry 
@Component 
struct ColorGradientExample { 
  @State transparent: number | string = '#00333333'; 
  bool: boolean = true; 
 
  build() { 
    Column({ space: 5 }) { 
      Text('linearGradient') 
        .fontSize(12) 
        .width('90%') 
        .fontColor(0xCCCCCC) 
      Row() 
        .width('90%') 
        .height(150) 
        .linearGradient({ 
          direction: GradientDirection.Bottom, 
          colors: [[this.transparent, 0.0], [0x80000000, 1.0]] 
        }) 
      Button('切换颜色资源') 
        .onClick(() => { 
          if (this.bool) { 
            this.transparent = 0x00333333; 
            this.bool = false; 
          } else { 
            this.transparent = '#00333333'; 
            this.bool = true; 
          } 
        }) 
    } 
    .justifyContent(FlexAlign.Center) 
    .width('100%') 
    .height('100%') 
    .padding({ top: 5 }) 
  } 
}
```


效果如图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160840.20540021491496215395724782352466:50001231000000:2800:1D61B3296F6D30376E4C500C52D80157B2040C37AA0E6851692C913D74AF455E.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-246
爬取时间: 2025-05-08 05:15:57
来源: Huawei Developer


可以不设置宽度大小，通过文字长度来撑开宽度。参考代码如下：


```less
@Entry 
@Component 
struct Index { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Column() { 
      Row() { 
        Text(this.message) 
      } 
      .backgroundImage($r('app.media.startIcon')) 
      .backgroundImageSize({ 
        width: '100%', 
        height: '100%' 
      }) 
      .height(100) 
      .border({ 
        width: 3, 
        color: Color.Pink 
      }) 
 
      TextInput() 
        .onChange((value: string) => { 
          this.message = value; 
        }) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-247
爬取时间: 2025-05-08 05:16:07
来源: Huawei Developer


在List容器组件内可以将ListItemGroup和LazyForEach结合使用。参考代码如下：


```less
@Entry 
@Component 
struct LazyForEachDemo { 
  private list: MyDataSource2 = new MyDataSource2(); 
 
  @Builder 
  itemHead(text: string) { 
    Text(text) 
      .fontSize(20) 
      .backgroundColor(0xAABBCC) 
      .width('100%') 
      .padding(10) 
  } 
 
  @Builder 
  itemFoot(num: number) { 
    Text('共' + num + '节课') 
      .fontSize(16) 
      .backgroundColor(0xAABBCC) 
      .width('100%') 
      .padding(5) 
  } 
 
  aboutToAppear() { 
    for (let date = 1; date < ~~(Math.random() * 30) + 3; date++) { 
      let dayData = new dateListItem(date + ''); 
      for (let index = 1; index < ~~(Math.random() * 100) + 30; index++) { 
        dayData.orderList.pushData(`hello${index}`); 
      } 
      this.list.pushData(dayData); 
    } 
  } 
 
  build() { 
    Column() { 
      List({ space: 20 }) { 
        LazyForEach(this.list, (item: dateListItem) => { 
          ListItemGroup({ header: this.itemHead(item.date + ''), footer: this.itemFoot(item.orderList.totalCount()) }) { 
            LazyForEach(item.orderList, (order: string, ) => { 
              ListItem() { 
                Text(order) 
                  .width('100%') 
                  .height(60) 
                  .fontSize(20) 
                  .textAlign(TextAlign.Center) 
                  .backgroundColor(0xFFFFFF) 
              } 
            }, (item: string) => JSON.stringify(item)) 
          } 
          .divider({ strokeWidth: 1, color: Color.Blue }) 
        }) 
      } 
      .height('100%') 
      .cachedCount(1) 
      .width('90%') 
      .sticky(StickyStyle.Header | StickyStyle.Footer) 
      .scrollBar(BarState.Off) 
    } 
    .width('100%') 
    .height('100%') 
    .backgroundColor(0xDCDCDC) 
    .padding({ top: 5 }) 
  } 
} 
 
class BasicDataSource implements IDataSource { 
  private listeners: DataChangeListener[] = []; 
  private originDataArray: string[] = []; 
 
  public totalCount(): number { 
    return 0; 
  } 
 
  public getData(index: number): string | dateListItem { 
    return this.originDataArray[index]; 
  } 
 
  registerDataChangeListener(listener: DataChangeListener): void { 
    if (this.listeners.indexOf(listener) < 0) { 
      this.listeners.push(listener); 
    } 
  } 
 
  unregisterDataChangeListener(listener: DataChangeListener): void { 
    const pos = this.listeners.indexOf(listener); 
    if (pos >= 0) { 
      this.listeners.splice(pos, 1); 
    } 
  } 
 
  notifyDataReload(): void { 
    this.listeners.forEach(listener => { 
      listener.onDataReloaded(); 
    }) 
  } 
 
  notifyDataAdd(index: number): void { 
    this.listeners.forEach(listener => { 
      listener.onDataAdd(index); 
    }) 
  } 
 
  notifyDataChange(index: number): void { 
    this.listeners.forEach(listener => { 
      listener.onDataChange(index); 
    }) 
  } 
 
  notifyDataDelete(index: number): void { 
    this.listeners.forEach(listener => { 
      listener.onDataDelete(index); 
    }) 
  } 
} 
 
class MyDataSource1 extends BasicDataSource { 
  private dataArray: string[] = []; 
 
  public totalCount(): number { 
    return this.dataArray.length; 
  } 
 
  public getData(index: number): string { 
    return this.dataArray[index]; 
  } 
 
  public addData(index: number, data: string): void { 
    this.dataArray.splice(index, 0, data); 
    this.notifyDataAdd(index); 
  } 
 
  public pushData(data: string): void { 
    this.dataArray.push(data); 
    this.notifyDataAdd(this.dataArray.length - 1); 
  } 
} 
 
 
class MyDataSource2 extends BasicDataSource { 
  private dataArray: dateListItem[] = []; 
 
  public totalCount(): number { 
    return this.dataArray.length; 
  } 
 
  public getData(index: number): dateListItem { 
    return this.dataArray[index]; 
  } 
 
  public addData(index: number, data: dateListItem): void { 
    this.dataArray.splice(index, 0, data); 
    this.notifyDataAdd(index); 
  } 
 
  public pushData(data: dateListItem): void { 
    this.dataArray.push(data); 
    this.notifyDataAdd(this.dataArray.length - 1); 
  } 
} 
 
class dateListItem { 
  date: string; 
  orderList: MyDataSource1; 
 
  constructor(date: string) { 
    this.date = date; 
    this.orderList = new MyDataSource1(); 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-248
爬取时间: 2025-05-08 05:16:17
来源: Huawei Developer


目前px2fp, px2vp等方法在修改系统显示大小之后不会实时更新，字体默认单位是fp，界面像素单位是px，可以使用像素单位来设置字体大小，参考如下：


```less
@Entry
@Component
struct CustomDialogDisplayLevel {
  @State message: string = 'hello world';


  build() {
    Column() {
      Text(this.message)
        .fontSize(53) // 默认单位为fp，会跟随系统显示大小变化
      Text(this.message)
        .fontSize(px2fp(160) + 'px') // 使用像素单位，不会跟随系统显示大小变化
      Blank()
        .color(0xff0000)
        .height(30)
        .width(226)
        .margin({ bottom: 20 }) // 默认单位 vp会跟随系统显示大小变化
      Blank()
        .color(0xff0000)
        .height(30 + 'px')
        .width(px2vp(672) + 'px') // 使用像素单位，不会跟随系统显示大小变化
    }
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-249
爬取时间: 2025-05-08 05:16:26
来源: Huawei Developer


可以使用window的getWindowAvoidArea()方法获取内容规避区域，需设置type为AvoidAreaType.TYPE_NAVIGATION_INDICATOR。


```typescript
import { window } from '@kit.ArkUI'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
@Entry 
@Component 
struct GetBottomNavBarHeight { 
  build() { 
    Column() { 
      Button('获取底部手势横条的高度') 
        .onClick(() => { 
          let type = window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR; 
          window.getLastWindow(getContext(this)).then((data) => { 
            let avoidArea = data.getWindowAvoidArea(type); 
            // 获取到导航条区域的高度 
            let bottomRectHeight = avoidArea.bottomRect.height; 
            console.info(`window bottomRectHeight is: ${bottomRectHeight}`); 
          }).catch((err: BusinessError) => { 
            console.error(`Failed to obtain the window. Cause: ${JSON.stringify(err)}`); 
          }); 
        }) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-250
爬取时间: 2025-05-08 05:16:36
来源: Huawei Developer


实现列表既可以左右滑动，又可以上下滑动，参考代码如下：


1.代码页面布局部分


```less
import { CommonDataSource } from '../viewmodel/CommonDataSource';


@Observed
class ListItemData {
  text: string = '';
  id: string = '';
}


@Observed
class ListData {
  id: string = '';
  fundName: string = '';
  textDataSource: CommonDataSource<ListItemData> = new CommonDataSource<ListItemData>();
}


@Entry
@Component
struct ScrollListDemoPage {
  // 列表数据横向滚动的距离
  @State remainOffset: number = 0;
  // 维护一个list控制器数组，用于保存所有横向列表的 ListScroller
  @State listScrollerArr: ListScroller[] = [];
  // list的开始下标，用来刷新当前屏幕显示的列表区域
  @State startIndex: number = 0;
  // list的结束下标
  @State endIndex: number = 0;
  // 列表数据--展示的内容
  @State listData: ListItemData[] = [];
  // 头部标题列表，每一列的标题
  private titleList: string[] = [];
  // 列表数据源
  private dataSource = new CommonDataSource<ListData>();
  // 列表数据垂直滚动
  verticalScroller: Scroller = new Scroller();
  // 列表数据横向滚动
  horizontalScroller: Scroller = new Scroller();
  // 左侧名称列滚动
  leftScroller: Scroller = new Scroller();
  // 头部标题列滚动
  topScroller: Scroller = new Scroller();
  // 头部标题列表数据源
  headerList = new CommonDataSource<string>();
  // 实际处理的数据
  showList: ListData[] = [];


  aboutToAppear(): void {
    this.loadData();
  }


  loadData() {
    for (let i = 0; i < 30; i++) {
      this.titleList.push('标题' + i);
      let itemData: ListItemData = {
        text: '内容' + i,
        id: i + ''
      };
      this.listData.push(itemData);
    }
    this.headerList.setData(this.titleList);


    for (let i = 0; i < 20; i++) {
      // 每次获取下一页数据时，需要同步增加list的控制器
      this.listScrollerArr.push(new ListScroller());
      let listItemData: ListData = new ListData();
      listItemData.fundName = '股票基金' + i;
      listItemData.id = '股票基金' + i;
      listItemData.textDataSource = new CommonDataSource<ListItemData>();
      listItemData.textDataSource.setData(this.listData);
      this.showList.push(listItemData);
    }
    this.dataSource.setData(this.showList);
  }


  build() {
    Column() {
      // 头部标题
      this.titleBuilder()
      // 分割线
      Divider()
        .strokeWidth('100%')
        .color(0xeeeeee)


      Row() {
        // 左侧列
        this.leftBuilder()
        // 右侧列
        this.rightScroll()
      }
    }
    .height('100%')
    .alignItems(HorizontalAlign.Start)
  }


  @Builder
  titleBuilder() {
    Row() {
      Column() {
        Text('名称')
      }
      .width(140)
      .height(48)
      .backgroundColor(Color.White)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Start)
      .padding({ left: 16 })


      // 头部标题列表
      List({ scroller: this.topScroller }) {
        LazyForEach(this.headerList, (item: string) => {
          ListItem() {
            Text(item)
              .height(48)
              .width(120)
              .textAlign(TextAlign.Start)
              .padding({ left: 16 })
              .backgroundColor(0xFFFFFF)
          }
        }, (item: string) => item)
      }
      .listDirection(Axis.Horizontal)
      .edgeEffect(EdgeEffect.None)
      .scrollBar(BarState.Off)
      .width('calc(100% - 140vp)')
      .layoutWeight(1)
      .onScrollFrameBegin((offset: number) => {
        for (let i = this.startIndex; i <= this.endIndex; i++) {
          this.listScrollerArr[i].scrollTo({
            xOffset: this.topScroller.currentOffset().xOffset + offset,
            yOffset: 0,
            animation: false
          });
        }
        return { offsetRemain: offset };
      })
    }
    .height(48)
    .width('100%')
    .justifyContent(FlexAlign.Start)
  }


  @Builder
  leftBuilder() {
    List({ scroller: this.leftScroller }) {
      LazyForEach(this.dataSource, (item: ListData) => {
        ListItem() {
          Column() {
            Text(item.fundName)
              .height('100%')
              .backgroundColor(0xFFFFFF)
              .layoutWeight(1)
              .margin({ left: 16 })
            Divider()
              .strokeWidth('100%')
              .color(0xeeeeee)
          }
          .justifyContent(FlexAlign.Center)
          .alignItems(HorizontalAlign.Start)
        }
        .height(60)
      }, (item: ListData) => JSON.stringify(item))
    }
    .listDirection(Axis.Vertical)
    .scrollBar(BarState.Off)
    .edgeEffect(EdgeEffect.None)
    .height('calc(100% - 48vp)')
    .width(140)
    .onScrollFrameBegin((offset: number) => {
      this.verticalScroller.scrollTo({
        xOffset: 0,
        yOffset: this.leftScroller.currentOffset().yOffset + offset,
        animation: false
      });
      return { offsetRemain: offset };
    })
  }


  @Builder
  rightScroll() {
    Scroll(this.horizontalScroller) {
      List({ initialIndex: 0, scroller: this.verticalScroller }) {
        LazyForEach(this.dataSource, (item: ListData, index: number) => {
          ListItem() {
            Column() {
              List({ scroller: this.listScrollerArr[index] }) {
                LazyForEach(item.textDataSource, (item: ListItemData) => {
                  ListItem() {
                    Text(item.text)
                      .height('100%')
                      .width('100%')
                      .textAlign(TextAlign.Start)
                      .padding({ left: 16 })
                      .backgroundColor(0xFFFFFF)
                      .fontColor('#ffe72929')
                      .maxLines(1)
                      .textOverflow({ overflow: TextOverflow.Ellipsis })
                  }
                  .width(120)
                }, (item: ListItemData, index: number) => JSON.stringify(item) + index + '')
              }
              .cachedCount(4)
              .height('100%')
              .width('100%')
              .layoutWeight(1)
              .listDirection(Axis.Horizontal)
              .scrollBar(BarState.Off)
              .nestedScroll({
                scrollForward: NestedScrollMode.PARENT_FIRST,
                scrollBackward: NestedScrollMode.PARENT_FIRST
              })
              .edgeEffect(EdgeEffect.None)
              .onDidScroll(() => {
                this.remainOffset = this.listScrollerArr[index]!.currentOffset().xOffset;
              })
              .onScrollFrameBegin((offset: number) => {
                this.topScroller.scrollTo({
                  xOffset: this.listScrollerArr[index]!.currentOffset().xOffset + offset,
                  yOffset: 0,
                  animation: false
                });
                for (let i = this.startIndex; i <= this.endIndex; i++) {
                  if (i !== index) {
                    this.listScrollerArr[i].scrollTo({
                      xOffset: this.listScrollerArr[index]!.currentOffset().xOffset + offset,
                      yOffset: 0,
                      animation: false
                    });
                  }
                }
                return { offsetRemain: offset };
              })


              Divider()
                .strokeWidth('100%')
                .color(0xeeeeee)
            }
            .height(60)
          }
        }, (item: ListData) => JSON.stringify(item))
      }
      .height('100%')
      .cachedCount(2)
      .flingSpeedLimit(1600)
      .listDirection(Axis.Vertical)
      .scrollBar(BarState.Off)
      .edgeEffect(EdgeEffect.None)
      .nestedScroll({ scrollForward: NestedScrollMode.PARENT_FIRST, scrollBackward: NestedScrollMode.PARENT_FIRST })
      .onScrollFrameBegin((offset: number) => {
        this.leftScroller.scrollTo({
          xOffset: 0,
          yOffset: this.verticalScroller.currentOffset().yOffset + offset,
          animation: false
        });
        return { offsetRemain: offset };
      })
      .onScrollIndex((start: number, end: number) => {
        this.startIndex = start;
        this.endIndex = end;
        // 只滚动当前显示范围内的item
        for (let i = start; i <= end; i++) {
          this.listScrollerArr[i].scrollTo({ xOffset: this.remainOffset, yOffset: 0, animation: false });
        }
      })
    }
    .position({ x: 140, y: 0 })
    .onDidScroll(() => {
      this.topScroller.scrollTo({ xOffset: this.remainOffset, yOffset: 0, animation: false });
    })
    .scrollBar(BarState.Off)
    .edgeEffect(EdgeEffect.None)
    .scrollable(ScrollDirection.Horizontal)
    .backgroundColor(0xDCDCDC)
    .height('calc(100% - 48vp)')
    .width('calc(100% - 140vp)')
  }
}
```


2.加载的数据源


```less
export class CommonDataSource<T> implements IDataSource {
  private listeners: DataChangeListener[] = [];
  protected originDataArray: T[] = [];


  totalCount(): number {
    return this.originDataArray.length;
  }


  getAllData(): T[] {
    return this.originDataArray;
  }


  getData(index: number) {
    return this.originDataArray[index];
  }


  addData(index: number, data: T): void {
    this.originDataArray.splice(index, 0, data);
    this.notifyDataAdd(index);
  }


  pushData(data: T): void {
    this.originDataArray.push(data);
    this.notifyDataAdd(this.originDataArray.length - 1);
  }


  pushDataArray(...items: T[]): void {
    for (let data of items) {
      this.originDataArray.push(data);
      this.notifyDataAdd(this.originDataArray.length - 1);
    }
  }


  clear() {
    this.originDataArray.splice(0, this.originDataArray.length)
    this.listeners.forEach(listener => {
      listener.onDataDelete(0);
    })
  }


  setData(dataArray?: T[]) {
    if (dataArray) {
      this.originDataArray = dataArray;
    } else {
      this.originDataArray = [];
    }
    this.notifyDataReload();
  }


  registerDataChangeListener(listener: DataChangeListener): void {
    if (this.listeners.indexOf(listener) < 0) {
      this.listeners.push(listener);
    }
  }


  unregisterDataChangeListener(listener: DataChangeListener): void {
    const pos = this.listeners.indexOf(listener);
    if (pos >= 0) {
      this.listeners.splice(pos, 1);
    }
  }


  notifyDataReload() {
    this.listeners.forEach(listener => {
      listener.onDataReloaded();
    })
  }


  notifyDataAdd(index: number) {
    this.listeners.forEach(listener => {
      listener.onDataAdd(index);
    })
  }


  notifyDataMove(from: number, to: number) {
    this.listeners.forEach(listener => {
      listener.onDataMove(from, to);
    })
  }


  notifyDataDelete(index: number) {
    this.listeners.forEach(listener => {
      listener.onDataDelete(index);
    })
  }


  notifyDataChange(index: number) {
    this.listeners.forEach(listener => {
      listener.onDataChange(index);
    })
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-251
爬取时间: 2025-05-08 05:16:46
来源: Huawei Developer


可以利用Refresh组件实现下拉刷新效果。


```typescript
@Entry 
@Component 
struct SwiperItemLeak { 
  @State isStopSwiperSlide: boolean = false; 
  @State positionY: number = 0; 
  private swiperController: SwiperController = new SwiperController(); 
  @State curSwiperIndex: number = 0; 
  private list: number[] = []; 
 
  aboutToAppear(): void { 
    for (let i = 1; i <= 10; i++) { 
      this.list.push(i); 
    } 
  } 
 
  build() { 
    Refresh({ refreshing: $$this.isStopSwiperSlide}) { 
      Swiper(this.swiperController) { 
        ForEach(this.list, (item: number) => { 
          Text(item.toString()) 
            .width('100%') 
            .height('100%') 
            .backgroundColor(0xAFEEEE * ((item + 1) / 0x0f)) 
            .textAlign(TextAlign.Center) 
            .fontSize(30) 
        },(item: number) => JSON.stringify(item)) 
      } 
      .vertical(true) 
      .width('100%') 
      .height('100%') 
      .cachedCount(3) 
      .index(0) 
      .autoPlay(false) 
      .indicator(false) 
      .effectMode(EdgeEffect.None) 
      .loop(false) 
      .duration(100) 
      .disableSwipe(this.isStopSwiperSlide) 
      .displayCount(1) 
      .itemSpace(0) 
      .curve(Curve.Linear) 
      .backgroundColor(Color.Red) 
      .position({ y: this.positionY }) 
      .onChange((index: number) => { 
        this.curSwiperIndex = index; 
      }) 
    } 
    .onRefreshing(() => { 
      setTimeout(() => { 
        this.isStopSwiperSlide = false 
      }, 2000) 
    }) 
    .backgroundColor(0x89CFF0) 
    .refreshOffset(64) 
    .pullToRefresh(true) 
    .width('100%') 
    .height('100%') 
  } 
}
```


参考链接


Refresh


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-252
爬取时间: 2025-05-08 05:16:56
来源: Huawei Developer


getContext参数及类型：getContext(component?: Object):Context。


Context传入参数component的作用是指定一个组件对象，getContext函数会返回这个组件的上下文对象Context。如果不传入参数，则默认返回当前组件的上下文对象。上下文对象Context包含了组件的状态、属性、方法等信息，可以在组件内部使用。


在某些场景下，可能需要在组件内部调用其他组件的方法或获取其他组件的属性，此时可以通过getContext(this)获取到当前组件的上下文对象，然后使用该上下文对象调用其他组件的方法或获取其他组件的属性。


参考链接


getContext()


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-258
爬取时间: 2025-05-08 05:17:05
来源: Huawei Developer


可以使用@Reusable修饰自定义组件减少aboutToBeDeleted的调用。示例代码如下：


```typescript
class MyDataSource implements IDataSource {
  private dataArray: string[] = [];
  private listener: DataChangeListener | undefined;


  public totalCount(): number {
    return this.dataArray.length;
  }


  public getData(index: number): string {
    return this.dataArray[index];
  }


  public pushData(data: string): void {
    this.dataArray.push(data);
  }


  public reloadListener(): void {
    this.listener?.onDataReloaded();
  }


  public registerDataChangeListener(listener: DataChangeListener): void {
    this.listener = listener;
  }


  public unregisterDataChangeListener(listener: DataChangeListener): void {
    this.listener = undefined;
  }
}


@Entry
@Component
struct ReuseDemo {
  private data: MyDataSource = new MyDataSource();


  aboutToAppear() {
    for (let i = 1; i < 1000; i++) {
      this.data.pushData(i + "");
    }
  }


  // ...
  build() {
    Column() {
      List() {
        LazyForEach(this.data, (item: string) => {
          ListItem() {
            CardView({ item: item })
          }
        }, (item: string) => item)
      }
    }
  }
}


// 复用组件
@Reusable
@Component
export struct CardView {
  @State item: string = '';


  aboutToReuse(params: Record<string, Object>): void {
    this.item = params.item as string;
  }


  build() {
    Column() {
      Text(this.item)
        .fontSize(30)
    }
    .borderWidth(1)
    .height(100)
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-259
爬取时间: 2025-05-08 05:17:15
来源: Huawei Developer


px2vp是ArkUI的接口，初始化ArkUI之前，这个转化比例是1，windowStage.loadContent是初始化ArkUI，只有当初始化完成后，px2vp才会根据设备得到具体的值。在windowStage.loadContent完成后再调用px2vp即可。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-260
爬取时间: 2025-05-08 05:17:24
来源: Huawei Developer


navigation暂无最大页面数量限制。router栈超过32个无响应，不会再有新页面入栈。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-261
爬取时间: 2025-05-08 05:17:34
来源: Huawei Developer


router是无法传递map类型的数据的，params中只能包含基础类型的数据，推荐使用Navigation进行复杂数据类型的传参。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-262
爬取时间: 2025-05-08 05:17:44
来源: Huawei Developer


通过getParamByIndex获取index指定的NavDestination页面的参数信息，通过getParamByName获取全部名为name的NavDestination页面的参数信息。具体代码参考如下链接。


参考链接


NavPathStack


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-263
爬取时间: 2025-05-08 05:17:54
来源: Huawei Developer


参考代码如下：


```typescript
import { window } from '@kit.ArkUI'; 
@Entry 
@Component 
struct FullNavigationSubcomponent { 
  onPageShow(): void { 
    window.getLastWindow(getContext(this), (err, win) => { 
      win.setWindowLayoutFullScreen(true); 
    }) 
  } 
  build() { 
    Navigation() { 
      Column() { 
      } 
      .width('100%') 
      .height('100%') 
      .backgroundColor(Color.Black) 
    } 
    .width('100%') 
    .height('100%') 
    .title('个性化设置') 
    .titleMode(NavigationTitleMode.Mini) 
    .backgroundColor(Color.Grey) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-264
爬取时间: 2025-05-08 05:18:04
来源: Huawei Developer


pushDestinationByName绑定了上下文对象，调用时会验证上下文是否一致，pushPathByName则不会验证。


不同的window，运行的UIContext不一样，在一个window下使用时，除了返回值不一样，没有其它区别。


参考链接


Navigation


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-265
爬取时间: 2025-05-08 05:18:14
来源: Huawei Developer


可以通过输入法服务@ohos.inputMethod的stopInputSession方法来隐藏软键盘，示例代码如下：


```typescript
import { inputMethod } from '@kit.IMEKit'; 
 
@Entry 
@Component 
struct ClickBlankHideKeyboard { 
  build() { 
    Column({ space: 12 }) { 
      TextInput({ placeholder: '请输入账号' }) 
        .height(40) 
      TextInput({ placeholder: '请输入密码' }) 
        .height(40) 
      Button('登录').width('100%') 
        .onClick(() => { 
          // 退出文本编辑状态 
          inputMethod.getController().stopInputSession(); 
        }) 
    } 
  } 
}
```


参考链接：


@ohos.inputMethod (输入法框架)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-266
爬取时间: 2025-05-08 05:18:24
来源: Huawei Developer


可以使用window的getWindowAvoidArea方法获取，示例代码如下：


```typescript
import { window } from '@kit.ArkUI'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
@Entry 
@Component 
struct GetAvoidAreaHeight { 
  build() { 
    Column() { 
      Button('GetAvoidAreaHeight') 
        .onClick(() => { 
          let type1 = window.AvoidAreaType.TYPE_SYSTEM; 
          let type2 = window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR; 
          window.getLastWindow(getContext(this)).then((data) => { 
            // 获取系统默认区域，一般包括状态栏、导航栏 
            let avoidArea1 = data.getWindowAvoidArea(type1); 
            // 顶部状态栏高度 
            let statusBarHeight = avoidArea1.topRect.height; 
            // 底部导航栏高度 
            let bottomNavHeight = avoidArea1.bottomRect.height; 
            // 获取导航条区域 
            let avoidArea2 = data.getWindowAvoidArea(type2); 
            // 获取到导航条区域的高度 
            let indicatorHeight = avoidArea2.bottomRect.height; 
            console.info(`statusBarHeight is ${statusBarHeight}`); 
            console.info(`bottomNavHeight is ${bottomNavHeight}`); 
            console.info(`indicatorHeight is ${indicatorHeight}`); 
          }).catch((err: BusinessError) => { 
            console.error(`Failed to obtain the window. Cause: ${JSON.stringify(err)}`); 
          }); 
        }) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-267
爬取时间: 2025-05-08 05:18:33
来源: Huawei Developer


使用MeasureText接口实现文字段落展开收起的功能，具体实现如下所示：


```less
import { MeasureText } from '@kit.ArkUI'


// 文本行宽度
const TEXT_WIDTH: number = 350;
// 收起文本显示行数
const COLLAPSE_LINES: number = 2;
const ELLIPSIS: string = '...';
const EXPAND_STR: string = '展开';
const COLLAPSE_STR: string = '收起';
const FULL_TEXT: string =
  'HarmonyOS提供了一套UI开发框架，即方舟开发框架（ArkUI框架）。方舟开发框架可为开发者提供应用UI开发' +
    '所必需的能力，比如多种组件、布局计算、动画能力、UI交互、绘制等。\n' +
    '方舟开发框架针对不同目的和技术背景的开发者提供了两种开发范式，分别是基于ArkTS的声明式开发范式（简称“声明式开发范式”）' +
    '和兼容JS的类Web开发范式（简称“类Web开发范式”）。以下是两种开发范式的简单对比。'


@Entry
@Component
struct TextCollapseTest {
  @State title: string = FULL_TEXT;
  @State suffixStr: string = '';
  private expanded: Boolean = true;
  private needProcess: boolean = true
  aboutToAppear(): void {
    this.process();
  }


  process(): void {
    if (this.expanded) {
      this.collapseText();
    } else {
      this.expandText();
    }
  }


  //展开文本
  expandText(): void {
    if (this.needProcess) {
      this.suffixStr = COLLAPSE_STR;
      this.expanded = true;
      this.title = FULL_TEXT;
    }
  }


  //收起文本
  collapseText(): void {
    if (!this.needProcess) {
      return;
    }
    // 展开文本的size
    let expandSize: SizeOptions = MeasureText.measureTextSize({
      textContent: FULL_TEXT,
      constraintWidth: TEXT_WIDTH,
      fontSize: 30
    });


    // 将要收起的文本size
    let collapseSize: SizeOptions = MeasureText.measureTextSize({
      textContent: FULL_TEXT,
      constraintWidth: TEXT_WIDTH,
      fontSize: 30,
      maxLines: COLLAPSE_LINES
    });


    //收起的文本高度和展开时的文本高度相等时，不进行处理
    if ((expandSize.height as number) == (collapseSize.height as number)) {
      this.needProcess = false;
      return;
    }


    let clipTitle: string = FULL_TEXT
    this.suffixStr = EXPAND_STR;
    // 使用二分法查找正好两行的长度的字符串
    let leftCursor: number = 0;
    let rightCursor: number = this.title.length;
    let cursor: number = Math.floor(rightCursor / 2);
    let tempTitle: string = '';
    while (true) {
      tempTitle = this.title.substring(0, cursor) + ELLIPSIS + EXPAND_STR;
      const currentLinesTextSize: SizeOptions = MeasureText.measureTextSize({
        textContent: tempTitle,
        fontSize: 30,
        wordBreak: WordBreak.BREAK_ALL,
        constraintWidth: TEXT_WIDTH
      });


      if ((currentLinesTextSize.height as number) > (collapseSize.height as number)) {
        // 当前字符已超过两行，向左继续找
        rightCursor = cursor;
        cursor = leftCursor + Math.floor((cursor - leftCursor) / 2);
      } else {
        // 当前字符小于两行了，可能已经ok，但仍需向右查找
        leftCursor = cursor;
        cursor += Math.floor((rightCursor - cursor) / 2);
      }
      if (Math.abs(rightCursor - leftCursor) <= 1) {
        // 两次指针基本重合了，代表已找到
        break;
      }
    }
    clipTitle = this.title.substring(0, cursor - 1);
    this.title = clipTitle + ELLIPSIS;
    this.expanded = false;
  }


  build() {
    Row() {
      Column() {
        Text() {
          Span(this.title)
          if (this.needProcess) {
            Span(this.suffixStr)
              .fontColor(Color.Orange)
              .onClick(() => {
                this.process();
              })
          }
        }
        .fontSize(30)
        .fontWeight(FontWeight.Bold)
        .width(TEXT_WIDTH)
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-268
爬取时间: 2025-05-08 05:18:43
来源: Huawei Developer


需求描述：


List组件下拉加载头顶元素，希望加载完之后，还是定位在刷新前的元素上面。


实现方法：


可以给List添加scroller控制器，将列表跳回原先所在位置this.scroller.scrollToIndex，示例代码如下：


```typescript
@Entry 
@Component 
struct RefreshDemo { 
  @State isRefreshing: boolean = false; 
  @State arr: String[] = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10']; 
  private listScroller: Scroller = new Scroller(); 
 
  build() { 
    Column() { 
      Refresh({ refreshing: $$this.isRefreshing }) { 
        List({ scroller: this.listScroller, space: 10 }) { 
          ForEach(this.arr, (item: string) => { 
            ListItem() { 
              Text(item) 
                .width('100%') 
                .height(100) 
                .textAlign(TextAlign.Center) 
                .backgroundColor(Color.Grey) 
            } 
          }, (item: string) => item) 
        } 
        .onScrollIndex((first: number) => { 
          console.info(first.toString()); 
        }) 
        .width('100%') 
        .height('100%') 
      } 
      .onRefreshing(() => { 
        setTimeout(() => { 
          this.isRefreshing = false; 
        }, 2000) 
        this.arr.unshift('11'); 
        this.arr.unshift('12'); 
        this.listScroller.scrollToIndex(2); 
      }) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-269
爬取时间: 2025-05-08 05:18:53
来源: Huawei Developer


设置visibility后，组件会直接从页面中消失，所以无法获焦。可以通过给textInput设置opacity(0.01)以此来隐藏，但是又不影响焦点的获取。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-270
爬取时间: 2025-05-08 05:19:04
来源: Huawei Developer


可以使用NavPathStack的getParamByName方法获取页面路由的参数。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-271
爬取时间: 2025-05-08 05:19:14
来源: Huawei Developer


在应用开发中，我们通常需要使用相同功能和样式的ArkUI组件，例如购物页面中会使用相同样式的Button按钮、Text显示文字，我们常用的方法是抽取公共样式或者封装成一个自定义组件到公共组件库中以减少冗余代码。


当需要向外提供单一组件的样式定制效果时，推荐使用跨文件样式复用方案。具体实现可参考如下步骤：


1.提供方创建AttributeModifier接口的实现类。


```less
/* 
  自定义class实现Text的AttributeModifier接口 
*/ 
export class CommodityText implements AttributeModifier<TextAttribute> { 
  textType: TextType = TextType.TYPE_ONE; 
  textSize: number = 15; 
 
  constructor( textType: TextType, textSize: number) { 
    this.textType = textType; 
    this.textSize = textSize; 
  } 
 
  applyNormalAttribute(instance: TextAttribute): void { 
    if (this.textType === TextType.TYPE_ONE) { 
      instance.fontSize(this.textSize); 
      instance.fontColor(Color.Orange); 
      instance.fontWeight(FontWeight.Bolder); 
      instance.width(200); 
    } else if (this.textType === TextType.TYPE_TWO) { 
      instance.fontSize(this.textSize); 
      instance.fontWeight(FontWeight.Bold); 
      instance.fontColor(Color.Blue); 
      instance.width(200); 
    } else if (this.textType === TextType.TYPE_Three) { 
      instance.fontColor(Color.Gray); 
      instance.fontSize(this.textSize); 
      instance.fontWeight(FontWeight.Normal); 
      instance.width(200); 
    } else if (this.textType === TextType.TYPE_FOUR) { 
      instance.fontSize(this.textSize); 
      instance.fontColor(Color.Orange); 
      instance.textAlign(TextAlign.Center); 
      instance.border({ width: 1, color: Color.Orange, style: BorderStyle.Solid }); 
      instance.margin({ right: 10 }); 
    } 
  } 
} 
/* 
  枚举文本类型 
*/ 
export enum TextType { 
  TYPE_ONE, 
  TYPE_TWO, 
  TYPE_Three, 
  TYPE_FOUR 
}
```


2.使用方创建提供方的AttributeModifier实现类实例，并作为系统组件attributeModifier属性方法的参数传入。


```typescript
import { CommodityText, TextType } from './attributeModifier'; 
 
@Entry 
@Component 
export struct Details { 
  // 使用方创建提供方的AttributeModifier实现类实例 
  @State textOne: CommodityText = new CommodityText(TextType.TYPE_FOUR, 15); 
 
  build(){ 
    Row(){ 
      Text($r('app.string.app_name')) 
        .attributeModifier(this.textOne) 
        .textAlign(TextAlign.Center) 
    } 
    .width('100%') 
    .height('100%') 
    .alignItems(VerticalAlign.Center) 
    .justifyContent(FlexAlign.Center) 
  } 
}
```


参考链接


动态属性设置-attributeModifier


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-272
爬取时间: 2025-05-08 05:19:24
来源: Huawei Developer


在应用开发中，我们通常需要使用相同功能和样式的ArkUI组件，例如购物页面中会使用相同样式的Button按钮、Text显示文字，我们常用的方法是抽取公共样式或者封装成一个自定义组件到公共组件库中以减少冗余代码。


当需要适用于多个组件结合的场景，如Image+Text等复合自定义组件时，推荐使用跨文件组件复用方案。


具体实现可参考如下步骤：


1.提供方在公共组件库CommonText中创建公用的自定义组件ImageText，该组件支持外部传入attributeModifier属性。


```less
export class ImageModifier implements AttributeModifier<ImageAttribute> { 
  width: number = 60; 
  height: number = 60; 
 
  constructor(width: number, height: number) { 
    this.width = width; 
    this.height = height 
  } 
 
  applyNormalAttribute(instance: ImageAttribute): void { 
    instance.width(this.width); 
    instance.height(this.height); 
  } 
} 
 
/* 
  自定义class实现text的AttributeModifier接口，用于初始化 
*/ 
export class TextModifier implements AttributeModifier<TextAttribute> { 
  textSize: number = 12; 
 
  constructor(textSize: number) { 
    this.textSize = textSize; 
  } 
 
  applyNormalAttribute(instance: TextAttribute): void { 
    instance.fontSize(this.textSize); 
    instance.fontColor(Color.Orange); 
    instance.textAlign(TextAlign.Center); 
    instance.border({ width: 1, color: Color.Orange, style: BorderStyle.Solid }); 
    instance.margin({ right: 10 }); 
  } 
} 
 
/* 
  自定义class实现checkbox的AttributeModifier接口，用于初始化 
*/ 
export class CheckboxModifier implements AttributeModifier<CheckboxAttribute> { 
  size: number = 15; 
 
  constructor(size: number) { 
    this.size = size; 
  } 
 
  applyNormalAttribute(instance: CheckboxAttribute): void { 
    instance.width(this.size); 
    instance.height(this.size); 
  } 
} 
 
/** 
 * 自定义封装图文组件 
 */ 
@Component 
export struct ImageText { 
  @State textOneContent: string | Resource = 'default'; 
  @State imageSrc: PixelMap | ResourceStr | DrawableDescriptor = $r('app.media.icon'); 
  //接受外部传入的AttributeModifier类实例,可以只定制部分组件，选择性传入参数。 
  @State textOne: AttributeModifier<TextAttribute> = new TextModifier(12); 
  @State imageModifier: AttributeModifier<ImageAttribute> = new ImageModifier(60, 60); 
  @State checkboxModifier: AttributeModifier<CheckboxAttribute> = new CheckboxModifier(15); 
 
  build() { 
    Row() { 
      Checkbox() 
        .attributeModifier(this.checkboxModifier) 
 
      Image(this.imageSrc) 
        .attributeModifier(this.imageModifier) 
        .margin({ right: 10 }) 
 
      Text(this.textOneContent) 
        .attributeModifier(this.textOne) 
        .fontColor(Color.Orange) 
    } 
    .padding({ top: 5 }) 
    .margin({ right: 10, bottom: 15 }) 
    .width(200) 
    .height(100) 
  } 
}
```


2.使用方分别实现Image组件、Text组件和checkbox的AttributeModifier接口实现类，然后使用自定义组件ImageText和入参，即可实现跨文件组件复用。


```less
import { ImageText, ImageModifier, TextModifier, CheckboxModifier } from './CommonText'; 
 
@Entry 
@Component 
struct Details { 
  // 使用方创建提供方的AttributeModifier实现类实例 
  @State textOne: TextModifier = new TextModifier(36); 
  @State imageModifier: ImageModifier = new ImageModifier(100, 100); 
  @State checkboxModifier: CheckboxModifier = new CheckboxModifier(20); 
 
  build(){ 
    Row(){ 
      ImageText({ 
        textOne: this.textOne, 
        imageModifier: this.imageModifier, 
        imageSrc: $r('app.media.icon'), 
        checkboxModifier: this.checkboxModifier, 
        textOneContent: 'hello' 
      }) 
    } 
    .width('100%') 
    .height('100%') 
    .alignItems(VerticalAlign.Center) 
    .justifyContent(FlexAlign.Center) 
  } 
}
```


参考链接


动态属性设置-attributeModifier


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-273
爬取时间: 2025-05-08 05:19:33
来源: Huawei Developer


参考代码如下：


```typescript
import { promptAction, ShowDialogSuccessResponse } from '@kit.ArkUI'; 
 
@Entry 
@Component 
struct SideslipIntercept { 
  controller: TextAreaController = new TextAreaController(); 
  @State text: string = ''; 
  @Provide pageStackForComponentSharedPages: NavPathStack = new NavPathStack(); 
   
  build() { 
    // 应用主页用NavDestination承载，用于显示Navigation的内容区 
    Navigation(this.pageStackForComponentSharedPages) { 
    } 
    .onAppear(() => { 
      this.pageStackForComponentSharedPages.pushPathByName('MainPage', null, false); 
    }) 
    // 创建NavDestination组件，需使用此组件的onBackPressed回调拦截返回事件 
    .navDestination(this.textArea) 
  } 
 
  @Builder 
  textArea(name: string) { 
    NavDestination() { 
      Column() { 
        TextArea({ 
          text: this.text, 
          placeholder: 'input your word...', 
          controller: this.controller 
        }) 
          .onChange((value: string) => { 
            this.text = value; 
          }) 
      } 
      .justifyContent(FlexAlign.Start) 
      .width('100%') 
      .height('100%') 
    } 
    .onBackPressed(() => { 
      // 此处可添加拦截处理逻辑，然后return true放行 
      promptAction.showDialog({ 
        message: '是否保存', 
        alignment: DialogAlignment.Center, 
        buttons: [ 
          { 
            text: '不保存', 
            color: '#0000FF' 
          }, 
          { 
            text: '保存', 
            color: '#0000FF' 
          } 
        ] 
      }).then((data: ShowDialogSuccessResponse) => { 
        // 操作菜单的响应结果,选中按钮在buttons数组中的索引，从0开始,第二个索引为1 
        // 点击不保存按钮 
        if (data.index === 0) { 
          console.info('不保存') 
        } 
        // 点击保存按钮 
        if (data.index === 1) { 
          console.info('保存') 
        } 
      }) 
      return true ; 
    }) 
  } 
}
```


参考链接


侧滑返回事件拦截案例


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-274
爬取时间: 2025-05-08 05:19:43
来源: Huawei Developer


```typescript
onWindowStageCreate(windowStage: window.WindowStage): void {
  AppStorage.setOrCreate('context', windowStage);
  windowStage.getMainWindow((err: BusinessError, data) => {
    let errCode: number = err.code;
    // 设置窗口为全屏显示状态
    data.setWindowLayoutFullScreen(true);
    // 设置顶部状态栏为隐藏状态
    let names: Array<'status' | 'navigation'> = [];
    data.setWindowSystemBarEnable(names, (err: BusinessError) => {
      if (err.code) {
        console.error('Failed to set the system bar to be visible. Cause:' + JSON.stringify(err));
        return;
      }
      console.info('Succeeded in setting the system bar to be visible.');
    });
  })
  // ...
}
```

1.  代码如下：

```less
import { display, promptAction, window } from '@kit.ArkUI';
import { common } from '@kit.AbilityKit';
import { batteryInfo } from '@kit.BasicServicesKit';


class TextMargin {
  left: number = 0; // 状态栏左偏移量
  right: number = 0; // 状态栏右偏移量
}


@Entry
@Component
struct Index {
  @State date: Date = new Date();
  @State currentTime: string = ''; // 顶部状态栏时间
  @State boundingRect: display.Rect[] = []; // 不可用区域数据
  @State screenWidth: number = 0; // 屏幕宽度
  @State displayClass: display.Display | null = null;
  @State topTextMargin: TextMargin = { left: 0, right: 0 }; // 顶部状态栏偏移量
  @StorageLink('context') context: common.UIAbilityContext | undefined =
    AppStorage.get('context'); // 获取UIAbilityContext


  aboutToAppear(): void {
    this.displayClass = display.getDefaultDisplaySync();
    display.getDefaultDisplaySync().getCutoutInfo((err, data) => {
      if (err.code !== 0) {
        console.log('getCutoutInfo failed. error is:', JSON.stringify(err));
        return;
      }
      this.boundingRect = data.boundingRects;
      this.topTextMargin = this.getBoundingRectPosition();
    })
    // 获取小时
    let hours = this.date.getHours();
    // 获取分钟
    let minutes = this.date.getMinutes();
    // 分钟小于10在前面加0
    this.currentTime = hours.toString() + ':' + (minutes < 10 ? '0' + minutes : minutes.toString());
  }


  // 退出当前页面时将窗口重新设置成初始状态
  aboutToDisappear() {
    if (this.context !== undefined) {
      window.getLastWindow(this.context, async (err, data) => {
        if (err.code !== 0) {
          console.log('getLastWindow failed. error is:', JSON.stringify(err));
          data.setWindowSystemBarEnable(['status', 'navigation']);
          data.setWindowLayoutFullScreen(false);
        }
      })
    }
  }


  getBoundingRectPosition(): TextMargin {
    if (this.boundingRect !== null && this.displayClass !== null && this.boundingRect[0] !== undefined) {
      // 不可用区域右侧到屏幕右边界的距离：屏幕宽度减去左侧宽度和不可用区域宽度
      let boundingRectRight: number =
        this.displayClass.width - (this.boundingRect[0].left + this.boundingRect[0].width);
      // 不可用区域左侧到屏幕左边界的距离：getCutoutInfo接口可以直接获取
      let boundingRectLeft: number = this.boundingRect[0].left;
      // 部分设备不可用区域在中间时存在左右距离会有10像素以内的差距，获取到的左右距离差值绝对值小于10都按照不可用区域位于中间处理
      if (Math.abs(boundingRectLeft - boundingRectRight) <= 10) {
        return { left: 0, right: 0 };
      }
      if (boundingRectLeft > boundingRectRight) {
        // 不可用区域在右边
        return { left: 0, right: this.displayClass.width - boundingRectLeft };
      } else if (boundingRectLeft < boundingRectRight) {
        // 不可用区域在左边
        return { left: this.boundingRect[0].left + this.boundingRect[0].width, right: 0 };
      }
    }
    return { left: 0, right: 0 };
  }


  build() {
    Stack() {
      Image($r('app.media.digging_hole_screen_2048game'))
        .objectFit(ImageFit.Fill)
        .width('100%')
        .height('100%')
        .onClick(() => {
          promptAction.showToast({
            message: '该功能暂未开发',
            duration: 2000
          })
        })
      Column() {
        Flex({ direction: FlexDirection.Row, justifyContent: FlexAlign.SpaceBetween }) {
          Text(this.currentTime) // 时间
            .fontSize(16)
            .fontColor(Color.Black)
            .fontWeight(FontWeight.Regular)
            .padding({ left: 12 })
            .margin({
              left: px2vp(this.topTextMargin.left),
              top: 14
            }) // 获取的偏移量单位为px需要进行转换
          Text(batteryInfo.batterySOC.toString() + '%')// 电池电量
            .fontSize(16)
            .fontColor(Color.Black)
            .fontWeight(FontWeight.Regular)
            .padding({ right: 16 })
            .margin({
              right: px2vp(this.topTextMargin.right),
              top: 14
            }) // 获取的偏移量单位为px需要进行转换
        }
        .width('100%')
      }
      .width('100%')
    }
    .width('100%')
    .height('100%')
    .alignContent(Alignment.TopStart)
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-275
爬取时间: 2025-05-08 05:19:53
来源: Huawei Developer


可以通过grayscale()方法添加灰度效果，实现统一置灰功能。


grayscale()接收一个number类型的参数，定义灰度转换的比例。

- 参数为1.0：表示完全转为灰度图像。
- 参数为0.0：表示图像无变化。
- 参数在0.0和1.0之间时：表示效果呈线性变化。

示例如下：


```typescript
@Entry 
@Component 
struct Index { 
  @State grayscaleValue: number = 0; 
 
  build() { 
    Column({ space: 20 }) { 
      Flex() 
      Image($r("app.media.app_icon")) 
        .height(100) 
      Row({ space: 20 }) { 
        Button("置灰") 
          .onClick(() => { 
            this.grayscaleValue = 1; // 页面置灰 
          }) 
        Button("恢复") 
          .onClick(() => { 
            this.grayscaleValue = 0; // 页面恢复色彩 
          }) 
      } 
    } 
    .width("100%") 
    .height("100%") 
    .backgroundColor('#fcd473') 
    .padding(10) 
    .grayscale(this.grayscaleValue) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-276
爬取时间: 2025-05-08 05:20:03
来源: Huawei Developer


参考如下示例：


```typescript
@Entry 
@Component 
struct Index { 
  @State listArr: string[] = []; 
 
  @Builder 
  pixelMapBuilder(text: string) { 
    Column() { 
      Text(text) 
        .fontSize(16) 
        .backgroundColor(0xDCDCDC) 
        .width(80) 
        .height(80) 
        .textAlign(TextAlign.Center) 
    } 
  } 
 
  aboutToAppear() { 
    for (let i = 0; i < 16; i++) { 
      this.listArr.push(i + ''); 
    } 
  } 
 
  // 交换listArr数组中listItem的位置 
  changeListItemIndex(index1: number, index2: number) { 
    let tempItem = this.listArr[index1]; 
    this.listArr[index1] = this.listArr[index2]; 
    this.listArr[index2] = tempItem; 
  } 
 
  build() { 
    Column() { 
      List() { 
        ForEach(this.listArr, (item: string) => { 
          ListItem() { 
            Text(item) 
          } 
          .width(80) 
          .height(80) 
          .backgroundColor(Color.White) 
          .borderRadius(4) 
          .margin({ top: 10 }) 
        }, (item: string) => item) 
      } 
      .width('100%') 
      .height(500) 
      .lanes({ minLength: 80, maxLength: 80 }) 
      .alignListItem(ListItemAlign.Center) 
      .onItemDragStart((event: ItemDragInfo, index: number) => { 
        return this.pixelMapBuilder(this.listArr[index]); 
      }) 
      .onItemDrop((event: ItemDragInfo, itemIndex: number, insertIndex: number, isSuccess: boolean) => { 
        if (!isSuccess || insertIndex >= this.listArr.length) { 
          return; 
        } 
        this.changeListItemIndex(itemIndex, insertIndex); 
      }) 
    } 
    .width('100%') 
    .height('100%') 
    .backgroundColor(0xDCDCDC) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-277
爬取时间: 2025-05-08 05:20:13
来源: Huawei Developer


可以使用ListScroller提供的closeAllSwipeActions()方法将滑动效果进行恢复，示例代码如下：


```typescript
@Component 
export struct SwiperActionRecover { 
  @State arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; 
  private scrollerForList: ListScroller = new ListScroller(); 
 
  @Builder 
  itemEnd() { 
    Row() { 
      Button('Delete') 
      Button('Set') 
        .onClick(() => { 
          this.scrollerForList.closeAllSwipeActions(); // 重点是这行代码 
        }) 
    } 
    .justifyContent(FlexAlign.SpaceEvenly) 
  } 
 
  build() { 
    Column() { 
      List({ space: 5, scroller: this.scrollerForList }) { 
        ForEach(this.arr, (item: number) => { 
          ListItem() { 
            Text('item' + item) 
              .width('100%') 
              .height(100) 
              .textAlign(TextAlign.Center) 
              .borderRadius(10) 
              .backgroundColor(0xFFFFFF) 
          } 
          .transition({ 
            type: TransitionType.Delete, 
            opacity: 0 
          }) 
          .swipeAction({ 
            end: { 
              builder: () => { 
                this.itemEnd(); 
              }, 
              onAction: () => { 
                animateTo({ duration: 1000 }, () => { 
                  let index = this.arr.indexOf(item); 
                  this.arr.splice(index, 1); 
                }); 
              }, 
              actionAreaDistance: 56 
            } 
          }) 
        }, (item: string) => item) 
      } 
    } 
    .padding(20) 
    .backgroundColor(0xDCDCDC) 
    .width('100%') 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-278
爬取时间: 2025-05-08 05:20:22
来源: Huawei Developer


下拉刷新可以使用Refresh嵌套List来实现，刷新逻辑在onRefreshing回调方法里面执行；上拉加载更多的实现可以给List添加onReachEnd事件回调，当列表滑动到底部的时候触发。示例代码如下：


```less
build() { 
  Column() { 
    // 搜索框 置顶 
    this.searchBarBuilder() 
    // 下拉刷新组件 
    Refresh({ refreshing: $$this.isRefreshing }) { 
      // List组件作为长列表布局 
      List({ space: 10 }) { 
        // ListItem 自定义Swiper轮播图模块 
        ListItem() { 
          this.bannerBuilder() 
        } 
        // ListItem 自定义Grid快接入口模块 
        ListItem() { 
          this.quickBuilder() 
        } 
        // ListItem 自定义Column秒杀模块 
        ListItem() { 
          this.flashBuilder() 
        } 
        // ListItemGroup 商品分类列表 
        this.productsBuilder() 
        // 最后ListItem 自定义触底加载更多 
        ListItem() { 
          this.footerLoadingBuilder() 
        }.height(50).width('100%').backgroundColor(0xeeeeee) 
      } 
      .sticky(StickyStyle.Header) 
      .height('100%') 
      // List组件触底模拟网络请求 
      .onReachEnd(() => { 
        // 加载更多数据逻辑 
      }) 
    } 
    // 下拉刷新模拟网络请求 
    .onRefreshing(() => { 
      // 数据刷新逻辑 
    }) 
    .layoutWeight(1) 
    .width('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-279
爬取时间: 2025-05-08 05:20:32
来源: Huawei Developer


minimize方法提供该能力。若主窗口调用，可以将窗口最小化，并支持在Dock栏中还原。若子窗口调用，可以将窗口隐藏。


参考代码如下：


在EntryAbility.ets的onWindowStageCreate回调中全局保存windowStage：


```less
AppStorage.setOrCreate('context', windowStage);
```


在页面中获取windowStage并调用方法实现最小化：


```typescript
import { window } from '@kit.ArkUI'; 
 
@Component 
export struct BackgroundExecution { 
  @State message: string = '后台运行'; 
 
  build() { 
    Column() { 
      Button(this.message) 
        .width('40%') 
        .onClick(() => { 
          let windowStage = AppStorage.get('context') as window.WindowStage; 
          windowStage.getMainWindowSync().minimize(); 
        }) 
    } 
    .height('100%') 
    .width('100%') 
    .justifyContent(FlexAlign.Center) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-280
爬取时间: 2025-05-08 05:20:42
来源: Huawei Developer


可以给边缘tabContent添加PanGesture手势来实现，给最左侧的tabContent添加向右滑动的手势，给最右侧的tabContent添加向左滑动手势，示例代码如下：


```less
@Component 
export struct TabsNoRebound { 
  @State currentIndex: number = 0; 
  private fontColor: string = '#182431'; 
  private selectedFontColor: string = '#007DFF'; 
  private controller: TabsController = new TabsController(); 
  private panOptionR: PanGestureOptions = new PanGestureOptions({ direction: PanDirection.Right }); 
  private panOptionL: PanGestureOptions = new PanGestureOptions({ direction: PanDirection.Left }); 
 
  @Builder 
  tabBuilder(index: number, name: string) { 
    Column() { 
      Text(name) 
        .fontColor(this.currentIndex === index ? this.selectedFontColor : this.fontColor) 
        .fontSize(16) 
        .fontWeight(this.currentIndex === index ? 500 : 400) 
        .lineHeight(22) 
        .margin({ 
          top: 17, 
          bottom: 7 
        }) 
      Divider() 
        .strokeWidth(2) 
        .color('#007DFF') 
        .opacity(this.currentIndex === index ? 1 : 0) 
    } 
    .width('100%') 
  } 
 
  build() { 
    Column() { 
      Tabs({ barPosition: BarPosition.Start, controller: this.controller }) { 
        TabContent() { 
          Column() 
            .width('100%') 
            .height('100%') 
            .backgroundColor('#00CB87') 
        } 
        .tabBar(this.tabBuilder(0, 'green')) 
        .gesture( 
          // 向右拖动触发该手势事件 
          PanGesture(this.panOptionR) 
            .onActionStart((event?: GestureEvent) => { 
              console.info('Pan start'); 
            }) 
            .onActionUpdate((event?: GestureEvent) => { 
              console.info('Pan onActionUpdate'); 
            }) 
            .onActionEnd(() => { 
              console.info('Pan end'); 
            }) 
        ) 
 
        TabContent() { 
          Column() 
            .width('100%') 
            .height('100%') 
            .backgroundColor('#007DFF') 
        } 
        .tabBar(this.tabBuilder(1, 'blue')) 
 
        TabContent() { 
          Column() 
            .width('100%') 
            .height('100%') 
            .backgroundColor('#FFBF00') 
        } 
        .tabBar(this.tabBuilder(2, 'yellow')) 
 
        TabContent() { 
          Column() 
            .width('100%') 
            .height('100%') 
            .backgroundColor('#E67C92') 
        } 
        .tabBar(this.tabBuilder(3, 'pink')) 
        .gesture( 
          // 向左拖动触发该手势事件 
          PanGesture(this.panOptionL) 
            .onActionStart((event?: GestureEvent) => { 
              console.info('Pan start'); 
            }) 
            .onActionUpdate((event?: GestureEvent) => { 
              console.info('Pan onActionUpdate'); 
            }) 
            .onActionEnd(() => { 
              console.info('Pan end'); 
            }) 
        ) 
      } 
      .barMode(BarMode.Fixed) 
      .barWidth(360) 
      .barHeight(56) 
      .onChange((index: number) => { 
        this.currentIndex = index; 
      }) 
      .width(360) 
      .height(296) 
      .margin({ top: 52 }) 
      .backgroundColor('#F1F3F5') 
    } 
    .width('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-281
爬取时间: 2025-05-08 05:20:51
来源: Huawei Developer


可以通过@State声明一个状态变量，动态控制customKeyboard属性的值来实现自定义键盘和系统键盘如何切换，示例代码如下：


```typescript
@Component 
export struct CustomSystemKeyboardToggle { 
  controller: TextInputController = new TextInputController(); 
  @State inputValue: string = ''; 
  @State show: boolean = false; 
 
  // 自定义键盘组件 
  @Builder 
  CustomKeyboardBuilder() { 
    Column() { 
      Button('x') 
        .onClick(() => { 
          // 关闭自定义键盘 
          this.controller.stopEditing(); 
          this.show = !this.show; 
        }) 
      Grid() { 
        ForEach([1, 2, 3, 4, 5, 6, 7, 8, 9, '*', 0, '#'], (item: number | string) => { 
          GridItem() { 
            Button(item + '') 
              .width(110) 
              .onClick(() => { 
                this.inputValue += item; 
              }) 
          } 
        }) 
      } 
      .maxCount(3) 
      .columnsGap(10) 
      .rowsGap(10) 
      .padding(5) 
    } 
    .backgroundColor(Color.Gray) 
  } 
 
  build() { 
    Column() { 
      TextInput({ controller: this.controller, text: this.inputValue })// 绑定自定义键盘 
        .customKeyboard(this.show ? this.CustomKeyboardBuilder() : undefined) 
        .margin(10) 
        .height(48) 
      Button('切换') 
        .onClick(() => { 
          this.show = !this.show; 
        }) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-282
爬取时间: 2025-05-08 05:21:00
来源: Huawei Developer


当用户执行点击遮障层关闭、左滑/右滑、三键back、键盘ESC关闭交互操作时，如果注册该回调函数，则不会立刻关闭弹窗。


在回调函数中可以通过reason得到阻拦关闭弹窗的操作类型，从而根据原因选择是否能关闭弹窗。


示例代码如下：


```typescript
@CustomDialog 
struct CustomDialogExample { 
  cancel?: () => void; 
  confirm?: () => void; 
  controller: CustomDialogController; 
 
  build() { 
    Column() { 
      Text('Are you sure?') 
        .fontSize(20) 
        .margin({ 
          top: 10, 
          bottom: 10 
        }) 
      Row() { 
        Button('cancel') 
          .onClick(() => { 
            this.controller.close(); 
            if (this.cancel) { 
              this.cancel(); 
            } 
          }) 
          .backgroundColor(0xffffff) 
          .fontColor(Color.Black) 
        Button('confirm') 
          .onClick(() => { 
            this.controller.close(); 
            if (this.confirm) { 
              this.confirm(); 
            } 
          }) 
          .backgroundColor(0xffffff) 
          .fontColor(Color.Red) 
      } 
      .width('100%') 
      .justifyContent(FlexAlign.SpaceAround) 
      .margin({ bottom: 10 }) 
    } 
  } 
} 
 
@Component 
export struct InterceptCustomDialog { 
  dialogController: CustomDialogController = new CustomDialogController({ 
    builder: CustomDialogExample({ 
      cancel: () => { 
        this.onCancel(); 
      }, 
      confirm: () => { 
        this.onAccept(); 
      } 
    }), 
    onWillDismiss: (dismissDialogAction: DismissDialogAction) => { 
      console.log('dialog onWillDismiss reason: ' + dismissDialogAction.reason); 
      // 1、PRESS_BACK    点击三键back、左滑/右滑、键盘ESC。 
      // 2、TOUCH_OUTSIDE    点击遮障层时 
      // 3、CLOSE_BUTTON    点击关闭按钮 
      if (dismissDialogAction.reason === DismissReason.PRESS_BACK) { 
        // 处理业务逻辑后通过dismiss主动关闭对话框 
        // dismissDialogAction.dismiss(); 
      } 
      if (dismissDialogAction.reason === DismissReason.TOUCH_OUTSIDE) { 
        // dismissDialogAction.dismiss(); 
      } 
    }, 
    alignment: DialogAlignment.Bottom, 
    offset: { dx: 0, dy: -20 } 
  }) 
 
  onCancel() { 
    console.info('Callback when the first button is clicked'); 
  } 
 
  onAccept() { 
    console.info('Callback when the second button is clicked'); 
  } 
 
  build() { 
    Column() { 
      Button('click me') 
        .onClick(() => { 
          this.dialogController.open(); 
        }) 
    } 
    .width('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-284
爬取时间: 2025-05-08 05:21:10
来源: Huawei Developer


struct只在自定义组件中使用，@Component装饰的struct就是自定义组件，自定义组件和class是两个概念，自定义组件没有类型，也不能等同于class。如果开发者需要使用组件作为参数在组件之间传递，可以使用自定义占位节点。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-285
爬取时间: 2025-05-08 05:21:20
来源: Huawei Developer


推荐使用的是Navigation跳转方式，可以将NavDestination设置mode为NavDestinationMode.DIALOG弹窗类型，此时整个NavDestination页面默认透明显示，具体可以参考：页面显示类型中的弹窗类型。示例代码如下：


```typescript
@Component 
export struct TransparentPage { 
  @Provide('NavPathStack') pageStack: NavPathStack = new NavPathStack(); 
 
  @Builder 
  PagesMap(name: string) { 
    if (name === 'DialogPage') { 
      DialogPage() 
    } 
  } 
 
  build() { 
    Navigation(this.pageStack) { 
      Button('Push DialogPage') 
        .margin(20) 
        .width('80%') 
        .onClick(() => { 
          this.pageStack.pushPathByName('DialogPage', ''); 
        }) 
    } 
    .mode(NavigationMode.Stack) 
    .title('Main') 
    .navDestination(this.PagesMap) 
  } 
} 
 
@Component 
export struct DialogPage { 
  @Consume('NavPathStack') pageStack: NavPathStack; 
 
  build() { 
    NavDestination() { 
      Stack({ alignContent: Alignment.Center }) { 
        Column() { 
          Text("Dialog NavDestination") 
            .fontSize(20) 
            .margin({ bottom: 100 }) 
          Button("Close") 
            .onClick(() => { 
            this.pageStack.pop(); 
          }) 
            .width('30%') 
        } 
        .justifyContent(FlexAlign.Center) 
        .borderRadius(10) 
        .height('30%') 
        .width('80%') 
      } 
      .height("100%") 
      .width('100%') 
    } 
    // 设置背景颜色 
    //.backgroundColor(Color.Red) 
    .hideTitleBar(true) 
    .mode(NavDestinationMode.DIALOG) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-292
爬取时间: 2025-05-08 05:21:30
来源: Huawei Developer


重新定义数据源数据类型，通过配合HashMap实现二维数组的懒加载数据源，然后通过ListGroup对数据进行分组。示例代码如下：


```less
import { HashMap } from '@kit.ArkTS'; 
 
class BasicDataSource implements IDataSource { 
  private listeners: DataChangeListener[] = []; 
  private originDataArray: Array<TimeTable> | Array<string> = []; 
 
  public totalCount(): number { 
    return 0; 
  } 
 
  public getData(index: number): TimeTable | string { 
    return this.originDataArray[index]; 
  } 
 
  registerDataChangeListener(listener: DataChangeListener): void { 
    if (this.listeners.indexOf(listener) < 0) { 
      console.info('add listener'); 
      this.listeners.push(listener); 
    } 
  } 
 
  unregisterDataChangeListener(listener: DataChangeListener): void { 
    const pos = this.listeners.indexOf(listener); 
    if (pos >= 0) { 
      console.info('remove listener'); 
      this.listeners.splice(pos, 1); 
    } 
  } 
 
  notifyDataReload(): void { 
    this.listeners.forEach(listener => { 
      listener.onDataReloaded(); 
    }) 
  } 
 
  notifyDataAdd(index: number): void { 
    this.listeners.forEach(listener => { 
      listener.onDataAdd(index); 
    }) 
  } 
 
  notifyDataChange(index: number): void { 
    this.listeners.forEach(listener => { 
      listener.onDataChange(index); 
    }) 
  } 
 
  notifyDataDelete(index: number): void { 
    this.listeners.forEach(listener => { 
      listener.onDataDelete(index); 
    }) 
  } 
 
  notifyDataMove(from: number, to: number): void { 
    this.listeners.forEach(listener => { 
      listener.onDataMove(from, to); 
    }) 
  } 
} 
 
class MyDataSource extends BasicDataSource { 
  private dataArray: TimeTable[] | Array<string> = []; 
 
  constructor(data: Array<TimeTable> | Array<string>) { 
    super(); 
    this.dataArray = data; 
  } 
 
  public totalCount(): number { 
    return this.dataArray.length; 
  } 
 
  public getData(index: number): TimeTable | string { 
    return this.dataArray[index]; 
  } 
 
  public addDataTimeTable(index: number, data: TimeTable): void { 
    this.dataArray.splice(index, 0, data); 
    this.notifyDataAdd(index); 
  } 
 
  public addDataString(index: number, data: string): void { 
    this.dataArray.splice(index, 0, data); 
    this.notifyDataAdd(index); 
  } 
 
  public pushDataTimeTable(data: TimeTable): void { 
    (this.dataArray as Array<TimeTable>).push(data); 
    this.notifyDataAdd(this.dataArray.length - 1); 
  } 
 
  public pushDataString(data: string): void { 
    (this.dataArray as Array<string>).push(data); 
    this.notifyDataAdd(this.dataArray.length - 1); 
  } 
} 
 
interface TimeTable { 
  title: string; 
  projects: string[]; 
} 
 
@Component 
export struct TwoNestingArrayLazy { 
  @State timeTable: TimeTable[] = [ 
    { 
      title: '星期一', 
      projects: ['语文', '数学', '英语'] 
    }, 
    { 
      title: '星期二', 
      projects: ['物理', '化学', '生物'] 
    }, 
    { 
      title: '星期三', 
      projects: ['历史', '地理', '政治'] 
    }, 
    { 
      title: '星期四', 
      projects: ['美术', '音乐', '体育'] 
    } 
  ]; 
  private data1: MyDataSource = new MyDataSource(this.timeTable); 
  private hashMap: HashMap<string, MyDataSource> = new HashMap(); 
 
  aboutToAppear(): void { 
    for (let index = 0; index < this.timeTable.length; index++) { 
      this.hashMap.set(this.timeTable[index].title, new MyDataSource(this.timeTable[index].projects)); 
    } 
  } 
 
  @Builder 
  itemHead(text: string) { 
    Text(text) 
      .fontSize(20) 
      .backgroundColor(0xAABBCC) 
      .width('100%') 
      .padding(10) 
  } 
 
  @Builder 
  itemFoot(num: number) { 
    Text('共' + num + '节课') 
      .fontSize(16) 
      .backgroundColor(0xAABBCC) 
      .width("100%") 
      .padding(5) 
  } 
 
  build() { 
    List({ space: 3 }) { 
      LazyForEach(this.data1, (item: TimeTable) => { 
        ListItemGroup({ header: this.itemHead(item.title), footer: this.itemFoot(item.projects.length) }) { 
          LazyForEach(this.hashMap.get(item.title), (project: string) => { 
            ListItem() { 
              Text(project) 
                .width('100%') 
                .height(100) 
                .fontSize(20) 
                .textAlign(TextAlign.Center) 
                .backgroundColor(0xFFFFFF) 
            } 
          }, (item: string) => item) 
        } 
        .divider({ strokeWidth: 1, color: Color.Blue }) // 每行之间的分界线 
      }, (item: string) => item) 
    } 
    .width('100%') 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-293
爬取时间: 2025-05-08 05:21:40
来源: Huawei Developer


可以通过使用NavDestination的Dialog模式实现，设置NavDestination的mode属性为NavDestinationMode.DIALOG，具体实现可以参考页面显示类型，示例代码如下：


```typescript
@Component
struct DialogCpt {
  @Consume('pageStack') pageStack: NavPathStack;


  build() {
    NavDestination() {
      Column(){
        Column() {
          Button('Next page').onClick(() => {
            this.pageStack.pushPathByName('NextPage', '');
          })
          Blank()
          Row() {
            Button('Cancel')
              .onClick(() => {
                this.pageStack.pop();
              })
            Button('Confirm')
              .onClick(() => {
                this.pageStack.pop();
              })
          }
          .width('100%')
          .justifyContent(FlexAlign.SpaceEvenly)
        }
        .padding(16)


        .height(300)
        .width(300)
        .backgroundColor(Color.White)
        .borderRadius(16)
      }
      .justifyContent(FlexAlign.Center)
      .height('100%')
      .width('100%')
    }
    .mode(NavDestinationMode.DIALOG)
    .hideTitleBar(true)
    .backgroundColor('#40000000')
  }
}


@Component
struct NextPage {
  @Consume('pageStack') pageStack: NavPathStack;


  build() {
    NavDestination() {
      Column() {
        Button('Back')
          .onClick(() => {
            this.pageStack.pop();
          })
      }
    }
  }
}


@Entry
struct Index {
  @Provide('pageStack') pageStack: NavPathStack = new NavPathStack()


  @Builder
  PageMap(name: string) {
    if (name === 'DialogCpt') {
      DialogCpt()
    } else if (name === 'NextPage') {
      NextPage()
    }
  }


  build() {
    Navigation(this.pageStack) {
      Column() {
        Button('Open dialog')
          .onClick(() => {
            this.pageStack.pushPathByName('DialogCpt', '');
          })
      }
    }
    .navDestination(this.PageMap)
    .backgroundColor('#F1F3F5')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-294
爬取时间: 2025-05-08 05:21:50
来源: Huawei Developer


可以通过stack布局，将image组件放在qrcode组件上实现，Image的叠加不会影响QRCode的识别，示例代码如下：


```less
@Entry 
@Component
struct QRCodeWithImage {
  private value: string = 'hello world';


  build() {
    Stack() {
      QRCode(this.value)
        .width(200)
        .height(200)
      Image($r('app.media.app_icon'))
        .height(50)
        .width(50)
    }
    .height('100%')
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-295
爬取时间: 2025-05-08 05:22:00
来源: Huawei Developer


Scroll嵌套List的时候，如果List默认不设置高度是会默认全部展开的，可以实现Scroll滚动整个布局的效果，但是要注意这样会失去懒加载效果，推荐使用List组件的nestedScroll属性来实现嵌套滚动效果


示例代码如下：


```less
@Component 
export struct ScrollNestingList { 
  build() { 
    Scroll() { 
      Column() { 
        Text('这是标题') 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
        List() { 
          ForEach(['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'], (item: string) => { 
            ListItem() { 
              Text(item) 
                .fontSize(50) 
                .height(150) 
            } 
          }, (item: string) => item) 
        } 
        .nestedScroll({ 
          scrollForward: NestedScrollMode.PARENT_FIRST, 
          scrollBackward: NestedScrollMode.SELF_FIRST 
        }) 
        .divider({ 
          strokeWidth: 1, 
          color: Color.Gray 
        }) 
        .edgeEffect(EdgeEffect.None) 
        .height('100%') 
        .width('100%') 
      } 
    } 
    .width('100%') 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-296
爬取时间: 2025-05-08 05:22:10
来源: Huawei Developer


可以使用FocusController的clearFocus方法来清除焦点并关闭软键盘，示例代码如下：


```less
 this.getUIContext().getFocusController().clearFocus()
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-297
爬取时间: 2025-05-08 05:22:20
来源: Huawei Developer


有2种截图方式，UI组件截图和窗口截图


UI组件截图参考：@ohos.arkui.componentSnapshot (组件截图)


窗口截图参考：获取窗口截图


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-298
爬取时间: 2025-05-08 05:22:30
来源: Huawei Developer


方式一：在onWindowStageCreate方法中获取


```less
import { UIAbility } from '@kit.AbilityKit'; 
import { hilog } from '@kit.PerformanceAnalysisKit'; 
import { window } from '@kit.ArkUI'; 
 
export default class EntryAbility extends UIAbility { 
  // ... 
  onWindowStageCreate(windowStage: window.WindowStage): void { 
    // Main window is created, set main page for this ability 
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate'); 
 
    windowStage.loadContent('pages/Index', (err) => { 
      if (err.code) { 
        hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? ''); 
        return; 
      } 
      hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.'); 
    }); 
    console.info('windowStage+++', JSON.stringify(windowStage)) 
    AppStorage.setAndLink('windowStage', windowStage) 
  } 
 
  // ... 
}
```


方式二：UIAbilityContext当前提供了相关接口来获取WindowStage实例


```typescript
// Index.ets 
import common from '@ohos.app.ability.common'; 
 
@Entry 
@Component 
struct Index { 
  @State showAbility: string = 'get windowStage' 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.showAbility) 
          .fontSize(30) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            let context = getContext(this) as common.UIAbilityContext; 
            console.info('获取到的WindowStage实例：',JSON.stringify(context.windowStage)) 
          }); 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


onWindowStageCreate


UIAbilityContext


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-299
爬取时间: 2025-05-08 05:22:39
来源: Huawei Developer


当前HarmonyOS支持两套路由机制（Navigation和Router），Navigation作为后续长期演进及推荐的路由选择方案，其与Router比较的优势如下：

- 易用性层面：
- 功能层面：
- 性能层面

Navigation & Router结构对比

- Navigation中的每个页面，承载在一个page里，通过NavDestination容器实现基于组件的页面跳转。
- Router的每一个页面配置在一个单独的page中，通过@Entry进行标识。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160841.48507563255560505055573483532771:50001231000000:2800:31687DC7AD3DD174E48CE1DD8EB5ABE6312017C5234990DC71629D12D1249906.jpg)

Navigation & Router能力对比


| 业务场景  | Navigation能力  | Router能力  |
| --- | --- | --- |
| 跳转指定页面  | pushPath & pushDestination  | pushUrl & pushNameRouter  |
| 跳转HSP中页面  | 支持，需要先import页面  | 支持  |
| 跳转HAR中页面  | 支持，需要先import页面  | 支持  |
| 跳转传参  | 支持  | 支持  |
| 获取指定页面参数  | 支持  | 不支持  |
| 跳转结果回调  | 支持  | 支持  |
| 跳转单例页面  | 可通过判断栈内有没有此页面，调用moveToTop实现  | 支持  |
| 页面返回  | pop  | back  |
| 页面返回传参  | 支持  | 支持  |
| 返回指定路由  | popToName&popToIndex  | 不支持  |
| 页面返回弹窗  | 通过路由拦截实现  | showAlertBeforeBackPage  |
| 路由替换  | replacePath & replacePathByName  | replaceUrl & replaceNameRouter  |
| 路由栈清理  | clear  | clear  |
| 清理指定路由  | removeByIndexes & removeByName  | 不支持  |
| 转场动画  | 支持  | 支持  |
| 自定义转场动画  | 支持  | 支持  |
| 屏蔽转场动画  | pushDestination(info: NavPathInfo, animated?: boolean) & pathStack.disableAnimation（true）  | 支持 duration属性设置为0  |
| 共享元素动画  | 支持  | 不支持  |
| 页面生命周期监听  | UIObserver.on('navDestinationUpdate')  | UIObserver.on('routerPageUpdate')  |
| 获取页面栈对象  | 支持  | 不支持  |
| 路由拦截  | setInterception  | 不支持  |
| 路由栈信息查询  | getAllPathName & getParamByIndex & getParamByName&size  | getState() & getLength()  |
| 路由栈操作  | moveToTop & moveIndexToTop  | 不支持  |
| 沉浸式页面  | 支持  | 不支持，需通过window配置  |
| 设置页面属性（背景，模糊等）  | 支持，backgroundBlurStyle  | 不支持  |
| 设置页面标题栏（title）和工具栏（toolbar）  | 支持  | 不支持  |
| 模态嵌套路由  | 支持  | 不支持  |

业务场景


Navigation能力


Router能力


跳转指定页面


pushPath & pushDestination


pushUrl & pushNameRouter


跳转HSP中页面


支持，需要先import页面


支持


跳转HAR中页面


支持，需要先import页面


支持


跳转传参


支持


支持


获取指定页面参数


支持


不支持


跳转结果回调


支持


支持


跳转单例页面


可通过判断栈内有没有此页面，调用moveToTop实现


支持


页面返回


pop


back


页面返回传参


支持


支持


返回指定路由


popToName&popToIndex


不支持


页面返回弹窗


通过路由拦截实现


showAlertBeforeBackPage


路由替换


replacePath & replacePathByName


replaceUrl & replaceNameRouter


路由栈清理


clear


clear


清理指定路由


removeByIndexes & removeByName


不支持


转场动画


支持


支持


自定义转场动画


支持


支持


屏蔽转场动画


pushDestination(info: NavPathInfo, animated?: boolean) & pathStack.disableAnimation（true）


支持 duration属性设置为0


共享元素动画


支持


不支持


页面生命周期监听


UIObserver.on('navDestinationUpdate')


UIObserver.on('routerPageUpdate')


获取页面栈对象


支持


不支持


路由拦截


setInterception


不支持


路由栈信息查询


getAllPathName & getParamByIndex & getParamByName&size


getState() & getLength()


路由栈操作


moveToTop & moveIndexToTop


不支持


沉浸式页面


支持


不支持，需通过window配置


设置页面属性（背景，模糊等）


支持，backgroundBlurStyle


不支持


设置页面标题栏（title）和工具栏（toolbar）


支持


不支持


模态嵌套路由


支持


不支持


使用选择


如果项目只有一个主项目，没有拆分模块，直接用Navigation即可。


如果项目包含模块，比如项目有主项目，A、B模块，主项目的H界面要跳转到A模块的I界面，或者A模块的I界面要跳转到B模块的J界面，这个时候就要用router。但是主项目里的M界面跳转主项目里的N界面，或者A模块的O界面跳转A模块的P界面，这种属于同模块内的不同界面，可以用Navigation。


参考链接


组件导航 (Navigation)、页面路由 (@ohos.router)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-302
爬取时间: 2025-05-08 05:22:49
来源: Huawei Developer


可以通过@kit.ArkUI.inspector(布局回调)接口获取绘制完成回调的通知。在aboutToAppear中记录开始的时间，在listener中监听绘制完成的回调中获取绘制完成的时间。得到的时间差就是组件渲染时间。示例代码如下：


```typescript
import { inspector } from '@kit.ArkUI';


@Entry
@Component
struct GetComponentRenderTime {
  @State startTime: number = 0;
  private listener: inspector.ComponentObserver = inspector.createComponentObserver('IMAGE_ID');
  private onDrawComplete = () => {
    // 2.图片组件绘制完成的时间
    console.info('onDrawComplete', new Date().getTime());
  };


  aboutToAppear() {
    // 1.渲染开始的时间
    this.startTime = new Date().getTime();
    console.info('aboutToAppear', this.startTime);


    // layout: 组件布局完成
    // draw: 组件绘制完成
    this.listener.on('draw', this.onDrawComplete);
  }


  aboutToDisappear() {
    // 销毁之前取消注册回调
    this.listener.off('draw', this.onDrawComplete);
  }


  build() {
    Column() {
      Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Start }) {
        Row({ space: 5 }) {
          Image($r('app.media.app_icon'))
            .width(110)
            .height(110)
            .id('IMAGE_ID')
        }
      }
    }
    .height(320)
    .width(360)
    .padding({
      right: 10,
      top: 10
    })
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-303
爬取时间: 2025-05-08 05:22:59
来源: Huawei Developer


需要控制Toggle组件传入的默认值，自定义一个toggleIsOn的状态变量，然后在onChange回调里面控制改变其的值，示例代码如下：


```less
import { hilog } from '@kit.PerformanceAnalysisKit';


@Entry
@Component
struct ToggleDrag {
  @State offsetX: number = 0;
  @State offsetY: number = 0;
  @State positionX: number = 0;
  @State positionY: number = 0;
  @State toggleIsOn: boolean = true;
  private isDragging: boolean = false;


  build() {
    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center }) {
      Toggle({ type: ToggleType.Button, isOn: this.toggleIsOn }) {
        Text('Toggle')
      }
      .selectedColor(Color.Pink)
      // onchange回调先于onActionEnd
      .onChange((isOn: boolean) => {
        hilog.info(0x0000, 'testTag', 'xxx %{public}s', `onClick Toggle, isOn: ${isOn}`);
        console.info('isDragging======' + this.isDragging);
        if (isOn === this.toggleIsOn) {
          return;
        } else {
          this.toggleIsOn = isOn;
        }
        if (this.isDragging) {
          this.toggleIsOn = !this.toggleIsOn;
        }
      })
      .translate({ x: this.offsetX, y: this.offsetY })
      .gesture(
        PanGesture()
          .onActionStart(() => {
            this.isDragging = true;
          })
          .onActionUpdate((event: GestureEvent) => {
            this.offsetX = this.positionX + event.offsetX;
            this.offsetY = this.positionY + event.offsetY;
          })
          .onActionEnd(() => {
            this.positionX = this.offsetX;
            this.positionY = this.offsetY;
            this.isDragging = false;
          })
      )
    }
  }
}
```


效果图如下：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160841.82948516571489647473315347325025:50001231000000:2800:B3912B829C20416163680585A485DAEA2F5254DBD4F3F01739489184A8D1286F.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-305
爬取时间: 2025-05-08 05:23:09
来源: Huawei Developer


统一使用组件导航(Navigation)的形式去操作，组件导航里面参考页面显示类型的弹窗类型(NavDestinationMode.DIALOG)。


参考链接


页面显示类型


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-306
爬取时间: 2025-05-08 05:23:18
来源: Huawei Developer


使用组合手势GestureGroup的互斥识别模式。双击事件需放在单击事件前面，互斥识别是按排列顺序来识别，如果单击事件放前面则只会识别到单击事件。参考代码如下：


```less
@Entry
@Component
struct TapGestureExample {
  build() {
    Column() {
      Text('Click twice')
        .fontSize(28)
        .gesture(GestureGroup(GestureMode.Exclusive,
          TapGesture({ count: 2 })
            .onAction(() => {
              console.info('TapGesture 2');
            }),
          TapGesture({ count: 1 })
            .onAction(() => {
              console.info('TapGesture 1');
            })
        )
      )
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
    .alignSelf(ItemAlign.Center)
  }
}
```


参考链接


互斥识别


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-307
爬取时间: 2025-05-08 05:23:28
来源: Huawei Developer


通过自定义的方式获取responseRegion属性值，参考代码如下：


```less
@Entry
@Component
struct TouchTargetExample {
  @State text: string = '';
  @State x: number = 0;
  @State y: number = 0;
  @State reg_width: string = '50%';
  @State reg_height: string = '100%';


  build() {
    Column({ space: 20 }) {
      Text(`{x:0,y:0,width:'50%',height:'100%'}`)
      // 热区宽度为按钮的一半，点击右侧无响应
      Button('button1')
        .responseRegion({
          x: this.x,
          y: this.y,
          width: this.reg_width,
          height: this.reg_height
        })
        .onClick(() => {
          this.text = 'button1 clicked';
          console.info('button1 clicked: ' + this.x + ' ' + this.y + ' ' + this.reg_width + ' ' + this.reg_height);
        })


      Text(this.text)
        .margin({ top: 10 })
    }
    .width('100%')
    .margin({ top: 100 })
  }
}
```


参考链接


responseRegion


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-308
爬取时间: 2025-05-08 05:23:38
来源: Huawei Developer


通过@ohos.pasteboard（剪贴板）模块提供的管理系统剪贴板能力，可以为系统复制、粘贴功能提供支持。系统剪贴板支持对文本、HTML、URI、Want、PixelMap等内容的操作。


示例如下：


```typescript
import { pasteboard } from '@kit.BasicServicesKit';
import { promptAction } from '@kit.ArkUI';


@Entry
@Component
struct CopyText {
  private textContent: string = '复制我';


  build() {
    Column() {
      Text(this.textContent)
        .fontSize(20)
        .borderRadius(9)
        .borderWidth(1)
        .padding({
          left: 8,
          right: 8
        })
        .fontColor($r('sys.color.ohos_id_color_text_primary'))
        .fontWeight(FontWeight.Medium)
        .opacity($r('sys.float.ohos_id_alpha_content_secondary'))
        .onClick(() => copyText(this.textContent))
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
    .alignSelf(ItemAlign.Center)
  }
}


// 定义方法
function copyText(text: string) {
  // 创建剪贴板内容对象
  const pasteboardData = pasteboard.createData(pasteboard.MIMETYPE_TEXT_PLAIN, text);
  // 获取系统剪贴板对象
  const systemPasteboard = pasteboard.getSystemPasteboard();
  systemPasteboard.setData(pasteboardData); // 将数据放入剪贴板
  systemPasteboard.getData().then((data) => { // 读取剪贴板内容
    if (data) {
      promptAction.showToast({ message: '复制成功' });
    } else {
      promptAction.showToast({ message: '复制失败' });
    }
  })
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-310
爬取时间: 2025-05-08 05:23:48
来源: Huawei Developer


Grid设置拖动时onItemDragStart默认时间是170毫秒，目前无法设置onItemDragStart的时间，可以通过自定义Grid，设置长按手势LongPressGesture中的duration时长，来实现控制GridItem拖拽的长按触发时间功能，参考代码如下：


```less
import { curves } from '@kit.ArkUI';


@Entry
@Component
struct Page {
  //元素数组
  @State numbers: number[] = [];
  @State row: number = 4;
  //元素数组中最后一个元素的索引
  @State lastIndex: number = 0;
  @State dragItem: number = -1;
  @State scaleItem: number = -1;
  @State item: number = -1;
  @State offsetX: number = 0;
  @State offsetY: number = 0;
  // row 设置网格列数
  private str: string = '';
  private dragRefOffsetx: number = 0;
  private dragRefOffsety: number = 0;
  private FIX_VP_X: number = 108;
  private FIX_VP_Y: number = 120;


  aboutToAppear() {
    for (let i = 1; i <= 110; i++) {
      this.numbers.push(i);
    }
    this.lastIndex = this.numbers.length - 1;


    // 多列
    for (let i = 0; i < this.row; i++) {
      this.str = this.str + '1fr ';
    }
  }


  itemMove(index: number, newIndex: number): void {
    if (!this.isDraggable(newIndex)) {
      return;
    }
    let tmp = this.numbers.splice(index, 1);
    this.numbers.splice(newIndex, 0, tmp[0]);
  }


  //向下滑
  down(index: number): void {
    // 指定固定GridItem不响应事件
    if (!this.isDraggable(index + this.row)) {
      return;
    }
    this.offsetY -= this.FIX_VP_Y;
    this.dragRefOffsety += this.FIX_VP_Y;
    // 多列
    this.itemMove(index, index + this.row);
  }


  //向下滑(右下角为空)
  down2(index: number): void {
    if (!this.isDraggable(index + 3)) {
      return;
    }
    this.offsetY -= this.FIX_VP_Y;
    this.dragRefOffsety += this.FIX_VP_Y;
    this.itemMove(index, index + 3);
  }


  //向上滑
  up(index: number): void {
    if (!this.isDraggable(index - this.row)) {
      return;
    }
    this.offsetY += this.FIX_VP_Y;
    this.dragRefOffsety -= this.FIX_VP_Y;
    this.itemMove(index, index - this.row);
  }


  //向左滑
  left(index: number): void {
    if (!this.isDraggable(index - 1)) {
      return;
    }
    this.offsetX += this.FIX_VP_X;
    this.dragRefOffsetx -= this.FIX_VP_X;
    this.itemMove(index, index - 1);
  }


  //向右滑
  right(index: number): void {
    if (!this.isDraggable(index + 1)) {
      return;
    }
    this.offsetX -= this.FIX_VP_X;
    this.dragRefOffsetx += this.FIX_VP_X;
    this.itemMove(index, index + 1);
  }


  //向右下滑
  lowerRight(index: number): void {
    if (!this.isDraggable(index + this.row + 1)) {
      return;
    }
    this.offsetX -= this.FIX_VP_X;
    this.dragRefOffsetx += this.FIX_VP_X;
    this.offsetY -= this.FIX_VP_Y;
    this.dragRefOffsety += this.FIX_VP_Y;
    this.itemMove(index, index + this.row + 1);
  }


  //向右上滑
  upperRight(index: number): void {
    if (!this.isDraggable(index - (this.row - 1))) {
      return;
    }
    this.offsetX -= this.FIX_VP_X;
    this.dragRefOffsetx += this.FIX_VP_X;
    this.offsetY += this.FIX_VP_Y;
    this.dragRefOffsety -= this.FIX_VP_Y;
    this.itemMove(index, index - (this.row - 1));
  }


  //向左下滑
  lowerLeft(index: number): void {
    if (!this.isDraggable(index + (this.row - 1))) {
      return;
    }
    this.offsetX += this.FIX_VP_X;
    this.dragRefOffsetx -= this.FIX_VP_X;
    this.offsetY -= this.FIX_VP_Y;
    this.dragRefOffsety += this.FIX_VP_Y;
    this.itemMove(index, index + (this.row - 1));
  }


  //向左上滑
  upperLeft(index: number): void {
    if (!this.isDraggable(index - (this.row + 1))) {
      return;
    }
    this.offsetX += this.FIX_VP_X;
    this.dragRefOffsetx -= this.FIX_VP_X;
    this.offsetY += this.FIX_VP_Y;
    this.dragRefOffsety -= this.FIX_VP_Y;
    this.itemMove(index, index - (this.row + 1));
  }


  //通过元素的索引，控制对应元素是否能移动排序
  isDraggable(index: number): boolean {
    return index > -1; //恒成立，所有元素均可移动排序
  }


  build() {
    Column() {
      Grid() {
        ForEach(this.numbers, (item: number) => {
          GridItem() {
            Text(item + '')
              .fontSize(16)
              .width('100%')
              .textAlign(TextAlign.Center)
              .height(100)
              .borderRadius(10)
              .backgroundColor(0xFFFFFF)
              .shadow(this.scaleItem == item ? {
                radius: 70,
                color: '#15000000',
                offsetX: 0,
                offsetY: 0
              } :
                {
                  radius: 0,
                  color: '#15000000',
                  offsetX: 0,
                  offsetY: 0
                })
              .animation({
                curve: Curve.Sharp,
                duration: 300
              })
          }
          .onAreaChange((_oldVal, newVal) => {
            // 多列
            this.FIX_VP_X = Math.round(newVal.width as number);
            this.FIX_VP_Y = Math.round(newVal.height as number);
          })
          // 指定固定GridItem不响应事件
          .hitTestBehavior(this.isDraggable(this.numbers.indexOf(item)) ? HitTestMode.Default : HitTestMode.None)
          .scale({ x: this.scaleItem === item ? 1.05 : 1, y: this.scaleItem === item ? 1.05 : 1 })
          .zIndex(this.dragItem === item ? 1 : 0)
          .translate(this.dragItem === item ? { x: this.offsetX, y: this.offsetY } : { x: 0, y: 0 })
          .padding(10)
          .gesture(
            //以下组合手势为顺序识别，当长按手势事件未正常触发时则不会触发拖动手势事件
            GestureGroup(GestureMode.Sequence,
              LongPressGesture({
                repeat: true,
                duration: 50
              })//控制触发拖动的长按事件的时间，默认500毫秒，设置小于0为默认值，这里设置为50毫秒
                .onAction((_event?: GestureEvent) => {
                  animateTo({
                    curve: Curve.Friction,
                    duration: 300
                  }, () => {
                    this.scaleItem = item;
                  });
                })
                .onActionEnd(() => {
                  animateTo({
                    curve: Curve.Friction,
                    duration: 300
                  }, () => {
                    this.scaleItem = -1;
                  });
                }),
              PanGesture({
                fingers: 1,
                direction: null,
                distance: 0
              })
                .onActionStart(() => {
                  this.dragItem = item;
                  this.dragRefOffsetx = 0;
                  this.dragRefOffsety = 0;
                })
                .onActionUpdate((event: GestureEvent) => {
                  this.offsetY = event.offsetY - this.dragRefOffsety;
                  this.offsetX = event.offsetX - this.dragRefOffsetx;


                  animateTo({ curve: curves.interpolatingSpring(0, 1, 400, 38) }, () => {
                    let index = this.numbers.indexOf(this.dragItem);
                    //  44  宽度一半  减间距
                    if (this.offsetY >= this.FIX_VP_Y / 2 &&
                      (this.offsetX <= this.FIX_VP_X / 2 && this.offsetX >= -this.FIX_VP_X / 2)
                      && (index + this.row <= this.lastIndex)) {
                      //向下滑
                      this.down(index);
                    } else if (this.offsetY <= -this.FIX_VP_Y / 2 &&
                      (this.offsetX <= this.FIX_VP_X / 2 && this.offsetX >= -this.FIX_VP_X / 2)
                      && index - this.row >= 0) {
                      //向上滑
                      this.up(index);
                    } else if (this.offsetX >= this.FIX_VP_X / 2 &&
                      (this.offsetY <= this.FIX_VP_Y / 2 && this.offsetY >= -this.FIX_VP_Y / 2)
                      && !(((index - (this.row - 1)) % this.row === 0) || index === this.lastIndex)) {
                      // ) {
                      //向右滑
                      this.right(index);
                    } else if (this.offsetX <= -this.FIX_VP_X / 2 &&
                      (this.offsetY <= this.FIX_VP_Y / 2 && this.offsetY >= -this.FIX_VP_Y / 2)
                      && !(index % this.row === 0)) {
                      //向左滑
                      this.left(index);
                    } else if (this.offsetX >= this.FIX_VP_X / 2 && this.offsetY >= this.FIX_VP_Y / 2
                      && ((index + this.row + 1 <= this.lastIndex && !((index - (this.row - 1)) % this.row === 0)) ||
                        !((index - (this.row - 1)) % this.row === 0))) {
                      //向右下滑
                      this.lowerRight(index);
                    } else if (this.offsetX >= this.FIX_VP_X / 2 && this.offsetY <= -this.FIX_VP_Y / 2
                      && !((index - this.row < 0) || ((index - (this.row - 1)) % this.row === 0))) {
                      //向右上滑
                      this.upperRight(index);
                    } else if (this.offsetX <= -this.FIX_VP_X / 2 && this.offsetY >= this.FIX_VP_Y / 2
                      && (!(index % this.row === 0) && (index + (this.row - 1) <= this.lastIndex))) {
                      //向左下滑
                      this.lowerLeft(index);
                    } else if (this.offsetX <= -this.FIX_VP_X / 2 && this.offsetY <= -this.FIX_VP_Y / 2
                      && !((index <= this.row - 1) || (index % this.row === 0))) {
                      //向左上滑
                      this.upperLeft(index);
                    } else if (this.offsetX >= this.FIX_VP_X / 2 && this.offsetY >= this.FIX_VP_Y / 2
                      && (index === this.lastIndex)) {
                      //向右下滑(右下角为空)
                      this.down2(index);
                    }
                  });
                })
                .onActionEnd(() => {
                  animateTo({
                    curve: curves.interpolatingSpring(0, 1, 400, 38)
                  }, () => {
                      this.dragItem = -1;
                    });
                  animateTo({
                    curve: curves.interpolatingSpring(14, 1, 170, 17),
                    delay: 150
                  }, () => {
                    this.scaleItem = -1;
                  });
                })
            )
              .onCancel(() => {
                animateTo({
                  curve: curves.interpolatingSpring(0, 1, 400, 38)
                }, () => {
                    this.dragItem = -1;
                  });
                animateTo({
                  curve: curves.interpolatingSpring(14, 1, 170, 17)
                }, () => {
                  this.scaleItem = -1;
                });
              })
          )
        }, (item: number) => item.toString())
      }
      .width('90%')
      .editMode(true)
      .scrollBar(BarState.Off)
      // 多列
      .columnsTemplate(this.str)
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#0D182431')
    .padding({ top: 5 })
  }
}
```


效果图如下：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160842.59924891017552558542707445591097:50001231000000:2800:F67DE0BD253AF16BC539F62764BA837CE57A40BCBA41894F56F14FBE55B09C53.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-311
爬取时间: 2025-05-08 05:23:58
来源: Huawei Developer


问题现象


bindSheet和foreach合用的问题，$$this.isShow会弹出两次半模态，如果是this.isShow，则半模态弹出的次数是数组的长度数，如何在某一个foreach中的item点击的时候只弹出一个弹窗。


解决措施


给每一个弹窗都绑定一个@State修饰的变量。


参考代码如下：


```typescript
@Entry
@Component
export struct BindSheetAndForEach {
  @State isShow: boolean = false;
  @State arr: number[] = [1, 2, 3, 4];
  @State isHoverText: Array<boolean> = new Array<boolean>(this.arr.length).fill(false);


  @Builder
  myBuilder() {
    Column() {
      Button('content1')
        .margin(10)
        .fontSize(20)
    }
    .width('100%')
  }


  build() {
    Column() {
      ForEach(this.arr, (item: number, idx: number) => {
        Row() {
          Text('item')
          Button('弹框')
            .onClick(() => {
              this.isHoverText[idx] = true;
            })
            .fontSize(15)
            .margin(10)
            .bindSheet(this.isHoverText[idx], this.myBuilder(), {
              backgroundColor: Color.Gray,
              height: SheetSize.MEDIUM,
              showClose: true,
              onDisappear: () => {
                this.isHoverText[idx] = false;
              }
            })
          Checkbox()
        }
        .border({ width: 1, radius: 5 })
      })
    }
    .justifyContent(FlexAlign.Start)
    .width('100%')
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-313
爬取时间: 2025-05-08 05:24:08
来源: Huawei Developer


利用CanvasRenderingContext2D对象的arc绘制弧形路径，结合lineTo方法绘制直线，参考代码如下：


```less
@Entry
@Component
struct CanvasDrawRoundedRectangle {
  private readonly settings: RenderingContextSettings = new RenderingContextSettings(true);
  private readonly ctx: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);


  drawRoundRect(x: number, y: number, width: number, height: number, radius: number, strokeColor?: string,
    fillColor?: string, lineDash?: []) {
    strokeColor = strokeColor || '#333';
    lineDash = lineDash || [];
    this.ctx.beginPath();
    this.ctx.setLineDash(lineDash);
    // 绘制第一段圆弧路径
    this.ctx.arc(x + radius, y + radius, radius, Math.PI, Math.PI * 3 / 2);
    // 绘制第一段直线路径
    this.ctx.lineTo(width - radius + x, y);
    // 绘制第二段圆弧路径
    this.ctx.arc(width - radius + x, radius + y, radius, Math.PI * 3 / 2, Math.PI * 2);
    // 绘制第二段直线路径
    this.ctx.lineTo(width + x, height + y - radius);
    // 绘制第三段圆弧路径
    this.ctx.arc(width - radius + x, height - radius + y, radius, 0, Math.PI / 2);
    // 绘制第三段直线路径
    this.ctx.lineTo(radius + x, height + y);
    // 绘制第四段圆弧路径
    this.ctx.arc(radius + x, height - radius + y, radius, Math.PI / 2, Math.PI);
    // 绘制第四段直线路径
    this.ctx.lineTo(x, y + radius);
    // 设置画笔颜色
    this.ctx.strokeStyle = strokeColor;
    // 描边绘制
    this.ctx.stroke();
    if (fillColor) {
      this.ctx.fillStyle = fillColor;
      this.ctx.fill();
    }
    this.ctx.closePath();
  }


  build() {
    Row() {
      Column() {
        Canvas(this.ctx)
          .width('100%')
          .height('100%')
          .onReady(() => {
            this.drawRoundRect(50, 50, 100, 100, 10);
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


实现效果图如下所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160842.40471930048783976021551401397392:50001231000000:2800:DD6DECBEF777E7402C1AE1A8110C318014F75F64F39E01557523B5F10BB76BB6.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-314
爬取时间: 2025-05-08 05:24:18
来源: Huawei Developer


margin和padding提供外边距类型LocalizedMargin和LocalizedPadding，可用于设置不同外边距和内边距。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-316
爬取时间: 2025-05-08 05:24:27
来源: Huawei Developer


1.Scroll组件：在onDidScroll里获取currentOffset().yOffset来控制单边回弹效果；


2.List组件：可以在onDidScroll里获取currentOffset().yOffset来控制，还可以通过onScrollIndex实现单边回弹效果。


参考代码如下：


```typescript
// Scroll组件单边回弹效果
@Entry
@Component
struct ScrollSideRebound {
  @State yOffset: number = 0;
  scroller: Scroller = new Scroller();
  private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];


  build() {
    Stack({ alignContent: Alignment.TopStart }) {
      Scroll(this.scroller) {
        Column() {
          ForEach(this.arr, (item: number) => {
            Text(item.toString())
              .width('90%')
              .height(150)
              .backgroundColor(0xFFFFFF)
              .borderRadius(15)
              .fontSize(16)
              .textAlign(TextAlign.Center)
              .margin({ top: 10 })
          }, (item: string) => item)
        }
        .width('100%')
      }
      .scrollable(ScrollDirection.Vertical) // 滚动方向纵向
      .scrollBar(BarState.On) // 滚动条常驻显示
      .scrollBarColor(Color.Gray) // 滚动条颜色
      .scrollBarWidth(2) // 滚动条宽度
      .friction(0.6)
      .edgeEffect(this.yOffset <= 0 ? EdgeEffect.Spring : EdgeEffect.None) // 滚动到边沿后回弹
      .onDidScroll(() => {
        this.yOffset = this.scroller.currentOffset().yOffset;
      })
    }
    .width('100%')
    .height('100%')
    .backgroundColor(0xDCDCDC)
  }
}
```


```typescript
// List组件单边回弹效果
@Entry
@Component
struct ListSideRebound {
  @State isTop: boolean = true;
  private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];


  build() {
    Column() {
      List({ space: 20, initialIndex: 0 }) {
        ForEach(this.arr, (item: number) => {
          ListItem() {
            Text('' + item)
              .width('100%')
              .height(100)
              .fontSize(16)
              .textAlign(TextAlign.Center)
              .borderRadius(10)
              .backgroundColor(0xFFFFFF)
          }
        }, (item: string) => item)
      }
      .listDirection(Axis.Vertical) // 排列方向
      .scrollBar(BarState.Off)
      .friction(0.6)
      .edgeEffect(this.isTop ? EdgeEffect.Spring : EdgeEffect.None)
      .onScrollIndex((firstIndex: number) => {
        if (firstIndex === 0) {
          this.isTop = true;
        } else {
          this.isTop = false;
        }
      })
      .width('90%')
    }
    .width('100%')
    .height('100%')
    .backgroundColor(0xDCDCDC)
    .padding({ top: 5 })
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-317
爬取时间: 2025-05-08 05:24:37
来源: Huawei Developer


整个外层布局是一个Scroll，内层布局有两个List，上面是ListA，下面的是ListB，分别采取LazyForEach的方式加载数据，并且给ListA和ListB绑定nestedScroll属性。


参考代码如下：


```less
import { MyDataSource } from './DataUtil';


@Entry
@Component
struct DoubleLazyForEach {
  private scrollerForScroll: Scroller = new Scroller();


  build() {
    Flex() {
      Scroll(this.scrollerForScroll) {
        Column() {
          Text('Scroll Area')
            .width('100%')
            .height('40%')
            .backgroundColor(0X330000FF)
            .fontSize(16)
            .textAlign(TextAlign.Center)
          ListA().height('80%')
          ListB().height('80%')
        }
      }
      .width('100%')
      .height('100%')
    }
    .width('100%')
    .height('100%')
    .backgroundColor(0xDCDCDC)
    .padding(20)
  }
}


@Component
struct ListA {
  private scrollerForListA: Scroller = new Scroller();
  private dataOne: MyDataSource = new MyDataSource();


  aboutToAppear() {
    for (let i = 0; i <= 20; i++) {
      this.dataOne.pushData(`Hello One ${i}`);
    }
  }


  build() {
    Column() {
      List({ space: 20, scroller: this.scrollerForListA }) {
        LazyForEach(this.dataOne, (item: number) => {
          ListItem() {
            Text('ListItem' + item)
              .width('100%')
              .height('100%')
              .borderRadius(15)
              .fontSize(16)
              .textAlign(TextAlign.Center)
              .backgroundColor(Color.White)
          }
          .width('100%')
          .height(100)
        }, (item: string) => item)
      }
      .width('100%')
      .height('100%')
      .edgeEffect(EdgeEffect.None)
      .friction(0.6)
      .nestedScroll({
        scrollForward: NestedScrollMode.SELF_FIRST,
        scrollBackward: NestedScrollMode.PARENT_FIRST
      })
    }
    .height('100%')
    .width('100%')
  }
}


@Component
struct ListB {
  private dataTwo: MyDataSource = new MyDataSource();
  private scrollerForListB: Scroller = new Scroller();


  aboutToAppear() {
    for (let i = 0; i <= 20; i++) {
      this.dataTwo.pushData(`Hello Two ${i}`);
    }
  }


  build() {
    Column() {
      List({ space: 20, scroller: this.scrollerForListB }) {
        LazyForEach(this.dataTwo, (item: number) => {
          ListItem() {
            MyText({ state_value: item.toString() })
          }
          .width('100%')
          .height(100)
        }, (item: string) => item)
      }
      .width('100%')
      .height('100%')
      .edgeEffect(EdgeEffect.None)
      .friction(0.6)
      .nestedScroll({
        scrollForward: NestedScrollMode.PARENT_FIRST,
        scrollBackward: NestedScrollMode.SELF_FIRST
      })
    }
  }
}


@Component
struct MyText {
  @State private state_value: string = 'Hello';


  build() {
    Text('ListItem' + this.state_value)
      .width('100%')
      .height('100%')
      .borderRadius(15)
      .fontSize(16)
      .textAlign(TextAlign.Center)
      .backgroundColor(Color.Pink)
  }
}
```


```less
// DataUtil.ets
export class BasicDataSource implements IDataSource {
  private listeners: DataChangeListener[] = [];
  private originDataArray: string[] = [];


  public totalCount(): number {
    return 0;
  }


  public getData(index: number): string {
    return this.originDataArray[index];
  }


  // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听
  registerDataChangeListener(listener: DataChangeListener): void {
    if (this.listeners.indexOf(listener) < 0) {
      console.info('add listener');
      this.listeners.push(listener);
    }
  }


  // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听
  unregisterDataChangeListener(listener: DataChangeListener): void {
    const pos = this.listeners.indexOf(listener);
    if (pos >= 0) {
      console.info('remove listener');
      this.listeners.splice(pos, 1);
    }
  }


  // 通知LazyForEach组件需要重载所有子组件
  notifyDataReload(): void {
    this.listeners.forEach(listener => {
      listener.onDataReloaded();
    })
  }


  // 通知LazyForEach组件需要在index对应索引处添加子组件
  notifyDataAdd(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataAdd(index);
    })
  }


  // 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件
  notifyDataChange(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataChange(index);
    })
  }


  // 通知LazyForEach组件需要在index对应索引处删除该子组件
  notifyDataDelete(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataDelete(index);
    })
  }


  // 通知LazyForEach组件将from索引和to索引处的子组件进行交换
  notifyDataMove(from: number, to: number): void {
    this.listeners.forEach(listener => {
      listener.onDataMove(from, to);
    })
  }
}


export class MyDataSource extends BasicDataSource {
  private dataArray: string[] = [];


  public totalCount(): number {
    return this.dataArray.length;
  }


  public getData(index: number): string {
    return this.dataArray[index];
  }


  public addData(index: number, data: string): void {
    this.dataArray.splice(index, 0, data);
    this.notifyDataAdd(index);
  }


  public pushData(data: string): void {
    this.dataArray.push(data);
    this.notifyDataAdd(this.dataArray.length - 1);
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-318
爬取时间: 2025-05-08 05:24:47
来源: Huawei Developer


是为了避免二次布局导致过大的性能开销，给高度标记了auto之后，在垂直方向上，RelativeContainer会依赖组件间在垂直方向上的布局这样会导致二次布局，因为子组件此时是相对容器的垂直方向上的布局，那这个时候，父组件的布局又要依赖子组件布局之后的结果再次进行布局。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-319
爬取时间: 2025-05-08 05:24:57
来源: Huawei Developer


可以通过在module.json5配置文件中abilities标签下的supportWindowMode属性设置“fullscreen”字段。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-320
爬取时间: 2025-05-08 05:25:06
来源: Huawei Developer


可以通过添加并行手势绑定方法parallelGesture来处理，参考代码如下：


```typescript
@Entry
@Component
struct ScrollAndGesture {
  scroller: Scroller = new Scroller();
  private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
  private panOption: PanGestureOptions = new PanGestureOptions({ direction: PanDirection.Up | PanDirection.Down });


  build() {
    Stack({ alignContent: Alignment.TopStart }) {
      Scroll(this.scroller) {
        Column() {
          ForEach(this.arr, (item: number) => {
            Text(item.toString())
              .width('90%')
              .height(150)
              .backgroundColor(0xFFFFFF)
              .borderRadius(15)
              .fontSize(16)
              .textAlign(TextAlign.Center)
              .margin({ top: 10 })
          }, (item: string) => item)
        }.width('100%')
      }
      .scrollable(ScrollDirection.Vertical) // 滚动方向纵向
      .scrollBar(BarState.On) // 滚动条常驻显示
      .scrollBarColor(Color.Gray) // 滚动条颜色
      .scrollBarWidth(10) // 滚动条宽度
      .friction(0.6)
      .edgeEffect(EdgeEffect.None)
      .onWillScroll((xOffset: number, yOffset: number) => {
        console.info(xOffset + ' ' + yOffset);
      })
      .onScrollEdge((side: Edge) => {
        console.info('To the edge');
      })
      .onScrollStop(() => {
        console.info('Scroll Stop');
      })
    }


    .parallelGesture(
      PanGesture(this.panOption)
        .onActionStart((event?: GestureEvent) => {
          console.info('wy Pan start',event);
        })
        .onActionUpdate((event?: GestureEvent) => {
          if (event) {
            console.info('wy Pan event',event);
          }
        })
        .onActionEnd(() => {
          console.info('wy Pan end');
        })
    )
    .width('100%')
    .height('100%')
    .backgroundColor(0xDCDCDC)
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-321
爬取时间: 2025-05-08 05:25:16
来源: Huawei Developer


可参考如下代码：


```less
@Entry
@Component
struct ListItemGroupAndReusable {
  data: DataSrc2 = new DataSrc2();


  @Builder
  itemHead(text: string) {
    Text(text)
      .fontSize(20)
      .backgroundColor(0xAABBCC)
      .width('100%')
      .padding(10)
  }


  aboutToAppear() {
    for (let i = 0; i < 10000; i++) {
      let data_1 = new DataSrc1();
      for (let j = 0; j < 12; j++) {
        data_1.Data.push(`测试数据测试数据测试数据: ${i} - ${j}`);
      }
      this.data.Data.push(data_1);
    }
  }


  build() {
    Stack() {
      List() {
        LazyForEach(this.data, (item: DataSrc1, index: number) => {
          ListItemGroup({ header: this.itemHead(index.toString()) }) {
            LazyForEach(item, (ii: string, index: number) => {
              ListItem() {
                Inner({ str: ii })
              }
            })
          }
          .width('100%')
          .height('60vp')
        })
      }
    }
    .width('100%')
    .height('100%')
  }
}


@Reusable
@Component
struct Inner {
  @State str: string = ''


  aboutToReuse(param: ESObject) {
    this.str = param.str;
  }


  build() {
    Text(this.str)
  }
}


class DataSrc1 implements IDataSource {
  listeners: DataChangeListener[] = [];
  Data: string[] = [];


  public totalCount(): number {
    return this.Data.length;
  }


  public getData(index: number): string {
    return this.Data[index];
  }


  // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听
  registerDataChangeListener(listener: DataChangeListener): void {
    if (this.listeners.indexOf(listener) < 0) {
      this.listeners.push(listener);
    }
  }


  // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听
  unregisterDataChangeListener(listener: DataChangeListener): void {
    const pos = this.listeners.indexOf(listener);
    if (pos >= 0) {
      this.listeners.splice(pos, 1);
    }
  }


  // 通知LazyForEach组件需要重载所有子组件
  notifyDataReload(): void {
    this.listeners.forEach(listener => {
      listener.onDataReloaded();
    })
  }


  // 通知LazyForEach组件需要在index对应索引处添加子组件
  notifyDataAdd(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataAdd(index);
    })
  }


  // 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件
  notifyDataChange(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataChange(index);
    })
  }


  // 通知LazyForEach组件需要在index对应索引处删除该子组件
  notifyDataDelete(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataDelete(index);
    })
  }


  // 通知LazyForEach组件将from索引和to索引处的子组件进行交换
  notifyDataMove(from: number, to: number): void {
    this.listeners.forEach(listener => {
      listener.onDataMove(from, to);
    })
  }
}


class DataSrc2 implements IDataSource {
  listeners: DataChangeListener[] = [];
  Data: DataSrc1[] = [];


  public totalCount(): number {
    return this.Data.length;
  }


  public getData(index: number): DataSrc1 {
    return this.Data[index];
  }


  // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听
  registerDataChangeListener(listener: DataChangeListener): void {
    if (this.listeners.indexOf(listener) < 0) {
      this.listeners.push(listener);
    }
  }


  // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听
  unregisterDataChangeListener(listener: DataChangeListener): void {
    const pos = this.listeners.indexOf(listener);
    if (pos >= 0) {
      this.listeners.splice(pos, 1);
    }
  }


  // 通知LazyForEach组件需要重载所有子组件
  notifyDataReload(): void {
    this.listeners.forEach(listener => {
      listener.onDataReloaded();
    })
  }


  // 通知LazyForEach组件需要在index对应索引处添加子组件
  notifyDataAdd(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataAdd(index);
    })
  }


  // 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件
  notifyDataChange(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataChange(index);
    })
  }


  // 通知LazyForEach组件需要在index对应索引处删除该子组件
  notifyDataDelete(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataDelete(index);
    })
  }


  // 通知LazyForEach组件将from索引和to索引处的子组件进行交换
  notifyDataMove(from: number, to: number): void {
    this.listeners.forEach(listener => {
      listener.onDataMove(from, to);
    })
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-323
爬取时间: 2025-05-08 05:25:26
来源: Huawei Developer


问题现象


Text组件绑定bindSelectionMenu自定义菜单，长按弹出自定义菜单，使用closeSelectionMenu关闭自定义菜单，文本选中状态不会取消。


解决措施


该场景下要取消选中状态可以使用selection重新设置选中区域，在调用closeSelectionMenu关闭自定义菜单时重新设置selection的start、end即可取消选中状态。示例代码如下：


```less
@Entry
@Component
struct TextMenuUnchecked {
  controller: TextController = new TextController();
  options: TextOptions = { controller: this.controller };
  @State start: number = -1;
  @State end: number = -1;


  build() {
    Column() {
      Column() {
        Text(undefined, this.options) {
          Span('Hello World')
          ImageSpan($r('app.media.app_icon'))
            .width(50)
            .height(50)
            .objectFit(ImageFit.Fill)
            .verticalAlign(ImageSpanAlignment.CENTER)
        }
        .selection(this.start, this.end)
        .copyOption(CopyOptions.InApp)
        // 长按弹出自定义菜单
        .bindSelectionMenu(TextSpanType.TEXT, this.LongPressImageCustomMenu, TextResponseType.LONG_PRESS, {
          onDisappear: () => {
            console.info(`自定义选择菜单关闭时回调`);
          },
          onAppear: () => {
            console.info(`自定义选择菜单弹出时回调`);
          }
        })
        // 选中区域发生变化时触发回调，更新选中区域的起始下标和末尾下标
        .onTextSelectionChange((selectionStart: number, selectionEnd: number) => {
          this.start = selectionStart;
          this.end = selectionEnd;
          console.info(`文本选中区域变化回调, selectionStart: ${selectionStart}, selectionEnd: ${selectionEnd}`);
        })
        .borderWidth(1)
        .borderColor(Color.Red)
        .width(200)
        .height(100)
      }
      .width('100%')
      .backgroundColor(Color.White)
      .alignItems(HorizontalAlign.Start)
      .padding(25)
    }
    .height('100%')
  }


  @Builder
  LongPressImageCustomMenu() {
    Column() {
      Menu() {
        MenuItemGroup() {
          MenuItem({
            startIcon: $r('app.media.app_icon'),
            content: 'Right Click Menu 1',
            labelInfo: ''
          })
            .onClick(() => { //点击自定义菜单时，重新设置选中区域的起始下标和末尾下标
              this.start = -1;
              this.end = -1;
              this.controller.closeSelectionMenu();
            })
          MenuItem({ startIcon: $r('app.media.app_icon'), content: 'Select Mixed Menu 2', labelInfo: '' })
          MenuItem({ startIcon: $r('app.media.app_icon'), content: 'Select Mixed Menu 3', labelInfo: '' })
        }
      }
      .radius($r('sys.float.ohos_id_corner_radius_card'))
      .clip(true)
      .backgroundColor('#F0F0F0')
    }
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-324
爬取时间: 2025-05-08 05:25:36
来源: Huawei Developer


WaterFlow适用于展示多列，各子组件高度参差不齐，需要不停滑动加载的布局场景。


Grid适用于网格布局，使用List的lanes属性，也能实现类似网格布局的效果，但是Grid组件对item的拖拽支持更好。


List适用于相同列宽，需要连续，多行呈现的列表布局场景。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-325
爬取时间: 2025-05-08 05:25:45
来源: Huawei Developer


问题现象


在A页面弹出一个CustomDialog，若Dialog未关闭时从A页面跳转到B页面，此时会发现在A页面弹出的Dialog会出现在B页面的层级上方。请问有什么方式可以让页面B盖住Dialog？


解决措施


原因是CustomDialog的默认层级高于页面。可以使用navigation方式跳转，它主要用于实现页面间以及组件内部的页面跳转，页面层级由导航栈管理，默认后打开的页面层级高于之前的页面。具体请参考如下示例代码：


```less
import { promptAction } from '@kit.ArkUI';


@Component
struct Test1 {
  @State message: string = 'Hello World';


  build() {
    NavDestination() {
      Row() {
        Column() {
          Text(this.message)
            .fontSize(50)
            .fontWeight(FontWeight.Bold)
        }
        .width('100%')
      }
      .height('100%')
    }
    .onBackPressed(() => {
      promptAction.showToast({ message: '123' });
      return false;
    })
  }
}


@Entry
@Component
struct CustomDialogDisplayLevel {
  @Provide('pageInfos') pageInfos: NavPathStack = new NavPathStack();
  @State textValue: string = '输入';
  // 显隐控制设置为不占用
  @State visible: Visibility = Visibility.None;


  @Builder
  pageMap(name: string) {
    if (name === 'pageOne') {
      Test1()
    }
  }


  build() {
    Navigation(this.pageInfos) {
      Column() {
        Stack() {
          Row() {
            Column() {
              Text('我是第一个页面')
                .fontSize(30)
                .fontWeight(FontWeight.Bold)
              Button('按钮')
                .onClick(() => {
                  console.info('hit me!');
                  if (this.visible === Visibility.Visible) {
                    this.visible = Visibility.None;
                  } else {
                    this.visible = Visibility.Visible;
                  }
                })
                .backgroundColor(0x777474)
                .fontColor(0x000000)
            }
            .height('100%')
            .width('100%')
            .justifyContent(FlexAlign.Start)
            .alignItems(HorizontalAlign.Center)
          }
          .height('100%')
          .backgroundColor('#FFF')


          Text('')
            .onClick(() => {
              if (this.visible === Visibility.Visible) {
                this.visible = Visibility.None;
              } else {
                this.visible = Visibility.Visible;
              }
            })
            .width('100%')
            .height('100%')
              // 透明度可以自己调节一下
            .opacity(0.5)
            .backgroundColor(Color.Black)
            .visibility(this.visible)
          Column() {
            GridRow({
              columns: {
                xs: 1,
                sm: 4,
                md: 8,
                lg: 12
              },
              breakpoints: {
                value: ['400vp', '600vp', '800vp'],
                reference: BreakpointsReference.WindowSize
              },
            }) {
              GridCol({
                span: {
                  xs: 1,
                  sm: 2,
                  md: 4,
                  lg: 8
                },
                offset: {
                  xs: 0,
                  sm: 1,
                  md: 2,
                  lg: 2
                }
              }) {
                Column() {
                  Text('安全隐私')
                    .fontSize(20)
                    .margin({
                      top: 10,
                      bottom: 10
                    })
                  Text('是否跳转到隐私详情页面?')
                    .fontSize(16)
                    .margin({ bottom: 10 })
                  Flex({ justifyContent: FlexAlign.SpaceAround }) {
                    Button('取消')
                      .onClick(() => {
                        if (this.visible === Visibility.Visible) {
                          this.visible = Visibility.None;
                        } else {
                          this.visible = Visibility.Visible;
                        }
                      })
                      .backgroundColor(0xffffff)
                      .fontColor(Color.Black)
                    Button('确定')
                      .onClick(() => {
                        this.pageInfos.pushPath({ name: 'pageOne' });
                      })
                      .backgroundColor(0xffffff)
                      .fontColor(Color.Red)
                  }
                  .margin({ bottom: 10 })
                }
                .backgroundColor(0xffffff)
                .visibility(this.visible)
                .clip(true)
                .borderRadius(20)
              }
            }
          }
          //设置弹窗宽度
          .width('100%')
        }
      }
      .width('100%')
      .margin({ top: 5 })
    }
    .navDestination(this.pageMap)
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-327
爬取时间: 2025-05-08 05:25:55
来源: Huawei Developer


针对ForEach耗时影响性能，需要注意键值生成规则。


使用ForEach渲染时第三个参数KeyGenerator函数如果处于缺省状态，ArkUI框架会使用默认的键值生成函数，即(item: any, index: number) => { return index + '__' + JSON.stringify(item); }，在数据复杂的对象集合和复杂的交互中，会影响渲染性能。为满足键值的唯一性，对于对象数据类型，建议使用对象数据中的唯一id作为键值。不推荐将第三个参数KeyGenerator函数处于缺省状态，以及在键值生成规则中包含数据项索引index。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-328
爬取时间: 2025-05-08 05:26:05
来源: Huawei Developer


如果需要做动画，规格上是一定要从1，2，3，4进行运动的，如果不想显示中间过渡页，可以通过设置.animationDuration(0)，示例代码如下：


```less
@Entry
@Component
struct TABTransitionAnimation {
  @State fontColor: string = '#182431';
  @State selectedFontColor: string = '#007DFF';
  @State currentIndex: number = 0;
  private controller: TabsController = new TabsController();


  @Builder
  tabBuilder(index: number, name: string) {
    Column() {
      Text(name)
        .fontColor(this.currentIndex === index ? this.selectedFontColor : this.fontColor)
        .fontSize(16)
        .fontWeight(this.currentIndex === index ? 500 : 400)
        .lineHeight(22)
        .margin({
          top: 17,
          bottom: 7
        })
      Divider()
        .strokeWidth(2)
        .color($r('sys.color.brand'))
        .opacity(this.currentIndex === index ? 1 : 0)
    }
    .width('100%')
  }


  build() {
    Column() {
      Tabs({ barPosition: BarPosition.Start, index: this.currentIndex, controller: this.controller }) {
        TabContent() {
          Column()
            .width('100%')
            .height('100%')
            .backgroundColor('#00CB87')
        }.tabBar(this.tabBuilder(0, 'green'))


        TabContent() {
          Column()
            .width('100%')
            .height('100%')
            .backgroundColor($r('sys.color.brand'))
        }.tabBar(this.tabBuilder(1, 'blue'))


        TabContent() {
          Column()
            .width('100%')
            .height('100%')
            .backgroundColor($r('sys.color.multi_color_11'))
        }.tabBar(this.tabBuilder(2, 'yellow'))


        TabContent() {
          Column()
            .width('100%')
            .height('100%')
            .backgroundColor('#E67C92')
        }
        .tabBar(this.tabBuilder(3, 'pink'))
      }
      .width(360)
      .height(296)
      .barWidth(360)
      .barHeight(56)
      .vertical(false)
      .barMode(BarMode.Fixed)
      .backgroundColor('#F1F3F5')
      .margin({ top: 52 })
      .animationDuration(0) // 设置动画时间为0，即可解决跨页切换显示中间过渡页面
      .onChange((index: number) => {
        this.currentIndex = index;
      })
    }
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-329
爬取时间: 2025-05-08 05:26:15
来源: Huawei Developer


LocalStorage的读写操作是同步的，即当读取或写入LocalStorage时，程序会阻塞等待操作完成才会继续执行后续代码，所以不推荐频繁修改复杂对象。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-331
爬取时间: 2025-05-08 05:26:25
来源: Huawei Developer


```less
controller: TextInputController = new TextInputController();
controller1: TextInputController = new TextInputController();
...
```


```less
// 自定义键盘组件
@Component
export struct CustomKeyboardBuilder {
  controller?: TextInputController = new TextInputController();
  index: number = 0;
  @Link inputValue: string


  build() {
    Column() {
      // ...
    }
  }
}
```


```less
TextInput({ controller: this.controller, text: this.inputValue })// 绑定自定义键盘
  .customKeyboard(this.CustomKeyboardBuilder()).margin(10).border({ width: 1 }).height('48vp')
```


参考如下代码:


```less
@Entry
@Component
struct TextInputExample {
  controller: TextInputController = new TextInputController();
  @State inputValue: string = '';
  controller1: TextInputController = new TextInputController();
  @State inputValue1: string = '';
  controller2: TextInputController = new TextInputController();
  @State inputValue2: string = '';


  build() {
    Column() {
      this.input({ inputValue: this.inputValue, controller: this.controller, index: 0 });
      this.input({ inputValue: this.inputValue1, controller: this.controller1, index: 1 });
      this.input({ inputValue: this.inputValue2, controller: this.controller2, index: 2 });
    }
  }


  @Builder
  input(tmp: Tmp) {
    if (tmp.index === 0) {
      TextInput({ controller: tmp.controller, text: tmp.inputValue })
        .customKeyboard(this.keyboard())
        .margin(10)
        .border({ width: 1 })
        .height('48vp')
    } else if (tmp.index === 1) {
      TextInput({ controller: tmp.controller, text: tmp.inputValue })
        .customKeyboard(this.keyboard1())
        .margin(10)
        .border({ width: 1 })
        .height('48vp')
    } else {
      TextInput({ controller: tmp.controller, text: tmp.inputValue })
        .customKeyboard(this.keyboard2())
        .margin(10)
        .border({ width: 1 })
        .height('48vp')
    }
  }


  @Builder
  keyboard() {
    CustomKeyboardBuilder({ inputValue: this.inputValue, controller: this.controller, index: 0 });
  }


  @Builder
  keyboard1() {
    CustomKeyboardBuilder({ inputValue: this.inputValue1, controller: this.controller1, index: 1 });
  }


  @Builder
  keyboard2() {
    CustomKeyboardBuilder({ inputValue: this.inputValue2, controller: this.controller2, index: 2 });
  }
}


class Tmp {
  inputValue?: string;
  controller?: TextInputController;
  index?: number;
}


// 自定义键盘组件
@Component
export struct CustomKeyboardBuilder {
  controller?: TextInputController = new TextInputController();
  index: number = 0;
  @Link inputValue: string;


  build() {
    Column() {
      Button('x').onClick(() => {
        // 关闭自定义键盘
        this.controller?.stopEditing();
      })
      Grid() {
        ForEach([1, 2, 3, 4, 5, 6, 7, 8, 9, '*', 0, '#'], (item: number | string) => {
          GridItem() {
            Button(item + '')
              .backgroundColor(this.index === 0 ? Color.Blue :
                (this.index === 1 ? Color.Green : Color.Red))
              .width(110)
              .onClick(() => {
                this.inputValue += item;
              })
          }
        })
      }
      .maxCount(3)
      .columnsGap(10)
      .rowsGap(10)
      .padding(5)
    }
    .backgroundColor(Color.Gray)
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-333
爬取时间: 2025-05-08 05:26:34
来源: Huawei Developer


问题现象


比如一个自定义的Component，有20个@State修饰的变量，每个State都定义了相关更新接口，外部某个时机，会批量更新这些State，调用每个State的更新接口，会不会导致频繁更新Component组件，导致性能问题？


解决措施


同时对多个State接口更新不会导致性能问题，因为每个@State都要有去更新UI的能力，一次性批量的修改不会导致一个组件被反复刷多次，在一个Vsync内，对同一个组件的多次标脏只刷新一次。如果状态变量数量过多会影响自定义组件创建耗时。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-334
爬取时间: 2025-05-08 05:26:43
来源: Huawei Developer


1.通过行高计算


```typescript
@Entry
@Component
struct AllListItemHeight {
  private itemHeightArr = [100, 150, 200, 130, 120, 110.130];
  private listHeight = 700;
  scroller = new ListScroller();


  build() {
    Column() {
      Button('是否超过一屏')
        .height(50)
        .width('100%')
        .onClick(() => {
          let result = 0;
          for (let i = 0; i < this.itemHeightArr.length; i++) {
            result += this.itemHeightArr[i];
          }
          console.info(result > this.listHeight ? '超过一屏' : '没有超过一屏');
        })
      List({ scroller: this.scroller }) {
        ForEach(this.itemHeightArr, (_: number, index: number) => {
          ListItem() {
            Text(index.toString())
              .width('100%')
              .textAlign(TextAlign.Center)
          }
          .height(this.itemHeightArr[index])
          .align(Alignment.Center)
        }, (item: number) => JSON.stringify(item))
      }
      .height(this.listHeight)
      .width('100%')
    }
  }
}
```


2.通过getItemRect(index: number): RectResult获取子组件的大小位置，可以获取最后一个ListItem的位置大小信息进行计算


```typescript
@Entry
@Component
struct GetLastItem {
  private itemHeightArr = [100, 150, 200, 130, 120, 110.130];
  private listHeight = 700;
  scroller = new ListScroller();


  build() {
    Column() {
      Button('是否超过一屏')
        .height(50)
        .width('100%')
        .onClick(() => {
          let result = this.scroller.getItemRect(this.itemHeightArr.length - 1);
          let flag = result.x == 0 && result.y == 0 && result.width == 0 && result.height == 0
          console.info(flag ? '超过一屏' : '没有超过一屏')
        })
      List({ scroller: this.scroller }) {
        ForEach(this.itemHeightArr, (_: number, index: number) => {
          ListItem() {
            Text(index.toString())
              .width('100%')
              .textAlign(TextAlign.Center)
          }
          .height(this.itemHeightArr[index])
          .align(Alignment.Center)
        }, (item: number) => JSON.stringify(item))
      }
      .height(this.listHeight)
      .width('100%')
    }
  }
}
```


3.通过getItemRectInGroup(index: number, indexInGroup: number): RectResult，获取最后一个ListItemGroup中的最后一个ListItem的大小和相对于List的位置进行计算


```typescript
@Entry
@Component
struct GetLastGroup {
  private groupItemHeightArr =
    [[30, 50, 60, 40, 90, 80.60],
      [50, 40, 50, 55, 77, 88.44],];
  private listHeight = 700;
  scroller = new ListScroller();


  build() {
    Column() {
      Button('是否超过一屏')
        .height(50)
        .width('100%')
        .onClick(() => {
          let lastGroupIndex = this.groupItemHeightArr.length - 1;
          let lastItemIndex = this.groupItemHeightArr[lastGroupIndex].length - 1;
          let result = this.scroller.getItemRectInGroup(lastGroupIndex, lastItemIndex);
          let flag = result.x == 0 && result.y == 0 && result.width == 0 && result.height == 0
          console.info(flag ? '超过一屏' : '没有超过一屏')
        })
      List({ scroller: this.scroller }) {
        ForEach(this.groupItemHeightArr, (itemHeight: number[], index: number) => {
          ListItemGroup() {
            ForEach(itemHeight, (height: number) => {
              ListItem() {
                Text(index.toString())
                  .width('100%')
                  .textAlign(TextAlign.Center)
              }
              .height(height)
              .align(Alignment.Center)
            }, (item: number, index: number) => JSON.stringify(item) + index)
          }
        }, (item: number[]) => JSON.stringify(item))
      }
      .height(this.listHeight)
      .width('100%')
    }
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-335
爬取时间: 2025-05-08 05:26:53
来源: Huawei Developer


在Row、Column、RelativeContainer组件中，width、height属性设置为'auto'表示自适应子组件。在TextInput组件中，width设置为'auto'表示自适应文本宽度。


flexBasis属性默认值为'auto'，表示组件在主轴方向上的基准尺寸为组件原本的大小。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-337
爬取时间: 2025-05-08 05:27:03
来源: Huawei Developer


问题场景


在一个外层ListA，分多个ListItem，每个ListItem中都是一个List，在内层List中使用LazyForEach，达到懒加载效果。如果设置外层ListA的每个ListItem 的高度情况下，内层List的LazyForEach会失效，会一次性都会加载出来。如果不设置外层ListA的每个ListItem 的高度情况下，内层List的 LazyForEach会起作用，但是有部分内层List的数据显示不完全。


解决措施


固定内层List高度。参考如下代码


```less
export class BaseDataSource<T> implements IDataSource {
  private readonly listeners: DataChangeListener[] = [];
  protected dataset: T[];


  constructor(dataset?: T[]) {
    this.dataset = dataset ?? [];
  }


  public resetDataset(dataset: T[]) {
    this.dataset = dataset;
    this.notifyDataReload();
  }


  public updateDataAt(index: number, data: T) {
    if (index >= 0 && index < this.dataset.length) {
      this.dataset[index] = data;
      this.notifyDataChange(index);
    }
  }


  public getDataset() {
    return this.dataset;
  }


  public totalCount(): number {
    return this.dataset.length;
  }


  public getData(index: number): T {
    return this.dataset[index];
  }


  /**
   * 通知LazyForEach组件需要重载所有子组件
   */
  notifyDataReload(): void {
    this.listeners.forEach(listener => {
      listener.onDataReloaded();
    })
  }


  /**
   * 通知LazyForEach组件需要在index对应索引处添加子组件
   * @param index
   */
  notifyDataAdd(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataAdd(index);
    })
  }


  /**
   * 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件
   * @param index
   */
  notifyDataChange(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataChange(index);
    })
  }


  /**
   * 通知LazyForEach组件需要在index对应索引处删除该子组件
   * @param index
   */
  notifyDataDelete(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataDelete(index);
    })
  }


  /**
   * 通知LazyForEach组件将from索引和to索引处的子组件进行交换
   * @param from
   * @param to
   */
  notifyDataMove(from: number, to: number): void {
    this.listeners.forEach(listener => {
      listener.onDataMove(from, to);
    })
  }


  //----------------------------------------------------------------------------------------------------
  // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听
  registerDataChangeListener(listener: DataChangeListener): void {
    if (this.listeners.indexOf(listener) < 0) {
      this.listeners.push(listener);
    }
  }


  // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听
  unregisterDataChangeListener(listener: DataChangeListener): void {
    const pos = this.listeners.indexOf(listener);
    if (pos >= 0) {
      this.listeners.splice(pos, 1);
    }
  }
}




class NewPosItemDataSource extends BaseDataSource<string> {
  private dataArray: string[] = [];


  public totalCount(): number {
    return this.dataArray.length;
  }


  public getData(index: number): string {
    return this.dataArray[index];
  }


  public addData(index: number, data: string): void {
    this.dataArray.splice(index, 0, data);
    this.notifyDataAdd(index);
  }


  public pushData(data: string): void {
    this.dataArray.push(data);
    this.notifyDataAdd(this.dataArray.length - 1);
  }
}


const bgColors: ResourceColor[] = [Color.Blue, Color.Gray];
const rowHeight = 60;


@Component
struct header {
  title: string = '';


  build() {
    Column() {
      Text(this.title)
        .width('100%')
        .height(40)
        .fontSize(14)
        .backgroundColor(Color.Yellow)
        .fontColor(Color.Blue)
        .textAlign(TextAlign.Center)
    }
  }
}


@Component
struct Itemcomponent {
  title: string = '';
  @Prop datas: string[];


  generateDataSource() {
    let datasource: NewPosItemDataSource = new NewPosItemDataSource();
    for (let index = 0; index < this.datas.length; index++) {
      const element = this.datas[index];
      datasource.pushData(element);
    }
    return datasource;
  }


  build() {
    Column() {
      header({ title: this.title })
      List() {
        LazyForEach(this.generateDataSource(), (data: string, index) => {
          ListItem() {
            Text(data)
              .width('100%')
              .fontSize(14)
              .backgroundColor(Color.White)
              .fontColor(bgColors[index % bgColors.length])
              .textAlign(TextAlign.Center)
          }
          .height(rowHeight)
        }, (data: string, index) => {
          console.log(`------- ${data + ' - ' + index.toString()}`);
          return data + ' - ' + index.toString();
        })
      }
      .layoutWeight(1)
      .scrollBar(BarState.Off)
      .cachedCount(10)
      .friction(1.25)
      .edgeEffect(EdgeEffect.None)
    }
  }
}


function generateData(pre: string, count: number) {
  let datas: string[] = [];
  for (let index = 0; index < count; index++) {
    const element = pre + '-' + index.toString();
    datas.push(element);
  }
  return datas;
}


@Entry
@Component
struct Index {
  @State message: string = 'Hello World';
  private scroll: Scroller = new Scroller();


  @Builder
  private mainListView() {
    List({ scroller: this.scroll }) {
      ListItem() {
        Itemcomponent({ title: 'A', datas: generateData('A', 200) })
      }
      // .height(40 + 200 * rowHeight) // 添加该高度属性后 内层list的内容区和可视区一样高 导致LazyForEach会失效


      ListItem() {
        Itemcomponent({ title: 'B', datas: generateData('B', 20) })
      }
      // .height(40 + 20 * rowHeight)  // 添加该高度属性后 内层list的内容区和可视区一样高 导致LazyForEach会失效
    }
    .divider({ strokeWidth: 10, color: Color.Gray })
    .height("100%")
    .width("100%")
    .scrollBar(BarState.Off)
    .edgeEffect(EdgeEffect.None)
  }


  build() {
    Column() {
      this.mainListView()
    }.width('100%')
    .height('100%')
    .backgroundColor(Color.White)
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-338
爬取时间: 2025-05-08 05:27:13
来源: Huawei Developer


问题现象


Marquee组件在文本滚动时，文本滚动到控件的开头，会造成大量空白，如何实现让文本末尾滚动到控件末尾时停止，避免空白出现。


解决措施


推荐使用Scroll代替跑马灯组件实现文字滚动。示例代码如下：


```less
@Entry
@Component
struct MarqueeScroll {
  @State textList: string[] = [
    'this is a test string1 this is a test string1',
    'this is a test string2 this is a test string2 this is a test string2',
    'this is a test string3 this is a test string3 this is a test string3 this is a test string3'
  ];
  @State count: number = 1;


  build() {
    Row() {
      Column() {
        myMarqueeCard({
          textList: $textList,
          updateList: () => {
            this.textList = [
              `这是测试数据${this.count++}这是测试数据${this.count++}`,
              `这是测试数据${this.count++}这是测试数据${this.count++}这是测试数据${this.count++}`,
              `这是测试数据${this.count++}这是测试数据${this.count++}这是测试数据${this.count++}这是测试数据${this.count++}`
            ];
          }
        })
      }
      .width('100%')
      .margin(20)
    }
    .height('100%')
  }
}


@Component
struct myMarqueeCard {
  @Link @Watch('handleNewList') textList: string[];
  @State list: string[] = [];
  scroller1: Scroller = new Scroller();
  scroller2: Scroller = new Scroller();
  scroller3: Scroller = new Scroller();
  updateList?: () => void;


  handleNewList() {
    console.info(JSON.stringify(this.textList));
  }


  build() {
    Column() {
      this.SingleText({ text: this.textList[0], scroller: this.scroller1 })
      this.SingleText({ text: this.textList[1], scroller: this.scroller2 })
      this.SingleText({ text: this.textList[2], scroller: this.scroller3 })
    }
  }


  @Builder
  SingleText($$: Tmp) {
    Scroll($$.scroller) {
      Row() {
        Text($$.text)
          .fontSize(30)
          .onAppear(() => {
            this.handleScroll($$.scroller);
          })
      }
    }
    .width(300)
    .scrollable(ScrollDirection.Horizontal)
    .enableScrollInteraction(false)
    .scrollBar(BarState.Off)


  }


  handleScroll(scroller: Scroller) {
    setInterval(() => {
      const curOffset: OffsetResult = scroller.currentOffset();
      scroller.scrollTo({
        xOffset: curOffset.xOffset + 50, yOffset: curOffset.yOffset, animation: {
          duration: 1000,
          curve: Curve.Linear
        }
      });
      if (scroller.isAtEnd()) {
        if (this.scroller1.isAtEnd() && this.scroller2.isAtEnd() && this.scroller3.isAtEnd()) {
          if (this.updateList) {
            this.scroller1.scrollTo({ xOffset: 0, yOffset: 0, animation: { duration: 0 } });
            this.scroller2.scrollTo({ xOffset: 0, yOffset: 0, animation: { duration: 0 } });
            this.scroller3.scrollTo({ xOffset: 0, yOffset: 0, animation: { duration: 0 } });
            this.updateList();
          }
        }
      }
    }, 500);
  }
}


class Tmp {
  text: string = '';
  scroller: Scroller = new Scroller();
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-339
爬取时间: 2025-05-08 05:27:23
来源: Huawei Developer


问题现象


Tabs组件嵌套Web组件滚动场景可能会出现以下问题：


解决措施


示例代码如下：


```less
import { webview } from '@kit.ArkWeb';


@Component
@Entry
struct TabWebScroll {
  @State flag: boolean = true; // 控制滑动页面进行页面切换
  private tabsController = new TabsController();
  private currentIndex: number = 0;
  private webviewController: webview.WebviewController = new webview.WebviewController();


  build() {
    Tabs({ barPosition: BarPosition.End, controller: this.tabsController }) {
      TabContent() {
        Web({ src: 'https://developer.huawei.com/consumer/cn/', controller: this.webviewController })
          .nestedScroll({
            // 设置嵌套滚动
            scrollForward: NestedScrollMode.PARENT_FIRST,
            scrollBackward: NestedScrollMode.SELF_FIRST
          })
      }
      .tabBar(this.tabBuilder('首页', 0))


      TabContent() {
        Column() {
          Text('发现')
        }
        .width('100%')
        .height('100%')
      }
      .tabBar(this.tabBuilder('发现', 1))


      TabContent() {
        Column() {
          Text('推荐')
        }
        .width('100%')
        .height('100%')
      }
      .tabBar(this.tabBuilder('推荐', 2))


      TabContent() {
        Column() {
          Text('我的')
        }
        .width('100%')
        .height('100%')
      }
      .tabBar(this.tabBuilder('我的', 3))
    }
    .onChange((index: number) => {
      this.currentIndex = index;
    })
    .scrollable(this.flag)
    .onAnimationEnd(() => {
      // 切换动画结束时触发该回调，设置web组件可以滑动
      this.webviewController.setScrollable(true);
    })
    .onGestureSwipe(() => {
      // 在页面跟手滑动过程中，逐帧触发该回调，设置tab页切换的时web页无法上下滑动
      this.webviewController.setScrollable(false);
    })
  }


  @Builder
  tabBuilder(title: string, targetIndex: number) {
    Column() {
      Text(title)
        .fontColor(this.currentIndex === targetIndex ? '#1698CE' : '#6B6B6B')
    }
    .width('100%')
    .height(50)
    .justifyContent(FlexAlign.Center)
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-340
爬取时间: 2025-05-08 05:27:32
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-341
爬取时间: 2025-05-08 05:27:42
来源: Huawei Developer


解决措施


可以使用窗口@ohos.window的keepKeyboardOnFocus接口，在窗口获焦时保留由其他窗口创建的软键盘，仅支持系统窗口与应用子窗口。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-343
爬取时间: 2025-05-08 05:27:52
来源: Huawei Developer


代码示例如下：


```typescript
@Entry
@Component
struct MaskDemo {
  private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];


  @Builder
  overlayBuilder() {
    Stack()
      .height('100%')
      .width('100%')
      .linearGradient({
        direction: GradientDirection.Bottom, // 渐变方向
        colors: [['#00FFFFFF', 0.0], ['#FFFFFFFF', 0.3]] // 数组末尾元素占比小于1时满足重复着色效果
      })
      .blendMode(BlendMode.DST_IN, BlendApplyType.OFFSCREEN)
      .hitTestBehavior(HitTestMode.None)
  }


  build() {
    Column() {
      List({ space: 20, initialIndex: 0 }) {
        ForEach(this.arr, (item: number) => {
          ListItem() {
            Text('' + item)
              .width('100%')
              .height(100)
              .fontSize(16)
              .textAlign(TextAlign.Center)
              .borderRadius(10)
              .backgroundColor(0xFFFFFF)
          }
          .onClick(() => {
            console.log('is click');
          })
        }, (item: string) => item)
      }
      .width('90%')
      .height('100%')
      .scrollBar(BarState.Off)
      .overlay(this.overlayBuilder())
      .blendMode(BlendMode.SRC_OVER, BlendApplyType.OFFSCREEN)
    }
    .width('100%')
    .height('100%')
    .backgroundColor(0xDCDCDC)
  }
}
```


实现效果：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160843.98925573094020494671445987829089:50001231000000:2800:524DA6C6A55C38FA74A2E9E441AC09E48094A743BD2F3E0A94F08330E4114FC0.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-344
爬取时间: 2025-05-08 05:28:02
来源: Huawei Developer


Tabs组件无法在tabBar中添加其它组件，可以通过自定义Tabs，实现在Tabs的tabBar中添加其他组件。


示例代码如下：


```less
import { componentUtils } from '@kit.ArkUI';


@Entry
@Component
struct TabsDemo {
  @State tabArray: Array<number> = [0, 1, 2];
  @State tabArrayVal: number = this.tabArray.length - 1;
  @State currentIndex: number = 0;
  @State animationDuration: number = 300;
  @State indicatorLeftMargin: number = 0;
  @State indicatorWidth: number = 0;
  private controller: TabsController = new TabsController();
  private tabsWidth: number = 0;


  // 单独的页签
  @Builder
  tab(tabName: string, tabItem: number, tabIndex: number) {
    Row({ space: 20 }) {
      Text(tabName).fontSize(18)
        .fontColor(tabItem === this.currentIndex ? Color.Red : Color.Black)
        .id(tabIndex.toString())
        .onAreaChange((oldValue: Area, newValue: Area) => {
          if (this.currentIndex === tabIndex && (this.indicatorLeftMargin === 0 || this.indicatorWidth === 0)) {
            if (newValue.position.x !== undefined) {
              let positionX = Number.parseFloat(newValue.position.x.toString());
              this.indicatorLeftMargin = Number.isNaN(positionX) ? 0 : positionX;
            }
            let width = Number.parseFloat(newValue.width.toString());
            this.indicatorWidth = Number.isNaN(width) ? 0 : width;
          }
        })
    }
    .justifyContent(FlexAlign.Center)
    .constraintSize({ minWidth: 35 })
    .width(80)
    .height(35)
    .borderRadius({
      topLeft: 10,
      topRight: 10
    })
    .onClick(() => {
      this.controller.changeIndex(tabIndex);
      this.currentIndex = tabIndex;
    })
  }


  build() {
    Column() {
      // 页签
      Stack({ alignContent: Alignment.TopStart }) {
        Scroll() {
          Row() {
            ForEach(this.tabArray, (item: number, index: number) => {
              this.tab('页签' + item, item, index);
            })
            Text('+')
              .width(36)
              .height(50)
              .fontSize(28)
              .borderRadius(5)
              .padding({
                left: 5,
                bottom: 2
              })
              .onClick(() => {
                this.tabArray.push(++this.tabArrayVal);
              })
          }
          .justifyContent(FlexAlign.SpaceBetween)
        }
        .align(Alignment.Start)
        .scrollable(ScrollDirection.Horizontal)
        .scrollBar(BarState.Off)
        .width('100%')


        Column()
          .width(this.indicatorWidth)
          .height(2)
          .backgroundColor(Color.Red)
          .borderRadius(2)
          .margin({
            left: this.indicatorLeftMargin,
            top: 38
          })
      }
      .width('100%')


      Tabs({ barPosition: BarPosition.Start, controller: this.controller }) {
        ForEach(this.tabArray, (item: number, index: number) => {
          TabContent() {
            Text('我是页面' + item + '的内容')
              .height(300)
              .width('100%')
              .fontSize(30)
              .textAlign(TextAlign.Center)
          }
          .backgroundColor(Color.Pink)
        })
      }
      .onAreaChange((oldValue: Area, newValue: Area) => {
        let width = Number.parseFloat(newValue.width.toString());
        this.tabsWidth = Number.isNaN(width) ? 0 : width;
      })
      .barWidth('100%')
      .barHeight(0)
      .width('100%')
      .height('100%')
      .backgroundColor('#F1F3F5')
      .animationDuration(this.animationDuration)
      .onChange((index: number) => {
        this.currentIndex = index; // 监听索引index的变化，实现页签内容的切换。
      })
      .onAnimationStart((index: number, targetIndex: number, event: TabsAnimationEvent) => {
        // 切换动画开始时触发该回调。下划线跟着页面一起滑动，同时宽度渐变。
        this.currentIndex = targetIndex;
        let targetIndexInfo = this.getTextInfo(targetIndex);
        this.startAnimateTo(this.animationDuration, targetIndexInfo.left, targetIndexInfo.width);
      })
      .onAnimationEnd((index: number, event: TabsAnimationEvent) => {
        // 切换动画结束时触发该回调。下划线动画停止。
        let currentIndicatorInfo = this.getCurrentIndicatorInfo(index, event);
        this.startAnimateTo(0, currentIndicatorInfo.left, currentIndicatorInfo.width);
      })
      .onGestureSwipe((index: number, event: TabsAnimationEvent) => {
        // 在页面跟手滑动过程中，逐帧触发该回调。
        let currentIndicatorInfo = this.getCurrentIndicatorInfo(index, event);
        this.currentIndex = currentIndicatorInfo.index;
        this.indicatorLeftMargin = currentIndicatorInfo.left;
        this.indicatorWidth = currentIndicatorInfo.width;
      })
    }
    .height('100%')
  }


  // 获取组件大小、位置、平移缩放旋转及仿射矩阵属性信息。
  private getTextInfo(index: number): Record<string, number> {
    let modePosition: componentUtils.ComponentInfo = componentUtils.getRectangleById(index.toString());
    return { 'left': px2vp(modePosition.windowOffset.x), 'width': px2vp(modePosition.size.width) };
  }


  private getCurrentIndicatorInfo(index: number, event: TabsAnimationEvent): Record<string, number> {
    let nextIndex = index;
    if (index > 0 && event.currentOffset > 0) {
      nextIndex--;
    } else if (index < 3 && event.currentOffset < 0) {
      nextIndex++;
    }
    let indexInfo = this.getTextInfo(index);
    let nextIndexInfo = this.getTextInfo(nextIndex);
    let swipeRatio = Math.abs(event.currentOffset / this.tabsWidth);
    // 页面滑动超过一半，tabBar切换到下一页。
    let currentIndex = swipeRatio > 0.5 ? nextIndex : index;
    let currentLeft = indexInfo.left + (nextIndexInfo.left - indexInfo.left) * swipeRatio;
    let currentWidth = indexInfo.width + (nextIndexInfo.width - indexInfo.width) * swipeRatio;
    return { 'index': currentIndex, 'left': currentLeft, 'width': currentWidth };
  }


  private startAnimateTo(duration: number, leftMargin: number, width: number) {
    animateTo({
      // 动画时长
      duration: duration,
      // 动画曲线
      curve: Curve.Linear,
      // 播放次数
      iterations: 1,
      // 动画模式
      playMode: PlayMode.Normal,
      onFinish: () => {
        console.info('play end');
      }
    }, () => {
      this.indicatorLeftMargin = leftMargin;
      this.indicatorWidth = width;
    })
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-346
爬取时间: 2025-05-08 05:28:12
来源: Huawei Developer


参考代码


```less
@Entry
@Component
struct HollowOutWithCanvas {
  @State circleCenterX: number = 0;
  @State circleCenterY: number = 0;
  @State circleRadius: number = 100;
  private settings: RenderingContextSettings = new RenderingContextSettings(true);
  private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);


  build() {
    Row() {
      Column() {
        Stack() {
          Image($r('app.media.startIcon'))
            .height(300)
          // 使用Canvas绘制遮罩覆盖在图片、相机等上面
          Canvas(this.context)
            .width('100%')
            .height('100%')
            .backgroundColor('#00000000')
            .onReady(() => {
              this.circleCenterX = this.context.width / 2;
              this.circleCenterY = this.context.height / 2;
              this.context.fillStyle = '#aa000000';
              // 绘制园形路径进行半透明填充
              this.context.beginPath();
              this.context.moveTo(0, 0);
              this.context.lineTo(0, this.context.height);
              this.context.lineTo(this.context.width, this.context.height);
              this.context.lineTo(this.context.width, 0);
              this.context.lineTo(0, 0);
              this.context.arc(this.circleCenterX, this.circleCenterY, this.circleRadius, 0, Math.PI * 2);
              this.context.fill();
              this.context.closePath();
            })
        }
        .width('1456px')
        .height('1456px')
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-347
爬取时间: 2025-05-08 05:28:21
来源: Huawei Developer


文本截断是按字截断。例如，英文以单词为最小单位进行截断，若需要以字母为单位进行截断，可在字母间添加零宽空格：\u200B。


从API 11开始，建议优先使用将wordBreak属性设置为WordBreak.BREAK_ALL的方式，来实现以字母为单位进行截断，示例代码如下：


```less
@Entry
@Component
struct TextMixException {
  @State text: string = '2年·VIP会员 3个月期·8GB·230mm·商品颜色';


  build() {
    RelativeContainer() {
      Text(this.text)
        .width(200)// 设置最大行数
        .maxLines(1)// 文本超长显示
        .textOverflow({ overflow: TextOverflow.Ellipsis })// 文本超长显示省略号
        .ellipsisMode(EllipsisMode.END)// 设置断行规则WordBreak.BREAK_ALL后实现字母为单位进行截断
        .wordBreak(WordBreak.BREAK_ALL)
        .textAlign(TextAlign.JUSTIFY)
        .backgroundColor(Color.Green)
        .fontSize(16)
    }
    .height('100%')
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-348
爬取时间: 2025-05-08 05:28:31
来源: Huawei Developer


可以使用显式动画animateTo,结合条件渲染if控制ListItem的内容区域的展开收起，示例代码如下：


```typescript
@Entry
@Component
struct ListCollapseExpand {
  private arr: number[] = [0, 1, 2, 3, 4, 5, 6];
  @State isContentShow: boolean = true;
  @State selectItem: number = 0;


  build() {
    Column() {
      List({ initialIndex: 0 }) {
        ForEach(this.arr, (item: number, index: number) => {
          ListItem() {
            Column() {
              Row() {
                Text(item.toString())
                Button(this.isContentShow && this.selectItem === item ? '收起' : '展开')
                  .onClick(() => {
                    animateTo({
                      duration: 300,
                      onFinish: () => {
                        console.info('animation end');
                      }
                    }, () => {
                      this.isContentShow = !this.isContentShow;
                      this.selectItem = item;
                    })
                  })
              }
              .width('100%')
              .justifyContent(FlexAlign.SpaceBetween)


              if (this.isContentShow && this.selectItem === item) {
                Text('这是内容区域')
                  .backgroundColor(Color.Gray)
                  .width('100%')
                  .height(100)
              }
            }
            .backgroundColor(0xFFFFFF)
            .width('100%')
            .padding({
              top: 12,
              bottom: 12
            })
            .margin({ top: 10 })
          }
        }, (item: string) => item.toString())
      }
      .scrollBar(BarState.Off)
      .height('100%')
      .width('100%')
    }
    .backgroundColor(0xF1F3F5)
    .padding(12)
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-349
爬取时间: 2025-05-08 05:28:41
来源: Huawei Developer


设置radius就可以改变Popup窗圆角大小，目前箭头颜色无法修改，只能通过popupColor设置气泡背景色，示例代码如下：


```typescript
@Entry
@Component
struct BindPopupDemo {
  @State handlePopup: boolean = false;
  @State customPopup: boolean = false;


  // popup构造器定义弹框内容
  @Builder
  popupBuilder() {
    Row({ space: 2 }) {
      Image($r('app.media.startIcon'))
        .width(24)
        .height(24)
        .margin({ left: -5 })
      Text('Custom Popup')
        .fontSize(10)
    }
    .width(100)
    .height(50)
    .padding(5)
  }


  build() {
    RelativeContainer() {
      Button('CustomPopupOptions')
        .onClick(() => {
          this.customPopup = !this.customPopup;
        })
        .bindPopup(this.customPopup, {
          builder: this.popupBuilder,
          radius: 30,
          popupColor: Color.Yellow,
          enableArrow: true,
          onStateChange: (e) => {
            if (!e.isVisible) {
              this.customPopup = false;
            }
          }
        })
    }
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-350
爬取时间: 2025-05-08 05:28:51
来源: Huawei Developer


可以尝试单独在webview组件前（同层）增加一个大小为0的组件来承载bindPopup。并且目前UX规范，针对边距有一个左右大小为7vp的偏移，以保证弹出菜单在屏幕范围内，具体可以参考以下代码：


```less
import { webview } from '@kit.ArkWeb';


@Entry
@Component
struct BindPopupOffset {
  controller: webview.WebviewController = new webview.WebviewController();
  private result: WebContextMenuResult | undefined = undefined;
  @State linkUrl: string = '';
  @State offsetX: number = 0;
  @State offsetY: number = 0;
  @State showMenu: boolean = false;


  @Builder
  MenuBuilder() {
    Menu() {
      MenuItem({
        content: '复制图片',
      })
        .width(100)
        .height(50)
        .onClick(() => {
          this.result?.copyImage();
          this.showMenu = false;
        })
      MenuItem({
        content: '剪切'
      })
        .width(100)
        .height(50)
        .onClick(() => {
          this.result?.cut();
          this.showMenu = false;
        })
    }
    .width(150)
    .backgroundColor('#eeeeee')
  }


  build() {
    Column() {
      Row()
        .width(0)
        .height(0)
        .position({ x: 0, y: 0 })
        .bindPopup(this.showMenu,
          {
            builder: this.MenuBuilder(),
            enableArrow: false,
            placement: Placement.LeftTop,
            targetSpace: 0,
            shadow: {
              radius: 0
            },
            offset: {
              x: this.offsetX - 7,
              y: this.offsetY
            },
            mask: false,
            onStateChange: (e) => {
              if (!e.isVisible) {
                this.showMenu = false;
                this.result!.closeContextMenu();
              }
            }
          })


      Web({ src: $rawfile('index.html'), controller: this.controller })//触发自定义弹窗
        .onContextMenuShow((event) => {
          if (event) {
            this.result = event.result;
            this.showMenu = true;
            this.offsetX = Math.max(px2vp(event?.param.x() ?? 0) - 0, 0);
            this.offsetY = Math.max(px2vp(event?.param.y() ?? 0) - 0, 0);
          }
          return true;
        })
    }
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-351
爬取时间: 2025-05-08 05:29:01
来源: Huawei Developer


可以使用promptAction结合ComponentContent实现自定义分享弹窗，示例代码如下：


```typescript
import { ComponentContent, PromptAction } from '@kit.ArkUI';


let promptAction: PromptAction | undefined = undefined;
let componentContent: ComponentContent<Params> | undefined = undefined;


class Params {
  applicationSharings: string[] = [];
  sharings: string[] = [];


  constructor(applicationSharings: string[], sharings: string[] = []) {
    this.applicationSharings = applicationSharings;
    this.sharings = sharings;
  }
}


@Builder
function buildText($$: Params) {
  Column() {
    Text('share')
    Grid() {
      ForEach($$.applicationSharings, (item: string, index) => {
        GridItem() {
          Column() {
            Image($r('app.media.app_icon'))
              .height(50)
              .width(50)
            Text(item)
              .fontSize(10)
          }
        }
      })
    }
    .height(100)
    .rowsGap(20)
    .columnsGap(20)
    .scrollBar(BarState.Off)
    .rowsTemplate('1fr')


    Grid() {
      ForEach($$.sharings, (item: string, index) => {
        GridItem() {
          Column() {
            Image($r('app.media.app_icon'))
              .height(50)
              .width(50)
            Text(item)
              .fontSize(10)
          }
        }
      })
    }
    .height(100)
    .rowsGap(20)
    .columnsGap(20)
    .scrollBar(BarState.Off)
    .rowsTemplate('1fr')


    Button('取消')
      .width('100%')
      .fontColor(Color.Black)
      .backgroundColor(Color.White)
      .onClick(() => {
        promptAction?.closeCustomDialog(componentContent);
      })
  }
  .backgroundColor('#FFF0F0F0')
  .width('90%')
  .height('30%')
  .borderRadius(10)
}


@Entry
@Component
struct CustomShareDialog {
  @State applicationSharings: string[] =
    ['share1', 'share2', 'share3', 'share4', 'share5', 'share6', 'share7', 'share8'];
  @State sharings: string[] = ['share1', 'share2', 'share3', 'share4', 'share5', 'share6', 'share7', 'share8'];


  build() {
    Row() {
      Column() {
        Button('click me')
          .onClick(() => {
            let uiContext = this.getUIContext();
            promptAction = uiContext.getPromptAction();
            let contentNode = new ComponentContent(uiContext, wrapBuilder(buildText),
              new Params(this.applicationSharings, this.sharings));
            componentContent = contentNode;
            promptAction.openCustomDialog(contentNode);
          })
      }
      .width('100%')
      .height('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-352
爬取时间: 2025-05-08 05:29:11
来源: Huawei Developer


可以在onComplete回调事件中处理Badge有无数量的逻辑，图片数据加载成功和解码成功时均触发该回调，示例代码如下：


```less
@Entry
@Component
struct BadgeDemo {
  @State message: string = 'Hello World';
  @State sizes: string = '0';
  @State isDnd: boolean = false;


  build() {
    Row() {
      Text(this.message)
        .fontSize(50)
        .fontWeight(FontWeight.Bold)
        .onClick(() => {
          this.isDnd = !this.isDnd;
        })
      Stack() {
        Badge({
          value: '',
          position: {
            x: 40,
            y: 0
          },
          style: {
            badgeSize: 15,
            badgeColor: Color.Red
          }
        }) {
          Image($r('app.media.startIcon'))
            .width(50)
            .height(50)
            .onComplete(() => {
              this.isDnd = !this.isDnd;
            })
        }
        .visibility(this.isDnd ? Visibility.Visible : Visibility.None)


        Badge({
          count: 98,
          maxCount: 99,
          position: { x: 30, y: 0 },
          style: {
            fontSize: 15,
            badgeSize: 15,
            badgeColor: Color.Red
          }
        }) {
          Image($r('app.media.startIcon'))
            .width(50)
            .height(50)
            .onComplete(() => {
              this.isDnd = !this.isDnd;
            })
        }
        .visibility(this.isDnd ? Visibility.None : Visibility.Visible)
      }
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-353
爬取时间: 2025-05-08 05:29:20
来源: Huawei Developer


可以使用hitTestBehavior结合setTimeout来解决，示例代码如下：


```typescript
@Entry
@Component
struct ToggleDemo {
  @State isDarkMode: boolean = false;


  build() {
    Column() {
      Column() {
        Toggle({ type: ToggleType.Switch, isOn: $$this.isDarkMode })
          .onChange((isOn: boolean) => {
            console.info('Toggle.onChange:isOn' + isOn);
            this.isDarkMode = isOn;
            getContext(this).getApplicationContext().setColorMode(this.isDarkMode ? 0 : 1);
          })
      }
      // 设置hitTestBehavior属性为HitTestMode.Block，阻塞Toggle组件响应事件。
      .hitTestBehavior(HitTestMode.Block)
      .onClick(() => {
        setTimeout(() => {
          this.isDarkMode = !this.isDarkMode;
        }, 1500);
      })
    }
    .width('100%')
    .height('100%')
    .padding(32)
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-354
爬取时间: 2025-05-08 05:29:30
来源: Huawei Developer


目前有两种方案可参考：


```less
 getContext(component).resourceManager.getColorSync($r('app.color.xxx').id);
```


```less
"metadata": [
  {
    "name": "ContextResourceConfigLoadFromParentTemp",
    "value": "true"
  }
]
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-355
爬取时间: 2025-05-08 05:29:40
来源: Huawei Developer


可以使用“Any-Latn”先将汉字内容进行音译转换成拼音，然后使用“Latin-ASCII”去掉音标，示例代码如下：


```typescript
import { i18n } from '@kit.LocalizationKit';


@Entry
@Component
struct RemovePinyin {
  @State message: string = 'Hello World';


  build() {
    RelativeContainer() {
      Text(this.message)
        .fontSize(50)
        .onClick(() => {
          let transliterator1 = i18n.Transliterator.getInstance('Any-Latn');
          let res = transliterator1.transform('中国');


          let transliterator2 = i18n.Transliterator.getInstance('Latin-ASCII');
          let res2 = transliterator2.transform(res);
          console.info('res2: ' + res2);
        })
    }
    .height('100%')
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-356
爬取时间: 2025-05-08 05:29:50
来源: Huawei Developer


使用Stack容器作为父容器，子容器使用Image来实现自定义一个passwordIcon，此时即可对Image组件的位置、大小、颜色做出更改，示例代码如下：


```less
@Entry
@Component
struct TextInputDemo {
  @State text: string = '';
  @State changeType: InputType = InputType.Password;
  @State isVisible: boolean = false;
  @State changeState: boolean = false;
  controller: TextInputController = new TextInputController();


  build() {
    Stack() {
      TextInput({ text: this.text, controller: this.controller })
        .type(this.changeType)
        .placeholderFont({
          size: 16,
          weight: 400
        })
        .showPasswordIcon(false)
        .width(336)
        .height(56)
        .padding({ right: 50 })
        .onChange((value: string) => {
          this.text = value;
        })
      //Image覆盖passwordIcon实现
      Image($r(this.isVisible ? 'app.media.startIcon' : 'app.media.invisible'))
        .margin({ left: 280 })
        .backgroundColor('#E7E8EA')
        .width(20)
        .height(20)
        .onClick(() => {
          this.changeState = !this.changeState;
          this.isVisible = !this.isVisible;
          if (this.changeState) {
            this.changeType = InputType.Normal;
          } else {
            this.changeType = InputType.Password;
          }
        })
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#F1F3F5')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-357
爬取时间: 2025-05-08 05:30:00
来源: Huawei Developer


问题描述


如果发生状态栏和页面内容重叠问题，可以从以下方向进行分析适配。


1、状态栏应该隐藏，实际上未隐藏，例如图片预览场景。


2、界面布局内容未对状态栏进行避让。


问题一解决措施：


参考代码：


设置全屏模式，缓存窗口对象


```less
// EntryAbility.ets


onWindowStageCreate(windowStage: window.WindowStage): void {
  // Main window is created, set main page for this ability
  hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');


  windowStage.loadContent('pages/ImagePreview', (err) => {
    if (err.code) {
      hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
      return;
    }
    hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');


    let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口
    // 1. 设置窗口全屏
    let isLayoutFullScreen = true;
    windowClass.setWindowLayoutFullScreen(isLayoutFullScreen);
    // 2. 缓存window窗口对象
    AppStorage.setOrCreate('windowClass', windowClass);
  });
}
```


```less
import { window } from '@kit.ArkUI';


@Entry
@Component
struct ImagePreviewExample {
  windowClass: window.Window = AppStorage.get<window.Window>('windowClass') as window.Window;
  @State visible: Visibility = Visibility.None;
  @State scaleValue: number = 1;
  @State pinchValue: number = 1;
  @State pinchX: number = 0;
  @State pinchY: number = 0;
  @State count: number = 0;
  @State offsetX: number = 0;
  @State offsetY: number = 0;
  @State positionX: number = 0;
  @State positionY: number = 0;


  build() {
    Stack() {
      Row() {
        Column() {
          Image($r('app.media.startIcon'))
            .width(100)
            .height(100)
            .onClick(() => {
              if (this.visible === Visibility.Visible) {
                this.visible = Visibility.None;
              } else {
                this.visible = Visibility.Visible;
                this.windowClass.setSpecificSystemBarEnabled('status', false);
              }
            })
        }
        .width('100%')
        .justifyContent(FlexAlign.Center)
        .alignItems(HorizontalAlign.Center)
      }
      .height('100%')


      Text('')
        .onClick(() => {
          if (this.visible === Visibility.Visible) {
            this.windowClass.setSpecificSystemBarEnabled('status', true);
            this.visible = Visibility.None;
          } else {
            this.visible = Visibility.Visible;
          }
        })
        .width('100%')
        .height('100%')
        .opacity(0.16)// 透明度
        .backgroundColor(Color.Black)
        .visibility(this.visible)


      Column() {
        Image($r('app.media.startIcon'))
          .width(300)
          .height(300)
          .draggable(false)
          .visibility(this.visible)
          .scale({
            x: this.scaleValue,
            y: this.scaleValue,
            z: 1
          })
          .translate({
            x: this.offsetX,
            y: this.offsetY,
            z: 0
          })
          .gesture(
            GestureGroup(GestureMode.Parallel,
              PinchGesture({ fingers: 2 })
                .onActionUpdate((event?: GestureEvent) => {
                  if (event) {
                    this.scaleValue = this.pinchValue * event.scale;
                    this.pinchX = event.pinchCenterX;
                    this.pinchY = event.pinchCenterY;
                  }
                })
                .onActionEnd(() => {
                  this.pinchValue = this.scaleValue;
                }),
              PanGesture()
                .onActionUpdate((event?: GestureEvent) => {
                  if (event) {
                    this.offsetX = this.positionX + event.offsetX;
                    this.offsetY = this.positionY + event.offsetY;
                  }
                })
                .onActionEnd(() => {
                  this.positionX = this.offsetX;
                  this.positionY = this.offsetY;
                })
            )
          )
      }
    }
    .backgroundColor(Color.White)
    .height('100%')
    .width('100%')
  }
}
```


问题二解决措施：


参考代码


```typescript
// EntryAbility.ets


onWindowStageCreate(windowStage: window.WindowStage): void {
  // Main window is created, set main page for this ability
  hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');


  windowStage.loadContent('pages/AvoidStatusBar', (err) => {
    if (err.code) {
      hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
      return;
    }
    hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');


    let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口
    // 1. 设置窗口全屏
    let isLayoutFullScreen = true;
    windowClass.setWindowLayoutFullScreen(isLayoutFullScreen);
    // 2. 缓存window窗口对象
    AppStorage.setOrCreate('windowClass', windowClass);


    // 3. 获取布局避让遮挡的区域
    let type = window.AvoidAreaType.TYPE_SYSTEM;
    let avoidArea = windowClass.getWindowAvoidArea(type);
    let statusBar =px2vp( avoidArea.topRect.height); // 获取状态栏的高度
    AppStorage.setOrCreate('statusBar', statusBar);
  });
}
```


```less
@Entry
@Component
struct AvoidStatusBar {
  statusBar: number = AppStorage.get<number>('statusBar') as number;


  build() {


      Column() {
        Row() {
          Text('ROW1')
            .fontSize(40)
        }
        .backgroundColor(Color.Orange)
        .padding(20)


        Row() {
          Text('ROW2')
            .fontSize(40)
        }
        .backgroundColor(Color.Orange)
        .padding(20)


        Row() {
          Text('ROW3')
            .fontSize(40)
        }
        .backgroundColor(Color.Orange)
        .padding(20)


        Row() {
          Text('ROW4')
            .fontSize(40)
        }
        .backgroundColor(Color.Orange)
        .padding(20)


        Row() {
          Text('ROW5')
            .fontSize(40)
        }
        .backgroundColor(Color.Orange)
        .padding(20)


        Row() {
          Text('ROW6')
            .fontSize(40)
        }
        .backgroundColor(Color.Orange)
        .padding(20)
      }
      .width('100%')
      .height('100%')
      .alignItems(HorizontalAlign.Center)
      .justifyContent(FlexAlign.SpaceBetween)
      .padding({ top: this.statusBar }) // 此处margin或padding具体数值在实际中应与状态栏区域高度保持一致
      .backgroundColor('#008000')
    }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-358
爬取时间: 2025-05-08 05:30:10
来源: Huawei Developer


问题描述


为了避免状态栏颜色和背景重合，需要根据状态栏以及内容区域的颜色进行沉浸式适配，可以有以下几种方式：


解决措施


```less
// EntryAbility.ets


onWindowStageCreate(windowStage: window.WindowStage): void {
  windowStage.loadContent('pages/Example', (err, data) => {
    if (err.code) {
      return;
    }
    // 设置全窗颜色和应用元素颜色一致
    windowStage.getMainWindowSync().setWindowBackgroundColor('#008000');
  });
}
```


```less
@Entry
@Component
struct Example {
  build() {
    Column() {
      Row() {
        Text('Top Row')
          .fontSize(40)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
      .backgroundColor('#F08080')
      // 设置顶部绘制延伸到状态栏
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])


      Row() {
        Text('ROW2')
          .fontSize(40)
      }
      .backgroundColor(Color.Orange)
      .padding(20)


      Row() {
        Text('ROW3')
          .fontSize(40)
      }
      .backgroundColor(Color.Orange)
      .padding(20)


      Row() {
        Text('ROW4')
          .fontSize(40)
      }
      .backgroundColor(Color.Orange)
      .padding(20)


      Row() {
        Text('ROW5')
          .fontSize(40)
      }
      .backgroundColor(Color.Orange)
      .padding(20)


      Row() {
        Text('Bottom Row')
          .fontSize(40)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
      .backgroundColor(Color.Orange)
      // 设置底部绘制延伸到导航条
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
    }
    .width('100%')
    .height('100%')
    .alignItems(HorizontalAlign.Center)
    .backgroundColor('#008000')
    .justifyContent(FlexAlign.SpaceBetween)
  }
}
```


方式三：手动设置状态栏的颜色：


实现步骤：


获取并缓存窗口对象


```less
// EntryAbility.ets


onWindowStageCreate(windowStage: window.WindowStage): void {
  // Main window is created, set main page for this ability
  hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');


  windowStage.loadContent('pages/Index', (err) => {
    if (err.code) {
      hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
      return;
    }
    hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
    let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口
    // 1. 设置窗口全屏
    let isLayoutFullScreen = true;
    windowClass.setWindowLayoutFullScreen(isLayoutFullScreen);
    // 2. 缓存window窗口对象
    AppStorage.setOrCreate('windowClass', windowClass);
  });
}
```


打开页面时设置状态栏属性，设置自己需要的沉浸式颜色。


```less
import { window } from '@kit.ArkUI';


@Entry
@Component
struct CommonTopBar {
  @State message: string = 'Hello World';


  aboutToAppear() {
    // 获取当前应用窗口
    let windowClass = AppStorage.get<window.Window>('windowClass') as window.Window;
    // 将状态栏和导航栏的背景色设置为跟应用窗口相同的颜色
    windowClass.setWindowSystemBarProperties({
      // 颜色属性为ARGB，将蒙尘设置为0%使其透明
      // 导航栏颜色
      navigationBarColor: '#fd121de5',
      // 状态栏颜色
      statusBarColor: '#ff0ad9c2',
      // 状态栏文字颜色
      statusBarContentColor: '#fff1e50a'
    })
  }


  build() {
    RelativeContainer() {
      Text(this.message)
        .id('PageHelloWorld')
        .fontSize(50)
        .fontWeight(FontWeight.Bold)
        .alignRules({
          center: {
            anchor: '__container__',
            align: VerticalAlign.Center
          },
          middle: {
            anchor: '__container__',
            align: HorizontalAlign.Center
          }
        })
    }
    .height('100%')
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-359
爬取时间: 2025-05-08 05:30:20
来源: Huawei Developer


问题描述


应用在深色模式下，可能会出现状态栏颜色与深色模式效果重叠，导致无法看清的问题。


解决措施


关于深色模式适配请参考深色模式适配。


参考代码如下：


```less
// resources/dark/element/color.json
{
  "color": [
    {
      "name": "status_bar",
      "value": "#000000"
    }
  ]
}
```


```less
// EntryAbility.ets


onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
  hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
  // 缓存当前设备的颜色模式
  AppStorage.setOrCreate('currentColorMode', this.context.config.colorMode);
}


onWindowStageCreate(windowStage: window.WindowStage): void {
  // Main window is created, set main page for this ability
  hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');


  windowStage.loadContent('pages/Index', (err) => {
    if (err.code) {
      hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
      return;
    }
    hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
    let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口
    // 1. 设置窗口全屏
    let isLayoutFullScreen = true;
    windowClass.setWindowLayoutFullScreen(isLayoutFullScreen);
    // 2. 缓存窗口对象
    AppStorage.setOrCreate('windowClass', windowClass);
  });
}
```


```less
// EntryAbility.ets


// 监听系统配置变更
onConfigurationUpdate(newConfig: Configuration): void {
  let newColorMode = newConfig.colorMode;
  let currentColorMode = AppStorage.get<ConfigurationConstant.ColorMode>('currentColorMode');
  if (newColorMode === currentColorMode) {
    return;
  }
  // 更新缓存中的颜色模式
  AppStorage.setOrCreate('currentColorMode', newConfig.colorMode);
}
```


```less
import { window } from '@kit.ArkUI';
import { ConfigurationConstant } from '@kit.AbilityKit';


@Entry
@Component
struct SysDarkMode {
  @State message: string = '页面布局';
  @StorageProp('currentColorMode') @Watch('onColorModeChange') currentColorMode: number =
    ConfigurationConstant.ColorMode.COLOR_MODE_LIGHT;


  aboutToAppear(): void {
    this.onColorModeChange();
  }


  onColorModeChange(): void {
    // 获取当前应用窗口
    let windowClass = AppStorage.get<window.Window>('windowClass') as window.Window;


    if (this.currentColorMode === ConfigurationConstant.ColorMode.COLOR_MODE_LIGHT) {
      // 当前为浅色模式
      //设置字体为黑色
      windowClass.setWindowSystemBarProperties({
        // 状态栏文字颜色
        statusBarContentColor: '#000000'
      });
    } else if (this.currentColorMode === ConfigurationConstant.ColorMode.COLOR_MODE_DARK) {
      // 当前为深色模式
      //设置字体为白色
      windowClass.setWindowSystemBarProperties({
        // 状态栏文字颜色
        statusBarContentColor: '#FFFFFF'
      });
    }
  }


  build() {
    Column() {
      Row()
        .width('100%')
        .height(100)
        .backgroundColor($r('app.color.status_bar'))
      // 页面布局
      Text(this.message)
        .fontSize(50)
        .fontColor(Color.Red)
        .fontWeight(FontWeight.Bold)
        .alignRules({
          center: {
            anchor: '__container__',
            align: VerticalAlign.Center
          },
          middle: {
            anchor: '__container__',
            align: HorizontalAlign.Center
          }
        })
        .layoutWeight(1)
    }
    .height('100%')
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-360
爬取时间: 2025-05-08 05:30:30
来源: Huawei Developer


问题描述


进入全屏时调用了setWindowLayoutFullscreen接口，导致状态栏隐藏，再回到之前页面，如何显示状态栏。


解决措施


退出页面时，需要调用setWindowSystemBarProperties设置状态栏为显示状态,再调用setWindowLayoutFullscreen接口显示状态栏。


参考代码


首先获取窗口对象


```less
// EntryAbility.ets


onWindowStageCreate(windowStage: window.WindowStage): void {
  // Main window is created, set main page for this ability
  hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');


  windowStage.loadContent('pages/GridImage', (err) => {
    if (err.code) {
      hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
      return;
    }
    hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');


    let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口
    // 1. 设置窗口全屏
    let isLayoutFullScreen = true;
    windowClass.setWindowLayoutFullScreen(isLayoutFullScreen);
    // 2. 缓存window窗口对象
    AppStorage.setOrCreate('windowClass', windowClass);
  });
}
```


```less
import { window } from '@kit.ArkUI';


@Entry
@Component
struct GridImage {
  @State message: string = 'Hello World';
  @State isVisible: boolean = true;
  @State isVisibleButton: boolean = true;
  data: number[] = [];
  windowClass = AppStorage.get<window.Window>('windowClass') as window.Window;


  aboutToAppear(): void {
    for (let i = 0; i < 40; i++) {
      this.data.push(i);
    }
  }


  build() {
    Stack() {
      Grid() {
        ForEach(this.data, (item: number, index: number) => {
          GridItem() {
            Image($r('app.media.startIcon'))
              .width('100%')
              .objectFit(ImageFit.Cover)
              .onClick(() => {
                let isLayoutFullScreen = true;
                this.windowClass.setWindowLayoutFullScreen(isLayoutFullScreen);
                this.windowClass.setSpecificSystemBarEnabled('status', false);
                this.windowClass.setSpecificSystemBarEnabled('navigationIndicator', false);
                this.isVisible = !this.isVisible;
              })
          }
          .aspectRatio(1)
        }, (item: number, index: number) => JSON.stringify(item) + index)
      }
      .visibility(this.isVisible ? Visibility.Visible : Visibility.None)
      .columnsTemplate('1fr 1fr 1fr 1fr')
      .rowsGap(2)
      .columnsGap(2)
      .height('100%')
      .width('100%')


      Image($r('app.media.startIcon'))
        .objectFit(ImageFit.Contain)
        .width('100%')
        .visibility(this.isVisible ? Visibility.None : Visibility.Visible)
        .onClick(() => {
          let isLayoutFullScreen = false;
          this.windowClass.setSpecificSystemBarEnabled('status', true);
          this.windowClass.setSpecificSystemBarEnabled('navigationIndicator', true);
          this.windowClass.setWindowLayoutFullScreen(isLayoutFullScreen);
          this.isVisible = !this.isVisible;
        })
    }
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-361
爬取时间: 2025-05-08 05:30:40
来源: Huawei Developer


Button组件的labelStyle可以设置Button组件label文本和字体的样式。示例代码如下：


```less
@Entry
@Component
struct ButtonSetTheMaximumAndMinimumFontSizes {
  @State text: string = 'hello';
  @State widthShortSize: number = 300;


  build() {
    Row() {
      Button(this.text)
        .width(this.widthShortSize)
        .height(100)
        .labelStyle({
          overflow: TextOverflow.Clip,
          maxLines: 1,
          minFontSize: 20,
          maxFontSize: 40,
          font: {
            size: 30,
            weight: FontWeight.Bolder,
            family: 'cursive',
            style: FontStyle.Italic
          }
        })
    }
  }
}
```


参考链接


Button


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-362
爬取时间: 2025-05-08 05:30:50
来源: Huawei Developer


```less
// module.json5
{
  "module": {
    ...
    ,
    "abilities": [
      {
        "name": "EntryAbility",
        ...,
        "orientation":"unspecified"  // 未定义方向模式，由系统判定
      }
    ]
  }
}
```


```typescript
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { display, window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';


export default class EntryAbility extends UIAbility {
  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
  }


  onDestroy(): void {
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
  }


  onWindowStageCreate(windowStage: window.WindowStage): void {
    // Main window is created, set main page for this ability
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');


    windowStage.loadContent('pages/Index', (err) => {
      if (err.code) {
        hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
        return;
      }
      hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
    });


    windowStage.getMainWindow().then((windowObj) => {
      let orientation = display.getFoldStatus() === display.FoldStatus.FOLD_STATUS_EXPANDED ?
        window.Orientation.AUTO_ROTATION : window.Orientation.PORTRAIT;
      windowObj?.setPreferredOrientation(orientation);


      // 监听折叠屏的展开态或折叠态
      display.on('foldStatusChange', (foldStatus: display.FoldStatus) => {
        orientation = foldStatus === display.FoldStatus.FOLD_STATUS_EXPANDED ? window.Orientation.AUTO_ROTATION :
          window.Orientation.PORTRAIT;
        try {
          windowObj?.setPreferredOrientation(orientation, (err: BusinessError) => {
            const errCode: number = err.code;
            if (errCode) {
              console.error(`Failed to set window orientation. Cause code: ${err.code}, message: ${err.message}`);
              return;
            }
            console.info('Succeeded in setting window orientation.');
          });
        } catch (exception) {
          console.error(`Failed to set window orientation. Cause code: ${exception.code}, message: ${exception.message}`);
        }
      })
    });
  }


  onWindowStageDestroy(): void {
    // Main window is destroyed, release UI related resources
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
  }


  onForeground(): void {
    // Ability has brought to foreground
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
  }


  onBackground(): void {
    // Ability has back to background
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-364
爬取时间: 2025-05-08 05:30:59
来源: Huawei Developer


可以通过ArkUI的NodeController模块，创建控制器管理绑定的NodeContainer组件，通过NodeController的rebuild()方法进行回调的触发，从而实现组件动态上下树，具体请参考如下代码：


```less
import { FrameNode, NodeController, BuilderNode } from '@kit.ArkUI';


declare class Params {
  text: string;
}


@Builder
function textInputBuilder(params: Params) {
  Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.SpaceEvenly }) {
    Text(params.text)
      .fontSize(12)
    Button(`This is a Button`, { type: ButtonType.Normal, stateEffect: true })
      .fontSize(12)
      .borderRadius(8)
      .backgroundColor(0x317aff)
  }
  .height(100)
  .width(200)
}


class MyNodeController extends NodeController {
  private rootNode: FrameNode | null = null; // 创建根节点
  private textInputBuilder: WrappedBuilder<[Params]> = wrapBuilder(textInputBuilder);
  private buildNode: BuilderNode<[Params]> | null = null;


  makeNode(uiContext: UIContext): FrameNode | null {
    this.rootNode = new FrameNode(uiContext); // 根节点初始化
    this.buildNode = new BuilderNode(uiContext);
    const rootRenderNode = this.rootNode.getRenderNode(); // 获取渲染节点
    if (rootRenderNode !== null) {
      this.buildNode.build(this.textInputBuilder, { text: 'This is a Text' });
      rootRenderNode.appendChild(this.buildNode.getFrameNode()?.getRenderNode()); // 在渲染节点后添加新的子节点
      console.info('rootRenderNode.appendChild');
    }
    return this.rootNode;
  }
}


@Entry
@Component
struct RenderNode_pages {
  private myNodeController: MyNodeController = new MyNodeController();


  build() {
    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Start, justifyContent: FlexAlign.SpaceEvenly }) {
      NodeContainer(this.myNodeController)
        .borderWidth(1)
        .height(500)
        .width(330)


      Button(`Adding a Node`, { type: ButtonType.Normal, stateEffect: true })
        .fontSize(12)
        .borderRadius(8)
        .backgroundColor(0x317aff)
        .onClick(() => {
          this.myNodeController.rebuild();
        })
    }
    .padding({ left: 35, right: 35, top: 35 })
    .height(500)
    .width(500)
  }
}
```


参考链接


rebuild：通知NodeContainer组件重新回调makeNode方法


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-365
爬取时间: 2025-05-08 05:31:09
来源: Huawei Developer


根据业务逻辑需要，使用parallelGesture或者priorityGesture绑定，解决自定义手势和系统手势之间冲突的关系。


系统默认手势效果保留，且自定义的LongPressGesture和panGesture手势也能响应，就用parallelGesture绑定。


参考代码：


```less
@Entry
@Component
struct Index {
  build() {
    Column() {
      Image($r('app.media.app_icon'))
        .width('80%')
        .parallelGesture(GestureGroup(GestureMode.Exclusive,
          TapGesture({ count: 2, fingers: 1 })
            .onAction(() => {
              console.log('TapGesture--双击');
            }),
          TapGesture({ count: 1, fingers: 1 })
            .onAction(() => {
              console.log('TapGesture--单击');
            }),
          LongPressGesture({ repeat: true })
            .onAction(() => {
              console.log('LongPressGesture--长按');
            }),
          PanGesture()
            .onActionStart((event: GestureEvent | undefined) => {
              console.info('PanGesture--拖拽');
            })
        ))
    }
    .height('100%')
    .width('100%')
  }
}
```


参考链接


绑定手势方法


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-366
爬取时间: 2025-05-08 05:31:19
来源: Huawei Developer


可以通过在页面onBackPress()生命周期中隐藏子窗口。示例如下：


```less
onWindowStageCreate(windowStage: window.WindowStage): void {
  // 创建应用子窗口
  let windowClass: window.Window | undefined = undefined;
  windowStage.createSubWindow('mySubWindow', (err: BusinessError, data) => {
    if (err.code) {
      console.error(`Failed to create the subwindow. Cause code: ${err.code}, message: ${err.message}`);
      return;
    }
    windowClass = data;
    console.info('Succeeded in creating the subwindow. Data: ' + JSON.stringify(data));
    // 子窗口创建成功后，设置子窗口的位置、大小及相关属性等
    windowClass.moveWindowTo(300, 300);
    windowClass.resize(200, 200);
    windowClass.setWindowTouchable(true);
    // 为子窗口加载对应的目标页面
    windowClass.setUIContent('pages/Index',(err: BusinessError) => {
      if (err.code) {
        console.error(`Failed to load the content. Cause code: ${err.code}, message: ${err.message}`);
        return;
      }
      if (windowClass) {
        windowClass.setWindowBackgroundColor('#64b38c');
      }
    });
    (windowClass as window.Window).showWindow();
  })
  // ...
}
```


```less
import { window } from '@kit.ArkUI';


@Entry
@Component
struct CloseWindowDemo {
  @State message: string = 'Hello World';


  onBackPress(): boolean | void {
    console.log('被触发了');
    window.findWindow('mySubWindow').destroyWindow();
    return true;
  }


  build() {
    RelativeContainer() {
      Text(this.message)
        .id('HelloWorld')
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
        .alignRules({
          center: { anchor: '__container__', align: VerticalAlign.Center },
          middle: { anchor: '__container__', align: HorizontalAlign.Center }
        })
    }
    .height('100%')
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-367
爬取时间: 2025-05-08 05:31:29
来源: Huawei Developer


使用getTarget接口获取状态管理框架代理前的原始对象。


参考示例如下：


```typescript
import { UIUtils } from '@kit.ArkUI';


@Observed
class Info {
  name: string = 'Tom';
}


@Entry
@Component
struct GetTargetDemo {
  @State info: Info = new Info();


  build() {
    Column() {
      Text(`info.name: ${this.info.name}`)
      Button('更改代理对象的属性')
        .onClick(() => {
          this.info.name = 'Alice'; // Text组件能够刷新
        })
      Button('更改原始对象的属性')
        .onClick(() => {
          let rawInfo: Info = UIUtils.getTarget(this.info);
          rawInfo.name = 'Bob'; // Text组件不能刷新
        })
    }
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-368
爬取时间: 2025-05-08 05:31:39
来源: Huawei Developer


解决措施


旋转涉及@ohos.window和@ohos.display两个模块，处于不同进程。由于旋转完后display的更新时间早于window的更新时间（display旋转时直接宽高互换，提前可预知；window要等ArkUI布局完成才能确定窗口大小，耗时长），故在display触发变化时获取窗口信息会存在时序问题（窗口信息还未更新完成，此时使用Window实例获取到的还是原来的宽高）。应用可以通过display.on('change')接口监听显示设备变化，在callback中通过Display实例获取屏幕的width、height、orientation等信息。


错误示例


```less
// display先更新
display.on('change', async (data) => {
  let newDisplay: display.Display = display.getDefaultDisplaySync();
  console.info('Orientation: ' + newDisplay.orientation);
  let windowClass: window.Window = await window.getLastWindow(this.context);
  // window后更新，获取到的还是原来的宽高
  let windowProperties = windowClass.getWindowProperties();
  console.info('Width: ' + windowProperties.windowRect.width +
    ', height: ' + windowProperties.windowRect.height);
  // 请确保已获取到相关Window实例，即windowClass
  windowClass.getWindowAvoidArea(window.AvoidAreaType.TYPE_CUTOUT);
});
```


正确示例


```less
display.on('change', (data) => {
  console.info('Succeeded in enabling the listener for display changes. Data: ' +
  JSON.stringify(data));
  let newDisplay: display.Display = display.getDefaultDisplaySync();
  console.info('Orientation: ' + newDisplay.orientation + 'width: ' +
  newDisplay.width + ', height: ' + newDisplay.height);
});
```


参考链接


display.on('change')


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-369
爬取时间: 2025-05-08 05:31:48
来源: Huawei Developer


以折叠屏形态变化时触发为示例，可以在EntryAbility.ets文件中通过on('avoidAreaChange')接口监听窗口系统规避区域的变化，在callback中获取avoidAreaChange信息，并通过Display实例获取屏幕方向orientation等信息。


```typescript
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { display, window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';


export default class EntryAbility extends UIAbility {
  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
  }


  onDestroy(): void {
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
  }


  onWindowStageCreate(windowStage: window.WindowStage): void {
    // Main window is created, set main page for this ability
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');


    windowStage.loadContent('pages/Index', (err) => {
      if (err.code) {
        hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
        return;
      }
      hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
    });


    let windowClass: window.Window | undefined = undefined;
    try {
      window.getLastWindow(this.context, (err: BusinessError, data) => {
        const errCode: number = err.code;
        if (errCode) {
          console.error(`Failed to obtain the top window. Cause code: ${err.code}, message: ${err.message}`);
          return;
        }
        windowClass = data;
        console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));
        // 请确保已获取到相关Window实例，即windowClass
        windowClass.on('avoidAreaChange', async (data) => {
          console.info('Succeeded in enabling the listener for avoid area changes. Type: ' + JSON.stringify(data.type) + ', area ' + JSON.stringify(data.area));
          let newDisplay: display.Display = display.getDefaultDisplaySync();
          console.info('---Orientation: ' + newDisplay.orientation);
        });
      });
    } catch (exception) {
      console.error(`Failed to obtain the top window. Cause code: ${exception.code}, message: ${exception.message}`);
    }
  }


  onWindowStageDestroy(): void {
    // Main window is destroyed, release UI related resources
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
  }


  onForeground(): void {
    // Ability has brought to foreground
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
  }


  onBackground(): void {
    // Ability has back to background
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
  }
}
```


参考链接


开启当前窗口系统规避区变化的监听显示设备当前显示的方向枚举


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-370
爬取时间: 2025-05-08 05:31:58
来源: Huawei Developer


解决措施


沉浸式页面开发通常分为以下两步：


```less
import { UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';


export default class EntryAbility extends UIAbility {
  onWindowStageCreate(windowStage: window.WindowStage) {
    // 1.获取应用主窗口。
    let windowClass: window.Window | undefined = undefined;
    windowStage.getMainWindow().then(windowClass => {
      console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(windowClass));
      // 2.设置窗口全屏，实现沉浸式效果。
      windowClass.setWindowLayoutFullScreen(true).then(() => {
        console.info('Succeeded in setting the window layout to full-screen mode.');
      }).catch((e: BusinessError) => {
        console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(e));
      })
    }).catch((err: BusinessError) => {
      console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err));
    })
    // 3.为沉浸式窗口加载对应的目标页面。
    windowStage.loadContent("pages/Index", (err) => {
      if (err.code) {
        console.error('Failed to load the content. Cause:' + JSON.stringify(err));
        return;
      }
      console.info('Succeeded in loading the content.');
    });
  }
};
```


```less
import { UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';


export default class EntryAbility extends UIAbility {
  onWindowStageCreate(windowStage: window.WindowStage) {
    // 1.获取应用主窗口。
    let windowClass: window.Window | undefined = undefined;
    windowStage.getMainWindow().then(windowClass => {
      console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(windowClass));
      // 2.设置窗口全屏，实现沉浸式效果。
      windowClass.setWindowLayoutFullScreen(true).then(() => {
        console.info('Succeeded in setting the window layout to full-screen mode.');
      }).catch((e: BusinessError) => {
        console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(e));
      })
    }).catch((err: BusinessError) => {
      console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err));
    })
    // 3.为沉浸式窗口加载对应的目标页面。
    windowStage.loadContent("pages/Index", (err) => {
      if (err.code) {
        console.error('Failed to load the content. Cause:' + JSON.stringify(err));
        return;
      }
      console.info('Succeeded in loading the content.');
    });
  }
};
```


```less
@Entry
@Component
struct Example {
  build() {
    Column() {
      Row() {
        Text('Top Row')
          .fontSize(40)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
      .backgroundColor('#F08080')
      // 设置顶部绘制延伸到状态栏
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])


      Row() {
        Text('ROW2')
          .fontSize(40)
      }
      .backgroundColor(Color.Orange)
      .padding(20)


      Row() {
        Text('ROW3')
          .fontSize(40)
      }
      .backgroundColor(Color.Orange)
      .padding(20)


      Row() {
        Text('ROW4')
          .fontSize(40)
      }
      .backgroundColor(Color.Orange)
      .padding(20)


      Row() {
        Text('ROW5')
          .fontSize(40)
      }
      .backgroundColor(Color.Orange)
      .padding(20)


      Row() {
        Text('Bottom Row')
          .fontSize(40)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
      .backgroundColor(Color.Orange)
      // 设置底部绘制延伸到导航条
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
    }
    .width('100%')
    .height('100%')
    .alignItems(HorizontalAlign.Center)
    .backgroundColor('#008000')
    .justifyContent(FlexAlign.SpaceBetween)
  }
}
```

1.  由于避让区本身是有内容展示，如状态栏中的电量、时间等系统信息，或是手势交互，如导航条点击或上滑，在实现应用页面沉浸式效果后，往往会和避让区域产生UI元素的遮挡、视觉上的违和或交互上的冲突等问题，开发者可以针对不同场景选择以下方式对避让区和应用页面进行适配。

```less
import { UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';


export default class EntryAbility extends UIAbility {
  onWindowStageCreate(windowStage: window.WindowStage) {
    // 1.获取应用主窗口。
    let windowClass: window.Window | undefined = undefined;
    windowStage.getMainWindow().then(windowClass => {
      console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(windowClass));
      // 2.设置窗口全屏，实现沉浸式效果。
      windowClass.setWindowLayoutFullScreen(true).then(() => {
        console.info('Succeeded in setting the window layout to full-screen mode.');
      }).catch((e: BusinessError) => {
        console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(e));
      })
    }).catch((err: BusinessError) => {
      console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err));
    })
    // 3.为沉浸式窗口加载对应的目标页面。
    windowStage.loadContent("pages/Index", (err) => {
      if (err.code) {
        console.error('Failed to load the content. Cause:' + JSON.stringify(err));
        return;
      }
      console.info('Succeeded in loading the content.');
    });
  }
};
```


```less
@Entry
@Component
struct Example {
  build() {
    Column() {
      Row() {
        Text('Top Row')
          .fontSize(40)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
      .backgroundColor('#F08080')
      // 设置顶部绘制延伸到状态栏
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])


      Row() {
        Text('ROW2')
          .fontSize(40)
      }
      .backgroundColor(Color.Orange)
      .padding(20)


      Row() {
        Text('ROW3')
          .fontSize(40)
      }
      .backgroundColor(Color.Orange)
      .padding(20)


      Row() {
        Text('ROW4')
          .fontSize(40)
      }
      .backgroundColor(Color.Orange)
      .padding(20)


      Row() {
        Text('ROW5')
          .fontSize(40)
      }
      .backgroundColor(Color.Orange)
      .padding(20)


      Row() {
        Text('Bottom Row')
          .fontSize(40)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
      .backgroundColor(Color.Orange)
      // 设置底部绘制延伸到导航条
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
    }
    .width('100%')
    .height('100%')
    .alignItems(HorizontalAlign.Center)
    .backgroundColor('#008000')
    .justifyContent(FlexAlign.SpaceBetween)
  }
}
```

- 使用Window.setWindowSystemBarEnable()方法或Window.setSpecificSystemBarEnabled()方法设置状态栏和导航栏的显隐。
- 使用Window.setWindowSystemBarProperties()方法设置状态栏和导航栏的样式。
- 使用Window.getWindowAvoidArea()方法获取避让区域的高度，据此设置应用页面内容的上下padding实现避让状态栏和导航栏。
- 使用Display.getCutoutInfo()方法获取挖孔区域宽高和位置信息，设置对应避让元素的margin实现挖孔区避让。

参考链接


沉浸式页面开发实践


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-371
爬取时间: 2025-05-08 05:32:08
来源: Huawei Developer


aspectRatio在布局的时候起两个作用：

- 第一个作用是和其他属性一起共同计算组件的约束以测量尺寸。
- 第二个作用是在组件测量完尺寸之后确保仍然遵守宽高比。

在布局过程中，父组件提供的约束由父组件的规格决定，子组件如何利用约束由子组件的规格决定。父组件给出约束后，aspectRatio和开发者设置的其他属性（如size、margin、constraintSize等）会共同影响约束数值，然后子组件才会基于这一处理过的约束测量自身尺寸。


示例代码


```less
@Entry
@Component
struct VideoAdaptPage {
  build() {
    Column() {
      Column() {
        Video({})
          .layoutWeight(1)
          .borderRadius(12)
          .clip(true)
          .aspectRatio(1)
          .loop(true)
          .autoPlay(true)
          .muted(true)
          .margin({
            left: 20,
            top: 20,
            right: 20,
          })
      }
    }.height(2000)
  }
}
```


上述代码中，Column子元素为垂直方向排列，有高度约束无宽度约束，示例代码中为了方便数值计算，给外层Column固定了高度为2000，以下Column均为内层。

- Column受高度约束2000、宽度约束NA。
- Column向Video传递高度约束2000、宽度约束NA。
- aspectRatio作用，Video受高度约束2000，宽度约束2000。
- margin作用，Video受高度约束1980，宽度约束1960。
- aspectRatio作用，Video测量尺寸得高度1960，宽度1960。
- Column被子组件撑起，Column测量尺寸得高度1980，宽度2000。

由于Column的宽度约束不起效果，在交叉轴上允许子组件画到容器外，在该状态下，Video的实际宽度还是1960，但是只有1080能显示在屏幕上。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-372
爬取时间: 2025-05-08 05:32:17
来源: Huawei Developer


CustomSpan作为最小单位的组件，若需实现特定功能，建议在多个CustomSpan上分别进行。若坚持在同一CustomSpan上实现，可从点击事件回调的ClickEvent中，依据属性判断实际点击位置，从而做出差异化响应。示例代码如下：


```less
import { promptAction } from '@kit.ArkUI';


@Entry
@Component
struct Index {
  controller: RichEditorController = new RichEditorController();
  option: RichEditorOptions = { controller: this.controller };


  @Builder
  comment() {
    Row() {
      Text() {
        Span('123123123')
        ImageSpan($r('app.media.startIcon')).width(20).height(20)
        Span('ggggggggggggggggggggggxxxxxxxxxxxxxxxxxxxxxxx')
      }
      .maxLines(1)
      .wordBreak(WordBreak.BREAK_ALL)
      .textOverflow({ overflow: TextOverflow.Ellipsis })
      .constraintSize({
        maxWidth: '90%'
      })


      Image($r('app.media.startIcon'))
        .width(25)
        .height(25)
        .onClick(() => {
          promptAction.showToast({
            message: '点我删除'
          })
        })
    }
    .width('100%')
    .align(Alignment.Center)
    .padding({
      top: 5,
      bottom: 5
    })
    .borderRadius(20)
    .backgroundColor(Color.Gray)
  }


  build() {
    Column() {
      Column() {
        RichEditor(this.option)
          .onReady(() => {
            this.controller.addBuilderSpan(() => this.comment())
          })
          .borderWidth(1)
          .borderColor(Color.Green)
          .width('100%')
          .height('30%')
      }
      .borderWidth(1)
      .borderColor(Color.Red)
      .width('100%')
      .height('70%')
    }
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-373
爬取时间: 2025-05-08 05:32:27
来源: Huawei Developer


两者的区别是，调用13~16时会临时旋转到指定方向，且前后台切换时窗口方向保持，而调用8~10或12前后台切换时窗口方向不会保持。


场景举例：


| 名称  | 值  | 可旋转方向  | 是否跟随传感器自动旋转  | 是否受旋转开关控制  |
| --- | --- | --- | --- | --- |
| AUTO_ROTATION_RESTRICTED  | 8  | 横屏、竖屏、反向竖屏、反向横屏  | 是  | 是  |
| AUTO_ROTATION_PORTRAIT_RESTRICTED  | 9  | 竖屏、反向竖屏  | 是  | 是  |
| AUTO_ROTATION_LANDSCAPE_RESTRICTED  | 10  | 横屏、反向横屏  | 是  | 是  |
| AUTO_ROTATION_UNSPECIFIED  | 12  | 受系统判定  | 是  | 是  |
| USER_ROTATION_PORTRAIT  | 13  | 受系统判定  | 是  | 是  |
| USER_ROTATION_LANDSCAPE  | 14  | 受系统判定  | 是  | 是  |
| USER_ROTATION_PORTRAIT_INVERTED  | 15  | 受系统判定  | 是  | 是  |
| USER_ROTATION_LANDSCAPE_INVERTED  | 16  | 受系统判定  | 是  | 是  |

名称


值


可旋转方向


是否跟随传感器自动旋转


是否受旋转开关控制


AUTO_ROTATION_RESTRICTED


8


横屏、竖屏、反向竖屏、反向横屏


是


是


AUTO_ROTATION_PORTRAIT_RESTRICTED


9


竖屏、反向竖屏


是


是


AUTO_ROTATION_LANDSCAPE_RESTRICTED


10


横屏、反向横屏


是


是


AUTO_ROTATION_UNSPECIFIED


12


受系统判定


是


是


USER_ROTATION_PORTRAIT


13


受系统判定


是


是


USER_ROTATION_LANDSCAPE


14


受系统判定


是


是


USER_ROTATION_PORTRAIT_INVERTED


15


受系统判定


是


是


USER_ROTATION_LANDSCAPE_INVERTED


16


受系统判定


是


是


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-input-method-framework
爬取时间: 2025-05-08 05:32:36
来源: Huawei Developer

- 输入法开发（IME）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ime-kit
爬取时间: 2025-05-08 05:32:46
来源: Huawei Developer

- 光标跟随相关接口

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ime-1
爬取时间: 2025-05-08 05:32:56
来源: Huawei Developer


在输入法应用中可以使用inputMethodEngine (输入法服务）模块的keyboardDelegate.on('cursorContextChange')接口，订阅光标变化事件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-data-and-files
爬取时间: 2025-05-08 05:33:06
来源: Huawei Developer

- 本地数据库管理
- 本地文件管理
- 文件预览（Preview）
- 媒体文件管理（Media Library）
- PDF预览和编辑（PDF）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkdata-kit
爬取时间: 2025-05-08 05:33:16
来源: Huawei Developer

- 如何将PixelMap的数据存储到数据库中
- 多个相同BundleName的HAP包，使用preference数据如何共享
- 关于数据库存储的位置，以及存储的区别
- 卡片开发中如何实现数据持久化
- 如何从数据库中获得特定类型的文件列表
- 如何使用Sqlite全文检索能力
- 如何获知Sqlite支持版本
- 通过RdbStore.query()获取resultSet对象，出现resultSet的rowCount返回结果为-1
- 如何读取本地/预制数据库
- 用sqlite开发时，怎么保证数据库同一时间只能支持一个写操作？怎么创建索引？
- 数据库查询失败 14800007
- RdbStore多线程安全注意事项
- 如何通过谓词查询方式获取数据
- 数据库batchInsert和单个事务insert效率问题
- 如果需要保存多张表，是创建一个数据库保存多张表还是创建多个数据库，每个数据库只保存一张表？使用的原则是什么？
- relationalStore.getRdbStore 执行多次，参数相同，获得的是同一个数据库对象吗？
- 是否可以创建一个单例，一直持有数据库对象？这样有没有性能影响？
- 应用的数据库db文件的目录的绝对路径
- 关系型数据库RDB支持哪些搜索能力
- 创建KVManager时bundleName必须是本应用的包名吗？
- 分布式对象必须要把默认obj的属性的每一个项值都设置undefined否则都会倒灌
- setsessionId加入组网和on启动监听前后设置的区别
- @ohos.data.preferences在App退出重启后，持久化数据丢失
- 非UI页面使用用户首选项时context如何获取
- 如何实现同步方式调用数据库接口？
- 首选项错误码：code:"401” err: Error: Parameter error. The type of 'value' must be ValueType. 如何排查问题
- 如何查看或导出持久化数据？
- 如何获知数据存储沙箱路径？
- 插入数据之后，RDB数据库的wal文件体积异常
- 用户首选项是线程安全的吗
- 为什么在关系型数据库中调用deleteRdbStore函数后并未真实删除数据库，对数据库的操作依旧可用
- HarmonyOS应用数据存储仍采用沙箱机制，各个APP有自己数据可见范围，为什么不将各APP产生的数据统一存储（同一个目录或者DB下）
- 数据存储方案如何选择？
- 跨模块、跨进程时如何保证正常读取首选项中数据？
- 数据管理如何保证数据安全？
- relationalStore是线程安全的吗
- 通过用户首选项实现数据持久化之后，如果App更新版本，之前首选项的数据是否会保留
- ArkData StoreConfig.customDir配置不生效
- 如何将数据库数据内置到App
- @ohos.data.distributedKVStore接口中的deleteKVStore，第一个参数appId需要传递什么值
- 关于对relationalStore.RdbStore的使用问题：如何查询数据库，需要开一个子线程吗
- ValuesBucket是否有可动态添加字段的方式

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-3
爬取时间: 2025-05-08 05:33:25
来源: Huawei Developer


PixelMap应该被转换成相应的ArrayBuffer再放进数据库。


参考链接


readPixelsToBuffer


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-4
爬取时间: 2025-05-08 05:33:35
来源: Huawei Developer


preference保存数据的时候保存在ApplicationContext中，可以使各个hap数据互通。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-5
爬取时间: 2025-05-08 05:33:44
来源: Huawei Developer


问题现象

- 使用ArkTS建立的数据库，数据存放在哪里？也就是database.db文件在哪里？
- 关系型数据库和轻量级存储的区别？

解决措施

- 存储地址会在database目录名下。
- 关系型数据库和轻量级存储的区别可参考下方文档。

参考链接


应用文件目录与应用文件路径


应用数据持久化概述


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-6
爬取时间: 2025-05-08 05:33:54
来源: Huawei Developer


数据持久化方式包括用户首选项、键值型数据库、关系型数据库。

- 用户首选项（Preferences）：应用存入数据到Preferences实例后，可以使用flush()方法实现数据持久化。
- 键值型数据库（KV-Store）：调用put()方法向键值数据库中插入数据。
- 关系型数据库（RelationalStore）：获取到RdbStore后，调用insert()接口插入数据。

参考链接


用户首选项


键值型数据库


关系型数据库


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-7
爬取时间: 2025-05-08 05:34:04
来源: Huawei Developer


DataSharePredicates是开发者通过DataShare查询数据库中的数据所使用的筛选条件，经常被应用在更新数据、删除数据和查询数据中。谓词的接口函数与数据库的筛选条件一一对应。


参考链接


@ohos.data.dataSharePredicates (数据共享谓词)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-9
爬取时间: 2025-05-08 05:34:13
来源: Huawei Developer


解决措施


没有提供直接的接口，可以通过执行sql语句实现相应功能。


executeSql：执行包含指定参数但不返回值的SQL语句。


querySql：根据指定SQL语句查询数据库中的数据。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-10
爬取时间: 2025-05-08 05:34:23
来源: Huawei Developer


当前SQLite版本号："3.40.1"，SQLite的版本是HarmonyOS系统内置好的, 有封装好的RDB接口，不能随意引用最新版本。


对于数据库操作不建议使用SQLite，建议使用框架提供的RDB接口，@ohos.data.relationalStore基于SQLite组件提供了一套完整的对本地数据库进行管理的机制，对外提供了一系列的增、删、改、查等接口，也可以直接运行用户输入的SQL语句来满足复杂的场景需要。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-11
爬取时间: 2025-05-08 05:34:32
来源: Huawei Developer


返回结果-1表示查询失败。


以下只是一种可能：


如果RdbPredicates对象传入一个错误的表名，然后调用query接口，得到resultset并不为空，也不会抛出异常，会在对resultset对象操作的时候触发异常。


ROWCOUNT == 0: 有表没数据


ROWCOUNT == -1:没有表


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-12
爬取时间: 2025-05-08 05:34:41
来源: Huawei Developer


解决措施


```less
import { fileIo, ReadOptions } from '@kit.CoreFileKit';
import { resourceManager } from '@kit.LocalizationKit';
import { relationalStore } from '@kit.ArkData';


let context = getContext(this);
let RDBDirectory = getContext(this).getApplicationContext().databaseDir;
let resource = getContext(this).resourceManager;


function saveFileToCache(file: resourceManager.RawFileDescriptor, dbName: string) {
  // 创建缓存文件(当前是覆盖式创建)
  let cFile = RDBDirectory + '/entry/rdb/' + dbName;
  let cacheFile = fileIo.openSync(cFile, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);


  // 读取缓冲区大小
  let bufferSize = 30000;
  let buffer = new ArrayBuffer(bufferSize); //创建buffer缓冲区


  // 要copy的文件的offset
  let currentOffset = file.offset;


  let readOption: ReadOptions = {
    offset: currentOffset, //期望读取文件的位置。可选，默认从当前位置开始读
    length: bufferSize //每次期望读取数据的长度。可选，默认缓冲区长度
  };


  // 后面len会一直减，直到没有
  while (true) {
    // 读取buffer容量的内容
    let readLength = fileIo.readSync(file.fd, buffer, readOption);
    // 写入buffer容量的内容
    fileIo.writeSync(cacheFile.fd, buffer, { length: readLength }); //写到cacheFile里
    // 判断后续内容 修改读文件的参数
    // buffer没读满代表文件读完了
    if (readLength < bufferSize) {
      break;
    }
    if (readOption.offset != undefined) {
      readOption.offset += readLength;
    }
  }
  console.log('Copy Success!!!')
  fileIo.close(cacheFile);
}


function INIT() {
  // 创建数据库沙箱目录
  try {
    let dirPath = RDBDirectory + '/entry';
    fileIo.mkdirSync(dirPath);
    dirPath = dirPath + '/rdb';
    fileIo.mkdirSync(dirPath);
  } catch (error) {
    console.error(`mkdir rdbPath failed, error code: ${error.code}, message: ${error.message}.`);
  }


  //数据库名称
  let dbName: string = 'Company.db';


  //读取rawfile目录下db文件
  try {
    resource.getRawFd('rdb/' + dbName, (error, value) => {
      if (error != null) {
        console.log(`callback getRawFd failed error code: ${error.code}, message: ${error.message}.`);
      } else {
        console.info(value.length.toString());
        saveFileToCache(value, dbName);
      }
    });
  } catch (error) {
    console.error(`callback getRawFd failed, error code: ${error.code}, message: ${error.message}.`);
  }
}
```


```less
function getRDB(): relationalStore.RdbStore | undefined {
  let result: relationalStore.RdbStore | undefined = undefined;
  const STORE_CONFIG: relationalStore.StoreConfig = {
    name: 'Company.db',
    securityLevel: relationalStore.SecurityLevel.S1
  };


  relationalStore.getRdbStore(context, STORE_CONFIG, (err, store) => {
    if (err) {
      console.error(`Failed to get RdbStore. Code:${err.code}, message:${err.message}`);
      return;
    } else {
      console.info(`Succeeded in getting RdbStore.`);
    }
    result = store;
  })
  return result;
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-14
爬取时间: 2025-05-08 05:34:51
来源: Huawei Developer


可以通过使用事务来保证数据库在同一时间只能支持一个写操作。创建索引参考sqlite创建方式：


1.定义SQL语句的常量


const SQL_CREATE_TABLE = 'CREATE TABLE IF NOT EXISTS EMPLOYEE (ID INTEGER PRIMARY KEY AUTOINCREMENT,NAME TEXT NOT NULL,AGE INTEGER,SALARY REAL)';


const CREATE_INDEX ='CREATE INDEX idx_name ON EMPLOYEE (NAME)'；


2.使用executeSql执行包含指定参数但不返回值的SQL语句


this.rdbStore.executeSql(SQL_CREATE_TABLE);


this.rdbStore.executeSql(CREATE_INDEX);


参考链接


beginTransaction


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-15
爬取时间: 2025-05-08 05:34:59
来源: Huawei Developer


问题现象


使用store.querySql可以得到 20 条结果，但是进行 resultSet.isColumnNull 时报错，报错信息如下：


[nodict]::[PrepareStep()-sqlite_shared_result_set.cpp:42]: StoreSession BeginStepQuery fail : not select sql !


[nodict]::[GetColumnIndex()-abs_result_set.cpp:334]: Failed to GetAllColumnNames, ret is 14800007


[nodict]::[GetColumnIndex()-napi_result_set.cpp:474]: IsAtLastRow failed code:14800007 columnName:-1


[nodict]::[PrepareStep()-sqlite_shared_result_set.cpp:42]: StoreSession BeginStepQuery fail : not select sql !


[nodict]::[GetColumnCount()-abs_result_set.cpp:308]: Failed to GetAllColumnNames, ret is 14800007


[nodict]::[IsColumnNull()-napi_result_set.cpp:503]: throw error: code = 14800000 , message = Inner error. Inner code is 8


[nodict][ecmascript] Pending exception before IsMixedDebugEnabled called in line:3200, exception details as follows:


[nodict]Error: Inner error. Inner code is 8


代码如下：


```less
async query( ) { 
  const STORE_CONFIG: relationalStore.StoreConfig = { 
  name: “NetMonitor.db”, 
  securityLevel: relationalStore.SecurityLevel.S1}; 
  let rdbStore: relationalStore.RdbStore = await relationalStore.getRdbStore(context, STORE_CONFIG); 
  let sql = 'SELECT * FROM net_monitor ORDER BY id desc LIMIT 20; 
  let resultSet = await rdbStore.querySql(sql) 
  let uuid = this.getString(resultSet, column_uuid)  // 报错 
} 
private getString(resultSet: relationalStore.ResultSet, columnName: string): string | undefined { 
let isColumnNull = resultSet.isColumnNull(resultSet.getColumnIndex(columnName)); 
if (isColumnNull){ 
  return undefined 
 } else { 
  return resultSet.getString(resultSet.getColumnIndex(columnName)) 
 } 
}
```


解决措施


isColumnNull：检查当前行中指定列的值是否为null。


ResultSet：提供用户调用关系型数据库查询接口之后返回的结果集合。


请先转到结果集中需要查询的行数后，再使用isColumnNull，如ResultSet.goToFirstRow()转到结果集的第一行。


参考链接


ResultSet


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-16
爬取时间: 2025-05-08 05:35:09
来源: Huawei Developer


1、RDB开库后有4个读连接，支持多线程读；由于只有1个写连接，每次只允许一个线程对数据库进行修改。当多线程尝试获取写连接时，只有一个线程可以获取到，未释放时，其他线程只能等待，超时2s将会报错14800048，即空闲连接数已用尽。


2、多个线程同时操作同一对象，如果一个线程劫持了这个对象，那么其他线程使用就有问题了。


3、多线程中，任何一个线程都不要去开启事务，会有风险。事务是作用在整个数据库的，如果在线程1中开启事务，但是在提交之前，线程2去插入数据并查询这条数据，那么就会查询不到。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-17
爬取时间: 2025-05-08 05:35:19
来源: Huawei Developer


getEntries()可以使用谓词查询，根据谓词查询的方式批量获取value，如使用like，unlike，isnull等方法。


参考代码如下：


```less
import { BusinessError } from '@kit.BasicServicesKit';
import { distributedKVStore } from '@kit.ArkData';


let kvStore: undefined | distributedKVStore.SingleKVStore = undefined;


@Entry
@Component
export struct ReadingTheLocalDatabase {
  build() {
    Row() {
      Column({ space: 20 }) {
        Button('创建数据库')
          .fontSize(20)
          .fontWeight(FontWeight.Bold)
          .onClick(async () => {
            try {
              let name = new distributedKVStore.FieldNode('name'); // 创建FieldNode对象
              name.type = distributedKVStore.ValueType.STRING; // 指定节点类型对应的数据类型为string
              name.nullable = false; // 节点数据不能为空
              name.default = 'cake'; // 默认值


              let schema1 = new distributedKVStore.Schema(); // 创建Schema对象
              schema1.root.appendChild(name); // 添加子节点
              schema1.indexes = ['$.name']; // 定义索引字段
              // 创建KVManager对象
              let kvManager = distributedKVStore.createKVManager({
                bundleName: 'TEST_CRASH_APP',
                context: getContext(this) as Context
              });
              // 创建并获取分布式键值数据库
              await kvManager.getKVStore('storeIds', {
                createIfMissing: true,
                backup: false,
                encrypt: false,
                autoSync: false,
                schema: schema1,
                kvStoreType: distributedKVStore.KVStoreType.SINGLE_VERSION,
                securityLevel: distributedKVStore.SecurityLevel.S2
              }).then((store: distributedKVStore.SingleKVStore) => {
                kvStore = store;
              }).catch((err: BusinessError) => {
                console.info(`getKVStore error is: ${err.code}, msg is: ${err.message}`);
              })
              if (kvStore === undefined) {
                return;
              }
              let entries: distributedKVStore.Entry[] = [];
              for (let i = 0; i < 10; i++) {
                let ent: distributedKVStore.Entry = {
                  key: 'test' + i,
                  value: {
                    type: distributedKVStore.ValueType.STRING,
                    value: '{"name":"cake"}'
                  }
                }
                entries.push(ent);
              }
              // 批量插入键值对到数据库中
              kvStore.putBatch(entries)
                .then((data) => {
                  console.info('Succeeded in putting Batch');
                })
                .catch((err: BusinessError) => {
                  console.info(`putBatch error is: ${err.code}, msg is: ${err.message}`);
                })
            } catch (e) {
              console.info(`putBatch e is: ${e.code}, msg is: ${e.message}`);
            }
          })


        Button('like查询')
          .fontSize(20)
          .onClick(() => {
            try {
              if (kvStore === undefined) {
                return;
              }
              // 使用谓词查询具有与指定字符串值相似的指定字段，并获取与指定Query对象匹配的键值对列表
              kvStore.getEntries(new distributedKVStore.Query().like('$.name', 'c%'))
                .then((value) => {
                  for (let i = 0; i < value.length; i++) {
                    console.info('key:' + value[i].key + 'value : ' + JSON.stringify(value[i].value))
                  }
                })
                .catch((err: BusinessError) => {
                  console.info(`getEntries error is: ${err.code}, msg is: ${err.message}`);
                })
            } catch (e) {
              console.info(`getEntries e is: ${e.code}, msg is: ${e.message}`);
            }
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-18
爬取时间: 2025-05-08 05:35:29
来源: Huawei Developer


事务insert无法达到batchInsert一样的效率，事务insert要100次，batchInsert只需要insert一次。另外batchInsert该接口内部有使用事务。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-19
爬取时间: 2025-05-08 05:35:38
来源: Huawei Developer


通常情况下，创建一个数据库保存多张表更为合适。如果每个表都创建一个数据库，会导致数据库数量过多，不方便管理和维护，更多的数据库链接，也会更消耗资源。另外如果有多表联合等场景也会更加复杂。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-20
爬取时间: 2025-05-08 05:35:48
来源: Huawei Developer


多次执行，参数相同，获取的是同一个数据库对象。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-21
爬取时间: 2025-05-08 05:35:57
来源: Huawei Developer


可以创建一个单例，一直持有数据库对象，对性能基本没有影响。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-22
爬取时间: 2025-05-08 05:36:07
来源: Huawei Developer


绝对路径：/data/app/el2/100/database/(bundleName)/entry/rdb


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-23
爬取时间: 2025-05-08 05:36:17
来源: Huawei Developer


SQL查询：SQLite 支持标准的 SQL 查询语法，可以执行 SELECT、INSERT、UPDATE、DELETE 等操作。


索引：SQLite 允许在列上创建索引，以提高查询性能。可以使用 CREATE INDEX 语句在 SQLite 中创建索引。


连接查询：SQLite 支持多个表之间的连接查询，可以使用 JOIN 关键字来实现表的关联查询。


全文搜索：SQLite 从版本 FTS3 开始支持全文搜索功能，您可以使用全文搜索扩展来实现对文本数据的搜索和匹配。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-24
爬取时间: 2025-05-08 05:36:27
来源: Huawei Developer


bundleName没有限制必须是本应用包名，但是closeKVStore、deleteKVStore时还需要传appId需要与bundleName相同，因此建议bundleName使用应用包名。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-26
爬取时间: 2025-05-08 05:36:37
来源: Huawei Developer


开发者分布式对象进行组网时，如果两个对象数据不一致，需要进行一次同步，后加入组网的对象的数据看做是最新的数据，覆盖先加入组网的数据，这点是符合逻辑的。 将数据设置为undefined可以不覆盖已有数据并且接收已有数据。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-27
爬取时间: 2025-05-08 05:36:46
来源: Huawei Developer


开发者先“on启动监听再setsessionId加入组网”和 “先setsessionId加入组网再on启动监听”之间的区别在于后者setsessionId到on之间这段时间监听未启动，如果数据有变化无法得知，具体需要视业务逻辑和代码而定。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-28
爬取时间: 2025-05-08 05:36:55
来源: Huawei Developer


数据持久化需要在preferences.put(key, value)调用后调用preferences.flush()接口。


参考链接


用户首选项


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-29
爬取时间: 2025-05-08 05:37:05
来源: Huawei Developer


可以在UIAbility里通过AppStorage或LocalStorage里存储context，然后在非ArkUI页面里使用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-30
爬取时间: 2025-05-08 05:37:15
来源: Huawei Developer


getRdbStore只提供Promise和Callback异步回调的方式打开数据库，推荐使用async/await语法封装实现。


关于数据库的增删改查，已提供同步接口，具体可查看API文档。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-31
爬取时间: 2025-05-08 05:37:25
来源: Huawei Developer


优先排查value长度，如果Value值为string类型，请使用UTF-8编码格式，可以为空，不为空时长度不超过8192个字节。


Parameter error问题可能原因


1、Mandatory parameters are left unspecified;


强制参数未指定，没有传入指定参数。


2、Incorrect parameter types;


参数类型不匹配。


3、Parameter verification failed.


参数无效，超过指定范围等。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-32
爬取时间: 2025-05-08 05:37:34
来源: Huawei Developer


可以通过DevEco Studio右下角的Device File Browser查看设备文件目录，在如下目录中可以查看数据库并导出。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160845.73865480013485173078911868769602:50001231000000:2800:1B239EFC389BAA7FE74BBE52DE5408B7200565164C4BC5A1F769C77763FC85A8.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-33
爬取时间: 2025-05-08 05:37:44
来源: Huawei Developer


关系型数据库：


"/data/app/el2/100/database/(bundleName)/entry/rdb/"下的.db文件


键值型数据库：


"/data/app/el2/100/database/(bundleName)/entry/kvdb/<系统默认生成文件名>/single_ver/main/"路径下的.db文件


首选项：


"data/app/el2/100/base/(bundleName)/haps/entry/preferences"路径下的文件


persistent_storage：


"/data/app/el2/100/base/(bundleName)/haps/<模块名>/files/persistent_storage"


通过获取应用文件路径获取kvStore、Rdb路径前缀databaseDir和preferences路径前缀preferencesDir，后面自行拼接。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-34
爬取时间: 2025-05-08 05:37:54
来源: Huawei Developer


解决措施


在开启读事务或者结果集未关闭的情况下，不断执行增删改操作，导致WAL文件大小超过默认上限，则抛出相应错误码（14800047）。


该错误码可以通过检查结果集或者事务是否未关闭来处理。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-35
爬取时间: 2025-05-08 05:38:04
来源: Huawei Developer


首选项是线程安全的，所以多线程访问可以保证数据一致性，但只支持同进程，不支持多进程。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-36
爬取时间: 2025-05-08 05:38:14
来源: Huawei Developer


建立数据库时，若在StoreConfig中配置了自定义路径，则调用relationalStore.deleteRdbStore接口进行删库无效，必须使用deleteRdbStore10+接口进行删库。另外，数据库删除成功后，建议将数据库对象置为null。


参考链接


关系型数据库


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-37
爬取时间: 2025-05-08 05:38:24
来源: Huawei Developer

- 安全性问题：由于所有应用的数据都存储在同一个位置，一旦有应用的数据被攻击者窃取，那么所有应用的数据都可能会受到影响，从而导致更大的安全风险。
- 隐私问题：应用数据统一存储会导致用户的个人隐私受到威胁，因为攻击者可以轻松地获取到用户的所有数据。
- 性能问题：由于所有应用的数据都存储在同一个位置，访问数据时可能会出现竞争，从而导致性能下降。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-38
爬取时间: 2025-05-08 05:38:34
来源: Huawei Developer


问题描述


HarmonyOS标准系统支持典型的存储数据形态，包括用户首选项、键值型数据库、关系型数据库。


如果开发者要实现应用级的，或者多个页面的状态数据共享，就需要用到应用级别的状态管理的概念。ArkTS根据不同特性，提供了多种应用状态管理的能力：包括LocalStorage：页面级UI状态存储、AppStorage：应用全局的UI状态存储、PersistentStorage：持久化存储UI状态。


那么开发者如何选择合适的数据存储方案呢？


解决措施


开发者可以根据如下功能介绍，选择合适的数据形态以满足自己应用数据的持久化需要。


| LocalStorage：页面级UI状态存储   | 页面级UI状态存储，通常用于UIAbility内、页面间的状态共享。  |
| --- | --- |
| AppStorage：应用全局的UI状态存储  | 特殊的单例LocalStorage对象，由UI框架在应用程序启动时创建，为应用程序UI状态属性提供中央存储。  |
| PersistentStorage：持久化存储UI状态  | 持久化存储UI状态，通常和AppStorage配合使用，选择AppStorage存储的数据写入磁盘，以确保这些属性在应用程序重新启动时的值与应用程序关闭时的值相同。  |
| 用户首选项（Preferences）  | 通常用于保存应用的配置信息。数据通过文本的形式保存在设备中，应用使用过程中会将文本中的数据全量加载到内存中，所以访问速度快、效率高，但不适合需要存储大量数据的场景。  |
| 键值型数据库（KV-Store）  | 一种非关系型数据库，其数据以“键值”对的形式进行组织、索引和存储，其中“键”作为唯一标识符。适合很少数据关系和业务关系的业务数据存储，同时因其在分布式场景中降低了解决数据库版本兼容问题的复杂度，和数据同步过程中冲突解决的复杂度而被广泛使用。相比于关系型数据库，更容易做到跨设备跨版本兼容。  |
| 关系型数据库（RelationalStore）  | 一种关系型数据库，以行和列的形式存储数据，广泛用于应用中的关系型数据的处理，包括一系列的增、删、改、查等接口，开发者也可以运行自己定义的SQL语句来满足复杂业务场景的需要。  |

LocalStorage：页面级UI状态存储


页面级UI状态存储，通常用于UIAbility内、页面间的状态共享。


AppStorage：应用全局的UI状态存储


特殊的单例LocalStorage对象，由UI框架在应用程序启动时创建，为应用程序UI状态属性提供中央存储。


PersistentStorage：持久化存储UI状态


持久化存储UI状态，通常和AppStorage配合使用，选择AppStorage存储的数据写入磁盘，以确保这些属性在应用程序重新启动时的值与应用程序关闭时的值相同。


用户首选项（Preferences）


通常用于保存应用的配置信息。数据通过文本的形式保存在设备中，应用使用过程中会将文本中的数据全量加载到内存中，所以访问速度快、效率高，但不适合需要存储大量数据的场景。


键值型数据库（KV-Store）


一种非关系型数据库，其数据以“键值”对的形式进行组织、索引和存储，其中“键”作为唯一标识符。适合很少数据关系和业务关系的业务数据存储，同时因其在分布式场景中降低了解决数据库版本兼容问题的复杂度，和数据同步过程中冲突解决的复杂度而被广泛使用。相比于关系型数据库，更容易做到跨设备跨版本兼容。


关系型数据库（RelationalStore）


一种关系型数据库，以行和列的形式存储数据，广泛用于应用中的关系型数据的处理，包括一系列的增、删、改、查等接口，开发者也可以运行自己定义的SQL语句来满足复杂业务场景的需要。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-39
爬取时间: 2025-05-08 05:38:43
来源: Huawei Developer


解决措施


跨模块：


由于context不同，获取到的是不同的首选项实例，因此会导致在跨模块、多页面等场景下取不到数据。此时可以考虑通过单例类在EntryAbility中存一个全局的context，或者使用应用级context。


跨进程：


不同进程一般只有在同沙箱的场景才能访问到一个preference文件，多进程可以通过dataGroupId在多个进程间共用一个preference文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-40
爬取时间: 2025-05-08 05:38:53
来源: Huawei Developer


问题描述


在系统运行中，存储损坏、存储空间不足、文件系统权限、系统掉电等都可能导致数据库发生故障。对此数据管理如何保证数据安全？


解决措施


数据管理提供了数据可靠性与安全性相关的解决方案和能力保障。


备份、恢复功能：重要业务应用（如银行）数据丢失，出现严重异常场景，可以通过备份恢复数据库，保证关键数据不丢失。


数据库加密功能：当数据库中存储如认证凭据、财务数据等高敏感信息时，可对数据库进行加密，提高数据库安全性。


数据库分类分级：数据跨设备同步时，数据管理基于数据安全标签和设备安全等级进行访问控制，保证数据安全。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-42
爬取时间: 2025-05-08 05:39:03
来源: Huawei Developer


relationalStore是线程安全的，但是不支持Worker线程。ArkTS语言基础类库提供的taskPool和worker两个多线程的方案，都是基于Actor并发模型实现的。Actor并发模型是基于事件基础传递数据，不需要开发者去面对锁代理等一系列复杂偶发的问题，是线程安全的，同时并发度也相对较高。


@ohos.data.relationalStore (关系型数据库)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-43
爬取时间: 2025-05-08 05:39:12
来源: Huawei Developer


持久化之后的数据是存在文件中的，App更新版本之后仍然存在。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-44
爬取时间: 2025-05-08 05:39:21
来源: Huawei Developer


当customDir为空字符串或undefined时，配置不生效，需检查customDir传入是否有误。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-45
爬取时间: 2025-05-08 05:39:31
来源: Huawei Developer


可以在合适的时机（用户使用前）将预置数据由其他格式存入关系型数据库中；预置的数据可以通过存放在本地的资源文件中，或者是自定义的module类组件中；如果考虑使用文件保存数据建议放到应用内目录中。


数据库持久化操作，参考下面文档，当前不支持批量处理：通过用户首选项实现数据持久化


应用数据持久化，是指应用将内存中的数据通过文件或数据库的形式保存到设备上；参考文档：应用数据持久化概述


关系型数据库的持久化，参考文档：通过关系型数据库实现数据持久化


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-46
爬取时间: 2025-05-08 05:39:41
来源: Huawei Developer


appId指的是所调用的数据库方应用的包名，调用bundleManager.getBundleInfoForSelf()获取到BundleInfo，然后在获取到的BundleInfo中的signatureInfo对象中包含appId的信息。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-47
爬取时间: 2025-05-08 05:39:50
来源: Huawei Developer


查询数据库可以使用@ohos.data.relationalStore模块提供的query方法，该方法是异步方法，所以对于查询数据库操作，不需要开子线程。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-database-management-48
爬取时间: 2025-05-08 05:40:01
来源: Huawei Developer


解决措施


ValuesBucket的实现为：


```typescript
export type ValuesBucket = Record<string, ValueType | Uint8Array | null>;
```


所以想要动态添加字段，可以参考如下方式


```less
let value : ValuesBucket={}; 
let name : string ='NAME'; 
value[name]= 'cxx'; 
value['AGE']=18; 
value['SALARY']=20000;
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-core-file-kit
爬取时间: 2025-05-08 05:40:11
来源: Huawei Developer

- 如何使用Zip模块解压项目目录rawfile中的文件至应用的沙箱目录中
- 如何实现文件不存在则创建文件
- 如何解决文件的中文乱码问题
- 如何修改沙箱路径下json文件的指定内容
- 沙箱路径的说明，以及如何获取沙箱路径
- 如何将像素点保存到图片文件
- 应用从远程服务器下载文件的下载路径
- 文件分享能否使用Want配置打开具体应用，而不是显示选择窗口
- 系统文件管理器支持的最长文件名是多少
- fs.write是否支持utf-8之外的编码格式
- 怎么获取应用已使用的缓存大小，如何使用API清理缓存
- Hash.hash是否支持同步接口
- el1与el2文件之间的区别
- 如何根据fd对应的mode来判断是否有对应的操作权限
- 手机录屏后的文件存放路径是哪里
- 如何导出手机的文件, 例如外部存储的文件
- 如何保存faultLogger
- 如何存储文件才不会跟随app卸载而删除
- 通过fs.openSync获得的fd，传递到C侧调close后，ArkTS侧fs.closeSync是不是不用调了
- 如何校验文件一致性
- 文件路径fd和internal的区别是什么
- 使用request.uploadFile上传文件后，没有回调可以获取到服务器返回的message信息，不能明确知道文件是否上传成功
- fs接口写文件，两次调用，第二次写入的内容比第一次写入的内容少，导致第二次写入的内容没有完全覆盖第一次内容，合理吗
- 从FilePicker返回的图片地址uri是不是只是在一定的时间内有访问权限
- 如何从一个二进制文件中读取其字节数组？通过fs.createStreamSync只能获取到ArrayBuffer，如何转成number[]
- fs.open读取应用沙盒路径失败
- 如何获取到 resources下rawfile 的文件
- 报错“the parameters check fails this is fail path”如何解决？
- 字体管理器中注册自定义字体时字体文件的路径如何填写？
- native如何获取沙箱路径
- 照片和视频都存储在什么路径？
- 如何将数据持续写入文件内
- 应用安装后，HAP文件在哪个目录路径
- 手机应用开发是否允许自行设置是否备份自身数据
- 获取指定文件系统的剩余空间大小
- fs.write返回的长度和本身content长度不一致
- 如何获取文件的扩展名
- 获取公共下载目录api不可用
- 不同类型的Context获取fileDir目录的结果不一致
- 如何读取指定文件内容，并转为具体对象
- 如何判断文件是不是目录
- 解决冷启动picker选择器无权限问题
- 如何创建临时文件

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-1
爬取时间: 2025-05-08 05:40:20
来源: Huawei Developer


注意：不可直接使用fileio.copyFile将rawfile目录的文件复制到应用的目录中。


参考链接


getRawFileContent接口，获取应用沙箱目录，fs.write接口，zlib.decompressFile接口


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-3
爬取时间: 2025-05-08 05:40:30
来源: Huawei Developer


可以通过调用函数fs.open来实现，open(path: string, mode?: number)，指定第二个参数mode为fs.OpenMode.CREATE，表示若文件不存在，则创建文件。


参考链接


文件管理


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-4
爬取时间: 2025-05-08 05:40:40
来源: Huawei Developer


读取文件内容的buffer数据后，通过TextDecoder对文件内容进行解码。


```less
import { util } from '@kit.ArkTS'; 
import { fileIo } from '@kit.CoreFileKit'; 
 
// 创建一个文件写入中文字符 
let filePath = getContext(this).filesDir + "/test0.txt"; 
let file = fileIo.openSync(filePath, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE); 
// 写入一段内容至文件 
let writeLen = fileIo.writeSync(file.fd, "你好，世界"); 
fileIo.closeSync(file); 
console.info(`GarbledCnCharacters The length of str is: ${writeLen}`); 
let stream = fileIo.createStreamSync(filePath, "r+"); 
let buffer = new ArrayBuffer(4096); 
stream.readSync(buffer); 
// 设置编码格式为“utf-8” 
let textDecoder = util.TextDecoder.create('utf-8', { ignoreBOM: true }); 
// 解码输后获取对应文本 
let readString = textDecoder.decodeWithStream(new Uint8Array(buffer), { stream: false }); 
console.info(`GarbledCnCharacters read content is:${readString}`);
```


参考链接


TextDecoder


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-5
爬取时间: 2025-05-08 05:40:49
来源: Huawei Developer


可以通过以下步骤来完成：


```typescript
import { fileIo } from '@kit.CoreFileKit'; 
import { common } from '@kit.AbilityKit'; 
 
let context = getContext(this) as common.UIAbilityContext; 
let filePath = context.filesDir + '/people.json'; 
 
class Student { 
  name: string = 'zhangsan'; 
  age: number = 10; 
} 
 
let student = new Student(); 
// 1 创建文件，并且写入内容 
let file = fileIo.openSync(filePath, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE); 
fileIo.writeSync(file.fd, JSON.stringify(student)) 
fileIo.close(file); 
// 2 通过fileIo.readSync读取json文件内容。 
let data = fileIo.readTextSync(filePath); 
let obj: Student = JSON.parse(data); 
// 3 修改指定内容name为lisi 
obj.name = 'lisi'; 
// 4 重新写入json文件 
let fileModify = fileIo.openSync(filePath, fileIo.OpenMode.WRITE_ONLY | fileIo.OpenMode.TRUNC); 
fileIo.writeSync(fileModify.fd, JSON.stringify(obj)); 
fileIo.close(fileModify); 
// 5 读取最新内容 
let content = fileIo.readTextSync(filePath); 
console.info(`ModifySanFileContent content is :${content}`);
```


参考链接


文件管理


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-6
爬取时间: 2025-05-08 05:40:59
来源: Huawei Developer


沙箱是指网络编程虚拟环境，可以用于测试可以运行的程序，运行结果不会影响系统的现状，沙箱路径即是应用程序在沙箱中的路径。


沙箱路径的说明参考：应用沙箱目录


沙箱路径的获取参考：获取应用文件路径


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-7
爬取时间: 2025-05-08 05:41:09
来源: Huawei Developer


问题现象


提供读取图片成imageSource，再将imageSource重新保存成图片，自己生成了像素点信息，如何将这些像素点保存成图片文件？


解决措施


参考链接


图片处理，文件管理


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-8
爬取时间: 2025-05-08 05:41:18
来源: Huawei Developer


应用仅能保存文件到“应用文件目录”下，根据目录的使用规范和注意事项来选择将数据保存到不同的子目录中。


参考链接


应用文件目录与应用文件路径，应用文件上传下载


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-9
爬取时间: 2025-05-08 05:41:28
来源: Huawei Developer


目前不支持使用Want配置打开具体应用。当前拉起的打开方式是通过设备内应用配置action: "ohos.want.action.sendData"来识别的，不能由业务自行指定。


参考链接


应用文件分享


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-10
爬取时间: 2025-05-08 05:41:38
来源: Huawei Developer


支持的最长文件名是255字节。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-11
爬取时间: 2025-05-08 05:41:47
来源: Huawei Developer


问题描述


1.希望fs.write支持utf-8之外的编码格式，目前只支持utf-8


2.诸如TextEncoder等工具类也支持多种编码格式，与其他API保持统一


解决措施


当前不支持其他格式，当前api能力满足通过自己写代码在内存进行编码转换后直接存arraybuffer到文件里。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-12
爬取时间: 2025-05-08 05:41:56
来源: Huawei Developer


解决措施


获取应用已使用缓存大小可以通过storageStatistics.getCurrentBundleStats来获取。清理缓存需要调用context的cacheDir获取缓存，然后调用系统@ohos.file.fs接口，判断是文件或者文件夹，再分别消除缓存。


需要注意的是，如果需要删除整个应用的缓存，需要对所有模块级的Context、应用级的Context都使用如下代码删除缓存。


参考代码


```typescript
import { fileIo, storageStatistics } from '@kit.CoreFileKit';
import { BusinessError } from '@kit.BasicServicesKit';


@Entry
@Component
struct ClearCache {
  // 在缓存中创建一个文件
  writeFile() {
    let filePath = getContext(this).cacheDir + '/test.txt';
    let fileStream = fileIo.createStreamSync(filePath, 'w+');
    fileStream.writeSync('1145141919810');
    fileStream.close();
  }


  // 获取应用数据空间大小
  getCache() {
    storageStatistics.getCurrentBundleStats((error: BusinessError, bundleStats: storageStatistics.BundleStats) => {
      if (error) {
        console.error('getCurrentBundleStats failed with error:' + JSON.stringify(error));
      } else {
        console.info('getCurrentBundleStats successfully:' + JSON.stringify(bundleStats));
        console.info('appsize :' + bundleStats.appSize);
        console.info('cacheSize :' + bundleStats.cacheSize);
        console.info('dataSize :' + bundleStats.dataSize);
      }
    });
  }


  // 清理缓存
  clearCache() {
    let cacheDir = getContext(this).cacheDir;
    console.info(cacheDir);


    fileIo.listFile(cacheDir).then((filenames) => {
      for (let i = 0; i < filenames.length; i++) {
        let dirPath = cacheDir + '/' + filenames[i];
        console.log(dirPath);
        // 判断是否为文件夹
        let isDirectory: boolean = false;
        try {
          isDirectory = fileIo.statSync(dirPath).isDirectory();
        } catch (e) {
          console.error(JSON.stringify(e));
        }


        if (isDirectory) {
          fileIo.rmdirSync(dirPath);
        } else {
          fileIo.unlink(dirPath).then(() => {
            console.info('remove file succeed');
          }).catch((err: Error) => {
            console.error('remove file failed with error message: ' + err.message);
          });
        }
      }


    })
  }


  build() {
    Column() {
      Button('向缓存写入数据')
        .onClick(() => {
          this.writeFile();
        })
      Button('获取系统缓存大小')
        .onClick(() => {
          this.getCache();
        })
      Button('点击清理缓存')
        .onClick(() => {
          this.clearCache();
        })
    }
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-13
爬取时间: 2025-05-08 05:42:06
来源: Huawei Developer


解决措施


@ohos.file.hash提供了文件哈希处理能力，对文件内容进行哈希处理。


其中的Hash.hash方法为异步方法，目前不支持提供同步方法，实现同步逻辑可以将该方法的调用放在callback中。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-14
爬取时间: 2025-05-08 05:42:16
来源: Huawei Developer


三级目录el1/和el2/：代表不同文件加密类型。


el1（设备级加密区）：设备开机后即可访问的数据区。


el2（用户级加密区）：设备开机后，需要至少一次解锁对应用户的锁屏界面（密码、指纹、人脸等方式或无密码状态）后，才能够访问的加密数据区。


应用如无特殊需要，应将数据存放在el2加密目录下，以尽可能保证数据安全。但是对于某些场景，一些应用文件需要在用户解锁前就可被访问，例如时钟、闹铃、壁纸等，此时应用需要将这些文件存放到设备级加密区（el1）。


具体关于应用沙箱路径的内容可以参考应用沙箱路径。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-16
爬取时间: 2025-05-08 05:42:26
来源: Huawei Developer


问题场景


使用fs.open传入只读，再使用fs.stat取出mode的值，发现这个值跟文档中对不上


使用场景是某些API支持用户传入fd，但需要根据fd对应的mode来判断是否有对应的操作权限，比如API涉及到写入，那么就需要通过fs.stat取出mode来判断是否支持写入


解决措施


fs.stat取出的mode值为文件本身的权限值，432的8进制为660，660是沙箱中的默认权限，开发者想获取的是文件的打开方式，打开方式为用户已知内容，目前不提供接口获取，总结下来就是：


1）想拿到open的打开方式，但这个打开方式获取不了，因为系统默认用户已知


2）mode是文件自己的权限信息，非应用操作该文件的信息


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-17
爬取时间: 2025-05-08 05:42:36
来源: Huawei Developer


录屏文件在/storage/media/100/local/files/Photo/1 （或其他数字）和 /storage/cloud/100/files/Photo/1 中都有保存。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-18
爬取时间: 2025-05-08 05:42:46
来源: Huawei Developer


可以在连接设备的情况下，尝试点击DevEco Studio右下角的Device File Browser进入手机目录结构，找到想要导出的文件右击选择 save as 另存到本地即可导出。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-19
爬取时间: 2025-05-08 05:42:56
来源: Huawei Developer


参考代码


```typescript
import { fileIo } from '@kit.CoreFileKit'; 
import { FaultLogger, hilog } from '@kit.PerformanceAnalysisKit'; 
import { AbilityConstant, common } from '@kit.AbilityKit'; 
import { preferences } from '@kit.ArkData'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
const TAG: string = 'testTag'; 
 
export class LogUtils { 
  static async queryAndUploadFaultLog(context: common.UIAbilityContext, launchParam: AbilityConstant.LaunchParam) { 
    if (launchParam.lastExitReason == AbilityConstant.LastExitReason.NORMAL) { 
      hilog.info(0x00000, TAG, '上次应用退出时未发生异常'); 
      return; 
    } 
    let value: Array<FaultLogger.FaultLogInfo> = await FaultLogger.query(FaultLogger.FaultType.NO_SPECIFIC) 
    hilog.info(0x00000, TAG, '报错日志:' + value.toString()); 
    if (value) { 
      let len = value.length; 
      hilog.info(0x00000, TAG, '报错日志数量：' + len); 
      if (len === 0) { 
        return; 
      } 
      //取得实例 
      let preference: preferences.Preferences = await preferences.getPreferences(context, 'STLiveness'); 
      // 查询上一次的处理的时间戳 
      let lastFaultHandleTime = preference.getSync('faultHandleTime', 0); 
      hilog.info(0x0000, TAG, 'lastFaultHandleTime:' + lastFaultHandleTime); 
      for (let i = 0; i < len; i++) { 
        let timestamp = value[i].timestamp; 
        hilog.info(0x00000, TAG, '日志文件名称#' + timestamp); 
        if (lastFaultHandleTime >= timestamp) { 
          hilog.error(0x00000, TAG, 'Maple No New Logs.'); 
          return; 
        } 
        // 将日志保存到应用沙箱的目录 保存文件名为 时间戳.log 
        await LogUtils.save(value[i].fullLog, context.filesDir + '/crash', timestamp + '.log'); 
        await preference.put('faultHandleTime', timestamp); 
        await preference.flush(); 
      } 
    } 
  } 
  static async save(buffer: ArrayBuffer | string, destFilePath: string, name: string): Promise<string> { 
    await LogUtils.mkdir(destFilePath); 
    hilog.info(0x00000, TAG, '写入日志的内容为：' + buffer); 
    hilog.info(0x00000, TAG, '被写入的日志文件路径为：' + destFilePath); 
    if (buffer) { 
      try { 
        let file = fileIo.openSync(destFilePath + '/' + name, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE); 
        fileIo.writeSync(file.fd, buffer); 
        fileIo.closeSync(file); 
      } catch (error) { 
        let e: BusinessError = error as BusinessError; 
        hilog.info(0x0000, TAG, 'FileUtils:save:::' + e.message); 
      } 
    } -m 
    return destFilePath; 
  } 
 
  static async mkdir(destFilePath: string) { 
    hilog.info(0x00000, TAG, '开始创建目录：' + destFilePath); 
    if (fileIo.accessSync(destFilePath)) { 
      hilog.info(0x00000, TAG, '目录已经存在，无需创建'); 
      return; 
    } 
    await fileIo.mkdir(destFilePath); 
    hilog.info(0x00000, TAG, '创建完成'); 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-20
爬取时间: 2025-05-08 05:43:06
来源: Huawei Developer


解决措施


如果是用户文件，比如用户在应用内主动保存的文件，那可以存在公共目录/storage/media/100/local/files，公共目录下的文件不会随着app卸载而删除。


参考代码


可以使用@ohos.file.picker中提供的save方法在公共目录创建文件，方法可以参考以下代码：


```typescript
import { BusinessError } from '@kit.BasicServicesKit'; 
import { picker, fileIo } from '@kit.CoreFileKit'; 
 
let uri: string = ''; 
 
// 将content至公共目录 
export async function saveToUser(content: string) { 
  try { 
    let DocumentSaveOptions = new picker.DocumentSaveOptions(); 
    // 新建文件名 
    DocumentSaveOptions.newFileNames = ['test.txt']; 
    let documentPicker = new picker.DocumentViewPicker(); 
    documentPicker.save(DocumentSaveOptions).then((DocumentSaveResult: Array<string>) => { 
      console.info('DocumentViewPicker.save successfully, uri: ' + JSON.stringify(DocumentSaveResult)); 
      uri = DocumentSaveResult[0]; 
      // 将content写入新建的文件内 
      let file = fileIo.openSync(uri, fileIo.OpenMode.READ_WRITE); 
      fileIo.writeSync(file.fd, content); 
    }).catch((err: BusinessError) => { 
      console.error('DocumentViewPicker.save failed with err: ' + JSON.stringify(err)); 
    }); 
  } catch (error) { 
    let err: BusinessError = error as BusinessError; 
    console.error('DocumentViewPicker failed with err: ' + err.message); 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-21
爬取时间: 2025-05-08 05:43:16
来源: Huawei Developer


需要调用，ArkTS侧open的fd传递给C侧，C侧使用之后需要单独close，ArkTs侧需要关闭文件，所以fs.openSync出来的对象，依旧需要使用fs.closeSync来关闭。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-22
爬取时间: 2025-05-08 05:43:27
来源: Huawei Developer


通过比较hash值的方法来校验文件的一致性。hash算法使用MD5算法，计算文件的MD5值，参考代码如下：


```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit'; 
import { fileIo } from '@kit.CoreFileKit' 
import { buffer } from '@kit.ArkTS'; 
 
async function calFileMd5(fileUrl: string) { 
  let md = cryptoFramework.createMd('MD5'); 
  let file = fileIo.openSync(fileUrl, fileIo.OpenMode.READ_ONLY); 
  let arrayBuffer = new ArrayBuffer(2048); 
  let len: number = 0; 
  let position: number = 0; 
  do { 
    len = fileIo.readSync(file.fd, arrayBuffer, { offset: position }); 
    if (len > 0) { 
      let uint8Array = new Uint8Array(arrayBuffer.slice(0, len)); 
      let updateMessageBlob: cryptoFramework.DataBlob = { data: uint8Array }; 
      await md.update(updateMessageBlob); 
      position += len; 
    } 
  } while (len > 0); 
  fileIo.closeSync(file); 
  let mdOutput = await md.digest(); 
  console.info('...calFileMd5: ' + buffer.from(mdOutput.data).toString('hex')); 
}
```


参考链接：


文件的哈希处理


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-23
爬取时间: 2025-05-08 05:43:37
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-24
爬取时间: 2025-05-08 05:43:47
来源: Huawei Developer


on('complete')回调就是成功后才走到的分支，如果需要获取服务端的响应信息自己处理判断逻辑，还有on('headerReceive')回调。


参考链接


on('headerReceive')


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-25
爬取时间: 2025-05-08 05:43:56
来源: Huawei Developer


清除写文件必须要设置OpenMode.TRUNC，默认只是覆盖不会清除。修改后代码：fs.openSync(dst, fs.OpenMode.WRITE_ONLY | fs.OpenMode.TRUNC | fs.OpenMode.CREATE)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-26
爬取时间: 2025-05-08 05:44:06
来源: Huawei Developer


重启应用后，uri失效是正常的，因为通过picker生成uri的同时系统会对uri有临时授权，应用被杀掉后该临时授权失效，需要重新通过picker选择来生成uri。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-28
爬取时间: 2025-05-08 05:44:16
来源: Huawei Developer


```less
@Component 
export struct ArrayBufferConversionArray { 
  @State fileLength: number = 10; 
  tempData: number[] = []; 
 
  aboutToAppear(): void { 
    let arrayBuffer: ArrayBuffer = new ArrayBuffer(this.fileLength); 
    let dataView: DataView = new DataView(arrayBuffer); 
    for (let index = 0; index < this.fileLength; index++) { 
      this.tempData[index] = dataView.getInt8(index); 
    } 
    console.info(this.tempData.toString()); 
  } 
 
  build() { 
    RelativeContainer() { 
      Text(this.tempData.toString()) 
        .id('ArrayBufferHelloWorld') 
        .fontSize(50) 
        .fontWeight(FontWeight.Bold) 
        .alignRules({ 
          center: { anchor: '__container__', align: VerticalAlign.Center }, 
          middle: { anchor: '__container__', align: HorizontalAlign.Center } 
        }) 
    } 
    .height('100%') 
    .width('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-29
爬取时间: 2025-05-08 05:44:25
来源: Huawei Developer


问题现象


获取到demo里面的歌曲path然后转换为uri发给另一个app使用，通过context获取的应用文件的沙盒路径后传入fs.open中发现报错。


解决措施


需要走文件分享，uid、gid都改成应用的。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-30
爬取时间: 2025-05-08 05:44:35
来源: Huawei Developer


```less
import { fileIo } from '@kit.CoreFileKit'; 
 
@Component 
export struct GetRawfile { 
  @State message: string = 'Hello World'; 
 
  aboutToAppear(): void { 
    getContext(this).resourceManager.getRawFileContent('test.txt', (_err, value) => { 
      let myBuffer: ArrayBufferLike = value.buffer; 
      let context = getContext(this); //沙箱路径 
      let filePath = context.filesDir + '/test.txt'; 
      console.info('testTag-filePath:' + filePath); 
      let file = fileIo.openSync(filePath, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE); 
      let writeLen = fileIo.writeSync(file.fd, myBuffer); 
      console.info('testTag-write data to file succeed and size is:' + writeLen); 
      fileIo.closeSync(file); 
    }); 
  } 
 
  build() { 
    RelativeContainer() { 
      Text(this.message) 
        .id('RawfileHelloWorld') 
        .fontSize(50) 
        .fontWeight(FontWeight.Bold) 
        .alignRules({ 
          center: { anchor: '__container__', align: VerticalAlign.Center }, 
          middle: { anchor: '__container__', align: HorizontalAlign.Center } 
        }) 
    } 
    .height('100%') 
    .width('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-31
爬取时间: 2025-05-08 05:44:45
来源: Huawei Developer


问题现象


```less
public static timelineReceivedResult(path: string): void { 
  if (!path) { 
  return; 
} 
// let file = fs.openSync(path, fs.OpenMode.READ_ONLY); 
// let result = fs.readTextSync(path); 
 
let filename = path.substring(path.lastIndexOf("/")+1); 
let uri = fileUri.getUriFromPath(path); 
let header = new Map<Object, string>(); 
// header.set('key1', 'value1'); 
// header.set('key2', 'value2'); 
let files: Array<request.File> = [ 
  { filename: filename, name: 'test', uri: uri, type: 'txt' } 
] 
let data: Array<request.RequestData> = [];// { name: 'name', value: 'value' } 
let uploadConfig: request.UploadConfig = { 
  url: 'http://30.7.242.25:8800',// TODO 
  header: header, 
  method: 'POST', 
  files: files, 
  data: data 
} 
 
// 将本地应用文件上传至网络服务器 
try { 
  request.uploadFile(WeexFactory.engine().getGlobalApplication(), uploadConfig) 
    .then((uploadTask: request.UploadTask) => { 
      uploadTask.on('complete', (taskStates: Array<request.TaskState>) => { 
        for (let i = 0; i < taskStates.length; i++) { 
          console.info(`upload complete taskState: ${JSON.stringify(taskStates[i])}`); 
        } 
      }); 
    }) 
    .catch((err: BusinessError) => { 
      console.error(`Invoke uploadFile failed, code is ${err.code}, message is ${err.message}`); 
    }) 
} catch (error) { 
  let err: BusinessError = error as BusinessError; 
  console.error(`Invoke uploadFile failed, code is ${err.code}, message is ${err.message}`); 
} 
}
```


报错如下：the parameters check fails this is fail path


解决措施


请尝试在 cache 里上传，当前仅支持"internal"协议，对应在cache目录下


参考链接


@ohos.request (上传下载)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-32
爬取时间: 2025-05-08 05:44:55
来源: Huawei Developer


建议开发者使用rawfile目录放置字体文件，通过/data/storage/el1/bundle/entry/resources/rawfile/路径进行访问。请注意在这里放置文件会占用您应用安装所需的存储空间，不要放置过大的文件。


参考链接


资源分类与访问


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-33
爬取时间: 2025-05-08 05:45:04
来源: Huawei Developer


目前支持通过ArkTS侧获取沙箱路径传递到Native侧，或者直接在Native侧直接拼接沙箱路径。详细实现方法可参考文章：Native侧实现文件访问开发实践。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-34
爬取时间: 2025-05-08 05:45:13
来源: Huawei Developer


存储位置为/storage/cloud/100/files/Photo和/storage/media/100/local/files/Photo。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-35
爬取时间: 2025-05-08 05:45:23
来源: Huawei Developer


fs.write中有WriteOptions.offset表示期望文件写入的位置，可以先通过fs.read获取偏移量offset，然后接着之前的数据位置写数据，参考代码如下：


```less
import { fileIo, WriteOptions } from '@kit.CoreFileKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
@Component 
export struct ContinuousWrite { 
  @State message: string = 'Hello World'; 
 
  aboutToAppear(): void { 
    let context = getContext(this); // 沙箱路径 
    let filePath = context.filesDir + '/test.txt'; 
    let file = fileIo.openSync(filePath, fileIo.OpenMode.READ_WRITE); 
    let arrayBuffer = new ArrayBuffer(4096); 
    fileIo.read(file.fd, arrayBuffer).then((readLen: number) => { 
      console.info(readLen.toString()); 
      let str: string = 'hello, world'; 
      let options: WriteOptions = { offset: readLen }; 
      let writeLen = fileIo.writeSync(file.fd, str, options); 
      console.info('write data to file succeed and size is:' + writeLen); 
    }).catch((err: BusinessError) => { 
      console.error('read file data failed with error message: ' + err.message + ', error code: ' + err.code); 
    }).finally(() => { 
      fileIo.closeSync(file); 
    }); 
  } 
 
  build() { 
    RelativeContainer() { 
      Text(this.message) 
        .id('WriteHelloWorld') 
        .fontSize(50) 
        .fontWeight(FontWeight.Bold) 
        .alignRules({ 
          center: { anchor: '__container__', align: VerticalAlign.Center }, 
          middle: { anchor: '__container__', align: HorizontalAlign.Center } 
        }) 
    } 
    .height('100%') 
    .width('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-36
爬取时间: 2025-05-08 05:45:33
来源: Huawei Developer


目录路径：“/data/app/el1/bundle/public/<bundleName>“


参考链接


应用沙箱目录


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-37
爬取时间: 2025-05-08 05:45:43
来源: Huawei Developer


应用均可接入数据备份恢复，在接入后，也可以通过手动设置参数allowToBackupRestore（是否允许备份恢复，默认为false）来决定是否接入备份，包括是否允许备份、备份哪些数据等。


参考链接：应用数据备份


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-38
爬取时间: 2025-05-08 05:45:53
来源: Huawei Developer


获取指定文件系统的剩余空间大小（单位为Byte），参考示例如下：


```typescript
import { BusinessError } from '@kit.BasicServicesKit';
import { common } from '@kit.AbilityKit';
import { statfs } from '@kit.CoreFileKit';


@Entry
@Component
struct GetFileSpace {
  build() {
    Column() {
      Button('获取系统空间大小')
        .onClick(() => {
          let context = getContext(this) as common.UIAbilityContext;
          let path = context.filesDir;


          //获取指定文件系统总字节数
          statfs.getTotalSize(path).then((number: number) => {
            console.info('getTotalSize succeed, Size: ' + number);
          }).catch((err: BusinessError) => {
            console.error('getTotalSize failed with error message: ' + err.message + ', error code: ' + err.code);
          });


          //获取指定文件系统空闲字节数
          statfs.getFreeSize(path).then((number: number) => {
            console.info('getFreeSize succeed, Size: ' + number);
          }).catch((err: BusinessError) => {
            console.error('getFreeSize failed with error message: ' + err.message + ', error code: ' + err.code);
          });
        })
    }
  }
}
```


参考链接：@ohos.file.statvfs (文件系统空间统计)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-39
爬取时间: 2025-05-08 05:46:03
来源: Huawei Developer


fs.write返回的是实际写入的数据长度，单位字节。string.length返回的是字符串的长度，两者返回的单位不一样，所以在比较长度时也是不一致的。


参考文档：fs.write


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-40
爬取时间: 2025-05-08 05:46:12
来源: Huawei Developer


可以使用fs.listFile接口获取文件夹目录下的文件列表，该接口的返回值为文件名称数组，通过获取到的文件名进行字符串的处理来获取文件的扩展名。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-41
爬取时间: 2025-05-08 05:46:22
来源: Huawei Developer


该能力仅对PC/2in1设备开放，可将文件先保存在应用沙箱目录，再通过picker的save方法转存到公共下载目录。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-42
爬取时间: 2025-05-08 05:46:31
来源: Huawei Developer


问题描述


不同类型的Context 获取 fileDir目录的结果不一致。


1.用Application的Context获取的目录是：“/data/storage/el2/base/files“。


2.用Ability的目录获取的是：“/data/storage/el2/base/haps/entry/files”。


问题澄清


当前设计即如此：Application可能存在多Ability情况，对应到沙箱目录下hap的路径。


参考链接


应用沙箱目录与应用沙箱路径


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-44
爬取时间: 2025-05-08 05:46:41
来源: Huawei Developer


可以使用resourceManager.getRawFileContent()方法，参考代码如下：


```typescript
import { Context } from '@kit.AbilityKit';
import { buffer } from '@kit.ArkTS';


@Entry
@Component
struct Index {
  private context: Context = getContext(this);
  private str: string = '';


  getRawFile(): ESObject {
    //调用getRawFileContent接口获取json文件内容，并读为string
    getContext(this).resourceManager.getRawFileContent('test.json', (err, data) => {
      try {
        this.str = buffer.from(data.buffer).toString();
        console.info(JSON.stringify(this.str));
      } catch (e) {
        console.info(JSON.stringify(e));
      }
    })
    //也可以调用getRawFileContentSync接口获取json文件内容，并读为string
    try {
      let data: Uint8Array = this.context.resourceManager.getRawFileContentSync('test.json');
      this.str = buffer.from(data.buffer).toString();
    } catch (e) {
      console.info(JSON.stringify(e));
    }
    // string转为ESObject
    let obj: ESObject = JSON.parse(this.str);
    console.info('ESObject', JSON.stringify(obj));
    return obj;
  }


  build() {
    Column() {
      Button('get')
        .onClick(() => {
          this.getRawFile();
        })
    }.width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-45
爬取时间: 2025-05-08 05:46:50
来源: Huawei Developer


判断文件是否为目录可以使用方法：fs.statSync(dirPath).isDirectory()。返回结果为true，表示是目录。


参考链接


isDirectory


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-46
爬取时间: 2025-05-08 05:47:00
来源: Huawei Developer


原因是在APP冷启后没有uri的读取权限了，可以通过保存草稿场景将对应的文件copy到沙箱路径下，冷启动时再去获取。


参考链接


fs.copyFile应用沙箱目录


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-local-file-manager-47
爬取时间: 2025-05-08 05:47:09
来源: Huawei Developer


可以参考如下示例：


```typescript
import { fileIo as fs, ReadOptions } from '@kit.CoreFileKit';
import { common } from '@kit.AbilityKit';
import { buffer } from '@kit.ArkTS';


@Entry
@Component
struct CreateFileDemo {
  @State message: string = 'Hello World';
  @State writeStr: string = 'write content';
  @State readStr: string = 'read content';


  build() {
    Column() {
      Text(this.message)
      Button(this.writeStr)
        .margin({ top: 15, bottom: 15 })
        .onClick(() => {
          let context = getContext(this) as common.UIAbilityContext;
          let filesDir = context.tempDir;
          let file = fs.openSync(filesDir + 'test.txt', fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);
          // 写入一段内容至文件
          fs.writeSync(file.fd, 'Try to write str.');
          console.info('str has been written');
          // 关闭文件
          fs.closeSync(file);
        })
      Button(this.readStr)
        .onClick(() => {
          let context = getContext(this) as common.UIAbilityContext;
          let filesDir = context.tempDir;
          let file = fs.openSync(filesDir + 'test.txt', fs.OpenMode.READ_WRITE);
          // 从文件读取一段内容
          let arrayBuffer = new ArrayBuffer(1024);
          let readOptions: ReadOptions = {
            offset: 0,
            length: arrayBuffer.byteLength
          };
          let readLen = fs.readSync(file.fd, arrayBuffer, readOptions);
          let buf = buffer.from(arrayBuffer, 0, readLen);
          this.message = buf.toString();
          // 关闭文件
          fs.closeSync(file);
        })
    }
    .height('100%')
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-preview
爬取时间: 2025-05-08 05:47:19
来源: Huawei Developer

- filePreview具体能够预览哪些文件？例如，包含PDF文件吗？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-preview-1
爬取时间: 2025-05-08 05:47:29
来源: Huawei Developer


filePreview（文件预览）支持PDF格式（官网文档后续更新），在使用时可以用canPreview接口判断文件类型是否可以预览。目前支持预览的文件类型如下：


| 类型  | 文件后缀  | mimeType类型  |
| --- | --- | --- |
| 文本  | txt、cpp、c、h、java、xhtml、xml  | text/plain、text/x-c++src、text/x-csrc、text/x-chdr、text/x-java、application/xhtml+xml、text/xml  |
| 网页  | html、htm  | text/html  |
| 图片  | jpg、png、gif、webp、bmp、svg  | image/jpeg、image/png、image/gif、image/webp，image/bmp、image/svg+xml  |
| 音频  | m4a、aac、mp3、ogg、wav  | audio/mp4a-latm、audio/aac、audio/mpeg、audio/ogg、audio/x-wav  |
| 视频  | mp4、mkv、ts  | video/mp4、video/x-matroska、video/mp2ts  |
| 文件夹  | 无  | 无  |

类型


文件后缀


mimeType类型


文本


txt、cpp、c、h、java、xhtml、xml


text/plain、text/x-c++src、text/x-csrc、text/x-chdr、text/x-java、application/xhtml+xml、text/xml


网页


html、htm


text/html


图片


jpg、png、gif、webp、bmp、svg


image/jpeg、image/png、image/gif、image/webp，image/bmp、image/svg+xml


音频


m4a、aac、mp3、ogg、wav


audio/mp4a-latm、audio/aac、audio/mpeg、audio/ogg、audio/x-wav


视频


mp4、mkv、ts


video/mp4、video/x-matroska、video/mp2ts


文件夹


无


无


参考链接：filePreview


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-library-kit
爬取时间: 2025-05-08 05:47:39
来源: Huawei Developer

- 如何监听文件或文件目录的变化
- 截屏图片保存在系统哪个目录下
- base64字符串如何转为图片并保存
- 关于导入图片的使用权限和问题
- 如何选择文件保存路径

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-library-1
爬取时间: 2025-05-08 05:47:48
来源: Huawei Developer


fs.createWatcher，监听文件或者目录的变化，使用callback异步回调。通知处理策略需要应用根据自己业务进行控制，可以通过消息队列存储，周期性进行刷新。


参考链接


fs.createWatcher


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-library-2
爬取时间: 2025-05-08 05:47:58
来源: Huawei Developer


获取截图截屏文件保存目录，可以在DevEco Studio日志控制台通过关键字筛选日志，然后在图库点击刚截图的图片，控制台可打印文件保存的路径。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-library-3
爬取时间: 2025-05-08 05:48:08
来源: Huawei Developer


可以通过buffer.from的方法，将base64编码格式的字符串创建为新的Buffer对象，接着用fileIo.writeSync方法将转换好的Buffer对象写入文件。


参考代码如下：


```typescript
import { buffer } from '@kit.ArkTS'; 
import { fileIo } from '@kit.CoreFileKit'; 
import { common } from '@kit.AbilityKit'; 
import { fileUri } from "@kit.CoreFileKit"; 
import { hilog } from '@kit.PerformanceAnalysisKit'; 
 
let context = getContext(this) as common.UIAbilityContext; 
let filesDir = context.filesDir; 
 
// data为需要转换的base64字符串，返回沙箱路径uri 
export async function writeFile(data: string): Promise<string> { 
  let uri = '' 
  try { 
    let filePath = filesDir + "/1.png"; 
    uri = fileUri.getUriFromPath(filePath); 
    let file = fileIo.openSync(filePath, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE); 
    console.info("file fd: " + file.fd); 
    const reg = new RegExp("data:image/\\w+;base64,") 
    const base64 = data.replace(reg, ""); 
    console.log("base64flag", base64) 
    const dataBuffer = buffer.from(base64, 'base64') 
    let writeLen = fileIo.writeSync(file.fd, dataBuffer.buffer); 
    hilog.info(0xA0c0d0,'uri',uri) 
    fileIo.closeSync(file); 
  } 
  catch (Error) { 
    hilog.error(0xA0c0d0,'Error',Error.code) 
  } 
  return uri; 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-library-4
爬取时间: 2025-05-08 05:48:18
来源: Huawei Developer


问题描述


目前的话需要导入图片获取到图片地址后传递到底层c++代码，经过测试发现导入之后读取图片的时候失败。


问题定位


目前手机上不支持在c侧打开公共路径，只支持在ts打开之后把fd传入到c侧，再用dopen打开。


参考代码


可以参考如下代码，将公共路径下的文件保存至沙箱路径，并将fd传入C侧，C侧即可通过fd操作文件。


```typescript
import { BusinessError } from '@kit.BasicServicesKit'; 
import { fileIo, picker } from '@kit.CoreFileKit'; 
import { common } from '@kit.AbilityKit'; 
 
let context = getContext(this) as common.UIAbilityContext; 
let filesDir = context.filesDir; 
function SavePictureToContext(){ 
  const photoSelectOptions = new picker.PhotoSelectOptions(); 
  photoSelectOptions.MIMEType = picker.PhotoViewMIMETypes.IMAGE_TYPE; // 过滤选择媒体文件类型为IMAGE 
  photoSelectOptions.maxSelectNumber = 5; // 选择媒体文件的最大数目 
  let uris: Array<string> = []; 
  const photoViewPicker = new picker.PhotoViewPicker(); 
  photoViewPicker.select(photoSelectOptions).then((photoSelectResult: picker.PhotoSelectResult) => { 
    uris = photoSelectResult.photoUris; 
    console.info('photoViewPicker.select to file succeed and uris are:' + uris); 
  }).catch((err: BusinessError) => { 
    console.error('Invoke photoViewPicker.select failed, code is'+ err.code+', message is '+err.message); 
  }) 
  let uri: string = uris[0]; 
  let file = fileIo.openSync(uri, fileIo.OpenMode.READ_ONLY); 
  console.info('file fd: ' + file.fd); 
  let fd =file.fd; 
  fileIo.copyFileSync(fd, filesDir + '/test2.jpg') 
  let file2 = fileIo.openSync(filesDir + '/test2.jpg', fileIo.OpenMode.READ_ONLY ); 
  let file3 = fileIo.openSync(filesDir + '/test3.jpg', fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE); 
  // 将fd传入后，C端即可进行调用 
  // ReadFile(file2.fd,file3.fd) 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-library-5
爬取时间: 2025-05-08 05:48:27
来源: Huawei Developer


官网中保存用户文件提供的方法是要FilePicker需要拉起系统应用，再由用户选择具体路径保存文件的，参考文档：保存用户文件。


但是如果是保存文件到媒体库的场景，可以使用保存控件SaveButton，示例如下


```typescript
import { photoAccessHelper } from '@kit.MediaLibraryKit'; 
import { fileIo } from '@kit.CoreFileKit'; 
 
@Entry 
@Component 
struct WebComponent { 
  build() { 
    Row() { 
      Column() { 
        Image($r('app.media.startIcon')) 
          .height(200) 
          .width(200) 
        SaveButton().onClick(async (event: ClickEvent, result: SaveButtonOnClickResult) => { 
          if (result === SaveButtonOnClickResult.SUCCESS) { 
            try { 
              const context = getContext(this); 
              let helper = photoAccessHelper.getPhotoAccessHelper(context); 
              // onClick触发后10秒内通过createAsset接口创建图片文件，10秒后createAsset权限收回。 
              let uri = await helper.createAsset(photoAccessHelper.PhotoType.IMAGE, 'jpg'); 
              // 使用uri打开文件，可以持续写入内容，写入过程不受时间限制 
              let file = await fileIo.open(uri, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE); 
              try { 
                context.resourceManager.getMediaContent($r('app.media.startIcon').id, 0) 
                  .then(async value => { 
                    let media = value.buffer; 
                    // 写到媒体库文件中 
                    await fileIo.write(file.fd, media); 
                    await fileIo.close(file.fd); 
                    AlertDialog.show({ message: '已保存至相册!' }); 
                  }); 
              } catch (err) { 
                console.error('error is ' + JSON.stringify(err)) 
              } 
            } catch (error) { 
              console.error('error is ' + JSON.stringify(error)); 
            } 
          } else { 
            AlertDialog.show({ message: '设置权限失败' }) 
          } 
        }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-pdf
爬取时间: 2025-05-08 05:48:37
来源: Huawei Developer

- PDF Kit可以移除具体页面的页眉页脚，水印，背景吗？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/pdf-faq-4
爬取时间: 2025-05-08 05:48:46
来源: Huawei Developer


PDF Kit移除页眉页脚，水印或背景不会针对具体页面，调用移除方法将移除所有页面的页眉页脚，水印或背景。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-accessibility-localization
爬取时间: 2025-05-08 05:48:56
来源: Huawei Developer

- 本地化开发（Localization）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-localization-kit
爬取时间: 2025-05-08 05:49:06
来源: Huawei Developer

- 如何读取rawfile中的xml文件并转化为String类型
- 如何获取resource目录下的资源
- 如何将Resource资源对象转成string类型
- 数字支持货币分隔符显示吗
- 如何将app.media.app_icon，转换为PixelMap
- 如何使用实现汉字转拼音
- 如何读取工程中/resources下json文件
- 如何将文件转换成字符串
- 在多模块工程中，如何获取har/hsp中的rawfile资源

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-localization-3
爬取时间: 2025-05-08 05:49:16
来源: Huawei Developer


通过resourceManager的getRawFileContent接口获取xml数据，再通过util工具函数中的decodeToString接口将获取的数据转化为String类型。


参考代码如下：


```less
import { BusinessError } from '@kit.BasicServicesKit'; 
import { common } from '@kit.AbilityKit'; 
import { util } from '@kit.ArkTS'; 
 
let context = getContext(this) as common.UIAbilityContext; 
 
try { 
  context.resourceManager.getRawFileContent('test.xml', (error, value) => { 
    if (error != null) { 
      console.log('error is ' + error); 
    } else { 
      let rawFile = value; 
      let textDecoder = util.TextDecoder.create('utf-8', { ignoreBOM : true }); 
      let rawFileString = textDecoder.decodeToString( rawFile , {stream: false}); 
    } 
  }); 
} catch (error) { 
  let code = (error as BusinessError).code; 
  let message = (error as BusinessError).message; 
  console.error(`callback getRawFileContent failed, error code: ${code}, message: ${message}.`); 
}
```


参考链接


资源管理


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-localization-4
爬取时间: 2025-05-08 05:49:25
来源: Huawei Developer


可以考虑如下两种方式获取资源文件：


1. 使用$r或者$rawfile获取。适合静态获取，程序运行时不改变资源路径。


2. 使用ResourceManage获取。适合动态获取，程序运行时可动态改变资源路径。


参考链接


资源分类与访问资源管理


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-localization-7
爬取时间: 2025-05-08 05:49:35
来源: Huawei Developer


Resource为string支持限定词目录使用this.context.resourceManager.getStringSync($r('app.string.test').id)，可以同步转换，且支持$r('app.string.test', 2)方式进行格式化。


参考链接


ResourceManager(资源管理)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-localization-8
爬取时间: 2025-05-08 05:49:44
来源: Huawei Developer


可以通过NumberFormat去设置数字的显示格式


```less
let numfmt = new Intl.NumberFormat(); 
console.info(`numfmt: ${numfmt.format(1000000)}`);
```


参考链接


numberformat使用参考


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-localization-9
爬取时间: 2025-05-08 05:49:54
来源: Huawei Developer


可以通过getMediaContent，获取指定资源ID对应的媒体文件内容，然后通过image的createPixelMap创建PixelMap。


参考代码如下：


```typescript
import { image } from '@kit.ImageKit';


@Entry
@Component
struct Index {
  @State text: string = '';


  convert() {
    try {
      // 媒体文件字节数组
      getContext().resourceManager.getMediaContent($r('app.media.startIcon').id, (error, value: ArrayBuffer) => {
        let opts: image.InitializationOptions = {
          editable: true,
          pixelFormat: 3,
          size: { height: 4, width: 6 }
        };
        let uint8Array: Uint8Array = new Uint8Array(value);
        let buffer: ArrayBuffer = uint8Array.buffer.slice(0);


        // 创建PixelMap
        image.createPixelMap(buffer, opts).then((pixelMap) => {
          // ...
          this.text = JSON.stringify(pixelMap);
        })
      });
    } catch (error) {
      console.error(`callback getMediaContent failed, error code: ${error.code}, message: ${error.message}.`)
    }
  }


  build() {
    Column() {
      Button('点击转换')
        .onClick(() => {
          this.convert();
        })
        .margin({ bottom: 16 })
      TextArea({ text: this.text })
    }
    .padding(16)
  }
}
```


参考链接


getMediaContentcreatePixelMap


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-localization-11
爬取时间: 2025-05-08 05:50:03
来源: Huawei Developer


可以通过Transliterator将汉字转成拼音。


参考代码如下：


```typescript
import { i18n } from '@kit.LocalizationKit';


let transliterator = i18n.Transliterator.getInstance('Any-Latn');
let res: string = transliterator.transform('中国'); // res = 'zhōng guó'


// 去除声部
let transliterator2 = i18n.Transliterator.getInstance('Latin-ASCII');
let res2 = transliterator2.transform(res);
console.info('去除声部后拼音为：',res2);
```


参考链接


Transliterator


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-localization-12
爬取时间: 2025-05-08 05:50:13
来源: Huawei Developer


json文件推荐放在rawfile路径下，通过getRawFileContent接口访问。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-localization-13
爬取时间: 2025-05-08 05:50:23
来源: Huawei Developer


参考示例如下：


```typescript
import { util } from '@kit.ArkTS';
import { BusinessError } from '@kit.BasicServicesKit';


@Entry
@Component
struct FileToString {
  build() {
    Row() {
      Column() {
        Button('file to string')
          .onClick(() => {
            getContext().resourceManager.getRawFileContent('test.txt').then((value: Uint8Array) => {
              let textDecoder: util.TextDecoder = util.TextDecoder.create(); // 调用util模块的TextDecoder类
              let retStr: string = textDecoder.decodeToString(value); // 对Uint8Array解码
              let strBase64 = new util.Base64Helper().encodeToStringSync(value);
              console.info('retStr:', retStr);
              console.info('strBase64:', strBase64);
            }).catch((error: BusinessError) => {
              console.error(`callback getRawFileContent failed, error code: ${error.code}, message: ${error.message}.`);
            });
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


参考链接


getRawFileContent


TextDecoder


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-localization-14
爬取时间: 2025-05-08 05:50:33
来源: Huawei Developer


har模块中的资源可以通过@ohos.resourceManager (资源管理)获取，hsp中的资源可以通过application的createModuleContext接口创建相应模块的context，再通过resourceManager进行获取。


示例如下：


```typescript
import { application, common } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { buffer } from '@kit.ArkTS';


@Entry
@Component
struct Index {
  private context = getContext(this) as common.UIAbilityContext;


  build() {
    Column() {
      Button('get rawFile content')
        .onClick(() => {
          let harContent = this.context.resourceManager.getStringSync($r('app.string.har_content'));
          application.createModuleContext(this.context, 'hsp')
            .then((data) => {
              let rawFileData = data.resourceManager.getRawFileContentSync('hsp.txt');
              let hspContent: string = buffer.from(rawFileData.buffer).toString();
            })
            .catch((error: BusinessError) => {
              console.error(`createModuleContext failed, error.code: ${error.code}, error.message: ${error.message}`);
            })
        })
    }
    .height('100%')
    .width('100%')
    .justifyContent(FlexAlign.Center)
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-web-page-framework
爬取时间: 2025-05-08 05:50:42
来源: Huawei Developer

- Web开发（ArkWeb）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-kit
爬取时间: 2025-05-08 05:50:51
来源: Huawei Developer

- Web组件的onLoadIntercept返回结果是否影响onInterceptRequest
- 为什么Web组件的onKeyEvent键盘事件不生效
- onInterceptRequest拦截URL并自定义HTML文件，页面加载失败
- 如何解决Web组件加载的HTML页面内检测网络状态失败
- Web组件中如何通过手势滑动返回上一个Web页面
- WebView中，双向交互可以使用JSBridge技术，也可以使用端口通信技术，这两者有什么区别
- 注册的自定义字体在 webview 中无效
- Web组件加载某个页面，出现白屏、页面显示不出来，如何解决和定位
- javaScriptProxy和registerJavaScriptProxy有什么区别，能注册多少个对象
- Webview的runJavaScript和runJavaScriptExt有什么区别，在页面生命周期（如onPageShow、onPageEnd）的什么时候进行调用
- 通过网络请求而来的 Cookie 如何同步配置到web中
- 多个Cookie如何进行批量设置
- 登录信息的cookie应该在什么时机注入？如何确保刚刚打开的web能注入登录信息cookie
- 如何控制只在Web组件第一次加载url的时候触发onPageBegin，onPageEnd
- 如何实现Web和Webview对前端常用框架（如Vue，React）的适配
- 如何在Web请求时添加header头
- Web组件对H5页面、常用框架VUE、React的页面支持情况，包括本地和网络端的页面
- Web组件如何访问本地的资源文件，并添加查询参数
- 如何判断Web滑动到了顶部/底部，并且把滑动事件传递给页面
- 在Web组件的H5页面中，如何使用a标签实现打开各种页面
- Web加载的H5页面跳转后，如何避免原有页面注册的资源被清空
- Web组件使用rawFile加载离线html时,如何在url后拼接参数
- 如何在webview中使用H5中的alert
- HarmonyOS是否支持web内核独立升级
- 是否支持使用第三方的webview内核
- webview是否支持CodeCache
- 动态创建web组件应该在什么场景下使用，性能如何
- 如何查看cookie的保存位置
- PDF预览如何隐藏PDF操作按钮栏
- 如何解决webview离线加载白屏问题
- 如何解决webview loaddata白屏问题
- 能否同步webview的cookie与app中的cookie
- Web组件中，如何在DOM树加载前后运行JS脚本
- 如何全局存储WebController
- 如何解决，webview每次调试都需要寻找进程号
- 使用Web组件，在哪个回调事件中可以设置自定义用户代理
- 如何使用web中的userAgent区别当前使用的设备类型是手机还是电脑
- 系统目前是否支持webrtc的功能，规格是什么
- web拦截如何处理文件
- WebView如何设置mixcontent策略，用以解决http与https混合加载的问题
- Web组件加载发生错误对应错误码如何获取
- 如何适配网页内播放器全屏
- Web组件是否支持通过URL Scheme协议跳转其它App
- 如何设置request.agent.Config中saveas参数
- 如何使用Web组件下载pdf文件并展示给用户
- HarmonyOS Webview如何实现透明效果
- Web组件的滚动条能否设置隐藏
- Webview 目前支持预览什么文件
- web组件访问过程中的illegal、fraud、risk和warning这4个风险等级区别是什么？是否可以自定义
- 有无api判断web组件是否与controller绑定
- 在onInterceptRequest接口中，如何异步处理响应数据
- 在onInterceptRequest接口中，通过request.getRequestHeader()可以获取所有的请求头吗
- Web组件是否有加载PDF失败时的监听或者回调方法
- Webview如何加载带有#路由的链接
- Webview设置UA的时候为什么accessBackward返回都是false
- WebviewController的getPageHeight方法在哪个生命周期函数中调用
- ArkWeb组件是否支持深拷贝
- ArkWeb如何适配多种设备
- Web组件什么时候进行内存回收

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-2
爬取时间: 2025-05-08 05:51:00
来源: Huawei Developer


Web组件的onLoadIntercept的不同返回结果对应不同的操作：

- onLoadIntercept返回true则直接拦截URL请求。
- onLoadIntercept返回false走onInterceptRequest回调。

参考链接


onloadIntercept


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-3
爬取时间: 2025-05-08 05:51:10
来源: Huawei Developer


问题现象


Web组件设置onKeyEvent监听键盘事件，键盘按下或抬起该事件不触发。


解决措施


onKeyEvent为通用事件，当前Web组件不支持通用事件。Web组件监听键盘事件可以使用onInterceptKeyEvent回调函数。


参考链接


onInterceptKeyEvent


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-4
爬取时间: 2025-05-08 05:51:20
来源: Huawei Developer


问题现象


onInterceptRequest拦截页面Web的src的链接后返回自定义HTML，但是自定义HTML文件里面的script标签里的内容没有加载。


解决措施


设置拦截器时，如果只设置setResponseData，内核将无法识别到这是个HTML文件，需要同时设置setResponseEncoding、setResponseMimeType、setResponseHeader等参数。参考代码如下：


```less
Web({ src: 'www.example.com', controller: this.controller }) 
  .onInterceptRequest((event) => { 
    console.log('url:' + event.request.getRequestUrl()) 
    this.responseweb = new WebResourceResponse(); 
    var head1:Header = { 
      headerKey:"Connection", 
      headerValue:"keep-alive" 
    } 
    var length = this.heads.push(head1) 
    this.responseweb.setResponseHeader(this.heads) 
    this.responseweb.setResponseData(this.webdata) 
    this.responseweb.setResponseEncoding('utf-8') 
    this.responseweb.setResponseMimeType('text/html') 
    this.responseweb.setResponseCode(200) 
    this.responseweb.setReasonMessage('OK') 
    return this.responseweb 
})
```


参考链接


WebResourceResponse


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-8
爬取时间: 2025-05-08 05:51:30
来源: Huawei Developer


问题现象


在HTML页面内通过window.navigator.onLine获取网络状态，联网和断网情况下均为false。


解决措施


配置应用获取网络信息权限： ohos.permission.GET_NETWORK_INFO


参考链接


GET_NETWORK_INFO


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-10
爬取时间: 2025-05-08 05:51:40
来源: Huawei Developer


通过重写onBackPress函数来自定义返回逻辑，使用WebviewController判断是否返回上一个Web页面。参考代码如下：


```typescript
import { webview } from '@kit.ArkWeb'; 
 
@Entry 
@Component 
struct BackPageByGesturesPage { 
  controller: webview.WebviewController = new webview.WebviewController(); 
 
  onBackPress() { 
    // 当前页面是否可前进或者后退给定的step步(-1),正数代表前进，负数代表后退 
    if (this.controller.accessStep(-1)) { 
      this.controller.backward(); // 返回上一个web页 
      // 执行用户自定义返回逻辑 
      return true; 
    } else { 
      // 执行系统默认返回逻辑，返回上一个page页 
      return false; 
    } 
  } 
 
  build() { 
    Column() { 
      Web({ src: 'http://www.example.com', controller: this.controller })//需要手动替换为真实网站 
    } 
  } 
}
```


参考链接


accessStep


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-11
爬取时间: 2025-05-08 05:51:49
来源: Huawei Developer


问题现象


这两者有什么区别，数据量的传递上有什么规格，在什么场景下选择什么方案呢？


解决措施


JSBridge是一种JavaScript与Web客户端之间的通信机制。通过JSBridge，可以在WebView中通过JavaScript代码调用客户端提供的功能，也可以从客户端中调用JavaScript函数。JSBridge可能无法满足复杂的通信需求，这时可以使用端口通信技术来实现更灵活的跨平台通信。

- 使用runJavaScript与registerJavaScriptProxy的JSBridge技术：特点：调用函数，不需要一直保持通道。使用场景：对于函数调用的场景，可以选择runJavaScript或者registerJavaScriptProxy实现。
- 特点：调用函数，不需要一直保持通道。
- 使用场景：对于函数调用的场景，可以选择runJavaScript或者registerJavaScriptProxy实现。
- 使用WebMessagePort建立端口通信：特点：建立通道，实时监听，持续消耗资源。使用场景：对于有双向通信需求的场景，对于数据实时更新，聊天应用，大文件如图片等场景建议选择端口通信技术，更加稳定。
- 特点：建立通道，实时监听，持续消耗资源。
- 使用场景：对于有双向通信需求的场景，对于数据实时更新，聊天应用，大文件如图片等场景建议选择端口通信技术，更加稳定。
- 特点：调用函数，不需要一直保持通道。
- 使用场景：对于函数调用的场景，可以选择runJavaScript或者registerJavaScriptProxy实现。
- 特点：建立通道，实时监听，持续消耗资源。
- 使用场景：对于有双向通信需求的场景，对于数据实时更新，聊天应用，大文件如图片等场景建议选择端口通信技术，更加稳定。

参考链接


应用侧调用前端页面函数


前端页面调用应用侧函数


建立应用侧与前端页面数据通道


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-16
爬取时间: 2025-05-08 05:51:59
来源: Huawei Developer


问题现象


注册的自定义字体在 webview 中无效，但是文档未说明通过 @ohos.font.registerFont 接口注册的自定义字体，在 webview 中设置对应的 family 无法正确显示对应字体，webview H5 中设置 dom style font family 也无效，文档里没有@ohos.font 注册自定义字体对 webview的规格的说明 。


解决措施


可以将字体文件放在工程rawfile目录下，在H5代码中使用@font-face指定用于显示文本的自定义字体，在指定元素中配置font-family属性设置自定义字体。


H5侧：


```less
<!DOCTYPE html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8"/> 
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/> 
    <title>Document</title> 
    <style> 
@font-face { 
  font-family: 'MaoKenWangXingYuan';src: url('./MaoKenWangXingYuan.ttf'); 
} 
#title { 
  font-family: 'MaoKenWangXingYuan'; 
} 
    </style> 
</head> 
<body> 
<h1 id="title">猫啃忘形圆</h1> 
</body> 
</html>
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-19
爬取时间: 2025-05-08 05:52:08
来源: Huawei Developer


使用Web组件时需要确认以下条件：


如果以上条件均满足，可以根据HTML的报错信息进行调试。


如果仍然出现白屏，可能是页面代码问题，开发者可以使用浏览器打开对应页面验证页面是否存在问题，或者参考使用Devtools工具调试前端页面进行调试。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-20
爬取时间: 2025-05-08 05:52:18
来源: Huawei Developer


从功能上讲，二者都可以注入JavaScript对象到window对象中，并在window对象中调用该对象的方法。


从注册对象上讲，前者只能注册一个对象，后者可以注册多个对象。


从生命周期上讲，javaScriptProxy在Web组件初始化调用，registerJavaScriptProxy在Web组件初始化完成后调用。


从接口上讲，javaScriptProxy是Web组件的方法，而registerJavaScriptProxy是WebviewController的方法。


javaScriptProxy可以参考javaScriptProxy，registerJavaScriptProxy可以参考registerJavaScriptProxy


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-21
爬取时间: 2025-05-08 05:52:26
来源: Huawei Developer


从功能上讲，二者都可以异步执行JavaScript脚本，并通过回调方式或Promise方式返回脚本执行的结果。


区别上讲，runJavaScript返回脚本执行的结果只能是string，而runJavaScriptExt可以返回的类型支持JsMessageType，包括字符串、数组类型等。


runJavaScript参数：


| 参数名  | 类型  | 必填  | 说明  |
| --- | --- | --- | --- |
| script  | string  | 是  | JavaScript脚本。  |
| callback  | AsyncCallback<string>  | 是  | 回调执行JavaScript脚本结果。JavaScript脚本若执行失败或无返回值时，返回null。  |

参数名


类型


必填


说明


script


string


是


JavaScript脚本。


callback


AsyncCallback<string>


是


回调执行JavaScript脚本结果。JavaScript脚本若执行失败或无返回值时，返回null。


runJavaScriptExt参数：


| 参数名  | 类型  | 必填  | 说明  |
| --- | --- | --- | --- |
| script  | string  | 是  | JavaScript脚本。  |
| callback  | AsyncCallback<JsMessageExt>  | 是  | 回调执行JavaScript脚本结果。  |

参数名


类型


必填


说明


script


string


是


JavaScript脚本。


callback


AsyncCallback<JsMessageExt>


是


回调执行JavaScript脚本结果。


从调用时间上讲，二者都需要在loadUrl完成后，比如onPageEnd中调用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-24
爬取时间: 2025-05-08 05:52:36
来源: Huawei Developer


获取到的cookie利用WebCookieManager提供的configCookieSync方法与configCookie方法可以实现对Cookie值的同步与异步设置，这样将请求而来的cookie同步到web中。


```typescript
import { webview } from '@kit.ArkWeb' 
@Entry 
@Component 
struct WebComponent { 
  controller: webview.WebviewController = new webview.WebviewController(); 
  headers : Array<webview.WebHeader> = [{ headerKey : "msg",headerValue : 'hello'}]; 
  build() { 
    Column() { 
      Button('configCookieSync') 
        .onClick(() => { 
          try { 
            webview.WebCookieManager.configCookieSync('https://www.example.com', 'a=b,c=d,e=f'); 
          } catch (error) { 
            console.error(`ErrorCode: ${error.code},  Message: ${error.message}`); 
          } 
        }) 
      Button('fetchCookieSync') 
        .onClick(() => { 
          try { 
            let value = webview.WebCookieManager.fetchCookieSync('https://www.example.com'); 
            console.log("fetchCookieSync cookie = " + value); 
          } catch (error) { 
            console.error(`ErrorCode: ${error.code},  Message: ${error.message}`); 
          } 
        }) 
      Column() { 
        Web({ src: 'www.example.com', controller: this.controller }) 
          .width('100%') 
          .height('100%') 
      } 
      .layoutWeight(1) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-25
爬取时间: 2025-05-08 05:52:46
来源: Huawei Developer


WebCookieManager提供了configCookieSync方法与configCookie方法支持对Cookie值的同步与异步设置，但接口目前不支持一次性批量设置多个cookie，只能通过configCookie或configCookieSync多次设置cookie来实现多个cookie的设置。


```typescript
import { webview } from '@kit.ArkWeb';


webview.once("webInited", () => {
  console.info("webInited setCookie");
  webview.WebCookieManager.configCookie("https://www.example.com", 'a=b');
  webview.WebCookieManager.configCookie("https://www.example.com", 'c=d');
  webview.WebCookieManager.configCookie("https://www.example.com", 'e=f');
})


@Entry
@Component
struct LoginCookieConfig {
  controller: webview.WebviewController = new webview.WebviewController();


  build() {
    Column() {
      Button('fetchCookieSync')
        .onClick(() => {
          try {
            let value = webview.WebCookieManager.fetchCookieSync('https://www.example.com');
            console.log(`fetchCookieSync cookie value is: ${value}`);
          } catch (error) {
            console.error(`fetchCookieSync failed,error is: ${JSON.stringify(error)}`);
          }
        })
      Web({ src: 'www.example.com', controller: this.controller })
    }
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-26
爬取时间: 2025-05-08 05:52:55
来源: Huawei Developer


once可以订阅一次指定类型Web事件的回调。一般在web初始化完成后可以注入。


```typescript
import { webview } from '@kit.ArkWeb' 
 
webview.once("webInited", () => { 
  console.log("setCookie"); 
  webview.WebCookieManager.configCookie("https://www.example.com", 'a=b,c=d,e=f'); 
}) 
 
@Entry 
@Component 
struct WebComponent { 
  controller: webview.WebviewController = new webview.WebviewController(); 
 
  build() { 
    Column() { 
      Web({ src: 'www.example.com', controller: this.controller }) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-34
爬取时间: 2025-05-08 05:53:05
来源: Huawei Developer


可以使用onAppear事件来控制只在第一次加载url时触发onPageBegin，onPageEnd，参考代码如下：


```typescript
import { webview } from '@kit.ArkWeb'; 
 
@Entry 
@Component 
struct OnlyOnTheFirstTrigger { 
  controller: webview.WebviewController = new webview.WebviewController(); 
  isFirst: boolean = false; 
 
  build() { 
    Column() { 
      Web({ 
        src: 'www.example.com', controller: this.controller 
      }) 
        .onAppear(() => { 
          this.isFirst = true; 
        }) 
        .onPageBegin(() => { 
          if (this.isFirst) { 
            this.isFirst = false; 
            console.info('test isFirst'); 
          } 
        }) 
    } 
    .width('100%') 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-35
爬取时间: 2025-05-08 05:53:15
来源: Huawei Developer


以Vue工程为例，使用runJavaScript API与javaScriptProxy API实现与Vue工程的交互。

- runJavaScript API用于异步执行JavaScript脚本，并通过回调方式返回脚本执行的结果。
- javaScriptProxy API用于注入JavaScript对象到window对象中，并在window对象中调用该对象的方法。
- 可以将Vue中的方法挂在到JavaScript脚本的document对象上，实现Vue与JavaScript脚本的交互。

参考链接


runJavaScript，javaScriptProxy


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-37
爬取时间: 2025-05-08 05:53:25
来源: Huawei Developer


可以通过loadUrl方法设置headers、loadUrl有两个参数：其中url表示需要加载的URL，headers表示URL的附加HTTP请求头。


```less
// 带参数headers 
this.controller.loadUrl('www.example.com', [{ headerKey: "headerKey", headerValue: "headerValue" }]);
```


参考链接


loadUrl


WebHeader


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-38
爬取时间: 2025-05-08 05:53:35
来源: Huawei Developer


Web组件支持H5页面及常用框架VUE和React。


Web组件支持加载网络页面、本地页面及HTML格式的文本数据，详细说明及代码实现可参考使用Web组件加载页面。


加载VUE及React项目时，先使用“npm run build”命令将项目打包，后通过加载本地页面方式进行加载；若上传至服务器，可通过加载网络页面方式进行加载。


具体可参考如下示例代码：


```typescript
// xxx.ets 
import { webview } from '@kit.ArkWeb';


@Entry
@Component
struct WebComponent {
  webviewController: webview.WebviewController = new webview.WebviewController();


  build() {
    Column() {
      Button('loadUrl').onClick(() => {
        try { // 点击按钮时，通过loadUrl，跳转到www.example1.com            
          this.webviewController.loadUrl('www.example1.com');
        } catch (error) {
          console.error(`ErrorCode: ${error.code},  Message: ${error.message}`);
        }
      })
      // 组件创建时，加载www.example.com       
      Web({ src: 'www.example.com', controller: this.webviewController })
    }
  }
}
```

1.  在“src\main\resources\rawfile”文件夹下创建local.html和local1.html：

```typescript
import { webview } from '@kit.ArkWeb';


@Entry
@Component
struct WebComponent {
  webviewController: webview.WebviewController = new webview.WebviewController();


  build() {
    Column() {
      Button('loadUrl')
        .onClick(() => {
          try {
            // 点击按钮时，通过resource加载resources/rawfile目录下的local1.html文件
            this.webviewController.loadUrl('resource://rawfile/local1.html');
          } catch (error) {
            console.error(`ErrorCode: ${error.code},  Message: ${error.message}`);
          }
        })
      // 组件创建时，使用resource协议加载本地文件local.html
      Web({ src: 'resource://rawfile/local.html', controller: this.webviewController })
    }
  }
}
```


```typescript
import { webview } from '@kit.ArkWeb';


@Entry
@Component
struct WebComponent {
  controller: webview.WebviewController = new webview.WebviewController();


  build() {
    Column() {
      Button('loadData')
        .onClick(() => {
          try {
            // 点击按钮时，通过loadData，加载HTML格式的文本数据 
            this.controller.loadData(
              "<html><body bgcolor=\"white\">Source:<pre>source</pre></body></html>",
              "text/html",
              "UTF-8"
            );
          } catch (error) {
            console.error(`ErrorCode: ${error.code},  Message: ${error.message}`);
          }
        })
      // 组件创建时，加载www.example.com 
      Web({ src: 'www.example.com', controller: this.controller })
    }
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-39
爬取时间: 2025-05-08 05:53:45
来源: Huawei Developer


本地资源文件可存放在模块的“src\main\resources\rawfile”文件夹下，在ets文件中通过$rawfile('文件名')访问。


目前不支持直接添加查询参数，可以通过Web组件加载一个HTML文件，通过window.location.href跳转到带有参数的本地HTML页面。具体可参考示例代码：


```less
import { webview } from '@kit.ArkWeb'; 
 
@Entry 
@Component 
struct WebComponent { 
  controller: webview.WebviewController = new webview.WebviewController(); 
 
  build() { 
    Column() { 
      Web({ src: $rawfile('index.html'), controller: this.controller }) 
        .javaScriptAccess(true) 
    } 
  } 
}
```


在“src\main\resources\rawfile”文件夹下创建index.html文件和details.html。


index.html：


```less
<!DOCTYPE html> 
<html> 
<head> 
    <script type="text/javascript"> window.onload = function() { window.location.href = "details.html"; } 
    </script> 
</head> 
<body></body> 
</html>
```


details.html：


```less
<!DOCTYPE html> 
<html> 
<head><title>详情页</title></head> 
<body><h1>欢迎来到详情页！</h1> 
<p>您已成功从首页跳转到此页，并在URL中添加了参数。</p></body> 
</html>
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-40
爬取时间: 2025-05-08 05:53:54
来源: Huawei Developer


通过Web组件的onOverScroll事件可以判断Web滑动到了顶部/底部。该接口可以通知网页过滚动偏移量，如果yOffset<0，即页面到达顶端；如果yOffset>0，即页面到达底端。


传递滑动事件可参考Web组件嵌套滚动，将Web组件内嵌于可滚动容器中，使用nestedScroll属性设置嵌套滚动选项，达到传递滑动事件给页面的效果。具体可参考代码示例：


```less
import { webview } from '@kit.ArkWeb'; 
 
@Entry 
@Component 
struct Index { 
  private scrollerForScroll: Scroller = new Scroller(); 
  controller: webview.WebviewController = new webview.WebviewController; 
  @State ScrollDirection: ScrollDirection = ScrollDirection.Vertical; 
  title = '2023落下帷幕，一起迎接2024年***********************************************'; 
  review = '评论'; 
  context = '一起迎接2024年，***********************************************************************************'; 
  list = [0, 0, 0, 0]; 
 
  build() { 
    Flex() { 
      Scroll(this.scrollerForScroll) { 
        Column({ space: 5 }) { 
          Text(this.title) 
            .fontSize(40) 
            .padding(40) 
          List() { 
            ForEach(this.list, () => { 
              ListItem() { 
                Text(this.context).fontSize(16) 
              } 
            }) 
          } 
 
          Web({ src: $rawfile('index.html'), controller: this.controller }) 
            .nestedScroll({ 
              scrollForward: NestedScrollMode.SELF_FIRST, 
              scrollBackward: NestedScrollMode.SELF_FIRST 
            }) 
            .height('100%') 
            .width('100%') 
            .layoutMode(WebLayoutMode.FIT_CONTENT) 
          Text(this.review) 
            .fontSize(30) 
          List() { 
            ForEach(this.list, () => { 
              ListItem() { 
                Text(this.context) 
                  .fontSize(16) 
              } 
            }) 
          } 
        } 
        .width('95%') 
      } 
      .scrollBar(BarState.Off) 
      .width('100%') 
      .height('120%') 
      .scrollable(this.ScrollDirection) 
    } 
    .width('100%') 
    .height('100%') 
 
  } 
}
```


在“src\main\resources\rawfile”文件夹下创建index.html：


```less
<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8"> 
    <meta name="viewport" 
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"> 
    <meta http-equiv="X-UA-Compatible" content="ie=edge"> 
    <title>Document</title> 
</head> 
<body> 
<ol> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
    <li>欢度佳节，********************************************************</li> 
    <li>********************************************************</li> 
</ol> 
</body> 
</html>
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-41
爬取时间: 2025-05-08 05:54:04
来源: Huawei Developer


情况一：跳转本应用的ArkTS页面


实现逻辑为，使用Web组件的onLoadIntercept来监测Web组件加载url,然后通过回调结果做判断是否为跳转本地ArkTS页面，如果是，使用router做跳转。


参数可以通过获取url然后做字符串操作获取。


ArkTS页面一：


```typescript
import { webview } from '@kit.ArkWeb'; 
import { router } from '@kit.ArkUI'; 
 
@Entry 
@Component 
struct WebComponent { 
  controller: webview.WebviewController = new webview.WebviewController(); 
  build() { 
    Column() { 
      Column() { 
        Web({ src: $rawfile('hello.html'), controller: this.controller }) 
          .onLoadIntercept((event) => { 
            if(event){ 
              let url = event.data.getRequestUrl(); 
              console.log(url); 
              if(url.indexOf('native://') === 0){ 
                router.pushUrl({ url : url.substring(9)}) 
                return true; 
              } 
            } 
            return false; 
          }) 
          .width('100%') 
          .height('100%') 
      } 
      .layoutWeight(1) 
    } 
  } 
}
```


ArkTS页面二：


```less
@Entry 
@Component 
struct Second { 
  build() { 
    Column() { 
      Text('这是本应用的第二个页面') 
    } 
  } 
}
```


H5侧


```less
<!DOCTYPE html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" /> 
    <meta http-equiv="X-UA-Compatible" content="IE=edge" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0 maximum-scale=1.0, user-scalable=no" /> 
    <title>Document</title> 
</head> 
<body> 
<div id="bg"> 
   hello world!<br> 
   <a href="native://pages/Second">跳转至本应用第二个arkts页面</a> 
</div> 
</body> 
</html>
```


情况二：跳转本应用的H5页面


实现逻辑为，使用相对路径定位第二个H5页面即可。


H5侧页面一：


```less
<!DOCTYPE html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" /> 
    <meta http-equiv="X-UA-Compatible" content="IE=edge" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0 maximum-scale=1.0, user-scalable=no" /> 
    <title>Document</title> 
</head> 
<body> 
<div id="bg"> 
   hello world!<br> 
    <a href="Second.html">跳转至本应用第二个H5页面</a> 
</div> 
</body> 
</html>
```


H5侧页面二：


```less
<!DOCTYPE html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" /> 
    <meta http-equiv="X-UA-Compatible" content="IE=edge" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0 maximum-scale=1.0, user-scalable=no" /> 
    <title>Document</title> 
</head> 
<body> 
<div id="bg"> 
    hello world 
    <br> 
    <br> 
    我是本应用的第二个H5页面 
</div> 
</body> 
</html>
```


情况三：跳转至系统应用页面


实现逻辑为，在a标签的url中存储系统应用的url，然后使用startAbility打开系统应用，完成跳转。


ArkTS页面：


```typescript
import { webview } from '@kit.ArkWeb' 
import { common } from '@kit.AbilityKit'; 
import { Want } from '@kit.AbilityKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
function startSettingsInfo(context: common.UIAbilityContext,uri : string): void { 
  let want: Want = { 
    bundleName: 'com.huawei.hmos.settings', 
    abilityName: 'com.huawei.hmos.settings.MainAbility', 
    uri: uri 
  }; 
  context.startAbility(want) 
    .then(() => { 
      // ... 
    }) 
    .catch((err: BusinessError) => { 
      console.error(`Failed to startAbility. Code: ${err.code}, message: ${err.message}`); 
    }); 
} 
@Entry 
@Component 
struct WebComponent { 
  context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext; 
  controller: webview.WebviewController = new webview.WebviewController(); 
  build() { 
    Column() { 
      Column() { 
        Web({ src: $rawfile('hello.html'), controller: this.controller }) 
          .onLoadIntercept((event) => { 
            if(event){ 
              let url = event.data.getRequestUrl(); 
              console.log(url); 
              if(url.indexOf('hmos://') === 0){ 
                startSettingsInfo(this.context,url.substring(7)) 
                return true; 
              } 
            } 
            return false; 
          }) 
          .width('100%') 
          .height('100%') 
      } 
      .layoutWeight(1) 
    } 
  } 
}
```


H5侧：


```less
<!DOCTYPE html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" /> 
    <meta http-equiv="X-UA-Compatible" content="IE=edge" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0 maximum-scale=1.0, user-scalable=no" /> 
    <title>Document</title> 
 
</head> 
<body> 
<div id="bg"> 
   hello world!<br> 
    <a href="hmos://volume_settings">跳转至系统应用（以声音与震动为例）</a> 
</div> 
</body> 
</html>
```


情况四：跳转至三方应用页面


实现逻辑为，使用Web组件的onLoadIntercept来监测Web组件加载url,然后获取url并判断是否跳转三方应用，然后使用startAbility打开三方应用，完成跳转。


ArkTS页面


```typescript
import { webview } from '@kit.ArkWeb' 
import { common } from '@kit.AbilityKit'; 
import { Want } from '@kit.AbilityKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
@Entry 
@Component 
struct WebComponent { 
  controller: webview.WebviewController = new webview.WebviewController(); 
  build() { 
    Column() { 
      Column() { 
        Web({ src: $rawfile('hello.html'), controller: this.controller }) 
          .onLoadIntercept((event) => { 
            let context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext; // UIAbilityContext 
            let want: Want = { 
              deviceId: '', // deviceId为空表示本设备 
              bundleName: '***', // 想要跳转的三方应用的bundleName 
              moduleName: 'entry', // moduleName非必选 
              abilityName: 'EntryAbility', 
              parameters: { 
                // 自定义参数传递页面信息 
                router: 'index' 
              } 
            } 
            context.startAbility(want).then(() => { 
              console.log('success') 
            }).catch((err: BusinessError) => { 
              console.log('error:' + JSON.stringify(err)) 
            }); 
            return false; 
          }) 
      } 
      .layoutWeight(1) 
    } 
 
  } 
}
```


H5侧：


```less
<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8"> 
    <meta name="viewport" 
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"> 
    <meta http-equiv="X-UA-Compatible" content="ie=edge"> 
    <title>Document</title> 
</head> 
<body> 
<a  href="">跳转至三方应用</a> 
</body> 
</html>
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-42
爬取时间: 2025-05-08 05:54:14
来源: Huawei Developer


使用runJavaScript加载JS可能会出现跳转后注册资源被清空的情况，使用javaScriptOnDocumentStart注入JS就不会出现H5跳转注册资源被清空的情况。


使用runJavaScript复现问题代码参考：


ArkTS页面：


两个Button使用runJavaScript注册并调用test()方法和bodyOnLoadLocalStorage()，两个方法分别实现了为sessionStorage设置值和根据sessionStorage刷新H5页面。


```typescript
import { webview } from '@kit.ArkWeb'; 
 
@Entry 
@Component 
struct Index { 
  controller: webview.WebviewController = new webview.WebviewController();
 
  build() { 
    Column({ space: 20 }) { 
      Button('调用注册资源') 
        .onClick(e => { 
          try { 
            this.controller.runJavaScript( 
              'test()', 
              (error, result) => { 
                if (error) { 
                  console.error(`run JavaScript error, ErrorCode: ${error.code},  Message: ${error.message}`); 
                  return; 
                } 
                if (result) { 
                  console.info(`The test() return value is: ${result}`); 
                } 
              }); 
          } catch (error) { 
            console.error(`ErrorCode: ${error.code},  Message: ${error.message}`); 
          } 
        }) 
      Button('调用注册资源') 
        .onClick(e => { 
          try { 
            this.controller.runJavaScript( 
              'bodyOnLoadLocalStorage()', 
              (error, result) => { 
                if (error) { 
                  console.error(`run JavaScript error, ErrorCode: ${error.code},  Message: ${error.message}`); 
                  return; 
                } 
                if (result) { 
                  console.info(`The bodyOnLoadLocalStorage() return value is: ${result}`); 
                } 
              }); 
          } catch (error) { 
            console.error(`ErrorCode: ${error.code},  Message: ${error.message}`); 
          } 
        }) 
      Web({ src: $rawfile('index.html'), controller: this.controller }) 
        .javaScriptAccess(true) 
        .domStorageAccess(true) 
        .backgroundColor(Color.Grey) 
        .width('100%') 
        .height('100%') 
    } 
  } 
}
```


H5侧：


页面一：


index.html声明了test方法和bodyOnLoadLocalStorage方法。


```less
<!-- index.html --> 
<!DOCTYPE html> 
<html> 
<head> 
  <meta charset="utf-8"> 
</head> 
<body style="font-size: 30px;" onload='bodyOnLoadLocalStorage()'> 
页面一：”Hello world! 
<div id="result"></div> 
<a href="Second.html">点击跳转</a> 
</body> 
<script type="text/javascript"> 
    function bodyOnLoadLocalStorage() { 
      if (typeof(Storage) !== 'undefined') { 
        document.getElementById('result').innerHTML = sessionStorage.getItem('color'); 
      } else { 
        document.getElementById('result').innerHTML = 'Your browser does not support sessionStorage.'; 
      } 
    } 
    function test(){ 
      if (typeof(Storage) !== 'undefined') { 
        sessionStorage.setItem('color', 'Red'); 
      } 
    } 
  </script> 
</html>
```


页面二：


页面二并不声明上述两个方法，利用之前的注册调用，结果跳转至页面二后不能正确调用，注册资源清空问题复现。


```less
<!-- Second.html --> 
<!DOCTYPE html> 
<html> 
<head> 
    <meta charset="utf-8"> 
</head> 
<body style="font-size: 30px;"> 
页面二：Hello world! 
<div id="result"></div> 
</body> 
<script type="text/javascript"> 
 
</script> 
</html>
```


使用javaScriptOnDocumentStart解决问题代码参考：


ArkUI侧


通过javaScriptOnDocumentStart的方式将test方法执行。


```less
import { webview } from '@kit.ArkWeb'; 
 
@Entry 
@Component 
struct Index { 
  controller: webview.WebviewController = new webview.WebviewController(); 
  private localStorage: string = 
    "if (typeof(Storage) !== 'undefined') {" + 
      "   sessionStorage.setItem('color', 'Red');" + 
      "}"; 
  @State scripts: Array<ScriptItem> = [ 
    { script: this.localStorage, scriptRules: ["*"] } 
  ];
 
  build() { 
    Column({ space: 20 }) { 
      Web({ src: $rawfile('index.html'), controller: this.controller }) 
        .javaScriptAccess(true) 
        .domStorageAccess(true) 
        .backgroundColor(Color.Grey) 
        .javaScriptOnDocumentStart(this.scripts) 
        .width('100%') 
        .height('100%') 
    } 
  } 
}
```


H5侧：


页面一：


页面一会调用bodyOnLoadLocalStorage刷新H5页面。


```less
<!-- index.html --> 
<!DOCTYPE html> 
<html> 
<head> 
  <meta charset="utf-8"> 
</head> 
<body style="font-size: 30px;" onload='bodyOnLoadLocalStorage()'> 
页面一：”Hello world! 
<div id="result"></div> 
<a href="Second.html">点击跳转</a> 
</body> 
<script type="text/javascript"> 
    function bodyOnLoadLocalStorage() { 
      if (typeof(Storage) !== 'undefined') { 
        document.getElementById('result').innerHTML = sessionStorage.getItem('color'); 
      } else { 
        document.getElementById('result').innerHTML = 'Your browser does not support sessionStorage.'; 
      } 
    } 
  </script> 
</html>
```


页面二：


点击跳转后test方法依旧会调用并生效。


```less
<!-- Second.html --> 
<!DOCTYPE html> 
<html> 
<head> 
    <meta charset="utf-8"> 
</head> 
<body style="font-size: 30px;" onload='bodyOnLoadLocalStorage()'> 
页面二：Hello world! 
<div id="result"></div> 
</body> 
<script type="text/javascript"> 
    function bodyOnLoadLocalStorage() { 
      if (typeof(Storage) !== 'undefined') { 
        document.getElementById('result').innerHTML = sessionStorage.getItem('color'); 
      } else { 
        document.getElementById('result').innerHTML = 'Your browser does not support sessionStorage.'; 
      } 
    } 
  </script> 
</html>
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-45
爬取时间: 2025-05-08 05:54:23
来源: Huawei Developer


使用Web组件加载时可以直接使用url拼接参数，加载后在H5侧获取并使用。


参考代码


通过Web组件使用rawFile加载离线html,使用的url拼接了参数。


```typescript
import { webview } from '@kit.ArkWeb' 
 
@Entry 
@Component 
struct WebComponent { 
  controller: webview.WebviewController = new webview.WebviewController() 
 
  build() { 
    Column() { 
      Web({ src: 'resource://rawfile/LoadingURLTransferParameters.html?key=value', controller: this.controller }) 
        .javaScriptAccess(true) 
        .domStorageAccess(true) 
    } 
    .width('100%') 
    .height('100%') 
  } 
}
```


H5侧通过如下方式可以获取到url中的参数并使用。


```less
<!DOCTYPE html> 
<html> 
<head> 
    <title>Parameter-based HTML</title> 
</head> 
<body> 
<h1>Welcome!</h1> 
<h1 id="params"></h1> 
 
<script> 
function getParams() { 
    var params = {}; 
    window.location.search.substring(1).split('&').forEach(function(param) { 
        var pair = param.split('='); 
        params[pair[0]] = decodeURIComponent(pair[1]); 
    }); 
    return params; 
} 
document.getElementById('params').innerHTML = JSON.stringify(getParams()); 
</script> 
</body> 
</html>
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-46
爬取时间: 2025-05-08 05:54:33
来源: Huawei Developer


参考代码


使用Web组件的onAlert属性可以监测网页触发alert()告警弹窗事件，之后使用AlertDialog实现弹窗的效果与逻辑。


```less
import { webview } from '@kit.ArkWeb'; 
 
@Entry 
@Component 
struct WebviewAlert { 
  controller: webview.WebviewController = new webview.WebviewController(); 
 
  build() { 
    Column() { 
      Web({ src: $rawfile('WebviewAlert.html'), controller: this.controller }) 
        .onAlert((event) => { 
          if (event) { 
            console.log('event.url:' + event.url); 
            console.log('event.message:' + event.message); 
            AlertDialog.show({ 
              title: 'onAlert', 
              message: 'text', 
              primaryButton: { 
                value: 'cancel', 
                action: () => { 
                  event.result.handleCancel(); 
                } 
              }, 
              secondaryButton: { 
                value: 'ok', 
                action: () => { 
                  event.result.handleConfirm(); 
                } 
              }, 
              cancel: () => { 
                event.result.handleCancel(); 
              } 
            }) 
          } 
          return true; 
        }) 
    } 
  } 
}
```


H5侧：


```less
<!DOCTYPE html> 
<html> 
<head> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0" charset="utf-8"> 
</head> 
<body> 
<h1>WebView onAlert Demo</h1> 
<button onclick="myFunction()">Click here</button> 
<script> 
    function myFunction() { 
      alert("Hello World"); 
    } 
  </script> 
</body> 
</html>
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-48
爬取时间: 2025-05-08 05:54:43
来源: Huawei Developer


支持，不需要跟随版本升级才能升级。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-49
爬取时间: 2025-05-08 05:54:52
来源: Huawei Developer


目前还不兼容其他第三方内核。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-51
爬取时间: 2025-05-08 05:55:01
来源: Huawei Developer

- webview默认支持运行时生成code cache，无需应用做操作。当前不支持开发阶段生成code cache。
- webview当前不兼容其他环境生成的code cache。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-52
爬取时间: 2025-05-08 05:55:11
来源: Huawei Developer


使用场景：动态创建web组件是用来解决加载白屏的问题。比如：有三个页面要来回切换，每个页面都是一个web组件，那么每次页面切换都会初始化web组件，这样会消耗大量资源，如果加载缓慢会产生白屏，就会降低用户体验。


性能：动态加载是在非UI线程中做的，数量大的时候对现有webview加载有一定影响，后台启动的Web实例不建议超过200个。


参考链接


使用Web组件加载页面


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-53
爬取时间: 2025-05-08 05:55:22
来源: Huawei Developer


Cookie信息保存在应用沙箱路径下/proc/{pid}/root/data/storage/el2/base/cache/web/Cookies的文件中。


参考链接


管理Cookie及数据存储


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-54
爬取时间: 2025-05-08 05:55:32
来源: Huawei Developer


解决措施


在url中加入隐藏PDF操作栏按钮的参数#toolbar=0&navpanes=0，使用Web加载即可。


参考代码


```less
import { webview } from '@kit.ArkWeb'; 
 
@Entry 
@Component 
struct HidePDFToolbar { 
  controller: webview.WebviewController = new webview.WebviewController(); 
 
  build() { 
    Column() { 
      Web({ src: 'resource://rawfile/test.pdf#toolbar=0&navpanes=0', controller: this.controller }) 
        .domStorageAccess(true) 
        .width('100%') 
        .height('100%') 
    } 
    .width('100%') 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-56
爬取时间: 2025-05-08 05:55:41
来源: Huawei Developer


问题场景：


web容器加载html调用全屏接口，在跳转5次后，第六次跳转会出现web白屏。使用最新特性离线组件，离线组件中的Text标签正常展示，但是web容器中的html展示异常，而且确定组件树上有web节点。如果不调全屏接口，跳转页面正常，跳转多次也不会白屏。


解决方案：


在每次创建好web实例，调用loadurl时，设置WebController的onActive方法主动激活状态即可解决此问题。需要应用调用相关接口。离线web释放需要先对使用的framenode进行释放，才可析构离线web组件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-57
爬取时间: 2025-05-08 05:55:51
来源: Huawei Developer


loaddata使用不同的参数会有不同的效果，如果参数不对可能会造成白屏现象。如果html中存在非法字符，例如css中的color："#333"，有"#"的时候会加载不了，需要使用文档中提供的加载本地资源的方法，后面两个参数要复制空格" "，" "。具体实现可参考loadData。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-58
爬取时间: 2025-05-08 05:56:00
来源: Huawei Developer


一般情况下，App和Web组件的请求是使用不同的Cookie来进行身份验证和会话管理的，因为它们是不同的应用程序，具有不同的域名和会话上下文。但是，如果App和Web组件是在同一个域名下运行的，那么它们可能会共享Cookie。例如，如果您在Web浏览器中登录了一个网站，并且该网站还有一个App，那么该App可能会使用与Web浏览器相同的Cookie来验证您的身份和管理会话。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-59
爬取时间: 2025-05-08 05:56:10
来源: Huawei Developer


在文档加载之前注入js脚本可以使用javaScriptOnDocumentStart，在文档加载之后注入js脚本可以使用javaScriptOnDocumentEnd。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-60
爬取时间: 2025-05-08 05:56:19
来源: Huawei Developer


问题场景：


需要全局存储多个WebController对象，目前使用将map存入AppStorage的方式不生效。


解决方案：


目前AppStorage中不支持放纯map类型的数据，因为不能被JSON序列化，可以改为放数组类型的。或者可以将map转换为string类型，因为AppStorage只支持存储String类型的数据。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-61
爬取时间: 2025-05-08 05:56:28
来源: Huawei Developer


问题背景：


在研发过程中，经常需要调试应用中的Web页面，使用Web调试工具Devtools，每次启动都需要重新映射端口。


解决方案：


可以参考如下示例代码，文件内容写好后，把文件改成bat后缀，每次开启调试之后，运行bat文件即可自行获取进程号。


```less
// xxx.bat 
@echo off 
setlocal 
 
:: Set devtools parameter 
hdc shell param set web.debug.devtools true 
if errorlevel 1 ( 
    echo Error: Failed to set devtools parameter. 
    pause 
    exit /b 
) 
 
:: Get the domain socket name of devtools 
for /f "tokens=*" %%a in ('hdc shell "cat /proc/net/unix | grep devtools"') do set SOCKET_NAME=%%a 
if not defined SOCKET_NAME ( 
    echo Error: Failed to get the domain socket name of devtools. 
    pause 
    exit /b 
) 
 
:: Extract process ID 
for /f "delims=_ tokens=4" %%a in ("%SOCKET_NAME%") do set PID=%%a 
if not defined PID ( 
    echo Error: Failed to extract process ID. 
    pause 
    exit /b 
) 
 
:: Add mapping 
hdc fport tcp:9222 localabstract:webview_devtools_remote_%PID% 
if errorlevel 1 ( 
    echo Error: Failed to add mapping. 
    pause 
    exit /b 
) 
 
:: Check mapping 
hdc fport ls 
 
echo. 
echo Script executed successfully. Press any key to exit... 
pause >nul 
 
:: 尝试在 Edge 中打开页面 
start msedge chrome://inspect/#devices.com 
 
:: 如果 Edge 不可用，那么在 Chrome 中打开页面 
if errorlevel 1 ( 
    start chrome chrome://inspect/#devices.com 
) 
 
endlocal
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-62
爬取时间: 2025-05-08 05:56:38
来源: Huawei Developer


建议在onControllerAttached回调事件中，使用setCustomUserAgent来设置自定义用户代理。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-63
爬取时间: 2025-05-08 05:56:48
来源: Huawei Developer


web组件中支持自定义userAgent，一种是在原有userAgent基础上加上一个字符串，还有一种是自定义的userAgent，二者都可以通过加入特定的字符串进行判断是当前设备类型手机还是电脑。


参考代码如下：


```typescript
import { webview } from '@kit.ArkWeb'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
@Entry 
@Component 
export struct WebUserAgent { 
  controller: webview.WebviewController = new webview.WebviewController(); 
 
  build() { 
    Column() { 
      Button('getUserAgent') 
        .onClick(() => { 
          try { 
            let userAgent = this.controller.getUserAgent(); 
            console.log("userAgent: " + userAgent); 
          } catch (error) { 
            let e: BusinessError = error as BusinessError; 
            console.error(`ErrorCode: ${e.code},  Message: ${e.message}`); 
          } 
        }) 
      Web({ src: 'www.example.com', controller: this.controller }) 
    } 
  } 
}
```


参考链接


getUseragent


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-64
爬取时间: 2025-05-08 05:56:58
来源: Huawei Developer


1. WebView支持webrtc的P-P功能以及音视频流功能。


2. 非WebView场景，HarmonyOS不直接提供webrtc，但会提供技术支持，比如支持三方gn+ninja交叉编译方式适配webrtc，包含以下两点：

- sdk支持gn+ninja交叉编译方式
- 提供编译样例指导

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-66
爬取时间: 2025-05-08 05:57:08
来源: Huawei Developer


问题描述


当拦截到图片请求时，想通过response.setResponseData()方法返回本地沙盒内的图片文件，但是setResponseData方法仅支持string/number/Resource参数，沙盒的图片文件应该如何正确返回给Web使用 ？


解决措施


当前response.setResponseData()方法已支持ArrayBuffer参数类型,可以支持图片、字体、音频、视频类型。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-67
爬取时间: 2025-05-08 05:57:18
来源: Huawei Developer


ArkWeb提供mixedMode(mixedMode: MixedMode)接口，设置是否允许加载超文本传输协议（HTTP）和超文本传输安全协议（HTTPS）混合内容，默认不允许加载HTTP和HTTPS混合内容。


需要在工程中的module.json5配置文件中添加网络访问权限ohos.permission.INTERNET。


参考代码如下：


```less
// xxx.ets 
import { webview } from '@kit.ArkWeb'; 
 
@Entry 
@Component 
struct WebComponent { 
  controller: webview.WebviewController = new webview.WebviewController(); 
  @State mode: MixedMode = MixedMode.All; 
  build() { 
    Column() { 
      Web({ src: 'www.example.com', controller: this.controller }) 
        .mixedMode(this.mode) 
    } 
  } 
}
```


参考链接


mixedMode


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-70
爬取时间: 2025-05-08 05:57:27
来源: Huawei Developer


问题场景


网页加载遇到错误时触发onErrorReceive回调。回调函数会报相关错误码，想要知道相关错误码的意义。


解决措施


相关错误码可以参考ArkWeb的网络协议栈错误列表。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-71
爬取时间: 2025-05-08 05:57:37
来源: Huawei Developer


需要在工程中的module.json5配置文件中添加网络访问权限ohos.permission.INTERNET。


具体实现可参考如下代码


```typescript
import { mediaquery, window } from '@kit.ArkUI'; 
import { common } from '@kit.AbilityKit'; 
import { webview } from '@kit.ArkWeb'; 
 
@Entry 
@Component 
struct WebPlayerFullScreen { 
  @State color: string = '#DB7093'; 
  @State text: string = 'Portrait'; 
  @State portraitFunc: mediaquery.MediaQueryResult | void | null = null; 
  handler: FullScreenExitHandler | null = null; 
  // 当设备横屏时条件成立 
  listener: mediaquery.MediaQueryListener = mediaquery.matchMediaSync('(orientation: landscape)'); 
  controller: webview.WebviewController = new webview.WebviewController(); 
 
  onPortrait(mediaQueryResult: mediaquery.MediaQueryResult) { 
    // 若设备为横屏状态，更改相应的页面布局 
    if (mediaQueryResult.matches as boolean) { 
      this.color = '#FFD700'; 
      this.text = 'Landscape'; 
    } else { 
      this.color = '#DB7093'; 
      this.text = 'Portrait'; 
    } 
  } 
 
  aboutToAppear() { 
    // 绑定当前应用实例 
    // 绑定回调函数 
    this.listener.on('change', (mediaQueryResult: mediaquery.MediaQueryResult) => { 
      this.onPortrait(mediaQueryResult); 
    }); 
  } 
 
  // 改变设备横竖屏状态函数 
  private changeOrientation(isLandscape: boolean) { 
    // 获取UIAbility实例的上下文信息 
    let context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext; 
    // 调用该接口手动改变设备横竖屏状态 
    window.getLastWindow(context).then((lastWindow) => { 
      lastWindow.setPreferredOrientation(isLandscape ? window.Orientation.LANDSCAPE : window.Orientation.PORTRAIT); 
    }); 
  } 
 
  build() { 
    Column() { 
      Web({ src: 'https://developer.huawei.com/consumer/cn/design/', controller: this.controller }) 
        .javaScriptAccess(true) 
        .domStorageAccess(true) 
        .onFullScreenEnter((event) => { 
          this.handler = event.handler; 
          this.changeOrientation(true); 
        }) 
        .onFullScreenExit(() => { 
          if (this.handler) { 
            this.handler.exitFullScreen(); 
            this.changeOrientation(false); 
          } 
        }) 
    } 
    .width('100%') 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-72
爬取时间: 2025-05-08 05:57:46
来源: Huawei Developer


Web组件支持通过URL Scheme协议跳转到其它App。开发者可以通过Web组件的onLoadIntercept回调拦截默认跳转逻辑，并在其中使用Deep Linking或App Linking的方式自定义跳转逻辑完成应用跳转。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-73
爬取时间: 2025-05-08 05:57:56
来源: Huawei Developer


问题场景


是否支持通过设置saveas参数实现将下载保存路径设置为getContext(this).filesDir下？


解决措施


saveas参数在config中有较为详细的描述，saveas参数支持以下几种方式：


默认为相对路径，即下载至调用方当前缓存路径下。


所以可以通过设置saveas参数将保存路径设置为getContext(this).filesDir下。


参考代码


需要在工程中的module.json5配置文件中添加网络访问权限ohos.permission.INTERNET。


```less
import { webview } from '@kit.ArkWeb'; 
import { common } from '@kit.AbilityKit'; 
import { request } from '@kit.BasicServicesKit'; 
 
let context = getContext(this) as common.UIAbilityContext; 
let filesDir = context.filesDir; 
let config: request.agent.Config = { 
  action: request.agent.Action.DOWNLOAD, 
  url: 'https://www-file.huawei.com/minisite/media/annual_report/annual_report_2023_cn.pdf', 
  title: 'createTest', 
  description: 'Sample code for create task', 
  mode: request.agent.Mode.FOREGROUND, 
  overwrite: true, 
  method: "get", 
  saveas: filesDir + '/test.pdf', 
  network: request.agent.Network.WIFI, 
  metered: false, 
  roaming: true, 
  retry: true, 
  redirect: true, 
  index: 0, 
  begins: 0, 
  ends: -1, 
  gauge: false, 
  precise: false, 
  token: 'it is a secret' 
}; 
let createOnCallback = (progress: request.agent.Progress) => { 
  console.info('upload task progress.'); 
}; 
 
@Entry 
@Component 
struct Index { 
  controller: webview.WebviewController = new webview.WebviewController(); 
  @State uri: string = ''; 
  @State isChange: boolean = false; 
 
  build() { 
    Column() { 
      Button('刷新UI') 
        .width('200vp') 
        .onClick(() => { 
          this.controller.loadUrl('file://' + filesDir + '/test.pdf') 
        }) 
        .margin({ bottom: '20vp' }) 
      Web({ src: $rawfile('test.html'), controller: this.controller }) 
        .domStorageAccess(true) 
        .onPageBegin((event)=>{ 
          request.agent.create(getContext(), config).then((task: request.agent.Task) => { 
            task.on('progress', createOnCallback); 
            console.info(`Succeeded in creating a download task. result: ${task.config}`); 
            task.start(); 
          }).catch((err: Error) => { 
            console.error(`Failed to create a download task, message: ${err.message}`); 
          }); 
        }) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-74
爬取时间: 2025-05-08 05:58:04
来源: Huawei Developer


问题场景


需要Webview在加载某一个url时下载pdf文件并展示给用户


解决措施


加载url可以通过onLoadIntercept来区分是否下载pdf文件，下载PDF能力可以通过@ohos.request提供的request.agent.create来实现。


具体实现逻辑为：首先利用request模块提供的能力将网络PDF下载到沙箱路径下，再通过Web组件加载PDF的能力展示给用户。


需要在工程中的module.json5配置文件中添加网络访问权限ohos.permission.INTERNET。


参考代码


```less
import { webview } from '@kit.ArkWeb';
import { common } from '@kit.AbilityKit';
import { request } from '@kit.BasicServicesKit';
import { promptAction } from '@kit.ArkUI';


let context = getContext(this) as common.UIAbilityContext;
let filesDir = context.filesDir;
let config: request.agent.Config = {
  action: request.agent.Action.DOWNLOAD,
  url: 'https://www-file.huawei.com/minisite/media/annual_report/annual_report_2023_cn.pdf',
  title: 'createTest',
  description: 'Sample code for create task',
  mode: request.agent.Mode.FOREGROUND,
  overwrite: true,
  method: 'get',
  saveas: filesDir + '/test.pdf',
  network: request.agent.Network.WIFI,
  metered: false,
  roaming: true,
  retry: true,
  redirect: true,
  index: 0,
  begins: 0,
  ends: -1,
  gauge: false,
  precise: false,
  token: 'it is a secret'
};
let createOnCallback = (progress: request.agent.Progress) => {
  console.info('download task completed.');
  promptAction.showToast({
    message: '下载完成',
    duration: 2000
  });
};


@Entry
@Component
struct Index {
  controller: webview.WebviewController = new webview.WebviewController();
  @State uri: string = '';
  @State isChange: boolean = false;


  build() {
    Column() {
      Button('刷新UI')
        .width('200vp')
        .onClick(() => {
          this.controller.loadUrl('file://' + filesDir + '/test.pdf');
        })
        .margin({ bottom: '20vp' })
      Web({ src: $rawfile('WebDownloadPDF.html'), controller: this.controller })
        .fileAccess(true)
        .domStorageAccess(true)
        .onPageBegin((event) => {
          request.agent.create(getContext(), config).then((task: request.agent.Task) => {
            task.on('completed', createOnCallback);
            console.info(`Succeeded in creating a download task. result: ${task.config}`);
            task.start();
          }).catch((err: Error) => {
            console.error(`Failed to create a download task, message: ${err.message}`);
          });
        })
    }
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-76
爬取时间: 2025-05-08 05:58:14
来源: Huawei Developer


目前Web上支持opacity，实现页面透明效果。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-77
爬取时间: 2025-05-08 05:58:23
来源: Huawei Developer


Web组件可以设置horizontalScrollBarAccess(false)属性和verticalScrollBarAccess(false)属性分别隐藏横向滚动条和纵向滚动条。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-78
爬取时间: 2025-05-08 05:58:33
来源: Huawei Developer


目前Webview支持加载图片、视频、网页、pdf。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-79
爬取时间: 2025-05-08 05:58:43
来源: Huawei Developer

- illegal、fraud 禁止访问，没有继续浏览的按钮
- risk 禁止访问，有继续浏览的按钮
- warning web内核不会主动拦截，没有继续访问的按钮

目前不允许自定义风险访问控制的流程，也没有提供相关回调。


参考链接


定义网站风险类型ThreatType


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-81
爬取时间: 2025-05-08 05:58:52
来源: Huawei Developer


目前没有api直接判断web组件是否与controller绑定，可以把调用的controller的方法放在web组件的生命周期中，这样能保证web组件绑定了controller。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-82
爬取时间: 2025-05-08 05:59:02
来源: Huawei Developer


可以使用setResponseIsReady设置资源响应数据是否已经就绪，具体可参考onInterceptRequest示例代码。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-83
爬取时间: 2025-05-08 05:59:12
来源: Huawei Developer


目前规格不支持获取所有的请求头。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-84
爬取时间: 2025-05-08 05:59:22
来源: Huawei Developer


Web组件目前还没有单独判断PDF加载失败与成功的API。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-86
爬取时间: 2025-05-08 05:59:32
来源: Huawei Developer


Web组件的src使用'resource://rawfile/index.html#AAA'这种格式进行加载，具体可参考如下代码：


```less
import { webview } from '@kit.ArkWeb'; 
 
@Entry 
@Component 
struct LoadWebLink { 
  controller: webview.WebviewController = new webview.WebviewController(); 
 
  build() { 
    RelativeContainer() { 
      Web({ src: 'resource://rawfile/LoadWebLink.html#AAA', controller: this.controller }) 
    } 
    .height('100%') 
    .width('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-88
爬取时间: 2025-05-08 05:59:41
来源: Huawei Developer


setCustomUserAgent设置后与web页面的跳转时序是web跳转后才设置UserAgent，这就导致页面跳转了但新agent关联的页面堆栈数仍只有一个,webviewController.accessBackward()总是返回false。


若需要setCustomUserAgent，在setCustomUserAgent方法后添加this.controller.loadUrl(this.webUrl)，webUrl为要加载的web页面，在原始的Web组件的src可以设置一个空字符串。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-89
爬取时间: 2025-05-08 05:59:51
来源: Huawei Developer


在网页渲染完成的回调onFirstContentfulPaint中使用Web的getPageHeight方法获取高度。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-90
爬取时间: 2025-05-08 06:00:02
来源: Huawei Developer


问题描述


ArkWeb组件是否支持深拷贝，将ArkWeb组件A拷贝给ArkWeb组件B，在A组件关闭后或从路由栈中退出后，B可以继续使用A中的资源。


解决措施


当前没有这种能力，只有通过动态创建web组件的形式，形成一个web组件池，想用哪个直接从池中取出，挂上节点树展示。


参考链接


使用Web组件加载页面


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-92
爬取时间: 2025-05-08 06:00:12
来源: Huawei Developer


在进行Web页面开发时可以采用CSS中的媒体查询即使用 @media 查询，根据不同的屏幕尺寸设置不同的样式。除此之外，开发者还可以参考响应式设计（RWD）的相关知识，例如使用百分比单位，视口单位等。同时开发者也可以使用成熟的前端框架，其中的许多组件实现内容都考虑了多端适配场景。


同时如果三方网页已经使用了UA标识适配了移动端设备，但在HarmonyOS设备上效果错误，一种可能原因是未能适配到HarmonyOS设备的UA标识，开发者可以在ArkTS侧使用getUserAgent()来查看HarmonyOS设备的UA标识从而进行补充适配，也可以使用基于默认的UA标识使用setCustomUserAgent来自定义UA标识。


参考链接：

- 默认UserAgent结构
- 设置自定义用户代理

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkweb-93
爬取时间: 2025-05-08 06:00:21
来源: Huawei Developer


问题场景


Web组件加载一个页面，退出页面之后内存释放不完全，担心存在内存泄露风险。


解决措施

- render进程在webview退出后，会完全销毁，没有内存对象泄露。
- browser进程（应用进程）在webview退出后，剩余的资源主要为通用线程的共享对象资源，在新建webview时会复用这些对象，不会重新创建，当应用完全退出后，跟随进程一同释放。所以这种情况下也不会内存泄露。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-system-development
爬取时间: 2025-05-08 06:00:30
来源: Huawei Developer

- 安全
- 网络
- 基础功能
- 硬件

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-security
爬取时间: 2025-05-08 06:00:40
来源: Huawei Developer

- 程序访问控制
- 数据安全存储（Data Prevention）
- 加解密算法（Crypto Architecture）
- 企业数据保护服务（Enterprise Data Guard）
- 密钥管理（Universal Keystore）
- 证书管理（Device Certificate）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-access-control
爬取时间: 2025-05-08 06:00:50
来源: Huawei Developer

- 权限申请被拒绝后，再次申请权限，是否出现申请权限弹窗
- 用户更新app后是否还会弹出权限申请弹窗
- 请求精准定位权限申请注意事项
- 用户在权限弹框中禁止应用获取权限，如何再拉起用户授权弹窗
- 动态申请权限能否添加描述
- user_grant权限预授权，可以使用吗
- 系统安全能力哪些是天然具备的，哪些需要开发者适配
- 在系统设置修改了应用权限，应用能否监听到权限变化
- 应用申请位置信息权限为什么没有弹窗
- 向用户申请授予权限但被用户拒绝后，如何处理才能避免应用二次进入时崩溃
- 是否支持动态授权
- module.json5配置文件中extensionAbilities和requestPermissions的权限声明有何区别

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-access-control-1
爬取时间: 2025-05-08 06:00:59
来源: Huawei Developer


通过设置页关闭权限后，再次申请该权限不会再次弹窗，返回值为-1。对于申请授权的返回值请参见：PermissionRequestResult


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-access-control-2
爬取时间: 2025-05-08 06:01:09
来源: Huawei Developer


应用在应用市场更新后，之前已经申请的用户授权的权限，不会再次弹框。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-access-control-3
爬取时间: 2025-05-08 06:01:18
来源: Huawei Developer


精确定位不可以单独申请，要先申请模糊定位权限后再去申请精确定位权限，而且对于精确定位权限申请的时候，必须和模糊定位权限一起申请。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-access-control4
爬取时间: 2025-05-08 06:01:28
来源: Huawei Developer


权限弹框目前规格是始终允许或者拒绝，也就是弹一次窗口。如果后续用户禁止后，需要弹出框引导用户去设置权限界面开启相应权限。详细可以参考向用户申请授权开发步骤中的第四步：处理授权结果。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-access-control-5
爬取时间: 2025-05-08 06:01:38
来源: Huawei Developer


目前只有静态配置权限的时候可以输入reason字段，动态申请权限不支持reason字段，不支持自定义描述。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-access-control-6
爬取时间: 2025-05-08 06:01:47
来源: Huawei Developer


当前权限预授权未对外开放。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-access-control-9
爬取时间: 2025-05-08 06:01:57
来源: Huawei Developer

- 系统机制，无需三方适配：应用沙箱隔离、权限管理、App签名、代码签名、应用加密、数据分级标签、SELinux、Capability、CFI、堆栈保护、安全启动、系统OTA升级安全、内核完整性保护、MAC随机化、安全芯片管理框架、TEE
- 需要开发者适配的安全机制：混淆加固（默认开启）、EL1/EL2类文件加密、EL3/EL4类文件加密、DLP数据版权保护、密码自动填充、FIDO/IFAA、人脸认证、分布式认证、指纹认证、PIN认证、密码自动填充、FIDO/IFAA、设备风险查询、开发者实名、申请开发者证书（Debug&Release）、申请Provision Profile(权限申请-可选)、代码安全扫描、Release签名上架发布
- 需要开发者遵守的审核项：应用合规扫描、应用权限审核。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-access-control-10
爬取时间: 2025-05-08 06:02:07
来源: Huawei Developer


在系统设置修改了应用权限，三方应用无法监听到权限变化。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-access-control-11
爬取时间: 2025-05-08 06:02:16
来源: Huawei Developer


可能原因


可能是未申请ohos.permission.LOCATION权限。


解决措施


开发应用时，需要先申请权限ohos.permission.APPROXIMATELY_LOCATION，才可申请位置信息。


参考链接


应用权限列表


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-access-control-12
爬取时间: 2025-05-08 06:02:25
来源: Huawei Developer


可能原因

- 业务功能所需要的权限被用户拒绝后不再弹窗请求权限而是直接返回结果。
- 若开发者在请求权限后未进行相关判断，会导致应用直接访问受权限管控的目标对象，此时应用可能会因为没有对应权限而被拒绝访问，从而导致应用意外终止。

解决措施


参考链接


访问控制概述


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-access-control-13
爬取时间: 2025-05-08 06:02:35
来源: Huawei Developer


根据授权方式的不同，权限类型分为系统授权和用户授权。

- 系统授权类的权限会在用户安装应用时，自动把相应权限授予给应用，无法动态授权。
- 用户授权类权限需要在应用动态运行时，通过发送弹窗的方式请求用户授权，可实现动态授权。

两种类型的详细介绍请参考指南：动态授权


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-access-control-14
爬取时间: 2025-05-08 06:02:45
来源: Huawei Developer

- requestPermissions：标识当前应用运行时需向系统申请的权限集合，应用申请的权限只有在此处配置的才会生效。
- extensionAbilities.permissions：标识当前ExtensionAbility组件自定义的权限信息，表示当其他应用访问该ExtensionAbility时，需要申请相应的权限信息，仅做权限校验使用。

参考链接


module.json5配置文件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-data-prevention
爬取时间: 2025-05-08 06:02:55
来源: Huawei Developer

- Asset Store是否会被其他应用获取？是否会出现跨设备同步的情况
- HarmonyOS应用的安全性如何？是否可能被逆向分析？
- HarmonyOS软件需要加壳吗

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-data-prevention-7
爬取时间: 2025-05-08 06:03:04
来源: Huawei Developer


1. 不会被其他应用获取，关键资产存储服务当前未实现应用共享数据能力，仅写入数据的业务可以访问数据。


2. 如果开发者不希望跨设备同步数据，需要在add时设置关键资产的SyncType属性为never。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-data-prevention-9
爬取时间: 2025-05-08 06:03:14
来源: Huawei Developer


HarmonyOS反编译安全性当前提供基础的应用加固安全能力，包括混淆、加密和代码签名能力，保护代码反编译和反调试。高级混淆暂不提供，由三方支持。


参考链接


HarmonyOS生态应用安全技术白皮书


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-data-prevention-10
爬取时间: 2025-05-08 06:03:24
来源: Huawei Developer


官方不提供加壳功能；HarmonyOS有应用加密功能，本身会对所有的abc、so文件进行加密，一定程度上可以替代加壳，因此不需要再加壳了。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-kit
爬取时间: 2025-05-08 06:03:34
来源: Huawei Developer

- 如何获取应用签名证书的hash值
- 如何使用服务端下发的RSA公钥（字符串）对明文数据进行加密
- ECC算法是否支持secp256r1
- 如何对大文件进行SM4加密
- 如何实现RSA的公钥PK加密一段文字
- 如何将公钥转为十六进制或者base64进制数据
- 如何解决base64解码为乱码问题
- 如何对公钥和私钥进行加解密
- Huks生成2048位RSA密钥，加密数据，报错401错误
- HMAC加密报错：error: convert sym key failed
- 如何用已有证书做RSA的公钥加密
- 如何使用SM3算法进行消息认证码计算
- 如何存储公钥
- 在进行aes加密的时候，如何把字符串转换成Key对象
- 如何使用SM3加密

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-2
爬取时间: 2025-05-08 06:03:44
来源: Huawei Developer

- “应用指纹”signatureInfo.fingerprint是应用签名证书(.cer文件)的SHA-256hash值，当前支持获取本应用的“应用指纹”。示例代码如下：

```less
import { bundleManager } from '@kit.AbilityKit'; 
import { hilog } from '@kit.PerformanceAnalysisKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
let bundleFlags = bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_SIGNATURE_INFO; 
try { 
  bundleManager.getBundleInfoForSelf(bundleFlags).then((data) => { 
    hilog.info(0x0000, 'testTag', 'getBundleInfoForSelf successfully. Data: %{public}s', JSON.stringify(data)); 
    //data里可以获取到signatureInfo，即应用的签名证书信息 
  }).catch((err: BusinessError) => { 
    hilog.error(0x0000, 'testTag', 'getBundleInfoForSelf failed. Cause: %{public}s', err.message); 
  }); 
} catch (err) { 
  let message = (err as BusinessError).message; 
  hilog.error(0x0000, 'testTag', 'getBundleInfoForSelf failed: %{public}s', message); 
}
```

- 对于hash值，可使用加解密框架的hash算法，目前支持SHA1、SHA224、SHA256、SHA384、SHA512、MD5。示例代码如下：

```typescript
import { common } from '@kit.AbilityKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
import { hash }from '@kit.CoreFileKit'; 
 
let context = getContext(this) as common.UIAbilityContext; 
let pathDir = context.filesDir; 
 
let filePath = pathDir + "/test.txt"; 
hash.hash(filePath, "sha256").then((str: string) => { 
  console.info("calculate file hash succeed:" + str); 
}).catch((err: BusinessError) => { 
  console.error("calculate file hash failed with error message: " + err.message + ", error code: " + err.code); 
});
```


参考链接


应用包的签名信息


文件哈希处理


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-3
爬取时间: 2025-05-08 06:03:53
来源: Huawei Developer


将服务器下发的RSA公钥字符串替换掉pubKeyStr即可实现，具体可参考如下代码：


```less
import { buffer, util } from '@kit.ArkTS'; 
import { cryptoFramework } from '@kit.CryptoArchitectureKit'; 
/** 
 * 使用RSA非对称密钥（PKCS1模式）加密 
 * @param message 要加密的明文数据 
 * @returns 加密后的字符串，base64编码 
 */ 
export async function encryptRSA(message: string) { 
  // 服务器下发RSA公钥字符串（base64编码） 
  let pubKeyStr = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDFQArGDm5BXM4jHHuZGIb/kUoqrSjXkjqPLgrDmqBFxNyYsyxvyFRO10nStQwdRkQkh5lZ5sqC1G/z6lyDPpEySTBo9S5GLZ2Tj4yinNjcMXmOwiHfyQAQo9LwdlyTedwRchg0fYewWBVTVhGcWPowT1aA+GnQhYwNmaS/iKQsNQIDAQAB"; 
  // 初始化Base64工具实例 
  let base64Helper = new util.Base64Helper(); 
  // 公钥转换为Uint8Array，然后包装为DataBlob类型 
  let pubKeyBlob: cryptoFramework.DataBlob = { data: base64Helper.decodeSync(pubKeyStr) }; 
  // 创建RSA key生成器 
  let rsaGenerator = cryptoFramework.createAsyKeyGenerator('RSA1024'); 
  // 将公钥包装数据pubKeyBlob转换成密钥对类型KeyPair 
  let keyPair = await rsaGenerator.convertKey(pubKeyBlob, null); 
  // 创建 Cipher对象 
  let cipher = cryptoFramework.createCipher('RSA1024|PKCS1'); 
  // 初始化加密模式，指定密钥keyPair.pubKey 
  await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, keyPair.pubKey, null); 
  // 包装要加密的明文 
  let plainTextBlob: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) }; 
  // 传入明文，获取加密后的数据 
  let encryptBlob = await cipher.doFinal(plainTextBlob); 
  // 返回加密后的字符串 
  return base64Helper.encodeToStringSync(encryptBlob.data); 
}
```


参考链接


使用RSA非对称密钥（PKCS1模式）加解密


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-5
爬取时间: 2025-05-08 06:04:03
来源: Huawei Developer


ECC算法支持secp256r1，ECC256生成的就是secp256r1。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-11
爬取时间: 2025-05-08 06:04:13
来源: Huawei Developer


使用分段加解密，对于ECB和CBC模式，不论update传入的数据是否为分组长度的整数倍，都会以分组作为基本单位进行加/解密，并输出本次update新产生的加/解密分组结果。update只要凑满一个新的分组就会有输出，如果没有凑满则此次update输出为null，把当前还没被加/解密的数据留着，等下一次update/doFinal传入数据的时候，拼接起来继续凑分组。最后doFinal的时候，会把剩下的还没加/解密的数据，根据createCipher时设置的padding模式进行填充，补齐到分组的整数倍长度，再输出剩余加解密结果。


参考代码如下：


```less
import { cryptoFramework } from '@kit.CryptoArchitectureKit'; 
function genIvParamsSpec() { 
  let arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; 
  let dataIv = new Uint8Array(arr); 
  let ivBlob: cryptoFramework.DataBlob = { data: dataIv }; 
  let ivParamsSpec: cryptoFramework.IvParamsSpec = { 
    algName: 'IvParamsSpec', 
    iv: ivBlob 
  }; 
  return ivParamsSpec; 
} 
function stringToUint8Array(str: string): Uint8Array { 
  let arr: Array<number> = []; 
  for (let i = 0, j = str.length; i < j; i++) { 
    arr.push(str.charCodeAt(i)); 
  } 
  return new Uint8Array(arr); 
} 
async function testAesMultiUpdate(plainText: string) { 
  let symAlgName = 'SM4_128'; 
  let length = 1024; 
  let symKeyGenerator = cryptoFramework.createSymKeyGenerator(symAlgName); 
  let cipherAlgName = 'SM4_128|CBC|PKCS7'; 
  let globalCipher = cryptoFramework.createCipher(cipherAlgName); 
  let result = new Uint8Array(); 
  let data: cryptoFramework.DataBlob; 
  let startEecrypt = 0; 
  let endEecrypt = 0; 
  let promiseSymKey = await symKeyGenerator.generateSymKey(); 
  await globalCipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, promiseSymKey, genIvParamsSpec()); 
  let updateOutput: cryptoFramework.DataBlob; 
  while (plainText.length > 0) { 
    const contentCurr = plainText.substring(0, length); 
    plainText = plainText.substring(length, plainText.length); 
    let messageBlob: cryptoFramework.DataBlob = { data: stringToUint8Array(contentCurr) }; 
    updateOutput = await globalCipher.update(messageBlob); 
    if (updateOutput !== null) { 
      let mergeText = new Uint8Array(result.length + updateOutput.data.length); 
      mergeText.set(result); 
      mergeText.set(updateOutput.data, result.length); 
      result = mergeText; 
    } 
  } 
  startEecrypt = new Date().getTime(); 
  data = await globalCipher.doFinal(null); 
  endEecrypt = new Date().getTime(); 
  console.info('TEST加密' + (endEecrypt - startEecrypt)); 
  let mergeText = new Uint8Array(result.length + data.data.length); 
  mergeText.set(result); 
  mergeText.set(data.data, result.length); 
  result = mergeText; 
  let contentTemp = result; 
  console.info('TEST加密成功', contentTemp); 
  await globalCipher.init(cryptoFramework.CryptoMode.DECRYPT_MODE, promiseSymKey, genIvParamsSpec()); 
  console.info('TEST == 长度' + contentTemp.length); 
} 
@Entry 
@Component 
struct SM4Encryption { 
  @State message: string = 'Hello World'; 
  aboutToAppear(): void { 
    testAesMultiUpdate('123456789102345566478416518498454151689546549849'); 
  } 
  build() { 
    RelativeContainer() { 
      Text(this.message) 
        .id('SM4EncryptionHelloWorld') 
        .fontSize(50) 
        .fontWeight(FontWeight.Bold) 
        .alignRules({ 
          center: { anchor: '__container__', align: VerticalAlign.Center }, 
          middle: { anchor: '__container__', align: HorizontalAlign.Center } 
        }) 
    } 
    .height('100%') 
    .width('100%') 
  } 
}
```


参考链接


@ohos.security.cryptoFramework


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-13
爬取时间: 2025-05-08 06:04:23
来源: Huawei Developer


算法库目前提供了RSA加解密常用的三种模式：NoPadding、PKCS1、PKCS1_OAEP。不同RSA密钥规格和不同填充方式支持加密的数据长度不同，详情见参考链接。


参考代码如下：


```less
import { cryptoFramework } from '@kit.CryptoArchitectureKit'; 
import { buffer, util } from '@kit.ArkTS'; 
// 字符串转成字节流 
function stringToUint8Array(str: string) { 
  return new Uint8Array(buffer.from(str, 'utf-8').buffer); 
} 
// 字节流转成可理解的字符串 
function uint8ArrayToString(array: Uint8Array) { 
  // 将UTF-8编码转换成Unicode编码 
  let out: string = ''; 
  let index: number = 0; 
  let len: number = array.length; 
  while (index < len) { 
    let character = array[index++]; 
    switch (character >> 4) { 
      case 0: 
      case 1: 
      case 2: 
      case 3: 
      case 4: 
      case 5: 
      case 6: 
      case 7: 
        out += String.fromCharCode(character); 
        break; 
      case 12: 
      case 13: 
        out += String.fromCharCode(((character & 0x1F) << 6) | (array[index++] & 0x3F)); 
        break; 
      case 14: 
        out += String.fromCharCode(((character & 0x0F) << 12) | ((array[index++] & 0x3F) << 6) | 
          ((array[index++] & 0x3F) << 0)); 
        break; 
      default: 
        break; 
    } 
  } 
  return out; 
} 
export class KeyPair { 
  publicKey: string = ''; 
  privateKey: string = ''; 
} 
export class RSA { 
  private ASY_KEY_NAME_RSA_3072: string = 'RSA1024'; 
  private ALG_NAME_RSA_3072: string = 'RSA|PKCS1'; 
  static priKey: Uint8Array = new Uint8Array(); //用于临时保存 
  static pubKey: Uint8Array = new Uint8Array(); //用于临时保存 
  private base: util.Base64Helper = new util.Base64Helper(); 
  public async generateRsaKeyPair(): Promise<KeyPair> { 
    let keyPair: KeyPair = new KeyPair(); 
    try { 
      let asyKeyGenerator = cryptoFramework.createAsyKeyGenerator(this.ASY_KEY_NAME_RSA_3072); 
      const tempKeyPair = await asyKeyGenerator.generateKeyPair(); 
      keyPair = { 
        publicKey: this.base.encodeToStringSync(tempKeyPair.pubKey.getEncoded().data), 
        privateKey: this.base.encodeToStringSync(tempKeyPair.priKey.getEncoded().data) 
      } 
    } catch (err) { 
      console.error(err); 
    } 
    return keyPair; 
  } 
  public async add(str: string, publicKey: string): Promise<string> { 
    let result = ''; 
    try { 
      let asyKeyGenerator = cryptoFramework.createAsyKeyGenerator(this.ASY_KEY_NAME_RSA_3072); 
      //创建一个 Cipher (解密)对象 
      let cipher = cryptoFramework.createCipher(this.ALG_NAME_RSA_3072); 
      //引入外部的公钥加密 
      let keyGenPromise: cryptoFramework.KeyPair = 
        await asyKeyGenerator.convertKey({ data: this.base.decodeSync(publicKey) }, null); 
      await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, keyGenPromise.pubKey, null); 
      let put: cryptoFramework.DataBlob = { data: stringToUint8Array(str) }; 
      const finalRes = await cipher.doFinal(put); 
      result = this.base.encodeToStringSync(finalRes.data); 
      console.info(result); 
    } catch (err) { 
      console.log(err.message); 
    } 
    return result; 
  } 
  public async rsaDecrypt(message: string | Uint8Array, privateKey: string): Promise<string> { 
    let result = ''; 
    try { 
      let asyKeyGenerator = cryptoFramework.createAsyKeyGenerator(this.ASY_KEY_NAME_RSA_3072); 
      const keyPair = await asyKeyGenerator.convertKey(null, { data: this.base.decodeSync(privateKey) }); 
      let cipher = cryptoFramework.createCipher(this.ALG_NAME_RSA_3072); //创建一个 Cipher (解密)对象 
      await cipher.init(cryptoFramework.CryptoMode.DECRYPT_MODE, keyPair.priKey, null); 
      let bytes: Uint8Array | string = message; 
      if (typeof message === 'string') { 
        bytes = this.base.decodeSync(message); 
      } else { 
        bytes = message; 
      } 
      const finalRes = await cipher.doFinal({ data: bytes }); 
      result = uint8ArrayToString(finalRes.data); 
      console.info(result); 
    } catch (err) { 
      console.error(err.code); 
    } 
    return result; 
  } 
} 
@Entry 
@Component 
struct EncryptedText { 
  @State word: string = '加解密文字'; 
  private EncryptionAndDecryption = new RSA(); 
  async aboutToAppear(): Promise<void> { 
    let key = await this.EncryptionAndDecryption.generateRsaKeyPair(); 
    let result = await this.EncryptionAndDecryption.add(this.word, key.publicKey); 
    this.EncryptionAndDecryption.rsaDecrypt(result, key.privateKey); 
  } 
  build() { 
  } 
}
```


参考链接：


非对称密钥加解密算法规格


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-18
爬取时间: 2025-05-08 06:04:32
来源: Huawei Developer


公钥转为十六进制或者base64进制数据，参考代码如下：


```typescript
import { buffer, util } from '@kit.ArkTS'; 
 
@Entry 
@Component 
struct PubKeysConvert { 
 
  build() { 
    Column(){ 
      Button('公钥转十六进制').onClick(()=>{ 
        let pubKeyData = '公钥' 
        let res = buffer.from(pubKeyData).toString('hex') 
        console.info('公钥转十六进制',res) 
      }) 
      Button('公钥转base64').onClick(()=>{ 
        let pubKeyUint8Array = new Uint8Array(buffer.from('公钥','utf-8').buffer) 
        let res = new util.Base64Helper().encodeToStringSync(pubKeyUint8Array) 
        console.info('公钥转base64',res) 
      }) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-19
爬取时间: 2025-05-08 06:04:42
来源: Huawei Developer


加密结果中如果有换行符\n，去掉之后解密成功。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-20
爬取时间: 2025-05-08 06:04:51
来源: Huawei Developer


参考代码如下：


```less
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { util } from '@kit.ArkTS';


let base = new util.Base64Helper();
let pubKeyStr = uint8ArrayToHexStr(base.decodeSync('公钥'));
let priKeyStr = uint8ArrayToHexStr(base.decodeSync('私钥'));


async function encryptionAndDecryption() {
  // 根据密钥参数生成公私钥
  let pk = await convertStrToPubKey(pubKeyStr);
  let sk = await convertStrToPriKey(priKeyStr);


  //加密
  let encryptText = await encryptMessagePromise(pk, '加密信息');
  //解密
  let res = await decryptMessagePromise(sk, encryptText);
}


//根据密钥参数生成sm2公钥
async function convertStrToPubKey(keyStr: string): Promise<cryptoFramework.PubKey> {
  let pubKeyStr = keyStr.startsWith("04") ? keyStr.slice(2) : keyStr;
  let pkPart1 = pubKeyStr.slice(0, pubKeyStr.length / 2);
  let pkPart2 = pubKeyStr.slice(pubKeyStr.length / 2);
  let pk: cryptoFramework.Point = {
    x: BigInt("0x" + pkPart1),
    y: BigInt("0x" + pkPart2),
  }
  let pubKeySpec: cryptoFramework.ECCPubKeySpec = {
    params: cryptoFramework.ECCKeyUtil.genECCCommonParamsSpec('NID_sm2'),
    pk: pk,
    algName: "SM2",
    specType: cryptoFramework.AsyKeySpecType.PUBLIC_KEY_SPEC
  }
  let keypairGenerator = cryptoFramework.createAsyKeyGeneratorBySpec(pubKeySpec);
  return await keypairGenerator.generatePubKey();
}


//根据密钥参数生成sm2私钥
async function convertStrToPriKey(keyStr: string): Promise<cryptoFramework.PriKey> {
  let sk = BigInt("0x" + keyStr);
  let priKeySpec: cryptoFramework.ECCPriKeySpec = {
    params: cryptoFramework.ECCKeyUtil.genECCCommonParamsSpec('NID_sm2'),
    sk: sk,
    algName: "SM2",
    specType: cryptoFramework.AsyKeySpecType.PRIVATE_KEY_SPEC
  }
  let keypairGenerator = cryptoFramework.createAsyKeyGeneratorBySpec(priKeySpec);
  return await keypairGenerator.generatePriKey();
}


// 解密消息
async function decryptMessagePromise(privateKey: cryptoFramework.PriKey, cipherText: cryptoFramework.DataBlob) {
  let decoder = cryptoFramework.createCipher('SM2_256|SM3');
  await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, privateKey, null);
  let decryptData = await decoder.doFinal(cipherText);
  return decryptData;
}


// 加密消息
async function encryptMessagePromise(publicKey: cryptoFramework.PubKey, plainText: string) {
  let cipher = cryptoFramework.createCipher('SM2_256|SM3');
  await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, publicKey, null);
  let encryptData = await cipher.doFinal({ data: stringToUint8Array(plainText) });
  return encryptData;
}


function uint8ArrayToHexStr(data: Uint8Array): string {
  let hexString = '';
  let i: number;
  for (i = 0; i < data.length; i++) {
    let char = ('00' + data[i].toString(16)).slice(-2);
    hexString += char;
  }
  return hexString;
}


function stringToUint8Array(str: string) {
  let arr = new Uint8Array(str.length);
  for (let i = 0, j = str.length; i < j; ++i) {
    arr[i] = str.charCodeAt(i);
  }
  return arr;
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-21
爬取时间: 2025-05-08 06:05:00
来源: Huawei Developer


生成RSA密钥长度与生成密钥时传入参数有关，参考非对称密钥生成和转换规格：RSA，生成2048位RSA密钥参数可以传'RSA2048|PRIMES_2'或者'RSA2048|PRIMES_3'。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-22
爬取时间: 2025-05-08 06:05:10
来源: Huawei Developer


问题场景


将key、str进行加密后返回相应的字符串，报错：error: convert sym key failed。


解决措施


把代码中的


```less
let symKeyGenerator = cryptoFramework.createSymKeyGenerator('HMAC');
```


替换成


```less
let symKeyGenerator = cryptoFramework.createSymKeyGenerator('HMAC|SHA1');
```


参考链接


对称密钥生成和转换规格


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-23
爬取时间: 2025-05-08 06:05:20
来源: Huawei Developer


问题场景


用PEM格式证书中的公钥调用示例中rsaPubKeyEncrypt()方法报错：init failed，用指南中示例的pubKey是能加密成功的，但是出来的数据转换为string后是乱码数据。


解决措施


转string的时候要转成base64，也可以转成十六进制，具体转化方法可参考如下代码：


```less
function uint8ArrayToHexStr(data: Uint8Array): string { 
  let hexString = ''; 
  let i: number; 
  for (i = 0; i < data.length; i++) { 
    let char = ('00' + data[i].toString(16)).slice(-2); 
    hexString += char; 
  } 
  return hexString; 
}
```


用正确的证书数据参考如下代码对应内容进行处理：


```less
import { cryptoFramework } from '@kit.CryptoArchitectureKit'; 
 
async function rsaPubKeyEncrypt(pubKey: cryptoFramework.PubKey, plainText: cryptoFramework.DataBlob) { 
  try { 
    let asyKeyGenerator = cryptoFramework.createAsyKeyGenerator('RSA1024'); 
    let keyGenPromise: cryptoFramework.KeyPair = 
      await asyKeyGenerator.convertKey({ data: pubKey.getEncoded().data }, null); 
    let cipher = cryptoFramework.createCipher('RSA1024|PKCS1'); 
    await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, keyGenPromise.pubKey, null); 
    let encryptData = await cipher.doFinal(plainText); 
    return uint8ArrayToHexStr(encryptData.data); 
  } catch (err) { 
    console.info(err); 
    return uint8ArrayToHexStr(new Uint8Array()); 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-24
爬取时间: 2025-05-08 06:05:29
来源: Huawei Developer


核心代码如下：


```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit'; 
import { buffer } from '@kit.ArkTS'; 
 
@Entry 
@Component 
struct Hmac { 
  @State message: string = 'Hello World'; 
 
  build() { 
    Row() { 
      Column() { 
        Button('使用SM3算法进行消息认证码计算') 
          .fontSize(20) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            getHmac('密钥') 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
} 
 
// 可理解的字符串转成字节流 
function stringToUint8Array(str: string) { 
  let arr = new Uint8Array(str.length); 
  for (let i = 0, j = str.length; i < j; ++i) { 
    arr[i] = str.charCodeAt(i); 
  } 
  return arr; 
} 
 
async function getHmac(message:string){ 
 
  try { 
    let macAlgName = 'SM3'; 
    let mac =cryptoFramework.createMac(macAlgName) 
    let arr = stringToUint8Array('30a86dc9056c44cc05420fec269270214bbb6914954e871e83771c9810ac1db0') 
    let KeyBlob: cryptoFramework.DataBlob = {data:arr}; 
    let symKeyGenerator = cryptoFramework.createSymKeyGenerator('HMAC'); 
    const  symKey=await symKeyGenerator.convertKey(KeyBlob); 
    await mac.init(symKey) 
    await mac.update({data:stringToUint8Array(message)}); 
    let macOutpt= await mac.doFinal(); 
    const res=buffer.from(macOutpt.data).toString('hex'); 
    console.log('Hmac---:'+res); 
  }catch (err){ 
    console.log('err:'+err) 
  } 
 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-26
爬取时间: 2025-05-08 06:05:39
来源: Huawei Developer


1、可以把公钥转为十六进制或者base64进制数据存储


2、拿到公钥后转数组


3、将转换的数组转换为公钥对象


参考代码如下：


```typescript
import { buffer, util } from '@kit.ArkTS' 
import { cryptoFramework } from '@kit.CryptoArchitectureKit' 
 
@Entry 
@Component 
struct PublicKeysStored { 
  build() { 
    Row() { 
      Column() { 
        Button('公钥转为base64进制数据存储').onClick(() => { 
          let publicKeys = 
            new Uint8Array([ 
              0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a, 
              0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0xc0, 0xfe, 0x1c, 0x67, 0xde, 
              0x86, 0x0e, 0xfb, 0xaf, 0xb5, 0x85, 0x52, 0xb4, 0x0e, 0x1f, 0x6c, 0x6c, 0xaa, 0xc5, 0xd9, 0xd2, 
              0x4d, 0xb0, 0x8a, 0x72, 0x24, 0xa1, 0x99, 0xaf, 0xfc, 0x3e, 0x55, 0x5a, 0xac, 0x99, 0x3d, 0xe8, 
              0x34, 0x72, 0xb9, 0x47, 0x9c, 0xa6, 0xd8, 0xfb, 0x00, 0xa0, 0x1f, 0x9f, 0x7a, 0x41, 0xe5, 0x44, 
              0x3e, 0xb2, 0x76, 0x08, 0xa2, 0xbd, 0xe9, 0x41, 0xd5, 0x2b, 0x9e 
            ]); 
          let result = new util.Base64Helper().encodeToStringSync(publicKeys) 
          console.info('base64 result=',result) 
          let base64 = new util.Base64Helper(); 
          let byte = base64.decodeSync(result)// base64 
          console.info('base64 byte=',byte) 
          // 将转换的数组转换为公钥对象 
          let keyBlob: cryptoFramework.DataBlob = { data: byte } 
 
        }) 
 
        Button('公钥转为十六进制数据存储').onClick(() => { 
          let publicKeys = 
            new Uint8Array([ 
              0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a, 
              0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0xc0, 0xfe, 0x1c, 0x67, 0xde, 
              0x86, 0x0e, 0xfb, 0xaf, 0xb5, 0x85, 0x52, 0xb4, 0x0e, 0x1f, 0x6c, 0x6c, 0xaa, 0xc5, 0xd9, 0xd2, 
              0x4d, 0xb0, 0x8a, 0x72, 0x24, 0xa1, 0x99, 0xaf, 0xfc, 0x3e, 0x55, 0x5a, 0xac, 0x99, 0x3d, 0xe8, 
              0x34, 0x72, 0xb9, 0x47, 0x9c, 0xa6, 0xd8, 0xfb, 0x00, 0xa0, 0x1f, 0x9f, 0x7a, 0x41, 0xe5, 0x44, 
              0x3e, 0xb2, 0x76, 0x08, 0xa2, 0xbd, 0xe9, 0x41, 0xd5, 0x2b, 0x9e 
            ]); 
          let result = buffer.from(publicKeys).toString('hex') 
          console.info('hex result=',result) 
          let byte = new Uint8Array(buffer.from(result, 'hex').buffer) 
          console.info('hex byte=',byte) 
          // 将转换的数组转换为公钥对象 
          let keyBlob: cryptoFramework.DataBlob = { data: byte } 
        }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-28
爬取时间: 2025-05-08 06:05:49
来源: Huawei Developer


可参考如下代码：


```typescript
import { buffer, util } from '@kit.ArkTS';
import { cryptoFramework } from '@kit.CryptoArchitectureKit';




@Entry
@Component
struct GetKey {
  // 字符串转成字节流
  stringToUint8Array(str: string) {
    return new Uint8Array(buffer.from(str, 'utf-8').buffer);
  }


  //导入密钥
  async getKey() {
    let symAlgName = 'AES128';
    let symKeyGenerator = cryptoFramework.createSymKeyGenerator(symAlgName);
    let dataUint8Array = this.stringToUint8Array('294A2561FEFDF08D');
    let keyBlob: cryptoFramework.DataBlob = { data: dataUint8Array };
    console.info('keyBlob', JSON.stringify(keyBlob))
    let symKey = await symKeyGenerator.convertKey(keyBlob);
    return symKey;
  }


  build() {
    Column({ space: 10 }) {
      Button('aes加密时,字符串转换成Key对象')
        .onClick(() => {
          this.getKey();
        })
    }
    .alignItems(HorizontalAlign.Center)
    .height('100%')
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-crypto-architecture-29
爬取时间: 2025-05-08 06:05:59
来源: Huawei Developer


调用cryptoFramework.createMd方法，传入SM3，可参考如下代码：


```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { util, buffer } from '@kit.ArkTS';


let base64 = new util.Base64Helper();


@Entry
@Component
struct SM3Encrypted {
  stringToUint8Array(str: string) {
    return new Uint8Array(buffer.from(str, 'utf-8').buffer);
  }


  // 以Promise方式完成摘要
  doMdByPromise() {
    // 摘要算法名称。
    let mdAlgName = 'SM3';
    // 要进行摘要的数据。
    let message = 'Hello,world';
    let md = cryptoFramework.createMd(mdAlgName);
    console.info('[Promise]: Md algName is: ' + md.algName);
    let promiseMdUpdate = md.update({ data: this.stringToUint8Array(message) });
    promiseMdUpdate.then(() => {
      // 调用 digest（） 以返回结果。
      let PromiseMdDigest = md.digest();
      return PromiseMdDigest;
    }).then(digestOutput => {
      let mdOutput = digestOutput.data;
      //Uint8Array转base64
      let str2 = base64.encodeToStringSync(mdOutput);
      //转16进制
      let str = this.uint8ArrayToHexStr(mdOutput);
      console.info('[Promise]: MD result: ' + mdOutput);
      let mdLen = md.getMdLength();
      console.info('[Promise]: MD len: ' + mdLen);
    }).catch((error: BusinessError) => {
      console.error('[Promise]: error: ' + error.message);
    });
  }


  //摘要结果是Uint8Array类型，转换得到十六进制字符串数据
  uint8ArrayToHexStr(data: Uint8Array): string {
    let hexString = '';
    let i: number;
    for (i = 0; i < data.length; i++) {
      let char = ('00' + data[i].toString(16)).slice(-2);
      hexString += char;
    }
    return hexString;
  }


  build() {
    Column({ space: 10 }) {
      Button('使用SM3加密')
        .onClick(() => {
        this.doMdByPromise();
      })
    }
    .alignItems(HorizontalAlign.Center)
    .height('100%')
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-data-guard-kit
爬取时间: 2025-05-08 06:06:08
来源: Huawei Developer

- Enterprise Data Guard Kit权限获取

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/dataguard-faq-1
爬取时间: 2025-05-08 06:06:18
来源: Huawei Developer


问题现象


DevEco Studio编译不通过，报错：install failed due to grant request permissions failed


解决措施


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-universal-keystore-kit
爬取时间: 2025-05-08 06:06:27
来源: Huawei Developer

- HUKS生成的密钥在什么情况下会消失或被清理
- HUKS初始向量是否必须为随机数？对生成的密钥有什么影响
- 并发场景下AES加密失败
- rsa加密公钥convertKey异常：401 invalid param
- 通用密钥库系统中，使用AES GCM算法进行操作，AAD可以为空吗
- HUKS解密时，若明文包含中文字符，则解密后明文与原明文不一致
- 如何获取HarmonyOS签名证书的公钥信息
- 如何使用用户自定义的pin码（6到16位）进行密钥解锁
- huks Native接口编译报错问题
- 如何保存私钥等重要数据
- huks.isKeyItemExist和huks.hasKeyItem的区别

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-universal-keystore-1
爬取时间: 2025-05-08 06:06:36
来源: Huawei Developer


应用中调用huks.deleteKeyItem接口可以手动删除指定别名的密钥；当应用卸载后，应用存储在设备的安全环境对应的密钥会被自动销毁。


参考链接


huks.deleteKeyItem


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-universal-keystore-2
爬取时间: 2025-05-08 06:06:46
来源: Huawei Developer


为了密钥的语义安全，初始向量必须为随机数，产生随机数的方法必须具有不可预测性。使用HUKS生成密钥时，HUKS_TAG_IV初始向量为可选参数；密钥加解密的过程中，设置特定参数时该初始向量必选。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-universal-keystore-3
爬取时间: 2025-05-08 06:06:56
来源: Huawei Developer


可能原因


使用HUKS重复导入相同的密钥， importKey会判断密钥是否存在，存在的话会删除重新生成，结果删除之后其他线程做init失败。


解决措施


如果使用HUKS相同密钥只用导入一次，系统会安全存储密钥，使用密钥别名进行密码学操作。如果不需要系统保存密钥的场景可以使用cryptoFramework。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-universal-keystore-4
爬取时间: 2025-05-08 06:07:06
来源: Huawei Developer


入参经过base64 encode转string，出参时未做base64 decode。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-universal-keystore-5
爬取时间: 2025-05-08 06:07:16
来源: Huawei Developer


密钥管理服务中对于gcm分组模式实现，当前要求强制使用AAD进行消息完整性认证。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-universal-keystore-6
爬取时间: 2025-05-08 06:07:26
来源: Huawei Developer


需要使用utf-8进行编解码，不然会出现乱码。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-universal-keystore-7
爬取时间: 2025-05-08 06:07:35
来源: Huawei Developer


获取HarmonyOS签名可以参考指南手动签名章节，公钥用于给数据加密，用公钥加密的数据只能使用私钥解密，可以通过以下命令获取公钥信息（需要提前安装安全套接字层密码库Openssl）：


```less
openssl x509 -in xxx.cer -pubkey -noout
```


参考链接


手动签名


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-universal-keystore-8
爬取时间: 2025-05-08 06:07:45
来源: Huawei Developer


目前是支持该能力的，可以将HUKS_TAG_USER_AUTH_TYPE属性在使用PIN时要设置为HUKS_USER_AUTH_TYPE_PIN。


对于密钥验证，只支持锁屏密码及生物特征的验证，支持密钥的用户身份认证访问控制：


1. 对于高安敏感的业务密钥，需要在使用密钥的时候，再次要求用户即时的验证锁屏密码或生物特征，验证通过后，才能使用业务密钥。


2. 对于非高安敏感的业务密钥，通过单独的密码验证(非锁屏密码)，需要应用自己实现这个验证业务。


参考链接


HuksAuthAccessType


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-universal-keystore-9
爬取时间: 2025-05-08 06:07:55
来源: Huawei Developer


问题场景


使用huks密钥库的c接口生成密钥时编译报错，错误信息如下：


```less
hvigor ERROR: Failed :har1withso:default@BuildNativeWithNinja… 
hvigor ERROR: Tools execution failed. 
Command failed with exit code 1: C:\HarmonyOS\sdk\default\base\native\build-tools\cmake\bin\ninja.exe -C C:\my\harmonyos-project\hos1230\har1withso.cxx\default\default\arm64-v8a 
ninja: Entering directory `C:\my\harmonyos-project\hos1230\har1withso.cxx\default\default\arm64-v8a’ 
[1/2] Building CXX object CMakeFiles/har1withso.dir/hello.cpp.o 
clang++: warning: argument unused during compilation: ‘–gcc-toolchain=C:/HarmonyOS/sdk/default/base/native/llvm’ [-Wunused-command-line-argument] 
[2/2] Linking CXX shared library C:\my\harmonyos-project\hos1230\har1withso\build\default\intermediates\cmake\default\obj\arm64-v8a\libhar1withso.so 
FAILED: C:/my/harmonyos-project/hos1230/har1withso/build/default/intermediates/cmake/default/obj/arm64-v8a/libhar1withso.so 
cmd.exe /C “cd . && C:\HarmonyOS\sdk\default\base\native\llvm\bin\clang++.exe --target=aarch64-linux-ohos --gcc-toolchain=C:/HarmonyOS/sdk/default/base/native/llvm --sysroot=C:/HarmonyOS/sdk/default/base/native/sysroot -fPIC -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -fno-addrsig -Wa,–noexecstack -Wformat -Werror=format-security -D__MUSL__ -O0 -g -fno-limit-debug-info --rtlib=compiler-rt -fuse-ld=lld -Wl,–build-id=sha1 -Wl,–warn-shared-textrel -Wl,–fatal-warnings -lunwind -Wl,–no-undefined -Qunused-arguments -Wl,-z,noexecstack -shared -Wl,-soname,libhar1withso.so -o C:\my\harmonyos-project\hos1230\har1withso\build\default\intermediates\cmake\default\obj\arm64-v8a\libhar1withso.so CMakeFiles/har1withso.dir/hello.cpp.o -lace_napi.z -lm && cd .” 
ld.lld: error: undefined symbol: OH_Huks_InitParamSet 
 
referenced by hello.cpp:7 (C:/my/harmonyos-project/hos1230/har1withso/src/main/cpp/hello.cpp:7) 
CMakeFiles/har1withso.dir/hello.cpp.o:(InitParamSet(OH_Huks_ParamSet**, OH_Huks_Param const*, unsigned int)) 
ld.lld: error: undefined symbol: OH_Huks_AddParams 
 
referenced by hello.cpp:11 (C:/my/harmonyos-project/hos1230/har1withso/src/main/cpp/hello.cpp:11) 
CMakeFiles/har1withso.dir/hello.cpp.o:(InitParamSet(OH_Huks_ParamSet**, OH_Huks_Param const*, unsigned int)) 
ld.lld: error: undefined symbol: OH_Huks_FreeParamSet 
 
referenced by hello.cpp:13 (C:/my/harmonyos-project/hos1230/har1withso/src/main/cpp/hello.cpp:13) 
CMakeFiles/har1withso.dir/hello.cpp.o:(InitParamSet(OH_Huks_ParamSet**, OH_Huks_Param const*, unsigned int)) 
referenced by hello.cpp:18 (C:/my/harmonyos-project/hos1230/har1withso/src/main/cpp/hello.cpp:18) 
CMakeFiles/har1withso.dir/hello.cpp.o:(InitParamSet(OH_Huks_ParamSet**, OH_Huks_Param const*, unsigned int)) 
ld.lld: error: undefined symbol: OH_Huks_BuildParamSet 
 
referenced by hello.cpp:16 (C:/my/harmonyos-project/hos1230/har1withso/src/main/cpp/hello.cpp:16) 
CMakeFiles/har1withso.dir/hello.cpp.o:(InitParamSet(OH_Huks_ParamSet**, OH_Huks_Param const*, unsigned int)) 
clang++: error: linker command failed with exit code 1 (use -v to see invocation) 
ninja: build stopped: subcommand failed. 
Detail: Please check the message from tools.
```


解决措施


在cmake文件里加一行target_link_libraries(hello_openharmony PUBLIC libhuks_ndk.z.so)，然后把hello_openharmony换成自己的模块。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-universal-keystore-11
爬取时间: 2025-05-08 06:08:05
来源: Huawei Developer


可以通过密钥导入接口，将私钥导入到密钥管理服务进行管理，导入后密钥在安全环境（如TEE）使用，提升安全性。也可以通过关键资产存储服务加密保护，可参考Asset Store Kit（关键资产存储服务）。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-universal-keystore-12
爬取时间: 2025-05-08 06:08:14
来源: Huawei Developer


huks.isKeyItemExist：若密钥存在，data为true，若密钥不存在，则error中会输出密钥不存在的error code。开发者需要通过错误码判断密钥不存在，不符合逻辑习惯。建议使用hasKeyItem接口。


huks.hasKeyItem：若密钥存在，返回值为true，若密钥不存在，返回值为false。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-device-certificate-kit
爬取时间: 2025-05-08 06:08:24
来源: Huawei Developer

- HarmonyOS是否支持CFCA证书预置
- 证书链校验器的参数如何获取？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-device-certificate-1
爬取时间: 2025-05-08 06:08:33
来源: Huawei Developer


系统可信证书里已经预置了CFCA的根证书，可实现开发者CFCA证书的合法校验。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-device-certificate-2
爬取时间: 2025-05-08 06:08:43
来源: Huawei Developer


可通过getSubjectName和getPublicKey接口获取CASubject 和CAPubKey 的字节数据，然后将值传入CertChainValidationParameters。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network
爬取时间: 2025-05-08 06:08:53
来源: Huawei Developer

- 网络（Network）
- 远场通信（Remote Communication）
- 分布式协同管理（Service Collaboration）
- 短距通信（Connectivity）
- 蜂窝通信（Telephony）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-kit
爬取时间: 2025-05-08 06:09:01
来源: Huawei Developer

- http网络请求中extraData支持的数据格式有哪些
- http请求中response错误码返回6是什么意思
- 调用camera拍摄的照片如何上传到服务器
- 如何理解connection.getDefaultNet返回对象netHandle中的netId
- http网络连接中的通用知识
- HTTP接口如何设置Cookie
- http请求的官方示例代码中的extraData是什么类型
- 如何通过网络请求获取数据并通过List组件展示
- WebSocket连接是否支持MQTT协议
- 如何使用网络接口获取数据库MySQL中的数据
- Socket连接报错，错误码88
- Stage模型如何配置支持http明文传输
- Image组件加载网络图片，PixelMap与直接访问url有什么区别
- http请求中能否不设置Content-Type参数
- http请求报错2300006如何解决
- http请求响应为空，报错:"The request has been canceled or the number of requests exceeds 100"
- Socket接口库是否支持绑定域名
- http请求中下载文件报错2300023
- http请求执行的线程是否可控
- http请求并发的最大数量限制是多少
- http请求结束后是否需要进行销毁
- http是否支持连接复用
- 应用能否指定使用某一网络来发请求
- 网络波动情况下，底层系统是否会关闭Socket连接
- 网络相关的三方库有哪些
- 三方件@ohos/axios中发起post请求，如何以queryParams形式传递参数
- ArkTS中HTTP请求如何以JSON形式进行传输
- 手机网络正常，但是调用connection.hasDefaultNet()接口失败
- 按照Axios三方库的下载安装步骤安装Axios，报错404如何解决
- 在ArkTS中，HTTP请求头中header参数中的key是否区分大小写
- httpRequest.request 请求https接口ssl证书验证失败
- 如何实现下载断点续传
- 能否通过httpResponse的result拿到一个加密内容的数据
- 使用SocketServer时，如何解决较高概率接收不到 client.on("message", (value: SocketInfo) 中的回调问题
- 如何判断使用的是移动蜂窝网络
- http请求如何以表单形式进行传输
- 如何实现http长连接
- 如何实现http并行下载
- request和requestInStream的使用边界问题
- 如何使用Charles工具抓包
- Socket下的TLSConnectOptions不配置是否会使用手机上的默认证书
- 在使用Socket连接相关接口时，NetAddress的address参数只能是IP地址，如果只有host的情况如何处理
- 在建立好TCPSocket之后，如何将复合类型结构转换为ArrayBuffer
- 如何将Axios获取GBK格式的网络数据转换UTF-8格式
- 如何解决网络连接状态变化的公共事件返回内容为"NetType":1的问题
- 如何判断当前网络能否上网
- Network connection模块netLost与netUnavailable监听场景如何区别
- http请求传输大于5M文件报错2300023
- connection能力netBearType类型与实际情况不符
- 无网络环境下使用同步方法获取网络状态报错
- 如何监听判断VPN类型网络
- connection如何监听网络事件
- connection如何获取网卡链路地址、DNS地址等信息

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-1
爬取时间: 2025-05-08 06:09:10
来源: Huawei Developer


extraData代表发送请求的额外数据，支持如下数据：

- 当http请求为POST、PUT方法时，此字段为http请求的content。
- 当http请求为GET、OPTIONS、DELETE、TRACE、CONNECT方法时，此字段为http请求的参数补充，参数内容会拼接到URL中进行发送。
- 若开发者传入string对象，开发者需要自行编码，将编码后的string传入。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-3
爬取时间: 2025-05-08 06:09:20
来源: Huawei Developer


错误码6表示地址无法解析主机，可以尝试ping一下request中的URL，确认是否可以ping通。


HTTP 错误码映射关系：2300000 + curl错误码。更多常用错误码，可参考：curl错误码


参考链接


Response常用错误码


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-4
爬取时间: 2025-05-08 06:09:30
来源: Huawei Developer


启动应用，获取权限后系统会访问远程服务器，将拍摄照片保存在本地，通过上传接口将文件从个人手机传送至远程服务器。


参考链接


上传下载


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-5
爬取时间: 2025-05-08 06:09:39
来源: Huawei Developer


问题现象


netId的值如0、100分别代表什么含义？


解决措施


正常情况下，netHandle里的netId为0时表示没联网，大于等于100时为有网状态。


参考链接


NetHandle


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-6
爬取时间: 2025-05-08 06:09:48
来源: Huawei Developer


http请求需要申请ohos.permission.INTERNET权限，其错误码参考文档：错误码合集。


常用的请求方式为GET、POST，请求成功时，返回的业务数据在data.result中，cookie信息则在data.cookies中，更改字符集方法为：在请求头head中添加参数为


```less
'Content-Type'："application/json; charset=UTF-8"。
```


其请求网页时，返回的数据有时为超长文本内容，console.log无法正确输出。


参考链接


http开发指导


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-7
爬取时间: 2025-05-08 06:09:58
来源: Huawei Developer


HttpRequestOptions中的header是一个Object类型，可以直接在header里设置cookie。调用httpRequest.request()需要申请权限：ohos.permission.INTERNET。使用时，httpRequest.request()接口中的“EXAMPLE_URL”需要替换成实际请求地址。参考代码如下：


```typescript
import { http } from '@kit.NetworkKit';


class Header {
  public contentType: string;
  public cookie: Record<string, string>;


  constructor(contentType: string, cookie: Record<string, string>) {
    this.contentType = contentType;
    this.cookie = cookie;
  }
}


@Entry
@Component
struct HttpRequest {
  @State message: string = '发起请求';


  request() {
    let httpRequest = http.createHttp();
    let options: http.HttpRequestOptions = {
      method: http.RequestMethod.POST, // 可选，默认为http.RequestMethod.GET
      // 当使用POST请求时此字段用于传递请求体内容，具体格式与服务端协商确定
      extraData: 'data to send',
      expectDataType: http.HttpDataType.STRING, // 可选，指定返回数据的类型
      priority: 1, // 可选，默认为1
      // 开发者根据自身业务需要添加header字段，第一个参数为contentType，第二个参数为cookie
      header: new Header('application/json', { 'name': 'value', 'name2': 'value2' })
    };
    console.info('Header:' + JSON.stringify(new Header('application/json', { 'name': 'value', 'name2': 'value2' })));
    httpRequest.request("EXAMPLE_URL", options, (err: Error, data: http.HttpResponse) => {
      if (!err) {
        console.info('Result:' + data.result);
        console.info('code:' + data.responseCode);
        console.info('type:' + JSON.stringify(data.resultType));
        console.info('header:' + JSON.stringify(data.header));
        console.info('cookies:' + data.cookies); // 自API version 8开始支持cookie
      } else {
        console.info('error:' + JSON.stringify(err));
      }
    });
  }


  build() {
    Row() {
      Column() {
        Button(this.message)
          .fontSize(30)
          .fontWeight(FontWeight.Bold)
          .onClick(() => {
            this.request();
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


参考链接


数据请求


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-9
爬取时间: 2025-05-08 06:10:07
来源: Huawei Developer

1. 

```less
1）extraData:"data to send";
2）extraData:{ data: "data to send", };
3）extraData:{ data: new ArrayBuffer(1)};
```


参考链接


HttpRequestOptions


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-11
爬取时间: 2025-05-08 06:10:17
来源: Huawei Developer


通过http组件发送网络请求获取数据，然后在List组件中使用循环渲染组件遍历展示数据。


参考链接


网络请求，循环渲染


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-12
爬取时间: 2025-05-08 06:10:27
来源: Huawei Developer


目前WebSocket不支持MQTT协议。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-13
爬取时间: 2025-05-08 06:10:37
来源: Huawei Developer


目前不支持直接从MySQL数据库中读取数据。可以使用其他语言开发一个服务端，并连接MySQL数据库，从中读取数据。然后使用ArkTS的网络请求接口从服务端获取数据。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-14
爬取时间: 2025-05-08 06:10:46
来源: Huawei Developer


错误码88代表连接通道已关闭。可能原因有Socket连接未绑定IP、端口或者端口不可用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-16
爬取时间: 2025-05-08 06:10:56
来源: Huawei Developer


无需配置，默认支持http明文传输数据。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-17
爬取时间: 2025-05-08 06:11:06
来源: Huawei Developer


两者皆可加载网络图片，使用PixelMap方式时，可以对图片进行更多的效果设置，功能更为强大。


参考链接


Image


PixelMap


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-18
爬取时间: 2025-05-08 06:11:15
来源: Huawei Developer


可以不设置。当不设置此参数时，系统会采用默认的配置"Content-Type: application/json"发起http请求。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-21
爬取时间: 2025-05-08 06:11:25
来源: Huawei Developer


错误码2300006表示域名无法解析。可能的原因为请求的URL编写错误，或者网络不通。


解决方式为：

- 检查请求的URL是否正确。
- 检查网络是否通畅。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-22
爬取时间: 2025-05-08 06:11:35
来源: Huawei Developer


这条错误信息是判断当前不存在httpRequest对象，原因则可能是httpRequest请求次数超过100了创建失败，或者是被调用了destroy方法删掉了导致请求失败。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-23
爬取时间: 2025-05-08 06:11:45
来源: Huawei Developer


Socket不支持域名访问，只能使用IP地址。域名可以通过DNS解析成对应的IP地址。


参考代码如下：


```less
import { connection } from '@kit.NetworkKit' 
import { BusinessError } from "@kit.BasicServicesKit" 
 
connection.getAddressesByName("xxxx", (error: BusinessError, data: connection.NetAddress[]) => { 
  console.log(JSON.stringify(error)); 
  console.log(JSON.stringify(data)); 
})
```


参考链接


获取IP地址


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-26
爬取时间: 2025-05-08 06:11:54
来源: Huawei Developer


问题现象


返回结果中报错："Failed writing received data to disk/application"。


解决措施


错误码2300023表示向磁盘/应用程序写入接收数据失败，可能原因有：

- 原因一：目标文件为只读文件，没有写入权限。
- 原因二：下载的文件大小超过5M。
- 原因三：上一次请求数据未接收完毕调用destroy销毁导致接收数据不完整。

参考链接：


http数据请求


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-27
爬取时间: 2025-05-08 06:12:03
来源: Huawei Developer


问题现象


三方应用发起http请求时，其执行任务的线程是否可控


解决措施


应用每次发请求时，底层系统都会从线程池中获取一个线程去执行。其线程执行过程是由底层系统管控的，三方应用可以监听相应的事件，以获取对应阶段的数据。三方应用可以控制请求的创建和销毁，其具体执行过程不可控。


参考链接


http开发指导


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-28
爬取时间: 2025-05-08 06:12:13
来源: Huawei Developer


http请求并发数量目前没有限制。


参考链接


http开发指导


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-29
爬取时间: 2025-05-08 06:12:21
来源: Huawei Developer


http请求对象，在请求成功或者失败后，都需要调用destroy()接口进行销毁，以节省资源消耗。详细请参见HTTP数据请求。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-30
爬取时间: 2025-05-08 06:12:31
来源: Huawei Developer


http请求时，底层建立的连接是TCP/IP连接，其是支持连接复用的。


参考链接


http开发指导


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-32
爬取时间: 2025-05-08 06:12:40
来源: Huawei Developer


问题现象


发网络请求时，指定使用的网络，如使用Wi-Fi来发http请求，或者使用蜂窝数据来发起网络请求。


解决措施


应用可以使用connection.setAppNet()接口来将应用绑定到指定的网络上，此时该应用的所有网络请求都会使用该网络，不支持该应用的某个请求使用其他网络。如若需要使用其他网络，则需要再次通过connection.setAppNet()将应用绑定到其他网络上。


参考链接


网络连接管理


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-33
爬取时间: 2025-05-08 06:12:50
来源: Huawei Developer


问题现象


网络波动情况，指网络一下连上，一下断开，非常不稳定，此时底层系统是否会关闭Socket连接。


解决措施


在网络波动时(网络一下断开，一下连上)，底层系统采用的策略是断开连接，关闭Socket端口，不会等待超时返回。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-34
爬取时间: 2025-05-08 06:12:59
来源: Huawei Developer


网络相关的三方库有Axios、httpclient、okdownload等，具体分类可以参考三四方库网络分类。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-35
爬取时间: 2025-05-08 06:13:09
来源: Huawei Developer


```less
let params: Url.URLParams = new Url.URLParams()
params.append('fod' ,'1')
params.append('bard','2')
axios.post('https://developer.mozilla.org/?' + params.toString()).then(res => {
  this.message = "request result: " + JSON.stringify(res.data);
}).catch(err => {
  this.message = "request error: " + err.message;
})
```


```less
axios({ url: 'https://developer.mozilla.org/?', method: 'post', params: { fod: '1', bard: '2', } }).then(res => {
  this.message = "request result: " + JSON.stringify(res.data);
}).catch(err => {
  this.message = "request error: " + err.message;
})
```


参考链接


Url.URLParams


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-36
爬取时间: 2025-05-08 06:13:19
来源: Huawei Developer


在HTTP协议消息头中，使用Content-Type来表示媒体类型信息。


设置该参数值为application/json，请求中的数据就会以JSON形式进行传输。参考代码如下：


```less
import { http } from '@kit.NetworkKit'; 
 
class Header { 
  public contentType: string; 
  constructor(contentType: string) { 
    this.contentType = contentType; 
  } 
} 
let httpRequest = http.createHttp(); 
let promise = httpRequest.request("EXAMPLE_URL", { 
  method: http.RequestMethod.GET, 
  connectTimeout: 60000, 
  readTimeout: 60000, 
  header: new Header('application/json') 
});
```


参考链接


request


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-37
爬取时间: 2025-05-08 06:13:29
来源: Huawei Developer


问题现象


手机可以上网，浏览器可以正常打开网页，但是hasDefaultNet这个方法调用失败，回调函数走到了失败的回调。


可能原因


未申请ohos.permission.GET_NETWORK_INFO权限。


解决措施


connection.hasDefaultNet接口需要申请权限ohos.permission.GET_NETWORK_INFO，Stage模型中，在module.json5配置文件中声明权限ohos.permission.GET_NETWORK_INFO即可。参考代码如下：


```less
{ 
  "module" : { 
    // ... 
    "requestPermissions":[ 
      { 
        "name" : "ohos.permission.GET_NETWORK_INFO", 
        "reason": "$string:reason", 
        "usedScene": { 
          "abilities": [ 
            "FormAbility" 
          ], 
          "when":"inuse" 
        } 
      }, 
}
```


参考链接


访问控制概述


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-39
爬取时间: 2025-05-08 06:13:39
来源: Huawei Developer


问题现象


按照Axios三方库的下载安装步骤安装Axios，执行命令“npm install @ohos/axios --save”报错，错误码404。


解决措施


错误码404表示找不到对应的资源文件。需要对镜像环境进行配置：

1. 

```less
ohpm config set registry https://repo.harmonyos.com/ohpm/
```

2. 

```less
ohpm install @ohos/axios
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-40
爬取时间: 2025-05-08 06:13:48
来源: Huawei Developer


在HTTP协议层对参数的大小写进行了处理，是不区分大小写的，默认为小写。在请求头和响应头中都是如此。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-41
爬取时间: 2025-05-08 06:13:57
来源: Huawei Developer


问题现象


https接口httpRequest.request请求报错：“SSL peer certificate or SSH remote key was not OK”。


解决措施


HTTPS证书是一种数字证书，这种证书的主要作用是保护网站安全性。HTTPS证书校验则是指在建立HTTPS连接时对证书进行校验，保证连接的安全性，使网站的安全性更高。


HTTPS校验主要包括以下几个步骤：


本题中的报错出现在第三步，即客户端对证书校验报错。


客户端对证书的校验，验证SSL证书的四个方面：


客户端如果没有对证书进行校验，就会导致中间人攻击，中间人攻击分两种：SSL劫持和SSL剥离。


SSL劫持原理：第三方攻击者会先把自己接到请求方和接收方之间，然后通过自己伪造的证书先模拟成接收方和请求方交换数据，然后再模拟自己为请求方与接收方进行数据交互。一般SSL劫持容易被用于使用者在自己的浏览器等地方安装了未被权威CA认证的证书，因此需要进行证书校验。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160853.19325800584674564402529461784168:50001231000000:2800:43B759BBF284E071AF4691F9C794F26135A27516E6644F2A1CECA397B1361951.png)

SSL剥离通常发生在HTTP请求中，不过现在的网站大部分强制使用HTTPS访问网站，这里不再赘述。


问题1：开发者应对服务端的证书进行上述四个方面的检查，确认无误。若服务端证书是自定义的CA，即SSL证书不是由浏览器中“受信任的根证书颁发机构”颁发，可以通过使用httpRequest.request接口的HttpRequestOptions参数中的caPath设置自定义CA的路径，如果设置了此参数，系统将使用用户指定路径的CA证书，(开发者需保证该路径下CA证书的可访问性)，否则将使用系统预设CA证书，系统预设CA证书位置：/etc/ssl/certs/cacert.pem。


问题2：当前不支持忽略证书验证的能力。客户端需要对证书进行验证，否则会导致中间人攻击。


参考链接


API参考：HttpRequestOptions


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-42
爬取时间: 2025-05-08 06:14:07
来源: Huawei Developer


断点续传的实现需要依赖于服务器，客户端仅支持通过设置下载的开始位置和结束位置来控制是否断点续传。开发者可以通过@ohos.request模块来实现上传下载功能，设置下载任务的配置信息request.agent.Config中的begins和ends参数，具体可以参考：request.agent.create。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-43
爬取时间: 2025-05-08 06:14:16
来源: Huawei Developer


使用http请求传递加密数据能够在result中获取到结果。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-44
爬取时间: 2025-05-08 06:14:25
来源: Huawei Developer


可能原因


客户端的socket被回收释放而导致较高概率接收不到client.on("message", (value: SocketInfo) 中的回调。


解决措施


定义一个数组，在有客户端连接上来的时候，将客户端的socket加入数组中，避免被回收释放从而导致无法接收数据。代码如下：


```typescript
import { socket } from '@kit.NetworkKit'; 
 
let tcpServer: socket.TCPSocketServer = socket.constructTCPSocketServerInstance(); 
// 定义存放客户端连接的数组 
let tcpConnectArray: socket.TCPSocketConnection[] = []; 
 
class SocketInfo { 
  message: ArrayBuffer = new ArrayBuffer(1); 
  remoteInfo: socket.SocketRemoteInfo = {} as socket.SocketRemoteInfo; 
} 
 
@Entry 
@Component 
struct CreateSocket { 
  build() { 
    Column() { 
      Button('创建socket').onClick(async () => { 
        tcpServer.on('connect', (client: socket.TCPSocketConnection) => { 
          // 保存客户端的socket 
          tcpConnectArray.push(client); 
          // Subscribe to events of the TCPSocketConnection object. 
          client.on('close', () => { 
            console.log("on close success"); 
          }); 
          client.on('message', (value: SocketInfo) => { 
            // 此处高概率收不到message 
            let buffer = value.message; 
            let dataView = new DataView(buffer); 
            let str = ''; 
            for (let i = 0; i < dataView.byteLength; ++i) { 
              str += String.fromCharCode(dataView.getUint8(i)); 
            } 
            console.log('received message--:' + str); 
          }); 
        }) 
        console.log('create socket Succeeded '); 
      }) 
 
    } 
    .height('100%') 
    .width('100%') 
    .justifyContent(FlexAlign.Center) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-45
爬取时间: 2025-05-08 06:14:35
来源: Huawei Developer


可以使用@kit.NetworkKit中的connection.getNetCapabilities接口来获取对应的网络能力信息。返回结果中如果bearerTypes的值为0，表示是移动蜂窝网络，否则是其他网络。需要权限：ohos.permission.GET_NETWORK_INFO。


参考代码如下：


```less
import { connection } from '@kit.NetworkKit'; 
 
// 检查网络是否连接 
connection.hasDefaultNet((error, data) => { 
  console.log('data: ' + data); 
}) 
// 获取网络能力信息 
connection.getDefaultNet().then((netHandle) => { 
  connection.getNetCapabilities(netHandle, (error, data) => { 
    console.log(JSON.stringify(error)); 
    console.log(JSON.stringify(data)); 
  }) 
})
```


参考链接


getNetCapabilities


NetBeartype


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-47
爬取时间: 2025-05-08 06:14:45
来源: Huawei Developer


```less
import { http } from '@kit.NetworkKit';


let options: http.HttpRequestOptions = {
  method: http.RequestMethod.GET,
  extraData: 'send message',
  header: { 'Content-Type': 'application/x-www-form-urlencoded' },
  readTimeout: 50000,
  connectTimeout: 50000
}
```


```less
let httpRequest = http.createHttp();
let data = "user=Query&password=Admin123";
httpRequest.request(
  // 填写HTTP请求的URL地址，可以带参数也可以不带参数。URL地址需要开发者自定义。请求的参数可以在extraData中指定   "https:xxx-xxx-xxx",  
  {
    method: http.RequestMethod.POST,
    // 可选，默认为http.RequestMethod.GET   // 开发者根据自身业务需要添加header字段   
    header: { 'Content-Type': 'application/x-www-form-urlencoded' }, // 当使用POST请求时此字段用于传递内容   
    extraData: data,
    connectTimeout: 60000, // 可选，默认为60000ms   
    readTimeout: 60000, // 可选，默认为60000ms   
  }, (err, data) => {
  if (!err) {
    // data.result为HTTP响应内容，可根据业务需要进行解析        
    console.info('Result:' + JSON.stringify(data.result));
    console.info('code:' +
    JSON.stringify(data.responseCode)); // data.header为HTTP响应头，可根据业务需要进行解析       
    console.info('header:' + JSON.stringify(data.header));
    console.info('cookies:' +
    JSON.stringify(data.cookies)); // 从api8开始   
  } else {
    console.info('error:' + JSON.stringify(err)); // 取消订阅HTTP响应头事件  
    httpRequest.off('headersReceive'); // 当该请求使用完毕时，调用destroy方法主动销毁。 
    httpRequest.destroy();
  }
})
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-48
爬取时间: 2025-05-08 06:14:55
来源: Huawei Developer


http模块发送可支持使用长连接，参考代码如下：


```typescript
import { http } from '@kit.NetworkKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
let httpRequest = http.createHttp(); 
httpRequest.requestInStream("EXAMPLE_URL", (err: BusinessError, data: number) => { 
  if (!err) { 
    console.info("requestInStream OK! ResponseCode is " + JSON.stringify(data)); 
  } else { 
    console.error("requestInStream ERROR : err = " + JSON.stringify(err)); 
  } 
})
```


参考链接


requestInStream


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-49
爬取时间: 2025-05-08 06:15:04
来源: Huawei Developer


使用上传下载模块进行下载即可。目前最多支持4个任务同时下载。


参考代码如下：


```less
import { request } from '@kit.BasicServicesKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
let downloadTask: request.DownloadTask; 
try { 
  request.downloadFile(getContext(), { url: 'https://xxxx/xxxx.hap' }).then((data: request.DownloadTask) => { 
    downloadTask = data; 
  }).catch((err: BusinessError) => { 
    console.error(`Failed to request the download. Code: ${err.code}, message: ${err.message}`); 
  }) 
} catch (err) { 
  console.error(`Failed to request the download. err: ${JSON.stringify(err)}`); 
}
```


参考链接


request (上传下载)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-52
爬取时间: 2025-05-08 06:15:14
来源: Huawei Developer


request和requestInStream使用区别在于：request接口有5M的数据，如果响应大于5M用requestinstream。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-55
爬取时间: 2025-05-08 06:15:24
来源: Huawei Developer


Charles是一款用于网络调试和分析的代理工具，可以拦截和查看设备与服务器之间的网络通信。通过Charles，可以监视应用程序的网络流量、修改请求和响应，甚至模拟不同的网络条件。其主要功能包括：

- 截取http和https网络封包。
- 支持重发网络请求，方便后端调试。
- 支持修改网络请求参数。
- 支持网络请求的截获并动态修改。
- 支持模拟慢速网络。

使用时需要通过设置应用的请求经过Charles客户端代理转发到服务器，这样可以在Charles客户端进行抓包。使用Charles进行Web网络抓包非常简单，启动Charles会自动与浏览器设置成代理，不需要进行过多的设置，通过浏览器发送网络请求，Charles就会直接抓取到这些信息和响应信息。


Charles抓包不仅可以抓取来自电脑端的HTTP请求，也能够抓取来自App发出的HTTP请求，手机抓包需要在电脑端配置并且需要手机和电脑在同一网络下，即完成设备代理设置步骤，https协议的报文需要安装SSL证书后才可以抓取，即完成Charles证书下载与证书安装步骤。


Charles具体使用步骤如下：

1.  点击需要连接的Wi-Fi进入密码输入页面 -> 在输入密码前点击“代理” -> 选择“手动” -> 设置“代理的服务器主机名”为Charles的IP地址，“服务器端口”为Charles监听的端口，即设置成8888 -> 最后输入密码，连接上Wi-Fi。
2. 
3. 
4. 
5.  点击需要连接的Wi-Fi进入密码输入页面 -> 在输入密码前点击“代理” -> 选择“手动” -> 设置“代理的服务器主机名”为Charles的IP地址，“服务器端口”为Charles监听的端口，即设置成8888 -> 最后输入密码，连接上Wi-Fi。
6.  点击顶部菜单栏“Help” -> 选择“SSL Proxying” -> 点击“install Charles Root Certificate” -> 点击“安装证书” -> 设置存储位置（可选择当前用户或是本地计算机）后点击“下一步” -> 选择“将所有的证书都放入下列存储” -> 点击“浏览” -> 设置证书存储路径为“受信任的根证书颁发机构”。 方式一：点击Charles顶部菜单栏“Help” -> 选择“SSL Proxying” -> 点击“Install Charles Root Certificate on a Mobile Device or Remote Browser” -> 在手机的自带浏览器中访问http://chls.pro/ssl -> 点击“立即下载”，将证书下载至手机内存内。 方式二：在pc端，点击“Help”-> 点击“SSL Proxying”-> 选择“Save Charles Root Certificate...”，将证书保存到本地，格式为pem类型。将手机连接到电脑上，通过DevEco将刚刚保存的pem文件上传到手机中（鼠标右键点击需要上传到的文件夹，点击“Upload...”，选择刚保存的pem文件），即可进行后续的证书安装步骤。
7.  点击顶部菜单栏“Help” -> 选择“SSL Proxying” -> 点击“install Charles Root Certificate” -> 点击“安装证书” -> 设置存储位置（可选择当前用户或是本地计算机）后点击“下一步” -> 选择“将所有的证书都放入下列存储” -> 点击“浏览” -> 设置证书存储路径为“受信任的根证书颁发机构”。
8.  方式一：点击Charles顶部菜单栏“Help” -> 选择“SSL Proxying” -> 点击“Install Charles Root Certificate on a Mobile Device or Remote Browser” -> 在手机的自带浏览器中访问http://chls.pro/ssl -> 点击“立即下载”，将证书下载至手机内存内。 方式二：在pc端，点击“Help”-> 点击“SSL Proxying”-> 选择“Save Charles Root Certificate...”，将证书保存到本地，格式为pem类型。将手机连接到电脑上，通过DevEco将刚刚保存的pem文件上传到手机中（鼠标右键点击需要上传到的文件夹，点击“Upload...”，选择刚保存的pem文件），即可进行后续的证书安装步骤。
9.  证书在手机上的安装步骤如下： 在手机端点击“设置” -> 隐私和安全 -> 下滑点击“高级” -> 选择“证书与凭据”，进入证书的安装选项中 -> 选择“从存储设备安装” -> 点击“CA证书” -> 点击“继续” -> 选择“浏览” -> 找到下载的证书的位置 -> 点击证书 -> 弹出“安装证书成功”的弹窗文字，则安装成功。 选择【从存储设备安装】 点击【CA证书】
10.  通常情况下，需要对网络请求进行过滤，只监控指定目录服务器上发送的请求。对于这种需求，有以下两种办法：
11. 
12. 
1. 
2. 
3. 
4.  点击需要连接的Wi-Fi进入密码输入页面 -> 在输入密码前点击“代理” -> 选择“手动” -> 设置“代理的服务器主机名”为Charles的IP地址，“服务器端口”为Charles监听的端口，即设置成8888 -> 最后输入密码，连接上Wi-Fi。
- Charles的IP地址查看方式：点击Help -> Local IP Address查看。
- 电脑IP地址查看方式：打开“运行”（快捷键：win+R键或者在任务栏的”搜索”按钮中查找并点击”运行”），输入“cmd”后进入命令行窗口，在命令行窗口中输入“ipconfig”命令查看IP。
- 
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160853.47347632022731719804197730938456:50001231000000:2800:52ABB48F01DCF81A026E3239823757DCED66543699163F021684D9C25DED72EC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160853.46194269347457329659186682182385:50001231000000:2800:8BFEA32A1B7F87D1A1C80DA9F72F1FB55C24496A5CB71C897AFC482DE620581F.png)
1.  点击顶部菜单栏“Help” -> 选择“SSL Proxying” -> 点击“install Charles Root Certificate” -> 点击“安装证书” -> 设置存储位置（可选择当前用户或是本地计算机）后点击“下一步” -> 选择“将所有的证书都放入下列存储” -> 点击“浏览” -> 设置证书存储路径为“受信任的根证书颁发机构”。
2.  方式一：点击Charles顶部菜单栏“Help” -> 选择“SSL Proxying” -> 点击“Install Charles Root Certificate on a Mobile Device or Remote Browser” -> 在手机的自带浏览器中访问http://chls.pro/ssl -> 点击“立即下载”，将证书下载至手机内存内。 方式二：在pc端，点击“Help”-> 点击“SSL Proxying”-> 选择“Save Charles Root Certificate...”，将证书保存到本地，格式为pem类型。将手机连接到电脑上，通过DevEco将刚刚保存的pem文件上传到手机中（鼠标右键点击需要上传到的文件夹，点击“Upload...”，选择刚保存的pem文件），即可进行后续的证书安装步骤。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160854.48498876037013942171657453394072:50001231000000:2800:F442DCDD46D3287B8C784C7F8BBEC4017F53722022030F4BE5C88E61CDAF882A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160854.71263090305294585080254800275745:50001231000000:2800:6519AC897C1F1BFE774EAF93BBD775658756B0B513DDA9D29756E46F14FA0CAA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160854.35512736477472777685466288638442:50001231000000:2800:E5210EB26549B8AF5ADD0BE63B19586BEB147968864F7126479F73C2E952C211.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160854.41556702650296694497103841814665:50001231000000:2800:F9F1279648DA7105309E2D01E64662A009DF983F1357AF8D034B8D77E9F0D430.png)

| 选择【从存储设备安装】  | 点击【CA证书】  |
| --- | --- |
|   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160854.27482592292812549437088494767950:50001231000000:2800:B55E7A34F87B853923A0958E76B7E82C157AFE713CE4B4F0FC1D14A413F09CC5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160854.87119673497442458947948328810667:50001231000000:2800:5EA16CC15FD78645A6C6314D2A3F275C556806BF621ADF867557DCDE6A0D721E.png)
1. 
2. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160854.50382752940625979612883226814606:50001231000000:2800:2CECD7166795B26467A8464F98D1228E1AF1311378500F75612A05DA35EFBE17.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160854.86380735634671552180209287475523:50001231000000:2800:ABE487AD5300C86D063F642AB7871DD81F6444C66E2B643387C2FED94BD965F4.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-56
爬取时间: 2025-05-08 06:15:33
来源: Huawei Developer


使用TLSSocket请求需要手动通过代码配置，不会使用手机上的默认证书。TLSConnectOptions部分配置证书需要使用与请求地址相匹配的证书内容，可将证书放至rawfile文件下通过getRawFileContent()方法读取转换为string类型数据放入。后续将会支持系统已安装的CA证书。


参考链接


应用通过-tls-socket-进行加密数据传输


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-57
爬取时间: 2025-05-08 06:15:43
来源: Huawei Developer


可通过使用getAddressByName接口解析主机名以获取IP地址。


参考链接


getAddressByName


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-58
爬取时间: 2025-05-08 06:15:52
来源: Huawei Developer


可将复合类型结构转换为字符串后使用如下方法转为ArrayBuffer，参考代码如下：


```typescript
interface ObjData { 
  A1: string, 
  B1: number, 
  C1: ObjData2 
} 
interface ObjData2 { 
  key1: string, 
  key2: string 
} 
 
@Entry 
@Component 
export  struct ObjectToArrayBuffer { 
  @State message: string = 'Object转ArrayBuffe'; 
 
  strToArrayBuffer(str: string) { 
    let buf = new ArrayBuffer(str.length * 2); 
    let bufView = new Uint16Array(buf); 
    for (let i = 0,  strLen = str.length; i < strLen; i++) { 
      bufView[i] = str.charCodeAt(i); 
    } 
    return bufView; 
  } 
 
  build() { 
    Row() { 
      Column() { 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(() => { 
            let objData: ObjData = { 
              A1:'字符串', 
              B1: 1, 
              C1:{'key1':'FF','key2':'GG'} 
            } 
            let buf1 = this.strToArrayBuffer(JSON.stringify(objData)); 
            console.info(`buf1: ${JSON.stringify(buf1 )}`); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-59
爬取时间: 2025-05-08 06:16:02
来源: Huawei Developer


通过util实现GBK转换UTF-8格式，实现思路如下：


1. 引入axios和util。


2. 使用axios获取网络数据，并将获取数据类型设置为ARRAY_BUFFER。


3. 使用util.TextDecoder方法进行解码操作。


4. 将解码后的数据通过LazyForEach循环显示在列表中。


参考代码如下：


```typescript
import { util } from '@kit.ArkTS'; 
import axios, { AxiosResponse } from '@ohos/axios'; 
 
const URL: string = 'xxx'; 
 
@Entry 
@Component 
struct FriendsBook { 
 
  build() { 
  } 
 
  aboutToAppear() { 
    axios<string, AxiosResponse<string>, null>({ 
      method: 'get', 
      url: URL, 
      // 在使用util.TextDecoder方法时，编码和解码格式要一致，所以在获取时需将数据类型设置为ARRAY_BUFFER，否则会出现乱码。 
      responseType: 'ARRAY_BUFFER' 
    }) 
      .then((res: AxiosResponse) => { 
        // 首先使用create构造TextDecoder实例，将编码格式设置为gbk。 
        const textDecoder = util.TextDecoder.create('gbk', { ignoreBOM: true }); 
        // 其次使用decodeWithStream方法通过解码输入的参数，输出对应UTF-8格式的文本字符串。其中传入的参数必须为Uint8Array格式，因此需将获取的数据使用Uint8Array方法转换数组类型。 
        const result = new Uint8Array(res.data); 
        const resultString = textDecoder.decodeToString(result, { stream: false }); 
        // 解析json字符串。 
        const jsonResult = JSON.parse(resultString) as string; 
      }) 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-60
爬取时间: 2025-05-08 06:16:12
来源: Huawei Developer


返回"NetType":1枚举值表示为NET_CONN_STATE_IDLE网络空闲状态。


如果是监听网络变化，建议使用@ohos.net.connection的能力，请参考@ohos.net.connection。


代码示例如下：


```less
import { connection } from '@kit.NetworkKit'; 
import { BusinessError, commonEventManager } from '@kit.BasicServicesKit'; 
 
function  listen_network() { 
  let netSpecifier: connection.NetSpecifier = { 
    netCapabilities: { 
      // 假设当前默认网络是WiFi，需要创建蜂窝网络连接，可指定网络类型为蜂窝网 
      bearerTypes: [connection.NetBearType.BEARER_CELLULAR, connection.NetBearType.BEARER_WIFI], 
    }, 
  }; 
  let conn = connection.createNetConnection(netSpecifier); 
 
 
  conn.register((err: BusinessError, data: void) => { 
    console.warn('register 网络 ' + JSON.stringify(err)) 
  }); 
 
  // 订阅事件，网络可用 
  conn.on('netAvailable', ((data: connection.NetHandle) => { 
    console.warn('网络可用, netId is ' + data.netId); 
  })); 
 
  // 订阅事件，网络可用 
  conn.on('netCapabilitiesChange', ((data: connection.NetCapabilityInfo) => { 
    console.warn('网络 netCapabilitiesChange bearerTypes ' + data.netCap.bearerTypes); 
    console.warn('网络 netCapabilitiesChange networkCap ' + data.netCap.networkCap); 
  })); 
 
  // 订阅事件，网络不可用 
  conn.on('netUnavailable', ((data: void) => { 
    console.warn('网络不可用, data is ' + JSON.stringify(data)); 
  })); 
 
  // 订阅事件，网络断开 
  conn.on('netLost', ((data: connection.NetHandle) => { 
    console.warn('网络lost, netId is ' + data.netId); 
  })); 
} 
 
// 监听到事件后，需要通过网络接口获取网络状态 
function sub_network() { 
  console.warn('into sub_network') 
  // 公共事件监听代码： 
  let subscribeInfo: commonEventManager.CommonEventSubscribeInfo = { 
    // 订阅消息异常公共事件 
    events: ['usual.event.CONNECTIVITY_CHANGE'] 
  } 
 
  // 创建订阅者回调 
  commonEventManager.createSubscriber(subscribeInfo, (err: BusinessError, subscriber: commonEventManager.CommonEventSubscriber) => { 
    if (err) { 
      console.warn(`Failed to create netWorkSubscribeInfo. Code is ${err.code}, message is ${err.message}`); 
      return; 
    } 
    if (subscribeInfo && subscribeInfo != null) { 
      // 订阅公共事件回调 
      commonEventManager.subscribe(subscriber, (err: BusinessError, data: commonEventManager.CommonEventData) => { 
        if (err) { 
          console.warn(`Failed to netWorkSubscribe common event. Code is ${err.code}, message is ${err.message}`); 
          return; 
        } 
        console.warn('NET_CONNECTIVITY_CHANGE：' + JSON.stringify(data.parameters)); 
 
        setTimeout(async () => { 
          connection.getDefaultNet((error, data) => { 
            console.log(JSON.stringify(error)) 
            console.log(JSON.stringify(data)) 
          }) }, 500); 
        // 此处打印的日志为{'NetType':1,'moduleName':''} 
      }) 
    } 
  }) 
} 
 
@Entry 
@Component 
struct NetWork { 
 
  build() { 
    Row() { 
      Column() { 
        Button('监听网络').onClick(()=>{ 
          listen_network() 
        }) 
        Button('获取网络状态').onClick(()=>{ 
          sub_network() 
        }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-61
爬取时间: 2025-05-08 06:16:21
来源: Huawei Developer


可以使用@ohos.net.connection的能力，每次网络连接发生变化时，都判断一下当前网络是否能上网，然后将判断结果用AppStorage存储起来，需要判断能否上网时直接从AppStorage里获取结果。参考代码如下：


```typescript
import { connection } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';




@Entry
@Component
export struct NetJudge {
  public static netConnection: connection.NetConnection | undefined = undefined;
  private static JUDGE_NET_TAG: string = 'NetJudge.currNet.isUseful';


  init() {
    NetJudge.netConnection = connection.createNetConnection();
    NetJudge.netConnection.register(() => {
      console.info('connection register success');
    });


    NetJudge.netConnection.on('netAvailable', (data) => {
      console.info('NetJudge  netAvailable ');
      AppStorage.setOrCreate(NetJudge.JUDGE_NET_TAG, this.judgeHasNet());
    });


    NetJudge.netConnection.on('netUnavailable', () => {
      console.info('NetJudge  netUnavailable ');
      AppStorage.setOrCreate(NetJudge.JUDGE_NET_TAG, this.judgeHasNet());
    });


    NetJudge.netConnection.on('netCapabilitiesChange', (data: connection.NetCapabilityInfo) => {
      AppStorage.setOrCreate(NetJudge.JUDGE_NET_TAG, this.judgeHasNet());
    });


    // 订阅网络连接信息变化事件。调用register后，才能接收到此事件通知
    NetJudge.netConnection.on('netConnectionPropertiesChange', (data: connection.NetConnectionPropertyInfo) => {
      AppStorage.setOrCreate(NetJudge.JUDGE_NET_TAG, this.judgeHasNet());
    });


    NetJudge.netConnection.on('netLost', () => {
      AppStorage.setOrCreate(NetJudge.JUDGE_NET_TAG, this.judgeHasNet());
    });
  }


  regist() {
    if (NetJudge.netConnection === undefined) {
      this.init();
    }
  }


  judgeHasNet(): boolean {
    try { // 获取当前网络连接
      let netHandle = connection.getDefaultNetSync();


      // 0-100 为系统预留的连接
      if (!netHandle || netHandle.netId < 100) {
        return false;
      }


      // 获取连接的属性
      let netCapability = connection.getNetCapabilitiesSync(netHandle);
      let cap = netCapability.networkCap;
      if (!cap) {
        return false;
      }


      for (let em of cap) {
        if (connection.NetCap.NET_CAPABILITY_VALIDATED === em) {
          return true;
        }
      }
    } catch (e) {
      let err = e as BusinessError;
      console.info('get netInfo error ：' + JSON.stringify(err));
    }
    return false;
  }


  build() {
    Column({ space: 10 }) {
      Button('如何判断当前网络能否上网')
        .onClick(() => {
          this.regist();
        })
    }
    .alignItems(HorizontalAlign.Center)
    .height('100%')
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-62
爬取时间: 2025-05-08 06:16:30
来源: Huawei Developer


netLost事件监听为网络状态丢失的监听，如：Wi-Fi / 移动网络断开时。


netUnavailable事件监听为网络连接成功但是发生异常无法正常访问浏览器的场景（例如设备上显示桌面wifi图标有"!"）。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-64
爬取时间: 2025-05-08 06:16:40
来源: Huawei Developer


http请求默认规格最大可传输5M数据文件，如文件超出当前限制可使用http.requestInstream能力替代。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-65
爬取时间: 2025-05-08 06:16:50
来源: Huawei Developer


netBearType参数当WiFi、蜂窝网络同时连接即双开场景下只会返回WiFi的状态信息，使用时涉及多次调用情况定义为当前规格问题。


参考文档：网络连接管理


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-66
爬取时间: 2025-05-08 06:16:59
来源: Huawei Developer


无网环境调用同步方法请求无法解析拿到nethandle对应内容，方法执行时产生报错，可采用try-catch方式获取报错信息。参考代码如下：


```typescript
import { connection } from '@kit.NetworkKit'
import { BusinessError } from '@kit.BasicServicesKit';


@Entry
@Component
 struct GetErrInfo {
  getErrInfo() {
    try {
      let netHandle = connection.getDefaultNetSync();
      let connectionproperties = connection.getConnectionPropertiesSync(netHandle);
    } catch (err) {
      let error: BusinessError = err as BusinessError;
      console.log('error: ' + JSON.stringify(error));
    }
  }


  build() {
    Row() {
      Column() {
        Button('获取网络类型')
          .onClick(() => {
            this.getErrInfo();


          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-67
爬取时间: 2025-05-08 06:17:09
来源: Huawei Developer


VPN类型可使用getNetCapabilities方法获取到bearerTypes，当bearerTypes的值是4时表示使用了VPN。参考代码如下：


```typescript
import { connection } from '@kit.NetworkKit';


@Entry
@Component
export struct JudeNetType {
  getNetType() {
    connection.getDefaultNet().then((netHandle: connection.NetHandle) => {
      connection.getNetCapabilities(netHandle).then((data: connection.NetCapabilities) => {
        const type: Number = data.bearerTypes[0];
        console.log('Acquire NetType Success：' + type)
        if (type === 4) {
          // 当type的值为4，则网络类型为VPN
          console.log('is vpn');
        }
      })
    });
  }


  build() {
    Column({ space: 10 }) {
      Button('获取网络连接类型').onClick(() => {
        this.getNetType()
      })
    }.alignItems(HorizontalAlign.Center)
    .height('100%')
    .width('100%')
  }
}
```


参考文档：网络连接管理


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-69
爬取时间: 2025-05-08 06:17:19
来源: Huawei Developer


需要先调用register接口注册订阅事件，然后再使用on方法来监听想要监听的网络事件。以on('netAvailable')订阅网络可用事件为例，参考代码如下：


```typescript
import { connection } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';


@Entry
@Component
struct ListenNetworkEvent {
  listenNetworkEvent() {
    // 创建NetConnection对象
    let netConnection: connection.NetConnection = connection.createNetConnection();


    // 先使用register接口注册订阅事件
    netConnection.register((error: BusinessError) => {
      console.info(JSON.stringify(error));
    });


    // 订阅网络可用事件。调用register后，才能接收到此事件通知
    netConnection.on('netAvailable', (data: connection.NetHandle) => {
      console.info('Succeeded to get data: ' + JSON.stringify(data));
    });
  }


  build() {
    Column({ space: 10 }) {
      Button('监听网络事件').onClick(() => {
        this.listenNetworkEvent()
      })
    }
    .alignItems(HorizontalAlign.Center)
    .height('100%')
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-network-70
爬取时间: 2025-05-08 06:17:28
来源: Huawei Developer


可以使用connection.getConnectionProperties去获取netHandle对应的网络的连接信息，获取到的信息包括网卡链路地址、DNS地址等信息。参考代码如下：


```typescript
import { connection } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';


@Entry
@Component
struct GetConnectionProperties {
  getConnectionProperties() {
    connection.getDefaultNet().then((netHandle: connection.NetHandle) => {
      connection.getConnectionProperties(netHandle, (error: BusinessError, data: connection.ConnectionProperties) => {
        if (error) {
          console.error(`Failed to get connection properties. Code:${error.code}, message:${error.message}`);
          return;
        }
        console.info('Succeeded to get data: ' + JSON.stringify(data));
      })
    });
  }


  build() {
    Column({ space: 10 }) {
      Button('获取对应的网络连接信息')
        .onClick(() => {
          this.getConnectionProperties();
        })
    }
    .alignItems(HorizontalAlign.Center)
    .height('100%')
    .width('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-remote-communication
爬取时间: 2025-05-08 06:17:38
来源: Huawei Developer

- rcp模块发起请求时如何设置超时时间

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-remote-communication-1
爬取时间: 2025-05-08 06:17:48
来源: Huawei Developer


rcp模块发起请求如需要设置超时时间，可在建立session会话前设置SessionConfiguration内有关参数。


相关示例如下：


```typescript
import { rcp } from '@kit.RemoteCommunicationKit';


const sessionConfig: rcp.SessionConfiguration = {
  //用于指定与会话关联的HTTP请求的配置
  requestConfiguration: {
    transfer: {
      //超时时间参数设置
      timeout: {
        //连接超时，默认值是60000
        connectMs: 5000,
        //传输超时，默认值是60000
        transferMs: 10000,
      },
    }
  }
};
const session = rcp.createSession(sessionConfig);


@Entry
@Component
export struct SetTimeout {
  build() {
    Row() {
      Column() {
        Button('超时时间参数设置')
          .onClick(() => {
            if (session) {
              console.log('创建session成功')
              console.log('连接超时参数设置:', sessionConfig.requestConfiguration?.transfer?.timeout?.connectMs);
              console.log('传输超时参数设置:', sessionConfig.requestConfiguration?.transfer?.timeout?.transferMs);
            } else {
              console.log('创建session失败');
            }
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}


```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-service-collaboration-kit
爬取时间: 2025-05-08 06:17:58
来源: Huawei Developer

- 接入跨设备互通控件后，设备选择列表没有周围设备

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/servicecollaboration-faq-1
爬取时间: 2025-05-08 06:18:07
来源: Huawei Developer


跨设备互通API支持根据特定调用策略调用设备。调用策略：2in1设备可以调用平板和手机，平板可以调用手机，同类型设备不可调用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-connectivity-kit
爬取时间: 2025-05-08 06:18:17
来源: Huawei Developer

- 三方应用如何获取蓝牙mac地址
- 如何扫描Wi-Fi列表
- USE_BLUETOOTH 和 ACCESS_BLUETOOTH的区别是什么
- 设备连接Wi-Fi后，如何获取当前设备的IP地址
- 如何获取网络类型：Wi-Fi，3G，4G，5G等

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-connectivity-1
爬取时间: 2025-05-08 06:18:27
来源: Huawei Developer


调用bluetoothManager.startBluetoothDiscovery()接口，使用蓝牙扫描功能，在扫描结果中即可获取蓝牙mac地址。参考代码如下：


```less
import { connection } from '@kit.ConnectivityKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
function onReceiveEvent(data: Array<string>) { // data为蓝牙设备地址集合 
  console.info('bluetooth device find = '+ JSON.stringify(data)); 
} 
 
try { 
  connection.on('bluetoothDeviceFind', onReceiveEvent); 
  connection.startBluetoothDiscovery(); 
} catch (err) { 
  console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message); 
}
```


参考链接


发现蓝牙设备


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-connectivity-2
爬取时间: 2025-05-08 06:18:36
来源: Huawei Developer


使用wifiManager.getScanInfoList方法获取扫描Wi-Fi结果，需要权限：ohos.permission.GET_WIFI_INFO。参考代码如下：


```less
import { wifiManager } from '@kit.ConnectivityKit'; 
 
try { 
  let scanInfoList = wifiManager.getScanInfoList(); 
  console.info('scanInfoList:' + JSON.stringify(scanInfoList)); 
  let len = scanInfoList.length; 
  console.log('wifi received scan info: ' + len); 
  if (len > 0) { 
    for (let i = 0; i < len; ++i) { 
      console.info('ssid: ' + scanInfoList[i].ssid); 
      console.info('bssid: ' + scanInfoList[i].bssid); 
      console.info('capabilities: ' + scanInfoList[i].capabilities); 
      console.info('securityType: ' + scanInfoList[i].securityType); 
      console.info('rssi: ' + scanInfoList[i].rssi); 
      console.info('band: ' + scanInfoList[i].band); 
      console.info('frequency: ' + scanInfoList[i].frequency); 
      console.info('channelWidth: ' + scanInfoList[i].channelWidth); 
      console.info('timestamp: ' + scanInfoList[i].timestamp); 
    } 
  } 
} catch (error) { 
  console.error('failed:' + JSON.stringify(error)); 
}
```


参考链接


wifiManager.getScanInfoList


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-connectivity-3
爬取时间: 2025-05-08 06:18:46
来源: Huawei Developer

- USE_BLUETOOTH：已废弃的接口使用该权限（API version 7/8/9），允许应用查看蓝牙的配置。（该权限允许应用查看蓝牙的配置信息，包括蓝牙名称、蓝牙设备类型、开关状态等。）
- ACCESS_BLUETOOTH：API version10及以上的接口使用该权限，允许应用接入蓝牙并使用蓝牙能力，例如配对、连接外围设备等。（允许应用接入并使用蓝牙功能，如扫描发现外围设备与外围蓝牙设备配对、连接等，以及低功耗蓝牙的广播和扫描功能。）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-connectivity-4
爬取时间: 2025-05-08 06:18:55
来源: Huawei Developer


使用wifiManager模块获取ipInfo，然后转换为IP常用格式，注意wifiManager.getIpInfo()接口需要权限ohos.permission.GET_WIFI_INFO。


参考代码如下：


```less
import { wifiManager } from '@kit.ConnectivityKit'; 
 
let ipAddress = wifiManager.getIpInfo().ipAddress; 
let ip = (ipAddress >>> 24) + "." + (ipAddress >> 16 & 0xFF) + "." + (ipAddress >> 8 & 0xFF) + "." + (ipAddress & 0xFF);
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-connectivity-5
爬取时间: 2025-05-08 06:19:05
来源: Huawei Developer


先通过getNetCapabilities去获取网络的类型，判断默认网络是Wi-Fi还是蜂窝。


如果是Wi-Fi，则直接确认网络类型是Wi-Fi。如果是在蜂窝连接情况下，可以调用radio.getSignalInformation获取指定SIM卡槽对应的注册网络信号强度信息列表，返回SignalInformation对象的数组，其中，返回的signalType代表网络类型NetworkType，signalType的值对应网络类型如下：

- GSM：2G
- CDMA：电信2G
- WCDMA：3G
- TDSCDMA：3G
- LTE：4G
- NR：5G

具体可参考如下示例代码：


```typescript
import { connection } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { radio } from '@kit.TelephonyKit';


@Entry
@Component
struct Index {
  build() {
    Column() {
      Button('获取网络类型')
        .type(ButtonType.Normal)
        .width(200)
        .height(200)
        .onClick(() => {
          connection.getDefaultNet().then((netHandle: connection.NetHandle) => {
            if (netHandle.netId == 0) {
              // 当前没有已连接的网络时，获取的netHandler的netid为0，属于异常场景，此处可以实际情况自行添加一些处理机制。
              return;
            }
            // 获取netHandle对应的网络的能力信息
            connection.getNetCapabilities(netHandle, (error: BusinessError, data: connection.NetCapabilities) => {
              if (error) {
                console.error(`Failed to get net capabilities. Code:${error.code}, message:${error.message}`);
                return;
              }
              console.info("Succeeded to get data: " + JSON.stringify(data));
              if (data.bearerTypes[0] == 1) {
                // console.info("Wi-Fi网络");
              } else if (data.bearerTypes[0] == 0) {
                // console.info("蜂窝网络");
                let slotId: number = 0; // 卡槽ID, - 0：卡槽1, - 1：卡槽2
                radio.getSignalInformation(slotId, (err: BusinessError, data: Array<radio.SignalInformation>) => {
                  if (err) {
                    console.error(`getSignalInformation failed, callback: err->${JSON.stringify(err)}`);
                    return;
                  }
                  console.log(`getSignalInformation success, callback: data->${JSON.stringify(data)}`);
                  // 返回SignalInformation对象的数组，其中，返回的signalType代表网络类型NetworkType
                });
              }
            })
          }).catch((error: BusinessError) => {
            console.error('error: ' + JSON.stringify(error));
          });
        })
    }
    .width('100%')
    .height('100%')
    .alignItems(HorizontalAlign.Center)
    .justifyContent(FlexAlign.Center)
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-telephony-kit
爬取时间: 2025-05-08 06:19:15
来源: Huawei Developer

- 如何判断蜂窝信号强度
- 如何发送短信

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-telephony-1
爬取时间: 2025-05-08 06:19:24
来源: Huawei Developer


可以通过radio.getSignalInformation​​()接口获取蜂窝信号强度，具体步骤如下：


参考代码如下：


```typescript
import { radio, observer } from '@kit.TelephonyKit'; 
 
// 以获取卡1的信号强度为例 
let slotId: number = 0; 
radio.getSignalInformation(slotId, (err, data) => { 
  if (!err) { 
    console.log("get signal information success."); 
    // 遍历数组，输出不同网络制式下的信号强度 
    for (let j = 0; j < data.length; j++) { 
      console.log("type:" + data[j].signalType + ", level:" + data[j].signalLevel); 
    } 
  } else { 
    console.error("get signal information fail, err is:" + JSON.stringify(err)); 
  } 
}); 
 
// 订阅蜂窝网络信号变化（可选） 
observer.on("signalInfoChange", (data) => { 
  console.log("signal info change, data is:" + JSON.stringify(data)); 
});
```


参考链接


getSignalInformation


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-telephony-2
爬取时间: 2025-05-08 06:19:34
来源: Huawei Developer


可以通过短信服务实现相关功能。发送短信需要请求服务端，然后服务端调用对应的短信接口来实现该功能，使用sms.sendMessage接口发送短信。


参考链接


@ohos.telephony.sms (短信服务)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-basic-functions
爬取时间: 2025-05-08 06:19:43
来源: Huawei Developer

- 基础服务（Basics Service）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-basic-services-kit
爬取时间: 2025-05-08 06:19:52
来源: Huawei Developer

- 如何获取系统时间戳
- 是否支持获取用户手机上所有的App列表
- eventId一样时，Emitter多次调用on是否能注册多个回调？
- 系统设置里应用的权限设置只展示应用申请过的权限
- 如何获取系统版本号
- 如何获取系统时间，并且在切换时区时，时间戳一直保持北京时间
- 上传文件的uploadConfig中，internal开头的路径是否可以换成其他路径
- request.downloadFile 使用报错， err number = 8属于什么问题
- OAID、AAID和ODID分别是什么，如何获取设备的唯一标识？
- 通过公共事件服务CES发布、订阅事件，发布事件达到一定数量后，订阅者接收不到发布的事件
- 如何持wakelock锁，防止系统休眠
- 如何获取设备支持的API的版本号

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faq-basics-service-kit-1
爬取时间: 2025-05-08 06:20:02
来源: Huawei Developer


可以通过systemDateTime.getTime()方法获取当前的系统时间和时区。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faq-basics-service-kit-6
爬取时间: 2025-05-08 06:20:12
来源: Huawei Developer


不支持获取设备所有App信息。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faq-basics-service-kit-7
爬取时间: 2025-05-08 06:20:21
来源: Huawei Developer


解决方案


针对同一个eventid多次注册订阅时，若关联的回调对象为同一个，则只会生效第一次注册的回调对象，若关联的回调对象不同，则多个回调对象均生效，由on的顺序决定回调顺序，同时off注销时，eventid与回调对象需配对，否则回调注销失败。


参考资料


events.emitter (Emitter)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faq-basics-service-kit-9
爬取时间: 2025-05-08 06:20:30
来源: Huawei Developer


应用的权限设置中只展示应用申请过的权限，该特性是系统规格，只有在调用requestPermissionsFromUser这个接口，并且用户选择是否授予权限之后，才会在应用详情页显示该权限开关。该设计特性考量：这个可以让用户看到一个更干净的权限管理页面，一个用户从来没有打开过的应用，进入应用详情页面却有一大堆权限，用户也会不大理解。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faq-basics-service-kit-10
爬取时间: 2025-05-08 06:20:40
来源: Huawei Developer


可通过@ohos.deviceInfo (设备信息)模块，查询设备信息。


示例如下：


```typescript
import { deviceInfo } from '@kit.BasicServicesKit';


let displayVersionInfo: string = deviceInfo.displayVersion; // 产品版本
let osFullNameInfo: string = deviceInfo.osFullName; // 系统版本
let versionIdInfo: string = deviceInfo.versionId; // 版本ID


@Entry
@Component
struct GetSysVersion {
  build() {
    Row() {
      Column() {
        Button('get device info')
          .onClick(() => {
            console.info('displayVersion: ', displayVersionInfo);
            console.info('osFullName: ', osFullNameInfo);
            console.info('versionId: ', versionIdInfo);
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faq-basics-service-kit-11
爬取时间: 2025-05-08 06:20:50
来源: Huawei Developer


使用systemDateTime.getTime()可以获取自Unix纪元以来经过的时间。getTime获取的是Unix时间戳，Unix时间戳和时区无关，在任何时区返回的值都是一致的。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faq-basics-service-kit-12
爬取时间: 2025-05-08 06:21:00
来源: Huawei Developer


internal对应在cache目录下，当前只支持上传应用自己沙箱路径的文件，目前不支持uri方式。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faq-basics-service-kit-13
爬取时间: 2025-05-08 06:21:10
来源: Huawei Developer


目前err num=8表示未知错误，更多错误码详情请参见错误码。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faq-basics-service-kit-14
爬取时间: 2025-05-08 06:21:19
来源: Huawei Developer


OAID：开放匿名设备标识符，是一种非永久性设备标识符，基于开放匿名设备标识符，可在保护用户个人数据隐私安全的前提下，向用户提供个性化广告，同时三方监测平台也可以向广告主提供转化根因分析。OAID具有以下特性：

- OAID是设备级标识符，同一台设备上不同的App获取到的OAID值一样。
- OAID的获取受应用的跟踪开关影响：当应用的跟踪开关开启时，该应用可获取到非全0的有效OAID；当应用的跟踪开关关闭时，该应用仅能获取到全0的OAID。
- 同一台设备上首个应用开启应用跟踪开关时，会首次生成OAID。

AAID：应用匿名标识符，标识运行在移动智能终端设备上的应用实例，只有该应用实例才能访问该标识符，它只存在于应用的安装期，总长度32位。与无法重置的设备级硬件ID相比，AAID具有更好的隐私权属性。AAID具有以下特性：

- 匿名化、无隐私风险：AAID和已有的任何标识符都不关联，并且每个应用只能访问自己的AAID。
- 同一个设备上，同一个开发者的多个应用，AAID取值不同。
- 同一个设备上，不同开发者的应用，AAID取值不同。
- 不同设备上，同一个开发者的应用，AAID取值不同。
- 不同设备上，不同开发者的应用，AAID取值不同

ODID：开发者匿名设备标识符，它主要用于开放给开发者的设备标识，同一设备上运行的同一个开发者的应用，ODID相同。帮助开发者更好地理解用户在不同应用间的行为，从而提供更个性化的服务和推荐。ODID具有以下特性：

- 同一设备上运行的同一个开发者的应用，ODID相同。
- 同一个设备上不同开发者的应用，ODID不同。
- 不同设备上同一个开发者的应用，ODID不同。
- 不同设备上不同开发者的应用，ODID不同。

如果想获取设备的唯一标识符，可以使用AAID，获取方法参考链接；广告业务场景下则可以使用OAID；开发者基于应用的分析可以用ODID。


参考链接


获取AAID、广告标识服务、设备信息


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faq-basics-service-kit-15
爬取时间: 2025-05-08 06:21:29
来源: Huawei Developer


通过commonEventManager.createSubscriber()创建订阅者时，需要保存返回的订阅者对象subscriber。应用切换后台之后，如果预测能回收的对象尺寸大于2M会触发一次Full GC，未保存的subscriber会被清理掉，进而导致订阅取消、收不到数据。


参考链接


动态订阅公共事件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faq-basics-service-kit-16
爬取时间: 2025-05-08 06:21:38
来源: Huawei Developer


可以调用RunningLock#create接口来创建RunningLock锁。调用RunningLock#hold接口来设置锁定持续时间，在此期间系统不会休眠。锁持续时间超时后，如果没有设置其他RunningLock，锁会自动释放，系统休眠。


参考链接


Runninglock锁


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-hardware
爬取时间: 2025-05-08 06:21:48
来源: Huawei Developer

- 手写笔服务（Pen Kit）
- 传感器（Sensor Service）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-pen-kit
爬取时间: 2025-05-08 06:21:57
来源: Huawei Developer

- Pen Kit手写套件是否支持自定义笔刷？
- Pen Kit手写套件是否支持自定义笔宽？
- Pen Kit手写套件是否支持自定义颜色？
- Pen Kit手写套件的工具栏是否可以单独提供？
- 集成了Pen Kit手写套件，还需要集成报点预测吗？
- 集成了Pen Kit手写套件，还需要集成一笔成形吗？
- Pen Kit报点预测功能能够调整预测的程度吗？
- 为什么一笔成形识别不出来？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/pen-faq-1
爬取时间: 2025-05-08 06:22:06
来源: Huawei Developer


Pen Kit当前支持圆珠笔、钢笔、铅笔、马克笔和荧光笔，暂不支持自定义笔刷。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/pen-faq-2
爬取时间: 2025-05-08 06:22:16
来源: Huawei Developer


Pen Kit当前支持设置5档笔宽范围，取值由华为笔宽算法决定，暂不支持自定义其他笔宽值。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/pen-faq-3
爬取时间: 2025-05-08 06:22:26
来源: Huawei Developer


工具栏支持100+种颜色选择，暂不支持自定义颜色。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/pen-faq-4
爬取时间: 2025-05-08 06:22:35
来源: Huawei Developer


Pen Kit手写套件画布和工具栏是配套提供的，暂不支持单独使用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/pen-faq-5
爬取时间: 2025-05-08 06:22:45
来源: Huawei Developer


不需要，手写套件已经自带报点预测功能。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/pen-faq-6
爬取时间: 2025-05-08 06:22:55
来源: Huawei Developer


不需要，手写套件已经自带一笔成形功能。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/pen-faq-7
爬取时间: 2025-05-08 06:23:04
来源: Huawei Developer


当前的预测程度是由华为算法调试优化后的结果，暂不提供设置程度类的接口。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/pen-faq-8
爬取时间: 2025-05-08 06:23:14
来源: Huawei Developer


一笔成形能力需要在绘制某一笔划结束时，手写笔/手指停留在屏幕上并保持静止一定时间后（默认为300ms，应用侧可自行定制），才会触发图形识别。也可在套件工具栏的设置中，打开“抬笔成形”，开启后则不需要停顿，抬笔即可触发形状的识别。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-sensor-service-kit
爬取时间: 2025-05-08 06:23:23
来源: Huawei Developer

- 如何解决震动模块接口调用报错，错误码201的问题
- 如何读取运动传感器比如加速度传感器

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-sensor-service-1
爬取时间: 2025-05-08 06:23:32
来源: Huawei Developer


问题现象


震动模块接口调用报错，错误码201。


错误信息：“vibrate fail, error.code: 201error.message: NaN“。


解决措施


权限校验失败。需要申请ohos.permission.VIBRATE权限。


参考链接


应用权限管控概述


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-sensor-service-2
爬取时间: 2025-05-08 06:23:42
来源: Huawei Developer


1. 导入sensor (传感器)模块：


```less
import { sensor } from '@kit.SensorServiceKit';
```


2. 设置加速度传感器数据回调监听：


```less
try { 
    sensor.on(sensor.SensorId.ACCELEROMETER, (data) => { 
        console.info('X-coordinate component: ' + data.x); 
        console.info('Y-coordinate component: ' + data.y); 
        console.info('Z-coordinate component: ' + data.z); 
    }, { interval: 10000000 }); 
} catch (err) { 
    console.error('On fail, errCode: ' + err.code + ' ,msg: ' + err.message); 
}
```


参考链接


传感器


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-development
爬取时间: 2025-05-08 06:23:52
来源: Huawei Developer

- 拍照和图片
- 音频和视频

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-photographing-pictures
爬取时间: 2025-05-08 06:24:00
来源: Huawei Developer

- 相机开发（Camera）
- 图片处理（Image）
- 扫码服务（Scan）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-kit
爬取时间: 2025-05-08 06:24:10
来源: Huawei Developer

- 使用XComponent组件显示相机的预览输出流时，如何获取相机的帧数据
- 如何获取前置摄像头的预览图像
- 如何设置相机焦距
- 如何检测当前相机服务的状态
- 如何读取相机的预览图
- 如何保证相机在全屏预览时不变形
- 相机预览切后台再回来画面不正确
- 如何实现相机关闭
- 预览流黑屏但无报错信息该怎么解决
- 调用API方法camera.getCameraManager传入context报错如何解决
- 如何避免预览流产生畸变
- 如何开关闪光灯
- 如何调用系统拍照并获取图片
- 视频的SPS/PPS需要单独传递给解码器吗
- 视频流支持哪些格式
- 视频预览分辨率设置
- 如何实现拍照预览onPreviewFrame回调
- YUV数据相关格式

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-1
爬取时间: 2025-05-08 06:24:20
来源: Huawei Developer


通过创建双路预览来实现。


参考链接


双路预览


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-2
爬取时间: 2025-05-08 06:24:30
来源: Huawei Developer


获取前置摄像头预览图像示例代码如下：


```typescript
import { BusinessError } from '@kit.BasicServicesKit'; 
import { camera } from '@kit.CameraKit'; 
import { common } from '@kit.AbilityKit'; 
const context = getContext(this) as common.UIAbilityContext; 
@Entry 
@Component 
struct GetFrontCameraImage { 
  private xComponentController: XComponentController = new XComponentController(); 
  async getCameraImage() { 
    // 1、使用系统相机框架camera模块获取物理摄像头信息。 
    let cameraManager = camera.getCameraManager(context); 
    let camerasInfo: Array<camera.CameraDevice> = cameraManager.getSupportedCameras(); 
    let cameraDevice: camera.CameraDevice = camerasInfo[0]; 
    // 检测相机状态 
    cameraManager.on('cameraStatus', (err: BusinessError, cameraStatusInfo: camera.CameraStatusInfo) => { 
      console.log(`camera : ${cameraStatusInfo.camera.cameraId}`); 
      console.log(`status : : ${cameraStatusInfo.status}`); 
    }); 
    // 2、创建并启动物理摄像头输入流通道 
    // 设置为前置摄像头 camera.CameraPosition.CAMERA_POSITION_FRONT 
    let cameraInput = cameraManager.createCameraInput(camera.CameraPosition.CAMERA_POSITION_FRONT, camera.CameraType.CAMERA_TYPE_DEFAULT); 
    await cameraInput.open(); 
    // 3、拿到物理摄像头信息查询摄像头支持预览流支持的输出格式，结合XComponent提供的surfaceId创建预览输出通道 
    let outputCapability = cameraManager.getSupportedOutputCapability(cameraDevice, camera.SceneMode.NORMAL_PHOTO); 
    let previewProfile = outputCapability.previewProfiles[0]; 
    let surfaceId = this.xComponentController.getXComponentSurfaceId(); 
    let previewOutput = cameraManager.createPreviewOutput(previewProfile, surfaceId); 
    // 4、创建相机会话，在会话中添加摄像头输入流和预览输出流，然后启动会话，预览画面就会在XComponent组件上送显。 
    let captureSession = cameraManager.createSession(camera.SceneMode.NORMAL_PHOTO); 
    captureSession.beginConfig(); 
    captureSession.addInput(cameraInput); 
    captureSession.addOutput(previewOutput); 
    captureSession.commitConfig() 
    captureSession.start(); 
  } 
  build() { 
    Row() { 
      Column({ space: 20 }) { 
        XComponent({ id: 'xComponentId1', type: 'surface', controller: this.xComponentController }) 
          .height(300) 
        Button('打开摄像头') 
          .onClick(() => { 
            // 在调用前确保已经获得相机权限 
            this.getCameraImage(); 
          }) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


参考链接


拍照实现方案


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-3
爬取时间: 2025-05-08 06:24:39
来源: Huawei Developer


参考链接


getZoomRatiorange、setZoomRatio


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-4
爬取时间: 2025-05-08 06:24:49
来源: Huawei Developer


通过cameraManager设置状态回调返回相机状态。


```less
import { camera } from '@kit.CameraKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
 
let cameraManager = camera.getCameraManager(getContext(this)); 
cameraManager.on('cameraStatus', (err: BusinessError, cameraStatusInfo: camera.CameraStatusInfo) => { 
  console.log(`camera : ${cameraStatusInfo.camera.cameraId}`); 
  console.log(`status: ${cameraStatusInfo.status}`); 
});
```


相机状态：CameraStatus


枚举，相机状态。


CAMERA_STATUS_APPEAR 0 新的相机出现。


CAMERA_STATUS_DISAPPEAR 1 相机被移除。


CAMERA_STATUS_AVAILABLE 2 相机可用。


CAMERA_STATUS_UNAVAILABLE 3 相机不可用。


参考链接


CameraStatus


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-6
爬取时间: 2025-05-08 06:24:59
来源: Huawei Developer


开发步骤如下：


1. 导入image接口。


创建双路预览流的SurfaceId，除XComponent组件的SurfaceId外，还需要使用ImageReceiver组件创建生成的SurfaceId，需要使用image模块提供的接口。


```less
import { image } from '@kit.ImageKit';
```


2. 创建ImageReceiver组件Surface。


```typescript
async function getImageReceiverSurfaceId(): Promise<string | undefined> { 
  let receiver: image.ImageReceiver = image.createImageReceiver({width: 640, height: 480}, 4, 8); 
  console.info('before ImageReceiver check'); 
  let ImageReceiverSurfaceId: string | undefined = undefined; 
  if (receiver !== undefined) { 
    console.info('ImageReceiver is ok'); 
    let ImageReceiverSurfaceId: string = await receiver.getReceivingSurfaceId(); 
    console.info(`ImageReceived id: ${ImageReceiverSurfaceId}`); 
  } else { 
    console.error('ImageReceiver is not ok'); 
  } 
  return ImageReceiverSurfaceId; 
}
```


3. 创建XComponent组件Surface。


可参考相机预览指导文档。


```less
//xxx.ets 
// 创建XComponentController 
@Entry 
@Component 
struct XComponentPage { 
  // 创建XComponentController 
  mXComponentController: XComponentController = new XComponentController; 
 
  build() { 
    Flex() { 
      // 创建XComponent 
      XComponent({ 
        id: '', 
        type: 'surface', 
        libraryname: '', 
        controller: this.mXComponentController 
      }) 
        .onLoad(() => { 
          // 设置Surface宽高（1920*1080），预览尺寸设置参考前面 previewProfilesArray 获取的当前设备所支持的预览分辨率大小去设置 
          this.mXComponentController.setXComponentSurfaceRect({surfaceWidth:1920,surfaceHeight:1080}); 
          // 获取Surface ID 
          let surfaceId: string = this.mXComponentController.getXComponentSurfaceId(); 
        }) 
        .width('1920px') 
        .height('1080px') 
    } 
  } 
}
```


4. 实现双路预览。


将步骤2、3生成的两路SurfaceId通过createPreviewOutput方法传递到相机服务，创建两路预览流，其余流程按照正常预览流程开发。


```less
import { camera } from '@kit.CameraKit';
import { image } from '@kit.ImageKit';


async function createDualChannelPreview(cameraManager: camera.CameraManager, XComponentSurfaceId: string, receiver: image.ImageReceiver): Promise<void> {
  let camerasDevices: Array<camera.CameraDevice> = cameraManager.getSupportedCameras(); // 获取支持的相机设备对象


  // 获取profile对象
  let profiles: camera.CameraOutputCapability = cameraManager.getSupportedOutputCapability(camerasDevices[0], camera.SceneMode.NORMAL_PHOTO); // 获取对应相机设备profiles
  let previewProfiles: Array<camera.Profile> = profiles.previewProfiles;


  // 预览流1
  let previewProfilesObj: camera.Profile = previewProfiles[0];


  // 预览流2
  let previewProfilesObj2: camera.Profile = previewProfiles[0];


  // 创建 预览流1 输出对象
  let previewOutput: camera.PreviewOutput = cameraManager.createPreviewOutput(previewProfilesObj, XComponentSurfaceId);


  // 创建 预览流2 输出对象
  let imageReceiverSurfaceId: string = await receiver.getReceivingSurfaceId();
  let previewOutput2: camera.PreviewOutput = cameraManager.createPreviewOutput(previewProfilesObj2, imageReceiverSurfaceId);


  // 创建cameraInput对象
  let cameraInput: camera.CameraInput = cameraManager.createCameraInput(camerasDevices[0]);


  // 打开相机
  await cameraInput.open();


  // 会话流程
  let captureSession = cameraManager.createSession(camera.SceneMode.NORMAL_PHOTO);


  // 开始配置会话
  captureSession.beginConfig();


  // 把CameraInput加入到会话
  captureSession.addInput(cameraInput);


  // 把 预览流1 加入到会话
  captureSession.addOutput(previewOutput);


  // 把 预览流2 加入到会话
  captureSession.addOutput(previewOutput2);


  // 提交配置信息
  await captureSession.commitConfig();


  // 会话开始
  await captureSession.start();
}
```


5. 通过ImageReceiver实时获取预览图像。


通过ImageReceiver组件中imageArrival事件监听获取底层返回的图像数据，详细的API说明请参考Image API参考。


```less
import { BusinessError } from '@kit.BasicServicesKit'; 
 
function onImageArrival(receiver: image.ImageReceiver): void { 
  receiver.on('imageArrival', () => { 
    receiver.readNextImage((err: BusinessError, nextImage: image.Image) => { 
      if (err || nextImage === undefined) { 
        return; 
      } 
      // 当前ImageReceiver不支持获取YUV数据，可以用JPEG的数据通道来接收YUV的数据，但是使用这种方式有风险 
      nextImage.getComponent(image.ComponentType.JPEG, (err: BusinessError, imgComponent: image.Component) => { 
        if (err || imgComponent === undefined) { 
          return; 
        } 
        if (imgComponent.byteBuffer as ArrayBuffer) { 
          // 根据业务诉求处理 
        } else { 
          return; 
        } 
      }) 
    }) 
  }) 
}
```


参考链接


双路预览


Image API


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-7
爬取时间: 2025-05-08 06:25:08
来源: Huawei Developer


需要获取手机的宽高比，用手机的屏幕的height/width去和支持的预览尺寸的width/height去取最贴近的值。预览流与录像输出流的分辨率的宽高比要保持一致，如示例代码中宽高比为1920:1080 = 16:9，则需要预览流中的分辨率的宽高比也为16:9，如分辨率选择640:360，或960:540，或1920:1080，以此类推。


参考链接


预览(ArkTS)-相机开发指导


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-8
爬取时间: 2025-05-08 06:25:18
来源: Huawei Developer


切换后台再切回来，必须要重新初始化相机才可以。因为切后台，相机资源是全部回收的。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-9
爬取时间: 2025-05-08 06:25:27
来源: Huawei Developer


实现相机关闭参考代码如下：


```less
// 停止当前会话 
  photoSession.stop(); 
 
// 释放相机输入流 
  cameraInput.close(); 
 
// 释放预览输出流 
  previewOutput.release(); 
 
// 释放拍照输出流 
  photoOutput.release(); 
 
// 释放会话 
  photoSession.release(); 
 
// 会话置空 
  photoSession = undefined;
```


参考链接


拍照实现方案(ArkTS)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-10
爬取时间: 2025-05-08 06:25:37
来源: Huawei Developer


可能原因

- 未正确获取相机权限，就进行初始化相机、获取相机输入流等操作。
- 应用切换至后台后切回，相机资源被回收后，没有重新获取权限开启预览导致。
- 设置的预览流尺寸不支持。

解决措施


```less
"requestPermissions": [
{
  "name":
  "ohos.permission.CAMERA", "usedScene":
  {
    "abilities": [
    "FormAbility"       ],
    "when":
    "always"
  }
  ,
  "reason":
  "$string:Camera_Permission_Request"
}
,
{
  "name":
  "ohos.permission.MICROPHONE", "usedScene":
  {
    "abilities": [
    "FormAbility"       ],
    "when":
    "always"
  }
  ,
  "reason":
  "$string:Camera_Permission_Request"
}
,
{
  "name":
  "ohos.permission.WRITE_MEDIA", "usedScene":
  {
    "abilities": [
    "FormAbility"       ],
    "when":
    "always"
  }
  ,
  "reason":
  "$string:Camera_Permission_Request"
}
,
{
  "name":
  "ohos.permission.READ_MEDIA", "usedScene":
  {
    "abilities": [
    "FormAbility"       ],
    "when":
    "always"
  }
  ,
  "reason":
  "$string:Camera_Permission_Request"
}
]
,
```


```less
"requestPermissions": [
{
  "name":
  "ohos.permission.CAMERA", "usedScene":
  {
    "abilities": [
    "FormAbility"       ],
    "when":
    "always"
  }
  ,
  "reason":
  "$string:Camera_Permission_Request"
}
,
{
  "name":
  "ohos.permission.MICROPHONE", "usedScene":
  {
    "abilities": [
    "FormAbility"       ],
    "when":
    "always"
  }
  ,
  "reason":
  "$string:Camera_Permission_Request"
}
,
{
  "name":
  "ohos.permission.WRITE_MEDIA", "usedScene":
  {
    "abilities": [
    "FormAbility"       ],
    "when":
    "always"
  }
  ,
  "reason":
  "$string:Camera_Permission_Request"
}
,
{
  "name":
  "ohos.permission.READ_MEDIA", "usedScene":
  {
    "abilities": [
    "FormAbility"       ],
    "when":
    "always"
  }
  ,
  "reason":
  "$string:Camera_Permission_Request"
}
]
,
```


```less
onWindowStageCreate(windowStage: window.WindowStage): void {
let atManager = abilityAccessCtrl.createAtManager();
atManager.requestPermissionsFromUser(this.context,
  [
    'ohos.permission.CAMERA',
    'ohos.permission.MICROPHONE',
    'ohos.permission.MEDIA_LOCATION',
    'ohos.permission.WRITE_MEDIA'
  ]
).then((data) => {
  console.info('data:' + JSON.stringify(data));
  console.info('data permissions:' + data.permissions);
  console.info('data authResults:' + data.authResults);
  // Main window is created, set main page for this ability 
  hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');


  windowStage.loadContent('pages/CameraPreviewFlow', (err, data) => {
    if (err.code) {
      hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
      return;
    }
    hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
  });
}).catch((err: BusinessError) => {
  console.info('data:' + JSON.stringify(err));
});
}
```


```less
async
onPageShow() {
  let baseContext = getContext() as common.BaseContext;
  await this.initCamera(baseContext, this.surfaceId);
}


async
onPageHide() {
  await this.releaseCamera();
}
```


```typescript
// 获取相机设备支持的输出流能力 
let cameraOutputCap: camera.CameraOutputCapability =
  cameraManager.getSupportedOutputCapability(cameraArray[0], camera.SceneMode.NORMAL_PHOTO);
if (!cameraOutputCap) {
  console.error(TAG, "cameraManager.getSupportedOutputCapability error");
  return;
}
console.info(TAG, "outputCapability: " +
JSON.stringify(cameraOutputCap));  //预览流与录像输出流的分辨率的宽高比要保持一致
let previewProfilesArray: Array<camera.Profile> = cameraOutputCap.previewProfiles;
let position: number = 0;
if (previewProfilesArray != null) {
  previewProfilesArray.forEach((value: camera.Profile,
    index: number) => { // 查看支持的预览尺寸   
    console.info(TAG,
      `支持的预览尺寸: [${value.size.width},${value.size.height},${value.size.width / value.size.height}]`);
    if (value.size.width === 2592 && value.size.height === 1200) {
      position = index;
    }
  })
} else {
  console.error(TAG, "createOutput photoProfilesArray == null || undefined");
}
```


```less
"requestPermissions": [
{
  "name":
  "ohos.permission.CAMERA", "usedScene":
  {
    "abilities": [
    "FormAbility"       ],
    "when":
    "always"
  }
  ,
  "reason":
  "$string:Camera_Permission_Request"
}
,
{
  "name":
  "ohos.permission.MICROPHONE", "usedScene":
  {
    "abilities": [
    "FormAbility"       ],
    "when":
    "always"
  }
  ,
  "reason":
  "$string:Camera_Permission_Request"
}
,
{
  "name":
  "ohos.permission.WRITE_MEDIA", "usedScene":
  {
    "abilities": [
    "FormAbility"       ],
    "when":
    "always"
  }
  ,
  "reason":
  "$string:Camera_Permission_Request"
}
,
{
  "name":
  "ohos.permission.READ_MEDIA", "usedScene":
  {
    "abilities": [
    "FormAbility"       ],
    "when":
    "always"
  }
  ,
  "reason":
  "$string:Camera_Permission_Request"
}
]
,
```


```less
onWindowStageCreate(windowStage: window.WindowStage): void {
let atManager = abilityAccessCtrl.createAtManager();
atManager.requestPermissionsFromUser(this.context,
  [
    'ohos.permission.CAMERA',
    'ohos.permission.MICROPHONE',
    'ohos.permission.MEDIA_LOCATION',
    'ohos.permission.WRITE_MEDIA'
  ]
).then((data) => {
  console.info('data:' + JSON.stringify(data));
  console.info('data permissions:' + data.permissions);
  console.info('data authResults:' + data.authResults);
  // Main window is created, set main page for this ability 
  hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');


  windowStage.loadContent('pages/CameraPreviewFlow', (err, data) => {
    if (err.code) {
      hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
      return;
    }
    hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
  });
}).catch((err: BusinessError) => {
  console.info('data:' + JSON.stringify(err));
});
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-11
爬取时间: 2025-05-08 06:25:46
来源: Huawei Developer


问题现象


调用 API方法camera.getCameraManager传入context报以下错误：


Argument of type 'import("/Users/a58/Downloads/deveco_studio/sdk/openharmony/10/ets/api/application/Context").default' is not assignable to parameter of type 'import("/Users/a58/Downloads/deveco_studio/sdk/openharmony/10/ets/api/app/context").Context'. Type 'Context' is missing the following properties from type 'Context': getOrCreateLocalDir, verifyPermission, requestPermissionsFromUser, getApplicationInfo, and 19 more. <ArkTSCheck>


解决措施


该问题是由不兼容修改引起的。之前用的是FA模型的context，现在应用都是Stage模型的，所以有app/Context和application/Context的变化，可使用getContext()as common.BaseContext获取需要的context。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-12
爬取时间: 2025-05-08 06:25:56
来源: Huawei Developer


使用下列代码获取设备支持的宽和高，然后根据手机屏幕的宽高设置最合适的预览流分辨率，并且使得surface和XComponent的宽高相同。


```typescript
//预览流与录像输出流的分辨率的宽高比要保持一致 
let previewProfilesArray: Array<camera.Profile> = cameraOutputCap.previewProfiles; 
 
let position: number = 0; 
if (previewProfilesArray != null) { 
  previewProfilesArray.forEach((value: camera.Profile, index: number) => { 
    // 查看支持的预览尺寸 
    console.info(TAG, `支持的预览尺寸: [${value.size.width},${value.size.height},${value.size.width / value.size.height}]`); 
    if (value.size.width === 2592 && value.size.height === 1200) { 
      position = index; 
    } 
  }) 
} else { 
  console.error(TAG, "createOutput photoProfilesArray == null || undefined"); 
} 
// DocsCode 2 
 
let photoProfilesArray: Array<camera.Profile> = cameraOutputCap.photoProfiles; 
if (!photoProfilesArray) { 
  console.error(TAG, "createOutput photoProfilesArray == null || undefined"); 
} 
 
this.xComponentWidth = previewProfilesArray[position].size.width; 
this.xComponentHeight = previewProfilesArray[position].size.height; 
 
this.mXComponentController.setXComponentSurfaceSize({ 
  surfaceWidth: this.xComponentWidth, 
  surfaceHeight: this.xComponentHeight 
}); 
// 创建预览输出流,其中参数 surfaceId 参考上文 XComponent 组件，预览流为XComponent组件提供的surface 
try { 
  previewOutput = cameraManager.createPreviewOutput(previewProfilesArray[position], surfaceId); 
} catch (error) { 
  let err = error as BusinessError; 
  console.error(TAG, `Failed to create the PreviewOutput instance. error code: ${err.code}`); 
} 
if (previewOutput === undefined) { 
  return; 
} 
 
// 监听预览输出错误信息 
previewOutput.on('error', (error: BusinessError) => { 
  console.error(TAG, `Preview output error code: ${error.code}`); 
}); 
 
// 创建ImageReceiver对象，并设置照片参数：分辨率大小是根据前面 photoProfilesArray 获取的当前设备所支持的拍照分辨率大小去设置 
let size: image.Size = { 
  height: 1200, 
  width: 2592 
} 
let imageReceiver: image.ImageReceiver = image.createImageReceiver(size, 4, 8);
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-13
爬取时间: 2025-05-08 06:26:06
来源: Huawei Developer


使用isFlashModeSupported方法检测设备是否支持需要设置的闪光灯模式后，使用setFlashMode设置闪光灯模式。


参考代码


```less
setFlash(flashMode: camera.FlashMode) { 
  if (captureSession != null) { 
    let focusModeStatus: boolean = captureSession?.isFlashModeSupported(flashMode); 
    if (focusModeStatus) { 
      console.info(TAG, 'Flash Mode = ' + flashModeRec[flashMode]); 
      captureSession.setFlashMode(flashMode); 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-14
爬取时间: 2025-05-08 06:26:16
来源: Huawei Developer


可使用Camera Picker拉起系统相机进行拍摄，示例代码可参考拉起系统相机。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-15
爬取时间: 2025-05-08 06:26:25
来源: Huawei Developer


AVC视频中的SPS/PPS需要通过queueInputBuffer提交。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-16
爬取时间: 2025-05-08 06:26:35
来源: Huawei Developer


问题现象


视频流除了 ArrayBuffer 和 Uint8Array 还有其他格式吗？这些字节组都可以转化为不同格式的图片吗？


解决措施


ts层无其他格式， 这些字节数据可以转成pixelMap，经过编码后可以转成JPEG、WebP 和 png 格式（目前支持这三种）。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-17
爬取时间: 2025-05-08 06:26:44
来源: Huawei Developer


问题现象


旋转手机，预览画面中同一个物品高度会发生明显变化，画面畸变。代码中的预览分辨率：previewProfile {"format":1003,"size":{"width":3200,"height":2400}}，XComponent的surfaceWidth: 3200, surfaceHeight: 2400。


```less
XComponent({ 
  id: 'componentId', 
  type: 'surface', 
  controller: this.mXComponentController, 
}).onLoad(async () => { 
  this.surfaceId = this.mXComponentController.getXComponentSurfaceId(); 
  let baseContext = getContext() as common.BaseContext; 
  await this.initCamera(baseContext, this.surfaceId) 
}).width('100%') 
  .height('100%')
```


可能原因


设置XComponent宽高比不合适导致的。


解决措施


上面代码 .width('100%').height('100%') 这两个值不要都设置成100%， 保证width和height的比例与previewProfile的height与width比例一致。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-19
爬取时间: 2025-05-08 06:26:54
来源: Huawei Developer


使用双路预览实现onPreviewFrame回调，设置previewOutput2接收连续数据，示例代码如下，在示例代码中保存接收到的前三帧数据，也可以通过业务需要调整：


```less
this.previewOutput = this.cameraManager!.createPreviewOutput(previewProfilesArray[5], surfaceId); 
let size: image.Size = { 
  width: 640, 
  height: 480 
} 
let receiver: image.ImageReceiver = image.createImageReceiver(size, image.ImageFormat.JPEG, 8); 
receiver.on('imageArrival', () => { 
  receiver.readNextImage((err: BusinessError, nextImage: image.Image) => { 
    if (err || nextImage === undefined) { 
      console.error('readNextImage failed'); 
      return; 
    } 
    nextImage.getComponent(image.ComponentType.JPEG, (err: BusinessError, imgComponent: image.Component) => { 
      if (err || imgComponent === undefined) { 
        console.error('getComponent failed'); 
      } 
      if (imgComponent && imgComponent.byteBuffer as ArrayBuffer && this.count<3) { 
        this.count = this.count + 1 
        let path: string = getContext().filesDir + "/image.yuv"; 
        let file = fileIo.openSync(path, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE); 
        let opt: WriteOptions = { 
          // 多出2048字节数据 
          length: imgComponent.byteBuffer.byteLength - 2048 
        } 
        fileIo.write(file.fd, imgComponent.byteBuffer, opt).then((writeLen) => { 
          console.info("write data to file succeed and size is:" + writeLen); 
          fileIo.closeSync(file); 
        }).catch((err: BusinessError) => { 
          console.info("write data to file failed with error message: " + err.message + ", error code: " + err.code); 
        }); 
      } 
      nextImage.release(); 
    }) 
  }) 
}) 
let ImageReceiverSurfaceId: string = await receiver.getReceivingSurfaceId(); 
this.previewOutput2 = this.cameraManager!.createPreviewOutput(previewProfilesArray[5], ImageReceiverSurfaceId); 


```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-camera-22
爬取时间: 2025-05-08 06:27:03
来源: Huawei Developer


目前相机给出的YUV数据是8bit位深的，采用的是BT709色域。


相机有HDR模式，采用的是HDR vivid标准；返回10bit位深的YUV数据，使用的是BT2020色域。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-kit
爬取时间: 2025-05-08 06:27:13
来源: Huawei Developer

- 通过PixelMap_CreatePixelMap创建的对象，内存在ArkTS侧和Native侧是否共享
- 如何设置图片的高斯模糊效果
- 调用imageSource.createPixelMap()报错“Create PixelMap error”
- 图片压缩API的质量参数quality与图片原始大小、压缩后大小的关系
- 图片编解码支持的格式有哪些
- 如何将相册选择的图片生成PixelMap
- 如何对相册图片进行编辑裁剪
- 如何设置图片显示的分辨率
- 如何读取相册中的图片
- 如何把ImageReceiver收到的视频帧数据保存到本地
- 为什么获取到的yuv数据量比宽 * 高 * 1.5多
- 通过OH_Pixelmap_CreatePixelMap创建的对象，内存是如何分配的
- 如何实现PixelMap和base64的相互转换
- 如何将PixelMap压缩到指定大小以下
- 错误码62980096怎么处理
- 如何将C++侧接收的PixelMap转换成cv::mat格式
- image.createPixelMap中pixelFormat不生效
- 如何将PixelMap保存到相册
- 如何保存网络图片到相册

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-1
爬取时间: 2025-05-08 06:27:23
来源: Huawei Developer


通过PixelMap_CreatePixelMap创建的对象在ArkTS侧和Native侧会共享同一份内存。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-2
爬取时间: 2025-05-08 06:27:32
来源: Huawei Developer


使用图像效果模块的blur接口，详情请参考链接：图像效果。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-3
爬取时间: 2025-05-08 06:27:43
来源: Huawei Developer


问题现象


从相册获取到一张图片uri，代码如下：


```less
const file = fs.openSync(uri, fs.OpenMode.READ_ONLY); 
const imageSource = image.createImageSource(file.fd); 
const pixelMap = await imageSource.createPixelMap({sampleSize: 2, rotate: 0});
```


此时报错“Create PixelMap error”，没有错误码。如果把sampleSize配置去掉则不报错。如何正确设置sampleSize，将图片缩小。


解决措施


该问题是sampleSize取值错误导致的，sampleSize表示缩略图采样大小，当前只能取1。可通过DecodingOptions.desiredSize指定输出大小。参考代码如下：


```less
import { BusinessError } from '@kit.BasicServicesKit'; 
import { image } from '@kit.ImageKit'; 
 
let decodingOptions: image.DecodingOptions = { 
  editable: true, 
  desiredPixelFormat: 3, 
  desiredSize: { width: 4, height: 6 } 
} 
const context: Context = getContext(this); 
const filePath: string = context.cacheDir + '/test.jpg'; 
const imageSource: image.ImageSource = image.createImageSource(filePath); 
// 创建pixelMap并进行简单的旋转和缩放 
imageSource.createPixelMap(decodingOptions).then((pixelMap: image.PixelMap) => { 
  console.log("Succeeded in creating PixelMap") 
}).catch((err: BusinessError) => { 
  console.error("Failed to create PixelMap") 
});
```


参考链接


DecodingOptions


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-4
爬取时间: 2025-05-08 06:27:51
来源: Huawei Developer


对于有损压缩图片格式，如jpeg格式，质量参数会影响压缩后的图片大小，对于无损压缩图片格式，如png格式，质量参数不会影响压缩后的图片大小


对于有损压缩图片格式，压缩后的图片大小不仅取决于图片原始大小、图片压缩质量，还与图片中内容有较大关系，因此当前系统不支持设置压缩后的图片大小，如果应用想要指定压缩后图片大小，可以根据压缩结果调整质量参数，或者将pixelmap scale到更小的尺寸后再压缩。


参考链接


scale


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-5
爬取时间: 2025-05-08 06:28:01
来源: Huawei Developer

- 图片解码

指将所支持格式的存档图片解码成统一的PixelMap，以便在应用或系统中进行图片显示或图片处理。当前支持的存档图片格式包括JPEG、PNG、GIF、RAW、WebP、BMP、SVG。

- 图片编码

指将PixelMap编码成不同格式的存档图片（当前仅支持编码为JPEG、WebP 和 PNG 格式），用于后续处理，如保存、传输等。


参考链接


图片解码


图片编码（ArkTS）


图片编码（C/C++）


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-6
爬取时间: 2025-05-08 06:28:11
来源: Huawei Developer


方法一：


参考代码如下：


```typescript
import { picker } from '@kit.CoreFileKit'; 
import { photoAccessHelper } from '@kit.MediaLibraryKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
import { dataSharePredicates } from '@kit.ArkData'; 
import { common } from '@kit.AbilityKit'; 
 
const context = getContext(this) as common.UIAbilityContext; 
@Entry 
@Component 
struct WebComponent { 
  build() { 
    Column() { 
      Button('选择图片').onClick(() => { 
        try { 
          let uris: Array<string> = []; 
          let PhotoSelectOptions = new picker.PhotoSelectOptions(); 
          PhotoSelectOptions.MIMEType = picker.PhotoViewMIMETypes.IMAGE_TYPE; 
          PhotoSelectOptions.maxSelectNumber = 1; 
          let photoPicker = new picker.PhotoViewPicker(); 
          photoPicker.select(PhotoSelectOptions).then((PhotoSelectResult: picker.PhotoSelectResult) => { 
            console.info('photoPicker.select successfully, PhotoSelectResult uri: ' + JSON.stringify(PhotoSelectResult)); 
            uris = PhotoSelectResult.photoUris; 
            let phAccessHelper = photoAccessHelper.getPhotoAccessHelper(context); 
            let predicates: dataSharePredicates.DataSharePredicates = new dataSharePredicates.DataSharePredicates(); 
            // 配置查询条件，使用PhotoViewPicker选择图片返回的uri进行查询 
            predicates.equalTo('uri', uris[0]); 
            let fetchOptions: photoAccessHelper.FetchOptions = { 
              fetchColumns: [], 
              predicates: predicates 
            }; 
            phAccessHelper.getAssets(fetchOptions, async (err, fetchResult) => { 
              if (fetchResult !== undefined) { 
                console.info('fetchResult success'); 
                let photoAsset: photoAccessHelper.PhotoAsset = await fetchResult.getFirstObject(); 
                if (photoAsset !== undefined) { 
                  // 获取缩略图 
                  photoAsset.getThumbnail((err, pixelMap) => { 
                    if (err == undefined) { 
                      console.info('getThumbnail successful ' + JSON.stringify(pixelMap)); 
                    } else { 
                      console.error('getThumbnail fail', err); 
                    } 
                  }); 
                  console.info('photoAsset.displayName : ' + photoAsset.displayName); 
                } 
              } else { 
                console.error(`fetchResult fail with error: ${err.code}, ${err.message}`); 
              } 
            }); 
          }).catch((err: BusinessError) => { 
            console.error('photoPicker.select failed with err: ' + JSON.stringify(err)); 
          }); 
        } catch (error) { 
          let err: BusinessError = error as BusinessError; 
          console.error('photoPicker failed with err: ' + JSON.stringify(err)); 
        } 
      }) 
    } 
  } 
}
```


方法二：


参考代码如下：


```typescript
import { photoAccessHelper } from '@kit.MediaLibraryKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
import { image } from '@kit.ImageKit'; 
import { picker } from '@kit.CoreFileKit'; 
import { fileIo } from '@kit.CoreFileKit'; 
 
@Entry 
@Component 
struct WebComponent { 
  build() { 
    Column() { 
      Button('选择图片').onClick(() => { 
        try { 
          let uris: Array<string> = []; 
          let PhotoSelectOptions = new picker.PhotoSelectOptions(); 
          PhotoSelectOptions.MIMEType = picker.PhotoViewMIMETypes.IMAGE_TYPE; 
          PhotoSelectOptions.maxSelectNumber = 1; 
          let photoPicker = new picker.PhotoViewPicker(); 
          photoPicker.select(PhotoSelectOptions).then((PhotoSelectResult: photoAccessHelper.PhotoSelectResult) => { 
            uris = PhotoSelectResult.photoUris; 
            let file = fileIo.openSync(uris[0], fileIo.OpenMode.READ_ONLY); 
            console.info('file fd: ' + file.fd); 
            let buffer = new ArrayBuffer(4096); 
            let readLen = fileIo.readSync(file.fd, buffer); 
            console.info('readSync data to file succeed and buffer size is:' + readLen); 
            const imageSource: image.ImageSource = image.createImageSource(file.fd); 
            let decodingOptions: image.DecodingOptions = { 
              editable: true, 
              desiredPixelFormat: 3, 
            } 
            imageSource.createPixelMap(decodingOptions, (err: BusinessError, pixelMap: image.PixelMap) => { 
              if (err !== undefined) { 
                console.error(`Failed to create pixelMap.code is ${err.code},message is ${err.message}`); 
              } else { 
                console.info('Succeeded in creating pixelMap object.'); 
              } 
            }) 
          }).catch((err: BusinessError) => { 
            console.error(`Invoke photoPicker.select failed, code is ${err.code}, message is ${err.message}`); 
          }) 
        } catch (error) { 
          let err: BusinessError = error as BusinessError; 
          console.error('photoPicker failed with err: ' + JSON.stringify(err)); 
        } 
      }) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-7
爬取时间: 2025-05-08 06:28:21
来源: Huawei Developer


可以通过图片处理模块的pixelMap方法对图片进行编辑裁剪。


其中包括但不限于：

- pixelMap.crop方法，可以根据输入的尺寸对图片进行裁剪。
- pixelMap.opacity方法，可以通过设置透明比率对图片设置透明效果。
- pixelMap.scale方法，可以根据输入的宽高对图片进行缩放。
- pixelMap.rotate方法，可以根据输入的角度对图片进行旋转。
- pixelMap.flip方法，可以根据输入的条件对图片进行翻转。

以下示例代码为pixelMap.crop图片裁剪方法的使用：


```less
// Crop 4:3 
... 
class RegionItem { 
  /** 
   * width coordinate. 
   */ 
  x: number; 
 
  /** 
   * height coordinate. 
   */ 
  y: number; 
 
  constructor(x: number, y: number) { 
    this.x = x; 
    this.y = y; 
  } 
} 
 
export async function cropCommon(pixelMap: PixelMap, cropWidth: number, cropHeight: number, cropPosition: RegionItem) { 
  pixelMap.crop({ 
    size: { 
      width: cropWidth, 
      height: cropHeight 
    }, 
    x: cropPosition.x, 
    y: cropPosition.y 
  }); 
} 
 
// 传入image.PixelMap、图片width、图片height三个参数，获取到裁剪后的图片宽度和高度后将参数传入cropCommon方法 
export async function banner(pixelMap: PixelMap, width: number, height: number) { 
  if (width <= height) { 
    const cropWidth = width; 
    const cropHeight = Math.floor(width * 0.75); 
    const cropPosition = new RegionItem(0, Math.floor((height - cropHeight) / 2)); 
    cropCommon(pixelMap, cropWidth, cropHeight, cropPosition); 
    return; 
  } 
  if (width * 0.75 >= height) { 
    const cropWidth = Math.floor(height / 0.75); 
    const cropHeight = height; 
    const cropPosition = new RegionItem(Math.floor((width - cropWidth) / 2), 0); 
    cropCommon(pixelMap, cropWidth, cropHeight, cropPosition); 
    return; 
  } 
  const cropWidth = width; 
  const cropHeight = Math.floor(width * 0.75); 
  const cropPosition = new RegionItem(0, Math.floor((height - cropHeight) / 2)); 
  cropCommon(pixelMap, cropWidth, cropHeight, cropPosition); 
} 
...
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-8
爬取时间: 2025-05-08 06:28:30
来源: Huawei Developer


可以通过sourceSize属性设置图片分辨率，实例代码如下所示，原图尺寸为1280*960，该示例将图片解码为40*40。


```less
@Entry 
@Component 
struct Index { 
  build() { 
    Column() { 
      Row({ space: 50 }) { 
        Image($r('app.media.example')) 
          .sourceSize({ 
            width: 40, 
            height: 40 
          }) 
          .objectFit(ImageFit.ScaleDown) 
          .aspectRatio(1) 
          .width('25%') 
          .border({ width: 1 }) 
          .overlay('width:40 height:40', { align: Alignment.Bottom, offset: { x: 0, y: 40 } }) 
      } 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-10
爬取时间: 2025-05-08 06:28:40
来源: Huawei Developer


使用photoAccessHelper.PhotoSelectOptions接口


```typescript
import { photoAccessHelper } from '@kit.MediaLibraryKit';
import { image } from '@kit.ImageKit';
import { fileIo as fs } from '@kit.CoreFileKit';


@Entry
@Component
struct Index {
  @State getAlbum: string = '显示相册中的图片';
  @State pixel: image.PixelMap | undefined = undefined;
  @State albumPath: string = '';
  @State photoSize: number = 0;


  async getPictureFromAlbum() {
    // 拉起相册，选择图片
    let PhotoSelectOptions = new photoAccessHelper.PhotoSelectOptions();
    PhotoSelectOptions.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE;
    PhotoSelectOptions.maxSelectNumber = 1;
    let photoPicker = new photoAccessHelper.PhotoViewPicker();
    let photoSelectResult: photoAccessHelper.PhotoSelectResult = await photoPicker.select(PhotoSelectOptions);
    this.albumPath = photoSelectResult.photoUris[0];


    // 读取图片为buffer
    const file = fs.openSync(this.albumPath, fs.OpenMode.READ_ONLY);
    this.photoSize = fs.statSync(file.fd).size;
    console.info('Photo Size: ' + this.photoSize);
    let buffer = new ArrayBuffer(this.photoSize);
    fs.readSync(file.fd, buffer);
    fs.closeSync(file);


    // 解码成PixelMap
    const imageSource = image.createImageSource(buffer);
    console.log('imageSource: ' + JSON.stringify(imageSource));
    this.pixel = await imageSource.createPixelMap({});
  }


  build() {
    Row() {
      Column() {
        Image(this.pixel)
          .width('100%')
          .aspectRatio(1)
        Button('显示照片')
          .onClick(() => {
            this.getPictureFromAlbum();
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-11
爬取时间: 2025-05-08 06:28:50
来源: Huawei Developer


如实例代码所示，在示例代码中保存接收到的前三帧数据，也可以通过业务需要调整。


```less
let size: image.Size = {
  width: 640,
  height: 480
}
let receiver: image.ImageReceiver = image.createImageReceiver(size, image.ImageFormat.JPEG, 8);
receiver.on('imageArrival', () => {
  console.info("imageArrival callback");
  receiver.readNextImage((err: BusinessError, nextImage: image.Image) => {
    if (err || nextImage === undefined) {
      console.error("receiveImage -error:" + err + " nextImage:" + nextImage);
      return;
    }
    nextImage.getComponent(image.ComponentType.JPEG, (err: BusinessError, imgComponent: image.Component) => {
      if (err || imgComponent === undefined) {
        console.error("receiveImage--getComponent -error:" + err + " imgComponent:" + imgComponent);
        return;
      }


      if (imgComponent.byteBuffer as ArrayBuffer) {
        let sourceOptions: image.SourceOptions = {
          sourceDensity: 120,
          sourcePixelFormat: 8,
          sourceSize: {
            height: 1080,
            width: 1920
          },
        }
        let imageResource = image.createImageSource(imgComponent.byteBuffer, sourceOptions);
        let imagePackerApi = image.createImagePacker();
        let packOpts: image.PackingOption = { format: "image/jpeg", quality: 90 };
        const filePath: string = getContext().cacheDir + "/image.jpg";
        let file = fs.openSync(filePath, fs.OpenMode.CREATE | fs.OpenMode.READ_WRITE);
        imagePackerApi.packToFile(imageResource, file.fd, packOpts).then(() => {
          console.error('pack success: ' + filePath);
        }).catch((error: BusinessError) => {
          console.error('Failed to pack the image. And the error is: ' + error);
        })
        imageResource.createPixelMap({}).then((res) => {
          this.imgUrl = res;
        });
      } else {
        return;
      }
      nextImage.release();
    });
  });
});
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-12
爬取时间: 2025-05-08 06:29:00
来源: Huawei Developer


这是正常规格，多出来的为YUV尾部数据，不影响YUV数据的解析。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-14
爬取时间: 2025-05-08 06:29:09
来源: Huawei Developer


通过OH_Pixelmap_CreatePixelMap创建的对象在ArkTS侧和Native侧会共享同一份内存。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-15
爬取时间: 2025-05-08 06:29:19
来源: Huawei Developer


问题详情：


需要上传服务器等场景中，需要实现PixelMap和base64的互相转换。


解决措施：

-  PixelMap转换成base64必须先使用imagePacker将pixelMap压缩后再进行base64转换。若要实现无损压缩，将PixelMap压缩成PNG，即调用imagePacker时，let packOpts: image.PackingOption = { format: 'image/png', quality: 100 }; 参考代码如下：

```typescript
import { image } from '@kit.ImageKit'; 
import { buffer } from '@kit.ArkTS';


@Entry
@Component
struct Index {
  @State message: string = 'PixelMapToBase64';
  @State base64: string = '';


  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .onClick(async () => {
            let resourceManager = getContext(this).resourceManager
            let imageArray = await resourceManager.getMediaContent($r('app.media.sample7'));
            let pixelBuffer = new Uint8Array(imageArray).buffer as Object as ArrayBuffer;
            let imageResource = image.createImageSource(pixelBuffer);
            let opts: image.DecodingOptions = { editable: true }
            let pixelMap = await imageResource.createPixelMap(opts);


            // 转换成base64 
            const imagePackerApi: image.ImagePacker = image.createImagePacker();
            let packOpts: image.PackingOption = { format: 'image/jpeg', quality: 100 };
            imagePackerApi.packing(pixelMap, packOpts).then((data: ArrayBuffer) => {
              let buf: buffer.Buffer = buffer.from(data);
              this.base64 = 'data:image/jpeg;base64,' + buf.toString('base64', 0, buf.length);
              console.info('base64: ' + this.base64);
            })
          })
        Image(this.base64)
          .width(200).height(200).margin(15)
      }
      .width('100%')
    }
    .height('100%')
  }
}
```

-  先将base64字符串解析成arraybuffer，然后利用这个arraybuffer构建新PixelMap，需要注意的是，使用decodeSync对base64字符串解码时，传入的base64字符串不能有'data:image/jpeg;base64,'这样的前缀。 参考代码如下： 参考链接 ImagePacker

```typescript
import CommonContants from '../common/constants/CommonContants'; 
import { util } from '@kit.ArkTS';
import { image } from '@kit.ImageKit';


@Entry
@Component
struct Index {
  @State message: string = 'Base64ToPixelMap';
  private base64: string = CommonContants.Image_Base64_String; // 该变量为图片的base64格式字符串 
  @State private pixelMap: PixelMap | null = null;


  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .onClick(async () => {
            let helper = new util.Base64Helper();
            let buffer: ArrayBuffer = helper.decodeSync(this.base64, util.Type.MIME).buffer as ArrayBuffer;
            let imageSource = image.createImageSource(buffer);
            let opts: image.DecodingOptions = { editable: true };
            this.pixelMap = await imageSource.createPixelMap(opts);
          })
        Image(this.pixelMap)
          .width(200).height(200).margin(15)
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-16
爬取时间: 2025-05-08 06:29:29
来源: Huawei Developer


问题详情：


目前只看到支持质量压缩，未找到其他方式压缩图片到指定大小以下，如将PixelMap压缩至30KB。


解决措施：


目前没有直接的接口支持将PixelMap压缩到指定大小以下，但可以通过循环压缩的方式实现，具体可参考如下方案实现压缩：


```less
import { image } from '@kit.ImageKit'; 
import { resourceManager } from '@kit.LocalizationKit';
import { fileUri } from '@kit.CoreFileKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { fileIo} from '@kit.CoreFileKit';


class CompressedImageInfo {
  imageUri: string = ""; // 压缩后图片保存位置的uri 
  imageByteLength: number = 0; // 压缩后图片字节长度 
}


/**
 * 图片压缩，保存
 * @param sourcePixelMap：原始待压缩图片的PixelMap对象
 * @param maxCompressedImageSize：指定图片的压缩目标大小，单位kb
 * @returns compressedImageInfo：返回最终压缩后的图片信息
 */
async function compressedImage(sourcePixelMap: image.PixelMap, maxCompressedImageSize: number): Promise<CompressedImageInfo> {
  // 创建图像编码ImagePacker对象 
  const imagePackerApi = image.createImagePacker();
  const IMAGE_QUALITY = 0;
  const packOpts: image.PackingOption = { format: "image/jpeg", quality: IMAGE_QUALITY };
  // 通过PixelMap进行编码。compressedImageData为打包获取到的图片文件流。 
  let compressedImageData: ArrayBuffer = await imagePackerApi.packing(sourcePixelMap, packOpts);
  // 压缩目标图像字节长度 
  const maxCompressedImageByte = maxCompressedImageSize * 1024;
  // 图片压缩。先判断设置图片质量参数quality为0时，packing能压缩到的图片最小字节大小是否满足指定的图片压缩大小。如果满足，则使用packing方式二分查找最接近指定图片压缩目标大小的quality来压缩图片。如果不满足，则使用scale对图片先进行缩放，采用while循环每次递减0.4倍缩放图片，再用packing（图片质量参数quality设置0）获取压缩图片大小，最终查找到最接近指定图片压缩目标大小的缩放倍数的图片压缩数据。 
  if (maxCompressedImageByte > compressedImageData.byteLength) {
    // 使用packing二分压缩获取图片文件流 
    compressedImageData = await packingImage(compressedImageData, sourcePixelMap, IMAGE_QUALITY, maxCompressedImageByte);
  } else {
    // 使用scale对图片先进行缩放，采用while循环每次递减0.4倍缩放图片，再用packing（图片质量参数quality设置0）获取压缩图片大小，最终查找到最接近指定图片压缩目标大小的缩放倍数的图片压缩数据 
    let imageScale = 1;
    const REDUCE_SCALE = 0.4;
    // 判断压缩后的图片大小是否大于指定图片的压缩目标大小，如果大于，继续降低缩放倍数压缩。 
    while (compressedImageData.byteLength > maxCompressedImageByte) {
      if (imageScale > 0) {
        // 性能知识点: 由于scale会直接修改图片PixelMap数据，所以不适用二分查找scale缩放倍数。这里采用循环递减0.4倍缩放图片，来查找确定最适合的缩放倍数。如果对图片压缩质量要求不高，建议调高每次递减的缩放倍数reduceScale，减少循环，提升scale压缩性能。 
        imageScale = imageScale - REDUCE_SCALE;
        await sourcePixelMap.scale(imageScale, imageScale);
        compressedImageData = await packing(sourcePixelMap, IMAGE_QUALITY);
      } else {
        // imageScale缩放小于等于0时，没有意义，结束压缩。这里不考虑图片缩放倍数小于reduceScale的情况。 
        break;
      }
    }
  }
  // 保存图片，返回压缩后的图片信息。 
  const compressedImageInfo: CompressedImageInfo = await saveImage(compressedImageData);
  return compressedImageInfo;
}


/**
 * packing压缩
 * @param sourcePixelMap：原始待压缩图片的PixelMap
 * @param imageQuality：图片质量参数
 * @returns data：返回压缩后的图片数据
 */
async function packing(sourcePixelMap: image.PixelMap, imageQuality: number): Promise<ArrayBuffer> {
  const imagePackerApi = image.createImagePacker();
  const packOpts: image.PackingOption = { format: "image/jpeg", quality: imageQuality };
  const data: ArrayBuffer = await imagePackerApi.packing(sourcePixelMap, packOpts);
  return data;
}


/**
 * packing二分方式循环压缩
 * @param compressedImageData：图片压缩的ArrayBuffer
 * @param sourcePixelMap：原始待压缩图片的PixelMap
 * @param imageQuality：图片质量参数
 * @param maxCompressedImageByte：压缩目标图像字节长度
 * @returns compressedImageData：返回二分packing压缩后的图片数据
 */
async function packingImage(compressedImageData: ArrayBuffer, sourcePixelMap: image.PixelMap, imageQuality: number, maxCompressedImageByte: number): Promise<ArrayBuffer> {
  // 图片质量参数范围为0-100，这里以10为最小二分单位创建用于packing二分图片质量参数的数组。 
  const packingArray: number[] = [];
  const DICHOTOMY_ACCURACY = 10;
  // 性能知识点: 如果对图片压缩质量要求不高，建议调高最小二分单位dichotomyAccuracy，减少循环，提升packing压缩性能。 
  for (let i = 0; i <= 100; i += DICHOTOMY_ACCURACY) {
    packingArray.push(i);
  }
  let left = 0;
  let right = packingArray.length - 1;
  // 二分压缩图片 
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    imageQuality = packingArray[mid];
    // 根据传入的图片质量参数进行packing压缩，返回压缩后的图片文件流数据。 
    compressedImageData = await packing(sourcePixelMap, imageQuality);
    // 判断查找一个尽可能接近但不超过压缩目标的压缩大小 
    if (compressedImageData.byteLength <= maxCompressedImageByte) {
      left = mid + 1;
      if (mid === packingArray.length - 1) {
        break;
      }
      // 获取下一次二分的图片质量参数（mid+1）压缩的图片文件流数据 
      compressedImageData = await packing(sourcePixelMap, packingArray[mid + 1]);
      // 判断用下一次图片质量参数（mid+1）压缩的图片大小是否大于指定图片的压缩目标大小。如果大于，说明当前图片质量参数（mid）压缩出来的图片大小最接近指定图片的压缩目标大小。传入当前图片质量参数mid，得到最终目标图片压缩数据。 
      if (compressedImageData.byteLength > maxCompressedImageByte) {
        compressedImageData = await packing(sourcePixelMap, packingArray[mid]);
        break;
      }
    } else {
      // 目标值不在当前范围的右半部分，将搜索范围的右边界向左移动，以缩小搜索范围并继续在下一次迭代中查找左半部分。 
      right = mid - 1;
    }
  }
  return compressedImageData;
}


/**
 * 图片保存
 * @param compressedImageData：压缩后的图片数据
 * @returns compressedImageInfo：返回压缩后的图片信息
 */
async function saveImage(compressedImageData: ArrayBuffer): Promise<CompressedImageInfo> {
  const context: Context = getContext();
  // 定义要保存的压缩图片uri。afterCompression.jpeg表示压缩后的图片。 
  const compressedImageUri: string = context.filesDir + '/' + 'afterCompression.jpeg';
  try {
    const res = fileIo.accessSync(compressedImageUri);
    if (res) {
      // 如果图片afterCompressiona.jpeg已存在，则删除 
      fileIo.unlinkSync(compressedImageUri);
    }
  } catch (err) {
    console.error(`AccessSync failed with error message: ${err.message}, error code: ${err.code}`);
  }
  // 知识点：保存图片。获取最终图片压缩数据compressedImageData，保存图片。 
  // 压缩图片数据写入文件 
  const file: fileIo.File = fileIo.openSync(compressedImageUri, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
  fileIo.writeSync(file.fd, compressedImageData);
  fileIo.closeSync(file);
  // 获取压缩图片信息 
  let compressedImageInfo: CompressedImageInfo = new CompressedImageInfo();
  compressedImageInfo.imageUri = compressedImageUri;
  compressedImageInfo.imageByteLength = compressedImageData.byteLength;
  return compressedImageInfo;
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-17
爬取时间: 2025-05-08 06:29:38
来源: Huawei Developer


问题详情：


调用createPixelMap方法，将pixelFormat设置为nv21或者nv12时报错62980096，怎么处理？


解决措施：


pixelFormat枚举目前是给ImageSource用的，所以NV21或者NV12格式的图片如果要创建PixelMap需要通过以下方式：

1.  此处需要设置 createimagesource的sourceOption参数，其中sourcePixelFormat参数的值8对应NV21格式，9对应NV12格式；sourceSize参数需要设置宽高（原始yuv图片的宽高数据），且width值不能为奇数。

具体代码如下：


```less
import { image } from '@kit.ImageKit'; 
 
@Entry 
@Component 
struct Index { 
  @State message: string = 'NV21AndNV12ToPixelMap'; 
  @State private pixelMap: PixelMap | null = null; 
  @State private pixelMap2: PixelMap | null = null; 
 
  build() { 
    Row() { 
      Column() { 
        Image(this.pixelMap) 
          .width(200).height(200).margin(15) 
        Text(this.message) 
          .fontSize(50) 
          .fontWeight(FontWeight.Bold) 
          .onClick(async () => { 
            let resourceManager = getContext(this).resourceManager 
            let imageArray = await resourceManager.getMediaContent($r("app.media.sample14_NV21_fromJPG_510X510")); 
            let pixelBuffer = new Uint8Array(imageArray).buffer as Object as ArrayBuffer; 
            // 其中sourcePixelFormat参数的值8对应NV21格式，9对应NV12格式；sourceSize参数需要设置宽高（原始yuv图片的宽高数据），且width值不能为奇数。 
            let sourceOptions: image.SourceOptions = 
              { sourceDensity: 120, sourcePixelFormat: 8, sourceSize: { width: 510, height: 510 } }; 
            let imageResource = image.createImageSource(pixelBuffer, sourceOptions); 
            let opts: image.DecodingOptions = { editable: true } 
            this.pixelMap = await imageResource.createPixelMap(opts); 
 
            let imageArray2 = await resourceManager.getMediaContent($r('app.media.sample10_NV12_fromJPG_510X510')); 
            let pixelBuffer2 = new Uint8Array(imageArray2).buffer as Object as ArrayBuffer; 
            // 其中sourcePixelFormat参数的值8对应NV21格式，9对应NV12格式；sourceSize参数需要设置宽高（原始yuv图片的宽高数据），且width值不能为奇数。 
            let sourceOptions2: image.SourceOptions = 
              { sourceDensity: 120, sourcePixelFormat: 9, sourceSize: { width: 510, height: 510 } }; 
            let imageResource2 = image.createImageSource(pixelBuffer2, sourceOptions2); 
            let opts2: image.DecodingOptions = { editable: true } 
            this.pixelMap2 = await imageResource2.createPixelMap(opts2); 
          }) 
        Image(this.pixelMap2) 
          .width(200).height(200).margin(15) 
      } 
      .width('100%') 
    } 
    .height('100%') 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-18
爬取时间: 2025-05-08 06:29:48
来源: Huawei Developer


解决措施：


将ArkTS侧传到Native侧的PixelMap转换成cv::mat有两种方法：

- 将PixelMap的arraybuffer转换成cv::mat。
- 使用OH_PixelMap_AccessPixels获取PixelMap的内存地址，将这个内存地址中的数据转换为cv::mat。

上述两种方法都必须保证PixelMap的格式与opencv中mat的格式一致，否则会出现色彩的偏差。


示例代码如下：


ArkTS侧传递参数：


```typescript
import cPixelMapToMat from 'libcpixelmaptomat.so';
import { BusinessError } from '@kit.BasicServicesKit';
import { image } from '@kit.ImageKit';


@Entry
@Component
struct Index {
  @State pixelMap: image.PixelMap | undefined = undefined


  async arrayBufferToMat() {
    if (this.pixelMap == undefined || this.pixelMap){
      let resourceManager = getContext(this).resourceManager
      let imageArray = await resourceManager.getMediaContent($r('app.media.sample10'));
      let pixelBuffer = new Uint8Array(imageArray).buffer as Object as ArrayBuffer
      console.info("pixelBuffer length: " + pixelBuffer.byteLength);
      let imageResource = image.createImageSource(pixelBuffer);
      let opts: image.DecodingOptions = {
        editable: true,
        desiredPixelFormat: image.PixelMapFormat.RGBA_8888
      }
      this.pixelMap = await imageResource.createPixelMap(opts);
    }


    const readBuffer: ArrayBuffer = new ArrayBuffer(this.pixelMap.getPixelBytesNumber()); // 获取pixelmap的arraybuffer
    console.info("readBuffer length: " + readBuffer.byteLength);
    this.pixelMap.readPixelsToBuffer(readBuffer).then(() => {
      console.info("No Error!")
    }).catch((err: BusinessError) => {
      console.error("Error! " + err.message)
    })
    const dir = getContext(this).filesDir;
    console.info('save path: ' + dir);
    cPixelMapToMat.arrayBufferToMat(this.pixelMap, readBuffer, dir);
  }


  async accessToMat(){
    if (this.pixelMap == undefined || this.pixelMap) {
      let resourceManager = getContext(this).resourceManager
      let imageArray = await resourceManager.getMediaContent($r('app.media.sample14'));
      let pixelBuffer = new Uint8Array(imageArray).buffer as Object as ArrayBuffer
      console.info("pixelBuffer length: " + pixelBuffer.byteLength);
      let imageResource = image.createImageSource(pixelBuffer);
      let opts: image.DecodingOptions = {
        editable: true,
        desiredPixelFormat: image.PixelMapFormat.RGBA_8888
      }
      this.pixelMap = await imageResource.createPixelMap(opts);
    }


    const dir = getContext(this).filesDir;
    console.info('save path: ' + dir);
    cPixelMapToMat.accessToMat(this.pixelMap, dir);
  }


  build() {
    Row() {
      Column() {
        Image(this.pixelMap)
          .width(200)
          .height(200)
        Button('ArrayBufferToMat')
          .onClick(() => {
            this.arrayBufferToMat();
          })


        Button('AccessToMat')
          .onClick(() => {
            this.accessToMat();
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


方案一：将arraybuffer转换成cv::mat代码如下：


```less
#include "napi/native_api.h" 
#include <multimedia/image_framework/image_mdk.h> 
#include <multimedia/image_framework/image_mdk_common.h> 
#include <multimedia/image_framework/image_pixel_map_mdk.h> 
#include <multimedia/image_framework/image_pixel_map_napi.h> 
#include "hilog/log.h" 
#include <opencv2/opencv.hpp> 
#include <bits/alltypes.h> 
 
static napi_value ArrayBufferToMat(napi_env env, napi_callback_info info) { 
    size_t argc = 3; 
    napi_value args[3] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    napi_value error; 
    napi_create_int32(env, -1, &error); 
    // 初始化PixelMap对象数据 
    NativePixelMap *native = OH_PixelMap_InitNativePixelMap(env, args[0]); 
    if (native == nullptr) { 
        return error; 
    } 
    // 获取图片信息 
    struct OhosPixelMapInfos pixelMapInfos; 
    if (OH_PixelMap_GetImageInfo(native, &pixelMapInfos) != IMAGE_RESULT_SUCCESS) { 
        OH_LOG_Print(LOG_APP, LOG_ERROR, 0xFF00, "Test", "Pure : -1"); 
        return error; 
    } 
    // 获取buffer 
    napi_value buffer = args[1]; 
    napi_valuetype valueType; 
    napi_typeof(env, buffer, &valueType); 
    if (valueType == napi_object) { 
        bool isArrayBuffer = false; 
        napi_is_arraybuffer(env, buffer, &isArrayBuffer); 
        if (!isArrayBuffer) { 
            napi_throw_error(env, "EINVAL", "Error"); 
        } 
    } 
    void *data = nullptr; 
    size_t byteLength = 0; 
    napi_get_arraybuffer_info(env, buffer, &data, &byteLength); 
    int32_t *saveBuffer = (int32_t *)(data); 
    // 转换成Mat 
    cv::Mat originMat(pixelMapInfos.height, pixelMapInfos.width, CV_8UC4, saveBuffer); 
    if (!originMat.data) { 
        OH_LOG_Print(LOG_APP, LOG_ERROR, 0xFF00, "Read Image", "Pure : -1"); 
        return error; 
    } 
    // opencv默认bgra或bgr，若pixelmap创建时未指定为这两种格式，需要进行格式转换 
    cv::Mat saveMat; 
    cv::cvtColor(originMat, saveMat, cv::COLOR_BGRA2RGBA); 
    char pathArray[1024]; 
    size_t length; 
    napi_get_value_string_utf8(env, args[2], pathArray, 1024, &length); 
    std::string path(pathArray); 
    path += "/buffer.jpg"; 
    if (!cv::imwrite(path, saveMat)) { 
        OH_LOG_Print(LOG_APP, LOG_ERROR, 0xFF00, "Write Image", "Pure : -1"); 
        return error; 
    } 
    napi_value res; 
    napi_create_int32(env, 1, &res); 
    return res; 
}
```


方案二：使用OH_PixelMap_AccessPixels获取PixelMap的内存地址，将这个内存地址中的数据转换为cv::mat的代码如下：


```less
static napi_value AccessToMat(napi_env env, napi_callback_info info) { 
    size_t argc = 2; 
    napi_value args[2] = {nullptr}; 
    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr); 
    napi_value error; 
    napi_create_int32(env, -1, &error); 
    NativePixelMap *native = OH_PixelMap_InitNativePixelMap(env, args[0]); 
    if (native == nullptr) { 
        return error; 
    } 
    struct OhosPixelMapInfos pixelMapInfos; 
    if (OH_PixelMap_GetImageInfo(native, &pixelMapInfos) != IMAGE_RESULT_SUCCESS) { 
        OH_LOG_Print(LOG_APP, LOG_ERROR, 0xFF00, "Test", "Pure : -1"); 
        return error; 
    } 
    void *pixel; 
    // 获取NativePixelMap对象的内存地址并锁定内存 
    OH_PixelMap_AccessPixels(native, &pixel); 
    // 转换成Mat，注意对齐，所以要传入rowSize 
    cv::Mat originMat(pixelMapInfos.height, pixelMapInfos.width, CV_8UC4, pixel, pixelMapInfos.rowSize); 
    if (!originMat.data) { 
        OH_LOG_Print(LOG_APP, LOG_ERROR, 0xFF00, "Read Image", "Pure : -1"); 
        return error; 
    } 
    // opencv默认bgra或bgr，若pixelmap创建时未指定为这两种格式，需要进行格式转换 
    cv::Mat saveMat; 
    cv::cvtColor(originMat, saveMat, cv::COLOR_BGRA2RGBA); 
    char pathArray[1024]; 
    size_t length; 
    napi_get_value_string_utf8(env, args[1], pathArray, 1024, &length); 
    std::string path(pathArray); 
    path += "/access.jpg"; 
    if (!cv::imwrite(path, saveMat)) { 
        OH_LOG_Print(LOG_APP, LOG_ERROR, 0xFF00, "Write Image", "Pure : -1"); 
        return error; 
    } 
    napi_value res; 
    napi_create_int32(env, 1, &res); 
    return res; 
}
```


在HarmonyOS开发中，针对图库支持硬解码的操作， 需要指定图像的内存空间大小，原本OH_PixelMap_AccessPixels()获取到图片的内存地址并锁定该内存，但是实际图像的大小需要lineStride对齐。所以在构造成mat时，要指定lineStride对齐，HarmonyOS项目开发中lineStride即rowSize。可以用OH_GetImageInfo获取到imageInfo,其中包含width，height，rowSize等信息。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-19
爬取时间: 2025-05-08 06:29:58
来源: Huawei Developer


目前image.createPixelMap默认只能使用BGRA_8888格式处理数据，通过Promise返回结果。后续会提供新接口，可以支持指定输入流格式。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-20
爬取时间: 2025-05-08 06:30:10
来源: Huawei Developer


PixelMap使用imagePacker.packToFile()的方法将ImageSource图片源编码后直接打包进文件。


参考代码


```typescript
import { resourceManager } from '@kit.LocalizationKit';
import { photoAccessHelper } from '@kit.MediaLibraryKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { image } from '@kit.ImageKit';
import { promptAction } from '@kit.ArkUI';
import { fileIo } from '@kit.CoreFileKit';


@Entry
@Component
struct SavePixelMapToAlbum {
  @State saveButtonOptions: SaveButtonOptions = {
    icon: SaveIconStyle.FULL_FILLED,
    text: SaveDescription.SAVE,
    buttonType: ButtonType.Capsule
  };
  @State pixel: image.PixelMap | undefined = undefined;
  @State albumPath: string = '';
  @State photoSize: number = 0;
  private context: Context = getContext(this);


  async aboutToAppear() {
    const resourceMgr: resourceManager.ResourceManager = this.context.resourceManager;
    // beer.jpeg为rawfile文件下的图片名，可根据自身需求修改使用。
    const fileData: Uint8Array = await resourceMgr.getRawFileContent('beer.jpeg');
    let buffer = new Uint8Array(fileData).buffer as object as ArrayBuffer;
    let imageResource = image.createImageSource(buffer);
    let opts: image.DecodingOptions = { editable: true };
    this.pixel = await imageResource.createPixelMap(opts);
  }


  async savePixelMapToAlbum() {
    // 获取相册的保存路径
    let helper = photoAccessHelper.getPhotoAccessHelper(this.context);
    let uri = await helper.createAsset(photoAccessHelper.PhotoType.IMAGE, 'jpeg');
    let file = await fileIo.open(uri, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
    let imagePackerApi = image.createImagePacker();
    let packOpts: image.PackingOption = { format: 'image/jpeg', quality: 98 };


    imagePackerApi.packToFile(this.pixel, file.fd, packOpts, (err: BusinessError) => {
      if (err) {
        console.error(`Failed to pack the image to file.code ${err.code},message is ${err.message}`);
      } else {
        console.info('Succeeded in packing the image to file.');
        imagePackerApi.release((err: BusinessError) => {
          if (err) {
            console.error(`Failed to release the image source instance.code ${err.code},message is ${err.message}`);
          } else {
            console.info('Succeeded in releasing the image source instance.');
            fileIo.close(file.fd);
          }
        })
        promptAction.showToast({ message: '已保存至相册！' });
      }
    })
  }


  build() {
    Row() {
      Column() {
        Image(this.pixel)
          .objectFit(ImageFit.None)
          .height('30%')


        SaveButton(this.saveButtonOptions)
          .onClick(async (event, result: SaveButtonOnClickResult) => {
            if (result === SaveButtonOnClickResult.SUCCESS) {
              this.savePixelMapToAlbum();
            }
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-image-21
爬取时间: 2025-05-08 06:30:20
来源: Huawei Developer


可以使用安全控件中的保存控件，免去权限申请和权限请求等环节，获得临时授权，保存对应图片。需要申请权限：ohos.permission.INTERNET。参考代码如下：


```less
import { http } from '@kit.NetworkKit';
import { image } from '@kit.ImageKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { photoAccessHelper } from '@kit.MediaLibraryKit';
import { promptAction } from '@kit.ArkUI';
import { fileIo as fs } from '@kit.CoreFileKit';


@Entry
@Component
struct SaveImage {
  @State pixelMap: PixelMap | undefined = undefined;


  loadImageWithUrl(url: string) {
    let responseCode = http.ResponseCode;
    let OutData: http.HttpResponse;
    let imagePackerApi = image.createImagePacker();
    let packOpts: image.PackingOption = { format: 'image/jpeg', quality: 98 };
    // 确保网络正常
    http.createHttp().request(url, {
      method: http.RequestMethod.GET,
      connectTimeout: 60000,
      readTimeout: 60000
    },
      async (error: BusinessError, data: http.HttpResponse) => {
        if (error) {
          console.error(`http request failed with. Code: ${error.code}, message: ${error.message}`);
        } else {
          OutData = data;
          let code: http.ResponseCode | number = OutData.responseCode;
          if (responseCode.OK === code) {
            let imageData: ArrayBuffer = OutData.result as ArrayBuffer;
            let imageSource: image.ImageSource = image.createImageSource(imageData);


            class tmp {
              height: number = 100
              width: number = 100
            };


            let options: Record<string, number | boolean | tmp> = {
              'alphaType': 0, // 透明度
              'editable': false, // 是否可编辑
              'pixelFormat': 3, // 像素格式
              'scaleMode': 1, // 缩略值
              'size': { height: 100, width: 100 }
            }; // 创建图片大小
            imageSource.createPixelMap(options).then((pixelMap: PixelMap) => {
              this.pixelMap = pixelMap;
              this.pixelMap.getImageInfo().then((info: image.ImageInfo) => {
                console.info('info.width = ' + info.size.width);
              }).catch((err: BusinessError) => {
                console.error('Failed ' + err);
              })
              imagePackerApi.packing(pixelMap, packOpts).then(async (buffer: ArrayBuffer) => {
                try {
                  const context = getContext(this);
                  let helper = photoAccessHelper.getPhotoAccessHelper(context);
                  let uri = await helper.createAsset(photoAccessHelper.PhotoType.IMAGE, 'png');
                  let file = await fs.open(uri, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);
                  // 写入文件
                  await fs.write(file.fd, buffer);
                  promptAction.showToast({ message: '已保存至相册！' });
                  // 关闭文件
                  await fs.close(file.fd);
                } catch (error) {
                  console.error('error is ' + JSON.stringify(error));
                }
              }).catch((error: BusinessError) => {
                console.error('Failed to pack the image. And the error is: ' + error);
              })
              pixelMap.release();
            })
          }
        }
      }
    )
  }


  build() {
    Row() {
      Column({ space: 10 }) {
        Image('https://agc-storage-drcn.platform.dbankcloud.cn/v0/test-rqcjj/test.png')
          .width('80%')


        SaveButton().onClick(async (event: ClickEvent, result: SaveButtonOnClickResult) => {
          if (result === SaveButtonOnClickResult.SUCCESS) {
            this.loadImageWithUrl('https://agc-storage-drcn.platform.dbankcloud.cn/v0/test-rqcjj/test.png');
          } else {
            promptAction.showToast({ message: '设置权限失败！' });
          }
        })
      }
      .width('100%')
    }
    .height('100%')
    .backgroundColor(0xF1F3F5)
  }
}
```


参考链接


使用保存控件


存档图类型数据源


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scan-kit
爬取时间: 2025-05-08 06:30:28
来源: Huawei Developer

- 如何添加“扫码直达”服务的快速入口
- 扫码直达跳转失败
- Scan Kit无法识别多个码图
- 上传软件包时提示“上传的软件包与声明支持设备不一致”
- 相册扫码识别多码失败
- 条形码识别错误
- 条形码识别坐标信息为空
- 自定义界面扫码预览画面出现拉伸
- 自定义界面扫码黑屏现象
- 自定义界面扫码如何连续扫码（customScan.rescan）
- 通过字节数组生成码图无法识别
- 默认界面扫码取消后，如何感知
- H5场景如何接入扫码
- 如何主动通过手势缩放变焦比
- 自定义界面扫码如何实现扫码框
- 默认界面扫码/自定义界面扫码体验设计
- 自定义界面扫码如何增加重试机制

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-1
爬取时间: 2025-05-08 06:30:38
来源: Huawei Developer


问题现象


有些用户编辑过控制中心，删除了默认存在的“扫一扫”入口，后续如何添加。


解决措施


控制中心编辑添加“扫一扫”入口：手机下滑菜单栏，打开控制中心，在编辑区域中添加选择“扫一扫”后保存，即可在下拉控制列表中找到。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-2
爬取时间: 2025-05-08 06:30:47
来源: Huawei Developer


问题现象


扫码直达跳转失败。


解决措施


请检查App Linking配置是否正确：


详情参考：App Linking的FAQ。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-3
爬取时间: 2025-05-08 06:30:57
来源: Huawei Developer


问题现象


实时扫描多个码图时，只返回一个码图结果。


解决措施


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-4
爬取时间: 2025-05-08 06:31:07
来源: Huawei Developer


问题现象


在进行应用上架操作中，上传软件包时，AGC平台提示“上传的软件包与声明支持设备不一致，请重新上传或修改可支持设备”。


解决措施


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-5
爬取时间: 2025-05-08 06:31:16
来源: Huawei Developer


问题现象


启动默认界面进行扫码，当开启相册扫码识别多码时，识别失败。


解决措施


相册扫码只支持单码识别。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-6
爬取时间: 2025-05-08 06:31:25
来源: Huawei Developer


问题现象


条形码识别过程中存在码图类型识别错误的场景。


解决措施


条形码识别是通过粗细黑白条组成的模式来进行匹配，由于条形码的图案都比较相似，不同类型的码会出现误匹配现象，Scan Kit在不断优化扫码识别算法，持续提升识别的准确率。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-7
爬取时间: 2025-05-08 06:31:34
来源: Huawei Developer


问题现象


条形码识别场景下，存在识别成功后，返回位置信息为空的现象。


解决措施


因为条形码识别逻辑，算法返回的位置信息可能在同一行或者同一列，无法返回外接矩形，该场景下需要开发者判断位置信息是否为空，进行对应处理。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-8
爬取时间: 2025-05-08 06:31:43
来源: Huawei Developer


问题现象


XComponent的宽高比与自定义界面扫码接口中ViewControl的宽高比不一致，导致自定义界面扫码预览画面出现拉伸。


解决措施


ViewControl的宽高比需要与XComponent的宽高比保持一致，会消除画面拉伸现象。当前支持的分辨率比例为16:9、4:3、1:1。


例如：XComponent中width为1080(px)，height为1920(px)，则ViewControl宽度设置为1080，高度设置为1920。


```less
import { hilog } from '@kit.PerformanceAnalysisKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { scanBarcode, customScan } from '@kit.ScanKit';


@Entry
@Component
struct customScanPage {
  // 设置预览流高度，默认单位：px
  @State cameraHeight: number = 1920;
  // 设置预览流宽度，默认单位：px
  @State cameraWidth: number = 1080;
  private mXComponentController: XComponentController = new XComponentController();


  build() {
    Stack() {
      XComponent({
        id: 'componentId',
        type: XComponentType.SURFACE,
        controller: this.mXComponentController
      })
        .onLoad(() => {
          hilog.info(0x0001, '[Scan Sample]', 'onLoad is called')
          // 获取XComponent的surfaceId
          let surfaceId: string = this.mXComponentController.getXComponentSurfaceId();
          hilog.info(0x0001, 'viewControl', `onLoad surfaceId: ${surfaceId}`);
          // 设置viewControl相应字段
          let viewControl: customScan.ViewControl = {
            width: this.cameraWidth,
            height: this.cameraHeight,
            surfaceId: surfaceId
          };
          try {
            customScan.start(viewControl).then((scanResult: Array<scanBarcode.ScanResult>) => {
              hilog.info(0x0001, '[Scan Sample]',
                `Succeeded in getting ScanResult by promise, scanResult is ${JSON.stringify(scanResult)}`);
            }).catch((error: BusinessError) => {
              hilog.error(0x0001, '[Scan Sample]',
                `Failed to get ScanResult by promise. Code: ${error.code}, message: ${error.message}`);
            })
          } catch (error) {
            hilog.error(0x0001, '[Scan Sample]',
              `Failed to start customScan. Code: ${error.code}, message: ${error.message}`);
          }
        })
        .height(this.cameraHeight + 'px')
        .width(this.cameraWidth + 'px')
        .position({ x: 0, y: 0 })
    }
    .alignContent(Alignment.Bottom)
    .height('100%')
    .width('100%')
    .position({ x: 0, y: 0 })
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-9
爬取时间: 2025-05-08 06:31:52
来源: Huawei Developer


问题现象


自定义启动相机却显示黑屏现象。


解决措施

- 权限校验错误码：201，没有申请相机权限，向用户申请授权。
-  切换至后台时，在页面生命周期onPageHide中先暂停并释放相机流（customScan.stop、customScan.release）。重新切换到前台后，在页面生命周期onPageShow中再重启相机流（customScan.start）。
- 没有初始化customScan.init。
- 自定义扫码customScan.ViewControl宽高比不符合相机流比率，常见相机流比例有：1:1、4:3、16:9。
-  切换至后台时，在页面生命周期onPageHide中先暂停并释放相机流（customScan.stop、customScan.release）。重新切换到前台后，在页面生命周期onPageShow中再重启相机流（customScan.start）。
1.  切换至后台时，在页面生命周期onPageHide中先暂停并释放相机流（customScan.stop、customScan.release）。重新切换到前台后，在页面生命周期onPageShow中再重启相机流（customScan.start）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-10
爬取时间: 2025-05-08 06:32:02
来源: Huawei Developer


问题现象


自定义界面扫码扫到码值后，如何连续扫码？


解决措施


customScan.rescan可以重新触发一次扫码，必须在customScan.start(viewControl, callback)方法Callback接口回调中有效，Promise方式无效。


示例：


```typescript
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { customScan, scanBarcode } from '@kit.ScanKit';


@Entry
@Component
struct Index {
  private callback: AsyncCallback<Array<scanBarcode.ScanResult>> =
    async (error: BusinessError, result: Array<scanBarcode.ScanResult>) => {
      if (error) {
        hilog.error(0x0001, '[Scan Sample]',
          `Failed to get ScanResult by callback. Code: ${error.code}, message: ${error.message}`);
        return;
      }
      hilog.info(0x0001, '[Scan Sample]',
        `Succeeded in getting ScanResult by callback, result is ${JSON.stringify(result)}`);
      try {
        // 重新触发扫码：不需要重启相机并重新触发一次扫码，可以在start接口的Callback异步回调中，调用rescan接口。
        customScan.rescan();
      } catch (error) {
        hilog.error(0x0001, '[Scan Sample]', `Failed to rescan. Code: ${error.code}, message: ${error.message}`);
      }
    }


  build() {
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-11
爬取时间: 2025-05-08 06:32:12
来源: Huawei Developer


问题现象


Scan Kit识别该码图内容显示内容为乱码，无法解析。


解决措施


通过字节数组生成码图，Scan Kit识别该码图内容显示内容为乱码，这种字节数组需要专门的解码器解析，例如地铁闸机。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-12
爬取时间: 2025-05-08 06:32:21
来源: Huawei Developer


问题现象


调用默认界面扫码功能，没有扫码直接关闭，如何在逻辑中判断？


解决措施


开启扫码，却没有进行任何扫码操作而直接取消扫码，可以从回调中获取返回错误码：1000500002，用户取消扫码，据此自行修改逻辑操作。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-13
爬取时间: 2025-05-08 06:32:31
来源: Huawei Developer


问题现象


Scan Kit没有提供H5的方案接入扫码。


解决措施


开发者可参考前端页面调用应用侧函数方式调用扫码接口，实现网页扫码功能。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-14
爬取时间: 2025-05-08 06:32:40
来源: Huawei Developer


问题现象


自定义界面扫码如何主动通过手势缩放相机流。


解决措施


通过组合手势接口设置变焦比setZoom(zoomValue : number): void。


参考下面示例代码，手势缩放跟随和手势缩放结束接口中都可以设置变焦比变化：


```typescript
import { hilog } from '@kit.PerformanceAnalysisKit';


@Entry
@Component
struct Index {
  build() {
    Column() {
      // 绑定手势
    }.gesture(PinchGesture({ fingers: 2 })
      .onActionStart((event: GestureEvent) => {
        hilog.info(0x0001, '[Scan Sample]', 'Pinch start');
      })
      .onActionUpdate((event: GestureEvent) => {
        if (event) {
          // 手势缩放比例
          let scaleValue = event.scale;
          // 1、手势跟随过程中设置变焦比
        }
      })
      .onActionEnd((event: GestureEvent) => {
        // 2、手势结束抬起后，设置变焦比
      })
    )
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-15
爬取时间: 2025-05-08 06:32:50
来源: Huawei Developer


问题现象


扫码界面没有类似扫码框呈现。


解决措施


示例代码（仅供参考）：


```typescript
import { customScan, scanBarcode } from '@kit.ScanKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { BusinessError } from '@kit.BasicServicesKit';


// 例如XComponent设置的宽高为cameraWidth = 1080px, cameraHeight = 1920px
let cameraWidth = 1080;
let cameraHeight = 1920;
// 自定义扫码框在屏幕中间 scanBox 为800px*800px，则扫码框相对xComponent的坐标left: 140px, top: 560px, right: 940px, bottom: 1360px
let scanBoxWidth = 800;
let scanBoxHeight = 800;
let scanBox: scanBarcode.ScanCodeRect = {
  left: (cameraWidth - scanBoxWidth) / 2,
  top: (cameraHeight - scanBoxHeight) / 2,
  right: (cameraWidth + scanBoxWidth) / 2,
  bottom: (cameraHeight + scanBoxHeight) / 2
}


// 设置ViewControl参数
let viewControl: customScan.ViewControl = {
  width: cameraWidth,
  height: cameraHeight,
  surfaceId: '123' // mock数据，实际需要从组件生成获取
};
try {
  customScan.start(viewControl, async (error: BusinessError, result: Array<scanBarcode.ScanResult>) => {
    if (error) {
      // 扫码识别失败
      return;
    }
    // 例如：mock扫码结果返回的结果为第一个result[0] = { left: 150px, top: 400px, right: 450px, bottom: 700px }
    let scanResult: scanBarcode.ScanCodeRect = {
      left: 150,
      top: 400,
      right: 450,
      bottom: 700
    };
    // 判断码图位置是否位于扫码框范围内
    if (scanResult.left >= scanBox.left && scanResult.top >= scanBox.top && scanResult.right <= scanBox.right &&
      scanResult.bottom <= scanBox.bottom) {
      // 扫码成功，码图位置位于扫码框范围，根据业务需求处理扫码结果
    } else {
      // 码图位置不在扫码框范围，继续扫码
      try {
        customScan.rescan();
      } catch (error) {
        hilog.error(0x0001, '[Scan Sample]', `Failed to rescan. Code: ${error.code}, message: ${error.message}`);
      }
    }
  });
} catch (error) {
  hilog.error(0x0001, '[Scan Sample]', `Failed to start customScan. Code: ${error.code}, message: ${error.message}`);
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-16
爬取时间: 2025-05-08 06:32:58
来源: Huawei Developer


问题现象


点击按钮后，无法确认是否正在拉起扫码功能。


解决措施


点击按钮拉起默认扫码界面或自定义扫码界面后，将按钮置灰，说明正在拉起扫码功能，以“默认界面扫码”按钮为例：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160910.97494881234623574696084374819208:50001231000000:2800:6401B547327878B04FCF0B2BB85F20D7289E582F1030CEA58A2169E7A8CCD4BF.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scan-faq-17
爬取时间: 2025-05-08 06:33:08
来源: Huawei Developer


问题现象


调用customScan.init成功后，调用customScan.start启动相机流时抛出1000500001内部错误。


解决措施


可以尝试增加扫码相机流重试机制。


先暂停并释放相机流（customScan.stop、customScan.release），再重启相机流（customScan.init、customScan.start）。


示例代码（仅供参考）：


```typescript
import { customScan, scanBarcode, scanCore } from '@kit.ScanKit';
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';


@Entry
@Component
struct Index {
  @State viewControl: customScan.ViewControl = {
    width: 1080,
    height: 1080,
    surfaceId: ''
  };
  private retryScanTimes = 0;
  private options: scanBarcode.ScanOptions = {
    scanTypes: [scanCore.ScanType.ALL],
    enableMultiMode: true,
    enableAlbum: true
  };
  private customScanCallbackScan: AsyncCallback<scanBarcode.ScanResult[]> =
    async (error: BusinessError, result: scanBarcode.ScanResult[]) => {
      if (error && error.code !== 0) {
        hilog.error(0x0001, '[Scan Sample]',
          `An error is returned by customScan.start->CallbackScan. Code: ${error.code}`);
        // start回调，出现1000500001内部错误时触发重启相机流
        if (error.code === scanCore.ScanErrorCode.INTERNAL_ERROR) {
          this.retryCamera(error);
        }
      }
      // 识码处理逻辑
      // ...
    }


  // 重启相机流
  retryCamera(error: BusinessError) {
    if (this.retryScanTimes < 3 && error.code === scanCore.ScanErrorCode.INTERNAL_ERROR) {
      this.retryScanTimes++;
      let timeId = setTimeout(async () => {
        hilog.info(0x0001, '[Scan Sample]',
          `Retry camera start. Times: ${this.retryScanTimes}.`);
        // 先暂停并释放相机流
        await this.releaseCamera();
        // 重启相机流
        this.startCamera();
        hilog.info(0x0001, '[Scan Sample]', 'Retry camera end.');
        clearTimeout(timeId);
      }, 100)
    }
  }


  // 启动相机流
  startCamera() {
    try {
      customScan.init(this.options);
      hilog.info(0x0001, '[Scan Sample]', 'customScan->init end');
      try {
        customScan.start(this.viewControl, this.customScanCallbackScan);
        hilog.info(0x0001, '[Scan Sample]', 'customScan->start end');
      } catch (error) {
        hilog.error(0x0001, '[Scan Sample]',
          `Failed to customScan->start. Code: ${error.code}, message: ${error.message}`);
      }
    } catch (error) {
      hilog.error(0x0001, '[Scan Sample]',
        `Failed to customScan->init. Code: ${error.code}, message: ${error.message}`);
    }
  }


  // 暂停并释放相机流
  async releaseCamera() {
    try {
      await customScan.stop();
      hilog.info(0x0001, '[Scan Sample]', 'customScan->stop end');
      try {
        await customScan.release();
        hilog.info(0x0001, '[Scan Sample]', 'customScan->release end');
      } catch (error) {
        hilog.error(0x0001, '[Scan Sample]',
          `Failed to customScan->release. Code: ${error.code}, message: ${error.message}`);
      }
    } catch (error) {
      hilog.error(0x0001, '[Scan Sample]',
        `Failed to customScan->stop. Code: ${error.code}, message: ${error.message}`);
    }
  }


  build() {
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-video
爬取时间: 2025-05-08 06:33:18
来源: Huawei Developer

- 音频（Audio）
- 媒体（Media ）
- 音视频播控（AVSession）
- 音视频编解码（AVCodec）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-kit
爬取时间: 2025-05-08 06:33:27
来源: Huawei Developer

- 如何后台播放音乐
- 创建多个视频组件无法播放
- OpenSL ES音频录制示例调用崩溃
- SoundPool播放的音频是否支持WMV格式
- 如何实现录音监听
- 音频处理哪些场景内置3A算法及AEC、ANC、AGC是否支持独立开关
- AudioRenderer是否有跳转到某一帧的接口
- 播放短促提示音（如点赞、收藏、新消息等场景的提示音或音效），应该如何处理？
- 静音播放音频时，如何做到不抢音频焦点？
- 三方应用如何选择音频流类型
- 应用音频如何使用OpenSL切换为OHAudio
- 播放音频时，如何修改默认输出设备
- 音频焦点如何适配
- Webview焦点如何适配
- 设备切换后没有暂停

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-1
爬取时间: 2025-05-08 06:33:36
来源: Huawei Developer


AVSession对媒体播放做了管控，当三方应用从前台切入后台或者进入锁屏状态，媒体播放会被强制暂停而应用不感知，如果要开发后台播放功能，应该启动后台任务管理的长时任务中播放音乐，同时接入AVSession能力，允许控制中心的播控面板控制三方应用的播放功能。


参考链接


后台任务管理-长时任务，AVSession开发指导参考


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-2
爬取时间: 2025-05-08 06:33:47
来源: Huawei Developer


当前限制最多创建16个媒体播放实例。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-3
爬取时间: 2025-05-08 06:33:56
来源: Huawei Developer


问题现象


OpenSL ES音频录制接口调用失败，造成程序崩溃。报错日志信息如下：


08-06 00:39:20.042 5198-5219/? E C02b00/AudioFramework: [audio_service_client.cpp] Client doesn't have MICROPHONE permission


解决措施


需要申请ohos.permission.MICROPHONE权限。详细请参见权限申请。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-4
爬取时间: 2025-05-08 06:34:06
来源: Huawei Developer


SoundPool：音频池加载播放实例，音频池提供了系统声音的加载、播放、音量设置、循环设置、停止播放、资源卸载等功能。


SoundPool当前不支持WMV格式，支持的格式有AAC、MPEG(MP3)、Flac、Vorbis。


参考链接


音频解码


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-5
爬取时间: 2025-05-08 06:34:16
来源: Huawei Developer


系统音频监听功能在AudioStreamManager内，录音监听可以通过on(type: 'audioCapturerChange', callback: Callback<AudioCapturerChangeInfoArray>): void订阅接口实现。详细可参考链接：on('audioCapturerChange')。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-6
爬取时间: 2025-05-08 06:34:25
来源: Huawei Developer


3A算法：指声学回声消除（Acoustic Echo Cancellation, AEC）、背景噪声抑制（Active Noise Control, ANC）、自动增益控制（Automatic Gain Control, AGC）三种音频处理算法。


存在STREAM_USAGE_VOICE_COMMUNICATION配置的音频流运行时自动内置3A。普通录音场景不会开启3A，仅voip通话时才会开启，需要在播放音频流时配置相应的StreamUsage类型。


目前不支持3A独立开关。


参考链接


AudioCapturer


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-7
爬取时间: 2025-05-08 06:34:35
来源: Huawei Developer


没有，AudioRender底层不支持跳转到某一帧。AudioRender和avplayer不一样，AudioRender接口是client主动给它发送数据，完成后就会播放。而avplayer有source, 比如文件，所以支持跳转到某一帧。可使用avPlayer.seek()方法跳转到指定播放位置，只能在prepared/playing/paused/completed状态调用。


```less
let seekTime: number = 1000
avPlayer.seek(seekTime, media.SeekMode.SEEK_PREV_SYNC)
```


参考链接


seek


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-8
爬取时间: 2025-05-08 06:34:44
来源: Huawei Developer

- 推荐优先使用SoundPool，若应用使用SoundPool开发音频播放功能，且StreamUsage指定为Music、Movie、AudioBook等类型，播放短音，则其申请焦点时默认为并发模式，不会影响其他音频。
- 若应用不希望使用SoundPool，并且当前使用的流类型会打断其他音频播放，推荐使用AudioSession相关接口，指定为MIX_WITH_OTHERS策略。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-9
爬取时间: 2025-05-08 06:34:54
来源: Huawei Developer


若应用以静音状态开始播放音频（或视频），并且希望静音阶段不影响其他音频，当后续解除静音的时候，再以正常策略申请音频焦点，则可以调用静音并发播放模式的相关接口。

- 若使用AVPlayer开发音频播放功能(ArkTS)，可以调用setMediaMuted函数。
- 若使用AudioRenderer开发音频播放功能，可调用setSilentModeAndMixWithOthers函数。
- 若使用OHAudio开发音频播放功能(C/C++)，可调用OH_AudioRenderer_SetSilentModeAndMixWithOthers函数。
- 若使用WebView开发音频播放功能，可在音频播放前先将流音量设为0，此时系统默认优先与其他音频流并发，当音频流解除静音时，才会申请音频焦点。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-10
爬取时间: 2025-05-08 06:35:04
来源: Huawei Developer


对于播放流，其类型由StreamUsage决定；对于录制流，其类型由SourceType决定。


（1）音频流类型在音量控制、音频焦点管理、输入/输出设备选择等方面有决定性影响。


（2）应用需要根据自身的业务场景和实际需求，为音频选择合适的流类型。


WebView策略：目前不支持主动设置流类型，由WebView根据是否有音频输入自动设置为Music或VoiceCommunication类型（有播放流、无录制流，则默认为Music类型；播放流、录制流都有，则默认为VoiceCommunication类型）。


参考链接


使用合适的音频流类型


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-11
爬取时间: 2025-05-08 06:35:14
来源: Huawei Developer


由于OpenSL ES无法满足音频系统的能力拓展，开发者可通过使用OHAudio替代OpenSL ES开发音频业务，具体请参考链接：从OpenSL ES切换到OHAudio。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-12
爬取时间: 2025-05-08 06:35:23
来源: Huawei Developer


应用使用AudioRenderer开发音频播放功能时，可以调用setDefaultOutputDevice接口，设置默认发声设备。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-13
爬取时间: 2025-05-08 06:35:33
来源: Huawei Developer


对应用而言，为确保带给用户良好的音频焦点体验，需要注意：


（1）应用在启动播放或录制之前，需要根据音频的用途，使用合适的音频流类型，即正确指定StreamUsage或SourceType；


（2）应用需要监听音频焦点事件，并在收到音频焦点事件（InterruptEvent）时做出必要的响应。


（3）若应用希望对音频焦点做一些主动管理，可以使用音频会话（AudioSession）相关接口。


参考链接


音频焦点和音频会话介绍


音频播放类应用交互场景实践


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-14
爬取时间: 2025-05-08 06:35:43
来源: Huawei Developer


参考链接


mediaOptions


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-audio-15
爬取时间: 2025-05-08 06:35:53
来源: Huawei Developer

- 开发者可以了解音频流输出设备变更信息，并完成相应适配，确保应用在设备发生变更时的用户体验。开发者可使用AudioRenderer的outputDeviceChangeWithInfo，用于监听音频流输出设备变化及原因。当系统出现音频输出设备的上下线、用户强选、设备抢占或设备选择策略变更等情况，导致音频流输出设备变更时，系统将通过该接口通知应用当前音频流设备变更信息，包含当前音频流输出设备信息和设备变更原因。
- Webview策略：当前Web自己做了暂停操作，若应用自身实现播放按钮UI，需监听video播放状态来刷新UI按钮界面。

参考链接


响应音频流输出设备变更


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-kit
爬取时间: 2025-05-08 06:36:02
来源: Huawei Developer

- 使用AVPlayer播放器概率性报错5400104、5400103要怎么处理
- 系统播放器AVPlayer支持的流媒体协议与功能
- 如何实现使用AVPlayer播放音频的过程中打断当前播放去播放另一个音频
- 使用AVPlayer播放视频时，如何实现应用从后台切回前台时继续播放原视频
- 使用video组件播放视频时，如何刷新重新加载视频?比如网络异常导致播放失败等情况
- 在使用Video组件时，为Video添加本地视频播放源后，立刻播放，为什么会播放失败

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-1
爬取时间: 2025-05-08 06:36:12
来源: Huawei Developer


问题现象


5400103：媒体与其他模块的数据交互发生问题(图形、音频、网络、HDI、相机)，可能和服务器限流有关。


5400104：网络超时或访问其他模块超时。默认网络超时时间为15秒，从开始缓存的事件上报后开始计时，超时后会上报该错误信息。


解决措施


参考链接


错误码5400103


错误码5400104


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-2
爬取时间: 2025-05-08 06:36:22
来源: Huawei Developer


系统播放器AVPlayer支持hls/http/https协议，支持播放、暂停、seek(无法精准seek)功能，切集和全屏功能则需要用户在应用层自己实现。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-3
爬取时间: 2025-05-08 06:36:31
来源: Huawei Developer


需要先调用reset()打断前一个音频，然后切换音频源。因为reset()是异步的，所以调用reset()的语句需加上await关键字。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-4
爬取时间: 2025-05-08 06:36:41
来源: Huawei Developer


在切换到前台的生命周期方法onPageShow()里调用AVPlayer的播放方法avPlayer.play()，并在切换到后台的生命周期方法onPageHide()里调用AVPlayer的暂停方法avPlayer.pause()即可。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-5
爬取时间: 2025-05-08 06:36:50
来源: Huawei Developer


可以先将url变为空，然后再改回原来的值，示例代码如下：


```typescript
@Component 
export struct VideoErrorReload { 
  @State url: string = 'https://******'; 
 
  build() { 
    Column({ space: 20 }) { 
      Video({ src: this.url }) 
        .height(300) 
 
      Button('重新url') 
        .onClick(() => { 
          let temp = this.url; 
          this.url = ''; 
          setTimeout(() => { 
            this.url = temp; 
          }, 100); 
        }) 
    } 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-media-6
爬取时间: 2025-05-08 06:37:00
来源: Huawei Developer


从给Video加载资源到Video播放中间必须要加载，这个加载需要耗时，可以将开始播放的逻辑写到Video组件的onPrepared回调函数里，等资源准备完毕后，自动播放。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avsession-kit
爬取时间: 2025-05-08 06:37:10
来源: Huawei Developer

- 如何响应播控中心的播放模式切换
- 应用如何更新进度条
- 为什么接入播控后，播控中心部分按钮是灰色的，不可点击
- 能否定制播控中心界面上显示的控制元素
- 如何在播控中心显示歌词
- 如何做到连续投播
- 系统是否支持DLNA设备投屏
- 如何自定义投播组件
- 应用内如何进行输出设备的选择
- 投播成功后，本端应用内该如何显示
- 投播后支持哪些控制功能

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avsession-1
爬取时间: 2025-05-08 06:37:19
来源: Huawei Developer


应用在创建AVSession后，要监听系统切换播放模式的接口来处理播控中心的控制命令。目前支持四种播放模式：顺序播放，随机播放，单曲循环，列表循环。应用在收到回调时，会同时获取一个当前的播放模式，应用可以自行决定下一个播放模式，然后把新的播放模式设置给AVSession。


参考链接


循环模式


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avsession-2
爬取时间: 2025-05-08 06:37:29
来源: Huawei Developer


应用如果期望在播控中心内支持进度显示和控制，需要将资源的时长信息设置给AVSession，同时需要注册seek的回调接口来响应系统的进度控制。应用更新进度条，可以在倍速、播放状态发生变化时更新，不需要实时更新，可以节约一些系统资源。


参考链接


进度控制


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avsession-3
爬取时间: 2025-05-08 06:37:39
来源: Huawei Developer


系统的播控中心会根据应用是否注册对应的控制命令，在界面中呈现对应的元素是否可以控制。应用根据自己支持的能力，按需注册；推荐使用支持播控中心内的元素，以达成较好的体验。


参考链接


注册控制命令


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avsession-4
爬取时间: 2025-05-08 06:37:49
来源: Huawei Developer


目前播控中心显示的控制元素是根据不同会话类型做的固定模板：

- audio类型，播控中心的控制样式为：收藏，上一首，播放/暂停，下一首，循环模式。
- video类型，播控中心的控制样式为：快退，上一首，播放/暂停，下一首，快进。

参考链接


创建不同类型的会话


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avsession-5
爬取时间: 2025-05-08 06:37:58
来源: Huawei Developer


开发者需要在创建AVSession后，把完整的歌词内容设置到AVMetadata中。歌词格式为标准的lyric格式，目前不支持其他格式的歌词类型。


参考链接


滚动歌词


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avsession-6
爬取时间: 2025-05-08 06:38:08
来源: Huawei Developer


对于切换剧集（同一电视剧不同集或预告、花絮等）的场景，为了方便用户，此时不应该结束投播，应获取到下一集的播放URL，继续自动投播下一集。应用在收到上一资源结束的回调，或者判断播放进度距离结束还有较短时间内（比如5秒），需要准备下一个资源，以达成连续投播的效果。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avsession-7
爬取时间: 2025-05-08 06:38:17
来源: Huawei Developer


系统当前同时支持Cast+协议和DLNA协议的设备进行资源投播。应用可以在创建AVSession的时候，传入需要发现和过滤的协议类型，来匹配应用期望的投屏设备。参考开发步骤中的第二步：设置媒体资源信息。


参考链接


投播组件开发指导


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avsession-8
爬取时间: 2025-05-08 06:38:27
来源: Huawei Developer


投播组件目前支持如下的一些自定义能力：


图标默认颜色、选中后的颜色、组件深浅色的适配、以及组件内元素的自定义。


实现步骤，可以参考链接：自定义样式实现。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avsession-9
爬取时间: 2025-05-08 06:38:37
来源: Huawei Developer


系统当前未直接提供切换输出设备的接口，但是提供了投播组件来支持设备的切换。开发者可以集成AVCastPicker嵌入在应用界面内实现设备切换。AVCastPicker支持一些自定义能力来满足应用对界面一致性的诉求。


参考链接


使用通话设备切换组件


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avsession-10
爬取时间: 2025-05-08 06:38:47
来源: Huawei Developer


应用在感知到设备连接成功后，本端的客户端界面一般要适配为遥控器状态，以达成更好的投播体验。


具体可以参考开发步骤中的第四步的描述。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avsession-11
爬取时间: 2025-05-08 06:38:55
来源: Huawei Developer


投播成功后，目前在本端支持的功能有：播放、暂停、下一首/曲、上一首/曲、快进、快退、进度控制、音量控制。


对端大屏设备支持的功能有：播放、暂停、下一首/曲、上一首/曲、快进、快退、进度控制。


目前不支持清晰度切换、音轨切换、倍速、弹幕等功能。


支持的接口：sendControlCommand(command: AVCastControlCommand, callback: AsyncCallback<void>): void。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avcodec-kit
爬取时间: 2025-05-08 06:39:05
来源: Huawei Developer

- VideoDecoder支持的包装方式是AVCC还是AnnexB
- 音视频文件的封装协议与编码格式有哪些
- 如何获取系统支持的编解码能力

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avcodec-1
爬取时间: 2025-05-08 06:39:14
来源: Huawei Developer


VideoDecoder支持的是AnnexB格式。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avcodec-2
爬取时间: 2025-05-08 06:39:23
来源: Huawei Developer

- 音视频文件的封装支持mp4和m4a容器格式。它们都是音频和视频文件格式，但是两种格式封装媒体成分略有不同。mp4封装了视频，音频，字幕，元数据等各种媒体元素，比如网上电影，电视剧，用户拍摄的视频等；m4a主要存储的是音频的媒体元素。它们在多媒体内容（如音乐，语音，视频等）编辑，存储，分享中发挥了重要作用。
- 视频编解码支持H.264（AVC），H.265（HEVC）的硬件加速编解码，H.264 和H.265是视频标准编码技术，H.265的视频压缩率高于H.264，比如，在录制相同的视频文件时，H.265录制生成的mp4文件的大小要小很多，更利于节省存储空间。
- 音频编码支持AAC，Flac；音频解码支持AAC，MPEG(MP3)，Flac，Vorbis。

参考链接


音视频封装


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-avcodec-4
爬取时间: 2025-05-08 06:39:33
来源: Huawei Developer


支持两种获取音视频编解码能力实例的方式：


方式一：通过OH_AVCodec_GetCapability获取系统推荐的音视频编解码器能力实例。与OH_XXX_CreateByMime系列接口系统推荐策略一致。


```less
// 获取系统推荐的音频AAC解码器能力实例
OH_AVCapability *capability = OH_AVCodec_GetCapability(OH_AVCODEC_MIMETYPE_AUDIO_AAC, false);
```


方式二：通过OH_AVCodec_GetCapabilityByCategory获取指定软件或硬件的编解码能力实例。


```less
// 获取指定硬件的视频AVC编码器能力实例
OH_AVCapability *capability = OH_AVCodec_GetCapabilityByCategory(OH_AVCODEC_MIMETYPE_VIDEO_AVC, true, HARDWARE);
```


若获取能力实例成功，则可继续向下执行。开发者无需关注该OH_AVCapability实例的回收问题，系统会自行回收。


参考链接


获取支持的编解码能力


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-graphic-development
爬取时间: 2025-05-08 06:39:42
来源: Huawei Developer

- 图形和游戏
- XR

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-graphics-games
爬取时间: 2025-05-08 06:39:52
来源: Huawei Developer

- 2D图形（ArkGraphics 2D）
- 图形加速（Graphics Accelerate）
- GPU加速引擎（XEngine）
- 游戏（Game Service）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics2d-kit
爬取时间: 2025-05-08 06:40:02
来源: Huawei Developer

- 如何使用EGL绘制自定义动画？请提供一个简单示例
- 应用帧率如何监控，运行时如何获取应用的帧率、渲染帧的耗时
- 多线程调用OH_Drawing_CreateFontCollection崩溃
- EGL绘制是否支持多线程？如何在多线程的场景下同时操作一块buffer进行图形绘制
- 解码后数据帧送显的三种方式
- OpenGL无法正常渲染某些分辨率YUV数据
- 使用eglSwapBuffers API，eglSwapBuffers执行抛出错误码：EGL_BAD_SURFACE （300d）。日志显示：QEGLPlatformContext: eglSwapBuffers failed: 300d。
- 使用eglSwapBuffers API，eglSwapBuffers执行抛错错误码：EGL_BAD_ALLOC。
- OpenGL同一个上下文在多线程中使用问题
- 关于GL_TEXTURE_2D和GL_TEXTURE_EXTERNAL_OES纹理类型的选择问题
- 一个EglSurface支持同时显屏和输出到编码器吗？
- 如何主动关闭CPU访问窗口缓冲区数据降低功耗

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics-2d-1
爬取时间: 2025-05-08 06:40:12
来源: Huawei Developer


自定义动画需要开发者自主实现。可以采用OpenGL进行绘制。关于动画的实现主要是业务方的逻辑，首先业务方需要识别动画触发事件，根据业务诉求获取动画的起点和终点。然后根据时间轴和动画曲线计算每一帧的绘制内容。最后调用OpenGL的接口绘制这部分内容。


参考链接


Native XComponent


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics-2d-2
爬取时间: 2025-05-08 06:40:22
来源: Huawei Developer


没有提供获取实时帧率的直接接口，只能获取单帧到达时间，可以通过间隔两次的到达时间自行计算，计算方式以及使用方法如下。


参考代码如下：


```typescript
import { displaySync } from '@kit.ArkGraphics2D'; 
 
@Entry 
@Component 
struct Index { 
  @State backDisplaySync: displaySync.DisplaySync = displaySync.create(); 
  private passframeInfo: Array<displaySync.IntervalInfo> = [] 
  @State fps: number = 0 
 
  aboutToAppear(): void { 
    let callback = (frameInfo: displaySync.IntervalInfo) => { 
      this.passframeInfo.push(frameInfo); 
      if (this.passframeInfo.length >= 2) { 
        let tmp = this.passframeInfo[1].timestamp - this.passframeInfo[0].timestamp; 
        let result = 1000000000 / Number.parseInt(tmp.toString()); 
        this.fps = result; 
        this.passframeInfo.shift(); 
      } 
    }; 
    // 注册订阅函数 
    this.backDisplaySync?.on("frame", callback); 
  } 
 
  build() { 
    Column() { 
      Row() { 
        Text('Start') 
          .fontSize(50) 
          .onClick(() => [ 
            this.backDisplaySync?.start() 
          ]) 
      } 
 
      Row() { 
        Text(this.fps.toString()) 
          .fontSize(50) 
      } 
 
      Row() { 
        Text('End') 
          .fontSize(50) 
          .onClick(() => [ 
            this.backDisplaySync?.stop() 
          ]) 
      } 
    } 
    .justifyContent(FlexAlign.Center) 
    .width('100%') 
    .height('100%') 
  } 
}
```


参考链接


@ohos.graphics.displaySync (可变帧率)


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics-2d-3
爬取时间: 2025-05-08 06:40:31
来源: Huawei Developer


问题详情：


多线程调用 OH_Drawing_TypographyCreate* handler = OH_Drawing_CreateTypographyHandler(typoStyle,OH_Drawing_CreateFontCollection()) 发生崩溃，单线程调用则不会崩溃。


解决措施：


目前该接口不支持多线程并发，但可以在异步线程中执行。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics-2d-6
爬取时间: 2025-05-08 06:40:41
来源: Huawei Developer

- 支持多线程，可以通过每个线程各自产生一块纹理，再将这些纹理合成到一块buffer。
- 可以使用sharedContext，另外绘制操作可通过调用OpenGL实现。

```less
void CreateShareEglContext() 
{
  if (renderContext == nullptr) { // renderContext是主线程context 
    RS_LOGE("renderContext_ is nullptr");
    return;
  }
  eglShareContext = renderContext->CreateShareContext(); //  创建share context 
  if (eglShareContext == EGL_NO_CONTEXT) {
    RS_LOGE("eglShareContext is EGL_NO_CONTEXT");
    return;
  }
  if (!eglMakeCurrent(renderContext->GetEGLDisplay(), EGL_NO_SURFACE, EGL_NO_SURFACE, eglShareContext)) {
    RS_LOGE("eglMakeCurrent failed");
    return;
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics-2d-7
爬取时间: 2025-05-08 06:40:51
来源: Huawei Developer


方式一：直接将XComponent对应的NativeWindow和解码器绑定(surface模式)。


方式二： NativeImage + XComponent surface模式，先将NativeImage对应的NativeWindow和解码器绑定（surface模式），获取到解码器输出纹理后，同时NativeImage通过OpenGL将纹理写入XComponent surface实现送显。


方式三： buffer模式 + XComponent surface模式，解码器输出的buffer，通过OpenGL 写入XComponent surface实现送显。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics-2d-8
爬取时间: 2025-05-08 06:41:01
来源: Huawei Developer


问题现象


某些分辨率下的YUV数据(比如668*352)，在通过OpenGL渲染时，图像会失真。


解决措施


由于OpenGL渲染要求宽16对齐，高2对齐。如果不需要按照此规格对齐，在渲染时需要加上glPixelStorei(GL_UNPACK_ALIGNMENT, 1); // 禁用纹理字节对齐限制


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics-2d-9
爬取时间: 2025-05-08 06:41:11
来源: Huawei Developer


surface不是EGL绘图表面就会报这个错：EGL_BAD_SURFACE。建议检查eglCreateWindowSurface/eglCreatePixmapSurface/eglCreatePbufferSurface的参数设置。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics-2d-10
爬取时间: 2025-05-08 06:41:19
来源: Huawei Developer


编码器通过OH_VideoEncoder_GetSurface(encoder_, &NativeWindow)获取NativeWindow，使用该NativeWindow去创建Encoder的EGLSurface来接收OpenGL的纹理数据。如果没有先调用OH_NativeWindow_NativeWindowHandleOpt(nativeWindow, SET_BUFFER_GEOMETRY, height, width) 来设置SET_BUFFER_GEOMETRY配置buffer大小，那么在调用eglSwapBuffers API时就会报该错误。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics-2d-11
爬取时间: 2025-05-08 06:41:29
来源: Huawei Developer


问题现象


在主线程中初始化EGL环境，创建了上下文‌Context，然后将渲染过程放在单独的子线程中去处理，这时的渲染会黑屏。


解决措施


因为OpenGL的上下文（‌Context）‌是与一个特定的线程绑定的，所以不能在同一个OpenGL上下文中同时从多个线程进行操作。


方法一：可以将EGL的初始化和渲染过程都放在同一个线程中处理；


方法二：当主线程完成EGL初始化和创建上下文后，再调用eglMakeCurrent方法在主线程中解绑当前上下文，然后在子线程中重新绑定上下文。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics-2d-12
爬取时间: 2025-05-08 06:41:39
来源: Huawei Developer


问题现象


在进行读取相册视频-->解封装-->解码-->OpenGL处理中，解码后的数据通过NativeImage中对应的生产者端NativeWindow来接收，NativeImage和OpenGL纹理绑定，但是测试发现解码输出的内容并没有更新到OpenGL纹理上去，也就是没有获取到OpenGL纹理数据。


原因分析


关于GL_TEXTURE_2D和GL_TEXTURE_EXTERNAL_OES纹理类型的使用场景的区别：

- GL_TEXTURE_2D纹理类型的使用场景：适用于大多数场景，可以用于展示静态贴图、渲染2D图形和进行图像处理等操作。
- GL_TEXTURE_EXTERNAL_OES纹理类型的使用场景：专门用于对外部图像或实时视频流进行处理，可以直接从BufferQueue中接收的数据渲染纹理多边形，从而提高更高效的视频处理和渲染性能。例如，我们需要从Camera或外部视频源读取数据帧进行处理时，就要选用该纹理类型。

解决措施


通过NativeImage关联的OpenGL ES纹理会绑定到GL_TEXTURE_EXTERNAL_OES目标上，因此，在创建OH_NativeImage并关联OpenGL的时候，纹理目标选用的应该是GL_TEXTURE_EXTERNAL_OES而不是GL_TEXTURE_2D。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics-2d-13
爬取时间: 2025-05-08 06:41:48
来源: Huawei Developer


不支持一个EglSurface同时显屏和输出到编码器。


原因分析


显屏和输出到编码器用同一个EglSurface，会导致buffer无法正常轮转，EglSurface里面的生产者-消费者是一对一的，一个生产者无法对应多个消费者。


解决措施


OpenGL处理后，同时显屏和输出到编码器在流程上是支持的，只不过要创建两个EglSurface来处理，然后用eglMakeCurrent方法选择每次需要消费的EglSurface即可。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics-2d-14
爬取时间: 2025-05-08 06:41:57
来源: Huawei Developer


当前操作系统的窗口缓冲区默认使用CPU访问，这样具有较好的兼容性，但GPU访问窗口缓冲区的能效通常更优，使用CPU访问的能效开销较大。当开发者确定应用无需CPU访问时可手动关闭该能力，提高应用能效。


问题现象


通常自绘制应用在生产缓冲区内容时，会默认使用CPU访问能力。此时由于CPU访问缓冲区效率较低，性能开销较大。


解决措施


如果开发者确认应用不需要使用CPU访问窗口缓冲区数据，应用可在首次获取窗口句柄 (OnSurfaceCreatedCB) 时关闭CPU访问能力，由硬件平台选择最佳的图像格式以提高能效降低功耗。


在首次获取窗口句柄 (OnSurfaceCreatedCB) 时调用OH_NativeWindow_NativeWindowHandleOpt(…, SET_USAGE, …)方法设置缓冲区USAGE的值，实现关闭CPU访问能力，系统会选择更高效的方法（GPU等）访问缓冲区，参考代码如下：


```less
void OnSurfaceCreatedCB(OH_NativeXComponent *component, void *window) {    
    uint64_t usage = 0;
    int32_t ret = OH_NativeWindow_NativeWindowHandleOpt((OHNativeWindow*)window, GET_USAGE, &usage);
    usage &= ~NATIVEBUFFER_USAGE_CPU_READ;
    int32_t ret2 = OH_NativeWindow_NativeWindowHandleOpt((OHNativeWindow*)window, SET_USAGE, usage);
}
```


对于大型游戏等高负载场景，关闭CPU访问可提高30%左右的能效。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-graphics-accelerate-kit
爬取时间: 2025-05-08 06:42:07
来源: Huawei Developer

- 超帧和ABR支持的图形API有哪些？
- Kit支持的设备类型有哪些？
- 开启超帧外插模式后运动物体边缘出现严重拖影现象，可能的原因是什么？
- 哪些特征的Buffer适合使能ABR？
- ABR进行Buffer分辨率调整引起其他Pass渲染效果异常，该如何解决？
- 集成ABR后，从游戏引擎获取到的Native纹理内容为空，该如何解决?

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/graphics-accelerate-faq-1
爬取时间: 2025-05-08 06:42:16
来源: Huawei Developer


目前超帧接口支持OpenGL ES和Vulkan图形API平台。ABR接口仅支持OpenGL ES图形API平台，暂不支持Vulkan平台。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/graphics-accelerate-faq-6
爬取时间: 2025-05-08 06:42:26
来源: Huawei Developer


Graphics Accelerate Kit支持的硬件设备类型包括：华为手机、华为平板设备。同时，您可以通过调用canIUse()接口并传入"SystemCapability.GraphicsGame.RenderAccelerate"进行设备类型适配查询。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/graphics-accelerate-faq-2
爬取时间: 2025-05-08 06:42:35
来源: Huawei Developer


由于外插模式需要标记模板缓冲（Stencil Buffer）的第8位用于区分静态物体和动态物体，即静态物体模板值第8位标记成0，动态物体模板值第8位标记成1，模板缓冲的低7位模板值开发者可自行设置。如果标记错误或漏标记，可能会在动态物体边缘产生严重的拖影现象。


现象描述


Demo中运动角色出现头身分离等严重拖影现象。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160915.09256905381569773051831493596317:50001231000000:2800:0BAF432B7E5BB5ECA95CF8D86B536F9C33DEB4576C2C3AB55EED03F968E33812.png)

原因分析


通过抓帧查看模板缓冲中的模板值，发现头发区域模板值为0，身体区域模板值为0x80。由于角色头、身均属于运动目标区域，应该将所有运动物体区域的模板值第8位标记为1。错误的头部区域模板值导致超帧效果出现头身分离的严重拖影现象。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160915.86867039761687457355096968545588:50001231000000:2800:07C9C9C48A2EE2A7393C9FEF205EBEB6ACE9402DED5C5610E6DBE347E80DB2CF.png)

处理步骤


基于分析结论，造成头身分离拖影现象的主要原因是运动区域模板值未统一标记为1xxx xxxx。因此将运动角色头发和面部区域的模板值统一改为0x80，保持和身体模板值一致，头身分离的拖影现象消失，效果如下图所示。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160915.60158885097317157629890819944581:50001231000000:2800:558C431EA0B2392979DEB467AF8583770766E412F62D0015FECA27576DE9EB75.png)

代码示例


检查动态物体材质Shader中的模板值是否设置正确，即静态物体模板值标记为0xxx xxxx，动态物体模板值标记为1xxx xxxx。


```less
Shader "Standard_with_stencil"
{
    Properties
    {
        /* ... */
        _LightingStencilRef("Lighting Stencil Reference", Float) = 128 // 将动态物体材质模板值改为1xxx xxxx，消除头身分离现象
        [Enum(UnityEngine.Rendering.CompareFunction)] _LightingStencilComp("Lighting Stencil Comparison", Float) = 8
        _StencilReadMask("Stencil Read Mask", Float) = 255   
        _StencilWriteMask("Stencil Write Mask", Float) = 255
    }
    SubShader
    {
        /* ... */
        Pass
        {
            /* ... */
            Stencil
            {
                Ref[_LightingStencilRef]
                Comp[_LightingStencilComp] 
                ReadMask[_StencilReadMask]
                WriteMask[_StencilWriteMask]
                Pass Replace
            }
        }
    }
}
```


不同管线的Shader中需要配置模板值的Pass不同，如下：

-  在每个有DepthOnly或DepthNormals的Pass中，即出现Tags {"LightMode" = "DepthOnly" }或Tags {"LightMode" = "DepthNormals" }的Pass，配置模板值。
-  在每个有ForwardBase或ForwardAdd的Pass中，即出现Tags {"LightMode" = "ForwardBase" }或Tags {"LightMode" = "ForwardAdd" }的Pass，配置模板值。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/graphics-accelerate-faq-3
爬取时间: 2025-05-08 06:42:45
来源: Huawei Developer

- 着色器处理耗时较高的Buffer。
- 原始分辨率较高的Buffer，建议不低于720P。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/graphics-accelerate-faq-4
爬取时间: 2025-05-08 06:42:54
来源: Huawei Developer


现象描述


以团结引擎URP管线为例，ABR对DrawOpaqueObjects绑定的Buffer进行分辨率调整时会引起SSAO shadow效果异常。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160915.16813921975990804210754136475430:50001231000000:2800:A46156042F01A294943BA160D15B012AAF4F2E9D3BFF49CDAB61F8BC136E69FD.png)

原因分析


通过上述URP管线可以看到，SSAO在渲染管线中是一个“前处理”，SSAO输出的图像会作为DrawOpaqueObjects的输入。当ABR对DrawOpaqueObjects绑定的Buffer进行自适应分辨率调整时，SSAO输出的图像为原始分辨率，而DrawOpaqueObjects绑定的Buffer使用低分辨率，分辨率不一致导致SSAO shadow效果异常。


处理步骤


针对该问题的解决方案，以下两种方案二选一即可。

-  在URP资产中勾选“After Opaque”：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160915.28432545162038040515043938966978:50001231000000:2800:6845FC788D49A0744F1994B72ABCB63BE82F38B5E388A027472C3D27C542B265.png)
-  SSAO的shader会根据scaledScreenParams参数进行计算，该变量与渲染分辨率相关，在集成ABR后，scaledScreenParams需要根据实时的ABR Buffer分辨率因子调整。 对于团结引擎，可在ScriptableRenderer.cs的SetPerCameraShaderVariables函数中根据Buffer分辨率因子设置scaledScreenParams参数。

```less
void SetPerCameraShaderVariables(CommandBuffer cmd, ref CameraData cameraData, bool isTargetFlipped)
{
    Camera camera = cameraData.camera;
    float scaledCameraWidth = (float)cameraData.cameraTargetDescriptor.width;
    float scaledCameraHeight = (float)cameraData.cameraTargetDescriptor.height;
    // scale为通过HMS_ABR_GetScale接口获取的ABR Buffer分辨率因子
    scaledCameraWidth *= scale;
    scaledCameraHeight *= scale;
    cmd.SetGlobalVector(ShaderPropertyId.scaledScreenParams, new Vector4(scaledCameraWidth, scaledCameraHeight, 1.0f + 1.0f / scaledCameraWidth, 1.0f + 1.0f / scaledCameraHeight));
}
```


对于同时支持渲染线程、RHI线程的游戏引擎，而且RHI线程延迟于渲染线程的场景，渲染线程通过HMS_ABR_GetScale接口获取的ABR Buffer分辨率因子无法解决上述问题。


```less
// 在Buffer渲染后调用
float scale = 1.0f;
errorCode = HMS_ABR_GetNextScale(context_, &scale);
if (errorCode != ABR_SUCCESS) {
    GOLOGE("HMS_ABR_GetNextScale execution failed, error code: %d.", errorCode);
}


// 根据Buffer分辨率因子对渲染数据进行同步调整
void SetViewUniformParameters()
{
    ViewUniformParameters.BufferSize.X = (int)(ViewUniformParameters.BufferSize.X * scale);
    ViewUniformParameters.BufferSize.Y = (int)(ViewUniformParameters.BufferSize.Y * scale);
    ViewUniformParameters.BufferInvSize.X /= scale;
    ViewUniformParameters.BufferInvSize.Y /= scale;
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/graphics-accelerate-faq-5
爬取时间: 2025-05-08 06:43:03
来源: Huawei Developer


现象描述


以团结引擎为例，游戏应用集成ABR，在游戏引擎中通过GetNativeTexturePtr获取Buffer关联的纹理，获取到的纹理内容为空。


原因分析


由于ABR对Buffer进行了自适应分辨率调整，并对ABR自适应缩放后的GLES纹理进行绘制，因而原始分辨率的GLES纹理中没有内容。


处理步骤


为解决此问题，需要通过HMS_ABR_GetScaledTexture_GLES接口获取到ABR自适应缩放后的GLES纹理索引。


```less
// 在Buffer渲染后调用
GLuint originTexture;
GLuint scaledTexture;
errorCode = HMS_ABR_GetScaledTexture_GLES(context_, originTexture, &scaledTexture);
if (errorCode != ABR_SUCCESS) {
    GOLOGE("HMS_ABR_GetScaledTexture_GLES execution failed, error code: %d.", errorCode);
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-xengine-kit
爬取时间: 2025-05-08 06:43:13
来源: Huawei Developer

- 创建特性实例失败如何处理
- 超分和自适应VRS特性是否可以同时使用
- 自适应VRS深度附件使用说明
- 空域AI超分的输出颜色附件是否需要通过OH_NativeBuffer创建

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/xengine-kit-faq-1
爬取时间: 2025-05-08 06:43:23
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/xengine-kit-faq-2
爬取时间: 2025-05-08 06:43:33
来源: Huawei Developer


可以同时使用，用户可根据实际应用选择超分和自适应VRS的使用顺序。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/xengine-kit-faq-3
爬取时间: 2025-05-08 06:43:43
来源: Huawei Developer


当不使用重投影矩阵时，可以不传深度附件。若使用重投影矩阵则必须传递深度附件，否则会导致着色率图计算错误。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/xengine-kit-faq-4
爬取时间: 2025-05-08 06:43:52
来源: Huawei Developer


输出不需要，仅输入需要通过OH_NativeBuffer创建。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-game-service-kit
爬取时间: 2025-05-08 06:44:02
来源: Huawei Developer

- HarmonyOS NEXT游戏包名是否必须以.huawei结尾？
- 是否需要在游戏初始化成功后才可以调用其他业务接口？
- 是否支持游戏自定义联合登录面板？
- 当切换游戏账号或进行其它操作时，如何强制拉起联合登录面板？
- “提交角色信息”这一步是否是必须接入？
- 把HarmonyOS游戏账号资产转移至HarmonyOS NEXT游戏的过程中，游戏侧需要做什么？
- 同一个游戏账号下的账号资产能否互通？
- 原系统游戏登录使用的openId/playerId/unionId，转移到新系统后，HarmonyOS NEXT游戏保存的玩家标识是gamePlayerId，如何进行绑定？
- 若HarmonyOS游戏没有玩家华为账号的登录记录，是否仅剩绑定流程可选？
- 玩家选错游戏的登录方式后如何补救？
- 玩家角色（转移）回退后，能否通知游戏侧，以便关联数据？
- 转移回退后再登录HarmonyOS NEXT游戏的玩家体验是什么？
- 实名认证、未成年人防沉迷等逻辑是华为侧实现还是游戏侧实现？
- 如何获取华为账号中的头像昵称等信息？
- 游戏没有历史渠道包，不存在转移场景，或者未配置支持转移，可以直接跳过吗？
- 绑定场景下，玩家不授权手机时，如何绑定华为账号和游戏官方账号？
- 玩家授权的手机号是华为账号绑定的手机号还是安全手机号？
- 游戏是否必须提供解绑账号能力？
- 游戏如何实现不展示官方账号登录？
- 游戏官方账号图标大小是多少？
- 使用C#语言开发的游戏是否可以接入游戏场景感知功能？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-1
爬取时间: 2025-05-08 06:44:11
来源: Huawei Developer


无特殊要求，遵从为HarmonyOS应用/元服务创建APP ID即可，但建议正式上架包名不要包含test、dev等信息。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-2
爬取时间: 2025-05-08 06:44:21
来源: Huawei Developer


游戏需先成功调用初始化init接口后再调用其它接口，否则将导致审核被驳回。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-3
爬取时间: 2025-05-08 06:44:30
来源: Huawei Developer


Game Service Kit为HarmonyOS NEXT游戏提供统一的联合登录面板，游戏不能自定义。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-4
爬取时间: 2025-05-08 06:44:40
来源: Huawei Developer


若游戏提供官方账号登录方式时，调用unionLogin接口且将loginParam中的showLoginDialog参数设置为true，游戏即可在玩家切换账号时强制拉起联合登录面板。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-5
爬取时间: 2025-05-08 06:44:50
来源: Huawei Developer


可选但推荐接入。上报角色关系数据后，可用于后续基于角色维度的联运活动规划，为玩家提供更好的体验和更丰富的能力。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-6
爬取时间: 2025-05-08 06:44:59
来源: Huawei Developer


玩家在联合登录面板完成转移流程后，Game Service Kit支持HarmonyOS游戏的账号资产（角色、区服信息、游戏进度等）全部转移至HarmonyOS NEXT游戏中。


转移前后，华为账号不会发生变化，也不涉及开发者服务器和数据库层面的变动。


转移的本质是华为平台将HarmonyOS系统的玩家标识ID值赋给HarmonyOS NEXT系统下的玩家标识ID，同时重置原玩家标识ID的值。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-7
爬取时间: 2025-05-08 06:45:09
来源: Huawei Developer

- 转移场景：HarmonyOS 游戏的账号资产与HarmonyOS NEXT游戏的账号资产不互通。
- 绑定场景：游戏官包的账号资产和HarmonyOS NEXT游戏的账号资产互通，且支持使用华为账号关联游戏官方账号进入游戏官包。
- 游戏官方账号登录场景：游戏官包的账号资产和HarmonyOS NEXT游戏的账号资产互通。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-8
爬取时间: 2025-05-08 06:45:19
来源: Huawei Developer


前往AppGallery Connect控制台配置HarmonyOS游戏与HarmonyOS NEXT游戏的APP ID映射关系，配置映射关系的具体操作请参见配置APP ID映射关系。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-9
爬取时间: 2025-05-08 06:45:29
来源: Huawei Developer


不是。若游戏配置了APP ID映射关系，Game Service Kit会向玩家展示“转移”和“绑定”两种登录方式。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-10
爬取时间: 2025-05-08 06:45:38
来源: Huawei Developer


|  场景 |  补救措施 |
| --- | --- |
|  转移 |  支持玩家前往“游戏中心”客户端进行回退。回退成功后，玩家可在联合登录面板中重新选择游戏的登录方式。玩家转移回退的具体操作请参见转移回退。 |
|  绑定 |  支持玩家点击游戏内的“解绑账号”按钮，解除华为账号与游戏官方账号的绑定关系。解绑成功后，支持玩家在联合登录面板上重新选择游戏的登录方式。游戏侧在游戏内提供解绑账号的开发步骤请参见解绑游戏账号。用户在“游戏中心”客户端解绑的具体操作请参见解绑账号。 |
|  游戏官方账号登录 |  支持玩家点击游戏内的“切换账号”按钮拉起联合登录面板，支持玩家重新选择华为账号登录或游戏官方账号登录。游戏侧在游戏内提供切换账号功能的开发步骤请参见游戏内切换账号。 |

场景


补救措施


转移


支持玩家前往“游戏中心”客户端进行回退。回退成功后，玩家可在联合登录面板中重新选择游戏的登录方式。玩家转移回退的具体操作请参见转移回退。


绑定


支持玩家点击游戏内的“解绑账号”按钮，解除华为账号与游戏官方账号的绑定关系。解绑成功后，支持玩家在联合登录面板上重新选择游戏的登录方式。游戏侧在游戏内提供解绑账号的开发步骤请参见解绑游戏账号。用户在“游戏中心”客户端解绑的具体操作请参见解绑账号。


游戏官方账号登录


支持玩家点击游戏内的“切换账号”按钮拉起联合登录面板，支持玩家重新选择华为账号登录或游戏官方账号登录。游戏侧在游戏内提供切换账号功能的开发步骤请参见游戏内切换账号。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-11
爬取时间: 2025-05-08 06:45:48
来源: Huawei Developer


目前未规划这类能力，未来将考虑为游戏提供云侧API接口进行监听。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-12
爬取时间: 2025-05-08 06:45:58
来源: Huawei Developer


玩家在“游戏中心”客户端完成转移回退后，再登录HarmonyOS NEXT游戏时，游戏调用unionLogin接口（showLoginDialog默认为false），游戏不展示联合登录面板，直接向玩家展示登录提示（玩过，继续游戏/没有，开始游戏）面板，允许玩家重新选择转移流程或绑定流程。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-13
爬取时间: 2025-05-08 06:46:08
来源: Huawei Developer


| 登录场景  | 游戏侧  | 华为侧  |
| --- | --- | --- |
| 转移  | -  | 调用合规校验接口。  |
| 绑定  | 自行实现账号实名认证、未成年人防沉迷以及支付限额逻辑。  |
| 游戏官方账号登录  |

登录场景


游戏侧


华为侧


转移


-


调用合规校验接口。


绑定


自行实现账号实名认证、未成年人防沉迷以及支付限额逻辑。


游戏官方账号登录


“绑定场景”与“游戏官方账号登录场景”游戏侧与华为侧的双重校验均通过，玩家才能进入游戏。若有一方未通过校验，玩家将不能进入游戏。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-14
爬取时间: 2025-05-08 06:46:18
来源: Huawei Developer


游戏先调用createAuthorizationWithHuaweiIDRequest创建授权请求并设置参数，再调用executeRequest执行授权请求，成功后可获取头像昵称等信息。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-15
爬取时间: 2025-05-08 06:46:28
来源: Huawei Developer


游戏不存在转移场景时，请在配置APP ID映射关系时，HarmonyOS游戏选择“不涉及”。完成配置后，用户点击“华为账号登录”将默认进入授权绑定登录。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-16
爬取时间: 2025-05-08 06:46:37
来源: Huawei Developer


绑定场景下，若未拿到玩家授权的手机号，游戏可以通过玩家手动输入的账号和密码绑定华为账号和游戏官方账号。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-17
爬取时间: 2025-05-08 06:46:47
来源: Huawei Developer


默认使用的是华为账号绑定的手机号，同时也可以手动添加其它手机号，和安全手机号无关。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-18
爬取时间: 2025-05-08 06:46:59
来源: Huawei Developer


是的，游戏必须向玩家提供解绑能力，具体的开发步骤请参见解绑游戏账号。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-19
爬取时间: 2025-05-08 06:47:09
来源: Huawei Developer


游戏调用unionLogin接口（将thirdAccountInfos参数传空数组）即可实现玩家登录游戏时不展示“游戏官方账号登录”选项，默认使用华为账号登录，届时Game Service Kit直接向玩家展示登录提示面板。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-20
爬取时间: 2025-05-08 06:47:19
来源: Huawei Developer


游戏官方账号ICON大小不超过35KB。若超过35KB，调用unionLogin接口时，会出现“1002000001 游戏内部通用错误”报错。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/gameservice-faq-21
爬取时间: 2025-05-08 06:47:28
来源: Huawei Developer


当前提供游戏场景感知C# SDK，可以实现使用C#语言开发的游戏接入游戏场景感知功能，具体请参见游戏场景感知C# SDK开发指导。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-xr
爬取时间: 2025-05-08 06:47:38
来源: Huawei Developer

- AR引擎（AR Engine）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ar-engine-kit
爬取时间: 2025-05-08 06:47:48
来源: Huawei Developer

- 获取检测平面的二维顶点数组时报错：“plane is nullptr!”，返回错误码：401
- 摄像头被遮挡一段时间后再放开，输出的位姿有跳变
- 反光、光线暗或者弱纹理场景（输入图像颜色变化小）下无法识别平面
- 某些特殊场景下（如附近存在磁场干扰、手机发烫或扫描到重复纹理等），出现平面漂移或者位姿数据跳变现象

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/arengine-faq-1
爬取时间: 2025-05-08 06:47:58
来源: Huawei Developer


现象描述


调用HMS_AREngine_ARPlane_GetPolygonSize获取检测到平面的二维顶点数组大小时报错：“plane is nullptr!”，返回错误码：401。


可能原因


初次打开应用还未识别到平面，调用HMS_AREngine_ARSession_GetAllTrackables获取的可跟踪对象列表为空，导致后续HMS_AREngine_ARTrackableList_AcquireItem获取对应索引的对象也为空，使用前未做有效性判断，使用时出现无效参数错误。


处理步骤


开发者从AR Engine获取平面之后需判断其有效性后使用，例如，进行非空判断。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/arengine-faq-2
爬取时间: 2025-05-08 06:48:08
来源: Huawei Developer


现象描述


使用运动跟踪能力时，摄像头被遮挡一段时间后再放开遮挡，调用HMS_AREngine_ARPose_GetPoseRaw函数获取的平移分量或旋转分量存在较大跳变。


可能原因


AR Engine通过摄像头采集数据感知当前设备在现实世界中的位姿，摄像头被遮挡后，AR Engine无法准确感知设备在现实世界的位姿变化，放开遮挡后，如果继续调用HMS_AREngine_ARSession_Update，AR Engine会尝试基于遮挡前识别到的数据进行恢复，如果当前摄像头采集数据和遮挡前类似，就可能会导致错误匹配到旧的结果，从而产生数据跳变。


处理步骤


如果开发者通过HMS_AREngine_ARCamera_GetTrackingState函数获取的状态为ARENGINE_TRACKING_STATE_PAUSED，可以通过函数：HMS_AREngine_ARCamera_GetTrackingStateReason进一步获取暂停原因，如暂停原因是ARENGINE_TRACKING_STATE_REASON_INSUFFICIENT_FEATURES或ARENGINE_TRACKING_STATE_REASON_EXCESSIVE_MOTION，建议在您的应用中提示用户，并在恢复后（HMS_AREngine_ARCamera_GetTrackingState获取的状态为：ARENGINE_TRACKING_STATE_TRACKING时）重新做session初始化，见：创建AR会话。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/arengine-faq-3
爬取时间: 2025-05-08 06:48:18
来源: Huawei Developer


现象描述


使用环境跟踪能力时，如果输入图像中有反光、光线暗、有弱纹理（输入图像颜色变化小），识别到的点云数量会变少甚至没有，出平面时间也会变长或无法生成平面。

1. 
2. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160945.70318879908886876204364147438927:50001231000000:2800:90ADB1F25C63F12517B528E5022FDF9CD01B93E999385262F315281FB33BC862.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160946.80149778653009129030965376404457:50001231000000:2800:28E913454A7C916B5DB15DDBF77D7DAC389D49229634148B942DEC40488248C0.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160946.62586575955041649487545566148682:50001231000000:2800:7B971208BA3EC8E47F94F4D990BEC1E540BC5128823B021A8D21BFB556832160.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160947.06200926122122679577075795042313:50001231000000:2800:2DF1AC351B5211291EFE7ACF868F3EF245C7CF89975FE4806CCD39BCE25309F1.jpg)

可能原因


AR Engine通过输入的图像数据进行平面上特征点的计算，如果输入图像数据中存在反光、光线暗和弱纹理，AR Engine计算后只能得到很少的点，而平面根据识别到的点云生成，因此会导致平面出现慢或者不出现的现象发生。


处理步骤


建议应用在持续无法获取点云或平面数据时，提示用户移动相机，避免画面中持续出现反光、光线暗或弱纹理。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/arengine-faq-4
爬取时间: 2025-05-08 06:48:28
来源: Huawei Developer


现象描述


某些特殊场景下，如使用环境附近存在强磁场，手机处于高负载场景下（后台开启很多应用或长时间使用导致手机发烫），或者扫描到重复纹理（见下图）时，可能出现识别到的平面无法锚定到现实世界中，或者通过HMS_AREngine_ARCamera_GetPose接口获取的位姿信息出现大幅度跳变等现象。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160947.89622272867522902271169343670207:50001231000000:2800:3DB630C37E8C736BE992A64D34CBBF8BEDAAA098614C754B9500A2DAAB97792D.jpg)

可能原因


AR Engine通过获取到的加速度计传感器和磁力计传感器的信息进行平面计算和相机位姿计算，上述特殊场景下，系统传感器数据可能会存在异常，从而导致平面漂移或者位姿跳变的现象发生。


处理步骤


建议应用对通过HMS_AREngine_ARCamera_GetPose接口获取到的位姿数据，按照实际应用使用场景进行滤波，如步行导航场景，应用可以缓存多帧数据，通过多帧数据可以计算得到运动速度，如果检测到此速度明显高于步行速度，证明此时AR数据已经不可信，可以丢弃此数据或者重启AR算法。


计算运动速度：x,y,z为在t时刻的位姿数据的位移量。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160948.19643909112725415156047952472940:50001231000000:2800:40EA5AEBA186E612CF8E8ECCF192DBF6541EDB1183C96B3C9F263501B2CD76A9.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-service-development
爬取时间: 2025-05-08 06:48:38
来源: Huawei Developer

- 实况窗服务（Live View Kit）
- 用户通知服务（Notification Kit）
- 推送服务（Push Kit）
- 应用内支付服务（IAP Kit）
- 华为支付服务（Payment Kit）
- 地图服务（Map Kit）
- 位置服务（Location Kit）
- 运动健康服务（Health Service Kit）
- 华为账号服务（Account Kit）
- 钱包服务（Wallet Kit）
- 分享服务（Share Kit）
- 天气服务（Weather Service Kit）
- 通话服务（Call Service Kit）
- 融合场景服务（Scenario Fusion Kit）
- 广告服务（Ads Kit）
- 应用市场（AppGallery Kit）
- 文件预览（Preview Kit）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-live-view-kit
爬取时间: 2025-05-08 06:48:46
来源: Huawei Developer

- 更新实况窗被频控的问题
- 三方开发框架接入的问题
- 关于实况窗生命周期的问题
- 关于实况窗模板使用的问题
- 关于实况窗数量约束的问题

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/liveview-faq-1
爬取时间: 2025-05-08 06:48:56
来源: Huawei Developer


通过Push Kit更新实况窗时，单个实况窗消息每个设备每5分钟最多更新10次，每小时最多更新60次。出行打车与赛事比分场景，5分钟最多更新30次，每小时最多更新180次。详情见Push Kit消息频控。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/liveview-faq-2
爬取时间: 2025-05-08 06:49:06
来源: Huawei Developer


HarmonyOS为常见的三方开发框架提供了接入指南：

- React Native
- Flutter
- Uni-app

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/liveview-faq-3
爬取时间: 2025-05-08 06:49:16
来源: Huawei Developer


如何实现“App关闭时，自动关闭构建的实况窗”


当App关闭时，可以调用liveViewManager.stopLiveView方法，设置参数PrimaryData实例的keepTime值为0，即可实现立即关闭实况窗。


本地更新如何获取实况窗实例以及实况窗被清除后的限制


1. 本地更新实况窗时，可以通过liveViewManager.getActiveLiveView函数获取活动的LiveView实例。


2. 如果想要结束实况窗，建议使用liveViewManager.stopLiveView方法。如果实况窗被notificationManager.cancel或notificationManager.cancelAll清除后，无论是Live View Kit还是Push Kit，无法再次通过该id更新或结束实况窗。


3. 再次创建该id的实况窗时，Live View Kit可以通过该id再次创建实况窗，Push Kit在12小时内无法通过该id再次创建实况窗。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/liveview-faq-4
爬取时间: 2025-05-08 06:49:24
来源: Huawei Developer


采用进度可视化模板并且indicatorType为INDICATOR_TYPE_OVERLAY时，图片较宽，无法完全覆盖进度条


当indicatorType=INDICATOR_TYPE_OVERLAY时，图标区域为64*56vp，图片较宽时会按比例进行缩放。应用需要自己修改图片大小和样式来达到想要的效果。


理想效果图

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507160952.81314816774783290220566944541317:50001231000000:2800:3C3428CBB898CC0E05413B20ADBAA7BA949A5484B6CACAC1521660989F79D6EA.png)

如何修改 "实况窗左上角图标"


除导航模板通过currentNavigationIcon设置左上角图标外，其他模板不支持修改实况窗左上角图标，默认展示为系统图标。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/liveview-faq-5
爬取时间: 2025-05-08 06:49:33
来源: Huawei Developer


1. 创建实况时的id约束：可以一次性创建多个实况窗，需要保证其id唯一，同一id在同一时刻只能创建一个实况窗。（当该id的实况窗结束后，Live View Kit可以通过该id再次创建，Push Kit在12小时内该id无法再次创建。）


2. 展示实况窗时的交互约束：在通知中心通过滑动最多展示24条实况窗。通过点击胶囊弹出的实况窗列表，无法滑动，只能展示5条实况窗。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-notification-kit
爬取时间: 2025-05-08 06:49:43
来源: Huawei Developer

- 如何让事件只在一个UIAbility实例中传递
- 如何监听系统公共事件，如熄屏、亮屏、开机等
- requestEnableNotification接口申请通知权限的机制是怎样的
- 系统弹框和应用消息推送的区别是什么
- 调用notificationManager.publish发布通知失败
- emitter.off取消订阅某个事件后，是不是所有订阅该事件的地方都不会再收到该事件的消息

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-notification-kit-2
爬取时间: 2025-05-08 06:49:53
来源: Huawei Developer


在UIAbility中使用EventHub订阅事件，EventHub模块提供了事件中心，提供订阅、取消订阅、触发事件的能力。


参考代码如下：


```typescript
import { UIAbility } from '@kit.AbilityKit'; 
 
export default class EntryAbility extends UIAbility { 
  onForeground() { 
    this.context.eventHub.on('myEvent', this.eventFunc); 
    // 结果： 
    // eventFunc is called,undefined,undefined 
    this.context.eventHub.emit('myEvent'); 
    // 结果： 
    // eventFunc is called,1,undefined 
    this.context.eventHub.emit('myEvent', 1); 
    // 结果： 
    // eventFunc is called,1,2 
    this.context.eventHub.emit('myEvent', 1, 2); 
  } 
 
  eventFunc(argOne: number, argTwo: number) { 
    console.log('eventFunc is called, ${argOne}, ${argTwo}'); 
  } 
}
```


参考链接


使用EventHub进行数据同步


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-notification-kit-5
爬取时间: 2025-05-08 06:50:03
来源: Huawei Developer


通过CES（Common Event Service，公共事件服务）为应用程序提供订阅、发布、退订公共事件的能力。可以通过订阅系统公共事件监听熄屏和亮屏。另外开机事件可使用公共事件"COMMON_EVENT_BOOT_COMPLETED"来监听。


参考代码如下：


```less
import { commonEventManager } from '@kit.BasicServicesKit'; 
 
let subscriber:commonEventManager.CommonEventSubscriber; 
let subscribeInfo: commonEventManager.CommonEventSubscribeInfo = { 
  events: ['usual.event.SCREEN_OFF'], // 订阅灭屏公共事件 
  priority:80 
} 
commonEventManager.createSubscriber(subscribeInfo, (err, data) => { 
  if (err) { 
    console.error(`Failed to create subscriber. Code is ${err.code}, message is ${err.message}`); 
    return; 
  } 
  console.info('Succeeded in creating subscriber1.'); 
  subscriber = data; 
  // 订阅公共事件回调 
  commonEventManager.subscribe(subscriber, (err, data) => { 
    if (err) { 
      console.error(`Failed to subscribe common event. Code is ${err.code}, message is ${err.message}`); 
      return; 
    } else { 
      console.info(`Succeeded in subscribe common event Succeeded1 `); 
    } 
  }) 
})
```


参考链接


系统公共事件定义


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-notification-kit-6
爬取时间: 2025-05-08 06:50:13
来源: Huawei Developer

- requestEnableNotification首次执行时，会直接弹出通知权限的申请弹窗，且该接口的回调函数与用户是否授权无关。
- requestEnableNotification非首次执行时，不会弹出通知权限的申请弹窗，且无论是否拥有通知权限，都会直接返回success。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-notification-kit-7
爬取时间: 2025-05-08 06:50:22
来源: Huawei Developer

- 系统弹框是指操作系统在特定情况下会弹出的提示框，例如电脑端的系统更新提示、手机端的电量低提示等。系统弹框通常是由操作系统自己控制和展示的，应用程序无法主动触发或控制。
- 应用消息推送则是指应用程序在后台发送的消息通知，可以显示在手机的通知栏或电脑的任务栏等位置，例如社交媒体应用的新消息提醒、邮件应用的邮件到达提醒等。应用消息推送需要应用程序自己发送，用户可以根据自己的需要设置是否接收这些通知。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-notification-kit-8
爬取时间: 2025-05-08 06:50:31
来源: Huawei Developer


问题现象


发布通知后，无错误日志信息，通知栏没有通知显示。


可能原因


未开启对应应用的通知开关。


解决措施


发布通知时，需要在真机端系统设置中，开启对应应用的通知开关，然后才能在通知栏中看到发布的通知。

- 手动开启步骤：设置 > 通知和状态栏 > 应用名称 > 允许通知。
- 也可通过接口notificationManager.requestEnableNotification()来弹窗让用户授权（仅弹一次）。

参考链接


requestEnableNotification


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-notification-kit-9
爬取时间: 2025-05-08 06:50:41
来源: Huawei Developer


是的，emitter.off取消订阅某个事件后，所有订阅这个事件的地方都不会再收到这个事件的消息。


参考代码如下：


```less
// 取消eventID为1的所有事件回调处理函数 
emitter.off(1);
```


参考链接


emitter.off


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-push-kit
爬取时间: 2025-05-08 06:50:51
来源: Huawei Developer

- 如何处理推送消息时遇到的问题
- 关于云侧接口推送成功但设备收不到推送消息的问题
- 如何处理误分类问题
- 如何处理推送通知消息数量不够用问题
- 关于通知消息被频控的问题
- 应用内通话消息在设备重启后的首次锁屏状态问题
- 应用内通话消息来电接听与横幅问题
- 推送通知消息接口URL版本说明
- 应用进程处于后台能否接受到消息？
- 要实现即时聊天功能应该使用什么类型的场景化消息？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/push-faq-2
爬取时间: 2025-05-08 06:51:01
来源: Huawei Developer


云侧消息下发成功后，可能会因为消息频控、通知开关未打开等原因，导致端侧消息未展示。


请您自查是否为以下情况造成：

- skills标签配置问题，正确的配置方法请参见点击消息动作。
- 终端设备的网络连接异常。
- 终端的通知开关关闭。
- 应用已卸载，未安装。

Push Kit建议您开发消息回执，Push服务端会将消息送达状态以回执消息形式发送给您的应用回执服务端，方便您获取消息下达端侧后的状态，通过回执状态码定位问题。

- 您使用的Push Token已经过期（可能原因请参见Push Token发生变化的场景），请重新生成Push Token发送消息。
- 消息被频控，请检查是否开通消息自分类权益；调测阶段建议发送测试消息，详情请参见关于通知消息被频控的问题。

您可以登录AppGallery Connect进行消息追踪和token信息查询，查询路径：“我的项目 > 增长 > 推送服务 > 自助分析（Beta）”。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/push-faq-3
爬取时间: 2025-05-08 06:51:11
来源: Huawei Developer


如何处理应用类别误分类


未发布应用，可以登录AppGallery Connect网站，点击“应用发布”，在应用列表中找到您的应用，修改应用分类。关于应用分类信息，请参见华为应用市场应用分类示例。


如何处理通知消息类别误分类


应用在不违反通知违规处罚标准的前提下推送消息，可按要求申请通知消息自分类权益。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/push-faq-4
爬取时间: 2025-05-08 06:51:20
来源: Huawei Developer


建议您优化推送策略，做精细化推送，尽量减少或避免全量用户的推送。如果您的消息内容中有符合服务与通讯类消息的内容，建议您申请和接入消息自分类，详情请参见通知消息分类标准与提醒方式，接入后该类消息的限制为每个设备每天不超过3000条。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/push-faq-5
爬取时间: 2025-05-08 06:51:29
来源: Huawei Developer


为了给用户提供更好的消息通知体验，营造清朗网络空间，华为推送服务设置了多条频控规则。若消息超出规则限制，超出的消息将会被丢弃，直到次日恢复。


通知消息被频控的可能原因

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161013.36834592672115987711932416261964:50001231000000:2800:A859EFBC414743D845C604AEDD19C993DE1F6C3AE3C7D796D02273132557922C.png)

调测阶段，每个项目每个自然日最多可推送1000条测试消息（非设备级，所有设备共用1000条），且不受场景化消息频控限制（即不区分通知消息类别、不区分场景化消息类别）。发送测试消息需设置testMessage为true。


若消息数量超出1000条频次限制，推送服务将向您的回执服务器返回256结果码。（1000条为REST API请求成功总数，非成功到达端侧的消息总数）


正式发布阶段，单设备单应用下每个自然日最多可推送3000条消息，并受场景化消息频控限制，具体频控规则见下表：


|  场景 |  频控规则 |
| --- | --- |
|  通知消息 |  若您未申请通知消息自分类权益，则推送的通知消息默认为资讯营销类（category取值为MARKETING）消息，根据通知消息推送数量管理规则限制单设备单应用下每个自然日，限制推送数量为2条或5条；若您仅需发送资讯营销类消息，则无需申请通知消息自分类权益。 授权订阅消息不大于每5分钟30次，超过30次会进入频控状态，5分钟内不能对进入频控的同一终端再次发送订阅请求，超过5分钟后重置。 |
|  卡片刷新消息 |  应用每个设备单个卡片上架时为2条/天，未上架为5条/天。 |
|  实况窗消息 |  单个实况窗消息每个设备每5分钟最多更新10次，每小时最多更新60次。 出行打车与赛事比分场景，5分钟最多更新30次，每小时最多更新180次。 |

场景


频控规则


通知消息


若您未申请通知消息自分类权益，则推送的通知消息默认为资讯营销类（category取值为MARKETING）消息，根据通知消息推送数量管理规则限制单设备单应用下每个自然日，限制推送数量为2条或5条；若您仅需发送资讯营销类消息，则无需申请通知消息自分类权益。


授权订阅消息不大于每5分钟30次，超过30次会进入频控状态，5分钟内不能对进入频控的同一终端再次发送订阅请求，超过5分钟后重置。


卡片刷新消息


应用每个设备单个卡片上架时为2条/天，未上架为5条/天。


实况窗消息


单个实况窗消息每个设备每5分钟最多更新10次，每小时最多更新60次。


出行打车与赛事比分场景，5分钟最多更新30次，每小时最多更新180次。


若消息数量超出3000条频次限制，推送服务将向您的回执服务器返回102结果码。


若场景化消息超出对应的频控规则限制，推送服务将向您的回执服务器返回256结果码。


频控规则详情请参见消息频控，回执状态码详情请参考回执状态码。


使用REST API接口单次推送消息可携带的Push Token数量是多少？


单次推送消息可携带的Push Token最多1000个，因此Push Kit服务器每次最多根据Token发送1000条消息。如果大于1000条，请求会返回错误码80300010，建议开发者分批发送。


推送消息最大为4KB，这是否意味着给1000个Token推送消息将超过此限制？


消息体大小限制不包括Token。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/push-faq-6
爬取时间: 2025-05-08 06:51:38
来源: Huawei Developer


当终端处于设备重启后的首次锁屏状态时，应用子进程可能会因数据区加密而导致访问失败，进而出现业务无法正常执行的情况。请您在开发时适配此种场景，进行相关异常保护。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/push-faq-7
爬取时间: 2025-05-08 06:51:48
来源: Huawei Developer


详情请参见Call Service Kit常见问题。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/push-faq-8
爬取时间: 2025-05-08 06:51:58
来源: Huawei Developer


场景化消息请求体中，接口URL版本为V3 Beta（https://push-api.cloud.huawei.com/v3/[projectId]/messages:send）时，仅支持给HarmonyOS Next/5.x及之后的系统版本推送通知；接口URL版本为V2（https://push-api.cloud.huawei.com/v2/[projectId]/messages:send）时，仅支持给HarmonyOS 3.x/4.x的系统版本推送通知。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-iap-kit
爬取时间: 2025-05-08 06:52:08
来源: Huawei Developer

- AppGallery Connect中可以配置多个关键事件通知接收地址吗？
- AppGallery Connect获取的IAP公钥最大长度是多少？便于用户存储设置的最大长度是多少？
- AppGallery Connect商品管理页面，商品价格编辑界面的默认价格表示什么意思？
- 在AppGallery Connect中单独修改商品在某个地区的价格，以后汇率变动，是否会影响应用内的商品价格？
- AppGallery Connect商品管理页面中，价格展示是否做了数字调整？比如小数点第二位6/9等调整？
- 是否必须使用SHA256的证书才能通过验签？
- 签名校验是否可以都在服务端执行？
- 是否能在删除商品后添加具有相同productId的商品？
- IAP服务器支持的证书范围
- IAP服务器支持的加密套件范围
- 如何解决证书链不完整？
- 应用在子窗口中调用createPurchase拉起IAP Kit收银台时，子窗口会被隐藏，此现象正常吗？
- 在沙盒环境进行测试，但是实际需要真实支付是为什么？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/iap-faq-2
爬取时间: 2025-05-08 06:52:18
来源: Huawei Developer


不可以。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/iap-faq-3
爬取时间: 2025-05-08 06:52:27
来源: Huawei Developer


长度是随钥匙规格而定的，不是定长的。后续会升级到3072位或更长，建议在数据库中使用text类型存储。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/iap-faq-4
爬取时间: 2025-05-08 06:52:37
来源: Huawei Developer


该默认价格在AppGallery Connect页面其他地方涉及商品价格展示时使用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/iap-faq-5
爬取时间: 2025-05-08 06:52:45
来源: Huawei Developer


不会，除非开发者自己修改。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/iap-faq-6
爬取时间: 2025-05-08 06:52:55
来源: Huawei Developer


做了调整，具体调整规则请参见换算规则。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/iap-faq-7
爬取时间: 2025-05-08 06:53:04
来源: Huawei Developer


是的，现在华为开发者联盟上要求配置的就是SHA256指纹。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/iap-faq-8
爬取时间: 2025-05-08 06:53:14
来源: Huawei Developer


若开发者有架设服务器，建议在服务器执行签名校验。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/iap-faq-11
爬取时间: 2025-05-08 06:53:23
来源: Huawei Developer


不支持。同一个productId只能使用一次。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/iap-faq-12
爬取时间: 2025-05-08 06:53:33
来源: Huawei Developer


请检查开发者证书链，确保证书链的完整性，同时确保证书链中的证书在IAP服务器内置的如下92个证书中。如果证书链存在问题，请参见如何解决证书链不完整。


| #  | Alias name  | Subject DN  | Issuer DN  | Certificate Serial Number  | Version  | Valid From [GMT]  | Valid To [GMT]  | Thumbprint(SHA1)  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1  | verisignclass2g2ca [jdk]  | OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 2 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US  | OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 2 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US  | b92f60cc889fa17a4609b85b706c8aaf  | 1  | Mon May 18 03:00:00 IDT 1998  | Wed Aug 02 02:59:59 IDT 2028  | B3:EA:C4:47:76:C9:C8:1C:EA:F2:9D:95:B6:CC:A0:08:1B:67:EC:9D  |
| 2  | digicertassuredidg3 [jdk]  | CN=DigiCert Assured ID Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Assured ID Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US  | ba15afa1ddfa0b54944afcd24a06cec  | 3  | Thu Aug 01 15:00:00 IDT 2013  | Fri Jan 15 14:00:00 IST 2038  | F5:17:A2:4F:9A:48:C6:C9:F8:A2:00:26:9F:DC:0F:48:2C:AB:30:89  |
| 3  | verisignuniversalrootca [jdk]  | CN=VeriSign Universal Root Certification Authority, OU=”(c) 2008 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | CN=VeriSign Universal Root Certification Authority, OU=”(c) 2008 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | 401ac46421b31321030ebbe4121ac51d  | 3  | Wed Apr 02 03:00:00 IDT 2008  | Wed Dec 02 01:59:59 IST 2037  | 36:79:CA:35:66:87:72:30:4D:30:A5:FB:87:3B:0F:A7:7B:B7:0D:54  |
| 4  | digicerttrustedrootg4 [jdk]  | CN=DigiCert Trusted Root G4, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Trusted Root G4, OU=www.digicert.com, O=DigiCert Inc, C=US  | 59b1b579e8e2132e23907bda777755c  | 3  | Thu Aug 01 15:00:00 IDT 2013  | Fri Jan 15 14:00:00 IST 2038  | DD:FB:16:CD:49:31:C9:73:A2:03:7D:3F:C8:3A:4D:7D:77:5D:05:E4  |
| 5  | identrustpublicca [jdk]  | CN=IdenTrust Public Sector Root CA 1, O=IdenTrust, C=US  | CN=IdenTrust Public Sector Root CA 1, O=IdenTrust, C=US  | a0142800000014523cf467c00000002  | 3  | Thu Jan 16 19:53:32 IST 2014  | Mon Jan 16 19:53:32 IST 2034  | BA:29:41:60:77:98:3F:F4:F3:EF:F2:31:05:3B:2E:EA:6D:4D:45:FD  |
| 6  | utnuserfirstobjectca [jdk]  | CN=UTN-USERFirst-Object, OU=http://www.usertrust.com, O=The USERTRUST Network, L=Salt Lake City, ST=UT, C=US  | CN=UTN-USERFirst-Object, OU=http://www.usertrust.com, O=The USERTRUST Network, L=Salt Lake City, ST=UT, C=US  | 44be0c8b500024b411d3362de0b35f1b  | 3  | Fri Jul 09 21:31:20 IDT 1999  | Tue Jul 09 21:40:36 IDT 2019  | E1:2D:FB:4B:41:D7:D9:C3:2B:30:51:4B:AC:1D:81:D8:38:5E:2D:46  |
| 7  | geotrustuniversalca [jdk]  | CN=GeoTrust Universal CA, O=GeoTrust Inc., C=US  | CN=GeoTrust Universal CA, O=GeoTrust Inc., C=US  | 1  | 3  | Thu Mar 04 07:00:00 IST 2004  | Sun Mar 04 07:00:00 IST 2029  | E6:21:F3:35:43:79:05:9A:4B:68:30:9D:8A:2F:74:22:15:87:EC:79  |
| 8  | digicertglobalrootg3 [jdk]  | CN=DigiCert Global Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Global Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US  | 55556bcf25ea43535c3a40fd5ab4572  | 3  | Thu Aug 01 15:00:00 IDT 2013  | Fri Jan 15 14:00:00 IST 2038  | 7E:04:DE:89:6A:3E:66:6D:00:E6:87:D3:3F:FA:D9:3B:E8:3D:34:9E  |
| 9  | entrustrootcaec1 [jdk]  | CN=Entrust Root Certification Authority - EC1, OU=”(c) 2012 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US  | CN=Entrust Root Certification Authority - EC1, OU=”(c) 2012 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US  | a68b79290000000050d091f9  | 3  | Tue Dec 18 17:25:36 IST 2012  | Fri Dec 18 17:55:36 IST 2037  | 20:D8:06:40:DF:9B:25:F5:12:25:3A:11:EA:F7:59:8A:EB:14:B5:47  |
| 10  | secomscrootca1 [jdk]  | OU=Security Communication RootCA1, O=SECOM Trust.net, C=JP  | OU=Security Communication RootCA1, O=SECOM Trust.net, C=JP  | 0  | 3  | Tue Sep 30 07:20:49 IDT 2003  | Sat Sep 30 07:20:49 IDT 2023  | 36:B1:2B:49:F9:81:9E:D7:4C:9E:BC:38:0F:C6:56:8F:5D:AC:B2:F7  |
| 11  | globalsignr2ca [jdk]  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R2  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R2  | 400000000010f8626e60d  | 3  | Fri Dec 15 10:00:00 IST 2006  | Wed Dec 15 10:00:00 IST 2021  | 75:E0:AB:B6:13:85:12:27:1C:04:F8:5F:DD:DE:38:E4:B7:24:2E:FE  |
| 12  | identrustdstx3 [jdk]  | CN=DST Root CA X3, O=Digital Signature Trust Co.  | CN=DST Root CA X3, O=Digital Signature Trust Co.  | 44afb080d6a327ba893039862ef8406b  | 3  | Sun Oct 01 00:12:19 IDT 2000  | Thu Sep 30 17:01:15 IDT 2021  | DA:C9:02:4F:54:D8:F6:DF:94:93:5F:B1:73:26:38:CA:6A:D7:7C:13  |
| 13  | comodoeccca [jdk]  | CN=COMODO ECC Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB  | CN=COMODO ECC Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB  | 1f47afaa62007050544c019e9b63992a  | 3  | Thu Mar 06 02:00:00 IST 2008  | Tue Jan 19 01:59:59 IST 2038  | 9F:74:4E:9F:2B:4D:BA:EC:0F:31:2C:50:B6:56:3B:8E:2D:93:C3:11  |
| 14  | entrust2048ca [jdk]  | CN=Entrust.net Certification Authority (2048), OU=(c) 1999 Entrust.net Limited, OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.), O=Entrust.net  | CN=Entrust.net Certification Authority (2048), OU=(c) 1999 Entrust.net Limited, OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.), O=Entrust.net  | 3863def8  | 3  | Fri Dec 24 19:50:51 IST 1999  | Tue Jul 24 17:15:12 IDT 2029  | 50:30:06:09:1D:97:D4:F5:AE:39:F7:CB:E7:92:7D:7D:65:2D:34:31  |
| 15  | addtrustexternalca [jdk]  | CN=AddTrust External CA Root, OU=AddTrust External TTP Network, O=AddTrust AB, C=SE  | CN=AddTrust External CA Root, OU=AddTrust External TTP Network, O=AddTrust AB, C=SE  | 1  | 3  | Tue May 30 13:48:38 IDT 2000  | Sat May 30 13:48:38 IDT 2020  | 02:FA:F3:E2:91:43:54:68:60:78:57:69:4D:F5:E4:5B:68:85:18:68  |
| 16  | globalsigneccrootcar4 [jdk]  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R4  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R4  | 2a38a41c960a04de42b228a50be8349802  | 3  | Tue Nov 13 02:00:00 IST 2012  | Tue Jan 19 05:14:07 IST 2038  | 69:69:56:2E:40:80:F4:24:A1:E7:19:9F:14:BA:F3:EE:58:AB:6A:BB  |
| 17  | usertrustrsaca [jdk]  | CN=USERTrust RSA Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US  | CN=USERTrust RSA Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US  | 1fd6d30fca3ca51a81bbc640e35032d  | 3  | Mon Feb 01 02:00:00 IST 2010  | Tue Jan 19 01:59:59 IST 2038  | 2B:8F:1B:57:33:0D:BB:A2:D0:7A:6C:51:F7:0E:E9:0D:DA:B9:AD:8E  |
| 18  | digicertassuredidrootca [jdk]  | CN=DigiCert Assured ID Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Assured ID Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US  | ce7e0e517d846fe8fe560fc1bf03039  | 3  | Fri Nov 10 02:00:00 IST 2006  | Mon Nov 10 02:00:00 IST 2031  | 05:63:B8:63:0D:62:D7:5A:BB:C8:AB:1E:4B:DF:B5:A8:99:B2:4D:43  |
| 19  | digicertglobalrootg2 [jdk]  | CN=DigiCert Global Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Global Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US  | 33af1e6a711a9a0bb2864b11d09fae5  | 3  | Thu Aug 01 15:00:00 IDT 2013  | Fri Jan 15 14:00:00 IST 2038  | DF:3C:24:F9:BF:D6:66:76:1B:26:80:73:FE:06:D1:CC:8D:4F:82:A4  |
| 20  | actalisauthenticationrootca [jdk]  | CN=Actalis Authentication Root CA, O=Actalis S.p.A./03358520967, L=Milan, C=IT  | CN=Actalis Authentication Root CA, O=Actalis S.p.A./03358520967, L=Milan, C=IT  | 570a119742c4e3cc  | 3  | Thu Sep 22 14:22:02 IDT 2011  | Sun Sep 22 14:22:02 IDT 2030  | F3:73:B3:87:06:5A:28:84:8A:F2:F3:4A:CE:19:2B:DD:C7:8E:9C:AC  |
| 21  | digicertassuredidg2 [jdk]  | CN=DigiCert Assured ID Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Assured ID Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US  | b931c3ad63967ea6723bfc3af9af44b  | 3  | Thu Aug 01 15:00:00 IDT 2013  | Fri Jan 15 14:00:00 IST 2038  | A1:4B:48:D9:43:EE:0A:0E:40:90:4F:3C:E0:A4:C0:91:93:51:5D:3F  |
| 22  | swisssigngoldg2ca [jdk]  | CN=SwissSign Gold CA - G2, O=SwissSign AG, C=CH  | CN=SwissSign Gold CA - G2, O=SwissSign AG, C=CH  | bb401c43f55e4fb0  | 3  | Wed Oct 25 10:30:35 IST 2006  | Sat Oct 25 11:30:35 IDT 2036  | D8:C5:38:8A:B7:30:1B:1B:6E:D4:7A:E6:45:25:3A:6F:9F:1A:27:61  |
| 23  | entrustrootcag2 [jdk]  | CN=Entrust Root Certification Authority - G2, OU=”(c) 2009 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US  | CN=Entrust Root Certification Authority - G2, OU=”(c) 2009 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US  | 4a538c28  | 3  | Tue Jul 07 20:25:54 IDT 2009  | Sat Dec 07 19:55:54 IST 2030  | 8C:F4:27:FD:79:0C:3A:D1:66:06:8D:E8:1E:57:EF:BB:93:22:72:D4  |
| 24  | quovadisrootca2g3 [jdk]  | CN=QuoVadis Root CA 2 G3, O=QuoVadis Limited, C=BM  | CN=QuoVadis Root CA 2 G3, O=QuoVadis Limited, C=BM  | 445734245b81899b35f2ceb82b3b5ba726f07528  | 3  | Thu Jan 12 20:59:32 IST 2012  | Sun Jan 12 20:59:32 IST 2042  | 09:3C:61:F3:8B:8B:DC:7D:55:DF:75:38:02:05:00:E1:25:F5:C8:36  |
| 25  | securetrustca [jdk]  | CN=SecureTrust CA, O=SecureTrust Corporation, C=US  | CN=SecureTrust CA, O=SecureTrust Corporation, C=US  | cf08e5c0816a5ad427ff0eb271859d0  | 3  | Tue Nov 07 21:31:18 IST 2006  | Mon Dec 31 21:40:55 IST 2029  | 87:82:C6:C3:04:35:3B:CF:D2:96:92:D2:59:3E:7D:44:D9:34:FF:11  |
| 26  | camerfirmachambersca [jdk]  | CN=Chambers of Commerce Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU  | CN=Chambers of Commerce Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU  | a3da427ea4b1aeda  | 3  | Fri Aug 01 15:29:50 IDT 2008  | Sat Jul 31 15:29:50 IDT 2038  | 78:6A:74:AC:76:AB:14:7F:9C:6A:30:50:BA:9E:A8:7E:FE:9A:CE:3C  |
| 27  | geotrustprimaryca [jdk]  | CN=GeoTrust Primary Certification Authority, O=GeoTrust Inc., C=US  | CN=GeoTrust Primary Certification Authority, O=GeoTrust Inc., C=US  | 18acb56afd69b6153a636cafdafac4a1  | 3  | Mon Nov 27 02:00:00 IST 2006  | Thu Jul 17 02:59:59 IDT 2036  | 32:3C:11:8E:1B:F7:B8:B6:52:54:E2:E2:10:0D:D6:02:90:37:F0:96  |
| 28  | identrustcommercial [jdk]  | CN=IdenTrust Commercial Root CA 1, O=IdenTrust, C=US  | CN=IdenTrust Commercial Root CA 1, O=IdenTrust, C=US  | a0142800000014523c844b500000002  | 3  | Thu Jan 16 20:12:23 IST 2014  | Mon Jan 16 20:12:23 IST 2034  | DF:71:7E:AA:4A:D9:4E:C9:55:84:99:60:2D:48:DE:5F:BC:F0:3A:25  |
| 29  | thawteprimaryrootcag3 [jdk]  | CN=thawte Primary Root CA - G3, OU=”(c) 2008 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US  | CN=thawte Primary Root CA - G3, OU=”(c) 2008 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US  | 600197b746a7eab4b49ad64b2ff790fb  | 3  | Wed Apr 02 03:00:00 IDT 2008  | Wed Dec 02 01:59:59 IST 2037  | F1:8B:53:8D:1B:E9:03:B6:A6:F0:56:43:5B:17:15:89:CA:F3:6B:F2  |
| 30  | buypassclass3ca [jdk]  | CN=Buypass Class 3 Root CA, O=Buypass AS-983163327, C=NO  | CN=Buypass Class 3 Root CA, O=Buypass AS-983163327, C=NO  | 2  | 3  | Tue Oct 26 10:28:58 IST 2010  | Fri Oct 26 11:28:58 IDT 2040  | DA:FA:F7:FA:66:84:EC:06:8F:14:50:BD:C7:C2:81:A5:BC:A9:64:57  |
| 31  | verisigntsaca [jdk]  | CN=Thawte Timestamping CA, OU=Thawte Certification, O=Thawte, L=Durbanville, ST=Western Cape, C=ZA  | CN=Thawte Timestamping CA, OU=Thawte Certification, O=Thawte, L=Durbanville, ST=Western Cape, C=ZA  | 67c8e1e8e3be1cbdfc913b8ea6238749  | 3  | Wed Jan 01 02:00:00 IST 1997  | Sat Jan 02 01:59:59 IST 2021  | 20:CE:B1:F0:F5:1C:0E:19:A9:F3:8D:B1:AA:8E:03:8C:AA:7A:C7:01  |
| 32  | verisignclass3g4ca [jdk]  | CN=VeriSign Class 3 Public Primary Certification Authority - G4, OU=”(c) 2007 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | CN=VeriSign Class 3 Public Primary Certification Authority - G4, OU=”(c) 2007 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | 2f80fe238c0e220f486712289187acb3  | 3  | Mon Nov 05 02:00:00 IST 2007  | Tue Jan 19 01:59:59 IST 2038  | 22:D5:D8:DF:8F:02:31:D1:8D:F7:9D:B7:CF:8A:2D:64:C9:3F:6C:3A  |
| 33  | baltimorecybertrustca [jdk]  | CN=Baltimore CyberTrust Root, OU=CyberTrust, O=Baltimore, C=IE  | CN=Baltimore CyberTrust Root, OU=CyberTrust, O=Baltimore, C=IE  | 20000b9  | 3  | Fri May 12 21:46:00 IDT 2000  | Tue May 13 02:59:00 IDT 2025  | D4:DE:20:D0:5E:66:FC:53:FE:1A:50:88:2C:78:DB:28:52:CA:E4:74  |
| 34  | luxtrustglobalrootca [jdk]  | CN=LuxTrust Global Root, O=LuxTrust s.a., C=LU  | CN=LuxTrust Global Root, O=LuxTrust s.a., C=LU  | bb8  | 3  | Thu Mar 17 11:51:37 IST 2011  | Wed Mar 17 11:51:37 IST 2021  | C9:3C:34:EA:90:D9:13:0C:0F:03:00:4B:98:BD:8B:35:70:91:56:11  |
| 35  | verisignclass3g2ca [jdk]  | OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 3 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US  | OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 3 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US  | 7dd9fe07cfa81eb7107967fba78934c6  | 1  | Mon May 18 03:00:00 IDT 1998  | Wed Aug 02 02:59:59 IDT 2028  | 85:37:1C:A6:E5:50:14:3D:CE:28:03:47:1B:DE:3A:09:E8:F8:77:0F  |
| 36  | camerfirmachamberscommerceca [jdk]  | CN=Chambers of Commerce Root, OU=http://www.chambersign.org, O=AC Camerfirma SA CIF A82743287, C=EU  | CN=Chambers of Commerce Root, OU=http://www.chambersign.org, O=AC Camerfirma SA CIF A82743287, C=EU  | 0  | 3  | Tue Sep 30 19:13:43 IDT 2003  | Wed Sep 30 19:13:44 IDT 2037  | 6E:3A:55:A4:19:0C:19:5C:93:84:3C:C0:DB:72:2E:31:30:61:F0:B1  |
| 37  | soneraclass2ca [jdk]  | CN=Sonera Class2 CA, O=Sonera, C=FI  | CN=Sonera Class2 CA, O=Sonera, C=FI  | 1d  | 3  | Fri Apr 06 09:29:40 IST 2001  | Tue Apr 06 10:29:40 IDT 2021  | 37:F7:6D:E6:07:7C:90:C5:B1:3E:93:1A:B7:41:10:B4:F2:E4:9A:27  |
| 38  | affirmtrustnetworkingca [jdk]  | CN=AffirmTrust Networking, O=AffirmTrust, C=US  | CN=AffirmTrust Networking, O=AffirmTrust, C=US  | 7c4f04391cd4992d  | 3  | Fri Jan 29 16:08:24 IST 2010  | Tue Dec 31 16:08:24 IST 2030  | 29:36:21:02:8B:20:ED:02:F5:66:C5:32:D1:D6:ED:90:9F:45:00:2F  |
| 39  | ttelesecglobalrootclass3ca [jdk]  | CN=T-TeleSec GlobalRoot Class 3, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE  | CN=T-TeleSec GlobalRoot Class 3, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE  | 1  | 3  | Wed Oct 01 13:29:56 IDT 2008  | Sun Oct 02 02:59:59 IDT 2033  | 55:A6:72:3E:CB:F2:EC:CD:C3:23:74:70:19:9D:2A:BE:11:E3:81:D1  |
| 40  | xrampglobalca [jdk]  | CN=XRamp Global Certification Authority, O=XRamp Security Services Inc, OU=www.xrampsecurity.com, C=US  | CN=XRamp Global Certification Authority, O=XRamp Security Services Inc, OU=www.xrampsecurity.com, C=US  | 50946cec18ead59c4dd597ef758fa0ad  | 3  | Mon Nov 01 19:14:04 IST 2004  | Mon Jan 01 07:37:19 IST 2035  | B8:01:86:D1:EB:9C:86:A5:41:04:CF:30:54:F3:4C:52:B7:E5:58:C6  |
| 41  | geotrustprimarycag3 [jdk]  | CN=GeoTrust Primary Certification Authority - G3, OU=(c) 2008 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US  | CN=GeoTrust Primary Certification Authority - G3, OU=(c) 2008 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US  | 15ac6e9419b2794b41f627a9c3180f1f  | 3  | Wed Apr 02 03:00:00 IDT 2008  | Wed Dec 02 01:59:59 IST 2037  | 03:9E:ED:B8:0B:E7:A0:3C:69:53:89:3B:20:D2:D9:32:3A:4C:2A:FD  |
| 42  | camerfirmachambersignca [jdk]  | CN=Global Chambersign Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU  | CN=Global Chambersign Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU  | c9cdd3e9d57d23ce  | 3  | Fri Aug 01 15:31:40 IDT 2008  | Sat Jul 31 15:31:40 IDT 2038  | 4A:BD:EE:EC:95:0D:35:9C:89:AE:C7:52:A1:2C:5B:29:F6:D6:AA:0C  |
| 43  | thawteprimaryrootcag2 [jdk]  | CN=thawte Primary Root CA - G2, OU=”(c) 2007 thawte, Inc. - For authorized use only”, O=”thawte, Inc.”, C=US  | CN=thawte Primary Root CA - G2, OU=”(c) 2007 thawte, Inc. - For authorized use only”, O=”thawte, Inc.”, C=US  | 35fc265cd9844fc93d263d579baed756  | 3  | Mon Nov 05 02:00:00 IST 2007  | Tue Jan 19 01:59:59 IST 2038  | AA:DB:BC:22:23:8F:C4:01:A1:27:BB:38:DD:F4:1D:DB:08:9E:F0:12  |
| 44  | usertrusteccca [jdk]  | CN=USERTrust ECC Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US  | CN=USERTrust ECC Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US  | 5c8b99c55a94c5d27156decd8980cc26  | 3  | Mon Feb 01 02:00:00 IST 2010  | Tue Jan 19 01:59:59 IST 2038  | D1:CB:CA:5D:B2:D5:2A:7F:69:3B:67:4D:E5:F0:5A:1D:0C:95:7D:F0  |
| 45  | swisssignsilverg2ca [jdk]  | CN=SwissSign Silver CA - G2, O=SwissSign AG, C=CH  | CN=SwissSign Silver CA - G2, O=SwissSign AG, C=CH  | 4f1bd42f54bb2f4b  | 3  | Wed Oct 25 10:32:46 IST 2006  | Sat Oct 25 11:32:46 IDT 2036  | 9B:AA:E5:9F:56:EE:21:CB:43:5A:BE:25:93:DF:A7:F0:40:D1:1D:CB  |
| 46  | affirmtrustpremiumca [jdk]  | CN=AffirmTrust Premium, O=AffirmTrust, C=US  | CN=AffirmTrust Premium, O=AffirmTrust, C=US  | 6d8c1446b1a60aee  | 3  | Fri Jan 29 16:10:36 IST 2010  | Mon Dec 31 16:10:36 IST 2040  | D8:A6:33:2C:E0:03:6F:B1:85:F6:63:4F:7D:6A:06:65:26:32:28:27  |
| 47  | globalsignca [jdk]  | CN=GlobalSign Root CA, OU=Root CA, O=GlobalSign nv-sa, C=BE  | CN=GlobalSign Root CA, OU=Root CA, O=GlobalSign nv-sa, C=BE  | 40000000001154b5ac394  | 3  | Tue Sep 01 15:00:00 IDT 1998  | Fri Jan 28 14:00:00 IST 2028  | B1:BC:96:8B:D4:F4:9D:62:2A:A8:9A:81:F2:15:01:52:A4:1D:82:9C  |
| 48  | dtrustclass3ca2 [jdk]  | CN=D-TRUST Root Class 3 CA 2 2009, O=D-Trust GmbH, C=DE  | CN=D-TRUST Root Class 3 CA 2 2009, O=D-Trust GmbH, C=DE  | 983f3  | 3  | Thu Nov 05 10:35:58 IST 2009  | Mon Nov 05 10:35:58 IST 2029  | 58:E8:AB:B0:36:15:33:FB:80:F7:9B:1B:6D:29:D3:FF:8D:5F:00:F0  |
| 49  | affirmtrustcommercialca [jdk]  | CN=AffirmTrust Commercial, O=AffirmTrust, C=US  | CN=AffirmTrust Commercial, O=AffirmTrust, C=US  | 7777062726a9b17c  | 3  | Fri Jan 29 16:06:06 IST 2010  | Tue Dec 31 16:06:06 IST 2030  | F9:B5:B6:32:45:5F:9C:BE:EC:57:5F:80:DC:E9:6E:2C:C7:B2:78:B7  |
| 50  | thawtepremiumserverca [jdk]  | EMAILADDRESS=premium-server@thawte.com, CN=Thawte Premium Server CA, OU=Certification Services Division, O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA  | EMAILADDRESS=premium-server@thawte.com, CN=Thawte Premium Server CA, OU=Certification Services Division, O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA  | 36122296c5e338a520a1d25f4cd70954  | 3  | Thu Aug 01 03:00:00 IDT 1996  | Sat Jan 02 01:59:59 IST 2021  | E0:AB:05:94:20:72:54:93:05:60:62:02:36:70:F7:CD:2E:FC:66:66  |
| 51  | comodoaaaca [jdk]  | CN=AAA Certificate Services, O=Comodo CA Limited, L=Salford, ST=Greater Manchester, C=GB  | CN=AAA Certificate Services, O=Comodo CA Limited, L=Salford, ST=Greater Manchester, C=GB  | 1  | 3  | Thu Jan 01 02:00:00 IST 2004  | Mon Jan 01 01:59:59 IST 2029  | D1:EB:23:A4:6D:17:D6:8F:D9:25:64:C2:F1:F1:60:17:64:D8:E3:49  |
| 52  | geotrustprimarycag2 [jdk]  | CN=GeoTrust Primary Certification Authority - G2, OU=(c) 2007 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US  | CN=GeoTrust Primary Certification Authority - G2, OU=(c) 2007 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US  | 3cb2f4480a00e2feeb243b5e603ec36b  | 3  | Mon Nov 05 02:00:00 IST 2007  | Tue Jan 19 01:59:59 IST 2038  | 8D:17:84:D5:37:F3:03:7D:EC:70:FE:57:8B:51:9A:99:E6:10:D7:B0  |
| 53  | globalsignr3ca [jdk]  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R3  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R3  | 4000000000121585308a2  | 3  | Wed Mar 18 12:00:00 IST 2009  | Sun Mar 18 12:00:00 IST 2029  | D6:9B:56:11:48:F0:1C:77:C5:45:78:C1:09:26:DF:5B:85:69:76:AD  |
| 54  | quovadisrootca3 [jdk]  | CN=QuoVadis Root CA 3, O=QuoVadis Limited, C=BM  | CN=QuoVadis Root CA 3, O=QuoVadis Limited, C=BM  | 5c6  | 3  | Fri Nov 24 21:11:23 IST 2006  | Mon Nov 24 21:06:44 IST 2031  | 1F:49:14:F7:D8:74:95:1D:DD:AE:02:C0:BE:FD:3A:2D:82:75:51:85  |
| 55  | thawteprimaryrootca [jdk]  | CN=thawte Primary Root CA, OU=”(c) 2006 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US  | CN=thawte Primary Root CA, OU=”(c) 2006 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US  | 344ed55720d5edec49f42fce37db2b6d  | 3  | Fri Nov 17 02:00:00 IST 2006  | Thu Jul 17 02:59:59 IDT 2036  | 91:C6:D6:EE:3E:8A:C8:63:84:E5:48:C2:99:29:5C:75:6C:81:7B:81  |
| 56  | starfieldrootg2ca [jdk]  | CN=Starfield Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US  | CN=Starfield Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US  | 0  | 3  | Tue Sep 01 03:00:00 IDT 2009  | Fri Jan 01 01:59:59 IST 2038  | B5:1C:06:7C:EE:2B:0C:3D:F8:55:AB:2D:92:F4:FE:39:D4:E7:0F:0E  |
| 57  | starfieldclass2ca [jdk]  | OU=Starfield Class 2 Certification Authority, O=”Starfield Technologies, Inc.”, C=US  | OU=Starfield Class 2 Certification Authority, O=”Starfield Technologies, Inc.”, C=US  | 0  | 3  | Tue Jun 29 20:39:16 IDT 2004  | Thu Jun 29 20:39:16 IDT 2034  | AD:7E:1C:28:B0:64:EF:8F:60:03:40:20:14:C3:D0:E3:37:0E:B5:8A  |
| 58  | verisignclass3ca [jdk]  | OU=Class 3 Public Primary Certification Authority, O=”VeriSign, Inc.”, C=US  | OU=Class 3 Public Primary Certification Authority, O=”VeriSign, Inc.”, C=US  | 3c9131cb1ff6d01b0e9ab8d044bf12be  | 1  | Mon Jan 29 02:00:00 IST 1996  | Thu Aug 03 02:59:59 IDT 2028  | A1:DB:63:93:91:6F:17:E4:18:55:09:40:04:15:C7:02:40:B0:AE:6B  |
| 59  | affirmtrustpremiumeccca [jdk]  | CN=AffirmTrust Premium ECC, O=AffirmTrust, C=US  | CN=AffirmTrust Premium ECC, O=AffirmTrust, C=US  | 7497258ac73f7a54  | 3  | Fri Jan 29 16:20:24 IST 2010  | Mon Dec 31 16:20:24 IST 2040  | B8:23:6B:00:2F:1D:16:86:53:01:55:6C:11:A4:37:CA:EB:FF:C3:BB  |
| 60  | geotrustglobalca [jdk]  | CN=GeoTrust Global CA, O=GeoTrust Inc., C=US  | CN=GeoTrust Global CA, O=GeoTrust Inc., C=US  | 23456  | 3  | Tue May 21 07:00:00 IDT 2002  | Sat May 21 07:00:00 IDT 2022  | DE:28:F4:A4:FF:E5:B9:2F:A3:C5:03:D1:A3:49:A7:F9:96:2A:82:12  |
| 61  | godaddyclass2ca [jdk]  | OU=Go Daddy Class 2 Certification Authority, O=”The Go Daddy Group, Inc.”, C=US  | OU=Go Daddy Class 2 Certification Authority, O=”The Go Daddy Group, Inc.”, C=US  | 0  | 3  | Tue Jun 29 20:06:20 IDT 2004  | Thu Jun 29 20:06:20 IDT 2034  | 27:96:BA:E6:3F:18:01:E2:77:26:1B:A0:D7:77:70:02:8F:20:EE:E4  |
| 62  | godaddyrootg2ca [jdk]  | CN=Go Daddy Root Certificate Authority - G2, O=”GoDaddy.com, Inc.”, L=Scottsdale, ST=Arizona, C=US  | CN=Go Daddy Root Certificate Authority - G2, O=”GoDaddy.com, Inc.”, L=Scottsdale, ST=Arizona, C=US  | 0  | 3  | Tue Sep 01 03:00:00 IDT 2009  | Fri Jan 01 01:59:59 IST 2038  | 47:BE:AB:C9:22:EA:E8:0E:78:78:34:62:A7:9F:45:C2:54:FD:E6:8B  |
| 63  | verisignclass3g5ca [jdk]  | CN=VeriSign Class 3 Public Primary Certification Authority - G5, OU=”(c) 2006 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | CN=VeriSign Class 3 Public Primary Certification Authority - G5, OU=”(c) 2006 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | 18dad19e267de8bb4a2158cdcc6b3b4a  | 3  | Wed Nov 08 02:00:00 IST 2006  | Thu Jul 17 02:59:59 IDT 2036  | 4E:B6:D5:78:49:9B:1C:CF:5F:58:1E:AD:56:BE:3D:9B:67:44:A5:E5  |
| 64  | quovadisrootca2 [jdk]  | CN=QuoVadis Root CA 2, O=QuoVadis Limited, C=BM  | CN=QuoVadis Root CA 2, O=QuoVadis Limited, C=BM  | 509  | 3  | Fri Nov 24 20:27:00 IST 2006  | Mon Nov 24 20:23:33 IST 2031  | CA:3A:FB:CF:12:40:36:4B:44:B2:16:20:88:80:48:39:19:93:7C:F7  |
| 65  | certumca [jdk]  | CN=Certum CA, O=Unizeto Sp. z o.o., C=PL  | CN=Certum CA, O=Unizeto Sp. z o.o., C=PL  | 10020  | 3  | Tue Jun 11 13:46:39 IDT 2002  | Fri Jun 11 13:46:39 IDT 2027  | 62:52:DC:40:F7:11:43:A2:2F:DE:9E:F7:34:8E:06:42:51:B1:81:18  |
| 66  | swisssignplatinumg2ca [jdk]  | CN=SwissSign Platinum CA - G2, O=SwissSign AG, C=CH  | CN=SwissSign Platinum CA - G2, O=SwissSign AG, C=CH  | 4eb200670c035d4f  | 3  | Wed Oct 25 10:36:00 IST 2006  | Sat Oct 25 11:36:00 IDT 2036  | 56:E0:FA:C0:3B:8F:18:23:55:18:E5:D3:11:CA:E8:C2:43:31:AB:66  |
| 67  | chunghwaepkirootca [jdk]  | OU=ePKI Root Certification Authority, O=”Chunghwa Telecom Co., Ltd.”, C=TW  | OU=ePKI Root Certification Authority, O=”Chunghwa Telecom Co., Ltd.”, C=TW  | 15c8bd65475cafb897005ee406d2bc9d  | 3  | Mon Dec 20 04:31:27 IST 2004  | Wed Dec 20 04:31:27 IST 2034  | 67:65:0D:F1:7E:8E:7E:5B:82:40:A4:F4:56:4B:CF:E2:3D:69:C6:F0  |
| 68  | quovadisrootca3g3 [jdk]  | CN=QuoVadis Root CA 3 G3, O=QuoVadis Limited, C=BM  | CN=QuoVadis Root CA 3 G3, O=QuoVadis Limited, C=BM  | 2ef59b0228a7db7affd5a3a9eebd03a0cf126a1d  | 3  | Thu Jan 12 22:26:32 IST 2012  | Sun Jan 12 22:26:32 IST 2042  | 48:12:BD:92:3C:A8:C4:39:06:E7:30:6D:27:96:E6:A4:CF:22:2E:7D  |
| 69  | quovadisrootca [jdk]  | CN=QuoVadis Root Certification Authority, OU=Root Certification Authority, O=QuoVadis Limited, C=BM  | CN=QuoVadis Root Certification Authority, OU=Root Certification Authority, O=QuoVadis Limited, C=BM  | 3ab6508b  | 3  | Mon Mar 19 20:33:33 IST 2001  | Wed Mar 17 20:33:33 IST 2021  | DE:3F:40:BD:50:93:D3:9B:6C:60:F6:DA:BC:07:62:01:00:89:76:C9  |
| 70  | digicerthighassuranceevrootca [jdk]  | CN=DigiCert High Assurance EV Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert High Assurance EV Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US  | 2ac5c266a0b409b8f0b79f2ae462577  | 3  | Fri Nov 10 02:00:00 IST 2006  | Mon Nov 10 02:00:00 IST 2031  | 5F:B7:EE:06:33:E2:59:DB:AD:0C:4C:9A:E6:D3:8F:1A:61:C7:DC:25  |
| 71  | quovadisrootca1g3 [jdk]  | CN=QuoVadis Root CA 1 G3, O=QuoVadis Limited, C=BM  | CN=QuoVadis Root CA 1 G3, O=QuoVadis Limited, C=BM  | 78585f2ead2c194be3370735341328b596d46593  | 3  | Thu Jan 12 19:27:44 IST 2012  | Sun Jan 12 19:27:44 IST 2042  | 1B:8E:EA:57:96:29:1A:C9:39:EA:B8:0A:81:1A:73:73:C0:93:79:67  |
| 72  | comodorsaca [jdk]  | CN=COMODO RSA Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB  | CN=COMODO RSA Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB  | 4caaf9cadb636fe01ff74ed85b03869d  | 3  | Tue Jan 19 02:00:00 IST 2010  | Tue Jan 19 01:59:59 IST 2038  | AF:E5:D2:44:A8:D1:19:42:30:FF:47:9F:E2:F8:97:BB:CD:7A:8C:B4  |
| 73  | buypassclass2ca [jdk]  | CN=Buypass Class 2 Root CA, O=Buypass AS-983163327, C=NO  | CN=Buypass Class 2 Root CA, O=Buypass AS-983163327, C=NO  | 2  | 3  | Tue Oct 26 10:38:03 IST 2010  | Fri Oct 26 11:38:03 IDT 2040  | 49:0A:75:74:DE:87:0A:47:FE:58:EE:F6:C7:6B:EB:C6:0B:12:40:99  |
| 74  | secomscrootca2 [jdk]  | OU=Security Communication RootCA2, O=”SECOM Trust Systems CO.,LTD.”, C=JP  | OU=Security Communication RootCA2, O=”SECOM Trust Systems CO.,LTD.”, C=JP  | 0  | 3  | Fri May 29 08:00:39 IDT 2009  | Tue May 29 08:00:39 IDT 2029  | 5F:3B:8C:F2:F8:10:B3:7D:78:B4:CE:EC:19:19:C3:73:34:B9:C7:74  |
| 75  | entrustevca [jdk]  | CN=Entrust Root Certification Authority, OU=”(c) 2006 Entrust, Inc.”, OU=www.entrust.net/CPS is incorporated by reference, O=”Entrust, Inc.”, C=US  | CN=Entrust Root Certification Authority, OU=”(c) 2006 Entrust, Inc.”, OU=www.entrust.net/CPS is incorporated by reference, O=”Entrust, Inc.”, C=US  | 456b5054  | 3  | Mon Nov 27 22:23:42 IST 2006  | Fri Nov 27 22:53:42 IST 2026  | B3:1E:B1:B7:40:E3:6C:84:02:DA:DC:37:D4:4D:F5:D4:67:49:52:F9  |
| 76  | verisignclass3g3ca [jdk]  | CN=VeriSign Class 3 Public Primary Certification Authority - G3, OU=”(c) 1999 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | CN=VeriSign Class 3 Public Primary Certification Authority - G3, OU=”(c) 1999 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | 9b7e0649a33e62b9d5ee90487129ef57  | 1  | Fri Oct 01 02:00:00 IST 1999  | Thu Jul 17 02:59:59 IDT 2036  | 13:2D:0D:45:53:4B:69:97:CD:B2:D5:C3:39:E2:55:76:60:9B:5C:C6  |
| 77  | certumtrustednetworkca [jdk]  | CN=Certum Trusted Network CA, OU=Certum Certification Authority, O=Unizeto Technologies S.A., C=PL  | CN=Certum Trusted Network CA, OU=Certum Certification Authority, O=Unizeto Technologies S.A., C=PL  | 444c0  | 3  | Wed Oct 22 14:07:37 IST 2008  | Mon Dec 31 14:07:37 IST 2029  | 07:E0:32:E0:20:B7:2C:3F:19:2F:06:28:A2:59:3A:19:A7:0F:06:9E  |
| 78  | dtrustclass3ca2ev [jdk]  | CN=D-TRUST Root Class 3 CA 2 EV 2009, O=D-Trust GmbH, C=DE  | CN=D-TRUST Root Class 3 CA 2 EV 2009, O=D-Trust GmbH, C=DE  | 983f4  | 3  | Thu Nov 05 10:50:46 IST 2009  | Mon Nov 05 10:50:46 IST 2029  | 96:C9:1B:0B:95:B4:10:98:42:FA:D0:D8:22:79:FE:60:FA:B9:16:83  |
| 79  | globalsigneccrootcar5 [jdk]  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R5  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R5  | 605949e0262ebb55f90a778a71f94ad86c  | 3  | Tue Nov 13 02:00:00 IST 2012  | Tue Jan 19 05:14:07 IST 2038  | 1F:24:C6:30:CD:A4:18:EF:20:69:FF:AD:4F:DD:5F:46:3A:1B:69:AA  |
| 80  | starfieldservicesrootg2ca [jdk]  | CN=Starfield Services Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US  | CN=Starfield Services Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US  | 0  | 3  | Tue Sep 01 03:00:00 IDT 2009  | Fri Jan 01 01:59:59 IST 2038  | 92:5A:8F:8D:2C:6D:04:E0:66:5F:59:6A:FF:22:D8:63:E8:25:6F:3F  |
| 81  | ttelesecglobalrootclass2ca [jdk]  | CN=T-TeleSec GlobalRoot Class 2, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE  | CN=T-TeleSec GlobalRoot Class 2, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE  | 1  | 3  | Wed Oct 01 13:40:14 IDT 2008  | Sun Oct 02 02:59:59 IDT 2033  | 59:0D:2D:7D:88:4F:40:2E:61:7E:A5:62:32:17:65:CF:17:D8:94:E9  |
| 82  | addtrustqualifiedca [jdk]  | CN=AddTrust Qualified CA Root, OU=AddTrust TTP Network, O=AddTrust AB, C=SE  | CN=AddTrust Qualified CA Root, OU=AddTrust TTP Network, O=AddTrust AB, C=SE  | 1  | 3  | Tue May 30 13:44:50 IDT 2000  | Sat May 30 13:44:50 IDT 2020  | 4D:23:78:EC:91:95:39:B5:00:7F:75:8F:03:3B:21:1E:C5:4D:8B:CF  |
| 83  | digicertglobalrootca [jdk]  | CN=DigiCert Global Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Global Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US  | 83be056904246b1a1756ac95991c74a  | 3  | Fri Nov 10 02:00:00 IST 2006  | Mon Nov 10 02:00:00 IST 2031  | A8:98:5D:3A:65:E5:E5:C4:B2:D7:D6:6D:40:C6:DD:2F:B1:9C:54:36  |
| 84  | amazonrootca1 [jdk]  | CN=Amazon Root CA 1, O=Amazon, C=US  | CN=Amazon Root CA 1, O=Amazon, C=US  | 66c9fcf99bf8c0a39e2f0788a43e696365bca  | 3  | Tue May 26 08:00:00 CST 2015  | Sun Jan 17 08:00:00 CST 2038  | 8D:A7:F9:65:EC:5E:FC:37:91:0F:1C:6E:59:FD:C1:CC:6A:6E:DE:16  |
| 85  | amazonrootca2 [jdk]  | CN=Amazon Root CA 2, O=Amazon, C=US  | CN=Amazon Root CA 2, O=Amazon, C=US  | 66c9fd29635869f0a0fe58678f85b26bb8a37  | 3  | Tue May 26 08:00:00 CST 2015  | Sat May 26 08:00:00 CST 2040  | 5A:8C:EF:45:D7:A6:98:59:76:7A:8C:8B:44:96:B5:78:CF:47:4B:1A  |
| 86  | amazonrootca3 [jdk]  | CN=Amazon Root CA 3, O=Amazon, C=US  | CN=Amazon Root CA 3, O=Amazon, C=US  | 66c9fd5749736663f3b0b9ad9e89e7603f24a  | 3  | Tue May 26 08:00:00 CST 2015  | Sat May 26 08:00:00 CST 2040  | 0D:44:DD:8C:3C:8C:1A:1A:58:75:64:81:E9:0F:2E:2A:FF:B3:D2:6E  |
| 87  | amazonrootca4 [jdk]  | CN=Amazon Root CA 4, O=Amazon, C=US  | CN=Amazon Root CA 4, O=Amazon, C=US  | 66c9fd7c1bb104c2943e5717b7b2cc81ac10e  | 3  | Tue May 26 08:00:00 CST 2015  | Sat May 26 08:00:00 CST 2040  | F6:10:84:07:D6:F8:BB:67:98:0C:C2:E2:44:C2:EB:AE:1C:EF:63:BE  |
| 88  | globalsignrootcar6 [jdk]  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R6  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R6  | 45e6bb038333c3856548e6ff4551  | 3  | Wed Dec 10 08:00:00 CST 2014  | Sun Dec 10 08:00:00 CST 2034  | 80:94:64:0E:B5:A7:A1:CA:11:9C:1F:DD:D5:9F:81:02:63:A7:FB:D1  |
| 89  | letsencryptisrgx1 [jdk]  | CN=ISRG Root X1, O=Internet Security Research Group, C=US  | CN=ISRG Root X1, O=Internet Security Research Group, C=US  | 8210cfb0d240e3594463e0bb63828b00  | 3  | Thu Jun 04 19:04:38 CST 2015  | Mon Jun 04 19:04:38 CST 2035  | CA:BD:2A:79:A1:07:6A:31:F2:1D:25:36:35:CB:03:9D:43:29:A5:E8  |
| 90  | luxtrustglobalroot2ca [jdk]  | CN=LuxTrust Global Root 2, O=LuxTrust S.A., C=LU  | CN=LuxTrust Global Root 2, O=LuxTrust S.A., C=LU  | a7ea6df4b449eda6a24859ee6b815d3167fbbb1  | 3  | Thu Mar 05 21:21:57 CST 2015  | Mon Mar 05 21:21:57 CST 2035  | 1E:0E:56:19:0A:D1:8B:25:98:B2:04:44:FF:66:8A:04:17:99:5F:3F  |
| 91  | teliasonerarootcav1 [jdk]  | CN=TeliaSonera Root CA v1, O=TeliaSonera  | CN=TeliaSonera Root CA v1, O=TeliaSonera  | 95be16a0f72e46f17b398272fa8bcd96  | 3  | Thu Oct 18 20:00:50 CST 2007  | Mon Oct 18 20:00:50 CST 2032  | 43:13:BB:96:F1:D5:86:9B:C1:4E:6A:92:F6:CF:F6:34:69:87:82:37  |
| 92  | TWCA Root Certification Authority  | CN=TWCA Root Certification Authority, OU=Root CA, O=TAIWAN-CA, C=TW  | CN=TWCA Root Certification Authority, OU=Root CA, O=TAIWAN-CA, C=TW  | 01  | 3  | Thu Aug 28 15:24:33 CST 2008  | Tue Dec 31 23:59:59 CST 2030  | CF:9E:87:6D:D3:EB:FC:42:26:97:A3:B5:A3:7A:A0:76:A9:06:23:48  |

#


Alias name


Subject DN


Issuer DN


Certificate Serial Number


Version


Valid From [GMT]


Valid To [GMT]


Thumbprint(SHA1)


1


verisignclass2g2ca [jdk]


OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 2 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US


OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 2 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US


b92f60cc889fa17a4609b85b706c8aaf


1


Mon May 18 03:00:00 IDT 1998


Wed Aug 02 02:59:59 IDT 2028


B3:EA:C4:47:76:C9:C8:1C:EA:F2:9D:95:B6:CC:A0:08:1B:67:EC:9D


2


digicertassuredidg3 [jdk]


CN=DigiCert Assured ID Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Assured ID Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US


ba15afa1ddfa0b54944afcd24a06cec


3


Thu Aug 01 15:00:00 IDT 2013


Fri Jan 15 14:00:00 IST 2038


F5:17:A2:4F:9A:48:C6:C9:F8:A2:00:26:9F:DC:0F:48:2C:AB:30:89


3


verisignuniversalrootca [jdk]


CN=VeriSign Universal Root Certification Authority, OU=”(c) 2008 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


CN=VeriSign Universal Root Certification Authority, OU=”(c) 2008 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


401ac46421b31321030ebbe4121ac51d


3


Wed Apr 02 03:00:00 IDT 2008


Wed Dec 02 01:59:59 IST 2037


36:79:CA:35:66:87:72:30:4D:30:A5:FB:87:3B:0F:A7:7B:B7:0D:54


4


digicerttrustedrootg4 [jdk]


CN=DigiCert Trusted Root G4, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Trusted Root G4, OU=www.digicert.com, O=DigiCert Inc, C=US


59b1b579e8e2132e23907bda777755c


3


Thu Aug 01 15:00:00 IDT 2013


Fri Jan 15 14:00:00 IST 2038


DD:FB:16:CD:49:31:C9:73:A2:03:7D:3F:C8:3A:4D:7D:77:5D:05:E4


5


identrustpublicca [jdk]


CN=IdenTrust Public Sector Root CA 1, O=IdenTrust, C=US


CN=IdenTrust Public Sector Root CA 1, O=IdenTrust, C=US


a0142800000014523cf467c00000002


3


Thu Jan 16 19:53:32 IST 2014


Mon Jan 16 19:53:32 IST 2034


BA:29:41:60:77:98:3F:F4:F3:EF:F2:31:05:3B:2E:EA:6D:4D:45:FD


6


utnuserfirstobjectca [jdk]


CN=UTN-USERFirst-Object, OU=http://www.usertrust.com, O=The USERTRUST Network, L=Salt Lake City, ST=UT, C=US


CN=UTN-USERFirst-Object, OU=http://www.usertrust.com, O=The USERTRUST Network, L=Salt Lake City, ST=UT, C=US


44be0c8b500024b411d3362de0b35f1b


3


Fri Jul 09 21:31:20 IDT 1999


Tue Jul 09 21:40:36 IDT 2019


E1:2D:FB:4B:41:D7:D9:C3:2B:30:51:4B:AC:1D:81:D8:38:5E:2D:46


7


geotrustuniversalca [jdk]


CN=GeoTrust Universal CA, O=GeoTrust Inc., C=US


CN=GeoTrust Universal CA, O=GeoTrust Inc., C=US


1


3


Thu Mar 04 07:00:00 IST 2004


Sun Mar 04 07:00:00 IST 2029


E6:21:F3:35:43:79:05:9A:4B:68:30:9D:8A:2F:74:22:15:87:EC:79


8


digicertglobalrootg3 [jdk]


CN=DigiCert Global Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Global Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US


55556bcf25ea43535c3a40fd5ab4572


3


Thu Aug 01 15:00:00 IDT 2013


Fri Jan 15 14:00:00 IST 2038


7E:04:DE:89:6A:3E:66:6D:00:E6:87:D3:3F:FA:D9:3B:E8:3D:34:9E


9


entrustrootcaec1 [jdk]


CN=Entrust Root Certification Authority - EC1, OU=”(c) 2012 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US


CN=Entrust Root Certification Authority - EC1, OU=”(c) 2012 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US


a68b79290000000050d091f9


3


Tue Dec 18 17:25:36 IST 2012


Fri Dec 18 17:55:36 IST 2037


20:D8:06:40:DF:9B:25:F5:12:25:3A:11:EA:F7:59:8A:EB:14:B5:47


10


secomscrootca1 [jdk]


OU=Security Communication RootCA1, O=SECOM Trust.net, C=JP


OU=Security Communication RootCA1, O=SECOM Trust.net, C=JP


0


3


Tue Sep 30 07:20:49 IDT 2003


Sat Sep 30 07:20:49 IDT 2023


36:B1:2B:49:F9:81:9E:D7:4C:9E:BC:38:0F:C6:56:8F:5D:AC:B2:F7


11


globalsignr2ca [jdk]


CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R2


CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R2


400000000010f8626e60d


3


Fri Dec 15 10:00:00 IST 2006


Wed Dec 15 10:00:00 IST 2021


75:E0:AB:B6:13:85:12:27:1C:04:F8:5F:DD:DE:38:E4:B7:24:2E:FE


12


identrustdstx3 [jdk]


CN=DST Root CA X3, O=Digital Signature Trust Co.


CN=DST Root CA X3, O=Digital Signature Trust Co.


44afb080d6a327ba893039862ef8406b


3


Sun Oct 01 00:12:19 IDT 2000


Thu Sep 30 17:01:15 IDT 2021


DA:C9:02:4F:54:D8:F6:DF:94:93:5F:B1:73:26:38:CA:6A:D7:7C:13


13


comodoeccca [jdk]


CN=COMODO ECC Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB


CN=COMODO ECC Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB


1f47afaa62007050544c019e9b63992a


3


Thu Mar 06 02:00:00 IST 2008


Tue Jan 19 01:59:59 IST 2038


9F:74:4E:9F:2B:4D:BA:EC:0F:31:2C:50:B6:56:3B:8E:2D:93:C3:11


14


entrust2048ca [jdk]


CN=Entrust.net Certification Authority (2048), OU=(c) 1999 Entrust.net Limited, OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.), O=Entrust.net


CN=Entrust.net Certification Authority (2048), OU=(c) 1999 Entrust.net Limited, OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.), O=Entrust.net


3863def8


3


Fri Dec 24 19:50:51 IST 1999


Tue Jul 24 17:15:12 IDT 2029


50:30:06:09:1D:97:D4:F5:AE:39:F7:CB:E7:92:7D:7D:65:2D:34:31


15


addtrustexternalca [jdk]


CN=AddTrust External CA Root, OU=AddTrust External TTP Network, O=AddTrust AB, C=SE


CN=AddTrust External CA Root, OU=AddTrust External TTP Network, O=AddTrust AB, C=SE


1


3


Tue May 30 13:48:38 IDT 2000


Sat May 30 13:48:38 IDT 2020


02:FA:F3:E2:91:43:54:68:60:78:57:69:4D:F5:E4:5B:68:85:18:68


16


globalsigneccrootcar4 [jdk]


CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R4


CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R4


2a38a41c960a04de42b228a50be8349802


3


Tue Nov 13 02:00:00 IST 2012


Tue Jan 19 05:14:07 IST 2038


69:69:56:2E:40:80:F4:24:A1:E7:19:9F:14:BA:F3:EE:58:AB:6A:BB


17


usertrustrsaca [jdk]


CN=USERTrust RSA Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US


CN=USERTrust RSA Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US


1fd6d30fca3ca51a81bbc640e35032d


3


Mon Feb 01 02:00:00 IST 2010


Tue Jan 19 01:59:59 IST 2038


2B:8F:1B:57:33:0D:BB:A2:D0:7A:6C:51:F7:0E:E9:0D:DA:B9:AD:8E


18


digicertassuredidrootca [jdk]


CN=DigiCert Assured ID Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Assured ID Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US


ce7e0e517d846fe8fe560fc1bf03039


3


Fri Nov 10 02:00:00 IST 2006


Mon Nov 10 02:00:00 IST 2031


05:63:B8:63:0D:62:D7:5A:BB:C8:AB:1E:4B:DF:B5:A8:99:B2:4D:43


19


digicertglobalrootg2 [jdk]


CN=DigiCert Global Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Global Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US


33af1e6a711a9a0bb2864b11d09fae5


3


Thu Aug 01 15:00:00 IDT 2013


Fri Jan 15 14:00:00 IST 2038


DF:3C:24:F9:BF:D6:66:76:1B:26:80:73:FE:06:D1:CC:8D:4F:82:A4


20


actalisauthenticationrootca [jdk]


CN=Actalis Authentication Root CA, O=Actalis S.p.A./03358520967, L=Milan, C=IT


CN=Actalis Authentication Root CA, O=Actalis S.p.A./03358520967, L=Milan, C=IT


570a119742c4e3cc


3


Thu Sep 22 14:22:02 IDT 2011


Sun Sep 22 14:22:02 IDT 2030


F3:73:B3:87:06:5A:28:84:8A:F2:F3:4A:CE:19:2B:DD:C7:8E:9C:AC


21


digicertassuredidg2 [jdk]


CN=DigiCert Assured ID Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Assured ID Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US


b931c3ad63967ea6723bfc3af9af44b


3


Thu Aug 01 15:00:00 IDT 2013


Fri Jan 15 14:00:00 IST 2038


A1:4B:48:D9:43:EE:0A:0E:40:90:4F:3C:E0:A4:C0:91:93:51:5D:3F


22


swisssigngoldg2ca [jdk]


CN=SwissSign Gold CA - G2, O=SwissSign AG, C=CH


CN=SwissSign Gold CA - G2, O=SwissSign AG, C=CH


bb401c43f55e4fb0


3


Wed Oct 25 10:30:35 IST 2006


Sat Oct 25 11:30:35 IDT 2036


D8:C5:38:8A:B7:30:1B:1B:6E:D4:7A:E6:45:25:3A:6F:9F:1A:27:61


23


entrustrootcag2 [jdk]


CN=Entrust Root Certification Authority - G2, OU=”(c) 2009 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US


CN=Entrust Root Certification Authority - G2, OU=”(c) 2009 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US


4a538c28


3


Tue Jul 07 20:25:54 IDT 2009


Sat Dec 07 19:55:54 IST 2030


8C:F4:27:FD:79:0C:3A:D1:66:06:8D:E8:1E:57:EF:BB:93:22:72:D4


24


quovadisrootca2g3 [jdk]


CN=QuoVadis Root CA 2 G3, O=QuoVadis Limited, C=BM


CN=QuoVadis Root CA 2 G3, O=QuoVadis Limited, C=BM


445734245b81899b35f2ceb82b3b5ba726f07528


3


Thu Jan 12 20:59:32 IST 2012


Sun Jan 12 20:59:32 IST 2042


09:3C:61:F3:8B:8B:DC:7D:55:DF:75:38:02:05:00:E1:25:F5:C8:36


25


securetrustca [jdk]


CN=SecureTrust CA, O=SecureTrust Corporation, C=US


CN=SecureTrust CA, O=SecureTrust Corporation, C=US


cf08e5c0816a5ad427ff0eb271859d0


3


Tue Nov 07 21:31:18 IST 2006


Mon Dec 31 21:40:55 IST 2029


87:82:C6:C3:04:35:3B:CF:D2:96:92:D2:59:3E:7D:44:D9:34:FF:11


26


camerfirmachambersca [jdk]


CN=Chambers of Commerce Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU


CN=Chambers of Commerce Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU


a3da427ea4b1aeda


3


Fri Aug 01 15:29:50 IDT 2008


Sat Jul 31 15:29:50 IDT 2038


78:6A:74:AC:76:AB:14:7F:9C:6A:30:50:BA:9E:A8:7E:FE:9A:CE:3C


27


geotrustprimaryca [jdk]


CN=GeoTrust Primary Certification Authority, O=GeoTrust Inc., C=US


CN=GeoTrust Primary Certification Authority, O=GeoTrust Inc., C=US


18acb56afd69b6153a636cafdafac4a1


3


Mon Nov 27 02:00:00 IST 2006


Thu Jul 17 02:59:59 IDT 2036


32:3C:11:8E:1B:F7:B8:B6:52:54:E2:E2:10:0D:D6:02:90:37:F0:96


28


identrustcommercial [jdk]


CN=IdenTrust Commercial Root CA 1, O=IdenTrust, C=US


CN=IdenTrust Commercial Root CA 1, O=IdenTrust, C=US


a0142800000014523c844b500000002


3


Thu Jan 16 20:12:23 IST 2014


Mon Jan 16 20:12:23 IST 2034


DF:71:7E:AA:4A:D9:4E:C9:55:84:99:60:2D:48:DE:5F:BC:F0:3A:25


29


thawteprimaryrootcag3 [jdk]


CN=thawte Primary Root CA - G3, OU=”(c) 2008 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US


CN=thawte Primary Root CA - G3, OU=”(c) 2008 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US


600197b746a7eab4b49ad64b2ff790fb


3


Wed Apr 02 03:00:00 IDT 2008


Wed Dec 02 01:59:59 IST 2037


F1:8B:53:8D:1B:E9:03:B6:A6:F0:56:43:5B:17:15:89:CA:F3:6B:F2


30


buypassclass3ca [jdk]


CN=Buypass Class 3 Root CA, O=Buypass AS-983163327, C=NO


CN=Buypass Class 3 Root CA, O=Buypass AS-983163327, C=NO


2


3


Tue Oct 26 10:28:58 IST 2010


Fri Oct 26 11:28:58 IDT 2040


DA:FA:F7:FA:66:84:EC:06:8F:14:50:BD:C7:C2:81:A5:BC:A9:64:57


31


verisigntsaca [jdk]


CN=Thawte Timestamping CA, OU=Thawte Certification, O=Thawte, L=Durbanville, ST=Western Cape, C=ZA


CN=Thawte Timestamping CA, OU=Thawte Certification, O=Thawte, L=Durbanville, ST=Western Cape, C=ZA


67c8e1e8e3be1cbdfc913b8ea6238749


3


Wed Jan 01 02:00:00 IST 1997


Sat Jan 02 01:59:59 IST 2021


20:CE:B1:F0:F5:1C:0E:19:A9:F3:8D:B1:AA:8E:03:8C:AA:7A:C7:01


32


verisignclass3g4ca [jdk]


CN=VeriSign Class 3 Public Primary Certification Authority - G4, OU=”(c) 2007 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


CN=VeriSign Class 3 Public Primary Certification Authority - G4, OU=”(c) 2007 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


2f80fe238c0e220f486712289187acb3


3


Mon Nov 05 02:00:00 IST 2007


Tue Jan 19 01:59:59 IST 2038


22:D5:D8:DF:8F:02:31:D1:8D:F7:9D:B7:CF:8A:2D:64:C9:3F:6C:3A


33


baltimorecybertrustca [jdk]


CN=Baltimore CyberTrust Root, OU=CyberTrust, O=Baltimore, C=IE


CN=Baltimore CyberTrust Root, OU=CyberTrust, O=Baltimore, C=IE


20000b9


3


Fri May 12 21:46:00 IDT 2000


Tue May 13 02:59:00 IDT 2025


D4:DE:20:D0:5E:66:FC:53:FE:1A:50:88:2C:78:DB:28:52:CA:E4:74


34


luxtrustglobalrootca [jdk]


CN=LuxTrust Global Root, O=LuxTrust s.a., C=LU


CN=LuxTrust Global Root, O=LuxTrust s.a., C=LU


bb8


3


Thu Mar 17 11:51:37 IST 2011


Wed Mar 17 11:51:37 IST 2021


C9:3C:34:EA:90:D9:13:0C:0F:03:00:4B:98:BD:8B:35:70:91:56:11


35


verisignclass3g2ca [jdk]


OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 3 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US


OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 3 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US


7dd9fe07cfa81eb7107967fba78934c6


1


Mon May 18 03:00:00 IDT 1998


Wed Aug 02 02:59:59 IDT 2028


85:37:1C:A6:E5:50:14:3D:CE:28:03:47:1B:DE:3A:09:E8:F8:77:0F


36


camerfirmachamberscommerceca [jdk]


CN=Chambers of Commerce Root, OU=http://www.chambersign.org, O=AC Camerfirma SA CIF A82743287, C=EU


CN=Chambers of Commerce Root, OU=http://www.chambersign.org, O=AC Camerfirma SA CIF A82743287, C=EU


0


3


Tue Sep 30 19:13:43 IDT 2003


Wed Sep 30 19:13:44 IDT 2037


6E:3A:55:A4:19:0C:19:5C:93:84:3C:C0:DB:72:2E:31:30:61:F0:B1


37


soneraclass2ca [jdk]


CN=Sonera Class2 CA, O=Sonera, C=FI


CN=Sonera Class2 CA, O=Sonera, C=FI


1d


3


Fri Apr 06 09:29:40 IST 2001


Tue Apr 06 10:29:40 IDT 2021


37:F7:6D:E6:07:7C:90:C5:B1:3E:93:1A:B7:41:10:B4:F2:E4:9A:27


38


affirmtrustnetworkingca [jdk]


CN=AffirmTrust Networking, O=AffirmTrust, C=US


CN=AffirmTrust Networking, O=AffirmTrust, C=US


7c4f04391cd4992d


3


Fri Jan 29 16:08:24 IST 2010


Tue Dec 31 16:08:24 IST 2030


29:36:21:02:8B:20:ED:02:F5:66:C5:32:D1:D6:ED:90:9F:45:00:2F


39


ttelesecglobalrootclass3ca [jdk]


CN=T-TeleSec GlobalRoot Class 3, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE


CN=T-TeleSec GlobalRoot Class 3, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE


1


3


Wed Oct 01 13:29:56 IDT 2008


Sun Oct 02 02:59:59 IDT 2033


55:A6:72:3E:CB:F2:EC:CD:C3:23:74:70:19:9D:2A:BE:11:E3:81:D1


40


xrampglobalca [jdk]


CN=XRamp Global Certification Authority, O=XRamp Security Services Inc, OU=www.xrampsecurity.com, C=US


CN=XRamp Global Certification Authority, O=XRamp Security Services Inc, OU=www.xrampsecurity.com, C=US


50946cec18ead59c4dd597ef758fa0ad


3


Mon Nov 01 19:14:04 IST 2004


Mon Jan 01 07:37:19 IST 2035


B8:01:86:D1:EB:9C:86:A5:41:04:CF:30:54:F3:4C:52:B7:E5:58:C6


41


geotrustprimarycag3 [jdk]


CN=GeoTrust Primary Certification Authority - G3, OU=(c) 2008 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US


CN=GeoTrust Primary Certification Authority - G3, OU=(c) 2008 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US


15ac6e9419b2794b41f627a9c3180f1f


3


Wed Apr 02 03:00:00 IDT 2008


Wed Dec 02 01:59:59 IST 2037


03:9E:ED:B8:0B:E7:A0:3C:69:53:89:3B:20:D2:D9:32:3A:4C:2A:FD


42


camerfirmachambersignca [jdk]


CN=Global Chambersign Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU


CN=Global Chambersign Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU


c9cdd3e9d57d23ce


3


Fri Aug 01 15:31:40 IDT 2008


Sat Jul 31 15:31:40 IDT 2038


4A:BD:EE:EC:95:0D:35:9C:89:AE:C7:52:A1:2C:5B:29:F6:D6:AA:0C


43


thawteprimaryrootcag2 [jdk]


CN=thawte Primary Root CA - G2, OU=”(c) 2007 thawte, Inc. - For authorized use only”, O=”thawte, Inc.”, C=US


CN=thawte Primary Root CA - G2, OU=”(c) 2007 thawte, Inc. - For authorized use only”, O=”thawte, Inc.”, C=US


35fc265cd9844fc93d263d579baed756


3


Mon Nov 05 02:00:00 IST 2007


Tue Jan 19 01:59:59 IST 2038


AA:DB:BC:22:23:8F:C4:01:A1:27:BB:38:DD:F4:1D:DB:08:9E:F0:12


44


usertrusteccca [jdk]


CN=USERTrust ECC Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US


CN=USERTrust ECC Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US


5c8b99c55a94c5d27156decd8980cc26


3


Mon Feb 01 02:00:00 IST 2010


Tue Jan 19 01:59:59 IST 2038


D1:CB:CA:5D:B2:D5:2A:7F:69:3B:67:4D:E5:F0:5A:1D:0C:95:7D:F0


45


swisssignsilverg2ca [jdk]


CN=SwissSign Silver CA - G2, O=SwissSign AG, C=CH


CN=SwissSign Silver CA - G2, O=SwissSign AG, C=CH


4f1bd42f54bb2f4b


3


Wed Oct 25 10:32:46 IST 2006


Sat Oct 25 11:32:46 IDT 2036


9B:AA:E5:9F:56:EE:21:CB:43:5A:BE:25:93:DF:A7:F0:40:D1:1D:CB


46


affirmtrustpremiumca [jdk]


CN=AffirmTrust Premium, O=AffirmTrust, C=US


CN=AffirmTrust Premium, O=AffirmTrust, C=US


6d8c1446b1a60aee


3


Fri Jan 29 16:10:36 IST 2010


Mon Dec 31 16:10:36 IST 2040


D8:A6:33:2C:E0:03:6F:B1:85:F6:63:4F:7D:6A:06:65:26:32:28:27


47


globalsignca [jdk]


CN=GlobalSign Root CA, OU=Root CA, O=GlobalSign nv-sa, C=BE


CN=GlobalSign Root CA, OU=Root CA, O=GlobalSign nv-sa, C=BE


40000000001154b5ac394


3


Tue Sep 01 15:00:00 IDT 1998


Fri Jan 28 14:00:00 IST 2028


B1:BC:96:8B:D4:F4:9D:62:2A:A8:9A:81:F2:15:01:52:A4:1D:82:9C


48


dtrustclass3ca2 [jdk]


CN=D-TRUST Root Class 3 CA 2 2009, O=D-Trust GmbH, C=DE


CN=D-TRUST Root Class 3 CA 2 2009, O=D-Trust GmbH, C=DE


983f3


3


Thu Nov 05 10:35:58 IST 2009


Mon Nov 05 10:35:58 IST 2029


58:E8:AB:B0:36:15:33:FB:80:F7:9B:1B:6D:29:D3:FF:8D:5F:00:F0


49


affirmtrustcommercialca [jdk]


CN=AffirmTrust Commercial, O=AffirmTrust, C=US


CN=AffirmTrust Commercial, O=AffirmTrust, C=US


7777062726a9b17c


3


Fri Jan 29 16:06:06 IST 2010


Tue Dec 31 16:06:06 IST 2030


F9:B5:B6:32:45:5F:9C:BE:EC:57:5F:80:DC:E9:6E:2C:C7:B2:78:B7


50


thawtepremiumserverca [jdk]


EMAILADDRESS=premium-server@thawte.com, CN=Thawte Premium Server CA, OU=Certification Services Division, O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA


EMAILADDRESS=premium-server@thawte.com, CN=Thawte Premium Server CA, OU=Certification Services Division, O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA


36122296c5e338a520a1d25f4cd70954


3


Thu Aug 01 03:00:00 IDT 1996


Sat Jan 02 01:59:59 IST 2021


E0:AB:05:94:20:72:54:93:05:60:62:02:36:70:F7:CD:2E:FC:66:66


51


comodoaaaca [jdk]


CN=AAA Certificate Services, O=Comodo CA Limited, L=Salford, ST=Greater Manchester, C=GB


CN=AAA Certificate Services, O=Comodo CA Limited, L=Salford, ST=Greater Manchester, C=GB


1


3


Thu Jan 01 02:00:00 IST 2004


Mon Jan 01 01:59:59 IST 2029


D1:EB:23:A4:6D:17:D6:8F:D9:25:64:C2:F1:F1:60:17:64:D8:E3:49


52


geotrustprimarycag2 [jdk]


CN=GeoTrust Primary Certification Authority - G2, OU=(c) 2007 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US


CN=GeoTrust Primary Certification Authority - G2, OU=(c) 2007 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US


3cb2f4480a00e2feeb243b5e603ec36b


3


Mon Nov 05 02:00:00 IST 2007


Tue Jan 19 01:59:59 IST 2038


8D:17:84:D5:37:F3:03:7D:EC:70:FE:57:8B:51:9A:99:E6:10:D7:B0


53


globalsignr3ca [jdk]


CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R3


CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R3


4000000000121585308a2


3


Wed Mar 18 12:00:00 IST 2009


Sun Mar 18 12:00:00 IST 2029


D6:9B:56:11:48:F0:1C:77:C5:45:78:C1:09:26:DF:5B:85:69:76:AD


54


quovadisrootca3 [jdk]


CN=QuoVadis Root CA 3, O=QuoVadis Limited, C=BM


CN=QuoVadis Root CA 3, O=QuoVadis Limited, C=BM


5c6


3


Fri Nov 24 21:11:23 IST 2006


Mon Nov 24 21:06:44 IST 2031


1F:49:14:F7:D8:74:95:1D:DD:AE:02:C0:BE:FD:3A:2D:82:75:51:85


55


thawteprimaryrootca [jdk]


CN=thawte Primary Root CA, OU=”(c) 2006 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US


CN=thawte Primary Root CA, OU=”(c) 2006 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US


344ed55720d5edec49f42fce37db2b6d


3


Fri Nov 17 02:00:00 IST 2006


Thu Jul 17 02:59:59 IDT 2036


91:C6:D6:EE:3E:8A:C8:63:84:E5:48:C2:99:29:5C:75:6C:81:7B:81


56


starfieldrootg2ca [jdk]


CN=Starfield Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US


CN=Starfield Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US


0


3


Tue Sep 01 03:00:00 IDT 2009


Fri Jan 01 01:59:59 IST 2038


B5:1C:06:7C:EE:2B:0C:3D:F8:55:AB:2D:92:F4:FE:39:D4:E7:0F:0E


57


starfieldclass2ca [jdk]


OU=Starfield Class 2 Certification Authority, O=”Starfield Technologies, Inc.”, C=US


OU=Starfield Class 2 Certification Authority, O=”Starfield Technologies, Inc.”, C=US


0


3


Tue Jun 29 20:39:16 IDT 2004


Thu Jun 29 20:39:16 IDT 2034


AD:7E:1C:28:B0:64:EF:8F:60:03:40:20:14:C3:D0:E3:37:0E:B5:8A


58


verisignclass3ca [jdk]


OU=Class 3 Public Primary Certification Authority, O=”VeriSign, Inc.”, C=US


OU=Class 3 Public Primary Certification Authority, O=”VeriSign, Inc.”, C=US


3c9131cb1ff6d01b0e9ab8d044bf12be


1


Mon Jan 29 02:00:00 IST 1996


Thu Aug 03 02:59:59 IDT 2028


A1:DB:63:93:91:6F:17:E4:18:55:09:40:04:15:C7:02:40:B0:AE:6B


59


affirmtrustpremiumeccca [jdk]


CN=AffirmTrust Premium ECC, O=AffirmTrust, C=US


CN=AffirmTrust Premium ECC, O=AffirmTrust, C=US


7497258ac73f7a54


3


Fri Jan 29 16:20:24 IST 2010


Mon Dec 31 16:20:24 IST 2040


B8:23:6B:00:2F:1D:16:86:53:01:55:6C:11:A4:37:CA:EB:FF:C3:BB


60


geotrustglobalca [jdk]


CN=GeoTrust Global CA, O=GeoTrust Inc., C=US


CN=GeoTrust Global CA, O=GeoTrust Inc., C=US


23456


3


Tue May 21 07:00:00 IDT 2002


Sat May 21 07:00:00 IDT 2022


DE:28:F4:A4:FF:E5:B9:2F:A3:C5:03:D1:A3:49:A7:F9:96:2A:82:12


61


godaddyclass2ca [jdk]


OU=Go Daddy Class 2 Certification Authority, O=”The Go Daddy Group, Inc.”, C=US


OU=Go Daddy Class 2 Certification Authority, O=”The Go Daddy Group, Inc.”, C=US


0


3


Tue Jun 29 20:06:20 IDT 2004


Thu Jun 29 20:06:20 IDT 2034


27:96:BA:E6:3F:18:01:E2:77:26:1B:A0:D7:77:70:02:8F:20:EE:E4


62


godaddyrootg2ca [jdk]


CN=Go Daddy Root Certificate Authority - G2, O=”GoDaddy.com, Inc.”, L=Scottsdale, ST=Arizona, C=US


CN=Go Daddy Root Certificate Authority - G2, O=”GoDaddy.com, Inc.”, L=Scottsdale, ST=Arizona, C=US


0


3


Tue Sep 01 03:00:00 IDT 2009


Fri Jan 01 01:59:59 IST 2038


47:BE:AB:C9:22:EA:E8:0E:78:78:34:62:A7:9F:45:C2:54:FD:E6:8B


63


verisignclass3g5ca [jdk]


CN=VeriSign Class 3 Public Primary Certification Authority - G5, OU=”(c) 2006 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


CN=VeriSign Class 3 Public Primary Certification Authority - G5, OU=”(c) 2006 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


18dad19e267de8bb4a2158cdcc6b3b4a


3


Wed Nov 08 02:00:00 IST 2006


Thu Jul 17 02:59:59 IDT 2036


4E:B6:D5:78:49:9B:1C:CF:5F:58:1E:AD:56:BE:3D:9B:67:44:A5:E5


64


quovadisrootca2 [jdk]


CN=QuoVadis Root CA 2, O=QuoVadis Limited, C=BM


CN=QuoVadis Root CA 2, O=QuoVadis Limited, C=BM


509


3


Fri Nov 24 20:27:00 IST 2006


Mon Nov 24 20:23:33 IST 2031


CA:3A:FB:CF:12:40:36:4B:44:B2:16:20:88:80:48:39:19:93:7C:F7


65


certumca [jdk]


CN=Certum CA, O=Unizeto Sp. z o.o., C=PL


CN=Certum CA, O=Unizeto Sp. z o.o., C=PL


10020


3


Tue Jun 11 13:46:39 IDT 2002


Fri Jun 11 13:46:39 IDT 2027


62:52:DC:40:F7:11:43:A2:2F:DE:9E:F7:34:8E:06:42:51:B1:81:18


66


swisssignplatinumg2ca [jdk]


CN=SwissSign Platinum CA - G2, O=SwissSign AG, C=CH


CN=SwissSign Platinum CA - G2, O=SwissSign AG, C=CH


4eb200670c035d4f


3


Wed Oct 25 10:36:00 IST 2006


Sat Oct 25 11:36:00 IDT 2036


56:E0:FA:C0:3B:8F:18:23:55:18:E5:D3:11:CA:E8:C2:43:31:AB:66


67


chunghwaepkirootca [jdk]


OU=ePKI Root Certification Authority, O=”Chunghwa Telecom Co., Ltd.”, C=TW


OU=ePKI Root Certification Authority, O=”Chunghwa Telecom Co., Ltd.”, C=TW


15c8bd65475cafb897005ee406d2bc9d


3


Mon Dec 20 04:31:27 IST 2004


Wed Dec 20 04:31:27 IST 2034


67:65:0D:F1:7E:8E:7E:5B:82:40:A4:F4:56:4B:CF:E2:3D:69:C6:F0


68


quovadisrootca3g3 [jdk]


CN=QuoVadis Root CA 3 G3, O=QuoVadis Limited, C=BM


CN=QuoVadis Root CA 3 G3, O=QuoVadis Limited, C=BM


2ef59b0228a7db7affd5a3a9eebd03a0cf126a1d


3


Thu Jan 12 22:26:32 IST 2012


Sun Jan 12 22:26:32 IST 2042


48:12:BD:92:3C:A8:C4:39:06:E7:30:6D:27:96:E6:A4:CF:22:2E:7D


69


quovadisrootca [jdk]


CN=QuoVadis Root Certification Authority, OU=Root Certification Authority, O=QuoVadis Limited, C=BM


CN=QuoVadis Root Certification Authority, OU=Root Certification Authority, O=QuoVadis Limited, C=BM


3ab6508b


3


Mon Mar 19 20:33:33 IST 2001


Wed Mar 17 20:33:33 IST 2021


DE:3F:40:BD:50:93:D3:9B:6C:60:F6:DA:BC:07:62:01:00:89:76:C9


70


digicerthighassuranceevrootca [jdk]


CN=DigiCert High Assurance EV Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert High Assurance EV Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US


2ac5c266a0b409b8f0b79f2ae462577


3


Fri Nov 10 02:00:00 IST 2006


Mon Nov 10 02:00:00 IST 2031


5F:B7:EE:06:33:E2:59:DB:AD:0C:4C:9A:E6:D3:8F:1A:61:C7:DC:25


71


quovadisrootca1g3 [jdk]


CN=QuoVadis Root CA 1 G3, O=QuoVadis Limited, C=BM


CN=QuoVadis Root CA 1 G3, O=QuoVadis Limited, C=BM


78585f2ead2c194be3370735341328b596d46593


3


Thu Jan 12 19:27:44 IST 2012


Sun Jan 12 19:27:44 IST 2042


1B:8E:EA:57:96:29:1A:C9:39:EA:B8:0A:81:1A:73:73:C0:93:79:67


72


comodorsaca [jdk]


CN=COMODO RSA Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB


CN=COMODO RSA Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB


4caaf9cadb636fe01ff74ed85b03869d


3


Tue Jan 19 02:00:00 IST 2010


Tue Jan 19 01:59:59 IST 2038


AF:E5:D2:44:A8:D1:19:42:30:FF:47:9F:E2:F8:97:BB:CD:7A:8C:B4


73


buypassclass2ca [jdk]


CN=Buypass Class 2 Root CA, O=Buypass AS-983163327, C=NO


CN=Buypass Class 2 Root CA, O=Buypass AS-983163327, C=NO


2


3


Tue Oct 26 10:38:03 IST 2010


Fri Oct 26 11:38:03 IDT 2040


49:0A:75:74:DE:87:0A:47:FE:58:EE:F6:C7:6B:EB:C6:0B:12:40:99


74


secomscrootca2 [jdk]


OU=Security Communication RootCA2, O=”SECOM Trust Systems CO.,LTD.”, C=JP


OU=Security Communication RootCA2, O=”SECOM Trust Systems CO.,LTD.”, C=JP


0


3


Fri May 29 08:00:39 IDT 2009


Tue May 29 08:00:39 IDT 2029


5F:3B:8C:F2:F8:10:B3:7D:78:B4:CE:EC:19:19:C3:73:34:B9:C7:74


75


entrustevca [jdk]


CN=Entrust Root Certification Authority, OU=”(c) 2006 Entrust, Inc.”, OU=www.entrust.net/CPS is incorporated by reference, O=”Entrust, Inc.”, C=US


CN=Entrust Root Certification Authority, OU=”(c) 2006 Entrust, Inc.”, OU=www.entrust.net/CPS is incorporated by reference, O=”Entrust, Inc.”, C=US


456b5054


3


Mon Nov 27 22:23:42 IST 2006


Fri Nov 27 22:53:42 IST 2026


B3:1E:B1:B7:40:E3:6C:84:02:DA:DC:37:D4:4D:F5:D4:67:49:52:F9


76


verisignclass3g3ca [jdk]


CN=VeriSign Class 3 Public Primary Certification Authority - G3, OU=”(c) 1999 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


CN=VeriSign Class 3 Public Primary Certification Authority - G3, OU=”(c) 1999 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


9b7e0649a33e62b9d5ee90487129ef57


1


Fri Oct 01 02:00:00 IST 1999


Thu Jul 17 02:59:59 IDT 2036


13:2D:0D:45:53:4B:69:97:CD:B2:D5:C3:39:E2:55:76:60:9B:5C:C6


77


certumtrustednetworkca [jdk]


CN=Certum Trusted Network CA, OU=Certum Certification Authority, O=Unizeto Technologies S.A., C=PL


CN=Certum Trusted Network CA, OU=Certum Certification Authority, O=Unizeto Technologies S.A., C=PL


444c0


3


Wed Oct 22 14:07:37 IST 2008


Mon Dec 31 14:07:37 IST 2029


07:E0:32:E0:20:B7:2C:3F:19:2F:06:28:A2:59:3A:19:A7:0F:06:9E


78


dtrustclass3ca2ev [jdk]


CN=D-TRUST Root Class 3 CA 2 EV 2009, O=D-Trust GmbH, C=DE


CN=D-TRUST Root Class 3 CA 2 EV 2009, O=D-Trust GmbH, C=DE


983f4


3


Thu Nov 05 10:50:46 IST 2009


Mon Nov 05 10:50:46 IST 2029


96:C9:1B:0B:95:B4:10:98:42:FA:D0:D8:22:79:FE:60:FA:B9:16:83


79


globalsigneccrootcar5 [jdk]


CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R5


CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R5


605949e0262ebb55f90a778a71f94ad86c


3


Tue Nov 13 02:00:00 IST 2012


Tue Jan 19 05:14:07 IST 2038


1F:24:C6:30:CD:A4:18:EF:20:69:FF:AD:4F:DD:5F:46:3A:1B:69:AA


80


starfieldservicesrootg2ca [jdk]


CN=Starfield Services Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US


CN=Starfield Services Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US


0


3


Tue Sep 01 03:00:00 IDT 2009


Fri Jan 01 01:59:59 IST 2038


92:5A:8F:8D:2C:6D:04:E0:66:5F:59:6A:FF:22:D8:63:E8:25:6F:3F


81


ttelesecglobalrootclass2ca [jdk]


CN=T-TeleSec GlobalRoot Class 2, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE


CN=T-TeleSec GlobalRoot Class 2, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE


1


3


Wed Oct 01 13:40:14 IDT 2008


Sun Oct 02 02:59:59 IDT 2033


59:0D:2D:7D:88:4F:40:2E:61:7E:A5:62:32:17:65:CF:17:D8:94:E9


82


addtrustqualifiedca [jdk]


CN=AddTrust Qualified CA Root, OU=AddTrust TTP Network, O=AddTrust AB, C=SE


CN=AddTrust Qualified CA Root, OU=AddTrust TTP Network, O=AddTrust AB, C=SE


1


3


Tue May 30 13:44:50 IDT 2000


Sat May 30 13:44:50 IDT 2020


4D:23:78:EC:91:95:39:B5:00:7F:75:8F:03:3B:21:1E:C5:4D:8B:CF


83


digicertglobalrootca [jdk]


CN=DigiCert Global Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Global Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US


83be056904246b1a1756ac95991c74a


3


Fri Nov 10 02:00:00 IST 2006


Mon Nov 10 02:00:00 IST 2031


A8:98:5D:3A:65:E5:E5:C4:B2:D7:D6:6D:40:C6:DD:2F:B1:9C:54:36


84


amazonrootca1 [jdk]


CN=Amazon Root CA 1, O=Amazon, C=US


CN=Amazon Root CA 1, O=Amazon, C=US


66c9fcf99bf8c0a39e2f0788a43e696365bca


3


Tue May 26 08:00:00 CST 2015


Sun Jan 17 08:00:00 CST 2038


8D:A7:F9:65:EC:5E:FC:37:91:0F:1C:6E:59:FD:C1:CC:6A:6E:DE:16


85


amazonrootca2 [jdk]


CN=Amazon Root CA 2, O=Amazon, C=US


CN=Amazon Root CA 2, O=Amazon, C=US


66c9fd29635869f0a0fe58678f85b26bb8a37


3


Tue May 26 08:00:00 CST 2015


Sat May 26 08:00:00 CST 2040


5A:8C:EF:45:D7:A6:98:59:76:7A:8C:8B:44:96:B5:78:CF:47:4B:1A


86


amazonrootca3 [jdk]


CN=Amazon Root CA 3, O=Amazon, C=US


CN=Amazon Root CA 3, O=Amazon, C=US


66c9fd5749736663f3b0b9ad9e89e7603f24a


3


Tue May 26 08:00:00 CST 2015


Sat May 26 08:00:00 CST 2040


0D:44:DD:8C:3C:8C:1A:1A:58:75:64:81:E9:0F:2E:2A:FF:B3:D2:6E


87


amazonrootca4 [jdk]


CN=Amazon Root CA 4, O=Amazon, C=US


CN=Amazon Root CA 4, O=Amazon, C=US


66c9fd7c1bb104c2943e5717b7b2cc81ac10e


3


Tue May 26 08:00:00 CST 2015


Sat May 26 08:00:00 CST 2040


F6:10:84:07:D6:F8:BB:67:98:0C:C2:E2:44:C2:EB:AE:1C:EF:63:BE


88


globalsignrootcar6 [jdk]


CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R6


CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R6


45e6bb038333c3856548e6ff4551


3


Wed Dec 10 08:00:00 CST 2014


Sun Dec 10 08:00:00 CST 2034


80:94:64:0E:B5:A7:A1:CA:11:9C:1F:DD:D5:9F:81:02:63:A7:FB:D1


89


letsencryptisrgx1 [jdk]


CN=ISRG Root X1, O=Internet Security Research Group, C=US


CN=ISRG Root X1, O=Internet Security Research Group, C=US


8210cfb0d240e3594463e0bb63828b00


3


Thu Jun 04 19:04:38 CST 2015


Mon Jun 04 19:04:38 CST 2035


CA:BD:2A:79:A1:07:6A:31:F2:1D:25:36:35:CB:03:9D:43:29:A5:E8


90


luxtrustglobalroot2ca [jdk]


CN=LuxTrust Global Root 2, O=LuxTrust S.A., C=LU


CN=LuxTrust Global Root 2, O=LuxTrust S.A., C=LU


a7ea6df4b449eda6a24859ee6b815d3167fbbb1


3


Thu Mar 05 21:21:57 CST 2015


Mon Mar 05 21:21:57 CST 2035


1E:0E:56:19:0A:D1:8B:25:98:B2:04:44:FF:66:8A:04:17:99:5F:3F


91


teliasonerarootcav1 [jdk]


CN=TeliaSonera Root CA v1, O=TeliaSonera


CN=TeliaSonera Root CA v1, O=TeliaSonera


95be16a0f72e46f17b398272fa8bcd96


3


Thu Oct 18 20:00:50 CST 2007


Mon Oct 18 20:00:50 CST 2032


43:13:BB:96:F1:D5:86:9B:C1:4E:6A:92:F6:CF:F6:34:69:87:82:37


92


TWCA Root Certification Authority


CN=TWCA Root Certification Authority, OU=Root CA, O=TAIWAN-CA, C=TW


CN=TWCA Root Certification Authority, OU=Root CA, O=TAIWAN-CA, C=TW


01


3


Thu Aug 28 15:24:33 CST 2008


Tue Dec 31 23:59:59 CST 2030


CF:9E:87:6D:D3:EB:FC:42:26:97:A3:B5:A3:7A:A0:76:A9:06:23:48


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/iap-faq-13
爬取时间: 2025-05-08 06:53:43
来源: Huawei Developer


具体见加密套件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/iap-faq-14
爬取时间: 2025-05-08 06:53:53
来源: Huawei Developer


如果开发者提供的证书在IAP服务内置信任库中查询不到，则该证书不被IAP信任，需要构造完整的信任链以被IAP信任。


此处以Chrome浏览器最新版本（一般是支持自动验证证书链）为工具，以华为的证书为例，手工构造完整的证书链步骤如下：


开发者也可以选择其他证书链工具构造完成的证书链。

1.  访问华为开发者网站, 依次点击“查看网站信息 > 显示连接详情 > 显示证书 > 详细信息”，可查看证书状况，如下图所示：
2.  依次点击“服务器证书 > 导出 > Base64 编码 ASCII，证书链（*.pem;*.crt） > 保存”，如下图所示：
3. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161024.39840931916893734667858566959980:50001231000000:2800:932B230DF7C1FD557F24388322492FD5D17B8A66B1C109123BFD733A44E31E39.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161024.78705099247286815049126578769728:50001231000000:2800:51FCB48DA920C48930927CB7898A78E5BD010484918D699953BC195BD5464B22.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161024.43715751380323939216969989410848:50001231000000:2800:ECCD9CC8ECB7265797A90288BFF29D8E6B19B215C64D642E2234220BABFA7FC6.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/iap-faq-15
爬取时间: 2025-05-08 06:54:03
来源: Huawei Developer


是正常的。出于安全考虑，系统控件在拉起IAP Kit收银台时，会将子窗口等悬浮形态的组件隐藏。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/iap-faq-16
爬取时间: 2025-05-08 06:54:12
来源: Huawei Developer


有可能是debug包切换为release包之后，手机进程缓存没有失效导致。切换debug包和release包后，要保证进程缓存失效，比如锁屏5分钟或者重启。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-payment-kit
爬取时间: 2025-05-08 06:54:21
来源: Huawei Developer

- 接入开发时，请求参数的签名、结果验签在什么场景使用？
- Payment Kit的签名公私钥怎么获取？
- GET请求的bodySign是对谁签名得到的？
- 拉起收银台无反应？
- 拉起收银台报错？
- 支付成功后没有收到回调？
- 同一用户重复签约华为支付服务会生成多笔签约吗？
- 华为支付签约的免密代扣在哪里可以解约？
- 关于支付回调的验签，为什么预下单请求验签的时候使用SHA256，回调验签却使用SM2？只能使用SM2进行验签吗？
- 接口请求响应“无效的签名”应该如何排查？
- 收银台报错“服务暂不可用，请稍后重试”？
- 预下单请求报错“交易订单状态异常”？
- 预下单一段时间后再支付，能否有接口查到prepayId？
- 部分提供通知回调的API接口中的callbackUrl参数是否可以自定义？回调通知的报文是否支持商户自定义？
- 同一次支付请求接收到多次回调通知，怎么解决？
- 商户提供的回调通知接口在Payment Kit生产环境需要加网络允许清单吗？如何验证提供的回调地址Payment Kit服务器访问是否正常？
- 商户侧没有传营销信息，支付回调里面为什么会有营销信息？
- 华为支付服务App和元服务接口入参除了appId不同，其他如商户号、证书、密钥这些可以使用相同的吗？
- 商户入网后，有商户接入联调环境吗？
- 请求头PayMercAuth中的callerId和请求体中的mercNo或者combineMercNo是什么关系？
- 请求接口加签验证中，如果请求头“PayMercAuth”中bodySign字段为空值，会做验签吗？还是会先校验字段？
- 不更换商户订单号重复发起退款，返回000000，不返回退款金额是为什么？
- Payment Kit的退款操作，除了通过接入指导中的退款接口退款，还有财务功能相关平台吗？能从这个平台进行退款？
- 下载账单文件后，应该使用哪种格式来解析日期？
- 收银台支付报错“应用信息校验不通过，请联系商家处理”？
- 商户号绑定AppID提示“主体不一致”？
- 如何联系运营机构或受理服务机构获取开发指引？
- 找不到“华为支付服务（非虚拟类）”菜单或AppID关联授权的页面怎么处理？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-1
爬取时间: 2025-05-08 06:54:31
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-2
爬取时间: 2025-05-08 06:54:41
来源: Huawei Developer


签名的公私钥对是由开发者自行生成，生成后将公钥上传到华为支付商户平台后可获取相应的请求参数authId，具体流程查看准备证书章节。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-3
爬取时间: 2025-05-08 06:54:51
来源: Huawei Developer


GET请求需要对path url进行签名，例如查询支付订单的待签名内容是：“/api/v2/aggr/transactions/orders/{sysTransOrderNo}”。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-4
爬取时间: 2025-05-08 06:55:00
来源: Huawei Developer


请检查orderStr入参格式，要求为JsonStr的格式（参见示例代码），不可为json对象或重复序列化。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-5
爬取时间: 2025-05-08 06:55:09
来源: Huawei Developer


该情况一般属于入参格式存在问题，还请根据支付的回调信息进行定位，请检查以下注意事项：

- 请确保每次的支付请求noncestr参数唯一。
- 请检查timestamp时间戳格式是否错误。
- 请检查签名前是否已排序拼接。
- 签名后的入参字段重新赋值。
- 对应prepay_id的订单是否已过期或已支付。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-6
爬取时间: 2025-05-08 06:55:19
来源: Huawei Developer

- 检查预下单传入的callbackUrl接口地址是否有效。
- 检查服务器是否有允许清单等网络限制。
- 加密套件不一致，目前华为支付支持的加密套件如下：

```less
TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
TLS_DHE_DSS_WITH_AES_128_GCM_SHA256
TLS_DHE_DSS_WITH_AES_256_GCM_SHA384
TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
TLS_AES_128_GCM_SHA256
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-7
爬取时间: 2025-05-08 06:55:28
来源: Huawei Developer


同一个商户号、使用同一个华为支付账号、使用同一套签约模板时，多次重复签约时只会生成一笔签约。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-8
爬取时间: 2025-05-08 06:55:38
来源: Huawei Developer

- 方式1：用户可选择“华为钱包 > 我的 > 华为支付”，点击右上角菜单栏“免密代扣 > 华为支付免密代扣”，完成免密代扣解约。
- 方式2：商户（开发者）通过华为支付服务对外开放的API接口进行解约。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-9
爬取时间: 2025-05-08 06:55:47
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-10
爬取时间: 2025-05-08 06:55:56
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-11
爬取时间: 2025-05-08 06:56:05
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-12
爬取时间: 2025-05-08 06:56:15
来源: Huawei Developer


请检查是否使用相同的订单号重复预下单，需要更换下商户订单号mercOrderNo再重新发起预下单请求。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-13
爬取时间: 2025-05-08 06:56:25
来源: Huawei Developer


prepayId有效期为10分钟。目前没有提供可以查询prepayId的接口。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-14
爬取时间: 2025-05-08 06:56:34
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-15
爬取时间: 2025-05-08 06:56:44
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-16
爬取时间: 2025-05-08 06:56:54
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-17
爬取时间: 2025-05-08 06:57:03
来源: Huawei Developer


营销活动不需要商户侧传递，拉起收银台前华为支付会根据用户和商户去获取华为支付侧配置的营销活动信息展示在收银台，若用户使用了营销活动，支付结果就会返回营销信息。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-18
爬取时间: 2025-05-08 06:57:13
来源: Huawei Developer


App和元服务属于不同的应用，appId因此不同，商户号、证书等是可以共用一套的。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-19
爬取时间: 2025-05-08 06:57:23
来源: Huawei Developer


目前商户接入联调建议直接在生产环境联调。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-20
爬取时间: 2025-05-08 06:57:32
来源: Huawei Developer


callerId和mercNo或者combineMercNo都是请求发起方商户号。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-21
爬取时间: 2025-05-08 06:57:42
来源: Huawei Developer


鉴权请求头“PayMercAuth”会先校验相关字段再做验签。bodySign字段设置为空值，Payment Kit服务器不会做验签，直接响应异常给商户。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-22
爬取时间: 2025-05-08 06:57:50
来源: Huawei Developer


请检查首次发起退款是否已正常完成退款。订单已经全额退款后，使用相同的商户订单号重复发起退款不会再返回退款金额。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-23
爬取时间: 2025-05-08 06:57:59
来源: Huawei Developer


除接入指导文档中提供给商户的退款接口进行退款，商户也可以登录华为支付商户平台，选择“交易中心 > 交易明细 > 订单详情”页面，在操作菜单中点击退款发起退款操作。


这个功能商户不需要对接联调，可以直接使用，支持发起部分退款和全额退款。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-24
爬取时间: 2025-05-08 06:58:09
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-25
爬取时间: 2025-05-08 06:58:18
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-26
爬取时间: 2025-05-08 06:58:28
来源: Huawei Developer


可能是开发者联盟上商户应用管理员的企业证件号码（营业执照注册号）未正确维护导致。

1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161045.36050605254821214339727156458838:50001231000000:2800:926D3BE01FDE9CA8982E20620593D4C3FB491ABC29E6BA28BF4483E42E2D470D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161045.06883209914217970006480632985248:50001231000000:2800:0752191A436BBF07611C5465C0D4E9628FC01D7FB4B1EC715E5A6225E609B341.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-27
爬取时间: 2025-05-08 06:58:38
来源: Huawei Developer


您可拨打数字人民币客服热线咨询接入流程和相关讯息。


客服热线：956196。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/payment-faq-28
爬取时间: 2025-05-08 06:58:48
来源: Huawei Developer


登录AppGallery Connect网站选择对应的项目后，在‘全部功能’中搜索华为支付服务并固定到菜单导航栏中。可参考下图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161045.68582643047734943798805725784079:50001231000000:2800:B8C4088F9150C06E8CDD874CF1113A3135D9E41BA92395C8BF8EEA83C8317921.png)

在“华为支付服务（非虚拟类）>待绑定商户”选择对应的商户点击“授权”即可。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-map-kit
爬取时间: 2025-05-08 06:58:58
来源: Huawei Developer

- 地图不显示
- siteId参数如何获取
- 手势卡顿或者不生效

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/map-faq-1
爬取时间: 2025-05-08 06:59:07
来源: Huawei Developer


现象描述


无法加载地图。


可能原因


处理步骤


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/map-faq-3
爬取时间: 2025-05-08 06:59:16
来源: Huawei Developer


siteId有多种获取方式，这里提供其中的3种作为参考：


1. 可通过on(type: 'poiClick')方法获取。


2. 可通过位置搜索相关接口（关键字搜索、周边搜索、地点详情、自动补全、正地理编码）的返回结果中获取。


3. 可通过chooseLocation接口的返回结果中获取。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/map-faq-4
爬取时间: 2025-05-08 06:59:25
来源: Huawei Developer


现象描述


地图页面操作手势卡顿或者不生效。


可能原因

1.  应用主线程处理大批量逻辑时，存在主线程阻塞，此时进行地图手势操作，手势应答会变慢甚至手势响应失败。
- 手势遮盖：地图组件的上层存在没有做手势穿透的组件。
- 手势冲突：以Swiper容器组件中使用地图组件为例，Swiper容器组件和地图组件手势会存在冲突。

处理步骤


```typescript
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
import { map, mapCommon, MapComponent } from '@kit.MapKit';


class MyDataSource implements IDataSource {
  private list: number[] = [];


  constructor(list: number[]) {
    this.list = list;
  }


  totalCount(): number {
    return this.list.length;
  }


  getData(index: number): number {
    return this.list[index];
  }


  registerDataChangeListener(listener: DataChangeListener): void {
  }


  unregisterDataChangeListener(listener: DataChangeListener): void {
  }
}


@Entry
@Component
struct SwiperExample {
  private swiperController: SwiperController = new SwiperController();
  private data: MyDataSource = new MyDataSource([]);
  private mapOptions?: mapCommon.MapOptions;
  private callback?: AsyncCallback<map.MapComponentController>;
  private mapController?: map.MapComponentController;
  private mapEventManager?: map.MapEventManager;
  @State mapPositionX: number = 0;
  @State mapPositionY: number = 0;
  @State mapHeight: number = 0;
  @State mapWidth: number = 0;
  @State index: number = 0;


  // 判断坐标是否在地图矩形内
  isMap(event: TouchEvent) {
    if (event.changedTouches[0].displayX > this.mapPositionX
      && event.changedTouches[0].displayX < this.mapPositionX + this.mapWidth
      && event.changedTouches[0].displayY > this.mapPositionY
      && event.changedTouches[0].displayY < this.mapPositionY + this.mapHeight) {
      return true;
    }
    return false;
  }


  aboutToAppear(): void {
    let list: number[] = [];
    for (let i = 1; i <= 10; i++) {
      list.push(i);
    }
    this.data = new MyDataSource(list);


    this.mapOptions = {
      position: {
        target: {
          latitude: 31.98441025,
          longitude: 118.766253
        },
        zoom: 10,
        tilt: 10,
        bearing: 90
      },
      scaleControlsEnabled: true
    }


    this.callback = async (err, mapController) => {
      if (!err) {
        this.mapController = mapController;
        this.mapEventManager = this.mapController.getEventManager();
        let callback = () => {
          console.info(`on-mapLoad`);
        };
        this.mapEventManager.on("mapLoad", callback);
      }
    }
  }


  build() {
    Column({ space: 5 }) {
      Swiper(this.swiperController) {
        LazyForEach(this.data, (item: string) => {
          if (item == "3") {
            Column() {
              Text(item.toString())
                .width('90%')
                .height(160)
                .backgroundColor(0xAFEEEE)
                .textAlign(TextAlign.Center)
                .fontSize(30)
              MapComponent({ mapOptions: this.mapOptions, mapCallback: this.callback })
                // 获取MapComponent的位置和长宽
                .width('100%')
                .height('65%')
                .onAreaChange((_oldValue: Area, newValue: Area) => {
                  try {
                    if (newValue.globalPosition.x !== undefined && newValue.globalPosition.y !== undefined) {
                      this.mapPositionX = Number(newValue.globalPosition.x);
                      this.mapPositionY = Number(newValue.globalPosition.y);
                      this.mapHeight = Number(newValue.height);
                      this.mapWidth = Number(newValue.width);
                    }
                  } catch (error) {
                    let e: BusinessError = error as BusinessError;
                    console.log("onAreaChange error code:" + e.code + "message:" + e.message);
                  }
                })
            }.height("100%")
          } else {
            Text(item.toString())
              .width('90%')
              .height(160)
              .backgroundColor(0xAFEEEE)
              .textAlign(TextAlign.Center)
              .fontSize(30)
          }
        }, (item: string) => item)
      }
      // 手势判断 当index为存在地图页面且点击在地图矩形内时为HitTestMode.None（不响应Swiper手势，响应子组件手势）
      .onTouchIntercept((event: TouchEvent) => {
        if (this.index === 2 && this.isMap(event)) {
          return HitTestMode.None;
        }
        return HitTestMode.Transparent;
      })
      .cachedCount(2)
      .index(1)
      .loop(true)
      .itemSpace(0)
      // 设置圆点导航点样式
      .indicator(
        new DotIndicator()
          .itemWidth(15)
          .itemHeight(15)
          .selectedItemWidth(15)
          .selectedItemHeight(15)
          .color(Color.Gray)
          .selectedColor(Color.Blue))
      .displayArrow({
        // 设置导航点箭头样式
        showBackground: true,
        isSidebarMiddle: true,
        backgroundSize: 24,
        backgroundColor: Color.White,
        arrowSize: 18,
        arrowColor: Color.Blue
      }, false)
      .curve(Curve.Linear)
      .onChange((index: number) => {
        this.index = index;
      })
      .onGestureSwipe((index: number, extraInfo: SwiperAnimationEvent) => {
        console.info("index: " + index);
        console.info("current offset: " + extraInfo.currentOffset);
      })


      Row({ space: 12 }) {
        Button('showNext')
          .onClick(() => {
            this.swiperController.showNext();
          })
        Button('showPrevious')
          .onClick(() => {
            this.swiperController.showPrevious();
          })
      }.margin(5)
    }.width('100%')
    .margin({ top: 5 })
  }
}
```


```typescript
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
import { map, mapCommon, MapComponent } from '@kit.MapKit';


class MyDataSource implements IDataSource {
  private list: number[] = [];


  constructor(list: number[]) {
    this.list = list;
  }


  totalCount(): number {
    return this.list.length;
  }


  getData(index: number): number {
    return this.list[index];
  }


  registerDataChangeListener(listener: DataChangeListener): void {
  }


  unregisterDataChangeListener(listener: DataChangeListener): void {
  }
}


@Entry
@Component
struct SwiperExample {
  private swiperController: SwiperController = new SwiperController();
  private data: MyDataSource = new MyDataSource([]);
  private mapOptions?: mapCommon.MapOptions;
  private callback?: AsyncCallback<map.MapComponentController>;
  private mapController?: map.MapComponentController;
  private mapEventManager?: map.MapEventManager;
  @State mapPositionX: number = 0;
  @State mapPositionY: number = 0;
  @State mapHeight: number = 0;
  @State mapWidth: number = 0;
  @State index: number = 0;


  // 判断坐标是否在地图矩形内
  isMap(event: TouchEvent) {
    if (event.changedTouches[0].displayX > this.mapPositionX
      && event.changedTouches[0].displayX < this.mapPositionX + this.mapWidth
      && event.changedTouches[0].displayY > this.mapPositionY
      && event.changedTouches[0].displayY < this.mapPositionY + this.mapHeight) {
      return true;
    }
    return false;
  }


  aboutToAppear(): void {
    let list: number[] = [];
    for (let i = 1; i <= 10; i++) {
      list.push(i);
    }
    this.data = new MyDataSource(list);


    this.mapOptions = {
      position: {
        target: {
          latitude: 31.98441025,
          longitude: 118.766253
        },
        zoom: 10,
        tilt: 10,
        bearing: 90
      },
      scaleControlsEnabled: true
    }


    this.callback = async (err, mapController) => {
      if (!err) {
        this.mapController = mapController;
        this.mapEventManager = this.mapController.getEventManager();
        let callback = () => {
          console.info(`on-mapLoad`);
        };
        this.mapEventManager.on("mapLoad", callback);
      }
    }
  }


  build() {
    Column({ space: 5 }) {
      Swiper(this.swiperController) {
        LazyForEach(this.data, (item: string) => {
          if (item == "3") {
            Column() {
              Text(item.toString())
                .width('90%')
                .height(160)
                .backgroundColor(0xAFEEEE)
                .textAlign(TextAlign.Center)
                .fontSize(30)
              MapComponent({ mapOptions: this.mapOptions, mapCallback: this.callback })
                // 获取MapComponent的位置和长宽
                .width('100%')
                .height('65%')
                .onAreaChange((_oldValue: Area, newValue: Area) => {
                  try {
                    if (newValue.globalPosition.x !== undefined && newValue.globalPosition.y !== undefined) {
                      this.mapPositionX = Number(newValue.globalPosition.x);
                      this.mapPositionY = Number(newValue.globalPosition.y);
                      this.mapHeight = Number(newValue.height);
                      this.mapWidth = Number(newValue.width);
                    }
                  } catch (error) {
                    let e: BusinessError = error as BusinessError;
                    console.log("onAreaChange error code:" + e.code + "message:" + e.message);
                  }
                })
            }.height("100%")
          } else {
            Text(item.toString())
              .width('90%')
              .height(160)
              .backgroundColor(0xAFEEEE)
              .textAlign(TextAlign.Center)
              .fontSize(30)
          }
        }, (item: string) => item)
      }
      // 手势判断 当index为存在地图页面且点击在地图矩形内时为HitTestMode.None（不响应Swiper手势，响应子组件手势）
      .onTouchIntercept((event: TouchEvent) => {
        if (this.index === 2 && this.isMap(event)) {
          return HitTestMode.None;
        }
        return HitTestMode.Transparent;
      })
      .cachedCount(2)
      .index(1)
      .loop(true)
      .itemSpace(0)
      // 设置圆点导航点样式
      .indicator(
        new DotIndicator()
          .itemWidth(15)
          .itemHeight(15)
          .selectedItemWidth(15)
          .selectedItemHeight(15)
          .color(Color.Gray)
          .selectedColor(Color.Blue))
      .displayArrow({
        // 设置导航点箭头样式
        showBackground: true,
        isSidebarMiddle: true,
        backgroundSize: 24,
        backgroundColor: Color.White,
        arrowSize: 18,
        arrowColor: Color.Blue
      }, false)
      .curve(Curve.Linear)
      .onChange((index: number) => {
        this.index = index;
      })
      .onGestureSwipe((index: number, extraInfo: SwiperAnimationEvent) => {
        console.info("index: " + index);
        console.info("current offset: " + extraInfo.currentOffset);
      })


      Row({ space: 12 }) {
        Button('showNext')
          .onClick(() => {
            this.swiperController.showNext();
          })
        Button('showPrevious')
          .onClick(() => {
            this.swiperController.showPrevious();
          })
      }.margin(5)
    }.width('100%')
    .margin({ top: 5 })
  }
}
```

1.  请分析应用的业务逻辑，将复杂逻辑放到子线程中处理。
- 手势遮盖：参考触摸测试控制做手势穿透。

```typescript
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
import { map, mapCommon, MapComponent } from '@kit.MapKit';


class MyDataSource implements IDataSource {
  private list: number[] = [];


  constructor(list: number[]) {
    this.list = list;
  }


  totalCount(): number {
    return this.list.length;
  }


  getData(index: number): number {
    return this.list[index];
  }


  registerDataChangeListener(listener: DataChangeListener): void {
  }


  unregisterDataChangeListener(listener: DataChangeListener): void {
  }
}


@Entry
@Component
struct SwiperExample {
  private swiperController: SwiperController = new SwiperController();
  private data: MyDataSource = new MyDataSource([]);
  private mapOptions?: mapCommon.MapOptions;
  private callback?: AsyncCallback<map.MapComponentController>;
  private mapController?: map.MapComponentController;
  private mapEventManager?: map.MapEventManager;
  @State mapPositionX: number = 0;
  @State mapPositionY: number = 0;
  @State mapHeight: number = 0;
  @State mapWidth: number = 0;
  @State index: number = 0;


  // 判断坐标是否在地图矩形内
  isMap(event: TouchEvent) {
    if (event.changedTouches[0].displayX > this.mapPositionX
      && event.changedTouches[0].displayX < this.mapPositionX + this.mapWidth
      && event.changedTouches[0].displayY > this.mapPositionY
      && event.changedTouches[0].displayY < this.mapPositionY + this.mapHeight) {
      return true;
    }
    return false;
  }


  aboutToAppear(): void {
    let list: number[] = [];
    for (let i = 1; i <= 10; i++) {
      list.push(i);
    }
    this.data = new MyDataSource(list);


    this.mapOptions = {
      position: {
        target: {
          latitude: 31.98441025,
          longitude: 118.766253
        },
        zoom: 10,
        tilt: 10,
        bearing: 90
      },
      scaleControlsEnabled: true
    }


    this.callback = async (err, mapController) => {
      if (!err) {
        this.mapController = mapController;
        this.mapEventManager = this.mapController.getEventManager();
        let callback = () => {
          console.info(`on-mapLoad`);
        };
        this.mapEventManager.on("mapLoad", callback);
      }
    }
  }


  build() {
    Column({ space: 5 }) {
      Swiper(this.swiperController) {
        LazyForEach(this.data, (item: string) => {
          if (item == "3") {
            Column() {
              Text(item.toString())
                .width('90%')
                .height(160)
                .backgroundColor(0xAFEEEE)
                .textAlign(TextAlign.Center)
                .fontSize(30)
              MapComponent({ mapOptions: this.mapOptions, mapCallback: this.callback })
                // 获取MapComponent的位置和长宽
                .width('100%')
                .height('65%')
                .onAreaChange((_oldValue: Area, newValue: Area) => {
                  try {
                    if (newValue.globalPosition.x !== undefined && newValue.globalPosition.y !== undefined) {
                      this.mapPositionX = Number(newValue.globalPosition.x);
                      this.mapPositionY = Number(newValue.globalPosition.y);
                      this.mapHeight = Number(newValue.height);
                      this.mapWidth = Number(newValue.width);
                    }
                  } catch (error) {
                    let e: BusinessError = error as BusinessError;
                    console.log("onAreaChange error code:" + e.code + "message:" + e.message);
                  }
                })
            }.height("100%")
          } else {
            Text(item.toString())
              .width('90%')
              .height(160)
              .backgroundColor(0xAFEEEE)
              .textAlign(TextAlign.Center)
              .fontSize(30)
          }
        }, (item: string) => item)
      }
      // 手势判断 当index为存在地图页面且点击在地图矩形内时为HitTestMode.None（不响应Swiper手势，响应子组件手势）
      .onTouchIntercept((event: TouchEvent) => {
        if (this.index === 2 && this.isMap(event)) {
          return HitTestMode.None;
        }
        return HitTestMode.Transparent;
      })
      .cachedCount(2)
      .index(1)
      .loop(true)
      .itemSpace(0)
      // 设置圆点导航点样式
      .indicator(
        new DotIndicator()
          .itemWidth(15)
          .itemHeight(15)
          .selectedItemWidth(15)
          .selectedItemHeight(15)
          .color(Color.Gray)
          .selectedColor(Color.Blue))
      .displayArrow({
        // 设置导航点箭头样式
        showBackground: true,
        isSidebarMiddle: true,
        backgroundSize: 24,
        backgroundColor: Color.White,
        arrowSize: 18,
        arrowColor: Color.Blue
      }, false)
      .curve(Curve.Linear)
      .onChange((index: number) => {
        this.index = index;
      })
      .onGestureSwipe((index: number, extraInfo: SwiperAnimationEvent) => {
        console.info("index: " + index);
        console.info("current offset: " + extraInfo.currentOffset);
      })


      Row({ space: 12 }) {
        Button('showNext')
          .onClick(() => {
            this.swiperController.showNext();
          })
        Button('showPrevious')
          .onClick(() => {
            this.swiperController.showPrevious();
          })
      }.margin(5)
    }.width('100%')
    .margin({ top: 5 })
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-location-kit
爬取时间: 2025-05-08 06:59:35
来源: Huawei Developer

- 如何申请精确定位
- 定位服务使用什么坐标系，如何根据实际应用场景转换
- 在室内时，在持续定位场景中设置interval为1，为何不生效

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-location-kit-1
爬取时间: 2025-05-08 06:59:45
来源: Huawei Developer


问题场景


在获取定位权限的场景中，申请了模糊和精准定位的权限['ohos.permission.APPROXIMATELY_LOCATION','ohos.permission.LOCATION']，其中模糊定位会弹出权限框，点击同意后在申请精准定位时，精准定位结果grantStatus返回2什么意思。


解决措施


精准定位结果grantStatus返回2，表示未授权，请求无效可能原因有：未在设置文件中声明目标权限、权限名非法、部分权限存在特殊申请条件，在申请对应权限时未满足其指定的条件。其他相应请求权限，返回的错误码，可参考PermissionRequestResult。


```typescript
import { abilityAccessCtrl, common, PermissionRequestResult, Permissions } from '@kit.AbilityKit'; 
import { BusinessError } from '@kit.BasicServicesKit'; 
import { promptAction } from '@kit.ArkUI'; 
 
@Component 
export struct ApplyPrecisePositioning { 
  permissions: Array<Permissions> = ['ohos.permission.APPROXIMATELY_LOCATION', 'ohos.permission.LOCATION']; 
 
  aboutToAppear(): void { 
    this.reqPermissionsFromUser(this.permissions); 
  } 
 
  reqPermissionsFromUser(permissions: Array<Permissions>): void { 
    let context: Context = getContext(this) as common.UIAbilityContext; 
    let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager(); 
    // requestPermissionsFromUser会判断权限的授权状态来决定是否唤起弹窗 
    atManager.requestPermissionsFromUser(context, permissions).then((data: PermissionRequestResult) => { 
      let grantStatus: Array<number> = data.authResults; 
      let length: number = grantStatus.length; 
      for (let i = 0; i < length; i++) { 
        if (grantStatus[i] === 0) { 
          // 用户授权，可以继续访问目标操作 
        } else { 
          // 用户拒绝授权，提示用户必须授权才能访问当前页面的功能，并引导用户到系统设置中打开相应的权限 
          promptAction.showToast({ message: '用户拒绝授权' }); 
          return; 
        } 
      } 
      // 授权成功 
    }).catch((err: BusinessError) => { 
      console.error(`Failed to request permissions from user. Code is ${err.code}, message is ${err.message}`); 
    }) 
  } 
 
  build() { 
  } 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-location-kit-2
爬取时间: 2025-05-08 06:59:54
来源: Huawei Developer


定位服务使用WGS84坐标系，在国内如果要配合地图使用，需要转换为GCJ02坐标系，具体转换方法可参考Map Kit（地图服务）的坐标转换。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-location-kit-3
爬取时间: 2025-05-08 07:00:04
来源: Huawei Developer


在室内因为没有GNSS信号，大概率返回的是网络位置。因为WLAN扫描有较大的功耗，系统限制20秒扫描一次，因此在室内即使interval设置为1，也只能20秒获取到一次位置。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-health-service-kit
爬取时间: 2025-05-08 07:00:13
来源: Huawei Developer

- 读取今天的日常活动数据统计，与运动健康App页面数据不一致
- 授权后仍然没有数据类型权限
- 在授权时上报1001502003错误
- 在授权时上报1001502014错误
- 用户隐私未同意，如何引导用户打开运动健康App

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/health-faqs-1
爬取时间: 2025-05-08 07:00:28
来源: Huawei Developer


聚合查询接口读取今日日常活动数据，数据上报存在延时，读取实时日常活动数据建议使用读取实时三环数据接口。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/health-faqs-2
爬取时间: 2025-05-08 07:00:37
来源: Huawei Developer


鉴权时使用的权限是用户授权的权限与应用申请的权限的交集，需确认：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/health-faqs-3
爬取时间: 2025-05-08 07:00:47
来源: Huawei Developer


参考配置Client ID，请登录AppGallery Connect平台，确认代码中配置的包名与client ID是匹配的。若仍无法解决通过在线提单提交问题，华为支持人员会及时处理。


更多错误码请参考ArkTS API错误码。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/health-faqs-4
爬取时间: 2025-05-08 07:00:57
来源: Huawei Developer


确保授权请求参数中的数据类型已经在Health Service Kit卡片中申请相应的权限，申请步骤请参考申请运动健康服务，数据类型对应的权限参考权限说明。


更多错误码请参考ArkTS API错误码。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/health-faqs-5
爬取时间: 2025-05-08 07:01:08
来源: Huawei Developer


接口响应错误码1002703001，可通过以下方式引导用户打开运动健康App，同意隐私授权：


调用canOpenLink判断运动健康App是否安装。运动健康App Scheme：huaweischeme://healthapp/home/main。

- App已安装，调用openLink接口拉起运动健康App。运动健康App Scheme：huaweischeme://healthapp/home/main。
- App未安装，调用应用市场推荐接口，引导用户下载运动健康App，运动健康App包名：com.huawei.hmos.health。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-account-kit
爬取时间: 2025-05-08 07:01:17
来源: Huawei Developer

- OpenID和UnionID的格式说明
- Access Token和Refresh Token的有效时长是多久
- Access Token和Refresh Token长度限制要求
- 调用接口获取应用级Access Token时，是否有次数和频率限制
- 无法获取手机号或获取到的手机号为空如何解决
- ID Token的使用场景与使用方法
- 未成年人模式开启后USB断连如何解决
- HarmonyOS APK应用和HarmonyOS应用在一键登录场景下的用户数据如何互通
- 使用华为账号一键登录功能时，是以华为账号的UnionID/OpenID还是以手机号作为用户的主要标识？
- 订阅到系统未成年人模式开启了，这个时候应用要怎么处理
- 为什么有的时候在应用内进行验密，会触发一个弹框提示用户已开启远程守护，无法输入密码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/account-faq-1
爬取时间: 2025-05-08 07:01:27
来源: Huawei Developer


长度

- OpenID应用创建时间晚于（含）2023年09月21日 23:00:00，OpenID固定28位。应用创建时间早于2023年09月21日 23:00:00，OpenID长度不固定，限制在1-256位。
- 应用创建时间晚于（含）2023年09月21日 23:00:00，OpenID固定28位。
- 应用创建时间早于2023年09月21日 23:00:00，OpenID长度不固定，限制在1-256位。
- UnionID开发者账号注册时间晚于（含）2023年09月21日 23:00:00，UnionID固定29位。开发者账号注册时间早于2023年09月21日 23:00:00，UnionID长度不固定，限制在1-92位。
- 开发者账号注册时间晚于（含）2023年09月21日 23:00:00，UnionID固定29位。
- 开发者账号注册时间早于2023年09月21日 23:00:00，UnionID长度不固定，限制在1-92位。
- 应用创建时间晚于（含）2023年09月21日 23:00:00，OpenID固定28位。
- 应用创建时间早于2023年09月21日 23:00:00，OpenID长度不固定，限制在1-256位。
- 开发者账号注册时间晚于（含）2023年09月21日 23:00:00，UnionID固定29位。
- 开发者账号注册时间早于2023年09月21日 23:00:00，UnionID长度不固定，限制在1-92位。

唯一性标识


数据类型


OpenID和UnionID均是字符串类型的数据。


大小写敏感


OpenID和UnionID严格区分大小写。


实际应用中的注意事项


在存储、查询或比较OpenID或UnionID时，请务必保持其原始的大小写格式。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/account-faq-2
爬取时间: 2025-05-08 07:01:37
来源: Huawei Developer


Access Token的有效时长是1个小时，Refresh Token的有效时长是180天。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/account-faq-3
爬取时间: 2025-05-08 07:01:47
来源: Huawei Developer


Access Token和Refresh Token的长度与其中编码的信息有关，目前来讲Access Token和Refresh Token的长度不会超过1024字符。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/account-faq-4
爬取时间: 2025-05-08 07:01:57
来源: Huawei Developer


单个应用在1小时内最多允许10000次调用获取应用级Access Token，超过该限制次数后失败。详细流控机制请参见华为OAuth应用级Access Token流控机制。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/account-faq-6
爬取时间: 2025-05-08 07:02:07
来源: Huawei Developer


在华为账号一键登录场景下，获取匿名手机号为空或无法获取到明文手机号时，建议通过以下步骤排查解决：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/account-faq-7
爬取时间: 2025-05-08 07:02:16
来源: Huawei Developer


ID Token是OIDC (OpenID Connect) 协议相对于 OAuth 2.0 协议扩展的一个用户身份凭证。


ID Token 是 JWT Token格式，意味着：


1. 用户的身份信息直接被编码进了ID Token，不需要额外请求其他的资源来获取用户信息。


2. ID Token 可以验证其是华为账号服务颁发的，携带华为账号签名信息，验证签名可证明其没有被篡改过。


使用场景


字段说明


ID Token是JWT Token格式数据，其中payload包含字段如下：


|  字段 |  参数类型 |  是否默认返回 |  描述 |
| --- | --- | --- | --- |
|  iss |  string |  是 |  固定值："https://accounts.huawei.com"。 |
|  sub |  string |  是 |  即用户的UnionID。同一个开发者下的所有应用，此参数均相同。具体格式要求请参考OpenID和UnionID的格式说明。 |
|  aud |  string |  是 |  接收ID Token的应用ID。 |
|  exp |  number |  是 |  ID Token过期时间。 |
|  iat |  number |  是 |  ID Token生成时间。 |
|  at_hash |  string |  是 |  Access Token的哈希值。 |
|  azp |  string |  是 |  生成ID Token的应用ID。 |
|  openid |  string |  是 |  用户OpenID。具体格式要求请参考OpenID和UnionID的格式说明。 |
|  nonce |  string |  否 |  防重放攻击随机值。详情请参考LoginWithHuaweiIDRequest或AuthorizationWithHuaweiIDRequest的nonce字段说明。 |
|  picture |  string |  否 |  用户头像图片链接。该字段返回场景：AuthorizationWithHuaweiIDRequest中的scopes包含profile。 |
|  display_name |  string |  否 |  华为账号对应的昵称，没有昵称则取匿名化的邮箱或手机号。该字段返回场景： AuthorizationWithHuaweiIDRequest中的scopes包含profile。 |
|  nickname |  string |  否 |  华为账号对应的昵称。该字段返回场景： AuthorizationWithHuaweiIDRequest中的scopes包含profile。 |
|  phone |  string |  否 |  华为账号绑定号码。该字段返回场景： AuthorizationWithHuaweiIDRequest中的scopes包含quickLoginMobilePhone。 |

字段


参数类型


是否默认返回


描述


iss


string


是


固定值："https://accounts.huawei.com"。


sub


string


是


即用户的UnionID。同一个开发者下的所有应用，此参数均相同。具体格式要求请参考OpenID和UnionID的格式说明。


aud


string


是


接收ID Token的应用ID。


exp


number


是


ID Token过期时间。


iat


number


是


ID Token生成时间。


at_hash


string


是


Access Token的哈希值。


azp


string


是


生成ID Token的应用ID。


openid


string


是


用户OpenID。具体格式要求请参考OpenID和UnionID的格式说明。


nonce


string


否


防重放攻击随机值。详情请参考LoginWithHuaweiIDRequest或AuthorizationWithHuaweiIDRequest的nonce字段说明。


picture


string


否


用户头像图片链接。该字段返回场景：AuthorizationWithHuaweiIDRequest中的scopes包含profile。


display_name


string


否


华为账号对应的昵称，没有昵称则取匿名化的邮箱或手机号。该字段返回场景：


AuthorizationWithHuaweiIDRequest中的scopes包含profile。


nickname


string


否


华为账号对应的昵称。该字段返回场景：


AuthorizationWithHuaweiIDRequest中的scopes包含profile。


phone


string


否


华为账号绑定号码。该字段返回场景：


AuthorizationWithHuaweiIDRequest中的scopes包含quickLoginMobilePhone。


解析与验证


服务端解析与验证


使用场景：有服务器应用。


对于有应用服务端的应用，推荐在服务端进行ID Token解析与验证，具体参考以下Maven工程依赖配置及Java示例代码。


Maven工程依赖：


```less
<dependencies>
    <dependency>
        <groupId>com.alibaba.fastjson2</groupId>
        <artifactId>fastjson2</artifactId>
        <version>2.0.51</version> <!--此处替换为您项目需要的版本-->
    </dependency>
    <dependency>
        <groupId>org.bouncycastle</groupId>
        <artifactId>bcprov-jdk18on</artifactId>
        <version>1.74</version> <!--此处替换为您项目需要的版本-->
    </dependency>
    <dependency>
        <groupId>org.apache.httpcomponents</groupId>
        <artifactId>httpclient</artifactId>
        <version>4.5</version> <!--此处替换为您项目需要的版本-->
    </dependency>
    <dependency>
        <groupId>com.auth0</groupId>
        <artifactId>jwks-rsa</artifactId>
        <version>0.8.2</version> <!--此处替换为您项目需要的版本-->
    </dependency>
    <dependency>
        <groupId>com.auth0</groupId>
        <artifactId>java-jwt</artifactId>
        <version>3.8.1</version> <!--此处替换为您项目需要的版本-->
    </dependency>
</dependencies>
```


Java代码示例：


```less
import com.alibaba.fastjson2.JSONArray;
import com.alibaba.fastjson2.JSONObject;
import com.auth0.jwk.InvalidPublicKeyException;
import com.auth0.jwk.Jwk;
import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTDecodeException;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.exceptions.TokenExpiredException;
import com.auth0.jwt.interfaces.DecodedJWT;
import org.apache.commons.codec.binary.Base64;
import org.apache.http.HttpEntity;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.Security;
import java.security.Signature;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class IDTokenParser {
    // 请替换为您的Client ID
    private final static String CLIENT_ID = "123456";
    private final static int MAX_PUBLIC_KEY_SIZE = 4;
    // 缓存jwt公钥信息
    private final Map<String, RSAPublicKey> keyId2PublicKey = new HashMap<>();
    /**
     * JWK JSON Web Key端点，开发者可以从该端点获取最近两天的JWK
     * 公钥在24小时内更新。确保以下ID Token在24小时内生成
     */
    private static final String CERT_URL = "https://oauth-login.cloud.huawei.com/oauth2/v3/certs";
    // ID Token的issuer
    public static final String ID_TOKEN_ISSUE = "https://accounts.huawei.com";
    public static final String ALG_RS256 = "RS256";
    public final static String ALG_PS256 = "PS256";
    public static void main(String[] args) throws Exception {
        // 由上述CLIENT_ID对应值生成的ID Token
        String idToken = "<idToken>";
        IDTokenParser idTokenParser = new IDTokenParser();
        JSONObject idTokenInfo = idTokenParser.verifyAndParse(idToken);
        // 解析获取ID Token中的数据，例：解析获取iss
        String iss = idTokenInfo.getString("iss");
    }
    /**
     * 验证并解析ID Token
     * @param idToken idToken
     * @return ID Token携带的信息
     * @throws Exception 异常
     */
    public JSONObject verifyAndParse(String idToken) throws Exception {
        try {
            DecodedJWT decoder = JWT.decode(idToken);
            if (!decoder.getIssuer().equals(ID_TOKEN_ISSUE)) {
                // issuer校验不通过，抛出异常（异常类型可自行选择）
                throw new RuntimeException("issuer no match");
            }
            if (decoder.getAudience().size() > 0) {
                if (!decoder.getAudience().get(0).equals(CLIENT_ID)) {
                    // audience校验不通过，抛出异常（异常类型可自行选择）
                    throw new RuntimeException("audience no match");
                }
            }
            // 获取ID Token签名使用的算法
            String alg = decoder.getAlgorithm();
            if (ALG_RS256.equals(alg)) {
                Algorithm algorithm = Algorithm.RSA256(getRSAPublicKeyByKid(decoder.getKeyId()), null);
                JWTVerifier verifier = JWT.require(algorithm).build();
                JSONObject jsonObject = JSONObject.parseObject(new String(Base64.decodeBase64(decoder.getPayload())));
                // 验证签名
                verifier.verify(decoder);
                jsonObject.put("alg", decoder.getAlgorithm());
                jsonObject.put("typ", decoder.getType());
                jsonObject.put("kid", decoder.getKeyId());
                return jsonObject;
            } else if (ALG_PS256.equals(alg)) {
                PS256Algorithm algorithm = new PS256Algorithm(getRSAPublicKeyByKid(decoder.getKeyId()));
                boolean verifyResult = algorithm.verify(decoder.getHeader(), decoder.getPayload(),
                    decoder.getSignature());
                if (verifyResult) {
                    JSONObject jsonObject = JSONObject.parseObject(
                        new String(Base64.decodeBase64(decoder.getPayload())));
                    jsonObject.put("alg", decoder.getAlgorithm());
                    jsonObject.put("typ", decoder.getType());
                    jsonObject.put("kid", decoder.getKeyId());
                    return jsonObject;
                }
            }
            return null;
        } catch (JWTDecodeException e) {
            // ID Token解析失败，此场景常见于ID Token格式不正确
            throw new RuntimeException("ID Token decode failed");
        } catch (TokenExpiredException e) {
            // ID Token已过期
            throw new RuntimeException("ID Token expired");
        }
    }
    /**
     * 通过kid获取公钥信息，请缓存公钥信息，示例中采用map方式进行缓存，开发者可选择其它合适的方式进行缓存
     * @param keyId  keyId
     * @return 公钥信息
     * @throws InvalidPublicKeyException 异常
     */
    private RSAPublicKey getRSAPublicKeyByKid(String keyId) throws InvalidPublicKeyException {
        if (keyId2PublicKey.get(keyId) != null) {
            return keyId2PublicKey.get(keyId);
        }
        JSONArray keys = getJwks();
        if (keys == null) {
            return null;
        }
        if (keyId2PublicKey.size() > MAX_PUBLIC_KEY_SIZE) {
            keyId2PublicKey.clear();
        }
        for (int i = 0; i < keys.size(); i++) {
            String kid = keys.getJSONObject(i).getString("kid");
            String alg = keys.getJSONObject(i).getString("alg");
            if (ALG_RS256.equals(alg) || ALG_PS256.equals(alg)) {
                keyId2PublicKey.put(kid, getRsaPublicKeyByJwk(keys.getJSONObject(i)));
            }
        }
        return keyId2PublicKey.get(keyId);
    }
    /**
     * 从https://oauth-login.cloud.huawei.com/oauth2/v3/certs获取jwt公钥信息jwk
     * 因为jwk每天都会更新，所以需要缓存jwk
     * @return JSONObject 公钥信息数组
     */
    private static JSONArray getJwks() {
        CloseableHttpClient httpClient = HttpClients.createDefault();
        HttpGet httpGet = new HttpGet(CERT_URL);
        RequestConfig requestConfig = RequestConfig.custom()
            .setConnectTimeout(5000)
            .setConnectionRequestTimeout(5000)
            .setSocketTimeout(5000)
            .build();
        httpGet.setConfig(requestConfig);
        try {
            CloseableHttpResponse response = httpClient.execute(httpGet);
            HttpEntity entity = response.getEntity();
            String result = EntityUtils.toString(entity);
            return JSONObject.parseObject(result).getJSONArray("keys");
        } catch (Exception e) {
            return null;
        } finally {
            if (null != httpClient) {
                try {
                    httpClient.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
    /**
     * 通过jwk获取公钥信息
     * @return RSAPublicKey 公钥信息
     */
    private static RSAPublicKey getRsaPublicKeyByJwk(JSONObject jwkObject) throws InvalidPublicKeyException {
        Map<String, Object> additionalAttributes = new HashMap<>();
        additionalAttributes.put("n", jwkObject.getString("n"));
        additionalAttributes.put("e", jwkObject.getString("e"));
        List<String> operations = new ArrayList<>();
        Jwk jwk = new Jwk(jwkObject.getString("kid"), jwkObject.getString("kty"), jwkObject.getString("alg"),
            jwkObject.getString("use"), operations, null, null, null, additionalAttributes);
        return (RSAPublicKey) jwk.getPublicKey();
    }
    static class PS256Algorithm {
        private final RSAPublicKey publicKey;
        public PS256Algorithm(RSAPublicKey publicKey) {
            this.publicKey = publicKey;
        }
        public boolean verify(String header, String payload, String signature) throws JWTVerificationException {
            byte[] contentBytes = (header + '.' + payload).getBytes(StandardCharsets.UTF_8);
            byte[] signatureBytes = Base64.decodeBase64(signature);
            try {
                Security.addProvider(new BouncyCastleProvider());
                Signature sign = Signature.getInstance("SHA256WithRSA/PSS");
                sign.initVerify(publicKey);
                sign.update(contentBytes);
                return sign.verify(signatureBytes);
            } catch (GeneralSecurityException e) {
                throw new JWTVerificationException("JWT verify failed");
            }
        }
    }
}
```


客户端解析与验证


使用场景：无服务器应用。


```typescript
import { buffer } from '@kit.ArkTS';
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { http } from '@kit.NetworkKit';
import { hilog } from '@kit.PerformanceAnalysisKit';


decodeBase64(data: string): string {
  return buffer.from(data, 'base64').toString('utf8');
}
// 解析ID Token并验证
decodeIdToken(idToken: string): void {
  const parts = idToken.split('.');
  if (parts.length !== 3) {
    return;
  }
  const idTokenObj: Record<string, Object> = {};
  // ID Token头部
  idTokenObj['header'] = JSON.parse(this.decodeBase64(parts[0]));
  // ID Token负载
  idTokenObj['payload'] = JSON.parse(this.decodeBase64(parts[1]));
  // ID Token签名
  idTokenObj['signature'] = parts[2];
  const header: Record<string, string> = idTokenObj['header'] as Record<string, string>;
  // 从负载中解析出nonce等数据
  const payLoad: Record<string, string> = idTokenObj['payload'] as Record<string, string>;
  const nonce: string = payLoad['nonce'];
  // 应用Client ID，使用前请替换
  const CLIENT_ID: string = '<应用Client ID>';
  const ID_TOKEN_ISSUE: string = 'https://accounts.huawei.com';
  const iss: string = payLoad['iss'];
  const aud: string = payLoad['aud'];
  if(iss !== ID_TOKEN_ISSUE){
    // 验证失败，开发者处理失败场景
    hilog.error(0x0000, 'testTag', 'Failed to check iss');
    return;
  }
  if(aud !== CLIENT_ID){
    // 验证失败，开发者处理失败场景
    hilog.error(0x0000, 'testTag', 'Failed to check aud');
    return;
  }
  // 验证签名
  this.checkSignature(idToken, header['kid'], header['alg']);
}


private stringToUint8Array(str: string): Uint8Array {
  const arr: number[] = [];
  for (let i = 0, j = str.length; i < j; ++i) {
    arr.push(str.charCodeAt(i));
  }
  const tmpUint8Array: Uint8Array = new Uint8Array(arr);
  return tmpUint8Array;
}
// 验签方法
private checkSignature(idToken: string, kid: string, alg: string) {
  if (!idToken) {
    return;
  }
  const parts = idToken.split('.');
  if (parts.length !== 3) {
    return;
  }
  const url = 'https://oauth-login.cloud.huawei.com/oauth2/v3/certs';
  // 创建http请求，应用需在module.json5文件中先申请“ohos.permission.INTERNET”网络权限，请求才能发送成功
  const httpRequest = http.createHttp();
  httpRequest.request(url, (err, data) => {
    if (err) {
      hilog.error(0x0000, 'testTag', `Failed to httpRequest. Code: ${err.code}, message: ${err.message}`);
      httpRequest.destroy();
      return;
    }
    let nStr = '';
    let eStr = '';
    const keys: object[] = JSON.parse(data.result as string)["keys"];
    for (let item of keys) {
      if (kid === item['kid']) {
        nStr = item['n'];
        eStr = item['e'];
        break;
      }
    }
    const nBigInt = '0x' + buffer.from(nStr, "base64url").toString('hex');
    const eBigInt = '0x' + buffer.from(eStr, "base64url").toString('hex');
    const dsaCommonSpec: cryptoFramework.RSACommonParamsSpec = {
      algName: "RSA",
      specType: cryptoFramework.AsyKeySpecType.COMMON_PARAMS_SPEC,
      n: BigInt(nBigInt),
    }
    const rsaKeyPairSpec: cryptoFramework.RSAPubKeySpec = {
      algName: "RSA",
      specType: cryptoFramework.AsyKeySpecType.PUBLIC_KEY_SPEC,
      params: dsaCommonSpec,
      pk: BigInt(eBigInt),
    }
    const asyKeyGeneratorBySpec = cryptoFramework.createAsyKeyGeneratorBySpec(rsaKeyPairSpec);
    asyKeyGeneratorBySpec.generatePubKey(async (error, publicKey) => {
      if (error) {
        return;
      }
      if (publicKey === null) {
        return;
      }
      const idTokenSign = parts[2];
      const idTokenSignArr: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(idTokenSign, "base64url").buffer) };
      const idToken = parts[0] + '.' + parts[1];
      const idTokenArr: cryptoFramework.DataBlob = { data: this.stringToUint8Array(idToken) };
      const verifier = alg === 'PS256' ? cryptoFramework.createVerify("RSA2048|PSS|SHA256|MGF1_SHA256")
        : cryptoFramework.createVerify("RSA2048|PKCS1|SHA256");
      verifier.init(publicKey, (initErr, result) => {
        verifier.verify(idTokenArr, idTokenSignArr, (verifyErr, data) => {
          // 打印验签结果，结果为true则验签通过
          hilog.info(0x0000, 'testTag', 'verify result is: %{public}s', data);
        });
      });
    })
    httpRequest.destroy();
  });
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/account-faq-8
爬取时间: 2025-05-08 07:02:25
来源: Huawei Developer


开发者可以进入设置-系统-开发者选项，点击USB调试开关，会校验健康使用设备密码，校验成功后可解除开发者调试模式限制。


如开发者重新开启USB调试开关后，发现DevEco Studio工具上hilog日志未恢复到断连之前，请执行“hdc shell hilog -G 16M”来扩大hilog日志缓存区，若hilog日志仍无法完全展示，可取出hilog日志本地查看。更多命令请参见hilog。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/account-faq-9
爬取时间: 2025-05-08 07:02:35
来源: Huawei Developer


终端设备从HarmonyOS 3.x/4.x（简称HarmonyOS）升级到HarmonyOS NEXT/5.0.x及之后版本（简称HarmonyOS NEXT）。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161110.14271316746384568095767225675209:50001231000000:2800:4B2A41595D373D2736E7327EE66DFA8F2F760EBACD14160ED6246E2AD0482464.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/account-faq-10
爬取时间: 2025-05-08 07:02:45
来源: Huawei Developer


推荐使用华为账号的UnionID/OpenID作为用户的主要标识，并将应用与华为账号绑定的手机号关联。华为账号的UnionID/OpenID不会发生变化，即使换绑手机号，仍然可以使用华为账号登录原来绑定的应用账号。该方式可以保障应用账号在多设备多场景多应用服务类型间（如应用、元服务等）的互联互通，保证应用的统一体验。若应用使用手机号作为用户的主要标识，如果华为账号换绑了手机号，再登录应用，就是新手机号对应的账号。华为账号一键登录详细流程请参考用户场景设计。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/account-faq-11
爬取时间: 2025-05-08 07:02:55
来源: Huawei Developer


如果应用处于后台，可以在应用切换至前台时进行页面内容的刷新。开发者可自行关注应用后台行为是否需要中断，例如是否需要中断后台播放的音视频内容等，避免未成年人绕过限制，继续访问非适龄内容。


如果应用处于前台（用户正在浏览内容或播放音视频等场景），可以在监听到状态变化后回到应用的主页，并将主页内容刷新为当前模式下的适龄内容。如果未及时刷新，可能存在未成年用户浏览到非适龄内容绕过管控，或成年用户仍浏览未成年人模式下的内容，无法关闭未成年人模式的情况。刷新后的未成年人模式主页可参考如下设计：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161116.22701948078195547372625477703853:50001231000000:2800:561E2AE5B34D2D621F7FAC518CD6CD4B69E36C3F0BE13D9DC522D2DE16196CAE.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/account-faq-12
爬取时间: 2025-05-08 07:03:04
来源: Huawei Developer


远程守护是未成年人模式的一个特殊场景，支持家长在自己设备上远程管理未成年人的设备。远程守护开启时，由于没有本地的六位数字家长密码，目前暂不支持在未成年人的设备上验证家长密码。详情可参考远程守护章节。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-wallet-kit
爬取时间: 2025-05-08 07:03:14
来源: Huawei Developer

- 华为Wallet Kit服务支持哪些国家/地区？
- 开发者应用使用Wallet Kit，是否需要集成华为Account Kit？
- 如果用户没有登录华为账号，添加卡券时如何处理？
- 现有提供的几种接入方式中，比较常用的是哪种？
- 添加卡券时商户服务器主要需要执行哪些步骤？
- 如何查看已添加卡券？
- 用户领取了同一商户的多张卡券，但是打开华为钱包后只显示一张卡券
- 用户删卡时会删除哪些信息？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wallet-faq-1
爬取时间: 2025-05-08 07:03:23
来源: Huawei Developer


华为Wallet Kit服务支持的国家/地区范围和Account Kit一致。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wallet-faq-2
爬取时间: 2025-05-08 07:03:33
来源: Huawei Developer


不需要，但用户添加卡券时，需要登录华为账号。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wallet-faq-3
爬取时间: 2025-05-08 07:03:43
来源: Huawei Developer


如果用户没有登录华为账号，Wallet Kit先会拉起华为账号注册登录页面，用户注册或登录华为账号后才能保存卡券到华为钱包。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wallet-faq-4
爬取时间: 2025-05-08 07:03:53
来源: Huawei Developer


目前比较常用的是用户申领后，通过邮件/短信方式保存卡券，JWE的方式链接内容较少，对网络资源依赖较小。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wallet-faq-5
爬取时间: 2025-05-08 07:04:03
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wallet-faq-6
爬取时间: 2025-05-08 07:04:12
来源: Huawei Developer


在手机中下载最新版本华为钱包应用，登录已绑定卡券的账号即可查看已添加的卡券。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wallet-faq-7
爬取时间: 2025-05-08 07:04:22
来源: Huawei Developer


请检查申请钥匙卡片的请求参数的serialNumber和organizationPassId字段是否都是唯一的。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/wallet-faq-8
爬取时间: 2025-05-08 07:04:32
来源: Huawei Developer


用户删卡时华为服务器会将卡券实例Instance和绑定的用户信息删除。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-share-kit
爬取时间: 2025-05-08 07:04:41
来源: Huawei Developer

- 拉起系统分享框失败
- 分享数据类型不支持

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/share-faq-1
爬取时间: 2025-05-08 07:04:50
来源: Huawei Developer


现象描述：


无法拉起系统分享框


可能原因：


处理步骤：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/share-faq-2
爬取时间: 2025-05-08 07:05:00
来源: Huawei Developer


现象描述：


原因：


处理步骤：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-weather-service-kit
爬取时间: 2025-05-08 07:05:26
来源: Huawei Developer

- 如何获取指定城市的天气数据？
- Weather Service Kit接口有定位功能吗？
- 请求了分钟级降水预报/天气预警/潮汐，未返回任何数据。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/weather-service-faq-1
爬取时间: 2025-05-08 07:05:36
来源: Huawei Developer


先调用getAddressesFromLocationName方法获取指定城市的经纬度信息，然后根据返回的经纬度数据调用getWeather方法获取天气数据。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/weather-service-faq-3
爬取时间: 2025-05-08 07:05:45
来源: Huawei Developer


如果查询区域当时无短时降水、无天气预警发布或预警已经解除、无潮汐站点时，没有数据返回属于正常现象。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-fusion-kit
爬取时间: 2025-05-08 07:06:49
来源: Huawei Developer

- 单击快速验证手机号按钮，无法拉起半模态页面
- 打开应用功能跳转第三方应用失败
- 剪贴板粘贴框遮挡智能填充选择框

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scenario-fusion-faq-1
爬取时间: 2025-05-08 07:06:59
来源: Huawei Developer


现象描述


日志报错示例：


```typescript
login fail, error: {"code":1001502014,"message":"The app does not have the required scopes or permissions."}
```


解决措施


未申请Scope权限，请参考配置权限文档进行操作。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scenario-fusion-faq-2
爬取时间: 2025-05-08 07:07:09
来源: Huawei Developer


现象描述


日志报错示例：


```typescript
startAbility failed, code is 16000018, message is The application is not allow jumping to other applications when api version is above 11.
```


解决措施


需要执行命令手动开启限制开关。


```typescript
hdc shell param set persist.sys.abilityms.support.start_other_app true
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/scenario-fusion-faq-3
爬取时间: 2025-05-08 07:07:20
来源: Huawei Developer


现象描述

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161120.06897373918861378618342440527821:50001231000000:2800:CDFF63374ACA994A4464D2D83424DAF6EA3065FC7B522D974201BF57A63E9C84.jpg)

解决措施


在代码文件中设置.selectionMenuHidden(true)，使剪贴板粘贴框隐藏。


```typescript
      Row() { 
        Text('收货人：').textAlign(TextAlign.End).width('25%') 
        TextInput().width('75%').contentType(ContentType.PERSON_FULL_NAME).selectionMenuHidden(true) 
      }
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ads-kit
爬取时间: 2025-05-08 07:07:30
来源: Huawei Developer

- 展示广告时显示白屏
- 鲸鸿动能媒体服务平台打开受限

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/ads-publisher-service-faq-4
爬取时间: 2025-05-08 07:07:40
来源: Huawei Developer


展示广告时出现白屏可能原因为展示的广告样式与UI展示页面不匹配，横幅广告使用AutoAdComponent组件展示；原生广告、开屏广告、贴片广告使用AdComponent组件展示；激励广告、插屏广告调用showAd方法展示。


建议排查手段：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/ads-publisher-service-faq-5
爬取时间: 2025-05-08 07:07:50
来源: Huawei Developer


原生广告展示采用的是广告高级UI组件AdComponent，此组件展示广告要求传入的数据为一个广告数组（Advertisement[]）。为了适应开发者请求多个广告而只选择一个展示的情况，组件内部逻辑默认只展示广告数组的第一个数据，即Advertisement[0]。因此开发者如果需要展示指定的广告样式，需要自己构造一个广告数据并把需要展示的广告放在数据的第一位。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/ads-publisher-service-faq-6
爬取时间: 2025-05-08 07:08:00
来源: Huawei Developer


受制于您所在国家/地区的外汇管制、税务处理等因素，您所在的国家/地区尚未对个人开发者开放鲸鸿动能流量变现服务，您需要实名认证成为华为开发者联盟的企业开发者，包括获得应用开发者合法授权的企业。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-store-kit
爬取时间: 2025-05-08 07:08:10
来源: Huawei Developer

- 是否能在删除商品后添加具有相同productId的商品？
- 数字商品服务器支持证书
- 数字商品服务器支持加密套件
- 数字商品服务中订单订购状态有哪些？
- 订阅商品的续费周期规则是什么？
- 订阅型商品中的续费周期1个月是指30天、31天还是自然月？同理，2个月、3个月具体包含多少天数？
- 订阅时长按照自然月计算时，2月份是28天还是29天？
- 应用市场推荐展示元服务卡片异常
- 按需加载场景中加载动态模块失败
- 按需加载模块是否支持单独上架应用市场或单独更新？
- 按需加载场景中，应用在加载指定模块后重启，还是已加载状态吗？是否需要重新发起按需加载请求？
- 按需加载场景中，用户在加载指定模块后是否可以卸载，然后重新发起请求？
- 未上架应用市场的应用如何快速接入调试产品特性按需分发功能？
- 生态查询服务场景中获取自身场景值为空
- 应用市场更新功能抛出不在前台异常
- 向用户显示应用更新提示弹框文案能否自定义？
- 调用应用归因服务登记归因来源接口报错身份检查错误
- 如何过滤应用归因服务的日志？
- 如何过滤应用内快捷方式加桌的日志？
- 应用内快捷方式加桌返回401错误码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-18
爬取时间: 2025-05-08 07:08:20
来源: Huawei Developer


不支持。同一个productId只能使用一次。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-19
爬取时间: 2025-05-08 07:08:30
来源: Huawei Developer


数字商品服务器内置了如下92个证书，请检查开发者证书链，确保证书链的完整性，同时确保证书链中的证书在数字商品服务器支持证书表格中。


| #  | Alias name  | Subject DN  | Issuer DN  | Certificate Serial Number  | Version  | Valid From [GMT]  | Valid To [GMT]  | Thumbprint(SHA1)  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1  | verisignclass2g2ca [jdk]  | OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 2 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US  | OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 2 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US  | b92f60cc889fa17a4609b85b706c8aaf  | 1  | Mon May 18 03:00:00 IDT 1998  | Wed Aug 02 02:59:59 IDT 2028  | B3:EA:C4:47:76:C9:C8:1C:EA:F2:9D:95:B6:CC:A0:08:1B:67:EC:9D  |
| 2  | digicertassuredidg3 [jdk]  | CN=DigiCert Assured ID Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Assured ID Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US  | ba15afa1ddfa0b54944afcd24a06cec  | 3  | Thu Aug 01 15:00:00 IDT 2013  | Fri Jan 15 14:00:00 IST 2038  | F5:17:A2:4F:9A:48:C6:C9:F8:A2:00:26:9F:DC:0F:48:2C:AB:30:89  |
| 3  | verisignuniversalrootca [jdk]  | CN=VeriSign Universal Root Certification Authority, OU=”(c) 2008 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | CN=VeriSign Universal Root Certification Authority, OU=”(c) 2008 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | 401ac46421b31321030ebbe4121ac51d  | 3  | Wed Apr 02 03:00:00 IDT 2008  | Wed Dec 02 01:59:59 IST 2037  | 36:79:CA:35:66:87:72:30:4D:30:A5:FB:87:3B:0F:A7:7B:B7:0D:54  |
| 4  | digicerttrustedrootg4 [jdk]  | CN=DigiCert Trusted Root G4, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Trusted Root G4, OU=www.digicert.com, O=DigiCert Inc, C=US  | 59b1b579e8e2132e23907bda777755c  | 3  | Thu Aug 01 15:00:00 IDT 2013  | Fri Jan 15 14:00:00 IST 2038  | DD:FB:16:CD:49:31:C9:73:A2:03:7D:3F:C8:3A:4D:7D:77:5D:05:E4  |
| 5  | identrustpublicca [jdk]  | CN=IdenTrust Public Sector Root CA 1, O=IdenTrust, C=US  | CN=IdenTrust Public Sector Root CA 1, O=IdenTrust, C=US  | a0142800000014523cf467c00000002  | 3  | Thu Jan 16 19:53:32 IST 2014  | Mon Jan 16 19:53:32 IST 2034  | BA:29:41:60:77:98:3F:F4:F3:EF:F2:31:05:3B:2E:EA:6D:4D:45:FD  |
| 6  | utnuserfirstobjectca [jdk]  | CN=UTN-USERFirst-Object, OU=http://www.usertrust.com, O=The USERTRUST Network, L=Salt Lake City, ST=UT, C=US  | CN=UTN-USERFirst-Object, OU=http://www.usertrust.com, O=The USERTRUST Network, L=Salt Lake City, ST=UT, C=US  | 44be0c8b500024b411d3362de0b35f1b  | 3  | Fri Jul 09 21:31:20 IDT 1999  | Tue Jul 09 21:40:36 IDT 2019  | E1:2D:FB:4B:41:D7:D9:C3:2B:30:51:4B:AC:1D:81:D8:38:5E:2D:46  |
| 7  | geotrustuniversalca [jdk]  | CN=GeoTrust Universal CA, O=GeoTrust Inc., C=US  | CN=GeoTrust Universal CA, O=GeoTrust Inc., C=US  | 1  | 3  | Thu Mar 04 07:00:00 IST 2004  | Sun Mar 04 07:00:00 IST 2029  | E6:21:F3:35:43:79:05:9A:4B:68:30:9D:8A:2F:74:22:15:87:EC:79  |
| 8  | digicertglobalrootg3 [jdk]  | CN=DigiCert Global Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Global Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US  | 55556bcf25ea43535c3a40fd5ab4572  | 3  | Thu Aug 01 15:00:00 IDT 2013  | Fri Jan 15 14:00:00 IST 2038  | 7E:04:DE:89:6A:3E:66:6D:00:E6:87:D3:3F:FA:D9:3B:E8:3D:34:9E  |
| 9  | entrustrootcaec1 [jdk]  | CN=Entrust Root Certification Authority - EC1, OU=”(c) 2012 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US  | CN=Entrust Root Certification Authority - EC1, OU=”(c) 2012 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US  | a68b79290000000050d091f9  | 3  | Tue Dec 18 17:25:36 IST 2012  | Fri Dec 18 17:55:36 IST 2037  | 20:D8:06:40:DF:9B:25:F5:12:25:3A:11:EA:F7:59:8A:EB:14:B5:47  |
| 10  | secomscrootca1 [jdk]  | OU=Security Communication RootCA1, O=SECOM Trust.net, C=JP  | OU=Security Communication RootCA1, O=SECOM Trust.net, C=JP  | 0  | 3  | Tue Sep 30 07:20:49 IDT 2003  | Sat Sep 30 07:20:49 IDT 2023  | 36:B1:2B:49:F9:81:9E:D7:4C:9E:BC:38:0F:C6:56:8F:5D:AC:B2:F7  |
| 11  | globalsignr2ca [jdk]  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R2  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R2  | 400000000010f8626e60d  | 3  | Fri Dec 15 10:00:00 IST 2006  | Wed Dec 15 10:00:00 IST 2021  | 75:E0:AB:B6:13:85:12:27:1C:04:F8:5F:DD:DE:38:E4:B7:24:2E:FE  |
| 12  | identrustdstx3 [jdk]  | CN=DST Root CA X3, O=Digital Signature Trust Co.  | CN=DST Root CA X3, O=Digital Signature Trust Co.  | 44afb080d6a327ba893039862ef8406b  | 3  | Sun Oct 01 00:12:19 IDT 2000  | Thu Sep 30 17:01:15 IDT 2021  | DA:C9:02:4F:54:D8:F6:DF:94:93:5F:B1:73:26:38:CA:6A:D7:7C:13  |
| 13  | comodoeccca [jdk]  | CN=COMODO ECC Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB  | CN=COMODO ECC Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB  | 1f47afaa62007050544c019e9b63992a  | 3  | Thu Mar 06 02:00:00 IST 2008  | Tue Jan 19 01:59:59 IST 2038  | 9F:74:4E:9F:2B:4D:BA:EC:0F:31:2C:50:B6:56:3B:8E:2D:93:C3:11  |
| 14  | entrust2048ca [jdk]  | CN=Entrust.net Certification Authority (2048), OU=(c) 1999 Entrust.net Limited, OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.), O=Entrust.net  | CN=Entrust.net Certification Authority (2048), OU=(c) 1999 Entrust.net Limited, OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.), O=Entrust.net  | 3863def8  | 3  | Fri Dec 24 19:50:51 IST 1999  | Tue Jul 24 17:15:12 IDT 2029  | 50:30:06:09:1D:97:D4:F5:AE:39:F7:CB:E7:92:7D:7D:65:2D:34:31  |
| 15  | addtrustexternalca [jdk]  | CN=AddTrust External CA Root, OU=AddTrust External TTP Network, O=AddTrust AB, C=SE  | CN=AddTrust External CA Root, OU=AddTrust External TTP Network, O=AddTrust AB, C=SE  | 1  | 3  | Tue May 30 13:48:38 IDT 2000  | Sat May 30 13:48:38 IDT 2020  | 02:FA:F3:E2:91:43:54:68:60:78:57:69:4D:F5:E4:5B:68:85:18:68  |
| 16  | globalsigneccrootcar4 [jdk]  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R4  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R4  | 2a38a41c960a04de42b228a50be8349802  | 3  | Tue Nov 13 02:00:00 IST 2012  | Tue Jan 19 05:14:07 IST 2038  | 69:69:56:2E:40:80:F4:24:A1:E7:19:9F:14:BA:F3:EE:58:AB:6A:BB  |
| 17  | usertrustrsaca [jdk]  | CN=USERTrust RSA Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US  | CN=USERTrust RSA Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US  | 1fd6d30fca3ca51a81bbc640e35032d  | 3  | Mon Feb 01 02:00:00 IST 2010  | Tue Jan 19 01:59:59 IST 2038  | 2B:8F:1B:57:33:0D:BB:A2:D0:7A:6C:51:F7:0E:E9:0D:DA:B9:AD:8E  |
| 18  | digicertassuredidrootca [jdk]  | CN=DigiCert Assured ID Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Assured ID Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US  | ce7e0e517d846fe8fe560fc1bf03039  | 3  | Fri Nov 10 02:00:00 IST 2006  | Mon Nov 10 02:00:00 IST 2031  | 05:63:B8:63:0D:62:D7:5A:BB:C8:AB:1E:4B:DF:B5:A8:99:B2:4D:43  |
| 19  | digicertglobalrootg2 [jdk]  | CN=DigiCert Global Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Global Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US  | 33af1e6a711a9a0bb2864b11d09fae5  | 3  | Thu Aug 01 15:00:00 IDT 2013  | Fri Jan 15 14:00:00 IST 2038  | DF:3C:24:F9:BF:D6:66:76:1B:26:80:73:FE:06:D1:CC:8D:4F:82:A4  |
| 20  | actalisauthenticationrootca [jdk]  | CN=Actalis Authentication Root CA, O=Actalis S.p.A./03358520967, L=Milan, C=IT  | CN=Actalis Authentication Root CA, O=Actalis S.p.A./03358520967, L=Milan, C=IT  | 570a119742c4e3cc  | 3  | Thu Sep 22 14:22:02 IDT 2011  | Sun Sep 22 14:22:02 IDT 2030  | F3:73:B3:87:06:5A:28:84:8A:F2:F3:4A:CE:19:2B:DD:C7:8E:9C:AC  |
| 21  | digicertassuredidg2 [jdk]  | CN=DigiCert Assured ID Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Assured ID Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US  | b931c3ad63967ea6723bfc3af9af44b  | 3  | Thu Aug 01 15:00:00 IDT 2013  | Fri Jan 15 14:00:00 IST 2038  | A1:4B:48:D9:43:EE:0A:0E:40:90:4F:3C:E0:A4:C0:91:93:51:5D:3F  |
| 22  | swisssigngoldg2ca [jdk]  | CN=SwissSign Gold CA - G2, O=SwissSign AG, C=CH  | CN=SwissSign Gold CA - G2, O=SwissSign AG, C=CH  | bb401c43f55e4fb0  | 3  | Wed Oct 25 10:30:35 IST 2006  | Sat Oct 25 11:30:35 IDT 2036  | D8:C5:38:8A:B7:30:1B:1B:6E:D4:7A:E6:45:25:3A:6F:9F:1A:27:61  |
| 23  | entrustrootcag2 [jdk]  | CN=Entrust Root Certification Authority - G2, OU=”(c) 2009 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US  | CN=Entrust Root Certification Authority - G2, OU=”(c) 2009 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US  | 4a538c28  | 3  | Tue Jul 07 20:25:54 IDT 2009  | Sat Dec 07 19:55:54 IST 2030  | 8C:F4:27:FD:79:0C:3A:D1:66:06:8D:E8:1E:57:EF:BB:93:22:72:D4  |
| 24  | quovadisrootca2g3 [jdk]  | CN=QuoVadis Root CA 2 G3, O=QuoVadis Limited, C=BM  | CN=QuoVadis Root CA 2 G3, O=QuoVadis Limited, C=BM  | 445734245b81899b35f2ceb82b3b5ba726f07528  | 3  | Thu Jan 12 20:59:32 IST 2012  | Sun Jan 12 20:59:32 IST 2042  | 09:3C:61:F3:8B:8B:DC:7D:55:DF:75:38:02:05:00:E1:25:F5:C8:36  |
| 25  | securetrustca [jdk]  | CN=SecureTrust CA, O=SecureTrust Corporation, C=US  | CN=SecureTrust CA, O=SecureTrust Corporation, C=US  | cf08e5c0816a5ad427ff0eb271859d0  | 3  | Tue Nov 07 21:31:18 IST 2006  | Mon Dec 31 21:40:55 IST 2029  | 87:82:C6:C3:04:35:3B:CF:D2:96:92:D2:59:3E:7D:44:D9:34:FF:11  |
| 26  | camerfirmachambersca [jdk]  | CN=Chambers of Commerce Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU  | CN=Chambers of Commerce Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU  | a3da427ea4b1aeda  | 3  | Fri Aug 01 15:29:50 IDT 2008  | Sat Jul 31 15:29:50 IDT 2038  | 78:6A:74:AC:76:AB:14:7F:9C:6A:30:50:BA:9E:A8:7E:FE:9A:CE:3C  |
| 27  | geotrustprimaryca [jdk]  | CN=GeoTrust Primary Certification Authority, O=GeoTrust Inc., C=US  | CN=GeoTrust Primary Certification Authority, O=GeoTrust Inc., C=US  | 18acb56afd69b6153a636cafdafac4a1  | 3  | Mon Nov 27 02:00:00 IST 2006  | Thu Jul 17 02:59:59 IDT 2036  | 32:3C:11:8E:1B:F7:B8:B6:52:54:E2:E2:10:0D:D6:02:90:37:F0:96  |
| 28  | identrustcommercial [jdk]  | CN=IdenTrust Commercial Root CA 1, O=IdenTrust, C=US  | CN=IdenTrust Commercial Root CA 1, O=IdenTrust, C=US  | a0142800000014523c844b500000002  | 3  | Thu Jan 16 20:12:23 IST 2014  | Mon Jan 16 20:12:23 IST 2034  | DF:71:7E:AA:4A:D9:4E:C9:55:84:99:60:2D:48:DE:5F:BC:F0:3A:25  |
| 29  | thawteprimaryrootcag3 [jdk]  | CN=thawte Primary Root CA - G3, OU=”(c) 2008 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US  | CN=thawte Primary Root CA - G3, OU=”(c) 2008 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US  | 600197b746a7eab4b49ad64b2ff790fb  | 3  | Wed Apr 02 03:00:00 IDT 2008  | Wed Dec 02 01:59:59 IST 2037  | F1:8B:53:8D:1B:E9:03:B6:A6:F0:56:43:5B:17:15:89:CA:F3:6B:F2  |
| 30  | buypassclass3ca [jdk]  | CN=Buypass Class 3 Root CA, O=Buypass AS-983163327, C=NO  | CN=Buypass Class 3 Root CA, O=Buypass AS-983163327, C=NO  | 2  | 3  | Tue Oct 26 10:28:58 IST 2010  | Fri Oct 26 11:28:58 IDT 2040  | DA:FA:F7:FA:66:84:EC:06:8F:14:50:BD:C7:C2:81:A5:BC:A9:64:57  |
| 31  | verisigntsaca [jdk]  | CN=Thawte Timestamping CA, OU=Thawte Certification, O=Thawte, L=Durbanville, ST=Western Cape, C=ZA  | CN=Thawte Timestamping CA, OU=Thawte Certification, O=Thawte, L=Durbanville, ST=Western Cape, C=ZA  | 67c8e1e8e3be1cbdfc913b8ea6238749  | 3  | Wed Jan 01 02:00:00 IST 1997  | Sat Jan 02 01:59:59 IST 2021  | 20:CE:B1:F0:F5:1C:0E:19:A9:F3:8D:B1:AA:8E:03:8C:AA:7A:C7:01  |
| 32  | verisignclass3g4ca [jdk]  | CN=VeriSign Class 3 Public Primary Certification Authority - G4, OU=”(c) 2007 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | CN=VeriSign Class 3 Public Primary Certification Authority - G4, OU=”(c) 2007 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | 2f80fe238c0e220f486712289187acb3  | 3  | Mon Nov 05 02:00:00 IST 2007  | Tue Jan 19 01:59:59 IST 2038  | 22:D5:D8:DF:8F:02:31:D1:8D:F7:9D:B7:CF:8A:2D:64:C9:3F:6C:3A  |
| 33  | baltimorecybertrustca [jdk]  | CN=Baltimore CyberTrust Root, OU=CyberTrust, O=Baltimore, C=IE  | CN=Baltimore CyberTrust Root, OU=CyberTrust, O=Baltimore, C=IE  | 20000b9  | 3  | Fri May 12 21:46:00 IDT 2000  | Tue May 13 02:59:00 IDT 2025  | D4:DE:20:D0:5E:66:FC:53:FE:1A:50:88:2C:78:DB:28:52:CA:E4:74  |
| 34  | luxtrustglobalrootca [jdk]  | CN=LuxTrust Global Root, O=LuxTrust s.a., C=LU  | CN=LuxTrust Global Root, O=LuxTrust s.a., C=LU  | bb8  | 3  | Thu Mar 17 11:51:37 IST 2011  | Wed Mar 17 11:51:37 IST 2021  | C9:3C:34:EA:90:D9:13:0C:0F:03:00:4B:98:BD:8B:35:70:91:56:11  |
| 35  | verisignclass3g2ca [jdk]  | OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 3 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US  | OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 3 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US  | 7dd9fe07cfa81eb7107967fba78934c6  | 1  | Mon May 18 03:00:00 IDT 1998  | Wed Aug 02 02:59:59 IDT 2028  | 85:37:1C:A6:E5:50:14:3D:CE:28:03:47:1B:DE:3A:09:E8:F8:77:0F  |
| 36  | camerfirmachamberscommerceca [jdk]  | CN=Chambers of Commerce Root, OU=http://www.chambersign.org, O=AC Camerfirma SA CIF A82743287, C=EU  | CN=Chambers of Commerce Root, OU=http://www.chambersign.org, O=AC Camerfirma SA CIF A82743287, C=EU  | 0  | 3  | Tue Sep 30 19:13:43 IDT 2003  | Wed Sep 30 19:13:44 IDT 2037  | 6E:3A:55:A4:19:0C:19:5C:93:84:3C:C0:DB:72:2E:31:30:61:F0:B1  |
| 37  | soneraclass2ca [jdk]  | CN=Sonera Class2 CA, O=Sonera, C=FI  | CN=Sonera Class2 CA, O=Sonera, C=FI  | 1d  | 3  | Fri Apr 06 09:29:40 IST 2001  | Tue Apr 06 10:29:40 IDT 2021  | 37:F7:6D:E6:07:7C:90:C5:B1:3E:93:1A:B7:41:10:B4:F2:E4:9A:27  |
| 38  | affirmtrustnetworkingca [jdk]  | CN=AffirmTrust Networking, O=AffirmTrust, C=US  | CN=AffirmTrust Networking, O=AffirmTrust, C=US  | 7c4f04391cd4992d  | 3  | Fri Jan 29 16:08:24 IST 2010  | Tue Dec 31 16:08:24 IST 2030  | 29:36:21:02:8B:20:ED:02:F5:66:C5:32:D1:D6:ED:90:9F:45:00:2F  |
| 39  | ttelesecglobalrootclass3ca [jdk]  | CN=T-TeleSec GlobalRoot Class 3, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE  | CN=T-TeleSec GlobalRoot Class 3, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE  | 1  | 3  | Wed Oct 01 13:29:56 IDT 2008  | Sun Oct 02 02:59:59 IDT 2033  | 55:A6:72:3E:CB:F2:EC:CD:C3:23:74:70:19:9D:2A:BE:11:E3:81:D1  |
| 40  | xrampglobalca [jdk]  | CN=XRamp Global Certification Authority, O=XRamp Security Services Inc, OU=www.xrampsecurity.com, C=US  | CN=XRamp Global Certification Authority, O=XRamp Security Services Inc, OU=www.xrampsecurity.com, C=US  | 50946cec18ead59c4dd597ef758fa0ad  | 3  | Mon Nov 01 19:14:04 IST 2004  | Mon Jan 01 07:37:19 IST 2035  | B8:01:86:D1:EB:9C:86:A5:41:04:CF:30:54:F3:4C:52:B7:E5:58:C6  |
| 41  | geotrustprimarycag3 [jdk]  | CN=GeoTrust Primary Certification Authority - G3, OU=(c) 2008 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US  | CN=GeoTrust Primary Certification Authority - G3, OU=(c) 2008 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US  | 15ac6e9419b2794b41f627a9c3180f1f  | 3  | Wed Apr 02 03:00:00 IDT 2008  | Wed Dec 02 01:59:59 IST 2037  | 03:9E:ED:B8:0B:E7:A0:3C:69:53:89:3B:20:D2:D9:32:3A:4C:2A:FD  |
| 42  | camerfirmachambersignca [jdk]  | CN=Global Chambersign Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU  | CN=Global Chambersign Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU  | c9cdd3e9d57d23ce  | 3  | Fri Aug 01 15:31:40 IDT 2008  | Sat Jul 31 15:31:40 IDT 2038  | 4A:BD:EE:EC:95:0D:35:9C:89:AE:C7:52:A1:2C:5B:29:F6:D6:AA:0C  |
| 43  | thawteprimaryrootcag2 [jdk]  | CN=thawte Primary Root CA - G2, OU=”(c) 2007 thawte, Inc. - For authorized use only”, O=”thawte, Inc.”, C=US  | CN=thawte Primary Root CA - G2, OU=”(c) 2007 thawte, Inc. - For authorized use only”, O=”thawte, Inc.”, C=US  | 35fc265cd9844fc93d263d579baed756  | 3  | Mon Nov 05 02:00:00 IST 2007  | Tue Jan 19 01:59:59 IST 2038  | AA:DB:BC:22:23:8F:C4:01:A1:27:BB:38:DD:F4:1D:DB:08:9E:F0:12  |
| 44  | usertrusteccca [jdk]  | CN=USERTrust ECC Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US  | CN=USERTrust ECC Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US  | 5c8b99c55a94c5d27156decd8980cc26  | 3  | Mon Feb 01 02:00:00 IST 2010  | Tue Jan 19 01:59:59 IST 2038  | D1:CB:CA:5D:B2:D5:2A:7F:69:3B:67:4D:E5:F0:5A:1D:0C:95:7D:F0  |
| 45  | swisssignsilverg2ca [jdk]  | CN=SwissSign Silver CA - G2, O=SwissSign AG, C=CH  | CN=SwissSign Silver CA - G2, O=SwissSign AG, C=CH  | 4f1bd42f54bb2f4b  | 3  | Wed Oct 25 10:32:46 IST 2006  | Sat Oct 25 11:32:46 IDT 2036  | 9B:AA:E5:9F:56:EE:21:CB:43:5A:BE:25:93:DF:A7:F0:40:D1:1D:CB  |
| 46  | affirmtrustpremiumca [jdk]  | CN=AffirmTrust Premium, O=AffirmTrust, C=US  | CN=AffirmTrust Premium, O=AffirmTrust, C=US  | 6d8c1446b1a60aee  | 3  | Fri Jan 29 16:10:36 IST 2010  | Mon Dec 31 16:10:36 IST 2040  | D8:A6:33:2C:E0:03:6F:B1:85:F6:63:4F:7D:6A:06:65:26:32:28:27  |
| 47  | globalsignca [jdk]  | CN=GlobalSign Root CA, OU=Root CA, O=GlobalSign nv-sa, C=BE  | CN=GlobalSign Root CA, OU=Root CA, O=GlobalSign nv-sa, C=BE  | 40000000001154b5ac394  | 3  | Tue Sep 01 15:00:00 IDT 1998  | Fri Jan 28 14:00:00 IST 2028  | B1:BC:96:8B:D4:F4:9D:62:2A:A8:9A:81:F2:15:01:52:A4:1D:82:9C  |
| 48  | dtrustclass3ca2 [jdk]  | CN=D-TRUST Root Class 3 CA 2 2009, O=D-Trust GmbH, C=DE  | CN=D-TRUST Root Class 3 CA 2 2009, O=D-Trust GmbH, C=DE  | 983f3  | 3  | Thu Nov 05 10:35:58 IST 2009  | Mon Nov 05 10:35:58 IST 2029  | 58:E8:AB:B0:36:15:33:FB:80:F7:9B:1B:6D:29:D3:FF:8D:5F:00:F0  |
| 49  | affirmtrustcommercialca [jdk]  | CN=AffirmTrust Commercial, O=AffirmTrust, C=US  | CN=AffirmTrust Commercial, O=AffirmTrust, C=US  | 7777062726a9b17c  | 3  | Fri Jan 29 16:06:06 IST 2010  | Tue Dec 31 16:06:06 IST 2030  | F9:B5:B6:32:45:5F:9C:BE:EC:57:5F:80:DC:E9:6E:2C:C7:B2:78:B7  |
| 50  | thawtepremiumserverca [jdk]  | EMAILADDRESS=premium-server@thawte.com, CN=Thawte Premium Server CA, OU=Certification Services Division, O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA  | EMAILADDRESS=premium-server@thawte.com, CN=Thawte Premium Server CA, OU=Certification Services Division, O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA  | 36122296c5e338a520a1d25f4cd70954  | 3  | Thu Aug 01 03:00:00 IDT 1996  | Sat Jan 02 01:59:59 IST 2021  | E0:AB:05:94:20:72:54:93:05:60:62:02:36:70:F7:CD:2E:FC:66:66  |
| 51  | comodoaaaca [jdk]  | CN=AAA Certificate Services, O=Comodo CA Limited, L=Salford, ST=Greater Manchester, C=GB  | CN=AAA Certificate Services, O=Comodo CA Limited, L=Salford, ST=Greater Manchester, C=GB  | 1  | 3  | Thu Jan 01 02:00:00 IST 2004  | Mon Jan 01 01:59:59 IST 2029  | D1:EB:23:A4:6D:17:D6:8F:D9:25:64:C2:F1:F1:60:17:64:D8:E3:49  |
| 52  | geotrustprimarycag2 [jdk]  | CN=GeoTrust Primary Certification Authority - G2, OU=(c) 2007 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US  | CN=GeoTrust Primary Certification Authority - G2, OU=(c) 2007 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US  | 3cb2f4480a00e2feeb243b5e603ec36b  | 3  | Mon Nov 05 02:00:00 IST 2007  | Tue Jan 19 01:59:59 IST 2038  | 8D:17:84:D5:37:F3:03:7D:EC:70:FE:57:8B:51:9A:99:E6:10:D7:B0  |
| 53  | globalsignr3ca [jdk]  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R3  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R3  | 4000000000121585308a2  | 3  | Wed Mar 18 12:00:00 IST 2009  | Sun Mar 18 12:00:00 IST 2029  | D6:9B:56:11:48:F0:1C:77:C5:45:78:C1:09:26:DF:5B:85:69:76:AD  |
| 54  | quovadisrootca3 [jdk]  | CN=QuoVadis Root CA 3, O=QuoVadis Limited, C=BM  | CN=QuoVadis Root CA 3, O=QuoVadis Limited, C=BM  | 5c6  | 3  | Fri Nov 24 21:11:23 IST 2006  | Mon Nov 24 21:06:44 IST 2031  | 1F:49:14:F7:D8:74:95:1D:DD:AE:02:C0:BE:FD:3A:2D:82:75:51:85  |
| 55  | thawteprimaryrootca [jdk]  | CN=thawte Primary Root CA, OU=”(c) 2006 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US  | CN=thawte Primary Root CA, OU=”(c) 2006 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US  | 344ed55720d5edec49f42fce37db2b6d  | 3  | Fri Nov 17 02:00:00 IST 2006  | Thu Jul 17 02:59:59 IDT 2036  | 91:C6:D6:EE:3E:8A:C8:63:84:E5:48:C2:99:29:5C:75:6C:81:7B:81  |
| 56  | starfieldrootg2ca [jdk]  | CN=Starfield Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US  | CN=Starfield Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US  | 0  | 3  | Tue Sep 01 03:00:00 IDT 2009  | Fri Jan 01 01:59:59 IST 2038  | B5:1C:06:7C:EE:2B:0C:3D:F8:55:AB:2D:92:F4:FE:39:D4:E7:0F:0E  |
| 57  | starfieldclass2ca [jdk]  | OU=Starfield Class 2 Certification Authority, O=”Starfield Technologies, Inc.”, C=US  | OU=Starfield Class 2 Certification Authority, O=”Starfield Technologies, Inc.”, C=US  | 0  | 3  | Tue Jun 29 20:39:16 IDT 2004  | Thu Jun 29 20:39:16 IDT 2034  | AD:7E:1C:28:B0:64:EF:8F:60:03:40:20:14:C3:D0:E3:37:0E:B5:8A  |
| 58  | verisignclass3ca [jdk]  | OU=Class 3 Public Primary Certification Authority, O=”VeriSign, Inc.”, C=US  | OU=Class 3 Public Primary Certification Authority, O=”VeriSign, Inc.”, C=US  | 3c9131cb1ff6d01b0e9ab8d044bf12be  | 1  | Mon Jan 29 02:00:00 IST 1996  | Thu Aug 03 02:59:59 IDT 2028  | A1:DB:63:93:91:6F:17:E4:18:55:09:40:04:15:C7:02:40:B0:AE:6B  |
| 59  | affirmtrustpremiumeccca [jdk]  | CN=AffirmTrust Premium ECC, O=AffirmTrust, C=US  | CN=AffirmTrust Premium ECC, O=AffirmTrust, C=US  | 7497258ac73f7a54  | 3  | Fri Jan 29 16:20:24 IST 2010  | Mon Dec 31 16:20:24 IST 2040  | B8:23:6B:00:2F:1D:16:86:53:01:55:6C:11:A4:37:CA:EB:FF:C3:BB  |
| 60  | geotrustglobalca [jdk]  | CN=GeoTrust Global CA, O=GeoTrust Inc., C=US  | CN=GeoTrust Global CA, O=GeoTrust Inc., C=US  | 23456  | 3  | Tue May 21 07:00:00 IDT 2002  | Sat May 21 07:00:00 IDT 2022  | DE:28:F4:A4:FF:E5:B9:2F:A3:C5:03:D1:A3:49:A7:F9:96:2A:82:12  |
| 61  | godaddyclass2ca [jdk]  | OU=Go Daddy Class 2 Certification Authority, O=”The Go Daddy Group, Inc.”, C=US  | OU=Go Daddy Class 2 Certification Authority, O=”The Go Daddy Group, Inc.”, C=US  | 0  | 3  | Tue Jun 29 20:06:20 IDT 2004  | Thu Jun 29 20:06:20 IDT 2034  | 27:96:BA:E6:3F:18:01:E2:77:26:1B:A0:D7:77:70:02:8F:20:EE:E4  |
| 62  | godaddyrootg2ca [jdk]  | CN=Go Daddy Root Certificate Authority - G2, O=”GoDaddy.com, Inc.”, L=Scottsdale, ST=Arizona, C=US  | CN=Go Daddy Root Certificate Authority - G2, O=”GoDaddy.com, Inc.”, L=Scottsdale, ST=Arizona, C=US  | 0  | 3  | Tue Sep 01 03:00:00 IDT 2009  | Fri Jan 01 01:59:59 IST 2038  | 47:BE:AB:C9:22:EA:E8:0E:78:78:34:62:A7:9F:45:C2:54:FD:E6:8B  |
| 63  | verisignclass3g5ca [jdk]  | CN=VeriSign Class 3 Public Primary Certification Authority - G5, OU=”(c) 2006 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | CN=VeriSign Class 3 Public Primary Certification Authority - G5, OU=”(c) 2006 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | 18dad19e267de8bb4a2158cdcc6b3b4a  | 3  | Wed Nov 08 02:00:00 IST 2006  | Thu Jul 17 02:59:59 IDT 2036  | 4E:B6:D5:78:49:9B:1C:CF:5F:58:1E:AD:56:BE:3D:9B:67:44:A5:E5  |
| 64  | quovadisrootca2 [jdk]  | CN=QuoVadis Root CA 2, O=QuoVadis Limited, C=BM  | CN=QuoVadis Root CA 2, O=QuoVadis Limited, C=BM  | 509  | 3  | Fri Nov 24 20:27:00 IST 2006  | Mon Nov 24 20:23:33 IST 2031  | CA:3A:FB:CF:12:40:36:4B:44:B2:16:20:88:80:48:39:19:93:7C:F7  |
| 65  | certumca [jdk]  | CN=Certum CA, O=Unizeto Sp. z o.o., C=PL  | CN=Certum CA, O=Unizeto Sp. z o.o., C=PL  | 10020  | 3  | Tue Jun 11 13:46:39 IDT 2002  | Fri Jun 11 13:46:39 IDT 2027  | 62:52:DC:40:F7:11:43:A2:2F:DE:9E:F7:34:8E:06:42:51:B1:81:18  |
| 66  | swisssignplatinumg2ca [jdk]  | CN=SwissSign Platinum CA - G2, O=SwissSign AG, C=CH  | CN=SwissSign Platinum CA - G2, O=SwissSign AG, C=CH  | 4eb200670c035d4f  | 3  | Wed Oct 25 10:36:00 IST 2006  | Sat Oct 25 11:36:00 IDT 2036  | 56:E0:FA:C0:3B:8F:18:23:55:18:E5:D3:11:CA:E8:C2:43:31:AB:66  |
| 67  | chunghwaepkirootca [jdk]  | OU=ePKI Root Certification Authority, O=”Chunghwa Telecom Co., Ltd.”, C=TW  | OU=ePKI Root Certification Authority, O=”Chunghwa Telecom Co., Ltd.”, C=TW  | 15c8bd65475cafb897005ee406d2bc9d  | 3  | Mon Dec 20 04:31:27 IST 2004  | Wed Dec 20 04:31:27 IST 2034  | 67:65:0D:F1:7E:8E:7E:5B:82:40:A4:F4:56:4B:CF:E2:3D:69:C6:F0  |
| 68  | quovadisrootca3g3 [jdk]  | CN=QuoVadis Root CA 3 G3, O=QuoVadis Limited, C=BM  | CN=QuoVadis Root CA 3 G3, O=QuoVadis Limited, C=BM  | 2ef59b0228a7db7affd5a3a9eebd03a0cf126a1d  | 3  | Thu Jan 12 22:26:32 IST 2012  | Sun Jan 12 22:26:32 IST 2042  | 48:12:BD:92:3C:A8:C4:39:06:E7:30:6D:27:96:E6:A4:CF:22:2E:7D  |
| 69  | quovadisrootca [jdk]  | CN=QuoVadis Root Certification Authority, OU=Root Certification Authority, O=QuoVadis Limited, C=BM  | CN=QuoVadis Root Certification Authority, OU=Root Certification Authority, O=QuoVadis Limited, C=BM  | 3ab6508b  | 3  | Mon Mar 19 20:33:33 IST 2001  | Wed Mar 17 20:33:33 IST 2021  | DE:3F:40:BD:50:93:D3:9B:6C:60:F6:DA:BC:07:62:01:00:89:76:C9  |
| 70  | digicerthighassuranceevrootca [jdk]  | CN=DigiCert High Assurance EV Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert High Assurance EV Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US  | 2ac5c266a0b409b8f0b79f2ae462577  | 3  | Fri Nov 10 02:00:00 IST 2006  | Mon Nov 10 02:00:00 IST 2031  | 5F:B7:EE:06:33:E2:59:DB:AD:0C:4C:9A:E6:D3:8F:1A:61:C7:DC:25  |
| 71  | quovadisrootca1g3 [jdk]  | CN=QuoVadis Root CA 1 G3, O=QuoVadis Limited, C=BM  | CN=QuoVadis Root CA 1 G3, O=QuoVadis Limited, C=BM  | 78585f2ead2c194be3370735341328b596d46593  | 3  | Thu Jan 12 19:27:44 IST 2012  | Sun Jan 12 19:27:44 IST 2042  | 1B:8E:EA:57:96:29:1A:C9:39:EA:B8:0A:81:1A:73:73:C0:93:79:67  |
| 72  | comodorsaca [jdk]  | CN=COMODO RSA Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB  | CN=COMODO RSA Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB  | 4caaf9cadb636fe01ff74ed85b03869d  | 3  | Tue Jan 19 02:00:00 IST 2010  | Tue Jan 19 01:59:59 IST 2038  | AF:E5:D2:44:A8:D1:19:42:30:FF:47:9F:E2:F8:97:BB:CD:7A:8C:B4  |
| 73  | buypassclass2ca [jdk]  | CN=Buypass Class 2 Root CA, O=Buypass AS-983163327, C=NO  | CN=Buypass Class 2 Root CA, O=Buypass AS-983163327, C=NO  | 2  | 3  | Tue Oct 26 10:38:03 IST 2010  | Fri Oct 26 11:38:03 IDT 2040  | 49:0A:75:74:DE:87:0A:47:FE:58:EE:F6:C7:6B:EB:C6:0B:12:40:99  |
| 74  | secomscrootca2 [jdk]  | OU=Security Communication RootCA2, O=”SECOM Trust Systems CO.,LTD.”, C=JP  | OU=Security Communication RootCA2, O=”SECOM Trust Systems CO.,LTD.”, C=JP  | 0  | 3  | Fri May 29 08:00:39 IDT 2009  | Tue May 29 08:00:39 IDT 2029  | 5F:3B:8C:F2:F8:10:B3:7D:78:B4:CE:EC:19:19:C3:73:34:B9:C7:74  |
| 75  | entrustevca [jdk]  | CN=Entrust Root Certification Authority, OU=”(c) 2006 Entrust, Inc.”, OU=www.entrust.net/CPS is incorporated by reference, O=”Entrust, Inc.”, C=US  | CN=Entrust Root Certification Authority, OU=”(c) 2006 Entrust, Inc.”, OU=www.entrust.net/CPS is incorporated by reference, O=”Entrust, Inc.”, C=US  | 456b5054  | 3  | Mon Nov 27 22:23:42 IST 2006  | Fri Nov 27 22:53:42 IST 2026  | B3:1E:B1:B7:40:E3:6C:84:02:DA:DC:37:D4:4D:F5:D4:67:49:52:F9  |
| 76  | verisignclass3g3ca [jdk]  | CN=VeriSign Class 3 Public Primary Certification Authority - G3, OU=”(c) 1999 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | CN=VeriSign Class 3 Public Primary Certification Authority - G3, OU=”(c) 1999 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US  | 9b7e0649a33e62b9d5ee90487129ef57  | 1  | Fri Oct 01 02:00:00 IST 1999  | Thu Jul 17 02:59:59 IDT 2036  | 13:2D:0D:45:53:4B:69:97:CD:B2:D5:C3:39:E2:55:76:60:9B:5C:C6  |
| 77  | certumtrustednetworkca [jdk]  | CN=Certum Trusted Network CA, OU=Certum Certification Authority, O=Unizeto Technologies S.A., C=PL  | CN=Certum Trusted Network CA, OU=Certum Certification Authority, O=Unizeto Technologies S.A., C=PL  | 444c0  | 3  | Wed Oct 22 14:07:37 IST 2008  | Mon Dec 31 14:07:37 IST 2029  | 07:E0:32:E0:20:B7:2C:3F:19:2F:06:28:A2:59:3A:19:A7:0F:06:9E  |
| 78  | dtrustclass3ca2ev [jdk]  | CN=D-TRUST Root Class 3 CA 2 EV 2009, O=D-Trust GmbH, C=DE  | CN=D-TRUST Root Class 3 CA 2 EV 2009, O=D-Trust GmbH, C=DE  | 983f4  | 3  | Thu Nov 05 10:50:46 IST 2009  | Mon Nov 05 10:50:46 IST 2029  | 96:C9:1B:0B:95:B4:10:98:42:FA:D0:D8:22:79:FE:60:FA:B9:16:83  |
| 79  | globalsigneccrootcar5 [jdk]  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R5  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R5  | 605949e0262ebb55f90a778a71f94ad86c  | 3  | Tue Nov 13 02:00:00 IST 2012  | Tue Jan 19 05:14:07 IST 2038  | 1F:24:C6:30:CD:A4:18:EF:20:69:FF:AD:4F:DD:5F:46:3A:1B:69:AA  |
| 80  | starfieldservicesrootg2ca [jdk]  | CN=Starfield Services Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US  | CN=Starfield Services Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US  | 0  | 3  | Tue Sep 01 03:00:00 IDT 2009  | Fri Jan 01 01:59:59 IST 2038  | 92:5A:8F:8D:2C:6D:04:E0:66:5F:59:6A:FF:22:D8:63:E8:25:6F:3F  |
| 81  | ttelesecglobalrootclass2ca [jdk]  | CN=T-TeleSec GlobalRoot Class 2, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE  | CN=T-TeleSec GlobalRoot Class 2, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE  | 1  | 3  | Wed Oct 01 13:40:14 IDT 2008  | Sun Oct 02 02:59:59 IDT 2033  | 59:0D:2D:7D:88:4F:40:2E:61:7E:A5:62:32:17:65:CF:17:D8:94:E9  |
| 82  | addtrustqualifiedca [jdk]  | CN=AddTrust Qualified CA Root, OU=AddTrust TTP Network, O=AddTrust AB, C=SE  | CN=AddTrust Qualified CA Root, OU=AddTrust TTP Network, O=AddTrust AB, C=SE  | 1  | 3  | Tue May 30 13:44:50 IDT 2000  | Sat May 30 13:44:50 IDT 2020  | 4D:23:78:EC:91:95:39:B5:00:7F:75:8F:03:3B:21:1E:C5:4D:8B:CF  |
| 83  | digicertglobalrootca [jdk]  | CN=DigiCert Global Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US  | CN=DigiCert Global Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US  | 83be056904246b1a1756ac95991c74a  | 3  | Fri Nov 10 02:00:00 IST 2006  | Mon Nov 10 02:00:00 IST 2031  | A8:98:5D:3A:65:E5:E5:C4:B2:D7:D6:6D:40:C6:DD:2F:B1:9C:54:36  |
| 84  | amazonrootca1 [jdk]  | CN=Amazon Root CA 1, O=Amazon, C=US  | CN=Amazon Root CA 1, O=Amazon, C=US  | 66c9fcf99bf8c0a39e2f0788a43e696365bca  | 3  | Tue May 26 08:00:00 CST 2015  | Sun Jan 17 08:00:00 CST 2038  | 8D:A7:F9:65:EC:5E:FC:37:91:0F:1C:6E:59:FD:C1:CC:6A:6E:DE:16  |
| 85  | amazonrootca2 [jdk]  | CN=Amazon Root CA 2, O=Amazon, C=US  | CN=Amazon Root CA 2, O=Amazon, C=US  | 66c9fd29635869f0a0fe58678f85b26bb8a37  | 3  | Tue May 26 08:00:00 CST 2015  | Sat May 26 08:00:00 CST 2040  | 5A:8C:EF:45:D7:A6:98:59:76:7A:8C:8B:44:96:B5:78:CF:47:4B:1A  |
| 86  | amazonrootca3 [jdk]  | CN=Amazon Root CA 3, O=Amazon, C=US  | CN=Amazon Root CA 3, O=Amazon, C=US  | 66c9fd5749736663f3b0b9ad9e89e7603f24a  | 3  | Tue May 26 08:00:00 CST 2015  | Sat May 26 08:00:00 CST 2040  | 0D:44:DD:8C:3C:8C:1A:1A:58:75:64:81:E9:0F:2E:2A:FF:B3:D2:6E  |
| 87  | amazonrootca4 [jdk]  | CN=Amazon Root CA 4, O=Amazon, C=US  | CN=Amazon Root CA 4, O=Amazon, C=US  | 66c9fd7c1bb104c2943e5717b7b2cc81ac10e  | 3  | Tue May 26 08:00:00 CST 2015  | Sat May 26 08:00:00 CST 2040  | F6:10:84:07:D6:F8:BB:67:98:0C:C2:E2:44:C2:EB:AE:1C:EF:63:BE  |
| 88  | globalsignrootcar6 [jdk]  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R6  | CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R6  | 45e6bb038333c3856548e6ff4551  | 3  | Wed Dec 10 08:00:00 CST 2014  | Sun Dec 10 08:00:00 CST 2034  | 80:94:64:0E:B5:A7:A1:CA:11:9C:1F:DD:D5:9F:81:02:63:A7:FB:D1  |
| 89  | letsencryptisrgx1 [jdk]  | CN=ISRG Root X1, O=Internet Security Research Group, C=US  | CN=ISRG Root X1, O=Internet Security Research Group, C=US  | 8210cfb0d240e3594463e0bb63828b00  | 3  | Thu Jun 04 19:04:38 CST 2015  | Mon Jun 04 19:04:38 CST 2035  | CA:BD:2A:79:A1:07:6A:31:F2:1D:25:36:35:CB:03:9D:43:29:A5:E8  |
| 90  | luxtrustglobalroot2ca [jdk]  | CN=LuxTrust Global Root 2, O=LuxTrust S.A., C=LU  | CN=LuxTrust Global Root 2, O=LuxTrust S.A., C=LU  | a7ea6df4b449eda6a24859ee6b815d3167fbbb1  | 3  | Thu Mar 05 21:21:57 CST 2015  | Mon Mar 05 21:21:57 CST 2035  | 1E:0E:56:19:0A:D1:8B:25:98:B2:04:44:FF:66:8A:04:17:99:5F:3F  |
| 91  | teliasonerarootcav1 [jdk]  | CN=TeliaSonera Root CA v1, O=TeliaSonera  | CN=TeliaSonera Root CA v1, O=TeliaSonera  | 95be16a0f72e46f17b398272fa8bcd96  | 3  | Thu Oct 18 20:00:50 CST 2007  | Mon Oct 18 20:00:50 CST 2032  | 43:13:BB:96:F1:D5:86:9B:C1:4E:6A:92:F6:CF:F6:34:69:87:82:37  |
| 92  | TWCA Root Certification Authority  | CN=TWCA Root Certification Authority, OU=Root CA, O=TAIWAN-CA, C=TW  | CN=TWCA Root Certification Authority, OU=Root CA, O=TAIWAN-CA, C=TW  | 01  | 3  | Thu Aug 28 15:24:33 CST 2008  | Tue Dec 31 23:59:59 CST 2030  | CF:9E:87:6D:D3:EB:FC:42:26:97:A3:B5:A3:7A:A0:76:A9:06:23:48  |

#


Alias name


Subject DN


Issuer DN


Certificate Serial Number


Version


Valid From [GMT]


Valid To [GMT]


Thumbprint(SHA1)


1


verisignclass2g2ca [jdk]


OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 2 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US


OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 2 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US


b92f60cc889fa17a4609b85b706c8aaf


1


Mon May 18 03:00:00 IDT 1998


Wed Aug 02 02:59:59 IDT 2028


B3:EA:C4:47:76:C9:C8:1C:EA:F2:9D:95:B6:CC:A0:08:1B:67:EC:9D


2


digicertassuredidg3 [jdk]


CN=DigiCert Assured ID Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Assured ID Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US


ba15afa1ddfa0b54944afcd24a06cec


3


Thu Aug 01 15:00:00 IDT 2013


Fri Jan 15 14:00:00 IST 2038


F5:17:A2:4F:9A:48:C6:C9:F8:A2:00:26:9F:DC:0F:48:2C:AB:30:89


3


verisignuniversalrootca [jdk]


CN=VeriSign Universal Root Certification Authority, OU=”(c) 2008 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


CN=VeriSign Universal Root Certification Authority, OU=”(c) 2008 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


401ac46421b31321030ebbe4121ac51d


3


Wed Apr 02 03:00:00 IDT 2008


Wed Dec 02 01:59:59 IST 2037


36:79:CA:35:66:87:72:30:4D:30:A5:FB:87:3B:0F:A7:7B:B7:0D:54


4


digicerttrustedrootg4 [jdk]


CN=DigiCert Trusted Root G4, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Trusted Root G4, OU=www.digicert.com, O=DigiCert Inc, C=US


59b1b579e8e2132e23907bda777755c


3


Thu Aug 01 15:00:00 IDT 2013


Fri Jan 15 14:00:00 IST 2038


DD:FB:16:CD:49:31:C9:73:A2:03:7D:3F:C8:3A:4D:7D:77:5D:05:E4


5


identrustpublicca [jdk]


CN=IdenTrust Public Sector Root CA 1, O=IdenTrust, C=US


CN=IdenTrust Public Sector Root CA 1, O=IdenTrust, C=US


a0142800000014523cf467c00000002


3


Thu Jan 16 19:53:32 IST 2014


Mon Jan 16 19:53:32 IST 2034


BA:29:41:60:77:98:3F:F4:F3:EF:F2:31:05:3B:2E:EA:6D:4D:45:FD


6


utnuserfirstobjectca [jdk]


CN=UTN-USERFirst-Object, OU=http://www.usertrust.com, O=The USERTRUST Network, L=Salt Lake City, ST=UT, C=US


CN=UTN-USERFirst-Object, OU=http://www.usertrust.com, O=The USERTRUST Network, L=Salt Lake City, ST=UT, C=US


44be0c8b500024b411d3362de0b35f1b


3


Fri Jul 09 21:31:20 IDT 1999


Tue Jul 09 21:40:36 IDT 2019


E1:2D:FB:4B:41:D7:D9:C3:2B:30:51:4B:AC:1D:81:D8:38:5E:2D:46


7


geotrustuniversalca [jdk]


CN=GeoTrust Universal CA, O=GeoTrust Inc., C=US


CN=GeoTrust Universal CA, O=GeoTrust Inc., C=US


1


3


Thu Mar 04 07:00:00 IST 2004


Sun Mar 04 07:00:00 IST 2029


E6:21:F3:35:43:79:05:9A:4B:68:30:9D:8A:2F:74:22:15:87:EC:79


8


digicertglobalrootg3 [jdk]


CN=DigiCert Global Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Global Root G3, OU=www.digicert.com, O=DigiCert Inc, C=US


55556bcf25ea43535c3a40fd5ab4572


3


Thu Aug 01 15:00:00 IDT 2013


Fri Jan 15 14:00:00 IST 2038


7E:04:DE:89:6A:3E:66:6D:00:E6:87:D3:3F:FA:D9:3B:E8:3D:34:9E


9


entrustrootcaec1 [jdk]


CN=Entrust Root Certification Authority - EC1, OU=”(c) 2012 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US


CN=Entrust Root Certification Authority - EC1, OU=”(c) 2012 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US


a68b79290000000050d091f9


3


Tue Dec 18 17:25:36 IST 2012


Fri Dec 18 17:55:36 IST 2037


20:D8:06:40:DF:9B:25:F5:12:25:3A:11:EA:F7:59:8A:EB:14:B5:47


10


secomscrootca1 [jdk]


OU=Security Communication RootCA1, O=SECOM Trust.net, C=JP


OU=Security Communication RootCA1, O=SECOM Trust.net, C=JP


0


3


Tue Sep 30 07:20:49 IDT 2003


Sat Sep 30 07:20:49 IDT 2023


36:B1:2B:49:F9:81:9E:D7:4C:9E:BC:38:0F:C6:56:8F:5D:AC:B2:F7


11


globalsignr2ca [jdk]


CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R2


CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R2


400000000010f8626e60d


3


Fri Dec 15 10:00:00 IST 2006


Wed Dec 15 10:00:00 IST 2021


75:E0:AB:B6:13:85:12:27:1C:04:F8:5F:DD:DE:38:E4:B7:24:2E:FE


12


identrustdstx3 [jdk]


CN=DST Root CA X3, O=Digital Signature Trust Co.


CN=DST Root CA X3, O=Digital Signature Trust Co.


44afb080d6a327ba893039862ef8406b


3


Sun Oct 01 00:12:19 IDT 2000


Thu Sep 30 17:01:15 IDT 2021


DA:C9:02:4F:54:D8:F6:DF:94:93:5F:B1:73:26:38:CA:6A:D7:7C:13


13


comodoeccca [jdk]


CN=COMODO ECC Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB


CN=COMODO ECC Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB


1f47afaa62007050544c019e9b63992a


3


Thu Mar 06 02:00:00 IST 2008


Tue Jan 19 01:59:59 IST 2038


9F:74:4E:9F:2B:4D:BA:EC:0F:31:2C:50:B6:56:3B:8E:2D:93:C3:11


14


entrust2048ca [jdk]


CN=Entrust.net Certification Authority (2048), OU=(c) 1999 Entrust.net Limited, OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.), O=Entrust.net


CN=Entrust.net Certification Authority (2048), OU=(c) 1999 Entrust.net Limited, OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.), O=Entrust.net


3863def8


3


Fri Dec 24 19:50:51 IST 1999


Tue Jul 24 17:15:12 IDT 2029


50:30:06:09:1D:97:D4:F5:AE:39:F7:CB:E7:92:7D:7D:65:2D:34:31


15


addtrustexternalca [jdk]


CN=AddTrust External CA Root, OU=AddTrust External TTP Network, O=AddTrust AB, C=SE


CN=AddTrust External CA Root, OU=AddTrust External TTP Network, O=AddTrust AB, C=SE


1


3


Tue May 30 13:48:38 IDT 2000


Sat May 30 13:48:38 IDT 2020


02:FA:F3:E2:91:43:54:68:60:78:57:69:4D:F5:E4:5B:68:85:18:68


16


globalsigneccrootcar4 [jdk]


CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R4


CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R4


2a38a41c960a04de42b228a50be8349802


3


Tue Nov 13 02:00:00 IST 2012


Tue Jan 19 05:14:07 IST 2038


69:69:56:2E:40:80:F4:24:A1:E7:19:9F:14:BA:F3:EE:58:AB:6A:BB


17


usertrustrsaca [jdk]


CN=USERTrust RSA Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US


CN=USERTrust RSA Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US


1fd6d30fca3ca51a81bbc640e35032d


3


Mon Feb 01 02:00:00 IST 2010


Tue Jan 19 01:59:59 IST 2038


2B:8F:1B:57:33:0D:BB:A2:D0:7A:6C:51:F7:0E:E9:0D:DA:B9:AD:8E


18


digicertassuredidrootca [jdk]


CN=DigiCert Assured ID Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Assured ID Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US


ce7e0e517d846fe8fe560fc1bf03039


3


Fri Nov 10 02:00:00 IST 2006


Mon Nov 10 02:00:00 IST 2031


05:63:B8:63:0D:62:D7:5A:BB:C8:AB:1E:4B:DF:B5:A8:99:B2:4D:43


19


digicertglobalrootg2 [jdk]


CN=DigiCert Global Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Global Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US


33af1e6a711a9a0bb2864b11d09fae5


3


Thu Aug 01 15:00:00 IDT 2013


Fri Jan 15 14:00:00 IST 2038


DF:3C:24:F9:BF:D6:66:76:1B:26:80:73:FE:06:D1:CC:8D:4F:82:A4


20


actalisauthenticationrootca [jdk]


CN=Actalis Authentication Root CA, O=Actalis S.p.A./03358520967, L=Milan, C=IT


CN=Actalis Authentication Root CA, O=Actalis S.p.A./03358520967, L=Milan, C=IT


570a119742c4e3cc


3


Thu Sep 22 14:22:02 IDT 2011


Sun Sep 22 14:22:02 IDT 2030


F3:73:B3:87:06:5A:28:84:8A:F2:F3:4A:CE:19:2B:DD:C7:8E:9C:AC


21


digicertassuredidg2 [jdk]


CN=DigiCert Assured ID Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Assured ID Root G2, OU=www.digicert.com, O=DigiCert Inc, C=US


b931c3ad63967ea6723bfc3af9af44b


3


Thu Aug 01 15:00:00 IDT 2013


Fri Jan 15 14:00:00 IST 2038


A1:4B:48:D9:43:EE:0A:0E:40:90:4F:3C:E0:A4:C0:91:93:51:5D:3F


22


swisssigngoldg2ca [jdk]


CN=SwissSign Gold CA - G2, O=SwissSign AG, C=CH


CN=SwissSign Gold CA - G2, O=SwissSign AG, C=CH


bb401c43f55e4fb0


3


Wed Oct 25 10:30:35 IST 2006


Sat Oct 25 11:30:35 IDT 2036


D8:C5:38:8A:B7:30:1B:1B:6E:D4:7A:E6:45:25:3A:6F:9F:1A:27:61


23


entrustrootcag2 [jdk]


CN=Entrust Root Certification Authority - G2, OU=”(c) 2009 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US


CN=Entrust Root Certification Authority - G2, OU=”(c) 2009 Entrust, Inc. - for authorized use only”, OU=See www.entrust.net/legal-terms, O=”Entrust, Inc.”, C=US


4a538c28


3


Tue Jul 07 20:25:54 IDT 2009


Sat Dec 07 19:55:54 IST 2030


8C:F4:27:FD:79:0C:3A:D1:66:06:8D:E8:1E:57:EF:BB:93:22:72:D4


24


quovadisrootca2g3 [jdk]


CN=QuoVadis Root CA 2 G3, O=QuoVadis Limited, C=BM


CN=QuoVadis Root CA 2 G3, O=QuoVadis Limited, C=BM


445734245b81899b35f2ceb82b3b5ba726f07528


3


Thu Jan 12 20:59:32 IST 2012


Sun Jan 12 20:59:32 IST 2042


09:3C:61:F3:8B:8B:DC:7D:55:DF:75:38:02:05:00:E1:25:F5:C8:36


25


securetrustca [jdk]


CN=SecureTrust CA, O=SecureTrust Corporation, C=US


CN=SecureTrust CA, O=SecureTrust Corporation, C=US


cf08e5c0816a5ad427ff0eb271859d0


3


Tue Nov 07 21:31:18 IST 2006


Mon Dec 31 21:40:55 IST 2029


87:82:C6:C3:04:35:3B:CF:D2:96:92:D2:59:3E:7D:44:D9:34:FF:11


26


camerfirmachambersca [jdk]


CN=Chambers of Commerce Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU


CN=Chambers of Commerce Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU


a3da427ea4b1aeda


3


Fri Aug 01 15:29:50 IDT 2008


Sat Jul 31 15:29:50 IDT 2038


78:6A:74:AC:76:AB:14:7F:9C:6A:30:50:BA:9E:A8:7E:FE:9A:CE:3C


27


geotrustprimaryca [jdk]


CN=GeoTrust Primary Certification Authority, O=GeoTrust Inc., C=US


CN=GeoTrust Primary Certification Authority, O=GeoTrust Inc., C=US


18acb56afd69b6153a636cafdafac4a1


3


Mon Nov 27 02:00:00 IST 2006


Thu Jul 17 02:59:59 IDT 2036


32:3C:11:8E:1B:F7:B8:B6:52:54:E2:E2:10:0D:D6:02:90:37:F0:96


28


identrustcommercial [jdk]


CN=IdenTrust Commercial Root CA 1, O=IdenTrust, C=US


CN=IdenTrust Commercial Root CA 1, O=IdenTrust, C=US


a0142800000014523c844b500000002


3


Thu Jan 16 20:12:23 IST 2014


Mon Jan 16 20:12:23 IST 2034


DF:71:7E:AA:4A:D9:4E:C9:55:84:99:60:2D:48:DE:5F:BC:F0:3A:25


29


thawteprimaryrootcag3 [jdk]


CN=thawte Primary Root CA - G3, OU=”(c) 2008 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US


CN=thawte Primary Root CA - G3, OU=”(c) 2008 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US


600197b746a7eab4b49ad64b2ff790fb


3


Wed Apr 02 03:00:00 IDT 2008


Wed Dec 02 01:59:59 IST 2037


F1:8B:53:8D:1B:E9:03:B6:A6:F0:56:43:5B:17:15:89:CA:F3:6B:F2


30


buypassclass3ca [jdk]


CN=Buypass Class 3 Root CA, O=Buypass AS-983163327, C=NO


CN=Buypass Class 3 Root CA, O=Buypass AS-983163327, C=NO


2


3


Tue Oct 26 10:28:58 IST 2010


Fri Oct 26 11:28:58 IDT 2040


DA:FA:F7:FA:66:84:EC:06:8F:14:50:BD:C7:C2:81:A5:BC:A9:64:57


31


verisigntsaca [jdk]


CN=Thawte Timestamping CA, OU=Thawte Certification, O=Thawte, L=Durbanville, ST=Western Cape, C=ZA


CN=Thawte Timestamping CA, OU=Thawte Certification, O=Thawte, L=Durbanville, ST=Western Cape, C=ZA


67c8e1e8e3be1cbdfc913b8ea6238749


3


Wed Jan 01 02:00:00 IST 1997


Sat Jan 02 01:59:59 IST 2021


20:CE:B1:F0:F5:1C:0E:19:A9:F3:8D:B1:AA:8E:03:8C:AA:7A:C7:01


32


verisignclass3g4ca [jdk]


CN=VeriSign Class 3 Public Primary Certification Authority - G4, OU=”(c) 2007 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


CN=VeriSign Class 3 Public Primary Certification Authority - G4, OU=”(c) 2007 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


2f80fe238c0e220f486712289187acb3


3


Mon Nov 05 02:00:00 IST 2007


Tue Jan 19 01:59:59 IST 2038


22:D5:D8:DF:8F:02:31:D1:8D:F7:9D:B7:CF:8A:2D:64:C9:3F:6C:3A


33


baltimorecybertrustca [jdk]


CN=Baltimore CyberTrust Root, OU=CyberTrust, O=Baltimore, C=IE


CN=Baltimore CyberTrust Root, OU=CyberTrust, O=Baltimore, C=IE


20000b9


3


Fri May 12 21:46:00 IDT 2000


Tue May 13 02:59:00 IDT 2025


D4:DE:20:D0:5E:66:FC:53:FE:1A:50:88:2C:78:DB:28:52:CA:E4:74


34


luxtrustglobalrootca [jdk]


CN=LuxTrust Global Root, O=LuxTrust s.a., C=LU


CN=LuxTrust Global Root, O=LuxTrust s.a., C=LU


bb8


3


Thu Mar 17 11:51:37 IST 2011


Wed Mar 17 11:51:37 IST 2021


C9:3C:34:EA:90:D9:13:0C:0F:03:00:4B:98:BD:8B:35:70:91:56:11


35


verisignclass3g2ca [jdk]


OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 3 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US


OU=VeriSign Trust Network, OU=”(c) 1998 VeriSign, Inc. - For authorized use only”, OU=Class 3 Public Primary Certification Authority - G2, O=”VeriSign, Inc.”, C=US


7dd9fe07cfa81eb7107967fba78934c6


1


Mon May 18 03:00:00 IDT 1998


Wed Aug 02 02:59:59 IDT 2028


85:37:1C:A6:E5:50:14:3D:CE:28:03:47:1B:DE:3A:09:E8:F8:77:0F


36


camerfirmachamberscommerceca [jdk]


CN=Chambers of Commerce Root, OU=http://www.chambersign.org, O=AC Camerfirma SA CIF A82743287, C=EU


CN=Chambers of Commerce Root, OU=http://www.chambersign.org, O=AC Camerfirma SA CIF A82743287, C=EU


0


3


Tue Sep 30 19:13:43 IDT 2003


Wed Sep 30 19:13:44 IDT 2037


6E:3A:55:A4:19:0C:19:5C:93:84:3C:C0:DB:72:2E:31:30:61:F0:B1


37


soneraclass2ca [jdk]


CN=Sonera Class2 CA, O=Sonera, C=FI


CN=Sonera Class2 CA, O=Sonera, C=FI


1d


3


Fri Apr 06 09:29:40 IST 2001


Tue Apr 06 10:29:40 IDT 2021


37:F7:6D:E6:07:7C:90:C5:B1:3E:93:1A:B7:41:10:B4:F2:E4:9A:27


38


affirmtrustnetworkingca [jdk]


CN=AffirmTrust Networking, O=AffirmTrust, C=US


CN=AffirmTrust Networking, O=AffirmTrust, C=US


7c4f04391cd4992d


3


Fri Jan 29 16:08:24 IST 2010


Tue Dec 31 16:08:24 IST 2030


29:36:21:02:8B:20:ED:02:F5:66:C5:32:D1:D6:ED:90:9F:45:00:2F


39


ttelesecglobalrootclass3ca [jdk]


CN=T-TeleSec GlobalRoot Class 3, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE


CN=T-TeleSec GlobalRoot Class 3, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE


1


3


Wed Oct 01 13:29:56 IDT 2008


Sun Oct 02 02:59:59 IDT 2033


55:A6:72:3E:CB:F2:EC:CD:C3:23:74:70:19:9D:2A:BE:11:E3:81:D1


40


xrampglobalca [jdk]


CN=XRamp Global Certification Authority, O=XRamp Security Services Inc, OU=www.xrampsecurity.com, C=US


CN=XRamp Global Certification Authority, O=XRamp Security Services Inc, OU=www.xrampsecurity.com, C=US


50946cec18ead59c4dd597ef758fa0ad


3


Mon Nov 01 19:14:04 IST 2004


Mon Jan 01 07:37:19 IST 2035


B8:01:86:D1:EB:9C:86:A5:41:04:CF:30:54:F3:4C:52:B7:E5:58:C6


41


geotrustprimarycag3 [jdk]


CN=GeoTrust Primary Certification Authority - G3, OU=(c) 2008 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US


CN=GeoTrust Primary Certification Authority - G3, OU=(c) 2008 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US


15ac6e9419b2794b41f627a9c3180f1f


3


Wed Apr 02 03:00:00 IDT 2008


Wed Dec 02 01:59:59 IST 2037


03:9E:ED:B8:0B:E7:A0:3C:69:53:89:3B:20:D2:D9:32:3A:4C:2A:FD


42


camerfirmachambersignca [jdk]


CN=Global Chambersign Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU


CN=Global Chambersign Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com/address), C=EU


c9cdd3e9d57d23ce


3


Fri Aug 01 15:31:40 IDT 2008


Sat Jul 31 15:31:40 IDT 2038


4A:BD:EE:EC:95:0D:35:9C:89:AE:C7:52:A1:2C:5B:29:F6:D6:AA:0C


43


thawteprimaryrootcag2 [jdk]


CN=thawte Primary Root CA - G2, OU=”(c) 2007 thawte, Inc. - For authorized use only”, O=”thawte, Inc.”, C=US


CN=thawte Primary Root CA - G2, OU=”(c) 2007 thawte, Inc. - For authorized use only”, O=”thawte, Inc.”, C=US


35fc265cd9844fc93d263d579baed756


3


Mon Nov 05 02:00:00 IST 2007


Tue Jan 19 01:59:59 IST 2038


AA:DB:BC:22:23:8F:C4:01:A1:27:BB:38:DD:F4:1D:DB:08:9E:F0:12


44


usertrusteccca [jdk]


CN=USERTrust ECC Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US


CN=USERTrust ECC Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US


5c8b99c55a94c5d27156decd8980cc26


3


Mon Feb 01 02:00:00 IST 2010


Tue Jan 19 01:59:59 IST 2038


D1:CB:CA:5D:B2:D5:2A:7F:69:3B:67:4D:E5:F0:5A:1D:0C:95:7D:F0


45


swisssignsilverg2ca [jdk]


CN=SwissSign Silver CA - G2, O=SwissSign AG, C=CH


CN=SwissSign Silver CA - G2, O=SwissSign AG, C=CH


4f1bd42f54bb2f4b


3


Wed Oct 25 10:32:46 IST 2006


Sat Oct 25 11:32:46 IDT 2036


9B:AA:E5:9F:56:EE:21:CB:43:5A:BE:25:93:DF:A7:F0:40:D1:1D:CB


46


affirmtrustpremiumca [jdk]


CN=AffirmTrust Premium, O=AffirmTrust, C=US


CN=AffirmTrust Premium, O=AffirmTrust, C=US


6d8c1446b1a60aee


3


Fri Jan 29 16:10:36 IST 2010


Mon Dec 31 16:10:36 IST 2040


D8:A6:33:2C:E0:03:6F:B1:85:F6:63:4F:7D:6A:06:65:26:32:28:27


47


globalsignca [jdk]


CN=GlobalSign Root CA, OU=Root CA, O=GlobalSign nv-sa, C=BE


CN=GlobalSign Root CA, OU=Root CA, O=GlobalSign nv-sa, C=BE


40000000001154b5ac394


3


Tue Sep 01 15:00:00 IDT 1998


Fri Jan 28 14:00:00 IST 2028


B1:BC:96:8B:D4:F4:9D:62:2A:A8:9A:81:F2:15:01:52:A4:1D:82:9C


48


dtrustclass3ca2 [jdk]


CN=D-TRUST Root Class 3 CA 2 2009, O=D-Trust GmbH, C=DE


CN=D-TRUST Root Class 3 CA 2 2009, O=D-Trust GmbH, C=DE


983f3


3


Thu Nov 05 10:35:58 IST 2009


Mon Nov 05 10:35:58 IST 2029


58:E8:AB:B0:36:15:33:FB:80:F7:9B:1B:6D:29:D3:FF:8D:5F:00:F0


49


affirmtrustcommercialca [jdk]


CN=AffirmTrust Commercial, O=AffirmTrust, C=US


CN=AffirmTrust Commercial, O=AffirmTrust, C=US


7777062726a9b17c


3


Fri Jan 29 16:06:06 IST 2010


Tue Dec 31 16:06:06 IST 2030


F9:B5:B6:32:45:5F:9C:BE:EC:57:5F:80:DC:E9:6E:2C:C7:B2:78:B7


50


thawtepremiumserverca [jdk]


EMAILADDRESS=premium-server@thawte.com, CN=Thawte Premium Server CA, OU=Certification Services Division, O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA


EMAILADDRESS=premium-server@thawte.com, CN=Thawte Premium Server CA, OU=Certification Services Division, O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA


36122296c5e338a520a1d25f4cd70954


3


Thu Aug 01 03:00:00 IDT 1996


Sat Jan 02 01:59:59 IST 2021


E0:AB:05:94:20:72:54:93:05:60:62:02:36:70:F7:CD:2E:FC:66:66


51


comodoaaaca [jdk]


CN=AAA Certificate Services, O=Comodo CA Limited, L=Salford, ST=Greater Manchester, C=GB


CN=AAA Certificate Services, O=Comodo CA Limited, L=Salford, ST=Greater Manchester, C=GB


1


3


Thu Jan 01 02:00:00 IST 2004


Mon Jan 01 01:59:59 IST 2029


D1:EB:23:A4:6D:17:D6:8F:D9:25:64:C2:F1:F1:60:17:64:D8:E3:49


52


geotrustprimarycag2 [jdk]


CN=GeoTrust Primary Certification Authority - G2, OU=(c) 2007 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US


CN=GeoTrust Primary Certification Authority - G2, OU=(c) 2007 GeoTrust Inc. - For authorized use only, O=GeoTrust Inc., C=US


3cb2f4480a00e2feeb243b5e603ec36b


3


Mon Nov 05 02:00:00 IST 2007


Tue Jan 19 01:59:59 IST 2038


8D:17:84:D5:37:F3:03:7D:EC:70:FE:57:8B:51:9A:99:E6:10:D7:B0


53


globalsignr3ca [jdk]


CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R3


CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R3


4000000000121585308a2


3


Wed Mar 18 12:00:00 IST 2009


Sun Mar 18 12:00:00 IST 2029


D6:9B:56:11:48:F0:1C:77:C5:45:78:C1:09:26:DF:5B:85:69:76:AD


54


quovadisrootca3 [jdk]


CN=QuoVadis Root CA 3, O=QuoVadis Limited, C=BM


CN=QuoVadis Root CA 3, O=QuoVadis Limited, C=BM


5c6


3


Fri Nov 24 21:11:23 IST 2006


Mon Nov 24 21:06:44 IST 2031


1F:49:14:F7:D8:74:95:1D:DD:AE:02:C0:BE:FD:3A:2D:82:75:51:85


55


thawteprimaryrootca [jdk]


CN=thawte Primary Root CA, OU=”(c) 2006 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US


CN=thawte Primary Root CA, OU=”(c) 2006 thawte, Inc. - For authorized use only”, OU=Certification Services Division, O=”thawte, Inc.”, C=US


344ed55720d5edec49f42fce37db2b6d


3


Fri Nov 17 02:00:00 IST 2006


Thu Jul 17 02:59:59 IDT 2036


91:C6:D6:EE:3E:8A:C8:63:84:E5:48:C2:99:29:5C:75:6C:81:7B:81


56


starfieldrootg2ca [jdk]


CN=Starfield Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US


CN=Starfield Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US


0


3


Tue Sep 01 03:00:00 IDT 2009


Fri Jan 01 01:59:59 IST 2038


B5:1C:06:7C:EE:2B:0C:3D:F8:55:AB:2D:92:F4:FE:39:D4:E7:0F:0E


57


starfieldclass2ca [jdk]


OU=Starfield Class 2 Certification Authority, O=”Starfield Technologies, Inc.”, C=US


OU=Starfield Class 2 Certification Authority, O=”Starfield Technologies, Inc.”, C=US


0


3


Tue Jun 29 20:39:16 IDT 2004


Thu Jun 29 20:39:16 IDT 2034


AD:7E:1C:28:B0:64:EF:8F:60:03:40:20:14:C3:D0:E3:37:0E:B5:8A


58


verisignclass3ca [jdk]


OU=Class 3 Public Primary Certification Authority, O=”VeriSign, Inc.”, C=US


OU=Class 3 Public Primary Certification Authority, O=”VeriSign, Inc.”, C=US


3c9131cb1ff6d01b0e9ab8d044bf12be


1


Mon Jan 29 02:00:00 IST 1996


Thu Aug 03 02:59:59 IDT 2028


A1:DB:63:93:91:6F:17:E4:18:55:09:40:04:15:C7:02:40:B0:AE:6B


59


affirmtrustpremiumeccca [jdk]


CN=AffirmTrust Premium ECC, O=AffirmTrust, C=US


CN=AffirmTrust Premium ECC, O=AffirmTrust, C=US


7497258ac73f7a54


3


Fri Jan 29 16:20:24 IST 2010


Mon Dec 31 16:20:24 IST 2040


B8:23:6B:00:2F:1D:16:86:53:01:55:6C:11:A4:37:CA:EB:FF:C3:BB


60


geotrustglobalca [jdk]


CN=GeoTrust Global CA, O=GeoTrust Inc., C=US


CN=GeoTrust Global CA, O=GeoTrust Inc., C=US


23456


3


Tue May 21 07:00:00 IDT 2002


Sat May 21 07:00:00 IDT 2022


DE:28:F4:A4:FF:E5:B9:2F:A3:C5:03:D1:A3:49:A7:F9:96:2A:82:12


61


godaddyclass2ca [jdk]


OU=Go Daddy Class 2 Certification Authority, O=”The Go Daddy Group, Inc.”, C=US


OU=Go Daddy Class 2 Certification Authority, O=”The Go Daddy Group, Inc.”, C=US


0


3


Tue Jun 29 20:06:20 IDT 2004


Thu Jun 29 20:06:20 IDT 2034


27:96:BA:E6:3F:18:01:E2:77:26:1B:A0:D7:77:70:02:8F:20:EE:E4


62


godaddyrootg2ca [jdk]


CN=Go Daddy Root Certificate Authority - G2, O=”GoDaddy.com, Inc.”, L=Scottsdale, ST=Arizona, C=US


CN=Go Daddy Root Certificate Authority - G2, O=”GoDaddy.com, Inc.”, L=Scottsdale, ST=Arizona, C=US


0


3


Tue Sep 01 03:00:00 IDT 2009


Fri Jan 01 01:59:59 IST 2038


47:BE:AB:C9:22:EA:E8:0E:78:78:34:62:A7:9F:45:C2:54:FD:E6:8B


63


verisignclass3g5ca [jdk]


CN=VeriSign Class 3 Public Primary Certification Authority - G5, OU=”(c) 2006 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


CN=VeriSign Class 3 Public Primary Certification Authority - G5, OU=”(c) 2006 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


18dad19e267de8bb4a2158cdcc6b3b4a


3


Wed Nov 08 02:00:00 IST 2006


Thu Jul 17 02:59:59 IDT 2036


4E:B6:D5:78:49:9B:1C:CF:5F:58:1E:AD:56:BE:3D:9B:67:44:A5:E5


64


quovadisrootca2 [jdk]


CN=QuoVadis Root CA 2, O=QuoVadis Limited, C=BM


CN=QuoVadis Root CA 2, O=QuoVadis Limited, C=BM


509


3


Fri Nov 24 20:27:00 IST 2006


Mon Nov 24 20:23:33 IST 2031


CA:3A:FB:CF:12:40:36:4B:44:B2:16:20:88:80:48:39:19:93:7C:F7


65


certumca [jdk]


CN=Certum CA, O=Unizeto Sp. z o.o., C=PL


CN=Certum CA, O=Unizeto Sp. z o.o., C=PL


10020


3


Tue Jun 11 13:46:39 IDT 2002


Fri Jun 11 13:46:39 IDT 2027


62:52:DC:40:F7:11:43:A2:2F:DE:9E:F7:34:8E:06:42:51:B1:81:18


66


swisssignplatinumg2ca [jdk]


CN=SwissSign Platinum CA - G2, O=SwissSign AG, C=CH


CN=SwissSign Platinum CA - G2, O=SwissSign AG, C=CH


4eb200670c035d4f


3


Wed Oct 25 10:36:00 IST 2006


Sat Oct 25 11:36:00 IDT 2036


56:E0:FA:C0:3B:8F:18:23:55:18:E5:D3:11:CA:E8:C2:43:31:AB:66


67


chunghwaepkirootca [jdk]


OU=ePKI Root Certification Authority, O=”Chunghwa Telecom Co., Ltd.”, C=TW


OU=ePKI Root Certification Authority, O=”Chunghwa Telecom Co., Ltd.”, C=TW


15c8bd65475cafb897005ee406d2bc9d


3


Mon Dec 20 04:31:27 IST 2004


Wed Dec 20 04:31:27 IST 2034


67:65:0D:F1:7E:8E:7E:5B:82:40:A4:F4:56:4B:CF:E2:3D:69:C6:F0


68


quovadisrootca3g3 [jdk]


CN=QuoVadis Root CA 3 G3, O=QuoVadis Limited, C=BM


CN=QuoVadis Root CA 3 G3, O=QuoVadis Limited, C=BM


2ef59b0228a7db7affd5a3a9eebd03a0cf126a1d


3


Thu Jan 12 22:26:32 IST 2012


Sun Jan 12 22:26:32 IST 2042


48:12:BD:92:3C:A8:C4:39:06:E7:30:6D:27:96:E6:A4:CF:22:2E:7D


69


quovadisrootca [jdk]


CN=QuoVadis Root Certification Authority, OU=Root Certification Authority, O=QuoVadis Limited, C=BM


CN=QuoVadis Root Certification Authority, OU=Root Certification Authority, O=QuoVadis Limited, C=BM


3ab6508b


3


Mon Mar 19 20:33:33 IST 2001


Wed Mar 17 20:33:33 IST 2021


DE:3F:40:BD:50:93:D3:9B:6C:60:F6:DA:BC:07:62:01:00:89:76:C9


70


digicerthighassuranceevrootca [jdk]


CN=DigiCert High Assurance EV Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert High Assurance EV Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US


2ac5c266a0b409b8f0b79f2ae462577


3


Fri Nov 10 02:00:00 IST 2006


Mon Nov 10 02:00:00 IST 2031


5F:B7:EE:06:33:E2:59:DB:AD:0C:4C:9A:E6:D3:8F:1A:61:C7:DC:25


71


quovadisrootca1g3 [jdk]


CN=QuoVadis Root CA 1 G3, O=QuoVadis Limited, C=BM


CN=QuoVadis Root CA 1 G3, O=QuoVadis Limited, C=BM


78585f2ead2c194be3370735341328b596d46593


3


Thu Jan 12 19:27:44 IST 2012


Sun Jan 12 19:27:44 IST 2042


1B:8E:EA:57:96:29:1A:C9:39:EA:B8:0A:81:1A:73:73:C0:93:79:67


72


comodorsaca [jdk]


CN=COMODO RSA Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB


CN=COMODO RSA Certification Authority, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB


4caaf9cadb636fe01ff74ed85b03869d


3


Tue Jan 19 02:00:00 IST 2010


Tue Jan 19 01:59:59 IST 2038


AF:E5:D2:44:A8:D1:19:42:30:FF:47:9F:E2:F8:97:BB:CD:7A:8C:B4


73


buypassclass2ca [jdk]


CN=Buypass Class 2 Root CA, O=Buypass AS-983163327, C=NO


CN=Buypass Class 2 Root CA, O=Buypass AS-983163327, C=NO


2


3


Tue Oct 26 10:38:03 IST 2010


Fri Oct 26 11:38:03 IDT 2040


49:0A:75:74:DE:87:0A:47:FE:58:EE:F6:C7:6B:EB:C6:0B:12:40:99


74


secomscrootca2 [jdk]


OU=Security Communication RootCA2, O=”SECOM Trust Systems CO.,LTD.”, C=JP


OU=Security Communication RootCA2, O=”SECOM Trust Systems CO.,LTD.”, C=JP


0


3


Fri May 29 08:00:39 IDT 2009


Tue May 29 08:00:39 IDT 2029


5F:3B:8C:F2:F8:10:B3:7D:78:B4:CE:EC:19:19:C3:73:34:B9:C7:74


75


entrustevca [jdk]


CN=Entrust Root Certification Authority, OU=”(c) 2006 Entrust, Inc.”, OU=www.entrust.net/CPS is incorporated by reference, O=”Entrust, Inc.”, C=US


CN=Entrust Root Certification Authority, OU=”(c) 2006 Entrust, Inc.”, OU=www.entrust.net/CPS is incorporated by reference, O=”Entrust, Inc.”, C=US


456b5054


3


Mon Nov 27 22:23:42 IST 2006


Fri Nov 27 22:53:42 IST 2026


B3:1E:B1:B7:40:E3:6C:84:02:DA:DC:37:D4:4D:F5:D4:67:49:52:F9


76


verisignclass3g3ca [jdk]


CN=VeriSign Class 3 Public Primary Certification Authority - G3, OU=”(c) 1999 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


CN=VeriSign Class 3 Public Primary Certification Authority - G3, OU=”(c) 1999 VeriSign, Inc. - For authorized use only”, OU=VeriSign Trust Network, O=”VeriSign, Inc.”, C=US


9b7e0649a33e62b9d5ee90487129ef57


1


Fri Oct 01 02:00:00 IST 1999


Thu Jul 17 02:59:59 IDT 2036


13:2D:0D:45:53:4B:69:97:CD:B2:D5:C3:39:E2:55:76:60:9B:5C:C6


77


certumtrustednetworkca [jdk]


CN=Certum Trusted Network CA, OU=Certum Certification Authority, O=Unizeto Technologies S.A., C=PL


CN=Certum Trusted Network CA, OU=Certum Certification Authority, O=Unizeto Technologies S.A., C=PL


444c0


3


Wed Oct 22 14:07:37 IST 2008


Mon Dec 31 14:07:37 IST 2029


07:E0:32:E0:20:B7:2C:3F:19:2F:06:28:A2:59:3A:19:A7:0F:06:9E


78


dtrustclass3ca2ev [jdk]


CN=D-TRUST Root Class 3 CA 2 EV 2009, O=D-Trust GmbH, C=DE


CN=D-TRUST Root Class 3 CA 2 EV 2009, O=D-Trust GmbH, C=DE


983f4


3


Thu Nov 05 10:50:46 IST 2009


Mon Nov 05 10:50:46 IST 2029


96:C9:1B:0B:95:B4:10:98:42:FA:D0:D8:22:79:FE:60:FA:B9:16:83


79


globalsigneccrootcar5 [jdk]


CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R5


CN=GlobalSign, O=GlobalSign, OU=GlobalSign ECC Root CA - R5


605949e0262ebb55f90a778a71f94ad86c


3


Tue Nov 13 02:00:00 IST 2012


Tue Jan 19 05:14:07 IST 2038


1F:24:C6:30:CD:A4:18:EF:20:69:FF:AD:4F:DD:5F:46:3A:1B:69:AA


80


starfieldservicesrootg2ca [jdk]


CN=Starfield Services Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US


CN=Starfield Services Root Certificate Authority - G2, O=”Starfield Technologies, Inc.”, L=Scottsdale, ST=Arizona, C=US


0


3


Tue Sep 01 03:00:00 IDT 2009


Fri Jan 01 01:59:59 IST 2038


92:5A:8F:8D:2C:6D:04:E0:66:5F:59:6A:FF:22:D8:63:E8:25:6F:3F


81


ttelesecglobalrootclass2ca [jdk]


CN=T-TeleSec GlobalRoot Class 2, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE


CN=T-TeleSec GlobalRoot Class 2, OU=T-Systems Trust Center, O=T-Systems Enterprise Services GmbH, C=DE


1


3


Wed Oct 01 13:40:14 IDT 2008


Sun Oct 02 02:59:59 IDT 2033


59:0D:2D:7D:88:4F:40:2E:61:7E:A5:62:32:17:65:CF:17:D8:94:E9


82


addtrustqualifiedca [jdk]


CN=AddTrust Qualified CA Root, OU=AddTrust TTP Network, O=AddTrust AB, C=SE


CN=AddTrust Qualified CA Root, OU=AddTrust TTP Network, O=AddTrust AB, C=SE


1


3


Tue May 30 13:44:50 IDT 2000


Sat May 30 13:44:50 IDT 2020


4D:23:78:EC:91:95:39:B5:00:7F:75:8F:03:3B:21:1E:C5:4D:8B:CF


83


digicertglobalrootca [jdk]


CN=DigiCert Global Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US


CN=DigiCert Global Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US


83be056904246b1a1756ac95991c74a


3


Fri Nov 10 02:00:00 IST 2006


Mon Nov 10 02:00:00 IST 2031


A8:98:5D:3A:65:E5:E5:C4:B2:D7:D6:6D:40:C6:DD:2F:B1:9C:54:36


84


amazonrootca1 [jdk]


CN=Amazon Root CA 1, O=Amazon, C=US


CN=Amazon Root CA 1, O=Amazon, C=US


66c9fcf99bf8c0a39e2f0788a43e696365bca


3


Tue May 26 08:00:00 CST 2015


Sun Jan 17 08:00:00 CST 2038


8D:A7:F9:65:EC:5E:FC:37:91:0F:1C:6E:59:FD:C1:CC:6A:6E:DE:16


85


amazonrootca2 [jdk]


CN=Amazon Root CA 2, O=Amazon, C=US


CN=Amazon Root CA 2, O=Amazon, C=US


66c9fd29635869f0a0fe58678f85b26bb8a37


3


Tue May 26 08:00:00 CST 2015


Sat May 26 08:00:00 CST 2040


5A:8C:EF:45:D7:A6:98:59:76:7A:8C:8B:44:96:B5:78:CF:47:4B:1A


86


amazonrootca3 [jdk]


CN=Amazon Root CA 3, O=Amazon, C=US


CN=Amazon Root CA 3, O=Amazon, C=US


66c9fd5749736663f3b0b9ad9e89e7603f24a


3


Tue May 26 08:00:00 CST 2015


Sat May 26 08:00:00 CST 2040


0D:44:DD:8C:3C:8C:1A:1A:58:75:64:81:E9:0F:2E:2A:FF:B3:D2:6E


87


amazonrootca4 [jdk]


CN=Amazon Root CA 4, O=Amazon, C=US


CN=Amazon Root CA 4, O=Amazon, C=US


66c9fd7c1bb104c2943e5717b7b2cc81ac10e


3


Tue May 26 08:00:00 CST 2015


Sat May 26 08:00:00 CST 2040


F6:10:84:07:D6:F8:BB:67:98:0C:C2:E2:44:C2:EB:AE:1C:EF:63:BE


88


globalsignrootcar6 [jdk]


CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R6


CN=GlobalSign, O=GlobalSign, OU=GlobalSign Root CA - R6


45e6bb038333c3856548e6ff4551


3


Wed Dec 10 08:00:00 CST 2014


Sun Dec 10 08:00:00 CST 2034


80:94:64:0E:B5:A7:A1:CA:11:9C:1F:DD:D5:9F:81:02:63:A7:FB:D1


89


letsencryptisrgx1 [jdk]


CN=ISRG Root X1, O=Internet Security Research Group, C=US


CN=ISRG Root X1, O=Internet Security Research Group, C=US


8210cfb0d240e3594463e0bb63828b00


3


Thu Jun 04 19:04:38 CST 2015


Mon Jun 04 19:04:38 CST 2035


CA:BD:2A:79:A1:07:6A:31:F2:1D:25:36:35:CB:03:9D:43:29:A5:E8


90


luxtrustglobalroot2ca [jdk]


CN=LuxTrust Global Root 2, O=LuxTrust S.A., C=LU


CN=LuxTrust Global Root 2, O=LuxTrust S.A., C=LU


a7ea6df4b449eda6a24859ee6b815d3167fbbb1


3


Thu Mar 05 21:21:57 CST 2015


Mon Mar 05 21:21:57 CST 2035


1E:0E:56:19:0A:D1:8B:25:98:B2:04:44:FF:66:8A:04:17:99:5F:3F


91


teliasonerarootcav1 [jdk]


CN=TeliaSonera Root CA v1, O=TeliaSonera


CN=TeliaSonera Root CA v1, O=TeliaSonera


95be16a0f72e46f17b398272fa8bcd96


3


Thu Oct 18 20:00:50 CST 2007


Mon Oct 18 20:00:50 CST 2032


43:13:BB:96:F1:D5:86:9B:C1:4E:6A:92:F6:CF:F6:34:69:87:82:37


92


TWCA Root Certification Authority


CN=TWCA Root Certification Authority, OU=Root CA, O=TAIWAN-CA, C=TW


CN=TWCA Root Certification Authority, OU=Root CA, O=TAIWAN-CA, C=TW


01


3


Thu Aug 28 15:24:33 CST 2008


Tue Dec 31 23:59:59 CST 2030


CF:9E:87:6D:D3:EB:FC:42:26:97:A3:B5:A3:7A:A0:76:A9:06:23:48


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-20
爬取时间: 2025-05-08 07:08:40
来源: Huawei Developer


具体见加密套件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-22
爬取时间: 2025-05-08 07:08:50
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-23
爬取时间: 2025-05-08 07:09:00
来源: Huawei Developer


当前支持的续费周期为1周、1个月、2个月、3个月、6个月、1年、30天（上次订阅日期+30天）、31天（上次订阅日期+31天），具体配置方法请参考数字商品介绍。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-24
爬取时间: 2025-05-08 07:09:09
来源: Huawei Developer


按照自然月计算。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-25
爬取时间: 2025-05-08 07:09:19
来源: Huawei Developer


根据订阅日期决定。例如：当月第N日订阅，下个月的第N日续期。如果这个N在下个月不存在，那就在下个月的最后一日续期，下下个月恢复第N日续期。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-1
爬取时间: 2025-05-08 07:09:29
来源: Huawei Developer


问题现象


调用展示元服务卡片详情页接口，显示异常页面。


解决措施


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-2
爬取时间: 2025-05-08 07:09:38
来源: Huawei Developer


问题现象


调用加载接口时加载模块失败。


解决措施


支持按需加载的应用需要先上架到应用市场，然后从应用市场下载应用包。应用包安装后才能在应用中调用动态下载接口。开发者通过本地DevEco Studio编译的demo包无法直接调用下载接口。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-28
爬取时间: 2025-05-08 07:09:48
来源: Huawei Developer


不支持，上架是整个.app包，包括基础包和功能包。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-29
爬取时间: 2025-05-08 07:09:58
来源: Huawei Developer


是的，不需要重新发起按需加载请求。产品特性按需分发服务分为两部分，按需加载安装+动态引入模块。只要已经下载安装了应用，就完成了按需下载安装。动态引入是运行时，即应用运行状态下去查找指定模块。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-30
爬取时间: 2025-05-08 07:10:07
来源: Huawei Developer


可以卸载指定模块后重新调用fetchModules接口发起按需加载请求。


使用hdc指令卸载指定应用的指定模块后重新发起请求，卸载命令请参考：hdc shell bm uninstall -n com.xxxx.instantdownloaddemo -m modulelibName。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-26
爬取时间: 2025-05-08 07:10:17
来源: Huawei Developer


推荐使用邀请测试。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-3
爬取时间: 2025-05-08 07:10:27
来源: Huawei Developer


问题现象


调用查询自身场景值接口返回场景值为空。


解决措施


当前应用/元服务没有生成场景值，通过其他应用或者元服务拉起当前应用或者元服务可以产生场景值，然后查询场景值。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-4
爬取时间: 2025-05-08 07:10:36
来源: Huawei Developer


问题现象


调用应用市场更新功能相关API时，提示应用不在前台异常。


解决措施


应用市场更新功能API要求应用必须在前台时进行调用，请在应用处于前台时调用相关接口。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-27
爬取时间: 2025-05-08 07:10:46
来源: Huawei Developer


可以，弹框文案详细信息由用户配置，具体请参考配置可本地化基础信息中的新版本特性。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-5
爬取时间: 2025-05-08 07:10:56
来源: Huawei Developer


问题现象


媒体调用登记归因来源接口时，报错1009300003，身份检查错误。


解决措施


1. 需要将应用通过应用市场上架。


2. 在应用归因云侧注册应用生态伙伴信息。


3. 开发者下配置应用id列表。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-6
爬取时间: 2025-05-08 07:11:06
来源: Huawei Developer


解决措施


过滤关键词：Attr-。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/store-faq-31
爬取时间: 2025-05-08 07:11:15
来源: Huawei Developer


解决措施


过滤关键词：AppGalleryKit|ShortcutManager


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-preview-kit
爬取时间: 2025-05-08 07:11:25
来源: Huawei Developer

- openPreview打开显示预览失败
- 使用DocumentViewPicker拿到的uri通过openPreview打开显示预览失败

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/preview-faq-1
爬取时间: 2025-05-08 07:11:35
来源: Huawei Developer


Preview Kit的openPreview接口在传入文件预览信息时，当前仅支持传入文件的uri，不支持传入文件的沙箱路径。


如果调用openPreview接口后，显示预览失败，请检查传入的是否为uri并且检查传入的uri是否存在。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/preview-faq-2
爬取时间: 2025-05-08 07:11:45
来源: Huawei Developer


DocumentViewPicker拿到的文件uri应用仅有临时权限，该权限无法分享给预览，导致预览失败。可先对uri持久化权限，然后再采用openPreview打开文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ai-function-development
爬取时间: 2025-05-08 07:11:55
来源: Huawei Developer

- 计算平台

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-computing-platform
爬取时间: 2025-05-08 07:12:04
来源: Huawei Developer

- HiAI Foundation

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-hiai-foundation-kit
爬取时间: 2025-05-08 07:12:14
来源: Huawei Developer

- 判断模型能否在手机上运行？
- 如何选择使用同步接口还是异步接口？
- 推理函数支持的数据格式有哪些？
- 如何处理OMG离线模型输出算子类型错误？
- 算法在设计模型时，如何确认哪些算子在HiAI上性能较优？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/hiaifoundation-faqs-1
爬取时间: 2025-05-08 07:12:24
来源: Huawei Developer


通过调用接口HMS_HiAICompatibility_CheckFromFile或者HMS_HiAICompatibility_CheckFromBuffer，传入编译后的模型文件或者模型buffer，如果返回“HIAI_COMPATIBILITY_COMPATIBLE”表示兼容性检查通过，模型可以在手机上运行。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/hiaifoundation-faqs-2
爬取时间: 2025-05-08 07:12:34
来源: Huawei Developer


由业务场景决定，目前两者均支持，从性能考虑推荐使用异步接口。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/hiaifoundation-faqs-3
爬取时间: 2025-05-08 07:12:44
来源: Huawei Developer


推理时传入的inputTensor的数据格式当前只支持NCHW。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/hiaifoundation-faqs-4
爬取时间: 2025-05-08 07:12:54
来源: Huawei Developer


Caffe网络中具有相同类型名但计算功能不同的层。比如DetectionOutput层，需要使用算子映射指明为FSRDetectionOutput、SSDDetectionOutput等检测算子类型，否则OMG生成离线模型会执行失败。为了避免出现错误，以下两种方案二选一即可。

- 方案1：可以在OMG命令中加入--op_name_map参数，参考OMG参数中op_name_map参数设置。
- 方案2：可以在原始网络proto模型文件中将输出算子类型指定为SSDDetectionOutput等算子类型，如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161128.23182005700633354721153351922323:50001231000000:2800:34B20DF1E80FE7932673C3A86D8909E991E7A88F38E0B9BE7B77BD75CFB81166.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/hiaifoundation-faqs-5
爬取时间: 2025-05-08 07:13:04
来源: Huawei Developer


您可参考Model Zoo中的HiAI算子性能指导，根据需要选择性能较优的算子。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-deveco-studio
爬取时间: 2025-05-08 07:13:14
来源: Huawei Developer

- 环境准备
- 工程管理
- 代码编辑
- 界面预览
- 编译构建
- 签名服务
- 应用运行
- 应用调试
- 性能分析
- 应用测试
- 命令行工具

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment
爬取时间: 2025-05-08 07:13:23
来源: Huawei Developer

- 导入Sample时，提示连接Gitee超时
- 导入Sample时，提示SSL证书校验错误
- 下载HarmonyOS SDK时提示网络连接错误
- DevEco Studio无法打开
- 如何配置DevEco Studio的代理
- 安装npm包失败的处理办法
- 如何在命令行使用ohpm
- 流水线场景使用命令行工具sdkmgr下载Linux SDK失败
- ohpm-repo是否支持对HSP包的管理
- c++层的crash怎么定位
- 自动签名时提示“The signature does not take effect or has expired. It may be the current system time is inaccurate, please calibrate the system time and sign again”错误
- DevEco Studio中如何设置超长日志自动换行

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment-2
爬取时间: 2025-05-08 07:13:33
来源: Huawei Developer


问题现象


导入Sample时，导入失败，提示“Failed to connect to gitee.com port 443: Time out”连接超时。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161129.06404648557823348857430349682164:50001231000000:2800:53D3429888F3926AF4839B00397D5987787C8BF83535E5DE767BEFEF6676D42C.png)

解决措施


该问题一般是由于网络受限导致，请检查网络连接状态。如果网络受限，需要通过代理服务器访问网络，请执行以下操作，配置git代理信息。

1.  如果password中存在特殊字符，如@、#、*等符号，可能导致配置不生效，建议将特殊字符替换为ASCII码，并在ASCII码前加百分号%。常用符号替换为ASCII码对照表如下：

```less
git config --global http.proxy http://proxyUsername:proxyPassword@proxy.server.com:port
```

- !：%21
- @：%40
- #：%23
- $：%24
- &：%26
- *：%2A

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment-3
爬取时间: 2025-05-08 07:13:43
来源: Huawei Developer


问题现象


导入Sample时，导入失败，提示“SSL certificate problem: unable to get local issuer certificate”证书校验错误。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161129.94505321838074986051893337473214:50001231000000:2800:1300368BAE5E998127047344AFF7610A9764ECB927480E0B07A6C35EFC608C2E.png)

解决措施


出现这个错误可能是网络遭受了攻击，或者你的网络提供方网络策略阻止了相关操作，如果你确认所处的网络环境安全，可以临时关闭证书校验以获取Sample。

1.  关闭SSL证书校验，可能会带来安全风险，建议导入完Sample后，及时开启。开启方法：将该命令中的false修改为true即可。

```less
git config --global http.sslVerify false
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment-4
爬取时间: 2025-05-08 07:13:52
来源: Huawei Developer


问题现象


网络连接正常，下载HarmonyOS SDK时，却提示网络连接错误。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161129.44631634455158991038728001517445:50001231000000:2800:4E82CAB81DE21A7231A3D89F4DAE6E6BBB522004FCBC8660D9F3E0FF75FF85C2.png)

解决措施


可能因为使用的PC的系统语言是英文，区域码是US所致。按照以下方式，将区域码修改为CN，在修改前请先关闭DevEco Studio。


在 C:\Users\username\AppData\Roaming\Huawei\DevEcoStudio4.1\options 路径下(MacOS路径为/Users/username/Library/Application Support/Huawei/DevEcoStudio4.1/options)，打开 country.region.xml ，修改countryregion name为“CN”。


```less
<application>
    <component name="CountryRegionSetting">
        <countryregion name="CN"/>
    </component>
</application>
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment-6
爬取时间: 2025-05-08 07:14:01
来源: Huawei Developer


问题现象


在Windows 10和Windows 11中，修改字符编码后，安装在中文目录下的DevEco Studio无法打开，报错“Error launching...”。


解决措施


请在英文目录下重新安装DevEco Studio。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment-7
爬取时间: 2025-05-08 07:14:11
来源: Huawei Developer


DevEco Studio开发环境依赖于网络环境，需要连接上网络才能确保工具的正常使用。


一般来说，如果使用的是个人或家庭网络，是不需要设置代理信息的；只有部分企业网络受限的情况下，才需要设置DevEco Studio的代理信息。

1. 
- HTTP配置项，设置代理服务器信息。如果不清楚代理服务器信息，可以咨询你们的网络管理人员。Host name：代理服务器主机名或IP地址。Port number：代理服务器对应的端口号。No proxy for：不需要通过代理服务器访问的URL或者IP地址（地址之间用英文逗号分隔）。
- Host name：代理服务器主机名或IP地址。
- Port number：代理服务器对应的端口号。
- No proxy for：不需要通过代理服务器访问的URL或者IP地址（地址之间用英文逗号分隔）。
- Proxy authentication配置项，如果代理服务器需要通过认证鉴权才能访问，则需要设置。否则，请跳过该配置项。Login：访问代理服务器的用户名。Password：访问代理服务器的密码。Remember：勾选，记住密码。
- Login：访问代理服务器的用户名。
- Password：访问代理服务器的密码。
- Remember：勾选，记住密码。
- Host name：代理服务器主机名或IP地址。
- Port number：代理服务器对应的端口号。
- No proxy for：不需要通过代理服务器访问的URL或者IP地址（地址之间用英文逗号分隔）。
- Login：访问代理服务器的用户名。
- Password：访问代理服务器的密码。
- Remember：勾选，记住密码。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161129.00376096830683546462870363418712:50001231000000:2800:14B2222ED7A74D977688C7F7BEBEB9FEF2B28D11619618ADEB094ECD55958906.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment-8
爬取时间: 2025-05-08 07:14:21
来源: Huawei Developer


问题现象


在执行npm install命令安装npm仓时，提示安装失败。


解决措施


可能是由于未设置npm仓的地址，可执行如下命令后进行重新安装。


```less
npm config set @ohos:registry=https://repo.harmonyos.com/npm/
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment-9
爬取时间: 2025-05-08 07:14:31
来源: Huawei Developer


ohpm 依赖于 node 运行，支持 node.js 18.x 及以上版本，请提前安装 nodejs，并完成环境变量的配置。


ohpm默认解压路径为：DevEco Studio中默认安装位置：<DevEco Studio安装目录>\tools\ohpm；命令行工具中默认安装位置：<Command Line Tools安装目录>/command-line-tools/ohpm。


问题现象1


针对Windows系统，node使用正常，安装ohpm之后，不能直接在命令行中使用ohpm。


解决措施1

1. 
2. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161129.16119335283807910695709027249222:50001231000000:2800:E6B529AD2287A47FDEE6C6A22AA31F0113342116088CBBBCD906F94C6570D6C6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161129.49387623964996747807930665686903:50001231000000:2800:A1707605CCC008A3019CCA0BE5316AB8C7FB80F603FDA0EE522DE1D7ED2081C3.png)

问题现象2


针对Linux/Mac系统，node使用正常，安装ohpm之后，不能直接在命令行中使用ohpm。


解决措施2


编辑命令行的配置文件，把ohpm工具包解压目录中bin目录的路径添加到PATH环境变量中（以Mac系统Zsh命令行举例）。

1. 

```less
vi ~/.zshrc
```

2. 

```less
export PATH="/home/tctAdmin/ohpm/bin:$PATH"
```

3. 

```less
source ~/.zshrc
```

4. 

```less
ohpm -v
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161129.68747455283609695585129380754066:50001231000000:2800:6A7CD607FD568BCC729401E4FF31BCCF3944A978741EA7F7B0B39EF338185564.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment-11
爬取时间: 2025-05-08 07:14:40
来源: Huawei Developer


问题现象


使用命令行工具sdkmgr在linux上使用时提示“Failed to request url https://devecostudio-dre.op.hicloud.com/sdkmanager/v5/hos/getSdkList”

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161129.04532068511604217093038927192200:50001231000000:2800:4A1281A16A3EB786A87EE13CA4906C2C38536A7BE7E4F3E770854E8BD3187DEF.png)

解决措施


该问题一般是由于Linux的国家码不是中国区。

1. 

```less
cd ${命令行工具根目录}/sdkmanager/bin
```

2. 

```less
vim sdkmgr
```

3. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161130.78861853603424611160468983768510:50001231000000:2800:7A1173FA2064D022D39E93A00F373A2211025846FC019F2BB0DB0E3F3A78EF82.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161130.60999476306988362845076922611407:50001231000000:2800:9605B89E492945F462330D28C52ADF8FF1F6F2F0BC189CA9FBB3445190A57AC9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161130.75457860586290250181336238559847:50001231000000:2800:7B4C0F6D1B1A11A3B5DA3A7F1935984B9DCA2C720AD0275BBE883F622A1E6DE1.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment-12
爬取时间: 2025-05-08 07:14:51
来源: Huawei Developer


目前ohpm-repo支持的包管理有.har和.tgz两种，对于HSP只支持应用内HSP，应用间HSP不支持。


在使用ohpm-repo中可以参考：三方中心仓。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment-13
爬取时间: 2025-05-08 07:15:01
来源: Huawei Developer


针对不同问题参考最佳实践CppCrash故障定位指导进行分析定位。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment-14
爬取时间: 2025-05-08 07:15:10
来源: Huawei Developer


问题描述


Automatically generate signature 失败。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161130.55974042722158195129852987046919:50001231000000:2800:6368632DAFEBD65ECE6F6740AFAE5B2BBDB2A50C09C981727F8D3061D7D8648B.png)

解决方案


报错原因：本地PC和服务器时间不一致，把本地PC和北京时间对比一下，精确到秒。


DevEco Studio签名提示系统时间不对，可以在设置-时间和语言-日期和时间-开启自动设置时间，尽量精确到1-2秒


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-development-environment-15
爬取时间: 2025-05-08 07:15:19
来源: Huawei Developer


打开Soft-Wrap功能即可控制日志消息自动换行。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161130.69196866370137334204736160297124:50001231000000:2800:92F0C1693F2CC69FAF2086FE75A2A880E498D36B94ED56C66030C0756B1755B6.png)

日志单条打印最大长度为4096个字符。建议在应用的日志框架中，对于打印的日志长度进行判断，若超过一定长度分段打印，避免日志丢失。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management
爬取时间: 2025-05-08 07:15:28
来源: Huawei Developer

- HarmonyOS API 9工程升级为4.0.0(10)工程
- 工程检查报错，提示“Incorrect settings found in the build-profile.json5 file”
- 环境诊断、创建工程/模块界面全部显示空白
- 打开历史工程，报错提示“Install failed FetchPackageInfo: hypium failed”
- 如何使用DevEco Studio中的ArkTS代码模板
- 如何将HSP（动态共享包）转为HAR（静态共享包）
- 如何将HAR（静态共享包）转为HSP（动态共享包）
- 打印较长的日志内容时，DevEco Studio控制台如何设置
- DevEco Studio如何自动install依赖
- 如何关闭DevEco Studio自动格式化功能
- 如何将HAR工程中引入的其他HAR的接口对外暴露
- 如何解决mac启动DevEco Studio报错提示“devecostudio”意外退出问题
- 如何解决Windows系统使用DevEco Studio时SDK卸载失败，报“Unable to rename the file. Cause:Unable to delete D:\xxx\default”错误
- .h文件中uint8_t无法使用如何解决？
- 如何编译HarmonyOS Next版本so库的32位版和64位版
- 如何使用DevEco Studio上的Git工具进行多远程仓管理
- 如何通过离线方式安装npm包
- 工程中存在多处-Wunused-command-line-argument告警，影响查看有效日志
- 如何设置可以在工程目录中自动定位当前打开的文件
- 打开工程时左侧目录树不显示
- ExternalCpp视图中显示SDK的系统API

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-1
爬取时间: 2025-05-08 07:15:38
来源: Huawei Developer

1. 
2. 

```less
"app": {
  "signingConfigs": [],
  "products": [
    {
      "name": "default",
      "signingConfig": "default",
      "compileSdkVersion": "4.0.0(10)",    //指定HarmonyOS应用/服务编译时的版本
      "compatibleSdkVersion": "4.0.0(10)", //指定HarmonyOS应用/服务兼容的最低版本。版本号需改为"4.0.0(10)"，注意使用英文.和()
      "targetSdkVersion": "4.0.0(10)",     //指定HarmonyOS应用/服务目标版本。若没有设置，默认为compatibleSdkVersion
      "runtimeOS": "HarmonyOS",            //指定为HarmonyOS/OpenHarmony
    }
  ],
  ...
}
```

3. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161130.88135954135100884005058737635454:50001231000000:2800:33D5DA32F623DE553116C6D7FB0D1F2BE72362C2BC9BE4FE48923172B844A53A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161130.02968798006495046658200201014332:50001231000000:2800:E470F0B5B1B939E3798267F36B7B0F37C4DCE9793B617AEEE091AB7FC457DE52.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161130.13550215993979706365195851308118:50001231000000:2800:0D5A864C9976BB89BF417F32C8DE4B7DCA4F48774BB471FDE3F92121A938FD90.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161130.70871282922770902460266410346820:50001231000000:2800:973386E46A9343280F5D8DC0EBEA533CA58C8498B929661E6D197B1FCA6C77BB.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-2
爬取时间: 2025-05-08 07:15:47
来源: Huawei Developer


解决措施


```less
{
  "app": {
    ...
    "products": [
      {
        "name": "default",
        "signingConfig": "default",
        "compileSdkVersion": "4.0.0(10)",    //指定HarmonyOS应用/服务编译时的版本
        "compatibleSdkVersion": "4.0.0(10)", //指定HarmonyOS应用/服务兼容的最低版本。版本号需改为"4.0.0(10)"，注意使用英文.和()
        "targetSdkVersion": "4.0.0(10)",     //指定HarmonyOS应用/服务目标版本。若没有设置，默认为compatibleSdkVersion
        "runtimeOS": "HarmonyOS",            //指定为HarmonyOS
      },
      ...
    ],
    ...
  },
  ...
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-3
爬取时间: 2025-05-08 07:15:56
来源: Huawei Developer


问题现象


打开环境诊断界面、选择工程/模块的模板时，界面显示全部空白；工程预览界面也为空白。


解决措施


导致该问题的可能原因为电脑GPU不兼容，或在云桌面的场景下使用DevEco Studio。


在DevEco Studio中双击Shift，在弹出的窗口中搜索Registry...，在Registry页面中勾选ide.browser.jcef.gpu.disable项，关闭窗口并重启DevEco Studio即可。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161130.70897369100253091559629396978123:50001231000000:2800:5EFFECADDCD2B82AB7DC2A9F2D477102438CB50B74EBF0B16E3BD33002BA284A.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-4
爬取时间: 2025-05-08 07:16:05
来源: Huawei Developer


问题现象


在DevEco Studio打开历史工程，依赖安装不成功，报错信息为"Install failed FetchPackageInfo: hypium failed"。


解决措施


导致该问题的可能原因为包名使用错误。在工程级oh-package.json5中，将devDependencies字段下"hypium"修改为"@ohos/hypium"。hypium具体版本信息请参考配套关系。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.41867633616469273347170794592248:50001231000000:2800:8EB22895D712B054AEF6DC5BFE478CC7DFFD0928A11B0E33218A19FC63076EF6.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-5
爬取时间: 2025-05-08 07:16:14
来源: Huawei Developer


开发过程使用代码模板，可以提高开发效率，DevEco Studio中可以在“File > Settings > Editor > Live Templates”中查看现有支持的代码模板，也可新增自定义模板。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.46337260007020471449589819210935:50001231000000:2800:F14BFC43537C0EA6909E1A9462AFEC192AE28A5CDF4DDF46561A138A646D95CD.png)

如上图所示，点击展开，可查看已提供的模板详情，点击右上角加号，可新增自定义模板。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.74689879395147092749956840745667:50001231000000:2800:9A5043861512CFA136C6E04297380B45C6D5C6C720BECC1F7F9F79A5EA6A9AC8.png)
1.  输入button后，会自动链接显示存在的代码模板，双击后自动补全。
2.  如上图所示。选择“Template Group”，新增模板群组来表示自定义模板。 选中自定义群组 > + >Live Template，来新增模板。 以定义Component的模板为例，在Abbreviation中输入模板的名称，此处的输入值就是代码模板的快捷键，在Template text中编辑模板样式，其中$符号包括的是用户使用代码模板后需要自己输入的部分。 点击上图Change处，可选择代码模板使用的文件。 点击Edit variables在弹窗中来设置LABEL值的自动获取方式。 自定义的代码模板生效。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.51606571981291376576016924438844:50001231000000:2800:2511C6988297ED140B061F30CBC9AD1D79AF90B9E04F10F5FC444DC2F27571A1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.50134139778623684982059530015947:50001231000000:2800:3CB49DB07C691A61FF962BD471E2BB1943C31E9B0F2784249A532C7D5F3C02ED.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.66019753846538230526223793498952:50001231000000:2800:0A859EC6EFF7E73155A0AD733FF8E3561B465007D52DDD90413D442856AB7175.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.95791165166067091444527728009188:50001231000000:2800:EC2052FF92E45DE94EBD032DD751B925021C5AA618F0BE993D8671D10029E957.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.93030343771575858768207793185772:50001231000000:2800:828806CA165011D6B046ED5625566AE6D92DB2EEEC881D2B5BD8B79A1B9F0A1A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.40467453421779461157413943736573:50001231000000:2800:7AA82C09B3C678EFE688BE39CB1459CDF5FEB3C4561D67E2C9B0DC5D1AFF909A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.91645881523983126404090634358079:50001231000000:2800:CE00FCC4CC2ED6F8AAFA3A352A8D7A2AC72265FE9BAE7D768BE2F91680ED03C6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.10284175719521542465255444842512:50001231000000:2800:D4D94ED2A821EC3E447EBE9DDB4834560C5075560C93C0310A8C1008AF6C2F74.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.88767884135437521049725281939491:50001231000000:2800:D0DFEA7EAD132B6C15EFF77DC519E6F1FB25AAD89E711270D36850565C898DD2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.19961596518435675574413188923090:50001231000000:2800:571AA9DFB2058C66B86811AA00A793EED3B32C4129FC7CD317CBD9FA69B43966.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161131.23632169021236379965486174900677:50001231000000:2800:2F6E4564E5793EB5F79C8F637866124B0F4DC884506002ED5075AA1C90C86DB8.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-6
爬取时间: 2025-05-08 07:16:23
来源: Huawei Developer


HSP转换成HAR可参考如下步骤：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-7
爬取时间: 2025-05-08 07:16:33
来源: Huawei Developer


HAR转换成HSP可参考如下步骤：


```less
"dependencies": {
  "myhar": "file:./lib/myHar.har" // myHar.har路径：oh-package.json5文件同目录下的lib文件夹下面
}
```


```less
export * as myhar from 'myhar';
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-8
爬取时间: 2025-05-08 07:16:42
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-9
爬取时间: 2025-05-08 07:16:52
来源: Huawei Developer


DevEco Studio在以下三种场景会自动install依赖：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-10
爬取时间: 2025-05-08 07:17:02
来源: Huawei Developer


如果是复制C/C++的代码到DevEco Studio中会自动格式化，可以在File -> settings打开设置界面，搜索Code Style，找到C/C++，选择Other，去掉Format On Paste的勾选


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-12
爬取时间: 2025-05-08 07:17:11
来源: Huawei Developer


问题描述


现在有一个HAR工程引入公司内部其他产品的har包，现在想通过一个HAR的方式对外提供。有没有对应配置方法？


例如：a.har工程里包含并使用了b.har现在需要对外提供a.har,使其对外暴露的接口功能中,涵盖b.har所有对外功能。能否通过配置进行实现。


解决方案


可以将b.har中的所有接口对外导出的时候使用namespace进行导出：如导出b.har的工具中多个方法


b.har根目录下的Index.ets

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161132.90149137102717918203101370064023:50001231000000:2800:9AE04546C580D5047392CD72D88DE9B9C9F7C9E114D53AA0AC439B95044C1515.png)

在a.har根目录下的Index.ets文件中，添加如下内容：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161132.01411698948285513006236235725321:50001231000000:2800:EB11842FA6BC442A206C198AE650B07C6EA9719ADA9D046A9F7DFD7A9DA76CA4.png)

外部调用

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161132.30401400419520118654893346453079:50001231000000:2800:4E59FD18CE488C2B36B0DE17702C4F10675902560A7DE912AFFFB2926C1A8C82.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-13
爬取时间: 2025-05-08 07:17:21
来源: Huawei Developer


问题描述


mac启动DevEco Studio报错提示“devecostudio”意外退出

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161132.40299392736558350624792873271881:50001231000000:2800:84A1EA4097F79D67E955014C92BDBE3BB38321AAE1CE68F68248B43B4007E46F.png)

解决方案


问题根因：异常修改了jetbrain启动脚本中的环境变量，导致java虚拟机无法启动，DevEco Studio无法打开，弹窗报错。


规避措施：删除启动脚本（/Users/{USER_NAME}/Library/LaunchAgents/jetbrains.vmoptions.plist），重启mac。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-15
爬取时间: 2025-05-08 07:17:30
来源: Huawei Developer


问题描述


windows系统使用DevEco Studio时SDK卸载失败，提示


Unable to rename the file.Cause:Unable to delete D:\xxx\default.


解决方案


1、打开任务管理器


2、切换到“性能”页签


3、点击下方“打开资源监视器”

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161132.38936772090832966063041781183049:50001231000000:2800:E5971F0D4227DC57D55A3023C79A85406EBD45C6EB99B33B810249AEA52F8AF0.png)

4、把上方提示的路径D:\xxx\default粘贴到关联的句柄窗口右侧搜索栏，回车搜索占用的进程，结束该进程即可。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161132.58541839760329963899128893139283:50001231000000:2800:AF66A9712E92B1E3B5E829958DFBA884C95C8508BB1B553C21297BFF46209AED.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-16
爬取时间: 2025-05-08 07:17:40
来源: Huawei Developer


解决措施


```less
#ifdef __cplusplus
extern “C” {
#endif
#include “MGDolphinTOTP.h”
#include “MGDolphinTOTPsha1.h”
#ifdef __cplusplus}#endif
```

1.  add_library(entry SHARED hello.cpp NapiTest.cpp MGDolphinTOTP.c MGDolphinTOTPSha1.c)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-17
爬取时间: 2025-05-08 07:17:49
来源: Huawei Developer


问题描述：


HarmonyOS Next版本是不是只有64位，不需要提供32位so库？


解决方案：


只有64位,不支持32位。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-19
爬取时间: 2025-05-08 07:17:59
来源: Huawei Developer

1. 
2. 
3. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161132.84319692248649863537931046340886:50001231000000:2800:A1A60BA5D65FC2B5051A72E8ECB9A4C6D3011C1A97BA6C116B5BDA92AA8F933E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161132.54780480232690125924795654453745:50001231000000:2800:6D88AD9B3775AB52B0210AAD724B1CF420C10BC5A1F4F7CA8CDC3E7F801B25C8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161132.20245976656292117368790787764884:50001231000000:2800:C834869CA8A667B0026D0BEF329AE566D83AA2FC455340A4BCBA339FF39AEF89.png)

Push提交：


Push提交和Push提交到远程仓库基本一样，如果有需要的话，单击下图中标记1的分支名可以切换远程仓，标记3表示以PR方式提交。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161132.32885469654365751138493484696581:50001231000000:2800:658B07EBC9DD0964499DD4FEC00E56F3B3DF6E7E7C1F32554E12434BE0742619.png)

切换默认关联的远程仓库：


```less
git branch hmos_dev_20230907 --set-upstream-to=codehub_origin/hmos_dev_20230907
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-20
爬取时间: 2025-05-08 07:18:09
来源: Huawei Developer


前置条件

- 有网环境PC一台。
- 离线环境PC已有node基础环境。
- 离线环境PC需安装Verdaccio工具（可通过以下安装离线包的方式来安装工具）。
1.  npminstall –g husky（npm-pack-all依赖）。
2.  npminstall –g husky（npm-pack-all依赖）。
3. 
4. 
5. 
6. 
7. 
1.  npminstall –g husky（npm-pack-all依赖）。
2. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161132.51919384043603953239189097889598:50001231000000:2800:D435A63935FCEC66879E040D6D90ADE46DC7B04DD1709E9B4948CBA0790998FF.png)
1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161132.71863820952238506805123550529404:50001231000000:2800:5CFE7AC8773F8503DB7599E838EE731D5A78B77B384994CD3CC30ADA51F330B3.png)
1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161133.36803852622350779316142990964713:50001231000000:2800:B6A660745827F2AC8E71AD696530C2A31844734FF762E07A22134663112D91A1.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-21
爬取时间: 2025-05-08 07:18:18
来源: Huawei Developer


问题描述


```less
clang: warning: argument unused during compilation: ‘–gcc-toolchain=C:/Users/username/AppData/Local/Huawei/Sdk/openharmony/9/native/llvm’ [-Wunused-command-line-argument]；
```


API 9版本内的clang编译器，编译每个文件都会报warning，当前可以通过屏蔽-Wunused-command-line-argument来执行，但是工程太多，是否有方法可以屏蔽这个告警？


解决方案


根据clang提示，可以看出这个告警是由-Werror,-Wunused-command-line-argument告警选项校验的，可能是代码中存在一些变量语法不支持，可通过配置-Wno-unused-command-line-argument关闭这个检查项或者尝试将sdk升级到api11。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-23
爬取时间: 2025-05-08 07:18:28
来源: Huawei Developer


问题现象


打开一个文件时，希望在左侧工程目录中可以自动到定位当前文件所在的位置。


解决措施


在工程目录右上角点击Select Opened File图标，即可定位到目前打开文件在工程目录里所在位置。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161133.84190617419532349935682481562743:50001231000000:2800:0BFF8B115DE1143FB41106DAEEF363D49420E01AA74371909B69E17961E4051E.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-24
爬取时间: 2025-05-08 07:18:37
来源: Huawei Developer


问题现象


当用户删除工程目录下的.idea/modules文件夹或者.idea/modules文件夹不存在时，如下图所示。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161133.50400691288763828381096184683551:50001231000000:2800:49947DAE106A7228089DDC33288A1C4BB228D6082B3D331F967246715DED4B20.png)

重新打开工程，左侧目录树不显示，如下图所示。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161133.05864869137100049345071327377929:50001231000000:2800:871CC7ABC4BC9A557C26E5370C15D624FF5832C9BC61D859FF474054A9476751.png)

问题原因


modules文件夹下的iml文件定义了详细的工程模块结构信息，modules.xml定义了工程模块结构文件的位置。删除modules文件夹后根据modules.xml无法找到对应的iml文件。


解决措施


需要关闭工程，在文件管理器中删除工程的modules.xml，重新通过DevEco Studio打开工程，工程目录树才可以恢复。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161133.09527403335476033974835220089418:50001231000000:2800:EEF59037BDA3225ED17657F2925C9F3E31D235599F055BCD53703CB54A3A1730.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-project-management-25
爬取时间: 2025-05-08 07:18:47
来源: Huawei Developer


问题现象


ExternalCpp视图中显示SDK的系统API。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161133.74825709352309459850372141420844:50001231000000:2800:7F74AA6BB2BB406602E8AA86301063F1F596857BE7F7B448E74E52253431537D.png)

可能原因


在本地存在多个DevEco Studio（包括Command Line Tools）打开同一个工程，并且使用daemon模式构建该工程。


解决措施


关闭多余的DevEco Studio（包括Command Line Tools）或者使用--no-daemon模式构建工程。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding
爬取时间: 2025-05-08 07:18:56
来源: Huawei Developer

- 编辑器自动联想、跳转等功能失效
- DevEco中是否有一键检查未引用资源的功能
- 在DevEco Studio中提交代码时，如何自动格式化修改过的代码
- DevEco中是否有预览结构树的方法
- 如何解决DevEco Studio左侧加断点的区域消失，无法加断点的问题
- DevEco Studio设置新建ets文件时自动添加头部注释和版权声明的方法
- 使用ESObject类型提示告警
- 关于BuildProfile自定义字段报错:Property 'BUILD_VERSION' does not exist on type 'typeof BuildProfile'
- 如何过滤编辑器对超大文件的扫描
- 如何配置编辑器Node进程的内存上限
- DevEco Studio上使用生成NAPI功能时， 提示 “Unsupported parameter type.” 或 “Unsupported return type.”错误
- DevEco Studio上使用生成NAPI功能时， 提示 "Failed to generate NAPI, check the napi_init.cpp file and try again. "错误
- DevEco Studio上使用生成NAPI功能时， 提示“ Could not find usage of napi_module_register in napi_init.cpp. ”错误

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding-1
爬取时间: 2025-05-08 07:19:05
来源: Huawei Developer


问题现象


在DevEco Studio上进行代码编辑时，代码自动联想、代码跳转等功能失效。


解决措施


导致该问题的可能原因是工程文件所在的目录存在中文字符，请将该工程移动到全英文目录下，然后重新打开工程即可。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding-2
爬取时间: 2025-05-08 07:19:14
来源: Huawei Developer


DevEco中有一键检查未引用资源的功能，可以在DevEco的上方Code > Analyze Code > Run Inspection by Name或使用快捷键Ctrl+Alt+Shift+I，在选项框输入Unused resources，即可进行资源检查。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161133.42945933762449124821063046653246:50001231000000:2800:49C1C8C4F0891A08B8132B007F269C2035DC2D158573DB75A6EEDBA2BB7EB6A3.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding-3
爬取时间: 2025-05-08 07:19:24
来源: Huawei Developer


在Project目录中，选择需要提交的文件或文件夹，点击鼠标右键，选择git -> Commit File，出来单独的Commit Changes窗口，在窗口中勾选Reformat code，可以自动格式化需要提交的代码。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161133.38805872648243780632800601004366:50001231000000:2800:64EE31C9C1837C6A214C06D624EE675C91FFF0FA6C5E4F8AE396A5A6B0FDCFC7.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding-4
爬取时间: 2025-05-08 07:19:34
来源: Huawei Developer


DevEco中有代码结构树。使用快捷键Alt + 7 / Ctrl + F12（macOS为Command+7）打开代码结构树，或者在DevEco Studio中点击菜单：View > Tool Windows > Structure，快速查看文件代码的结构树，包括全局变量和函数、类成员变量和方法等，并且可以跳转到对应代码行。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161133.84519695640792329555590279665218:50001231000000:2800:58B0D846A73671238615A385AB9A59B60222BF2DD38FFEC2E96C81C3E19B42C6.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding-6
爬取时间: 2025-05-08 07:19:44
来源: Huawei Developer


在setting -> Editor -> General -> Gutter Icons中勾选Show gutter icons，将开关打开即可。如图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161133.34586168801524913698366937506927:50001231000000:2800:4F2B5747848CAE1455733B5798323AC921BA4AE2970B235FFE09EAA2A1724675.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding-8
爬取时间: 2025-05-08 07:19:54
来源: Huawei Developer


自动添加头部注释方法File --> Settings --> Editor --> File and Code Templates，右侧选Files > ArkTS File后，添加内容如下：


```less
/**
 * 添加描述
 *
 * @author Your ID
 * @since ${YEAR}−${MONTH}-${DAY}
 *
 * Copyright © Huawei Technologies Co., Ltd.${YEAR}−${YEAR}. All rights reserved.
 */
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161134.33835037177298684991874909925972:50001231000000:2800:4C6F24CE166F9DC8F03A281854CB79852E3187F8B0F12F58944ECEBE7E4B5E9C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161134.68902528935605971221810196600408:50001231000000:2800:09975F61CE2450727900D87831B3BB5A2494471CFD7CD9E36521494ADF7CB7F8.png)

新建一个后缀是ets的文件：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161134.61943034370489788619854258128118:50001231000000:2800:F97B08311F0EF269C2503F4EB3686F145B896C544E150D31F20349DDCBDC0D0E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161134.66751458742132785633293586724261:50001231000000:2800:0254BD9EDC779EB8C55FB69E53F2E9A4DB351922E438CEFE5DA7C6424926A3F7.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding-9
爬取时间: 2025-05-08 07:20:03
来源: Huawei Developer


问题现象


在API 10及以上工程的.ets文件中使用ESObject类型，编辑器界面出现WARN告警。


解决措施


ESObject类型在DevEco Studio 4.0 Release版本支持使用，请尽量使用具体类型替代ESObject，如无法获知具体类型，则可忽略该WARN告警。


ESObject类型仅支持在API 10及以上版本使用，更低API版本下无法识别ESObject类型，编码时使用将产生Error告警。请将ESObject替换为具体类型，避免影响后续编译。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding-10
爬取时间: 2025-05-08 07:20:13
来源: Huawei Developer


问题描述


项目编译关于BuildProfile自定义字段报错如下:


```less
Property 'BUILD_VERSION' does not exist on type 'typeof BuildProfile'
```


解决措施


在代码中获取构建参数,生成BuildProfile类文件后，在代码中可以通过如下方式引入该文件：


```less
import BuildProfile from '${packageName}/BuildProfile';
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding-11
爬取时间: 2025-05-08 07:20:22
来源: Huawei Developer


问题现象


工程中存在ProtoBuf等工具自动生成的超大源码（如十万行以上源码）文件时，编辑器扫描加载这些文件后会占用较多的系统运行内存资源。如果用户不需要在这些文件使用代码编辑相关功能，可以通过配置编辑器扫描单个文件大小的上限进行过滤。


解决措施


以过滤大小超过10M的文件为例，通过DevEco Studio菜单栏的Help > Edit Custom Properties...，打开idea.properties配置文件，在文件中新增一行arkts.server.max.intellisense.filesize=10240，并重启DevEco Studio，编辑器则会过滤大小超过10240KB（即10MB）的文件。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161134.02030534879394890183209155950415:50001231000000:2800:A1928846FB4800DE84D0B08E42C92297B99E86E5A1A63D72E2D9D1F8CAB8703E.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding-12
爬取时间: 2025-05-08 07:20:32
来源: Huawei Developer


问题现象


用户工程超大时，编辑器启动扫描工程代码，可能会存在编辑器Node进程超出内存上限（默认为8G）的问题，导致编辑器启动失败，该场景可以通过调整编辑器Node进程的内存上限来处理。


解决措施


以配置内存上限为10G举例，通过DevEco Studio菜单栏的Help > Edit Custom Properties...，打开idea.properties配置文件，在文件中新增一行arkts.server.max.old.space.size=10240，并重启DevEco Studio，编辑器Node进程的内存上限会配置为10240M（即10G）。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161134.50094010361025199451822192763055:50001231000000:2800:493BF34AD1A0CDB1B33949C797B7FF585129A8F5EE91D8A426326B9A807DD3E9.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding-13
爬取时间: 2025-05-08 07:20:42
来源: Huawei Developer


问题现象

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161134.10371797990524092485604212923886:50001231000000:2800:9AC80120A9E51F1825C94F4C5B1C68D8A5BEA5640ABB7356084C76B91439FC82.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161134.70786568636770622413959671360477:50001231000000:2800:834E525B1B47A6FF9A96C69A0AB1AC754B6DA4C2991818163B6B0F2B0234455B.png)

解决措施


修改生成NAPI函数的函数参数或返回值类型。


当前支持的类型（JS 和 C++ 的类型映射关系）：

- void：void
- number: int, int32, uint32_t, int64_t, uint64_t, double（float不支持，NAPI接口不支持）
- string: char*, char16_t*, const char*, const char16_t*, char, char const, const char, std::string
- boolean：布尔值
- 用户自定义结构体类型: C++用户自定义结构体类型 class（不包括系统库的类）
- Array<>: std::vector<>, std::array<> （支持std::vector<>和std::array<>的嵌套解析）

不支持的类型：

- 不支持模板函数
- 不支持模板类
- 不支持枚举enum
- 不支持联合union
- 不支持除了std::vector<>,std::array<>以外的系统容器，如iterator，set，map，list，stack等
- 不支持用户自定义类以外的系统库的类
- 不支持其他引用和指针
- 不支持函数类型的转换，例如函数返回一个回调函数
- 不支持auto类型

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding-14
爬取时间: 2025-05-08 07:20:51
来源: Huawei Developer


问题现象

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161134.76215096990949007957978651601499:50001231000000:2800:6D2DE78C9F6615AECCBB058A1994EC5A415267A7FEA16CFCE8A9105EE37A9797.png)

解决措施


检查napi_init.cpp文件的Init函数中是否初始化了napi_property_descriptor变量。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161134.20624846052161221701411706032721:50001231000000:2800:B4EA9F57BDC4D2E3453BBF96F2AA97CDE8A077FA9810E11632DFE17583A3237D.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-coding-15
爬取时间: 2025-05-08 07:21:00
来源: Huawei Developer


问题现象

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161135.61072610300855262113996768345583:50001231000000:2800:076286451B46197023C1E1BC7BF1707F47102D9D2F997C41ED445B1E07CEF2CB.png)

解决措施


检查napi_init.cpp文件的RegisterEntryModule函数中是否调用了napi_module_register函数。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161135.50393851113956674389341946913306:50001231000000:2800:8602B9D3B52C65C2DF8C910E575F05EB0663FF9E904EE8B04F50776D48975F60.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-previewer-operating
爬取时间: 2025-05-08 07:21:10
来源: Huawei Developer

- 如何设置DevEco Studio 的预览功能的屏幕像素值
- 预览功能使用过程中，可能无法使用帮助菜单压缩日志按钮收集日志
- 预览告警“@Consume/@Link decorated property <propertyName> not initialized”
- 预览告警“There are properties not initialized”
- 预览报错“Node service error detected. Reinstall DevEco Studio to fix the error”
- 预览窗口顶部和底部出现白边
- DevEco无法执行Previewer，报错“This module is referencing one or more HSPs and cannot be previewed.”怎么处理

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-previewer-operating-1
爬取时间: 2025-05-08 07:21:19
来源: Huawei Developer


问题描述


DevEco Studio 的预览功能当前可以使用 phone，PC/2in1，Foldable, 但是这几种设备不能直观的显示出屏幕的高宽的像素值。


解决方案


预览器有一个New Profile功能，可以自己填写屏幕尺寸和DPI

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161135.82190098201230479182013172070202:50001231000000:2800:4CB8FD669034DC0FA97682E7DE76A4C3D9E96B07A0F1F691749797FE197589B8.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-previewer-operating-2
爬取时间: 2025-05-08 07:21:29
来源: Huawei Developer


问题现象


当打开多个工程并且同时预览时，此时点击帮助菜单上的压缩日志按钮，可能会出现日志文件被占用导致无法压缩的情况。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161135.59070014716750527739119947484773:50001231000000:2800:8B2B155A929DC6A36CE3C0A893D6B80A0D9D3513594CF2CD4B0AB1D6A70DF3E6.png)

此时右下角会出现压缩失败的提示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161135.09380109192989197043245530114288:50001231000000:2800:5D2CB3469FCB56349852BA09C81406363811C82CAB81D6A0CE367249BB721561.png)

解决措施


请关闭预览过的工程，或者重启DevEco Studio后先不要打开预览器，即可再次压缩收集日志。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-previewer-operating-3
爬取时间: 2025-05-08 07:21:39
来源: Huawei Developer


问题现象


启动预览后，预览窗口出现如下白屏，并在上方出现“Preview failed. View details in the PreviewerLog window.”的错误信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161135.02485898683897304011992118031817:50001231000000:2800:D2C96D4DDD82F116D0F0691CB62D83478B270E5C82DAB8DA57B1CB9C5C302D14.png)

此时下方PreviewLog窗口出现如下告警信息“@Consume/@Link decorated property<propertyName>not initialized.”

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161135.01932058562243400337676471917170:50001231000000:2800:0506054350FBA0A6172240B064838AF7308042E4A9EF1F1C82085B4B0664A7A4.png)

解决措施


如果预览页面/组件内含有@Consume（或者@Link）装饰的成员，预览时可能会出现白屏。


建议不要直接预览含有@Consume（或者@Link）装饰成员的子组件，通过预览父组件的形式来查看子组件的预览效果。


示例代码：


```typescript
// 建议通过在ParentComp上添加@Preview，预览ParentComp来查看ChildComp的预览效果
@Preview //组件预览
@Component
struct ParentComp {
  // @Provide装饰的变量reviewVotes由入口组件ParentComp提供其后代组件
  @Provide reviewVotes: number = 10;


  build() {
    Column() {
      Button(`reviewVotes(${this.reviewVotes}), give +1`)
        .onClick(() => this.reviewVotes += 1)
      ChildComp()
    }
  }
}


// @Preview 不建议直接预览ChildComp
@Component
struct ChildComp {
  // @Consume装饰的变量通过相同的属性名绑定其祖先组件ParentComp内的@Provide装饰的变量
  @Consume reviewVotes: number;
  build() {
    Column() {
      Text(`reviewVotes(${this.reviewVotes})`)
      Button(`reviewVotes(${this.reviewVotes}), give +1`)
        .onClick(() => this.reviewVotes += 1)
    }
    .width('50%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-previewer-operating-4
爬取时间: 2025-05-08 07:21:48
来源: Huawei Developer


问题现象


启动预览后，预览窗口出现如下白屏，并在上方出现“Preview failed. View details in the PreviewerLog window.”的错误信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161135.12742199630351600192255631968588:50001231000000:2800:8FB10F43AA01E88239AC5E79FD4829A16EFD055BAC9E6B7005DD5B58EBB649A6.png)

此时下方PreviewLog窗口出现如下告警信息“There are properties not initialized.”

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161135.46515962061631086376911440026891:50001231000000:2800:614BCA99C1F665B9169FDABF7D9966C24B88495EF616DE7C9C7B5EBA33FA7C2B.png)

解决措施


预览页面/组件含有未初始化成功的成员变量，调用这些成员变量的属性/方法时会导致报错，预览白屏。可能导致该问题的典型原因有：


场景一：使用了AppStorage等方式设置的全局变量。


场景二：使用了router.getParams()获取路由参数。


请使用自定义Mock。

1. 

```less
"dependencies": {
  // 版本号需根据hvigor及SDK的配套关系进行修改
  "@ohos/hamock": "1.0.0"
}
```

2. 

```less
import { MockSetup } from '@ohos/hamock';
```

3. 

```typescript
@MockSetup
mock(){
  this.fruit = new Fruit("apple");
}
```


场景一：使用了AppStorage等方式设置的全局变量，修改后的示例代码如下：


```typescript
import { MockSetup } from '@ohos/hamock';


export default class Fruit{
  public name: string;


  getName(): string{
    return this.name;
  }


  constructor(name: string) {
    this.name = name;
  }


}
@Entry
@Component
struct GlobalData {
  @State fruit:Fruit = AppStorage.get("fruit") as Fruit;


  @MockSetup
  mock(){
    this.fruit = new Fruit("apple");
  }


  build() {
    Row() {
      Column() {
        Text(this.fruit.name)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


场景二：使用了路由参数，修改后的示例代码如下：


```typescript
@Entry
@Component
struct Page {
  @State params: object = router.getParams();


  @MockSetup
  mock(){
    this.params = [];
    this.params["path"] = "path";
  }


  build() {
    Row() {
      Column() {
        Text(this.params['path'])
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
      }
      .width('100%')
    }
    .height('100%')
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-previewer-operating-5
爬取时间: 2025-05-08 07:21:58
来源: Huawei Developer


问题现象


预览启动失败，并在PreviewerLog窗口显示“Node service error detected. Reinstall DevEco Studio to fix the error”的错误信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161135.93188468571204736379279532522297:50001231000000:2800:9ADA2A757982160AF597EB3A035091FC0AAFD55E1EB7F476B4525BB3034D2E0A.png)

解决措施

- 方案一：DevEco Studio内置文件被破坏，请重新安装DevEco Studio。
- 
- Windows平台配置文件：C:\Windows\System32\drivers\etc\hosts。
- Mac平台配置文件：/private/etc/hosts。
-  以管理员身份打开命令提示符窗口或PowerShell，执行以下命令：

```less
net stop winnat
```


```less
net stop winnat
```


```less
net start winnat
```

- Windows平台配置文件：C:\Windows\System32\drivers\etc\hosts。
- Mac平台配置文件：/private/etc/hosts。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161135.26298620741641234444234844861834:50001231000000:2800:1DE9BFD2EDF9AABB7916415A8D7970BC5BD1197ACEB96CD533A6F855E9359904.png)

```less
net stop winnat
```


```less
net start winnat
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-previewer-operating-6
爬取时间: 2025-05-08 07:22:08
来源: Huawei Developer


问题现象


Phone/Default/Tablet设备启动预览后，在预览窗口的顶部和底部出现白边。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161135.07459188141148228381413767360282:50001231000000:2800:290AEA87D296A2BD14B7D9A8097F1BBA91F5861540ED2BF30B8C244482F463CC.png)

解决措施


这是应用了沉浸式的特性，其中状态栏和导航条，在沉浸式布局下称为避让区，避让区之外的区域称为安全区，在默认情况下，开发者的组件被布局在安全区内。如果开发者希望将页面布局应用到全屏窗口，可以采用如下两种方式：


```less
//Index.ets
@Entry
@Component
struct Index {
  @State message: string = 'Hello World';


  build() {
    RelativeContainer() {
      Text(this.message)
        .id('HelloWorld')
        .fontSize(50)
        .fontWeight(FontWeight.Bold)
        .alignRules({
          center: { anchor: '__container__', align: VerticalAlign.Center },
          middle: { anchor: '__container__', align: HorizontalAlign.Center }
        })
    }
    .height('100%')
    .width('100%')
    .backgroundColor('#008000')
    .expandSafeArea([SafeAreaType.SYSTEM])
  }
}
```


```less
// EntryAbility.ets
onWindowStageCreate(windowStage: window.WindowStage): void {
  // Main window is created, set main page for this ability
  hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
  windowStage.loadContent('pages/Index', (err) => {
    …..
  });    
  windowStage.getMainWindow((err, data) => {
    if (!err.code) {
      data.setWindowLayoutFullScreen(true)
    }
  }); 
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-previewer-operating-7
爬取时间: 2025-05-08 07:22:17
来源: Huawei Developer


可能原因如下：

- 引入了HSP，DevEco Studio NEXT Developer Beta1版本预览不支持引用HSP。引用了HSP的模块不支持预览，请直接在HSP内预览。
- 项目里使用的方法API可能不在Previewer支持的列表里：支持使用预览器的API清单

可以尝试使用Previewer下面的设备管理器的本地模拟器，或者usb连接真机尝试运行。


参考链接


查看ArkTS/JS预览效果


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building
爬取时间: 2025-05-08 07:22:26
来源: Huawei Developer

- 编译报错“JS heap out of memory”
- Linux环境下编译报错“JS heap out of memory”
- 编译告警“The re-export name 'xx' need to be marked as type”
- 编译报错“Cannot find module XXX or its corresponding type declarations”
- 编译报错“ERROR: Failed :entry:default@CompileResource”
- 编译报错“Module 'xxx' has no exported member 'yyy'”
- 编译报错“Could not load ${file1} (imported by ${file2}): Maximum call stack size exceeded”
- 编译报错“Failed to get a resolved OhmUrl by filepath xx”
- 编译报错“Property xxx does not exist on type 'typeof BuildProfile'.”
- C++工程编译导致电脑卡顿的处理建议
- JDK版本不匹配导致编译失败
- LABEL_VALUE_ERROR处理指导
- 应用/服务的启动界面信息缺失，提示"Schema validate failed"报错
- 编译报错“Schema validate failed”
- 编译报错“No available entry module found”
- 编译报错“keystore password was incorrect”
- 编译报错"please check deviceType or distroFilter of the module"
- 编译报错“Failed to generate test project build system”
- C/C++项目三方依赖库未打包入HAP
- Static Library模块中src/main/cpp目录下的文件未打包进HAR
- ArkUI-X工程编译报错“The ArkUI-X project's structure has been changed”
- Target AOT编译，AP文件生成失败
- 工程编译告警提示“ArkTS:WARN: For details about ArkTS syntax errors”
- 编译报错“ninja: error: mkdir(xxx): No such file or directory”
- 编译报错“(is the command line too long?)”
- 编译报错“CMake Error: The following variables are used in this project, but they are set to NOTFOUND”
- 执行sync过程中修改hvigor及plugin版本导致build init报错
- 更新hvigor版本时，配置了依赖却在build init时报未找到此依赖
- 编译报错 “Unknown resource name”
- 构建报错“ERROR: Task xxx was not found in the project xxx”
- 编译报错“The reason and usedScene attributes are mandatory for user_grant permissions”
- 编译报错“Only one default card can be configured in the form_config.json file”
- 编译报错“In the form_config.json file, if the value of the updateEnabled field is true, the updateDuration and scheduleUpdateTime fields cannot be both empty”
- 编译时DevEco Studio报错App Launch: To run and debug the Harmony device, configure the HarmonyOS runtime
- 编译报错“Property 'XX' does not exist on type 'typeof BuildProfile'”
- 无法调试，DevEco Studio提示“ The target can not be empty. Check the build-profile.json5 file of the project root directory and make sure the targets of the modules in configuration is set to specified product: default in applyToProducts.”
- 编译时DevEco Studio提示Signing material error
- 如何在不修改build-profile.json5的情况下选择构建debug或release版本
- 生成HAR包时，如何删除掉某个so库，不集成到HAR包里
- 如何配置oh-package.json5动态依赖
- 如何解决SDK与镜像不匹配导致abc文件无法正常运行的问题
- 如何解决自定义组件struct内不支持定义成员变量get/set方法的问题
- 应用打包成.app时其中的HAP包没有签名
- 如何给新增的module在线签名
- 如何设置DevEco Studio配置用来调试动态库
- 如何使用手动生成证书打包
- 项目工程中怎样配置Native的版本
- 静态共享包HAR如何引用另一个HAR包中的so文件
- 怎样在编译配置中设置excludes文件
- 如何在编译过程中添加一些自定义的任务
- 如何处理 include <stddef.h> 编译报错
- 如何控制编译过程的cpu使用
- DevEco怎么导出项目的依赖树？
- 使用命令行打包HSP，报错“ACCESS_ERROR, code: 109. Details: Init keystore failed: parseAlgParameters failed: ObjectIdentifier() -- data isn't an object ID (tag = 48) Detail: Please check the message from tools.”
- 如何在hvigor自定义任务中使用npm包
- 如何写har包的编译脚本
- 如何定制构建多目标产物
- 开发的插件能直接在DevEco Studio使用么
- 如何解决编译报错“Property xxx does not exist on type 'typeof BuildProfile'
- 如何进行DevEco Studio编译构建初步性能分析
- 如何解决DevEco Studio编译hsp和闭源har包的时候，生成声明文件时emit的耗时过长导致编译慢的问题
- 如何获取BuildProfile中的值
- BuildProfile文件是否支持在Native侧直接读取
- 如何解决hdc file send指令行为异常
- 如何解决构建流水线提示Couldn't find hvigor/hvigor-wrapper.js的问题
- 如何解决搭建流水线时commandline-tools-linux中sdkmgr下载开发包报错
- DevEco Studio编译报“Operation not permitted”无权限错误
- 编译命令行中如何传递参数并且在Hvigor编译阶段扩展插件中获取到
- 生成签名时报错Delete the material folder in the .p12 file directory and apply automatic signing again.
- 如何通过构建参数传入签名信息
- DevEco Studio日志中如何排除某一特征的日志
- 项目C++代码依赖多种so库，如何在编译打包的时候在HAP包中仅编译指定的so库
- 编译打包CPU架构设置
- 编译报错：platform/OHOS to use this system, please post your config file on discourse.cmake.org so it
- 构建流水线报错：Failed to request the remote SDK
- 如何提高代码混淆率
- HarmonyOS NDK上的llvm是否有更改，一些中间产物能否复用？
- armeabi-v7a是否支持Neon指令扩展
- arm64，armv7，x86_64 三种架构的适用范围
- 如何解决混淆之后的静态引用异常问题
- linux编译release的har包，如何解决产物中将cpp目录完全过滤掉的问题
- 如何在编译打包的时候在hap包中仅编译指定的so库？
- 编译的时候遇到“too many open files”
- 打包体积大如何配置优化包体积问题
- 构建流水线报错“hap-sign-tool:erro :ACCESS_ERROR, code: 109”
- 如何以release编译类型编译HAR包
- 编译通过，但是安装时失败报错“Error while Deploy Hap”
- 如何在构建任务中执行shell脚本
- 编译报错“no such file or directory, realpath 'xxx'”
- 编译过程内存过高
- 编译报错“Duplicated files found in module entry. This may cause unexpected errors at runtime”
- 构建报错"Cannot read properties of undefined(reading 'XXX')"
- 构建报错“Duplicated files found in module xxx. This may cause unexpected errors at runtime”
- 构建报错“input module releaseType is different”
- 构建报错“debug is different”
- 构建报错“proxy data is duplicated”
- 编译报错“Init keystore failed: parseAlgParameters failed: ObjectIdentifier()”
- 编译报错“generate SignerBlock failed”
- 编译报错“java.io.IOException: DerValue.getOID, not an OID 49”
- CPP编译报错"A 'undefined symbol' error has occurred"
- CPP编译报错"A 'unknown type name' error has occurred"
- 编译报错“The path XX is not writable. please choose a new location”
- 编译报错“The useNormalizedOHMUrl settings of packages xxx and the project useNormalizedOHMUrl: xxx do not match”
- 如何解决编译报错“Could not resolve 'xxx' from”，但'xxx'目录存在的问题
- 用户目录下没有npmrc文件
- 如何解决编译报错“ Error: 'icon' value `$media:icons` invalid value.”的问题
- 如何解决编译报错“Error: cJSON_Parse failed, please check the JSON file.”的问题
- 如何解决编译报错“Error: the name 'XXX' can only contain [a-zA-Z0-9_]”的问题
- 如何解决三方包require语句报错
- 如何解决编译报错“Indexed access is not supported for fields(arkts-no-props-by-index)”的问题
- 如何解决编译报错“Declaration merging is not supported(arkts-no-decl-merging)” 或 “Cannot redeclare block-scoped variable 'xxx'”的问题
- 如何解决编译报错“ The inferred type of 'xxx' cannot be named without a reference to 'xxx'. This is likelynot portable. A type annotation is necessary.”的问题
- 如何解决编译报错"arkts-no-any-unknown" 和 "Cannot find module 'xx' or its corresponding type declarations"的问题
- 如何解决编译报错“ERROR: ArkTS Compiler Error ERROR: /bin/sh: "xxxx/es2abc": Operation not permitted”的问题
- 如何解决编译报错“Cannot add xxxx items to index”的问题
- 编译初始化报错“resource busy or locked, open 'xxx\outputs\build-logs\build.log'”
- Mac环境下加载动态库，签名拦截导致未生效
- 文件没有默认导出，但可以默认导入的场景说明
- 编译报错“The service widget file contains one or more references to HSPs”
- 编译报错“The required attribute: module-name is missing”
- 编译报错“The required attribute module-srcPath is missing”
- 编译报错“The srcPath is not a relative path：xxx”
- 编译报错“Method setProperty validate failed in hvigorfile.ts”
- 编译报错“Cannot resolved import statement”
- 编译报错“The type of target device does not match the device type configured by module：xxx”
- 编译报错“UseNormalizedOHMUrl can be true only when Compatible SDK Version is 5.0.0 (12) or later”
- 编译报错“The local dependency below in module %s is invalid”
- 编译报错“There are some dependency names that are inconsistent with the actual package names”
- 编译报错“Local dependency in parameterFile does not exist”
- 编译报错“Invalid form name 'xxx'.”
- 编译报错“File 'string.json' is missing the required property 'string'.”
- 编译报错“Invalid tag 'xxx' at 'xxx/xxx.json5'.”
- 编译报错“The 'tag' keyword is not allowed for 'version' at 'xxx/oh-package.json5'”
- 编译报错“module.json5 file not found.”
- 编译报错“The name of the 'xxx' module must be a string, but received a value of type 'xxx'.”
- 编译报错“The version number of the module must be a string, but received a xxx.”
- 编译报错“This project is in the FA model and does not allow for external dependencies.”
- 编译报错“This project is in the stage model and does not allow for dependencies of modules in the FA model.”
- 编译报错“Cannot depend on HAP modules outside of this project”
- 编译报错“ohpm install failed.”
- 编译报错“Unrecognized archive format in parameterFile”
- 编译报错“The reason and usedScene attributes are mandatory for user_grant permissions.”
- 编译报错“The reason attribute are mandatory for user_grant permissions.”
- 编译报错“CMake task execution failed”
- 编译报错“Duplicate 'routerMap' object names detected.”
- 编译报错“Failed to obtain the module type.”
- 编译报错“The permission under requestPermissions must be a value that is predefined within the SDK or a custom one that you have included under definePermissions.”
- 编译报错“The metadata field in FormExtensionAbility cannot be left blank or as an empty array”
- 编译报错“In FormExtensionAbility, metadata must contain an object with its name set to 'ohos.extension.form' and resource set to a second-level resource reference.”
- 编译报错“byteCodeHar not supported when useNormalizedOHMUrl is not true.”
- 编译报错“Duplicate 'Module-Abilities' object names detected.”
- 如何快速关闭工程中所有字节码HAR配置
- 在.ts文件中使用"import { export } from 'xxx.so';"方式导入.so文件编译告警：Currently module for 'xxx.so' is not verified.
- 构建HSP模块时报错“Ohos BundleTool [Error]: hsp has home ability;Ohos BundleTool [Error]: CompressEntrance::main exit, verify failed.”
- 编译报错"Error: open 'xxx\libimage_transcoder_shared.dll' failed"
- 推包调试报错“Error message:cannot find record '&XXX/src/main/ets/YYY&x.y.z', please check the request path.'ZZZ.abc'.”
- 编译报错“ReferenceError, TransformStream is not defined in hvigorfile: XXX”
- 编译报错“Cannot read properties of undefined (reading 'split')”

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-1
爬取时间: 2025-05-08 07:22:36
来源: Huawei Developer


问题现象


编译构建时，出现报错“JS heap out of memory“。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161136.80852291641322563441423682925112:50001231000000:2800:04AB91FC363ED1A8F5177DCC8982CC0831E3833F9DEB94BD643071A65F45B834.png)

解决措施


出现该报错的原因是hvigor运行时内存不足，在使用3.1.0及以上版本的hvigor时，可通过以下方式修改hvigor运行时内存的最大值。


勾选Enable the Daemon for tasks：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161136.74167720721737439135630323246949:50001231000000:2800:19C63B6A4DC9B493F71486E2C2A84F08B7CE49529BE1B6135F6E0948D53994E7.png)

在hvigor-config.json5中修改maxOldSpaceSize字段，根据工程的大小，适当将其增大（如设置为8192）：


```less
"nodeOptions": {
  "maxOldSpaceSize": 8192
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-2
爬取时间: 2025-05-08 07:22:45
来源: Huawei Developer


问题现象


在Linux环境下，系统内存有64G，Hvigorw脚本中配置--max-old-space-size=40960，在编译构建时，实际在使用内存未达到配置的内存（例如使用到20G左右）就出现报错“JS heap out of memory“。


```less
FATAL ERROR: NewSpace::Rebalance Allocation failed - JavaScript heap out of memory
Writing Node.js report to file: report.20200512.172528.47517.24.011.json
Node.js report completed
1: 0xa295e0 node::Abort() [node]
2: 0x9782df node::FatalError(char const*, char const*) [node]
3: 0xb99c2e v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [node]
4: 0xb99fa7 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [node]
5: 0xd3a3b5 [node]
6: 0xd74f27 [node]
7: 0xd84707 v8::internal::MarkCompactCollector::CollectGarbage() [node]
8: 0xd481b9 v8::internal::Heap::MarkCompact() [node]
9: 0xd48f0b v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [node]
10: 0xd499a5 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [node]
11: 0xd4aebf v8::internal::Heap::HandleGCRequest() [node]
12: 0xcf5f97 v8::internal::StackGuard::HandleInterrupts() [node]
13: 0x104b803 v8::internal::Runtime_StackGuard(int, unsigned long*, v8::internal::Isolate*) [node]
14: 0x13a5a99 [node]
Aborted (core dumped)
```


问题原因


vm.max_map_count是一个与内核虚拟内存子系统相关的参数，用于控制进程可以拥有的内存映射区域的最大数量。它通常用于限制一个进程可以打开的文件数量，特别是在使用大量内存映射文件的情况下。


在Linux系统上，vm.max_map_count参数的默认值通常是较小的数值，例如65530。然而，对于一些需要大量内存映射的应用程序或者特定的使用场景，可能需要增加该参数的值，以便支持更多的内存映射区域。


解决措施


修改vm.max_map_count的值：


```less
sysctl -w vm.max_map_count=新值
```

-  保存文件后，使用以下命令使更改生效：

```less
vm.max_map_count=新值
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-3
爬取时间: 2025-05-08 07:22:55
来源: Huawei Developer


问题现象


在升级DevEco Studio至3.1 Beta2版本后，原有的API 9的Stage工程编译告警，提示“please use 'export type'.”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161136.75896318678806771737928778144364:50001231000000:2800:45CF0B52C70EEC4AE2ACFD598BCB49B2FFC1244C0DAD5BA58E4D003CF6B5BE86.png)

解决措施


DevEco Studio 3.1 Beta2版本默认开启模块化编译，若开发时在应用里存在如下re-export语法，将出现告警。


```less
  // index.ets
  import {test} from "./test"
  export {test}
  let b : test = {a : 'index'}


  // test.ets
  export interface test {
    a: string
  }
  let obj : test = {a : 'string'}
```


出现该问题的原因是ets/ts模块声明的类型符号在转换后的js模块中会被消除。经过工具链编译后，转化成js文件如下所示，引用模块的import语句本身及引用的类型符号并不会被消除，导致运行期找不到import的类型符号。


```less
  // index.js
  import {test} from "./test"
  export {test}
  let b = {a :'index'}


  // test.js
  let obj
```


如编译构建期提示上述告警信息，请根据提示信息进行如下修改，通过添加type显式声明类型符号的引用，从而使编译转换后js模块能够将类型符号的引用消除


```less
  // index.ets
  import type {test} from "./test"  //此处增加type声明
  export {test}
  let b : test = {a : 'index'}


  // test.ets
  export interface test {
    a: string
  }
  let obj : test = {a : 'string'}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-4
爬取时间: 2025-05-08 07:23:04
来源: Huawei Developer

-  问题现象 Stage模板工程编译引用native文件(.so) 提示 "Cannot find module XXX or its corresponding type declarations."。 解决措施 当前Stage工程在编译构建阶段新增对native文件(.so)导出符号的语法校验，如果引用了没有对应声明文件(.d.ts)的native文件(.so)的现有工程在编译构建阶段，语法校验工具便会报错提示找不到对应的声明文件。 如果出现类似问题，可尝试通过如下方式进行解决：
- 
- 
1. 
2. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161136.85041538731190844860001352355803:50001231000000:2800:683B6AED1D7EA4FFEF75D50DEFB231B6921F61636A40C10AB5202348B73C720B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161136.64476187102130982666775157397245:50001231000000:2800:32E511304BEF40C1E41C1FF4EA4822E9B391CAF8F00DAA297133E6A844D52ED6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161136.69409458909120050143579181815564:50001231000000:2800:4B78883630ED392F41E3700E8EB5930832937581262D2757CB4EFCE3FDAA8620.png)
-  问题现象 API 11 Stage模型工程编译失败，提示“Cannot find module '@kit.xxx' or its corresponding type declarations”。 问题原因 出现该问题的原因是使用DevEco Studio NEXT Developer Preview1及之后版本，新创建的API 11 Stage模型的模板文件里面使用的import方式，全部改为了import xxx from '@kit.xxx'的方式，若SDK使用的是HarmonyOS NEXT Developer Preview1之前的版本，将会出现编译报错，因为旧的SDK不支持此类方式导入。 解决措施 如果出现类似问题，需要对SDK进行升级或升级DevEco Studio。
- 如果使用的是DevEco Studio NEXT Developer Preview1至HarmonyOS NEXT Developer Beta1（5.0.3.300）之间的版本，在菜单栏点击Tool > SDK Manager，将SDK升级至HarmonyOS NEXT Developer Preview1及以上版本后，重新进行编译。
- 如果使用的是HarmonyOS NEXT Developer Beta1（5.0.3.300）及以上的版本，SDK随DevEco Studio软件包安装，无需单独下载，请在下载中心下载并使用新版本DevEco Studio。
-  问题现象 引用三方包，构建失败，提示“Cannot find module 'xxx' or its corresponding type declarations”。 解决措施 进入对应模块级oh-package.json5文件或工程级oh-package.json5文件中查看三方包是否已安装，若未安装，需执行ohpm install安装；若已安装，需查看“main”字段是否配置正确，若未配置或配置错误，需配置为正确的入口文件。
-  问题现象 引用的包路径被混淆，代码中又是在引用包后面拼接了路径，导致模块引用不到而报错。 例如： 代码中这样引用 这样引用会找不到模块，导致报错。 解决措施 修改引用方式，改为推荐的引用方式。
-  问题现象 被引用模块oh_package.json5配置有误，执行了ohpm install 并且成功地安装了依赖，但是还报错模块找不到。 被引用模块的 oh_package.json5 中配置了错误的types字段。 该字段优先于main字段。 如果 types 字段配置的不存在，就会报错模块找不到。 解决措施 如果该包中没有d.ets声明，则这个字段可以删除。配置不存在或者错误，会导致报错。
-  问题现象 oh_package.json5中dependencies中引入模块的名称和实际使用时import的不一致。 例如在oh_package.json5 中这样引入： 但是实际上在代码中import的时候是大写 HAR或者其他而不是dependencies里面配置的‘har’的值，要注意保持完全一致。（目前windows 没有问题，linux会报错模块找不到） 解决措施 引入和使用改成一致。

```less
"dependencies": {   "har": "file:../har" }
```

-  问题现象 引用模块的oh_package.json5中main字段值和实际的文件名称大小写不一致。 解决措施 将main字段和实际文件名称的大小写改为一致。
-  问题现象 Stage模板工程编译构建失败，提示 "Cannot find module '@bundle:rollup_plugin_ignore_empty_module_placeholder' or its corresponding type declarations"。 解决措施 该问题是由于工程引用了无对应实现文件的.d.ts声明文件： 在输入栏中输入rollup_plugin_ignore_empty_module_placeholder，找到问题模块的中间文件。

```typescript
export type {T} from './type';
```

-  在输入栏中输入rollup_plugin_ignore_empty_module_placeholder，找到问题模块的中间文件。
- 

```typescript
export type {T} from './type';
```

- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161136.59910007804311289597155618359609:50001231000000:2800:347A78BE2B8D65040BD1406D903669B268E66CEB41FE48DB9973C2B0067A1710.png)
- 如果使用的是DevEco Studio NEXT Developer Preview1至HarmonyOS NEXT Developer Beta1（5.0.3.300）之间的版本，在菜单栏点击Tool > SDK Manager，将SDK升级至HarmonyOS NEXT Developer Preview1及以上版本后，重新进行编译。
- 如果使用的是HarmonyOS NEXT Developer Beta1（5.0.3.300）及以上的版本，SDK随DevEco Studio软件包安装，无需单独下载，请在下载中心下载并使用新版本DevEco Studio。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161136.06177097823145580582857133748433:50001231000000:2800:C9AAAA4E5E87B746A6681AA8310A394D7DD9F74A515691638801E87C66DE340C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161136.10205528675445274599331886193760:50001231000000:2800:15A82A3F39A5B990A7032F3404B81C647CF153C862B7F74EBDCE599A81F51A81.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161136.52770213059541969362084327863227:50001231000000:2800:C968DD0275BEF8B6F249071308510CE6396B35B7F8CC5B651175504A5FAD424C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161136.69599416294822815173470567997153:50001231000000:2800:F0C6966F9ADA114D80899822FB16DFA966360C38A20C6F29AD84EC4004AB2816.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.32100524537412860652780204655831:50001231000000:2800:58561CCE9CB21F819FAD22DE9EB108546D46CBA784E37273323B8F0CAB8456C1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.09641572024026072102587714684247:50001231000000:2800:3054326B959A666E650C586E30D4E6DCCB40E942254F808DDCAB3B115E801494.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.83701515582738418872791824061652:50001231000000:2800:AE128B9580795A27C1C6F29C9AB02864EF98F86BBC5A954AEC2650B051D14A38.png)
1.  在输入栏中输入rollup_plugin_ignore_empty_module_placeholder，找到问题模块的中间文件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.30035468199464483627335341023217:50001231000000:2800:F3DAB22E2BF897615294BABC736D5D8FE55B0943F2157A1AB3544112EF0E896A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.46250053586776003395566650623109:50001231000000:2800:0F63CA9E919BCA01258FA61FE25DDE0A42202063DF5C1713DB676DF08EF51CB5.png)
1. 

```typescript
export type {T} from './type';
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.13305496616027020913023358484265:50001231000000:2800:0C8C8A867FE78452DBCF2295B5BE0BA74B622864F930D300460B23403C28B159.png)
1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.93032799728662421593626909291348:50001231000000:2800:A26F75016552A8049FD07EDA6AE793DAA01F2F8334485664ED919170B32A66EF.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-5
爬取时间: 2025-05-08 07:23:14
来源: Huawei Developer


问题现象


在构建依赖HSP的HAP模块时，提示“ERROR: Failed :entry:default@CompileResource”，提示某资源文件不存在，但该资源文件实际存在于HSP内。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.15935291796386163828849939479727:50001231000000:2800:44CB5568401CC4924B33C5EED1FF8A0ACB31DC1FAA3398DDE24A4741A9F36673.png)

问题原因


出现该问题的原因是在HSP的module.json5中声明申请权限等场景中使用了自身的资源文件，该部分内容被合并到了引用方的HAP中。而HSP的资源仅能在HSP本身里使用，无法直接被HAP使用。


解决措施

- 在各引用的HSP的module.json5中搜索对应资源，确定引入该资源的来源；
- 可以在引用方HAP内或appScope里添加对应资源规避；
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.88609680302571039901149481933374:50001231000000:2800:E74C7F23584AC4C1204ED70F755E723CBC3A8003FD8E38E5FE1CE678CFCD789F.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-6
爬取时间: 2025-05-08 07:23:24
来源: Huawei Developer


问题现象


Stage模板工程编译构建失败，提示 "Module 'xxx' has no exported member 'yyy'" 并且"yyy"符号是由export * from 'x.js'语法从js文件中导出。


解决措施


当前Stage工程编译构建期的语法校验工具对js文件不作检查，因此当使用export * from 'x.js'导出js文件中的符号时，符号引用处便会提示"Module 'xxx' has no exported member 'yyy'"的错误信息。


如果出现类似问题，可尝试通过如下方式进行解决：


```less
export { yyy } from 'x.js'
```

- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.12911518523271346506204192745616:50001231000000:2800:2D1D085C8FE885540A6A14E6284E76956D0C1887A199D95D8CEB6CDD72E736FB.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-8
爬取时间: 2025-05-08 07:23:33
来源: Huawei Developer


问题现象


Stage模板工程编译构建失败，提示 "ERROR: Could not load ${file1} (imported by ${file2}): Maximum call stack size exceeded"。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.72431041381558830809099132526695:50001231000000:2800:4BFDFC035EA8B6B609C093C98FB7D09385DB92ECFCA9A063A24460071FACD104.png)

解决措施


该问题是由于file1为当前工程外的代码：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.15812606235719144018657851912555:50001231000000:2800:490549512761988EBB297BFF8FEADCBA01D88158AAEA0440EBD1F63BBBB61AF8.png)

请新建Static Library模块，并将工程外的代码迁移至Static Library模块内，并使用HAP引用HAR方式进行模块间引用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-10
爬取时间: 2025-05-08 07:23:43
来源: Huawei Developer

-  问题现象 如果工程在本地可编译成功，压缩后拷贝到其他环境中再打开该工程编译构建失败，提示 "ERROR:  ArkTS:ERROR Failed to get a resolved OhmUrl by filepath xx"。 解决措施 该问题可能是由于工程中存在oh_modules目录，因为oh_modules中存在软链接，经过压缩后软链接会失效，导致在其他环境中再打开该项目，编译时无法找到对应的文件。 请删除工程中的oh_modules后，执行File > Sync and Refresh Project。
-  问题现象 三方包在配置依赖时，配置到devDependencies，源码中又有引用依赖中的API时，编译失败。如以下示例：三方包@hms-security/ucs-appauth将依赖@network/gr配置在devDependencies中，源码中使用了@network/gr的API时，编译失败，提示“ERROR: ArkTS:ERROR Failed to get a resolved OhmUrl by filepath xxx”。 解决措施
- 
- 
- 向此包开发团队提改进建议：运行时的依赖，不能配置在devDependencies中。
- 可在依赖上层引入对应devDependencies中的三方包规避此问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.88248643701478517825514193386411:50001231000000:2800:120695A244ACD12CBCA299D7FFE55D27A2EBF6B4ED888AA9619F7106338D300D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161137.87897957507146552692750844803273:50001231000000:2800:E46A2E57DFB3CB24DA5601B0C625662A941203CFB44BD3A03061580C762E9AE2.png)
1. 
2. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161138.31870305051625844143295789067162:50001231000000:2800:EE75D531976B0FA14C2A19E894C2A209BD8221006490AF48085E15037897963B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161138.51212524383884105028675357894706:50001231000000:2800:4FE877FE074CA82AC67E1E80D10B40DB7A5D2CA3E8595D8EB40639D03C9639ED.png)
- 向此包开发团队提改进建议：运行时的依赖，不能配置在devDependencies中。
- 可在依赖上层引入对应devDependencies中的三方包规避此问题。
-  问题现象 DevEco Studio编译失败，提示“ERROR: ArkTS:ERROR Failed to get a resolved OhmUrl by filepath xxx”。 问题确认 查看工程目录下的build-profile.json5文件中modules字段配置的srcPath路径是否与真实路径不相同，是否存在大小写不一致问题。 解决措施 将工程目录下的build-profile.json5文件中modules字段配置的srcPath路径与真实路径保持一致。
-  问题现象 工程A以相对路径引用了工程B的模块，这种引用会导致报错。 处理措施
- 把工程B这种的har转至工程A里，作为A的一个模块引用。
- 把工程B的har提前打包，在A中 以.har的方式引用。
- 上传到仓库，以版本号的方式引用。
-  问题现象 DevEco Studio编译失败，提示“Error Message: Failed to get a resolved OhmUrl for 'hvigor_ignore_xxxxx' imported by xxx”。 处理措施 如果hvigor_ignore_xxxxx所在的模块是一个har模块，需要排查oh_package.json5中是否存在"packageType": "InterfaceHar"，如果存在，请删除"packageType": "InterfaceHar"。 如果hvigor_ignore_xxxxx所在的模块是一个hsp模块，需要排查${模块路径}\build\default\cache\default\default@CompileArkTS\esmodule\${debug/release}\filesInfo.txt文件中是否存在hvigor_ignore_xxxxx路径，如果存在，可将hvigor_ignore_xxxxx路径所在的模块或包添加到当前编译模块oh_package.json5的dependencies中临时规避。
-  问题现象 DevEco Studio编译失败，提示“Failed to get a resolved OhmUrl for 'xxx' imported by 'yyy'”。 问题确认 处理措施

```less
"buildOption": { 
  "arkOptions": { 
    "byteCodeHar": false
  }
}
```

- 排查yyy所在模块是否为字节码har，查看工程级build-profile.json5的useNormalizedOHMUrl是否为true（缺省默认值为false），如果为true则默认构建字节码har。
- 如果yyy所在模块是字节码har，请排查xxx依赖是否被配置在工程级oh_package.json5的dependencies，但没有配置在yyy模块级oh_package.json5的dependencies中。
- 

```less
"buildOption": { 
  "arkOptions": { 
    "byteCodeHar": false
  }
}
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161138.26265244311829305296373823491419:50001231000000:2800:0CEB12F91921C515209FBD33CA25AC1FDEF8571AEF7E3AB26EAA28258FF3CD1B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161138.61262982029504266097088165252873:50001231000000:2800:D72E217D606B17314E86A85919F9A4B67B73DE0E187A90CF06DF26F85DA15F38.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161138.60302992466413706088042218005275:50001231000000:2800:6AFEA19E2769C25C95AB44A86AA591EF44B9EF0B1FB65ED1BCF649F65E7BA820.png)
- 把工程B这种的har转至工程A里，作为A的一个模块引用。
- 把工程B的har提前打包，在A中 以.har的方式引用。
- 上传到仓库，以版本号的方式引用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161138.75023991604163368826532024668951:50001231000000:2800:827F799D6D810219B3EF6E553F469C719B1D715E25845715D986D66D42E4B8B7.png)
- 

```less
"buildOption": { 
  "arkOptions": { 
    "byteCodeHar": false
  }
}
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161138.27879492167672686765865718982776:50001231000000:2800:2635EC4BCFF47E8E39FA77CD8E0583C3118DC292F9E0EB8B6F7DDF6B54623EEB.png)
-  请确认当前使用的DevEco Studio和SDK版本是配套的，点击菜单栏Help > About DevEco Studio，Help > About HarmonyOS SDK分别查看DevEco Studio和SDK版本，版本配套关系请参考版本概览。
-  问题现象： DevEco Studio编译失败，提示“ERROR:  ArkTS:ERROR failed to execute es2abc ERROR:  ArkTS:ERROR Failed to get a resolved OhmUrl by filepath xxx”。 处理措施 该问题是由于在工程中引用了非工程标准模块目录（即目录内无模块描述文件module.json5），如下图utils目录所示： 请新建Static Library模块，并将utils/common里面的代码迁移至Static Library模块内，并使用HAP引用HAR方式进行模块间引用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161138.87497077866955037134131244055961:50001231000000:2800:2FF78BF06A381C641CD32D8B32A17F41A3B557E649F5C890C70E66ACBB4A6CFD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161138.67724038661375793250395946917879:50001231000000:2800:91416EA9981383B3CE582898853CBC4A79D96DA87D19204D4209FC3E5030C0FC.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-11
爬取时间: 2025-05-08 07:23:53
来源: Huawei Developer


问题现象1


使用了自定义参数BuildProfile，编译态无异常但编译构建失败，提示“Property xxx does not exist on type 'typeof BuildProfile'.”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161138.24897201215267921952668632623187:50001231000000:2800:CB926A670AFC4F3B418D5496543B128C438BFB5BC3232C9C02926079CD76AD4F.png)

解决措施


检查在当前模块下build-profile.json5中的targets > buildProfileFields配置的自定义参数中key值是否相同，如果不同请将targets内所有buildProfileFields中的key值保持相同。


以下为导致编译报错的错误配置示例：


```less
"targets": [
  {
    "name": "default",
    "config": {
      "buildOption": {
        "arkOptions": {
          "buildProfileFields": {
            "targetName": "default"
          }
        }
      }
    }
  },
  {
    "name": "default1",
    "config": {
      "buildOption": {
        "arkOptions": {
          "buildProfileFields": {
            "targetName1": "default1"
          }
        }
      }
    }
  },
]
```


请将targets内所有buildProfileFields中的key值修改一致，如以下示例：


```less
"targets": [
  {
    "name": "default",
    "config": {
      "buildOption": {
        "arkOptions": {
          "buildProfileFields": {
            "targetName": "default"
          }
        }
      }
    }
  },
  {
    "name": "default1",
    "config": {
      "buildOption": {
        "arkOptions": {
          "buildProfileFields": {
            "targetName": "default1"
          }
        }
      }
    }
  },
]
```


问题现象2


使用了自定义参数BuildProfile并且编译器标红且构建失败，提示“Property xxx does not exist on type 'typeof BuildProfile'.”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161138.05017745479025444405010251279958:50001231000000:2800:F2C9DCCFEA11C35B19AF90EA9CC15A6DABCE4199F32A39E814A6CAF9AFDED325.png)

解决措施


请检查当前模块下build-profile.json5中buildProfileFields内是否添加了所使用的自定义参数，请确保该自定义参数已配置在buildProfileFields内。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-12
爬取时间: 2025-05-08 07:24:03
来源: Huawei Developer


问题现象


在执行代码规模较大的C++工程的编译时，由于C++编译时的CPU占用率较高，可能出现电脑卡顿、反应迟缓等现象。


解决措施


如果出现类似问题，可尝试通过如下方式进行解决：


```less
"arguments": "-DCMAKE_JOB_POOL_COMPILE:STRING=compile -DCMAKE_JOB_POOL_LINK:STRING=link -DCMAKE_JOB_POOLS:STRING=compile=2;link=2",
```


需要说明的是，修改了compile和link的值，可能会导致编译时长增加，请耐心等待。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-14
爬取时间: 2025-05-08 07:24:12
来源: Huawei Developer


问题现象


通过命令行方式构建HarmonyOS应用或元服务过程中出现构建失败，现象如下图所示。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161138.94026414178059194789808206580467:50001231000000:2800:2467A7D428629071A417A5CB6B91701F0A7A6AE11EC96BD2A9AA829CD33626F1.png)

解决措施


该问题是由于JDK版本不匹配导致，当前配套的版本为JDK 17。因此，请根据如下方法进行修正：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-15
爬取时间: 2025-05-08 07:24:22
来源: Huawei Developer


问题现象


在工程同步、编译构建过程中，提示LABEL_VALUE_ERROR错误信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161138.91401995025222582465912108143125:50001231000000:2800:711BCD2B75B0491F784F7DA62500FDAF4AAFB464FB836591ADB8785749281CD1.png)

解决措施


该问题是由于config.json文件的资源引用规则变更导致，需要将“label”字段的取值，修改为资源引用方式。

1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161139.79943373911094831344603252989858:50001231000000:2800:1C52236ACB3B2953CB72BC84F6E808D5E14230490878BDED9309FF40A8517E29.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-16
爬取时间: 2025-05-08 07:24:31
来源: Huawei Developer


问题现象


在工程同步或者编译构建时出现错误，提示“Schema validate failed”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161139.62890235670900611255680529164818:50001231000000:2800:D237FEE97320247CC1EB8DE300D0E80AA61560CBE697ED9F0668E56F2C78C6FD.png)

解决措施


在开发应用/服务时，可以设置应用/服务的启动界面的图标及背景颜色，创建工程后自动设置了默认的启动界面信息，但若开发者误删其中某个字段后将导致报错。下面以重新设置启动界面信息为例，开发者可自定义启动界面的图标及背景颜色。


在开发应用/服务时，为了提升应用/服务冷启动的性能，您可以通过如下方式设置应用/服务的启动界面的图标及背景颜色。

1. 
2.  创建完成后，color.json文件如下图所示：
3. 
4. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161139.27266466127225028912434566284550:50001231000000:2800:3889ED4F527AE21893AFF2A4CCD258991F1C7DC889324B8D5EF45BDDDDEBBC47.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161139.67035392205044604041212494748211:50001231000000:2800:398D117F8286CFC70FCF99708D7DCBD4EB46918945F1A724F03D5CDA8D60EB6E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161139.65903294648679639513261593382133:50001231000000:2800:74F9062968C514C3A70FAEF642F1AADDF61686C393489F749FA663FDB628D02B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161139.92266861907406530556660249700717:50001231000000:2800:CCBBD2EB74DE2F87A41B3880F62A14560D97A90F6341C130C091769C797AB571.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161139.45920592481165499303949006746626:50001231000000:2800:F0235DEAEFA93FFC5353F23C3EA09720714871C08D08771C100A23987CA22953.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-17
爬取时间: 2025-05-08 07:24:41
来源: Huawei Developer


问题现象


DevEco Studio编译时出现错误，提示“Schema validate failed”错误信息。


解决措施


出现该问题的原因是配置文件中字段缺失或拼写错误，可根据报错的详细信息进行问题定位。


如将module.json5文件中abilities标签中的“name”错写为“nam”，报错信息如下：


```less
     Detail: Please check the following fields.
{
  instancePath: 'module.abilities[0]',
  keyword: 'required',
  params: { missingProperty: 'name' },
  message: "must have required property 'name'",
  location: 'D:/MyApplication/entry/src/main/module.json5:15:8'
} 
{
  instancePath: 'module.abilities[0]',
  keyword: 'required',
  params: { missingProperty: 'srcEntrance' },
  message: "must have required property 'srcEntrance'",
  location: 'D:/MyApplication/entry/src/main/module.json5:15:8'
} 
{
  instancePath: 'module.abilities[0]',
  keyword: 'required',
  params: { missingProperty: 'name' },
  message: "must have required property 'name'",
  location: 'D:/MyApplication/entry/src/main/module.json5:15:8'
} 
{
  instancePath: 'module.abilities[0]',
  keyword: 'oneOf',
  params: { passingSchemas: null },
  message: 'must match exactly one schema in oneOf',
  location: 'D:/MyApplication/entry/src/main/module.json5:15:8'
} 
{
  instancePath: 'module.abilities[0]',
  keyword: 'enum',
  params: {
    allowedValues: [
      'priority',
      'name',
      'srcEntrance',
      'srcEntry',
      'launchType',
      'description',
      'icon',
      'label',
      'permissions',
      'metadata',
      'visible',
      'exported',
      'skills',
      'backgroundModes',
      'continuable',
      'startWindowIcon',
      'startWindowBackground',
      'removeMissionAfterTerminate',
      'orientation',
      'supportWindowMode',
      'maxWindowRatio',
      'minWindowRatio',
      'maxWindowWidth',
      'minWindowWidth',
      'maxWindowHeight',
      'minWindowHeight',
      'excludeFromMissions'
    ]
  },
  message: 'must be equal to one of the allowed values',
  location: 'D:/MyApplication/entry/src/main/module.json5:15:8'
} 
{
  instancePath: 'module.abilities[0]',
  keyword: 'propertyNames',
  params: { propertyName: 'nam' },
  message: 'property name must be valid',
  location: 'D:/MyApplication/entry/src/main/module.json5:15:8'
} 
```


以上述报错为例，说明报错中关键词的含义，便于开发者理解报错信息，完成问题定位及修改。

- instancePath：错误所在的文件位置。'module.abilities[0]'表示在module.json5文件中的第一个abilities。
- 
- required：表示该字段为必选配置项。由于缺失或拼写错误导致该属性未配置。
- 
- enum：该标签内所有可配置的属性。开发者可根据枚举值确认属性的正确写法。
- propertyNames：如果字段拼写错误将出现propertyNames，propertyName: 'nam'指明“nam”为错误属性。
- params：不同keyword对应不同的详细说明，如keyword为'required'时，params的missingProperty: 'name' 表示缺失的属性为“name”。
- message：修改要求的说明，如keyword为'required'时，message表示必须配置name属性。
- location：错误的具体位置，点击可以跳转。
- required：表示该字段为必选配置项。由于缺失或拼写错误导致该属性未配置。
- 
- enum：该标签内所有可配置的属性。开发者可根据枚举值确认属性的正确写法。
- propertyNames：如果字段拼写错误将出现propertyNames，propertyName: 'nam'指明“nam”为错误属性。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161139.99530573099045572987927601458891:50001231000000:2800:F7DB28F62420A64068EAF4466DEB0014EB86DB9FF61D2D6081F8BC03B53FF5C2.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-18
爬取时间: 2025-05-08 07:24:52
来源: Huawei Developer


问题现象


DevEco Studio编译时出现错误，提示“No available entry module found”错误信息。


解决措施


feature模块中需要配置依赖的entry模块，DevEco Studio在编译时会校验feature模块所依赖的entry模块是否存在，出现该问题的原因可能为以下情况：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-19
爬取时间: 2025-05-08 07:25:00
来源: Huawei Developer


问题现象


DevEco Studio编译时出现错误，提示“ERROR - hap-sign-tool: error: ACCESS_ERROR, code: 109. Details: Init keystore failed: keystore password was incorrect”错误信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161139.56157143947514564895839703936079:50001231000000:2800:BE9FD2740D924F524ED96F6086DD74AB51AEDF5E3F9C1F4749DDBEEF7166FE79.png)

报错原因


密钥库(p12)密码错误。


密钥库密码和密钥密码是在创建p12文件时由开发者自行输入的，请牢记该密码。DevEco Studio工程的build-profile.json5文件中有记录密码的密文，但签名工具需要输入密码明文，不能直接将build-profile.json5中的值用到签名工具中。


常见场景


解决措施


出现该问题的原因是签名文件中签名密码错误。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161139.77675678520117720745763322007363:50001231000000:2800:8DE9C8DAC8366DB1433840D88F9E8DC5DD6890E0E50A14E4CEED0D6A589725DD.png)

开发者可通过重新自动签名解决该问题：


1. 点击File > Project Structure > Project > Signing Configs，打开签名配置页面。


2. 勾选“Automatically generate signing”（如果是HarmonyOS工程，需同时勾选“Support HarmonyOS”），等待重新签名，然后点击OK即可。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161139.25290915304916349001405483870512:50001231000000:2800:E9679E6A7D41B523DB12E4FB106237BE2F1DE32454C0AB828A5ADFDFA3D45B5D.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-20
爬取时间: 2025-05-08 07:25:09
来源: Huawei Developer


问题现象


DevEco Studio编译时出现错误，出现如下提示之一：

- 
- 
- 
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161139.42890813401846121106605174921857:50001231000000:2800:7F26BB52EAEE53E90ABE058D789A14DF70203A8E7A295BD4E9F95888754A6067.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161139.20255385001172802427495058599194:50001231000000:2800:D7491B6176A3549AD58CBD65B6E2F63D101801F8EA42F15138AC678E1C7B6F59.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161140.75246576885907691085580833345626:50001231000000:2800:CCC12361B168666EF3AEE4168E047E397CDC34CABF873BDB1CE929F44455AF98.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161140.57384836765857257944112212130226:50001231000000:2800:C5F72E97DAB6E265824BD46D9BB7D8582DE12DED90825F7AC681F03460442D9A.png)

解决措施

- 可能是打包时工程未满足HAP唯一性校验逻辑，请根据HAP唯一性校验逻辑修改工程，满足校验逻辑即可正常打包。
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161140.47231533064602590288820701348676:50001231000000:2800:65421A41EABAFFD8A3F5DB9BE3D524D6C1EF32468D6B201C93A95BFD5165A5E0.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-21
爬取时间: 2025-05-08 07:25:19
来源: Huawei Developer


问题现象


执行多模块native模块构建时，提示“Failed to generate test project build system.”错误信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161140.78223205276688995174055807376214:50001231000000:2800:84DFEF712F69DE102AACEB7594B2EEB8BC27F4EB806D89F51F2E2442A01219CA.png)

解决措施


请删除报错模块下的.cxx文件夹，然后选中需要构建的模块，执行Make Module${moduleName}完成单独构建，避免同时构建多个模块。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161140.77040546341018636742460606390259:50001231000000:2800:FA4149E96D592C57176E641F4F8EF7EA476D1612098F43AD738F1C7AD2FA9B7F.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-22
爬取时间: 2025-05-08 07:25:29
来源: Huawei Developer


问题现象


C/C++项目依赖三方so时，在打包生成HAP后，发现三方so未打包到HAP中。


解决措施


当前DevEco Studio对C/C++项目三方so的寻址方式有限，如出现三方so未打包到HAP中，请尝试修改so引入方式。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161140.91995932397090828753533668650657:50001231000000:2800:81A3D21C236D6DCE1D37A210C907154435B3797467AE6120290C45E6D6840B0F.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-23
爬取时间: 2025-05-08 07:25:38
来源: Huawei Developer


问题现象


点击Build > Make Module ${libraryName}编译构建生成HAR后，发现构建产物中未出现cpp目录下的文件。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161140.94468707651672091608658904538982:50001231000000:2800:319F3DCF858B530DDF4AD3959B82EEACA6B4A9B00B941F2BCBF085B3C16E633A.png)

解决措施


如果使用的Hvigor为2.5.0-s及以上版本，在编译构建HAR的过程中，只会将dependencies内处于本模块路径下的本地依赖也打包进.har文件中，devDependencies里的依赖不会打包进.har文件中。


请将相应的本地依赖移至dependencies中后重新编译。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161140.57308728785289535040426908559420:50001231000000:2800:53A0D4E0AEAAC207E7DCB1AB4F4796C6951B8C470B8E184D37BEE16E54013F6C.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-28
爬取时间: 2025-05-08 07:25:49
来源: Huawei Developer


问题现象


使用DevEco Studio 4.0.0.700及以上版本打开ArkUI-X历史工程，工程同步（Sync）或执行构建时，提示“ERROR: The ArkUI-X project's structure has been changed. Migrate and adapt the project as instructed in FAQs.”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161140.15448581485039917056256549654842:50001231000000:2800:015E00666099B1896CCCBDAA686EA471DAF2D43F91D6163C2ACA6982E4D588F2.png)

解决措施


出现该提示的原因是在旧版本的ArkUI-X工程模板中，ArkUI-X工程标识（"crossplatform": true）配置在工程目录下build-profile.json5中，在DevEco Studio 4.0.0.700及以上版本需要在工程目录下.arkui-x/arkui-x-config.json5文件中配置ArkUI-X工程模块、工程标识等信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161140.46374214065547612431967471964723:50001231000000:2800:438625FC4827F11B1A881BED9E15571ECDC48FCE0D48D5118B954F5F4F28E734.png)

由于配置位置变更，对于使用历史工程模板的用户，如果使用DevEco Studio 4.0.0.700及以上版本，需要手工进行迁移适配新的工程结构。迁移步骤如下：

1.  工程迁移后结构如下：

```less
{
  "crossplatform": true,     // 跨平台工程标识
  "modules": [               // 跨平台模块配置
    "entry"
  ]
}
```

2. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161140.56230319801333655911358841046871:50001231000000:2800:DA6A4D799E4C7CA4473BADE89308147E1AE6334E6CF31FEEBA0295A9164F2860.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161140.44140203093129444488080494587011:50001231000000:2800:74C8589E4DBD1C029CA3F1BA03E7745FB6E1CE5C274837140B82E1A9A19253B3.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-29
爬取时间: 2025-05-08 07:25:58
来源: Huawei Developer


问题现象


Target AOT编译ap文件生成失败，并报错提示“errno: 13”，如下图所示。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161140.65545985398666509113110276511013:50001231000000:2800:B981257F4E6609E291431043886F2F56BB1ABC4D20A5FF557E77F0EBE8885781.png)

解决措施


errno: 13表示权限不足，请通过下述措施解决：


```less
hdc shell
setenforce 0
```


以上设置重启将会失效，若设备重启请重新进行以上设置


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-30
爬取时间: 2025-05-08 07:26:08
来源: Huawei Developer


问题现象


工程构建时，提示“ArkTS:WARN: For details about ArkTS syntax errors, see FAQs”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161141.84037201652669867035942780266495:50001231000000:2800:42AEE204CC7422701BCBD980CDE6774B1B76556B37DCC9D79AC5D46F4FA46E6E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161141.45933418414508392777554287382460:50001231000000:2800:D187BF9C026AE2EC998E281C31EFDE2E2981531BB58CE6A14A6DC7E6138405E6.png)

解决措施


出现该告警说明当前工程存在不符合ArkTS语法规范的写法，请根据ERROR报错中的报错信息进行修改，或根据提示的语法规则(如arkts-no-var、arkts-sendable-decorator-limited等)，在本网站搜索对应的说明，修改为ArkTS规范写法。ArkTS语言相关介绍请查看ArkTS（方舟编程语言）


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-31
爬取时间: 2025-05-08 07:26:18
来源: Huawei Developer


问题现象


Native工程编译报错，同时出现以下告警和报错信息。


出现工程目录长度超过250字符的告警，示例如下：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161141.94361859315083716950406307700731:50001231000000:2800:4B308708689AF7132124CF2FEB4AE8157E81F3818F79594EDEC11D6EEB4DC009.png)

出现编译报错“ninja: error: mkdir(xxx): No such file or directory”，示例如下：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161141.29398098697006864266539855829564:50001231000000:2800:1E73F172D28FC61C1C3D8CAC890C2560EE517E2950DE621E5BD1B6023EE7BE0E.png)

解决措施


CMAKE_OBJECT_PATH_MAX默认大小为250，如果工程中object file实际路径长度超出该大小，将导致编译报错。


开发者需要根据object file实际路径长度在工程CMakeLists.txt中设置CMAKE_OBJECT_PATH_MAX大小，具体方法如下：

-  示例中告警文件为TextMeasureCache.cpp.obj，长度为24字符，在默认值250的基础上增加24，即设置set(CMAKE_OBJECT_PATH_MAX 274)。
-  计算公式：CMAKE_OBJECT_PATH_MAX = 总路径长度 - object file中目录部分长度 + cmake哈希值字符数（固定为32） 代入示例中的长度后，计算可得：CMAKE_OBJECT_PATH_MAX = 297 - 74 + 32 = 255，即设置set(CMAKE_OBJECT_PATH_MAX 255)。
- 
- object file中目录部分长度：示例中“__/__/__/__/__/third-party/rn/ReactCommon/react/renderer/textlayoutmanager”长度为74字符，以实际为准。
- cmake哈希值字符数：cmake将长路径转换为哈希值时哈希值的长度，固定为32。
- 
- object file中目录部分长度：示例中“__/__/__/__/__/third-party/rn/ReactCommon/react/renderer/textlayoutmanager”长度为74字符，以实际为准。
- cmake哈希值字符数：cmake将长路径转换为哈希值时哈希值的长度，固定为32。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161141.19480564548894296412520224461028:50001231000000:2800:C49C51DE6C0DF471063556958594C7E8E8AC4BE6462B88AB6195FF18E1DF1932.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-32
爬取时间: 2025-05-08 07:26:27
来源: Huawei Developer


问题现象


Native工程编译报错，同时出现以下告警和报错信息。


出现工程目录长度超过250字符的告警，示例如下：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161141.74071349208535875061213038263085:50001231000000:2800:D7D767C671D07BC2A4631E349764E7398EDD8034D623B7AACE2220B6A3D097C1.png)

出现编译报错“(is the command line too long?)”，示例如下：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161141.07205788739042610626783071867725:50001231000000:2800:D4A3CA62D8362EFED4EFA2F8FC24FABC1137AE91C8949E5F01F3FF91B7205694.png)

解决措施


CMAKE_OBJECT_PATH_MAX默认大小为250，是CMake 中用于限制object file路径长度的变量。它的作用是在生成构建系统时，避免编译器或操作系统由于路径过长导致的问题。如果工程中object file实际路径长度超出该大小，将导致编译报错。理论上CMake对CMAKE_OBJECT_PATH_MAX没有最大限制，但操作系统和工具链会对路径长度有所限制，具体的值需要查询操作系统和工具链的介绍。


开发者需要根据object file实际路径长度在工程CMakeLists.txt中设置CMAKE_OBJECT_PATH_MAX大小，具体方法如下：

-  示例中告警文件为TextMeasureCache.cpp.obj，长度为24字符，在默认值250的基础上增加24，即设置set(CMAKE_OBJECT_PATH_MAX 274)
-  计算公式：CMAKE_OBJECT_PATH_MAX = 总路径长度 - object file中目录部分长度 + cmake哈希值字符数（固定为32） 代入示例中的长度后，计算可得：CMAKE_OBJECT_PATH_MAX = 297 - 74 + 32 = 255，即设置set(CMAKE_OBJECT_PATH_MAX 255)
- 
- object file中目录部分长度：示例中“__/__/__/__/__/third-party/rn/ReactCommon/react/renderer/textlayoutmanager”长度为74字符，以实际为准
- cmake哈希值字符数：cmake将长路径转换为哈希值时哈希值的长度，固定为32
-  设置CMAKE_OBJECT_PATH_MAX后，cmake会将长路径转换为32字符的哈希值以缩短路径长度，如果转换后的路径依然过长，只能缩短工程的存放路径。
- 
- object file中目录部分长度：示例中“__/__/__/__/__/third-party/rn/ReactCommon/react/renderer/textlayoutmanager”长度为74字符，以实际为准
- cmake哈希值字符数：cmake将长路径转换为哈希值时哈希值的长度，固定为32
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161141.20054720351693151483687648876571:50001231000000:2800:A0CECFC056495AA9EF5899A0C7853734273A01B64C17D29142DD3A2EF0B854FD.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-33
爬取时间: 2025-05-08 07:26:37
来源: Huawei Developer


问题现象


Native工程中使用find_path时出现以下报错信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161141.16024945466674447533058902024348:50001231000000:2800:61FEF988E031B4CBF09115AD4E39037024926E5CC57A1A728C5ABCB74DE88063.png)

解决措施


OpenHarmony SDK提供的CMake交叉编译配置文件（ohos.toolchain.cmake）中，限制了搜索路径为CMAKE_SYSROOT。


如果开发者需要添加搜索路径，可在CMakeList.txt中使用list接口添加自定义路径，如将"D:demo"添加至搜索路径：


```less
list(APPEND CMAKE_FIND_ROOT_PATH_MODE_INCLUDE "D:demo")
```


添加后，即可使用find_path查找"D:demo"目录下的文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-34
爬取时间: 2025-05-08 07:26:47
来源: Huawei Developer


问题现象


在配置hvigor及hvigor-ohos-plugin版本号后点击Sync，然后又再次修改了版本号，导致在build init中出现两次下载，而后build init出现报错或大量debug日志，最终无法build init成功。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161141.04650845376118407292073453082062:50001231000000:2800:F99A108385898246F924A09D8C073B41C79AF65CE51D4688F95D205608DE180E.png)

解决措施


出现该问题是由于执行到build init的下载Hvigor过程中修改了Hvigor版本，而后执行Hvigor.js时发现依赖有了变化所以产生了第二次下载新版本，从而导致了不兼容问题。尽量在执行Sync并下载Hvigor时不修改Hvigor版本。


点击File > Sync and Refresh Project，重新执行Sync即可。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-35
爬取时间: 2025-05-08 07:26:57
来源: Huawei Developer


问题现象

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161141.45338779100187126098217195945763:50001231000000:2800:F734DF5D75053706FCAA9382357274DC000969D92C863D94EA8F0756A58BD70B.png)

解决措施


出现该问题的原因是工程中使用的老的Hvigor-wrapper.js并且是使用的3.3.0及后续版本的Hvigor，Hvigor-wrapper.js与Hvigor不适配。不适配的场景包括：

- 场景一：使用4.0 Canary2之前的DevEco Studio，Sync时只会下载hvigor，不会下载dependencies下的内容（即hvigor-ohos-plugin）。在这个场景下，如果不更新DevEco Studio，并要更新hvigor版本，只能下载hvigor，无法下载hvigor-ohos-plugin。该场景下请更新至DevEco Studio NEXT Developer Preview1及以上版本。
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161141.73721679503284193232937027265412:50001231000000:2800:97EA83669114E5572B17A42AC41B274AF89EA7F9B97D170C987BE1EF43991FEE.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-36
爬取时间: 2025-05-08 07:27:06
来源: Huawei Developer


场景一：


问题现象


工程中模块A引用了模块B，编译模块A时出现错误，提示 "Unknown resource name 'xxxx'"，找不到模块B的资源。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161142.72607693188689310015163002129434:50001231000000:2800:706D5F7EE2A570B9B4E4D54E66F86AD3F7901F8B669BA959419E4A8EAE68302C.png)

解决措施


请确保符合以下条件：


场景二：


问题现象


引用模块的方式不对，如果引用的是一个其他模块的代码，也会报资源找不到。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161142.28982993486464977308024125287342:50001231000000:2800:C86D2DF73CEE29C4D2C19334DCC6D08325DDF20F60F754CB8A03B59E43CAB1E9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161142.51837100920050817547045623086607:50001231000000:2800:D686CBE82E57A3B98A31CCE3F6D532CA34E2DD89F297D8A680BE91EC814F0AB1.png)

解决措施


在oh_package.json5中引入该模块。通过定义的模块名称来引用。


如下图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161142.98319523846130063435618225993121:50001231000000:2800:4CB397C2AD429AF7E3FD3C58B47B3841DBEC148E82B517A925718D9F37EED26D.png)

场景三：


问题现象


HSP A 申请了某个权限，这个权限进行了资源的引用，在所有依赖A的组件进行构建时，报错 A 引用的资源找不到。


解决措施


手动在引用方配置对应资源可以解决此问题。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-37
爬取时间: 2025-05-08 07:27:16
来源: Huawei Developer


问题现象


命令行手动执行构建命令时，构建失败，提示“ERROR: Task xxx was not found in the project xxx”


问题确认

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161142.87145142204191769364559806080937:50001231000000:2800:EFCF8E3E7CE2708CABE0B62F02B70C078C529B61F04998EA6A61A184EBC4ACEF.png)

解决措施


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-38
爬取时间: 2025-05-08 07:27:25
来源: Huawei Developer


问题现象


DevEco Studio编译失败，提示“The reason and usedScene attributes are mandatory for user_grant permissions”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161142.04940160549998991604798395286240:50001231000000:2800:8930A5F9B274E1EDE41419373FDB51CF33E02F509313D7A07D118BC945D0B7B4.png)

问题原因


从DevEco Studio NEXT Developer Preview2版本开始新增规则：APP包中，所有entry和feature hap的module下的requestPermissions权限清单必须指定(可以缺省为空，若非空则name必填,user_grant权限则必填reason、usedScene字段)。


解决措施


进入对应module.json5文件中，补齐requestPermissions字段下的reason和usedScene字段。如以下示例：


```less
"requestPermissions": [
  {
    "name": "ohos.permission.READ_IMAGEVIDEO",
    "reason": "$string:module_desc",
    "usedScene": {
      "abilities": [
        "EntryAbility"
      ],
      "when": "inuse"
    }
  }
]
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-39
爬取时间: 2025-05-08 07:27:34
来源: Huawei Developer


问题现象


DevEco Studio编译失败，提示“Only one default card can be configured in the form_config.json file”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161142.70535719132648780616151953970727:50001231000000:2800:880E9E468FC8E5DDF91AE33686F9E3FBCDA4A52CE29344DCF1ED810D9680C2FC.png)

问题原因


从DevEco Studio NEXT Developer Preview2版本开始新增规则：卡片的配置文件中isDefault不可缺省，每个UIAbility有且只有一个默认卡片。


解决措施


进入对应module.json5文件中，选择唯一默认卡片，将其他卡片的isDefault字段设置为false。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-40
爬取时间: 2025-05-08 07:27:43
来源: Huawei Developer


问题现象


DevEco Studio编译失败，提示“In the form_config.json file, if the value of the updateEnabled field is true, the updateDuration and scheduleUpdateTime fields cannot be both empty.”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161142.75758563011539957774642729285896:50001231000000:2800:920EC0A79BC55AF3641341298BB76F249F95C4F511F1939AD3D61BA4D868AAD4.png)

问题原因


从DevEco Studio NEXT Developer Preview2版本开始新增规则：卡片的配置文件中updateEnabled不可缺省，为true时可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。


解决措施


进入对应module.json5文件中，按照需求，选择配置updateEnabled为false，或者增加定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式配置。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-41
爬取时间: 2025-05-08 07:27:53
来源: Huawei Developer


问题现象

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161142.86975390298950562804912178345699:50001231000000:2800:EAA0E3093933242A8D7DF4031C1430E44976121FF873FD9356977915B0EDE014.png)

解决措施


需要修改build-profile.json5文件，并登录个人华为账号后重新签名。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-42
爬取时间: 2025-05-08 07:28:02
来源: Huawei Developer


问题现象


本地HSP模块对外提供的接口中使用了HAP未定义的自定义参数BuildProfileFileds，且HAP引用了HSP中的该接口，导致编译失败，提示“Property 'XX' does not exist on type 'typeof BuildProfile'”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161142.88567180447253124385329678944830:50001231000000:2800:9237490E360FF2660008947C749E53FBF6AB4E3FE45F28BD5463A70F345257C1.png)

解决措施


可采用以下两种方式解决该问题：

- 在HAP中配置与HSP相同的自定义参数BuildProfileFileds。
- 将与HSP相同的自定义参数BuildProfileFileds配置到工程级build-profile.json5中，该方法会使HSP中的自定义参数在全局生效。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-43
爬取时间: 2025-05-08 07:28:12
来源: Huawei Developer


问题现象

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161142.46974126688388611301959694999550:50001231000000:2800:205A63C16562685487C76212C20E976A6515544DF4118ECFE55135F7E45BA9E4.png)

问题分析


报该错误，可能是build-profile.json5文件中未添加"targets"配置，Module Target下为空，工程同步失败。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161143.19355818589772366157882108991661:50001231000000:2800:EC00C33CC21581D135A7D942296BA234210A2640A98ABF74D5B00CAC3B33CF28.png)

解决措施


需要在模块级build-profile.json5文件中添加"targets"配置，点击"Sync Now"，待完成同步后，即可解决该问题（确保工程同步成功）。具体配置如图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161143.50724574600929073763150971716421:50001231000000:2800:FB376777B6BBD9A5B8B9805BE82B39643172C4C1EE86F2C7CF5CF89FA55665F2.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-44
爬取时间: 2025-05-08 07:28:21
来源: Huawei Developer


问题现象

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161143.47864890893976171017278431899403:50001231000000:2800:9C0B13B1F7918A61673B29D72FC4275D8A566B29CCC975107C8F901CCC403902.png)

解决措施


删除在C盘用户路径下.hvigor文件夹中的meta文件后，再重新签名编译即可。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-46
爬取时间: 2025-05-08 07:28:31
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-47
爬取时间: 2025-05-08 07:28:40
来源: Huawei Developer


问题现象


使用NDK时，会自动生成一个libc++_shared.so的库，使用了napiLibFilterOption中的excludes，但是没有效果，依然会打入HAR包中的lib目录下，如果有多个NDK项目，每个项目都存在这样的一个so库，包大小就会增加，如何删除这个库。


解决措施


将需要排除的.so文件路径，配置到模块级build-profile.json5文件中的nativeLib/filter配置下的"excludes"属性中，即："excludes":["**/Libc++_shared.so"]，即可实现自定义打包。


参考链接


配置CPP


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-48
爬取时间: 2025-05-08 07:28:50
来源: Huawei Developer


oh-package.json5文件中：

- dependencies（生产依赖）：声明需要在代码中import的HarmonyOS三方库（参与编译/运行阶段使用的依赖）。
- devDependencies（开发依赖）：参与项目的开发或测试阶段。
- dynamicDependencies（动态依赖）：动态依赖的HSP模块。在开发者需要动态加载HSP的时候配置使用。

示例如下：


```less
{
  "name": "parameter-test",
  "version": "@param:version", 
  "description": "test desc.",
  "main": "index.ets",
  "author": "test author",
  "license": "ISC",
  "dependencies": {
    "libtest1": "@param:dependencies.libtest1"
  },
  "devDependencies": {
    "libtest2": "@param:devDependencies.libtest2"
  },
  "dynamicDependencies": {
    "libtest3": "@param:dynamicDependencies.libtest3"
  },
  "parameterFile": '.parameterFile/parameterFile.json5' // 开启参数化并指定参数化配置文件路径
}
```


参考链接


oh-package.json5文件，添加依赖项


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-49
爬取时间: 2025-05-08 07:28:59
来源: Huawei Developer


问题现象


当SDK版本与镜像版本不匹配时，应用将会闪退，出现jscrash，同时hilog出现日志。


解决措施


现象根本原因是SDK工具与镜像版本不匹配。推荐使用匹配的SDK与镜像版本。


查看SDK版本方法：


在工程目录下local.properties文件中可以获取sdk路径，执行 {hwsdk.dir}/openharmony/11/ets/build-tools/ets-loader/bin/ark/build-win/bin/es2abc.exe --bc-version可查看SDK版本号。用于检验SDK与镜像版本是否匹配。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-50
爬取时间: 2025-05-08 07:29:09
来源: Huawei Developer


问题现象


运行DevEco Studio的build编译构建功能，产物中没有get/set方法所生成的代码逻辑。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161143.50489117338082279513728823947755:50001231000000:2800:07F3F56EFE69C4E067742345FBFD6596797AFE01BC6AA442E4B113F8B6AD4C8B.png)

```typescript
@Entry
@Component
struct GetSetDemo {
  private get value(): string {
    return "Hello";
  }
  private set value(value: string) {
    this.value = value;
  }


  build() {
    Row() {
      Column() {
        Text("Hello World")
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
      }
    }
  }
}
```


解决措施


1.可以使用以下方式替代get方法：


private value: string = "Hello";


2.可以使用以下方式替代set方法：


this.value = "World"；


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-51
爬取时间: 2025-05-08 07:29:19
来源: Huawei Developer


上架的时候应用市场会拆包重签名，对app签名就可以上架了，应用市场校验完app签名之后，会解压获取所有的HAP，再对HAP签名，就不用在DevEco Studio里签名。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-52
爬取时间: 2025-05-08 07:29:28
来源: Huawei Developer


操作步骤：

1. 
2.  签名完成后，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161143.79223617084739136282192004835114:50001231000000:2800:5B1F8D4887D5D72727AD10EE83448F4FFFB9942FC88E3EBCFD9FA9D6FD00ADD5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161143.39756013693260588593944201664634:50001231000000:2800:F30B01697ED513EFD0A105D9C7C4F8AE8801C71008B26ECCAF991F4A3FB791B4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161143.14153547626005492870273069621376:50001231000000:2800:BB703EFC7163B391D2690E86D5D6C86C2CB39612D0E22FE7F20947523EBAC76D.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-53
爬取时间: 2025-05-08 07:29:37
来源: Huawei Developer


在调试配置中将 Debug type 选择为 Dual (ArkTS/JS + Native) 、Native 或 Detect Automatically，在启动调试前进行配置并在下一次调试生效。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161143.07878341419590215346964163220815:50001231000000:2800:AFA418FCC2FAF918476455B71B1B8CE720B5FACBEA7BA6D7D6A4D0E9AB097FC4.png)

参考链接


启动调试


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-54
爬取时间: 2025-05-08 07:29:46
来源: Huawei Developer


操作步骤：

1.  在申请数字证书和Profile文件前，首先需要通过DevEco Studio来生成密钥和证书请求文件。 CSR文件创建成功后，将在存储路径下获取生成密钥库文件（.p12）和证书请求文件（.csr）。
2. 
3. 
4. 
5.  CSR文件创建成功后，将在存储路径下获取生成密钥库文件（.p12）和证书请求文件（.csr）。
6. 
7. 
8. 
9. 
10. 
11. 
12. 
13. 
14. 
15. 
16. 
17. 
18. 
19. 
20. 
- 密钥：包含非对称加密中使用的公钥和私钥，存储在密钥库文件中，格式为.p12，公钥和私钥对用于数字签名和验证。
- 证书请求文件：格式为.csr，全称为Certificate Signing Request，包含密钥对中的公钥和公共名称、组织名称、组织单位等信息，用于向AGC申请数字证书。
1. 
2. 
3. 
4.  CSR文件创建成功后，将在存储路径下获取生成密钥库文件（.p12）和证书请求文件（.csr）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161143.23361281993933437821638808613014:50001231000000:2800:979C8DFEEFE092E4B08049E1B1A22CF7A7DA30E0062C82EFBD23AE157D325B69.png)
- Key store file：设置密钥库文件存储路径，并填写p12文件名。
- Password：设置密钥库密码，必须由大写字母、小写字母、数字和特殊符号中的两种以上字符的组合，长度至少为8位。请记住该密码，后续签名配置需要使用。
- Confirm password：再次输入密钥库密码。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.53663539533157441416931089335266:50001231000000:2800:4F718DABA363931A49577A41AE2519232337A094B50FD85317CA83967B0CA570.png)
- Alias：密钥的别名信息，用于标识密钥名称。请记住该别名，后续签名配置需要使用。
- Password：密钥对应的密码，与密钥库密码保持一致，无需手动输入。
- Validity：证书有效期，建议设置为25年及以上，覆盖应用/元服务的完整生命周期。
- Certificate：输入证书基本信息，如组织、城市或地区、国家码等。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.32025696623296817145213735679062:50001231000000:2800:29DF988415676A9D03CA6ED035E51DFE10F8BF07CAAEC85F67BBD733428120EB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.79684195623188611705436729202925:50001231000000:2800:CA2AA191DD63BD671395A29C5500E9515177E98525F8F6497D3BB52574216624.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.21181073959411816850115884120327:50001231000000:2800:1B683B7ACA2B1112D602AEFF0D2C29AA3AC013D4A61638F3F2956967EF04448D.png)
1. 
2. 
3. 
4. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.66726848756035954215132285430461:50001231000000:2800:B944FCA8976EF43C9AD708AC0E4A5F220FB6455DAF37CFBC589E437A290765AD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.15049994499278721889002552681151:50001231000000:2800:67B15E5FE240272E7E25311F3486F241BC8E646174BAA1745330F44A3BFCD97F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.39590919312296065700846097892931:50001231000000:2800:52E9C913087DF285138B99372EF820DD59DE686CBA2B1017277A4E0A186CB74E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.71165701112374352887394473587811:50001231000000:2800:9947CB5529C0738482F29C495CBFFAFC4A39AC2031CA9FA943F9FE8FB2758D4B.png)
1. 
2. 
3. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.78128917231507712696434119517922:50001231000000:2800:6095D507B28F7959FF92661EB19E99C52DEE01F6ED89D475B1BAE51BCFFFD14C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.79459949950667376365250885549891:50001231000000:2800:B4C05A6905C99207F32EB82C30CD8328428ADD0B084543FCE1BFAA1C99EB1295.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.33665112445256498960229523264281:50001231000000:2800:DA6158F816B4312DA440692254A073A042837A226A9414987D95F4115AAD6BAF.png)
1. 
2. 
3. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.02078334416148883541169159089006:50001231000000:2800:C83920FF563A66A50EDF691C4F9D4597A3314F75D9D41A39E84EF3ACD7435FA0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.07451512964423014510020125581338:50001231000000:2800:AFFF120C028BB91F6A9F969153796B1FE2E1CC505ABDBB933642FD90E736F394.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.43871390762988097813967795477654:50001231000000:2800:1EBE1F4401075B68AD44A41FE75ADC1477217378E8A17DCBDF42E3E15225018B.png)
1. 
- Store File：密钥库文件，选择生成密钥和证书请求文件时生成的.p12文件。
- Store Password：密钥库密码，需要与生成密钥和证书请求文件时设置的密钥库密码保持一致。
- Key alias：密钥的别名信息，需要与生成密钥和证书请求文件时设置的别名保持一致。
- Key password：密钥的密码，需要与生成密钥和证书请求文件时设置的密码保持一致。
- Sign alg：固定设置为“SHA256withECDSA”。
- Profile file：选择申请调试Profile时下载的.p7b文件。
- Certpath file：选择申请调试证书时下载的.cer文件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161144.75390194442311267167902434014566:50001231000000:2800:5388B03BBE0FF47B6257C2B90D218156B1D043CA7F9FD72EDEC0F4BDCBB780EA.png)

参考链接


手动签名方式调试HarmonyOS应用/元服务


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-55
爬取时间: 2025-05-08 07:29:56
来源: Huawei Developer


在工程级build-profile.json5的app.products中如下进行配置：


```less
    "products": [
      {
        "name": "default",
        "signingConfig": "default",
        "compileSdkVersion": "4.1.0(11)",
        "compatibleSdkVersion": "4.1.0(11)",
        "runtimeOS": "HarmonyOS",
      }
    ],
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-56
爬取时间: 2025-05-08 07:30:07
来源: Huawei Developer


可以将so库导出放在libs目录下，然后在CMakeLists.txt中添加如下代码，如下所示添加libnativeSub.so到har包中。


```less
target_link_directories(entry PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/../../../libs/${OHOS_ARCH}/)
target_link_libraries(entry PUBLIC libace_napi.z.so libc++.a libnativeSub.so)
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-57
爬取时间: 2025-05-08 07:30:17
来源: Huawei Developer


在模块级build-profile.json5中如下进行配置：


```less
      "nativeLib": {
        "debugSymbol": {
          "strip": true,
          "exclude": [
            "**/3.so"
          ]
        }
      },
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-58
爬取时间: 2025-05-08 07:30:28
来源: Huawei Developer


```less
import { hapTasks } from '@ohos/hvigor-ohos-plugin';
import { getNode, HvigorNode, HvigorTask } from '@ohos/hvigor';


const node = getNode(__filename);
node.registerTask({
    name: 'customTask',
    run() {
        console.log('this is Task');
    }});
```


```less
./hvigorw customTask
```


参考链接


开发hvigor任务


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-59
爬取时间: 2025-05-08 07:30:37
来源: Huawei Developer


问题现象


C 代码中 include <stddef.h> 编译报错：


lib/clang/15.0.4/include/stddef. h:74:24: error: typedef redefinition with different tves ('unsigned short" vs 'unsigned int")typedefWCHAR_TYPE_ wchar_t;… 10/native/sysroot/us/include/aarch64-linux-ohos/bits/alltypes.h:15:18: note: previous definition is here typedef unsigned whar_t。


解决措施


在CMakeLists.txt中将TARGET_COMPILE_OPTIONS内参数-fshort-wchar删除。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-60
爬取时间: 2025-05-08 07:30:47
来源: Huawei Developer


在模块级build-profile.json5中的buildOption.arguments添加相关配置，指定CMake编译参数，如下示例代码所示，编译使用2个处理器，链接使用2个处理器。


```less
  "buildOption": {
    "externalNativeOptions": {
      "path": "./src/main/cpp/CMakeLists.txt",
      "arguments": "-DCMAKE_JOB_POOL_COMPILE:STRING=compile -DCMAKE_JOB_POOL_LINK:STRING=link -DCMAKE_JOB_POOLS:STRING=compile=2;link=2",
      "cppFlags": "",
    }
  },
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-61
爬取时间: 2025-05-08 07:30:57
来源: Huawei Developer


在终端输入ohpm list查看依赖关系。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-62
爬取时间: 2025-05-08 07:31:07
来源: Huawei Developer

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161145.86081942865883046443117793473247:50001231000000:2800:86BF53A024A37B89D95961B91E0B1F1090B144D810E5EAE8EC0DEA7CB9DE3F89.png)

可能原因


JRE版本过低。


解决措施


签名工具developtools_hapsigner要求JRE 8.0，升级JRE版本即可。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-63
爬取时间: 2025-05-08 07:31:18
来源: Huawei Developer


在hvigor/hvigor-config.json5的dependencies可以下载依赖，然后在hvigor的自定义任务中使用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-64
爬取时间: 2025-05-08 07:31:28
来源: Huawei Developer


在har包目录下的hvigorfile.ts文件中编写代码如下：


```less
import { harTasks } from '@ohos/hvigor-ohos-plugin';


function harTask(): HvigorPlugin {
  return {
    pluginId: 'harTask',
    apply(node: HvigorNode) {
      console.log('hello harTasks!');
    }
  }
}


export default {
  system: harTasks,
  plugins: [harTask()]
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-65
爬取时间: 2025-05-08 07:31:38
来源: Huawei Developer


问题场景：


如何根据不同的部署环境，不同的目标人群，不同的运行环境等，定制构建多目标产物，将同一个应用定制为不同的版本？


参考代码：


1.项目build-profile.json5配置demo如下：


```less
{
  "app": {
    "products": [
      {
        "name": "default",
        "signingConfig": "default",
        "compileSdkVersion": "4.1.0(11)",
        "compatibleSdkVersion": "4.1.0(11)",
        "runtimeOS": "HarmonyOS",
      },
      {
        "name": "release",
        "signingConfig": "release",
        "compileSdkVersion": "4.1.0(11)",
        "compatibleSdkVersion": "4.1.0(11)",
        "runtimeOS": "HarmonyOS",
      },
      {
        "name": "beta1",
        "compileSdkVersion": "4.1.0(11)",
        "compatibleSdkVersion": "4.1.0(11)",
        "runtimeOS": "HarmonyOS",
      },
      {
        "name": "zhaohangzhuanyong",
        "compileSdkVersion": "4.1.0(11)",
        "compatibleSdkVersion": "4.1.0(11)",
        "runtimeOS": "HarmonyOS",
      }
    ],
    "buildModeSet": [
      {
        "name": "debug",
      },
      {
        "name": "beta1"
      }
    ],
    "signingConfigs": [
      {
        "name": "release",
        "material": {
          "storePassword": "",
          "certpath": "",
          "keyAlias": "",
          "keyPassword": "",
          "profile": "",
          "signAlg": "SHA256withECDSA",
          "storeFile": ""
        },
        "type": "HarmonyOS"
      },
      {
        "name": "default",
        "material": {
          "storePassword": "",
          "certpath": "",
          "keyAlias": "",
          "keyPassword": "",
          "profile": "",
          "signAlg": "SHA256withECDSA",
          "storeFile": ""
        },
        "type": "HarmonyOS"
      }
    ]
  },
  "modules": [
    {
      "name": "entry",
      "srcPath": "./entry",
      "targets": [
        {
          "name": "default",
          "applyToProducts": [
            "release"
          ]
        }
      ]
    },
    {
      "name": "library1",
      "srcPath": "./library1"
    },
    {
      "name": "library2",
      "srcPath": "./library2"
    },
    {
      "name": "library",
      "srcPath": "./library",
      "targets": [
        {
          "name": "default",
          "applyToProducts": [
            "release"
          ]
        }
      ]
    },
  ]
}
```


2.target的配置在modules下面的build-profile.json5中；配置demo如下：


```less
{
  "apiType": "stageMode",
  "buildOption": {
    "arkOptions": {
      // "apPath": "./modules.ap" /* Profile used for profile-guided optimization (PGO), a compiler optimization technique to improve app runtime performance. */
    }
  },
  "buildOptionSet": [
    {
      "name": "release",
      "arkOptions": {
        "obfuscation": {
          "ruleOptions": {
            "enable": true,
            "files": [
              "./obfuscation-rules.txt"
            ]
          }
        }
      }
    },
  ],
  "targets": [
    {
      "name": "default",
      "runtimeOS": "HarmonyOS"
    },
    {
      "name": "ohosTest",
    }
  ]
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-66
爬取时间: 2025-05-08 07:31:49
来源: Huawei Developer


上线插件市场会有白名单管控，插件需要与HarmonyOS应用开发相关，本地可以使用Install Plugin from Disk加载。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-69
爬取时间: 2025-05-08 07:31:59
来源: Huawei Developer


问题场景一：


编译态没问题，使用了自定义参数BuildProfile，编译态无异常但编译构建失败，提示“Property xxx does not exist on type 'typeof BuildProfile'.”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161145.73102679473278383867339621896540:50001231000000:2800:56D29327310963995F34D87BDDA1FA323AAC5AE73EB83587CB642800AE806579.png)

解决方案：


检查在当前模块下build-profile.json5中的targets > buildProfileFields配置的自定义参数中key值是否相同，如果不同请将targets内所有buildProfileFields中的key值保持相同。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161145.61473458757976094496209420126593:50001231000000:2800:5ECF25640925859FB35CD15BBE5850CD0D57C04B8A9B03B3B9FA6E65DA44CA55.png)

问题场景二：


本地HSP模块对外提供的接口中使用了HAP未定义的自定义参数BuildProfileFields，且HAP引用了HSP中的该接口，导致编译失败，提示“Property 'XX' does not exist on type 'typeof BuildProfile'”。


解决方案：


可采用以下两种方式解决该问题：


1.在HAP中配置与HSP相同的自定义参数BuildProfileFields。


2.将与HSP相同的自定义参数BuildProfileFileds配置到工程级build-profile.json5中，该方法会使HSP中的自定义参数在全局生效。


问题场景三：


编译态标红，使用了自定义参数BuildProfile并且编译器标红且构建失败，提示“Property xxx does not exist on type 'typeof BuildProfile'.”。


解决方案：


请检查当前模块下build-profile.json5中buildProfileFields内是否添加了所使用的自定义参数，请确保该自定义参数已配置在buildProfileFields内。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-70
爬取时间: 2025-05-08 07:32:09
来源: Huawei Developer


使用Build Analyzer工具可以显示编译构建过程的重要信息，开发者可以可视化分析排查构建过程中的性能问题。


可以在构建完成后通过以下两种打开Build Analyzer窗口：

- 在底部的工具栏区域，直接点击Build Analyzer窗口进行查看。
- 在Run窗口，点击左侧边栏，打开Build Analyzer窗口。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161145.91734541841592830158069953591969:50001231000000:2800:768E7745304E3B6A372DEF83613B1D0E7A17E89BC917CB8A941D6E3E663ECD90.png)

完成构建后首次打开Build Analyzer 时，窗口会显示构建分析概览，如下图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161145.65800317104498257362470253791191:50001231000000:2800:FD19910A32D128B50DE2937A6A50B8A4D2E6286E03A400FD9EA81FA9ECF56643.png)

如需查看构建任务时间图谱，请从下拉菜单中点击Tasks，默认进入时间图谱界面。该界面会分块显示：构建历史记录、构建任务时长图谱、构建日志以及对应的日志详情信息，如下图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161145.16801336844270751280161739138993:50001231000000:2800:88B3157CB8486CC85083CCF3585659FEB5512D6CC04DFB3281367B0EAE2FD51F.png)

事件信息：


| 事件  | 子事件  | 业务  |
| --- | --- | --- |
| CompileResource  |    | 资源编译  |
| PackageHap/App  |    | 打包工具  |
| SignHap/App  |    | 签名工具  |
| BuildNativeWithCmake/Ninja  |    | cpp编译工具链  |
| CompileArkTS  | watchChangedFiles  | ArkUI  |
| invalidCachePlugin  | 编译构建  |
| oh-resolve  | 编译构建  |
| moduleInfoMetaPlugin  | 编译构建  |
| commonjs  | 编译构建  |
| etsChecker  | ArkUI 语言和类型编译器  |
| etsTransform  | ArkUI  |
| buildInstrument  | 测试框架  |
| genAbc  | 模块化，es2abc 语言和类型编译器  |
| delete  | 编译构建  |
| commonjs--resolver  | 编译构建  |
| ignorePlugin  | 编译构建  |
| apiTransform  | api范式  |
|    | commonPlugin  | 编译构建  |

事件


子事件


业务


CompileResource


资源编译


PackageHap/App


打包工具


SignHap/App


签名工具


BuildNativeWithCmake/Ninja


cpp编译工具链


CompileArkTS


watchChangedFiles


ArkUI


invalidCachePlugin


编译构建


oh-resolve


编译构建


moduleInfoMetaPlugin


编译构建


commonjs


编译构建


etsChecker


ArkUI


语言和类型编译器


etsTransform


ArkUI


buildInstrument


测试框架


genAbc


模块化，es2abc


语言和类型编译器


delete


编译构建


commonjs--resolver


编译构建


ignorePlugin


编译构建


apiTransform


api范式


commonPlugin


编译构建


参考链接：


分析构建性能


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-71
爬取时间: 2025-05-08 07:32:19
来源: Huawei Developer


注：此方法为临时规避方案，后续会修复该问题，最好在阻塞时再使用该方案！


用于减少编译hsp和闭源har包的时候，生成声明文件时emit的耗时


修改ets_checker.js文件（文件路径：SDK路径\default\base\ets\build-tools\ets-loader\lib\ets_checker.js）修改其中的processBuildHap函数。

1. 

```less
var sourceFile = _main.globalProgram.program.getSourceFile(e);
```

2. 

```less
(sourceFile && (t = ts.getFileEmitOutput(_main.globalProgram.program,sourceFile,!0,undefined,undefined,!0)).outputFiles[0])
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161145.56794997657436135995080825770768:50001231000000:2800:D7E4F6ED96F373ED9356F2A41F6041D917DC91CAC9DA72705E3ECE19832976C5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161146.36384034476854759817143721625203:50001231000000:2800:719D9AE67D125D4B060C3AA7839A77E5D67E35D1E140FCC1075112D7D378E111.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-72
爬取时间: 2025-05-08 07:32:29
来源: Huawei Developer


生成BuildProfile文件后，在代码中可以通过相对路径引入该文件。例如在HAR模块的Index.ets文件中使用该文件：


```less
import BuildProfile from './BuildProfile';
```


获取BuildProfile类中的值：


```less
const HAR_VERSION: string = BuildProfile.HAR_VERSION;
const BUILD_MODE_NAME:string = BuildProfile.BUILD_MODE_NAME;
const DEBUG:boolean = BuildProfile.DEBUG;
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161146.39647894591905605292502397540841:50001231000000:2800:6A35B439766AEDF20306CB4EAE279992216B291EE0D72CB0E7B4BD5FE9EB3EA0.png)

参考链接


HAR运行时获取编译构建参数


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-73
爬取时间: 2025-05-08 07:32:38
来源: Huawei Developer


目前不支持在Native侧直接读取。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-74
爬取时间: 2025-05-08 07:32:48
来源: Huawei Developer


问题现象


使用hdc file send向手机发送hap包和hsp包，但文件发送到手机上后就变成一个大小为3.4k的文件夹。执行install命令时提示解析错误。点击DevEco Studio右上角的绿色小三角按钮，当应用构建成功后，在项目根目录下执行hdc file send "./entry/build/default/outputs/default/entry-default-signed.hap" "data/local/tmp/app/entry-default-signed.hap"命令，最终推送到手机上的仍然不是单个hap包。目录结构如图：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161146.75790672628152984373440993111674:50001231000000:2800:99A305ABCCBD997244B6B388F806933A2FFF1B371ADCAC31ECE1D5F5BC70406A.png)

解决措施


路径只能用\绝对路径，不能用/相对路径。


绝对路径建议直接在DevEco Studio中Copy Absolute path。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-75
爬取时间: 2025-05-08 07:32:58
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-76
爬取时间: 2025-05-08 07:33:08
来源: Huawei Developer


问题现象


使用commandline-tools工具在linux上使用时提示：“Failed to request url https://devecostudio-dre.op.hicloud.com/sdkmanager/v5/hos/getSdkList”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161146.47495170290914041587948239711150:50001231000000:2800:A9A7C7A90118F003F21153EEB6AD299291D6F28406B18DE05746164D02CF1973.png)

解决措施


该问题一般是由于linux的国家码不是中国区导致。


可参考如下方式解决：

1. 
2. 
3. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161146.60836720822698470125872669710749:50001231000000:2800:8F75C1E8A5AB5D91247EC056EC33632B758C84B3A681F9540A4EFACA58C375E2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161146.71954511647767327310497912425003:50001231000000:2800:6D0BB7264CB7018C01BF945929C140BC3E85F10A7883D30CDC437A6F0EFC50DB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161146.95103907631390250821895660285115:50001231000000:2800:CF20422BC0B5DA0794A9B7926D44A0BD01E025C710E23D03DF383F7E507D7EDA.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-78
爬取时间: 2025-05-08 07:33:18
来源: Huawei Developer


问题描述


DevEco Studio安装完成后一直报Operation not permitted无权限，具体报错如下所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161146.93531914337497855707130817566289:50001231000000:2800:1DD71D1023831A7C91302E8C647BCC4891289F29248F963650E8CB6C5535C6DF.png)

解决方案


通过以下命令查看是否有com.example.myapplication标识


xattr -l /path/to/es2abc


用以下命令删除该标识


xattr -d  com.example.myapplication/path/to/es2abc


根因：mac系统对文件访问有限制


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-79
爬取时间: 2025-05-08 07:33:28
来源: Huawei Developer


可以使用hvigor命令：


```shell
 > hvigorw -s -p key1=value2222
```


取自定义参数代码：


```less
// hvigorfile.ts
import { hapTasks } from '@ohos/hvigor-ohos-plugin';
import { hvigor } from '@ohos/hvigor';
export default {
  system: hapTasks,  /* Built-in plugin of Hvigor. It cannot be modified. */
  plugins: []  /* Custom plugin to extend the functionality of Hvigor. */
}
console.log('value===', hvigor.getParameter().getExtParam('key1'));
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-80
爬取时间: 2025-05-08 07:33:38
来源: Huawei Developer


问题描述


点击生成签名报错：


解决方案：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161146.39666173934400913400751023923967:50001231000000:2800:A9386034C2DDA1CA40AA26276AAA23DCAAD1E988019DB658C4A8BE09BD77511B.png)

可尝试通过签名界面提供的profile file(*.p7b)/Certpath file(*.cer)对应的签名文件路径，删除本地的material文件夹，重新启动DevEco Studio签名。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-81
爬取时间: 2025-05-08 07:33:48
来源: Huawei Developer


如何通过构建参数传入签名信息，可参考准备申请签名所需文件


流水线构建应用可以通过构建命令行传入签名参数，并在自定义构建任务时获取命令行构建参数，但不支持通过自定义任务更改签名的配置。 在编译时进行签名目前可以采取自定义任务的实现方式，在编译打包时插入一个自定义签名任务调用签名工具进行签名，同时屏蔽掉原有的签名流程，可参考API使用示例


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-82
爬取时间: 2025-05-08 07:33:58
来源: Huawei Developer


使用^(?!.*xxx).*$排除正则搜索日志，且适用范围是全量日志包括domain和tag。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-84
爬取时间: 2025-05-08 07:34:08
来源: Huawei Developer


问题描述


项目中使用了包含了c/c++代码，通过build-profile.json5中abiFilters配置，当前模块可以只编译armv8-64a架构的so库，但是项目中还依赖了一些已经编译好的三方库，三方库里面有x86_64和armeabi-v7a架构的so库，这些库最终都会打包到hap包中，如何在hap包中只保留armv8-64a架构的so库？实现减少包大小。


解决方案


在build-profile.json5中进行如下配置：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161146.16492915460627213069994725962905:50001231000000:2800:69589EDD9F803C30FC0AB87B5FE28C553E471881900358A60C956C4857EE0A3C.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-86
爬取时间: 2025-05-08 07:34:18
来源: Huawei Developer


问题描述


我们想在编译打包的时候，去掉v7a，有没有可以配置的相关文档。


解决方案


可参考Bundle Manager包管理工具文档


```less
"externalNativeOptions":{
  "path": "./src/main/cpp/CMakeLists.txt", //CMake配置文件，提供CMake构建脚本
  "arguments": "", //传递给CMake的可选编译参数
  "abiFilters": ["arm64-v8a"], //用于设置本机的ABI编译环境
  "cppFlags": "" //设置C++编译器的可选参数
},
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-87
爬取时间: 2025-05-08 07:34:27
来源: Huawei Developer


问题描述


在编译C++库时有多条warn


platform/OHOS to use this system, please post your config file on discourse.cmake.org so it


这个是否会有影响


解决方案


您好，该问题原因为Mac的SDK中缺少OHOS.cmake文件导致。


需要在SDK存放目录的“default/base/native/build-tools/cmake/share/cmake-3.16/Modules/Platform”层级下，新建名为OHOS.cmake的文件，写入如下内容：include(Platform/Linux)。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-88
爬取时间: 2025-05-08 07:34:37
来源: Huawei Developer


问题描述


执行安装SDK的时候报错，请帮忙查看问题原因


./sdkmgr install xxx --sdk-directory="/opt/HarmonyOS/SDK" Failed to request url https://devecostudio-dre.op.hicloud.com/sdkmanager/v7/hos/getSdkList [ ]0% Failed to request the remote SDK. This may be caused by a network error. If your environment needs a proxy to access the Internet, check whether the --proxy and --no-proxy parameters are correctly set. If they are not set, check whether the http_proxy/HTTP_PROXY and no_proxy/NO_PROXY environment variables are correctly set. root@luckyclientbuild01-test3-ucscompute16-cloudvsp:~/command-line-tools/sdkmanager/bin#


解决方案


编译时建议先执行clean操作，尽量不做增量编译，避免上次编译产物影响新的编译。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-89
爬取时间: 2025-05-08 07:34:46
来源: Huawei Developer


问题描述


闭源库如何真正能保证闭源性、安全性？


当前闭源库只能做到基础的字段混淆，伙伴验证下来只能混淆20%不到，实际的逻辑并不能混淆，对比js打包工具webpack打包出来的混淆效果（webpack打包后无法通过format js看清内部的逻辑），我们还差很多。


如果后续有规划，后续具体的规划是怎样的？针对现状当前如何保证银行金融类sdk的闭源行安全性问题？


解决方案


混淆比例较低的原因可能有以下两点


1：属性混淆-enable-property-obfuscation、export内容混淆-enable-export-obfuscation，顶层作用域混淆-enable-toplevel-obfuscation等选项没有开启。


2：若上述主要混淆选项都已开启，仍存在混淆比例低的现场，那么可能由于你定义的变量、属性名、函数名、方法名与系统白名单重名导致没有混淆，建议给名称加上前缀或后缀来避开系统白名单。系统白名单的缓存路径：build/cache/{…}/release/obfuscation/systemApiCache.json


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-90
爬取时间: 2025-05-08 07:34:56
来源: Huawei Developer


问题描述


HarmonyOS  NDK上的llvm是否有更改，一些中间产物能否复用


解决方案


HarmonyOS  NDK上的llvm只支持ohos编译的一些中间产物复用，非ohos编译的产物不能复用


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-91
爬取时间: 2025-05-08 07:35:06
来源: Huawei Developer


问题描述


使用CMake将现有工程编译armeabi-v7a架构时出现


D:/DeveloperTools/Huawei/SDK/default/base/native/llvm/lib/clang/15.0.4/include/arm_neon.h:28:2: error: “NEON intrinsics not available with the soft-float ABI. Please use -mfloat-abi=softfp or -mfloat-abi=hard”#error “NEON intrinsics not available with the soft-float ABI. Please use -mfloat-abi=softfp or -mfloat-abi=hard”


解决方案


可以进行如下验证：neon指令集引入方案如下：


entry目录下的build-profile.json5文件中externalNativeOptions节点添加配置项：


```less
"externalNativeOptions": {  
"path": "./src/main/cpp/CMakeLists.txt",  
"arguments": "",  
"abiFilters": ["arm64-v8a"], // 这是要添加的配置项  
"cppFlags": "-mfloat-abi=hard", // 这是要添加的配置项 }
```


引入头文件#include <arm_neon.h>


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-92
爬取时间: 2025-05-08 07:35:16
来源: Huawei Developer


问题描述


HarmonyOS Next 创建的 Native C++ 项目，默认可以有 arm64，armv7，x86_64三种架构，分别用在什么地方？


在 DevEco-Studio 3.1.1 release 版本，模拟器可以只使用 arm64


在 DevEco-Studio Next Preview1 版本，Next 真机可以只使用 arm64


那是否需要对外提供 armv7 和 x86_64 的 SDK？分别会在什么情况下用到这两种架构？


解决方案


arm64：这是一种64位的 ARM 架构，适用于大多数现代的移动设备和嵌入式系统，如智能手机、平板电脑、物联网设备等。armv7：这是一种32位的ARM架构，适用于较老的移动设备和嵌入式系统，如早期移动设备、低功耗物联网设备等。x86_64：这是一种64位的 x86 架构，适用于桌面电脑、服务器和虚拟机等基于x86处理器的系统。 无需额外提供armv7和 x86_64版本


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-93
爬取时间: 2025-05-08 07:35:26
来源: Huawei Developer


问题描述


import静态加载的时候如果引用的是index文件的，那是不是会一次性将index文件内的内容全部加载？另外如果静态引用时是引用的具体路径，一旦组件混淆了，具体路径就没了，变为混淆后的路径，这个问题怎么解决？有没有什么加载引用的优化方式？


解决方案


是的，会一次性将index文件内的内容全部加载，可以使用动态导入来代替静态引用，动态导入允许在运行时动态加载模块，而不是在编译时静态加载。这样可以在代码混淆后仍然保留正确的模块路径。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-94
爬取时间: 2025-05-08 07:35:35
来源: Huawei Developer


问题描述


linux编译release的har包，产物中将cpp目录完全过滤掉了，/main/cpp/types目录没有了


解决方案


包名大小写问题，目前Linux区分大小写，mac不区分大小写。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-95
爬取时间: 2025-05-08 07:35:45
来源: Huawei Developer


问题描述


项目中使用了包含了c/c++代码，通过build-profile.json5中abiFilters配置，当前模块可以只编译armv8-64a架构的so库，但是项目中还依赖了一些已经编译好的三方库，三方库里面有x86_64和armeabi-v7a架构的so库，这些库最终都会打包到hap包中，如何在hap包中只保留armv8-64a架构的so库，实现减少包大小？


解决措施


在编译打包的时候在hap包中仅编译指定的so库,在build-profile.json5中配置：


```less
  //配置筛选har依赖.so资源文件的过滤规则         
       "nativeLib": {         
        "filter": {         
            //按照.so文件的优先级顺序，打包最高优先级的.so文件        
         "pickFirsts": [           
           "**/1.so"               ],        
        //按照.so文件的优先级顺序，打包最低优先级的.so文件         
           "pickLasts": [          
            "**/2.so"               ],         
         //排除的.so文件       
            "excludes": [             
           "**/3.so", //排除所有名称为“3”的so文件           
           "**/x86_64/*.so //排除所有x86_64架构的so文件                ],          
        //允许当.so重名冲突时，使用高优先级的.so文件覆盖低优先级的.so文件           
          "enableOverride": true
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-99
爬取时间: 2025-05-08 07:35:55
来源: Huawei Developer


问题描述


mac系统项目编译报错如下:


```less
hvigor ERROR: EMFILE: too many open files, open '/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/ets/build-tools/ets-loader/kit_configs/@kit.ArkTS.json'
```


解决措施


最大连接数限制就是系统所能打开的最大文件数（文件描述符）的限制,Linux动态端口号默认范围是32768-65535，也就是说，作为客户端连接同一个IP和同一个端口号，最多只能建立30000多个连接，而Mac默认只能建立16000个左右的连接。可以在DevEco Studio终端执行如下命令(根据自己实际情况填充数字)：


```less
sysctl kern.maxfiles
sudo sysctl -w kern.maxfiles=20480
sudo sysctl -w kern.maxfilesperproc=18000
hvigorw --stop-daemon-all
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-100
爬取时间: 2025-05-08 07:36:05
来源: Huawei Developer


问题描述


程序包目前打包完体积很大,远超预期.


解决措施


1.首先查看打包的类型,debug编译打包含有调试信息相对于release包的体积较大.可以通过配置"strip": true来去除so中的debug信息减小so体积。该配置需要配置在hap和hsp模块，release和debug模式下都可以配置:


```less
"nativeLib": {
"debugSymbol": { // 可通过此配置对cpp编译产物so执行strip，移除so中的调试信息与符号表等
"strip": true, // 执行strip
"exclude": [] //执行strip的过滤正则表达式规则
},
```


2.当前DevEco Studio默认打包应用时不压缩so库文件，配置so压缩选项后，DevEco Studio会将so库文件以压缩形式打包到包中，从而减小应用包大小。修改应用模块配置文件module.json5中的compressNativeLibs字段，将值配置为true，重新编译、打包应用。


```less
{
"module": {
// ...
"compressNativeLibs": true // 标识libs库以压缩存储方式打包
}
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-101
爬取时间: 2025-05-08 07:36:15
来源: Huawei Developer


问题描述


使用命令行编译时报错“hap-sign-tool:erro :ACCESS_ERROR, code: 109. Details: Init keystore failed: parseAlgParameters failed: ObjectIdentifier() -- data isn't an object ID (tag = 48) Detail: Please check the message from tools.”


编译命令是：hvigorw assembleHap --mode module -p product=default -p debuggable=false --no-daemon


解决措施


由于本地java版本过低，需要升级本地java版本到jdk17以上。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-102
爬取时间: 2025-05-08 07:36:25
来源: Huawei Developer


问题描述


如何以release编译类型编译HAR包


解决措施


如下图，在DevEco Studio 右上角product选中要编包的模式,然后make module har包,Generate Build Profile生成的文件去查看目前包的编译模式即可.

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161147.34678032772198337616757955294251:50001231000000:2800:9190407D2CE01F69B8FCC43C43F35ABFF2E9BE523C35B4B8FD02D3615AD5F026.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-103
爬取时间: 2025-05-08 07:36:35
来源: Huawei Developer


问题描述


打包的har包，在工程内，编译通过，但是安装时失败。


```less
04/10 14:01:54: Install Failed: error: failed to install bundle. 
code:9568278 
error: install version code not same. 
$ hdc shell rm -rf data/local/tmp/f47e1222b8c64dbe92f86bc3b55cc3d2 
Error while Deploy Hap
```


可能原因


该报错是因为需要安装的应用和系统已经安装的应用中，app.json的versionCode字段不一致。


解决措施


方案一：可能开发者使用DevEco Studio的debug按钮安装了该应用，后来有通过打包之后hdc install 的方式安装可以使用命令查看已安装应用的debug字段信息：


```less
bm dump -n 应用bundleName | grep debug  
```


普通应用卸载安装：


```shell
>hdc uninstall 应用bundleName  
```


清空应用数据：


```less
hdc shell bm clean -d -n 应用bundleName  
```


方案二：也可能是保存的数据应用版本和新安装的版本不一致导致的 ===》run->Edit Configurations  Run/Debug Configuration，去掉保存数据Keep Application Data的勾选。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161147.44587551262839477418295926324354:50001231000000:2800:4AD0E224AD62CE72E9D4B2428F8D6FD7CB57A336AE6C846C2FEF1A7739A5C2F5.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-104
爬取时间: 2025-05-08 07:36:45
来源: Huawei Developer


在hvigorfile.ts文件中，参考执行如下示例：


```less
import { hapTasks } from '@ohos/hvigor-ohos-plugin';
import { exec } from 'node:child_process';
import util from 'node:util';


const scriptPath = 'xxxx.bat';


export function customPluginFunction1(str?: string) {
  return {
    pluginId: 'CustomPluginID1',
    apply(pluginContext) {
      pluginContext.registerTask({
        // 编写自定义任务
        name: 'customTask1',
        run: (taskContext) => {
          console.log('run into: ');
          const execPromise = util.promisify(exec)
          execPromise(scriptPath).then(res => {
            console.log(res, 'res');
          }).catch(err => {
            console.log(err, 'err');
          })
        },
        // 确认自定义任务插入位置
        dependencies: ['default@BuildJS'],
        postDependencies: ['default@CompileArkTS']
      })
    }
  }
}


export default {
  system: hapTasks, /* Built-in plugin of Hvigor. It cannot be modified. */
  plugins: [customPluginFunction1()] /* Custom plugin to extend the functionality of Hvigor. */
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-105
爬取时间: 2025-05-08 07:36:54
来源: Huawei Developer


问题现象


DevEco Studio编译时出现错误，提示“no such file or directory, realpath 'xxx'”错误信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161147.66668982134392312356579332548786:50001231000000:2800:A5715DBE08E01C6CB6AFCEB1833610C4EDB01CE54182EF4F232870348B0056ED.png)

解决措施


“no such file or directory”是一种常见的错误提示，表示当前工程无法找到指定文件或目录，可能由多种原因引起，通常由于文件或目录被意外删除、当前指定文件或目录路径不正确、指定文件或目录没有足够权限访问导致。以下提供常见可能的解决方案：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-106
爬取时间: 2025-05-08 07:37:03
来源: Huawei Developer


问题现象


编译构建时，内存或CPU占用过高，导致出现DevEco Studio运行卡顿、延迟等现象。


解决措施

-  可以在hvigor-config.json5中添加配置。 当配置项"hvigor.pool.maxSize"和"ohos.arkCompile.maxSize"的值改小，"hvigor.enableMemoryCache"改为false后，可能会导致编译时长增加，请耐心等待。

```less
"properties": {
  // 配置为0，表示不启用内存缓存配置，默认为4，数值越低，内存中缓存数据越少
  "hvigor.pool.cache.capacity": 0,
  // 默认配置为cpu核数-1， 包含ohos.arkCompile.maxSize4，值越小，占用内存越少
  "hvigor.pool.maxSize" : 5,
  // 默认配置值为5, 值越小，占用内存越少
  "ohos.arkCompile.maxSize": 3
  // 默认配置值为true, 表示开启内存缓存，占用内存较多，配置为false,关闭内存缓存，占用内存较少
  "hvigor.enableMemoryCache": false
},
```

-  使用非并行模式编译，内存占用会减少，但可能会导致编译时长增加，请耐心等待。

```less
hvigorw assembleHap --no-parallel
```

- 

```less
hvigorw assembleHap --no-parallel
```

- 

```less
hvigorw assembleHap --no-parallel
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161147.41985629350574962792516165553600:50001231000000:2800:63A13362D2049926146C67DE2FBC35E83DEA1A9A3611C75BDF3E842045167EAB.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-107
爬取时间: 2025-05-08 07:37:14
来源: Huawei Developer


问题现象


编译构建时，报错“Duplicated files found in module entry. This may cause unexpected errors at runtime”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161148.89647702331962151754657066562281:50001231000000:2800:B40CBC8943F680E27093C0E09E425E53BE2B19748D752554F9F8807F7EEC23A7.png)

解决措施


该报错是从不同的包中收集到了相同名称的so包，导致so包冲突，可在模块级build-profile.json5文件中添加enableOverride字段并设置true。更多内容可参考build-profile.json5。


```less
"buildOption": {
  "nativeLib": {
    "filter": {
      "enableOverride": true
    }
  }
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-108
爬取时间: 2025-05-08 07:37:24
来源: Huawei Developer


请先根据XXX的值从以下场景排查，没解决问题再参考最终方案。

-  问题现象 编译构建时，出现报错“Cannot read properties of undefined(reading 'setEnabled')”。 问题确认 hvigorfile.ts里有如下代码： 处理措施 假设是entry模块的hvigorfile.ts中的代码导致的问题 ，XXX的有效值就是下图中的“default@SignHap”、“default@CollectDebugSymbol”、“assembleHap”等值。

```less
import { hvigor, getHvigorNode } from "@ohos/hvigor"
import { hapTasks} from '@ohos/hvigor-ohos-plugin';
// 问题代码
getHvigorNode(__filename).getTaskByName('XXX').setEnabled(false)；
export default {
    system: hapTasks, /* Built-in plugin of Hvigor. It cannot be modified. */
    plugins: []         /* Custom plugin to extend the functionality of Hvigor. */
}
```

-  假设是entry模块的hvigorfile.ts中的代码导致的问题 ，XXX的有效值就是下图中的“default@SignHap”、“default@CollectDebugSymbol”、“assembleHap”等值。
- 确保getTaskByName的使用位置是在Hvigor的配置阶段及之后的生命周期里，包括beforeNodeEvaluate、afterNodeEvaluate、nodesEvaluated、taskGraphResolved、buildFinished。
-  问题现象 编译构建时，出现报错“Cannot read properties of undefined(reading 'isSO')”。 处理措施 升级到DevEco Studio 5.0.9.300及以上的版本。
-  问题现象 编译构建时，出现报错“Cannot read properties of undefined(reading 'getPluginId')”。 处理措施 确保hvigorfile.ts里export default的对象中的字段system的值是appTasks/hapTasks/hspTasks/harTasks之一。

```less
import { appTasks } from '@ohos/hvigor-ohos-plugin';


export default {
    system: appTasks,  /* Built-in plugin of Hvigor. It cannot be modified. */
    plugins:[]         /* Custom plugin to extend the functionality of Hvigor. */
}
```

-  问题现象 编译构建时，出现报错“Cannot read properties of undefined(reading 'getNeedExecTargetServiceList')”。 处理措施 确保模块下的module.json5的type字段的值和hvigorfile.ts中export default的对象的system字段符合以下对应关系： module.json5的type字段 hvigorfile.ts中export default的对象的system字段 entry hapTasks feature hapTasks shared hspTasks har harTasks
-  问题现象 编译构建时，出现报错“Cannot read properties of undefined(reading 'app')”。 处理措施 确保工程目录下AppScope/app.json5文件存在。
-  问题现象 Linux环境下，执行单元测试，出现报错“Cannot read properties of undefined(reading 'toString')”。 处理措施 Linux环境暂不支持单元测试。
-  问题现象 编译构建时，出现报错“Cannot read properties of undefined(reading 'kind')”。 处理措施 检查ArkTS代码是否有如下写法：

```typescript
// 错误写法：空数组
class w {
  public a: [][] = []
  test() {
    console.log("1", this.a[0])
  }
}
// 正确写法
class w {
  public a: string[][] = []
  test() {
    console.log("1", this.a[0])
  }
}
```

-  问题现象 编译构建时，出现报错“Cannot read properties of undefined(reading 'clear')”。 问题确认 在工程根目录hvigor/hvigor-config.json5文件中配置如下内容打开堆栈。 确认堆栈内容是否如下。 处理措施 确认DevEco Studio是否有使用安全加固等三方插件。如果有，可以先禁用三方插件，看是否会复现问题，还能复现就参考下面的最终方案。

```less
"debugging": {
  "stacktrace": true                /* Disable stacktrace compilation. Value: [ true | false ]. Default: false */
},
```

-  如果以上场景都不符合，打开堆栈后，根据堆栈信息排查代码。 堆栈打开方法：工程根目录hvigor/hvigor-config.json5文件中配置如下内容。 优先排查hvigorconfig.ts文件和hvigorfile.ts文件，其他代码次之。 如果上述文件中并未排查出问题，请及时向我们提单反馈。 请按照如下步骤进行操作：提单链接，在线提单 -> 问题分类选择"HarmonyOS NEXT / 开发工具 / DevEco Studio"。

```less
"debugging": {
  "stacktrace": true                /* Disable stacktrace compilation. Value: [ true | false ]. Default: false */
},
```

1.  假设是entry模块的hvigorfile.ts中的代码导致的问题 ，XXX的有效值就是下图中的“default@SignHap”、“default@CollectDebugSymbol”、“assembleHap”等值。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161148.15999457376945982117916487806438:50001231000000:2800:E107240888B74703C38AF771B680316611BF92B86D5D8C0065474290E5532CDB.png)

| module.json5的type字段  | hvigorfile.ts中export default的对象的system字段  |
| --- | --- |
| entry  | hapTasks  |
| feature  | hapTasks  |
| shared  | hspTasks  |
| har  | harTasks  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161148.62542362710674346406413941406896:50001231000000:2800:1940B6B79E00527297A8BB5148CA22D751959DEA1A05CB680CE535EDC110A412.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161148.56647272797215822087288563170231:50001231000000:2800:927059157A60F9A04D6B143B43CF0A5114A8947AA751B6886ED0A70D1FBC27CF.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-109
爬取时间: 2025-05-08 07:37:33
来源: Huawei Developer


问题现象


编译构建时，出现报错“Duplicated files found in module xxx. This may cause unexpected errors at runtime”。


问题原因是构建时存在不同版本的同名so文件。比如将har模块产物里的so文件拷贝到entry模块的libs目录下，这时har模块里有一个libhar.so，entry模块里也有一个libhar.so，再配置entry依赖har，构建entry就会出现报错。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161148.73380857164445079496768630559304:50001231000000:2800:904A10E90C02CD9E1E66CD808D2C6822F9F768AFAD1ECF9C48801DB24C598F2F.png)

解决措施


使用select、pickFirsts、pickLasts等配置选中要使用的so文件; select提供native产物的精准选择能力，优先级高于excludes、pickFirsts等配置项。pickFirsts、pickLasts按照.so文件的优先级顺序，打包最高优先级的.so文件，优先级顺序是指依赖收集的顺序，越晚被收集优先级越高。


具体可参考：build-profile.json5。


基于上面的例子，可以在entry的build-profile.json5中添加配置select选中har模块中的so文件，package选中包名为“har”的模块, include选中“libhar.so”文件。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161148.04737131910787693300721647817677:50001231000000:2800:8F7CCDB9A972E28E01A95E996923FD810DCBE80A49088F91C7D6E6B2A38BD4B7.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-110
爬取时间: 2025-05-08 07:37:42
来源: Huawei Developer


问题现象


打包APP时，提示“input module releaseType is different”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161148.55601031566916147129845203667388:50001231000000:2800:7CD4A0D703A054E1A7E6DE6A500ACF82387886D63CC38B3EF39B279E792232A3.png)

解决措施


根据报错日志的Warning信息所提示的模块名称，检查模块间的apiReleaseType字段是否一致。


该apiReleaseType字段由编译构建工具自动生成，保存在HAP/HSP包的module.json文件中。如下图所示，首先确认各模块间该字段是否一致，如果存在不一致的情况，需要将应用的各个模块，使用相同版本的SDK重新打包，然后打包APP。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161148.47838699337851388428245963496968:50001231000000:2800:9F8C65D11E0C3F1A42E1F05CCE288603F614FABBA835EE8BCC00D75789DAFEB4.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-111
爬取时间: 2025-05-08 07:37:53
来源: Huawei Developer


问题现象


打包APP时，提示“debug is different”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161148.39236735362388292152121872644133:50001231000000:2800:E252E7F6B38BA9E8447EDF157C68A2932B1F706FF4B8F674D09BF2ACF9C73138.png)

解决措施


根据报错日志的Warning信息所提示的模块名称，检查模块间的debug字段是否一致，尤其需要关注本地模块和外部引用模块之间是否一致。


1.该debug字段由编译构建工具自动生成，保存在HAP/HSP包的module.json文件中，如下图所示，首先确认各模块间该字段是否一致。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161148.73377139100400819342185471265771:50001231000000:2800:3384EE2339A7EA6AEB7A07C0880F1994F46DC5631371A68C5DE24466D5AE8A1F.png)

2.编译工具根据设置的Build Mode选项生成debug标识，如图所示，可以通过此处进行设置。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161148.05943539792939650802491783960733:50001231000000:2800:5EE4ADA4C28CFE9B4577618CDAD789D70ED1DA558388F8E300FD922575688334.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-112
爬取时间: 2025-05-08 07:38:03
来源: Huawei Developer


问题现象


打包APP时，提示“uri datashareproxy://bundleName/** in proxy data is duplicated”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161148.74588945476102707176676998788087:50001231000000:2800:22BDD9F35AE96C86CB9410A66F40F8BAFEFF5152F00CE8FA4155CCE712AF9194.png)

解决措施


proxyData标识模块提供的数据代理列表，只允许entry和feature配置，不同的proxyData中配置的URI不可重复。遇到此问题，检查模块间是否配置了相同uri的proxyData。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161148.58723439403572553080338646619207:50001231000000:2800:4497287AFD240641268B3A43DCAFAF0EAAF05D5A9F82A4B8E22BDFFE315091B2.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-113
爬取时间: 2025-05-08 07:38:13
来源: Huawei Developer


问题现象


编译构建时，出现错误：Init keystore failed: parseAlgParameters failed: ObjectIdentifier()。


```less
hap-sign-tool: error: ACCESS_ERROR, code: 109. Details:   Init keystore failed: parseAlgParameters failed: ObjectIdentifier() -- data isn't an object ID (tag = 48)   Detail: Please check the message from tools
```


错误原因


使用高版本JDK生成密钥对(p12)，再使用低版本的JDK执行签名命令时，会因为不兼容导致解析p12失败，从而签名失败。


场景


解决方案


请检查当前使用的JDK版本和生产密钥对使用的JDK版本，使用版本匹配的JDK执行签名命令。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-114
爬取时间: 2025-05-08 07:38:22
来源: Huawei Developer


问题现象


编译构建时，出现错误：message:generate SignerBlock failed。


```less
hap-sign-tool: error: {errorcode:0,message:generate SignerBlock failed}
```


错误原因


签名用的公私钥对不匹配，使用私钥签名后，用公钥验签失败。需保证私钥(keyalias)和公钥(appCertPath)配对使用。


场景


解决方案


请选择正确、配对的keyalias和appCertPath文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-115
爬取时间: 2025-05-08 07:38:32
来源: Huawei Developer


问题现象


编译构建时，出现错误：java.io.IOException: DerValue.getOID, not an OID 49。


```less
hap-sign-tool: error: ACCESS_ERROR, code: 109. Details: java.io.IOException: DerValue.getOID, not an OID 49 Detail: Please check the message from tools
```


报错原因


证书文件解析失败，找不到证书的OID。


场景


解决方案


请检查证书文件是否正确。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-116
爬取时间: 2025-05-08 07:38:43
来源: Huawei Developer


问题现象


在编译HarmonyOS C++ 项目时，报错提示"A 'undefined symbol' error has occurred"。


解决措施


"undefined symbol"错误通常表示链接器找不到特定符号的定义。这通常是因为源文件没有正确编译或链接，或者因为缺少必要的库文件。以下是如何定位和解决这个问题的步骤：


1. 确保所有源文件都已包含在 CMake 构建中。


首先，检查您的 CMakeLists.txt 文件，确保所有相关的源文件都已包含在项目中。


```less
cmake_minimum_required(VERSION 3.10) 
project(MyProject)  
set(CMAKE_CXX_STANDARD 17)  
include_directories(${CMAKE_CURRENT_SOURCE_DIR}                    
                    ${CMAKE_CURRENT_SOURCE_DIR}/include)  
# 添加所有源文件
add_library(myProgram SAHRED main.cpp myLibrary.cpp) 
```


2. 确认源文件的符号定义。


确保在所有相关的源文件中正确定义了符号。例如，检查 myLibrary.cpp 是否包含 myFunction 的定义：


myLibrary.cpp


```less
#include "myLibrary.h" 
void myFunction() {     
// Function implementation
}
```


myLibrary.h


```less
#ifndef MY_LIBRARY_H
#define MY_LIBRARY_H 
void myFunction();  
#endif 
```


3. 检查编译和链接顺序。


确保所有源文件和库文件按照正确的顺序进行编译和链接。CMake 和 Ninja 通常会处理这个问题，但在手动编译时可能会出现问题。


4. 清理和重新生成构建文件。


有时，构建文件可能会损坏或丢失符号定义。尝试清理构建目录并重新生成构建文件：


```less
hvigorw clean 1 
```


或手动删除模块下.cxx目录。


5. 检查库路径和链接器标志。


如果使用三方库，确保 CMakeLists.txt中正确配置了库路径和链接器标志。例如：


```less
cmake_minimum_required(VERSION 3.10) 
project(MyProject)  
set(CMAKE_CXX_STANDARD 17)  
# 确保添加三方库的头文件
include_directories(${PATH_TO_EXTERNAL_LIBRARY}
                    ${PATH_TO_EXTERNAL_LIBRARY}/include)  
# 添加源文件
add_library(myProgram SAHRED main.cpp myLibrary.cpp)  
# 链接三方库
target_link_libraries(myProgram PUBLIC /path/to/external/library) 
```


6. 启用详细编译和链接输出。


为了解详细的编译和链接过程，可以启用更详细的输出。在 CMakeLists.txt 中添加以下内容：


```less
set(CMAKE_VERBOSE_MAKEFILE ON)
```


7. 检查 Ninja 输出日志。


Ninja 默认生成 .ninja_log 文件，其中包含构建过程的详细信息。您可以检查这个日志文件以了解构建过程中的问题。


```less
cat {module}/.cxx/default/default/arm64-v8a/.ninja_log 
```


检查编译日志中是否存在符号所在的源文件或头文件。


8. 使用 nm 工具检查符号。


使用 nm 工具检查目标文件和库文件中的符号，确保符号定义存在。


可使用sdk中内置的nm工具：sdk/default/openharmony/native/llvm/bin/llvm-nm。


检查目标文件


```less
nm myLibrary.o | grep myFunction 
```


检查三方库文件


```less
nm /path/to/external/library | grep myFunction
```


结论


通过上述步骤，您可以定位和解决 error: undefined symbol 问题。在使用 CMake、Ninja 和 LLVM 编译 C++ 项目时，确保所有源文件和库文件正确包含在项目中，并正确配置编译和链接选项是关键。如果问题依旧存在，详细的编译和链接输出日志通常能提供更多线索，帮助您找到具体的原因。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-117
爬取时间: 2025-05-08 07:38:53
来源: Huawei Developer


问题现象


在编译HarmonyOS C++ 项目时，报错提示"A 'unknown type name' error has occurred"。


解决措施


在编译HarmonyOS C++ 项目时，遇到"unknown type name"错误通常表示编译器无法识别某个类型。这可能是因为类型未定义、未包含相关的头文件，或者包含的头文件路径不正确。以下是定位和解决这个问题的步骤：


1. 检查是否包含头文件。


确保所有必要的头文件都已正确包含在源文件中。例如，如果您正在使用某个自定义类型或库提供的类型，请确保在使用该类型的文件中包含了相关的头文件。


示例：


```less
// main.cpp
#include "myLibrary.h" 
int main() {
     MyType obj;
     // 使用自定义类型
     return 0;
}


// myLibrary.h
#ifndef MY_LIBRARY_H
#define MY_LIBRARY_H
class MyType {
public:
     MyType() {}
     void doSomething();
};
#endif
```


2. 检查头文件路径。


确保CMakeLists.txt中正确设置了头文件的搜索路径。可以通过include_directories添加头文件目录。


示例CMakeLists.txt：


```less
cmake_minimum_required(VERSION 3.10) 
project(MyProject)  
set(CMAKE_CXX_STANDARD 17)  
# 添加头文件目录
include_directories(${CMAKE_SOURCE_DIR}/include)  
# 添加源文件
add_library(myProgram SHARED src/main.cpp src/myLibrary.cpp) 
```


3. 清理和重新生成构建文件。


有时，构建文件可能会损坏或丢失符号定义。尝试清理构建目录并重新生成构建文件：


```less
hvigorw clean
```


或手动删除模块下.cxx目录。


4. 启用详细编译输出。


为了解详细的编译过程，可以启用更详细的输出。在 CMakeLists.txt 中添加以下内容：


```less
set(CMAKE_VERBOSE_MAKEFILE ON) 
```


5. 检查编译输出日志。


Ninja 默认生成 .ninja_log 文件，其中包含构建过程的详细信息。你可以检查这个日志文件以了解构建过程中的问题。


```less
cat .cxx/default/default/arm64-v8a/.ninja_log
```


6. 使用 CMake 的 message 函数调试。


可以在 CMakeLists.txt 文件中添加 message 函数来打印一些调试信息，以确保路径和变量正确设置。


示例：


```less
message(STATUS "Source directory: ${CMAKE_SOURCE_DIR}") 
message(STATUS "Include directories: ${CMAKE_INCLUDE_PATH}") 
```


结论


通过上述步骤，您可以定位和解决 unknown type name 问题。在使用 CMake、Ninja 和 LLVM 编译 C++ 项目时，确保所有头文件正确包含并设置正确的头文件路径是关键。如果问题依旧存在，详细的编译输出日志通常能提供更多线索，帮助您找到具体的原因。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-118
爬取时间: 2025-05-08 07:39:02
来源: Huawei Developer


问题现象


在mac上，通过直接打开dmg中的DevEco Studio图标打开DevEco Studio，构建报错 The path XX is not writable. please choose a new location.”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161149.73250521318157689665907044574828:50001231000000:2800:C38D4E82F484CA7997286D2FBF352CC1DB42D328D76454B20199082E12E500C0.png)

问题原因


在mac上直接打开dmg 中DevEco Studio图标进入DevEco Studio，是会以只读的方式打开的，内置到DevEco Studio里面的文件是没有写权限的。


解决措施


将“DevEco-Studio.app”拖拽到“Applications”中，先安装再使用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-119
爬取时间: 2025-05-08 07:39:11
来源: Huawei Developer


问题现象


编译报错“The useNormalizedOHMUrl settings of packages xxx and the project useNormalizedOHMUrl: xxx do not match”。


解决措施


useNormalizedOHMUrl为true的时候ohmurl使用的是新的拼接和解析方式，不能和旧的ohmurl混用，会导致运行时无法识别。


可采用以下两种方式解决该问题：


```less
{
  "app": {
    "products": [
      {
         "buildOption": {
           "strictMode": {
             "useNormalizedOHMUrl": true
           }
         }
      }
    ]
  }
}
```

- 如果与工程不一致的依赖包较多，建议修改工程的工程级build-profile.json5中的useNormalizedOHMUrl值以及替换其它的不一致的依赖包。

如果修改了useNormalizedOHMUrl仍无法解决，表明当前hsp包是本地包，需要以本地hsp包的形式引入，请在工程下的build-profile.json5中的modules中添加报错hsp模块，示例如下：


```less
"modules": [
  {
    name: "hsp",   // 引用的hsp包依赖
    srcPath: "../MyApplication_stageB/hsp",   // 引用的hsp包的路径（绝对和相对都可以）
  }
]
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-120
爬取时间: 2025-05-08 07:39:21
来源: Huawei Developer


问题现象


编译报错：“Could not resolve 'xxx' from”，但'xxx'目录存在，目录下存在Index文件。


问题原因


在引用目录时，编译时自动拼接小写的index文件，而目录中是大写的Index文件，在编译大小写敏感时，找不到index文件，则报错。


解决措施


在引用'xxx'目录时，明确写明引用到'xxx/Index'文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-121
爬取时间: 2025-05-08 07:39:31
来源: Huawei Developer


问题现象


新建项目报错 Error: The hvigor depends on the npmrc file. Configure the npmrc file first。


问题原因


在用户目录下没有 .npmrc 文件。


解决措施


在用户目录下创建.npmrc文件，配置如下信息：


```less
registry=https://repo.huaweicloud.com/repository/npm/
@ohos:registry=https://repo.harmonyos.com/npm/
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-122
爬取时间: 2025-05-08 07:39:41
来源: Huawei Developer


问题现象


编译报错“ Error: 'icon' value `$media:icons` invalid value”。


```less
ERROR: Failed :entry:default@CompileResource...
ERROR: Tools execution failed.
Error: ref `$media:icons` don`t be defined.
Error: 'icon' value `$media:icons` invalid value.
at D:\project\process_profile\default\module.json
Detail: Please check the message from tools.
```


报错原因


引用的资源不存在时，编译报错指向的文件路径是build目录。


常见场景


解决方案


根据报错的资源id全局搜索此id，通过右上角查找按钮进行查找，查看报错的资源是否存在。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161149.68869432830467522582365477491330:50001231000000:2800:E615F5BA70A0DF6FA0CCE5E779455183E94AFA6D67152D032C368CD4FA83A292.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-123
爬取时间: 2025-05-08 07:39:51
来源: Huawei Developer


问题现象


编译报错“Error: cJSON_Parse failed, please check the JSON file”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161149.38200553630431472998676910380331:50001231000000:2800:7ACAC1E3B073835E2125469640A514024C7771FB3779CCEFDC0F212BC6AE62A1.png)

报错原因


module.json文件格式不正确。


常见场景


1. json文件内末尾多了逗号。


2. 根标签不是大括号{}。


解决方案


检查报错指向的json文件格式，比如是否末尾多了逗号，根标签是否为大括号{}。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-124
爬取时间: 2025-05-08 07:40:01
来源: Huawei Developer


问题现象


编译报错“Error: the name 'XXX' can only contain [a-zA-Z0-9_]”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161149.18664260615202572784440468508151:50001231000000:2800:CA321542F0F0D6733B3D1C734806E655B4C28159300D9899A984CEF5700A3044.png)

解决方案


检查文件名是否合法，文件名只能包含大小写字母、数字、下划线。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-125
爬取时间: 2025-05-08 07:40:11
来源: Huawei Developer


问题现象


当引入三方包时编译报错。


报错原因


部分三方包由npm迁移而来，其开发环境为node， 其中的require语法arkcompiler不完全支持，出现运行报错情况。


场景1：


```less
// Module/src/test.json
{a: 1, b: 2}
//use.js
let test = require("Module/src/test.json")
```


需修改为：


```less
// Module/src/test.js
module.exports = {a: 1, b: 2}
//use.js
let test = require("Module/src/test")
```


场景2：


```less
// Module/package.json
...
main: "./src"
...
// use.js
let module = require("Module")
```


需修改为：


```less
// Module/package.json
...
main: "./src/index.js"
...
// use.js
let module = require("Module")
```


场景3：


编译出现warning信息：


```less
Plugin node-resolve: preferring built-in module 'util' over local alternative at '/Users/~/Documents/fe-module/demo/node_modules/util/util.js', pass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning
```


解决方案


修改rollup 配置文件，rollup.config.js中修改 preferBuiltins 字段：


```less
plugins: [ 
  resolve({ 
    preferBuiltins: false,    // true 或 false
    mainFields: ['module', 'main'], 
    extensions
  })
];
```


场景4：


```less
import {Buffer} from 'buffer'
```


需修改为：


```less
import {Buffer} from 'buffer/'
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-126
爬取时间: 2025-05-08 07:40:21
来源: Huawei Developer


问题现象


动态调用类或者接口的字段，导致编译报错出现：Indexed access is not supported for fields(arkts-no-props-by-index)。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161149.57409074262262976835271120759826:50001231000000:2800:724D5036CAE23854927AB292F802557287E5784A476743FB7D9308AC2E2B3CB5.png)

解决方案


修改代码：


```less
getValue(breakpoint: string): T {
    return Reflect.get(this.options, breakpoint) as T;
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-127
爬取时间: 2025-05-08 07:40:31
来源: Huawei Developer


问题现象


在不同的文件中声明相同变量或者interface、enum等类型，DevEco Studio不报错，但是编译报错。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161149.87623437773121027844254857083430:50001231000000:2800:AF01A35A5A8CD9A3F231E7F47F745690734B7B9419FA1E4FD3A42D0DC5898058.png)

解决方案


如果文件中不包含export关键字，该文件将视作全局命名空间的一部分，相当于两个文件实质为同一个文件。请添加export关键字使其成为独立命名空间，或者将声明的内容添加到自定义的命名空间中。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-128
爬取时间: 2025-05-08 07:40:40
来源: Huawei Developer


问题现象


编译报错"The inferred type of 'xxx' cannot be named without a reference to 'xxx'. This is likelynot portable. A type annotation is necessary"。


问题原因


HSP会生成.d.ts声明文件，由于原始文件中未注明类型，导致生成的.d.ts文件缺少类型注解。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161149.41055691171312534372035764311797:50001231000000:2800:C16126974A32579B257A6343F0FB8EF61492625F4077B39C5DFDC4A0B8D356E9.png)

解决方案


报错位置添加类型注解。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-129
爬取时间: 2025-05-08 07:40:49
来源: Huawei Developer


问题现象


编译报错"arkts-no-any-unknown" 和 "Cannot find module 'xx' or its corresponding type declarations"。


问题原因


大小写敏感导致模块找不到。常见于图片中的两种错误同时出现，且仅在Linux系统出现，win/mac不报错。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161150.41371463067497643006951166268980:50001231000000:2800:1C0FEBDA4FF99082EC8152575F391E6759ECA659BB61305B3ED82E445BB41463.png)

解决方案


解决引用中的大小写问题。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-130
爬取时间: 2025-05-08 07:40:59
来源: Huawei Developer


问题现象


编译报错“ERROR: ArkTS Compiler Error ERROR: /bin/sh: "xxxx/es2abc": Operation not permitted”。


问题原因


由于获取SDK的方式是从网络上下载，mac的安全设置会给可执行文件添加来源于网络的标识（com.apple.quarantine），导致无法执行。


解决方案


执行命令删除可执行文件的com.apple.quarantine标识。


```less
xattr -d com.apple.quarantine /path/to/es2abc
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-131
爬取时间: 2025-05-08 07:41:08
来源: Huawei Developer


问题现象


编译报错“Cannot add xxxx items to index”。


问题原因


被编译文件中某函数内部有大量object literal, array literal和string，导致item的数量超过了上限（65536）。


解决方案


排查相关文件，将存在上述原因的函数进行拆分。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-132
爬取时间: 2025-05-08 07:41:18
来源: Huawei Developer


问题现象


在升级DevEco Studio至5.0.3.403版本后，打开旧工程概率性报错：resource busy or locked, open 'xxx\outputs\build-logs\build.log'。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161150.51821960733369257261915852770066:50001231000000:2800:D432B4F3D47E33E378FC4EAD06A290293945835E689C62D6EDD8E9078E2D5923.png)

问题原因


初始化时日志写入存在冲突，.hvigor目录中的build-log文件被占用导致了该报错。


解决方案

- 
- 
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161150.07265184248621042189537405546051:50001231000000:2800:BCB402783D60A4B24318DCAFE97AF2F658B6FA2C301B96911F35C37585059B3A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161150.36078635211098812281988706264939:50001231000000:2800:8A8840BD03BEB4A298D75AF97458A5EF2F5BC5655241629E1B3A8D7D00DAEF20.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161150.84835732069060498833950051551592:50001231000000:2800:4E8444C9E74570D2FDC7AD12BF4FE2D38AAABC668FFA2E5F47FE6E9611BD32F2.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-133
爬取时间: 2025-05-08 07:41:28
来源: Huawei Developer


问题现象


Mac环境下，在DevEco项目开发时，build-profile.json中添加了如下的插桩配置，但是插桩功能未生效。


```json
"transformLib": "<相对模块根路径的动态库路径，以./开头>"
```


判断与验证


```less
./es2abc --merge-abc --transform-lib <动态库路径> <测试js文件路径>
```


```less
os::library_loader::Load error: dlopen(..., 0x0001): 
tried: '...' (code signature in <...> '...' not valid for use in process: mapped file has no cdhash, completely unsigned? Code has to be at least ad-hoc signed.)
```


```less
codesign -dv --verbose=1 <es2abc路径>
codesign -dv --verbose=1 <动态库路径>
```


解决方案


执行下列命令，将es2abc文件的签名替换成和动态库文件一样的用户签名。


```less
codesign --remove-signature <es2abc路径>
codesign -s - -v <es2abc路径>
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-134
爬取时间: 2025-05-08 07:41:38
来源: Huawei Developer


问题现象


声明文件没有默认导出，使用 import xxx from 'module' 在另一文件默认导入，编译不报错。


```typescript
// test.d.ts文件
export const addFunction: {
add: (a: number, b: number) => number
}
```


```less
// index.ets文件
import test from './test'


test.addFunction.add(1,2)
```


原因说明


此场景编译时不报错，原因是编译时的配置文件中开启了allowSyntheticDefaultImports选项，不仅允许没有默认导出的声明文件让另一文件默认导入，还兼容从那些使用 CommonJS（require）导出模块的库中导入默认导出（default exports），例如可以import default默认导入类似react这样的三方库。


react例：安装@type/react包，使用默认导入的方式，编译不报错。


```typescript
import React from "react"


let a: string = React.useId()
```


CommonJS例：用默认导入方式导入commonjs模块。


```less
// 编译文件
import allFunction from 'library'


allFunction.sub(1,2)
```


```typescript
// 依赖包的声明文件 index.d.ts
declare const allFunction : {
sub: (a: number, b: number) => number
}
export = allFunction
```


```less
// 依赖包的实现文件 index.js
function sub(a, b) {
return a - b
}


var allFunction = { sub }
module.exports = allFuntion
```


解决方案


如果源码文件没有默认导出，那么可以尝试使用import * as xx from 'xxx' 去导入。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-135
爬取时间: 2025-05-08 07:41:48
来源: Huawei Developer


错误描述


服务卡片文件包含一个或多个HSP模块类型的引用。


可能原因


服务卡片文件中存在对HSP模块类型的引用 。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161150.34893562926578737545329711038412:50001231000000:2800:62336E17F6D8F34474A96F0090D7D549C6D7349ABBC571FAB055E39A6F20027E.png)

解决措施


删除服务卡片文件中关于HSP类型模块的引用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-136
爬取时间: 2025-05-08 07:41:57
来源: Huawei Developer


错误描述


缺少必需属性：module-name。


可能原因

1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161150.91213021245534840806507954309340:50001231000000:2800:A2FB7CF0E3004A6BCAFB249D126794DC643B9952C468CBAAFF27600BCB22C206.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161150.69273198968675011412794289804239:50001231000000:2800:3211D16CBC92F6EBF6E35269145B6C6ADFAD83A7BEB7CFE224AE1EB207840862.png)

解决措施


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-137
爬取时间: 2025-05-08 07:42:07
来源: Huawei Developer


错误描述


缺少必需属性：module-srcPath。


可能原因


build-profile.json5文件中缺少模块的相对路径。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161150.71126904016114784396730189479223:50001231000000:2800:5FB8C719A19A45431131B3E192A859EA09CE7E9A3592D4814F626195590F7400.png)

解决措施


进入项目根目录下的build-profile.json5文件，确保module下srcPath字段存在且非空。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-138
爬取时间: 2025-05-08 07:42:16
来源: Huawei Developer


错误描述


srcPath字段配置值非相对路径。


可能原因


在hvigorconfig.ts文件中使用includeNode方法添加模块时设置的srcPath非相对路径。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161151.10079462745838155567699120619858:50001231000000:2800:FFBC6061177F49044DD94F173ACA7071629CC29B48889C10CB5E7BF295FFA554.png)

解决措施


确保项目的hvigorconfig.ts文件中使用includeNode时的传参srcPath为相对路径。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-139
爬取时间: 2025-05-08 07:42:25
来源: Huawei Developer


错误描述


hvigorfile.ts中的setProperty方法校验失败。


可能原因


在hvigorfile.ts中使用setProperty方法传入参数不符合schema校验。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161151.85188535217167477238815757053914:50001231000000:2800:203FF7DC93010C36DB583FE8C84A6309210C40A6F72C9BE1E7885EA607C017D5.png)

解决措施


请按照报错提示信息，修改hvigorfile.ts文件中的配置字段。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-140
爬取时间: 2025-05-08 07:42:35
来源: Huawei Developer


错误描述


无法解析import语句。


可能原因


import文件时大小写不一致。（import至单文件夹时默认寻址小写index.ets文件，此处文件夹下仅存在大写Index.ets文件。）

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161151.87744523660589636471834612909008:50001231000000:2800:9207D708502A96D36BFA93FCC1C62A0D4FB2A8BFB6C6E8449836AC2538B3D22F.png)

解决措施


检查import文件大小写。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-141
爬取时间: 2025-05-08 07:42:45
来源: Huawei Developer


错误描述


指定target设备的类型与模块配置的设备类型不匹配。


可能原因


指定target设备的类型与模块配置的设备类型不匹配。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161151.36986948011116288219701559218234:50001231000000:2800:7B839FFC2DD3F19181017A859B3EA79F5B493F572BC00CE11F8F0670E09ED47F.png)

解决措施


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-142
爬取时间: 2025-05-08 07:42:54
来源: Huawei Developer


错误描述


仅当兼容SDK版本为5.0.0 (12)及以上版本时，UseNormalizedOHMUrl才可以为true。


可能原因


compatibleSdkVersion为5.0.0(12)以下版本时设置useNormalizedOHMurl=true。


解决措施


检查工程级build-profile.json5的compatibleSdkVersion配置，如果compatibleSdkVersion为4.1.0(11)及之前版本，请将工程级build-profile.json5的useNormalizedOHMUrl设置为false。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-143
爬取时间: 2025-05-08 07:43:03
来源: Huawei Developer


错误描述


模块内添加本地依赖项无效。


可能原因


设置"harLocalDependencyCheck": true时，har模块添加模块外依赖。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161151.37361639961498935154262893376075:50001231000000:2800:57B32B9096DF782A836897E42BFEA963CEF8B29E63792FCBD80D28328F46E90F.png)

解决措施


设置"harLocalDependencyCheck": true时，确保模块的oh-package.json5文件中，在dependencies和dynamicDependencies下指定的本地依赖都在当前模块目录下。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-144
爬取时间: 2025-05-08 07:43:14
来源: Huawei Developer


错误描述


依赖名与包名不一致。


可能原因


依赖名与依赖包的oh-package.json5中的name不一致。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161151.07634292566418158232647772639875:50001231000000:2800:B6568FF2B86A70E6CDD7BC98F73B0C3CE257803703BFC9F9BBB5C57D40E4465C.png)

解决措施


将依赖名修改为依赖包在oh-package.json5中定义的name。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-145
爬取时间: 2025-05-08 07:43:23
来源: Huawei Developer


错误描述


parameterFile中的本地依赖不存在。


可能原因


parameterFile中定义值实际不存在。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161151.61810502274338659530103666354056:50001231000000:2800:5ED8DA39F526E4A1C29F720ED8F9C020239EC803EB4030AB4230599635345250.png)

解决措施


检查本地依赖路径是否存在；检查本地依赖路径是否区分大小写。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-146
爬取时间: 2025-05-08 07:43:33
来源: Huawei Developer


错误描述


无效的卡片名称。


可能原因


使用意图框架，在insight_intent.json中配置了不存在的服务卡片formName,  formName必须包含在form_config.json已配置的forms中。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161151.34198349662571625158929386752813:50001231000000:2800:033EDEA6A3FC0782D0D6F01AE0FD87B1324F5B12A894C4D3DD0F3438AA600207.png)

解决措施


修改insight_intent.json中的form配置，确保formName包含在form_config.json文件已配置的forms中。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-147
爬取时间: 2025-05-08 07:43:43
来源: Huawei Developer


错误描述


资源文件“string.json”缺少必需的属性“string”。


可能原因


hap模块依赖的hsp或har包中的资源文件string.json缺少必需的属性“string”。


解决措施


确保hsp或har文件中的“string.json”包含名为“string”的属性。


示例：


```less
{
  "string": [
    {
      "name": "shared_desc",
      "value": "description"
    }
  ]
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-148
爬取时间: 2025-05-08 07:43:53
来源: Huawei Developer


错误描述


在xxx文件中存在无效的tag标签"xxx"。


可能原因


在项目根目录oh-package.json5中定义的parameterFile参数配置文件中配置版本号时，使用的tag标签存在不符合要求的字符。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161152.82361617641220404904995615688268:50001231000000:2800:BC4C7419D578A07DC53F7BFBFB08B2E6E3AE925ACF350E39365E087A3D81A59B.png)

解决措施


确保parameterFile中定义的tag标签只能由字母、数字、“.”、“-”或“_”组成，必须以字母或数字开头，长度不超过60个字符，且不能配置为'latest'。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-149
爬取时间: 2025-05-08 07:44:02
来源: Huawei Developer


错误描述


oh-package.json5的version字段不允许使用tag标签。


可能原因


使用parameterFile参数化配置版本号时，oh-package.json5中的version字段不允许使用tag标签。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161152.30316854227331197455487073422649:50001231000000:2800:9B071EFAF955F9F899A06314E0CA335B8E43D2CA677ED4AD7BF7C9E0CB0FB73A.png)

解决措施


oh-package.json5中的version字段引用parameterFile时，不使用tag标签。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-150
爬取时间: 2025-05-08 07:44:12
来源: Huawei Developer


错误描述


找不到module.json5文件。


可能原因


模块下module.json5文件缺失。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161152.18143505889995325861650486855188:50001231000000:2800:3F6031E840EB1A61BC59A102E52AE998A170976F3411D24528AA6C4DB87B4AAE.png)

解决措施


Stage模型项目中，确保模块下存在module.json5文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-151
爬取时间: 2025-05-08 07:44:22
来源: Huawei Developer


错误描述


模块的名称必须是string类型。


可能原因


模块下oh-package.json5中配置的模块名name字段，配置值非string类型。


解决措施


模块下oh-package.json5中配置的模块名name字段，修改配置值为string类型。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-152
爬取时间: 2025-05-08 07:44:32
来源: Huawei Developer


错误描述


模块的版本号必须为string类型。


可能原因


模块下oh-package.json5中配置的模块版本号version字段，配置值非string类型。


解决措施


模块下oh-package.json5中配置的模块版本号version字段，修改配置值为string类型。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-153
爬取时间: 2025-05-08 07:44:42
来源: Huawei Developer


错误描述


FA模型的项目不允许依赖外部项目模块。


可能原因


FA模型的项目在build-profile.json5中，srcPath字段依赖了外部项目模块。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161152.76430941367775039171285816358955:50001231000000:2800:F3DF01E9C26D33D291CC6E1D21AAAF338D62179A0109E144A871651F943C6EC0.png)

解决措施


项目根目录build-profile.json5中，移除srcPath字段依赖的外部项目模块。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-154
爬取时间: 2025-05-08 07:44:52
来源: Huawei Developer


错误描述


Stage模型的项目不允许依赖FA模型的模块。


可能原因


Stage模型的项目根目录下build-profile.json5中srcPath字段引入了FA模型的工程模块。


解决措施


项目根目录下build-profile.json5移除对FA模型的工程模块的引用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-155
爬取时间: 2025-05-08 07:45:01
来源: Huawei Developer


错误描述


不能依赖项目外的HAP模块。


可能原因


项目根目录下build-profile.json5中srcPath字段依赖了项目外的HAP模块。


解决措施


使用HSP或HAR模块代替项目外的HAP模块。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-156
爬取时间: 2025-05-08 07:45:10
来源: Huawei Developer


错误描述


ohpm安装依赖失败。


可能原因


网络不通，或ohpm镜像仓库地址、oh-package.json5中依赖的包名、版本号不正确。


解决措施


请检查网络，或ohpm镜像仓库地址、oh-package.json5中依赖的包名、版本号是否正确。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-157
爬取时间: 2025-05-08 07:45:19
来源: Huawei Developer


错误描述


parameterFile中存在无法识别的格式。


可能原因


使用parameterFile参数化配置的本地依赖既不是目录，也不是har/tgz文件。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161152.85092706912885253331598164811952:50001231000000:2800:8F9B2D578E3256E2AF1D826386EB243EB7B6274706DD0B528DDDDAC4B44DBCDA.png)

解决措施


本地依赖修改为模块的目录或者模块编译后的har/tgz文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-158
爬取时间: 2025-05-08 07:45:28
来源: Huawei Developer


错误描述


针对Hap模块，配置user_grant权限必须有reason和usedScene属性。


可能原因


在module.json5文件中配置user_grant类型的权限缺少reason或usedScene属性。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161152.75018852857075679617280916125280:50001231000000:2800:08262B7267A1DCB4217FBB57F7D3D9072E980423F4B373E7743DF56C185EAC48.png)

解决措施


对于hap模块，在module.json5文件的requestPermissions中添加reason和usedScene字段。


对于har/hsp模块，在module.json5文件的requestPermissions中添加reason字段。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-159
爬取时间: 2025-05-08 07:45:38
来源: Huawei Developer


错误描述


针对Har和Hsp模块，配置user_grant权限必须有reason属性。


可能原因


在module.json5文件中配置user_grant类型的权限缺少reason属性。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161152.00079405422718087314888408475553:50001231000000:2800:888AD740C0B4138E10A3112A6F32B8954F2E35A785D998093ACE88F2D3011498.png)

解决措施


对于hap模块，在module.json5文件的requestPermissions中添加reason和usedScene字段。


对于har/hsp模块，在module.json5文件的requestPermissions中添加reason字段。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-160
爬取时间: 2025-05-08 07:45:47
来源: Huawei Developer


错误描述


CMake任务执行失败。


可能原因


用户手动删除编译后模块的.cxx目录，并且在build-profile.json5中arguments字段下配置“--version”参数。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161153.52206493950666513693155333263235:50001231000000:2800:499BA01BC7F21C3B0692880A93D0D6C4C16248FF210A88FE729CFDAF600B4BC0.png)

解决措施


删除arguments字段下的“--version”参数。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-161
爬取时间: 2025-05-08 07:45:56
来源: Huawei Developer


错误描述


存在重复名称的routerMap配置。


可能原因


当前模块的router_map.json中存在name重复的routerMap配置，或者当前模块与依赖模块存在name重复的routerMap配置。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161153.83015739286692702179037234915991:50001231000000:2800:1D9923D98B9D77E82FE8A67B66C7D8A1C494A166BAF940ECBEF77CA6D75D176C.png)

解决措施


修改router_map.json文件中的name字段，保证name的值唯一。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-162
爬取时间: 2025-05-08 07:46:05
来源: Huawei Developer


错误描述


找不到模块类型。


可能原因


在FA模型中，config.json文件中的module/distro/moduleType字段缺失或者配置错误。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161153.61125710953511451472944066922080:50001231000000:2800:56B6CDDAB2F5301760A4EFF4DF94A78EB3DD7BEA80BBF5287FFE396068804855.png)

解决措施


确保模块在FA模型中，config.json文件中的module/distro/moduleType字段存在并且配置正确。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-163
爬取时间: 2025-05-08 07:46:15
来源: Huawei Developer


错误描述


requestPermissions下的权限必须是SDK中预定义的值，或者是在definePermissions下包含的自定义值。


可能原因


在module.json5文件的requestPermissions中配置name时，配置了不存在的权限名称。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161153.89275235789393571612302710257770:50001231000000:2800:C44DDE6431DFCB824287DF38DDF3304653A35AD156C375CE7D122F90285D1A90.png)

解决措施


在module.json5文件的requestPermissions中配置name字段，必须是SDK中预定义的权限，或者在definePermissions下自定义的权限。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-164
爬取时间: 2025-05-08 07:46:24
来源: Huawei Developer


错误描述


FormExtensionAbility中的metadata字段不能为空或空数组。


可能原因


module.json5中type为form的ExtensionAbility中的metadata字段为空或者空数组。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161153.04089998657616732591023585050978:50001231000000:2800:2690E037579CDA0E5D909927521B684674C10B253094C32002CB25CB5A4B2723.png)

解决措施


在module.json5中type为form的ExtensionAbility中配置metadata字段，具体配置方式参考配置卡片的配置文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-165
爬取时间: 2025-05-08 07:46:33
来源: Huawei Developer


错误描述


在FormExtensionAbility中，metadata必须包含一个对象，其名称设置为“ohos.extension.form”，资源设置为二级资源引用。


可能原因


module.json5中type为form的ExtensionAbility中的metadata缺少name为ohos.extension.form’的对象值，或者缺少resource字段。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161153.15994861300300319345210795448349:50001231000000:2800:A46686AA346C88B8D0E8143C6FC94029D6B82AA1CBC6010B94D1A12E9BF24660.png)

解决措施


在module.json5中type为form的ExtensionAbility中增加metadata字段，补充一个name为‘ohos.extension.form’的对象值，并配置对应的resource值，具体配置方式参考配置卡片的配置文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-166
爬取时间: 2025-05-08 07:46:43
来源: Huawei Developer


错误描述


useNormalizedOHMUrl配置为false的情况下不支持编译字节码HAR。


可能原因


HAR模块的build-profile.json5的byteCodeHar字段配置为true的情况下，工程级build-profile.json5中的useNormalizedOHMUrl未配置为true。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161153.11601637795814540781227519397024:50001231000000:2800:39BB63ED6F93E7F73D241C81F20958FE6A82D4C4F987F142D74ABEE13FD2F7CD.png)

解决措施


HAR模块的build-profile.json5的byteCodeHar字段配置为true的情况下，工程级build-profile.json5中的useNormalizedOHMUrl需要配置为true。


参考链接


build-profile.json5


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-167
爬取时间: 2025-05-08 07:46:52
来源: Huawei Developer


错误描述


'Module-Abilities' 对象的名称重复。


可能原因


依赖的har中module.json5的abilities数组的ability对象存在重复name。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161153.91929048429908428176336002465015:50001231000000:2800:0D706F34400AD9730372A7AFCEEE1DACDE3676102EEDE59CCAD59AC160144A9D.png)

解决措施


检查依赖har模块的module.json5中的abilities字段是否存在相同name，确保依赖的每个ability是唯一的。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-169
爬取时间: 2025-05-08 07:47:02
来源: Huawei Developer


解决措施


方案一：适用于Har文件较少的场景，直接修改字段byteCodeHar为false，详细字段可在以下链接中查询：模块级build-profile.json5


方案二：适用于Har文件较多的场景，单独为每个Har包配置太过繁琐，可以通过自定义插件直接修改所有Har包字段byteCodeHar的值。该方法会在编译的时候生效，但并不会修改build-profile.json5文件中的字段值。


```less
// 工程级hvigorfile.ts文件
import { hvigor, HvigorNode, HvigorPlugin } from '@ohos/hvigor';
import { appTasks, OhosHarContext, OhosPluginId, Target } from '@ohos/hvigor-ohos-plugin';
// 实现自定义插件
export function customPlugin(): HvigorPlugin {
  return {
    pluginId: 'customPlugin',
    async apply(currentNode: HvigorNode): Promise<void> {
      hvigor.afterNodeEvaluate(async () => {
        // 注册模块级任务
        harTask(currentNode);
      });
    }
  };
}
function harTask(currentNode: HvigorNode) {
  currentNode.subNodes((node: HvigorNode) => {
    const context = node.getContext(OhosPluginId.OHOS_HAR_PLUGIN)
    context?.targets((target: Target) => {
      const targetName = target.getTargetName();
      node.registerTask({
        // 任务名称
        name: `HarTask`,
        // 任务执行逻辑主体函数
        run() {
          if (context.getBuildProfileOpt) {
            const buildProfile = context.getBuildProfileOpt();
            console.log(buildProfile)
            // 设置字节码har配置为false
            buildProfile["buildOption"] = { arkOptions: { byteCodeHar: false } };
            console.log(buildProfile)
            context.setBuildProfileOpt(buildProfile);
          }
        },
        // 配置前置任务依赖
        dependencies: [`${targetName}@PackageHar`],
        // 配置任务的后置任务依赖
        postDependencies: ['assembleHar']
      });
    });
  });
}
export default {
  system: appTasks,  /* Built-in plugin of Hvigor. It cannot be modified. */
  plugins:[customPlugin()]  /* Custom plugin to extend the functionality of Hvigor. */
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-179
爬取时间: 2025-05-08 07:47:12
来源: Huawei Developer


问题现象


在.ts文件中，按照编辑器修复建议使用"import { export } from 'xxx.so';"的方式导入.so文件后，编译告警（Currently module for 'xxx.so' is not verified. If you're importing napi, its verification will be enabled in later SDK version. Please make sure the corresponding .d.ts file is provided and the napis are correctly declared.）并出现相关类型报错。


问题原因


若使用"import { export } from 'xxx.so';"方式导入.so文件，编译器不会对.so文件中的变量、属性或方法进行解析，类型均为any，因此出现告警。


解决措施


方案一：当使用从.so文件中引入的变量、属性、方法时，通过类型断言的方式给定义的变量、属性等赋予确定的类型。


方案二：若.so文件与.ts文件同时存在于同一个模块中，可以通过相对路径的方式引入.so文件。例如："import { export } from './index';"，其中当前文件与.so的实际入口文件index位于同一目录下。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-180
爬取时间: 2025-05-08 07:47:22
来源: Huawei Developer


问题现象


构建HSP模块时报错：Ohos BundleTool [Error]: hsp has home ability;Ohos BundleTool [Error]: CompressEntrance::main exit, verify failed.

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161153.40307052896254826860625180908825:50001231000000:2800:88ECAE59BEDC8333FE2D13C92E12D5A01DD4B06160F3166431A9559C3698E70B.png)

问题原因

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.16236730138759055932561592142724:50001231000000:2800:412158E01AEEAE46FDA673200F400F2DA92BFBD57452085187CC99F6BF7DF420.png)

解决措施


```less
// HSP模块hvigorfile.ts
import { hspTasks,OhosPluginId, Target } from '@ohos/hvigor-ohos-plugin';
import { hvigor, HvigorNode, HvigorPlugin,FileUtil } from '@ohos/hvigor';
export function customPlugin():HvigorPlugin {
    return {
        pluginId: 'customPlugin',
        context() {
            return {
                data: 'customPlugin xxx'
            };
        },
        apply(currentNode:HvigorNode): Promise<void> {
            hvigor.nodesEvaluated(async () => {
                hspTask(currentNode);
            });
        }
    }
}
function hspTask(currentNode: HvigorNode) {
    // 获取hsp模块上下文信息
    const hspContext = currentNode.getContext(OhosPluginId.OHOS_HSP_PLUGIN) as OhosHspContext;
    hspContext?.targets((target: Target) => {
        const targetName = target.getTargetName();
        const outputPath = target.getBuildTargetOutputPath();
        const task = currentNode.getTaskByName(`${targetName}@GeneratePkgModuleJson`);
        currentNode.registerTask({
            // 任务名称
            name: `${targetName}@changeModuleJson`,
            // 任务执行逻辑主体函数
            run() {
                const moduleJson = FileUtil.readJson5(outputPath+"/../../intermediates/package/"+targetName+"/module.json");
                const abilities = moduleJson['module']['abilities'];
                abilities.forEach((ability)=>{
                    delete ability['skills'];
                })
                console.log('begin to rewrite module.json file.');
                moduleJson['module']['abilities'] = abilities
                FileUtil.writeFileSync(outputPath+"/../../intermediates/package/"+targetName+"/module.json",JSON.stringify(moduleJson));
            },
            // 配置前置任务依赖
            dependencies: [`${targetName}@GeneratePkgModuleJson`],
            // 配置任务的后置任务依赖
            postDependencies: [`${targetName}@PackageSharedHar`]
        });
    });
}
export default {
    system: hspTasks,  /* Built-in plugin of Hvigor. It cannot be modified. */
    plugins:[customPlugin()]         /* Custom plugin to extend the functionality of Hvigor. */
}
```


```less
// HSP模块hvigorfile.ts
import { hspTasks,OhosPluginId, Target } from '@ohos/hvigor-ohos-plugin';
import { hvigor, HvigorNode, HvigorPlugin,FileUtil } from '@ohos/hvigor';
export function customPlugin():HvigorPlugin {
    return {
        pluginId: 'customPlugin',
        context() {
            return {
                data: 'customPlugin xxx'
            };
        },
        apply(currentNode:HvigorNode): Promise<void> {
            hvigor.nodesEvaluated(async () => {
                hspTask(currentNode);
            });
        }
    }
}
function hspTask(currentNode: HvigorNode) {
    // 获取hsp模块上下文信息
    const hspContext = currentNode.getContext(OhosPluginId.OHOS_HSP_PLUGIN) as OhosHspContext;
    hspContext?.targets((target: Target) => {
        const targetName = target.getTargetName();
        const outputPath = target.getBuildTargetOutputPath();
        const task = currentNode.getTaskByName(`${targetName}@GeneratePkgModuleJson`);
        currentNode.registerTask({
            // 任务名称
            name: `${targetName}@changeModuleJson`,
            // 任务执行逻辑主体函数
            run() {
                const moduleJson = FileUtil.readJson5(outputPath+"/../../intermediates/package/"+targetName+"/module.json");
                const abilities = moduleJson['module']['abilities'];
                abilities.forEach((ability)=>{
                    delete ability['skills'];
                })
                console.log('begin to rewrite module.json file.');
                moduleJson['module']['abilities'] = abilities
                FileUtil.writeFileSync(outputPath+"/../../intermediates/package/"+targetName+"/module.json",JSON.stringify(moduleJson));
            },
            // 配置前置任务依赖
            dependencies: [`${targetName}@GeneratePkgModuleJson`],
            // 配置任务的后置任务依赖
            postDependencies: [`${targetName}@PackageSharedHar`]
        });
    });
}
export default {
    system: hspTasks,  /* Built-in plugin of Hvigor. It cannot be modified. */
    plugins:[customPlugin()]         /* Custom plugin to extend the functionality of Hvigor. */
}
```


```less
// HSP模块hvigorfile.ts
import { hspTasks,OhosPluginId, Target } from '@ohos/hvigor-ohos-plugin';
import { hvigor, HvigorNode, HvigorPlugin,FileUtil } from '@ohos/hvigor';
export function customPlugin():HvigorPlugin {
    return {
        pluginId: 'customPlugin',
        context() {
            return {
                data: 'customPlugin xxx'
            };
        },
        apply(currentNode:HvigorNode): Promise<void> {
            hvigor.nodesEvaluated(async () => {
                hspTask(currentNode);
            });
        }
    }
}
function hspTask(currentNode: HvigorNode) {
    // 获取hsp模块上下文信息
    const hspContext = currentNode.getContext(OhosPluginId.OHOS_HSP_PLUGIN) as OhosHspContext;
    hspContext?.targets((target: Target) => {
        const targetName = target.getTargetName();
        const outputPath = target.getBuildTargetOutputPath();
        const task = currentNode.getTaskByName(`${targetName}@GeneratePkgModuleJson`);
        currentNode.registerTask({
            // 任务名称
            name: `${targetName}@changeModuleJson`,
            // 任务执行逻辑主体函数
            run() {
                const moduleJson = FileUtil.readJson5(outputPath+"/../../intermediates/package/"+targetName+"/module.json");
                const abilities = moduleJson['module']['abilities'];
                abilities.forEach((ability)=>{
                    delete ability['skills'];
                })
                console.log('begin to rewrite module.json file.');
                moduleJson['module']['abilities'] = abilities
                FileUtil.writeFileSync(outputPath+"/../../intermediates/package/"+targetName+"/module.json",JSON.stringify(moduleJson));
            },
            // 配置前置任务依赖
            dependencies: [`${targetName}@GeneratePkgModuleJson`],
            // 配置任务的后置任务依赖
            postDependencies: [`${targetName}@PackageSharedHar`]
        });
    });
}
export default {
    system: hspTasks,  /* Built-in plugin of Hvigor. It cannot be modified. */
    plugins:[customPlugin()]         /* Custom plugin to extend the functionality of Hvigor. */
}
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-181
爬取时间: 2025-05-08 07:47:31
来源: Huawei Developer


问题现象


Windows下编译工程出现错误，提示"Error: open 'xxx\deveco-studio\sdk\default\hms\toolchains\lib\libimage_transcoder_shared.dll' failed"，加载dll失败。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.08457373894882744495534666207763:50001231000000:2800:F21E4C70DFDE29C23699AE6A52A4A38A40F74BF5B68D9DC300FB86033EE4B6C3.png)

可能原因


1、系统在环境变量中找不到libimage_transcoder_shared.dll以及它所依赖的三方库的路径。


2、用户环境变量或者系统环境变量的某些路径下存在有权限限制或者损坏的文件无法被正常访问，并且这些路径在环境变量中的顺序排在libimage_transcoder_shared.dll的前面，系统加载dll时按顺序搜索环境变量，先访问了出错的文件。


比如用户环境变量中存在%USERPROFILE%\AppData\Local\Microsoft\WindowsApps

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.63402429269075181287119187074254:50001231000000:2800:16F9E124F01893680297F0793AAD73A6A6DDB066A7C12253FB62FF1CF1337387.png)

但该路径的文件无法正常访问

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.97655891536574586806785834378662:50001231000000:2800:1A43517103A5164C1C6B40ED744EF8124E7E38E805EF71FF89216637F016B9D5.png)

解决措施


1、将报错的路径xxx\deveco-studio\sdk\default\hms\toolchains\lib以及xxx\deveco-studio\sdk\default\openharmony\previewer\common\bin手动加入到系统环境的最前面。


2、检查用户环境变量和系统环境变量下的所有路径，确保这些路径下的文件都可以访问（可以尝试对文件进行修改，比如覆盖、压缩等，观察是否有报错），将不能访问的路径从环境变量中删除。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-182
爬取时间: 2025-05-08 07:47:41
来源: Huawei Developer


问题现象


在使用DevEco Studio推包到设备进行调试时，jscrash报错，FaultLog中显示：Error message:cannot find record '&XXX/src/main/ets/YYY&x.y.z', please check the request path.'ZZZ.abc'.

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.94032740971576852441367651891741:50001231000000:2800:41A5E6E759901365963A870B84809844DD8EA8B9F1D2AE99AEFA2AD9092D553D.png)

问题原因


应用依赖了包XXX，该XXX包在构建时使用了增量构建的方式，且同时修改了模块级oh-package.json5中的version字段，导致了XXX包中部分文件在寻址时还是用老的版本号去寻址，进而导致找不到相关文件。


解决措施


措施1：在XXX包对应工程中执行Build > Clean Project操作，再重新Build全量构建后使用。


措施2：在工程级hvigorfils.ts文件中增加插件来修复，具体步骤如下：


1）在工程根目录下新增plugin.ts文件，文件内容如下：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.11853253598492719309304437387887:50001231000000:2800:C96B630B19D8AF5DCB4522530FAAEA72C3FADA210E3A7F2E569B5464981C9883.png)

plugin.ts文件内容：


```less
import {OhosPluginId, Target} from '@ohos/hvigor-ohos-plugin';
import {hvigor, HvigorNode, HvigorPlugin} from '@ohos/hvigor';
import path from "path";
import fs from "fs";


function getLoaderJsonPath(target: Target) {
  return path.resolve(target.getBuildTargetOutputPath(), `../../intermediates/loader/${target.getTargetName()}/loader.json`);
}


function getPkgContextInfoPath(target: Target) {
  return path.resolve(target.getBuildTargetOutputPath(), `../../intermediates/loader/${target.getTargetName()}/pkgContextInfo.json`);
}


function deleteLoaderJson(target: Target) {
  const loaderJsonPath = getLoaderJsonPath(target);
  if (fs.existsSync(loaderJsonPath)) {
    fs.rmSync(loaderJsonPath);
  }
}


function deletePkgContextInfo(target: Target) {
  const pkgContextInfoPath = getPkgContextInfoPath(target);
  if (fs.existsSync(pkgContextInfoPath)) {
    fs.rmSync(pkgContextInfoPath);
  }
}


function deleteRollupCache(target: Target, buildMode: string) {
  const arkTSCompileCachePath = path.resolve(target.getBuildTargetOutputPath(),
    `../../cache/${target.getTargetName()}/${target.getTargetName()}@HarCompileArkTS/esmodule/${buildMode}/compiler.cache`);
  if (fs.existsSync(arkTSCompileCachePath)) {
    fs.rmSync(arkTSCompileCachePath, { recursive: true });
  }
}


function updateHapHspAbcVersion(subNode: HvigorNode, target: Target) {
  const task = subNode.getTaskByName(`${target.getTargetName()}@GenerateLoaderJson`);
  if (!task) {
    console.log('GenerateLoaderJson not found.');
    return;
  }
  deleteLoaderJson(target);
  deletePkgContextInfo(target);
  task.afterRun(() => {
    const pkgContextInfoPath = getPkgContextInfoPath(target);
    if (!fs.existsSync(pkgContextInfoPath)) {
      console.log('pkgContextInfo not found.');
      return;
    }
    const pkgContextInfoObj = JSON.parse(fs.readFileSync(pkgContextInfoPath).toString());
    if (!pkgContextInfoObj) {
      console.log('pkgContextInfo parse failed.');
      return;
    }
    const loaderJsonPath = getLoaderJsonPath(target);
    if (!fs.existsSync(loaderJsonPath)) {
      console.log('loaderJson not found.');
      return;
    }
    const loaderJsonObj = JSON.parse(fs.readFileSync(loaderJsonPath).toString());
    if (!loaderJsonObj) {
      console.log('loaderJson parse failed.');
      return;
    }
    for (const [key, value] of Object.entries(pkgContextInfoObj)) {
      if (!value?.version) {
        continue;
      }
      if (!loaderJsonObj.updateVersionInfo[key]) {
        loaderJsonObj.updateVersionInfo[key] = {};
      }
      loaderJsonObj.updateVersionInfo[key][key] = value.version;
    }
    fs.writeFileSync(loaderJsonPath, JSON.stringify(loaderJsonObj));
  });
}


function updateHarAbcVersion(target: Target) {
  deleteLoaderJson(target);
  deleteRollupCache(target, 'debug');
  deleteRollupCache(target, 'release');
}


// 字节码har的使用方使用此插件，在集成字节码har时，可以正确修改abc中ohmurl的版本号，保证运行时不闪退
export function updateAbcVersionPlugin(): HvigorPlugin {
  return {
    pluginId: 'updateAbcVersionPlugin',
    apply(node: HvigorNode) {
      hvigor.nodesEvaluated(() => {
        hvigor.getRootNode().subNodes(subNode => {
          let context = subNode.getContext(OhosPluginId.OHOS_HAP_PLUGIN);
          if (!context) {
            context = subNode.getContext(OhosPluginId.OHOS_HSP_PLUGIN);
          }
          if (!context) {
            return;
          }
          context.targets(target => {
            updateHapHspAbcVersion(subNode, target);
          });
        });
      });
    }
  };
}


// 字节码har的生成方使用此插件，在修改版本号之后可以增量构建出ohmurl正确的字节码har
export function updateHarAbcVersionPlugin(): HvigorPlugin {
  return {
    pluginId: 'updateHarAbcVersionPlugin',
    apply(node: HvigorNode) {
      hvigor.nodesEvaluated(() => {
        hvigor.getRootNode().subNodes(subNode => {
          const context = subNode.getContext(OhosPluginId.OHOS_HAR_PLUGIN);
          if (!context) {
            return;
          }
          context.targets(target => {
            updateHarAbcVersion(target);
          });
        });
      });
    }
  };
}
```


2）在工程级hvigorfile.ts文件中增加两个插件并执行Sync。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.67591745505486121430275340125729:50001231000000:2800:A143A76E47A8443F138EA2F7C10863D71C9133548F7212C299F55B9B8D58A06F.png)

hvigorfile.ts文件内容：


```less
import { appTasks } from '@ohos/hvigor-ohos-plugin';
import { updateAbcVersionPlugin, updateHarAbcVersionPlugin } from './plugin.ts';


export default {
    system: appTasks,  /* Built-in plugin of Hvigor. It cannot be modified. */
    plugins:[updateAbcVersionPlugin(), updateHarAbcVersionPlugin()]         /* Custom plugin to extend the functionality of Hvigor. */
}
```


3) 在Terminal终端执行以下命令后重新推包运行即可。


```less
hvigorw --stop-daemon
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.21839939223750832267612124528500:50001231000000:2800:E03BFCE3866A72F00B09A4827035B006EE174407251067068429588FCB83F110.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-compiling-and-building-183
爬取时间: 2025-05-08 07:47:50
来源: Huawei Developer


问题现象


流水线或命令行中编译报错：


问题原因

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.71595853089004146892110514556233:50001231000000:2800:36A6A5D640309A7F3FEE2EF343C12420BDBF3A78A1516CF6B3B038B73E998CD8.png)

自定义的Node.js版本过低，编译不支持低于v18.0.0的Node.js。相关配置查看搭建流水线配置文档。


解决措施


1. 确认流水线或计算机配置的Node.js的版本。Windows通过cmd或Powershell运行， Mac或Linux系统通过终端（Terminal）运行：


```less
node -v
```


查看输出：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.70877054966097041571116429155985:50001231000000:2800:683F43DF27474B7B096AE9F90273A58B3A7FA96DF0E0E8C384B62F2A9F50631B.png)

2. 如果流水线或计算机配置的Node.js的版本低于v18.0.0，推荐使用DevEco或Command Line Tool自带的Node.js包来配置系统变量。


Windows系统打开环境变量的配置，将DevEco或Command Line Tool自带的Node.js包的路径添加进系统变量的Path中。如果是通过%NODE_HOME%配置的，可以直接修改%NODE_HOME%配置的路径。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.78393474816288291368459817676598:50001231000000:2800:FA62929C8200216E3E456FA664E6F0F63CBCEFE7781035EB0B67E755BC98522D.png)

Mac或Linux系统参考搭建流水线配置文档。


DevEco的自带的Node.js的路径为DevEco安装目录/DevEco Studio/tools/node。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.47315395559287342753226090649506:50001231000000:2800:01F778CFFB13ADFAA9DC5E4B9026E4B107E71E79C79264531874C6094ACA0A4C.png)

Command Line Tool自带的Node.js的路径为Command Line Tool安装路径/command-line-tools/tool/node。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.42873130488204565871800367956809:50001231000000:2800:4C2138F7D8077E67BBBC0A43B4EF95978E9DA32C85AFB9EC7F6580BDD8BAE8D9.png)

2. 将自定义的Node.js版本升级为与DevEco自带的Node.js版本一致，可以通过上述路径运行node -v查看。然后在Node.js官方网站中找到对应版本下载。此处为https://nodejs.org/dist/v18.20.1/。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161154.02092021175940148553657063833225:50001231000000:2800:8ECFBA5A312F4622110278203083A8CC3F59FBDFE1273B63FC1D5A67BE895744.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-signature-service
爬取时间: 2025-05-08 07:48:00
来源: Huawei Developer

- 登录超时说明
- 已实名认证，登录时还是提示用户需要进行实名认证
- 输入华为账号后，未出现“允许”按钮，浏览器界面无跳转
- 浏览器点击“允许”按钮后，出现登录客户端失败提示
- 点击“允许”后，浏览器提示“无法访问此网站”
- 登录时浏览器提示不安全，“你的连接不是私密连接”
- DevEco Studio在登录授权时无法弹出浏览器窗口
- 多人协作时DevEco Studio如何引用一份签名文件
- 签名后生成的material目录是干什么用的
- 打包报错提示“hap-sign-tool:error:invalid CEN header (bad signature)”
- 签名时，提示"Failed to query agreement signing records"

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-signature-service-1
爬取时间: 2025-05-08 07:48:10
来源: Huawei Developer


DevEco Studio登录的超时时长为24h，如果关闭DevEco Studio后，原来的登录状态会失效，需要重新登录授权。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-signature-service-2
爬取时间: 2025-05-08 07:48:20
来源: Huawei Developer


问题现象


在登录授权模拟器时，提示华为账号需要进行实名制认证。在账号中心查看账号的状态，显示“已实名”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161156.41192028038731975362093149348098:50001231000000:2800:B53950D11F06D4172D2BBFD3CB1714704874105EB930F95BDE335AFA5BF53A64.png)

解决措施


华为账号实名分两种，一个是账号实名认证，即上图展示的状态，还有一个是开发者实名认证。这两种实名认证方式是不一样的，模拟器的登录授权是需要开发者实名认证，请根据实名认证指导进行处理。开发者实名认证后的结果如下图所示。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161156.81246598568258510966714708183920:50001231000000:2800:E698DE926A3EA87BE2EA34D2A30121E5B1543FCEB4D8A172682263D93DFC46DC.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-signature-service-3
爬取时间: 2025-05-08 07:48:29
来源: Huawei Developer


问题现象


使用浏览器登录华为账号后，如果账号已经实名认证，但还是未出现授权的“允许”按钮，浏览器界面也未跳转或提示。


解决措施


出现该问题的原因可能是浏览器不兼容导致，模拟器登录授权在Chrome、IE11和Safari浏览器中进行过充分验证，建议您将默认浏览器设置为其中一种。

1.  如果使用Safari浏览器，点击Safari 浏览器 > 偏好设置 > 隐私，请取消浏览器的“阻止跨站跟踪”和“阻止所有Cookie”设置。
2. 
3.  如果使用Safari浏览器，点击Safari 浏览器 > 偏好设置 > 隐私，请取消浏览器的“阻止跨站跟踪”和“阻止所有Cookie”设置。
4. 
- 
-  如果使用Safari浏览器，点击Safari 浏览器 > 偏好设置 > 隐私，请取消浏览器的“阻止跨站跟踪”和“阻止所有Cookie”设置。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161156.24744181301089631128716198866065:50001231000000:2800:31C53311BF28BC571F29DF7DB6F558EC7DC7CB64B6F6AEA9C6C656712E9E46DF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161156.18800939698566456234691895634967:50001231000000:2800:5980C547FF6850584831C53C5260D53AE186AA33DD9BD6F0482861740A822668.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161156.92503843956891718965203805330233:50001231000000:2800:8FC387441F61A4E7A16E4BBE98F807CA78005FD1C1C961380BF005BC7BA01E65.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161156.82085981637941534578271837975435:50001231000000:2800:B854B577072DDACA5FBDBC48FC9C53028E98B7BA57F485BADACAC9DAFEAFD54A.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-signature-service-4
爬取时间: 2025-05-08 07:48:39
来源: Huawei Developer


问题现象


使用实名认证的华为账号登录后，点击“允许”按钮进行授权，但浏览器提示“登录HUAWEI DevEco Studio客户端失败”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161156.09399648772901260959778407891553:50001231000000:2800:6A20D4622361684EC1FFB878DCC621FE795F922F520EF261F155D641DB4AA13B.png)

解决措施


该问题可能是由于DevEco Studio的HTTP代理问题引起的。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161156.77192097762675503444849496099590:50001231000000:2800:4EA89D9EF9CFD9F733BA7629DFBA3DDC11B1AAD8DBE9573A311F7ECF9B871D7E.png)
1. 
2. 
- 如果您的网络无需代理即可访问Internet，设置了代理会影响模拟器的登录授权，请检查并将HTTP Proxy设置为“No proxy”。
- 如果您的网络需要代理访问Internet，未设置代理会影响模拟器的登录授权，请检查并将HTTP Proxy设置为“Manual proxy configuration”，设置方法可参考DevEco Studio代理设置。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161156.07067122824250070482557742495036:50001231000000:2800:2877930CC385045FDB7ED4D38409097E3DA55746C2848E44AC82B176DD36A71E.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-signature-service-5
爬取时间: 2025-05-08 07:48:49
来源: Huawei Developer


问题现象


使用浏览器登录华为账号后点击“允许”按钮，浏览器跳转至http://localhost:10101/xxx，提示“无法访问此网站”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161156.46591541970904073522760400271562:50001231000000:2800:7334693D7EDB0FDCA435DD9B12BCB8FA637188239A61678C24CFFB1CEEAC47CE.png)

解决措施


出现该问题的原因一般是登录授权过程中，DevEco Studio与华为账号之间的登录通道异常导致，如点击了DevEco Studio登录界面的Cancel按钮，或者登录过程中，DevEco Studio异常关闭。


请尝试重新登录，建议在登录过程中不要做其它操作，避免误操作。如果重新登录还是出现该界面，请根据浏览器点击“允许”按钮后，出现登录客户端失败提示解决措施，检查和设置DevEco Studio的HTTP Proxy后进行重试。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-signature-service-6
爬取时间: 2025-05-08 07:48:58
来源: Huawei Developer


问题现象


使用模拟器需要通过浏览器登录授权，浏览器提示该网站“不安全”，或者“你的连接不是私密连接”信息。


解决措施


DevEco Studio云端服务平台使用的是业界知名CA机构ACTALIS颁发的商业证书，一般主流浏览器都会预置ACTALIS公司的根证书。如果出现上述问题现象，可以通过如下措施进行解决：

1. 
2. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161156.74581816016139721852100875070714:50001231000000:2800:DB4D10E36C9C211AAB040E8E2CBED512E1288F5513F7FE990DA931831845ABDA.png)
- 已安装：请检查Actalis证书是否被禁用。
- 未安装：请前往https://www.actalis.it/area-download#下载和安装“Actalis Authentication Root CA”，安装完成后重启浏览器即可。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161156.53505551610114990589634157758058:50001231000000:2800:B8C3E862454B0D7975DB55BC5FFCCAB2E45C2EEE9602D721FA493FE25EF6BB20.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-signature-service-7
爬取时间: 2025-05-08 07:49:08
来源: Huawei Developer


问题现象


在DevEco Studio中点击登录、帮助文档时，无法弹出浏览器窗口。


解决措施


可以参考如下操作换一个浏览器：

1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161156.38513418322070766405093642676979:50001231000000:2800:0F46ADA29FB785CB5C5BB6F509CCFCDA92EE0029E7E5288EA2F2C9170B03C510.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-signature-service-8
爬取时间: 2025-05-08 07:49:18
来源: Huawei Developer


使用手动签名，并在申请调试证书和申请调试Profile文件时选择添加多个设备，就可以多人使用同一套签名，并在多个设备上调试。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-signature-service-9
爬取时间: 2025-05-08 07:49:27
来源: Huawei Developer


问题描述


通过DevEco studio上的Generate key and csr工具生成p12及csr文件时，会同时生成一个material文件夹，请问这个material文件夹是干啥用的，是签名应用时所必需的吗？


解决措施


material是DevEco Studio生成的，用于加密用户的明文密码，cer，p12是签名工具需要的签名材料，两者不是一一对应的关系


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-signature-service-10
爬取时间: 2025-05-08 07:49:36
来源: Huawei Developer


出现此报错，可能是用户unsigned的包有问题。


请尝试clean project后重新打包。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-signature-service-11
爬取时间: 2025-05-08 07:49:45
来源: Huawei Developer


问题现象


使用未实名认证的华为账号登录后，签名报错。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161157.73843375305207719467803900848690:50001231000000:2800:1EE2DC3FE2BA4FDA0F5579C9EA493ED8E4219697CF5FC9220D61286EC2DE7D11.png)

解决措施


出现该问题的原因一般是签名过程中，DevEco Studio与查询协议链接通道异常导致。


请尝试通过如下两种方式解决。


方式一：该问题可能是由于DevEco Studio的HTTP代理问题引起的，请参考配置代理。


方式二：进行开发者实名认证，具体指导可以参考实名认证指导。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running
爬取时间: 2025-05-08 07:49:54
来源: Huawei Developer

- 登录华为开发者账号后，提示需要实名认证
- 在本地模拟器中卸载应用显示成功，但实际未卸载成功
- 运行工程到本地模拟器，提示“Failed to get the device apiVersion”
- 模拟器播放本地音频文件偶现卡顿
- 模拟器时间与系统时间不一致
- 模拟器启动后，设备无法识别
- 在Windows电脑上启动模拟器，提示未开启Hyper-V
- 模拟器“设置”中或List组件分割线不清晰或不显示
- DevEco Studio本地模拟器启动时提示“The available disk space is less than the amount of space required to run the emulator. Free up some space or change the path.”
- 如何在模拟器访问mac本地http服务
- 虚拟机打开时，一直报错”无法打开“libQt5Network.5.dylib”，因为Apple无法检查其是否包含恶意软件
- 点击Device Manager，提示“找不到应用程序”
- DevEco Studio修改文件后点击run，一直没成功跑起来，run按钮一直处于禁用状态（mac环境）
- 模拟器放在后台一段时间后就卡住一直在loading状态了，cpu占用高
- 模拟器应用运行时崩溃退出
- 模拟器使用OpenGLES指令绘制图像，可能与真机存在色差
- macOS上活动监视器中显示模拟器内存偏高
- 如何增加模拟器运行内存
- Windows x86模拟器三方C/C++库使用限制
- 模拟器无法连接网络
- 使用模拟器发起https请求时如何安装数字证书
- 在应用中如何区分真机和模拟器
- 设备管理点击新建模拟器无响应
- Windows x86模拟器卡在开机界面，无法进入桌面
- Windows X86模拟器启动后无法亮屏
- 模拟器使用物理键盘无法输入中文
- 启动模拟器，提示镜像文件缺失
- 模拟器中如何管理应用的权限
- 在模拟器上运行应用，应用生成的文件在哪个目录下
- 播放音频的过程中拔插耳机后，无法继续播放音频
- 模拟器上某些视频无法正常播放
- Windows X86模拟器使用过程中调整系统屏幕缩放比，模拟器显示异常
- Windows电脑上启动模拟器，提示可申请内存不足
- 设备管理获取模板数据、下载模拟器镜像，提示网络异常

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-1
爬取时间: 2025-05-08 07:50:04
来源: Huawei Developer


问题现象


使用本地模拟器需要使用实名认证的开发者账号登录授权后才能使用，如果账号未实名认证，本地模拟器界面会提示用户需要实名认证。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161157.48788989673443429596914005229084:50001231000000:2800:D28C4007651531823F526ABB2393818C01725CA156B27F1009AEA8172FD561DA.png)

解决措施


原因可能存在以下两种情况：

- 华为账号未实名认证，请按照如下步骤进行处理。
- 刚完成实名认证，但是认证未生效，可根据步骤4清除浏览器Cookie后重试。
1. 
2. 
3. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161157.68743966762811415881807955599177:50001231000000:2800:B69A802D5C6502BD3A6D500204EF7B9A13AFC93CFE0FF576B8272A7E46F6920D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161157.62211292247972512775437800491973:50001231000000:2800:0CA29D11AF99D531305C3F7142B50C2CF90C00D25B7AF61BAE53AC0B2135C116.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161157.69520304282093512158485435388257:50001231000000:2800:95D99C7502E83056367F90BCE0F3101C9D4B491190D6FAA40C22A434B0032BFC.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-4
爬取时间: 2025-05-08 07:50:14
来源: Huawei Developer


问题现象


通过桌面菜单卸载应用，显示卸载成功，但实际未卸载成功。


解决措施


出现该问题的原因是模拟器的磁盘空间已满，无法正常卸载应用。一般在频繁使用hdc file sendlocal remote命令向模拟器中推送文件后可能会出现该问题。


请尝试通过如下两种方式解决。

- 方式一：及时删除本地模拟器中不再使用的文件。可以通过hdc shell [COMMAND]命令删除相关文件，更多关于hdc命令使用指导请参考hdc使用指导。
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161157.07147933883830636741033956252318:50001231000000:2800:0B2E3CBE2D8D68C5BA8E88F00380EB453CBE381E7E837C1AD5FB63126F8CB6DF.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-5
爬取时间: 2025-05-08 07:50:25
来源: Huawei Developer


问题现象


本地模拟器已启动后，运行工程到本地模拟器，提示“Failed to get the device apiVersion”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161157.76601463191545894073260731235858:50001231000000:2800:2AE395AC7CDCAC986CD3254D150FF2C300DB51E0CD56F2B1CF68A8C0C9485227.png)

解决措施


可以通过如下方式重新运行工程：

- 在Local Emulator的设备列表窗口，点击“Wipe User Data”清除模拟器数据，然后启动模拟器后重新运行工程。
- 

```less
./hdc kill -r
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161157.28857221305986192249623483937888:50001231000000:2800:C7163CBF772046C03F5A1D7EC5CE995687A0A7F244E66ED38936CEB9384258A1.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-6
爬取时间: 2025-05-08 07:50:34
来源: Huawei Developer


问题现象


部分场景下，模拟器播放音频文件可能出现卡顿情况：


场景一：模拟器启动后，立即播放音频；


场景二：长时间使用模拟器播放音频。


解决措施：


在模拟器启动稳定后再进行音频场景测试，对于需要长时间验证音频播放的场景，建议使用真机设备。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-7
爬取时间: 2025-05-08 07:50:44
来源: Huawei Developer


问题现象


模拟器长时间运行后，可能出现显示的时间与当前实际的系统时间不一致。


解决措施


在设置中打开自动设置时间，联网情况下时间会自动同步，也可以手动设置时间。重启模拟器后时间会同步。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-8
爬取时间: 2025-05-08 07:50:54
来源: Huawei Developer


问题现象


场景一：调试运行过程中，安装HAP失败，提示“Device not founded or connected”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161157.06866613970481692546434632170529:50001231000000:2800:A8D28B9250614FA8160F10F4B9B2DCCC5C0A95BDEAB7EB6FB93B8C400B321E56.png)

场景二：DevEco Studio无法识别到已连接的设备，显示“No device”。


可能原因


hdc工具的进程或模拟器存在异常。


```less
hdc kill
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-10
爬取时间: 2025-05-08 07:51:03
来源: Huawei Developer


问题现象一


启动模拟器时，弹窗提示“未开启Hyper-V”或“Hyper-V not enabled”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161158.48690757189962044536128767773227:50001231000000:2800:48F572488456A5F53D6F3EBBE2E5422AA21121DE045CCED5E26DD6EF4EDE70FA.png)

解决措施

1. 
2. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161158.33192969637350384619847831019740:50001231000000:2800:0205B2A17BDDBE12F7F75E6A84AFE660E0BF521810B15277DAC31D40F97FA975.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161158.19213146112410838946294661118021:50001231000000:2800:2C548CD62142CAB4F01A7A978FDFD915786A5BC175E5F0BDEDBA2F9137741BA9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161158.21664599674181610488191340631250:50001231000000:2800:8383FE4A9952D78BBA43E07AF356CC7402D512FA25B6ACB0A805416647BD14FC.png)

更多关于Hyper-V安装请参考在 Windows 上安装 Hyper-V和Hyper-V 系统要求。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-11
爬取时间: 2025-05-08 07:51:13
来源: Huawei Developer


问题现象


当list组件divider中的strokeWidth为0.25vp或不足整数倍时，模拟器的分辨率不足以显示细线宽的分割线。


解决措施


真机可正常显示，若涉及分割线显示问题，建议使用真机调试；或者增大分割线宽度。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-12
爬取时间: 2025-05-08 07:51:23
来源: Huawei Developer


问题现象


启动模拟器，提示磁盘空间不足。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161158.83545766832364607539554413681562:50001231000000:2800:AEA716D01B761B7EB779C45D19BB4330A01D8E81C15CAC95FD1F39F42D93E8DE.png)

解决措施


本地模拟器默认安装在C:\Users\xxx\AppData\Local\Huawei\Emulator\deployed（macOS默认为：/Users/用户/.Huawei/Emulator/deployed），请确保磁盘可用空间大于3.6 GB；或者重新创建模拟器，并选择其它存储路径。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-15
爬取时间: 2025-05-08 07:51:33
来源: Huawei Developer


可以通过hdc shell ip -r查看映射到pc的ip地址，一般情况下是10.0.2.2。


在请求http的url中将ip替换为10.0.2.2。比如mac上http的url为http://127.0.0.1:8088/api/userinfo，对应替换后url为http://10.0.2.2:8088/api/userinfo


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-16
爬取时间: 2025-05-08 07:51:43
来源: Huawei Developer


问题描述


按教程创建后虚拟机，打不开 。虚拟机打开时，一直报错”无法打开“libQt5Network.5.dylib”，因为Apple无法检查其是否包含恶意软件。",已在设置/隐私中反复同意打开仍然不能解决。


解决方案


您好，开发者应该按照指导手册，通过DevEco Studio工具提供的unzip工具来进行 安装IDE完成后，下载对应的模拟器镜像和平台，通过Tools --> Unzip，打开IDE工具提供的解压入口，依次选择模拟器镜像和平台压缩包文件的下载路径和解压路径，进行解压操作 待解压安装完成后，启动模拟器即不会遇到上述问题。


临时解决方案，保持上面的弹窗不关闭，打开“系统偏好设置”->“安全性与隐私”->“通用”，选择仍要打开 再次启动模拟器，就可以在弹窗中选择“打开”即可。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-18
爬取时间: 2025-05-08 07:51:53
来源: Huawei Developer


问题现象


点击Device Manager进行登录授权时，提示“找不到应用程序”，无法打开浏览器进行登录

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161158.69524434181869845426595227151422:50001231000000:2800:09BDF5231D9232B3E25039E5DC4C089214661DCBC5966A03413C1BD46DCF5A53.png)

解决措施


该问题是由于默认浏览器损坏或者被卸载导致，无法打开默认浏览器。


请根据输入华为账号后，未出现“允许”按钮，浏览器界面无跳转处理指导，重新设置默认浏览器后进行登录。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-19
爬取时间: 2025-05-08 07:52:02
来源: Huawei Developer


问题描述


DevEco Studio修改文件后点击run，一直没成功跑起来，run按钮一直处于禁用状态（mac环境）


可能原因


hdc在该mac上的socket默认使用了ipv6，但是java又不支持，默认使用了ipv4，导致网口接收到了数据，但是协议层无法接收到数据。


解决方案


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-20
爬取时间: 2025-05-08 07:52:13
来源: Huawei Developer


问题描述

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161158.70004732148105012764823905711939:50001231000000:2800:EE41142F5C8091BD7823772528812E8043C7A6A0D240FFEF7A55267556F82555.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161158.81350752853543038743707071670835:50001231000000:2800:733168709D819964C3452743341900794AFEC48CF31C5380D224BAE2E01583B2.png)

打开活动检测器发现模拟器CPU占用比较高


解决措施


1.打开模拟器设备管理页面

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161158.41312145438593104249001924447146:50001231000000:2800:A6296139D0306089F242800AD7B492158088D5545369C4B42B5DD49BA1D672BB.png)

2.选择新建模拟器弹窗

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161158.63188138477805283741400422862374:50001231000000:2800:29E3B90B52E92DCB3A117DD954C1A91ABB6FD25AE87FF9B1AD484F36B35A57F9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161158.93352621941898128989169045245126:50001231000000:2800:EBEFDC793163F30921F9B96E827845FF114DE37240E321AFD709622A3CB0D7FD.png)

3.复制路径用文件夹打开system-image\HarmonyOS-NEXT-DB1\phone_x86

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161158.63456025417005567847180424088522:50001231000000:2800:908C87C129D5CAA053A6B5ADB24CF05DDAA70C5D584B5707DC50215D56E603F1.png)

4.打开features.ini文件并将bootanimation.feature.key的值改为true保存重启模拟器

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161159.27107984045406600070910201176647:50001231000000:2800:570C30EEECBDA63CAF9FBA18FE4FA50E955E209980FC2E6CB90B0F3941C9AD34.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-21
爬取时间: 2025-05-08 07:52:22
来源: Huawei Developer


问题现象


模拟器在启动调试或运行过程中应用异常退出。


解决措施

- 采用try-catch语句捕获异常代码段。
- 首先判断设备是否为模拟器（参见在应用中如何区分真机和模拟器）。针对模拟器的调试场景，使用if语句跳过异常代码段。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-22
爬取时间: 2025-05-08 07:52:32
来源: Huawei Developer


由于本地计算机所使用的OpenGL图形驱动与真机的图形驱动存在差异，部分图形接口的绘制效果无法与真机保持一致。同时，不同的显示设备也可能呈现出不同的显示效果，存在色差、饱和度的差异。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-23
爬取时间: 2025-05-08 07:52:41
来源: Huawei Developer


配置模拟器内存为4GB并使用一段时间，您可能会在活动监视器中发现模拟器进程占用了超过6GB的内存（如下图所示）。需要明确的是，图中的6.49GB并不代表模拟器进程实际使用的物理内存（即Dirty内存），而是指其占用的phys_footprint内存。在Mac系统中，针对虚拟化平台（如模拟器），普遍存在phys_footprint内存远高于Dirty内存的情况。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161159.27127921730962858691759382994940:50001231000000:2800:D4DD56734F05A88D478A8C6369AF4B70D5204F4E6B69FEDC8EC62182B7051BBF.png)

想要查看模拟器的Dirty内存，首先打开活动监视器，查看Emulator的进程号（PID）。然后通过 `footprint -vmObjectDirty 进程号` 命令可以查看Dirty内存大小。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-24
爬取时间: 2025-05-08 07:52:51
来源: Huawei Developer


问题现象


模拟器默认内存为4G，运行过程中内存不足时，可能会出现模拟器卡顿或者闪退。


解决措施


建议在创建模拟器时增加模拟器的运行内存（RAM）大小，请参考创建模拟器。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-25
爬取时间: 2025-05-08 07:53:01
来源: Huawei Developer


x86模拟器支持已x86化的C/C++三方库调试运行，未x86化的三方库开发者可以自行编译x86版本。


目前已经x86化的三方库如下：


| 三方库  | 备注  |
| --- | --- |
| @ohos/mmkv  | 自2.0.4-rc.4版本开始支持x86编译。  |
| @ohos/imageknife  | 自2.1.1版本开始支持x86编译。已经是2.1.1版本请重新安装imageknife再进行编译。  |
| @ohos/videocompressor  | 自1.0.3版本开始支持x86编译。  |
| @ohos/coap  | 自2.0.5版本开始支持x86编译。  |
| @ohos/unrar  | 自2.0.2版本开始支持x86编译。  |
| @ohos/commons-compress  | 自2.0.2-rc.0版本开始支持x86编译。  |
| @ohos/socketio  | 自2.0.0版本开始支持x86编译。  |
| @ohos/smack  | 自2.0.1-rc.0版本开始支持x86编译。  |
| @ohos/ijkplayer  | 自2.0.3-rc.0版本开始支持x86编译。  |
| @ohos/mqtt  | 自2.0.5版本开始支持x86编译。  |
| @ohos/mars  | 自2.0.1-rc.1版本开始支持x86编译。  |
| @ohos/mp4parser  | 自2.0.2-rc.0版本开始支持x86编译。  |

三方库


备注


@ohos/mmkv


自2.0.4-rc.4版本开始支持x86编译。


@ohos/imageknife


自2.1.1版本开始支持x86编译。已经是2.1.1版本请重新安装imageknife再进行编译。


@ohos/videocompressor


自1.0.3版本开始支持x86编译。


@ohos/coap


自2.0.5版本开始支持x86编译。


@ohos/unrar


自2.0.2版本开始支持x86编译。


@ohos/commons-compress


自2.0.2-rc.0版本开始支持x86编译。


@ohos/socketio


自2.0.0版本开始支持x86编译。


@ohos/smack


自2.0.1-rc.0版本开始支持x86编译。


@ohos/ijkplayer


自2.0.3-rc.0版本开始支持x86编译。


@ohos/mqtt


自2.0.5版本开始支持x86编译。


@ohos/mars


自2.0.1-rc.1版本开始支持x86编译。


@ohos/mp4parser


自2.0.2-rc.0版本开始支持x86编译。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-26
爬取时间: 2025-05-08 07:53:10
来源: Huawei Developer


问题现象


开发者打开了模拟器中的WLAN选项并已成功连接到VirtWifi，但是在模拟器中仍然无法访问网站。


解决措施


是否连接VirtWifi与模拟器能否访问互联网无关。VirtWifi仅用于在模拟器中判断WLAN的连接状态。模拟器访问网络实际上利用的是本地计算机的以太网或者WLAN，与本地计算机共享同一网络资源。如出现无法连接网络的情况，请开发者确认本地网络访问是否受到了限制（如使用公司内网）。如果对网络访问进行了限制，则需要在模拟器上配置网络代理。参见网络代理。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-27
爬取时间: 2025-05-08 07:53:19
来源: Huawei Developer


问题现象


在使用网络代理发送https请求时，有时需要安装网站服务器的数字证书。


解决措施

1.  选择从存储设备安装，选择pem格式证书进行安装。

```less
hdc shell aa start -a MainAbility -b com.ohos.certmanager
```

2. 
3.  选择从存储设备安装，选择pem格式证书进行安装。

```less
hdc shell aa start -a MainAbility -b com.ohos.certmanager
```

- 
-  选择从存储设备安装，选择pem格式证书进行安装。

```less
hdc shell aa start -a MainAbility -b com.ohos.certmanager
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161159.39059723352272795030790163383118:50001231000000:2800:90CBF47AAA3EBD344F99ED1E3C4FCF40D511D60472A67A081CC6F9E611E8081F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161159.91815964426837205055692492114709:50001231000000:2800:D7B0BCF303F2A245DE1322C666477049D0A23B3503A60E274517CBC28C927C2A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161159.11774253235944660949987304486727:50001231000000:2800:B9A4CBCE99EDFF91270EDE3F7E450701B702A1C0E7AB847E0C363746D6FBD238.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-28
爬取时间: 2025-05-08 07:53:28
来源: Huawei Developer


问题现象


在调试应用代码时，有时需要判断当前运行的设备是真机还是模拟器，如何进行区分？


解决措施


在应用中，您可以使用@ohos.deviceInfo模块的productModel属性来区分真机和模拟器。在模拟器上productModel的值为emulator。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161159.53994437482497050592608533331695:50001231000000:2800:66AD4B8457BE00AFBC294E71A663C286D6CADDC376DA57224C5B924F7205CB6A.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-29
爬取时间: 2025-05-08 07:53:38
来源: Huawei Developer


问题现象


在设备管理界面点击New Emulator按钮没有反应，无法新建模拟器。


解决措施

1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161159.36831517051062613490673623792214:50001231000000:2800:A93F950EA9327F8774CB805AE0C8884EE88E2CB3D555F0887EC3C67F3A51A7E6.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-30
爬取时间: 2025-05-08 07:53:48
来源: Huawei Developer


查看本机CPU支持的指令集（如使用业界CPU-Z工具等）。模拟器需要电脑的CPU支持AES指令集，若电脑不支持则无法使用模拟器。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-31
爬取时间: 2025-05-08 07:53:57
来源: Huawei Developer


问题现象


更新DevEco Studio后首次启动Windows X86模拟器，模拟器无法亮屏。


解决措施


建议清除模拟器中的用户数据后重新启动。关于如何清除用户数据，请参考启动和关闭模拟器。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-32
爬取时间: 2025-05-08 07:54:06
来源: Huawei Developer


问题现象


点击输入框后使用物理键盘无法输入中文。


解决措施


模拟器不支持通过物理键盘输入中文，如需输入中文，在模拟器上点击输入框时会弹出软键盘，可以使用软键盘进行中文输入。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161159.55713723255914836700153152443576:50001231000000:2800:F76921AE4808B2AFEF7C885F6C14C181A4DE8AE498D6D519ECAC3F29155D1DD2.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-33
爬取时间: 2025-05-08 07:54:15
来源: Huawei Developer


问题现象


启动模拟器失败，提示“system-image文件缺失”或“The system-image file is missing.”，模拟器镜像文件缺失。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161159.75179061446311420652624781752642:50001231000000:2800:B4736E70F432E055ABFE2540E7AFA696EC3951FF3DCA22168EED3373059A2B8A.png)

解决措施


请通过以下两种方式解决：

- 单击菜单栏的Tools > Device Manager。在Local Emulator页签，单击右下角的New Emulator按钮。在虚拟设备配置界面，更新模拟器的镜像。
- 删除已创建的模拟器，然后重新创建模拟器。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-34
爬取时间: 2025-05-08 07:54:25
来源: Huawei Developer


进入设置>应用和元服务，点击对应的应用，即可管理应用的权限。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161200.06879339230809428130078325569000:50001231000000:2800:21BA8FC63BB111E94CA9F672346C024583D45F07743C609070DE13EC10789AB2.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-35
爬取时间: 2025-05-08 07:54:35
来源: Huawei Developer


问题现象


在模拟器上运行应用，应用的沙箱路径和真实的物理路径不一致，导致找不到应用文件。


解决措施


在模拟器中，应用的沙箱路径和真实物理路径存在对应关系，该对应关系和真机保持一致，具体可参见应用沙箱路径和真实物理路径的对应关系。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-36
爬取时间: 2025-05-08 07:54:44
来源: Huawei Developer


问题现象


模拟器播放音频过程中，先拔掉USB接口的耳机，随后再将耳机插上，导致音频播放功能不可用。


解决措施


模拟器不支持耳机的热插拔，请不要在播放音频的过程中拔插耳机。如果插拔耳机后无法播放音频，请重启模拟器。也可以使用圆孔接口耳机来避免此问题。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-37
爬取时间: 2025-05-08 07:54:54
来源: Huawei Developer


问题现象


模拟器播放视频过程中，有时候会出现视频有声音无画面，或播放卡顿的现象。


解决措施


由于模拟器目前仅支持RGBA格式的像素显示，请确保视频解码格式正确。此外，由于模拟器只支持软件解码，如果视频解码器依赖硬件解码能力，也可能导致视频无法正常播放。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-38
爬取时间: 2025-05-08 07:55:03
来源: Huawei Developer


问题现象


打开模拟器，在Windows的设置选项中调整屏幕缩放比例，模拟器屏幕出现黑边，工具栏布局混乱，边框被截断。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161200.08353880777008494214993398785306:50001231000000:2800:68B8CE7CE4D64C48146BE3B49048A517CD7BCFCDD34ACE34752446DA6DA90205.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161200.68158418781539384718892807269461:50001231000000:2800:CD90563052E5B28ACA062F2B9A7F2E1EEB9DCA25E2C6B14EFA5520DC088A11E9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161200.52584875258482574497943960828410:50001231000000:2800:81B64CD8265C76C1A4F6CFD624433832802EE1D2F4D74A936130A5066AF40ED3.png)

解决措施


手动缩放模拟器即可恢复，缩放方式参见移动和缩放模拟器。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-39
爬取时间: 2025-05-08 07:55:13
来源: Huawei Developer


问题现象


Windows电脑上启动模拟器时，弹窗提示“当前系统可申请的内存不足”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161200.57639074865235650389377284490905:50001231000000:2800:BF45CFDF2B6D8CB7F1D50469F97EEC7F7DB53530260ADD520DBE40DE53FE8752.png)

解决措施

1. 
2. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161200.16720450191250642912621551545533:50001231000000:2800:566487C1478668572BC09D3BEB74C13B9207456FAD07EA7C7F88566EE43DD0CD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161200.94476101778239037702188944794842:50001231000000:2800:0C57B78ED800861E3F45C076B981F5412FE99DCD7EDCEB200D161ACAE8CAC49E.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-running-40
爬取时间: 2025-05-08 07:55:22
来源: Huawei Developer


问题现象

- 
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161200.83317159255657258934179293686861:50001231000000:2800:394301BB71D122955CBBD25800DCAAC29C64AB21497B614BA2EB9C8164FCDB17.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161200.05272267442428890402548685633832:50001231000000:2800:6A007764BA3A2969EB76433A8DFF8864E9027889EF47DABAA31C5813B2DE32C4.png)

解决措施


尝试修改本机网络环境后进行重试，例如：设置代理、连接手机热点。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging
爬取时间: 2025-05-08 07:55:32
来源: Huawei Developer

- 调试过程中无法添加断点
- 设备连接后，无法识别设备的处理指导
- 设备ROM升级至5.0.0.31及以上版本，DevEco Studio连接设备不成功，查询不到设备
- HarmonyOS应用自动化签名时提示“Provision number exceeds limit”
- HarmonyOS应用自动化签名时提示“Unsupported restricted ACL permission exist in the configuration”
- 安装HAP时提示“compatibleSdkVersion and releaseType of the app do not match the apiVersion and releaseType on the device.”
- 安装HAP时提示“error: failed to start ability”
- 安装HAP时提示“error: unlock screen failed in developer mode”
- 如何解决调试启动时，一直卡在Waiting for application to come online notification的问题
- Release应用堆栈解析相关错误提示及解决措施
- entry引用本地library时，没有ASan日志输出
- 运行时提示“Hdc server port XXXX has been used”
- 修改代码后使用Hot Reload不支持情况说明
- Hot Reload执行失败原因说明
- 启动C++调试时出现错误，提示“Failed connect to unix-abstract-connect”
- 如何使用DevEco Studio进行C/C++代码断点调试
- 如何将设备中的截屏图片导出到本地
- 应用自动签名失败，提示“calibrate the system time and sign again”
- 如何强制重启设备
- 如何在DevEco Studio每次run项目后数据持久化
- 如何解决Network单元测试用例crash问题
- Native调试无法与lldb-server连接
- DevEco Studio安装HAP时报错“FileTransfer Failed: Error while Deploy Hap”
- 升级到5.0.3.400 DevEco Studio版本 无法识别设备，hdc命令也无法识别设备
- 应用运行报错：hap path error
- Native调试堆栈可视化功能并行栈视图显示空白
- DevEco如何配置不响应raise捕获到的assert信号
- 如何保证代码修改后每次Run之后Preferences存储的用户信息不会被清除

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-1
爬取时间: 2025-05-08 07:55:41
来源: Huawei Developer


问题现象


调试过程中无法添加断点，并提示“Can't set breakpoint to remote debug server”，如下图所示。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161201.05932647808929861180622069818980:50001231000000:2800:15CBF6399C8407A4E909F7E49B37738BABF640BBEBEAEB6D8F466C1E2787021A.png)

解决措施


请通过下述方法排查原因：

- 对于stage模型工程，需检查sourceMaps.map文件是否存在。该文件由编译构建生成，位于模块中“entry\build\default\intermediates\loader_out\default”目录下，如下图所示：图1stage模型工程中sourceMaps.map文件目录
- 对于FA模型工程，需检查断点所在文件对应的map文件是否存在。该文件由编译构建生成，位于模块中“entry\build\default\intermediates\loader_out\default”目录下，如下图所示：图2FA模型工程中map文件目录
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161201.17405787847758880181715292597883:50001231000000:2800:A5D2FAD1F90C0E55C23E55012CF187924742EF053A10D8B4E3D805A9279AEB18.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161201.61574128462171274878288497068962:50001231000000:2800:5CD6A4DBDF4325824901C3B5B12E647AF7612BB3283338C9843B66E2DFD65699.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161201.62023463730954643690547648069081:50001231000000:2800:06E0B0985A32E82A24941CF01DA083B7B20C0997777E429F60B0A2CDD0253101.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161201.34059020705549297355035925016431:50001231000000:2800:3F9002D11AB44F1FA5842F564A3F7149609700D6FFB11FAF8ED4AD3DD6063474.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-3
爬取时间: 2025-05-08 07:55:51
来源: Huawei Developer


问题现象


调试运行过程中，安装HAP失败，提示“Device not founded or connected”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161201.26596031190235273589133856710713:50001231000000:2800:BB37872741E941D423BCAFFDDACB3DF248EE12D7713F931E3F32AD57531C8AC1.png)

或DevEco Studio无法识别到已连接的设备，显示“No device”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161201.67261555814077761144317702411165:50001231000000:2800:B540DA64E3889CA89F5317E1C8B678E8D5DA947FC0B7AA118EFF2DBAACC479F3.png)

解决措施


无法识别设备可能有以下原因：

-  设备未开启“开发者选项”。 解决措施 在设备上打开“开发者选项”开关，打开“USB调试”开关或“无线调试”开关。
-  设备系统与DevEco Studio版本不配套。 解决措施 务必确认版本的配套关系是否与当前所使用的开发套件是一致的，可参考版本概览使用对应的配套版本。如无真机设备，可使用Device Manager模拟器。
-  使用的USB连接线为充电线而非数据线。 解决措施 请更换为满足USB2.0标准的数据线；建议使用直连方式，不要使用拓展坞。
-  当前的USB数据口可能损坏。 解决措施 请更换另一个USB数据口后重新尝试；检查端口驱动是否正常。
-  hdc工具的进程或设备存在异常。

```less
hdc kill
```


```less
hdc kill
```

- 若按照步骤1操作后还是不能连接，请重启设备，然后尝试重新连接。
-  场景一：关闭“USB调试”开关，并且断开USB连接，重新打开“USB调试”开关。无法识别到设备。 场景二：打开“无线调试”开关后，进行无线调试连接，然后关闭“无线调试”开关后，又打开“USB调试”开关，进行USB调试。无法识别到设备。 解决措施 重启设备，连接USB，打开“USB调试”开关。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161201.64563419344237972352221697222219:50001231000000:2800:06418CDA1E645DEC3879C9FB9903B5B717B71F7C4C945925EA760030E98BA325.png)

```less
hdc kill
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-38
爬取时间: 2025-05-08 07:56:00
来源: Huawei Developer


问题现象


当开发者设备ROM升级至5.0.0.31及以上时，DevEco Studio连接设备不成功，查询不到设备。


解决措施


确认开发环境所在电脑设备的用户名是否是中文。若电脑系统登录的用户名是中文，请修改用户名为英文或者拼音后，重新尝试连接设备。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-4
爬取时间: 2025-05-08 07:56:10
来源: Huawei Developer


问题现象


使用自动化签名功能对HarmonyOS进行签名时，提示“Provision number exceeds limit”信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161201.31700731998387459591353757968554:50001231000000:2800:0EB5367927F47DF5EBA24F2764752F8B4C8F4E327130EA69F60D2001FC6B19F5.png)

解决措施


该问题的原因是AGC（AppGallery Connect）对自动化签名使用次数有限制，同一个开发者账号，在最近30天使用自动化签名功能使用次数不能超过150次。

- 方法1：建议相同BundleName的应用，如果设备无变化，请使用同一套签名文件信息，不要反复进行重签名操作。
- 方法2：更换其它开发者账号进行登录，然后进行签名。
- 方法3：AGC限制同一个账号，在近30天使用自动化签名的次数不能超过150次。因此，可以等待一段时间后，重新使用该账号进行签名。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-5
爬取时间: 2025-05-08 07:56:19
来源: Huawei Developer


问题现象


在对HarmonyOS应用工程中，勾选“Automatically generate signature”时，提示“Unsupported restricted ACL permission exist in the configuration”报错信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161201.58521851529635748634622201582272:50001231000000:2800:1B77EBAABF93C6C24A5453F58660BEC4B1D720FC3F441AC64EAAF6AC10286CB7.png)

解决措施


出现该问题的原因是当前DevEco Studio自动签名只支持部分的ACL权限，当前工程中使用了不在支持范围之内的ACL权限，可尝试进行手动签名，请参考HarmonyOS应用/元服务手动签名指导。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-22
爬取时间: 2025-05-08 07:56:28
来源: Huawei Developer


问题现象


在启动调试或运行应用/服务时，安装HAP出现错误，提示“compatibleSdkVersion and releaseType of the app do not match the apiVersion and releaseType on the device.”错误信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161201.90342971720933670677534021552734:50001231000000:2800:6AF456EDCFBBECBF8C7E1EC551E330A4CC42813C7BCF1944989C403BB4F433E8.png)

解决措施


出现该问题是因为当前工程的兼容的最低版本高于设备镜像版本。


使用命令hdc shell param get const.ohos.apiversion查询当前设备的api版本，对比看下工程级build-profile.json5配置的compatibleSdkVersion字段api版本。可以使用以下解决办法：


方法一：请升级设备镜像版本以匹配当前工程版本，请在设备的系统设置界面去升级设备系统。


方法二：降低工程的api版本，修改工程级build-profile.json5配置的compatibleSdkVersion字段api版本兼容设备的api版本。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-23
爬取时间: 2025-05-08 07:56:37
来源: Huawei Developer


问题现象


在启动调试或运行应用/服务时，安装HAP出现错误，提示“error: failed to start ability. error: ability visible false deny request”错误信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161202.63674322895225637199261088569157:50001231000000:2800:31A6C307E6BE02B2E5F617264B19C6C1CDF067DAAF89101E172785A16B796389.png)

解决措施

- Stage模型工程：module.json5文件的abilities字段内exported未设置为true，请设置exported设置为true。
- FA模型工程：config.json文件的abilities字段内的visible未设置为true，请设置visible设置为true。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-39
爬取时间: 2025-05-08 07:56:47
来源: Huawei Developer


问题现象


在启动调试或运行应用/服务时，安装HAP出现错误，提示“error: failed to start ability. error: unlock screen failed in developer mode”错误信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161202.95974874251186217964448352630789:50001231000000:2800:CABAE7FCE6C4BF7B011422B6079F3D9D8EA792A914369A06BACF485A31FC35FA.png)

解决措施


该问题的原因是锁屏状态下，设备设置了锁屏密码，无法正常拉起应用。

- 方法一：通过设置 - 显示和亮度 - 屏幕 - 休眠，延长自动休眠时间。
- 方法二：应用开发时候，可不设置应用锁屏密码，应用启动会自动亮屏进入设备并启动应用。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-51
爬取时间: 2025-05-08 07:56:57
来源: Huawei Developer


这种情况有可能是以下条件触发：

-  解决方案 卸载应用，然后重新启动调试，如果还存在此问题则请重启设备然后启动调试。

```less
> hdc shell
ps -ef|grep bundleName
```

-  首先通过执行 hdc track-jpid 命令查看应用是否被拉起： 如果列表中没有对应的应用进程，则 hdc shell 进设备中，通过 ps -ef|grep bundleName 查看应用是否存在。 如果应用不在，说明应用没拉起来，如果应用存在，但 hdc track-jpid 列表中不在，说明应用没注册上， 可能应用为 release 应用，hdc shell bm dump -n bundleName > aa.txt 查看 debug 值是否为true，如果为false则设备上的应用是 release 应用，建议clean工程然后重新debug打包，如果还是不行，说明应用未覆盖安装成功，优先判断当前需调试应用是否为预置应用，如果是预置应用推荐进行 OTA 升级。 build mode：None/debug 打出的包均为debug包
-  不配套请使用配套版本，新建一个模板工程，查看下hvigor目录下的 hvigor-config.json5 中的版本是多少，保持和这个版本配套。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161202.87478685265339965599475088712216:50001231000000:2800:C94251B26AEAB3D59B5E8B6729ABF801116E4D01775E89E107AB07F9F7B55340.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161202.80070468912540595275831109587780:50001231000000:2800:E5B14A434C7BF64C1763B28CEFE3B7B9250559DE63E6205351A129D573FD199F.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-17
爬取时间: 2025-05-08 07:57:06
来源: Huawei Developer


在使用Release应用堆栈解析功能时，可能遇到的错误提示及解决措施如下所示。


| 错误提示  | 问题原因  | 解决措施  |
| --- | --- | --- |
| Incorrect path format in line X  | 堆栈解析功能会将含有(路径:行号:列号)的堆栈识别为ArkTS堆栈进行解析，会对堆栈进行进一步的校验，路径不能含有运行系统下的不合法字符。如果输入的某行堆栈不满足上述形式，则会提示"Incorrect path format in line X"。  | 请排查输入堆栈是否满足(路径:行号:列号)的格式，若不满足应按照格式进行修改，并重新解析。  |
| Failed to find the source file in line X  | 在不勾选Unscramble stack trace的情况下，会将堆栈默认为是当前工程产生的堆栈，从本工程中获取解析需要的文件，解析结果也会从当前工程中寻找源文件，如果不存在会提示"Failed to find the source file in line X"。 在勾选Unscramble stack trace的情况下，ArkTS堆栈解析结果是相对路径，不会去寻找源文件，so解析结果如果不存在会提示"Failed to find the source file in line X"。  | 如果解析结果不包含一个绝对路径，可以用“file”命令检查so是否包含debuginfo。 检查堆栈对应工程与所打开工程的是否一致，并检查堆栈对应的源文件是否存在。 如果是自提供的so文件，请确定是产生当前堆栈的so。  |
| SourceMap error in line X  | 解析堆栈信息时，DevEco Studio需要用sourceMap将堆栈中的bundle文件信息映射为源码信息，如果没有提供相应的sourceMap，或者工程当前的sourceMap文件与生成堆栈时的sourceMap文件不一致，又或者堆栈被人为修改，导致堆栈与sourceMap不匹配； 出现上述情况则可能导致无法将堆栈中的信息映射为源码信息，此时会提示"SourceMap error in line X"。  | 检查所打开工程中的bundle文件与生成堆栈信息对应的bundle文件是否一致，如不一致，利用生成堆栈时的源码构建Release版本App，再进行堆栈解析。 如果是FA模型产生的堆栈，请在对应工程中不勾选Unscramble stack trace进行解析，勾选情况下，FA模型产生的堆栈无法匹配到源码信息。  |
| So Error in Line X  | 解析堆栈信息时，DevEco Studio需要用so文件将so的堆栈映射为源码信息，如果没有提供对应的so，则可能导致无法将堆栈中的信息映射为源码信息，此时会提示"So errorin Line X"。  | 请提供堆栈对应的so文件，确保so包含符号信息，可以使用"file"命令查看so是否为"not striped"。若so为"striped"，说明so的信息已被清除，可在模块级build-profile.json5中的debugSymbol->strip字段置为false。  |
| Failed to find source data in line X  | 如果输入堆栈中存在字符串"Cannot get SourceMap info, dump raw stack:"，DevEco Studio则会将其所在行替换为："Error Line: +第一条解析成功的堆栈对应的源码数据"。 当第一条解析成功的堆栈对应的源码不存在时（比如源码可能已被修改），则会提示："Failed to find source data in line X："。  | 检查源码是否存在，如果不存在，将源码文件改为堆栈信息对应的源码文件。  |
| Failed to find the bundle file in line X  | 在未勾选Unscramble stack trace的情况下，堆栈解析功能需要在打开对应工程，并且构建App对应Release版本条件下使用。 对于输入的堆栈信息，DevEco Studio会根据对应工程类型的路径转换规则寻找堆栈对应的Release版本bundle文件，如果转换后的路径对应bundle文件不存在，则会提示"Failed to find the bundle file in line X ："。  | 打开工程并构建对应App的Release版本，重新输入堆栈进行解析。  |

错误提示


问题原因


解决措施


Incorrect path format in line X


堆栈解析功能会将含有(路径:行号:列号)的堆栈识别为ArkTS堆栈进行解析，会对堆栈进行进一步的校验，路径不能含有运行系统下的不合法字符。如果输入的某行堆栈不满足上述形式，则会提示"Incorrect path format in line X"。


请排查输入堆栈是否满足(路径:行号:列号)的格式，若不满足应按照格式进行修改，并重新解析。


Failed to find the source file in line X


在不勾选Unscramble stack trace的情况下，会将堆栈默认为是当前工程产生的堆栈，从本工程中获取解析需要的文件，解析结果也会从当前工程中寻找源文件，如果不存在会提示"Failed to find the source file in line X"。


在勾选Unscramble stack trace的情况下，ArkTS堆栈解析结果是相对路径，不会去寻找源文件，so解析结果如果不存在会提示"Failed to find the source file in line X"。


如果解析结果不包含一个绝对路径，可以用“file”命令检查so是否包含debuginfo。


检查堆栈对应工程与所打开工程的是否一致，并检查堆栈对应的源文件是否存在。


如果是自提供的so文件，请确定是产生当前堆栈的so。


SourceMap error in line X


解析堆栈信息时，DevEco Studio需要用sourceMap将堆栈中的bundle文件信息映射为源码信息，如果没有提供相应的sourceMap，或者工程当前的sourceMap文件与生成堆栈时的sourceMap文件不一致，又或者堆栈被人为修改，导致堆栈与sourceMap不匹配；


出现上述情况则可能导致无法将堆栈中的信息映射为源码信息，此时会提示"SourceMap error in line X"。


检查所打开工程中的bundle文件与生成堆栈信息对应的bundle文件是否一致，如不一致，利用生成堆栈时的源码构建Release版本App，再进行堆栈解析。


如果是FA模型产生的堆栈，请在对应工程中不勾选Unscramble stack trace进行解析，勾选情况下，FA模型产生的堆栈无法匹配到源码信息。


So Error in Line X


解析堆栈信息时，DevEco Studio需要用so文件将so的堆栈映射为源码信息，如果没有提供对应的so，则可能导致无法将堆栈中的信息映射为源码信息，此时会提示"So errorin Line X"。


请提供堆栈对应的so文件，确保so包含符号信息，可以使用"file"命令查看so是否为"not striped"。若so为"striped"，说明so的信息已被清除，可在模块级build-profile.json5中的debugSymbol->strip字段置为false。


Failed to find source data in line X


如果输入堆栈中存在字符串"Cannot get SourceMap info, dump raw stack:"，DevEco Studio则会将其所在行替换为："Error Line: +第一条解析成功的堆栈对应的源码数据"。


当第一条解析成功的堆栈对应的源码不存在时（比如源码可能已被修改），则会提示："Failed to find source data in line X："。


检查源码是否存在，如果不存在，将源码文件改为堆栈信息对应的源码文件。


Failed to find the bundle file in line X


在未勾选Unscramble stack trace的情况下，堆栈解析功能需要在打开对应工程，并且构建App对应Release版本条件下使用。


对于输入的堆栈信息，DevEco Studio会根据对应工程类型的路径转换规则寻找堆栈对应的Release版本bundle文件，如果转换后的路径对应bundle文件不存在，则会提示"Failed to find the bundle file in line X ："。


打开工程并构建对应App的Release版本，重新输入堆栈进行解析。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-18
爬取时间: 2025-05-08 07:57:16
来源: Huawei Developer


问题现象


entry引用本地library时，已经勾选ASan选择项，没有ASan日志输出。


解决措施


引用本地C++ library时，需在library模块的build-profile.json5文件中，配置arguments字段值为“-DOHOS_ENABLE_ASAN=ON”，表示以ASan模式编译so文件。


```less
{
  ...
  "buildOption": {
    "externalNativeOptions": {
      ...
      "arguments": "-DOHOS_ENABLE_ASAN=ON",
      ...
    },
  },
  ...
}
```

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161202.80134928955684857665414891363794:50001231000000:2800:3289A8D40025523BC35D4D1346B03AFD4419BEC0D7FE11698AFBAD7B523E7E20.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-19
爬取时间: 2025-05-08 07:57:26
来源: Huawei Developer


问题现象


在设备中运行HAP时，提示“Hdc server port XXXX has been used.Configure environment variable ‘OHOS_HDC_SERVER_PORT’and restart IDE.”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161202.11046468605281360948378556477809:50001231000000:2800:7B3F6CF8DEBCE8E785ED836962C7704117583809317E6123EA5A5573ECB75652.png)

解决措施


该问题是由于HDC的默认端口8710，导致HDC服务无法启动，可参考如下步骤进行解决。


方式一：结束掉占用该端口的应用。

1. 
2. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161202.04699875179530156345721692802499:50001231000000:2800:78E7E360B1F123A182290B6BA9136A7780B695B26DBC840CC8EF2ED573AFB31C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161202.65347861936723659528699870927647:50001231000000:2800:C52A826E9EDD260555988E47A30A551AA8DE2254211DCC20835E0212C8688A85.png)

方式二：为HDC端口号设置其他的环境变量。

-  在此电脑 > 属性 > 高级系统设置 > 高级 > 环境变量中，添加HDC端口变量名为：OHOS_HDC_SERVER_PORT，变量值可设置为任意未被占用的端口，如7035。 环境变量配置完成后，关闭并重启DevEco Studio。

```less
echo $SHELL 
```


```less
echo $SHELL 
```


```less
vi ~/.bash_profile
```


```less
vi ~/.zshrc
```

- 单击字母“i”，进入Insert模式。

```less
OHOS_HDC_SERVER_PORT=7035
launchctl setenv OHOS_HDC_SERVER_PORT $OHOS_HDC_SERVER_PORT
export OHOS_HDC_SERVER_PORT
```

- 编辑完成后，单击Esc键，退出编辑模式，然后输入“:wq”，单击Enter键保存。

```less
source ~/.bash_profile
```


```less
source ~/.bash_profile
```


```less
source ~/.zshrc
```

- 环境变量配置完成后，关闭并重启DevEco Studio。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161202.24271729314488491131764054964026:50001231000000:2800:40566C1A1169F4355F56075D23D8248645C1258FCECE470CFB09B0FA4843BC0B.png)

```less
echo $SHELL 
```


```less
vi ~/.bash_profile
```


```less
vi ~/.zshrc
```


```less
OHOS_HDC_SERVER_PORT=7035
launchctl setenv OHOS_HDC_SERVER_PORT $OHOS_HDC_SERVER_PORT
export OHOS_HDC_SERVER_PORT
```


```less
source ~/.bash_profile
```


```less
source ~/.bash_profile
```


```less
source ~/.zshrc
```


```less
vi ~/.bash_profile
```


```less
vi ~/.zshrc
```


```less
source ~/.bash_profile
```


```less
source ~/.zshrc
```


方式三：如果查询端口未被占用，可检查端口是否被防火墙拦截，若被拦截则可放行端口再重启DevEco Studio进行尝试。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-20
爬取时间: 2025-05-08 07:57:36
来源: Huawei Developer


问题现象


执行热重载过程中报错，控制台打印蓝色重启链接"The current modification does not support hot reload. Please reinstall and restart."

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161202.89400678382060424803856398860231:50001231000000:2800:135C2C0286BFFF8F616858AD7D5C8C066992A0579CB0ED90C55741CA836F4056.png)

解决措施


当前DevEco Studio热重载功能支持的代码场景有范围限制，若修改的代码超出热重载支持范围则会提示当前修改不支持，请重启。当前热重载代码支持范围在官网中有限定说明，参考开发者官网Hot Reload使用约束。


常见不支持代码场景

- 
- 
- 
-  若一个代码文件在热重载启动是没有被当前文件import引用，则不支持在热重载过程中在当前文件新增import引用那一个代码文件。如下图，TestC.ets在热重载启动时未在Index.ets中import引用，则在热重载过程中不支持在Index.ets中新增import语句引用TestC.ets。 若热重载启动之前import语句是置灰状态，此文件在编译过程中不会参与编译，属于未加载的模块。
- 
- 
-  当前Hot Reload不支持大部分装饰器的修改。@Entry入口文件内支持@Styles装饰器新增、修改，支持@Builder装饰器修改，不支持新增，不支持@State装饰器新增、修改。
- 
- 
- 
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.11188893005059127839463938318514:50001231000000:2800:8F1AF09F0688B49572787D12B5D275F31907A2AED731629EE2B1F98CFFF3BF93.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.16073631448596303664484256694982:50001231000000:2800:8ECAFD500410902B66CD58ED9D34818341D402435C3AF781ACC9BD94ADA089AE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.00963084939310868498283228094804:50001231000000:2800:0BDD13641A001DEF321274836D5A3CF12B4B3DD9BAE4F5F79A24171BFB9E847B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.26931929688235424996455138262047:50001231000000:2800:B45B790AFC915213F7172729DF3F6984055BDA72FFAD2F3284D0D9214DF98EA7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.54493667922875222505033962315437:50001231000000:2800:D9C4CC9EAF8317ABE323C93F4B59A0AEEE7B6923EF08435D8116728301FCE871.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.17006380151341538367139234127241:50001231000000:2800:81639302441B483D24D3E15CCA4F52FDE62D7F20EC07F7EC237DD0DB052345BF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.77330307032332311257511354634805:50001231000000:2800:11F2D2B189FCB71541267D236925511300248FD2C77DAC71AABF0EDAAD1946E1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.52132250143387652924909560497346:50001231000000:2800:CF12CF497663468863167E2D3B3AD470C3B64E0B9C2A8CDEEAEEC2BC4590C8B6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.60780898608624854418773340095788:50001231000000:2800:047420AA80DA22F05EE343F2D4E6AE232EC6642491DD2776C330D794DB3188C6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.69167083027289978584146020341137:50001231000000:2800:15B63A7AA1010E7A0365B2D5B360850AE9852834BFB677B65263E7CE5A49DCD9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.54188725821287279698089661879799:50001231000000:2800:FB356E3FE0A49A9120EC679609E33121A8382AA3392DAE49FD2510FE4FFFD068.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.96311863173199984275606378308790:50001231000000:2800:6766F785CDB5C9D8CA698320CD440046BB16E4EE6FCE055C80D86E3E2C882D42.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-21
爬取时间: 2025-05-08 07:57:45
来源: Huawei Developer


问题现象


热重载执行结果失败，控制台打印蓝色重启链接：“Reloaded 1 files failed. Please reinstall and restart.”

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.75202074146188299109897298606617:50001231000000:2800:6D3952C7269B17B4C91162E435783261BC3754C0A30C0BFEF8838741428C3327.png)

解决措施


出现该问题是由于热重载最后一步会将补丁包安装到设备，执行quickfix命令，如果此命令执行失败则会导致热重载执行失败。


导致补丁包安装失败原因可检查以下几个方面：

- 
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161203.24889838525263797184215399686466:50001231000000:2800:2C4F2E39859C9A8FC47863D7E64029B54ACF62FBCF8B99C27D345D219C58D161.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161204.65871521349764834516405575779451:50001231000000:2800:0AC2DA67D2CBE28407B02AAB560E500245E0745618D960B4EBAA87AC5D306A7D.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-25
爬取时间: 2025-05-08 07:57:55
来源: Huawei Developer


问题现象


启动C++调试时出现错误，提示“Failed connect to unix-abstract-connect://*********.sock: Connection shut down by remote side while waiting for reply to initial handshake packet”错误信息。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161204.66308170986707744429888744802614:50001231000000:2800:481C7B006C387193916DF7DCB9CBDC55657A587C9AAA8C1D2BAACBF34420A883.png)

解决措施


1. 设备镜像与DevEco Studio版本不匹配，尝试更换设备镜像版本解决。


2. 签名使用了release调试证书，尝试更换成debug调试证书。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-26
爬取时间: 2025-05-08 07:58:05
来源: Huawei Developer


问题现象


在DevEco Studio上的C/C++代码处打断点，调试运行时断点不生效。


可能原因


DevEco Studio进行ArkTS/JS + Native混合调试时需要配置IDE的调试模式。


解决措施


选择配置项：Run/Debug Configurations > Debugger > Dual(ArkTS/JS + Native)

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161204.81647030827974086639216430864904:50001231000000:2800:8E388D648849A51E71A90A7383F47DA11F178D5639C375A8F75B83565C754BBE.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-28
爬取时间: 2025-05-08 07:58:15
来源: Huawei Developer

1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161204.99496047373853306397090261472808:50001231000000:2800:AC200838876D5D16C840B908BFEA57CBE2AA0B4DD2C617029B5C88AB9FA77F92.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-29
爬取时间: 2025-05-08 07:58:25
来源: Huawei Developer


问题现象


应用在进行自动签名时，签名失败，提示“The signature does not take effect or has expired. It may be the current system time is inaccurate, please calibrate the system time and sign again”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161204.67350366623279462571820723024533:50001231000000:2800:593E25270710BAE109D045DE78F3D5FDEBE3D3E8ABBE952CA2C29E93777C3137.png)

解决措施


出现该报错是由于PC的系统时间与北京时间不一致。请在PC的系统设置中，将系统时间设置为北京时间。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-30
爬取时间: 2025-05-08 07:58:35
来源: Huawei Developer


可以通过以下几种方式进行重启设备。

- 方式1：长按电源键，点击重启。
- 方式2：长按音量减键+电源键。
- 方式3：在连接数据线可以发现设备的情况下使用下述命令：hdc shell reboot

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-31
爬取时间: 2025-05-08 07:58:44
来源: Huawei Developer


DevEco Studio每次run项目（执行的命令都是先卸载当前推的hap包，再把要run的项目的hap包推上去），应用都会被卸载，其在设备上产生的数据库文件及临时文件也会被移除。


如果需要保存数据，可以在‘Run' - 'Edit Configurations' - 'General' - 'Installation Options' -中勾选 'Keep Application Data'。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-33
爬取时间: 2025-05-08 07:58:53
来源: Huawei Developer


问题描述


组件依赖已更新到最新，network源码编译，出现如下报错：


```less
Fingerprint:8c83cd8bd1e043ceecdb478f0ca56f241b09616da77300b1a834d50620c6cdd9Module name:msc_cpp_testTimestamp:2024-03-22 15:35:05.292Pid:59626Uid:0Process name:/data/local/tmp/msc_cpp_test/msc_cpp_testReason:Signal:SIGABRT(SI_TKILL)@0x000000000000e8ea from:59626:0Fault thread Info:Tid:59626, Name:msc_cpp_test#00 pc 0000000000185ca8 /system/lib/ld-musl-aarch64.so.1(raise+188)(bad62e733958f8d89d07480a2491abc9)#01 pc 00000000001381a8 /system/lib/ld-musl-aarch64.so.1(abort+20)(bad62e733958f8d89d07480a2491abc9)#02 pc 000000000005bef4 /system/lib64/libclang_rt.asan.so(d3894082b99f633c446cd1895b6190bd6a0bad31)#03 pc 000000000005a48c /system/lib64/libclang_rt.asan.so(d3894082b99f633c446cd1895b6190bd6a0bad31)#04 pc 00000000000d64e8 /system/lib64/libclang_rt.asan.so(d3894082b99f633c446cd1895b6190bd6a0bad31)#05 pc 00000000000d88ac /system/lib64/libclang_rt.asan.so(d3894082b99f633c446cd1895b6190bd6a0bad31)#06 pc 00000000000d2624 /system/lib64/libclang_rt.asan.so(__asan_memmove+468)(d3894082b99f633c446cd1895b6190bd6a0bad31)#07 pc 000000000064a264 /data/local/tmp/msc_cpp_test/libnetwork.so(std::__n1::pair<int const*, int*> std::__n1::__copy_impl[abi:v15004]<int const, int, void>(int const*, int const*, int*)+376)(f3db319579d1a289ab34f7fab2eb24eb1da4921e)./llvm-addr2line -Cfpie libnetwork.so 000000000064a264mt_network::WebSocket::Impl::Impl() at /Users/xxx/workspace/workspace/123460300/22012/s/network/src/main/cpp/websocket/websocket.cpp:114#08 pc 0000000000649ab0 /data/local/tmp/msc_cpp_test/libnetwork.so(std::__n1::pair<int const*, int*> std::__n1::__copy[abi:v15004]<int const*, int const*, int*, 0>(int const*, int const*, int*)+600)(f3db319579d1a289ab34f7fab2eb24eb1da4921e)./llvm-addr2line -Cfpie libnetwork.so 0000000000649ab0unsigned long std::__n1::allocator_traits<std::__n1::allocator<std::__n1::__shared_ptr_emplace<mt_network::WebSocket::Impl, std::__n1::allocator<mt_network::WebSocket::Impl>>>>::max_size[abi:v15004]<std::__n1::allocator<std::__n1::__shared_ptr_emplace<mt_network::WebSocket::Impl, std::__n1::allocator<mt_network::WebSocket::Impl>>>, void>(std::__n1::allocator<std::__n1::__shared_ptr_emplace<mt_network::WebSocket::Impl, std::__n1::allocator<mt_network::WebSocket::Impl>>> const&) at /Users/xxx/.meat/sdk/default/base/native/llvm/bin/…/include/libcxx-ohos/include/c++/v1/__memory/allocator_traits.h:326#09 pc 0000000000649720 /data/local/tmp/msc_cpp_test/libnetwork.so(int* std::__n1::copy[abi:v15004]<int const*, int*>(int const*, int const*, int*)+296)(f3db319579d1a289ab34f7fab2eb24eb1da4921e)./llvm-addr2line -Cfpie libnetwork.so 0000000000649720std::__n1::__allocation_guard<std::__n1::allocator<std::__n1::__shared_ptr_emplace<mt_network::WebSocket::Impl, std::__n1::allocator<mt_network::WebSocket::Impl>>>>::__release_ptrabi:v15004 at /Users/xxx/.meat/sdk/default/base/native/llvm/bin/…/include/libcxx-ohos/include/c++/v1/__memory/allocation_guard.h:66
```


解决方案


network单元测试用例crash问题的根因是container_overflow，这个检测项误报很多，目前是通过环境变量关闭的状态，测试用例没有设置ASAN对应的环境变量，所以触发了这个检测，导致误报。解决方法可以在跑测试用例的时候设置对应的ASAN环境变量手动推进手机，在执行linux脚本里面加这两条命令


export ASAN_OPTIONS=log_path=/dev/asanlog/asan.log:include=/system/etc/asan.options


export UBSAN_OPTIONS=print_stacktrace=1


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-34
爬取时间: 2025-05-08 07:59:03
来源: Huawei Developer


问题现象：Native调试长时间没有启动，最后DevEco Studio超时报错"Attach request timeout after 600000 milliseconds"或Native调试启动后报错"Failed to connect port"。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161204.43584757200023295097787338270021:50001231000000:2800:A72CEF9BF384079F5A61A78FCA518C70E02CD4ED3BA0366BCE36CF8E9E562FA9.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161204.32982922526341832648964603840697:50001231000000:2800:506D2219FE39CA4F860406655FEEE4A059EA3274B124EC885122F7765F5DB7C0.png)

可能原因：


linux或MacOS 下 /etc/hosts文件被修改。


解决措施：


```less
127.0.0.1 localhost
255.255.255.255 broadcasthost
::1 localhost
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-35
爬取时间: 2025-05-08 07:59:13
来源: Huawei Developer


问题场景一


DevEco Studio安装HAP时报错“FileTransfer Failed: Error while Deploy Hap”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161204.59626164938153464015407214720410:50001231000000:2800:5D62142DE027B7D62436CF15EDDC9154FF55167EEE4D9BB908289E03ABB2ED47.png)

解决措施


使用真机场景：请更换数据线或PC侧USB接口后尝试。


使用模拟器场景：

- 在Local Emulator的设备列表窗口，点击“Wipe User Data”清除模拟器数据，然后启动模拟器并重新运行工程。
- 

问题场景二


DevEco Studio安装HAP时报错“FileTransfer Failed: [Fail]Error opening file: no such file or directory”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161204.01804029387793552951053917102044:50001231000000:2800:37827C6CE5B1E0818ECE595BE00B51DCE1E48033BDECFBC19DA8B01C04C63B42.png)

解决措施


出现该问题是path路径的安装包不存在，可以检查是否签名HAP包没打包成功，修改签名能正常打出签名HAP包后再运行。


问题场景三


DevEco Studio安装HAP时报错“FileTransfer Failed: [Fail]Error opening file: operation not permitted”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161204.63338167812480415013649564524586:50001231000000:2800:77345567CFACE6D3370C4A1EB15B11ED9C750EE54E0E29F56E1F8637C26FDD04.png)

解决措施


出现该问题是安装包HAP所在路径没有权限导致的，可能是工程在C盘没有权限导致，将工程移出C盘再运行。


问题场景四


DevEco Studio安装HAP时报错“FileTransfer Failed: [Fail]Transfer Stop at:XXX, Reason: no space left on device”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161204.63830046154079465696211073108348:50001231000000:2800:2E7975DB69B573259953AF4A4204D0668F5F922ABA663E4755C1CA8D48F17D9E.png)

解决措施


设备侧磁盘满无法写入，请确认设备侧磁盘空间。如果是模拟器可以点击“Wipe User Data”清除模拟器数据再运行模拟器。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-36
爬取时间: 2025-05-08 07:59:22
来源: Huawei Developer


问题描述


前提条件：确认开发者模式和USB调试是打开的


解决措施


当前DevEco Studio无法识别设备的问题，可以按照以下步骤操作试下


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-55
爬取时间: 2025-05-08 07:59:32
来源: Huawei Developer


问题现象


在启动调试或运行应用/服务时，应用运行crash，提示“errorMsg:hap path error”错误信息。


解决措施


可能是由于依赖的应用包没有安装，可以进入Run/Debug Configurations > Deploy Multi Hap页签，勾选Deploy Multi Hap Packages，并选择所依赖的应用包，然后重新运行应用。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161205.68976129919598853766456837454612:50001231000000:2800:9C706E40AE2A1825DEA6B94EBBCC043CA9C6F9A39B9C13E3E81B93E09434AF71.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-56
爬取时间: 2025-05-08 07:59:41
来源: Huawei Developer


问题现象


使用Native调试堆栈可视化功能时，在任意两个页签来回切换后，可能出现并行栈视图界面显示空白。


解决措施


导致该问题的可能原因为电脑GPU不兼容，或在云桌面的场景下使用DevEco Studio。


在DevEco Studio中双击Shift，在弹出的窗口中搜索Registry...，在Registry页面中勾选ide.browser.jcef.gpu.disable项，关闭窗口并重启DevEco Studio即可。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161205.92209361034789529152659299139155:50001231000000:2800:B8889851F1DC28EA4F23BDFF4ABD031D8CF573B883E1B823E1F7B8E78A9CB079.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-57
爬取时间: 2025-05-08 07:59:51
来源: Huawei Developer


在DevEco Studio RUN/Debug Configurations中的Edit Configurations > Debugger > LLDB Post Attach Commands中添加配置：process handle -p false -s false -n false signal，其中signal为assert发送的信号量，详细步骤如图所示：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161205.79078672305786108008812448718500:50001231000000:2800:7001E8EA84A7C1B76EC8303B676C1ED14FBB20E85675C5195194A8834E42BBB2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161205.18153699875491559970270342369089:50001231000000:2800:09CAE4086069193B4056AE482C4E8EF8F6172143BBFD2BDE4FC950ED25567125.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-debugging-58
爬取时间: 2025-05-08 08:00:01
来源: Huawei Developer


如果需要保存数据在Run之后Preferences存储的用户信息不会被清除，可以在DevEco Studio内进行如下设置‘点击Run->Edit Configurations... 进入Debug Configurations’-‘General’-‘Installation Options’-中勾选‘Keep Application Data’。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161205.66349793813025897510948767804372:50001231000000:2800:824703F077D8F49000DBABF38E350DAF38CBBFC86016362811383688D30DC647.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-profiler
爬取时间: 2025-05-08 08:00:13
来源: Huawei Developer

- Profiler分析任务录制失败
- 导入历史数据失败
- 内存占用率过高导致DevEco Studio无法正常运行
- 开启多线程开关后应用性能劣化

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-profiler-1
爬取时间: 2025-05-08 08:00:22
来源: Huawei Developer


问题现象


单击Profiler深度分析任务的启动录制按钮后，无法录制成功：

- DevEco Studio右下角提示深度分析任务启动或者录制失败。
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161205.55253557057842311872424737017321:50001231000000:2800:4AE06CFF70425E8E456439296744F831894C0E19DEC62324113271F7B80C4D7D.png)

解决措施


深度分析任务启动录制后会经历初始化Initializing，录制Recording，停止录制后分析及组装数据Analyzing三个阶段。在这些阶段中均可能出现任务录制失败的情况，原因包括但不限于连接断开、插件错误及设备状态异常等。


请按照如下步骤进行操作。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-profiler-2
爬取时间: 2025-05-08 08:00:31
来源: Huawei Developer


问题现象


在使用其他版本的DevEco Studio导出的Profiler深度分析任务文件（.insight文件）时，出现如下异常：

- 导入失败
- 导入后不显示泳道
- 导入后无数据

解决措施


请使用与导出文件时相同版本的DevEco Studio重新操作。


如您无法从导出方确认DevEco Studio的版本号，可通过查看.insight文件,查看manifest.json目录下devEcoStudioBuildVersion字段，确认版本号信息。


.insight文件可以使用常用解压软件打开并查看。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-profiler-3
爬取时间: 2025-05-08 08:00:41
来源: Huawei Developer


问题现象


在Profiler数据分析过程中，DevEco Studio卡顿或停止响应，显示“Low Memory”告警。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161205.60590465690153370998806082713563:50001231000000:2800:2C80AEDFBA699EAE209E19C12AA684EBA51A76D31FD5B1B34D1B84EEAD56438A.png)

解决措施


可在DevEco Studio的配置文件中手动修改虚拟机可使用的最大内存。

1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161205.07654549679826992764636200277485:50001231000000:2800:45C9B4876069BA1179688404E8FC1B8AA65D2A75E293D430F093D8C84BEB4B57.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-profiler-4
爬取时间: 2025-05-08 08:00:51
来源: Huawei Developer


问题现象


在进行DevEco Testing稳定性压测后，进行性能测试发现性能劣化。


可能原因


DevEco Testing稳定性压测会默认打开多线程开关，压测结束后可能执行关闭失败。多线程开关本身是为了方便定位多线程安全问题，开启多线程开关会对性能产生影响。


解决措施


通过如下命令手动关闭多线程开关。


```less
hdc shell param set persist.ark.propserties 0x105c
hdc shell reboot
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-test
爬取时间: 2025-05-08 08:01:01
来源: Huawei Developer

- 升级DevEco Studio后执行测试任务失败
- 运行测试用例时，结果树始终处于加载状态
- 报错“container is not running”
- 运行UITest用例，运行超时屏幕黑屏后报错
- 原有工程使用新的DevEco Studio版本打开，运行测试用例失败
- 命令行方式执行Instrument Test堆栈路径打印错误
- ohosTest测试文件引用了entry模块的方法，测试时报cppcrash
- ohosTest测试文件引用了启动页的导出方法，测试时报错“Load Page Failed: pages/Index”
- DevEco Studio 5.0 AppAnalyzer-场景化体检-应用冷启动安装Python依赖错误

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-test-2
爬取时间: 2025-05-08 08:01:12
来源: Huawei Developer


问题现象


升级DevEco Studio之后，打开之前创建的工程，执行测试框架任务失败。


解决措施


出现该问题的原因是升级DevEco Studio后测试框架hypium版本及框架内模板OpenHarmonyTestRunner与原工程不匹配，建议的解决措施如下：

- 措施一（建议）：使用升级后DevEco Studio新建工程，将原有测试任务迁移至新工程。
- 措施二：升级原工程，具体包括：升级hypium插件版本：在工程级oh-package.json5中，升级hypium至最新版本。具体版本信息请参考配套关系。替换OpenHarmonyTestRunner入口文件模板：新建全新的工程，将src/ohosTest/ets/testrunner/OpenHarmonyTestRunner.ets文件拷贝到原工程同样的目录中。修正错误：由于不同版本之间可能存在差异，替换完上述文件后，仍需根据编辑器的错误提示逐一修正错误。
- 升级hypium插件版本：在工程级oh-package.json5中，升级hypium至最新版本。具体版本信息请参考配套关系。
- 替换OpenHarmonyTestRunner入口文件模板：新建全新的工程，将src/ohosTest/ets/testrunner/OpenHarmonyTestRunner.ets文件拷贝到原工程同样的目录中。
- 修正错误：由于不同版本之间可能存在差异，替换完上述文件后，仍需根据编辑器的错误提示逐一修正错误。
- 升级hypium插件版本：在工程级oh-package.json5中，升级hypium至最新版本。具体版本信息请参考配套关系。
- 替换OpenHarmonyTestRunner入口文件模板：新建全新的工程，将src/ohosTest/ets/testrunner/OpenHarmonyTestRunner.ets文件拷贝到原工程同样的目录中。
- 修正错误：由于不同版本之间可能存在差异，替换完上述文件后，仍需根据编辑器的错误提示逐一修正错误。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-test-3
爬取时间: 2025-05-08 08:01:22
来源: Huawei Developer


问题现象


如果存在多个模块（如entry和feature两个模块）同时依赖HSP，先在设备上运行entry和HSP模块，再执行feature模块下的测试用例时，出现任务结果树处于一直加载状态，无法正常执行完成。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161206.83443515841150615657712491493503:50001231000000:2800:7FDF9AA6911F442B8816E93E71245C1C32548EE90BC11A9DB38B0784FF375BE5.png)

解决措施

1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161206.13683797015270551812483808497687:50001231000000:2800:9C1C1DEB2A036CCD8433073316F62EACBE4A685399E8800D5D4B0F9CEF0D1701.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-test-4
爬取时间: 2025-05-08 08:01:31
来源: Huawei Developer


问题现象


在HarmonyOS设备上运行命令“hdc -n shell param set persist.ace.testmode.enabled 1”时报错“container is not running”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161206.16997997142577508284007595440906:50001231000000:2800:73D2E5E31A761571C748703BA61C771A9018898B4AA35BFB8FE69DFD2E27F496.png)

解决措施


UiTest测试能力使能需要先推包到设备上，可以在DevEco Studio中运行一个测试用例，运行的流程中有推包动作，推包后再运行命令“hdc -n shell param set persist.ace.testmode.enabled 1”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161206.39309665476916196860544260763072:50001231000000:2800:85A80DA3FC078221E77B6839824B259BEF179BBE0BE330E6B01186DE4181FE86.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-test-5
爬取时间: 2025-05-08 08:01:42
来源: Huawei Developer


问题现象


运行UITest用例，运行超时屏幕黑屏后报错提示“Tests failed”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161206.42166840117945365106755534495417:50001231000000:2800:F8984E728C2C7A10E844DE2DC41BDC12EED2419A856098AF53F259D13B7F31C6.png)

解决措施


运行UITest用例时，需保持设备常亮。在设备保持常亮的状态下，即可运行成功。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161206.21427473184947740282598499107336:50001231000000:2800:C1CDF5B5DBDB1F40EF01390C883CFE51105667E28987E6FCA8634701402A393D.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-test-6
爬取时间: 2025-05-08 08:01:52
来源: Huawei Developer


问题现象


如果工程是在DevEco Studio 3.1.0.400之前版本创建的，在升级DevEco Studio至3.1.0.400及以上版本后，原有工程运行测试用例失败，提示“A page configured in 'test_pages.json' must have one and only one '@Entry' decorator”。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161206.04155052163051899264064509377677:50001231000000:2800:2E4F47E4A90FA7C49B3DEE7E340EC95EAF089E8FD15C5D41E1847CF6D6B3F337.png)

解决措施


将TestRunner、TestAbility目录改成小写testrunner、testability，再次运行测试用例。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161206.48455245330262670107239380740790:50001231000000:2800:7F7458ECCFAA44E67FCC7863DDA25AFD2D60733B003177A0BD9D591F9222273D.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-test-7
爬取时间: 2025-05-08 08:02:02
来源: Huawei Developer


问题现象


在5.0.3.400版本下，通过命令行执行Instrument Test，堆栈信息中的文件路径和位置有误，出现"|"而不是"/"，升级到5.0.3.401及以上版本仍然有误。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161206.08571264456962444729169517397074:50001231000000:2800:9E2A2484CB7998DF4F0B33E4F20830EBBB6409C1F993A6E81F3C1E58C6976F13.png)

可能原因


未同时删除在5.0.3.400版本下生成的.test（需要手动删除）和build文件夹。


解决措施


同时删除在5.0.3.400版本下生成的.test（需要手动删除）和build文件夹，重新执行测试用例。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161206.43931764638855804245246065054821:50001231000000:2800:26443D9610AE7D8B9AC5116EDFF5A1BF4030D79CC27C076798D7C2E80B287A3D.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-test-8
爬取时间: 2025-05-08 08:02:12
来源: Huawei Developer


问题现象


如果ohosTest测试文件引用了entry的方法，并且entry中存在以普通形式（例如"entry/ets/workers/Worker.ets"）加载worker时，测试执行期间会报cppcrash。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161206.80623037155857515015717375493571:50001231000000:2800:DC1759236559588D2A2ED03D47287D8099EBE0CFEF18C293120211D103567BBA.png)

解决措施


修改entry中实例化worker的路径形式为：带@标识路径加载形式或相对路径加载形式，再次执行测试可以正常通过。

- 
- 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161207.44562661870537673300892707973389:50001231000000:2800:5B52A35D7BEBEBEA8706745903C3ED58AD1209D1E08A2301369C977563DA9207.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161207.09699888934948883359685941784940:50001231000000:2800:EC69BC4C5568DAA9DB6739F47DB055DAB4FC7F9416E32B6F87C384DA252E82B3.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-test-9
爬取时间: 2025-05-08 08:02:21
来源: Huawei Developer


问题现象


在测试文件中引用启动页的导出方法，并且拉起启动页面所在的Ability的时候，执行测试会抛出jscrash，错误信息为：“Load Page Failed: pages/Index”。解决措施

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161207.10034523019548152709379906849414:50001231000000:2800:9560AD4DDAF3F1527B33ED9BB8FD33BBA215B3FD1A5E015B9FB280A892738E59.png)

在拉起启动页面所在Ability时指定当前模块名称，执行测试，用例正常运行。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161207.18241463443246787225141377476731:50001231000000:2800:29BB8AA08E85AE327D9CA53C5E4DD47B3EB87EAA10A3479BF44C6E13F0CD37A4.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-test-10
爬取时间: 2025-05-08 08:02:30
来源: Huawei Developer


问题现象


安装Python依赖报错

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161207.68738870510486689923402535083666:50001231000000:2800:B4CBA15B3342BE36ECFE36974BD8AFB5882E40E2190B36CAACA1CF647D3C11D4.png)

可能原因


解决措施

1.  推荐从官网获取3.11.7版本，其他版本可能出现兼容性问题，如果已安装请跳过

```less
https://www.python.org/ 
```

2.  Mac/Win需要手动添加Python环境变量，如果已配置请跳过 Mac系统下打开终端运行vi ~/.bashrc, 编辑完成后运行source ~/.bashrc 使其生效 Win系统下请按系统键，在弹出的窗口中搜索环境变量, 在系统属性弹窗中点击环境变量，在环境变量窗口中双击path，然后添加python的安装路径。 在CMD/Shell命令窗口输入python -V检查是否生效。 在CMD/Shell命令窗口输入python -m pip install --upgrade pip更新pip。

```less
export PYTHON_3_11_HOME=/Your/Path/Python.framework/Versions/3.11
export PATH=$PYTHON_3_11_HOME/bin:$PATH
alias python=python3
```

3.  设为默认，如果已经设置，请跳过 Pip的配置文件为用户根目录下的：~/.pip/pip.conf（Windows路径为：C:\Users\<UserName>\pip\pip.ini*), 您可以配置如下内容： 如需设置代理，可以参考如下配置，如果username、password有特殊字符，需要转义。 如果password中存在特殊字符，如@、#、*等符号，可能导致配置不生效，建议将特殊字符替换为ASCII码，并在ASCII码前加百分号%。常用符号替换为ASCII码对照表如下： 查看本地生效的pip 配置。 测试安装一个python依赖，查看网络、配置是否正常。

```less
[global]
index-url = https://mirrors.huaweicloud.com/repository/pypi/simple
trusted-host = mirrors.huaweicloud.com
timeout = 120 
```

4.  DevEco Studio 5.0.3/5.0.4安装依赖 如果自动安装依赖失败，可以手动安装，新建一个requirements.txt将以下内容拷贝到requirements.txt, 用pip install -r /your/path/requirements.txt安装所有依赖 DevEco Studio 5.0.5安装依赖 初次使用冷启动python依赖。

```less
Flask==3.0.3
numpy==2.0.2
onnxruntime==1.19.2
opencv-python==4.10.0.84
openvino==2024.4.0
openvino-telemetry==2025.1.0
pillow==10.4.0
pyclipper==1.3.0.post6
shapely==2.0.6
waitress==3.0.2
```

5.  安装完依赖后，重启DevEco Studio，重新点击Tools-AppAnalyzer-场景化体检-应用冷启动。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161207.94911921326505722017127784777140:50001231000000:2800:6DC2E7205883C28F090C9C9ECA7130A46E8F5B24B4F3D7E82954959A414AD37F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161207.33935524233181034156338427511516:50001231000000:2800:66DE15A98C894D15FDCF16CFD2E3BA6FD5418D5521B937F6EFC4627C244FD9B3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161207.08453749346643992633012598276868:50001231000000:2800:5A8E5D0C0393D92C9D80ABC19C4FDA40DDA98B9EFDB919CEA469BBE2DB137BD7.png)
- !：%21
- @：%40
- #：%23
- $：%24
- &：%26
- *：%2A

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-command-line-tool
爬取时间: 2025-05-08 08:02:40
来源: Huawei Developer

- 通过cmd命令行或终端可以正常publish，在git bash上publish时报错The content of private l key in the key path error
- ohpm-repo私有化后删除上传包及审核上传包步骤
- 编译时DevEco Studio报”ohpm ERROR: EINSTALL install failed, Error: Dependency node build failed Install failed”错
- ohpm-repo使用mysqlDB插件连mysql时，报错“decrypt data failed. error: Unsupported state or unable to authenticate data”
- ohpm ERROR: JSON5: invalid end of input at 1:1
- 误下线了组件，再次推包时提示需要24小时之后操作，怎么可以解除限制？
- ohpm私仓修改upload_max_times不生效
- 发布ohpm提示错误：The version field: 12.5.0.0-20-dev in the oh-package.json5 file does not satisfy the semver specification
- 如何查看项目中har版本冲突
- ohpm publish在本地git bash环境下一直报错 the content of private key in the key_path error
- 如何解决ohpm上传har包异常，报错：The publishId is invalid!
- 如何获取可用的三方库
- 如何使用ohpm引入三四方库

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-command-line-tool-1
爬取时间: 2025-05-08 08:02:50
来源: Huawei Developer


问题现象


通过cmd命令行或终端可以正常publish，但是在git bash上publish时报错。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161207.77540281981276440759339459007633:50001231000000:2800:9FDDE10A3540C2675A0E59697171015D7681C8F6AE428CDCE7E440C5C895F816.png)

解决措施


方法一：从git官网下载安装最新版本 git， 使用最新版本携带的 git-bash 终端进行操作。


方法二：在当前 git 安装目录下的 etc 目录中新增 git-bash.config文件, git-bash.confg文件里面添加一行MSYS=enable_pcon配置， 重新打开 git-bash 终端运行 ohpm publish 命令即可。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-command-line-tool-2
爬取时间: 2025-05-08 08:03:01
来源: Huawei Developer

1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161208.56983938550466476730634683826285:50001231000000:2800:289F5C46999F6C660BD4A394C10EBFFE384833288171B0BA7E5A1B60F27657AD.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-command-line-tool-3
爬取时间: 2025-05-08 08:03:10
来源: Huawei Developer


问题现象


编译时报错：


ohpm ERROR: EFETCH Fetch local file package error, D:\dev\harmonyos\mgty-ohos-phone\oh_modules.ohpm@ohos+mgkv@pediph1+Vjwini4jdg9r1s9hqaq=\oh_modules@ohos\mgkv\libs\MMKV.har does not exist.


ohpm ERROR: missing: @ohos/MMKV@D:/dev/harmony{ngty-ohos-phone/oh moduLes/.ohpm{@ohos+mgKCpediph1 v/wini4jdg9r1s9nqaq\oh_modules@ohos\mgkv\Libs\HMKV.har, required by @ohos/mgkVOD:/dev/harmony/mgtv-ohos-phone/baseLib/kv/Lib/ngkv.nde


ohpm ERROR: ERUNNING execute tasks failed, Error: Dependency node build failed


ohpm ERROR: EINSTALL install failed, Error: Dependency node build failed


Install failed。


可能原因


ohpm 1.4.0之后，har中配置的有相对路径依赖的包，但是在生成oh_module中，可能没有添加对应的依赖，导致在构建时找不到对应的包。


解决措施


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-command-line-tool-4
爬取时间: 2025-05-08 08:03:20
来源: Huawei Developer


删除ohpm-repo私仓根目录下的.deploy_root文件后，重新指定加密组件，执行start操作。


参考链接


ohpm-repo start


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-command-line-tool-5
爬取时间: 2025-05-08 08:03:30
来源: Huawei Developer


问题描述


电脑无网络，升级600后报错：ohpm ERROR: JSON5: invalid end of input at 1:1


解决方案


删除工程下的oh-package-lock.json5文件后， 执行ohpm clean ohpm cache clean ohpm install --all


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-command-line-tool-6
爬取时间: 2025-05-08 08:03:40
来源: Huawei Developer


问题描述


版本上传时发现版本号打错了，点了下架，改好版本号后重新上传提示规定时间禁止发布，想能不能先帮忙恢复下，或者规定时间是多久？


解决方案


ohpm-repo里面有配置文件。修改再上架小时为比如0.00x。然后执行ohpm install,然后重启ohpm-repo但是这种方式，再上架版本号要加1，具体可以参考配置文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-command-line-tool-7
爬取时间: 2025-05-08 08:03:49
来源: Huawei Developer


问题描述


默认100，修改成9999后还是有100限制


解决方案


[2024-03-05T19:17:41.123] [INFO] default - "deploy_root" environment variables: "OHPM_REPO_DEPLOY_ROOT = C:\Users\uhamc\AppData\Roaming\Huawei\ohpm-repo". PS C:\Users\uhamc> ohpm-repo start


[2024-03-05T19:18:10.555] [INFO] default - config file path: "C:\Users\uhamc\AppData\Roaming\Huawei\ohpm-repo\conf\config.yaml".


ohpm-repo启动时会打印config地址，需要修改此处的config文件，然后重启服务生效。


参考链接


配置文件 config.yaml


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-command-line-tool-8
爬取时间: 2025-05-08 08:04:00
来源: Huawei Developer


问题描述


在线构建播放器库的har包后发布ohpm提示错误： 11:29:52 ohpm [91mERROR: [39m [31mThe version field: 12.5.0.0-20-dev in the oh-package.json5 file does not satisfy the semver specification


解决方案


版本不遵循 semver 语义化规范,目前使用只能是1.0.0-XXXX 三段式的形式, 可参考文档:https://semver.org/#spec-item-11


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-command-line-tool-9
爬取时间: 2025-05-08 08:04:09
来源: Huawei Developer


属于ohpm install --all的信息，可以执行此命令看到保留住对应信息；


ohpm list可以查看已安装的三方库 ；依赖冲突解决可以使用overrides字段控制版本，也可参考模块内依赖版本冲突文档。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-command-line-tool-10
爬取时间: 2025-05-08 08:04:19
来源: Huawei Developer


问题描述


ohpm publish在本地git bash环境下一直报错 ”the content of private key in the key_path error.”但是在DevEco Studio中不会，会让输入密码。ohpm版本1.5，环境变量已经配置 。


原因分析


原因分析: 使用ohpm publish命今上传包时，此时如果使用ssh证书密码认证，程序需要通过TTY流读取用户输入的密码，git安装的版本过低其携带的git-bash会导致TTY流丢失， 从而出现该错误。


解决方案


1、从git官网下载安装最新版本 git， 使用最新版本携带的 git-bash 终端进行操作。


2、在当前 git 安装目录下的 etc 目录中新增 git-bash.config文件, git-bash.confg文件里面添加一行MSYS=enable_pcon配置， 重新打开 git-bash 终端运行 ohpm publish 命令即可.


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-command-line-tool-11
爬取时间: 2025-05-08 08:04:29
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-deveco-testing
爬取时间: 2025-05-08 08:04:38
来源: Huawei Developer

- 常见问题
- 应用稳定性测试
- 应用基础质量测试
- 应用性能测试
- 回归测试
- 实用工具

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-deveco-testing-faq
爬取时间: 2025-05-08 08:04:47
来源: Huawei Developer

- 针对HarmonyOS NEXT应用测试，DevEco Testing提供了哪些配套测试能力？
- 设备已连接，为什么设备列表中未显示该设备？
- 测试任务执行过程中，需避免PC进入睡眠状态，该如何设置？
- 创建任务时，为什么会提示创建任务失败？
- 是否支持对使用Flutter等三方框架开发的应用进行测试？
- 是否支持DevEco Emulator模拟器？
- 使用DevEco Testing/DevEco Testing Hypium有疑问，如何自助查阅资料及指南？
- 测试指南及FAQ无法解决问题，如何获取在线支持？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-deveco-testing-faq-1
爬取时间: 2025-05-08 08:04:56
来源: Huawei Developer


当前已发布DevEco Testing Windows/Mac客户端，及稳定性、性能、应用基础质量等专项测试服务，如应用探索测试、场景化性能测试、回归测试、应用基础质量测试（功能体验、功耗、稳定性、性能、UX）、UiViewer、设备投屏等。同时提供了DevEco Testing Hypium UI自动化测试框架及智能编码插件。覆盖应用测试全周期，助力打造高品质应用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-deveco-testing-faq-2
爬取时间: 2025-05-08 08:05:06
来源: Huawei Developer


需满足以下条件，方可使用DevEco Testing识别设备及进行测试。

1. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161208.25396832005284591205902202406555:50001231000000:2800:4273DE344CD24549E1D8FDCB5A9E674672BD9FA43AC8B3854EC742EAF24BFFA7.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-deveco-testing-faq-3
爬取时间: 2025-05-08 08:05:15
来源: Huawei Developer


DevEco Testing在执行测试任务的时候，需要PC一直保持正常的工作状态。为了避免因PC进入休眠而导致的设备断连、任务暂停等情况，请手动设置电源管理。


Windows设置方法：控制面板—电源选项—更改计划设置—使计算机进入睡眠状态—设置为【从不】—保存修改。


Mac设置方法：系统偏好设置—电池/节能，将【此时间段后关闭显示器】改为【永不】，并勾选【当显示器关闭时，防止电脑自动进入睡眠】。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-deveco-testing-faq-4
爬取时间: 2025-05-08 08:05:25
来源: Huawei Developer


若出现该场景，请前往DevEco Testing客户端-设置-问题反馈，或通过华为开发者联盟-在线提单，提交该场景信息（测试服务名称+异常任务信息+问题描述+问题截图），以便于研发团队进一步分析。


注意：客户端提交反馈需打开日志上传开关，华为开发者联盟提单请附上工具日志。


Windows日志路径：C:\Users\用户名\AppData\Local\DevEco Testing\common\modules\launcher\logs


Mac日志路径：/Users/用户名/Library/Application Support/DevEco Testing/common/modules/launcher/logs


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-deveco-testing-faq-5
爬取时间: 2025-05-08 08:05:35
来源: Huawei Developer


当前版本仅支持Stage模型开发的HarmonyOS应用。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-deveco-testing-faq-6
爬取时间: 2025-05-08 08:05:45
来源: Huawei Developer


当前版本仅支持手机、PC等硬件设备。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-deveco-testing-faq-7
爬取时间: 2025-05-08 08:05:55
来源: Huawei Developer


DevEco Testing资料查询：


方式1：前往DevEco Testing客户端任务创建页，右下角可查看各测试服务的使用指南。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161208.96309200590598193224927838587268:50001231000000:2800:705E4F791AD6EF1198A239D89F25F97CFE0C6C82D79F37D0E3B6E6C16D38ABCB.png)

方式2：前往华为开发者联盟官网查看指南-应用测试-专项测试，查看DevEco Testing章节。


DevEco Testing Hypium资料查询：


前往华为开发者联盟官网查看指南-应用测试-单元测试和UI测试，查看应用UI测试（基于python）章节。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-deveco-testing-faq-8
爬取时间: 2025-05-08 08:06:05
来源: Huawei Developer


反馈方式1：可通过DevEco Testing客户端-设置-问题反馈，提交测试服务名称+异常任务信息+问题描述+问题截图，并打开日志上传开关。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161208.56237302353062032107250323425388:50001231000000:2800:7C6AB3FD9005D5EA44A8A2E646D6A2BEF11A140F78FA9BA0912F794FB8492E9F.png)

反馈方式2：可通过华为开发者联盟—在线提单，提交测试服务名称+异常任务信息+问题描述+问题截图，并提交工具日志，待研发团队进一步分析后，给出答复。


Windows日志路径：C:\Users\用户名\AppData\Local\DevEco Testing\common\modules\launcher\logs


Mac日志路径：/Users/用户名/Library/Application Support/DevEco Testing/common/modules/launcher/logs


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-stability-test
爬取时间: 2025-05-08 08:06:15
来源: Huawei Developer

- 应用探索测试

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-exploration-test
爬取时间: 2025-05-08 08:06:25
来源: Huawei Developer

- 测试过程中，为什么测试页面截图会出现页面切换状态？
- 测试过程中，控件语义识别中的“XXX的项”、“XXX的列”应如何理解？
- 查看应用探索测试报告时，报告加载卡顿的原因是什么？
- 遍历路径地图中，为什么会出现截图相同的节点？
- 语义分析的过程中，为什么会对空白区域（看不到有按钮或文字）进行红框标记？
- 应用中嵌入了 Web窗口，能进行应用探索测试吗？
- 应用为什么无法进行应用探索测试？
- 应用稳定性问题定位，可以参考哪些资料？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-exploration-test-1
爬取时间: 2025-05-08 08:06:35
来源: Huawei Developer


在遍历操作过程中，对页面的滑动操作与截图操作并不是完全同步的，测试截图时，存在小概率会截取页面正在切换的过程，该场景为正常情况，不影响应用探索测试整体功能。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161209.52344708520008205931036581502109:50001231000000:2800:2DBDF65FF6D96991BFB0CB2965B509E4FB4C1D21E78FAAEFB1736AE8B2A9F4AE.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-exploration-test-2
爬取时间: 2025-05-08 08:06:45
来源: Huawei Developer


当前应用页面元素被分解为菜单、频道、列表等元素，当AI模型识别到相似的元素，会自动归一为测试等价类，对于同一个列表里的多个元素，则都会被视为同一类项。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-exploration-test-3
爬取时间: 2025-05-08 08:06:54
来源: Huawei Developer


由于探索测试执行时间比较长，会产生大量的报告数据，当报告节点过多时，或出现报告资源加载卡顿，可关闭客户端重启尝试恢复。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-exploration-test-4
爬取时间: 2025-05-08 08:07:03
来源: Huawei Developer


当前节点的判断根据页面layout确定，系统会根据各个页面的layout生成唯一节点。部分节点看起来截图相同，实际上它们的layout信息不同。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-exploration-test-5
爬取时间: 2025-05-08 08:07:14
来源: Huawei Developer


系统会根据当前页面的layout信息对控件进行标记，控件分为可见控件及不可见控件，空白区域内或存在不可见的控件，为测试正常执行过程。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-exploration-test-6
爬取时间: 2025-05-08 08:07:24
来源: Huawei Developer


当前已支持Web类应用测试。当前页面遍历层级限制为8层，若测试场景页面层级大于8，将无法进一步遍历。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-exploration-test-7
爬取时间: 2025-05-08 08:07:34
来源: Huawei Developer


若发现应用界面控件无法点击，请使用DevEco Testing 实用工具-UIViewer打开该应用界面，逐层点击该页面控件树排查：

1. 
2. 
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161209.57756711784836593136249569030800:50001231000000:2800:987487B023C75F4F759CC89932486E02976C33B8CB4026FAECAC046CEAB6D739.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161209.83883638576987996756864994232740:50001231000000:2800:BFF3CA3ABE9AA593F5B2B672E618C0A89360CD9B50787DD0436E1E663C9F22DE.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-exploration-test-8
爬取时间: 2025-05-08 08:07:43
来源: Huawei Developer


更多应用稳定性体验优化建议及问题定位，请前往华为开发者联盟查阅：应用稳定性体验建议及CppCrash故障定位指导


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-basic-quality-test
爬取时间: 2025-05-08 08:07:54
来源: Huawei Developer

- 测试报告中，为什么会出现测试项检测异常？
- 测试报告中，为什么会批量出现待检测项？
- 应用基础质量测试问题定位，可以参考哪些资料？
- UX基础质量测试
- 性能基础质量测试
- 稳定性基础质量测试

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-basic-quality-test-1
爬取时间: 2025-05-08 08:08:04
来源: Huawei Developer

- 请选用手机设备进行测试，且系统版本为HarmonyOS NEXT版本。其他类型设备及系统测试报告中或出现检测异常。
- 请确保测试过程中设备正常连接，设备断连会影响测试结果，可能出现检测异常及待检测项。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-basic-quality-test-2
爬取时间: 2025-05-08 08:08:13
来源: Huawei Developer


偶现由于测试任务内部异常导致任务终止，请查看【测试报告-执行日志】，若应用信息为空，请再次创建任务执行测试。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161209.61195383590026696922809497966333:50001231000000:2800:91DF51C12C2C3A63EE5B6E06D47865528F7C8D52201B1C11E5B8086CEB6063B9.png)

该问题为应用信息暂未解析完创建任务导致，再次创建任务时，请等待右侧应用信息加载完成后再创建，即可解决该问题。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161209.65206787331165753940981035320364:50001231000000:2800:94549F4CA2A3A36FBC6E0833CBADCC829711442561392B336DFA0103380AF3DA.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-basic-quality-test-3
爬取时间: 2025-05-08 08:08:23
来源: Huawei Developer


稳定性基础质量测试：应用稳定性体验建议及CppCrash故障定位指导


UX基础质量测试：应用UX体验建议及应用UX体验标准


功能体验基础质量测试：应用基础功能和兼容性体验建议


性能基础质量测试：应用性能体验建议及最佳实践-性能


功耗基础质量测试：应用功耗体验建议及最佳实践-功耗


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ux-basic-quality-test
爬取时间: 2025-05-08 08:08:32
来源: Huawei Developer

- 测试报告中，为什么会出现不涉及检测项？
- 测试报告中，所有检测项均异常，异常原因提示“the ux script reports an error”，该如何处理？
- 实际情况与测试结果有偏差，该如何处理？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ux-basic-quality-test-1
爬取时间: 2025-05-08 08:08:42
来源: Huawei Developer


布局合理美观相关检测项为折叠屏机型专属测试项，直板机测试过程中，不涉及此类检测项的测试。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ux-basic-quality-test-2
爬取时间: 2025-05-08 08:08:52
来源: Huawei Developer


若出现该场景，请前往DevEco Testing客户端-设置-问题反馈，或通过华为开发者联盟-在线提单，提交该场景信息（测试服务名称+异常任务信息+问题描述+问题截图），以便于研发团队进一步分析。


注意：客户端提交反馈需打开日志上传开关，华为开发者联盟提单请附上工具日志。


Windows日志路径：C:\Users\用户名\AppData\Local\DevEco Testing\common\modules\launcher\logs


Mac日志路径：/Users/用户名/Library/Application Support/DevEco Testing/common/modules/launcher/logs


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ux-basic-quality-test-3
爬取时间: 2025-05-08 08:09:01
来源: Huawei Developer


部分检测项可能存在少量视觉检测误差，测试结果请忽略，后续将持续降低检测误差。如误差较大，请通过DevEco Testing客户端-设置-问题反馈或华为开发者联盟-在线提单，提交该场景信息（测试服务名称+异常任务信息+问题描述+问题截图），以便于研发团队进一步优化。


注意：客户端提交反馈需打开日志上传开关，华为开发者联盟提单请附上工具日志。


Windows日志路径：C:\Users\用户名\AppData\Local\DevEco Testing\common\modules\launcher\logs


Mac日志路径：/Users/用户名/Library/Application Support/DevEco Testing/common/modules/launcher/logs


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-basic-quality-test
爬取时间: 2025-05-08 08:09:12
来源: Huawei Developer

- 报告中为什么会出现未执行检测？
- 测试过程中，设备断连重连后任务能否继续进行？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-basic-quality-test-1
爬取时间: 2025-05-08 08:09:21
来源: Huawei Developer


如遇到以下几种场景，将会出现未执行检测项。


场景1：在应用测试过程中，不满足测试用例执行条件，将不执行相关测试场景。例如，应用页面仅一屏，不支持滑动，则本次遍历中，滑动相关指标将无数据；某些指标检测动效场景，如果遍历中未遇到动效场景，则XX流畅相关指标将无数据。


场景2：由于通过查找桌面应用图标名查找应用，被测应用需放置在桌面上，请勿放在文件夹中，否则将出现批量未检测项。


场景3：使用WebView类应用进行测试，将出现测试数据不准确及批量出现未执行检测项。


场景4：偶现应用解析异常，导致批量出现未检测项，该场景请重新执行任务即可恢复。


场景5：应用内操作测试目前主要支持ArkUI控件类应用（含ReactNative框架开发应用），WebView页面遍历系统版本需为HarmonyOS NEXT Beta1及以上版本。


场景6：不支持Flutter应用，以及其他三方自研的自定义控件识别。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-basic-quality-test-2
爬取时间: 2025-05-08 08:09:30
来源: Huawei Developer


如果发生设备断连情况测试会终止，并生成测试报告，由于测试执行不充分，会导致生成的报告数据不完整，请保证设备在测试的过程中正常连接。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-stability-basic-quality-test
爬取时间: 2025-05-08 08:09:40
来源: Huawei Developer

- 任务出现超时未结束是什么原因？
- 内存泄漏的定位日志为什么是乱码？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-stability-basic-quality-test-1
爬取时间: 2025-05-08 08:09:50
来源: Huawei Developer


请排查电脑的睡眠设置，如未设置从不睡眠，将出现任务超时不结束的情况。


Windows设置方法：控制面板—电源选项—更改计划设置—使计算机进入睡眠状态—设置为【从不】—保存修改。


Mac设置方法：系统偏好设置—电池/节能，将【此时间段后关闭显示器】改为【永不】，并勾选【当显示器关闭时，防止电脑自动进入睡眠】。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-stability-basic-quality-test-2
爬取时间: 2025-05-08 08:10:00
来源: Huawei Developer


系统自动抓的调用栈（ memleak native --[process_ name]--[ pid]--[timestamp].txt ）无法直接在DevEco Studio打开，需要修改后缀名为 .nas，然后用最新版本的DevEco Studio打开。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-app-performance-test
爬取时间: 2025-05-08 08:10:10
来源: Huawei Developer

- 性能指标监控测试
- 场景化性能测试

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-indicator-monitoring-test
爬取时间: 2025-05-08 08:10:19
来源: Huawei Developer

- trace采集功能如何使用？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-performance-indicator-monitoring-test-1
爬取时间: 2025-05-08 08:10:29
来源: Huawei Developer


在点击开始采集后，用户可点击trace采集按钮，随时进行trace采集。由于trace文件较大，且采集时需要占用设备内存作为日志缓冲区，所以当前每次采集固定为30秒，且单次任务只保留最近10个trace文件。请使用时留意工具提示，防止因采集次数超过限制导致较早文件被删除。


若需要完整操作的trace，推荐使用场景化性能测试服务，支持通过编写脚本来自定义操作场景，对应用性能进行评估。测试报告中可获取详细的trace文件、CPU、应用内存占用数据。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test
爬取时间: 2025-05-08 08:10:39
来源: Huawei Developer

- 执行报告用例的其中一个步骤，在视频中动效为什么只录了一半？
- Can't find component with [BY.text('XXX')] 的报错是什么原因？
- 执行python.exe -m pip install --upgrade pip命令更新pip库时报错ValueError: Unable to find resource t64.exe in package pip._vendor.distlib
- 环境安装完成，下载工程模板至本地后，本地调试时失败；测试服务包更新后，本地调试时失败，该如何处理？
- 任务执行失败，原因：指定目录下未找到用例。该如何排查？
- 安装完全部包后，本地调试运行脚本报错
- 卡顿率报了异常，丢帧卡顿次数为0，该如何理解？
- 卡顿率显示的视频时间与下面给的视频图片集编号对不上，是什么原因？
- 如何获取trace文件 ?
- 卡顿率指标是怎么定义的?
- 卡顿率是否支持应用自定义检测？
- 如何结合trace，分析卡顿率指标异常问题 ？
- 测试报告中，用例执行详情为红色，且无数据是什么原因？
- 时延类指标出现负数是什么原因？
- 测试结果中，指标值“0”和“-”有什么区别？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-1
爬取时间: 2025-05-08 08:10:49
来源: Huawei Developer


例：启动App步骤，显示App打开到一半视频就结束了，没有加载完成的录屏部分。


上一步操作的动效较长，还未结束就返回结果，并开始下一步的操作，导致录屏中步骤不全。可以在create_tag方法加上wait_time参数，进行等待采集并分析这段时间。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-2
爬取时间: 2025-05-08 08:10:58
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-3
爬取时间: 2025-05-08 08:11:08
来源: Huawei Developer


输入python –m pip uninstall pip setuptools卸载setuptools，输入pip install --upgrade setuptools重新安装setuptools，然后重新执行python.exe -m pip install --upgrade pip命令pip库更新成功。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-4
爬取时间: 2025-05-08 08:11:18
来源: Huawei Developer


请检查环境是否正确，Pycharm所引用的python版本是否引用hypium及hypium_perf的全部版本，可尝试参考DevEco Testing-性能测试-场景化性能-安装hypium_perf章节手动安装并检查依赖包完整性。


如更新场景化性能测试服务后，出现本地调试失败，请检查当前依赖包版本是否与安装包中的版本一致。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-5
爬取时间: 2025-05-08 08:11:27
来源: Huawei Developer

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161210.30080284557145029380079868151581:50001231000000:2800:5FC38FBCB97E4441DA24BCA739DC76B3D8A30F7D105AC88790CB86B6553CD646.png)

检查用例对应的json文件中的py文件路径是否正确，该路径是testcases下的相对路径。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-6
爬取时间: 2025-05-08 08:11:37
来源: Huawei Developer

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161210.84248714562415002618677788026036:50001231000000:2800:67BE257D0E5BCFB9DCE17BCDB3E39C7CD9362397A1B134D8C31626D7BF2FBE46.png)

请检查python环境中是否存在服务指定xdevice包之外的xdevice包，如果有，则需要卸载。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-7
爬取时间: 2025-05-08 08:11:47
来源: Huawei Developer

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161210.91921773466839032159481003805497:50001231000000:2800:779BE5AA486A7D210805FC7B3EC09E47278ACD9D6BC0537D48980A18E8D16C81.png)

卡顿率和丢帧卡顿的检测机制不同，无必然联系，两者都需要关注。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-8
爬取时间: 2025-05-08 08:11:57
来源: Huawei Developer

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161210.23243500108350774495427597812871:50001231000000:2800:70182279C51E1A5DC99558BD29488FAE9F26CB437AB557157DCC7B487D9A3E00.png)

卡顿率指标关注设备时间，可与trace中RenderService帧的上屏时间对应，下面给的帧图片集仅供参考。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-9
爬取时间: 2025-05-08 08:12:07
来源: Huawei Developer

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161210.68524822602753886688161510814046:50001231000000:2800:E06E772C872CECFE4877BA4C122C6191C6ED312EC400A7D6EE81A17BBCEB9AD1.png)

点击报告中资源文件“trace”，会自动打开本地文件夹。修改对应步骤文件的后缀，将“.perfdata”改为“.zip”，再将zip文件解压即可 。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-10
爬取时间: 2025-05-08 08:12:17
来源: Huawei Developer


卡顿率看的是一段动效区间内，累计的丢帧时长，评估整个动效时段画面的流畅度；值是累计丢帧时长和动效时长的比值，单位ms/s。


单帧丢帧时长 = 实际上屏时间 - 期望上屏时间 （上屏时间可看trace图形子系统的present线程，取泳道结束点）

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161211.85403463566951992223168953980161:50001231000000:2800:A03808076AC7702366200F2110B2AB147AFCF1ADA6100BAD9857464216689274.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-11
爬取时间: 2025-05-08 08:12:26
来源: Huawei Developer


支持应用自定义动效的卡顿率检测，应用在trace动效点位标签命名加入前缀H:CUSTOM_ANIMATOR即可，可自动识别和检测。trace样例如下：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161211.04257205537624730422961656412139:50001231000000:2800:133FFE666C9476112EC5626E54A026A16E90812277DD734A49B278E98D004864.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-12
爬取时间: 2025-05-08 08:12:36
来源: Huawei Developer


下载和打开trace后，可快速通过上报的Present ID字段，在trace中搜索，定位到问题点。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161211.88873198362119173010590658740997:50001231000000:2800:A5A718CB9E6EBF0B700B76119220C4A3F4C98AC6363FD6B42798A21E1962938D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161211.35033621628337217955846291397694:50001231000000:2800:C81775CE0ACCA1E3E7E091AAD3E39928A05CF3126DCFC1E8B121FAA9CBD271BC.png)

上图中，99009这一帧，在屏幕持续了33ms，减去应持续的16.6ms，被统计为丢1帧。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-13
爬取时间: 2025-05-08 08:12:46
来源: Huawei Developer


报告中出现用例详情表头为红色，说明用例未能成功执行，可以点击报告右上角执行日志查看执行过程中的错误信息。常见的失败原因包括：用例抛出未捕获的异常，待测应用未安装，设备断连等等。建议先在DevEco Studio中运行和调试脚本，可顺利执行后再使用DevEco Testing进行正式测试。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161211.00507005332031694526565933080021:50001231000000:2800:BC6E99490E955D584CEFD60D38E1D2F7D17205D63998A4685DD2EABE09CAF898.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-14
爬取时间: 2025-05-08 08:12:55
来源: Huawei Developer


响应时延


-2：起始点异常


-3：结束点异常，一般是没点动或没滑动


-4：步骤没采集到视频


-5：步骤没采集到trace


-6：值异常，大于800ms，没点动或没滑动也可能因为图像质量误识别到某一帧


完成时延


-2： 找到的结束点比起始点早，一般是页面没发生什么变化


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-scenario-based-performance-test-15
爬取时间: 2025-05-08 08:13:05
来源: Huawei Developer


0：表示该指标项参与了检测，检测结果为0


-：表示该指标项不需要或不支持检测，无需关注


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test
爬取时间: 2025-05-08 08:13:15
来源: Huawei Developer

- 生成回归测试包时报错提示“打包失败,当前项目根目录下缺少testcases文件夹”
- 生成回归测试包时报错提示“当前项目根目录下不存在setup-regression.py文件!”
- 生成回归测试包时报错提示“setup-regression.py 解析失败, 请检查setup-regression.py写法是否规范!”？
- 生成回归测试包时报错提示“测试套生成失败,请检查setup-regression.py文件后重试”？
- 生成回归测试包时报错提示“dist/testsuite 文件夹为临时目录，请确保该文件夹为空”？
- 生成回归测试包时报错提示“测试包中需包含单用例（json及对应的 py 文件），请校验setup-regression.py 文件后重试”？
- 生成回归测试包时报错提示“xxx.json 中 py_file 字段为空，请检查该文件是否填写正确!”？
- 生成回归测试包时报错提示“xxx.py 文件不存在,请检查 json 文件是否填写正确!”？
- 生成回归测试包时报错提示“xxx 模块下载失败”
- 选择测试包后报错提示“应用解析异常，请稍后重试”
- 选择测试包后报错提示“请添加测试步骤，具体请参考测试指南”
- 选择测试包后报错提示“测试包解析失败，请查看测试指南排查失败原因”
- 创建任务后报错提示“测试套中用例数量不为1，请检查后使用回归测试插件生成新的测试套！”
- 创建任务后报错提示“测试套类型异常，请使用回归测试插件生成测试套！”
- 创建回归测试任务时，提示“应用解析异常”
- 测试结束后 hilog 日志一栏显示“-”
- 测试过程中没有显示用例包步骤且指标监控中无数据

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-1
爬取时间: 2025-05-08 08:13:24
来源: Huawei Developer


若根目录下缺少testcases文件夹，会出现该提示，请按测试指南测试包构建指导构建工程。


一个完整的回归测试工程结构为：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161211.89396229941865208466868736922096:50001231000000:2800:AA7F0767D436CC78A9C5E1B2DA4F2E894525CD647CC47B4222CEEA0AC6D9D74D.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-2
爬取时间: 2025-05-08 08:13:34
来源: Huawei Developer


工程根目录下需维护回归测试打包必需的实例文件setup-regression.py，否则出包失败。


一个完整的回归测试工程结构为：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161211.91073275281084238455495196982875:50001231000000:2800:D9D258BB1D3B30ABD6C33F04C48A500296D9E5A9FD586D10598BC3D5F7A43A9F.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-3
爬取时间: 2025-05-08 08:13:44
来源: Huawei Developer


若setup-regression.py编写不规范，会出现该提示。编写setup-regression.py文件时需注意：需去除注释，参数以“参数名=参数值”的形式设置。


```less
 # setup-regression.py文件编写示例
from setuptools import setup   
setup(       
      name='hypiumTest',       
      version='1.0.0.0',       
      author='xxx',       
      # py_modules指定需要打包的hypium用例py文件       
      py_modules=['testcases.Example'],       
      include_package_data=True       
      )       
```


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-4
爬取时间: 2025-05-08 08:13:54
来源: Huawei Developer


请检测setup-regression.py文件写法，使用python setup-regression.py sdist --formats=zip进行本地自验证，验证通过后再利用插件出包。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-5
爬取时间: 2025-05-08 08:14:03
来源: Huawei Developer


setuptools构建工程会使用临时目录dist/testsuite，请勿在此目录下存放用户个人文件。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-6
爬取时间: 2025-05-08 08:14:13
来源: Huawei Developer


若setup-regression.py文件构建的工程包中不含用例，会出现该提示。回归测试要求工程包中必须包含单用例，请检查setup-regression.py文件，利用python setup-regression.py sdist --formats=zip 进行本地自验证，确保构建的工程中仅包含单用例。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-7
爬取时间: 2025-05-08 08:14:22
来源: Huawei Developer


当用户在setup-regression.py文件中指定打包的json文件中未声明对应的用例py文件，则会出现该提示，请参考应用UI测试（基于python）-测试脚本开发快速入门修改用例写法。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-8
爬取时间: 2025-05-08 08:14:32
来源: Huawei Developer


当指定待打包的json文件中指定的py用例文件不存在，会出现该报错，请检查json文件中指定的py文件是否存在。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-9
爬取时间: 2025-05-08 08:14:42
来源: Huawei Developer


由于网络或其他原因导致install_requires中指定的依赖下载失败，可稍后重试。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-10
爬取时间: 2025-05-08 08:14:52
来源: Huawei Developer


用户在生成可执行测试包时填写的应用名在测试设备上解析应用信息失败，检查打包时应用名填写是否正确，且设备上是否有安装该应用。


如果没有填写应用名或应用名填写错误，请重新生成可执行测试包及创建测试任务。


如果有应用且应用名也正确，请在命令行执行“hdc shell bm dump -n 应用名”，查看应用解析异常原因。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-11
爬取时间: 2025-05-08 08:15:02
来源: Huawei Developer


回归测试服务会按步骤上报每一步的执行结果，若用户选择的测试包中待执行用例里没有使用Step接口声明步骤信息，则会出现该报错。


在用例脚本中，请导入并使用hypium.advance.deveco_testing.step 中的 Step函数标记步骤 (from hypium.advance.deveco_testing.step import Step)，否则回归测试过程中无法正确读取到测试步骤。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-12
爬取时间: 2025-05-08 08:15:12
来源: Huawei Developer


出现该报错通常有两种原因：


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-13
爬取时间: 2025-05-08 08:15:22
来源: Huawei Developer


若用户选择的可执行测试包中用例数不为1，会出现该提示。回归测试仅支持单用例执行，请使用DevEco Testing Hypium插件重新生成可执行测试包。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-14
爬取时间: 2025-05-08 08:15:31
来源: Huawei Developer


该场景出现是因为用户选择的测试包非DevEco Testing Hypium插件生成的回归测试服务包，不可用于回归测试，用户可参照下图重新生成可执行测试包。

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161212.00747180768539635057318238937366:50001231000000:2800:F5D34978E41FB09BAE18BC8A0C8BFC4BE9EC18ABE9225DEA821E2E06D669F08B.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-15
爬取时间: 2025-05-08 08:15:41
来源: Huawei Developer


请确保当前待测设备已安装测试包对应的被测应用，若未安装应用，选择测试包创建任务，将提示该报错。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-16
爬取时间: 2025-05-08 08:15:51
来源: Huawei Developer


用户手动停止任务后，Hypium 进程会直接关闭，不会生成 hilog。如任务正常结束后缺少hilog，请确认测试包中 config 文件夹下的 user_config.xml 文件中 devicelog 参数为 ON（如果没有，请添加），重新打包即可解决。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-regression-test-17
爬取时间: 2025-05-08 08:16:01
来源: Huawei Developer


在用例脚本中，请导入并使用hypium.advance.deveco_testing.step 中的Step函数标记步骤 (from hypium.advance.deveco_testing.step import Step)，否则回归测试过程中无法正确读取到测试步骤，并导致指标监控为空。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-utilities
爬取时间: 2025-05-08 08:16:11
来源: Huawei Developer

- 设备投屏
- UIViewer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-utilities-cast
爬取时间: 2025-05-08 08:16:20
来源: Huawei Developer

- 设备投屏时，投屏画面持续加载中如何处理？
- 设备投屏时，投屏卡顿如何处理？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-utilities-cast-1
爬取时间: 2025-05-08 08:16:30
来源: Huawei Developer


打开cmd窗口，在设备上执行hdc指令删除该文件：


hdc shell rm -r /data/local/tmp/latestScreen.jpeg


然后重试设备投屏，如果获取页面仍失败可重启设备后再试。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-utilities-cast-2
爬取时间: 2025-05-08 08:16:40
来源: Huawei Developer



URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-utilities-uiviewer
爬取时间: 2025-05-08 08:16:50
来源: Huawei Developer

- 如何处理UIViewer获取页面时，无论如何操作切换设备界面，UIViewer展示的都是同一个界面
- UIViewer获取页面时，无法展示页面截图和元素树如何处理？

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-utilities-uiviewer-1
爬取时间: 2025-05-08 08:17:00
来源: Huawei Developer


打开cmd窗口，在设备上执行hdc指令删除该文件：


```less
hdc shell rm -r /data/local/tmp/latestScreen.jpeg
```


然后重试设备投屏，如果获取页面仍展示同一界面，可重启设备后再试。


URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-utilities-uiviewer-2
爬取时间: 2025-05-08 08:17:10
来源: Huawei Developer


请排查设备UiTest框架是否正常，打开cmd窗口，在设备上运行 hdc shell uitest dumpLayout 和 hdc shell snapshot_display -f /data/local/tmp/screenCasting.jpeg 两条指令，确认下是否能运行成功，成功运行截图如下：

![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250507161212.20284840405999537431288113248776:50001231000000:2800:B47361DAC01D8B2C05D60D7B8CEF979006347FAB1935A083B7DADB66C9BB3FAA.png)

如运行失败，请前往DevEco Testing客户端-设置-问题反馈，或通过华为开发者联盟-在线提单，提交该场景信息（测试服务名称+异常任务信息+问题描述+问题截图），以便于研发团队进一步分析。


注意：客户端提交反馈需打开日志上传开关，华为开发者联盟提单请附上工具日志。


Windows日志路径：C:\Users\用户名\AppData\Local\DevEco Testing\common\modules\launcher\logs


Mac日志路径：/Users/用户名/Library/Application Support/DevEco Testing/common/modules/launcher/logs



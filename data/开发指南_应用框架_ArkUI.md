# 合并文件
合并时间: 2025-04-28 00:06:07

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkui-V14
爬取时间: 2025-04-27 23:14:11
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkui-overview-V14
爬取时间: 2025-04-27 23:14:24
来源: Huawei Developer
ArkUI（方舟UI框架）为应用的UI开发提供了完整的基础设施，包括简洁的UI语法、丰富的UI功能（组件、布局、动画以及交互事件），以及实时界面预览工具等，可以支持开发者进行可视化界面开发。
基本概念
-  UI：即用户界面。开发者可以将应用的用户界面设计为多个功能页面，每个页面进行单独的文件管理，并通过页面路由API完成页面间的调度管理如跳转、回退等操作，以实现应用内的功能解耦。
-  组件：UI构建与显示的最小单位，如列表、网格、按钮、单选框、进度条、文本等。开发者通过多种组件的组合，构建出满足自身应用诉求的完整界面。
两种开发范式
针对不同的应用场景及技术背景，方舟UI框架提供了两种开发范式，分别是基于ArkTS的声明式开发范式（简称“声明式开发范式”）和兼容JS的类Web开发范式（简称“类Web开发范式”）。
-  声明式开发范式：采用基于TypeScript声明式UI语法扩展而来的ArkTS语言，从组件、动画和状态管理三个维度提供UI绘制能力。
-  类Web开发范式：采用经典的HML、CSS、JavaScript三段式开发方式，即使用HML标签文件搭建布局、使用CSS文件描述样式、使用JavaScript文件处理逻辑。该范式更符合于Web前端开发者的使用习惯，便于快速将已有的Web应用改造成方舟UI框架应用。
在开发一款新应用时，推荐采用声明式开发范式来构建UI，主要基于以下几点考虑：
-  开发效率：声明式开发范式更接近自然语义的编程方式，开发者可以直观地描述UI，无需关心如何实现UI绘制和渲染，开发高效简洁。
-  应用性能：如下图所示，两种开发范式的UI后端引擎和语言运行时是共用的，但是相比类Web开发范式，声明式开发范式无需JS框架进行页面DOM管理，渲染更新链路更为精简，占用内存更少，应用性能更佳。
-  发展趋势：声明式开发范式后续会作为主推的开发范式持续演进，为开发者提供更丰富、更强大的能力。 图1方舟UI框架示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170239.89537039424959909303224422482504:50001231000000:2800:AAFAC52509274C3038BFFB47BB140A2F92AF5CBCF10109467B526FCA92E57F30.png)
不同应用类型支持的开发范式
根据所选用应用模型（Stage模型、FA模型）和页面形态（应用或服务的普通页面、卡片）的不同，对应支持的UI开发范式也有所差异，详见下表。
表1支持的UI开发范式
| 应用模型 | 页面形态 | 支持的UI开发范式 |
| --- | --- | --- |
| Stage模型（推荐） | 应用或服务的页面 | 声明式开发范式（推荐） |
|  | 卡片 | 声明式开发范式（推荐） 类Web开发范式 |
| FA模型 | 应用或服务的页面 | 声明式开发范式 类Web开发范式 |
|  | 卡片 | 类Web开发范式 |
声明式开发范式（推荐）
类Web开发范式
声明式开发范式
类Web开发范式

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-ui-development-V14
爬取时间: 2025-04-27 23:14:38
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-ui-development-overview-V14
爬取时间: 2025-04-27 23:14:52
来源: Huawei Developer
基于ArkTS的声明式开发范式的方舟开发框架是一套开发极简、高性能、支持跨设备的UI开发框架，提供了构建应用UI所必需的能力，主要包括：
-  ArkTS ArkTS是优选的主力应用开发语言，围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展。扩展能力包含声明式UI描述、自定义组件、动态扩展UI元素、状态管理和渲染控制。状态管理作为基于ArkTS的声明式开发范式的特色，通过功能不同的装饰器给开发者提供了清晰的页面更新渲染流程和管道。状态管理包括UI组件状态和应用程序状态，两者协作可以使开发者完整地构建整个应用的数据更新和UI渲染。ArkTS语言的基础知识请参考初识ArkTS语言。
-  布局 布局是UI的必要元素，它定义了组件在界面中的位置。ArkUI框架提供了多种布局方式，除了基础的线性布局、层叠布局、弹性布局、相对布局、栅格布局外，也提供了相对复杂的列表、宫格、轮播。
-  组件 组件是UI的必要元素，形成了在界面中的样子，由框架直接提供的称为系统组件，由开发者定义的称为自定义组件。系统内置组件包括按钮、单选框、进度条、文本等。开发者可以通过链式调用的方式设置系统内置组件的渲染效果。开发者可以将系统内置组件组合为自定义组件，通过这种方式将页面组件化为一个个独立的UI单元，实现页面不同单元的独立创建、开发和复用，具有更强的工程性。
-  页面路由和组件导航 应用可能包含多个页面，可通过页面路由实现页面间的跳转。一个页面内可能存在组件间的导航如典型的分栏，可通过导航组件实现组件间的导航。
-  图形 方舟开发框架提供了多种类型图片的显示能力和多种自定义绘制的能力，以满足开发者的自定义绘图需求，支持绘制形状、填充颜色、绘制文本、变形与裁剪、嵌入图片等。
-  动画 动画是UI的重要元素之一。优秀的动画设计能够极大地提升用户体验，框架提供了丰富的动画能力，除了组件内置动画效果外，还包括属性动画、显式动画、自定义转场动画以及动画API等，开发者可以通过封装的物理模型或者调用动画能力API来实现自定义动画轨迹。
-  交互事件 交互事件是UI和用户交互的必要元素。方舟开发框架提供了多种交互事件，除了触摸事件、鼠标事件、键盘按键事件、焦点事件等通用事件外，还包括基于通用事件进行进一步识别的手势事件。手势事件有单一手势如点击手势、长按手势、拖动手势、捏合手势、旋转手势、滑动手势，以及通过单一手势事件进行组合的组合手势事件。
-  自定义能力 自定义能力是UI开发框架提供给开发者对UI界面进行开发和定制化的能力。包括：自定义组合、自定义扩展、自定义节点和自定义渲染。
特点
-  开发效率高，开发体验好
-  性能优越
-  生态容易快速推进 能够借力主流语言生态快速推进，语言相对中立友好，有相应的标准组织可以逐步演进。
整体架构
图1整体架构图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170239.65818155680368963399516785098350:50001231000000:2800:8634E601A7B3ABF575165263D6D5CF09652F5DD7C653F8D98CB28E28B38BAFD5.png)
-  声明式UI前端 提供了UI开发范式的基础语言规范，并提供内置的UI组件、布局和动画，提供了多种状态管理机制，为应用开发者提供一系列接口支持。
-  语言运行时 选用方舟语言运行时，提供了针对UI范式语法的解析能力、跨语言调用支持的能力和TS语言高性能运行环境。
-  声明式UI后端引擎 后端引擎提供了兼容不同开发范式的UI渲染管线，提供多种基础组件、布局计算、动效、交互事件，提供了状态管理和绘制能力。
-  渲染引擎 提供了高效的绘制能力，将渲染管线收集的渲染指令，绘制到屏幕的能力。
-  平台适配层 提供了对系统平台的抽象接口，具备接入不同系统的能力，如系统渲染管线、生命周期调度等。
开发流程
使用UI开发框架开发应用时，主要涉及如下开发过程。
| 任务 | 简介 | 相关指导 |
| --- | --- | --- |
| 学习ArkTS | 介绍了ArkTS的基本语法、状态管理和渲染控制的场景。 | - 基本语法 - 状态管理 - 渲染控制 |
| 开发布局 | 介绍了几种常用的布局方式。 | - 常用布局 |
| 添加组件 | 介绍了几种常用的系统组件使用方法。 | - 常用组件 - 自定义组件 |
| 设置组件导航和页面路由 | 介绍了如何设置组件间的导航以及页面路由。 | - 组件导航（推荐） - 页面路由 |
| 使用文本 | 介绍了输入框、富文本和属性字符串等文本组件的使用方法。 | - 文本显示 - 文本输入 - 富文本 - 图标小符号 - 属性字符串 |
| 使用弹窗 | 介绍了弹窗的应用场景与使用方法。 | - 弹出框 - 菜单控制 - 气泡提示 - 绑定模态页面 - 即时反馈 - 设置浮层 |
| 显示图形 | 介绍了如何显示图片、绘制自定义几何图形以及使用画布绘制自定义图形。 | - 几何图形 - 画布 |
| 使用动画 | 介绍了组件和页面使用动画的典型场景。 | - 属性动画 - 转场动画 - 粒子动画 - 组件动画 - 动画曲线 - 动画衔接 - 动画效果 - 帧动画 |
| 绑定事件 | 介绍了事件的基本概念和如何使用通用事件和手势事件。 | - 通用事件 - 手势事件 |
| 使用自定义能力 | 介绍了自定义能力的基本概念和如何使用自定义能力。 | - 自定义节点 - 自定义扩展 |
| 使用镜像能力 | 介绍了镜像能力的基本概念和如何使用镜像能力。 | - 使用镜像能力 |
| 支持适老化 | 介绍了适老化的使用场景和使用方法。 | - 支持适老化 |
| 主题设置 | 介绍了应用级和页面级的主题设置能力。 | - 应用深浅色适配 - 设置应用内主题换肤 |
| 使用UI上下文接口操作界面 | 介绍了如何使用UIContext中对应的接口获取与实例绑定的对象。 | - 使用UI上下文接口操作界面 |
| 跨进程拉起页面 | 介绍了全屏方式拉起元服务的方法。 | - 全屏启动元服务组件 |
| 使用NDK接口构建UI | 介绍了ArkUI NDK接口提供的能力，以及如何通过NDK接口创建UI界面。 | - 接入ArkTS页面 - 监听组件事件 - 使用动画 - 使用懒加载开发长列表界面 - 构建弹窗 - 构建自定义组件 - 嵌入ArkTS组件 - 通过XComponent接入无障碍 |
-基本语法
-状态管理
-渲染控制
-常用布局
-常用组件
-自定义组件
-组件导航（推荐）
-页面路由
-文本显示
-文本输入
-富文本
-图标小符号
-属性字符串
-弹出框
-菜单控制
-气泡提示
-绑定模态页面
-即时反馈
-设置浮层
-几何图形
-画布
-属性动画
-转场动画
-粒子动画
-组件动画
-动画曲线
-动画衔接
-动画效果
-帧动画
-通用事件
-手势事件
-自定义节点
-自定义扩展
-应用深浅色适配
-设置应用内主题换肤
-接入ArkTS页面
-监听组件事件
-使用动画
-使用懒加载开发长列表界面
-构建弹窗
-构建自定义组件
-嵌入ArkTS组件
-通过XComponent接入无障碍
通用规则
-  默认单位 表示长度的入参单位默认为vp，即入参为number类型、以及Length和Dimension类型中的number单位为vp。
-  异常值处理 输入的参数为异常（undefined，null或无效值）时，处理规则如下： （1）对应参数有默认值，按默认值处理； （2）对应参数无默认值，该参数对应的属性或接口不生效。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-layout-development-V14
爬取时间: 2025-04-27 23:15:05
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-layout-development-overview-V14
爬取时间: 2025-04-27 23:15:19
来源: Huawei Developer
组件按照布局的要求依次排列，构成应用的页面。在声明式UI中，所有的页面都是由自定义组件构成，开发者可以根据自己的需求，选择合适的布局进行页面开发。
布局指用特定的组件或者属性来管理用户页面所放置UI组件的大小和位置。在实际的开发过程中，需要遵守以下流程保证整体的布局效果：
-  确定页面的布局结构。
-  分析页面中的元素构成。
-  选用适合的布局容器组件或属性控制页面中各个元素的位置和大小。
布局结构
布局通常为分层结构，一个常见的页面结构如下所示：
图1常见页面结构图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170239.83552623743646809396103865006396:50001231000000:2800:37AE0CD7019DA7E9F2E8F8A31EA3066FEEB5F5BBF21F8D854D61C7D021B195A8.png)
为实现上述效果，开发者需要在页面中声明对应的元素。其中，Page表示页面的根节点，Column/Row等元素为系统组件。针对不同的页面结构，ArkUI提供了不同的布局组件来帮助开发者实现对应布局的效果，例如Row用于实现线性布局。
布局元素的组成
布局相关的容器组件可形成对应的布局效果。例如，List组件可构成线性布局。
图2布局元素组成图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170239.68746597209934708675843925705565:50001231000000:2800:A9BC2952F425A66BAA2A74A14A8A08B059D3CBFADC9371EA291131896B8366C1.png)
-  组件区域（蓝区方块）：组件区域表示组件的大小，width、height属性用于设置组件区域的大小。
-  组件内容区（黄色方块）：组件内容区大小为组件区域大小减去组件的border值，组件内容区大小会作为组件内容（或者子组件）进行大小测算时的布局测算限制。
-  组件内容（绿色方块）：组件内容本身占用的大小，比如文本内容占用的大小。组件内容和组件内容区不一定匹配，比如设置了固定的width和height，此时组件内容的大小就是设置的width和height减去padding和border值，但文本内容则是通过文本布局引擎测算后得到的大小，可能出现文本真实大小小于设置的组件内容区大小。当组件内容和组件内容区大小不一致时，align属性生效，定义组件内容在组件内容区的对齐方式，如居中对齐。
-  组件布局边界（虚线部分）：组件通过margin属性设置外边距时，组件布局边界就是组件区域加上margin的大小。
如何选择布局
声明式UI提供了以下10种常见布局，开发者可根据实际应用场景选择合适的布局进行页面开发。
| 布局 | 应用场景 |
| --- | --- |
| 线性布局（Row、Column） | 如果布局内子元素超过1个时，且能够以某种方式线性排列时优先考虑此布局。 |
| 层叠布局（Stack） | 组件需要有堆叠效果时优先考虑此布局。层叠布局的堆叠效果不会占用或影响其他同容器内子组件的布局空间。例如Panel作为子组件弹出时将其他组件覆盖更为合理，则优先考虑在外层使用堆叠布局。 |
| 弹性布局（Flex） | 弹性布局是与线性布局类似的布局方式。区别在于弹性布局默认能够使子组件压缩或拉伸。在子组件需要计算拉伸或压缩比例时优先使用此布局，可使得多个容器内子组件能有更好的视觉上的填充效果。 |
| 相对布局（RelativeContainer） | 相对布局是在二维空间中的布局方式，不需要遵循线性布局的规则，布局方式更为自由。通过在子组件上设置锚点规则（AlignRules）使子组件能够将自己在横轴、纵轴中的位置与容器或容器内其他子组件的位置对齐。设置的锚点规则可以天然支持子元素压缩、拉伸、堆叠或形成多行效果。在页面元素分布复杂或通过线性布局会使容器嵌套层数过深时推荐使用。 |
| 栅格布局（GridRow、GridCol） | 栅格是多设备场景下通用的辅助定位工具，可将空间分割为有规律的栅格。栅格不同于网格布局固定的空间划分，可以实现不同设备下不同的布局，空间划分更随心所欲，从而显著降低适配不同屏幕尺寸的设计及开发成本，使得整体设计和开发流程更有秩序和节奏感，同时也保证多设备上应用显示的协调性和一致性，提升用户体验。推荐内容相同但布局不同时使用。 |
| 媒体查询（@ohos.mediaquery） | 媒体查询可根据不同设备类型或同设备不同状态修改应用的样式。例如根据设备和应用的不同属性信息设计不同的布局，以及屏幕发生动态改变时更新应用的页面布局。 |
| 列表（List） | 使用列表可以高效地显示结构化、可滚动的信息。在ArkUI中，列表具有垂直和水平布局能力和自适应交叉轴方向上排列个数的布局能力，超出屏幕时可以滚动。列表适合用于呈现同类数据类型或数据类型集，例如图片和文本。 |
| 网格（Grid） | 网格布局具有较强的页面均分能力、子元素占比控制能力。网格布局可以控制元素所占的网格数量、设置子元素横跨几行或者几列，当网格容器尺寸发生变化时，所有子元素以及间距等比例调整。推荐在需要按照固定比例或者均匀分配空间的布局场景下使用，例如计算器、相册、日历等。 |
| 轮播（Swiper） | 轮播组件通常用于实现广告轮播、图片预览等。 |
| 选项卡（Tabs） | 选项卡可以在一个页面内快速实现视图内容的切换，一方面提升查找信息的效率，另一方面精简用户单次获取到的信息量。 |
布局位置
position、offset等属性影响了布局容器相对于自身或其他组件的位置。
| 定位能力 | 使用场景 | 实现方式 |
| --- | --- | --- |
| 绝对定位 | 对于不同尺寸的设备，使用绝对定位的适应性会比较差，在屏幕的适配上有缺陷。 | 使用position实现绝对定位，设置元素左上角相对于父容器左上角偏移位置。在布局容器中，设置该属性不影响父容器布局，仅在绘制时进行位置调整。 |
| 相对定位 | 相对定位不脱离文档流，即原位置依然保留，不影响元素本身的特性，仅相对于原位置进行偏移。 | 使用offset可以实现相对定位，设置元素相对于自身的偏移量。设置该属性，不影响父容器布局，仅在绘制时进行位置调整。 |
对子元素的约束
-  拉伸：容器组件尺寸发生变化时，增加或减小的空间全部分配给容器组件内指定区域。 flexGrow和flexShrink属性：
-  缩放：子组件的宽高按照预设的比例，随容器组件发生变化，且变化过程中子组件的宽高比不变。 aspectRatio属性指定当前组件的宽高比来控制缩放，公式为：aspectRatio=width/height。
-  占比：子组件的宽高按照预设的比例，随祖先容器组件发生变化。 基于通用属性的两种实现方式： 子组件的宽高设置为百分比。 layoutWeight属性，使得子元素自适应占满剩余空间。
-  子组件的宽高设置为百分比。
-  layoutWeight属性，使得子元素自适应占满剩余空间。
-  隐藏：隐藏能力是指容器组件内的子组件，按照其预设的显示优先级，随容器组件尺寸变化显示或隐藏，其中相同显示优先级的子组件同时显示或隐藏。 通过displayPriority属性来控制组件的显示和隐藏。
1.  子组件的宽高设置为百分比。
2.  layoutWeight属性，使得子元素自适应占满剩余空间。
| 父组件与祖先组件宽高设置情况 | 子组件百分比 |
| --- | --- |
| 父组件设置宽或高 & 祖先组件未指定父组件宽或高 | 参考父组件的宽高 |
| 父组件设置宽或高 & 祖先组件指定父组件宽或高 | 参考祖先组件指定的父组件宽高 |
| 父组件未设置宽或高 & 祖先组件指定父组件宽或高 | 参考祖先组件指定的父组件宽高 |
| 父组件未设置宽或高 & 祖先组件未指定父组件宽或高 | 参考父组件的百分比参照。由于父组件未指定宽高，该百分比参照传递自祖先组件 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-build-layout-V14
爬取时间: 2025-04-27 23:15:33
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-layout-development-linear-V14
爬取时间: 2025-04-27 23:15:51
来源: Huawei Developer
概述
线性布局（LinearLayout）是开发中最常用的布局，通过线性容器Row和Column构建。线性布局是其他布局的基础，其子元素在线性方向上（水平方向和垂直方向）依次排列。线性布局的排列方向由所选容器组件决定，Column容器内子元素按照垂直方向排列，Row容器内子元素按照水平方向排列。根据不同的排列方向，开发者可选择使用Row或Column容器创建线性布局。
图1Column容器内子元素排列示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170239.28858168357569788388296642184383:50001231000000:2800:87EEBB40FE68820A1D6FD8434BAF258904BD11962198D2DE17D65A63F06A8943.png)
图2Row容器内子元素排列示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170239.91551912150849129352078154965687:50001231000000:2800:8DE36FDF463E6C1547DD4DFC111C7B916898A5F86583FE46CCDCF90AE1452905.png)
基本概念
-  布局容器：具有布局能力的容器组件，可以承载其他元素作为其子元素，布局容器会对其子元素进行尺寸计算和布局排列。
-  布局子元素：布局容器内部的元素。
-  主轴：线性布局容器在布局方向上的轴线，子元素默认沿主轴排列。Row容器主轴为水平方向，Column容器主轴为垂直方向。
-  交叉轴：垂直于主轴方向的轴线。Row容器交叉轴为垂直方向，Column容器交叉轴为水平方向。
-  间距：布局子元素的间距。
布局子元素在排列方向上的间距
在布局容器内，可以通过space属性设置排列方向上子元素的间距，使各子元素在排列方向上有等间距效果。
Column容器内排列方向上的间距
图3Column容器内排列方向的间距图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170239.68203885928417921148642101139616:50001231000000:2800:0E1A833D60385540A93CC24FF0F77A8B72A4A8325E7D945BF9B0477F260D1270.png)
```typescript
Column({ space: 20 }) {
Text('space: 20').fontSize(15).fontColor(Color.Gray).width('90%')
Row().width('90%').height(50).backgroundColor(0xF5DEB3)
Row().width('90%').height(50).backgroundColor(0xD2B48C)
Row().width('90%').height(50).backgroundColor(0xF5DEB3)
}.width('100%')
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170239.63957478919765904158840003979965:50001231000000:2800:1642AF0859A7FA3146781788A930DEBCDB3BFEA847C9E8577F0890E8CE8ACC11.png)
Row容器内排列方向上的间距
图4Row容器内排列方向的间距图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170239.13069581972268660817356618004337:50001231000000:2800:6787C639720D48AB89F671931FD6C8DFDCDB30EF3BF0C28A71351958F5A9A21E.png)
```typescript
Row({ space: 35 }) {
Text('space: 35').fontSize(15).fontColor(Color.Gray)
Row().width('10%').height(150).backgroundColor(0xF5DEB3)
Row().width('10%').height(150).backgroundColor(0xD2B48C)
Row().width('10%').height(150).backgroundColor(0xF5DEB3)
}.width('90%')
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170239.82087458032701963776140417211873:50001231000000:2800:76FE87FA13E6A6B6DF0FC08FF1478BF11EB97703FEDEDA3B7DD526CC7337608A.png)
布局子元素在交叉轴上的对齐方式
在布局容器内，可以通过alignItems属性设置子元素在交叉轴（排列方向的垂直方向）上的对齐方式。且在各类尺寸屏幕中，表现一致。其中，交叉轴为垂直方向时，取值为VerticalAlign类型，水平方向取值为HorizontalAlign类型。
alignSelf属性用于控制单个子元素在容器交叉轴上的对齐方式，其优先级高于alignItems属性，如果设置了alignSelf属性，则在单个子元素上会覆盖alignItems属性。
Column容器内子元素在水平方向上的排列
图5Column容器内子元素在水平方向上的排列图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170239.64962209886912787220724347297123:50001231000000:2800:6E210D84F51AD8A3B735875594E18BE570104CF9D20326CB141CCAD6DED8C98B.png)
-  HorizontalAlign.Start：子元素在水平方向左对齐。
```typescript
Column({}) {
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
Column() {
}.width('80%').height(50).backgroundColor(0xD2B48C)
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
}.width('100%').alignItems(HorizontalAlign.Start).backgroundColor('rgb(242,242,242)')
```
-  HorizontalAlign.Center：子元素在水平方向居中对齐。
```typescript
Column({}) {
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
Column() {
}.width('80%').height(50).backgroundColor(0xD2B48C)
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
}.width('100%').alignItems(HorizontalAlign.Center).backgroundColor('rgb(242,242,242)')
```
-  HorizontalAlign.End：子元素在水平方向右对齐。
```typescript
Column({}) {
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
Column() {
}.width('80%').height(50).backgroundColor(0xD2B48C)
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
}.width('100%').alignItems(HorizontalAlign.End).backgroundColor('rgb(242,242,242)')
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170239.60788278414995977063610730292198:50001231000000:2800:7BD2BB0B9A1920C3CB1C2B17397CB2007C400F0D2166E626FEA57394BFA49A55.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.76655501503064775551772070765879:50001231000000:2800:5B7F5DDAD3C1702AB7CCC27BABEF366621D0E69EAA6175B4EC47715D51D1B784.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.55305818878809423831855577817031:50001231000000:2800:1610D559A879261E8705576BA67F310045E89A982FB710C9E2D15F0201E58D8B.png)
Row容器内子元素在垂直方向上的排列
图6Row容器内子元素在垂直方向上的排列图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.43870137269585975056988326042356:50001231000000:2800:8AE36D342D659D0A9B1B4A50D1A2786B478AB2F07A5F6490182528ACCE51F9E4.png)
-  VerticalAlign.Top：子元素在垂直方向顶部对齐。
```typescript
Row({}) {
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
Column() {
}.width('20%').height(30).backgroundColor(0xD2B48C)
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
}.width('100%').height(200).alignItems(VerticalAlign.Top).backgroundColor('rgb(242,242,242)')
```
-  VerticalAlign.Center：子元素在垂直方向居中对齐。
```typescript
Row({}) {
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
Column() {
}.width('20%').height(30).backgroundColor(0xD2B48C)
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
}.width('100%').height(200).alignItems(VerticalAlign.Center).backgroundColor('rgb(242,242,242)')
```
-  VerticalAlign.Bottom：子元素在垂直方向底部对齐。
```typescript
Row({}) {
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
Column() {
}.width('20%').height(30).backgroundColor(0xD2B48C)
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
}.width('100%').height(200).alignItems(VerticalAlign.Bottom).backgroundColor('rgb(242,242,242)')
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.18760251949346710106043833635738:50001231000000:2800:F31262AC56A7C096E0CF11C48ADDDFD55B8FC696547B7090FDDA0E3EDF1D03A9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.92166682911893476711668018239323:50001231000000:2800:67BF6BA847B328B53A73F0E89E5B8754458737567F6A4DA7885E502D95C55FDD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.89733658115955992012703179406395:50001231000000:2800:34487F7468C9728FCA91FEC2411D549AC5A080785D18DE91C2CE0726A448CFD1.png)
布局子元素在主轴上的排列方式
在布局容器内，可以通过justifyContent属性设置子元素在容器主轴上的排列方式。可以从主轴起始位置开始排布，也可以从主轴结束位置开始排布，或者均匀分割主轴的空间。
Column容器内子元素在垂直方向上的排列
图7Column容器内子元素在垂直方向上的排列图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.16307147385183479686982401787521:50001231000000:2800:AB88A5827B5D523C01114372CCE61D568742F538D2A095F1332972955162A4EC.png)
-  justifyContent(FlexAlign.Start)：元素在垂直方向首端对齐，第一个元素与行首对齐，同时后续的元素与前一个对齐。
```typescript
Column({}) {
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
Column() {
}.width('80%').height(50).backgroundColor(0xD2B48C)
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
}.width('100%').height(300).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.Start)
```
-  justifyContent(FlexAlign.Center)：元素在垂直方向中心对齐，第一个元素与行首的距离与最后一个元素与行尾距离相同。
```typescript
Column({}) {
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
Column() {
}.width('80%').height(50).backgroundColor(0xD2B48C)
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
}.width('100%').height(300).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.Center)
```
-  justifyContent(FlexAlign.End)：元素在垂直方向尾部对齐，最后一个元素与行尾对齐，其他元素与后一个对齐。
```typescript
Column({}) {
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
Column() {
}.width('80%').height(50).backgroundColor(0xD2B48C)
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
}.width('100%').height(300).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.End)
```
-  justifyContent(FlexAlign.SpaceBetween)：垂直方向均匀分配元素，相邻元素之间距离相同。第一个元素与行首对齐，最后一个元素与行尾对齐。
```typescript
Column({}) {
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
Column() {
}.width('80%').height(50).backgroundColor(0xD2B48C)
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
}.width('100%').height(300).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.SpaceBetween)
```
-  justifyContent(FlexAlign.SpaceAround)：垂直方向均匀分配元素，相邻元素之间距离相同。第一个元素到行首的距离和最后一个元素到行尾的距离是相邻元素之间距离的一半。
```typescript
Column({}) {
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
Column() {
}.width('80%').height(50).backgroundColor(0xD2B48C)
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
}.width('100%').height(300).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.SpaceAround)
```
-  justifyContent(FlexAlign.SpaceEvenly)：垂直方向均匀分配元素，相邻元素之间的距离、第一个元素与行首的间距、最后一个元素到行尾的间距都完全一样。
```typescript
Column({}) {
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
Column() {
}.width('80%').height(50).backgroundColor(0xD2B48C)
Column() {
}.width('80%').height(50).backgroundColor(0xF5DEB3)
}.width('100%').height(300).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.SpaceEvenly)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.53609401578751879972921379127072:50001231000000:2800:7021A2011AE84B9E7F6DBF1501398D1289B4D408D37F3A24EC66EF258528B34E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.20105955035351200635917303175799:50001231000000:2800:BD5CA879F5865003B6B4A5CB9AEE06595F6D7574F5627759E2EAF9E6A59C695D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.54986645069408752548403192760177:50001231000000:2800:F39B1AA85DFAC0B559E05B7F5089628C36946DBD28769CDF158F3A14AD6F2FA0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.10817448003658483716493486792612:50001231000000:2800:40B6F726B895DA1241B6524A66811BFADDE18A5B2FCC4F31266D73B161AA534B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.88838008614851109905450315603304:50001231000000:2800:565E25FC7DC6E46FC52C1E0CB6AC1BD1227D2527E25E4F99F326F1C6DC65B2A8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.04791207654089424383373565180535:50001231000000:2800:AFF9D4FB9707CCE0B84F11921B48C95D6CE033B0E9A9FCEF3A5D6FA4A326818E.png)
Row容器内子元素在水平方向上的排列
图8Row容器内子元素在水平方向上的排列图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.61105385141416078055116447073777:50001231000000:2800:D176D827ABD6E155E2D9F50743783566E562AC35E16B89DD310F1C544FEC1538.png)
-  justifyContent(FlexAlign.Start)：元素在水平方向首端对齐，第一个元素与行首对齐，同时后续的元素与前一个对齐。
```typescript
Row({}) {
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
Column() {
}.width('20%').height(30).backgroundColor(0xD2B48C)
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
}.width('100%').height(200).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.Start)
```
-  justifyContent(FlexAlign.Center)：元素在水平方向中心对齐，第一个元素与行首的距离与最后一个元素与行尾距离相同。
```typescript
Row({}) {
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
Column() {
}.width('20%').height(30).backgroundColor(0xD2B48C)
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
}.width('100%').height(200).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.Center)
```
-  justifyContent(FlexAlign.End)：元素在水平方向尾部对齐，最后一个元素与行尾对齐，其他元素与后一个对齐。
```typescript
Row({}) {
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
Column() {
}.width('20%').height(30).backgroundColor(0xD2B48C)
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
}.width('100%').height(200).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.End)
```
-  justifyContent(FlexAlign.SpaceBetween)：水平方向均匀分配元素，相邻元素之间距离相同。第一个元素与行首对齐，最后一个元素与行尾对齐。
```typescript
Row({}) {
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
Column() {
}.width('20%').height(30).backgroundColor(0xD2B48C)
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
}.width('100%').height(200).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.SpaceBetween)
```
-  justifyContent(FlexAlign.SpaceAround)：水平方向均匀分配元素，相邻元素之间距离相同。第一个元素到行首的距离和最后一个元素到行尾的距离是相邻元素之间距离的一半。
```typescript
Row({}) {
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
Column() {
}.width('20%').height(30).backgroundColor(0xD2B48C)
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
}.width('100%').height(200).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.SpaceAround)
```
-  justifyContent(FlexAlign.SpaceEvenly)：水平方向均匀分配元素，相邻元素之间的距离、第一个元素与行首的间距、最后一个元素到行尾的间距都完全一样。
```typescript
Row({}) {
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
Column() {
}.width('20%').height(30).backgroundColor(0xD2B48C)
Column() {
}.width('20%').height(30).backgroundColor(0xF5DEB3)
}.width('100%').height(200).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.SpaceEvenly)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170240.45558266440139902936024600781159:50001231000000:2800:4A02327F7C114D5EDFEC1DA2B305DBBC5BB68689BAAB0EBCDD59FE8DB827DA75.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.93687019231645271510820045010153:50001231000000:2800:763CE56C98121FACFEC39AC7134440CFCD5C466BB4E67B4E0F036943EE62E7C3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.18853332397553727029550108562706:50001231000000:2800:832C0473E9FC8BA921E7CD2B70DFD05FF708F3715DB3E7C5B2B82FF9D0AA78BB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.15301186452935728870355496534931:50001231000000:2800:CC3CA59D2DDA50987F0C08610574AD35D0C54210A0710D57F0B6EAD7C8A3D816.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.49255715448449664599348931038956:50001231000000:2800:7322B5C8A50501AA545B3A8F8E6D18239F6E8DB2E6CB63BA26B3FC21F781F7FF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.79376122813745415383233761006216:50001231000000:2800:09E995342DF58AFC3C1A294D52B41A334299E6D88B123222AFD493E8E379D283.png)
自适应拉伸
在线性布局下，常用空白填充组件Blank，在容器主轴方向自动填充空白空间，达到自适应拉伸效果。Row和Column作为容器，只需要添加宽高为百分比，当屏幕宽高发生变化时，会产生自适应效果。
```typescript
@Entry
@Component
struct BlankExample {
build() {
Column() {
Row() {
Text('Bluetooth').fontSize(18)
Blank()
Toggle({ type: ToggleType.Switch, isOn: true })
}.backgroundColor(0xFFFFFF).borderRadius(15).padding({ left: 12 }).width('100%')
}.backgroundColor(0xEFEFEF).padding(20).width('100%')
}
}
```
图9竖屏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.45175919219826091183224120375940:50001231000000:2800:84FF4C9A36461BE69D7CA9DBF55FB3BF17051F83FC602778B185E49FD53BEC93.png)
图10横屏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.17646384234486632811862217351364:50001231000000:2800:54CFCC6DF11E7F41E3D6555136F7A27E7FD336A2B963D95E44B57DC5769AD9AA.png)
自适应缩放
自适应缩放是指子元素随容器尺寸的变化而按照预设的比例自动调整尺寸，适应各种不同大小的设备。在线性布局中，可以使用以下两种方法实现自适应缩放。
-  父容器尺寸确定时，使用layoutWeight属性设置子元素和兄弟元素在主轴上的权重，忽略元素本身尺寸设置，使它们在任意尺寸的设备下自适应占满剩余空间。 图11横屏 图12竖屏
```typescript
@Entry
@Component
struct layoutWeightExample {
build() {
Column() {
Text('1:2:3').width('100%')
Row() {
Column() {
Text('layoutWeight(1)')
.textAlign(TextAlign.Center)
}.layoutWeight(1).backgroundColor(0xF5DEB3).height('100%')
Column() {
Text('layoutWeight(2)')
.textAlign(TextAlign.Center)
}.layoutWeight(2).backgroundColor(0xD2B48C).height('100%')
Column() {
Text('layoutWeight(3)')
.textAlign(TextAlign.Center)
}.layoutWeight(3).backgroundColor(0xF5DEB3).height('100%')
}.backgroundColor(0xffd306).height('30%')
Text('2:5:3').width('100%')
Row() {
Column() {
Text('layoutWeight(2)')
.textAlign(TextAlign.Center)
}.layoutWeight(2).backgroundColor(0xF5DEB3).height('100%')
Column() {
Text('layoutWeight(5)')
.textAlign(TextAlign.Center)
}.layoutWeight(5).backgroundColor(0xD2B48C).height('100%')
Column() {
Text('layoutWeight(3)')
.textAlign(TextAlign.Center)
}.layoutWeight(3).backgroundColor(0xF5DEB3).height('100%')
}.backgroundColor(0xffd306).height('30%')
}
}
}
```
-  父容器尺寸确定时，使用百分比设置子元素和兄弟元素的宽度，使他们在任意尺寸的设备下保持固定的自适应占比。 图13横屏 图14竖屏
```typescript
@Entry
@Component
struct WidthExample {
build() {
Column() {
Row() {
Column() {
Text('left width 20%')
.textAlign(TextAlign.Center)
}.width('20%').backgroundColor(0xF5DEB3).height('100%')
Column() {
Text('center width 50%')
.textAlign(TextAlign.Center)
}.width('50%').backgroundColor(0xD2B48C).height('100%')
Column() {
Text('right width 30%')
.textAlign(TextAlign.Center)
}.width('30%').backgroundColor(0xF5DEB3).height('100%')
}.backgroundColor(0xffd306).height('30%')
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.60228595931069393631973020407583:50001231000000:2800:271447FB306E4329C5670448A3DA248689DDD60E3A0DBC05EE4EC8480E7BA8D7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.64273407587213585337769350365806:50001231000000:2800:F2489B326BF57D2A916688F2CA103D089978D69249C3E1002CC3F9EE93216896.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.13717766285868988585437195829806:50001231000000:2800:3AE9530AC94AF3EE07C7FA992C2157E9D4282E146F774BFC26BBE7B943A91AB4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.78322984657568203907397337184994:50001231000000:2800:77042B69F51214FCFCB3833F9F4C20E16308DC2E47D684CAF414FACAB686D27A.png)
自适应延伸
自适应延伸是指在不同尺寸设备下，当页面的内容超出屏幕大小而无法完全显示时，可以通过滚动条进行拖动展示。这种方法适用于线性布局中内容无法一屏展示的场景。通常有以下两种实现方式。
-  在List中添加滚动条：当List子项过多一屏放不下时，可以将每一项子元素放置在不同的组件中，通过滚动条进行拖动展示。可以通过scrollBar属性设置滚动条的常驻状态，edgeEffect属性设置拖动到内容最末端的回弹效果。
-  使用Scroll组件：在线性布局中，开发者可以进行垂直方向或者水平方向的布局。当一屏无法完全显示时，可以在Column或Row组件的外层包裹一个可滚动的容器组件Scroll来实现可滑动的线性布局。 垂直方向布局中使用Scroll组件： 水平方向布局中使用Scroll组件：
```typescript
@Entry
@Component
struct ScrollExample {
scroller: Scroller = new Scroller();
private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
build() {
Scroll(this.scroller) {
Column() {
ForEach(this.arr, (item?:number|undefined) => {
if(item){
Text(item.toString())
.width('90%')
.height(150)
.backgroundColor(0xFFFFFF)
.borderRadius(15)
.fontSize(16)
.textAlign(TextAlign.Center)
.margin({ top: 10 })
}
}, (item:number) => item.toString())
}.width('100%')
}
.backgroundColor(0xDCDCDC)
.scrollable(ScrollDirection.Vertical) // 滚动方向为垂直方向
.scrollBar(BarState.On) // 滚动条常驻显示
.scrollBarColor(Color.Gray) // 滚动条颜色
.scrollBarWidth(10) // 滚动条宽度
.edgeEffect(EdgeEffect.Spring) // 滚动到边沿后回弹
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.14714790331543022760798636114722:50001231000000:2800:115EE67D8BDEF5139038F8BAEAC815B9317E016AB78436B3BE47CBA6A4E107D8.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.27556857821153506579794121961760:50001231000000:2800:C5A1E377ED6C1C434305570D0E3B60354A82448742C276ABD9D63A62E940CCED.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-layout-development-stack-layout-V14
爬取时间: 2025-04-27 23:16:05
来源: Huawei Developer
概述
层叠布局（StackLayout）用于在屏幕上预留一块区域来显示组件中的元素，提供元素可以重叠的布局。层叠布局通过Stack容器组件实现位置的固定定位与层叠，容器中的子元素依次入栈，后一个子元素覆盖前一个子元素，子元素可以叠加，也可以设置位置。
层叠布局具有较强的页面层叠、位置定位能力，其使用场景有广告、卡片层叠效果等。
如图1，Stack作为容器，容器内的子元素的顺序为Item1->Item2->Item3。
图1层叠布局
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170241.01430503554279198543027309666606:50001231000000:2800:16F43AC1B13E55F67762B846F04FCD225C1D519E603E5F042838C6E260EF0F98.png)
开发布局
Stack组件为容器组件，容器内可包含各种子元素。其中子元素默认进行居中堆叠。子元素被约束在Stack下，进行自己的样式定义以及排列。
```typescript
// xxx.ets
let MTop:Record<string,number> = { 'top': 50 }
@Entry
@Component
struct StackExample {
build() {
Column(){
Stack({ }) {
Column(){}.width('90%').height('100%').backgroundColor('#ff58b87c')
Text('text').width('60%').height('60%').backgroundColor('#ffc3f6aa')
Button('button').width('30%').height('30%').backgroundColor('#ff8ff3eb').fontColor('#000')
}.width('100%').height(150).margin(MTop)
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170242.83269941562111571893419910206714:50001231000000:2800:6DFFF68F51F5FEAB23C49785F9543D4136563D57E6A4DBD38F8B80C07EA8F878.png)
对齐方式
Stack组件通过alignContent参数实现位置的相对移动。如图2所示，支持九种对齐方式。
图2Stack容器内元素的对齐方式
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170242.15149894428679419671503513208660:50001231000000:2800:4D01BEFFF62E8B393EA4A6E74965CCFD7AF0C78B9349BA6E603B8FF9333E5AF2.png)
```typescript
// xxx.ets
@Entry
@Component
struct StackExample {
build() {
Stack({ alignContent: Alignment.TopStart }) {
Text('Stack').width('90%').height('100%').backgroundColor('#e1dede').align(Alignment.BottomEnd)
Text('Item 1').width('70%').height('80%').backgroundColor(0xd2cab3).align(Alignment.BottomEnd)
Text('Item 2').width('50%').height('60%').backgroundColor(0xc1cbac).align(Alignment.BottomEnd)
}.width('100%').height(150).margin({ top: 5 })
}
}
```
Z序控制
Stack容器中兄弟组件显示层级关系可以通过Z序控制的zIndex属性改变。zIndex值越大，显示层级越高，即zIndex值大的组件会覆盖在zIndex值小的组件上方。
在层叠布局中，如果后面子元素尺寸大于前面子元素尺寸，则前面子元素完全隐藏。
```typescript
Stack({ alignContent: Alignment.BottomStart }) {
Column() {
Text('Stack子元素1').textAlign(TextAlign.End).fontSize(20)
}.width(100).height(100).backgroundColor(0xffd306)
Column() {
Text('Stack子元素2').fontSize(20)
}.width(150).height(150).backgroundColor(Color.Pink)
Column() {
Text('Stack子元素3').fontSize(20)
}.width(200).height(200).backgroundColor(Color.Grey)
}.width(350).height(350).backgroundColor(0xe0e0e0)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170242.73766178075325347731004650411120:50001231000000:2800:BE28E01A17B6DF1D499A6DACB006B07848CEA28C38709B78F26B9518CC945DBA.png)
上图中，最后的子元素3的尺寸大于前面的所有子元素，所以，前面两个元素完全隐藏。改变子元素1，子元素2的zIndex属性后，可以将元素展示出来。
```typescript
Stack({ alignContent: Alignment.BottomStart }) {
Column() {
Text('Stack子元素1').fontSize(20)
}.width(100).height(100).backgroundColor(0xffd306).zIndex(2)
Column() {
Text('Stack子元素2').fontSize(20)
}.width(150).height(150).backgroundColor(Color.Pink).zIndex(1)
Column() {
Text('Stack子元素3').fontSize(20)
}.width(200).height(200).backgroundColor(Color.Grey)
}.width(350).height(350).backgroundColor(0xe0e0e0)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170242.71699050542364470140860257311491:50001231000000:2800:53700E4BCC78E5B296B34FD4CBBB8B796B93C619EEB10649362623A87C11F219.png)
场景示例
使用层叠布局快速搭建页面。
```typescript
@Entry
@Component
struct StackSample {
private arr: string[] = ['APP1', 'APP2', 'APP3', 'APP4', 'APP5', 'APP6', 'APP7', 'APP8'];
build() {
Stack({ alignContent: Alignment.Bottom }) {
Flex({ wrap: FlexWrap.Wrap }) {
ForEach(this.arr, (item:string) => {
Text(item)
.width(100)
.height(100)
.fontSize(16)
.margin(10)
.textAlign(TextAlign.Center)
.borderRadius(10)
.backgroundColor(0xFFFFFF)
}, (item:string):string => item)
}.width('100%').height('100%')
Flex({ justifyContent: FlexAlign.SpaceAround, alignItems: ItemAlign.Center }) {
Text('联系人').fontSize(16)
Text('设置').fontSize(16)
Text('短信').fontSize(16)
}
.width('50%')
.height(50)
.backgroundColor('#16302e2e')
.margin({ bottom: 15 })
.borderRadius(15)
}.width('100%').height('100%').backgroundColor('#CFD0CF')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170242.97563624518669640689279774520561:50001231000000:2800:C87DFD4E359D3830BED994123FA09E03B72E655FE048CBCD4B8B92A3D47469D8.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-layout-development-flex-layout-V14
爬取时间: 2025-04-27 23:16:19
来源: Huawei Developer
概述
弹性布局（Flex）提供更加有效的方式对容器中的子元素进行排列、对齐和分配剩余空间。常用于页面头部导航栏的均匀分布、页面框架的搭建、多行数据的排列等。
容器默认存在主轴与交叉轴，子元素默认沿主轴排列，子元素在主轴方向的尺寸称为主轴尺寸，在交叉轴方向的尺寸称为交叉轴尺寸。
图1主轴为水平方向的Flex容器示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170242.07517846184137949106787052029108:50001231000000:2800:F23765143BC2E3D7D150EB3BFA2A02C77CAE83C85E347814562630B6CB12679F.png)
基本概念
-  主轴：Flex组件布局方向的轴线，子元素默认沿着主轴排列。主轴开始的位置称为主轴起始点，结束位置称为主轴结束点。
-  交叉轴：垂直于主轴方向的轴线。交叉轴开始的位置称为交叉轴起始点，结束位置称为交叉轴结束点。
布局方向
在弹性布局中，容器的子元素可以按照任意方向排列。通过设置参数direction，可以决定主轴的方向，从而控制子元素的排列方向。
图2弹性布局方向图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170242.89847725181031715907541782871078:50001231000000:2800:0E7AD67B7E6772A14A547F2CA63E2D22AAA909D11A4E7546C788049340FC41D5.png)
-  FlexDirection.Row（默认值）：主轴为水平方向，子元素从起始端沿着水平方向开始排布。
```typescript
Flex({ direction: FlexDirection.Row }) {
Text('1').width('33%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('33%').height(50).backgroundColor(0xD2B48C)
Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)
}
.height(70)
.width('90%')
.padding(10)
.backgroundColor(0xAFEEEE)
```
-  FlexDirection.RowReverse：主轴为水平方向，子元素从终点端沿着FlexDirection. Row相反的方向开始排布。
```typescript
Flex({ direction: FlexDirection.RowReverse }) {
Text('1').width('33%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('33%').height(50).backgroundColor(0xD2B48C)
Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)
}
.height(70)
.width('90%')
.padding(10)
.backgroundColor(0xAFEEEE)
```
-  FlexDirection.Column：主轴为垂直方向，子元素从起始端沿着垂直方向开始排布。
```typescript
Flex({ direction: FlexDirection.Column }) {
Text('1').width('100%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('100%').height(50).backgroundColor(0xD2B48C)
Text('3').width('100%').height(50).backgroundColor(0xF5DEB3)
}
.height(70)
.width('90%')
.padding(10)
.backgroundColor(0xAFEEEE)
```
-  FlexDirection.ColumnReverse：主轴为垂直方向，子元素从终点端沿着FlexDirection. Column相反的方向开始排布。
```typescript
Flex({ direction: FlexDirection.ColumnReverse }) {
Text('1').width('100%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('100%').height(50).backgroundColor(0xD2B48C)
Text('3').width('100%').height(50).backgroundColor(0xF5DEB3)
}
.height(70)
.width('90%')
.padding(10)
.backgroundColor(0xAFEEEE)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170242.81298222378195245391526554486101:50001231000000:2800:4EF3107A8D9CD6B5B3F0109880D0BDAB14810173410631A5B92002F08A7E5F47.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170242.22415504395318809714800083957915:50001231000000:2800:AC6C72FCE1FE954B5B30DAD08834469504CC2578C338A4753F5C953AB1D228EC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170242.17116803002777755370717326919521:50001231000000:2800:0B31E51C46D736ECDE016E513F0EF23C7ECC7AEEC50B85F2C44BFA4922BECDD6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170242.91798389876641547231713976351191:50001231000000:2800:ADE85DA872CFACE7A421F69F3719AF2D712FB1AD490F8FD2B1E0DE6569C38C03.png)
布局换行
弹性布局分为单行布局和多行布局。默认情况下，Flex容器中的子元素都排在一条线（又称“轴线”）上。wrap属性控制当子元素主轴尺寸之和大于容器主轴尺寸时，Flex是单行布局还是多行布局。在多行布局时，通过交叉轴方向，确认新行排列方向。
-  FlexWrap. NoWrap（默认值）：不换行。如果子元素的宽度总和大于父元素的宽度，则子元素会被压缩宽度。
```typescript
Flex({ wrap: FlexWrap.NoWrap }) {
Text('1').width('50%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('50%').height(50).backgroundColor(0xD2B48C)
Text('3').width('50%').height(50).backgroundColor(0xF5DEB3)
}
.width('90%')
.padding(10)
.backgroundColor(0xAFEEEE)
```
-  FlexWrap. Wrap：换行，每一行子元素按照主轴方向排列。
```typescript
Flex({ wrap: FlexWrap.Wrap }) {
Text('1').width('50%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('50%').height(50).backgroundColor(0xD2B48C)
Text('3').width('50%').height(50).backgroundColor(0xD2B48C)
}
.width('90%')
.padding(10)
.backgroundColor(0xAFEEEE)
```
-  FlexWrap. WrapReverse：换行，每一行子元素按照主轴反方向排列。
```typescript
Flex({ wrap: FlexWrap.WrapReverse}) {
Text('1').width('50%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('50%').height(50).backgroundColor(0xD2B48C)
Text('3').width('50%').height(50).backgroundColor(0xF5DEB3)
}
.width('90%')
.padding(10)
.backgroundColor(0xAFEEEE)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170242.02322326917285795568539388550166:50001231000000:2800:BB8340683BD19859CA0AFD808420CA3F0C561A7C8093D878DBCE782C71504674.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.57117779181213866605746877304930:50001231000000:2800:8F61202709DF2B6DC4872D1A0DEDB67BDB8B8B66DFCCE227ED543103443C25FC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.58541588693519463202360057806189:50001231000000:2800:7E404A82C4D3A67A10E6DB16629D8EFD90B4689D99FD451CE93B240722A1FEF8.png)
主轴对齐方式
通过justifyContent参数设置子元素在主轴方向的对齐方式。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.94685429632763430873818975031121:50001231000000:2800:B132350C785FB6BC07E46AAB504FAB1AB5E6BF8FB7A082D7741FBFB589A10632.png)
-  FlexAlign.Start（默认值）：子元素在主轴方向起始端对齐， 第一个子元素与父元素边沿对齐，其他元素与前一个元素对齐。
```typescript
Flex({ justifyContent: FlexAlign.Start }) {
Text('1').width('20%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('20%').height(50).backgroundColor(0xD2B48C)
Text('3').width('20%').height(50).backgroundColor(0xF5DEB3)
}
.width('90%')
.padding({ top: 10, bottom: 10 })
.backgroundColor(0xAFEEEE)
```
-  FlexAlign.Center：子元素在主轴方向居中对齐。
```typescript
Flex({ justifyContent: FlexAlign.Center }) {
Text('1').width('20%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('20%').height(50).backgroundColor(0xD2B48C)
Text('3').width('20%').height(50).backgroundColor(0xF5DEB3)
}
.width('90%')
.padding({ top: 10, bottom: 10 })
.backgroundColor(0xAFEEEE)
```
-  FlexAlign.End：子元素在主轴方向终点端对齐, 最后一个子元素与父元素边沿对齐，其他元素与后一个元素对齐。
```typescript
Flex({ justifyContent: FlexAlign.End }) {
Text('1').width('20%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('20%').height(50).backgroundColor(0xD2B48C)
Text('3').width('20%').height(50).backgroundColor(0xF5DEB3)
}
.width('90%')
.padding({ top: 10, bottom: 10 })
.backgroundColor(0xAFEEEE)
```
-  FlexAlign.SpaceBetween：Flex主轴方向均匀分配弹性元素，相邻子元素之间距离相同。第一个子元素和最后一个子元素与父元素边沿对齐。
```typescript
Flex({ justifyContent: FlexAlign.SpaceBetween }) {
Text('1').width('20%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('20%').height(50).backgroundColor(0xD2B48C)
Text('3').width('20%').height(50).backgroundColor(0xF5DEB3)
}
.width('90%')
.padding({ top: 10, bottom: 10 })
.backgroundColor(0xAFEEEE)
```
-  FlexAlign.SpaceAround：Flex主轴方向均匀分配弹性元素，相邻子元素之间距离相同。第一个子元素到主轴起始端的距离和最后一个子元素到主轴终点端的距离是相邻元素之间距离的一半。
```typescript
Flex({ justifyContent: FlexAlign.SpaceAround }) {
Text('1').width('20%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('20%').height(50).backgroundColor(0xD2B48C)
Text('3').width('20%').height(50).backgroundColor(0xF5DEB3)
}
.width('90%')
.padding({ top: 10, bottom: 10 })
.backgroundColor(0xAFEEEE)
```
-  FlexAlign.SpaceEvenly：Flex主轴方向元素等间距布局，相邻子元素之间的间距、第一个子元素与主轴起始端的间距、最后一个子元素到主轴终点端的间距均相等。
```typescript
Flex({ justifyContent: FlexAlign.SpaceEvenly }) {
Text('1').width('20%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('20%').height(50).backgroundColor(0xD2B48C)
Text('3').width('20%').height(50).backgroundColor(0xF5DEB3)
}
.width('90%')
.padding({ top: 10, bottom: 10 })
.backgroundColor(0xAFEEEE)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.37034082048241810425659041386731:50001231000000:2800:63C02EFB5E1C146FD760403431B3AD5DF063E4F91938B592F07672EC985CACD9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.56289127090532560845976572730734:50001231000000:2800:4F0F449E41193FE1F87D46AD774F5CC96B81933A3CB41969181069D4E00AFEC9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.51583542610616431271133772987179:50001231000000:2800:279C2353AA0761BD216B9B3DED0C53A1509D27CDBE60553A22E78D11A2F4B1A4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.16550154682097938752261677990406:50001231000000:2800:89C37AC217021EA844CE3E4E6863E20D14E8908E8970D4141180DDA0A16816CC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.76107489112743933690731643021864:50001231000000:2800:869A9A7773B53609F5600EB997CFE4E926ED9AEEAC6F81DD9ADF458D7EFCFFFC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.09992717353611633748968905803132:50001231000000:2800:1B4962EB533A4009CDFB3A60B4DB14BA0D75B36DDBF352E75FE648992CE67E55.png)
交叉轴对齐方式
容器和子元素都可以设置交叉轴对齐方式，且子元素设置的对齐方式优先级较高。
容器组件设置交叉轴对齐
可以通过Flex组件的alignItems参数设置子元素在交叉轴的对齐方式。
-  ItemAlign.Auto：使用Flex容器中默认配置。
```typescript
Flex({ alignItems: ItemAlign.Auto }) {
Text('1').width('33%').height(30).backgroundColor(0xF5DEB3)
Text('2').width('33%').height(40).backgroundColor(0xD2B48C)
Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)
}
.size({ width: '90%', height: 80 })
.padding(10)
.backgroundColor(0xAFEEEE)
```
-  ItemAlign.Start：交叉轴方向首部对齐。
```typescript
Flex({ alignItems: ItemAlign.Start }) {
Text('1').width('33%').height(30).backgroundColor(0xF5DEB3)
Text('2').width('33%').height(40).backgroundColor(0xD2B48C)
Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)
}
.size({ width: '90%', height: 80 })
.padding(10)
.backgroundColor(0xAFEEEE)
```
-  ItemAlign.Center：交叉轴方向居中对齐。
```typescript
Flex({ alignItems: ItemAlign.Center }) {
Text('1').width('33%').height(30).backgroundColor(0xF5DEB3)
Text('2').width('33%').height(40).backgroundColor(0xD2B48C)
Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)
}
.size({ width: '90%', height: 80 })
.padding(10)
.backgroundColor(0xAFEEEE)
```
-  ItemAlign.End：交叉轴方向底部对齐。
```typescript
Flex({ alignItems: ItemAlign.End }) {
Text('1').width('33%').height(30).backgroundColor(0xF5DEB3)
Text('2').width('33%').height(40).backgroundColor(0xD2B48C)
Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)
}
.size({ width: '90%', height: 80 })
.padding(10)
.backgroundColor(0xAFEEEE)
```
-  ItemAlign.Stretch：交叉轴方向拉伸填充，在未设置尺寸时，拉伸到容器尺寸。
```typescript
Flex({ alignItems: ItemAlign.Stretch }) {
Text('1').width('33%').backgroundColor(0xF5DEB3)
Text('2').width('33%').backgroundColor(0xD2B48C)
Text('3').width('33%').backgroundColor(0xF5DEB3)
}
.size({ width: '90%', height: 80 })
.padding(10)
.backgroundColor(0xAFEEEE)
```
-  ItemAlign. Baseline：交叉轴方向文本基线对齐。
```typescript
Flex({ alignItems: ItemAlign.Baseline }) {
Text('1').width('33%').height(30).backgroundColor(0xF5DEB3)
Text('2').width('33%').height(40).backgroundColor(0xD2B48C)
Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)
}
.size({ width: '90%', height: 80 })
.padding(10)
.backgroundColor(0xAFEEEE)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.74921612105079014104385968700096:50001231000000:2800:F88715B9AEBF340F8946B0DD4459FAFE56907EAF104404418EBE0CE3DBE4F5F6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.36761982767572797949440605353449:50001231000000:2800:22A5AA1943FE2F7FE1C4B20D9CDE531E8144E42EC81E538A01C515EE904DF6CB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.12517953805095582356932197268075:50001231000000:2800:3E989EFCBEA5086EBB6725AE935270322DDFF63446A5D65F669644AF5E5CCCE5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.72672518564663264675282233609004:50001231000000:2800:F7312DD5AA9AF122103CB1EFF67CA7C695DA2C3E54639E902B1C9BBABCF469D4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.08538611906136494068301800477548:50001231000000:2800:367377824AC942716B6F8677E700793E47F9F0A2A57DFA6CB1217B497510275B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170243.41102124373664313715973638795660:50001231000000:2800:84B5A4F40860B39D7787001C54D0A5A5E18BF217A8C3600BD1FDDA42D47C57FC.png)
子元素设置交叉轴对齐
子元素的alignSelf属性也可以设置子元素在父容器交叉轴的对齐格式，且会覆盖Flex布局容器中alignItems配置。如下例所示：
```typescript
Flex({ direction: FlexDirection.Row, alignItems: ItemAlign.Center }) { // 容器组件设置子元素居中
Text('alignSelf Start').width('25%').height(80)
.alignSelf(ItemAlign.Start)
.backgroundColor(0xF5DEB3)
Text('alignSelf Baseline')
.alignSelf(ItemAlign.Baseline)
.width('25%')
.height(80)
.backgroundColor(0xD2B48C)
Text('alignSelf Baseline').width('25%').height(100)
.backgroundColor(0xF5DEB3)
.alignSelf(ItemAlign.Baseline)
Text('no alignSelf').width('25%').height(100)
.backgroundColor(0xD2B48C)
Text('no alignSelf').width('25%').height(100)
.backgroundColor(0xF5DEB3)
}.width('90%').height(220).backgroundColor(0xAFEEEE)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170244.17885092002226535878953277530017:50001231000000:2800:F7B10C6690AAAA4116E0341BF623FF0F21BF548B6AAC024ECE176072AA75FE8F.png)
上例中，Flex容器中alignItems设置交叉轴子元素的对齐方式为居中，子元素自身设置了alignSelf属性的情况，覆盖父组件的alignItems值，表现为alignSelf的定义。
内容对齐
可以通过alignContent参数设置子元素各行在交叉轴剩余空间内的对齐方式，只在多行的Flex布局中生效，可选值有：
-  FlexAlign.Start：子元素各行与交叉轴起点对齐。
```typescript
Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.Start }) {
Text('1').width('30%').height(20).backgroundColor(0xF5DEB3)
Text('2').width('60%').height(20).backgroundColor(0xD2B48C)
Text('3').width('40%').height(20).backgroundColor(0xD2B48C)
Text('4').width('30%').height(20).backgroundColor(0xF5DEB3)
Text('5').width('20%').height(20).backgroundColor(0xD2B48C)
}
.width('90%')
.height(100)
.backgroundColor(0xAFEEEE)
```
-  FlexAlign.Center：子元素各行在交叉轴方向居中对齐。
```typescript
Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.Center }) {
Text('1').width('30%').height(20).backgroundColor(0xF5DEB3)
Text('2').width('60%').height(20).backgroundColor(0xD2B48C)
Text('3').width('40%').height(20).backgroundColor(0xD2B48C)
Text('4').width('30%').height(20).backgroundColor(0xF5DEB3)
Text('5').width('20%').height(20).backgroundColor(0xD2B48C)
}
.width('90%')
.height(100)
.backgroundColor(0xAFEEEE)
```
-  FlexAlign.End：子元素各行与交叉轴终点对齐。
```typescript
Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.End }) {
Text('1').width('30%').height(20).backgroundColor(0xF5DEB3)
Text('2').width('60%').height(20).backgroundColor(0xD2B48C)
Text('3').width('40%').height(20).backgroundColor(0xD2B48C)
Text('4').width('30%').height(20).backgroundColor(0xF5DEB3)
Text('5').width('20%').height(20).backgroundColor(0xD2B48C)
}
.width('90%')
.height(100)
.backgroundColor(0xAFEEEE)
```
-  FlexAlign.SpaceBetween：子元素各行与交叉轴两端对齐，各行间垂直间距平均分布。
```typescript
Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.SpaceBetween }) {
Text('1').width('30%').height(20).backgroundColor(0xF5DEB3)
Text('2').width('60%').height(20).backgroundColor(0xD2B48C)
Text('3').width('40%').height(20).backgroundColor(0xD2B48C)
Text('4').width('30%').height(20).backgroundColor(0xF5DEB3)
Text('5').width('20%').height(20).backgroundColor(0xD2B48C)
}
.width('90%')
.height(100)
.backgroundColor(0xAFEEEE)
```
-  FlexAlign.SpaceAround：子元素各行间距相等，是元素首尾行与交叉轴两端距离的两倍。
```typescript
Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.SpaceAround }) {
Text('1').width('30%').height(20).backgroundColor(0xF5DEB3)
Text('2').width('60%').height(20).backgroundColor(0xD2B48C)
Text('3').width('40%').height(20).backgroundColor(0xD2B48C)
Text('4').width('30%').height(20).backgroundColor(0xF5DEB3)
Text('5').width('20%').height(20).backgroundColor(0xD2B48C)
}
.width('90%')
.height(100)
.backgroundColor(0xAFEEEE)
```
-  FlexAlign.SpaceEvenly: 子元素各行间距，子元素首尾行与交叉轴两端距离都相等。
```typescript
Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.SpaceEvenly }) {
Text('1').width('30%').height(20).backgroundColor(0xF5DEB3)
Text('2').width('60%').height(20).backgroundColor(0xD2B48C)
Text('3').width('40%').height(20).backgroundColor(0xD2B48C)
Text('4').width('30%').height(20).backgroundColor(0xF5DEB3)
Text('5').width('20%').height(20).backgroundColor(0xD2B48C)
}
.width('90%')
.height(100)
.backgroundColor(0xAFEEEE)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170244.60154387127650930606656374576587:50001231000000:2800:B821F9802563FB6D8474BA64B2AE18CE8BE161EFF79813281C6F9D548B494750.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170244.32921934801398780297617360393748:50001231000000:2800:D5E55A86A657A54C83ECC62AF9871D622A05ECDB68601856357F22FA2F711330.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170244.35644608942373044637101175257557:50001231000000:2800:5593E33F635CC837740ABD2D38A028D8819F7BB14DD82DE47818BD0001B482BA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170244.35487749733673697883963525701756:50001231000000:2800:5B2873723BE5B35444F761C753AE67205476B6B751A90845D9B894FC1BD0D7AF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170244.79576565128839781463748703516768:50001231000000:2800:E89391E45BA347231E9E0F84A11301633C53E2BCD555FA56507FEEB8FA5AB213.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170244.37377179496369233629440611099195:50001231000000:2800:9DC4F2DFB9AB35016C4CADCC29D74F9C23352993F9E90D50D3C807588769F002.png)
自适应拉伸
在弹性布局父组件尺寸过小时，通过子元素的以下属性设置其在父容器的占比，达到自适应布局。
-  flexBasis：设置子元素在父容器主轴方向上的基准尺寸。如果设置了该属性，则子项占用的空间为该属性所设置的值；如果没设置该属性，那子项的空间为width/height的值。
```typescript
Flex() {
Text('flexBasis("auto")')
.flexBasis('auto') // 未设置width以及flexBasis值为auto，内容自身宽度
.height(100)
.backgroundColor(0xF5DEB3)
Text('flexBasis("auto")'+' width("40%")')
.width('40%')
.flexBasis('auto') //设置width以及flexBasis值auto，使用width的值
.height(100)
.backgroundColor(0xD2B48C)
Text('flexBasis(100)')  // 未设置width以及flexBasis值为100，宽度为100vp
.flexBasis(100)
.height(100)
.backgroundColor(0xF5DEB3)
Text('flexBasis(100)')
.flexBasis(100)
.width(200) // flexBasis值为100，覆盖width的设置值，宽度为100vp
.height(100)
.backgroundColor(0xD2B48C)
}.width('90%').height(120).padding(10).backgroundColor(0xAFEEEE)
```
-  flexGrow：设置父容器的剩余空间分配给此属性所在组件的比例。用于分配父组件的剩余空间。 父容器宽度420vp，三个子元素原始宽度为100vp，左右padding为20vp，总和320vp，剩余空间100vp根据flexGrow值的占比分配给子元素，未设置flexGrow的子元素不参与“瓜分”。 第一个元素以及第二个元素以2:3分配剩下的100vp。第一个元素为100vp+100vp * 2/5=140vp，第二个元素为100vp+100vp * 3/5=160vp。
```typescript
Flex() {
Text('flexGrow(2)')
.flexGrow(2)
.width(100)
.height(100)
.backgroundColor(0xF5DEB3)
Text('flexGrow(3)')
.flexGrow(3)
.width(100)
.height(100)
.backgroundColor(0xD2B48C)
Text('no flexGrow')
.width(100)
.height(100)
.backgroundColor(0xF5DEB3)
}.width(420).height(120).padding(10).backgroundColor(0xAFEEEE)
```
-  flexShrink: 当父容器空间不足时，子元素的压缩比例。
```typescript
Flex({ direction: FlexDirection.Row }) {
Text('flexShrink(3)')
.flexShrink(3)
.width(200)
.height(100)
.backgroundColor(0xF5DEB3)
Text('no flexShrink')
.width(200)
.height(100)
.backgroundColor(0xD2B48C)
Text('flexShrink(2)')
.flexShrink(2)
.width(200)
.height(100)
.backgroundColor(0xF5DEB3)
}.width(400).height(120).padding(10).backgroundColor(0xAFEEEE)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170244.95078978556385851093232383292121:50001231000000:2800:3DB47F0F66E88648730AF8068CC96AE01A628E7A7BBA628A23C4624AD6F6949E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170244.31464070225431305966380068783385:50001231000000:2800:02C47E35AE4144DCDED31962A12FBFEF844C17AEEA5643A36C4ACB7FE37F558F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170244.89093652346536199335448813334970:50001231000000:2800:E6B182D4548591D48C0CC053D9053110A9B3477327C83089F4AB91A688B5AB7A.png)
场景示例
使用弹性布局，可以实现子元素沿水平方向排列，两端对齐，子元素间距平分，垂直方向上子元素居中的效果。
```typescript
@Entry
@Component
struct FlexExample {
build() {
Column() {
Column({ space: 5 }) {
Flex({ direction: FlexDirection.Row, wrap: FlexWrap.NoWrap, justifyContent: FlexAlign.SpaceBetween, alignItems: ItemAlign.Center }) {
Text('1').width('30%').height(50).backgroundColor(0xF5DEB3)
Text('2').width('30%').height(50).backgroundColor(0xD2B48C)
Text('3').width('30%').height(50).backgroundColor(0xF5DEB3)
}
.height(70)
.width('90%')
.backgroundColor(0xAFEEEE)
}.width('100%').margin({ top: 5 })
}.width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170244.35713297253508512488507508502722:50001231000000:2800:6F0AE3F74FB8CFD47510F9E5C12B642FBD25C2D6240009A9759E7DBB7629763E.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-layout-development-relative-layout-V14
爬取时间: 2025-04-27 23:16:33
来源: Huawei Developer
概述
在应用的开发过程中，经常需要设计复杂界面，此时涉及到多个相同或不同组件之间的嵌套。如果布局组件嵌套深度过深，或者嵌套组件数过多，会带来额外的开销。如果在布局的方式上进行优化，就可以有效的提升性能，减少时间开销。
RelativeContainer为采用相对布局的容器，支持容器内部的子元素设置相对位置关系，适用于界面复杂场景的情况，对多个子组件进行对齐和排列。子元素支持指定兄弟元素作为锚点，也支持指定父容器作为锚点，基于锚点做相对位置布局。下图是一个RelativeContainer的概念图，图中的虚线表示位置的依赖关系。
图1相对布局示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170244.59475066085478203658588017316813:50001231000000:2800:B23E940EB482FC1C7D566A21AA4649A4880D8B1DF7FDA9E82B43C79E2E5FF934.png)
子元素并不完全是上图中的依赖关系。比如，Item4可以以Item2为依赖锚点，也可以以RelativeContainer父容器为依赖锚点。
基本概念
-  锚点：通过锚点设置当前元素基于哪个元素确定位置。
-  对齐方式：通过对齐方式，设置当前元素是基于锚点的上中下对齐，还是基于锚点的左中右对齐。
设置依赖关系
锚点设置
锚点设置是指设置子元素相对于父元素或兄弟元素的位置依赖关系。在水平方向上，可以设置left、middle、right的锚点。在竖直方向上，可以设置top、center、bottom的锚点。
为了明确定义锚点，必须为RelativeContainer及其子元素设置ID，用于指定锚点信息。ID默认为“__container__”，其余子元素的ID通过id属性设置。不设置id的组件能显示，但是不能被其他子组件作为锚点，相对布局容器会为其拼接id，此id的规律无法被应用感知。互相依赖，环形依赖时容器内子组件全部不绘制。同方向上两个以上位置设置锚点，但锚点位置逆序时此子组件大小为0，即不绘制。
在使用锚点时要注意子元素的相对位置关系，避免出现错位或遮挡的情况。
-  RelativeContainer父组件为锚点，__container__代表父容器的ID。
```typescript
let AlignRus: Record<string, Record<string, string | VerticalAlign | HorizontalAlign>> = {
'top': { 'anchor': '__container__', 'align': VerticalAlign.Top },
'left': { 'anchor': '__container__', 'align': HorizontalAlign.Start }
}
let AlignRue: Record<string, Record<string, string | VerticalAlign | HorizontalAlign>> = {
'top': { 'anchor': '__container__', 'align': VerticalAlign.Top },
'right': { 'anchor': '__container__', 'align': HorizontalAlign.End }
}
let Mleft: Record<string, number> = { 'left': 20 }
let BWC: Record<string, number | string> = { 'width': 2, 'color': '#6699FF' }
@Entry
@Component
struct Index {
build() {
RelativeContainer() {
Row() {
Text('row1')
}
.justifyContent(FlexAlign.Center)
.width(100)
.height(100)
.backgroundColor('#a3cf62')
.alignRules(AlignRus)
.id("row1")
Row() {
Text('row2')
}
.justifyContent(FlexAlign.Center)
.width(100)
.height(100)
.backgroundColor('#00ae9d')
.alignRules(AlignRue)
.id("row2")
}.width(300).height(300)
.margin(Mleft)
.border(BWC)
}
}
```
-  以兄弟元素为锚点。
```typescript
let AlignRus: Record<string, Record<string, string | VerticalAlign | HorizontalAlign>> = {
'top': { 'anchor': '__container__', 'align': VerticalAlign.Top },
'left': { 'anchor': '__container__', 'align': HorizontalAlign.Start }
}
let RelConB: Record<string, Record<string, string | VerticalAlign | HorizontalAlign>> = {
'top': { 'anchor': 'row1', 'align': VerticalAlign.Bottom },
'left': { 'anchor': 'row1', 'align': HorizontalAlign.Start }
}
let Mleft: Record<string, number> = { 'left': 20 }
let BWC: Record<string, number | string> = { 'width': 2, 'color': '#6699FF' }
@Entry
@Component
struct Index {
build() {
RelativeContainer() {
Row() {
Text('row1')
}
.justifyContent(FlexAlign.Center)
.width(100)
.height(100)
.backgroundColor('#00ae9d')
.alignRules(AlignRus)
.id("row1")
Row() {
Text('row2')
}
.justifyContent(FlexAlign.Center)
.width(100)
.height(100)
.backgroundColor('#a3cf62')
.alignRules(RelConB)
.id("row2")
}.width(300).height(300)
.margin(Mleft)
.border(BWC)
}
}
```
-  子组件锚点可以任意选择，但需注意不要相互依赖。
```typescript
@Entry
@Component
struct Index {
build() {
Row() {
RelativeContainer() {
Row(){Text('row1')}.justifyContent(FlexAlign.Center).width(100).height(100)
.backgroundColor('#a3cf62')
.alignRules({
top: {anchor: "__container__", align: VerticalAlign.Top},
left: {anchor: "__container__", align: HorizontalAlign.Start}
})
.id("row1")
Row(){Text('row2')}.justifyContent(FlexAlign.Center).width(100)
.backgroundColor('#00ae9d')
.alignRules({
top: {anchor: "__container__", align: VerticalAlign.Top},
right: {anchor: "__container__", align: HorizontalAlign.End},
bottom: {anchor: "row1", align: VerticalAlign.Center},
})
.id("row2")
Row(){Text('row3')}.justifyContent(FlexAlign.Center).height(100)
.backgroundColor('#0a59f7')
.alignRules({
top: {anchor: "row1", align: VerticalAlign.Bottom},
left: {anchor: "row1", align: HorizontalAlign.Start},
right: {anchor: "row2", align: HorizontalAlign.Start}
})
.id("row3")
Row(){Text('row4')}.justifyContent(FlexAlign.Center)
.backgroundColor('#2ca9e0')
.alignRules({
top: {anchor: "row3", align: VerticalAlign.Bottom},
left: {anchor: "row1", align: HorizontalAlign.Center},
right: {anchor: "row2", align: HorizontalAlign.End},
bottom: {anchor: "__container__", align: VerticalAlign.Bottom}
})
.id("row4")
}
.width(300).height(300)
.margin({left: 50})
.border({width:2, color: "#6699FF"})
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170244.00209808478874180785031258356485:50001231000000:2800:DD82C59ECF195DB453830BB54A759D263D3BF2DEF8314821488CA0A9B59DC59A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170245.12307636794388700997074512413654:50001231000000:2800:69D2B92DDBB62ABBA68FB801090E5BB1F14E758C4DD0B2F228610A93895E97E2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170245.34894980699154639590585744665165:50001231000000:2800:1C8464A1AAB7307C2E3733A9C73CB3113EDEA7B90157A551D3E6B3EFB25C8429.png)
设置相对于锚点的对齐位置
设置了锚点之后，可以通过align设置相对于锚点的对齐位置。
在水平方向上，对齐位置可以设置为HorizontalAlign.Start、HorizontalAlign.Center、HorizontalAlign.End。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170245.97557799766732254755449783175586:50001231000000:2800:3358133E6229C6D2D000269811EEC5D12CA48AC2EC92B621C37D9A7717301A83.png)
在竖直方向上，对齐位置可以设置为VerticalAlign.Top、VerticalAlign.Center、VerticalAlign.Bottom。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170245.76705849391548579906851144204814:50001231000000:2800:87BE42CBD1F8C56F33FF327A262341491936E710284C95CADEBC42183EEBC573.png)
子组件位置偏移
子组件经过相对位置对齐后，位置可能还不是目标位置，开发者可根据需要进行额外偏移设置offset。
```typescript
@Entry
@Component
struct Index {
build() {
Row() {
RelativeContainer() {
Row() {
Text('row1')
}
.justifyContent(FlexAlign.Center)
.width(100)
.height(100)
.backgroundColor('#a3cf62')
.alignRules({
top: { anchor: "__container__", align: VerticalAlign.Top },
left: { anchor: "__container__", align: HorizontalAlign.Start }
})
.id("row1")
Row() {
Text('row2')
}
.justifyContent(FlexAlign.Center)
.width(100)
.backgroundColor('#00ae9d')
.alignRules({
top: { anchor: "__container__", align: VerticalAlign.Top },
right: { anchor: "__container__", align: HorizontalAlign.End },
bottom: { anchor: "row1", align: VerticalAlign.Center },
})
.offset({
x: -40,
y: -20
})
.id("row2")
Row() {
Text('row3')
}
.justifyContent(FlexAlign.Center)
.height(100)
.backgroundColor('#0a59f7')
.alignRules({
top: { anchor: "row1", align: VerticalAlign.Bottom },
left: { anchor: "row1", align: HorizontalAlign.End },
right: { anchor: "row2", align: HorizontalAlign.Start }
})
.offset({
x: -10,
y: -20
})
.id("row3")
Row() {
Text('row4')
}
.justifyContent(FlexAlign.Center)
.backgroundColor('#2ca9e0')
.alignRules({
top: { anchor: "row3", align: VerticalAlign.Bottom },
bottom: { anchor: "__container__", align: VerticalAlign.Bottom },
left: { anchor: "__container__", align: HorizontalAlign.Start },
right: { anchor: "row1", align: HorizontalAlign.End }
})
.offset({
x: -10,
y: -30
})
.id("row4")
Row() {
Text('row5')
}
.justifyContent(FlexAlign.Center)
.backgroundColor('#30c9f7')
.alignRules({
top: { anchor: "row3", align: VerticalAlign.Bottom },
bottom: { anchor: "__container__", align: VerticalAlign.Bottom },
left: { anchor: "row2", align: HorizontalAlign.Start },
right: { anchor: "row2", align: HorizontalAlign.End }
})
.offset({
x: 10,
y: 20
})
.id("row5")
Row() {
Text('row6')
}
.justifyContent(FlexAlign.Center)
.backgroundColor('#ff33ffb5')
.alignRules({
top: { anchor: "row3", align: VerticalAlign.Bottom },
bottom: { anchor: "row4", align: VerticalAlign.Bottom },
left: { anchor: "row3", align: HorizontalAlign.Start },
right: { anchor: "row3", align: HorizontalAlign.End }
})
.offset({
x: -15,
y: 10
})
.backgroundImagePosition(Alignment.Bottom)
.backgroundImageSize(ImageSize.Cover)
.id("row6")
}
.width(300).height(300)
.margin({ left: 50 })
.border({ width: 2, color: "#6699FF" })
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170245.20396975447667948379793898366347:50001231000000:2800:0C6F4A60B9AF0AEF189F08B487527A6DB7598661E75946FF5F9B2DD531792A40.png)
多种组件的对齐布局
Row、Column、Flex、Stack等多种布局组件，可按照RelativeContainer组件规则进行对齐排布。
```typescript
@Entry
@Component
struct Index {
@State value: number = 0
build() {
Row() {
RelativeContainer() {
Row()
.width(100)
.height(100)
.backgroundColor('#a3cf62')
.alignRules({
top: { anchor: "__container__", align: VerticalAlign.Top },
left: { anchor: "__container__", align: HorizontalAlign.Start }
})
.id("row1")
Column()
.width('50%')
.height(30)
.backgroundColor('#00ae9d')
.alignRules({
top: { anchor: "__container__", align: VerticalAlign.Top },
left: { anchor: "__container__", align: HorizontalAlign.Center }
})
.id("row2")
Flex({ direction: FlexDirection.Row }) {
Text('1').width('20%').height(50).backgroundColor('#0a59f7')
Text('2').width('20%').height(50).backgroundColor('#2ca9e0')
Text('3').width('20%').height(50).backgroundColor('#0a59f7')
Text('4').width('20%').height(50).backgroundColor('#2ca9e0')
}
.padding(10)
.backgroundColor('#30c9f7')
.alignRules({
top: { anchor: "row2", align: VerticalAlign.Bottom },
left: { anchor: "__container__", align: HorizontalAlign.Start },
bottom: { anchor: "__container__", align: VerticalAlign.Center },
right: { anchor: "row2", align: HorizontalAlign.Center }
})
.id("row3")
Stack({ alignContent: Alignment.Bottom }) {
Text('First child, show in bottom').width('90%').height('100%').backgroundColor('#a3cf62').align(Alignment.Top)
Text('Second child, show in top').width('70%').height('60%').backgroundColor('#00ae9d').align(Alignment.Top)
}
.margin({ top: 5 })
.alignRules({
top: { anchor: "row3", align: VerticalAlign.Bottom },
left: { anchor: "__container__", align: HorizontalAlign.Start },
bottom: { anchor: "__container__", align: VerticalAlign.Bottom },
right: { anchor: "row3", align: HorizontalAlign.End }
})
.id("row4")
}
.width(300).height(300)
.margin({ left: 50 })
.border({ width: 2, color: "#6699FF" })
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170245.31883612597635011927536178996083:50001231000000:2800:C84D91D8B5E5B0A9D3F72247FED02833B5AF445452950FF7ADE1B81D7F463DCE.png)
组件尺寸
子组件尺寸大小不会受到相对布局规则的影响。若子组件某个方向上设置两个或以上alignRules时最好不设置此方向尺寸大小，否则对齐规则确定的组件尺寸与开发者设置的尺寸可能产生冲突。
```typescript
@Entry
@Component
struct Index {
build() {
Row() {
RelativeContainer() {
Row() {
Text('row1')
}
.justifyContent(FlexAlign.Center)
.width(100)
.height(100)
.backgroundColor('#a3cf62')
.alignRules({
top: { anchor: "__container__", align: VerticalAlign.Top },
left: { anchor: "__container__", align: HorizontalAlign.Start }
})
.id("row1")
Row() {
Text('row2')
}
.justifyContent(FlexAlign.Center)
.width(100)
.backgroundColor('#00ae9d')
.alignRules({
top: { anchor: "__container__", align: VerticalAlign.Top },
right: { anchor: "__container__", align: HorizontalAlign.End },
bottom: { anchor: "row1", align: VerticalAlign.Center },
})
.id("row2")
Row() {
Text('row3')
}
.justifyContent(FlexAlign.Center)
.height(100)
.backgroundColor('#0a59f7')
.alignRules({
top: { anchor: "row1", align: VerticalAlign.Bottom },
left: { anchor: "row1", align: HorizontalAlign.End },
right: { anchor: "row2", align: HorizontalAlign.Start }
})
.id("row3")
Row() {
Text('row4')
}.justifyContent(FlexAlign.Center)
.backgroundColor('#2ca9e0')
.alignRules({
top: { anchor: "row3", align: VerticalAlign.Bottom },
bottom: { anchor: "__container__", align: VerticalAlign.Bottom },
left: { anchor: "__container__", align: HorizontalAlign.Start },
right: { anchor: "row1", align: HorizontalAlign.End }
})
.id("row4")
Row() {
Text('row5')
}.justifyContent(FlexAlign.Center)
.backgroundColor('#30c9f7')
.alignRules({
top: { anchor: "row3", align: VerticalAlign.Bottom },
bottom: { anchor: "__container__", align: VerticalAlign.Bottom },
left: { anchor: "row2", align: HorizontalAlign.Start },
right: { anchor: "row2", align: HorizontalAlign.End }
})
.id("row5")
Row() {
Text('row6')
}
.justifyContent(FlexAlign.Center)
.backgroundColor('#ff33ffb5')
.alignRules({
top: { anchor: "row3", align: VerticalAlign.Bottom },
bottom: { anchor: "row4", align: VerticalAlign.Bottom },
left: { anchor: "row3", align: HorizontalAlign.Start },
right: { anchor: "row3", align: HorizontalAlign.End }
})
.id("row6")
.backgroundImagePosition(Alignment.Bottom)
.backgroundImageSize(ImageSize.Cover)
}
.width(300).height(300)
.margin({ left: 50 })
.border({ width: 2, color: "#6699FF" })
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170245.19688532106343489246723014031076:50001231000000:2800:E48F2CC68608111A9DAF33BACA8F6B35FA4FD3CDE54350DE60FD4A73C7011D6C.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-layout-development-grid-layout-V14
爬取时间: 2025-04-27 23:16:47
来源: Huawei Developer
概述
栅格布局是一种通用的辅助定位工具，对移动设备的界面设计有较好的借鉴作用。主要优势包括：
1.  提供可循的规律：栅格布局可以为布局提供规律性的结构，解决多尺寸多设备的动态布局问题。通过将页面划分为等宽的列数和行数，可以方便地对页面元素进行定位和排版。
2.  统一的定位标注：栅格布局可以为系统提供一种统一的定位标注，保证不同设备上各个模块的布局一致性。这可以减少设计和开发的复杂度，提高工作效率。
3.  灵活的间距调整方法：栅格布局可以提供一种灵活的间距调整方法，满足特殊场景布局调整的需求。通过调整列与列之间和行与行之间的间距，可以控制整个页面的排版效果。
4.  自动换行和自适应：栅格布局可以完成一对多布局的自动换行和自适应。当页面元素的数量超出了一行或一列的容量时，他们会自动换到下一行或下一列，并且在不同的设备上自适应排版，使得页面布局更加灵活和适应性强。
GridRow为栅格容器组件，需与栅格子组件GridCol在栅格布局场景中联合使用。
栅格容器GridRow
栅格系统断点
栅格系统以设备的水平宽度（屏幕密度像素值，单位vp）作为断点依据，定义设备的宽度类型，形成了一套断点规则。开发者可根据需求在不同的断点区间实现不同的页面布局效果。
栅格系统默认断点将设备宽度分为xs、sm、md、lg四类，尺寸范围如下：
| 断点名称 | 取值范围（vp） | 设备描述 |
| --- | --- | --- |
| xs | [0, 320） | 最小宽度类型设备。 |
| sm | [320, 520) | 小宽度类型设备。 |
| md | [520, 840) | 中等宽度类型设备。 |
| lg | [840, +∞) | 大宽度类型设备。 |
在GridRow栅格组件中，允许开发者使用breakpoints自定义修改断点的取值范围，最多支持6个断点，除了默认的四个断点外，还可以启用xl，xxl两个断点，支持六种不同尺寸（xs, sm, md, lg, xl, xxl）设备的布局设置。
| 断点名称 | 设备描述 |
| --- | --- |
| xs | 最小宽度类型设备。 |
| sm | 小宽度类型设备。 |
| md | 中等宽度类型设备。 |
| lg | 大宽度类型设备。 |
| xl | 特大宽度类型设备。 |
| xxl | 超大宽度类型设备。 |
-  针对断点位置，开发者根据实际使用场景，通过一个单调递增数组设置。由于breakpoints最多支持六个断点，单调递增数组长度最大为5。 表示启用xs、sm、md共3个断点，小于100vp为xs，100vp-200vp为sm，大于200vp为md。 表示启用xs、sm、md、lg、xl共5个断点，小于320vp为xs，320vp-520vp为sm，520vp-840vp为md，840vp-1080vp为lg，大于1080vp为xl。
```typescript
breakpoints: {value: ['100vp', '200vp']}
```
-  栅格系统通过监听窗口或容器的尺寸变化进行断点，通过reference设置断点切换参考物。 考虑到应用可能以非全屏窗口的形式显示，以应用窗口宽度为参照物更为通用。
例如，使用栅格的默认列数12列，通过断点设置将应用宽度分成六个区间，在各区间中，每个栅格子元素占用的列数均不同。
```typescript
@State bgColors: ResourceColor[] =
['rgb(213,213,213)', 'rgb(150,150,150)', 'rgb(0,74,175)', 'rgb(39,135,217)', 'rgb(61,157,180)', 'rgb(23,169,141)',
'rgb(255,192,0)', 'rgb(170,10,33)'];
// ...
GridRow({
breakpoints: {
value: ['200vp', '300vp', '400vp', '500vp', '600vp'],
reference: BreakpointsReference.WindowSize
}
}) {
ForEach(this.bgColors, (color:ResourceColor, index?:number|undefined) => {
GridCol({
span: {
xs: 2, // 在最小宽度类型设备上，栅格子组件占据的栅格容器2列。
sm: 3, // 在小宽度类型设备上，栅格子组件占据的栅格容器3列。
md: 4, // 在中等宽度类型设备上，栅格子组件占据的栅格容器4列。
lg: 6, // 在大宽度类型设备上，栅格子组件占据的栅格容器6列。
xl: 8, // 在特大宽度类型设备上，栅格子组件占据的栅格容器8列。
xxl: 12 // 在超大宽度类型设备上，栅格子组件占据的栅格容器12列。
}
}) {
Row() {
Text(`${index}`)
}.width("100%").height('50vp')
}.backgroundColor(color)
})
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170245.66778854822667092683968478125787:50001231000000:2800:45CC686C0DB18814CD6851722C4DD015191654460152957818DA85E326F2F41A.gif)
布局的总列数
GridRow中通过columns设置栅格布局的总列数。
-  columns默认值为12，即在未设置columns时，任何断点下，栅格布局被分成12列。
```typescript
@State bgColors: ResourceColor[] =
['rgb(213,213,213)', 'rgb(150,150,150)', 'rgb(0,74,175)', 'rgb(39,135,217)', 'rgb(61,157,180)', 'rgb(23,169,141)',
'rgb(255,192,0)', 'rgb(170,10,33)', 'rgb(213,213,213)', 'rgb(150,150,150)', 'rgb(0,74,175)', 'rgb(39,135,217)'];
// ...
GridRow() {
ForEach(this.bgColors, (item:ResourceColor, index?:number|undefined) => {
GridCol() {
Row() {
Text(`${index}`)
}.width('100%').height('50')
}.backgroundColor(item)
})
}
```
-  当columns为自定义值，栅格布局在任何尺寸设备下都被分为columns列。下面分别设置栅格布局列数为4和8，子元素默认占一列，效果如下：
```typescript
class CurrTmp{
currentBp: string = 'unknown';
set(val:string){
this.currentBp = val
}
}
let BorderWH:Record<string,Color|number> = { 'color': Color.Blue, 'width': 2 }
@State bgColors: ResourceColor[] =
['rgb(213,213,213)', 'rgb(150,150,150)', 'rgb(0,74,175)', 'rgb(39,135,217)', 'rgb(61,157,180)', 'rgb(23,169,141)',
'rgb(255,192,0)', 'rgb(170,10,33)'];
@State currentBp: string = 'unknown';
// ...
Row() {
GridRow({ columns: 4 }) {
ForEach(this.bgColors, (item: ResourceColor, index?:number|undefined) => {
GridCol() {
Row() {
Text(`${index}`)
}.width('100%').height('50')
}.backgroundColor(item)
})
}
.width('100%').height('100%')
.onBreakpointChange((breakpoint:string) => {
let CurrSet:CurrTmp = new CurrTmp()
CurrSet.set(breakpoint)
})
}
.height(160)
.border(BorderWH)
.width('90%')
Row() {
GridRow({ columns: 8 }) {
ForEach(this.bgColors, (item: ResourceColor, index?:number|undefined) => {
GridCol() {
Row() {
Text(`${index}`)
}.width('100%').height('50')
}.backgroundColor(item)
})
}
.width('100%').height('100%')
.onBreakpointChange((breakpoint:string) => {
let CurrSet:CurrTmp = new CurrTmp()
CurrSet.set(breakpoint)
})
}
.height(160)
.border(BorderWH)
.width('90%')
```
-  当columns类型为GridRowColumnOption时，支持下面六种不同尺寸（xs, sm, md, lg, xl, xxl）设备的总列数设置，各个尺寸下数值可不同。
```typescript
@State bgColors: ResourceColor[] =
['rgb(213,213,213)', 'rgb(150,150,150)', 'rgb(0,74,175)', 'rgb(39,135,217)', 'rgb(61,157,180)', 'rgb(23,169,141)',
'rgb(255,192,0)', 'rgb(170,10,33)'];
GridRow({ columns: { sm: 4, md: 8 }, breakpoints: { value: ['200vp', '300vp', '400vp', '500vp', '600vp'] } }) {
ForEach(this.bgColors, (item: ResourceColor, index?:number|undefined) => {
GridCol() {
Row() {
Text(`${index}`)
}.width('100%').height('50')
}.backgroundColor(item)
})
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170245.84462822979891572239673170115038:50001231000000:2800:7E311703B3AFA2587752B4D9870E077D6C0708E6146A1D958F0BD208EAF5822C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170245.18894758266983709060927538602122:50001231000000:2800:004BFA7342C91F21447D96C2B62D0AC5250467F4DE769F863E3F305A99BE8ACC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170245.28192355403344619783045329053525:50001231000000:2800:DDEE764A988702540EE8F4D1ED4FB093991F1C54BD4071DC483E7B56060AFF53.gif)
若只设置sm, md的栅格总列数，则较小的尺寸使用默认columns值12，较大的尺寸使用前一个尺寸的columns。这里只设置sm:4, md:8，则较小尺寸的xs:12，较大尺寸的参照md的设置，lg:8, xl:8, xxl:8
排列方向
栅格布局中，可以通过设置GridRow的direction属性来指定栅格子组件在栅格容器中的排列方向。该属性可以设置为GridRowDirection.Row（从左往右排列）或GridRowDirection.RowReverse（从右往左排列），以满足不同的布局需求。通过合理的direction属性设置，可以使得页面布局更加灵活和符合设计要求。
-  子组件默认从左往右排列。
```typescript
GridRow({ direction: GridRowDirection.Row }){}
```
-  子组件从右往左排列。
```typescript
GridRow({ direction: GridRowDirection.RowReverse }){}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170245.99699606711733228696207260074083:50001231000000:2800:C0DC3672A35C890B7CC41FF57F29D3C68DEA6C65BCD9FF7E2B44871119CA3C6B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170245.58138013516772715120153318711002:50001231000000:2800:E63EF68B25167EC6ABF3B0E81E7F2379C677D185EF9F8EAB202F6B59FFBAE5E5.png)
子组件间距
GridRow中通过gutter属性设置子元素在水平和垂直方向的间距。
-  当gutter类型为number时，同时设置栅格子组件间水平和垂直方向边距且相等。下例中，设置子组件水平与垂直方向距离相邻元素的间距为10。
```typescript
GridRow({ gutter: 10 }){}
```
-  当gutter类型为GutterOption时，单独设置栅格子组件水平垂直边距，x属性为水平方向间距，y为垂直方向间距。
```typescript
GridRow({ gutter: { x: 20, y: 50 } }){}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170246.46614613023713230144981195753232:50001231000000:2800:22677CA670023E990ED1FDC57A838624BD3F556FB5E7DFA0D07A277943E0092C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170246.61723478817439779005025750280465:50001231000000:2800:27F394148EA66CABFB618ADD191E883F00629BF23C4F55B3D8DE434AC1DCA0C8.png)
子组件GridCol
GridCol组件作为GridRow组件的子组件，通过给GridCol传参或者设置属性两种方式，设置span（占用列数），offset（偏移列数），order（元素序号）的值。
-  设置span。
```typescript
let Gspan:Record<string,number> = { 'xs': 1, 'sm': 2, 'md': 3, 'lg': 4 }
GridCol({ span: 2 }){}
GridCol({ span: { xs: 1, sm: 2, md: 3, lg: 4 } }){}
GridCol(){}.span(2)
GridCol(){}.span(Gspan)
```
-  设置offset。
```typescript
let Goffset:Record<string,number> = { 'xs': 1, 'sm': 2, 'md': 3, 'lg': 4 }
GridCol({ offset: 2 }){}
GridCol({ offset: { xs: 2, sm: 2, md: 2, lg: 2 } }){}
GridCol(){}.offset(Goffset)
```
-  设置order。
```typescript
let Gorder:Record<string,number> = { 'xs': 1, 'sm': 2, 'md': 3, 'lg': 4 }
GridCol({ order: 2 }){}
GridCol({ order: { xs: 1, sm: 2, md: 3, lg: 4 } }){}
GridCol(){}.order(2)
GridCol(){}.order(Gorder)
```
span
子组件占栅格布局的列数，决定了子组件的宽度，默认为1。
-  当类型为number时，子组件在所有尺寸设备下占用的列数相同。
```typescript
@State bgColors: ResourceColor[] =
['rgb(213,213,213)', 'rgb(150,150,150)', 'rgb(0,74,175)', 'rgb(39,135,217)', 'rgb(61,157,180)', 'rgb(23,169,141)',
'rgb(255,192,0)', 'rgb(170,10,33)'];
// ...
GridRow({ columns: 8 }) {
ForEach(this.bgColors, (color:ResourceColor, index?:number|undefined) => {
GridCol({ span: 2 }) {
Row() {
Text(`${index}`)
}.width('100%').height('50vp')
}
.backgroundColor(color)
})
}
```
-  当类型为GridColColumnOption时，支持六种不同尺寸（xs, sm, md, lg, xl, xxl）设备中子组件所占列数设置，各个尺寸下数值可不同。
```typescript
@State bgColors: ResourceColor[] =
['rgb(213,213,213)', 'rgb(150,150,150)', 'rgb(0,74,175)', 'rgb(39,135,217)', 'rgb(61,157,180)', 'rgb(23,169,141)',
'rgb(255,192,0)', 'rgb(170,10,33)'];
// ...
GridRow({ columns: 8 }) {
ForEach(this.bgColors, (color:ResourceColor, index?:number|undefined) => {
GridCol({ span: { xs: 1, sm: 2, md: 3, lg: 4 } }) {
Row() {
Text(`${index}`)
}.width('100%').height('50vp')
}
.backgroundColor(color)
})
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170246.53798750278861559395777795413786:50001231000000:2800:839EC0738E9A90BAB2E13E86E7AA462DA81651644779F8951D217333B40D7736.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170246.58047856828240432097636330117850:50001231000000:2800:CCCB6D7A38AB411AF42CD7E6A7BB787B87D648514B9A8F20A31369F1FAD44E11.gif)
offset
栅格子组件相对于前一个子组件的偏移列数，默认为0。
-  当类型为number时，子组件偏移相同列数。 栅格默认分成12列，每一个子组件默认占1列，偏移2列，每个子组件及间距共占3列，一行放四个子组件。
```typescript
@State bgColors: ResourceColor[] =
['rgb(213,213,213)', 'rgb(150,150,150)', 'rgb(0,74,175)', 'rgb(39,135,217)', 'rgb(61,157,180)', 'rgb(23,169,141)',
'rgb(255,192,0)', 'rgb(170,10,33)'];
// ...
GridRow() {
ForEach(this.bgColors, (color:ResourceColor, index?:number|undefined) => {
GridCol({ offset: 2 }) {
Row() {
Text('' + index)
}.width('100%').height('50vp')
}
.backgroundColor(color)
})
}
```
-  当类型为GridColColumnOption时，支持六种不同尺寸（xs, sm, md, lg, xl, xxl）设备中子组件所占列数设置,各个尺寸下数值可不同。
```typescript
@State bgColors: ResourceColor[] =
['rgb(213,213,213)', 'rgb(150,150,150)', 'rgb(0,74,175)', 'rgb(39,135,217)', 'rgb(61,157,180)', 'rgb(23,169,141)',
'rgb(255,192,0)', 'rgb(170,10,33)'];
// ...
GridRow() {
ForEach(this.bgColors, (color:ResourceColor, index?:number|undefined) => {
GridCol({ offset: { xs: 1, sm: 2, md: 3, lg: 4 } }) {
Row() {
Text('' + index)
}.width('100%').height('50vp')
}
.backgroundColor(color)
})
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170246.82985336921625859041396998898750:50001231000000:2800:38EF7178894BE5B2722EDEDE4A9495AC34D4F16DF3CA4E2059F8818BEBF17D41.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170246.16103528365178200643855778939039:50001231000000:2800:843C29438FF3855AFF6FC4D995BC0C668C741E57FC26EFAB7706E6A77D347970.gif)
order
栅格子组件的序号，决定子组件排列次序。当子组件不设置order或者设置相同的order, 子组件按照代码顺序展示。当子组件设置不同的order时，order较小的组件在前，较大的在后。
当子组件部分设置order，部分不设置order时，未设置order的子组件依次排序靠前，设置了order的子组件按照数值从小到大排列。
-  当类型为number时，子组件在任何尺寸下排序次序一致。
```typescript
GridRow() {
GridCol({ order: 4 }) {
Row() {
Text('1')
}.width('100%').height('50vp')
}.backgroundColor('rgb(213,213,213)')
GridCol({ order: 3 }) {
Row() {
Text('2')
}.width('100%').height('50vp')
}.backgroundColor('rgb(150,150,150)')
GridCol({ order: 2 }) {
Row() {
Text('3')
}.width('100%').height('50vp')
}.backgroundColor('rgb(0,74,175)')
GridCol({ order: 1 }) {
Row() {
Text('4')
}.width('100%').height('50vp')
}.backgroundColor('rgb(39,135,217)')
}
```
-  当类型为GridColColumnOption时，支持六种不同尺寸（xs, sm, md, lg, xl, xxl）设备中子组件排序次序设置。在xs设备中，子组件排列顺序为1234；sm为2341，md为3412，lg为2431。
```typescript
GridRow() {
GridCol({ order: { xs:1, sm:5, md:3, lg:7}}) {
Row() {
Text('1')
}.width('100%').height('50vp')
}.backgroundColor(Color.Red)
GridCol({ order: { xs:2, sm:2, md:6, lg:1} }) {
Row() {
Text('2')
}.width('100%').height('50vp')
}.backgroundColor(Color.Orange)
GridCol({ order: { xs:3, sm:3, md:1, lg:6} }) {
Row() {
Text('3')
}.width('100%').height('50vp')
}.backgroundColor(Color.Yellow)
GridCol({ order: { xs:4, sm:4, md:2, lg:5} }) {
Row() {
Text('4')
}.width('100%').height('50vp')
}.backgroundColor(Color.Green)
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170246.80572187682566620023477811425111:50001231000000:2800:391AA84A67E7ECF92DDCCC0A674912058D2D9DEAA961FC4CF9F64BCD08390B6F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170246.43604488003012775689257293925251:50001231000000:2800:E44D07F7D07011D583496989BB4D6B4E097DCCB59A022F66D7E6B36068C688F3.gif)
栅格组件的嵌套使用
栅格组件也可以嵌套使用，完成一些复杂的布局。
以下示例中，栅格把整个空间分为12份。第一层GridRow嵌套GridCol，分为中间大区域以及“footer”区域。第二层GridRow嵌套GridCol，分为“left”和“right”区域。子组件空间按照上一层父组件的空间划分，粉色的区域是屏幕空间的12列，绿色和蓝色的区域是父组件GridCol的12列，依次进行空间的划分。
```typescript
@Entry
@Component
struct GridRowExample {
build() {
GridRow() {
GridCol({ span: { sm: 12 } }) {
GridRow() {
GridCol({ span: { sm: 2 } }) {
Row() {
Text('left').fontSize(24)
}
.justifyContent(FlexAlign.Center)
.height('90%')
}.backgroundColor('#ff41dbaa')
GridCol({ span: { sm: 10 } }) {
Row() {
Text('right').fontSize(24)
}
.justifyContent(FlexAlign.Center)
.height('90%')
}.backgroundColor('#ff4168db')
}
.backgroundColor('#19000000')
}
GridCol({ span: { sm: 12 } }) {
Row() {
Text('footer').width('100%').textAlign(TextAlign.Center)
}.width('100%').height('10%').backgroundColor(Color.Pink)
}
}.width('100%').height(300)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170246.33375975431748875997150438732422:50001231000000:2800:AD5C6CF51D65FB98B4C6913557DB5D9FCEC15DA62D2C2EDFE2294F3FABE55A70.png)
综上所述，栅格组件提供了丰富的自定义能力，功能异常灵活和强大。只需要明确栅格在不同断点下的Columns、Margin、Gutter及span等参数，即可确定最终布局，无需关心具体的设备类型及设备状态（如横竖屏）等。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-layout-development-media-query-V14
爬取时间: 2025-04-27 23:17:01
来源: Huawei Developer
概述
媒体查询作为响应式设计的核心，在移动设备上应用十分广泛。媒体查询可根据不同设备类型或同设备不同状态修改应用的样式。媒体查询常用于下面两种场景：
1.  针对设备和应用的属性信息（比如显示区域、深浅色、分辨率），设计出相匹配的布局。
2.  当屏幕发生动态改变时（比如分屏、横竖屏切换），同步更新应用的页面布局。
引入与使用流程
媒体查询通过mediaquery模块接口，设置查询条件并绑定回调函数，任一媒体特征改变时，均会触发回调函数，返回匹配结果，根据返回值更改页面布局或者实现业务逻辑，实现页面的响应式设计。具体步骤如下：
首先导入媒体查询模块。
```typescript
import { mediaquery } from '@kit.ArkUI';
```
通过matchMediaSync接口设置媒体查询条件，保存返回的条件监听句柄listener。例如监听横屏事件：
```typescript
let listener: mediaquery.MediaQueryListener = this.getUIContext().getMediaQuery().matchMediaSync('(orientation: landscape)');
```
给条件监听句柄listener绑定回调函数onPortrait，当listener检测设备状态变化时执行回调函数。在回调函数内，根据不同设备状态更改页面布局或者实现业务逻辑。
```typescript
onPortrait(mediaQueryResult: mediaquery.MediaQueryResult) {
if (mediaQueryResult.matches as boolean) {
// do something here
} else {
// do something here
}
}
listener.on('change', onPortrait);
```
媒体查询条件
媒体查询条件由媒体类型、逻辑操作符、媒体特征组成，其中媒体类型可省略，逻辑操作符用于连接不同媒体类型与媒体特征，其中，媒体特征要使用“()”包裹且可以有多个。
语法规则
语法规则包括媒体类型（media-type）、媒体逻辑操作（media-logic-operations）和媒体特征（media-feature）。
```typescript
[media-type] [media-logic-operations] [(media-feature)]
```
例如：
-  screen and (round-screen: true) ：表示当设备屏幕是圆形时条件成立。
-  (max-height: 800px) ：表示当高度小于等于800px时条件成立。
-  (height <= 800px) ：表示当高度小于等于800px时条件成立。
-  screen and (device-type: tv) or (resolution < 2) ：表示包含多个媒体特征的多条件复杂语句查询，当设备类型为tv或设备分辨率小于2时条件成立。
-  (dark-mode: true) ：表示当系统为深色模式时成立。
媒体类型（media-type）
查询条件未写媒体类型时，默认为screen。媒体类型必须写在查询条件开头。
| 类型 | 说明 |
| --- | --- |
| screen | 按屏幕相关参数进行媒体查询。 |
媒体逻辑操作（media-logic-operations）
媒体逻辑操作符：and、or、not、only用于构成复杂媒体查询，也可以通过comma（, ）将其组合起来，详细解释说明如下表。
表1媒体逻辑操作符
| 类型 | 说明 |
| --- | --- |
| and | 将多个媒体特征（Media Feature）以“与”的方式连接成一个媒体查询，只有当所有媒体特征都为true，查询条件成立。另外，它还可以将媒体类型和媒体功能结合起来。例如：screen and (device-type: wearable) and (max-height: 600px) 表示当设备类型是智能穿戴且应用的最大高度小于等于600个像素单位时成立。 |
| or | 将多个媒体特征以“或”的方式连接成一个媒体查询，如果存在结果为true的媒体特征，则查询条件成立。例如：screen and (max-height: 1000px) or (round-screen: true) 表示当应用高度小于等于1000个像素单位或者设备屏幕是圆形时，条件成立。 |
| not | not操作符必须搭配screen使用，取反媒体查询结果，媒体查询结果不成立时返回true，否则返回false。例如：not screen and (min-height: 50px) and (max-height: 600px) 表示当应用高度小于50个像素单位或者大于600个像素单位时成立。 |
| only | only操作符必须搭配screen使用, 当前效果与单独使用screen相同。例如：only screen and (height <= 50) 。 |
| comma（, ） | 将多个媒体特征以“或”的方式连接成一个媒体查询，如果存在结果为true的媒体特征，则查询条件成立。其效果等同于or运算符。例如：screen and (min-height: 1000px), (round-screen: true) 表示当应用高度大于等于1000个像素单位或者设备屏幕是圆形时，条件成立。 |
媒体范围操作符包括<=，>=，<，>，详细解释说明如下表。
表2媒体逻辑范围操作符
| 类型 | 说明 |
| --- | --- |
| <= | 小于等于，例如：screen and (height <= 50)。 |
| >= | 大于等于，例如：screen and (height >= 600)。 |
| < | 小于，例如：screen and (height < 50)。 |
| > | 大于，例如：screen and (height > 600)。 |
媒体特征（media-feature）
媒体特征包括应用显示区域的宽高、设备分辨率以及设备的宽高等属性，详细说明如下表。
表3媒体特征说明表
比较height、width等宽高尺寸时，支持vp和px单位，无单位默认为px。
| 类型 | 说明 |
| --- | --- |
| height | 应用页面可绘制区域的高度。 |
| min-height | 应用页面可绘制区域的最小高度。 |
| max-height | 应用页面可绘制区域的最大高度。 |
| width | 应用页面可绘制区域的宽度。 |
| min-width | 应用页面可绘制区域的最小宽度。 |
| max-width | 应用页面可绘制区域的最大宽度。 |
| resolution | 设备的分辨率，支持dpi，dppx和dpcm单位。其中： - dpi表示每英寸中物理像素个数，1dpi ≈ 0.39dpcm； - dpcm表示每厘米上的物理像素个数，1dpcm ≈ 2.54dpi； - dppx表示每个px中的物理像素数（此单位按96px = 1英寸为基准，与页面中的px单位计算方式不同），1dppx = 96dpi。 |
| min-resolution | 设备的最小分辨率。 |
| max-resolution | 设备的最大分辨率。 |
| orientation | 屏幕的方向。 可选值： - orientation: portrait（设备竖屏）； - orientation: landscape（设备横屏）。 |
| device-height | 设备的高度。 |
| min-device-height | 设备的最小高度。 |
| max-device-height | 设备的最大高度。 |
| device-width | 设备的宽度。当前仅在应用初始化时保存一次，不会随设备宽度变化实时更新，例如折叠屏的折叠展开场景。 |
| device-type | 设备的类型。 可选值：default、phone、tablet、tv、car、wearable、2in1。 |
| min-device-width | 设备的最小宽度。 |
| max-device-width | 设备的最大宽度。 |
| round-screen | 屏幕类型，圆形屏幕为true，非圆形屏幕为false。 |
| dark-mode | 系统当前的深浅模式。可选值：true、false。 深色模式为true，浅色模式为false。 |
设备的分辨率，支持dpi，dppx和dpcm单位。其中：
- dpi表示每英寸中物理像素个数，1dpi ≈ 0.39dpcm；
- dpcm表示每厘米上的物理像素个数，1dpcm ≈ 2.54dpi；
- dppx表示每个px中的物理像素数（此单位按96px = 1英寸为基准，与页面中的px单位计算方式不同），1dppx = 96dpi。
屏幕的方向。
可选值：
- orientation: portrait（设备竖屏）；
- orientation: landscape（设备横屏）。
设备的类型。
可选值：default、phone、tablet、tv、car、wearable、2in1。
系统当前的深浅模式。可选值：true、false。
深色模式为true，浅色模式为false。
目前在卡片中使用媒体查询，只支持height、width。
场景示例
下例中使用媒体查询，实现屏幕横竖屏切换时，给页面文本应用添加不同的内容和样式。
Stage模型下的示例：
```typescript
import { mediaquery, window } from '@kit.ArkUI';
import { common } from '@kit.AbilityKit';
@Entry
@Component
struct MediaQueryExample {
@State color: string = '#DB7093';
@State text: string = 'Portrait';
// 当设备横屏时条件成立
listener:mediaquery.MediaQueryListener = this.getUIContext().getMediaQuery().matchMediaSync('(orientation: landscape)');
// 当满足媒体查询条件时，触发回调
onPortrait(mediaQueryResult:mediaquery.MediaQueryResult) {
if (mediaQueryResult.matches as boolean) { // 若设备为横屏状态，更改相应的页面布局
this.color = '#FFD700';
this.text = 'Landscape';
} else {
this.color = '#DB7093';
this.text = 'Portrait';
}
}
aboutToAppear() {
// 绑定当前应用实例
// 绑定回调函数
this.listener.on('change', (mediaQueryResult: mediaquery.MediaQueryResult) => {
this.onPortrait(mediaQueryResult)
});
}
aboutToDisappear() {
// 解绑listener中注册的回调函数
this.listener.off('change');
}
// 改变设备横竖屏状态函数
private changeOrientation(isLandscape: boolean) {
// 获取UIAbility实例的上下文信息
let context:common.UIAbilityContext = this.getUIContext().getHostContext() as common.UIAbilityContext;
// 调用该接口手动改变设备横竖屏状态
window.getLastWindow(context).then((lastWindow) => {
lastWindow.setPreferredOrientation(isLandscape ? window.Orientation.LANDSCAPE : window.Orientation.PORTRAIT)
});
}
build() {
Column({ space: 50 }) {
Text(this.text).fontSize(50).fontColor(this.color)
Text('Landscape').fontSize(50).fontColor(this.color).backgroundColor(Color.Orange)
.onClick(() => {
this.changeOrientation(true);
})
Text('Portrait').fontSize(50).fontColor(this.color).backgroundColor(Color.Orange)
.onClick(() => {
this.changeOrientation(false);
})
}
.width('100%').height('100%')
}
}
```
FA模型下的示例：
```typescript
import { mediaquery } from '@kit.ArkUI';
import { featureAbility } from '@kit.AbilityKit';
@Entry
@Component
struct MediaQueryExample {
@State color: string = '#DB7093';
@State text: string = 'Portrait';
listener:mediaquery.MediaQueryListener = mediaquery.matchMediaSync('(orientation: landscape)'); // 当设备横屏时条件成立
onPortrait(mediaQueryResult:mediaquery.MediaQueryResult) { // 当满足媒体查询条件时，触发回调
if (mediaQueryResult.matches as boolean) { // 若设备为横屏状态，更改相应的页面布局
this.color = '#FFD700';
this.text = 'Landscape';
} else {
this.color = '#DB7093';
this.text = 'Portrait';
}
}
aboutToAppear() {
// 绑定当前应用实例
this.listener.on('change', (mediaQueryResult:mediaquery.MediaQueryResult) => { this.onPortrait(mediaQueryResult) }); //绑定回调函数
}
aboutToDisappear() {
// 解绑listener中注册的回调函数
this.listener.off('change');
}
build() {
Column({ space: 50 }) {
Text(this.text).fontSize(50).fontColor(this.color)
Text('Landscape').fontSize(50).fontColor(this.color).backgroundColor(Color.Orange)
.onClick(() => {
let context = featureAbility.getContext();
context.setDisplayOrientation(0); //调用该接口手动改变设备横竖屏状态
})
Text('Portrait').fontSize(50).fontColor(this.color).backgroundColor(Color.Orange)
.onClick(() => {
let context = featureAbility.getContext();
context.setDisplayOrientation(1); //调用该接口手动改变设备横竖屏状态
})
}
.width('100%').height('100%')
}
}
```
图1竖屏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170246.94205548932084504173668891405609:50001231000000:2800:FD426CBEB9358E0827F754CA210751ACAA2F8F150C1427942C8CEDCCDFA630FE.jpg)
图2横屏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170246.91946766408362123288569654749241:50001231000000:2800:66609476071C8D7423BE20EEFC3632AC2BB3F472CF7A613C6BB92E0E1A4E91F5.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-layout-development-create-list-V14
爬取时间: 2025-04-27 23:17:15
来源: Huawei Developer
概述
列表是一种复杂的容器，当列表项达到一定数量，内容超过屏幕大小时，可以自动提供滚动功能。它适合用于呈现同类数据类型或数据类型集，例如图片和文本。在列表中显示数据集合是许多应用程序中的常见要求（如通讯录、音乐列表、购物清单等）。
使用列表可以轻松高效地显示结构化、可滚动的信息。通过在List组件中按垂直或者水平方向线性排列子组件ListItemGroup或ListItem，为列表中的行或列提供单个视图，或使用循环渲染迭代一组行或列，或混合任意数量的单个视图和ForEach结构，构建一个列表。List组件支持使用条件渲染、循环渲染、懒加载等渲染控制方式生成子组件。
布局与约束
列表作为一种容器，会自动按其滚动方向排列子组件，向列表中添加组件或从列表中移除组件会重新排列子组件。
如下图所示，在垂直列表中，List按垂直方向自动排列ListItemGroup或ListItem。
ListItemGroup用于列表数据的分组展示，其子组件也是ListItem。ListItem表示单个列表项，可以包含单个子组件。
图1List、ListItemGroup和ListItem组件关系
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170246.83947718166643434548826425128166:50001231000000:2800:673E1746F2518F40A634E48DE8F5B70A8B6F45FF4DF72F8562AD89B6188E6ECC.png)
List的子组件必须是ListItemGroup或ListItem，ListItem和ListItemGroup必须配合List来使用。
布局
List除了提供垂直和水平布局能力、超出屏幕时可以滚动的自适应延伸能力之外，还提供了自适应交叉轴方向上排列个数的布局能力。
利用垂直布局能力可以构建单列或者多列垂直滚动列表，如下图所示。
图2垂直滚动列表（左：单列；右：多列）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170247.07468284964641576439183217280400:50001231000000:2800:CA2DC18B20EEBED5CB10D034C4C0D3165FD8C4B415E2BA852A82E298F23E7F4E.png)
利用水平布局能力可以是构建单行或多行水平滚动列表，如下图所示。
图3水平滚动列表（左：单行；右：多行）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170247.44116691924254534564537135393721:50001231000000:2800:6ABFBC75FC62247F89446F4B1F1A515D4AF6361039B0A6ADA88D4913F5F7732E.png)
Grid和WaterFlow也可以实现单列、多列布局，如果布局每列等宽，且不需要跨行跨列布局，相比Grid和WaterFlow，则更推荐使用List。
约束
列表的主轴方向是指子组件列的排列方向，也是列表的滚动方向。垂直于主轴的轴称为交叉轴，其方向与主轴方向相互垂直。
如下图所示，垂直列表的主轴是垂直方向，交叉轴是水平方向；水平列表的主轴是水平方向，交叉轴是垂直方向。
图4列表的主轴与交叉轴
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170247.03677795585214947126374836678625:50001231000000:2800:E235B4FE9FC1997E1D3DE8B8B1AF4CC03F72F2E7B0B06E5DA83B6B76221D3C10.png)
如果List组件主轴或交叉轴方向设置了尺寸，则其对应方向上的尺寸为设置值。
如果List组件主轴方向没有设置尺寸，当List子组件主轴方向总尺寸小于List的父组件尺寸时，List主轴方向尺寸自动适应子组件的总尺寸。
如下图所示，一个垂直列表B没有设置高度时，其父组件A高度为200vp，若其所有子组件C的高度总和为150vp，则此时列表B的高度为150vp。
图5列表主轴高度约束示例1（A: List的父组件;B: List组件;C: List的所有子组件）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170247.75134664778296338787547226832433:50001231000000:2800:4F6C97514399A8B13AC15E0992F4B42C2B1C85764AB356B2D9ACEEAD2365F985.png)
如果子组件主轴方向总尺寸超过List父组件尺寸时，List主轴方向尺寸适应List的父组件尺寸。
如下图所示，同样是没有设置高度的垂直列表B，其父组件A高度为200vp，若其所有子组件C的高度总和为300vp，则此时列表B的高度为200vp。
图6列表主轴高度约束示例2（A: List的父组件;B: List组件;C: List的所有子组件）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170247.36902321634543997557295917644494:50001231000000:2800:421C7C98F4CF63EBE03E2B2EE954AB371546D3AAED12F1AC6AC6115B4D90CD4A.png)
List组件交叉轴方向在没有设置尺寸时，其尺寸默认自适应父组件尺寸。
开发布局
设置主轴方向
List组件主轴默认是垂直方向，即默认情况下不需要手动设置List方向，就可以构建一个垂直滚动列表。
若是水平滚动列表场景，将List的listDirection属性设置为Axis.Horizontal即可实现。listDirection默认为Axis.Vertical，即主轴默认是垂直方向。
```typescript
List() {
// ...
}
.listDirection(Axis.Horizontal)
```
设置交叉轴布局
List组件的交叉轴布局可以通过lanes和alignListItem属性进行设置，lanes属性用于确定交叉轴排列的列表项数量，alignListItem用于设置子组件在交叉轴方向的对齐方式。
List组件的lanes属性通常用于在不同尺寸的设备自适应构建不同行数或列数的列表，即一次开发、多端部署的场景，例如歌单列表。lanes属性的取值类型是"number |LengthConstrain"，即整数或者LengthConstrain类型。以垂直列表为例，如果将lanes属性设为2，表示构建的是一个两列的垂直列表，如图2中右图所示。lanes的默认值为1，即默认情况下，垂直列表的列数是1。
```typescript
List() {
// ...
}
.lanes(2)
```
当其取值为LengthConstrain类型时，表示会根据LengthConstrain与List组件的尺寸自适应决定行或列数。
```typescript
@Entry
@Component
struct EgLanes {
@State egLanes: LengthConstrain = { minLength: 200, maxLength: 300 }
build() {
List() {
// ...
}
.lanes(this.egLanes)
}
}
```
例如，假设在垂直列表中设置了lanes的值为{ minLength: 200, maxLength: 300 }。此时：
-  当List组件宽度为300vp时，由于minLength为200vp，此时列表为一列。
-  当List组件宽度变化至400vp时，符合两倍的minLength，则此时列表自适应为两列。
同样以垂直列表为例，当alignListItem属性设置为ListItemAlign.Center表示列表项在水平方向上居中对齐。alignListItem的默认值是ListItemAlign.Start，即列表项在列表交叉轴方向上默认按首部对齐。
```typescript
List() {
// ...
}
.alignListItem(ListItemAlign.Center)
```
在列表中显示数据
列表视图垂直或水平显示项目集合，在行或列超出屏幕时提供滚动功能，使其适合显示大型数据集合。在最简单的列表形式中，List静态地创建其列表项ListItem的内容。
图7城市列表
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170247.05539258567348171783999891943962:50001231000000:2800:CEE0C807FC0A9E7D687D4DA4CA8B3DB6903E8171639651AAE279AF4FDDD357BC.png)
```typescript
@Entry
@Component
struct CityList {
build() {
List() {
ListItem() {
Text('北京').fontSize(24)
}
ListItem() {
Text('杭州').fontSize(24)
}
ListItem() {
Text('上海').fontSize(24)
}
}
.backgroundColor('#FFF1F3F5')
.alignListItem(ListItemAlign.Center)
}
}
```
由于在ListItem中只能有一个根节点组件，不支持以平铺形式使用多个组件。因此，若列表项是由多个组件元素组成的，则需要将这多个元素组合到一个容器组件内或组成一个自定义组件。
图8联系人列表项示例
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170247.53680951886408110779658386150450:50001231000000:2800:700A0CBDC03308255E882726C5EBD6430AD47A8060861D64E3682B5D19584499.png)
如上图所示，联系人列表的列表项中，每个联系人都有头像和名称。此时，需要将Image和Text封装到一个Row容器内。
```typescript
List() {
ListItem() {
Row() {
Image($r('app.media.iconE'))
.width(40)
.height(40)
.margin(10)
Text('小明')
.fontSize(20)
}
}
ListItem() {
Row() {
Image($r('app.media.iconF'))
.width(40)
.height(40)
.margin(10)
Text('小红')
.fontSize(20)
}
}
}
```
迭代列表内容
通常，应用通过数据集合动态地创建列表。使用循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件，降低代码复杂度。
ArkTS通过ForEach提供了组件的循环渲染能力。以简单形式的联系人列表为例，将联系人名称和头像数据以Contact类结构存储到contacts数组，使用ForEach中嵌套ListItem的形式来代替多个平铺的、内容相似的ListItem，从而减少重复代码。
```typescript
import { util } from '@kit.ArkTS'
class Contact {
key: string = util.generateRandomUUID(true);
name: string;
icon: Resource;
constructor(name: string, icon: Resource) {
this.name = name;
this.icon = icon;
}
}
@Entry
@Component
struct SimpleContacts {
private contacts: Array<object> = [
new Contact('小明', $r("app.media.iconA")),
new Contact('小红', $r("app.media.iconB")),
]
build() {
List() {
ForEach(this.contacts, (item: Contact) => {
ListItem() {
Row() {
Image(item.icon)
.width(40)
.height(40)
.margin(10)
Text(item.name).fontSize(20)
}
.width('100%')
.justifyContent(FlexAlign.Start)
}
}, (item: Contact) => JSON.stringify(item))
}
.width('100%')
}
}
```
在List组件中，ForEach除了可以用来循环渲染ListItem，也可以用来循环渲染ListItemGroup。ListItemGroup的循环渲染详细使用请参见支持分组列表。
自定义列表样式
设置内容间距
在初始化列表时，如需在列表项之间添加间距，可以使用space参数。例如，在每个列表项之间沿主轴方向添加10vp的间距：
```typescript
List({ space: 10 }) {
// ...
}
```
添加分隔线
分隔线用来将界面元素隔开，使单个元素更加容易识别。如下图所示，当列表项左边有图标（如蓝牙图标），由于图标本身就能很好的区分，此时分隔线从图标之后开始显示即可。
图9设置列表分隔线样式
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170247.43926489077449501225611180294502:50001231000000:2800:3828BB75D2066A8FF7224F6F5D88ED68BCE025ADB2A10D264D47B8455737DA44.png)
List提供了divider属性用于给列表项之间添加分隔线。在设置divider属性时，可以通过strokeWidth和color属性设置分隔线的粗细和颜色。
startMargin和endMargin属性分别用于设置分隔线距离列表侧边起始端的距离和距离列表侧边结束端的距离。
```typescript
class DividerTmp {
strokeWidth: Length = 1
startMargin: Length = 60
endMargin: Length = 10
color: ResourceColor = '#ffe9f0f0'
constructor(strokeWidth: Length, startMargin: Length, endMargin: Length, color: ResourceColor) {
this.strokeWidth = strokeWidth
this.startMargin = startMargin
this.endMargin = endMargin
this.color = color
}
}
@Entry
@Component
struct EgDivider {
@State egDivider: DividerTmp = new DividerTmp(1, 60, 10, '#ffe9f0f0')
build() {
List() {
// ...
}
.divider(this.egDivider)
}
}
```
此示例表示从距离列表侧边起始端60vp开始到距离结束端10vp的位置，画一条粗细为1vp的分割线，可以实现图9设置列表分隔线的样式。
1.  分隔线的宽度会使ListItem之间存在一定间隔，当List设置的内容间距小于分隔线宽度时，ListItem之间的间隔会使用分隔线的宽度。
2.  当List存在多列时，分割线的startMargin和endMargin作用于每一列上。
3.  List组件的分隔线画在两个ListItem之间，第一个ListItem上方和最后一个ListItem下方不会绘制分隔线。
添加滚动条
当列表项高度（宽度）超出屏幕高度（宽度）时，列表可以沿垂直（水平）方向滚动。在页面内容很多时，若用户需快速定位，可拖拽滚动条，如下图所示。
图10列表的滚动条
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170247.77856213017868969586897426990137:50001231000000:2800:35028C504776F730C09F5FE2307A63112544A9AC2AD4CD3332D97EFA5E735174.gif)
在使用List组件时，可通过scrollBar属性控制列表滚动条的显示。scrollBar的取值类型为BarState，当取值为BarState.Auto表示按需显示滚动条。此时，当触摸到滚动条区域时显示控件，可上下拖拽滚动条快速浏览内容，拖拽时会变粗。若不进行任何操作，2秒后滚动条自动消失。
scrollBar属性API version 9及以下版本默认值为BarState.Off，从API version 10版本开始默认值为BarState.Auto。
```typescript
List() {
// ...
}
.scrollBar(BarState.Auto)
```
支持分组列表
在列表中支持数据的分组展示，可以使列表显示结构清晰，查找方便，从而提高使用效率。分组列表在实际应用中十分常见，如下图所示联系人列表。
图11联系人分组列表
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170247.33441990926570417877013583277959:50001231000000:2800:89DA0227DF231E94C41A41DFF634547A64DA4C3F3F82A317E822BEB11FDE0402.png)
在List组件中使用ListItemGroup对项目进行分组，可以构建二维列表。
在List组件中可以直接使用一个或者多个ListItemGroup组件，ListItemGroup的宽度默认充满List组件。在初始化ListItemGroup时，可通过header参数设置列表分组的头部组件。
```typescript
@Entry
@Component
struct ContactsList {
@Builder itemHead(text: string) {
// 列表分组的头部组件，对应联系人分组A、B等位置的组件
Text(text)
.fontSize(20)
.backgroundColor('#fff1f3f5')
.width('100%')
.padding(5)
}
build() {
List() {
ListItemGroup({ header: this.itemHead('A') }) {
// 循环渲染分组A的ListItem
}
ListItemGroup({ header: this.itemHead('B') }) {
// 循环渲染分组B的ListItem
}
}
}
}
```
如果多个ListItemGroup结构类似，可以将多个分组的数据组成数组，然后使用ForEach对多个分组进行循环渲染。例如在联系人列表中，将每个分组的联系人数据contacts（可参考迭代列表内容章节）和对应分组的标题title数据进行组合，定义为数组contactsGroups。然后在ForEach中对contactsGroups进行循环渲染，即可实现多个分组的联系人列表。可参考添加粘性标题章节示例代码。
添加粘性标题
粘性标题是一种常见的标题模式，常用于定位字母列表的头部元素。如下图所示，在联系人列表中滚动A部分时，B部分开始的头部元素始终处于A的下方。而在开始滚动B部分时，B的头部会固定在屏幕顶部，直到所有B的项均完成滚动后，才被后面的头部替代。
粘性标题不仅有助于阐明列表中数据的表示形式和用途，还可以帮助用户在大量信息中进行数据定位，从而避免用户在标题所在的表的顶部与感兴趣区域之间反复滚动。
图12粘性标题
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170247.59767475476575917370044348848952:50001231000000:2800:CF6C805ABF252AF676B5F3B58EEA9392DBA769A7B2C1D8C19F9FC454D3B341A4.gif)
List组件的sticky属性配合ListItemGroup组件使用，用于设置ListItemGroup中的头部组件是否呈现吸顶效果或者尾部组件是否呈现吸底效果。
通过给List组件设置sticky属性为StickyStyle.Header，即可实现列表的粘性标题效果。如果需要支持吸底效果，可以通过footer参数初始化ListItemGroup的底部组件，并将sticky属性设置为StickyStyle.Footer。
```typescript
import { util } from '@kit.ArkTS'
class Contact {
key: string = util.generateRandomUUID(true);
name: string;
icon: Resource;
constructor(name: string, icon: Resource) {
this.name = name;
this.icon = icon;
}
}
class ContactsGroup {
title: string = ''
contacts: Array<object> | null = null
key: string = ""
}
export let contactsGroups: object[] = [
{
title: 'A',
contacts: [
new Contact('艾佳', $r('app.media.iconA')),
new Contact('安安', $r('app.media.iconB')),
new Contact('Angela', $r('app.media.iconC')),
],
key: util.generateRandomUUID(true)
} as ContactsGroup,
{
title: 'B',
contacts: [
new Contact('白叶', $r('app.media.iconD')),
new Contact('伯明', $r('app.media.iconE')),
],
key: util.generateRandomUUID(true)
} as ContactsGroup,
// ...
]
@Entry
@Component
struct ContactsList {
// 定义分组联系人数据集合contactsGroups数组
@Builder itemHead(text: string) {
// 列表分组的头部组件，对应联系人分组A、B等位置的组件
Text(text)
.fontSize(20)
.backgroundColor('#fff1f3f5')
.width('100%')
.padding(5)
}
build() {
List() {
// 循环渲染ListItemGroup，contactsGroups为多个分组联系人contacts和标题title的数据集合
ForEach(contactsGroups, (itemGroup: ContactsGroup) => {
ListItemGroup({ header: this.itemHead(itemGroup.title) }) {
// 循环渲染ListItem
if (itemGroup.contacts) {
ForEach(itemGroup.contacts, (item: Contact) => {
ListItem() {
// ...
}
}, (item: Contact) => JSON.stringify(item))
}
}
}, (itemGroup: ContactsGroup) => JSON.stringify(itemGroup))
}.sticky(StickyStyle.Header)  // 设置吸顶，实现粘性标题效果
}
}
```
控制滚动位置
控制滚动位置在实际应用中十分常见，例如当新闻页列表项数量庞大，用户滚动列表到一定位置时，希望快速滚动到列表底部或返回列表顶部。此时，可以通过控制滚动位置来实现列表的快速定位，如下图所示。
图13返回列表顶部
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170247.95179166715499524944686888118279:50001231000000:2800:3AA2DD5744E7CFA804F1DF1BF0A16B7056D3760A7BB6F15F5303BA5613736DF0.gif)
List组件初始化时，可以通过scroller参数绑定一个Scroller对象，进行列表的滚动控制。例如，用户在新闻应用中，点击新闻页面底部的返回顶部按钮时，就可以通过Scroller对象的scrollToIndex方法使列表滚动到指定的列表项索引位置。
首先，需要创建一个Scroller的对象listScroller。
```typescript
private listScroller: Scroller = new Scroller();
```
然后，通过将listScroller用于初始化List组件的scroller参数，完成listScroller与列表的绑定。在需要跳转的位置指定scrollToIndex的参数为0，表示返回列表顶部。
```typescript
Stack({ alignContent: Alignment.Bottom }) {
// 将listScroller用于初始化List组件的scroller参数，完成listScroller与列表的绑定。
List({ space: 20, scroller: this.listScroller }) {
// ...
}
Button() {
// ...
}
.onClick(() => {
// 点击按钮时，指定跳转位置，返回列表顶部
this.listScroller.scrollToIndex(0)
})
}
```
响应滚动位置
许多应用需要监听列表的滚动位置变化并作出响应。例如，在联系人列表滚动时，如果跨越了不同字母开头的分组，则侧边字母索引栏也需要更新到对应的字母位置。
除了字母索引之外，滚动列表结合多级分类索引在应用开发过程中也很常见，例如购物应用的商品分类页面，多级分类也需要监听列表的滚动位置。
图14字母索引响应联系人列表滚动
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170248.07633582391796751499875267776710:50001231000000:2800:66E72394B9A8BF15692F9F957F9203E5F7E71C096FC2E74EBCE0FA5B54EF265B.gif)
如上图所示，当联系人列表从A滚动到B时，右侧索引栏也需要同步从选中A状态变成选中B状态。此场景可以通过监听List组件的onScrollIndex事件来实现，右侧索引栏需要使用字母表索引组件AlphabetIndexer。
在列表滚动时，根据列表此时所在的索引值位置firstIndex，重新计算字母索引栏对应字母的位置selectedIndex。由于AlphabetIndexer组件通过selected属性设置了选中项索引值，当selectedIndex变化时会触发AlphabetIndexer组件重新渲染，从而显示为选中对应字母的状态。
```typescript
const alphabets = ['#', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',
'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
@Entry
@Component
struct ContactsList {
@State selectedIndex: number = 0;
private listScroller: Scroller = new Scroller();
build() {
Stack({ alignContent: Alignment.End }) {
List({ scroller: this.listScroller }) {}
.onScrollIndex((firstIndex: number) => {
// 根据列表滚动到的索引值，重新计算对应联系人索引栏的位置this.selectedIndex
})
// 字母表索引组件
AlphabetIndexer({ arrayValue: alphabets, selected: 0 })
.selected(this.selectedIndex)
}
}
}
```
计算索引值时，ListItemGroup作为一个整体占一个索引值，不计算ListItemGroup内部ListItem的索引值。
响应列表项侧滑
侧滑菜单在许多应用中都很常见。例如，通讯类应用通常会给消息列表提供侧滑删除功能，即用户可以通过向左侧滑列表的某一项，再点击删除按钮删除消息，如下图所示。其中，列表项头像右上角标记设置参考给列表项添加标记。
图15侧滑删除列表项
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170248.32910310603914276388848210177548:50001231000000:2800:1985DDE1B95F3220EC2E48FFD14D7EB8013986CEF6BA6176F91EA802B3F65771.gif)
ListItem的swipeAction属性可用于实现列表项的左右滑动功能。swipeAction属性方法初始化时有必填参数SwipeActionOptions，其中，start参数表示设置列表项右滑时起始端滑出的组件，end参数表示设置列表项左滑时尾端滑出的组件。
在消息列表中，end参数表示设置ListItem左滑时尾端划出自定义组件，即删除按钮。在初始化end方法时，将滑动列表项的索引传入删除按钮组件，当用户点击删除按钮时，可以根据索引值来删除列表项对应的数据，从而实现侧滑删除功能。
1.  实现尾端滑出组件的构建。
```typescript
@Builder itemEnd(index: number) {
// 构建尾端滑出组件
Button({ type: ButtonType.Circle }) {
Image($r('app.media.ic_public_delete_filled'))
.width(20)
.height(20)
}
.onClick(() => {
// this.messages为列表数据源，可根据实际场景构造。点击后从数据源删除指定数据项。
this.messages.splice(index, 1);
})
}
```
2.  绑定swipeAction属性到可左滑的ListItem上。
```typescript
// 构建List时，通过ForEach基于数据源this.messages循环渲染ListItem。
ListItem() {
// ...
}
.swipeAction({
end: {
// index为该ListItem在List中的索引值。
builder: () => { this.itemEnd(index) },
}
}) // 设置侧滑属性.
```
给列表项添加标记
添加标记是一种无干扰性且直观的方法，用于显示通知或将注意力集中到应用内的某个区域。例如，当消息列表接收到新消息时，通常对应的联系人头像的右上方会出现标记，提示有若干条未读消息，如下图所示。
图16给列表项添加标记
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170248.28791878996898058890290400006761:50001231000000:2800:B7BC1F7AB3D5CB2E435B19A1CB71E211C18B1816F9875AEC8E6604994FD5C231.png)
在ListItem中使用Badge组件可实现给列表项添加标记功能。Badge是可以附加在单个组件上用于信息标记的容器组件。
在消息列表中，若希望在联系人头像右上角添加标记，可在实现消息列表项ListItem的联系人头像时，将头像Image组件作为Badge的子组件。
在Badge组件中，count和position参数用于设置需要展示的消息数量和提示点显示位置，还可以通过style参数灵活设置标记的样式。
```typescript
ListItem() {
Badge({
count: 1,
position: BadgePosition.RightTop,
style: { badgeSize: 16, badgeColor: '#FA2A2D' }
}) {
// Image组件实现消息联系人头像
// ...
}
}
```
下拉刷新与上拉加载
页面的下拉刷新与上拉加载功能在移动应用中十分常见，例如，新闻页面的内容刷新和加载。这两种操作的原理都是通过响应用户的触摸事件，在顶部或者底部显示一个刷新或加载视图，完成后再将此视图隐藏。
以下拉刷新为例，其实现主要分成三步：
1.  监听手指按下事件，记录其初始位置的值。
2.  监听手指按压移动事件，记录并计算当前移动的位置与初始值的差值，大于0表示向下移动，同时设置一个允许移动的最大值。
3.  监听手指抬起事件，若此时移动达到最大值，则触发数据加载并显示刷新视图，加载完成后将此视图隐藏。
页面的下拉刷新操作推荐使用Refresh组件实现。
下拉刷新与上拉加载的具体实现可参考新闻数据加载。
编辑列表
列表的编辑模式用途十分广泛，常见于待办事项管理、文件管理、备忘录的记录管理等应用场景。在列表的编辑模式下，新增和删除列表项是最基础的功能，其核心是对列表项对应的数据集合进行数据添加和删除。
下面以待办事项管理为例，介绍如何快速实现新增和删除列表项功能。
新增列表项
如下图所示，当用户点击添加按钮时，提供用户新增列表项内容选择或填写的交互界面，用户点击确定后，列表中新增对应的项目。
图17新增待办
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170248.16686141954587862360695198414478:50001231000000:2800:81E9190BEBE10866B6F924759E8C4F542007FFDBDEFC2211D587A6E408E853A3.gif)
添加列表项功能实现主要流程如下：
1.  定义列表项数据结构，以待办事项管理为例，首先定义待办数据结构。
```typescript
//ToDo.ets
import { util } from '@kit.ArkTS'
export class ToDo {
key: string = util.generateRandomUUID(true);
name: string;
constructor(name: string) {
this.name = name;
}
}
```
2.  构建列表整体布局和列表项。
```typescript
//ToDoListItem.ets
import { ToDo } from './ToDo';
@Component
export struct ToDoListItem {
@Link isEditMode: boolean
@Link selectedItems: ToDo[]
private toDoItem: ToDo = new ToDo("");
build() {
Flex({ justifyContent: FlexAlign.SpaceBetween, alignItems: ItemAlign.Center }) {
// ...
}
.width('100%')
.height(80)
//.padding() 根据具体使用场景设置
.borderRadius(24)
//.linearGradient() 根据具体使用场景设置
.gesture(
GestureGroup(GestureMode.Exclusive,
LongPressGesture()
.onAction(() => {
// ...
})
)
)
}
}
```
3.  初始化待办列表数据和可选事项，最后，构建列表布局和列表项。
```typescript
//ToDoList.ets
import { ToDo } from './ToDo';
import { ToDoListItem } from './ToDoListItem';
@Entry
@Component
struct ToDoList {
@State toDoData: ToDo[] = []
@Watch('onEditModeChange') @State isEditMode: boolean = false
@State selectedItems: ToDo[] = []
private availableThings: string[] = ['读书', '运动', '旅游', '听音乐', '看电影', '唱歌']
onEditModeChange() {
if (!this.isEditMode) {
this.selectedItems = []
}
}
build() {
Column() {
Row() {
if (this.isEditMode) {
Text('X')
.fontSize(20)
.onClick(() => {
this.isEditMode = false;
})
.margin({ left: 20, right: 20 })
} else {
Text('待办')
.fontSize(36)
.margin({ left: 40 })
Blank()
Text('+') //提供新增列表项入口，即给新增按钮添加点击事件
.onClick(() => {
this.getUIContext().showTextPickerDialog({
range: this.availableThings,
onAccept: (value: TextPickerResult) => {
let arr = Array.isArray(value.index) ? value.index : [value.index];
for (let i = 0; i < arr.length; i++) {
this.toDoData.push(new ToDo(this.availableThings[arr[i]])); // 新增列表项数据toDoData(可选事项)
}
},
})
})
}
List({ space: 10 }) {
ForEach(this.toDoData, (toDoItem: ToDo) => {
ListItem() {
// 将toDoData的每个数据放入到以model的形式放进ListItem里
ToDoListItem({
isEditMode: this.isEditMode,
toDoItem: toDoItem,
selectedItems: this.selectedItems })
}
}, (toDoItem: ToDo) => toDoItem.key.toString())
}
}
}
}
}
```
删除列表项
如下图所示，当用户长按列表项进入删除模式时，提供用户删除列表项选择的交互界面，用户勾选完成后点击删除按钮，列表中删除对应的项目。
图18长按删除待办事项
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170248.27373629916095377513218923060224:50001231000000:2800:2D0B27E87C0AE92DA154A5BBDB41155F3C6156C15A91417E1E877D2986F9C150.gif)
删除列表项功能实现主要流程如下：
1.  列表的删除功能一般进入编辑模式后才可使用，所以需要提供编辑模式的入口。 以待办列表为例，通过监听列表项的长按事件，当用户长按列表项时，进入编辑模式。
```typescript
// 结构参考
export class ToDo {
key: string = util.generateRandomUUID(true);
name: string;
toDoData: ToDo[] = [];
constructor(name: string) {
this.name = name;
}
}
```
2.  需要响应用户的选择交互，记录要删除的列表项数据。 在待办列表中，通过勾选框的勾选或取消勾选，响应用户勾选列表项变化，记录所有选择的列表项。
```typescript
// 结构参考
import { util } from '@kit.ArkTS'
export class ToDo {
key: string = util.generateRandomUUID(true);
name: string;
toDoData: ToDo[] = [];
constructor(name: string) {
this.name = name;
}
}
```
3.  需要响应用户点击删除按钮事件，删除列表中对应的选项。
```typescript
// 结构参考
import { util } from '@kit.ArkTS'
export class ToDo {
key: string = util.generateRandomUUID(true);
name: string;
toDoData: ToDo[] = [];
constructor(name: string) {
this.name = name;
}
}
```
长列表的处理
循环渲染适用于短列表，当构建具有大量列表项的长列表时，如果直接采用循环渲染方式，会一次性加载所有的列表元素，会导致页面启动时间过长，影响用户体验。因此，推荐使用数据懒加载（LazyForEach）方式实现按需迭代加载数据，从而提升列表性能。
关于长列表按需加载优化的具体实现可参考数据懒加载章节中的示例。
当使用懒加载方式渲染列表时，为了更好的列表滚动体验，减少列表滑动时出现白块，List组件提供了cachedCount参数用于设置列表项缓存数，只在懒加载LazyForEach中生效。
```typescript
List() {
// ...
}.cachedCount(3)
```
以垂直列表为例：
-  若懒加载是用于ListItem，当列表为单列模式时，会在List显示的ListItem前后各缓存cachedCount个ListItem；若是多列模式下，会在List显示的ListItem前后各缓存cachedCount * 列数个ListItem。
-  若懒加载是用于ListItemGroup，无论单列模式还是多列模式，都是在List显示的ListItem前后各缓存cachedCount个ListItemGroup。
1.  cachedCount的增加会增大UI的CPU、内存开销。使用时需要根据实际情况，综合性能和用户体验进行调整。
2.  列表使用数据懒加载时，除了显示区域的列表项和前后缓存的列表项，其他列表项会被销毁。
折叠与展开
列表项的折叠与展开用途广泛，常用于信息清单的展示、填写等应用场景。
图19列表项的折叠与展开
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170248.24653225389614215513819590212307:50001231000000:2800:B0DED752FA8B1DA56348B40EA41633DBD69E023F9CB5BD9497CA3BE3D2A06774.gif)
列表项折叠与展开效果实现主要流程如下：
1.  定义列表项数据结构。
```typescript
interface ItemInfo {
index: number,
name: string,
label: ResourceStr,
type?: string,
}
interface ItemGroupInfo extends ItemInfo {
children: ItemInfo[]
}
```
2.  构造列表结构。
```typescript
@State routes: ItemGroupInfo[] = [
{
index: 0,
name: 'basicInfo',
label: '个人基本资料',
children: [
{
index: 0,
name: '昵称',
label: 'xxxx',
type: 'Text'
},
{
index: 1,
name: '头像',
label: $r('sys.media.ohos_user_auth_icon_face'),
type: 'Image'
},
{
index: 2,
name: '年龄',
label: 'xxxx',
type: 'Text'
},
{
index: 3,
name: '生日',
label: 'xxxxxxxxx',
type: 'Text'
},
{
index: 4,
name: '性别',
label: 'xxxxxxxx',
type: 'Text'
},
]
},
{
index: 1,
name: 'equipInfo',
label: '设备信息',
children: []
},
{
index: 2,
name: 'appInfo',
label: '应用使用信息',
children: []
},
{
index: 3,
name: 'uploadInfo',
label: '您主动上传的数据',
children: []
},
{
index: 4,
name: 'tradeInfo',
label: '交易与资产信息',
children: []
},
{
index: 5,
name: 'otherInfo',
label: '其他资料',
children: []
},
];
@State expandedItems: boolean[] = Array(this.routes.length).fill(false);
@State selection: string | null = null;
build() {
Column() {
// ...
List({ space: 10 }) {
ForEach(this.routes, (itemGroup: ItemGroupInfo) => {
ListItemGroup({
header: this.ListItemGroupHeader(itemGroup),
style: ListItemGroupStyle.CARD,
}) {
if (this.expandedItems[itemGroup.index] && itemGroup.children) {
ForEach(itemGroup.children, (item: ItemInfo) => {
ListItem({ style: ListItemStyle.CARD }) {
Row() {
Text(item.name)
Blank()
if (item.type === 'Image') {
Image(item.label)
.height(20)
.width(20)
} else {
Text(item.label)
}
Image($r('sys.media.ohos_ic_public_arrow_right'))
.fillColor($r('sys.color.ohos_id_color_fourth'))
.height(30)
.width(30)
}
.width("100%")
}
.width("100%")
.animation({ curve: curves.interpolatingSpring(0, 1, 528, 39) })
})
}
}.clip(true)
})
}
.width("100%")
}
.width('100%')
.height('100%')
.justifyContent(FlexAlign.Start)
.backgroundColor($r('sys.color.ohos_id_color_sub_background'))
}
```
3.  通过改变ListItem的状态，来控制每个列表项是否展开，并通过animation和animateTo来实现展开与折叠过程中的动效效果。
```typescript
@Builder
ListItemGroupHeader(itemGroup: ItemGroupInfo) {
Row() {
Text(itemGroup.label)
Blank()
Image($r('sys.media.ohos_ic_public_arrow_down'))
.fillColor($r('sys.color.ohos_id_color_fourth'))
.height(30)
.width(30)
.rotate({ angle: !!itemGroup.children.length ? (this.expandedItems[itemGroup.index] ? 180 : 0) : 180 })
.animation({ curve: curves.interpolatingSpring(0, 1, 228, 22) })
}
.width("100%")
.padding(10)
.animation({ curve: curves.interpolatingSpring(0, 1, 528, 39) })
.onClick(() => {
if (itemGroup.children.length) {
this.getUIContext()?.animateTo({ curve: curves.interpolatingSpring(0, 1, 528, 39) }, () => {
this.expandedItems[itemGroup.index] = !this.expandedItems[itemGroup.index]
})
}
})
}
```
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-layout-development-create-grid-V14
爬取时间: 2025-04-27 23:17:31
来源: Huawei Developer
概述
网格布局是由“行”和“列”分割的单元格所组成，通过指定“项目”所在的单元格做出各种各样的布局。网格布局具有较强的页面均分能力，子组件占比控制能力，是一种重要自适应布局，其使用场景有九宫格图片展示、日历、计算器等。
ArkUI提供了Grid容器组件和子组件GridItem，用于构建网格布局。Grid用于设置网格布局相关参数，GridItem定义子组件相关特征。Grid组件支持使用条件渲染、循环渲染、懒加载等方式生成子组件。
布局与约束
Grid组件为网格容器，其中容器内各条目对应一个GridItem组件，如下图所示。
图1Grid与GridItem组件关系
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170248.53774174902898104842414581332855:50001231000000:2800:3EF54A3D161CDAE3565B55EDFB41633B1FDB0ED5BACA7081533087D7CF0FF3EB.png)
Grid的子组件必须是GridItem组件。
网格布局是一种二维布局。Grid组件支持自定义行列数和每行每列尺寸占比、设置子组件横跨几行或者几列，同时提供了垂直和水平布局能力。当网格容器组件尺寸发生变化时，所有子组件以及间距会等比例调整，从而实现网格布局的自适应能力。根据Grid的这些布局能力，可以构建出不同样式的网格布局，如下图所示。
图2网格布局
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170248.15065043677337137645561757755061:50001231000000:2800:1A3A594A755E2805B32ADE21AC253496CEF268086A1FDEABB67B9B8766C6D73A.png)
如果Grid组件设置了宽高属性，则其尺寸为设置值。如果没有设置宽高属性，Grid组件的尺寸默认适应其父组件的尺寸。
Grid组件根据行列数量与占比属性的设置，可以分为三种布局情况：
-  行、列数量与占比同时设置：Grid只展示固定行列数的元素，其余元素不展示，且Grid不可滚动。（推荐使用该种布局方式）
-  只设置行、列数量与占比中的一个：元素按照设置的方向进行排布，超出的元素可通过滚动的方式展示。
-  行列数量与占比都不设置：元素在布局方向上排布，其行列数由布局方向、单个网格的宽高等多个属性共同决定。超出行列容纳范围的元素不展示，且Grid不可滚动。
设置排列方式
设置行列数量与占比
通过设置行列数量与尺寸占比可以确定网格布局的整体排列方式。Grid组件提供了rowsTemplate和columnsTemplate属性用于设置网格布局行列数量与尺寸占比。
rowsTemplate和columnsTemplate属性值是一个由多个空格和'数字+fr'间隔拼接的字符串，fr的个数即网格布局的行或列数，fr前面的数值大小，用于计算该行或列在网格布局宽度上的占比，最终决定该行或列宽度。
图3行列数量占比示例
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170248.50455346362161977215486543170189:50001231000000:2800:B78F3DA9DCE2EA01803EAD9A6F063A5B09DD62E61E16809E7CE1F1C84548415A.png)
如上图所示，构建的是一个三行三列的网格布局，其在垂直方向上分为三等份，每行占一份；在水平方向上分为四等份，第一列占一份，第二列占两份，第三列占一份。
只要将rowsTemplate的值为'1fr 1fr 1fr'，同时将columnsTemplate的值为'1fr 2fr 1fr'，即可实现上述网格布局。
```typescript
Grid() {
// ...
}
.rowsTemplate('1fr 1fr 1fr')
.columnsTemplate('1fr 2fr 1fr')
```
当Grid组件设置了rowsTemplate或columnsTemplate时，Grid的layoutDirection、maxCount、minCount、cellLength属性不生效，属性说明可参考Grid-属性。
设置子组件所占行列数
除了大小相同的等比例网格布局，由不同大小的网格组成不均匀分布的网格布局场景在实际应用中十分常见，如下图所示。在Grid组件中，可以通过创建Grid时传入合适的GridLayoutOptions实现如图所示的单个网格横跨多行或多列的场景，其中，irregularIndexes和onGetIrregularSizeByIndex可对仅设置rowsTemplate或columnsTemplate的Grid使用；onGetRectByIndex可对同时设置rowsTemplate和columnsTemplate的Grid使用。
图4不均匀网格布局
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170249.31542026968130896957444412441863:50001231000000:2800:9FE707FC8BDBCAAF979D01BB19D4E78B084BFF0E97C3C5682A4740BDB48B1A80.png)
例如计算器的按键布局就是常见的不均匀网格布局场景。如下图，计算器中的按键“0”和“=”，按键“0”横跨第一、二两列，按键“=”横跨第五、六两行。使用Grid构建的网格布局，其行列标号从0开始，依次编号。
图5计算器
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170249.16413160085226957070272426673076:50001231000000:2800:25CA2DA3FE4A3637B89D6B9298131D4C7E8D15FAAD7A5876AFC433C68B74B0F9.png)
在网格中，可以通过onGetRectByIndex返回的[rowStart,columnStart,rowSpan,columnSpan]来实现跨行跨列布局，其中rowStart和columnStart属性表示指定当前元素起始行号和起始列号，rowSpan和columnSpan属性表示指定当前元素的占用行数和占用列数。
所以“0”按键横跨第一列和第二列，“=”按键横跨第五行和第六行，只要将“0”对应onGetRectByIndex的rowStart和columnStart设为6和0，rowSpan和columnSpan设为1和2，将“=”对应onGetRectByIndex的rowStart和columnStart设为5和3，rowSpan和columnSpan设为2和1即可。
```typescript
layoutOptions: GridLayoutOptions = {
regularSize: [1, 1],
onGetRectByIndex: (index: number) => {
if (index == key1) { // key1是“0”按键对应的index
return [6, 0, 1, 2];
} else if (index == key2) { // key2是“=”按键对应的index
return [5, 3, 2, 1];
}
// ...
// 这里需要根据具体布局返回其他item的位置
}
}
Grid(undefined, this.layoutOptions) {
// ...
}
.columnsTemplate('1fr 1fr 1fr 1fr')
.rowsTemplate('1fr 1fr 1fr 1fr 1fr 1fr 1fr')
```
设置主轴方向
使用Grid构建网格布局时，若没有设置行列数量与占比，可以通过layoutDirection设置网格布局的主轴方向，决定子组件的排列方式。此时可以结合minCount和maxCount属性来约束主轴方向上的网格数量。
图6主轴方向示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170249.55740632452611527554156559345820:50001231000000:2800:1A30F24CFDEB650E372BAAA411879711B6C57BECDC937C71D0A4B673BF5672CD.png)
当前layoutDirection设置为Row时，先从左到右排列，排满一行再排下一行。当前layoutDirection设置为Column时，先从上到下排列，排满一列再排下一列，如上图所示。此时，将maxCount属性设为3，表示主轴方向上最大显示的网格单元数量为3。
```typescript
Grid() {
// ...
}
.maxCount(3)
.layoutDirection(GridDirection.Row)
```
在网格布局中显示数据
网格布局采用二维布局的方式组织其内部元素，如下图所示。
图7通用办公服务
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170249.26933860811248307345136784448237:50001231000000:2800:9DC4A861E25E6ADEEC578C90361929650C69A9DC5A9069C2604E38FE8E7415F9.png)
Grid组件可以通过二维布局的方式显示一组GridItem子组件。
```typescript
Grid() {
GridItem() {
Text('会议')
// ...
}
GridItem() {
Text('签到')
// ...
}
GridItem() {
Text('投票')
// ...
}
GridItem() {
Text('打印')
// ...
}
}
.rowsTemplate('1fr 1fr')
.columnsTemplate('1fr 1fr')
```
对于内容结构相似的多个GridItem，通常更推荐使用ForEach语句中嵌套GridItem的形式，来减少重复代码。
```typescript
@Entry
@Component
struct OfficeService {
@State services: Array<string> = ['会议', '投票', '签到', '打印']
build() {
Column() {
Grid() {
ForEach(this.services, (service:string) => {
GridItem() {
Text(service)
}
}, (service:string):string => service)
}
.rowsTemplate(('1fr 1fr') as string)
.columnsTemplate(('1fr 1fr') as string)
}
}
}
```
设置行列间距
在两个网格单元之间的网格横向间距称为行间距，网格纵向间距称为列间距，如下图所示。
图8网格的行列间距
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170249.07609866715235714377488095091602:50001231000000:2800:4EEF00DE869E04CABAEDFF8A32EB6307C4F4FAD6BCE2C691827E6A325898A5DF.png)
通过Grid的rowsGap和columnsGap可以设置网格布局的行列间距。在图5所示的计算器中，行间距为15vp，列间距为10vp。
```typescript
Grid() {
// ...
}
.columnsGap(10)
.rowsGap(15)
```
构建可滚动的网格布局
可滚动的网格布局常用在文件管理、购物或视频列表等页面中，如下图所示。在设置Grid的行列数量与占比时，如果仅设置行、列数量与占比中的一个，即仅设置rowsTemplate或仅设置columnsTemplate属性，网格单元按照设置的方向排列，超出Grid显示区域后，Grid拥有可滚动能力。
图9横向可滚动网格布局
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170249.34517595364639382470184604624394:50001231000000:2800:4E29CE99613F05F560E773C8A290D58F281A26F96F7E036C3474115F9C98876B.gif)
如果设置的是columnsTemplate，Grid的滚动方向为垂直方向；如果设置的是rowsTemplate，Grid的滚动方向为水平方向。
如上图所示的横向可滚动网格布局，只要设置rowsTemplate属性的值且不设置columnsTemplate属性，当内容超出Grid组件宽度时，Grid可横向滚动进行内容展示。
```typescript
@Entry
@Component
struct Shopping {
@State services: Array<string> = ['直播', '进口']
build() {
Column({ space: 5 }) {
Grid() {
ForEach(this.services, (service: string, index) => {
GridItem() {
}
.width('25%')
}, (service:string):string => service)
}
.rowsTemplate('1fr 1fr') // 只设置rowsTemplate属性，当内容超出Grid区域时，可水平滚动。
.rowsGap(15)
}
}
}
```
控制滚动位置
与新闻列表的返回顶部场景类似，控制滚动位置功能在网格布局中也很常用，例如下图所示日历的翻页功能。
图10日历翻页
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170249.12250196122910643668659070689162:50001231000000:2800:EB5265A66D6C7583E4FA296E98919E84F97D7794EBFEBC12DA41FF59516DEF27.gif)
Grid组件初始化时，可以绑定一个Scroller对象，用于进行滚动控制，例如通过Scroller对象的scrollPage方法进行翻页。
```typescript
private scroller: Scroller = new Scroller()
```
在日历页面中，用户在点击“下一页”按钮时，应用响应点击事件，通过指定scrollPage方法的参数next为true，滚动到下一页。
```typescript
Column({ space: 5 }) {
Grid(this.scroller) {
}
.columnsTemplate('1fr 1fr 1fr 1fr 1fr 1fr 1fr')
Row({space: 20}) {
Button('上一页')
.onClick(() => {
this.scroller.scrollPage({
next: false
})
})
Button('下一页')
.onClick(() => {
this.scroller.scrollPage({
next: true
})
})
}
}
```
性能优化
与长列表的处理类似，循环渲染适用于数据量较小的布局场景，当构建具有大量网格项的可滚动网格布局时，推荐使用数据懒加载方式实现按需迭代加载数据，从而提升列表性能。
关于按需加载优化的具体实现可参考数据懒加载章节中的示例。
当使用懒加载方式渲染网格时，为了更好的滚动体验，减少滑动时出现白块，Grid组件中也可通过cachedCount属性设置GridItem的预加载数量，只在懒加载LazyForEach中生效。
设置预加载数量后，会在Grid显示区域前后各缓存cachedCount*列数个GridItem，超出显示和缓存范围的GridItem会被释放。
```typescript
Grid() {
LazyForEach(this.dataSource, () => {
GridItem() {
}
})
}
.cachedCount(3)
```
cachedCount的增加会增大UI的CPU、内存开销。使用时需要根据实际情况，综合性能和用户体验进行调整。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-layout-development-create-looping-V14
爬取时间: 2025-04-27 23:17:44
来源: Huawei Developer
Swiper组件提供滑动轮播显示的能力。Swiper本身是一个容器组件，当设置了多个子组件后，可以对这些子组件进行轮播显示。通常，在一些应用首页显示推荐的内容时，需要用到轮播显示的能力。
针对复杂页面场景，可以使用 Swiper 组件的预加载机制，利用主线程的空闲时间来提前构建和布局绘制组件，优化滑动体验。
布局与约束
Swiper作为一个容器组件，如果设置了自身尺寸属性，则在轮播显示过程中均以该尺寸生效。如果自身尺寸属性未被设置，则分两种情况：如果设置了prevMargin或者nextMargin属性，则Swiper自身尺寸会跟随其父组件；如果未设置prevMargin或者nextMargin属性，则会自动根据子组件的大小设置自身的尺寸。
循环播放
通过loop属性控制是否循环播放，该属性默认值为true。
当loop为true时，在显示第一页或最后一页时，可以继续往前切换到前一页或者往后切换到后一页。如果loop为false，则在第一页或最后一页时，无法继续向前或者向后切换页面。
```typescript
Swiper() {
Text('0')
.width('90%')
.height('100%')
.backgroundColor(Color.Gray)
.textAlign(TextAlign.Center)
.fontSize(30)
Text('1')
.width('90%')
.height('100%')
.backgroundColor(Color.Green)
.textAlign(TextAlign.Center)
.fontSize(30)
Text('2')
.width('90%')
.height('100%')
.backgroundColor(Color.Pink)
.textAlign(TextAlign.Center)
.fontSize(30)
}
.loop(true)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170249.08459839406922523523659032502196:50001231000000:2800:AFC6EE408FEE57857CBEBE73E733F68B505FB72A86389E6D78DC65F26C92C9FB.gif)
```typescript
Swiper() {
// ...
}
.loop(false)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170249.41315056480142830656304716722514:50001231000000:2800:BC2C7DD7EEB6EEFFC2932A37B81111EB999B24C305DFE361380C0BABC83DC4E3.gif)
自动轮播
Swiper通过设置autoPlay属性，控制是否自动轮播子组件。该属性默认值为false。
autoPlay为true时，会自动切换播放子组件，子组件与子组件之间的播放间隔通过interval属性设置。interval属性默认值为3000，单位毫秒。
```typescript
Swiper() {
// ...
}
.loop(true)
.autoPlay(true)
.interval(1000)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170249.61211554509449724557742668927839:50001231000000:2800:696E023765661B97F7D9757031E2D699CAD31DA4FACA583EC40CE0E64C4BD132.gif)
导航点样式
Swiper提供了默认的导航点样式和导航点箭头样式，导航点默认显示在Swiper下方居中位置，开发者也可以通过indicator属性自定义导航点的位置和样式，导航点箭头默认不显示。
通过indicator属性，开发者可以设置导航点相对于Swiper组件上下左右四个方位的位置，同时也可以设置每个导航点的尺寸、颜色、蒙层和被选中导航点的颜色。
```typescript
Swiper() {
Text('0')
.width('90%')
.height('100%')
.backgroundColor(Color.Gray)
.textAlign(TextAlign.Center)
.fontSize(30)
Text('1')
.width('90%')
.height('100%')
.backgroundColor(Color.Green)
.textAlign(TextAlign.Center)
.fontSize(30)
Text('2')
.width('90%')
.height('100%')
.backgroundColor(Color.Pink)
.textAlign(TextAlign.Center)
.fontSize(30)
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.86299962927153608831887273201365:50001231000000:2800:732E91626D3C8FF8999B955C7D9F10BEC4F54755C49ACA2DBB026E10719C54C1.png)
导航点直径设为30vp，左边距为0，导航点颜色设为红色。
```typescript
Swiper() {
// ...
}
.indicator(
Indicator.dot()
.left(0)
.itemWidth(15)
.itemHeight(15)
.selectedItemWidth(30)
.selectedItemHeight(15)
.color(Color.Red)
.selectedColor(Color.Blue)
)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.01197699307305474147128683267511:50001231000000:2800:772E3510FC12FF2B7DF91D5D301D4D9C4EA4F175AC02281A481910C3CC1D2E1A.png)
Swiper通过设置displayArrow属性，可以控制导航点箭头的大小、位置、颜色，底板的大小及颜色，以及鼠标悬停时是否显示箭头。
```typescript
Swiper() {
// ...
}
.displayArrow(true, false)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.57419791604961071913163341939748:50001231000000:2800:5DB999FEC34D341CDCB88E5E388DFE5F58CEFF486C12A26CD88D9138B959DD92.gif)
箭头显示在组件两侧，大小为18vp，导航点箭头颜色设为蓝色。
```typescript
Swiper() {
// ...
}
.displayArrow({
showBackground: true,
isSidebarMiddle: true,
backgroundSize: 24,
backgroundColor: Color.White,
arrowSize: 18,
arrowColor: Color.Blue
}, false)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.62213215134030877161551267126928:50001231000000:2800:D1C4DB3E746D48B0F57885B8813FED0BE21B5A14DF8A73EF94FDF98BA98C8016.gif)
页面切换方式
Swiper支持手指滑动、点击导航点和通过控制器三种方式切换页面，以下示例展示通过控制器切换页面的方法。
```typescript
@Entry
@Component
struct SwiperDemo {
private swiperController: SwiperController = new SwiperController();
build() {
Column({ space: 5 }) {
Swiper(this.swiperController) {
Text('0')
.width(250)
.height(250)
.backgroundColor(Color.Gray)
.textAlign(TextAlign.Center)
.fontSize(30)
Text('1')
.width(250)
.height(250)
.backgroundColor(Color.Green)
.textAlign(TextAlign.Center)
.fontSize(30)
Text('2')
.width(250)
.height(250)
.backgroundColor(Color.Pink)
.textAlign(TextAlign.Center)
.fontSize(30)
}
.indicator(true)
Row({ space: 12 }) {
Button('showNext')
.onClick(() => {
this.swiperController.showNext(); // 通过controller切换到后一页
})
Button('showPrevious')
.onClick(() => {
this.swiperController.showPrevious(); // 通过controller切换到前一页
})
}.margin(5)
}.width('100%')
.margin({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.76419970587467062747222179700482:50001231000000:2800:C45E7C0C384A98A985E2BE83D974AD280BB8A9D5DD4E816C65EC722398605FBA.gif)
轮播方向
Swiper支持水平和垂直方向上进行轮播，主要通过vertical属性控制。
当vertical为true时，表示在垂直方向上进行轮播；为false时，表示在水平方向上进行轮播。vertical默认值为false。
```typescript
Swiper() {
// ...
}
.indicator(true)
.vertical(false)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.90078316639680150975487142742502:50001231000000:2800:4A5CE8C8730EF313FECE48FA3444E5D361D3D8E689D815E2C803003684618967.png)
```typescript
Swiper() {
// ...
}
.indicator(true)
.vertical(true)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.19554080499827959614132418660838:50001231000000:2800:3A66188828E508D6E4B7253197D6E233BBC5335B92CF94461B7881AF774D54FF.png)
每页显示多个子页面
Swiper支持在一个页面内同时显示多个子组件，通过displayCount属性设置。
```typescript
Swiper() {
Text('0')
.width(250)
.height(250)
.backgroundColor(Color.Gray)
.textAlign(TextAlign.Center)
.fontSize(30)
Text('1')
.width(250)
.height(250)
.backgroundColor(Color.Green)
.textAlign(TextAlign.Center)
.fontSize(30)
Text('2')
.width(250)
.height(250)
.backgroundColor(Color.Pink)
.textAlign(TextAlign.Center)
.fontSize(30)
Text('3')
.width(250)
.height(250)
.backgroundColor(Color.Blue)
.textAlign(TextAlign.Center)
.fontSize(30)
}
.indicator(true)
.displayCount(2)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.27864987521639284710475023002415:50001231000000:2800:EF5BD9FFFC0FB24FE46FB41039123F1EA911E8D761E85DD93D1C24ADF2546C2A.png)
自定义切换动画
Swiper支持通过customContentTransition设置自定义切换动画，可以在回调中对视窗内所有页面逐帧设置透明度、缩放比例、位移、渲染层级等属性实现自定义切换动画。
```typescript
@Entry
@Component
struct SwiperCustomAnimationExample {
private DISPLAY_COUNT: number = 2
private MIN_SCALE: number = 0.75
@State backgroundColors: Color[] = [Color.Green, Color.Blue, Color.Yellow, Color.Pink, Color.Gray, Color.Orange]
@State opacityList: number[] = []
@State scaleList: number[] = []
@State translateList: number[] = []
@State zIndexList: number[] = []
aboutToAppear(): void {
for (let i = 0; i < this.backgroundColors.length; i++) {
this.opacityList.push(1.0)
this.scaleList.push(1.0)
this.translateList.push(0.0)
this.zIndexList.push(0)
}
}
build() {
Column() {
Swiper() {
ForEach(this.backgroundColors, (backgroundColor: Color, index: number) => {
Text(index.toString()).width('100%').height('100%').fontSize(50).textAlign(TextAlign.Center)
.backgroundColor(backgroundColor)
.opacity(this.opacityList[index])
.scale({ x: this.scaleList[index], y: this.scaleList[index] })
.translate({ x: this.translateList[index] })
.zIndex(this.zIndexList[index])
})
}
.height(300)
.indicator(false)
.displayCount(this.DISPLAY_COUNT, true)
.customContentTransition({
timeout: 1000,
transition: (proxy: SwiperContentTransitionProxy) => {
if (proxy.position <= proxy.index % this.DISPLAY_COUNT || proxy.position >= this.DISPLAY_COUNT + proxy.index % this.DISPLAY_COUNT) {
// 同组页面完全滑出视窗外时，重置属性值
this.opacityList[proxy.index] = 1.0
this.scaleList[proxy.index] = 1.0
this.translateList[proxy.index] = 0.0
this.zIndexList[proxy.index] = 0
} else {
// 同组页面未滑出视窗外时，对同组中左右两个页面，逐帧根据position修改属性值
if (proxy.index % this.DISPLAY_COUNT === 0) {
this.opacityList[proxy.index] = 1 - proxy.position / this.DISPLAY_COUNT
this.scaleList[proxy.index] = this.MIN_SCALE + (1 - this.MIN_SCALE) * (1 - proxy.position / this.DISPLAY_COUNT)
this.translateList[proxy.index] = - proxy.position * proxy.mainAxisLength + (1 - this.scaleList[proxy.index]) * proxy.mainAxisLength / 2.0
} else {
this.opacityList[proxy.index] = 1 - (proxy.position - 1) / this.DISPLAY_COUNT
this.scaleList[proxy.index] = this.MIN_SCALE + (1 - this.MIN_SCALE) * (1 - (proxy.position - 1) / this.DISPLAY_COUNT)
this.translateList[proxy.index] = - (proxy.position - 1) * proxy.mainAxisLength - (1 - this.scaleList[proxy.index]) * proxy.mainAxisLength / 2.0
}
this.zIndexList[proxy.index] = -1
}
}
})
}.width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.31366225928165122341288545463922:50001231000000:2800:1090F43402982EC6ACD5D6F9F29B9AF6CAB911A9D864ECF9597D7C1BB5D16682.gif)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-navigation-tabs-V14
爬取时间: 2025-04-27 23:17:58
来源: Huawei Developer
当页面信息较多时，为了让用户能够聚焦于当前显示的内容，需要对页面内容进行分类，提高页面空间利用率。Tabs组件可以在一个页面内快速实现视图内容的切换，一方面提升查找信息的效率，另一方面精简用户单次获取到的信息量。
基本布局
Tabs组件的页面组成包含两个部分，分别是TabContent和TabBar。TabContent是内容页，TabBar是导航页签栏，页面结构如下图所示，根据不同的导航类型，布局会有区别，可以分为底部导航、顶部导航、侧边导航，其导航栏分别位于底部、顶部和侧边。
图1Tabs组件布局示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.15618306267089631656727418921126:50001231000000:2800:8E3D3C93FD1BE0D9DDD56E6B3E873DBFCA23A629E9416BFA7EE7167C8FD1BB6A.png)
-  TabContent组件不支持设置通用宽度属性，其宽度默认撑满Tabs父组件。
-  TabContent组件不支持设置通用高度属性，其高度由Tabs父组件高度与TabBar组件高度决定。
Tabs使用花括号包裹TabContent，如图2，其中TabContent显示相应的内容页。
图2Tabs与TabContent使用
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.85703762875250429731292552182161:50001231000000:2800:878DDD49037E4099E858CC89C555F1CABF33DDEC2C61ADB0B78CADC8AAA1178D.png)
每一个TabContent对应的内容需要有一个页签，可以通过TabContent的tabBar属性进行配置。在如下TabContent组件上设置tabBar属性，可以设置其对应页签中的内容，tabBar作为内容的页签。
```typescript
TabContent() {
Text('首页的内容').fontSize(30)
}
.tabBar('首页')
```
设置多个内容时，需在Tabs内按照顺序放置。
```typescript
Tabs() {
TabContent() {
Text('首页的内容').fontSize(30)
}
.tabBar('首页')
TabContent() {
Text('推荐的内容').fontSize(30)
}
.tabBar('推荐')
TabContent() {
Text('发现的内容').fontSize(30)
}
.tabBar('发现')
TabContent() {
Text('我的内容').fontSize(30)
}
.tabBar("我的")
}
```
底部导航
底部导航是应用中最常见的一种导航方式。底部导航位于应用一级页面的底部，用户打开应用，能够分清整个应用的功能分类，以及页签对应的内容，并且其位于底部更加方便用户单手操作。底部导航一般作为应用的主导航形式存在，其作用是将用户关心的内容按照功能进行分类，迎合用户使用习惯，方便在不同模块间的内容切换。
图3底部导航栏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.66104923101127942267278141461154:50001231000000:2800:1A3E3EBD30BB8B319EB83491D348C4B680541A83F13298A8E1A7B140E59FC129.gif)
导航栏位置使用Tabs的barPosition参数进行设置。默认情况下，导航栏位于顶部，此时，barPosition为BarPosition.Start。设置为底部导航时，需要将barPosition设置为BarPosition.End。
```typescript
Tabs({ barPosition: BarPosition.End }) {
// TabContent的内容：首页、发现、推荐、我的
// ...
}
```
顶部导航
当内容分类较多，用户对不同内容的浏览概率相差不大，需要经常快速切换时，一般采用顶部导航模式进行设计，作为对底部导航内容的进一步划分，常见一些资讯类应用对内容的分类为关注、视频、数码，或者主题应用中对主题进行进一步划分为图片、视频、字体等。
图4顶部导航栏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.42649686298043972495193080626631:50001231000000:2800:6F0F895F94FF58D521E1759310136EC0E20D0D6B1FD116A40BBA6E3B6A49D7B0.gif)
```typescript
Tabs({ barPosition: BarPosition.Start }) {
// TabContent的内容:关注、视频、游戏、数码、科技、体育、影视
// ...
}
```
侧边导航
侧边导航是应用较为少见的一种导航模式，更多适用于横屏界面，用于对应用进行导航操作，由于用户的视觉习惯是从左到右，侧边导航栏默认为左侧侧边栏。
图5侧边导航栏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170250.13086965951084165445704136080459:50001231000000:2800:92E8A411C484C9B502D64F68C3D7E8D10D77EBB27B6BC199712CC09EE9585E4C.png)
实现侧边导航栏需要将Tabs的vertical属性设置为true，vertical默认值为false，表明内容页和导航栏垂直方向排列。
```typescript
Tabs({ barPosition: BarPosition.Start }) {
// TabContent的内容:首页、发现、推荐、我的
// ...
}
.vertical(true)
.barWidth(100)
.barHeight(200)
```
-  vertical为false时，tabbar的宽度默认为撑满屏幕的宽度，需要设置barWidth为合适值。
-  vertical为true时，tabbar的高度默认为实际内容的高度，需要设置barHeight为合适值。
限制导航栏的滑动切换
默认情况下，导航栏都支持滑动切换，在一些内容信息量需要进行多级分类的页面，如支持底部导航+顶部导航组合的情况下，底部导航栏的滑动效果与顶部导航出现冲突，此时需要限制底部导航的滑动，避免引起不好的用户体验。
图6限制底部导航栏滑动
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170251.34432277655976466910773540983566:50001231000000:2800:1F6FCE3EE0CDB7467B2C01AC4B20C0AC75BBD132E6D8587A6533ACE60394E7ED.gif)
控制滑动切换的属性为scrollable，默认值为true，表示可以滑动，若要限制滑动切换页签则需要设置为false。
```typescript
Tabs({ barPosition: BarPosition.End }) {
TabContent(){
Column(){
Tabs(){
// 顶部导航栏内容
// ...
}
}
.backgroundColor('#ff08a8f1')
.width('100%')
}
.tabBar('首页')
// 其他TabContent内容：发现、推荐、我的
// ...
}
.scrollable(false)
```
固定导航栏
当内容分类较为固定且不具有拓展性时，例如底部导航内容分类一般固定，分类数量一般在3-5个，此时使用固定导航栏。固定导航栏不可滚动，无法被拖拽滚动，内容均分tabBar的宽度。
图7固定导航栏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170251.92452895913253132412150738403386:50001231000000:2800:AE40A864A1027939116DADE4CDB0BECA4245A41D3B15421451C045D01CC2305A.gif)
Tabs的barMode属性用于控制导航栏是否可以滚动，默认值为BarMode.Fixed。
```typescript
Tabs({ barPosition: BarPosition.End }) {
// TabContent的内容：首页、发现、推荐、我的
// ...
}
.barMode(BarMode.Fixed)
```
滚动导航栏
滚动导航栏可以用于顶部导航栏或者侧边导航栏的设置，内容分类较多，屏幕宽度无法容纳所有分类页签的情况下，需要使用可滚动的导航栏，支持用户点击和滑动来加载隐藏的页签内容。
图8可滚动导航栏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170251.85199085647965187278949129777109:50001231000000:2800:59B59241D63B015AFAEEC3832CEF58CF4228AE5892511F1B33D1CEE3E5442B43.gif)
滚动导航栏需要设置Tabs组件的barMode属性，默认值为BarMode.Fixed表示为固定导航栏，BarMode.Scrollable表示可滚动导航栏。
```typescript
Tabs({ barPosition: BarPosition.Start }) {
// TabContent的内容：关注、视频、游戏、数码、科技、体育、影视、人文、艺术、自然、军事
// ...
}
.barMode(BarMode.Scrollable)
```
自定义导航栏
对于底部导航栏，一般作为应用主页面功能区分，为了更好的用户体验，会组合文字以及对应语义图标表示页签内容，这种情况下，需要自定义导航页签的样式。
图9自定义导航栏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170251.83794837193998720708869787575172:50001231000000:2800:3019DF0DB035E4B1CED3F851621F33672FB9155375BDAD7A41C606939FC68282.png)
系统默认情况下采用了下划线标志当前活跃的页签，而自定义导航栏需要自行实现相应的样式，用于区分当前活跃页签和未活跃页签。
设置自定义导航栏需要使用tabBar的参数，以其支持的CustomBuilder的方式传入自定义的函数组件样式。例如这里声明tabBuilder的自定义函数组件，传入参数包括页签文字title，对应位置index，以及选中状态和未选中状态的图片资源。通过当前活跃的currentIndex和页签对应的targetIndex匹配与否，决定UI显示的样式。
```typescript
@State currentIndex: number = 0;
@Builder tabBuilder(title: string, targetIndex: number, selectedImg: Resource, normalImg: Resource) {
Column() {
Image(this.currentIndex === targetIndex ? selectedImg : normalImg)
.size({ width: 25, height: 25 })
Text(title)
.fontColor(this.currentIndex === targetIndex ? '#1698CE' : '#6B6B6B')
}
.width('100%')
.height(50)
.justifyContent(FlexAlign.Center)
}
```
在TabContent对应tabBar属性中传入自定义函数组件，并传递相应的参数。
```typescript
TabContent() {
Column(){
Text('我的内容')
}
.width('100%')
.height('100%')
.backgroundColor('#007DFF')
}
.tabBar(this.tabBuilder('我的', 0, $r('app.media.mine_selected'), $r('app.media.mine_normal')))
```
切换至指定页签
在不使用自定义导航栏时，默认的Tabs会实现切换逻辑。在使用了自定义导航栏后，默认的Tabs仅实现滑动内容页和点击页签时内容页的切换逻辑，页签切换逻辑需要自行实现。即用户滑动内容页和点击页签时，页签栏需要同步切换至内容页对应的页签。
图10内容页和页签不联动
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170251.15953850328571945250094272166637:50001231000000:2800:374EC5A624D4086B5495EFD07B21B2DDD9786B07BFF87651BDA7773AA3ACB09F.gif)
此时需要使用Tabs提供的onChange事件方法，监听索引index的变化，并将当前活跃的index值传递给currentIndex，实现页签的切换。
```typescript
@Entry
@Component
struct TabsExample1 {
@State currentIndex: number = 2
@Builder tabBuilder(title: string, targetIndex: number) {
Column() {
Text(title)
.fontColor(this.currentIndex === targetIndex ? '#1698CE' : '#6B6B6B')
}
}
build() {
Column() {
Tabs({ barPosition: BarPosition.End }) {
TabContent() {
// ...
}.tabBar(this.tabBuilder('首页', 0))
TabContent() {
// ...
}.tabBar(this.tabBuilder('发现', 1))
TabContent() {
// ...
}.tabBar(this.tabBuilder('推荐', 2))
TabContent() {
// ...
}.tabBar(this.tabBuilder('我的', 3))
}
.animationDuration(0)
.backgroundColor('#F1F3F5')
.onChange((index: number) => {
this.currentIndex = index
})
}.width('100%')
}
}
```
图11内容页和页签联动
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170251.60884194717852987476539388760175:50001231000000:2800:D02E8EECA0CE56EB2BE7AB961E6E04E9E40612CC1457952DBC6351971802ABB9.gif)
若希望不滑动内容页和点击页签也能实现内容页和页签的切换，可以将currentIndex传给Tabs的index参数，通过改变currentIndex来实现跳转至指定索引值对应的TabContent内容。也可以使用TabsController，TabsController是Tabs组件的控制器，用于控制Tabs组件进行内容页切换。通过TabsController的changeIndex方法来实现跳转至指定索引值对应的TabContent内容。
```typescript
@State currentIndex: number = 2
private controller: TabsController = new TabsController()
Tabs({ barPosition: BarPosition.End, index: this.currentIndex, controller: this.controller }) {
// ...
}
.height(600)
.onChange((index: number) => {
this.currentIndex = index
})
Button('动态修改index').width('50%').margin({ top: 20 })
.onClick(()=>{
this.currentIndex = (this.currentIndex + 1) % 4
})
Button('changeIndex').width('50%').margin({ top: 20 })
.onClick(()=>{
let index = (this.currentIndex + 1) % 4
this.controller.changeIndex(index)
})
```
图12切换指定页签
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170251.84841812898830979818550491876979:50001231000000:2800:D093E55AEBC5E4A904C6FDB52EBDC6A2CC6E45A7F5255E5E186AC1A4B7D270BE.gif)
开发者可以通过Tabs组件的onContentWillChange接口，设置自定义拦截回调函数。拦截回调函数在下一个页面即将展示时被调用，如果回调返回true，新页面可以展示；如果回调返回false，新页面不会展示，仍显示原来页面。
```typescript
Tabs({ barPosition: BarPosition.End, controller: this.controller, index: this.currentIndex }) {
// ...
}
.onContentWillChange((currentIndex, comingIndex) => {
if (comingIndex == 2) {
return false
}
return true
})
```
图13支持开发者自定义页面切换拦截事件
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170251.44059076091316755362033454220837:50001231000000:2800:1BF5E42310783885E7610E9792EFDA325DFFD611D6459765CAA6E8C575E17AE6.gif)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-develop-apply-immersive-effects-V14
爬取时间: 2025-04-27 23:18:12
来源: Huawei Developer
概述
典型应用全屏窗口UI元素包括状态栏、应用界面和底部导航条，其中状态栏和导航条，通常在沉浸式布局下称为避让区；避让区之外的区域称为安全区。开发应用沉浸式效果主要指通过调整状态栏、应用界面和导航条的显示效果来减少状态栏导航条等系统界面的突兀感，从而使用户获得最佳的UI体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170251.87155488019396829684377501690595:50001231000000:2800:7978CE48ADA823634B9A57AC67E581782061588EC1485E38B675279535C4CEF9.png)
开发应用沉浸式效果主要要考虑如下几个设计要素：
针对上面的设计要求，可以通过如下两种方式实现应用沉浸式效果：
-  该方案下，界面元素仅做绘制延伸，无法单独布局到状态栏和导航条区域，针对需要单独布局UI元素到状态栏和导航条区域的场景建议使用窗口全屏布局方案处理。
窗口全屏布局方案
窗口全屏布局方案主要涉及以下应用扩展布局，全屏显示，不隐藏避让区和应用扩展布局，隐藏避让区两个应用场景。
应用扩展布局，全屏显示，不隐藏避让区
可以通过调用窗口强制全屏布局接口setWindowLayoutFullScreen()实现界面元素延伸到状态栏和导航条；然后通过接口getWindowAvoidArea()和on('avoidAreaChange')获取并动态监听避让区域的变更信息，页面布局根据避让区域信息进行动态调整；设置状态栏或导航条的颜色等属性与界面元素进行匹配。
```typescript
// EntryAbility.ets
// 2. 获取布局避让遮挡的区域
let type = window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR; // 以导航条避让为例
let avoidArea = windowClass.getWindowAvoidArea(type);
let bottomRectHeight = avoidArea.bottomRect.height; // 获取到导航条区域的高度
AppStorage.setOrCreate('bottomRectHeight', bottomRectHeight);
type = window.AvoidAreaType.TYPE_SYSTEM; // 以状态栏避让为例
avoidArea = windowClass.getWindowAvoidArea(type);
let topRectHeight = avoidArea.topRect.height; // 获取状态栏区域高度
AppStorage.setOrCreate('topRectHeight', topRectHeight);
```
1.  避让区域存在大小为0的情况，当获取到的避让区域为0时，开发者需注意针对性处理适配此时的页面区域和布局，避免贴边、内容裁剪等问题，影响应用界面正常显示或美观性。 如下例子中，对控件顶部设置padding（具体数值与状态栏高度一致），实现对状态栏的避让；对底部设置padding（具体数值与底部导航条区域高度一致），实现对底部导航条的避让。如果去掉顶部和底部的padding设置，即不避让状态栏和导航条，UI元素就会发生重叠。具体可见下文步骤中图2和图3的效果对比。
2.  此例中UI颜色主要有两种，比较简单，故未对状态栏文字颜色、背景色进行设置。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170251.06934778334072233017262015339101:50001231000000:2800:2626B38460E05576FDB47E30913E46A04B4F529D437AA6B819AE685922FA979F.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170251.93671498677068646067587563568912:50001231000000:2800:50648A36E572809C4AD01F7A745AFEA1613876AAB5BCE83F899FF0A57D1046FB.jpg)
应用扩展布局，隐藏避让区
此场景下导航条会自动隐藏，适用于游戏、电影等应用场景。可以通过从底部上滑唤出导航条。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170251.15449562993550251987217651649107:50001231000000:2800:6285D85E17BDD79376EB075D4F7324FF8A53945024D62470B089FD5D14554AEA.png)
组件安全区方案
应用未使用setWindowLayoutFullScreen()接口设置窗口全屏布局时，默认使能组件安全区布局。
应用在默认情况下窗口背景绘制范围是全屏，但UI元素被限制在安全区内（自动排除状态栏和导航条）进行布局，来避免界面元素被状态栏和导航条遮盖。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170252.41406025379390114144826299609182:50001231000000:2800:CF63915AC817096E851F7A3D08250C4F2C8916E925DE98A1DD6B437CC8B802CD.png)
针对状态栏和导航条颜色与界面元素颜色不匹配问题，可以通过如下两种方式实现沉浸式效果：
-  界面状态栏和导航条颜色相同场景。
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170252.89401179605368276703752264510214:50001231000000:2800:BD9A155FDB89FB8A57528111454522DF0197A183303C92D50E6B3C85D3064B61.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170252.71737889830851603967663767212947:50001231000000:2800:E2D7D59294D93D90932794BBE9C46E9959318A5B7180FAE19E5DD00AF24C1676.png)
扩展安全区域属性原理
-
-
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170252.28167283321268231704340167579089:50001231000000:2800:BBD323557B8276EDE224B69C5C35BDB7F845D652AE9C05EDC31388915E9D4E4F.png)
背景图和视频场景
设置背景图、视频控件大小为安全区域大小并配置expandSafeArea属性。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170252.41789256584986907258401938006064:50001231000000:2800:339D80FB58F9938B7166BBF6987767A2F3133570D1120D2136072359576C1026.png)
滚动类场景
要求需要List滚动类组件滚动过程中元素可以和导航条重合，滚动至底部时，元素在导航条上面需要避让。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170252.59668618959803261012383656829559:50001231000000:2800:8193DEEFFFE8E6CC061DD0B73F92BEFD56A0D31FEC9F0C6B5FF34C3CE54FC78D.png)
由于expandSafeArea不改变子节点布局，因此，List等滚动类组件可以调用expandSafeArea，延伸List组件视图窗口大小而不改变ListItem内在布局。实现ListItem在滑动过程中显示在导航条下，但滚动至最后一个时显示在导航条上，示意图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170252.27885681957084075326501039802509:50001231000000:2800:B22BA5DE9B427B8D35B9B9E0C87114E27D9F866DD4C8902A531879F5E4359D19.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170252.50465434632096718070322507059598:50001231000000:2800:8C2B88327F08396C417E13C6F7904614C361EFB5D55DC01ACF50F73D421F327D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170252.33622057486052535226244231387028:50001231000000:2800:22C9C6F767F4CBCFC784A57B6C2796B7BE1F3BFF7893B6CE238C9FEDCA8F5C95.png)
仅扩展底部导航条。
底部页签场景
要求页签背景色能够延伸到导航条区域，但页签内部可操作元素需要在导航条之上。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170252.82105708872233015629957136942536:50001231000000:2800:4CC149C607566A61D54FA587100DBDE5F11A98D4C6EC67924DECABCA41E00DF0.png)
针对底部的页签部分，Navigation组件和Tabs组件默认实现了页签的延伸处理，开发者只需要保证Navigation和Tabs组件的底部边界和底部导航条重合即可。若开发者显式调用expandSafeArea接口，则安全区效果由expandSafeArea参数指定。
如果未使用上述组件而是采用自定义方式实现页签的场景，可以针对底部元素设置expandSafeArea属性实现底部元素的背景扩展。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170252.03907807893781005679924175482885:50001231000000:2800:7CFE7681C2FA1F7DE3E2C6A5A381290B26D4BF6A48D60F6033AB6E4248511C8A.png)
图文场景
当状态栏元素和底部导航条元素不同时，无法单纯通过窗口背景色或者背景图组件延伸实现，此时需要对顶部元素和底部元素分别配置expandSafeArea属性，顶部元素配置expandSafeArea([SafeAreaType.SYSTEM],[SafeAreaEdge.TOP])，底部元素配置expandSafeArea([SafeAreaType.SYSTEM],[SafeAreaEdge.BOTTOM])。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170252.62239939214959662027511160233675:50001231000000:2800:2A89D3F5E8E85EDA833ADD7FE7CC199F03BC466E9F4928AB612BEBFABF3DBFC3.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-add-component-V14
爬取时间: 2025-04-27 23:18:26
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-components-button-V14
爬取时间: 2025-04-27 23:18:40
来源: Huawei Developer
Button是按钮组件，通常用于响应用户的点击操作，其类型包括胶囊按钮、圆形按钮、普通按钮。Button做为容器使用时可以通过添加子组件实现包含文字、图片等元素的按钮。具体用法请参考Button。
创建按钮
Button通过调用接口来创建，接口调用有以下两种形式：
-  通过label和ButtonOptions创建不包含子组件的按钮。以ButtonOptions中的type和stateEffect为例。 其中，label用来设置按钮文字，type用于设置Button类型，stateEffect属性设置Button是否开启点击效果。
```typescript
Button(label?: ResourceStr, options?: { type?: ButtonType, stateEffect?: boolean })
```
-  通过ButtonOptions创建包含子组件的按钮。以ButtonOptions中的type和stateEffect为例。 只支持包含一个子组件，子组件可以是基础组件或者容器组件。
```typescript
Button(options?: {type?: ButtonType, stateEffect?: boolean})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170253.38263460383818822904106340342107:50001231000000:2800:D6B340761C543C97A6E863C900AEA1BBA816A9846AF7278258B3D160EEC62A0F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170253.91003791471046740837377032423184:50001231000000:2800:96A47C38626AE117E7819DC8761E28347A1B2B582ABE11810071481DBE2E5828.png)
设置按钮类型
Button有三种可选类型，分别为胶囊类型（Capsule）、圆形按钮（Circle）和普通按钮（Normal），通过type进行设置。
-  胶囊按钮（默认类型）。 此类型按钮的圆角自动设置为高度的一半，不支持通过borderRadius属性重新设置圆角。
```typescript
Button('Disable', { type: ButtonType.Capsule, stateEffect: false })
.backgroundColor(0x317aff)
.width(90)
.height(40)
```
-  圆形按钮。 此类型按钮为圆形，不支持通过borderRadius属性重新设置圆角。
```typescript
Button('Circle', { type: ButtonType.Circle, stateEffect: false })
.backgroundColor(0x317aff)
.width(90)
.height(90)
```
-  普通按钮。 此类型的按钮默认圆角为0，支持通过borderRadius属性重新设置圆角。
```typescript
Button('Ok', { type: ButtonType.Normal, stateEffect: true })
.borderRadius(8)
.backgroundColor(0x317aff)
.width(90)
.height(40)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170253.65156252920567429009537675705288:50001231000000:2800:B1BF78F9FDE26EBC9AD21C810D900E8D1D5FFE491085E44E9ED5314B98E05A76.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170253.46697781826911201330065921356224:50001231000000:2800:4039B909EBD5EC0805AD3D22FBC7A3EF211CB27DA4B6659E87919E3B99AE74BA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170253.43267073809506485697301889612746:50001231000000:2800:EB82A027CA0C548A438EF25B39D82AE4D75050E24CF0417A058FB9F07A6E2C84.png)
自定义样式
-  设置边框弧度。 使用通用属性来自定义按钮样式。例如通过borderRadius属性设置按钮的边框弧度。
```typescript
Button('circle border', { type: ButtonType.Normal })
.borderRadius(20)
.height(40)
```
-  设置文本样式。 通过添加文本样式设置按钮文本的展示样式。
```typescript
Button('font style', { type: ButtonType.Normal })
.fontSize(20)
.fontColor(Color.Pink)
.fontWeight(800)
```
-  设置背景颜色。 添加backgroundColor属性设置按钮的背景颜色。
```typescript
Button('background color').backgroundColor(0xF55A42)
```
-  创建功能型按钮。 为删除操作创建一个按钮。
```typescript
let MarLeft: Record<string, number> = { 'left': 20 }
Button({ type: ButtonType.Circle, stateEffect: true }) {
Image($r('app.media.ic_public_delete_filled')).width(30).height(30)
}.width(55).height(55).margin(MarLeft).backgroundColor(0xF55A42)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170253.26209990475698741432389694666516:50001231000000:2800:A438EFE7E61DD261B7EEAE27DF3FEF4063B2A9783C05FD75F391E87CF1AFEB92.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170253.07067906358734427847437464102909:50001231000000:2800:EEB9DC6C7C5C89DA7B8900E6FE5A238E88DD1E548879B49657EBA5CB66B9DD05.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170253.76356131819125274020530037098937:50001231000000:2800:0300396F8F4C4C57BFA2C3A8DEC2B5C02F485FE957DE3AB9A65235883C2FE62A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170253.78415101571598738787575414127045:50001231000000:2800:222E1F09D5F4A1FC41B1F1AE654593409D1B8D2CC1D9C68162537895618DB028.png)
添加事件
Button组件通常用于触发某些操作，可以绑定onClick事件来响应点击操作后的自定义行为。
```typescript
Button('Ok', { type: ButtonType.Normal, stateEffect: true })
.onClick(()=>{
console.info('Button onClick')
})
```
场景示例
-  用于启动操作。 可以用按钮启动任何用户界面元素，按钮会根据用户的操作触发相应的事件。例如，在List容器里通过点击按钮进行页面跳转。
```typescript
// xxx.ets
@Entry
@Component
struct ButtonCase1 {
pathStack: NavPathStack = new NavPathStack();
@Builder
PageMap(name: string) {
if (name === "first_page") {
pageOneTmp()
} else if (name === "second_page") {
pageTwoTmp()
} else if (name === "third_page") {
pageThreeTmp()
}
}
build() {
Navigation(this.pathStack) {
List({ space: 4 }) {
ListItem() {
Button("First").onClick(() => {
this.pathStack.pushPath({ name: "first_page"})
})
.width('100%')
}
ListItem() {
Button("Second").onClick(() => {
this.pathStack.pushPath({ name: "second_page"})
})
.width('100%')
}
ListItem() {
Button("Third").onClick(() => {
this.pathStack.pushPath({ name: "third_page"})
})
.width('100%')
}
}
.listDirection(Axis.Vertical)
.backgroundColor(0xDCDCDC).padding(20)
}
.mode(NavigationMode.Stack)
.navDestination(this.PageMap)
}
}
// pageOne
@Component
export struct pageOneTmp {
pathStack: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Text("first_page")
}.width('100%').height('100%')
}.title("pageOne")
.onBackPressed(() => {
const popDestinationInfo = this.pathStack.pop() // 弹出路由栈栈顶元素
console.log('pop' + '返回值' + JSON.stringify(popDestinationInfo))
return true
})
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack
})
}
}
// pageTwo
@Component
export struct pageTwoTmp {
pathStack: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Text("second_page")
}.width('100%').height('100%')
}.title("pageTwo")
.onBackPressed(() => {
const popDestinationInfo = this.pathStack.pop() // 弹出路由栈栈顶元素
console.log('pop' + '返回值' + JSON.stringify(popDestinationInfo))
return true
})
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack
})
}
}
// pageThree
@Component
export struct pageThreeTmp {
pathStack: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Text("third_page")
}.width('100%').height('100%')
}.title("pageThree")
.onBackPressed(() => {
const popDestinationInfo = this.pathStack.pop() // 弹出路由栈栈顶元素
console.log('pop' + '返回值' + JSON.stringify(popDestinationInfo))
return true
})
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack
})
}
}
```
-  用于提交表单。 在用户登录/注册页面，使用按钮进行登录或注册操作。
```typescript
// xxx.ets
@Entry
@Component
struct ButtonCase2 {
build() {
Column() {
TextInput({ placeholder: 'input your username' }).margin({ top: 20 })
TextInput({ placeholder: 'input your password' }).type(InputType.Password).margin({ top: 20 })
Button('Register').width(300).margin({ top: 20 })
.onClick(() => {
// 需要执行的操作
})
}.padding(20)
}
}
```
-  悬浮按钮。 在可以滑动的界面，滑动时按钮始终保持悬浮状态。
```typescript
// xxx.ets
@Entry
@Component
struct HoverButtonExample {
private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
build() {
Stack() {
List({ space: 20, initialIndex: 0 }) {
ForEach(this.arr, (item:number) => {
ListItem() {
Text('' + item)
.width('100%').height(100).fontSize(16)
.textAlign(TextAlign.Center).borderRadius(10).backgroundColor(0xFFFFFF)
}
}, (item:number) => item.toString())
}.width('90%')
Button() {
Image($r('app.media.ic_public_add'))
.width(50)
.height(50)
}
.width(60)
.height(60)
.position({x: '80%', y: 600})
.shadow({radius: 10})
.onClick(() => {
// 需要执行的操作
})
}
.width('100%')
.height('100%')
.backgroundColor(0xDCDCDC)
.padding({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170253.58670536915492223473627678518143:50001231000000:2800:9F53BE58DA60405F8BF0E334DD9A9E316AA7F2D649A8906DEB99ABC5BC4E8451.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170253.59515111168086473061097394653981:50001231000000:2800:6837665E99791D1156CCB85FCC2638A0A75CC4D4342D95FD1BE77FB513296C3F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170253.28302252597059135200540064566171:50001231000000:2800:FE430905C8E965C34955C36DD43ED1F8FAF7577276F9AA7C67D29E40FE47C38E.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-components-radio-button-V14
爬取时间: 2025-04-27 23:18:54
来源: Huawei Developer
Radio是单选框组件，通常用于提供相应的用户交互选择项，同一组的Radio中只有一个可以被选中。具体用法请参考Radio。
创建单选框
Radio通过调用RadioOptions来创建，以RadioOptions中的value和group为例：
```typescript
Radio(options: {value: string, group: string})
```
其中，value是单选框的名称，group是单选框的所属群组名称。checked属性可以设置单选框的状态，状态分别为false和true，设置为true时表示单选框被选中。
Radio支持设置选中状态和非选中状态的样式。
```typescript
Radio({ value: 'Radio1', group: 'radioGroup' })
.checked(false)
Radio({ value: 'Radio2', group: 'radioGroup' })
.checked(true)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170254.40717320449179856104197281623452:50001231000000:2800:4C0CB7DA6F8047B04DFE0DA2D5F3636364EA60AECB68EC2FC7CF7664B5D48BAF.png)
添加事件
除支持通用事件外，Radio还用于选中后触发某些操作，可以绑定onChange事件来响应选中操作后的自定义行为。
```typescript
Radio({ value: 'Radio1', group: 'radioGroup' })
.onChange((isChecked: boolean) => {
if(isChecked) {
//需要执行的操作
}
})
Radio({ value: 'Radio2', group: 'radioGroup' })
.onChange((isChecked: boolean) => {
if(isChecked) {
//需要执行的操作
}
})
```
场景示例
通过点击Radio切换声音模式。
```typescript
// xxx.ets
import { promptAction } from '@kit.ArkUI';
@Entry
@Component
struct RadioExample {
@State Rst:promptAction.ShowToastOptions = {'message': 'Ringing mode.'}
@State Vst:promptAction.ShowToastOptions = {'message': 'Vibration mode.'}
@State Sst:promptAction.ShowToastOptions = {'message': 'Silent mode.'}
build() {
Row() {
Column() {
Radio({ value: 'Radio1', group: 'radioGroup' }).checked(true)
.height(50)
.width(50)
.onChange((isChecked: boolean) => {
if(isChecked) {
// 切换为响铃模式
promptAction.showToast(this.Rst)
}
})
Text('Ringing')
}
Column() {
Radio({ value: 'Radio2', group: 'radioGroup' })
.height(50)
.width(50)
.onChange((isChecked: boolean) => {
if(isChecked) {
// 切换为振动模式
promptAction.showToast(this.Vst)
}
})
Text('Vibration')
}
Column() {
Radio({ value: 'Radio3', group: 'radioGroup' })
.height(50)
.width(50)
.onChange((isChecked: boolean) => {
if(isChecked) {
// 切换为静音模式
promptAction.showToast(this.Sst)
}
})
Text('Silent')
}
}.height('100%').width('100%').justifyContent(FlexAlign.Center)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170254.42804033739909327418182783739267:50001231000000:2800:74FEF090D0FF231E53CC565E37AE789C38F0D428A15B3FC3C4E166B6B76882F8.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-components-switch-V14
爬取时间: 2025-04-27 23:19:07
来源: Huawei Developer
Toggle组件提供状态按钮样式、勾选框样式和开关样式，一般用于两种状态之间的切换。具体用法请参考Toggle。
创建切换按钮
Toggle通过调用接口来创建，接口调用形式如下：
```typescript
Toggle(options: { type: ToggleType, isOn?: boolean })
```
其中，ToggleType为开关类型，包括Button、Checkbox和Switch，isOn为切换按钮的状态。
API version 11开始，Checkbox默认样式由圆角方形变为圆形。
接口调用有以下两种形式：
-  创建不包含子组件的Toggle。 当ToggleType为Checkbox或者Switch时，用于创建不包含子组件的Toggle：
```typescript
Toggle({ type: ToggleType.Checkbox, isOn: false })
Toggle({ type: ToggleType.Checkbox, isOn: true })
```
-  创建包含子组件的Toggle。 当ToggleType为Button时，只能包含一个子组件，如果子组件有文本设置，则相应的文本内容会显示在按钮上。
```typescript
Toggle({ type: ToggleType.Button, isOn: false }) {
Text('status button')
.fontColor('#182431')
.fontSize(12)
}.width(100)
Toggle({ type: ToggleType.Button, isOn: true }) {
Text('status button')
.fontColor('#182431')
.fontSize(12)
}.width(100)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170254.96363315607912871650879149092383:50001231000000:2800:870D78B9B8F3E45DD5EF669E9A6D4EB20677EB4417F5CBAE1E998F78E5CC1A23.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170254.73935498548834125291042691874728:50001231000000:2800:CD5CE7065BCFBC9FC3C15224C17817E791D5B9DAC00AC8545C3786B649684891.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170254.31783738742323527431195481241265:50001231000000:2800:B0FE014E0EA099FD76722A58B6A5A04AEF644CCEAC9CE964BDE8D12E51CC65B8.png)
自定义样式
-  通过selectedColor属性设置Toggle打开选中后的背景颜色。
```typescript
Toggle({ type: ToggleType.Button, isOn: true }) {
Text('status button')
.fontColor('#182431')
.fontSize(12)
}.width(100).selectedColor(Color.Pink)
Toggle({ type: ToggleType.Checkbox, isOn: true })
.selectedColor(Color.Pink)
Toggle({ type: ToggleType.Switch, isOn: true })
.selectedColor(Color.Pink)
```
-  通过switchPointColor属性设置Switch类型的圆形滑块颜色，仅对type为ToggleType.Switch生效。
```typescript
Toggle({ type: ToggleType.Switch, isOn: false })
.switchPointColor(Color.Pink)
Toggle({ type: ToggleType.Switch, isOn: true })
.switchPointColor(Color.Pink)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170254.15602100421040523310712327121570:50001231000000:2800:AA2303974F15B531568FA327DA3F9E3F3398FB9BE3901F1F5A6D5CB9E2191E88.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170254.63890276336658347427513580102053:50001231000000:2800:3DBCB3392FCF35EB46022616DE4C6F2085BED16CB87046DDD2377916BA69A3C1.png)
添加事件
除支持通用事件外，Toggle还用于选中和取消选中后触发某些操作，可以绑定onChange事件来响应操作后的自定义行为。
```typescript
Toggle({ type: ToggleType.Switch, isOn: false })
.onChange((isOn: boolean) => {
if(isOn) {
// 需要执行的操作
}
})
```
场景示例
Toggle用于切换蓝牙开关状态。
```typescript
// xxx.ets
import { promptAction } from '@kit.ArkUI';
@Entry
@Component
struct ToggleExample {
@State BOnSt:promptAction.ShowToastOptions = {'message': 'Bluetooth is on.'}
@State BOffSt:promptAction.ShowToastOptions = {'message': 'Bluetooth is off.'}
build() {
Column() {
Row() {
Text("Bluetooth Mode")
.height(50)
.fontSize(16)
}
Row() {
Text("Bluetooth")
.height(50)
.padding({left: 10})
.fontSize(16)
.textAlign(TextAlign.Start)
.backgroundColor(0xFFFFFF)
Toggle({ type: ToggleType.Switch })
.margin({left: 200, right: 10})
.onChange((isOn: boolean) => {
if(isOn) {
promptAction.showToast(this.BOnSt)
} else {
promptAction.showToast(this.BOffSt)
}
})
}
.backgroundColor(0xFFFFFF)
}
.padding(10)
.backgroundColor(0xDCDCDC)
.width('100%')
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170254.70646114088567909473549302998501:50001231000000:2800:798CCF495A779A5FAC58B33CCB1EC2D0976B3A199B0524FE8B49F4426004F569.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-components-progress-indicator-V14
爬取时间: 2025-04-27 23:19:23
来源: Huawei Developer
Progress是进度条显示组件，显示内容通常为目标操作的当前进度。具体用法请参考Progress。
创建进度条
Progress通过调用接口来创建，接口调用形式如下：
```typescript
Progress(options: {value: number, total?: number, type?: ProgressType})
```
其中，value用于设置初始进度值，total用于设置进度总长度，type用于设置Progress样式。
```typescript
Progress({ value: 24, total: 100, type: ProgressType.Linear }) // 创建一个进度总长为100，初始进度值为24的线性进度条
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170254.39509525870449868081383494300191:50001231000000:2800:74F173B59EF36962AAA12B1B6F86FC80352E3B10811E7E4BF370D51A028FE663.png)
设置进度条样式
Progress有5种可选类型，通过ProgressType可以设置进度条样式，ProgressType类型包括：ProgressType.Linear（线性样式）、 ProgressType.Ring（环形无刻度样式）、ProgressType.ScaleRing（环形有刻度样式）、ProgressType.Eclipse（圆形样式）和ProgressType.Capsule（胶囊样式）。
-  线性样式进度条（默认类型） 从API version9开始，组件高度大于宽度时，自适应垂直显示；组件高度等于宽度时，保持水平显示。
```typescript
Progress({ value: 20, total: 100, type: ProgressType.Linear }).width(200).height(50)
Progress({ value: 20, total: 100, type: ProgressType.Linear }).width(50).height(200)
```
-  环形无刻度样式进度条
```typescript
// 从左往右，1号环形进度条，默认前景色为蓝色渐变，默认strokeWidth进度条宽度为2.0vp
Progress({ value: 40, total: 150, type: ProgressType.Ring }).width(100).height(100)
// 从左往右，2号环形进度条
Progress({ value: 40, total: 150, type: ProgressType.Ring }).width(100).height(100)
.color(Color.Grey)    // 进度条前景色为灰色
.style({ strokeWidth: 15})    // 设置strokeWidth进度条宽度为15.0vp
```
-  环形有刻度样式进度条
```typescript
Progress({ value: 20, total: 150, type: ProgressType.ScaleRing }).width(100).height(100)
.backgroundColor(Color.Black)
.style({ scaleCount: 20, scaleWidth: 5 })    // 设置环形有刻度进度条总刻度数为20，刻度宽度为5vp
Progress({ value: 20, total: 150, type: ProgressType.ScaleRing }).width(100).height(100)
.backgroundColor(Color.Black)
.style({ strokeWidth: 15, scaleCount: 20, scaleWidth: 5 })    // 设置环形有刻度进度条宽度15，总刻度数为20，刻度宽度为5vp
Progress({ value: 20, total: 150, type: ProgressType.ScaleRing }).width(100).height(100)
.backgroundColor(Color.Black)
.style({ strokeWidth: 15, scaleCount: 20, scaleWidth: 3 })    // 设置环形有刻度进度条宽度15，总刻度数为20，刻度宽度为3vp
```
-  圆形样式进度条
```typescript
// 从左往右，1号圆形进度条，默认前景色为蓝色
Progress({ value: 10, total: 150, type: ProgressType.Eclipse }).width(100).height(100)
// 从左往右，2号圆形进度条，指定前景色为灰色
Progress({ value: 20, total: 150, type: ProgressType.Eclipse }).color(Color.Grey).width(100).height(100)
```
-  胶囊样式进度条 头尾两端圆弧处的进度展示效果与ProgressType.Eclipse样式相同。 中段处的进度展示效果为矩形状长条，与ProgressType.Linear线性样式相似。 组件高度大于宽度的时候自适应垂直显示。
```typescript
Progress({ value: 10, total: 150, type: ProgressType.Capsule }).width(100).height(50)
Progress({ value: 20, total: 150, type: ProgressType.Capsule }).width(50).height(100).color(Color.Grey)
Progress({ value: 50, total: 150, type: ProgressType.Capsule }).width(50).height(100).color(Color.Blue).backgroundColor(Color.Black)
```
-  头尾两端圆弧处的进度展示效果与ProgressType.Eclipse样式相同。
-  中段处的进度展示效果为矩形状长条，与ProgressType.Linear线性样式相似。
-  组件高度大于宽度的时候自适应垂直显示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170254.58496848402006800487376539139469:50001231000000:2800:EF87ED2A5AB64EBBECE74DE627E4BE278FC17C6F95D3226A3B48866DEA70D36C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170254.46767059670100315861629429888067:50001231000000:2800:73F90268ACB4F88E0056934190A7863F8695910B03999F59ECC09C1BD92415D6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170254.55002560030592368991434255379432:50001231000000:2800:043973C88690371952D5AA3B4CC8A9607366574171B7E487039D895D519C18CB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170254.15102255501939802268157014504638:50001231000000:2800:B5DF66AFB304984D5133946A5D635A4E920A33AB1E278D56D5D959656FAD4634.png)
-  头尾两端圆弧处的进度展示效果与ProgressType.Eclipse样式相同。
-  中段处的进度展示效果为矩形状长条，与ProgressType.Linear线性样式相似。
-  组件高度大于宽度的时候自适应垂直显示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.53553712327163582915389261355588:50001231000000:2800:86B116F9AE2B187EEE53752F93D87320EE4F73080E1ED0E38B6666D4F2BBCBB7.png)
场景示例
更新当前进度值，如应用安装进度条，可通过点击Button增加progressValue，value属性将progressValue设置给Progress组件，进度条组件即会触发刷新，更新当前进度。
```typescript
@Entry
@Component
struct ProgressCase1 {
@State progressValue: number = 0    // 设置进度条初始值为0
build() {
Column() {
Column() {
Progress({value:0, total:100, type:ProgressType.Capsule}).width(200).height(50).value(this.progressValue)
Row().width('100%').height(5)
Button("进度条+5")
.onClick(()=>{
this.progressValue += 5
if (this.progressValue > 100){
this.progressValue = 0
}
})
}
}.width('100%').height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.79011602892385637639017259768901:50001231000000:2800:C86385A9E4975DF907F0117968FC8FB73FCABA87665B624E82735AA224451442.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-graphics-display-V14
爬取时间: 2025-04-27 23:19:37
来源: Huawei Developer
开发者经常需要在应用中显示一些图片，例如：按钮中的icon、网络图片、本地图片等。在应用中显示图片需要使用Image组件实现，Image支持多种图片格式，包括png、jpg、bmp、svg、gif和heif，具体用法请参考Image组件。
Image通过调用接口来创建，接口调用形式如下：
```typescript
Image(src: PixelMap | ResourceStr | DrawableDescriptor)
```
该接口通过图片数据源获取图片，支持本地图片和网络图片的渲染展示。其中，src是图片的数据源，加载方式请参考加载图片资源。
加载图片资源
Image支持加载存档图、多媒体像素图两种类型。
存档图类型数据源
存档图类型的数据源可以分为本地资源、网络资源、Resource资源、媒体库资源和base64。
-  本地资源 创建文件夹，将本地图片放入ets文件夹下的任意位置。 Image组件引入本地图片路径，即可显示图片（根目录为ets文件夹）。
```typescript
Image('images/view.jpg')
.width(200)
```
-  网络资源 引入网络图片需申请权限ohos.permission.INTERNET，具体申请方式请参考声明权限。此时，Image组件的src参数为网络图片的链接。 当前Image组件仅支持加载简单网络图片。 Image组件首次加载网络图片时，需要请求网络资源，非首次加载时，默认从缓存中直接读取图片，更多图片缓存设置请参考setImageCacheCount、setImageRawDataCacheSize、setImageFileCacheSize。但是，这三个图片缓存接口并不灵活，且后续不继续演进，对于复杂情况，更推荐使用ImageKnife。 API version 14及之后，Image组件在显示网络图片时，网络图片下载与缓存能力将不再内嵌于Image组件中，而是剥离至上传下载模块进行统一管理。上传下载模块提供独立的预下载接口，允许应用开发者在创建Image组件前预下载所需图片。组件创建后，通过向上传下载模块请求数据，从而优化了Image组件的显示流程。关于网络缓存的位置，对于API version 14之前的版本，Image组件的缓存位于应用的本地沙箱路径下，而对于API version 14及之后的版本，缓存则移至应用根目录下的cache目录中。
```typescript
Image('https://www.example.com/example.JPG') // 实际使用时请替换为真实地址
```
-  Resource资源 使用资源格式可以跨包/跨模块引入图片，resources文件夹下的图片都可以通过$r资源接口读取到并转换到Resource格式。 图1resources 调用方式： 还可以将图片放在rawfile文件夹下。 图2rawfile 调用方式：
-  媒体库file://data/storage 支持file://路径前缀的字符串，用于访问通过选择器提供的图片路径。 调用接口获取图库的照片url。 从媒体库获取的url格式通常如下。
```typescript
import { photoAccessHelper } from '@kit.MediaLibraryKit';
import { BusinessError } from '@kit.BasicServicesKit';
@Entry
@Component
struct Index {
@State imgDatas: string[] = [];
// 获取照片url集
getAllImg() {
try {
let PhotoSelectOptions:photoAccessHelper.PhotoSelectOptions = new photoAccessHelper.PhotoSelectOptions();
PhotoSelectOptions.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE;
PhotoSelectOptions.maxSelectNumber = 5;
let photoPicker:photoAccessHelper.PhotoViewPicker = new photoAccessHelper.PhotoViewPicker();
photoPicker.select(PhotoSelectOptions).then((PhotoSelectResult:photoAccessHelper.PhotoSelectResult) => {
this.imgDatas = PhotoSelectResult.photoUris;
console.info('PhotoViewPicker.select successfully, PhotoSelectResult uri: ' + JSON.stringify(PhotoSelectResult));
}).catch((err:Error) => {
let message = (err as BusinessError).message;
let code = (err as BusinessError).code;
console.error(`PhotoViewPicker.select failed with. Code: ${code}, message: ${message}`);
});
} catch (err) {
let message = (err as BusinessError).message;
let code = (err as BusinessError).code;
console.error(`PhotoViewPicker failed with. Code: ${code}, message: ${message}`);    }
}
// aboutToAppear中调用上述函数，获取图库的所有图片url，存在imgDatas中
async aboutToAppear() {
this.getAllImg();
}
// 使用imgDatas的url加载图片。
build() {
Column() {
Grid() {
ForEach(this.imgDatas, (item:string) => {
GridItem() {
Image(item)
.width(200)
}
}, (item:string):string => JSON.stringify(item))
}
}.width('100%').height('100%')
}
}
```
-  调用接口获取图库的照片url。
```typescript
import { photoAccessHelper } from '@kit.MediaLibraryKit';
import { BusinessError } from '@kit.BasicServicesKit';
@Entry
@Component
struct Index {
@State imgDatas: string[] = [];
// 获取照片url集
getAllImg() {
try {
let PhotoSelectOptions:photoAccessHelper.PhotoSelectOptions = new photoAccessHelper.PhotoSelectOptions();
PhotoSelectOptions.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE;
PhotoSelectOptions.maxSelectNumber = 5;
let photoPicker:photoAccessHelper.PhotoViewPicker = new photoAccessHelper.PhotoViewPicker();
photoPicker.select(PhotoSelectOptions).then((PhotoSelectResult:photoAccessHelper.PhotoSelectResult) => {
this.imgDatas = PhotoSelectResult.photoUris;
console.info('PhotoViewPicker.select successfully, PhotoSelectResult uri: ' + JSON.stringify(PhotoSelectResult));
}).catch((err:Error) => {
let message = (err as BusinessError).message;
let code = (err as BusinessError).code;
console.error(`PhotoViewPicker.select failed with. Code: ${code}, message: ${message}`);
});
} catch (err) {
let message = (err as BusinessError).message;
let code = (err as BusinessError).code;
console.error(`PhotoViewPicker failed with. Code: ${code}, message: ${message}`);    }
}
// aboutToAppear中调用上述函数，获取图库的所有图片url，存在imgDatas中
async aboutToAppear() {
this.getAllImg();
}
// 使用imgDatas的url加载图片。
build() {
Column() {
Grid() {
ForEach(this.imgDatas, (item:string) => {
GridItem() {
Image(item)
.width(200)
}
}, (item:string):string => JSON.stringify(item))
}
}.width('100%').height('100%')
}
}
```
-  从媒体库获取的url格式通常如下。
```typescript
Image('file://media/Photos/5')
.width(200)
```
-  base64 路径格式为data:image/[png|jpeg|bmp|webp|heif];base64,[base64 data]，其中[base64 data]为Base64字符串数据。 Base64格式字符串可用于存储图片的像素数据，在网页上使用较为广泛。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.85786858266106756515621037827098:50001231000000:2800:F0460E00FA0BB0AAD8325D4BC193373AC1790193CA243769A9EC9670D3C7955F.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.38678210797062737606141703159276:50001231000000:2800:BB551FC06964373EFF965980E970701BEC614085D4482097F9C426F85BF79C2F.jpg)
1.  调用接口获取图库的照片url。
```typescript
import { photoAccessHelper } from '@kit.MediaLibraryKit';
import { BusinessError } from '@kit.BasicServicesKit';
@Entry
@Component
struct Index {
@State imgDatas: string[] = [];
// 获取照片url集
getAllImg() {
try {
let PhotoSelectOptions:photoAccessHelper.PhotoSelectOptions = new photoAccessHelper.PhotoSelectOptions();
PhotoSelectOptions.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE;
PhotoSelectOptions.maxSelectNumber = 5;
let photoPicker:photoAccessHelper.PhotoViewPicker = new photoAccessHelper.PhotoViewPicker();
photoPicker.select(PhotoSelectOptions).then((PhotoSelectResult:photoAccessHelper.PhotoSelectResult) => {
this.imgDatas = PhotoSelectResult.photoUris;
console.info('PhotoViewPicker.select successfully, PhotoSelectResult uri: ' + JSON.stringify(PhotoSelectResult));
}).catch((err:Error) => {
let message = (err as BusinessError).message;
let code = (err as BusinessError).code;
console.error(`PhotoViewPicker.select failed with. Code: ${code}, message: ${message}`);
});
} catch (err) {
let message = (err as BusinessError).message;
let code = (err as BusinessError).code;
console.error(`PhotoViewPicker failed with. Code: ${code}, message: ${message}`);    }
}
// aboutToAppear中调用上述函数，获取图库的所有图片url，存在imgDatas中
async aboutToAppear() {
this.getAllImg();
}
// 使用imgDatas的url加载图片。
build() {
Column() {
Grid() {
ForEach(this.imgDatas, (item:string) => {
GridItem() {
Image(item)
.width(200)
}
}, (item:string):string => JSON.stringify(item))
}
}.width('100%').height('100%')
}
}
```
2.  从媒体库获取的url格式通常如下。
```typescript
Image('file://media/Photos/5')
.width(200)
```
多媒体像素图
PixelMap是图片解码后的像素图，具体用法请参考图片开发指导。以下示例将加载的网络图片返回的数据解码成PixelMap格式，再显示在Image组件上。
1.  创建PixelMap状态变量。
```typescript
@State image: PixelMap | undefined = undefined;
```
2.  引用多媒体。 (1) 引用网络权限与媒体库权限。 (2) 填写网络图片地址。
```typescript
import { http } from '@kit.NetworkKit';
import { image } from '@kit.ImageKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
3.  将网络地址成功返回的数据，编码转码成pixelMap的图片格式。
```typescript
let code: http.ResponseCode | number = OutData.responseCode
if (http.ResponseCode.OK === code) {
let imageData: ArrayBuffer = OutData.result as ArrayBuffer;
let imageSource: image.ImageSource = image.createImageSource(imageData);
class tmp {
height: number = 100
width: number = 100
}
let si: tmp = new tmp()
let options: Record<string, number | boolean | tmp> = {
'alphaType': 0, // 透明度
'editable': false, // 是否可编辑
'pixelFormat': 3, // 像素格式
'scaleMode': 1, // 缩略值
'size': { height: 100, width: 100 }
} // 创建图片大小
class imagetmp {
image: PixelMap | undefined = undefined
set(val: PixelMap) {
this.image = val
}
}
imageSource.createPixelMap(options).then((pixelMap: PixelMap) => {
let im = new imagetmp()
im.set(pixelMap)
})
}
```
4.  显示图片。 同时，也可以传入pixelMap创建PixelMapDrawableDescriptor对象，用来显示图片。
```typescript
class htp{
httpRequest: Function | undefined = undefined
set(){
if(this.httpRequest){
this.httpRequest()
}
}
}
Button("获取网络图片")
.onClick(() => {
let sethtp = new htp()
sethtp.set()
})
Image(this.image).height(100).width(100)
```
显示矢量图
Image组件可显示矢量图（svg格式的图片），svg标签文档请参考svg说明。
svg格式的图片可以使用fillColor属性改变图片的绘制颜色。
```typescript
Image($r('app.media.cloud'))
.width(50)
.fillColor(Color.Blue)
```
图3原始图片
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.42771941834442877775212721567440:50001231000000:2800:AFF710109C1405C076CEDB2CEC6E8F19068F19446BEDD6B52058A7B0475131CD.png)
图4设置绘制颜色后的svg图片
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.72990546133513148503928211029442:50001231000000:2800:1E6D49967E2BB8B7C54E38D55987C3906F986CCD5D3BDC294861C959FD7ED421.png)
矢量图引用位图
如果Image加载的Svg图源中包含对本地位图的引用，则Svg图源的路径应当设置为以ets为根目录的工程路径，同时，本地位图的路径应设置为与Svg图源同级的相对路径。
Image加载的Svg图源路径设置方法如下所示：
```typescript
Image("images/icon.svg")
.width(50)
.height(50)
```
Svg图源通过<image>标签的xlink:href属性指定本地位图路径，本地位图路径设置为跟Svg图源同级的相对路径：
文件工程路径示例如图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.84594923956827321922643008340959:50001231000000:2800:62E0F482F8AC08C9AF53B5A1D68F17AD3C6B68B408B7B6B516A7AEE319BB9F34.png)
添加属性
给Image组件设置属性可以使图片显示更灵活，达到一些自定义的效果。以下是几个常用属性的使用示例，完整属性信息详见Image。
设置图片缩放类型
通过objectFit属性使图片缩放到高度和宽度确定的框内。
```typescript
@Entry
@Component
struct MyComponent {
scroller: Scroller = new Scroller()
build() {
Scroll(this.scroller) {
Column() {
Row() {
Image($r('app.media.img_2'))
.width(200)
.height(150)
.border({ width: 1 })
// 保持宽高比进行缩小或者放大，使得图片完全显示在显示边界内。
.objectFit(ImageFit.Contain)
.margin(15)
.overlay('Contain', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
Image($r('app.media.ic_img_2'))
.width(200)
.height(150)
.border({ width: 1 })
// 保持宽高比进行缩小或者放大，使得图片两边都大于或等于显示边界。
.objectFit(ImageFit.Cover)
.margin(15)
.overlay('Cover', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
Image($r('app.media.img_2'))
.width(200)
.height(150)
.border({ width: 1 })
// 自适应显示。
.objectFit(ImageFit.Auto)
.margin(15)
.overlay('Auto', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
}
Row() {
Image($r('app.media.img_2'))
.width(200)
.height(150)
.border({ width: 1 })
// 不保持宽高比进行放大缩小，使得图片充满显示边界。
.objectFit(ImageFit.Fill)
.margin(15)
.overlay('Fill', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
Image($r('app.media.img_2'))
.width(200)
.height(150)
.border({ width: 1 })
// 保持宽高比显示，图片缩小或者保持不变。
.objectFit(ImageFit.ScaleDown)
.margin(15)
.overlay('ScaleDown', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
Image($r('app.media.img_2'))
.width(200)
.height(150)
.border({ width: 1 })
// 保持原有尺寸显示。
.objectFit(ImageFit.None)
.margin(15)
.overlay('None', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
}
}
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.84631917190548483196493149971714:50001231000000:2800:6F1DF2EA98C8C17C906F323595F74E828E8F6AF4B7B0CC1D74B14DA72F672324.png)
图片插值
当原图分辨率较低并且放大显示时，图片会模糊出现锯齿。这时可以使用interpolation属性对图片进行插值，使图片显示得更清晰。
```typescript
@Entry
@Component
struct Index {
build() {
Column() {
Row() {
Image($r('app.media.grass'))
.width('40%')
.interpolation(ImageInterpolation.None)
.borderWidth(1)
.overlay("Interpolation.None", { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
.margin(10)
Image($r('app.media.grass'))
.width('40%')
.interpolation(ImageInterpolation.Low)
.borderWidth(1)
.overlay("Interpolation.Low", { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
.margin(10)
}.width('100%')
.justifyContent(FlexAlign.Center)
Row() {
Image($r('app.media.grass'))
.width('40%')
.interpolation(ImageInterpolation.Medium)
.borderWidth(1)
.overlay("Interpolation.Medium", { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
.margin(10)
Image($r('app.media.grass'))
.width('40%')
.interpolation(ImageInterpolation.High)
.borderWidth(1)
.overlay("Interpolation.High", { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
.margin(10)
}.width('100%')
.justifyContent(FlexAlign.Center)
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.56531621428376571207484249154728:50001231000000:2800:01ABA1C00ECBCE3E39842CF2DE0FBD01067AC95C1F08E886EF074FC0C5BBAE18.png)
设置图片重复样式
通过objectRepeat属性设置图片的重复样式方式，重复样式请参考ImageRepeat枚举说明。
```typescript
@Entry
@Component
struct MyComponent {
build() {
Column({ space: 10 }) {
Row({ space: 5 }) {
Image($r('app.media.ic_public_favor_filled_1'))
.width(110)
.height(115)
.border({ width: 1 })
.objectRepeat(ImageRepeat.XY)
.objectFit(ImageFit.ScaleDown)
// 在水平轴和竖直轴上同时重复绘制图片
.overlay('ImageRepeat.XY', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
Image($r('app.media.ic_public_favor_filled_1'))
.width(110)
.height(115)
.border({ width: 1 })
.objectRepeat(ImageRepeat.Y)
.objectFit(ImageFit.ScaleDown)
// 只在竖直轴上重复绘制图片
.overlay('ImageRepeat.Y', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
Image($r('app.media.ic_public_favor_filled_1'))
.width(110)
.height(115)
.border({ width: 1 })
.objectRepeat(ImageRepeat.X)
.objectFit(ImageFit.ScaleDown)
// 只在水平轴上重复绘制图片
.overlay('ImageRepeat.X', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
}
}.height(150).width('100%').padding(8)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.49499576796145817146055794343876:50001231000000:2800:4828D72AF14599BAF51BCBCF31CD60B75349D9E64430E90E6FB8CA7089E6715F.png)
设置图片渲染模式
通过renderMode属性设置图片的渲染模式为原色或黑白。
```typescript
@Entry
@Component
struct MyComponent {
build() {
Column({ space: 10 }) {
Row({ space: 50 }) {
Image($r('app.media.example'))
// 设置图片的渲染模式为原色
.renderMode(ImageRenderMode.Original)
.width(100)
.height(100)
.border({ width: 1 })
// overlay是通用属性，用于在组件上显示说明文字
.overlay('Original', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
Image($r('app.media.example'))
// 设置图片的渲染模式为黑白
.renderMode(ImageRenderMode.Template)
.width(100)
.height(100)
.border({ width: 1 })
.overlay('Template', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })
}
}.height(150).width('100%').padding({ top: 20,right: 10 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.26182886512203591145062833876260:50001231000000:2800:581C134D5DE368730A9AE02589EAF2C1FD290E0E88ADF69032517DB3DE237B13.png)
设置图片解码尺寸
通过sourceSize属性设置图片解码尺寸，降低图片的分辨率。
原图尺寸为1280*960，该示例将图片解码为40*40和90*90。
```typescript
@Entry
@Component
struct Index {
build() {
Column() {
Row({ space: 50 }) {
Image($r('app.media.example'))
.sourceSize({
width: 40,
height: 40
})
.objectFit(ImageFit.ScaleDown)
.aspectRatio(1)
.width('25%')
.border({ width: 1 })
.overlay('width:40 height:40', { align: Alignment.Bottom, offset: { x: 0, y: 40 } })
Image($r('app.media.example'))
.sourceSize({
width: 90,
height: 90
})
.objectFit(ImageFit.ScaleDown)
.width('25%')
.aspectRatio(1)
.border({ width: 1 })
.overlay('width:90 height:90', { align: Alignment.Bottom, offset: { x: 0, y: 40 } })
}.height(150).width('100%').padding(20)
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.89050670583308068584930202710787:50001231000000:2800:7C6C080FDB29E8BCCBC5B03BA77EDF7D2804112927D4166F1F1A89C42C083DEA.png)
为图片添加滤镜效果
通过colorFilter修改图片的像素颜色，为图片添加滤镜。
```typescript
@Entry
@Component
struct Index {
build() {
Column() {
Row() {
Image($r('app.media.example'))
.width('40%')
.margin(10)
Image($r('app.media.example'))
.width('40%')
.colorFilter(
[1, 1, 0, 0, 0,
0, 1, 0, 0, 0,
0, 0, 1, 0, 0,
0, 0, 0, 1, 0])
.margin(10)
}.width('100%')
.justifyContent(FlexAlign.Center)
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.77846354055625298240330452293274:50001231000000:2800:FB12A53336593484A8B34D8EE3C3936A2305BCAFD8118793F6751246C512A170.png)
同步加载图片
一般情况下，图片加载流程会异步进行，以避免阻塞主线程，影响UI交互。但是特定情况下，图片刷新时会出现闪烁，这时可以使用syncLoad属性，使图片同步加载，从而避免出现闪烁。不建议图片加载较长时间时使用，会导致页面无法响应。
```typescript
Image($r('app.media.icon'))
.syncLoad(true)
```
事件调用
通过在Image组件上绑定onComplete事件，图片加载成功后可以获取图片的必要信息。如果图片加载失败，也可以通过绑定onError回调来获得结果。
```typescript
@Entry
@Component
struct MyComponent {
@State widthValue: number = 0
@State heightValue: number = 0
@State componentWidth: number = 0
@State componentHeight: number = 0
build() {
Column() {
Row() {
Image($r('app.media.ic_img_2'))
.width(200)
.height(150)
.margin(15)
.onComplete(msg => {
if(msg){
this.widthValue = msg.width
this.heightValue = msg.height
this.componentWidth = msg.componentWidth
this.componentHeight = msg.componentHeight
}
})
// 图片获取失败，打印结果
.onError(() => {
console.info('load image fail')
})
.overlay('\nwidth: ' + String(this.widthValue) + ', height: ' + String(this.heightValue) + '\ncomponentWidth: ' + String(this.componentWidth) + '\ncomponentHeight: ' + String(this.componentHeight), {
align: Alignment.Bottom,
offset: { x: 0, y: 60 }
})
}
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170255.48687927076422223472280196140024:50001231000000:2800:1016CCFEBFAA5E1807C25FF22DE4831A3A0D13E44F07D8C3EBDC3A4DEBA46FC1.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-components-video-player-V14
爬取时间: 2025-04-27 23:19:50
来源: Huawei Developer
Video组件用于播放视频文件并控制其播放状态，常用于为短视频和应用内部视频的列表页面。当视频完整出现时会自动播放，用户点击视频区域则会暂停播放，同时显示播放进度条，通过拖动播放进度条指定视频播放到具体位置。具体用法请参考Video。
创建视频组件
Video通过调用接口来创建，接口调用形式如下：
Video(value: VideoOptions)
加载视频资源
Video组件支持加载本地视频和网络视频。
加载本地视频
-  普通本地视频。 加载本地视频时，首先在本地rawfile目录指定对应的文件，如下图所示。 再使用资源访问符$rawfile()引用视频资源。
```typescript
// xxx.ets
@Component
export struct VideoPlayer {
private controller: VideoController = new VideoController()
private previewUris: Resource = $r('app.media.preview')
private innerResource: Resource = $rawfile('videoTest.mp4')
build() {
Column() {
Video({
src: this.innerResource,
previewUri: this.previewUris,
controller: this.controller
})
}
}
}
```
-  Data Ability提供的视频路径带有dataability://前缀，使用时确保对应视频资源存在即可。
```typescript
// xxx.ets
@Component
export struct VideoPlayer {
private controller: VideoController = new VideoController()
private previewUris: Resource = $r('app.media.preview')
private videoSrc: string = 'dataability://device_id/com.domainname.dataability.videodata/video/10'
build() {
Column() {
Video({
src: this.videoSrc,
previewUri: this.previewUris,
controller: this.controller
})
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170256.96182780206719695187801337160565:50001231000000:2800:A91D541DE6ABFB7C3D1B1AEBF1F078C194E594C0633180070ADB280424033AAA.png)
加载沙箱路径视频
支持file://路径前缀的字符串，用于读取应用沙箱路径内的资源，需要保证应用沙箱目录路径下的文件存在并且有可读权限。
```typescript
// xxx.ets
@Component
export struct VideoPlayer {
private controller: VideoController = new VideoController()
private videoSrc: string = 'file:///data/storage/el2/base/haps/entry/files/show.mp4'
build() {
Column() {
Video({
src: this.videoSrc,
controller: this.controller
})
}
}
}
```
加载网络视频
加载网络视频时，需要申请权限ohos.permission.INTERNET，具体申请方式请参考声明权限。此时，Video的src属性为网络视频的链接。
```typescript
// xxx.ets
@Component
export struct VideoPlayer {
private controller: VideoController = new VideoController()
private previewUris: Resource = $r('app.media.preview')
private videoSrc: string = 'https://www.example.com/example.mp4' // 使用时请替换为实际视频加载网址
build() {
Column() {
Video({
src: this.videoSrc,
previewUri: this.previewUris,
controller: this.controller
})
}
}
}
```
添加属性
Video组件属性主要用于设置视频的播放形式。例如设置视频播放是否静音、播放是否显示控制条等。
```typescript
// xxx.ets
@Component
export struct VideoPlayer {
private controller: VideoController = new VideoController()
build() {
Column() {
Video({
controller: this.controller
})
.muted(false) // 设置是否静音
.controls(false) // 设置是否显示默认控制条
.autoPlay(false) // 设置是否自动播放
.loop(false) // 设置是否循环播放
.objectFit(ImageFit.Contain) // 设置视频适配模式
}
}
}
```
事件调用
Video组件回调事件主要为播放开始、暂停结束、播放失败、播放停止、视频准备和操作进度条等事件，除此之外，Video组件也支持通用事件的调用，如点击、触摸等事件的调用。详细事件请参考事件说明。
```typescript
// xxx.ets
@Entry
@Component
struct VideoPlayer {
private controller: VideoController = new VideoController()
private previewUris: Resource = $r('app.media.preview')
private innerResource: Resource = $rawfile('videoTest.mp4')
build() {
Column() {
Video({
src: this.innerResource,
previewUri: this.previewUris,
controller: this.controller
})
.onUpdate((event) => { // 更新事件回调
console.info("Video update.");
})
.onPrepared((event) => { // 准备事件回调
console.info("Video prepared.");
})
.onError(() => { // 失败事件回调
console.info("Video error.");
})
.onStop(() => { // 停止事件回调
console.info("Video stopped.");
})
}
}
}
```
Video控制器使用
Video控制器主要用于控制视频的状态，包括播放、暂停、停止以及设置进度等，详细使用请参考VideoController使用说明。
-  默认控制器 默认的控制器支持视频的开始、暂停、进度调整、全屏显示四项基本功能。
```typescript
// xxx.ets
@Entry
@Component
struct VideoGuide {
@State videoSrc: Resource = $rawfile('videoTest.mp4')
@State previewUri: string = 'common/videoIcon.png'
@State curRate: PlaybackSpeed = PlaybackSpeed.Speed_Forward_1_00_X
build() {
Row() {
Column() {
Video({
src: this.videoSrc,
previewUri: this.previewUri,
currentProgressRate: this.curRate
})
}
.width('100%')
}
.height('100%')
}
}
```
-  自定义控制器 使用自定义的控制器，先将默认控制器关闭掉，之后可以使用button以及slider等组件进行自定义的控制与显示，适合自定义较强的场景下使用。
```typescript
// xxx.ets
@Entry
@Component
struct VideoGuide {
@State videoSrc: Resource = $rawfile('videoTest.mp4')
@State previewUri: string = 'common/videoIcon.png'
@State curRate: PlaybackSpeed = PlaybackSpeed.Speed_Forward_1_00_X
@State isAutoPlay: boolean = false
@State showControls: boolean = true
@State sliderStartTime: string = ''
@State currentTime: number = 0
@State durationTime: number = 0
@State durationStringTime: string = ''
controller: VideoController = new VideoController()
build() {
Row() {
Column() {
Video({
src: this.videoSrc,
previewUri: this.previewUri,
currentProgressRate: this.curRate,
controller: this.controller
})
.controls(false)
.autoPlay(true)
.onPrepared((event) => {
if (event) {
this.durationTime = event.duration
}
})
.onUpdate((event) => {
if (event) {
this.currentTime = event.time
}
})
Row() {
Text(JSON.stringify(this.currentTime) + 's')
Slider({
value: this.currentTime,
min: 0,
max: this.durationTime
})
.onChange((value: number, mode: SliderChangeMode) => {
this.controller.setCurrentTime(value);
})
.width("90%")
Text(JSON.stringify(this.durationTime) + 's')
}
.opacity(0.8)
.width("100%")
}
.width('100%')
}
.height('40%')
}
}
```
其他说明
Video组件已经封装好了视频播放的基础能力，开发者无需进行视频实例的创建，视频信息的设置获取，只需要设置数据源以及基础信息即可播放视频，相对扩展能力较弱。如果开发者想自定义视频播放，请参考视频播放。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/napi-xcomponent-guidelines-V14
爬取时间: 2025-04-27 23:20:05
来源: Huawei Developer
概述
XComponent组件作为一种渲染组件，可用于EGL/OpenGLES和媒体数据写入，通过使用XComponent持有的“NativeWindow”来渲染画面，通常用于满足开发者较为复杂的自定义渲染需求，例如相机预览流的显示和游戏画面的渲染。其可通过指定type字段来实现不同的渲染方式，分别为XComponentType.SURFACE和XComponentType.TEXTURE。对于SURFACE类型，开发者将定制的绘制内容单独展示到屏幕上。对于TEXTURE类型，开发者将定制的绘制内容和XComponent组件的内容合成后展示到屏幕上。
目前XComponent组件主要有两个应用场景。一个是Native XComponent场景，在native层获取Native XComponent实例，在native侧注册XComponent的生命周期回调，以及触摸、鼠标、按键等事件回调。另一个是ArkTS XComponent场景，在ArkTS侧获取SurfaceId，生命周期回调、触摸、鼠标、按键等事件回调等均在ArkTS侧触发。
Native XComponent场景
在XComponent组件构造函数的libraryname中定义需要加载的动态库，而后应用就可以在Native层获取Native XComponent实例，其是XComponent组件提供在Native层的实例，可作为ArkTS层和Native层XComponent绑定的桥梁。XComponent所提供的NDK接口都依赖于该实例。接口能力包括获取NativeWindow实例、获取XComponent的布局/事件信息、注册XComponent的生命周期回调、注册XComponent的触摸、鼠标、按键等事件回调。针对Native XComponent，主要的开发场景如下：
接口说明
| 接口名 | 描述 |
| --- | --- |
| OH_NativeXComponent_GetXComponentId(OH_NativeXComponent* component, char* id, uint64_t* size) | 获取XComponent的id。 |
| OH_NativeXComponent_GetXComponentSize(OH_NativeXComponent* component, const void* window, uint64_t* width, uint64_t* height) | 获取XComponent持有的surface的大小。 |
| OH_NativeXComponent_GetXComponentOffset(OH_NativeXComponent* component, const void* window, double* x, double* y) | 获取XComponent持有的surface相对其父组件左顶点的偏移量。 |
| OH_NativeXComponent_GetTouchEvent(OH_NativeXComponent* component, const void* window, OH_NativeXComponent_TouchEvent* touchEvent) | 获取由XComponent触发的触摸事件。touchEvent内的具体属性值可参考OH_NativeXComponent_TouchEvent。 |
| OH_NativeXComponent_GetTouchPointToolType(OH_NativeXComponent* component, uint32_t pointIndex, OH_NativeXComponent_TouchPointToolType* toolType) | 获取XComponent触摸点的工具类型。 |
| OH_NativeXComponent_GetTouchPointTiltX(OH_NativeXComponent* component, uint32_t pointIndex, float* tiltX) | 获取XComponent触摸点处相对X轴的倾斜角度。 |
| OH_NativeXComponent_GetTouchPointTiltY(OH_NativeXComponent* component, uint32_t pointIndex, float* tiltY) | 获取XComponent触摸点处相对Y轴的倾斜角度。 |
| OH_NativeXComponent_GetMouseEvent(OH_NativeXComponent* component, const void* window, OH_NativeXComponent_MouseEvent* mouseEvent) | 获取由XComponent触发的鼠标事件。 |
| OH_NativeXComponent_RegisterCallback(OH_NativeXComponent* component, OH_NativeXComponent_Callback* callback) | 为此OH_NativeXComponent实例注册生命周期和触摸事件回调。 |
| OH_NativeXComponent_RegisterMouseEventCallback(OH_NativeXComponent* component, OH_NativeXComponent_MouseEvent_Callback* callback) | 为此OH_NativeXComponent实例注册鼠标事件回调。 |
| OH_NativeXComponent_RegisterFocusEventCallback(OH_NativeXComponent* component, void (*callback)(OH_NativeXComponent* component, void* window)) | 为此OH_NativeXComponent实例注册获得焦点事件回调。 |
| OH_NativeXComponent_RegisterKeyEventCallback(OH_NativeXComponent* component, void (*callback)(OH_NativeXComponent* component, void* window)) | 为此OH_NativeXComponent实例注册按键事件回调。 |
| OH_NativeXComponent_RegisterBlurEventCallback(OH_NativeXComponent* component, void (*callback)(OH_NativeXComponent* component, void* window)) | 为此OH_NativeXComponent实例注册失去焦点事件回调。 |
| OH_NativeXComponent_GetKeyEvent(OH_NativeXComponent* component, OH_NativeXComponent_KeyEvent** keyEvent) | 获取由XComponent触发的按键事件。 |
| OH_NativeXComponent_GetKeyEventAction(OH_NativeXComponent_KeyEvent* keyEvent, OH_NativeXComponent_KeyAction* action) | 获取按键事件的动作。 |
| OH_NativeXComponent_GetKeyEventCode(OH_NativeXComponent_KeyEvent* keyEvent, OH_NativeXComponent_KeyCode* code) | 获取按键事件的键码值。 |
| OH_NativeXComponent_GetKeyEventSourceType(OH_NativeXComponent_KeyEvent* keyEvent, OH_NativeXComponent_EventSourceType* sourceType) | 获取按键事件的输入源类型。 |
| OH_NativeXComponent_GetKeyEventDeviceId(OH_NativeXComponent_KeyEvent* keyEvent, int64_t* deviceId) | 获取按键事件的设备ID。 |
| OH_NativeXComponent_GetKeyEventTimestamp(OH_NativeXComponent_KeyEvent* keyEvent, int64_t* timestamp) | 获取按键事件的时间戳。 |
上述接口不支持跨线程访问。
XComponent销毁（onSurfaceDestroyed回调触发后）时会释放上述接口中获取的OH_NativeXComponent和window对象。如果再次使用获取的对象，有可能会导致使用野指针或空指针的崩溃问题。
开发步骤
以下步骤以SURFACE类型为例，描述了如何使用XComponent组件调用Node-API接口来创建EGL/GLES环境，实现在主页面绘制图形，并可以改变图形的颜色。
1.  在界面中定义XComponent。
```typescript
//在ets/interface/XComponentContext.ts中声明native侧接口
export default interface XComponentContext {
drawPattern(): void;
getStatus(): XComponentContextStatus;
};
type XComponentContextStatus = {
hasDraw: boolean,
hasChangeColor: boolean,
};
```
2.  Node-API模块注册，具体使用请参考Native API在应用工程中的使用指导。
3.  注册XComponent事件回调，使用Node-API实现XComponent事件回调函数。 (1) 定义surface创建成功，发生改变，销毁和XComponent的touch事件回调接口。 (2) 注册XComponent事件回调函数，在XComponent事件触发时调用3.1步骤中定义的方法。 (3) 定义NapiDrawPattern方法，暴露到ArkTS侧的drawPattern()方法会执行该方法。 (4) 定义TestGetXComponentStatus方法，暴露到ArkTS侧的getStatus()方法会执行该方法。
4.  初始化环境，包括初始化可用的EGLDisplay、确定可用的surface配置、创建渲染区域surface、创建并关联上下文等。
5.  渲染功能实现。 (1) 绘制背景。 (2) 绘制图形。 (3) 改变颜色，重新画一个大小相同颜色不同的图形，与原图形替换，达到改变颜色的效果。
6.  释放相关资源。 (1) EGLCore类下创建Release()方法，释放初始化环境时申请的资源，包含窗口display、渲染区域surface、环境上下文context等。 (2) PluginRender类添加Release()方法，释放EGLCore实例及PluginRender实例。
7.  CMakeLists，使用CMake工具链将C++源代码编译成动态链接库文件。
ArkTS XComponent场景
与Native XComponent不同，ArkTS XComponent不再需要libraryname参数。通过在ArkTS侧获取SurfaceId，布局信息、生命周期回调、触摸、鼠标、按键等事件回调等均在ArkTS侧触发，按需传递到Native侧进行处理。主要开发场景如下：
接口说明
ArkTS侧的XComponentController
| 接口名 | 描述 |
| --- | --- |
| getXComponentSurfaceId(): string | 获取XComponent对应Surface的ID。 |
| onSurfaceCreated(surfaceId: string): void | 当XComponent持有的Surface创建后进行该回调。 |
| onSurfaceChanged(surfaceId: string, rect: SurfaceRect): void | 当XComponent持有的Surface大小改变后（包括首次创建时的大小改变）进行该回调。 |
| onSurfaceDestroyed(surfaceId: string): void | 当XComponent持有的Surface销毁后进行该回调。 |
Native侧
| 接口名 | 描述 |
| --- | --- |
| int32_t OH_NativeWindow_CreateNativeWindowFromSurfaceId (uint64_t surfaceId, OHNativeWindow **window ) | 通过surfaceId创建对应的OHNativeWindow。 |
| void OH_NativeWindow_DestroyNativeWindow (OHNativeWindow* window) | 将OHNativeWindow对象的引用计数减1，当引用计数为0的时候，该OHNativeWindow对象会被析构掉。 |
开发步骤
以下步骤以SURFACE类型为例，描述了如何使用XComponent组件在ArkTS侧传入SurfaceId，在native侧创建NativeWindow实例，然后创建EGL/GLES环境，实现在主页面绘制图形，并可以改变图形的颜色。
1.  在界面中定义XComponent。
2.  Node-API模块注册，具体使用请参考Native API在应用工程中的使用指导。
```typescript
#include <hilog/log.h>
#include "common/common.h"
#include "manager/plugin_manager.h"
namespace NativeXComponentSample {
// 在napi_init.cpp文件中，Init方法注册接口函数，从而将封装的C++方法传递出来，供ArkTS侧调用
EXTERN_C_START
static napi_value Init(napi_env env, napi_value exports) {
// ...
// 向ArkTS侧暴露接口SetSurfaceId(),ChangeSurface(),DestroySurface(),
// DrawPattern(),ChangeColor(),GetXComponentStatus()
napi_property_descriptor desc[] = {
{"SetSurfaceId", nullptr, PluginManager::SetSurfaceId, nullptr, nullptr, nullptr, napi_default, nullptr},
{"ChangeSurface", nullptr, PluginManager::ChangeSurface, nullptr, nullptr, nullptr, napi_default, nullptr},
{"DestroySurface", nullptr, PluginManager::DestroySurface, nullptr, nullptr, nullptr, napi_default, nullptr},
{"DrawPattern", nullptr, PluginManager::DrawPattern, nullptr, nullptr, nullptr, napi_default, nullptr},
{"ChangeColor", nullptr, PluginManager::ChangeColor, nullptr, nullptr, nullptr, napi_default, nullptr},
{"GetXComponentStatus", nullptr, PluginManager::GetXComponentStatus, nullptr, nullptr, nullptr, napi_default,
nullptr}};
if (napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc) != napi_ok) {
OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Init", "napi_define_properties failed");
return nullptr;
}
return exports;
}
EXTERN_C_END
// 编写接口的描述信息，根据实际需要可以修改对应参数
static napi_module nativerenderModule = {.nm_version = 1,
.nm_flags = 0,
.nm_filename = nullptr,
// 入口函数
.nm_register_func = Init,
// 模块名称
.nm_modname = "nativerender",
.nm_priv = ((void *)0),
.reserved = {0}};
} // namespace NativeXComponentSample
// __attribute__((constructor))修饰的方法由系统自动调用，使用Node-API接口napi_module_register()传入模块描述信息进行模块注册
extern "C" __attribute__((constructor)) void RegisterModule(void) {
napi_module_register(&NativeXComponentSample::nativerenderModule);
}
```
3.  上述注册的六个函数在native侧具体实现。
4.  配置具体的CMakeLists，使用CMake工具链将C++源代码编译成动态链接库文件。
自绘制原理说明
XComponent持有一个surface，开发者能通过调用NativeWindow等接口，申请并提交Buffer至图形队列，以此方式将自绘制内容传送至该surface。XComponent负责将此surface整合进UI界面，其中展示的内容正是开发者传送的自绘制内容。surface的默认位置与大小与XComponent组件一致，开发者可利用setXComponentSurfaceRect接口自定义调整surface的位置和大小。
当开发者传输的绘制内容包含透明元素时，surface区域的显示效果会与下方内容进行合成展示。例如，若传输的内容完全透明，且XComponent的背景色被设置为黑色，同时Surface保持默认的大小与位置，则最终显示的将是一片黑色区域。
生命周期说明
开发者在ArkTS侧使用如下代码即可用XComponent组件进行利用EGL/OpenGLES渲染的开发。
```typescript
@Builder
function myComponent() {
XComponent({ id: 'xcomponentId1', type: XComponentType.SURFACE, libraryname: 'nativerender' })
.onLoad((context) => {})
.onDestroy(() => {})
}
```
onLoad事件
触发时刻：XComponent准备好surface后触发。
参数context：其上面挂载了暴露在模块上的Native方法，使用方法类似于利用 import context from "libnativerender.so" 直接加载模块后获得的context实例。
时序：
​ Native XComponent场景：
​ onLoad事件的触发和surface相关，其和Native侧的OnSurfaceCreated的时序如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170256.02659464623615346953008373520980:50001231000000:2800:89ADDB86FEE9790146D76966450251DCB2C00DF4B04EDF32041E72736746C090.png)
​ ArkTS XComponent场景：
​ onLoad事件的触发和surface相关，其和ArkTS侧的OnSurfaceCreated的时序如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170256.07378438934582743154601457857863:50001231000000:2800:CFF032E5426D77E40B8AF91F1BB7B2197DC2E1A3AFC5D7E9743C6E18D1E2D55C.png)
onDestroy事件
触发时刻：XComponent组件被销毁时触发，与一般ArkUI的组件销毁时机一致。
时序：
​ Native XComponent场景：
​ onDestroy事件的触发和surface相关，其和Native侧的OnSurfaceDestroyed的时序如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170256.99563594063196636834042490078005:50001231000000:2800:C0C412FEF5BD66625E6FB461A3DD4770136631E5965E84CCAE20CF490D03EA12.png)
​ ArkTS XComponent场景：
​ onDestroy事件的触发和surface相关，其和ArkTS侧的OnSurfaceDestroyed的时序如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170256.32014340943945059546089509706010:50001231000000:2800:B5230D99FBE39BC0B57A677C2B66581FB2191C61D3BAA9659FED5610766994B2.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-set-navigation-routing-V14
爬取时间: 2025-04-27 23:20:18
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-navigation-introduction-V14
爬取时间: 2025-04-27 23:20:32
来源: Huawei Developer
组件导航（Navigation）和页面路由（@ohos.router）均支持应用内的页面跳转，但组件导航支持在组件内部进行跳转，使用更灵活。组件导航具备更强的一次开发多端部署能力，可以进行更加灵活的页面栈操作，同时支持更丰富的动效和生命周期。因此，推荐使用组件导航（Navigation）来实现页面跳转以及组件内的跳转，以获得更佳的使用体验。
架构差异
从ArkUI组件树层级上来看，原先由Router管理的page在页面栈管理节点stage的下面。Navigation作为导航容器组件，可以挂载在单个page节点下，也可以叠加、嵌套。Navigation管理了标题栏、内容区和工具栏，内容区用于显示用户自定义页面的内容，并支持页面的路由能力。Navigation的这种设计上有如下优势：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170256.58914943614171825760975765575943:50001231000000:2800:F1428D6BF052418CA8C3BC54CF8D1F9A6732AF083A7FA27459051C003599ADCC.png)
1.  接口上显式区分标题栏、内容区和工具栏，实现更加灵活的管理和UX动效能力；
2.  显式提供路由容器概念，由开发者决定路由容器的位置，支持在全模态、半模态、弹窗中显示；
3.  整合UX设计和一多能力，默认提供统一的标题显示、页面切换和单双栏适配能力；
4.  基于通用UIBuilder能力，由开发者决定页面别名和页面UI对应关系，提供更加灵活的页面配置能力；
5.  基于组件属性动效和共享元素动效能力，将页面切换动效转换为组件属性动效实现，提供更加丰富和灵活的切换动效；
6.  开放了页面栈对象，开发者可以继承，能更好的管理页面显示。
能力对比
| 业务场景 | Navigation | Router |
| --- | --- | --- |
| 一多能力 | 支持，Auto模式自适应单栏跟双栏显示 | 不支持 |
| 跳转指定页面 | pushPath & pushDestination | pushUrl & pushNameRoute |
| 跳转HSP中页面 | 支持 | 支持 |
| 跳转HAR中页面 | 支持 | 支持 |
| 跳转传参 | 支持 | 支持 |
| 获取指定页面参数 | 支持 | 不支持 |
| 传参类型 | 传参为对象形式 | 传参为对象形式，对象中暂不支持方法变量 |
| 跳转结果回调 | 支持 | 支持 |
| 跳转单例页面 | 支持 | 支持 |
| 页面返回 | 支持 | 支持 |
| 页面返回传参 | 支持 | 支持 |
| 返回指定路由 | 支持 | 支持 |
| 页面返回弹窗 | 支持，通过路由拦截实现 | showAlertBeforeBackPage |
| 路由替换 | replacePath & replacePathByName | replaceUrl & replaceNameRoute |
| 路由栈清理 | clear | clear |
| 清理指定路由 | removeByIndexes & removeByName | 不支持 |
| 转场动画 | 支持 | 支持 |
| 自定义转场动画 | 支持 | 支持，动画类型受限 |
| 屏蔽转场动画 | 支持全局和单次 | 支持 设置pageTransition方法duration为0 |
| geometryTransition共享元素动画 | 支持（NavDestination之间共享） | 不支持 |
| 页面生命周期监听 | UIObserver.on('navDestinationUpdate') | UIObserver.on('routerPageUpdate') |
| 获取页面栈对象 | 支持 | 不支持 |
| 路由拦截 | 支持通过setInterception做路由拦截 | 不支持 |
| 路由栈信息查询 | 支持 | getState() & getLength() |
| 路由栈move操作 | moveToTop & moveIndexToTop | 不支持 |
| 沉浸式页面 | 支持 | 不支持，需通过window配置 |
| 设置页面标题栏（titlebar）和工具栏（toolbar） | 支持 | 不支持 |
| 模态嵌套路由 | 支持 | 不支持 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-navigation-navigation-V14
爬取时间: 2025-04-27 23:20:46
来源: Huawei Developer
组件导航（Navigation）主要用于实现页面间以及组件内部的页面跳转，支持在不同组件间传递跳转参数，提供灵活的跳转栈操作，从而更便捷地实现对不同页面的访问和复用。本文将从组件导航（Navigation）的显示模式、路由操作、子页面管理、跨包跳转以及跳转动效等几个方面进行详细介绍。
Navigation是路由导航的根视图容器，一般作为页面（@Entry）的根容器，包括单栏（Stack）、分栏（Split）和自适应（Auto）三种显示模式。Navigation组件适用于模块内和跨模块的路由切换，通过组件级路由能力实现更加自然流畅的转场体验，并提供多种标题栏样式来呈现更好的标题和内容联动效果。一次开发，多端部署场景下，Navigation组件能够自动适配窗口显示大小，在窗口较大的场景下自动切换分栏展示效果。
Navigation组件主要包含​导航页和子页。导航页由标题栏（包含菜单栏）、内容区和工具栏组成，可以通过hideNavBar属性进行隐藏，导航页不存在页面栈中，与子页，以及子页之间可以通过路由操作进行切换。
在API Version 9上，Navigation需要配合NavRouter组件实现页面路由。从API Version 10开始，更推荐使用NavPathStack实现页面路由。
设置页面显示模式
Navigation组件通过mode属性设置页面的显示模式。
-  自适应模式 Navigation组件默认为自适应模式，此时mode属性为NavigationMode.Auto。自适应模式下，当页面宽度大于等于一定阈值( API version 9及以前：520vp，API version 10及以后：600vp )时，Navigation组件采用分栏模式，反之采用单栏模式。
-  单页面模式 图1单页面布局示意图 将mode属性设置为NavigationMode.Stack，Navigation组件即可设置为单页面显示模式。
```typescript
Navigation() {
// ...
}
.mode(NavigationMode.Stack)
```
-  分栏模式 图2分栏布局示意图 将mode属性设置为NavigationMode.Split，Navigation组件即可设置为分栏显示模式。
```typescript
@Entry
@Component
struct NavigationExample {
@State TooTmp: ToolbarItem = {
'value': "func", 'icon': "./image/ic_public_highlights.svg", 'action': () => {
}
}
@Provide('pageInfos') pageInfos: NavPathStack = new NavPathStack()
private arr: number[] = [1, 2, 3];
@Builder
PageMap(name: string) {
if (name === "NavDestinationTitle1") {
pageOneTmp()
} else if (name === "NavDestinationTitle2") {
pageTwoTmp()
} else if (name === "NavDestinationTitle3") {
pageThreeTmp()
}
}
build() {
Column() {
Navigation(this.pageInfos) {
TextInput({ placeholder: 'search...' })
.width("90%")
.height(40)
.backgroundColor('#FFFFFF')
List({ space: 12 }) {
ForEach(this.arr, (item: number) => {
ListItem() {
Text("Page" + item)
.width("100%")
.height(72)
.backgroundColor('#FFFFFF')
.borderRadius(24)
.fontSize(16)
.fontWeight(500)
.textAlign(TextAlign.Center)
.onClick(() => {
this.pageInfos.pushPath({ name: "NavDestinationTitle" + item })
})
}
}, (item: number) => item.toString())
}
.width("90%")
.margin({ top: 12 })
}
.title("主标题")
.mode(NavigationMode.Split)
.navDestination(this.PageMap)
.menus([
{
value: "", icon: "./image/ic_public_search.svg", action: () => {
}
},
{
value: "", icon: "./image/ic_public_add.svg", action: () => {
}
},
{
value: "", icon: "./image/ic_public_add.svg", action: () => {
}
},
{
value: "", icon: "./image/ic_public_add.svg", action: () => {
}
},
{
value: "", icon: "./image/ic_public_add.svg", action: () => {
}
}
])
.toolbarConfiguration([this.TooTmp, this.TooTmp, this.TooTmp])
}
.height('100%')
.width('100%')
.backgroundColor('#F1F3F5')
}
}
// PageOne.ets
@Component
export struct pageOneTmp {
@Consume('pageInfos') pageInfos: NavPathStack;
build() {
NavDestination() {
Column() {
Text("NavDestinationContent1")
}.width('100%').height('100%')
}.title("NavDestinationTitle1")
.onBackPressed(() => {
const popDestinationInfo = this.pageInfos.pop() // 弹出路由栈栈顶元素
console.log('pop' + '返回值' + JSON.stringify(popDestinationInfo))
return true
})
}
}
// PageTwo.ets
@Component
export struct pageTwoTmp {
@Consume('pageInfos') pageInfos: NavPathStack;
build() {
NavDestination() {
Column() {
Text("NavDestinationContent2")
}.width('100%').height('100%')
}.title("NavDestinationTitle2")
.onBackPressed(() => {
const popDestinationInfo = this.pageInfos.pop() // 弹出路由栈栈顶元素
console.log('pop' + '返回值' + JSON.stringify(popDestinationInfo))
return true
})
}
}
// PageThree.ets
@Component
export struct pageThreeTmp {
@Consume('pageInfos') pageInfos: NavPathStack;
build() {
NavDestination() {
Column() {
Text("NavDestinationContent3")
}.width('100%').height('100%')
}.title("NavDestinationTitle3")
.onBackPressed(() => {
const popDestinationInfo = this.pageInfos.pop() // 弹出路由栈栈顶元素
console.log('pop' + '返回值' + JSON.stringify(popDestinationInfo))
return true
})
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170256.41296011906327807458743085027360:50001231000000:2800:9806DDC0C52DBFC412E5F1BF9FF2339DD6A36889B373115692314648BFAED023.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170256.66644871453109750141382808886251:50001231000000:2800:A4A6633EC013D629075C18D235BC865C085A58FD332EC4B55856E6957C46C868.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170256.69918108823079568231515525693281:50001231000000:2800:38DD1707FBBF831E7962B3D8DA41969295172D818E5C6F0AED08CBC146AFCD9B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170256.33027755952925443393115360634917:50001231000000:2800:3FC7401B2A782EBEE00D4B6E4CA9582B8090A85D3369FB43F907CBDBC3537429.jpg)
设置标题栏模式
标题栏在界面顶部，用于呈现界面名称和操作入口，Navigation组件通过titleMode属性设置标题栏模式。
Navigation或NavDestination未设置主副标题并且没有返回键时，不显示标题栏。
-  Mini模式 普通型标题栏，用于一级页面不需要突出标题的场景。 图3Mini模式标题栏
```typescript
Navigation() {
// ...
}
.titleMode(NavigationTitleMode.Mini)
```
-  Full模式 强调型标题栏，用于一级页面需要突出标题的场景。 图4Full模式标题栏
```typescript
Navigation() {
// ...
}
.titleMode(NavigationTitleMode.Full)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170257.95148878919351186146381499888271:50001231000000:2800:537E3CE25744862CF7B4E712ABA7A3C241FFEB80A025483ACE0631BF375F6DB4.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170257.55537052176978053477213911685910:50001231000000:2800:D860C8C9B048D178DEB260A40AFBA29D3B62DA0CFF3660EB5D57BD652BC0694A.jpg)
设置菜单栏
菜单栏位于Navigation组件的右上角，开发者可以通过menus属性进行设置。menus支持Array<NavigationMenuItem>和CustomBuilder两种参数类型。使用Array<NavigationMenuItem>类型时，竖屏最多支持显示3个图标，横屏最多支持显示5个图标，多余的图标会被放入自动生成的更多图标。
图5设置了3个图标的菜单栏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170257.80474046983310240431043033630676:50001231000000:2800:409B8AB426DB8B3EDCAFEB23CDEB2D0839F1D7162CC2ACBFBE8FFC4ED08661EF.jpg)
```typescript
let TooTmp: NavigationMenuItem = {'value': "", 'icon': "./image/ic_public_highlights.svg", 'action': ()=> {}}
Navigation() {
// ...
}
.menus([TooTmp,
TooTmp,
TooTmp])
```
图片也可以引用resources中的资源。
```typescript
let TooTmp: NavigationMenuItem = {'value': "", 'icon': "resources/base/media/ic_public_highlights.svg", 'action': ()=> {}}
Navigation() {
// ...
}
.menus([TooTmp,
TooTmp,
TooTmp])
```
图6设置了4个图标的菜单栏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170257.03688728241443131647506084501023:50001231000000:2800:10B8D42C742808864AABD009414B7555ECAE3E347049C613A98ECFD062C231BB.jpg)
```typescript
let TooTmp: NavigationMenuItem = {'value': "", 'icon': "./image/ic_public_highlights.svg", 'action': ()=> {}}
Navigation() {
// ...
}
// 竖屏最多支持显示3个图标，多余的图标会被放入自动生成的更多图标。
.menus([TooTmp,
TooTmp,
TooTmp,
TooTmp])
```
设置工具栏
工具栏位于Navigation组件的底部，开发者可以通过toolbarConfiguration属性进行设置。
图7工具栏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170257.46321691138069084061898894034209:50001231000000:2800:7742665AE6235904445ED3E74B0DE5A2190F94E63F1E90EA5B31BEF9A1C1299D.jpg)
```typescript
let TooTmp: ToolbarItem = {'value': "func", 'icon': "./image/ic_public_highlights.svg", 'action': ()=> {}}
let TooBar: ToolbarItem[] = [TooTmp,TooTmp,TooTmp]
Navigation() {
// ...
}
.toolbarConfiguration(TooBar)
```
路由操作
Navigation路由相关的操作都是基于页面栈NavPathStack提供的方法进行，每个Navigation都需要创建并传入一个NavPathStack对象，用于管理页面。主要涉及页面跳转、页面返回、页面替换、页面删除、参数获取、路由拦截等功能。
从API version 12开始，页面栈允许被继承。开发者可以在派生类中自定义属性和方法，也可以重写父类的方法。派生类对象可以替代基类NavPathStack对象使用。具体示例代码参见：页面栈继承示例代码。
不建议开发者通过监听生命周期的方式管理自己的页面栈。
不建议开发者通过监听生命周期的方式管理自己的页面栈。
```typescript
@Entry
@Component
struct Index {
// 创建一个页面栈对象并传入Navigation
pageStack: NavPathStack = new NavPathStack()
build() {
Navigation(this.pageStack) {
}
.title('Main')
}
}
```
页面跳转
NavPathStack通过Push相关的接口去实现页面跳转的功能，主要分为以下三类:
1.  普通跳转，通过页面的name去跳转，并可以携带param。
```typescript
this.pageStack.pushPath({ name: "PageOne", param: "PageOne Param" })
this.pageStack.pushPathByName("PageOne", "PageOne Param")
```
2.  带返回回调的跳转，跳转时添加onPop回调，能在页面出栈时获取返回信息，并进行处理。
```typescript
this.pageStack.pushPathByName('PageOne', "PageOne Param", (popInfo) => {
console.log('Pop page name is: ' + popInfo.info.name + ', result: ' + JSON.stringify(popInfo.result))
});
```
3.  带错误码的跳转，跳转结束会触发异步回调，返回错误码信息。
```typescript
this.pageStack.pushDestination({name: "PageOne", param: "PageOne Param"})
.catch((error: BusinessError) => {
console.error(`Push destination failed, error code = ${error.code}, error.message = ${error.message}.`);
}).then(() => {
console.info('Push destination succeed.');
});
this.pageStack.pushDestinationByName("PageOne", "PageOne Param")
.catch((error: BusinessError) => {
console.error(`Push destination failed, error code = ${error.code}, error.message = ${error.message}.`);
}).then(() => {
console.info('Push destination succeed.');
});
```
页面返回
NavPathStack通过Pop相关接口去实现页面返回功能。
```typescript
// 返回到上一页
this.pageStack.pop()
// 返回到上一个PageOne页面
this.pageStack.popToName("PageOne")
// 返回到索引为1的页面
this.pageStack.popToIndex(1)
// 返回到根首页（清除栈中所有页面）
this.pageStack.clear()
```
页面替换
NavPathStack通过Replace相关接口去实现页面替换功能。
```typescript
// 将栈顶页面替换为PageOne
this.pageStack.replacePath({ name: "PageOne", param: "PageOne Param" })
this.pageStack.replacePathByName("PageOne", "PageOne Param")
// 带错误码的替换，跳转结束会触发异步回调，返回错误码信息
this.pageStack.replaceDestination({name: "PageOne", param: "PageOne Param"})
.catch((error: BusinessError) => {
console.error(`Replace destination failed, error code = ${error.code}, error.message = ${error.message}.`);
}).then(() => {
console.info('Replace destination succeed.');
})
```
页面删除
NavPathStack通过Remove相关接口去实现删除页面栈中特定页面的功能。
```typescript
// 删除栈中name为PageOne的所有页面
this.pageStack.removeByName("PageOne")
// 删除指定索引的页面
this.pageStack.removeByIndexes([1,3,5])
// 删除指定id的页面
this.pageStack.removeByNavDestinationId("1");
```
移动页面
NavPathStack通过Move相关接口去实现移动页面栈中特定页面到栈顶的功能。
```typescript
// 移动栈中name为PageOne的页面到栈顶
this.pageStack.moveToTop("PageOne");
// 移动栈中索引为1的页面到栈顶
this.pageStack.moveIndexToTop(1);
```
参数获取
NavPathStack通过Get相关接口去获取页面的一些参数。
```typescript
// 获取栈中所有页面name集合
this.pageStack.getAllPathName()
// 获取索引为1的页面参数
this.pageStack.getParamByIndex(1)
// 获取PageOne页面的参数
this.pageStack.getParamByName("PageOne")
// 获取PageOne页面的索引集合
this.pageStack.getIndexByName("PageOne")
```
路由拦截
NavPathStack提供了setInterception方法，用于设置Navigation页面跳转拦截回调。该方法需要传入一个NavigationInterception对象，该对象包含三个回调函数：
| 名称 | 描述 |
| --- | --- |
| willShow | 页面跳转前回调，允许操作栈，在当前跳转生效。 |
| didShow | 页面跳转后回调，在该回调中操作栈会在下一次跳转生效。 |
| modeChange | Navigation单双栏显示状态发生变更时触发该回调。 |
无论是哪个回调，在进入回调时页面栈都已经发生了变化。
开发者可以在willShow回调中通过修改路由栈来实现路由拦截重定向的能力。
```typescript
this.pageStack.setInterception({
willShow: (from: NavDestinationContext | "navBar", to: NavDestinationContext | "navBar",
operation: NavigationOperation, animated: boolean) => {
if (typeof to === "string") {
console.log("target page is navigation home page.");
return;
}
// 将跳转到PageTwo的路由重定向到PageOne
let target: NavDestinationContext = to as NavDestinationContext;
if (target.pathInfo.name === 'PageTwo') {
target.pathStack.pop();
target.pathStack.pushPathByName('PageOne', null);
}
}
})
```
子页面
NavDestination是Navigation子页面的根容器，用于承载子页面的一些特殊属性以及生命周期等。NavDestination可以设置独立的标题栏和菜单栏等属性，使用方法与Navigation相同。NavDestination也可以通过mode属性设置不同的显示类型，用于满足不同页面的诉求。
页面显示类型
-  标准类型 NavDestination组件默认为标准类型，此时mode属性为NavDestinationMode.STANDARD。标准类型的NavDestination的生命周期跟随其在NavPathStack页面栈中的位置变化而改变。
-  弹窗类型 NavDestination设置mode为NavDestinationMode.DIALOG弹窗类型，此时整个NavDestination默认透明显示。弹窗类型的NavDestination显示和消失时不会影响下层标准类型的NavDestination的显示和生命周期，两者可以同时显示。
```typescript
// Dialog NavDestination
@Entry
@Component
struct Index {
@Provide('NavPathStack') pageStack: NavPathStack = new NavPathStack()
@Builder
PagesMap(name: string) {
if (name == 'DialogPage') {
DialogPage()
}
}
build() {
Navigation(this.pageStack) {
Button('Push DialogPage')
.margin(20)
.width('80%')
.onClick(() => {
this.pageStack.pushPathByName('DialogPage', '');
})
}
.mode(NavigationMode.Stack)
.title('Main')
.navDestination(this.PagesMap)
}
}
@Component
export struct DialogPage {
@Consume('NavPathStack') pageStack: NavPathStack;
build() {
NavDestination() {
Stack({ alignContent: Alignment.Center }) {
Column() {
Text("Dialog NavDestination")
.fontSize(20)
.margin({ bottom: 100 })
Button("Close").onClick(() => {
this.pageStack.pop()
}).width('30%')
}
.justifyContent(FlexAlign.Center)
.backgroundColor(Color.White)
.borderRadius(10)
.height('30%')
.width('80%')
}.height("100%").width('100%')
}
.backgroundColor('rgba(0,0,0,0.5)')
.hideTitleBar(true)
.mode(NavDestinationMode.DIALOG)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170257.03361855130501698142350743862045:50001231000000:2800:BE0E64C44DE0410D4DC25531874EC109D9C1CE78508E140A298FCE6CC71CD48C.png)
页面生命周期
Navigation作为路由容器，其生命周期承载在NavDestination组件上，以组件事件的形式开放。
其生命周期大致可分为三类，自定义组件生命周期、通用组件生命周期和自有生命周期。其中，aboutToAppear和aboutToDisappear是自定义组件的生命周期(NavDestination外层包含的自定义组件)，OnAppear和OnDisappear是组件的通用生命周期。剩下的六个生命周期为NavDestination独有。
生命周期时序如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170257.57248561103336225141623973081586:50001231000000:2800:AEE6C0570D00A0F60BBF945221CFF5BF108F40FD39ED9890B222E339904473C9.png)
页面监听和查询
为了方便组件跟页面解耦，在NavDestination子页面内部的自定义组件可以通过全局方法监听或查询到页面的一些状态信息。
-  页面信息查询 自定义组件提供queryNavDestinationInfo方法，可以在NavDestination内部查询到当前所属页面的信息，返回值为NavDestinationInfo，若查询不到则返回undefined。
```typescript
import { uiObserver } from '@kit.ArkUI';
// NavDestination内的自定义组件
@Component
struct MyComponent {
navDesInfo: uiObserver.NavDestinationInfo | undefined
aboutToAppear(): void {
this.navDesInfo = this.queryNavDestinationInfo();
}
build() {
Column() {
Text("所属页面Name: " + this.navDesInfo?.name)
}.width('100%').height('100%')
}
}
```
-  页面状态监听 通过observer.on('navDestinationUpdate')提供的注册接口可以注册NavDestination生命周期变化的监听，使用方式如下： 也可以注册页面切换的状态回调，能在页面发生路由切换的时候拿到对应的页面信息NavDestinationSwitchInfo，并且提供了UIAbilityContext和UIContext不同范围的监听：
```typescript
uiObserver.on('navDestinationUpdate', (info) => {
console.info('NavDestination state update', JSON.stringify(info));
});
```
页面转场
Navigation默认提供了页面切换的转场动画，通过页面栈操作时，会触发不同的转场效果（API version 13之前，Dialog类型的页面默认无转场动画。从API version13开始，Dialog类型的页面支持系统转场动画。），Navigation也提供了关闭系统转场、自定义转场以及共享元素转场的能力。
关闭转场
-  全局关闭 Navigation通过NavPathStack中提供的disableAnimation方法可以在当前Navigation中关闭或打开所有转场动画。
```typescript
pageStack: NavPathStack = new NavPathStack()
aboutToAppear(): void {
this.pageStack.disableAnimation(true)
}
```
-  单次关闭 NavPathStack中提供的Push、Pop、Replace等接口中可以设置animated参数，默认为true表示有转场动画，需要单次关闭转场动画可以置为false，不影响下次转场动画。
```typescript
pageStack: NavPathStack = new NavPathStack()
this.pageStack.pushPath({ name: "PageOne" }, false)
this.pageStack.pop(false)
```
自定义转场
Navigation通过customNavContentTransition事件提供自定义转场动画的能力，通过如下三步可以定义一个自定义的转场动画。
具体示例代码可以参考Navigation自定义转场示例。
共享元素转场
NavDestination之间切换时可以通过geometryTransition实现共享元素转场。配置了共享元素转场的页面同时需要关闭系统默认的转场动画。
1.  为需要实现共享元素转场的组件添加geometryTransition属性，id参数必须在两个NavDestination之间保持一致。
```typescript
// 起始页配置共享元素id
NavDestination() {
Column() {
// ...
Image($r('app.media.startIcon'))
.geometryTransition('sharedId')
.width(100)
.height(100)
}
}
.title('FromPage')
// 目的页配置共享元素id
NavDestination() {
Column() {
// ...
Image($r('app.media.startIcon'))
.geometryTransition('sharedId')
.width(200)
.height(200)
}
}
.title('ToPage')
```
2.  将页面路由的操作，放到animateTo动画闭包中，配置对应的动画参数以及关闭系统默认的转场。
```typescript
NavDestination() {
Column() {
Button('跳转目的页')
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
this.getUIContext()?.animateTo({ duration: 1000 }, () => {
this.pageStack.pushPath({ name: 'ToPage' }, false)
})
})
}
}
.title('FromPage')
```
跨包动态路由
通过静态import页面再进行路由跳转的方式会造成不同模块之间的依赖耦合，以及首页加载时间长等问题。
动态路由设计的初衷旨在解决多个模块（HAR/HSP）能够复用相同的业务逻辑，实现各业务模块间的解耦，同时支持路由功能的扩展与整合。
动态路由的优势：
动态路由提供系统路由表和自定义路由表两种实现方式。
-  系统路由表相对自定义路由表，使用更简单，只需要添加对应页面跳转配置项，即可实现页面跳转。
-  自定义路由表使用起来更复杂，但是可以根据应用业务进行定制处理。
支持自定义路由表和系统路由表混用。
系统路由表
从API version 12开始，Navigation支持使用系统路由表的方式进行动态路由。各业务模块（HSP/HAR）中需要独立配置route_map.json文件，在触发路由跳转时，应用只需要通过NavPathStack提供的路由方法，传入需要路由的页面配置名称，此时系统会自动完成路由模块的动态加载、页面组件构建，并完成路由跳转，从而实现了开发层面的模块解耦。系统路由表不支持预览器，跨平台及模拟器。其主要步骤如下：
1.  在跳转目标模块的配置文件module.json5添加路由表配置：
```json
{
"module" : {
"routerMap": "$profile:route_map"
}
}
```
2.  添加完路由配置文件地址后，需要在工程resources/base/profile中创建route_map.json文件。添加如下配置信息： 配置说明如下：
```json
{
"routerMap": [
{
"name": "PageOne",
"pageSourceFile": "src/main/ets/pages/PageOne.ets",
"buildFunction": "PageOneBuilder",
"data": {
"description" : "this is PageOne"
}
}
]
}
```
3.  在跳转目标页面中，需要配置入口Builder函数，函数名称需要和route_map.json配置文件中的buildFunction保持一致，否则在编译时会报错。
```typescript
// 跳转页面入口函数
@Builder
export function PageOneBuilder() {
PageOne()
}
@Component
struct PageOne {
pathStack: NavPathStack = new NavPathStack()
build() {
NavDestination() {
}
.title('PageOne')
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack
})
}
}
```
4.  通过pushPathByName等路由接口进行页面跳转。(注意：此时Navigation中可以不用配置navDestination属性)。
```typescript
@Entry
@Component
struct Index {
pageStack : NavPathStack = new NavPathStack();
build() {
Navigation(this.pageStack){
}.onAppear(() => {
this.pageStack.pushPathByName("PageOne", null, false);
})
.hideNavBar(true)
}
}
```
| 配置项 | 说明 |
| --- | --- |
| name | 跳转页面名称。 |
| pageSourceFile | 跳转目标页在包内的路径，相对src目录的相对路径。 |
| buildFunction | 跳转目标页的入口函数名称，必须以@Builder修饰。 |
| data | 应用自定义字段。可以通过配置项读取接口getConfigInRouteMap获取。 |
自定义路由表
开发者可以通过自定义路由表的方式来实现跨包动态路由，具体实现方法请参考Navigation自定义动态路由示例。
实现方案：
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-navigation-transition-V14
爬取时间: 2025-04-27 23:21:00
来源: Huawei Developer
导航转场是页面的路由转场方式，也就是一个界面消失，另外一个界面出现的动画效果。开发者也可以自定义导航转场的动画效果，具体请参考Navigation示例3。
导航转场推荐使用Navigation组件实现，可搭配NavDestination组件实现导航功能。
完整的代码示例和效果如下。
创建导航页
实现步骤为：
1.使用Navigation创建导航主页，并创建路由栈NavPathStack以此来实现不同页面之间的跳转。
2.在Navigation中增加List组件，来定义导航主页中不同的一级界面。
3.在List内的组件添加onClick方法，并在其中使用路由栈NavPathStack的pushPathByName方法，使组件可以在点击之后从当前页面跳转到输入参数name在路由表内对应的页面。
```typescript
//PageOne.ets
@Entry
@Component
struct NavigationDemo {
@Provide('pathInfos') pathInfos: NavPathStack = new NavPathStack();
private listArray: Array<string> = ['WLAN', 'Bluetooth', 'Personal Hotpot', 'Connect & Share'];
build() {
Column() {
Navigation(this.pathInfos) {
TextInput({ placeholder: '输入关键字搜索' })
.width('90%')
.height(40)
.margin({ bottom: 10 })
// 通过List定义导航的一级界面
List({ space: 12, initialIndex: 0 }) {
ForEach(this.listArray, (item: string) => {
ListItem() {
Row() {
Row() {
Text(`${item.slice(0, 1)}`)
.fontColor(Color.White)
.fontSize(14)
.fontWeight(FontWeight.Bold)
}
.width(30)
.height(30)
.backgroundColor('#a8a8a8')
.margin({ right: 20 })
.borderRadius(20)
.justifyContent(FlexAlign.Center)
Column() {
Text(item)
.fontSize(16)
.margin({ bottom: 5 })
}
.alignItems(HorizontalAlign.Start)
Blank()
Row()
.width(12)
.height(12)
.margin({ right: 15 })
.border({
width: { top: 2, right: 2 },
color: 0xcccccc
})
.rotate({ angle: 45 })
}
.borderRadius(15)
.shadow({ radius: 100, color: '#ededed' })
.width('90%')
.alignItems(VerticalAlign.Center)
.padding({ left: 15, top: 15, bottom: 15 })
.backgroundColor(Color.White)
}
.width('100%')
.onClick(() => {
this.pathInfos.pushPathByName(`${item}`, '详情页面参数')//将name指定的NaviDestination页面信息入栈,传递的参数为param
})
}, (item: string): string => item)
}
.listDirection(Axis.Vertical)
.edgeEffect(EdgeEffect.Spring)
.sticky(StickyStyle.Header)
.chainAnimation(false)
.width('100%')
}
.width('100%')
.mode(NavigationMode.Auto)
.title('设置') // 设置标题文字
}
.size({ width: '100%', height: '100%' })
.backgroundColor(0xf4f4f5)
}
}
```
创建导航子页
导航子页1实现步骤为：
1.使用NavDestination，来创建导航子页CommonPage。
2.创建路由栈NavPathStack并在onReady时进行初始化，获取当前所在的页面栈，以此来实现不同页面之间的跳转。
3.在子页面内的组件添加onClick，并在其中使用路由栈NavPathStack的pop方法，使组件可以在点击之后弹出路由栈栈顶元素实现页面的返回。
```typescript
//PageOne.ets
@Builder
export function MyCommonPageBuilder(name: string, param: string) {
MyCommonPage({ name: name, value: param })
}
@Component
export struct MyCommonPage {
pathInfos: NavPathStack = new NavPathStack();
name: String = '';
@State value: String = '';
build() {
NavDestination() {
Column() {
Text(`${this.name}设置页面`)
.width('100%')
.fontSize(20)
.fontColor(0x333333)
.textAlign(TextAlign.Center)
.textShadow({
radius: 2,
offsetX: 4,
offsetY: 4,
color: 0x909399
})
.padding({ top: 30 })
Text(`${JSON.stringify(this.value)}`)
.width('100%')
.fontSize(18)
.fontColor(0x666666)
.textAlign(TextAlign.Center)
.padding({ top: 45 })
Button('返回')
.width('50%')
.height(40)
.margin({ top: 50 })
.onClick(() => {
//弹出路由栈栈顶元素，返回上个页面
this.pathInfos.pop();
})
}
.size({ width: '100%', height: '100%' })
}.title(`${this.name}`)
.onReady((ctx: NavDestinationContext) => {
//NavDestinationContext获取当前所在的页面栈
this.pathInfos = ctx.pathStack;
})
}
}
```
导航子页2实现步骤为：
1.使用NavDestination，来创建导航子页SharePage。
2.创建路由栈NavPathStack并在onReady时进行初始化，获取当前所在的页面栈，以此来实现不同页面之间的跳转。
3.在子页面内的组件添加onClick，并在其中使用路由栈NavPathStack的pushPathByName方法，使组件可以在点击之后从当前页面跳转到输入参数name在路由表内对应的页面。
```typescript
//PageTwo.ets
@Builder
export function MySharePageBuilder(name: string, param: string) {
MySharePage({ name: name })
}
@Component
export struct MySharePage {
pathInfos: NavPathStack = new NavPathStack();
name: String = '';
private listArray: Array<string> = ['Projection', 'Print', 'VPN', 'Private DNS', 'NFC'];
build() {
NavDestination() {
Column() {
List({ space: 12, initialIndex: 0 }) {
ForEach(this.listArray, (item: string) => {
ListItem() {
Row() {
Row() {
Text(`${item.slice(0, 1)}`)
.fontColor(Color.White)
.fontSize(14)
.fontWeight(FontWeight.Bold)
}
.width(30)
.height(30)
.backgroundColor('#a8a8a8')
.margin({ right: 20 })
.borderRadius(20)
.justifyContent(FlexAlign.Center)
Column() {
Text(item)
.fontSize(16)
.margin({ bottom: 5 })
}
.alignItems(HorizontalAlign.Start)
Blank()
Row()
.width(12)
.height(12)
.margin({ right: 15 })
.border({
width: { top: 2, right: 2 },
color: 0xcccccc
})
.rotate({ angle: 45 })
}
.borderRadius(15)
.shadow({ radius: 100, color: '#ededed' })
.width('90%')
.alignItems(VerticalAlign.Center)
.padding({ left: 15, top: 15, bottom: 15 })
.backgroundColor(Color.White)
}
.width('100%')
.onClick(() => {
this.pathInfos.pushPathByName(`${item}`, '页面设置参数')
})
}, (item: string): string => item)
}
.listDirection(Axis.Vertical)
.edgeEffect(EdgeEffect.Spring)
.sticky(StickyStyle.Header)
.width('100%')
}
.size({ width: '100%', height: '100%' })
}.title(`${this.name}`)
.onReady((ctx: NavDestinationContext) => {
//NavDestinationContext获取当前所在的页面栈
this.pathInfos = ctx.pathStack;
})
}
}
```
创建路由跳转
实现步骤为：
1.工程配置文件module.json5中配置 {"routerMap": "$profile:route_map"}。
2.route_map.json中配置全局路由表，路由栈NavPathStack可根据路由表中的name将对应页面信息入栈。
```typescript
{
"routerMap" : [
{
"name" : "WLAN",
"pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
"buildFunction" : "MyCommonPageBuilder"
},
{
"name" : "Bluetooth",
"pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
"buildFunction" : "MyCommonPageBuilder"
},
{
"name" : "Personal Hotpot",
"pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
"buildFunction" : "MyCommonPageBuilder"
},
{
"name" : "Connect & Share",
"pageSourceFile"  : "src/main/ets/pages/PageTwo.ets",
"buildFunction" : "MySharePageBuilder"
},
{
"name" : "Projection",
"pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
"buildFunction" : "MyCommonPageBuilder"
},
{
"name" : "Print",
"pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
"buildFunction" : "MyCommonPageBuilder"
},
{
"name" : "VPN",
"pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
"buildFunction" : "MyCommonPageBuilder"
},
{
"name" : "Private DNS",
"pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
"buildFunction" : "MyCommonPageBuilder"
},
{
"name" : "NFC",
"pageSourceFile"  : "src/main/ets/pages/PageOne.ets",
"buildFunction" : "MyCommonPageBuilder"
}
]
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170257.10537987306923689447163983613264:50001231000000:2800:AE0C107DD48814C9283966CDF52FAB0ABA13D76372D53E473A89585E2820F843.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-routing-V14
爬取时间: 2025-04-27 23:21:13
来源: Huawei Developer
页面路由指在应用程序中实现不同页面之间的跳转和数据传递。Router模块通过不同的url地址，可以方便地进行页面路由，轻松地访问不同的页面。本文将从页面跳转、页面返回、页面返回前增加一个询问框和命名路由这几个方面，介绍如何通过Router模块实现页面路由。
组件导航 (Navigation)具有更强的功能和自定义能力，推荐使用该组件作为应用的路由框架。Navigation和Router的差异可参考Router切换Navigation指导。
页面跳转
页面跳转是开发过程中的一个重要组成部分。在使用应用程序时，通常需要在不同的页面之间跳转，有时还需要将数据从一个页面传递到另一个页面。
图1页面跳转
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170258.90775899254635789012595628651821:50001231000000:2800:B04581BCC04EAAAE3E11CEF50D7313DA37555BD0A73176032A375760F533FBD6.gif)
Router模块提供了两种跳转模式，分别是router.pushUrl和router.replaceUrl。这两种模式决定了目标页面是否会替换当前页。
-  router.pushUrl：目标页面不会替换当前页，而是压入页面栈。这样可以保留当前页的状态，并且可以通过返回键或者调用router.back方法返回到当前页。
-  router.replaceUrl：目标页面会替换当前页，并销毁当前页。这样可以释放当前页的资源，并且无法返回到当前页。
-  创建新页面时，请参考构建第二个页面配置第二个页面的路由。
-  页面栈的最大容量为32个页面。如果超过这个限制，可以调用router.clear方法清空历史页面栈，释放内存空间。
同时，Router模块提供了两种实例模式，分别是Standard和Single。这两种模式决定了目标url是否会对应多个实例。
-  Standard：多实例模式，也是默认情况下的跳转模式。目标页面会被添加到页面栈顶，无论栈中是否存在相同url的页面。
-  Single：单实例模式。如果目标页面的url已经存在于页面栈中，则会将离栈顶最近的同url页面移动到栈顶，该页面成为新建页。如果目标页面的url在页面栈中不存在同url页面，则按照默认的多实例模式进行跳转。
在使用Router相关功能之前，需要在代码中先导入Router模块。
```typescript
import { promptAction, router } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
```
-  场景一：有一个主页（Home）和一个详情页（Detail），希望从主页点击一个商品，跳转到详情页。同时，需要保留主页在页面栈中，以便返回时恢复状态。这种场景下，可以使用pushUrl方法，并且使用Standard实例模式（或者省略）。 多实例模式下，router.RouterMode.Standard参数可以省略。
```typescript
import { router } from '@kit.ArkUI';
// 在Home页面中
function onJumpClick(): void {
router.pushUrl({
url: 'pages/Detail' // 目标url
}, router.RouterMode.Standard, (err) => {
if (err) {
console.error(`Invoke pushUrl failed, code is ${err.code}, message is ${err.message}`);
return;
}
console.info('Invoke pushUrl succeeded.');
});
}
```
-  场景二：有一个登录页（Login）和一个个人中心页（Profile），希望从登录页成功登录后，跳转到个人中心页。同时，销毁登录页，在返回时直接退出应用。这种场景下，可以使用replaceUrl方法，并且使用Standard实例模式（或者省略）。 多实例模式下，router.RouterMode.Standard参数可以省略。
```typescript
import { router } from '@kit.ArkUI';
// 在Login页面中
function onJumpClick(): void {
router.replaceUrl({
url: 'pages/Profile' // 目标url
}, router.RouterMode.Standard, (err) => {
if (err) {
console.error(`Invoke replaceUrl failed, code is ${err.code}, message is ${err.message}`);
return;
}
console.info('Invoke replaceUrl succeeded.');
})
}
```
-  场景三：有一个设置页（Setting）和一个主题切换页（Theme），希望从设置页点击主题选项，跳转到主题切换页。同时，需要保证每次只有一个主题切换页存在于页面栈中，在返回时直接回到设置页。这种场景下，可以使用pushUrl方法，并且使用Single实例模式。
```typescript
import { router } from '@kit.ArkUI';
// 在Setting页面中
function onJumpClick(): void {
router.pushUrl({
url: 'pages/Theme' // 目标url
}, router.RouterMode.Single, (err) => {
if (err) {
console.error(`Invoke pushUrl failed, code is ${err.code}, message is ${err.message}`);
return;
}
console.info('Invoke pushUrl succeeded.');
});
}
```
-  场景四：有一个搜索结果列表页（SearchResult）和一个搜索结果详情页（SearchDetail），希望从搜索结果列表页点击某一项结果，跳转到搜索结果详情页。同时，如果该结果已经被查看过，则不需要再新建一个详情页，而是直接跳转到已经存在的详情页。这种场景下，可以使用replaceUrl方法，并且使用Single实例模式。
```typescript
import { router } from '@kit.ArkUI';
// 在SearchResult页面中
function onJumpClick(): void {
router.replaceUrl({
url: 'pages/SearchDetail' // 目标url
}, router.RouterMode.Single, (err) => {
if (err) {
console.error(`Invoke replaceUrl failed, code is ${err.code}, message is ${err.message}`);
return;
}
console.info('Invoke replaceUrl succeeded.');
})
}
```
以上是不带参数传递的场景。
如果需要在跳转时传递一些数据给目标页面，则可以在调用Router模块的方法时，添加一个params属性，并指定一个对象作为参数。例如：
```typescript
import { router } from '@kit.ArkUI';
class DataModelInfo {
age: number = 0;
}
class DataModel {
id: number = 0;
info: DataModelInfo | null = null;
}
function onJumpClick(): void {
// 在Home页面中
let paramsInfo: DataModel = {
id: 123,
info: {
age: 20
}
};
router.pushUrl({
url: 'pages/Detail', // 目标url
params: paramsInfo // 添加params属性，传递自定义参数
}, (err) => {
if (err) {
console.error(`Invoke pushUrl failed, code is ${err.code}, message is ${err.message}`);
return;
}
console.info('Invoke pushUrl succeeded.');
})
}
```
在目标页面中，可以通过调用Router模块的getParams方法来获取传递过来的参数。例如：
```typescript
import { router } from '@kit.ArkUI';
class InfoTmp {
age: number = 0
}
class RouTmp {
id: object = () => {
}
info: InfoTmp = new InfoTmp()
}
const params: RouTmp = router.getParams() as RouTmp; // 获取传递过来的参数对象
const id: object = params.id // 获取id属性的值
const age: number = params.info.age // 获取age属性的值
```
页面返回
当用户在一个页面完成操作后，通常需要返回到上一个页面或者指定页面，这就需要用到页面返回功能。在返回的过程中，可能需要将数据传递给目标页面，这就需要用到数据传递功能。
图2页面返回
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170258.62870139564934268855290031211228:50001231000000:2800:BF64361DA80E5D917CBF978B3A9F7B399C0B743A7F30D91108A6270031A4D68C.gif)
在使用页面路由Router相关功能之前，需要在代码中先导入Router模块。
```typescript
import { router } from '@kit.ArkUI';
```
可以使用以下几种方式返回页面：
-  方式一：返回到上一个页面。 这种方式会返回到上一个页面，即上一个页面在页面栈中的位置。但是，上一个页面必须存在于页面栈中才能够返回，否则该方法将无效。
```typescript
import { router } from '@kit.ArkUI';
router.back();
```
-  方式二：返回到指定页面。 返回普通页面。 返回命名路由页面。 这种方式可以返回到指定页面，需要指定目标页面的路径。目标页面必须存在于页面栈中才能够返回。
```typescript
import { router } from '@kit.ArkUI';
router.back({
url: 'pages/Home'
});
```
-  方式三：返回到指定页面，并传递自定义参数信息。 返回到普通页面。 返回命名路由页面。 这种方式不仅可以返回到指定页面，还可以在返回的同时传递自定义参数信息。这些参数信息可以在目标页面中通过调用router.getParams方法进行获取和解析。
```typescript
import { router } from '@kit.ArkUI';
router.back({
url: 'pages/Home',
params: {
info: '来自Home页'
}
});
```
在目标页面中，在需要获取参数的位置调用router.getParams方法即可，例如在onPageShow生命周期回调中：
直接使用router可能导致实例不明确的问题，建议使用getUIContext获取UIContext实例，并使用getRouter获取绑定实例的router。
```typescript
@Entry
@Component
struct Home {
@State message: string = 'Hello World';
onPageShow() {
const params = this.getUIContext().getRouter().getParams() as Record<string, string>; // 获取传递过来的参数对象
if (params) {
const info: string = params.info as string; // 获取info属性的值
}
}
// ...
}
```
当使用router.back方法返回到指定页面时，原栈顶页面（包括）到指定页面（不包括）之间的所有页面栈都将从栈中弹出并销毁。
另外，如果使用router.back方法返回到原来的页面，原页面不会被重复创建，因此使用@State声明的变量不会重复声明，也不会触发页面的aboutToAppear生命周期回调。如果需要在原页面中使用返回页面传递的自定义参数，可以在需要的位置进行参数解析。例如，在onPageShow生命周期回调中进行参数解析。
页面返回前增加一个询问框
在开发应用时，为了避免用户误操作或者丢失数据，有时候需要在用户从一个页面返回到另一个页面之前，弹出一个询问框，让用户确认是否要执行这个操作。
本文将从系统默认询问框和自定义询问框两个方面来介绍如何实现页面返回前增加一个询问框的功能。
图3页面返回前增加一个询问框
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170258.86026010264432550270373511000113:50001231000000:2800:4ADC0DF8C5F62E6A24885815B58466977143B8E7B4759E508423CD494B288377.gif)
系统默认询问框
为了实现这个功能，可以使用页面路由Router模块提供的两个方法：router.showAlertBeforeBackPage和router.back来实现这个功能。
在使用页面路由Router相关功能之前，需要在代码中先导入Router模块。
```typescript
import { router } from '@kit.ArkUI';
```
如果想要在目标界面开启页面返回询问框，需要在调用router.back方法之前，通过调用router.showAlertBeforeBackPage方法设置返回询问框的信息。例如，在支付页面中定义一个返回按钮的点击事件处理函数：
```typescript
import { router } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
// 定义一个返回按钮的点击事件处理函数
function onBackClick(): void {
// 调用router.showAlertBeforeBackPage()方法，设置返回询问框的信息
try {
router.showAlertBeforeBackPage({
message: '您还没有完成支付，确定要返回吗？' // 设置询问框的内容
});
} catch (err) {
let message = (err as BusinessError).message
let code = (err as BusinessError).code
console.error(`Invoke showAlertBeforeBackPage failed, code is ${code}, message is ${message}`);
}
// 调用router.back()方法，返回上一个页面
router.back();
}
```
其中，router.showAlertBeforeBackPage方法接收一个对象作为参数，该对象包含以下属性：
message：string类型，表示询问框的内容。
如果调用成功，则会在目标界面开启页面返回询问框；如果调用失败，则会抛出异常，并通过err.code和err.message获取错误码和错误信息。
当用户点击“返回”按钮时，会弹出确认对话框，询问用户是否确认返回。选择“取消”将停留在当前页目标页面；选择“确认”将触发router.back方法，并根据参数决定如何执行跳转。
自定义询问框
自定义询问框的方式，可以使用弹窗promptAction.showDialog或者自定义弹窗实现。这样可以让应用界面与系统默认询问框有所区别，提高应用的用户体验度。本文以弹窗为例，介绍如何实现自定义询问框。
在使用页面路由Router相关功能之前，需要在代码中先导入Router模块。
```typescript
import { router } from '@kit.ArkUI';
```
在事件回调中，调用弹窗的promptAction.showDialog方法：
```typescript
import { promptAction, router } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
function onBackClick() {
// 弹出自定义的询问框
promptAction.showDialog({
message: '您还没有完成支付，确定要返回吗？',
buttons: [
{
text: '取消',
color: '#FF0000'
},
{
text: '确认',
color: '#0099FF'
}
]
}).then((result: promptAction.ShowDialogSuccessResponse) => {
if (result.index === 0) {
// 用户点击了“取消”按钮
console.info('User canceled the operation.');
} else if (result.index === 1) {
// 用户点击了“确认”按钮
console.info('User confirmed the operation.');
// 调用router.back()方法，返回上一个页面
router.back();
}
}).catch((err: Error) => {
let message = (err as BusinessError).message
let code = (err as BusinessError).code
console.error(`Invoke showDialog failed, code is ${code}, message is ${message}`);
})
}
```
当用户点击“返回”按钮时，会弹出自定义的询问框，询问用户是否确认返回。选择“取消”将停留在当前页目标页面；选择“确认”将触发router.back方法，并根据参数决定如何执行跳转。
命名路由
在开发中为了跳转到共享包HAR或者HSP中的页面（即共享包中路由跳转），可以使用router.pushNamedRoute来实现。
图4命名路由跳转
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170258.03944939817070550657965275025182:50001231000000:2800:9CB235688090699A0F6E44D17B44ED72D05A895CA7F895F7BBDDD49A9B22BC9B.gif)
在使用页面路由Router相关功能之前，需要在代码中先导入Router模块。
```typescript
import { router } from '@kit.ArkUI';
```
在想要跳转到的共享包HAR或者HSP页面里，给@Entry修饰的自定义组件EntryOptions命名：
```typescript
// library/src/main/ets/pages/Index.ets
// library为新建共享包自定义的名字
@Entry({ routeName: 'myPage' })
@Component
export struct MyComponent {
build() {
Row() {
Column() {
Text('Library Page')
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
.width('100%')
}
.height('100%')
}
}
```
配置成功后需要在跳转的页面中引入命名路由的页面：
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
import '@ohos/library/src/main/ets/pages/Index'; // 引入共享包中的命名路由页面
@Entry
@Component
struct Index {
build() {
Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {
Text('Hello World')
.fontSize(50)
.fontWeight(FontWeight.Bold)
.margin({ top: 20 })
.backgroundColor('#ccc')
.onClick(() => { // 点击跳转到其他共享包中的页面
try {
this.getUIContext().getRouter().pushNamedRoute({
name: 'myPage',
params: {
data1: 'message',
data2: {
data3: [123, 456, 789]
}
}
})
} catch (err) {
let message = (err as BusinessError).message
let code = (err as BusinessError).code
console.error(`pushNamedRoute failed, code is ${code}, message is ${message}`);
}
})
}
.width('100%')
.height('100%')
}
}
```
使用命名路由方式跳转时，需要在当前应用包的oh-package.json5文件中配置依赖。例如：
```typescript
"dependencies": {
"@ohos/library": "file:../library",
...
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-router-to-navigation-V14
爬取时间: 2025-04-27 23:21:27
来源: Huawei Developer
鉴于组件导航(Navigation)支持更丰富的动效、一次开发多端部署能力和更灵活的栈操作。本文主要从页面跳转、动效和生命周期等方面介绍如何从Router切换到Navigation。
页面结构
Router路由的页面是一个@Entry修饰的Component，每一个页面都需要在main_page.json中声明。
```json
// main_page.json
{
"src": [
"pages/Index",
"pages/pageOne",
"pages/pageTwo"
]
}
```
以下为Router页面的示例。
```typescript
// index.ets
import { router } from '@kit.ArkUI';
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Button('router to pageOne', { stateEffect: true, type: ButtonType.Capsule })
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
router.pushUrl({
url: 'pages/pageOne' // 目标url
}, router.RouterMode.Standard, (err) => {
if (err) {
console.error(`Invoke pushUrl failed, code is ${err.code}, message is ${err.message}`);
return;
}
console.info('Invoke pushUrl succeeded.');
})
})
}
.width('100%')
}
.height('100%')
}
}
```
```typescript
// pageOne.ets
import { router } from '@kit.ArkUI';
@Entry
@Component
struct pageOne {
@State message: string = 'This is pageOne';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Button('router back to Index', { stateEffect: true, type: ButtonType.Capsule })
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
router.back();
})
}
.width('100%')
}
.height('100%')
}
}
```
而基于Navigation的路由页面分为导航页和子页，导航页又叫Navbar，是Navigation包含的子组件，子页是NavDestination包含的子组件。
以下为Navigation导航页的示例。
```typescript
// index.ets
@Entry
@Component
struct Index {
pathStack: NavPathStack = new NavPathStack()
build() {
Navigation(this.pathStack) {
Column() {
Button('Push PageOne', { stateEffect: true, type: ButtonType.Capsule })
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
this.pathStack.pushPathByName('pageOne', null)
})
}.width('100%').height('100%')
}
.title("Navigation")
.mode(NavigationMode.Stack)
}
}
```
以下为Navigation子页的示例。
```typescript
// PageOne.ets
@Builder
export function PageOneBuilder() {
PageOne()
}
@Component
export struct PageOne {
pathStack: NavPathStack = new NavPathStack()
build() {
NavDestination() {
Column() {
Button('回到首页', { stateEffect: true, type: ButtonType.Capsule })
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
this.pathStack.clear()
})
}.width('100%').height('100%')
}.title('PageOne')
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack
})
}
}
```
每个子页也需要配置到系统配置文件route_map.json中（参考系统路由表）。
```json
// 工程配置文件module.json5中配置 {"routerMap": "$profile:route_map"}
// route_map.json
{
"routerMap": [
{
"name": "pageOne",
"pageSourceFile": "src/main/ets/pages/PageOne.ets",
"buildFunction": "PageOneBuilder",
"data": {
"description": "this is pageOne"
}
}
]
}
```
路由操作
Router通过@ohos.router模块提供的方法来操作页面，使用前需要先import。
```typescript
import { router } from '@kit.ArkUI';
// push page
router.pushUrl({ url:"pages/pageOne", params: null })
// pop page
router.back({ url: "pages/pageOne" })
// replace page
router.replaceUrl({ url: "pages/pageOne" })
// clear all page
router.clear()
// 获取页面栈大小
let size = router.getLength()
// 获取页面状态
let pageState = router.getState()
```
Navigation通过页面栈对象NavPathStack提供的方法来操作页面，需要创建一个栈对象并传入Navigation中。
```typescript
@Entry
@Component
struct Index {
pathStack: NavPathStack = new NavPathStack()
build() {
// 设置NavPathStack并传入Navigation
Navigation(this.pathStack) {
// ...
}.width('100%').height('100%')
.title("Navigation")
.mode(NavigationMode.Stack)
}
}
// push page
this.pathStack.pushPath({ name: 'pageOne' })
// pop page
this.pathStack.pop()
this.pathStack.popToIndex(1)
this.pathStack.popToName('pageOne')
// replace page
this.pathStack.replacePath({ name: 'pageOne' })
// clear all page
this.pathStack.clear()
// 获取页面栈大小
let size: number = this.pathStack.size()
// 删除栈中name为PageOne的所有页面
this.pathStack.removeByName("pageOne")
// 删除指定索引的页面
this.pathStack.removeByIndexes([1, 3, 5])
// 获取栈中所有页面name集合
this.pathStack.getAllPathName()
// 获取索引为1的页面参数
this.pathStack.getParamByIndex(1)
// 获取PageOne页面的参数
this.pathStack.getParamByName("pageOne")
// 获取PageOne页面的索引集合
this.pathStack.getIndexByName("pageOne")
// ...
```
Router作为全局通用模块，可以在任意页面中调用，Navigation作为组件，子页面想要做路由需要拿到Navigation持有的页面栈对象NavPathStack，可以通过如下几种方式获取：
方式一：通过@Provide和@Consume传递给子页面（有耦合，不推荐）。
```typescript
// Navigation根容器
@Entry
@Component
struct Index {
// Navigation创建一个Provide修饰的NavPathStack
@Provide('pathStack') pathStack: NavPathStack = new NavPathStack()
build() {
Navigation(this.pathStack) {
// ...
}
.title("Navigation")
.mode(NavigationMode.Stack)
}
}
// Navigation子页面
@Component
export struct PageOne {
// NavDestination通过Consume获取到
@Consume('pathStack') pathStack: NavPathStack;
build() {
NavDestination() {
// ...
}
.title("PageOne")
}
}
```
方式二：子页面通过OnReady回调获取。
```typescript
@Component
export struct PageOne {
pathStack: NavPathStack = new NavPathStack()
build() {
NavDestination() {
// ...
}.title('PageOne')
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack
})
}
}
```
方式三： 通过全局的AppStorage接口设置获取。
```typescript
@Entry
@Component
struct Index {
pathStack: NavPathStack = new NavPathStack()
// 全局设置一个NavPathStack
aboutToAppear(): void {
AppStorage.setOrCreate("PathStack", this.pathStack)
}
build() {
Navigation(this.pathStack) {
// ...
}.title("Navigation")
.mode(NavigationMode.Stack)
}
}
// Navigation子页面
@Component
export struct PageOne {
// 子页面中获取全局的NavPathStack
pathStack: NavPathStack = AppStorage.get("PathStack") as NavPathStack
build() {
NavDestination() {
// ...
}
.title("PageOne")
}
}
```
方式四：通过自定义组件查询接口获取，参考queryNavigationInfo。
```typescript
// 子页面中的自定义组件
@Component
struct CustomNode {
pathStack: NavPathStack = new NavPathStack()
aboutToAppear() {
// query navigation info
let navigationInfo: NavigationInfo = this.queryNavigationInfo() as NavigationInfo
this.pathStack = navigationInfo.pathStack;
}
build() {
Row() {
Button('跳转到PageTwo')
.onClick(() => {
this.pathStack.pushPath({ name: 'pageTwo' })
})
}
}
}
```
生命周期
Router页面生命周期为@Entry页面中的通用方法，主要有如下四个生命周期：
```typescript
// 页面创建后挂树的回调
aboutToAppear(): void {
}
// 页面销毁前下树的回调
aboutToDisappear(): void {
}
// 页面显示时的回调
onPageShow(): void {
}
// 页面隐藏时的回调
onPageHide(): void {
}
```
其生命周期时序如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170258.42842496083769645035442750748511:50001231000000:2800:782BEA98D1C3AF74B36792043D28AEAEC5B3D652F8CD9D9243059A40B8E73FE2.png)
Navigation作为路由容器，其生命周期承载在NavDestination组件上，以组件事件的形式开放。
具体生命周期描述请参考Navigation页面生命周期。
```typescript
@Component
struct PageOne {
aboutToDisappear() {
}
aboutToAppear() {
}
build() {
NavDestination() {
// ...
}
.onWillAppear(() => {
})
.onAppear(() => {
})
.onWillShow(() => {
})
.onShown(() => {
})
.onWillHide(() => {
})
.onHidden(() => {
})
.onWillDisappear(() => {
})
.onDisAppear(() => {
})
}
}
```
转场动画
Router和Navigation都提供了系统的转场动画也提供了自定义转场的能力。
其中Router自定义页面转场通过通用方法pageTransition()实现，具体可参考Router页面转场动画。
Navigation作为路由容器组件，其内部的页面切换动画本质上属于组件跟组件之间的属性动画，可以通过Navigation中的customNavContentTransition事件提供自定义转场动画的能力，具体实现可以参考Navigation自定义转场。（注意：Dialog类型的页面当前没有转场动画）
共享元素转场
页面和页面之间跳转的时候需要进行共享元素过渡动画，Router可以通过通用属性sharedTransition来实现共享元素转场，具体可以参考如下链接：
Router共享元素转场动画。
Navigation也提供了共享元素一镜到底的转场能力，需要配合geometryTransition属性，在子页面（NavDestination）之间切换时，可以实现共享元素转场，具体可参考Navigation共享元素转场动画。
跨包路由
Router可以通过命名路由的方式实现跨包跳转。
1.  在想要跳转到的共享包HAR或者HSP页面里，给@Entry修饰的自定义组件EntryOptions命名。
```typescript
// library/src/main/ets/pages/Index.ets
// library为新建共享包自定义的名字
@Entry({ routeName: 'myPage' })
@Component
export struct MyComponent {
build() {
Row() {
Column() {
Text('Library Page')
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
.width('100%')
}
.height('100%')
}
}
```
2.  配置成功后需要在跳转的页面中引入命名路由的页面并跳转。
```typescript
import { router } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
import('library/src/main/ets/pages/Index');  // 引入共享包中的命名路由页面
@Entry
@Component
struct Index {
build() {
Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {
Text('Hello World')
.fontSize(50)
.fontWeight(FontWeight.Bold)
.margin({ top: 20 })
.backgroundColor('#ccc')
.onClick(() => { // 点击跳转到其他共享包中的页面
try {
router.pushNamedRoute({
name: 'myPage',
params: {
data1: 'message',
data2: {
data3: [123, 456, 789]
}
}
})
} catch (err) {
let message = (err as BusinessError).message
let code = (err as BusinessError).code
console.error(`pushNamedRoute failed, code is ${code}, message is ${message}`);
}
})
}
.width('100%')
.height('100%')
}
}
```
Navigation作为路由组件，默认支持跨包跳转。
1.  从HSP（HAR）中完成自定义组件（需要跳转的目标页面）开发，将自定义组件申明为export。
```typescript
@Component
export struct PageInHSP {
build() {
NavDestination() {
// ...
}
}
}
```
2.  在HSP（HAR）的index.ets中导出组件。
```typescript
export { PageInHSP } from "./src/main/ets/pages/PageInHSP"
```
3.  配置好HSP（HAR）的项目依赖后，在mainPage中导入自定义组件，并添加到pageMap中，即可正常调用。
```typescript
// 1.导入跨包的路由页面
import { PageInHSP } from 'library/src/main/ets/pages/PageInHSP'
@Entry
@Component
struct mainPage {
pageStack: NavPathStack = new NavPathStack()
@Builder pageMap(name: string) {
if (name === 'PageInHSP') {
// 2.定义路由映射表
PageInHSP()
}
}
build() {
Navigation(this.pageStack) {
Button("Push HSP Page")
.onClick(() => {
// 3.跳转到Hsp中的页面
this.pageStack.pushPath({ name: "PageInHSP" });
})
}
.mode(NavigationMode.Stack)
.navDestination(this.pageMap)
}
}
```
以上是通过静态依赖的形式完成了跨包的路由，在大型的项目中一般跨模块的开发需要解耦，那就需要依赖动态路由的能力。
动态路由
动态路由设计的目的是解决多个产品（Hap）之间可以复用相同的业务模块，各个业务模块之间解耦（模块之间跳转通过路由表跳转，不需要互相依赖）和路由功能扩展整合。
业务特性模块对外暴露的就是模块内支持完成具体业务场景的多个页面的集合；路由管理就是将每个模块支持的页面都用统一的路由表结构管理起来。 当产品需要某个业务模块时，就会注册对应的模块的路由表。
动态路由的优势：
Router实现动态路由主要有下面三个过程：
1.  定义过程： 路由表定义新增路由 -> 页面文件绑定路由名称（装饰器） -> 加载函数和页面文件绑定（动态import函数）
2.  定义注册过程： 路由注册（可在入口ability中按需注入依赖模块的路由表）。
Navigation实现动态路由有如下两种实现方案：
方案一：自定义路由表
基本实现跟上述Router动态路由类似。
具体的构建过程，可以参考Navigation自动生成动态路由示例。
方案二：系统路由表
从API version 12版本开始，Navigation支持系统跨模块的路由表方案，整体设计是将路由表方案下沉到系统中管理，即在需要路由的各个业务模块（HSP/HAR）中独立配置router_map.json文件，在触发路由跳转时，应用只需要通过NavPathStack进行路由跳转，此时系统会自动完成路由模块的动态加载、组件构建，并完成路由跳转功能，从而实现了开发层面的模块解耦。
具体可参考Navigation系统路由表。
生命周期监听
Router可以通过observer实现注册监听，接口定义请参考Router无感监听observer.on('routerPageUpdate')。
```typescript
import { uiObserver } from '@kit.ArkUI';
function callBackFunc(info: uiObserver.RouterPageInfo) {
console.info("RouterPageInfo is : " + JSON.stringify(info))
}
// used in ability context.
uiObserver.on('routerPageUpdate', this.context, callBackFunc);
// used in UIContext.
uiObserver.on('routerPageUpdate', this.getUIContext(), callBackFunc);
```
在页面状态发生变化时，注册的回调将会触发，开发者可以通过回调中传入的入参拿到页面的相关信息，如：页面的名字，索引，路径，生命周期状态等。
Navigation同样可以通过在observer中实现注册监听。
```typescript
// EntryAbility.ets
import { BusinessError } from '@kit.BasicServicesKit';
import { UIObserver } from '@kit.ArkUI';
export default class EntryAbility extends UIAbility {
// ...
onWindowStageCreate(windowStage: window.WindowStage): void {
// ...
windowStage.getMainWindow((err: BusinessError, data) => {
// ...
let windowClass = data;
// 获取UIContext实例。
let uiContext: UIContext = windowClass.getUIContext();
// 获取UIObserver实例。
let uiObserver : UIObserver = uiContext.getUIObserver();
// 注册DevNavigation的状态监听.
uiObserver.on("navDestinationUpdate",(info) => {
// NavDestinationState.ON_SHOWN = 0, NavDestinationState.ON_HIDE = 1
if (info.state == 0) {
// NavDestination组件显示时操作
console.info('page ON_SHOWN:' + info.name.toString());
}
})
})
}
}
```
页面信息查询
为了实现页面内自定义组件跟页面解耦，自定义组件中提供了全局查询页面信息的接口。
Router可以通过queryRouterPageInfo接口查询当前自定义组件所在的Page页面的信息，其返回值包含如下几个属性，其中pageId是页面的唯一标识符：
| 名称 | 类型 | 必填 | 说明 |
| --- | --- | --- | --- |
| context | UIAbilityContext/ UIContext | 是 | routerPage页面对应的上下文信息 |
| index | number | 是 | routerPage在栈中的位置。 |
| name | string | 是 | routerPage页面的名称。 |
| path | string | 是 | routerPage页面的路径。 |
| state | RouterPageState | 是 | routerPage页面的状态 |
| pageId12+ | string | 是 | routerPage页面的唯一标识 |
```typescript
import { uiObserver } from '@kit.ArkUI';
// 页面内的自定义组件
@Component
struct MyComponent {
aboutToAppear() {
let info: uiObserver.RouterPageInfo | undefined = this.queryRouterPageInfo();
}
build() {
// ...
}
}
```
Navigation也可以通过queryNavDestinationInfo接口查询当前自定义组件所在的NavDestination的信息，其返回值包含如下几个属性，其中navDestinationId是页面的唯一标识符：
| 名称 | 类型 | 必填 | 说明 |
| --- | --- | --- | --- |
| navigationId | ResourceStr | 是 | 包含NavDestination组件的Navigation组件的id。 |
| name | ResourceStr | 是 | NavDestination组件的名称。 |
| state | NavDestinationState | 是 | NavDestination组件的状态。 |
| index12+ | number | 是 | NavDestination在页面栈中的索引。 |
| param12+ | Object | 否 | NavDestination组件的参数。 |
| navDestinationId12+ | string | 是 | NavDestination组件的唯一标识ID。 |
```typescript
import { uiObserver } from '@kit.ArkUI';
@Component
export struct NavDestinationExample {
build() {
NavDestination() {
MyComponent()
}
}
}
@Component
struct MyComponent {
navDesInfo: uiObserver.NavDestinationInfo | undefined
aboutToAppear() {
this.navDesInfo = this.queryNavDestinationInfo();
console.log('get navDestinationInfo: ' + JSON.stringify(this.navDesInfo))
}
build() {
// ...
}
}
```
路由拦截
Router原生没有提供路由拦截的能力，开发者需要自行封装路由跳转接口，并在自己封装的接口中做路由拦截的判断并重定向路由。
Navigation提供了setInterception方法，用于设置Navigation页面跳转拦截回调。具体可以参考文档：Navigation路由拦截

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-use-text-V14
爬取时间: 2025-04-27 23:21:41
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-text-introduction-V14
爬取时间: 2025-04-27 23:21:54
来源: Huawei Developer
文本通常涵盖用户输入的信息、呈现的文本内容以及小图标，这些元素共同构建了用户与系统间的交互界面，提升了操作的便捷性与信息展示的直观性。
开发者可根据实际应用场景选择合适的文本组件进行页面开发。
| 文本组件名称 | 应用场景 |
| --- | --- |
| 文本（Text/Span） | 主要用于显示静态文本。开发者可以使用Text组件配合Span组件创建文本节点，也可以使用属性字符串（StyledString/MutableStyledString）节点生成文本信息并接入Text组件。 |
| 文本输入（TextInput/TextArea） | 当需要在单行输入框（TextInput）或多行输入框（TextArea）输入纯文本时，应优先考虑使用此文本组件。 |
| 富文本（RichEditor） | 当需要在编辑框内插入图片或者自定义图标等述求时，应优先考虑使用此文本组件。 |
| 图标小符号（SymbolGlyph/SymbolSpan） | 当需要显示小图标时，应优先考虑使用此文本组件。 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-components-text-display-V14
爬取时间: 2025-04-27 23:22:08
来源: Huawei Developer
Text是文本组件，通常用于展示用户视图，如显示文章的文字内容。Span则用于呈现显示行内文本。
具体用法请参考Text和Span组件的使用说明。
创建文本
Text可通过以下两种方式来创建：
-  string字符串。
```typescript
Text('我是一段文本')
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.77857945651825662646350826605682:50001231000000:2800:FD146615854B7999910C23E9B736B8D8CD9189E30FB90E54084F5766FB0AA9D8.png)
-  引用Resource资源。 资源引用类型可以通过$r创建Resource类型对象，文件位置为/resources/base/element/string.json。
```typescript
Text($r('app.string.module_desc'))
.baselineOffset(0)
.fontSize(30)
.border({ width: 1 })
.padding(10)
.width(300)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.05912932925730172359712633790942:50001231000000:2800:83294164FF4FD2FE2DEBA69F11A2DD70FB47B8DD2E0D9A156F640A4ED79AF086.png)
添加子组件
Span只能作为Text和RichEditor组件的子组件显示文本内容。可以在一个Text内添加多个Span来显示一段信息，例如产品说明书、承诺书等。
-  创建Span。 Span组件必须嵌入在Text组件中才能显示，单独的Span组件不会呈现任何内容。Text与Span同时配置文本内容时，Span内容覆盖Text内容。
```typescript
Text('我是Text') {
Span('我是Span')
}
.padding(10)
.borderWidth(1)
```
-  设置文本装饰线及颜色。 通过decoration设置文本装饰线及颜色。
```typescript
Text() {
Span('我是Span1，').fontSize(16).fontColor(Color.Grey)
.decoration({ type: TextDecorationType.LineThrough, color: Color.Red })
Span('我是Span2').fontColor(Color.Blue).fontSize(16)
.fontStyle(FontStyle.Italic)
.decoration({ type: TextDecorationType.Underline, color: Color.Black })
Span('，我是Span3').fontSize(16).fontColor(Color.Grey)
.decoration({ type: TextDecorationType.Overline, color: Color.Green })
}
.borderWidth(1)
.padding(10)
```
-  通过textCase设置文字一直保持大写或者小写状态。
```typescript
Text() {
Span('I am Upper-span').fontSize(12)
.textCase(TextCase.UpperCase)
}
.borderWidth(1)
.padding(10)
```
-  添加事件。 由于Span组件无尺寸信息，事件仅支持添加点击事件onClick。
```typescript
Text() {
Span('I am Upper-span').fontSize(12)
.textCase(TextCase.UpperCase)
.onClick(() => {
console.info('我是Span——onClick');
})
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.53938228145915495909787760390616:50001231000000:2800:23C375F16999ED7D75D48805F87DEFBC48285FA2EEDB6852E5222D3329AF639E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.99995453653179546360570888578755:50001231000000:2800:11F5508B1521D2EA6F883ADAE60921EDD595B135D30FCB6093DAB9CE2442C6CC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.52420580725775778319332896088502:50001231000000:2800:7A2F2DD3A45D5D0A5E29DD5A2B6E59A1EAA7DB60B9976D28C055D4392BD90F95.png)
自定义文本样式
-  通过textAlign属性设置文本对齐样式。
```typescript
Text('左对齐')
.width(300)
.textAlign(TextAlign.Start)
.border({ width: 1 })
.padding(10)
Text('中间对齐')
.width(300)
.textAlign(TextAlign.Center)
.border({ width: 1 })
.padding(10)
Text('右对齐')
.width(300)
.textAlign(TextAlign.End)
.border({ width: 1 })
.padding(10)
```
-  通过textOverflow属性控制文本超长处理，textOverflow需配合maxLines一起使用（默认情况下文本自动折行）。
```typescript
Text('This is the setting of textOverflow to Clip text content This is the setting of textOverflow to None text content. This is the setting of textOverflow to Clip text content This is the setting of textOverflow to None text content.')
.width(250)
.textOverflow({ overflow: TextOverflow.None })
.maxLines(1)
.fontSize(12)
.border({ width: 1 })
.padding(10)
Text('我是超长文本，超出的部分显示省略号。I am an extra long text, with ellipses displayed for any excess。')
.width(250)
.textOverflow({ overflow: TextOverflow.Ellipsis })
.maxLines(1)
.fontSize(12)
.border({ width: 1 })
.padding(10)
Text('当文本溢出其尺寸时，文本将滚动显示。When the text overflows its dimensions, the text will scroll for displaying.')
.width(250)
.textOverflow({ overflow: TextOverflow.MARQUEE })
.maxLines(1)
.fontSize(12)
.border({ width: 1 })
.padding(10)
```
-  通过lineHeight属性设置文本行高。
```typescript
Text('This is the text with the line height set. This is the text with the line height set.')
.width(300).fontSize(12).border({ width: 1 }).padding(10)
Text('This is the text with the line height set. This is the text with the line height set.')
.width(300).fontSize(12).border({ width: 1 }).padding(10)
.lineHeight(20)
```
-  通过decoration属性设置文本装饰线样式及其颜色。
```typescript
Text('This is the text')
.decoration({
type: TextDecorationType.LineThrough,
color: Color.Red
})
.borderWidth(1).padding(10).margin(5)
Text('This is the text')
.decoration({
type: TextDecorationType.Overline,
color: Color.Red
})
.borderWidth(1).padding(10).margin(5)
Text('This is the text')
.decoration({
type: TextDecorationType.Underline,
color: Color.Red
})
.borderWidth(1).padding(10).margin(5)
```
-  通过baselineOffset属性设置文本基线的偏移量。
```typescript
Text('This is the text content with baselineOffset 0.')
.baselineOffset(0)
.fontSize(12)
.border({ width: 1 })
.padding(10)
.width('100%')
.margin(5)
Text('This is the text content with baselineOffset 30.')
.baselineOffset(30)
.fontSize(12)
.border({ width: 1 })
.padding(10)
.width('100%')
.margin(5)
Text('This is the text content with baselineOffset -20.')
.baselineOffset(-20)
.fontSize(12)
.border({ width: 1 })
.padding(10)
.width('100%')
.margin(5)
```
-  通过letterSpacing属性设置文本字符间距。
```typescript
Text('This is the text content with letterSpacing 0.')
.letterSpacing(0)
.fontSize(12)
.border({ width: 1 })
.padding(10)
.width('100%')
.margin(5)
Text('This is the text content with letterSpacing 3.')
.letterSpacing(3)
.fontSize(12)
.border({ width: 1 })
.padding(10)
.width('100%')
.margin(5)
Text('This is the text content with letterSpacing -1.')
.letterSpacing(-1)
.fontSize(12)
.border({ width: 1 })
.padding(10)
.width('100%')
.margin(5)
```
-  通过minFontSize与maxFontSize自适应字体大小。 minFontSize用于设置文本的最小显示字号，maxFontSize用于设置文本的最大显示字号。这两个属性必须同时设置才能生效，并且需要与maxLines属性或布局大小限制配合使用，单独设置任一属性将不会产生效果。
```typescript
Text('我的最大字号为30，最小字号为5，宽度为250，maxLines为1')
.width(250)
.maxLines(1)
.maxFontSize(30)
.minFontSize(5)
.border({ width: 1 })
.padding(10)
.margin(5)
Text('我的最大字号为30，最小字号为5，宽度为250，maxLines为2')
.width(250)
.maxLines(2)
.maxFontSize(30)
.minFontSize(5)
.border({ width: 1 })
.padding(10)
.margin(5)
Text('我的最大字号为30，最小字号为15，宽度为250,高度为50')
.width(250)
.height(50)
.maxFontSize(30)
.minFontSize(15)
.border({ width: 1 })
.padding(10)
.margin(5)
Text('我的最大字号为30，最小字号为15，宽度为250,高度为100')
.width(250)
.height(100)
.maxFontSize(30)
.minFontSize(15)
.border({ width: 1 })
.padding(10)
.margin(5)
```
-  通过textCase属性设置文本大小写。
```typescript
Text('This is the text content with textCase set to Normal.')
.textCase(TextCase.Normal)
.padding(10)
.border({ width: 1 })
.padding(10)
.margin(5)
// 文本全小写展示
Text('This is the text content with textCase set to LowerCase.')
.textCase(TextCase.LowerCase)
.border({ width: 1 })
.padding(10)
.margin(5)
// 文本全大写展示
Text('This is the text content with textCase set to UpperCase.')
.textCase(TextCase.UpperCase)
.border({ width: 1 })
.padding(10)
.margin(5)
```
-  通过copyOption属性设置文本是否可复制粘贴。
```typescript
Text("这是一段可复制文本")
.fontSize(30)
.copyOption(CopyOptions.InApp)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.18043519752497267185304484461549:50001231000000:2800:0824E964CE8376E229F391B2814745845DCD49EAC34CC66639300A73505F5668.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.94578385241309304195517882433534:50001231000000:2800:46171F5E771B9B1FE0D08E7953A8F9459E7D86D44AC815B0E987659A5C6A95FB.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.53445943500801835406995169655656:50001231000000:2800:DC83816CEF0E37005C33CDB39C1A3DBB12F0902AC253B351E0D4509EFF488AF5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.74465885397815500182134398924712:50001231000000:2800:DA6D52B6015326E577AD5E2D83E9D3675A0D9ACEE27DBCEAD0D5F7B2A63C8173.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.18158039074150705602009116006327:50001231000000:2800:56280305AB64A6D430ECAB0AD49356BAC7862C6386885AC98DBFE8EC49B323FA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.91680056714538647660268752649199:50001231000000:2800:431F3B007D8C9D464B5DA181DA3948E8B165DF5585766DDF59285A7C7AF4DE8A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.00590379526861766195293485468776:50001231000000:2800:F27A09D064F643C4F489F65328E27A823E0803DD09D42044DA7147D804170708.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.20737344530629212528073267376441:50001231000000:2800:1B3687AD4E6E3BF599D5ACE28BDF1DD3B041471F951F5C5035EAC1228F2D3374.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.96842118703817118704709416327673:50001231000000:2800:F9AF5868F84C4EE8186625986EB37EF604832F56960559F13187AF787F630879.png)
添加事件
Text组件可以添加通用事件，可以绑定onClick、onTouch等事件来响应操作。
```typescript
Text('点我')
.onClick(() => {
console.info('我是Text的点击响应事件');
})
```
场景示例
该示例通过maxLines、textOverflow、textAlign、constraintSize属性展示了热搜榜的效果。
```typescript
// xxx.ets
@Entry
@Component
struct TextExample {
build() {
Column() {
Row() {
Text("1").fontSize(14).fontColor(Color.Red).margin({ left: 10, right: 10 })
Text("我是热搜词条1")
.fontSize(12)
.fontColor(Color.Blue)
.maxLines(1)
.textOverflow({ overflow: TextOverflow.Ellipsis })
.fontWeight(300)
Text("爆")
.margin({ left: 6 })
.textAlign(TextAlign.Center)
.fontSize(10)
.fontColor(Color.White)
.fontWeight(600)
.backgroundColor(0x770100)
.borderRadius(5)
.width(15)
.height(14)
}.width('100%').margin(5)
Row() {
Text("2").fontSize(14).fontColor(Color.Red).margin({ left: 10, right: 10 })
Text("我是热搜词条2 我是热搜词条2 我是热搜词条2 我是热搜词条2 我是热搜词条2")
.fontSize(12)
.fontColor(Color.Blue)
.fontWeight(300)
.constraintSize({ maxWidth: 200 })
.maxLines(1)
.textOverflow({ overflow: TextOverflow.Ellipsis })
Text("热")
.margin({ left: 6 })
.textAlign(TextAlign.Center)
.fontSize(10)
.fontColor(Color.White)
.fontWeight(600)
.backgroundColor(0xCC5500)
.borderRadius(5)
.width(15)
.height(14)
}.width('100%').margin(5)
Row() {
Text("3").fontSize(14).fontColor(Color.Orange).margin({ left: 10, right: 10 })
Text("我是热搜词条3")
.fontSize(12)
.fontColor(Color.Blue)
.fontWeight(300)
.maxLines(1)
.constraintSize({ maxWidth: 200 })
.textOverflow({ overflow: TextOverflow.Ellipsis })
Text("热")
.margin({ left: 6 })
.textAlign(TextAlign.Center)
.fontSize(10)
.fontColor(Color.White)
.fontWeight(600)
.backgroundColor(0xCC5500)
.borderRadius(5)
.width(15)
.height(14)
}.width('100%').margin(5)
Row() {
Text("4").fontSize(14).fontColor(Color.Grey).margin({ left: 10, right: 10 })
Text("我是热搜词条4 我是热搜词条4 我是热搜词条4 我是热搜词条4 我是热搜词条4")
.fontSize(12)
.fontColor(Color.Blue)
.fontWeight(300)
.constraintSize({ maxWidth: 200 })
.maxLines(1)
.textOverflow({ overflow: TextOverflow.Ellipsis })
}.width('100%').margin(5)
}.width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170259.96851938279456735929252430329919:50001231000000:2800:6F44B7E914327C3F64BF6E9CCE910851BCB8E81A73C77D1C9FD5B6EC8AD93FFD.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-components-text-input-V14
爬取时间: 2025-04-27 23:22:22
来源: Huawei Developer
TextInput、TextArea是输入框组件，通常用于响应用户的输入操作，比如评论区的输入、聊天框的输入、表格的输入等，也可以结合其它组件构建功能页面，例如登录注册页面。具体用法请参考TextInput、TextArea。
创建输入框
TextInput为单行输入框、TextArea为多行输入框。通过以下接口来创建。
```typescript
TextInput(value?:{placeholder?: ResourceStr, text?: ResourceStr, controller?: TextInputController})
```
```typescript
TextArea(value?:{placeholder?: ResourceStr, text?: ResourceStr, controller?: TextAreaController})
```
-  单行输入框
```typescript
TextInput()
```
-  多行输入框 多行输入框文字超出一行时会自动折行。
```typescript
TextArea()
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.62577508484301667491062986759471:50001231000000:2800:7329BA67ACD990627C2BD26820188D95EB7D8826975D309D4007F67B26F51E7D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.76891379255301963595056362831222:50001231000000:2800:B26C6BB532DC1BBE86608764297665BBF93F7FB817C6CE6A8D2DBB7C0D8D0203.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.83845714417072573740064303029110:50001231000000:2800:BDAC357030884957B1F039EAAEB8F06150C2C068FCB43684400633341F51E06D.png)
设置输入框类型
TextInput有以下类型可选择：Normal基本输入模式、Password密码输入模式、Email邮箱地址输入模式、Number纯数字输入模式、PhoneNumber电话号码输入模式、USER_NAME用户名输入模式、NEW_PASSWORD新密码输入模式、NUMBER_PASSWORD纯数字密码输入模式、NUMBER_DECIMAL带小数点的数字输入模式、带URL的输入模式。通过type属性进行设置：
-  基本输入模式（默认类型）
```typescript
TextInput()
.type(InputType.Normal)
```
-  密码输入模式
```typescript
TextInput()
.type(InputType.Password)
```
-  邮箱地址输入模式
```typescript
TextInput()
.type(InputType.Email)
```
-  纯数字输入模式
```typescript
TextInput()
.type(InputType.Number)
```
-  电话号码输入模式
```typescript
TextInput()
.type(InputType.PhoneNumber)
```
-  带小数点的数字输入模式
```typescript
TextInput()
.type(InputType.NUMBER_DECIMAL)
```
-  带URL的输入模式
```typescript
TextInput()
.type(InputType.URL)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.17648270598186917010843029845044:50001231000000:2800:591CA603D4FB5124303AF4C733D1A113F9052C39B9CC77D6A8B79A4E9209765F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.55625674812597904472792099541180:50001231000000:2800:E4400EFF0015C7EFE04DB304B25384848D00B002D888F08FAD6A1B78DEC647DA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.66607911743592152849210965537278:50001231000000:2800:8F436A810D755E966E55D2BDE8EB58F20F1234B5A9CAE6B4DFA754FC6076836F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.01979664146694937883899242858101:50001231000000:2800:EF7D2EEE4BC49B0888AE86E11D50AFDA265967E2D41A8ECF671093C5483F98DD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.74356532550801094173994930610107:50001231000000:2800:3061B30AF07F1F5A6D9B750F0E0B6086D9E5BDD470F7DFDD0E151583E5F02F33.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.77627663377296632017047286259257:50001231000000:2800:19747FC670C4E4A94855880AC736B322483FF67669946F160628CFC535BE2CC7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.31267417235564959005971920338202:50001231000000:2800:3928B4861609B87D38811D30CC9F28FFDA26D8E2D1D3E0EA190072497E6FE100.png)
自定义样式
-  设置无输入时的提示文本。
```typescript
TextInput({ placeholder: '我是提示文本' })
```
-  设置输入框当前的文本内容。
```typescript
TextInput({ placeholder: '我是提示文本', text: '我是当前文本内容' })
```
-  添加backgroundColor改变输入框的背景颜色。 更丰富的样式可以结合通用属性实现。
```typescript
TextInput({ placeholder: '我是提示文本', text: '我是当前文本内容' })
.backgroundColor(Color.Pink)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.22438117378335605847378075585907:50001231000000:2800:5699D81253D2D94941B2A0D6659DC36E970C2D3E758668D99F84CB8430561F06.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.76156705741180006260014366399906:50001231000000:2800:007A1C7F8B812A3C4D96C79E6C0450A8D5EFBE55A0874F4BF92CA87AE4E916A2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.57067873804012072573897862710873:50001231000000:2800:99698930DD1E85E02ABF8B7C30736DE3CE4CF45E4939264203F487299E9D76C4.png)
添加事件
文本框主要用于获取用户输入的信息，把信息处理成数据进行上传，绑定onChange事件可以获取输入框内改变的内容。用户也可以使用通用事件来进行相应的交互操作。
```typescript
TextInput()
.onChange((value: string) => {
console.info(value);
})
.onFocus(() => {
console.info('获取焦点');
})
```
场景示例
在登录/注册页面，用户进行登录或注册。
```typescript
@Entry
@Component
struct TextInputSample {
build() {
Column() {
TextInput({ placeholder: 'input your username' }).margin({ top: 20 })
.onSubmit((EnterKeyType) => {
console.info(EnterKeyType + '输入法回车键的类型值');
})
TextInput({ placeholder: 'input your password' }).type(InputType.Password).margin({ top: 20 })
.onSubmit((EnterKeyType) => {
console.info(EnterKeyType + '输入法回车键的类型值');
})
Button('Sign in').width(150).margin({ top: 20 })
}.padding(20)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.33422539602896532228899434270589:50001231000000:2800:8D8101E46347B0E8BBFE3D1D010A68C1D3CA8E0E995BD15F61F64C7232DCC8E6.gif)
键盘避让
键盘抬起后，具有滚动能力的容器组件在横竖屏切换时，才会生效键盘避让，若希望无滚动能力的容器组件也生效键盘避让，建议在组件外嵌套一层具有滚动能力的容器组件，比如Scroll、List、Grid。
```typescript
// xxx.ets
@Entry
@Component
struct Index {
placeHolderArr: string[] = ['1', '2', '3', '4', '5', '6', '7'];
build() {
Scroll() {
Column() {
ForEach(this.placeHolderArr, (placeholder: string) => {
TextInput({ placeholder: 'TextInput ' + placeholder })
.margin(30)
})
}
}
.height('100%')
.width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.33052775619582651717814425372673:50001231000000:2800:DCB179C471A70812DBB07BF7CD0F1DDEC45E855CA9D23951F485B3F4719D4F66.gif)
光标避让
keyBoardAvoidMode枚举中的OFFSET和RESIZE在键盘抬起后，不支持二次避让。如果想要支持光标位置在点击或者通过接口设置变化后发生二次避让，可以考虑使用OFFSET_WITH_CARET和RESIZE_CARET替换原有的OFFSET和RESIZE模式。
对于滚动容器更推荐使用RESIZE_WITH_CARET，非滚动容器应该使用OFFSET_WITH_CARET。
```typescript
// EntryAbility.ets
import { KeyboardAvoidMode } from '@kit.ArkUI';
// Used in UIAbility
onWindowStageCreate(windowStage: window.WindowStage) {
// Main window is created, set main page for this ability
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
windowStage.loadContent('pages/Index', (err, data) => {
let keyboardAvoidMode = windowStage.getMainWindowSync().getUIContext().getKeyboardAvoidMode();
windowStage.getMainWindowSync().getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.OFFSET_WITH_CARET);
if (err.code) {
hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
return;
}
hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
});
}
```
```typescript
// xxx.ets
@Entry
@Component
struct Index {
@State caretPosition: number = 600;
areaController: TextAreaController = new TextAreaController();
text = "Most of us compare ourselves with anyone we think is happier — a relative, someone we know a lot, or someone we hardly know. As a result, what we do remember is anything that makes others happy, anything that makes ourselves unhappy, totally forgetting that there is something happy in our own life.\
So the best way to destroy happiness is to look at something and focus on even the smallest flaw. It is the smallest flaw that would make us complain. And it is the complaint that leads to us becoming unhappy.\
If one chooses to be happy, he will be blessed; if he chooses to be unhappy, he will be cursed. Happiness is just what you think will make you happy.Most of us compare ourselves with anyone we think is happier — a relative, someone we know a lot, or someone we hardly know. As a result, what we do remember is anything that makes others happy, anything that makes ourselves unhappy, totally forgetting that there is something happy in our own life.\
So the best way to destroy happiness is to look at something and focus on even the smallest flaw. It is the smallest flaw that would make us complain. And it is the complaint that leads to us becoming unhappy.\
If one chooses to be happy, he will be blessed; if he chooses to be unhappy, he will be cursed. Happiness is just what you think will make you happy.Most of us compare ourselves with anyone we think is happier — a relative, someone we know a lot, or someone we hardly know. As a result, what we do remember is anything that makes others happy, anything that makes ourselves unhappy, totally forgetting that there is something happy in our own life.\
So the best way to destroy happiness is to look at something and focus on even the smallest flaw. It is the smallest flaw that would make us complain. And it is the complaint that leads to us becoming unhappy.\
If one chooses to be happy, he will be blessed; if he chooses to be unhappy, he will be cursed. Happiness is just what you think will make you happy.Most of us compare ourselves with anyone we think is happier — a relative, someone we know a lot, or someone we hardly know. As a result, what we do remember is anything that makes others happy, anything that makes ourselves unhappy, totally forgetting that there is something happy in our own life.\
So the best way to destroy happiness is to look at something and focus on even the smallest flaw. It is the smallest flaw that would make us complain. And it is the complaint that leads to us becoming unhappy.\
If one chooses to be happy, he will be blessed; if he chooses to be unhappy, he will be cursed. Happiness is just what you think will make you happy.Most of us compare ourselves with anyone we think is happier — a relative, someone we know a lot, or someone we hardly know. As a result, what we do remember is anything that makes others happy, anything that makes ourselves unhappy, totally forgetting that there is something happy in our own life.\
";
build() {
Scroll() {
Column() {
Row() {
Button('CaretPostiion++: ' + this.caretPosition).onClick(() => {
this.caretPosition += 1;
}).fontSize(10)
Button('CaretPostiion--: ' + this.caretPosition).onClick(() => {
this.caretPosition -= 1;
}).fontSize(10)
Button('SetCaretPostion: ').onClick(() => {
this.areaController.caretPosition(this.caretPosition);
}).fontSize(10)
}
TextArea({ text: this.text, controller: this.areaController })
.width('100%')
.fontSize('20fp')
}
}.width('100%').height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170300.79190331176532798176813876028770:50001231000000:2800:69C7113BBCD982B1F35C21DD60A930B208A1636606A5E17E420CBF1664C42B35.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-components-richeditor-V14
爬取时间: 2025-04-27 23:22:36
来源: Huawei Developer
RichEditor是支持图文混排和文本交互式编辑的组件，通常用于响应用户对图文混合内容的输入操作，例如可以输入图文的评论区。具体用法参考RichEditor。
创建RichEditor组件
开发者可以创建不使用属性字符串和使用属性字符串构建的RichEditor组件。
创建不使用属性字符串构建的RichEditor组件
使用RichEditor(value:RichEditorOptions)接口创建非属性字符串构建的RichEditor组件，一般用于展示简单的图文信息，例如展示联系人的信息，也可以用于内容要求格式统一的场景，例如一些代码编辑器。
```typescript
@Entry
@Component
struct create_rich_editor {
controller: RichEditorController = new RichEditorController()
options: RichEditorOptions = { controller: this.controller }
build() {
Column() {
Column() {
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('创建不使用属性字符串构建的RichEditor组件。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
}.width('100%')
}.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170301.87565913406181333792388831406955:50001231000000:2800:C1839D16F58AE34ED7BA5E546FCA95CB94D8E3B461FA017D00EC45BFE12AF939.gif)
创建使用属性字符串构建的RichEditor组件
使用RichEditor(options:RichEditorStyledStringOptions)接口创建属性字符串构建的RichEditor组件，是基于属性字符串（StyledString/MutableStyledString）构建的，通常应用于需要界面美化和内容强调的场景，通过设置重要功能特性文本的样式来突出显示，从而吸引用户注意。
相较于不使用属性字符串构建的RichEditor组件，此种方式提供了多种文本修改方式，包括调整字号、添加字体颜色、使文本具备可点击性，以及支持自定义文本绘制等。此外，此种方式还提供了多种类型样式对象，覆盖了各种常见的文本样式格式，如文本装饰线样式、文本行高样式、文本阴影样式等。
```typescript
fontStyle: TextStyle = new TextStyle({
fontColor: Color.Pink
});
// 定义字体样式对象
mutableStyledString: MutableStyledString = new MutableStyledString("创建使用属性字符串构建的RichEditor组件。",
[{
start: 0,
length: 5,
styledKey: StyledStringKey.FONT,
styledValue: this.fontStyle
}]);
// 创建属性字符串
controller: RichEditorStyledStringController = new RichEditorStyledStringController();
options: RichEditorStyledStringOptions = { controller: this.controller };
RichEditor(this.options)
.onReady(() => {
this.controller.setStyledString(this.mutableStyledString);
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170301.38537527321772894197445597605540:50001231000000:2800:8D3D26A5CBB6F2F98579CAFD48D03FB03829251DC706720604C413FE2B6B50FE.gif)
设置属性
设置自定义选择菜单
通过bindSelectionMenu设置自定义选择菜单。
组件原本具有默认的文本选择菜单，包含复制、剪切和全选的功能。用户可使用该属性设定自定义菜单，例如翻译英文、加粗字体等丰富的菜单功能。
当自定义菜单超长时，建议内部嵌套Scroll组件使用，避免键盘被遮挡。
```typescript
export interface SelectionMenuTheme {
imageSize: number;
buttonSize: number;
menuSpacing: number;
editorOptionMargin: number;
expandedOptionPadding: number;
defaultMenuWidth: number;
imageFillColor: Resource;
backGroundColor: Resource;
iconBorderRadius: Resource;
containerBorderRadius: Resource;
cutIcon: Resource;
copyIcon: Resource;
pasteIcon: Resource;
selectAllIcon: Resource;
shareIcon: Resource;
translateIcon: Resource;
searchIcon: Resource;
arrowDownIcon: Resource;
iconPanelShadowStyle: ShadowStyle;
iconFocusBorderColor: Resource;
}
// 自定义SelectionMenuTheme接口
export const defaultTheme: SelectionMenuTheme = {
imageSize: 24,
buttonSize: 48,
menuSpacing: 8,
editorOptionMargin: 1,
expandedOptionPadding: 3,
defaultMenuWidth: 256,
imageFillColor: $r('sys.color.ohos_id_color_primary'),
backGroundColor: $r('sys.color.ohos_id_color_dialog_bg'),
iconBorderRadius: $r('sys.float.ohos_id_corner_radius_default_m'),
containerBorderRadius: $r('sys.float.ohos_id_corner_radius_card'),
cutIcon: $r("sys.media.ohos_ic_public_cut"),
copyIcon: $r("sys.media.ohos_ic_public_copy"),
pasteIcon: $r("sys.media.ohos_ic_public_paste"),
selectAllIcon: $r("sys.media.ohos_ic_public_select_all"),
shareIcon: $r("sys.media.ohos_ic_public_share"),
translateIcon: $r("sys.media.ohos_ic_public_translate_c2e"),
searchIcon: $r("sys.media.ohos_ic_public_search_filled"),
arrowDownIcon: $r("sys.media.ohos_ic_public_arrow_down"),
iconPanelShadowStyle: ShadowStyle.OUTER_DEFAULT_MD,
iconFocusBorderColor: $r('sys.color.ohos_id_color_focused_outline'),
}
// 定义defaultTheme变量
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('组件设置了自定义菜单，长按可触发。', {
style: {
fontColor: Color.Black,
fontSize: 18
}
})
})
.bindSelectionMenu(RichEditorSpanType.TEXT, this.SystemMenu, ResponseType.LongPress, {
onDisappear: () => {
this.sliderShow = false
}
})
// 绑定自定义菜单
.width(300)
.height(300)
@Builder
SystemMenu() {
Column() {
Menu() {
if (this.controller) {
MenuItemGroup() {
MenuItem({
startIcon: this.theme.cutIcon,
content: "剪切",
labelInfo: "Ctrl+X",
})
MenuItem({
startIcon: this.theme.copyIcon,
content: "复制",
labelInfo: "Ctrl+C"
})
MenuItem({
startIcon: this.theme.pasteIcon,
content: "粘贴",
labelInfo: "Ctrl+V"
})
}
}
}
.radius(this.theme.containerBorderRadius)
.clip(true)
.backgroundColor(Color.White)
.width(this.theme.defaultMenuWidth)
}
.width(this.theme.defaultMenuWidth)
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170301.97967071621408426160764143680488:50001231000000:2800:DC30D46D43DC2CC593199D20E69A5F99021FC04FEF26105D0A069386A2383E5D.gif)
设置输入框光标、手柄颜色
通过caretColor设置输入框光标、手柄颜色。
设置不同颜色的光标和手柄可以提高视觉辨识度，特别是在包含多个输入区域或不同类型内容输入区域的复杂界面中，独特的光标颜色能协助用户迅速定位当前操作的输入区域。这一特性同样适用于需要标示特殊功能或状态的输入框，比如密码输入框。
```typescript
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('组件设置了光标手柄颜色。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
.caretColor(Color.Orange)
.width(300)
.height(300)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170301.24826536597598273260431688193516:50001231000000:2800:484A664252C6C39C584485A8AF1138F7F0C0864D02DDEB6747518A7012AC4A9B.gif)
设置无输入时的提示文本
通过placeholder设置无输入时的提示文本。
例如，在用户登录界面采用提示文本，有助于用户区分用户名与密码的输入框。又如，在文本编辑框中，运用提示文本明确输入要求，如“限输入100字以内”，以此指导用户正确操作。
```typescript
RichEditor(this.options)
.placeholder("此处为提示文本...", {
fontColor: Color.Gray,
font: {
size: 15,
weight: FontWeight.Normal,
family: "HarmonyOS Sans",
style: FontStyle.Normal
}
})
.width(300)
.height(50)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170301.61654907624417462939918326252555:50001231000000:2800:8869E7B35EC67FB621A92D457668830F72AB3B7884CF6BEFBA9F1B7C545FDC7A.gif)
更多属性使用请参考RichEditor属性。
添加事件
添加组件初始化完成后可触发的回调
通过onReady来添加组件初始化完成后可触发的回调。
该回调可在组件初始化后，有效地展示包括图文和表情在内的丰富内容。例如，利用富文本组件展示新闻时，此回调可触发从服务器获取图文数据的操作。随后，将获取到的数据填充至组件中，确保组件在初始化完成后能够迅速在页面上呈现完整的新闻内容。
```typescript
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('onReady回调内容是组件内预置文本。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170301.95146178477860655451114625686504:50001231000000:2800:9341DE57482084CE5FE46E6FC5B9517C3EF826A5B4EDC2A61945A1D1AFB17D24.gif)
添加组件内容被选中时可触发的回调
通过onSelect来添加组件内容被选中时可触发的回调。
该回调可在文本选择后增强操作体验。例如，在选中文本后，可在回调中触发弹出菜单，以便用户进行文本样式的修改。或者对选中的文本进行内容分析和处理，为用户提供输入建议，从而提升文本编辑的效率和便捷性。
触发回调有两种方式：一是通过鼠标左键选择，即按下左键进行选择，然后在松开左键时触发回调。二是通过手指触摸选择，即用手指进行选择，然后在松开手指时触发回调。
```typescript
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('选中此处文本，触发onselect回调。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
.onSelect((value: RichEditorSelection) => {
this.controller1.addTextSpan(JSON.stringify(value), {
style: {
fontColor: Color.Gray,
fontSize: 10
}
})
})
.width(300)
.height(50)
Text('查看回调内容：').fontSize(10).fontColor(Color.Gray).width(300)
RichEditor(this.options1)
.width(300)
.height(70)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170301.12786649635333470219743831707169:50001231000000:2800:88FC0938B4D8477627216F0FA224CFC9564DB8C332D74B773A691244DA759468.gif)
添加图文变化前和图文变化后可触发的回调
通过onWillChange添加图文变化前可触发的回调。此回调适用于用户实时数据校验与提醒，例如在用户输入文本时，可在回调内实现对输入内容的检测，若检测到敏感词汇，应立即弹出提示框。此外，它还适用于实时字数统计与限制，对于有字数限制的输入场景，可在回调中实时统计用户输入的字数，并在接近字数上限时提供相应的提示。
通过onDidChange添加图文变化后可触发的回调。此回调适用于内容保存与同步，例如在用户完成内容编辑后，可使用该回调自动将最新内容保存至本地或同步至服务器。此外，它还适用于内容状态更新与渲染，例如在待办事项列表应用中，用户编辑富文本格式的待办事项描述后，可使用该回调更新待办事项在列表中的显示样式。
使用RichEditorStyledStringOptions构建的RichEditor组件不支持上述两种回调。
```typescript
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('组件内图文变化前，触发回调。\n图文变化后，触发回调。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
.onWillChange((value: RichEditorChangeValue) => {
this.controller1.addTextSpan('组件内图文变化前，触发回调：\n' + JSON.stringify(value), {
style: {
fontColor: Color.Gray,
fontSize: 10
}
})
return true;
})
.onDidChange((rangeBefore: TextRange, rangeAfter: TextRange) => {
this.controller1.addTextSpan('\n图文变化后，触发回调：\nrangeBefore:' + JSON.stringify(rangeBefore) +
'\nrangeAfter：' + JSON.stringify(rangeBefore), {
style: {
fontColor: Color.Gray,
fontSize: 10
}
})
return true;
})
.width(300)
.height(50)
Text('查看回调内容：').fontSize(10).fontColor(Color.Gray).width(300)
RichEditor(this.options1)
.width(300)
.height(70)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170301.18756109799648933105982781280381:50001231000000:2800:66C5F0C45F4E675F8D72B324F468A9DD6131D877E310F72B68215E5ECAEE2081.gif)
添加输入法输入内容前和完成输入后可触发的回调
在添加输入法输入内容前，可以通过aboutToIMEInput触发回调。在输入法完成输入后，可以通过onIMEInputComplete触发回调。
这两种回调机制适用于智能输入辅助。例如：在用户开始输入文本前，利用回调进行词汇联想的提供，在用户完成输入后，利用回调执行自动化纠错或格式转换。
使用RichEditorStyledStringOptions构建的组件并不支持上述两种回调功能。
```typescript
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('输入法输入内容前，触发回调。\n输入法完成输入后，触发回调。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
.aboutToIMEInput((value: RichEditorInsertValue) => {
this.controller1.addTextSpan('输入法输入内容前，触发回调：\n' + JSON.stringify(value), {
style: {
fontColor: Color.Gray,
fontSize: 10
}
})
return true;
})
.onIMEInputComplete((value: RichEditorTextSpanResult) => {
this.controller1.addTextSpan('输入法完成输入后，触发回调：\n' + JSON.stringify(value), {
style: {
fontColor: Color.Gray,
fontSize: 10
}
})
return true;
})
.width(300)
.height(50)
Text('查看回调内容：').fontSize(10).fontColor(Color.Gray).width(300)
RichEditor(this.options1)
.width(300)
.height(70)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170301.61471753953962627045425261004434:50001231000000:2800:BE05252D717D969030AC938A1FF667DD7D4FAACEA5C41AB024DC6BEFCC1CE0C9.gif)
添加完成粘贴前可触发的回调
通过onPaste添加完成粘贴前可触发的回调。
此回调适用于内容格式的处理。例如，当用户复制包含HTML标签的文本时，可在回调中编写代码，将其转换为富文本组件所支持的格式，同时剔除不必要的标签或仅保留纯文本内容。
由于组件默认的粘贴行为仅限于纯文本，无法处理图片粘贴，开发者可利用此方法实现图文并茂的粘贴功能，从而替代组件原有的粘贴行为。
```typescript
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('对此处文本进行复制粘贴操作可触发对应回调。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
.onPaste(() => {
this.controller1.addTextSpan('触发onPaste回调\n', {
style: {
fontColor: Color.Gray,
fontSize: 10
}
})
})
.width(300)
.height(70)
```
添加完成剪切前可触发的回调
通过onCut添加完成剪切前可触发的回调。
此回调功能适用于数据处理与存储，例如，当用户从富文本组件中剪切内容时，可在回调中执行将被剪切的内容进行临时存储的操作，确保后续的粘贴操作能够准确无误地还原内容。
由于组件默认的剪切行为仅限于纯文本，无法处理图片剪切，开发者可利用此方法实现图文并茂的剪切功能，从而替代组件原有的剪切行为。
```typescript
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('对此处文本进行复制粘贴操作可触发对应回调。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
.onCut(() => {
this.controller1.addTextSpan('触发onCut回调\n', {
style: {
fontColor: Color.Gray,
fontSize: 10
}
})
})
.width(300)
.height(70)
```
添加完成复制前可触发的回调
通过onCopy添加完成复制前可触发的回调。
此回调适用于内容的备份与共享，例如在用户复制内容时，可在回调中执行以下操作：将复制的内容及其格式信息保存至本地备份文件夹，或自动生成一段包含复制内容及产品购买链接的分享文案，以方便用户进行粘贴和分享。
由于组件默认的复制行为仅限于纯文本，无法处理图片复制，开发者可利用此方法实现图文并茂的复制功能，从而替代组件原有的复制行为。
```typescript
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('对此处文本进行复制粘贴操作可触发对应回调。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
.onCopy(() => {
this.controller1.addTextSpan('触发onCopy回调\n', {
style: {
fontColor: Color.Gray,
fontSize: 10
}
})
})
.width(300)
.height(70)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170301.95217278217276757725940446787511:50001231000000:2800:D05518ACFD915D45FBF4EB340DDE98A2E09745D61DF590FF364CBB7D39FB0A2B.gif)
更多事件使用请参考RichEditor事件。
设置用户预设的样式
通过setTypingStyle设置用户预设的样式。
此接口可用于个性化的写作体验，例如可以使用此接口让输入的不同层级标题自动应用相应格式（如一级、二级标题）。
```typescript
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('点击按钮,改变组件预设样式。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
.width(300)
.height(60)
Button('setTypingStyle', {
buttonStyle: ButtonStyleMode.NORMAL
})
.height(30)
.fontSize(13)
.onClick(() => {
this.controller.setTypingStyle({
fontWeight: 'medium',
fontColor: Color.Pink,
fontSize: 15,
fontStyle: FontStyle.Italic,
decoration: {
type: TextDecorationType.Underline,
color: Color.Gray
}
})
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170301.04265682874667388422106072509770:50001231000000:2800:24EAADCD611D896B6DE011173170D748343B31B9D7712E6DDFA85DA23B51F433.gif)
设置组件内的内容选中时部分背板高亮
通过setSelection设置组件内的内容选中时部分背板高亮。
此接口可用与文本聚焦效果，例如当用户点击某个文本段落的标题或摘要时，可通过该接口自动选中并高亮出对应正文内容。
当组件内未获焦出现光标时，调用该接口不产生选中效果。
```typescript
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('点击按钮在此处选中0-2位置的文本。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
.width(300)
.height(60)
Button('setSelection(0,2)', {
buttonStyle: ButtonStyleMode.NORMAL
})
.height(30)
.fontSize(13)
.onClick(() => {
this.controller.setSelection(0, 2)
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170301.51078576549288573759849578095424:50001231000000:2800:61DC23D706DFFB90F32A16707D2A17DBC4DCE98112D58092C316CFB6DED9ED15.gif)
添加文本内容
除了直接在组件内输入内容，也可以通过addTextSpan添加文本内容。
此接口可以实现文本样式多样化，例如需要创建混合样式文本。
如果组件是获焦状态，有光标在闪烁，那么通过addTextSpan添加文本内容后，光标位置会更新，在新添加文本内容的右侧闪烁。
```typescript
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('点击按钮在此处添加text。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
.width(300)
.height(100)
Button('addTextSpan', {
buttonStyle: ButtonStyleMode.NORMAL
})
.height(30)
.fontSize(13)
.onClick(() => {
this.controller.addTextSpan('新添加一段文字。')
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170301.49906198814489692578169938721866:50001231000000:2800:B4FD3F9C80BB019E149E77ED746B876558D5211A8A94F58FEB65FEF23B9E3AD8.gif)
添加图片内容
通过addImageSpan添加图片内容。
此接口可用于内容丰富与可视化展示，例如在新闻中加入图片，在文档中加入数据可视化图形等。
如果组件是获焦状态，有光标在闪烁，那么通过addImageSpan添加图片内容后，光标位置会更新，在新添加图片内容的右侧闪烁。
```typescript
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('点击按钮在此处添加image。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
.width(300)
.height(100)
Button('addImageSpan', {
buttonStyle: ButtonStyleMode.NORMAL
})
.height(30)
.fontSize(13)
.onClick(() => {
this.controller.addImageSpan($r("app.media.startIcon"), {
imageStyle: {
size: ["57px", "57px"]
}
})
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.03481794363081715203414309634102:50001231000000:2800:28C56533E1AA1BDF7EB728DF6AF05215CB21991D6AC0C382A5497C958027C179.gif)
添加@Builder装饰器修饰的内容
通过addBuilderSpan添加@Builder装饰器修饰的内容。
此接口可用于自定义复杂组件的嵌入，例如在组件内加入自定义图表。
该接口内可通过RichEditorBuilderSpanOptions设置在组件中添加builder的位置，省略或者为异常值时，则添加builder到所有内容的最后位置。
```typescript
private my_builder: CustomBuilder = undefined
@Builder
TextBuilder() {
Row() {
Image($r('app.media.startIcon')).width(50).height(50).margin(16)
Column() {
Text("文本文档.txt").fontWeight(FontWeight.Bold).fontSize(16)
Text("123.45KB").fontColor('#8a8a8a').fontSize(12)
}.alignItems(HorizontalAlign.Start)
}.backgroundColor('#f4f4f4')
.borderRadius("20")
.width(220)
}
Button('addBuilderSpan', {
buttonStyle: ButtonStyleMode.NORMAL
})
.height(30)
.fontSize(13)
.onClick(() => {
this.my_builder = () => {
this.TextBuilder()
}
this.controller.addBuilderSpan(this.my_builder)
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.10498038198118559044992738269574:50001231000000:2800:7BE8AA126EC0DBDE4ABF6710AF8D475A151414DD1B7DDB22917CAC86D8090BCA.gif)
添加SymbolSpan内容
可通过addSymbolSpan添加Symbol内容。此接口可用于特殊符号添加与展示，例如在编辑学术论文时，此接口可用于添加各种数学符号。
添加Symbol内容时，如果组件内有光标闪烁，则插入Symbol后光标位置更新为新插入Symbol的右侧。
Symbol内容暂不支持手势、复制、拖拽处理。
```typescript
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('点击按钮在此处添加symbol。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
.width(300)
.height(100)
Button('addSymbolSpan', {
buttonStyle: ButtonStyleMode.NORMAL
})
.height(30)
.fontSize(13)
.onClick(() => {
this.controller.addSymbolSpan($r("sys.symbol.basketball_fill"), {
style: {
fontSize: 30
}
})
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.30068297899490254003219407633399:50001231000000:2800:A6F8EC77C61A9DDAFE1268A4C1E32604F51D277964B1609CFE3C43D6FE488AA9.gif)
获取组件内图文信息
可通过getSpans获取组件内所有图文内容的信息，包括图文的内容、id、样式、位置等信息。获取内容位置信息后，可对指定范围内容进行样式的更新。
此接口适用于已有的内容样式获取与检查，例如在模板应用场景下，可利用此接口获取文本样式。此外，它还适用于内容解析与处理，例如在文本分析应用中，此接口能够获取特定范围内的文本信息。
```typescript
controller: RichEditorController = new RichEditorController();
options: RichEditorOptions = { controller: this.controller }
controller1: RichEditorController = new RichEditorController();
options1: RichEditorOptions = { controller: this.controller1 }
// 创建两个富文本组件
RichEditor(this.options)
.onReady(() => {
this.controller.addTextSpan('点击按钮获取此处span信息。', {
style: {
fontColor: Color.Black,
fontSize: 15
}
})
})
.width(300)
.height(50)
Text('查看getSpans返回值：').fontSize(10).fontColor(Color.Gray).width(300)
RichEditor(this.options1)
.width(300)
.height(50)
Button('getSpans', {
buttonStyle: ButtonStyleMode.NORMAL
})
.height(30)
.fontSize(13)
.onClick(() => {
this.controller1.addTextSpan(JSON.stringify(this.controller.getSpans()), {
style: {
fontColor: Color.Gray,
fontSize: 10
}
})
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.14184981535608746918424308240660:50001231000000:2800:66E2BB9D9D377601C02E8D31251A641744F15BFFF05756C1C43C73D6A0C630C9.gif)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-components-symbol-V14
爬取时间: 2025-04-27 23:22:50
来源: Huawei Developer
SymbolGlyph是图标小符号组件，便于使用精美的图标，如渲染多色图标和使用动效图标。SymbolSpan作为Text组件的子组件，可在文本中穿插显示图标小符号。具体用法请参考SymbolGlyph和SymbolSpan组件的文档。
创建图标
SymbolGlyph通过$r引用Resource资源来创建，目前仅支持系统预置的Symbol资源名。
相关资源可参考系统图标。
```typescript
SymbolGlyph($r('sys.symbol.ohos_folder_badge_plus'))
.fontSize(96)
.renderingStrategy(SymbolRenderingStrategy.SINGLE)
.fontColor([Color.Black, Color.Green, Color.White])
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.51291911097998059706959642905061:50001231000000:2800:96ECCD73D62C12944CE4837AB65F04436E6D8D8687744DF58FF6AD49BEC4F882.png)
添加到文本中
SymbolSpan可作为Text的子组件用于显示图标小符号。可以在一个Text组件内添加多个SymbolSpan，从而展示一串连续的图标。
-  创建SymbolSpan。 SymbolSpan组件必须嵌入在Text组件中才能显示，单独的SymbolSpan组件不会呈现任何内容。
```typescript
Text() {
SymbolSpan($r('sys.symbol.ohos_trash'))
.fontWeight(FontWeight.Normal)
.fontSize(96)
}
```
-  通过fontSize属性设置SymbolSpan的大小。
```typescript
Row() {
Column() {
Text("48")
Text() {
SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
.fontSize(48)
.renderingStrategy(SymbolRenderingStrategy.SINGLE)
.fontColor([Color.Black, Color.Green, Color.White])
}
}
Column() {
Text("72")
Text() {
SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
.fontSize(72)
.renderingStrategy(SymbolRenderingStrategy.SINGLE)
.fontColor([Color.Black, Color.Green, Color.White])
}
}
Column() {
Text("96")
Text() {
SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
.fontSize(96)
.renderingStrategy(SymbolRenderingStrategy.SINGLE)
.fontColor([Color.Black, Color.Green, Color.White])
}
}
}
```
-  通过fontWeight属性设置SymbolSpan组件的粗细。
```typescript
Row() {
Column() {
Text("Light")
Text() {
SymbolSpan($r('sys.symbol.ohos_trash'))
.fontWeight(FontWeight.Lighter)
.fontSize(96)
}
}
Column() {
Text("Normal")
Text() {
SymbolSpan($r('sys.symbol.ohos_trash'))
.fontWeight(FontWeight.Normal)
.fontSize(96)
}
}
Column() {
Text("Bold")
Text() {
SymbolSpan($r('sys.symbol.ohos_trash'))
.fontWeight(FontWeight.Bold)
.fontSize(96)
}
}
}
```
-  通过fontColor属性设置SymbolSpan的颜色。
```typescript
Row() {
Column() {
Text("Black")
Text() {
SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
.fontSize(96)
.fontColor([Color.Black])
}
}
Column() {
Text("Green")
Text() {
SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
.fontSize(96)
.fontColor([Color.Green])
}
}
Column() {
Text("Pink")
Text() {
SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
.fontSize(96)
.fontColor([Color.Pink])
}
}
}
```
-  通过renderingStrategy属性设置SymbolSpan的渲染策略。
```typescript
Row() {
Column() {
Text("单色")
Text() {
SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
.fontSize(96)
.renderingStrategy(SymbolRenderingStrategy.SINGLE)
.fontColor([Color.Black, Color.Green, Color.White])
}
}
Column() {
Text("多色")
Text() {
SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
.fontSize(96)
.renderingStrategy(SymbolRenderingStrategy.MULTIPLE_COLOR)
.fontColor([Color.Black, Color.Green, Color.White])
}
}
Column() {
Text("分层")
Text() {
SymbolSpan($r('sys.symbol.ohos_folder_badge_plus'))
.fontSize(96)
.renderingStrategy(SymbolRenderingStrategy.MULTIPLE_OPACITY)
.fontColor([Color.Black, Color.Green, Color.White])
}
}
}
```
-  通过effectStrategy属性设置SymbolSpan的动效策略。
```typescript
Row() {
Column() {
Text("无动效")
Text() {
SymbolSpan($r('sys.symbol.ohos_wifi'))
.fontSize(96)
.effectStrategy(SymbolEffectStrategy.NONE)
}
}
Column() {
Text("整体缩放动效")
Text() {
SymbolSpan($r('sys.symbol.ohos_wifi'))
.fontSize(96)
.effectStrategy(SymbolEffectStrategy.SCALE)
}
}
Column() {
Text("层级动效")
Text() {
SymbolSpan($r('sys.symbol.ohos_wifi'))
.fontSize(96)
.effectStrategy(SymbolEffectStrategy.HIERARCHICAL)
}
}
}
```
-  SymbolSpan不支持通用事件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.36133675565892212331060315080099:50001231000000:2800:32F696FDD56396FE80858CA62C6E453BBDBB3F8A2A1D087CF375F37913D46533.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.45749594995789576057635250075113:50001231000000:2800:E24D9CD72CB14B3B74124A39E39CFFDCBFF408C2ECC940A7B515B3B135F37662.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.65795922268135134706619345047947:50001231000000:2800:B398FBB0BC509A7E933BD3830025006C286CBB42EF9B18CB4D61713C140B2E6F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.19270037967588703601686703926694:50001231000000:2800:9359C1424D45FE8C07ADEEBEC1AF178644DAF47F7D5164BE437F821ED771277B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.72848752699588659248970708017910:50001231000000:2800:A920C0A35AEA0D5E78FE22B84391AFFFFB5E77DF51AEACB541C1CC15EC20B98F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.59284666213338341355157520419592:50001231000000:2800:D61FDE7554CEBC8E43E45223E27E0BF4C41E7CE45666271475293662FE352D05.gif)
自定义图标动效
相较于effectStrategy属性在启动时即触发动效，可以通过以下两种方式来控制动效的播放状态，以及选择更多样化的动效策略。
关于effectStrategy属性与symbolEffect属性的多种动态属性使用及生效原则，详情请参阅SymbolGlyph.symbolEffect属性的说明。
-  通过设置SymbolEffect属性，可以同时配置SymbolGlyph的动效策略及其播放状态。
```typescript
@State isActive: boolean = true;
Column() {
Text("可变颜色动效")
SymbolGlyph($r('sys.symbol.ohos_wifi'))
.fontSize(96)
.symbolEffect(new HierarchicalSymbolEffect(EffectFillStyle.ITERATIVE), this.isActive)
Button(this.isActive ? '关闭' : '播放').onClick(() => {
this.isActive = !this.isActive;
})
}
```
-  通过设置SymbolEffect属性，可以同时指定SymbolGlyph的动画效果策略及其播放触发条件。
```typescript
@State triggerValueReplace: number = 0;
Column() {
Text("弹跳动效")
SymbolGlyph($r('sys.symbol.ellipsis_message_1'))
.fontSize(96)
.fontColor([Color.Gray])
.symbolEffect(new BounceSymbolEffect(EffectScope.WHOLE, EffectDirection.UP), this.triggerValueReplace)
Button('trigger').onClick(() => {
this.triggerValueReplace = this.triggerValueReplace + 1;
})
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.09871078615344846262046703160144:50001231000000:2800:BA41B714A6A9C80334890CB38BD5BBC8AFC745C34F2AD2529BC26A3A599B49FA.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.42611840184399931477892994365862:50001231000000:2800:EFFF1EE7C8509745B692A16F542A220B20EBB6EA970539E388B4C5F17324BB4C.gif)
添加事件
SymbolGlyph组件可以添加通用事件，例如绑定onClick、onTouch等事件来响应操作。
```typescript
@State wifiColor: ResourceColor = Color.Black;
SymbolGlyph($r('sys.symbol.ohos_wifi'))
.fontSize(96)
.fontColor([this.wifiColor])
.onClick(() => {
this.wifiColor = Color.Gray;
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170302.42844225207664789090152252648333:50001231000000:2800:974E52AD301383C5CBF958611B89B75DA03451C5CBBC00152937D62C7890D464.gif)
场景示例
该示例通过symbolEffect、fontSize、fontColor属性展示了播放列表的效果。
```typescript
// xxx.ets
@Entry
@Component
struct Index {
@State triggerValueReplace: number = 0;
@State symbolSources: Resource[] =
[$r('sys.symbol.repeat'), $r('sys.symbol.repeat_1'), $r('sys.symbol.arrow_left_arrow_right')];
@State symbolSourcesIndex: number = 0;
@State symbolText: string[] = ['顺序播放', '单曲循环', '随机播放'];
@State symbolTextIndex: number = 0;
@State fontColorValue: ResourceColor = Color.Grey;
@State fontColorValue1: ResourceColor = '#E8E8E8';
build() {
Column({ space: 10 }) {
Row() {
Text() {
Span('当前播放列表')
.fontSize(20)
.fontWeight(FontWeight.Bolder)
Span('（101）')
}
}
Row() {
Row({ space: 5 }) {
SymbolGlyph(this.symbolSources[this.symbolSourcesIndex])
.symbolEffect(new ReplaceSymbolEffect(EffectScope.WHOLE), this.triggerValueReplace)
.fontSize(20)
.fontColor([this.fontColorValue])
Text(this.symbolText[this.symbolTextIndex])
.fontColor(this.fontColorValue)
}
.onClick(() => {
this.symbolTextIndex++;
this.symbolSourcesIndex++;
this.triggerValueReplace++;
if (this.symbolSourcesIndex > (this.symbolSources.length - 1)) {
this.symbolSourcesIndex = 0;
this.triggerValueReplace = 0;
}
if (this.symbolTextIndex > (this.symbolText.length - 1)) {
this.symbolTextIndex = 0;
}
})
.width('75%')
Row({ space: 5 }) {
Text() {
SymbolSpan($r('sys.symbol.arrow_down_circle_badge_vip_circle_filled'))
.fontColor([this.fontColorValue])
.fontSize(20)
}
Text() {
SymbolSpan($r('sys.symbol.heart_badge_plus'))
.fontColor([this.fontColorValue])
.fontSize(20)
}
Text() {
SymbolSpan($r('sys.symbol.ohos_trash'))
.fontColor([this.fontColorValue])
.fontSize(20)
}
}
.width('25%')
}
Divider().width(5).color(this.fontColorValue1).width('98%')
Row() {
Row() {
Text("歌曲一")
}.width('82%')
Row({ space: 5 }) {
SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
.fontColor([this.fontColorValue])
.fontSize(20)
SymbolGlyph($r('sys.symbol.trash'))
.fontColor([this.fontColorValue])
.fontSize(20)
}
}
Divider().width(5).color(this.fontColorValue1).width('98%')
Row() {
Row() {
Text("歌曲二")
}.width('82%')
Row({ space: 5 }) {
SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
.fontColor([this.fontColorValue])
.fontSize(20)
SymbolGlyph($r('sys.symbol.trash'))
.fontColor([this.fontColorValue])
.fontSize(20)
}
}
Divider().width(5).color(this.fontColorValue1).width('98%')
Row() {
Row() {
Text("歌曲三")
}.width('82%')
Row({ space: 5 }) {
SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
.fontColor([this.fontColorValue])
.fontSize(20)
SymbolGlyph($r('sys.symbol.trash'))
.fontColor([this.fontColorValue])
.fontSize(20)
}
}
Divider().width(5).color(this.fontColorValue1).width('98%')
Row() {
Row() {
Text("歌曲四")
}.width('82%')
Row({ space: 5 }) {
SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
.fontColor([this.fontColorValue])
.fontSize(20)
SymbolGlyph($r('sys.symbol.trash'))
.fontColor([this.fontColorValue])
.fontSize(20)
}
}
Divider().width(5).color(this.fontColorValue1).width('98%')
Row() {
Row() {
Text("歌曲五")
}.width('82%')
Row({ space: 5 }) {
SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
.fontColor([this.fontColorValue])
.fontSize(20)
SymbolGlyph($r('sys.symbol.trash'))
.fontColor([this.fontColorValue])
.fontSize(20)
}
}
Divider().width(5).color(this.fontColorValue1).width('98%')
Row() {
Row() {
Text("歌曲六")
}.width('82%')
Row({ space: 5 }) {
SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
.fontColor([this.fontColorValue])
.fontSize(20)
SymbolGlyph($r('sys.symbol.trash'))
.fontColor([this.fontColorValue])
.fontSize(20)
}
}
Divider().width(5).color(this.fontColorValue1).width('98%')
Row() {
Row() {
Text("歌曲七")
}.width('82%')
Row({ space: 5 }) {
SymbolGlyph($r('sys.symbol.play_arrow_triangle_2_circlepath'))
.fontColor([this.fontColorValue])
.fontSize(20)
SymbolGlyph($r('sys.symbol.trash'))
.fontColor([this.fontColorValue])
.fontSize(20)
}
}
Divider().width(5).color(this.fontColorValue1).width('98%')
Column() {
Text("关闭")
}
.alignItems(HorizontalAlign.Center)
.width('98%')
}
.alignItems(HorizontalAlign.Start)
.width('100%')
.height(400)
.padding({
left: 10,
top: 10
})
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170303.38265257752177855338860561180292:50001231000000:2800:CBC0D8DFF721B0F6F5797563AAD8A69FC66F439EB499CB57DEC3CF1C55BE3F99.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-styled-string-V14
爬取时间: 2025-04-27 23:23:04
来源: Huawei Developer
属性字符串StyledString/MutableStyledString（其中MutableStyledString继承自StyledString，下文统称为StyledString），可用于在字符或段落级别上设置文本样式。将StyledString应用到文本组件上，可以采用多种方式修改文本，包括调整字号、添加字体颜色、使文本具备可点击性，以及通过自定义方式绘制文本等。具体使用方法请参考属性字符串的文档。
属性字符串提供多种类型样式对象，涵盖各种常见的文本样式格式，例如文本装饰线样式、文本行高样式、文本阴影样式等。也可以自行创建CustomSpan，以应用自定义样式。
创建并应用StyledString和MutableStyledString
可以通过TextController提供的setStyledString方法，将属性字符串附加到文本组件，并推荐在onPageShow中触发绑定。
在aboutToAppear中调用setStyledString方法时，由于该方法运行阶段组件尚未完成创建并成功挂载节点树，因此无法在页面初始化时显示属性字符串。
```typescript
@Entry
@Component
struct styled_string_demo1 {
styledString1: StyledString = new StyledString("运动45分钟");
mutableStyledString1: MutableStyledString = new MutableStyledString("运动35分钟");
controller1: TextController = new TextController();
controller2: TextController = new TextController();
async onPageShow() {
this.controller1.setStyledString(this.styledString1);
this.controller2.setStyledString(this.mutableStyledString1);
}
build() {
Column() {
// 显示属性字符串
Text(undefined, { controller: this.controller1 })
Text(undefined, { controller: this.controller2 })
}
.width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170303.98380596255237952329518440124181:50001231000000:2800:0ABF9A6CC9A5E5A3F283465C5902CB568C67C9B84436A17690E28128D815B380.png)
设置文本样式
属性字符串目前提供了TextStyle、TextShadowStyle、DecorationStyle、BaselineOffsetStyle、LineHeightStyle、LetterSpacingStyle各种Style对象来实现设置文本的各类样式。
-  创建及应用文本字体样式对象（TextStyle）
```typescript
import { LengthMetrics } from '@kit.ArkUI';
@Entry
@Component
struct styled_string_demo2 {
textStyleAttrs: TextStyle =
new TextStyle({ fontWeight: FontWeight.Bolder, fontSize: LengthMetrics.vp(24), fontStyle: FontStyle.Italic });
mutableStyledString: MutableStyledString = new MutableStyledString("运动35分钟 目标达成", [
{
start: 2,
length: 2,
styledKey: StyledStringKey.FONT,
styledValue: this.textStyleAttrs
},
{
start: 7,
length: 4,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontColor: Color.Orange, fontSize: LengthMetrics.vp(12) })
}
]);
controller: TextController = new TextController();
async onPageShow() {
this.controller.setStyledString(this.mutableStyledString);
}
build() {
Column() {
// 显示属性字符串
Text(undefined, { controller: this.controller })
.margin({ top: 10 })
}
.width('100%')
}
}
```
-  创建及应用文本阴影对象（TextShadowStyle）
```typescript
// xxx.ets
@Entry
@Component
struct styled_string_demo3 {
mutableStyledString: MutableStyledString = new MutableStyledString("运动35分钟", [
{
start: 0,
length: 3,
styledKey: StyledStringKey.TEXT_SHADOW,
styledValue: new TextShadowStyle({
radius: 5,
type: ShadowType.COLOR,
color: Color.Red,
offsetX: 10,
offsetY: 10
})
}
]);
controller: TextController = new TextController();
async onPageShow() {
this.controller.setStyledString(this.mutableStyledString);
}
build() {
Column() {
// 显示属性字符串
Text(undefined, { controller: this.controller })
}
.width('100%')
}
}
```
-  创建及应用文本装饰线对象（DecorationStyle）
```typescript
// xxx.ets
@Entry
@Component
struct styled_string_demo4 {
mutableStyledString: MutableStyledString = new MutableStyledString("运动35分钟", [
{
start: 0,
length: 3,
styledKey: StyledStringKey.DECORATION,
styledValue: new DecorationStyle({ type: TextDecorationType.LineThrough, color: Color.Red })
}
]);
controller: TextController = new TextController();
async onPageShow() {
this.controller.setStyledString(this.mutableStyledString);
}
build() {
Column() {
// 显示属性字符串
Text(undefined, { controller: this.controller })
}
.width('100%')
}
}
```
-  创建及应用文本基线偏移量对象（BaselineOffsetStyle）
```typescript
import { LengthMetrics } from '@kit.ArkUI';
// xxx.ets
@Entry
@Component
struct styled_string_demo5 {
mutableStyledString: MutableStyledString = new MutableStyledString("运动35分钟", [
{
start: 0,
length: 3,
styledKey: StyledStringKey.BASELINE_OFFSET,
styledValue: new BaselineOffsetStyle(LengthMetrics.px(20))
}
]);
controller: TextController = new TextController();
async onPageShow() {
this.controller.setStyledString(this.mutableStyledString);
}
build() {
Column() {
// 显示属性字符串
Text(undefined, { controller: this.controller })
}
.width('100%')
}
}
```
-  创建及应用文本行高对象（LineHeightStyle）
```typescript
import { LengthMetrics } from '@kit.ArkUI';
// xxx.ets
@Entry
@Component
struct styled_string_demo6 {
mutableStyledString: MutableStyledString = new MutableStyledString("运动35分钟\n顶顶顶\n得到", [
{
start: 8,
length: 3,
styledKey: StyledStringKey.LINE_HEIGHT,
styledValue: new LineHeightStyle(LengthMetrics.vp(50))
}
]);
controller: TextController = new TextController();
async onPageShow() {
this.controller.setStyledString(this.mutableStyledString);
}
build() {
Column() {
// 显示属性字符串
Text(undefined, { controller: this.controller })
}
.width('100%')
.margin({ top: 10 })
}
}
```
-  创建及应用文本字符间距对象（LetterSpacingStyle）
```typescript
import { LengthMetrics, LengthUnit } from '@kit.ArkUI';
// xxx.ets
@Entry
@Component
struct styled_string_demo7 {
mutableStyledString: MutableStyledString = new MutableStyledString("运动35分钟", [
{
start: 0,
length: 2,
styledKey: StyledStringKey.LETTER_SPACING,
styledValue: new LetterSpacingStyle(new LengthMetrics(20, LengthUnit.VP))
}
]);
controller: TextController = new TextController();
async onPageShow() {
this.controller.setStyledString(this.mutableStyledString);
}
build() {
Column() {
// 显示属性字符串
Text(undefined, { controller: this.controller })
}
.width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170303.91613444267623722911415109256798:50001231000000:2800:0DD05E40DB8B8FB991ECA7328A31310120364F344845CA5DADE8C8D4662BA3C2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170303.35274764568193578285927218573311:50001231000000:2800:148F0FC5A50ECC560A1594EF15CB08252B2048BFF31229AE06F8C1229B4BD353.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170303.97346904917145312867088244606287:50001231000000:2800:342A139401D3B52D3B8B9D721F1EE3692D65F1FA0F059358B4F8B66E848541FC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170303.09660446798917080749112824044418:50001231000000:2800:DB72AEF53FB86304F46AA29E9CDE83350D7451A5F457CA3FF3F96CDB1B027984.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170303.73064658568585311097943596546703:50001231000000:2800:72EB16C9FC2DD3970140959D2B52932E49A47447632EC5CCCD4AEAA94EE837B7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170303.91415699271081512735512256098094:50001231000000:2800:C4FA3D6F4BF7F367FF18F77B4F2D296D2A99E43560388A5133006876F34BB8C0.png)
设置段落样式
可通过ParagraphStyle设置段落样式布局。下图显示了如何分割文本中的段落，段落以换行符 \n 结尾。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170303.67950794435744010226577988279309:50001231000000:2800:F0C210C2B3690ECEBE6E656FE0451A34E57ED063C4A7D2A0D329B8AD47EDF1CE.png)
以下代码示例展示了如何创建ParagraphStyle并应用。如果将ParagraphStyle附加到段落开头末尾或之间的任何位置，均会应用样式，非段落区间内则不会应用样式。
```typescript
import { LengthMetrics } from '@kit.ArkUI';
titleParagraphStyleAttr: ParagraphStyle = new ParagraphStyle({ textAlign: TextAlign.Center });
//段落首行缩进15vp
paragraphStyleAttr1: ParagraphStyle = new ParagraphStyle({ textIndent: LengthMetrics.vp(15) });
//行高样式对象
lineHeightStyle1: LineHeightStyle= new LineHeightStyle(new LengthMetrics(24));
//创建含段落样式的对象paragraphStyledString1
paragraphStyledString1: MutableStyledString = new MutableStyledString("段落标题\n正文第一段落开始0123456789正文第一段落结束。", [
{
start: 0,
length: 4,
styledKey: StyledStringKey.PARAGRAPH_STYLE,
styledValue: this.titleParagraphStyleAttr
},
{
start: 0,
length: 4,
styledKey: StyledStringKey.LINE_HEIGHT,
styledValue: new LineHeightStyle(new LengthMetrics(50))
},{
start: 0,
length: 4,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontSize: LengthMetrics.vp(24), fontWeight: FontWeight.Bolder })
},
{
start: 5,
length: 3,
styledKey: StyledStringKey.PARAGRAPH_STYLE,
styledValue: this.paragraphStyleAttr1
},
{
start: 5,
length: 20,
styledKey: StyledStringKey.LINE_HEIGHT,
styledValue: this.lineHeightStyle1
}
]);
```
除了可以在创建属性字符串时就预设样式，也可以后续通过replaceStyle清空原样式替换新样式, 同时需要在附加的文本组件controller上主动触发更新绑定的属性字符串。
```typescript
import { LengthMetrics } from '@kit.ArkUI';
//段落不设置缩进配置最大行数及超长显示方式
paragraphStyleAttr3: ParagraphStyle = new ParagraphStyle({ textAlign: TextAlign.End, maxLines: 1, wordBreak: WordBreak.BREAK_ALL, overflow: TextOverflow.Ellipsis});
// 后续某个节点触发更新段落样式
controller: TextController = new TextController();
this.paragraphStyledString1.replaceStyle({
start: 5,
length: 3,
styledKey: StyledStringKey.PARAGRAPH_STYLE,
styledValue: this.paragraphStyleAttr3
});
this.controller.setStyledString(this.paragraphStyledString1);
```
使用图片
可通过ImageAttachment来添加图片。
以下示例展示了如何将图片和文本附加到同一个MutableStyledString对象上，并实现图文混排。
```typescript
// xxx.ets
import { image } from '@kit.ImageKit';
import { LengthMetrics } from '@kit.ArkUI';
@Entry
@Component
struct styled_string_demo4 {
@State message: string = 'Hello World';
imagePixelMap: image.PixelMap | undefined = undefined;
@State imagePixelMap3: image.PixelMap | undefined = undefined;
mutableStr: MutableStyledString = new MutableStyledString('123');
controller: TextController = new TextController();
mutableStr2: MutableStyledString = new MutableStyledString('This is set decoration line style to the mutableStr2', [{
start: 0,
length: 15,
styledKey: StyledStringKey.DECORATION,
styledValue: new DecorationStyle({
type: TextDecorationType.Overline,
color: Color.Orange,
style: TextDecorationStyle.DOUBLE
})
}]);
async aboutToAppear() {
console.info("aboutToAppear initial imagePixelMap");
this.imagePixelMap = await this.getPixmapFromMedia($r('app.media.sea'));
}
private async getPixmapFromMedia(resource: Resource) {
let unit8Array = await this.getUIContext().getHostContext()?.resourceManager?.getMediaContent({
bundleName: resource.bundleName,
moduleName: resource.moduleName,
id: resource.id
});
let imageSource = image.createImageSource(unit8Array?.buffer?.slice(0, unit8Array?.buffer?.byteLength));
let createPixelMap: image.PixelMap = await imageSource.createPixelMap({
desiredPixelFormat: image.PixelMapFormat.RGBA_8888
});
await imageSource.release();
return createPixelMap;
}
leadingMarginValue: ParagraphStyle = new ParagraphStyle({ leadingMargin: LengthMetrics.vp(5)});
//行高样式对象
lineHeightStyle1: LineHeightStyle= new LineHeightStyle(new LengthMetrics(24));
//Bold样式
boldTextStyle: TextStyle = new TextStyle({ fontWeight: FontWeight.Bold });
//创建含段落样式的对象paragraphStyledString1
paragraphStyledString1: MutableStyledString = new MutableStyledString("\n品牌相纸 高清冲印30张\n限时直降5.15元 限量增送", [
{
start: 0,
length: 28,
styledKey: StyledStringKey.PARAGRAPH_STYLE,
styledValue: this.leadingMarginValue
},
{
start: 14,
length: 9,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontSize: LengthMetrics.vp(14), fontColor: '#B22222' })
},
{
start: 24,
length: 4,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontSize: LengthMetrics.vp(14), fontWeight: FontWeight.Lighter })
},
{
start: 11,
length: 4,
styledKey: StyledStringKey.LINE_HEIGHT,
styledValue: this.lineHeightStyle1
}
]);
paragraphStyledString2: MutableStyledString = new MutableStyledString("\n￥16.21 3000+人好评", [
{
start: 0,
length: 5,
styledKey: StyledStringKey.PARAGRAPH_STYLE,
styledValue: this.leadingMarginValue
},
{
start: 0,
length: 4,
styledKey: StyledStringKey.LINE_HEIGHT,
styledValue: new LineHeightStyle(new LengthMetrics(60))
},
{
start: 0,
length: 7,
styledKey: StyledStringKey.FONT,
styledValue: this.boldTextStyle
},
{
start: 1,
length: 1,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontSize: LengthMetrics.vp(18) })
},
{
start: 2,
length: 2,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontSize: LengthMetrics.vp(36) })
},
{
start: 4,
length: 3,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontSize: LengthMetrics.vp(20) })
},
{
start: 7,
length: 9,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontColor: Color.Grey, fontSize: LengthMetrics.vp(14)})
}
]);
build() {
Row() {
Column({ space: 10 }) {
Text(undefined, { controller: this.controller })
.copyOption(CopyOptions.InApp)
.draggable(true)
.backgroundColor('#FFFFFF')
.borderRadius(5)
Button('点击查看商品卡片')
.onClick(() => {
if (this.imagePixelMap !== undefined) {
this.mutableStr = new MutableStyledString(new ImageAttachment({
value: this.imagePixelMap,
size: { width: 180, height: 160 },
verticalAlign: ImageSpanAlignment.BASELINE,
objectFit: ImageFit.Fill
}));
this.paragraphStyledString1.appendStyledString(this.paragraphStyledString2);
this.mutableStr.appendStyledString(this.paragraphStyledString1);
this.controller.setStyledString(this.mutableStr);
}
})
}
.width('100%')
}
.height('100%')
.backgroundColor('#F8F8FF')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170303.52722280421966731492638458749717:50001231000000:2800:FE9E1E62339BB67A7424DA76E91715FEE33CA43EB51B9358DC3E2667A54A17FE.png)
设置事件
可通过GestureStyle设置onClick、onLongPress事件来使文本响应点击长按事件。
除了初始化属性字符串对象即初始样式对象，亦可通过setStyle接口再叠加新样式或更新已有样式，同时需要在附加的文本组件controller上主动触发更新绑定的属性字符串。
```typescript
import { drawing } from '@kit.ArkGraphics2D';
class MyCustomSpan extends CustomSpan {
constructor(word: string, width: number, height: number, fontSize: number) {
super();
this.word = word;
this.width = width;
this.height = height;
this.fontSize = fontSize;
}
onMeasure(measureInfo: CustomSpanMeasureInfo): CustomSpanMetrics {
return { width: this.width, height: this.height };
}
onDraw(context: DrawContext, options: CustomSpanDrawInfo) {
let canvas = context.canvas;
const brush = new drawing.Brush();
brush.setColor({
alpha: 255,
red: 0,
green: 0,
blue: 0
});
const font = new drawing.Font();
font.setSize(vp2px(this.fontSize));
const textBlob =
drawing.TextBlob.makeFromString(this.word.substring(0, 5), font, drawing.TextEncoding.TEXT_ENCODING_UTF8);
canvas.attachBrush(brush);
this.onDrawRectByRadius(context, options.x, options.x + vp2px(this.width), options.lineTop, options.lineBottom, 20);
brush.setColor({
alpha: 255,
red: 255,
green: 255,
blue: 255
});
canvas.attachBrush(brush);
canvas.drawTextBlob(textBlob, options.x, options.lineBottom - 30);
brush.setColor({
alpha: 255,
red: 255,
green: 228,
blue: 196
});
canvas.attachBrush(brush);
const textBlob1 =
drawing.TextBlob.makeFromString(this.word.substring(5), font, drawing.TextEncoding.TEXT_ENCODING_UTF8);
canvas.drawTextBlob(textBlob1, options.x + vp2px(100), options.lineBottom - 30);
canvas.detachBrush();
}
onDrawRectByRadius(context: DrawContext, left: number, right: number, top: number, bottom: number, radius: number) {
let canvas = context.canvas;
let path = new drawing.Path();
// 画带radius的rect
path.moveTo(left + radius, top);
path.lineTo(right - radius, top);
path.arcTo(right - 2 * radius, top, right, top + 2 * radius, 270, 90);
path.lineTo(right, bottom - radius);
path.arcTo(right - 2 * radius, bottom - 2 * radius, right, bottom, 0, 90);
path.lineTo(left + 2 * radius, bottom);
path.arcTo(left, bottom - 2 * radius, left + 2 * radius, bottom, 90, 90);
path.lineTo(left, top + 2 * radius);
path.arcTo(left, top, left + 2 * radius, top + 2 * radius, 180, 90);
canvas.drawPath(path);
}
setWord(word: string) {
this.word = word;
}
width: number = 160;
word: string = "drawing";
height: number = 10;
fontSize: number = 16;
}
@Entry
@Component
struct styled_string_demo6 {
customSpan3: MyCustomSpan = new MyCustomSpan("99VIP88%off", 200, 40, 30);
textStyle: MutableStyledString = new MutableStyledString("123");
textController: TextController = new TextController();
isPageShow: boolean = true;
async onPageShow() {
if (!this.isPageShow) {
return;
}
this.isPageShow = false;
this.textController.setStyledString(new StyledString(this.customSpan3));
}
build() {
Row() {
Column() {
Text(undefined, { controller: this.textController })
.copyOption(CopyOptions.InApp)
.fontSize(30)
}
.width('100%')
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170303.58175951601828754019582184054793:50001231000000:2800:45E7B03B9672FE01E4FC133815F0A17104BA429A0DC375532BE31A60DAEFBA13.png)
场景示例
该示例通过ParagraphStyle、LineHeightStyle、TextStyle对象展示了会员过期提示的效果。
```typescript
import { LengthMetrics } from '@kit.ArkUI';
@Entry
@Component
struct Index {
alignCenterParagraphStyleAttr: ParagraphStyle = new ParagraphStyle({ textAlign: TextAlign.Center });
//行高样式对象
lineHeightStyle1: LineHeightStyle = new LineHeightStyle(LengthMetrics.vp(24));
//Bold样式
boldTextStyle: TextStyle = new TextStyle({ fontWeight: FontWeight.Bold });
//创建含段落样式的对象paragraphStyledString1
paragraphStyledString1: MutableStyledString =
new MutableStyledString("您的豪华钻石已过期1天\n续费可继续享受会员专属权益", [
{
start: 0,
length: 4,
styledKey: StyledStringKey.PARAGRAPH_STYLE,
styledValue: this.alignCenterParagraphStyleAttr
},
{
start: 0,
length: 4,
styledKey: StyledStringKey.LINE_HEIGHT,
styledValue: new LineHeightStyle(LengthMetrics.vp(40))
},
{
start: 11,
length: 14,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontSize: LengthMetrics.vp(14), fontColor: Color.Grey })
},
{
start: 11,
length: 4,
styledKey: StyledStringKey.PARAGRAPH_STYLE,
styledValue: this.alignCenterParagraphStyleAttr
},
{
start: 11,
length: 4,
styledKey: StyledStringKey.LINE_HEIGHT,
styledValue: this.lineHeightStyle1
}
]);
paragraphStyledString2: MutableStyledString = new MutableStyledString("\n￥4.88￥15", [
{
start: 0,
length: 4,
styledKey: StyledStringKey.PARAGRAPH_STYLE,
styledValue: this.alignCenterParagraphStyleAttr
},
{
start: 0,
length: 4,
styledKey: StyledStringKey.LINE_HEIGHT,
styledValue: new LineHeightStyle(LengthMetrics.vp(60))
},
{
start: 0,
length: 6,
styledKey: StyledStringKey.FONT,
styledValue: this.boldTextStyle
},
{
start: 1,
length: 1,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontSize: LengthMetrics.vp(18) })
},
{
start: 2,
length: 4,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontSize: LengthMetrics.vp(40) })
},
{
start: 6,
length: 3,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontColor: Color.Grey, fontSize: LengthMetrics.vp(14) })
},
{
start: 6,
length: 3,
styledKey: StyledStringKey.DECORATION,
styledValue: new DecorationStyle({ type: TextDecorationType.LineThrough, color: Color.Grey })
}
]);
paragraphStyledString3: MutableStyledString = new MutableStyledString("\n02时06分后将失去该优惠", [
{
start: 0,
length: 4,
styledKey: StyledStringKey.PARAGRAPH_STYLE,
styledValue: this.alignCenterParagraphStyleAttr
},
{
start: 0,
length: 4,
styledKey: StyledStringKey.LINE_HEIGHT,
styledValue: new LineHeightStyle(LengthMetrics.vp(30))
},
{
start: 1,
length: 2,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontColor: '#FFD700', fontWeight: FontWeight.Bold })
},
{
start: 4,
length: 2,
styledKey: StyledStringKey.FONT,
styledValue: new TextStyle({ fontColor: '#FFD700', fontWeight: FontWeight.Bold })
}
]);
controller: TextController = new TextController();
build() {
Row() {
Column({ space: 5 }) {
Text(undefined, { controller: this.controller })
.width(240)
.copyOption(CopyOptions.InApp)
.draggable(true)
.onAppear(() => {
this.paragraphStyledString2.appendStyledString(this.paragraphStyledString3);
this.paragraphStyledString1.appendStyledString(this.paragraphStyledString2);
this.controller.setStyledString(this.paragraphStyledString1);
})
Button("限时4.88元 立即续费")
.width(200)
.fontColor(Color.White)
.fontSize(18)
.backgroundColor('#3CB371')
.margin({ bottom: 10 })
}
.borderWidth(1).borderColor('#FFDEAD')
.margin({ left: 10 })
}
.height('60%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170303.65010510365801653929083069376186:50001231000000:2800:659FF99CFEB374AC39069A43606294DFB006D0136D2FE5C1B1AC20C850D317E2.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-use-dialog-V14
爬取时间: 2025-04-27 23:23:17
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-dialog-overview-V14
爬取时间: 2025-04-27 23:23:31
来源: Huawei Developer
弹窗一般指打开应用时自动弹出或者用户行为操作时弹出的UI界面，用于短时间内展示用户需关注的信息或待处理的操作。
弹窗的种类
根据用户交互操作场景，弹窗可分为模态弹窗和非模态弹窗两种类型，其区别在于用户是否必须对其做出响应。
当前模态弹窗通过设置指定属性变成非模态，例如AlertDialog，可以设置isModal为false变成非模态，其他弹窗详见API说明。
使用场景
开发者可根据实际应用场景选择合适的弹窗进行页面开发。
| 弹窗名称 | 应用场景 |
| --- | --- |
| 弹出框（Dialog） | 当需要展示用户当前需要或必须关注的信息内容或操作时，例如二次退出应用等，应优先考虑使用此弹出框。 |
| 菜单控制（Menu） | 当需要给指定的组件绑定用户可执行的操作时，例如长按图标展示操作选项等，应优先考虑使用此弹窗。 |
| 气泡提示（Popup） | 当需要给指定的组件提示时，例如点击一个问号图标弹出一段帮助提示等，应优先考虑使用此弹窗。 |
| 绑定模态页面（bindContentCover/bindSheet） | 当需要新的界面覆盖在旧的界面上，且旧的界面不消失的一种转场方式时，例如缩略图片点击后查看大图等，应优先考虑使用此弹窗。 |
| 即时反馈（Toast） | 当需要在一个小的窗口中提供用户当前操作的简单反馈时，例如提示文件保存成功等，应用优先考虑使用此弹窗。 |
| 设置浮层（OverlayManager） | 当需要完全自定义内容、行为、样式时，可以使用浮层将UI展示在页面之上，例如音乐/语音播放悬浮球/胶囊等，应优先考虑使用此弹窗。 |
规格约束
-  多个弹窗组件先后弹出时，后弹出的组件的层级高于先弹出的层级，退出时按照层级从高到低的顺序逐次退出。不支持调整层级。
-  在移动设备中，子窗模式的弹窗当前无法超出主窗口。而在2in1设备上，使用模态类弹窗时，会出现需要超出主窗口显示的场景，开发者可以通过设置showInSubWindow为true实现超出主窗口的显示效果。如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170304.50219618387411187938584711510342:50001231000000:2800:258CE7DD985E5C5819E4F58563F94F85EE3D4D31254693E2CEA10A18DDD8A6E8.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-use-dialogs-V14
爬取时间: 2025-04-27 23:24:25
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-base-dialog-overview-V14
爬取时间: 2025-04-27 23:24:39
来源: Huawei Developer
弹出框是一种模态窗口，通常用于在保持当前上下文环境的同时，临时展示用户需关注的信息或待处理的操作。用户需在模态弹出框内完成相关交互任务之后，才能退出模态模式。弹出框可以不与任何组件绑定，其内容通常由多种组件组成，如文本、列表、输入框、图片等，以实现布局。ArkUI当前提供了自定义和固定样式两类弹出框组件。
使用场景
| 名称 | 描述 |
| --- | --- |
| 不依赖UI组件的自定义弹出框 (openCustomDialog) | 当用户需要在自定义弹出框内动态更新弹出框属性时使用。 |
| 基础自定义弹出框 (CustomDialog) | 当用户需要自定义弹出框内的组件和内容时使用。 |
| 警告弹窗 (AlertDialog) | 固定样式，通常用来展示用户当前需要或必须关注的信息或操作。如用户操作一个敏感行为时响应一个二次确认的弹出框。 |
| 列表选择弹窗 (ActionSheet) | 固定样式，当用户需要关注或确认的信息存在列表选择时使用。 |
| 选择器弹窗 (PickerDialog) | 固定样式，当用户需要在弹出框内选择日期、时间和文本时使用。 |
| 对话框 (showDialog) | 固定样式，当用户需要对在弹出框响应后异步返回结果进行处理时使用。 |
| 操作菜单 (showActionMenu) | 固定样式，当用户需要对在操作菜单响应后异步返回结果进行处理时使用。 |
规格约束

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-uicontext-custom-dialog-V14
爬取时间: 2025-04-27 23:24:52
来源: Huawei Developer
由于CustomDialogController在使用上存在诸多限制，不支持动态创建也不支持动态刷新，在相对较复杂的应用场景中推荐使用UIContext中获取到的PromptAction对象提供的openCustomDialog接口来实现自定义弹出框。
弹出框（openCustomDialog）存在两种入参方式创建自定义弹出框：
本文介绍通过入参形式为ComponentContent创建自定义弹出框，传builder形式的弹出框使用方法可参考openCustomDialog。
弹出框（openCustomDialog）可以通过配置isModal来实现模态和非模态弹窗。isModal为true时，弹出框为模态弹窗。isModal为false时，弹出框为非模态弹窗。
生命周期
弹出框提供了生命周期函数用于通知用户该弹出框的生命周期。生命周期的触发时序依次为：onWillAppear -> onDidAppear -> onWillDisappear -> onDidDisappear。
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| onDidAppear | () => void | 弹出框弹出时的事件回调。 |
| onDidDisappear | () => void | 弹出框消失时的事件回调。 |
| onWillAppear | () => void | 弹出框显示动效前的事件回调。 |
| onWillDisappear | () => void | 弹出框退出动效前的事件回调。 |
自定义弹出框的打开与关闭
详细变量定义请参考完整示例。
1.  创建ComponentContent。 ComponentContent用于定义自定义弹出框的内容。其中，wrapBuilder(buildText)封装自定义组件，new Params(this.message)是自定义组件的入参，可以缺省，也可以传入基础数据类型。
```typescript
private contentNode: ComponentContent<Object> = new ComponentContent(this.ctx, wrapBuilder(buildText), new Params(this.message));
```
2.  打开自定义弹出框。 通过调用openCustomDialog接口打开的弹出框默认为customStyle为true的弹出框，即弹出框的内容样式完全按照contentNode自定义样式显示。
```typescript
PromptActionClass.ctx.getPromptAction().openCustomDialog(PromptActionClass.contentNode, PromptActionClass.options)
.then(() => {
console.info('OpenCustomDialog complete.')
})
.catch((error: BusinessError) => {
let message = (error as BusinessError).message;
let code = (error as BusinessError).code;
console.error(`OpenCustomDialog args error code is ${code}, message is ${message}`);
})
```
3.  关闭自定义弹出框。 由于closeCustomDialog接口需要传入待关闭弹出框对应的ComponentContent。因此，如果需要在弹出框中设置关闭方法，则可参考完整示例封装静态方法来实现。 关闭弹出框之后若需要释放对应的ComponentContent，则需要调用ComponentContent的dispose方法。
```typescript
PromptActionClass.ctx.getPromptAction().closeCustomDialog(PromptActionClass.contentNode)
.then(() => {
console.info('CloseCustomDialog complete.')
if (this.contentNode !== null) {
this.contentNode.dispose();   // 释放contentNode
}
})
.catch((error: BusinessError) => {
let message = (error as BusinessError).message;
let code = (error as BusinessError).code;
console.error(`CloseCustomDialog args error code is ${code}, message is ${message}`);
})
```
更新自定义弹出框的内容
ComponentContent与BuilderNode有相同的使用限制，不支持自定义组件使用@Reusable、@Link、@Provide、@Consume等装饰器，来同步弹出框弹出的页面与ComponentContent中自定义组件的状态。因此，若需要更新弹出框中自定义组件的内容可以通过ComponentContent提供的update方法来实现。
```typescript
this.contentNode.update(new Params('update'))
```
更新自定义弹出框的属性
通过updateCustomDialog可以动态更新弹出框的属性。目前支持的属性包括alignment、offset、autoCancel、maskColor。
需要注意的是，更新属性时，未设置的属性会恢复为默认值。例如，初始设置{ alignment: DialogAlignment.Top, offset: { dx: 0, dy: 50 } }，更新时设置{ alignment: DialogAlignment.Bottom }，则初始设置的offset: { dx: 0, dy: 50 }不会保留，会恢复为默认值。
```typescript
PromptActionClass.ctx.getPromptAction().updateCustomDialog(PromptActionClass.contentNode, options)
.then(() => {
console.info('UpdateCustomDialog complete.')
})
.catch((error: BusinessError) => {
let message = (error as BusinessError).message;
let code = (error as BusinessError).code;
console.error(`UpdateCustomDialog args error code is ${code}, message is ${message}`);
})
```
完整示例
```typescript
// PromptActionClass.ets
import { BusinessError } from '@kit.BasicServicesKit';
import { ComponentContent, promptAction } from '@kit.ArkUI';
import { UIContext } from '@ohos.arkui.UIContext';
export class PromptActionClass {
static ctx: UIContext;
static contentNode: ComponentContent<Object>;
static options: promptAction.BaseDialogOptions;
static setContext(context: UIContext) {
PromptActionClass.ctx = context;
}
static setContentNode(node: ComponentContent<Object>) {
PromptActionClass.contentNode = node;
}
static setOptions(options: promptAction.BaseDialogOptions) {
PromptActionClass.options = options;
}
static openDialog() {
if (PromptActionClass.contentNode !== null) {
PromptActionClass.ctx.getPromptAction().openCustomDialog(PromptActionClass.contentNode, PromptActionClass.options)
.then(() => {
console.info('OpenCustomDialog complete.')
})
.catch((error: BusinessError) => {
let message = (error as BusinessError).message;
let code = (error as BusinessError).code;
console.error(`OpenCustomDialog args error code is ${code}, message is ${message}`);
})
}
}
static closeDialog() {
if (PromptActionClass.contentNode !== null) {
PromptActionClass.ctx.getPromptAction().closeCustomDialog(PromptActionClass.contentNode)
.then(() => {
console.info('CloseCustomDialog complete.')
})
.catch((error: BusinessError) => {
let message = (error as BusinessError).message;
let code = (error as BusinessError).code;
console.error(`CloseCustomDialog args error code is ${code}, message is ${message}`);
})
}
}
static updateDialog(options: promptAction.BaseDialogOptions) {
if (PromptActionClass.contentNode !== null) {
PromptActionClass.ctx.getPromptAction().updateCustomDialog(PromptActionClass.contentNode, options)
.then(() => {
console.info('UpdateCustomDialog complete.')
})
.catch((error: BusinessError) => {
let message = (error as BusinessError).message;
let code = (error as BusinessError).code;
console.error(`UpdateCustomDialog args error code is ${code}, message is ${message}`);
})
}
}
}
```
```typescript
// Index.ets
import { ComponentContent } from '@kit.ArkUI';
import { PromptActionClass } from './PromptActionClass';
class Params {
text: string = ""
constructor(text: string) {
this.text = text;
}
}
@Builder
function buildText(params: Params) {
Column() {
Text(params.text)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.margin({ bottom: 36 })
Button('Close')
.onClick(() => {
PromptActionClass.closeDialog()
})
}.backgroundColor('#FFF0F0F0')
}
@Entry
@Component
struct Index {
@State message: string = "hello"
private ctx: UIContext = this.getUIContext();
private contentNode: ComponentContent<Object> =
new ComponentContent(this.ctx, wrapBuilder(buildText), new Params(this.message));
aboutToAppear(): void {
PromptActionClass.setContext(this.ctx);
PromptActionClass.setContentNode(this.contentNode);
PromptActionClass.setOptions({ alignment: DialogAlignment.Top, offset: { dx: 0, dy: 50 } });
}
build() {
Row() {
Column() {
Button("open dialog and update options")
.margin({ top: 50 })
.onClick(() => {
PromptActionClass.openDialog()
setTimeout(() => {
PromptActionClass.updateDialog({
alignment: DialogAlignment.Bottom,
offset: { dx: 0, dy: -50 }
})
}, 1500)
})
Button("open dialog and update content")
.margin({ top: 50 })
.onClick(() => {
PromptActionClass.openDialog()
setTimeout(() => {
this.contentNode.update(new Params('update'))
}, 1500)
})
}
.width('100%')
.height('100%')
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170304.38882726727561002964642398273735:50001231000000:2800:1B57EBD4252F75DCFDD3EC7A9B21D5CB37BD1797F800B3CC5D840EABC4E197E7.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-components-custom-dialog-V14
爬取时间: 2025-04-27 23:25:06
来源: Huawei Developer
CustomDialog是自定义弹出框，可用于广告、中奖、警告、软件更新等与用户交互响应操作。开发者可以通过CustomDialogController类显示自定义弹出框。具体用法请参考自定义弹出框。
当前，ArkUI弹出框均为非页面级弹出框，在页面路由跳转时，如果开发者未调用close方法将其关闭，弹出框将不会自动关闭。若需实现在跳转页面时覆盖弹出框的场景，建议使用Navigation。具体使用方法，请参考组件导航子页面显示类型的弹窗类型。
弹出框（CustomDialog）可以通过配置isModal来实现模态和非模态弹窗。isModal为true的时候，弹出框为模态弹窗。isModal为false时，弹出框为非模态弹窗。
创建自定义弹出框
1.  使用@CustomDialog装饰器装饰自定义弹出框，可在此装饰器内自定义弹出框内容。CustomDialogController需在@Component内定义。
```typescript
@CustomDialog
struct CustomDialogExample {
controller: CustomDialogController = new CustomDialogController({
builder: CustomDialogExample({}),
})
build() {
Column() {
Text('我是内容')
.fontSize(20)
}.height(60).justifyContent(FlexAlign.Center)
}
}
```
2.  创建构造器，与装饰器呼应相连。
```typescript
@Entry
@Component
struct CustomDialogUser {
dialogController: CustomDialogController = new CustomDialogController({
builder: CustomDialogExample(),
})
}
```
3.  点击与onClick事件绑定的组件使弹出框弹出。
```typescript
@Entry
@Component
struct CustomDialogUser {
dialogController: CustomDialogController = new CustomDialogController({
builder: CustomDialogExample(),
})
build() {
Column() {
Button('click me')
.onClick(() => {
this.dialogController.open()
})
}.width('100%').margin({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170304.96780582235411452832554335568297:50001231000000:2800:A0C7BF99FB8509C4A8A7CF224AD6398E41A7BC1AFD8588006E2E18FB25FDF9D4.png)
弹出框的交互
弹出框可用于数据交互，完成用户一系列响应操作。
1.  在@CustomDialog装饰器内添加按钮，同时添加数据函数。
```typescript
@CustomDialog
struct CustomDialogExample {
cancel?: () => void
confirm?: () => void
controller: CustomDialogController
build() {
Column() {
Text('我是内容').fontSize(20).margin({ top: 10, bottom: 10 })
Flex({ justifyContent: FlexAlign.SpaceAround }) {
Button('cancel')
.onClick(() => {
this.controller.close()
if (this.cancel) {
this.cancel()
}
}).backgroundColor(0xffffff).fontColor(Color.Black)
Button('confirm')
.onClick(() => {
this.controller.close()
if (this.confirm) {
this.confirm()
}
}).backgroundColor(0xffffff).fontColor(Color.Red)
}.margin({ bottom: 10 })
}
}
}
```
2.  页面内需要在构造器内进行接收，同时创建相应的函数操作。 3.可通过弹出框中的按钮实现路由跳转，同时获取跳转页面向当前页传入的参数。
```typescript
@Entry
@Component
struct CustomDialogUser {
dialogController: CustomDialogController = new CustomDialogController({
builder: CustomDialogExample({
cancel: ()=> { this.onCancel() },
confirm: ()=> { this.onAccept() },
}),
})
onCancel() {
console.info('Callback when the first button is clicked')
}
onAccept() {
console.info('Callback when the second button is clicked')
}
build() {
Column() {
Button('click me')
.onClick(() => {
this.dialogController.open()
})
}.width('100%').margin({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170304.28409666762529206325115142073962:50001231000000:2800:93931E43497C20C507904F2D815FB98A58C43D3D0CA37A7BADF2B820067DBC3D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170304.32224852326722689327160824619296:50001231000000:2800:B7CA06B61F03B5BB4D8A3680D9937076B581226380BFF8D26D8C3F607DF2B967.gif)
弹出框的动画
弹出框通过定义openAnimation控制弹出框出现动画的持续时间，速度等参数。
```typescript
@CustomDialog
struct CustomDialogExample {
controller?: CustomDialogController
build() {
Column() {
Text('Whether to change a text?').fontSize(16).margin({ bottom: 10 })
}
}
}
@Entry
@Component
struct CustomDialogUser {
@State textValue: string = ''
@State inputValue: string = 'click me'
dialogController: CustomDialogController | null = new CustomDialogController({
builder: CustomDialogExample(),
openAnimation: {
duration: 1200,
curve: Curve.Friction,
delay: 500,
playMode: PlayMode.Alternate,
onFinish: () => {
console.info('play end')
}
},
autoCancel: true,
alignment: DialogAlignment.Bottom,
offset: { dx: 0, dy: -20 },
gridCount: 4,
customStyle: false,
backgroundColor: 0xd9ffffff,
cornerRadius: 10,
})
// 在自定义组件即将析构销毁时将dialogController置空
aboutToDisappear() {
this.dialogController = null // 将dialogController置空
}
build() {
Column() {
Button(this.inputValue)
.onClick(() => {
if (this.dialogController != null) {
this.dialogController.open()
}
}).backgroundColor(0x317aff)
}.width('100%').margin({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170304.21058156719897079676354361937288:50001231000000:2800:EA58A0703C7026C1DFC22B53949DD2AA36E3FC9CB9AD4282D84BD19C2CC02337.gif)
弹出框的样式
弹出框通过定义宽度、高度、背景色、阴影等参数来控制样式。
```typescript
@CustomDialog
struct CustomDialogExample {
controller?: CustomDialogController
build() {
Column() {
Text('我是内容').fontSize(16).margin({ bottom: 10 })
}
}
}
@Entry
@Component
struct CustomDialogUser {
@State textValue: string = ''
@State inputValue: string = 'click me'
dialogController: CustomDialogController | null = new CustomDialogController({
builder: CustomDialogExample(),
autoCancel: true,
alignment: DialogAlignment.Center,
offset: { dx: 0, dy: -20 },
gridCount: 4,
customStyle: false,
backgroundColor: 0xd9ffffff,
cornerRadius: 20,
width: '80%',
height: '100px',
borderWidth: 1,
borderStyle: BorderStyle.Dashed,//使用borderStyle属性，需要和borderWidth属性一起使用
borderColor: Color.Blue,//使用borderColor属性，需要和borderWidth属性一起使用
shadow: ({ radius: 20, color: Color.Grey, offsetX: 50, offsetY: 0}),
})
// 在自定义组件即将析构销毁时将dialogController置空
aboutToDisappear() {
this.dialogController = null // 将dialogController置空
}
build() {
Column() {
Button(this.inputValue)
.onClick(() => {
if (this.dialogController != null) {
this.dialogController.open()
}
}).backgroundColor(0x317aff)
}.width('100%').margin({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170304.26182442541832252977193935184322:50001231000000:2800:37A8484EF1111DAD475D3574E749011F90C269E5D1EC651CF995A75516294211.gif)
嵌套自定义弹出框
通过第一个弹出框打开第二个弹出框时，最好将第二个弹出框定义在第一个弹出框的父组件处，通过父组件传给第一个弹出框的回调来打开第二个弹出框。
```typescript
@CustomDialog
struct CustomDialogExampleTwo {
controllerTwo?: CustomDialogController
@State message: string = "I'm the second dialog box."
@State showIf: boolean = false;
build() {
Column() {
if (this.showIf) {
Text("Text")
.fontSize(30)
.height(100)
}
Text(this.message)
.fontSize(30)
.height(100)
Button("Create Text")
.onClick(()=>{
this.showIf = true;
})
Button ('Close Second Dialog Box')
.onClick(() => {
if (this.controllerTwo != undefined) {
this.controllerTwo.close()
}
})
.margin(20)
}
}
}
@CustomDialog
struct CustomDialogExample {
openSecondBox?: ()=>void
controller?: CustomDialogController
build() {
Column() {
Button ('Open Second Dialog Box and close this box')
.onClick(() => {
this.controller!.close();
this.openSecondBox!();
})
.margin(20)
}.borderRadius(10)
}
}
@Entry
@Component
struct CustomDialogUser {
@State inputValue: string = 'Click Me'
dialogController: CustomDialogController | null = new CustomDialogController({
builder: CustomDialogExample({
openSecondBox: ()=>{
if (this.dialogControllerTwo != null) {
this.dialogControllerTwo.open()
}
}
}),
cancel: this.exitApp,
autoCancel: true,
alignment: DialogAlignment.Bottom,
offset: { dx: 0, dy: -20 },
gridCount: 4,
customStyle: false
})
dialogControllerTwo: CustomDialogController | null = new CustomDialogController({
builder: CustomDialogExampleTwo(),
alignment: DialogAlignment.Bottom,
offset: { dx: 0, dy: -25 } })
aboutToDisappear() {
this.dialogController = null
this.dialogControllerTwo = null
}
onCancel() {
console.info('Callback when the first button is clicked')
}
onAccept() {
console.info('Callback when the second button is clicked')
}
exitApp() {
console.info('Click the callback in the blank area')
}
build() {
Column() {
Button(this.inputValue)
.onClick(() => {
if (this.dialogController != null) {
this.dialogController.open()
}
}).backgroundColor(0x317aff)
}.width('100%').margin({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170305.97417685227276839720121010421522:50001231000000:2800:2C4F361452CC15805AED6FD5F9235FC11A547AE9EA85A9DDACDF35FEBB29274C.gif)
由于自定义弹出框在状态管理侧有父子关系，如果将第二个弹出框定义在第一个弹出框内，那么当父组件（第一个弹出框）被销毁（关闭）时，子组件（第二个弹出框）内无法再继续创建新的组件。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-fixes-style-dialog-V14
爬取时间: 2025-04-27 23:25:21
来源: Huawei Developer
固定样式弹出框采用固定的布局格式，这使得开发者无需关心具体的显示布局细节，只需输入所需显示的文本内容，从而简化了使用流程，提升了便捷性。
使用约束
-  弹出框的弹出依赖UI的执行上下文，不可在UI上下文不明确的地方使用，具体约束参见UIContext说明。
-  可以通过调用UIContext或getUIContext，在非UI页面或某些异步回调中使用本文中的接口。CalendarPickerDialog当前不支持此操作。
-  操作菜单 (showActionMenu)、对话框 (showDialog)需先使用UIContext中的getPromptAction()方法获取到PromptAction对象，再通过该对象调用对应方法。
-  列表选择弹出框 (ActionSheet)、警告弹出框 (AlertDialog)、选择器弹出框 (PickerDialog)中除CalendarPickerDialog都需先使用ohos.window中的getUIContext()方法获取UIContext实例，再通过此实例调用对应方法。或者可以通过自定义组件内置方法getUIContext()获取。
操作菜单 (showActionMenu)、对话框 (showDialog)、列表选择弹出框 (ActionSheet)、警告弹出框 (AlertDialog)可以设置isModal为false变成非模态弹窗。
操作菜单 (showActionMenu)
操作菜单通过UIContext中的getPromptAction方法获取到PromptAction对象，再通过该对象调用showActionMenu接口实现，支持在回调或开发者自定义类中使用。
创建并显示操作菜单后，菜单的响应结果会异步返回选中按钮在buttons数组中的索引。
```typescript
import { PromptAction } from '@kit.ArkUI';
let uiContext = this.getUIContext();
let promptAction: PromptAction = uiContext.getPromptAction();
try {
promptAction.showActionMenu({
title: 'showActionMenu Title Info',
buttons: [
{
text: 'item1',
color: '#666666'
},
{
text: 'item2',
color: '#000000'
},
]
})
.then(data => {
console.info('showActionMenu success, click button: ' + data.index);
})
.catch((err: Error) => {
console.error('showActionMenu error: ' + err);
})
} catch (error) {
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170305.49764899197134866676646793417113:50001231000000:2800:AE8CBF9CD2A5C618636C3C627C816AEB84C111307B82D0AF4F9AA876BAAFBE7D.gif)
对话框 (showDialog)
对话框通过UIContext中的getPromptAction方法获取到PromptAction对象，再通过该对象调用showDialog接口实现，支持在回调或开发者自定义类中使用。
创建并显示对话框，对话框响应后异步返回选中按钮在buttons数组中的索引。
```typescript
// xxx.ets
import { PromptAction } from '@kit.ArkUI';
let uiContext = this.getUIContext();
let promptAction: PromptAction = uiContext.getPromptAction();
try {
promptAction.showDialog({
title: 'showDialog Title Info',
message: 'Message Info',
buttons: [
{
text: 'button1',
color: '#000000'
},
{
text: 'button2',
color: '#000000'
}
]
}, (err, data) => {
if (err) {
console.error('showDialog err: ' + err);
return;
}
console.info('showDialog success callback, click button: ' + data.index);
});
} catch (error) {
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170305.08802678055620847606671512368145:50001231000000:2800:C8870086A8FCE6DEF21AEADA34BDFE84A1B0A117D41F9B41A45EF69ECAA3DF54.gif)
选择器弹窗 (PickerDialog)
选择器弹窗通常用于在用户进行某些操作（如点击按钮）时显示特定的信息或选项。
生命周期
弹窗提供了生命周期函数用于通知用户该弹窗的生命周期。
生命周期的触发顺序可看各组件API参考。
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| onDidAppear | () => void | 弹窗弹出时的事件回调。 |
| onDidDisappear | () => void | 弹窗消失时的事件回调。 |
| onWillAppear | () => void | 弹窗显示动效前的事件回调。 |
| onWillDisappear | () => void | 弹窗退出动效前的事件回调。 |
日历选择器弹窗 (CalendarPickerDialog)
日历选择器弹窗提供日历视图，包含年、月和星期信息，通过CalendarPickerDialog接口实现。开发者可调用show函数，定义并弹出日历选择器弹窗。
通过配置 acceptButtonStyle、cancelButtonStyle可以实现自定义按钮样式。
```typescript
// xxx.ets
@Entry
@Component
struct CalendarPickerDialogExample {
private selectedDate: Date = new Date('2024-04-23')
build() {
Column() {
Button("Show CalendarPicker Dialog")
.margin(20)
.onClick(() => {
console.info("CalendarDialog.show")
CalendarPickerDialog.show({
selected: this.selectedDate,
acceptButtonStyle: {
fontColor: '#2787d9',
fontSize: '16fp',
backgroundColor: '#f7f7f7',
borderRadius: 10
},
cancelButtonStyle: {
fontColor: Color.Red,
fontSize: '16fp',
backgroundColor: '#f7f7f7',
borderRadius: 10
},
onAccept: (date: Date)=>{
// 当弹出框再次弹出时显示选中的是上一次确定的日期
this.selectedDate = date
}
})
})
}.width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170305.73359409013883317720768842215787:50001231000000:2800:AD1C5EB66E4C9BAD0E0BE46A3C0C26C0DE8CE27AEDC15D1EE4A946B0948630AF.gif)
日期滑动选择器弹窗 (DatePickerDialog)
开发者可以利用指定的日期范围，创建日期滑动选择器弹窗，将日期信息清晰地展示在弹出的窗口上。
日期滑动选择器弹窗通过UIContext中的showDatePickerDialog接口实现。
弹窗中配置lunarSwitch、showTime为true时，展示切换农历的开关以及时间，当checkbox被选中时，显示农历。当按下确定按钮时，弹窗会通过onDateAccept返回目前所选中的日期。如需弹窗再次弹出时显示选中的是上一次确定的日期，就要在回调中重新给selectTime进行赋值。
```typescript
@Entry
@Component
struct DatePickerDialogExample {
@State selectTime: Date = new Date('2023-12-25T08:30:00');
build() {
Column() {
Button('showDatePickerDialog')
.margin(30)
.onClick(() => {
this.getUIContext().showDatePickerDialog({
start: new Date("2000-1-1"),
end: new Date("2100-12-31"),
selected: this.selectTime,
lunarSwitch: true,
showTime: true,
onDateAccept: (value: Date) => {
this.selectTime = value
console.info("DatePickerDialog:onAccept()" + JSON.stringify(value))
},
})
})
}.width('100%').margin({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170305.30122010585753878093169673389559:50001231000000:2800:7ED51BF9253BA497679DDA5E50BB850A2533AB87F327E2FBB85583822A911447.gif)
该示例通过配置disappearTextStyle、textStyle、selectedTextStyle、acceptButtonStyle、cancelButtonStyle实现了自定义文本以及按钮样式。
```typescript
@Entry
@Component
struct DatePickerDialogExample {
@State selectTime: Date = new Date('2023-12-25T08:30:00');
build() {
Column() {
Button('showDatePickerDialog')
.margin(30)
.onClick(() => {
this.getUIContext().showDatePickerDialog({
start: new Date("2000-1-1"),
end: new Date("2100-12-31"),
selected: this.selectTime,
textStyle: { color: '#2787d9', font: { size: '14fp', weight: FontWeight.Normal } },
selectedTextStyle: { color: '#004aaf', font: { size: '18fp', weight: FontWeight.Regular } },
acceptButtonStyle: {
fontColor: '#2787d9',
fontSize: '16fp',
backgroundColor: '#f7f7f7',
borderRadius: 10
},
cancelButtonStyle: {
fontColor: Color.Red,
fontSize: '16fp',
backgroundColor: '#f7f7f7',
borderRadius: 10
}
})
})
}.width('100%').margin({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170305.90453477130880471553501923916644:50001231000000:2800:B01751B2FF152B4DE632D9347A8BB3507A8352DFB12FA26BF3019602B74FDB07.gif)
时间滑动选择器弹窗 (TimePickerDialog)
开发者可根据24小时的时间区间，创建时间滑动选择器弹窗，将时间信息清晰地展示在弹出的窗口上。
时间滑动选择器弹窗通过UIContext中的showTimePickerDialog接口实现。
该示例通过配置disappearTextStyle、textStyle、selectedTextStyle、acceptButtonStyle、cancelButtonStyle实现了自定义文本以及按钮样式。
```typescript
// xxx.ets
@Entry
@Component
struct TimePickerDialogExample {
@State selectTime: Date = new Date('2023-12-25T08:30:00');
build() {
Column() {
Button('showTimePickerDialog')
.margin(30)
.onClick(() => {
this.getUIContext().showTimePickerDialog({
selected: this.selectTime,
textStyle: { color: '#2787d9', font: { size: '14fp', weight: FontWeight.Normal } },
selectedTextStyle: { color: '#004aaf', font: { size: '18fp', weight: FontWeight.Regular } },
acceptButtonStyle: {
fontColor: '#2787d9',
fontSize: '16fp',
backgroundColor: '#f7f7f7',
borderRadius: 10
},
cancelButtonStyle: {
fontColor: Color.Red,
fontSize: '16fp',
backgroundColor: '#f7f7f7',
borderRadius: 10
}
})
})
}.width('100%').margin({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170305.39082520212855081535548175846129:50001231000000:2800:EFFCA6622581E9E1E612C93F16138A713E29FCCD3D0EE1E93EA663FCC06BAB9C.gif)
文本滑动选择器弹窗 (TextPickerDialog)
开发者可根据指定的选择范围，创建文本滑动选择器弹窗，将文本信息清晰地展示在弹出的窗口上。
文本滑动选择器弹窗通过UIContext中的showTextPickerDialog接口实现。
该示例通过设置range的参数类型为TextCascadePickerRangeContent[]类型实现3列文本选择器弹窗。当按下确定按钮时，弹窗会通过onAccept返回目前所选中文本和索引值。如需弹窗再次弹出时显示选中的是上一次确定的文本，就要在回调中重新给select进行赋值。
```typescript
@Entry
@Component
struct TextPickerDialogExample {
private fruits: TextCascadePickerRangeContent[] = [
{
text: '辽宁省',
children: [{ text: '沈阳市', children: [{ text: '沈河区' }, { text: '和平区' }, { text: '浑南区' }] },
{ text: '大连市', children: [{ text: '中山区' }, { text: '金州区' }, { text: '长海县' }] }]
},
{
text: '吉林省',
children: [{ text: '长春市', children: [{ text: '南关区' }, { text: '宽城区' }, { text: '朝阳区' }] },
{ text: '四平市', children: [{ text: '铁西区' }, { text: '铁东区' }, { text: '梨树县' }] }]
},
{
text: '黑龙江省',
children: [{ text: '哈尔滨市', children: [{ text: '道里区' }, { text: '道外区' }, { text: '南岗区' }] },
{ text: '牡丹江市', children: [{ text: '东安区' }, { text: '西安区' }, { text: '爱民区' }] }]
}
]
private select : number  = 0;
build() {
Column() {
Button('showTextPickerDialog')
.margin(30)
.onClick(() => {
this.getUIContext().showTextPickerDialog({
range: this.fruits,
selected: this.select,
onAccept: (value: TextPickerResult) => {
this.select = value.index as number
}
})
})
}.width('100%').margin({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170305.08028699195461480399155487802736:50001231000000:2800:6D3D344DBCC5320FD904CEF28DCEF648482116E1F329A9C0DCAC7689E5A0E5D3.gif)
列表选择弹窗 (ActionSheet)
列表选择器弹窗适用于呈现多个操作选项，尤其当界面中仅需展示操作列表而无其他内容时。
列表选择器弹窗通过UIContext中的showActionSheet接口实现。
该示例通过配置width、height、transition等接口定义了弹窗的样式以及弹出动效。
```typescript
@Entry
@Component
struct showActionSheetExample {
build() {
Column() {
Button('showActionSheet')
.margin(30)
.onClick(() => {
this.getUIContext().showActionSheet({
title: 'ActionSheet title',
message: 'message',
autoCancel: false,
width: 300,
height: 300,
cornerRadius: 20,
borderWidth: 1,
borderStyle: BorderStyle.Solid,
borderColor: Color.Blue,
backgroundColor: Color.White,
transition: TransitionEffect.asymmetric(TransitionEffect.OPACITY
.animation({ duration: 3000, curve: Curve.Sharp })
.combine(TransitionEffect.scale({ x: 1.5, y: 1.5 }).animation({ duration: 3000, curve: Curve.Sharp })),
TransitionEffect.OPACITY.animation({ duration: 100, curve: Curve.Smooth })
.combine(TransitionEffect.scale({ x: 0.5, y: 0.5 }).animation({ duration: 100, curve: Curve.Smooth }))),
confirm: {
value: 'Confirm button',
action: () => {
console.info('Get Alert Dialog handled')
}
},
alignment: DialogAlignment.Center,
sheets: [
{
title: 'apples',
action: () => {
}
},
{
title: 'bananas',
action: () => {
}
},
{
title: 'pears',
action: () => {
console.log('pears')
}
}
]
})
})
}.width('100%').margin({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170305.22388628788332205922321536741809:50001231000000:2800:285C6F13656C84E5F30AFFC9B5185B23E9D88022F682E555ACA596C11D490AA3.gif)
警告弹窗 (AlertDialog)
需要向用户提问或得到用户的许可时，可使用警告弹窗。
警告弹窗通过UIContext中的showAlertDialog接口实现。
该示例通过配置width、height、transition等接口定义了多个按钮弹窗的样式以及弹出动效。
```typescript
@Entry
@Component
struct showAlertDialogExample {
build() {
Column() {
Button('showAlertDialog')
.margin(30)
.onClick(() => {
this.getUIContext().showAlertDialog(
{
title: 'title',
message: 'text',
autoCancel: true,
alignment: DialogAlignment.Center,
offset: { dx: 0, dy: -20 },
gridCount: 3,
transition: TransitionEffect.asymmetric(TransitionEffect.OPACITY
.animation({ duration: 3000, curve: Curve.Sharp })
.combine(TransitionEffect.scale({ x: 1.5, y: 1.5 }).animation({ duration: 3000, curve: Curve.Sharp })),
TransitionEffect.OPACITY.animation({ duration: 100, curve: Curve.Smooth })
.combine(TransitionEffect.scale({ x: 0.5, y: 0.5 })
.animation({ duration: 100, curve: Curve.Smooth }))),
buttons: [{
value: 'cancel',
action: () => {
console.info('Callback when the first button is clicked')
}
},
{
enabled: true,
defaultFocus: true,
style: DialogButtonStyle.HIGHLIGHT,
value: 'ok',
action: () => {
console.info('Callback when the second button is clicked')
}
}],
}
)
})
}.width('100%').margin({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170305.85122905900414987035751457452383:50001231000000:2800:E9D90C184480CD44490DB87BBC2C279EE1F9DF8618DE1E889E7AA45C0DB44BF5.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-popup-and-menu-components-menu-V14
爬取时间: 2025-04-27 23:25:35
来源: Huawei Developer
Menu是菜单接口，一般用于鼠标右键弹窗、点击弹窗等。具体用法请参考菜单控制。
使用bindContextMenu并设置预览图，菜单弹出时有蒙层，此时为模态。
使用bindMenu或bindContextMenu未设置预览图时，菜单弹出无蒙层，此时为非模态。
生命周期
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| aboutToAppear | () => void | 菜单显示动效前的事件回调。 |
| onAppear | () => void | 菜单弹出时的事件回调。 |
| aboutToDisappear | () => void | 菜单退出动效前的事件回调。 |
| onDisappear | () => void | 菜单消失时的事件回调。 |
创建默认样式的菜单
菜单需要调用bindMenu接口来实现。bindMenu响应绑定组件的点击事件，绑定组件后手势点击对应组件后即可弹出。
```typescript
Button('click for Menu')
.bindMenu([
{
value: 'Menu1',
action: () => {
console.info('handle Menu1 select')
}
}
])
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170305.77787558784640659669965013304904:50001231000000:2800:DE5838ED7C3F152E1C034670673D7AC70DFA631FCE655EC5FB8BE9F0A2D16FF2.png)
创建自定义样式的菜单
当默认样式不满足开发需求时，可使用@Builder自定义菜单内容，通过bindMenu接口进行菜单的自定义。
@Builder开发菜单内的内容
```typescript
class Tmp {
iconStr2: ResourceStr = $r("app.media.view_list_filled")
set(val: Resource) {
this.iconStr2 = val
}
}
@Entry
@Component
struct menuExample {
@State select: boolean = true
private iconStr: ResourceStr = $r("app.media.view_list_filled")
private iconStr2: ResourceStr = $r("app.media.view_list_filled")
@Builder
SubMenu() {
Menu() {
MenuItem({ content: "复制", labelInfo: "Ctrl+C" })
MenuItem({ content: "粘贴", labelInfo: "Ctrl+V" })
}
}
@Builder
MyMenu() {
Menu() {
MenuItem({ startIcon: $r("app.media.icon"), content: "菜单选项" })
MenuItem({ startIcon: $r("app.media.icon"), content: "菜单选项" }).enabled(false)
MenuItem({
startIcon: this.iconStr,
content: "菜单选项",
endIcon: $r("app.media.arrow_right_filled"),
// 当builder参数进行配置时，表示与menuItem项绑定了子菜单。鼠标hover在该菜单项时，会显示子菜单。
builder: this.SubMenu
})
MenuItemGroup({ header: '小标题' }) {
MenuItem({ content: "菜单选项" })
.selectIcon(true)
.selected(this.select)
.onChange((selected) => {
console.info("menuItem select" + selected);
let Str: Tmp = new Tmp()
Str.set($r("app.media.icon"))
})
MenuItem({
startIcon: $r("app.media.view_list_filled"),
content: "菜单选项",
endIcon: $r("app.media.arrow_right_filled"),
builder: this.SubMenu
})
}
MenuItem({
startIcon: this.iconStr2,
content: "菜单选项",
endIcon: $r("app.media.arrow_right_filled")
})
}
}
build() {
// ...
}
}
```
bindMenu属性绑定组件
```typescript
Button('click for Menu')
.bindMenu(this.MyMenu)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170305.09700739202901688153866589562155:50001231000000:2800:F89060FDCEBC405DDF718BDDA4D614AB03BDC761067D7DD202C99E709E6BAD4C.png)
创建支持右键或长按的菜单
通过bindContextMenu接口自定义菜单，设置菜单弹出的触发方式，触发方式为右键或长按。使用bindContextMenu弹出的菜单项是在独立子窗口内的，可显示在应用窗口外部。
-  @Builder开发菜单内的内容与上文写法相同。
-  确认菜单的弹出方式，使用bindContextMenu属性绑定组件。示例中为右键弹出菜单。
```typescript
Button('click for Menu')
.bindContextMenu(this.MyMenu, ResponseType.RightClick)
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-popup-and-menu-components-popup-V14
爬取时间: 2025-04-27 23:25:49
来源: Huawei Developer
Popup属性可绑定在组件上显示气泡弹窗提示，设置弹窗内容、交互逻辑和显示状态。主要用于屏幕录制、信息弹出提醒等显示状态。
气泡分为两种类型，一种是系统提供的气泡PopupOptions，一种是开发者可以自定义的气泡CustomPopupOptions。其中，PopupOptions通过配置primaryButton和secondaryButton来设置带按钮的气泡，CustomPopupOptions通过配置builder来设置自定义的气泡。
气泡可以通过配置mask来实现模态和非模态窗口，mask为true或者颜色值的时候，气泡为模态窗口，mask为false时，气泡为非模态窗口。
文本提示气泡
文本提示气泡常用于只展示带有文本的信息提示，不带有任何交互的场景。Popup属性需绑定组件，当bindPopup属性中参数show为true时会弹出气泡提示。
在Button组件上绑定Popup属性，每次点击Button按钮，handlePopup会切换布尔值，当值为true时，触发bindPopup弹出气泡。
```typescript
@Entry
@Component
struct PopupExample {
@State handlePopup: boolean = false
build() {
Column() {
Button('PopupOptions')
.onClick(() => {
this.handlePopup = !this.handlePopup
})
.bindPopup(this.handlePopup, {
message: 'This is a popup with PopupOptions',
})
}.width('100%').padding({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170306.25107587717644546526084472698859:50001231000000:2800:2BF08F0E9C9767D98E93B61EA91C21526CC317B0356843A1F59C436F5FF5B26A.png)
添加气泡状态变化的事件
通过onStateChange参数为气泡添加状态变化的事件回调，可以判断当前气泡的显示状态。
```typescript
@Entry
@Component
struct PopupExample {
@State handlePopup: boolean = false
build() {
Column() {
Button('PopupOptions')
.onClick(() => {
this.handlePopup = !this.handlePopup
})
.bindPopup(this.handlePopup, {
message: 'This is a popup with PopupOptions',
onStateChange: (e)=> { // 返回当前的气泡状态
if (!e.isVisible) {
this.handlePopup = false
}
}
})
}.width('100%').padding({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170306.76117256999643111496755740821657:50001231000000:2800:22093CC1440CB2B89AFF5F3664B95E8EEE8A7C9FD193E980490E2C3FFF560633.gif)
带按钮的提示气泡
通过primaryButton、secondaryButton属性为气泡最多设置两个Button按钮，通过此按钮进行简单的交互，开发者可以通过配置action参数来设置想要触发的操作。
```typescript
@Entry
@Component
struct PopupExample22 {
@State handlePopup: boolean = false
build() {
Column() {
Button('PopupOptions').margin({ top: 200 })
.onClick(() => {
this.handlePopup = !this.handlePopup
})
.bindPopup(this.handlePopup, {
message: 'This is a popup with PopupOptions',
primaryButton: {
value: 'Confirm',
action: () => {
this.handlePopup = !this.handlePopup
console.info('confirm Button click')
}
},
secondaryButton: {
value: 'Cancel',
action: () => {
this.handlePopup = !this.handlePopup
}
},
onStateChange: (e) => {
if (!e.isVisible) {
this.handlePopup = false
}
}
})
}.width('100%').padding({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170306.18264780610987094350588235007838:50001231000000:2800:B4E49B0EEFA12E230FB771BD90AA1F7FA7C5CFABB75B232CBD6A5AFC3C27EDD2.jpeg)
气泡的动画
气泡通过定义transition控制气泡的进场和出场动画效果。
```typescript
// xxx.ets
@Entry
@Component
struct PopupExample {
@State handlePopup: boolean = false
@State customPopup: boolean = false
// popup构造器定义弹框内容
@Builder popupBuilder() {
Row() {
Text('Custom Popup with transitionEffect').fontSize(10)
}.height(50).padding(5)
}
build() {
Flex({ direction: FlexDirection.Column }) {
// PopupOptions 类型设置弹框内容
Button('PopupOptions')
.onClick(() => {
this.handlePopup = !this.handlePopup
})
.bindPopup(this.handlePopup, {
message: 'This is a popup with transitionEffect',
placementOnTop: true,
showInSubWindow: false,
onStateChange: (e) => {
if (!e.isVisible) {
this.handlePopup = false
}
},
// 设置弹窗显示动效为透明度动效与平移动效的组合效果，无退出动效
transition:TransitionEffect.asymmetric(
TransitionEffect.OPACITY.animation({ duration: 1000, curve: Curve.Ease }).combine(
TransitionEffect.translate({ x: 50, y: 50 })),
TransitionEffect.IDENTITY)
})
.position({ x: 100, y: 150 })
// CustomPopupOptions 类型设置弹框内容
Button('CustomPopupOptions')
.onClick(() => {
this.customPopup = !this.customPopup
})
.bindPopup(this.customPopup, {
builder: this.popupBuilder,
placement: Placement.Top,
showInSubWindow: false,
onStateChange: (e) => {
if (!e.isVisible) {
this.customPopup = false
}
},
// 设置弹窗显示动效与退出动效为缩放动效
transition:TransitionEffect.scale({ x: 1, y: 0 }).animation({ duration: 500, curve: Curve.Ease })
})
.position({ x: 80, y: 300 })
}.width('100%').padding({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170306.95094270444071415437743818632428:50001231000000:2800:B51627A291D3810CD578F4FB3F023A68C302E104E626C1BE1F794C906D861129.gif)
自定义气泡
开发者可以使用CustomPopupOptions的builder创建自定义气泡，@Builder中可以放自定义的内容。除此之外，还可以通过popupColor等参数控制气泡样式。
```typescript
@Entry
@Component
struct Index {
@State customPopup: boolean = false
// popup构造器定义弹框内容
@Builder popupBuilder() {
Row({ space: 2 }) {
Image($r("app.media.icon")).width(24).height(24).margin({ left: 5 })
Text('This is Custom Popup').fontSize(15)
}.width(200).height(50).padding(5)
}
build() {
Column() {
Button('CustomPopupOptions')
.position({x:100,y:200})
.onClick(() => {
this.customPopup = !this.customPopup
})
.bindPopup(this.customPopup, {
builder: this.popupBuilder, // 气泡的内容
placement:Placement.Bottom, // 气泡的弹出位置
popupColor:Color.Pink, // 气泡的背景色
onStateChange: (e) => {
if (!e.isVisible) {
this.customPopup = false
}
}
})
}
.height('100%')
}
}
```
使用者通过配置placement参数将弹出的气泡放到需要提示的位置。弹窗构造器会触发弹出提示信息，来引导使用者完成操作，也让使用者有更好的UI体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170306.04127956422693977204392977042219:50001231000000:2800:485C15A208A0372CC34E67A1CBF36494A1FFCF7059181333F5B291D81A38F035.jpeg)
气泡样式
气泡除了可以通过builder实现自定义气泡，还可以通过接口设置气泡的样式和显示效果。
背景颜色：气泡的背景色默认为透明，但是会有一个默认的模糊效果，手机上为COMPONENT_ULTRA_THICK。
蒙层样式：气泡默认有蒙层，且蒙层的颜色为透明。
显示大小：气泡大小有内部的builder大小或者message的长度决定的。
显示位置：气泡默认显示在宿主组件的下方，可以通过Placement接口来配置其显示位置以及对齐方向。
以下示例通过设置popupColor（背景颜色）、mask（蒙层样式）、width（气泡宽度）、placement（显示位置）实现气泡的样式。
```typescript
// xxx.ets
@Entry
@Component
struct PopupExample {
@State handlePopup: boolean = false
build() {
Column({ space: 100 }) {
Button('PopupOptions')
.onClick(() => {
this.handlePopup = !this.handlePopup
})
.bindPopup(this.handlePopup, {
width: 200,
message: 'This is a popup.',
popupColor: Color.Red, // 设置气泡的背景色
mask: {
color: '#33d9d9d9'
},
placement: Placement.Top,
backgroundBlurStyle: BlurStyle.NONE // 去除背景模糊效果需要关闭气泡的模糊背景
})
}
.width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170306.22071775738636638431938274013084:50001231000000:2800:55785C65EB6E5F24A6AA9F766F6B3ED489844B1E860C112B53281030DD7DFB6C.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-bind-modal-V14
爬取时间: 2025-04-27 23:26:02
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-modal-overview-V14
爬取时间: 2025-04-27 23:26:16
来源: Huawei Developer
模态页面是一种大面板大视图交互式的弹窗，和其他弹窗组件一样，通常用于在保持当前的上下文环境时，临时展示用户需关注的信息或待处理的操作。相比于其他弹窗组件，模态页面的内容都需要开发者通过自定义组件来填充实现，可展示的视图往往也很大。默认需要用户进行交互才能够退出模态页面。ArkUI当前提供了半模态和全模态两类模态页面组件。
使用场景
| 接口 | 使用场景 |
| --- | --- |
| bindContentCover | 用于自定义全屏的模态展示界面，结合转场动画和共享元素动画可实现复杂转场动画效果，如缩略图片点击后查看大图。 |
| bindSheet | 用于半模态展示界面，如分享框。 |
| openBindSheet/ updateBindSheet/closeBindSheet | 用于不依赖UI组件的场景，如全局拉起、更新、关闭。 |
规格约束

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-sheet-page-V14
爬取时间: 2025-04-27 23:26:30
来源: Huawei Developer
半模态页面（bindSheet）默认是模态形式的非全屏弹窗式交互页面，允许部分底层父视图可见，帮助用户在与半模态交互时保留其父视图环境。
半模态页面适用于展示简单的任务或信息面板，例如，个人信息、文本简介、分享面板、创建日程、添加内容等。若需展示可能影响父视图的半模态页面，半模态支持配置为非模态交互形式。
半模态在不同宽度的设备上存在不同的形态能力，开发者对不同宽度的设备上有不同的形态诉求请参考(preferType)属性。可以使用bindSheet构建半模态转场效果,详见模态转场。对于复杂或者冗长的用户流程，建议考虑其他的转场方式替代半模态。如全模态转场和Navigation转场。
使用约束
-  半模态内嵌UIExtension时，不支持再在UIExtension内拉起半模态/弹窗。
-  若无二次确认或者自定义关闭行为的场景，不建议使用shouldDismiss/onWilDismiss接口。
生命周期
半模态页面提供了生命周期函数，用于通知用户该弹窗的生命周期状态。生命周期的触发顺序依次为：onWillAppear -> onAppear -> onWillDisappear -> onDisappear。
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| onWillAppear | () => void | 半模态页面显示（动画开始前）回调函数。 |
| onAppear | () => void | 半模态页面显示（动画结束后）回调函数。 |
| onWillDisappear | () => void | 半模态页面回退（动画开始前）回调函数。 |
| onDisappear | () => void | 半模态页面回退（动画结束后）回调函数。 |
使用嵌套滚动交互
在半模态面板内容区域滑动时的操作优先级：
1.  内容处于最顶部（内容不可滚动时以此状态处理） 上滑时，优先向上扩展面板档位，如无档位可扩展，则滚动内容 下滑时，优先向下收缩面板档位，如无档位可收缩，则关闭面板
2.  内容处于中间位置（可上下滚动） 上/下滑时，优先滚动内容，直至页面内容到达底部/顶部
3.  内容处于底部位置（内容可滚动时） 上滑时，呈现内容区域回弹效果，不切换档位 下滑时，滚动内容直到到达顶部
半模态上述交互默认的嵌套模式为：{Forward：PARENT_FIRST，Backward：SELF_FIRST}
如果开发者希望在面板内容的builder中定义滚动容器，如List、Scroll，并结合半模态的上述交互能力，那么需要在垂直方向上为滚动容器设置嵌套滚动属性。
```typescript
.nestedScroll({
// 可滚动组件往末尾端滚动时的嵌套滚动选项，手势向上
scrollForward: NestedScrollMode.PARENT_FIRST,
// 可滚动组件往起始端滚动时的嵌套滚动选项，手势向下
scrollBackward: NestedScrollMode.SELF_FIRST,
})
```
完整示例代码如下：
```typescript
@Entry
@Component
struct SheetDemo {
@State isShowSheet: boolean = false
private items: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
@Builder
SheetBuilder() {
Column() {
// 第一步：自定义滚动容器
List({ space: '10vp' }) {
ForEach(this.items, (item: number) => {
ListItem() {
Text(String(item)).fontSize(16).fontWeight(FontWeight.Bold)
}.width('90%').height('80vp').backgroundColor('#ff53ecd9').borderRadius(10)
})
}
.alignListItem(ListItemAlign.Center)
.margin({ top: '10vp' })
.width('100%')
.height('900px')
// 第二步：设置滚动组件的嵌套滚动属性
.nestedScroll({
scrollForward: NestedScrollMode.PARENT_FIRST,
scrollBackward: NestedScrollMode.SELF_FIRST,
})
Text("非滚动区域")
.width('100%')
.backgroundColor(Color.Gray)
.layoutWeight(1)
.textAlign(TextAlign.Center)
.align(Alignment.Top)
}.width('100%').height('100%')
}
build() {
Column() {
Button('Open Sheet').width('90%').height('80vp')
.onClick(() => {
this.isShowSheet = !this.isShowSheet
})
.bindSheet($$this.isShowSheet, this.SheetBuilder(), {
detents: [SheetSize.MEDIUM, SheetSize.LARGE, 600],
preferType: SheetType.BOTTOM,
title: { title: '嵌套滚动场景' },
})
}.width('100%').height('100%')
.justifyContent(FlexAlign.Center)
}
}
```
二次确认能力
推荐使用onWillDismiss接口，此接口支持在回调中处理二次确认，或自定义关闭行为。
声明onWillDismiss接口后，半模态页面的所有关闭操作，包括侧滑、点击关闭按钮、点击蒙层和下拉关闭，都需通过调用dismiss方法来实现。若未实现此逻辑，半模态页面将无法响应上述关闭操作。
```typescript
// 第一步：声明onWillDismiss回调
onWillDismiss: ((DismissSheetAction: DismissSheetAction) => {
// 第二步：确认二次回调交互能力，此处用AlertDialog提示 "是否需要关闭半模态"
AlertDialog.show(
{
message: '是否选择关闭半模态',
autoCancel: true,
alignment: DialogAlignment.Bottom,
gridCount: 4,
offset: { dx: 0, dy: -20 },
primaryButton: {
value: 'cancel',
action: () => {
console.info('Callback when the cancel button is clicked')
}
},
secondaryButton: {
enabled: true,
defaultFocus: true,
style: DialogButtonStyle.HIGHLIGHT,
value: 'ok',
// 第三步：确认关闭半模态逻辑所在，此处为AlertDialog的Button回调
action: () => {
// 第四步：上述第三步逻辑触发的时候，调用dismiss()关闭半模态
DismissSheetAction.dismiss()
console.info('Callback when the ok button is clicked')
}
},
cancel: () => {
console.info('AlertDialog Closed callbacks')
}
}
)
})
```
屏蔽部分关闭行为
由于声明了onWillDismiss接口，半模态的关闭行为都需要dismiss处理。可以通过if等逻辑自定义处理关闭逻辑。
下述示例显示半模态页面只在下滑的时候关闭。
```typescript
onWillDismiss: ((DismissSheetAction: DismissSheetAction) => {
if (DismissSheetAction.reason === DismissReason.SLIDE_DOWN) {
DismissSheetAction.dismiss() //注册dismiss行为
}
}),
```
同理可以结合onWillSpringBackWhenDismiss接口实现更好的下滑体验。
类比onWillDismiss，在声明了onWillSpringBackWhenDismiss后，半模态下滑时的回弹操作需要使用 SpringBackAction.springBack()处理，无此逻辑则不会回弹。
具体代码如下，在半模态下滑的时候无需回弹。
```typescript
onWillDismiss: ((DismissSheetAction: DismissSheetAction) => {
if (DismissSheetAction.reason === DismissReason.SLIDE_DOWN) {
DismissSheetAction.dismiss() //注册dismiss行为
}
}),
onWillSpringBackWhenDismiss: ((SpringBackAction: SpringBackAction) => {
//没有注册springBack, 下拉半模态页面无回弹行为
}),
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-contentcover-page-V14
爬取时间: 2025-04-27 23:26:44
来源: Huawei Developer
全模态页面（bindContentCover）是全屏模态形式的弹窗交互页面，完全覆盖底层父视图。适用于查看大图，全屏查看文稿等场景。
使用约束
全模态页面本质上是弹窗类组件，其交互层级默认为应用内顶层。
Navigation导航转场时，新push的页面层级无法超出全模态，其效果仍然显示在模态页面之下。针对此类场景，建议将模态页面的内容迁移至转场页面中实现。例如，在上述情况下，可以使用NavDestination来替代拉起的模态页面，新push的页面层级低于全模态。
生命周期
全模态页面提供了生命周期函数，用于通知应用程序该弹窗的生命周期状态。生命周期的触发顺序依次为：onWillAppear -> onAppear -> onWillDisappear -> onDisappear。
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| onWillAppear | () => void | 全模态页面显示（动画开始前）回调函数。 |
| onAppear | () => void | 全模态页面显示（动画结束后）回调函数。 |
| onWillDisappear | () => void | 全模态页面回退（动画开始前）回调函数。 |
| onDisappear | () => void | 全模态页面回退（动画结束后）回调函数。 |
使用bindContentCover构建全屏模态内容覆盖半模态
全模态与半模态之间存在弹窗式的层级交互。后拉起的模态页面能够覆盖先前的模态页面。若开发者期望实现全屏转场，以覆盖半模态，并在全屏页面侧滑退出后，半模态页面仍保持显示，使用bindSheet结合bindContentCover将满足这一场景诉求。
详见模态转场章节，了解使用bindContentCover构建全屏模态转场效果。
```typescript
import { curves } from '@kit.ArkUI';
interface PersonList {
name: string,
cardnum: string
}
@Entry
@Component
struct BindContentCoverDemo {
private personList: Array<PersonList> = [
{ name: '王**', cardnum: '1234***********789' },
{ name: '宋*', cardnum: '2345***********789' },
{ name: '许**', cardnum: '3456***********789' },
{ name: '唐*', cardnum: '4567***********789' }
];
// 半模态转场控制变量
@State isSheetShow: boolean = false;
// 全模态转场控制变量
@State isPresent: boolean = false;
@Builder
MyContentCoverBuilder() {
Column() {
Row() {
Text('选择乘车人')
.fontSize(20)
.fontColor(Color.White)
.width('100%')
.textAlign(TextAlign.Center)
.padding({ top: 30, bottom: 15 })
}
.backgroundColor(0x007dfe)
Row() {
Text('+ 添加乘车人')
.fontSize(16)
.fontColor(0x333333)
.margin({ top: 10 })
.padding({ top: 20, bottom: 20 })
.width('92%')
.borderRadius(10)
.textAlign(TextAlign.Center)
.backgroundColor(Color.White)
}
Column() {
ForEach(this.personList, (item: PersonList, index: number) => {
Row() {
Column() {
if (index % 2 == 0) {
Column()
.width(20)
.height(20)
.border({ width: 1, color: 0x007dfe })
.backgroundColor(0x007dfe)
} else {
Column()
.width(20)
.height(20)
.border({ width: 1, color: 0x007dfe })
}
}
.width('20%')
Column() {
Text(item.name)
.fontColor(0x333333)
.fontSize(18)
Text(item.cardnum)
.fontColor(0x666666)
.fontSize(14)
}
.width('60%')
.alignItems(HorizontalAlign.Start)
Column() {
Text('编辑')
.fontColor(0x007dfe)
.fontSize(16)
}
.width('20%')
}
.padding({ top: 10, bottom: 10 })
.border({ width: { bottom: 1 }, color: 0xf1f1f1 })
.width('92%')
.backgroundColor(Color.White)
})
}
.padding({ top: 20, bottom: 20 })
Text('确认')
.width('90%')
.height(40)
.textAlign(TextAlign.Center)
.borderRadius(10)
.fontColor(Color.White)
.backgroundColor(0x007dfe)
.onClick(() => {
this.isPresent = !this.isPresent;
})
}
.size({ width: '100%', height: '100%' })
.backgroundColor(0xf5f5f5)
}
@Builder
TripInfo() {
Row() {
Column() {
Text('00:25')
Text('始发站')
}
.width('25%')
Column() {
Text('G1234')
Text('8时1分')
}
.width('25%')
Column() {
Text('08:26')
Text('终点站')
}
.width('25%')
}
}
// 第二步：定义半模态展示界面
// 通过@Builder构建模态展示界面
@Builder
MySheetBuilder() {
Column() {
Column() {
this.TripInfo()
}
.width('92%')
.margin(15)
.backgroundColor(Color.White)
.shadow({ radius: 30, color: '#aaaaaa' })
.borderRadius(10)
Column() {
Text('+ 选择乘车人')
.fontSize(18)
.fontColor(Color.Orange)
.fontWeight(FontWeight.Bold)
.padding({ top: 10, bottom: 10 })
.width('60%')
.textAlign(TextAlign.Center)
.borderRadius(15)
.onClick(() => {
// 第三步：通过全模态接口调起全模态展示界面，新拉起的模态面板默认显示在最上层
this.isPresent = !this.isPresent;
})
// 通过全模态接口，绑定模态展示界面MyContentCoverBuilder。transition属性支持自定义转场效果，此处定义了x轴横向入场
.bindContentCover($$this.isPresent, this.MyContentCoverBuilder(), {
transition: TransitionEffect.translate({ x: 500 }).animation({ curve: curves.springMotion(0.6, 0.8) })
})
}
.padding({ top: 60 })
}
}
build() {
Column() {
Row() {
this.TripInfo()
Text('有票')
.fontColor(Color.Blue)
.width('25%')
}
.width('100%')
.margin({top: 200, bottom: 30})
.borderRadius(10)
.backgroundColor(Color.White)
.onClick(()=>{
this.isSheetShow = !this.isSheetShow
})
// 第一步：定义半模态转场效果
.bindSheet($$this.isSheetShow, this.MySheetBuilder(), {
height: SheetSize.MEDIUM,
title: {title: "确认订单"},
})
}
.width('100%')
.height('100%')
.backgroundColor('#30aaaaaa')
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-create-toast-V14
爬取时间: 2025-04-27 23:26:57
来源: Huawei Developer
即时反馈（Toast）是一种临时性的消息提示框，用于向用户显示简短的操作反馈或状态信息。​它通常在屏幕的底部或顶部短暂弹出，随后在一段时间后自动消失。即时反馈的主要目的是提供简洁、不打扰的信息反馈，避免干扰用户当前的操作流程。
可以通过使用UIContext中的getPromptAction方法获取当前UI上下文关联的PromptAction对象，再通过该对象调用showToast创建并显示文本提示框。
使用建议
-  合理使用弹出场景，而不是频繁的提醒用户。 可以针对以下常用场景使用即时反馈操作，例如，当用户执行某个操作时及时结果反馈，用来提示用户操作是否成功或失败；或是当应用程序的状态发生变化时提供状态更新等。
-  注意文本的信息密度，即时反馈展示时间有限，应当避免长文本的出现。 Toast控件的文本应该清晰可读，字体大小和颜色应该与应用程序的主题相符。除此之外，即时反馈控件本身不应该包含任何可交互的元素，如按钮或链接。
-  杜绝强制占位和密集弹出的提示。 即时反馈作为应用内的轻量通知，应当避免内容布局占用界面内的其他元素信息，如遮盖弹出框的展示内容，从而迷惑用户弹出的内容是否属于弹出框。再或者频繁性的弹出信息内容，且每次弹出之间无时间间隔，影响用户的正常使用。也不要在短时间内频繁弹出新的即时反馈替代上一个。即时反馈的单次显示时长不要超过 3 秒钟，避免影响用户正常的行为操作。
-  遵从系统默认弹出位置。 即时反馈在系统中默认从界面底部弹出，距离底部有一定的安全间距，作为系统性的应用内提示反馈，请遵守系统默认效果，避免与其他弹出类组件内容重叠。特殊场景下可对内容布局进行规避。
即时反馈模式对比
即时反馈提供了两种显示模式，分别为DEFAULT（显示在应用内）、TOP_MOST（显示在应用之上）。
在TOP_MOST类型的Toast显示前，会创建一个全屏大小的子窗（手机上子窗大小和主窗大小一致），然后在该子窗上计算Toast的布局位置，最后显示在该子窗上。具体和DEFAULT模式Toast的差异如下：
| 差异点 | DEFAULT | TOP_MOST |
| --- | --- | --- |
| 是否创建子窗 | 否 | 是 |
| 层级 | 显示在主窗内，层级和主窗一致，一般比较低 | 显示在子窗中，一般比主窗层级高，比其他弹窗类组件层级高，比软键盘和权限弹窗层级低。 |
| 是否避让软键盘 | 软键盘抬起时，必定上移软键盘的高度 | 软键盘抬起时，只有toast被遮挡时，才会避让，且避让后toast底部距离软键盘高度为80vp。 |
| UIExtension内布局 | 以UIExtension为主窗中布局，对齐方式与UIExtension对齐 | 以宿主窗口为主窗中布局，对齐方式与宿主窗口对齐。 |
```typescript
import {promptAction} from '@kit.ArkUI';
@Entry
@Component
struct Index {
build() {
Column({space: 10}) {
TextInput()
Button() {
Text("DEFAULT类型Toast")
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
.width('100%')
.onClick(()=>{
promptAction.showToast({
message:"ok，我是DEFAULT toast",
duration:2000,
showMode: promptAction.ToastShowMode.DEFAULT,
bottom:80
})
})
Button() {
Text("TOPMOST类型Toast")
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
.width('100%')
.onClick(()=>{
promptAction.showToast({
message:"ok，我是TOP_MOST toast",
duration:2000,
showMode: promptAction.ToastShowMode.TOP_MOST,
bottom:85
})
})
}
}
}
```
创建即时反馈
适用于短时间内提示框自动消失的场景。
```typescript
import { LengthMetrics, PromptAction } from '@kit.ArkUI'
import { BusinessError } from '@kit.BasicServicesKit'
@Entry
@Component
struct toastExample {
private uiContext: UIContext = this.getUIContext()
private promptAction: PromptAction = this.uiContext.getPromptAction()
build() {
Column() {
Button('Show toast').fontSize(20)
.onClick(() => {
try {
this.promptAction.showToast({
message: 'Hello World',
duration: 2000
});
} catch (error) {
let message = (error as BusinessError).message
let code = (error as BusinessError).code
console.error(`showToast args error code is ${code}, message is ${message}`);
};
})
}.height('100%').width('100%').justifyContent(FlexAlign.Center)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170306.77093857205159715206238189099857:50001231000000:2800:179BD75B078D480E45700032DDFDD49AEB3E05948AC0C79AB75C1ED3FF428052.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-create-overlaymanager-V14
爬取时间: 2025-04-27 23:27:11
来源: Huawei Developer
浮层（OverlayManager）用于将自定义的UI内容展示在页面（Page）之上，在Dialog、Popup、Menu、BindSheet、BindContentCover和Toast等组件之下，展示的范围为当前窗口安全区内。可适用于常驻悬浮等场景。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170306.56243759401377300969728312202121:50001231000000:2800:B4C78DA1688E84BE6BFDBE1E7E6838399DCDAD4ADF5076C409D76FD092A62079.png)
可以通过使用UIContext中的getOverlayManager方法获取当前UI上下文关联的OverlayManager对象，再通过该对象调用对应方法。
规格约束
设置浮层
在OverlayManager上新增指定节点（addComponentContent）、删除指定节点（removeComponentContent）、显示所有节点（showAllComponentContents）和隐藏所有节点（hideAllComponentContents）。
```typescript
import { ComponentContent, OverlayManager, router } from '@kit.ArkUI';
class Params {
text: string = ""
offset: Position
constructor(text: string, offset: Position) {
this.text = text
this.offset = offset
}
}
@Builder
function builderText(params: Params) {
Column() {
Text(params.text)
.fontSize(30)
.fontWeight(FontWeight.Bold)
}.offset(params.offset)
}
@Entry
@Component
struct OverlayExample {
@State message: string = 'ComponentContent';
private uiContext: UIContext = this.getUIContext()
private overlayNode: OverlayManager = this.uiContext.getOverlayManager()
@StorageLink('contentArray') contentArray: ComponentContent<Params>[] = []
@StorageLink('componentContentIndex') componentContentIndex: number = 0
@StorageLink('arrayIndex') arrayIndex: number = 0
@StorageLink("componentOffset") componentOffset: Position = {x: 0, y: 80}
build() {
Column({space:10}) {
Button("递增componentContentIndex: " + this.componentContentIndex).onClick(()=>{
++this.componentContentIndex
})
Button("递减componentContentIndex: " + this.componentContentIndex).onClick(()=>{
--this.componentContentIndex
})
Button("增加ComponentContent" + this.contentArray.length).onClick(()=>{
let componentContent = new ComponentContent(
this.uiContext, wrapBuilder<[Params]>(builderText),
new Params(this.message + (this.contentArray.length), this.componentOffset)
)
this.contentArray.push(componentContent)
this.overlayNode.addComponentContent(componentContent, this.componentContentIndex)
})
Button("递增arrayIndex: " + this.arrayIndex).onClick(()=>{
++this.arrayIndex
})
Button("递减arrayIndex: " + this.arrayIndex).onClick(()=>{
--this.arrayIndex
})
Button("删除ComponentContent" + this.arrayIndex).onClick(()=>{
if (this.arrayIndex >= 0 && this.arrayIndex < this.contentArray.length) {
let componentContent = this.contentArray.splice(this.arrayIndex, 1)
this.overlayNode.removeComponentContent(componentContent.pop())
} else {
console.info("arrayIndex有误")
}
})
Button("显示ComponentContent" + this.arrayIndex).onClick(()=>{
if (this.arrayIndex >= 0 && this.arrayIndex < this.contentArray.length) {
let componentContent = this.contentArray[this.arrayIndex]
this.overlayNode.showComponentContent(componentContent)
} else {
console.info("arrayIndex有误")
}
})
Button("隐藏ComponentContent" + this.arrayIndex).onClick(()=>{
if (this.arrayIndex >= 0 && this.arrayIndex < this.contentArray.length) {
let componentContent = this.contentArray[this.arrayIndex]
this.overlayNode.hideComponentContent(componentContent)
} else {
console.info("arrayIndex有误")
}
})
Button("显示所有ComponentContent").onClick(()=>{
this.overlayNode.showAllComponentContents()
})
Button("隐藏所有ComponentContent").onClick(()=>{
this.overlayNode.hideAllComponentContents()
})
Button("跳转页面").onClick(()=>{
router.pushUrl({
url: 'pages/Second'
})
})
}
.width('100%')
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170306.07549292343308167915965515787452:50001231000000:2800:8BF266A0679335F71BD587F5DE7FC34FFCA5241A9340F5F51A6F235CE72CB9B0.gif)
显示一个始终在屏幕左侧的悬浮球，点击可以弹出alertDialog弹窗。
```typescript
import { ComponentContent, OverlayManager } from '@kit.ArkUI';
class Params {
context: UIContext
offset: Position
constructor(context: UIContext, offset: Position) {
this.context = context
this.offset = offset
}
}
@Builder
function builderOverlay(params: Params) {
Column() {
Stack(){
}.width(50).height(50).backgroundColor(Color.Yellow).position(params.offset).borderRadius(50)
.onClick(() => {
params.context.showAlertDialog(
{
title: 'title',
message: 'Text',
autoCancel: true,
alignment: DialogAlignment.Center,
gridCount: 3,
confirm: {
value: 'Button',
action: () => {}
},
cancel: () => {}
}
)
})
}.focusable(false).width('100%').height('100%').hitTestBehavior(HitTestMode.Transparent)
}
@Entry
@Component
struct OverlayExample {
@State message: string = 'ComponentContent';
private uiContext: UIContext = this.getUIContext()
private overlayNode: OverlayManager = this.uiContext.getOverlayManager()
private overlayContent:ComponentContent<Params>[] = []
controller: TextInputController = new TextInputController()
aboutToAppear(): void {
let uiContext = this.getUIContext();
let componentContent = new ComponentContent(
this.uiContext, wrapBuilder<[Params]>(builderOverlay),
new Params(uiContext, {x:0, y: 100})
)
this.overlayNode.addComponentContent(componentContent, 0)
this.overlayContent.push(componentContent)
}
aboutToDisappear(): void {
let componentContent = this.overlayContent.pop()
this.overlayNode.removeComponentContent(componentContent)
}
build() {
Column() {
}
.width('100%')
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170306.91370818499028730448459001067828:50001231000000:2800:6449E1D6A162B67D8EB4A82CAAA2FC68D63EEA4C4EB09E6F4AD4B9895A62E6B2.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-draw-graphics-V14
爬取时间: 2025-04-27 23:27:25
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-geometric-shape-drawing-V14
爬取时间: 2025-04-27 23:27:39
来源: Huawei Developer
绘制组件用于在页面绘制图形，Shape组件是绘制组件的父组件，父组件中会描述所有绘制组件均支持的通用属性。具体用法请参考Shape。
创建绘制组件
绘制组件可以由以下两种形式创建：
-  绘制组件使用Shape作为父组件，实现类似SVG的效果。接口调用为以下形式： 该接口用于创建带有父组件的绘制组件，其中value用于设置绘制目标，可将图形绘制在指定的PixelMap对象中，若未设置，则在当前绘制目标中进行绘制。
```typescript
Shape(value?: PixelMap)
```
-  绘制组件单独使用，用于在页面上绘制指定的图形。有7种绘制类型，分别为Circle（圆形）、Ellipse（椭圆形）、Line（直线）、Polyline（折线）、Polygon（多边形）、Path（路径）、Rect（矩形）。以Circle的接口调用为例： 该接口用于在页面绘制圆形，其中width用于设置圆形的宽度，height用于设置圆形的高度，圆形直径由宽高最小值确定。
```typescript
Circle(value?: { width?: string | number, height?: string | number })
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.45270990759905518611247352918865:50001231000000:2800:5E6678A7DC5E375945995C172486B6CA5DC6AB9AD4B5F6B6A01AB48209420E1D.jpg)
形状视口viewport
```typescript
viewPort(value: { x?: number | string, y?: number | string, width?: number | string, height?: number | string })
```
形状视口viewport指定用户空间中的一个矩形，该矩形映射到为关联的SVG元素建立的视区边界。viewport属性的值包含x、y、width和height四个可选参数，x和y表示视区的左上角坐标，width和height表示其尺寸。
以下3个示例讲解viewport具体用法：
-  通过形状视口对图形进行放大与缩小。
```typescript
class tmp{
x:number = 0
y:number = 0
width:number = 75
height:number = 75
}
let viep:tmp = new tmp()
class tmp1{
x:number = 0
y:number = 0
width:number = 300
height:number = 300
}
let viep1:tmp1 = new tmp1()
// 画一个宽高都为75的圆
Text('原始尺寸Circle组件')
Circle({width: 75, height: 75}).fill('#E87361')
Row({space:10}) {
Column() {
// 创建一个宽高都为150的shape组件，背景色为黄色，一个宽高都为75的viewport。用一个蓝色的矩形来填充viewport，在viewport中绘制一个直径为75的圆。
// 绘制结束，viewport会根据组件宽高放大两倍
Text('shape内放大的Circle组件')
Shape() {
Rect().width('100%').height('100%').fill('#0097D4')
Circle({width: 75, height: 75}).fill('#E87361')
}
.viewPort(viep)
.width(150)
.height(150)
.backgroundColor('#F5DC62')
}
Column() {
// 创建一个宽高都为150的shape组件，背景色为黄色，一个宽高都为300的viewport。用一个绿色的矩形来填充viewport，在viewport中绘制一个直径为75的圆。
// 绘制结束，viewport会根据组件宽高缩小两倍。
Text('Shape内缩小的Circle组件')
Shape() {
Rect().width('100%').height('100%').fill('#BDDB69')
Circle({width: 75, height: 75}).fill('#E87361')
}
.viewPort(viep1)
.width(150)
.height(150)
.backgroundColor('#F5DC62')
}
}
```
-  创建一个宽高都为300的shape组件，背景色为黄色，一个宽高都为300的viewport。用一个蓝色的矩形来填充viewport，在viewport中绘制一个半径为75的圆。
```typescript
class tmp{
x:number = 0
y:number = 0
width:number = 300
height:number = 300
}
let viep:tmp = new tmp()
Shape() {
Rect().width("100%").height("100%").fill("#0097D4")
Circle({ width: 150, height: 150 }).fill("#E87361")
}
.viewPort(viep)
.width(300)
.height(300)
.backgroundColor("#F5DC62")
```
-  创建一个宽高都为300的shape组件，背景色为黄色，创建一个宽高都为300的viewport。用一个蓝色的矩形来填充viewport，在viewport中绘制一个半径为75的圆，将viewport向右方和下方各平移150。
```typescript
class tmp{
x:number = -150
y:number = -150
width:number = 300
height:number = 300
}
let viep:tmp = new tmp()
Shape() {
Rect().width("100%").height("100%").fill("#0097D4")
Circle({ width: 150, height: 150 }).fill("#E87361")
}
.viewPort(viep)
.width(300)
.height(300)
.backgroundColor("#F5DC62")
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.09869395206127472513060629184806:50001231000000:2800:9FF0529D8BEA585D66A69FFA5F60C82D34D48460CEE941B8B870861001DB03A7.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.61908309546627202597323375032164:50001231000000:2800:77ECF98E86C834F6009149D2659D4E938FFDEF0934BD274A0BA16B7AF1675625.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.50280872140223070337149824472033:50001231000000:2800:4AB44FEE49FDC4AD9CA41EADB7498A5E171E0825B70317019302AC6D544395B2.jpg)
自定义样式
绘制组件支持通过各种属性对组件样式进行更改。
-  通过fill可以设置组件填充区域颜色。
```typescript
Path()
.width(100)
.height(100)
.commands('M150 0 L300 300 L0 300 Z')
.fill("#E87361")
.strokeWidth(0)
```
-  通过stroke可以设置组件边框颜色。
```typescript
Path()
.width(100)
.height(100)
.fillOpacity(0)
.commands('M150 0 L300 300 L0 300 Z')
.stroke(Color.Red)
```
-  通过strokeOpacity可以设置边框透明度。
```typescript
Path()
.width(100)
.height(100)
.fillOpacity(0)
.commands('M150 0 L300 300 L0 300 Z')
.stroke(Color.Red)
.strokeWidth(10)
.strokeOpacity(0.2)
```
-  通过strokeLineJoin可以设置线条拐角绘制样式。拐角绘制样式分为Bevel(使用斜角连接路径段)、Miter(使用尖角连接路径段)、Round(使用圆角连接路径段)。
```typescript
Polyline()
.width(100)
.height(100)
.fillOpacity(0)
.stroke(Color.Red)
.strokeWidth(8)
.points([[20, 0], [0, 100], [100, 90]])
// 设置折线拐角处为圆弧
.strokeLineJoin(LineJoinStyle.Round)
```
-  通过strokeMiterLimit设置斜接长度与边框宽度比值的极限值。 斜接长度表示外边框外边交点到内边交点的距离，边框宽度即strokeWidth属性的值。strokeMiterLimit取值需大于等于1，且在strokeLineJoin属性取值LineJoinStyle.Miter时生效。
```typescript
Polyline()
.width(100)
.height(100)
.fillOpacity(0)
.stroke(Color.Red)
.strokeWidth(10)
.points([[20, 0], [20, 100], [100, 100]])
// 设置折线拐角处为尖角
.strokeLineJoin(LineJoinStyle.Miter)
// 设置斜接长度与线宽的比值
.strokeMiterLimit(1/Math.sin(45))
Polyline()
.width(100)
.height(100)
.fillOpacity(0)
.stroke(Color.Red)
.strokeWidth(10)
.points([[20, 0], [20, 100], [100, 100]])
.strokeLineJoin(LineJoinStyle.Miter)
.strokeMiterLimit(1.42)
```
-  通过antiAlias设置是否开启抗锯齿，默认值为true（开启抗锯齿）。
```typescript
//开启抗锯齿
Circle()
.width(150)
.height(200)
.fillOpacity(0)
.strokeWidth(5)
.stroke(Color.Black)
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.04998280490271738093545071984397:50001231000000:2800:39DE0D930F589916C6D846956A5CD762434556957B690A1B2AD0F032F8FFF1BF.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.73490166057875618302180885727822:50001231000000:2800:DAB243D3725E42B7F41E73A0A62F7B53C2EA36C442CAF48CDF087D96C2185AFE.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.13089961506201098911099290066624:50001231000000:2800:1036E2678637EFC8C395A237322DB406703B7A8E23424E19F5C47A2BA7B5226A.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.68790566067103376407828992767730:50001231000000:2800:B4E8891A1C96E37331A6077F954208621EDDF74AB50848F92FDC01694D195488.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.25762984306685623090544926348243:50001231000000:2800:DAF4FE9AF8415DB10A48471E12C0C3A8FFAC5CA965682F53FF0E242E4AF64155.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.46451752322065868507308993192200:50001231000000:2800:73136C758E14BE617DABDD5DFD335B88D286200A6DB3B57F13C19E866B07F096.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.69518976413373566785775580311708:50001231000000:2800:36DE251BAAB6536D7486EBEDF2B463E3DACBC6E2C7F4E359092598CFE5E9E7FF.jpg)
场景示例
绘制封闭路径
在Shape的(-80, -5)点绘制一个封闭路径，填充颜色0x317AF7，线条宽度3，边框颜色红色，拐角样式锐角（默认值）。
```typescript
@Entry
@Component
struct ShapeExample {
build() {
Column({ space: 10 }) {
Shape() {
Path().width(200).height(60).commands('M0 0 L400 0 L400 150 Z')
}
.viewPort({ x: -80, y: -5, width: 500, height: 300 })
.fill(0x317AF7)
.stroke(Color.Red)
.strokeWidth(3)
.strokeLineJoin(LineJoinStyle.Miter)
.strokeMiterLimit(5)
}.width('100%').margin({ top: 15 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.41306149425442157988822445311835:50001231000000:2800:14F25DD548C085B4B8D9C103B4A79143EA71EC4BA3C30AE606B7196D092165A3.jpg)
绘制圆和圆环
绘制一个直径为150的圆，和一个直径为150、线条为红色虚线的圆环（宽高设置不一致时以短边为直径）。
```typescript
@Entry
@Component
struct CircleExample {
build() {
Column({ space: 10 }) {
//绘制一个直径为150的圆
Circle({ width: 150, height: 150 })
//绘制一个直径为150、线条为红色虚线的圆环
Circle()
.width(150)
.height(200)
.fillOpacity(0)
.strokeWidth(3)
.stroke(Color.Red)
.strokeDashArray([1, 2])
}.width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.69284795005219438583255824208295:50001231000000:2800:89D95F1B78282A7358DD526B3EEE523CDCDEABBC1980505DBEE12FC7BDEC3AB9.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-drawing-customization-on-canvas-V14
爬取时间: 2025-04-27 23:27:53
来源: Huawei Developer
Canvas提供画布组件，用于自定义绘制图形，开发者使用CanvasRenderingContext2D对象和OffscreenCanvasRenderingContext2D对象在Canvas组件上进行绘制，绘制对象可以是基础形状、文本、图片等。
使用画布组件绘制自定义图形
可以由以下三种形式在画布绘制自定义图形：
-  使用CanvasRenderingContext2D对象在Canvas画布上绘制。
```typescript
@Entry
@Component
struct CanvasExample1 {
//用来配置CanvasRenderingContext2D对象的参数，包括是否开启抗锯齿，true表明开启抗锯齿。
private settings: RenderingContextSettings = new RenderingContextSettings(true)
//用来创建CanvasRenderingContext2D对象，通过在canvas中调用CanvasRenderingContext2D对象来绘制。
private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings)
build() {
Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {
//在canvas中调用CanvasRenderingContext2D对象。
Canvas(this.context)
.width('100%')
.height('100%')
.backgroundColor('#F5DC62')
.onReady(() => {
//可以在这里绘制内容。
this.context.strokeRect(50, 50, 200, 150);
})
}
.width('100%')
.height('100%')
}
}
```
-  离屏绘制是指将需要绘制的内容先绘制在缓存区，再将其转换成图片，一次性绘制到Canvas上，加快了绘制速度。过程为： 具体使用参考OffscreenCanvasRenderingContext2D对象。 在画布组件中，通过CanvasRenderingContext2D对象和OffscreenCanvasRenderingContext2D对象在Canvas组件上进行绘制时调用的接口相同，另接口参数如无特别说明，单位均为vp。
```typescript
@Entry
@Component
struct CanvasExample2 {
//用来配置CanvasRenderingContext2D对象和OffscreenCanvasRenderingContext2D对象的参数，包括是否开启抗锯齿。true表明开启抗锯齿
private settings: RenderingContextSettings = new RenderingContextSettings(true)
private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings)
//用来创建OffscreenCanvas对象，width为离屏画布的宽度，height为离屏画布的高度。通过在canvas中调用OffscreenCanvasRenderingContext2D对象来绘制。
private offCanvas: OffscreenCanvas = new OffscreenCanvas(600, 600)
build() {
Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {
Canvas(this.context)
.width('100%')
.height('100%')
.backgroundColor('#F5DC62')
.onReady(() => {
let offContext = this.offCanvas.getContext("2d", this.settings)
//可以在这里绘制内容
offContext.strokeRect(50, 50, 200, 150);
//将离屏绘值渲染的图像在普通画布上显示
let image = this.offCanvas.transferToImageBitmap();
this.context.transferFromImageBitmap(image);
})
}
.width('100%')
.height('100%')
}
}
```
-  在Canvas上加载Lottie动画时，需要先按照如下方式下载Lottie。 具体接口请参考Lottie。
```typescript
import lottie from '@ohos/lottie'
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.50831590789671342731085434607072:50001231000000:2800:4433DEDF1E7C9C02E6883642A71E5ACF866F4F714E1EAC50F2C5F5F4930CC412.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170307.83130747948218015144345006007639:50001231000000:2800:256384AA372A0E9D53733F090BA5AAD278969BBCD341C9B5B8CCEABCEDE50684.jpg)
初始化画布组件
onReady(event: () => void)是Canvas组件初始化完成时的事件回调，调用该事件后，可获取Canvas组件的确定宽高，进一步使用CanvasRenderingContext2D对象和OffscreenCanvasRenderingContext2D对象调用相关API进行图形绘制。
```typescript
Canvas(this.context)
.width('100%')
.height('100%')
.backgroundColor('#F5DC62')
.onReady(() => {
this.context.fillStyle = '#0097D4';
this.context.fillRect(50, 50, 100, 100);
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170308.59396617663042506787839278662642:50001231000000:2800:3718B613AFE5F7BA6475B28A9AF74A254616AFDD3428E176C76CC19EBBB79856.jpg)
画布组件绘制方式
在Canvas组件生命周期接口onReady()调用之后，开发者可以直接使用canvas组件进行绘制。或者可以脱离Canvas组件和onReady()生命周期，单独定义Path2d对象构造理想的路径，并在onReady()调用之后使用Canvas组件进行绘制。
-  通过CanvasRenderingContext2D对象和OffscreenCanvasRenderingContext2D对象直接调用相关API进行绘制。
```typescript
Canvas(this.context)
.width('100%')
.height('100%')
.backgroundColor('#F5DC62')
.onReady(() => {
this.context.beginPath();
this.context.moveTo(50, 50);
this.context.lineTo(280, 160);
this.context.stroke();
})
```
-  先单独定义path2d对象构造理想的路径，再通过调用CanvasRenderingContext2D对象和OffscreenCanvasRenderingContext2D对象的stroke接口或者fill接口进行绘制，具体使用可以参考Path2D对象。
```typescript
Canvas(this.context)
.width('100%')
.height('100%')
.backgroundColor('#F5DC62')
.onReady(() => {
let region = new Path2D();
region.arc(100, 75, 50, 0, 6.28);
this.context.stroke(region);
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170308.48381391605076058011667742077391:50001231000000:2800:58747A27F0DA5FFDD82C719DF0D7C1358EB4141BF7C091578BC6DBE444E7C3D5.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170308.95186390744517505378525658644704:50001231000000:2800:2E5F1A2F42BB30AB04ED2F7D97FBF6D6F10792600C0BED404BB9336992B0726B.jpg)
画布组件常用方法
OffscreenCanvasRenderingContext2D对象和CanvasRenderingContext2D对象提供了大量的属性和方法，可以用来绘制文本、图形，处理像素等，是Canvas组件的核心。常用接口有fill（对封闭路径进行填充）、clip（设置当前路径为剪切路径）、stroke（进行边框绘制操作）等等，同时提供了fillStyle（指定绘制的填充色）、globalAlpha（设置透明度）与strokeStyle（设置描边的颜色）等属性修改绘制内容的样式。将通过以下几个方面简单介绍画布组件常见使用方法：
-  基础形状绘制。 可以通过arc（绘制弧线路径）、ellipse（绘制一个椭圆）、rect（创建矩形路径）等接口绘制基础形状。
```typescript
Canvas(this.context)
.width('100%')
.height('100%')
.backgroundColor('#F5DC62')
.onReady(() => {
//绘制矩形
this.context.beginPath();
this.context.rect(100, 50, 100, 100);
this.context.stroke();
//绘制圆形
this.context.beginPath();
this.context.arc(150, 250, 50, 0, 6.28);
this.context.stroke();
//绘制椭圆
this.context.beginPath();
this.context.ellipse(150, 450, 50, 100, Math.PI * 0.25, Math.PI * 0, Math.PI * 2);
this.context.stroke();
})
```
-  文本绘制。 可以通过fillText（文本填充）、strokeText（文本描边）等接口进行文本绘制，示例中设置了font为50像素高加粗的"sans-serif"字体，然后调用fillText方法在(50, 100)处绘制文本"Hello World!"，设置strokeStyle为红色，lineWidth为2，font为50像素高加粗的"sans-serif"字体，然后调用strokeText方法在(50, 150)处绘制文本"Hello World!"的轮廓。
```typescript
Canvas(this.context)
.width('100%')
.height('100%')
.backgroundColor('#F5DC62')
.onReady(() => {
// 文本填充
this.context.font = '50px bolder sans-serif';
this.context.fillText("Hello World!", 50, 100);
// 文本描边
this.context.strokeStyle = "#ff0000"
this.context.lineWidth = 2
this.context.font = '50px bolder sans-serif';
this.context.strokeText("Hello World!", 50, 150);
})
```
-  绘制图片和图像像素信息处理。 可以通过drawImage（图像绘制）、putImageData（使用ImageData数据填充新的矩形区域）等接口绘制图片，通过createImageData（创建新的ImageData 对象）、getPixelMap（以当前canvas指定区域内的像素创建PixelMap对象）、getImageData（以当前canvas指定区域内的像素创建ImageData对象）等接口进行图像像素信息处理。
```typescript
@Entry
@Component
struct GetImageData {
private settings: RenderingContextSettings = new RenderingContextSettings(true)
private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings)
private offCanvas: OffscreenCanvas = new OffscreenCanvas(600, 600)
private img: ImageBitmap = new ImageBitmap("/common/images/1234.png")
build() {
Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {
Canvas(this.context)
.width('100%')
.height('100%')
.backgroundColor('#F5DC62')
.onReady(() => {
let offContext = this.offCanvas.getContext("2d", this.settings)
// 使用drawImage接口将图片画在（0，0）为起点，宽高130的区域
offContext.drawImage(this.img, 0, 0, 130, 130);
// 使用getImageData接口，获得canvas组件区域中，（50，50）为起点，宽高130范围内的绘制内容
let imagedata = offContext.getImageData(50, 50, 130, 130);
// 使用putImageData接口将得到的ImageData画在起点为（150， 150）的区域中
offContext.putImageData(imagedata, 150, 150);
// 将离屏绘制的内容画到canvas组件上
let image = this.offCanvas.transferToImageBitmap();
this.context.transferFromImageBitmap(image);
})
}
.width('100%')
.height('100%')
}
}
```
-  其他方法。 Canvas中还提供其他类型的方法。渐变（CanvasGradient对象）相关的方法：createLinearGradient（创建一个线性渐变色）、createRadialGradient（创建一个径向渐变色）等。
```typescript
Canvas(this.context)
.width('100%')
.height('100%')
.backgroundColor('#F5DC62')
.onReady(() => {
//创建一个径向渐变色的CanvasGradient对象
let grad = this.context.createRadialGradient(200, 200, 50, 200, 200, 200)
//为CanvasGradient对象设置渐变断点值，包括偏移和颜色
grad.addColorStop(0.0, '#E87361');
grad.addColorStop(0.5, '#FFFFF0');
grad.addColorStop(1.0, '#BDDB69');
//用CanvasGradient对象填充矩形
this.context.fillStyle = grad;
this.context.fillRect(0, 0, 400, 400);
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170308.05871352157520095031861834120215:50001231000000:2800:291F8F8B8316415E6731B1793BD67F7F28306CED6139D8CCE0F0D67A2D312ACC.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170308.39452821752611654800227900491668:50001231000000:2800:61C9A5A267EEF44A8131FFB7F8DEDBFDCBC096FD0E63F9216A7E6DA025B912FC.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170308.95750157637446435702427038962594:50001231000000:2800:CBACCDFE54700E47DA674303BE53EE858BDD5F48A6E5BBCFB8F6B4FFF92F5FDC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170308.54785353300079921833147601023302:50001231000000:2800:556C6C9AF2EF33ADA170DBE16195841D46512A9CD50D9907B1AFA6B9D02AA424.jpg)
场景示例
-  规则基础形状绘制。
```typescript
@Entry
@Component
struct ClearRect {
private settings: RenderingContextSettings = new RenderingContextSettings(true);
private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);
build() {
Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {
Canvas(this.context)
.width('100%')
.height('100%')
.backgroundColor('#F5DC62')
.onReady(() => {
// 设定填充样式，填充颜色设为蓝色
this.context.fillStyle = '#0097D4';
// 以(50, 50)为左上顶点，画一个宽高200的矩形
this.context.fillRect(50, 50, 200, 200);
// 以(70, 70)为左上顶点，清除宽150高100的区域
this.context.clearRect(70, 70, 150, 100);
})
}
.width('100%')
.height('100%')
}
}
```
-  不规则图形绘制。
```typescript
@Entry
@Component
struct Path2d {
private settings: RenderingContextSettings = new RenderingContextSettings(true);
private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);
build() {
Row() {
Column() {
Canvas(this.context)
.width('100%')
.height('100%')
.backgroundColor('#F5DC62')
.onReady(() => {
// 使用Path2D的接口构造一个五边形
let path = new Path2D();
path.moveTo(150, 50);
path.lineTo(50, 150);
path.lineTo(100, 250);
path.lineTo(200, 250);
path.lineTo(250, 150);
path.closePath();
// 设定填充色为蓝色
this.context.fillStyle = '#0097D4';
// 使用填充的方式，将Path2D描述的五边形绘制在canvas组件内部
this.context.fill(path);
})
}
.width('100%')
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170308.92750358517655763016256535142116:50001231000000:2800:EB822AF6B3944BBED49630B473306478C6B8E6E6DD8FF69C26E8A26AD0637B0B.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170308.88086017188269873233106603817318:50001231000000:2800:1FE5664F8EC657FFE8A184D6184ACEE8B832AAC391572F0257CA3EDE00AB0C23.jpg)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-use-animation-V14
爬取时间: 2025-04-27 23:28:06
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-animation-V14
爬取时间: 2025-04-27 23:28:20
来源: Huawei Developer
UI（用户界面）中包含开发者与设备进行交互时所看到的各种组件（如时间、壁纸等）。属性作为接口，用于控制组件的行为。例如，开发者可通过位置属性调整组件在屏幕上的位置。
属性值的变化，通常会引起UI的变化。动画可在UI发生改变时，添加流畅的过渡效果。如果不加入动画，属性将在一瞬间完成变化。造成突兀感的同时，容易导致用户失去视觉焦点。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170308.84535768074144218936270112518553:50001231000000:2800:19467D6461EEE3611DF5A09C7567FDC3B2E3A1BEAD159CB8F6E4AA0489770AC2.gif)
动画的目的包括：
在需要为UI变化添加过渡的场景，都可以使用动画，如开机、应用启动退出、下拉进入控制中心等。这些动画可向用户提供关于其操作的反馈，并有助于让用户始终关注界面。
ArkUI中提供多种动画接口（属性动画、转场动画等），用于驱动属性值按照设定的动画参数，从起始值逐渐变化到终点值。尽管变化过程中参数值并非绝对的连续，而是具有一定的离散性。但由于人眼会产生视觉暂留，所以最终看到的就是一个“连续“的动画。UI的一次改变称为一个动画帧，对应一次屏幕刷新。决定动画流畅度的一个重要指标就是帧率FPS（Frame Per Second），即每秒的动画帧数，帧率越高则动画就会越流畅。ArkUI中，动画参数包含了如动画时长、动画曲线等参数。动画曲线作为主要因素，决定了属性值变化的规律。以线性动画曲线为例，在动画时长内，属性值将从起点值匀速变化到终点值。属性过快或过慢的变化，都可能带来不好的视觉感受，影响用户体验。因此动画参数特别是动画曲线，需要结合场景和曲线特点进行设计和调整。
动画接口驱动属性值按照动画参数决定的规律，从原来的状态连续过渡到新的状态，进而在UI上产生的连续视觉效果。本文将按照如下结构，提供各种动画的使用方法和注意事项，使开发者快速学习动画。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170308.84052773341470402552573507365676:50001231000000:2800:E06457C568159FDA8EF9A3F5E3CC191DA5547802E1E9353B4FCE273488671BCD.png)
-  属性动画：最基础的动画类型，按照动画参数逐帧驱动属性的变化，产生一帧帧的动画效果。除其中的自定义属性动画外，动画过程的驱动由系统完成，应用侧不感知动画过程。
-  转场动画：为组件在出现和消失时添加过渡动画。为了保证动画一致性，部分接口动画曲线已内置，不支持开发者自定义。
-  组件动画：组件提供默认动效（如List的滑动动效）便于开发者使用，同时部分组件还支持定制化动效。
-  动画曲线：介绍传统曲线和弹簧曲线的特点和使用方式。动画曲线影响属性值的运动规律，进而决定界面的动画效果。
-  动画衔接：介绍如何实现动画与动画之间、手势与动画之间的自然过渡。
-  高阶动画效果：介绍模糊、大阴影和颜色渐变等高阶效果接口的使用方法。
-  帧动画：系统侧提供在动画过程中的插值结果，由开发者每帧修改属性值产生动画，相比于属性动画，有可实现暂停的优点，但性能不如属性动画。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-animation-attribute-V14
爬取时间: 2025-04-27 23:28:34
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-attribute-animation-overview-V14
爬取时间: 2025-04-27 23:28:48
来源: Huawei Developer
属性接口（以下简称属性）包含尺寸属性、布局属性、位置属性等多种类型，用于控制组件的行为。针对当前界面上的组件，其部分属性（如位置属性）的变化会引起UI的变化。添加动画可以让属性值从起点逐渐变化到终点，从而产生连续的动画效果。根据变化时是否能够添加动画，可以将属性分为可动画属性和不可动画属性。判断一种属性是否适合作为可动画属性主要有两个标准：
1.  属性变化能够引起UI的变化。例如，enabled属性用于控制组件是否可以响应点击、触摸等事件，但enable属性的变化不会引起UI的变化，因此不适合作为可动画属性。
2.  属性在变化时适合添加动画作为过渡。例如，focusable属性决定当前组件是否可以获得焦点，当focusable属性发生变化时，应立即切换到终点值以响应用户行为，不应该加入动画效果，因此不适合作为可动画属性。
属性接口分类说明：
-  可动画属性： 系统可动画属性： 自定义可动画属性：通过自定义属性动画机制抽象出的可动画属性。
-  系统可动画属性：
-  自定义可动画属性：通过自定义属性动画机制抽象出的可动画属性。
-  不可动画属性：zIndex、focusable等。
-  系统可动画属性：
-  自定义可动画属性：通过自定义属性动画机制抽象出的可动画属性。
| 分类 | 说明 |
| --- | --- |
| 布局属性 | 位置、大小、内边距、外边距、对齐方式、权重等。 |
| 仿射变换 | 平移、旋转、缩放、锚点等。 |
| 背景 | 背景颜色、背景模糊等。 |
| 内容 | 文字大小、文字颜色，图片对齐方式、模糊等。 |
| 前景 | 前景颜色等。 |
| Overlay | Overlay属性等。 |
| 外观 | 透明度、圆角、边框、阴影等。 |
| ... | ... |
通常，可动画属性的参数数据类型必须具备连续性，即可以通过插值方法来填补数据点之间的空隙，达到视觉上的连续效果。但属性的参数数据类型是否能够进行插值并非决定属性是否可动画的关键因素。例如，对于设置元素水平方向布局的direction属性，其参数数据类型是枚举值。但是，由于位置属性是可动画属性，ArkUI同样支持在其属性值改变引起组件位置变化时添加动画。
对于可动画属性，系统不仅提供通用属性，还支持自定义可动画属性。
-  系统可动画属性：组件自带的支持改变UI界面的属性接口，如位置、缩放、模糊等。
-  自定义可动画属性：ArkUI提供@AnimatableExtend装饰器用于自定义可动画属性。开发者可从自定义绘制的内容中抽象出可动画属性，用于控制每帧绘制的内容，如自定义绘制音量图标。通过自定义可动画属性，可以为ArkUI中部分原本不支持动画的属性添加动画。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-attribute-animation-apis-V14
爬取时间: 2025-04-27 23:29:02
来源: Huawei Developer
通过可动画属性改变引起UI上产生的连续视觉效果，即为属性动画。属性动画是最基础易懂的动画，ArkUI提供两种属性动画接口animateTo和animation驱动组件属性按照动画曲线等动画参数进行连续的变化，产生属性动画。
| 属性动画接口 | 作用域 | 原理 | 使用场景 |
| --- | --- | --- | --- |
| animateTo | 闭包内改变属性引起的界面变化。 作用于出现消失转场。 | 通用函数，对闭包前界面和闭包中的状态变量引起的界面之间的差异做动画。 支持多次调用，支持嵌套。 | 适用对多个可动画属性配置相同动画参数的动画。 需要嵌套使用动画的场景。 |
| animation | 组件通过属性接口绑定的属性变化引起的界面变化。 | 识别组件的可动画属性变化，自动添加动画。 组件的接口调用是从下往上执行，animation只会作用于在其之上的属性调用。 组件可以根据调用顺序对多个属性设置不同的animation。 | 适用于对多个可动画属性配置不同参数动画的场景。 |
闭包内改变属性引起的界面变化。
作用于出现消失转场。
通用函数，对闭包前界面和闭包中的状态变量引起的界面之间的差异做动画。
支持多次调用，支持嵌套。
适用对多个可动画属性配置相同动画参数的动画。
需要嵌套使用动画的场景。
识别组件的可动画属性变化，自动添加动画。
组件的接口调用是从下往上执行，animation只会作用于在其之上的属性调用。
组件可以根据调用顺序对多个属性设置不同的animation。
使用animateTo产生属性动画
animateTo接口参数中，value指定AnimateParam对象（包括时长、Curve等）event为动画的闭包函数，闭包内变量改变产生的属性动画将遵循相同的动画参数。
直接使用animateTo可能导致实例不明确的问题，建议使用getUIContext获取UIContext实例，并使用animateTo调用绑定实例的animateTo。
```typescript
import { curves } from '@kit.ArkUI';
@Entry
@Component
struct AnimateToDemo {
@State animate: boolean = false;
// 第一步: 声明相关状态变量
@State rotateValue: number = 0; // 组件一旋转角度
@State translateX: number = 0; // 组件二偏移量
@State opacityValue: number = 1; // 组件二透明度
// 第二步：将状态变量设置到相关可动画属性接口
build() {
Row() {
// 组件一
Column() {
}
.rotate({ angle: this.rotateValue })
.backgroundColor('#317AF7')
.justifyContent(FlexAlign.Center)
.width(100)
.height(100)
.borderRadius(30)
.onClick(() => {
this.getUIContext()?.animateTo({ curve: curves.springMotion() }, () => {
this.animate = !this.animate;
// 第三步：闭包内通过状态变量改变UI界面
// 这里可以写任何能改变UI的逻辑比如数组添加，显隐控制，系统会检测改变后的UI界面与之前的UI界面的差异，对有差异的部分添加动画
// 组件一的rotate属性发生变化，所以会给组件一添加rotate旋转动画
this.rotateValue = this.animate ? 90 : 0;
// 组件二的透明度发生变化，所以会给组件二添加透明度的动画
this.opacityValue = this.animate ? 0.6 : 1;
// 组件二的translate属性发生变化，所以会给组件二添加translate偏移动画
this.translateX = this.animate ? 50 : 0;
})
})
// 组件二
Column() {
}
.justifyContent(FlexAlign.Center)
.width(100)
.height(100)
.backgroundColor('#D94838')
.borderRadius(30)
.opacity(this.opacityValue)
.translate({ x: this.translateX })
}
.width('100%')
.height('100%')
.justifyContent(FlexAlign.Center)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170309.31942518412508210820548210282601:50001231000000:2800:187F42490F9D3E33FCA3DD5E8FBE9B538D5156ABC743BC1EEE241058AB46CA1C.gif)
使用animation产生属性动画
相比于animateTo接口需要把要执行动画的属性的修改放在闭包中，animation接口无需使用闭包，把animation接口加在要做属性动画的可动画属性后即可。animation只要检测到其绑定的可动画属性发生变化，就会自动添加属性动画，animateTo则必须在动画闭包内改变可动画属性的值从而生成动画。
```typescript
import { curves } from '@kit.ArkUI';
@Entry
@Component
struct AnimationDemo {
@State animate: boolean = false;
// 第一步: 声明相关状态变量
@State rotateValue: number = 0; // 组件一旋转角度
@State translateX: number = 0; // 组件二偏移量
@State opacityValue: number = 1; // 组件二透明度
// 第二步：将状态变量设置到相关可动画属性接口
build() {
Row() {
// 组件一
Column() {
}
.opacity(this.opacityValue)
.rotate({ angle: this.rotateValue })
// 第三步：通过属性动画接口开启属性动画
.animation({ curve: curves.springMotion() })
.backgroundColor('#317AF7')
.justifyContent(FlexAlign.Center)
.width(100)
.height(100)
.borderRadius(30)
.onClick(() => {
this.animate = !this.animate;
// 第四步：闭包内通过状态变量改变UI界面
// 这里可以写任何能改变UI的逻辑比如数组添加，显隐控制，系统会检测改变后的UI界面与之前的UI界面的差异，对有差异的部分添加动画
// 组件一的rotate属性发生变化，所以会给组件一添加rotate旋转动画
this.rotateValue = this.animate ? 90 : 0;
// 组件二的translate属性发生变化，所以会给组件二添加translate偏移动画
this.translateX = this.animate ? 50 : 0;
// 父组件column的opacity属性有变化，会导致其子节点的透明度也变化，所以这里会给column和其子节点的透明度属性都加动画
this.opacityValue = this.animate ? 0.6 : 1;
})
// 组件二
Column() {
}
.justifyContent(FlexAlign.Center)
.width(100)
.height(100)
.backgroundColor('#D94838')
.borderRadius(30)
.opacity(this.opacityValue)
.translate({ x: this.translateX })
.animation({ curve: curves.springMotion() })
}
.width('100%')
.height('100%')
.justifyContent(FlexAlign.Center)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170309.76689109117139024274719194064956:50001231000000:2800:CF3A2255EFB9C47D59180DB8C2F0E0CEAC957EE1F0A130CFB227208B3F842FC6.gif)
-  在对组件的位置大小的变化做动画的时候，由于布局属性的改变会触发测量布局，性能开销大。scale属性的改变不会触发测量布局，性能开销小。因此，在组件位置大小持续发生变化的场景，如跟手触发组件大小变化的场景，推荐适用scale。
-  属性动画应该作用于始终存在的组件，对于将要出现或者将要消失的组件的动画应该使用转场动画。
-  尽量不要使用动画结束回调。属性动画是对已经发生的状态进行的动画，不需要开发者去处理结束的逻辑。如果要使用结束回调，一定要正确处理连续操作的数据管理。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-custom-attribute-animation-V14
爬取时间: 2025-04-27 23:29:16
来源: Huawei Developer
属性动画是可动画属性的参数值发生变化时，引起UI上产生的连续视觉效果。当参数值发生连续变化，且设置到可以引起UI发生变化的属性接口上时，就可以实现属性动画。
ArkUI提供@AnimatableExtend装饰器，用于自定义可动画属性接口。由于参数的数据类型必须具备一定程度的连续性，自定义可动画属性接口的参数类型仅支持number类型和实现AnimatableArithmetic<T>接口的自定义类型。通过自定义可动画属性接口和可动画数据类型，在使用animateTo或animation执行动画时，通过逐帧回调函数修改不可动画属性接口的值，能够让不可动画属性接口实现动画效果。也可通过逐帧回调函数每帧修改可动画属性的值，实现逐帧布局的效果。
使用number数据类型和@AnimatableExtend装饰器改变Text组件宽度实现逐帧布局的效果
```typescript
// 第一步：使用@AnimatableExtend装饰器，自定义可动画属性接口
@AnimatableExtend(Text)
function animatableWidth(width: number) {
.width(width) // 调用系统属性接口，逐帧回调函数每帧修改可动画属性的值，实现逐帧布局的效果。
}
@Entry
@Component
struct AnimatablePropertyExample {
@State textWidth: number = 80;
build() {
Column() {
Text("AnimatableProperty")
.animatableWidth(this.textWidth)// 第二步：将自定义可动画属性接口设置到组件上
.animation({ duration: 2000, curve: Curve.Ease }) // 第三步:为自定义可动画属性接口绑定动画
Button("Play")
.onClick(() => {
this.textWidth = this.textWidth == 80 ? 160 : 80; // 第四步：改变自定义可动画属性的参数，产生动画
})
}.width("100%")
.padding(10)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170309.66915736639907147809432327217605:50001231000000:2800:83AF57C71DF464DBB07F83A23A94FE77AB5E8BE3F928109D009E32653E595302.gif)
使用自定义数据类型和@AnimatableExtend装饰器改变图形形状
```typescript
declare type Point = number[];
// 定义可动画属性接口的参数类型，实现AnimatableArithmetic<T>接口中加法、减法、乘法和判断相等函数
class PointClass extends Array<number> {
constructor(value: Point) {
super(value[0], value[1])
}
add(rhs: PointClass): PointClass {
let result: Point = new Array<number>() as Point;
for (let i = 0; i < 2; i++) {
result.push(rhs[i] + this[i])
}
return new PointClass(result);
}
subtract(rhs: PointClass): PointClass {
let result: Point = new Array<number>() as Point;
for (let i = 0; i < 2; i++) {
result.push(this[i] - rhs[i]);
}
return new PointClass(result);
}
multiply(scale: number): PointClass {
let result: Point = new Array<number>() as Point;
for (let i = 0; i < 2; i++) {
result.push(this[i] * scale)
}
return new PointClass(result);
}
}
// 定义可动画属性接口的参数类型，实现AnimatableArithmetic<T>接口中加法、减法、乘法和判断相等函数
// 模板T支持嵌套实现AnimatableArithmetic<T>的类型
class PointVector extends Array<PointClass> implements AnimatableArithmetic<Array<Point>> {
constructor(initialValue: Array<Point>) {
super();
if (initialValue.length) {
initialValue.forEach((p: Point) => this.push(new PointClass(p)))
}
}
// implement the IAnimatableArithmetic interface
plus(rhs: PointVector): PointVector {
let result = new PointVector([]);
const len = Math.min(this.length, rhs.length)
for (let i = 0; i < len; i++) {
result.push(this[i].add(rhs[i]))
}
return result;
}
subtract(rhs: PointVector): PointVector {
let result = new PointVector([]);
const len = Math.min(this.length, rhs.length)
for (let i = 0; i < len; i++) {
result.push(this[i].subtract(rhs[i]))
}
return result;
}
multiply(scale: number): PointVector {
let result = new PointVector([]);
for (let i = 0; i < this.length; i++) {
result.push(this[i].multiply(scale))
}
return result;
}
equals(rhs: PointVector): boolean {
if (this.length !== rhs.length) {
return false;
}
for (let index = 0, size = this.length; index < size; ++index) {
if (this[index][0] !== rhs[index][0] || this[index][1] !== rhs[index][1]) {
return false;
}
}
return true;
}
}
// 自定义可动画属性接口
@AnimatableExtend(Polyline)
function animatablePoints(points: PointVector) {
.points(points)
}
@Entry
@Component
struct AnimatedShape {
squareStartPointX: number = 75;
squareStartPointY: number = 25;
squareWidth: number = 150;
squareEndTranslateX: number = 50;
squareEndTranslateY: number = 50;
@State pointVec1: PointVector = new PointVector([
[this.squareStartPointX, this.squareStartPointY],
[this.squareStartPointX + this.squareWidth, this.squareStartPointY],
[this.squareStartPointX + this.squareWidth, this.squareStartPointY + this.squareWidth],
[this.squareStartPointX, this.squareStartPointY + this.squareWidth]
]);
@State pointVec2: PointVector = new PointVector([
[this.squareStartPointX + this.squareEndTranslateX, this.squareStartPointY + this.squareStartPointY],
[this.squareStartPointX + this.squareWidth + this.squareEndTranslateX,
this.squareStartPointY + this.squareStartPointY],
[this.squareStartPointX + this.squareWidth, this.squareStartPointY + this.squareWidth],
[this.squareStartPointX, this.squareStartPointY + this.squareWidth]
]);
@State color: Color = Color.Green;
@State fontSize: number = 20.0;
@State polyline1Vec: PointVector = this.pointVec1;
@State polyline2Vec: PointVector = this.pointVec2;
build() {
Row() {
Polyline()
.width(300)
.height(200)
.backgroundColor("#0C000000")
.fill('#317AF7')
.animatablePoints(this.polyline1Vec)
.animation({ duration: 2000, delay: 0, curve: Curve.Ease })
.onClick(() => {
if (this.polyline1Vec.equals(this.pointVec1)) {
this.polyline1Vec = this.pointVec2;
} else {
this.polyline1Vec = this.pointVec1;
}
})
}
.width('100%').height('100%').justifyContent(FlexAlign.Center)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170309.39456597329520830134591367135798:50001231000000:2800:B17B1D3984159185B2D0349AF8F8B2A2892C890E52D9EBDA0CDA9A1B99BD5D42.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-animation-transition-V14
爬取时间: 2025-04-27 23:29:30
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-transition-overview-V14
爬取时间: 2025-04-27 23:29:43
来源: Huawei Developer
转场动画是指对将要出现或消失的组件做动画，对始终出现的组件做动画应使用属性动画。转场动画主要为了让开发者从繁重的消失节点管理中解放出来，如果用属性动画做组件转场，开发者需要在动画结束回调中删除组件节点。同时，由于动画结束前已经删除的组件节点可能会重新出现，还需要在结束回调中增加对节点状态的判断。
转场动画分为基础转场和高级模板化转场，有如下几类：
-  出现/消失转场：对新增、消失的控件实现动画效果，是通用的基础转场效果。
-  导航转场：页面的路由转场方式，对应一个界面消失，另外一个界面出现的动画效果，如设置应用一级菜单切换到二级界面。
-  模态转场：新的界面覆盖在旧的界面之上的动画，旧的界面不消失，新的界面出现，如弹框就是典型的模态转场动画。
-  共享元素转场 (一镜到底)：共享元素转场是一种界面切换时对相同或者相似的元素做的一种位置和大小匹配的过渡动画效果。
-  页面转场动画（不推荐）：页面的路由转场方式，可以通过在pageTransition函数中自定义页面入场和页面退场的转场动效。为了实现更好的转场效果，推荐使用导航转场和模态转场。
-  旋转屏动画：旋转屏动画主要分为两类：布局切换的旋转屏动画和透明度变化的旋转屏动画，旨在实现屏幕显示方向变化时的自然过渡。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-enter-exit-transition-V14
爬取时间: 2025-04-27 23:29:57
来源: Huawei Developer
transition是基础的组件转场接口，用于实现一个组件出现或者消失时的动画效果。可以通过TransitionEffect对象的组合使用，定义出各式效果。
表1转场效果接口
| 转场效果 | 说明 | 动画 |
| --- | --- | --- |
| IDENTITY | 禁用转场效果。 | 无。 |
| OPACITY | 默认的转场效果，透明度转场。 | 出现时透明度从0到1，消失时透明度从1到0。 |
| SLIDE | 滑动转场效果。 | 出现时从窗口左侧滑入，消失时从窗口右侧滑出。 |
| translate | 通过设置组件平移创建转场效果。 | 出现时为translate接口设置的值到默认值0，消失时为默认值0到translate接口设置的值。 |
| rotate | 通过设置组件旋转创建转场效果。 | 出现时为rotate接口设置的值到默认值0，消失时为默认值0到rotate接口设置的值。 |
| opacity | 通过设置透明度参数创建转场效果。 | 出现时为opacity设置的值到默认透明度1，消失时为默认透明度1到opacity设置的值。 |
| move | 通过TransitionEdge创建从窗口哪条边缘出来的效果。 | 出现时从TransitionEdge方向滑入，消失时滑出到TransitionEdge方向。 |
| asymmetric | 通过此方法组合非对称的出现消失转场效果。 - appear:出现转场的效果。 - disappear：消失转场的效果。 | 出现时采用appear设置的TransitionEffect出现效果，消失时采用disappear设置的TransitionEffect消失效果。 |
| combine | 组合其他TransitionEffect。 | 组合其他TransitionEffect，一起生效。 |
| animation | 定义转场效果的动画参数： - 如果不定义会跟随animateTo的动画参数。 - 不支持通过控件的animation接口配置动画参数。 - TransitionEffect中animation的onFinish不生效。 | 调用顺序时从上往下，上面TransitionEffect的animation也会作用到下面TransitionEffect。 |
通过此方法组合非对称的出现消失转场效果。
- appear:出现转场的效果。
- disappear：消失转场的效果。
定义转场效果的动画参数：
- 如果不定义会跟随animateTo的动画参数。
- 不支持通过控件的animation接口配置动画参数。
- TransitionEffect中animation的onFinish不生效。
1.  创建TransitionEffect。
```typescript
// 出现时会是所有转场效果的出现效果叠加，消失时会是所有消失转场效果的叠加
// 用于说明各个effect跟随的动画参数
private effect: object =
TransitionEffect.OPACITY // 创建了透明度转场效果，这里没有调用animation接口，会跟随animateTo的动画参数
// 通过combine方法，添加缩放转场效果，并指定了springMotion(0.6, 1.2)曲线
.combine(TransitionEffect.scale({ x: 0, y: 0 }).animation({ curve: curves.springMotion(0.6, 1.2) }))
// 添加旋转转场效果，这里的动画参数会跟随上面的TransitionEffect，也就是springMotion(0.6, 1.2)
.combine(TransitionEffect.rotate({ angle: 90 }))
// 添加平移转场效果，动画参数会跟随其之上带animation的TransitionEffect，也就是springMotion(0.6, 1.2)
.combine(TransitionEffect.translate({ x: 150, y: 150 })
// 添加move转场效果，并指定了springMotion曲线
.combine(TransitionEffect.move(TransitionEdge.END)).animation({curve: curves.springMotion()}))
// 添加非对称的转场效果，由于这里没有设置animation，会跟随上面的TransitionEffect的animation效果，也就是springMotion
.combine(TransitionEffect.asymmetric(TransitionEffect.scale({ x: 0, y: 0 }), TransitionEffect.rotate({ angle: 90 })));
```
2.  将转场效果通过transition接口设置到组件。
```typescript
Text('test')
.transition(this.effect)
```
3.  新增或者删除组件触发转场。
```typescript
@State isPresent: boolean = true;
// ...
if (this.isPresent) {
Text('test')
.transition(this.effect)
}
// ...
// 控制新增或者删除组件
// 方式一：将控制变量放到animateTo闭包内，未通过animation接口定义动画参数的TransitionEffect将跟随animateTo的动画参数
this.getUIContext()?.animateTo({ curve: curves.springMotion() }, () => {
this.isPresent = false;
})
// 方式二：直接控制删除或者新增组件，动画参数由TransitionEffect的animation接口配置
this.isPresent = false;
```
完整的示例代码和效果如下，示例中采用直接删除或新增组件的方式触发转场，也可以替换为在animateTo闭包内改变控制变量触发转场。
```typescript
import { curves } from '@kit.ArkUI';
@Entry
@Component
struct TransitionEffectDemo {
@State isPresent: boolean = false;
// 第一步，创建TransitionEffect
private effect: TransitionEffect =
// 创建默认透明度转场效果,并指定了springMotion(0.6, 0.8)曲线
TransitionEffect.OPACITY.animation({
curve: curves.springMotion(0.6, 0.8)
})// 通过combine方法,这里的动画参数会跟随上面的TransitionEffect，也就是springMotion(0.6, 0.8)
.combine(TransitionEffect.scale({
x: 0,
y: 0
}))// 添加旋转转场效果，这里的动画参数会跟随上面带animation的TransitionEffect，也就是springMotion(0.6, 0.8)
.combine(TransitionEffect.rotate({ angle: 90 }))// 添加平移转场效果，这里的动画参数使用指定的springMotion()
.combine(TransitionEffect.translate({ y: 150 })
.animation({ curve: curves.springMotion() }))// 添加move转场效果，这里的动画参数会跟随上面的TransitionEffect，也就是springMotion()
.combine(TransitionEffect.move(TransitionEdge.END))
build() {
Stack() {
if (this.isPresent) {
Column() {
Text('ArkUI')
.fontWeight(FontWeight.Bold)
.fontSize(20)
.fontColor(Color.White)
}
.justifyContent(FlexAlign.Center)
.width(150)
.height(150)
.borderRadius(10)
.backgroundColor(0xf56c6c)
// 第二步：将转场效果通过transition接口设置到组件
.transition(this.effect)
}
// 边框
Column()
.width(155)
.height(155)
.border({
width: 5,
radius: 10,
color: Color.Black
})
// 第三步：新增或者删除组件触发转场，控制新增或者删除组件
Button('Click')
.margin({ top: 320 })
.onClick(() => {
this.isPresent = !this.isPresent;
})
}
.width('100%')
.height('60%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170309.05503315600219373517343241367514:50001231000000:2800:61E3BA4E8E3AF2086F109590493D4AC2FF287AECFCF95B7CCEED1FFD0C1E1AA4.gif)
对多个组件添加转场效果时，可以通过在animation动画参数中配置不同的delay值，实现组件渐次出现消失的效果：
```typescript
const ITEM_COUNTS = 9;
const ITEM_COLOR = '#ED6F21';
const INTERVAL = 30;
const DURATION = 300;
@Entry
@Component
struct Index1 {
@State isGridShow: boolean = false;
private dataArray: number[] = new Array(ITEM_COUNTS);
aboutToAppear(): void {
for (let i = 0; i < ITEM_COUNTS; i++) {
this.dataArray[i] = i;
}
}
build() {
Stack() {
if (this.isGridShow) {
Grid() {
ForEach(this.dataArray, (item: number, index: number) => {
GridItem() {
Stack() {
Text((item + 1).toString())
}
.size({ width: 50, height: 50 })
.backgroundColor(ITEM_COLOR)
.transition(TransitionEffect.OPACITY
.combine(TransitionEffect.scale({ x: 0.5, y: 0.5 }))// 对每个方格的转场添加delay，实现组件的渐次出现消失效果
.animation({ duration: DURATION, curve: Curve.Friction, delay: INTERVAL * index }))
.borderRadius(10)
}
// 消失时，如果不对方格的所有父控件添加转场效果，则方格的消失转场不会生效
// 此处让方格的父控件在出现消失转场时一直以0.99的透明度显示，使得方格的转场效果不受影响
.transition(TransitionEffect.opacity(0.99))
}, (item: number) => item.toString())
}
.columnsTemplate('1fr 1fr 1fr')
.rowsGap(15)
.columnsGap(15)
.size({ width: 180, height: 180 })
// 消失时，如果不对方格的所有父控件添加转场效果，则方格的消失转场不会生效
// 此处让父控件在出现消失转场时一直以0.99的透明度显示，使得方格的转场效果不受影响
.transition(TransitionEffect.opacity(0.99))
}
}
.size({ width: '100%', height: '100%' })
.onClick(() => {
this.getUIContext()?.animateTo({
duration: DURATION + INTERVAL * (ITEM_COUNTS - 1),
curve: Curve.Friction
}, () => {
this.isGridShow = !this.isGridShow;
})
})
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170309.36574541329004086784746185656474:50001231000000:2800:DF8633E00EA63D7C9EB6D3B9E94BFB01CAEC6ED7F88D6AB167EC45D66CFA9F12.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-modal-transition-V14
爬取时间: 2025-04-27 23:30:11
来源: Huawei Developer
模态转场是新的界面覆盖在旧的界面上，旧的界面不消失的一种转场方式。
表1模态转场接口
| 接口 | 说明 | 使用场景 |
| --- | --- | --- |
| bindContentCover | 弹出全屏的模态组件。 | 用于自定义全屏的模态展示界面，结合转场动画和共享元素动画可实现复杂转场动画效果，如缩略图片点击后查看大图。 |
| bindSheet | 弹出半模态组件。 | 用于半模态展示界面，如分享框。 |
| bindMenu | 弹出菜单，点击组件后弹出。 | 需要Menu菜单的场景，如一般应用的“+”号键。 |
| bindContextMenu | 弹出菜单，长按或者右键点击后弹出。 | 长按浮起效果，一般结合拖拽框架使用，如桌面图标长按浮起。 |
| bindPopup | 弹出Popup弹框。 | Popup弹框场景，如点击后对某个组件进行临时说明。 |
| if | 通过if新增或删除组件。 | 用来在某个状态下临时显示一个界面，这种方式的返回导航需要由开发者监听接口实现。 |
使用bindContentCover构建全屏模态转场效果
bindContentCover接口用于为组件绑定全屏模态页面，在组件出现和消失时可通过设置转场参数ModalTransition添加过渡动效。
1.  定义全屏模态转场效果bindContentCover。
2.  定义模态展示界面。
```typescript
// 通过@Builder构建模态展示界面
@Builder MyBuilder() {
Column() {
Text('my model view')
}
// 通过转场动画实现出现消失转场动画效果，transition需要加在builder下的第一个组件
.transition(TransitionEffect.translate({ y: 1000 }).animation({ curve: curves.springMotion(0.6, 0.8) }))
}
```
3.  通过模态接口调起模态展示界面，通过转场动画或者共享元素动画去实现对应的动画效果。
```typescript
// 模态转场控制变量
@State isPresent: boolean = false;
Button('Click to present model view')
// 通过选定的模态接口，绑定模态展示界面，ModalTransition是内置的ContentCover转场动画类型，这里选择None代表系统不加默认动画，通过onDisappear控制状态变量变换
.bindContentCover(this.isPresent, this.MyBuilder(), {
modalTransition: ModalTransition.NONE,
onDisappear: () => {
if (this.isPresent) {
this.isPresent = !this.isPresent;
}
}
})
.onClick(() => {
// 改变状态变量，显示模态界面
this.isPresent = !this.isPresent;
})
```
完整示例代码和效果如下。
```typescript
import { curves } from '@kit.ArkUI';
interface PersonList {
name: string,
cardnum: string
}
@Entry
@Component
struct BindContentCoverDemo {
private personList: Array<PersonList> = [
{ name: '王**', cardnum: '1234***********789' },
{ name: '宋*', cardnum: '2345***********789' },
{ name: '许**', cardnum: '3456***********789' },
{ name: '唐*', cardnum: '4567***********789' }
];
// 第一步：定义全屏模态转场效果bindContentCover
// 模态转场控制变量
@State isPresent: boolean = false;
// 第二步：定义模态展示界面
// 通过@Builder构建模态展示界面
@Builder
MyBuilder() {
Column() {
Row() {
Text('选择乘车人')
.fontSize(20)
.fontColor(Color.White)
.width('100%')
.textAlign(TextAlign.Center)
.padding({ top: 30, bottom: 15 })
}
.backgroundColor(0x007dfe)
Row() {
Text('+ 添加乘车人')
.fontSize(16)
.fontColor(0x333333)
.margin({ top: 10 })
.padding({ top: 20, bottom: 20 })
.width('92%')
.borderRadius(10)
.textAlign(TextAlign.Center)
.backgroundColor(Color.White)
}
Column() {
ForEach(this.personList, (item: PersonList, index: number) => {
Row() {
Column() {
if (index % 2 == 0) {
Column()
.width(20)
.height(20)
.border({ width: 1, color: 0x007dfe })
.backgroundColor(0x007dfe)
} else {
Column()
.width(20)
.height(20)
.border({ width: 1, color: 0x007dfe })
}
}
.width('20%')
Column() {
Text(item.name)
.fontColor(0x333333)
.fontSize(18)
Text(item.cardnum)
.fontColor(0x666666)
.fontSize(14)
}
.width('60%')
.alignItems(HorizontalAlign.Start)
Column() {
Text('编辑')
.fontColor(0x007dfe)
.fontSize(16)
}
.width('20%')
}
.padding({ top: 10, bottom: 10 })
.border({ width: { bottom: 1 }, color: 0xf1f1f1 })
.width('92%')
.backgroundColor(Color.White)
})
}
.padding({ top: 20, bottom: 20 })
Text('确认')
.width('90%')
.height(40)
.textAlign(TextAlign.Center)
.borderRadius(10)
.fontColor(Color.White)
.backgroundColor(0x007dfe)
.onClick(() => {
this.isPresent = !this.isPresent;
})
}
.size({ width: '100%', height: '100%' })
.backgroundColor(0xf5f5f5)
// 通过转场动画实现出现消失转场动画效果
.transition(TransitionEffect.translate({ y: 1000 }).animation({ curve: curves.springMotion(0.6, 0.8) }))
}
build() {
Column() {
Row() {
Text('确认订单')
.fontSize(20)
.fontColor(Color.White)
.width('100%')
.textAlign(TextAlign.Center)
.padding({ top: 30, bottom: 60 })
}
.backgroundColor(0x007dfe)
Column() {
Row() {
Column() {
Text('00:25')
Text('始发站')
}
.width('30%')
Column() {
Text('G1234')
Text('8时1分')
}
.width('30%')
Column() {
Text('08:26')
Text('终点站')
}
.width('30%')
}
}
.width('92%')
.padding(15)
.margin({ top: -30 })
.backgroundColor(Color.White)
.shadow({ radius: 30, color: '#aaaaaa' })
.borderRadius(10)
Column() {
Text('+ 选择乘车人')
.fontSize(18)
.fontColor(Color.Orange)
.fontWeight(FontWeight.Bold)
.padding({ top: 10, bottom: 10 })
.width('60%')
.textAlign(TextAlign.Center)
.borderRadius(15)// 通过选定的模态接口，绑定模态展示界面，ModalTransition是内置的ContentCover转场动画类型，这里选择DEFAULT代表设置上下切换动画效果，通过onDisappear控制状态变量变换。
.bindContentCover(this.isPresent, this.MyBuilder(), {
modalTransition: ModalTransition.DEFAULT,
onDisappear: () => {
if (this.isPresent) {
this.isPresent = !this.isPresent;
}
}
})
.onClick(() => {
// 第三步：通过模态接口调起模态展示界面，通过转场动画或者共享元素动画去实现对应的动画效果
// 改变状态变量，显示模态界面
this.isPresent = !this.isPresent;
})
}
.padding({ top: 60 })
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170309.25982803092851199677601999327042:50001231000000:2800:8A82B1CB403D40FF9FA2A6879DB739FCACAF885EF6D719221668987EB77E29B5.gif)
使用bindSheet构建半模态转场效果
bindSheet属性可为组件绑定半模态页面，在组件出现时可通过设置自定义或默认的内置高度确定半模态大小。构建半模态转场动效的步骤基本与使用bindContentCover构建全屏模态转场动效相同。
完整示例和效果如下。
```typescript
@Entry
@Component
struct BindSheetDemo {
// 半模态转场显示隐藏控制
@State isShowSheet: boolean = false;
private menuList: string[] = ['不要辣', '少放辣', '多放辣', '不要香菜', '不要香葱', '不要一次性餐具', '需要一次性餐具'];
// 通过@Builder构建半模态展示界面
@Builder
mySheet() {
Column() {
Flex({ direction: FlexDirection.Row, wrap: FlexWrap.Wrap }) {
ForEach(this.menuList, (item: string) => {
Text(item)
.fontSize(16)
.fontColor(0x333333)
.backgroundColor(0xf1f1f1)
.borderRadius(8)
.margin(10)
.padding(10)
})
}
.padding({ top: 18 })
}
.width('100%')
.height('100%')
.backgroundColor(Color.White)
}
build() {
Column() {
Text('口味与餐具')
.fontSize(28)
.padding({ top: 30, bottom: 30 })
Column() {
Row() {
Row()
.width(10)
.height(10)
.backgroundColor('#a8a8a8')
.margin({ right: 12 })
.borderRadius(20)
Column() {
Text('选择点餐口味和餐具')
.fontSize(16)
.fontWeight(FontWeight.Medium)
}
.alignItems(HorizontalAlign.Start)
Blank()
Row()
.width(12)
.height(12)
.margin({ right: 15 })
.border({
width: { top: 2, right: 2 },
color: 0xcccccc
})
.rotate({ angle: 45 })
}
.borderRadius(15)
.shadow({ radius: 100, color: '#ededed' })
.width('90%')
.alignItems(VerticalAlign.Center)
.padding({ left: 15, top: 15, bottom: 15 })
.backgroundColor(Color.White)
// 通过选定的半模态接口，绑定模态展示界面，style中包含两个参数，一个是设置半模态的高度，不设置时默认高度是Large，一个是是否显示控制条DragBar，默认是true显示控制条，通过onDisappear控制状态变量变换。
.bindSheet(this.isShowSheet, this.mySheet(), {
height: 300,
dragBar: false,
onDisappear: () => {
this.isShowSheet = !this.isShowSheet;
}
})
.onClick(() => {
this.isShowSheet = !this.isShowSheet;
})
}
.width('100%')
}
.width('100%')
.height('100%')
.backgroundColor(0xf1f1f1)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170309.95393068837175234193305036234058:50001231000000:2800:31ACCA9AD9886AF9FAD0D7595C05301E7FAF40245A39B0E7D52C10CD152C8E81.gif)
使用bindMenu实现菜单弹出效果
bindMenu为组件绑定弹出式菜单，通过点击触发。完整示例和效果如下。
```typescript
class BMD{
value:ResourceStr = ''
action:() => void = () => {}
}
@Entry
@Component
struct BindMenuDemo {
// 第一步: 定义一组数据用来表示菜单按钮项
@State items:BMD[] = [
{
value: '菜单项1',
action: () => {
console.info('handle Menu1 select')
}
},
{
value: '菜单项2',
action: () => {
console.info('handle Menu2 select')
}
},
]
build() {
Column() {
Button('click')
.backgroundColor(0x409eff)
.borderRadius(5)
// 第二步: 通过bindMenu接口将菜单数据绑定给元素
.bindMenu(this.items)
}
.justifyContent(FlexAlign.Center)
.width('100%')
.height(437)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170309.70612902496509492537090752670691:50001231000000:2800:14DAB4011FECECD9EB85F4234050056269B8A46D018CE7F453A0D8F7CE91295A.gif)
使用bindContextMenu实现菜单弹出效果
bindContextMenu为组件绑定弹出式菜单，通过长按或右键点击触发。
完整示例和效果如下。
```typescript
@Entry
@Component
struct BindContextMenuDemo {
private menu: string[] = ['保存图片', '收藏', '搜一搜'];
private pics: Resource[] = [$r('app.media.icon_1'), $r('app.media.icon_2')];
// 通过@Builder构建自定义菜单项
@Builder myMenu() {
Column() {
ForEach(this.menu, (item: string) => {
Row() {
Text(item)
.fontSize(18)
.width('100%')
.textAlign(TextAlign.Center)
}
.padding(15)
.border({ width: { bottom: 1 }, color: 0xcccccc })
})
}
.width(140)
.borderRadius(15)
.shadow({ radius: 15, color: 0xf1f1f1 })
.backgroundColor(0xf1f1f1)
}
build() {
Column() {
Row() {
Text('查看图片')
.fontSize(20)
.fontColor(Color.White)
.width('100%')
.textAlign(TextAlign.Center)
.padding({ top: 20, bottom: 20 })
}
.backgroundColor(0x007dfe)
Column() {
ForEach(this.pics, (item: Resource) => {
Row(){
Image(item)
.width('100%')
.draggable(false)
}
.padding({ top: 20, bottom: 20, left: 10, right: 10 })
.bindContextMenu(this.myMenu, ResponseType.LongPress)
})
}
}
.width('100%')
.alignItems(HorizontalAlign.Center)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170310.61748445767679836609011075121357:50001231000000:2800:C6E4C275EEE2630A66BB05C914089746C37706BCD2CAE55DCE6F3EA9F0A246A2.gif)
使用bindPopUp实现气泡弹窗效果
bindpopup属性可为组件绑定弹窗，并设置弹窗内容，交互逻辑和显示状态。
完整示例和代码如下。
```typescript
@Entry
@Component
struct BindPopupDemo {
// 第一步：定义变量控制弹窗显示
@State customPopup: boolean = false;
// 第二步：popup构造器定义弹框内容
@Builder popupBuilder() {
Column({ space: 2 }) {
Row().width(64)
.height(64)
.backgroundColor(0x409eff)
Text('Popup')
.fontSize(10)
.fontColor(Color.White)
}
.justifyContent(FlexAlign.SpaceAround)
.width(100)
.height(100)
.padding(5)
}
build() {
Column() {
Button('click')
// 第四步：创建点击事件，控制弹窗显隐
.onClick(() => {
this.customPopup = !this.customPopup;
})
.backgroundColor(0xf56c6c)
// 第三步：使用bindPopup接口将弹窗内容绑定给元素
.bindPopup(this.customPopup, {
builder: this.popupBuilder,
placement: Placement.Top,
maskColor: 0x33000000,
popupColor: 0xf56c6c,
enableArrow: true,
onStateChange: (e) => {
if (!e.isVisible) {
this.customPopup = false;
}
}
})
}
.justifyContent(FlexAlign.Center)
.width('100%')
.height(437)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170310.67841945603253699199676958617815:50001231000000:2800:9763A31F2F1FCCE04C79F9F4E219CFC1EFCA3DE9ABA5D38018E3CB90B5B1CBCE.gif)
使用if实现模态转场
上述模态转场接口需要绑定到其他组件上，通过监听状态变量改变调起模态界面。同时，也可以通过if范式，通过新增/删除组件实现模态转场效果。
完整示例和代码如下。
```typescript
@Entry
@Component
struct ModalTransitionWithIf {
private listArr: string[] = ['WLAN', '蓝牙', '个人热点', '连接与共享'];
private shareArr: string[] = ['投屏', '打印', 'VPN', '私人DNS', 'NFC'];
// 第一步：定义状态变量控制页面显示
@State isShowShare: boolean = false;
private shareFunc(): void {
this.getUIContext()?.animateTo({ duration: 500 }, () => {
this.isShowShare = !this.isShowShare;
})
}
build(){
// 第二步：定义Stack布局显示当前页面和模态页面
Stack() {
Column() {
Column() {
Text('设置')
.fontSize(28)
.fontColor(0x333333)
}
.width('90%')
.padding({ top: 30, bottom: 15 })
.alignItems(HorizontalAlign.Start)
TextInput({ placeholder: '输入关键字搜索' })
.width('90%')
.height(40)
.margin({ bottom: 10 })
.focusable(false)
List({ space: 12, initialIndex: 0 }) {
ForEach(this.listArr, (item: string, index: number) => {
ListItem() {
Row() {
Row() {
Text(`${item.slice(0, 1)}`)
.fontColor(Color.White)
.fontSize(14)
.fontWeight(FontWeight.Bold)
}
.width(30)
.height(30)
.backgroundColor('#a8a8a8')
.margin({ right: 12 })
.borderRadius(20)
.justifyContent(FlexAlign.Center)
Column() {
Text(item)
.fontSize(16)
.fontWeight(FontWeight.Medium)
}
.alignItems(HorizontalAlign.Start)
Blank()
Row()
.width(12)
.height(12)
.margin({ right: 15 })
.border({
width: { top: 2, right: 2 },
color: 0xcccccc
})
.rotate({ angle: 45 })
}
.borderRadius(15)
.shadow({ radius: 100, color: '#ededed' })
.width('90%')
.alignItems(VerticalAlign.Center)
.padding({ left: 15, top: 15, bottom: 15 })
.backgroundColor(Color.White)
}
.width('100%')
.onClick(() => {
// 第五步：改变状态变量，显示模态页面
if(item.slice(-2) === '共享'){
this.shareFunc();
}
})
}, (item: string): string => item)
}
.width('100%')
}
.width('100%')
.height('100%')
.backgroundColor(0xfefefe)
// 第三步：在if中定义模态页面，显示在最上层，通过if控制模态页面出现消失
if(this.isShowShare){
Column() {
Column() {
Row() {
Row() {
Row()
.width(16)
.height(16)
.border({
width: { left: 2, top: 2 },
color: 0x333333
})
.rotate({ angle: -45 })
}
.padding({ left: 15, right: 10 })
.onClick(() => {
this.shareFunc();
})
Text('连接与共享')
.fontSize(28)
.fontColor(0x333333)
}
.padding({ top: 30 })
}
.width('90%')
.padding({bottom: 15})
.alignItems(HorizontalAlign.Start)
List({ space: 12, initialIndex: 0 }) {
ForEach(this.shareArr, (item: string) => {
ListItem() {
Row() {
Row() {
Text(`${item.slice(0, 1)}`)
.fontColor(Color.White)
.fontSize(14)
.fontWeight(FontWeight.Bold)
}
.width(30)
.height(30)
.backgroundColor('#a8a8a8')
.margin({ right: 12 })
.borderRadius(20)
.justifyContent(FlexAlign.Center)
Column() {
Text(item)
.fontSize(16)
.fontWeight(FontWeight.Medium)
}
.alignItems(HorizontalAlign.Start)
Blank()
Row()
.width(12)
.height(12)
.margin({ right: 15 })
.border({
width: { top: 2, right: 2 },
color: 0xcccccc
})
.rotate({ angle: 45 })
}
.borderRadius(15)
.shadow({ radius: 100, color: '#ededed' })
.width('90%')
.alignItems(VerticalAlign.Center)
.padding({ left: 15, top: 15, bottom: 15 })
.backgroundColor(Color.White)
}
.width('100%')
}, (item: string): string => item)
}
.width('100%')
}
.width('100%')
.height('100%')
.backgroundColor(0xffffff)
// 第四步：定义模态页面出现消失转场方式
.transition(TransitionEffect.OPACITY
.combine(TransitionEffect.translate({ x: '100%' }))
.combine(TransitionEffect.scale({ x: 0.95, y: 0.95 })))
}
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170310.84474406312429183405606804433191:50001231000000:2800:B3327C1FE00164A0B5CFD2614A0855D368440F4BA494DD3A3F11710F20835777.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-shared-element-transition-V14
爬取时间: 2025-04-27 23:30:27
来源: Huawei Developer
共享元素转场是一种界面切换时对相同或者相似的两个元素做的一种位置和大小匹配的过渡动画效果，也称一镜到底动效。
如下例所示，在点击图片后，该图片消失，同时在另一个位置出现新的图片，二者之间内容相同，可以对它们添加一镜到底动效。左图为不添加一镜到底动效的效果，右图为添加一镜到底动效的效果，一镜到底的效果能够让二者的出现消失产生联动，使得内容切换过程显得灵动自然而不生硬。
|  |  |
| --- | --- |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170310.57015786123169643063376588888696:50001231000000:2800:A6D15C01EC407926F8995406B7B8ABD7F30B7638C0C6956D4829EAF2066E96A0.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170310.66363808657259116218251232301904:50001231000000:2800:CE520E208E2B61C6F4871E9B78AA3D2CB99C9A949578DD7C4A37E9A318BD5F78.gif)
一镜到底的动效有多种实现方式，在实际开发过程中，应根据具体场景选择合适的方法进行实现。
以下是不同实现方式的对比：
| 一镜到底实现方式 | 特点 | 适用场景 |
| --- | --- | --- |
| 不新建容器直接变化原容器 | 不发生路由跳转，需要在一个组件中实现展开及关闭两种状态的布局，展开后组件层级不变。 | 适用于转场开销小的简单场景，如点开页面无需加载大量数据及组件。 |
| 新建容器并跨容器迁移组件 | 通过使用NodeController，将组件从一个容器迁移到另一个容器，在开始迁移时，需要根据前后两个布局的位置大小等信息对组件添加位移及缩放，确保迁移开始时组件能够对齐初始布局，避免出现视觉上的跳变现象。之后再添加动画将位移及缩放等属性复位，实现组件从初始布局到目标布局的一镜到底过渡效果。 | 适用于新建对象开销大的场景，如视频直播组件点击转为全屏等。 |
| 使用geometryTransition共享元素转场 | 利用系统能力，转场前后两个组件调用geometryTransition接口绑定同一id，同时将转场逻辑置于animateTo动画闭包内，这样系统侧会自动为二者添加一镜到底的过渡效果。 | 系统将调整绑定的两个组件的宽高及位置至相同值，并切换二者的透明度，以实现一镜到底过渡效果。因此，为了实现流畅的动画效果，需要确保对绑定geometryTransition的节点添加宽高动画不会有跳变。此方式适用于创建新节点开销小的场景。 |
不新建容器并直接变化原容器
该方法不新建容器，通过在已有容器上增删组件触发transition，搭配组件属性动画实现一镜到底效果。
对于同一个容器展开，容器内兄弟组件消失或者出现的场景，可通过对同一个容器展开前后进行宽高位置变化并配置属性动画，对兄弟组件配置出现消失转场动画实现一镜到底效果。基本步骤为：
1.  构建需要展开的页面，并通过状态变量构建好普通状态和展开状态的界面。
2.  将需要展开的页面展开，通过状态变量控制兄弟组件消失或出现，并通过绑定出现消失转场实现兄弟组件转场效果。
以点击卡片后显示卡片内容详情场景为例：
```typescript
class PostData {
avatar: Resource = $r('app.media.flower');
name: string = '';
message: string = '';
images: Resource[] = [];
}
@Entry
@Component
struct Index {
@State isExpand: boolean = false;
@State @Watch('onItemClicked') selectedIndex: number = -1;
private allPostData: PostData[] = [
{ avatar: $r('app.media.flower'), name: 'Alice', message: '天气晴朗',
images: [$r('app.media.spring'), $r('app.media.tree')] },
{ avatar: $r('app.media.sky'), name: 'Bob', message: '你好世界',
images: [$r('app.media.island')] },
{ avatar: $r('app.media.tree'), name: 'Carl', message: '万物生长',
images: [$r('app.media.flower'), $r('app.media.sky'), $r('app.media.spring')] }];
private onItemClicked(): void {
if (this.selectedIndex < 0) {
return;
}
this.getUIContext()?.animateTo({
duration: 350,
curve: Curve.Friction
}, () => {
this.isExpand = !this.isExpand;
});
}
build() {
Column({ space: 20 }) {
ForEach(this.allPostData, (postData: PostData, index: number) => {
// 当点击了某个post后，会使其余的post消失下树
if (!this.isExpand || this.selectedIndex === index) {
Column() {
Post({ data: postData, selecteIndex: this.selectedIndex, index: index })
}
.width('100%')
// 对出现消失的post添加透明度转场和位移转场效果
.transition(TransitionEffect.OPACITY
.combine(TransitionEffect.translate({ y: index < this.selectedIndex ? -250 : 250 }))
.animation({ duration: 350, curve: Curve.Friction}))
}
}, (postData: PostData, index: number) => index.toString())
}
.size({ width: '100%', height: '100%' })
.backgroundColor('#40808080')
}
}
@Component
export default struct  Post {
@Link selecteIndex: number;
@Prop data: PostData;
@Prop index: number;
@State itemHeight: number = 250;
@State isExpand: boolean = false;
@State expandImageSize: number = 100;
@State avatarSize: number = 50;
build() {
Column({ space: 20 }) {
Row({ space: 10 }) {
Image(this.data.avatar)
.size({ width: this.avatarSize, height: this.avatarSize })
.borderRadius(this.avatarSize / 2)
.clip(true)
Text(this.data.name)
}
.justifyContent(FlexAlign.Start)
Text(this.data.message)
Row({ space: 15 }) {
ForEach(this.data.images, (imageResource: Resource, index: number) => {
Image(imageResource)
.size({ width: this.expandImageSize, height: this.expandImageSize })
}, (imageResource: Resource, index: number) => index.toString())
}
// 展开态下组件增加的内容
if (this.isExpand) {
Column() {
Text('评论区')
// 对评论区文本添加出现消失转场效果
.transition( TransitionEffect.OPACITY
.animation({ duration: 350, curve: Curve.Friction }))
.padding({ top: 10 })
}
.transition(TransitionEffect.asymmetric(
TransitionEffect.opacity(0.99)
.animation({ duration: 350, curve: Curve.Friction }),
TransitionEffect.OPACITY.animation({ duration: 0 })
))
.size({ width: '100%'})
}
}
.backgroundColor(Color.White)
.size({ width: '100%', height: this.itemHeight })
.alignItems(HorizontalAlign.Start)
.padding({ left: 10, top: 10 })
.onClick(() => {
this.selecteIndex = -1;
this.selecteIndex = this.index;
this.getUIContext()?.animateTo({
duration: 350,
curve: Curve.Friction
}, () => {
// 对展开的post做宽高动画，并对头像尺寸和图片尺寸加动画
this.isExpand = !this.isExpand;
this.itemHeight = this.isExpand ? 780 : 250;
this.avatarSize = this.isExpand ? 75: 50;
this.expandImageSize = (this.isExpand && this.data.images.length > 0)
? (360 - (this.data.images.length + 1) * 15) / this.data.images.length : 100;
})
})
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170310.75075135765355595681002257939631:50001231000000:2800:5FAD40FB55E0A23F06F713516AB83A931510CB8BA3601B12EF47684C596FAF4C.gif)
新建容器并跨容器迁移组件
通过NodeContainer自定义占位节点，利用NodeController实现组件的跨节点迁移，配合属性动画给组件的迁移过程赋予一镜到底效果。这种一镜到底的实现方式可以结合多种转场方式使用，如导航转场（Navigation）、半模态转场（bindSheet）等。
结合Stack使用
可以利用Stack内后定义组件在最上方的特性控制组件在跨节点迁移后位z序最高，以展开收起卡片的场景为例，实现步骤为：
-  展开卡片时，获取节点A的位置信息，将其中的组件迁移到与节点A位置一致的节点B处，节点B的层级高于节点A。
-  对节点B添加属性动画，使之展开并运动到展开后的位置，完成一镜到底的动画效果。
-  收起卡片时，对节点B添加属性动画，使之收起并运动到收起时的位置，即节点A的位置，实现一镜到底的动画效果。
-  在动画结束时利用回调将节点B中的组件迁移回节点A处。
```typescript
// Index.ets
import { createPostNode, getPostNode, PostNode } from "../PostNode"
import { componentUtils, curves } from '@kit.ArkUI';
@Entry
@Component
struct Index {
// 新建一镜到底动画类
@State AnimationProperties: AnimationProperties = new AnimationProperties();
private listArray: Array<number> = [1, 2, 3, 4, 5, 6, 7, 8 ,9, 10];
build() {
// 卡片折叠态，展开态的共同父组件
Stack() {
List({space: 20}) {
ForEach(this.listArray, (item: number) => {
ListItem() {
// 卡片折叠态
PostItem({ index: item, AnimationProperties: this.AnimationProperties })
}
})
}
.clip(false)
.alignListItem(ListItemAlign.Center)
if (this.AnimationProperties.isExpandPageShow) {
// 卡片展开态
ExpandPage({ AnimationProperties: this.AnimationProperties })
}
}
.key('rootStack')
.enabled(this.AnimationProperties.isEnabled)
}
}
@Component
struct PostItem {
@Prop index: number
@Link AnimationProperties: AnimationProperties;
@State nodeController: PostNode | undefined = undefined;
// 折叠时详细内容隐藏
private showDetailContent: boolean = false;
aboutToAppear(): void {
this.nodeController = createPostNode(this.getUIContext(), this.index.toString(), this.showDetailContent);
if (this.nodeController != undefined) {
// 设置回调，当卡片从展开态回到折叠态时触发
this.nodeController.setCallback(this.resetNode.bind(this));
}
}
resetNode() {
this.nodeController = getPostNode(this.index.toString());
}
build() {
Stack() {
NodeContainer(this.nodeController)
}
.width('100%')
.height(100)
.key(this.index.toString())
.onClick( ()=> {
if (this.nodeController != undefined) {
// 卡片从折叠态节点下树
this.nodeController.onRemove();
}
// 触发卡片从折叠到展开态的动画
this.AnimationProperties.expandAnimation(this.index);
})
}
}
@Component
struct ExpandPage {
@Link AnimationProperties: AnimationProperties;
@State nodeController: PostNode | undefined = undefined;
// 展开时详细内容出现
private showDetailContent: boolean = true;
aboutToAppear(): void {
// 获取对应序号的卡片组件
this.nodeController = getPostNode(this.AnimationProperties.curIndex.toString())
// 更新为详细内容出现
this.nodeController?.update(this.AnimationProperties.curIndex.toString(), this.showDetailContent)
}
build() {
Stack() {
NodeContainer(this.nodeController)
}
.width('100%')
.height(this.AnimationProperties.changedHeight ? '100%' : 100)
.translate({ x: this.AnimationProperties.translateX, y: this.AnimationProperties.translateY })
.position({ x: this.AnimationProperties.positionX, y: this.AnimationProperties.positionY })
.onClick(() => {
this.getUIContext()?.animateTo({ curve: curves.springMotion(0.6, 0.9),
onFinish: () => {
if (this.nodeController != undefined) {
// 执行回调，折叠态节点获取卡片组件
this.nodeController.callCallback();
// 当前展开态节点的卡片组件下树
this.nodeController.onRemove();
}
// 卡片展开态节点下树
this.AnimationProperties.isExpandPageShow = false;
this.AnimationProperties.isEnabled = true;
}
}, () => {
// 卡片从展开态回到折叠态
this.AnimationProperties.isEnabled = false;
this.AnimationProperties.translateX = 0;
this.AnimationProperties.translateY = 0;
this.AnimationProperties.changedHeight = false;
// 更新为详细内容消失
this.nodeController?.update(this.AnimationProperties.curIndex.toString(), false);
})
})
}
}
class RectInfo {
left: number = 0;
top: number = 0;
right: number = 0;
bottom: number = 0;
width: number = 0;
height: number = 0;
}
// 封装的一镜到底动画类
@Observed
class AnimationProperties {
public isExpandPageShow: boolean = false;
// 控制组件是否响应点击事件
public isEnabled: boolean = true;
// 展开卡片的序号
public curIndex: number = -1;
public translateX: number = 0;
public translateY: number = 0;
public positionX: number = 0;
public positionY: number = 0;
public changedHeight: boolean = false;
private calculatedTranslateX: number = 0;
private calculatedTranslateY: number = 0;
// 设置卡片展开后相对父组件的位置
private expandTranslateX: number = 0;
private expandTranslateY: number = 0;
public expandAnimation(index: number): void {
// 记录展开态卡片的序号
if (index != undefined) {
this.curIndex = index;
}
// 计算折叠态卡片相对父组件的位置
this.calculateData(index.toString());
// 展开态卡片上树
this.isExpandPageShow = true;
// 卡片展开的属性动画
animateTo({ curve: curves.springMotion(0.6, 0.9)
}, () => {
this.translateX = this.calculatedTranslateX;
this.translateY = this.calculatedTranslateY;
this.changedHeight = true;
})
}
// 获取需要跨节点迁移的组件的位置，及迁移前后节点的公共父节点的位置，用以计算做动画组件的动画参数
public calculateData(key: string): void {
let clickedImageInfo = this.getRectInfoById(key);
let rootStackInfo = this.getRectInfoById('rootStack');
this.positionX = px2vp(clickedImageInfo.left - rootStackInfo.left);
this.positionY = px2vp(clickedImageInfo.top - rootStackInfo.top);
this.calculatedTranslateX = px2vp(rootStackInfo.left - clickedImageInfo.left) + this.expandTranslateX;
this.calculatedTranslateY = px2vp(rootStackInfo.top - clickedImageInfo.top) + this.expandTranslateY;
}
// 根据组件的id获取组件的位置信息
private getRectInfoById(id: string): RectInfo {
let componentInfo: componentUtils.ComponentInfo = componentUtils.getRectangleById(id);
if (!componentInfo) {
throw Error('object is empty');
}
let rstRect: RectInfo = new RectInfo();
const widthScaleGap = componentInfo.size.width * (1 - componentInfo.scale.x) / 2;
const heightScaleGap = componentInfo.size.height * (1 - componentInfo.scale.y) / 2;
rstRect.left = componentInfo.translate.x + componentInfo.windowOffset.x + widthScaleGap;
rstRect.top = componentInfo.translate.y + componentInfo.windowOffset.y + heightScaleGap;
rstRect.right =
componentInfo.translate.x + componentInfo.windowOffset.x + componentInfo.size.width - widthScaleGap;
rstRect.bottom =
componentInfo.translate.y + componentInfo.windowOffset.y + componentInfo.size.height - heightScaleGap;
rstRect.width = rstRect.right - rstRect.left;
rstRect.height = rstRect.bottom - rstRect.top;
return {
left: rstRect.left,
right: rstRect.right,
top: rstRect.top,
bottom: rstRect.bottom,
width: rstRect.width,
height: rstRect.height
}
}
}
```
```typescript
// PostNode.ets
// 跨容器迁移能力
import { UIContext } from '@ohos.arkui.UIContext';
import { NodeController, BuilderNode, FrameNode } from '@ohos.arkui.node';
import { curves } from '@kit.ArkUI';
class Data {
item: string | null = null
isExpand: Boolean | false = false
}
@Builder
function PostBuilder(data: Data) {
// 跨容器迁移组件置于@Builder内
Column() {
Row() {
Row()
.backgroundColor(Color.Pink)
.borderRadius(20)
.width(80)
.height(80)
Column() {
Text('点击展开 Item ' + data.item)
.fontSize(20)
Text('共享元素转场')
.fontSize(12)
.fontColor(0x909399)
}
.alignItems(HorizontalAlign.Start)
.justifyContent(FlexAlign.SpaceAround)
.margin({ left: 10 })
.height(80)
}
.width('90%')
.height(100)
// 展开后显示细节内容
if (data.isExpand) {
Row() {
Text('展开态')
.fontSize(28)
.fontColor(0x909399)
.textAlign(TextAlign.Center)
.transition(TransitionEffect.OPACITY.animation({ curve: curves.springMotion(0.6, 0.9) }))
}
.width('90%')
.justifyContent(FlexAlign.Center)
}
}
.width('90%')
.height('100%')
.alignItems(HorizontalAlign.Center)
.borderRadius(10)
.margin({ top: 15 })
.backgroundColor(Color.White)
.shadow({
radius: 20,
color: 0x909399,
offsetX: 20,
offsetY: 10
})
}
class __InternalValue__{
flag:boolean =false;
};
export class PostNode extends NodeController {
private node: BuilderNode<Data[]> | null = null;
private isRemove: __InternalValue__ = new __InternalValue__();
private callback: Function | undefined = undefined
private data: Data | null = null
makeNode(uiContext: UIContext): FrameNode | null {
if(this.isRemove.flag == true){
return null;
}
if (this.node != null) {
return this.node.getFrameNode();
}
return null;
}
init(uiContext: UIContext, id: string, isExpand: boolean) {
if (this.node != null) {
return;
}
// 创建节点，需要uiContext
this.node = new BuilderNode(uiContext)
// 创建离线组件
this.data = { item: id, isExpand: isExpand }
this.node.build(wrapBuilder<Data[]>(PostBuilder), this.data)
}
update(id: string, isExpand: boolean) {
if (this.node !== null) {
// 调用update进行更新。
this.data = { item: id, isExpand: isExpand }
this.node.update(this.data);
}
}
setCallback(callback: Function | undefined) {
this.callback = callback
}
callCallback() {
if (this.callback != undefined) {
this.callback();
}
}
onRemove(){
this.isRemove.flag = true;
// 组件迁移出节点时触发重建
this.rebuild();
this.isRemove.flag = false;
}
}
let gNodeMap: Map<string, PostNode | undefined> = new Map();
export const createPostNode =
(uiContext: UIContext, id: string, isExpand: boolean): PostNode | undefined => {
let node = new PostNode();
node.init(uiContext, id, isExpand);
gNodeMap.set(id, node);
return node;
}
export const getPostNode = (id: string): PostNode | undefined => {
if (!gNodeMap.has(id)) {
return undefined
}
return gNodeMap.get(id);
}
export const deleteNode = (id: string) => {
gNodeMap.delete(id)
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170310.50182495224212157871421766969728:50001231000000:2800:A1DB4F16A16ED618ABF5FA7FF981F542E418A5C729B6AE180DAE75F4EB1FD1FE.gif)
结合Navigation使用
可以利用Navigation的自定义导航转场动画能力（customNavContentTransition，可参考Navigation示例3）实现一镜到底动效。共享元素转场期间，组件由消失页面迁移至出现页面。
以展开收起缩略图的场景为例，实现步骤为：
-  通过customNavContentTransition配置PageOne与PageTwo的自定义导航转场动画。
-  自定义的共享元素转场效果由属性动画实现，具体实现方式为抓取页面内组件相对窗口的位置信息从而正确匹配组件在PageOne与PageTwo的位置、缩放等，即动画开始和结束的属性信息。
-  点击缩略图后共享元素组件从PageOne被迁移至PageTwo，随后触发由PageOne至PageTwo的自定义转场动画，即PageTwo的共享元素组件从原来的缩略图状态做动画到全屏状态。
-  由全屏状态返回到缩略图时，触发由PageTwo至PageOne的自定义转场动画，即PageTwo的共享元素组件从全屏状态做动画到原PageOne的缩略图状态，转场结束后共享元素组件从PageTwo被迁移回PageOne。
```typescript
// Index.ets
import { AnimateCallback, CustomTransition } from '../CustomTransition/CustomNavigationUtils';
const TAG: string = 'Index';
@Entry
@Component
struct Index {
private pageInfos: NavPathStack = new NavPathStack();
// 允许进行自定义转场的页面名称
private allowedCustomTransitionFromPageName: string[] = ['PageOne'];
private allowedCustomTransitionToPageName: string[] = ['PageTwo'];
aboutToAppear(): void {
this.pageInfos.pushPath({ name: 'PageOne' });
}
private isCustomTransitionEnabled(fromName: string, toName: string): boolean {
// 点击和返回均需要进行自定义转场，因此需要分别判断
if ((this.allowedCustomTransitionFromPageName.includes(fromName)
&& this.allowedCustomTransitionToPageName.includes(toName))
|| (this.allowedCustomTransitionFromPageName.includes(toName)
&& this.allowedCustomTransitionToPageName.includes(fromName))) {
return true;
}
return false;
}
build() {
Navigation(this.pageInfos)
.hideNavBar(true)
.customNavContentTransition((from: NavContentInfo, to: NavContentInfo, operation: NavigationOperation) => {
if ((!from || !to) || (!from.name || !to.name)) {
return undefined;
}
// 通过from和to的name对自定义转场路由进行管控
if (!this.isCustomTransitionEnabled(from.name, to.name)) {
return undefined;
}
// 需要对转场页面是否注册了animation进行判断，来决定是否进行自定义转场
let fromParam: AnimateCallback = CustomTransition.getInstance().getAnimateParam(from.index);
let toParam: AnimateCallback = CustomTransition.getInstance().getAnimateParam(to.index);
if (!fromParam.animation || !toParam.animation) {
return undefined;
}
// 一切判断完成后，构造customAnimation给系统侧调用，执行自定义转场动画
let customAnimation: NavigationAnimatedTransition = {
onTransitionEnd: (isSuccess: boolean) => {
console.log(TAG, `current transition result is ${isSuccess}`);
},
timeout: 2000,
transition: (transitionProxy: NavigationTransitionProxy) => {
console.log(TAG, 'trigger transition callback');
if (fromParam.animation) {
fromParam.animation(operation == NavigationOperation.PUSH, true, transitionProxy);
}
if (toParam.animation) {
toParam.animation(operation == NavigationOperation.PUSH, false, transitionProxy);
}
}
};
return customAnimation;
})
}
}
```
```typescript
// PageOne.ets
import { CustomTransition } from '../CustomTransition/CustomNavigationUtils';
import { MyNodeController, createMyNode, getMyNode } from '../NodeContainer/CustomComponent';
import { ComponentAttrUtils, RectInfoInPx } from '../utils/ComponentAttrUtils';
import { WindowUtils } from '../utils/WindowUtils';
@Builder
export function PageOneBuilder() {
PageOne();
}
@Component
export struct PageOne {
private pageInfos: NavPathStack = new NavPathStack();
private pageId: number = -1;
@State myNodeController: MyNodeController | undefined = new MyNodeController(false);
aboutToAppear(): void {
let node = getMyNode();
if (node == undefined) {
// 新建自定义节点
createMyNode(this.getUIContext());
}
this.myNodeController = getMyNode();
}
private doFinishTransition(): void {
// PageTwo结束转场时将节点从PageTwo迁移回PageOne
this.myNodeController = getMyNode();
}
private registerCustomTransition(): void {
// 注册自定义动画协议
CustomTransition.getInstance().registerNavParam(this.pageId,
(isPush: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => {}, 500);
}
private onCardClicked(): void {
let cardItemInfo: RectInfoInPx =
ComponentAttrUtils.getRectInfoById(WindowUtils.window.getUIContext(), 'card');
let param: Record<string, Object> = {};
param['cardItemInfo'] = cardItemInfo;
param['doDefaultTransition'] = (myController: MyNodeController) => {
this.doFinishTransition()
};
this.pageInfos.pushPath({ name: 'PageTwo', param: param });
// 自定义节点从PageOne下树
if (this.myNodeController != undefined) {
(this.myNodeController as MyNodeController).onRemove();
}
}
build() {
NavDestination() {
Stack() {
Column({ space: 20 }) {
Row({ space: 10 }) {
Image($r("app.media.avatar"))
.size({ width: 50, height: 50 })
.borderRadius(25)
.clip(true)
Text('Alice')
}
.justifyContent(FlexAlign.Start)
Text('你好世界')
NodeContainer(this.myNodeController)
.size({ width: 320, height: 250 })
.onClick(() => {
this.onCardClicked()
})
}
.alignItems(HorizontalAlign.Start)
.margin(30)
}
}
.onReady((context: NavDestinationContext) => {
this.pageInfos = context.pathStack;
this.pageId = this.pageInfos.getAllPathName().length - 1;
this.registerCustomTransition();
})
.onDisAppear(() => {
CustomTransition.getInstance().unRegisterNavParam(this.pageId);
// 自定义节点从PageOne下树
if (this.myNodeController != undefined) {
(this.myNodeController as MyNodeController).onRemove();
}
})
}
}
```
```typescript
// PageTwo.ets
import { CustomTransition } from '../CustomTransition/CustomNavigationUtils';
import { AnimationProperties } from '../CustomTransition/AnimationProperties';
import { RectInfoInPx } from '../utils/ComponentAttrUtils';
import { getMyNode, MyNodeController } from '../NodeContainer/CustomComponent';
@Builder
export function PageTwoBuilder() {
PageTwo();
}
@Component
export struct PageTwo {
@State pageInfos: NavPathStack = new NavPathStack();
@State AnimationProperties: AnimationProperties = new AnimationProperties();
@State myNodeController: MyNodeController | undefined = new MyNodeController(false);
private pageId: number = -1;
private shouldDoDefaultTransition: boolean = false;
private prePageDoFinishTransition: () => void = () => {};
private cardItemInfo: RectInfoInPx = new RectInfoInPx();
@StorageProp('windowSizeChanged') @Watch('unRegisterNavParam') windowSizeChangedTime: number = 0;
@StorageProp('onConfigurationUpdate') @Watch('unRegisterNavParam') onConfigurationUpdateTime: number = 0;
aboutToAppear(): void {
// 迁移自定义节点至当前页面
this.myNodeController = getMyNode();
}
private unRegisterNavParam(): void {
this.shouldDoDefaultTransition = true;
}
private onBackPressed(): boolean {
if (this.shouldDoDefaultTransition) {
CustomTransition.getInstance().unRegisterNavParam(this.pageId);
this.pageInfos.pop();
this.prePageDoFinishTransition();
this.shouldDoDefaultTransition = false;
return true;
}
this.pageInfos.pop();
return true;
}
build() {
NavDestination() {
// Stack需要设置alignContent为TopStart，否则在高度变化过程中，截图和内容都会随高度重新布局位置
Stack({ alignContent: Alignment.TopStart }) {
Stack({ alignContent: Alignment.TopStart }) {
Column({space: 20}) {
NodeContainer(this.myNodeController)
if (this.AnimationProperties.showDetailContent)
Text('展开态内容')
.fontSize(20)
.transition(TransitionEffect.OPACITY)
.margin(30)
}
.alignItems(HorizontalAlign.Start)
}
.position({ y: this.AnimationProperties.positionValue })
}
.scale({ x: this.AnimationProperties.scaleValue, y: this.AnimationProperties.scaleValue })
.translate({ x: this.AnimationProperties.translateX, y: this.AnimationProperties.translateY })
.width(this.AnimationProperties.clipWidth)
.height(this.AnimationProperties.clipHeight)
.borderRadius(this.AnimationProperties.radius)
// expandSafeArea使得Stack做沉浸式效果，向上扩到状态栏，向下扩到导航条
.expandSafeArea([SafeAreaType.SYSTEM])
// 对高度进行裁切
.clip(true)
}
.backgroundColor(this.AnimationProperties.navDestinationBgColor)
.hideTitleBar(true)
.onReady((context: NavDestinationContext) => {
this.pageInfos = context.pathStack;
this.pageId = this.pageInfos.getAllPathName().length - 1;
let param = context.pathInfo?.param as Record<string, Object>;
this.prePageDoFinishTransition = param['doDefaultTransition'] as () => void;
this.cardItemInfo = param['cardItemInfo'] as RectInfoInPx;
CustomTransition.getInstance().registerNavParam(this.pageId,
(isPush: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => {
this.AnimationProperties.doAnimation(
this.cardItemInfo, isPush, isExit, transitionProxy, 0,
this.prePageDoFinishTransition, this.myNodeController);
}, 500);
})
.onBackPressed(() => {
return this.onBackPressed();
})
.onDisAppear(() => {
CustomTransition.getInstance().unRegisterNavParam(this.pageId);
})
}
}
```
```typescript
// CustomNavigationUtils.ets
// 配置Navigation自定义转场动画
export interface AnimateCallback {
animation: ((isPush: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => void | undefined)
| undefined;
timeout: (number | undefined) | undefined;
}
const customTransitionMap: Map<number, AnimateCallback> = new Map();
export class CustomTransition {
private constructor() {};
static delegate = new CustomTransition();
static getInstance() {
return CustomTransition.delegate;
}
// 注册页面的动画回调，name是注册页面的动画的回调
// animationCallback是需要执行的动画内容，timeout是转场结束的超时时间
registerNavParam(
name: number,
animationCallback: (operation: boolean, isExit: boolean, transitionProxy: NavigationTransitionProxy) => void,
timeout: number): void {
if (customTransitionMap.has(name)) {
let param = customTransitionMap.get(name);
if (param != undefined) {
param.animation = animationCallback;
param.timeout = timeout;
return;
}
}
let params: AnimateCallback = { timeout: timeout, animation: animationCallback };
customTransitionMap.set(name, params);
}
unRegisterNavParam(name: number): void {
customTransitionMap.delete(name);
}
getAnimateParam(name: number): AnimateCallback {
let result: AnimateCallback = {
animation: customTransitionMap.get(name)?.animation,
timeout: customTransitionMap.get(name)?.timeout,
};
return result;
}
}
```
```typescript
// 工程配置文件module.json5中配置 {"routerMap": "$profile:route_map"}
// route_map.json
{
"routerMap": [
{
"name": "PageOne",
"pageSourceFile": "src/main/ets/pages/PageOne.ets",
"buildFunction": "PageOneBuilder"
},
{
"name": "PageTwo",
"pageSourceFile": "src/main/ets/pages/PageTwo.ets",
"buildFunction": "PageTwoBuilder"
}
]
}
```
```typescript
// AnimationProperties.ets
// 一镜到底转场动画封装
import { curves } from '@kit.ArkUI';
import { RectInfoInPx } from '../utils/ComponentAttrUtils';
import { WindowUtils } from '../utils/WindowUtils';
import { MyNodeController } from '../NodeContainer/CustomComponent';
const TAG: string = 'AnimationProperties';
const DEVICE_BORDER_RADIUS: number = 34;
// 将自定义一镜到底转场动画进行封装，其他界面也需要做自定义一镜到底转场的话，可以直接复用，减少工作量
@Observed
export class AnimationProperties {
public navDestinationBgColor: ResourceColor = Color.Transparent;
public translateX: number = 0;
public translateY: number = 0;
public scaleValue: number = 1;
public clipWidth: Dimension = 0;
public clipHeight: Dimension = 0;
public radius: number = 0;
public positionValue: number = 0;
public showDetailContent: boolean = false;
public doAnimation(cardItemInfo_px: RectInfoInPx, isPush: boolean, isExit: boolean,
transitionProxy: NavigationTransitionProxy, extraTranslateValue: number, prePageOnFinish: (index: MyNodeController) => void, myNodeController: MyNodeController|undefined): void {
// 首先计算卡片的宽高与窗口宽高的比例
let widthScaleRatio = cardItemInfo_px.width / WindowUtils.windowWidth_px;
let heightScaleRatio = cardItemInfo_px.height / WindowUtils.windowHeight_px;
let isUseWidthScale = widthScaleRatio > heightScaleRatio;
let initScale: number = isUseWidthScale ? widthScaleRatio : heightScaleRatio;
let initTranslateX: number = 0;
let initTranslateY: number = 0;
let initClipWidth: Dimension = 0;
let initClipHeight: Dimension = 0;
// 使得PageTwo卡片向上扩到状态栏
let initPositionValue: number = -px2vp(WindowUtils.topAvoidAreaHeight_px + extraTranslateValue);;
if (isUseWidthScale) {
initTranslateX = px2vp(cardItemInfo_px.left - (WindowUtils.windowWidth_px - cardItemInfo_px.width) / 2);
initClipWidth = '100%';
initClipHeight = px2vp((cardItemInfo_px.height) / initScale);
initTranslateY = px2vp(cardItemInfo_px.top - ((vp2px(initClipHeight) - vp2px(initClipHeight) * initScale) / 2));
} else {
initTranslateY = px2vp(cardItemInfo_px.top - (WindowUtils.windowHeight_px - cardItemInfo_px.height) / 2);
initClipHeight = '100%';
initClipWidth = px2vp((cardItemInfo_px.width) / initScale);
initTranslateX = px2vp(cardItemInfo_px.left - (WindowUtils.windowWidth_px / 2 - cardItemInfo_px.width / 2));
}
// 转场动画开始前通过计算scale、translate、position和clip height & width，确定节点迁移前后位置一致
console.log(TAG, 'initScale: ' + initScale + ' initTranslateX ' + initTranslateX +
' initTranslateY ' + initTranslateY + ' initClipWidth ' + initClipWidth +
' initClipHeight ' + initClipHeight + ' initPositionValue ' + initPositionValue);
// 转场至新页面
if (isPush && !isExit) {
this.scaleValue = initScale;
this.translateX = initTranslateX;
this.clipWidth = initClipWidth;
this.clipHeight = initClipHeight;
this.translateY = initTranslateY;
this.positionValue = initPositionValue;
animateTo({
curve: curves.interpolatingSpring(0, 1, 328, 36),
onFinish: () => {
if (transitionProxy) {
transitionProxy.finishTransition();
}
}
}, () => {
this.scaleValue = 1.0;
this.translateX = 0;
this.translateY = 0;
this.clipWidth = '100%';
this.clipHeight = '100%';
// 页面圆角与系统圆角一致
this.radius = DEVICE_BORDER_RADIUS;
this.showDetailContent = true;
})
animateTo({
duration: 100,
curve: Curve.Sharp,
}, () => {
// 页面由透明逐渐变为设置背景色
this.navDestinationBgColor = '#00ffffff';
})
// 返回旧页面
} else if (!isPush && isExit) {
animateTo({
duration: 350,
curve: Curve.EaseInOut,
onFinish: () => {
if (transitionProxy) {
transitionProxy.finishTransition();
}
prePageOnFinish(myNodeController);
// 自定义节点从PageTwo下树
if (myNodeController != undefined) {
(myNodeController as MyNodeController).onRemove();
}
}
}, () => {
this.scaleValue = initScale;
this.translateX = initTranslateX;
this.translateY = initTranslateY;
this.radius = 0;
this.clipWidth = initClipWidth;
this.clipHeight = initClipHeight;
this.showDetailContent = false;
})
animateTo({
duration: 200,
delay: 150,
curve: Curve.Friction,
}, () => {
this.navDestinationBgColor = Color.Transparent;
})
}
}
}
```
```typescript
// ComponentAttrUtils.ets
// 获取组件相对窗口的位置
import { componentUtils, UIContext } from '@kit.ArkUI';
import { JSON } from '@kit.ArkTS';
export class ComponentAttrUtils {
// 根据组件的id获取组件的位置信息
public static getRectInfoById(context: UIContext, id: string): RectInfoInPx {
if (!context || !id) {
throw Error('object is empty');
}
let componentInfo: componentUtils.ComponentInfo = context.getComponentUtils().getRectangleById(id);
if (!componentInfo) {
throw Error('object is empty');
}
let rstRect: RectInfoInPx = new RectInfoInPx();
const widthScaleGap = componentInfo.size.width * (1 - componentInfo.scale.x) / 2;
const heightScaleGap = componentInfo.size.height * (1 - componentInfo.scale.y) / 2;
rstRect.left = componentInfo.translate.x + componentInfo.windowOffset.x + widthScaleGap;
rstRect.top = componentInfo.translate.y + componentInfo.windowOffset.y + heightScaleGap;
rstRect.right =
componentInfo.translate.x + componentInfo.windowOffset.x + componentInfo.size.width - widthScaleGap;
rstRect.bottom =
componentInfo.translate.y + componentInfo.windowOffset.y + componentInfo.size.height - heightScaleGap;
rstRect.width = rstRect.right - rstRect.left;
rstRect.height = rstRect.bottom - rstRect.top;
return {
left: rstRect.left,
right: rstRect.right,
top: rstRect.top,
bottom: rstRect.bottom,
width: rstRect.width,
height: rstRect.height
}
}
}
export class RectInfoInPx {
left: number = 0;
top: number = 0;
right: number = 0;
bottom: number = 0;
width: number = 0;
height: number = 0;
}
export class RectJson {
$rect: Array<number> = [];
}
```
```typescript
// WindowUtils.ets
// 窗口信息
import { window } from '@kit.ArkUI';
export class WindowUtils {
public static window: window.Window;
public static windowWidth_px: number;
public static windowHeight_px: number;
public static topAvoidAreaHeight_px: number;
public static navigationIndicatorHeight_px: number;
}
```
```typescript
// EntryAbility.ets
// 程序入口处的onWindowStageCreate增加对窗口宽高等的抓取
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { display, window } from '@kit.ArkUI';
import { WindowUtils } from '../utils/WindowUtils';
const TAG: string = 'EntryAbility';
export default class EntryAbility extends UIAbility {
private currentBreakPoint: string = '';
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
}
onDestroy(): void {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
}
onWindowStageCreate(windowStage: window.WindowStage): void {
// Main window is created, set main page for this ability
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
// 获取窗口宽高
WindowUtils.window = windowStage.getMainWindowSync();
WindowUtils.windowWidth_px = WindowUtils.window.getWindowProperties().windowRect.width;
WindowUtils.windowHeight_px = WindowUtils.window.getWindowProperties().windowRect.height;
this.updateBreakpoint(WindowUtils.windowWidth_px);
// 获取上方避让区(状态栏等)高度
let avoidArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);
WindowUtils.topAvoidAreaHeight_px = avoidArea.topRect.height;
// 获取导航条高度
let navigationArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR);
WindowUtils.navigationIndicatorHeight_px = navigationArea.bottomRect.height;
console.log(TAG, 'the width is ' + WindowUtils.windowWidth_px + '  ' + WindowUtils.windowHeight_px + '  ' +
WindowUtils.topAvoidAreaHeight_px + '  ' + WindowUtils.navigationIndicatorHeight_px);
// 监听窗口尺寸、状态栏高度及导航条高度的变化并更新
try {
WindowUtils.window.on('windowSizeChange', (data) => {
console.log(TAG, 'on windowSizeChange, the width is ' + data.width + ', the height is ' + data.height);
WindowUtils.windowWidth_px = data.width;
WindowUtils.windowHeight_px = data.height;
this.updateBreakpoint(data.width);
AppStorage.setOrCreate('windowSizeChanged', Date.now())
})
WindowUtils.window.on('avoidAreaChange', (data) => {
if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
let topRectHeight = data.area.topRect.height;
console.log(TAG, 'on avoidAreaChange, the top avoid area height is ' + topRectHeight);
WindowUtils.topAvoidAreaHeight_px = topRectHeight;
} else if (data.type == window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
let bottomRectHeight = data.area.bottomRect.height;
console.log(TAG, 'on avoidAreaChange, the navigation indicator height is ' + bottomRectHeight);
WindowUtils.navigationIndicatorHeight_px = bottomRectHeight;
}
})
} catch (exception) {
console.log('register failed ' + JSON.stringify(exception));
}
windowStage.loadContent('pages/Index', (err) => {
if (err.code) {
hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
return;
}
hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
});
}
updateBreakpoint(width: number) {
let windowWidthVp = width / (display.getDefaultDisplaySync().densityDPI / 160);
let newBreakPoint: string = '';
if (windowWidthVp < 400) {
newBreakPoint = 'xs';
} else if (windowWidthVp < 600) {
newBreakPoint = 'sm';
} else if (windowWidthVp < 800) {
newBreakPoint = 'md';
} else {
newBreakPoint = 'lg';
}
if (this.currentBreakPoint !== newBreakPoint) {
this.currentBreakPoint = newBreakPoint;
// 使用状态变量记录当前断点值
AppStorage.setOrCreate('currentBreakpoint', this.currentBreakPoint);
}
}
onWindowStageDestroy(): void {
// Main window is destroyed, release UI related resources
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
}
onForeground(): void {
// Ability has brought to foreground
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
}
onBackground(): void {
// Ability has back to background
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
}
}
```
```typescript
// CustomComponent.ets
// 自定义占位节点，跨容器迁移能力
import { BuilderNode, FrameNode, NodeController } from '@kit.ArkUI';
@Builder
function CardBuilder() {
Image($r("app.media.card"))
.width('100%')
.id('card')
}
export class MyNodeController extends NodeController {
private CardNode: BuilderNode<[]> | null = null;
private wrapBuilder: WrappedBuilder<[]> = wrapBuilder(CardBuilder);
private needCreate: boolean = false;
private isRemove: boolean = false;
constructor(create: boolean) {
super();
this.needCreate = create;
}
makeNode(uiContext: UIContext): FrameNode | null {
if(this.isRemove == true){
return null;
}
if (this.needCreate && this.CardNode == null) {
this.CardNode = new BuilderNode(uiContext);
this.CardNode.build(this.wrapBuilder)
}
if (this.CardNode == null) {
return null;
}
return this.CardNode!.getFrameNode()!;
}
getNode(): BuilderNode<[]> | null {
return this.CardNode;
}
setNode(node: BuilderNode<[]> | null) {
this.CardNode = node;
this.rebuild();
}
onRemove() {
this.isRemove = true;
this.rebuild();
this.isRemove = false;
}
init(uiContext: UIContext) {
this.CardNode = new BuilderNode(uiContext);
this.CardNode.build(this.wrapBuilder)
}
}
let myNode: MyNodeController | undefined;
export const createMyNode =
(uiContext: UIContext) => {
myNode = new MyNodeController(false);
myNode.init(uiContext);
}
export const getMyNode = (): MyNodeController | undefined => {
return myNode;
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170310.26028154003044940229445754600501:50001231000000:2800:76C1C8A9AAB835FDDBE257AE4D30743BE406B1E89A5626D62555621C08EE181A.gif)
结合BindSheet使用
想实现半模态转场（bindSheet）的同时，组件从初始界面做一镜到底动画到半模态页面的效果，可以使用这样的设计思路。将SheetOptions中的mode设置为SheetMode.EMBEDDED，该模式下新起的页面可以覆盖在半模态弹窗上，页面返回后该半模态依旧存在，半模态面板内容不丢失。在半模态转场的同时设置一全模态转场（bindContentCover）页面无转场出现，该页面仅有需要做共享元素转场的组件，通过属性动画，展示组件从初始界面至半模态页面的一镜到底动效，并在动画结束时关闭页面，并将该组件迁移至半模态页面。
以点击图片展开半模态页的场景为例，实现步骤为：
-  在初始界面挂载半模态转场和全模态转场两个页面，半模态页按需布局，全模态页面仅放置一镜到底动效需要的组件，抓取布局信息，使其初始位置为初始界面图片的位置。点击初始界面图片时，同时触发半模态和全模态页面出现，因设置为SheetMode.EMBEDDED模式，此时全模态页面层级最高。
-  设置不可见的占位图片置于半模态页上，作为一镜到底动效结束时图片的终止位置。利用布局回调监听该占位图片布局完成的时候，此时执行回调抓取占位图片的位置信息，随后全模态页面上的图片利用属性动画开始进行共享元素转场。
-  全模态页面的动画结束时触发结束回调，关闭全模态页面，将共享元素图片的节点迁移至半模态页面，替换占位图片。
-  需注意，半模态页面的弹起高度不同，其页面起始位置也有所不同，而全模态则是全屏显示，两者存在一高度差，做一镜到底动画时，需要计算差值并进行修正，具体可见demo。
-  还可以配合一镜到底动画，给初始界面图片也增加一个从透明到出现的动画，使得动效更为流畅。
```typescript
// index.ets
import { MyNodeController, createMyNode, getMyNode } from '../NodeContainer/CustomComponent';
import { ComponentAttrUtils, RectInfoInPx } from '../utils/ComponentAttrUtils';
import { WindowUtils } from '../utils/WindowUtils';
import { inspector } from '@kit.ArkUI'
class AnimationInfo {
scale: number = 0;
translateX: number = 0;
translateY: number = 0;
clipWidth: Dimension = 0;
clipHeight: Dimension = 0;
}
@Entry
@Component
struct Index {
@State isShowSheet: boolean = false;
@State isShowImage: boolean = false;
@State isShowOverlay: boolean = false;
@State isAnimating: boolean = false;
@State isEnabled: boolean = true;
@State scaleValue: number = 0;
@State translateX: number = 0;
@State translateY: number = 0;
@State clipWidth: Dimension = 0;
@State clipHeight: Dimension = 0;
@State radius: number = 0;
// 原图的透明度
@State opacityDegree: number = 1;
// 抓取照片原位置信息
private originInfo: AnimationInfo = new AnimationInfo;
// 抓取照片在半模态页上位置信息
private targetInfo: AnimationInfo = new AnimationInfo;
// 半模态高度
private bindSheetHeight: number = 450;
// 半模态上图片圆角
private sheetRadius: number = 20;
// 设置半模态上图片的布局监听
listener:inspector.ComponentObserver = this.getUIContext().getUIInspector().createComponentObserver('target');
aboutToAppear(): void {
// 设置半模态上图片的布局完成回调
let onLayoutComplete:()=>void=():void=>{
// 目标图片布局完成时抓取布局信息
this.targetInfo = this.calculateData('target');
// 仅半模态正确布局且此时无动画时触发一镜到底动画
if (this.targetInfo.scale != 0 && this.targetInfo.clipWidth != 0 && this.targetInfo.clipHeight != 0 && !this.isAnimating) {
this.isAnimating = true;
// 用于一镜到底的模态页的属性动画
this.getUIContext()?.animateTo({
duration: 1000,
curve: Curve.Friction,
onFinish: () => {
// 模态转场页（overlay）上的自定义节点下树
this.isShowOverlay = false;
// 半模态上的自定义节点上树，由此完成节点迁移
this.isShowImage = true;
}
}, () => {
this.scaleValue = this.targetInfo.scale;
this.translateX = this.targetInfo.translateX;
this.clipWidth = this.targetInfo.clipWidth;
this.clipHeight = this.targetInfo.clipHeight;
// 修正因半模态高度和缩放导致的高度差
this.translateY = this.targetInfo.translateY +
(this.getUIContext().px2vp(WindowUtils.windowHeight_px) - this.bindSheetHeight
- this.getUIContext().px2vp(WindowUtils.navigationIndicatorHeight_px) - this.getUIContext().px2vp(WindowUtils.topAvoidAreaHeight_px));
// 修正因缩放导致的圆角差异
this.radius = this.sheetRadius / this.scaleValue
})
// 原图从透明到出现的动画
this.getUIContext()?.animateTo({
duration: 2000,
curve: Curve.Friction,
}, () => {
this.opacityDegree = 1;
})
}
}
// 打开布局监听
this.listener.on('layout', onLayoutComplete)
}
// 获取对应id的组件相对窗口左上角的属性
calculateData(id: string): AnimationInfo {
let itemInfo: RectInfoInPx =
ComponentAttrUtils.getRectInfoById(WindowUtils.window.getUIContext(), id);
// 首先计算图片的宽高与窗口宽高的比例
let widthScaleRatio = itemInfo.width / WindowUtils.windowWidth_px;
let heightScaleRatio = itemInfo.height / WindowUtils.windowHeight_px;
let isUseWidthScale = widthScaleRatio > heightScaleRatio;
let itemScale: number = isUseWidthScale ? widthScaleRatio : heightScaleRatio;
let itemTranslateX: number = 0;
let itemClipWidth: Dimension = 0;
let itemClipHeight: Dimension = 0;
let itemTranslateY: number = 0;
if (isUseWidthScale) {
itemTranslateX = this.getUIContext().px2vp(itemInfo.left - (WindowUtils.windowWidth_px - itemInfo.width) / 2);
itemClipWidth = '100%';
itemClipHeight = this.getUIContext().px2vp((itemInfo.height) / itemScale);
itemTranslateY = this.getUIContext().px2vp(itemInfo.top - ((this.getUIContext().vp2px(itemClipHeight) - this.getUIContext().vp2px(itemClipHeight) * itemScale) / 2));
} else {
itemTranslateY = this.getUIContext().px2vp(itemInfo.top - (WindowUtils.windowHeight_px - itemInfo.height) / 2);
itemClipHeight = '100%';
itemClipWidth = this.getUIContext().px2vp((itemInfo.width) / itemScale);
itemTranslateX = this.getUIContext().px2vp(itemInfo.left - (WindowUtils.windowWidth_px / 2 - itemInfo.width / 2));
}
return {
scale: itemScale,
translateX: itemTranslateX ,
translateY: itemTranslateY,
clipWidth: itemClipWidth,
clipHeight: itemClipHeight,
}
}
// 照片页
build() {
Column() {
Text('照片')
.textAlign(TextAlign.Start)
.width('100%')
.fontSize(30)
.padding(20)
Image($r("app.media.flower"))
.opacity(this.opacityDegree)
.width('90%')
.id('origin')// 挂载半模态页
.enabled(this.isEnabled)
.onClick(() => {
// 获取原始图像的位置信息，将模态页上图片移动缩放至该位置
this.originInfo = this.calculateData('origin');
this.scaleValue = this.originInfo.scale;
this.translateX = this.originInfo.translateX;
this.translateY = this.originInfo.translateY;
this.clipWidth = this.originInfo.clipWidth;
this.clipHeight = this.originInfo.clipHeight;
this.radius = 0;
this.opacityDegree = 0;
// 启动半模态页和模态页
this.isShowSheet = true;
this.isShowOverlay = true;
// 设置原图为不可交互抗打断
this.isEnabled = false;
})
}
.width('100%')
.height('100%')
.padding({ top: 20 })
.alignItems(HorizontalAlign.Center)
.bindSheet(this.isShowSheet, this.mySheet(), {
// Embedded模式使得其他页面可以高于半模态页
mode: SheetMode.EMBEDDED,
height: this.bindSheetHeight,
onDisappear: () => {
// 保证半模态消失时状态正确
this.isShowImage = false;
this.isShowSheet = false;
// 设置一镜到底动画又进入可触发状态
this.isAnimating = false;
// 原图重新变为可交互状态
this.isEnabled = true;
}
}) // 挂载模态页作为一镜到底动画的实现页
.bindContentCover(this.isShowOverlay, this.overlayNode(), {
// 模态页面设置为无转场
transition: TransitionEffect.IDENTITY,
})
}
// 半模态页面
@Builder
mySheet() {
Column({space: 20}) {
Text('半模态页面')
.fontSize(30)
Row({space: 40}) {
Column({space: 20}) {
ForEach([1, 2, 3, 4], () => {
Stack()
.backgroundColor(Color.Pink)
.borderRadius(20)
.width(60)
.height(60)
})
}
Column() {
if (this.isShowImage) {
// 半模态页面的自定义图片节点
ImageNode()
}
else {
// 抓取布局和占位用，实际不显示
Image($r("app.media.flower"))
.visibility(Visibility.Hidden)
}
}
.height(300)
.width(200)
.borderRadius(20)
.clip(true)
.id('target')
}
.alignItems(VerticalAlign.Top)
}
.alignItems(HorizontalAlign.Start)
.height('100%')
.width('100%')
.margin(40)
}
@Builder
overlayNode() {
// Stack需要设置alignContent为TopStart，否则在高度变化过程中，截图和内容都会随高度重新布局位置
Stack({ alignContent: Alignment.TopStart }) {
ImageNode()
}
.scale({ x: this.scaleValue, y: this.scaleValue, centerX: undefined, centerY: undefined})
.translate({ x: this.translateX, y: this.translateY })
.width(this.clipWidth)
.height(this.clipHeight)
.borderRadius(this.radius)
.clip(true)
}
}
@Component
struct ImageNode {
@State myNodeController: MyNodeController | undefined = new MyNodeController(false);
aboutToAppear(): void {
// 获取自定义节点
let node = getMyNode();
if (node == undefined) {
// 新建自定义节点
createMyNode(this.getUIContext());
}
this.myNodeController = getMyNode();
}
aboutToDisappear(): void {
if (this.myNodeController != undefined) {
// 节点下树
this.myNodeController.onRemove();
}
}
build() {
NodeContainer(this.myNodeController)
}
}
```
```typescript
// CustomComponent.ets
// 自定义占位节点，跨容器迁移能力
import { BuilderNode, FrameNode, NodeController } from '@kit.ArkUI';
@Builder
function CardBuilder() {
Image($r("app.media.flower"))
// 避免第一次加载图片时图片闪烁
.syncLoad(true)
}
export class MyNodeController extends NodeController {
private CardNode: BuilderNode<[]> | null = null;
private wrapBuilder: WrappedBuilder<[]> = wrapBuilder(CardBuilder);
private needCreate: boolean = false;
private isRemove: boolean = false;
constructor(create: boolean) {
super();
this.needCreate = create;
}
makeNode(uiContext: UIContext): FrameNode | null {
if(this.isRemove == true){
return null;
}
if (this.needCreate && this.CardNode == null) {
this.CardNode = new BuilderNode(uiContext);
this.CardNode.build(this.wrapBuilder)
}
if (this.CardNode == null) {
return null;
}
return this.CardNode!.getFrameNode()!;
}
getNode(): BuilderNode<[]> | null {
return this.CardNode;
}
setNode(node: BuilderNode<[]> | null) {
this.CardNode = node;
this.rebuild();
}
onRemove() {
this.isRemove = true;
this.rebuild();
this.isRemove = false;
}
init(uiContext: UIContext) {
this.CardNode = new BuilderNode(uiContext);
this.CardNode.build(this.wrapBuilder)
}
}
let myNode: MyNodeController | undefined;
export const createMyNode =
(uiContext: UIContext) => {
myNode = new MyNodeController(false);
myNode.init(uiContext);
}
export const getMyNode = (): MyNodeController | undefined => {
return myNode;
}
```
```typescript
// ComponentAttrUtils.ets
// 获取组件相对窗口的位置
import { componentUtils, UIContext } from '@kit.ArkUI';
import { JSON } from '@kit.ArkTS';
export class ComponentAttrUtils {
// 根据组件的id获取组件的位置信息
public static getRectInfoById(context: UIContext, id: string): RectInfoInPx {
if (!context || !id) {
throw Error('object is empty');
}
let componentInfo: componentUtils.ComponentInfo = context.getComponentUtils().getRectangleById(id);
if (!componentInfo) {
throw Error('object is empty');
}
let rstRect: RectInfoInPx = new RectInfoInPx();
const widthScaleGap = componentInfo.size.width * (1 - componentInfo.scale.x) / 2;
const heightScaleGap = componentInfo.size.height * (1 - componentInfo.scale.y) / 2;
rstRect.left = componentInfo.translate.x + componentInfo.windowOffset.x + widthScaleGap;
rstRect.top = componentInfo.translate.y + componentInfo.windowOffset.y + heightScaleGap;
rstRect.right =
componentInfo.translate.x + componentInfo.windowOffset.x + componentInfo.size.width - widthScaleGap;
rstRect.bottom =
componentInfo.translate.y + componentInfo.windowOffset.y + componentInfo.size.height - heightScaleGap;
rstRect.width = rstRect.right - rstRect.left;
rstRect.height = rstRect.bottom - rstRect.top;
return {
left: rstRect.left,
right: rstRect.right,
top: rstRect.top,
bottom: rstRect.bottom,
width: rstRect.width,
height: rstRect.height
}
}
}
export class RectInfoInPx {
left: number = 0;
top: number = 0;
right: number = 0;
bottom: number = 0;
width: number = 0;
height: number = 0;
}
export class RectJson {
$rect: Array<number> = [];
}
```
```typescript
// WindowUtils.ets
// 窗口信息
import { window } from '@kit.ArkUI';
export class WindowUtils {
public static window: window.Window;
public static windowWidth_px: number;
public static windowHeight_px: number;
public static topAvoidAreaHeight_px: number;
public static navigationIndicatorHeight_px: number;
}
```
```typescript
// EntryAbility.ets
// 程序入口处的onWindowStageCreate增加对窗口宽高等的抓取
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { display, window } from '@kit.ArkUI';
import { WindowUtils } from '../utils/WindowUtils';
const TAG: string = 'EntryAbility';
export default class EntryAbility extends UIAbility {
private currentBreakPoint: string = '';
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
}
onDestroy(): void {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
}
onWindowStageCreate(windowStage: window.WindowStage): void {
// Main window is created, set main page for this ability
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
// 获取窗口宽高
WindowUtils.window = windowStage.getMainWindowSync();
WindowUtils.windowWidth_px = WindowUtils.window.getWindowProperties().windowRect.width;
WindowUtils.windowHeight_px = WindowUtils.window.getWindowProperties().windowRect.height;
this.updateBreakpoint(WindowUtils.windowWidth_px);
// 获取上方避让区(状态栏等)高度
let avoidArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);
WindowUtils.topAvoidAreaHeight_px = avoidArea.topRect.height;
// 获取导航条高度
let navigationArea = WindowUtils.window.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR);
WindowUtils.navigationIndicatorHeight_px = navigationArea.bottomRect.height;
console.log(TAG, 'the width is ' + WindowUtils.windowWidth_px + '  ' + WindowUtils.windowHeight_px + '  ' +
WindowUtils.topAvoidAreaHeight_px + '  ' + WindowUtils.navigationIndicatorHeight_px);
// 监听窗口尺寸、状态栏高度及导航条高度的变化并更新
try {
WindowUtils.window.on('windowSizeChange', (data) => {
console.log(TAG, 'on windowSizeChange, the width is ' + data.width + ', the height is ' + data.height);
WindowUtils.windowWidth_px = data.width;
WindowUtils.windowHeight_px = data.height;
this.updateBreakpoint(data.width);
AppStorage.setOrCreate('windowSizeChanged', Date.now())
})
WindowUtils.window.on('avoidAreaChange', (data) => {
if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
let topRectHeight = data.area.topRect.height;
console.log(TAG, 'on avoidAreaChange, the top avoid area height is ' + topRectHeight);
WindowUtils.topAvoidAreaHeight_px = topRectHeight;
} else if (data.type == window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
let bottomRectHeight = data.area.bottomRect.height;
console.log(TAG, 'on avoidAreaChange, the navigation indicator height is ' + bottomRectHeight);
WindowUtils.navigationIndicatorHeight_px = bottomRectHeight;
}
})
} catch (exception) {
console.log('register failed ' + JSON.stringify(exception));
}
windowStage.loadContent('pages/Index', (err) => {
if (err.code) {
hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
return;
}
hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
});
}
updateBreakpoint(width: number) {
let windowWidthVp = width / (display.getDefaultDisplaySync().densityDPI / 160);
let newBreakPoint: string = '';
if (windowWidthVp < 400) {
newBreakPoint = 'xs';
} else if (windowWidthVp < 600) {
newBreakPoint = 'sm';
} else if (windowWidthVp < 800) {
newBreakPoint = 'md';
} else {
newBreakPoint = 'lg';
}
if (this.currentBreakPoint !== newBreakPoint) {
this.currentBreakPoint = newBreakPoint;
// 使用状态变量记录当前断点值
AppStorage.setOrCreate('currentBreakpoint', this.currentBreakPoint);
}
}
onWindowStageDestroy(): void {
// Main window is destroyed, release UI related resources
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
}
onForeground(): void {
// Ability has brought to foreground
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
}
onBackground(): void {
// Ability has back to background
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170310.63838915339784213111670495902350:50001231000000:2800:78EA422EB72041F42198905C8FF958CBEA1F25ECF37009DFA5D612B3F25B6B01.gif)
使用geometryTransition共享元素转场
geometryTransition用于组件内隐式共享元素转场，在视图状态切换过程中提供丝滑的上下文继承过渡体验。
geometryTransition的使用方式为对需要添加一镜到底动效的两个组件使用geometryTransition接口绑定同一id，这样在其中一个组件消失同时另一个组件创建出现的时候，系统会对二者添加一镜到底动效。
geometryTransition绑定两个对象的实现方式使得geometryTransition区别于其他方法，最适合用于两个不同对象之间完成一镜到底。
geometryTransition的简单使用
对于同一个页面中的两个元素的一镜到底效果，geometryTransition接口的简单使用示例如下：
```typescript
import { curves } from '@kit.ArkUI';
@Entry
@Component
struct IfElseGeometryTransition {
@State isShow: boolean = false;
build() {
Stack({ alignContent: Alignment.Center }) {
if (this.isShow) {
Image($r('app.media.spring'))
.autoResize(false)
.clip(true)
.width(200)
.height(200)
.borderRadius(100)
.geometryTransition("picture")
.transition(TransitionEffect.OPACITY)
// 在打断场景下，即动画过程中点击页面触发下一次转场，如果不加id，则会出现重影
// 加了id之后，新建的spring图片会复用之前的spring图片节点，不会重新创建节点，也就不会有重影问题
// 加id的规则为加在if和else下的第一个节点上，有多个并列节点则也需要进行添加
.id('item1')
} else {
// geometryTransition此处绑定的是容器，那么容器内的子组件需设为相对布局跟随父容器变化，
// 套多层容器为了说明相对布局约束传递
Column() {
Column() {
Image($r('app.media.sky'))
.size({ width: '100%', height: '100%' })
}
.size({ width: '100%', height: '100%' })
}
.width(100)
.height(100)
// geometryTransition会同步圆角，但仅限于geometryTransition绑定处，此处绑定的是容器
// 则对容器本身有圆角同步而不会操作容器内部子组件的borderRadius
.borderRadius(50)
.clip(true)
.geometryTransition("picture")
// transition保证节点离场不被立即析构，设置通用转场效果
.transition(TransitionEffect.OPACITY)
.position({ x: 40, y: 40 })
.id('item2')
}
}
.onClick(() => {
this.getUIContext()?.animateTo({
curve: curves.springMotion()
}, () => {
this.isShow = !this.isShow;
})
})
.size({ width: '100%', height: '100%' })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170310.31195881223291809580829375775029:50001231000000:2800:3C186A04A68642CE7C1533770D36233DEEDBFED586768912F5A0147EAA89D4F4.gif)
geometryTransition结合模态转场使用
更多的场景中，需要对一个页面的元素与另一个页面的元素添加一镜到底动效。可以通过geometryTransition搭配模态转场接口实现。以点击头像弹出个人信息页的demo为例：
```typescript
class PostData {
avatar: Resource = $r('app.media.flower');
name: string = '';
message: string = '';
images: Resource[] = [];
}
@Entry
@Component
struct Index {
@State isPersonalPageShow: boolean = false;
@State selectedIndex: number = 0;
@State alphaValue: number = 1;
private allPostData: PostData[] = [
{ avatar: $r('app.media.flower'), name: 'Alice', message: '天气晴朗',
images: [$r('app.media.spring'), $r('app.media.tree')] },
{ avatar: $r('app.media.sky'), name: 'Bob', message: '你好世界',
images: [$r('app.media.island')] },
{ avatar: $r('app.media.tree'), name: 'Carl', message: '万物生长',
images: [$r('app.media.flower'), $r('app.media.sky'), $r('app.media.spring')] }];
private onAvatarClicked(index: number): void {
this.selectedIndex = index;
this.getUIContext()?.animateTo({
duration: 350,
curve: Curve.Friction
}, () => {
this.isPersonalPageShow = !this.isPersonalPageShow;
this.alphaValue = 0;
});
}
private onPersonalPageBack(index: number): void {
this.getUIContext()?.animateTo({
duration: 350,
curve: Curve.Friction
}, () => {
this.isPersonalPageShow = !this.isPersonalPageShow;
this.alphaValue = 1;
});
}
@Builder
PersonalPageBuilder(index: number) {
Column({ space: 20 }) {
Image(this.allPostData[index].avatar)
.size({ width: 200, height: 200 })
.borderRadius(100)
// 头像配置共享元素效果，与点击的头像的id匹配
.geometryTransition(index.toString())
.clip(true)
.transition(TransitionEffect.opacity(0.99))
Text(this.allPostData[index].name)
.font({ size: 30, weight: 600 })
// 对文本添加出现转场效果
.transition(TransitionEffect.asymmetric(
TransitionEffect.OPACITY
.combine(TransitionEffect.translate({ y: 100 })),
TransitionEffect.OPACITY.animation({ duration: 0 })
))
Text('你好，我是' + this.allPostData[index].name)
// 对文本添加出现转场效果
.transition(TransitionEffect.asymmetric(
TransitionEffect.OPACITY
.combine(TransitionEffect.translate({ y: 100 })),
TransitionEffect.OPACITY.animation({ duration: 0 })
))
}
.padding({ top: 20 })
.size({ width: 360, height: 780 })
.backgroundColor(Color.White)
.onClick(() => {
this.onPersonalPageBack(index);
})
.transition(TransitionEffect.asymmetric(
TransitionEffect.opacity(0.99),
TransitionEffect.OPACITY
))
}
build() {
Column({ space: 20 }) {
ForEach(this.allPostData, (postData: PostData, index: number) => {
Column() {
Post({ data: postData, index: index, onAvatarClicked: (index: number) => { this.onAvatarClicked(index) } })
}
.width('100%')
}, (postData: PostData, index: number) => index.toString())
}
.size({ width: '100%', height: '100%' })
.backgroundColor('#40808080')
.bindContentCover(this.isPersonalPageShow,
this.PersonalPageBuilder(this.selectedIndex), { modalTransition: ModalTransition.NONE })
.opacity(this.alphaValue)
}
}
@Component
export default struct  Post {
@Prop data: PostData;
@Prop index: number;
@State expandImageSize: number = 100;
@State avatarSize: number = 50;
private onAvatarClicked: (index: number) => void = (index: number) => { };
build() {
Column({ space: 20 }) {
Row({ space: 10 }) {
Image(this.data.avatar)
.size({ width: this.avatarSize, height: this.avatarSize })
.borderRadius(this.avatarSize / 2)
.clip(true)
.onClick(() => {
this.onAvatarClicked(this.index);
})
// 对头像绑定共享元素转场的id
.geometryTransition(this.index.toString(), {follow:true})
.transition(TransitionEffect.OPACITY.animation({ duration: 350, curve: Curve.Friction }))
Text(this.data.name)
}
.justifyContent(FlexAlign.Start)
Text(this.data.message)
Row({ space: 15 }) {
ForEach(this.data.images, (imageResource: Resource, index: number) => {
Image(imageResource)
.size({ width: 100, height: 100 })
}, (imageResource: Resource, index: number) => index.toString())
}
}
.backgroundColor(Color.White)
.size({ width: '100%', height: 250 })
.alignItems(HorizontalAlign.Start)
.padding({ left: 10, top: 10 })
}
}
```
效果为点击主页的头像后，弹出模态页面显示个人信息，并且两个页面之间的头像做一镜到底动效：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170310.78876910684203398256268685873352:50001231000000:2800:5FEAE02C3E1798F5320EACFD6F2F777873502DE51E4918A1805E575D02250D70.gif)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-rotation-transition-animation-V14
爬取时间: 2025-04-27 23:30:41
来源: Huawei Developer
旋转屏动画主要分为两类：布局切换的旋转屏动画和透明度变化的旋转屏动画，旨在实现屏幕显示方向变化时的自然过渡。布局切换的旋转屏动画实现较为简便，例如在module.json5中配置自动旋转（或设置窗口显示方向）即可实现。而透明度变化的旋转屏动画则需在module.json5配置的基础上，预备两套视图，在屏幕旋转时，通过视图切换，使消失的视图呈现渐隐效果，新出现的视图则渐显，从而营造流畅的视觉体验。
布局切换的旋转屏动画
布局切换时的旋转屏动画，是在屏幕显示方向改变时，为窗口与应用视图同步旋转而设计的大小和位置过渡动画。这种布局切换的旋转屏动画是系统默认的，便于开发者实现。当屏幕显示方向变化时，系统会生成窗口旋转动画，并自动调整窗口大小以匹配旋转后的尺寸。在此过程中，窗口会通知对应的应用，要求其根据新的窗口大小重新布局，产生与窗口旋转动画参数相同的布局动画。
切换屏幕方向即可实现布局切换的旋转屏动画效果。
```typescript
// xx.ets
import { display } from '@kit.ArkUI';
@Entry
@Component
struct rotation {
build() {
Stack() {
Image($r('app.media.tree'))
.position({ x: 0, y: 0 })
.size({ width: 100, height: 100 })
.id('image1')
}
.backgroundColor(Color.White)
.size({ width: '100%', height: '100%' })
}
}
```
需要在项目的module.json5文件中的abilities列表里添加"orientation"，指定为"auto_rotation"。
```json
"orientation": "auto_rotation",
```
布局切换的旋转屏动画，会对同步旋转的窗口与应用视图做大小和位置的过渡。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170311.47225988908475638083216944559816:50001231000000:2800:35B562F1B484EA4A9BEC64C92F19869316DC1C9136CB12E4B5C8D2251C54D40F.gif)
透明度变化的旋转屏动画
透明度变化的旋转屏动画在屏幕显示方向变化时启用，当窗口进行旋转动画时，为旋转过程中新增或删除的组件添加默认透明度转场，以实现组件的优雅出现和消失。此功能通过监听窗口旋转事件，在事件中切换组件的视图效果，如果消失视图的根节点和新出现视图的根节点未设置转场效果，会为其自动添加默认透明度转场（即TransitionEffect.OPACITY），展现出透明度的渐隐和渐显效果。
```typescript
// xx.ets
import { display } from '@kit.ArkUI';
@Entry
@Component
struct rotation {
// 获取通过监听窗口的windowsSizeChange事件得到的屏幕显示方向
@StorageLink('orientation') myOrientation: display.Orientation = display.Orientation.PORTRAIT;
build() {
Stack() {
// 当屏幕显示方向变化时，切换组件的视图效果
if (this.myOrientation == display.Orientation.PORTRAIT || this.myOrientation == display.Orientation.PORTRAIT_INVERTED) {
Image($r('app.media.sky'))
.size({ width: 100, height: 100 })
.id('image1')
// 开发者也可以通过自行设置transition的TransitionEffect.OPACITY转场效果来实现旋转屏动画的透明度变化
// .transition(TransitionEffect.OPACITY)
} else {
Image($r('app.media.tree'))
.position({ x: 0, y: 0 })
.size({ width: 200, height: 200 })
.id('image2')
// 开发者也可以通过自行设置transition的TransitionEffect.OPACITY来实现旋转屏动画的透明度变化
// .transition(TransitionEffect.OPACITY)
}
}
.backgroundColor(Color.White)
.size({ width: '100%', height: '100%' })
}
}
```
监听窗口旋转的同步事件windowsSizeChange来实现视图的切换。例如可在EntryAbility.ets文件的onWindowStageCreate方法中添加处理逻辑以获取屏幕的显示方向
```typescript
onWindowStageCreate(windowStage: window.WindowStage): void {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
let mainWindow: window.Window;
try {
mainWindow = windowStage.getMainWindowSync();
let displayClass: display.Display = display.getDefaultDisplaySync();
AppStorage.setOrCreate('orientation', displayClass.orientation);
// 监听窗口的windowsSizeChange事件，旋转屏时会触发该事件
mainWindow.on('windowSizeChange', (data) => {
console.info('Succeeded in enabling the listener for window size changes. Data: ' + JSON.stringify(data));
let displayClass: display.Display | null = null;
try {
displayClass = display.getDefaultDisplaySync();
console.info('display orientation is ' + JSON.stringify(displayClass.orientation));
// 获取屏幕的显示方向
AppStorage.set('orientation', displayClass.orientation);
} catch {
return;
}
})
} catch {
hilog.info(0x0000, 'testTag', '%{public}s', 'error');
return;
}
windowStage.loadContent('pages/Index', (err) => {
if (err.code) {
hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
return;
}
hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
});
}
```
需要在项目的 module.json5 文件中的 abilities 列表里添加 "orientation"，指定为 "auto_rotation"
```json
"orientation": "auto_rotation",
```
透明度变化的旋转屏动画，会对窗口做大小和位置的过渡，并同时对应用视图做切换过渡，且为消失隐藏的应用视图做渐隐效果，对新出现的视图做渐显的效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170311.91199685083055195527249559989253:50001231000000:2800:0FE98C376BDE8FD1638C2B83856DE4E45A8CDBB39DAB9272AD3B2FDCA779F57C.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-page-transition-animation-V14
爬取时间: 2025-04-27 23:30:56
来源: Huawei Developer
为了实现更好的转场效果，推荐使用导航转场和模态转场。
两个页面间发生跳转，一个页面消失，另一个页面出现，这时可以配置各自页面的页面转场参数实现自定义的页面转场效果。页面转场效果写在pageTransition函数中，通过PageTransitionEnter和PageTransitionExit指定页面进入和退出的动画效果。
pageTransition的函数为：
```typescript
pageTransition() {
PageTransitionEnter()
PageTransitionExit()
}
```
PageTransitionEnter的接口为：
```typescript
PageTransitionEnter({type?: RouteType,duration?: number,curve?: Curve | string,delay?: number})
```
PageTransitionExit的接口为：
```typescript
PageTransitionExit({type?: RouteType,duration?: number,curve?: Curve | string,delay?: number})
```
上述接口定义了PageTransitionEnter和PageTransitionExit组件，可通过slide、translate、scale、opacity属性定义不同的页面转场效果。对于PageTransitionEnter而言，这些效果表示入场时起点值，对于PageTransitionExit而言，这些效果表示退场的终点值，这一点与组件转场transition配置方法类似。此外，PageTransitionEnter提供了onEnter接口进行自定义页面入场动画的回调，PageTransitionExit提供了onExit接口进行自定义页面退场动画的回调。
上述接口中的参数type，表示路由生效的类型，这一点开发者容易混淆其含义。页面转场的两个页面，必定有一个页面退出，一个页面进入。如果通过router.pushUrl操作从页面A跳转到页面B，则页面A退出，做页面退场动画，页面B进入，做页面入场动画。如果通过router.back操作从页面B返回到页面A，则页面B退出，做页面退场动画，页面A进入，做页面入场动画。即页面的PageTransitionEnter既可能是由于新增页面(push，入栈)引起的新页面的入场动画，也可能是由于页面返回(back，或pop，出栈)引起的页面栈中老页面的入场动画，为了能区分这两种形式的入场动画，提供了type参数，这样开发者能完全定义所有类型的页面转场效果。
type配置为RouteType.None
type为RouteType.None表示对页面栈的push、pop操作均生效，type的默认值为RouteType.None。
```typescript
// page A
pageTransition() {
// 定义页面进入时的效果，从左侧滑入，时长为1200ms，无论页面栈发生push还是pop操作均可生效
PageTransitionEnter({ type: RouteType.None, duration: 1200 })
.slide(SlideEffect.Left)
// 定义页面退出时的效果，向左侧滑出，时长为1000ms，无论页面栈发生push还是pop操作均可生效
PageTransitionExit({ type: RouteType.None, duration: 1000 })
.slide(SlideEffect.Left)
}
```
```typescript
// page B
pageTransition() {
// 定义页面进入时的效果，从右侧滑入，时长为1000ms，无论页面栈发生push还是pop操作均可生效
PageTransitionEnter({ type: RouteType.None, duration: 1000 })
.slide(SlideEffect.Right)
// 定义页面退出时的效果，向右侧滑出，时长为1200ms，无论页面栈发生push还是pop操作均可生效
PageTransitionExit({ type: RouteType.None, duration: 1200 })
.slide(SlideEffect.Right)
}
```
假设页面跳转配置为多实例模式，即页面栈中允许存在重复的页面。可能会有4种场景，对应的页面转场效果如下表。
| 路由操作 | 页面A转场效果 | 页面B转场效果 |
| --- | --- | --- |
| router.pushUrl，从页面A跳转到新增的页面B | 页面退出，PageTransitionExit生效，向左侧滑出屏幕 | 页面进入，PageTransitionEnter生效，从右侧滑入屏幕 |
| router.back，从页面B返回到页面A | 页面进入，PageTransitionEnter生效，从左侧滑入屏幕 | 页面退出，PageTransitionExit生效，向右侧滑出屏幕 |
| router.pushUrl，从页面B跳转到新增的页面A | 页面进入，PageTransitionEnter生效，从左侧滑入屏幕 | 页面退出，PageTransitionExit生效，向右侧滑出屏幕 |
| router.back，从页面A返回到页面B | 页面退出，PageTransitionExit生效，向左侧滑出屏幕 | 页面进入，PageTransitionEnter生效，从右侧滑入屏幕 |
如果希望pushUrl进入的页面总是从右侧滑入，back时退出的页面总是从右侧滑出，则上表中的第3、4种情况不满足要求，那么需要完整的定义4个页面转场效果。
type配置为RouteType.Push或RouteType.Pop
type为RouteType.Push表示仅对页面栈的push操作生效，type为RouteType.Pop表示仅对页面栈的pop操作生效。
```typescript
// page A
pageTransition() {
// 定义页面进入时的效果，从右侧滑入，时长为1200ms，页面栈发生push操作时该效果才生效
PageTransitionEnter({ type: RouteType.Push, duration: 1200 })
.slide(SlideEffect.Right)
// 定义页面进入时的效果，从左侧滑入，时长为1200ms，页面栈发生pop操作时该效果才生效
PageTransitionEnter({ type: RouteType.Pop, duration: 1200 })
.slide(SlideEffect.Left)
// 定义页面退出时的效果，向左侧滑出，时长为1000ms，页面栈发生push操作时该效果才生效
PageTransitionExit({ type: RouteType.Push, duration: 1000 })
.slide(SlideEffect.Left)
// 定义页面退出时的效果，向右侧滑出，时长为1000ms，页面栈发生pop操作时该效果才生效
PageTransitionExit({ type: RouteType.Pop, duration: 1000 })
.slide(SlideEffect.Right)
}
```
```typescript
// page B
pageTransition() {
// 定义页面进入时的效果，从右侧滑入，时长为1000ms，页面栈发生push操作时该效果才生效
PageTransitionEnter({ type: RouteType.Push, duration: 1000 })
.slide(SlideEffect.Right)
// 定义页面进入时的效果，从左侧滑入，时长为1000ms，页面栈发生pop操作时该效果才生效
PageTransitionEnter({ type: RouteType.Pop, duration: 1000 })
.slide(SlideEffect.Left)
// 定义页面退出时的效果，向左侧滑出，时长为1200ms，页面栈发生push操作时该效果才生效
PageTransitionExit({ type: RouteType.Push, duration: 1200 })
.slide(SlideEffect.Left)
// 定义页面退出时的效果，向右侧滑出，时长为1200ms，页面栈发生pop操作时该效果才生效
PageTransitionExit({ type: RouteType.Pop, duration: 1200 })
.slide(SlideEffect.Right)
}
```
以上代码则完整的定义了所有可能的页面转场样式。假设页面跳转配置为多实例模式，即页面栈中允许存在重复的页面。可能会有4种场景，对应的页面转场效果如下表。
| 路由操作 | 页面A转场效果 | 页面B转场效果 |
| --- | --- | --- |
| router.pushUrl，从页面A跳转到新增的页面B | 页面退出，PageTransitionExit且type为RouteType.Push的转场样式生效，向左侧滑出屏幕 | 页面进入，PageTransitionEnter且type为RouteType.Push的转场样式生效，从右侧滑入屏幕 |
| router.back，从页面B返回到页面A | 页面进入，PageTransitionEnter且type为RouteType.Pop的转场样式生效，从左侧滑入屏幕 | 页面退出，PageTransitionExit且type为RouteType.Pop的转场样式生效，向右侧滑出屏幕 |
| router.pushUrl，从页面B跳转到新增的页面A | 页面进入，PageTransitionEnter且type为RouteType.Push的转场样式生效，从右侧滑入屏幕 | 页面退出，PageTransitionExit且type为RouteType.Push的转场样式生效，向左侧滑出屏幕 |
| router.back，从页面A返回到页面B | 页面退出，PageTransitionExit且type为RouteType.Pop的转场样式生效，向右侧滑出屏幕 | 页面进入，PageTransitionEnter且type为RouteType.Pop的转场样式生效，从左侧滑入屏幕 |
1.  由于每个页面的页面转场样式都可由开发者独立配置，而页面转场涉及到两个页面，开发者应考虑两个页面的页面转场效果的衔接，如时长尽量保持一致。
2.  如果没有定义匹配的页面转场样式，则该页面使用系统默认的页面转场样式。
禁用某页面的页面转场
```typescript
pageTransition() {
PageTransitionEnter({ type: RouteType.None, duration: 0 })
PageTransitionExit({ type: RouteType.None, duration: 0 })
}
```
通过设置页面转场的时长为0，可使该页面无页面转场动画。
场景示例
下面介绍了利用router.pushUrl跳转能力定义了所有的四种页面转场样式的页面转场动画示例。
```typescript
// PageTransitionSrc1
@Entry
@Component
struct PageTransitionSrc1 {
build() {
Column() {
Image($r('app.media.mountain'))
.width('90%')
.height('80%')
.objectFit(ImageFit.Fill)
.syncLoad(true) // 同步加载图片，使页面出现时图片已经加载完成
.margin(30)
Row({ space: 10 }) {
Button("pushUrl")
.onClick(() => {
// 路由到下一个页面，push操作
this.getUIContext().getRouter().pushUrl({ url: 'pages/myTest/pageTransitionDst1' });
})
Button("back")
.onClick(() => {
// 返回到上一页面，相当于pop操作
this.getUIContext().getRouter().back();
})
}.justifyContent(FlexAlign.Center)
}
.width("100%").height("100%")
.alignItems(HorizontalAlign.Center)
}
pageTransition() {
// 定义页面进入时的效果，从右侧滑入，时长为1000ms，页面栈发生push操作时该效果才生效
PageTransitionEnter({ type: RouteType.Push, duration: 1000 })
.slide(SlideEffect.Right)
// 定义页面进入时的效果，从左侧滑入，时长为1000ms，页面栈发生pop操作时该效果才生效
PageTransitionEnter({ type: RouteType.Pop, duration: 1000 })
.slide(SlideEffect.Left)
// 定义页面退出时的效果，向左侧滑出，时长为1000ms，页面栈发生push操作时该效果才生效
PageTransitionExit({ type: RouteType.Push, duration: 1000 })
.slide(SlideEffect.Left)
// 定义页面退出时的效果，向右侧滑出，时长为1000ms，页面栈发生pop操作时该效果才生效
PageTransitionExit({ type: RouteType.Pop, duration: 1000 })
.slide(SlideEffect.Right)
}
}
```
```typescript
// PageTransitionDst1
@Entry
@Component
struct PageTransitionDst1 {
build() {
Column() {
Image($r('app.media.forest'))
.width('90%')
.height('80%')
.objectFit(ImageFit.Fill)
.syncLoad(true) // 同步加载图片，使页面出现时图片已经加载完成
.margin(30)
Row({ space: 10 }) {
Button("pushUrl")
.onClick(() => {
// 路由到下一页面，push操作
this.getUIContext().getRouter().pushUrl({ url: 'pages/myTest/pageTransitionSrc1' });
})
Button("back")
.onClick(() => {
// 返回到上一页面，相当于pop操作
this.getUIContext().getRouter().back();
})
}.justifyContent(FlexAlign.Center)
}
.width("100%").height("100%")
.alignItems(HorizontalAlign.Center)
}
pageTransition() {
// 定义页面进入时的效果，从右侧滑入，时长为1000ms，页面栈发生push操作时该效果才生效
PageTransitionEnter({ type: RouteType.Push, duration: 1000 })
.slide(SlideEffect.Right)
// 定义页面进入时的效果，从左侧滑入，时长为1000ms，页面栈发生pop操作时该效果才生效
PageTransitionEnter({ type: RouteType.Pop, duration: 1000 })
.slide(SlideEffect.Left)
// 定义页面退出时的效果，向左侧滑出，时长为1000ms，页面栈发生push操作时该效果才生效
PageTransitionExit({ type: RouteType.Push, duration: 1000 })
.slide(SlideEffect.Left)
// 定义页面退出时的效果，向右侧滑出，时长为1000ms，页面栈发生pop操作时该效果才生效
PageTransitionExit({ type: RouteType.Pop, duration: 1000 })
.slide(SlideEffect.Right)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170311.73187335268481283840577063870338:50001231000000:2800:370685BB9F939883DECD6682D5C7DE074E9E5028268AE63AEA42DB64016B5FEE.gif)
下面介绍使用了type为None的页面转场动画示例。
```typescript
// PageTransitionSrc2
@Entry
@Component
struct PageTransitionSrc2 {
build() {
Column() {
Image($r('app.media.mountain'))
.width('90%')
.height('80%')
.objectFit(ImageFit.Fill)
.syncLoad(true) // 同步加载图片，使页面出现时图片已经加载完成
.margin(30)
Row({ space: 10 }) {
Button("pushUrl")
.onClick(() => {
// 路由到下一页面，push操作
this.getUIContext().getRouter().pushUrl({ url: 'pages/myTest/pageTransitionDst2' });
})
Button("back")
.onClick(() => {
// 返回到上一页面，相当于pop操作
this.getUIContext().getRouter().back();
})
}.justifyContent(FlexAlign.Center)
}
.width("100%").height("100%")
.alignItems(HorizontalAlign.Center)
}
pageTransition() {
// 定义页面进入时的效果，从左侧滑入，时长为1000ms，无论页面栈发生push还是pop操作均可生效
PageTransitionEnter({ duration: 1000 })
.slide(SlideEffect.Left)
// 定义页面退出时的效果，相对于正常页面位置x方向平移100vp，y方向平移100vp，透明度变为0，时长为1200ms，无论页面栈发生push还是pop操作均可生效
PageTransitionExit({ duration: 1200 })
.translate({ x: 100.0, y: 100.0 })
.opacity(0)
}
}
```
```typescript
// PageTransitionDst2
@Entry
@Component
struct PageTransitionDst2 {
build() {
Column() {
Image($r('app.media.forest'))
.width('90%')
.height('80%')
.objectFit(ImageFit.Fill)
.syncLoad(true) // 同步加载图片，使页面出现时图片已经加载完成
.margin(30)
Row({ space: 10 }) {
Button("pushUrl")
.onClick(() => {
// 路由到下一页面，push操作
this.getUIContext().getRouter().pushUrl({ url: 'pages/myTest/pageTransitionSrc2' });
})
Button("back")
.onClick(() => {
// 返回到上一页面，相当于pop操作
this.getUIContext().getRouter().back();
})
}.justifyContent(FlexAlign.Center)
}
.width("100%").height("100%")
.alignItems(HorizontalAlign.Center)
}
pageTransition() {
// 定义页面进入时的效果，从左侧滑入，时长为1200ms，无论页面栈发生push还是pop操作均可生效
PageTransitionEnter({ duration: 1200 })
.slide(SlideEffect.Left)
// 定义页面退出时的效果，相对于正常页面位置x方向平移100vp，y方向平移100vp，透明度变为0，时长为1000ms，无论页面栈发生push还是pop操作均可生效
PageTransitionExit({ duration: 1000 })
.translate({ x: 100.0, y: 100.0 })
.opacity(0)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170311.06892348829279501572036738119815:50001231000000:2800:EE0A9B223841640552199BEE92A72D272AB077A3CCB043D3F164E6CA0D67949F.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-particle-animation-V14
爬取时间: 2025-04-27 23:31:10
来源: Huawei Developer
粒子动画是通过在限定区域内随机生成大量粒子的运动，进而组合成的动画效果，通过Particle组件来实现。动画的基本构成元素为单个粒子，这些粒子可以表现为圆点或图片等形式。开发者能够通过对粒子在颜色、透明度、大小、速度、加速度、自旋角度等多个维度上的动态变化做动画，以营造特定的氛围，例如模拟下雪场景时，飘舞的雪花实际上是由一个个雪花粒子的动画效果所构成。
粒子动画的简单实现如下所示。
```typescript
@Entry
@Component
struct ParticleExample {
build() {
Stack() {
Text()
.width(300).height(300).backgroundColor('rgb(240, 250, 255)')
Particle({ particles: [
{
emitter: {
particle: {
type: ParticleType.POINT, // 粒子类型
config: {
radius: 5 // 圆点半径
},
count: 100, // 粒子总数
},
},
color:{
range:['rgb(39, 135, 217)','rgb(0, 74, 175)'],//初始颜色范围
},
},
]
}).width(250).height(250)
}.width("100%").height("100%").align(Alignment.Center)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170311.94694535102125313147297651176993:50001231000000:2800:EAB04CC8EBB4ED2B879840384BA62A417C5CF4D13AEC8E056F4CA1244E3A8D01.gif)
实现粒子发射器
粒子发射器（Particle Emitter）主要定义粒子的初始属性（如类型、位置和颜色），控制粒子的生成速率，以及管理粒子的生命周期。可通过emitter方法调整粒子发射器的位置、发射速率和发射窗口的大小，实现发射器位置的动态更新。
```typescript
// ...
@State emitterProperties: Array<EmitterProperty> = [
{
index: 0,
emitRate: 100,
position: { x: 60, y: 80 },
size: { width: 200, height: 200 }
}
]
Particle(...).width(300).height(300).emitter(this.emitterProperties) // 动态调整粒子发射器的位置
// ...
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170311.44294521257061463403701154846106:50001231000000:2800:3DD13276B919E80D741F1FE043EA29964FEB00EE4D976305384EE26CE9CB2FE6.gif)
设置粒子颜色
可以通过range来确定粒子的初始颜色范围，而distributionType则用于指定粒子初始颜色随机值的分布方式，具体可选择均匀分布或者高斯（正态）分布。
```typescript
// ...
color: {
range: ['rgb(39, 135, 217)','rgb(0, 74, 175)'], // 初始颜色范围
distributionType: DistributionType.GAUSSIAN // 初始颜色随机值分布
},
// ...
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170311.84381746129054268277183982915302:50001231000000:2800:DAB8853FA61F825577BD20F98DED0C84DCE5877685BABD39BCDCFB8793BA260B.gif)
粒子的生命周期
粒子的生命周期（Lifecycle）是粒子从生成至消亡的整个过程，用于确定粒子的存活时间长度。粒子的生命周期可通过设置lifetime和lifetimeRange来指定。
```typescript
// ...
emitter: {
particle: {
// ...
lifetime: 300, // 粒子生命周期，单位ms
lifetimeRange: 100 // 粒子生命周期取值范围，单位ms
},
emitRate: 10, // 每秒发射粒子数
position: [0, 0],
shape: ParticleEmitterShape.RECTANGLE // 发射器形状
},
color: {
range: ['rgb(39, 135, 217)','rgb(0, 74, 175)'], // 初始颜色范围
},
// ...
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170311.86616748962163875208431146246561:50001231000000:2800:CAAA5B40B967694D3D4CE35CB37CBE7F8814647D3752B30E79E39C44C2985690.gif)
设置粒子扰动场
扰动场（Disturbance Field）是一种影响粒子运动的机制。通过在粒子所在的空间区域内施加特定的力，扰动场能够改变粒子的轨迹和行为，进而实现更为复杂和自然的动画效果。扰动场的配置可以通过disturbanceFields方法来完成。
```typescript
// ...
Particle({ particles: [
{
emitter: // ...
color: // ...
scale: {
range: [0.0, 0.0],
updater: {
type: ParticleUpdater.CURVE,
config: [
{
from: 0.0,
to: 0.5,
startMillis: 0,
endMillis: 3000,
curve: Curve.EaseIn
}
]
}
},
acceleration: { //加速度的配置，从大小和方向两个维度变化，speed表示加速度大小，angle表示加速度方向
speed: {
range: [3, 9],
updater: {
type: ParticleUpdater.RANDOM,
config: [1, 20]
}
},
angle: {
range: [90, 90]
}
}
}
]
}).width(300).height(300).disturbanceFields([{
strength: 10,
shape: DisturbanceFieldShape.RECT,
size: { width: 100, height: 100 },
position: { x: 100, y: 100 },
feather: 15,
noiseScale: 10,
noiseFrequency: 15,
noiseAmplitude: 5
}])
// ...
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170311.56356806105575872914858984889342:50001231000000:2800:118FD71110501BC177972E7F6DA0CC547C94DD4E1C904F7BDC78026779B48808.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-component-animation-V14
爬取时间: 2025-04-27 23:31:24
来源: Huawei Developer
ArkUI为组件提供了通用的属性动画和转场动画能力的同时，还为一些组件提供了默认的动画效果。例如，List的滑动动效、Button的点击动效，是组件自带的默认动画效果。在组件默认动画效果的基础上，开发者还可以通过属性动画和转场动画对容器组件内的子组件动效进行定制。
使用组件默认动画
组件默认动效具备以下功能：
-  提示用户当前状态，例如用户点击Button组件时，Button组件默认变灰，用户即确定完成选中操作。
-  提升界面精致程度和生动性。
-  减少开发者工作量，例如列表滑动组件自带滑动动效，开发者直接调用即可。
更多效果，可以参考组件说明。
示例代码和效果如下。
```typescript
@Entry
@Component
struct ComponentDemo {
build() {
Row() {
Checkbox({ name: 'checkbox1', group: 'checkboxGroup' })
.select(true)
.shape(CheckBoxShape.CIRCLE)
.size({ width: 50, height: 50 })
}
.width('100%')
.height('100%')
.justifyContent(FlexAlign.Center)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170312.95221033124820147285464243905808:50001231000000:2800:D151F4457F81E1522BB8065978F6AE2FEF75B166A1B6FE2FA1DC664FDDF62814.gif)
打造组件定制化动效
部分组件支持通过属性动画和转场动画自定义组件子Item的动效，实现定制化动画效果。例如，Scroll组件中可对各个子组件在滑动时的动画效果进行定制。
-  在滑动或者点击操作时通过改变各个Scroll子组件的仿射属性来实现各种效果。
-  如果要在滑动过程中定制动效，可在滑动回调onScroll中监控滑动距离，并计算每个组件的仿射属性。也可以自己定义手势，通过手势监控位置，手动调用ScrollTo改变滑动位置。
-  在滑动回调onScrollStop或手势结束回调中对滑动的最终位置进行微调。
定制Scroll组件滑动动效示例代码和效果如下。
```typescript
import { curves, window, display, mediaquery } from '@kit.ArkUI';
import { UIAbility } from '@kit.AbilityKit';
export default class GlobalContext extends AppStorage{
static mainWin: window.Window|undefined = undefined;
static mainWindowSize:window.Size|undefined = undefined;
}
/**
* 窗口、屏幕相关信息管理类
*/
export class WindowManager {
private static instance: WindowManager|null = null;
private displayInfo: display.Display|null = null;
private orientationListener = mediaquery.matchMediaSync('(orientation: landscape)');
constructor() {
this.orientationListener.on('change', (mediaQueryResult: mediaquery.MediaQueryResult) => { this.onPortrait(mediaQueryResult) })
this.loadDisplayInfo()
}
/**
* 设置主window窗口
* @param win 当前app窗口
*/
setMainWin(win: window.Window) {
if (win == null) {
return
}
GlobalContext.mainWin = win;
win.on("windowSizeChange", (data: window.Size) => {
if (GlobalContext.mainWindowSize == undefined || GlobalContext.mainWindowSize == null) {
GlobalContext.mainWindowSize = data;
} else {
if (GlobalContext.mainWindowSize.width == data.width && GlobalContext.mainWindowSize.height == data.height) {
return
}
GlobalContext.mainWindowSize = data;
}
let winWidth = this.getMainWindowWidth();
AppStorage.setOrCreate<number>('mainWinWidth', winWidth)
let winHeight = this.getMainWindowHeight();
AppStorage.setOrCreate<number>('mainWinHeight', winHeight)
let context:UIAbility = new UIAbility()
context.context.eventHub.emit("windowSizeChange", winWidth, winHeight)
})
}
static getInstance(): WindowManager {
if (WindowManager.instance == null) {
WindowManager.instance = new WindowManager();
}
return WindowManager.instance
}
private onPortrait(mediaQueryResult: mediaquery.MediaQueryResult) {
if (mediaQueryResult.matches == AppStorage.get<boolean>('isLandscape')) {
return
}
AppStorage.setOrCreate<boolean>('isLandscape', mediaQueryResult.matches)
this.loadDisplayInfo()
}
/**
* 切换屏幕方向
* @param ori 常量枚举值：window.Orientation
*/
changeOrientation(ori: window.Orientation) {
if (GlobalContext.mainWin != null) {
GlobalContext.mainWin.setPreferredOrientation(ori)
}
}
private loadDisplayInfo() {
this.displayInfo = display.getDefaultDisplaySync()
AppStorage.setOrCreate<number>('displayWidth', this.getDisplayWidth())
AppStorage.setOrCreate<number>('displayHeight', this.getDisplayHeight())
}
/**
* 获取main窗口宽度，单位vp
*/
getMainWindowWidth(): number {
return GlobalContext.mainWindowSize != null ? px2vp(GlobalContext.mainWindowSize.width) : 0
}
/**
* 获取main窗口高度，单位vp
*/
getMainWindowHeight(): number {
return GlobalContext.mainWindowSize != null ? px2vp(GlobalContext.mainWindowSize.height) : 0
}
/**
* 获取屏幕宽度，单位vp
*/
getDisplayWidth(): number {
return this.displayInfo != null ? px2vp(this.displayInfo.width) : 0
}
/**
* 获取屏幕高度，单位vp
*/
getDisplayHeight(): number {
return this.displayInfo != null ? px2vp(this.displayInfo.height) : 0
}
/**
* 释放资源
*/
release() {
if (this.orientationListener) {
this.orientationListener.off('change', (mediaQueryResult: mediaquery.MediaQueryResult) => { this.onPortrait(mediaQueryResult)})
}
if (GlobalContext.mainWin != null) {
GlobalContext.mainWin.off('windowSizeChange')
}
WindowManager.instance = null;
}
}
/**
* 封装任务卡片信息数据类
*/
export class TaskData {
bgColor: Color | string | Resource = Color.White;
index: number = 0;
taskInfo: string = 'music';
constructor(bgColor: Color | string | Resource, index: number, taskInfo: string) {
this.bgColor = bgColor;
this.index = index;
this.taskInfo = taskInfo;
}
}
export const taskDataArr: Array<TaskData> =
[
new TaskData('#317AF7', 0, 'music'),
new TaskData('#D94838', 1, 'mall'),
new TaskData('#DB6B42 ', 2, 'photos'),
new TaskData('#5BA854', 3, 'setting'),
new TaskData('#317AF7', 4, 'call'),
new TaskData('#D94838', 5, 'music'),
new TaskData('#DB6B42', 6, 'mall'),
new TaskData('#5BA854', 7, 'photos'),
new TaskData('#D94838', 8, 'setting'),
new TaskData('#DB6B42', 9, 'call'),
new TaskData('#5BA854', 10, 'music')
];
@Entry
@Component
export struct TaskSwitchMainPage {
displayWidth: number = WindowManager.getInstance().getDisplayWidth();
scroller: Scroller = new Scroller();
cardSpace: number = 0; // 卡片间距
cardWidth: number = this.displayWidth / 2 - this.cardSpace / 2; // 卡片宽度
cardHeight: number = 400; // 卡片高度
cardPosition: Array<number> = []; // 卡片初始位置
clickIndex: boolean = false;
@State taskViewOffsetX: number = 0;
@State cardOffset: number = this.displayWidth / 4;
lastCardOffset: number = this.cardOffset;
startTime: number|undefined=undefined
// 每个卡片初始位置
aboutToAppear() {
for (let i = 0; i < taskDataArr.length; i++) {
this.cardPosition[i] = i * (this.cardWidth + this.cardSpace);
}
}
// 每个卡片位置
getProgress(index: number): number {
let progress = (this.cardOffset + this.cardPosition[index] - this.taskViewOffsetX + this.cardWidth / 2) / this.displayWidth;
return progress
}
build() {
Stack({ alignContent: Alignment.Bottom }) {
// 背景
Column()
.width('100%')
.height('100%')
.backgroundColor(0xF0F0F0)
// 滑动组件
Scroll(this.scroller) {
Row({ space: this.cardSpace }) {
ForEach(taskDataArr, (item:TaskData, index) => {
Column()
.width(this.cardWidth)
.height(this.cardHeight)
.backgroundColor(item.bgColor)
.borderStyle(BorderStyle.Solid)
.borderWidth(1)
.borderColor(0xAFEEEE)
.borderRadius(15)
// 计算子组件的仿射属性
.scale((this.getProgress(index) >= 0.4 && this.getProgress(index) <= 0.6) ?
{
x: 1.1 - Math.abs(0.5 - this.getProgress(index)),
y: 1.1 - Math.abs(0.5 - this.getProgress(index))
} :
{ x: 1, y: 1 })
.animation({ curve: Curve.Smooth })
// 滑动动画
.translate({ x: this.cardOffset })
.animation({ curve: curves.springMotion() })
.zIndex((this.getProgress(index) >= 0.4 && this.getProgress(index) <= 0.6) ? 2 : 1)
}, (item:TaskData) => item.toString())
}
.width((this.cardWidth + this.cardSpace) * (taskDataArr.length + 1))
.height('100%')
}
.gesture(
GestureGroup(GestureMode.Parallel,
PanGesture({ direction: PanDirection.Horizontal, distance: 5 })
.onActionStart((event: GestureEvent|undefined) => {
if(event){
this.startTime = event.timestamp;
}
})
.onActionUpdate((event: GestureEvent|undefined) => {
if(event){
this.cardOffset = this.lastCardOffset + event.offsetX;
}
})
.onActionEnd((event: GestureEvent|undefined) => {
if(event){
let time = 0
if(this.startTime){
time = event.timestamp - this.startTime;
}
let speed = event.offsetX / (time / 1000000000);
let moveX = Math.pow(speed, 2) / 7000 * (speed > 0 ? 1 : -1);
this.cardOffset += moveX;
// 左滑大于最右侧位置
let cardOffsetMax = -(taskDataArr.length - 1) * (this.displayWidth / 2);
if (this.cardOffset < cardOffsetMax) {
this.cardOffset = cardOffsetMax;
}
// 右滑大于最左侧位置
if (this.cardOffset > this.displayWidth / 4) {
this.cardOffset = this.displayWidth / 4;
}
// 左右滑动距离不满足/满足切换关系时，补位/退回
let remainMargin = this.cardOffset % (this.displayWidth / 2);
if (remainMargin < 0) {
remainMargin = this.cardOffset % (this.displayWidth / 2) + this.displayWidth / 2;
}
if (remainMargin <= this.displayWidth / 4) {
this.cardOffset += this.displayWidth / 4 - remainMargin;
} else {
this.cardOffset -= this.displayWidth / 4 - (this.displayWidth / 2 - remainMargin);
}
// 记录本次滑动偏移量
this.lastCardOffset = this.cardOffset;
}
})
), GestureMask.IgnoreInternal)
.scrollable(ScrollDirection.Horizontal)
.scrollBar(BarState.Off)
// 滑动到首尾位置
Button('Move to first/last')
.backgroundColor(0x888888)
.margin({ bottom: 30 })
.onClick(() => {
this.clickIndex = !this.clickIndex;
if (this.clickIndex) {
this.cardOffset = this.displayWidth / 4;
} else {
this.cardOffset = this.displayWidth / 4 - (taskDataArr.length - 1) * this.displayWidth / 2;
}
this.lastCardOffset = this.cardOffset;
})
}
.width('100%')
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170312.74876889837802849869792272609827:50001231000000:2800:D4ED6AE841C2A4F590DFAAE6AD60CE3C5BFB05457D92E3304F5BB1C5F527FEB1.gif)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-animation-curve-V14
爬取时间: 2025-04-27 23:31:38
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-curve-overview-V14
爬取时间: 2025-04-27 23:31:52
来源: Huawei Developer
动画曲线是属性关于时间的变化函数，决定属性变化时产生动画的运动轨迹。某一时刻下动画曲线的斜率代表动画的速度，对应属性变化的快慢。一条优秀的动画曲线具备连续光滑、符合用户意图、符合物理世界客观规律的特点。开发者可结合用户的使用场景和意图，为动效选取合适的动画曲线。
根据动画曲线是否符合物理世界客观规律，可将其分为物理曲线（ArkUI当前提供了多种物理弹簧曲线）和传统曲线两种类型。相比于传统曲线，物理曲线产生的运动轨迹更加符合用户认知，有助于创造自然生动的动画效果，建议开发者优先使用物理曲线。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-traditional-curve-V14
爬取时间: 2025-04-27 23:32:06
来源: Huawei Developer
传统曲线基于数学公式，创造形状符合开发者预期的动画曲线。以三阶贝塞尔曲线为代表，通过调整曲线控制点，可以改变曲线形状，从而带来缓入、缓出等动画效果。对于同一条传统曲线，由于不具备物理含义，其形状不会因为用户行为发生任何改变，缺少物理动画的自然感和生动感。建议优先采用物理曲线创建动画，将传统曲线作为辅助用于极少数必要场景中。
ArkUI提供了贝塞尔曲线、阶梯曲线等传统曲线接口，开发者可参照插值计算进行查阅。
传统曲线的示例和效果如下：
```typescript
class MyCurve {
public title: string;
public curve: Curve;
public color: Color | string;
constructor(title: string, curve: Curve, color: Color | string = '') {
this.title = title;
this.curve = curve;
this.color = color;
}
}
const myCurves: MyCurve[] = [
new MyCurve(' Linear', Curve.Linear, '#317AF7'),
new MyCurve(' Ease', Curve.Ease, '#D94838'),
new MyCurve(' EaseIn', Curve.EaseIn, '#DB6B42'),
new MyCurve(' EaseOut', Curve.EaseOut, '#5BA854'),
new MyCurve(' EaseInOut', Curve.EaseInOut, '#317AF7'),
new MyCurve(' FastOutSlowIn', Curve.FastOutSlowIn, '#D94838')
]
@Entry
@Component
export struct CurveDemo {
@State dRotate: number = 0; // 旋转角度
build() {
Column() {
// 曲线图例
Grid() {
ForEach(myCurves, (item: MyCurve) => {
GridItem() {
Column() {
Row()
.width(30)
.height(30)
.borderRadius(15)
.backgroundColor(item.color)
Text(item.title)
.fontSize(15)
.fontColor(0x909399)
}
.width('100%')
}
})
}
.columnsTemplate('1fr 1fr 1fr')
.rowsTemplate('1fr 1fr 1fr 1fr 1fr')
.padding(10)
.width('100%')
.height(300)
.margin({ top: 50 })
Stack() {
// 摆动管道
Row()
.width(290)
.height(290)
.border({
width: 15,
color: 0xE6E8EB,
radius: 145
})
ForEach(myCurves, (item: MyCurve) => {
// 小球
Column() {
Row()
.width(30)
.height(30)
.borderRadius(15)
.backgroundColor(item.color)
}
.width(20)
.height(300)
.rotate({ angle: this.dRotate })
.animation({
duration: 2000,
iterations: -1,
curve: item.curve,
delay: 100
})
})
}
.width('100%')
.height(200)
.onClick(() => {
this.dRotate ? null : this.dRotate = 360;
})
}
.width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170312.28977514407784385913347267908841:50001231000000:2800:CF59AC7FEB04D1D8202613097E7F369D289640F56CD5DD9BE2171A9E330F37DB.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-spring-curve-V14
爬取时间: 2025-04-27 23:32:23
来源: Huawei Developer
阻尼弹簧曲线（以下简称弹簧曲线）对应的阻尼弹簧系统中，偏离平衡位置的物体一方面受到弹簧形变产生的反向作用力，被迫发生振动。另一方面，阻尼的存在为物体振动提供阻力。除阻尼为0的特殊情况，物体在振动过程中振幅不断减小，且最终趋于0，其轨迹对应的动画曲线自然连续。
采用弹簧曲线的动画在达终点时动画速度为0，不会产生动画“戛然而止”的观感，以避免影响用户体验。
ArkUI提供了四种阻尼弹簧曲线接口。
-  springMotion：创建弹性动画，动画时长由曲线参数、属性变化值大小和弹簧初速度自动计算，开发者指定的动画时长不生效。 springMotion不提供速度设置接口，速度通过继承获得，无需开发者指定。对于某个属性，如果当前存在正在运行的springMotion或者responsiveSpringMotion类型动画，新创建的弹簧动画将停止正在运行的动画，并继承其当前时刻的动画属性值和速度作为新建动画的初始状态。此外，接口提供默认参数，便于开发者直接使用。
```typescript
function springMotion(response?: number, dampingFraction?: number, overlapDuration?: number): ICurve;
```
-  responsiveSpringMotion：是springMotion动画的一种特例，仅默认参数不同。一般用于跟手做成动画的场景，离手时可用springMotion创建动画，此时离手阶段动画将自动继承跟手阶段动画速度，完成动画衔接。 当新动画的overlapDuration参数不为0，且当前属性的上一个springMotion动画还未结束时，response和dampingFraction将在overlapDuration指定的时间内，从旧动画的参数值过渡到新动画的参数值。
```typescript
function responsiveSpringMotion(response?: number, dampingFraction?: number, overlapDuration?: number): ICurve;
```
-  interpolatingSpring：适合于需要指定初速度的动效场景，动画时长同样由接口参数自动计算，开发者在动画接口中指定的时长不生效。 曲线接口提供速度入参，且由于接口对应一条从0到1的阻尼弹簧曲线，实际动画值根据曲线进行插值计算。所以速度也应该为归一化速度，其值等于动画属性改变的绝对速度除以动画属性改变量。因此不适合于动画起点属性值和终点属性值相同的场景，此时动画属性改变量为0，归一化速度不存在。
```typescript
function interpolatingSpring(velocity: number, mass: number, stiffness: number, damping: number): ICurve;
```
-  springCurve：适合于需要直接指定动画时长的场景。springCurve接口与interpolatingSpring接口几乎一致，但是对于采用springCurve的动画，会将曲线的物理时长映射到指定的时长，相当于在时间轴上拉伸或压缩曲线，破坏曲线原本的物理规律，因此不建议开发者使用。
```typescript
function springCurve(velocity: number, mass: number, stiffness: number, damping: number): ICurve;
```
关于弹簧曲线完整的使用示例和参考效果如下，开发者也可参考动画衔接，掌握使用responsiveSpringMotion和springMotion进行手势和动画之间的衔接。
弹簧曲线的示例代码和效果如下。
```typescript
import { curves } from '@kit.ArkUI';
class Spring {
public title: string;
public subTitle: string;
public iCurve: ICurve;
constructor(title: string, subTitle: string, iCurve: ICurve) {
this.title = title;
this.iCurve = iCurve;
this.subTitle = subTitle;
}
}
// 弹簧组件
@Component
struct Motion {
@Prop dRotate: number = 0
private title: string = ""
private subTitle: string = ""
private iCurve: ICurve | undefined = undefined
build() {
Column() {
Circle()
.translate({ y: this.dRotate })
.animation({ curve: this.iCurve, iterations: -1 })
.foregroundColor('#317AF7')
.width(30)
.height(30)
Column() {
Text(this.title)
.fontColor(Color.Black)
.fontSize(10).height(30)
Text(this.subTitle)
.fontColor(0xcccccc)
.fontSize(10).width(50)
}
.borderWidth({ top: 1 })
.borderColor(0xf5f5f5)
.width(80)
.alignItems(HorizontalAlign.Center)
.height(100)
}
.height(110)
.margin({ bottom: 5 })
.alignItems(HorizontalAlign.Center)
}
}
@Entry
@Component
export struct SpringCurve {
@State dRotate: number = 0;
private springs: Spring[] = [
new Spring('springMotion', '周期1, 阻尼0.25', curves.springMotion(1, 0.25)),
new Spring('responsive' + '\n' + 'SpringMotion', '弹性跟手曲线', curves.responsiveSpringMotion(1, 0.25)),
new Spring('interpolating' + '\n' + 'Spring', '初始速度10，质量1， 刚度228， 阻尼30',
curves.interpolatingSpring(10, 1, 228, 30)),
new Spring('springCurve', '初始速度10， 质量1， 刚度228， 阻尼30', curves.springCurve(10, 1, 228, 30))
];
build() {
Row() {
ForEach(this.springs, (item: Spring) => {
Motion({
title: item.title,
subTitle: item.subTitle,
iCurve: item.iCurve,
dRotate: this.dRotate
})
})
}
.justifyContent(FlexAlign.Center)
.alignItems(VerticalAlign.Bottom)
.width('100%')
.height(437)
.margin({ top: 20 })
.onClick(() => {
this.dRotate = -50;
})
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170312.25956285475743570472528329274610:50001231000000:2800:81149CAC02512D14FB9803FB350B621440618C9845AF81024C8A042CB498BFB4.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-animation-smoothing-V14
爬取时间: 2025-04-27 23:32:36
来源: Huawei Developer
UI界面除了运行动画之外，还承载着与用户进行实时交互的功能。当用户行为根据意图变化发生改变时，UI界面应做到即时响应。例如用户在应用启动过程中，上滑退出，那么启动动画应该立即过渡到退出动画，而不应该等启动动画完成后再退出，从而减少用户等待时间。对于桌面翻页类从跟手到离手触发动画的场景，离手后动画的初始速度应承继手势速度，避免由于速度不接续导致停顿感的产生。针对以上场景，系统已提供动画与动画、手势与动画之间的衔接能力，保证各类场景下动画平稳光滑地过渡的同时，尽可能降低开发难度。
假设对于某一可动画属性，存在正在运行的动画。当UI侧行为改变该属性终点值时，开发者仅需在animateTo动画闭包中改变属性值或者改变animation接口作用的属性值，即可产生动画。系统会自动衔接之前的动画和当前的动画，开发者仅需要关注当前单次动画的实现。
示例如下。通过点击click，红色方块的缩放属性会发生变化。当连续快速点击click时，缩放属性的终点值连续发生变化，当前动画也会平滑过渡到朝着新的缩放属性终点值运动。
```typescript
import { curves } from '@kit.ArkUI';
class SetSlt {
isAnimation: boolean = true
set(): void {
this.isAnimation = !this.isAnimation;
}
}
@Entry
@Component
struct AnimationToAnimationDemo {
// 第一步：声明相关状态变量
@State SetAnimation: SetSlt = new SetSlt();
build() {
Column() {
Text('ArkUI')
.fontWeight(FontWeight.Bold)
.fontSize(12)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.borderRadius(10)
.backgroundColor(0xf56c6c)
.width(100)
.height(100)
.scale({
// 第二步：将状态变量设置到相关可动画属性接口
x: this.SetAnimation.isAnimation ? 2 : 1,
y: this.SetAnimation.isAnimation ? 2 : 1
})
.animation({ curve: curves.springMotion(0.4, 0.8) }) // 第四步：通过隐式动画接口开启隐式动画，动画终点值改变时，系统自动添加衔接动画
Button('Click')
.margin({ top: 200 })
.onClick(() => {
// 第三步：通过点击事件改变状态变量值，影响可动画属性值
this.SetAnimation.set()
})
}
.width('100%')
.height('100%')
.justifyContent(FlexAlign.Center)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170312.92215922023854172568575027184487:50001231000000:2800:A20816547F84E08E7AEFA91FD3E60557C1D5CBC6C07EABAB4948BD8085A5AF24.gif)
手势与动画的衔接
使用滑动、捏合、旋转等手势的场景中，跟手过程中一般会触发属性的改变。离手后，这部分属性往往会继续发生变化，直到到达属性终点值。
离手阶段的属性变化初始速度应与离手前一刻的属性改变速度保持一致。如果离手后属性变化速度从0开始，就好像正在运行的汽车紧急刹车，造成观感上的骤变是用户和开发者都不希望看到的。
针对在TapGesture和动画之间进行衔接的场景（如列表滑动），可以在跟手阶段每一次更改组件属性时，都做成使用跟手弹簧曲线的属性动画。离手时再用离手弹簧曲线产生离手阶段的属性动画。对于采用springMotion曲线的动画，离手阶段动画将自动继承跟手阶段动画的速度，并以跟手动画当前位置为起点，运动到指定的属性终点。
示例代码如下，小球跟手运动。
```typescript
import { curves } from '@kit.ArkUI';
@Entry
@Component
struct SpringMotionDemo {
// 第一步：声明相关状态变量
@State positionX: number = 100;
@State positionY: number = 100;
diameter: number = 50;
build() {
Column() {
Row() {
Circle({ width: this.diameter, height: this.diameter })
.fill(Color.Blue)
.position({ x: this.positionX, y: this.positionY })// 第二步：将状态变量设置到相关可动画属性接口
.onTouch((event?: TouchEvent) => {
// 第三步：在跟手过程改变状态变量值，并且采用responsiveSpringMotion动画运动到新的值
if (event) {
if (event.type === TouchType.Move) {
// 跟手过程，使用responsiveSpringMotion曲线
this.getUIContext()?.animateTo({ curve: curves.responsiveSpringMotion() }, () => {
// 减去半径，以使球的中心运动到手指位置
this.positionX = event.touches[0].windowX - this.diameter / 2;
this.positionY = event.touches[0].windowY - this.diameter / 2;
console.info(`move, animateTo x:${this.positionX}, y:${this.positionY}`);
})
} else if (event.type === TouchType.Up) {
// 第四步：在离手过程设定状态变量终点值，并且用springMotion动画运动到新的值，springMotion动画将继承跟手阶段的动画速度
this.getUIContext()?.animateTo({ curve: curves.springMotion() }, () => {
this.positionX = 100;
this.positionY = 100;
console.info(`touchUp, animateTo x:100, y:100`);
})
}
}
})
}
.width("100%").height("80%")
.clip(true) // 如果球超出父组件范围，使球不可见
.backgroundColor(Color.Orange)
Flex({ direction: FlexDirection.Row, alignItems: ItemAlign.Start, justifyContent: FlexAlign.Center }) {
Text("拖动小球").fontSize(16)
}
.width("100%")
Row() {
Text('点击位置: [x: ' + Math.round(this.positionX) + ', y:' + Math.round(this.positionY) + ']').fontSize(16)
}
.padding(10)
.width("100%")
}.height('100%').width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170312.01170929775414062946479450023220:50001231000000:2800:5A5A7BD4715AEE87ECE0319C4DA9F6DAAEE071AF4B5A0E757B45752AF11D92BC.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-animation-effects-V14
爬取时间: 2025-04-27 23:32:50
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-blur-effect-V14
爬取时间: 2025-04-27 23:33:44
来源: Huawei Developer
动画效果可以丰富界面的细节，提升UI界面的真实感和品质感。例如，模糊和阴影效果可以让物体看起来更加立体，使得动画更加生动。ArkUI提供了丰富的效果接口，开发者可快速打造出精致、个性化的效果。本章中主要对常用的模糊、阴影和色彩效果等效果接口进行了介绍。
模糊可以用来体现界面空间的纵深感，区分前后元素的层级关系。
| 接口 | 说明 |
| --- | --- |
| backdropBlur | 为当前组件添加背景模糊效果，入参为模糊半径。 |
| blur | 为当前组件添加内容模糊效果，入参为模糊半径。 |
| backgroundBlurStyle | 为当前组件添加背景模糊效果，入参为模糊样式。 |
| foregroundBlurStyle | 为当前组件添加内容模糊效果，入参为模糊样式。 |
| motionBlur | 为当前组件添加由缩放大小或位移变化引起的运动过程中的动态模糊效果，入参为模糊半径和锚点坐标。 |
以上接口是实时模糊接口，会每帧进行实时渲染，性能负载较高。当模糊内容和模糊半径都不需要变化时，建议使用静态模糊接口blur。
使用backdropBlur为组件添加背景模糊
```typescript
@Entry
@Component
struct BlurEffectsExample {
build() {
Column({ space: 10 }) {
Text('backdropBlur')
.width('90%')
.height('90%')
.fontSize(20)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.backdropBlur(10)// 对背景进行模糊
.backgroundImage($r('app.media.share'))
.backgroundImageSize({ width: 400, height: 300 })
}
.width('100%')
.height('50%')
.margin({ top: 20 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170312.11095938418491502668259530567730:50001231000000:2800:3C2B5BB469106540D823509F10BE47110CF69E59E4C7FD83DCC372CC7A5C8C15.png)
使用blur为组件添加内容模糊
```typescript
@Entry
@Component
struct Index1 {
@State radius: number = 0;
@State text: string = '';
@State y: string = '手指不在屏幕上';
aboutToAppear() {
this.text = "按住屏幕上下滑动\n" + "当前手指所在y轴位置 ： " + this.y +
"\n" + "当前图片模糊程度为 : " + this.radius;
}
build() {
Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.SpaceBetween }) {
Text(this.text)
.height(200)
.fontSize(20)
.fontWeight(FontWeight.Bold)
.fontFamily("cursive")
.fontStyle(FontStyle.Italic)
Image($r("app.media.wall"))
.blur(this.radius)// 使用blur接口为照片组件添加内容模糊效果
.height('100%')
.width("100%")
.objectFit(ImageFit.Cover)
}.height('100%')
.width("100%")
.onTouch((event?: TouchEvent) => {
if (event) {
if (event.type === TouchType.Move) {
this.y = Number(event.touches[0].y.toString()).toString();
this.radius = Number(this.y) / 10; // 根据跟手过程中的滑动距离修改模糊半径，配合模糊接口，形成跟手模糊效果
}
if (event.type === TouchType.Up) {
this.radius = 0;
this.y = '手指离开屏幕';
}
}
this.text = "按住屏幕上下滑动\n" + "当前手指所在y轴位置 ： " + this.y +
"\n" + "当前图片模糊程度为 : " + this.radius;
})
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170312.66401745631603175664563995817164:50001231000000:2800:D4AE6E6FA434239300767B5B63AA5FD2FF0C3919002A542CC90C248CAC5C1AAC.gif)
使用backgroundBlurStyle为组件添加背景模糊效果
```typescript
@Entry
@Component
struct BackDropBlurStyleDemo {
build() {
Grid() {
GridItem() {
Column() {
Column() {
Text('原图')
.fontSize(20)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
Text('原图')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('Thin')
.fontSize(20)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
// BlurStyle.Thin: 为组件添加轻薄材质模糊效果
// ThemeColorMode.LIGHT: 固定使用浅色模式效果
// AdaptiveColor.DEFAULT: 不使用取色模糊，使用默认的颜色作为蒙版颜色
// scale: 背景材质模糊效果程度，默认值是1
.backgroundBlurStyle(BlurStyle.Thin, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('Thin')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('Regular')
.fontSize(20)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
.backgroundBlurStyle(BlurStyle.Regular, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('Regular')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('Thick')
.fontSize(20)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
.backgroundBlurStyle(BlurStyle.Thick, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('Thick')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('BACKGROUND_THIN')
.fontSize(12)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
.backgroundBlurStyle(BlurStyle.BACKGROUND_THIN, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('BACKGROUND_THIN')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('BACKGROUND_REGULAR')
.fontSize(12)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
.backgroundBlurStyle(BlurStyle.BACKGROUND_REGULAR, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('BACKGROUND_REGULAR')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('BACKGROUND_THICK')
.fontSize(12)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
.backgroundBlurStyle(BlurStyle.BACKGROUND_THICK, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('BACKGROUND_THICK')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('BACKGROUND_ULTRA_THICK')
.fontSize(12)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
.backgroundBlurStyle(BlurStyle.BACKGROUND_ULTRA_THICK, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('BACKGROUND_ULTRA_THICK')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
}
.columnsTemplate('1fr 1fr')
.rowsTemplate('1fr 1fr 1fr 1fr')
.width('100%')
.height('100%')
.margin({ top: 40 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170312.43395043295391791776996010048147:50001231000000:2800:E8BA357D0D1E4BF42B76388F0849ACCC25DB9396A3F6A9B83BDDF03177F670AF.png)
使用foregroundBlurStyle为组件添加内容模糊效果
```typescript
@Entry
@Component
struct ForegroundBlurStyleDemo {
build() {
Grid() {
GridItem() {
Column() {
Column() {
Text('原图')
.fontSize(20)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
Text('原图')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('Thin')
.fontSize(20)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
// BlurStyle.Thin: 为组件添加轻薄材质模糊效果
// ThemeColorMode.LIGHT: 固定使用浅色模式效果
// AdaptiveColor.DEFAULT: 不使用取色模糊，使用默认的颜色作为蒙版颜色
// scale: 背景材质模糊效果程度，默认值是1
.foregroundBlurStyle(BlurStyle.Thin, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('Thin')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('Regular')
.fontSize(20)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
.foregroundBlurStyle(BlurStyle.Regular, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('Regular')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('Thick')
.fontSize(20)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
.foregroundBlurStyle(BlurStyle.Thick, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('Thick')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('BACKGROUND_THIN')
.fontSize(12)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
.foregroundBlurStyle(BlurStyle.BACKGROUND_THIN, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('BACKGROUND_THIN')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('BACKGROUND_REGULAR')
.fontSize(12)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
.foregroundBlurStyle(BlurStyle.BACKGROUND_REGULAR, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('BACKGROUND_REGULAR')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('BACKGROUND_THICK')
.fontSize(12)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
.foregroundBlurStyle(BlurStyle.BACKGROUND_THICK, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('BACKGROUND_THICK')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
GridItem() {
Column() {
Column() {
Text('BACKGROUND_ULTRA_THICK')
.fontSize(12)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.width('100%')
.height('100%')
}
.height(100)
.aspectRatio(1)
.borderRadius(10)
.backgroundImage($r('app.media.share'))
.foregroundBlurStyle(BlurStyle.BACKGROUND_ULTRA_THICK, {
colorMode: ThemeColorMode.LIGHT,
adaptiveColor: AdaptiveColor.DEFAULT,
scale: 0.1
})
Text('BACKGROUND_ULTRA_THICK')
.fontSize(12)
.fontColor(Color.Black)
}
.height('100%')
.justifyContent(FlexAlign.Start)
}
.width(200)
.height(200)
}
.columnsTemplate('1fr 1fr')
.rowsTemplate('1fr 1fr 1fr 1fr')
.width('100%')
.height('100%')
.margin({ top: 40 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170313.03958646667800708477304430902125:50001231000000:2800:5C76A7A42EF248EB0703AEF31914F7F57885336DCDC47ADC638FB0046713C31E.png)
使用motionBlur为组件添加运动模糊效果
```typescript
import { curves } from '@kit.ArkUI';
@Entry
@Component
struct motionBlurTest {
@State widthSize: number = 400
@State heightSize: number = 320
@State flag: boolean = true
@State radius: number = 0
@State x: number = 0
@State y: number = 0
build() {
Column() {
Column() {
Image($r('app.media.testImg'))
.width(this.widthSize)
.height(this.heightSize)
.onClick(() => {
this.radius = 5;
this.x = 0.5;
this.y = 0.5;
if (this.flag) {
this.widthSize = 100;
this.heightSize = 80;
} else {
this.widthSize = 400;
this.heightSize = 320;
}
this.flag = !this.flag;
})
.animation({
duration: 2000,
curve: curves.springCurve(10, 1, 228, 30),
onFinish: () => {
this.radius = 0;
}
})
.motionBlur({ radius: this.radius, anchor: { x: this.x, y: this.y } })
}
}.width('100%').margin({ top: 5 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170313.29881466782115796033166465085109:50001231000000:2800:6C592F32AD5022DF0F0887C7753394FC7D936B69A60D6E76710DB097F3CE9C34.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-shadow-effect-V14
爬取时间: 2025-04-27 23:33:58
来源: Huawei Developer
阴影接口shadow可以为当前组件添加阴影效果，该接口支持两种类型参数，开发者可配置ShadowOptions自定义阴影效果。ShadowOptions模式下，当radius = 0 或者 color 的透明度为0时，无阴影效果。
```typescript
@Entry
@Component
struct ShadowOptionDemo {
build() {
Row() {
Column() {
Column() {
Text('shadowOption').fontSize(12)
}
.width(100)
.aspectRatio(1)
.margin(10)
.justifyContent(FlexAlign.Center)
.backgroundColor(Color.White)
.borderRadius(20)
.shadow({ radius: 10, color: Color.Gray })
Column() {
Text('shadowOption').fontSize(12)
}
.width(100)
.aspectRatio(1)
.margin(10)
.justifyContent(FlexAlign.Center)
.backgroundColor('#a8a888')
.borderRadius(20)
.shadow({
radius: 10,
color: Color.Gray,
offsetX: 20,
offsetY: 20
})
}
.width('100%')
.height('100%')
.justifyContent(FlexAlign.Center)
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170313.97585979539440477521890246277666:50001231000000:2800:35DE853D0648CA8433E987655F0740A2D8750061E1A8BFD8D0647FE6EA802CBE.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-color-effect-V14
爬取时间: 2025-04-27 23:34:12
来源: Huawei Developer
色彩
通过颜色渐变接口，可以设置组件的背景颜色渐变效果，实现在两个或多个指定的颜色之间进行平稳的过渡。
| 接口 | 说明 |
| --- | --- |
| linearGradient | 为当前组件添加线性渐变的颜色渐变效果。 |
| sweepGradient | 为当前组件添加角度渐变的颜色渐变效果。 |
| radialGradient | 为当前组件添加径向渐变的颜色渐变效果。 |
为组件添加线性渐变效果
```typescript
@Entry
@Component
struct LinearGradientDemo {
build() {
Grid() {
GridItem() {
Column() {
Text('angle: 180')
.fontSize(15)
}
.width(100)
.height(100)
.justifyContent(FlexAlign.Center)
.borderRadius(10)
.linearGradient({
// 0点方向顺时针旋转为正向角度，线性渐变起始角度的默认值为180°
colors: [
[0xf56c6c, 0.0], // 颜色断点1的颜色和比重，对应组件在180°方向上的起始位置
[0xffffff, 1.0],// 颜色断点2的颜色和比重，对应组件在180°方向上的终点位置
]
})
}
GridItem() {
Column() {
Text('angle: 45')
.fontSize(15)
}
.width(100)
.height(100)
.justifyContent(FlexAlign.Center)
.borderRadius(10)
.linearGradient({
angle: 45, // 设置颜色渐变起始角度为顺时针方向45°
colors: [
[0xf56c6c, 0.0],
[0xffffff, 1.0],
]
})
}
GridItem() {
Column() {
Text('repeat: true')
.fontSize(15)
}
.width(100)
.height(100)
.justifyContent(FlexAlign.Center)
.borderRadius(10)
.linearGradient({
repeating: true, // 在当前组件内0.3到1.0区域内重复0到0.3区域的颜色渐变效果
colors: [
[0xf56c6c, 0.0],
[0xE6A23C, .3],
]
})
}
GridItem() {
Column() {
Text('repeat: false')
.fontSize(15)
}
.width(100)
.height(100)
.justifyContent(FlexAlign.Center)
.borderRadius(10)
.linearGradient({
colors: [
[0xf56c6c, 0.0], // repeating默认为false，此时组件内只有0到0.3区域内存在颜色渐变效果
[0xE6A23C, .3],
]
})
}
}
.columnsGap(10)
.rowsGap(10)
.columnsTemplate('1fr 1fr')
.rowsTemplate('1fr 1fr 1fr')
.width('100%')
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170313.38241584867223983800218318403818:50001231000000:2800:894F2DF0BADD86E3EE1B8EAEE17E8EFAA3DED30B42018E9857FEBE2A18C792CA.png)
为组件添加角度渐变效果
```typescript
@Entry
@Component
struct SweepGradientDemo {
build() {
Grid() {
GridItem() {
Column() {
Text('center: 50')
.fontSize(15)
}
.width(100)
.height(100)
.justifyContent(FlexAlign.Center)
.borderRadius(10)
.sweepGradient({
center: [50, 50], // 角度渐变中心点
start: 0, // 角度渐变的起点
end: 360, // 角度渐变的终点。
repeating: true, // 渐变效果在重复
colors: [
// 当前组件中，按照中心点和渐变的起点和终点值,
// 角度区域为0-0.125的范围，从颜色断点1的颜色渐变到颜色断点2的颜色,
// 角度区域0.125到0.25的范围，从颜色断点2的颜色渐变到颜色断点3的颜色,
// 因为repeating设置为true，角度区域0.25到1的范围，重复区域0到0.25的颜色渐变效果
[0xf56c6c, 0], // 颜色断点1的颜色和比重，对应角度为0*360°=0°，角点为中心点
[0xffffff, 0.125], // 颜色断点2的颜色和比重
[0x409EFF, 0.25]// 颜色断点3的颜色和比重
]
})
}
GridItem() {
Column() {
Text('center: 0')
.fontSize(15)
}
.width(100)
.height(100)
.justifyContent(FlexAlign.Center)
.borderRadius(10)
.sweepGradient({
center: [0, 0], // 角度渐变中心点，当前为组件的左上角坐标
start: 0,
end: 360,
repeating: true,
colors: [
// 当前组件中，因为角度渐变中心是组件的左上角，所以从颜色断点1到颜色断点3的角度范围，恰好可以覆盖整个组件
[0xf56c6c, 0], // 颜色断点1的颜色和比重，对应角度为0*360°=0°
[0xffffff, 0.125], // 色断点2的颜色和比重，对应角度为0.125*360°=45°
[0x409EFF, 0.25]// 色断点3的颜色和比重，对应角度为0.25*360°=90°
]
})
}
GridItem() {
Column() {
Text('repeat: true')
.fontSize(15)
}
.width(100)
.height(100)
.justifyContent(FlexAlign.Center)
.borderRadius(10)
.sweepGradient({
center: [50, 50],
start: 0,
end: 360,
repeating: true,
colors: [
[0xf56c6c, 0],
[0xffffff, 0.125],
[0x409EFF, 0.25]
]
})
}
GridItem() {
Column() {
Text('repeat: false')
.fontSize(15)
}
.width(100)
.height(100)
.justifyContent(FlexAlign.Center)
.borderRadius(10)
.sweepGradient({
center: [50, 50],
start: 0,
end: 360,
repeating: false, //只在颜色断点角度覆盖范围内产生颜色渐变效果，其余范围内不重复
colors: [
[0xf56c6c, 0],
[0xffffff, 0.125],
[0x409EFF, 0.25]
]
})
}
}
.columnsGap(10)
.rowsGap(10)
.columnsTemplate('1fr 1fr')
.rowsTemplate('1fr 1fr 1fr')
.width('100%')
.height(437)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170313.21448715814538685108607195198740:50001231000000:2800:D7D5D1ADFEE8683D319107471F2A76B68E0FF3CC72E854C140E864F31FB8F5D4.png)
为组件添加径向渐变效果
```typescript
@Entry
@Component
struct radialGradientDemo {
build() {
Grid() {
GridItem() {
Column() {
Text('center: 50')
.fontSize(15)
}
.width(100)
.height(100)
.justifyContent(FlexAlign.Center)
.borderRadius(10)
.radialGradient({
center: [50, 50], // 径向渐变中心点
radius: 100, // 径向渐变半径
repeating: true, // 允许在组件内渐变范围外重复按照渐变范围内效果着色
colors: [
// 组件内以[50，50]为中心点，在半径为0到12.5的范围内从颜色断点1的颜色渐变到颜色断点2的颜色,
// 在半径为12.5到25的范围内从颜色断点2的颜色渐变到颜色断点3的颜色,
// 组件外其他半径范围内按照半径为0到25的渐变效果重复着色
[0xf56c6c, 0], // 颜色断点1的颜色和比重，对应半径为0*100=0
[0xffffff, 0.125], // 颜色断点2的颜色和比重，对应半径为0.125*100=12.5
[0x409EFF, 0.25]// 颜色断点3的颜色和比重，对应半径为0.25*100=25
]
})
}
GridItem() {
Column() {
Text('center: 0')
.fontSize(15)
}
.width(100)
.height(100)
.justifyContent(FlexAlign.Center)
.borderRadius(10)
.radialGradient({
center: [0, 0], // 径向渐变中心点，当前为组件左上角坐标
radius: 100,
repeating: true,
colors: [
[0xf56c6c, 0],
[0xffffff, 0.125],
[0x409EFF, 0.25]
]
})
}
GridItem() {
Column() {
Text('repeat: true')
.fontSize(15)
}
.width(100)
.height(100)
.justifyContent(FlexAlign.Center)
.borderRadius(10)
.radialGradient({
center: [50, 50],
radius: 100,
repeating: true,
colors: [
[0xf56c6c, 0],
[0xffffff, 0.125],
[0x409EFF, 0.25]
]
})
}
GridItem() {
Column() {
Text('repeat: false')
.fontSize(15)
}
.width(100)
.height(100)
.justifyContent(FlexAlign.Center)
.borderRadius(10)
.radialGradient({
center: [50, 50],
radius: 100,
repeating: false, // 在组件内渐变范围外不重复按照渐变范围内效果着色
colors: [
[0xf56c6c, 0],
[0xffffff, 0.125],
[0x409EFF, 0.25]
]
})
}
}
.columnsGap(10)
.rowsGap(10)
.columnsTemplate('1fr 1fr')
.rowsTemplate('1fr 1fr 1fr')
.width('100%')
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170313.12377492790951588095879502337289:50001231000000:2800:6F01B20625856B3E7FFAC5792514CBEF64AC3CB63F09AC7C0358076B2431C6C8.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-animator-V14
爬取时间: 2025-04-27 23:34:26
来源: Huawei Developer
帧动画具备逐帧回调的特性，便于开发者在每一帧中处理需调整的属性。通过向应用提供onFrame逐帧回调，帧动画使开发者能够在应用的每一帧设置属性值，从而实现组件属性值变化的自然过渡，营造出动画效果。帧动画接口详情可参考@ohos.animator (动画)。
与属性动画相比，帧动画能让开发者实时感知动画进程，即时调整UI值，具备事件即时响应和可暂停的优势，但在性能上略逊于属性动画。当属性动画能满足需求时，建议优先采用属性动画接口实现。属性动画接口可参考实现属性动画。
| 名称 | 实现方式 | 事件响应方式 | 可暂停 | 性能 |
| --- | --- | --- | --- | --- |
| 帧动画（ohos.animator） | 开发者可每帧修改UI侧属性值，UI侧属性实时更新 | 实时响应 | 是 | 较差 |
| 属性动画 | UI侧只计算动画最终状态，动画过程为渲染值在改变，UI侧一直为动画最终状态，不感知实时渲染值 | 按最终状态响应 | 否 | 较好 |
如图所示，帧动画在动画过程中即可实时响应，而属性动画按最终状态响应。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170313.08831069270931778560645512171647:50001231000000:2800:015BACA5F80348F4B2ABE7F43988AF6EA0E0A4A4BC8A836D45257C0D093A40F8.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170313.42521060717810461006615059629617:50001231000000:2800:E113AF84AAA21EABD6527C0E90CAFAF8E6E10FF0269DD0703221357DB6F084FF.gif)
使用帧动画实现动画效果
使用如下步骤可以创建一个简单的animator，并且在每个帧回调中打印当前插值。
1.  引入相关依赖。
```typescript
import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';
```
2.  创建执行动画的对象。
```typescript
// 创建动画的初始参数
let options: AnimatorOptions = {
duration: 1500,
easing: "friction",
delay: 0,
fill: "forwards",
direction: "normal",
iterations: 2,
// 动画onFrame 插值首帧值
begin: 200.0,
// 动画onFrame 插值尾帧值
end: 400.0
};
let result: AnimatorResult = this.getUIContext().createAnimator(options);
// 设置接收到帧时回调，动画播放过程中每帧会调用onFrame回调
result.onFrame = (value: number) => {
console.log("current value is :" + value);
}
```
3.  播放动画。
```typescript
// 播放动画
result.play();
```
4.  动画执行完成后手动释放AnimatorResult对象。
```typescript
// 释放动画对象
result = undefined;
```
使用帧动画实现小球抛物运动
1.  引入相关依赖。
```typescript
import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';
```
2.  定义要做动画的组件。
```typescript
Button()
.width(60)
.height(60)
.translate({ x: this.translateX, y: this.translateY })
```
3.  在onPageShow中创建AnimatorResult对象。
```typescript
onPageShow(): void {
//创建animatorResult对象
this.animatorOptions = this.getUIContext().createAnimator(options);
this.animatorOptions.onFrame = (progress: number) => {
this.translateX = progress;
if (progress > this.topWidth && this.translateY < this.bottomHeight) {
this.translateY = Math.pow(progress - this.topWidth, 2) * this.g;
}
}
//动画取消时执行方法
this.animatorOptions.onCancel = () => {
this.animatorStatus = '取消';
}
//动画完成时执行方法
this.animatorOptions.onFinish = () => {
this.animatorStatus = '完成';
}
//动画重复播放时执行方法
this.animatorOptions.onRepeat = () => {
console.log("动画重复播放");
}
}
```
4.  定义动画播放，重置，暂停的按钮。
```typescript
Button('播放').onClick(() => {
this.animatorOptions?.play();
this.animatorStatus = '播放中'
}).width(80).height(35)
Button("重置").onClick(() => {
this.translateX = 0;
this.translateY = 0;
}).width(80).height(35)
Button("暂停").onClick(() => {
this.animatorOptions?.pause();
this.animatorStatus = '暂停'
}).width(80).height(35)
```
5.  在页面隐藏或销毁的生命周期中释放动画对象，避免内存泄漏。
```typescript
onPageHide(): void {
this.animatorOptions = undefined;
}
```
完整示例如下。
```typescript
import { AnimatorOptions, AnimatorResult } from '@kit.ArkUI';
@Entry
@Component
struct Index {
@State animatorOptions: AnimatorResult | undefined = undefined;
@State animatorStatus: string = '创建';
begin: number = 0;
end: number = 300
topWidth: number = 150;
bottomHeight: number = 100;
g: number = 0.18
animatorOption: AnimatorOptions = {
duration: 4000,
delay: 0,
easing: 'linear',
iterations: 1,
fill: "forwards",
direction: 'normal',
begin: this.begin,
end: this.end
};
@State translateX: number = 0;
@State translateY: number = 0;
onPageShow(): void {
this.animatorOptions = this.getUIContext().createAnimator(this.animatorOption)
this.animatorOptions.onFrame = (progress: number) => {
this.translateX = progress;
if (progress > this.topWidth && this.translateY < this.bottomHeight) {
this.translateY = Math.pow(progress - this.topWidth, 2) * this.g;
}
}
this.animatorOptions.onCancel = () => {
this.animatorStatus = '取消';
}
this.animatorOptions.onFinish = () => {
this.animatorStatus = '完成';
}
this.animatorOptions.onRepeat = () => {
console.log("动画重复播放");
}
}
onPageHide(): void {
this.animatorOptions = undefined;
}
build() {
Column() {
Column({ space: 30 }) {
Button('播放').onClick(() => {
this.animatorOptions?.play();
this.animatorStatus = '播放中';
}).width(80).height(35)
Button("重置").onClick(() => {
this.translateX = 0;
this.translateY = 0;
}).width(80).height(35)
Button("暂停").onClick(() => {
this.animatorOptions?.pause();
this.animatorStatus = '暂停';
}).width(80).height(35)
}.width("100%").height('25%')
Stack() {
Button()
.width(60)
.height(60)
.translate({ x: this.translateX, y: this.translateY })
}
.width("100%")
.height('45%')
.align(Alignment.Start)
Text("当前动画状态为:" + this.animatorStatus)
}.width("100%").height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170313.79571931417934119879039119646434:50001231000000:2800:693704874AD3B7660678B01C978C2E1B645C9832FED3FBFE2CF4A4570B9F7373.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-events-V14
爬取时间: 2025-04-27 23:34:39
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-event-overview-V14
爬取时间: 2025-04-27 23:34:53
来源: Huawei Developer
通用事件按照触发类型来分类，包括触屏事件、键鼠事件、焦点事件和拖拽事件。
-  触屏事件：手指或手写笔在触屏上的单指或单笔操作。
-  键鼠事件：包括外设鼠标或触控板的操作事件和外设键盘的按键事件。
-  焦点事件：通过以上方式控制组件焦点的能力和响应的事件。
-  拖拽事件：由触屏事件和键鼠事件发起，包括手指/手写笔长按组件拖拽和鼠标拖拽。
-  事件分发：描述触控类事件（不包括按键，焦点）响应链的命中收集过程。
手势事件由绑定手势方法和绑定的手势组成，绑定的手势可以分为单一手势和组合手势两种类型，根据手势的复杂程度进行区分。
-  绑定手势方法：用于在组件上绑定单一手势或组合手势，并声明所绑定的手势的响应优先级。
-  单一手势：手势的基本单元，是所有复杂手势的组成部分。
-  组合手势：由多个单一手势组合而成，可以根据声明的类型将多个单一手势按照一定规则组合成组合手势，并进行使用。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-events-V14
爬取时间: 2025-04-27 23:35:07
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-events-distribute-V14
爬取时间: 2025-04-27 23:35:20
来源: Huawei Developer
概述
事件分发是指ArkUI收到用户操作生成的触控事件，通过触摸测试，将触控事件分发至各个组件形成事件的过程。
触控事件是触摸测试的输入，根据用户操作方式的不同，可以划分为Touch类触控事件和Mouse类触控事件。
-  Touch类触控事件指触摸生成的触控事件，输入源包含：finger（手指在屏幕滑动）、pen（手写笔在屏幕滑动）、mouse（鼠标操作）、touchpad（触控板操作），可以触发触摸事件、点击事件、拖拽事件和手势事件。
-  Mouse类触控事件指鼠标操作生成的触控事件，输入源包含：mouse（鼠标操作）、touchpad（触控板操作）、joystick（手柄操作），可以触发触摸事件、点击事件、拖拽事件、手势事件和鼠标事件。
不论是Touch类触控事件还是Mouse类触控事件，最后触发的事件均是通过触摸测试决定最终所分发到的组件。触摸测试决定了ArkUI事件响应链生成、触控事件分发以及组件绑定事件的触发。
触摸测试
触摸测试是指当ArkUI收到了Touch类触控事件或者Mouse类触控事件的起始事件（如手指或者鼠标光标按下时生成的事件），基于所收到的事件的坐标，进行组件响应区域的测试判定并收集事件响应链的过程。
开发者可以通过设置以下属性影响触摸测试流程：
-  hitTestBehavior：触摸测试控制
-  interceptTouch：事件自定义拦截
-  responseRegion：触摸热区设置
-  enabled：禁用控制
-  安全组件
-  其他属性设置：透明度/组件下线
触摸测试基本流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170314.57591065096547688713093886185382:50001231000000:2800:E9AF5643280F18BE6CAE36A52D683C4C63B248F62D66946C4666F26B0FBBEBAE.png)
触摸测试的基本流程如下：接收到起始事件后，系统将自上而下、自右向左遍历组件树，收集每个组件上绑定的手势和事件，然后将这些信息逐级向上冒泡至父组件进行整合，最终构建完整的事件响应链。
如图所示，当起始事件被分发至组件时，组件会收集自身绑定的手势与事件，随后将收集结果传递给父组件，直至达到根节点。若组件透明、已从组件树中移除，或事件坐标不在组件响应热区范围内，将不会触发收集过程，父组件接收的反馈为空。除此之外，所有组件均会执行手势与事件的收集，并将结果反馈给父组件。
触摸测试控制
在组件上绑定触摸测试控制时，可能会影响到兄弟节点以及父子节点的触摸测试。子组件对父组件的触摸测试影响程度，取决于最后一个未被阻塞触摸测试的子组件状态。
开发者可以通过配置触摸测试控制，来实现阻塞组件自身或其他组件的触摸测试。
-  HitTestMode.Default：默认不配hitTestBehavior属性的效果，自身如果命中会阻塞兄弟组件，但是不阻塞子组件。
-  HitTestMode.None：自身不接收事件，但不会阻塞兄弟组件/子组件继续做触摸测试。
-  HitTestMode.Block：阻塞子组件的触摸测试，如果自身触摸测试命中，会阻塞兄弟组件及父组件的触摸测试。
-  HitTestMode.Transparent：自身进行触摸测试，同时不阻塞兄弟组件及父组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170314.02062892669869934924303206839680:50001231000000:2800:7F849360DA6ED774BBD6BD0429E90DC1A72919029F437C38620D0E76AF721A2A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170314.07974338708295488241553407549761:50001231000000:2800:1FE83A399C07E0A36F675088D5CA6C780EC32D7C69AC377B97DAACECE916F443.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170314.81441491580906370328751471083978:50001231000000:2800:8259EF95B143E3B03FE24B4AED37D4F94FB58F89BDA0717B77F878B826788687.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170314.20537194302455750858826090604052:50001231000000:2800:570EB49F83115EB6F8545D056AC20438291F37F194C443435916D5F99DA016B5.png)
自定义事件拦截
当用户执行按下操作时，将触发组件上绑定的自定义事件拦截的回调。开发者可根据应用状态，动态调整组件的hitTestBehavior属性，进而影响触控测试的流程。
禁用控制
设置了禁用控制的组件，组件自身和其子组件不会发起触摸测试过程，会直接返回组件的父组件继续触摸测试。
触摸热区设置
触摸热区设置会影响触屏/鼠标类的触摸测试。根据触摸测试的基本流程，仅当事件的坐标命中组件的触摸热区时，该组件绑定的手势和事件才会被收集并进入事件响应链。开发者可以通过调整组件的触摸热区来控制触摸测试流程。若触摸热区被设置为0，或定义为不可触控区域，事件将直接回传给父节点，以进行后续的触摸测试。
安全组件
ArkUI包含的安全组件有：使用位置组件、使用粘贴组件、使用保存组件等。
安全组件当前对触摸测试影响：如果有组件的z序比安全组件的z序靠前，且遮盖安全组件，则安全组件事件直接返回到父节点继续触摸测试。
事件响应链的收集
事件响应链为触摸测试的结果。ArkUI事件响应链收集，遵循右子树（按组件布局的先后层级）优先的后序遍历。伪代码实现为：
事件响应链收集举例：按下图的组件树，hitTestBehavior属性均为默认，用户点按的动作如果发生在组件5上，则最终收集到的响应链，以及先后关系是5，3，1。
因为组件3的hitTestBehavior属性为Default，收集到事件后会阻塞兄弟节点，所以没有收集组件1的左子树。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170314.89160630766011129224025338606747:50001231000000:2800:AE1A1BDE75CA014D034DC3795FFA2F6EF050209B4BA674C3C7DCB45F663298B3.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-events-touch-screen-event-V14
爬取时间: 2025-04-27 23:35:34
来源: Huawei Developer
触屏事件指当手指/手写笔在组件上按下、滑动、抬起时触发的回调事件。包括点击事件、拖拽事件和触摸事件。
图1触摸事件原理
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170314.31869680245869200464587120159233:50001231000000:2800:FF10316E36F7732F8C58F46480563A014B6043B6BD88AA87BF7E8B68F7CE3553.png)
点击事件
点击事件是指通过手指或手写笔做出一次完整的按下和抬起动作。当发生点击事件时，会触发以下回调函数：
```typescript
onClick(event: (event?: ClickEvent) => void)
```
event参数提供点击事件相对于窗口或组件的坐标位置，以及发生点击的事件源。
例如通过按钮的点击事件控制图片的显示和隐藏。
```typescript
@Entry
@Component
struct IfElseTransition {
@State flag: boolean = true;
@State btnMsg: string = 'show';
build() {
Column() {
Button(this.btnMsg).width(80).height(30).margin(30)
.onClick(() => {
if (this.flag) {
this.btnMsg = 'hide';
} else {
this.btnMsg = 'show';
}
// 点击Button控制Image的显示和消失
this.flag = !this.flag;
})
if (this.flag) {
Image($r('app.media.icon')).width(200).height(200)
}
}.height('100%').width('100%')
}
}
```
图2通过按钮的点击事件控制图片的显示和隐藏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170314.63111317571359761534102116897974:50001231000000:2800:5340DBE15A3D3D8786D7D7F5C161C1FC71C717187A3AD9B632688832676BD63B.gif)
触摸事件
当手指或手写笔在组件上触碰时，会触发不同动作所对应的事件响应，包括按下（Down）、滑动（Move）、抬起（Up）事件：
```typescript
onTouch(event: (event?: TouchEvent) => void)
```
-  event.type为TouchType.Down：表示手指按下。
-  event.type为TouchType.Up：表示手指抬起。
-  event.type为TouchType.Move：表示手指按住移动。
-  event.type为TouchType.Cancel：表示打断取消当前手指操作。
触摸事件可以同时多指触发，通过event参数可获取触发的手指位置、手指唯一标志、当前发生变化的手指和输入的设备源等信息。
```typescript
// xxx.ets
@Entry
@Component
struct TouchExample {
@State text: string = '';
@State eventType: string = '';
build() {
Column() {
Button('Touch').height(40).width(100)
.onTouch((event?: TouchEvent) => {
if(event){
if (event.type === TouchType.Down) {
this.eventType = 'Down';
}
if (event.type === TouchType.Up) {
this.eventType = 'Up';
}
if (event.type === TouchType.Move) {
this.eventType = 'Move';
}
this.text = 'TouchType:' + this.eventType + '\nDistance between touch point and touch element:\nx: '
+ event.touches[0].x + '\n' + 'y: ' + event.touches[0].y + '\nComponent globalPos:('
+ event.target.area.globalPosition.x + ',' + event.target.area.globalPosition.y + ')\nwidth:'
+ event.target.area.width + '\nheight:' + event.target.area.height
}
})
Button('Touch').height(50).width(200).margin(20)
.onTouch((event?: TouchEvent) => {
if(event){
if (event.type === TouchType.Down) {
this.eventType = 'Down';
}
if (event.type === TouchType.Up) {
this.eventType = 'Up';
}
if (event.type === TouchType.Move) {
this.eventType = 'Move';
}
this.text = 'TouchType:' + this.eventType + '\nDistance between touch point and touch element:\nx: '
+ event.touches[0].x + '\n' + 'y: ' + event.touches[0].y + '\nComponent globalPos:('
+ event.target.area.globalPosition.x + ',' + event.target.area.globalPosition.y + ')\nwidth:'
+ event.target.area.width + '\nheight:' + event.target.area.height
}
})
Text(this.text)
}.width('100%').padding(30)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170314.42775161197608161345993039091752:50001231000000:2800:AE99D7162EBEEC38CA20108664B0F3F9D7124560A6EE3617153D974C095BE5BA.gif)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-events-device-input-event-V14
爬取时间: 2025-04-27 23:35:48
来源: Huawei Developer
键鼠事件指键盘，鼠标外接设备的输入事件。
鼠标事件
支持的鼠标事件包含通过外设鼠标、触控板触发的事件。
鼠标事件可触发以下回调：
| 名称 | 描述 |
| --- | --- |
| onHover(event: (isHover: boolean) => void) | 鼠标进入或退出组件时触发该回调。 isHover：表示鼠标是否悬浮在组件上，鼠标进入时为true, 退出时为false。 |
| onMouse(event: (event?: MouseEvent) => void) | 当前组件被鼠标按键点击时或者鼠标在组件上悬浮移动时，触发该回调，event返回值包含触发事件时的时间戳、鼠标按键、动作、鼠标位置在整个屏幕上的坐标和相对于当前组件的坐标。 |
鼠标进入或退出组件时触发该回调。
isHover：表示鼠标是否悬浮在组件上，鼠标进入时为true, 退出时为false。
当组件绑定onHover回调时，可以通过hoverEffect属性设置该组件的鼠标悬浮态显示效果。
图1鼠标事件数据流
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170314.43598078150365374263049413190527:50001231000000:2800:FA8A7139E9DEA9F4746F7FC6F795427E11D47F2A819CBEFB0853E0F991A7FAD8.png)
鼠标事件传递到ArkUI之后，会先判断鼠标事件是否是左键的按下/抬起/移动，然后做出不同响应：
-  是：鼠标事件先转换成相同位置的触摸事件，执行触摸事件的碰撞测试、手势判断和回调响应。接着去执行鼠标事件的碰撞测试和回调响应。
-  否：事件仅用于执行鼠标事件的碰撞测试和回调响应。
所有单指可响应的触摸事件/手势事件，均可通过鼠标左键来操作和响应。例如当我们需要开发单击Button跳转页面的功能、且需要支持手指点击和鼠标左键点击，那么只绑定一个点击事件（onClick）就可以实现该效果。若需要针对手指和鼠标左键的点击实现不一样的效果，可以在onClick回调中，使用回调参数中的source字段即可判断出当前触发事件的来源是手指还是鼠标。
onHover
```typescript
onHover(event: (isHover: boolean) => void)
```
鼠标悬浮事件回调。参数isHover类型为boolean，表示鼠标进入组件或离开组件。该事件不支持自定义冒泡设置，默认父子冒泡。
若组件绑定了该接口，当鼠标指针从组件外部进入到该组件的瞬间会触发事件回调，参数isHover等于true；鼠标指针离开组件的瞬间也会触发该事件回调，参数isHover等于false。
事件冒泡：在一个树形结构中，当子节点处理完一个事件后，再将该事件交给它的父节点处理。
```typescript
// xxx.ets
@Entry
@Component
struct MouseExample {
@State hoverText: string = 'Not Hover';
@State Color: Color = Color.Gray;
build() {
Column() {
Button(this.hoverText)
.width(200).height(100)
.backgroundColor(this.Color)
.onHover((isHover?: boolean) => { // 使用onHover接口监听鼠标是否悬浮在Button组件上
if (isHover) {
this.hoverText = 'Hovered!';
this.Color = Color.Green;
}
else {
this.hoverText = 'Not Hover';
this.Color = Color.Gray;
}
})
}.width('100%').height('100%').justifyContent(FlexAlign.Center)
}
}
```
该示例创建了一个Button组件，初始背景色为灰色，内容为“Not Hover”。示例中的Button组件绑定了onHover回调，在该回调中将this.isHovered变量置为回调参数：isHover。
当鼠标从Button外移动到Button内的瞬间，回调响应，isHover值等于true，isHovered的值变为true，将组件的背景色改成Color.Green，内容变为“Hovered!”。
当鼠标从Button内移动到Button外的瞬间，回调响应，isHover值等于false，又将组件变成了初始的样式。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170314.50810782569039650311997965118979:50001231000000:2800:6E789A779018AB3DFFAA9195B9CD9AC69DF6BC52ADFA5733F6499BC2F9955BB6.gif)
onMouse
```typescript
onMouse(event: (event?: MouseEvent) => void)
```
鼠标事件回调。绑定该API的组件每当鼠标指针在该组件内产生行为（MouseAction）时，触发事件回调，参数为MouseEvent对象，表示触发此次的鼠标事件。该事件支持自定义冒泡设置，默认父子冒泡。常用于开发者自定义的鼠标行为逻辑处理。
开发者可以通过回调中的MouseEvent对象获取触发事件的坐标（displayX/displayY/windowX/windowY/x/y）、按键（MouseButton）、行为（MouseAction）、时间戳（timestamp）、交互组件的区域（EventTarget）、事件来源（SourceType）等。MouseEvent的回调函数stopPropagation用于设置当前事件是否阻止冒泡。
按键（MouseButton）的值：Left/Right/Middle/Back/Forward 均对应鼠标上的实体按键，当这些按键被按下或松开时触发这些按键的事件。None表示无按键，会出现在鼠标没有按键按下或松开的状态下，移动鼠标所触发的事件中。
```typescript
// xxx.ets
@Entry
@Component
struct MouseExample {
@State buttonText: string = '';
@State columnText: string = '';
@State hoverText: string = 'Not Hover';
@State Color: Color = Color.Gray;
build() {
Column() {
Button(this.hoverText)
.width(200)
.height(100)
.backgroundColor(this.Color)
.onHover((isHover?: boolean) => {
if (isHover) {
this.hoverText = 'Hovered!';
this.Color = Color.Green;
}
else {
this.hoverText = 'Not Hover';
this.Color = Color.Gray;
}
})
.onMouse((event?: MouseEvent) => { // 设置Button的onMouse回调
if (event) {
this.buttonText = 'Button onMouse:\n' + '' +
'button = ' + event.button + '\n' +
'action = ' + event.action + '\n' +
'x,y = (' + event.x + ',' + event.y + ')' + '\n' +
'windowXY=(' + event.windowX + ',' + event.windowY + ')';
}
})
Divider()
Text(this.buttonText).fontColor(Color.Green)
Divider()
Text(this.columnText).fontColor(Color.Red)
}
.width('100%')
.height('100%')
.justifyContent(FlexAlign.Center)
.borderWidth(2)
.borderColor(Color.Red)
.onMouse((event?: MouseEvent) => { // Set the onMouse callback for the column.
if (event) {
this.columnText = 'Column onMouse:\n' + '' +
'button = ' + event.button + '\n' +
'action = ' + event.action + '\n' +
'x,y = (' + event.x + ',' + event.y + ')' + '\n' +
'windowXY=(' + event.windowX + ',' + event.windowY + ')';
}
})
}
}
```
在onHover示例的基础上，给Button绑定onMouse接口。在回调中，打印出鼠标事件的button/action等回调参数值。同时，在外层的Column容器上，也做相同的设置。整个过程可以分为以下两个动作：
1.  移动鼠标：当鼠标从Button外部移入Button的过程中，仅触发了Column的onMouse回调；当鼠标移入到Button内部后，由于onMouse事件默认是冒泡的，所以此时会同时响应Column的onMouse回调和Button的onMouse回调。此过程中，由于鼠标仅有移动动作没有点击动作，因此打印信息中的button均为0（MouseButton.None的枚举值）、action均为3（MouseAction.Move的枚举值）。
2.  点击鼠标：鼠标进入Button后进行了2次点击，分别是左键点击和右键点击。 左键点击时：button = 1（MouseButton.Left的枚举值），按下时：action = 1（MouseAction.Press的枚举值），抬起时：action = 2（MouseAction.Release的枚举值）。 右键点击时：button = 2（MouseButton.Right的枚举值），按下时：action = 1（MouseAction.Press的枚举值），抬起时：action = 2（MouseAction.Release的枚举值）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170314.32184676662213290762042972604224:50001231000000:2800:ABE9119000768FE6A6E07DED4EFF1D97B46CDB67420788C2B6BD224C7B3BE526.gif)
如果需要阻止鼠标事件冒泡，可以通过调用stopPropagation()方法进行设置。
```typescript
class ish{
isHovered:boolean = false
set(val:boolean){
this.isHovered = val;
}
}
class butf{
buttonText:string = ''
set(val:string){
this.buttonText = val
}
}
@Entry
@Component
struct MouseExample {
@State isHovered:ish = new ish()
build(){
Column(){
Button(this.isHovered ? 'Hovered!' : 'Not Hover')
.width(200)
.height(100)
.backgroundColor(this.isHovered ? Color.Green : Color.Gray)
.onHover((isHover?: boolean) => {
if(isHover) {
let ishset = new ish()
ishset.set(isHover)
}
})
.onMouse((event?: MouseEvent) => {
if (event) {
if (event.stopPropagation) {
event.stopPropagation(); // 在Button的onMouse事件中设置阻止冒泡
}
let butset = new butf()
butset.set('Button onMouse:\n' + '' +
'button = ' + event.button + '\n' +
'action = ' + event.action + '\n' +
'x,y = (' + event.x + ',' + event.y + ')' + '\n' +
'windowXY=(' + event.windowX + ',' + event.windowY + ')');
}
})
}
}
}
```
在子组件（Button）的onMouse中，通过回调参数event调用stopPropagation回调方法（如下）即可阻止Button子组件的鼠标事件冒泡到父组件Column上。
```typescript
event.stopPropagation()
```
效果是：当鼠标在Button组件上操作时，仅Button的onMouse回调会响应，Column的onMouse回调不会响应。
hoverEffect
```typescript
hoverEffect(value: HoverEffect)
```
鼠标悬浮态效果设置的通用属性。参数类型为HoverEffect，HoverEffect提供的Auto、Scale、Highlight效果均为固定效果，开发者无法自定义设置效果参数。
表1HoverEffect说明
| HoverEffect枚举值 | 效果说明 |
| --- | --- |
| Auto | 组件默认提供的悬浮态效果，由各组件定义。 |
| Scale | 动画播放方式，鼠标悬浮时：组件大小从100%放大至105%，鼠标离开时：组件大小从105%缩小至100%。 |
| Highlight | 动画播放方式，鼠标悬浮时：组件背景色叠加一个5%透明度的白色，视觉效果是组件的原有背景色变暗，鼠标离开时：组件背景色恢复至原有样式。 |
| None | 禁用悬浮态效果。 |
```typescript
// xxx.ets
@Entry
@Component
struct HoverExample {
build() {
Column({ space: 10 }) {
Button('Auto')
.width(170).height(70)
Button('Scale')
.width(170).height(70)
.hoverEffect(HoverEffect.Scale)
Button('Highlight')
.width(170).height(70)
.hoverEffect(HoverEffect.Highlight)
Button('None')
.width(170).height(70)
.hoverEffect(HoverEffect.None)
}.width('100%').height('100%').justifyContent(FlexAlign.Center)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170315.45290703256430643754532630707872:50001231000000:2800:7E6DACED015D215480E8DFDD876FD6EB6F268C431033CFF67CF3836EC8BDE2C6.gif)
Button默认的悬浮态效果就是Highlight效果，因此Auto和Highlight的效果一样，Highlight会使背板颜色变暗，Scale会让组件缩放，None会禁用悬浮态效果。
按键事件
按键事件数据流
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170315.81647758105861667615326678086185:50001231000000:2800:F6F59CF094310FAAD82A9372DEE34A53D1DDEBAB116AD50897CDF201B5CEEDC1.png)
按键事件由外设键盘等设备触发，经驱动和多模处理转换后发送给当前获焦的窗口，窗口获取到事件后，会尝试分发三次事件。三次分发的优先顺序如下，一旦事件被消费，则跳过后续分发流程。
因此，当某输入框组件获焦，且打开了输入法，此时大部分按键事件均会被输入法消费。例如字母键会被输入法用来往输入框中输入对应字母字符、方向键会被输入法用来切换选中备选词。如果在此基础上给输入框组件绑定了快捷键，那么快捷键会优先响应事件，事件也不再会被输入法消费。
按键事件到ArkUI框架之后，会先找到完整的父子节点获焦链。从叶子节点到根节点，逐一发送按键事件。
Web组件的KeyEvent流程与上述过程有所不同。对于Web组件，不会在onKeyPreIme返回false时候，去匹配快捷。而是第三次按键派发中，Web对于未消费的KeyEvent会通过ReDispatch重新派发回ArkUI。在ReDispatch中再执行匹配快捷键等操作。
onKeyEvent & onKeyPreIme
```typescript
onKeyEvent(event: (event: KeyEvent) => void): T
onKeyPreIme(event: Callback<KeyEvent, boolean>): T
```
上述两种方法的区别仅在于触发的时机（见按键事件数据流）。其中onKeyPreIme的返回值决定了该按键事件后续是否会被继续分发给页面快捷键、输入法和onKeyEvent。
当绑定方法的组件处于获焦状态下，外设键盘的按键事件会触发该方法，回调参数为KeyEvent，可由该参数获得当前按键事件的按键行为（KeyType）、键码（keyCode）、按键英文名称（keyText）、事件来源设备类型（KeySource）、事件来源设备id（deviceId）、元键按压状态（metaKey）、时间戳（timestamp）、阻止冒泡设置（stopPropagation）。
```typescript
// xxx.ets
@Entry
@Component
struct KeyEventExample {
@State buttonText: string = '';
@State buttonType: string = '';
@State columnText: string = '';
@State columnType: string = '';
build() {
Column() {
Button('onKeyEvent')
.defaultFocus(true)
.width(140).height(70)
.onKeyEvent((event?: KeyEvent) => { // 给Button设置onKeyEvent事件
if(event){
if (event.type === KeyType.Down) {
this.buttonType = 'Down';
}
if (event.type === KeyType.Up) {
this.buttonType = 'Up';
}
this.buttonText = 'Button: \n' +
'KeyType:' + this.buttonType + '\n' +
'KeyCode:' + event.keyCode + '\n' +
'KeyText:' + event.keyText;
}
})
Divider()
Text(this.buttonText).fontColor(Color.Green)
Divider()
Text(this.columnText).fontColor(Color.Red)
}.width('100%').height('100%').justifyContent(FlexAlign.Center)
.onKeyEvent((event?: KeyEvent) => { // 给父组件Column设置onKeyEvent事件
if(event){
if (event.type === KeyType.Down) {
this.columnType = 'Down';
}
if (event.type === KeyType.Up) {
this.columnType = 'Up';
}
this.columnText = 'Column: \n' +
'KeyType:' + this.buttonType + '\n' +
'KeyCode:' + event.keyCode + '\n' +
'KeyText:' + event.keyText;
}
})
}
}
```
上述示例中给组件Button和其父容器Column绑定onKeyEvent。应用打开页面加载后，组件树上第一个可获焦的非容器组件自动获焦，设置Button为当前页面的默认焦点，由于Button是Column的子节点，Button获焦也同时意味着Column获焦。获焦机制见焦点事件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170315.28589779408396608982639215156138:50001231000000:2800:5E9A86F61D98870CAF9693868325F30FB6D563881A7B9EEAC7767C376A1B4440.gif)
打开应用后，依次在键盘上按这些按键：“空格、回车、左Ctrl、左Shift、字母A、字母Z”。
1.  由于onKeyEvent事件默认是冒泡的，所以Button和Column的onKeyEvent都可以响应。
2.  每个按键都有2次回调，分别对应KeyType.Down和KeyType.Up，表示按键被按下、然后抬起。
如果要阻止冒泡，即仅Button响应键盘事件，Column不响应，在Button的onKeyEvent回调中加入event.stopPropagation()方法即可，如下：
```typescript
@Entry
@Component
struct KeyEventExample {
@State buttonText: string = '';
@State buttonType: string = '';
@State columnText: string = '';
@State columnType: string = '';
build() {
Column() {
Button('onKeyEvent')
.defaultFocus(true)
.width(140).height(70)
.onKeyEvent((event?: KeyEvent) => {
// 通过stopPropagation阻止事件冒泡
if(event){
if(event.stopPropagation){
event.stopPropagation();
}
if (event.type === KeyType.Down) {
this.buttonType = 'Down';
}
if (event.type === KeyType.Up) {
this.buttonType = 'Up';
}
this.buttonText = 'Button: \n' +
'KeyType:' + this.buttonType + '\n' +
'KeyCode:' + event.keyCode + '\n' +
'KeyText:' + event.keyText;
}
})
Divider()
Text(this.buttonText).fontColor(Color.Green)
Divider()
Text(this.columnText).fontColor(Color.Red)
}.width('100%').height('100%').justifyContent(FlexAlign.Center)
.onKeyEvent((event?: KeyEvent) => { // 给父组件Column设置onKeyEvent事件
if(event){
if (event.type === KeyType.Down) {
this.columnType = 'Down';
}
if (event.type === KeyType.Up) {
this.columnType = 'Up';
}
this.columnText = 'Column: \n' +
'KeyType:' + this.buttonType + '\n' +
'KeyCode:' + event.keyCode + '\n' +
'KeyText:' + event.keyText;
}
})
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170315.51432397653494526866527434362529:50001231000000:2800:34C2DA852D378EF66BA64E7E8ED6786524C0ECE789B1D01D1B61C62D91E205A0.gif)
使用OnKeyPreIme屏蔽在输入框中使用方向左键。
```typescript
import { KeyCode } from '@kit.InputKit';
@Entry
@Component
struct PreImeEventExample {
@State buttonText: string = '';
@State buttonType: string = '';
@State columnText: string = '';
@State columnType: string = '';
build() {
Column() {
Search({
placeholder: "Search..."
})
.width("80%")
.height("40vp")
.border({ radius:"20vp" })
.onKeyPreIme((event:KeyEvent) => {
if (event.keyCode == KeyCode.KEYCODE_DPAD_LEFT) {
return true;
}
return false;
})
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-events-focus-event-V14
爬取时间: 2025-04-27 23:36:02
来源: Huawei Developer
基础概念与规范
基础概念
焦点、焦点链和走焦
焦点态
用来指向当前获焦组件的样式。
层级页面
层级页面是焦点框架中特定容器组件的统称，涵盖Page、Dialog、SheetPage、ModalPage、Menu、Popup、NavBar、NavDestination等。这些组件通常具有以下关键特性：
在一个应用程序中，任何时候都至少存在一个层级页面组件，并且该组件会持有当前焦点。当该层级页面关闭或不再可见时，焦点会自动转移到下一个可用的层级页面组件上，确保用户交互的连贯性和一致性。
Popup组件在focusable属性（组件属性，非通用属性）为false的时候，不会有第2条特性。
NavBar、NavDestination没有第3条特性，对于它们的走焦范围，是与它们的首个父层级页面相同的。
根容器
根容器是层级页面内的概念，当某个层级页面首次创建并展示时，根据层级页面的特性，焦点会立即被该页面抢占。此时，该层级页面所在焦点链的末端节点将成为默认焦点，而这个默认焦点通常位于该层级页面的根容器上。
在缺省状态下，层级页面的默认焦点位于其根容器上，但开发者可以通过defaultFocus属性来自定义这一行为。
当焦点位于根容器时，首次按下TAB键不仅会使焦点进入激活状态，还会触发焦点向子组件的传递。如果子组件本身也是一个容器，则焦点会继续向下传递，直至到达叶子节点。传递规则是：优先传递给上一次获得焦点的子节点，如果不存在这样的节点，则默认传递给第一个子节点。
走焦规范
根据走焦的触发方式，可以分为主动走焦和被动走焦。
主动走焦
指开发者/用户主观行为导致的焦点移动，包括：使用外接键盘的按键走焦（TAB键/Shift+TAB键/方向键）、使用requestFocus申请焦点、clearFocus清除焦点、focusOnTouch点击申请焦点等接口导致的焦点转移。
1.  按键类型： TAB键：遵循Z字型遍历逻辑，完成当前范围内所有叶子节点的遍历，到达当前范围内的最后一个组件后，继续按下TAB键，焦点将循环至范围内的第一个可获焦组件，实现循环走焦。 Shift+TAB键：与TAB键具有相反的焦点转移效果。 方向键（上、下、左、右）：遵循十字型移动策略，在单层容器中，焦点的转移由该容器的特定走焦算法决定。若算法判定下一个焦点应落在某个容器组件上，系统将采用中心点距离优先的算法来进一步确定容器内的目标子节点。
-  requestFocus 详见主动获焦失焦，可以主动将焦点转移到指定组件上。 不可跨窗口，不可跨ArkUI实例申请焦点，可以跨层级页面申请焦点。
-  clearFocus 详见clearFocus，会清除当前层级页面中的焦点，最终焦点停留在根容器上。
-  focusOnTouch 详见focusOnTouch，使绑定组件具备点击后获得焦点的能力。若组件本身不可获焦，则此功能无效。若绑定的是容器组件，点击后优先将焦点转移给上一次获焦的子组件，否则转移给第一个可获焦的子组件。
被动走焦
被动走焦是指组件焦点因系统或其他操作而自动转移，无需开发者直接干预，这是焦点系统的默认行为。
目前会被动走焦的机制有：
走焦算法
在焦点管理系统中，每个可获焦的容器都配备有特定的走焦算法，这些算法定义了当使用TAB键、Shift+TAB键或方向键时，焦点如何从当前获焦的子组件转移到下一个可获焦的子组件。
容器采用何种走焦算法取决于其UX（用户体验）规格，并由容器组件进行适配。目前，焦点框架支持三种走焦算法：线性走焦、投影走焦和自定义走焦。
线性走焦算法
线性走焦算法是默认的走焦策略，它基于容器中子节点在节点树中的挂载顺序进行走焦，常用于单方向布局的容器，如Row、Column和Flex容器。运行规则如下：
投影走焦算法
投影走焦算法基于当前获焦组件在走焦方向上的投影，结合子组件与投影的重叠面积和中心点距离进行胜出判定。该算法特别适用于子组件大小不一的容器，目前仅有配置了wrap属性的Flex组件。运行规则如下：
自定义走焦算法
由组件自定义的走焦算法，规格由组件定义。
获焦/失焦事件
```typescript
onFocus(event: () => void)
```
获焦事件回调，绑定该接口的组件获焦时，回调响应。
```typescript
onBlur(event:() => void)
```
失焦事件回调，绑定该接口的组件失焦时，回调响应。
onFocus和onBlur两个接口通常成对使用，来监听组件的焦点变化。
```typescript
// xxx.ets
@Entry
@Component
struct FocusEventExample {
@State oneButtonColor: Color = Color.Gray;
@State twoButtonColor: Color = Color.Gray;
@State threeButtonColor: Color = Color.Gray;
build() {
Column({ space: 20 }) {
// 通过外接键盘的上下键可以让焦点在三个按钮间移动，按钮获焦时颜色变化，失焦时变回原背景色
Button('First Button')
.width(260)
.height(70)
.backgroundColor(this.oneButtonColor)
.fontColor(Color.Black)
// 监听第一个组件的获焦事件，获焦后改变颜色
.onFocus(() => {
this.oneButtonColor = Color.Green;
})
// 监听第一个组件的失焦事件，失焦后改变颜色
.onBlur(() => {
this.oneButtonColor = Color.Gray;
})
Button('Second Button')
.width(260)
.height(70)
.backgroundColor(this.twoButtonColor)
.fontColor(Color.Black)
// 监听第二个组件的获焦事件，获焦后改变颜色
.onFocus(() => {
this.twoButtonColor = Color.Green;
})
// 监听第二个组件的失焦事件，失焦后改变颜色
.onBlur(() => {
this.twoButtonColor = Color.Grey;
})
Button('Third Button')
.width(260)
.height(70)
.backgroundColor(this.threeButtonColor)
.fontColor(Color.Black)
// 监听第三个组件的获焦事件，获焦后改变颜色
.onFocus(() => {
this.threeButtonColor = Color.Green;
})
// 监听第三个组件的失焦事件，失焦后改变颜色
.onBlur(() => {
this.threeButtonColor = Color.Gray ;
})
}.width('100%').margin({ top: 20 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170315.38772906555446767602833787745959:50001231000000:2800:2A8D1512E8659ABA779FC68B81BC2355EA03AEA322BFD9D7B184728D80B0B03F.gif)
上述示例包含以下3步：
设置组件是否可获焦
```typescript
focusable(value: boolean)
```
设置组件是否可获焦。
按照组件的获焦能力可大致分为三类：
-  默认可获焦的组件，通常是有交互行为的组件，例如Button、Checkbox、TextInput组件，此类组件无需设置任何属性，默认即可获焦。
-  有获焦能力，但默认不可获焦的组件，典型的是Text、Image组件，此类组件缺省情况下无法获焦，若需要使其获焦，可使用通用属性focusable(true)使能。对于没有配置focusable属性，有获焦能力但默认不可获焦的组件，为其配置onClick或是单指单击的Tap手势，该组件会隐式地成为可获焦组件。如果其focusable属性被设置为false，即使配置了上述事件，该组件依然不可获焦。
-  无获焦能力的组件，通常是无任何交互行为的展示类组件，例如Blank、Circle组件，此类组件即使使用focusable属性也无法使其可获焦。
```typescript
enabled(value: boolean)
```
设置组件可交互性属性enabled为false，则组件不可交互，无法获焦。
```typescript
visibility(value: Visibility)
```
设置组件可见性属性visibility为Visibility.None或Visibility.Hidden，则组件不可见，无法获焦。
```typescript
focusOnTouch(value: boolean)
```
设置当前组件是否支持点击获焦能力。
当某组件处于获焦状态时，将其的focusable属性或enabled属性设置为false，会自动使该组件失焦，然后焦点按照走焦规范将焦点转移给其他组件。
```typescript
// xxx.ets
@Entry
@Component
struct FocusableExample {
@State textFocusable: boolean = true;
@State textEnabled: boolean = true;
@State color1: Color = Color.Yellow;
@State color2: Color = Color.Yellow;
@State color3: Color = Color.Yellow;
build() {
Column({ space: 5 }) {
Text('Default Text')    // 第一个Text组件未设置focusable属性，默认不可获焦
.borderColor(this.color1)
.borderWidth(2)
.width(300)
.height(70)
.onFocus(() => {
this.color1 = Color.Blue;
})
.onBlur(() => {
this.color1 = Color.Yellow;
})
Divider()
Text('focusable: ' + this.textFocusable)    // 第二个Text设置了focusable初始为true，focusableOnTouch为true
.borderColor(this.color2)
.borderWidth(2)
.width(300)
.height(70)
.focusable(this.textFocusable)
.focusOnTouch(true)
.onFocus(() => {
this.color2 = Color.Blue;
})
.onBlur(() => {
this.color2 = Color.Yellow;
})
Text('enabled: ' + this.textEnabled)    // 第三个Text设置了focusable为true，enabled初始为true
.borderColor(this.color3)
.borderWidth(2)
.width(300)
.height(70)
.focusable(true)
.enabled(this.textEnabled)
.focusOnTouch(true)
.onFocus(() => {
this.color3 = Color.Blue;
})
.onBlur(() => {
this.color3 = Color.Yellow;
})
Divider()
Row() {
Button('Button1')
.width(140).height(70)
Button('Button2')
.width(160).height(70)
}
Divider()
Button('Button3')
.width(300).height(70)
Divider()
}.width('100%').justifyContent(FlexAlign.Center)
.onKeyEvent((e) => {
// 绑定onKeyEvent，在该Column组件获焦时，按下'F'键，可将第二个Text的focusable置反
if (e.keyCode === 2022 && e.type === KeyType.Down) {
this.textFocusable = !this.textFocusable;
}
// 绑定onKeyEvent，在该Column组件获焦时，按下'G'键，可将第三个Text的enabled置反
if (e.keyCode === 2023 && e.type === KeyType.Down) {
this.textEnabled = !this.textEnabled;
}
})
}
}
```
运行效果：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170315.22632699018658815246744169178540:50001231000000:2800:63FF1748C6EEBB4E9E69DBD39D0118DA7608197DDE318A04AE4D200D4D0AFC41.gif)
上述示例包含以下3步：
默认焦点
页面的默认焦点
```typescript
defaultFocus(value: boolean)
```
设置当前组件是否为当前页面上的默认焦点。
```typescript
// xxx.ets
@Entry
@Component
struct morenjiaodian {
@State oneButtonColor: Color = Color.Gray;
@State twoButtonColor: Color = Color.Gray;
@State threeButtonColor: Color = Color.Gray;
build() {
Column({ space: 20 }) {
// 通过外接键盘的上下键可以让焦点在三个按钮间移动，按钮获焦时颜色变化，失焦时变回原背景色
Button('First Button')
.width(260)
.height(70)
.backgroundColor(this.oneButtonColor)
.fontColor(Color.Black)
// 监听第一个组件的获焦事件，获焦后改变颜色
.onFocus(() => {
this.oneButtonColor = Color.Green;
})
// 监听第一个组件的失焦事件，失焦后改变颜色
.onBlur(() => {
this.oneButtonColor = Color.Gray;
})
Button('Second Button')
.width(260)
.height(70)
.backgroundColor(this.twoButtonColor)
.fontColor(Color.Black)
// 监听第二个组件的获焦事件，获焦后改变颜色
.onFocus(() => {
this.twoButtonColor = Color.Green;
})
// 监听第二个组件的失焦事件，失焦后改变颜色
.onBlur(() => {
this.twoButtonColor = Color.Grey;
})
Button('Third Button')
.width(260)
.height(70)
.backgroundColor(this.threeButtonColor)
.fontColor(Color.Black)
// 设置默认焦点
.defaultFocus(true)
// 监听第三个组件的获焦事件，获焦后改变颜色
.onFocus(() => {
this.threeButtonColor = Color.Green;
})
// 监听第三个组件的失焦事件，失焦后改变颜色
.onBlur(() => {
this.threeButtonColor = Color.Gray ;
})
}.width('100%').margin({ top: 20 })
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170315.22806891887642709316952050814806:50001231000000:2800:2D286BCFA3D552DDC24CA8743640157F221E4DC6250E245262E5D12BD9F8D91F.gif)
上述示例包含以下2步：
容器的默认焦点
容器的默认焦点受到获焦优先级的影响。
defaultFocus与FocusPriority的区别
defaultFocus是用于指定页面首次展示时的默认获焦节点，FocusPriority是用于指定某个容器首次获焦时其子节点的获焦优先级。上述两个属性在某些场景同时配置时行为未定义，例如下面的场景，页面首次展示无法同时满足defaultFocus获焦和高优先级组件获焦。
示例
```typescript
@Entry
@Component
struct Index {
build() {
Row() {
Button('Button1')
.defaultFocus(true)
Button('Button2')
.focusScopePriority('RowScope', FocusPriority.PREVIOUS)
}.focusScopeId('RowScope')
}
}
```
页面/容器整体获焦时的焦点链
整体获焦与非整体获焦
-  整体获焦是页面/容器自身作为焦点链的叶节点获焦，获焦后再把焦点链叶节点转移到子孙组件。例如，页面切换、Navigation组件中的路由切换、焦点组走焦、容器组件主动调用requestFocusById等。
-  非整体获焦是某个组件作为焦点链叶节点获焦，导致其祖先节点跟着获焦。例如TextInput组件主动获取焦点、Tab键在非焦点组场景下走焦等。
整体获焦的焦点链形成
1.页面首次获焦：
-  焦点链叶节点为配置了defaultFocus的节点。
-  未配置defaultFocus时，焦点停留在页面的根容器上。
2.页面非首次获焦：由上次获焦的节点获焦。
3.获焦链上存在配置了获焦优先级的组件和容器：
-  容器内存在优先级大于PREVIOUS的组件，由优先级最高的组件获焦。
-  容器内不存在优先级大于PREVIOUS的组件，由上次获焦的节点获焦。例如，窗口失焦后重新获焦。
焦点样式
最终绘制焦点态的组件的zIndex默认会被抬升至INT_MAX，如果该组件已经配置了zIndex，则不做zIndex调整。该组件不再绘制焦点态时，例如组件失焦或是退出走焦态，zIndex恢复为默认层级。
```typescript
focusBox(style: FocusBoxStyle)
```
设置当前组件系统焦点框样式。
```typescript
import { ColorMetrics, LengthMetrics } from '@kit.ArkUI'
@Entry
@Component
struct RequestFocusExample {
build() {
Column({ space: 30 }) {
Button("small black focus box")
.focusBox({
margin: new LengthMetrics(0),
strokeColor: ColorMetrics.rgba(0, 0, 0),
})
Button("large red focus box")
.focusBox({
margin: LengthMetrics.px(20),
strokeColor: ColorMetrics.rgba(255, 0, 0),
strokeWidth: LengthMetrics.px(10)
})
}
.alignItems(HorizontalAlign.Center)
.width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170315.80217328646591108246427189566789:50001231000000:2800:12962A726E299F846D082E89E87182F031D773AFE44076DE48C6BE679E23279A.gif)
上述示例包含以下2步：
主动获焦/失焦
-  使用FocusController中的方法 更推荐使用FocusController中的requestFocus主动获取焦点。优势如下： 需先使用UIContext中的getFocusController()方法获取实例，再通过此实例调用对应方法。 通过组件的id将焦点转移到组件树对应的实体节点，生效时间为当帧生效。 清除焦点，将焦点强制转移到页面根容器节点，焦点链路上其他节点失焦。
```typescript
requestFocus(key: string): void
```
-  使用focusControl中的方法 调用此接口可以主动让焦点转移至参数指定的组件上，焦点转移生效时间为下一个帧信号。
```typescript
requestFocus(value: string): boolean
```
```typescript
// focusTest.ets
@Entry
@Component
struct RequestExample {
@State btColor: string = '#ff2787d9'
@State btColor2: string = '#ff2787d9'
build() {
Column({ space: 20 }) {
Column({ space: 5 }) {
Button('Button')
.width(200)
.height(70)
.fontColor(Color.White)
.focusOnTouch(true)
.backgroundColor(this.btColor)
.onFocus(() => {
this.btColor = '#ffd5d5d5'
})
.onBlur(() => {
this.btColor = '#ff2787d9'
})
.id("testButton")
Button('Button')
.width(200)
.height(70)
.fontColor(Color.White)
.focusOnTouch(true)
.backgroundColor(this.btColor2)
.onFocus(() => {
this.btColor2 = '#ffd5d5d5'
})
.onBlur(() => {
this.btColor2 = '#ff2787d9'
})
.id("testButton2")
Divider()
.vertical(false)
.width("80%")
.backgroundColor('#ff707070')
.height(10)
Button('FocusController.requestFocus')
.width(200).height(70).fontColor(Color.White)
.onClick(() => {
this.getUIContext().getFocusController().requestFocus("testButton")
})
.backgroundColor('#ff2787d9')
Button("focusControl.requestFocus")
.width(200).height(70).fontColor(Color.White)
.onClick(() => {
focusControl.requestFocus("testButton2")
})
.backgroundColor('#ff2787d9')
Button("clearFocus")
.width(200).height(70).fontColor(Color.White)
.onClick(() => {
this.getUIContext().getFocusController().clearFocus()
})
.backgroundColor('#ff2787d9')
}
}
.width('100%')
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170315.69278848478824167283143732064660:50001231000000:2800:EA129B0D74EBAD09A7544254DF9BA126594277C2F6DBB74E9D2D691C8B1B2E7B.gif)
上述示例包含以下3步：
焦点组与获焦优先级
```typescript
focusScopePriority(scopeId: string, priority?: FocusPriority)
```
设置当前组件在指定容器内获焦的优先级。需要配合focusScopeId一起使用。
```typescript
focusScopeId(id: string, isGroup?: boolean)
```
设置当前容器组件的id标识，设置当前容器组件是否为焦点组。焦点组与tabIndex不能混用。
```typescript
// focusTest.ets
@Entry
@Component
struct FocusableExample {
@State inputValue: string = ''
build() {
Scroll() {
Row({ space: 20 }) {
Column({ space: 20 }) {  // 标记为Column1
Column({ space: 5 }) {
Button('Group1')
.width(165)
.height(40)
.fontColor(Color.White)
Row({ space: 5 }) {
Button()
.width(80)
.height(40)
.fontColor(Color.White)
Button()
.width(80)
.height(40)
.fontColor(Color.White)
}
Row({ space: 5 }) {
Button()
.width(80)
.height(40)
.fontColor(Color.White)
Button()
.width(80)
.height(40)
.fontColor(Color.White)
}
}.borderWidth(2).borderColor(Color.Red).borderStyle(BorderStyle.Dashed)
Column({ space: 5 }) {
Button('Group2')
.width(165)
.height(40)
.fontColor(Color.White)
Row({ space: 5 }) {
Button()
.width(80)
.height(40)
.fontColor(Color.White)
Button()
.width(80)
.height(40)
.fontColor(Color.White)
.focusScopePriority('ColumnScope1', FocusPriority.PRIOR)  // Column1首次获焦时获焦
}
Row({ space: 5 }) {
Button()
.width(80)
.height(40)
.fontColor(Color.White)
Button()
.width(80)
.height(40)
.fontColor(Color.White)
}
}.borderWidth(2).borderColor(Color.Green).borderStyle(BorderStyle.Dashed)
}
.focusScopeId('ColumnScope1')
Column({ space: 5 }) {  // 标记为Column2
TextInput({placeholder: 'input', text: this.inputValue})
.onChange((value: string) => {
this.inputValue = value
})
.width(156)
Button('Group3')
.width(165)
.height(40)
.fontColor(Color.White)
Row({ space: 5 }) {
Button()
.width(80)
.height(40)
.fontColor(Color.White)
Button()
.width(80)
.height(40)
.fontColor(Color.White)
}
Button()
.width(165)
.height(40)
.fontColor(Color.White)
.focusScopePriority('ColumnScope2', FocusPriority.PREVIOUS)  // Column2获焦时获焦
Row({ space: 5 }) {
Button()
.width(80)
.height(40)
.fontColor(Color.White)
Button()
.width(80)
.height(40)
.fontColor(Color.White)
}
Button()
.width(165)
.height(40)
.fontColor(Color.White)
Row({ space: 5 }) {
Button()
.width(80)
.height(40)
.fontColor(Color.White)
Button()
.width(80)
.height(40)
.fontColor(Color.White)
}
}.borderWidth(2).borderColor(Color.Orange).borderStyle(BorderStyle.Dashed)
.focusScopeId('ColumnScope2', true)  // Column2为焦点组
}.alignItems(VerticalAlign.Top)
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170315.65412878571844310376601934355723:50001231000000:2800:FC590A9B6EAC607EA026AC39B9A58C096D4C8A3F95979F5E7D74A40A9A040CAC.gif)
上述示例包含以下2步：
焦点与按键事件
当组件获焦且存在点击事件（onClick）或单指单击事件（TapGesture）时，回车和空格会触发对应的事件回调。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170315.02661124953059629081384212511531:50001231000000:2800:90A729220B16446355FBE861DB0CA531AC6BE2109E43E634F51AA2BC9BD52642.gif)
组件获焦能力说明
表1基础组件获焦能力
| 基础组件 | 是否有获焦能力 | focusable默认值 |
| --- | --- | --- |
| AlphabetIndexer | 是 | true |
| Blank | 否 | false |
| Button | 是 | true |
| CalendarPicker | 是 | true |
| Checkbox | 是 | true |
| CheckboxGroup | 是 | true |
| ContainerSpan | 否 | false |
| DataPanel | 是 | false |
| DatePicker | 是 | true |
| Divider | 是 | false |
| Gauge | 是 | false |
| Image | 是 | false |
| ImageAnimator | 否 | false |
| ImageSpan | 否 | false |
| LoadingProgress | 是 | true |
| Marquee | 否 | false |
| Menu | 是 | true |
| MenuItem | 是 | true |
| MenuItemGroup | 否 | false |
| Navigation | 是 | true |
| NavRouter | 否 | false |
| NavDestination | 是 | true |
| PatternLock | 是 | true |
| Progress | 是 | true |
| QRCode | 是 | true |
| Radio | 是 | true |
| Rating | 是 | true |
| RichEditor | 是 | true |
| RichText | 否 | false |
| ScrollBar | 否 | false |
| Search | 是 | true |
| Select | 是 | true |
| Slider | 是 | true |
| Span | 否 | false |
| Stepper | 是 | true |
| StepperItem | 是 | true |
| SymbolSpan | 否 | false |
| SymbolGlyph | 否 | false |
| Text | 是 | false |
| TextArea | 否 | false |
| TextClock | 否 | false |
| TextInput | 是 | true |
| TextPicker | 是 | true |
| TextTimer | 否 | false |
| TimePicker | 否 | false |
| Toggle | 是 | true |
| XComponent | 是 | false |
表2容器组件获焦能力
| 容器组件 | 是否可获焦 | focusable默认值 |
| --- | --- | --- |
| Badge | 否 | false |
| Column | 是 | true |
| ColumnSplit | 是 | true |
| Counter | 是 | false |
| EmbeddedComponent | 否 | false |
| Flex | 是 | true |
| FlowItem | 是 | true |
| FolderStack | 是 | true |
| FormLink | 否 | false |
| GridCol | 是 | true |
| GridRow | 是 | true |
| Grid | 是 | true |
| GridItem | 是 | true |
| Hyperlink | 是 | true |
| List | 是 | true |
| ListItem | 是 | true |
| ListItemGroup | 是 | true |
| Navigator | 是 | true |
| Refresh | 是 | true |
| RelativeContainer | 否 | false |
| Row | 是 | true |
| RowSplit | 是 | true |
| Scroll | 是 | true |
| SideBarContainer | 是 | true |
| Stack | 是 | true |
| Swiper | 是 | true |
| Tabs | 是 | true |
| TabContent | 是 | true |
| WaterFlow | 否 | false |
| WithTheme | 是 | true |
表3媒体组件获焦能力
| 媒体组件 | 是否可获焦 | focusable默认值 |
| --- | --- | --- |
| Video | 是 | true |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-common-events-drag-event-V14
爬取时间: 2025-04-27 23:36:16
来源: Huawei Developer
拖拽事件提供了一种通过鼠标或手势触屏传递数据的机制，即从一个组件位置拖出（drag）数据并将其拖入（drop）到另一个组件位置，以触发响应。在这一过程中，拖出方提供数据，而拖入方负责接收和处理数据。这一操作使用户能够便捷地移动、复制或删除指定内容。
基本概念
拖拽流程
拖拽流程包含手势拖拽流程和鼠标拖拽流程，可帮助开发者理解回调事件触发的时机。
​手势拖拽流程
对于手势长按触发拖拽的场景，ArkUI在发起拖拽前会校验当前组件是否具备拖拽功能。对于默认可拖出的组件（Search、TextInput、TextArea、RichEditor、Text、Image、Hyperlink）需要判断是否设置了draggable，需检查是否已设置draggable属性为true（若系统使能分层参数，draggable属性默认为true）。其他组件则需额外确认是否已设置onDragStart回调函数。在满足上述条件后，长按时间达到或超过500ms即可触发拖拽，而长按800ms时，系统开始执行预览图的浮起动效。若与Menu功能结合使用，并通过isShow控制其显示与隐藏，建议避免在用户操作800ms后才控制菜单显示，此举可能引发非预期的行为。
手势拖拽（手指/手写笔）触发拖拽流程：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170316.66555626945514217415770046415238:50001231000000:2800:E262191DFB1DF75FBDC3B5B950843B1B9A679BB9C52C19FDDBFA16DB1FDC64AF.png)
​鼠标拖拽流程
鼠标拖拽操作遵循即拖即走的模式，当鼠标左键在可拖拽的组件上按下并移动超过1vp时，即可触发拖拽功能。
当前不仅支持应用内部的拖拽，还支持跨应用的拖拽操作。为了帮助开发者更好地感知拖拽状态并调整系统默认的拖拽行为，ArkUI提供了多个回调事件，具体详情如下：
| 回调事件 | 说明 |
| --- | --- |
| onDragStart | 拖出的组件产生拖出动作时，该回调触发。 该回调可以感知拖拽行为的发起，开发者可以在onDragStart方法中设置拖拽过程中传递的数据，并自定义拖拽的背板图像。建议开发者采用pixelmap的方式来返回背板图像，避免使用customBuilder，因为后者可能会带来额外的性能开销。 |
| onDragEnter | 当拖拽操作的拖拽点进入组件的范围时，如果该组件监听了onDrop事件，此回调将会被触发。 |
| onDragMove | 当拖拽点在组件范围内移动时，如果该组件监听了onDrop事件，此回调将会被触发。 在这一过程中，可以通过调用DragEvent中的setResult方法来影响系统在部分场景下的外观表现 1. 设置DragResult.DROP_ENABLED。 2. 设置DragResult.DROP_DISABLED。 |
| onDragLeave | 当拖拽点移出组件范围时，如果该组件监听了onDrop事件，此回调将会被触发。 在以下两种情况下，系统默认不会触发onDragLeave事件： 1. 父组件移动到子组件。 2. 目标组件与当前组件布局有重叠。 API version 12开始可通过UIContext中的setDragEventStrictReportingEnabled方法严格触发onDragLeave事件。 |
| onDrop | 当用户在组件范围内释放拖拽操作时，此回调会被触发。开发者需在此回调中通过DragEvent的setResult方法来设置拖拽结果，否则在拖出方组件的onDragEnd方法中，通过getResult方法获取的将只是默认的处理结果DragResult.DRAG_FAILED。 此回调是开发者干预系统默认拖入处理行为的关键点，系统会优先执行开发者定义的onDrop回调。通过在onDrop回调中调用setResult方法，开发者可以告知系统如何处理被拖拽的数据。 1. 设置 DragResult.DRAG_SUCCESSFUL，数据完全由开发者自己处理，系统不进行处理。 2. 设置DragResult.DRAG_FAILED，数据不再由系统继续处理。 3. 设置DragResult.DRAG_CANCELED，系统也不需要进行数据处理。 4. 设置DragResult.DROP_ENABLED或DragResult.DROP_DISABLED会被忽略，等同于设置DragResult.DRAG_FAILED。 |
| onDragEnd | 当用户释放拖拽时，拖拽活动终止，发起拖出动作的组件将触发该回调函数。 |
| onPreDrag | 当触发拖拽事件的不同阶段时，绑定此事件的组件会触发该回调函数。 开发者可利用此方法，在拖拽开始前的不同阶段，根据PreDragStatus枚举准备相应数据。 1. ACTION_DETECTING_STATUS：拖拽手势启动阶段。按下50ms时触发。 2. READY_TO_TRIGGER_DRAG_ACTION：拖拽准备完成，可发起拖拽阶段。按下500ms时触发。 3. PREVIEW_LIFT_STARTED：拖拽浮起动效发起阶段。按下800ms时触发。 4. PREVIEW_LIFT_FINISHED：拖拽浮起动效结束阶段。浮起动效完全结束时触发。 5. PREVIEW_LANDING_STARTED：拖拽落回动效发起阶段。落回动效发起时触发。 6. PREVIEW_LANDING_FINISHED：拖拽落回动效结束阶段。落回动效结束时触发。 7. ACTION_CANCELED_BEFORE_DRAG：拖拽浮起落位动效中断。已满足READY_TO_TRIGGER_DRAG_ACTION状态后，未达到动效阶段，手指抬起时触发。 |
拖出的组件产生拖出动作时，该回调触发。
该回调可以感知拖拽行为的发起，开发者可以在onDragStart方法中设置拖拽过程中传递的数据，并自定义拖拽的背板图像。建议开发者采用pixelmap的方式来返回背板图像，避免使用customBuilder，因为后者可能会带来额外的性能开销。
当拖拽点在组件范围内移动时，如果该组件监听了onDrop事件，此回调将会被触发。
在这一过程中，可以通过调用DragEvent中的setResult方法来影响系统在部分场景下的外观表现
1. 设置DragResult.DROP_ENABLED。
2. 设置DragResult.DROP_DISABLED。
当拖拽点移出组件范围时，如果该组件监听了onDrop事件，此回调将会被触发。
在以下两种情况下，系统默认不会触发onDragLeave事件：
1. 父组件移动到子组件。
2. 目标组件与当前组件布局有重叠。
API version 12开始可通过UIContext中的setDragEventStrictReportingEnabled方法严格触发onDragLeave事件。
当用户在组件范围内释放拖拽操作时，此回调会被触发。开发者需在此回调中通过DragEvent的setResult方法来设置拖拽结果，否则在拖出方组件的onDragEnd方法中，通过getResult方法获取的将只是默认的处理结果DragResult.DRAG_FAILED。
此回调是开发者干预系统默认拖入处理行为的关键点，系统会优先执行开发者定义的onDrop回调。通过在onDrop回调中调用setResult方法，开发者可以告知系统如何处理被拖拽的数据。
1. 设置 DragResult.DRAG_SUCCESSFUL，数据完全由开发者自己处理，系统不进行处理。
2. 设置DragResult.DRAG_FAILED，数据不再由系统继续处理。
3. 设置DragResult.DRAG_CANCELED，系统也不需要进行数据处理。
4. 设置DragResult.DROP_ENABLED或DragResult.DROP_DISABLED会被忽略，等同于设置DragResult.DRAG_FAILED。
当触发拖拽事件的不同阶段时，绑定此事件的组件会触发该回调函数。
开发者可利用此方法，在拖拽开始前的不同阶段，根据PreDragStatus枚举准备相应数据。
1. ACTION_DETECTING_STATUS：拖拽手势启动阶段。按下50ms时触发。
2. READY_TO_TRIGGER_DRAG_ACTION：拖拽准备完成，可发起拖拽阶段。按下500ms时触发。
3. PREVIEW_LIFT_STARTED：拖拽浮起动效发起阶段。按下800ms时触发。
4. PREVIEW_LIFT_FINISHED：拖拽浮起动效结束阶段。浮起动效完全结束时触发。
5. PREVIEW_LANDING_STARTED：拖拽落回动效发起阶段。落回动效发起时触发。
6. PREVIEW_LANDING_FINISHED：拖拽落回动效结束阶段。落回动效结束时触发。
7. ACTION_CANCELED_BEFORE_DRAG：拖拽浮起落位动效中断。已满足READY_TO_TRIGGER_DRAG_ACTION状态后，未达到动效阶段，手指抬起时触发。
DragEvent支持的get方法可用于获取拖拽行为的详细信息，下表展示了在相应的拖拽回调中，这些get方法是否能够返回有效数据。
| 回调事件 | onDragStart | onDragEnter | onDragMove | onDragLeave | onDrop | onDragEnd |
| --- | --- | --- | --- | --- | --- | --- |
| getData | — | — | — | — | 支持 | — |
| getSummary | — | 支持 | 支持 | 支持 | 支持 | — |
| getResult | — | — | — | — | — | 支持 |
| getPreviewRect | — | — | — | — | 支持 | — |
| getVelocity/X/Y | — | 支持 | 支持 | 支持 | 支持 | — |
| getWindowX/Y | 支持 | 支持 | 支持 | 支持 | 支持 | — |
| getDisplayX/Y | 支持 | 支持 | 支持 | 支持 | 支持 | — |
| getX/Y | 支持 | 支持 | 支持 | 支持 | 支持 | — |
| behavior | — | — | — | — | — | 支持 |
DragEvent支持相关set方法向系统传递信息，这些信息部分会影响系统对UI或数据的处理方式。下表列出了set方法应该在回调的哪个阶段执行才会被系统接受并处理。
| 回调事件 | onDragStart | onDragEnter | onDragMove | onDragLeave | onDrop |
| --- | --- | --- | --- | --- | --- |
| useCustomDropAnimation | — | — | — | — | 支持 |
| setData | 支持 | — | — | — | — |
| setResult | 支持，可通过set failed或cancel来阻止拖拽发起 | 支持，不作为最终结果传递给onDragEnd | 支持，不作为最终结果传递给onDragEnd | 支持，不作为最终结果传递给onDragEnd | 支持，作为最终结果传递给onDragEnd |
| behavior | — | 支持 | 支持 | 支持 | 支持 |
拖拽背板图
在拖拽移动过程中显示的背板图并非组件本身，而是表示用户拖动的数据，开发者可将其设定为任意可显示的图像。具体而言，onDragStart回调中返回的customBuilder或pixelmap可以用于设置拖拽移动过程中的背板图，而浮起图则默认采用组件本身的截图。dragpreview属性中设定的customBuilder或pixelmap可以用于配置浮起和拖拽过程的背板图。若开发者未配置背板图，系统将自动采用组件本身的截图作为拖拽和浮起时的背板图。
拖拽背板图当前支持设置透明度、圆角、阴影和模糊，具体用法见拖拽控制。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170316.65301383708766197169653893024403:50001231000000:2800:A52D8C49946980C1E0A3475820409A63A7241B3A0E9743DE4E93E2F009FA0467.png)
约束限制：
通用拖拽适配
如下以Image组件为例，介绍组件拖拽开发的基本步骤，以及开发中需要注意的事项。
1.  组件使能拖拽。 设置draggable属性为true，并配置onDragStart回调函数。在回调函数中，可通过UDMF（用户数据管理框架）设置拖拽的数据，并返回自定义的拖拽背景图像。 手势场景触发的拖拽功能依赖于底层绑定的长按手势。如果开发者在可拖拽组件上也绑定了长按手势，这将与底层的长按手势产生冲突，进而导致拖拽操作失败。为解决此类问题，可以采用并行手势的方案，具体如下。
```typescript
import { unifiedDataChannel, uniformTypeDescriptor } from '@kit.ArkData';
Image($r('app.media.app_icon'))
.width(100)
.height(100)
.draggable(true)
.onDragStart((event) => {
let data: unifiedDataChannel.Image = new unifiedDataChannel.Image();
data.imageUri = 'common/pic/img.png';
let unifiedData = new unifiedDataChannel.UnifiedData(data);
event.setData(unifiedData);
let dragItemInfo: DragItemInfo = {
pixelMap: this.pixmap,
extraInfo: "this is extraInfo",
};
// onDragStart回调函数中返回自定义拖拽背板图
return dragItemInfo;
})
```
2.  自定义拖拽背板图。 可以通过在长按50ms时触发的回调中设置onPreDrag回调函数，来提前准备自定义拖拽背板图的pixmap。 pixmap的生成可以调用componentSnapshot.createFromBuilder函数来实现。
```typescript
.onPreDrag((status: PreDragStatus) => {
if (preDragStatus == PreDragStatus.ACTION_DETECTING_STATUS) {
this.getComponentSnapshot();
}
})
```
3.  若开发者需确保触发onDragLeave事件，应通过调用setDragEventStrictReportingEnabled方法进行设置。
```typescript
import { UIAbility } from '@kit.AbilityKit';
import { window, UIContext } from '@kit.ArkUI';
export default class EntryAbility extends UIAbility {
onWindowStageCreate(windowStage: window.WindowStage): void {
windowStage.loadContent('pages/Index', (err, data) => {
if (err.code) {
return;
}
windowStage.getMainWindow((err, data) => {
if (err.code) {
return;
}
let windowClass: window.Window = data;
let uiContext: UIContext = windowClass.getUIContext();
uiContext.getDragController().setDragEventStrictReportingEnabled(true);
});
});
}
}
```
4.  拖拽过程显示角标样式。 通过设置allowDrop来定义接收的数据类型，这将影响角标显示。当拖拽的数据符合定义的允许落入的数据类型时，显示“COPY”角标。当拖拽的数据类型不在允许范围内时，显示“FORBIDDEN”角标。若未设置allowDrop，则显示“MOVE”角标。以下代码示例表示仅接收UnifiedData中定义的HYPERLINK和PLAIN_TEXT类型数据，其他类型数据将被禁止落入。 在实现onDrop回调的情况下，还可以通过在onDragMove中设置DragResult为DROP_ENABLED，并将DragBehavior设置为COPY或MOVE，以此来控制角标显示。如下代码将移动时的角标强制设置为“MOVE”。
```typescript
.allowDrop([uniformTypeDescriptor.UniformDataType.HYPERLINK, uniformTypeDescriptor.UniformDataType.PLAIN_TEXT])
```
5.  拖拽数据的接收。 需要设置onDrop回调函数，并在回调函数中处理拖拽数据，显示设置拖拽结果。 数据的传递是通过UDMF实现的，在数据较大时可能存在时延，因此在首次获取数据失败时建议加1500ms的延迟重试机制。
```typescript
.onDrop((dragEvent?: DragEvent) => {
// 获取拖拽数据
this.getDataFromUdmf((dragEvent as DragEvent), (event: DragEvent) => {
let records: Array<unifiedDataChannel.UnifiedRecord> = event.getData().getRecords();
let rect: Rectangle = event.getPreviewRect();
this.imageWidth = Number(rect.width);
this.imageHeight = Number(rect.height);
this.targetImage = (records[0] as unifiedDataChannel.Image).imageUri;
this.imgState = Visibility.None；
// 显式设置result为successful，则将该值传递给拖出方的onDragEnd
event.setResult(DragResult.DRAG_SUCCESSFUL);
})
```
6.  拖拽发起方可以通过设置onDragEnd回调感知拖拽结果。
```typescript
import { promptAction } from '@kit.ArkUI';
.onDragEnd((event) => {
// onDragEnd里取到的result值在接收方onDrop设置
if (event.getResult() === DragResult.DRAG_SUCCESSFUL) {
promptAction.showToast({ duration: 100, message: 'Drag Success' });
} else if (event.getResult() === DragResult.DRAG_FAILED) {
promptAction.showToast({ duration: 100, message: 'Drag failed' });
}
})
```
完整示例：
```typescript
import { unifiedDataChannel, uniformTypeDescriptor } from '@kit.ArkData';
import { promptAction } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
import { image } from '@kit.ImageKit';
@Entry
@Component
struct Index {
@State targetImage: string = '';
@State imageWidth: number = 100;
@State imageHeight: number = 100;
@State imgState: Visibility = Visibility.Visible;
@State pixmap: image.PixelMap|undefined = undefined
@Builder
pixelMapBuilder() {
Column() {
Image($r('app.media.startIcon'))
.width(120)
.height(120)
.backgroundColor(Color.Yellow)
}
}
getDataFromUdmfRetry(event: DragEvent, callback: (data: DragEvent) => void) {
try {
let data: UnifiedData = event.getData();
if (!data) {
return false;
}
let records: Array<unifiedDataChannel.UnifiedRecord> = data.getRecords();
if (!records || records.length <= 0) {
return false;
}
callback(event);
return true;
} catch (e) {
console.log("getData failed, code: " + (e as BusinessError).code + ", message: " + (e as BusinessError).message);
return false;
}
}
// 获取UDMF数据，首次获取失败后添加1500ms延迟重试机制
getDataFromUdmf(event: DragEvent, callback: (data: DragEvent) => void) {
if (this.getDataFromUdmfRetry(event, callback)) {
return;
}
setTimeout(() => {
this.getDataFromUdmfRetry(event, callback);
}, 1500);
}
// 调用componentSnapshot中的createFromBuilder接口截取自定义builder的截图
private getComponentSnapshot(): void {
this.getUIContext().getComponentSnapshot().createFromBuilder(()=>{this.pixelMapBuilder()},
(error: Error, pixmap: image.PixelMap) => {
if(error){
console.log("error: " + JSON.stringify(error))
return;
}
this.pixmap = pixmap;
})
}
// 长按50ms时提前准备自定义截图的pixmap
private PreDragChange(preDragStatus: PreDragStatus): void {
if (preDragStatus == PreDragStatus.ACTION_DETECTING_STATUS) {
this.getComponentSnapshot();
}
}
build() {
Row() {
Column() {
Text('start Drag')
.fontSize(18)
.width('100%')
.height(40)
.margin(10)
.backgroundColor('#008888')
Row() {
Image($r('app.media.app_icon'))
.width(100)
.height(100)
.draggable(true)
.margin({ left: 15 })
.visibility(this.imgState)
// 绑定平行手势，可同时触发应用自定义长按手势
.parallelGesture(LongPressGesture().onAction(() => {
promptAction.showToast({ duration: 100, message: 'Long press gesture trigger' });
}))
.onDragStart((event) => {
let data: unifiedDataChannel.Image = new unifiedDataChannel.Image();
data.imageUri = 'common/pic/img.png';
let unifiedData = new unifiedDataChannel.UnifiedData(data);
event.setData(unifiedData);
let dragItemInfo: DragItemInfo = {
pixelMap: this.pixmap,
extraInfo: "this is extraInfo",
};
return dragItemInfo;
})
// 提前准备拖拽自定义背板图
.onPreDrag((status: PreDragStatus) => {
this.PreDragChange(status);
})
.onDragEnd((event) => {
// onDragEnd里取到的result值在接收方onDrop设置
if (event.getResult() === DragResult.DRAG_SUCCESSFUL) {
promptAction.showToast({ duration: 100, message: 'Drag Success' });
} else if (event.getResult() === DragResult.DRAG_FAILED) {
promptAction.showToast({ duration: 100, message: 'Drag failed' });
}
})
}
Text('Drag Target Area')
.fontSize(20)
.width('100%')
.height(40)
.margin(10)
.backgroundColor('#008888')
Row() {
Image(this.targetImage)
.width(this.imageWidth)
.height(this.imageHeight)
.draggable(true)
.margin({ left: 15 })
.border({ color: Color.Black, width: 1 })
// 控制角标显示类型为MOVE，即不显示角标
.onDragMove((event) => {
event.setResult(DragResult.DROP_ENABLED)
event.dragBehavior = DragBehavior.MOVE
})
.allowDrop([uniformTypeDescriptor.UniformDataType.IMAGE])
.onDrop((dragEvent?: DragEvent) => {
// 获取拖拽数据
this.getDataFromUdmf((dragEvent as DragEvent), (event: DragEvent) => {
let records: Array<unifiedDataChannel.UnifiedRecord> = event.getData().getRecords();
let rect: Rectangle = event.getPreviewRect();
this.imageWidth = Number(rect.width);
this.imageHeight = Number(rect.height);
this.targetImage = (records[0] as unifiedDataChannel.Image).imageUri;
this.imgState = Visibility.None;
// 显式设置result为successful，则将该值传递给拖出方的onDragEnd
event.setResult(DragResult.DRAG_SUCCESSFUL);
})
})
}
}
.width('100%')
.height('100%')
}
.height('100%')
}
}
```
多选拖拽适配
从API version 12开始，Grid组件和List组件中的GridItem和ListItem组件支持多选与拖拽功能。目前，仅支持onDragStart的触发方式。
以下以Grid为例，详细介绍实现多选拖拽的基本步骤，以及在开发过程中需要注意的事项。
1.  组件多选拖拽使能。 创建GridItem子组件并绑定onDragStart回调函数。同时设置GridItem组件的状态为可选中。 多选拖拽功能默认处于关闭状态。若要启用此功能，需在dragPreviewOptions接口的DragInteractionOptions参数中，将isMultiSelectionEnabled设置为true，以表明当前组件支持多选。此外，DragInteractionOptions还包含defaultAnimationBeforeLifting参数，用于控制组件浮起前的默认效果。将该参数设置为true，组件在浮起前将展示一个默认的缩小动画效果。 为了确保选中状态，应将GridItem子组件的selected属性设置为true。例如，可以通过调用onClick来设置特定组件为选中状态。
```typescript
Grid() {
ForEach(this.numbers, (idx: number) => {
GridItem() {
Column()
.backgroundColor(this.colors[idx % 9])
.width(50)
.height(50)
.opacity(1.0)
.id('grid'+idx)
}
.onDragStart(()=>{})
.selectable(true)
}, (idx: string) => idx)
}
```
2.  优化多选拖拽性能。 在多选拖拽操作中，当多选触发聚拢动画效果时，系统会截取当前屏幕内显示的选中组件图像。如果选中组件数量过多，可能会造成较高的性能消耗。为了优化性能，多选拖拽功能支持从dragPreview中获取截图，用以实现聚拢动画效果，从而有效节省系统资源。 截图的获取可以在选中组件时通过调用componentSnapshot中的get方法获取。以下示例通过获取组件对应id的方法进行截图。
```typescript
.dragPreview({
pixelMap:this.pixmap
})
```
3.  多选显示效果。 通过stateStyles可以设置选中态和非选中态的显示效果，方便区分。
```typescript
@Styles
normalStyles(): void{
.opacity(1.0)
}
@Styles
selectStyles(): void{
.opacity(0.4)
}
.stateStyles({
normal : this.normalStyles,
selected: this.selectStyles
})
```
4.  适配数量角标。 多选拖拽的数量角标当前需要应用使用dragPreviewOptions中的numberBadge参数设置，开发者需要根据当前选中的节点数量来设置数量角标。
```typescript
@State numberBadge: number = 0;
.onClick(()=>{
this.isSelectedGrid[idx] = !this.isSelectedGrid[idx]
if (this.isSelectedGrid[idx]) {
this.numberBadge++;
} else {
this.numberBadge--;
}
})
// 多选场景右上角数量角标需要应用设置numberBadge参数
.dragPreviewOptions({numberBadge: this.numberBadge})
```
完整示例：
```typescript
import { image } from '@kit.ImageKit';
@Entry
@Component
struct GridEts {
@State pixmap: image.PixelMap|undefined = undefined
@State numbers: number[] = []
@State isSelectedGrid: boolean[] = []
@State previewData: DragItemInfo[] = []
@State colors: Color[] = [Color.Red, Color.Blue, Color.Brown, Color.Gray, Color.Green, Color.Grey, Color.Orange,Color.Pink ,Color.Yellow]
@State numberBadge: number = 0;
@Styles
normalStyles(): void{
.opacity(1.0)
}
@Styles
selectStyles(): void{
.opacity(0.4)
}
onPageShow(): void {
let i: number = 0
for(i=0;i<100;i++){
this.numbers.push(i)
this.isSelectedGrid.push(false)
this.previewData.push({})
}
}
@Builder
RandomBuilder(idx: number) {
Column()
.backgroundColor(this.colors[idx % 9])
.width(50)
.height(50)
.opacity(1.0)
}
build() {
Column({ space: 5 }) {
Grid() {
ForEach(this.numbers, (idx: number) => {
GridItem() {
Column()
.backgroundColor(this.colors[idx % 9])
.width(50)
.height(50)
.opacity(1.0)
.id('grid'+idx)
}
.dragPreview(this.previewData[idx])
.selectable(true)
.selected(this.isSelectedGrid[idx])
// 设置多选显示效果
.stateStyles({
normal : this.normalStyles,
selected: this.selectStyles
})
.onClick(()=>{
this.isSelectedGrid[idx] = !this.isSelectedGrid[idx]
if (this.isSelectedGrid[idx]) {
this.numberBadge++;
let gridItemName = 'grid' + idx
// 选中状态下提前调用componentSnapshot中的get接口获取pixmap
this.getUIContext().getComponentSnapshot().get(gridItemName, (error: Error, pixmap: image.PixelMap)=>{
this.pixmap = pixmap
this.previewData[idx] = {
pixelMap:this.pixmap
}
})
} else {
this.numberBadge--;
}
})
// 使能多选拖拽，右上角数量角标需要应用设置numberBadge参数
.dragPreviewOptions({numberBadge: this.numberBadge},{isMultiSelectionEnabled:true,defaultAnimationBeforeLifting:true})
.onDragStart(()=>{
})
}, (idx: string) => idx)
}
.columnsTemplate('1fr 1fr 1fr 1fr 1fr')
.columnsGap(5)
.rowsGap(10)
.backgroundColor(0xFAEEE0)
}.width('100%').margin({ top: 5 })
}
}
```
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-gesture-events-V14
爬取时间: 2025-04-27 23:36:30
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-gesture-events-binding-V14
爬取时间: 2025-04-27 23:37:23
来源: Huawei Developer
通过给各个组件绑定不同的手势事件，并设计事件的响应方式，当手势识别成功时，ArkUI框架将通过事件回调通知组件手势识别的结果。
gesture（常规手势绑定方法）
```typescript
.gesture(gesture: GestureType, mask?: GestureMask)
```
gesture为通用的一种手势绑定方法，可以将手势绑定到对应的组件上。
例如，可以将点击手势TapGesture通过gesture手势将方法绑定到Text组件上。
```typescript
// xxx.ets
@Entry
@Component
struct Index {
build() {
Column() {
Text('Gesture').fontSize(28)
// 采用gesture手势绑定方法绑定TapGesture
.gesture(
TapGesture()
.onAction(() => {
console.info('TapGesture is onAction');
}))
}
.height(200)
.width(250)
}
}
```
priorityGesture（带优先级的手势绑定方法）
```typescript
.priorityGesture(gesture: GestureType, mask?: GestureMask)
```
priorityGesture是带优先级的手势绑定方法，可以在组件上绑定优先识别的手势。
在默认情况下，当父组件和子组件使用gesture绑定同类型的手势时，子组件优先识别通过gesture绑定的手势。当父组件使用priorityGesture绑定与子组件同类型的手势时，父组件优先识别通过priorityGesture绑定的手势。
长按手势时，设置触发长按的最短时间小的组件会优先响应，会忽略priorityGesture设置。
例如，当父组件Column和子组件Text同时绑定TapGesture手势时，父组件以带优先级手势priorityGesture的形式进行绑定时，优先响应父组件绑定的TapGesture。
```typescript
// xxx.ets
@Entry
@Component
struct Index {
build() {
Column() {
Text('Gesture').fontSize(28)
.gesture(
TapGesture()
.onAction(() => {
console.info('Text TapGesture is onAction');
}))
}
.height(200)
.width(250)
// 设置为priorityGesture时，点击文本区域会忽略Text组件的TapGesture手势事件，优先响应父组件Column的TapGesture手势事件
.priorityGesture(
TapGesture()
.onAction(() => {
console.info('Column TapGesture is onAction');
}), GestureMask.IgnoreInternal)
}
}
```
parallelGesture（并行手势绑定方法）
```typescript
.parallelGesture(gesture: GestureType, mask?: GestureMask)
```
parallelGesture是并行的手势绑定方法，可以在父子组件上绑定可以同时响应的相同手势。
在默认情况下，手势事件为非冒泡事件，当父子组件绑定相同的手势时，父子组件绑定的手势事件会发生竞争，最多只有一个组件的手势事件能够获得响应。而当父组件绑定了并行手势parallelGesture时，父子组件相同的手势事件都可以触发，实现类似冒泡效果。
```typescript
// xxx.ets
@Entry
@Component
struct Index {
build() {
Column() {
Text('Gesture').fontSize(28)
.gesture(
TapGesture()
.onAction(() => {
console.info('Text TapGesture is onAction');
}))
}
.height(200)
.width(250)
// 设置为parallelGesture时，点击文本区域会同时响应父组件Column和子组件Text的TapGesture手势事件
.parallelGesture(
TapGesture()
.onAction(() => {
console.info('Column TapGesture is onAction');
}), GestureMask.Normal)
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-gesture-events-single-gesture-V14
爬取时间: 2025-04-27 23:37:37
来源: Huawei Developer
点击手势（TapGesture）
```typescript
TapGesture(value?:{count?:number, fingers?:number})
```
点击手势支持单次点击和多次点击，拥有两个可选参数：
-  count：声明该点击手势识别的连续点击次数。默认值为1，若设置小于1的非法值会被转化为默认值。如果配置多次点击，上一次抬起和下一次按下的超时时间为300毫秒。
-  fingers：用于声明触发点击的手指数量，最小值为1，最大值为10，默认值为1。当配置多指时，若第一根手指按下300毫秒内未有足够的手指数按下则手势识别失败。 以在Text组件上绑定双击手势（count值为2的点击手势）为例：
```typescript
// xxx.ets
@Entry
@Component
struct Index {
@State value: string = "";
build() {
Column() {
Text('Click twice').fontSize(28)
.gesture(
// 绑定count为2的TapGesture
TapGesture({ count: 2 })
.onAction((event: GestureEvent|undefined) => {
if(event){
this.value = JSON.stringify(event.fingerList[0]);
}
}))
Text(this.value)
}
.height(200)
.width(250)
.padding(20)
.border({ width: 3 })
.margin(30)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170316.52486967588298908982008020433985:50001231000000:2800:8168A3AB29200A3AB96642E89F4E48C44D5D0B408B209808440CBA05B21A6E8D.gif)
长按手势（LongPressGesture）
```typescript
LongPressGesture(value?:{fingers?:number, repeat?:boolean, duration?:number})
```
长按手势用于触发长按手势事件，拥有三个可选参数：
-  fingers：用于声明触发长按手势所需要的最少手指数量，最小值为1，最大值为10，默认值为1。
-  repeat：用于声明是否连续触发事件回调，默认值为false。
-  duration：用于声明触发长按所需的最短时间，单位为毫秒，默认值为500。
以在Text组件上绑定可以重复触发的长按手势为例：
```typescript
// xxx.ets
@Entry
@Component
struct Index {
@State count: number = 0;
build() {
Column() {
Text('LongPress OnAction:' + this.count).fontSize(28)
.gesture(
// 绑定可以重复触发的LongPressGesture
LongPressGesture({ repeat: true })
.onAction((event: GestureEvent|undefined) => {
if(event){
if (event.repeat) {
this.count++;
}
}
})
.onActionEnd(() => {
this.count = 0;
})
)
}
.height(200)
.width(250)
.padding(20)
.border({ width: 3 })
.margin(30)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170316.30856109435384350208556383591657:50001231000000:2800:FB08F453EFB0D32D9C390AAB7B07D170A20E51D594F7F155DD23EA7BE346C6D7.gif)
拖动手势（PanGesture）
```typescript
PanGesture(value?:{ fingers?:number, direction?:PanDirection, distance?:number})
```
拖动手势用于触发拖动手势事件，滑动达到最小滑动距离（默认值为5vp）时拖动手势识别成功，拥有三个可选参数：
-  fingers：用于声明触发拖动手势所需要的最少手指数量，最小值为1，最大值为10，默认值为1。
-  direction：用于声明触发拖动的手势方向，此枚举值支持逻辑与（&）和逻辑或（|）运算。默认值为Pandirection.All。
-  distance：用于声明触发拖动的最小拖动识别距离，单位为vp，默认值为5。
以在Text组件上绑定拖动手势为例，可以通过在拖动手势的回调函数中修改组件的布局位置信息来实现组件的拖动：
```typescript
// xxx.ets
@Entry
@Component
struct Index {
@State offsetX: number = 0;
@State offsetY: number = 0;
@State positionX: number = 0;
@State positionY: number = 0;
build() {
Column() {
Text('PanGesture Offset:\nX: ' + this.offsetX + '\n' + 'Y: ' + this.offsetY)
.fontSize(28)
.height(200)
.width(300)
.padding(20)
.border({ width: 3 })
// 在组件上绑定布局位置信息
.translate({ x: this.offsetX, y: this.offsetY, z: 0 })
.gesture(
// 绑定拖动手势
PanGesture()
.onActionStart((event: GestureEvent|undefined) => {
console.info('Pan start');
})
// 当触发拖动手势时，根据回调函数修改组件的布局位置信息
.onActionUpdate((event: GestureEvent|undefined) => {
if(event){
this.offsetX = this.positionX + event.offsetX;
this.offsetY = this.positionY + event.offsetY;
}
})
.onActionEnd(() => {
this.positionX = this.offsetX;
this.positionY = this.offsetY;
})
)
}
.height(200)
.width(250)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170316.95804744240529721242751527158523:50001231000000:2800:954284C355AEECD0C802E8788343E2B5C0C9325C55C3566022353486444CFCC6.gif)
大部分可滑动组件，如List、Grid、Scroll、Tab等组件是通过PanGesture实现滑动，在组件内部的子组件绑定拖动手势（PanGesture）或者滑动手势（SwipeGesture）会导致手势竞争。
当在子组件绑定PanGesture时，在子组件区域进行滑动仅触发子组件的PanGesture。如果需要父组件响应，需要通过修改手势绑定方法或者子组件向父组件传递消息进行实现，或者通过修改父子组件的PanGesture参数distance使得拖动更灵敏。当子组件绑定SwipeGesture时，由于PanGesture和SwipeGesture触发条件不同，需要修改PanGesture和SwipeGesture的参数以达到所需效果。
不合理的阈值设置会导致滑动不跟手（响应时延慢）的问题。
捏合手势（PinchGesture）
```typescript
PinchGesture(value?:{fingers?:number, distance?:number})
```
捏合手势用于触发捏合手势事件，拥有两个可选参数：
-  fingers：用于声明触发捏合手势所需要的最少手指数量，最小值为2，最大值为5，默认值为2。
-  distance：用于声明触发捏合手势的最小距离，单位为vp，默认值为5。
以在Column组件上绑定三指捏合手势为例，可以通过在捏合手势的函数回调中获取缩放比例，实现对组件的缩小或放大：
```typescript
// xxx.ets
@Entry
@Component
struct Index {
@State scaleValue: number = 1;
@State pinchValue: number = 1;
@State pinchX: number = 0;
@State pinchY: number = 0;
build() {
Column() {
Column() {
Text('PinchGesture scale:\n' + this.scaleValue)
Text('PinchGesture center:\n(' + this.pinchX + ',' + this.pinchY + ')')
}
.height(200)
.width(300)
.border({ width: 3 })
.margin({ top: 100 })
// 在组件上绑定缩放比例，可以通过修改缩放比例来实现组件的缩小或者放大
.scale({ x: this.scaleValue, y: this.scaleValue, z: 1 })
.gesture(
// 在组件上绑定三指触发的捏合手势
PinchGesture({ fingers: 3 })
.onActionStart((event: GestureEvent|undefined) => {
console.info('Pinch start');
})
// 当捏合手势触发时，可以通过回调函数获取缩放比例，从而修改组件的缩放比例
.onActionUpdate((event: GestureEvent|undefined) => {
if(event){
this.scaleValue = this.pinchValue * event.scale;
this.pinchX = event.pinchCenterX;
this.pinchY = event.pinchCenterY;
}
})
.onActionEnd(() => {
this.pinchValue = this.scaleValue;
console.info('Pinch end');
})
)
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170316.16509193681102621963004217888906:50001231000000:2800:2E122ED2E11F893F04547698C2A7E94025F4A4A8CC1ECE879195911B5BD585A3.png)
旋转手势（RotationGesture）
```typescript
RotationGesture(value?:{fingers?:number, angle?:number})
```
旋转手势用于触发旋转手势事件，拥有两个可选参数：
-  fingers：用于声明触发旋转手势所需要的最少手指数量，最小值为2，最大值为5，默认值为2。
-  angle：用于声明触发旋转手势的最小改变度数，单位为deg，默认值为1。
以在Text组件上绑定旋转手势实现组件的旋转为例，可以通过在旋转手势的回调函数中获取旋转角度，从而实现组件的旋转：
```typescript
// xxx.ets
@Entry
@Component
struct Index {
@State angle: number = 0;
@State rotateValue: number = 0;
build() {
Column() {
Text('RotationGesture angle:' + this.angle).fontSize(28)
// 在组件上绑定旋转布局，可以通过修改旋转角度来实现组件的旋转
.rotate({ angle: this.angle })
.gesture(
RotationGesture()
.onActionStart((event: GestureEvent|undefined) => {
console.info('RotationGesture is onActionStart');
})
// 当旋转手势生效时，通过旋转手势的回调函数获取旋转角度，从而修改组件的旋转角度
.onActionUpdate((event: GestureEvent|undefined) => {
if(event){
this.angle = this.rotateValue + event.angle;
}
console.info('RotationGesture is onActionEnd');
})
// 当旋转结束抬手时，固定组件在旋转结束时的角度
.onActionEnd(() => {
this.rotateValue = this.angle;
console.info('RotationGesture is onActionEnd');
})
.onActionCancel(() => {
console.info('RotationGesture is onActionCancel');
})
)
.height(200)
.width(300)
.padding(20)
.border({ width: 3 })
.margin(100)
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170316.40490744701563185465664340360506:50001231000000:2800:0262FC3817892AE919088698125A1AEA739DB518B309F020D7594B2B11AAC2DE.png)
滑动手势（SwipeGesture）
```typescript
SwipeGesture(value?:{fingers?:number, direction?:SwipeDirection, speed?:number})
```
滑动手势用于触发滑动事件，当滑动速度大于100vp/s时可以识别成功，拥有三个可选参数：
-  fingers：用于声明触发滑动手势所需要的最少手指数量，最小值为1，最大值为10，默认值为1。
-  direction：用于声明触发滑动手势的方向，此枚举值支持逻辑与（&）和逻辑或（|）运算。默认值为SwipeDirection.All。
-  speed：用于声明触发滑动的最小滑动识别速度，单位为vp/s，默认值为100。
以在Column组件上绑定滑动手势实现组件的旋转为例：
```typescript
// xxx.ets
@Entry
@Component
struct Index {
@State rotateAngle: number = 0;
@State speed: number = 1;
build() {
Column() {
Column() {
Text("SwipeGesture speed\n" + this.speed)
Text("SwipeGesture angle\n" + this.rotateAngle)
}
.border({ width: 3 })
.width(300)
.height(200)
.margin(100)
// 在Column组件上绑定旋转，通过滑动手势的滑动速度和角度修改旋转的角度
.rotate({ angle: this.rotateAngle })
.gesture(
// 绑定滑动手势且限制仅在竖直方向滑动时触发
SwipeGesture({ direction: SwipeDirection.Vertical })
// 当滑动手势触发时，获取滑动的速度和角度，实现对组件的布局参数的修改
.onAction((event: GestureEvent|undefined) => {
if(event){
this.speed = event.speed;
this.rotateAngle = event.angle;
}
})
)
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170316.84921149939572125723886047105150:50001231000000:2800:8452EFBDFFE4FBC835A258D94A8947A348721594B3797E26940247C47F88F2B3.gif)
当SwipeGesture和PanGesture同时绑定时，若二者是以默认方式或者互斥方式进行绑定时，会发生竞争。SwipeGesture的触发条件为滑动速度达到100vp/s，PanGesture的触发条件为滑动距离达到5vp，先达到触发条件的手势触发。可以通过修改SwipeGesture和PanGesture的参数以达到不同的效果。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-gesture-events-combined-gestures-V14
爬取时间: 2025-04-27 23:37:51
来源: Huawei Developer
组合手势由多种单一手势组合而成，通过在GestureGroup中使用不同的GestureMode来声明该组合手势的类型，支持顺序识别、并行识别和互斥识别三种类型。
```typescript
GestureGroup(mode:GestureMode, gesture:GestureType[])
```
-  mode：为GestureMode枚举类。用于声明该组合手势的类型。
-  gesture：由多个手势组合而成的数组。用于声明组合成该组合手势的各个手势。
顺序识别
顺序识别组合手势对应的GestureMode为Sequence。顺序识别组合手势将按照手势的注册顺序识别手势，直到所有的手势识别成功。当顺序识别组合手势中有一个手势识别失败时，后续手势识别均失败。顺序识别手势组仅有最后一个手势可以响应onActionEnd。
以一个由长按手势和拖动手势组合而成的连续手势为例：
在一个Column组件上绑定了translate属性，通过修改该属性可以设置组件的位置移动。然后在该组件上绑定LongPressGesture和PanGesture组合而成的Sequence组合手势。当触发LongPressGesture时，更新显示的数字。当长按后进行拖动时，根据拖动手势的回调函数，实现组件的拖动。
```typescript
// xxx.ets
@Entry
@Component
struct Index {
@State offsetX: number = 0;
@State offsetY: number = 0;
@State count: number = 0;
@State positionX: number = 0;
@State positionY: number = 0;
@State borderStyles: BorderStyle = BorderStyle.Solid
build() {
Column() {
Text('sequence gesture\n' + 'LongPress onAction:' + this.count + '\nPanGesture offset:\nX: ' + this.offsetX + '\n' + 'Y: ' + this.offsetY)
.fontSize(28)
}.margin(10)
.borderWidth(1)
// 绑定translate属性可以实现组件的位置移动
.translate({ x: this.offsetX, y: this.offsetY, z: 0 })
.height(250)
.width(300)
//以下组合手势为顺序识别，当长按手势事件未正常触发时不会触发拖动手势事件
.gesture(
// 声明该组合手势的类型为Sequence类型
GestureGroup(GestureMode.Sequence,
// 该组合手势第一个触发的手势为长按手势，且长按手势可多次响应
LongPressGesture({ repeat: true })
// 当长按手势识别成功，增加Text组件上显示的count次数
.onAction((event: GestureEvent|undefined) => {
if(event){
if (event.repeat) {
this.count++;
}
}
console.info('LongPress onAction');
})
.onActionEnd(() => {
console.info('LongPress end');
}),
// 当长按之后进行拖动，PanGesture手势被触发
PanGesture()
.onActionStart(() => {
this.borderStyles = BorderStyle.Dashed;
console.info('pan start');
})
// 当该手势被触发时，根据回调获得拖动的距离，修改该组件的位移距离从而实现组件的移动
.onActionUpdate((event: GestureEvent|undefined) => {
if(event){
this.offsetX = (this.positionX + event.offsetX);
this.offsetY = this.positionY + event.offsetY;
}
console.info('pan update');
})
.onActionEnd(() => {
this.positionX = this.offsetX;
this.positionY = this.offsetY;
this.borderStyles = BorderStyle.Solid;
})
)
.onCancel(() => {
console.log("sequence gesture canceled")
})
)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170316.63374269485924375116529803470487:50001231000000:2800:95CA4F45A407D581BF3E18FD5F638AFB63189C86DE71D1E28D9DDC53CF8DF7DB.gif)
拖拽事件是一种典型的顺序识别组合手势事件，由长按手势事件和滑动手势事件组合而成。只有先长按达到长按手势事件预设置的时间后进行滑动才会触发拖拽事件。如果长按事件未达到或者长按后未进行滑动，拖拽事件均识别失败。
并行识别
并行识别组合手势对应的GestureMode为Parallel。并行识别组合手势中注册的手势将同时进行识别，直到所有手势识别结束。并行识别手势组合中的手势进行识别时互不影响。
以在一个Column组件上绑定点击手势和双击手势组成的并行识别手势为例，由于单击手势和双击手势是并行识别，因此两个手势可以同时进行识别，二者互不干涉。
```typescript
// xxx.ets
@Entry
@Component
struct Index {
@State count1: number = 0;
@State count2: number = 0;
build() {
Column() {
Text('Parallel gesture\n' + 'tapGesture count is 1:' + this.count1 + '\ntapGesture count is 2:' + this.count2 + '\n')
.fontSize(28)
}
.height(200)
.width('100%')
// 以下组合手势为并行并别，单击手势识别成功后，若在规定时间内再次点击，双击手势也会识别成功
.gesture(
GestureGroup(GestureMode.Parallel,
TapGesture({ count: 1 })
.onAction(() => {
this.count1++;
}),
TapGesture({ count: 2 })
.onAction(() => {
this.count2++;
})
)
)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170317.10799229884591502436355183551676:50001231000000:2800:14FF33B21E8D04C7CB01DAFB3D6D0E5797BF6E8CEE418198281BBE8FA3C3558A.gif)
当由单击手势和双击手势组成一个并行识别组合手势后，在区域内进行点击时，单击手势和双击手势将同时进行识别。
当只有单次点击时，单击手势识别成功，双击手势识别失败。
当有两次点击时，若两次点击相距时间在规定时间内（默认规定时间为300毫秒），触发两次单击事件和一次双击事件。
当有两次点击时，若两次点击相距时间超出规定时间，触发两次单击事件不触发双击事件。
互斥识别
互斥识别组合手势对应的GestureMode为Exclusive。互斥识别组合手势中注册的手势将同时进行识别，若有一个手势识别成功，则结束手势识别，其他所有手势识别失败。
以在一个Column组件上绑定单击手势和双击手势组合而成的互斥识别组合手势为例。若先绑定单击手势后绑定双击手势，由于单击手势只需要一次点击即可触发而双击手势需要两次，每次的点击事件均被单击手势消费而不能积累成双击手势，所以双击手势无法触发。若先绑定双击手势后绑定单击手势，则触发双击手势不触发单击手势。
```typescript
// xxx.ets
@Entry
@Component
struct Index {
@State count1: number = 0;
@State count2: number = 0;
build() {
Column() {
Text('Exclusive gesture\n' + 'tapGesture count is 1:' + this.count1 + '\ntapGesture count is 2:' + this.count2 + '\n')
.fontSize(28)
}
.height(200)
.width('100%')
//以下组合手势为互斥并别，单击手势识别成功后，双击手势会识别失败
.gesture(
GestureGroup(GestureMode.Exclusive,
TapGesture({ count: 1 })
.onAction(() => {
this.count1++;
}),
TapGesture({ count: 2 })
.onAction(() => {
this.count2++;
})
)
)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170317.93192161509663512989039674140630:50001231000000:2800:1054E98CEB1EEF9802ACFDDF41C28DA4AA95EC7ED5C7798EA9BB5B269805F1EC.gif)
当由单击手势和双击手势组成一个互斥识别组合手势后，在区域内进行点击时，单击手势和双击手势将同时进行识别。
当只有单次点击时，单击手势识别成功，双击手势识别失败。
当有两次点击时，手势响应取决于绑定手势的顺序。若先绑定单击手势后绑定双击手势，单击手势在第一次点击时即宣告识别成功，此时双击手势已经失败。即使在规定时间内进行了第二次点击，双击手势事件也不会进行响应，此时会触发单击手势事件的第二次识别成功。若先绑定双击手势后绑定单击手势，则会响应双击手势不响应单击手势。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-gesture-events-multi-level-gesture-V14
爬取时间: 2025-04-27 23:38:05
来源: Huawei Developer
多层级手势事件指父子组件嵌套时，父子组件均绑定了手势或事件。在该场景下，手势或者事件的响应受到多个因素的影响，相互之间发生传递和竞争，容易出现预期外的响应。
本章主要介绍了多层级手势事件的默认响应顺序，以及如何通过设置相关属性影响多层级手势事件的响应顺序。
默认多层级手势事件
触摸事件
触摸事件（onTouch事件）是所有手势组成的基础，有Down，Move，Up，Cancel四种。手势均由触摸事件组成，例如，点击为Down+Up，滑动为Down+一系列Move+Up。触摸事件具有最特殊性：
1.监听了onTouch事件的组件。若在手指落下时被触摸则均会收到onTouch事件的回调，被触摸受到触摸热区和触摸控制影响。
2.onTouch事件的回调是闭环的。若一个组件收到了手指Id为0的Down事件，后续也会收到手指Id为0的Move事件和Up事件。
3.onTouch事件的回调是一致的。若一个组件收到了手指Id为0的Down事件未收到手指Id为1的Down事件，则后续只会收到手指Id为0的touch事件，不会收到手指Id为1的后续touch事件。
对于一般的容器组件（例如：Column），父子组件之间onTouch事件能够同时触发，兄弟组件之间onTouch事件根据布局进行触发。
```typescript
ComponentA() {
ComponentB().onTouch(() => {})
ComponentC().onTouch(() => {})
}.onTouch(() => {})
```
组件B和组件C作为组件A的子组件，当触摸到组件B或者组件C时，组件A也会被触摸到。onTouch事件允许多个组件同时触发，
因此，当触摸组件B时，会触发组件A和组件B的onTouch回调，不会触发组件C的onTouch回调。
当触摸组件C时，会触发组件A和组件C的onTouch回调，不触发组件B的回调。
特殊的容器组件，如Stack等组件，由于子组件之间存在着堆叠关系，子组件的布局也互相存在遮盖关系。
所以，父子组件之间onTouch事件能够同时触发，兄弟组件之间onTouch事件会存在遮盖关系。
```typescript
Stack A() {
ComponentB().onTouch(() => {})
ComponentC().onTouch(() => {})
}.onTouch(() => {})
```
组件B和组件C作为Stack A的子组件，组件C覆盖在组件B上。当触摸到组件B或者组件C时，Stack A也会被触摸到。onTouch事件允许多个组件同时触发，因此，当触摸组件B和组件C的重叠区域时，会触发Stack A和组件C的onTouch回调，不会触发组件B的onTouch回调（组件B被组件C遮盖）。
手势与事件
除了触摸事件（onTouch事件）外的所有手势与事件，均是通过基础手势或者组合手势实现的。例如，拖拽事件是由长按手势和滑动手势组成的一个顺序手势。
在未显式声明的情况下，同一时间，一根手指对应的手势组中只会有一个手势获得成功从而触发所设置的回调。
因此，除非显式声明允许多个手势同时成功，同一时间只会有一个手势响应。
响应优先级遵循以下条件：
1.当父子组件均绑定同一类手势时，子组件优先于父组件触发。
2.当一个组件绑定多个手势时，先达到手势触发条件的手势优先触发。
```typescript
ComponentA() {
ComponentB().gesture(TapGesture({count: 1}))
}.gesture(TapGesture({count: 1}))
```
当父组件和子组件均绑定点击手势时，子组件的优先级高于父组件。
因此，当在B组件上进行点击时，组件B所绑定的TapGesture的回调会被触发，而组件A所绑定的TapGesture的回调不会被触发。
```typescript
ComponentA()
.gesture(
GestureGroup(
GestureMode.Exclusive,
TapGesture({count: 1}),
PanGesture({distance: 5})
)
)
```
当组件A上绑定了由点击和滑动手势组成的互斥手势组时，先达到手势触发条件的手势触发对应的回调。
若使用者做了一次点击操作，则响应点击对应的回调。若使用者进行了一次滑动操作并且滑动距离达到了阈值，则响应滑动对应的回调。
自定义控制的多层级手势事件
可以通过设置属性，控制默认的多层级手势事件竞争流程，更好的实现手势事件。
目前，responseRegion属性和hitTestBehavior属性可以控制Touch事件的分发，从而可以影响到onTouch事件和手势的响应。而绑定手势方法属性可以控制手势的竞争从而影响手势的响应，但不能影响到onTouch事件。
responseRegion对手势和事件的控制
responseRegion属性可以实现组件的响应区域范围的变化。响应区域范围可以超出或者小于组件的布局范围。
```typescript
ComponentA() {
ComponentB()
.onTouch(() => {})
.gesture(TapGesture({count: 1}))
.responseRegion({Rect1, Rect2, Rect3})
}
.onTouch(() => {})
.gesture(TapGesture({count: 1}))
.responseRegion({Rect4})
```
当组件A绑定了.responseRegion({Rect4})的属性后，所有落在Rect4区域范围的触摸事件和手势可被组件A对应的回调响应。
当组件B绑定了.responseRegion({Rect1, Rect2, Rect3})的属性后，所有落在Rect1,Rect2和Rect3区域范围的触摸事件和手势可被组件B对应的回调响应。
当绑定了responseRegion后，手势与事件的响应区域范围将以所绑定的区域范围为准，而不是以布局区域为准，可能出现布局相关区域不响应手势与事件的情况。
此外，responseRegion属性支持由多个Rect组成的数组作为入参，以支持更多开发需求。
hitTestBehavior对手势和事件的控制
hitTestBehavior属性可以实现在复杂的多层级场景下，一些组件能够响应手势和事件，而一些组件不能响应手势和事件。
```typescript
ComponentA() {
ComponentB()
.onTouch(() => {})
.gesture(TapGesture({count: 1}))
ComponentC() {
ComponentD()
.onTouch(() => {})
.gesture(TapGesture({count: 1}))
}
.onTouch(() => {})
.gesture(TapGesture({count: 1}))
.hitTestBehavior(HitTestMode.Block)
}
.onTouch(() => {})
.gesture(TapGesture({count: 1}))
```
HitTestMode.Block自身会响应触摸测试，阻塞子节点和兄弟节点的触摸测试，从而导致子节点和兄弟节点的onTouch事件和手势均无法触发。
当组件C未设置hitTestBehavior时，点击组件D区域，组件A、组件C和组件D的onTouch事件会触发，组件D的点击手势会触发。
当组件C设置了hitTestBehavior为HitTestMode.Block时，点击组件D区域，组件A和组件C的onTouch事件会触发，组件D的onTouch事件未触发。同时，由于组件D的点击手势因为被阻塞而无法触发，组件C的点击手势会触发。
```typescript
Stack A() {
ComponentB()
.onTouch(() => {})
.gesture(TapGesture({count: 1}))
ComponentC()
.onTouch(() => {})
.gesture(TapGesture({count: 1}))
.hitTestBehavior(HitTestMode.Transparent)
}
.onTouch(() => {})
.gesture(TapGesture({count: 1}))
```
HitTestMode.Transparent自身响应触摸测试，不会阻塞兄弟节点的触摸测试。
当组件C未设置hitTestBehavior时，点击组件B和组件C的重叠区域时，Stack A和组件C的onTouch事件会触发，组件C的点击事件会触发，组件B的onTouch事件和点击手势均不触发。
而当组件C设置hitTestBehavior为HitTestMode.Transparent时，点击组件B和组件C的重叠区域，组件A和组件C不受到影响与之前一致，组件A和组件C的onTouch事件会触发，组件C的点击手势会触发。而组件B因为组件C设置了HitTestMode.Transparent，组件B也收到了Touch事件，从而组件B的onTouch事件和点击手势触发。
```typescript
ComponentA() {
ComponentB()
.onTouch(() => {})
.gesture(TapGesture({count: 1}))
}
.onTouch(() => {})
.gesture(TapGesture({count: 1}))
.hitTestBehavior(HitTestMode.None)
```
HitTestMode.None自身不响应触摸测试，不会阻塞子节点和兄弟节点的触摸控制。
当组件A未设置hitTestBehavior时，点击组件B区域时，组件A和组件B的onTouch事件均会触发，组件B的点击手势会触发。
当组件A设置hitTestBehavior为HitTestMode.None时，点击组件B区域时，组件B的onTouch事件触发，而组件A的onTouch事件无法触发，组件B的点击手势触发。
针对简单的场景，建议在单个组件上绑定hitTestBehavior。
针对复杂场景，建议在多个组件上绑定不同的hitTestBehavior来控制Touch事件的分发。
绑定手势方法对手势的控制
设置绑定手势的方法可以实现在多层级场景下，当父组件与子组件绑定了相同的手势时，设置不同的绑定手势方法有不同的响应优先级。
当父组件使用.gesture绑定手势，父子组件所绑定手势类型相同时，子组件优先于父组件响应。
```typescript
ComponentA() {
ComponentB()
.gesture(TapGesture({count: 1}))
}
.gesture(TapGesture({count: 1}))
```
当父子组件均正常绑定点击手势时，子组件优先于父组件响应。
此时，单击组件B区域范围，组件B的点击手势会触发，组件A的点击手势不会触发。
如果以带优先级的方式绑定手势，则可使得父组件所绑定手势的响应优先级高于子组件。
```typescript
ComponentA() {
ComponentB()
.gesture(TapGesture({count: 1}))
}
.priorityGesture(TapGesture({count: 1}))
```
当父组件以.priorityGesture的形式绑定手势时，父组件所绑定的手势优先级高于子组件。
此时，单击组件B区域范围，组件A的点击手势会触发，组件B的点击手势不会触发。
如果需要父子组件所绑定的手势不发生冲突，均可响应，则可以使用并行的方式在父组件绑定手势。
```typescript
ComponentA() {
ComponentB()
.gesture(TapGesture({count: 1}))
}
.parallelGesture(TapGesture({count: 1}))
```
当父组件以.parallelGesture的形式绑定手势时，父组件和子组件所绑定的手势均可触发。
此时，单击组件B区域范围，组件A和组件B的点击手势均会触发。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-gesture-events-gesture-judge-V14
爬取时间: 2025-04-27 23:38:18
来源: Huawei Developer
手势拦截主要用于确保手势按需执行，有效解决手势冲突问题。典型应用场景包括：嵌套滚动、通过过滤组件响应手势的范围来优化交互体验。手势拦截主要采用手势触发控制和手势响应控制两种方式实现。
手势触发控制
手势触发控制是指，在系统判定阈值已满足的条件下，应用可自行判断是否应拦截手势，使手势操作失败。
图1手势触发控制流程图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170317.93722916886967793263251785960334:50001231000000:2800:4C786F022CD7035AA05EB86C805A298DB206AEF54D5C7300F65A9E13EAB7C0DF.png)
手势触发控制涉及以下接口。
| 接口 | 说明 |
| --- | --- |
| onGestureJudgeBegin | 用于手势拦截，是通用事件。在手势满足系统触发阈值场景下，回调给应用判断是否拦截手势。 |
| onGestureRecognizerJudgeBegin | 用于手势拦截、获取手势识别器和初始化手势识别器开闭状态。是onGestureJudgeBegin接口的能力扩展，可以代替onGestureJudgeBegin接口。 获取手势识别器时，会获取一次交互中手势响应链上的所有手势识别器，以及当前即将触发的手势识别器，初始化手势的激活状态。 |
用于手势拦截、获取手势识别器和初始化手势识别器开闭状态。是onGestureJudgeBegin接口的能力扩展，可以代替onGestureJudgeBegin接口。
获取手势识别器时，会获取一次交互中手势响应链上的所有手势识别器，以及当前即将触发的手势识别器，初始化手势的激活状态。
以下示例中，Image和Stack两个组件位于同一区域。长按Stack组件的上半部分可触发挂载在Stack组件上的长按手势，长按Stack组件的下半部分则会响应Image组件的拖拽操作。
图2示例图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170317.65134028192002766814962192016363:50001231000000:2800:1B1D5AF5C5B134008EA3B96D82661AC563ED83303B0CCF706FADC739B62B682D.png)
1.  Image组件设置拖拽。
```typescript
Image($r('sys.media.ohos_app_icon'))
.draggable(true)
.onDragStart(()=>{
promptAction.showToast({ message: "Drag 下半区蓝色区域，Image响应" });
})
.width('200vp').height('200vp')
```
2.  Stack组件设置手势。
```typescript
Stack() {}
.width('200vp')
.height('200vp')
.hitTestBehavior(HitTestMode.Transparent)
.gesture(GestureGroup(GestureMode.Parallel,
LongPressGesture()
.onAction((event: GestureEvent) => {
promptAction.showToast({ message: "LongPressGesture 长按上半区 红色区域，红色区域响应" });
})
.tag("longpress")
))
```
3.  Stack组件设置拦截。
```typescript
.onGestureJudgeBegin((gestureInfo: GestureInfo, event: BaseGestureEvent) => {
// 如果是长按类型手势，判断点击的位置是否在上半区
if (gestureInfo.type == GestureControl.GestureType.LONG_PRESS_GESTURE) {
if (event.fingerList.length > 0 && event.fingerList[0].localY < 100) {
return GestureJudgeResult.CONTINUE;
} else {
return GestureJudgeResult.REJECT;
}
}
return GestureJudgeResult.CONTINUE;
})
```
4.  代码完整示例。
```typescript
import { promptAction } from '@kit.ArkUI';
@Entry
@Component
struct Index {
scroller: Scroller = new Scroller();
build() {
Scroll(this.scroller) {
Column({ space: 8 }) {
Text("包括上下两层组件，上层组件绑定长按手势，下层组件绑定拖拽。其中上层组件下半区域绑定手势拦截，使该区域响应下层拖拽手势。").width('100%').fontSize(20).fontColor('0xffdd00')
Stack({ alignContent: Alignment.Center }) {
Column() {
// 模拟上半区和下半区
Stack().width('200vp').height('100vp').backgroundColor(Color.Red)
Stack().width('200vp').height('100vp').backgroundColor(Color.Blue)
}.width('200vp').height('200vp')
// Stack的下半区是绑定了拖动手势的图像区域。
Image($r('sys.media.ohos_app_icon'))
.draggable(true)
.onDragStart(()=>{
promptAction.showToast({ message: "Drag 下半区蓝色区域，Image响应" });
})
.width('200vp').height('200vp')
// Stack的上半区是绑定了长按手势的浮动区域。
Stack() {
}
.width('200vp')
.height('200vp')
.hitTestBehavior(HitTestMode.Transparent)
.gesture(GestureGroup(GestureMode.Parallel,
LongPressGesture()
.onAction((event: GestureEvent) => {
promptAction.showToast({ message: "LongPressGesture 长按上半区 红色区域，红色区域响应" });
})
.tag("longpress")
))
.onGestureJudgeBegin((gestureInfo: GestureInfo, event: BaseGestureEvent) => {
// 如果是长按类型手势，判断点击的位置是否在上半区
if (gestureInfo.type == GestureControl.GestureType.LONG_PRESS_GESTURE) {
if (event.fingerList.length > 0 && event.fingerList[0].localY < 100) {
return GestureJudgeResult.CONTINUE;
} else {
return GestureJudgeResult.REJECT;
}
}
return GestureJudgeResult.CONTINUE;
})
}.width('100%')
}.width('100%')
}
}
}
```
手势响应控制
手势响应控制，指的是手势已经成功识别，但是开发者仍然可以通过调用API接口控制手势回调是否能够响应。
图3手势响应控制流程图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170317.54270133891613565051509190851436:50001231000000:2800:F10F20EFFE1E002B03359DE6ED94C7C33648F4928327B224DA95E958C0636634.png)
手势响应控制的前提是手势识别成功，如果手势不成功也不会产生手势回调响应。
1.  业务手势作业流：指真正触发UI变化的业务手势，比如使页面滚动的PanGesture，触发点击的TapGesture等。
2.  监听手势作业流：指在监听手势运行的过程中，应根据上下文的业务状态变化动态控制手势识别器的启停，例如在组件于嵌套滚动过程中是否已滑至边缘。这一监听事件可借助一个使用并行手势绑定方式的PanGesture实现，或者采用Touch事件来完成。
3.  设置手势并行：此步骤并非必需，典型场景是在嵌套滚动中，设置外部组件的滚动手势与内部的滚动手势并行。
4.  动态开闭手势：指通过手势识别器的setEnable方法，控制手势是否响应用户回调。
手势响应控制涉及以下接口。
| 接口 | 说明 |
| --- | --- |
| shouldBuiltInRecognizerParallelWith | 用于设置系统原生组件内置手势与其他手势并行。 |
| onGestureRecognizerJudgeBegin | 用于手势拦截，获取手势识别器，初始化手势识别器开闭状态。 |
| parallelGesture | 可使开发者定义的手势，与比他优先级高的手势并行。 |
以下示例是两个Scroll组件的嵌套滚动场景，使用手势控制的api去控制外部组件和内部组件的嵌套滚动联动。
1.  使用shouldBuiltInRecognizerParallelWith接口设置外部Scroll组件的PanGesture手势，与内部Scroll组件的PanGesture手势并行。
```typescript
.shouldBuiltInRecognizerParallelWith((current: GestureRecognizer, others: Array<GestureRecognizer>) => {
for (let i = 0; i < others.length; i++) {
let target = others[i].getEventTargetInfo();
if (target.getId() == "inner" && others[i].isBuiltIn() && others[i].getType() == GestureControl.GestureType.PAN_GESTURE) { // 找到将要组成并行手势的识别器
this.currentRecognizer = current; // 保存当前组件的识别器
this.childRecognizer = others[i]; // 保存将要组成并行手势的识别器
return others[i]; // 返回和当前手势将要组成并行手势的识别器
}
}
return undefined;
})
```
2.  使用onGestureRecognizerJudgeBegin接口获取到Scroll组件的PanGesture手势识别器，同时根据内外Scroll组件的边界条件，初始化内外手势的开闭状态。
```typescript
.onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer, others: Array<GestureRecognizer>) => { // 在识别器即将要成功时，根据当前组件状态，设置识别器使能状态
let target = current.getEventTargetInfo();
if (target.getId() == "outer" && current.isBuiltIn() && current.getType() == GestureControl.GestureType.PAN_GESTURE) {
for (let i = 0; i < others.length; i++) {
let target = others[i].getEventTargetInfo() as ScrollableTargetInfo;
if (target instanceof ScrollableTargetInfo && target.getId() == "inner") { // 找到响应链上对应并行的识别器
let panEvent = event as PanGestureEvent;
this.childRecognizer.setEnabled(true);
this.currentRecognizer.setEnabled(false);
if (target.isEnd()) { // 根据当前组件状态以及移动方向动态控制识别器使能状态
if (panEvent && panEvent.offsetY < 0) {
this.childRecognizer.setEnabled(false);
this.currentRecognizer.setEnabled(true);
}
} else if (target.isBegin()) {
if (panEvent.offsetY > 0) {
this.childRecognizer.setEnabled(false);
this.currentRecognizer.setEnabled(true);
}
}
}
}
}
return GestureJudgeResult.CONTINUE;
})
```
3.  设置监听手势，监听Scroll组件状态，动态调整手势开闭状态，以使手势响应。
```typescript
.parallelGesture( // 绑定一个Pan手势作为动态控制器
PanGesture()
.onActionUpdate((event: GestureEvent)=>{
if (this.childRecognizer.getState() != GestureRecognizerState.SUCCESSFUL || this.currentRecognizer.getState() != GestureRecognizerState.SUCCESSFUL) { // 如果识别器状态不是SUCCESSFUL，则不做控制
return;
}
let target = this.childRecognizer.getEventTargetInfo() as ScrollableTargetInfo;
let currentTarget = this.currentRecognizer.getEventTargetInfo() as ScrollableTargetInfo;
if (target instanceof ScrollableTargetInfo && currentTarget instanceof ScrollableTargetInfo) {
this.childRecognizer.setEnabled(true);
this.currentRecognizer.setEnabled(false);
if (target.isEnd()) { // 在移动过程中实时根据当前组件状态，控制识别器的开闭状态
if ((event.offsetY - this.lastOffset) < 0) {
this.childRecognizer.setEnabled(false);
if (currentTarget.isEnd()) {
this.currentRecognizer.setEnabled(false);
} else {
this.currentRecognizer.setEnabled(true);
}
}
} else if (target.isBegin()) {
if ((event.offsetY - this.lastOffset) > 0) {
this.childRecognizer.setEnabled(false);
if (currentTarget.isBegin()) {
this.currentRecognizer.setEnabled(false);
} else {
this.currentRecognizer.setEnabled(true);
}
}
}
}
this.lastOffset = event.offsetY
})
)
```
4.  代码完整示例。
```typescript
// xxx.ets
@Entry
@Component
struct FatherControlChild {
scroller: Scroller = new Scroller();
scroller2: Scroller = new Scroller();
private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
private childRecognizer: GestureRecognizer = new GestureRecognizer();
private currentRecognizer: GestureRecognizer = new GestureRecognizer();
private lastOffset: number = 0;
build() {
Stack({ alignContent: Alignment.TopStart }) {
Scroll(this.scroller) { // 外部滚动容器
Column() {
Text("Scroll Area")
.width('90%')
.height(150)
.backgroundColor(0xFFFFFF)
.borderRadius(15)
.fontSize(16)
.textAlign(TextAlign.Center)
.margin({ top: 10 })
Scroll(this.scroller2) { // 内部滚动容器
Column() {
Text("Scroll Area2")
.width('90%')
.height(150)
.backgroundColor(0xFFFFFF)
.borderRadius(15)
.fontSize(16)
.textAlign(TextAlign.Center)
.margin({ top: 10 })
Column() {
ForEach(this.arr, (item: number) => {
Text(item.toString())
.width('90%')
.height(150)
.backgroundColor(0xFFFFFF)
.borderRadius(15)
.fontSize(16)
.textAlign(TextAlign.Center)
.margin({ top: 10 })
}, (item: string) => item)
}.width('100%')
}
}
.id("inner")
.width('100%')
.height(800)
}.width('100%')
}
.id("outer")
.height(600)
.scrollable(ScrollDirection.Vertical) // 滚动方向纵向
.scrollBar(BarState.On) // 滚动条常驻显示
.scrollBarColor(Color.Gray) // 滚动条颜色
.scrollBarWidth(10) // 滚动条宽度
.edgeEffect(EdgeEffect.None)
.shouldBuiltInRecognizerParallelWith((current: GestureRecognizer, others: Array<GestureRecognizer>) => {
for (let i = 0; i < others.length; i++) {
let target = others[i].getEventTargetInfo();
if (target.getId() == "inner" && others[i].isBuiltIn() && others[i].getType() == GestureControl.GestureType.PAN_GESTURE) { // 找到将要组成并行手势的识别器
this.currentRecognizer = current; // 保存当前组件的识别器
this.childRecognizer = others[i]; // 保存将要组成并行手势的识别器
return others[i]; // 返回和当前手势将要组成并行手势的识别器
}
}
return undefined;
})
.onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer, others: Array<GestureRecognizer>) => { // 在识别器即将要成功时，根据当前组件状态，设置识别器使能状态
let target = current.getEventTargetInfo();
if (target.getId() == "outer" && current.isBuiltIn() && current.getType() == GestureControl.GestureType.PAN_GESTURE) {
for (let i = 0; i < others.length; i++) {
let target = others[i].getEventTargetInfo() as ScrollableTargetInfo;
if (target instanceof ScrollableTargetInfo && target.getId() == "inner") { // 找到响应链上对应并行的识别器
let panEvent = event as PanGestureEvent;
this.childRecognizer.setEnabled(true);
this.currentRecognizer.setEnabled(false);
if (target.isEnd()) { // 根据当前组件状态以及移动方向动态控制识别器使能状态
if (panEvent && panEvent.offsetY < 0) {
this.childRecognizer.setEnabled(false);
this.currentRecognizer.setEnabled(true);
}
} else if (target.isBegin()) {
if (panEvent.offsetY > 0) {
this.childRecognizer.setEnabled(false);
this.currentRecognizer.setEnabled(true);
}
}
}
}
}
return GestureJudgeResult.CONTINUE;
})
.parallelGesture( // 绑定一个Pan手势作为动态控制器
PanGesture()
.onActionUpdate((event: GestureEvent)=>{
if (this.childRecognizer.getState() != GestureRecognizerState.SUCCESSFUL || this.currentRecognizer.getState() != GestureRecognizerState.SUCCESSFUL) { // 如果识别器状态不是SUCCESSFUL，则不做控制
return;
}
let target = this.childRecognizer.getEventTargetInfo() as ScrollableTargetInfo;
let currentTarget = this.currentRecognizer.getEventTargetInfo() as ScrollableTargetInfo;
if (target instanceof ScrollableTargetInfo && currentTarget instanceof ScrollableTargetInfo) {
this.childRecognizer.setEnabled(true);
this.currentRecognizer.setEnabled(false);
if (target.isEnd()) { // 在移动过程中实时根据当前组件状态，控制识别器的开闭状态
if ((event.offsetY - this.lastOffset) < 0) {
this.childRecognizer.setEnabled(false);
if (currentTarget.isEnd()) {
this.currentRecognizer.setEnabled(false);
} else {
this.currentRecognizer.setEnabled(true);
}
}
} else if (target.isBegin()) {
if ((event.offsetY - this.lastOffset) > 0) {
this.childRecognizer.setEnabled(false)
if (currentTarget.isBegin()) {
this.currentRecognizer.setEnabled(false);
} else {
this.currentRecognizer.setEnabled(true);
}
}
}
}
this.lastOffset = event.offsetY;
})
)
}.width('100%').height('100%').backgroundColor(0xDCDCDC)
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-user-defined-capabilities-V14
爬取时间: 2025-04-27 23:38:32
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-user-defined-V14
爬取时间: 2025-04-27 23:38:45
来源: Huawei Developer
自定义能力分层
自定义能力是ArkUI开发框架提供的对UI界面进行开发和定制化的能力。ArkUI开发框架提供的不同控制层级的自定义能力用于实现不同场景的应用的开发。自定义能力的开放层次越低，表示越接近底层基础能力，开发的灵活程度越高，开发难度越高、对于开发者能力的要求也越高。
当前开放的自定义能力由低到高包括以下几个层次：
自定义能力导览
上述提到自定义能力层次不同，使用场景也不同。通过以下导览，可快速了解各种自定义能力的说明以及使用场景和建议。
| 自定义层次 | 自定义能力 | 能力说明及适用场景 |
| --- | --- | --- |
| 自定义组合 | 自定义封装 | @Component装饰器：提供了最基础的组件封装能力，通过组合已有组件封装为新的自定义组件。 @Builder装饰器：提供更轻量的UI封装和复用机制，可以将重复使用的UI结构抽象成一个Builder方法，在组件的build方法中调用。 |
| 自定义组合 | 自定义布局 | 层叠布局（Stack）：通过Stack容器，结合尺寸设置和位置设置的通用属性，可对子组件进行自定义的排布。适用于子组件明确、相对简单的布局场景。 自定义组件的自定义布局：通过自定义组件的布局生命周期回调方法，对组件内子组件的位置进行调整。适用于封装一个特定布局算法的自定义组件。 |
| 自定义组合 | 自定义绘制 | Canvas组件：通过Canvas组件的能力进行自定义绘制，通过组合的方式集成到自定义组件中，其接口和W3C标准的Canvas接口相近，在性能不敏感的场景下，适用于熟悉Web开发的开发者，可用于移植基于W3C的Canvas的绘制库。 Shape类组件：通过基础的图形类组件（Rect、Path、Circle、Ellipse、Polyline、Polygon）进行组合，构建出自定义的图形。类似SVG矢量图的能力，适用于比较简单的图形组合，并可以结合动画的能力，实现一些交互的图形动画。 |
| 自定义组合 | 自定义动画 | 属性动画：对于组件的可动画属性，通过属性动画的能力，可组合实现自定义的动画效果。 @AnimatableExtend装饰器：对于组件的不可动画属性，通过@AnimatableExtend装饰器，使不可动画属性能实现自定义动画效果。 @ohos.animator 接口：通过动画接口可实现逐帧修改属性或结合自定义绘制的能力，实现类似帧动画的自定义动画效果。 |
| 自定义扩展 | 属性扩展 | AttributeModifier：通过AttributeModifier可以实现UI与样式分离，实现属性、事件的动态设置与更新，同时支持跨文件的导出与复用。可用于组件封装，通过暴露Modifier实现属性的扩展。 自定义Modifier：通过框架提供封装的组件Modifier类，直接在Modifier对象上暴露组件的属性和方法，可以简化组件封装时属性的传递与扩展。 AttributeUpdater：在AttributeModifier的基础上增加直接设置属性的能力，避免通过状态变量更新带来的性能损耗。适用于大量组件频繁更新某些属性的场景，提升属性设置的性能。 |
| 自定义扩展 | 手势扩展 | GestureModifier：与AttributeModifier的能力类似，支持对手势进行扩展，动态的添加、删除手势，同样可以支持跨文件的导出与复用。适用于需要对自定义手势处理的通用逻辑进行封装和复用的场景。 |
| 自定义扩展 | 内容扩展 | DrawModifier：通过DrawModifier可以在原生组件的基础之上，扩展叠加绘制自定义的内容，或者完全替换组件默认的绘制内容。 ContentModifier：在一些内容区和交互明确的内置组件上，通过ContentModifier可以实现使用自定义的Builder方法替换组件的内容。 |
| 自定义节点 | 组件节点 | FrameNode: 表示组件的实体节点，主要提供以下两类能力： 完全自定义节点能力：提供完整的自定义能力，包括自定义测量、布局以及绘制，支持节点的动态增加、删除，并且可以为节点设置通用属性和事件。适用于不带渲染引擎，但需要依赖系统的布局、事件、动画及渲染等能力，实现语言为高级语言的三方框架对接。 组件代理节点能力：提供声明式组件的代理能力，提供遍历节点树的能力，通过FrameNode可以遍历整个组件树，并通过节点访问组件的信息或者注册额外的事件监听回调。适用于结合无感监听的接口实现打点、广告SDK、中台DFX等业务。 TypedFrameNode：通过typeNode提供的接口，可创建具体类型的FrameNode能力。创建出具体组件类型的FrameNode，可通过FrameNode的接口，进行自定义的挂载，生成一棵自定义的组件树。适用于高效对接高级语言开发的动态化框架。 |
| 自定义节点 | 渲染节点 | RenderNode：表示轻量级的渲染节点RenderNode，仅提供了设置渲染相关属性、自定义绘制内容以及节点操作的能力。可以向三方框架提供基础的渲染、动画能力。适用于不带渲染引擎，只依赖系统的基础动画、渲染的三方框架对接。 |
| 自定义节点 | 原生组件混合 | BuilderNode：BuilderNode对象提供了能够创建、更新原生组件以及组件树的能力。用于在自定义的FrameNode或RenderNode树结构中嵌入声明式的组件结构，实现原生组件与自定义节点的混合显示。另外还提供了对Builder内容进行纹理导出的能力，可实现在XComponent创建的渲染环境中进行同层渲染显示。 |
| 自定义渲染 | 独立渲染 | XComponent：XComponent的“surface”模式会暴露出NativeWindow，通过NDK接口配合NativeWindow可创建独立的渲染环境，将EGL/OpenGLES生成的显示数据或其它方式解码生成的媒体流数据写入到NativeWindow中，不依赖ArkUI框架提供的其它组件能力即可进行自定义的渲染。适用于自带渲染引擎的框架，如游戏引擎、地图、相机等场景。 |
@Component装饰器：提供了最基础的组件封装能力，通过组合已有组件封装为新的自定义组件。
@Builder装饰器：提供更轻量的UI封装和复用机制，可以将重复使用的UI结构抽象成一个Builder方法，在组件的build方法中调用。
层叠布局（Stack）：通过Stack容器，结合尺寸设置和位置设置的通用属性，可对子组件进行自定义的排布。适用于子组件明确、相对简单的布局场景。
自定义组件的自定义布局：通过自定义组件的布局生命周期回调方法，对组件内子组件的位置进行调整。适用于封装一个特定布局算法的自定义组件。
Canvas组件：通过Canvas组件的能力进行自定义绘制，通过组合的方式集成到自定义组件中，其接口和W3C标准的Canvas接口相近，在性能不敏感的场景下，适用于熟悉Web开发的开发者，可用于移植基于W3C的Canvas的绘制库。
Shape类组件：通过基础的图形类组件（Rect、Path、Circle、Ellipse、Polyline、Polygon）进行组合，构建出自定义的图形。类似SVG矢量图的能力，适用于比较简单的图形组合，并可以结合动画的能力，实现一些交互的图形动画。
属性动画：对于组件的可动画属性，通过属性动画的能力，可组合实现自定义的动画效果。
@AnimatableExtend装饰器：对于组件的不可动画属性，通过@AnimatableExtend装饰器，使不可动画属性能实现自定义动画效果。
@ohos.animator接口：通过动画接口可实现逐帧修改属性或结合自定义绘制的能力，实现类似帧动画的自定义动画效果。
AttributeModifier：通过AttributeModifier可以实现UI与样式分离，实现属性、事件的动态设置与更新，同时支持跨文件的导出与复用。可用于组件封装，通过暴露Modifier实现属性的扩展。
自定义Modifier：通过框架提供封装的组件Modifier类，直接在Modifier对象上暴露组件的属性和方法，可以简化组件封装时属性的传递与扩展。
AttributeUpdater：在AttributeModifier的基础上增加直接设置属性的能力，避免通过状态变量更新带来的性能损耗。适用于大量组件频繁更新某些属性的场景，提升属性设置的性能。
DrawModifier：通过DrawModifier可以在原生组件的基础之上，扩展叠加绘制自定义的内容，或者完全替换组件默认的绘制内容。
ContentModifier：在一些内容区和交互明确的内置组件上，通过ContentModifier可以实现使用自定义的Builder方法替换组件的内容。
FrameNode: 表示组件的实体节点，主要提供以下两类能力：
完全自定义节点能力：提供完整的自定义能力，包括自定义测量、布局以及绘制，支持节点的动态增加、删除，并且可以为节点设置通用属性和事件。适用于不带渲染引擎，但需要依赖系统的布局、事件、动画及渲染等能力，实现语言为高级语言的三方框架对接。
组件代理节点能力：提供声明式组件的代理能力，提供遍历节点树的能力，通过FrameNode可以遍历整个组件树，并通过节点访问组件的信息或者注册额外的事件监听回调。适用于结合无感监听的接口实现打点、广告SDK、中台DFX等业务。
TypedFrameNode：通过typeNode提供的接口，可创建具体类型的FrameNode能力。创建出具体组件类型的FrameNode，可通过FrameNode的接口，进行自定义的挂载，生成一棵自定义的组件树。适用于高效对接高级语言开发的动态化框架。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-nodes-V14
爬取时间: 2025-04-27 23:38:59
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-user-defined-node-V14
爬取时间: 2025-04-27 23:39:13
来源: Huawei Developer
自定义节点是ArkUI通过接口提供的底层实体节点，具备部分基础能力，能够与系统组件混合显示。自定义节点的挂载与显示依赖于自定义占位节点。当前，自定义节点涵盖三类对象：FrameNode、RenderNode和BuilderNode。FrameNode表示单个自定义组件节点，RenderNode表示为更轻量级的渲染节点，而BuilderNode对象赋予了创建、更新系统组件及其组件树的能力。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170317.29166927749047173644601792616361:50001231000000:2800:1A1475D724128E6AE1361574292171C99FB7BDFAA48B1D05EE481285438BD973.png)
基本概念
-  系统组件：组件是UI的必要元素，形成了在界面中的样子，由ArkUI直接提供的称为系统组件。
-  实体节点：系统内部维护了一棵组件树，用于处理组件的属性设置、生命周期等逻辑。该组件树上的节点即为实体节点。开发者通过TS获取或创建的自定义节点，其本质是一个前端对象，持有对应实体节点的引用。
-  自定义节点：使用ArkUI提供的接口，以命令式创建的节点。包括自定义组件节点（FrameNode）、自定义渲染节点（RenderNode）、自定义声明式节点（BuilderNode）、ComponentContent等。
自定义占位节点
自定义占位节点作为系统组件可以在原生组件树上为自定义节点提供挂载的点。通过自定义占位节点，可以将自定义节点挂载在占位节点上，实现自定义节点与原生组件的混合显示。
自定义组件节点 (FrameNode)
FrameNode表示组件的实体节点，具体可以分为两大类能力：完全自定义节点的能力以及原生组件节点代理的能力。
-  完全自定义节点：提供完整的自定义能力，包括自定义测量、布局以及绘制，支持节点的动态增、删，设置通用属性，设置事件回调。适用于不自带渲染引擎，需要依赖系统的布局、事件、动画、渲染等能力的场景。
-  系统组件代理节点：提供系统组件的代理能力，提供遍历节点树的能力，通过组件树上的FrameNode可以遍历整个组件树，并通过节点访问组件的信息或者注册额外的事件监听回调。适用于结合无感监听的接口实现打点、广告SDK、中台DFX等业务。
自定义渲染节点 (RenderNode)
RenderNode作为轻量级的渲染节点，仅提供了设置渲染相关属性、自定义绘制内容以及节点操作的能力。适用于仅依赖系统渲染与动画能力的自定义场景。
自定义声明式节点 (BuilderNode)
BuilderNode通过无状态的UI方法全局自定义构建函数@Builder生成组件树，组件树内的节点为系统组件。适用于需要基于系统能力创建特定原生组件树与其他自定义节点进行混合显示的场景。相比较系统组件，BuilderNode具备预创建的优势，可以控制开始创建的时间。由于持有实体节点对象，因此可以同步实现节点的复用，通过占位节点结合FrameNode、RenderNode的节点操作能力控制显示位置。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-user-defined-place-hoder-V14
爬取时间: 2025-04-27 23:39:26
来源: Huawei Developer
ArkUI提供了系统组件NodeContainer和ContentSlot作为自定义节点的占位节点。主要用于自定义节点以及自定义节点树的显示。
NodeContainer作为容器节点存在，具备通用属性，是UI节点。ContentSlot只是一个语法节点，无通用属性，不参与布局和渲染。支持混合模式开发，当容器是ArkTS组件，子组件在Native侧创建时，推荐使用ContentSlot占位组件。具体使用参考ContentSlot的接口文档说明。
NodeContainer是用来占位的系统组件，主要用于自定义节点以及自定义节点树的显示，支持组件的通用属性，对通用属性的处理请参考默认左上角对齐的Stack组件。
NodeController提供了一系列生命周期回调，通过makeNode回调返回一个FrameNode节点树的根节点。将FrameNode节点树挂载到对应的NodeContainer下。同时提供了aboutToAppear、aboutToDisappear、aboutToResize、onTouchEvent、rebuild五个回调方法用于监听对应的NodeContainer的状态。
每个生命周期的回调的具体含义参考NodeController的接口文档说明。
-  NodeContainer下仅支持挂载自定义的FrameNode节点以及BuilderNode创建的组件树的根节点。
-  从API Version 12开始支持的接口，可以通过FrameNode的查询接口返回原生组件的代理节点，代理节点可以作为makeNode的返回值进行返回，但代理节点无法成功挂载在组件树上，最终的显示结果为代理节点挂载失败。
-  需要保证一个节点只能作为一个父节点的子节点去使用，否则可能存在显示异常或者功能异常，尤其是页面路由场景或者动效场景。例如，如果通过NodeController将同一个节点挂载在多个NodeContainer上，仅一个占位容器下会显示节点，且多个NodeContainer的可见性、透明度等影响子组件状态的属性更新均会影响被挂载的子节点。
基本概念
-  自定义节点：使用ArkUI提供的接口，以命令式创建的节点。包括自定义组件节点（FrameNode）、自定义渲染节点（RenderNode）、自定义声明式节点（BuilderNode）、ComponentContent等。
-  自定义节点树：根节点为自定义节点的节点树。
-  声明式节点树：根节点为声明式节点的节点树。
-  节点树：一种常见的数据结构，用于表示节点的层级关系。
-  占位节点：用于在声明式节点树上为自定义节点树预留位置的节点，主要包括NodeContainer和ContentSlot。鉴于页面的主树采用声明式节点树，因此，唯有借助占位节点，才能将命令式构建的自定义节点成功挂载至声明式节点树上。
使用NodeContainer挂载自定义节点
通过NodeController在NodeContainer下挂载自定义节点。
```typescript
// common.ets
import { BuilderNode, UIContext } from '@kit.ArkUI'
class Params {
text: string = "this is a text"
}
let buttonNode: BuilderNode<[Params]> | null = null;
@Builder
function buttonBuilder(params: Params) {
Column() {
Button(params.text)
.fontSize(12)
.borderRadius(8)
.borderWidth(2)
.backgroundColor(Color.Orange)
}
}
export function createNode(uiContext: UIContext) {
buttonNode = new BuilderNode<[Params]>(uiContext);
buttonNode.build(wrapBuilder(buttonBuilder), { text: "This is a Button" });
return buttonNode;
}
export function getOrCreateNode(uiContext: UIContext): BuilderNode<[Params]> | null {
if (buttonNode?.getFrameNode() && buttonNode?.getFrameNode()?.getUniqueId() != -1) {
return buttonNode;
} else {
return createNode(uiContext);
}
}
```
```typescript
// Index.ets
import { FrameNode, NodeController, Size, UIContext } from '@kit.ArkUI'
import { getOrCreateNode } from "./common"
const TEST_TAG: string = "NodeContainer";
class MyNodeController extends NodeController {
private isShow: boolean = false;
constructor(isShow: boolean) {
super();
this.isShow = isShow;
}
makeNode(uiContext: UIContext): FrameNode | null {
if (!this.isShow) {
return null;
}
let frameNode = getOrCreateNode(uiContext)?.getFrameNode();
return frameNode ? frameNode : null;
}
aboutToResize(size: Size) {
console.log(TEST_TAG + " aboutToResize width : " + size.width + " height : " + size.height)
}
aboutToAppear() {
console.log(TEST_TAG + " aboutToAppear")
}
aboutToDisappear() {
console.log(TEST_TAG + " aboutToDisappear");
}
onTouchEvent(event: TouchEvent) {
console.log(TEST_TAG + " onTouchEvent");
}
toShow() {
this.isShow = true;
this.rebuild();
}
toHide() {
this.isShow = false;
this.rebuild();
}
}
@Entry
@Component
struct Index {
private myNodeController1: MyNodeController = new MyNodeController(true);
private myNodeController2: MyNodeController = new MyNodeController(false);
build() {
Column() {
NodeContainer(this.myNodeController1)
.width("100%")
.height("40%")
.backgroundColor(Color.Brown)
NodeContainer(this.myNodeController2)
.width("100%")
.height("40%")
.backgroundColor(Color.Gray)
Button("Change the place of button")
.onClick(() => {
// 先在原始占位节点中下树
// 后在新的占位节点中上树
// 保证自定义节点仅作为一个节点的子节点存在
this.myNodeController1.toHide();
this.myNodeController2.toShow();
})
}
.padding({ left: 35, right: 35, top: 35 })
.width("100%")
.height("100%")
}
}
```
NodeContainer和ContentSlot添加子节点布局差异
NodeContainer是一个容器节点，布局参考默认左上角对齐的Stack组件，不会按照父容器的布局规则进行布局。ContentSlot只是一个语法节点，不参与布局，添加的子节点会按照父容器的布局规则进行布局。
```typescript
import { FrameNode, NodeContent, NodeController, typeNode, UIContext } from '@kit.ArkUI';
class NodeContentCtrl {
content: NodeContent
textNode: Array<typeNode.Text> = new Array();
uiContext: UIContext
width: number
constructor(uiContext: UIContext) {
this.content = new NodeContent()
this.uiContext = uiContext
this.width = Infinity
}
AddNode() {
let node = typeNode.createNode(this.uiContext, "Text")
node.initialize("ContentText:" + this.textNode.length).fontSize(20)
this.textNode.push(node)
this.content.addFrameNode(node)
}
RemoveNode() {
let node = this.textNode.pop()
this.content.removeFrameNode(node)
}
RemoveFront() {
let node = this.textNode.shift()
this.content.removeFrameNode(node)
}
GetContent(): NodeContent {
return this.content
}
}
class MyNodeController extends NodeController {
public rootNode: FrameNode | null = null;
textNode: Array<typeNode.Text> = new Array();
makeNode(uiContext: UIContext): FrameNode {
this.rootNode = new FrameNode(uiContext);
return this.rootNode;
}
AddNode(frameNode: FrameNode | null, uiContext: UIContext) {
let node = typeNode.createNode(uiContext, "Text")
node.initialize("ControllerText:" + this.textNode.length).fontSize(20)
this.textNode.push(node)
frameNode?.appendChild(node)
}
RemoveNode(frameNode: FrameNode | null) {
let node = this.textNode.pop()
frameNode?.removeChild(node)
}
RemoveFront(frameNode: FrameNode | null) {
let node = this.textNode.shift()
frameNode?.removeChild(node)
}
}
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
controller = new NodeContentCtrl(this.getUIContext());
myNodeController = new MyNodeController();
build() {
Row() {
Column() {
ContentSlot(this.controller.GetContent())
Button("AddToSlot")
.onClick(() => {
this.controller.AddNode()
})
.margin(10)
Button("RemoveBack")
.onClick(() => {
this.controller.RemoveNode()
})
.margin(10)
Button("RemoveFront")
.onClick(() => {
this.controller.RemoveFront()
})
.margin(10)
}
.width('50%')
Column() {
NodeContainer(this.myNodeController)
Button("AddToNodeContainer")
.onClick(() => {
this.myNodeController.AddNode(this.myNodeController.rootNode, this.getUIContext())
})
.margin(10)
Button("RemoveBack")
.onClick(() => {
this.myNodeController.RemoveNode(this.myNodeController.rootNode)
})
.margin(10)
Button("RemoveFront")
.onClick(() => {
this.myNodeController.RemoveFront(this.myNodeController.rootNode)
})
.margin(10)
}
.width('50%')
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170318.79223491787271654594417101279930:50001231000000:2800:D0410B7AEC51AAB5DDE1951614C8D2698A5C93B6B41F88BBCD1BB7851ABE7AC1.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-user-defined-arktsnode-framenode-V14
爬取时间: 2025-04-27 23:39:41
来源: Huawei Developer
概述
对于拥有自定义前端的第三方框架（如JSON、XML、DOM树等），需将特定的DSL转换为ArkUI的声明式描述。如下图描述了JSON定义的前端框架和ArkUI声明式描述的对应关系。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170318.95595055712781608700179590671574:50001231000000:2800:AD1787796956F6D571E4920641E3CD8A8E414E196E11B0CF5F9BA6CAFFB44357.png)
上述转换过程需要依赖额外的数据驱动，绑定至Builder中，较为复杂且性能欠佳。这类框架通常依赖于ArkUI的布局、事件处理、基础的节点操作和自定义能力。大部分组件通过自定义实现，但需结合使用部分系统组件以实现混合显示，如下图示例既使用了FrameNode的自定义方法进行绘制，又使用了系统组件Column及其子组件Text，通过BuilderNode的方式将其挂载到根节点的FrameNode上混合显示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170318.92740381402882192456679054267666:50001231000000:2800:7CED52A9B318E3501C60DCC11A162611DCE9A07AA67764E7CC1050641E86D98E.png)
FrameNode的设计初衷正是为了解决上述转换问题。FrameNode表示组件树中的实体节点，与自定义占位容器组件NodeContainer相配合，实现在占位容器内构建一棵自定义的节点树。该节点树支持动态操作，如节点的增加、修改和删除。基础的FrameNode具备设置通用属性和事件回调的功能，同时提供完整的自定义能力，涵盖自定义测量、布局和绘制等方面。
除此之外，ArkUI还提供了获取和遍历系统组件对应代理FrameNode对象的能力（下文简称代理节点）。代理节点能够用于遍历整个UI的树形结构，支持获取系统组件节点的详细信息，以及额外注册组件的事件监听回调。
创建和删除节点
FrameNode提供了节点创建和删除的能力。可以通过FrameNode的构造函数创建自定义FrameNode节点，通过构造函数创建的节点对应一个实体的节点。同时，可以通过FrameNode中的dispose接口来实现与实体节点的绑定关系的解除。
-  在创建FrameNode对象的时候需要传入必选参数UIContext，若未传入UIContext对象或者传入不合法，则节点创建抛出异常。
-  自定义占位组件将节点进行显示的时候需要保证UI上下文一致，否则会出现显示异常。
-  若不持有FrameNode对象，则该对象会在GC的时候被回收。
判断节点是否可修改
isModifiable用于查询当前节点类型是否为系统组件的代理节点。当FrameNode节点作为系统组件的代理节点的时候，该节点不可修改。即无法修改代理节点的自身属性以及其子节点的结构。
获取对应的RenderNode节点
FrameNode提供了getRenderNode接口，用于获取FrameNode中的RenderNode。可以通过对获取到的RenderNode对象进行操作，动态修改FrameNode上绘制相关的属性，具体可修改的属性参考RenderNode的接口。
-  无法获取系统组件代理FrameNode的RenderNode对象。
-  BuilderNode中调用getFrameNode获取得到的FrameNode节点对象中，可以通过getRenderNode获取对应的根节点的RenderNode对象。
操作节点树
FrameNode提供了节点的增、删、查、改的能力，能够修改非代理节点的子树结构。可以对所有FrameNode的节点的父子节点做出查询操作，并返回查询结果。
对节点进行增、删、改操作的时候，会对非法操作抛出异常信息。
通过查询获得的原生组件的代理节点，仅具备查询节点信息的作用，不具备修改节点属性的功能。代理节点不持有组件的实体节点，即不影响对应的节点的生命周期。
查询节点仅查询获得UI相关的节点，不返回语法节点。
使用自定义组件的场景下，可能查询获得自定义组件的新增节点，节点类型为“__Common__”。
```typescript
import { BuilderNode, FrameNode, NodeController, UIContext } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
const TEST_TAG: string = "FrameNode"
class Params {
text: string = "this is a text"
}
@Builder
function buttonBuilder(params: Params) {
Column({ space: 10 }) {
Button(params.text)
.fontSize(12)
.borderRadius(8)
.borderWidth(2)
.backgroundColor(Color.Orange)
Button(params.text)
.fontSize(12)
.borderRadius(8)
.borderWidth(2)
.backgroundColor(Color.Pink)
}
}
class MyNodeController extends NodeController {
public buttonNode: BuilderNode<[Params]> | null = null;
public frameNode: FrameNode | null = null;
public childList: Array<FrameNode> = new Array<FrameNode>();
public rootNode: FrameNode | null = null;
private uiContext: UIContext | null = null;
private wrapBuilder: WrappedBuilder<[Params]> = wrapBuilder(buttonBuilder);
makeNode(uiContext: UIContext): FrameNode | null {
this.uiContext = uiContext;
if (this.rootNode == null) {
this.rootNode = new FrameNode(uiContext);
this.rootNode.commonAttribute
.width("50%")
.height(100)
.borderWidth(1)
.backgroundColor(Color.Gray)
}
if (this.frameNode == null) {
this.frameNode = new FrameNode(uiContext);
this.frameNode.commonAttribute
.width("100%")
.height(50)
.borderWidth(1)
.position({ x: 200, y: 0 })
.backgroundColor(Color.Pink);
this.rootNode.appendChild(this.frameNode);
}
if (this.buttonNode == null) {
this.buttonNode = new BuilderNode<[Params]>(uiContext);
this.buttonNode.build(this.wrapBuilder, { text: "This is a Button" })
this.rootNode.appendChild(this.buttonNode.getFrameNode())
}
return this.rootNode;
}
operationFrameNodeWithFrameNode(frameNode: FrameNode | undefined | null) {
if (frameNode) {
console.log(TEST_TAG + " get ArkTSNode success.")
console.log(TEST_TAG + " check rootNode whether is modifiable " + frameNode.isModifiable());
}
if (this.uiContext) {
let frameNode1 = new FrameNode(this.uiContext);
let frameNode2 = new FrameNode(this.uiContext);
frameNode1.commonAttribute.size({ width: 50, height: 50 })
.backgroundColor(Color.Black)
.position({ x: 50, y: 60 })
frameNode2.commonAttribute.size({ width: 50, height: 50 })
.backgroundColor(Color.Orange)
.position({ x: 120, y: 60 })
try {
frameNode?.appendChild(frameNode1);
console.log(TEST_TAG + " appendChild success ");
} catch (err) {
console.log(TEST_TAG + " appendChild fail :" + (err as BusinessError).code + " : " +
(err as BusinessError).message);
}
try {
frameNode?.insertChildAfter(frameNode2, null);
console.log(TEST_TAG + " insertChildAfter success ");
} catch (err) {
console.log(TEST_TAG + " insertChildAfter fail : " + (err as BusinessError).code + " : " +
(err as BusinessError).message);
}
setTimeout(() => {
try {
frameNode?.removeChild(frameNode?.getChild(0))
console.log(TEST_TAG + " removeChild success ");
} catch (err) {
console.log(TEST_TAG + " removeChild fail : " + (err as BusinessError).code + " : " +
(err as BusinessError).message);
}
}, 2000)
setTimeout(() => {
try {
frameNode?.clearChildren();
console.log(TEST_TAG + " clearChildren success ");
} catch (err) {
console.log(TEST_TAG + " clearChildren fail : " + (err as BusinessError).code + " : " +
(err as BusinessError).message);
}
}, 4000)
}
}
testInterfaceAboutSearch(frameNode: FrameNode | undefined | null): string {
let result: string = "";
if (frameNode) {
result = result + `current node is ${frameNode.getNodeType()} \n`;
result = result + `parent node is ${frameNode.getParent()?.getNodeType()} \n`;
result = result + `child count is ${frameNode.getChildrenCount()} \n`;
result = result + `first child node is ${frameNode.getFirstChild()?.getNodeType()} \n`;
result = result + `second child node is ${frameNode.getChild(1)?.getNodeType()} \n`;
result = result + `previousSibling node is ${frameNode.getPreviousSibling()?.getNodeType()} \n`;
result = result + `nextSibling node is ${frameNode.getNextSibling()?.getNodeType()} \n`;
}
return result;
}
checkAppendChild(parent: FrameNode | undefined | null, child: FrameNode | undefined | null) {
try {
if (parent && child) {
parent.appendChild(child);
console.log(TEST_TAG + " appendChild success ");
}
} catch (err) {
console.log(TEST_TAG + " appendChild fail : " + (err as BusinessError).code + " : " +
(err as BusinessError).message);
}
}
}
@Entry
@Component
struct Index {
@State index: number = 0;
@State result: string = ""
private myNodeController: MyNodeController = new MyNodeController();
build() {
Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.SpaceBetween }) {
List({ space: 20, initialIndex: 0 }) {
ListItem() {
Column({ space: 5 }) {
Text("验证FrameNode子节点的增、删、改功能")
Button("对自定义FrameNode进行操作")
.fontSize(16)
.width(400)
.onClick(() => {
// 对FrameNode节点进行增、删、改操作，正常实现。
this.myNodeController.operationFrameNodeWithFrameNode(this.myNodeController?.frameNode);
})
Button("对BuilderNode中的代理节点进行操作")
.fontSize(16)
.width(400)
.onClick(() => {
// 对BuilderNode代理节点进行增、删、改操作，捕获异常信息。
this.myNodeController.operationFrameNodeWithFrameNode(this.myNodeController?.buttonNode?.getFrameNode());
})
Button("对原生组件中的代理节点进行操作")
.fontSize(16)
.width(400)
.onClick(() => {
// 对代理节点进行增、删、改操作，捕获异常信息。
this.myNodeController.operationFrameNodeWithFrameNode(this.myNodeController?.rootNode?.getParent());
})
}
}
ListItem() {
Column({ space: 5 }) {
Text("验证FrameNode添加子节点的特殊场景")
Button("新增BuilderNode的代理节点")
.fontSize(16)
.width(400)
.onClick(() => {
let buttonNode = new BuilderNode<[Params]>(this.getUIContext());
buttonNode.build(wrapBuilder<[Params]>(buttonBuilder), { text: "BUTTON" })
this.myNodeController.checkAppendChild(this.myNodeController?.frameNode, buttonNode?.getFrameNode());
})
Button("新增原生组件代理节点")
.fontSize(16)
.width(400)
.onClick(() => {
this.myNodeController.checkAppendChild(this.myNodeController?.frameNode,
this.myNodeController?.rootNode?.getParent());
})
Button("新增已有父节点的自定义节点")
.fontSize(16)
.width(400)
.onClick(() => {
this.myNodeController.checkAppendChild(this.myNodeController?.frameNode,
this.myNodeController?.rootNode);
})
}
}
ListItem() {
Column({ space: 5 }) {
Text("验证FrameNode节点的查询功能")
Button("对自定义FrameNode进行操作")
.fontSize(16)
.width(400)
.onClick(() => {
// 对FrameNode节点进行进行查询。当前节点为NodeContainer的子节点。
this.result = this.myNodeController.testInterfaceAboutSearch(this.myNodeController?.rootNode);
setTimeout(() => {
// 对FrameNode节点进行进行查询。rootNode下的第一个子节点。
this.result = this.myNodeController.testInterfaceAboutSearch(this.myNodeController?.frameNode);
}, 2000)
})
Button("对BuilderNode中的代理节点进行操作")
.fontSize(16)
.width(400)
.onClick(() => {
// 对BuilderNode代理节点进行进行查询。当前节点为BuilderNode中的Column节点。
this.result =
this.myNodeController.testInterfaceAboutSearch(this.myNodeController?.buttonNode?.getFrameNode());
})
Button("对原生组件中的代理节点进行操作")
.fontSize(16)
.width(400)
.onClick(() => {
// 对代理节点进行查询。当前节点为NodeContainer。
this.result =
this.myNodeController.testInterfaceAboutSearch(this.myNodeController?.rootNode?.getParent());
})
}
}
}.height("50%")
Text(`Result：\n${this.result}`)
.fontSize(16)
.width(400)
.height(200)
.padding(30)
.borderWidth(1)
Column() {
Text("This is a NodeContainer.")
.textAlign(TextAlign.Center)
.borderRadius(10)
.backgroundColor(0xFFFFFF)
.width('100%')
.fontSize(16)
NodeContainer(this.myNodeController)
.borderWidth(1)
.width(400)
.height(150)
}
}
.padding({
left: 35,
right: 35,
top: 35,
bottom: 35
})
.width("100%")
.height("100%")
}
}
```
设置节点通用属性和事件回调
FrameNode提供了commonAttribute和commonEvent两个对象用于设置节点的通用属性和设置事件回调。
-  由于代理节点的属性不可修改，因此通过代理节点的commonAttribute修改节点的基础属性不生效。
-  设置的基础事件与原生组件定义的事件平行，参与事件竞争。设置的基础事件不覆盖原生组件事件。同时设置两个事件回调的时候，优先回调原生组件事件。
```typescript
import { BuilderNode, FrameNode, NodeController, UIContext } from '@kit.ArkUI'
class Params {
text: string = "this is a text"
}
@Builder
function buttonBuilder(params: Params) {
Button(params.text)
.fontSize(12)
.borderRadius(8)
.borderWidth(2)
.backgroundColor(Color.Orange)
.onClick((event: ClickEvent) => {
console.log(`Button ${JSON.stringify(event)}`);
})
}
class MyNodeController extends NodeController {
public buttonNode: BuilderNode<[Params]> | null = null;
public frameNode: FrameNode | null = null;
public rootNode: FrameNode | null = null;
private wrapBuilder: WrappedBuilder<[Params]> = wrapBuilder(buttonBuilder);
makeNode(uiContext: UIContext): FrameNode | null {
if (this.rootNode == null) {
this.rootNode = new FrameNode(uiContext);
// 对rootNode进行属性修改，该节点为自定义的FrameNode节点，修改生效
this.rootNode.commonAttribute
.width("100%")
.height(100)
.borderWidth(1)
.backgroundColor(Color.Gray)
}
if (this.frameNode == null) {
this.frameNode = new FrameNode(uiContext);
// 对frameNode进行属性修改，该节点为自定义的FrameNode节点，修改生效
this.frameNode.commonAttribute
.width("50%")
.height(50)
.borderWidth(1)
.backgroundColor(Color.Pink);
this.rootNode.appendChild(this.frameNode);
}
if (this.buttonNode == null) {
this.buttonNode = new BuilderNode<[Params]>(uiContext);
this.buttonNode.build(this.wrapBuilder, { text: "This is a Button" })
// 对BuilderNode中获取的FrameNode进行属性修改，该节点非自定义的FrameNode节点，修改不生效
this.buttonNode?.getFrameNode()?.commonAttribute.position({ x: 100, y: 100 })
this.rootNode.appendChild(this.buttonNode.getFrameNode())
}
return this.rootNode;
}
modifyNode(frameNode: FrameNode | null | undefined, sizeValue: SizeOptions, positionValue: Position) {
if (frameNode) {
frameNode.commonAttribute.size(sizeValue).position(positionValue);
}
}
addClickEvent(frameNode: FrameNode | null | undefined) {
if (frameNode) {
frameNode.commonEvent.setOnClick((event: ClickEvent) => {
console.log(`FrameNode ${JSON.stringify(event)}`);
})
}
}
}
@Entry
@Component
struct Index {
private myNodeController: MyNodeController = new MyNodeController();
build() {
Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.SpaceBetween }) {
Column({ space: 10 }) {
Text("修改节点通用属性-宽高")
Button("modify ArkTS-FrameNode")
.onClick(() => {
// 获取到的是当前页面中的开发者创建的FrameNode对象，该节点可修改。即节点大小与位置。
console.log("Check the weather the node can be modified " + this.myNodeController?.frameNode
?.isModifiable());
this.myNodeController.modifyNode(this.myNodeController?.frameNode, { width: 150, height: 100 }, {
x: 100,
y: 0
})
})
Button("modify FrameNode get by BuilderNode")
.onClick(() => {
// 获取到的是当前页面中的BuilderNode的根节点，该节点不可修改。即节点大小与位置未发生改变。
console.log("Check the weather the node can be modified " +
this.myNodeController?.buttonNode?.getFrameNode()
?.isModifiable());
this.myNodeController.modifyNode(this.myNodeController?.buttonNode?.getFrameNode(), {
width: 100,
height: 100
}, { x: 50, y: 50 })
})
Button("modify proxyFrameNode get by search")
.onClick(() => {
// rootNode调用getParent()获取到的是当前页面中的NodeContainer节点，该节点不可修改。即节点大小与位置未发生改变。
console.log("Check the weather the node can be modified " + this.myNodeController?.rootNode?.getParent()
?.isModifiable());
this.myNodeController.modifyNode(this.myNodeController?.rootNode?.getParent(), {
width: 500,
height: 500
}, {
x: 0,
y: 0
})
})
}
.padding({
left: 35,
right: 35,
top: 35,
bottom: 35
})
Column({ space: 10 }) {
Text("修改节点点击事件")
Button("add click event to ArkTS-FrameNode")
.onClick(() => {
// 获取到的是当前页面中的开发者创建的FrameNode对象，该节点可增加点击事件。
// 增加的点击事件参与事件竞争，即点击事件会在该节点被消费且不不再向父组件冒泡。
console.log("Check the weather the node can be modified " + this.myNodeController?.rootNode?.getParent()
?.isModifiable());
this.myNodeController.addClickEvent(this.myNodeController?.frameNode)
})
Button("add click event to FrameNode get by BuilderNode")
.onClick(() => {
// 获取到的是当前页面中的BuilderNode的根节点，该类节点可增加点击事件。
// 点击的时候优先回调通过原生组件接口设置的click事件回调，然后回调通过commonEvent增加的click监听。
console.log("Check the weather the node can be modified " +
this.myNodeController?.buttonNode?.getFrameNode()
?.isModifiable());
this.myNodeController.addClickEvent(this.myNodeController?.buttonNode?.getFrameNode())
})
Button("add click event to proxyFrameNode get by search")
.onClick(() => {
// rootNode调用getParent()获取到的是当前页面中的NodeContainer节点，该类节点可增加点击事件。
console.log("Check the weather the node can be modified " + this.myNodeController?.rootNode?.getParent()
?.isModifiable());
this.myNodeController.addClickEvent(this.myNodeController?.rootNode?.getParent());
})
}
.padding({
left: 35,
right: 35,
top: 35,
bottom: 35
})
NodeContainer(this.myNodeController)
.borderWidth(1)
.width("100%")
.height(100)
.onClick((event: ClickEvent) => {
console.log(`NodeContainer ${JSON.stringify(event)}`);
})
}
.padding({
left: 35,
right: 35,
top: 35,
bottom: 35
})
.width("100%")
.height("100%")
}
}
```
自定义测量布局与绘制
通过重写onDraw方法，可以自定义FrameNode的绘制内容。invalidate接口可以主动触发节点的重新绘制。
通过重写onMeasure可以自定义FrameNode的测量方式，使用measure可以主动传递布局约束触发重新测量。
通过重写onLayout方法可以自定义FrameNode的布局方式，使用layout方法可以主动传递位置信息并触发重新布局。
setNeedsLayout可以将当前节点标记，在下一帧触发重新布局。
-  对节点进行dispose解引用后，由于FrameNode对象不再对应一个实体节点，invalidate无法触发原有绑定节点的刷新。
-  通过onDraw方法进行的自定义绘制，绘制内容大小无法超出组件大小。
```typescript
import { DrawContext, FrameNode, NodeController, Position, Size, UIContext, LayoutConstraint } from '@kit.ArkUI';
import { drawing } from '@kit.ArkGraphics2D';
function GetChildLayoutConstraint(constraint: LayoutConstraint, child: FrameNode): LayoutConstraint {
const size = child.getUserConfigSize();
const width = Math.max(
Math.min(constraint.maxSize.width, size.width.value),
constraint.minSize.width
);
const height = Math.max(
Math.min(constraint.maxSize.height, size.height.value),
constraint.minSize.height
);
const finalSize: Size = { width, height };
const res: LayoutConstraint = {
maxSize: finalSize,
minSize: finalSize,
percentReference: finalSize
};
return res;
}
class MyFrameNode extends FrameNode {
public width: number = 100;
public offsetY: number = 0;
private space: number = 1;
onMeasure(constraint: LayoutConstraint): void {
let sizeRes: Size = { width: vp2px(100), height: vp2px(100) };
for (let i = 0; i < this.getChildrenCount(); i++) {
let child = this.getChild(i);
if (child) {
let childConstraint = GetChildLayoutConstraint(constraint, child);
child.measure(childConstraint);
let size = child.getMeasuredSize();
sizeRes.height += size.height + this.space;
sizeRes.width = Math.max(sizeRes.width, size.width);
}
}
this.setMeasuredSize(sizeRes);
}
onLayout(position: Position): void {
for (let i = 0; i < this.getChildrenCount(); i++) {
let child = this.getChild(i);
if (child) {
child.layout({
x: vp2px(100),
y: vp2px(this.offsetY)
});
let layoutPosition = child.getLayoutPosition();
console.log("child position:" + JSON.stringify(layoutPosition));
}
}
this.setLayoutPosition(position);
}
onDraw(context: DrawContext) {
const canvas = context.canvas;
const pen = new drawing.Pen();
pen.setStrokeWidth(15);
pen.setColor({
alpha: 255,
red: 255,
green: 0,
blue: 0
});
canvas.attachPen(pen);
canvas.drawRect({
left: 50,
right: this.width + 50,
top: 50,
bottom: this.width + 50,
});
canvas.detachPen();
}
addWidth() {
this.width = (this.width + 10) % 50 + 100;
}
}
class MyNodeController extends NodeController {
public rootNode: MyFrameNode | null = null;
makeNode(context: UIContext): FrameNode | null {
this.rootNode = new MyFrameNode(context);
this.rootNode?.commonAttribute?.size({ width: 100, height: 100 }).backgroundColor(Color.Green);
let frameNode: FrameNode = new FrameNode(context);
this.rootNode.appendChild(frameNode);
frameNode.commonAttribute.width(10).height(10).backgroundColor(Color.Pink);
return this.rootNode;
}
}
@Entry
@Component
struct Index {
private nodeController: MyNodeController = new MyNodeController();
build() {
Row() {
Column() {
NodeContainer(this.nodeController)
.width('100%')
.height(200)
.backgroundColor('#FFF0F0F0')
Button('Invalidate')
.margin(10)
.onClick(() => {
this.nodeController?.rootNode?.addWidth();
this.nodeController?.rootNode?.invalidate();
})
Button('UpdateLayout')
.onClick(() => {
let node = this.nodeController.rootNode;
node!.offsetY = (node!.offsetY + 10) % 110;
this.nodeController?.rootNode?.setNeedsLayout();
})
}
.width('100%')
.height('100%')
}
.height('100%')
}
}
```
查找节点及获取基础信息
FrameNode提供了查询接口用于返回实体节点的基础信息。具体返回的信息内容参考FrameNode中提供的接口。
查找获得FrameNode的方式包括三种：
1.  使用getFrameNodeById获取。
2.  使用getFrameNodeByUniqueId获取。
3.  通过无感监听获取。
1、当前接口提供的可查询的信息包括：
-  节点大小：getMeasuredSize，getUserConfigSize
-  布局信息：getPositionToWindow，getPositionToParent，getLayoutPosition，getUserConfigBorderWidth，getUserConfigPadding，getUserConfigMargin
-  节点信息：getId，getUniqueId，getNodeType，getOpacity，isVisible，isClipToFrame，isAttached，getInspectorInfo，getCustomProperty
2、无法获取UINode类型节点，例如：JsView节点、Span、ContainerSpan、ContentSlot、ForEach、LazyForEach、if/else组件等。
获取节点位置偏移信息
FrameNode提供了查询节点相对窗口、父组件以及屏幕位置偏移的信息接口（getPositionToWindow，getPositionToParent，getPositionToScreen，getPositionToWindowWithTransform，getPositionToParentWithTransform，getPositionToScreenWithTransform，getLayoutPosition，getUserConfigBorderWidth，getUserConfigPadding，getUserConfigMargin）。
```typescript
import { NodeController, FrameNode, UIContext } from '@kit.ArkUI';
const TEST_TAG: string = "FrameNode"
class MyNodeController extends NodeController {
public frameNode: FrameNode | null = null;
private rootNode: FrameNode | null = null;
makeNode(uiContext: UIContext): FrameNode | null {
this.rootNode = new FrameNode(uiContext);
this.frameNode = new FrameNode(uiContext);
this.rootNode.appendChild(this.frameNode);
return this.rootNode;
}
getPositionToWindow() {
let positionToWindow = this.rootNode?.getPositionToWindow(); // 获取FrameNode相对于窗口的位置偏移
console.log(`${TEST_TAG} ${JSON.stringify(positionToWindow)}`);
}
getPositionToParent() {
let positionToParent = this.rootNode?.getPositionToParent(); // 获取FrameNode相对于父组件的位置偏移
console.log(`${TEST_TAG} ${JSON.stringify(positionToParent)}`);
}
getPositionToScreen() {
let positionToScreen = this.rootNode?.getPositionToScreen(); // 获取FrameNode相对于屏幕的位置偏移
console.log(`${TEST_TAG} ${JSON.stringify(positionToScreen)}`);
}
getPositionToWindowWithTransform() {
let positionToWindowWithTransform =
this.rootNode?.getPositionToWindowWithTransform(); // 获取FrameNode相对于窗口带有绘制属性的位置偏移
console.log(`${TEST_TAG} ${JSON.stringify(positionToWindowWithTransform)}`);
}
getPositionToParentWithTransform() {
let positionToParentWithTransform =
this.rootNode?.getPositionToParentWithTransform(); // 获取FrameNode相对于父组件带有绘制属性的位置偏移
console.log(`${TEST_TAG} ${JSON.stringify(positionToParentWithTransform)}`);
}
getPositionToScreenWithTransform() {
let positionToScreenWithTransform =
this.rootNode?.getPositionToScreenWithTransform(); // 获取FrameNode相对于屏幕带有绘制属性的位置偏移
console.log(`${TEST_TAG} ${JSON.stringify(positionToScreenWithTransform)}`);
}
}
@Entry
@Component
struct Index {
private myNodeController: MyNodeController = new MyNodeController();
build() {
Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.SpaceBetween }) {
Button("getPositionToWindow")
.width(300)
.onClick(() => {
this.myNodeController.getPositionToWindow();
})
Button("getPositionToParent")
.width(300)
.onClick(() => {
this.myNodeController.getPositionToParent();
})
Button("getPositionToScreen")
.width(300)
.onClick(() => {
this.myNodeController.getPositionToScreen();
})
Button("getPositionToParentWithTransform")
.width(300)
.onClick(() => {
this.myNodeController.getPositionToParentWithTransform();
})
Button("getPositionToWindowWithTransform")
.width(300)
.onClick(() => {
this.myNodeController.getPositionToWindowWithTransform();
})
Button("getPositionToScreenWithTransform")
.width(300)
.onClick(() => {
this.myNodeController.getPositionToScreenWithTransform();
})
Column() {
Text("This is a NodeContainer.")
.textAlign(TextAlign.Center)
.borderRadius(10)
.backgroundColor(0xFFFFFF)
.width('100%')
.fontSize(16)
NodeContainer(this.myNodeController)
.borderWidth(1)
.width(300)
.height(100)
}
}
.padding({
left: 35,
right: 35,
top: 35,
bottom: 35
})
.width("100%")
.height("100%")
}
}
```
通过typeNode创建具体类型的FrameNode节点
通过TypeNode创建具体类型的FrameNode节点，可以根据属性获取接口来检索用户设置的属性信息。
```typescript
import { NodeController, FrameNode, UIContext, BuilderNode, typeNode } from '@kit.ArkUI';
class Params {
text: string = "";
constructor(text: string) {
this.text = text;
}
}
@Builder
function buildText(params: Params) {
Column() {
Text(params.text)
.id("buildText")
.border({ width: 1 })
.padding(1)
.fontSize(25)
.fontWeight(FontWeight.Bold)
.margin({ top: 10 })
.visibility(Visibility.Visible)
.opacity(0.7)
.customProperty("key1", "value1")
.width(300)
}
}
const TEST_TAG: string = "FrameNode"
class MyNodeController extends NodeController {
public frameNode: typeNode.Column | null = null;
public uiContext: UIContext | undefined = undefined;
private rootNode: FrameNode | null = null;
private textNode: BuilderNode<[Params]> | null = null;
public textTypeNode: typeNode.Text | null = null;
private message: string = "DEFAULT";
makeNode(uiContext: UIContext): FrameNode | null {
this.rootNode = new FrameNode(uiContext);
this.uiContext = uiContext;
this.frameNode = typeNode.createNode(uiContext, "Column");
this.frameNode.attribute
.width("100%")
.height("100%")
this.rootNode.appendChild(this.frameNode);
this.textNode = new BuilderNode(uiContext);
this.textNode.build(wrapBuilder<[Params]>(buildText), new Params(this.message));
this.frameNode.appendChild(this.textNode.getFrameNode());
this.textTypeNode = typeNode.createNode(uiContext, "Text");
this.textTypeNode.initialize("textTypeNode")
.fontSize(25)
.visibility(Visibility.Visible)
.id("textTypeNode")
this.frameNode.appendChild(this.textTypeNode);
return this.rootNode;
}
removeChild(frameNode: FrameNode) {
let parent = frameNode.getParent();
if (parent) {
parent.removeChild(frameNode);
}
}
getUserConfigBorderWidth(frameNode: FrameNode) {
let userConfigBorderWidth = frameNode?.getUserConfigBorderWidth(); // 获取用户设置的边框宽度
console.log(`${TEST_TAG} ${JSON.stringify(userConfigBorderWidth)}`);
}
getUserConfigPadding(frameNode: FrameNode) {
let userConfigPadding = frameNode?.getUserConfigPadding(); // 获取用户设置的内边距
console.log(`${TEST_TAG} ${JSON.stringify(userConfigPadding)}`);
}
getUserConfigMargin(frameNode: FrameNode) {
let userConfigMargin = frameNode?.getUserConfigMargin(); // 获取用户设置的外边距
console.log(`${TEST_TAG} ${JSON.stringify(userConfigMargin)}`);
}
getUserConfigSize(frameNode: FrameNode) {
let userConfigSize = frameNode?.getUserConfigSize(); // 获取用户设置的宽高
console.log(`${TEST_TAG} ${JSON.stringify(userConfigSize)}`);
}
getId(frameNode: FrameNode) {
let id = frameNode?.getId(); // 获取用户设置的节点ID
console.log(`${TEST_TAG} ${id}`);
}
getUniqueId(frameNode: FrameNode) {
let uniqueId = frameNode?.getUniqueId(); // 获取系统分配的唯一标识的节点UniqueID
console.log(`${TEST_TAG} ${uniqueId}`);
}
getNodeType(frameNode: FrameNode) {
let nodeType = frameNode?.getNodeType(); // 获取节点的类型
console.log(`${TEST_TAG} ${nodeType}`);
}
getOpacity(frameNode: FrameNode) {
let opacity = frameNode?.getOpacity(); // 获取节点的不透明度
console.log(`${TEST_TAG} ${JSON.stringify(opacity)}`);
}
isVisible(frameNode: FrameNode) {
let visible = frameNode?.isVisible(); // 获取节点是否可见
console.log(`${TEST_TAG} ${JSON.stringify(visible)}`);
}
isClipToFrame(frameNode: FrameNode) {
let clipToFrame = frameNode?.isClipToFrame(); // 获取节点是否是剪裁到组件区域
console.log(`${TEST_TAG} ${JSON.stringify(clipToFrame)}`);
}
isAttached(frameNode: FrameNode) {
let attached = frameNode?.isAttached(); // 获取节点是否被挂载到主节点树上
console.log(`${TEST_TAG} ${JSON.stringify(attached)}`);
}
getInspectorInfo(frameNode: FrameNode) {
let inspectorInfo = frameNode?.getInspectorInfo(); // 获取节点的结构信息
console.log(`${TEST_TAG} ${JSON.stringify(inspectorInfo)}`);
}
}
@Entry
@Component
struct Index {
private myNodeController: MyNodeController = new MyNodeController();
@State index: number = 0;
build() {
Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.SpaceBetween }) {
Column() {
Text("This is a NodeContainer.")
.textAlign(TextAlign.Center)
.borderRadius(10)
.backgroundColor(0xFFFFFF)
.width('100%')
.fontSize(16)
NodeContainer(this.myNodeController)
.borderWidth(1)
.width(300)
.height(100)
}
Button("getUserConfigBorderWidth")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("buildText") || null;
if (node) {
this.myNodeController.getUserConfigBorderWidth(node);
}
}
})
Button("getUserConfigPadding")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("buildText") || null;
if (node) {
this.myNodeController.getUserConfigPadding(node);
}
}
})
Button("getUserConfigMargin")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("buildText") || null;
if (node) {
this.myNodeController.getUserConfigMargin(node);
}
}
})
Button("getUserConfigSize")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("buildText") || null;
if (node) {
this.myNodeController.getUserConfigSize(node);
}
}
})
Button("getId")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("buildText") || null;
if (node) {
this.myNodeController.getId(node);
}
}
})
Button("getUniqueId")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("buildText") || null;
if (node) {
this.myNodeController.getUniqueId(node);
}
}
})
Button("getNodeType")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("buildText") || null;
if (node) {
this.myNodeController.getNodeType(node);
}
}
})
Button("getOpacity")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("buildText") || null;
if (node) {
this.myNodeController.getOpacity(node);
}
}
})
Button("isVisible")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("buildText") || null;
if (node) {
this.myNodeController.isVisible(node);
}
}
})
Button("isClipToFrame")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("buildText") || null;
if (node) {
this.myNodeController.isClipToFrame(node);
}
}
})
Button("isAttached")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("buildText") || null;
if (node) {
this.myNodeController.isAttached(node);
}
}
})
Button("remove Text")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("textTypeNode") || null;
if (node) {
this.myNodeController.removeChild(node);
this.myNodeController.isAttached(node);
}
}
})
Button("getInspectorInfo")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("buildText") || null;
if (node) {
this.myNodeController.getInspectorInfo(node);
}
}
})
Button("getCustomProperty")
.width(300)
.onClick(() => {
const uiContext: UIContext = this.getUIContext();
if (uiContext) {
const node: FrameNode | null = uiContext.getFrameNodeById("buildText") || null;
if (node) {
const property = node.getCustomProperty("key1");
console.log(TEST_TAG, JSON.stringify(property));
}
}
})
}
.padding({
left: 35,
right: 35,
top: 35,
bottom: 35
})
.width("100%")
.height("100%")
}
}
```
解除当前FrameNode对象对实体FrameNode节点的引用关系
使用dispose接口可以立即解除当前FrameNode对象对实体FrameNode节点的引用关系。
在调用dispose方法后，FrameNode对象不再对应任何实际的FrameNode节点。此时，若尝试调用以下查询接口：getMeasuredSize、getLayoutPosition、getUserConfigBorderWidth、getUserConfigPadding、getUserConfigMargin、getUserConfigSize，将导致应用程序触发jscrash。
通过getUniqueId可以判断当前FrameNode是否对应一个实体FrameNode节点。当UniqueId大于0时表示该对象对应一个实体FrameNode节点。
```typescript
import { NodeController, FrameNode, BuilderNode } from '@kit.ArkUI';
const TEST_TAG: string = "FrameNode";
@Component
struct TestComponent {
build() {
Column() {
Text('This is a BuilderNode.')
.fontSize(16)
.fontWeight(FontWeight.Bold)
}
.width('100%')
.backgroundColor(Color.Gray)
}
aboutToAppear() {
console.error(TEST_TAG + ' aboutToAppear');
}
aboutToDisappear() {
console.error(TEST_TAG + ' aboutToDisappear');
}
}
@Builder
function buildComponent() {
TestComponent()
}
class MyNodeController extends NodeController {
private rootNode: FrameNode | null = null;
private builderNode: BuilderNode<[]> | null = null;
makeNode(uiContext: UIContext): FrameNode | null {
this.rootNode = new FrameNode(uiContext);
this.builderNode = new BuilderNode(uiContext, { selfIdealSize: { width: 200, height: 100 } });
this.builderNode.build(new WrappedBuilder(buildComponent));
const rootRenderNode = this.rootNode.getRenderNode();
if (rootRenderNode !== null) {
rootRenderNode.size = { width: 200, height: 200 };
rootRenderNode.backgroundColor = 0xff00ff00;
rootRenderNode.appendChild(this.builderNode!.getFrameNode()!.getRenderNode());
}
return this.rootNode;
}
printUniqueId(): void {
if (this.rootNode !== null && this.builderNode !== null) {
console.log(`${TEST_TAG} rootNode's uniqueId: ${this.rootNode.getUniqueId()}`);
const frameNode = this.builderNode.getFrameNode();
if (frameNode) {
console.log(`${TEST_TAG} the uniqueId of builderNode's framenode: ${frameNode.getUniqueId()}`);
} else {
console.log(`${TEST_TAG} builderNode's framenode is undefined`);
}
}
}
disposeFrameNode(): void {
if (this.rootNode !== null && this.builderNode !== null) {
console.log(`${TEST_TAG} disposeFrameNode`);
this.rootNode.removeChild(this.builderNode.getFrameNode());
this.builderNode.dispose();
this.rootNode.dispose();
}
}
removeBuilderNode(): void {
const rootRenderNode = this.rootNode!.getRenderNode();
if (rootRenderNode !== null && this.builderNode !== null && this.builderNode.getFrameNode() !== null) {
rootRenderNode.removeChild(this.builderNode!.getFrameNode()!.getRenderNode());
}
}
}
@Entry
@Component
struct Index {
private myNodeController: MyNodeController = new MyNodeController();
build() {
Column({ space: 4 }) {
NodeContainer(this.myNodeController)
Button('FrameNode dispose')
.onClick(() => {
this.myNodeController.printUniqueId();
this.myNodeController.disposeFrameNode();
this.myNodeController.printUniqueId();
})
.width('100%')
}
}
}
```
FrameNode的数据懒加载能力
提供NodeAdapter对象替代ArkTS侧的LazyForEach功能，提供自定义节点的数据懒加载功能，实现按需迭代数据。
入参不能为负数，入参为负数时不做处理。
```typescript
import { FrameNode, NodeController, NodeAdapter, typeNode } from '@kit.ArkUI';
const TEST_TAG: string = "FrameNode";
class MyNodeAdapter extends NodeAdapter {
uiContext: UIContext
cachePool: Array<FrameNode> = new Array();
changed: boolean = false
reloadTimes: number = 0;
data: Array<string> = new Array();
hostNode?: FrameNode
constructor(uiContext: UIContext, count: number) {
super();
this.uiContext = uiContext;
this.totalNodeCount = count;
this.loadData();
}
reloadData(count: number): void {
this.reloadTimes++;
NodeAdapter.attachNodeAdapter(this, this.hostNode);
this.totalNodeCount = count;
this.loadData();
this.reloadAllItems();
}
refreshData(): void {
let items = this.getAllAvailableItems()
console.log(TEST_TAG + " get All items:" + items.length);
this.totalNodeCount -= 1;
this.reloadAllItems();
}
detachData(): void {
NodeAdapter.detachNodeAdapter(this.hostNode);
this.reloadTimes = 0;
}
loadData(): void {
for (let i = 0; i < this.totalNodeCount; i++) {
this.data[i] = "Adapter ListItem " + i + " r:" + this.reloadTimes;
}
}
changeData(from: number, count: number): void {
this.changed = !this.changed;
for (let i = 0; i < count; i++) {
let index = i + from;
this.data[index] = "Adapter ListItem " + (this.changed ? "changed:" : "") + index + " r:" + this.reloadTimes;
}
this.reloadItem(from, count);
}
insertData(from: number, count: number): void {
for (let i = 0; i < count; i++) {
let index = i + from;
this.data.splice(index, 0, "Adapter ListItem " + from + "-" + i);
}
this.insertItem(from, count);
this.totalNodeCount += count;
console.log(TEST_TAG + " after insert count:" + this.totalNodeCount);
}
removeData(from: number, count: number): void {
let arr = this.data.splice(from, count);
this.removeItem(from, count);
this.totalNodeCount -= arr.length;
console.log(TEST_TAG + " after remove count:" + this.totalNodeCount);
}
moveData(from: number, to: number): void {
let tmp = this.data.splice(from, 1);
this.data.splice(to, 0, tmp[0]);
this.moveItem(from, to);
}
onAttachToNode(target: FrameNode): void {
console.log(TEST_TAG + " onAttachToNode id:" + target.getUniqueId());
this.hostNode = target;
}
onDetachFromNode(): void {
console.log(TEST_TAG + " onDetachFromNode");
}
onGetChildId(index: number): number {
console.log(TEST_TAG + " onGetChildId:" + index);
return index;
}
onCreateChild(index: number): FrameNode {
console.log(TEST_TAG + " onCreateChild:" + index);
if (this.cachePool.length > 0) {
let cacheNode = this.cachePool.pop();
if (cacheNode !== undefined) {
console.log(TEST_TAG + " onCreateChild reused id:" + cacheNode.getUniqueId());
let text = cacheNode?.getFirstChild();
let textNode = text as typeNode.Text;
textNode?.initialize(this.data[index]).fontSize(20);
return cacheNode;
}
}
console.log(TEST_TAG + " onCreateChild createNew");
let itemNode = typeNode.createNode(this.uiContext, "ListItem");
let textNode = typeNode.createNode(this.uiContext, "Text");
textNode.initialize(this.data[index]).fontSize(20);
itemNode.appendChild(textNode);
return itemNode;
}
onDisposeChild(id: number, node: FrameNode): void {
console.log(TEST_TAG + " onDisposeChild:" + id);
if (this.cachePool.length < 10) {
if (!this.cachePool.includes(node)) {
console.log(TEST_TAG + " caching node id:" + node.getUniqueId());
this.cachePool.push(node);
}
} else {
node.dispose();
}
}
onUpdateChild(id: number, node: FrameNode): void {
let index = id;
let text = node.getFirstChild();
let textNode = text as typeNode.Text;
textNode?.initialize(this.data[index]).fontSize(20);
}
}
class MyNodeAdapterController extends NodeController {
rootNode: FrameNode | null = null;
nodeAdapter: MyNodeAdapter | null = null;
makeNode(uiContext: UIContext): FrameNode | null {
this.rootNode = new FrameNode(uiContext);
let listNode = typeNode.createNode(uiContext, "List");
listNode.initialize({ space: 3 }).borderWidth(2).borderColor(Color.Black);
this.rootNode.appendChild(listNode);
this.nodeAdapter = new MyNodeAdapter(uiContext, 100);
NodeAdapter.attachNodeAdapter(this.nodeAdapter, listNode);
return this.rootNode;
}
}
@Entry
@Component
struct ListNodeTest {
adapterController: MyNodeAdapterController = new MyNodeAdapterController();
build() {
Column() {
Text("ListNode Adapter");
NodeContainer(this.adapterController)
.width(300).height(300)
.borderWidth(1).borderColor(Color.Black);
Row() {
Button("Reload")
.onClick(() => {
this.adapterController.nodeAdapter?.reloadData(50);
})
Button("Change")
.onClick(() => {
this.adapterController.nodeAdapter?.changeData(5, 10)
})
Button("Insert")
.onClick(() => {
this.adapterController.nodeAdapter?.insertData(10, 10);
})
}
Row() {
Button("Remove")
.onClick(() => {
this.adapterController.nodeAdapter?.removeData(10, 10);
})
Button("Move")
.onClick(() => {
this.adapterController.nodeAdapter?.moveData(2, 5);
})
Button("Refresh")
.onClick(() => {
this.adapterController.nodeAdapter?.refreshData();
})
Button("Detach")
.onClick(() => {
this.adapterController.nodeAdapter?.detachData();
})
}
}.borderWidth(1)
.width("100%")
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-user-defined-arktsnode-rendernode-V14
爬取时间: 2025-04-27 23:39:54
来源: Huawei Developer
概述
对于不具备自己的渲染环境的三方框架，尽管已实现前端解析、布局及事件处理等功能，但仍需依赖系统的基础渲染和动画能力。FrameNode上的通用属性与通用事件对这类框架而言是冗余的，会导致多次不必要的操作，涵盖布局、事件处理等逻辑。
自定义渲染节点 (RenderNode)是更加轻量的渲染节点，仅具备与渲染相关的功能。它提供了设置基础渲染属性的能力，以及节点的动态添加、删除和自定义绘制的能力。RenderNode能够为第三方框架提供基础的渲染和动画支持。
创建和删除节点
RenderNode提供了节点创建和删除的能力。可以通过RenderNode的构造函数创建自定义的RenderNode节点。通过构造函数创建的节点对应一个实体的节点。同时，可以通过RenderNode中的dispose接口来实现与实体节点的绑定关系的解除。
操作节点树
RenderNode提供了节点的增、删、查、改的能力，能够修改节点的子树结构；可以对所有RenderNode的节点的父子节点做出查询操作，并返回查询结果。
-  RenderNode中查询获取得到的子树结构按照开发通过RenderNode的接口传递的参数构建。
-  RenderNode如果要与系统直接结合显示，使用需要依赖FrameNode中获取的RenderNode进行挂载上树。
```typescript
import { FrameNode, NodeController, RenderNode } from '@kit.ArkUI';
const TEST_TAG: string = "RenderNode";
const renderNode = new RenderNode();
renderNode.frame = {
x: 0,
y: 0,
width: 200,
height: 350
};
renderNode.backgroundColor = 0xffff0000;
for (let i = 0; i < 5; i++) {
const node = new RenderNode();
// 设置node节点的Frame大小
node.frame = {
x: 10,
y: 10 + 60 * i,
width: 50,
height: 50
};
// 设置node节点的背景颜色
node.backgroundColor = 0xff00ff00;
// 将新增节点挂载在renderNode上
renderNode.appendChild(node);
}
class MyNodeController extends NodeController {
private rootNode: FrameNode | null = null;
makeNode(uiContext: UIContext): FrameNode | null {
this.rootNode = new FrameNode(uiContext);
const rootRenderNode = this.rootNode?.getRenderNode();
if (rootRenderNode) {
rootRenderNode.appendChild(renderNode);
}
return this.rootNode;
}
}
@Entry
@Component
struct Index {
private myNodeController: MyNodeController = new MyNodeController();
build() {
Row() {
NodeContainer(this.myNodeController)
.width(200)
.height(350)
Button('getNextSibling')
.onClick(() => {
const child = renderNode.getChild(1);
const nextSibling = child!.getNextSibling()
if (child === null || nextSibling === null) {
console.log(TEST_TAG + ' the child or nextChild is null');
} else {
// 获取子节点的位置信息
console.log(`${TEST_TAG} the position of child is x: ${child.position.x}, y: ${child.position.y}, ` +
`the position of nextSibling is x: ${nextSibling.position.x}, y: ${nextSibling.position.y}`);
}
})
}
}
}
```
设置和获取渲染相关属性
RenderNode中可以设置渲染相关的属性，包括：backgroundColor，clipToFrame，opacity，size，position，frame，pivot，scale，translation，rotation，transform，shadowColor，shadowOffset，shadowAlpha，shadowElevation，shadowRadius，borderStyle，borderWidth，borderColor，borderRadius，shapeMask，shapeClip，markNodeGroup等。具体属性支持范围参考RenderNode接口说明。
-  RenderNode中查询获取得到的属性为设置的属性值。
-  若未传入参数或者传入参数为非法值则查询获得的为默认值。
-  不建议对BuilderNode中的RenderNode进行修改操作。BuilderNode中具体属性设置是由状态管理实现的,属性更新的时序开发者不可控，BuilderNode和FrameNode中同时设置RenderNode属性可能会导致RenderNode属性设置与预期不相符。
```typescript
import { RenderNode, FrameNode, NodeController, ShapeMask, ShapeClip } from '@kit.ArkUI';
const TEST_TAG: string = "RenderNode";
const mask = new ShapeMask();
mask.setRectShape({
left: 0,
right: 150,
top: 0,
bottom: 150
});
mask.fillColor = 0X55FF0000;
mask.strokeColor = 0XFFFF0000;
mask.strokeWidth = 24;
const clip = new ShapeClip();
clip.setCommandPath({ commands: "M100 0 L0 100 L50 200 L150 200 L200 100 Z" });
const renderNode = new RenderNode();
renderNode.backgroundColor = 0xffff0000;
renderNode.size = { width: 100, height: 100 };
class MyNodeController extends NodeController {
private rootNode: FrameNode | null = null;
makeNode(uiContext: UIContext): FrameNode | null {
this.rootNode = new FrameNode(uiContext);
const rootRenderNode = this.rootNode.getRenderNode();
if (rootRenderNode !== null) {
rootRenderNode.appendChild(renderNode);
}
return this.rootNode;
}
}
@Entry
@Component
struct Index {
private myNodeController: MyNodeController = new MyNodeController();
build() {
Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.SpaceBetween }) {
Column() {
NodeContainer(this.myNodeController)
}
Button("position")
.width(300)
.onClick(() => {
renderNode.position = { x: 10, y: 10 };
console.log(TEST_TAG + " position:" + JSON.stringify(renderNode.position));
})
Button("pivot")
.width(300)
.onClick(() => {
renderNode.pivot = { x: 0.5, y: 0.6 };
console.log(TEST_TAG + " pivot:" + JSON.stringify(renderNode.pivot));
})
Button("scale")
.width(300)
.onClick(() => {
renderNode.scale = { x: 0.5, y: 1 };
console.log(TEST_TAG + " scale:" + JSON.stringify(renderNode.scale));
})
Button("translation")
.width(300)
.onClick(() => {
renderNode.translation = { x: 100, y: 0 };
console.log(TEST_TAG + " translation:" + JSON.stringify(renderNode.translation));
})
Button("rotation")
.width(300)
.onClick(() => {
renderNode.rotation = { x: 45, y: 0, z: 0 };
console.log(TEST_TAG + " rotation:" + JSON.stringify(renderNode.rotation));
})
Button("transform")
.width(300)
.onClick(() => {
renderNode.transform = [
1, 0, 0, 0,
0, 2, 0, 0,
0, 0, 1, 0,
0, 0, 0, 1
];
console.log(TEST_TAG + " transform:" + JSON.stringify(renderNode.transform));
})
Button("shadow")
.width(300)
.onClick(() => {
renderNode.shadowElevation = 10;
renderNode.shadowColor = 0XFF00FF00;
renderNode.shadowOffset = { x: 10, y: 10 };
renderNode.shadowAlpha = 0.1;
console.log(TEST_TAG + " shadowElevation:" + JSON.stringify(renderNode.shadowElevation));
console.log(TEST_TAG + " shadowColor:" + JSON.stringify(renderNode.shadowColor));
console.log(TEST_TAG + " shadowOffset:" + JSON.stringify(renderNode.shadowOffset));
console.log(TEST_TAG + " shadowAlpha:" + JSON.stringify(renderNode.shadowAlpha));
})
Button("shadowRadius")
.width(300)
.onClick(() => {
renderNode.shadowOffset = { x: 10, y: 10 };
renderNode.shadowAlpha = 0.7
renderNode.shadowRadius = 30;
console.log(TEST_TAG + " shadowOffset:" + JSON.stringify(renderNode.shadowOffset));
console.log(TEST_TAG + " shadowAlpha:" + JSON.stringify(renderNode.shadowAlpha));
console.log(TEST_TAG + " shadowRadius:" + JSON.stringify(renderNode.shadowRadius));
})
Button("border")
.width(300)
.onClick(() => {
renderNode.borderWidth = {
left: 8,
top: 8,
right: 8,
bottom: 8
};
renderNode.borderStyle = {
left: BorderStyle.Solid,
top: BorderStyle.Dotted,
right: BorderStyle.Dashed,
bottom: BorderStyle.Solid
}
renderNode.borderColor = {
left: 0xFF0000FF,
top: 0xFF0000FF,
right: 0xFF0000FF,
bottom: 0xFF0000FF
};
renderNode.borderRadius = {
topLeft: 32,
topRight: 32,
bottomLeft: 32,
bottomRight: 32
};
console.log(TEST_TAG + " borderWidth:" + JSON.stringify(renderNode.borderWidth));
console.log(TEST_TAG + " borderStyle:" + JSON.stringify(renderNode.borderStyle));
console.log(TEST_TAG + " borderColor:" + JSON.stringify(renderNode.borderColor));
console.log(TEST_TAG + " borderRadius:" + JSON.stringify(renderNode.borderRadius));
})
Button("shapeMask")
.width(300)
.onClick(() => {
renderNode.shapeMask = mask;
console.log(TEST_TAG + " shapeMask:" + JSON.stringify(renderNode.shapeMask));
})
Button("shapeClip")
.width(300)
.onClick(() => {
renderNode.shapeClip = clip;
console.log(TEST_TAG + " shapeMask:" + JSON.stringify(renderNode.shapeMask));
})
}
.padding({
left: 35,
right: 35,
top: 35,
bottom: 35
})
.width("100%")
.height("100%")
}
}
```
自定义绘制
通过重写RenderNode中的draw方法，可以自定义RenderNode的绘制内容，通过invalidate接口可以主动触发节点的重新绘制。
-  同时同步触发多个invalidate仅会触发一次重新绘制。
-  自定义绘制有两种绘制方式：通过ArkTS接口进行调用和通过Node-API进行调用。
ArkTS接口调用示例：
```typescript
import { FrameNode, NodeController, RenderNode } from '@kit.ArkUI';
import { drawing } from '@kit.ArkGraphics2D';
class MyRenderNode extends RenderNode {
width: number = 200;
draw(context: DrawContext) {
// 获取canvas对象
const canvas = context.canvas;
// 创建笔刷
const brush = new drawing.Brush();
// 设置笔刷颜色
brush.setColor({
alpha: 255,
red: 255,
green: 0,
blue: 0
});
canvas.attachBrush(brush);
// 绘制矩阵
canvas.drawRect({
left: 0,
right: this.width,
top: 0,
bottom: 200
});
canvas.detachBrush();
console.log(`RenderNode draw width = ${this.width}`);
}
}
const renderNode = new MyRenderNode();
renderNode.frame = {
x: 0,
y: 0,
width: 300,
height: 300
};
renderNode.backgroundColor = 0xff0000ff;
renderNode.opacity = 0.5;
class MyNodeController extends NodeController {
private rootNode: FrameNode | null = null;
makeNode(uiContext: UIContext): FrameNode | null {
this.rootNode = new FrameNode(uiContext);
const rootRenderNode = this.rootNode?.getRenderNode();
if (rootRenderNode !== null) {
rootRenderNode.frame = {
x: 0,
y: 0,
width: 500,
height: 500
}
rootRenderNode.appendChild(renderNode);
}
return this.rootNode;
}
}
@Entry
@Component
struct Index {
private myNodeController: MyNodeController = new MyNodeController();
build() {
Column() {
NodeContainer(this.myNodeController)
.width('100%')
Button('Invalidate')
.onClick(() => {
// 同步调用多次，仅触发一次重绘，draw回调中的日志仅打印一次
renderNode.width += 10;
renderNode.invalidate();
renderNode.invalidate();
})
}
}
}
```
Node-API调用示例：
C++侧可通过Node-API来获取Canvas，并进行后续的自定义绘制操作。
修改工程中的src/main/cpp/CMakeLists.txt文件，添加如下内容：
同时在工程中的src/main/cpp/types/libentry/index.d.ts文件中，添加自定义绘制函数在ArkTS侧的定义，如：
```typescript
import { DrawContext } from '@kit.ArkUI'
export const nativeOnDraw: (id: number, context: DrawContext, width: number, height: number) => number;
```
ArkTS侧代码：
```typescript
// Index.ets
import bridge from "libentry.so" // 该 so 由 Node-API 编写并生成
import { DrawContext, FrameNode, NodeController, RenderNode } from '@kit.ArkUI'
class MyRenderNode extends RenderNode {
draw(context: DrawContext) {
// 需要将 context 中的宽度和高度从vp转换为px
bridge.nativeOnDraw(0, context, vp2px(context.size.height), vp2px(context.size.width));
}
}
class MyNodeController extends NodeController {
private rootNode: FrameNode | null = null;
makeNode(uiContext: UIContext): FrameNode | null {
this.rootNode = new FrameNode(uiContext);
const rootRenderNode = this.rootNode.getRenderNode();
if (rootRenderNode !== null) {
const renderNode = new MyRenderNode();
renderNode.size = { width: 100, height: 100 }
rootRenderNode.appendChild(renderNode);
}
return this.rootNode;
}
}
@Entry
@Component
struct Index {
private myNodeController: MyNodeController = new MyNodeController();
build() {
Row() {
NodeContainer(this.myNodeController)
}
}
}
```
设置标签
开发者可利用label接口向RenderNode设置标签信息，这有助于在节点Inspector中更清晰地区分各节点。
```typescript
import {  RenderNode, FrameNode, NodeController, UIContext } from '@kit.ArkUI';
class MyNodeController extends NodeController {
private rootNode: FrameNode | null = null;
makeNode(uiContext: UIContext): FrameNode | null {
this.rootNode = new FrameNode(uiContext);
const renderNode: RenderNode | null = this.rootNode.getRenderNode();
if (renderNode !== null) {
const renderChildNode: RenderNode = new RenderNode();
renderChildNode.frame = { x: 0, y: 0, width: 100, height: 100 };
renderChildNode.backgroundColor = 0xffff0000;
renderChildNode.label = 'customRenderChildNode';
console.log('label:', renderChildNode.label);
renderNode.appendChild(renderChildNode);
}
return this.rootNode;
}
}
@Entry
@Component
struct Index {
private myNodeController: MyNodeController = new MyNodeController();
build() {
Column() {
NodeContainer(this.myNodeController)
.width(300)
.height(700)
.backgroundColor(Color.Gray)
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-user-defined-arktsnode-buildernode-V14
爬取时间: 2025-04-27 23:40:08
来源: Huawei Developer
概述
自定义声明式节点 (BuilderNode)提供能够挂载系统组件的能力，支持采用无状态的UI方式，通过全局自定义构建函数@Builder定制组件树。组件树的根FrameNode节点可通过getFrameNode获取，该节点既可直接由NodeController返回并挂载于NodeContainer节点下，亦可在FrameNode树与RenderNode树中嵌入声明式组件，实现混合显示。同时，BuilderNode具备纹理导出功能，导出的纹理可在XComponent中实现同层渲染。
由BuilderNode构建的ArkTS原生控件树，支持与自定义节点（如FrameNode、RenderNode）关联使用，确保了系统组件与自定义节点的混合显示效果。对于需与自定义节点对接的第三方框架，BuilderNode提供了嵌入系统组件的方法。
此外，BuilderNode还提供了组件预创建的能力，能够自定义系统组件的创建开始的时间，在后续业务中实现动态挂载与显示。此功能尤其适用于初始化耗时较长的声明式组件，如Web、XComponent等，通过预创建，可以有效减少初始化时间，优化组件加载效率。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170319.86678970222860101675743756109670:50001231000000:2800:10F1B7856FA17D8D3622FE60C99988BD3092244C1E33EC5383A2582D74CBAEB9.png)
基本概念
-  系统组件：组件是UI的必要元素，形成了在界面中的样子，由ArkUI直接提供的称为系统组件。
-  实体节点：由后端创建的Native节点。
BuilderNode仅可作为叶子节点进行使用。如有更新需要，建议通过BuilderNode中的update方式触发更新，不建议通过BuilderNode中获取的RenderNode对节点进行修改操作。
-  BuilderNode只支持一个由wrapBuilder包装的全局自定义构建函数@Builder。
-  一个新建的BuildNode在build之后才能通过getFrameNode获取到一个指向根节点的FrameNode对象，否则返回null。
-  如果传入的Builder的根节点为语法节点（if/else/foreach/...），需要额外生成一个FrameNode，在节点树中的显示为“BuilderProxyNode”。
-  如果BuilderNode通过getFrameNode将节点挂载在另一个FrameNode上，或者将其作为子节点挂载在NodeContainer节点上。则节点中使用父组件的布局约束进行布局。
-  如果BuilderNode的FrameNode通过getRenderNode形式将自己的节点挂载在RenderNode节点上，由于其FrameNode未上树，其大小默认为0，需要通过构造函数中的selfIdeaSize显式指定布局约束大小，才能正常显示。
-  BuilderNode的预加载并不会减少组件的创建时间。Web组件创建的时候需要在内核中加载资源，预创建不能减少Web组件的创建的时间，但是可以让内核进行预加载，减少正式使用时候内核的加载耗时。
创建BuilderNode对象
BuilderNode对象为一个模板类，需要在创建的时候指定类型。该类型需要与后续build方法中传入的WrappedBuilder的类型保持一致，否则会存在编译告警导致编译失败。
创建原生组件树
通过BuilderNode的build可以实现原生组件树的创建。依照传入的WrappedBuilder对象创建组件树，并持有组件树的根节点。
无状态的UI方法全局@Builder最多拥有一个根节点。
build方法中对应的@Builder支持一个参数作为入参。
build中对于@Builder嵌套@Builder进行使用的场景，需要保证嵌套的参数与build的中提供的入参一致。
对于@Builder嵌套@Builder进行使用的场景，如果入参类型不一致，则要求增加BuilderOptions字段作为build的入参。
需要操作BuilderNode中的对象时，需要保证其引用不被回收。当BuilderNode对象被虚拟机回收之后，它的FrameNode、RenderNode对象也会与后端节点解引用。即从BuilderNode中获取的FrameNode对象不对应任何一个节点。
创建离线节点以及原生组件树，结合FrameNode进行使用。
BuilderNode的根节点直接作为NodeController的makeNode返回值。
```typescript
import { BuilderNode, FrameNode, NodeController, UIContext } from '@kit.ArkUI';
class Params {
text: string = "";
constructor(text: string) {
this.text = text;
}
}
@Builder
function buildText(params: Params) {
Column() {
Text(params.text)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.margin({ bottom: 36 })
}
}
class TextNodeController extends NodeController {
private textNode: BuilderNode<[Params]> | null = null;
private message: string = "DEFAULT";
constructor(message: string) {
super();
this.message = message;
}
makeNode(context: UIContext): FrameNode | null {
this.textNode = new BuilderNode(context);
this.textNode.build(wrapBuilder<[Params]>(buildText), new Params(this.message))
return this.textNode.getFrameNode();
}
}
@Entry
@Component
struct Index {
@State message: string = "hello";
build() {
Row() {
Column() {
NodeContainer(new TextNodeController(this.message))
.width('100%')
.height(100)
.backgroundColor('#FFF0F0F0')
}
.width('100%')
.height('100%')
}
.height('100%')
}
}
```
将BuilderNode与RenderNode进行结合使用。
BuilderNode的RenderNode挂载其它RenderNode下时，需要明确定义selfIdeaSize的大小作为BuilderNode的布局约束。不推荐通过该方式挂载节点。
```typescript
import { NodeController, BuilderNode, FrameNode, UIContext, RenderNode } from "@kit.ArkUI";
class Params {
text: string = "";
constructor(text: string) {
this.text = text;
}
}
@Builder
function buildText(params: Params) {
Column() {
Text(params.text)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.margin({ bottom: 36 })
}
}
class TextNodeController extends NodeController {
private rootNode: FrameNode | null = null;
private textNode: BuilderNode<[Params]> | null = null;
private message: string = "DEFAULT";
constructor(message: string) {
super();
this.message = message;
}
makeNode(context: UIContext): FrameNode | null {
this.rootNode = new FrameNode(context);
let renderNode = new RenderNode();
renderNode.clipToFrame = false;
this.textNode = new BuilderNode(context, { selfIdealSize: { width: 150, height: 150 } });
this.textNode.build(wrapBuilder<[Params]>(buildText), new Params(this.message));
const textRenderNode = this.textNode?.getFrameNode()?.getRenderNode();
const rootRenderNode = this.rootNode.getRenderNode();
if (rootRenderNode !== null) {
rootRenderNode.appendChild(renderNode);
renderNode.appendChild(textRenderNode);
}
return this.rootNode;
}
}
@Entry
@Component
struct Index {
@State message: string = "hello";
build() {
Row() {
Column() {
NodeContainer(new TextNodeController(this.message))
.width('100%')
.height(100)
.backgroundColor('#FFF0F0F0')
}
.width('100%')
.height('100%')
}
.height('100%')
}
}
```
更新原生组件树
通过BuilderNode对象的build创建原生组件树。依照传入的WrappedBuilder对象创建组件树，并持有组件树的根节点。
自定义组件的更新遵循状态管理的更新机制。WrappedBuilder中直接使用的自定义组件其父组件为BuilderNode对象。因此，更新子组件即WrappedBuilder中定义的自定义组件，需要遵循状态管理的定义将相关的状态变量定义为@Prop或者@ObjectLink。装饰器的选择请参照状态管理的装饰器规格结合应用开发需求进行选择。
使用update更新BuilderNode中的节点。
使用updateConfiguration触发BuilderNode中节点的全量更新。
更新BuilderNode中的节点。
```typescript
import { NodeController, BuilderNode, FrameNode, UIContext } from "@kit.ArkUI";
class Params {
text: string = "";
constructor(text: string) {
this.text = text;
}
}
// 自定义组件
@Component
struct TextBuilder {
// 作为自定义组件中需要更新的属性，数据类型为基础属性，定义为@Prop
@Prop message: string = "TextBuilder";
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.margin({ bottom: 36 })
.backgroundColor(Color.Gray)
}
}
}
}
@Builder
function buildText(params: Params) {
Column() {
Text(params.text)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.margin({ bottom: 36 })
TextBuilder({ message: params.text }) // 自定义组件
}
}
class TextNodeController extends NodeController {
private textNode: BuilderNode<[Params]> | null = null;
private message: string = "";
constructor(message: string) {
super()
this.message = message
}
makeNode(context: UIContext): FrameNode | null {
this.textNode = new BuilderNode(context);
this.textNode.build(wrapBuilder<[Params]>(buildText), new Params(this.message))
return this.textNode.getFrameNode();
}
update(message: string) {
if (this.textNode !== null) {
// 调用update进行更新。
this.textNode.update(new Params(message));
}
}
}
@Entry
@Component
struct Index {
@State message: string = "hello";
private textNodeController: TextNodeController = new TextNodeController(this.message);
private count = 0;
build() {
Row() {
Column() {
NodeContainer(this.textNodeController)
.width('100%')
.height(200)
.backgroundColor('#FFF0F0F0')
Button('Update')
.onClick(() => {
this.count += 1;
const message = "Update " + this.count.toString();
this.textNodeController.update(message);
})
}
.width('100%')
.height('100%')
}
.height('100%')
}
}
```
解除实体节点引用关系
由于BuilderNode对应的是后端的实体节点，正常的内存释放依赖前端对象的回收。如果期望直接释放后端的节点对象，则可以通过调用dispose与实体节点解除引用关系，此时持有的前端BuilderNode对象不再影响实体节点的生命周期。
当BuilderNode对象调用dispose之后，不仅BuilderNode对象与后端实体节点解除引用关系，BuilderNode中的FrameNode与RenderNode也会同步和实体节点解除引用关系。
若前端对象BuilderNode无法释放，容易导致内存泄漏。建议在不再需要对该BuilderNode对象进行操作时，开发者应主动调用dispose释放后端节点，以减少引用关系的复杂性，降低内存泄漏的风险。
注入触摸事件
BuilderNode中提供了postTouchEvent，可以通过该接口向BuilderNode中绑定的组件注入触摸事件，实现事件的模拟转发。
通过postTouchEvent向BuilderNode对应的节点树中注入触摸事件。
向BuilderNode中的Column组件转发另一个Column的接收事件，即点击下方的Column组件，上方的Colum组件也会收到同样的触摸事件。当Button中的事件被成功识别的时候，返回值为true。
```typescript
import { NodeController, BuilderNode, FrameNode, UIContext } from '@kit.ArkUI';
class Params {
text: string = "this is a text";
}
@Builder
function ButtonBuilder(params: Params) {
Column() {
Button(`button ` + params.text)
.borderWidth(2)
.backgroundColor(Color.Orange)
.width("100%")
.height("100%")
.gesture(
TapGesture()
.onAction((event: GestureEvent) => {
console.log("TapGesture");
})
)
}
.width(500)
.height(300)
.backgroundColor(Color.Gray)
}
class MyNodeController extends NodeController {
private rootNode: BuilderNode<[Params]> | null = null;
private wrapBuilder: WrappedBuilder<[Params]> = wrapBuilder(ButtonBuilder);
makeNode(uiContext: UIContext): FrameNode | null {
this.rootNode = new BuilderNode(uiContext);
this.rootNode.build(this.wrapBuilder, { text: "this is a string" })
return this.rootNode.getFrameNode();
}
postTouchEvent(touchEvent: TouchEvent): void {
if (this.rootNode == null) {
return;
}
let result = this.rootNode.postTouchEvent(touchEvent);
console.log("result " + result);
}
}
@Entry
@Component
struct MyComponent {
private nodeController: MyNodeController = new MyNodeController();
build() {
Column() {
NodeContainer(this.nodeController)
.height(300)
.width(500)
Column()
.width(500)
.height(300)
.backgroundColor(Color.Pink)
.onTouch((event) => {
if (event != undefined) {
this.nodeController.postTouchEvent(event);
}
})
}
}
}
```
节点复用能力
调用reuse接口和recycle接口，将复用和回收事件传递至BuilderNode中的自定义组件，以实现BuilderNode节点内部的自定义组件的复用。
以下面的Demo为例，被复用的自定义组件ReusableChildComponent可以传递复用和回收事件到其下的自定义组件ReusableChildComponent3，但无法传递给自定义组件ReusableChildComponent2，因为被BuilderNode所隔断。因此需要主动调用BuilderNode的reuse和recycle接口，将复用和回收事件传递给自定义组件ReusableChildComponent2，以达成复用效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170319.75322934169842223528760260392365:50001231000000:2800:3D65724228BF2E3390F744CECB2803EBCE6536E7590D440E5B5149D924555DE9.png)
```typescript
import { FrameNode, NodeController, BuilderNode, UIContext } from "@kit.ArkUI";
const TEST_TAG: string = "Reuse+Recycle";
class MyDataSource {
private dataArray: string[] = [];
private listener: DataChangeListener | null = null
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number) {
return this.dataArray[index];
}
public pushData(data: string) {
this.dataArray.push(data);
}
public reloadListener(): void {
this.listener?.onDataReloaded();
}
public registerDataChangeListener(listener: DataChangeListener): void {
this.listener = listener;
}
public unregisterDataChangeListener(): void {
this.listener = null;
}
}
class Params {
item: string = '';
constructor(item: string) {
this.item = item;
}
}
@Builder
function buildNode(param: Params = new Params("hello")) {
Row() {
Text(`C${param.item} -- `)
ReusableChildComponent2({ item: param.item }) //该自定义组件在BuilderNode中无法被正确复用
}
}
class MyNodeController extends NodeController {
public builderNode: BuilderNode<[Params]> | null = null;
public item: string = "";
makeNode(uiContext: UIContext): FrameNode | null {
if (this.builderNode == null) {
this.builderNode = new BuilderNode(uiContext, { selfIdealSize: { width: 300, height: 200 } });
this.builderNode.build(wrapBuilder<[Params]>(buildNode), new Params(this.item));
}
return this.builderNode.getFrameNode();
}
}
// 被回收复用的自定义组件，其状态变量会更新，而子自定义组件ReusableChildComponent3中的状态变量也会更新，但BuilderNode会阻断这一传递过程
@Reusable
@Component
struct ReusableChildComponent {
@Prop item: string = '';
@Prop switch: string = '';
private controller: MyNodeController = new MyNodeController();
aboutToAppear() {
this.controller.item = this.item;
}
aboutToRecycle(): void {
console.log(`${TEST_TAG} ReusableChildComponent aboutToRecycle ${this.item}`);
// 当开关为open，通过BuilderNode的reuse接口和recycle接口传递给其下的自定义组件，例如ReusableChildComponent2，完成复用
if (this.switch === 'open') {
this.controller?.builderNode?.recycle();
}
}
aboutToReuse(params: object): void {
console.log(`${TEST_TAG} ReusableChildComponent aboutToReuse ${JSON.stringify(params)}`);
// 当开关为open，通过BuilderNode的reuse接口和recycle接口传递给其下的自定义组件，例如ReusableChildComponent2，完成复用
if (this.switch === 'open') {
this.controller?.builderNode?.reuse(params);
}
}
build() {
Row() {
Text(`A${this.item}--`)
ReusableChildComponent3({ item: this.item })
NodeContainer(this.controller);
}
}
}
@Component
struct ReusableChildComponent2 {
@Prop item: string = "false";
aboutToReuse(params: Record<string, object>) {
console.log(`${TEST_TAG} ReusableChildComponent2 aboutToReuse ${JSON.stringify(params)}`);
}
aboutToRecycle(): void {
console.log(`${TEST_TAG} ReusableChildComponent2 aboutToRecycle ${this.item}`);
}
build() {
Row() {
Text(`D${this.item}`)
.fontSize(20)
.backgroundColor(Color.Yellow)
.margin({ left: 10 })
}.margin({ left: 10, right: 10 })
}
}
@Component
struct ReusableChildComponent3 {
@Prop item: string = "false";
aboutToReuse(params: Record<string, object>) {
console.log(`${TEST_TAG} ReusableChildComponent3 aboutToReuse ${JSON.stringify(params)}`);
}
aboutToRecycle(): void {
console.log(`${TEST_TAG} ReusableChildComponent3 aboutToRecycle ${this.item}`);
}
build() {
Row() {
Text(`B${this.item}`)
.fontSize(20)
.backgroundColor(Color.Yellow)
.margin({ left: 10 })
}.margin({ left: 10, right: 10 })
}
}
@Entry
@Component
struct Index {
@State data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i < 100; i++) {
this.data.pushData(i.toString());
}
}
build() {
Column() {
List({ space: 3 }) {
LazyForEach(this.data, (item: string) => {
ListItem() {
ReusableChildComponent({
item: item,
switch: 'open' // 将open改为close可观察到，BuilderNode不通过reuse和recycle接口传递复用时，BuilderNode内部的自定义组件的行为表现
})
}
}, (item: string) => item)
}
.width('100%')
.height('100%')
}
}
}
```
通过系统环境变化更新节点
使用updateConfiguration来监听系统环境变化事件，以触发节点的全量更新。
updateConfiguration接口用于通知对象进行更新，更新所使用的系统环境取决于应用当前系统环境的变化。
```typescript
import { NodeController, BuilderNode, FrameNode, UIContext } from "@kit.ArkUI";
import { AbilityConstant, Configuration, EnvironmentCallback } from '@kit.AbilityKit';
class Params {
text: string = ""
constructor(text: string) {
this.text = text;
}
}
// 自定义组件
@Component
struct TextBuilder {
// 作为自定义组件中需要更新的属性，数据类型为基础属性，定义为@Prop
@Prop message: string = "TextBuilder";
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.margin({ bottom: 36 })
.fontColor($r(`app.color.text_color`))
.backgroundColor($r(`app.color.start_window_background`))
}
}
}
}
@Builder
function buildText(params: Params) {
Column() {
Text(params.text)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.margin({ bottom: 36 })
.fontColor($r(`app.color.text_color`))
TextBuilder({ message: params.text }) // 自定义组件
}.backgroundColor($r(`app.color.start_window_background`))
}
class TextNodeController extends NodeController {
private textNode: BuilderNode<[Params]> | null = null;
private message: string = "";
constructor(message: string) {
super()
this.message = message;
}
makeNode(context: UIContext): FrameNode | null {
return this.textNode?.getFrameNode() ? this.textNode?.getFrameNode() : null;
}
createNode(context: UIContext) {
this.textNode = new BuilderNode(context);
this.textNode.build(wrapBuilder<[Params]>(buildText), new Params(this.message));
builderNodeMap.push(this.textNode);
}
deleteNode() {
let node = builderNodeMap.pop();
node?.dispose();
}
update(message: string) {
if (this.textNode !== null) {
// 调用update进行更新。
this.textNode.update(new Params(message));
}
}
}
// 记录创建的自定义节点对象
const builderNodeMap: Array<BuilderNode<[Params]>> = new Array();
function updateColorMode() {
builderNodeMap.forEach((value, index) => {
// 通知BuilderNode环境变量改变
value.updateConfiguration();
})
}
@Entry
@Component
struct Index {
@State message: string = "hello"
private textNodeController: TextNodeController = new TextNodeController(this.message);
private count = 0;
aboutToAppear(): void {
let environmentCallback: EnvironmentCallback = {
onMemoryLevel: (level: AbilityConstant.MemoryLevel): void => {
console.log('onMemoryLevel');
},
onConfigurationUpdated: (config: Configuration): void => {
console.log('onConfigurationUpdated ' + JSON.stringify(config));
updateColorMode();
}
}
// 注册监听回调
this.getUIContext().getHostContext()?.getApplicationContext().on('environment', environmentCallback);
//创建自定义节点并添加至map
this.textNodeController.createNode(this.getUIContext());
}
aboutToDisappear(): void {
//移除map中的引用，并将自定义节点释放
this.textNodeController.deleteNode();
}
build() {
Row() {
Column() {
NodeContainer(this.textNodeController)
.width('100%')
.height(200)
.backgroundColor('#FFF0F0F0')
Button('Update')
.onClick(() => {
this.count += 1;
const message = "Update " + this.count.toString();
this.textNodeController.update(message);
})
}
.width('100%')
.height('100%')
}
.height('100%')
}
}
```
跨页面复用注意事项
在使用路由接口router.replaceUrl、router.back、router.clear、router.replaceNamedRoute操作页面时，若某个被缓存的BuilderNode位于即将销毁的页面内，那么在新页面中复用该BuilderNode时，可能会存在数据无法更新或新创建节点无法显示的问题。以router.replaceNamedRoute为例，在以下示例代码中，当点击“router replace”按钮后，页面将切换至PageTwo，同时标志位isShowText会被设定为false。
```typescript
// ets/pages/Index.ets
import { NodeController, BuilderNode, FrameNode, UIContext } from "@kit.ArkUI";
import "ets/pages/PageTwo"
@Builder
function buildText() {
// @Builder中使用语法节点生成BuilderProxyNode
if (true) {
MyComponent()
}
}
@Component
struct MyComponent {
@StorageLink("isShowText") isShowText: boolean = true;
build() {
if (this.isShowText) {
Column() {
Text("BuilderNode Reuse")
.fontSize(36)
.fontWeight(FontWeight.Bold)
.padding(16)
}
}
}
}
class TextNodeController extends NodeController {
private rootNode: FrameNode | null = null;
private textNode: BuilderNode<[]> | null = null;
makeNode(context: UIContext): FrameNode | null {
this.rootNode = new FrameNode(context);
if (AppStorage.has("textNode")) {
// 复用AppStorage中的BuilderNode
this.textNode = AppStorage.get<BuilderNode<[]>>("textNode") as BuilderNode<[]>;
const parent = this.textNode.getFrameNode()?.getParent();
if (parent) {
parent.removeChild(this.textNode.getFrameNode());
}
} else {
this.textNode = new BuilderNode(context);
this.textNode.build(wrapBuilder<[]>(buildText));
// 将创建的BuilderNode存入AppStorage
AppStorage.setOrCreate<BuilderNode<[]>>("textNode", this.textNode);
}
this.rootNode.appendChild(this.textNode.getFrameNode());
return this.rootNode;
}
}
@Entry({ routeName: "myIndex" })
@Component
struct Index {
aboutToAppear(): void {
AppStorage.setOrCreate<boolean>("isShowText", true);
}
build() {
Row() {
Column() {
NodeContainer(new TextNodeController())
.width('100%')
.backgroundColor('#FFF0F0F0')
Button('Router pageTwo')
.onClick(() => {
// 改变AppStorage中的状态变量触发Text节点的重新创建
AppStorage.setOrCreate<boolean>("isShowText", false);
this.getUIContext().getRouter().replaceNamedRoute({ name: "pageTwo" });
})
.margin({ top: 16 })
}
.width('100%')
.height('100%')
.padding(16)
}
.height('100%')
}
}
```
PageTwo的实现如下：
```typescript
// ets/pages/PageTwo.ets
// 该页面中存在一个按钮，可跳转回主页面，回到主页面后，原有的文字消失
import "ets/pages/Index"
@Entry({ routeName: "pageTwo" })
@Component
struct PageTwo {
build() {
Column() {
Button('Router replace to index')
.onClick(() => {
this.getUIContext().getRouter().replaceNamedRoute({ name: "myIndex" });
})
}
.height('100%')
.width('100%')
.alignItems(HorizontalAlign.Center)
.padding(16)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170319.69385419666686406889931801420025:50001231000000:2800:696235340B2DC1237F8BF1FE674DD3B2EB7BFB971BC836CC04BA95196C514F24.gif)
在API version 16之前，解决该问题的方法是在页面销毁时，将页面上的BuilderNode从缓存中移除。以上述例子为例，可以在页面跳转前，通过点击事件将BuilderNode从AppStorage中移除，以此达到预期效果。
API version 16及之后版本，BuilderNode在新页面被复用时，会自动刷新自身内容，无需在页面销毁时将BuilderNode从缓存中移除。
```typescript
// ets/pages/Index.ets
import { NodeController, BuilderNode, FrameNode, UIContext } from "@kit.ArkUI";
import "ets/pages/PageTwo"
@Builder
function buildText() {
// @Builder中使用语法节点生成BuilderProxyNode
if (true) {
MyComponent()
}
}
@Component
struct MyComponent {
@StorageLink("isShowText") isShowText: boolean = true;
build() {
if (this.isShowText) {
Column() {
Text("BuilderNode Reuse")
.fontSize(36)
.fontWeight(FontWeight.Bold)
.padding(16)
}
}
}
}
class TextNodeController extends NodeController {
private rootNode: FrameNode | null = null;
private textNode: BuilderNode<[]> | null = null;
makeNode(context: UIContext): FrameNode | null {
this.rootNode = new FrameNode(context);
if (AppStorage.has("textNode")) {
// 复用AppStorage中的BuilderNode
this.textNode = AppStorage.get<BuilderNode<[]>>("textNode") as BuilderNode<[]>;
const parent = this.textNode.getFrameNode()?.getParent();
if (parent) {
parent.removeChild(this.textNode.getFrameNode());
}
} else {
this.textNode = new BuilderNode(context);
this.textNode.build(wrapBuilder<[]>(buildText));
// 将创建的BuilderNode存入AppStorage
AppStorage.setOrCreate<BuilderNode<[]>>("textNode", this.textNode);
}
this.rootNode.appendChild(this.textNode.getFrameNode());
return this.rootNode;
}
}
@Entry({ routeName: "myIndex" })
@Component
struct Index {
aboutToAppear(): void {
AppStorage.setOrCreate<boolean>("isShowText", true);
}
build() {
Row() {
Column() {
NodeContainer(new TextNodeController())
.width('100%')
.backgroundColor('#FFF0F0F0')
Button('Router pageTwo')
.onClick(() => {
// 改变AppStorage中的状态变量触发Text节点的重新创建
AppStorage.setOrCreate<boolean>("isShowText", false);
// 将BuilderNode从AppStorage中移除
AppStorage.delete("textNode");
this.getUIContext().getRouter().replaceNamedRoute({ name: "pageTwo" });
})
.margin({ top: 16 })
}
.width('100%')
.height('100%')
.padding(16)
}
.height('100%')
}
}
```
BuilderNode中使用LocalStorage
从API version 12开始，自定义组件支持接收LocalStorage实例。可以通过传递LocalStorage实例来使用LocalStorage相关的装饰器@LocalStorageProp、@LocalStorageLink。
```typescript
import { BuilderNode, NodeController, UIContext } from '@kit.ArkUI';
let localStorage1: LocalStorage = new LocalStorage();
localStorage1.setOrCreate('PropA', 'PropA');
let localStorage2: LocalStorage = new LocalStorage();
localStorage2.setOrCreate('PropB', 'PropB');
@Entry(localStorage1)
@Component
struct Index {
// 'PropA'，和localStorage1中'PropA'的双向同步
@LocalStorageLink('PropA') PropA: string = 'Hello World';
@State count: number = 0;
private controller: NodeController = new MyNodeController(this.count, localStorage2);
build() {
Row() {
Column() {
Text(this.PropA)
.fontSize(50)
.fontWeight(FontWeight.Bold)
// 使用LocalStorage 实例localStorage2
Child({ count: this.count }, localStorage2)
NodeContainer(this.controller)
}
.width('100%')
}
.height('100%')
}
}
interface Params {
count: number;
localStorage: LocalStorage;
}
@Builder
function CreateChild(params: Params) {
//构造过程中传递localStorage
Child({ count: params.count }, params.localStorage)
}
class MyNodeController extends NodeController {
private count?: number;
private localStorage ?: LocalStorage;
constructor(count: number, localStorage: LocalStorage) {
super();
this.count = count;
this.localStorage = localStorage;
}
makeNode(uiContext: UIContext): FrameNode | null {
let builderNode = new BuilderNode<[Params]>(uiContext);
//构造过程中传递localStorage
builderNode.build(wrapBuilder(CreateChild), { count: this.count, localStorage: this.localStorage });
return builderNode.getFrameNode();
}
}
@Component
struct Child {
@Prop count: number;
//  'Hello World'，和localStorage2中'PropB'的双向同步，如果localStorage2中没有'PropB'，则使用默认值'Hello World'
@LocalStorageLink('PropB') PropB: string = 'Hello World';
build() {
Text(this.PropB)
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-modifier-V14
爬取时间: 2025-04-27 23:40:22
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-user-defined-modifier-V14
爬取时间: 2025-04-27 23:40:35
来源: Huawei Developer
ArkUI框架提供一系列基于Modifier的自定义扩展能力，通过与UI分离的方式，对已有UI组件的属性、手势、内容进行扩展修改，以满足开发者在不改变UI组件底层实现的情况下，快速调整UI组件外观、行为等需求。自定义扩展包括AttributeModifier、GestureModifier、DrawModifier等。其中AttributeModifier和AttributeUpdater允许开发者通过自定义类设置属性，扩展了属性设置的实现方式，能够与原生属性设置方式混合使用。例如，使用自定义扩展处理特定的逻辑或复杂交互，使用原生设置方式处理简单静态属性等。
AttributeModifier
声明式语法引入的@Styles和@Extend两个装饰器，虽然可以解决复用相同自定义样式的问题，但是使用场景存在一定局限性，如无法跨文件导出等。为此，ArkUI引入了AttributeModifier机制，可以通过Modifier对象动态修改属性。与@Styles和@Extend相比，AttributeModifier提供了更强的能力和灵活性，且在持续完善全量的属性和事件设置能力，因此推荐优先使用AttributeModifier。
AttributeUpdater
AttributeUpdater是一个特殊的AttributeModifier，除了继承AttributeModifier的能力，还提供了获取属性对象的能力。通过属性对象可以不经过状态变量，直接更新对应属性。开发者可以通过AttributeUpdater实现自定义的更新策略，进一步提高属性更新的性能。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-user-defined-extension-attributemodifier-V14
爬取时间: 2025-04-27 23:40:49
来源: Huawei Developer
概述
声明式语法引入了@Styles和@Extend两个装饰器，可以解决复用相同自定义样式的问题，但是存在以下受限场景：
为了解决上述问题，ArkUI引入了AttributeModifier机制，可以通过Modifier对象动态修改属性。能力对比如下：
| 能力 | @Styles | @Extend | AttributeModifier |
| --- | --- | --- | --- |
| 跨文件导出 | 不支持 | 不支持 | 支持 |
| 通用属性设置 | 支持 | 支持 | 支持 |
| 通用事件设置 | 支持 | 支持 | 部分支持 |
| 组件特有属性设置 | 不支持 | 支持 | 部分支持 |
| 组件特有事件设置 | 不支持 | 支持 | 部分支持 |
| 参数传递 | 不支持 | 支持 | 支持 |
| 多态样式 | 支持 | 不支持 | 支持 |
| 业务逻辑 | 不支持 | 不支持 | 支持 |
可以看出，与@Styles和@Extend相比，AttributeModifier提供了更强的能力和灵活性，且在持续完善全量的属性和事件设置能力，因此推荐优先使用AttributeModifier。
接口定义
```typescript
declare interface AttributeModifier<T> {
applyNormalAttribute?(instance: T): void;
applyPressedAttribute?(instance: T): void;
applyFocusedAttribute?(instance: T): void;
applyDisabledAttribute?(instance: T): void;
applySelectedAttribute?(instance: T): void;
}
```
AttributeModifier是一个接口，开发者需要实现其中的applyXxxAttribute方法来实现对应场景的属性设置。Xxx表示多态的场景，支持默认态（Normal）、按压态（Pressed）、焦点态（Focused）、禁用态（Disabled）、选择态（Selected）。T是组件的属性类型，开发者可以在回调中获取到属性对象，通过该对象设置属性。
```typescript
declare class CommonMethod<T> {
attributeModifier(modifier: AttributeModifier<T>): T;
}
```
组件的通用方法增加了attributeModifier方法，支持传入自定义的Modifier。由于组件在实例化时会明确T的类型，所以调用该方法时，T必须指定为组件对应的Attribute类型，或者是CommonAttribute。
使用说明
设置和修改组件属性
AttributeModifier可以分离UI与样式，支持参数传递及业务逻辑编写，并且通过状态变量触发刷新。
```typescript
// button_modifier.ets
export class MyButtonModifier implements AttributeModifier<ButtonAttribute> {
// 可以实现一个Modifier，定义私有的成员变量，外部可动态修改
isDark: boolean = false
// 通过构造函数，创建时传参
constructor(dark?: boolean) {
this.isDark = dark ? dark : false
}
applyNormalAttribute(instance: ButtonAttribute): void {
// instance为Button的属性对象，可以通过instance对象对属性进行修改
if (this.isDark) { // 支持业务逻辑的编写
// 属性变化触发apply函数时，变化前已设置并且变化后未设置的属性会恢复为默认值
instance.backgroundColor('#707070')
} else {
// 支持属性的链式调用
instance.backgroundColor('#17A98D')
.borderColor('#707070')
.borderWidth(2)
}
}
}
```
```typescript
// demo.ets
import { MyButtonModifier } from './button_modifier'
@Entry
@Component
struct attributeDemo {
// 支持用状态装饰器修饰，行为和普通的对象一致
@State modifier: MyButtonModifier = new MyButtonModifier(true);
build() {
Row() {
Column() {
Button("Button")
.attributeModifier(this.modifier)
.onClick(() => {
// 对象的一层属性被修改时，会触发UI刷新，重新执行applyNormalAttribute
this.modifier.isDark = !this.modifier.isDark
})
}
.width('100%')
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170319.15515896963451970746230499284987:50001231000000:2800:A685EA4D0AA26A7ED3EF6A18CEA9F17DB7A93875B2EC452EAE53809263C684E2.gif)
当一个组件上同时使用属性方法和applyNormalAttribute设置相同的属性时，遵循属性覆盖原则，即后设置的属性生效。
```typescript
// button_modifier.ets
export class MyButtonModifier implements AttributeModifier<ButtonAttribute> {
isDark: boolean = false
constructor(dark?: boolean) {
this.isDark = dark ? dark : false
}
applyNormalAttribute(instance: ButtonAttribute): void {
if (this.isDark) {
instance.backgroundColor('#707070')
} else {
instance.backgroundColor('#17A98D')
.borderColor('#707070')
.borderWidth(2)
}
}
}
```
```typescript
// demo.ets
import { MyButtonModifier } from './button_modifier';
@Entry
@Component
struct attributeDemo {
@State modifier: MyButtonModifier = new MyButtonModifier(true);
build() {
Row() {
Column() {
// 先设置属性，后设置modifier，按钮颜色会跟随modifier的值改变
Button("Button")
.backgroundColor('#2787D9')
.attributeModifier(this.modifier)
.onClick(() => {
this.modifier.isDark = !this.modifier.isDark
})
}
.width('100%')
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170319.41438196347586596626729575803806:50001231000000:2800:ED5ADCAEE7F54EB0F2C899642A365F2712B223CF2CECB6FE57983FAF30F53EC9.gif)
当一个组件上多次使用applyNormalAttribute设置不同的Modifier实例时，每次状态变量刷新均会按顺序执行这些实例的方法属性设置，遵循属性覆盖原则，即后设置的属性生效。
```typescript
// button_modifier.ets
export class MyButtonModifier implements AttributeModifier<ButtonAttribute> {
isDark: boolean = false
constructor(dark?: boolean) {
this.isDark = dark ? dark : false
}
applyNormalAttribute(instance: ButtonAttribute): void {
if (this.isDark) {
instance.backgroundColor(Color.Black)
.width(200)
} else {
instance.backgroundColor(Color.Red)
.width(100)
}
}
}
```
```typescript
// button_modifier2.ets
export class MyButtonModifier2 implements AttributeModifier<ButtonAttribute> {
isDark2: boolean = false
constructor(dark?: boolean) {
this.isDark2 = dark ? dark : false
}
applyNormalAttribute(instance: ButtonAttribute): void {
if (this.isDark2) {
instance.backgroundColor('#2787D9')
} else {
instance.backgroundColor('#707070')
}
}
}
```
```typescript
// demo.ets
import { MyButtonModifier } from './button_modifier';
import { MyButtonModifier2 } from './button_modifier2';
@Entry
@Component
struct attributeDemo {
@State modifier: MyButtonModifier = new MyButtonModifier(true);
@State modifier2: MyButtonModifier2 = new MyButtonModifier2(true);
build() {
Row() {
Column() {
Button("Button")
.attributeModifier(this.modifier)
.attributeModifier(this.modifier2)
.onClick(() => {
this.modifier.isDark = !this.modifier.isDark
this.modifier2.isDark2 = !this.modifier2.isDark2
})
}
.width('100%')
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170319.90267142074560781927090152899997:50001231000000:2800:CAF8C8F5D179A0E8BC9FBC696AF9D43A507DC60988E7BE705C8249595E96076F.gif)
设置多态样式、事件
使用AttributeModifier设置多态样式、事件，实现事件逻辑的复用，支持默认态（Normal）、按压态（Pressed）、焦点态（Focused）、禁用态（Disabled）、选择态（Selected）。例如如果需要在组件进入按压态时设置某些属性，就可以通过自定义实现applyPressedAttribute方法完成。
```typescript
// button_modifier.ets
export class MyButtonModifier implements AttributeModifier<ButtonAttribute> {
applyNormalAttribute(instance: ButtonAttribute): void {
// instance为Button的属性对象，设置正常状态下属性值
instance.backgroundColor('#17A98D')
.borderColor('#707070')
.borderWidth(2)
}
applyPressedAttribute(instance: ButtonAttribute): void {
// instance为Button的属性对象，设置按压状态下属性值
instance.backgroundColor('#2787D9')
.borderColor('#FFC000')
.borderWidth(5)
}
}
```
```typescript
// demo.ets
import { MyButtonModifier } from './button_modifier'
@Entry
@Component
struct attributeDemo {
@State modifier: MyButtonModifier = new MyButtonModifier();
build() {
Row() {
Column() {
Button("Button")
.attributeModifier(this.modifier)
}
.width('100%')
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170319.29810400569070434486260291269283:50001231000000:2800:23681DED1D133AFAF1C0E9E4A93592DC9F88702A14D4F72745A907AED7A65AA8.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-user-defined-extension-attributeupdater-V14
爬取时间: 2025-04-27 23:41:03
来源: Huawei Developer
概述
在大量属性频繁更新的场景下，使用状态变量可能导致前端状态管理的计算量过大，并且需要对单个组件进行全量属性更新。尽管可以通过AttributeModifier机制实现按需更新属性，但前端仍会采用一定的diff和reset策略，这可能带来性能问题。
AttributeUpdater作为一个特殊的AttributeModifier，不仅继承了AttributeModifier的功能，还提供了直接获取属性对象的能力。通过属性对象，开发者能够直接更新对应属性，无需经过状态变量。开发者可以利用AttributeUpdater实现自定义的更新策略，从而进一步提升属性更新的性能。
由于AttributeUpdater提供了较高的灵活性，无法限制“单一数据源”的规则，因此在与状态变量同时更新同一属性时，存在相互覆盖的情况。这要求开发者必须确保属性设置的合理性。
接口定义
```typescript
export declare class AttributeUpdater<T, C = Initializer<T>> implements AttributeModifier<T> {
applyNormalAttribute?(instance: T): void;
initializeModifier(instance: T): void;
get attribute(): T | undefined;
updateConstructorParams: C;
}
```
AttributeUpdater实现了AttributeModifier接口，并额外提供了initializeModifier，可以对组件的属性进行初始化。通过attribute属性方法可以获取属性对象，直接更新对应组件的属性。另外也可以直接通过updateConstructorParams更新组件的构造参数。
使用说明
通过modifier直接修改属性
组件初始化完成之后，开发者可以通过AttributeUpdater实例的attribute属性方法，获取到属性对象。通过属性对象直接修改属性，会立即触发组件属性的更新。
```typescript
import { AttributeUpdater } from '@ohos.arkui.modifier'
class MyButtonModifier extends AttributeUpdater<ButtonAttribute> {
// 首次绑定时触发initializeModifier方法，进行属性初始化
initializeModifier(instance: ButtonAttribute): void {
instance.backgroundColor('#2787D9')
.width('50%')
.height(30)
}
}
@Entry
@Component
struct updaterDemo {
modifier: MyButtonModifier = new MyButtonModifier()
build() {
Row() {
Column() {
Button("Button")
.attributeModifier(this.modifier)
.onClick(() => {
// 通过attribute，直接修改组件属性，并立即触发组件属性更新
this.modifier.attribute?.backgroundColor('#17A98D').width('30%')
})
}
.width('100%')
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170320.25978107577175250669814340082522:50001231000000:2800:0E7646600245A4BCEA89C8101ED0CCDC9580809562D8F600DDDB7C8214C14F2C.gif)
通过modifier更新组件的构造参数
可以通过AttributeUpdater实例的updateConstructorParams方法，直接更新组件的构造参数。
```typescript
import { AttributeUpdater } from '@ohos.arkui.modifier'
class MyTextModifier extends AttributeUpdater<TextAttribute, TextInterface> {
initializeModifier(instance: TextAttribute): void {
}
}
@Entry
@Component
struct updaterDemo {
modifier: MyTextModifier = new MyTextModifier()
build() {
Row() {
Column() {
Text("Text")
.attributeModifier(this.modifier)
.fontColor(Color.White)
.fontSize(14)
.border({ width: 1 })
.textAlign(TextAlign.Center)
.lineHeight(20)
.width(200)
.height(50)
.backgroundColor('#2787D9')
.onClick(() => {
// 调用updateConstructorParams方法，直接更新组件的构造参数
this.modifier.updateConstructorParams('Update');
})
}
.width('100%')
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170320.46733078872368142241504206316459:50001231000000:2800:413AE94D9DA79DC1D07414E8A74902DFD26FB5907CD18CF441509B63FB53CA1F.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-mirroring-display-V14
爬取时间: 2025-04-27 23:41:17
来源: Huawei Developer
概述
为满足不同用户的阅读习惯，ArkUI提供了镜像能力。在特定情况下将显示内容在X轴上进行镜像反转，由从左向右显示变成从右向左显示。
| 镜像前 | 镜像后 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170320.40579112110058315693299153173314:50001231000000:2800:572818AC79783D45A60972C1742BAD8FD83C0A240166F8452C0D51047D0691E9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170320.47180180289817180890878716103304:50001231000000:2800:48BB467AB1BC2CA5256C6711F1D5B5D084AD8CDCA0DAECBFA042CB508ECB4472.png)
当组件满足以下任意条件时，镜像能力生效：
1.  组件的direction属性设置为Direction.Rtl。
2.  组件的direction属性设置为Direction.Auto，且当前的系统语言（如维吾尔语）的阅读习惯是从右向左。
基本概念
使用约束
ArkUI 如下能力已默认适配镜像：
| 类别 | 名称 |
| --- | --- |
| 基础组件 | Swiper、Tabs、TabContent、List、Progress、CalendarPicker、CalendarPickerDialog、TextPicker、TextPickerDialog、DatePicker、DatePickerDialog、Grid、WaterFlow、Scroll、ScrollBar、AlphabetIndexer、Stepper、SideBarContainer、Navigation、NavDestination、Rating、Slider、Toggle、Badge、Counter、Chip、SegmentButton、bindMenu、bindContextMenu、TextInput、TextArea、Search、Stack、GridRow、Text、Select、Marquee、Row、Column、Flex、RelativeContainer、ListItemGroup |
| 高级组件 | SelectionMenu 、TreeView 、Filter、SplitLayout、ToolBar、ComposeListItem、EditableTitleBar、ProgressButton、SubHeader 、Popup、Dialog、SwipeRefresher |
| 通用属性 | position、markAnchor、offset、alignRules、borderWidth、borderColor、borderRadius、padding、margin |
| 接口 | AlertDialog、ActionSheet、promptAction.showDialog、promptAction.showToast |
但如下三种场景还需要进行适配：
1.  界面布局、边框设置：关于方向类的通用属性，如果需要支持镜像能力，使用泛化的方向指示词 start/end入参类型替换 left/right、x/y等绝对方向指示词的入参类型，来表示自适应镜像能力。
2.  Canvas组件只有限支持文本绘制的镜像能力。
3.  XComponent组件不支持组件镜像能力。
界面布局和边框设置
目前，以下三类通用属性需要使用新入参类型适配：
位置设置：position、markAnchor、offset、alignRules
边框设置：borderWidth、borderColor、borderRadius
尺寸设置：padding、margin
以position为例，需要把绝对方向x、y描述改为新入参类型start、end的描述，其他属性类似。
自定义绘制Canvas组件
Canvas组件的绘制内容和坐标均不支持镜像能力。已绘制到Canvas组件上的内容并不会跟随系统语言的切换自动做镜像效果。
CanvasRenderingContext2D的文本绘制支持镜像能力，在使用时需要与Canvas组件的通用属性direction（组件显示方向）和CanvasRenderingContext2D的属性direction（文本绘制方向）协同使用。具体规格如下：
| 镜像前 | 镜像后 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170320.30607633151377071758618033607706:50001231000000:2800:E774F28A29E03C936AD53C3EE9DBD35BCBD67516D93DFF674D6D512DE991FD23.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170320.71690424861528770258946790276585:50001231000000:2800:ED05BB169BD10D7B9714B149CA8360DD8582E42EFCDE3447E075FB4BDC4F2FD4.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkui-support-for-aging-adaptation-V14
爬取时间: 2025-04-27 23:41:31
来源: Huawei Developer
基本概念
适老化提供了一种通过鼠标或手指长按的方法来放大所选区域或组件，即如果系统字体大小大于1倍，当用户使用鼠标或手指长按装配了适老化方法的组件，需要从所选区域的组件中提取数据，并放入另一个弹窗组件中展示。该方法的目的在于使组件和组件内部数据（子组件）放大，同时将整体组件在屏幕中央显示，让用户能够更好的观察该组件。
使用约束
-  适老化规则 由于在系统字体大于1倍时，组件并没有默认放大，需要通过配置configuration标签，实现组件放大的适老化功能。
-  如何开启适老化 进入手机设置，点击辅助功能，开启关怀模式。
-  适老化操作 在已经支持适老化能力的组件上长按组件，能够触发弹窗，当用户释放时，适老化操作结束。当设置系统字体大于1倍时，组件自动放大，当系统字体恢复至1倍时组件恢复正常状态。
-  适老化对象 触发适老化操作并提供数据的组件。
-  适老化弹窗目标 可接收并处理适老化数据的组件。
-  弹窗限制 当用户将系统字体设置为2倍以上时，弹窗内容包括icon和文字的放大倍数固定为2倍。
-  联合其他能力 适老化能力可以适配其他能力（如：滑动拖拽）。底部页签（tabBar）组件在触发适老化时，如果用户滑动手指或鼠标可以触发底部页签其他子组件的适老化功能。
适配适老化的组件及触发方式
| 触发方式 | 组件名称 |
| --- | --- |
| 长按组件触发 | SideBarContainer， 底部页签（tabBar），Navigation，NavDestination， Tabs |
| 设置系统字体默认放大 | PickerDialog， Button， Menu， Stepper， BindSheet，TextInput，TextArea，Search，SelectionMenu，Chip，Dialog，Slider， Progress， Badge |
示例
SideBarContainer组件通过长按控制按钮触发适老化弹窗。在系统字体为1倍的情况下，长按控制按钮不能弹窗。在系统字体大于1倍的情况下，长按控制按钮可以弹窗。
```typescript
@Entry
@Component
struct SideBarContainerExample {
@State currentFontSizeScale: number = 1
normalIcon: Resource = $r("app.media.icon")
selectedIcon: Resource = $r("app.media.icon")
@State arr: number[] = [1, 2, 3]
@State current: number = 1
@State title: string = 'Index01';
build() {
SideBarContainer(SideBarContainerType.Embed) {
Column() {
ForEach(this.arr, (item: number) => {
Column({ space: 5 }) {
Image(this.current === item ? this.selectedIcon : this.normalIcon).width(64).height(64)
Text("0" + item)
.fontSize(25)
.fontColor(this.current === item ? '#0A59F7' : '#999')
.fontFamily('source-sans-pro,cursive,sans-serif')
}
.onClick(() => {
this.current = item;
this.title = "Index0" + item;
})
}, (item: string) => item)
}.width('100%')
.justifyContent(FlexAlign.SpaceEvenly)
.backgroundColor($r('sys.color.mask_fifth'))
}
.controlButton({
icons: {
hidden: $r('sys.media.ohos_ic_public_drawer_open_filled'),
shown: $r('sys.media.ohos_ic_public_drawer_close')
}
})
.sideBarWidth(150)
.minSideBarWidth(50)
.maxSideBarWidth(300)
.minContentWidth(0)
.onChange((value: boolean) => {
console.info('status:' + value)
})
.divider({ strokeWidth: '1vp', color: Color.Gray, startMargin: '4vp', endMargin: '4vp' })
}
}
```
切换系统字体前后长按已经支持适老化能力的组件，有如下效果：
| 系统字体为一倍（适老化能力开启前） | 系统字体为1.75倍（适老化能力开启后） |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170320.11541184911835410005962030242856:50001231000000:2800:77681D20B4084CC09FA3EE20742D734C5C647D1C1EF172888FDD5516A7C8AF4D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170320.54339084577231959537770131202179:50001231000000:2800:36FCF7A00BD4A43984A00613C456E9AF21368F6E68E43D70F8AA098E000EA644.png)
TextPickerDialog组件通过设置系统字体大小触发适老化弹窗。在系统字体为1倍的情况下，适老化不触发；在系统字体大于1倍的情况下，适老化触发。
```typescript
@Entry
@Component
struct TextPickerExample {
private select: number | number[] = 0;
private cascade: TextCascadePickerRangeContent[] = [
{
text: '辽宁省',
children: [{ text: '沈阳市', children: [{ text: '沈河区' }, { text: '和平区' }, { text: '浑南区' }] },
{ text: '大连市', children: [{ text: '中山区' }, { text: '金州区' }, { text: '长海县' }] }]
},
{
text: '吉林省',
children: [{ text: '长春市', children: [{ text: '南关区' }, { text: '宽城区' }, { text: '朝阳区' }] },
{ text: '四平市', children: [{ text: '铁西区' }, { text: '铁东区' }, { text: '梨树县' }] }]
},
{
text: '黑龙江省',
children: [{ text: '哈尔滨市', children: [{ text: '道里区' }, { text: '道外区' }, { text: '南岗区' }] },
{ text: '牡丹江市', children: [{ text: '东安区' }, { text: '西安区' }, { text: '爱民区' }] }]
}
]
@State v: string = '';
@State showTriggered: string = '';
private triggered: string = '';
private maxLines: number = 3;
linesNum(max: number): void {
let items: string[] = this.triggered.split('').filter(item => item != '');
if (items.length > max) {
this.showTriggered = items.slice(-this.maxLines).join('');
} else {
this.showTriggered = this.triggered;
}
}
build() {
Column() {
Button("TextPickerDialog.show:" + this.v)
.onClick(() => {
TextPickerDialog.show({
range: this.cascade,
selected: this.select,
onAccept: (value: TextPickerResult) => {
this.select = value.index
console.log(this.select + '')
this.v = value.value as string
console.info("TextPickerDialog:onAccept()" + JSON.stringify(value))
if (this.triggered != '') {
this.triggered += `onAccept(${JSON.stringify(value)})`;
} else {
this.triggered = `onAccept(${JSON.stringify(value)})`;
}
this.linesNum(this.maxLines);
},
onCancel: () => {
console.info("TextPickerDialog:onCancel()")
if (this.triggered != '') {
this.triggered += `onCancel()`;
} else {
this.triggered = `onCancel()`;
}
this.linesNum(this.maxLines);
},
onChange: (value: TextPickerResult) => {
console.info("TextPickerDialog:onChange()" + JSON.stringify(value))
if (this.triggered != '') {
this.triggered += `onChange(${JSON.stringify(value)})`;
} else {
this.triggered = `onChange(${JSON.stringify(value)})`;
}
this.linesNum(this.maxLines);
},
})
})
.margin({ top: 60 })
}
}
}
```
| 系统字体为一倍（适老化能力开启前） | 系统字体为1.75倍（适老化能力开启后） |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170320.15942043157556365301495186091868:50001231000000:2800:019308C994ACAC2BCE0A4E9915A5FC2736B00E908BFFEC3FE31A72CCBC4F5F55.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170320.05321547441452412197291592769506:50001231000000:2800:DFC7A6D631A8949377ABF6793B54F1A76DADF9CC9D06398F0D4C837E35EE427E.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-theme-V14
爬取时间: 2025-04-27 23:41:45
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-dark-light-color-adaptation-V14
爬取时间: 2025-04-27 23:41:58
来源: Huawei Developer
概述
当前系统存在深浅色两种显示模式，为了给用户更好的使用体验，应用应适配深浅色模式。从应用与系统配置关联的角度来看，适配深浅色模式可以分为下面两种情况：
应用跟随系统的深浅色模式
应用主动设置深浅色模式
应用跟随系统的深浅色模式
1.  颜色适配 自定义资源实现 resources目录下增加深色模式限定词目录（命名为dark）并新建color.json文件，可显示深色模式颜色资源的配置。详细请参考资源分类与访问。 图1 resources目录结构示意 例如，开发者可在这两个color.json中定义同名配色定义并赋予不同的色值。 base/element/color.json文件： dark/element/color.json文件： 通过系统资源实现 开发者可直接使用的系统预置资源，即分层参数，同一资源ID在设备类型、深浅色等不同配置下有不同的取值。通过使用系统资源，不同的开发者可以开发出具有相同视觉风格的应用，不需要自定义两份颜色资源，在深浅色模式下也会自动切换成不同的颜色值。例如，开发者可调用系统资源中的文本主要配色来定义应用内文本颜色。
```json
{
"color": [
{
"name": "app_title_color",
"value": "#000000"
}
]
}
```
2.  自定义资源实现 resources目录下增加深色模式限定词目录（命名为dark）并新建color.json文件，可显示深色模式颜色资源的配置。详细请参考资源分类与访问。 图1 resources目录结构示意 例如，开发者可在这两个color.json中定义同名配色定义并赋予不同的色值。 base/element/color.json文件： dark/element/color.json文件：
```json
{
"color": [
{
"name": "app_title_color",
"value": "#000000"
}
]
}
```
3.  通过系统资源实现 开发者可直接使用的系统预置资源，即分层参数，同一资源ID在设备类型、深浅色等不同配置下有不同的取值。通过使用系统资源，不同的开发者可以开发出具有相同视觉风格的应用，不需要自定义两份颜色资源，在深浅色模式下也会自动切换成不同的颜色值。例如，开发者可调用系统资源中的文本主要配色来定义应用内文本颜色。
```typescript
Text('使用系统定义配色')
.fontColor($r('sys.color.ohos_id_color_text_primary'))
```
4.  图片资源适配 采用资源限定词目录的方式。参照颜色适配的方法，需要将深色模式下对应的同名图片放到 dark/media 目录下，再通过$r的方式加载图片资源的key值，系统做深浅色模式切换时，会自动加载对应资源文件中的value值。 对于 SVG 格式的一些简单图标，可以使用fillColor属性配合系统资源改变图片的绘制颜色。不通过两套图片资源的方式，也可以实现深浅色模式适配。
```typescript
Image($r('app.media.pic_svg'))
.width(50)
.fillColor($r('sys.color.ohos_id_color_text_primary'))
```
5.  Web组件适配 Web组件支持对前端页面进行深色模式配置，可参考Web组件深色模式进行相关配置。
6.  应用监听深浅色模式切换事件 应用可以主动监听系统深浅色模式变化，进行其他类型的资源初始化等自定义逻辑。无论应用是否跟随系统深浅色模式变化，该监听方式均可生效。 a. 在 AbilityStage 的 onCreate() 生命周期中获取APP当前的颜色模式并保存到 AppStorage。 b. 在 AbilityStage 的 onConfigurationUpdate() 生命周期中获取最新变更的颜色模式并刷新到 AppStorage。 c. 在Page中通过 @StorageProp + @Watch 方式获取当前最新颜色并监听设备深色模式变化。 d. 在 aboutToAppear 初始化函数中根据当前最新颜色模式刷新状态变量。 e. 在 @Watch 回调函数中执行同样的适配逻辑。
```typescript
onCreate(): void {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
AppStorage.setOrCreate('currentColorMode', this.context.config.colorMode);
}
```
-  自定义资源实现 resources目录下增加深色模式限定词目录（命名为dark）并新建color.json文件，可显示深色模式颜色资源的配置。详细请参考资源分类与访问。 图1 resources目录结构示意 例如，开发者可在这两个color.json中定义同名配色定义并赋予不同的色值。 base/element/color.json文件： dark/element/color.json文件：
```json
{
"color": [
{
"name": "app_title_color",
"value": "#000000"
}
]
}
```
-  通过系统资源实现 开发者可直接使用的系统预置资源，即分层参数，同一资源ID在设备类型、深浅色等不同配置下有不同的取值。通过使用系统资源，不同的开发者可以开发出具有相同视觉风格的应用，不需要自定义两份颜色资源，在深浅色模式下也会自动切换成不同的颜色值。例如，开发者可调用系统资源中的文本主要配色来定义应用内文本颜色。
```typescript
Text('使用系统定义配色')
.fontColor($r('sys.color.ohos_id_color_text_primary'))
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170320.65053213407733213005685296312996:50001231000000:2800:A0923F69CB9D01DE13089F9D1EF33A6CF2E99EB081A10C2AD15B07CBF3FE7F87.png)
应用主动设置深浅色模式
应用默认配置为跟随系统切换深浅色模式，如不希望应用跟随系统深浅色模式变化，可主动设置应用的深浅色风格。设置后，应用的深浅色模式固定，不会随系统改变。
```typescript
onCreate(): void {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
this.context.getApplicationContext().setColorMode(ConfigurationConstant.ColorMode.COLOR_MODE_DARK);
}
```
系统默认判断规则
1.  如果应用调用上述setColorMode接口主动设置了深浅色，则以接口效果优先。
2.  应用没有调用setColorMode接口时： 如果应用工程dark目录下有深色资源，则系统内置组件在深色模式下会自动切换成为深色。 如果应用工程dark目录下没有任何深色资源，则系统内置组件在深色模式下仍会保持浅色体验。
3.  如果应用工程dark目录下有深色资源，则系统内置组件在深色模式下会自动切换成为深色。
4.  如果应用工程dark目录下没有任何深色资源，则系统内置组件在深色模式下仍会保持浅色体验。
-  如果应用工程dark目录下有深色资源，则系统内置组件在深色模式下会自动切换成为深色。
-  如果应用工程dark目录下没有任何深色资源，则系统内置组件在深色模式下仍会保持浅色体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170320.72936832854502831585565881980436:50001231000000:2800:3D99CA1283C962C64F4A95684F2F874AFE5FFB89C0956EBD4B8DD8734DB1177A.png)
如果应用全部都是由系统内置组件/系统颜色开发，且想要跟随系统切换深浅色模式时，请参考以下示例修改代码来保证应用体验。
```typescript
onCreate(): void {
this.context.getApplicationContext().setColorMode(ConfigurationConstant.ColorMode.COLOR_MODE_NOT_SET);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/theme_skinning-V14
爬取时间: 2025-04-27 23:42:13
来源: Huawei Developer
概述
对于采用ArkTS开发的应用，提供了应用内组件的主题换肤功能，支持局部的深浅色切换及动态换肤。目前，该功能只支持设置应用内主题换肤，暂不支持在UIAbility或窗口层面进行主题设置，同时也不支持C-API和Node-API。
自定义主题色
当应用需要使用换肤功能时，应自定义主题颜色。CustomTheme用于自定义主题色的内容，其属性可选，仅需要复写需修改的部分，未修改内容将继承系统默认设置，可参考系统默认的token颜色值。请参照以下示例自定义主题色：
```typescript
import { CustomColors, CustomTheme } from '@kit.ArkUI'
export class AppColors implements CustomColors {
//自定义主题色
brand: ResourceColor = '#FF75D9';
}
export class AppTheme implements CustomTheme {
public colors: AppColors = new AppColors()
}
export let gAppTheme: CustomTheme = new AppTheme()
```
设置应用内组件自定义主题色
-  可以在页面入口处统一设置应用内组件自定义主题色，但需确保在页面build前执行ThemeControl。 其中，onWillApplyTheme回调函数用于使自定义组件获取当前生效的Theme对象。
```typescript
import { Theme, ThemeControl } from '@kit.ArkUI'
import { gAppTheme } from './AppTheme'
//在页面build前执行ThemeControl
ThemeControl.setDefaultTheme(gAppTheme)
@Entry
@Component
struct DisplayPage {
@State menuItemColor: ResourceColor = $r('sys.color.background_primary')
onWillApplyTheme(theme: Theme) {
this.menuItemColor = theme.colors.backgroundPrimary;
}
build() {
Column() {
List({ space: 10 }) {
ListItem() {
Column({ space: '5vp' }) {
Text('Color mode')
.margin({ top: '5vp', left: '14fp' })
.width('100%')
Row() {
Column() {
Text('Light')
.fontSize('16fp')
.textAlign(TextAlign.Start)
.alignSelf(ItemAlign.Center)
Radio({ group: 'light or dark', value: 'light' })
.checked(true)
}
.width('50%')
Column() {
Text('Dark')
.fontSize('16fp')
.textAlign(TextAlign.Start)
.alignSelf(ItemAlign.Center)
Radio({ group: 'light or dark', value: 'dark' })
}
.width('50%')
}
}
.width('100%')
.height('90vp')
.borderRadius('10vp')
.backgroundColor(this.menuItemColor)
}
ListItem() {
Column() {
Text('Brightness')
.width('100%')
.margin({ top: '5vp', left: '14fp' })
Slider({ value: 40, max: 100 })
}
.width('100%')
.height('70vp')
.borderRadius('10vp')
.backgroundColor(this.menuItemColor)
}
ListItem() {
Column() {
Row() {
Column({ space: '5vp' }) {
Text('Touch sensitivity')
.fontSize('16fp')
.textAlign(TextAlign.Start)
.width('100%')
Text('Increase the touch sensitivity of your screen' +
' for use with screen protectors')
.fontSize('12fp')
.fontColor(Color.Blue)
.textAlign(TextAlign.Start)
.width('100%')
}
.alignSelf(ItemAlign.Center)
.margin({ left: '14fp' })
.width('75%')
Toggle({ type: ToggleType.Switch, isOn: true })
.margin({ right: '14fp' })
.alignSelf(ItemAlign.Center)
}
.width('100%')
.height('80vp')
}
.width('100%')
.borderRadius('10vp')
.backgroundColor(this.menuItemColor)
}
}
}
.padding('10vp')
.backgroundColor('#dcdcdc')
.width('100%')
.height('100%')
}
}
```
-  在UIAbility中设置ThemeControl，需要在onWindowStageCreate()方法中setDefaultTheme，设置应用内组件的自定义主题色。
```typescript
import {AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { window, CustomColors, ThemeControl } from '@kit.ArkUI';
class AppColors implements CustomColors {
fontPrimary = 0xFFD53032
iconOnPrimary = 0xFFD53032
iconFourth = 0xFFD53032
}
const abilityThemeColors = new AppColors();
export default class EntryAbility extends UIAbility {
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
}
onDestroy() {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
}
onWindowStageCreate(windowStage: window.WindowStage) {
// Main window is created, set main page for this ability
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
windowStage.loadContent('pages/Index', (err, data) => {
if (err.code) {
hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
return;
}
hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
// 在onWindowStageCreate()方法中setDefaultTheme
ThemeControl.setDefaultTheme({ colors: abilityThemeColors })
hilog.info(0x0000, 'testTag', '%{public}s', 'ThemeControl.setDefaultTheme done');
});
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170320.88205129630512236764711778965967:50001231000000:2800:323D82D76958F8620DDB44727538F621E0B0F0896454F43E7CA02D4F208471DA.png)
如果setDefaultTheme的参数为undefined时，默认token值对应的色值参考系统缺省token色值。
设置应用局部页面自定义主题风格
通过设置WithTheme，将自定义主题Theme的配色应用于内部组件的默认样式。在WithTheme的作用范围内，组件的配色会根据Theme的配色进行调整。
如示例所示，使用WithTheme({ theme: this.myTheme })可将作用域内组件的配色设置为自定义主题风格。后续可以通过更新this.myTheme来更换主题风格。onWillApplyTheme回调函数用于使自定义组件能够获取当前生效的Theme对象。
```typescript
import { CustomColors, CustomTheme, Theme } from '@kit.ArkUI'
class AppColors implements CustomColors {
fontPrimary: ResourceColor = $r('app.color.brand_purple')
backgroundEmphasize: ResourceColor = $r('app.color.brand_purple')
}
class AppColorsSec implements CustomColors {
fontPrimary: ResourceColor = $r('app.color.brand')
backgroundEmphasize: ResourceColor = $r('app.color.brand')
}
class AppTheme implements CustomTheme {
public colors: AppColors = new AppColors()
}
class AppThemeSec implements CustomTheme {
public colors: AppColors = new AppColorsSec()
}
@Entry
@Component
struct DisplayPage {
@State customTheme: CustomTheme = new AppTheme()
@State message: string = '设置应用局部页面自定义主题风格'
count = 0;
build() {
WithTheme({ theme: this.customTheme }) {
Row(){
Column() {
Text('WithTheme')
.fontSize(30)
.margin({bottom: 10})
Text(this.message)
.margin({bottom: 10})
Button('change theme').onClick(() => {
this.count++;
if (this.count > 1) {
this.count = 0;
}
switch (this.count) {
case 0:
this.customTheme = new AppTheme();
break;
case 1:
this.customTheme = new AppThemeSec();
break;
}
})
}
.width('100%')
}
.height('100%')
.width('100%')
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.24303910112509528666364263511812:50001231000000:2800:A90903E98436A4BEEB89D4E6CE5B5B7B71050FCF94F1A16C29A0E3E13534D5FE.gif)
设置应用页面局部深浅色
通过WithTheme可以设置三种颜色模式，跟随系统模式，浅色模式和深色模式。
在WithTheme的作用范围内，组件的样式资源值会根据指定的模式，读取对应的深浅色模式系统和应用资源值。这意味着，在WithTheme作用范围内，组件的配色会根据所指定的深浅模式进行调整。
如下面的示例所示，通过WithTheme({ colorMode: ThemeColorMode.DARK })，可以将作用范围内的组件设置为深色模式。
设置局部深浅色时，需要添加dark.json资源文件，深浅色模式才会生效。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.16387303567991422355746711723772:50001231000000:2800:58B70E52D5CE8C7A44D815EAB9CAB4B587D0EC1F6E17D3C810E2EC1A30D677A0.png)
dark.json数据示例：
```typescript
{
"color": [
{
"name": "start_window_background",
"value": "#FFFFFF"
}
]
}
```
```typescript
@Entry
@Component
struct DisplayPage {
@State message: string = 'Hello World';
@State colorMode: ThemeColorMode = ThemeColorMode.DARK;
build() {
WithTheme({ colorMode: this.colorMode }) {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Button('Switch ColorMode').onClick(() => {
if (this.colorMode === ThemeColorMode.LIGHT) {
this.colorMode = ThemeColorMode.DARK;
} else if (this.colorMode === ThemeColorMode.DARK) {
this.colorMode = ThemeColorMode.LIGHT;
}
})
}
.width('100%')
}
.backgroundColor($r('sys.color.background_primary'))
.height('100%')
.expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.END, SafeAreaEdge.BOTTOM, SafeAreaEdge.START])
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.95983748576262650690077865585924:50001231000000:2800:ADBAC876EBC8FEE7CB79ADE76D76A5423265E471B442D8825DD7118E89934068.png)
系统缺省token色值
| Token | 场景类别 | Light |  | Dark |  |
| --- | --- | --- | --- | --- | --- |
| theme.colors.brand | 品牌色 | #ff0a59f7 |  | #ff317af7 |  |
| theme.colors.warning | 一级警示色 | #ffe84026 |  | #ffd94838 |  |
| theme.colors.alert | 二级警示色 | #ffed6f21 |  | #ffdb6b42 |  |
| theme.colors.confirm | 确认色 | #ff64bb5c |  | #ff5ba854 |  |
| theme.colors.fontPrimary | 一级文本 | #e5000000 |  | #e5ffffff |  |
| theme.colors.fontSecondary | 二级文本 | #99000000 |  | #99ffffff |  |
| theme.colors.fontTertiary | 三级文本 | #66000000 |  | #66ffffff |  |
| theme.colors.fontFourth | 四级文本 | #33000000 |  | #33ffffff |  |
| theme.colors.fontEmphasize | 高亮文本 | #ff0a59f7 |  | #ff317af7 |  |
| theme.colors.fontOnPrimary | 一级文本反色 | #ffffffff |  | #ff000000 |  |
| theme.colors.fontOnSecondary | 二级文本反色 | #99ffffff |  | #99000000 |  |
| theme.colors.fontOnTertiary | 三级文本反色 | #66ffffff |  | #66000000 |  |
| theme.colors.fontOnFourth | 四级文本反色 | #33ffffff |  | #33000000 |  |
| theme.colors.iconPrimary | 一级图标 | #e5000000 |  | #e5ffffff |  |
| theme.colors.iconSecondary | 二级图标 | #99000000 |  | #99ffffff |  |
| theme.colors.iconTertiary | 三级图标 | #66000000 |  | #66ffffff |  |
| theme.colors.iconFourth | 四级图标 | #33000000 |  | #33ffffff |  |
| theme.colors.iconEmphasize | 高亮图标 | #ff0a59f7 |  | #ff317af7 |  |
| theme.colors.iconSubEmphasize | 高亮辅助图标 | #660a59f7 |  | #66317af7 |  |
| theme.colors.iconOnPrimary | 一级图标反色 | #ffffffff |  | #ff000000 |  |
| theme.colors.iconOnSecondary | 二级图标反色 | #99ffffff |  | #99000000 |  |
| theme.colors.iconOnTertiary | 三级图标反色 | #66ffffff |  | #66000000 |  |
| theme.colors.iconOnFourth | 四级图标反色 | #33ffffff |  | #33000000 |  |
| theme.colors.backgroundPrimary | 一级背景（实色/不透明色） | #ffffffff |  | #ffe5e5e5 |  |
| theme.colors.backgroundSecondary | 二级背景（实色/不透明色） | #fff1f3f5 |  | #ff191a1c |  |
| theme.colors.backgroundTertiary | 三级背景（实色/不透明色） | #ffe5e5ea |  | #ff202224 |  |
| theme.colors.backgroundFourth | 四级背景（实色/不透明色） | #ffd1d1d6 |  | #ff2e3033 |  |
| theme.colors.backgroundEmphasize | 高亮背景（实色/不透明色） | #ff0a59f7 |  | #ff317af7 |  |
| theme.colors.compForegroundPrimary | 前背景 | #ff000000 |  | #ffe5e5e5 |  |
| theme.colors.compBackgroundPrimary | 白色背景 | #ffffffff |  | #ffffffff |  |
| theme.colors.compBackgroundPrimaryTran | 白色透明背景 | #ffffffff |  | #33ffffff |  |
| theme.colors.compBackgroundPrimaryContrary | 常亮背景 | #ffffffff |  | #ffe5e5e5 |  |
| theme.colors.compBackgroundGray | 灰色背景 | #fff1f3f5 |  | #ffe5e5ea |  |
| theme.colors.compBackgroundSecondary | 二级背景 | #19000000 |  | #19ffffff |  |
| theme.colors.compBackgroundTertiary | 三级背景 | #0c000000 |  | #0cffffff |  |
| theme.colors.compBackgroundEmphasize | 高亮背景 | #ff0a59f7 |  | #ff317af7 |  |
| theme.colors.compBackgroundNeutral | 黑色中性高亮背景 | #ff000000 |  | #ffffffff |  |
| theme.colors.compEmphasizeSecondary | 20%高亮背景 | #330a59f7 |  | #33317af7 |  |
| theme.colors.compEmphasizeTertiary | 10%高亮背景 | #190a59f7 |  | #19317af7 |  |
| theme.colors.compDivider | 分割线颜色 | #33000000 |  | #33ffffff |  |
| theme.colors.compCommonContrary | 通用反色 | #ffffffff |  | #ff000000 |  |
| theme.colors.compBackgroundFocus | 获焦态背景色 | #fff1f3f5 |  | #ff000000 |  |
| theme.colors.compFocusedPrimary | 获焦态一级反色 | #e5000000 |  | #e5ffffff |  |
| theme.colors.compFocusedSecondary | 获焦态二级反色 | #99000000 |  | #99ffffff |  |
| theme.colors.compFocusedTertiary | 获焦态三级反色 | #66000000 |  | #66ffffff |  |
| theme.colors.interactiveHover | 通用悬停交互式颜色 | #0c000000 |  | #0cffffff |  |
| theme.colors.interactivePressed | 通用按压交互式颜色 | #19000000 |  | #19ffffff |  |
| theme.colors.interactiveFocus | 通用获焦交互式颜色 | #ff0a59f7 |  | #ff317af7 |  |
| theme.colors.interactiveActive | 通用激活交互式颜色 | #ff0a59f7 |  | #ff317af7 |  |
| theme.colors.interactiveSelect | 通用选择交互式颜色 | #33000000 |  | #33ffffff |  |
| theme.colors.interactiveClick | 通用点击交互式颜色 | #19000000 |  | #19ffffff |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.08401246721800838690608757414304:50001231000000:2800:5F063DF531DE4ED67BD0D2A68B4253EC53C409848EC493B618C8D38860DAA498.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.02676840411952860990063647626442:50001231000000:2800:5CE206809AB8B0C807FBD8753AC07FA278C98B9C261E1D30B0BDBB5602816E2C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.59777580917209197827905728228734:50001231000000:2800:2C83E283646C4877277EA9F65D8BC25DB00C319415D97EBAB2F211C93DE50A5A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.08233734338393900300964384171511:50001231000000:2800:11BCF73962790245CF19E296EC0C1FF10CB9C31331509EB326C5DB8D699F854D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.31073003966094991909302192240171:50001231000000:2800:47C6DDEE25984DE76480CB5D274EF4DDB668FE3B908B612A47B8B3CF284169E0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.00939527973715064111752187138521:50001231000000:2800:D4D7281D30FA6DAE193D07927F21CEE75FB275AA9F7CE7856A6389C610910953.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.22484668550396165297941897497368:50001231000000:2800:97F196923133AE7E187A0BB2BAB0B02516A3D7495007315E2A144F740A7D8548.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.50278518752449871865894287891066:50001231000000:2800:3FFDBD6E18A558AF83A62C02328613E40B8E4E1E2A3C1EC47DBE83BF8CAD171D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.81797649722132595903821269444739:50001231000000:2800:94BF39A177FA611F049A4530CA4B7FC43F9FA8D295C9C69527F35C06B9E98E50.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.65123727719491505191747766071579:50001231000000:2800:BECCCEDAECF2F65C30C21F65BFC41FDAF0EE5C31CDF192B19099E763246C328D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.03554889938221566304461910558280:50001231000000:2800:EF3DD1D63D0BC8C790396E7C686E033E4F978451B283BE5C47BB4200836EC957.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.57853965289852174386930054936159:50001231000000:2800:EABB5355DB6DE2F5E6B5634361C3D0C3EAA942442ED7D1B0AFFFAA6015E3E6D2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170321.38142259185226212018770991656162:50001231000000:2800:A9A7F3D3969229375527EC71C3BCE336A504DC7067AB569C26EC75F5BCC5B8A3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.65073641869787209030082216826621:50001231000000:2800:8D6758E1A65C2FF430540203A675C5EBC477B0146DFB37AA0D32DCFDA5AE8636.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.85712958725572272115595528933587:50001231000000:2800:B3DA2E179CFADAC3FDD4FBF36948AA2F060C11C9342FFD710B63AE93CC161FF1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.10392510301286747217804893065303:50001231000000:2800:B9C91C9509235F53CC175300F850F41C5A88805C98EA68E6BB167018CE8834C2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.39057393458045336856573532692591:50001231000000:2800:FF87F86C3F5B79CDBAEA2EA3C5B3AE3A8757DE76892F6BB8B4293CEA756F8E23.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.83141604886712142400070070058157:50001231000000:2800:E8F2B27B9345BD976DDD6B6D1B811FD1F09810693D515FF0D81B369DED5CD278.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.14587810104462128395976623527505:50001231000000:2800:2B042A37EB8AF2166011E2DC6AFE4F08ACB19FD9C4A395EB1D53BC38C0A2B875.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.63799951288789016733044575731679:50001231000000:2800:B0F5CA81586064008504975C3DA5B01C2F91E08E91B0E07F9561A81C945DC763.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.79123051869710659242060168574290:50001231000000:2800:223F10BBAA4BCF645A90E52AA14FE36B620564BB845730A2F269448A09425FB7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.63900403331856128614131014319414:50001231000000:2800:53CDCB11DB28D67BAE9CB13D07C8CE3BE89D24FFC8D80E432ADE2103B2EBED68.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.65716805209056892297777951049673:50001231000000:2800:DB0ED61F1B96A1FD1821490043CBAE2B5945BE093F773245C76404A173A7192B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.29731080387734070775665619961968:50001231000000:2800:62E85EB252EC8F9CFC33779EEE89F19E9E16D281FD5A87E54EF512E68A6C9CED.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.68670421020182838600328074970636:50001231000000:2800:51DCADA0F2425AE21C783C888DDCC05B9A058A97192BF674B1B529599FCBB8DD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.17252339918900445508065122480585:50001231000000:2800:B7421EFAB1B8DA524EAC9DF57A1D48A2903A8533503AB03E2F8D8C79A642DDDD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.10464905600535687945594930621190:50001231000000:2800:7837D8700863F889843DEE4E326450C0C0B00FFFB070AFAF5A29A5D77C0D8BE5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.97201064962492970492060728781377:50001231000000:2800:7CD774E093E7BA1A3BE9CCA5B7F8A95AE0D7B085EC4BB0DEDD5A410A720C6044.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.14177393562128633006667826155136:50001231000000:2800:2908C5F63ADB199704A8271ECA5B61A418B8B0EE460E69CAA3574CE8EE25064E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170322.17442918611190217254696795047471:50001231000000:2800:1409DFC7907022DBC5D155F80A6517D9110449ED618C2DA606B599E54B3B11FC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.24344291374166335964134174606578:50001231000000:2800:1E3D7428347EC1E6CBBB867A6A789CD2831D255E4B4BF67CC66400B679EFEAEB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.10729582928397585474978460488080:50001231000000:2800:62FCAFF6BA482C0C7C710767F59DC421D060D65D576C09C9C960D309383C76E6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.53603385642623687564018869499245:50001231000000:2800:3EEC2A773E62F599146688B1D4CF2A385A1E135A4D101D6E4FD5D029F2CFB9E3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.39020671221945870539170654202241:50001231000000:2800:4F84FC806561A08BB610B93617B3450CBDB1CB939204647E15ADE485CE431463.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.59147194684474967329291390226310:50001231000000:2800:F108C480818CE32B5EAF4FF6875047EEEF98B68477F600E79B09BCCB9D4BA135.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.05540304769268057265903140669483:50001231000000:2800:BE51A520958BF4F52E5DE31DD498C1137CD1BEF60C5B5EF054955D2B7BA531F0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.68813072803592641559523470408863:50001231000000:2800:18049530D99476F6D2E7343502101B81EB4A9F60AEC88654256372D420488B00.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.44400951356387689273792414639112:50001231000000:2800:B11D12F2EB235A47D1111309E4541F866671B7EEC25CC39A706C4102109A9B04.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.48514591542649191702721973101836:50001231000000:2800:0F37D8E675CCB3F32716F6424FD75AFA83A47E01F1A3DEFCE9E72C03C85BBF46.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.26458102418454929459266464144312:50001231000000:2800:9FA69F98E3B7E02E0AE6A8F5326991E62728C67A9936CE8578FB3547BB2A5B27.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.62183074762401535274458953610687:50001231000000:2800:EC8B897939FF17101F06B91E2701AEA0FBA2E3C632005F26875E2D6D3077B6A2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.33868894662269587396473662471840:50001231000000:2800:3C0619F71B5DB4B15590116DB8E092397128BFF201F39EC34E92DF6891E24D69.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.58963673545171423908588992564094:50001231000000:2800:A59D20F15F8056C9298BF40D9F535FDDB9039EB9497F1245E5F7812FD77324D4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.67752440436746939798777502849148:50001231000000:2800:893616DA8879C60E618C838F7AC18FF3452E040A9C2124BCE58E1D0C68764227.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.50115550484387343438390841579537:50001231000000:2800:0F985E225AF3C88BA8BC3C51E1FDA98BFF5C4920C0AAC6E36C657921CFEFC0D7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170323.10083372612880738822032891845859:50001231000000:2800:177EA47FCF8D1DCD154F587BA752CCB5F960BAF6C302BA99B4C85CD8FCC6AC45.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.08886919228091353531164868744726:50001231000000:2800:7B4E7193B2508921F6FCF45CE82CB3B42E49C07058D12DE5BF523E471993D3FC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.60217850525720639368818450258106:50001231000000:2800:3AA3FE37E37113269FBF12065915CDE5BB8AF879B765AB75A5366FFE86A1BD35.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.54202866524638531873580276814853:50001231000000:2800:E39A1DEBA00059CBA8A988AD97FDBA2AF519B721D2DE59FDED5EED23C4EDB217.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.77150901342464891071072215233231:50001231000000:2800:6E36E7E272921AECC3D7A1A88ED76568DE534C7E77A23B3ACD6F6980F43C96F2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.84034870444538632398380860778036:50001231000000:2800:37AC5ED929B1D7AC3350AE90E2E689E1753C7CD42B5FF4DEDCAF5F66842F8F25.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.64265436455362921922430327931597:50001231000000:2800:7F3107D25E9C2486DA832E33A1C11D3A9D8E3E8892DD07934B7ACBE14C1D08CA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.43171381489654023009778547733351:50001231000000:2800:A38E9BF25F264DABDD98601955B35A1DD295C20F6AD4658AF8079E7200C118EF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.79596716749561592550530783396603:50001231000000:2800:DE80956F745D33392855D8E965769ADEF2B9F0211B866B9020F053170A355F4D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.83346606558438179047249915567918:50001231000000:2800:B3BE525AA08A8A5B4E2FA613D870B10EA7B3A6F5EC85F0D96AB6925073E2D0AB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.74131197605679742510092553415409:50001231000000:2800:D38F9BF8CB20A3DD34CB48C0CDF20F09EA5E69A8A328657F0953EBF055F9B36B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.82938572474048597101959168155595:50001231000000:2800:6B62A38F28969F049997C3110B6B1B1F94B1912D45043056AC689124A566C138.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.94737633298612345759364985983616:50001231000000:2800:6F43723F22F5299A338692386D62EC136CDEA8A243F921FFC45341B22D781E99.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.50173347926103214346167507092070:50001231000000:2800:31102055C672222FEFAA14AAA35947E036FBA4175A583FD10DD9A843E574B242.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.37298082672654882917463717191109:50001231000000:2800:6F60EEC122376B453760CC64E876675036F91036EDFFFC262E034555A1FCB21F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.01921506009775708709592145792017:50001231000000:2800:85AE02B1AB9C8C0CEF75262AC4454CA880AEFDE2D635EB7195B96452A44255E7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.99729333731646193313815241437657:50001231000000:2800:E64BEC2C4D4C19B1673818D65766876F0AF977DC3D29A1AE1D94198F7C2C2963.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170324.97642272773811494157575478456705:50001231000000:2800:AB06CF8715019026E0039805D75DA4780AAC196702A0D5162C7339740DBE6E16.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.04097008604038311308179656007754:50001231000000:2800:045E65995007913992B8C6E2DC6A3AE76C6A2B9B6A6BEA0CAC6F7F619C085AF6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.30623398290646243382436923411001:50001231000000:2800:6162CAEE27B5B1C6FFA8F0CCCFE38EC52926DCA75685B2C1D0EF7F8A76F9D91E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.31194203221552554379302330819565:50001231000000:2800:3B1BD73706A18053AD0144557B7E24ACA73C2E5C290F3B62B90C012EB0AC3E5C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.81464666055225919560048770186226:50001231000000:2800:C5A416FC1422DC8F900859E9527EF3E4D2CB1DB16B6C6BB506CF4372B200EFDB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.86629208272891994051455018300269:50001231000000:2800:DAF2C4A73AB8602B95F6A4E1C401528DE195576026B092D73C468948BA52FC12.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.03713466228465900958664352285655:50001231000000:2800:66346555E35F5FDE1CA60F6D684885169869E9E2F7DBED97F122D29DA5965B0C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.61149556116952888063475138597036:50001231000000:2800:CC69AC5EBF02D4DF42CA9F7E66BDD2813111B15D0F9A040815EC81E71AA02AB0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.07872925809818998419978123637084:50001231000000:2800:729FEA5CA7A28B5AF5EE16B9D99E773C1158A71FB0EDB9A69CD25001AE91C639.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.31305986203771230130914592070390:50001231000000:2800:841B139A089B05ADFBB8DD3DABCD9BE1F0A4127E310B2C596F6B0F8374545B78.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.41228745753005789069956846309171:50001231000000:2800:668E21505E5951094DC54CF662932A3CE62CBF72F945FFE0BC78D11F1D31C64D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.94339578326585826979593277062967:50001231000000:2800:CCA12624578313E507F7264ADA9D2C53A32C13EBDC1BC4366CE8DD8C01082206.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.74442979999969949657107143019168:50001231000000:2800:23E90BB9EDE9FC18215DA322FC76DF8DDFAD5ADD983245EC0948F50B365747E1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.56439745981073602520611921694593:50001231000000:2800:1EFAFF07475EDB3744D8196E672442473F04F1FFB0C9AE18EE5C42307E9D0C5C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.31172454720165275102313141541896:50001231000000:2800:239693E4FF65360839B9B5F1C15E75CC4FBA53B28162077E45C1825EF932AE0F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.80402007289820820848328939569917:50001231000000:2800:2C1F218204DB8B39F4EDCDFA913BDB1F7B795DDBB292DF25036E7D14D9D615D7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.19641551139084366961653671360894:50001231000000:2800:BD5EAE3C56832D22D54DCD209BCC7F008B08BC15F05F19BB1D88D88B37F6AA14.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170325.42259191556216080858998567852877:50001231000000:2800:0703689B3A71E8D86CAFDD895BFE5A4B88ED2AA05471AD4A7D59BA5746476BD4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.88829332457893642108323924652852:50001231000000:2800:6AB209CC757075635DBD726380B17B0E2E353AC489683471323ECE36833090E3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.57440919912057656211442423244019:50001231000000:2800:78B0325470F86308688819A8CAE9BFF643D56DB35ABF29D30177FC11423B8B6C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.64458550802396456036064115808027:50001231000000:2800:F71AB2055C4892ED4AD18805B1E1970EED7D0BDB0459F5C1CB1120342E92E881.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.37855660631867085809541571515172:50001231000000:2800:24F36175F040B509FBD0BA395B66C18CAAD2DA7D2D7CD84D832F3D9B299FC327.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.65364159468842231516568519138217:50001231000000:2800:AA2B17ED2036028EB5921EE1CBF5231402E67E70BB579FF84D541A1B3A765E42.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.39444404380435542165278536434355:50001231000000:2800:B35F50326B3ADBEC93C4CE34ED78C1CF5BDE7925ED05E796B7EE6B0CB63120AD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.76337046354149409180180046083727:50001231000000:2800:EEE9659BC1BDA5237E7731403B0F5E016EF67B498DE26E83AE7079B7A5C5C45C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.16552065638883764657240643510665:50001231000000:2800:4595780B4F0529B7788F34D8AD70122C4373ECC9051096760A9EE159D727DC57.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.27694069142419503325928070402899:50001231000000:2800:816627B607B2B127AE5E4C64318C621D4AEDF4396E2EF65D1B2DA37692E0120D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.74272330735083238907179536917125:50001231000000:2800:042EF4497476A3BCF9F74637AB7EB985EFAB6B342EB1FE4471D81AF98AB19108.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.41988398757170579767353169181107:50001231000000:2800:B8A138A9593A2C65DAC43D4E503A8B20242E3FAF7E0D3A941ABF4E359E73C496.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.44448722339112854844044595931997:50001231000000:2800:9F46AAAB346C29C4D6338526C129FD44ADCAF73E5571FCD8E588F3D1E59B69A6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.86849492240866225587143586545809:50001231000000:2800:1AE2E502C20C42CD754BB395A716476DE701D7069F6A96B87D70C551AEA3A1B7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.76521467926305407269111026257647:50001231000000:2800:C2C4C6CE4BBF051BECE8B4C7E79E6BCE3B32F4F8F3C28AA891A180AA89D702D0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170326.10763714339224642117823619946945:50001231000000:2800:C48194E1DBBD6239827E62CB47B284BE36F7CB2E3E00402B4BA1450CED0711A4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170327.79439614862129944539961761079716:50001231000000:2800:E634C15B55AED1056C8A62084DFED37665B75C873AC74319760F0C3C9EFA13E1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170327.33548238712504687049120874291886:50001231000000:2800:40A94A560AB600C92DCFC8EC049DC16B91505C7C1D0D88CA7200135C782D66D0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170327.00647623958087699384039782067690:50001231000000:2800:66B68AF2E5BE8D18CA9ECFB5B4516A1AF39D3D0BCA7602BB71CDDA9E8C23CD9E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170327.95624414063989377953141357971061:50001231000000:2800:2650302DE92D9455A3FCED1105DD72536A228AFEC015EACEEFA87A72BA6614B8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170327.46280255497134991061369566369658:50001231000000:2800:78178F3B0566724B03D562B88A0C4B1ECE853AB2D92C069C3FF23C046F9A0E55.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170327.67143351693848560974858750353445:50001231000000:2800:DB5C99F77A949682EE0EC5CDCEBB74F23085FCBB4BFF17AD3C04170960867288.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170327.92314187749313561727662302480787:50001231000000:2800:6B0BB9DC8FA794AB6F4307536ED52DE824E1CD1B10D3AD107155E56B2508B04F.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-global-interface-V14
爬取时间: 2025-04-27 23:42:26
来源: Huawei Developer
概述
HarmonyOS支持Stage模型后，存在一个ArkTS引擎里面运行多个ArkUI实例的场景。此时，一个ArkTS引擎下可能会有多个Ability，每个Ability可能有多个Window，每个Window通过loadContent加载页面，生成一个UIContent（ArkUI实例）。
图1多实例关系图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170327.17147156080013946258537851332826:50001231000000:2800:D110572E7A7013CF094B5959CB79EBCD8EC4CDEE735869265FDEFC41AEE22D21.png)
FA模型默认只支持一个ArkUI实例，没有多实例的场景。当框架切换到Stage模型后，在FA模型下开放的ArkUI全局接口，在调用时无法明确运行在哪个实例里，存在语义不明确的问题。并且，这些接口实现依赖了ArkUI实例相关的信息，如果实例不明确，会导致运行时会出现预期外的行为。
为了解决此类问题，ArkUI针对Stage模型推出了替代接口，以便满足开发者在多实例场景下的诉求。可使用window的接口方法getUIContext或者使用组件内置方法getUIContext直接获取当前组件所在的UIContext，并使用UIContext中对应的接口获取与实例绑定的对象。
接口替代关系
部分多实例替代接口如下表所示，UIContext实例支持的全量接口以UIContext中描述为准。
| 全局接口 | 替代接口 | 说明 |
| --- | --- | --- |
| @ohos.animator | createAnimator | 自定义动画控制器 |
| @ohos.arkui.componentSnapshot | getComponentSnapshot | 组件截图 |
| @ohos.arkui.componentUtils | getComponentUtils | 组件工具类 |
| @ohos.arkui.dragController | getDragController | 拖拽控制器 |
| @ohos.arkui.inspector | getUIInspector | 组件布局回调 |
| @ohos.arkui.observer | getUIObserver | 无感监听 |
| @ohos.font | getFont | 自定义字体 |
| @ohos.measure | getMeasureUtil | 文本计算 |
| @ohos.mediaquery | getMediaQuery | 媒体查询 |
| @ohos.promptAction | getPromptAction | 弹窗 |
| @ohos.router | getRouter | 页面路由 |
| AlertDialog | showAlertDialog | 警告弹窗 |
| ActionSheet | showActionSheet | 列表选择弹窗 |
| CalendarPickerDialog | 不支持 | 日历选择器弹窗 |
| DatePickerDialog | showDatePickerDialog | 日期滑动选择弹窗 |
| TimePickerDialog | showTimePickerDialog | 时间滑动选择器弹窗 |
| TextPickerDialog | showTextPickerDialog | 文本滑动选择器弹窗 |
| ContextMenu | getContextMenuController | 菜单控制 |
| vp2px/px2vp/fp2px/px2fp/lpx2px/px2lpx | vp2px/px2vp/fp2px/px2fp/lpx2px/px2lpx | 像素单位转换 |
| focusControl | getFocusControl | 焦点控制 |
| cursorControl | getCursorControl | 光标控制 |
| getContext | getHostContext | 获取当前的Ability的Context |
| LocalStorage.getShared | getSharedLocalStorage | 获取Ability传递的Storage |
| animateTo | animateTo | 显式动画 |
| animateToImmediately | 不支持 | 显式立即动画 |
接口切换方法
下述示例，实现了在具体窗口内弹出Toast。ArkUI可感知到是在当前页面下调用，找到对应的UI实例。但是，如果一些复杂场景的起始调用不在页面中，经过了异步调用，作用的实例就可能出现行为不明确的问题。
```typescript
import { promptAction } from '@kit.ArkUI'
@Entry
@Component
struct Index {
build() {
Row() {
Button()
.onClick(() => {
promptAction.showToast({
message: 'Message Info',
duration: 2000
});
})
}
}
}
```
下述示例，callNative是Node-API方法，回调如果是由C侧异步触发，执行时无法感知当前页面信息，无法确定响应的UI实例。
```typescript
import { promptAction } from '@kit.ArkUI'
@Entry
@Component
struct Index {
build() {
Row() {
Button()
.onClick(() => {
bridge.callNative("xxxx", ()=> {
promptAction.showToast({
message: 'Message Info',
duration: 2000
});
})
})
}
}
}
```
针对上述问题，可使用组件内置方法getUIContext直接获取当前组件所在的UIContext，并使用UIContext中的的getPromptAction接口获取与实例绑定的对象，使得Toast绑定到具体的实例。
```typescript
@Entry
@Component
struct Index {
build() {
Row() {
Button()
.onClick(() => {
let uiContext = this.getUIContext();
let prompt = uiContext.getPromptAction();
bridge.callNative("xxxx", ()=> {
prompt.showToast({
message: 'Message Info',
duration: 2000
});
})
})
}
}
}
```
对于UIContext中没有提供替代的接口（例如，CalendarPickerDialog和animateToImmediately），或者开发者自定义实现的业务行为与多实例相关，需要和实例绑定事（例如，一个代码段），可以使用UIContext的runScopedTask方法将接口或一段代码段包裹起来。
| UIContext接口 | 说明 |
| --- | --- |
| runScopedTask | 执行绑定实例的闭包。 |
上文的示例也可以使用如下方法实现。
```typescript
// 执行绑定实例的闭包
import { promptAction } from '@kit.ArkUI'
@Entry
@Component
struct Index {
build() {
Row() {
Button()
.onClick(() => {
let uiContext = this.getUIContext();
uiContext.runScopedTask(() => {
promptAction.showToast({
message: 'Message Info',
duration: 2000
});
})
})
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-ui-cross-process-V14
爬取时间: 2025-04-27 23:42:40
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-fullscreencomponent-V14
爬取时间: 2025-04-27 23:42:53
来源: Huawei Developer
FullScreenLaunchComponent允许开发者以全屏方式拉起元服务，使得应用能够提供更原生和友好的用户体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170327.82548742766273947598360373916834:50001231000000:2800:49F9775C9D5818592687C32C1297DDBD8F2E47879670C6548F709B111C4C40E5.png)
基本概念
-  FullScreenLaunchComponent组件 FullScreenLaunchComponent是由ArkUI提供的组件，允许在使用方应用中通过ArkTS的声明式范式进行定义和使用。FullScreenLaunchComponent向第三方应用开放使用权限，当被拉起方授权使用方应用嵌入式运行元服务时，使用方应用可全屏嵌入式运行该服务。若未授权，则使用方应用将以跳出式方式拉起元服务。
-  EmbeddableUIAbility组件 提供方应用中定义使用，用于运行提供方应用在一个独立进程中，同时具备跳转启动和嵌入式启动两种启动方式。
实现原理
FullScreenLaunchComponent提供的一种全屏启动元服务的能力。需要拉起元服务时，拉起方向AMS查询拉起方是否授权使用方可以嵌入式运行元服务。已授权时，使用方全屏嵌入式运行元服务；未授权时，使用方跳出式拉起元服务。
全屏嵌入式运行元服务是指，通过UIExtensionComponent的组件方式嵌入到使用方的组件树中，拉起EmbeddableUIAbility，展示提供方的应用内容。能够实现组件式的交互体验。
跳出式运行元服务是指，非组件化的方式拉起EmbeddableUIAbility，交互体验接近独立窗口。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170327.59622504308015548345014600215700:50001231000000:2800:26460380D9121954F581C0845E1FB77A99AA9AFB481E227B2CF96C7006512F59.png)
能力范围
组件基本能力
EmbeddableUIAbility进程应用可用能力范围
FullScreenLaunchComponent为了实现跨应用的能力共享，存在较开放的灵活性，通过跨进程的方式拉起提供方应用提供的能力供当前使用方（宿主方）使用。在运行机制上，是两个进程之间的业务交互行为，和一般组件和宿主方存在根本上的差异。
以下给出针对FullScreenLaunchComponent，在EmbeddableUIAbility内提供方应用能够使用的属性、事件、组件、Node-API接口等方面的范围，便于使用方应用与提供方应用在使用FullScreenLaunchComponent组件时进行参照。
以下为当前组件不支持及部分支持的能力。
通用属性
不支持通用属性。
组件
应用提供方使用组件时，需要和使用方（宿主方）的组件、应用进程上下文交互的场景，默认不支持。主要包括如下场景：
详情如下：
| 组件 | 能力规格 | 功能说明 | 规格补充说明 |
| --- | --- | --- | --- |
| FullScreenLaunchComponent (全屏启动元服务组件) | 不支持 | 全屏启动元服务组件，当被拉起方授权使用方可以嵌入式运行元服务时，使用方全屏嵌入式运行元服务；未授权时，使用方跳出式拉起元服务。 | 由于是一种跨应用调度的能力，FullScreenLaunchComponent中暂不支持嵌套拉起。 |
| EmbeddedComponent | 不支持 | EmbeddedComponent用于支持在当前页面嵌入本应用内其他EmbeddedUIExtensionAbility提供的UI。EmbeddedUIExtensionAbility在独立进程中运行，完成页面布局和渲染。 | 由于是一种跨应用调度的能力，FullScreenLaunchComponent中暂不支持嵌套拉起。 |
| RichText | 不支持 | 富文本组件，解析并显示HTML格式文本。 | — |
| FolderStack | 不支持 | 通常用于有Abc热更新诉求的模块化开发场景。FolderStack继承于Stack(层叠布局)控件，新增了折叠屏悬停能力，通过识别upperItems自动避让折叠屏折痕区后移到上半屏。 | 折叠屏划分组件能力，需要和宿主方窗口形成联动，从而需要在提供方内获取宿主主窗的信息，目前无法支持。 |
| XComponent | 不支持 | 可用于EGL/OpenGLES和媒体数据写入，并显示在XComponent组件。 | — |
| FormLink | 不支持 | 提供静态卡片交互组件，用于静态卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件。 | 卡片提供的是跨进程的组件调用能力，FullScreenLaunchComponent中嵌套使用会导致进程关系复杂，导致功能性能方面的问题。 |
| HyperLink | 不支持 | 超链接组件，组件宽高范围内点击实现跳转。 | — |
| ContextMenu | 不支持 | 在页面范围内关闭通过bindContextMenu属性绑定的菜单。 | — |
| 警告弹窗 | 部分支持 | 显示警告弹窗组件，可设置文本内容与响应回调。若在FullScreenLaunchComponent中设置showInSubWindow为true, 弹窗将基于FullScreenLaunchComponent的宿主窗口对齐。 | 需要依赖主窗的信息实现弹窗对齐，弹窗组件基于FullScreenLaunchComponent提供的信息获取宿主应用的窗口信息实现了对齐应用窗口的能力。仅限于窗口对齐。 |
| 列表选择弹窗 | 部分支持 | 列表弹窗。若在FullScreenLaunchComponent中设置showInSubWindow为true, 弹窗将基于FullScreenLaunchComponent的宿主窗口对齐。 | 需要依赖主窗的信息实现弹窗对齐，弹窗组件基于FullScreenLaunchComponent提供的信息获取宿主应用的窗口信息实现了对齐应用窗口的能力。仅限于窗口对齐。 |
| 自定义弹窗 | 部分支持 | 通过CustomDialogController类显示自定义弹窗。使用弹窗组件时，可优先考虑自定义弹窗，便于自定义弹窗的样式与内容。若在FullScreenLaunchComponent中设置showInSubWindow为true, 弹窗将基于FullScreenLaunchComponent的宿主窗口对齐。 | 需要依赖主窗的信息实现弹窗对齐，弹窗组件基于FullScreenLaunchComponent提供的信息获取宿主应用的窗口信息实现了对齐应用窗口的能力。仅限于窗口对齐。 |
| Navigation | 部分支持 | 该组件从API Version 11开始默认支持安全区避让特性(默认值为：expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM]))，开发者可以重写该属性覆盖默认行为。 | 1、如果FullScreenLaunchComponent未设置模态或沉浸式，Navigation无法扩展到安全区。 2、无法路由到宿主方的页面中。 |
1、如果FullScreenLaunchComponent未设置模态或沉浸式，Navigation无法扩展到安全区。
2、无法路由到宿主方的页面中。
Node-API接口
Native API接口提供能力，在FullScreenLaunchComponent场景下也需要考虑是否是跨出当前组件的能力，以及和使用方（宿主方）组件、应用进程上下文交互的场景。主要包括如下场景：
详情如下：
| 模块 | 能力规格 | 功能说明 | 规格补充说明 |
| --- | --- | --- | --- |
| 页面间转场 | 不支持 | 当路由进行切换时，可以通过在pageTransition函数中自定义页面入场和页面退场的转场动效。 | — |
| 组件内隐式共享元素转场 | 不支持 | 在视图切换过程中提供丝滑的上下文传承过渡。通用transition机制提供了opacity、scale等转场效果，geometryTransition通过安排绑定的in/out组件(in指新视图、out指旧视图)的frame、position使得原本独立的transition动画在空间位置上发生联系，将视觉焦点由旧视图位置引导到新视图位置。 | — |
| componentUtils | 不支持 | 提供获取组件绘制区域坐标和大小的能力。 | 获取信息来自于窗口，默认情况下直接获取到的位置信息是EmbeddableUIAbility的WindowProxy的信息，非宿主应用的主窗口信息。 |
| UIContext | 不支持 | @ohos.window在API version 10 新增getUIContext接口，获取UI上下文实例UIContext对象，使用UIContext对象提供的替代方法，可以直接作用在对应的UI实例上。 | 基于window获取，但FullScreenLaunchComponent内部默认方式下，提供方无真正的窗口承载，无法使用该接口获取到正确的UIContext。 |
| DragController | 不支持 | 本模块提供发起主动拖拽的能力，当应用接收到触摸或长按等事件时可以主动发起拖拽的动作，并在其中携带拖拽信息。 本模块功能依赖UI的执行上下文，不可在UI上下文不明确的地方使用，参见UIContext说明。 | 拖拽时通过UIContext上下文传递组件间的事件传递，使用方应用和提供方应用不共享UIContext内容，默认能力下无法支持拖拽事件的传递。 |
| 布局回调 | 部分支持 | 提供注册组件布局和绘制完成回调通知的能力。 | 如果指定FullScreenLaunchComponent组件，预期是获得所有FullScreenLaunchComponent中的组件信息，尚未支持该能力；提供方内部可以正常使用。 |
| 注册自定义字体 | 不支持 | 本模块提供注册自定义字体。 | 注册字体存在影响范围的问题，提供方侧无法影响使用方应用的字体。 |
| PluginComponentManager | 不支持 | 用于给插件组件的使用者请求组件与数据，使用者发送组件模板和数据。 | 依赖获取其他组件的数据，提供方组件在另一个进程中，无法提供访问宿主组件的能力。 |
本模块提供发起主动拖拽的能力，当应用接收到触摸或长按等事件时可以主动发起拖拽的动作，并在其中携带拖拽信息。
本模块功能依赖UI的执行上下文，不可在UI上下文不明确的地方使用，参见UIContext说明。
约束与限制
安全能力约束
FullScreenLaunchComponent组件（使用方）可以访问调用集成了EmbeddableUIAbility的应用（提供方），提供了一种通用应用共享能力。FullScreenLaunchComponent能力无法独立提供安全保障机制，作为提供服务的应用（提供方）保护自己不被使用方应用攻击，需要提供方应用结合使用其他ArkUI的能力进行安全保护。
由于FullScreenLaunchComponent能力（包含基于FullScreenLaunchComponent衍生的相关能力）机制的灵活性，如果提供方应用存在安全方面的诉求，无法在现有FullScreenLaunchComponent的场景下解决的，建议优先使用其他方案。如选择继续采用FullScreenLaunchComponent能力，提供方应用以及使用方应用都需要承担一定的安全风险。
使用模式
嵌入式模式下为了避免被使用方的子窗遮挡，使用方的交互行为将受限，使用方无法再创建任何子窗覆盖到提供方的窗口上。
嵌套约束
FullScreenLaunchComponent暂不支持嵌套，比如A应用(UIAbility)->B应用(EmbeddableUIAbility)->C应用(EmbeddableUIAbility)这种嵌套能力依赖。
事件处理机制约束
FullScreenLaunchComponent不支持通用事件，会将事件经过坐标转换后传递给提供方EmbeddableUIAbility处理。
对事件传递处理方式进行区分，针对不同事件使用场景确定同步或异步方式：
应用开发者使用FullScreenLaunchComponent能力时，需要遵守如下设计场景约束：
异步处理的事件场景：FullScreenLaunchComponent组件以及宿主应用侧组件可以同时收到事件。需要应用开发者结合应用场景进行处理，如宿主应用侧组件不做事件处理。如果无法避免，建议替换FullScreenLaunchComponent组件来保障交互体验。
| 场景 | 分类 | 是否支持 | 同步/异步（宿主与提供方） | 备注 |
| --- | --- | --- | --- | --- |
| 通用事件 | 点击事件（Click） | 支持 | 异步 | — |
| 通用事件 | 触摸事件（Touch） | 支持 | 异步 | — |
| 通用事件 | 拖拽事件（onDragXXX） | 支持 | 异步 | — |
| 通用事件 | 按键事件（KeyEvent） | 支持 | 同步 | 支持超时等待机制，超时后会结束等待，对上层来说相当于事件未处理。 |
| 通用事件 | 焦点事件（onFocus/onBlur） | 支持 | 同步 | 支持超时等待机制，超时后会结束等待，对上层来说相当于事件未处理。 |
| 通用事件 | 鼠标事件（onHove/onMouse） | 支持 | 异步 | — |
| 手势处理 | — | 支持 | 异步 | — |
| 无障碍 | — | 支持 | 同步 | 支持超时等待机制，超时后会结束等待，对上层来说相当于事件未处理。 |
页面渲染效果体验约束
由于FullScreenLaunchComponent是一种跨进程的应用调用，使用方应用进程和提供方应用进程的处理不能实现同步，会导致在交互体验上存在和一般组件不同的体验问题。应用开发者应知悉本组件存在跨多个进程渲染页面的性能约束，从而进行针对性的处理。
应用开发者（提供方）需要考虑如下设计约束：
应用开发者（使用方）可以通过如下方式消减闪白问题：
如果消减后效果不能完全满足应用交互诉求，由于跨进程的能力约束，建议应用优先考虑其他方案。
其他约束
-  不支持在运行过程中修改切换后端拉起的元服务EmbeddableUIAbility。
-  不支持预览，不在开发DevEco Studio中提供预览能力。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-use-ndk-V14
爬取时间: 2025-04-27 23:43:07
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ndk-build-ui-overview-V14
爬取时间: 2025-04-27 23:43:21
来源: Huawei Developer
ArkUI开发框架提供了一系列NDK接口，能够在应用中使用C和C++代码构建UI界面，这些接口包括UI组件创建、UI树操作、属性设置和事件监听等。面向通用UI界面开发场景，建议使用ArkTS代码和ArkUI声明式开发框架。然而，如果需要实现以下一个或多个目标，那么ArkUI NDK接口就能派上用场：
-  需要使用UI组件树控制接口来动态创建和挂载UI组件，方便实现自身UI开发框架的系统桥接。
-  进一步提升UI界面性能，细粒度控制组件的创建和属性设置，以降低延迟、处理极高UI负载。
-  重复使用自己或其他开发者的C或C++UI库。
ArkUI NDK接口能力主要包括：
-  布局 布局是UI的必要元素，定义了组件在界面中的大小位置。ArkUI NDK接口提供了线性布局、层叠布局、弹性布局、相对布局、滚动容器、轮播容器等。
-  组件 组件是UI的必要元素，形成了在界面中的样子。包括系统内置组件和用户自定义布局绘制行为的组件。系统内置组件包括按钮、单选框、图片、文本等，可以使用ArkUI NDK提供的接口快速创建相应组件并设置属性和事件。针对UI组件的自定义能力包括了布局测算和绘制，用户可以通过这些自定义能力构建差异化UI组件。
-  弹窗 弹窗是UI界面交互的重要元素。ArkUI NDK接口提供了自定义弹窗相关接口，可以自定义弹窗界面内容并调用相关弹窗接口展示弹窗。
-  动画 动画是UI的重要元素之一。优秀的动画设计能够极大地提升用户体验，ArkUI NDK提供了显式动画接口用于快速构建组件的属性动画、实现高效精致的动画效果。
-  交互事件 交互事件是UI和用户交互的必要元素。ArkUI NDK接口提供了多种交互事件，除了触摸事件、鼠标事件、焦点事件等通用事件外，还包括基于通用事件进行进一步识别的手势事件。手势事件有单一手势如点击手势、长按手势、拖动手势、捏合手势、旋转手势、滑动手势，以及通过单一手势事件进行组合的组合手势事件。
整体架构
图1NDK接口和ArkTS声明式关系架构图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170328.00093960600693343045487686541263:50001231000000:2800:F785D4F35B6E1E5D19A6F2BC28DE5678C70DFBEC9CA213CD983AF80A51452969.png)
图2通过NDK接口创建的组件挂载示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170328.86246948571321172292662379419258:50001231000000:2800:3352886E79FEA5895DCD099172205D5733A5AD337E858F59910B06E6757C089B.png)
-  ArkTS声明式UI前端和NDK接口都是针对ArkUI底层实现的接口暴露，NDK接口相比于ArkTS声明式UI前端，除了剥离状态管理等声明式UI语法外，还精简了组件能力，将ArkUI组件核心功能通过C接口进行封装暴露。
-  NDK创建的UI组件需要通过ArkTS层的占位组件进行挂载显示，挂载后，NDK创建的组件和ArkTS创建的组件位于同一个UI树上，相关布局渲染和事件处理遵循相同规则。
开发流程
使用NDK接口开发UI界面时，主要涉及如下开发过程。
| 任务 | 简介 |
| --- | --- |
| NDK开发导读 | 介绍NDK的适用场景与必备基础知识。 |
| 接入ArkTS页面 | 介绍了如何将NDK接口开发的UI界面挂载到ArkTS主页面上进行渲染显示。 |
| 监听组件事件 | 介绍了如何注册组件的事件监听和添加手势交互。 |
| 使用动画 | 介绍了如何在Native侧添加动画。 |
| 使用懒加载开发长列表界面 | 介绍了如何使用懒加载能力在Native侧开发高性能长列表界面。 |
| 构建弹窗 | 介绍了如何使用弹窗接口构建UI界面进行弹窗显示。 |
| 构建自定义组件 | 介绍了如何使用NDK接口能力构建自定义组件，实现差异化UI组件。 |
| 嵌入ArkTS组件 | 介绍了如何在Native侧构建带有ArkTS组件的界面。 |
| 通过XComponent接入无障碍 | 介绍了通过XComponent接入UI平台的三方系统如何对接无障碍。 |
注意事项
使用NDK接口开发UI界面时，需要保证相关UI接口调用在应用主线程上调用，避免多线程操作导致应用崩溃问题。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ndk-access-the-arkts-page-V14
爬取时间: 2025-04-27 23:43:35
来源: Huawei Developer
占位组件
使用NDK接口构建UI界面时，需要在ArkTS页面创建用于挂载NDK接口创建组件的占位组件。占位组件类型为ContentSlot，ContentSlot能够绑定一个NodeContent对象，该对象可通过Node-API传递到Native侧挂载显示Native组件。
-  占位组件和其他ArkTS内置组件使用方法相同。详细代码请参考示例。
```typescript
import { NodeContent } from '@kit.ArkUI';
import nativeNode from 'libentry.so';
@Entry
@Component
struct Index {
// 初始化NodeContent对象。
private rootSlot = new NodeContent();
@State @Watch('changeNativeFlag') showNative: boolean = false;
changeNativeFlag(): void {
if (this.showNative) {
// 传递NodeContent对象用于Native创建组件的挂载显示
nativeNode.createNativeRoot(this.rootSlot)
} else {
// 销毁NativeModule组件
nativeNode.destroyNativeRoot()
}
}
build() {
Column() {
Button(this.showNative ? "HideNativeUI" : "ShowNativeUI").onClick(() => {
this.showNative = !this.showNative
})
Row() {
// 将NodeContent和ContentSlot占位组件绑定。
ContentSlot(this.rootSlot)
}.layoutWeight(1)
}
.width('100%')
.height('100%')
}
}
```
-  占位组件可以通过相关接口在Native侧转化为挂载对象。
-  挂载对象提供了相关挂载和卸载组件接口。
NDK组件模块
NDK提供的UI组件能力如组件创建、树操作、属性设置、事件注册等是通过函数指针结构体(如ArkUI_NativeNodeAPI_1）进行暴露，该函数指针结构体可以通过模块查询接口获取。
在获取到函数指针结构体后，可以使用该结构体内的函数实现相关UI组件操作。
-  组件创建和销毁。 获取NDK接口支持的组件范围可以通过查询ArkUI_NodeType枚举值。
-  组件树操作。
-  属性设置。 获取NDK接口支持的属性范围可以通过查询ArkUI_NodeAttributeType枚举值。
-  事件注册。 获取NDK接口支持的事件范围可以通过查询ArkUI_NodeEventType枚举值。
示例
下面的示例展示了如何使用ContentSlot挂载Native侧的文本列表。
图1Native文本列表
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170328.39221608196880831751429014390433:50001231000000:2800:FA4B8282A6DED8727434B1A1D29609484A7CE5B286DBC29C326EBA19EC9AEC64.gif)
1.  在ArkTS页面上声明用于Native页面挂载的占位组件，并在页面创建时通知Native侧创建文本列表。
```typescript
import nativeNode from 'libentry.so';
import { NodeContent } from '@kit.ArkUI';
@Entry
@Component
struct Index {
// 初始化NodeContent对象。
private rootSlot = new NodeContent();
@State @Watch('changeNativeFlag') showNative: boolean = false;
changeNativeFlag(): void {
if (this.showNative) {
// 传递NodeContent对象用于Native创建组件的挂载显示
nativeNode.createNativeRoot(this.rootSlot)
} else {
// 销毁NativeModule组件
nativeNode.destroyNativeRoot()
}
}
build() {
Column() {
Button(this.showNative ? "HideNativeUI" : "ShowNativeUI").onClick(() => {
this.showNative = !this.showNative
})
Row() {
// 将NodeContent和ContentSlot占位组件绑定。
ContentSlot(this.rootSlot)
}.layoutWeight(1)
}
.width('100%')
.height('100%')
}
}
```
2.  使用Native模板创建工程，并在Native侧提供Node-API的桥接方法，实现ArkTS侧的NativeNode模块接口。 接口声明。 Native实现。
```typescript
// entry/src/main/cpp/types/libentry/Index.d.ts
export const createNativeRoot: (content: Object) => void;
export const destroyNativeRoot: () => void;
```
3.  在NativeEntry.h文件中创建Native界面。 对应实现文件。 使用NDK 提供的C接口需要在CMakeLists.txt 中增加libace_ndk.z.so 的引用，如下所示，其中entry为工程导出的动态库名称，如当前示例使用的是默认的名称 libentry.so。
4.  由于NDK接口提供的是C接口，为了使用面向对象的方式简化编程和工程管理，这里建议使用C++进行二次封装，下面示例代码展示了示例界面中所需的列表，文本组件封装类。 1）获取ArkUI在NDK接口的入口模块ArkUI_NativeNodeAPI_1，该结构体模块提供了一系列组件创建、树构建、属性设置和事件注册等函数指针。 2）提供列表，文本组件的基类对象，用于封装通用属性和事件。 3）实现列表组件。 4）实现列表项组件。 5）实现文本组件。
5.  完善步骤3的CreateTextListExample函数，实现Native文本列表的创建和挂载显示。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkts-add-event-V14
爬取时间: 2025-04-27 23:43:48
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ndk-listen-to-component-events-V14
爬取时间: 2025-04-27 23:44:02
来源: Huawei Developer
NDK接口针对UI组件的事件，提供了监听函数的方式。首先，可使用addNodeEventReceiver函数添加组件事件的监听器，该监听器会监听该组件上发生的所有事件，例如：点击事件、焦点事件。然后，可使用registerNodeEvent函数声明组件的哪些事件需要监听，NDK接口支持的事件范围通过ArkUI_NodeEventType枚举值定义。
-  事件注册需要声明addNodeEventReceiver监听器注册和registerNodeEvent事件类型，监听器只能监听已声明的事件。
-  需要关注事件的反注册逻辑，如在组件销毁前调用removeNodeEventReceiver移除事件监听器，unregisterNodeEvent通知ArkUI框架已监听的事件不再需要监听。
-  addNodeEventReceiver可以添加多个函数指针，每个函数指针都会在对应事件触发时触发，对应的removeNodeEventReceiver需要传递对应的函数指针用于移除监听。
-  registerNodeEventReceiver是全局监听函数，不同于addNodeEventReceiver，registerEventReceiver能够监听所有Native组件的事件触发，但只能传递一个函数指针，多次调用使用最后一次的函数指针进行回调，释放时使用ungisterNodeEventReceiver进行释放。
以下示例基于接入ArkTS页面章节，补充相关事件监听。
1.  在ArkUINode基类对象中实现通用事件注册逻辑。
2.  在ArkUIListNode对象中实现列表事件注册逻辑。
3.  添加相关事件。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ndk-bind-gesture-events-V14
爬取时间: 2025-04-27 23:44:16
来源: Huawei Developer
ArkUI开发框架在NDK接口主要提供点击手势、拖动手势、滑动手势、长按手势、捏合手势和旋转手势，通过给指定的组件绑定不同的手势并设置相应的回调，实现期望的手势交互能力。
下面通过一个简单的示例来介绍如何实现手势绑定。
1.  创建一个Column节点，用于绑定手势。
2.  创建一个单指长按1秒并持续响应的长按手势。
3.  将创建的手势和步骤一中创建的Column节点绑定。
单一手势
通过上文的示例已经了解了如果将手势绑定在节点上，接下来将分别介绍不同手势的创建方法，并分别支持哪些事件回调。
-  点击手势 通过给组件绑定点击手势可在组件被点击时触发此回调，可指定触发回调需要的点击次数和手指个数。
-  拖动手势 通过给组件绑定拖动手势可在用户拖动组件时触发回调，可指定触发回调需要的手指个数、拖动方向、拖动距离。单位为px。
-  长按手势 通过给组件绑定长按手势可在用户长按组件时触发回调，可指定触发回调需要的手指个数、长按时间（单位毫秒）、是否连续触发。
-  捏合手势 通过给组件绑定捏合手势可在用户捏合组件时触发回调，可指定触发回调需要的手指个数（最小为2）、捏合距离（单位px）。
-  旋转手势 通过给组件绑定旋转手势可在用户旋转组件时触发回调，可指定触发回调需要的手指个数（最小为2）、旋转角度。
-  滑动手势 通过给组件绑定滑动手势可在用户滑动组件时触发回调，可指定触发回调需要的手指个数（最小为1）、滑动方向、滑动速度（单位px/s）。
组合手势
组合手势由多种单一手势组合而成，通过在GroupGesture中使用不同的ArkUI_GroupGestureMode来声明该组合手势的类型，支持顺序识别、并行识别、互斥识别三种类型。
ArkUI_GroupGestureMode枚举类，用于声明该组合手势的类型。顺序识别SEQUENTIAL_GROUP，并行识别PARALLEL_GROUP，互斥识别EXCLUSIVE_GROUP。
顺序识别
顺序识别组合手势对应的ArkUI_GroupGestureMode为SEQUENTIAL_GROUP。顺序识别组合手势将按照手势的注册顺序识别手势，直到所有的手势识别成功。当顺序识别组合手势中有一个手势识别失败时，后续手势识别均失败。顺序识别手势组仅有最后一个手势可以响应GESTURE_EVENT_ACTION_END。
以顺序识别长按和滑动手势为例：
并行识别
并行识别组合手势对应的ArkUI_GroupGestureMode为PARALLEL_GROUP。并行识别组合手势中注册的手势将同时进行识别，直到所有手势识别结束。并行识别手势组合中的手势进行识别时互不影响。
以并行识别长按和滑动手势为例：
互斥识别
互斥识别组合手势对应的ArkUI_GroupGestureMode为EXCLUSIVE_GROUP。互斥识别组合手势中注册的手势将同时进行识别，若有一个手势识别成功，则结束手势识别，其他所有手势识别失败。
以互斥识别平移手势和捏合手势为例：
自定义手势判定
支持自定义手势判定，当组件触发手势时，可根据回调内容判定当前响应的手势是否继续执行。
在上文绑定手势事件的示例中按照如下方式进行调整即可实现自定义手势判定。
1.  创建自定义手势判定回调。
2.  绑定手势判定和节点。
经过上述修改，将原本可以生效的长按手势做了拦截，即，此时再对Column节点长按将不会触发长按的手势回调。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ndk-use-animation-V14
爬取时间: 2025-04-27 23:44:30
来源: Huawei Developer
使用属性动画
ArkUI开发框架在NDK接口主要提供属性动画，实现组件出现/消失转场。同时，可以通过Node-API桥接ArkTS侧帧动画能力，实现Native侧的动画效果。
-  需要从ArkTS侧获取this.getUIContext()，传入到Native侧。
-  在Native侧通过OH_ArkUI_GetContextFromNapiValue方法获取context。
-  需要执行的动画属性变化必须写在ArkUI_ContextCallback中callback中。
-  需要执行的动画属性,必须在执行动画之前设置过。
提供全局animateTo显式动画接口，来指定由于闭包代码导致的状态变化插入过渡动效。同属性动画，布局类改变宽高的动画，内容都是直接到终点状态。
1.  在.ets文件中获取UIContext，把this.getUIContext()当做参数输出到Native方法中。
```typescript
// createNativeNode是Native侧暴露的方法
nativeNode.createNativeNode("xcomponentId", this.getUIContext());
```
2.  解析UIContext转换C中的context对象。
3.  获取ArkUI_NativeAnimateAPI_1 对象。
4.  设置 ArkUI_AnimateOption参数，通过提供的C方法设置对应的参数。
5.  设置回调参数。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170328.75579144259801107260590568209698:50001231000000:2800:D7EA71CCDF31ED9F4215D3A1705FD982611F25CAE8AD89BDF889AA0E683BF102.gif)
组件出现/消失转场
组件内转场通过NODE_XX_TRANSITION属性（XX包括：OPACITY、TRANSLATE、SCALE、ROTATE、MOVE）配置转场参数，在组件插入和删除时显示过渡动效（通过NODE_TRANSFORM_CENTER属性设置NODE_SCALE_TRANSITION和NODE_ROTATE_ROTATE动效的中心点坐标）。主要用于容器组件中子组件插入和删除时，提升用户体验。
1.  创建可交互界面，界面中包含Button，点击可以控制转场节点的添加和移除。其中 ArkUI_NodeContentHandle 类型节点的获取与使用可参考接入ArkTS页面。
2.  创建一个设置了Transition属性的节点，当目标节点上下树时会播放转场动画。
3.  在Button的监听回调里添加转场节点上下树逻辑，以此控制转场节点的入场和出场。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170328.67172655206759366305413517617000:50001231000000:2800:96595A67626E46FC4B384B3D9E0DC9E2C21A315B9376C1F880A2198265DF4A76.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ndk-loading-long-list-V14
爬取时间: 2025-04-27 23:44:44
来源: Huawei Developer
针对List、Grid、WaterFlow、Swiper组件，提供NodeAdapter对象替代ArkTS侧的LazyForEach功能，用于按需生成子组件，其中List组件的属性枚举值为NODE_LIST_NODE_ADAPTER，Grid组件的属性枚举值为NODE_GRID_NODE_ADAPTER，WaterFlow组件的属性枚举值为NODE_WATER_FLOW_NODE_ADAPTER，Swiper组件的属性枚举值为NODE_SWIPER_NODE_ADAPTER。
虽然都用于按需生成组件，但不同于ArkTS的LazyForEach，NodeAdapter对象的规格如下：
-  设置了NodeAdapter属性的节点，不再支持addChild等直接添加子组件的接口。子组件完全由NodeAdapter管理，使用属性方法设置NodeAdapter时，会判断父组件是否已经存在子节点，如果父组件已经存在子节点，则设置NodeAdapter操作失败，返回错误码。
-  NodeApdater通过相关事件通知开发者按需生成组件，类似组件事件机制，开发者使用NodeAdapter时要注册事件监听器，在监听器事件中处理逻辑，相关事件通过ArkUI_NodeAdapterEventType定义。另外NodeAdapter不会主动释放不在屏幕内显示的组件对象，开发者需要在NODE_ADAPTER_EVENT_ON_REMOVE_NODE_FROM_ADAPTER事件中进行组件对象的释放，或者进行缓存复用。下图展示了典型列表滑动场景下的事件触发机制：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170328.12273624218610645193227156092099:50001231000000:2800:91EC838DA400155140D1442E26BB4BE5964363E9C33F7BDA145F7C4CE6E30081.png)
以下示例代码针对接入ArkTS页面章节代码进行优化，引入懒加载机制实现文本列表：
1.  接入ArkTS，参考接入ArkTS页面。
2.  懒加载适配器相关功能实现。
3.  针对接入ArkTS页面章节使用的列表封装类对象，添加额外懒加载能力。
4.  创建列表懒加载的示例代码。
5.  定时器模块相关简单实现。
6.  按照接入ArkTS页面章节将懒加载相关示例代码挂载到ContentSlot上显示。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ndk-build-pop-up-window-V14
爬取时间: 2025-04-27 23:44:58
来源: Huawei Developer
通过弹窗控制器显示自定义弹窗，可以设置自定义弹窗的样式和内容。
弹窗接口集合定义在结构体里，命名为ArkUI_NativeDialogAPI_x （x表示版本），这些接口围绕弹窗控制器实现各种弹窗控制。
创建和销毁弹窗控制器
-  创建弹窗控制器 ArkUI_NativeDialogHandle表示指向弹窗控制器的指针，可以通过调用ArkUI_NativeDialogAPI_x的create接口创建一个弹窗控制器。 该方法返回ArkUI_NativeDialogHandle类型的数据。
-  销毁弹窗控制器 当不再需要弹窗操作时，需要主动调用dispose接口销毁弹窗控制器对象。
设置弹窗样式
可以设置弹窗对齐方式、偏移量，弹窗背板圆角弧度、背景色、蒙层颜色以及区域等。
1.  创建弹窗内容节点。
2.  通过controller控制弹窗样式。弹窗接口清单和描述可查看native_dialog.h。
3.  不需要弹窗时关闭弹窗。
弹窗的交互
可创建交互页面，打开或关闭弹窗。
1.  创建一个可交互的界面，点击Button之后可以弹窗。其中 ArkUI_NodeContentHandle 类型节点的获取与使用可参考接入ArkTS页面。
2.  创建Button事件的回调函数，当Button点击时触发弹窗显示或关闭。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170329.52244931990772068159524548987226:50001231000000:2800:89B04DEAEC175F4EEF56832E7916E19F784F516FE26CBB0DDAC6EE348CB96664.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ndk-build-custom-components-V14
爬取时间: 2025-04-27 23:45:12
来源: Huawei Developer
ArkUI开发框架在NDK接口提供了自定义UI组件的能力，这些能力包括自定义测算，自定义布局和自定义绘制。开发者通过注册相关自定义回调事件接入ArkUI开发框架的布局渲染流程，这些事件需要使用registerNodeCustomEvent来进行声明，并通过addNodeCustomEventReceiver函数添加组件自定义事件的监听器，在该监听器的回调函数中处理相关自定义测算，自定义布局和自定义绘制逻辑。
-  自定义组件事件注册需要addNodeCustomEventReceiver声明监听器注册和registerNodeCustomEvent声明需要的自定义事件类型，监听器只能监听已声明的事件。
-  需要关注事件的反注册逻辑，如在组件销毁前调用removeNodeCustomEventReceiver移除事件监听器，unregisterNodeCustomEvent通知ArkUI框架已监听的自定义组件事件不再需要监听。
-  addNodeCustomEventReceiver可以添加多个函数指针，每个函数指针都会在对应事件触发时触发，对应的removeNodeCustomEventReceiver需要传递对应的函数指针用于移除监听。
-  registerNodeCustomEventReceiver是全局监听函数，不同于addNodeCustomEventReceiver，registerNodeCustomEventReceiver能够监听所有Native组件的自定义事件触发，但只能传递一个函数指针，多次调用使用最后一次的函数指针进行回调，释放时使用unregisterNodeCustomEventReceiver进行反注册。
-  自定义组件相关接口（measureNode、layoutNode、setMeasuredSize、setLayoutPosition）仅允许在对应的自定义事件（ARKUI_NODE_CUSTOM_EVENT_ON_MEASURE、ARKUI_NODE_CUSTOM_EVENT_ON_LAYOUT）回调中使用。
自定义布局容器
以下示例创建了一个自定义容器，该容器将子组件最大值加上额外边距作为自身大小，同时对子组件进行居中排布。
图1自定义容器组件
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170329.18727492179649797172506951208056:50001231000000:2800:83622F474B7D9CA66880224AB325A08CECD1CD7EB332D1813FEA259C6BA0D559.png)
1.  按照接入ArkTS页面创建前置工程。
2.  创建自定义容器组件封装对象。
3.  使用自定义容器创建带文本的示例界面，并沿用定时器模块相关简单实现。
自定义绘制组件
以下示例创建了一个自定义绘制组件，该绘制组件能够绘制自定义矩形，并使用上述自定义容器进行布局排布。
图2自定义绘制组件
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170329.61265100398544862965639432277519:50001231000000:2800:0680C562D096155889A9A175388F3FFEFA0E362136B280E38958E2F1EEC7A669.png)
1.  按照自定义布局容器章节准备前置工程。
2.  创建自定义绘制组件封装对象。
3.  使用自定义绘制组件和自定义容器创建示例界面，并沿用定时器模块相关简单实现。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ndk-embed-arkts-components-V14
爬取时间: 2025-04-27 23:45:26
来源: Huawei Developer
ArkUI在Native侧提供的能力作为ArkTS的子集，部分能力不会在Native侧提供，如声明式UI语法，自定义struct组件，UI高级组件。
针对需要使用ArkTS侧独立能力的场景，ArkUI开发框架提供了Native侧嵌入ArkTS组件的能力，该能力依赖ComponentContent机制，通过ComponentContent完成对ArkTS组件的封装，然后将封装对象转递到Native侧，通过Native侧的OH_ArkUI_GetNodeHandleFromNapiValue接口转化为ArkUI_NodeHandle对象用于Native侧组件挂载使用。
-  通过OH_ArkUI_GetNodeHandleFromNapiValue接口获得的ArkUI_NodeHandle对象只能作为子组件参数使用，如addChild接口的第二个参数，将该对象使用在其他场景下，如setAttribute设置属性将不生效并返回错误码。
-  针对Native侧修改ArkTS组件的场景，需要在Native侧通过Node-API方式构建ArkTS侧的更新数据，再通过ComponentContent的update接口更新。
-  构建自定义组件时，相关函数如measureNode等无法对ArkTS模块内部的组件进行调用。
以下示例代码在接入ArkTS页面章节基础上引入ArkTS的Refresh组件。
图1Refresh组件挂载文本列表
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170329.19981335346014012553234955116742:50001231000000:2800:8D23EDC5845B5800D5433AC022CE6E51AB96C2607B2AC1986DCC8125BBFB2BA9.gif)
1.  注册ArkTS组件创建函数给Native侧，以便Native侧调用，创建函数使用ComponentContent能力进行封装。
```typescript
// MixedModule.ets
// 使用ComponentContent能力创建ArkTS组件
import { NodeContent,  UIContext, RefreshModifier, ComponentContent } from '@kit.ArkUI';
// 定义Native侧和ArkTS进行交互的数据对象。
interface NativeRefreshAttribute {
isRefreshing: boolean;
width?: number;
height?: number;
backgroundColor?: number;
refreshOffset?: number;
pullToRefresh?: boolean
onRefreshing?: () => void;
onOffsetChange?: (offset: number) => void;
}
// 定义@Builder函数的入参格式。
interface RefreshAttribute {
isRefreshing: boolean;
// 属性设置通过Modifier优化性能
modifier?: RefreshModifier;
slot?: NodeContent;
onRefreshing?: () => void;
onOffsetChange?: (offset: number) => void;
}
// ComponentContent封装ArkTS组件依赖全局@Builder函数，涉及复杂自定义组件场景，可以在@Builder函数中嵌套@Component自定义组件。
// @Builder函数提供入参方式，方便后续通过ComponentContent的update接口进行参数更新。
@Builder
function mixedRefresh(attribute: RefreshAttribute) {
Refresh({ refreshing: attribute.isRefreshing }) {
// Refresh作为容器组件，需要使用ContentSlot机制预留子组件占位
ContentSlot(attribute.slot)
}.attributeModifier(attribute.modifier)
.onRefreshing(() => {
console.info("on onRefreshing");
if (attribute.onRefreshing) {
console.info("on native onRefreshing");
attribute.onRefreshing();
}
})
.onOffsetChange((value: number) => {
console.info("on offset change: " + value);
if (attribute.onOffsetChange) {
console.info("on native onOffsetChange");
attribute.onOffsetChange(value);
}
})
}
// 定义创建函数的返回值，用于ArkTS侧和Native侧的交互。
interface MixedModuleResult {
// 定义针对Refresh构建函数的封装对象，用于Native侧转化为ArkUI_NodeHandle对象。
content?: ComponentContent<RefreshAttribute>;
// Refresh作为容器组件，需要使用ContentSlot机制挂载Native侧的子组件。
childSlot?: NodeContent;
}
// 提供创建ArkTS组件的入口函数。
export function createMixedRefresh(value: NativeRefreshAttribute): MixedModuleResult {
console.info("createMixedRefresh");
// 通过AppStorage对象在Ability启动的时候保持UI上下文对象。
let uiContent = AppStorage.get<UIContext>("context");
let modifier = new RefreshModifier();
if (value.width) {
modifier.width(value.width)
}
if (value.height) {
modifier.height(value.height)
}
if (value.backgroundColor) {
modifier.backgroundColor(value.backgroundColor)
}
if (value.pullToRefresh) {
modifier.pullToRefresh(value.pullToRefresh)
}
if (value.refreshOffset) {
modifier.refreshOffset(value.refreshOffset)
}
// 创建NodeContent插槽对象用于Refresh子组件挂载。
let nodeSlot = new NodeContent();
// 通过ComponentContent创建Refresh组件并将它封装起来。
let content = new ComponentContent<RefreshAttribute>(uiContent!, wrapBuilder<[RefreshAttribute]>(mixedRefresh),
{
isRefreshing: value.isRefreshing,
modifier: modifier,
slot: nodeSlot,
onRefreshing: value.onRefreshing,
onOffsetChange: value.onOffsetChange
});
// 将Refresh组件的封装对象及其子组件插槽对象传递给Native侧。
return { content: content, childSlot: nodeSlot };
}
// 定义Refresh组件的更新函数，用于Native侧更新。
// 在更新场景下，需要将Refresh组件的封装对象及其子组件插槽对象返回，防止组件重新创建。
export function updateMixedRefresh(refresh: ComponentContent<RefreshAttribute>, childSlot: NodeContent,
value: NativeRefreshAttribute): void {
let modifier = new RefreshModifier();
if (value.width) {
modifier.width(value.width)
}
if (value.height) {
modifier.height(value.height)
}
if (value.backgroundColor) {
modifier.backgroundColor(value.backgroundColor)
}
if (value.pullToRefresh) {
modifier.pullToRefresh(value.pullToRefresh)
}
if (value.refreshOffset) {
modifier.refreshOffset(value.refreshOffset)
}
// 调用ComponentContent的update接口进行更新。
refresh.update({
isRefreshing: value.isRefreshing,
modifier: modifier,
slot: childSlot,
onRefreshing: value.onRefreshing,
onOffsetChange: value.onOffsetChange
})
}
```
2.  将创建和更新函数注册给Native侧。
```typescript
// entry.ets
import nativeNode from 'libentry.so';
import { NodeContent } from '@kit.ArkUI';
import { createMixedRefresh, updateMixedRefresh } from './MixedModule'
@Entry
@Component
struct Index {
private rootSlot = new NodeContent();
@State @Watch('changeNativeFlag') showNative: boolean = false;
aboutToAppear(): void {
// 设置uiContext;
AppStorage.setOrCreate<UIContext>("context", this.getUIContext());
// 设置混合模式下的builder函数。
nativeNode.registerCreateMixedRefreshNode(createMixedRefresh);
nativeNode.registerUpdateMixedRefreshNode(updateMixedRefresh);
}
changeNativeFlag(): void {
if (this.showNative) {
// 创建NativeModule组件挂载
nativeNode.createNativeRoot(this.rootSlot)
} else {
// 销毁NativeModule组件
nativeNode.destroyNativeRoot()
}
}
build() {
Column() {
Button(this.showNative ? "HideNativeUI" : "ShowNativeUI").onClick(() => {
this.showNative = !this.showNative
})
Row() {
// ArkTS插入Native组件。
ContentSlot(this.rootSlot)
}.layoutWeight(1)
}
.width('100%')
.height('100%')
}
}
```
3.  Native侧通过Node-API保存创建和更新函数，用于后续调用。
4.  抽象混合模式下组件的基类，用于通用逻辑管理。
5.  实现Refresh组件的混合模式封装对象。 相关实现类说明：
6.  使用接入ArkTS页面章节的页面结构，并沿用定时器模块相关简单实现，将Refresh组件作为文本列表的父组件。 替换入口组件创建为下拉刷新文本列表。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ndk-accessibility-xcomponent-V14
爬取时间: 2025-04-27 23:45:40
来源: Huawei Developer
通过XComponent接入的三方平台，NDK提供了对接无障碍的接口函数，实现三方平台的组件在ArkUI中的无障碍能力。
首先，需要使用XComponent的OH_NativeXComponent_GetNativeAccessibilityProvider获得无障碍接入provider。然后，通过OH_ArkUI_AccessibilityProviderRegisterCallback注册接入无障碍所需的回调函数ArkUI_AccessibilityProviderCallbacks，三方应用需要按照接口要求实现回调函数供无障碍系统调用。
三方应用需要按照要求适配无障碍系统发出的操作Action，以及针对组件交互行为发送无障碍事件Event到无障碍子系统，实现无障碍辅助应用的交互体验。
对接无障碍
以下示例提供了对接无障碍能力的实现方法。对接完成后，在开启无障碍功能时，可使XComponent中的三方绘制组件接入，实现无障碍交互。
1.按照自定义渲染（XComponent）创建前置工程。
2.根据接口定义实现回调函数。
3.使用XComponent句柄注册无障碍回调函数。
4.组件发生变化时，主动发送事件。参考事件定义ArkUI_AccessibilityEventType说明。
如果因为Touch事件导致页面变化，需要发送页面变化事件ARKUI_ACCESSIBILITY_NATIVE_EVENT_TYPE_PAGE_STATE_UPDATE以及获焦组件位置变化事件ARKUI_ACCESSIBILITY_NATIVE_EVENT_TYPE_FOCUS_NODE_UPDATE给无障碍子系统。
5.对接成功后，可开启无障碍功能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170329.97355627424203724256566039948149:50001231000000:2800:09AA321F80C8CD11C6F09C8A919D625D7943AE057502593EC42F297FC4969393.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-dev-V14
爬取时间: 2025-04-27 23:45:53
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-overview-V14
爬取时间: 2025-04-27 23:46:07
来源: Huawei Developer
兼容JS的类Web开发范式的方舟开发框架，采用经典的HML、CSS、JavaScript三段式开发方式。使用HML标签文件进行布局搭建，使用CSS文件进行样式描述，使用JavaScript文件进行逻辑处理。UI组件与数据之间通过单向数据绑定的方式建立关联，当数据发生变化时，UI界面自动触发更新。此种开发方式，更接近Web前端开发者的使用习惯，快速将已有的Web应用改造成方舟开发框架应用。主要适用于界面较为简单的中小型应用开发。
请参考兼容JS的类Web开发范式API文档，全面地了解组件，更好地开发应用。
整体架构
兼容JS的类Web开发范式的方舟开发框架，包括应用层（Application）、前端框架层（Framework）、引擎层（Engine）和平台适配层（Porting Layer）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170329.69423688764987225323817465889980:50001231000000:2800:C81F6E4AF47A974C022D12777E880A02415399965F053E18350FBA4FA353ECED.png)
-  Application 应用层表示开发者开发的FA应用，这里的FA应用特指JS FA应用。
-  Framework 前端框架层主要完成前端页面解析，并提供MVVM（Model-View-ViewModel）开发模式、页面路由机制和自定义组件等能力。
-  Engine 引擎层主要提供动画解析、DOM（Document Object Model）树构建、布局计算、渲染命令构建与绘制、事件管理等能力。
-  Porting Layer 适配层主要对平台层进行抽象，提供抽象接口，可以对接到系统平台。比如：事件对接、渲染管线对接和系统生命周期对接等。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/js-framework-overview-V14
爬取时间: 2025-04-27 23:46:21
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/js-framework-file-V14
爬取时间: 2025-04-27 23:46:34
来源: Huawei Developer
目录结构
JS FA应用的JS模块（entry/src/main/js/module）的典型开发目录结构如下：
图1目录结构
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170330.19941183708869766695231540299416:50001231000000:2800:312DFC6DDC536517BDB63443A80F1EAAEC923AAE6A68D0637625104790607ECB.png)
图2多实例资源共享目录结构
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170330.64012248419022261549356654635728:50001231000000:2800:3E82DE304C4E7460FEFB4E74653298E7BEC6B37B581C19D35109A4609DA6D835.png)
目录结构中文件分类如下：
-  .hml结尾的HML模板文件，描述当前页面的文件布局结构。
-  .css结尾的CSS样式文件，描述页面样式。
-  .js结尾的JS文件，处理页面间的交互。
各个文件夹的作用：
-  app.js文件用于全局JavaScript逻辑和应用生命周期管理，详见app.js。
-  pages目录用于存放所有组件页面。
-  common目录用于存放公共资源文件，比如：媒体资源，自定义组件和JS文件。
-  resources目录用于存放资源配置文件，比如：多分辨率加载等配置文件，详见资源限定与访问章节。
-  share目录用于配置多个实例共享的资源内容，比如：share中的图片和JSON文件可被default1和default2实例共享。
-  i18n和resources文件夹不可重命名。
-  如果share目录中的资源和实例(default)中的资源文件同名且目录一致时，实例中资源的优先级高于share中资源的优先级。
-  share目录当前不支持i18n。
-  在使用DevEco Studio进行应用开发时，目录结构中的可选文件夹需要开发者根据实际情况自行创建。
文件访问规则
应用资源可通过绝对路径或相对路径的方式进行访问，绝对路径以"/"开头，相对路径以"./"或"../"。具体访问规则如下：
-  引用代码文件，推荐使用相对路径，比如：../common/utils.js。
-  引用资源文件，推荐使用绝对路径。比如：/common/xxx.png。
-  公共代码文件和资源文件推荐放在common下，通过以上两条规则进行访问。
-  CSS样式文件中通过url()函数创建<url>数据类型，如：url(/common/xxx.png)。
当代码文件A需要引用代码文件B时：
-  如果代码文件A和文件B位于同一目录，则代码文件B引用资源文件时可使用相对路径，也可使用绝对路径。
-  如果代码文件A和文件B位于不同目录，则代码文件B引用资源文件时必须使用绝对路径。因为Webpack打包时，代码文件B的目录会发生变化。
-  在js文件中通过数据绑定的方式指定资源文件路径时，必须使用绝对路径。
媒体文件格式
表1支持的图片格式
| 格式 | 支持的文件类型 |
| --- | --- |
| BMP | .bmp |
| GIF | .gif |
| JPEG | .jpg |
| PNG | .png |
| WebP | .webp |
表2支持的视频格式
| 格式 | 支持的文件类型 |
| --- | --- |
| H.264 AVC Baseline Profile (BP)  | .3gp .mp4  |
H.264 AVC
Baseline Profile (BP)
.3gp
.mp4

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/js-framework-js-tag-V14
爬取时间: 2025-04-27 23:46:48
来源: Huawei Developer
js标签中包含了实例名称、页面路由和窗口样式信息。
| 标签 | 类型 | 默认值 | 必填 | 描述 |
| --- | --- | --- | --- | --- |
| name | string | default | 是 | 标识JS实例的名字。 |
| pages | Array | - | 是 | 路由信息，详见“pages”。 |
| window | Object | - | 否 | 窗口信息，详见“window”。 |
name、pages和window等标签配置需在配置文件（config.json）中的“js”标签中完成设置。
pages
定义每个页面的路由信息，每个页面由页面路径和页面名组成，页面的文件名就是页面名。比如：
```json
{
// ...
"pages": [
"pages/index/index",
"pages/detail/detail"
]
// ...
}
```
-  pages列表中第一个页面是应用的首页，即entry入口。
-  页面文件名不能使用组件名称，比如：text.hml、button.hml等。
window
window用于定义与显示窗口相关的配置。对于屏幕适配问题，有2种配置方法：
-  指定designWidth（屏幕逻辑宽度），所有与大小相关的样式（例如width、font-size）均以designWidth和实际屏幕宽度的比例进行缩放，例如在designWidth为720时，如果设置width为100px时，在实际宽度为1440物理像素的屏幕上，width实际渲染像素为200物理像素。
-  设置autoDesignWidth为true，此时designWidth字段将会被忽略，渲染组件和布局时按屏幕密度进行缩放。屏幕逻辑宽度由设备宽度和屏幕密度自动计算得出，在不同设备上可能不同，请使用相对布局来适配多种设备。例如：在466*466分辨率，320dpi的设备上，屏幕密度为2（以160dpi为基准），1px等于渲染出的2物理像素。 组件样式中<length>类型的默认值，按屏幕密度进行计算和绘制，如：在屏幕密度为2（以160dpi为基准）的设备上，默认<length>为1px时，设备上实际渲染出2物理像素。 autoDesignWidth、designWidth的设置不影响默认值计算方式和绘制结果。
-  组件样式中<length>类型的默认值，按屏幕密度进行计算和绘制，如：在屏幕密度为2（以160dpi为基准）的设备上，默认<length>为1px时，设备上实际渲染出2物理像素。
-  autoDesignWidth、designWidth的设置不影响默认值计算方式和绘制结果。
1.  组件样式中<length>类型的默认值，按屏幕密度进行计算和绘制，如：在屏幕密度为2（以160dpi为基准）的设备上，默认<length>为1px时，设备上实际渲染出2物理像素。
2.  autoDesignWidth、designWidth的设置不影响默认值计算方式和绘制结果。
| 属性 | 类型 | 必填 | 缺省值 | 描述 |
| --- | --- | --- | --- | --- |
| designWidth | number | 否 | 720  | 页面显示设计时的参考值，实际显示效果基于设备宽度与参考值之间的比例进行缩放。 |
| autoDesignWidth | boolean | 否 | false | 页面设计基准宽度是否自动计算，当设为true时，designWidth将会被忽略，设计基准宽度由设备宽度与屏幕密度计算得出。 |
720
示例如下：
```json
{
// ...
"window": {
"designWidth": 720,
"autoDesignWidth": false
}
// ...
}
```
示例
```json
{
"app": {
"bundleName": "com.example.player",
"version": {
"code": 1,
"name": "1.0"
},
"vendor": "example"
}
"module": {
// ...
"js": [
{
"name": "default",
"pages": [
"pages/index/index",
"pages/detail/detail"
],
"window": {
"designWidth": 720,
"autoDesignWidth": false
}
}
],
"abilities": [
{
// ...
}
]
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/js-framework-js-file-V14
爬取时间: 2025-04-27 23:47:02
来源: Huawei Developer
应用生命周期
每个应用可以在app.js自定义应用级生命周期的实现逻辑，以下示例仅在生命周期函数中打印对应日志：
应用对象6+
| 属性 | 类型 | 描述 |
| --- | --- | --- |
| getApp | Function | 提供getApp()全局方法，可以在自定义js文件中获取app.js中暴露的对象。 |
示例如下：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/js-framework-syntax-V14
爬取时间: 2025-04-27 23:47:16
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/js-framework-syntax-hml-V14
爬取时间: 2025-04-27 23:47:30
来源: Huawei Developer
HML是一套类HTML的标记语言，通过组件，事件构建出页面的内容。页面具备数据绑定、事件绑定、列表渲染、条件渲染和逻辑控制等高级能力。
页面结构
数据绑定
-  针对数组内的数据修改，请使用splice方法生效数据绑定变更。
-  hml文件中的js表达式不支持ES6语法。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170330.34578478973115401417771604917208:50001231000000:2800:D610ED2CFD1265813A2D5AF3243FFDFCA86AC2A7DB076F0D26A01ED3A51322A5.png)
普通事件绑定
事件通过'on'或者'@'绑定在组件上，当组件触发事件时会执行JS文件中对应的事件处理函数。
事件支持的写法有：
-  "funcName"：funcName为事件回调函数名（在JS文件中定义相应的函数实现）。
-  "funcName(a,b)"：函数参数例如a，b可以是常量，或者是在JS文件中的data中定义的变量（前面不用写this.）。
-  示例
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170330.25346983602422381801428772182817:50001231000000:2800:4DC81C6A5224ADD2F2F0ED326A047E45DE3D6BB7A8A047AE426835036CD8726E.gif)
冒泡事件绑定5+
冒泡事件绑定包括：
-  绑定冒泡事件：on:{event}.bubble。on:{event}等价于on:{event}.bubble。
-  绑定并阻止冒泡事件向上冒泡：grab:{event}.bubble。grab:{event}等价于grab:{event}.bubble。 冒泡事件是指多个组件嵌套时，组件之间会有层次关系，当这些组件注册了相同的事件时，这个事件会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，一直向上到其他祖先上的处理程序。如果当一个组件触发了这个事件，它会首先触发该组件的回调函数，然后触发其父元素上的回调函数，然后触发其他祖先上的处理程序。 详细冒泡事件说明参见通用事件章节。
-  示例
采用旧写法(onclick)的事件绑定在最小API版本6以下时采用不冒泡处理，在最小API版本为6及6以上时采用冒泡处理。
捕获事件绑定5+
Touch触摸类事件支持捕获，捕获阶段位于冒泡阶段之前，捕获事件先到达父组件然后达到子组件。
捕获事件绑定包括：
-  绑定捕获事件：on:{event}.capture。
-  绑定并阻止事件向下传递：grab:{event}.capture。
-  示例
列表渲染
tid属性主要用来加速for循环的重渲染，旨在列表中的数据有变更时，提高重新渲染的效率。tid属性是用来指定数组中每个元素的唯一标识，如果未指定，数组中每个元素的索引为该元素的唯一id。例如上述tid="id"表示数组中的每个元素的id属性为该元素的唯一标识。for循环支持的写法如下：
-  for="array"：其中array为数组对象，array的元素变量默认为$item。
-  for="v in array"：其中v为自定义的元素变量，元素索引默认为$idx。
-  for="(i, v) in array"：其中元素索引为i，元素变量为v，遍历数组对象array。
-  数组中的每个元素必须存在tid指定的数据属性，否则运行时可能会导致异常。
-  数组中被tid指定的属性要保证唯一性，如果不是则会造成性能损耗。比如，示例中只有id和name可以作为tid字段，因为它们属于唯一字段。
-  tid不支持表达式。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170331.70178851816929529206206961519337:50001231000000:2800:4355EA40C610C0640FAA3880F85506A2E559E49A5C81FF375787E08B04A49EF5.gif)
条件渲染
条件渲染分为2种：if/elif/else和show。两种写法的区别在于：第一种写法里if为false时，组件不会在vdom中构建，也不会渲染，而第二种写法里show为false时虽然也不渲染，但会在vdom中构建；另外，当使用if/elif/else写法时，节点必须是兄弟节点，否则编译无法通过。实例如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170331.69438719405531536230701558816862:50001231000000:2800:BF68112EE7CB708D137F0B6A469AEDE8B5A02BCFC5A1C6836B37A33EC96B5172.gif)
优化渲染优化：show方法。当show为true时，节点正常渲染；当为false时，仅仅设置display样式为none。
禁止在同一个元素上同时设置for和if属性。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170331.90685104744507903561465177808235:50001231000000:2800:F3BD71448692208D26BC067BB6410C0F46C8463D9FE23391B832813BE19CFAD2.gif)
逻辑控制块
<block>控制块使得循环渲染和条件渲染变得更加灵活；block在构建时不会被当作真实的节点编译。注意block标签只支持for和if属性。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170331.08513217849559162222344875549445:50001231000000:2800:DDCEB40EBE98B8E2DAE5C1166278ABC1CD6A8F30D2839189B59B5A25CF7656AC.png)
模板引用
HML可以通过element引用模板文件，详细介绍可参考自定义组件的基本用法章节。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/js-framework-syntax-css-V14
爬取时间: 2025-04-27 23:47:43
来源: Huawei Developer
CSS是描述HML页面结构的样式语言。所有组件均存在系统默认样式，也可在页面CSS样式文件中对组件、页面自定义不同的样式。请参考通用样式了解兼容JS的类Web开发范式支持的组件样式。
尺寸单位
-  逻辑像素px（文档中以<length>表示）：
-  百分比（文档中以<percentage>表示）：表示该组件占父组件尺寸的百分比，如组件的width设置为50%，代表其宽度为父组件的50%。
样式导入
为了模块化管理和代码复用，CSS样式文件支持 @import 语句，导入css文件。
声明样式
每个页面目录下存在一个与布局hml文件同名的css文件，用来描述该hml页面中组件的样式，决定组件应该如何显示。
1.  内部样式，支持使用style、class属性来控制组件的样式。例如：
2.  文件导入，合并外部样式文件。例如，在common目录中定义样式文件style.css，并在index.css文件首行中进行导入：
选择器
css选择器用于选择需要添加样式的元素，支持的选择器如下表所示：
| 选择器 | 样例 | 样例描述 |
| --- | --- | --- |
| .class | .container | 用于选择class="container"的组件。 |
| #id | #titleId | 用于选择id="titleId"的组件。 |
| tag | text | 用于选择text组件。 |
| , | .title, .content | 用于选择class="title"和class="content"的组件。 |
| #id .class tag | #containerId .content text | 非严格父子关系的后代选择器，选择具有id="containerId"作为祖先元素，class="content"作为次级祖先元素的所有text组件。如需使用严格的父子关系，可以使用“>”代替空格，如：#containerId>.content。 |
示例：
以上样式运行效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170331.15533146621835034044794673251172:50001231000000:2800:E8969A1F3A27D384324783C12D9AE0320CCEEF7146B1B883C68B416145BF50DD.png)
其中“.container text”将“标题”和“内容”设置为蓝色，而“.container > text”直接后代选择器将“标题”设置为红色。2者优先级相同，但直接后代选择器声明顺序靠后，将前者样式覆盖（优先级计算见选择器优先级）。
选择器优先级
选择器的优先级计算规则与w3c规则保持一致（只支持：内联样式，id，class，tag，后代和直接后代），其中内联样式为在元素style属性中声明的样式。
当多条选择器声明匹配到同一元素时，各类选择器优先级由高到低顺序为：内联样式 > id > class > tag。
伪类
css伪类是选择器中的关键字，用于指定要选择元素的特殊状态。例如，:disabled状态可以用来设置元素的disabled属性变为true时的样式。
除了单个伪类之外，还支持伪类的组合，例如，:focus:checked状态可以用来设置元素的focus属性和checked属性同时为true时的样式。支持的单个伪类如下表所示，按照优先级降序排列：
| 名称 | 支持组件 | 描述 |
| --- | --- | --- |
| :disabled | 支持disabled属性的组件 | 表示disabled属性变为true时的元素（不支持动画样式的设置）。 |
| :active | 支持click事件的组件 | 表示被用户激活的元素，如：被用户按下的按钮、被激活的tab-bar页签（不支持动画样式的设置）。 |
| :waiting | button | 表示waiting属性为true的元素（不支持动画样式的设置）。 |
| :checked | input[type="checkbox"、type="radio"]、 switch | 表示checked属性为true的元素（不支持动画样式的设置）。 |
支持click事件的组件
伪类示例如下，设置按钮的:active伪类可以控制被用户按下时的样式：
针对弹窗类组件及其子元素不支持伪类效果，包括popup、dialog、menu、option、picker。
样式预编译
预编译提供了利用特有语法生成css的程序，可以提供变量、运算等功能，令开发者更便捷地定义组件样式，目前支持less、sass和scss的预编译。使用样式预编译时，需要将原css文件后缀改为less、sass或scss，如index.css改为index.less、index.sass或index.scss。
-  当前文件使用样式预编译，例如将原index.css改为index.less：
-  引用预编译文件，例如common中存在style.scss文件，将原index.css改为index.scss，并引入style.scss： 在index.scss中引用： 引用的预编译文件建议放在common目录进行管理。
CSS样式继承6+
css样式继承提供了子节点继承父节点样式的能力，继承下来的样式在多选择器样式匹配的场景下，优先级排最低，当前支持以下样式的继承：
-  font-family
-  font-weight
-  font-size
-  font-style
-  text-align
-  line-height
-  letter-spacing
-  color
-  visibility

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/js-framework-syntax-js-V14
爬取时间: 2025-04-27 23:47:57
来源: Huawei Developer
JS文件用来定义HML页面的业务逻辑，支持ECMA规范的JavaScript语言。基于JavaScript语言的动态化能力，可以使应用更加富有表现力，具备更加灵活的设计能力。下面讲述JS文件的编译和运行的支持情况。
语法
支持ES6语法。
-  模块声明 使用import方法引入功能模块：
-  代码引用 使用import方法导入js代码：
对象
-  应用对象 使用this.$app.$def获取在app.js中暴露的对象。 说明： 应用对象不支持数据绑定，需主动触发UI更新。 示例代码
-  页面对象 页面的数据模型，类型是对象或者函数，如果类型是函数，返回值必须是对象。属性名不能以$或_开头，不要使用保留字for, if, show, tid。 data与private和public不能重合使用。
| 属性 | 类型 | 描述 |
| --- | --- | --- |
| $def | Object | 使用this.$app.$def获取在app.js中暴露的对象。 说明： 应用对象不支持数据绑定，需主动触发UI更新。 |
| 属性 | 类型 | 描述 |
| --- | --- | --- |
| data | Object/Function | 页面的数据模型，类型是对象或者函数，如果类型是函数，返回值必须是对象。属性名不能以$或_开头，不要使用保留字for, if, show, tid。 data与private和public不能重合使用。 |
| $refs | Object | 持有注册过ref 属性的DOM元素或子组件实例的对象。示例见获取DOM元素。 |
| private | Object | 页面的数据模型，private下的数据属性只能由当前页面修改。 |
| public | Object | 页面的数据模型，public下的数据属性的行为与data保持一致。 |
| props | Array/Object | props用于组件之间的通信，可以通过<tag xxxx='value'>方式传递给组件；props名称必须用小写，不能以$或_开头，不要使用保留字for, if, show, tid。目前props的数据类型不支持Function。示例见Props。 |
| computed | Object | 用于在读取或设置进行预先处理，计算属性的结果会被缓存。计算属性名不能以$或_开头，不要使用保留字。示例见computed。 |
方法
-  数据方法 添加新的数据属性或者修改已有数据属性。 用法： this.$set('key',value)：添加数据属性。 删除数据属性。 用法： this.$delete('key')：删除数据属性。 示例代码
-  公共方法 获得指定id的组件对象，如果无指定id，则返回根组件对象。示例见获取DOM元素。 用法： <div id='xxx'></div> - this.$element('xxx')：获得id为xxx的组件对象。 - this.$element()：获得根组件对象。 获取根组件对象。 用法： this.$rootElement().scrollTo({ duration: 500, position: 300 }), 页面在500ms内滚动300px。 获得指定id的子级自定义组件的ViewModel实例。获取ViewModel示例。 用法： this.$child('xxx') ：获取id为xxx的子级自定义组件的ViewModel实例。
-  事件方法 观察data中的属性变化，如果属性值改变，触发绑定的事件。示例见$watch感知数据改变。 用法： this.$watch('key', callback)：通过监听key属性值的变化，触发callback事件。
-  页面方法 表1ScrollPageParam6+ 指定滚动动画曲线，可选值参考 动画样式animation-timing-function。 示例：
| 方法 | 参数 | 描述 |
| --- | --- | --- |
| $set | key: string, value: any | 添加新的数据属性或者修改已有数据属性。 用法： this.$set('key',value)：添加数据属性。 |
| $delete | key: string | 删除数据属性。 用法： this.$delete('key')：删除数据属性。 |
| 方法 | 参数 | 描述 |
| --- | --- | --- |
| $element | id: string | 获得指定id的组件对象，如果无指定id，则返回根组件对象。示例见获取DOM元素。 用法： <div id='xxx'></div> - this.$element('xxx')：获得id为xxx的组件对象。 - this.$element()：获得根组件对象。 |
| $rootElement | 无 | 获取根组件对象。 用法： this.$rootElement().scrollTo({ duration: 500, position: 300 }), 页面在500ms内滚动300px。 |
| $root | 无 | 获得顶级ViewModel实例。获取ViewModel示例。 |
| $parent | 无 | 获得父级ViewModel实例。获取ViewModel示例。 |
| $child | id: string | 获得指定id的子级自定义组件的ViewModel实例。获取ViewModel示例。 用法： this.$child('xxx') ：获取id为xxx的子级自定义组件的ViewModel实例。 |
| 方法 | 参数 | 描述 |
| --- | --- | --- |
| $watch | data: string, callback: string | Function | 观察data中的属性变化，如果属性值改变，触发绑定的事件。示例见$watch感知数据改变。 用法： this.$watch('key', callback)：通过监听key属性值的变化，触发callback事件。 |
| 方法 | 参数 | 描述 |
| --- | --- | --- |
| scrollTo6+ | scrollPageParam: ScrollPageParam | 将页面滚动到目标位置，可以通过ID选择器指定或者滚动距离指定。 |
| 名称 | 类型 | 默认值 | 描述 |
| --- | --- | --- | --- |
| position | number | - | 指定滚动位置。 |
| id | string | - | 指定需要滚动到的元素id。 |
| duration | number | 300 | 指定滚动时长，单位为毫秒。 |
| timingFunction | string | ease | 指定滚动动画曲线，可选值参考 动画样式animation-timing-function。 |
| complete | () => void | - | 指定滚动完成后需要执行的回调函数。 |
获取DOM元素
1.  通过$refs获取DOM元素
2.  通过$element获取DOM元素
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170331.11553241784032570643815281510456:50001231000000:2800:D0FADC71D3F66136F84A4167F0E414EE22C131D298ABBF880F59D243E6C7F6FB.gif)
获取ViewModel
根节点所在页面：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170331.42549950815692055716982353979952:50001231000000:2800:D03A594BB1CFB0642951003C428046A04E72D7D328CAA5399956746C557AEF13.png)
自定义parent组件：
自定义child组件：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170331.29892067871737543741267814309930:50001231000000:2800:2CEF1210273A3E1A6B5E330A2B66F4B1CBDB7A5AD2404F3B199F1F9FA695C75A.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/js-framework-lifecycle-V14
爬取时间: 2025-04-27 23:48:11
来源: Huawei Developer
应用生命周期
在app.js中可以定义如下应用生命周期函数：
| 属性 | 类型 | 描述 | 触发时机 |
| --- | --- | --- | --- |
| onCreate | () => void | 应用创建 | 当应用创建时调用。 |
| onShow6+ | () => void | 应用处于前台 | 当应用处于前台时触发。 |
| onHide6+ | () => void | 应用处于后台 | 当应用处于后台时触发。 |
| onDestroy | () => void | 应用销毁 | 当应用退出时触发。 |
页面生命周期
在页面JS文件中可以定义如下页面生命周期函数：
| 属性 | 类型 | 描述 | 触发时机 |
| --- | --- | --- | --- |
| onInit | () => void | 页面初始化 | 页面数据初始化完成时触发，只触发一次。 |
| onReady | () => void | 页面创建完成 | 页面创建完成时触发，只触发一次。 |
| onShow | () => void | 页面显示 | 页面显示时触发。 |
| onHide | () => void | 页面消失 | 页面消失时触发。 |
| onDestroy | () => void | 页面销毁 | 页面销毁时触发。 |
| onBackPress | () => boolean | 返回按钮动作 | 当用户点击返回按钮时触发。 - 返回true表示页面自己处理返回逻辑。 - 返回false表示使用默认的返回逻辑。 - 不返回值会作为false处理。  |
| onActive()5+ | () => void | 页面激活 | 页面激活时触发。 |
| onInactive()5+ | () => void | 页面暂停 | 页面暂停时触发。 |
| onNewRequest()5+ | () => void | FA重新请求 | FA已经启动时收到新的请求后触发。 |
当用户点击返回按钮时触发。
- 返回true表示页面自己处理返回逻辑。
- 返回false表示使用默认的返回逻辑。
- 不返回值会作为false处理。
页面A的生命周期接口的调用顺序
-  打开页面A：onInit() -> onReady() -> onShow()
-  在页面A打开页面B：onHide()
-  从页面B返回页面A：onShow()
-  退出页面A：onBackPress() -> onHide() -> onDestroy()
-  页面隐藏到后台运行：onInactive() -> onHide()
-  页面从后台运行恢复到前台：onShow() -> onActive()
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170331.68899601303024576629519868242297:50001231000000:2800:6BABDFD3425ECF9EAA743A54C6F9943205A1E883957C12E5CA5224AED4EC0391.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/js-framework-resource-restriction-V14
爬取时间: 2025-04-27 23:48:24
来源: Huawei Developer
资源限定词
资源限定词可以由一个或多个表征应用场景或设备特征的限定词组合而成，包括屏幕密度等维度，限定词之间通过中划线（-）连接。开发者在resources目录下创建限定词文件时，需要掌握限定词文件的命名要求以及与限定词文件与设备状态的匹配规则。
资源限定词的命名要求
-  限定词的组合顺序：屏幕密度。开发者可以根据应用的使用场景和设备特征，选择其中的一类或几类限定词组成目录名称，顺序不可颠倒。
-  限定词的连接方式：限定词之间均采用中划线（-）连接。例如：res-dark-ldpi.json 。
-  限定词的取值范围：每类限定词的取值必须符合下表的条件，否则，将无法匹配目录中的资源文件，限定词大小写敏感。
-  限定词前缀：resources资源文件的资源限定词有前缀res，例如res-ldpi.json。
-  默认资源限定文件：resources资源文件的默认资源限定文件为res-defaults.json。
-  资源限定文件中不支持使用枚举格式的颜色来设置资源。
表1资源限定词
| 类型 | 含义与取值说明 |
| --- | --- |
| 屏幕密度 | 表示设备的屏幕密度（单位为dpi），取值如下： - ldpi：表示低密度屏幕（~120dpi）（0.75基准密度） - mdpi：表示中密度屏幕（~160dpi）（基准密度） - hdpi：表示高密度屏幕（~240dpi）（1.5基准密度） - xhdpi：表示加高密度屏幕（~320dpi）（2.0基准密度） - xxhdpi：表示超超高密度屏幕（~480dpi）（3.0基准密度） - xxxhdpi：表示超超超高密度屏幕（~640dpi）（4.0基准密度）  |
表示设备的屏幕密度（单位为dpi），取值如下：
- ldpi：表示低密度屏幕（~120dpi）（0.75基准密度）
- mdpi：表示中密度屏幕（~160dpi）（基准密度）
- hdpi：表示高密度屏幕（~240dpi）（1.5基准密度）
- xhdpi：表示加高密度屏幕（~320dpi）（2.0基准密度）
- xxhdpi：表示超超高密度屏幕（~480dpi）（3.0基准密度）
- xxxhdpi：表示超超超高密度屏幕（~640dpi）（4.0基准密度）
限定词与设备状态的匹配规则
-  在为设备匹配对应的资源文件时，限定词目录匹配的优先级从高到低依次为：MCC和MNC> 横竖屏 > 深色模式 > 设备类型 > 屏幕密度。在资源限定词目录均未匹配的情况下，则匹配默认资源限定文件。
-  如果限定词目录中包含资源限定词，则对应限定词的取值必须与当前的设备状态完全一致，该目录才能够参与设备的资源匹配。例如：资源限定文件res-hdpi.json与当前设备密度xhdpi无法匹配。
引用JS模块内resources资源
在应用开发的hml和js文件中使用$r的语法，可以对JS模块内的resources目录下的json资源进行格式化，获取相应的资源内容，该目录与pages目录同级，具体目录结构请参考文件组织。
| 属性 | 类型 | 描述 |
| --- | --- | --- |
| $r | (key: string) => string | 获取资源限定下具体的资源内容。例如：$r('strings.hello')。 参数说明： - key：定义在资源限定文件中的键值，如strings.hello。  |
获取资源限定下具体的资源内容。例如：$r('strings.hello')。
参数说明：
- key：定义在资源限定文件中的键值，如strings.hello。
res-defaults.json示例：
```json
{
"strings": {
"hello": "hello world"
}
}
```
示例
resources/res-dark.json:
```json
{
"image": {
"clockFace": "common/dark_face.png"
},
"colors": {
"background": "#000000"
}
}
```
resources/res-defaults.json:
```json
{
"image": {
"clockFace": "common/face.png"
},
"colors": {
"background": "#ffffff"
}
}
```
资源限定文件中不支持颜色枚举格式。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/js-framework-multiple-languages-V14
爬取时间: 2025-04-27 23:48:39
来源: Huawei Developer
基于开发框架的应用会覆盖多个国家和地区，开发框架支持多语言能力后，可以让应用开发者无需开发多个不同语言的版本，就可以同时支持多种语言的切换，为项目维护带来便利。
开发者仅需要通过定义资源文件和引用资源两个步骤，就可以使用开发框架的多语言能力；如果需要在应用中获取当前系统语言，请参考获取语言。
定义资源文件
资源文件用于存放应用在多种语言场景下的资源内容，开发框架使用JSON文件保存资源定义。在文件组织中指定的i18n文件夹内放置语言资源文件，其中语言资源文件的命名是由语言、文字、国家或地区的限定词通过中划线连接组成，其中文字和国家或地区可以省略，如zh-Hant-HK（中国香港地区使用的繁体中文）、zh-CN（中国使用的简体中文）、zh（中文）。命名规则如下：
限定词的取值需符合下表要求。
表1 限定词取值要求
| 限定词类型 | 含义与取值说明 |
| --- | --- |
| 语言 | 表示设备使用的语言类型，由2~3个小写字母组成。例如：zh表示中文，en表示英语，mai表示迈蒂利语。 详细取值范围，请查阅ISO 639（ISO制定的语言编码标准）。 |
| 文字 | 表示设备使用的文字类型，由1个大写字母（首字母）和3个小写字母组成。例如：Hans表示简体中文，Hant表示繁体中文。 详细取值范围，请查阅ISO 15924（ISO制定的文字编码标准）。 |
| 国家或地区 | 表示用户所在的国家或地区，由2~3个大写字母或者3个数字组成。例如：CN表示中国，GB表示英国。 详细取值范围，请查阅ISO 3166-1（ISO制定的国家和地区编码标准）。 |
表示设备使用的语言类型，由2~3个小写字母组成。例如：zh表示中文，en表示英语，mai表示迈蒂利语。
详细取值范围，请查阅ISO 639（ISO制定的语言编码标准）。
表示设备使用的文字类型，由1个大写字母（首字母）和3个小写字母组成。例如：Hans表示简体中文，Hant表示繁体中文。
详细取值范围，请查阅ISO 15924（ISO制定的文字编码标准）。
表示用户所在的国家或地区，由2~3个大写字母或者3个数字组成。例如：CN表示中国，GB表示英国。
详细取值范围，请查阅ISO 3166-1（ISO制定的国家和地区编码标准）。
当开发框架无法在应用中找到系统语言的资源文件时，默认使用en-US.json中的资源内容。
资源文件内容格式如下：
en-US.json
```json
{
"strings": {
"hello": "Hello world!",
"object": "Object parameter substitution-{name}",
"array": "Array type parameter substitution-{0}",
"symbol": "@#$%^&*()_+-={}[]\\|:;\"'<>,./?"
},
"files": {
"image": "image/en_picture.PNG"
}
}
```
由于不同语言针对单复数有不同的匹配规则，在资源文件中使用“zero”“one”“two”“few”“many”“other”定义不同单复数场景下的词条内容。例如中文不区分单复数，仅存在“other”场景；英文存在“one”、“other”场景；阿拉伯语存在上述6种场景。
以en-US.json和ar-AE.json为例，资源文件内容格式如下：
en-US.json
```json
{
"strings": {
"people": {
"one": "one person",
"other": "{count} people"
}
}
}
```
ar-AE.json
```json
{
"strings": {
"people": {
"zero": "لا أحد",
"one": "وحده",
"two": "اثنان",
"few": "ستة اشخاص",
"many": "خمسون شخص",
"other": "مائة شخص"
}
}
}
```
引用资源
在应用开发的页面中使用多语言的语法，包含简单格式化和单复数格式化两种，都可以在hml或js中使用。
-  简单格式化方法 在应用中使用$t方法引用资源，$t既可以在hml中使用，也可以在js中使用。系统将根据当前语言环境和指定的资源路径（通过$t的path参数设置），显示对应语言的资源文件中的内容。 表2 简单格式化 表3 $t参数说明 运行时用来替换占位符的实际内容，占位符分为两种： - 具名占位符，例如{name}。实际内容必须用Object类型指定，例如：$t('strings.object', {name:'Hello world'})。 - 数字占位符，例如{0}。实际内容必须用Array类型指定，例如：$t('strings.array', [Hello world']。
-  简单格式化示例代码
-  单复数格式化方法 表4 单复数格式化 根据系统语言完成单复数替换：this.$tc('strings.people')。 说明： 定义资源的内容通过json格式的key为“zero”、“one”、“two”、“few”、“many”和“other”区分。 表5 $tc参数说明
-  单复数格式化示例代码
| 属性 | 类型 | 参数 | 必填 | 描述 |
| --- | --- | --- | --- | --- |
| $t | Function | 请见表 $t参数说明 | 是 | 根据系统语言完成简单的替换：this.$t('strings.hello')。 |
| 参数 | 类型 | 必填 | 描述 |
| --- | --- | --- | --- |
| path | string | 是 | 资源路径。 |
| params | Array|Object | 否 | 运行时用来替换占位符的实际内容，占位符分为两种： - 具名占位符，例如{name}。实际内容必须用Object类型指定，例如：$t('strings.object', {name:'Hello world'})。 - 数字占位符，例如{0}。实际内容必须用Array类型指定，例如：$t('strings.array', [Hello world']。 |
| 属性 | 类型 | 参数 | 必填 | 描述 |
| --- | --- | --- | --- | --- |
| $tc | Function | 请见表 $tc参数说明 | 是 | 根据系统语言完成单复数替换：this.$tc('strings.people')。 说明： 定义资源的内容通过json格式的key为“zero”、“one”、“two”、“few”、“many”和“other”区分。 |
| 参数 | 类型 | 必填 | 描述 |
| --- | --- | --- | --- |
| path | string | 是 | 资源路径。 |
| count | number | 是 | 要表达的值。 |
获取语言
获取语言功能请参考@ohos.app.ability.Configuration (Configuration)。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-building-ui-V14
爬取时间: 2025-04-27 23:48:52
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-building-ui-component-V14
爬取时间: 2025-04-27 23:49:06
来源: Huawei Developer
组件（Component）是构建页面的核心，每个组件通过对数据和方法的简单封装，实现独立的可视、可交互功能单元。组件之间相互独立，随取随用，也可以在需求相同的地方重复使用。关于组件的详细参考文档请参见组件。
开发者还可以通过组件间合理的搭配定义满足业务需求的新组件，减少开发量，自定义组件的开发方法请参见自定义组件。
组件分类
根据组件的功能，可以分为以下六大类：
| 组件类型 | 主要组件 |
| --- | --- |
| 容器组件 | badge、dialog、div、form、list、list-item、list-item-group、panel、popup、refresh、stack、stepper、stepper-item、swiper、tabs、tab-bar、tab-content |
| 基础组件 | button、chart、divider、image、image-animator、input、label、marquee、menu、option、picker、picker-view、piece、progress、qrcode、rating、richtext、search、select、slider、span、switch、text、textarea、toolbar、toolbar-item、toggle |
| 媒体组件 | video |
| 画布组件 | canvas |
| 栅格组件 | grid-container、grid-row、grid-col |
| svg组件 | svg、rect、circle、ellipse、path、line、polyline、polygon、text、tspan、textPath、animate、animateMotion、animateTransform |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-building-layout-V14
爬取时间: 2025-04-27 23:49:19
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-building-ui-layout-intro-V14
爬取时间: 2025-04-27 23:49:33
来源: Huawei Developer
设备的基准宽度为720px（px为逻辑像素，非物理像素），实际显示效果会根据实际屏幕宽度进行缩放。
其换算关系如下：
组件的width设为100px时，在宽度为720物理像素的屏幕上，实际显示为100物理像素；在宽度为1440物理像素的屏幕上，实际显示为200物理像素。
一个页面的基本元素包含标题区域、文本区域、图片区域等，每个基本元素内还可以包含多个子元素，开发者根据需求还可以添加按钮、开关、进度条等组件。在构建页面布局时，需要对每个基本元素思考以下几个问题：
-  该元素的尺寸和排列位置
-  是否有重叠的元素
-  是否需要设置对齐、内间距或者边界
-  是否包含子元素及其排列位置
-  是否需要容器组件及其类型
将页面中的元素分解之后再对每个基本元素按顺序实现，可以减少多层嵌套造成的视觉混乱和逻辑混乱，提高代码的可读性，方便对页面做后续的调整。以下图为例进行分解：
图1页面布局分解
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170332.67077235301998392770189160444077:50001231000000:2800:8818F8282348E81B6751CE151995B6C0F7F163ADF48D4994A71B583932C8A7F5.png)
图2留言区布局分解
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170332.87695665249634263628393945420916:50001231000000:2800:63044724218D9C7C28B799DEAC037E443E9ED5BF6C9F68BCF799C1F87ACC7E51.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-building-ui-layout-text-V14
爬取时间: 2025-04-27 23:49:46
来源: Huawei Developer
实现标题和文本区域最常用的是基础组件text。text组件用于展示文本，可以设置不同的属性和样式，文本内容需要写在标签内容区，完整属性和样式信息请参考text。在页面中插入标题和文本区域的示例如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170332.72489312053286310084643074897647:50001231000000:2800:D902E9CB2421071315EC3EBD5106749F3351C2CCCFB32687BE186D94D44B86E1.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-building-ui-layout-image-V14
爬取时间: 2025-04-27 23:50:01
来源: Huawei Developer
添加图片区域通常用image组件来实现，使用的方法和text组件类似。
图片资源建议放在js\default\common目录下，common目录需自行创建，详细的目录结构见目录结构。代码示例如下：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-building-ui-layout-comment-V14
爬取时间: 2025-04-27 23:50:14
来源: Huawei Developer
留言框的功能为：用户输入留言后点击完成，留言区域即显示留言内容。用户点击右侧的删除按钮可删除当前留言内容并重新输入。
留言区域由div、text、input关联click事件实现。开发者可以使用input组件实现输入留言的部分，使用text组件实现留言完成部分，使用commentText的状态标记此时显示的组件（通过if属性控制）。在包含文本完成和删除的text组件中关联click事件，更新commentText状态和inputValue的内容。具体的实现示例如下：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-building-ui-layout-external-container-V14
爬取时间: 2025-04-27 23:50:28
来源: Huawei Developer
要将页面的基本元素组装在一起，需要使用容器组件。在页面布局中常用到三种容器组件，分别是div、list和tabs。在页面结构相对简单时，可以直接用div作为容器，因为div作为单纯的布局容器，可以支持多种子组件，使用起来更为方便。
List组件
当页面结构较为复杂时，如果使用div循环渲染，容易出现卡顿，因此推荐使用list组件代替div组件实现长列表布局，从而实现更加流畅的列表滚动体验。需要注意的是，list仅支持list-item作为子组件，具体的使用示例如下：
为避免示例代码过长，以上示例的list中只包含一个list-item，list-item中只有一个text组件。在实际应用中可以在list中加入多个list-item，同时list-item下可以包含多个其他子组件。
Tabs组件
当页面经常需要动态加载时，推荐使用tabs组件。tabs组件支持change事件，在页签切换后触发。tabs组件仅支持一个tab-bar和一个tab-content。具体的使用示例如下：
tab-content组件用来展示页签的内容区，高度默认充满tabs剩余空间。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-building-ui-interactions-V14
爬取时间: 2025-04-27 23:50:42
来源: Huawei Developer
添加交互可以通过在组件上关联事件实现。本节将介绍如何用div、text、image组件关联click事件，构建一个如下图所示的点赞按钮。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170332.57221777900574019483652017324405:50001231000000:2800:237671E45EE02334E2AF2866E54F322FC3DFF11FBFB47CB923F5E0B710050D47.gif)
点赞按钮通过一个div组件关联click事件实现。div组件包含一个image组件和一个text组件：
-  image组件用于显示未点赞和点赞的效果。click事件函数会交替更新点赞和未点赞图片的路径。
-  text组件用于显示点赞数，点赞数会在click事件的函数中同步更新。
click事件作为一个函数定义在js文件中，可以更改isPressed的状态，从而更新显示的image组件。如果isPressed为真，则点赞数加1。该函数在hml文件中对应的div组件上生效，点赞按钮各子组件的样式设置在css文件当中。具体的实现示例如下：
除此之外，还提供了很多表单组件，例如开关、标签、滑动选择器等，以便于开发者在页面布局时灵活使用和提高交互性。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-building-ui-animation-V14
爬取时间: 2025-04-27 23:50:57
来源: Huawei Developer
动画分为静态动画和连续动画。
静态动画
静态动画的核心是transform样式，主要可以实现以下三种变换类型，一次样式设置只能实现一种类型变换。
-  translate：沿水平或垂直方向将指定组件移动所需距离。
-  scale：横向或纵向将指定组件缩小或放大到所需比例。
-  rotate：将指定组件沿横轴或纵轴或中心点旋转指定的角度。
具体的使用示例如下，更多信息请参考组件方法。
图1静态动画效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170333.98047577296449076689541392996740:50001231000000:2800:3F569BF2DFF345193F203DA7085869B732A90FA713A415023B36D46584A0B03E.png)
连续动画
静态动画只有开始状态和结束状态，没有中间状态，如果需要设置中间的过渡状态和转换效果，需要使用连续动画实现。
连续动画的核心是animation样式，它定义了动画的开始状态、结束状态以及时间和速度的变化曲线。通过animation样式可以实现的效果有：
-  animation-name：设置动画执行后应用到组件上的背景颜色、透明度、宽高和变换类型。
-  animation-delay和animation-duration：分别设置动画执行后元素延迟和持续的时间。
-  animation-timing-function：描述动画执行的速度曲线，使动画更加平滑。
-  animation-iteration-count：定义动画播放的次数。
-  animation-fill-mode：指定动画执行结束后是否恢复初始状态。
animation样式需要在css文件中先定义keyframe，在keyframe中设置动画的过渡效果，并通过一个样式类型在hml文件中调用。animation-name的使用示例如下：
图2连续动画效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170333.10566358945909509129875163837042:50001231000000:2800:5C470DCD517EA7ED77999B2AC65CE50C4F50D2EA749FCB59F509BBA63BD876A5.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-building-ui-event-V14
爬取时间: 2025-04-27 23:51:11
来源: Huawei Developer
手势表示由单个或多个事件识别的语义动作（例如：触摸、点击和长按）。一个完整的手势也可能由多个事件组成，对应手势的生命周期。支持的事件有：
触摸
-  touchstart：手指触摸动作开始。
-  touchmove：手指触摸后移动。
-  touchcancel：手指触摸动作被打断，如来电提醒、弹窗。
-  touchend：手指触摸动作结束。
点击
click：用户快速轻敲屏幕。
长按
longpress：用户在相同位置长时间保持与屏幕接触。
具体的使用示例如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170333.79882176571233261615254516330125:50001231000000:2800:CFCF61E5B32A395575C9130774ECE7FCB744F20C9C5A35F987006F9E09A67372.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-building-ui-routes-V14
爬取时间: 2025-04-27 23:51:25
来源: Huawei Developer
很多应用由多个页面组成，比如用户可以从音乐列表页面点击歌曲，跳转到该歌曲的播放界面。开发者需要通过页面路由将这些页面串联起来，按需实现跳转。
页面路由router根据页面的uri找到目标页面，从而实现跳转。以最基础的两个页面之间的跳转为例，具体实现步骤如下：
1.  在“Project“窗口，打开src > main >js >MainAbility，右键点击pages文件夹，选择NewJS Page，创建一个详情页。
2.  调用router.push()路由到详情页。
3.  调用router.back()回到首页。
构建页面布局
index和detail这两个页面均包含一个text组件和button组件：text组件用来指明当前页面，button组件用来实现两个页面之间的相互跳转。hml文件代码示例如下：
构建页面样式
构建index和detail页面的页面样式，text组件和button组件居中显示，两个组件之间间距为50px。css代码如下（两个页面样式代码一致）：
实现跳转
为了使button组件的launch方法生效，需要在页面的js文件中实现跳转逻辑。调用router.push()接口将uri指定的页面添加到路由栈中，即跳转到uri指定的页面。在调用router方法之前，需要导入router模块。代码示例如下：
运行效果如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170333.74258402928586292549328493785936:50001231000000:2800:97C466381C2150C5E77BD741F5A4758A971CF63521E23D38D08674A907AF67AE.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-V14
爬取时间: 2025-04-27 23:51:38
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-container-components-V14
爬取时间: 2025-04-27 23:51:52
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-list-V14
爬取时间: 2025-04-27 23:52:06
来源: Huawei Developer
list是用来显示列表的组件，包含一系列相同宽度的列表项，适合连续、多行地呈现同类数据。具体用法请参考list API。
创建list组件
在pages/index目录下的hml文件中创建一个list组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170333.62432373260173743056891391227765:50001231000000:2800:E2379B72960713982D9E0A71B3B36C151EBD0C295E7CD6395B0756E08918A358.png)
-  <list-item-group>是<list>的子组件，实现列表分组功能，不能再嵌套<list>，可以嵌套<list-item>。
-  <list-item>是<list>的子组件，展示列表的具体项。
添加滚动条
设置scrollbar属性为on即可在屏幕右侧生成滚动条，实现长列表或者屏幕滚动等效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170333.10194367907977626636587867248340:50001231000000:2800:2C69B2AE193F5E1713C2CFBE29FFE76643CD544498860C53FBE8720CC3EABDB3.gif)
添加侧边索引栏
设置indexer属性为自定义索引时，索引栏会显示在列表右边界处，indexer属性设置为true，默认为字母索引表。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170333.70578766033474251113772401765456:50001231000000:2800:9DAAC7C1FD9FF9CF9994DC1F0CABE93FA52339B59E403D79CA93F95665BECF60.png)
-  indexer属性生效需要flex-direction属性配合设置为column，且columns属性设置为1。
-  indexer可以自定义索引表，自定义时"#"必须要存在。
实现列表折叠和展开
为list组件添加groupcollapse和groupexpand事件实现列表的折叠和展开。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170333.52524493601755704251437225261051:50001231000000:2800:38D2225084DF11E944ECFCA9ABE0B4A789C4BD2723F061CD80DE4D01094C73DE.gif)
场景示例
在本场景中，开发者可以根据字母索引表查找对应联系人。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170334.48232707028070374056305490775980:50001231000000:2800:079ABD21D705BDCAD9EFF766C01FD609B86C0821675E63A42A6AA1BE7E61EBB3.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-dialog-V14
爬取时间: 2025-04-27 23:52:19
来源: Huawei Developer
dialog组件用于创建自定义弹窗，通常用来展示用户当前需要或用户必须关注的信息或操作。具体用法请参考dialog API。
创建dialog组件
在pages/index目录下的hml文件中创建一个dialog组件，并添加Button组件来触发dialog。dialog组件仅支持width、height、margin、margin-[left|top|right|bottom]、margin-[start|end]样式。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170334.59205633096300414047609348669653:50001231000000:2800:CC3AB4B370293149C34F734194A7430C3785B84EEB57893B19CF755D4DD7F44E.gif)
设置弹窗响应
开发者点击页面上非dialog的区域时，将触发cancel事件而关闭弹窗。同时也可以通过对dialog添加show和close方法来显示和关闭弹窗。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170334.56187559083079478884770786246475:50001231000000:2800:956EE56507E7F59758E014F052ACC0638491DB53C3BB33C9CBE7DB5B6D7CBDBF.gif)
-  仅支持单个子组件。
-  dialog属性、样式均不支持动态更新。
-  dialog组件不支持focusable、click-effect属性。
场景示例
在本场景中，开发者可以通过dialog组件实现一个日程表。弹窗在打开状态下，利用Textarea组件输入当前日程，点击确认按钮后获取当前时间并保存输入文本。最后以列表形式将各日程进行展示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170334.48987507774084731997529953728497:50001231000000:2800:B336F898ECC92B33F54E17FD33B112347E054F7B862292CE44F3FA49348D88D1.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-form-V14
爬取时间: 2025-04-27 23:52:33
来源: Huawei Developer
form是一个表单容器，支持容器内Input组件内容的提交和重置。具体用法请参考form API。
创建form组件
在pages/index目录下的hml文件中创建一个form组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170334.09059262597486229465875844095271:50001231000000:2800:FA6808193358D54816FBE798B84EC6D597F63C1592CD8A66F554B9727107F2FA.png)
实现表单缩放
为form组件添加click-effect属性，实现点击表单后的缩放效果，click-effect枚举值请参考通用属性。
设置form样式
通过为form添加background-color和border属性，来设置表单的背景颜色和边框。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170334.08983098683800403125505173552090:50001231000000:2800:D198E026FE3A756939C8ACFF4DF9D64A8C464FB730C0958D92E4E61DA741E12D.gif)
添加响应事件
为form组件添加submit和reset事件，来提交表单内容或重置表单选项。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170334.50743282604045250388909970230491:50001231000000:2800:D360F07E3643CF4C460CAB4F5555B256E8161C3AB3AEDB15921AD6BAA1CFE53D.gif)
场景示例
在本场景中，开发者可以选择相应选项并提交或重置数据。
创建Input组件，分别设置type属性为checkbox（多选框）和radio（单选框），再使用form组件的onsubmit和onreset事件实现表单数据的提交与重置。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170334.67117464889048831706211780483556:50001231000000:2800:3BBFA14073CFB08BAD062156340DA3926F6F336F4C7F7821E6DFD1C4852BF5B7.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-stepper-V14
爬取时间: 2025-04-27 23:52:47
来源: Huawei Developer
当一个任务需要多个步骤时，可以使用stepper组件展示当前进展。具体用法请参考stepper API。
创建stepper组件
在pages/index目录下的hml文件中创建一个stepper组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170334.83086374661632361861350001710811:50001231000000:2800:230BABAEFD7ADEC19EACB86BC882130618E708ABCBCB3E0C4FB6280EDAE44C09.gif)
设置index属性
页面默认显示索引值为index的步骤。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170334.72454923065236397340025161938107:50001231000000:2800:736A587EDB2392354B3E36C80D06CEB72C0D3979789C12221292DAD0C7D18764.gif)
通过设置label属性，自定义stepper-item的提示按钮。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170334.28689253993296844261683309802957:50001231000000:2800:A4A66EDBC3D6480F1C0AF6CF67147A17DDB5B9DFB3E38266794BB4D2EC30D26D.gif)
设置样式
stepper组件默认填充父容器，通过border和background-color设置边框、背景色。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170335.05621245304159302178700624679836:50001231000000:2800:D0EAB9C163D499827B8E99ACD5A54590AD51E842098BF259A42D9D4C74FE26C6.png)
添加事件
stepper分别添加finish，change，next，back，skip事件。
-  当change与next或back同时存在时，会先执行next或back事件再去执行change事件。
-  重新设置index属性值时要先清除index的值再重新设置，否则检测不到值的改变。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170335.50718396016009045262029948988059:50001231000000:2800:589521AF5AF5488738F7B344D63DEC43032D19D8FDA0B6AE4C53345C86409A48.gif)
场景示例
在本场景中，开发者可以在界面上点击选择并实时显示选择结果，点击下一步按钮后可动态修改页面的字体颜色和字体大小。
用stepper组件实现分步，再创建Toggle组件实现选择显示功能，再使用Select组件实现改变选中值动态修改字体颜色或大小。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170335.91825367649259601404079836017845:50001231000000:2800:FF40EA5C2D50C31F5EEA97DB1C9B42A569ED0031104A1B9FB185A8BB4E597E76.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-component-tabs-V14
爬取时间: 2025-04-27 23:53:01
来源: Huawei Developer
tabs是一种常见的界面导航结构。通过页签容器，用户可以快捷地访问应用的不同模块。具体用法请参考tabs API。
创建tabs
在pages/index目录下的hml文件中创建一个tabs组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170335.67714860983961737076057777419811:50001231000000:2800:357954294C0B1770EB795021186E5A22DD6B5F09D61682E97AD40132694D1222.gif)
设置样式
设置tabs背景色及边框和tab-content布局。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170335.67342346468626841071235858858225:50001231000000:2800:BCAE6BEDAFFAE9078ADA0179191E8DBC09496158F7919211283C7D7D8A80DED8.gif)
显示页签索引
开发者可以为tabs添加change事件，实现页签切换后显示当前页签索引的功能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170335.25947253287661285159864755519023:50001231000000:2800:88129FB3262C9968699708D88E918FDDE1EE59BDD2089770F520B85582C592B3.gif)
tabs子组件仅支持一个<tab-bar>和一个<tab-content>。
场景示例
在本场景中，开发者可以点击标签切换内容，选中后标签文字颜色变红，并显示下划线。
用tabs、tab-bar和tab-content实现点击切换功能，再定义数组，设置属性。使用change事件改变数组内的属性值实现变色及下划线的显示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170335.85197823090009842966662159658796:50001231000000:2800:365E9700B5FB0F2887FBEEEBDDDE221EFB523C77CBE3D2CC2F8BEDDC5B19652C.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-swiper-V14
爬取时间: 2025-04-27 23:53:14
来源: Huawei Developer
swiper为滑动容器，提供切换显示子组件的能力。具体用法请参考swiper。
创建swiper组件
在pages/index目录下的hml文件中创建一个swiper组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170335.26845540537033776869910979024145:50001231000000:2800:8FCB950B687184025791D59BAE27D2995A66114C4CA91A293D289887DB965665.gif)
swiper组件支持除<list>之外的子组件。
添加属性
swiper组件当不开启循环播放（loop="false"）时添加自动播放属性（autoplay），设置自动播放时播放时间间隔（interval），页面会自动切换并停留在最后一个子组件页面。添加digital属性启用数字导航点，设置切换时为渐隐滑动效果（scrolleffect="fade"）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170336.07132457342525746386954335534610:50001231000000:2800:2707443E0EAC0A3F2DE250B67A3C1CBEE11B44267C1A5A6C82F95C176E8F68DE.gif)
-  设置indicator（是否启用导航点指示器）属性为true时digital（是否启用数字导航点）属性才会生效。
-  swiper子组件的个数大于等于2时设置的loop属性才会生效。
-  scrolleffect属性仅在loop属性值为false时生效。
设置样式
设置swiper组件的宽高，导航点指示器的直径大小（indicator-size）、颜色（indicator-color）、相对位置（indicator-top）及选中时的颜色（indicator-selected-color）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170336.63297416949518403892084040518207:50001231000000:2800:278E21BFDAD9C908804C8152A07BABCC4E725CC8A66ED623FE13A4278A903954.gif)
绑定事件
创建两个text组件添加点击事件，当点击后就调用showPrevious（显示上一个子组件）或showNext（显示下一个子组件）方法。添加select组件下拉选择时触发change事件后调用swipeTo方法跳转到指定轮播页面。swiper组件绑定change（当前显示的组件索引变化时触发）和finish（切换动画结束时触发）事件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170336.13685826069053141223209376243222:50001231000000:2800:28C13ECA2F36C7DD2808A836629A1B4AE8008956204D45AD45418B3BD0D36A8B.gif)
场景示例
本场景中使用swiper创建一个轮播图，在轮播图底部制作一个缩略图，点击缩略图后调用swipeTo方法切换到对应的轮播图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170336.98078147749144534026567354519161:50001231000000:2800:48FD0A414548059EAF4BA68E434DAD5D6E0A4A61FF2EF8145D56E825A9C3234F.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-basic-components-V14
爬取时间: 2025-04-27 23:53:28
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-text-V14
爬取时间: 2025-04-27 23:53:41
来源: Huawei Developer
text是文本组件，用于呈现一段文本信息。具体用法请参考text API。
创建text组件
在pages/index目录下的hml文件中创建一个text组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170336.33503493718693364667242549061605:50001231000000:2800:5AE13CD23B160C3DBF3AB585DCC66410C9CB2DF8D990C340992AB05BA739FE9C.png)
设置text组件样式和属性
-  添加文本样式 设置color、font-size、allow-scale、word-spacing、text-align属性分别为文本添加颜色、大小、缩放、文本之间的间距和文本在水平方向的对齐方式。
-  添加划线 设置text-decoration和text-decoration-color属性为文本添加划线和划线颜色，text-decoration枚举值请参考 text自有样式。
-  隐藏文本内容 当文本内容过多而显示不全时，添加text-overflow属性将隐藏内容以省略号的形式展现。 ​
-  设置文本断行 设置word-break属性对文本内容做断行处理，word-break枚举值请参考text自有样式。 ​
-  text组件支持Span子组件 当使用Span子组件组成文本段落时，如果Span属性样式异常（例如：font-weight设置为1000），将导致文本段落显示异常。 在使用Span子组件时，注意text组件内不能存在文本内容，如果存在文本内容也只会显示子组件Span里的内容。
-  当使用Span子组件组成文本段落时，如果Span属性样式异常（例如：font-weight设置为1000），将导致文本段落显示异常。
-  在使用Span子组件时，注意text组件内不能存在文本内容，如果存在文本内容也只会显示子组件Span里的内容。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170336.11405249164055584874250222813580:50001231000000:2800:6FACEE3E7BB167B7F3439E551FB1F5E26D9CE5E774605ADA4A831413685D0298.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170336.23756906059215526072239537039121:50001231000000:2800:51AAC53433E5C7B695008FA1B99134CCC68415D2D4312915CD39C1C3D4825997.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170336.43026496163212830007956465132483:50001231000000:2800:DFC1B9C568C02A696E74C1AC3DA349D2126BC45BA27ACFC5CE80028454014041.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170336.48784194112681666513158334896893:50001231000000:2800:BEE61656648FFDF6D638D1925CA07BA7C6B5CC09E4A4FBA2860B5A399B79912D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170336.58216640033830110321687316507668:50001231000000:2800:0FC8988DC8BAC6BC0F709E41CD1927CEB241DA2B01C84176AC382A2043FAD322.png)
-  当使用Span子组件组成文本段落时，如果Span属性样式异常（例如：font-weight设置为1000），将导致文本段落显示异常。
-  在使用Span子组件时，注意text组件内不能存在文本内容，如果存在文本内容也只会显示子组件Span里的内容。
场景示例
text组件通过数据绑定展示文本内容，Span组件通过设置show属性来实现文本内容的隐藏和显示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170337.03560405591059976730605839722357:50001231000000:2800:DAA1F4E1F76468ABF687EEBF5EC9650D88D1A1A6001CECBD674BCF95CA010AE7.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-input-V14
爬取时间: 2025-04-27 23:54:35
来源: Huawei Developer
input是交互式组件，用于接收用户数据。其类型可设置为日期、多选框和按钮等。具体用法请参考input API。
创建input组件
在pages/index目录下的hml文件中创建一个input组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170337.29025188395537514752169918842520:50001231000000:2800:D5F83B3AE9E5A27450539CBCB7EC00AC729CEB2BF7392D6712AE6F884D8B9DA4.png)
设置input类型
通过设置type属性来定义input类型，如将input设置为button、date等。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170337.66470133567571206333692532583677:50001231000000:2800:0E17BABAA930A8C4B2BBACB864A8428884BFEFE2C0F9FFA4EED7DFA15C272108.gif)
仅当input类型为checkbox和radio时，当前组件选中的属性是checked才生效，默认值为false。
事件绑定
向input组件添加search和translate事件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170337.30126640982111592913537086459059:50001231000000:2800:79AD1DF98FBF645331EE28808C3521179CACE5B9967F0A0EA9F196D62FBAED77.gif)
设置输入提示
通过对input组件添加showError方法来提示输入的错误原因。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170337.90993683442893247213153995030551:50001231000000:2800:BF858D3D8A0E63742CDAB4D9C43E57EDAE7E7F69A9B42D92E11BF1157EBD89F6.gif)
该方法在input类型为text、email、date、time、number和password时生效。
场景示例
根据场景选择不同类型的input输入框，完成信息录入。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170337.60731172261997338565344690393059:50001231000000:2800:DF4A9E5C033E0BBF4CCF8D0EDCD39B4521637307178BB1C5BFF634D946A5F826.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-button-V14
爬取时间: 2025-04-27 23:54:49
来源: Huawei Developer
button是按钮组件，其类型包括胶囊按钮、圆形按钮、文本按钮、弧形按钮、下载按钮。具体用法请参考button API。
创建button组件
在pages/index目录下的hml文件中创建一个button组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170337.49552734763623121710707802459689:50001231000000:2800:EFB7CF177A7581D734913E3343EB937F801256F056E8F6E01FA324EEFBFDB827.png)
设置button类型
通过设置button的type属性来选择按钮类型，如定义button为圆形按钮、文本按钮等。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170338.73488230602691172355610034521915:50001231000000:2800:71949957A216633CE0DC476CA0F56BEF7520A685768FAAFDFC99CAAEB280F275.png)
如果需要添加ohos.permission.INTERNET权限，则在resources文件夹下的config.json文件里进行权限配置。
显示下载进度
为button组件添加setProgress方法，来实时显示下载进度条的进度。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170338.73221956607276535482224589822795:50001231000000:2800:43D083ADBF05DF0EC548B161810F8D1F5E57721F5FD48C67F161D49ACAF84134.gif)
setProgress方法只支持button的类型为download。
场景示例
在本场景中，开发者可根据输入的文本内容进行button类型切换。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170338.56467349435682099242733474837391:50001231000000:2800:74BD8F7CF977EC790063FE4886747960A2FF1C09C1A4D54B04B4E70B928B8AEC.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-picker-V14
爬取时间: 2025-04-27 23:55:03
来源: Huawei Developer
picker是滑动选择器组件，类型支持普通选择器、日期选择器、时间选择器、时间日期选择器和多列文本选择器。具体用法请参考picker API。
创建picker组件
在pages/index目录下的hml文件中创建一个picker组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170338.28904930614255168979561064939393:50001231000000:2800:45A6888C15E6C750E7AE557774F25276FCB4F50F031917AE7C33F8798CF33094.gif)
设置picker类型
通过设置picker的type属性来选择滑动选择器类型，如定义picker为日期选择器。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170338.26114648300528186606619838596648:50001231000000:2800:76BBE1939AA33F98199DC5B941FFC46D5C5FB2648E800DA8245DE2676834E601.gif)
普通选择器设置取值范围时，需要使用数据绑定的方式。
设置时间展现格式
picker的hours属性定义时间的展现格式，可选类型有12小时制和24小时制。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170338.65163008348495938171513481474728:50001231000000:2800:E67653D29CE7CFA5764F62A7A5CE2BA2FADC32425192B228E1C73B641829EB8B.gif)
-  hours属性为12：按照12小时制显示，用上午和下午进行区分。
-  hours属性为24：按照24小时制显示。
添加响应事件
对picker添加change和cancel事件，来对选择的内容进行确定和取消。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170338.58015365514163024736106224306194:50001231000000:2800:4E17AA899AB91B29FAF85ECD4A3D325D01CC508A60C69C30386945D2F19A3941.gif)
场景示例
在本场景中，开发者可以自定义填写当前的健康情况来进行打卡。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170338.52748188361193321630071525495183:50001231000000:2800:2EB82AE1DB7DD27322DD5D7E68F76BB1A74454CED0EEBF68BD89D6449FEDEC69.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-images-V14
爬取时间: 2025-04-27 23:55:16
来源: Huawei Developer
image是图片组件，用来渲染展示图片。具体用法请参考image API。
创建image组件
在pages/index目录下的hml文件中创建一个image组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170339.25385727607255296040308946723455:50001231000000:2800:BE32B5E9A1C8DECF05260338DF9F7B34F7714F2229606FAFEF2BF0AE6EAFD03E.png)
设置image样式
通过设置width、height和object-fit属性定义图片的宽、高和缩放样式。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170339.35091285135761432553917875213602:50001231000000:2800:3998787937CB2250EA8108C90BBD66320AF34FF36612DB18AD521985B6B9C506.png)
加载图片
图片成功加载时触发complete事件，返回加载的图源尺寸。加载失败则触发error事件，打印图片加载失败。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170339.53437612894182802412521081272645:50001231000000:2800:6383F553DBF9F1E71D0790FA08930A64CBE6E04833318C4E9977744DE008D33A.gif)
场景示例
在本场景中，开发者长按图片后将慢慢隐藏图片，当完全隐藏后再重新显示原始图片。定时器setInterval每隔一段时间改变图片透明度,实现慢慢隐藏的效果，当透明度为0时清除定时器，设置透明度为1。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170339.81636703887886820718305935465524:50001231000000:2800:33FD7B5513E6D5246899837BB9A12CD429578C35A20727C46CF8A8B0B310E714.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-image-animator-V14
爬取时间: 2025-04-27 23:55:30
来源: Huawei Developer
image-animator组件为图片帧动画播放器。具体用法请参考image-animator。
创建image-animator组件
在pages/index目录下的hml文件中创建一个image-animator组件，css文件中编写组件样式，js文件中引用图片。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170339.23452809441318822569249798015220:50001231000000:2800:4D9690DB4855E8988E13AFB0AD4DAFE5C0997F721260D18C148F804E0B51FB51.gif)
设置image-animator组件属性
添加iteration（播放次数）、reverse（播放顺序）、fixedsize（图片大小是否固定为组件大小）、duration（播放时长）和fillmode（执行结束后的状态）属性，控制图片的播放效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170339.58695751539107144962275008416598:50001231000000:2800:68646D7F782BCB078FD1C16A16706E7F0A22F1303E1685F38092F6D4D65B1265.gif)
-  如果在images属性中设置了单独的duration属性，在image-animator组件中设置的duration属性无效。
-  如果fixedsize属性值设置为true，图片的width 、height 、top 和left属性无效。
-  如果reverse属性值设置为false，表示从第1张图片播放到最后1张图片。 如果reverse属性值设置为true，表示从最后1张图片播放到第1张图片。
绑定事件
向image-animator组件添加start、pause、stop和resume事件。当图片播放器开始播放时触发start事件，当图片播放器被点击时触发pause事件，长按图片播放器触发resume事件，图片播放器停止播放时触发stop事件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170339.25555542335553000185597049921682:50001231000000:2800:1D5F49F850CDD5DD33D8A0EFF524E11ED6DDE2C70DD4DE2DB0ACAE086F5BC528.gif)
场景示例
在本场景中，开发者可通过开始播放、停止播放等按钮切换图片的播放状态。
image-animator组件通过调用start、pause、stop和resume方法控制图片的开始、暂停、停止和重新播放，通过getState方法查询图片的播放状态。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170339.25008828544742879450195641125089:50001231000000:2800:E9AF5C3CE7B3302006BDF2BE1B3AE82DA5A5FA10B2BA6CC5B922BECBF930699E.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-rating-V14
爬取时间: 2025-04-27 23:55:44
来源: Huawei Developer
rating为评分条组件，表示用户使用感受的衡量标准条。具体用法请参考rating。
创建rating组件
在pages/index目录下的hml文件中创建一个rating组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170339.37606096906895407827773006930197:50001231000000:2800:1797595B357FA719D8763EAA33DB55DF0B78BD8580863046AB6CFC477CAAE87E.gif)
设置评分星级
rating组件通过设置numstars和rating属性设置评分条的星级总数和当前评星数。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170339.30667855503779850629662282618496:50001231000000:2800:5A3127739E014D78AE55A95D0140326FF9629E35B8D77A3BDE227E9B17CE9A8B.gif)
设置评分样式
rating组件通过star-background、star-foreground和star-secondary属性设置单个星级未选择、选中和选中的次级背景图片。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170339.19568798024876360938185847767310:50001231000000:2800:EB6E98291207BCCD3FDD8D1031C4DBE598B56E73556509B53841C0D1BC2DF69E.gif)
-  star-background、star-secondary、star-foreground属性的星级图源必须全部设置，否则默认的星级颜色为灰色，提示图源设置错误。
-  star-background、star-secondary、star-foreground属性只支持本地路径图片，图片格式为png和jpg。
绑定事件
向rating组件添加change事件，打印当前评分。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170339.59326401283981323487208630519595:50001231000000:2800:5C75C5D0E1A18EA43611263C4A8EE42525A904DCDB5E7DB26F31136E5EEA098D.gif)
场景示例
开发者可以通过改变开关状态切换星级背景图，通过改变滑动条的值调整星级总数。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170340.21823856691048709973284075388866:50001231000000:2800:EE09E1E60055527E844B75C91765DC4F8485AA87DDF7EADADBEE57EC0653A179.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-slider-V14
爬取时间: 2025-04-27 23:55:57
来源: Huawei Developer
slider为滑动条组件，用来快速调节音量、亮度等。具体用法请参考slider。
创建slider组件
在pages/index目录下的hml文件中创建一个slider组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170340.64919558526915617118224748161735:50001231000000:2800:C1F7AA624B60D608521798734F002D6A3BBBD2DFB3D1266AA1AF3A67A23C6716.gif)
设置样式和属性
slider组件通过color、selected-color、block-color样式分别为滑动条设置背景颜色、已选择颜色和滑块颜色。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170340.65428273889857343081215084490652:50001231000000:2800:E6E96E3FDCCA9F5B79D91C98345D7F27A3DE40D9E5689975052AFB08C2366481.gif)
通过添加mix、max、value、step、mode属性分别为滑动条设置最小值、最大值、初始值、滑动步长和滑动条样式。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170340.47286586850642290637933614011443:50001231000000:2800:FFA6B22DF51633F69271E5916E20703BE327C8948E12D6EA481AF5F9C4D950F8.gif)
mode属性为滑动条样式，可选值为：
-  outset：滑块在滑杆上。
-  inset：滑块在滑杆内。
绑定事件
向slider组件添加change事件，添加时需要传入ChangeEvent参数。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170340.19923796412066016087165898053568:50001231000000:2800:B5AD724738168740801AB4B01AE3D0C1CBEA3DABD61228FF5028E1BF91AA4CC3.gif)
场景示例
开发者可以通过调整滑动条的值来改变图片大小，并且动态打印当前图片的宽和高。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170340.01017196549780349829642619153577:50001231000000:2800:234D733FA8162F637F58D10F5AA7E5F1BAF0AAC887E0A974FF8FBCDAB6379B3C.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-chart-V14
爬取时间: 2025-04-27 23:56:11
来源: Huawei Developer
chart为图表组件，用于呈现线形图、柱状图和量规图界面。具体用法请参考chart。
创建chart组件
在pages/index目录下的hml文件中创建一个chart组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170340.47583954722263470469591853765404:50001231000000:2800:9243DE27A5B6D398E8C424852A03F7044B1184D3EAB347D62A3868BB52717DF2.png)
设置图表类型
chart组件通过设置type属性定义图表类型，如将图表设置为柱状图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170340.59453935000971388317288718478590:50001231000000:2800:4743BDDEF702AC384CC4856B4A835F16EDA119574707C5C9AF8130EF03C8A9EE.gif)
chart不支持显示每个点的值。
设置图表属性
chart组件在options属性中设置对x轴、y轴和数据序列参数的设置，在datasets属性里添加对线条颜色、填充颜色、填充渐变颜色和绘制点集的设置。
-  options只支持柱状图和线形图设置参数，量规图不生效。
-  datasets只支持柱状图和线形图设置数据集合，量规图不生效。
-  series只有线形图支持。
添加数据
通过chart组件的append方法，实现动态添加数据。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170340.12012726330628800832397284131735:50001231000000:2800:4A6C93A692C62D9DB5D223A1645D646B0DE36DF96E6EDDAC06338B1B7BD2A31A.gif)
场景示例
开发者可以根据开关Switch的状态来选择数据展示的状态，当Switch状态为true时，通过定时器来实现数据的动态展示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170340.02802664441719579613574861334135:50001231000000:2800:6D68FD915D3C9874AAA38825472D9D47AD3B2E35DAEBC5B6C92C774AB372C95E.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-switch-V14
爬取时间: 2025-04-27 23:56:25
来源: Huawei Developer
switch为开关选择器，切换开启或关闭状态。具体用法请参考switch。
创建switch组件
在pages/index目录下的hml文件中创建一个switch组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170341.16975268366980533493637689908277:50001231000000:2800:F643BDF89A2490EC743794728B7EBC76F581750530338DD57C09AE0D0F65D8E3.png)
添加属性和方法
switch组件通过textoff和showtext属性设置文本选中和未选中时的状态。设置checked属性值为true（组件为打开状态）。添加change事件，当组件状态改变时触发，触发后执行switchChange函数获取组件当前状态（关闭/打开）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170341.20481841993515827674748552245877:50001231000000:2800:90EAA3F813CE2B4EDE3865AD708F71382BFAFA3F27791B65DA6B80FBE3B629A0.gif)
当showtext属性值设置为true时，texton和textoff设置的文本才会生效。
场景示例
在下面示例中设置开关为打开状态（使用默认收货地址），关闭开关后页面显示选择地址按钮，点击按钮即可改变收货地址。
实现方法：创建switch开关，设置checked属性为true，通过数据绑定改变收货地址。设置display属性（默认为none），当关闭开关改变display属性值为flex后显示地址模块，点击按钮改变颜色。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170341.67341627945328688996217336876509:50001231000000:2800:539035015FE37D80665D53C82410D1A37E1F4AB1E1CBCA4FD119793C9C160EE0.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-toolbar-V14
爬取时间: 2025-04-27 23:56:39
来源: Huawei Developer
toolbar为页面工具栏组件，用于展示针对当前界面的操作选项，可作为页面的一级导航。具体用法请参考toolbar。
创建toolbar组件
在pages/index目录下的hml文件中创建一个toolbar组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170341.53193663816490840640903241439265:50001231000000:2800:2BE73F5AD516339AB3803B9EA5298E3E7E959D3D245382BD21AB239C9CBED954.gif)
添加子组件
toolbar组件仅支持toolbar-item为子组件，页面最多可以展示5个toolbar-item子组件，如果存在6个及以上toolbar-item，则保留前面4个，后续的将收纳到工具栏上的更多项中，通过点击更多项弹窗进行展示。并且更多项展示的组件样式采用系统默认样式，toolbar-item上设置的自定义样式不生效。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170341.36813052579557262870338439625068:50001231000000:2800:21D4F056EE2635CB9A67C6FEC154BFF79FFE21E8D3D738E777177371AFF6F89D.gif)
设置样式
设置position样式控制toolbar组件的位置，并设置子组件toolbar-item的字体颜色、大小及背景色。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170341.45630584576492091218953544096560:50001231000000:2800:8D92005053910E2E2AB05CC910B982C5A1703F2B2D7FC8A4AFE7C6127006E11E.png)
绑定事件
分别给toolbar-item绑定单击事件和长按事件，单击后文本变红，长按时文本变蓝。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170341.96994134104779777340132721681415:50001231000000:2800:8C3EFE52EDCAC92C2A48FFCFF6AC4E70F0067AA2C5DDA85BC4F4B820AF4C4A21.gif)
toolbar组件不支持添加事件和方法，但其子组件toolbar-item支持。
场景示例
本场景中开发者可点击toolbar-item组件，改变当前组件文本颜色并更换相对应的图片内容。
使用for循环创建toolbar-item组件并添加点击事件，点击后获得索引值进行存储。设置文本颜色时，判断当前索引值是否为储存的值，若相同则设置为红色，不同则使用默认颜色。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170341.72970425596158116281766417737809:50001231000000:2800:22C2BBB3D9A8D11DCC4FA6302A658D55B881D49A33DC615E11CA0057A894F762.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-menu-V14
爬取时间: 2025-04-27 23:56:53
来源: Huawei Developer
提供菜单组件，作为临时性弹出窗口，用于展示用户可执行的操作，具体用法请参考menu。
创建menu组件
在pages/index目录下的hml文件中创建一个menu组件，添加target、type、title属性。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170341.01549545495119896766191519944779:50001231000000:2800:0B0F36DED722A61D9F15D9ECA7CA7902E51D7E1AD3E6C6B5CDD6FD67FCC82FB1.gif)
-  menu仅支持option子组件。
-  menu组件不支持focusable、disabled属性。
设置样式
为menu组件设置样式，例如字体颜色、大小、字符间距等。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170342.02717285747953690001791755258025:50001231000000:2800:52E037A63F613D4CBFC58234C70A8E0A59E19739117CD39645F2BA5A5F675617.gif)
绑定事件
为menu组件绑定onselected事件（菜单中某个值被点击选中时触发）和oncancel事件（取消操作时触发），点击text组件调用show方法可设置menu组件的坐标。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170342.87201978864859364607472089619209:50001231000000:2800:A5CCD39BDC4C81B10D837689340D53CD2B25D1E18F98EF339871293283BF2D94.gif)
场景示例
本场景中开发者可点击toggle组件修改文字颜色，选择menu组件修改渐变色块大小。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170342.99750370498383964321594404074713:50001231000000:2800:00B159728C14208155C4CFE0636039D3908DC54C69289A65DD14549DF664DC96.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-marquee-V14
爬取时间: 2025-04-27 23:57:07
来源: Huawei Developer
marquee为跑马灯组件，用于展示一段单行滚动的文字。具体用法请参考marquee。
创建marquee组件
在pages/index目录下的hml文件中创建一个marquee组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170342.26121120379507767596191604810425:50001231000000:2800:1ABD32A42B0C14C9B8EC17DF78303FB4405DEBAE8D31C9281936B38D448F35CF.png)
设置属性和样式
marquee通过color和font-weight属性设置跑马灯中文本的颜色、字体粗细和边框样式。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170342.25007977265814798706075962610005:50001231000000:2800:DEBFFE23640FB416BDFDF3C6A6A3E2EAB1C7C54DA86E4A546028D87461A071E5.png)
通过scrollamount、loop和direction属性实现跑马灯滚动时移动的最大长度、滚动次数和文字滚动方向。
当loop的值小于等于零时，跑马灯marquee将连续滚动。如果loop未指定，则默认为-1。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170342.82750442941436821606973207179690:50001231000000:2800:8F40109AE5D7F953C367FE78CC9567B241076FDF1B0F0CEA92798C19DB67BDFD.gif)
场景示例
本场景可以控制跑马灯文字的滚动和暂停。
跑马灯的次数设置为1，在结束的时候触发finish事件使跑马灯的次数加1，字体颜色变为随机颜色，调用start方法使跑马灯再次开始滚动。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170342.46970962797924265548681520116071:50001231000000:2800:139B730AE9D0BCFC36C1B00BB5F8F533061EAA1408CA3FC8F917DCF2F7AA8EC5.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-qrcode-V14
爬取时间: 2025-04-27 23:57:20
来源: Huawei Developer
生成并显示二维码，具体用法请参考qrcode。
创建qrcode组件
在pages/index目录下的hml文件中创建一个qrcode组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170342.44308917216805865179026035733972:50001231000000:2800:D5FC01E9ED34C8FA2E5AD088D0B4C514ADF0A4C18687957D21ED80B1666DA6AE.png)
qrcode组件在创建的时候value的值为必填项。
设置组件类型
通过设置qrcode的type属性来选择按钮类型，如定义qrcode为矩形二维码、圆形二维码。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170342.49212937342578408816038321699561:50001231000000:2800:4569EBB926C7B9F1173092742262EA624EE33D533EA68831279142C27543C7B7.gif)
设置样式
通过color和background-color样式为二维码设置显示颜色和背景颜色。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170343.23563048807429227947383223703499:50001231000000:2800:B0F2B7B95F61C9496BD182CC3896DDDBF5349E0023DC86EB88A8023DC7D31623.png)
-  width和height不一致时，取二者较小值作为二维码的边长，且最终生成的二维码居中显示。
-  width和height只设置一个时，取设置的值作为二维码的边长。都不设置时，使用200px作为默认边长。
场景示例
在本场景中将二维码与输入框绑定，通过改变输入框的内容改变二维码。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170343.29902207569917116409371229917673:50001231000000:2800:C83E2662D58E039BE85A8A48804C817BFCB17A97E077644B86A2A4A486397B1E.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-search-V14
爬取时间: 2025-04-27 23:57:34
来源: Huawei Developer
提供搜索框组件，用于提供用户搜索内容的输入区域，具体用法请参考search。
创建search组件
在pages/index目录下的hml文件中创建一个search组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170343.22827301151134242673147300219105:50001231000000:2800:8F18B61926218A37C3FCD272A0DDB098E52DE7CC363D2FC538AC86FFFC668E76.png)
设置属性
通过设置hint、icon和searchbutton属性设置搜索框的提示文字、图标和末尾搜索按钮的内容。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170343.43368205759391224613925875292537:50001231000000:2800:84BDF06E047D9226F0F2C9431A89E4F7FBC9645CFE034B33212F9A863253766D.png)
添加样式
通过color、placeholder-color和caret-color样式来设置搜索框的文本颜色、提示文本颜色和光标颜色。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170344.39284642364286848799025174928138:50001231000000:2800:EF9718914A276E1052D022B7E8D139628DAA734E0A2E5235D0E3AEDD6F4804D9.gif)
绑定事件
向search组件添加change、search、submit、share和translate事件，对输入信息进行操作。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170344.40234725469287027043771613901813:50001231000000:2800:B75ADB517F1E82B5DF997D772890E391ACDA8CE02792E9FEEAEEB985A1CF064D.gif)
场景示例
在本场景中通过下拉菜单选择search、Textarea和Input组件来实现搜索和输入效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170344.05698771214303040192581656050438:50001231000000:2800:BB99E3201DF99C66A15691E452F9ABF4968FEB5CC0327AFECAC175D049114E92.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-canvas-V14
爬取时间: 2025-04-27 23:57:47
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-canvas-V14
爬取时间: 2025-04-27 23:58:00
来源: Huawei Developer
Canvas组件提供画布，用于自定义绘制图形。具体用法请参考CanvasRenderingContext2D对象。
创建Canvas组件
在pages/index目录下的hml文件中创建一个Canvas组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170344.22905423947810316825838843440427:50001231000000:2800:6FC118531FF6986CCDB76DA7EADA9F3C09414B73D26A8EAABCAEF9686599B949.png)
-  Canvas组件默认背景色与父组件的背景色一致。
-  Canvas默认宽高为width: 300px，height: 150px。
添加样式
Canvas组件设置宽（width）、高（height）、背景色（background-color）及边框样式（border）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170344.41567657136444703051690666275852:50001231000000:2800:7C68BE17CD07009756B9C7E73DFA62898BB2ECCC60382AE5239983E31ACD55BA.png)
添加事件
Canvas添加长按事件，长按后可获取Canvas组件的dataUrl值（toDataURL方法返回的图片信息），打印在下方文本区域内。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170344.10526637978440183387511205150689:50001231000000:2800:30609866B8C964C4E9B71C757AF1326CFB036615874590154393AF1B0695DC1A.gif)
画布不支持在onInit和onReady中进行创建。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-canvasrenderingcontext2d-V14
爬取时间: 2025-04-27 23:58:14
来源: Huawei Developer
使用CanvasRenderingContext2D在Canvas画布组件上进行绘制，绘制对象可以是图形、文本、线段、图片等。具体请参考CanvasRenderingContext2D对象。
画线段
使用moveTo和lineTo画出一条线段，当使用closePath方法时会结束当前路径形成一个封闭图形 。设置quadraticCurveTo（二次贝赛尔曲线）或bezierCurveTo（三次贝赛尔曲线）的值组成图形。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170344.30373019368090546982230689249753:50001231000000:2800:9321BAC8575FF215F07EF6D36D664F48C673C41D89B84E98CC1CD22063FC4F16.gif)
画边框
全局定义画布（el）及画笔（ctx），初始化创建一个边框宽度为5的长方形。对边框的宽度（lineWidth）、颜色（strokeStyle）、虚化程度（setLineDash）进行改变，选用select组件添加change事件，下拉选择时触发change事件后画出改变后的图形。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170344.21489470116196854126579189134422:50001231000000:2800:A97E2DC986F093C5250FE7259BA16C21CB9FADA2D893C29870876AD731506E9B.gif)
填充渐变色
添加createLinearGradient和createRadialGradient属性创建渐变容器，接着用addColorStop方法添加多个色块组成渐变色，再设置fillStyle为gradient将渐变色填充到矩形中，最后设置阴影的模糊级别（shadowBlur）、阴影颜色（shadowColor）及阴影偏移量（shadowOffset）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170344.79034971027896294779692030340542:50001231000000:2800:9393DD77EEFCF5D91D40EFF14419A2513ABF438DAC7C76C151FF15C18DE15993.gif)
填充文字
先创建文本，再用fillText方法把文字写在画布上。通过globalAlpha属性改变基线透明度，使基线不会挡住文字，再设置textAlign和textBaseline属性确定文字基于基线的位置。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170344.64880907368963021627445372237294:50001231000000:2800:56277C9BF59118B376A39742D546EC68B29F18488F2FE75882BEF776F66C2A76.gif)
ltr布局模式下start和left一致，rtl布局模式下start和right一致。
添加图片
创建图片对象后使用drawImage属性画出图片，给图片设置一些动画样式如scale（缩放）、translate（平移）或rotate（旋转）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170345.28960937915245529005745833811210:50001231000000:2800:088BD704D3EFF37F729E5A07F400D223D6F04283E71B5AFA7D152409B485DDEC.gif)
-  setTransform方法使用的参数和transform()方法相同，但setTransform()方法会重置现有的变换矩阵并创建新的变换矩阵。
-  变换后的坐标计算方式（x和y为变换前坐标，x'和y'为变换后坐标）： x' = scaleX * x + skewY * y + translateX y' = skewX * x + scaleY * y + translateY
添加方法
save方法可对画笔样式进行存储，restore可对存储的画笔进行恢复。如下面的示例，先设置画笔为红色，在保存画笔后对画布进行清除并改变画笔为蓝色，当我们直接使用画笔时会画出一个蓝色矩形，对存储的画笔进行恢复后就可画出红色矩形。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170345.90257442744349205083763712544358:50001231000000:2800:B034ABB33160E36FBB88BAE3A86FA84369CC681DFE8C0D9D5D3E2451994EE7C4.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-path2d-V14
爬取时间: 2025-04-27 23:58:29
来源: Huawei Developer
路径对象，支持通过对象的接口进行路径的描述，并通过Canvas的stroke接口进行绘制。具体请参考Path2D对象。
画线段
创建Path2D，使用多条线段组合图形。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170345.22106881434025191941342819462145:50001231000000:2800:BD4BE4187BECF9E40D1B407CD9BBDC8A7655A5A202A22D4BB2A3DEC33B6B34B0.png)
画图形
先使用createPath2D创建出路径对象，只对path1路径进行描边，所以画布上就只会出现path1的路径图形。点击text组件触发addPath方法会把path2路径对象当参数传入path1中，再对path1对象进行描边（stroke）操作后画布出现path1和path2两个图形。点击change文本改变setTransform属性值为setTransform(2, 0.1, 0.1, 2, 0,0)，图形变大并向左倾斜。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170345.51130196002070742436447253127820:50001231000000:2800:61CF236368E715CECFFE711C63091F15DB962D9CFFF544673C7A42C9C4573283.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-offscreencanvas-V14
爬取时间: 2025-04-27 23:58:42
来源: Huawei Developer
使用OffscreenCanvas在离屏Canvas画布组件上进行绘制，绘制对象可以是矩形、文本、图片等。 离屏，即GPU在当前缓冲区以外新开辟的一个缓冲区。 具体请参考OffscreenCanvasRenderingContext2D对象。
以下示例创建了一个OffscreenCanvas画布，再在画布上创建一个getContext2d对象，并设置filter属性改变图片样式。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170345.21635099284407881459860632654221:50001231000000:2800:220E49E50F054F450CD37B5DD514C1CA1B132560956420DA945EBE72F1F18123.gif)
判断位置
使用isPointInPath判断坐标点是否在路径的区域内，使用isPointInStroke判断坐标点是否在路径的边缘线上，并在页面上显示返回结果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170345.55831967522410745500392327696717:50001231000000:2800:A3664D31312C2060D5B894F71528A581A1769E0814DF96CC1C545F064A973D69.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-components-grid-V14
爬取时间: 2025-04-27 23:58:56
来源: Huawei Developer
栅格布局容器根节点，使用grid-row与grid-col进行栅格布局。具体请参考Grid-container。
创建grid-container组件
在pages/index目录下的hml文件中创建一个grid-container组件，并添加Grid-row子组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170345.01165744240179100136603389816327:50001231000000:2800:D17328DFD746344F73D7833254217778F886F7BD2FAD66CE9AC389F02B30D614.png)
grid-container仅支持grid-row为子组件。
调用方法
grid-container点击组件调用getColumns、getColumnWidth、getGutterWidth方法，返回栅格容器列数、column宽度及gutter宽度。长按调用getSizeType方法返回当前容器响应尺寸类型（xs|sm|md|lg）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170345.70638122448581941986995805296599:50001231000000:2800:B5354A937489D359B044FF11E9341C87CD0820CD66AACB2877FCC27782A0249E.gif)
添加grid-col
创建grid-container组件并添加grid-row，在grid-row组件内添加grid-col组件形成布局。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170345.76168373121510531468556775651534:50001231000000:2800:712B8803BD372F451D52B104EF60D4400E1F7A9357DE97440C9C1E278B2A5EAE.png)
grid-row仅支持grid-col为子组件，只能在grid-col组件中添加填充的内容。
场景示例
本场景中循环输出list中的内容，创建出网格布局。进行下拉操时触发refresh（刷新页面）方法，这时会向list数组中添加一条数据并设置setTimeout（延迟触发），达到刷新请求数据的效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170345.61041524529114535640086245732437:50001231000000:2800:E694263E1ADD408FB0C36CF3A42B583830B88E949592D8269DC9B0030DCD2157.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-svg-V14
爬取时间: 2025-04-27 23:59:10
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-animation-V14
爬取时间: 2025-04-27 23:59:23
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-animation-css-V14
爬取时间: 2025-04-27 23:59:36
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-animation-js-V14
爬取时间: 2025-04-27 23:59:50
来源: Huawei Developer

# 合并文件
合并时间: 2025-04-28 00:06:07

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-custom-components-V14
爬取时间: 2025-04-28 00:00:04
来源: Huawei Developer
使用兼容JS的类Web开发范式的方舟开发框架支持自定义组件，用户可根据业务需求将已有的组件进行扩展，增加自定义的私有属性和事件，封装成新的组件，方便在工程中多次调用，提高页面布局代码的可读性。具体的封装方法示例如下：
-  构建自定义组件
-  引入自定义组件
本示例中父组件通过添加自定义属性向子组件传递了名称为title的参数，子组件在props中接收。同时子组件也通过事件绑定向上传递了参数text，接收时通过e.detail获取。要绑定子组件事件，父组件事件命名必须遵循事件绑定规则，详见自定义组件的基本用法。自定义组件效果如下图所示：
图1自定义组件的效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170349.89324146987634044039569118029562:50001231000000:2800:688056A0E96FD7372D57EE9C8FEA50C45C3423071999EB7E2590DC380961AAE8.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ui-js-webgl-V14
爬取时间: 2025-04-28 00:00:20
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/webgl-2d-guidelines-V14
爬取时间: 2025-04-28 00:00:34
来源: Huawei Developer
场景介绍
WebGL的全称为Web Graphic Library（网页图形库），主要用于交互式渲染2D图形。目前HarmonyOS中使用的WebGL是基于OpenGL裁剪的OpenGL ES，可以在HTML5的Canvas元素对象中使用，无需使用插件，支持跨平台。WebGL程序是由JavaScript代码组成的，其中使用的API可以利用用户设备提供的GPU硬件完成图形渲染和加速。更多信息请参考WebGL™标准。
目前该功能仅支持使用兼容JS的类Web开发范式开发。
基本概念
着色器程序
将缓冲区中的数据推送到着色器中还需涉及“着色器程序”，一个负责关联着色器和缓冲区的JavaScript对象。一个WebGLProgram对象由两个编译过后的 WebGLShader组成，即顶点着色器和片元着色器（均由GLSL语言所写）。
着色器
着色器可以理解为运行在显卡中的指令和数据。在WebGL中，着色器是用OpenGL ES着色语言（GLSL）编写的。
完整的着色器包括顶点着色器和片元着色器。顶点着色器和片元着色器的交互则涉及到图片光栅化。
-  顶点着色器：最基本的任务是接收三维空间中点的坐标，将其处理为二维空间中的坐标并输出。
-  片元着色器：最基本的任务是对需要处理的屏幕上的每个像素输出一个颜色值。
图片光栅化
将顶点着色器输出的二维空间中的点坐标，转化为需要处理的像素并传递给片元着色器的过程。
帧缓冲对象
帧缓冲区对象为绘图缓冲区提供替代呈现目标。它们是颜色、字母、深度和模板缓冲区的集合，通常用于渲染图像。
纹理
纹理是一种图像，可以应用到3D模型的表面上。WebGL中的纹理有许多属性，包括宽度、高度、格式和类型。在使用纹理时，需要将其加载到WebGL中，并将其绑定到一个纹理单元上。
变量与接口说明
变量类型
| 类型 | 对应Web IDL类型 | 描述 |
| --- | --- | --- |
| GLenum | unsigned long | 用于枚举。 |
| GLboolean | boolean | 纹理true或者false。 |
| GLbitfield | unsigned long | 无符号整数，可以包含多个位标志。每个位标志都代表一个特定的选项。 |
| GLbyte | byte | 纹理八位（一个字节），2的补码表示的有符号整数。 |
| GLshort | short | 16位2的补码表示的有符号整数。 |
| GLint | long | 32位2的补码表示的有符号整数。 |
| GLsizei | long | 用来描述尺寸（例如：绘画缓冲drawing buffer 的宽和高）。 |
| GLintptr | long long | 用来表示指针的特殊类型，通常用于指定缓冲区对象的偏移量。 |
| GLsizeiptr | long long | 用来表示指针的特殊类型，通常用于指定缓冲区对象的大小。 |
| GLubyte | octet | 八位（一个字节）2的补码表示的无符号整数。 |
| GLushort | unsigned short | 16位2的补码表示的无符号整数。 |
| GLuint | unsigned short | 32位2的补码表示的有符号整数。 |
| GLfloat | unrestricted float | 32位的IEEE标准的浮点数。 |
| GLclampf | unrestricted float | 限值32位IEEE浮点数。 |
接口说明
| 接口名 | 描述 |
| --- | --- |
| canvas.getContext | 获取canvas对象上下文。 |
| webgl.createBuffer(): WebGLBuffer | null | 创建与初始化WebGL数据缓冲区。 |
| webgl.bindBuffer(target: GLenum, buffer: WebGLBuffer | null): void | 将WebGL数据缓冲区与目标进行绑定。 |
| webgl.bufferData(target: GLenum, srcData: ArrayBufferView, usage: GLenum, srcOffset: GLuint, length?: GLuint): void | 创建并初始化WebGL的数据存储区。 |
| webgl.getAttribLocation(program: WebGLProgram, name: string): GLint | 从给定WebGL着色程序中获取着色器中attribute变量的地址。 |
| webgl.vertexAttribPointer(index GLuint, size: GLint, type: GLenum, normalized: GLboolean, stride: GLsizei, offset: GLintptr): void | 将缓冲区对象分配给变量。 |
| webgl.enableVertexAttribArray(index: GLuint): void | 连接变量与分配给它的缓冲区对象。 |
| webgl.clearColor(red: GLclampf, green:GLclampf, blue: GLclampf, alpha: GLclampf): void | 清空<canvas>指定的颜色。 |
| webgl.clear(mask: GLbitfield): void | 清空<canvas>。 |
| webgl.drawArrays(mode: GLenum, first:;GLint, count: GLsizei): void | 执行数据绘制。 |
| webgl.flush(): void | 刷新数据至GPU，清空缓冲区。 |
| webgl.createProgram(): WebGLProgram | null | 创建着色器程序对象。 |
开发步骤
如下以实现一个彩色正方形为例，来演示使用WebGL绘制2D图形的过程。
1.  使用WebGL进行3D渲染前，首先需要一个Canvas元素。以下示例创建了一个Canvas元素并设置一个onclick事件处理程序来初始化WebGL上下文。
2.  设置WebGL的上下文。 JavaScript 代码中的 main() 函数将会在文档加载完成之后被调用。它的任务是设置WebGL上下文并开始渲染内容。 当获取到canvas之后，会调用getContext函数并向它传递 "webgl" 参数，来尝试获取WebGLRenderingContext。如果浏览器不支持WebGL， getContext将会返回null，如果WebGL上下文成功初始化，变量'gl'会用来引用该上下文。
3.  JavaScript 代码中的 main() 函数将会在文档加载完成之后被调用。它的任务是设置WebGL上下文并开始渲染内容。
4.  当获取到canvas之后，会调用getContext函数并向它传递 "webgl" 参数，来尝试获取WebGLRenderingContext。如果浏览器不支持WebGL， getContext将会返回null，如果WebGL上下文成功初始化，变量'gl'会用来引用该上下文。
5.  定义顶点着色器。 顶点着色器需要对顶点坐标进行必要的转换，在每个顶点基础上进行其他调整或计算，然后通过将其保存在由GLSL提供的特殊变量中来返回变换后的顶点。 在矩阵计算之前需要先引入gl-matrix开源工具库，可以从gl-matrix官网下载，也可以使用npm命令下载： npm install gl-matrix
6.  定义片段着色器。 片段着色器在顶点着色器处理完图形的顶点后，会被要绘制的每个图形的每个像素点调用一次。
7.  将着色器传递给WebGL。 定义顶点着色器与片段着色器之后，需要将它们传递给WebGL，并将其编译连接在一起。 如下代码通过调用 loadShader()，为着色器传递类型和来源。创建了两个着色器。然后创建一个附加着色器的程序，将它们连接在一起。如果编译或链接失败，代码将弹出alert。
8.  查找WebGL返回分配的输入位置。 在创建着色器程序之后，需要查找WebGL返回分配的输入位置。上述有一个属性和两个Uniform。 属性从缓冲区接收值。顶点着色器的每次迭代都从分配给该属性的缓冲区接收下一个值。 Uniform类似于JavaScript全局变量。它们在着色器的所有迭代中保持相同的值。由于属性的位置是特定于单个着色器程序的，因此将它们存储在一起以易于传递。
9.  在创建着色器程序之后，需要查找WebGL返回分配的输入位置。上述有一个属性和两个Uniform。
10.  属性从缓冲区接收值。顶点着色器的每次迭代都从分配给该属性的缓冲区接收下一个值。
11.  Uniform类似于JavaScript全局变量。它们在着色器的所有迭代中保持相同的值。由于属性的位置是特定于单个着色器程序的，因此将它们存储在一起以易于传递。
12.  创建缓冲器对象。 在画正方形前，需要创建一个缓冲器来存储它的顶点。 首先调用gl的成员函数createBuffer()得到缓冲对象并存储在顶点缓冲器。然后调用 bindBuffer() 函数绑定上下文。 创建一个Javascript数组去记录每一个正方体的每一个顶点。然后将其转化为WebGL浮点型类型的数组，并将其传到gl对象的bufferData()方法来建立对象的顶点。
13.  在画正方形前，需要创建一个缓冲器来存储它的顶点。
14.  首先调用gl的成员函数createBuffer()得到缓冲对象并存储在顶点缓冲器。然后调用 bindBuffer() 函数绑定上下文。
15.  创建一个Javascript数组去记录每一个正方体的每一个顶点。然后将其转化为WebGL浮点型类型的数组，并将其传到gl对象的bufferData()方法来建立对象的顶点。
16.  渲染场景。 用背景色擦除画布，然后建立摄像机透视矩阵。设置45度的视图角度，并且设置一个适合实际图像的宽高比。指定在摄像机距离0.1到100单位长度的范围内的物体可见。 加载特定位置，并把正方形放在距离摄像机6个单位的位置。然后，绑定正方形的顶点缓冲到上下文，并配置好，再通过调用drawArrays()方法来画出对象。
17.  用背景色擦除画布，然后建立摄像机透视矩阵。设置45度的视图角度，并且设置一个适合实际图像的宽高比。指定在摄像机距离0.1到100单位长度的范围内的物体可见。
18.  加载特定位置，并把正方形放在距离摄像机6个单位的位置。然后，绑定正方形的顶点缓冲到上下文，并配置好，再通过调用drawArrays()方法来画出对象。
-  JavaScript 代码中的 main() 函数将会在文档加载完成之后被调用。它的任务是设置WebGL上下文并开始渲染内容。
-  当获取到canvas之后，会调用getContext函数并向它传递 "webgl" 参数，来尝试获取WebGLRenderingContext。如果浏览器不支持WebGL， getContext将会返回null，如果WebGL上下文成功初始化，变量'gl'会用来引用该上下文。
-  在创建着色器程序之后，需要查找WebGL返回分配的输入位置。上述有一个属性和两个Uniform。
-  属性从缓冲区接收值。顶点着色器的每次迭代都从分配给该属性的缓冲区接收下一个值。
-  Uniform类似于JavaScript全局变量。它们在着色器的所有迭代中保持相同的值。由于属性的位置是特定于单个着色器程序的，因此将它们存储在一起以易于传递。
-  在画正方形前，需要创建一个缓冲器来存储它的顶点。
-  首先调用gl的成员函数createBuffer()得到缓冲对象并存储在顶点缓冲器。然后调用 bindBuffer() 函数绑定上下文。
-  创建一个Javascript数组去记录每一个正方体的每一个顶点。然后将其转化为WebGL浮点型类型的数组，并将其传到gl对象的bufferData()方法来建立对象的顶点。
-  用背景色擦除画布，然后建立摄像机透视矩阵。设置45度的视图角度，并且设置一个适合实际图像的宽高比。指定在摄像机距离0.1到100单位长度的范围内的物体可见。
-  加载特定位置，并把正方形放在距离摄像机6个单位的位置。然后，绑定正方形的顶点缓冲到上下文，并配置好，再通过调用drawArrays()方法来画出对象。
最终实现效果示意如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170349.13194756158596930255177005203936:50001231000000:2800:BF0F060EC4EAB1AE37A434221EA7754D5FDCDA903A7D93F50FC9EB92F75B10E4.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/window-manager-V14
爬取时间: 2025-04-28 00:00:48
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/window-overview-V14
爬取时间: 2025-04-28 00:01:02
来源: Huawei Developer
窗口模块的定义
窗口模块用于在同一块物理屏幕上，提供多个应用界面显示、交互的机制。
-  对应用开发者而言，窗口模块提供了界面显示和交互能力。
-  对终端用户而言，窗口模块提供了控制应用界面的方式。
-  对整个操作系统而言，窗口模块提供了不同应用界面的组织管理逻辑。
窗口模块的用途
在HarmonyOS中，窗口模块主要负责以下职责：
-  提供应用和系统界面的窗口对象。应用开发者通过窗口加载UI界面，实现界面显示功能。
-  组织不同窗口的显示关系，即维护不同窗口间的叠加层次和位置属性。应用和系统的窗口具有多种类型，不同类型的窗口具有不同的默认位置和叠加层次（Z轴高度）。同时，用户操作也可以在一定范围内对窗口的位置和叠加层次进行调整。
-  提供窗口装饰。窗口装饰指窗口标题栏和窗口边框。窗口标题栏通常包括窗口最大化、最小化及关闭按钮等界面元素，具有默认的点击行为，方便用户进行操作；窗口边框则方便用户对窗口进行拖拽缩放等行为。窗口装饰是系统的默认行为，开发者可选择启用/禁用，无需关注UI代码层面的实现。
-  提供窗口动效。在窗口显示、隐藏及窗口间切换时，窗口模块通常会添加动画效果，以使各个交互过程更加连贯流畅。在HarmonyOS中，应用窗口的动效为默认行为，不需要开发者进行设置或者修改。
-  指导输入事件分发。即根据当前窗口的状态或焦点，进行事件的分发。触摸和鼠标事件根据窗口的位置和尺寸进行分发，而键盘事件会被分发至焦点窗口。应用开发者可以通过窗口模块提供的接口设置窗口是否可以触摸和是否可以获焦。
基本概念
窗口类型
HarmonyOS的窗口模块将窗口界面分为系统窗口、应用窗口两种基本类型。
应用窗口模式
应用窗口模式指应用主窗口启动时的显示方式。HarmonyOS目前支持全屏、分屏、自由窗口三种应用窗口模式。这种对多种应用窗口模式的支持能力，也称为操作系统的“多窗口能力”。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170349.31470361992253011518480496019808:50001231000000:2800:724F366CD362E32488091EC63FFD59F71472E33F8773F9B9D37760A7FD494BCA.png)
实现原理
当前窗口的实现和开发与应用开发模型相关联，不同模型下的接口功能略有区别。当前应用开发模型分为FA模型和Stage模型。
两个模型的整体架构和设计思想，详见应用模型。
针对窗口开发，推荐使用Stage模型进行相关开发。
约束与限制
-  在FA模型下，不支持系统窗口的相关开发。
-  应用主窗口与子窗口存在大小限制，宽度范围：[320, 2560]，高度范围：[240, 2560]，单位为vp。
-  系统窗口存在大小限制，宽度范围：(0, 2560]，高度范围：(0, 2560]，单位为vp。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/application-window-stage-V14
爬取时间: 2025-04-28 00:01:16
来源: Huawei Developer
基本概念
-  窗口沉浸式能力：指对状态栏、导航栏等系统窗口进行控制，减少状态栏导航栏等系统界面的突兀感，从而使用户获得最佳体验的能力。 沉浸式能力只在应用主窗口作为全屏窗口时生效。通常情况下，应用子窗口（弹窗、悬浮窗口等辅助窗口）和处于自由窗口下的应用主窗口无法使用沉浸式能力。
-  悬浮窗：全局悬浮窗口是一种特殊的应用窗口，具备在应用主窗口和对应Ability退至后台后仍然可以在前台显示的能力。 悬浮窗口可以用于应用退至后台后，使用小窗继续播放视频，或者为特定的应用创建悬浮球等快速入口。应用在创建悬浮窗口前，需要申请对应的权限。
场景介绍
在Stage模型下，管理应用窗口的典型场景有：
-  设置应用主窗口属性及目标页面
-  设置应用子窗口属性及目标页面
-  体验窗口沉浸式能力
-  设置悬浮窗
-  监听窗口不可交互与可交互事件
以下分别介绍具体开发方式。
接口说明
上述场景涉及的常用接口如下表所示。更多API说明请参见API参考。
| 实例名 | 接口名 | 描述 |
| --- | --- | --- |
| WindowStage | getMainWindow(callback: AsyncCallback<Window>): void | 获取WindowStage实例下的主窗口。 此接口仅可在Stage模型下使用。 |
| WindowStage | loadContent(path: string, callback: AsyncCallback<void>): void | 为当前WindowStage的主窗口加载具体页面。 其中path为要加载到窗口中的页面内容的路径，该路径需添加到工程的main_pages.json文件中。 此接口仅可在Stage模型下使用。 |
| WindowStage | createSubWindow(name: string, callback: AsyncCallback<Window>): void | 创建子窗口。 此接口仅可在Stage模型下使用。 |
| WindowStage | on(type: 'windowStageEvent', callback: Callback<WindowStageEventType>): void | 开启WindowStage生命周期变化的监听。 此接口仅可在Stage模型下使用。 |
| window静态方法 | createWindow(config: Configuration, callback: AsyncCallback<Window>): void | 创建子窗口或者系统窗口。 -config：创建窗口时的参数。 |
| Window | setUIContent(path: string, callback: AsyncCallback<void>): void | 根据当前工程中某个页面的路径为窗口加载具体的页面内容。 其中path为要加载到窗口中的页面内容的路径，在Stage模型下该路径需添加到工程的main_pages.json文件中。 |
| Window | setWindowBrightness(brightness: number, callback: AsyncCallback<void>): void | 设置屏幕亮度值。 |
| Window | setWindowTouchable(isTouchable: boolean, callback: AsyncCallback<void>): void | 设置窗口是否为可触状态。 |
| Window | moveWindowTo(x: number, y: number, callback: AsyncCallback<void>): void | 移动当前窗口位置。 |
| Window | resize(width: number, height: number, callback: AsyncCallback<void>): void | 改变当前窗口大小。 |
| Window | setWindowLayoutFullScreen(isLayoutFullScreen: boolean): Promise<void> | 设置窗口布局是否为全屏布局。 |
| Window | setWindowSystemBarEnable(names: Array<'status'|'navigation'>): Promise<void> | 设置导航栏、状态栏是否显示。 |
| Window | setWindowSystemBarProperties(systemBarProperties: SystemBarProperties): Promise<void> | 设置窗口内导航栏、状态栏属性。 systemBarProperties：导航栏、状态栏的属性集合。 |
| Window | showWindow(callback: AsyncCallback<void>): void | 显示当前窗口。 |
| Window | on(type: 'touchOutside', callback: Callback<void>): void | 开启本窗口区域外的点击事件的监听。 |
| Window | destroyWindow(callback: AsyncCallback<void>): void | 销毁当前窗口。 |
获取WindowStage实例下的主窗口。
此接口仅可在Stage模型下使用。
为当前WindowStage的主窗口加载具体页面。
其中path为要加载到窗口中的页面内容的路径，该路径需添加到工程的main_pages.json文件中。
此接口仅可在Stage模型下使用。
创建子窗口。
此接口仅可在Stage模型下使用。
开启WindowStage生命周期变化的监听。
此接口仅可在Stage模型下使用。
创建子窗口或者系统窗口。
-config：创建窗口时的参数。
根据当前工程中某个页面的路径为窗口加载具体的页面内容。
其中path为要加载到窗口中的页面内容的路径，在Stage模型下该路径需添加到工程的main_pages.json文件中。
设置窗口内导航栏、状态栏属性。
systemBarProperties：导航栏、状态栏的属性集合。
设置应用主窗口
在Stage模型下，应用主窗口由UIAbility创建并维护生命周期。在UIAbility的onWindowStageCreate回调中，通过WindowStage获取应用主窗口，即可对其进行属性设置等操作。还可以在应用配置文件中设置应用主窗口的属性，如最大窗口宽度maxWindowWidth等，详见module.json5配置文件中的abilities标签。
开发步骤
1.  获取应用主窗口。 通过getMainWindow接口获取应用主窗口。
2.  设置主窗口属性。 可设置主窗口的背景色、亮度值、是否可触等多个属性，开发者可根据需要选择对应的接口。本示例以设置“是否可触”属性为例。
3.  为主窗口加载对应的目标页面。 通过loadContent接口加载主窗口的目标页面。
```typescript
import { UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
export default class EntryAbility extends UIAbility {
onWindowStageCreate(windowStage: window.WindowStage) {
// 1.获取应用主窗口。
let windowClass: window.Window | null = null;
windowStage.getMainWindow((err: BusinessError, data) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err));
return;
}
windowClass = data;
console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(data));
// 2.设置主窗口属性。以设置"是否可触"属性为例。
let isTouchable: boolean = true;
windowClass.setWindowTouchable(isTouchable, (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to set the window to be touchable. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in setting the window to be touchable.');
})
})
// 3.为主窗口加载对应的目标页面。
windowStage.loadContent("pages/page2", (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to load the content. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in loading the content.');
});
}
};
```
设置应用子窗口
开发者可以按需创建应用子窗口，如弹窗等，并对其进行属性设置等操作。
由于以下几种情况，移动设备场景下不推荐使用子窗口，优先推荐使用控件overlay能力实现。
开发步骤
1.  创建应用子窗口。 通过createSubWindow接口创建应用子窗口。
2.  设置子窗口属性。 子窗口创建成功后，可以改变其大小、位置等，还可以根据应用需要设置窗口背景色、亮度等属性。
3.  加载显示子窗口的具体内容。 通过setUIContent和showWindow接口加载显示子窗口的具体内容。
4.  销毁子窗口。 当不再需要某些子窗口时，可根据具体实现逻辑，使用destroyWindow接口销毁子窗口。
直接在onWindowStageCreate里面创建子窗口的整体示例代码如下：
```typescript
import { UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
let windowStage_: window.WindowStage | null = null;
let sub_windowClass: window.Window | null = null;
export default class EntryAbility extends UIAbility {
showSubWindow() {
// 1.创建应用子窗口。
if (windowStage_ == null) {
console.error('Failed to create the subwindow. Cause: windowStage_ is null');
}
else {
windowStage_.createSubWindow("mySubWindow", (err: BusinessError, data) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to create the subwindow. Cause: ' + JSON.stringify(err));
return;
}
sub_windowClass = data;
console.info('Succeeded in creating the subwindow. Data: ' + JSON.stringify(data));
// 2.子窗口创建成功后，设置子窗口的位置、大小及相关属性等。
sub_windowClass.moveWindowTo(300, 300, (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to move the window. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in moving the window.');
});
sub_windowClass.resize(500, 500, (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to change the window size. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in changing the window size.');
});
// 3.为子窗口加载对应的目标页面。
sub_windowClass.setUIContent("pages/page3", (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to load the content. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in loading the content.');
// 3.显示子窗口。
(sub_windowClass as window.Window).showWindow((err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
return;
}
console.info('Succeeded in showing the window.');
});
});
})
}
}
destroySubWindow() {
// 4.销毁子窗口。当不再需要子窗口时，可根据具体实现逻辑，使用destroy对其进行销毁。
(sub_windowClass as window.Window).destroyWindow((err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));
return;
}
console.info('Succeeded in destroying the window.');
});
}
onWindowStageCreate(windowStage: window.WindowStage) {
windowStage_ = windowStage;
// 开发者可以在适当的时机，如主窗口上按钮点击事件等，创建子窗口。并不一定需要在onWindowStageCreate调用，这里仅作展示
this.showSubWindow();
}
onWindowStageDestroy() {
// 开发者可以在适当的时机，如子窗口上点击关闭按钮等，销毁子窗口。并不一定需要在onWindowStageDestroy调用，这里仅作展示
this.destroySubWindow();
}
};
```
另外，也可以在某个page页面通过点击按钮创建子窗口，整体示例代码如下：
```typescript
// EntryAbility.ets
onWindowStageCreate(windowStage: window.WindowStage) {
windowStage.loadContent('pages/Index', (err) => {
if (err.code) {
console.error('Failed to load the content. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in loading the content.');
})
// 给Index页面传递windowStage
AppStorage.setOrCreate('windowStage', windowStage);
}
```
```typescript
// Index.ets
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
let windowStage_: window.WindowStage | undefined = undefined;
let sub_windowClass: window.Window | undefined = undefined;
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
private CreateSubWindow(){
// 获取windowStage
windowStage_ = AppStorage.get('windowStage');
// 1.创建应用子窗口。
if (windowStage_ == null) {
console.error('Failed to create the subwindow. Cause: windowStage_ is null');
}
else {
windowStage_.createSubWindow("mySubWindow", (err: BusinessError, data) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to create the subwindow. Cause: ' + JSON.stringify(err));
return;
}
sub_windowClass = data;
console.info('Succeeded in creating the subwindow. Data: ' + JSON.stringify(data));
// 2.子窗口创建成功后，设置子窗口的位置、大小及相关属性等。
sub_windowClass.moveWindowTo(300, 300, (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to move the window. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in moving the window.');
});
sub_windowClass.resize(500, 500, (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to change the window size. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in changing the window size.');
});
// 3.为子窗口加载对应的目标页面。
sub_windowClass.setUIContent("pages/subWindow", (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to load the content. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in loading the content.');
// 3.显示子窗口。
(sub_windowClass as window.Window).showWindow((err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
return;
}
console.info('Succeeded in showing the window.');
});
});
})
}
}
private destroySubWindow(){
// 4.销毁子窗口。当不再需要子窗口时，可根据具体实现逻辑，使用destroy对其进行销毁。
(sub_windowClass as window.Window).destroyWindow((err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));
return;
}
console.info('Succeeded in destroying the window.');
});
}
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Button(){
Text('CreateSubWindow')
.fontSize(24)
.fontWeight(FontWeight.Normal)
}.width(220).height(68)
.margin({left:10, top:60})
.onClick(() => {
this.CreateSubWindow()
})
Button(){
Text('destroySubWindow')
.fontSize(24)
.fontWeight(FontWeight.Normal)
}.width(220).height(68)
.margin({left:10, top:60})
.onClick(() => {
this.destroySubWindow()
})
}
.width('100%')
}
.height('100%')
}
}
```
```typescript
// subWindow.ets
@Entry
@Component
struct SubWindow {
@State message: string = 'Hello subWindow';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
.width('100%')
}
.height('100%')
}
}
```
体验窗口沉浸式能力
在看视频、玩游戏等场景下，用户往往希望隐藏状态栏、导航栏等不必要的系统窗口，从而获得更佳的沉浸式体验。此时可以借助窗口沉浸式能力（窗口沉浸式能力都是针对应用主窗口而言的），达到预期效果。从API version 10开始，沉浸式窗口默认配置为全屏大小并由组件模块控制布局，状态栏、导航栏背景颜色为透明，文字颜色为黑色；应用窗口调用setWindowLayoutFullScreen接口，设置为true表示由组件模块控制忽略状态栏、导航栏的沉浸式全屏布局，设置为false表示由组件模块控制避让状态栏、导航栏的非沉浸式全屏布局。
当前沉浸式界面开发仅支持window级别的配置，暂不支持Page级别的配置。若有Page级别切换的需要，可以在页面生命周期开始，例如onPageShow中设置沉浸模式，然后在页面退出，例如onPageHide中恢复默认设置来实现。
开发步骤
1.  获取应用主窗口。 通过getMainWindow接口获取应用主窗口。
2.  实现沉浸式效果。有以下两种方式： 方式一：应用主窗口为全屏窗口时，调用setWindowSystemBarEnable接口，设置导航栏、状态栏不显示，从而达到沉浸式效果。 方式二：调用setWindowLayoutFullScreen接口，设置应用主窗口为全屏布局；然后调用setWindowSystemBarProperties接口，设置导航栏、状态栏的透明度、背景/文字颜色以及高亮图标等属性，使之保持与主窗口显示协调一致，从而达到沉浸式效果。
3.  方式一：应用主窗口为全屏窗口时，调用setWindowSystemBarEnable接口，设置导航栏、状态栏不显示，从而达到沉浸式效果。
4.  方式二：调用setWindowLayoutFullScreen接口，设置应用主窗口为全屏布局；然后调用setWindowSystemBarProperties接口，设置导航栏、状态栏的透明度、背景/文字颜色以及高亮图标等属性，使之保持与主窗口显示协调一致，从而达到沉浸式效果。
5.  加载显示沉浸式窗口的具体内容。 通过loadContent接口加载沉浸式窗口的具体内容。
-  方式一：应用主窗口为全屏窗口时，调用setWindowSystemBarEnable接口，设置导航栏、状态栏不显示，从而达到沉浸式效果。
-  方式二：调用setWindowLayoutFullScreen接口，设置应用主窗口为全屏布局；然后调用setWindowSystemBarProperties接口，设置导航栏、状态栏的透明度、背景/文字颜色以及高亮图标等属性，使之保持与主窗口显示协调一致，从而达到沉浸式效果。
```typescript
import { UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
export default class EntryAbility extends UIAbility {
onWindowStageCreate(windowStage: window.WindowStage) {
// 1.获取应用主窗口。
let windowClass: window.Window | null = null;
windowStage.getMainWindow((err: BusinessError, data) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err));
return;
}
windowClass = data;
console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(data));
// 2.实现沉浸式效果。方式一：设置导航栏、状态栏不显示。
let names: Array<'status' | 'navigation'> = [];
windowClass.setWindowSystemBarEnable(names)
.then(() => {
console.info('Succeeded in setting the system bar to be visible.');
})
.catch((err: BusinessError) => {
console.error('Failed to set the system bar to be visible. Cause:' + JSON.stringify(err));
});
// 2.实现沉浸式效果。方式二：设置窗口为全屏布局，配合设置导航栏、状态栏的透明度、背景/文字颜色及高亮图标等属性，与主窗口显示保持协调一致。
let isLayoutFullScreen = true;
windowClass.setWindowLayoutFullScreen(isLayoutFullScreen)
.then(() => {
console.info('Succeeded in setting the window layout to full-screen mode.');
})
.catch((err: BusinessError) => {
console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));
});
let sysBarProps: window.SystemBarProperties = {
statusBarColor: '#ff00ff',
navigationBarColor: '#00ff00',
// 以下两个属性从API Version 8开始支持
statusBarContentColor: '#ffffff',
navigationBarContentColor: '#ffffff'
};
windowClass.setWindowSystemBarProperties(sysBarProps)
.then(() => {
console.info('Succeeded in setting the system bar properties.');
})
.catch((err: BusinessError) => {
console.error('Failed to set the system bar properties. Cause: ' + JSON.stringify(err));
});
})
// 3.为沉浸式窗口加载对应的目标页面。
windowStage.loadContent("pages/page2", (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to load the content. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in loading the content.');
});
}
};
```
设置悬浮窗（受限开放）
悬浮窗可以在已有的任务基础上，创建一个始终在前台显示的窗口。即使创建悬浮窗的任务退至后台，悬浮窗仍然可以在前台显示。通常悬浮窗位于所有应用窗口之上，开发者可以创建悬浮窗，并对悬浮窗进行属性设置等操作。
开发步骤
前提条件：创建WindowType.TYPE_FLOAT即悬浮窗类型的窗口，需要申请ohos.permission.SYSTEM_FLOAT_WINDOW权限，该权限为受控开放权限，仅符合指定场景的在2in1设备上的应用可申请该权限。申请方式请参考：申请使用受限权限。
在其他设备或场景下，请使用画中画功能，使用方式参考：画中画开发指导。
如果应用未在应用市场（AGC）申请相应的权限证书，却试图在配置文件中声明此类权限，将会导致应用安装失败。
1.  创建悬浮窗。 通过window.createWindow接口创建悬浮窗类型的窗口。
2.  对悬浮窗进行属性设置等操作。 悬浮窗窗口创建成功后，可以改变其大小、位置等，还可以根据应用需要设置悬浮窗背景色、亮度等属性。
3.  加载显示悬浮窗的具体内容。 通过setUIContent和showWindow接口加载显示悬浮窗的具体内容。
4.  销毁悬浮窗。 当不再需要悬浮窗时，可根据具体实现逻辑，使用destroyWindow接口销毁悬浮窗。
```typescript
import { UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
export default class EntryAbility extends UIAbility {
onWindowStageCreate(windowStage: window.WindowStage) {
// 1.创建悬浮窗。
let windowClass: window.Window | null = null;
let config: window.Configuration = {
name: "floatWindow", windowType: window.WindowType.TYPE_FLOAT, ctx: this.context
};
window.createWindow(config, (err: BusinessError, data) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to create the floatWindow. Cause: ' + JSON.stringify(err));
return;
}
console.info('Succeeded in creating the floatWindow. Data: ' + JSON.stringify(data));
windowClass = data;
// 2.悬浮窗窗口创建成功后，设置悬浮窗的位置、大小及相关属性等。
windowClass.moveWindowTo(300, 300, (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to move the window. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in moving the window.');
});
windowClass.resize(500, 500, (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to change the window size. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in changing the window size.');
});
// 3.为悬浮窗加载对应的目标页面。
windowClass.setUIContent("pages/page4", (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to load the content. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in loading the content.');
// 3.显示悬浮窗。
(windowClass as window.Window).showWindow((err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
return;
}
console.info('Succeeded in showing the window.');
});
});
// 4.销毁悬浮窗。当不再需要悬浮窗时，可根据具体实现逻辑，使用destroy对其进行销毁。
windowClass.destroyWindow((err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));
return;
}
console.info('Succeeded in destroying the window.');
});
});
}
};
```
监听窗口不可交互与可交互事件
应用在前台显示过程中可能会进入某些不可交互的场景，比较典型的是进入多任务界面。此时，对于一些应用可能需要选择暂停某个与用户正在交互的业务，如视频类应用暂停正在播放的视频或者相机暂停预览流等。而当该应用从多任务又切回前台时，又变成了可交互的状态，此时需要恢复被暂停中断的业务，如恢复视频播放或相机预览流等。
开发步骤
在创建WindowStage对象后可通过监听'windowStageEvent'事件类型，监听到窗口进入前台、后台、前台可交互、前台不可交互等事件，应用可根据这些上报的事件状态进行相应的业务处理。
```typescript
import { UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
export default class EntryAbility extends UIAbility {
onWindowStageCreate(windowStage: window.WindowStage) {
try {
windowStage.on('windowStageEvent', (data) => {
console.info('Succeeded in enabling the listener for window stage event changes. Data: ' +
JSON.stringify(data));
// 根据事件状态类型选择进行相应的处理
if (data == window.WindowStageEventType.SHOWN) {
console.info('current window stage event is SHOWN');
// 应用进入前台，默认为可交互状态
// ...
} else if (data == window.WindowStageEventType.HIDDEN) {
console.info('current window stage event is HIDDEN');
// 应用进入后台，默认为不可交互状态
// ...
} else if (data == window.WindowStageEventType.PAUSED) {
console.info('current window stage event is PAUSED');
// 前台应用进入多任务，转为不可交互状态
// ...
} else if (data == window.WindowStageEventType.RESUMED) {
console.info('current window stage event is RESUMED');
// 进入多任务后又继续返回前台时，恢复可交互状态
// ...
}
// ...
});
} catch (exception) {
console.error('Failed to enable the listener for window stage event changes. Cause:' +
JSON.stringify(exception));
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/application-window-fa-V14
爬取时间: 2025-04-28 00:01:29
来源: Huawei Developer
基本概念
窗口沉浸式能力：指对状态栏、导航栏等系统窗口进行控制，减少状态栏导航栏等系统界面的突兀感，从而使用户获得最佳体验的能力。
沉浸式能力只在应用主窗口作为全屏窗口时生效。通常情况下，应用子窗口（弹窗、悬浮窗口等辅助窗口）和处于自由窗口下的应用主窗口无法使用沉浸式能力。
当前沉浸式界面开发仅支持window级别的配置，暂不支持Page级别的配置。若有Page级别切换的需要，可以在页面生命周期开始，例如onPageShow中设置沉浸模式，然后在页面退出，例如onPageHide中恢复默认设置来实现。
场景介绍
在FA模型下，管理应用窗口的典型场景有：
-  设置应用子窗口属性及目标页面
-  体验窗口沉浸式能力
以下分别介绍具体开发方式。
接口说明
上述场景涉及的常用接口如下表所示。更多API说明请参见API参考。
| 实例名 | 接口名 | 描述 |
| --- | --- | --- |
| window静态方法 | createWindow(config: Configuration, callback: AsyncCallback<Window>): void | 创建子窗口。 -config：创建窗口时的参数。 |
| window静态方法 | findWindow(name: string): Window | 查找name所对应的窗口。 |
| Window | setUIContent(path: string, callback: AsyncCallback<void>): void | 根据当前工程中某个页面的路径为窗口加载具体的页面内容。 其中path为要加载到窗口中的页面内容的路径，在FA模型下该路径需添加到工程的config.json文件中。 |
| Window | moveWindowTo(x: number, y: number, callback: AsyncCallback<void>): void | 移动当前窗口。 |
| Window | setWindowBrightness(brightness: number, callback: AsyncCallback<void>): void | 设置屏幕亮度值。 |
| Window | resize(width: number, height: number, callback: AsyncCallback<void>): void | 改变当前窗口大小。 |
| Window | setWindowLayoutFullScreen(isLayoutFullScreen: boolean): Promise<void> | 设置窗口布局是否为全屏布局。 |
| Window | setWindowSystemBarEnable(names: Array<'status'|'navigation'>): Promise<void> | 设置导航栏、状态栏是否显示。 |
| Window | setWindowSystemBarProperties(systemBarProperties: SystemBarProperties): Promise<void> | 设置窗口内导航栏、状态栏属性。 systemBarProperties：导航栏、状态栏的属性集合。 |
| Window | showWindow(callback: AsyncCallback<void>): void | 显示当前窗口。 |
| Window | on(type: 'touchOutside', callback: Callback<void>): void | 开启本窗口区域外的点击事件的监听。 |
| Window | destroyWindow(callback: AsyncCallback<void>): void | 销毁当前窗口。 |
创建子窗口。
-config：创建窗口时的参数。
根据当前工程中某个页面的路径为窗口加载具体的页面内容。
其中path为要加载到窗口中的页面内容的路径，在FA模型下该路径需添加到工程的config.json文件中。
设置窗口内导航栏、状态栏属性。
systemBarProperties：导航栏、状态栏的属性集合。
设置应用子窗口
开发者可以按需创建应用子窗口，如弹窗等，并对其进行属性设置等操作。
由于以下几种情况，移动设备场景下不推荐使用子窗口，优先推荐使用控件overlay能力实现。
开发步骤
1.  创建/获取子窗口对象。
```typescript
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
let windowClass: window.Window | null = null;
// 方式一：创建子窗口。
let config: window.Configuration = { name: "subWindow", windowType: window.WindowType.TYPE_APP };
window.createWindow(config, (err: BusinessError, data) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to create the subWindow. Cause: ' + JSON.stringify(err));
return;
}
console.info('Succeeded in creating subWindow. Data: ' + JSON.stringify(data));
windowClass = data;
});
// 方式二：查找得到子窗口。
try {
windowClass = window.findWindow('subWindow');
} catch (exception) {
console.error('Failed to find the Window. Cause: ' + JSON.stringify(exception));
}
```
2.  设置子窗口属性。 子窗口创建成功后，可以改变其大小、位置等，还可以根据应用需要设置窗口背景色、亮度等属性。
```typescript
// 移动子窗口位置。
let windowClass: window.Window = window.findWindow("test");
windowClass.moveWindowTo(300, 300, (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to move the window. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in moving the window.');
});
// 改变子窗口大小。
windowClass.resize(500, 500, (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to change the window size. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in changing the window size.');
});
```
3.  加载显示子窗口的具体内容。 使用setUIContent和showWindow接口加载显示子窗口的具体内容。
```typescript
// 为子窗口加载对应的目标页面。
let windowClass: window.Window = window.findWindow("test");
windowClass.setUIContent("pages/page2", (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to load the content. Cause: ' + JSON.stringify(err));
return;
}
console.info('Succeeded in loading the content.');
// 显示子窗口。
windowClass.showWindow((err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
return;
}
console.info('Succeeded in showing the window.');
});
});
```
4.  销毁子窗口。 当不再需要某些子窗口时，可根据场景的具体实现逻辑，使用destroyWindow接口销毁子窗口。
```typescript
// 销毁子窗口。当不再需要某些子窗口时，可根据场景的具体实现逻辑，使用destroy接口销毁子窗口。
let windowClass: window.Window = window.findWindow("test");
windowClass.destroyWindow((err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to destroy the subwindow. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in destroying the subwindow.');
});
```
体验窗口沉浸式能力
在看视频、玩游戏等场景下，用户往往希望隐藏状态栏、导航栏等不必要的系统窗口，从而获得更佳的沉浸式体验。此时可以借助窗口沉浸式能力（窗口沉浸式能力都是针对应用主窗口而言的），达到预期效果。从API version 10开始，沉浸式窗口默认配置为全屏大小并由组件模块控制布局，状态栏、导航栏背景颜色为透明，文字颜色为黑色；应用窗口调用setWindowLayoutFullScreen接口，设置为true表示由组件模块控制忽略状态栏、导航栏的沉浸式全屏布局，设置为false表示由组件模块控制避让状态栏、导航栏的非沉浸式全屏布局。
开发步骤
1.  获取主窗口对象。 沉浸式能力需要在成功获取应用主窗口对象的前提下进行。 确保应用内最后显示的窗口为主窗口，然后再使用window.getLastWindow接口来获取得到主窗口。
```typescript
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
let mainWindowClass: window.Window | null = null;
// 获取主窗口。
class BaseContext {
stageMode: boolean = false;
}
let context: BaseContext = { stageMode: false };
window.getLastWindow(context, (err: BusinessError, data) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to get the subWindow. Cause: ' + JSON.stringify(err));
return;
}
console.info('Succeeded in getting subWindow. Data: ' + JSON.stringify(data));
mainWindowClass = data;
});
```
2.  实现沉浸式效果。有以下两种方式：
```typescript
// 实现沉浸式效果。方式一：设置导航栏、状态栏不显示。
let names: Array<'status' | 'navigation'> = [];
let mainWindowClass: window.Window = window.findWindow("test");
mainWindowClass.setWindowSystemBarEnable(names)
.then(() => {
console.info('Succeeded in setting the system bar to be visible.');
})
.catch((err: BusinessError) => {
console.error('Failed to set the system bar to be visible. Cause:' + JSON.stringify(err));
});
// 实现沉浸式效果。
// 方式二：设置窗口为全屏布局，配合设置状态栏、导航栏的透明度、背景/文字颜色及高亮图标等属性，与主窗口显示保持协调一致。
let isLayoutFullScreen: boolean = true;
mainWindowClass.setWindowLayoutFullScreen(isLayoutFullScreen)
.then(() => {
console.info('Succeeded in setting the window layout to full-screen mode.');
})
.catch((err: BusinessError) => {
console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));
});
let sysBarProps: window.SystemBarProperties = {
statusBarColor: '#ff00ff',
navigationBarColor: '#00ff00',
// 以下两个属性从API Version8开始支持。
statusBarContentColor: '#ffffff',
navigationBarContentColor: '#ffffff'
};
mainWindowClass.setWindowSystemBarProperties(sysBarProps)
.then(() => {
console.info('Succeeded in setting the system bar properties.');
})
.catch((err: BusinessError) => {
console.error('Failed to set the system bar properties. Cause: ' + JSON.stringify(err));
});
```
3.  加载显示沉浸式窗口的具体内容。 使用setUIContent和showWindow接口加载显示沉浸式窗口的具体内容。
```typescript
// 为沉浸式窗口加载对应的目标页面。
let mainWindowClass: window.Window = window.findWindow("test");
mainWindowClass.setUIContent("pages/page3", (err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to load the content. Cause: ' + JSON.stringify(err));
return;
}
console.info('Succeeded in loading the content.');
// 显示沉浸式窗口。
mainWindowClass.showWindow((err: BusinessError) => {
let errCode: number = err.code;
if (errCode) {
console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
return;
}
console.info('Succeeded in showing the window.');
});
});
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/native-window-event-filter-V14
爬取时间: 2025-04-28 00:01:43
来源: Huawei Developer
场景介绍
开发者可以NativeWindowEventFilter模块提供的能力去拦截按键事件，让按键事件不往应用内部组件分发。
接口说明
| 接口名 | 描述 |
| --- | --- |
| OH_NativeWindowManager_RegisterKeyEventFilter (int32_t windowId, OH_NativeWindowManager_KeyEventFilter keyEventFilter); | 为指定的窗口注册过滤回调函数keyEventFilter。 |
| OH_NativeWindowManager_UnregisterKeyEventFilter(int32_t windowId) | 取消指定窗口上的过滤回调函数。 |
开发步骤
在CMake脚本中链接动态库
添加头文件
接口使用说明
示例代码
以下示例代码中介绍了如何注册过滤函数和取消过滤函数，以过滤ESC退出按键和数字按键为例。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/window-pipwindow-V14
爬取时间: 2025-04-28 00:01:57
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/pipwindow-overview-V14
爬取时间: 2025-04-28 00:02:11
来源: Huawei Developer
场景介绍
应用在视频播放、视频会议、视频通话等场景下，可以使用画中画能力将视频内容以小窗（画中画）模式呈现。切换为小窗（画中画）模式后，用户可以进行其他界面操作，提升使用体验。
画中画的常见使用场景有以下几种：
系统提供以下两种画中画功能的开发方式：
约束与限制
接口说明
以下是画中画功能的常用接口，更多接口及使用参考@ohos.PiPWindow (画中画窗口)。
| 接口名  | 描述  |
| --- | --- |
| isPiPEnabled(): boolean  | 判断当前系统是否开启画中画功能。  |
| create(config: PiPConfiguration): Promise<PiPController>  | 创建画中画控制器。  |
| create(config: PiPConfiguration, contentNode: typeNode.XComponent): Promise<PiPController>  | 使用typeNode创建画中画控制器。  |
| startPiP(): Promise<void>  | 启动画中画。  |
| stopPiP(): Promise<void>  | 停止画中画。  |
| setAutoStartEnabled(enable: boolean): void  | 设置是否需要在返回桌面时自动启动画中画。  |
| updateContentSize(width: number, height: number): void  | 当媒体源切换时，向画中画控制器更新媒体源尺寸信息。  |
| on(type: 'stateChange', callback: (state: PiPState, reason: string) => void): void  | 开启画中画生命周期状态的监听。  |
| off(type: 'stateChange'): void  | 关闭画中画生命周期状态的监听。  |
| on(type: 'controlPanelActionEvent', callback: ControlPanelActionEventCallback): void  | 开启画中画控制面板控件动作事件的监听。推荐使用on('controlEvent')来开启画中画控制面板控件动作事件的监听。  |
| off(type: 'controlPanelActionEvent'): void  | 关闭画中画控制面板控件动作事件的监听。推荐使用off('controlEvent')来关闭画中画控制面板控件动作事件的监听。  |
| updatePiPControlStatus(controlType: PiPControlType, status: PiPControlStatus): void  | 更新画中画控制面板控件状态。  |
| setPiPControlEnabled(controlType: PiPControlType, enabled: boolean): void  | 设置控制面板控件使能状态。  |
| on(type: 'controlEvent', callback: CallBack<ControlEventParam>): void  | 开启画中画控制面板控件动作事件的监听。  |
| off(type: 'controlEvent', callback?: CallBack<ControlEventParam>): void  | 关闭画中画控制面板控件动作事件的监听。  |
接口名
描述
isPiPEnabled(): boolean
判断当前系统是否开启画中画功能。
create(config: PiPConfiguration): Promise<PiPController>
创建画中画控制器。
create(config: PiPConfiguration, contentNode: typeNode.XComponent): Promise<PiPController>
使用typeNode创建画中画控制器。
startPiP(): Promise<void>
启动画中画。
stopPiP(): Promise<void>
停止画中画。
setAutoStartEnabled(enable: boolean): void
设置是否需要在返回桌面时自动启动画中画。
updateContentSize(width: number, height: number): void
当媒体源切换时，向画中画控制器更新媒体源尺寸信息。
on(type: 'stateChange', callback: (state: PiPState, reason: string) => void): void
开启画中画生命周期状态的监听。
off(type: 'stateChange'): void
关闭画中画生命周期状态的监听。
on(type: 'controlPanelActionEvent', callback: ControlPanelActionEventCallback): void
开启画中画控制面板控件动作事件的监听。推荐使用on('controlEvent')来开启画中画控制面板控件动作事件的监听。
off(type: 'controlPanelActionEvent'): void
关闭画中画控制面板控件动作事件的监听。推荐使用off('controlEvent')来关闭画中画控制面板控件动作事件的监听。
updatePiPControlStatus(controlType: PiPControlType, status: PiPControlStatus): void
更新画中画控制面板控件状态。
setPiPControlEnabled(controlType: PiPControlType, enabled: boolean): void
设置控制面板控件使能状态。
on(type: 'controlEvent', callback: CallBack<ControlEventParam>): void
开启画中画控制面板控件动作事件的监听。
off(type: 'controlEvent', callback?: CallBack<ControlEventParam>): void
关闭画中画控制面板控件动作事件的监听。
交互方式
画中画窗口提供以下交互方式：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170350.74149765792471737437543560731712:50001231000000:2800:7355A61FF87452E615AD423C17970A90DCE2EFC9A6A92142670D243A6BDE3C9F.png)
配置画中画控制层可选控件
在使用create接口创建画中画时，可通过在PiPConfiguration中新增PiPControlGroup类型的数组配置当前画中画控制层控件。
-  若不配置，视频通话模版默认不存在任何按钮，点击画中画窗口即可启动还原（见下图左，未配置任何控件的操作示意图）。下图右为配置控件的操作示意图。
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170350.11410006106157963826925685595430:50001231000000:2800:73DBCA7BBA9067223E1D874F43C84A593BD0ABE79532CA08722D2627A88A8511.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170350.77603370770260293166173618695706:50001231000000:2800:AAAE079E58520881B1196DE9459455FB6AD96C0E39FBA6854CC7D9D48FCE7921.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170350.14111572304386971134338548495595:50001231000000:2800:8156FBE6F016F543D8232A2DA3FB7E71FF5C27B33B122BA3B3EFEC6D2D110112.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170350.83544029733193671064527958765008:50001231000000:2800:08A93175060C810B13212C69F760BED6F36930B3C06DEDA5D0FB146ED78CECDD.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170350.87125494390078634121761893346181:50001231000000:2800:96B7D95E2DEDA93E19AB9C4129EC7B3FCDB45E7335D27738CFCB78D79ADBC396.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170350.17390113313416918880236550329748:50001231000000:2800:66645E5AAEFD0F53CC1242D51F2625010F76A8053EF3DA4BBBBCDD57B10C706E.png)
在画中画内容上方展示自定义UI
在使用create接口创建画中画时，可通过在PiPConfiguration中传入customUIController来显示自定义UI。
自定义显示的UI无法响应交互事件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170351.51445871587459970132302228147805:50001231000000:2800:B1CB0F1B81035594CA3094AA6FEE8E072684570B474332FB131A512FE9F95D44.png)
更新画中画控制面板控件状态
应用可以使用updatePiPControlStatus接口更新控制面板控件的功能状态，如将视频播放模板下VIDEO_PLAY_PAUSE控件的播放状态更改为暂停状态，见下图。
应用也可以使用setPiPControlEnabled接口设置控制面板控件的使能状态，如将视频播放模板下VIDEO_PREVIOUS控件从可点击状态变为不可点击状态，见下图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170351.96290731922571444915342349507753:50001231000000:2800:E1A2B96D4E3E982A64ED5C044B22D6EA4053984D878F7A0E77849D66863C4FB6.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170351.85909231038795834817349854510448:50001231000000:2800:F02CCFBF3F5A1FAA57BA6B7C2341A17CEC7D026F750C225B6D445858B2E0662E.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/pipwindow-xcomponent-V14
爬取时间: 2025-04-28 00:02:25
来源: Huawei Developer
本文以视频播放为例，介绍通过XComponent实现画中画功能的基本开发步骤。
约束与限制
开发步骤
1.
2.  创建画中画控制器实例后，通过startPiP接口启动画中画。
3.  画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
4.  当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画。
以上示例代码对应的示意图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170351.64233538454236756546501679460005:50001231000000:2800:639D5E357D2D6A338BF2A6DE923FEF6AAFC1D1207AB106B05F717A80DDA92CB8.gif)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/pipwindow-typenode-V14
爬取时间: 2025-04-28 00:02:39
来源: Huawei Developer
该方式适用于任意场景下应用接入画中画功能，以下根据实际开发场景提供四个示例，分别介绍对应场景下画中画功能的实现步骤：
本文以视频播放为例，介绍通过typeNode实现画中画功能的基本开发步骤。
示例中的视频播放器简易实现参考：
```typescript
// model/AVPlayer.ets
// 简易播放器实现
import { BusinessError } from '@kit.BasicServicesKit';
import { common } from '@kit.AbilityKit';
import { media } from '@kit.MediaKit';
export class AVPlayer {
private avPlayer?: media.AVPlayer;
surfaceID: string = '';
setAVPlayerCallback() {
this.avPlayer?.on('seekDone', (seekDoneTime: number) => {
console.info(`AVPlayer seek succeeded, seek time is ${seekDoneTime}`);
})
this.avPlayer?.on('stateChange', async (state, reason) => {
if (!this.avPlayer) {
return;
}
switch (state) {
case 'idle':
this.avPlayer.release();
break;
case 'initialized':
this.avPlayer.surfaceId = this.surfaceID;
this.avPlayer.prepare().then(() => {
console.info('AVPlayer prepare succeeded.');
}, (err: BusinessError) => {
console.error(`Invoke prepare failed, code is ${err.code}, message is ${err.message}`);
});
break;
case 'prepared':
this.avPlayer.play();
break;
case 'stopped':
this.avPlayer.reset();
break;
default:
break;
}
})
}
async avPlayerFdSrc() {
this.avPlayer = await media.createAVPlayer();
this.setAVPlayerCallback();
let context = getContext(this) as common.UIAbilityContext;
let fileDescriptor = await context.resourceManager.getRawFd('xxx.mp4');
this.avPlayer.fdSrc = fileDescriptor;
}
}
```
约束与限制
应用使用typeNode自由节点（不添加到布局）实现画中画功能
1.
2.  创建画中画控制器实例后，通过startPiP接口启动画中画。
3.  画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
4.  当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画。
```typescript
// Index.ets
// 该页面用于展示应用布局文件，创建的typeNode节点不会添加到该布局中
import { PipManager } from '../model/PipManager';
const TAG = 'Index'
@Entry
@Component
struct Index {
build() {
Column() {
Text('This is MainPage')
.fontSize(30)
.fontWeight(FontWeight.Bold)
.margin({ bottom: 20 })
Text('This is not typeNode')
.size({ width: '100%', height: '800px' })
.fontSize(30)
.textAlign(TextAlign.Center)
.fontWeight(FontWeight.Bold)
.backgroundColor('#4d5b5858')
Row({ space: 20 }) {
Button('startPip') // 启动画中画
.onClick(() => {
PipManager.getInstance().startPip();
})
Button('stopPip') // 停止画中画
.onClick(() => {
PipManager.getInstance().stopPip();
})
Button('updateSize') // 更新视频尺寸
.onClick(() => {
PipManager.getInstance().updateContentSize(900, 1600);
})
}
.backgroundColor('#4da99797')
.size({ width: '100%', height: 60 })
.justifyContent(FlexAlign.SpaceAround)
}
.justifyContent(FlexAlign.Center)
.width('100%')
.height('100%')
}
aboutToDisappear(): void {
PipManager.getInstance().unregisterPipStateChangeListener(); // 解注册画中画生命周期及状态回调
}
onPageShow(): void {
console.info(TAG, 'onPageShow')
PipManager.getInstance().init(getContext(this)); // 创建画中画控制器
PipManager.getInstance().setAutoStart(true); // 设置应用退后台时自动启动画中画
}
onPageHide(): void {
console.info(TAG, 'onPageHide')
PipManager.getInstance().setAutoStart(false);
}
}
```
```typescript
// model/PipManager.ets
// 画中画控制器单例
import { PiPWindow, typeNode } from '@kit.ArkUI'; // 引入PiPWindow模块
import { BusinessError } from '@kit.BasicServicesKit';
import { AVPlayer} from '../model/AVPlayer'
// 自定义XComponentController
class CustomXComponentController extends XComponentController {
// 监听onSurfaceCreated，并将surfaceId设置给播放器
onSurfaceCreated(surfaceId: string): void {
console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
if (PipManager.getInstance().player.surfaceID === surfaceId) {
return;
}
PipManager.getInstance().player.surfaceID = surfaceId;
PipManager.getInstance().player.avPlayerFdSrc();
}
onSurfaceDestroyed(surfaceId: string): void {
console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
}
}
const TAG = 'PipManager';
export class PipManager {
player: AVPlayer;
private static instance: PipManager = new PipManager();
private pipController?: PiPWindow.PiPController = undefined;
private mXComponentController: XComponentController;
private xComponent: typeNode.XComponent| null = null; // typeNode节点
public static getInstance(): PipManager {
return PipManager.instance;
}
constructor() {
this.player = new AVPlayer();
this.mXComponentController = new CustomXComponentController();
}
onActionEvent(control: PiPWindow.ControlEventParam) {
switch (control.controlType) {
case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
//停止视频
} else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
//播放视频
}
break;
case PiPWindow.PiPControlType.VIDEO_NEXT:
// 切换到下一个视频
break;
case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
// 切换到上一个视频
break;
case PiPWindow.PiPControlType.FAST_FORWARD:
// 视频进度快进
break;
case PiPWindow.PiPControlType.FAST_BACKWARD:
// 视频进度后退
break;
default:
break;
}
console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
}
// 监听画中画生命周期
onStateChange(state: PiPWindow.PiPState, reason: string) {
let curState: string = '';
switch (state) {
case PiPWindow.PiPState.ABOUT_TO_START:
curState = "ABOUT_TO_START";
break;
case PiPWindow.PiPState.STARTED:
curState = "STARTED";
break;
case PiPWindow.PiPState.ABOUT_TO_STOP:
curState = "ABOUT_TO_STOP";
break;
case PiPWindow.PiPState.STOPPED:
curState = "STOPPED";
break;
case PiPWindow.PiPState.ABOUT_TO_RESTORE:
curState = "ABOUT_TO_RESTORE";
break;
case PiPWindow.PiPState.ERROR:
curState = "ERROR";
break;
default:
break;
}
console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
}
// 解注册监听
unregisterPipStateChangeListener() {
console.info(TAG, 'aboutToDisappear');
this.pipController?.off('stateChange');
this.pipController?.off('controlEvent');
}
getXComponentController(): CustomXComponentController {
return this.mXComponentController;
}
// 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
init(ctx: Context) {
if (this.pipController !== null && this.pipController != undefined) {
return;
}
console.info(TAG, 'onPageShow');
if (!PiPWindow.isPiPEnabled()) {
console.error(TAG, `picture in picture disabled for current OS`);
return;
}
let config: PiPWindow.PiPConfiguration = {
context: ctx,
componentController: this.getXComponentController(),
templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则将设置为16:9默认比例
contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则将设置为16:9默认比例
};
// 通过create接口创建画中画控制器实例
let promise: Promise<PiPWindow.PiPController> = PiPWindow.create(config, this.xComponent);
promise.then((controller: PiPWindow.PiPController) => {
this.pipController = controller;
// 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
this.pipController.setAutoStartEnabled(true);
// 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
this.onStateChange(state, reason);
});
// 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
this.onActionEvent(control);
});
}).catch((err: BusinessError) => {
console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
});
}
// 步骤2：创建画中画控制器实例后，通过startPiP接口启动画中画
startPip() {
this.pipController?.startPiP().then(() => {
console.info(TAG, `Succeeded in starting pip.`);
}).catch((err: BusinessError) => {
console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
});
}
// 步骤3：更新媒体源尺寸信息
updateContentSize(width: number, height: number) {
if (this.pipController) {
this.pipController.updateContentSize(width, height);
}
}
// 步骤4：关闭画中画
stopPip() {
if (this.pipController === null || this.pipController === undefined) {
return;
}
let promise: Promise<void> = this.pipController.stopPiP();
promise.then(() => {
console.info(TAG, `Succeeded in stopping pip.`);
}).catch((err: BusinessError) => {
console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
});
}
setAutoStart(autoStart: boolean): void {
this.pipController?.setAutoStartEnabled(autoStart);
}
// 创建typeNode节点
makeTypeNode(ctx: UIContext) {
if (this.xComponent === null || this.xComponent === undefined) {
// 创建typeNode
// let xc_options: XComponentOptions = {
//   type: XComponentType.TEXTURE, // 类型设置为TEXTURE
//   controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
// }
// this.xComponent = typeNode.createNode(ctx, "XComponent", xc_options);
// 创建XComponent类型的typeNode
this.xComponent = typeNode.createNode(ctx, "XComponent", {
type: XComponentType.SURFACE, // 类型设置为SURFACE
controller: PipManager.getInstance().getXComponentController(), // 设置XComponentController
});
}
}
}
```
以上示例代码对应的示意图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170351.17558317150634554509066182197147:50001231000000:2800:9E6C4C50EF41C8996E51C1C65375BB46E10C04FBECD3F73F907A5F69E36C4AF8.gif)
应用使用router导航时通过typeNode实现画中画功能
1.
2.  创建画中画控制器实例后，通过startPiP接口启动画中画，在画中画ABOUT_TO_START生命周期将typeNode节点从布局移除，并返回上级界面（可选）。如果启动画中画时返回了上级界面，需要在画中画ABOUT_TO_RESTORE（还原）时重新push原界面。
3.  画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
4.  当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画，在画中画ABOUT_TO_STOP生命周期将typeNode节点重新添加到布局中。
```typescript
// pages/Index.ets
import { PipManager } from '../model/PipManager';
import { PiPWindow, router, Router } from '@kit.ArkUI'; // 引入PiPWindow模块
const TAG = 'Index'
@Entry
@Component
struct Index {
private page1: string = 'pages/Page1';
private pageRouter: Router | null = null;
// 画中画生命周期事件监听，用于页面及节点操作
private callback: Function = (state: PiPWindow.PiPState) => {
console.info(TAG, `pipStateChange: state ${state}`);
if (state === PiPWindow.PiPState.ABOUT_TO_START) {
// 返回到上级页面（可选）
this.pageRouter?.back();
} else if (state === PiPWindow.PiPState.ABOUT_TO_STOP) {
// 重新将typeNode节点添加到布局中，例如还原场景
PipManager.getInstance().addNode();
} else if (state === PiPWindow.PiPState.ABOUT_TO_RESTORE) {
// 如果在ABOUT_TO_START时返回了上级界面，需要还原时push到原界面
this.jumpNext();
}
};
aboutToAppear(): void {
this.pageRouter = this.getUIContext().getRouter();
PipManager.getInstance().registerLifecycleCallback(this.callback);
}
aboutToDisappear(): void {
PipManager.getInstance().unregisterPipStateChangeListener();
PipManager.getInstance().unRegisterLifecycleCallback(this.callback);
}
jumpNext(): void {
let topPage = this.pageRouter?.getState();
if (topPage !== undefined && (this.page1.toString() === topPage.path + topPage.name)) {
console.info(TAG, `page1 aready at top`)
return;
}
this.pageRouter?.pushUrl({
url: this.page1 // 目标url
}, router.RouterMode.Standard, (err) => {
if (err) {
console.error(TAG, `Invoke pushUrl failed, code is ${err.code}: ${err.message}`);
return;
}
console.info(TAG, 'Invoke pushUrl succeeded.');
});
}
build() {
Row() {
Column() {
Text('Main Page')
.fontSize(50)
.fontWeight(FontWeight.Bold)
Button('Jump Next')
.onClick(() => {
this.jumpNext();
})
.margin({ top: 16, bottom: 16 })
}
.width('100%')
}
.height('100%')
}
}
```
```typescript
// pages/Page1.ets
import { PipManager } from '../model/PipManager';
const TAG = 'Page1';
@Component
export struct Page1 {
build() {
Column() {
Text('This is Page1')
.fontSize(30)
.fontWeight(FontWeight.Bold)
.margin({bottom: 20})
// 将typeNode添加到页面布局中
NodeContainer(PipManager.getInstance().getNodeController())
.size({ width: '100%', height: '800px' })
Row({ space: 20 }) {
Button('startPip')// 启动画中画
.onClick(() => {
PipManager.getInstance().startPip();
})
Button('stopPip')// 停止画中画
.onClick(() => {
PipManager.getInstance().stopPip();
})
Button('updateSize')// 更新视频尺寸
.onClick(() => {
// 此处设置的宽高应为媒体内容宽高，需要通过媒体相关接口或回调获取
// 例如使用AVPlayer播放视频时，可通过videoSizeChange回调获取媒体源更新后的尺寸
PipManager.getInstance().updateContentSize(900, 1600);
})
}
.backgroundColor('#4da99797')
.size({ width: '100%', height: 60 })
.justifyContent(FlexAlign.SpaceAround)
}
.justifyContent(FlexAlign.Center)
.width('100%')
.height('100%')
}
onPageShow(): void {
console.info(TAG, 'onPageShow')
PipManager.getInstance().initPipController(getContext(this));
PipManager.getInstance().setAutoStart(true);
}
onPageHide(): void {
console.info(TAG, 'onPageHide')
PipManager.getInstance().setAutoStart(false);
PipManager.getInstance().removeNode();
}
}
```
```typescript
// model/PipManager.ets
import { PiPWindow, typeNode } from '@kit.ArkUI'; // 引入PiPWindow模块
import { BusinessError } from '@kit.BasicServicesKit';
import { XCNodeController } from './XCNodeController';
import { AVPlayer } from './AVPlayer';
export class CustomXComponentController extends XComponentController {
onSurfaceCreated(surfaceId: string): void {
console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
if (PipManager.getInstance().player.surfaceID === surfaceId) {
return;
}
// 将surfaceId设置给媒体源
PipManager.getInstance().player.surfaceID = surfaceId;
PipManager.getInstance().player.avPlayerFdSrc();
}
onSurfaceDestroyed(surfaceId: string): void {
console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
}
}
const TAG = 'PipManager';
export class PipManager {
private static instance: PipManager = new PipManager();
private pipController?: PiPWindow.PiPController = undefined;
private xcNodeController: XCNodeController;
private mXComponentController: XComponentController;
private lifeCycleCallback: Set<Function> = new Set();
player: AVPlayer;
public static getInstance(): PipManager {
return PipManager.instance;
}
constructor() {
this.xcNodeController = new XCNodeController();
this.player = new AVPlayer();
this.mXComponentController = new CustomXComponentController();
}
public registerLifecycleCallback(callBack: Function) {
this.lifeCycleCallback.add(callBack);
}
public unRegisterLifecycleCallback(callBack: Function): void {
this.lifeCycleCallback.delete(callBack);
}
getNode(): typeNode.XComponent | null {
return this.xcNodeController.getNode();
}
onActionEvent(control: PiPWindow.ControlEventParam) {
switch (control.controlType) {
case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
//停止视频
} else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
//播放视频
}
break;
case PiPWindow.PiPControlType.VIDEO_NEXT:
// 切换到下一个视频
break;
case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
// 切换到上一个视频
break;
case PiPWindow.PiPControlType.FAST_FORWARD:
// 视频进度快进
break;
case PiPWindow.PiPControlType.FAST_BACKWARD:
// 视频进度后退
break;
default:
break;
}
console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
}
onStateChange(state: PiPWindow.PiPState, reason: string) {
let curState: string = '';
this.xcNodeController.setCanAddNode(
state === PiPWindow.PiPState.ABOUT_TO_STOP || state === PiPWindow.PiPState.STOPPED)
if (this.lifeCycleCallback !== null) {
this.lifeCycleCallback.forEach((fun) => {
fun(state)
});
}
switch (state) {
case PiPWindow.PiPState.ABOUT_TO_START:
curState = "ABOUT_TO_START";
// 将typeNode节点从布局移除
this.xcNodeController.removeNode();
break;
case PiPWindow.PiPState.STARTED:
curState = "STARTED";
break;
case PiPWindow.PiPState.ABOUT_TO_STOP:
curState = "ABOUT_TO_STOP";
break;
case PiPWindow.PiPState.STOPPED:
curState = "STOPPED";
break;
case PiPWindow.PiPState.ABOUT_TO_RESTORE:
curState = "ABOUT_TO_RESTORE";
break;
case PiPWindow.PiPState.ERROR:
curState = "ERROR";
break;
default:
break;
}
console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
}
unregisterPipStateChangeListener() {
console.info(`${TAG} aboutToDisappear`)
this.pipController?.off('stateChange');
this.pipController?.off('controlEvent');
}
getXComponentController(): CustomXComponentController {
return this.mXComponentController;
}
// 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
initPipController(ctx: Context) {
if (this.pipController !== null && this.pipController != undefined) {
return;
}
console.info(`${TAG} onPageShow`)
if (!PiPWindow.isPiPEnabled()) {
console.error(TAG, `picture in picture disabled for current OS`);
return;
}
let config: PiPWindow.PiPConfiguration = {
context: ctx,
componentController: this.getXComponentController(),
templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则创建画中画失败
contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则创建画中画失败
};
// 通过create接口创建画中画控制器实例
let promise: Promise<PiPWindow.PiPController> = PiPWindow.create(config, this.getNode());
promise.then((controller: PiPWindow.PiPController) => {
this.pipController = controller;
// 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
this.pipController.setAutoStartEnabled(true)
// 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
this.onStateChange(state, reason);
});
// 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
this.onActionEvent(control);
});
}).catch((err: BusinessError) => {
console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
});
}
// 步骤2：启动画中画
startPip() {
this.pipController?.startPiP().then(() => {
console.info(TAG, `Succeeded in starting pip.`);
}).catch((err: BusinessError) => {
console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
});
}
// 步骤3：更新媒体源尺寸信息
updateContentSize(width: number, height: number) {
if (this.pipController) {
this.pipController.updateContentSize(width, height);
}
}
// 步骤4：关闭画中画
stopPip() {
if (this.pipController) {
let promise: Promise<void> = this.pipController.stopPiP();
promise.then(() => {
console.info(TAG, `Succeeded in stopping pip.`);
}).catch((err: BusinessError) => {
console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
});
}
}
getNodeController(): XCNodeController {
console.info(TAG, `getNodeController.`);
return this.xcNodeController;
}
setAutoStart(autoStart: boolean): void {
this.pipController?.setAutoStartEnabled(autoStart);
}
removeNode(): void {
this.xcNodeController.removeNode();
}
addNode(): void {
this.xcNodeController.addNode();
}
}
```
以上示例代码对应的示意图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170351.56521415474833950133278453613879:50001231000000:2800:6A3F91824DF8A1B8F0C564D57046568D86D4A9CA324535AA2EBB742B255F24DC.gif)
应用使用Navigation导航时通过typeNode实现画中画功能
1.
2.  创建画中画控制器实例后，通过startPiP接口启动画中画，在画中画ABOUT_TO_START生命周期将typeNode节点从布局移除，并返回上级界面（可选）。如果启动画中画时返回了上级界面，需要在画中画ABOUT_TO_RESTORE（还原）时重新跳转到原界面。
3.  画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
4.  当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画，在画中画ABOUT_TO_STOP生命周期将typeNode节点重新添加到布局中。
```typescript
// pages/Index.ets
import { PipManager } from '../model/PipManager';
import { Page1 } from "../pages/Page1"
import { PiPWindow } from '@kit.ArkUI';
const TAG = 'Index1';
@Entry
@Component
struct Index {
@Provide('pageInfos') pageInfos: NavPathStack = new NavPathStack();
// 画中画生命周期事件监听，用于页面及节点操作
private callback: Function = (state: PiPWindow.PiPState) => {
console.info(TAG, `pipStateChange: state ${state}`);
if (state === PiPWindow.PiPState.ABOUT_TO_START) {
// 返回到上级页面（可选）
this.pageInfos.pop();
} else if (state === PiPWindow.PiPState.ABOUT_TO_STOP) {
// 重新将typeNode节点添加到布局中，例如还原场景
PipManager.getInstance().addNode();
} else if (state === PiPWindow.PiPState.ABOUT_TO_RESTORE) {
// 如果在ABOUT_TO_START时返回了上级界面，需要还原时push到原界面
this.jumpNext();
}
};
jumpNext() {
if (this.pageInfos.getAllPathName()[0] === 'Page1') {
console.log(TAG, 'Page1 already at top');
return;
}
this.pageInfos.pushPath({ name: 'Page1' });
}
aboutToAppear(): void {
PipManager.getInstance().registerLifecycleCallback(this.callback);
}
aboutToDisappear(): void {
PipManager.getInstance().unregisterPipStateChangeListener();
PipManager.getInstance().unRegisterLifecycleCallback(this.callback);
}
@Builder
PageMap(name: string) {
if (name === 'Page1') {
Page1();
}
}
build() {
Navigation(this.pageInfos) {
Column() {
Text("This is Main Page")
Column()
.height('200px')
Row({ space: 12 }) {
Button("Jump Page1")
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
this.jumpNext();
})
}
}
.height("100%")
.width("100%")
.justifyContent(FlexAlign.Center)
.backgroundColor("#DCDCDC")
}.title('MainTitle')
.navDestination(this.PageMap)
}
}
```
```typescript
// pages/Page1.ets
import { PipManager } from '../model/PipManager';
const TAG = 'Page1';
@Component
export struct Page1 {
build() {
NavDestination() {
Column() {
Text('This is Page1')
.fontSize(30)
.fontWeight(FontWeight.Bold)
.margin({bottom: 20})
// 将typeNode添加到页面布局中
NodeContainer(PipManager.getInstance().getNodeController())
.size({ width: '100%', height: '800px' })
Row({ space: 20 }) {
Button('startPip') // 启动画中画
.onClick(() => {
PipManager.getInstance().startPip();
})
Button('stopPip') // 停止画中画
.onClick(() => {
PipManager.getInstance().stopPip();
})
Button('updateSize') // 更新视频尺寸
.onClick(() => {
// 此处设置的宽高应为媒体内容宽高，需要通过媒体相关接口或回调获取
// 例如使用AVPlayer播放视频时，可通过videoSizeChange回调获取媒体源更新后的尺寸
PipManager.getInstance().updateContentSize(900, 1600);
})
}
.backgroundColor('#4da99797')
.size({ width: '100%', height: 60 })
.justifyContent(FlexAlign.SpaceAround)
}
.justifyContent(FlexAlign.Center)
.width('100%')
.height('100%')
}
.title('page1')
.onShown(()=>{
console.info(TAG, 'onShown')
PipManager.getInstance().init(getContext(this));
PipManager.getInstance().setAutoStart(true);
})
.onHidden(()=>{
console.info(TAG, 'onHidden')
PipManager.getInstance().setAutoStart(false);
PipManager.getInstance().removeNode();
})
}
}
```
```typescript
// model/PipManager.ets
import { PiPWindow, typeNode } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
import { XCNodeController } from './XCNodeController';
import { AVPlayer } from './AVPlayer'
export class CustomXComponentController extends XComponentController {
onSurfaceCreated(surfaceId: string): void {
console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
if (PipManager.getInstance().player.surfaceID === surfaceId) {
return;
}
// 将surfaceId设置给媒体源
PipManager.getInstance().player.surfaceID = surfaceId;
PipManager.getInstance().player.avPlayerFdSrc();
}
onSurfaceDestroyed(surfaceId: string): void {
console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
}
}
const TAG = 'PipManager';
export class PipManager {
private static instance: PipManager = new PipManager();
private pipController?: PiPWindow.PiPController = undefined;
private xcNodeController: XCNodeController;
private mXComponentController: XComponentController;
private lifeCycleCallback: Set<Function> = new Set();
player: AVPlayer;
public static getInstance(): PipManager {
return PipManager.instance;
}
constructor() {
this.xcNodeController = new XCNodeController();
this.player = new AVPlayer();
this.mXComponentController = new CustomXComponentController();
}
public registerLifecycleCallback(callBack: Function) {
this.lifeCycleCallback.add(callBack);
}
public unRegisterLifecycleCallback(callBack: Function): void {
this.lifeCycleCallback.delete(callBack);
}
getNode(): typeNode.XComponent | null {
return this.xcNodeController.getNode();
}
onActionEvent(control: PiPWindow.ControlEventParam) {
switch (control.controlType) {
case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
//停止视频
} else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
//播放视频
}
break;
case PiPWindow.PiPControlType.VIDEO_NEXT:
// 切换到下一个视频
break;
case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
// 切换到上一个视频
break;
case PiPWindow.PiPControlType.FAST_FORWARD:
// 视频进度快进
break;
case PiPWindow.PiPControlType.FAST_BACKWARD:
// 视频进度后退
break;
default:
break;
}
console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
}
onStateChange(state: PiPWindow.PiPState, reason: string) {
let curState: string = '';
this.xcNodeController.setCanAddNode(
state === PiPWindow.PiPState.ABOUT_TO_STOP || state === PiPWindow.PiPState.STOPPED)
if (this.lifeCycleCallback !== null) {
this.lifeCycleCallback.forEach((fun) => {
fun(state);
});
}
switch (state) {
case PiPWindow.PiPState.ABOUT_TO_START:
curState = "ABOUT_TO_START";
// 将typeNode节点从布局移除
this.xcNodeController.removeNode();
break;
case PiPWindow.PiPState.STARTED:
curState = "STARTED";
break;
case PiPWindow.PiPState.ABOUT_TO_STOP:
curState = "ABOUT_TO_STOP";
break;
case PiPWindow.PiPState.STOPPED:
curState = "STOPPED";
break;
case PiPWindow.PiPState.ABOUT_TO_RESTORE:
curState = "ABOUT_TO_RESTORE";
break;
case PiPWindow.PiPState.ERROR:
curState = "ERROR";
break;
default:
break;
}
console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
}
unregisterPipStateChangeListener() {
console.info(`${TAG} aboutToDisappear`);
this.pipController?.off('stateChange');
this.pipController?.off('controlEvent');
}
getXComponentController(): CustomXComponentController {
return this.mXComponentController;
}
// 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
init(ctx: Context) {
if (this.pipController !== null && this.pipController != undefined) {
return;
}
console.info(`${TAG} onPageShow`)
if (!PiPWindow.isPiPEnabled()) {
console.error(TAG, `picture in picture disabled for current OS`);
return;
}
let config: PiPWindow.PiPConfiguration = {
context: ctx,
componentController: this.getXComponentController(),
templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则创建画中画失败
contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则创建画中画失败
};
// 通过create接口创建画中画控制器实例
let promise: Promise<PiPWindow.PiPController> = PiPWindow.create(config, this.xcNodeController.getNode());
promise.then((controller: PiPWindow.PiPController) => {
this.pipController = controller;
// 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
this.pipController?.setAutoStartEnabled(true);
// 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
this.onStateChange(state, reason);
});
// 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
this.onActionEvent(control);
});
}).catch((err: BusinessError) => {
console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
});
}
// 步骤2：启动画中画
startPip() {
this.pipController?.startPiP().then(() => {
console.info(TAG, `Succeeded in starting pip.`);
}).catch((err: BusinessError) => {
console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
});
}
// 步骤3：更新媒体源尺寸信息
updateContentSize(width: number, height: number) {
if (this.pipController) {
this.pipController.updateContentSize(width, height);
}
}
// 步骤4：关闭画中画
stopPip() {
if (this.pipController === null || this.pipController === undefined) {
return;
}
let promise: Promise<void> = this.pipController.stopPiP();
promise.then(() => {
console.info(TAG, `Succeeded in stopping pip.`);
}).catch((err: BusinessError) => {
console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
});
}
getNodeController(): XCNodeController {
console.info(TAG, `getNodeController.`);
return this.xcNodeController;
}
setAutoStart(autoStart: boolean): void {
this.pipController?.setAutoStartEnabled(autoStart);
}
removeNode() {
this.xcNodeController.removeNode();
}
addNode(): void {
this.xcNodeController.addNode();
}
}
```
以上示例代码对应的示意图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170351.87336650273396848497027087131131:50001231000000:2800:F932A25672CCE6348D121E911BC344455C9993F5D63AB5F90454864517AE28F8.gif)
应用使用单界面Ability时通过typeNode实现画中画功能
1.
2.  创建画中画控制器实例后，通过startPiP接口启动画中画，在画中画ABOUT_TO_START生命周期将typeNode节点从布局移除。
3.  画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。
4.  当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画，在画中画ABOUT_TO_STOP生命周期将typeNode节点重新添加到布局中。
```typescript
// pages/Index.ets
import { PipManager } from '../model/PipManager';
import { PiPWindow } from '@kit.ArkUI'; // 引入PiPWindow模块
const TAG = 'Index'
@Entry
@Component
struct Index {
private callback: Function = (state: PiPWindow.PiPState) => {
if (state === PiPWindow.PiPState.ABOUT_TO_STOP) {
// 画中画关闭或还原时触发ABOUT_TO_STOP生命周期，此时需要重新添加节点
PipManager.getInstance().addNode();
}
};
build() {
Column() {
Text('This is MainPage')
.fontSize(30)
.fontWeight(FontWeight.Bold)
.margin({ bottom: 20 })
// 将typeNode添加到页面布局中
NodeContainer(PipManager.getInstance().getNodeController())
.size({ width: '100%', height: '800px' })
Row({ space: 20 }) {
Button('startPip') // 启动画中画
.onClick(() => {
PipManager.getInstance().startPip();
})
Button('stopPip') // 停止画中画
.onClick(() => {
PipManager.getInstance().stopPip();
})
Button('updateSize') // 更新视频尺寸
.onClick(() => {
// 此处设置的宽高应为媒体内容宽高，需要通过媒体相关接口或回调获取
// 例如使用AVPlayer播放视频时，可通过videoSizeChange回调获取媒体源更新后的尺寸
PipManager.getInstance().updateContentSize(900, 1600);
})
}
.backgroundColor('#4da99797')
.size({ width: '100%', height: 60 })
.justifyContent(FlexAlign.SpaceAround)
}
.justifyContent(FlexAlign.Center)
.width('100%')
.height('100%')
}
aboutToAppear(): void {
PipManager.getInstance().registerLifecycleCallback(this.callback);
}
aboutToDisappear(): void {
PipManager.getInstance().unregisterPipStateChangeListener();
PipManager.getInstance().unRegisterLifecycleCallback(this.callback);
}
onPageShow(): void {
console.info(TAG, 'onPageShow')
PipManager.getInstance().init(getContext(this));
PipManager.getInstance().setAutoStart(true);
}
onPageHide(): void {
console.info(TAG, 'onPageHide')
PipManager.getInstance().setAutoStart(false);
}
}
```
```typescript
// model/PipManager.ets
import { PiPWindow, typeNode } from '@kit.ArkUI'; // 引入PiPWindow模块
import { BusinessError } from '@kit.BasicServicesKit';
import { XCNodeController } from './XCNodeController';
import { AVPlayer} from '../model/AVPlayer'
// 自定义XComponentController
export class CustomXComponentController extends XComponentController {
onSurfaceCreated(surfaceId: string): void {
console.log(TAG, `onSurfaceCreated surfaceId: ${surfaceId}`);
if (PipManager.getInstance().player.surfaceID === surfaceId) {
return;
}
PipManager.getInstance().player.surfaceID = surfaceId;
PipManager.getInstance().player.avPlayerFdSrc();
}
onSurfaceDestroyed(surfaceId: string): void {
console.log(TAG, `onSurfaceDestroyed surfaceId: ${surfaceId}`);
}
}
const TAG = 'PipManager';
export class PipManager {
private static instance: PipManager = new PipManager();
private pipController?: PiPWindow.PiPController = undefined;
private xcNodeController: XCNodeController;
private mXComponentController: XComponentController;
private lifeCycleCallback: Set<Function> = new Set();
player: AVPlayer;
public static getInstance(): PipManager {
return PipManager.instance;
}
constructor() {
this.xcNodeController = new XCNodeController();
this.player = new AVPlayer();
this.mXComponentController = new CustomXComponentController();
}
public registerLifecycleCallback(callBack: Function) {
this.lifeCycleCallback.add(callBack);
}
public unRegisterLifecycleCallback(callBack: Function): void {
this.lifeCycleCallback.delete(callBack);
}
getNode(): typeNode.XComponent | null {
return this.xcNodeController.getNode();
}
onActionEvent(control: PiPWindow.ControlEventParam) {
switch (control.controlType) {
case PiPWindow.PiPControlType.VIDEO_PLAY_PAUSE:
if (control.status === PiPWindow.PiPControlStatus.PAUSE) {
//停止视频
} else if (control.status === PiPWindow.PiPControlStatus.PLAY) {
//播放视频
}
break;
case PiPWindow.PiPControlType.VIDEO_NEXT:
// 切换到下一个视频
break;
case PiPWindow.PiPControlType.VIDEO_PREVIOUS:
// 切换到上一个视频
break;
case PiPWindow.PiPControlType.FAST_FORWARD:
// 视频进度快进
break;
case PiPWindow.PiPControlType.FAST_BACKWARD:
// 视频进度后退
break;
default:
break;
}
console.info('onActionEvent, controlType:' + control.controlType + ', status' + control.status);
}
onStateChange(state: PiPWindow.PiPState, reason: string) {
let curState: string = '';
this.xcNodeController.setCanAddNode(
state === PiPWindow.PiPState.ABOUT_TO_STOP || state === PiPWindow.PiPState.STOPPED);
if (this.lifeCycleCallback !== null) {
this.lifeCycleCallback.forEach((fun) => {
fun(state);
});
}
switch (state) {
case PiPWindow.PiPState.ABOUT_TO_START:
curState = "ABOUT_TO_START";
// 将typeNode节点从布局移除
this.xcNodeController.removeNode();
break;
case PiPWindow.PiPState.STARTED:
curState = "STARTED";
break;
case PiPWindow.PiPState.ABOUT_TO_STOP:
curState = "ABOUT_TO_STOP";
break;
case PiPWindow.PiPState.STOPPED:
curState = "STOPPED";
break;
case PiPWindow.PiPState.ABOUT_TO_RESTORE:
curState = "ABOUT_TO_RESTORE";
break;
case PiPWindow.PiPState.ERROR:
curState = "ERROR";
break;
default:
break;
}
console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);
}
unregisterPipStateChangeListener() {
console.info(`${TAG} aboutToDisappear`);
this.pipController?.off('stateChange');
this.pipController?.off('controlEvent');
}
getXComponentController(): CustomXComponentController {
return this.mXComponentController;
}
// 步骤1：创建画中画控制器，注册生命周期事件以及控制事件回调
init(ctx: Context) {
if (this.pipController !== null && this.pipController != undefined) {
return;
}
console.info(`${TAG} onPageShow`)
if (!PiPWindow.isPiPEnabled()) {
console.error(TAG, `picture in picture disabled for current OS`);
return;
}
let config: PiPWindow.PiPConfiguration = {
context: ctx,
componentController: this.getXComponentController(),
templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY,
contentWidth: 1920, // 使用typeNode启动画中画时，contentWidth需设置为大于0的值，否则创建画中画失败
contentHeight: 1080, // 使用typeNode启动画中画时，contentHeight需设置为大于0的值，否则创建画中画失败
};
// 通过create接口创建画中画控制器实例
let promise: Promise<PiPWindow.PiPController> = PiPWindow.create(config, this.xcNodeController.getNode());
promise.then((controller: PiPWindow.PiPController) => {
this.pipController = controller;
// 通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画
this.pipController?.setAutoStartEnabled(true);
// 通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调
this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {
this.onStateChange(state, reason);
});
// 通过画中画控制器实例的on('controlEvent')接口注册控制事件回调
this.pipController.on('controlEvent', (control: PiPWindow.ControlEventParam) => {
this.onActionEvent(control);
});
}).catch((err: BusinessError) => {
console.error(TAG, `Failed to create pip controller. Cause:${err.code}, message:${err.message}`);
});
}
// 步骤2：启动画中画
startPip() {
this.pipController?.startPiP().then(() => {
console.info(TAG, `Succeeded in starting pip.`);
}).catch((err: BusinessError) => {
console.error(TAG, `Failed to start pip. Cause:${err.code}, message:${err.message}`);
});
}
// 步骤3：更新媒体源尺寸信息
updateContentSize(width: number, height: number) {
if (this.pipController) {
this.pipController.updateContentSize(width, height);
}
}
// 步骤4：关闭画中画
stopPip() {
if (this.pipController === null || this.pipController === undefined) {
return;
}
let promise: Promise<void> = this.pipController.stopPiP();
promise.then(() => {
console.info(TAG, `Succeeded in stopping pip.`);
}).catch((err: BusinessError) => {
console.error(TAG, `Failed to stop pip. Cause:${err.code}, message:${err.message}`);
});
}
getNodeController(): XCNodeController {
console.info(TAG, `getNodeController.`);
return this.xcNodeController;
}
setAutoStart(autoStart: boolean): void {
this.pipController?.setAutoStartEnabled(autoStart);
}
// 将typeNode节点添加到原父节点
addNode(): void {
this.xcNodeController.addNode();
}
}
```
以上示例代码对应的示意图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170351.93462321504985036453179841448291:50001231000000:2800:EB8271ACCDEABE7650DBE39073B5CA223A6401CBB42475C9A0B704A1FBD4CFA3.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/multi-window-guide-V14
爬取时间: 2025-04-28 00:02:52
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/multi-window-intro-V14
爬取时间: 2025-04-28 00:03:05
来源: Huawei Developer
智慧多窗是一种多任务处理解决方案，它允许用户在同一时间、同一屏幕上以悬浮窗或分屏的方式同时运行多个应用窗口。在智慧多窗的显示模式下，用户可以根据自己的需求，合理安排应用窗口的位置和大小。
悬浮窗
悬浮窗是一种在设备屏幕上悬浮的、非全屏的应用窗口。一般用于在已有全屏任务运行的基础上，临时处理另一个任务，或短时间多任务并行使用。如浏览网页的同时回复消息。
针对手机，一个屏幕内最多支持显示一个悬浮窗；在折叠屏手机展开态、平板类设备上，一个屏幕内最多支持显示两个悬浮窗。在超出悬浮窗显示最大个数限制时，打开新的悬浮窗会替换最近久未操作的悬浮窗。
悬浮窗的类型
悬浮窗的常见类型主要分为如下两种：
-
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170351.34599928375753210339571805753939:50001231000000:2800:B68647D5439C2092262510ED31A5A3CAE875D709D962B2B8234FD543A73885C9.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170352.12715947195204265230280071181021:50001231000000:2800:18A7C436F5C86F5039326F2B4E128CFC210462F231870A3756186EE8F9FF29E9.jpg)
悬浮窗的触发及恢复方式
悬浮窗的触发方式有以下两种：
-
-  悬浮窗的恢复方式主要有以下两种：
-
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170352.94288197246069629223569813848511:50001231000000:2800:158B5FBDFF3B8EC3A7F9B2F55BAE42EF9D83A4D85C85BE33C6371572AF7E39B6.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170352.63955405265361105309847332542033:50001231000000:2800:84B0AE5A7DF11B38FC65A6D34D36CCE62529871262504F6B6CAC83A2AC454BEC.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170353.85586686464855073989773319032917:50001231000000:2800:547EF65CD61C29F043D73B7C80CC926CBA1CC452932D57F80E2F4F3B1B1DDDEB.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170353.88061131579134063058054561098896:50001231000000:2800:BB3A133A704EFC3429AC06930063BF17747331DCB915826C3F49A3C5F25118FB.png)
分屏
分屏一般用于两个应用长时间并行使用的场景。例如边看购物攻略、边浏览商品；边看视频、边玩游戏；看学习类视频的同时做笔记等。
分屏的触发方式
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170354.97729291480969010242204372406685:50001231000000:2800:C3682CC73BB4A84A3639B4F4AAEAB8E0797B81311ECD4439D50806FF85783BF0.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/multi-window-adapt-V14
爬取时间: 2025-04-28 00:03:19
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/multi-window-support-V14
爬取时间: 2025-04-28 00:03:32
来源: Huawei Developer
当应用需要智慧多窗的能力时，可以通过在module.json5配置文件中对应标签添加相关字段声明支持。
声明支持悬浮窗
开发者可以通过在module.json5配置文件中abilities标签下的supportWindowMode属性增加“floating”字段或使用缺省值以声明应用支持悬浮窗。
supportWindowMode缺省值为["fullscreen", "split", "floating"]。
supportWindowMode属性主要标识当前UIAbility所支持的窗口模式，支持的字段及含义如下表所示。
| 字段  | 说明  |
| --- | --- |
| fullscreen  | 窗口支持全屏显示。  |
| split  | 窗口支持分屏显示。  |
| floating  | 窗口支持悬浮窗显示。  |
字段
说明
fullscreen
窗口支持全屏显示。
split
窗口支持分屏显示。
floating
窗口支持悬浮窗显示。
在应用声明支持智慧多窗后，还可根据业务场景的需要配置是否支持横向悬浮窗或上下分屏模式。
当应用需要支持横向悬浮窗时，开发者可以通过在module.json5配置文件中abilities标签下的preferMultiWindowOrientation属性增加“landscape”或者“landscape_auto”配合API以声明应用支持横向悬浮窗或上下分屏模式。
preferMultiWindowOrientation属性主要标识当前UIAbility组件多窗布局方向，支持的字段及含义如下表所示。
| 配置值  | 说明  | 效果  |
| --- | --- | --- |
| portrait  | 多窗布局方向为竖向。建议竖向游戏类应用配置。  | 手机 手势触发悬浮窗：竖向悬浮窗 手势触发分屏：不支持 分屏样式切换：不涉及 折叠屏手机展开态 手势触发悬浮窗：竖向悬浮窗 手势触发分屏：形成左右分屏 分屏样式切换：不支持样式切换  |
| landscape  | 多窗布局方向为横向，配置后支持横向悬浮窗和上下分屏。建议横向游戏类应用配置。   | 手机 手势触发悬浮窗：横向悬浮窗 手势触发分屏：不支持 分屏样式切换：不涉及 折叠屏手机展开态 手势触发悬浮窗：横向悬浮窗 手势触发分屏：形成上下分屏 分屏样式切换：不支持样式切换  |
| landscape_auto  | 多窗布局动态可变为横向，需要配合API（enableLandscapeMultiWindow / disableLandscapeMultiWindow）使用。建议视频类应用配置。  | 系统识别应用为横向全屏播放： 手机 手势触发悬浮窗：横向悬浮窗 手势触发分屏：形成上下分屏 分屏样式切换：不涉及 折叠屏手机展开态 手势触发悬浮窗：横向悬浮窗 手势触发分屏：形成上下分屏 分屏样式切换：支持样式切换 系统识别应用为非横向全屏播放：同配置为default  |
| default  | 缺省值，参数不配置时默认为default。 建议其他应用类配置。  | 折叠屏手机折叠态 & 手机 手势触发悬浮窗：竖向悬浮窗 手势触发分屏：形成上下分屏 分屏样式切换：不涉及 折叠屏手机展开态 手势触发悬浮窗：竖向悬浮窗 手势触发分屏：形成左右分屏 分屏样式切换：支持样式切换  |
配置值
说明
效果
portrait
多窗布局方向为竖向。建议竖向游戏类应用配置。
手机
手势触发悬浮窗：竖向悬浮窗
手势触发分屏：不支持
分屏样式切换：不涉及
折叠屏手机展开态
手势触发悬浮窗：竖向悬浮窗
手势触发分屏：形成左右分屏
分屏样式切换：不支持样式切换
landscape
多窗布局方向为横向，配置后支持横向悬浮窗和上下分屏。建议横向游戏类应用配置。
手机
手势触发悬浮窗：横向悬浮窗
手势触发分屏：不支持
分屏样式切换：不涉及
折叠屏手机展开态
手势触发悬浮窗：横向悬浮窗
手势触发分屏：形成上下分屏
分屏样式切换：不支持样式切换
landscape_auto
多窗布局动态可变为横向，需要配合API（enableLandscapeMultiWindow/disableLandscapeMultiWindow）使用。建议视频类应用配置。
系统识别应用为横向全屏播放：
手机
手势触发悬浮窗：横向悬浮窗
手势触发分屏：形成上下分屏
分屏样式切换：不涉及
折叠屏手机展开态
手势触发悬浮窗：横向悬浮窗
手势触发分屏：形成上下分屏
分屏样式切换：支持样式切换
系统识别应用为非横向全屏播放：同配置为default
default
缺省值，参数不配置时默认为default。
建议其他应用类配置。
折叠屏手机折叠态 & 手机
手势触发悬浮窗：竖向悬浮窗
手势触发分屏：形成上下分屏
分屏样式切换：不涉及
折叠屏手机展开态
手势触发悬浮窗：竖向悬浮窗
手势触发分屏：形成左右分屏
分屏样式切换：支持样式切换
声明支持分屏
开发者可以通过在module.json5配置文件中abilities标签下的supportWindowMode属性增加“split”字段或使用缺省值以声明应用支持分屏。
supportWindowMode缺省值为["fullscreen", "split", "floating"]。
supportWindowMode属性主要标识当前UIAbility所支持的窗口模式，支持的字段及含义如下表所示。
| 字段  | 说明  |
| --- | --- |
| fullscreen  | 窗口支持全屏显示。  |
| split  | 窗口支持分屏显示。  |
| floating  | 窗口支持悬浮窗显示。  |
字段
说明
fullscreen
窗口支持全屏显示。
split
窗口支持分屏显示。
floating
窗口支持悬浮窗显示。
应用内分屏
应用内分屏功能允许声明支持分屏的应用在全屏显示模式下，通过调用startAbility方法启动UIAbility并形成分屏。该功能能够增强应用的多任务处理能力，提升用户的操作体验。
此处以点击按钮启动分屏为例，主要步骤和示例如下所示：
1.
2.
完整示例如下：
使用DevEco Studio新建Ability，创建EntryAbility1和EntryAbility2，对应文中组成分屏的两个窗口页面，加载页面为默认页面Index.ets。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/multi-window-layout-adapt-V14
爬取时间: 2025-04-28 00:03:45
来源: Huawei Developer
应用布局适配智慧多窗的意义
由于应用从全屏进入智慧多窗（悬浮窗/分屏）模式后，窗口尺寸、宽高比例会发生变化，所以需要开发者适配应用窗口在不同尺寸、不同比例下的自适应布局，以确保应用窗口在各种形态下都能呈现出最佳的视觉效果，提供更好的用户体验。
悬浮窗的比例
不同设备支持悬浮窗的比例如下所示：
| 设备  | 竖向悬浮窗宽高比  | 横向悬浮窗宽高比  |
| --- | --- | --- |
| 手机  | 3:4.575  | 16:9  |
| 折叠屏手机展开态  | 9:16  | 16:9  |
设备
竖向悬浮窗宽高比
横向悬浮窗宽高比
手机
3:4.575
16:9
折叠屏手机展开态
9:16
16:9
分屏的比例
目前支持两种分屏样式：“上下分屏”和“左右分屏”。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170355.75092836796089648894986138773864:50001231000000:2800:5D316DEA46119B80CE58FD38520AAB314717A54FCC4A5FBB507DB73682997904.jpg)
分屏比例指的是分屏下两应用间尺寸的比例，调整分屏比例会调整应用窗口的大小。
默认形成分屏后分屏比例为1:1，拖动中间的分屏条可以改变分屏比例档位。手机“上下分屏”可调节档位1:2、1:1、2:1，“左右分屏”可调节档位为1:1。手机折叠屏展开态可调节档位只有1:1。
| 设备  | 默认分屏比例  | 分屏可调节档位  |
| --- | --- | --- |
| 手机  | 1:1  | “上下分屏”: 1:1, 1:2, 2:1 “左右分屏”: 1:1  |
| 手机折叠屏展开态  | 1:1  | “上下分屏”和 “左右分屏”: 1:1  |
设备
默认分屏比例
分屏可调节档位
手机
1:1
“上下分屏”: 1:1, 1:2, 2:1
“左右分屏”: 1:1
手机折叠屏展开态
1:1
“上下分屏”和 “左右分屏”: 1:1
应用布局可以通过自适应布局和响应式布局来更新自身布局，避免出现截断、挤压、堆叠等现象:
应用布局适配智慧多窗的方案
无论是悬浮窗还是分屏，当应用进入智慧多窗模式时，应用的窗口尺寸发生变化，所以应用需要根据不同的窗口尺寸调整自身布局。
主要可以通过窗口的on('windowSizeChange')方法实现对窗口尺寸大小变化的监听。再根据窗口的尺寸变化，更新调整自身应用布局以实现适配。
主要步骤和示例如下：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/multi-window-controlbar-adapt-V14
爬取时间: 2025-04-28 00:03:59
来源: Huawei Developer
顶部窗口控制条是应用窗口处于智慧多窗模式下，应用顶部的操作横条。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170355.73841469596541980553171556175279:50001231000000:2800:90C160CC2089522DA04EA8BDE43A4B82BE01FF8FB529D27447711520122FCA2F.png)
顶部窗口控制条示意图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170355.38236538110600786697475509045008:50001231000000:2800:BE4636BF17B9AA15450226ED129D3A3425D2AF775A90FC6A7D1F063515D9F03F.jpg)
顶部横条的避让可通过以下两种方式适配：
-  沉浸式布局是指应用布局不避让状态栏、导航栏以及智慧多窗顶部横条，这可能发生组件与顶部横条的重叠，导致文字遮挡、点击事件冲突等情况。非沉浸式布局是指布局避让状态栏、导航栏以及智慧多窗顶部横条，组件不会与其重叠。因此可设置isLayoutFullScreen值为false使窗口的布局为非沉浸式布局。 示例：
```typescript
// Index.ets
import { BusinessError } from '@kit.BasicServicesKit';
import { window } from '@kit.ArkUI';
@Entry
@Component
struct Index {
@State message: string = '非沉浸式布局';
private windowClass: window.Window | undefined = undefined;
aboutToAppear(): void {
try {
window.getLastWindow(getContext(this), (err: BusinessError, data) => {
const errCode: number = err.code;
if (errCode) {
console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));
return;
}
this.windowClass = data;
console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));
});
} catch (exception) {
console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));
}
}
private setWindowLayoutFullScreen(isLayoutFullScreen: boolean) {
if (!this.windowClass) {
return;
}
try {
this.windowClass.setWindowLayoutFullScreen(isLayoutFullScreen, (err: BusinessError) => {
const errCode: number = err.code;
if (errCode) {
console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in setting the window layout to full-screen mode.');
});
} catch (exception) {
console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(exception));
}
}
build() {
Stack({ alignContent: Alignment.TopStart }) {
Column() {
Text(this.message)
.fontSize(25)
.fontWeight(FontWeight.Bold)
.margin({
top: '2%',
bottom: '40%'
})
Button() {
Text('设置窗口为沉浸式布局')
.fontSize(18)
.fontWeight(FontWeight.Normal)
}
.type(ButtonType.Normal)
.borderRadius(15)
.margin({ top: 20 })
.stateStyles({
normal: {
.backgroundColor('#ff6b89d4')
},
pressed: {
.backgroundColor('#ffc81f2a')
}
})
.width('60%')
.height('6%')
.onClick(() => {
this.setWindowLayoutFullScreen(true);
this.message = '沉浸式布局';
})
Button() {
Text('设置窗口为非沉浸式布局')
.fontSize(18)
.fontWeight(FontWeight.Normal)
}
.type(ButtonType.Normal)
.borderRadius(15)
.margin({ top: 20 })
.stateStyles({
normal: {
.backgroundColor('#ff6b89d4')
},
pressed: {
.backgroundColor('#ffc81f2a')
}
})
.width('60%')
.height('6%')
.onClick(() => {
this.setWindowLayoutFullScreen(false);
this.message = '非沉浸式布局';
})
}
.width('100%')
}
.backgroundColor('#fceaeaea')
.height('100%')
}
}
```
```typescript
// Index.ets
import { BusinessError } from '@kit.BasicServicesKit';
import { window } from '@kit.ArkUI';
@Entry
@Component
struct Index {
@State topSafeHeight: number = 0;
aboutToAppear(): void {
try {
let windowClass: window.Window | undefined = undefined;
window.getLastWindow(getContext(this), (err: BusinessError, data) => {
const errCode: number = err.code;
if (errCode) {
console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));
return;
}
windowClass = data;
windowClass.setWindowLayoutFullScreen(true);
this.topSafeHeight = px2vp(windowClass.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM).topRect.height);
windowClass.on('avoidAreaChange', (data) => {
if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {
this.topSafeHeight = px2vp(data.area.topRect.height)
}
})
console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));
});
} catch (exception) {
console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));
}
}
build() {
Stack({ alignContent: Alignment.TopStart }) {
// 顶部避让区域
Row() {
}
.height(this.topSafeHeight)
.width("100%")
// 根据topSafeHeight动态调整应用布局
// ...
}
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170355.25685616243697900525972776926558:50001231000000:2800:FB9303303A0691112102C375731AA476FCE3DC2EA61FB4283E94F52C8C7356AF.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/display-manager-V14
爬取时间: 2025-04-28 00:04:13
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/displaymanager-overview-V14
爬取时间: 2025-04-28 00:04:27
来源: Huawei Developer
屏幕管理主要是针对设备的各种屏幕（包括物理屏、虚拟屏、折叠屏）进行管理，管理其各种属性信息，并当做广播者，将监听到的信息广播给各个需要屏幕信息的订阅服务。
屏幕管理主要包括以下几方面能力：
针对屏幕属性相关信息的查询和监听，可见使用OH_DisplayManager实现屏幕基础信息查询和状态监听 (C/C++)和使用Display实现屏幕属性查询及状态监听 (ArkTS)。
约束和限制

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/native-display-manager-V14
爬取时间: 2025-04-28 00:04:41
来源: Huawei Developer
场景介绍
OH_DisplayManager屏幕管理模块用于提供屏幕的信息查询、屏幕状态变化监听、折叠设备的折叠状态变化监听等能力，应用可根据对应的屏幕信息、屏幕状态变化、屏幕折叠状态适配不同的UI界面显示。
-  支持查询的屏幕信息，包括屏幕的分辨率、物理像素密度、逻辑像素密度、刷新率、屏幕尺寸、屏幕旋转方向、屏幕旋转角度等。
-  支持屏幕状态变化的监听，包括屏幕旋转变化，屏幕分辨率变化、屏幕刷新率变化等。
-  支持查询当前设备是否为可折叠设备，同时支持折叠状态（展开/折叠）变化的监听。
基本概念
-  屏幕的物理像素密度(densityDPI)：代表每英寸屏幕所拥有的物理像素点数。
-  屏幕的逻辑像素的密度(densityPixels)：代表物理像素与逻辑像素的缩放系数比，计算方法为物理像素密度除以160。
接口说明
常用接口如下表所示。更多API说明请参考OH_DisplayManager。
| 接口名 | 描述 |
| --- | --- |
| OH_NativeDisplayManager_GetDefaultDisplayRotation(NativeDisplayManager_Rotation *displayRotation) | 获取默认屏幕的旋转角度。 |
| OH_NativeDisplayManager_CreateDefaultDisplayCutoutInfo(NativeDisplayManager_CutoutInfo **cutoutInfo) | 获取挖孔屏、刘海屏、瀑布屏等不可用屏幕区域信息。 |
| OH_NativeDisplayManager_DestroyDefaultDisplayCutoutInfo(NativeDisplayManager_CutoutInfo *cutoutInfo) | 销毁挖孔屏、刘海屏、瀑布屏等不可用屏幕区域信息。 |
| OH_NativeDisplayManager_IsFoldable() | 查询设备是否可折叠。 |
| OH_NativeDisplayManager_RegisterDisplayChangeListener( OH_NativeDisplayManager_DisplayChangeCallback displayChangeCallback, uint32_t *listenerIndex) | 注册屏幕状态变化监听（如旋转变化、刷新率、DPI、分辨率等）。 |
| OH_NativeDisplayManager_UnregisterDisplayChangeListener(uint32_t listenerIndex) | 取消屏幕状态变化监听。 |
| OH_NativeDisplayManager_RegisterFoldDisplayModeChangeListener( OH_NativeDisplayManager_FoldDisplayModeChangeCallback displayModeChangeCallback, uint32_t *listenerIndex) | 注册屏幕展开、折叠状态变化监听。 |
| OH_NativeDisplayManager_UnregisterFoldDisplayModeChangeListener(uint32_t listenerIndex) | 取消屏幕展开、折叠状态变化监听。 |
在CMake脚本中链接动态库
添加头文件
获取屏幕状态
1.  可以通过OH_NativeDisplayManager_GetDefaultDisplayRotation获取默认屏幕的旋转角度。
2.  可以通过OH_NativeDisplayManager_CreateDefaultDisplayCutoutInfo获取挖孔屏、刘海屏、瀑布屏等不可用屏幕区域信息。 可通过OH_NativeDisplayManager_DestroyDefaultDisplayCutoutInfo销毁挖孔屏、刘海屏、瀑布屏等不可用屏幕区域信息。
监听屏幕状态变化
可以通过OH_NativeDisplayManager_RegisterDisplayChangeListener接口注册屏幕变化的监听，包括屏幕旋转、分辨率变化、刷新率变化、DPI变化等。 通过OH_NativeDisplayManager_UnregisterDisplayChangeListener接口取消屏幕状态变化的监听。
监听折叠设备状态变化
1.  可以通过OH_NativeDisplayManager_IsFoldable接口查询设备是不是折叠设备。
2.  可以通过OH_NativeDisplayManager_RegisterFoldDisplayModeChangeListener注册屏幕展开/折叠状态变化的监听。 通过OH_NativeDisplayManager_UnregisterFoldDisplayModeChangeListener接口取消屏幕展开/折叠状态变化的监听。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/screenproperty-guideline-V14
爬取时间: 2025-04-28 00:05:35
来源: Huawei Developer
场景介绍
Display屏幕属性提供管理设备屏幕的一些基础能力，例如获取默认显示设备的相关信息、获取全部显示设备的信息，此外还能对显示设备的插拔行为进行监听。应用可以根据对应的屏幕信息、屏幕状态变化、屏幕折叠状态等适配不同的UI界面显示。
屏幕属性的常见使用场景有以下几种：
接口说明
屏幕属性的常用接口如下表所示，更多功能及接口说明和使用请见@ohos.display (屏幕属性)。
| 接口 | 描述 |
| --- | --- |
| getAllDisplays(): Promise<Array<Display>> | 获取当前所有的Display对象，使用Promise异步回调。 |
| getDefaultDisplaySync(): Display | 获取当前默认的display对象。 |
| getDisplayByIdSync(displayId: number): Display | 根据DisplayId获取对应的Display对象。 |
| on(type: 'add'|'remove'|'change', callback: Callback<number>): void | 开启显示设备变化的监听。 |
| off(type: 'add'|'remove'|'change', callback?: Callback<number>): void | 关闭显示设备变化的监听。 |
| on(type: 'captureStatusChange', callback: Callback<boolean>): void | 开启屏幕截屏、投屏、录屏状态变化的监听。 |
| off(type: 'captureStatusChange', callback?: Callback<boolean>): void | 关闭屏幕截屏、投屏、录屏状态变化的监听。 |
| on(type: 'availableAreaChange', callback: Callback<Rect>): void | 开启当前设备屏幕的可用区域监听。当前设备屏幕有可用区域变化时，触发回调函数，返回可用区域。 |
| off(type: 'availableAreaChange', callback?: Callback<Rect>): void | 关闭当前设备屏幕可用区域变化的监听。 |
| isFoldable(): boolean | 检查设备是否可折叠。 |
| on(type: 'foldStatusChange', callback: Callback<FoldStatus>): void | 开启折叠设备折叠状态变化的监听。 |
| off(type: 'foldStatusChange', callback?: Callback<FoldStatus>): void | 关闭折叠设备折叠状态变化的监听。 |
获取Display对象
Display对象，即屏幕实例，提供屏幕相关属性及监听变化的接口。目前有以下几种不同获取Display的方式，开发者可根据具体场景需要选择使用。
此处，以使用getDefaultDisplaySync()获取当前默认Display对象为例，示例如下：
```typescript
import { display } from '@kit.ArkUI';
let displayClass: display.Display | null = null;
displayClass = display.getDefaultDisplaySync();
// 确保获取到Display对象，即displayClass，再进行后续相关屏幕属性信息查询和事件/状态变化监听
```
获取屏幕相关属性
1.  确保获取到Display对象之后（具体可见获取Display对象），可以通过相关属性查询屏幕的一些基础信息。
```typescript
import { display } from '@kit.ArkUI';
let displayClass: display.Display | null = null;
displayClass = display.getDefaultDisplaySync();
// 获取屏幕Id
console.info(`The scree Id is ${displayClass.id}.`);
// 获取屏幕刷新率
console.info(`The screen is ${displayClass.refreshRate}.`);
// 获取屏幕宽度
console.info(`The screen width is ${displayClass.width}.`);
// 获取屏幕高度
console.info(`The screen height is ${displayClass.height}.`);
// ...
```
2.  还可以通过getCutoutInfo()获取挖孔屏、刘海屏、瀑布屏等不可用的屏幕区域信息，以在UI布局时更好地规避该区域。也可以通过getAvailableArea()获取当前设备屏幕的可用区域。
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
displayClass.getCutoutInfo().then((cutoutInfo: display.CutoutInfo) => {
console.info('Succeeded in getting cutoutInfo. Data: ' + JSON.stringify(cutoutInfo));
}).catch((err: BusinessError) => {
console.error(`Failed to obtain all the display objects. Code: ${err.code}, message: ${err.message}`);
});
displayClass.getAvailableArea().then((availableArea) => {
console.info('Succeeded get the available area in this display. data: ' + JSON.stringify(availableArea));
}).catch((err: BusinessError) => {
console.error(`Failed to get the available area in this display. Code: ${err.code}, message: ${err.message}`);
});
```
3.  此外，还可以通过display.isCaptured()判断当前设备是都正在截屏、投屏或录屏。
```typescript
console.info(`The sceeen is captured or not : ${display.isCaptured()}`);
```
监听屏幕状态变化
1.  可以通过display.on('add'|'remove'|'change')监听设备屏幕变化，支持监听屏幕设备的增加、移除和改变等，可以通过display.off('add'|'remove'|'change')关闭对应的监听。
```typescript
import { display } from '@kit.ArkUI';
import { Callback } from '@kit.BasicServicesKit';
let callback1: Callback<number> = (data: number) => {
console.info('Listening enabled. Data: ' + JSON.stringify(data));
};
// 此处以监听显示设备的增加为例
display.on("add", callback1);
// 如果通过on注册多个callback，同时关闭所有callback监听
display.off("add");
// 关闭单个callback监听
display.off('add', callback1);
```
2.  可以通过display.on('captureStatusChange')开启屏幕截屏、投屏或录屏状态变化的监听；可以通过display.off('captureStatusChange')关闭对应的监听。
```typescript
let callback2: Callback<boolean> = (captureStatus: boolean) => {
// captureStatus为true表示显示设备开始截屏、投屏或录屏，false表示结束截屏、投屏或录屏
console.info('Listening capture status: ' + captureStatus);
};
// 开启屏幕截屏、投屏、录屏状态变化的监听
display.on('captureStatusChange', callback2);
display.off('captureStatusChange', callback2);
```
3.  此外，还可以通过on('availableAreaChange')监听当前屏幕对象（Display对象）的可用区域变化；可通过on('availableAreaChange')关闭对应的监听。
```typescript
import { Callback } from '@kit.BasicServicesKit';
import { display } from '@kit.ArkUI';
let callback3: Callback<display.Rect> = (data: display.Rect) => {
console.info('Listening enabled. Data: ' + JSON.stringify(data));
};
let displayClass: display.Display | null = null;
try {
displayClass = display.getDefaultDisplaySync();
// 开启当前屏幕可用区域变化的监听
displayClass.on("availableAreaChange", callback3);
} catch (exception) {
console.error(`Failed to register callback. Code: ${exception.code}, message: ${exception.message}`);
}
// 关闭当前监听
displayClass.off("availableAreaChange", callback3);
```
监听折叠设备状态变化
1.  可以通过display.isFoldable()接口查询当前设备是不是折叠设备。
```typescript
import { display } from '@kit.ArkUI';
let ret: boolean = false;
ret = display.isFoldable();
```
2.  若当前设备为折叠设备，可以通过display.on('foldStatusChange')开启折叠设备折叠状态变化的监听；可通过display.off('foldStatusChange')关闭对应的监听。
```typescript
import { Callback } from '@kit.BasicServicesKit';
/**
* 注册监听的callback参数要采用对象传递.
* 若使用匿名函数注册，每次调用会创建一个新的底层对象，引起内存泄漏问题。
*/
let callback: Callback<display.FoldStatus> = (data: display.FoldStatus) => {
console.info('Listening enabled. Data: ' + JSON.stringify(data));
};
display.on('foldStatusChange', callback);
// 如果通过on注册多个callback，同时关闭所有callback监听
display.off('foldStatusChange');
// 关闭单个callback监听
display.off('foldStatusChange', callback);
```

# 合并文件
合并时间: 2025-04-28 07:04:34

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-paradigm-basic-syntax
爬取时间: 2025-04-28 06:51:10
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-basic-syntax-overview
爬取时间: 2025-04-28 06:51:23
来源: Huawei Developer
在初步了解了ArkTS语言之后，我们以一个具体的示例来说明ArkTS的基本组成。如下图所示，当开发者点击按钮时，文本内容从“Hello World”变为“Hello ArkUI”。
图1示例效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163818.64337074871265909434522751339789:50001231000000:2800:390AE1C7B2EBDE8D5AF89F8F666975C85FE09C0D20B9DAE9BBE38F744BBCEE99.gif)
本示例中，ArkTS的基本组成如下所示。
图2ArkTS的基本组成
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163819.33242931398155932928266269590032:50001231000000:2800:8EC090EDCCE12EC8CE65CFCCDFA4F7E6571F811BD0CD554602C347EC79605587.png)
自定义变量不能与基础通用属性/事件名重复。
-  装饰器： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component和@State都是装饰器，@Component表示自定义组件，@Entry表示该自定义组件为入口组件，@State表示组件中的状态变量，状态变量变化会触发UI刷新。
-  UI描述：以声明式的方式来描述UI的结构，例如build()方法中的代码块。
-  自定义组件：可复用的UI单元，可组合其他组件，如上述被@Component装饰的struct Hello。
-  系统组件：ArkUI框架中默认内置的基础和容器组件，可直接被开发者调用，比如示例中的Column、Text、Divider、Button。
-  属性方法：组件可以通过链式调用配置多项属性，如fontSize()、width()、height()、backgroundColor()等。
-  事件方法：组件可以通过链式调用设置多个事件的响应逻辑，如跟随在Button后面的onClick()。
除此之外，ArkTS扩展了多种语法范式来使开发更加便捷：
-  @Builder/@BuilderParam：特殊的封装UI描述的方法，细粒度的封装和复用UI描述。
-  @Extend/@Styles：扩展系统组件和封装属性样式，更灵活地组合系统组件。
-  stateStyles：多态样式，可以依据组件的内部状态的不同，设置不同样式。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-declarative-ui-description
爬取时间: 2025-04-28 06:51:36
来源: Huawei Developer
ArkTS以声明方式组合和扩展组件来描述应用程序的UI，同时还提供了基本的属性、事件和子组件配置方法，帮助开发者实现应用交互逻辑。
创建组件
根据组件构造方法的不同，创建组件包含有参数和无参数两种方式。
创建组件时不需要new运算符。
无参数
如果组件的接口定义没有包含必选构造参数，则组件后面的“()”不需要配置任何内容。例如，Divider组件不包含构造参数。
```typescript
Column() {
Text('item 1')
Divider()
Text('item 2')
}
```
有参数
如果组件的接口定义包含构造参数，则在组件后面的“()”需要配置相应参数。
-  Image组件的必选参数src。
```typescript
Image('https://xyz/test.jpg')
```
-  Text组件的非必选参数content。
```typescript
// string类型的参数
Text('test')
// $r形式引入应用资源，可应用于多语言场景
Text($r('app.string.title_value'))
// 无参数形式
Text()
```
-  变量或表达式也可以用于参数赋值，其中表达式返回的结果类型必须满足参数类型要求。 例如，设置变量或表达式来构造Image和Text组件的参数。
```typescript
Image(this.imagePath)
Image('https://' + this.imageUrl)
Text(`count: ${this.count}`)
```
配置属性
属性方法以“.”链式调用的方式配置系统组件的样式和其他属性，建议每个属性方法单独写一行。
-  配置Text组件的字体大小。
```typescript
Text('test')
.fontSize(12)
```
-  配置组件的多个属性。
```typescript
Image('test.jpg')
.alt('error.jpg')
.width(100)
.height(100)
```
-  除了直接传递常量参数外，还可以传递变量或表达式。
```typescript
Text('hello')
.fontSize(this.size)
Image('test.jpg')
.width(this.count % 2 === 0 ? 100 : 200)
.height(this.offset + 100)
```
-  对于系统组件，ArkUI还为其属性预定义了一些枚举类型供开发者调用，枚举类型可以作为参数传递，但必须满足参数类型要求。 例如，可以按以下方式配置Text组件的颜色和字体样式。
```typescript
Text('hello')
.fontSize(20)
.fontColor(Color.Red)
.fontWeight(FontWeight.Bold)
```
配置事件
事件方法以“.”链式调用的方式配置系统组件支持的事件，建议每个事件方法单独写一行。
-  使用箭头函数配置组件的事件方法。
```typescript
Button('Click me')
.onClick(() => {
this.myText = 'ArkUI';
})
```
-  使用箭头函数表达式配置组件的事件方法，要求使用“() => {...}”，以确保函数与组件绑定，同时符合ArkTS语法规范。
```typescript
Button('add counter')
.onClick(() => {
this.counter += 2;
})
```
-  使用组件的成员函数配置组件的事件方法，需要bind this。ArkTS语法不推荐使用成员函数配合bind this去配置组件的事件方法。
```typescript
myClickHandler(): void {
this.counter += 2;
}
...
Button('add counter')
.onClick(this.myClickHandler.bind(this))
```
-  使用声明的箭头函数，可以直接调用，不需要bind this。
```typescript
fn = () => {
console.info(`counter: ${this.counter}`)
this.counter++
}
...
Button('add counter')
.onClick(this.fn)
```
箭头函数内部的this是词法作用域，由上下文确定。匿名函数可能会有this指向不明确问题，在ArkTS中不允许使用。
配置子组件
如果组件支持子组件配置，则需在尾随闭包"{...}"中为组件添加子组件的UI描述。Column、Row、Stack、Grid、List等组件都是容器组件。
-  以下是简单的Column组件配置子组件的示例。
```typescript
Column() {
Text('Hello')
.fontSize(100)
Divider()
Text(this.myText)
.fontSize(100)
.fontColor(Color.Red)
}
```
-  容器组件均支持子组件配置，可以实现相对复杂的多级嵌套。
```typescript
Column() {
Row() {
Image('test1.jpg')
.width(100)
.height(100)
Button('click +1')
.onClick(() => {
console.info('+1 clicked!');
})
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-custom-components
爬取时间: 2025-04-28 06:51:50
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components
爬取时间: 2025-04-28 06:52:03
来源: Huawei Developer
在ArkUI中，UI显示的内容均为组件，由框架直接提供的称为系统组件，由开发者定义的称为自定义组件。在进行 UI 界面开发时，通常不是简单的将系统组件进行组合使用，而是需要考虑代码可复用性、业务逻辑与UI分离，后续版本演进等因素。因此，将UI和部分业务逻辑封装成自定义组件是不可或缺的能力。
自定义组件具有以下特点：
-  可组合：允许开发者组合使用系统组件、及其属性和方法。
-  可重用：自定义组件可以被其他组件重用，并作为不同的实例在不同的父组件或容器中使用。
-  数据驱动UI更新：通过状态变量的改变，来驱动UI的刷新。
自定义组件的基本用法
以下示例展示了自定义组件的基本用法。
```typescript
@Component
struct HelloComponent {
@State message: string = 'Hello, World!';
build() {
// HelloComponent自定义组件组合系统组件Row和Text
Row() {
Text(this.message)
.onClick(() => {
// 状态变量message的改变驱动UI刷新，UI从'Hello, World!'刷新为'Hello, ArkUI!'
this.message = 'Hello, ArkUI!';
})
}
}
}
```
如果在另外的文件中引用该自定义组件，需要使用export关键字导出，并在使用的页面import该自定义组件。
HelloComponent可以在其他自定义组件中的build()函数中多次创建，实现自定义组件的重用。
```typescript
@Entry
@Component
struct ParentComponent {
build() {
Column() {
Text('ArkUI message')
HelloComponent({ message: 'Hello World!' });
Divider()
HelloComponent({ message: '你好，世界!' });
}
}
}
```
要完全理解上面的示例，需要了解自定义组件的以下概念定义，本文将在后面的小节中介绍：
-  自定义组件的基本结构
-  成员函数/变量
-  自定义组件的参数规定
-  build()函数
-  自定义组件通用样式
自定义组件的基本结构
struct
自定义组件基于struct实现，struct + 自定义组件名 + {...}的组合构成自定义组件，不能有继承关系。对于struct的实例化，可以省略new。
自定义组件名、类名、函数名不能和系统组件名相同。
@Component
@Component装饰器仅能装饰struct关键字声明的数据结构。struct被@Component装饰后具备组件化的能力，需要实现build方法描述UI，一个struct只能被一个@Component装饰。@Component可以接受一个可选的bool类型参数。
从API version 9开始，该装饰器支持在ArkTS卡片中使用。
从API version 11开始，@Component可以接受一个可选的bool类型参数。
```typescript
@Component
struct MyComponent {
}
```
freezeWhenInactive11+
组件冻结选项。
| 名称 | 类型 | 必填 | 说明 |
| --- | --- | --- | --- |
| freezeWhenInactive | boolean | 否 | 是否开启组件冻结，默认值false。 |
```typescript
@Component({ freezeWhenInactive: true })
struct MyComponent {
}
```
build()函数
build()函数用于定义自定义组件的声明式UI描述，自定义组件必须定义build()函数。
```typescript
@Component
struct MyComponent {
build() {
}
}
```
@Entry
@Entry装饰的自定义组件将作为UI页面的入口。在单个UI页面中，最多可以使用@Entry装饰一个自定义组件。@Entry可以接受一个可选的LocalStorage的参数。
从API version 9开始，该装饰器支持在ArkTS卡片中使用。
从API version 10开始，@Entry可以接受一个可选的LocalStorage的参数或者一个可选的EntryOptions参数。
从API version 11开始，该装饰器支持在元服务中使用。
```typescript
@Entry
@Component
struct MyComponent {
}
```
EntryOptions10+
命名路由跳转选项。
| 名称 | 类型 | 必填 | 说明 |
| --- | --- | --- | --- |
| routeName | string | 否 | 表示作为命名路由页面的名字。 |
| storage | LocalStorage | 否 | 页面级的UI状态存储。 |
| useSharedStorage12+ | boolean | 否 | 是否使用LocalStorage.getShared()接口返回的LocalStorage实例对象，默认值false。 |
当useSharedStorage设置为true，并且storage也被赋值时，useSharedStorage的值优先级更高。
```typescript
@Entry({ routeName : 'myPage' })
@Component
struct MyComponent {
}
```
@Reusable
@Reusable装饰的自定义组件具备可复用能力。详细请参考：@Reusable装饰器：组件复用。
从API version 10开始，该装饰器支持在ArkTS卡片中使用。
```typescript
@Reusable
@Component
struct MyComponent {
}
```
成员函数/变量
自定义组件除了必须要实现build()函数外，还可以实现其他成员函数，成员函数具有以下约束：
自定义组件可以包含成员变量，成员变量具有以下约束：
-  自定义组件的成员变量为私有的，且不建议声明成静态变量。
-  自定义组件的成员变量本地初始化有些是可选的，有些是必选的。具体是否需要本地初始化，是否需要从父组件通过参数传递初始化子组件的成员变量，请参考状态管理。
自定义组件的参数规定
从上文的示例中，我们已经了解到，可以在build方法里创建自定义组件，在创建自定义组件的过程中，根据装饰器的规则来初始化自定义组件的参数。
```typescript
@Component
struct MyComponent {
private countDownFrom: number = 0;
private color: Color = Color.Blue;
build() {
}
}
@Entry
@Component
struct ParentComponent {
private someColor: Color = Color.Pink;
build() {
Column() {
// 创建MyComponent实例，并将创建MyComponent成员变量countDownFrom初始化为10，将成员变量color初始化为this.someColor
MyComponent({ countDownFrom: 10, color: this.someColor })
}
}
}
```
下面的示例代码将父组件中的函数传递给子组件，并在子组件中调用。
```typescript
@Entry
@Component
struct Parent {
@State cnt: number = 0
submit: () => void = () => {
this.cnt++;
}
build() {
Column() {
Text(`${this.cnt}`)
Son({ submitArrow: this.submit })
}
}
}
@Component
struct Son {
submitArrow?: () => void
build() {
Row() {
Button('add')
.width(80)
.onClick(() => {
if (this.submitArrow) {
this.submitArrow()
}
})
}
.height(56)
}
}
```
build()函数
所有声明在build()函数的语句，我们统称为UI描述，UI描述需要遵循以下规则：
-  @Entry装饰的自定义组件，其build()函数下的根节点唯一且必要，且必须为容器组件，其中ForEach禁止作为根节点。 @Component装饰的自定义组件，其build()函数下的根节点唯一且必要，可以为非容器组件，其中ForEach禁止作为根节点。
```typescript
@Entry
@Component
struct MyComponent {
build() {
// 根节点唯一且必要，必须为容器组件
Row() {
ChildComponent()
}
}
}
@Component
struct ChildComponent {
build() {
// 根节点唯一且必要，可为非容器组件
Image('test.jpg')
}
}
```
-  不允许声明本地变量，反例如下。
```typescript
build() {
// 反例：不允许声明本地变量
let num: number = 1;
}
```
-  不允许在UI描述里直接使用console.info，但允许在方法或者函数里使用，反例如下。
```typescript
build() {
// 反例：不允许console.info
console.info('print debug log');
}
```
-  不允许创建本地的作用域，反例如下。
```typescript
build() {
// 反例：不允许本地作用域
{
// ...
}
}
```
-  不允许调用没有用@Builder装饰的方法，允许系统组件的参数是TS方法的返回值。
```typescript
@Component
struct ParentComponent {
doSomeCalculations() {
}
calcTextValue(): string {
return 'Hello World';
}
@Builder doSomeRender() {
Text(`Hello World`)
}
build() {
Column() {
// 反例：不能调用没有用@Builder装饰的方法
this.doSomeCalculations();
// 正例：可以调用
this.doSomeRender();
// 正例：参数可以为调用TS方法的返回值
Text(this.calcTextValue())
}
}
}
```
-  不允许使用switch语法，如果需要使用条件判断，请使用if。示例如下。
```typescript
build() {
Column() {
// 反例：不允许使用switch语法
switch (expression) {
case 1:
Text('...')
break;
case 2:
Image('...')
break;
default:
Text('...')
break;
}
// 正例：使用if
if(expression == 1) {
Text('...')
} else if(expression == 2) {
Image('...')
} else {
Text('...')
}
}
}
```
-  不允许使用表达式，请使用if组件，示例如下。
```typescript
build() {
Column() {
// 反例：不允许使用表达式
(this.aVar > 10) ? Text('...') : Image('...')
// 正例：使用if判断
if(this.aVar > 10) {
Text('...')
} else {
Image('...')
}
}
}
```
-  不允许直接改变状态变量，反例如下。详细分析见@State常见问题：不允许在build里改状态变量。 在ArkUI状态管理中，状态驱动UI更新。 所以，不能在自定义组件的build()或@Builder方法里直接改变状态变量，这可能会造成循环渲染的风险。Text('${this.count++}')在全量更新或最小化更新会产生不同的影响： build函数中更改应用状态的行为可能会比上面的示例更加隐蔽，比如： 在@Builder，@Extend或@Styles方法内改变状态变量 。 在计算参数时调用函数中改变应用状态变量，例如 Text('${this.calcLabel()}')。 对当前数组做出修改，sort()改变了数组this.arr，随后的filter方法会返回一个新的数组。
```typescript
@Component
struct MyComponent {
@State textColor: Color = Color.Yellow;
@State columnColor: Color = Color.Green;
@State count: number = 1;
build() {
Column() {
// 应避免直接在Text组件内改变count的值
Text(`${this.count++}`)
.width(50)
.height(50)
.fontColor(this.textColor)
.onClick(() => {
this.columnColor = Color.Red;
})
Button("change textColor").onClick(() =>{
this.textColor = Color.Pink;
})
}
.backgroundColor(this.columnColor)
}
}
```
-  在@Builder，@Extend或@Styles方法内改变状态变量 。
-  在计算参数时调用函数中改变应用状态变量，例如 Text('${this.calcLabel()}')。
-  对当前数组做出修改，sort()改变了数组this.arr，随后的filter方法会返回一个新的数组。
```typescript
// 反例
@State arr : Array<...> = [ ... ];
ForEach(this.arr.sort().filter(...),
item => {
// ...
})
// 正确的执行方式为：filter返回一个新数组，后面的sort方法才不会改变原数组this.arr
ForEach(this.arr.filter(...).sort(),
item => {
// ...
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163819.66144087406594732319778942702002:50001231000000:2800:BCF15B2641F8ABDDC58ADEC7A18AF257EB803A4BB9B9792CA8E33CBF20D82542.png)
-  在@Builder，@Extend或@Styles方法内改变状态变量 。
-  在计算参数时调用函数中改变应用状态变量，例如 Text('${this.calcLabel()}')。
-  对当前数组做出修改，sort()改变了数组this.arr，随后的filter方法会返回一个新的数组。
```typescript
// 反例
@State arr : Array<...> = [ ... ];
ForEach(this.arr.sort().filter(...),
item => {
// ...
})
// 正确的执行方式为：filter返回一个新数组，后面的sort方法才不会改变原数组this.arr
ForEach(this.arr.filter(...).sort(),
item => {
// ...
})
```
自定义组件通用样式
自定义组件通过“.”链式调用的形式设置通用样式。
```typescript
@Component
struct ChildComponent {
build() {
Button(`Hello World`)
}
}
@Entry
@Component
struct MyComponent {
build() {
Row() {
ChildComponent()
.width(200)
.height(300)
.backgroundColor(Color.Red)
}
}
}
```
ArkUI给自定义组件设置样式时，相当于给ChildComponent套了一个不可见的容器组件，而这些样式是设置在容器组件上的，而非直接设置给ChildComponent的Button组件。通过渲染结果我们可以很清楚的看到，背景颜色红色并没有直接生效在Button上，而是生效在Button所处的开发者不可见的容器组件上。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-page-custom-components-lifecycle
爬取时间: 2025-04-28 06:52:17
来源: Huawei Developer
在开始之前，我们先明确自定义组件和页面的关系：
-  自定义组件：@Component装饰的UI单元，可以组合多个系统组件实现UI的复用，可以调用组件的生命周期。
-  页面：即应用的UI页面。可以由一个或者多个自定义组件组成，@Entry装饰的自定义组件为页面的入口组件，即页面的根节点，一个页面有且仅能有一个@Entry。只有被@Entry装饰的组件才可以调用页面的生命周期。
页面生命周期，即被@Entry装饰的组件生命周期，提供以下生命周期接口：
-  onPageShow：页面每次显示时触发一次，包括路由过程、应用进入前台等场景。
-  onPageHide：页面每次隐藏时触发一次，包括路由过程、应用进入后台等场景。
-  onBackPress：当用户点击返回按钮时触发。
组件生命周期，即一般用@Component装饰的自定义组件的生命周期，提供以下生命周期接口：
-  aboutToAppear：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。
-  onDidBuild：组件build()函数执行完成之后回调该接口，开发者可以在这个阶段进行埋点数据上报等不影响实际UI的功能。不建议在onDidBuild函数中更改状态变量、使用animateTo等功能，这可能会导致不稳定的UI表现。
-  aboutToDisappear：aboutToDisappear函数在自定义组件析构销毁之前执行。不允许在aboutToDisappear函数中改变状态变量，特别是@Link变量的修改可能会导致应用程序行为不稳定。
生命周期流程如下图所示，下图展示的是被@Entry装饰的组件（页面）生命周期。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163819.42154906943195865088928258477275:50001231000000:2800:0E48F6E8FB03D63D6B4928EF485FF12D330DF5C0BADD75CB759D16D31A8FF757.png)
根据上面的流程图，我们从自定义组件的初始创建、重新渲染和删除来详细解释。
自定义组件的创建和渲染流程
1.  自定义组件的创建：自定义组件的实例由ArkUI框架创建。
2.  初始化自定义组件的成员变量：通过本地默认值或者构造方法传递参数来初始化自定义组件的成员变量，初始化顺序为成员变量的定义顺序。
3.  如果开发者定义了aboutToAppear，则执行aboutToAppear方法。
4.  在首次渲染的时候，执行build方法渲染系统组件，如果子组件为自定义组件，则创建自定义组件的实例。在首次渲染的过程中，框架会记录状态变量和组件的映射关系，当状态变量改变时，驱动其相关的组件刷新。
5.  如果开发者定义了onDidBuild，则执行onDidBuild方法。
自定义组件重新渲染
当事件句柄被触发（比如设置了点击事件，即触发点击事件）改变了状态变量时，或者LocalStorage / AppStorage中的属性更改，并导致绑定的状态变量更改其值时：
1.  框架观察到了变化，将启动重新渲染。
2.  根据框架持有的两个map（自定义组件的创建和渲染流程中第4步），框架可以知道该状态变量管理了哪些UI组件，以及这些UI组件对应的更新函数。执行这些UI组件的更新函数，实现最小化更新。
自定义组件的删除
如果if组件的分支改变，或者ForEach循环渲染中数组的个数改变，组件将被删除：
1.  在删除组件之前，将调用其aboutToDisappear生命周期函数，标记着该节点将要被销毁。ArkUI的节点删除机制是：后端节点直接从组件树上摘下，后端节点被销毁，对前端节点解引用，前端节点已经没有引用时，将被JS虚拟机垃圾回收。
2.  自定义组件和它的变量将被删除，如果其有同步的变量，比如@Link、@Prop、@StorageLink，将从同步源上取消注册。
不建议在生命周期aboutToDisappear内使用async await，如果在生命周期的aboutToDisappear使用异步操作（Promise或者回调方法），自定义组件将被保留在Promise的闭包中，直到回调方法被执行完，这个行为阻止了自定义组件的垃圾回收。
以下示例展示了生命周期的调用时机：
```typescript
// Index.ets
import { router } from '@kit.ArkUI';
@Entry
@Component
struct MyComponent {
@State showChild: boolean = true;
@State btnColor: string = "#FF007DFF";
// 只有被@Entry装饰的组件才可以调用页面的生命周期
onPageShow() {
console.info('Index onPageShow');
}
// 只有被@Entry装饰的组件才可以调用页面的生命周期
onPageHide() {
console.info('Index onPageHide');
}
// 只有被@Entry装饰的组件才可以调用页面的生命周期
onBackPress() {
console.info('Index onBackPress');
this.btnColor = "#FFEE0606";
return true; // 返回true表示页面自己处理返回逻辑，不进行页面路由；返回false表示使用默认的路由返回逻辑，不设置返回值按照false处理
}
// 组件生命周期
aboutToAppear() {
console.info('MyComponent aboutToAppear');
}
// 组件生命周期
onDidBuild() {
console.info('MyComponent onDidBuild');
}
// 组件生命周期
aboutToDisappear() {
console.info('MyComponent aboutToDisappear');
}
build() {
Column() {
// this.showChild为true，创建Child子组件，执行Child aboutToAppear
if (this.showChild) {
Child()
}
Button('delete Child')
.margin(20)
.backgroundColor(this.btnColor)
.onClick(() => {
// 更改this.showChild为false，删除Child子组件，执行Child aboutToDisappear
this.showChild = false;
})
// push到Page页面，执行onPageHide
Button('push to next page')
.onClick(() => {
router.pushUrl({ url: 'pages/Page' });
})
}
}
}
@Component
struct Child {
@State title: string = 'Hello World';
// 组件生命周期
aboutToDisappear() {
console.info('Child aboutToDisappear');
}
// 组件生命周期
onDidBuild() {
console.info('Child onDidBuild');
}
// 组件生命周期
aboutToAppear() {
console.info('Child aboutToAppear');
}
build() {
Text(this.title)
.fontSize(50)
.margin(20)
.onClick(() => {
this.title = 'Hello ArkUI';
})
}
}
```
```typescript
// Page.ets
@Entry
@Component
struct Page {
@State textColor: Color = Color.Black;
@State num: number = 0;
// 只有被@Entry装饰的组件才可以调用页面的生命周期
onPageShow() {
console.info('Page onPageShow');
this.num = 5;
}
// 只有被@Entry装饰的组件才可以调用页面的生命周期
onPageHide() {
console.info('Page onPageHide');
}
// 只有被@Entry装饰的组件才可以调用页面的生命周期
onBackPress() { // 不设置返回值按照false处理
console.info('Page onBackPress');
this.textColor = Color.Grey;
this.num = 0;
}
// 组件生命周期
aboutToAppear() {
console.info('Page aboutToAppear');
this.textColor = Color.Blue;
}
// 组件生命周期
onDidBuild() {
console.info('Page onDidBuild');
}
// 组件生命周期
aboutToDisappear() {
console.info('Page aboutToDisappear');
}
build() {
Column() {
Text(`num 的值为：${this.num}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
.fontColor(this.textColor)
.margin(20)
.onClick(() => {
this.num += 5;
})
}
.width('100%')
}
}
```
以上示例中，Index页面包含两个自定义组件，一个是被@Entry装饰的MyComponent，也是页面的入口组件，即页面的根节点；一个是Child，是MyComponent的子组件。只有@Entry装饰的节点才可以使页面级别的生命周期方法生效，因此在MyComponent中声明当前Index页面的页面生命周期函数（onPageShow / onPageHide / onBackPress）。MyComponent和其子组件Child分别声明了各自的组件级别生命周期函数（aboutToAppear / onDidBuild / aboutToDisappear）。
```typescript
MyComponent aboutToAppear
MyComponent onDidBuild
Child aboutToAppear
Child onDidBuild
Index onPageShow
```
-  点击“delete Child”，if绑定的this.showChild变成false，删除Child组件，会执行Child aboutToDisappear方法。
-  点击“push to next page”，调用router.pushUrl接口，跳转到另外一个页面，当前Index页面隐藏，执行页面生命周期Index onPageHide。此处调用的是router.pushUrl接口，Index页面被隐藏，并没有销毁，所以只调用onPageHide。跳转到新页面后，执行初始化新页面的生命周期的流程。
-  如果调用的是router.replaceUrl，则当前Index页面被销毁，上文已经提到，组件的销毁是从组件树上直接摘下子树，所以执行的生命周期流程将变为：Page aboutToAppear --> Page build --> Page onDidBuild --> Index onPageHide --> Page onPageShow --> MyComponent aboutToDisappear --> Child aboutToDisappear。此时日志输出信息如下：
```typescript
Page aboutToAppear
Page onDidBuild
Index onPageHide
Page onPageShow
MyComponent aboutToDisappear
Child aboutToDisappear
```
```typescript
Index onBackPress
Index onPageHide
```
```typescript
Page onBackPress
Page onPageHide
Index onPageShow
Page aboutToDisappear
```
-  最小化应用或者应用进入后台，触发Index onPageHide。当前Index页面没有被销毁，所以并不会执行组件的aboutToDisappear。应用回到前台，执行Index onPageShow。
-  退出应用，执行Index onPageHide --> MyComponent aboutToDisappear --> Child aboutToDisappear。
自定义组件监听页面生命周期
使用无感监听页面路由的能力，能够实现在自定义组件中监听页面的生命周期。
```typescript
// Index.ets
import { uiObserver, router, UIObserver } from '@kit.ArkUI';
@Entry
@Component
struct Index {
listener: (info: uiObserver.RouterPageInfo) => void = (info: uiObserver.RouterPageInfo) => {
let routerInfo: uiObserver.RouterPageInfo | undefined = this.queryRouterPageInfo();
if (info.pageId == routerInfo?.pageId) {
if (info.state == uiObserver.RouterPageState.ON_PAGE_SHOW) {
console.log(`Index onPageShow`);
} else if (info.state == uiObserver.RouterPageState.ON_PAGE_HIDE) {
console.log(`Index onPageHide`);
}
}
}
aboutToAppear(): void {
let uiObserver: UIObserver = this.getUIContext().getUIObserver();
uiObserver.on('routerPageUpdate', this.listener);
}
aboutToDisappear(): void {
let uiObserver: UIObserver = this.getUIContext().getUIObserver();
uiObserver.off('routerPageUpdate', this.listener);
}
build() {
Column() {
Text(`this page is ${this.queryRouterPageInfo()?.pageId}`)
.fontSize(25)
Button("push self")
.onClick(() => {
router.pushUrl({
url: 'pages/Index'
})
})
Column() {
SubComponent()
}
}
}
}
@Component
struct SubComponent {
listener: (info: uiObserver.RouterPageInfo) => void = (info: uiObserver.RouterPageInfo) => {
let routerInfo: uiObserver.RouterPageInfo | undefined = this.queryRouterPageInfo();
if (info.pageId == routerInfo?.pageId) {
if (info.state == uiObserver.RouterPageState.ON_PAGE_SHOW) {
console.log(`SubComponent onPageShow`);
} else if (info.state == uiObserver.RouterPageState.ON_PAGE_HIDE) {
console.log(`SubComponent onPageHide`);
}
}
}
aboutToAppear(): void {
let uiObserver: UIObserver = this.getUIContext().getUIObserver();
uiObserver.on('routerPageUpdate', this.listener);
}
aboutToDisappear(): void {
let uiObserver: UIObserver = this.getUIContext().getUIObserver();
uiObserver.off('routerPageUpdate', this.listener);
}
build() {
Column() {
Text(`SubComponent`)
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-page-custom-components-layout
爬取时间: 2025-04-28 06:52:30
来源: Huawei Developer
如果需要通过测算的方式布局自定义组件内子组件的位置，建议使用以下接口：
-  onMeasureSize：组件每次布局时触发，计算子组件的尺寸，其执行时间先于onPlaceChildren。
-  onPlaceChildren：组件每次布局时触发，设置子组件的起始位置。
示例：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163819.10559001317973964429010190212156:50001231000000:2800:6B77D62E86FDD9AD8A90C2633CF3A5CC5D73EF66A03DAEE850035804A1A3D266.png)
以上示例中，Index页面包含一个实现了自定义布局的自定义组件，且对应自定义组件的子组件通过index页面内的builder方式传入。
而在自定义组件中，调用了onMeasureSize和onPlaceChildren设置子组件大小和放置位置。例如，在本示例中，在onMeasureSize中初始化组件大小size=100，后续的每一个子组件size会加上上一个子组件大小的一半，实现组件大小递增的效果。而在onPlaceChildren中，定义startPos=300，设置每一个子组件的位置为startPos减去子组件自身的高度，所有子组件右下角一致在顶点位置(300,300)，实现一个从右下角开始展示组件的类Stack组件。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-custom-components-access-restrictions
爬取时间: 2025-04-28 06:52:44
来源: Huawei Developer
在状态管理V1中，当组件开发者封装了自定义组件后，由于组件没有明确的输入输出标识，使得调用方无法按照统一的标准判断传入哪些变量作为组件入参。在状态管理V1中，可以使用private限定符来限制当前变量不允许被进行外部初始化。
当组件开发者不希望状态变量被外部初始化时，可以添加private限定符，提醒组件调用方不要初始化该状态变量。但是外部初始化也需要遵循装饰器自身的规则，具体规则见使用限制。
ArkTS会对自定义组件的成员变量使用的访问限定符private/public/protected进行校验，当不按规范使用访问限定符private/public/protected时，会产生对应的日志信息。
在阅读本文档前，建议提前阅读：状态管理概述。
从API version 12开始，支持自定义组件成员属性访问限定符使用限制的规则。
使用限制
-  @State/@Prop/@Provide/@BuilderParam/常规成员变量(不涉及更新的普通变量)的初始化规则为可以被外部初始化，也可以使用本地值进行初始化。当组件开发者不希望当前变量被外部初始化时，可以使用private进行修饰，此时会有编译告警日志提示。
-  @StorageLink/@StorageProp/@LocalStorageLink/@LocalStorageProp/@Consume变量的初始化规则为不可以被外部初始化，当组件开发者希望当前变量被外部初始化而使用public修饰时，这和装饰器本身的初始化规则是相违背的，会有编译告警日志提示。
-  @Link/@ObjectLink变量的初始化规则为必须被外部初始化，禁止本地初始化。当组件开发者使用private对变量进行修饰时，这和装饰器本身的初始化规则相矛盾，会有编译告警日志提示。
-  由于struct没有继承能力，上述所有的这些变量使用protected修饰时，会有编译告警日志提示。
-  @Require含义是当前被@Require装饰的变量必须被外部初始化，当@Require和private同时装饰@State/@Prop/@Provide/@BuilderParam/常规成员变量(不涉及更新的普通变量)时，他们的含义是自相矛盾的，会有编译告警日志提示。
使用场景
1.当成员变量被private访问限定符和@State/@Prop/@Provide/@BuilderParam装饰器同时修饰，并且通过父组件进行初始化赋值，ArkTS会进行校验并产生告警日志。
【反例】
```typescript
@Entry
@Component
struct AccessRestrictions {
@Builder
buildTest() {
Text("Parent builder")
}
build() {
Column() {
ComponentsChild({
state_value: "Hello",
prop_value: "Hello",
provide_value: "Hello",
builder_value: this.buildTest,
regular_value: "Hello"
})
}
.width('100%')
}
}
@Component
struct ComponentsChild {
// 此处使用private修饰符时会出现告警日志
@State private state_value: string = "Hello";
// 此处使用private修饰符时会出现告警日志
@Prop private prop_value: string = "Hello";
// 此处使用private修饰符时会出现告警日志
@Provide private provide_value: string = "Hello";
// 此处使用private修饰符时会出现告警日志
@BuilderParam private builder_value: () => void = this.buildTest;
// 此处使用private修饰符时会出现告警日志
private regular_value: string = "Hello";
@Builder
buildTest() {
Text("Child builder")
}
build() {
Column() {
Text("Hello")
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
}
}
```
编译告警日志如下：
```typescript
Property 'state_value' is private and can not be initialized through the component constructor.
Property 'prop_value' is private and can not be initialized through the component constructor.
Property 'provide_value' is private and can not be initialized through the component constructor.
Property 'builder_value' is private and can not be initialized through the component constructor.
Property 'regular_value' is private and can not be initialized through the component constructor.
```
【正例】
```typescript
@Entry
@Component
struct AccessRestrictions {
@Builder
buildTest() {
Text("Parent builder")
}
build() {
Column() {
ComponentsChild({
state_value: "Hello",
prop_value: "Hello",
provide_value: "Hello",
builder_value: this.buildTest,
regular_value: "Hello"
})
}
.width('100%')
}
}
@Component
struct ComponentsChild {
@State state_value: string = "Hello";
@Prop prop_value: string = "Hello";
@Provide provide_value: string = "Hello";
@BuilderParam builder_value: () => void = this.buildTest;
regular_value: string = "Hello";
@Builder
buildTest() {
Text("Child builder")
}
build() {
Column() {
Text("Hello")
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
}
}
```
2.当成员变量被public访问限定符和@StorageLink/@StorageProp/@LocalStorageLink/@LocalStorageProp/@Consume装饰器同时修饰，并且通过父组件进行初始化赋值，ArkTS会进行校验并产生告警日志。
【反例】
```typescript
@Entry
@Component
struct AccessRestrictions {
@Provide consume_value: string = "Hello";
build() {
Column() {
ComponentChild()
}
.width('100%')
}
}
@Component
struct ComponentChild {
// 此处使用public修饰符时会出现告警日志
@LocalStorageProp("sessionLocalProp") public local_prop_value: string = "Hello";
// 此处使用public修饰符时会出现告警日志
@LocalStorageLink("sessionLocalLink") public local_link_value: string = "Hello";
// 此处使用public修饰符时会出现告警日志
@StorageProp("sessionProp") public storage_prop_value: string = "Hello";
// 此处使用public修饰符时会出现告警日志
@StorageLink("sessionLink") public storage_link_value: string = "Hello";
// 此处使用public修饰符时会出现告警日志
@Consume public consume_value: string;
build() {
Column() {
Text("Hello")
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
}
}
```
编译告警日志如下：
```typescript
Property 'local_prop_value' can not be decorated with both @LocalStorageProp and public.
Property 'local_link_value' can not be decorated with both @LocalStorageLink and public.
Property 'storage_prop_value' can not be decorated with both @StorageProp and public.
Property 'storage_link_value' can not be decorated with both @StorageLink and public.
Property 'consume_value' can not be decorated with both @Consume and public.
```
【正例】
```typescript
@Entry
@Component
struct AccessRestrictions {
@Provide consume_value: string = "Hello";
build() {
Column() {
ComponentChild()
}
.width('100%')
}
}
@Component
struct ComponentChild {
@LocalStorageProp("sessionLocalProp") local_prop_value: string = "Hello";
@LocalStorageLink("sessionLocalLink") local_link_value: string = "Hello";
@StorageProp("sessionProp") storage_prop_value: string = "Hello";
@StorageLink("sessionLink") storage_link_value: string = "Hello";
@Consume consume_value: string;
build() {
Column() {
Text("Hello")
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
}
}
```
3.当成员变量被private访问限定符和@Link/@ObjectLink装饰器同时修饰，并且通过父组件进行初始化赋值，ArkTS会进行校验并产生告警日志。
【反例】
```typescript
@Entry
@Component
struct AccessRestrictions {
@State link_value: string = "Hello";
@State objectLink_value: ComponentObj = new ComponentObj();
build() {
Column() {
ComponentChild({link_value: this.link_value, objectLink_value: this.objectLink_value})
}
.width('100%')
}
}
@Observed
class ComponentObj {
count: number = 0;
}
@Component
struct ComponentChild {
// 此处使用private修饰符时会出现告警日志
@Link private link_value: string;
// 此处使用private修饰符时会出现告警日志
@ObjectLink private objectLink_value: ComponentObj;
build() {
Column() {
Text("Hello")
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
}
}
```
编译告警日志如下：
```typescript
Property 'link_value' can not be decorated with both @Link and private.
Property 'objectLink_value' can not be decorated with both @ObjectLink and private.
```
【正例】
```typescript
@Entry
@Component
struct AccessRestrictions {
@State link_value: string = "Hello";
@State objectLink_value: ComponentObj = new ComponentObj();
build() {
Column() {
ComponentChild({link_value: this.link_value, objectLink_value: this.objectLink_value})
}
.width('100%')
}
}
@Observed
class ComponentObj {
count: number = 0;
}
@Component
struct ComponentChild {
@Link link_value: string;
@ObjectLink objectLink_value: ComponentObj;
build() {
Column() {
Text("Hello")
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
}
}
```
4.当成员变量被protected访问限定符修饰，并且通过父组件进行初始化赋值，ArkTS会进行校验并产生告警日志。
【反例】
```typescript
@Entry
@Component
struct AccessRestrictions {
build() {
Column() {
ComponentChild({regular_value: "Hello"})
}
.width('100%')
}
}
@Component
struct ComponentChild {
// 此处使用protected修饰符时会出现告警日志
protected regular_value: string = "Hello";
build() {
Column() {
Text("Hello")
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
}
}
```
编译告警日志如下：
```typescript
The member attributes of a struct can not be protected.
```
【正例】
```typescript
@Entry
@Component
struct AccessRestrictions {
build() {
Column() {
ComponentChild({regular_value: "Hello"})
}
.width('100%')
}
}
@Component
struct ComponentChild {
regular_value: string = "Hello";
build() {
Column() {
Text("Hello")
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
}
}
```
5.当成员变量被private访问限定符、@Require和@State/@Prop/@Provide/@BuilderParam装饰器同时修饰，并且通过父组件进行初始化赋值，ArkTS会进行校验并产生告警日志。
【反例】
```typescript
@Entry
@Component
struct AccessRestrictions {
build() {
Column() {
ComponentChild({prop_value: "Hello"})
}
.width('100%')
}
}
@Component
struct ComponentChild {
// 此处使用private修饰符时会出现告警日志
@Require @Prop private prop_value: string = "Hello";
build() {
Column() {
Text("Hello")
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
}
}
```
编译告警日志如下：
```typescript
Property 'prop_value' can not be decorated with both @Require and private.
Property 'prop_value' is private and can not be initialized through the component constructor.
```
【正例】
```typescript
@Entry
@Component
struct AccessRestrictions {
build() {
Column() {
ComponentChild({prop_value: "Hello"})
}
.width('100%')
}
}
@Component
struct ComponentChild {
@Require @Prop prop_value: string = "Hello";
build() {
Column() {
Text("Hello")
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-builder
爬取时间: 2025-04-28 06:52:57
来源: Huawei Developer
ArkUI提供了一种轻量的UI元素复用机制@Builder，其内部UI结构固定，仅与使用方进行数据传递，开发者可以将重复使用的UI元素抽象成一个方法，在build方法里调用。
为了简化语言，我们将@Builder装饰的函数也称为“自定义构建函数”。
在阅读本文档前，建议提前阅读：基本语法概述，声明式UI描述，自定义组件-创建自定义组件。
从API version 9开始，该装饰器支持在ArkTS卡片中使用。
从API version 11开始，该装饰器支持在元服务中使用。
装饰器使用说明
@Builder装饰器有两种使用方式，分别是定义在自定义组件内部的私有自定义构建函数和定义在全局的全局自定义构建函数。
私有自定义构建函数
定义的语法：
```typescript
@Entry
@Component
struct BuilderDemo {
@Builder
showTextBuilder() {
Text('Hello World')
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
@Builder
showTextValueBuilder(param: string) {
Text(param)
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
build() {
Column() {
// 无参数
this.showTextBuilder()
// 有参数
this.showTextValueBuilder('Hello @Builder')
}
}
}
```
使用方法：
```typescript
this.showTextBuilder()
```
-  允许在自定义组件内定义一个或多个@Builder方法，该方法被认为是该组件的私有、特殊类型的成员函数。
-  私有自定义构建函数允许在自定义组件内、build方法和其他自定义构建函数中调用。
-  在自定义函数体中，this指代当前所属组件，组件的状态变量可以在自定义构建函数内访问。建议通过this访问自定义组件的状态变量而不是参数传递。
全局自定义构建函数
定义的语法：
```typescript
@Builder
function showTextBuilder() {
Text('Hello World')
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
@Entry
@Component
struct BuilderDemo {
build() {
Column() {
showTextBuilder()
}
}
}
```
使用方法：
```typescript
showTextBuilder()
```
-  如果不涉及组件状态变化，建议使用全局的自定义构建方法。
-  全局自定义构建函数允许在build方法和其他自定义构建函数中调用。
参数传递规则
自定义构建函数的参数传递有按值传递和按引用传递两种，均需遵守以下规则：
-  参数的类型必须与参数声明的类型一致，不允许undefined、null和返回undefined、null的表达式。
-  在@Builder修饰的函数内部，不允许改变参数值。
-  @Builder内UI语法遵循UI语法规则。
-  只有传入一个参数，且参数需要直接传入对象字面量才会按引用传递该参数，其余传递方式均为按值传递。
按值传递参数
调用@Builder装饰的函数默认按值传递。当传递的参数为状态变量时，状态变量的改变不会引起@Builder方法内的UI刷新。所以当使用状态变量的时候，推荐使用按引用传递。
```typescript
@Builder function overBuilder(paramA1: string) {
Row() {
Text(`UseStateVarByValue: ${paramA1} `)
}
}
@Entry
@Component
struct Parent {
@State label: string = 'Hello';
build() {
Column() {
overBuilder(this.label)
}
}
}
```
按引用传递参数
按引用传递参数时，传递的参数可为状态变量，且状态变量的改变会引起@Builder方法内的UI刷新。
```typescript
class Tmp {
paramA1: string = '';
}
@Builder function overBuilder(params: Tmp) {
Row() {
Text(`UseStateVarByReference: ${params.paramA1} `)
}
}
@Entry
@Component
struct Parent {
@State label: string = 'Hello';
build() {
Column() {
// 在父组件中调用overBuilder组件时，
// 把this.label通过引用传递的方式传给overBuilder组件。
overBuilder({ paramA1: this.label })
Button('Click me').onClick(() => {
// 单击Click me后，UI文本从Hello更改为ArkUI。
this.label = 'ArkUI';
})
}
}
}
```
限制条件
1.  @Builder装饰的函数内部，不允许修改参数值，否则框架会抛出运行时错误。开发者可以在调用@Builder的自定义组件里改变其参数。请参考在@Builder装饰的函数内部修改入参内容。
2.  @Builder通过按引用传递的方式传入参数，才会触发动态渲染UI，并且参数只能是一个。请参考按引用传递参数。
3.  @Builder如果传入的参数是两个或两个以上，不会触发动态渲染UI。请参考@Builder存在两个或者两个以上参数。
4.  @Builder传入的参数中同时包含按值传递和按引用传递两种方式，不会触发动态渲染UI。请参考@Builder存在两个或者两个以上参数。
5.  @Builder的参数必须按照对象字面量的形式，把所需要的属性一一传入，才会触发动态渲染UI。请参考@Builder存在两个或者两个以上参数。
使用场景
自定义组件内使用自定义构建函数
创建私有的@Builder方法，在Column里面使用this.builder()方式调用，通过aboutToAppear生命周期函数和按钮的点击事件改变builder_value的内容，实现动态渲染UI。
```typescript
@Entry
@Component
struct PrivateBuilder {
@State builder_value: string = 'Hello';
@Builder builder() {
Column(){
Text(this.builder_value)
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
}
aboutToAppear(): void {
setTimeout(() => {
this.builder_value = 'Hello World';
},3000)
}
build() {
Row() {
Column() {
Text(this.builder_value)
.fontSize(30)
.fontWeight(FontWeight.Bold)
this.builder()
Button('点击改变builder_value内容')
.onClick(() => {
this.builder_value ='builder_value被点击了';
})
}
}
}
}
```
使用全局自定义构建函数
创建全局的@Builder方法，在Column里面使用overBuilder()方式调用，通过以对象字面量的形式传递参数，无论是简单类型还是复杂类型，值的改变都会引起UI界面的刷新。
```typescript
class ChildTmp {
val: number = 1;
}
class Tmp {
str_value: string = 'Hello';
num_value: number = 0;
tmp_value: ChildTmp = new ChildTmp();
arrayTmp_value: Array<ChildTmp> = [];
}
@Builder function overBuilder(param: Tmp) {
Column() {
Text(`str_value: ${param.str_value}`)
Text(`num_value: ${param.num_value}`)
Text(`tmp_value: ${param.tmp_value.val}`)
ForEach(param.arrayTmp_value, (item: ChildTmp) => {
Text(`arrayTmp_value: ${item.val}`)
}, (item: ChildTmp) => JSON.stringify(item))
}
}
@Entry
@Component
struct Parent {
@State objParam: Tmp = new Tmp();
build() {
Column() {
Text('通过调用@Builder渲染UI界面')
.fontSize(20)
overBuilder({str_value: this.objParam.str_value, num_value: this.objParam.num_value,
tmp_value: this.objParam.tmp_value, arrayTmp_value: this.objParam.arrayTmp_value})
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
Button('点击改变参数值').onClick(() => {
this.objParam.str_value = 'Hello World';
this.objParam.num_value = 1;
this.objParam.tmp_value.val = 8;
const child_value: ChildTmp = {
val: 2
}
this.objParam.arrayTmp_value.push(child_value)
})
}
}
}
```
修改装饰器修饰的变量触发UI刷新
此种场景@Builder只是用来展示Text组件，没有参与动态UI刷新的功能，Text组件中值的变化是使用了装饰器的特性，监听到值的改变触发的UI刷新，而不是通过@Builder的能力触发的。
```typescript
class Tmp {
str_value: string = 'Hello';
}
@Entry
@Component
struct Parent {
@State objParam: Tmp = new Tmp();
@State label: string = 'World';
@Builder privateBuilder() {
Column() {
Text(`wrapBuilder str_value: ${this.objParam.str_value}`)
Text(`wrapBuilder num: ${this.label}`)
}
}
build() {
Column() {
Text('通过调用@Builder渲染UI界面')
.fontSize(20)
this.privateBuilder()
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
Button('点击改变参数值').onClick(() => {
this.objParam.str_value = 'str_value Hello World';
this.label = 'label Hello World'
})
}
}
}
```
使用全局和局部的@Builder传入customBuilder类型
当某个参数类型为customBuilder的时候，可以把定义的@Builder函数传入，因为customBuilder实际是一个Function(() => any)或者是void类型，而@Builder实际也是一个Function类型。此场景中通过把@Builder传入已实现特定的效果。
```typescript
@Builder
function overBuilder() {
Row() {
Text('全局 Builder')
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
}
@Entry
@Component
struct customBuilderDemo {
@State arr: number[] = [0, 1, 2, 3, 4];
@Builder
privateBuilder() {
Row() {
Text('局部 Builder')
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
}
build() {
Column() {
List({ space: 10 }) {
ForEach(this.arr, (item: number) => {
ListItem() {
Text(`${item}`)
.width('100%')
.height(100)
.fontSize(16)
.textAlign(TextAlign.Center)
.borderRadius(10)
.backgroundColor(0xFFFFFF)
}
.swipeAction({
start: {
builder: overBuilder()
},
end: {
builder: () => {
this.privateBuilder()
}
}
})
}, (item: number) => JSON.stringify(item))
}
}
}
}
```
多层@Builder方法嵌套使用
在@Builder方法内调用自定义组件或者其他@Builder方法，以实现多个@Builder嵌套使用的场景，要想实现最里面的@Builder动态UI刷新功能，必须要保证每层调用@Builder的地方使用按引用传递的方式。这里的$$也可以换成其他名称，$$不是必须的参数形式。
```typescript
class Tmp {
paramA1: string = '';
}
@Builder function parentBuilder($$: Tmp) {
Row() {
Column() {
Text(`parentBuilder===${$$.paramA1}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
HelloComponent({message: $$.paramA1})
childBuilder({paramA1: $$.paramA1})
}
}
}
@Component
struct HelloComponent {
@Prop message: string = '';
build() {
Row() {
Text(`HelloComponent===${this.message}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
}
}
@Builder
function childBuilder($$: Tmp) {
Row() {
Column() {
Text(`childBuilder===${$$.paramA1}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
HelloChildComponent({message: $$.paramA1})
grandsonBuilder({paramA1: $$.paramA1})
}
}
}
@Component
struct HelloChildComponent {
@Prop message: string = '';
build() {
Row() {
Text(`HelloChildComponent===${this.message}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
}
}
@Builder function grandsonBuilder($$: Tmp) {
Row() {
Column() {
Text(`grandsonBuilder===${$$.paramA1}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
HelloGrandsonComponent({message: $$.paramA1})
}
}
}
@Component
struct HelloGrandsonComponent {
@Prop message: string;
build() {
Row() {
Text(`HelloGrandsonComponent===${this.message}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
}
}
@Entry
@Component
struct Parent {
@State label: string = 'Hello';
build() {
Column() {
parentBuilder({paramA1: this.label})
Button('Click me').onClick(() => {
this.label = 'ArkUI';
})
}
}
}
```
@Builder函数联合V2装饰器使用
使用全局@Builder和局部@Builder在@ComponentV2修饰的自定义组件中调用，配合@ObservedV2和@Trace装饰器来监听具体值的变化，以达到触发UI刷新的功能。
```typescript
@ObservedV2
class Info {
@Trace name: string = '';
@Trace age: number = 0;
}
@Builder
function overBuilder(param: Info) {
Column() {
Text(`全局@Builder name :${param.name}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
Text(`全局@Builder age :${param.age}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
}
@ComponentV2
struct ChildPage {
@Require @Param childInfo: Info;
build() {
overBuilder({name: this.childInfo.name, age: this.childInfo.age})
}
}
@Entry
@ComponentV2
struct ParentPage {
info1: Info = { name: "Tom", age: 25 };
@Local info2: Info = { name: "Tom", age: 25 };
@Builder
privateBuilder() {
Column() {
Text(`局部@Builder name :${this.info1.name}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
Text(`局部@Builder age :${this.info1.age}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
}
build() {
Column() {
Text(`info1: ${this.info1.name}  ${this.info1.age}`) // Text1
.fontSize(30)
.fontWeight(FontWeight.Bold)
this.privateBuilder() // 调用局部@Builder
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
Text(`info2: ${this.info2.name}  ${this.info2.age}`) // Text2
.fontSize(30)
.fontWeight(FontWeight.Bold)
overBuilder({ name: this.info2.name, age: this.info2.age}) // 调用全局@Builder
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
Text(`info1: ${this.info1.name}  ${this.info1.age}`) // Text1
.fontSize(30)
.fontWeight(FontWeight.Bold)
ChildPage({ childInfo: this.info1}) // 调用自定义组件
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
Text(`info2: ${this.info2.name}  ${this.info2.age}`) // Text2
.fontSize(30)
.fontWeight(FontWeight.Bold)
ChildPage({ childInfo: this.info2}) // 调用自定义组件
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
Button("change info1&info2")
.onClick(() => {
this.info1 = { name: "Cat", age: 18}; // Text1不会刷新，原因是没有装饰器修饰监听不到值的改变。
this.info2 = { name: "Cat", age: 18}; // Text2会刷新，原因是有装饰器修饰，可以监听到值的改变。
})
}
}
}
```
常见问题
@Builder存在两个或者两个以上参数
当参数存在两个或者两个以上的时候，就算通过对象字面量的形式传递，值的改变也不会引起UI刷新。
【反例】
```typescript
class GlobalTmp {
str_value: string = 'Hello';
}
@Builder function overBuilder(param: GlobalTmp, num: number) {
Column() {
Text(`str_value: ${param.str_value}`)
Text(`num: ${num}`)
}
}
@Entry
@Component
struct Parent {
@State objParam: GlobalTmp = new GlobalTmp();
@State num: number = 0;
build() {
Column() {
Text('通过调用@Builder渲染UI界面')
.fontSize(20)
// 使用了两个参数，用法错误。
overBuilder({str_value: this.objParam.str_value}, this.num)
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
Button('点击改变参数值').onClick(() => {
this.objParam.str_value = 'Hello World';
this.num = 1;
})
}
}
}
```
【反例】
```typescript
class GlobalTmp {
str_value: string = 'Hello';
}
class SecondTmp {
num_value: number = 0;
}
@Builder function overBuilder(param: GlobalTmp, num: SecondTmp) {
Column() {
Text(`str_value: ${param.str_value}`)
Text(`num: ${num.num_value}`)
}
}
@Entry
@Component
struct Parent {
@State strParam: GlobalTmp = new GlobalTmp();
@State numParam: SecondTmp = new SecondTmp();
build() {
Column() {
Text('通过调用@Builder渲染UI界面')
.fontSize(20)
// 使用了两个参数，用法错误。
overBuilder({str_value: this.strParam.str_value}, {num_value: this.numParam.num_value})
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
Button('点击改变参数值').onClick(() => {
this.strParam.str_value = 'Hello World';
this.numParam.num_value = 1;
})
}
}
}
```
@Builder只接受一个参数，当传入一个参数的时候，通过对象字面量的形式传递，值的改变会引起UI的刷新。
【正例】
```typescript
class GlobalTmp {
str_value: string = 'Hello';
num_value: number = 0;
}
@Builder function overBuilder(param: GlobalTmp) {
Column() {
Text(`str_value: ${param.str_value}`)
Text(`num: ${param.num_value}`)
}
}
@Entry
@Component
struct Parent {
@State objParam: GlobalTmp = new GlobalTmp();
build() {
Column() {
Text('通过调用@Builder渲染UI界面')
.fontSize(20)
overBuilder({str_value: this.objParam.str_value, num_value: this.objParam.num_value})
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
Button('点击改变参数值').onClick(() => {
this.objParam.str_value = 'Hello World';
this.objParam.num_value = 1;
})
}
}
}
```
使用@ComponentV2装饰器触发动态刷新
使用按值传递的方式，在@ComponentV2装饰器修饰的自定义组件里配合使用@ObservedV2和@Trace装饰器可以实现刷新UI功能。
【反例】
在@ComponentV2装饰的自定义组件中，使用简单数据类型不可以触发UI的刷新。
```typescript
@ObservedV2
class ParamTmp {
@Trace count : number = 0;
}
@Builder
function renderNumber(paramNum: number) {
Text(`paramNum : ${paramNum}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
@Entry
@ComponentV2
struct PageBuilder {
@Local class_value: ParamTmp = new ParamTmp();
// 此处使用简单数据类型不支持刷新UI的能力。
@Local num_value: number = 0;
private progressTimer: number = -1;
aboutToAppear(): void {
this.progressTimer = setInterval(() => {
if (this.class_value.count < 100) {
this.class_value.count += 5;
this.num_value += 5;
} else {
clearInterval(this.progressTimer);
}
}, 500);
}
build() {
Column() {
renderNumber(this.num_value)
}
.width('100%')
.height('100%')
.padding(50)
}
}
```
【正例】
在@ComponentV2装饰中，只有使用@ObservedV2修饰的ParamTmp类和@Trace修饰的count属性才可以触发UI的刷新。
```typescript
@ObservedV2
class ParamTmp {
@Trace count : number = 0;
}
@Builder
function renderText(param: ParamTmp) {
Column() {
Text(`param : ${param.count}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
@Builder
function renderMap(paramMap: Map<string,number>) {
Text(`paramMap : ${paramMap.get('name')}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
@Builder
function renderSet(paramSet: Set<number>) {
Text(`paramSet : ${paramSet.size}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
@Builder
function renderNumberArr(paramNumArr: number[]) {
Text(`paramNumArr : ${paramNumArr[0]}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
@Entry
@ComponentV2
struct PageBuilder {
@Local builderParams: ParamTmp = new ParamTmp();
@Local map_value: Map<string,number> = new Map();
@Local set_value: Set<number> = new Set([0]);
@Local numArr_value: number[] = [0];
private progressTimer: number = -1;
aboutToAppear(): void {
this.progressTimer = setInterval(() => {
if (this.builderParams.count < 100) {
this.builderParams.count += 5;
this.map_value.set('name', this.builderParams.count);
this.set_value.add(this.builderParams.count);
this.numArr_value[0] = this.builderParams.count;
} else {
clearInterval(this.progressTimer);
}
}, 500);
}
@Builder
localBuilder() {
Column() {
Text(`localBuilder : ${this.builderParams.count}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
build() {
Column() {
this.localBuilder()
Text(`builderParams :${this.builderParams.count}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
renderText(this.builderParams)
renderText({ count: this.builderParams.count })
renderMap(this.map_value)
renderSet(this.set_value)
renderNumberArr(this.numArr_value)
}
.width('100%')
.height('100%')
}
}
```
在@Builder装饰的函数内部修改入参内容
【反例】
```typescript
interface Temp {
paramA: string;
}
@Builder function overBuilder(param: Temp) {
Row() {
Column() {
Button(`overBuilder === ${param.paramA}`)
.onClick(() => {
// 错误写法，不允许在@Builder装饰的函数内部修改参数值
param.paramA = 'Yes';
})
}
}
}
@Entry
@Component
struct Parent {
@State label: string = 'Hello';
build() {
Column() {
overBuilder({paramA: this.label})
Button('click me')
.onClick(() => {
this.label = 'ArkUI';
})
}
}
}
```
【正例】
```typescript
interface Temp {
paramA: string;
}
@Builder function overBuilder(param: Temp) {
Row() {
Column() {
Button(`overBuilder === ${param.paramA}`)
}
}
}
@Entry
@Component
struct Parent {
@State label: string = 'Hello';
build() {
Column() {
overBuilder({paramA: this.label})
Button('click me')
.onClick(() => {
this.label = 'ArkUI';
})
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-localbuilder
爬取时间: 2025-04-28 06:53:11
来源: Huawei Developer
当开发者使用@Builder做引用数据传递时，会考虑组件的父子关系，使用了bind(this)之后，组件的父子关系和状态管理的父子关系并不一致。为了解决组件的父子关系和状态管理的父子关系保持一致的问题，引入@LocalBuilder装饰器。@LocalBuilder拥有和局部@Builder相同的功能，且比局部@Builder能够更好的确定组件的父子关系和状态管理的父子关系。
在阅读本文档前，建议提前阅读：@Builder。
从API version 12开始支持。
装饰器使用说明
自定义组件内自定义构建函数
定义的语法：
```typescript
@LocalBuilder MyBuilderFunction() { ... }
```
使用方法：
```typescript
this.MyBuilderFunction()
```
限制条件
-  @LocalBuilder只能在所属组件内声明，不允许全局声明。
-  @LocalBuilder不能被内置装饰器和自定义装饰器使用。
-  自定义组件内的静态方法不能和@LocalBuilder一起使用。
@LocalBuilder和局部@Builder使用区别
@Builder方法引用传参时，为了改变this指向，使用bind(this)后，会导致组件的父子关系和状态管理的父子关系不一致，但是@LocalBuilder是否使用bind(this)，都不会改变组件的父子关系。@LocalBuilder和@Builder区别说明。
参数传递规则
@LocalBuilder函数的参数传递有按值传递和按引用传递两种，均需遵守以下规则：
-  参数的类型必须与参数声明的类型一致，不允许undefined、null和返回undefined、null的表达式。
-  在@LocalBuilder修饰的函数内部，不允许改变参数值。
-  @LocalBuilder内UI语法遵循UI语法规则。
-  只有传入一个参数，且参数需要直接传入对象字面量才会按引用传递该参数，其余传递方式均为按值传递。
按引用传递参数
按引用传递参数时，传递的参数可为状态变量，且状态变量的改变会引起@LocalBuilder方法内的UI刷新。
特别说明，若@LocalBuilder函数和$$参数一起使用，子组件调用父组件的@LocalBuilder函数，传入的参数发生变化，不会引起@LocalBuilder方法内的UI刷新。
使用场景：
组件Parent内的@LocalBuilder方法在build函数内调用，按键值对写法进行传值，当点击Click me 时，@LocalBuilder内的Text文本内容会随着状态变量内容的改变而改变。
```typescript
class ReferenceType {
paramString: string = '';
}
@Entry
@Component
struct Parent {
@State variableValue: string = 'Hello World';
@LocalBuilder
citeLocalBuilder(params: ReferenceType) {
Row() {
Text(`UseStateVarByReference: ${params.paramString}`)
}
};
build() {
Column() {
this.citeLocalBuilder({ paramString: this.variableValue })
Button('Click me').onClick(() => {
this.variableValue = 'Hi World';
})
}
}
}
```
按引用传递参数时，如果在@LocalBuilder方法内调用自定义组件，ArkUI提供$$作为按引用传递参数的范式。
使用场景：
组件Parent内的@LocalBuilder方法内调用自定义组件，且按照引用传递参数将值传递到自定义组件，当Parent组件内状态变量值发生变化时，@LocalBuilder方法内的自定义组件HelloComponent的message值也会发生变化。
```typescript
class ReferenceType {
paramString: string = '';
}
@Component
struct HelloComponent {
@Prop message: string;
build() {
Row() {
Text(`HelloComponent===${this.message}`)
}
}
}
@Entry
@Component
struct Parent {
@State variableValue: string = 'Hello World';
@LocalBuilder
citeLocalBuilder($$: ReferenceType) {
Row() {
Column() {
Text(`citeLocalBuilder===${$$.paramString}`)
HelloComponent({ message: $$.paramString })
}
}
}
build() {
Column() {
this.citeLocalBuilder({ paramString: this.variableValue })
Button('Click me').onClick(() => {
this.variableValue = 'Hi World';
})
}
}
}
```
子组件引用父组件的@LocalBuilder函数，传入的参数为状态变量，状态变量的改变不会引发@LocalBuilder方法内的UI刷新，原因是@Localbuilder装饰的函数绑定在父组件上，状态变量刷新机制是刷新本组件以及其子组件，对父组件无影响，故无法引发刷新。若使用@Builder修饰则可引发刷新，原因是@Builder改变了函数的this指向，此时函数被绑定到子组件上，故能引发UI刷新。
使用场景：
组件Child将状态变量传递到Parent的@Builder和@LocalBuilder函数内，在@Builder的函数内，this指向Child，参数变化能引发UI刷新，在@LocalBuilder函数内，this指向Parent，参数变化不能引发UI刷新。若@LocalBuilder函数内引用Parent的状态变量发生变化，UI能正常刷新。
```typescript
class Data {
size: number = 0;
}
@Entry
@Component
struct Parent {
label: string = 'parent';
@State data: Data = new Data();
@Builder
componentBuilder($$: Data) {
Text(`builder + $$`)
Text(`${'this -> ' + this.label}`)
Text(`${'size : ' + $$.size}`)
Text(`------------------------`)
}
@LocalBuilder
componentLocalBuilder($$: Data) {
Text(`LocalBuilder + $$ data`)
Text(`${'this -> ' + this.label}`)
Text(`${'size : ' + $$.size}`)
Text(`------------------------`)
}
@LocalBuilder
contentLocalBuilderNoArgument() {
Text(`LocalBuilder + local data`)
Text(`${'this -> ' + this.label}`)
Text(`${'size : ' + this.data.size}`)
Text(`------------------------`)
}
build() {
Column() {
Child({
contentBuilder: this.componentBuilder,
contentLocalBuilder: this.componentLocalBuilder,
contentLocalBuilderNoArgument: this.contentLocalBuilderNoArgument,
data: this.data
})
}
}
}
@Component
struct Child {
label: string = 'child';
@Builder customBuilder() {};
@BuilderParam contentBuilder: ((data: Data) => void) = this.customBuilder;
@BuilderParam contentLocalBuilder: ((data: Data) => void) = this.customBuilder;
@BuilderParam contentLocalBuilderNoArgument: (() => void) = this.customBuilder;
@Link data: Data;
build() {
Column() {
this.contentBuilder({ size: this.data.size })
this.contentLocalBuilder({ size: this.data.size })
this.contentLocalBuilderNoArgument()
Button("add child size").onClick(() => {
this.data.size += 1;
})
}
}
}
```
按值传递参数
调用@LocalBuilder装饰的函数默认按值传递。当传递的参数为状态变量时，状态变量的改变不会引起@LocalBuilder方法内的UI刷新。所以当使用状态变量的时候，推荐使用按引用传递。
使用场景：
组件Parent将@State修饰的label值按照函数传参方式传递到@LocalBuilder函数内，此时@LocalBuilder函数获取到的值为普通变量值，所以改变@State修饰的label值时，@LocalBuilder函数内的值不会发生改变。
```typescript
@Entry
@Component
struct Parent {
@State label: string = 'Hello';
@LocalBuilder
citeLocalBuilder(paramA1: string) {
Row() {
Text(`UseStateVarByValue: ${paramA1}`)
}
}
build() {
Column() {
this.citeLocalBuilder(this.label)
}
}
}
```
@LocalBuilder和@Builder区别说明
函数componentBuilder被@Builder修饰时，显示效果是 “Child”，函数componentBuilder被@LocalBuilder修饰时，显示效果是“Parent”。
说明：
@Builder componentBuilder()通过this.componentBuilder的形式传给子组件@BuilderParam customBuilderParam，this指向在Child的label，即“Child”。
@LocalBuilder componentBuilder()通过this.componentBuilder的形式传给子组件@BuilderParam customBuilderParam，this指向Parent的label，即“Parent”。
```typescript
@Component
struct Child {
label: string = 'Child';
@BuilderParam customBuilderParam: () => void;
build() {
Column() {
this.customBuilderParam()
}
}
}
@Entry
@Component
struct Parent {
label: string = 'Parent';
@Builder componentBuilder() {
Text(`${this.label}`)
}
// @LocalBuilder componentBuilder() {
//   Text(`${this.label}`)
// }
build() {
Column() {
Child({ customBuilderParam: this.componentBuilder })
}
}
}
```
使用场景
@LocalBuilder在@ComponentV2修饰的自定义组件中使用
使用局部的@LocalBuilder在@ComponentV2修饰的自定义组件中调用，修改变量触发UI刷新。
```typescript
@ObservedV2
class Info {
@Trace name: string = '';
@Trace age: number = 0;
}
@ComponentV2
struct ChildPage {
@Require @Param childInfo: Info;
build() {
Column() {
Text(`自定义组件 name :${this.childInfo.name}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
Text(`自定义组件 age :${this.childInfo.age}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
}
@Entry
@ComponentV2
struct ParentPage {
info1: Info = { name: "Tom", age: 25 };
@Local info2: Info = { name: "Tom", age: 25 };
@LocalBuilder
privateBuilder() {
Column() {
Text(`局部LocalBuilder@Builder name :${this.info1.name}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
Text(`局部LocalBuilder@Builder age :${this.info1.age}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
@LocalBuilder
privateBuilderSecond() {
Column() {
Text(`局部LocalBuilder@Builder name :${this.info2.name}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
Text(`局部LocalBuilder@Builder age :${this.info2.age}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
build() {
Column() {
Text(`info1: ${this.info1.name}  ${this.info1.age}`) // Text1
.fontSize(30)
.fontWeight(FontWeight.Bold)
this.privateBuilder() // 调用局部@Builder
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
Text(`info2: ${this.info2.name}  ${this.info2.age}`) // Text2
.fontSize(30)
.fontWeight(FontWeight.Bold)
this.privateBuilderSecond() // 调用局部@Builder
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
Text(`info1: ${this.info1.name}  ${this.info1.age}`) // Text1
.fontSize(30)
.fontWeight(FontWeight.Bold)
ChildPage({ childInfo: this.info1}) // 调用自定义组件
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
Text(`info2: ${this.info2.name}  ${this.info2.age}`) // Text2
.fontSize(30)
.fontWeight(FontWeight.Bold)
ChildPage({ childInfo: this.info2}) // 调用自定义组件
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
Button("change info1&info2")
.onClick(() => {
this.info1 = { name: "Cat", age: 18} // Text1不会刷新，原因是没有装饰器修饰监听不到值的改变。
this.info2 = { name: "Cat", age: 18} // Text2会刷新，原因是有装饰器修饰，可以监听到值的改变。
})
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-builderparam
爬取时间: 2025-04-28 06:53:25
来源: Huawei Developer
当开发者创建了自定义组件，并想对该组件添加特定功能，例如想在某一个指定的自定义组件中添加一个点击跳转操作，此时若直接在组件内嵌入事件方法，将会导致所有该自定义组件的实例都增加了功能。为解决此问题，ArkUI引入了@BuilderParam装饰器，@BuilderParam用来装饰指向@Builder方法的变量（@BuilderParam是用来承接@Builder函数的）。开发者可以在初始化自定义组件时，使用不同的方式（如：参数修改、尾随闭包、借用箭头函数等）对@BuilderParam装饰的自定义构建函数进行传参赋值，在自定义组件内部通过调用@BuilderParam为组件增加特定的功能。该装饰器用于声明任意UI描述的一个元素，类似slot占位符。
在阅读本文档前，建议提前阅读：@Builder。
从API version 9开始，该装饰器支持在ArkTS卡片中使用。
从API version 11开始，该装饰器支持在元服务中使用。
装饰器使用说明
初始化@BuilderParam装饰的方法
@BuilderParam装饰的方法只能被自定义构建函数（@Builder装饰的方法）初始化。
-  使用所属自定义组件的自定义构建函数或者全局的自定义构建函数，在本地初始化@BuilderParam。
```typescript
@Builder function overBuilder() {}
@Component
struct Child {
@Builder doNothingBuilder() {};
// 使用自定义组件的自定义构建函数初始化@BuilderParam
@BuilderParam customBuilderParam: () => void = this.doNothingBuilder;
// 使用全局自定义构建函数初始化@BuilderParam
@BuilderParam customOverBuilderParam: () => void = overBuilder;
build(){}
}
```
-  用父组件自定义构建函数初始化子组件@BuilderParam装饰的方法。 图1示例效果图
```typescript
@Component
struct Child {
@Builder customBuilder() {};
@BuilderParam customBuilderParam: () => void = this.customBuilder;
build() {
Column() {
this.customBuilderParam()
}
}
}
@Entry
@Component
struct Parent {
@Builder componentBuilder() {
Text(`Parent builder `)
}
build() {
Column() {
Child({ customBuilderParam: this.componentBuilder })
}
}
}
```
-  需要注意this的指向。 以下示例对this的指向做了介绍。 图2示例效果图
```typescript
@Component
struct Child {
label: string = 'Child';
@Builder customBuilder() {};
@Builder customChangeThisBuilder() {};
@BuilderParam customBuilderParam: () => void = this.customBuilder;
@BuilderParam customChangeThisBuilderParam: () => void = this.customChangeThisBuilder;
build() {
Column() {
this.customBuilderParam()
this.customChangeThisBuilderParam()
}
}
}
@Entry
@Component
struct Parent {
label: string = 'Parent';
@Builder componentBuilder() {
Text(`${this.label}`)
}
build() {
Column() {
// 调用this.componentBuilder()时，this指向当前@Entry所装饰的Parent组件，即label变量的值为"Parent"。
this.componentBuilder()
Child({
// 把this.componentBuilder传给子组件Child的@BuilderParam customBuilderParam，this指向的是子组件Child，即label变量的值为"Child"。
customBuilderParam: this.componentBuilder,
// 把():void=>{this.componentBuilder()}传给子组件Child的@BuilderParam customChangeThisBuilderParam，
// 因为箭头函数的this指向的是宿主对象，所以label变量的值为"Parent"。
customChangeThisBuilderParam: (): void => { this.componentBuilder() }
})
}
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163820.27047302218755472027393930133306:50001231000000:2800:2DC1F4A22899D5BF92C70146A241EEB4367F1F6C73DD9B5FE59F0C2DEB977C5A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163820.72275164557140888383849814811436:50001231000000:2800:33BB5508B7E7309F62CCA427B9EE2C419B09DD972E22FD3589EA00C4E8066B11.png)
限制条件
-  @BuilderParam装饰的变量只能使用@Builder函数来进行初始化。详情见@BuilderParam装饰器初始化的值必须为@Builder。
-  当@Require装饰器和@BuilderParam装饰器一起使用的时候，@BuilderParam装饰器必须进行初始化。详情见@Require装饰器和@BuilderParam装饰器联合使用。
-  在自定义组件尾随闭包的场景下，子组件有且仅有一个@BuilderParam用来接收此尾随闭包，且此@BuilderParam不能有参数。详情见尾随闭包初始化组件。
使用场景
参数初始化组件
@BuilderParam装饰的方法可以是有参数和无参数的两种形式，需与指向的@Builder方法类型匹配。
```typescript
class Tmp{
label: string = '';
}
@Builder function overBuilder($$: Tmp) {
Text($$.label)
.width(400)
.height(50)
.backgroundColor(Color.Green)
}
@Component
struct Child {
label: string = 'Child';
@Builder customBuilder() {};
// 无参数类型，指向的customBuilder也是无参数类型
@BuilderParam customBuilderParam: () => void = this.customBuilder;
// 有参数类型，指向的overBuilder也是有参数类型的方法
@BuilderParam customOverBuilderParam: ($$: Tmp) => void = overBuilder;
build() {
Column() {
this.customBuilderParam()
this.customOverBuilderParam({label: 'global Builder label' } )
}
}
}
@Entry
@Component
struct Parent {
label: string = 'Parent';
@Builder componentBuilder() {
Text(`${this.label}`)
}
build() {
Column() {
this.componentBuilder()
Child({ customBuilderParam: this.componentBuilder, customOverBuilderParam: overBuilder })
}
}
}
```
图3示例效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163820.35329193197283955071988751953356:50001231000000:2800:76BBBA28D6CE7AA5C48F8770933B4BB8A90611A302292C4AA87300B69F50ECC0.png)
尾随闭包初始化组件
在自定义组件中使用@BuilderParam装饰的属性时也可通过尾随闭包进行初始化。在初始化自定义组件时，组件后紧跟一个大括号“{}”形成尾随闭包场景。
-  此场景下自定义组件内有且仅有一个使用@BuilderParam装饰的属性。
-  此场景下自定义组件不支持使用通用属性。
开发者可以将尾随闭包内的内容看做@Builder装饰的函数传给@BuilderParam。
示例1：
```typescript
@Component
struct CustomContainer {
@Prop header: string = '';
@Builder closerBuilder(){};
// 使用父组件的尾随闭包{}(@Builder装饰的方法)初始化子组件@BuilderParam
@BuilderParam closer: () => void = this.closerBuilder;
build() {
Column() {
Text(this.header)
.fontSize(30)
this.closer()
}
}
}
@Builder function specificParam(label1: string, label2: string) {
Column() {
Text(label1)
.fontSize(30)
Text(label2)
.fontSize(30)
}
}
@Entry
@Component
struct CustomContainerUser {
@State text: string = 'header';
build() {
Column() {
// 创建CustomContainer，在创建CustomContainer时，通过其后紧跟一个大括号“{}”形成尾随闭包
// 作为传递给子组件CustomContainer @BuilderParam closer: () => void的参数
CustomContainer({ header: this.text }) {
Column() {
specificParam('testA', 'testB')
}.backgroundColor(Color.Yellow)
.onClick(() => {
this.text = 'changeHeader';
})
}
}
}
}
```
图4示例效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163820.43403114976112269029856539261697:50001231000000:2800:2E60EF2F3095925F22BB256964F1B6C23F9FC3490595BD300F36E6A8049108BF.png)
使用全局@Builder和局部@Builder通过尾随闭包的形式去初始化@ComponentV2修饰的自定义组件中的@BuilderParam。
示例2：
```typescript
@ComponentV2
struct ChildPage {
@Require @Param message: string = "";
@Builder customBuilder() {};
@BuilderParam customBuilderParam: () => void = this.customBuilder;
build() {
Column() {
Text(this.message)
.fontSize(30)
.fontWeight(FontWeight.Bold)
this.customBuilderParam()
}
}
}
const builder_value: string = 'Hello World';
@Builder function overBuilder() {
Row() {
Text(`全局 Builder: ${builder_value}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
@Entry
@ComponentV2
struct ParentPage {
@Local label: string = 'Parent Page';
@Builder componentBuilder() {
Row(){
Text(`局部 Builder :${this.label}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
build() {
Column() {
ChildPage({ message: this.label}){
Column() {  // 使用局部@Builder，通过组件后紧跟一个大括号“{}”形成尾随闭包去初始化自定义组件@BuilderParam
this.componentBuilder();
}
}
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
ChildPage({ message: this.label}){  // 使用全局@Builder，通过组件后紧跟一个大括号“{}”形成尾随闭包去初始化自定义组件@BuilderParam
Column() {
overBuilder();
}
}
}
}
}
```
使用全局和局部@Builder初始化@BuilderParam
在自定义组件中，使用@BuilderParam修饰的变量接收来自父组件通过@Builder传递的内容进行初始化，因为父组件的@Builder可以使用箭头函数的形式改变当前的this指向，所以当使用@BuilderParam修饰的变量时，会展示出不同的内容。
```typescript
@Component
struct ChildPage {
label: string = 'Child Page';
@Builder customBuilder() {};
@BuilderParam customBuilderParam: () => void = this.customBuilder;
@BuilderParam customChangeThisBuilderParam: () => void = this.customBuilder;
build() {
Column() {
this.customBuilderParam()
this.customChangeThisBuilderParam()
}
}
}
const builder_value: string = 'Hello World';
@Builder function overBuilder() {
Row() {
Text(`全局 Builder: ${builder_value}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
@Entry
@Component
struct ParentPage {
label: string = 'Parent Page';
@Builder componentBuilder() {
Row(){
Text(`局部 Builder :${this.label}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
build() {
Column() {
// 调用this.componentBuilder()时，this指向当前@Entry所装饰的ParentPage组件，所以label变量的值为"Parent Page"。
this.componentBuilder()
ChildPage({
// 把this.componentBuilder传给子组件ChildPage的@BuilderParam customBuilderParam，this指向的是子组件ChildPage，所以label变量的值为"Child Page"。
customBuilderParam: this.componentBuilder,
// 把():void=>{this.componentBuilder()}传给子组件ChildPage的@BuilderParam customChangeThisBuilderParam，
// 因为箭头函数的this指向的是宿主对象，所以label变量的值为"Parent Page"。
customChangeThisBuilderParam: (): void => { this.componentBuilder() }
})
Line()
.width('100%')
.height(10)
.backgroundColor('#000000').margin(10)
// 调用全局overBuilder()时，this指向当前整个活动页，所以展示的内容为"Hello World"。
overBuilder()
ChildPage({
// 把全局overBuilder传给子组件ChildPage的@BuilderParam customBuilderParam，this指向当前整个活动页，所以展示的内容为"Hello World"。
customBuilderParam: overBuilder,
// 把全局overBuilder传给子组件ChildPage的@BuilderParam customChangeThisBuilderParam，this指向当前整个活动页，所以展示的内容为"Hello World"。
customChangeThisBuilderParam: overBuilder
})
}
}
}
```
图5示例效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163820.93508359470000789756527416295861:50001231000000:2800:9ACF08FC61C78FDF785A4CE036E9AA109386D5EA5EC4AC70B7132F989C5AF047.png)
在@ComponentV2修饰的自定义组件中使用@BuilderParam
使用全局@Builder和局部@Builder去初始化@ComponentV2修饰的自定义组件中的@BuilderParam属性。
```typescript
@ComponentV2
struct ChildPage {
@Param label: string = 'Child Page';
@Builder customBuilder() {};
@BuilderParam customBuilderParam: () => void = this.customBuilder;
@BuilderParam customChangeThisBuilderParam: () => void = this.customBuilder;
build() {
Column() {
this.customBuilderParam()
this.customChangeThisBuilderParam()
}
}
}
const builder_value: string = 'Hello World';
@Builder function overBuilder() {
Row() {
Text(`全局 Builder: ${builder_value}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
@Entry
@ComponentV2
struct ParentPage {
@Local label: string = 'Parent Page';
@Builder componentBuilder() {
Row(){
Text(`局部 Builder :${this.label}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
build() {
Column() {
// 调用this.componentBuilder()时，this指向当前@Entry所装饰的ParentPage组件，所以label变量的值为"Parent Page"。
this.componentBuilder()
ChildPage({
// 把this.componentBuilder传给子组件ChildPage的@BuilderParam customBuilderParam，this指向的是子组件ChildPage，所以label变量的值为"Child Page"。
customBuilderParam: this.componentBuilder,
// 把():void=>{this.componentBuilder()}传给子组件ChildPage的@BuilderParam customChangeThisBuilderPara
// 因为箭头函数的this指向的是宿主对象，所以label变量的值为"Parent Page"。
customChangeThisBuilderParam: (): void => { this.componentBuilder() }
})
Line()
.width('100%')
.height(5)
.backgroundColor('#000000').margin(10)
// 调用全局overBuilder()时，this指向当前整个活动页，所以展示的内容为"Hello World"。
overBuilder()
ChildPage({
// 把全局overBuilder传给子组件ChildPage的@BuilderParam customBuilderParam，this指向当前整个活动页，所以展示的内容为"Hello World"。
customBuilderParam: overBuilder,
// 把全局overBuilder传给子组件ChildPage的@BuilderParam customChangeThisBuilderParam，this指向当前整个活动页，所以展示的内容为"Hello World"。
customChangeThisBuilderParam: overBuilder
})
}
}
}
```
图6示例效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163820.73964702441891596690840579651938:50001231000000:2800:D592FA1B789B96385E9738FDA0613A771E9CBC30AC99CB1FF252AA023973BD02.png)
常见问题
改变内容UI不刷新
当调用自定义组件ChildPage时，把@Builder作为参数通过this.componentBuilder的形式传递，当前this会指向自定义组件内部，所以在父组件里面改变label的值，自定义组件ChildPage是感知不到的。
【反例】
```typescript
@Component
struct ChildPage {
@State label: string = 'Child Page';
@Builder customBuilder() {};
@BuilderParam customChangeThisBuilderParam: () => void = this.customBuilder;
build() {
Column() {
this.customChangeThisBuilderParam()
}
}
}
@Entry
@Component
struct ParentPage {
@State label: string = 'Parent Page';
@Builder componentBuilder() {
Row(){
Text(`Builder :${this.label}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
build() {
Column() {
ChildPage({
// 当前写法this指向ChildPage组件内
customChangeThisBuilderParam: this.componentBuilder
})
Button('点击改变label内容')
.onClick(() => {
this.label = 'Hello World';
})
}
}
}
```
使用箭头函数的形式把@Builder传递进自定义组件ChildPage中，当前this指向会停留在父组件ParentPage里，所以在父组件里改变label的值，自定义组件ChildPage会感知到并重新渲染UI。
把@Builder改为@LocalBuilder也能实现动态渲染UI功能。
【正例】
```typescript
@Component
struct ChildPage {
@State label: string = 'Child Page';
@Builder customBuilder() {};
@BuilderParam customChangeThisBuilderParam: () => void = this.customBuilder;
build() {
Column() {
this.customChangeThisBuilderParam()
}
}
}
@Entry
@Component
struct ParentPage {
@State label: string = 'Parent Page';
@Builder componentBuilder() {
Row(){
Text(`Builder :${this.label}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
build() {
Column() {
ChildPage({
customChangeThisBuilderParam: () => { this.componentBuilder() }
})
Button('点击改变label内容')
.onClick(() => {
this.label = 'Hello World';
})
}
}
}
```
@Require装饰器和@BuilderParam装饰器联合使用
由于@Require装饰器所装饰的变量需进行初始化，若变量未初始化，在编译时会输出报错信息。
【反例】
```typescript
@Builder function globalBuilder() {
Text('Hello World')
}
@Entry
@Component
struct customBuilderDemo {
build() {
Column() {
// 由于未对子组件ChildBuilder进行赋值，此处无论是编译还是编辑，均会报错。
ChildPage()
}
}
}
@Component
struct ChildPage {
@Require @BuilderParam ChildBuilder: () => void = globalBuilder;
build() {
Column() {
this.ChildBuilder()
}
}
}
```
对使用@Require装饰器修饰的变量进行初始化，此时，编译不会报错，无报错信息。
【正例】
```typescript
@Builder function globalBuilder() {
Text('Hello World')
}
@Entry
@Component
struct customBuilderDemo {
build() {
Column() {
ChildPage({ChildBuilder: globalBuilder})
}
}
}
@Component
struct ChildPage {
@Require @BuilderParam ChildBuilder: () => void = globalBuilder;
build() {
Column() {
this.ChildBuilder()
}
}
}
```
@BuilderParam装饰器初始化的值必须为@Builder
使用@State装饰器修饰的变量，给子组件@BuilderParam和ChildBuilder变量进行初始化，在编译时会输出报错信息。
【反例】
```typescript
@Builder function globalBuilder() {
Text('Hello World')
}
@Entry
@Component
struct customBuilderDemo {
@State message: string = "";
build() {
Column() {
// 子组件ChildBuilder接收@State修饰的变量，会出现编译和编辑报错
ChildPage({ChildBuilder: this.message})
}
}
}
@Component
struct ChildPage {
@BuilderParam ChildBuilder: () => void = globalBuilder;
build() {
Column() {
this.ChildBuilder()
}
}
}
```
使用全局的@Builder修饰的globalBuilder()给子组件@BuilderParam修饰的ChildBuilder变量进行初始化，编译时没有报错，功能正常。
【正例】
```typescript
@Builder function globalBuilder() {
Text('Hello World')
}
@Entry
@Component
struct customBuilderDemo {
build() {
Column() {
ChildPage({ChildBuilder: globalBuilder})
}
}
}
@Component
struct ChildPage {
@BuilderParam ChildBuilder: () => void = globalBuilder;
build() {
Column() {
this.ChildBuilder()
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-wrapbuilder
爬取时间: 2025-04-28 06:53:38
来源: Huawei Developer
当开发者在一个struct内使用了多个全局@Builder函数，来实现UI的不同效果时，多个全局@Builder函数会使代码维护起来非常困难，并且页面不整洁。此时，开发者可以使用wrapBuilder来封装全局@Builder。
在阅读本文档前，建议提前阅读：@Builder。
从API version 11开始使用。
当@Builder方法赋值给变量或者数组后，赋值的变量或者数组在UI方法中无法使用。
```typescript
@Builder
function builderElement() {}
let builderArr: Function[] = [builderElement];
@Builder
function testBuilder() {
ForEach(builderArr, (item: Function) => {
item();
})
}
```
在上述代码中，builderArr是一个@Builder方法组成的数组， 在ForEach中取每一项@Builder方法时会出现@Builder方法在UI方法中无法使用的错误。
为了解决这一问题，引入wrapBuilder作为全局@Builder封装函数。wrapBuilder的参数返回WrappedBuilder对象，实现全局@Builder可以进行赋值和传递。
接口说明
wrapBuilder是一个模板函数，返回一个WrappedBuilder对象。
```typescript
declare function wrapBuilder< Args extends Object[]>(builder: (...args: Args) => void): WrappedBuilder;
```
同时 WrappedBuilder对象也是一个模板类。
```typescript
declare class WrappedBuilder< Args extends Object[]> {
builder: (...args: Args) => void;
constructor(builder: (...args: Args) => void);
}
```
说明：模板参数Args extends Object[]是需要包装的builder函数的参数列表
使用方法：
```typescript
let builderVar: WrappedBuilder<[string, number]> = wrapBuilder(MyBuilder)
let builderArr: WrappedBuilder<[string, number]>[] = [wrapBuilder(MyBuilder)] //可以放入数组
```
限制条件
wrapBuilder方法只能传入全局@Builder方法。
wrapBuilder方法返回的WrappedBuilder对象的builder属性方法只能在struct内部使用。
@Builder方法赋值给变量
把@Builder装饰器装饰的方法MyBuilder作为wrapBuilder的参数，再将wrapBuilder赋值给变量globalBuilder，用来解决@Builder方法赋值给变量后无法被使用的问题。
```typescript
@Builder
function MyBuilder(value: string, size: number) {
Text(value)
.fontSize(size)
}
let globalBuilder: WrappedBuilder<[string, number]> = wrapBuilder(MyBuilder);
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Row() {
Column() {
globalBuilder.builder(this.message, 50)
}
.width('100%')
}
.height('100%')
}
}
```
@Builder方法赋值给变量在UI语法中使用
自定义组件Index使用ForEach来进行不同@Builder函数的渲染，可以使用builderArr声明的wrapBuilder数组进行不同@Builder函数效果体现。整体代码会较整洁。
```typescript
@Builder
function MyBuilder(value: string, size: number) {
Text(value)
.fontSize(size)
}
@Builder
function YourBuilder(value: string, size: number) {
Text(value)
.fontSize(size)
.fontColor(Color.Pink)
}
const builderArr: WrappedBuilder<[string, number]>[] = [wrapBuilder(MyBuilder), wrapBuilder(YourBuilder)];
@Entry
@Component
struct Index {
@Builder testBuilder() {
ForEach(builderArr, (item: WrappedBuilder<[string, number]>) => {
item.builder('Hello World', 30)
}
)
}
build() {
Row() {
Column() {
this.testBuilder()
}
.width('100%')
}
.height('100%')
}
}
```
引用传递
通过按引用传递的方式传入参数，会触发UI的刷新。
```typescript
class Tmp {
paramA2: string = 'hello';
}
@Builder function overBuilder(param: Tmp) {
Column(){
Text(`wrapBuildervalue:${param.paramA2}`)
}
}
const wBuilder: WrappedBuilder<[Tmp]> = wrapBuilder(overBuilder);
@Entry
@Component
struct Parent{
@State label: Tmp = new Tmp();
build(){
Column(){
wBuilder.builder({paramA2: this.label.paramA2})
Button('Click me').onClick(() => {
this.label.paramA2 = 'ArkUI';
})
}
}
}
```
常见问题
重复定义wrapBuilder失效
在同一个自定义组件内，同一个wrapBuilder只能初始化一次。示例中builderObj通过wrapBuilder(MyBuilderFirst)初始化定义之后，再次对builderObj进行赋值wrapBuilder(MyBuilderSecond)不会生效。
```typescript
@Builder
function MyBuilderFirst(value: string, size: number) {
Text('MyBuilderFirst：' + value)
.fontSize(size)
}
@Builder
function MyBuilderSecond(value: string, size: number) {
Text('MyBuilderSecond：' + value)
.fontSize(size)
}
interface BuilderModel {
globalBuilder: WrappedBuilder<[string, number]>;
}
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
@State builderObj: BuilderModel = { globalBuilder: wrapBuilder(MyBuilderFirst) };
aboutToAppear(): void {
setTimeout(() => {
// wrapBuilder(MyBuilderSecond) 不会生效
this.builderObj.globalBuilder = wrapBuilder(MyBuilderSecond);
},1000)
}
build() {
Row() {
Column() {
this.builderObj.globalBuilder.builder(this.message, 20)
}
.width('100%')
}
.height('100%')
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-style
爬取时间: 2025-04-28 06:53:52
来源: Huawei Developer
如果每个组件的样式都需要单独设置，在开发过程中会出现大量代码在进行重复样式设置，虽然可以复制粘贴，但为了代码简洁性和后续方便维护，我们推出了可以提炼公共样式进行复用的装饰器@Styles。
@Styles装饰器可以将多条样式设置提炼成一个方法，直接在组件声明的位置调用。通过@Styles装饰器可以快速定义并复用自定义样式。
从API version 9开始，该装饰器支持在ArkTS卡片中使用。
从API version 11开始，该装饰器支持在元服务中使用。
装饰器使用说明
-  当前@Styles仅支持通用属性和通用事件。
-  @Styles可以定义在组件内或全局，在全局定义时需在方法名前面添加function关键字，组件内定义时则不需要添加function关键字。
只能在当前文件内使用，不支持export。
如果想实现export功能，推荐使用AttributeModifier
```typescript
// 全局
@Styles function functionName() { ... }
// 在组件内
@Component
struct FancyUse {
@Styles fancy() {
.height(100)
}
}
```
如果要实现跨文件操作的功能，可以参考使用动态属性设置。
```typescript
// index.ets
import { MyButtonModifier } from './setAttribute'
@Entry
@Component
struct AttributeDemo {
@State modifier: MyButtonModifier = new MyButtonModifier();
build() {
Row() {
Column() {
Button("Button")
.attributeModifier(this.modifier)
.onClick(() => {
this.modifier.isDark = !this.modifier.isDark
})
}
.width('100%')
}
.height('100%')
}
}
```
```typescript
// setAttribute.ets
export class MyButtonModifier implements AttributeModifier<ButtonAttribute> {
isDark: boolean = false;
applyNormalAttribute(instance: ButtonAttribute): void {
if (this.isDark) {
instance.backgroundColor(Color.Black)
} else {
instance.backgroundColor(Color.Red)
}
}
}
```
-  定义在组件内的@Styles可以通过this访问组件的常量和状态变量，并可以在@Styles里通过事件来改变状态变量的值，示例如下：
```typescript
@Entry
@Component
struct FancyUse {
@State heightValue: number = 100;
@Styles fancy() {
.height(this.heightValue)
.backgroundColor(Color.Yellow)
.onClick(() => {
this.heightValue = 200;
})
}
}
```
-  组件内@Styles的优先级高于全局@Styles。 框架优先找当前组件内的@Styles，如果找不到，则会全局查找。
限制条件
-  @Styles方法不能有参数，编译期会报错，提醒开发者@Styles方法不支持参数。
```typescript
// 错误写法： @Styles不支持参数，编译期报错
@Styles function globalFancy (value: number) {
.width(value)
}
// 正确写法
@Styles function globalFancy () {
.width(value)
}
```
-  不支持在@Styles方法内使用逻辑组件，在逻辑组件内的属性不生效。
```typescript
// 错误写法
@Styles function backgroundColorStyle() {
if (true) {
.backgroundColor(Color.Red)
}
}
// 正确写法
@Styles function backgroundColorStyle() {
.backgroundColor(Color.Red)
}
```
使用场景
以下示例中演示了组件内@Styles和全局@Styles的用法。
```typescript
// 定义在全局的@Styles封装的样式
@Styles function globalFancy  () {
.width(150)
.height(100)
.backgroundColor(Color.Pink)
}
@Entry
@Component
struct FancyUse {
@State heightValue: number = 100;
// 定义在组件内的@Styles封装的样式
@Styles fancy() {
.width(200)
.height(this.heightValue)
.backgroundColor(Color.Yellow)
.onClick(() => {
this.heightValue = 200
})
}
build() {
Column({ space: 10 }) {
// 使用全局的@Styles封装的样式
Text('FancyA')
.globalFancy()
.fontSize(30)
// 使用组件内的@Styles封装的样式
Text('FancyB')
.fancy()
.fontSize(30)
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-extend
爬取时间: 2025-04-28 06:54:05
来源: Huawei Developer
在前文的示例中，可以使用@Styles用于样式的重用，在@Styles的基础上，我们提供了@Extend，用于扩展组件样式。
从API version 9开始，该装饰器支持在ArkTS卡片中使用。
从API version 11开始，该装饰器支持在元服务中使用。
装饰器使用说明
语法
```typescript
@Extend(UIComponentName) function functionName { ... }
```
使用规则
-  和@Styles不同，@Extend支持封装指定组件的私有属性、私有事件和自身定义的全局方法。
```typescript
// @Extend(Text)可以支持Text的私有属性fontColor
@Extend(Text) function fancy () {
.fontColor(Color.Red)
}
// superFancyText可以调用预定义的fancy
@Extend(Text) function superFancyText(size:number) {
.fontSize(size)
.fancy()
}
```
-  和@Styles不同，@Extend装饰的方法支持参数，开发者可以在调用时传递参数，调用遵循TS方法传值调用。
```typescript
// xxx.ets
@Extend(Text) function fancy (fontSize: number) {
.fontColor(Color.Red)
.fontSize(fontSize)
}
@Entry
@Component
struct FancyUse {
build() {
Row({ space: 10 }) {
Text('Fancy')
.fancy(16)
Text('Fancy')
.fancy(24)
}
}
}
```
-  @Extend装饰的方法的参数可以为function，作为Event事件的句柄。
```typescript
@Extend(Text) function makeMeClick(onClick: () => void) {
.backgroundColor(Color.Blue)
.onClick(onClick)
}
@Entry
@Component
struct FancyUse {
@State label: string = 'Hello World';
onClickHandler() {
this.label = 'Hello ArkUI';
}
build() {
Row({ space: 10 }) {
Text(`${this.label}`)
.makeMeClick(() => {this.onClickHandler()})
}
}
}
```
-  @Extend的参数可以为状态变量，当状态变量改变时，UI可以正常的被刷新渲染。
```typescript
@Extend(Text) function fancy (fontSize: number) {
.fontColor(Color.Red)
.fontSize(fontSize)
}
@Entry
@Component
struct FancyUse {
@State fontSizeValue: number = 20
build() {
Row({ space: 10 }) {
Text('Fancy')
.fancy(this.fontSizeValue)
.onClick(() => {
this.fontSizeValue = 30
})
}
}
}
```
限制条件
只能在当前文件内使用，不支持export。
如果想实现export功能，推荐使用AttributeModifier。
【反例】
```typescript
@Entry
@Component
struct FancyUse {
// 错误写法，@Extend仅支持在全局定义，不支持在组件内部定义
@Extend(Text) function fancy (fontSize: number) {
.fontSize(fontSize)
}
build() {
Row({ space: 10 }) {
Text('Fancy')
.fancy(16)
}
}
}
```
【正例】
```typescript
// 正确写法
@Extend(Text) function fancy (fontSize: number) {
.fontSize(fontSize)
}
@Entry
@Component
struct FancyUse {
build() {
Row({ space: 10 }) {
Text('Fancy')
.fancy(16)
}
}
}
```
使用场景
以下示例声明了3个Text组件，每个Text组件均设置了fontStyle、fontWeight和backgroundColor样式。
```typescript
@Entry
@Component
struct FancyUse {
@State label: string = 'Hello World'
build() {
Row({ space: 10 }) {
Text(`${this.label}`)
.fontStyle(FontStyle.Italic)
.fontWeight(100)
.backgroundColor(Color.Blue)
Text(`${this.label}`)
.fontStyle(FontStyle.Italic)
.fontWeight(200)
.backgroundColor(Color.Pink)
Text(`${this.label}`)
.fontStyle(FontStyle.Italic)
.fontWeight(300)
.backgroundColor(Color.Orange)
}.margin('20%')
}
}
```
@Extend将样式组合复用，示例如下。
```typescript
@Extend(Text) function fancyText(weightValue: number, color: Color) {
.fontStyle(FontStyle.Italic)
.fontWeight(weightValue)
.backgroundColor(color)
}
```
通过@Extend组合样式后，使得代码更加简洁，增强可读性。
```typescript
@Entry
@Component
struct FancyUse {
@State label: string = 'Hello World'
build() {
Row({ space: 10 }) {
Text(`${this.label}`)
.fancyText(100, Color.Blue)
Text(`${this.label}`)
.fancyText(200, Color.Pink)
Text(`${this.label}`)
.fancyText(300, Color.Orange)
}.margin('20%')
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-statestyles
爬取时间: 2025-04-28 06:54:19
来源: Huawei Developer
@Styles仅仅应用于静态页面的样式复用，stateStyles可以依据组件的内部状态的不同，快速设置不同样式。这就是我们本章要介绍的内容stateStyles（又称为：多态样式）。
多态样式仅支持通用属性。如果多态样式不生效，则该属性可能为组件的私有属性，例如：fontColor、TextInput组件的backgroundColor等。此时，可以通过attributeModifier动态设置组件属性来解决此问题。
概述
stateStyles是属性方法，可以根据UI内部状态来设置样式，类似于css伪类，但语法不同。ArkUI提供以下五种状态：
-  focused：获焦态。
-  normal：正常态。
-  pressed：按压态。
-  disabled：不可用态。
-  selected10+：选中态。
获焦态目前仅支持通过外接键盘的tab键、方向键触发。不支持嵌套滚动组件场景按键走焦。
使用场景
基础场景
下面的示例展示了stateStyles最基本的使用场景。Button1处于第一个组件，Button2处于第二个组件。按压时显示为pressed态指定的黑色。使用Tab键走焦，先是Button1获焦并显示为focus态指定的粉色。当Button2获焦的时候，Button2显示为focus态指定的粉色，Button1失焦显示normal态指定的蓝色。
```typescript
@Entry
@Component
struct StateStylesSample {
build() {
Column() {
Button('Button1')
.stateStyles({
focused: {
.backgroundColor('#ffffeef0')
},
pressed: {
.backgroundColor('#ff707070')
},
normal: {
.backgroundColor('#ff2787d9')
}
})
.margin(20)
Button('Button2')
.stateStyles({
focused: {
.backgroundColor('#ffffeef0')
},
pressed: {
.backgroundColor('#ff707070')
},
normal: {
.backgroundColor('#ff2787d9')
}
})
}.margin('30%')
}
}
```
图1获焦态和按压态
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163821.64167562897118148814793554025290:50001231000000:2800:7F0ACB4505A2CC3EA881D2A60333DA666C25EAA15D8A971FA2BD6B0C9162D1B9.gif)
@Styles和stateStyles联合使用
以下示例通过@Styles指定stateStyles的不同状态。
```typescript
@Entry
@Component
struct MyComponent {
@Styles normalStyle() {
.backgroundColor(Color.Gray)
}
@Styles pressedStyle() {
.backgroundColor(Color.Red)
}
build() {
Column() {
Text('Text1')
.fontSize(50)
.fontColor(Color.White)
.stateStyles({
normal: this.normalStyle,
pressed: this.pressedStyle,
})
}
}
}
```
图2正常态和按压态
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163821.62044408482455413572504087658897:50001231000000:2800:9F276D996D9A466922A30FF4A99A0E009579E1579F2BDEF1B6008383BC80A60A.gif)
在stateStyles里使用常规变量和状态变量
stateStyles可以通过this绑定组件内的常规变量和状态变量。
```typescript
@Entry
@Component
struct CompWithInlineStateStyles {
@State focusedColor: Color = Color.Red;
normalColor: Color = Color.Green
build() {
Column() {
Button('clickMe').height(100).width(100)
.stateStyles({
normal: {
.backgroundColor(this.normalColor)
},
focused: {
.backgroundColor(this.focusedColor)
}
})
.onClick(() => {
this.focusedColor = Color.Pink
})
.margin('30%')
}
}
}
```
Button默认normal态显示绿色，第一次按下Tab键让Button获焦显示为focus态的红色，点击事件触发后，再次按下Tab键让Button获焦，focus态变为粉色。
图3点击改变获焦态样式
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163821.89271365797808210232943749891049:50001231000000:2800:7EF2E7502178DB375A74EC8BD0D704CC021EFDB228995AE75CA111A2B84CD313.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-animatable-extend
爬取时间: 2025-04-28 06:54:32
来源: Huawei Developer
@AnimatableExtend装饰器用于自定义可动画的属性方法，在这个属性方法中修改组件不可动画的属性。在动画执行过程时，通过逐帧回调函数修改不可动画属性值，让不可动画属性也能实现动画效果。也可通过逐帧回调函数修改可动画属性的值，实现逐帧布局的效果。
-  可动画属性：如果一个属性方法在animation属性前调用，改变这个属性的值可以使animation属性的动画效果生效，这个属性称为可动画属性。比如height、width、backgroundColor、translate属性，和Text组件的fontSize属性等。
-  不可动画属性：如果一个属性方法在animation属性前调用，改变这个属性的值不能使animation属性的动画效果生效，这个属性称为不可动画属性。比如Polyline组件的points属性等。
该装饰器从API Version 10开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。
从API version 11开始，该装饰器支持在元服务中使用。
装饰器使用说明
语法
```typescript
@AnimatableExtend(UIComponentName) function functionName(value: typeName) {
.propertyName(value)
}
```
AnimatableArithmetic<T>接口说明
该接口定义非number数据类型的动画运算规则。对非number类型的数据（如数组、结构体、颜色等）做动画，需要实现AnimatableArithmetic<T>接口中加法、减法、乘法和判断相等函数，
使得该数据能参与动画的插值运算和识别该数据是否发生改变。即定义它们为实现了AnimatableArithmetic<T>接口的类型。
| 名称 | 入参类型 | 返回值类型 | 说明 |
| --- | --- | --- | --- |
| plus | AnimatableArithmetic<T> | AnimatableArithmetic<T> | 定义该数据类型的加法运算规则 |
| subtract | AnimatableArithmetic<T> | AnimatableArithmetic<T> | 定义该数据类型的减法运算规则 |
| multiply | number | AnimatableArithmetic<T> | 定义该数据类型的乘法运算规则 |
| equals | AnimatableArithmetic<T> | boolean | 定义该数据类型的相等判断规则 |
使用场景
以下示例通过改变Text组件宽度实现逐帧布局的效果。
```typescript
@AnimatableExtend(Text)
function animatableWidth(width: number) {
.width(width)
}
@Entry
@Component
struct AnimatablePropertyExample {
@State textWidth: number = 80;
build() {
Column() {
Text("AnimatableProperty")
.animatableWidth(this.textWidth)
.animation({ duration: 2000, curve: Curve.Ease })
Button("Play")
.onClick(() => {
this.textWidth = this.textWidth == 80 ? 160 : 80;
})
}.width("100%")
.padding(10)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163821.64325310440957928193537568388800:50001231000000:2800:7B188EA5983FCC44202A763E6B330284C3010CD81E9DE5E09495008BB2F8CFCA.gif)
以下示例实现折线的动画效果。
```typescript
class Point {
x: number
y: number
constructor(x: number, y: number) {
this.x = x
this.y = y
}
plus(rhs: Point): Point {
return new Point(this.x + rhs.x, this.y + rhs.y)
}
subtract(rhs: Point): Point {
return new Point(this.x - rhs.x, this.y - rhs.y)
}
multiply(scale: number): Point {
return new Point(this.x * scale, this.y * scale)
}
equals(rhs: Point): boolean {
return this.x === rhs.x && this.y === rhs.y
}
}
// PointVector实现了AnimatableArithmetic<T>接口
class PointVector extends Array<Point> implements AnimatableArithmetic<PointVector> {
constructor(value: Array<Point>) {
super();
value.forEach(p => this.push(p))
}
plus(rhs: PointVector): PointVector {
let result = new PointVector([])
const len = Math.min(this.length, rhs.length)
for (let i = 0; i < len; i++) {
result.push((this as Array<Point>)[i].plus((rhs as Array<Point>)[i]))
}
return result
}
subtract(rhs: PointVector): PointVector {
let result = new PointVector([])
const len = Math.min(this.length, rhs.length)
for (let i = 0; i < len; i++) {
result.push((this as Array<Point>)[i].subtract((rhs as Array<Point>)[i]))
}
return result
}
multiply(scale: number): PointVector {
let result = new PointVector([])
for (let i = 0; i < this.length; i++) {
result.push((this as Array<Point>)[i].multiply(scale))
}
return result
}
equals(rhs: PointVector): boolean {
if (this.length != rhs.length) {
return false
}
for (let i = 0; i < this.length; i++) {
if (!(this as Array<Point>)[i].equals((rhs as Array<Point>)[i])) {
return false
}
}
return true
}
get(): Array<Object[]> {
let result: Array<Object[]> = []
this.forEach(p => result.push([p.x, p.y]))
return result
}
}
@AnimatableExtend(Polyline)
function animatablePoints(points: PointVector) {
.points(points.get())
}
@Entry
@Component
struct AnimatablePropertyExample {
@State points: PointVector = new PointVector([
new Point(50, Math.random() * 200),
new Point(100, Math.random() * 200),
new Point(150, Math.random() * 200),
new Point(200, Math.random() * 200),
new Point(250, Math.random() * 200),
])
build() {
Column() {
Polyline()
.animatablePoints(this.points)
.animation({ duration: 1000, curve: Curve.Ease })// 设置动画参数
.size({ height: 220, width: 300 })
.fill(Color.Green)
.stroke(Color.Red)
.backgroundColor('#eeaacc')
Button("Play")
.onClick(() => {
// points是实现了可动画协议的数据类型，points在动画过程中可按照定义的运算规则、动画参数从之前的PointVector变为新的PointVector数据，产生每一帧的PointVector数据，进而产生动画
this.points = new PointVector([
new Point(50, Math.random() * 200),
new Point(100, Math.random() * 200),
new Point(150, Math.random() * 200),
new Point(200, Math.random() * 200),
new Point(250, Math.random() * 200),
])
})
}.width("100%")
.padding(10)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163821.09965921543184889180965462716778:50001231000000:2800:02ED78B86B5E5740CFC8D6333FC289570FA0546BF0C96E197C9455341313F454.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-require
爬取时间: 2025-04-28 06:54:46
来源: Huawei Developer
@Require是校验@Prop、@State、@Provide、@BuilderParam 、@Param和普通变量(无状态装饰器修饰的变量)是否需要构造传参的一个装饰器。
从API version 11开始对@Prop/@BuilderParam进行校验。
从API version 11开始，该装饰器支持在元服务中使用。
从API version 12开始对@State/@Provide/@Param/和普通变量(无状态装饰器修饰的变量)进行校验。
概述
当@Require装饰器和@Prop、@State、@Provide、@BuilderParam、@Param和普通变量(无状态装饰器修饰的变量)结合使用时，在构造该自定义组件时，@Prop、@State、@Provide、@BuilderParam、@Param和普通变量(无状态装饰器修饰的变量)必须在构造时传参。
限制条件
@Require装饰器仅用于装饰struct内的@Prop、@State、@Provide、@BuilderParam、@Param和普通变量(无状态装饰器修饰的变量)。
预览器限制场景请参考PreviewChecker检测规则。
使用场景
当Child组件内使用@Require装饰器和@Prop、@State、@Provide、@BuilderParam、@Param和普通变量(无状态装饰器修饰的变量)结合使用时，父组件Index在构造Child时必须传参，否则编译不通过。
```typescript
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
@Builder buildTest() {
Row() {
Text('Hello, world')
.fontSize(30)
}
}
build() {
Row() {
Child({ regular_value: this.message, state_value: this.message, provide_value: this.message, initMessage: this.message, message: this.message,
buildTest: this.buildTest, initBuildTest: this.buildTest })
}
}
}
@Component
struct Child {
@Builder buildFunction() {
Column() {
Text('initBuilderParam')
.fontSize(30)
}
}
@Require regular_value: string = 'Hello';
@Require @State state_value: string = "Hello";
@Require @Provide provide_value: string = "Hello";
@Require @BuilderParam buildTest: () => void;
@Require @BuilderParam initBuildTest: () => void = this.buildFunction;
@Require @Prop initMessage: string = 'Hello';
@Require @Prop message: string;
build() {
Column() {
Text(this.initMessage)
.fontSize(30)
Text(this.message)
.fontSize(30)
this.initBuildTest();
this.buildTest();
}
.width('100%')
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163821.77169650852731993084655450094204:50001231000000:2800:C08DE87441379F9B12F6E8CE470094ADD149C7A37691494A5AB3DFE2EEDDBB56.png)
使用@ComponentV2修饰的自定义组件ChildPage通过父组件ParentPage进行初始化，因为有@Require装饰，所以父组件必须进行构造赋值。
```typescript
@ObservedV2
class Info {
@Trace name: string = '';
@Trace age: number = 0;
}
@ComponentV2
struct ChildPage {
@Require @Param childInfo: Info = new Info();
@Require @Param state_value: string = "Hello";
build() {
Column() {
Text(`ChildPage childInfo name :${this.childInfo.name}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
Text(`ChildPage childInfo age :${this.childInfo.age}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
Text(`ChildPage state_value age :${this.state_value}`)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}
}
@Entry
@ComponentV2
struct ParentPage {
info1: Info = { name: "Tom", age: 25 };
label1: string = "Hello World";
@Local info2: Info = { name: "Tom", age: 25 };
@Local label2: string = "Hello World";
build() {
Column() {
Text(`info1: ${this.info1.name}  ${this.info1.age}`) // Text1
.fontSize(30)
.fontWeight(FontWeight.Bold)
ChildPage({ childInfo: this.info1, state_value: this.label1}) // 调用自定义组件
Line()
.width('100%')
.height(5)
.backgroundColor('#000000').margin(10)
Text(`info2: ${this.info2.name}  ${this.info2.age}`) // Text2
.fontSize(30)
.fontWeight(FontWeight.Bold)
ChildPage({ childInfo: this.info2, state_value: this.label2}) // 调用自定义组件
Line()
.width('100%')
.height(5)
.backgroundColor('#000000').margin(10)
Button("change info1&info2")
.onClick(() => {
this.info1 = { name: "Cat", age: 18} // Text1不会刷新，原因是没有装饰器修饰监听不到值的改变。
this.info2 = { name: "Cat", age: 18} // Text2会刷新，原因是有装饰器修饰，可以监听到值的改变。
this.label1 = "Luck"; // 不会刷新，原因是没有装饰器修饰监听不到值的改变。
this.label2 = "Luck"; // 会刷新，原因是有装饰器修饰，可以监听到值的改变。
})
}
}
}
```
错误场景
```typescript
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
@Builder buildTest() {
Row() {
Text('Hello, world')
.fontSize(30)
}
}
build() {
Row() {
Child()
}
}
}
@Component
struct Child {
@Builder buildFunction() {
Column() {
Text('initBuilderParam')
.fontSize(30)
}
}
// 使用@Require必须构造时传参。
@Require regular_value: string = 'Hello';
@Require @State state_value: string = "Hello";
@Require @Provide provide_value: string = "Hello";
@Require @BuilderParam initBuildTest: () => void = this.buildFunction;
@Require @Prop initMessage: string = 'Hello';
build() {
Column() {
Text(this.initMessage)
.fontSize(30)
this.initBuildTest();
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-reusable
爬取时间: 2025-04-28 06:55:00
来源: Huawei Developer
@Reusable装饰器装饰任意自定义组件时，表示该自定义组件可以复用。
从API version 10开始，对@Reusable进行支持，支持在ArkTS中使用。
概述
限制条件
```typescript
import { ComponentContent } from "@kit.ArkUI";
// @Builder加上@Reusable编译报错,不适用于builder
// @Reusable
@Builder
function buildCreativeLoadingDialog(closedClick: () => void) {
Crash()
}
@Component
export struct Crash {
build() {
Column() {
Text("Crash")
.fontSize(12)
.lineHeight(18)
.fontColor(Color.Blue)
.margin({
left: 6
})
}.width('100%')
.height('100%')
.justifyContent(FlexAlign.Center)
}
}
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
private uicontext = this.getUIContext();
build() {
RelativeContainer() {
Text(this.message)
.id('Index')
.fontSize(50)
.fontWeight(FontWeight.Bold)
.alignRules({
center: { anchor: '__container__', align: VerticalAlign.Center },
middle: { anchor: '__container__', align: HorizontalAlign.Center }
})
.onClick(() => {
let contentNode = new ComponentContent(this.uicontext, wrapBuilder(buildCreativeLoadingDialog), () => {
});
this.uicontext.getPromptAction().openCustomDialog(contentNode);
})
}
.height('100%')
.width('100%')
}
}
```
```typescript
import { ComponentContent } from "@kit.ArkUI";
@Builder
function buildCreativeLoadingDialog(closedClick: () => void) {
Crash()
}
// 如果注释掉就可以正常弹出弹窗，如果加上@Reusable就直接crash
@Reusable
@Component
export struct Crash {
build() {
Column() {
Text("Crash")
.fontSize(12)
.lineHeight(18)
.fontColor(Color.Blue)
.margin({
left: 6
})
}.width('100%')
.height('100%')
.justifyContent(FlexAlign.Center)
}
}
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
private uicontext = this.getUIContext();
build() {
RelativeContainer() {
Text(this.message)
.id('Index')
.fontSize(50)
.fontWeight(FontWeight.Bold)
.alignRules({
center: { anchor: '__container__', align: VerticalAlign.Center },
middle: { anchor: '__container__', align: HorizontalAlign.Center }
})
.onClick(() => {
// ComponentContent底层是buildNode，buildNode不支持传入@Reusable注解的自定义组件
let contentNode = new ComponentContent(this.uicontext, wrapBuilder(buildCreativeLoadingDialog), () => {
});
this.uicontext.getPromptAction().openCustomDialog(contentNode);
})
}
.height('100%')
.width('100%')
}
}
```
不支持嵌套使用，只是标记，会多增加一个缓存池，各自的复用缓存池存在相同树状结构，复用效率低，引发复用内存增加;
嵌套使用形成各自独立的复用缓存池之后，生命周期的传递存在问题，资源和变量管理无法共享，并不方便维护，容易引发问题;
示例中PlayButton形成的复用缓存池，并不能在PlayButton02的复用缓存池使用，但PlayButton02自己形成复用缓存相互可以使用;
在PlayButton隐藏时已经触发PlayButton02的aboutToRecycle，但是在PlayButton02单独显示时却无法执行aboutToReuse，组件复用的生命周期方法存在无法成对调用问题;
综上，不建议嵌套使用。
```typescript
@Entry
@Component
struct Index {
@State isPlaying: boolean = false;
@State isPlaying02: boolean = true;
@State isPlaying01: boolean = false;
build() {
Column() {
if (this.isPlaying02) {
// 初始态是显示的按钮
Text("Default shown childbutton")
.fontSize(14)
PlayButton02({ isPlaying02: $isPlaying02 })
}
Text(`------------------------`)
// 初始态是隐藏的按钮
if (this.isPlaying01) {
Text("Default hidden childbutton")
.fontSize(14)
PlayButton02({ isPlaying02: $isPlaying01 })
}
Text(`------------------------`)
// 父子嵌套
if (this.isPlaying) {
Text("parent child 嵌套")
.fontSize(14)
PlayButton({ buttonPlaying: $isPlaying })
}
Text(`------------------------`)
// 父子嵌套控制
Text(`Parent=child==is ${this.isPlaying ? '' : 'not'} playing`).fontSize(14)
Button('Parent=child===controll=' + this.isPlaying)
.margin(14)
.onClick(() => {
this.isPlaying = !this.isPlaying;
})
Text(`------------------------`)
//  默认隐藏按钮控制
Text(`Hiddenchild==is ${this.isPlaying01 ? '' : 'not'} playing`).fontSize(14)
Button('Button===hiddenchild==control==' + this.isPlaying01)
.margin(14)
.onClick(() => {
this.isPlaying01 = !this.isPlaying01;
})
Text(`------------------------`)
// 默认显示按钮控制
Text(`shownchid==is ${this.isPlaying02 ? '' : 'not'} playing`).fontSize(14)
Button('Button===shownchid==control==:' + this.isPlaying02)
.margin(15)
.onClick(() => {
this.isPlaying02 = !this.isPlaying02;
})
}
}
}
// 复用1
@Reusable
@Component
struct PlayButton {
@Link buttonPlaying: boolean;
build() {
Column() {
// 复用
PlayButton02({ isPlaying02: $buttonPlaying })
Button(this.buttonPlaying ? 'parent_pause' : 'parent_play')
.margin(12)
.onClick(() => {
this.buttonPlaying = !this.buttonPlaying;
})
}
}
}
//  复用2 不建议嵌套使用
@Reusable
@Component
struct PlayButton02 {
@Link isPlaying02: boolean;
aboutToRecycle(): void {
console.log("=====aboutToRecycle====PlayButton02====");
}
aboutToReuse(params: ESObject): void {
console.log("=====aboutToReuse====PlayButton02====");
}
build() {
Column() {
Button('===commonbutton=====')
.margin(12)
}
}
}
```
使用场景
-  列表滚动：当应用需要展示大量数据的列表，并且用户进行滚动操作时，频繁创建和销毁列表项的视图可能导致卡顿和性能问题。在这种情况下，使用列表组件的组件复用机制可以重用已经创建的列表项视图，提高滚动的流畅度。
-  动态布局更新：如果应用中的界面需要频繁地进行布局更新，例如根据用户的操作或数据变化动态改变视图结构和样式，重复创建和销毁视图可能导致频繁的布局计算，影响帧率。在这种情况下，使用组件复用可以避免不必要的视图创建和布局计算，提高性能。
-  频繁创建和销毁数据项的视图场景下。使用组件复用可以重用已创建的视图，只更新数据的内容，减少视图的创建和销毁，能有效提高性能。
使用场景举例
动态布局更新
```typescript
// xxx.ets
export class Message {
value: string | undefined;
constructor(value: string) {
this.value = value;
}
}
@Entry
@Component
struct Index {
@State switch: boolean = true;
build() {
Column() {
Button('Hello')
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.switch = !this.switch;
})
if (this.switch) {
// 如果只有一个复用的组件，可以不用设置reuseId
Child({ message: new Message('Child') })
.reuseId('Child')
}
}
.height("100%")
.width('100%')
}
}
@Reusable
@Component
struct Child {
@State message: Message = new Message('AboutToReuse');
aboutToReuse(params: Record<string, ESObject>) {
console.info("Recycle ====Child==");
this.message = params.message as Message;
}
build() {
Column() {
Text(this.message.value)
.fontSize(30)
}
.borderWidth(1)
.height(100)
}
}
```
列表滚动配合LazyForEach使用
```typescript
class MyDataSource implements IDataSource {
private dataArray: string[] = [];
private listener: DataChangeListener | undefined;
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
}
public reloadListener(): void {
this.listener?.onDataReloaded();
}
public registerDataChangeListener(listener: DataChangeListener): void {
this.listener = listener;
}
public unregisterDataChangeListener(listener: DataChangeListener): void {
this.listener = undefined;
}
}
@Entry
@Component
struct ReuseDemo {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 1; i < 1000; i++) {
this.data.pushData(i + "");
}
}
// ...
build() {
Column() {
List() {
LazyForEach(this.data, (item: string) => {
ListItem() {
CardView({ item: item })
}
}, (item: string) => item)
}
}
}
}
// 复用组件
@Reusable
@Component
export struct CardView {
@State item: string = '';
aboutToReuse(params: Record<string, Object>): void {
this.item = params.item as string;
}
build() {
Column() {
Text(this.item)
.fontSize(30)
}
.borderWidth(1)
.height(100)
}
}
```
if使用场景
```typescript
@Entry
@Component
struct Index {
private dataSource = new MyDataSource<FriendMoment>();
aboutToAppear(): void {
for (let i = 0; i < 20; i++) {
let title = i + 1 + "test_if";
this.dataSource.pushData(new FriendMoment(i.toString(), title, 'app.media.app_icon'));
}
for (let i = 0; i < 50; i++) {
let title = i + 1 + "test_if";
this.dataSource.pushData(new FriendMoment(i.toString(), title, ''));
}
}
build() {
Column() {
// TopBar()
List({ space: 3 }) {
LazyForEach(this.dataSource, (moment: FriendMoment) => {
ListItem() {
// 使用reuseId进行组件复用的控制
OneMoment({ moment: moment })
.reuseId((moment.image !== '') ? 'withImage' : 'noImage')
}
}, (moment: FriendMoment) => moment.id)
}
.cachedCount(0)
}
}
}
class FriendMoment {
id: string = '';
text: string = '';
title: string = '';
image: string = '';
answers: Array<ResourceStr> = [];
constructor(id: string, title: string, image: string) {
this.text = id;
this.title = title;
this.image = image;
}
}
@Reusable
@Component
export struct OneMoment {
@Prop moment: FriendMoment;
// 复用id相同的同才能触发复用
aboutToReuse(params: ESObject): void {
console.log("=====aboutToReuse====OneMoment==复用了==" + this.moment.text);
}
build() {
Column() {
Text(this.moment.text)
// if分支判断
if (this.moment.image !== '') {
Flex({ wrap: FlexWrap.Wrap }) {
Image($r(this.moment.image)).height(50).width(50)
Image($r(this.moment.image)).height(50).width(50)
Image($r(this.moment.image)).height(50).width(50)
Image($r(this.moment.image)).height(50).width(50)
}
}
}
}
}
class BasicDataSource<T> implements IDataSource {
private listeners: DataChangeListener[] = [];
private originDataArray: T[] = [];
public totalCount(): number {
return 0;
}
public getData(index: number): T {
return this.originDataArray[index];
}
registerDataChangeListener(listener: DataChangeListener): void {
if (this.listeners.indexOf(listener) < 0) {
this.listeners.push(listener);
}
}
unregisterDataChangeListener(listener: DataChangeListener): void {
const pos = this.listeners.indexOf(listener);
if (pos >= 0) {
this.listeners.splice(pos, 1);
}
}
notifyDataAdd(index: number): void {
this.listeners.forEach(listener => {
listener.onDataAdd(index);
});
}
}
export class MyDataSource<T> extends BasicDataSource<T> {
private dataArray: T[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): T {
return this.dataArray[index];
}
public pushData(data: T): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
```
Foreach使用场景
```typescript
// xxx.ets
class MyDataSource implements IDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
}
public registerDataChangeListener(listener: DataChangeListener): void {
}
public unregisterDataChangeListener(listener: DataChangeListener): void {
}
}
@Entry
@Component
struct Index {
private data: MyDataSource = new MyDataSource();
private data02: MyDataSource = new MyDataSource();
@State isShow: boolean = true;
@State dataSource: ListItemObject[] = [];
aboutToAppear() {
for (let i = 0; i < 100; i++) {
this.data.pushData(i.toString());
}
for (let i = 30; i < 80; i++) {
this.data02.pushData(i.toString());
}
}
build() {
Column() {
Row() {
Button('clear').onClick(() => {
for (let i = 1; i < 50; i++) {
let obj = new ListItemObject();
obj.id = i;
obj.uuid = Math.random().toString();
obj.isExpand = false;
this.dataSource.pop();
}
}).height(40)
Button('update').onClick(() => {
for (let i = 1; i < 50; i++) {
let obj = new ListItemObject();
obj.id = i;
obj.uuid = Math.random().toString();
obj.isExpand = false;
this.dataSource.push(obj);
}
}).height(40)
}
List({ space: 10 }) {
ForEach(this.dataSource, (item: ListItemObject) => {
ListItem() {
ListItemView({
obj: item
})
}
}, (item: ListItemObject) => {
return item.uuid.toString();
})
}.cachedCount(0)
.width('100%')
.height('100%')
}
}
}
@Reusable
@Component
struct ListItemView {
@ObjectLink obj: ListItemObject;
@State item: string = '';
aboutToAppear(): void {
// 点击 update，首次进入，上下滑动，由于Foreach折叠展开属性，无法复用
console.log("=====aboutToAppear=====ListItemView==创建了==" + this.item);
}
aboutToReuse(params: ESObject) {
this.item = params.item;
// 点击 clear，再次update，复用成功
// 符合一帧内重复创建多个已被销毁的自定义组件
console.log("=====aboutToReuse====ListItemView==复用了==" + this.item);
}
build() {
Column({ space: 10 }) {
Text(`${this.obj.id}.标题`)
.fontSize(16)
.fontColor('#000000')
.padding({
top: 20,
bottom: 20,
})
if (this.obj.isExpand) {
Text('')
.fontSize(14)
.fontColor('#999999')
}
}
.width('100%')
.borderRadius(10)
.backgroundColor(Color.White)
.padding(15)
.onClick(() => {
this.obj.isExpand = !this.obj.isExpand;
})
}
}
@Observed
class ListItemObject {
uuid: string = "";
id: number = 0;
isExpand: boolean = false;
}
```
Grid使用场景
```typescript
// MyDataSource类实现IDataSource接口
class MyDataSource implements IDataSource {
private dataArray: number[] = [];
public pushData(data: number): void {
this.dataArray.push(data);
}
// 数据源的数据总量
public totalCount(): number {
return this.dataArray.length;
}
// 返回指定索引位置的数据
public getData(index: number): number {
return this.dataArray[index];
}
registerDataChangeListener(listener: DataChangeListener): void {
}
unregisterDataChangeListener(listener: DataChangeListener): void {
}
}
@Entry
@Component
struct MyComponent {
// 数据源
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 1; i < 1000; i++) {
this.data.pushData(i);
}
}
build() {
Column({ space: 5 }) {
Grid() {
LazyForEach(this.data, (item: number) => {
GridItem() {
// 使用可复用自定义组件
ReusableChildComponent({ item: item })
}
}, (item: string) => item)
}
.cachedCount(2) // 设置GridItem的缓存数量
.columnsTemplate('1fr 1fr 1fr')
.columnsGap(10)
.rowsGap(10)
.margin(10)
.height(500)
.backgroundColor(0xFAEEE0)
}
}
}
@Reusable
@Component
struct ReusableChildComponent {
@State item: number = 0;
// aboutToReuse从复用缓存中加入到组件树之前调用，可在此处更新组件的状态变量以展示正确的内容
// aboutToReuse参数类型已不支持any，这里使用Record指定明确的数据类型。Record用于构造一个对象类型，其属性键为Keys，属性值为Type
aboutToReuse(params: Record<string, number>) {
this.item = params.item;
}
build() {
Column() {
// 请开发者自行在src/main/resources/base/media路径下添加app.media.app_icon图片，否则运行时会因资源缺失而报错
Image($r('app.media.app_icon'))
.objectFit(ImageFit.Fill)
.layoutWeight(1)
Text(`图片${this.item}`)
.fontSize(16)
.textAlign(TextAlign.Center)
}
.width('100%')
.height(120)
.backgroundColor(0xF9CF93)
}
}
```
WaterFlow使用场景
```typescript
class WaterFlowDataSource implements IDataSource {
private dataArray: number[] = [];
private listeners: DataChangeListener[] = [];
constructor() {
for (let i = 0; i <= 60; i++) {
this.dataArray.push(i);
}
}
// 获取索引对应的数据
public getData(index: number): number {
return this.dataArray[index];
}
// 通知控制器增加数据
notifyDataAdd(index: number): void {
this.listeners.forEach(listener => {
listener.onDataAdd(index);
});
}
// 获取数据总数
public totalCount(): number {
return this.dataArray.length;
}
// 注册改变数据的控制器
registerDataChangeListener(listener: DataChangeListener): void {
if (this.listeners.indexOf(listener) < 0) {
this.listeners.push(listener);
}
}
// 注销改变数据的控制器
unregisterDataChangeListener(listener: DataChangeListener): void {
const pos = this.listeners.indexOf(listener);
if (pos >= 0) {
this.listeners.splice(pos, 1);
}
}
// 在数据尾部增加一个元素
public addLastItem(): void {
this.dataArray.splice(this.dataArray.length, 0, this.dataArray.length);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
@Reusable
@Component
struct ReusableFlowItem {
@State item: number = 0;
// 从复用缓存中加入到组件树之前调用，可在此处更新组件的状态变量以展示正确的内容
aboutToReuse(params: ESObject) {
this.item = params.item;
console.log("=====aboutToReuse====FlowItem==复用了==" + this.item);
}
aboutToRecycle(): void {
console.log("=====aboutToRecycle====FlowItem==回收了==" + this.item);
}
build() {
// 请开发者自行在src/main/resources/base/media路径下添加app.media.app_icon图片，否则运行时会因资源缺失而报错
Column() {
Text("N" + this.item).fontSize(24).height('26').margin(10)
Image($r('app.media.app_icon'))
.objectFit(ImageFit.Cover)
.width(50)
.height(50)
}
}
}
@Entry
@Component
struct Index {
@State minSize: number = 50;
@State maxSize: number = 80;
@State fontSize: number = 24;
@State colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F];
scroller: Scroller = new Scroller();
dataSource: WaterFlowDataSource = new WaterFlowDataSource();
private itemWidthArray: number[] = [];
private itemHeightArray: number[] = [];
// 计算flow item宽/高
getSize() {
let ret = Math.floor(Math.random() * this.maxSize);
return (ret > this.minSize ? ret : this.minSize);
}
// 保存flow item宽/高
getItemSizeArray() {
for (let i = 0; i < 100; i++) {
this.itemWidthArray.push(this.getSize());
this.itemHeightArray.push(this.getSize());
}
}
aboutToAppear() {
this.getItemSizeArray();
}
build() {
Stack({ alignContent: Alignment.TopStart }) {
Column({ space: 2 }) {
Button('back top')
.height('5%')
.onClick(() => { // 点击后回到顶部
this.scroller.scrollEdge(Edge.Top);
})
WaterFlow({ scroller: this.scroller }) {
LazyForEach(this.dataSource, (item: number) => {
FlowItem() {
ReusableFlowItem({ item: item })
}.onAppear(() => {
if (item + 20 == this.dataSource.totalCount()) {
for (let i = 0; i < 50; i++) {
this.dataSource.addLastItem();
}
}
})
})
}
}
}
}
@Builder
itemFoot() {
Column() {
Text(`Footer`)
.fontSize(10)
.backgroundColor(Color.Red)
.width(50)
.height(50)
.align(Alignment.Center)
.margin({ top: 2 })
}
}
}
```
Swiper使用场景
```typescript
@Entry
@Component
struct Index {
private dataSource = new MyDataSource<Question>();
aboutToAppear(): void {
for (let i = 0; i < 1000; i++) {
let title = i + 1 + "test_swiper";
let answers = ["test1", "test2", "test3",
"test4"];
// 请开发者自行在src/main/resources/base/media路径下添加app.media.app_icon图片，否则运行时会因资源缺失而报错
this.dataSource.pushData(new Question(i.toString(), title, $r('app.media.app_icon'), answers));
}
}
build() {
Column({ space: 5 }) {
Swiper() {
LazyForEach(this.dataSource, (item: Question) => {
QuestionSwiperItem({ itemData: item })
}, (item: Question) => item.id)
}
}
.width('100%')
.margin({ top: 5 })
}
}
class Question {
id: string = '';
title: ResourceStr = '';
image: ResourceStr = '';
answers: Array<ResourceStr> = [];
constructor(id: string, title: ResourceStr, image: ResourceStr, answers: Array<ResourceStr>) {
this.id = id;
this.title = title;
this.image = image;
this.answers = answers;
}
}
@Reusable
@Component
struct QuestionSwiperItem {
@State itemData: Question | null = null;
aboutToReuse(params: Record<string, Object>): void {
this.itemData = params.itemData as Question;
console.info("===test===aboutToReuse====QuestionSwiperItem==");
}
build() {
Column() {
Text(this.itemData?.title)
.fontSize(18)
.fontColor($r('sys.color.ohos_id_color_primary'))
.alignSelf(ItemAlign.Start)
.margin({
top: 10,
bottom: 16
})
Image(this.itemData?.image)
.width('100%')
.borderRadius(12)
.objectFit(ImageFit.Contain)
.margin({
bottom: 16
})
.height(80)
.width(80)
Column({ space: 16 }) {
ForEach(this.itemData?.answers, (item: Resource) => {
Text(item)
.fontSize(16)
.fontColor($r('sys.color.ohos_id_color_primary'))
}, (item: ResourceStr) => JSON.stringify(item))
}
.width('100%')
.alignItems(HorizontalAlign.Start)
}
.width('100%')
.padding({
left: 16,
right: 16
})
}
}
class BasicDataSource<T> implements IDataSource {
private listeners: DataChangeListener[] = [];
private originDataArray: T[] = [];
public totalCount(): number {
return 0;
}
public getData(index: number): T {
return this.originDataArray[index];
}
registerDataChangeListener(listener: DataChangeListener): void {
if (this.listeners.indexOf(listener) < 0) {
this.listeners.push(listener);
}
}
unregisterDataChangeListener(listener: DataChangeListener): void {
const pos = this.listeners.indexOf(listener);
if (pos >= 0) {
this.listeners.splice(pos, 1);
}
}
notifyDataAdd(index: number): void {
this.listeners.forEach(listener => {
listener.onDataAdd(index);
});
}
}
export class MyDataSource<T> extends BasicDataSource<T> {
private dataArray: T[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): T {
return this.dataArray[index];
}
public pushData(data: T): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
```
ListItemGroup使用场景
```typescript
@Entry
@Component
struct ListItemGroupAndReusable {
data: DataSrc2 = new DataSrc2();
@Builder
itemHead(text: string) {
Text(text)
.fontSize(20)
.backgroundColor(0xAABBCC)
.width('100%')
.padding(10)
}
aboutToAppear() {
for (let i = 0; i < 10000; i++) {
let data_1 = new DataSrc1();
for (let j = 0; j < 12; j++) {
data_1.Data.push(`测试条目数据: ${i} - ${j}`);
}
this.data.Data.push(data_1);
}
}
build() {
Stack() {
List() {
LazyForEach(this.data, (item: DataSrc1, index: number) => {
ListItemGroup({ header: this.itemHead(index.toString()) }) {
LazyForEach(item, (ii: string, index: number) => {
ListItem() {
Inner({ str: ii })
}
})
}
.width('100%')
.height('60vp')
})
}
}
.width('100%')
.height('100%')
}
}
@Reusable
@Component
struct Inner {
@State str: string = '';
aboutToReuse(param: ESObject) {
this.str = param.str;
}
build() {
Text(this.str)
}
}
class DataSrc1 implements IDataSource {
listeners: DataChangeListener[] = [];
Data: string[] = [];
public totalCount(): number {
return this.Data.length;
}
public getData(index: number): string {
return this.Data[index];
}
// 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听
registerDataChangeListener(listener: DataChangeListener): void {
if (this.listeners.indexOf(listener) < 0) {
this.listeners.push(listener);
}
}
// 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听
unregisterDataChangeListener(listener: DataChangeListener): void {
const pos = this.listeners.indexOf(listener);
if (pos >= 0) {
this.listeners.splice(pos, 1);
}
}
// 通知LazyForEach组件需要重载所有子组件
notifyDataReload(): void {
this.listeners.forEach(listener => {
listener.onDataReloaded();
});
}
// 通知LazyForEach组件需要在index对应索引处添加子组件
notifyDataAdd(index: number): void {
this.listeners.forEach(listener => {
listener.onDataAdd(index);
});
}
// 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件
notifyDataChange(index: number): void {
this.listeners.forEach(listener => {
listener.onDataChange(index);
});
}
// 通知LazyForEach组件需要在index对应索引处删除该子组件
notifyDataDelete(index: number): void {
this.listeners.forEach(listener => {
listener.onDataDelete(index);
});
}
// 通知LazyForEach组件将from索引和to索引处的子组件进行交换
notifyDataMove(from: number, to: number): void {
this.listeners.forEach(listener => {
listener.onDataMove(from, to);
});
}
}
class DataSrc2 implements IDataSource {
listeners: DataChangeListener[] = [];
Data: DataSrc1[] = [];
public totalCount(): number {
return this.Data.length;
}
public getData(index: number): DataSrc1 {
return this.Data[index];
}
// 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听
registerDataChangeListener(listener: DataChangeListener): void {
if (this.listeners.indexOf(listener) < 0) {
this.listeners.push(listener);
}
}
// 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听
unregisterDataChangeListener(listener: DataChangeListener): void {
const pos = this.listeners.indexOf(listener);
if (pos >= 0) {
this.listeners.splice(pos, 1);
}
}
// 通知LazyForEach组件需要重载所有子组件
notifyDataReload(): void {
this.listeners.forEach(listener => {
listener.onDataReloaded();
});
}
// 通知LazyForEach组件需要在index对应索引处添加子组件
notifyDataAdd(index: number): void {
this.listeners.forEach(listener => {
listener.onDataAdd(index);
});
}
// 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件
notifyDataChange(index: number): void {
this.listeners.forEach(listener => {
listener.onDataChange(index);
});
}
// 通知LazyForEach组件需要在index对应索引处删除该子组件
notifyDataDelete(index: number): void {
this.listeners.forEach(listener => {
listener.onDataDelete(index);
});
}
// 通知LazyForEach组件将from索引和to索引处的子组件进行交换
notifyDataMove(from: number, to: number): void {
this.listeners.forEach(listener => {
listener.onDataMove(from, to);
});
}
}
```
多种条目类型使用场景
标准型
有限变化型
```typescript
class MyDataSource implements IDataSource {
private dataArray: string[] = [];
private listener: DataChangeListener | undefined;
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
}
public reloadListener(): void {
this.listener?.onDataReloaded();
}
public registerDataChangeListener(listener: DataChangeListener): void {
this.listener = listener;
}
public unregisterDataChangeListener(listener: DataChangeListener): void {
this.listener = undefined;
}
}
@Entry
@Component
struct Index {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i < 1000; i++) {
this.data.pushData(i + "");
}
}
build() {
Column() {
List({ space: 10 }) {
LazyForEach(this.data, (item: number) => {
ListItem() {
ReusableComponent({ item: item })
.reuseId(item % 2 === 0 ? 'ReusableComponentOne' : 'ReusableComponentTwo')
}
.backgroundColor(Color.Orange)
.width('100%')
}, (item: number) => item.toString())
}
.cachedCount(2)
}
}
}
@Reusable
@Component
struct ReusableComponent {
@State item: number = 0;
aboutToReuse(params: ESObject) {
this.item = params.item;
}
build() {
Column() {
if (this.item % 2 === 0) {
Text(`Item ${this.item} ReusableComponentOne`)
.fontSize(20)
.margin({ left: 10 })
} else {
Text(`Item ${this.item} ReusableComponentTwo`)
.fontSize(20)
.margin({ left: 10 })
}
}.margin({ left: 10, right: 10 })
}
}
```
组合型
```typescript
class MyDataSource implements IDataSource {
private dataArray: string[] = [];
private listener: DataChangeListener | undefined;
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
}
public reloadListener(): void {
this.listener?.onDataReloaded();
}
public registerDataChangeListener(listener: DataChangeListener): void {
this.listener = listener;
}
public unregisterDataChangeListener(listener: DataChangeListener): void {
this.listener = undefined;
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i < 1000; i++) {
this.data.pushData(i.toString());
}
}
// itemBuilderOne作为复用组件的写法未展示，以下为转为Builder之后的写法
@Builder
itemBuilderOne(item: string) {
Column() {
ChildComponentA({ item: item })
ChildComponentB({ item: item })
ChildComponentC({ item: item })
}
}
// itemBuilderTwo转为Builder之后的写法
@Builder
itemBuilderTwo(item: string) {
Column() {
ChildComponentA({ item: item })
ChildComponentC({ item: item })
ChildComponentD({ item: item })
}
}
// itemBuilderThree转为Builder之后的写法
@Builder
itemBuilderThree(item: string) {
Column() {
ChildComponentA({ item: item })
ChildComponentB({ item: item })
ChildComponentD({ item: item })
}
}
build() {
List({ space: 40 }) {
LazyForEach(this.data, (item: string, index: number) => {
ListItem() {
if (index % 3 === 0) {
this.itemBuilderOne(item)
} else if (index % 5 === 0) {
this.itemBuilderTwo(item)
} else {
this.itemBuilderThree(item)
}
}
.backgroundColor('#cccccc')
.width('100%')
.onAppear(() => {
console.log(`ListItem ${index} onAppear`);
})
}, (item: number) => item.toString())
}
.width('100%')
.height('100%')
.cachedCount(0)
}
}
@Reusable
@Component
struct ChildComponentA {
@State item: string = '';
aboutToReuse(params: ESObject) {
console.log(`ChildComponentA ${params.item} Reuse ${this.item}`);
this.item = params.item;
}
aboutToRecycle(): void {
console.log(`ChildComponentA ${this.item} Recycle`);
}
build() {
Column() {
Text(`Item ${this.item} Child Component A`)
.fontSize(20)
.margin({ left: 10 })
.fontColor(Color.Blue)
Grid() {
ForEach((new Array(20)).fill(''), (item: string, index: number) => {
GridItem() {
// 请开发者自行在src/main/resources/base/media路径下添加app.media.startIcon图片，否则运行时会因资源缺失而报错
Image($r('app.media.startIcon'))
.height(20)
}
})
}
.columnsTemplate('1fr 1fr 1fr 1fr 1fr')
.rowsTemplate('1fr 1fr 1fr 1fr')
.columnsGap(10)
.width('90%')
.height(160)
}
.margin({ left: 10, right: 10 })
.backgroundColor(0xFAEEE0)
}
}
@Reusable
@Component
struct ChildComponentB {
@State item: string = '';
aboutToReuse(params: ESObject) {
this.item = params.item;
}
build() {
Row() {
Text(`Item ${this.item} Child Component B`)
.fontSize(20)
.margin({ left: 10 })
.fontColor(Color.Red)
}.margin({ left: 10, right: 10 })
}
}
@Reusable
@Component
struct ChildComponentC {
@State item: string = '';
aboutToReuse(params: ESObject) {
this.item = params.item;
}
build() {
Row() {
Text(`Item ${this.item} Child Component C`)
.fontSize(20)
.margin({ left: 10 })
.fontColor(Color.Green)
}.margin({ left: 10, right: 10 })
}
}
@Reusable
@Component
struct ChildComponentD {
@State item: string = '';
aboutToReuse(params: ESObject) {
this.item = params.item;
}
build() {
Row() {
Text(`Item ${this.item} Child Component D`)
.fontSize(20)
.margin({ left: 10 })
.fontColor(Color.Orange)
}.margin({ left: 10, right: 10 })
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state-management
爬取时间: 2025-04-28 06:55:13
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state-management-overview
爬取时间: 2025-04-28 06:55:27
来源: Huawei Developer
在前文的描述中，我们构建的页面多为静态界面。如果希望构建一个动态的、有交互的界面，就需要引入“状态”的概念。
图1效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163821.96942459719923237428002021844518:50001231000000:2800:4318F849DA677CAEC2E17F606AF195BA1FC0DA83096D496377C97502DB9F1036.gif)
上面的示例中，用户与应用程序的交互触发了文本状态变更，状态变更引起了UI渲染，UI从“Hello World”变更为“Hello ArkUI”。
在声明式UI编程框架中，UI是程序状态的运行结果，用户构建了一个UI模型，其中应用的运行时的状态是参数。当参数改变时，UI作为返回结果，也将进行对应的改变。这些运行时的状态变化所带来的UI的重新渲染，在ArkUI中统称为状态管理机制。
自定义组件拥有变量，变量必须被装饰器装饰才可以成为状态变量，状态变量的改变会引起UI的渲染刷新。如果不使用状态变量，UI只能在初始化时渲染，后续将不会再刷新。 下图展示了State和View（UI）之间的关系。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163821.42429065210039519084161041677420:50001231000000:2800:F9E4F255BF26E4B60283B87E884FBF0B67A46E2B7044E658AD3140626C143430.png)
-  View(UI)：UI渲染，指将build方法内的UI描述和@Builder装饰的方法内的UI描述映射到界面。
-  State：状态，指驱动UI更新的数据。用户通过触发组件的事件方法，改变状态数据。状态数据的改变，引起UI的重新渲染。
在阅读状态管理文档前，开发者需要对UI范式基本语法有基本的了解。建议提前阅读：基本语法概述，声明式UI描述，自定义组件-创建自定义组件。
基本概念
-  状态变量：被状态装饰器装饰的变量，状态变量值的改变会引起UI的渲染更新。示例：@State num: number = 1,其中，@State是状态装饰器，num是状态变量。
-  常规变量：没有被状态装饰器装饰的变量，通常应用于辅助计算。它的改变永远不会引起UI的刷新。以下示例中increaseBy变量为常规变量。
-  数据源/同步源：状态变量的原始来源，可以同步给不同的状态数据。通常意义为父组件传给子组件的数据。以下示例中数据源为count: 1。
-  命名参数机制：父组件通过指定参数传递给子组件的状态变量，为父子传递同步参数的主要手段。示例：CompA({ aProp: this.aProp })。
-  从父组件初始化：父组件使用命名参数机制，将指定参数传递给子组件。子组件初始化的默认值在有父组件传值的情况下，会被覆盖。示例：
```typescript
@Component
struct MyComponent {
@State count: number = 0;
private increaseBy: number = 1;
build() {
}
}
@Entry
@Component
struct Parent {
build() {
Column() {
// 从父组件初始化，覆盖本地定义的默认值
MyComponent({ count: 1, increaseBy: 2 })
}
}
}
```
-  初始化子组件：父组件中状态变量可以传递给子组件，初始化子组件对应的状态变量。示例同上。
-  本地初始化：在变量声明的时候赋值，作为变量的默认值。示例：@State count: number = 0。
当前状态管理的功能仅支持在UI主线程使用，不能在子线程、worker、taskpool中使用。
状态管理（V1）
开发者可以选择使用状态管理V1版本进行应用开发。
装饰器总览
ArkUI状态管理V1提供了多种装饰器，通过使用这些装饰器，状态变量不仅可以观察在组件内的改变，还可以在不同组件层级间传递，比如父子组件、跨组件层级，也可以观察全局范围内的变化。根据状态变量的影响范围，将所有的装饰器可以大致分为：
-  管理组件内状态的装饰器：组件级别的状态管理，可以观察同一个组件树上（即同一个页面内）组件内或不同组件层级的变量变化。
-  管理应用级状态的装饰器：应用级别的状态管理，可以观察不同页面，甚至不同UIAbility的状态变化，是应用内全局的状态管理。
从数据的传递形式和同步类型层面看，装饰器也可分为：
-  只读的单向传递；
-  可变更的双向传递。
图示如下，具体装饰器的介绍，可详见管理组件拥有的状态和管理应用拥有的状态。开发者可以灵活地利用这些能力来实现数据和UI的联动。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163822.25098057410046797187430022792995:50001231000000:2800:1F28D38096EED8355B3823B3615D1074CF94D67F1B3498EB9E81F25EDABF1928.png)
上图中，Components部分的装饰器为组件级别的状态管理，Application部分为应用的状态管理。开发者可以通过@StorageLink/@LocalStorageLink实现应用和组件状态的双向同步，通过@StorageProp/@LocalStorageProp实现应用和组件状态的单向同步。
管理组件拥有的状态，即图中Components级别的状态管理：
-  @State：@State装饰的变量拥有其所属组件的状态，可以作为其子组件单向和双向同步的数据源。当其数值改变时，会引起相关组件的渲染刷新。
-  @Prop：@Prop装饰的变量可以和父组件建立单向同步关系，@Prop装饰的变量是可变的，但修改不会同步回父组件。
-  @Link：@Link装饰的变量可以和父组件建立双向同步关系，子组件中@Link装饰变量的修改会同步给父组件中建立双向数据绑定的数据源，父组件的更新也会同步给@Link装饰的变量。
-  @Provide/@Consume：@Provide/@Consume装饰的变量用于跨组件层级（多层组件）同步状态变量，可以不需要通过参数命名机制传递，通过alias（别名）或者属性名绑定。
-  @Observed：@Observed装饰class，需要观察多层嵌套场景的class需要被@Observed装饰。单独使用@Observed没有任何作用，需要和@ObjectLink、@Prop联用。
-  @ObjectLink：@ObjectLink装饰的变量接收@Observed装饰的class的实例，应用于观察多层嵌套场景，和父组件的数据源构建双向同步。
仅@Observed/@ObjectLink可以观察嵌套场景，其他的状态变量仅能观察第一层，详情见各个装饰器章节的“观察变化和行为表现”小节。
管理应用拥有的状态，即图中Application级别的状态管理：
-  AppStorage是应用程序中的一个特殊的单例LocalStorage对象，是应用级的数据库，和进程绑定，通过@StorageProp和@StorageLink装饰器可以和组件联动。
-  AppStorage是应用状态的“中枢”，将需要与组件（UI）交互的数据存入AppStorage，比如持久化数据PersistentStorage和环境变量Environment。UI再通过AppStorage提供的装饰器或者API接口，访问这些数据。
-  框架还提供了LocalStorage，AppStorage是LocalStorage特殊的单例。LocalStorage是应用程序声明的应用状态的内存“数据库”，通常用于页面级的状态共享，通过@LocalStorageProp和@LocalStorageLink装饰器可以和UI联动。
其他状态管理V1功能
@Watch用于监听状态变量的变化。
$$运算符：给系统组件提供TS变量的引用，使得TS变量和系统组件的内部状态保持同步。
状态管理（V2）
为了增强状态管理V1版本的部分能力，例如深度观察、属性级更新等，ArkUI推出状态管理V2供开发者使用。
状态管理V1现状以及V2优点
状态管理V1使用代理观察数据，当创建一个状态变量时，同时也创建了一个数据代理观察者。该观察者可感知代理变化，但无法感知实际数据变化，因此在使用上有如下限制：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163822.57653239206737586011706995940837:50001231000000:2800:B970FFD567D4975D3719ABA1738ECA1D284000A1DFC925A324C97B0B808F8FC9.png)
状态管理V2将观察能力增强到数据本身，数据本身就是可观察的，更改数据会触发相应的视图的更新。相较于状态管理V1，状态管理V2有如下优点：
-  状态变量独立于UI，更改数据会触发相应视图的更新。
-  支持对象的深度观测和深度监听，且深度观测机制不影响观测性能。
-  支持对象中属性级精准更新及数组中元素的最小化更新。
-  装饰器易用性高、拓展性强，在组件中明确输入与输出，有利于组件化。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163822.79789888342365966083230890606757:50001231000000:2800:DA22FD85A912117D0298A704E629D47359E67F35DEFC3EAC4FD889088FA29B9D.png)
装饰器总览
状态管理（V2）提供了一套全新的装饰器。
-  @ObservedV2：@ObservedV2装饰器装饰class，使得被装饰的class具有深度监听的能力。@ObservedV2和@Trace配合使用可以使class中的属性具有深度观测的能力。
-  @Trace：@Trace装饰器装饰被@ObservedV2装饰的class中的属性，被装饰的属性具有深度观测的能力。
-  @ComponentV2：使用@ComponentV2装饰的struct中能使用新的装饰器。例如：@Local、@Param、@Event、@Once、@Monitor、@Provider、@Consumer。
-  @Local：@Local装饰的变量为组件内部状态，无法从外部初始化。
-  @Param：@Param装饰的变量作为组件的输入，可以接受从外部传入初始化并同步。
-  @Once：@Once装饰的变量仅初始化时同步一次，需要与@Param一起使用。
-  @Event：@Event装饰方法类型，作为组件输出，可以通过该方法影响父组件中变量。
-  @Monitor：@Monitor装饰器用于@ComponentV2装饰的自定义组件或@ObservedV2装饰的类中，能够对状态变量进行深度监听。
-  @Provider和@Consumer：用于跨组件层级双向同步。
-  @Computed：计算属性，在被计算的值变化的时候，只会计算一次。主要应用于解决UI多次重用该属性从而重复计算导致的性能问题。
-  !!语法：双向绑定语法糖。
状态管理V1与V2能力对比
| V1能力 | V2能力 | 说明 |
| --- | --- | --- |
| @Observed | @ObservedV2 |  表明当前对象为可观察对象。但两者能力并不相同。 @Observed可观察第一层的属性，需要搭配@ObjectLink使用才能生效。 @ObservedV2本身无观察能力，仅代表当前class可被观察，如果要观察其属性，需要搭配@Trace使用。 |
| @Track | @Trace |  V1装饰器@Track为精确观察，不使用则无法做到类属性的精准观察。 V2@Trace装饰的属性可以被精确跟踪观察。 |
| @Component | @ComponentV2 |  @Component为搭配V1状态变量使用的自定义组件装饰器。 @ComponentV2为搭配V2状态变量使用的自定义组件装饰器。 |
| @State |  无外部初始化：@Local 外部初始化一次：@Param@Once | @State和@Local类似都是数据源的概念，区别是@State可以外部传入初始化，而@Local无法外部传入初始化。 |
| @Prop | @Param | @Prop和@Param类似都是自定义组件参数的概念。当输入参数为复杂类型时，@Prop为深拷贝，@Param为引用。 |
| @Link | @Param@Event | @Link是框架自己封装实现的双向同步，对于V2开发者可以通过@Param@Event自己实现双向同步。 |
| @ObjectLink | @Param | 直接兼容，@ObjectLink需要被@Observed装饰的class的实例初始化，@Param没有此限制。 |
| @Provide | @Provider | 兼容。 |
| @Consume | @Consumer | 兼容。 |
| @Watch | @Monitor |  @Watch用于监听V1状态变量的变化，具有监听状态变量本身和其第一层属性变化的能力。状态变量可观察到的变化会触发其@Watch监听事件。 @Monitor用于监听V2状态变量的变化，搭配@Trace使用，可有深层监听的能力。状态变量在一次事件中多次变化时，仅会以最终的结果判断是否触发@Monitor监听事件。 |
| LocalStorage | 全局@ObservedV2@Trace | 兼容。 |
| AppStorage | AppStorageV2 | 兼容。 |
| Environment | 调用Ability接口获取系统环境变量 | Environment获取环境变量能力和AppStorage耦合。在V2中可直接调用Ability接口获取系统环境变量。 |
| PersistentStorage | PersistenceV2 | PersistentStorage持久化能力和AppStorage耦合，PersistenceV2持久化能力可独立使用。 |
| 自定义组件生命周期 | 自定义组件生命周期 | 均支持。aboutToAppear、onDidBuild、aboutToDisappear。 |
| 页面生命周期 | 页面生命周期 | 均支持。onPageShow、onPageHide、onBackPress。 |
| @Reusable | 暂未提供 | 组件复用。包括：aboutToReuse、aboutToRecycle。 |
| $$ | !! | 双向绑定。V2建议使用!!实现双向绑定。 |
| @CustomDialog | openCustomDialog接口 | 自定义弹窗。V2建议使用openCustomDialog实现自定义弹窗功能。 |
| withTheme | 暂未提供 | 主题。用于设置应用局部页面自定义主题风格。包括：onWillApplyTheme。 |
| 高级组件 | 暂未提供 | 高级组件。例如：DownloadFileButton、ProgressButton、SegmentButton。 |
| animateTo | 部分场景不支持 | 当前某些场景下，在状态管理V2中使用animateTo动画，会产生异常效果，详见：在状态管理V2中使用animateTo动画效果异常。 |
表明当前对象为可观察对象。但两者能力并不相同。
@Observed可观察第一层的属性，需要搭配@ObjectLink使用才能生效。
@ObservedV2本身无观察能力，仅代表当前class可被观察，如果要观察其属性，需要搭配@Trace使用。
V1装饰器@Track为精确观察，不使用则无法做到类属性的精准观察。
V2@Trace装饰的属性可以被精确跟踪观察。
@Component为搭配V1状态变量使用的自定义组件装饰器。
@ComponentV2为搭配V2状态变量使用的自定义组件装饰器。
无外部初始化：@Local
外部初始化一次：@Param@Once
@Watch用于监听V1状态变量的变化，具有监听状态变量本身和其第一层属性变化的能力。状态变量可观察到的变化会触发其@Watch监听事件。
@Monitor用于监听V2状态变量的变化，搭配@Trace使用，可有深层监听的能力。状态变量在一次事件中多次变化时，仅会以最终的结果判断是否触发@Monitor监听事件。
有关V1向V2的迁移可参考迁移指导，有关V1与V2的混用可参考混用文档。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state-management-v1
爬取时间: 2025-04-28 06:55:45
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state-management-v2
爬取时间: 2025-04-28 06:55:58
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-v2-decorators
爬取时间: 2025-04-28 06:56:12
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-observedv2-and-trace
爬取时间: 2025-04-28 06:56:25
来源: Huawei Developer
为了增强状态管理框架对类对象中属性的观测能力，开发者可以使用@ObservedV2装饰器和@Trace装饰器装饰类以及类中的属性。
@ObservedV2和@Trace提供了对嵌套类对象属性变化直接观测的能力，是状态管理V2中相对核心的能力之一。在阅读本文档前，建议提前阅读：状态管理概述来了解状态管理V2整体的能力架构。
@ObservedV2与@Trace装饰器从API version 12开始支持。
概述
@ObservedV2装饰器与@Trace装饰器用于装饰类以及类中的属性，使得被装饰的类和属性具有深度观测的能力：
状态管理V1版本对嵌套类对象属性变化直接观测的局限性
现有状态管理V1版本无法实现对嵌套类对象属性变化的直接观测。
```typescript
@Observed
class Father {
son: Son;
constructor(name: string, age: number) {
this.son = new Son(name, age);
}
}
@Observed
class Son {
name: string;
age: number;
constructor(name: string, age: number) {
this.name = name;
this.age = age;
}
}
@Entry
@Component
struct Index {
@State father: Father = new Father("John", 8);
build() {
Row() {
Column() {
Text(`name: ${this.father.son.name} age: ${this.father.son.age}`)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.father.son.age++;
})
}
.width('100%')
}
.height('100%')
}
}
```
上述代码中，点击Text组件增加age的值时，不会触发UI刷新。因为在现有的状态管理框架下，无法观测到嵌套类中属性age的值变化。V1版本的解决方案是使用@ObjectLink装饰器与自定义组件的方式实现观测。
```typescript
@Observed
class Father {
son: Son;
constructor(name: string, age: number) {
this.son = new Son(name, age);
}
}
@Observed
class Son {
name: string;
age: number;
constructor(name: string, age: number) {
this.name = name;
this.age = age;
}
}
@Component
struct Child {
@ObjectLink son: Son;
build() {
Row() {
Column() {
Text(`name: ${this.son.name} age: ${this.son.age}`)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.son.age++;
})
}
.width('100%')
}
.height('100%')
}
}
@Entry
@Component
struct Index {
@State father: Father = new Father("John", 8);
build() {
Column() {
Child({son: this.father.son})
}
}
}
```
通过这种方式虽然能够实现对嵌套类中属性变化的观测，但是当嵌套层级较深时，代码将会变得十分复杂，易用性差。因此推出类装饰器@ObservedV2与成员变量装饰器@Trace，增强对嵌套类中属性变化的观测能力。
装饰器说明
| @ObservedV2类装饰器 | 说明 |
| --- | --- |
| 装饰器参数 | 无。 |
| 类装饰器 | 装饰class。需要放在class的定义前，使用new创建类对象。 |
| @Trace成员变量装饰器 | 说明 |
| --- | --- |
| 装饰器参数 | 无。 |
| 可装饰的变量 | class中成员属性。属性的类型可以为number、string、boolean、class、Array、Date、Map、Set等类型。 |
观察变化
使用@ObservedV2装饰的类中被@Trace装饰的属性具有被观测变化的能力，当该属性值变化时，会触发该属性绑定的UI组件刷新。
```typescript
@ObservedV2
class Son {
@Trace age: number = 100;
}
class Father {
son: Son = new Son();
}
@Entry
@ComponentV2
struct Index {
father: Father = new Father();
build() {
Column() {
// 当点击改变age时，Text组件会刷新
Text(`${this.father.son.age}`)
.onClick(() => {
this.father.son.age++;
})
}
}
}
```
```typescript
@ObservedV2
class Father {
@Trace name: string = "Tom";
}
class Son extends Father {
}
@Entry
@ComponentV2
struct Index {
son: Son = new Son();
build() {
Column() {
// 当点击改变name时，Text组件会刷新
Text(`${this.son.name}`)
.onClick(() => {
this.son.name = "Jack";
})
}
}
}
```
```typescript
@ObservedV2
class Manager {
@Trace static count: number = 1;
}
@Entry
@ComponentV2
struct Index {
build() {
Column() {
// 当点击改变count时，Text组件会刷新
Text(`${Manager.count}`)
.onClick(() => {
Manager.count++;
})
}
}
}
```
-  @Trace装饰内置类型时，可以观测各自API导致的变化：
| 类型 | 可观测变化的API |
| --- | --- |
| Array | push、pop、shift、unshift、splice、copyWithin、fill、reverse、sort |
| Date | setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds |
| Map | set, clear, delete |
| Set | add, clear, delete |
使用限制
@ObservedV2与@Trace装饰器存在以下使用限制：
```typescript
@ObservedV2
class Person {
id: number = 0;
@Trace age: number = 8;
}
@Entry
@ComponentV2
struct Index {
person: Person = new Person();
build() {
Column() {
// age被@Trace装饰，用在UI中可以触发UI刷新
Text(`${this.person.age}`)
.onClick(() => {
this.person.age++; // 点击会触发UI刷新
})
// id未被@Trace装饰，用在UI中不会触发UI刷新
Text(`${this.person.id}`) // 当id变化时不会刷新
.onClick(() => {
this.person.id++; // 点击不会触发UI刷新
})
}
}
}
```
```typescript
@ObservedV2 // 错误用法，编译时报错
struct Index {
build() {
}
}
```
```typescript
class User {
id: number = 0;
@Trace name: string = "Tom"; // 错误用法，编译时报错
}
```
```typescript
@ComponentV2
struct Comp {
@Trace message: string = "Hello World"; // 错误用法，编译时报错
build() {
}
}
```
```typescript
@Observed
class User {
@Trace name: string = "Tom"; // 错误用法，编译时报错
}
@ObservedV2
class Person {
@Track name: string = "Jack"; // 错误用法，编译时报错
}
```
```typescript
// 以@State装饰器为例
@ObservedV2
class Job {
@Trace jobName: string = "Teacher";
}
@ObservedV2
class Info {
@Trace name: string = "Tom";
@Trace age: number = 25;
job: Job = new Job();
}
@Entry
@Component
struct Index {
@State info: Info = new Info(); // 无法混用，编译时报错
build() {
Column() {
Text(`name: ${this.info.name}`)
Text(`age: ${this.info.age}`)
Text(`jobName: ${this.info.job.jobName}`)
Button("change age")
.onClick(() => {
this.info.age++;
})
Button("Change job")
.onClick(() => {
this.info.job.jobName = "Doctor";
})
}
}
}
```
```typescript
// 以@State装饰器为例
@ObservedV2
class Job {
@Trace jobName: string = "Teacher";
}
@ObservedV2
class Info {
@Trace name: string = "Tom";
@Trace age: number = 25;
job: Job = new Job();
}
class Message extends Info {
constructor() {
super();
}
}
@Entry
@Component
struct Index {
@State message: Message = new Message(); // 无法混用，运行时报错
build() {
Column() {
Text(`name: ${this.message.name}`)
Text(`age: ${this.message.age}`)
Text(`jobName: ${this.message.job.jobName}`)
Button("change age")
.onClick(() => {
this.message.age++;
})
Button("Change job")
.onClick(() => {
this.message.job.jobName = "Doctor";
})
}
}
}
```
使用场景
嵌套类场景
在下面的嵌套类场景中，Pencil类是Son类中最里层的类，Pencil类被@ObservedV2装饰且属性length被@Trace装饰，此时length的变化能够被观测到。
@Trace装饰器与现有状态管理框架的@Track与@State装饰器的能力不同，@Track使class具有属性级更新的能力，但并不具备深度观测的能力；而@State只能观测到对象本身以及第一层的变化，对于多层嵌套场景只能通过封装自定义组件，搭配@Observed和@ObjectLink来实现观测。
```typescript
@ObservedV2
class Pencil {
@Trace length: number = 21; // 当length变化时，会刷新关联的组件
}
class Bag {
width: number = 50;
height: number = 60;
pencil: Pencil = new Pencil();
}
class Son {
age: number = 5;
school: string = "some";
bag: Bag = new Bag();
}
@Entry
@ComponentV2
struct Page {
son: Son = new Son();
renderTimes: number = 0;
isRender(id: number): number {
console.info(`id: ${id} renderTimes: ${this.renderTimes}`);
this.renderTimes++;
return 40;
}
build() {
Column() {
Text('pencil length'+ this.son.bag.pencil.length)
.fontSize(this.isRender(1))   // UINode (1)
Button("change length")
.onClick(() => {
// 点击更改length值，UINode（1）会刷新
this.son.bag.pencil.length += 100;
})
Button("assign Son")
.onClick(() => {
// 由于变量son非状态变量，因此无法刷新UINode（1）
this.son = new Son();
})
}
}
}
```
继承类场景
@Trace支持在类的继承场景中使用，无论是在基类还是继承类中，只有被@Trace装饰的属性才具有被观测变化的能力。
以下例子中，声明class GrandFather、Father、Uncle、Son、Cousin，继承关系如下图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163830.55942624572673036066192647527479:50001231000000:2800:0EF83905C3CD590A66CE7BC45CB58F9F51A87524770EAC60D8C835B35D6549EA.png)
创建类Son和类Cousin的实例，点击Button('change Son age')和Button('change Cousin age')可以触发UI的刷新。
```typescript
@ObservedV2
class GrandFather {
@Trace age: number = 0;
constructor(age: number) {
this.age = age;
}
}
class Father extends GrandFather{
constructor(father: number) {
super(father);
}
}
class Uncle extends GrandFather {
constructor(uncle: number) {
super(uncle);
}
}
class Son extends Father {
constructor(son: number) {
super(son);
}
}
class Cousin extends Uncle {
constructor(cousin: number) {
super(cousin);
}
}
@Entry
@ComponentV2
struct Index {
son: Son = new Son(0);
cousin: Cousin = new Cousin(0);
renderTimes: number = 0;
isRender(id: number): number {
console.info(`id: ${id} renderTimes: ${this.renderTimes}`);
this.renderTimes++;
return 40;
}
build() {
Row() {
Column() {
Text(`Son ${this.son.age}`)
.fontSize(this.isRender(1))
.fontWeight(FontWeight.Bold)
Text(`Cousin ${this.cousin.age}`)
.fontSize(this.isRender(2))
.fontWeight(FontWeight.Bold)
Button('change Son age')
.onClick(() => {
this.son.age++;
})
Button('change Cousin age')
.onClick(() => {
this.cousin.age++;
})
}
.width('100%')
}
.height('100%')
}
}
```
@Trace装饰基础类型的数组
@Trace装饰数组时，使用支持的API能够观测到变化。支持的API见观察变化。
在下面的示例中@ObservedV2装饰的Arr类中的属性numberArr是@Trace装饰的数组，当使用数组API操作numberArr时，可以观测到对应的变化。注意使用数组长度进行判断以防越界访问。
```typescript
let nextId: number = 0;
@ObservedV2
class Arr {
id: number = 0;
@Trace numberArr: number[] = [];
constructor() {
this.id = nextId++;
this.numberArr = [0, 1, 2];
}
}
@Entry
@ComponentV2
struct Index {
arr: Arr = new Arr();
build() {
Column() {
Text(`length: ${this.arr.numberArr.length}`)
.fontSize(40)
Divider()
if (this.arr.numberArr.length >= 3) {
Text(`${this.arr.numberArr[0]}`)
.fontSize(40)
.onClick(() => {
this.arr.numberArr[0]++;
})
Text(`${this.arr.numberArr[1]}`)
.fontSize(40)
.onClick(() => {
this.arr.numberArr[1]++;
})
Text(`${this.arr.numberArr[2]}`)
.fontSize(40)
.onClick(() => {
this.arr.numberArr[2]++;
})
}
Divider()
ForEach(this.arr.numberArr, (item: number, index: number) => {
Text(`${index} ${item}`)
.fontSize(40)
})
Button('push')
.onClick(() => {
this.arr.numberArr.push(50);
})
Button('pop')
.onClick(() => {
this.arr.numberArr.pop();
})
Button('shift')
.onClick(() => {
this.arr.numberArr.shift();
})
Button('splice')
.onClick(() => {
this.arr.numberArr.splice(1, 0, 60);
})
Button('unshift')
.onClick(() => {
this.arr.numberArr.unshift(100);
})
Button('copywithin')
.onClick(() => {
this.arr.numberArr.copyWithin(0, 1, 2);
})
Button('fill')
.onClick(() => {
this.arr.numberArr.fill(0, 2, 4);
})
Button('reverse')
.onClick(() => {
this.arr.numberArr.reverse();
})
Button('sort')
.onClick(() => {
this.arr.numberArr.sort();
})
}
}
}
```
@Trace装饰对象数组
```typescript
let nextId: number = 0;
@ObservedV2
class Person {
@Trace age: number = 0;
constructor(age: number) {
this.age = age;
}
}
@ObservedV2
class Info {
id: number = 0;
@Trace personList: Person[] = [];
constructor() {
this.id = nextId++;
this.personList = [new Person(0), new Person(1), new Person(2)];
}
}
@Entry
@ComponentV2
struct Index {
info: Info = new Info();
build() {
Column() {
Text(`length: ${this.info.personList.length}`)
.fontSize(40)
Divider()
if (this.info.personList.length >= 3) {
Text(`${this.info.personList[0].age}`)
.fontSize(40)
.onClick(() => {
this.info.personList[0].age++;
})
Text(`${this.info.personList[1].age}`)
.fontSize(40)
.onClick(() => {
this.info.personList[1].age++;
})
Text(`${this.info.personList[2].age}`)
.fontSize(40)
.onClick(() => {
this.info.personList[2].age++;
})
}
Divider()
ForEach(this.info.personList, (item: Person, index: number) => {
Text(`${index} ${item.age}`)
.fontSize(40)
})
}
}
}
```
@Trace装饰Map类型
```typescript
@ObservedV2
class Info {
@Trace memberMap: Map<number, string> = new Map([[0, "a"], [1, "b"], [3, "c"]]);
}
@Entry
@ComponentV2
struct MapSample {
info: Info = new Info();
build() {
Row() {
Column() {
ForEach(Array.from(this.info.memberMap.entries()), (item: [number, string]) => {
Text(`${item[0]}`)
.fontSize(30)
Text(`${item[1]}`)
.fontSize(30)
Divider()
})
Button('init map')
.onClick(() => {
this.info.memberMap = new Map([[0, "a"], [1, "b"], [3, "c"]]);
})
Button('set new one')
.onClick(() => {
this.info.memberMap.set(4, "d");
})
Button('clear')
.onClick(() => {
this.info.memberMap.clear();
})
Button('set the key: 0')
.onClick(() => {
this.info.memberMap.set(0, "aa");
})
Button('delete the first one')
.onClick(() => {
this.info.memberMap.delete(0);
})
}
.width('100%')
}
.height('100%')
}
}
```
@Trace装饰Set类型
```typescript
@ObservedV2
class Info {
@Trace memberSet: Set<number> = new Set([0, 1, 2, 3, 4]);
}
@Entry
@ComponentV2
struct SetSample {
info: Info = new Info();
build() {
Row() {
Column() {
ForEach(Array.from(this.info.memberSet.entries()), (item: [number, number]) => {
Text(`${item[0]}`)
.fontSize(30)
Divider()
})
Button('init set')
.onClick(() => {
this.info.memberSet = new Set([0, 1, 2, 3, 4]);
})
Button('set new one')
.onClick(() => {
this.info.memberSet.add(5);
})
Button('clear')
.onClick(() => {
this.info.memberSet.clear();
})
Button('delete the first one')
.onClick(() => {
this.info.memberSet.delete(0);
})
}
.width('100%')
}
.height('100%')
}
}
```
@Trace装饰Date类型
```typescript
@ObservedV2
class Info {
@Trace selectedDate: Date = new Date('2021-08-08')
}
@Entry
@ComponentV2
struct DateSample {
info: Info = new Info()
build() {
Column() {
Button('set selectedDate to 2023-07-08')
.margin(10)
.onClick(() => {
this.info.selectedDate = new Date('2023-07-08');
})
Button('increase the year by 1')
.margin(10)
.onClick(() => {
this.info.selectedDate.setFullYear(this.info.selectedDate.getFullYear() + 1);
})
Button('increase the month by 1')
.margin(10)
.onClick(() => {
this.info.selectedDate.setMonth(this.info.selectedDate.getMonth() + 1);
})
Button('increase the day by 1')
.margin(10)
.onClick(() => {
this.info.selectedDate.setDate(this.info.selectedDate.getDate() + 1);
})
DatePicker({
start: new Date('1970-1-1'),
end: new Date('2100-1-1'),
selected: this.info.selectedDate
})
}.width('100%')
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-componentv2
爬取时间: 2025-04-28 06:56:38
来源: Huawei Developer
为了在自定义组件中使用V2版本状态变量装饰器的能力，开发者可以使用@ComponentV2装饰器装饰自定义组件。
@ComponentV2主要配合状态管理V2使用。在阅读文档前，建议提前阅读：状态管理概述。
@ComponentV2装饰器从API version 12开始支持。
概述
和@Component装饰器一样，@ComponentV2装饰器用于装饰自定义组件：
-  在@ComponentV2装饰的自定义组件中，开发者仅可以使用全新的状态变量装饰器，包括@Local、@Param、@Once、@Event、@Provider、@Consumer等。
-  @ComponentV2装饰的自定义组件暂不支持组件复用、LocalStorage等现有自定义组件的能力。
-  无法同时使用@ComponentV2与@Component装饰同一个struct结构。
-  @ComponentV2支持一个可选的boolean类型参数freezeWhenInactive，来实现组件冻结功能。
-  一个简单的@ComponentV2装饰的自定义组件应具有以下部分：
```typescript
@ComponentV2 // 装饰器
struct Index { // struct声明的数据结构
build() { // build定义的UI
}
}
```
除非特别说明，@ComponentV2装饰的自定义组件将与@Component装饰的自定义组件保持相同的行为。
限制条件
在将@Component装饰的自定义组件与@ComponentV2装饰的自定义组件混合使用时，可参考混用文档。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-local
爬取时间: 2025-04-28 06:56:52
来源: Huawei Developer
为了实现对@ComponentV2装饰的自定义组件中变量变化的观测，开发者可以使用@Local装饰器装饰变量。
在阅读本文档前，建议提前阅读：@ComponentV2。
从API version 12开始，在@ComponentV2装饰的自定义组件中支持使用@Local装饰器。
概述
@Local表示组件内部的状态，使得自定义组件内部的变量具有观测变化的能力：
-  被@Local装饰的变量无法从外部初始化，因此必须在组件内部进行初始化。
-  当被@Local装饰的变量变化时，会刷新使用该变量的组件。
-  @Local支持观测number、boolean、string、Object、class等基本类型以及Array、Set、Map、Date等内嵌类型。
-  @Local的观测能力仅限于被装饰的变量本身。当装饰简单类型时，能够观测到对变量的赋值；当装饰对象类型时，仅能观测到对对象整体的赋值；当装饰数组类型时，能观测到数组整体以及数组元素项的变化；当装饰Array、Set、Map、Date等内嵌类型时，可以观测到通过API调用带来的变化。详见观察变化。
-  @Local支持null、undefined以及联合类型。
状态管理V1版本@State装饰器的局限性
状态管理V1使用@State装饰器定义类中的状态变量。但由于@State装饰器能够从外部初始化，因此@State无法准确表达组件内部状态不能被外面修改的语义。
```typescript
class ComponentInfo {
name: string;
count: number;
message: string;
constructor(name: string, count: number, message: string) {
this.name = name;
this.count = count;
this.message = message;
}
}
@Component
struct Child {
@State componentInfo: ComponentInfo = new ComponentInfo("Child", 1, "Hello World");
build() {
Column() {
Text(`componentInfo.message is ${this.componentInfo.message}`)
}
}
}
@Entry
@Component
struct Index {
build() {
Column() {
Child({componentInfo: new ComponentInfo("Unknown", 0, "Error")})
}
}
}
```
上述代码中，可以通过在初始化Child组件时，传入新的值来覆盖Child组件想要作为内部状态变量使用的componentInfo。但Child组件并不能感知到componentInfo从外部进行了初始化，这不利于组件内部状态的管理。因此推出@Local装饰器表示组件的内部状态。
装饰器说明
| @Local变量装饰器 | 说明 |
| --- | --- |
| 装饰器参数 | 无。 |
| 可装饰的变量类型 | Object、class、string、number、boolean、enum等基本类型以及Array、Date、Map、Set等内嵌类型。支持null、undefined以及联合类型。 |
| 装饰变量的初始值 | 必须本地初始化，不允许外部传入初始化。 |
变量传递
| 传递规则 | 说明 |
| --- | --- |
| 从父组件初始化 | @Local装饰的变量仅允许本地初始化，无法从外部传入初始化。 |
| 初始化子组件 | @Local装饰的变量可以初始化子组件中@Param装饰的变量。 |
观察变化
使用@Local装饰的变量具有被观测变化的能力。当装饰的变量发生变化时，会触发该变量绑定的UI组件刷新。
-  当装饰的变量类型为boolean、string、number时，可以观察到对变量赋值的变化。
```typescript
@Entry
@ComponentV2
struct Index {
@Local count: number = 0;
@Local message: string = "Hello";
@Local flag: boolean = false;
build() {
Column() {
Text(`${this.count}`)
Text(`${this.message}`)
Text(`${this.flag}`)
Button("change Local")
.onClick(()=>{
// 当@Local装饰简单类型时，能够观测到对变量的赋值
this.count++;
this.message += " World";
this.flag = !this.flag;
})
}
}
}
```
-  当装饰的变量类型为类对象时，仅可以观察到对类对象整体赋值的变化，无法直接观察到对类成员属性赋值的变化，对类成员属性的观察依赖@ObservedV2和@Trace装饰器。注意，@Local无法和@Observed装饰的类实例对象混用。
```typescript
class RawObject {
name: string;
constructor(name: string) {
this.name = name;
}
}
@ObservedV2
class ObservedObject {
@Trace name: string;
constructor(name: string) {
this.name = name;
}
}
@Entry
@ComponentV2
struct Index {
@Local rawObject: RawObject = new RawObject("rawObject");
@Local observedObject: ObservedObject = new ObservedObject("observedObject");
build() {
Column() {
Text(`${this.rawObject.name}`)
Text(`${this.observedObject.name}`)
Button("change object")
.onClick(() => {
// 对类对象整体的修改均能观察到
this.rawObject = new RawObject("new rawObject");
this.observedObject = new ObservedObject("new observedObject");
})
Button("change name")
.onClick(() => {
// @Local不具备观察类对象属性的能力，因此对rawObject.name的修改无法观察到
this.rawObject.name = "new rawObject name";
// 由于ObservedObject的name属性被@Trace装饰，因此对observedObject.name的修改能被观察到
this.observedObject.name = "new observedObject name";
})
}
}
}
```
-  当装饰的变量类型为简单类型的数组时，可以观察到数组整体或数组项的变化。
```typescript
@Entry
@ComponentV2
struct Index {
@Local numArr: number[] = [1,2,3,4,5];
@Local dimensionTwo: number[][] = [[1,2,3],[4,5,6]];
build() {
Column() {
Text(`${this.numArr[0]}`)
Text(`${this.numArr[1]}`)
Text(`${this.numArr[2]}`)
Text(`${this.dimensionTwo[0][0]}`)
Text(`${this.dimensionTwo[1][1]}`)
Button("change array item")
.onClick(() => {
this.numArr[0]++;
this.numArr[1] += 2;
this.dimensionTwo[0][0] = 0;
this.dimensionTwo[1][1] = 0;
})
Button("change whole array")
.onClick(() => {
this.numArr = [5,4,3,2,1];
this.dimensionTwo = [[7,8,9],[0,1,2]];
})
}
}
}
```
-  当装饰的变量是嵌套类或对象数组时，@Local无法观察深层对象属性的变化。对深层对象属性的观测依赖@ObservedV2与@Trace装饰器。
```typescript
@ObservedV2
class Region {
@Trace x: number;
@Trace y: number;
constructor(x: number, y: number) {
this.x = x;
this.y = y;
}
}
@ObservedV2
class Info {
@Trace region: Region;
@Trace name: string;
constructor(name: string, x: number, y: number) {
this.name = name;
this.region = new Region(x, y);
}
}
@Entry
@ComponentV2
struct Index {
@Local infoArr: Info[] = [new Info("Ocean", 28, 120), new Info("Mountain", 26, 20)];
@Local originInfo: Info = new Info("Origin", 0, 0);
build() {
Column() {
ForEach(this.infoArr, (info: Info) => {
Row() {
Text(`name: ${info.name}`)
Text(`region: ${info.region.x}-${info.region.y}`)
}
})
Row() {
Text(`Origin name: ${this.originInfo.name}`)
Text(`Origin region: ${this.originInfo.region.x}-${this.originInfo.region.y}`)
}
Button("change infoArr item")
.onClick(() => {
// 由于属性name被@Trace装饰，所以能够观察到
this.infoArr[0].name = "Win";
})
Button("change originInfo")
.onClick(() => {
// 由于变量originInfo被@Local装饰，所以能够观察到
this.originInfo = new Info("Origin", 100, 100);
})
Button("change originInfo region")
.onClick(() => {
// 由于属性x、y被@Trace装饰，所以能够观察到
this.originInfo.region.x = 25;
this.originInfo.region.y = 25;
})
}
}
}
```
-  当装饰的变量类型是内置类型时，可以观察到变量整体赋值以及通过API调用带来的变化。
| 类型 | 可观测变化的API |
| --- | --- |
| Array | push、pop、shift、unshift、splice、copyWithin、fill、reverse、sort |
| Date | setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds |
| Map | set, clear, delete |
| Set | add, clear, delete |
限制条件
@Local装饰器存在以下使用限制：
-  @Local装饰器只能在@ComponentV2装饰的自定义组件中使用。
```typescript
@ComponentV2
struct MyComponent {
@Local message: string = "Hello World"; // 正确用法
build() {
}
}
@Component
struct TestComponent {
@Local message: string = "Hello World"; // 错误用法，编译时报错
build() {
}
}
```
-  @Local装饰的变量表示组件内部状态，不允许从外部传入初始化。
```typescript
@ComponentV2
struct ChildComponent {
@Local message: string = "Hello World";
build() {
}
}
@ComponentV2
struct MyComponent {
build() {
ChildComponent({ message: "Hello" }) // 错误用法，编译时报错
}
}
```
@Local与@State对比
@Local与@State的用法、功能对比如下：
|  | @State | @Local |
| --- | --- | --- |
| 参数 | 无。 | 无。 |
| 从父组件初始化 | 可选。 | 不允许外部初始化。 |
| 观察能力 | 能观测变量本身以及一层的成员属性，无法深度观测。 | 能观测变量本身，深度观测依赖@Trace装饰器。 |
| 数据传递 | 可以作为数据源和子组件中状态变量同步。 | 可以作为数据源和子组件中状态变量同步。 |
使用场景
观测对象整体变化
被@ObservedV2与@Trace装饰的类对象实例，具有深度观测对象属性的能力。但当对对象整体赋值时，UI却无法刷新。使用@Local装饰对象，可以达到观测对象本身变化的效果。
```typescript
@ObservedV2
class Info {
@Trace name: string;
@Trace age: number;
constructor(name: string, age: number) {
this.name = name;
this.age = age;
}
}
@Entry
@ComponentV2
struct Index {
info: Info = new Info("Tom", 25);
@Local localInfo: Info = new Info("Tom", 25);
build() {
Column() {
Text(`info: ${this.info.name}-${this.info.age}`) // Text1
Text(`localInfo: ${this.localInfo.name}-${this.localInfo.age}`) // Text2
Button("change info&localInfo")
.onClick(() => {
this.info = new Info("Lucy", 18); // Text1不会刷新
this.localInfo = new Info("Lucy", 18); // Text2会刷新
})
}
}
}
```
装饰Date类型变量
当装饰的对象是Date时，可以观察到Date整体的赋值，同时可通过调用Date的接口setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds 更新Date的属性。
```typescript
@Entry
@ComponentV2
struct DatePickerExample {
@Local selectedDate: Date = new Date('2021-08-08');
build() {
Column() {
Button('set selectedDate to 2023-07-08')
.margin(10)
.onClick(() => {
this.selectedDate = new Date('2023-07-08');
})
Button('increase the year by 1')
.margin(10)
.onClick(() => {
this.selectedDate.setFullYear(this.selectedDate.getFullYear() + 1);
})
Button('increase the month by 1')
.margin(10)
.onClick(() => {
this.selectedDate.setMonth(this.selectedDate.getMonth() + 1);
})
Button('increase the day by 1')
.margin(10)
.onClick(() => {
this.selectedDate.setDate(this.selectedDate.getDate() + 1);
})
DatePicker({
start: new Date('1970-1-1'),
end: new Date('2100-1-1'),
selected: this.selectedDate
})
}.width('100%')
}
}
```
装饰Map类型变量
当装饰的对象是Map时，可以观察到对Map整体的赋值，同时可以通过调用Map的接口 set、clear、delete更新Map中的数据。
```typescript
@Entry
@ComponentV2
struct MapSample {
@Local message: Map<number, string> = new Map([[0, "a"], [1, "b"], [3, "c"]]);
build() {
Row() {
Column() {
ForEach(Array.from(this.message.entries()), (item: [number, string]) => {
Text(`${item[0]}`).fontSize(30)
Text(`${item[1]}`).fontSize(30)
Divider()
})
Button('init map').onClick(() => {
this.message = new Map([[0, "a"], [1, "b"], [3, "c"]]);
})
Button('set new one').onClick(() => {
this.message.set(4, "d");
})
Button('clear').onClick(() => {
this.message.clear();
})
Button('replace the first one').onClick(() => {
this.message.set(0, "aa");
})
Button('delete the first one').onClick(() => {
this.message.delete(0);
})
}
.width('100%')
}
.height('100%')
}
}
```
装饰Set类型变量
当装饰的对象是Set时，可以观察到对Set整体的赋值，同时可以通过调用Set的接口add、clear、delete更新Set中的数据。
```typescript
@Entry
@ComponentV2
struct SetSample {
@Local message: Set<number> = new Set([0, 1, 2, 3, 4]);
build() {
Row() {
Column() {
ForEach(Array.from(this.message.entries()), (item: [number, string]) => {
Text(`${item[0]}`).fontSize(30)
Divider()
})
Button('init set').onClick(() => {
this.message = new Set([0, 1, 2, 3, 4]);
})
Button('set new one').onClick(() => {
this.message.add(5);
})
Button('clear').onClick(() => {
this.message.clear();
})
Button('delete the first one').onClick(() => {
this.message.delete(0);
})
}
.width('100%')
}
.height('100%')
}
}
```
联合类型
@Local支持null、undefined以及联合类型。在下面的示例中，count类型为number | undefined，点击改变count的类型，UI会随之刷新。
```typescript
@Entry
@ComponentV2
struct Index {
@Local count: number | undefined = 10;
build() {
Column() {
Text(`count(${this.count})`)
Button("change to undefined")
.onClick(() => {
this.count = undefined;
})
Button("change to number")
.onClick(() => {
this.count = 10;
})
}
}
}
```
常见问题
复杂类型常量重复赋值给状态变量触发刷新
```typescript
@Entry
@ComponentV2
struct Index {
list: string[][] = [['a'], ['b'], ['c']];
@Local dataObjFromList: string[] = this.list[0];
@Monitor("dataObjFromList")
onStrChange(monitor: IMonitor) {
console.log("dataObjFromList has changed");
}
build() {
Column() {
Button('change to self').onClick(() => {
// 新值和本地初始化的值相同
this.dataObjFromList = this.list[0];
})
}
}
}
```
以上示例每次点击Button('change to self')，把相同的Array类型常量赋值给一个Array类型的状态变量，都会触发刷新。原因是在状态管理V2中，会给使用状态变量装饰器如@Trace、@Local装饰的Date、Map、Set、Array添加一层代理用于观测API调用产生的变化。
当再次赋值list[0]时，dataObjFromList已经是一个Proxy类型，而list[0]是Array类型，判断是不相等的，因此会触发赋值和刷新。
为了避免这种不必要的赋值和刷新，可以使用UIUtils.getTarget()获取原始对象提前进行新旧值的判断，当两者相同时不执行赋值。
使用UIUtils.getTarget()方法示例
```typescript
import { UIUtils } from '@ohos.arkui.StateManagement';
@Entry
@ComponentV2
struct Index {
list: string[][] = [['a'], ['b'], ['c']];
@Local dataObjFromList: string[] = this.list[0];
@Monitor("dataObjFromList")
onStrChange(monitor: IMonitor) {
console.log("dataObjFromList has changed");
}
build() {
Column() {
Button('change to self').onClick(() => {
// 获取原始对象来和新值做对比
if (UIUtils.getTarget(this.dataObjFromList) !== this.list[0]) {
this.dataObjFromList = this.list[0];
}
})
}
}
}
```
在状态管理V2中使用animateTo动画效果异常
在下面的场景中，animateTo暂不支持直接在状态管理V2中使用。
```typescript
@Entry
@ComponentV2
struct Index {
@Local w: number = 50; // 宽度
@Local h: number = 50; // 高度
@Local message: string = 'Hello';
build() {
Column() {
Button('change size')
.margin(20)
.onClick(() => {
// 在执行动画前，存在额外的修改
this.w = 100;
this.h = 100;
this.message = 'Hello World';
animateTo({
duration: 1000
}, () => {
this.w = 200;
this.h = 200;
this.message = 'Hello ArkUI';
})
})
Column() {
Text(`${this.message}`)
}
.backgroundColor('#ff17a98d')
.width(this.w)
.height(this.h)
}
}
}
```
上面的代码中，开发者预期显示的动画为绿色矩形从长宽100变化成200，字符串从Hello World变化成Hello ArkUI，但由于当前animateTo与V2在刷新机制上暂不兼容，在执行动画前额外的修改并不会生效，因此实际显示的动画为绿色矩形从长宽50变化成200，字符串从Hello变化成Hello ArkUI。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163830.52334103076360371251629828682336:50001231000000:2800:6CDF15236EE67BFE561C944F5CDFA50076040E21408F4656D7D44588D2962ACE.gif)
可以通过下面的方法暂时获得预期的显示效果。
```typescript
@Entry
@ComponentV2
struct Index {
@Local w: number = 50; // 宽度
@Local h: number = 50; // 高度
@Local message: string = 'Hello';
build() {
Column() {
Button('change size')
.margin(20)
.onClick(() => {
// 在执行动画前，存在额外的修改
this.w = 100;
this.h = 100;
this.message = 'Hello Word';
animateToImmediately({
duration: 0
}, () => {
})
animateTo({
duration: 1000
}, () => {
this.w = 200;
this.h = 200;
this.message = 'Hello ArkUI';
})
})
Column() {
Text(`${this.message}`)
}
.backgroundColor('#ff17a98d')
.width(this.w)
.height(this.h)
}
}
}
```
原理为使用一个duration为0的animateToImmediately将额外的修改先刷新，再执行原来的动画达成预期的效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163830.02611752480298693308184942787395:50001231000000:2800:A7E970647705647B61777DF90F4E97E6B70BE1CE8139B293741146F638650479.gif)
建议开发者在状态管理V2中谨慎使用animateTo接口。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-param
爬取时间: 2025-04-28 06:57:06
来源: Huawei Developer
为了增强子组件接受外部参数输入的能力，开发者可以使用@Param装饰器。
@Param不仅可以接受组件外部输入，还可以接受@Local的同步变化。在阅读本文档前，建议提前阅读：@Local。
从API version 12开始，在@ComponentV2装饰的自定义组件中支持使用@Param装饰器。
概述
@Param表示组件从外部传入的状态，使得父子组件之间的数据能够进行同步：
-  @Param装饰的变量支持本地初始化，但是不允许在组件内部直接修改变量本身。
-  被@Param装饰的变量能够在初始化自定义组件时从外部传入，当数据源也是状态变量时，数据源的修改会同步给@Param。
-  @Param可以接受任意类型的数据源，包括普通变量、状态变量、常量、函数返回值等。
-  @Param装饰的变量变化时，会刷新该变量关联的组件。
-  @Param支持观测number、boolean、string、Object、class等基本类型以及Array、Set、Map、Date等内嵌类型。
-  对于复杂类型如类对象，@Param会接受数据源的引用。在组件内可以修改类对象中的属性，该修改会同步到数据源。
-  @Param的观测能力仅限于被装饰的变量本身。当装饰简单类型时，对变量的整体改变能够观测到；当装饰对象类型时，仅能观测对象整体的改变；当装饰数组类型时，能观测到数组整体以及数组元素项的改变；当装饰Array、Set、Map、Date等内嵌类型时，可以观测到通过API调用带来的变化。详见观察变化。
-  @Param支持null、undefined以及联合类型。
状态管理V1版本接受外部传入的装饰器的局限性
状态管理V1存在多种可接受外部传入的装饰器，常用的有@State、@Prop、@Link、@ObjectLink。这些装饰器使用各有限制，不易区分，当使用不当时，还会导致性能问题。
```typescript
@Observed
class Region {
x: number;
y: number;
constructor(x: number, y: number) {
this.x = x;
this.y = y;
}
}
@Observed
class Info {
region: Region;
constructor(x: number, y: number) {
this.region = new Region(x, y);
}
}
@Entry
@Component
struct Index {
@State info: Info = new Info(0, 0);
build() {
Column() {
Button("change Info")
.onClick(() => {
this.info = new Info(100, 100);
})
Child({
region: this.info.region,
regionProp: this.info.region,
infoProp: this.info,
infoLink: this.info,
infoState: this.info
})
}
}
}
@Component
struct Child {
@ObjectLink region: Region;
@Prop regionProp: Region;
@Prop infoProp: Info;
@Link infoLink: Info;
@State infoState: Info = new Info(1, 1);
build() {
Column() {
Text(`ObjectLink region: ${this.region.x}-${this.region.y}`)
Text(`Prop regionProp: ${this.regionProp.x}-${this.regionProp.y}`)
}
}
}
```
在上面的示例中，@State仅能在初始化时获得info的引用，当改变info之后，无法进行同步。@Prop虽然能够进行单向同步，但是对于较复杂的类型来说，深拷贝性能较差。@Link能够接受传入的引用进行双向同步，但它必须要求数据源也是状态变量，因此无法接受info中的成员属性region。@ObjectLink能够接受类成员属性，但是要求该属性类型必须为@Observed装饰的类。装饰器的不同限制使得父子组件之间传值规则十分复杂，不易使用。因此推出@Param装饰器表示组件从外部传入的状态。
装饰器说明
| @Param变量装饰器 | 说明 |
| --- | --- |
| 装饰器参数 | 无。 |
| 能否本地修改 | 否，修改值需使用@Event装饰器的能力。 |
| 同步类型 | 由父到子单向同步。 |
| 允许装饰的变量类型 | Object、class、string、number、boolean、enum等基本类型以及Array、Date、Map、Set等内嵌类型。支持null、undefined以及联合类型。 |
| 被装饰变量的初始值 | 允许本地初始化，若不在本地初始化，则需要和@Require装饰器一起使用，要求必须从外部传入初始化。 |
变量传递
| 传递规则 | 说明 |
| --- | --- |
| 从父组件初始化 | @Param装饰的变量允许本地初始化，若无本地初始化则必须从外部传入初始化。当同时存在本地初始值与外部传入值时，会优先使用外部传入值进行初始化。 |
| 初始化子组件 | @Param装饰的变量可以初始化子组件中@Param装饰的变量。 |
| 同步 | @Param可以和父组件传入的状态变量数据源（即@Local或@Param装饰的变量）进行同步，当数据源发生变化时，会将修改同步给子组件的@Param。 |
观察变化
使用@Param装饰的变量具有被观测变化的能力。当装饰的变量发生变化时，会触发该变量绑定的UI组件刷新。
-  当装饰的变量类型为boolean、string、number类型时，可以观察来自数据源同步的变化。
```typescript
@Entry
@ComponentV2
struct Index {
@Local count: number = 0;
@Local message: string = "Hello";
@Local flag: boolean = false;
build() {
Column() {
Text(`Local ${this.count}`)
Text(`Local ${this.message}`)
Text(`Local ${this.flag}`)
Button("change Local")
.onClick(()=>{
// 对数据源的更改会同步给子组件
this.count++;
this.message += " World";
this.flag = !this.flag;
})
Child({
count: this.count,
message: this.message,
flag: this.flag
})
}
}
}
@ComponentV2
struct Child {
@Require @Param count: number;
@Require @Param message: string;
@Require @Param flag: boolean;
build() {
Column() {
Text(`Param ${this.count}`)
Text(`Param ${this.message}`)
Text(`Param ${this.flag}`)
}
}
}
```
-  当装饰的变量类型为类对象时，仅可以观察到对类对象整体赋值的变化，无法直接观察到对类成员属性赋值的变化，对类成员属性的观察依赖@ObservedV2和@Trace装饰器。
```typescript
class RawObject {
name: string;
constructor(name: string) {
this.name = name;
}
}
@ObservedV2
class ObservedObject {
@Trace name: string;
constructor(name: string) {
this.name = name;
}
}
@Entry
@ComponentV2
struct Index {
@Local rawObject: RawObject = new RawObject("rawObject");
@Local observedObject: ObservedObject = new ObservedObject("observedObject");
build() {
Column() {
Text(`${this.rawObject.name}`)
Text(`${this.observedObject.name}`)
Button("change object")
.onClick(() => {
// 对类对象整体的修改均能观察到
this.rawObject = new RawObject("new rawObject");
this.observedObject = new ObservedObject("new observedObject");
})
Button("change name")
.onClick(() => {
// @Local与@Param均不具备观察类对象属性的能力，因此对rawObject.name的修改无法观察到
this.rawObject.name = "new rawObject name";
// 由于ObservedObject的name属性被@Trace装饰，因此对observedObject.name的修改能被观察到
this.observedObject.name = "new observedObject name";
})
Child({
rawObject: this.rawObject,
observedObject: this.observedObject
})
}
}
}
@ComponentV2
struct Child {
@Require @Param rawObject: RawObject;
@Require @Param observedObject: ObservedObject;
build() {
Column() {
Text(`${this.rawObject.name}`)
Text(`${this.observedObject.name}`)
}
}
}
```
-  当装饰的变量类型为简单类型的数组时，可以观察到数组整体或数组项的变化。
```typescript
@Entry
@ComponentV2
struct Index {
@Local numArr: number[] = [1,2,3,4,5];
@Local dimensionTwo: number[][] = [[1,2,3],[4,5,6]];
build() {
Column() {
Text(`${this.numArr[0]}`)
Text(`${this.numArr[1]}`)
Text(`${this.numArr[2]}`)
Text(`${this.dimensionTwo[0][0]}`)
Text(`${this.dimensionTwo[1][1]}`)
Button("change array item")
.onClick(() => {
this.numArr[0]++;
this.numArr[1] += 2;
this.dimensionTwo[0][0] = 0;
this.dimensionTwo[1][1] = 0;
})
Button("change whole array")
.onClick(() => {
this.numArr = [5,4,3,2,1];
this.dimensionTwo = [[7,8,9],[0,1,2]];
})
Child({
numArr: this.numArr,
dimensionTwo: this.dimensionTwo
})
}
}
}
@ComponentV2
struct Child {
@Require @Param numArr: number[];
@Require @Param dimensionTwo: number[][];
build() {
Column() {
Text(`${this.numArr[0]}`)
Text(`${this.numArr[1]}`)
Text(`${this.numArr[2]}`)
Text(`${this.dimensionTwo[0][0]}`)
Text(`${this.dimensionTwo[1][1]}`)
}
}
}
```
-  当装饰的变量是嵌套类或对象数组时，@Param无法观察深层对象属性的变化。对深层对象属性的观测依赖@ObservedV2与@Trace装饰器。
```typescript
@ObservedV2
class Region {
@Trace x: number;
@Trace y: number;
constructor(x: number, y: number) {
this.x = x;
this.y = y;
}
}
@ObservedV2
class Info {
@Trace region: Region;
@Trace name: string;
constructor(name: string, x: number, y: number) {
this.name = name;
this.region = new Region(x, y);
}
}
@Entry
@ComponentV2
struct Index {
@Local infoArr: Info[] = [new Info("Ocean", 28, 120), new Info("Mountain", 26, 20)];
@Local originInfo: Info = new Info("Origin", 0, 0);
build() {
Column() {
ForEach(this.infoArr, (info: Info) => {
Row() {
Text(`name: ${info.name}`)
Text(`region: ${info.region.x}-${info.region.y}`)
}
})
Row() {
Text(`Origin name: ${this.originInfo.name}`)
Text(`Origin region: ${this.originInfo.region.x}-${this.originInfo.region.y}`)
}
Button("change infoArr item")
.onClick(() => {
// 由于属性name被@Trace装饰，所以能够观察到
this.infoArr[0].name = "Win";
})
Button("change originInfo")
.onClick(() => {
// 由于变量originInfo被@Local装饰，所以能够观察到
this.originInfo = new Info("Origin", 100, 100);
})
Button("change originInfo region")
.onClick(() => {
// 由于属性x、y被@Trace装饰，所以能够观察到
this.originInfo.region.x = 25;
this.originInfo.region.y = 25;
})
}
}
}
@ComponentV2
struct Child {
@Param infoArr: Info[] = [];
@Param originInfo: Info = new Info("O", 0, 0);
build() {
Column() {
ForEach(this.infoArr, (info: Info) => {
Row() {
Text(`name: ${info.name}`)
Text(`region: ${info.region.x}-${info.region.y}`)
}
})
Row() {
Text(`Origin name: ${this.originInfo.name}`)
Text(`Origin region: ${this.originInfo.region.x}-${this.originInfo.region.y}`)
}
}
}
}
```
-  当装饰的变量类型是内置类型时，可以观察到变量整体赋值以及通过API调用带来的变化。
| 类型 | 可观测变化的API |
| --- | --- |
| Array | push、pop、shift、unshift、splice、copyWithin、fill、reverse、sort |
| Date | setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds |
| Map | set, clear, delete |
| Set | add, clear, delete |
限制条件
@Param装饰器存在以下使用限制：
-  @Param装饰器只能在@ComponentV2装饰器的自定义组件中使用。
```typescript
@ComponentV2
struct MyComponent {
@Param message: string = "Hello World"; // 正确用法
build() {
}
}
@Component
struct TestComponent {
@Param message: string = "Hello World"; // 错误用法，编译时报错
build() {
}
}
```
-  @Param装饰的变量表示组件外部输入，需要被初始化。支持使用本地初始值做初始化。当存在外部传入值时，将优先使用外部传入的值初始化。既不使用本地初始值，也不使用外部传入值是不允许的。
```typescript
@ComponentV2
struct ChildComponent {
@Param param1: string = "Initialize local";
@Param param2: string = "Initialize local and put in";
@Require @Param param3: string;
@Param param4: string; // 错误用法，外部未传入初始化且本地也无初始值，编译报错
build() {
Column() {
Text(`${this.param1}`) // 本地初始化，显示Initialize local
Text(`${this.param2}`) // 外部传入初始化，显示Put in
Text(`${this.param3}`) // 外部传入初始化，显示Put in
}
}
}
@Entry
@ComponentV2
struct MyComponent {
@Local message: string = "Put in";
build() {
Column() {
ChildComponent({
param2: this.message,
param3: this.message
})
}
}
}
```
-  @Param装饰的变量在子组件中无法进行修改。但当装饰的变量类型为对象时，在子组件中修改对象中属性是允许的。
```typescript
@ObservedV2
class Info {
@Trace name: string;
constructor(name: string) {
this.name = name;
}
}
@Entry
@ComponentV2
struct Index {
@Local info: Info = new Info("Tom");
build() {
Column() {
Text(`Parent info.name ${this.info.name}`)
Button("Parent change info")
.onClick(() => {
// 父组件更改@Local变量，会同步子组件对应@Param变量
this.info = new Info("Lucy");
})
Child({ info: this.info })
}
}
}
@ComponentV2
struct Child {
@Require @Param info: Info;
build() {
Column() {
Text(`info.name: ${this.info.name}`)
Button("change info")
.onClick(() => {
// 错误用法，不允许在子组件更改@Param变量，编译时报错
this.info = new Info("Jack");
})
Button("Child change info.name")
.onClick(() => {
// 允许在子组件中更改对象中属性，该修改会同步到父组件数据源上，当属性被@Trace装饰时，可观测到对应UI刷新
this.info.name = "Jack";
})
}
}
}
```
使用场景
从父组件到子组件变量传递与同步
@Param能够接受父组件@Local或@Param传递的数据并与之变化同步。
```typescript
@ObservedV2
class Region {
@Trace x: number;
@Trace y: number;
constructor(x: number, y: number) {
this.x = x;
this.y = y;
}
}
@ObservedV2
class Info {
@Trace name: string;
@Trace age: number;
@Trace region: Region;
constructor(name: string, age: number, x: number, y: number) {
this.name = name;
this.age = age;
this.region = new Region(x, y);
}
}
@Entry
@ComponentV2
struct Index {
@Local infoList: Info[] = [new Info("Alice", 8, 0, 0), new Info("Barry", 10, 1, 20), new Info("Cindy", 18, 24, 40)];
build() {
Column() {
ForEach(this.infoList, (info: Info) => {
MiddleComponent({ info: info })
})
Button("change")
.onClick(() => {
this.infoList[0] = new Info("Atom", 40, 27, 90);
this.infoList[1].name = "Bob";
this.infoList[2].region = new Region(7, 9);
})
}
}
}
@ComponentV2
struct MiddleComponent {
@Require @Param info: Info;
build() {
Column() {
Text(`name: ${this.info.name}`)
Text(`age: ${this.info.age}`)
SubComponent({ region: this.info.region })
}
}
}
@ComponentV2
struct SubComponent {
@Require @Param region: Region;
build() {
Column() {
Text(`region: ${this.region.x}-${this.region.y}`)
}
}
}
```
装饰Date类型变量
@Param装饰Date类型变量，可以观察到数据源对Date整体的赋值，以及调用Date的接口setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds 带来的变化。
```typescript
@ComponentV2
struct DateComponent {
@Param selectedDate: Date = new Date('2024-01-01');
build() {
Column() {
DatePicker({
start: new Date('1970-1-1'),
end: new Date('2100-1-1'),
selected: this.selectedDate
})
}
}
}
@Entry
@ComponentV2
struct ParentComponent {
@Local parentSelectedDate: Date = new Date('2021-08-08');
build() {
Column() {
Button('parent update the new date')
.margin(10)
.onClick(() => {
this.parentSelectedDate = new Date('2023-07-07')
})
Button('increase the year by 1')
.margin(10)
.onClick(() => {
this.parentSelectedDate.setFullYear(this.parentSelectedDate.getFullYear() + 1)
})
Button('increase the month by 1')
.margin(10)
.onClick(() => {
this.parentSelectedDate.setMonth(this.parentSelectedDate.getMonth() + 1)
})
Button('parent increase the day by 1')
.margin(10)
.onClick(() => {
this.parentSelectedDate.setDate(this.parentSelectedDate.getDate() + 1)
})
DateComponent({ selectedDate: this.parentSelectedDate })
}
}
}
```
装饰Map类型变量
@Param装饰Map类型变量，可以观察到数据源对Map整体的赋值，以及调用Map的接口 set、clear、delete带来的变化。
```typescript
@ComponentV2
struct Child {
@Param value: Map<number, string> = new Map()
build() {
Column() {
ForEach(Array.from(this.value.entries()), (item: [number, string]) => {
Text(`${item[0]}`).fontSize(30)
Text(`${item[1]}`).fontSize(30)
Divider()
})
}
}
}
@Entry
@ComponentV2
struct MapSample2 {
@Local message: Map<number, string> = new Map([[0, "a"], [1, "b"], [3, "c"]])
build() {
Row() {
Column() {
Child({ value: this.message })
Button('init map').onClick(() => {
this.message = new Map([[0, "a"], [1, "b"], [3, "c"]])
})
Button('set new one').onClick(() => {
this.message.set(4, "d")
})
Button('clear').onClick(() => {
this.message.clear()
})
Button('replace the first one').onClick(() => {
this.message.set(0, "aa")
})
Button('delete the first one').onClick(() => {
this.message.delete(0)
})
}
.width('100%')
}
.height('100%')
}
}
```
装饰Set类型变量
@Param装饰Set类型变量，可以观察到数据源对Set整体的赋值，以及调用Set的接口 add、clear、delete带来的变化。
```typescript
@ComponentV2
struct Child {
@Param message: Set<number> = new Set()
build() {
Column() {
ForEach(Array.from(this.message.entries()), (item: [number, string]) => {
Text(`${item[0]}`).fontSize(30)
Divider()
})
}
.width('100%')
}
}
@Entry
@ComponentV2
struct SetSample11 {
@Local message: Set<number> = new Set([0, 1, 2, 3, 4])
build() {
Row() {
Column() {
Child({ message: this.message })
Button('init set').onClick(() => {
this.message = new Set([0, 1, 2, 3, 4])
})
Button('set new one').onClick(() => {
this.message.add(5)
})
Button('clear').onClick(() => {
this.message.clear()
})
Button('delete the first one').onClick(() => {
this.message.delete(0)
})
}
.width('100%')
}
.height('100%')
}
}
```
联合类型
@Param支持null、undefined以及联合类型。在下面的示例中，count类型为number | undefined，点击改变count的类型，UI会随之刷新。
```typescript
@Entry
@ComponentV2
struct Index {
@Local count: number | undefined = 0;
build() {
Column() {
MyComponent({ count: this.count })
Button('change')
.onClick(() => {
this.count = undefined;
})
}
}
}
@ComponentV2
struct MyComponent {
@Param count: number | undefined = 0;
build() {
Column() {
Text(`count(${this.count})`)
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-once
爬取时间: 2025-04-28 06:57:21
来源: Huawei Developer
为了实现仅从外部初始化一次、不接受后续同步变化的能力，开发者可以使用@Once装饰器搭配@Param装饰器使用。
在阅读本文档前，建议提前阅读：@Param。
从API version 12开始，在@ComponentV2装饰的自定义组件中支持使用@Once装饰器。
概述
@Once装饰器仅在变量初始化时接受外部传入值进行初始化，当后续数据源更改时，不会将修改同步给子组件：
装饰器使用规则说明
@Once装饰器作为辅助装饰器，本身没有对装饰类型的要求以及对变量的观察能力。
| @Once变量装饰器 | 说明 |
| --- | --- |
| 装饰器参数 | 无。 |
| 使用条件 | 无法单独使用，必须配合@Param装饰器使用。 |
限制条件
-  @Once只能用在@ComponentV2装饰的自定义组件中且仅能与@Param搭配使用。
```typescript
@ComponentV2
struct MyComponent {
@Param @Once onceParam: string = "onceParam"; // 正确用法
@Once onceStr: string = "Once"; // 错误用法，@Once无法单独使用
@Local @Once onceLocal: string = "onceLocal"; // 错误用法，@Once不能与@Local一起使用
}
@Component
struct Index {
@Once @Param onceParam: string = "onceParam"; // 错误用法
}
```
-  @Once与@Param的先后顺序无关，可以写成@Param @Once也可以写成@Once @Param。
```typescript
@ComponentV2
struct MyComponent {
@Param @Once param1: number;
@Once @Param param2: number;
}
```
使用场景
变量仅初始化同步一次
@Once使用在期望变量仅初始化时同步数据源一次，之后不再继续同步变化的场景。
```typescript
@ComponentV2
struct ChildComponent {
@Param @Once onceParam: string = "";
build() {
Column() {
Text(`onceParam: ${this.onceParam}`)
}
}
}
@Entry
@ComponentV2
struct MyComponent {
@Local message: string = "Hello World";
build() {
Column() {
Text(`Parent message: ${this.message}`)
Button("change message")
.onClick(() => {
this.message = "Hello Tomorrow";
})
ChildComponent({ onceParam: this.message })
}
}
}
```
本地修改@Param变量
当@Once搭配@Param使用时，可以解除@Param无法在本地修改的限制，且修改能够触发UI刷新。此时，使用@Param @Once相当于使用@Local，区别在于@Param @Once能够接受外部传入初始化。
```typescript
@ObservedV2
class Info {
@Trace name: string;
constructor(name: string) {
this.name = name;
}
}
@ComponentV2
struct Child {
@Param @Once onceParamNum: number = 0;
@Param @Once @Require onceParamInfo: Info;
build() {
Column() {
Text(`Child onceParamNum: ${this.onceParamNum}`)
Text(`Child onceParamInfo: ${this.onceParamInfo.name}`)
Button("changeOnceParamNum")
.onClick(() => {
this.onceParamNum++;
})
Button("changeParamInfo")
.onClick(() => {
this.onceParamInfo = new Info("Cindy");
})
}
}
}
@Entry
@ComponentV2
struct Index {
@Local localNum: number = 10;
@Local localInfo: Info = new Info("Tom");
build() {
Column() {
Text(`Parent localNum: ${this.localNum}`)
Text(`Parent localInfo: ${this.localInfo.name}`)
Button("changeLocalNum")
.onClick(() => {
this.localNum++;
})
Button("changeLocalInfo")
.onClick(() => {
this.localInfo = new Info("Cindy");
})
Child({
onceParamNum: this.localNum,
onceParamInfo: this.localInfo
})
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-event
爬取时间: 2025-04-28 06:57:34
来源: Huawei Developer
为了实现子组件向父组件要求更新@Param装饰变量的能力，开发者可以使用@Event装饰器。使用@Event装饰回调方法是一种规范，表明子组件需要传入更新数据源的回调。
@Event主要配合@Param实现数据的双向同步。在阅读本文档前，建议提前阅读：@Param。
从API version 12开始，在@ComponentV2装饰的自定义组件中支持使用@Event装饰器。
概述
由于@Param装饰的变量在本地无法更改，使用@Event装饰器装饰回调方法并调用，可以实现更改数据源的变量，再通过@Local的同步机制，将修改同步回@Param，以此达到主动更新@Param装饰变量的效果。
@Event用于装饰组件对外输出的方法：
-  @Event装饰的回调方法中参数以及返回值由开发者决定。
-  @Event装饰非回调类型的变量不会生效。当@Event没有初始化时，会自动生成一个空的函数作为默认回调。
-  当@Event未被外部初始化，但本地有默认值时，会使用本地默认的函数进行处理。
@Param标志着组件的输入，表明该变量受父组件影响，而@Event标志着组件的输出，可以通过该方法影响父组件。使用@Event装饰回调方法是一种规范，表明该回调作为自定义组件的输出。父组件需要判断是否提供对应方法用于子组件更改@Param变量的数据源。
装饰器说明
| @Event属性装饰器 | 说明 |
| --- | --- |
| 装饰器参数 | 无。 |
| 允许装饰的变量类型 | 回调方法，例如()=>void、(x:number)=>boolean等。回调方法是否含有参数以及返回值由开发者决定。 |
| 允许传入的函数类型 | 箭头函数。 |
限制条件
-  @Event只能用在@ComponentV2装饰的自定义组件中。当装饰非方法类型的变量时，不会有任何作用。
```typescript
@ComponentV2
struct Index {
@Event changeFactory: ()=>void = ()=>{}; //正确用法
@Event message: string = "abcd"; // 错误用法，装饰非函数类型变量，@Event无作用
}
@Component
struct Index {
@Event changeFactory: ()=>void = ()=>{}; // 错误用法，编译时报错
}
```
使用场景
更改父组件中变量
使用@Event可以更改父组件中变量，当该变量作为子组件@Param变量的数据源时，该变化会同步回子组件的@Param变量。
```typescript
@Entry
@ComponentV2
struct Index {
@Local title: string = "Title One";
@Local fontColor: Color = Color.Red;
build() {
Column() {
Child({
title: this.title,
fontColor: this.fontColor,
changeFactory: (type: number) => {
if (type == 1) {
this.title = "Title One";
this.fontColor = Color.Red;
} else if (type == 2) {
this.title = "Title Two";
this.fontColor = Color.Green;
}
}
})
}
}
}
@ComponentV2
struct Child {
@Param title: string = '';
@Param fontColor: Color = Color.Black;
@Event changeFactory: (x: number) => void = (x: number) => {};
build() {
Column() {
Text(`${this.title}`)
.fontColor(this.fontColor)
Button("change to Title Two")
.onClick(() => {
this.changeFactory(2);
})
Button("change to Title One")
.onClick(() => {
this.changeFactory(1);
})
}
}
}
```
值得注意的是，使用@Event修改父组件的值是立刻生效的，但从父组件将变化同步回子组件的过程是异步的，即在调用完@Event的方法后，子组件内的值不会立刻变化。这是因为@Event将子组件值实际的变化能力交由父组件处理，在父组件实际决定如何处理后，将最终值在渲染之前同步回子组件。
```typescript
@ComponentV2
struct Child {
@Param index: number = 0;
@Event changeIndex: (val: number) => void;
build() {
Column() {
Text(`Child index: ${this.index}`)
.onClick(() => {
this.changeIndex(20);
console.log(`after changeIndex ${this.index}`);
})
}
}
}
@Entry
@ComponentV2
struct Index {
@Local index: number = 0;
build() {
Column() {
Child({
index: this.index,
changeIndex: (val: number) => {
this.index = val;
console.log(`in changeIndex ${this.index}`);
}
})
}
}
}
```
在上面的示例中，点击文字触发@Event函数事件改变子组件的值，打印出的日志为：
这表明在调用changeIndex之后，父组件中index的值已经变化，但子组件中的index值还没有同步变化。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-provider-and-consumer
爬取时间: 2025-04-28 06:57:47
来源: Huawei Developer
@Provider和@Consumer用于跨组件层级数据双向同步，可以使得开发者不用拘泥于组件层级。
@Provider和@Consumer属于状态管理V2装饰器，所以只能在@ComponentV2中才能使用，在@Component中使用会编译报错。
@Provider和@Consumer提供了跨组件层级数据双向同步的能力。在阅读本文档前，建议提前阅读：@ComponentV2。
@Provider和@Consumer装饰器从API version 12开始支持。
概述
@Provider，即数据提供方，其所有的子组件都可以通过@Consumer绑定相同的key来获取@Provider提供的数据。
@Consumer，即数据消费方，可以通过绑定同样的key获取其最近父节点的@Provider的数据，当查找不到@Provider的数据时，使用本地默认值。
@Provider和@Consumer装饰数据类型需要一致。
开发者在使用@Provider和@Consumer时要注意：
@Provider和@Consumer vs @Provide和@Consume能力对比
在状态管理V1版本中，提供跨组件层级双向的装饰器为@Provide和@Consume，当前文档介绍的是状态管理V2装饰器@Provider和@Consumer。虽然两者名字和功能类似，但在特性上还存在一些差异。
如果开发者对状态管理V1中@Provide和@Consume完全不曾了解过，可以直接跳过本节。
| 能力 | V2装饰器@Provider和@Consumer | V1装饰器@Provide和@Consume |
| --- | --- | --- |
| @Consume(r) | 允许本地初始化，当找不到@Provider的时候使用本地默认值。 | 禁止本地初始化，当找不到对应的的@Provide时候，会抛出异常。 |
| 支持类型 | 支持function。 | 不支持function。 |
| 观察能力 | 仅能观察自身赋值变化，如果要观察嵌套场景，配合@Trace一起使用。 | 观察第一层变化，如果要观察嵌套场景，配合@Observed和@ObjectLink一起使用。 |
| alias和属性名 | alias是唯一匹配的key，如果缺省alias，则默认属性名为alias。 | alias和属性名都为key，优先匹配alias，匹配不到可以匹配属性名。 |
| @Provide(r) 从父组件初始化 | 禁止。 | 允许。 |
| @Provide(r)支持重载 | 默认开启，即@Provider可以重名，@Consumer向上查找最近的@Provider。 | 默认关闭，即在组件树上不允许有同名@Provide。如果需要重载，则需要配置allowOverride。 |
装饰器说明
基本规则
@Provider语法：
@Provider(alias?: string) varName : varType = initValue
| @Provider属性装饰器 | 说明 |
| --- | --- |
| 装饰器参数 | aliasName?: string，别名，缺省时默认为属性名。 |
| 支持类型 | 自定义组件中成员变量。属性的类型可以为number、string、boolean、class、Array、Date、Map、Set等类型。支持装饰箭头函数。 |
| 从父组件初始化 | 禁止。 |
| 本地初始化 | 必须本地初始化。 |
| 观察能力 | 能力等同于@Trace。变化会同步给对应的@Consumer。 |
@Consumer语法：
@Consumer(alias?: string) varName : varType = initValue
| @Consumer属性装饰器 | 说明 |
| --- | --- |
| 装饰器参数 | aliasName?: string，别名，缺省时默认为属性名，向上查找最近的@Provider。 |
| 可装饰的变量 | 自定义组件中成员变量。属性的类型可以为number、string、boolean、class、Array、Date、Map、Set等类型。支持装饰箭头函数。 |
| 从父组件初始化 | 禁止。 |
| 本地初始化 | 必须本地初始化。 |
| 观察能力 | 能力等同于@Trace。变化会同步给对应的@Provider。 |
aliasName和属性名
@Provider和@Consumer可接受可选参数aliasName，如果开发者没有配置参数，则使用属性名作为默认的aliasName。注意：aliasName是用于@Provider和@Consumer进行匹配的唯一指定key。
以下三个例子可清楚介绍@Provider和@Consumer如何使用aliasName进行查找匹配。
```typescript
@ComponentV2
struct Parent {
// 未定义aliasName, 使用属性名'str'作为aliasName
@Provider() str: string = 'hello';
}
@ComponentV2
struct Child {
// 定义aliasName为'str'，使用aliasName去寻找
// 能够在Parent组件上找到, 使用@Provider的值'hello'
@Consumer('str') str: string = 'world';
}
```
```typescript
@ComponentV2
struct Parent {
// 定义aliasName为'alias'
@Provider('alias') str: string = 'hello';
}
@ComponentV2 struct Child {
// 定义aliasName为 'alias'，找到@Provider并获得值'hello'
@Consumer('alias') str: string = 'world';
}
```
```typescript
@ComponentV2
struct Parent {
// 定义aliasName为'alias'
@Provider('alias') str: string = 'hello';
}
@ComponentV2
struct Child {
// 未定义aliasName，使用属性名'str'作为aliasName
// 没有找到对应的@Provider，使用本地值'world'
@Consumer() str: string = 'world';
}
```
变量传递
| 传递规则 | 说明 |
| --- | --- |
| 从父组件初始化 | @Provider和@Consumer装饰的变量仅允许本地初始化，无法从外部传入初始化。 |
| 初始化子组件 | @Provider和@Consumer装饰的变量可以初始化子组件中@Param装饰的变量。 |
使用限制
使用场景
@Provider和@Consumer双向同步
建立双向绑定
```typescript
@Entry
@ComponentV2
struct Parent {
@Provider() str: string = 'hello';
build() {
Column() {
Button(this.str)
.onClick(() => {
this.str += '0';
})
Child()
}
}
}
@ComponentV2
struct Child {
@Consumer() str: string = 'world';
build() {
Column() {
Button(this.str)
.onClick(() => {
this.str += '0';
})
}
}
}
```
未建立双向绑定
下面的例子中，@Provider和@Consumer由于aliasName值不同，无法建立双向同步关系。
```typescript
@Entry
@ComponentV2
struct Parent {
@Provider() str1: string = 'hello';
build() {
Column() {
Button(this.str1)
.onClick(() => {
this.str1 += '0';
})
Child()
}
}
}
@ComponentV2
struct Child {
@Consumer() str: string = 'world';
build() {
Column() {
Button(this.str)
.onClick(() => {
this.str += '0';
})
}
}
}
```
@Provider和@Consumer装饰回调事件，用于组件之间完成行为抽象
当需要在父组件中向子组件注册回调函数时，可以通过使用@Provider和@Consumer装饰回调方法来解决。
比如拖拽场景，当发生拖拽事件时，如果希望将子组件拖拽的起始位置信息同步给父组件，可以参考下面的例子。
```typescript
@Entry
@ComponentV2
struct Parent {
@Local childX: number = 0;
@Local childY: number = 1;
@Provider() onDrag: (x: number, y: number) => void = (x: number, y: number) => {
console.log(`onDrag event at x=${x} y:${y}`);
this.childX = x;
this.childY = y;
}
build() {
Column() {
Text(`child position x: ${this.childX}, y: ${this.childY}`)
Child()
}
}
}
@ComponentV2
struct Child {
@Consumer() onDrag: (x: number, y: number) => void = (x: number, y: number) => {};
build() {
Button("changed")
.draggable(true)
.onDragStart((event: DragEvent) => {
// 当前预览器上不支持通用拖拽事件
this.onDrag(event.getDisplayX(), event.getDisplayY());
})
}
}
```
@Provider和@Consumer装饰复杂类型，配合@Trace一起使用
```typescript
@ObservedV2
class User {
@Trace name: string;
@Trace age: number;
constructor(name: string, age: number) {
this.name = name;
this.age = age;
}
}
const data: User[] = [new User('Json', 10), new User('Eric', 15)];
@Entry
@ComponentV2
struct Parent {
@Provider('data') users: User[] = data;
build() {
Column() {
Child()
Button('add new user')
.onClick(() => {
this.users.push(new User('Molly', 18));
})
Button('age++')
.onClick(() => {
this.users[0].age++;
})
Button('change name')
.onClick(() => {
this.users[0].name = 'Shelly';
})
}
}
}
@ComponentV2
struct Child {
@Consumer('data') users: User[] = [];
build() {
Column() {
ForEach(this.users, (item: User) => {
Column() {
Text(`name: ${item.name}`).fontSize(30)
Text(`age: ${item.age}`).fontSize(30)
Divider()
}
})
}
}
}
```
@Provider重名时，@Consumer向上查找其最近的@Provider
@Provider可以在组件树上重名，@Consumer会向上查找其最近父节点的@Provider的数据。
```typescript
@Entry
@ComponentV2
struct Index {
@Provider() val: number = 10;
build() {
Column() {
Parent()
}
}
}
@ComponentV2
struct Parent {
@Provider() val: number = 20;
@Consumer("val") val2: number = 0; // 10
build() {
Column() {
Text(`${this.val2}`)
Child()
}
}
}
@ComponentV2
struct Child {
@Consumer() val: number = 0; // 20
build() {
Column() {
Text(`${this.val}`)
}
}
}
```
上面的例子中：
@Provider和@Consumer初始化@Param
```typescript
@Entry
@ComponentV2
struct Index {
@Provider() val: number = 10;
build() {
Column() {
Parent({ val2: this.val })
}
}
}
@ComponentV2
struct Parent {
@Consumer() val: number = 0;
@Param val2: number = 0;
build() {
Column() {
Text(`Parent @Consumer val: ${this.val}`).fontSize(30).onClick(() => {
this.val++;
})
Text(`Parent @Param val2: ${this.val2}`).fontSize(30)
Child({ val: this.val })
}.border({ width: 2, color: Color.Green })
}
}
@ComponentV2
struct Child {
@Param val: number = 0;
build() {
Column() {
Text(`Child @Param val ${this.val}`).fontSize(30)
}.border({ width: 2, color: Color.Pink })
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-monitor
爬取时间: 2025-04-28 06:58:01
来源: Huawei Developer
为了增强状态管理框架对状态变量变化的监听能力，开发者可以使用@Monitor装饰器对状态变量进行监听。
@Monitor提供了对V2状态变量的监听。在阅读本文档前，建议提前阅读：@ComponentV2，@ObservedV2和@Trace，@Local。
@Monitor装饰器从API version 12开始支持。
概述
@Monitor装饰器用于监听状态变量修改，使得状态变量具有深度监听的能力：
-  @Monitor装饰器支持在@ComponentV2装饰的自定义组件中使用，未被状态变量装饰器@Local、@Param、@Provider、@Consumer、@Computed装饰的变量无法被@Monitor监听到变化。
-  @Monitor装饰器支持在类中与@ObservedV2、@Trace配合使用，不允许在未被@ObservedV2装饰的类中使用@Monitor装饰器。未被@Trace装饰的属性无法被@Monitor监听到变化。
-  当观测的属性变化时，@Monitor装饰器定义的回调方法将被调用。判断属性是否变化使用的是严格相等（===），当严格相等判断的结果是false（即不相等）的情况下，就会触发@Monitor的回调。当在一次事件中多次改变同一个属性时，将会使用初始值和最终值进行比较以判断是否变化。
-  单个@Monitor装饰器能够同时监听多个属性的变化，当这些属性在一次事件中共同变化时，只会触发一次@Monitor的回调方法。
-  @Monitor装饰器具有深度监听的能力，能够监听嵌套类、多维数组、对象数组中指定项的变化。对于嵌套类、对象数组中成员属性变化的监听要求该类被@ObservedV2装饰且该属性被@Trace装饰。
-  在继承类场景中，可以在父子组件中对同一个属性分别定义@Monitor进行监听，当属性变化时，父子组件中定义的@Monitor回调均会被调用。
-  和@Watch装饰器类似，开发者需要自己定义回调函数，区别在于@Watch装饰器将函数名作为参数，而@Monitor直接装饰回调函数。@Monitor与@Watch的对比可以查看@Monitor与@Watch的对比。
状态管理V1版本@Watch装饰器的局限性
现有状态管理V1版本无法实现对对象、数组中某一单个属性或数组项变化的监听，且无法获取变化之前的值。
```typescript
@Observed
class Info {
name: string = "Tom";
age: number = 25;
}
@Entry
@Component
struct Index {
@State @Watch('onInfoChange') info: Info = new Info();
@State @Watch('onNumArrChange') numArr: number[] = [1,2,3,4,5];
onInfoChange() {
console.log(`info after change name: ${this.info.name}, age: ${this.info.age} `);
}
onNumArrChange() {
console.log(`numArr after change ${JSON.stringify(this.numArr)}`);
}
build() {
Row() {
Column() {
Button("change info name")
.onClick(() => {
this.info.name = "Jack";
})
Button("change info age")
.onClick(() => {
this.info.age = 30;
})
Button("change numArr[2]")
.onClick(() => {
this.numArr[2] = 5;
})
Button("change numArr[3]")
.onClick(() => {
this.numArr[3] = 6;
})
}
.width('100%')
}
.height('100%')
}
}
```
上述代码中，点击"change info name"更改info中的name属性或点击"change info age"更改age时，均会触发info注册的@Watch回调。点击"change numArr[2]"更改numArr中的第3个元素或点击"change numArr[3]"更改第4个元素时，均会触发numArr注册的@Watch回调。在这两个回调中，由于无法获取数据更改前的值，在业务逻辑更加复杂的场景下，无法准确知道是哪一个属性或元素发生了改变从而触发了@Watch事件，这不便于开发者对变量的更改进行准确监听。因此推出@Monitor装饰器实现对对象、数组中某一单个属性或数组项变化的监听，并且能够获取到变化之前的值。
装饰器说明
| @Monitor属性装饰器 | 说明 |
| --- | --- |
| 装饰器参数 | 字符串类型的对象属性名。可同时监听多个对象属性，每个属性以逗号隔开，例如@Monitor("prop1", "prop2")。可监听深层的属性变化，如多维数组中的某一个元素，嵌套对象或对象数组中的某一个属性。详见监听变化。 |
| 装饰对象 | @Monitor装饰成员方法。当监听的属性发生变化时，会触发该回调方法。该回调方法以IMonitor类型的变量作为参数，开发者可以从该参数中获取变化前后的相关信息。 |
接口说明
IMonitor类型
IMonitor类型的变量用作@Monitor装饰方法的参数。
| 属性 | 类型 | 参数 | 返回值 | 说明 |
| --- | --- | --- | --- | --- |
| dirty | Array<string> | 无 | 无 | 保存发生变化的属性名。 |
| value<T> | function | path?: string | IMonitorValue<T> | 获得指定属性（path）的变化信息。当不填path时返回@Monitor监听顺序中第一个改变的属性的变化信息。 |
IMonitorValue<T>类型
IMonitorValue<T>类型保存了属性变化的信息，包括属性名、变化前值、当前值。
| 属性 | 类型 | 说明 |
| --- | --- | --- |
| before | T | 监听属性变化之前的值。 |
| now | T | 监听属性变化之后的当前值。 |
| path | string | 监听的属性名。 |
监听变化
在@ComponentV2装饰的自定义组件中使用@Monitor
使用@Monitor监听的状态变量发生变化时，会触发@Monitor的回调方法。
-  @Monitor监听的变量需要被@Local、@Param、@Provider、@Consumer、@Computed装饰，未被状态变量装饰器装饰的变量在变化时无法被监听。@Monitor可以同时监听多个状态变量，这些变量名之间用","隔开。
```typescript
@Entry
@ComponentV2
struct Index {
@Local message: string = "Hello World";
@Local name: string = "Tom";
@Local age: number = 24;
@Monitor("message", "name")
onStrChange(monitor: IMonitor) {
monitor.dirty.forEach((path: string) => {
console.log(`${path} changed from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`)
})
}
build() {
Column() {
Button("change string")
.onClick(() => {
this.message += "!";
this.name = "Jack";
})
}
}
}
```
-  @Monitor监听的状态变量为类对象时，仅能监听对象整体的变化。监听类属性的变化需要类属性被@Trace装饰。
```typescript
class Info {
name: string;
age: number;
constructor(name: string, age: number) {
this.name = name;
this.age = age;
}
}
@Entry
@ComponentV2
struct Index {
@Local info: Info = new Info("Tom", 25);
@Monitor("info")
infoChange(monitor: IMonitor) {
console.log(`info change`);
}
@Monitor("info.name")
infoPropertyChange(monitor: IMonitor) {
console.log(`info name change`);
}
build() {
Column() {
Text(`name: ${this.info.name}, age: ${this.info.age}`)
Button("change info")
.onClick(() => {
this.info = new Info("Lucy", 18); // 能够监听到
})
Button("change info.name")
.onClick(() => {
this.info.name = "Jack"; // 监听不到
})
}
}
}
```
在@ObservedV2装饰的类中使用@Monitor
使用@Monitor监听的属性发生变化时，会触发@Monitor的回调方法。
```typescript
@ObservedV2
class Info {
@Trace name: string = "Tom";
@Trace region: string = "North";
@Trace job: string = "Teacher";
age: number = 25;
// name被@Trace装饰，能够监听变化
@Monitor("name")
onNameChange(monitor: IMonitor) {
console.log(`name change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
// age未被@Trace装饰，不能监听变化
@Monitor("age")
onAgeChange(monitor: IMonitor) {
console.log(`age change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
// region与job均被@Trace装饰，能够监听变化
@Monitor("region", "job")
onChange(monitor: IMonitor) {
monitor.dirty.forEach((path: string) => {
console.log(`${path} change from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`);
})
}
}
@Entry
@ComponentV2
struct Index {
info: Info = new Info();
build() {
Column() {
Button("change name")
.onClick(() => {
this.info.name = "Jack"; // 能够触发onNameChange方法
})
Button("change age")
.onClick(() => {
this.info.age = 26; // 不能够触发onAgeChange方法
})
Button("change region")
.onClick(() => {
this.info.region = "South"; // 能够触发onChange方法
})
Button("change job")
.onClick(() => {
this.info.job = "Driver"; // 能够触发onChange方法
})
}
}
}
```
```typescript
@ObservedV2
class Inner {
@Trace num: number = 0;
}
@ObservedV2
class Outer {
inner: Inner = new Inner();
@Monitor("inner.num")
onChange(monitor: IMonitor) {
console.log(`inner.num change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
}
@Entry
@ComponentV2
struct Index {
outer: Outer = new Outer();
build() {
Column() {
Button("change name")
.onClick(() => {
this.outer.inner.num = 100; // 能够触发onChange方法
})
}
}
}
```
```typescript
@ObservedV2
class Base {
@Trace name: string;
// 基类监听name属性
@Monitor("name")
onBaseNameChange(monitor: IMonitor) {
console.log(`Base Class name change`);
}
constructor(name: string) {
this.name = name;
}
}
@ObservedV2
class Derived extends Base {
// 继承类监听name属性
@Monitor("name")
onDerivedNameChange(monitor: IMonitor) {
console.log(`Derived Class name change`);
}
constructor(name: string) {
super(name);
}
}
@Entry
@ComponentV2
struct Index {
derived: Derived = new Derived("AAA");
build() {
Column() {
Button("change name")
.onClick(() => {
this.derived.name = "BBB"; // 能够先后触发onBaseNameChange、onDerivedNameChange方法
})
}
}
}
```
通用监听能力
@Monitor还有一些通用的监听能力。
```typescript
@ObservedV2
class Info {
@Trace name: string;
@Trace age: number;
constructor(name: string, age: number) {
this.name = name;
this.age = age;
}
}
@ObservedV2
class ArrMonitor {
@Trace dimensionTwo: number[][] = [[1,1,1],[2,2,2],[3,3,3]];
@Trace dimensionThree: number[][][] = [[[1],[2],[3]],[[4],[5],[6]],[[7],[8],[9]]];
@Trace infoArr: Info[] = [new Info("Jack", 24), new Info("Lucy", 18)];
// dimensionTwo为二维简单类型数组，且被@Trace装饰，能够观测里面的元素变化
@Monitor("dimensionTwo.0.0", "dimensionTwo.1.1")
onDimensionTwoChange(monitor: IMonitor) {
monitor.dirty.forEach((path: string) => {
console.log(`dimensionTwo path: ${path} change from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`);
})
}
// dimensionThree为三维简单类型数组，且被@Trace装饰，能够观测里面的元素变化
@Monitor("dimensionThree.0.0.0", "dimensionThree.1.1.0")
onDimensionThreeChange(monitor: IMonitor) {
monitor.dirty.forEach((path: string) => {
console.log(`dimensionThree path: ${path} change from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`);
})
}
// Info类中属性name、age均被@Trace装饰，能够监听到变化
@Monitor("infoArr.0.name", "infoArr.1.age")
onInfoArrPropertyChange(monitor: IMonitor) {
monitor.dirty.forEach((path: string) => {
console.log(`infoArr path:${path} change from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`);
})
}
// infoArr被@Trace装饰，能够监听到infoArr整体赋值的变化
@Monitor("infoArr")
onInfoArrChange(monitor: IMonitor) {
console.log(`infoArr whole change`);
}
// 能够监听到infoArr的长度变化
@Monitor("infoArr.length")
onInfoArrLengthChange(monitor: IMonitor) {
console.log(`infoArr length change`);
}
}
@Entry
@ComponentV2
struct Index {
arrMonitor: ArrMonitor = new ArrMonitor();
build() {
Column() {
Button("Change dimensionTwo")
.onClick(() => {
// 能够触发onDimensionTwoChange方法
this.arrMonitor.dimensionTwo[0][0]++;
this.arrMonitor.dimensionTwo[1][1]++;
})
Button("Change dimensionThree")
.onClick(() => {
// 能够触发onDimensionThreeChange方法
this.arrMonitor.dimensionThree[0][0][0]++;
this.arrMonitor.dimensionThree[1][1][0]++;
})
Button("Change info property")
.onClick(() => {
// 能够触发onInfoArrPropertyChange方法
this.arrMonitor.infoArr[0].name = "Tom";
this.arrMonitor.infoArr[1].age = 19;
})
Button("Change whole infoArr")
.onClick(() => {
// 能够触发onInfoArrChange、onInfoArrPropertyChange、onInfoArrLengthChange方法
this.arrMonitor.infoArr = [new Info("Cindy", 8)];
})
Button("Push new info to infoArr")
.onClick(() => {
// 能够触发onInfoArrPropertyChange、onInfoArrLengthChange方法
this.arrMonitor.infoArr.push(new Info("David", 50));
})
}
}
}
```
下面的示例按照Step1-Step2-Step3的顺序点击，表现为代码注释中的行为。
如果只点击Step2或Step3，改变name、age的值，此时会触发onNameChange和onAgeChange方法。
```typescript
@ObservedV2
class Info {
@Trace person: Person;
@Monitor("person.name")
onNameChange(monitor: IMonitor) {
console.log(`name change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
@Monitor("person.age")
onAgeChange(monitor: IMonitor) {
console.log(`age change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
constructor(name: string, age: number) {
this.person = new Person(name, age);
}
}
@ObservedV2
class Person {
@Trace name: string;
@Trace age: number;
constructor(name: string, age: number) {
this.name = name;
this.age = age;
}
}
@Entry
@ComponentV2
struct Index {
info: Info = new Info("Tom", 25);
build() {
Column() {
Button("Step1、Only change name")
.onClick(() => {
this.info.person = new Person("Jack", 25);  // 能够触发onNameChange方法，不触发onAgeChange方法
})
Button("Step2、Only change age")
.onClick(() => {
this.info.person = new Person("Jack", 18);  // 能够触发onAgeChange方法，不触发onNameChange方法
})
Button("Step3、Change name and age")
.onClick(() => {
this.info.person = new Person("Lucy", 19);  // 能够触发onNameChange、onAgeChange方法
})
}
}
}
```
```typescript
@ObservedV2
class Frequence {
@Trace count: number = 0;
@Monitor("count")
onCountChange(monitor: IMonitor) {
console.log(`count change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
}
@Entry
@ComponentV2
struct Index {
frequence: Frequence = new Frequence();
build() {
Column() {
Button("change count to 1000")
.onClick(() => {
for (let i = 1; i <= 1000; i++) {
this.frequence.count = i;
}
})
Button("change count to 0 then to 1000")
.onClick(() => {
for (let i = 999; i >= 0; i--) {
this.frequence.count = i;
}
this.frequence.count = 1000; // 最终不触发onCountChange方法
})
}
}
}
```
在点击按钮"change count to 1000"后，会触发一次onCountChange方法，并输出日志"count change from 0 to 1000"。在点击按钮"change count to 0 then to 1000"后，由于事件前后属性count的值并没有改变，都为1000，所以不触发onCountChange方法。
限制条件
使用@Monitor需要注意如下限制条件：
```typescript
@ObservedV2
class Info {
@Trace name: string = "Tom";
@Monitor("name")
onNameChange(monitor: IMonitor) {
console.log(`onNameChange`);
}
@Monitor("name")
onNameChangeDuplicate(monitor: IMonitor) {
console.log(`onNameChangeDuplicate`);
}
}
@Entry
@ComponentV2
struct Index {
info: Info = new Info();
build() {
Column() {
Button("change name")
.onClick(() => {
this.info.name = "Jack"; // 仅会触发onNameChangeDuplicate方法
})
}
}
}
```
```typescript
const t2: string = "t2"; // const常量
enum ENUM {
T3 = "t3" // enum枚举值
};
let t4: string = "t4"; // 变量
@ObservedV2
class Info {
@Trace t1: number = 0;
@Trace t2: number = 0;
@Trace t3: number = 0;
@Trace t4: number = 0;
@Trace t5: number = 0;
@Monitor("t1") // 字符串字面量
onT1Change(monitor: IMonitor) {
console.log(`t1 change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
@Monitor(t2)
onT2Change(monitor: IMonitor) {
console.log(`t2 change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
@Monitor(ENUM.T3)
onT3Change(monitor: IMonitor) {
console.log(`t3 change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
@Monitor(t4)
onT4Change(monitor: IMonitor) {
console.log(`t4 change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
}
@Entry
@ComponentV2
struct Index {
info: Info = new Info();
build() {
Column() {
Button("Change t1")
.onClick(() => {
this.info.t1++; // 能够触发onT1Change方法
})
Button("Change t2")
.onClick(() => {
this.info.t2++; // 能够触发onT2Change方法
})
Button("Change t3")
.onClick(() => {
this.info.t3++; // 能够触发onT3Change方法
})
Button("Change t4")
.onClick(() => {
this.info.t4++; // 能够触发onT4Change方法
})
Button("Change var t4 to t5")
.onClick(() => {
t4 = "t5"; // 更改变量值为"t5"
})
Button("Change t5")
.onClick(() => {
this.info.t5++; // onT4Change仍监听t4，不会触发
})
Button("Change t4 again")
.onClick(() => {
this.info.t4++; // 能够触发onT4Change方法
})
}
}
}
```
```typescript
@ObservedV2
class Info {
@Trace count: number = 0;
@Monitor("count")
onCountChange(monitor: IMonitor) {
this.count++; // 应避免这种写法，会导致无限循环
}
}
```
@Monitor与@Watch对比
@Monitor与@Watch的用法、功能对比如下：
|   | @Watch | @Monitor |
| --- | --- | --- |
| 参数 | 回调方法名。 | 监听状态变量名、属性名。 |
| 监听目标数 | 只能监听单个状态变量。 | 能同时监听多个状态变量。 |
| 监听能力 | 跟随状态变量观察能力（一层）。 | 跟随状态变量观察能力（深层）。 |
| 能否获取变化前的值 | 不能获取变化前的值。 | 能获取变化前的值。 |
| 监听条件 | 监听对象为状态变量。 | 监听对象为状态变量或为@Trace装饰的类成员属性。 |
| 使用限制 | 仅能在@Component装饰的自定义组件中使用。 | 能在@ComponentV2装饰的自定义组件中使用，也能在@ObservedV2装饰的类中使用。 |
使用场景
监听深层属性变化
@Monitor可以监听深层属性的变化，并能够根据更改前后的值做分类处理。
下面的示例中监听了属性value的变化，并根据变化的幅度改变Text组件显示的样式。
```typescript
@ObservedV2
class Info {
@Trace value: number = 50;
}
@ObservedV2
class UIStyle {
info: Info = new Info();
@Trace color: Color = Color.Black;
@Trace fontSize: number = 45;
@Monitor("info.value")
onValueChange(monitor: IMonitor) {
let lastValue: number = monitor.value()?.before as number;
let curValue: number = monitor.value()?.now as number;
if (lastValue != 0) {
let diffPercent: number = (curValue - lastValue) / lastValue;
if (diffPercent > 0.1) {
this.color = Color.Red;
this.fontSize = 50;
} else if (diffPercent < -0.1) {
this.color = Color.Green;
this.fontSize = 40;
} else {
this.color = Color.Black;
this.fontSize = 45;
}
}
}
}
@Entry
@ComponentV2
struct Index {
textStyle: UIStyle = new UIStyle();
build() {
Column() {
Text(`Important Value: ${this.textStyle.info.value}`)
.fontColor(this.textStyle.color)
.fontSize(this.textStyle.fontSize)
Button("change!")
.onClick(() => {
this.textStyle.info.value = Math.floor(Math.random() * 100) + 1;
})
}
}
}
```
常见问题
自定义组件中@Monitor对变量监听的生效及失效时间
当@Monitor定义在@ComponentV2装饰的自定义组件中时，@Monitor会在状态变量初始化完成之后生效，并在组件销毁时失效。
```typescript
@ObservedV2
class Info {
@Trace message: string = "not initialized";
constructor() {
console.log("in constructor message change to initialized");
this.message = "initialized";
}
}
@ComponentV2
struct Child {
@Param info: Info = new Info();
@Monitor("info.message")
onMessageChange(monitor: IMonitor) {
console.log(`Child message change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
aboutToAppear(): void {
this.info.message = "Child aboutToAppear";
}
aboutToDisappear(): void {
console.log("Child aboutToDisappear");
this.info.message = "Child aboutToDisappear";
}
build() {
Column() {
Text("Child")
Button("change message in Child")
.onClick(() => {
this.info.message = "Child click to change Message";
})
}
.borderColor(Color.Red)
.borderWidth(2)
}
}
@Entry
@ComponentV2
struct Index {
@Local info: Info = new Info();
@Local flag: boolean = false;
@Monitor("info.message")
onMessageChange(monitor: IMonitor) {
console.log(`Index message change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
build() {
Column() {
Button("show/hide Child")
.onClick(() => {
this.flag = !this.flag
})
Button("change message in Index")
.onClick(() => {
this.info.message = "Index click to change Message";
})
if (this.flag) {
Child({ info: this.info })
}
}
}
}
```
在上面的例子中，可以通过创建和销毁Child组件来观察定义在自定义组件中的@Monitor的生效和失效时机。推荐按如下顺序进行操作：
这表明Child组件中定义的@Monitor监听随着Child组件的创建初始化生效，随着Child组件的销毁失效。
类中@Monitor对变量监听的生效及失效时间
当@Monitor定义在@ObservedV2装饰的类中时，@Monitor会在类创建完成后生效，在类销毁时失效。
```typescript
@ObservedV2
class Info {
@Trace message: string = "not initialized";
constructor() {
this.message = "initialized";
}
@Monitor("message")
onMessageChange(monitor: IMonitor) {
console.log(`message change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
}
@Entry
@ComponentV2
struct Index {
info: Info = new Info();
aboutToAppear(): void {
this.info.message = "Index aboutToAppear";
}
build() {
Column() {
Button("change message")
.onClick(() => {
this.info.message = "Index click to change message";
})
}
}
}
```
上面的例子中，@Monitor会在info创建完成后生效，这个时机晚于类的constructor，早于自定义组件的aboutToAppear。当界面加载完成后，点击“change message”，修改message变量。此时日志输出信息如下：
```typescript
message change from initialized to Index aboutToAppear
message change from Index aboutToAppear to Index click to change message
```
类中定义的@Monitor随着类的销毁失效。而由于类的实际销毁释放依赖于垃圾回收机制，因此会出现即使所在自定义组件已经销毁，类却还未及时销毁，导致类中定义的@Monitor仍在监听变化的情况。
```typescript
@ObservedV2
class InfoWrapper {
info?: Info;
constructor(info: Info) {
this.info = info;
}
@Monitor("info.age")
onInfoAgeChange(monitor: IMonitor) {
console.log(`age change from ${monitor.value()?.before} to ${monitor.value()?.now}`)
}
}
@ObservedV2
class Info {
@Trace age: number;
constructor(age: number) {
this.age = age;
}
}
@ComponentV2
struct Child {
@Param @Require infoWrapper: InfoWrapper;
aboutToDisappear(): void {
console.log("Child aboutToDisappear", this.infoWrapper.info?.age)
}
build() {
Column() {
Text(`${this.infoWrapper.info?.age}`)
}
}
}
@Entry
@ComponentV2
struct Index {
dataArray: Info[] = [];
@Local showFlag: boolean = true;
aboutToAppear(): void {
for (let i = 0; i < 5; i++) {
this.dataArray.push(new Info(i));
}
}
build() {
Column() {
Button("change showFlag")
.onClick(() => {
this.showFlag = !this.showFlag;
})
Button("change number")
.onClick(() => {
console.log("click to change age")
this.dataArray.forEach((info: Info) => {
info.age += 100;
})
})
if (this.showFlag) {
Column() {
Text("Childs")
ForEach(this.dataArray, (info: Info) => {
Child({ infoWrapper: new InfoWrapper(info) })
})
}
.borderColor(Color.Red)
.borderWidth(2)
}
}
}
}
```
在上面的例子中，当点击“change showFlag”切换if组件的条件时，Child组件会被销毁。此时，点击“change number”修改age的值时，可以通过日志观察到InfoWrapper中定义的@Monitor回调仍然被触发了。这是因为此时自定义组件Child虽然执行了aboutToDisappear，但是其成员变量infoWrapper还没有被立刻回收，当变量发生变化时，依然能够调用到infoWrapper中定义的onInfoAgeChange方法，所以从现象上看@Monitor回调仍会被触发。
借助垃圾回收机制去取消@Monitor的监听是不稳定的，开发者可以采用以下两种方式去管理@Monitor的失效时间：
1、将@Monitor定义在自定义组件中。由于自定义组件在销毁时，状态管理框架会手动取消@Monitor的监听，因此在自定义组件调用完aboutToDisappear，尽管自定义组件的数据不一定已经被释放，但@Monitor回调已不会再被触发。
```typescript
@ObservedV2
class InfoWrapper {
info?: Info;
constructor(info: Info) {
this.info = info;
}
}
@ObservedV2
class Info {
@Trace age: number;
constructor(age: number) {
this.age = age;
}
}
@ComponentV2
struct Child {
@Param @Require infoWrapper: InfoWrapper;
@Monitor("infoWrapper.info.age")
onInfoAgeChange(monitor: IMonitor) {
console.log(`age change from ${monitor.value()?.before} to ${monitor.value()?.now}`)
}
aboutToDisappear(): void {
console.log("Child aboutToDisappear", this.infoWrapper.info?.age)
}
build() {
Column() {
Text(`${this.infoWrapper.info?.age}`)
}
}
}
@Entry
@ComponentV2
struct Index {
dataArray: Info[] = [];
@Local showFlag: boolean = true;
aboutToAppear(): void {
for (let i = 0; i < 5; i++) {
this.dataArray.push(new Info(i));
}
}
build() {
Column() {
Button("change showFlag")
.onClick(() => {
this.showFlag = !this.showFlag;
})
Button("change number")
.onClick(() => {
console.log("click to change age")
this.dataArray.forEach((info: Info) => {
info.age += 100;
})
})
if (this.showFlag) {
Column() {
Text("Childs")
ForEach(this.dataArray, (info: Info) => {
Child({ infoWrapper: new InfoWrapper(info) })
})
}
.borderColor(Color.Red)
.borderWidth(2)
}
}
}
}
```
2、主动置空监听的对象。当自定义组件即将销毁时，主动置空@Monitor的监听目标，这样@Monitor无法再监听原监听目标的变化，达到取消@Monitor监听的效果。
```typescript
@ObservedV2
class InfoWrapper {
info?: Info;
constructor(info: Info) {
this.info = info;
}
@Monitor("info.age")
onInfoAgeChange(monitor: IMonitor) {
console.log(`age change from ${monitor.value()?.before} to ${monitor.value()?.now}`)
}
}
@ObservedV2
class Info {
@Trace age: number;
constructor(age: number) {
this.age = age;
}
}
@ComponentV2
struct Child {
@Param @Require infoWrapper: InfoWrapper;
aboutToDisappear(): void {
console.log("Child aboutToDisappear", this.infoWrapper.info?.age)
this.infoWrapper.info = undefined; // 使InfoWrapper对info.age的监听失效
}
build() {
Column() {
Text(`${this.infoWrapper.info?.age}`)
}
}
}
@Entry
@ComponentV2
struct Index {
dataArray: Info[] = [];
@Local showFlag: boolean = true;
aboutToAppear(): void {
for (let i = 0; i < 5; i++) {
this.dataArray.push(new Info(i));
}
}
build() {
Column() {
Button("change showFlag")
.onClick(() => {
this.showFlag = !this.showFlag;
})
Button("change number")
.onClick(() => {
console.log("click to change age")
this.dataArray.forEach((info: Info) => {
info.age += 100;
})
})
if (this.showFlag) {
Column() {
Text("Childs")
ForEach(this.dataArray, (info: Info) => {
Child({ infoWrapper: new InfoWrapper(info) })
})
}
.borderColor(Color.Red)
.borderWidth(2)
}
}
}
}
```
正确设置@Monitor入参
由于@Monitor无法对入参做编译时校验，当前存在以下写法不符合@Monitor监听条件但@Monitor仍会触发的情况。开发者应当正确传入@Monitor入参，不传入非状态变量，避免造成功能异常或行为表现不符合预期。
【反例1】
```typescript
@ObservedV2
class Info {
name: string = "John";
@Trace age: number = 24;
@Monitor("age", "name") // 同时监听状态变量age和非状态变量name
onPropertyChange(monitor: IMonitor) {
monitor.dirty.forEach((path: string) => {
console.log(`property path:${path} change from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`);
})
}
}
@Entry
@ComponentV2
struct Index {
info: Info = new Info();
build() {
Column() {
Button("change age&name")
.onClick(() => {
this.info.age = 25; // 同时改变状态变量age和非状态变量name
this.info.name = "Johny";
})
}
}
}
```
上面的代码中，当点击按钮同时更改状态变量age和非状态变量name时，会输出以下日志：
实际上name属性本身并不是可被观测的变量，不应被加入到@Monitor的入参当中。建议开发者去除对name属性的监听或者给name加上@Trace装饰成为状态变量。
【正例1】
```typescript
@ObservedV2
class Info {
name: string = "John";
@Trace age: number = 24;
@Monitor("age") // 仅监听状态变量age
onPropertyChange(monitor: IMonitor) {
monitor.dirty.forEach((path: string) => {
console.log(`property path:${path} change from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`);
})
}
}
@Entry
@ComponentV2
struct Index {
info: Info = new Info();
build() {
Column() {
Button("change age&name")
.onClick(() => {
this.info.age = 25; // 状态变量age改变
this.info.name = "Johny";
})
}
}
}
```
【反例2】
```typescript
@ObservedV2
class Info {
name: string = "John";
@Trace age: number = 24;
get myAge() {
return this.age; // age为状态变量
}
@Monitor("myAge") // 监听非@Computed装饰的getter访问器
onPropertyChange() {
console.log("age changed");
}
}
@Entry
@ComponentV2
struct Index {
info: Info = new Info();
build() {
Column() {
Button("change age")
.onClick(() => {
this.info.age = 25; // 状态变量age改变
})
}
}
}
```
上面的代码中，@Monitor的入参为一个getter访问器的名字，但该getter访问器本身并未被@Computed装饰，不是一个可被监听的变量。但由于使用了状态变量参与了计算，在状态变量变化后，myAge也被认为发生了变化，因此触发了@Monitor回调。建议开发者给myAge添加@Computed装饰器或当getter访问器直接返回状态变量时，不监听getter访问器而是直接监听状态变量本身。
【正例2】
将myAge变为状态变量：
```typescript
@ObservedV2
class Info {
name: string = "John";
@Trace age: number = 24;
@Computed // 给myAge添加@Computed成为状态变量
get myAge() {
return this.age;
}
@Monitor("myAge") // 监听@Computed装饰的getter访问器
onPropertyChange() {
console.log("age changed");
}
}
@Entry
@ComponentV2
struct Index {
info: Info = new Info();
build() {
Column() {
Button("change age")
.onClick(() => {
this.info.age = 25; // 状态变量age改变
})
}
}
}
```
或直接监听状态变量本身：
```typescript
@ObservedV2
class Info {
name: string = "John";
@Trace age: number = 24;
@Monitor("age") // 监听状态变量age
onPropertyChange() {
console.log("age changed");
}
}
@Entry
@ComponentV2
struct Index {
info: Info = new Info();
build() {
Column() {
Button("change age")
.onClick(() => {
this.info.age = 25; // 状态变量age改变
})
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-computed
爬取时间: 2025-04-28 06:58:15
来源: Huawei Developer
@Computed装饰器：计算属性，在被计算的值变化的时候，只会计算一次。主要应用于解决UI多次重用该属性从而重复计算导致的性能问题。
状态变量的变化可以触发其关联@Computed的重新计算。在阅读本文档前，建议提前阅读：@ComponentV2，@ObservedV2和@Trace，@Local。
@Computed装饰器从API version 12开始支持。
概述
@Computed为方法装饰器，装饰getter方法。@Computed会检测被计算的属性变化，当被计算的属性变化时，@Computed只会被求解一次。
对于复杂的计算，@Computed会有性能收益。
装饰器说明
@Computed语法：
```typescript
@Computed
get varName(): T {
return value;
}
```
| @Computed方法装饰器 | 说明 |
| --- | --- |
| 支持类型 | getter访问器。 |
| 从父组件初始化 | 禁止。 |
| 可初始化子组件 | @Param。 |
| 被执行的时机 | @ComponentV2被初始化时，计算属性会被触发计算。当被计算的值改变的时候，计算属性也会发生计算。 |
| 是否允许赋值 | @Computed装饰的属性是只读的，不允许赋值，详情见使用限制。 |
使用限制
-  @Computed为方法装饰器，仅能装饰getter方法。
```typescript
@Computed
get fullName() { // 正确用法
return this.firstName + ' ' + this.lastName;
}
@Computed val: number = 0; // 错误用法，编译时报错
@Computed
func() { // 错误用法，编译时报错
}
```
-  在@Computed装饰的getter方法中，不能改变参与计算的属性。
```typescript
@Computed
get fullName() {
this.lastName += 'a'; // 错误，不能改变参与计算的属性
return this.firstName + ' ' + this.lastName;
}
```
-  @Computed不能和双向绑定!!连用，@Computed装饰的是getter访问器，不会被子组件同步，也不能被赋值。开发者自己实现的计算属性的setter不生效，且产生运行时报错。
```typescript
@ComponentV2
struct Child {
@Param double: number = 100;
@Event $double: (val: number) => void;
build() {
Button('ChildChange')
.onClick(() => {
this.$double(200);
})
}
}
@Entry
@ComponentV2
struct Index {
@Local count: number = 100;
@Computed
get double() {
return this.count * 2;
}
// @Computed装饰的属性是只读的，开发者自己实现的setter不生效，且产生运行时报错
set double(newValue : number) {
this.count = newValue / 2;
}
build() {
Scroll() {
Column({ space: 3 }) {
Text(`${this.count}`)
// 错误写法，@Computed装饰的属性方法是只读的，无法和双向绑定连用
Child({ double: this.double!! })
}
}
}
}
```
-  @Computed为状态管理V2提供的能力，只能在@ComponentV2和@ObservedV2中使用。
-  多个@Computed一起使用时，警惕循环求解。
```typescript
@Local a : number = 1;
@Computed
get b() {
return this.a + ' ' + this.c;  // 错误写法，存在循环b -> c -> b
}
@Computed
get c() {
return this.a + ' ' + this.b; // 错误写法，存在循环c -> b -> c
}
```
使用场景
当被计算的属性变化时，@Computed装饰的getter访问器只会被求解一次
```typescript
@Entry
@ComponentV2
struct Index {
@Local firstName: string = 'Li';
@Local lastName: string = 'Hua';
age: number = 20; // 无法触发Computed
@Computed
get fullName() {
console.info("---------Computed----------");
return this.firstName + ' ' + this.lastName + this.age;
}
build() {
Column() {
Text(this.lastName + ' ' + this.firstName)
Text(this.lastName + ' ' + this.firstName)
Divider()
Text(this.fullName)
Text(this.fullName)
Button('changed lastName').onClick(() => {
this.lastName += 'a';
})
Button('changed age').onClick(() => {
this.age++;  // 无法触发Computed
})
}
}
}
```
但是需要注意，计算属性本身是有性能开销的，实际应用开发中：
```typescript
@ObservedV2
class Name {
@Trace firstName: string = 'Li';
@Trace lastName: string = 'Hua';
@Computed
get fullName() {
console.info('---------Computed----------');
return this.firstName + ' ' + this.lastName;
}
}
const name: Name = new Name();
@Entry
@ComponentV2
struct Index {
name1: Name = name;
build() {
Column() {
Text(this.name1.fullName)
Text(this.name1.fullName)
Button('changed lastName').onClick(() => {
this.name1.lastName += 'a';
})
}
}
}
```
@Computed装饰的属性可以被@Monitor监听变化
下面的例子展示了使用计算属性求解fahrenheit和kelvin。
```typescript
@Entry
@ComponentV2
struct MyView {
@Local celsius: number = 20;
@Computed
get fahrenheit(): number {
return this.celsius * 9 / 5 + 32; // C -> F
}
@Computed
get kelvin(): number {
return (this.fahrenheit - 32) * 5 / 9 + 273.15; // F -> K
}
@Monitor("kelvin")
onKelvinMonitor(mon: IMonitor) {
console.log("kelvin changed from " + mon.value()?.before + " to " + mon.value()?.now);
}
build() {
Column({ space: 20 }) {
Row({ space: 20 }) {
Button('-')
.onClick(() => {
this.celsius--;
})
Text(`Celsius ${this.celsius.toFixed(1)}`).fontSize(50)
Button('+')
.onClick(() => {
this.celsius++;
})
}
Text(`Fahrenheit ${this.fahrenheit.toFixed(2)}`).fontSize(50)
Text(`Kelvin ${this.kelvin.toFixed(2)}`).fontSize(50)
}
.width('100%')
}
}
```
@Computed装饰的属性可以初始化@Param
下面的例子使用@Computed初始化@Param。
```typescript
@ObservedV2
class Article {
@Trace quantity: number = 0;
unitPrice: number = 0;
constructor(quantity: number, unitPrice: number) {
this.quantity = quantity;
this.unitPrice = unitPrice;
}
}
@Entry
@ComponentV2
struct Index {
@Local shoppingBasket: Article[] = [new Article(1, 20), new Article(5, 2)];
@Computed
get total(): number {
return this.shoppingBasket.reduce((acc: number, item: Article) => acc + (item.quantity * item.unitPrice), 0);
}
@Computed
get qualifiesForDiscount(): boolean {
return this.total >= 100;
}
build() {
Column() {
Text(`Shopping List: `).fontSize(30)
ForEach(this.shoppingBasket, (item: Article) => {
Row() {
Text(`unitPrice: ${item.unitPrice}`)
Button('-').onClick(() => {
if (item.quantity > 0) {
item.quantity--;
}
})
Text(`quantity: ${item.quantity}`)
Button('+').onClick(() => {
item.quantity++;
})
}
Divider()
})
Child({ total: this.total, qualifiesForDiscount: this.qualifiesForDiscount })
}.alignItems(HorizontalAlign.Start)
}
}
@ComponentV2
struct Child {
@Param total: number = 0;
@Param qualifiesForDiscount: boolean = false;
build() {
Row() {
Text(`Total: ${this.total} `).fontSize(30)
Text(`Discount: ${this.qualifiesForDiscount} `).fontSize(30)
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-type
爬取时间: 2025-04-28 06:58:28
来源: Huawei Developer
为了实现序列化类时不丢失属性的复杂类型，开发者可以使用@Type装饰器装饰类属性。
@Type的目的是标记类属性，配合PersistenceV2使用，防止序列化时类丢失。在阅读本文档前，建议提前阅读：PersistenceV2。
@Type从API version 12开始支持。
概述
@Type标记类属性，使得类属性序列化时不丢失类型信息，便于类的反序列化。
装饰器说明
| @Type装饰器 | 说明 |
| --- | --- |
| 装饰器参数 | type：类型。 |
| 可装饰的类型 | Object class以及Array、Date、Map、Set等内嵌类型。 |
使用限制
1、只能用在@ObservedV2装饰的类中，不能用在自定义组件中。
```typescript
class Sample {
data: number = 0;
}
@ObservedV2
class Info {
@Type(Sample)
@Trace sample: Sample = new Sample(); // 正确用法
}
@Observed
class Info2 {
@Type(Sample)
sample: Sample = new Sample(); // 错误用法，不能用在@Observed装饰的类中，编译时报错
}
@ComponentV2
struct Index {
@Type(Sample)
sample: Sample = new Sample(); // 错误用法，不能用在自定义组件中
build() {
}
}
```
2、不支持collections.Set、collections.Map等类型。
3、不支持非buildin类型，如PixelMap、NativePointer、ArrayList等Native类型。
4、不支持简单类型，如string、number、boolean等。
5、@Type不支持构造函数含参的类。
使用场景
持久化数据
数据页面
```typescript
import { Type } from '@kit.ArkUI';
// 数据中心
@ObservedV2
class SampleChild {
@Trace p1: number = 0;
p2: number = 10;
}
@ObservedV2
export class Sample {
// 对于复杂对象需要@Type修饰，确保序列化成功
@Type(SampleChild)
@Trace f: SampleChild = new SampleChild();
}
```
页面
```typescript
import { PersistenceV2 } from '@kit.ArkUI';
import { Sample } from '../Sample';
@Entry
@ComponentV2
struct Page {
prop: Sample = PersistenceV2.connect(Sample, () => new Sample())!;
build() {
Column() {
Text(`Page1 add 1 to prop.p1: ${this.prop.f.p1}`)
.fontSize(30)
.onClick(() => {
this.prop.f.p1++;
})
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-other-state-mgmt
爬取时间: 2025-04-28 06:58:42
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-appstoragev2
爬取时间: 2025-04-28 06:58:55
来源: Huawei Developer
为了增强状态管理框架对应用全局UI状态变量存储的能力，开发者可以使用AppStorageV2存储应用全局UI状态变量数据。
AppStorageV2是提供状态变量在应用级全局共享的能力，开发者可以通过connect绑定同一个key，进行跨ability的数据共享。
在阅读本文档前，建议提前阅读：@ComponentV2，@ObservedV2和@Trace，配合阅读：AppStorageV2-API文档。
AppStorageV2从API version 12开始支持。
概述
AppStorageV2是在应用UI启动时会被创建的单例。它的目的是为了提供应用状态数据的中心存储，这些状态数据在应用级别都是可访问的。AppStorageV2将在应用运行过程保留其数据。数据通过唯一的键字符串值访问。
AppStorageV2可以和UI组件同步，且可以在应用业务逻辑中被访问。
AppStorageV2支持应用的主线程内多个UIAbility实例间的状态共享。
使用说明
connect：创建或获取储存的数据
| connect | 说明 |
| --- | --- |
| 参数 |  type：指定的类型，若未指定key，则使用type的name作为key； keyOrDefaultCreator：指定的key，或者是默认数据的构造器； defaultCreator：默认数据的构造器。 |
| 返回值 | 创建或获取数据成功时，返回数据；否则返回undefined。 |
type：指定的类型，若未指定key，则使用type的name作为key；
keyOrDefaultCreator：指定的key，或者是默认数据的构造器；
defaultCreator：默认数据的构造器。
1、若未指定key，使用第二个参数作为默认构造器；否则使用第三个参数作为默认构造器（第二个参数非法也使用第三个参数作为默认构造器）。
2、确保数据已经存储在AppStorageV2中，可省略默认构造器，获取存储的数据；否则必须指定默认构造器，不指定将导致应用异常。
3、同一个key，connect不同类型的数据会导致应用异常，应用需要确保类型匹配。
4、key建议使用有意义的值，可由字母、数字、下划线组成，长度不超过255，使用非法字符或空字符的行为是未定义的。
5、关联@Observed对象时，由于该类型的name属性未定义，需要指定key或者自定义name属性。
remove：删除指定key的储存数据
| remove | 说明 |
| --- | --- |
| 参数 | keyOrType：需要删除的key；如果指定的是type类型，删除的key为type的name。 |
| 返回值 | 无。 |
删除AppStorageV2中不存在的key会报警告。
keys：返回所有AppStorageV2中的key
| keys | 说明 |
| --- | --- |
| 参数 | 无。 |
| 返回值 | 所有AppStorageV2中的key。 |
使用限制
1、需要配合UI使用（UI线程），不能在其他线程使用，如不支持@Sendable。
2、不支持collections.Set、collections.Map等类型。
3、不支持非buildin类型，如PixelMap、NativePointer、ArrayList等Native类型。
使用场景
在两个页面之间存储数据
数据页面
```typescript
// 数据中心
// Sample.ets
@ObservedV2
export class Sample {
@Trace p1: number = 0;
p2: number = 10;
}
```
页面1
```typescript
// Page1.ets
import { AppStorageV2 } from '@kit.ArkUI';
import { Sample } from '../Sample';
@Entry
@ComponentV2
struct Page1 {
// 在AppStorageV2中创建一个key为Sample的键值对（如果存在，则返回AppStorageV2中的数据），并且和prop关联
@Local prop: Sample = AppStorageV2.connect(Sample, () => new Sample())!;
pageStack: NavPathStack = new NavPathStack();
build() {
Navigation(this.pageStack) {
Column() {
Button('Go to page2')
.onClick(() => {
this.pageStack.pushPathByName('Page2', null);
})
Button('Page1 connect the key Sample')
.onClick(() => {
// 在AppStorageV2中创建一个key为Sample的键值对（如果存在，则返回AppStorageV2中的数据），并且和prop关联
this.prop = AppStorageV2.connect(Sample, 'Sample', () => new Sample())!;
})
Button('Page1 remove the key Sample')
.onClick(() => {
// 从AppStorageV2中删除后，prop将不会再与key为Sample的值关联
AppStorageV2.remove(Sample);
})
Text(`Page1 add 1 to prop.p1: ${this.prop.p1}`)
.fontSize(30)
.onClick(() => {
this.prop.p1++;
})
Text(`Page1 add 1 to prop.p2: ${this.prop.p2}`)
.fontSize(30)
.onClick(() => {
// 页面不刷新，但是p2的值改变了
this.prop.p2++;
})
// 获取当前AppStorageV2里面的所有key
Text(`all keys in AppStorage: ${AppStorageV2.keys()}`)
.fontSize(30)
}
}
}
}
```
页面2
```typescript
// Page2.ets
import { AppStorageV2 } from '@kit.ArkUI';
import { Sample } from '../Sample';
@Builder
export function Page2Builder() {
Page2()
}
@ComponentV2
struct Page2 {
// 在AppStorageV2中创建一个key为Sample的键值对（如果存在，则返回AppStorageV2中的数据），并且和prop关联
@Local prop: Sample = AppStorageV2.connect(Sample, () => new Sample())!;
pathStack: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Button('Page2 connect the key Sample1')
.onClick(() => {
// 在AppStorageV2中创建一个key为Sample1的键值对（如果存在，则返回AppStorageV2中的数据），并且和prop关联
this.prop = AppStorageV2.connect(Sample, 'Sample1', () => new Sample())!;
})
Text(`Page2 add 1 to prop.p1: ${this.prop.p1}`)
.fontSize(30)
.onClick(() => {
this.prop.p1++;
})
Text(`Page2 add 1 to prop.p2: ${this.prop.p2}`)
.fontSize(30)
.onClick(() => {
// 页面不刷新，但是p2的值改变了；只有重新初始化才会改变
this.prop.p2++;
})
// 获取当前AppStorageV2里面的所有key
Text(`all keys in AppStorage: ${AppStorageV2.keys()}`)
.fontSize(30)
}
}
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack;
})
}
}
```
使用Navigation时，需要添加配置系统路由表文件src/main/resources/base/profile/route_map.json，并替换pageSourceFile为Page2页面的路径，并且在module.json5中添加："routerMap": "$profile:route_map"。
```json
{
"routerMap": [
{
"name": "Page2",
"pageSourceFile": "src/main/ets/pages/Page2.ets",
"buildFunction": "Page2Builder",
"data": {
"description" : "AppStorageV2 example"
}
}
]
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-persistencev2
爬取时间: 2025-04-28 06:59:09
来源: Huawei Developer
为了增强状态管理框架对持久化存储UI的能力，开发者可以使用PersistenceV2存储持久化的数据。
PersistenceV2是应用程序中的可选单例对象。此对象的作用是持久化存储UI相关的数据，以确保这些属性在应用程序重新启动时的值与应用程序关闭时的值相同。
PersistenceV2提供状态变量持久化能力，开发者可以通过connect绑定同一个key，在状态变量变换和应用冷启动时，实现持久化能力。
在阅读本文档前，建议提前阅读：@ComponentV2，@ObservedV2和@Trace，配合阅读：PersistentV2-API文档。
PersistenceV2从API version 12开始支持。
概述
PersistenceV2是在应用UI启动时会被创建的单例。它的目的是为了提供应用状态数据的中心存储，这些状态数据在应用级别都是可访问的。数据通过唯一的键字符串值访问。不同于AppStorageV2，PersistenceV2还将最新数据储存在设备磁盘上（持久化）。这意味着，应用退出再次启动后，依然能保存选定的结果。
对于与PersistenceV2关联的@ObservedV2对象，该对象的@Trace属性的变化，会触发整个关联对象的自动持久化；非@Trace属性的变化则不会，如有必要，可调用PersistenceV2 API手动持久化。
PersistenceV2可以和UI组件同步，且可以在应用业务逻辑中被访问。
PersistenceV2支持应用的主线程内多个UIAbility实例间的状态共享。
使用说明
connect：创建或获取储存的数据
| connect | 说明 |
| --- | --- |
| 参数 |  type：指定的类型，若未指定key，则使用type的name作为key； keyOrDefaultCreator：指定的key，或者是默认数据的构造器； defaultCreator：默认数据的构造器。 |
| 返回值 | 创建或获取数据成功时，返回数据；否则返回undefined。 |
type：指定的类型，若未指定key，则使用type的name作为key；
keyOrDefaultCreator：指定的key，或者是默认数据的构造器；
defaultCreator：默认数据的构造器。
1、若未指定key，使用第二个参数作为默认构造器；否则使用第三个参数作为默认构造器（第二个参数非法也使用第三个参数作为默认构造器）。
2、确保数据已经存储在PersistenceV2中，可省略默认构造器，获取存储的数据；否则必须指定默认构造器，不指定将导致应用异常。
3、同一个key，connect不同类型的数据会导致应用异常，应用需要确保类型匹配。
4、key建议使用有意义的值，可由字母、数字、下划线组成，长度不超过255，使用非法字符或空字符的行为是未定义的。
5、关联@Observed对象时，由于该类型的name属性未定义，需要指定key或者自定义name属性。
remove：删除指定key的储存数据
| remove | 说明 |
| --- | --- |
| 参数 | keyOrType：需要删除的key；如果指定的是type类型，删除的key为type的name。 |
| 返回值 | 无。 |
删除PersistenceV2中不存在的key会报警告。
keys：返回所有PersistenceV2中的key
| keys | 说明 |
| --- | --- |
| 参数 | 无。 |
| 返回值 | 所有PersistenceV2中的key。 |
save：手动持久化数据
| save | 说明 |
| --- | --- |
| 参数 | keyOrType：需要手动持久化的key；如果指定的是type类型，key为type的name。 |
| 返回值 | 无。 |
由于非@Trace的数据改变不会触发PersistenceV2的自动持久化，如有必要，可调用该接口持久化对应key的数据。
手动持久化当前内存中不处于connect状态的key是无意义的。
notifyOnError：响应序列化或反序列化失败的回调
| notifyOnError | 说明 |
| --- | --- |
| 参数 | callback：当序列化或者反序列化失败时，执行该回调；若传入undefined，取消该回调。 |
| 返回值 | 无。 |
将数据存入磁盘时，需要对数据进行序列化；当某个key序列化失败时，错误是不可预知的；可调用该接口捕获异常。
使用限制
1、需要配合UI使用（UI线程），不能在其他线程使用，如不支持@Sendable。
2、不支持collections.Set、collections.Map等类型。
3、不支持非buildin类型，如PixelMap、NativePointer、ArrayList等Native类型。
4、单个key支持数据大小约8k，过大会导致持久化失败。
5、持久化的数据必须是class对象，不能是容器（如Array、Set、Map），不能是buildin的构造对象（如Date、Number）。
6、不支持循环引用的对象。
7、只有@Trace的数据改变会触发自动持久化，如V1状态变量、@Observed对象、普通数据的改变不会触发持久化。
8、不宜大量持久化数据，可能会导致页面卡顿。
使用场景
在两个页面之间存储数据
数据页面
```typescript
// Sample.ets
import { Type } from '@kit.ArkUI';
// 数据中心
@ObservedV2
class SampleChild {
@Trace p1: number = 0;
p2: number = 10;
}
@ObservedV2
export class Sample {
// 对于复杂对象需要@Type修饰，确保序列化成功
@Type(SampleChild)
@Trace f: SampleChild = new SampleChild();
}
```
页面1
```typescript
// Page1.ets
import { PersistenceV2 } from '@kit.ArkUI';
import { Sample } from '../Sample';
// 接受序列化失败的回调
PersistenceV2.notifyOnError((key: string, reason: string, msg: string) => {
console.error(`error key: ${key}, reason: ${reason}, message: ${msg}`);
});
@Entry
@ComponentV2
struct Page1 {
// 在PersistenceV2中创建一个key为Sample的键值对（如果存在，则返回PersistenceV2中的数据），并且和prop关联
// 对于需要换connect对象的prop属性，需要加@Local修饰（不建议对属性换connect的对象）
@Local prop: Sample = PersistenceV2.connect(Sample, () => new Sample())!;
pageStack: NavPathStack = new NavPathStack();
build() {
Navigation(this.pageStack) {
Column() {
Button('Go to page2')
.onClick(() => {
this.pageStack.pushPathByName('Page2', null);
})
Button('Page1 connect the key Sample')
.onClick(() => {
// 在PersistenceV2中创建一个key为Sample的键值对（如果存在，则返回PersistenceV2中的数据），并且和prop关联
// 不建议对prop属性换connect的对象
this.prop = PersistenceV2.connect(Sample, 'Sample', () => new Sample())!;
})
Button('Page1 remove the key Sample')
.onClick(() => {
// 从PersistenceV2中删除后，prop将不会再与key为Sample的值关联
PersistenceV2.remove(Sample);
})
Button('Page1 save the key Sample')
.onClick(() => {
// 如果处于connect状态，持久化key为Sample的键值对
PersistenceV2.save(Sample);
})
Text(`Page1 add 1 to prop.p1: ${this.prop.f.p1}`)
.fontSize(30)
.onClick(() => {
this.prop.f.p1++;
})
Text(`Page1 add 1 to prop.p2: ${this.prop.f.p2}`)
.fontSize(30)
.onClick(() => {
// 页面不刷新，但是p2的值改变了
this.prop.f.p2++;
})
// 获取当前PersistenceV2里面的所有key
Text(`all keys in PersistenceV2: ${PersistenceV2.keys()}`)
.fontSize(30)
}
}
}
}
```
页面2
```typescript
// Page2.ets
import { PersistenceV2 } from '@kit.ArkUI';
import { Sample } from '../Sample';
@Builder
export function Page2Builder() {
Page2()
}
@ComponentV2
struct Page2 {
// 在PersistenceV2中创建一个key为Sample的键值对（如果存在，则返回PersistenceV2中的数据），并且和prop关联
// 对于需要换connect对象的prop属性，需要加@Local修饰（不建议对属性换connect的对象）
@Local prop: Sample = PersistenceV2.connect(Sample, () => new Sample())!;
pathStack: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Button('Page2 connect the key Sample1')
.onClick(() => {
// 在PersistenceV2中创建一个key为Sample1的键值对（如果存在，则返回PersistenceV2中的数据），并且和prop关联
// 不建议对prop属性换connect的对象
this.prop = PersistenceV2.connect(Sample, 'Sample1', () => new Sample())!;
})
Text(`Page2 add 1 to prop.p1: ${this.prop.f.p1}`)
.fontSize(30)
.onClick(() => {
this.prop.f.p1++;
})
Text(`Page2 add 1 to prop.p2: ${this.prop.f.p2}`)
.fontSize(30)
.onClick(() => {
// 页面不刷新，但是p2的值改变了；只有重新初始化才会改变
this.prop.f.p2++;
})
// 获取当前PersistenceV2里面的所有key
Text(`all keys in PersistenceV2: ${PersistenceV2.keys()}`)
.fontSize(30)
}
}
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack;
})
}
}
```
使用Navigation时，需要添加配置系统路由表文件src/main/resources/base/profile/route_map.json，并替换pageSourceFile为Page2页面的路径，并且在module.json5中添加："routerMap": "$profile:route_map"。
```json
{
"routerMap": [
{
"name": "Page2",
"pageSourceFile": "src/main/ets/pages/Page2.ets",
"buildFunction": "Page2Builder",
"data": {
"description" : "PersistenceV2 example"
}
}
]
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-binding
爬取时间: 2025-04-28 06:59:22
来源: Huawei Developer
在状态管理V1中使用$$用于系统组件双向绑定。
在状态管理V2中，提供了归一处理，提供!!语法糖作为统一处理双向绑定语法。
!!语法从API version 12开始支持。
概述
!!双向绑定语法，是一个语法糖方便开发者实现数据双向绑定，用于初始化子组件的@Param和@Event。其中@Event方法名需要声明为“$”+ @Param属性名，详见使用场景。
使用限制
!!双向绑定语法不支持多层父子组件传递。
使用场景
自定义组件间双向绑定
-  双向绑定语法糖可视为：
```typescript
@Entry
@ComponentV2
struct Index {
@Local value: number = 0;
build() {
Column() {
Text(`${this.value}`)
Button(`change value`).onClick(() => {
this.value++;
})
Star({ value: this.value!! })
}
}
}
@ComponentV2
struct Star {
@Param value: number = 0;
@Event $value: (val: number) => void = (val: number) => {};
build() {
Column() {
Text(`${this.value}`)
Button(`change value `).onClick(() => {
this.$value(10);
})
}
}
}
```
系统组件参数双向绑定
!!运算符为系统组件提供TS变量的引用，使得TS变量和系统组件的内部状态保持同步。添加方式是在变量名后添加，例如isShow!!。
内部状态具体指什么取决于组件。例如，bindMenu组件的isShow参数。
使用规则
-  当前!!支持以下接口参数基础类型变量的双向绑定，也就是参数同步当前弹出菜单或气泡状态。!!双向绑定支持基础类型变量，当该变量使用状态管理V2@Local或状态管理V1@State装饰时，变量值的变化会触发UI刷新。
-  !!绑定的@Local变量变化时，会触发UI的同步刷新。
| 属性 | 支持的参数 | 起始API版本 |
| --- | --- | --- |
| bindMenu | isShow | 13 |
| bindContextMenu | isShown | 13 |
| bindPopup | show | 13 |
使用示例
bindMenu接口isShow参数双向绑定功能。
```typescript
@Entry
@ComponentV2
struct BindMenuInterface {
@Local isShow: boolean = false;
build() {
Column() {
Row() {
Text('click show Menu')
.bindMenu(this.isShow!!, // 双向绑定
[
{
value: 'Menu1',
action: () => {
console.info('handle Menu1 click');
}
},
{
value: 'Menu2',
action: () => {
console.info('handle Menu2 click');
}
},
])
}.height('50%')
Text("当前isShow: " + this.isShow).fontSize(18).fontColor(Color.Red)
Row() {
Button("Click")
.onClick(() => {
this.isShow = true;
})
.width(100)
.fontSize(20)
.margin(10)
}
}.width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163832.92489280649026115120206299152845:50001231000000:2800:7AFF4846E6CA4910150B81566E9AD192B1837FF5D6BEFC7202FC74A13010AFA5.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-custom-components-freezev2
爬取时间: 2025-04-28 06:59:36
来源: Huawei Developer
当@ComponentV2装饰的自定义组件处于非激活状态时，状态变量将不响应更新，即@Monitor不会调用，状态变量关联的节点不会刷新。通过freezeWhenInactive属性来决定是否使用冻结功能，不传参数时默认不使用。支持的场景有：页面路由，TabContent，Navigation。
在阅读本文档前，开发者需要了解@ComponentV2基本语法。建议提前阅读：@ComponentV2。
从API version 12开始，支持@ComponentV2装饰的自定义组件冻结功能。
和@Component的组件冻结不同， @ComponentV2装饰的自定义组件不支持LazyForEach场景下的缓存节点组件冻结。
当前支持的场景
页面路由
本示例使用了router进行页面跳转，建议开发者使用组件导航(Navigation)代替页面路由(router)来实现页面切换。Navigation提供了更多的功能和更灵活的自定义能力。请参考使用Navigation的组件冻结用例。
-  当页面1调用router.pushUrl接口跳转到页面2时，页面1为隐藏不可见状态，此时如果更新页面1中的状态变量，不会触发页面1刷新。 图示如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163832.60896423540133269383292275798966:50001231000000:2800:D3871D339FD65F3216D4E5890B7C524983D5DBA862DA64702939EEE70E75890A.png)
页面1：
```typescript
import { router } from '@kit.ArkUI';
@ObservedV2
export class Book {
@Trace name: string = "100";
constructor(page: string) {
this.name = page;
}
}
@Entry
@ComponentV2({ freezeWhenInactive: true })
export struct Page1 {
@Local bookTest: Book = new Book("A Midsummer Night’s Dream");
@Monitor("bookTest.name")
onMessageChange(monitor: IMonitor) {
console.log(`The book name change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
build() {
Column() {
Text(`Book name is  ${this.bookTest.name}`).fontSize(25)
Button('changeBookName').fontSize(25)
.onClick(() => {
this.bookTest.name = "The Old Man and the Sea";
})
Button('go to next page').fontSize(25)
.onClick(() => {
router.pushUrl({ url: 'pages/Page2' });
setTimeout(() => {
this.bookTest = new Book("Jane Austen oPride and Prejudice");
}, 1000)
})
}
}
}
```
页面2：
```typescript
import { router } from '@kit.ArkUI';
@Entry
@ComponentV2
struct Page2 {
build() {
Column() {
Text(`This is the page2`).fontSize(25)
Button('Back')
.onClick(() => {
router.back();
})
}
}
}
```
在上面的示例中：
1.点击页面1中的Button “changeBookName”，bookTest变量的name属性改变，@Monitor中注册的方法onMessageChange会被调用。
2.点击页面1中的Button “go to next page”，跳转到页面2，然后延迟1s更新状态变量“bookTest”。在更新“bookTest”的时候，已经跳转到页面2，页面1处于inactive状态，状态变量@Local bookTest将不响应更新，其@Monitor不会调用，状态变量关联的节点不会刷新。
trace如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163832.05859609648157040810738918444065:50001231000000:2800:3ACA4F7187AD276314C915CCAF318854CF391882A222FCDB4EFD652405E2D4C7.png)
3.点击“back”，页面2被销毁，页面1的状态由inactive变为active。状态变量“bookTest”的更新被观察到，@Monitor中注册的方法onMessageChange被调用，对应的Text显示内容改变。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163832.98903269878036251214365878932500:50001231000000:2800:B69F903B5EB0093EE7FDFC4A032049BBB4567E838D607D165B3EA52E43B57A3F.gif)
TabContent
-  对Tabs中当前不可见的TabContent进行冻结，不会触发组件的更新。
-  需要注意的是：在首次渲染的时候，Tab只会创建当前正在显示的TabContent，当切换全部的TabContent后，TabContent才会被全部创建。
图示如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163832.67396913859048640012579175792545:50001231000000:2800:F8577F894B0E43B4C2107E280204E7660E7A79493433743978EC4310CDA6B2F2.png)
```typescript
@Entry
@ComponentV2
struct TabContentTest {
@Local message: number = 0;
@Local data: number[] = [0, 1];
build() {
Row() {
Column() {
Button('change message').onClick(() => {
this.message++;
})
Tabs() {
ForEach(this.data, (item: number) => {
TabContent() {
FreezeChild({ message: this.message, index: item })
}.tabBar(`tab${item}`)
}, (item: number) => item.toString())
}
}
.width('100%')
}
.height('100%')
}
}
@ComponentV2({ freezeWhenInactive: true })
struct FreezeChild {
@Param message: number = 0;
@Param index: number = 0;
@Monitor('message') onMessageUpdated(mon: IMonitor) {
console.info(`FreezeChild message callback func ${this.message}, index: ${this.index}`);
}
build() {
Text("message" + `${this.message}, index: ${this.index}`)
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
}
```
在上面的示例中：
1.点击“change message”更改message的值，当前正在显示的TabContent组件中的@Monitor中注册的方法onMessageUpdated被触发。
2.点击TabBar“tab1”切换到另外的TabContent，TabContent状态由inactive变为active，对应的@Monitor中注册的方法onMessageUpdated被触发。
3.再次点击“change message”更改message的值，仅当前显示的TabContent子组件中的@Monitor中注册的方法onMessageUpdated被触发。其他inactive的TabContent组件不会触发@Monitor。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163832.54359433098072304879116080987533:50001231000000:2800:5FE23A1AE1B0BB2903DE653F8EC5053B944CD1B65866B01E85C88160B5E489EB.gif)
Navigation
```typescript
@Entry
@ComponentV2
struct MyNavigationTestStack {
@Provider('pageInfo') pageInfo: NavPathStack = new NavPathStack();
@Local message: number = 0;
@Monitor('message') info() {
console.info(`freeze-test MyNavigation message callback ${this.message}`);
}
@Builder
PageMap(name: string) {
if (name === 'pageOne') {
pageOneStack({ message: this.message })
} else if (name === 'pageTwo') {
pageTwoStack({ message: this.message })
} else if (name === 'pageThree') {
pageThreeStack({ message: this.message })
}
}
build() {
Column() {
Button('change message')
.onClick(() => {
this.message++;
})
Navigation(this.pageInfo) {
Column() {
Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })
.onClick(() => {
this.pageInfo.pushPath({ name: 'pageOne' }); //将name指定的NavDestination页面信息入栈
})
}
}.title('NavIndex')
.navDestination(this.PageMap)
.mode(NavigationMode.Stack)
}
}
}
@ComponentV2
struct pageOneStack {
@Consumer('pageInfo') pageInfo: NavPathStack = new NavPathStack();
@Local index: number = 1;
@Param message: number = 0;
build() {
NavDestination() {
Column() {
NavigationContentMsgStack({ message: this.message, index: this.index })
Text("cur stack size:" + `${this.pageInfo.size()}`)
.fontSize(30)
Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })
.onClick(() => {
this.pageInfo.pushPathByName('pageTwo', null);
})
Button('Back Page', { stateEffect: true, type: ButtonType.Capsule })
.onClick(() => {
this.pageInfo.pop();
})
}.width('100%').height('100%')
}.title('pageOne')
.onBackPressed(() => {
this.pageInfo.pop();
return true;
})
}
}
@ComponentV2
struct pageTwoStack {
@Consumer('pageInfo') pageInfo: NavPathStack = new NavPathStack();
@Local index: number = 2;
@Param message: number = 0;
build() {
NavDestination() {
Column() {
NavigationContentMsgStack({ message: this.message, index: this.index })
Text("cur stack size:" + `${this.pageInfo.size()}`)
.fontSize(30)
Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })
.onClick(() => {
this.pageInfo.pushPathByName('pageThree', null);
})
Button('Back Page', { stateEffect: true, type: ButtonType.Capsule })
.onClick(() => {
this.pageInfo.pop();
})
}
}.title('pageTwo')
.onBackPressed(() => {
this.pageInfo.pop();
return true;
})
}
}
@ComponentV2
struct pageThreeStack {
@Consumer('pageInfo') pageInfo: NavPathStack = new NavPathStack();
@Local index: number = 3;
@Param message: number = 0;
build() {
NavDestination() {
Column() {
NavigationContentMsgStack({ message: this.message, index: this.index })
Text("cur stack size:" + `${this.pageInfo.size()}`)
.fontSize(30)
Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })
.height(40)
.onClick(() => {
this.pageInfo.pushPathByName('pageOne', null);
})
Button('Back Page', { stateEffect: true, type: ButtonType.Capsule })
.height(40)
.onClick(() => {
this.pageInfo.pop();
})
}
}.title('pageThree')
.onBackPressed(() => {
this.pageInfo.pop();
return true;
})
}
}
@ComponentV2({ freezeWhenInactive: true })
struct NavigationContentMsgStack {
@Param message: number = 0;
@Param index: number = 0;
@Monitor('message') info() {
console.info(`freeze-test NavigationContent message callback ${this.message}`);
console.info(`freeze-test ---- called by content ${this.index}`);
}
build() {
Column() {
Text("msg:" + `${this.message}`)
.fontSize(30)
}
}
}
```
在上面的示例中：
1.点击“change message”更改message的值，当前正在显示的MyNavigationTestStack组件中的@Monitor中注册的方法info被触发。
2.点击“Next Page”切换到PageOne，创建pageOneStack节点。
3.再次点击“change message”更改message的值，仅pageOneStack中的NavigationContentMsgStack子组件中的@Monitor中注册的方法info被触发。
4.再次点击“Next Page”切换到PageTwo，创建pageTwoStack节点。pageOneStack节点状态由active变为inactive。
5.再次点击“change message”更改message的值，仅pageTwoStack中的NavigationContentMsgStack子组件中的@Monitor中注册的方法info被触发。Navigation路由栈中非栈顶的NavDestination中的子自定义组件，将是inactive状态。@Monitor方法不会触发。
6.再次点击“Next Page”切换到PageThree，创建pageThreeStack节点。pageTwoStack节点状态由active变为inactive。
7.再次点击“change message”更改message的值，仅pageThreeStack中的NavigationContentMsgStack子组件中的@Monitor中注册的方法info被触发。Navigation路由栈中非栈顶的NavDestination中的子自定义组件，将是inactive状态。@Monitor方法不会触发。
8.点击“Back Page”回到PageTwo，此时，pageTwoStack节点状态由inactive变为active，其NavigationContentMsgStack子组件中的@Monitor中注册的方法info被触发。
9.再次点击“Back Page”回到PageOne，此时，pageOneStack节点状态由inactive变为active，其NavigationContentMsgStack子组件中的@Monitor中注册的方法info被触发。
10.再次点击“Back Page”回到初始页。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163832.50202165687745829905298894550753:50001231000000:2800:68CC570A63AAC45E4FE85493B04E8FB3A2C81EBFCC17DDA18A9E371344B644E8.gif)
限制条件
如下面的例子所示，FreezeBuildNode中使用了自定义节点BuilderNode。BuilderNode可以通过命令式动态挂载组件，而组件冻结又是强依赖父子关系来通知是否开启组件冻结。如果父组件使用组件冻结，且组件树的中间层级上又启用了BuilderNode，则BuilderNode的子组件将无法被冻结。
```typescript
import { BuilderNode, FrameNode, NodeController, UIContext } from '@kit.ArkUI';
// 定义一个Params类，用于传递参数
@ObservedV2
class Params {
// 单例模式，确保只有一个Params实例
static singleton_: Params;
// 获取Params实例的方法
static instance() {
if (!Params.singleton_) {
Params.singleton_ = new Params(0);
}
return Params.singleton_;
}
// 使用@Trace装饰器装饰message属性，以便跟踪其变化
@Trace message: string = "Hello";
index: number = 0;
constructor(index: number) {
this.index = index;
}
}
// 定义一个buildNodeChild组件，它包含一个message属性和一个index属性
@ComponentV2
struct buildNodeChild {
// 使用Params实例作为storage属性
storage: Params = Params.instance();
@Param index: number = 0;
// 使用@Monitor装饰器监听storage.message的变化
@Monitor("storage.message")
onMessageChange(monitor: IMonitor) {
console.log(`FreezeBuildNode buildNodeChild message callback func ${this.storage.message}, index:${this.index}`);
}
build() {
Text(`buildNode Child message: ${this.storage.message}`).fontSize(30)
}
}
// 定义一个buildText函数，它接收一个Params参数并构建一个Column组件
@Builder
function buildText(params: Params) {
Column() {
buildNodeChild({ index: params.index })
}
}
class TextNodeController extends NodeController {
private textNode: BuilderNode<[Params]> | null = null;
private index: number = 0;
// 构造函数接收一个index参数
constructor(index: number) {
super();
this.index = index;
}
// 创建并返回一个FrameNode
makeNode(context: UIContext): FrameNode | null {
this.textNode = new BuilderNode(context);
this.textNode.build(wrapBuilder<[Params]>(buildText), new Params(this.index));
return this.textNode.getFrameNode();
}
}
// 定义一个Index组件，它包含一个message属性和一个data数组
@Entry
@ComponentV2
struct Index {
// 使用Params实例作为storage属性
storage: Params = Params.instance();
private data: number[] = [0, 1];
build() {
Row() {
Column() {
Button("change").fontSize(30)
.onClick(() => {
this.storage.message += 'a';
})
Tabs() {
// 使用Repeat重复渲染TabContent组件
Repeat<number>(this.data)
.each((obj: RepeatItem<number>) => {
TabContent() {
FreezeBuildNode({ index: obj.item })
.margin({ top: 20 })
}.tabBar(`tab${obj.item}`)
})
.key((item: number) => item.toString())
}
}
}
.width('100%')
.height('100%')
}
}
// 定义一个FreezeBuildNode组件，它包含一个message属性和一个index属性
@ComponentV2({ freezeWhenInactive: true })
struct FreezeBuildNode {
// 使用Params实例作为storage属性
storage: Params = Params.instance();
@Param index: number = 0;
// 使用@Monitor装饰器监听storage.message的变化
@Monitor("storage.message")
onMessageChange(monitor: IMonitor) {
console.log(`FreezeBuildNode message callback func ${this.storage.message}, index: ${this.index}`);
}
build() {
NodeContainer(new TextNodeController(this.index))
.width('100%')
.height('100%')
.backgroundColor('#FFF0F0F0')
}
}
```
点击Button("change")。改变message的值，当前正在显示的TabContent组件中的@Watch中注册的方法onMessageUpdated被触发。未显示的TabContent中的BuilderNode节点下组件的@Watch方法onMessageUpdated也被触发，并没有被冻结。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163832.07158356181395999193154388232222:50001231000000:2800:BA75E8D333D57FA8F494C2AF6B5A8E95F2728EE0FBB018F37BD709E906CD12D4.gif)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-rendering-control-repeat
爬取时间: 2025-04-28 06:59:50
来源: Huawei Developer
Repeat从API version 12开始支持。
本文档仅为开发者指南。API参数说明见：Repeat API参数说明。
概述
Repeat基于数组类型数据来进行循环渲染，一般与容器组件配合使用。Repeat组件包含两种模式：non-virtualScroll模式和virtualScroll模式。
-  virtualScroll模式（开启virtualScroll开关）：Repeat根据容器组件的有效加载范围（可视区域+预加载区域）加载子组件。当容器滑动/数组改变时，Repeat会根据父容器组件传递的参数重新计算有效加载范围，实时管理列表节点的创建与销毁。 该模式适合需要懒加载的长数据列表/通过组件复用优化性能表现的场景。详细描述见virtualScroll模式。
Repeat与ForEach、LazyForEach的区别：
下面的示例代码使用Repeat组件的virtualScroll模式进行循环渲染。
```typescript
// 在List容器组件中使用Repeat virtualScroll模式
@Entry
@ComponentV2 // 推荐使用V2装饰器
struct RepeatExample {
@Local dataArr: Array<string> = []; // 数据源
aboutToAppear(): void {
for (let i = 0; i < 50; i++) {
this.dataArr.push(`data_${i}`); // 为数组添加一些数据
}
}
build() {
Column() {
List() {
Repeat<string>(this.dataArr)
.each((ri: RepeatItem<string>) => { // 默认模板
ListItem() {
Text('each_A_' + ri.item).fontSize(30).fontColor(Color.Red) // 文本颜色为红色
}
})
.key((item: string, index: number): string => item) // 键值生成函数
.virtualScroll({ totalCount: this.dataArr.length }) // 打开virtualScroll模式，totalCount为期望加载的数据长度
.templateId((item: string, index: number): string => { // 根据返回值寻找对应的模板子组件进行渲染
return index <= 4 ? 'A' : (index <= 10 ? 'B' : ''); // 前5个节点模板为A，接下来的5个为B，其余为默认模板
})
.template('A', (ri: RepeatItem<string>) => { // 'A'模板
ListItem() {
Text('ttype_A_' + ri.item).fontSize(30).fontColor(Color.Green) // 文本颜色为绿色
}
}, { cachedCount: 3 }) // 'A'模板的缓存列表容量为3
.template('B', (ri: RepeatItem<string>) => { // 'B'模板
ListItem() {
Text('ttype_B_' + ri.item).fontSize(30).fontColor(Color.Blue) // 文本颜色为蓝色
}
}, { cachedCount: 4 }) // 'B'模板的缓存列表容量为4
}
.cachedCount(2) // 容器组件的预加载区域大小
.height('70%')
.border({ width: 1 }) // 边框
}
}
}
```
运行后界面如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163833.52878697546195282287045058376502:50001231000000:2800:31E5A8390CA564E5F88B6F070722E777D8A24E99A1C1243892D34E5A47BFC2C7.png)
使用限制
Repeat virtualScroll模式使用限制：
Repeat通过键值识别数组如何改变：增加了哪些数据、删除了哪些数据，以及哪些数据改变了位置（索引）。键值生成函数.key()的使用建议如下：
Repeat子组件节点的操作分为四种：节点创建、节点更新、节点复用、节点销毁。其中，节点更新和节点复用的区别为：
non-virtualScroll模式
键值生成规则
.key()方法为每一项数据生成一个键值。请注意键值（key）与索引（index）的区别：键值是数据项的唯一标识符，Repeat根据键值是否发生变化判断数据项是否更新；索引则只标识数据项在数据源中的位置。
.key()的逻辑如下图所示。
当.key()缺省时，Repeat会生成新的随机键值。当发现有重复key时，Repeat会在已有键值的基础上递归生成新的键值，直到没有重复键值。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163833.19372899785040142351489784472111:50001231000000:2800:4C555329DD9301B2132E753F605E0FFAB33C9474C084D91CFE03D7CA9F7830B8.png)
子组件渲染逻辑
在Repeat首次渲染时，子组件全部创建。数组发生改变后，Repeat的处理分为以下几个步骤：
首先，遍历旧数组键值，如果新数组中没有该键值，将其加入键值集合deletedKeys。
其次，遍历新数组键值，依次判断以下条件，符合条件时进行对应的操作：
最后，如果新数组键值遍历结束后，deletedKeys非空，则销毁集合中的键值所对应的节点。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163833.57073951533396413310095304025192:50001231000000:2800:668339BBE0839952642E8718CAF512BA80F5DCADB53F42E96EBAE8FDE10E227D.png)
以下图中的数组变化为例。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163833.48536484340030854372052617218767:50001231000000:2800:0A3B8A7341DAF1C2EB0A00A2C973978A714826AA4F6D7B380ABAA1F9D4B13CE8.png)
根据上述判断逻辑，item_0没有变化，item_1和item_2只更新了索引，item_n1和item_n2分别由item_4和item_3进行节点更新获得，item_n3为新创建的节点。
virtualScroll模式
键值生成规则
和non-virtualScroll模式的逻辑基本一致，如下图所示。
.key()方法为每一项数据生成一个键值。请注意键值（key）与索引（index）的区别：键值是数据项的唯一标识符，Repeat根据键值是否发生变化判断数据项是否更新；索引则只标识数据项在数据源中的位置。
当.key()缺省时，Repeat会生成新的随机键值。当存在重复key时，Repeat会重新生成随机key作为当前数据项的键值并且放进该列表。列表中已有的键值不受影响。随机key的构成：___${index}_+_${key}_+_${Math.random()}，其中的变量依次为：索引、旧键值、随机数。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163833.35612282419684850530746752830795:50001231000000:2800:3FF60A8CAE0E6040AA9C4C6294133B38093E33EDBA2C219786F45E60A4D1ACFE.png)
子组件渲染逻辑
在Repeat首次渲染时，根据容器组件的有效加载范围（可视区域+预加载区域）创建当前需要的子组件。
在容器滑动/数组改变时，将失效的子组件节点（离开有效加载范围）加入空闲节点缓存列表中（断开与组件树的关系，但不销毁），在需要生成新的组件时，对缓存里的组件进行复用（更新被复用子组件的变量值，重新上树）。
通过典型的滑动场景和数据更新场景示例来展示virtualScroll模式下子组件的渲染逻辑。定义长度为20的数组，数组前5项的template type为aa，其余项为bb。aa缓存池容量为3，bb缓存池容量为4。容器组件的预加载区域大小为2。为了便于理解，在aa和bb缓存池中分别加入一个和两个空闲节点。
首次渲染，列表的节点状态如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163833.68474111638099110125967082890489:50001231000000:2800:8C04DB6287DDE0F656FFC8C76C8AF13BC9CB5B2F6B55E758A55C004A554F5866.png)
滑动场景
将屏幕向右滑动（屏幕内容右移）一个节点的距离，Repeat将开始复用缓存池中的节点。index=10的节点进入有效加载范围，计算出其template type为bb。由于bb缓存池非空，Repeat会从bb缓存池中取出一个空闲节点进行复用，更新其节点属性，该子组件中涉及数据item和索引index的其他孙子组件会根据V2状态管理的规则做同步更新。其他节点仍在有效加载范围，均只更新索引index。
index=0的节点滑出了有效加载范围。当UI主线程空闲时，会检查aa缓存池是否已满，此时aa缓存池未满，将该节点加入到对应的缓存池中。
如果此时对应template type的缓存池已满，Repeat会销毁掉多余的节点。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163833.95457622289431738126824740806005:50001231000000:2800:C7BC18667EC106F021A65C760FB812C6FD56DC8D65F07E3F69828A5EBAE08550.png)
数据更新场景
在上一小节的基础上做如下的数组更新操作，删除index=4的节点，修改节点数据item_7为new_7。
首先，删除index=4的节点后，失效节点加入aa缓存池。后面的列表节点前移，新进入有效加载区域的节点item_11会复用bb缓存池中的空闲节点，其他节点均只更新索引index。如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163833.24178542664845352200967596799737:50001231000000:2800:3A39845C4791F77CACCB7A3DB7FD1E2D8249AB1747E8EBE9497D0378182E7526.png)
其次，节点item_5前移，索引index更新为4。根据template type的计算规则，节点item_5的template type变为aa，需要从aa缓存池中复用空闲节点，并且将旧节点加入bb缓存池。如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163833.45312849334007609385739857305052:50001231000000:2800:6E23A5164B4A38F8AB11A51D98823287FF8417EEF8C049E2017959C194F86DD1.png)
template：子组件渲染模板
template模板目前只支持在virtualScroll模式下使用。
totalCount：期望加载的数据长度
totalCount表示期望加载的数据长度，默认为原数组长度，可以大于已加载数据项的数量。令arr.length表示数据源长度，以下为totalCount的处理规则：
当totalCount > arr.length时，在父组件容器滚动过程中，应用需要保证列表即将滑动到数据源末尾时请求后续数据，开发者需要对数据请求的错误场景（如网络延迟）进行保护操作，直到数据源全部加载完成，否则列表滑动的过程中会出现滚动效果异常。
cachedCount：空闲节点缓存列表大小
cachedCount是相应的template type的缓存池中可缓存子组件节点的最大数量，仅在virtualScroll模式下生效。
滚动容器组件属性.cachedCount()和Repeat组件属性.template()的参数cachedCount都是为了平衡性能和内存，但是含义是不同的。
将cachedCount设置为当前模板的节点在屏上可能出现的最大数量时，Repeat可以做到尽可能多的复用。但后果是当屏上没有当前模板的节点时，缓存池也不会释放，应用内存会增大。需要开发者根据具体情况自行把控。
使用场景
non-virtualScroll数据展示&操作
数据源变化
```typescript
@Entry
@ComponentV2
struct Parent {
@Local simpleList: Array<string> = ['one', 'two', 'three'];
build() {
Row() {
Column() {
Text('点击修改第3个数组项的值')
.fontSize(24)
.fontColor(Color.Red)
.onClick(() => {
this.simpleList[2] = 'new three';
})
Repeat<string>(this.simpleList)
.each((obj: RepeatItem<string>)=>{
ChildItem({ item: obj.item })
.margin({top: 20})
})
.key((item: string) => item)
}
.justifyContent(FlexAlign.Center)
.width('100%')
.height('100%')
}
.height('100%')
.backgroundColor(0xF1F3F5)
}
}
@ComponentV2
struct ChildItem {
@Param @Require item: string;
build() {
Text(this.item)
.fontSize(30)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163834.99375842893645467851955857955972:50001231000000:2800:6271D33A09EAFBB305149E30693FFE3DD288E50DC8A4C335E1488C7D1A469DB5.gif)
第三个数组项重新渲染时会复用之前的第三项的组件，仅对数据做了刷新。
索引值变化
下方例子当交换数组项1和2时，若键值和上次保持一致，Repeat会复用之前的组件，仅对使用了index索引值的组件做数据刷新。
```typescript
@Entry
@ComponentV2
struct Parent {
@Local simpleList: Array<string> = ['one', 'two', 'three'];
build() {
Row() {
Column() {
Text('交换数组项1，2')
.fontSize(24)
.fontColor(Color.Red)
.onClick(() => {
let temp: string = this.simpleList[2];
this.simpleList[2] = this.simpleList[1];
this.simpleList[1] = temp;
})
.margin({bottom: 20})
Repeat<string>(this.simpleList)
.each((obj: RepeatItem<string>)=>{
Text("index: " + obj.index)
.fontSize(30)
ChildItem({ item: obj.item })
.margin({bottom: 20})
})
.key((item: string) => item)
}
.justifyContent(FlexAlign.Center)
.width('100%')
.height('100%')
}
.height('100%')
.backgroundColor(0xF1F3F5)
}
}
@ComponentV2
struct ChildItem {
@Param @Require item: string;
build() {
Text(this.item)
.fontSize(30)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163834.30048759434117879698811405389392:50001231000000:2800:77972913E17D001563ECDFC6397DBB225448AAA1893627B4C7440AFBCDF04C3B.gif)
virtualScroll数据展示&操作
本小节将展示virtualScroll模式下，Repeat的实际使用场景和组件节点的复用情况。根据复用规则可以衍生出大量的测试场景，篇幅原因，只对典型的数据变化进行解释。
一个template
下面的代码示例展示了Repeat virtualScroll模式下修改数组的常见操作，包括插入数据、修改数据、删除数据、交换数据。点击下拉框选择索引index值，点击相应的按钮即可进行数据修改操作。依次点击数据项可以交换被点击的两个数据项。
```typescript
@ObservedV2
class Repeat005Clazz {
@Trace message: string = '';
constructor(message: string) {
this.message = message;
}
}
@Entry
@ComponentV2
struct RepeatVirtualScroll {
@Local simpleList: Array<Repeat005Clazz> = [];
private exchange: number[] = [];
private counter: number = 0;
@Local selectOptions: SelectOption[] = [];
@Local selectIdx: number = 0;
@Monitor("simpleList")
reloadSelectOptions(): void {
this.selectOptions = [];
for (let i = 0; i < this.simpleList.length; ++i) {
this.selectOptions.push({ value: i.toString() });
}
if (this.selectIdx >= this.simpleList.length) {
this.selectIdx = this.simpleList.length - 1;
}
}
aboutToAppear(): void {
for (let i = 0; i < 100; i++) {
this.simpleList.push(new Repeat005Clazz(`item_${i}`));
}
this.reloadSelectOptions();
}
handleExchange(idx: number): void { // 点击交换子组件
this.exchange.push(idx);
if (this.exchange.length === 2) {
let _a = this.exchange[0];
let _b = this.exchange[1];
let temp: Repeat005Clazz = this.simpleList[_a];
this.simpleList[_a] = this.simpleList[_b];
this.simpleList[_b] = temp;
this.exchange = [];
}
}
build() {
Column({ space: 10 }) {
Text('virtualScroll each()&template() 1t')
.fontSize(15)
.fontColor(Color.Gray)
Text('Select an index and press the button to update data.')
.fontSize(15)
.fontColor(Color.Gray)
Select(this.selectOptions)
.selected(this.selectIdx)
.value(this.selectIdx.toString())
.key('selectIdx')
.onSelect((index: number) => {
this.selectIdx = index;
})
Row({ space: 5 }) {
Button('Add No.' + this.selectIdx)
.onClick(() => {
this.simpleList.splice(this.selectIdx, 0, new Repeat005Clazz(`${this.counter++}_add_item`));
this.reloadSelectOptions();
})
Button('Modify No.' + this.selectIdx)
.onClick(() => {
this.simpleList.splice(this.selectIdx, 1, new Repeat005Clazz(`${this.counter++}_modify_item`));
})
Button('Del No.' + this.selectIdx)
.onClick(() => {
this.simpleList.splice(this.selectIdx, 1);
this.reloadSelectOptions();
})
}
Button('Update array length to 5.')
.onClick(() => {
this.simpleList = this.simpleList.slice(0, 5);
this.reloadSelectOptions();
})
Text('Click on two items to exchange.')
.fontSize(15)
.fontColor(Color.Gray)
List({ space: 10 }) {
Repeat<Repeat005Clazz>(this.simpleList)
.each((obj: RepeatItem<Repeat005Clazz>) => {
ListItem() {
Text(`[each] index${obj.index}: ${obj.item.message}`)
.fontSize(25)
.onClick(() => {
this.handleExchange(obj.index);
})
}
})
.key((item: Repeat005Clazz, index: number) => {
return item.message;
})
.virtualScroll({ totalCount: this.simpleList.length })
.templateId(() => "a")
.template('a', (ri) => {
Text(`[a] index${ri.index}: ${ri.item.message}`)
.fontSize(25)
.onClick(() => {
this.handleExchange(ri.index);
})
}, { cachedCount: 3 })
}
.cachedCount(2)
.border({ width: 1 })
.width('95%')
.height('40%')
}
.justifyContent(FlexAlign.Center)
.width('100%')
.height('100%')
}
}
```
该应用列表内容为100项自定义类RepeatClazz的message字符串属性，List组件的cachedCount设为2，模板'a'的缓存池大小设为3。应用界面如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163834.15763894364178037290633635645000:50001231000000:2800:EA76240C2A0B79EAEDE3E7D5684F1E02DFFF5B6275DF6EAAFF69F159E265C387.gif)
多个template
```typescript
@ObservedV2
class Repeat006Clazz {
@Trace message: string = '';
constructor(message: string) {
this.message = message;
}
}
@Entry
@ComponentV2
struct RepeatVirtualScroll2T {
@Local simpleList: Array<Repeat006Clazz> = [];
private exchange: number[] = [];
private counter: number = 0;
@Local selectOptions: SelectOption[] = [];
@Local selectIdx: number = 0;
@Monitor("simpleList")
reloadSelectOptions(): void {
this.selectOptions = [];
for (let i = 0; i < this.simpleList.length; ++i) {
this.selectOptions.push({ value: i.toString() });
}
if (this.selectIdx >= this.simpleList.length) {
this.selectIdx = this.simpleList.length - 1;
}
}
aboutToAppear(): void {
for (let i = 0; i < 100; i++) {
this.simpleList.push(new Repeat006Clazz(`item_${i}`));
}
this.reloadSelectOptions();
}
handleExchange(idx: number): void { // 点击交换子组件
this.exchange.push(idx);
if (this.exchange.length === 2) {
let _a = this.exchange[0];
let _b = this.exchange[1];
let temp: Repeat006Clazz = this.simpleList[_a];
this.simpleList[_a] = this.simpleList[_b];
this.simpleList[_b] = temp;
this.exchange = [];
}
}
build() {
Column({ space: 10 }) {
Text('virtualScroll each()&template() 2t')
.fontSize(15)
.fontColor(Color.Gray)
Text('Select an index and press the button to update data.')
.fontSize(15)
.fontColor(Color.Gray)
Select(this.selectOptions)
.selected(this.selectIdx)
.value(this.selectIdx.toString())
.key('selectIdx')
.onSelect((index: number) => {
this.selectIdx = index;
})
Row({ space: 5 }) {
Button('Add No.' + this.selectIdx)
.onClick(() => {
this.simpleList.splice(this.selectIdx, 0, new Repeat006Clazz(`${this.counter++}_add_item`));
this.reloadSelectOptions();
})
Button('Modify No.' + this.selectIdx)
.onClick(() => {
this.simpleList.splice(this.selectIdx, 1, new Repeat006Clazz(`${this.counter++}_modify_item`));
})
Button('Del No.' + this.selectIdx)
.onClick(() => {
this.simpleList.splice(this.selectIdx, 1);
this.reloadSelectOptions();
})
}
Button('Update array length to 5.')
.onClick(() => {
this.simpleList = this.simpleList.slice(0, 5);
this.reloadSelectOptions();
})
Text('Click on two items to exchange.')
.fontSize(15)
.fontColor(Color.Gray)
List({ space: 10 }) {
Repeat<Repeat006Clazz>(this.simpleList)
.each((obj: RepeatItem<Repeat006Clazz>) => {
ListItem() {
Text(`[each] index${obj.index}: ${obj.item.message}`)
.fontSize(25)
.onClick(() => {
this.handleExchange(obj.index);
})
}
})
.key((item: Repeat006Clazz, index: number) => {
return item.message;
})
.virtualScroll({ totalCount: this.simpleList.length })
.templateId((item: Repeat006Clazz, index: number) => {
return (index % 2 === 0) ? 'odd' : 'even';
})
.template('odd', (ri) => {
Text(`[odd] index${ri.index}: ${ri.item.message}`)
.fontSize(25)
.fontColor(Color.Blue)
.onClick(() => {
this.handleExchange(ri.index);
})
}, { cachedCount: 3 })
.template('even', (ri) => {
Text(`[even] index${ri.index}: ${ri.item.message}`)
.fontSize(25)
.fontColor(Color.Green)
.onClick(() => {
this.handleExchange(ri.index);
})
}, { cachedCount: 1 })
}
.cachedCount(2)
.border({ width: 1 })
.width('95%')
.height('40%')
}
.justifyContent(FlexAlign.Center)
.width('100%')
.height('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163834.35685025386288701628780966397812:50001231000000:2800:C505F870D2E9EE88841C79A96A14C3D36E63D47C89A32A1B9F023F4C2FEDC8AC.gif)
Repeat嵌套
Repeat支持嵌套使用。下面是使用virtualScroll模式进行嵌套的示例代码：
```typescript
// Repeat嵌套
@Entry
@ComponentV2
struct RepeatNest {
@Local outerList: string[] = [];
@Local innerList: number[] = [];
aboutToAppear(): void {
for (let i = 0; i < 20; i++) {
this.outerList.push(i.toString());
this.innerList.push(i);
}
}
build() {
Column({ space: 20 }) {
Text('Repeat virtualScroll嵌套')
.fontSize(15)
.fontColor(Color.Gray)
List() {
Repeat<string>(this.outerList)
.each((obj) => {
ListItem() {
Column() {
Text('outerList item: ' + obj.item)
.fontSize(30)
List() {
Repeat<number>(this.innerList)
.each((subObj) => {
ListItem() {
Text('innerList item: ' + subObj.item)
.fontSize(20)
}
})
.key((item) => "innerList_" + item)
.virtualScroll()
}
.width('80%')
.border({ width: 1 })
.backgroundColor(Color.Orange)
}
.height('30%')
.backgroundColor(Color.Pink)
}
.border({ width: 1 })
})
.key((item) => "outerList_" + item)
.virtualScroll()
}
.width('80%')
.border({ width: 1 })
}
.justifyContent(FlexAlign.Center)
.width('90%')
.height('80%')
}
}
```
运行效果：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163834.50380294353685069174080580580054:50001231000000:2800:223214D739F476BD06C23E4CE136790D7A30D6FC349ABDE6851CF32728FF93DC.png)
父容器组件应用场景
本节展示Repeat virtualScroll模式与容器组件的常见应用场景。
与List组合使用
在List容器组件中使用Repeat的virtualScroll模式，示例如下：
```typescript
class DemoListItemInfo {
name: string;
icon: Resource;
constructor(name: string, icon: Resource) {
this.name = name;
this.icon = icon;
}
}
@Entry
@ComponentV2
struct DemoList {
@Local videoList: Array<DemoListItemInfo> = [];
aboutToAppear(): void {
for (let i = 0; i < 10; i++) {
// 此处app.media.listItem0、app.media.listItem1、app.media.listItem2仅作示例，请开发者自行替换
this.videoList.push(new DemoListItemInfo('视频' + i,
i % 3 == 0 ? $r("app.media.listItem0") :
i % 3 == 1 ? $r("app.media.listItem1") : $r("app.media.listItem2")));
}
}
@Builder
itemEnd(index: number) {
Button('删除')
.backgroundColor(Color.Red)
.onClick(() => {
this.videoList.splice(index, 1);
})
}
build() {
Column({ space: 10 }) {
Text('List容器组件中包含Repeat组件')
.fontSize(15)
.fontColor(Color.Gray)
List({ space: 5 }) {
Repeat<DemoListItemInfo>(this.videoList)
.each((obj: RepeatItem<DemoListItemInfo>) => {
ListItem() {
Column() {
Image(obj.item.icon)
.width('80%')
.margin(10)
Text(obj.item.name)
.fontSize(20)
}
}
.swipeAction({
end: {
builder: () => {
this.itemEnd(obj.index);
}
}
})
.onAppear(() => {
console.info('AceTag', obj.item.name);
})
})
.key((item: DemoListItemInfo) => item.name)
.virtualScroll()
}
.cachedCount(2)
.height('90%')
.border({ width: 1 })
.listDirection(Axis.Vertical)
.alignListItem(ListItemAlign.Center)
.divider({
strokeWidth: 1,
startMargin: 60,
endMargin: 60,
color: '#ffe9f0f0'
})
Row({ space: 10 }) {
Button('删除第1项')
.onClick(() => {
this.videoList.splice(0, 1);
})
Button('删除第5项')
.onClick(() => {
this.videoList.splice(4, 1);
})
}
}
.width('100%')
.height('100%')
.justifyContent(FlexAlign.Center)
}
}
```
右滑并点击按钮，或点击底部按钮，可删除视频卡片：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163834.75646411280112845546796168265581:50001231000000:2800:473C9736513D0F4B8394E7C74E53F59731123EAF5EAC19C8DBD643BF7BEEE820.gif)
与Grid组合使用
在Grid容器组件中使用Repeat的virtualScroll模式，示例如下：
```typescript
class DemoGridItemInfo {
name: string;
icon: Resource;
constructor(name: string, icon: Resource) {
this.name = name;
this.icon = icon;
}
}
@Entry
@ComponentV2
struct DemoGrid {
@Local itemList: Array<DemoGridItemInfo> = [];
@Local isRefreshing: boolean = false;
private layoutOptions: GridLayoutOptions = {
regularSize: [1, 1],
irregularIndexes: [10]
}
private GridScroller: Scroller = new Scroller();
private num: number = 0;
aboutToAppear(): void {
for (let i = 0; i < 10; i++) {
// 此处app.media.gridItem0、app.media.gridItem1、app.media.gridItem2仅作示例，请开发者自行替换
this.itemList.push(new DemoGridItemInfo('视频' + i,
i % 3 == 0 ? $r("app.media.gridItem0") :
i % 3 == 1 ? $r("app.media.gridItem1") : $r("app.media.gridItem2")));
}
}
build() {
Column({ space: 10 }) {
Text('Grid容器组件中包含Repeat组件')
.fontSize(15)
.fontColor(Color.Gray)
Refresh({ refreshing: $$this.isRefreshing }) {
Grid(this.GridScroller, this.layoutOptions) {
Repeat<DemoGridItemInfo>(this.itemList)
.each((obj: RepeatItem<DemoGridItemInfo>) => {
if (obj.index === 10 ) {
GridItem() {
Text('先前浏览至此，点击刷新')
.fontSize(20)
}
.height(30)
.border({ width: 1 })
.onClick(() => {
this.GridScroller.scrollToIndex(0);
this.isRefreshing = true;
})
.onAppear(() => {
console.info('AceTag', obj.item.name);
})
} else {
GridItem() {
Column() {
Image(obj.item.icon)
.width('100%')
.height(80)
.objectFit(ImageFit.Cover)
.borderRadius({ topLeft: 16, topRight: 16 })
Text(obj.item.name)
.fontSize(15)
.height(20)
}
}
.height(100)
.borderRadius(16)
.backgroundColor(Color.White)
.onAppear(() => {
console.info('AceTag', obj.item.name);
})
}
})
.key((item: DemoGridItemInfo) => item.name)
.virtualScroll()
}
.columnsTemplate('repeat(auto-fit, 150)')
.cachedCount(4)
.rowsGap(15)
.columnsGap(10)
.height('100%')
.padding(10)
.backgroundColor('#F1F3F5')
}
.onRefreshing(() => {
setTimeout(() => {
this.itemList.splice(10, 1);
this.itemList.unshift(new DemoGridItemInfo('refresh', $r('app.media.gridItem0'))); // 此处app.media.gridItem0仅作示例，请开发者自行替换
for (let i = 0; i < 10; i++) {
// 此处app.media.gridItem0、app.media.gridItem1、app.media.gridItem2仅作示例，请开发者自行替换
this.itemList.unshift(new DemoGridItemInfo('新视频' + this.num,
i % 3 == 0 ? $r("app.media.gridItem0") :
i % 3 == 1 ? $r("app.media.gridItem1") : $r("app.media.gridItem2")));
this.num++;
}
this.isRefreshing = false;
}, 1000);
console.info('AceTag', 'onRefreshing');
})
.refreshOffset(64)
.pullToRefresh(true)
.width('100%')
.height('85%')
Button('刷新')
.onClick(() => {
this.GridScroller.scrollToIndex(0);
this.isRefreshing = true;
})
}
.width('100%')
.height('100%')
.justifyContent(FlexAlign.Center)
}
}
```
下拉屏幕，或点击刷新按钮，或点击“先前浏览至此，点击刷新”，可加载新的视频内容：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163834.59983329978986758284958940785043:50001231000000:2800:810245E486CA494A767557396E37D5D24C57C97E49B6B23B65BCFCD955CC7422.gif)
与Swiper组合使用
在Swiper容器组件中使用Repeat的virtualScroll模式，示例如下：
```typescript
const remotePictures: Array<string> = [
'https://www.example.com/xxx/0001.jpg', // 请填写具体的网络图片地址
'https://www.example.com/xxx/0002.jpg',
'https://www.example.com/xxx/0003.jpg',
'https://www.example.com/xxx/0004.jpg',
'https://www.example.com/xxx/0005.jpg',
'https://www.example.com/xxx/0006.jpg',
'https://www.example.com/xxx/0007.jpg',
'https://www.example.com/xxx/0008.jpg',
'https://www.example.com/xxx/0009.jpg'
];
@ObservedV2
class DemoSwiperItemInfo {
id: string;
@Trace url: string = 'default';
constructor(id: string) {
this.id = id;
}
}
@Entry
@ComponentV2
struct DemoSwiper {
@Local pics: Array<DemoSwiperItemInfo> = [];
aboutToAppear(): void {
for (let i = 0; i < 9; i++) {
this.pics.push(new DemoSwiperItemInfo('pic' + i));
}
setTimeout(() => {
this.pics[0].url = remotePictures[0];
}, 1000);
}
build() {
Column() {
Text('Swiper容器组件中包含Repeat组件')
.fontSize(15)
.fontColor(Color.Gray)
Stack() {
Text('图片加载中')
.fontSize(15)
.fontColor(Color.Gray)
Swiper() {
Repeat(this.pics)
.each((obj: RepeatItem<DemoSwiperItemInfo>) => {
Image(obj.item.url)
.onAppear(() => {
console.info('AceTag', obj.item.id);
})
})
.key((item: DemoSwiperItemInfo) => item.id)
.virtualScroll()
}
.cachedCount(9)
.height('50%')
.loop(false)
.indicator(true)
.onChange((index) => {
setTimeout(() => {
this.pics[index].url = remotePictures[index];
}, 1000);
})
}
.width('100%')
.height('100%')
.backgroundColor(Color.Black)
}
}
}
```
定时1秒后加载图片，模拟网络延迟：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163834.32010050602837228004977597004622:50001231000000:2800:09F49271641451861F3D19D625821F73CDBB2CBE5BD535917D57FE21AE3BAFB0.gif)
常见问题
屏幕外的列表数据发生变化时，保证滚动条位置不变
以下示例中，屏幕外的数据源变化将影响屏幕中List列表Scroller停留的位置：
在List组件中声明Repeat组件，实现key值生成逻辑和each逻辑（如下示例代码），点击按钮“insert”，在屏幕显示的第一个元素前面插入一个元素，屏幕出现向下滚动。
```typescript
// 定义一个类，标记为可观察的
// 类中自定义一个数组，标记为可追踪的
@ObservedV2
class ArrayHolder {
@Trace arr: Array<number> = [];
// constructor，用于初始化数组个数
constructor(count: number) {
for (let i = 0; i < count; i++) {
this.arr.push(i);
}
}
}
@Entry
@ComponentV2
struct RepeatTemplateSingle {
@Local arrayHolder: ArrayHolder = new ArrayHolder(100);
@Local totalCount: number = this.arrayHolder.arr.length;
scroller: Scroller = new Scroller();
build() {
Column({ space: 5 }) {
List({ space: 20, initialIndex: 19, scroller: this.scroller }) {
Repeat(this.arrayHolder.arr)
.virtualScroll({ totalCount: this.totalCount })
.templateId((item, index) => {
return 'number';
})
.template('number', (r) => {
ListItem() {
Text(r.index! + ":" + r.item + "Reuse");
}
})
.each((r) => {
ListItem() {
Text(r.index! + ":" + r.item + "eachMessage");
}
})
}
.height('30%')
Button(`insert totalCount ${this.totalCount}`)
.height(60)
.onClick(() => {
// 插入元素，元素位置为屏幕显示的前一个元素
this.arrayHolder.arr.splice(18, 0, this.totalCount);
this.totalCount = this.arrayHolder.arr.length;
})
}
.width('100%')
.margin({ top: 5 })
}
}
```
运行效果：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163834.21258230155199849485297775786681:50001231000000:2800:9A76E9B3A7A82DF60EBAED1BF2D283DDCDA173C55431831F290415458D44CC76.gif)
以下为修正后的示例：
在一些场景中，我们不希望屏幕外的数据源变化影响屏幕中List列表Scroller停留的位置，可以通过List组件的onScrollIndex事件对列表滚动动作进行监听，当列表发生滚动时，获取列表滚动位置。使用Scroller组件的scrollToIndex特性，滑动到指定index位置，实现屏幕外的数据源增加/删除数据时，Scroller停留的位置不变的效果。
示例代码仅对增加数据的情况进行展示。
```typescript
// ...ArrayHolder的定义和上述demo代码一致
@Entry
@ComponentV2
struct RepeatTemplateSingle {
@Local arrayHolder: ArrayHolder = new ArrayHolder(100);
@Local totalCount: number = this.arrayHolder.arr.length;
scroller: Scroller = new Scroller();
private start: number = 1;
private end: number = 1;
build() {
Column({ space: 5 }) {
List({ space: 20, initialIndex: 19, scroller: this.scroller }) {
Repeat(this.arrayHolder.arr)
.virtualScroll({ totalCount: this.totalCount })
.templateId((item, index) => {
return 'number';
})
.template('number', (r) => {
ListItem() {
Text(r.index! + ":" + r.item + "Reuse")
}
})
.each((r) => {
ListItem() {
Text(r.index! + ":" + r.item + "eachMessage")
}
})
}
.onScrollIndex((start, end) => {
this.start = start;
this.end = end;
})
.height('30%')
Button(`insert totalCount ${this.totalCount}`)
.height(60)
.onClick(() => {
// 插入元素，元素位置为屏幕显示的前一个元素
this.arrayHolder.arr.splice(18, 0, this.totalCount);
let rect = this.scroller.getItemRect(this.start); // 获取子组件的大小位置
this.scroller.scrollToIndex(this.start + 1); // 滑动到指定index
this.scroller.scrollBy(0, -rect.y); // 滑动指定距离
this.totalCount = this.arrayHolder.arr.length;
})
}
.width('100%')
.margin({ top: 5 })
}
}
```
运行效果：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163834.28464847403559423827789296530112:50001231000000:2800:4827EB72701A8E6E231C3DFE62B1BA5B92A72035756D322FC8AF9A02282C05B5.gif)
totalCount值大于数据源长度
当数据源总长度很大时，会使用懒加载的方式先加载一部分数据，为了使Repeat显示正确的滚动条样式，需要将数据总长度赋值给totalCount，即数据源全部加载完成前，totalCount大于array.length。
totalCount > array.length时，在父组件容器滚动过程中，应用需要保证列表即将滑动到数据源末尾时请求后续数据，开发者需要对数据请求的错误场景（如网络延迟）进行保护操作，直到数据源全部加载完成，否则列表滑动的过程中会出现滚动效果异常。
上述规范可以通过实现父组件List/Grid的onScrollIndex属性的回调函数完成。示例代码如下：
```typescript
@ObservedV2
class VehicleData {
@Trace name: string;
@Trace price: number;
constructor(name: string, price: number) {
this.name = name;
this.price = price;
}
}
@ObservedV2
class VehicleDB {
public vehicleItems: VehicleData[] = [];
constructor() {
// 数组初始化大小 20
for (let i = 1; i <= 20; i++) {
this.vehicleItems.push(new VehicleData(`Vehicle${i}`, i));
}
}
}
@Entry
@ComponentV2
struct entryCompSucc {
@Local vehicleItems: VehicleData[] = new VehicleDB().vehicleItems;
@Local listChildrenSize: ChildrenMainSize = new ChildrenMainSize(60);
@Local totalCount: number = this.vehicleItems.length;
scroller: Scroller = new Scroller();
build() {
Column({ space: 3 }) {
List({ scroller: this.scroller }) {
Repeat(this.vehicleItems)
.virtualScroll({ totalCount: 50 }) // 数组预期长度 50
.templateId(() => 'default')
.template('default', (ri) => {
ListItem() {
Column() {
Text(`${ri.item.name} + ${ri.index}`)
.width('90%')
.height(this.listChildrenSize.childDefaultSize)
.backgroundColor(0xFFA07A)
.textAlign(TextAlign.Center)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
}.border({ width: 1 })
}, { cachedCount: 5 })
.each((ri) => {
ListItem() {
Text("Wrong: " + `${ri.item.name} + ${ri.index}`)
.width('90%')
.height(this.listChildrenSize.childDefaultSize)
.backgroundColor(0xFFA07A)
.textAlign(TextAlign.Center)
.fontSize(20)
.fontWeight(FontWeight.Bold)
}.border({ width: 1 })
})
.key((item, index) => `${index}:${item}`)
}
.height('50%')
.margin({ top: 20 })
.childrenMainSize(this.listChildrenSize)
.alignListItem(ListItemAlign.Center)
.onScrollIndex((start, end) => {
console.log('onScrollIndex', start, end);
// 数据懒加载
if (this.vehicleItems.length < 50) {
for (let i = 0; i < 10; i++) {
if (this.vehicleItems.length < 50) {
this.vehicleItems.push(new VehicleData("Vehicle_loaded", i));
}
}
}
})
}
}
}
```
示例代码运行效果：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163834.67146230904077333562059829504078:50001231000000:2800:299CFA5E5120182B36C1517172BA7ABBAA297DDEFDC42191599DB0851D1C26AB.gif)
Repeat与@Builder混用的限制
当Repeat与@Builder混用时，必须将RepeatItem类型整体进行传参，组件才能监听到数据变化，如果只传递RepeatItem.item或RepeatItem.index，将会出现UI渲染异常。
示例代码如下：
```typescript
@Entry
@ComponentV2
struct RepeatBuilderPage {
@Local simpleList1: Array<number> = [];
@Local simpleList2: Array<number> = [];
aboutToAppear(): void {
for (let i = 0; i < 100; i++) {
this.simpleList1.push(i);
this.simpleList2.push(i);
}
}
build() {
Column({ space: 20 }) {
Text('Repeat与@Builder混用，左边是异常场景，右边是正常场景，向下滑动一段距离可以看出差别')
.fontSize(15)
.fontColor(Color.Gray)
Row({ space: 20 }) {
List({ initialIndex: 5, space: 20 }) {
Repeat<number>(this.simpleList1)
.each((ri) => {})
.virtualScroll({ totalCount: this.simpleList1.length })
.templateId((item: number, index: number) => "default")
.template('default', (ri) => {
ListItem() {
Column() {
Text('Text id = ' + ri.item)
.fontSize(20)
this.buildItem1(ri.item) // 错误示例，为避免渲染异常，应修改为：this.buildItem1(ri)
}
}
.border({ width: 1 })
}, { cachedCount: 3 })
}
.cachedCount(1)
.border({ width: 1 })
.width('45%')
.height('60%')
List({ initialIndex: 5, space: 20 }) {
Repeat<number>(this.simpleList2)
.each((ri) => {})
.virtualScroll({ totalCount: this.simpleList2.length })
.templateId((item: number, index: number) => "default")
.template('default', (ri) => {
ListItem() {
Column() {
Text('Text id = ' + ri.item)
.fontSize(20)
this.buildItem2(ri) // 正确示例，渲染正常
}
}
.border({ width: 1 })
}, { cachedCount: 3 })
}
.cachedCount(1)
.border({ width: 1 })
.width('45%')
.height('60%')
}
}
.height('100%')
.justifyContent(FlexAlign.Center)
}
@Builder
// @Builder参数必须传RepeatItem类型才能正常渲染
buildItem1(item: number) {
Text('Builder1 id = ' + item)
.fontSize(20)
.fontColor(Color.Red)
.margin({ top: 2 })
}
@Builder
buildItem2(ri: RepeatItem<number>) {
Text('Builder2 id = ' + ri.item)
.fontSize(20)
.fontColor(Color.Red)
.margin({ top: 2 })
}
}
```
界面展示如下图，进入页面后向下滑动一段距离可以看出差别，左边是错误用法，右边是正确用法（Text组件为黑色，Builder组件为红色）。上述代码展示了开发过程中易出错的场景，即在@Builder构造函数中传参方式为值传递。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163834.26315108096959182153523880762609:50001231000000:2800:DAD52CB9950A92DE8C2CD561FE78FE283F3FC8F6FB1BDB243422CC6440342C8B.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-gettarget
爬取时间: 2025-04-28 07:00:04
来源: Huawei Developer
为了获取状态管理框架代理前的原始对象，开发者可以使用getTarget接口。
在阅读本文档前，建议提前阅读：@Observed，@ObservedV2。
从API version 12开始，开发者可以使用UIUtils中的getTarget接口获取状态管理框架代理前的原始对象。
概述
状态管理框架会对Class、Date、Map、Set、Array类型的原始对象添加代理，用于观测属性变化与API调用。这一层代理会使得变量类型改变，在类型判断、NAPI调用等场景，会由于类型并非原始对象的类型产生预料之外的结果。
-  使用getTarget接口需要导入UIUtils工具。
```typescript
import { UIUtils } from '@kit.ArkUI';
```
-  状态管理V1中，会给@Observed装饰的类对象以及使用状态变量装饰器如@State装饰的Class、Date、Map、Set、Array添加一层代理用于观测一层属性或API调用产生的变化。
-  状态管理V2中，会给使用状态变量装饰器如@Trace、@Local装饰的Date、Map、Set、Array添加一层代理用于观测API调用产生的变化。
使用getTarget接口可以获取这些代理对象的原始对象。
限制条件
-  getTarget仅支持对象类型传参。
```typescript
import { UIUtils } from '@kit.ArkUI';
let res = UIUtils.getTarget(2); // 非对象类型入参，错误用法
@Observed
class Info {
name: string = "Tom";
}
let info: Info = new Info();
let rawInfo: Info = UIUtils.getTarget(info); // 正确用法
```
-  更改getTarget获取的原始对象中的内容不会被观察到变化，也不会触发UI刷新。
```typescript
import { UIUtils } from '@kit.ArkUI';
@Observed
class Info {
name: string = "Tom";
}
@Entry
@Component
struct Index {
@State info: Info = new Info();
build() {
Column() {
Text(`info.name: ${this.info.name}`)
Button(`更改代理对象的属性`)
.onClick(() => {
this.info.name = "Alice"; // Text组件能够刷新
})
Button(`更改原始对象的属性`)
.onClick(() => {
let rawInfo: Info = UIUtils.getTarget(this.info);
rawInfo.name = "Bob"; // Text组件不能刷新
})
}
}
}
```
使用场景
获取状态管理V1代理前的原始对象
状态管理V1有两种场景会给对象增加代理：
【1】@Observed装饰的类实例。在创建@Observed装饰的类实例时，会给该实例添加代理。该过程发生在new对象的过程中，没有经过new操作符创建的对象是不被代理的。
```typescript
@Observed
class ObservedClass {
name: string = "Tom";
}
class NonObservedClass {
name: string = "Tom";
}
let observedClass: ObservedClass = new ObservedClass(); // 被代理
let nonObservedClass: NonObservedClass = new NonObservedClass(); // 不被代理
```
【2】状态变量装饰器装饰的复杂类型对象。使用@State、@Prop等状态变量装饰器装饰Class、Map、Set、Date、Array时，会添加代理。若该对象已经是代理对象，则不会重复创建代理。
```typescript
@Observed
class ObservedClass {
name: string = "Tom";
}
class NonObservedClass {
name: string = "Tom";
}
let observedClass: ObservedClass = new ObservedClass(); // 被代理
let nonObservedClass: NonObservedClass = new NonObservedClass(); // 不被代理
@Entry
@Component
struct Index {
@State observedObject: ObservedClass = observedClass; // 已被代理数据不会重复创建代理
@State nonObservedObject: NonObservedClass = nonObservedClass; // 创建代理
@State numberList: number[] = [1, 2, 3]; // Array类型创建代理
@State sampleMap: Map<number, string> = new Map([[0, "a"], [1, "b"], [3, "c"]]); // Map类型创建代理
@State sampleSet: Set<number> = new Set([0, 1, 2, 3, 4]); // Set类型创建代理
@State sampleDate: Date = new Date(); // Date类型创建代理
build() {
Column() {
Text(`this.observedObject === observedClass: ${this.observedObject === observedClass}`) // true
Text(`this.nonObservedObject === nonObservedClass: ${this.nonObservedObject === nonObservedClass}`) // false
}
}
}
```
使用UIUtils.getTarget接口可以获取代理前的原始对象。
```typescript
import { UIUtils } from '@kit.ArkUI';
@Observed
class ObservedClass {
name: string = "Tom";
}
class NonObservedClass {
name: string = "Tom";
}
let observedClass: ObservedClass = new ObservedClass(); // 被代理
let nonObservedClass: NonObservedClass = new NonObservedClass(); // 不被代理
let globalNumberList: number[] = [1, 2, 3]; // 不被代理
let globalSampleMap: Map<number, string> = new Map([[0, "a"], [1, "b"], [3, "c"]]); // 不被代理
let globalSampleSet: Set<number> = new Set([0, 1, 2, 3, 4]); // 不被代理
let globalSampleDate: Date = new Date(); // 不被代理
@Entry
@Component
struct Index {
@State observedObject: ObservedClass = observedClass; // 已被代理数据不会重复创建代理
@State nonObservedObject: NonObservedClass = nonObservedClass; // 创建代理
@State numberList: number[] = globalNumberList; // Array类型创建代理
@State sampleMap: Map<number, string> = globalSampleMap; // Map类型创建代理
@State sampleSet: Set<number> = globalSampleSet; // Set类型创建代理
@State sampleDate: Date = globalSampleDate; // Date类型创建代理
build() {
Column() {
Text(`this.observedObject === observedClass: ${this.observedObject ===
observedClass}`) // true
Text(`UIUtils.getTarget(this.nonObservedObject) === nonObservedClass: ${UIUtils.getTarget(this.nonObservedObject) ===
nonObservedClass}`) // true
Text(`UIUtils.getTarget(this.numberList) === globalNumberList: ${UIUtils.getTarget(this.numberList) ===
globalNumberList}`) // true
Text(`UIUtils.getTarget(this.sampleMap) === globalSampleMap: ${UIUtils.getTarget(this.sampleMap) ===
globalSampleMap}`) // true
Text(`UIUtils.getTarget(this.sampleSet) === globalSampleSet: ${UIUtils.getTarget(this.sampleSet) ===
globalSampleSet}`) // true
Text(`UIUtils.getTarget(this.sampleDate) === globalSampleDate: ${UIUtils.getTarget(this.sampleDate) ===
globalSampleDate}`) // true
}
}
}
```
获取状态管理V2代理前的原始对象
状态管理V2会给状态变量装饰器如@Trace、@Local装饰的Map、Set、Date、Array添加一层代理。和V1不同的是，状态管理V2不会对类对象实例进行代理。
```typescript
@ObservedV2
class ObservedClass {
@Trace name: string = "Tom";
}
let globalObservedObject: ObservedClass = new ObservedClass(); // 不被代理
let globalNumberList: number[] = [1, 2, 3]; // 不被代理
let globalSampleMap: Map<number, string> = new Map([[0, "a"], [1, "b"], [3, "c"]]); // 不被代理
let globalSampleSet: Set<number> = new Set([0, 1, 2, 3, 4]); // 不被代理
let globalSampleDate: Date = new Date(); // 不被代理
@Entry
@ComponentV2
struct Index {
@Local observedObject: ObservedClass = globalObservedObject; // V2中对象不被代理
@Local numberList: number[] = globalNumberList; // Array类型创建代理
@Local sampleMap: Map<number, string> = globalSampleMap; // Map类型创建代理
@Local sampleSet: Set<number> = globalSampleSet; // Set类型创建代理
@Local sampleDate: Date = globalSampleDate; // Date类型创建代理
build() {
Column() {
Text(`this.observedObject === globalObservedObject ${this.observedObject === globalObservedObject}`) // true
Text(`this.numberList === globalNumberList ${this.numberList === globalNumberList}`) // false
}
}
}
```
使用UIUtils.getTarget接口可以获取代理前的原始对象。
```typescript
import { UIUtils } from '@kit.ArkUI';
@ObservedV2
class ObservedClass {
@Trace name: string = "Tom";
}
let globalObservedObject: ObservedClass = new ObservedClass(); // 不被代理
let globalNumberList: number[] = [1, 2, 3]; // 不被代理
let globalSampleMap: Map<number, string> = new Map([[0, "a"], [1, "b"], [3, "c"]]); // 不被代理
let globalSampleSet: Set<number> = new Set([0, 1, 2, 3, 4]); // 不被代理
let globalSampleDate: Date = new Date(); // 不被代理
@Entry
@ComponentV2
struct Index {
@Local observedObject: ObservedClass = globalObservedObject; // V2中对象不被代理
@Local numberList: number[] = globalNumberList; // Array类型创建代理
@Local sampleMap: Map<number, string> = globalSampleMap; // Map类型创建代理
@Local sampleSet: Set<number> = globalSampleSet; // Set类型创建代理
@Local sampleDate: Date = globalSampleDate; // Date类型创建代理
build() {
Column() {
Text(`this.observedObject === globalObservedObject ${this.observedObject ===
globalObservedObject}`) // true
Text(`UIUtils.getTarget(this.numberList) === globalNumberList: ${UIUtils.getTarget(this.numberList) ===
globalNumberList}`) // true
Text(`UIUtils.getTarget(this.sampleMap) === globalSampleMAP: ${UIUtils.getTarget(this.sampleMap) ===
globalSampleMap}`) // true
Text(`UIUtils.getTarget(this.sampleSet) === globalSampleSet: ${UIUtils.getTarget(this.sampleSet) ===
globalSampleSet}`) // true
Text(`UIUtils.getTarget(this.sampleDate) === globalSampleDate: ${UIUtils.getTarget(this.sampleDate) ===
globalSampleDate}`) // true
}
}
}
```
状态管理V2装饰器会为装饰的变量生成getter和setter方法，同时为原有变量名添加"__ob_"的前缀。出于性能考虑，getTarget接口不会对V2装饰器生成的前缀进行处理，因此向getTarget接口传入@ObservedV2装饰的类对象实例时，返回的对象依旧为对象本身，且被@Trace装饰的属性名仍有"__ob_"前缀。
该前缀会导致某些NAPI接口无法按预期处理对象的属性，以下面的对象为例，目前已知影响的NAPI接口如下：
```typescript
// ObservedV2装饰的类
@ObservedV2
class Info {
@Trace name: string = "Tom";
@Trace age: number = 24;
}
let info: Info = new Info(); // NAPI接口传入info实例
```
| 影响接口名 | 影响结果 |
| --- | --- |
| napi_get_property_names | 返回值为"__ob_name"，"__ob_age"。 |
| napi_set_property | 使用"name"，"__ob_name"均能赋值成功。 |
| napi_get_property | 使用"name"，"__ob_name"均能获取到值。 |
| napi_has_property | 使用"name"，"__ob_name"均返回true。 |
| napi_delete_property | 删除属性时需要加上"__ob_"前缀才能删除成功。 |
| napi_has_own_property | 使用"name"，"__ob_name"均返回true。 |
| napi_set_named_property | 使用"name"，"__ob_name"均能赋值成功。 |
| napi_get_named_property | 使用"name"，"__ob_name"均能获取到值。 |
| napi_has_named_property | 使用"name"，"__ob_name"均返回true。 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-makeobserved
爬取时间: 2025-04-28 07:00:18
来源: Huawei Developer
为了将普通不可观察数据变为可观察数据，开发者可以使用makeObserved接口。
makeObserved可以在@Trace无法标记的情况下使用。在阅读本文档前，建议提前阅读：@Trace。
从API version 12开始，开发者可以使用UIUtils中的makeObserved接口将普通不可观察数据变为可观察数据。
概述
-  状态管理框架已提供@ObservedV2/@Trace用于观察类属性变化，makeObserved接口提供主要应用于@ObservedV2/@Trace无法涵盖的场景： class的定义在三方包中：开发者无法手动对class中需要观察的属性加上@Trace标签，可以使用makeObserved使得当前对象可以被观察。 当前类的成员属性不能被修改：因为@Trace观察类属性会动态修改类的属性，这个行为在@Sendable装饰的class中是不被允许的，此时可以使用makeObserved。 interface或者JSON.parse返回的匿名对象：这类场景往往没有明确的class声明，开发者无法使用@Trace标记当前属性可以被观察，此时可以使用makeObserved。
-  class的定义在三方包中：开发者无法手动对class中需要观察的属性加上@Trace标签，可以使用makeObserved使得当前对象可以被观察。
-  当前类的成员属性不能被修改：因为@Trace观察类属性会动态修改类的属性，这个行为在@Sendable装饰的class中是不被允许的，此时可以使用makeObserved。
-  interface或者JSON.parse返回的匿名对象：这类场景往往没有明确的class声明，开发者无法使用@Trace标记当前属性可以被观察，此时可以使用makeObserved。
-  使用makeObserved接口需要导入UIUtils。
```typescript
import { UIUtils } from '@kit.ArkUI';
```
-  class的定义在三方包中：开发者无法手动对class中需要观察的属性加上@Trace标签，可以使用makeObserved使得当前对象可以被观察。
-  当前类的成员属性不能被修改：因为@Trace观察类属性会动态修改类的属性，这个行为在@Sendable装饰的class中是不被允许的，此时可以使用makeObserved。
-  interface或者JSON.parse返回的匿名对象：这类场景往往没有明确的class声明，开发者无法使用@Trace标记当前属性可以被观察，此时可以使用makeObserved。
限制条件
-  makeObserved仅支持非空的对象类型传参。
```typescript
import { UIUtils } from '@kit.ArkUI';
let res1 = UIUtils.makeObserved(2); // 非法类型入参，错误用法，编译报错
let res2 = UIUtils.makeObserved(undefined); // 非法类型入参，错误用法，返回自身，res2 === undefined
let res3 = UIUtils.makeObserved(null); // 非法类型入参，错误用法，返回自身，res3 === null
class Info {
id: number = 0;
}
let rawInfo: Info = UIUtils.makeObserved(new Info()); // 正确用法
```
-  makeObserved不支持传入被@ObservedV2、@Observed装饰的类的实例以及已经被makeObserved封装过的代理数据。为了防止双重代理，makeObserved发现入参为上述情况时则直接返回，不做处理。
```typescript
import { UIUtils } from '@kit.ArkUI';
@ObservedV2
class Info {
@Trace id: number = 0;
}
// 错误用法：makeObserved发现传入的实例是@ObservedV2装饰的类的实例，则返回传入对象自身
let observedInfo: Info = UIUtils.makeObserved(new Info());
class Info2 {
id: number = 0;
}
// 正确用法：传入对象既不是@ObservedV2/@Observed装饰的类的实例，也不是makeObserved封装过的代理数据
// 返回可观察数据
let observedInfo1: Info2 = UIUtils.makeObserved(new Info2());
// 错误用法：传入对象为makeObserved封装过的代理数据，此次makeObserved不做处理
let observedInfo2: Info2 = UIUtils.makeObserved(observedInfo1);
```
-  makeObserved可以用在@Component装饰的自定义组件中，但不能和状态管理V1的状态变量装饰器配合使用，如果一起使用，则会抛出运行时异常。 下面message2的写法不会抛异常，原因是this.message是@State装饰的，其实现等同于@Observed，而UIUtils.makeObserved的入参是@Observed装饰的class，会直接返回自身。因此对于message2来说，他的初始值不是makeObserved的返回值，而是@State装饰的变量。
```typescript
// 错误写法，运行时异常
@State message: Info = UIUtils.makeObserved(new Info(20));
```
makeObserved仅对入参生效，不会改变接受返回值的观察能力
```typescript
import { UIUtils } from '@kit.ArkUI';
class Info {
id: number = 0;
constructor(id: number) {
this.id = id;
}
}
@Entry
@ComponentV2
struct Index {
@Local message: Info = UIUtils.makeObserved(new Info(20));
build() {
Column() {
Button(`change id`).onClick(() => {
this.message.id++;
})
Button(`change Info ${this.message.id}`).onClick(() => {
this.message = new Info(30);
})
Button(`change Info1 ${this.message.id}`).onClick(() => {
this.message = UIUtils.makeObserved(new Info(30));
})
}
}
}
```
支持类型和观察变化
支持类型
观察变化
-  makeObserved传入内置类型或collections类型的实例时，可以观测其API带来的变化：
| 类型 | 可观测变化的API |
| --- | --- |
| Array | push、pop、shift、unshift、splice、copyWithin、fill、reverse、sort |
| collections.Array | push、pop、shift、unshift、splice、fill、reverse、sort、shrinkTo、extendTo |
| Map/collections.Map | set、clear、delete |
| Set/collections.Set | add、clear、delete |
| Date | setFullYear、setMonth、setDate、setHours、setMinutes、setSeconds、setMilliseconds、setTime、setUTCFullYear、setUTCMonth、setUTCDate、setUTCHours、setUTCMinutes、setUTCSeconds、setUTCMilliseconds |
使用场景
makeObserved和@Sendable装饰的class配合使用
@Sendable主要是为了处理应用场景中的并发任务。将makeObserved和@Sendable配合使用是为了满足一般应用开发中，在子线程做大数据处理，在UI线程做ViewModel的显示和观察数据的需求。@Sendable具体内容可参考并发任务文档。
本章节将说明下面的场景：
例子如下：
```typescript
// SendableData.ets
@Sendable
export class SendableData  {
name: string = 'Tom';
age: number = 20;
gender: number = 1;
// ....更多其他属性
likes: number = 1;
follow: boolean = false;
}
```
```typescript
import { taskpool } from '@kit.ArkTS';
import { SendableData } from './SendableData';
import { UIUtils } from '@kit.ArkUI';
@Concurrent
function threadGetData(param: string): SendableData {
// 在子线程处理数据
let ret = new SendableData();
console.info(`Concurrent threadGetData, param ${param}`);
ret.name = param + "-o";
ret.age = Math.floor(Math.random() * 40);
ret.likes = Math.floor(Math.random() * 100);
return ret;
}
@Entry
@ComponentV2
struct ObservedSendableTest {
// 通过makeObserved给普通对象或是Sendable对象添加可观察能力
@Local send: SendableData = UIUtils.makeObserved(new SendableData());
build() {
Column() {
Text(this.send.name)
Button("change name").onClick(() => {
// ok 可以观察到属性的改变
this.send.name += "0";
})
Button("task").onClick(() => {
// 将待执行的函数放入taskpool内部任务队列等待，等待分发到工作线程执行。
taskpool.execute(threadGetData, this.send.name).then(val => {
// 和@Local一起使用，可以观察this.send的变化
this.send = UIUtils.makeObserved(val as SendableData);
})
})
}
}
}
```
需要注意：数据的构建和处理可以在子线程中完成，但有观察能力的数据不能传给子线程，只有在主线程里才可以操作可观察的数据。所以上述例子中只是将this.send的属性name传给子线程操作。
makeObserved和collections.Array/Set/Map配合使用
collections提供ArkTS容器集，可用于并发场景下的高性能数据传递。详情见@arkts.collections文档。
makeObserved可以在ArkUI中导入可观察的colletions容器，但makeObserved不能和状态管理V1的状态变量装饰器如@State和@Prop等配合使用，否则会抛出运行时异常。
collections.Array
collections.Array可以触发UI刷新的API有：
其他API不会改变原始数组，所以不会触发UI刷新。
```typescript
import { collections } from '@kit.ArkTS';
import { UIUtils } from '@kit.ArkUI';
@Sendable
class Info {
id: number = 0;
name: string = 'cc';
constructor(id: number) {
this.id = id;
}
}
@Entry
@ComponentV2
struct Index {
scroller: Scroller = new Scroller();
@Local arrCollect: collections.Array<Info> =
UIUtils.makeObserved(new collections.Array<Info>(new Info(1), new Info(2)));
build() {
Column() {
// ForEach接口仅支持Array<any>，不支持collections.Array<any>。
// 但ForEach的实现用到的Array的API，collections.Array都有提供。所以可以使用as类型断言Array。
// 需要注意断言并不会改变原本的数据类型。
ForEach(this.arrCollect as object as Array<Info>, (item: Info) => {
Text(`${item.id}`).onClick(() => {
item.id++;
})
}, (item: Info, index) => item.id.toString() + index.toString())
Divider()
.color('blue')
if (this.arrCollect.length > 0) {
Text(`the first one ${this.arrCollect[this.arrCollect.length - this.arrCollect.length].id}`)
Text(`the last one ${this.arrCollect[this.arrCollect.length - 1].id}`)
}
Divider()
.color('blue')
/****************************改变数据长度的api**************************/
Scroll(this.scroller) {
Column({space: 10}) {
// push: 新增新元素
Button('push').onClick(() => {
this.arrCollect.push(new Info(30));
})
// pop: 删除最后一个
Button('pop').onClick(() => {
this.arrCollect.pop();
})
// shift: 删除第一个
Button('shift').onClick(() => {
this.arrCollect.shift();
})
// unshift: 在数组的开头插入新项
Button('unshift').onClick(() => {
this.arrCollect.unshift(new Info(50));
})
// splice: 从数组的指定位置删除元素
Button('splice').onClick(() => {
this.arrCollect.splice(1);
})
// shrinkTo: 将数组长度缩小到给定的长度
Button('shrinkTo').onClick(() => {
this.arrCollect.shrinkTo(1);
})
// extendTo: 将数组长度扩展到给定的长度
Button('extendTo').onClick(() => {
this.arrCollect.extendTo(6, new Info(20));
})
Divider()
.color('blue')
/****************************************改变数组item本身*****************/
// sort：从大到小排序
Button('sort').onClick(() => {
this.arrCollect.sort((a: Info, b: Info) => b.id - a.id);
})
// fill: 用值填充指定部分
Button('fill').onClick(() => {
this.arrCollect.fill(new Info(5), 0, 2);
})
/*****************************不会改变数组本身API***************************/
// slice：返回新的数组，根据start end对原数组的拷贝，不会改变原数组，所以直接调用slice不会触发UI刷新
// 可以构建用例为返回的浅拷贝的数据赋值给this.arrCollect,需要注意这里依然要调用makeObserved，否则this.arr被普通变量赋值后，会丧失观察能力
Button('slice').onClick(() => {
this.arrCollect = UIUtils.makeObserved(this.arrCollect.slice(0, 1));
})
// map：原理同上
Button('map').onClick(() => {
this.arrCollect = UIUtils.makeObserved(this.arrCollect.map((value) => {
value.id += 10;
return value;
}))
})
// filter：原理同上
Button('filter').onClick(() => {
this.arrCollect = UIUtils.makeObserved(this.arrCollect.filter((value: Info) => value.id % 2 === 0));
})
// concat：原理同上
Button('concat').onClick(() => {
let array1 = new collections.Array(new Info(100))
this.arrCollect = UIUtils.makeObserved(this.arrCollect.concat(array1));
})
}.height('200%')
}.height('60%')
}
.height('100%')
.width('100%')
}
}
```
collections.Map
collections.Map可以触发UI刷新的API有：set、clear、delete。
```typescript
import { collections } from '@kit.ArkTS';
import { UIUtils } from '@kit.ArkUI';
@Sendable
class Info {
id: number = 0;
constructor(id: number) {
this.id = id;
}
}
@Entry
@ComponentV2
struct CollectionMap {
mapCollect: collections.Map<string, Info> = UIUtils.makeObserved(new collections.Map<string, Info>([['a', new Info(10)], ['b', new Info(20)]]));
build() {
Column() {
// this.mapCollect.keys()返回迭代器。Foreach不支持迭代器，所以要Array.From浅拷贝生成数据。
ForEach(Array.from(this.mapCollect.keys()), (item: string) => {
Text(`${this.mapCollect.get(item)?.id}`).onClick(() => {
let value: Info|undefined = this.mapCollect.get(item);
if (value) {
value.id++;
}
})
}, (item: string, index) => item + index.toString())
// set c
Button('set c').onClick(() => {
this.mapCollect.set('c', new Info(30));
})
// delete c
Button('delete c').onClick(() => {
if (this.mapCollect.has('c')) {
this.mapCollect.delete('c');
}
})
// clear
Button('clear').onClick(() => {
this.mapCollect.clear();
})
}
.height('100%')
.width('100%')
}
}
```
collections.Set
collections.Set可以触发UI刷新的API有：add、clear、delete。
```typescript
import { collections } from '@kit.ArkTS';
import { UIUtils } from '@kit.ArkUI';
@Sendable
class Info {
id: number = 0;
constructor(id: number) {
this.id = id;
}
}
@Entry
@ComponentV2
struct Index {
set: collections.Set<Info> = UIUtils.makeObserved(new collections.Set<Info>([new Info(10), new Info(20)]));
build() {
Column() {
// 因为ForEach不支持迭代器，所以需要使用Array.from浅拷贝生成数组。
// 但是浅拷贝生成的新的数组没有观察能力，为了ForEach组件在访问item的时候是可观察的数据，所以需要重新调用makeObserved。
ForEach((UIUtils.makeObserved(Array.from(this.set.values()))), (item: Info) => {
Text(`${item.id}`).onClick(() => {
item.id++;
})
}, (item: Info, index) => item.id + index.toString())
// add
Button('add').onClick(() => {
this.set.add(new Info(30));
console.log('size:' + this.set.size);
})
// delete
Button('delete').onClick(() => {
let iterator = this.set.keys();
this.set.delete(iterator.next().value);
})
// clear
Button('clear').onClick(() => {
this.set.clear();
})
}
.height('100%')
.width('100%')
}
}
```
makeObserved的入参为JSON.parse的返回值
JSON.parse返回Object，无法使用@Trace装饰其属性，可以使用makeObserved使其变为可观察数据。
```typescript
import { JSON } from '@kit.ArkTS';
import { UIUtils } from '@kit.ArkUI';
class Info {
id: number = 0;
constructor(id: number) {
this.id = id;
}
}
let test: Record<string, number> = { "a": 123 };
let testJsonStr :string = JSON.stringify(test);
let test2: Record<string, Info> = { "a": new Info(20) };
let test2JsonStr: string = JSON.stringify(test2);
@Entry
@ComponentV2
struct Index {
message: Record<string, number> = UIUtils.makeObserved<Record<string, number>>(JSON.parse(testJsonStr) as Record<string, number>);
message2: Record<string, Info> = UIUtils.makeObserved<Record<string, Info>>(JSON.parse(test2JsonStr) as Record<string, Info>);
build() {
Column() {
Text(`${this.message.a}`)
.fontSize(50)
.onClick(() => {
this.message.a++;
})
Text(`${this.message2.a.id}`)
.fontSize(50)
.onClick(() => {
this.message2.a.id++;
})
}
.height('100%')
.width('100%')
}
}
```
makeObserved和V2装饰器配合使用
makeObserved可以和V2的装饰器一起使用。对于@Monitor和@Computed，因为makeObserved传入@Observed或ObservedV2装饰的类实例会返回其自身，所以@Monitor或者@Computed不能定义在class中，只能定义在自定义组件里。
例子如下：
```typescript
import { UIUtils } from '@kit.ArkUI';
class Info {
id: number = 0;
age: number = 20;
constructor(id: number) {
this.id = id;
}
}
@Entry
@ComponentV2
struct Index {
@Local message: Info = UIUtils.makeObserved(new Info(20));
@Monitor('message.id')
onStrChange(monitor: IMonitor) {
console.log(`name change from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
@Computed
get ageId() {
console.info("---------Computed----------");
return this.message.id + ' ' + this.message.age;
}
build() {
Column() {
Text(`id: ${this.message.id}`)
.fontSize(50)
.onClick(() => {
this.message.id++;
})
Text(`age: ${this.message.age}`)
.fontSize(50)
.onClick(() => {
this.message.age++;
})
Text(`Computed age+id: ${this.ageId}`)
.fontSize(50)
Button('change Info').onClick(() => {
this.message = UIUtils.makeObserved(new Info(200));
})
Child({message: this.message})
}
.height('100%')
.width('100%')
}
}
@ComponentV2
struct Child {
@Param @Require message: Info;
build() {
Text(`Child id: ${this.message.id}`)
}
}
```
makeObserved在@Component内使用
makeObserved不能和V1的状态变量装饰器一起使用，但可以在@Component装饰的自定义组件里使用。
```typescript
import { UIUtils } from '@kit.ArkUI';
class Info {
id: number = 0;
constructor(id: number) {
this.id = id;
}
}
@Entry
@Component
struct Index {
// 如果和@State一起使用会抛出运行时异常
message: Info = UIUtils.makeObserved(new Info(20));
build() {
RelativeContainer() {
Text(`${this.message.id}`)
.onClick(() => {
this.message.id++;
})
}
.height('100%')
.width('100%')
}
}
```
常见问题
getTarget后的数据可以正常赋值，但是无法触发UI刷新
getTarget可以获取状态管理框架代理前的原始对象。
makeObserved封装的观察对象，可以通过getTarget获取到其原始对象，对原始对象的赋值不会触发UI刷新。
如下面例子：
```typescript
import { UIUtils } from '@kit.ArkUI';
class Info {
id: number = 0;
}
@Entry
@Component
struct Index {
observedObj: Info = UIUtils.makeObserved(new Info());
build() {
Column() {
Text(`${this.observedObj.id}`)
.fontSize(50)
.onClick(() => {
// 通过getTarget获取其原始对象，将this.observedObj赋值为不可观察的数据
let rawObj: Info= UIUtils.getTarget(this.observedObj);
// 不会触发UI刷新，但数据会正常赋值
rawObj.id = 20;
})
Text(`${this.observedObj.id}`)
.fontSize(50)
.onClick(() => {
// 触发UI刷新，Text显示21
this.observedObj.id++;
})
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-mvvm-v2
爬取时间: 2025-04-28 07:00:34
来源: Huawei Developer
概述
在应用开发中，UI的更新需要随着数据状态的变化进行实时同步，而这种同步往往决定了应用程序的性能和用户体验。为了解决数据与UI同步的复杂性，ArkUI采用了Model-View-ViewModel（MVVM）架构模式。MVVM将应用分为Model、View和ViewModel三个核心部分，实现数据、视图与逻辑的分离。通过这种模式，UI可以随着状态的变化自动更新，无需手动处理，从而更加高效地管理数据和视图的绑定与更新。
通过状态管理V2版本实现ViewModel
在MVVM模式中，ViewModel扮演着至关重要的角色，负责管理数据状态，并在数据发生变化时自动更新视图。ArkUI的状态管理V2版本提供了丰富的装饰器和工具，帮助开发者在自定义组件之间共享数据，确保数据变化自动同步到UI。常用的状态管理装饰器包括@Local、@Param、@Event、@ObservedV2、@Trace等等。除此之外，V2还提供了AppStorageV2和PersistenceV2作为全局状态存储工具，用于应用间的状态共享和持久化存储。
本节将通过一个简单的todolist示例，逐步引入和使用状态管理V2的装饰器及工具，从基础的静态任务列表开始，逐步扩展功能。每个步骤都基于上一步扩展，帮助开发者循序渐进地理解并掌握各个装饰器的使用方法。
基础示例
首先，从最基础的静态待办事项列表开始。在这个例子中，任务是静态的，没有状态变化和动态交互。
```typescript
// src/main/ets/pages/1-Basic.ets
@Entry
@ComponentV2
struct TodoList {
build() {
Column() {
Text('待办')
.fontSize(40)
.margin({ bottom: 10 })
Text('Task1')
Text('Task2')
Text('Task3')
}
}
}
```
添加@Local，实现对组件内部状态观测
完成静态待办列表展示后，为了让用户能够更改任务的完成状态，需要使待办事项能够响应交互并动态更新显示。为此，引入@Local装饰器管理组件内部的状态。被@Local装饰的变量发生变化时，会触发绑定的UI组件刷新。
在这个例子中，新增了一个被@Local装饰的isFinish属性代表任务是否完成。准备了两个图标：finished.png和unfinished.png，用于展示任务完成或未完成的状态。点击待办事项时，isFinish状态切换，从而更新图标和文本删除线的效果。
```typescript
// src/main/ets/pages/2-Local.ets
@Entry
@ComponentV2
struct TodoList {
@Local isFinish: boolean = false;
build() {
Column() {
Text('待办')
.fontSize(40)
.margin({ bottom: 10 })
Row() {
// 请开发者自行在src/main/resources/base/media路径下添加finished.png和unfinished.png两张图片，否则运行时会因资源缺失而报错
Image(this.isFinish ? $r('app.media.finished') : $r('app.media.unfinished'))
.width(28)
.height(28)
Text('Task1')
.decoration({ type: this.isFinish ? TextDecorationType.LineThrough : TextDecorationType.None })
}
.onClick(() => this.isFinish = !this.isFinish)
}
}
}
```
添加@Param，实现组件接受外部输入
实现了任务本地状态切换后，为了增强待办事项列表的灵活性，需要能够动态设置每个任务的名称，而不是固定在代码中。引入@Param装饰器后，子组件被修饰的变量能够接收父组件传入的值，实现从父到子的单向数据同步。默认情况下，@Param是只读的。如需在子组件中对传入的值进行本地更新，可使用@Param @Once进行配置。
在这个例子中，每个待办事项被抽象为TaskItem组件。被@Param修饰的taskName属性从父组件TodoList传入任务名称，使TaskItem组件灵活且可复用，能接收并渲染不同的任务名称。被@Param @Once装饰的isFinish属性在接收初始值后，可以在子组件内更新。
```typescript
// src/main/ets/pages/3-Param.ets
@ComponentV2
struct TaskItem {
@Param taskName: string = '';
@Param @Once isFinish: boolean = false;
build() {
Row() {
// 请开发者自行在src/main/resources/base/media路径下添加finished.png和unfinished.png两张图片，否则运行时会因资源缺失而报错
Image(this.isFinish ? $r('app.media.finished') : $r('app.media.unfinished'))
.width(28)
.height(28)
Text(this.taskName)
.decoration({ type: this.isFinish ? TextDecorationType.LineThrough : TextDecorationType.None })
}
.onClick(() => this.isFinish = !this.isFinish)
}
}
@Entry
@ComponentV2
struct TodoList {
build() {
Column() {
Text('待办')
.fontSize(40)
.margin({ bottom: 10 })
TaskItem({ taskName: 'Task 1', isFinish: false })
TaskItem({ taskName: 'Task 2', isFinish: false })
TaskItem({ taskName: 'Task 3', isFinish: false })
}
}
}
```
添加@Event，实现组件对外输出
在实现任务名称动态设置后，任务列表内容依然是固定的，需要增加任务项的添加和删除功能，以实现任务列表的动态扩展。为此，引入@Event装饰器，用于实现子组件向父组件输出数据。
在这个例子中，每个TaskItem增加了删除按钮，同时任务列表底部增加了添加新任务的功能。点击子组件TaskItem的“删除”按钮时，deleteTask事件会被触发并传递给父组件TodoList，父组件响应并将该任务从列表中移除。通过使用@Param和@Event，子组件不仅能接收父组件的数据，还能够将事件传递回父组件，实现数据的双向同步。
```typescript
// src/main/ets/pages/4-Event.ets
@ComponentV2
struct TaskItem {
@Param taskName: string = '';
@Param @Once isFinish: boolean = false;
@Event deleteTask: () => void = () => {};
build() {
Row() {
// 请开发者自行在src/main/resources/base/media路径下添加finished.png和unfinished.png两张图片，否则运行时会因资源缺失而报错
Image(this.isFinish ? $r('app.media.finished') : $r('app.media.unfinished'))
.width(28)
.height(28)
Text(this.taskName)
.decoration({ type: this.isFinish ? TextDecorationType.LineThrough : TextDecorationType.None })
Button('删除')
.onClick(() => this.deleteTask())
}
.onClick(() => this.isFinish = !this.isFinish)
}
}
@Entry
@ComponentV2
struct TodoList {
@Local tasks: string[] = ['task1','task2','task3'];
@Local newTaskName: string = '';
build() {
Column() {
Text('待办')
.fontSize(40)
.margin({ bottom: 10 })
ForEach(this.tasks, (task: string) => {
TaskItem({
taskName: task,
isFinish: false,
deleteTask: () => this.tasks.splice(this.tasks.indexOf(task), 1)
})
})
Row() {
TextInput({ placeholder: '添加新任务', text: this.newTaskName })
.onChange((value) => this.newTaskName = value)
.width('70%')
Button('增加事项')
.onClick(() => {
this.tasks.push(this.newTaskName);
this.newTaskName = '';
})
}
}
}
}
```
添加Repeat，实现子组件复用
添加了任务增删功能后，随着任务列表项的增加，需要一种高效渲染多个结构相同的子组件的方法，以提高界面的性能表现。为此，引入了Repeat方法，用于优化任务列表的渲染过程。Repeat支持两种模式：virtualScroll和non-virtualScroll。virtualScroll适用于大量数据的场景，在滚动类容器中按需加载组件，极大节省内存和提升渲染效率。non-virtualScroll适用于数据量较小的场景，一次性渲染所有组件，并在数据变化时仅更新需要变化的部分，避免整体重新渲染。
在本例中，任务量较少，选择了non-virtualScroll模式。新建了一个任务数组tasks，并使用Repeat方法迭代数组中的每一项，动态生成并复用TaskItem组件。在任务增删时，这种方式能高效复用已有组件，避免重复渲染，从而提高界面响应速度和性能。这种机制有效地提高了代码的复用性和渲染效率。
```typescript
// src/main/ets/pages/5-Repeat.ets
@ComponentV2
struct TaskItem {
@Param taskName: string = '';
@Param @Once isFinish: boolean = false;
@Event deleteTask: () => void = () => {};
build() {
Row() {
// 请开发者自行在src/main/resources/base/media路径下添加finished.png和unfinished.png两张图片，否则运行时会因资源缺失而报错
Image(this.isFinish ? $r('app.media.finished') : $r('app.media.unfinished'))
.width(28)
.height(28)
Text(this.taskName)
.decoration({ type: this.isFinish ? TextDecorationType.LineThrough : TextDecorationType.None })
Button('删除')
.onClick(() => this.deleteTask())
}
.onClick(() => this.isFinish = !this.isFinish)
}
}
@Entry
@ComponentV2
struct TodoList {
@Local tasks: string[] = ['task1','task2','task3'];
@Local newTaskName: string = '';
build() {
Column() {
Text('待办')
.fontSize(40)
.margin({ bottom: 10 })
Repeat<string>(this.tasks)
.each((obj: RepeatItem<string>) => {
TaskItem({
taskName: obj.item,
isFinish: false,
deleteTask: () => this.tasks.splice(this.tasks.indexOf(obj.item), 1)
})
})
Row() {
TextInput({ placeholder: '添加新任务', text: this.newTaskName })
.onChange((value) => this.newTaskName = value)
.width('70%')
Button('增加事项')
.onClick(() => {
this.tasks.push(this.newTaskName);
this.newTaskName = '';
})
}
}
}
}
```
添加@ObservedV2，@Trace，实现类属性观测变化
实现了多个功能之后，任务列表的管理逐渐变得复杂。为了更好地处理任务数据的变化，特别在多层嵌套结构中，需要确保属性的变化可以被深度观测并自动更新UI。为此，引入了@ObservedV2和@Trace装饰器。相比于@Local只能观测对象本身及其第一层的变化，@ObservedV2和@Trace更适用于处理多层嵌套、继承等复杂结构场景。在@ObservedV2装饰的类中，被@Trace装饰的属性发生变化时，会触发其绑定的UI组件刷新。
在这个例子中，任务（Task）被抽象为一个类，并用@ObservedV2标记该类，用@Trace标记isFinish属性。TodoList组件嵌套了TaskItem，TaskItem又嵌套了Task。在最外层的TodoList中，添加了"全部完成"和"全部未完成"的按钮，每次点击这些按钮都会直接更新最内层Task类的isFinish属性。@ObservedV2和@Trace确保可以观察到对应isFinish UI组件的刷新，从而实现了对嵌套类属性的深度观测。
```typescript
// src/main/ets/pages/6-ObservedV2Trace.ets
@ObservedV2
class Task {
taskName: string = '';
@Trace isFinish: boolean = false;
constructor (taskName: string, isFinish: boolean) {
this.taskName = taskName;
this.isFinish = isFinish;
}
}
@ComponentV2
struct TaskItem {
@Param task: Task = new Task('', false);
@Event deleteTask: () => void = () => {};
build() {
Row() {
// 请开发者自行在src/main/resources/base/media路径下添加finished.png和unfinished.png两张图片，否则运行时会因资源缺失而报错
Image(this.task.isFinish ? $r('app.media.finished') : $r('app.media.unfinished'))
.width(28)
.height(28)
Text(this.task.taskName)
.decoration({ type: this.task.isFinish ? TextDecorationType.LineThrough : TextDecorationType.None })
Button('删除')
.onClick(() => this.deleteTask())
}
.onClick(() => this.task.isFinish = !this.task.isFinish)
}
}
@Entry
@ComponentV2
struct TodoList {
@Local tasks: Task[] = [
new Task('task1', false),
new Task('task2', false),
new Task('task3', false),
];
@Local newTaskName: string = '';
finishAll(ifFinish: boolean) {
for (let task of this.tasks) {
task.isFinish = ifFinish;
}
}
build() {
Column() {
Text('待办')
.fontSize(40)
.margin({ bottom: 10 })
Repeat<Task>(this.tasks)
.each((obj: RepeatItem<Task>) => {
TaskItem({
task: obj.item,
deleteTask: () => this.tasks.splice(this.tasks.indexOf(obj.item), 1)
})
})
Row() {
Button('全部完成')
.onClick(() => this.finishAll(true))
Button('全部未完成')
.onClick(() => this.finishAll(false))
}
Row() {
TextInput({ placeholder: '添加新任务', text: this.newTaskName })
.onChange((value) => this.newTaskName = value)
.width('70%')
Button('增加事项')
.onClick(() => {
this.tasks.push(new Task(this.newTaskName, false));
this.newTaskName = '';
})
}
}
}
}
```
添加@Monitor，@Computed，实现监听状态变量和计算属性
在当前任务列表功能基础上，为了提升体验，可以增加一些额外的功能，如任务状态变化的监听和未完成任务数量的动态计算。为此，引入@Monitor和@Computed装饰器。@Monitor用于深度监听状态变量，在属性变化时触发自定义回调方法。@Computed用于装饰getter方法，检测被计算的属性变化。在被计算的值变化时，仅会计算一次，减少重复计算开销。
在这个例子中，使用@Monitor深度监听TaskItem中task的isFinish属性。当任务完成状态变化时会触发onTasksFinished回调，输出日志记录任务完成状态的变化。此外，新增了对todolist中未完成任务的数量的记录。用@Computed装饰tasksUnfinished，每当任务状态变化时自动重新计算。通过这两个装饰器，实现了对状态变量的深度监听和高效的计算属性。
```typescript
// src/main/ets/pages/7-MonitorComputed.ets
@ObservedV2
class Task {
taskName: string = '';
@Trace isFinish: boolean = false;
constructor (taskName: string, isFinish: boolean) {
this.taskName = taskName;
this.isFinish = isFinish;
}
}
@ComponentV2
struct TaskItem {
@Param task: Task = new Task('', false);
@Event deleteTask: () => void = () => {};
@Monitor('task.isFinish')
onTaskFinished(mon: IMonitor) {
console.log('任务' + this.task.taskName + '的完成状态从' + mon.value()?.before + '变为了' + mon.value()?.now);
}
build() {
Row() {
// 请开发者自行在src/main/resources/base/media路径下添加finished.png和unfinished.png两张图片，否则运行时会因资源缺失而报错
Image(this.task.isFinish ? $r('app.media.finished') : $r('app.media.unfinished'))
.width(28)
.height(28)
Text(this.task.taskName)
.decoration({ type: this.task.isFinish ? TextDecorationType.LineThrough : TextDecorationType.None })
Button('删除')
.onClick(() => this.deleteTask())
}
.onClick(() => this.task.isFinish = !this.task.isFinish)
}
}
@Entry
@ComponentV2
struct TodoList {
@Local tasks: Task[] = [
new Task('task1', false),
new Task('task2', false),
new Task('task3', false),
];
@Local newTaskName: string = '';
finishAll(ifFinish: boolean) {
for (let task of this.tasks) {
task.isFinish = ifFinish;
}
}
@Computed
get tasksUnfinished(): number {
return this.tasks.filter(task => !task.isFinish).length;
}
build() {
Column() {
Text('待办')
.fontSize(40)
.margin({ bottom: 10 })
Text(`未完成任务：${this.tasksUnfinished}`)
Repeat<Task>(this.tasks)
.each((obj: RepeatItem<Task>) => {
TaskItem({
task: obj.item,
deleteTask: () => this.tasks.splice(this.tasks.indexOf(obj.item), 1)
})
})
Row() {
Button('全部完成')
.onClick(() => this.finishAll(true))
Button('全部未完成')
.onClick(() => this.finishAll(false))
}
Row() {
TextInput({ placeholder: '添加新任务', text: this.newTaskName })
.onChange((value) => this.newTaskName = value)
.width('70%')
Button('增加事项')
.onClick(() => {
this.tasks.push(new Task(this.newTaskName, false));
this.newTaskName = '';
})
}
}
}
}
```
添加AppStorageV2，实现应用全局UI状态存储
随着待办事项功能的不断增强，应用可能涉及到多个页面或功能模块，此时常常需要在这些页面之间共享全局状态。例如，在待办事项应用中，可以新增一个设置页面与主界面联动。为实现跨页面的状态共享，引入AppStorageV2，用于在多个UIAbility实例之间存储和共享应用的全局状态。
在这个例子中，新增了一个Ability，SettingAbility，用于加载设置页SettingPage。SettingPage包含了一个Setting类，其中的showCompletedTask属性用于控制是否显示已完成的任务，用户通过一个开关可以切换该选项。两个Ability通过AppStorageV2共享设置数据，键为"Setting"，对应的数据为Setting类。第一次通过connect连接Setting时，若不存在储存的数据，会新建一个默认showCompletedTask为trueSetting实例。后续用户在设置页面修改设置后，主页面会根据这一设置更新任务列表的显示。通过AppStorageV2，实现了跨Ability、跨页面的数据共享。
```typescript
// src/main/ets/pages/8-AppStorageV2.ets
import { AppStorageV2 } from '@kit.ArkUI';
import { common, Want } from '@kit.AbilityKit';
import { Setting } from './SettingPage';
@ObservedV2
class Task {
taskName: string = '';
@Trace isFinish: boolean = false;
constructor (taskName: string, isFinish: boolean) {
this.taskName = taskName;
this.isFinish = isFinish;
}
}
@ComponentV2
struct TaskItem {
@Param task: Task = new Task('', false);
@Event deleteTask: () => void = () => {};
@Monitor('task.isFinish')
onTaskFinished(mon: IMonitor) {
console.log('任务' + this.task.taskName + '的完成状态从' + mon.value()?.before + '变为了' + mon.value()?.now);
}
build() {
Row() {
// 请开发者自行在src/main/resources/base/media路径下添加finished.png和unfinished.png两张图片，否则运行时会因资源缺失而报错
Image(this.task.isFinish ? $r('app.media.finished') : $r('app.media.unfinished'))
.width(28)
.height(28)
Text(this.task.taskName)
.decoration({ type: this.task.isFinish ? TextDecorationType.LineThrough : TextDecorationType.None })
Button('删除')
.onClick(() => this.deleteTask())
}
.onClick(() => this.task.isFinish = !this.task.isFinish)
}
}
@Entry
@ComponentV2
struct TodoList {
@Local tasks: Task[] = [
new Task('task1', false),
new Task('task2', false),
new Task('task3', false),
];
@Local newTaskName: string = '';
@Local setting: Setting = AppStorageV2.connect(Setting, 'Setting', () => new Setting())!;
private context = getContext(this) as common.UIAbilityContext;
finishAll(ifFinish: boolean) {
for (let task of this.tasks) {
task.isFinish = ifFinish;
}
}
@Computed
get tasksUnfinished(): number {
return this.tasks.filter(task => !task.isFinish).length;
}
build() {
Column() {
Text('待办')
.fontSize(40)
.margin({ bottom: 10 })
Text(`未完成任务：${this.tasksUnfinished}`)
Repeat<Task>(this.tasks.filter(task => this.setting.showCompletedTask || !task.isFinish))
.each((obj: RepeatItem<Task>) => {
TaskItem({
task: obj.item,
deleteTask: () => this.tasks.splice(this.tasks.indexOf(obj.item), 1)
})
})
Row() {
Button('全部完成')
.onClick(() => this.finishAll(true))
Button('全部未完成')
.onClick(() => this.finishAll(false))
Button('设置')
.onClick(() => {
let wantInfo: Want = {
deviceId: '', // deviceId为空表示本设备
bundleName: 'com.samples.statemgmtv2mvvm', // 替换成AppScope/app.json5里的bundleName
abilityName: 'SettingAbility',
};
this.context.startAbility(wantInfo);
})
}
Row() {
TextInput({ placeholder: '添加新任务', text: this.newTaskName })
.onChange((value) => this.newTaskName = value)
.width('70%')
Button('增加事项')
.onClick(() => {
this.tasks.push(new Task(this.newTaskName, false));
this.newTaskName = '';
})
}
}
}
}
```
```typescript
// SettingAbility的SettingPage页面代码
import { AppStorageV2 } from '@kit.ArkUI';
import { common } from '@kit.AbilityKit';
@ObservedV2
export class Setting {
@Trace showCompletedTask: boolean = true;
}
@Entry
@ComponentV2
struct SettingPage {
@Local setting: Setting = AppStorageV2.connect(Setting, 'Setting', () => new Setting())!;
private context = getContext(this) as common.UIAbilityContext;
build() {
Column() {
Text('设置')
.fontSize(40)
.margin({ bottom: 10 })
Row() {
Text('显示已完成任务');
Toggle({ type: ToggleType.Switch, isOn:this.setting.showCompletedTask })
.onChange((isOn) => {
this.setting.showCompletedTask = isOn;
})
}
Button('返回待办')
.onClick(()=>this.context.terminateSelf())
.margin({ top: 10 })
}
.alignItems(HorizontalAlign.Start)
}
}
```
添加PersistenceV2，实现持久化UI状态存储
为了保证用户在重新打开应用时仍然能够看到之前的任务状态，可以引入持久化存储方案。使用PersistenceV2能够将数据持久化保存在设备磁盘上。与AppStorageV2的运行时内存不同，PersistenceV2能确保即使应用关闭后再启动，数据依然保持不变。
在这个例子中，创建了一个TaskList类，用于通过PersistenceV2持久化存储所有任务信息，键为"TaskList"，数据对应TaskList类。第一次通过connect连接TaskList时，如果没有数据，会创建一个默认tasks数组为空的新TaskList实例。在aboutToAppear生命周期函数中，连接到PersistenceV2的TaskList，若无存储任务数据，会从本地文件defaultTasks.json中加载任务并存储到PersistenceV2中。此后，每个任务的完成状态都会同步到PersistenceV2中。这样，即使应用关闭后再次打开，所有任务数据依旧保持不变，实现了持久化的应用状态存储功能。
```typescript
// src/main/ets/pages/9-PersistenceV2.ets
import { AppStorageV2, PersistenceV2, Type } from '@kit.ArkUI';
import { common, Want } from '@kit.AbilityKit';
import { Setting } from './SettingPage';
import util from '@ohos.util';
@ObservedV2
class Task {
// 未实现构造函数，因为@Type当前不支持带参数的构造函数
@Trace taskName: string = 'Todo';
@Trace isFinish: boolean = false;
}
@ObservedV2
class TaskList {
// 对于复杂对象需要@Type修饰，确保序列化成功
@Type(Task)
@Trace tasks: Task[] = [];
constructor(tasks: Task[]) {
this.tasks = tasks;
}
async loadTasks(context: common.UIAbilityContext) {
let getJson = await context.resourceManager.getRawFileContent('defaultTasks.json');
let textDecoderOptions: util.TextDecoderOptions = { ignoreBOM : true };
let textDecoder = util.TextDecoder.create('utf-8',textDecoderOptions);
let result = textDecoder.decodeToString(getJson);
this.tasks =JSON.parse(result).map((task: Task)=>{
let newTask = new Task();
newTask.taskName = task.taskName;
newTask.isFinish = task.isFinish;
return newTask;
});
}
}
@ComponentV2
struct TaskItem {
@Param task: Task = new Task();
@Event deleteTask: () => void = () => {};
@Monitor('task.isFinish')
onTaskFinished(mon: IMonitor) {
console.log('任务' + this.task.taskName + '的完成状态从' + mon.value()?.before + '变为了' + mon.value()?.now);
}
build() {
Row() {
// 请开发者自行在src/main/resources/base/media路径下添加finished.png和unfinished.png两张图片，否则运行时会因资源缺失而报错
Image(this.task.isFinish ? $r('app.media.finished') : $r('app.media.unfinished'))
.width(28)
.height(28)
Text(this.task.taskName)
.decoration({ type: this.task.isFinish ? TextDecorationType.LineThrough : TextDecorationType.None })
Button('删除')
.onClick(() => this.deleteTask())
}
.onClick(() => this.task.isFinish = !this.task.isFinish)
}
}
@Entry
@ComponentV2
struct TodoList {
@Local taskList: TaskList = PersistenceV2.connect(TaskList, 'TaskList', () => new TaskList([]))!;
@Local newTaskName: string = '';
@Local setting: Setting = AppStorageV2.connect(Setting, 'Setting', () => new Setting())!;
private context = getContext(this) as common.UIAbilityContext;
async aboutToAppear() {
this.taskList = PersistenceV2.connect(TaskList, 'TaskList', () => new TaskList([]))!;
if (this.taskList.tasks.length === 0) {
await this.taskList.loadTasks(this.context);
}
}
finishAll(ifFinish: boolean) {
for (let task of this.taskList.tasks) {
task.isFinish = ifFinish;
}
}
@Computed
get tasksUnfinished(): number {
return this.taskList.tasks.filter(task => !task.isFinish).length;
}
build() {
Column() {
Text('待办')
.fontSize(40)
.margin({ bottom: 10 })
Text(`未完成任务：${this.tasksUnfinished}`)
Repeat<Task>(this.taskList.tasks.filter(task => this.setting.showCompletedTask || !task.isFinish))
.each((obj: RepeatItem<Task>) => {
TaskItem({
task: obj.item,
deleteTask: () => this.taskList.tasks.splice(this.taskList.tasks.indexOf(obj.item), 1)
})
})
Row() {
Button('全部完成')
.onClick(() => this.finishAll(true))
Button('全部未完成')
.onClick(() => this.finishAll(false))
Button('设置')
.onClick(() => {
let wantInfo: Want = {
deviceId: '', // deviceId为空表示本设备
bundleName: 'com.samples.statemgmtv2mvvm', // 替换成AppScope/app.json5里的bundleName
abilityName: 'SettingAbility',
};
this.context.startAbility(wantInfo);
})
}
Row() {
TextInput({ placeholder: '添加新任务', text: this.newTaskName })
.onChange((value) => this.newTaskName = value)
.width('70%')
Button('增加事项')
.onClick(() => {
let newTask = new Task();
newTask.taskName = this.newTaskName;
this.taskList.tasks.push(newTask);
this.newTaskName = '';
})
}
}
}
}
```
JSON文件存放在src/main/resources/rawfile/defaultTasks.json路径下。
```json
[
{"taskName": "学习ArkTS开发", "isFinish": false},
{"taskName": "健身", "isFinish": false},
{"taskName": "买水果", "isFinish": true},
{"taskName": "取快递", "isFinish": true},
{"taskName": "刷题", "isFinish": true}
]
```
添加@Builder，实现自定义构建函数
随着应用功能逐步扩展，代码中的某些UI元素开始重复，这不仅增加了代码量，也让维护变得复杂。为了解决这一问题，可以使用@Builder装饰器，将重复的UI组件抽象成独立的构建方法，便于复用和代码的模块化。
在这个例子中，使用@Builder定义了ActionButton方法，统一管理各类按钮的文字、样式和点击事件，使代码更简洁、结构更清晰，提升了代码的可维护性。在此基础上，调整了待办事项界面的布局和样式，例如组件的间距、颜色和大小，使UI更美观，最终呈现一个功能完善、界面简洁的待办事项应用。
```typescript
// src/main/ets/pages/10-Builder.ets
import { AppStorageV2, PersistenceV2, Type } from '@kit.ArkUI';
import { common, Want } from '@kit.AbilityKit';
import { Setting } from './SettingPage';
import util from '@ohos.util';
@ObservedV2
class Task {
// 未实现构造函数，因为@Type当前不支持带参数的构造函数
@Trace taskName: string = 'Todo';
@Trace isFinish: boolean = false;
}
@Builder function ActionButton(text: string, onClick:() => void) {
Button(text, { buttonStyle: ButtonStyleMode.NORMAL })
.onClick(onClick)
.margin({ left: 10, right: 10, top: 5, bottom: 5 })
}
@ObservedV2
class TaskList {
// 对于复杂对象需要@Type修饰，确保序列化成功
@Type(Task)
@Trace tasks: Task[] = [];
constructor(tasks: Task[]) {
this.tasks = tasks;
}
async loadTasks(context: common.UIAbilityContext) {
let getJson = await context.resourceManager.getRawFileContent('defaultTasks.json');
let textDecoderOptions: util.TextDecoderOptions = { ignoreBOM : true };
let textDecoder = util.TextDecoder.create('utf-8',textDecoderOptions);
let result = textDecoder.decodeToString(getJson);
this.tasks =JSON.parse(result).map((task: Task)=>{
let newTask = new Task();
newTask.taskName = task.taskName;
newTask.isFinish = task.isFinish;
return newTask;
});
}
}
@ComponentV2
struct TaskItem {
@Param task: Task = new Task();
@Event deleteTask: () => void = () => {};
@Monitor('task.isFinish')
onTaskFinished(mon: IMonitor) {
console.log('任务' + this.task.taskName + '的完成状态从' + mon.value()?.before + '变为了' + mon.value()?.now);
}
build() {
Row() {
// 请开发者自行在src/main/resources/base/media路径下添加finished.png和unfinished.png两张图片，否则运行时会因资源缺失而报错
Image(this.task.isFinish ? $r('app.media.finished') : $r('app.media.unfinished'))
.width(28)
.height(28)
.margin({ left : 15, right : 10 })
Text(this.task.taskName)
.decoration({ type: this.task.isFinish ? TextDecorationType.LineThrough : TextDecorationType.None })
.fontSize(18)
ActionButton('删除', () => this.deleteTask())
}
.height('7%')
.width('90%')
.backgroundColor('#90f1f3f5')
.borderRadius(25)
.onClick(() => this.task.isFinish = !this.task.isFinish)
}
}
@Entry
@ComponentV2
struct TodoList {
@Local taskList: TaskList = PersistenceV2.connect(TaskList, 'TaskList', () => new TaskList([]))!;
@Local newTaskName: string = '';
@Local setting: Setting = AppStorageV2.connect(Setting, 'Setting', () => new Setting())!;
private context = getContext(this) as common.UIAbilityContext;
async aboutToAppear() {
this.taskList = PersistenceV2.connect(TaskList, 'TaskList', () => new TaskList([]))!;
if (this.taskList.tasks.length === 0) {
await this.taskList.loadTasks(this.context);
}
}
finishAll(ifFinish: boolean) {
for (let task of this.taskList.tasks) {
task.isFinish = ifFinish;
}
}
@Computed
get tasksUnfinished(): number {
return this.taskList.tasks.filter(task => !task.isFinish).length;
}
build() {
Column() {
Text('待办')
.fontSize(40)
.margin(10)
Text(`未完成任务：${this.tasksUnfinished}`)
.margin({ left: 10, bottom: 10 })
Repeat<Task>(this.taskList.tasks.filter(task => this.setting.showCompletedTask || !task.isFinish))
.each((obj: RepeatItem<Task>) => {
TaskItem({
task: obj.item,
deleteTask: () => this.taskList.tasks.splice(this.taskList.tasks.indexOf(obj.item), 1)
}).margin(5)
})
Row() {
ActionButton('全部完成', (): void => this.finishAll(true))
ActionButton('全部未完成', (): void => this.finishAll(false))
ActionButton('设置', (): void => {
let wantInfo: Want = {
deviceId: '', // deviceId为空表示本设备
bundleName: 'com.samples.statemgmtv2mvvm', // 替换成AppScope/app.json5里的bundleName
abilityName: 'SettingAbility',
};
this.context.startAbility(wantInfo);
})
}
.margin({ top: 10, bottom: 5 })
Row() {
TextInput({ placeholder: '添加新任务', text: this.newTaskName })
.onChange((value) => this.newTaskName = value)
.width('70%')
ActionButton('+', (): void => {
let newTask = new Task();
newTask.taskName = this.newTaskName;
this.taskList.tasks.push(newTask);
this.newTaskName = '';
})
}
}
.height('100%')
.width('100%')
.alignItems(HorizontalAlign.Start)
.margin({ left: 15 })
}
}
```
效果图展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163835.17103427372505835176901435203825:50001231000000:2800:DB26526520CE5DE3B15CB5823BD04C3E195B18772E94F7A5587BB8DACC83347C.gif)
重构代码以符合MVVM架构
前面的例子通过使用一系列的状态管理装饰器，实现了todolist中的数据同步与UI更新。然而，随着应用功能的复杂化，代码的结构变得难以维护，Model、View和ViewModel的职责并没有完全分离，仍然存在一定的耦合。为了更好地组织代码和提升可维护性，使用MVVM模式重构代码，进一步将数据层（Model）、逻辑层（ViewModel）和展示层（View）分离。
重构后的代码结构
Model层
Model层负责管理应用的数据及其业务逻辑，通常与后端或数据存储进行交互。在todolist应用中，Model层的主要职责是存储任务数据、加载任务列表，并提供数据操作的接口，而不直接涉及UI展示。
```typescript
// src/main/ets/model/TaskModel.ets
export default class TaskModel {
taskName: string = 'Todo';
isFinish: boolean = false;
}
```
```typescript
// src/main/ets/model/TaskListModel.ets
import { common } from '@kit.AbilityKit';
import util from '@ohos.util';
import TaskModel from'./TaskModel';
export default class TaskListModel {
tasks: TaskModel[] = [];
constructor(tasks: TaskModel[]) {
this.tasks = tasks;
}
async loadTasks(context: common.UIAbilityContext){
let getJson = await context.resourceManager.getRawFileContent('defaultTasks.json');
let textDecoderOptions: util.TextDecoderOptions = { ignoreBOM : true };
let textDecoder = util.TextDecoder.create('utf-8',textDecoderOptions);
let result = textDecoder.decodeToString(getJson);
this.tasks =JSON.parse(result).map((task: TaskModel)=>{
let newTask = new TaskModel();
newTask.taskName = task.taskName;
newTask.isFinish = task.isFinish;
return newTask;
});
}
}
```
ViewModel层
ViewModel层负责管理UI状态和业务逻辑，扮演Model和View之间的桥梁角色。在ViewModel中，负责监控Model数据的变化，处理应用的逻辑，并将数据同步到View层，从而实现UI的自动更新。ViewModel的使用实现了数据与视图的解耦，提高了代码的可读性和可维护性。
```typescript
// src/main/ets/viewmodel/TaskViewModel.ets
import TaskModel from '../model/TaskModel';
@ObservedV2
export default class TaskViewModel {
@Trace taskName: string = 'Todo';
@Trace isFinish: boolean = false;
updateTask(task: TaskModel) {
this.taskName = task.taskName;
this.isFinish = task.isFinish;
}
updateIsFinish(): void {
this.isFinish = !this.isFinish;
}
}
```
```typescript
// src/main/ets/viewmodel/TaskListViewModel.ets
import { common } from '@kit.AbilityKit';
import { Type } from '@kit.ArkUI';
import TaskListModel from '../model/TaskListModel';
import TaskViewModel from'./TaskViewModel';
@ObservedV2
export default class TaskListViewModel {
@Type(TaskViewModel)
@Trace tasks: TaskViewModel[] = [];
async loadTasks(context: common.UIAbilityContext) {
let taskList = new TaskListModel([]);
await taskList.loadTasks(context);
for(let task of taskList.tasks){
let taskViewModel = new TaskViewModel();
taskViewModel.updateTask(task);
this.tasks.push(taskViewModel);
}
}
finishAll(ifFinish: boolean): void {
for(let task of this.tasks){
task.isFinish = ifFinish;
}
}
addTask(newTask: TaskViewModel): void {
this.tasks.push(newTask);
}
removeTask(removedTask: TaskViewModel): void {
this.tasks.splice(this.tasks.indexOf(removedTask), 1)
}
}
```
View层
View层负责应用程序的UI展示和与用户的交互。它只关注如何渲染用户界面和展示数据，不包含业务逻辑。所有的数据状态和逻辑都来自ViewModel层，View层通过接收ViewModel传递的状态数据进行渲染，确保视图和数据分离。
```typescript
// src/main/ets/view/TitleView.ets
@ComponentV2
export default struct TitleView {
@Param tasksUnfinished: number = 0;
build() {
Column() {
Text('待办')
.fontSize(40)
.margin(10)
Text(`未完成任务：${this.tasksUnfinished}`)
.margin({ left: 10, bottom: 10 })
}
}
}
```
```typescript
// src/main/ets/view/ListView.ets
import TaskViewModel from '../viewmodel/TaskViewModel';
import TaskListViewModel from '../viewmodel/TaskListViewModel';
import { Setting } from '../pages/SettingPage';
import { ActionButton } from './BottomView';
@ComponentV2
struct TaskItem {
@Param task: TaskViewModel = new TaskViewModel();
@Event deleteTask: () => void = () => {};
@Monitor('task.isFinish')
onTaskFinished(mon: IMonitor) {
console.log('任务' + this.task.taskName + '的完成状态从' + mon.value()?.before + '变为了' + mon.value()?.now);
}
build() {
Row() {
// 请开发者自行在src/main/resources/base/media路径下添加finished.png和unfinished.png两张图片，否则运行时会因资源缺失而报错
Image(this.task.isFinish ? $r('app.media.finished') : $r('app.media.unfinished'))
.width(28)
.height(28)
.margin({ left: 15, right: 10 })
Text(this.task.taskName)
.decoration({ type: this.task.isFinish ? TextDecorationType.LineThrough : TextDecorationType.None })
.fontSize(18)
ActionButton('删除', () => this.deleteTask());
}
.height('7%')
.width('90%')
.backgroundColor('#90f1f3f5')
.borderRadius(25)
.onClick(() => this.task.updateIsFinish())
}
}
@ComponentV2
export default struct ListView {
@Param taskList: TaskListViewModel = new TaskListViewModel();
@Param setting: Setting = new Setting();
build() {
Repeat<TaskViewModel>(this.taskList.tasks.filter(task => this.setting.showCompletedTask || !task.isFinish))
.each((obj: RepeatItem<TaskViewModel>) => {
TaskItem({
task: obj.item,
deleteTask: () => this.taskList.removeTask(obj.item)
}).margin(5)
})
}
}
```
```typescript
// src/main/ets/view/BottomView.ets
import { common, Want } from '@kit.AbilityKit';
import TaskViewModel from '../viewmodel/TaskViewModel';
import TaskListViewModel from '../viewmodel/TaskListViewModel';
@Builder export function ActionButton(text: string, onClick:() => void) {
Button(text, { buttonStyle: ButtonStyleMode.NORMAL })
.onClick(onClick)
.margin({ left: 10, right: 10, top: 5, bottom: 5 })
}
@ComponentV2
export default struct BottomView {
@Param taskList: TaskListViewModel = new TaskListViewModel();
@Local newTaskName: string = '';
private context = getContext() as common.UIAbilityContext;
build() {
Column() {
Row() {
ActionButton('全部完成', (): void => this.taskList.finishAll(true))
ActionButton('全部未完成', (): void => this.taskList.finishAll(false))
ActionButton('设置', (): void => {
let wantInfo: Want = {
deviceId: '', // deviceId为空表示本设备
bundleName: 'com.samples.statemgmtv2mvvm', // 替换成AppScope/app.json5里的bundleName
abilityName: 'SettingAbility',
};
this.context.startAbility(wantInfo);
})
}
.margin({ top: 10, bottom: 5 })
Row() {
TextInput({ placeholder: '添加新任务', text: this.newTaskName })
.onChange((value) => this.newTaskName = value)
.width('70%')
ActionButton('+', (): void => {
let newTask = new TaskViewModel();
newTask.taskName = this.newTaskName;
this.taskList.addTask(newTask);
this.newTaskName = '';
})
}
}
}
}
```
```typescript
// src/main/ets/pages/TodoListPage.ets
import TaskListViewModel from '../viewmodel/TaskListViewModel';
import { common } from '@kit.AbilityKit';
import { AppStorageV2, PersistenceV2 } from '@kit.ArkUI';
import { Setting } from '../pages/SettingPage';
import TitleView from '../view/TitleView';
import ListView from '../view/ListView';
import BottomView from '../view/BottomView';
@Entry
@ComponentV2
struct TodoList {
@Local taskList: TaskListViewModel = PersistenceV2.connect(TaskListViewModel, 'TaskList', () => new TaskListViewModel())!;
@Local setting: Setting = AppStorageV2.connect(Setting, 'Setting', () => new Setting())!;
private context = getContext(this) as common.UIAbilityContext;
async aboutToAppear() {
this.taskList = PersistenceV2.connect(TaskListViewModel, 'TaskList', () => new TaskListViewModel())!;
if (this.taskList.tasks.length === 0) {
await this.taskList.loadTasks(this.context);
}
}
@Computed
get tasksUnfinished(): number {
return this.taskList.tasks.filter(task => !task.isFinish).length;
}
build() {
Column() {
TitleView({ tasksUnfinished: this.tasksUnfinished })
ListView({ taskList: this.taskList, setting: this.setting });
BottomView({ taskList: this.taskList });
}
.height('100%')
.width('100%')
.alignItems(HorizontalAlign.Start)
.margin({ left: 15 })
}
}
```
```typescript
// src/main/ets/pages/SettingPage.ets
import { AppStorageV2 } from '@kit.ArkUI';
import { common } from '@kit.AbilityKit';
@ObservedV2
export class Setting {
@Trace showCompletedTask: boolean = true;
}
@Entry
@ComponentV2
struct SettingPage {
@Local setting: Setting = AppStorageV2.connect(Setting, 'Setting', () => new Setting())!;
private context = getContext(this) as common.UIAbilityContext;
build(){
Column(){
Text('设置')
.fontSize(40)
.margin({ bottom: 10 })
Row() {
Text('显示已完成任务');
Toggle({ type: ToggleType.Switch, isOn:this.setting.showCompletedTask })
.onChange((isOn) => {
this.setting.showCompletedTask = isOn;
})
}
Button('返回待办')
.onClick(()=>this.context.terminateSelf())
.margin({ top: 10 })
}
.alignItems(HorizontalAlign.Start)
}
}
```
总结
本教程通过一个简单的待办事项应用示例，逐步引入了状态管理V2装饰器，并通过代码重构实现了MVVM架构。最终，将数据、逻辑和视图分层，使得代码结构更加清晰、易于维护。合理地使用Model、View和ViewModel，可以帮助开发者实现高效的数据与UI同步，简化开发流程并降低复杂性。希望通过这个示例，开发者能够更好地理解MVVM模式，并能将其灵活应用到自己项目的开发中，从而提高开发效率和代码质量。
代码示例
完整源码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/v1v2-migration
爬取时间: 2025-04-28 07:01:38
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-custom-component-mixed-scenarios
爬取时间: 2025-04-28 07:01:51
来源: Huawei Developer
在@Component装饰的自定义组件中（后续称V1的自定义组件），我们为开发者提供了与之对应的状态变量装饰器（后续称V1的装饰器），例如：@State、@Prop、@Link等，然而状态管理V1（简称V1）对于嵌套类的观测存在诸多限制，例如需要开发者通过@ObjectLink不断拆解嵌套类才能使得深层次数据具备观测能力。为此，在API12中为开发者提供了一套全新的状态管理V2（简称V2），开发者可以声明@ComponentV2装饰的自定义组件（后续称V2的自定义组件）并搭配一套全新的装饰器去使用（后续称V2的装饰器），如：@Local、@Param等。V2的提出不仅解决了V1对于嵌套类观测的先天性不足，同时对部分装饰器功能进行加强，如V2的@Monitor对比V1的@Watch不仅能感知变化后的数据，还能够获取变化之前的数据。
在设计上，我们希望V1和V2的代码是完全隔离的，因为V1能实现的功能，V2能做的更好。但从实际角度出发，V1的开发者已经有很大的基础，让开发者一次性迁移成V2也不符合实际，因此在V1的代码中使用V2的部分能力是允许的，V2中也没有完全禁止V1，这样就涉及到V1和V2的一个混用问题，例如：V1的自定义组件使用了V2的自定义组件或V1去使用V2的装饰器等。
本篇通过对V1、V2之间的混用场景进行较为完善的阐述，旨在指引开发者将V1代码向V2代码迁移。
状态管理V2从API version 12开始支持。
概述
状态管理V1与V2的混用规则可以概括为：
-  V1的自定义组件中不可以使用V2的装饰器，否则编译报错。
-  组件间不存在变量传递时，V1的自定义组件中可以使用V2的自定义组件，包括import第三方@ComponentV2装饰的自定义组件。
-  组件间存在变量传递时，V1的变量传递给V2的自定义组件，有如下限制：
-  V2的自定义组件中不可以使用V1的装饰器，否则编译报错。
-  组件间不存在变量传递时，V2自定义组件可以使用V1的自定义组件，包括import第三方@Component装饰的自定义组件。
-  组件间存在变量传递时，V2的变量传递给V1的自定义组件，有如下限制：
状态管理装饰器总览
状态管理V1的装饰器
| 装饰器类别 | 装饰器 |
| --- | --- |
| 组件内装饰器 | @State、@Prop、@Link、@ObjectLink、@Provide、@Consume、@StorageProp、@StorageLink、@LocalStorageProp、@LocalStorageLink、@Watch |
| 类相关装饰器 | @Observed、@Track |
状态管理V2的装饰器
| 装饰器类别 | 装饰器 |
| --- | --- |
| 组件内装饰器 | @Local、@Param、@Provider、@Consumer、@Once、@Event、@Monitor、@Computed |
| 类相关装饰器 | @ObservedV2、@Trace、@Type |
状态管理装饰器支持的数据类型总览
状态管理能够支持的数据类型有：
| 数据类型 | 关键字 |
| --- | --- |
| 简单类型数据 | boolean、number、enum、string、null、undefined |
| function类型 | function(仅V2的@Event、@Monitor、@Computed支持) |
| Object类型 | Object |
| Class类型 | Class |
| 内置类型 | Array、Map、Set、Date |
限制条件
V1和V2的装饰器不允许混用
1.V1的自定义组件中不可以使用V2的装饰器
```typescript
@Component
struct Child {
// @Param不可以在@Component中使用，编译报错
// @Once @Require都是@Param的能力扩展装饰器，必须和@Param一起连用
@Param message: string = "";
@Event changeMessage: (val: string) => void;  // @Event 不可以在@Component中使用，编译报错
build() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.changeMessage('world hello');
})
}
}
}
@Entry
@Component
struct Index {
@Local message: string = 'Hello World'; // @Local不可以在 @Component中使用，编译报错
build() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Divider()
.color(Color.Blue)
Child({
message: this.message,
changeMessage: (val: string) => {
this.message = val;
}
})
}
.height('100%')
.width('100%')
}
}
```
V2的组件内装饰器不允许在V1的自定义组件中使用，编译会报错。
@Local、@Param、@Event，@Provider、@Consumer、@Monitor、@Computed和示例代码中的装饰器表现一致。
2.V2的自定义组件中不可以使用V1的装饰器
```typescript
@ComponentV2
struct Child {
@Prop message: string = "";      // @Prop不可以在@ComponentV2中使用，编译报错
@Link myId: number;           // @Link不可以在@ComponentV2中使用，编译报错
build() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world hello';
})
Divider()
.color(Color.Blue)
Text(`${this.myId}`)
.id('HelloWorld')
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.myId++;
})
}
}
}
@Entry
@ComponentV2
struct Index {
@State message: string = 'Hello World';      // @State不可以在@ComponentV2中使用，编译报错
@State @Watch('idChange') myId: number = 1;  // @Watch不可以在@ComponentV2中使用，编译报错
idChange(propName: number) : void {
console.info(`id changed ${this.myId}`);
}
build() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Divider()
.color(Color.Blue)
Child({
message: this.message,
myId: this.myId
})
}
.height('100%')
.width('100%')
.margin(5)
}
}
```
V1的组件内装饰器不允许在V2的自定义组件中使用，编译会报错。
@ObjectLink、@Provide、@Consume、@StorageProp、@StorageLink、@LocalStorageProp、@LocalStorageLink和示例的装饰器表现一致。
多个装饰器不允许装饰同一个变量（@Watch、@Once、@Require除外）
```typescript
@Component
struct Child {
@State @Prop message: string = "";    // 多个V1的装饰器不可以修饰同一个变量，编译器报错
build() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world hello';
})
}
}
}
@Entry
@ComponentV2
struct Index {
@Local @Param message: string = 'Hello World'; // 多个V2的装饰器不允许修饰同一个变量，编译器报错
build() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Divider()
.color(Color.Blue)
Child({
message: this.message
})
}
.height('100%')
.width('100%')
}
}
```
除了@Watch、@Once、@Require这些能力扩展装饰器可以配合其他装饰器使用外，其他装饰器不允许装饰同一个变量。
混用场景介绍
V1和V2类相关装饰器混用
1.V1的自定义组件中使用被@ObservedV2装饰的类对象
```typescript
@ObservedV2
class Info {
@Trace myId: number;           // 有观测能力
name: string;                   // 无观测能力
@Track trackId: number = 1;     // @Track作为V1的装饰器，不能在@ObservedV2中使用，编译时报错；消除编译错误请去掉@Track
constructor(id?: number, name?: string) {
this.myId = id || 0;
this.name = name || 'aaa';
}
}
@Observed
class message extends Info {    // 继承自@ObservedV2装饰的类不可以被Observed装饰，编译时报错；消除编译错误请去掉@Observed
}
class MessageInfo extends Info {
}
@Entry
@Component
struct Index {
info1: Info = new Info();                      // @ObservedV2装饰的Class可以在V1中使用，且被@Trace装饰的类属性具有观测能力
@State info2: Info = new Info();               // @ObservedV2装饰的Class不可以被V1的装饰器装饰，否则编译器报错；消除编译错误请去掉@State
@State messageInfo: MessageInfo = new MessageInfo();  // 继承自@ObservedV2的Class不可以被V1装饰器装饰，运行时报错；消除错误请去掉@State
build() {
Column() {
Text(`info1 name: ${this.info1.name}`)            // name未被@Trace装饰，无法观察变化
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.info1.name += 'b';
})
Text(`info1 id: ${this.info1.myId}`)              // myId被@Trace装饰，可观察变化
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.info1.myId += 1;
})
Divider()
.color(Color.Blue)
Text(`info2 id: ${this.info2.myId}`)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.info2.myId += 1;
})
Divider()
.color(Color.Blue)
Text(`messageInfo id: ${this.messageInfo.myId}`) // 继承自@ObservedV2的Class被V1的装饰器装饰时会出现crash，运行时出错，需要去掉装饰器@State
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.messageInfo.myId += 1;
})
}
.height('100%')
.width('100%')
.margin(5)
}
}
```
@ObservedV2的使用需要遵循如下规则：
2.V2的自定义组件中使用被@Observed装饰的类对象
```typescript
@Observed
class Info {
@Track myId: number;             // 无观测能力，只能防止因其他属性改变而导致的连带刷新
name: string;                     // 无观测能力
@Trace trackId: number = 1;       // @Trace作为V2的装饰器，不能在@Observed中使用，编译时报错；消除编译错误请去掉@Trace
constructor(id?: number, name?: string) {
this.myId = id || 0;
this.name = name || 'aaa';
}
}
@ObservedV2
class message extends Info {      // @ObservedV2装饰的Class不能继承@Observed，编译时报错；消除编译错误请去掉@ObservedV2
}
class MessageInfo extends Info {
}
@Entry
@ComponentV2
struct Index {
info1: Info = new Info();             // @Observed装饰的Class可以在V2中使用
@Local info2: Info = new Info();      // @Observe装饰的Class不可以被V2的装饰器装饰，否则编译器报错；消除编译错误请去掉@Local
@Local messageInfo: MessageInfo = new MessageInfo();
build() {
Column() {
Text(`info1 name: ${this.info1.name}`)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.info1.name += 'b';
})
Text(`info1 id: ${this.info1.myId}`)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.info1.myId += 1;
})
Divider()
.color(Color.Blue)
Text(`info2 id: ${this.info2.myId}`)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.info2.myId += 1;
})
Divider()
.color(Color.Blue)
// 继承自@ObservedV2的Class被V2装饰器装饰，V2的装饰器无类属性观测能力，所以不建议在V2中使用@Observed装饰的Class
Text(`messageInfo id: ${this.messageInfo.myId}`)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.messageInfo.myId += 1;
})
}
.height('100%')
.width('100%')
.margin(5)
}
}
```
不建议开发者在V2中使用@Observed装饰的Class，因为@Observed和@Track仅能对类属性做区分，无观测能力，使用@Observed和@ObjectLink拆分嵌套数据才能够观测深层次数据，但@ObjectLink无法在V2的自定义组件中使用。
开发者在对V1的代码向V2迁移时，@Observed装饰的Class不建议在@ComponentV2中使用，无观测能力，如果一定要使用，则遵循以下规则：
不存在变量传递时，V1和V2的自定义组件混用
1.V1中使用V2的自定义组件
```typescript
@ComponentV2
struct Child {
@Local message: string = "hello";
build() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world';
})
}
}
}
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world hello';
})
Divider()
.color(Color.Blue)
Child()
}
.height('100%')
.width('100%')
}
}
```
V1中使用V2的自定义组件，当不存在变量传递时无影响，若涉及变量传递，请见下一节V1和V2的数据混用。
2.V2中使用V1的自定义组件
```typescript
@Component
struct Child {
@State message: string = "hello";
build() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world';
})
}
}
}
@Entry
@ComponentV2
struct Index {
@Local message: string = 'Hello World';
build() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world hello';
})
Divider()
.color(Color.Blue)
Child()
}
.height('100%')
.width('100%')
}
}
```
V2中使用V1的自定义组件，当不存在变量传递时无影响，若涉及变量传递，请见下一节V1和V2的数据混用。
存在变量传递时，V1和V2的自定义组件数据混用
1.V1->V2：V1的普通变量传递给V2的自定义组件
```typescript
class Info {
myId: number;
name: string;
constructor(myId?: number, name?: string) {
this.myId = myId || 0;
this.name = name || 'aaa';
}
}
@ComponentV2
struct Child {
// V2对数据输入有严格的管理，从父组件接受数据时，必须@Param装饰器进行数据接收
@Param @Once message: string = "hello";                  // 可以观测到变化，同步回父组件依赖@Event，使用了@Once可以修改@Param装饰的变量
@Param @Once undefinedVal: string | undefined = undefined;  // 使用了@Once可以修改@Param装饰的变量
@Param info: Info = new Info();                         // 观测不到类属性变化
@Require @Param set: Set<number>;
build() {
Column() {
Text(`child message:${this.message}`) // 显示 string
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world';
})
Divider()
.color(Color.Blue)
Text(`undefinedVal:${this.undefinedVal}`) // 显示 undefinedVal
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.undefinedVal = "change to define";
})
Divider()
.color(Color.Blue)
Text(`info id:${this.info.myId}`) // 显示 info:myId
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.info.myId++;
})
Divider()
.color(Color.Blue)
ForEach(Array.from(this.set.values()), (item: number) => {  // 显示 Set
Text(`${item}`)
.fontSize(30)
})
}
.margin(5)
}
}
@Entry
@Component
struct Index {
message: string = 'Hello World';       // 简单数据
undefinedVal: undefined = undefined;    // 简单类型，undefined
info: Info = new Info();               // Class类型
set: Set<number> = new Set([10, 20]);  // 内置 类型
build() {
Column() {
Text(`message:${this.message}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world hello';
})
Divider()
.color(Color.Blue)
Child({
message: this.message,
undefinedVal: this.undefinedVal,
info: this.info,
set: this.set
})
}
.height('100%')
.width('100%')
}
}
```
当V1的普通变量传递给V2的自定义组件时，有如下限制：
2.V1->V2：V1的状态变量传递给V2的自定义组件
```typescript
class Info {
myId: number;
name: string;
constructor(myId?: number, name?: string) {
this.myId = myId || 0;
this.name = name || 'aaa';
}
}
@ComponentV2
struct Child {
// V2对数据输入有严格的管理，从父组件接受数据时，必须@Param装饰器进行数据接收
@Param @Once message: string = "hello";
@Param @Once undefinedVal: string | undefined = undefined;  // 使用了@Once可以修改@Param装饰的变量
@Param info: Info = new Info();
@Require @Param set: Set<number>;
build() {
Column() {
Text(`child message:${this.message}`) // 显示string
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world';
})
Divider()
.color(Color.Blue)
Text(`undefinedVal:${this.undefinedVal}`) // 显示undefinedVal
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.undefinedVal = "change to define";
})
Divider()
.color(Color.Blue)
Text(`info id:${this.info.myId}`) // 显示info:myId
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.info.myId++;
})
Divider()
.color(Color.Blue)
ForEach(Array.from(this.set.values()), (item: number) => {  // 显示Set
Text(`${item}`)
.fontSize(30)
})
}
.margin(5)
}
}
@Entry
@Component
struct Index {
@State message: string = 'Hello World';       // 简单类型数据，支持
@State undefinedVal: undefined = undefined;    // 简单类型数据，undefined，支持
@State info: Info = new Info();               // Class类型，不支持传递，编译器报错；消除编译错误请去掉@State
@State set: Set<number> = new Set([10, 20]);  // 内置类型，不支持传递，编译器报错；消除编译错误请去掉@State
build() {
Column() {
Text(`message:${this.message}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world hello';
})
Divider()
.color(Color.Blue)
Child({
message: this.message,
undefinedVal: this.undefinedVal,
info: this.info,
set: this.set
})
}
.height('100%')
.width('100%')
}
}
```
当V1的状态变量给V2的自定义组件时，有如下规则：
-  仅支持简单类型变量，其余类型数据会在编译时报错。
-  示例中使用了@State装饰器，@Prop、@Link、@ObjectLink、@Provide、@Consume、@StorageProp、@StorageLink、@LocalStorageProp、@LocalStorageLink行为和@State保持一致。
3.V2->V1：V2的普通变量传递给V1的自定义组件
```typescript
class Info {
myId: number;
name: string;
constructor(myId?: number, name?: string) {
this.myId = myId || 0;
this.name = name || 'aaa';
}
}
@Component
struct Child {
// V1从V2接收的状态变量，若使用装饰器，仅可使用@State、@Prop、@Provide接收
@State  message: string = "hello";             // 可以观测到变化
@State info: Info = new Info();                  // 可以观测一层类属性变化
@Prop undefinedVal: undefined | string = undefined;
@Provide setMap: Set<number> = new Set();
build() {
Column() {
Text(`child message:${this.message}`)     // 显示string
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world';
})
Divider()
.color(Color.Blue)
Text(`undefinedVal:${this.undefinedVal}`)     // 显示undefinedVal
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.undefinedVal = "change to define";
})
Divider()
.color(Color.Blue)
Text(`info id:${this.info.myId}`)             // 显示info:myId
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.info.myId++;
})
Divider()
.color(Color.Blue)
ForEach(Array.from(this.setMap.values()), (item: number) => {  // 显示 Set
Text(`${item}`)
.fontSize(30)
})
}
.margin(5)
}
}
@Entry
@ComponentV2
struct Index {
message: string = 'Hello World';       // 简单数据类型
undefinedVal: undefined = undefined;    // 简单数据类型，undefined
info: Info = new Info();               // Class类型
set: Set<number> = new Set([10, 20]);  // 内置 类型
build() {
Column() {
Text(`message:${this.message}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world hello';
})
Divider()
.color(Color.Blue)
Child({
message: this.message,
undefinedVal: this.undefinedVal,
info: this.info,
setMap: this.set
})
}
.height('100%')
.width('100%')
}
}
```
当V2的普通变量传递给V1自定义组件时：
-  V1可以不使用装饰器接收数据，接收过来的变量在V1组定义组件内也会是普通变量。
-  V1若使用装饰器接收数据，仅可通过@State、@Prop、@Provide接收。
4.V2->V1：V2的状态变量传递给V1的自定义组件
```typescript
class Info {
myId: number;
name: string;
constructor(myId?: number, name?: string) {
this.myId = myId || 0;
this.name = name || 'aaa';
}
}
@Component
struct Child {
// V1从V2接收的状态变量，仅可使用@State、@Prop、@Provide接收
@State  message: string = "hello";            // 可以观测到变化
@State info: Info = new Info();                // 可以观测一层类属性变化
@Prop undefinedVal: undefined | string = undefined;
@Provide set: Set<number> = new Set();
build() {
Column() {
Text(`child message:${this.message}`)     // 显示 string
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world';
})
Divider()
.color(Color.Blue)
Text(`undefinedVal:${this.undefinedVal}`)     // 显示 undefinedVal
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.undefinedVal = "change to define";
})
Divider()
.color(Color.Blue)
Text(`info id:${this.info.myId}`)     // 显示 info:myId
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.info.myId++;
})
Divider()
.color(Color.Blue)
ForEach(Array.from(this.set.values()), (item: number) => {  // 显示 Set
Text(`${item}`)
.fontSize(30)
})
}
.margin(5)
}
}
@Entry
@ComponentV2
struct Index {
@Local message: string = 'Hello World';           // 简单数据类型，支持传递
@Provider() undefinedVal: undefined = undefined;   // 简单数据类型，undefined，支持传递
@Consumer() info: Info = new Info();              // Class类型，支持传递
@Param set: Set<number> = new Set([10, 20]);      // 内置类型，不支持传递；消除编译错误请去掉@Param
build() {
Column() {
Text(`message:${this.message}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'world hello';
})
Divider()
.color(Color.Blue)
Child({
message: this.message,
undefinedVal: this.undefinedVal,
info: this.info,
set: this.set
})
}
.height('100%')
.width('100%')
}
}
```
V2的状态变量传递给V1的自定义组件，存在如下限制：
-  V1可以不使用装饰器接收数据，接收过来的变量在V1组定义组件内也会是普通变量。
-  V1若使用装饰器接收数据，仅可通过@State、@Prop、@Provide接收。
-  V1若使用装饰器接收数据，不支持内置类型的数据。
混用场景总结
通过对V1和V2的混用场景详细梳理，可以看到，当V2的代码混用V1的代码时，即V1的组件或者类数据向V2进行传递，大部分V1的能力在V2都是被禁止的。而V1的代码去混用V2代码时，即V2的组件或者类数据向V1传递，做了部分功能开放，例如@ObservedV2和@Trace，这也是对V1嵌套类数据的观测能提供的最大的帮助。所以在代码开发时，不鼓励开发者使用V1和V2进行混用开发，但是对于代码迁移上，可以让V1的开发者逐步将代码向V2进行迁移，从而稳步替换V1的功能代码，并且十分不鼓励开发者在V2的代码架构上混用V1的代码。
补充场景
@Observed和@ObservedV2由于装饰Class类型，而Class可以进行多层级的嵌套，因此场景相对复杂，本节主要是对Class类型的自嵌套和内置类型的嵌套作一个详细的场景说明。由于@Observed并没有@ObservedV2+@Trace那样强大的深层次观测能力，不再对@Observed的深层次嵌套进行讨论，只讨论@ObservedV2在V1的使用场景。
使用@Observed+@ObjectLink观测嵌套类
```typescript
@Observed
class Info {
myId: number;
name: string;
constructor(myId?: number, name?: string) {
this.myId = myId || 0;
this.name = name || 'aaa';
}
}
@Observed
class MessageInfo {         // 一层嵌套
@Track info: Info;        // 防止messageId改变导致info的连带刷新
@Track messageId: number; // 防止messageId改变导致info的连带刷新
constructor(info?: Info, messageId?: number) {
this.info = info || new Info();
this.messageId = messageId || 0;
}
}
@Observed
class MessageInfoNested {     // 二层嵌套
messageInfo: MessageInfo;
constructor(messageInfo?: MessageInfo) {
this.messageInfo = messageInfo || new MessageInfo();
}
}
@Component
struct GrandSon {
@ObjectLink info: Info;
build() {
Column() {
Text(`ObjectLink info info.myId:${this.info.myId}`)  // 经过@ObjectLink拆解两次之后，观测到变化
.fontSize(30)
.onClick(() => {
this.info.myId++;
})
}
}
}
@Component
struct Child {
@ObjectLink messageInfo: MessageInfo;
build() {
Column() {
Text(`ObjectLink MessageInfo messageId:${this.messageInfo.messageId}`)  // 经过@ObjectLink拆解之后，可以观测一层类属性变化
.fontSize(30)
.onClick(() => {
this.messageInfo.messageId++;
})
Divider()
.color(Color.Blue)
Text(`ObjectLink MessageInfo info.myId:${this.messageInfo.info.myId}`)  // 经过@ObjectLink拆解之后，依旧观测不到变化
.fontSize(30)
.onClick(() => {
this.messageInfo.info.myId++;
})
GrandSon({info: this.messageInfo.info});                // 继续拆解一层子组件
}
}
}
@Entry
@Component
struct Index {
@State messageInfoNested: MessageInfoNested = new MessageInfoNested();  // 三层嵌套的数据，需要对所有数据进行观测。
build() {
Column() {
// 观察messageInfoNested
Text(`messageInfoNested messageId:${this.messageInfoNested.messageInfo.messageId}`)  // @State只有一层类属性观测能力，无法观察到变化
.fontSize(30)
.onClick(() => {
this.messageInfoNested.messageInfo.messageId++;
})
Divider()
.color(Color.Blue)
// 通过@ObjectLink嵌套观察 messageInfoId
Child({messageInfo: this.messageInfoNested.messageInfo})      // 经过拆分后，使用@ObjectLink拆分可以观察到深一层的变化
Divider()
.color(Color.Blue)
}
.height('100%')
.width('100%')
.margin(10)
}
}
```
示例给出了一个三层嵌套的场景，可以看到：
使用@ObsevedV2+@Trace观测嵌套类
```typescript
@ObservedV2
class Info {
@Trace myId: number;
name: string;
constructor(myId?: number, name?: string) {
this.myId = myId || 0;
this.name = name || 'aaa';
}
}
@Observed
class MessageInfo { // 一层嵌套
@Track info: Info;        // 防止messageId改变导致info的连带刷新
@Track messageId: number; // 防止messageId改变导致info的连带刷新
constructor(info?: Info, messageId?: number) {
this.info = info || new Info();   // 使用传入的info或创建一个新的Info
this.messageId = messageId || 0;
}
}
@Observed
class MessageInfoNested { // 二层嵌套，MessageInfoNested如果是被@ObservedV2装饰，则不可以被V1的状态变量更新相关的装饰器装饰，如@State
messageInfo: MessageInfo;
constructor(messageInfo?: MessageInfo) {
this.messageInfo = messageInfo || new MessageInfo();
}
}
@Component
struct Child {
@ObjectLink messageInfo: MessageInfo;
build() {
Column() {
Text(`ObjectLink MessageInfo messageId:${this.messageInfo.messageId}`)  // 经过@ObjectLink拆解之后，可以观测一层类属性变化
.fontSize(30)
.onClick(() => {
this.messageInfo.messageId++;
})
}
}
}
@Entry
@Component
struct Index {
@State messageInfoNested: MessageInfoNested = new MessageInfoNested();  // 三层嵌套的数据，如何观测内部。
build() {
Column() {
// 观察messageInfoNested，@State只有一层观测能力，无法观察到变化
Text(`messageInfoNested messageId:${this.messageInfoNested.messageInfo.messageId}`)
.fontSize(30)
.onClick(() => {
this.messageInfoNested.messageInfo.messageId++;
})
Divider()
.color(Color.Blue)
Text(`messageInfoNested name:${this.messageInfoNested.messageInfo.info.name}`)   // 未被@Trace修饰，无法观测
.fontSize(30)
.onClick(() => {
this.messageInfoNested.messageInfo.info.name += 'a';
})
Divider()
.color(Color.Blue)
Text(`messageInfoNested myId:${this.messageInfoNested.messageInfo.info.myId}`)   // 被@Trace修饰，无论嵌套多少层都能观测
.fontSize(30)
.onClick(() => {
this.messageInfoNested.messageInfo.info.myId++;
})
Divider()
.color(Color.Blue)
// 通过@ObjectLink嵌套观察 messageInfoId
Child({messageInfo: this.messageInfoNested.messageInfo})      // 经过拆分后，使用@ObjectLink拆分可以观察到深一层的变化
}
.height('100%')
.width('100%')
.margin(10)
}
}
```
当使用@ObservedV2 + @Trace可以发现：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-v1-v2-migration
爬取时间: 2025-04-28 07:02:46
来源: Huawei Developer
概述
ArkUI状态管理的主要职责是：负责将可观察数据的变化自动同步到UI界面，实现数据驱动的UI刷新，使开发者能更加够专注于UI界面的实现和设计。
在状态管理框架的演进过程中，先后推出了状态管理V1和V2两个版本。V1强调组件层级的状态管理，而V2则增强了对数据对象的深度观察与管理能力，不再局限于组件层级。通过V2，开发者能够更灵活地控制数据和状态，实现更高效的UI刷新。具体V1和V2的区别可以参见状态管理概述。
V1V2使用指引
迁移指南的目的
V1V2能力对比及迁移简表
| V1装饰器名 | V2装饰器名 | 说明 |
| --- | --- | --- |
| @Observed | @ObservedV2 |  表明当前对象为可观察对象。但两者能力并不相同。 @Observed可观察第一层的属性，需要搭配@ObjectLink使用才能生效。 @ObservedV2本身无观察能力，仅代表当前class可被观察，如果要观察其属性，需要搭配@Trace使用。 |
| @Track | @Trace |  V1装饰器@Track为精确观察，不使用则无法做到类属性的精准观察。 V2@Trace装饰的属性可以被精确跟踪观察。 |
| @Component | @ComponentV2 |  @Component为搭配V1状态变量使用的自定义组件装饰器。 @ComponentV2为搭配V2状态变量使用的自定义组件装饰器。 |
| @State |  无外部初始化：@Local 外部初始化一次：@Param@Once | @State和@Local类似都是数据源的概念，在不需要外部传入初始化时，可直接迁移。如果需要外部传入初始化，则可以迁移为@Param@Once，详情见@State->@Local。 |
| @Prop | @Param | @Prop和@Param类似都是自定义组件参数的概念。当输入参数为复杂类型时，@Prop为深拷贝，@Param为引用。 |
| @Link | @Param@Event | @Link是框架自己封装实现的双向同步，对于V2开发者可以通过@Param@Event自己实现双向同步。 |
| @ObjectLink | @Param | 直接兼容，@ObjectLink需要被@Observed装饰的class的实例初始化，@Param没有此限制。 |
| @Provide | @Provider | 兼容。 |
| @Consume | @Consumer | 兼容。 |
| @Watch | @Monitor |  @Watch用于监听V1状态变量的变化，具有监听状态变量本身和其第一层属性变化的能力。状态变量可观察到的变化会触发其@Watch监听事件。 @Monitor用于监听V2状态变量的变化，搭配@Trace使用，可有深层监听的能力。状态变量在一次事件中多次变化时，仅会以最终的结果判断是否触发@Monitor监听事件。 |
| LocalStorage | 全局@ObservedV2@Trace | 兼容。 |
| AppStorage | AppStorageV2 | 兼容。 |
| Environment | 调用Ability接口获取系统环境变量 | Environment获取环境变量能力和AppStorage耦合。在V2中可直接调用Ability接口获取系统环境变量。 |
| PersistentStorage | PersistenceV2 | PersistentStorage持久化能力和AppStorage耦合，PersistenceV2持久化能力可独立使用。 |
表明当前对象为可观察对象。但两者能力并不相同。
@Observed可观察第一层的属性，需要搭配@ObjectLink使用才能生效。
@ObservedV2本身无观察能力，仅代表当前class可被观察，如果要观察其属性，需要搭配@Trace使用。
V1装饰器@Track为精确观察，不使用则无法做到类属性的精准观察。
V2@Trace装饰的属性可以被精确跟踪观察。
@Component为搭配V1状态变量使用的自定义组件装饰器。
@ComponentV2为搭配V2状态变量使用的自定义组件装饰器。
无外部初始化：@Local
外部初始化一次：@Param@Once
@Watch用于监听V1状态变量的变化，具有监听状态变量本身和其第一层属性变化的能力。状态变量可观察到的变化会触发其@Watch监听事件。
@Monitor用于监听V2状态变量的变化，搭配@Trace使用，可有深层监听的能力。状态变量在一次事件中多次变化时，仅会以最终的结果判断是否触发@Monitor监听事件。
各装饰器迁移示例
@State->@Local
迁移规则
在V1中，@State装饰器用于装饰组件内部的状态变量，在V2中提供了@Local作为其替代能力，但两者在观察能力和初始化规则上存在明显差异。针对不同的使用场景，迁移策略如下：
示例
简单类型
对于简单类型变量，V1的@State可以直接替换为V2的@Local。
V1：
```typescript
@Entry
@Component
struct Child {
@State val: number = 10;
build(){
Text(this.val.toString())
}
}
```
V2迁移策略：直接替换。
```typescript
@Entry
@ComponentV2
struct Child {
@Local val: number = 10;
build(){
Text(this.val.toString())
}
}
```
复杂类型
V1的@State能够观察复杂对象的第一层属性变化，但V2的@Local无法观察对象内部变化。为了解决这个问题，需要在类上添加@ObservedV2，并在需要观察的属性上添加@Trace。这样，框架就能追踪对象内部的属性变化。
V1：
```typescript
class Child {
value: number = 10;
}
@Component
@Entry
struct example {
@State child: Child = new Child();
build(){
Column() {
Text(this.child.value.toString())
// @State可以观察第一层变化
Button('value+1')
.onClick(() => {
this.child.value++;
})
}
}
}
```
V2迁移策略：使用@ObservedV2和@Trace。
```typescript
@ObservedV2
class Child {
@Trace public value: number = 10;
}
@ComponentV2
@Entry
struct example {
@Local child: Child = new Child();
build(){
Column() {
Text(this.child.value.toString())
// @Local只能观察自身，需要给Child加上@ObservedV2和@Trace
Button('value+1')
.onClick(() => {
this.child.value++;
})
}
}
}
```
外部初始化状态变量
V1的@State变量可以从外部初始化，V2的@Local禁止外部初始化。为实现类似功能，需要用@Param和@Once代替@State，允许外部传入初始值，并确保该值只初始化时同步一次。
V1实现：
```typescript
@Component
struct Child {
@State value: number = 0;
build() {
Text(this.value.toString())
}
}
@Entry
@Component
struct Parent {
build() {
Column(){
// @State可以从外部初始化
Child({ value: 30 })
}
}
}
```
V2迁移策略：使用@Param和@Once。
```typescript
@ComponentV2
struct Child {
@Param @Once value: number = 0;
build() {
Text(this.value.toString())
}
}
@Entry
@ComponentV2
struct Parent {
build() {
Column(){
// @Local禁止从外部初始化，可以用@Param和@Once替代实现
Child({ value: 30 })
}
}
}
```
@Link -> @Param/@Event
迁移规则
在V1中，@Link允许父组件和子组件之间进行双向数据绑定。迁移到V2时，可以用@Param和@Event模拟双向同步。@Param实现父到子的单向传递，子组件再通过@Event回调函数触发父组件的状态更新。
示例
V1实现：
```typescript
@Component
struct Child {
// @Link可以双向同步数据
@Link val: number;
build() {
Column(){
Text("child: " + this.val.toString())
Button("+1")
.onClick(() => {
this.val++;
})
}
}
}
@Entry
@Component
struct Parent {
@State myVal: number = 10;
build() {
Column(){
Text("parent: " + this.myVal.toString())
Child({val: this.myVal})
}
}
}
```
V2迁移策略：使用@Param和@Event
```typescript
@ComponentV2
struct Child {
// @Param搭配@Event回调实现数据双向同步
@Param val: number  = 0;
@Event addOne: () => void;
build() {
Column(){
Text("child: " + this.val.toString())
Button("+1")
.onClick(()=> {
this.addOne();
})
}
}
}
@Entry
@ComponentV2
struct Parent {
@Local myVal: number = 10
build() {
Column() {
Text("parent: " + this.myVal.toString())
Child({ val: this.myVal, addOne: () => this.myVal++})
}
}
}
```
@Prop -> @Param
迁移规则
在V1中，@Prop装饰器用于从父组件传递参数给子组件，这些参数在子组件中可以被直接修改。在V2中，@Param取代了@Prop的作用，但@Param是只读的，子组件不能直接修改参数的值。因此，根据场景的不同，有几种迁移策略：
示例
简单类型
对于简单类型变量，V1的@Prop可以直接替换为V2的@Param。
V1实现：
```typescript
@Component
struct Child {
@Prop value: number;
build() {
Text(this.value.toString())
}
}
@Entry
@Component
struct Parent {
build() {
Column(){
Child({ value: 30 })
}
}
}
```
V2迁移策略：直接替换
```typescript
@ComponentV2
struct Child {
@Param value: number = 0;
build() {
Text(this.value.toString())
}
}
@Entry
@ComponentV2
struct Parent {
build() {
Column(){
Child({ value: 30 })
}
}
}
```
复杂类型的单向数据传递
在V2中，传递复杂类型时，如果希望实现严格的单向数据绑定，防止子组件修改父组件的数据，需要在使用@Param传递复杂对象时进行深拷贝以避免传递对象的引用。
V1实现：
```typescript
class Fruit {
apple: number = 5;
orange: number = 10;
}
@Component
struct Child {
// @Prop传递Fruit类，当子类修改属性，父类不受影响
@Prop fruit: Fruit;
build() {
Column() {
Text("child apple: "+ this.fruit.apple.toString())
Text("child orange: "+ this.fruit.orange.toString())
Button("apple+1")
.onClick(() => {
this.fruit.apple++;
})
Button("orange+1")
.onClick(() => {
this.fruit.orange++;
})
}
}
}
@Entry
@Component
struct Parent {
@State parentFruit: Fruit = new Fruit();
build() {
Column(){
Text("parent apple: "+this.parentFruit.apple.toString())
Text("parent orange: "+this.parentFruit.orange.toString())
Child({ fruit: this.parentFruit })
}
}
}
```
​
V2迁移策略：使用深拷贝
```typescript
@ObservedV2
class Fruit{
@Trace apple: number = 5;
@Trace orange: number = 10;
// 实现深拷贝，子组件不会修改父组件的数据
clone(): Fruit {
let newFruit: Fruit = new Fruit();
newFruit.apple = this.apple;
newFruit.orange = this.orange;
return newFruit;
}
}
@ComponentV2
struct Child {
@Param fruit: Fruit = new Fruit();
build() {
Column() {
Text("child")
Text(this.fruit.apple.toString())
Text(this.fruit.orange.toString())
Button("apple+1")
.onClick( ()=> {
this.fruit.apple++;
})
Button("orange+1")
.onClick(() => {
this.fruit.orange++;
})
}
}
}
@Entry
@ComponentV2
struct Parent {
@Local parentFruit: Fruit = new Fruit();
build() {
Column(){
Text("parent")
Text(this.parentFruit.apple.toString())
Text(this.parentFruit.orange.toString())
Child({ fruit: this.parentFruit.clone()})
}
}
}
```
子组件修改变量
在V1中，子组件可以修改@Prop的变量，然而在V2中，@Param是只读的。如果子组件需要修改传入的值，可以使用@Param和@Once允许子组件在本地修改。
V1实现：
```typescript
@Component
struct Child {
// @Prop可以直接修改变量值
@Prop value: number;
build() {
Column(){
Text(this.value.toString())
Button("+1")
.onClick(()=> {
this.value++;
})
}
}
}
@Entry
@Component
struct Parent {
build() {
Column(){
Child({ value: 30 })
}
}
}
```
V2迁移策略：使用@Param和@Once
```typescript
@ComponentV2
struct Child {
// @Param搭配@Once使用，可以在本地修改@Param变量
@Param @Once value: number = 0;
build() {
Column(){
Text(this.value.toString())
Button("+1")
.onClick(() => {
this.value++;
})
}
}
}
@Entry
@ComponentV2
struct Parent {
build() {
Column(){
Child({ value: 30 })
}
}
}
```
在V1中，子组件可以修改@Prop的变量，且只会在本地更新，不会同步回父组件。父组件数据源更新时，会通知子组件更新，并覆写子组件本地@Prop的值。
V1：
```typescript
@Component
struct Child {
@Prop localValue: number = 0;
build() {
Column() {
Text(`${this.localValue}`).fontSize(25)
Button('Child +100')
.onClick(() => {
// 改变localValue不会传递给父组件Parent
this.localValue += 100;
})
}
}
}
@Entry
@Component
struct Parent {
@State value: number = 10;
build() {
Column() {
Button('Parent +1')
.onClick(() => {
// 改变value的值，通知子组件Child value更新
this.value += 1;
})
Child({ localValue: this.value })
}
}
}
```
V2中，@Param本地不可写，和@Once搭配使用只会同步一次。如果要实现子组件本地可写，且父组件后续更新还是能通知子组件，可以借助@Monitor来实现这一效果。
V2实现：
```typescript
@ComponentV2
struct Child {
@Local localValue: number = 0;
@Param value: number = 0;
@Monitor('value')
onValueChange(mon: IMonitor) {
console.info(`value has been changed from ${mon.value()?.before} to ${mon.value()?.now}`);
// 父组件value变化时，通知子组件value更新，回调Monitor函数，将更新的值覆写给本地的localValue
this.localValue = this.value;
}
build() {
Column() {
Text(`${this.localValue}`).fontSize(25)
Button('Child +100')
.onClick(() => {
// 改变localValue不会传递给父组件Parent
this.localValue += 100;
})
}
}
}
@Entry
@ComponentV2
struct Parent {
@Local value: number = 10;
build() {
Column() {
Button('Parent +1')
.onClick(() => {
// 改变value的值，通知子组件Child value更新
this.value += 1;
})
Child({ value: this.value })
}
}
}
```
@ObjectLink/@Observed/@Track -> @ObservedV2/@Trace
迁移规则
在V1中，@Observed与@ObjectLink装饰器用于观察类对象及其嵌套属性的变化，但V1只能直接观察对象的第一层属性。对于嵌套对象的属性，必须通过自定义组件和@ObjectLink实现观察。此外，V1中提供了@Track装饰器来实现对属性级别变化的精确控制。
在V2中，@ObservedV2与@Trace结合使用，可以高效地实现类对象及其嵌套属性的深度观察，省去了对自定义组件的依赖，简化了开发流程。同时，@Trace装饰器还具备精确更新的能力，替代了V1中的@Track，从而实现更高效的UI刷新控制。根据不同的场景，有以下迁移策略：
示例
嵌套对象属性观察方法
在V1中，无法直接观察嵌套对象的属性变化，只能观察到第一层属性的变化。必须通过创建自定义组件并使用@ObjectLink来实现对嵌套属性的观察。V2中使用@ObservedV2和@Trace，可以直接对嵌套对象的属性进行深度观察，减少复杂度。
V1实现：
```typescript
@Observed
class Address {
city: string;
constructor(city: string) {
this.city = city;
}
}
@Observed
class User {
name: string;
address: Address;
constructor(name: string, address: Address) {
this.name = name;
this.address = address;
}
}
@Component
struct AddressView {
// 子组件中@ObjectLink装饰的address从父组件初始化，接收被@Observed装饰的Address实例
@ObjectLink address: Address;
build() {
Column() {
Text(`City: ${this.address.city}`)
Button("city +a")
.onClick(() => {
this.address.city += "a";
})
}
}
}
@Entry
@Component
struct UserProfile {
@State user: User = new User("Alice", new Address("New York"));
build() {
Column() {
Text(`Name: ${this.user.name}`)
// 无法直接观察嵌套对象的属性变化，例如this.user.address.city
// 只能观察到对象第一层属性变化，所以需要将嵌套的对象Address抽取到自定义组件AddressView
AddressView({ address: this.user.address })
}
}
}
```
V2迁移策略：使用@ObservedV2和@Trace
```typescript
@ObservedV2
class Address {
@Trace city: string;
constructor(city: string) {
this.city = city;
}
}
@ObservedV2
class User {
@Trace name: string;
@Trace address: Address;
constructor(name: string, address: Address) {
this.name = name;
this.address = address;
}
}
@Entry
@ComponentV2
struct UserProfile {
@Local user: User = new User("Alice", new Address("New York"));
build() {
Column() {
Text(`Name: ${this.user.name}`)
// 通过@ObservedV2和@Trace可以直接观察嵌套属性
Text(`City: ${this.user.address.city}`)
Button("city +a")
.onClick(() => {
this.user.address.city += "a";
})
}
}
}
```
类属性变化观测
在V1中，@Observed用于观察类实例及其属性的变化，@Track则用于对属性级别的变化优化，使得只有被@Track装饰的属性触发UI更新。在V2中，@Trace结合了观察和更新属性级别变化的能力，搭配@ObservedV2实现高效的UI更新。
V1实现：
```typescript
@Observed
class User {
@Track name: string;
@Track age: number;
constructor(name: string, age: number) {
this.name = name;
this.age = age;
}
}
@Entry
@Component
struct UserProfile {
@State user: User = new User('Alice', 30);
build() {
Column() {
Text(`Name: ${this.user.name}`)
Text(`Age: ${this.user.age}`)
Button("increase age")
.onClick(() => {
this.user.age++;
})
}
}
}
```
V2迁移策略：使用@ObservedV2和@Trace
```typescript
@ObservedV2
class User {
@Trace name: string;
@Trace age: number;
constructor(name: string, age: number) {
this.name = name;
this.age = age;
}
}
@Entry
@ComponentV2
struct UserProfile {
@Local user: User = new User('Alice', 30);
build() {
Column() {
Text(`Name: ${this.user.name}`)
Text(`Age: ${this.user.age}`)
Button("Increase age")
.onClick(() => {
this.user.age++;
})
}
}
}
```
@Provide/@Consume -> @Provider/@Consumer
迁移规则
V1的@Provide/@Consume和V2@Provider/@Consumer定位和作用大体类似，基本可以实现丝滑替换，但是有以下细微差距，开发者可根据自己代码实现来参考是否需要调整：
在V1中，@Provide和@Consume用于父子组件之间的数据共享，可以通过alias（别名）或属性名匹配，同时@Consume必须依赖父组件的@Provide，不允许本地初始化。而V2中，@Provider和@Consumer增强了这些特性，使数据共享更加灵活。根据不同的场景，有以下迁移策略：
示例
alias和属性名匹配规则
在V1中，@Provide和@Consume的匹配既可以通过alias，也可以通过属性名。在V2中，alias成为唯一的key，如果在@Consumer中制定了alias，只能通过alias而非属性名进行匹配。
V1实现:
```typescript
@Component
struct Child {
// alias和属性名都为key，alias和属性名都可以匹配
@Consume('text') childMessage: string;
@Consume message: string;
build(){
Column(){
Text(this.childMessage)
Text(this.message) // Text是Hello World
}
}
}
@Entry
@Component
struct Parent {
@Provide('text') message: string = "Hello World";
build(){
Column(){
Child()
}
}
}
```
V2迁移策略：确保alias一致，没有指定alias的情况下，依赖属性名进行匹配
```typescript
@ComponentV2
struct Child {
// alias是唯一匹配的key，有alias情况下无法通过属性名匹配
@Consumer('text') childMessage: string = "default";
@Consumer() message: string = "default";
build(){
Column(){
Text(this.childMessage)
Text(this.message) // Text是default
}
}
}
@Entry
@ComponentV2
struct Parent {
@Provider('text') message: string = "Hello World";
build(){
Column(){
Child()
}
}
}
```
V1的@Consume不支持本地初始化，V2支持
V1中，@Consume不允许本地初始化变量，必须依赖父组件的@Provide，否则会抛出异常。迁移到V2后，@Consumer允许本地初始化，当找不到对应的@Provider，会使用本地默认值。
V1实现：
```typescript
@Component
struct Child {
// @Consume禁止本地初始化，当找不到对应的@Provide时抛出异常
@Consume message: string;
build(){
Text(this.message)
}
}
@Entry
@Component
struct Parent {
@Provide message: string = "Hello World";
build(){
Column(){
Child()
}
}
}
```
V2迁移策略：@Consumer可以本地初始化
```typescript
@ComponentV2
struct Child {
// @Consumer允许本地初始化，当找不到@Provider的时候使用本地默认值
@Consumer() message: string = "Hello World";
build(){
Text(this.message)
}
}
@Entry
@ComponentV2
struct Parent {
build(){
Column(){
Child()
}
}
}
```
V1的@Provide可以从父组件初始化，V2不支持
在V1中，@Provide允许从父组件初始化，可以直接通过组件参数传递初始值。在V2中，@Provider禁止从外部初始化。为实现相同功能，可以在子组件中使用@Param @Once接受初始值，然后将其赋值给@Provider变量。
V1实现：
```typescript
@Entry
@Component
struct Parent {
@State parentValue: number = 42;
build() {
Column() {
// @Provide可以从父组件初始化
Child({ childValue: this.parentValue })
}
}
}
@Component
struct Child {
@Provide childValue: number = 0;
build(){
Column(){
Text(this.childValue.toString())
}
}
}
```
V2迁移策略：使用@Param接受初始值，再赋值给@Provider
```typescript
@Entry
@ComponentV2
struct Parent {
@Local parentValue: number = 42;
build() {
Column() {
// @Provider禁止从父组件初始化，替代方案为先用@Param接受，再赋值给@Provider
Child({ initialValue: this.parentValue })
}
}
}
@ComponentV2
struct Child {
@Param @Once initialValue: number = 0;
@Provider() childValue: number = this.initialValue;
build() {
Column(){
Text(this.childValue.toString())
}
}
}
```
V1的@Provide默认不支持重载，V2默认支持
在V1中，@Provide默认不支持重载，无法覆盖上层组件的同名@Provide。若需支持重载，必须设置allowOverride。在V2中，@Provider默认支持重载，@Consumer会向上查找最近的@Provider，无需额外设置。
V1实现:
```typescript
@Entry
@Component
struct GrandParent {
@Provide("reviewVotes") reviewVotes: number = 40;
build() {
Column(){
Parent()
}
}
}
@Component
struct Parent {
// @Provide默认不支持重载，支持重载需设置allowOverride函数
@Provide({ allowOverride: "reviewVotes" }) reviewVotes: number = 20;
build() {
Child()
}
}
@Component
struct Child {
@Consume("reviewVotes") reviewVotes: number;
build() {
Text(this.reviewVotes.toString()) // Text显示20
}
}
```
V2迁移策略：去掉allowOverride
```typescript
@Entry
@ComponentV2
struct GrandParent {
@Provider("reviewVotes") reviewVotes: number = 40;
build() {
Column(){
Parent()
}
}
}
@ComponentV2
struct Parent {
// @Provider默认支持重载，@Consumer向上查找最近的@Provider
@Provider() reviewVotes: number = 20;
build() {
Child()
}
}
@ComponentV2
struct Child {
@Consumer() reviewVotes: number = 0;
build() {
Text(this.reviewVotes.toString()) // Text显示20
}
}
```
@Watch -> @Monitor
迁移规则
在V1中，@Watch用于监听状态变量的变化，并在变量变化时触发指定回调函数。在V2中，@Monitor替代了@Watch，可以更灵活地监听变量的变化，并获取变量变化前后的值。具体的迁移策略如下：
示例
单变量监听
对于简单案例，V1的@Watch可以直接替换为替换为V2的@Monitor。
V1实现：
```typescript
@Entry
@Component
struct watchExample {
@State @Watch('onAppleChange') apple: number = 0;
onAppleChange(): void {
console.log("apple count changed to "+this.apple);
}
build() {
Column(){
Text(`apple count: ${this.apple}`)
Button("add apple")
.onClick(() => {
this.apple++;
})
}
}
}
```
V2迁移策略：直接替换
```typescript
@Entry
@ComponentV2
struct monitorExample {
@Local apple: number = 0;
@Monitor('apple')
onFruitChange(monitor: IMonitor) {
console.log(`apple changed from ${monitor.value()?.before} to ${monitor.value()?.now}`);
}
build() {
Column(){
Text(`apple count: ${this.apple}`)
Button("add apple")
.onClick(()=> {
this.apple++;
})
}
}
}
```
多变量监听
在V1中，每个@Watch回调函数只能监听一个变量，且无法获取变化前的值。迁移到V2后，可以使用一个@Monitor同时监听多个变量以及获取监听变量的变化前后的值。
V1实现：
```typescript
@Entry
@Component
struct watchExample {
@State @Watch('onAppleChange') apple: number = 0;
@State @Watch('onOrangeChange') orange: number = 0;
// @Watch 回调，只能监听单个变量，不能获取变化前的值
onAppleChange(): void {
console.log("apple count changed to "+this.apple);
}
onOrangeChange(): void {
console.log("orange count changed to "+this.orange);
}
build() {
Column(){
Text(`apple count: ${this.apple}`)
Text(`orange count: ${this.orange}`)
Button("add apple")
.onClick(() => {
this.apple++;
})
Button("add orange")
.onClick(() => {
this.orange++;
})
}
}
}
```
V2迁移策略：同时监听多个变量，以及获取变化前的值
```typescript
@Entry
@ComponentV2
struct monitorExample {
@Local apple: number = 0;
@Local orange: number = 0;
// @Monitor回调，支持监听多个变量，可以获取变化前的值
@Monitor('apple','orange')
onFruitChange(monitor: IMonitor) {
monitor.dirty.forEach((name: string) => {
console.log(`${name} changed from ${monitor.value(name)?.before} to ${monitor.value(name)?.now}`);
});
}
build() {
Column() {
Text(`apple count: ${this.apple}`)
Text(`orange count: ${this.orange}`)
Button("add apple")
.onClick(() => {
this.apple++;
})
Button("add orange")
.onClick(() => {
this.orange++;
})
}
}
}
```
@Computed
迁移规则
V1中并没有提供计算属性的概念，所以对于UI中的冗余计算，并没有办法可以减少重复计算。V2针对该场景，提供了@Computed装饰器，可以帮助开发者减少重复计算。
V1：
在下面的例子中，每次改变lastName都会触发Text组件的刷新，每次Text组件的刷新，都需要重复计算this.lastName + ' ' + this.firstName。
V2:
使用V2中的@Computed，每次改变lastName仅会触发一次计算。
LocalStorage->全局@ObservedV2/@Trace
迁移规则
LocalStorage的目的是为了实现页面间的状态变量共享。之所以提供这个能力，是因为V1状态变量和View层耦合，无法由开发者自主地实现页面间状态变量的共享。
对于状态管理V2，状态变量的观察能力内嵌到数据本身，不再和View层耦合，所以对于状态管理V2，不再需要类似LocalStorage的能力，可以使用全局@ObservedV2/@Trace，由开发者自己import和export，自己实现状态变量的页面间共享。
示例
基本场景
V1:
通过windowStage.loadContent和getShared接口实现页面间的状态变量共享。
```typescript
// EntryAbility.ets
import { UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
export default class EntryAbility extends UIAbility {
para:Record<string, number> = { 'count': 47 };
storage: LocalStorage = new LocalStorage(this.para);
onWindowStageCreate(windowStage: window.WindowStage): void {
windowStage.loadContent('pages/Page1', this.storage);
}
}
```
在下面的示例中，使用@LocalStorageLink，可以使得开发者本地的修改同步回LocalStorage中。
```typescript
// Page2.ets
@Builder
export function Page2Builder() {
Page2()
}
// Page2组件获得了父亲Page1组件的LocalStorage实例
@Component
struct Page2 {
@LocalStorageLink('count') count: number = 0;
pathStack: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Text(`${this.count}`)
.fontSize(50)
.onClick(() => {
this.count++;
})
}
}
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack;
})
}
}
```
使用Navigation时，需要添加配置系统路由表文件src/main/resources/base/profile/route_map.json，并替换pageSourceFile为Page2页面的路径，并且在module.json5中添加："routerMap": "$profile:route_map"。
```json
{
"routerMap": [
{
"name": "Page2",
"pageSourceFile": "src/main/ets/pages/Page2.ets",
"buildFunction": "Page2Builder",
"data": {
"description" : "LocalStorage example"
}
}
]
}
```
V2:
```typescript
// storage.ets
@ObservedV2
export class MyStorage {
static singleton_: MyStorage;
static instance() {
if(!MyStorage.singleton_) {
MyStorage.singleton_ = new MyStorage();
};
return MyStorage.singleton_;
}
@Trace count: number = 47;
}
```
```typescript
// Page1.ets
import { MyStorage } from './storage';
@Entry
@ComponentV2
struct Page1 {
storage: MyStorage = MyStorage.instance();
pageStack: NavPathStack = new NavPathStack();
build() {
Navigation(this.pageStack) {
Column() {
Text(`${this.storage.count}`)
.fontSize(50)
.onClick(() => {
this.storage.count++;
})
Button('push to Page2')
.onClick(() => {
this.pageStack.pushPathByName('Page2', null);
})
}
}
}
}
```
```typescript
// Page2.ets
import { MyStorage } from './storage';
@Builder
export function Page2Builder() {
Page2()
}
@ComponentV2
struct Page2 {
storage: MyStorage = MyStorage.instance();
pathStack: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Text(`${this.storage.count}`)
.fontSize(50)
.onClick(() => {
this.storage.count++;
})
}
}
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack;
})
}
}
```
使用Navigation时，需要添加配置系统路由表文件src/main/resources/base/profile/route_map.json，并替换pageSourceFile为Page2页面的路径，并且在module.json5中添加："routerMap": "$profile:route_map"。
```json
{
"routerMap": [
{
"name": "Page2",
"pageSourceFile": "src/main/ets/pages/Page2.ets",
"buildFunction": "Page2Builder",
"data": {
"description" : "LocalStorage example"
}
}
]
}
```
如果开发者需要实现类似于@LocalStorageProp的效果，希望本地的修改不要同步回LocalStorage中，如以下示例:
```typescript
// Page1.ets
export let storage: LocalStorage = new LocalStorage();
storage.setOrCreate('count', 47);
@Entry(storage)
@Component
struct Page1 {
@LocalStorageProp('count') count: number = 0;
pageStack: NavPathStack = new NavPathStack();
build() {
Navigation(this.pageStack) {
Column() {
Text(`${this.count}`)
.fontSize(50)
.onClick(() => {
this.count++;
})
Button('change Storage Count')
.onClick(() => {
storage.setOrCreate('count', storage.get<number>('count') as number + 100);
})
Button('push to Page2')
.onClick(() => {
this.pageStack.pushPathByName('Page2', null);
})
}
}
}
}
```
```typescript
// Page2.ets
import { storage } from './Page1'
@Builder
export function Page2Builder() {
Page2()
}
// Page2组件获得了父亲Page1组件的LocalStorage实例
@Component
struct Page2 {
@LocalStorageProp('count') count: number = 0;
pathStack: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Text(`${this.count}`)
.fontSize(50)
.onClick(() => {
this.count++;
})
Button('change Storage Count')
.onClick(() => {
storage.setOrCreate('count', storage.get<number>('count') as number + 100);
})
}
}
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack;
})
}
}
```
在V2中，可以借助@Local和@Monitor实现类似的效果。
```typescript
// Page1.ets
import { MyStorage } from './storage';
@Entry
@ComponentV2
struct Page1 {
storage: MyStorage = MyStorage.instance();
pageStack: NavPathStack = new NavPathStack();
@Local count: number = this.storage.count;
@Monitor('storage.count')
onCountChange(mon: IMonitor) {
console.log(`Page1 ${mon.value()?.before} to ${mon.value()?.now}`);
this.count = this.storage.count;
}
build() {
Navigation(this.pageStack) {
Column() {
Text(`${this.count}`)
.fontSize(50)
.onClick(() => {
this.count++;
})
Button('change Storage Count')
.onClick(() => {
this.storage.count += 100;
})
Button('push to Page2')
.onClick(() => {
this.pageStack.pushPathByName('Page2', null);
})
}
}
}
}
```
```typescript
// Page2.ets
import { MyStorage } from './storage';
@Builder
export function Page2Builder() {
Page2()
}
@ComponentV2
struct Page2 {
storage: MyStorage = MyStorage.instance();
pathStack: NavPathStack = new NavPathStack();
@Local count: number = this.storage.count;
@Monitor('storage.count')
onCountChange(mon: IMonitor) {
console.log(`Page2 ${mon.value()?.before} to ${mon.value()?.now}`);
this.count = this.storage.count;
}
build() {
NavDestination() {
Column() {
Text(`${this.count}`)
.fontSize(50)
.onClick(() => {
this.count++;
})
Button('change Storage Count')
.onClick(() => {
this.storage.count += 100;
})
}
}
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack;
})
}
}
```
自定义组件接收LocalStorage实例场景
为了配合Navigation的场景，LocalStorage支持作为自定义组件的入参，传递给以当前自定义组件为根节点的所有子自定义组件。
对于该场景，V2可以采用多个全局@ObservedV2/@Trace实例来替代。
V1:
```typescript
let localStorageA: LocalStorage = new LocalStorage();
localStorageA.setOrCreate('PropA', 'PropA');
let localStorageB: LocalStorage = new LocalStorage();
localStorageB.setOrCreate('PropB', 'PropB');
let localStorageC: LocalStorage = new LocalStorage();
localStorageC.setOrCreate('PropC', 'PropC');
@Entry
@Component
struct MyNavigationTestStack {
@Provide('pageInfo') pageInfo: NavPathStack = new NavPathStack();
@Builder
PageMap(name: string) {
if (name === 'pageOne') {
// 传递不同的LocalStorage实例
pageOneStack({}, localStorageA)
} else if (name === 'pageTwo') {
pageTwoStack({}, localStorageB)
} else if (name === 'pageThree') {
pageThreeStack({}, localStorageC)
}
}
build() {
Column({ space: 5 }) {
Navigation(this.pageInfo) {
Column() {
Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
this.pageInfo.pushPath({ name: 'pageOne' }); //将name指定的NavDestination页面信息入栈
})
}
}.title('NavIndex')
.navDestination(this.PageMap)
.mode(NavigationMode.Stack)
.borderWidth(1)
}
}
}
@Component
struct pageOneStack {
@Consume('pageInfo') pageInfo: NavPathStack;
@LocalStorageLink('PropA') PropA: string = 'Hello World';
build() {
NavDestination() {
Column() {
// 显示'PropA'
NavigationContentMsgStack()
// 显示'PropA'
Text(`${this.PropA}`)
Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
this.pageInfo.pushPathByName('pageTwo', null);
})
}.width('100%').height('100%')
}.title('pageOne')
.onBackPressed(() => {
this.pageInfo.pop();
return true;
})
}
}
@Component
struct pageTwoStack {
@Consume('pageInfo') pageInfo: NavPathStack;
@LocalStorageLink('PropB') PropB: string = 'Hello World';
build() {
NavDestination() {
Column() {
// 显示'Hello'，当前LocalStorage实例localStorageB没有PropA对应的值，使用本地默认值'Hello'
NavigationContentMsgStack()
// 显示'PropB'
Text(`${this.PropB}`)
Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
this.pageInfo.pushPathByName('pageThree', null);
})
}.width('100%').height('100%')
}.title('pageTwo')
.onBackPressed(() => {
this.pageInfo.pop();
return true;
})
}
}
@Component
struct pageThreeStack {
@Consume('pageInfo') pageInfo: NavPathStack;
@LocalStorageLink('PropC') PropC: string = 'pageThreeStack';
build() {
NavDestination() {
Column() {
// 显示'Hello'，当前LocalStorage实例localStorageC没有PropA对应的值，使用本地默认值'Hello'
NavigationContentMsgStack()
// 显示'PropC'
Text(`${this.PropC}`)
Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
this.pageInfo.pushPathByName('pageOne', null);
})
}.width('100%').height('100%')
}.title('pageThree')
.onBackPressed(() => {
this.pageInfo.pop();
return true;
})
}
}
@Component
struct NavigationContentMsgStack {
@LocalStorageLink('PropA') PropA: string = 'Hello';
build() {
Column() {
Text(`${this.PropA}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
}
}
```
V2：
声明@ObservedV2装饰的class代替LocalStorage。其中LocalStorage的key可以用@Trace装饰的属性代替。
```typescript
// storage.ets
@ObservedV2
export class MyStorageA {
@Trace propA: string = 'Hello';
constructor(propA?: string) {
this.propA = propA? propA : this.propA;
}
}
@ObservedV2
export class MyStorageB extends MyStorageA {
@Trace propB: string = 'Hello';
constructor(propB: string) {
super();
this.propB = propB;
}
}
@ObservedV2
export class MyStorageC extends MyStorageA {
@Trace propC: string = 'Hello';
constructor(propC: string) {
super();
this.propC = propC;
}
}
```
在pageOneStack、pageTwoStack和pageThreeStack组件内分别创建MyStorageA、MyStorageB、MyStorageC的实例，并通过@Param传递给其子组件NavigationContentMsgStack，从而实现类似LocalStorage实例在子组件树上共享的能力。
```typescript
// Index.ets
import { MyStorageA, MyStorageB, MyStorageC } from './storage';
@Entry
@ComponentV2
struct MyNavigationTestStack {
pageInfo: NavPathStack = new NavPathStack();
@Builder
PageMap(name: string) {
if (name === 'pageOne') {
pageOneStack()
} else if (name === 'pageTwo') {
pageTwoStack()
} else if (name === 'pageThree') {
pageThreeStack()
}
}
build() {
Column({ space: 5 }) {
Navigation(this.pageInfo) {
Column() {
Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
this.pageInfo.pushPath({ name: 'pageOne' }); //将name指定的NavDestination页面信息入栈
})
}
}.title('NavIndex')
.navDestination(this.PageMap)
.mode(NavigationMode.Stack)
.borderWidth(1)
}
}
}
@ComponentV2
struct pageOneStack {
pageInfo: NavPathStack = new NavPathStack();
@Local storageA: MyStorageA = new MyStorageA('PropA');
build() {
NavDestination() {
Column() {
// 显示'PropA'
NavigationContentMsgStack({storage: this.storageA})
// 显示'PropA'
Text(`${this.storageA.propA}`)
Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
this.pageInfo.pushPathByName('pageTwo', null);
})
}.width('100%').height('100%')
}.title('pageOne')
.onBackPressed(() => {
this.pageInfo.pop();
return true;
})
.onReady((context: NavDestinationContext) => {
this.pageInfo = context.pathStack;
})
}
}
@ComponentV2
struct pageTwoStack {
pageInfo: NavPathStack = new NavPathStack();
@Local storageB: MyStorageB = new MyStorageB('PropB');
build() {
NavDestination() {
Column() {
// 显示'Hello'
NavigationContentMsgStack({ storage: this.storageB })
// 显示'PropB'
Text(`${this.storageB.propB}`)
Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
this.pageInfo.pushPathByName('pageThree', null);
})
}.width('100%').height('100%')
}.title('pageTwo')
.onBackPressed(() => {
this.pageInfo.pop();
return true;
})
.onReady((context: NavDestinationContext) => {
this.pageInfo = context.pathStack;
})
}
}
@ComponentV2
struct pageThreeStack {
pageInfo: NavPathStack = new NavPathStack();
@Local storageC: MyStorageC = new MyStorageC("PropC");
build() {
NavDestination() {
Column() {
// 显示'Hello'
NavigationContentMsgStack({ storage: this.storageC })
// 显示'PropC'
Text(`${this.storageC.propC}`)
Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
this.pageInfo.pushPathByName('pageOne', null);
})
}.width('100%').height('100%')
}.title('pageThree')
.onBackPressed(() => {
this.pageInfo.pop();
return true;
})
.onReady((context: NavDestinationContext) => {
this.pageInfo = context.pathStack;
})
}
}
@ComponentV2
struct NavigationContentMsgStack {
@Require@Param storage: MyStorageA;
build() {
Column() {
Text(`${this.storage.propA}`)
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
}
}
```
AppStorage->AppStorageV2
上一小节中，对于全局的@ObserveV2/@Trace的改造并不适合跨Ability的数据共享，该场景可以使用AppStorageV2来替换。
V1:
AppStorage是和应用进程绑定了，可以跨Ability实现数据共享。
在下面的示例中，使用@StorageLink，可以使得开发者本地的修改同步回AppStorage中。
```typescript
// EntryAbility Index.ets
import { common, Want } from '@kit.AbilityKit';
@Entry
@Component
struct Index {
@StorageLink('count') count: number = 0;
private context: common.UIAbilityContext= getContext(this) as common.UIAbilityContext;
build() {
Column() {
Text(`EntryAbility count: ${this.count}`)
.fontSize(50)
.onClick(() => {
this.count++;
})
Button('Jump to EntryAbility1').onClick(() => {
let wantInfo: Want = {
bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName
abilityName: 'EntryAbility1'
};
this.context.startAbility(wantInfo);
})
}
}
}
```
```typescript
// EntryAbility1 Index1.ets
import { common, Want } from '@kit.AbilityKit';
@Entry
@Component
struct Index1 {
@StorageLink('count') count: number = 0;
private context: common.UIAbilityContext= getContext(this) as common.UIAbilityContext;
build() {
Column() {
Text(`EntryAbility1 count: ${this.count}`)
.fontSize(50)
.onClick(() => {
this.count++;
})
Button('Jump to EntryAbility').onClick(() => {
let wantInfo: Want = {
bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName
abilityName: 'EntryAbility'
};
this.context.startAbility(wantInfo);
})
}
}
}
```
V2:
可以使用AppStorageV2实现跨Ability共享。
如下面示例：
```typescript
import { common, Want } from '@kit.AbilityKit';
import { AppStorageV2 } from '@kit.ArkUI';
@ObservedV2
export class MyStorage {
@Trace count: number = 0
}
@Entry
@ComponentV2
struct Index {
@Local storage: MyStorage = AppStorageV2.connect(MyStorage, 'storage', () => new MyStorage())!;
private context: common.UIAbilityContext= getContext(this) as common.UIAbilityContext;
build() {
Column() {
Text(`EntryAbility1 count: ${this.storage.count}`)
.fontSize(50)
.onClick(() => {
this.storage.count++;
})
Button('Jump to EntryAbility1').onClick(() => {
let wantInfo: Want = {
bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName
abilityName: 'EntryAbility1'
};
this.context.startAbility(wantInfo);
})
}
}
}
```
```typescript
import { common, Want } from '@kit.AbilityKit';
import { AppStorageV2 } from '@kit.ArkUI';
@ObservedV2
export class MyStorage {
@Trace count: number = 0
}
@Entry
@ComponentV2
struct Index1 {
@Local storage: MyStorage = AppStorageV2.connect(MyStorage, 'storage', () => new MyStorage())!;
private context: common.UIAbilityContext= getContext(this) as common.UIAbilityContext;
build() {
Column() {
Text(`EntryAbility1 count: ${this.storage.count}`)
.fontSize(50)
.onClick(() => {
this.storage.count++;
})
Button('Jump to EntryAbility').onClick(() => {
let wantInfo: Want = {
bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName
abilityName: 'EntryAbility'
};
this.context.startAbility(wantInfo);
})
}
}
}
```
如果开发者需要实现类似于@StorageProp的效果，希望本地的修改不要同步回AppStorage中，而AppStorage的变化又可以通知给使用@StorageProp装饰器的组件，可以参考以下示例对比。
V1：
```typescript
// EntryAbility Index.ets
import { common, Want } from '@kit.AbilityKit';
@Entry
@Component
struct Index {
@StorageProp('count') count: number = 0;
private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
build() {
Column() {
Text(`EntryAbility count: ${this.count}`)
.fontSize(25)
.onClick(() => {
this.count++;
})
Button('change Storage Count')
.onClick(() => {
AppStorage.setOrCreate('count', AppStorage.get<number>('count') as number + 100);
})
Button('Jump to EntryAbility1').onClick(() => {
let wantInfo: Want = {
bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName
abilityName: 'EntryAbility1'
};
this.context.startAbility(wantInfo);
})
}
}
}
```
```typescript
// EntryAbility1 Index1.ets
import { common, Want } from '@kit.AbilityKit';
@Entry
@Component
struct Index1 {
@StorageProp('count') count: number = 0;
private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
build() {
Column() {
Text(`EntryAbility1 count: ${this.count}`)
.fontSize(50)
.onClick(() => {
this.count++;
})
Button('change Storage Count')
.onClick(() => {
AppStorage.setOrCreate('count', AppStorage.get<number>('count') as number + 100);
})
Button('Jump to EntryAbility').onClick(() => {
let wantInfo: Want = {
bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName
abilityName: 'EntryAbility'
};
this.context.startAbility(wantInfo);
})
}
}
}
```
V2:
开发者可以借助@Monitor和@Local来实现类似的效果，示例如下。
```typescript
import { common, Want } from '@kit.AbilityKit';
import { AppStorageV2 } from '@kit.ArkUI';
@ObservedV2
export class MyStorage {
@Trace count: number = 0;
}
@Entry
@ComponentV2
struct Index {
@Local storage: MyStorage = AppStorageV2.connect(MyStorage, 'storage', () => new MyStorage())!;
@Local count: number = this.storage.count;
private context: common.UIAbilityContext= getContext(this) as common.UIAbilityContext;
@Monitor('storage.count')
onCountChange(mon: IMonitor) {
console.log(`Index1 ${mon.value()?.before} to ${mon.value()?.now}`);
this.count = this.storage.count;
}
build() {
Column() {
Text(`EntryAbility1 count: ${this.count}`)
.fontSize(25)
.onClick(() => {
this.count++;
})
Button('change Storage Count')
.onClick(() => {
this.storage.count += 100;
})
Button('Jump to EntryAbility1').onClick(() => {
let wantInfo: Want = {
bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName
abilityName: 'EntryAbility1'
};
this.context.startAbility(wantInfo);
})
}
}
}
```
```typescript
import { common, Want } from '@kit.AbilityKit';
import { AppStorageV2 } from '@kit.ArkUI';
@ObservedV2
export class MyStorage {
@Trace count: number = 0;
}
@Entry
@ComponentV2
struct Index1 {
@Local storage: MyStorage = AppStorageV2.connect(MyStorage, 'storage', () => new MyStorage())!;
@Local count: number = this.storage.count;
private context: common.UIAbilityContext= getContext(this) as common.UIAbilityContext;
@Monitor('storage.count')
onCountChange(mon: IMonitor) {
console.log(`Index1 ${mon.value()?.before} to ${mon.value()?.now}`);
this.count = this.storage.count;
}
build() {
Column() {
Text(`EntryAbility1 count: ${this.count}`)
.fontSize(25)
.onClick(() => {
this.count++;
})
Button('change Storage Count')
.onClick(() => {
this.storage.count += 100;
})
Button('Jump to EntryAbility').onClick(() => {
let wantInfo: Want = {
bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName
abilityName: 'EntryAbility'
};
this.context.startAbility(wantInfo);
})
}
}
}
```
Environment->调用Ability接口直接获取系统环境变量
V1中，开发者可以通过Environment来获取环境变量，但Environment获取的结果无法直接使用，需要配合AppStorage才能得到对应环境变量的值。
在切换V2的过程中，开发者无需再通过Environment来获取环境变量，可以直接通过UIAbilityContext的config属性获取系统环境变量。
V1:
以languageCode为例。
```typescript
// 将设备languageCode存入AppStorage中
Environment.envProp('languageCode', 'en');
@Entry
@Component
struct Index {
@StorageProp('languageCode') languageCode: string = 'en';
build() {
Row() {
Column() {
// 输出当前设备的languageCode
Text(this.languageCode)
}
}
}
}
```
V2:
封装Env类型来传递多个系统环境变量。
在onCreate里获得需要的系统环境变量：
在页面中获得当前Env的值。
```typescript
// Index.ets
import { env } from '../pages/Env';
@Entry
@ComponentV2
struct Index {
build() {
Row() {
Column() {
// 输出当前设备的环境变量
Text(`languageCode: ${env.language}`).fontSize(20)
Text(`colorMode: ${env.colorMode}`).fontSize(20)
Text(`fontSizeScale: ${env.fontSizeScale}`).fontSize(20)
Text(`fontWeightScale: ${env.fontWeightScale}`).fontSize(20)
}
}
}
}
```
PersistentStorage->PersistenceV2
V1中PersistentStorage提供了持久化UI数据的能力，而V2则提供了更加方便使用的PersistenceV2接口来替代它。
对于PersistenceV2：
V1:
```typescript
PersistentStorage.persistProp('aProp', 47);
@Entry
@Component
struct Index {
@StorageLink('aProp') aProp: number = 48;
build() {
Row() {
Column() {
// 应用退出时会保存当前结果。重新启动后，会显示上一次的保存结果
Text(`${this.aProp}`)
.onClick(() => {
this.aProp += 1;
})
}
}
}
}
```
V2:
下面的案例展示了：
```typescript
import { PersistenceV2 } from '@kit.ArkUI';
// 数据中心
@ObservedV2
class Storage {
@Trace aProp: number = 0;
bProp: number = 10;
}
// 接受序列化失败的回调
PersistenceV2.notifyOnError((key: string, reason: string, msg: string) => {
console.error(`error key: ${key}, reason: ${reason}, message: ${msg}`);
});
@Entry
@ComponentV2
struct Page1 {
// 在PersistenceV2中创建一个key为Sample的键值对（如果存在，则返回PersistenceV2中的数据），并且和prop关联
@Local storage: Storage = PersistenceV2.connect(Storage, () => new Storage())!;
build() {
Column() {
Text(`@Trace aProp: ${this.storage.aProp}`)
.fontSize(30)
.onClick(() => {
this.storage.aProp++;
})
Text(`bProp:: ${this.storage.bProp}`)
.fontSize(30)
.onClick(() => {
// 页面不刷新，但是bProp的值改变了
this.storage.bProp++;
})
Button('save storage')
.onClick(() => {
// 和V1不同，PersistenceV2不依赖状态变量的观察能力，开发者可以主动持久化
PersistenceV2.save(Storage);
})
}
}
}
```
存量迁移场景
对于已经使用V1开发的大型应用，一般不太可能做到一次性的从V1迁移到V2，而是分批次和分组件的部分迁移，这就必然会带来V1和V2的混用。
这种场景，一般是父组件是状态管理V1，而迁移的子组件为状态管理V2。为了模拟这种场景，我们举出下面的示例：
这种情况，我们可以通过以下策略进行迁移：
具体示例如下：
```typescript
let storage: LocalStorage = new LocalStorage();
@ObservedV2
class V1StorageData {
@Trace title: string = 'V1OldComponent'
@Monitor('title')
onStrChange(monitor: IMonitor) {
monitor.dirty.forEach((path: string) => {
console.log(`${path} changed from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`)
if (path === 'title') {
storage.setOrCreate('title', this.title);
}
})
}
}
let v1Data: V1StorageData = new V1StorageData();
@Entry(storage)
@Component
struct V1OldComponent {
@LocalStorageLink('title') title: string = 'V1OldComponent';
build() {
Column() {
Text(`V1OldComponent: ${this.title}`)
.fontSize(20)
.onClick(() => {
this.title = 'new value from V1OldComponent';
})
Bridge()
}
}
}
@Component
struct Bridge {
@LocalStorageLink('title')@Watch('titleWatch') title: string = 'Bridge';
titleWatch() {
v1Data.title = this.title;
}
build() {
NewV2Component()
}
}
@ComponentV2
struct NewV2Component {
build() {
Column() {
Text(`NewV2Component: ${v1Data.title}`)
.fontSize(20)
.onClick(() => {
v1Data.title = 'NewV2Component';
})
}
}
}
```
其他迁移场景
滑动组件
List
开发者可以通过ChildrenMainSize来设置List的子组件在主轴方向的大小信息。
V1：
在状态管理V1中，可以通过@State装饰观察其api调用。
具体示例如下：
```typescript
@Entry
@Component
struct ListExample {
private arr: Array<number> = new Array(10).fill(0);
private scroller: ListScroller = new ListScroller();
@State listSpace: number = 10;
@State listChildrenSize: ChildrenMainSize = new ChildrenMainSize(100);
build() {
Column() {
Button('change Default').onClick(() => {
this.listChildrenSize.childDefaultSize += 10;
})
Button('splice 5').onClick(() => {
this.listChildrenSize.splice(0, 5, [100, 100, 100, 100, 100]);
})
Button('update 5').onClick(() => {
this.listChildrenSize.update(0, 200);
})
List({ space: this.listSpace, scroller: this.scroller }) {
ForEach(this.arr, (item: number) => {
ListItem() {
Text(`item-` + item)
}.backgroundColor(Color.Pink)
})
}
.childrenMainSize(this.listChildrenSize) // 10
}
}
}
```
V2：
但在状态管理V2中，@Local只能观察本身的变化，无法观察第一层的变化，又因为ChildrenMainSize定义在框架中，开发者无法使用@Trace来标注ChildrenMainSize的属性，此时可以使用makeObserved替代。
具体示例如下：
```typescript
import { UIUtils } from '@kit.ArkUI';
@Entry
@ComponentV2
struct ListExample {
private arr: Array<number> = new Array(10).fill(0);
private scroller: ListScroller = new ListScroller();
listSpace: number = 10;
// 使用makeObserved的能力来观测ChildrenMainSize
listChildrenSize: ChildrenMainSize = UIUtils.makeObserved(new ChildrenMainSize(100));
build() {
Column() {
Button('change Default').onClick(() => {
this.listChildrenSize.childDefaultSize += 10;
})
Button('splice 5').onClick(() => {
this.listChildrenSize.splice(0, 5, [100, 100, 100, 100, 100]);
})
Button('update 5').onClick(() => {
this.listChildrenSize.update(0, 200);
})
List({ space: this.listSpace, scroller: this.scroller }) {
ForEach(this.arr, (item: number) => {
ListItem() {
Text(`item-` + item)
}.backgroundColor(Color.Pink)
})
}
.childrenMainSize(this.listChildrenSize) // 10
}
}
}
```
WaterFlow
开发者可以通过WaterFlowSections来设置WaterFlow瀑布流分组信息。
需要注意的是，数组arr的长度需要与WaterFlowSections的中所有SectionOptions的itemsCount的总和保持一致，否则WaterFlow无法处理，导致UI不刷新。
以下两个示例请按照'push option' -> 'splice option' -> 'update option'的顺序进行点击。
V1：
在状态管理V1中，可以通过@State装饰观察其api调用。
具体示例如下：
```typescript
@Entry
@Component
struct WaterFlowSample {
@State colors: Color[] = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Blue, Color.Pink];
@State sections: WaterFlowSections = new WaterFlowSections();
scroller: Scroller = new Scroller();
@State private arr: Array<number> = new Array(9).fill(0);
oneColumnSection: SectionOptions = {
itemsCount: 4,
crossCount: 1,
columnsGap: '5vp',
rowsGap: 10,
};
twoColumnSection: SectionOptions = {
itemsCount: 2,
crossCount: 2,
};
lastSection: SectionOptions = {
itemsCount: 3,
crossCount: 3,
};
aboutToAppear(): void {
let sectionOptions: SectionOptions[] = [this.oneColumnSection, this.twoColumnSection, this.lastSection];
this.sections.splice(0, 0, sectionOptions);
}
build() {
Column() {
Text(`${this.arr.length}`)
Button('push option').onClick(() => {
let section: SectionOptions = {
itemsCount: 1,
crossCount: 1,
};
this.sections.push(section);
this.arr.push(100);
})
Button('splice option').onClick(() => {
let section: SectionOptions = {
itemsCount: 8,
crossCount: 2,
};
this.sections.splice(0, this.arr.length, [section]);
this.arr = new Array(8).fill(10);
})
Button('update option').onClick(() => {
let section: SectionOptions = {
itemsCount: 8,
crossCount: 2,
};
this.sections.update(1, section);
this.arr = new Array(16).fill(1);
})
WaterFlow({ scroller: this.scroller, sections: this.sections }) {
ForEach(this.arr, (item: number) => {
FlowItem() {
Text(`${item}`)
.border({ width: 1 })
.backgroundColor(this.colors[item % 6])
.height(30)
.width(50)
}
})
}
}
}
}
```
V2：
但在状态管理V2中，@Local只能观察本身的变化，无法观察第一层的变化，又因为WaterFlowSections定义在框架中，开发者无法使用@Trace来标注WaterFlowSections的属性，此时可以使用makeObserved替代。
具体示例如下：
```typescript
import { UIUtils } from '@kit.ArkUI';
@Entry
@ComponentV2
struct WaterFlowSample {
colors: Color[] = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Blue, Color.Pink];
// 使用makeObserved的能力来观测WaterFlowSections
sections: WaterFlowSections = UIUtils.makeObserved(new WaterFlowSections());
scroller: Scroller = new Scroller();
@Local private arr: Array<number> = new Array(9).fill(0);
oneColumnSection: SectionOptions = {
itemsCount: 4,
crossCount: 1,
columnsGap: '5vp',
rowsGap: 10,
};
twoColumnSection: SectionOptions = {
itemsCount: 2,
crossCount: 2,
};
lastSection: SectionOptions = {
itemsCount: 3,
crossCount: 3,
};
aboutToAppear(): void {
let sectionOptions: SectionOptions[] = [this.oneColumnSection, this.twoColumnSection, this.lastSection];
this.sections.splice(0, 0, sectionOptions);
}
build() {
Column() {
Text(`${this.arr.length}`)
Button('push option').onClick(() => {
let section: SectionOptions = {
itemsCount: 1,
crossCount: 1,
};
this.sections.push(section);
this.arr.push(100);
})
Button('splice option').onClick(() => {
let section: SectionOptions = {
itemsCount: 8,
crossCount: 2,
};
this.sections.splice(0, this.arr.length, [section]);
this.arr = new Array(8).fill(10);
})
Button('update option').onClick(() => {
let section: SectionOptions = {
itemsCount: 8,
crossCount: 2,
};
this.sections.update(1, section);
this.arr = new Array(16).fill(1);
})
WaterFlow({ scroller: this.scroller, sections: this.sections }) {
ForEach(this.arr, (item: number) => {
FlowItem() {
Text(`${item}`)
.border({ width: 1 })
.backgroundColor(this.colors[item % 6])
.height(30)
.width(50)
}
})
}
}
}
}
```
Modifier
attributeModifier
开发者可以通过attributeModifier动态设置组件的属性方法。
V1：
在状态管理V1中，可以通过@State装饰观察其变化。
具体示例如下：
```typescript
class MyButtonModifier implements AttributeModifier<ButtonAttribute> {
isDark: boolean = false;
applyNormalAttribute(instance: ButtonAttribute): void {
if (this.isDark) {
instance.backgroundColor(Color.Black);
} else {
instance.backgroundColor(Color.Red);
}
}
}
@Entry
@Component
struct AttributeDemo {
@State modifier: MyButtonModifier = new MyButtonModifier();
build() {
Row() {
Column() {
Button('Button')
.attributeModifier(this.modifier)
.onClick(() => {
this.modifier.isDark = !this.modifier.isDark;
})
}
.width('100%')
}
.height('100%')
}
}
```
V2：
但在状态管理V2中，@Local只能观察本身的变化，无法观察第一层的变化，如果要观察attributeModifier的属性变化，可以使用makeObserved替代。
具体示例如下：
```typescript
import { UIUtils } from '@kit.ArkUI';
class MyButtonModifier implements AttributeModifier<ButtonAttribute> {
isDark: boolean = false;
applyNormalAttribute(instance: ButtonAttribute): void {
if (this.isDark) {
instance.backgroundColor(Color.Black);
} else {
instance.backgroundColor(Color.Red);
}
}
}
@Entry
@ComponentV2
struct AttributeDemo {
// 使用makeObserved的能力观测attributeModifier的属性this.modifier
modifier: MyButtonModifier = UIUtils.makeObserved(new MyButtonModifier());
build() {
Row() {
Column() {
Button('Button')
.attributeModifier(this.modifier)
.onClick(() => {
this.modifier.isDark = !this.modifier.isDark;
})
}
.width('100%')
}
.height('100%')
}
}
```
CommonModifier
动态设置组件的属性类。以CommonModifier为例。
V1：
在状态管理V1中，可以通过@State装饰观察其变化。
具体实例如下：
```typescript
import { CommonModifier } from '@ohos.arkui.modifier';
class MyModifier extends CommonModifier {
applyNormalAttribute(instance: CommonAttribute): void {
super.applyNormalAttribute?.(instance);
}
public setGroup1(): void {
this.borderStyle(BorderStyle.Dotted);
this.borderWidth(8);
}
public setGroup2(): void {
this.borderStyle(BorderStyle.Dashed);
this.borderWidth(8);
}
}
@Component
struct MyImage1 {
@Link modifier: CommonModifier;
build() {
// 此处'app.media.app_icon'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。
Image($r('app.media.app_icon'))
.attributeModifier(this.modifier as MyModifier)
}
}
@Entry
@Component
struct Index {
@State myModifier: CommonModifier = new MyModifier().width(100).height(100).margin(10);
index: number = 0;
build() {
Column() {
Button($r('app.string.EntryAbility_label'))
.margin(10)
.onClick(() => {
console.log('Modifier', 'onClick');
this.index++;
if (this.index % 2 === 1) {
(this.myModifier as MyModifier).setGroup1();
console.log('Modifier', 'setGroup1');
} else {
(this.myModifier as MyModifier).setGroup2();
console.log('Modifier', 'setGroup2');
}
})
MyImage1({ modifier: this.myModifier })
}
.width('100%')
}
}
```
V2：
但在状态管理V2中，@Local只能观察本身的变化，无法观察第一层的变化，又因为CommonModifier在框架内是通过其属性触发刷新，此时可以使用makeObserved替代。
具体示例如下：
```typescript
import { UIUtils } from '@kit.ArkUI';
import { CommonModifier } from '@ohos.arkui.modifier';
class MyModifier extends CommonModifier {
applyNormalAttribute(instance: CommonAttribute): void {
super.applyNormalAttribute?.(instance);
}
public setGroup1(): void {
this.borderStyle(BorderStyle.Dotted);
this.borderWidth(8);
}
public setGroup2(): void {
this.borderStyle(BorderStyle.Dashed);
this.borderWidth(8);
}
}
@ComponentV2
struct MyImage1 {
@Param @Require modifier: CommonModifier;
build() {
// 此处'app.media.app_icon'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。
Image($r('app.media.app_icon'))
.attributeModifier(this.modifier as MyModifier)
}
}
@Entry
@ComponentV2
struct Index {
// 使用makeObserved的能力来观测CommonModifier
@Local myModifier: CommonModifier = UIUtils.makeObserved(new MyModifier().width(100).height(100).margin(10));
index: number = 0;
build() {
Column() {
Button($r('app.string.EntryAbility_label'))
.margin(10)
.onClick(() => {
console.log('Modifier', 'onClick');
this.index++;
if (this.index % 2 === 1) {
(this.myModifier as MyModifier).setGroup1();
console.log('Modifier', 'setGroup1');
} else {
(this.myModifier as MyModifier).setGroup2();
console.log('Modifier', 'setGroup2');
}
})
MyImage1({ modifier: this.myModifier })
}
.width('100%')
}
}
```
组件Modfier
动态设置组件的属性类。以Text组件为例。
V1：
在状态管理V1中，可以通过@State装饰观察其变化。
具体示例如下：
```typescript
import { TextModifier } from '@ohos.arkui.modifier';
class MyModifier extends TextModifier {
applyNormalAttribute(instance: TextModifier): void {
super.applyNormalAttribute?.(instance);
}
public setGroup1(): void {
this.fontSize(50);
this.fontColor(Color.Pink);
}
public setGroup2(): void {
this.fontSize(50);
this.fontColor(Color.Gray);
}
}
@Component
struct MyImage1 {
@Link modifier: TextModifier;
index: number = 0;
build() {
Column() {
Text('Test')
.attributeModifier(this.modifier as MyModifier)
Button($r('app.string.EntryAbility_label'))
.margin(10)
.onClick(() => {
console.log('Modifier', 'onClick');
this.index++;
if (this.index % 2 === 1) {
(this.modifier as MyModifier).setGroup1();
console.log('Modifier', 'setGroup1');
} else {
(this.modifier as MyModifier).setGroup2();
console.log('Modifier', 'setGroup2');
}
})
}
}
}
@Entry
@Component
struct Index {
@State myModifier: TextModifier = new MyModifier().width(100).height(100).margin(10);
index: number = 0;
build() {
Column() {
MyImage1({ modifier: this.myModifier })
Button('replace whole')
.margin(10)
.onClick(() => {
this.myModifier = new MyModifier().backgroundColor(Color.Orange);
})
}
.width('100%')
}
}
```
V2：
但在状态管理V2中，@Local只能观察本身的变化，无法观察第一层的变化，此时可以使用makeObserved替代。
具体示例如下：
```typescript
import { UIUtils } from '@kit.ArkUI';
import { TextModifier } from '@ohos.arkui.modifier';
class MyModifier extends TextModifier {
applyNormalAttribute(instance: TextModifier): void {
super.applyNormalAttribute?.(instance);
}
public setGroup1(): void {
this.fontSize(50);
this.fontColor(Color.Pink);
}
public setGroup2(): void {
this.fontSize(50);
this.fontColor(Color.Gray);
}
}
@ComponentV2
struct MyImage1 {
@Param @Require modifier: TextModifier;
index: number = 0;
build() {
Column() {
Text('Test')
.attributeModifier(this.modifier as MyModifier)
Button($r('app.string.EntryAbility_label'))
.margin(10)
.onClick(() => {
console.log('Modifier', 'onClick');
this.index++;
if (this.index % 2 === 1) {
(this.modifier as MyModifier).setGroup1();
console.log('Modifier', 'setGroup1');
} else {
(this.modifier as MyModifier).setGroup2();
console.log('Modifier', 'setGroup2');
}
})
}
}
}
@Entry
@ComponentV2
struct Index {
// 使用makeObserved的能力观测TextModifier
@Local myModifier: TextModifier = UIUtils.makeObserved(new MyModifier().width(100).height(100).margin(10));
index: number = 0;
build() {
Column() {
MyImage1({ modifier: this.myModifier })
Button('replace whole')
.margin(10)
.onClick(() => {
this.myModifier = UIUtils.makeObserved(new MyModifier().backgroundColor(Color.Orange));
})
}
.width('100%')
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control
爬取时间: 2025-04-28 07:03:00
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-overview
爬取时间: 2025-04-28 07:03:13
来源: Huawei Developer
ArkUI通过自定义组件的build()函数和@Builder装饰器中的声明式UI描述语句构建相应的UI。在声明式描述语句中开发者除了使用系统组件外，还可以使用渲染控制语句来辅助UI的构建，这些渲染控制语句包括控制组件是否显示的条件渲染语句，基于数组数据快速生成组件的循环渲染语句，针对大数据量场景的数据懒加载语句，针对混合模式开发的组件渲染语句。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-ifelse
爬取时间: 2025-04-28 07:03:27
来源: Huawei Developer
ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，使用if、else和else if渲染对应状态下的UI内容。
从API version 9开始，该接口支持在ArkTS卡片中使用。
使用规则
-  支持if、else和else if语句。
-  if、else if后跟随的条件语句可以使用状态变量或者常规变量(状态变量：值的改变可以实时渲染UI，常规变量：值的改变不会实时渲染UI)。
-  允许在容器组件内使用，通过条件渲染语句构建不同的子组件。
-  条件渲染语句在涉及到组件的父子关系时是“透明”的，当父组件和子组件之间存在一个或多个if语句时，必须遵守父组件关于子组件使用的规则。
-  每个分支内部的构建函数必须遵循构建函数的规则，并创建一个或多个组件。无法创建组件的空构建函数会产生语法错误。
-  某些容器组件限制子组件的类型或数量，将条件渲染语句用于这些组件内时，这些限制将同样应用于条件渲染语句内创建的组件。例如，Grid容器组件的子组件仅支持GridItem组件，在Grid内使用条件渲染语句时，条件渲染语句内仅允许使用GridItem组件。
更新机制
当if、else if后跟随的状态判断中使用的状态变量值变化时，条件渲染语句会进行更新，更新步骤如下：
1.  评估if和else if的状态判断条件，如果分支没有变化，无需执行以下步骤。如果分支有变化，则执行2、3步骤。
2.  删除此前构建的所有子组件。
3.  执行新分支的构造函数，将获取到的组件添加到if父容器中。如果缺少适用的else分支，则不构建任何内容。
条件可以包括Typescript表达式。对于构造函数中的表达式，此类表达式不得更改应用程序状态。
使用场景
使用if进行条件渲染
```typescript
@Entry
@Component
struct MyComponent {
@State count: number = 0;
build() {
Column() {
Text(`count=${this.count}`)
if (this.count > 0) {
Text(`count is positive`)
.fontColor(Color.Green)
}
Button('increase count')
.onClick(() => {
this.count++;
})
Button('decrease count')
.onClick(() => {
this.count--;
})
}
}
}
```
if语句的每个分支都包含一个构建函数。此类构建函数必须创建一个或多个子组件。在初始渲染时，if语句会执行构建函数，并将生成的子组件添加到其父组件中。
每当if或else if条件语句中使用的状态变量发生变化时，条件语句都会更新并重新评估新的条件值。如果条件值评估发生了变化，这意味着需要构建另一个条件分支。此时ArkUI框架将：
1.  删除所有以前渲染的（早期分支的）组件。
2.  执行新分支的构造函数，将生成的子组件添加到其父组件中。
在以上示例中，如果count从0增加到1，那么if语句更新，条件count > 0将重新评估，评估结果将从false更改为true。因此，将执行条件为真分支的构造函数，创建一个Text组件，并将它添加到父组件Column中。如果后续count更改为0，则Text组件将从Column组件中删除。由于没有else分支，因此不会执行新的构造函数。
if ... else ...语句和子组件状态
以下示例包含if ... else ...语句与拥有@State装饰变量的子组件。
```typescript
@Component
struct CounterView {
@State counter: number = 0;
label: string = 'unknown';
build() {
Column({ space: 20 }) {
Text(`${this.label}`)
Button(`counter ${this.counter} +1`)
.onClick(() => {
this.counter += 1;
})
}
.margin(10)
.padding(10)
.border({ width: 1 })
}
}
@Entry
@Component
struct MainView {
@State toggle: boolean = true;
build() {
Column() {
if (this.toggle) {
CounterView({ label: 'CounterView #positive' })
} else {
CounterView({ label: 'CounterView #negative' })
}
Button(`toggle ${this.toggle}`)
.onClick(() => {
this.toggle = !this.toggle;
})
}
.width('100%')
.justifyContent(FlexAlign.Center)
}
}
```
CounterView（label为 'CounterView #positive'）子组件在初次渲染时创建。此子组件携带名为counter的状态变量。当修改CounterView.counter状态变量时，CounterView（label为 'CounterView #positive'）子组件重新渲染并保留状态变量值。当MainView.toggle状态变量的值更改为false时，MainView父组件内的if语句将更新，随后将删除CounterView（label为 'CounterView #positive'）子组件。与此同时，将创建新的CounterView（label为 'CounterView #negative'）实例。而它自己的counter状态变量设置为初始值0。
CounterView（label为 'CounterView #positive'）和CounterView（label为 'CounterView #negative'）是同一自定义组件的两个不同实例。if分支的更改，不会更新现有子组件，也不会保留状态。
以下示例展示了条件更改时，若需要保留counter值所做的修改。
```typescript
@Component
struct CounterView {
@Link counter: number;
label: string = 'unknown';
build() {
Column({ space: 20 }) {
Text(`${this.label}`)
.fontSize(20)
Button(`counter ${this.counter} +1`)
.onClick(() => {
this.counter += 1;
})
}
.margin(10)
.padding(10)
.border({ width: 1 })
}
}
@Entry
@Component
struct MainView {
@State toggle: boolean = true;
@State counter: number = 0;
build() {
Column() {
if (this.toggle) {
CounterView({ counter: $counter, label: 'CounterView #positive' })
} else {
CounterView({ counter: $counter, label: 'CounterView #negative' })
}
Button(`toggle ${this.toggle}`)
.onClick(() => {
this.toggle = !this.toggle;
})
}
.width('100%')
.justifyContent(FlexAlign.Center)
}
}
```
此处，@State counter变量归父组件所有。因此，当CounterView组件实例被删除时，该变量不会被销毁。CounterView组件通过@Link装饰器引用状态。状态必须从子级移动到其父级（或父级的父级），以避免在条件内容或重复内容被销毁时丢失状态。
嵌套if语句
条件语句的嵌套对父组件的相关规则没有影响。
```typescript
@Entry
@Component
struct MyComponent {
@State toggle: boolean = false;
@State toggleColor: boolean = false;
build() {
Column({ space: 20 }) {
Text('Before')
.fontSize(15)
if (this.toggle) {
Text('Top True, positive 1 top')
.backgroundColor('#aaffaa').fontSize(20)
// 内部if语句
if (this.toggleColor) {
Text('Top True, Nested True, positive COLOR  Nested ')
.backgroundColor('#00aaaa').fontSize(15)
} else {
Text('Top True, Nested False, Negative COLOR  Nested ')
.backgroundColor('#aaaaff').fontSize(15)
}
} else {
Text('Top false, negative top level').fontSize(20)
.backgroundColor('#ffaaaa')
if (this.toggleColor) {
Text('positive COLOR  Nested ')
.backgroundColor('#00aaaa').fontSize(15)
} else {
Text('Negative COLOR  Nested ')
.backgroundColor('#aaaaff').fontSize(15)
}
}
Text('After')
.fontSize(15)
Button('Toggle Outer')
.onClick(() => {
this.toggle = !this.toggle;
})
Button('Toggle Inner')
.onClick(() => {
this.toggleColor = !this.toggleColor;
})
}
.width('100%')
.justifyContent(FlexAlign.Center)
}
}
```
常见问题
动效场景下if分支切换保护失效
在动画当中改变IfElse分支，而这个IfElse是用来做数据保护的，继续使用该分支会导致访问数据异常，然后造成crash。
反例：
```typescript
class MyData {
str: string;
constructor(str: string) {
this.str = str;
}
}
@Entry
@Component
struct Index {
@State data1: MyData|undefined = new MyData("branch 0");
@State data2: MyData|undefined = new MyData("branch 1");
build() {
Column() {
if (this.data1) {
// 如果在动画中增加/删除，会给Text增加默认转场
// 对于删除时，增加默认透明度转场后，会延长组件的生命周期，Text组件没有真正删除，而是等转场动画做完后才删除
Text(this.data1.str)
.id("1")
} else if (this.data2) {
// 如果在动画中增加/删除，会给Text增加默认转场
Text(this.data2.str)
.id("2")
}
Button("play with animation")
.onClick(() => {
animateTo({}, ()=>{
// 在animateTo中修改if条件，在动画当中，会给if下的第一层组件默认转场
if (this.data1) {
this.data1 = undefined;
this.data2 = new MyData("branch 1");
} else {
this.data1 = new MyData("branch 0");
this.data2 = undefined;
}
})
})
Button("play directlp")
.onClick(() => {
// 直接改if条件，不在动画当中，可以正常切换，也不会加默认转场
if (this.data1) {
this.data1 = undefined;
this.data2 = new MyData("branch 1");
} else {
this.data1 = new MyData("branch 0");
this.data2 = undefined;
}
})
}.width("100%")
.padding(10)
}
}
```
正例：
方式1：给数据继续加判空的保护，即在使用data时再加一层判空，即"Text(this.data1?.str)"。
```typescript
class MyData {
str: string;
constructor(str: string) {
this.str = str;
}
}
@Entry
@Component
struct Index {
@State data1: MyData|undefined = new MyData("branch 0");
@State data2: MyData|undefined = new MyData("branch 1");
build() {
Column() {
if (this.data1) {
// 如果在动画中增加/删除，会给Text增加默认转场
// 对于删除时，增加默认透明度转场后，会延长组件的生命周期，Text组件没有真正删除，而是等转场动画做完后才删除
// 在使用数据时再加一层判空保护，如果data1存在才去使用data1当中的str
Text(this.data1?.str)
.id("1")
} else if (this.data2) {
// 如果在动画中增加/删除，会给Text增加默认转场
// 在使用数据时再加一层判空保护
Text(this.data2?.str)
.id("2")
}
Button("play with animation")
.onClick(() => {
animateTo({}, ()=>{
// 在animateTo中修改if条件，在动画当中，会给if下的第一层组件默认转场
if (this.data1) {
this.data1 = undefined;
this.data2 = new MyData("branch 1");
} else {
this.data1 = new MyData("branch 0");
this.data2 = undefined;
}
})
})
}.width("100%")
.padding(10)
}
}
```
方式2：给IfElse下直接要被删除的组件显示的添加transition(TransitionEffect.IDENTITY)属性，避免系统添加默认转场。
```typescript
class MyData {
str: string;
constructor(str: string) {
this.str = str;
}
}
@Entry
@Component
struct Index {
@State data1: MyData|undefined = new MyData("branch 0");
@State data2: MyData|undefined = new MyData("branch 1");
build() {
Column() {
if (this.data1) {
// 在IfElse的根组件显示指定空的转场效果，避免默认转场动画
Text(this.data1.str)
.transition(TransitionEffect.IDENTITY)
.id("1")
} else if (this.data2) {
// 在IfElse的根组件显示指定空的转场效果，避免默认转场动画
Text(this.data2.str)
.transition(TransitionEffect.IDENTITY)
.id("2")
}
Button("play with animation")
.onClick(() => {
animateTo({}, ()=>{
// 在animateTo中修改if条件，在动画当中，会给if下的第一层组件默认转场
// 但由于已经显示指定转场了就不会再添加默认转场
if (this.data1) {
this.data1 = undefined;
this.data2 = new MyData("branch 1");
} else {
this.data1 = new MyData("branch 0");
this.data2 = undefined;
}
})
})
}.width("100%")
.padding(10)
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach
爬取时间: 2025-04-28 07:03:41
来源: Huawei Developer
ForEach接口基于数组类型数据来进行循环渲染，需要与容器组件配合使用，且接口返回的组件应当是允许包含在ForEach父容器组件中的子组件。例如，ListItem组件要求ForEach的父容器组件必须为List组件。
API参数说明见：ForEach API参数说明。
从API version 9开始，该接口支持在ArkTS卡片中使用。
键值生成规则
在ForEach循环渲染过程中，系统会为每个数组元素生成一个唯一且持久的键值，用于标识对应的组件。当这个键值变化时，ArkUI框架将视为该数组元素已被替换或修改，并会基于新的键值创建一个新的组件。
ForEach提供了一个名为keyGenerator的参数，这是一个函数，开发者可以通过它自定义键值的生成规则。如果开发者没有定义keyGenerator函数，则ArkUI框架会使用默认的键值生成函数，即(item: Object, index: number) => { return index + '__' + JSON.stringify(item); }。
ArkUI框架对于ForEach的键值生成有一套特定的判断规则，这主要与itemGenerator函数的第二个参数index以及keyGenerator函数的第二个参数index有关，具体的键值生成规则判断逻辑如下图所示。
图1ForEach键值生成规则
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163835.00659913035959643278513149151451:50001231000000:2800:42827D4151622CFB992D80263F33780F68F4712AA082C756351FA6F64A63745D.png)
ArkUI框架会对重复的键值发出警告。在UI更新的场景下，如果出现重复的键值，框架可能无法正常工作，具体请参见渲染结果非预期。
组件创建规则
在确定键值生成规则后，ForEach的第二个参数itemGenerator函数会根据键值生成规则为数据源的每个数组项创建组件。组件的创建包括两种情况：ForEach首次渲染和ForEach非首次渲染。
首次渲染
在ForEach首次渲染时，会根据前述键值生成规则为数据源的每个数组项生成唯一键值，并创建相应的组件。
```typescript
@Entry
@Component
struct Parent {
@State simpleList: Array<string> = ['one', 'two', 'three'];
build() {
Row() {
Column() {
ForEach(this.simpleList, (item: string) => {
ChildItem({ item: item })
}, (item: string) => item)
}
.width('100%')
.height('100%')
}
.height('100%')
.backgroundColor(0xF1F3F5)
}
}
@Component
struct ChildItem {
@Prop item: string;
build() {
Text(this.item)
.fontSize(50)
}
}
```
运行效果如下图所示。
图2ForEach数据源不存在相同值案例首次渲染运行效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163836.50478294701360008035299035315688:50001231000000:2800:09933827BDDE1BA2AAEE1C4BB5DEFD8C09853784442C270CBAB1D005F7556A4A.png)
在上述代码中，键值生成规则是keyGenerator函数的返回值item。在ForEach渲染循环时，为数据源数组项依次生成键值one、two和three，并创建对应的ChildItem组件渲染到界面上。
当不同数组项按照键值生成规则生成的键值相同时，框架的行为是未定义的。例如，在以下代码中，ForEach渲染相同的数据项two时，只创建了一个ChildItem组件，而没有创建多个具有相同键值的组件。
```typescript
@Entry
@Component
struct Parent {
@State simpleList: Array<string> = ['one', 'two', 'two', 'three'];
build() {
Row() {
Column() {
ForEach(this.simpleList, (item: string) => {
ChildItem({ item: item })
}, (item: string) => item)
}
.width('100%')
.height('100%')
}
.height('100%')
.backgroundColor(0xF1F3F5)
}
}
@Component
struct ChildItem {
@Prop item: string;
build() {
Text(this.item)
.fontSize(50)
}
}
```
运行效果如下图所示。
图3ForEach数据源存在相同值案例首次渲染运行效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163836.72238228179808896508637952161264:50001231000000:2800:D8F0419FAAA53C139E8F7F449FA85D8E32FEBAE5F967238E0C2754CC89695433.png)
在该示例中，最终键值生成规则为item。当ForEach遍历数据源simpleList，遍历到索引为1的two时，按照最终键值生成规则生成键值为two的组件并进行标记。当遍历到索引为2的two时，按照最终键值生成规则当前项的键值也为two，此时不再创建新的组件。
非首次渲染
在ForEach组件进行非首次渲染时，它会检查新生成的键值是否在上次渲染中已经存在。如果键值不存在，则会创建一个新的组件；如果键值存在，则不会创建新的组件，而是直接渲染该键值所对应的组件。例如，在以下的代码示例中，通过点击事件修改了数组的第三项值为"new three"，这将触发ForEach组件进行非首次渲染。
```typescript
@Entry
@Component
struct Parent {
@State simpleList: Array<string> = ['one', 'two', 'three'];
build() {
Row() {
Column() {
Text('点击修改第3个数组项的值')
.fontSize(24)
.fontColor(Color.Red)
.onClick(() => {
this.simpleList[2] = 'new three';
})
ForEach(this.simpleList, (item: string) => {
ChildItem({ item: item })
.margin({ top: 20 })
}, (item: string) => item)
}
.justifyContent(FlexAlign.Center)
.width('100%')
.height('100%')
}
.height('100%')
.backgroundColor(0xF1F3F5)
}
}
@Component
struct ChildItem {
@Prop item: string;
build() {
Text(this.item)
.fontSize(30)
}
}
```
运行效果如下图所示。
图4ForEach非首次渲染案例运行效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163836.56439629143953045185946572166522:50001231000000:2800:EDAB50A2AC6845B7CD4350C4E105FDD6BFF699E2BFEA6BFE8C1E316F7AF7C59F.gif)
从本例可以看出@State 能够监听到简单数据类型数组数据源 simpleList 数组项的变化。
使用场景
ForEach组件在开发过程中的主要应用场景包括：数据源不变、数据源数组项发生变化（如插入、删除操作）、数据源数组项子属性变化。
数据源不变
在数据源保持不变的场景中，数据源可以直接采用基本数据类型。例如，在页面加载状态时，可以使用骨架屏列表进行渲染展示。
```typescript
@Entry
@Component
struct ArticleList {
@State simpleList: Array<number> = [1, 2, 3, 4, 5];
build() {
Column() {
ForEach(this.simpleList, (item: number) => {
ArticleSkeletonView()
.margin({ top: 20 })
}, (item: number) => item.toString())
}
.padding(20)
.width('100%')
.height('100%')
}
}
@Builder
function textArea(width: number | Resource | string = '100%', height: number | Resource | string = '100%') {
Row()
.width(width)
.height(height)
.backgroundColor('#FFF2F3F4')
}
@Component
struct ArticleSkeletonView {
build() {
Row() {
Column() {
textArea(80, 80)
}
.margin({ right: 20 })
Column() {
textArea('60%', 20)
textArea('50%', 20)
}
.alignItems(HorizontalAlign.Start)
.justifyContent(FlexAlign.SpaceAround)
.height('100%')
}
.padding(20)
.borderRadius(12)
.backgroundColor('#FFECECEC')
.height(120)
.width('100%')
.justifyContent(FlexAlign.SpaceBetween)
}
}
```
运行效果如下图所示。
图5骨架屏运行效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163836.25948838853583104892232236219490:50001231000000:2800:A8C5955018F2FBA5CF0FCC30E4CB919DE808F54CDEA8CD8D0FA7E15194B11512.png)
在本示例中，采用数据项item作为键值生成规则，由于数据源simpleList的数组项各不相同，因此能够保证键值的唯一性。
数据源数组项发生变化
在数据源数组项发生变化的场景下，例如进行数组插入、删除操作或者数组项索引位置发生交换时，数据源应为对象数组类型，并使用对象的唯一ID作为最终键值。例如，当在页面上通过手势上滑加载下一页数据时，会在数据源数组尾部新增新获取的数据项，从而使得数据源数组长度增大。
```typescript
class Article {
id: string;
title: string;
brief: string;
constructor(id: string, title: string, brief: string) {
this.id = id;
this.title = title;
this.brief = brief;
}
}
@Entry
@Component
struct ArticleListView {
@State isListReachEnd: boolean = false;
@State articleList: Array<Article> = [
new Article('001', '第1篇文章', '文章简介内容'),
new Article('002', '第2篇文章', '文章简介内容'),
new Article('003', '第3篇文章', '文章简介内容'),
new Article('004', '第4篇文章', '文章简介内容'),
new Article('005', '第5篇文章', '文章简介内容'),
new Article('006', '第6篇文章', '文章简介内容')
];
loadMoreArticles() {
this.articleList.push(new Article('007', '加载的新文章', '文章简介内容'));
}
build() {
Column({ space: 5 }) {
List() {
ForEach(this.articleList, (item: Article) => {
ListItem() {
ArticleCard({ article: item })
.margin({ top: 20 })
}
}, (item: Article) => item.id)
}
.onReachEnd(() => {
this.isListReachEnd = true;
})
.parallelGesture(
PanGesture({ direction: PanDirection.Up, distance: 80 })
.onActionStart(() => {
if (this.isListReachEnd) {
this.loadMoreArticles();
this.isListReachEnd = false;
}
})
)
.padding(20)
.scrollBar(BarState.Off)
}
.width('100%')
.height('100%')
.backgroundColor(0xF1F3F5)
}
}
@Component
struct ArticleCard {
@Prop article: Article;
build() {
Row() {
// 此处'app.media.icon'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。
Image($r('app.media.icon'))
.width(80)
.height(80)
.margin({ right: 20 })
Column() {
Text(this.article.title)
.fontSize(20)
.margin({ bottom: 8 })
Text(this.article.brief)
.fontSize(16)
.fontColor(Color.Gray)
.margin({ bottom: 8 })
}
.alignItems(HorizontalAlign.Start)
.width('80%')
.height('100%')
}
.padding(20)
.borderRadius(12)
.backgroundColor('#FFECECEC')
.height(120)
.width('100%')
.justifyContent(FlexAlign.SpaceBetween)
}
}
```
初始运行效果（左图）和手势上滑加载后效果（右图）如下图所示。
图6数据源数组项变化案例运行效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163836.29112474798587318114309436828789:50001231000000:2800:78FC1E2A0F1782510937893079779CB02A18082934936E013F317B01C72FED06.png)
在本示例中，ArticleCard组件作为ArticleListView组件的子组件，通过@Prop装饰器接收一个Article对象，用于渲染文章卡片。
数据源数组项子属性变化
当数据源的数组项为对象数据类型，并且只修改某个数组项的属性值时，由于数据源为复杂数据类型，ArkUI框架无法监听到@State装饰器修饰的数据源数组项的属性变化，从而无法触发ForEach的重新渲染。为实现ForEach重新渲染，需要结合@Observed和@ObjectLink装饰器使用。例如，在文章列表卡片上点击“点赞”按钮，从而修改文章的点赞数量。
```typescript
@Observed
class Article {
id: string;
title: string;
brief: string;
isLiked: boolean;
likesCount: number;
constructor(id: string, title: string, brief: string, isLiked: boolean, likesCount: number) {
this.id = id;
this.title = title;
this.brief = brief;
this.isLiked = isLiked;
this.likesCount = likesCount;
}
}
@Entry
@Component
struct ArticleListView {
@State articleList: Array<Article> = [
new Article('001', '第0篇文章', '文章简介内容', false, 100),
new Article('002', '第1篇文章', '文章简介内容', false, 100),
new Article('003', '第2篇文章', '文章简介内容', false, 100),
new Article('004', '第4篇文章', '文章简介内容', false, 100),
new Article('005', '第5篇文章', '文章简介内容', false, 100),
new Article('006', '第6篇文章', '文章简介内容', false, 100),
];
build() {
List() {
ForEach(this.articleList, (item: Article) => {
ListItem() {
ArticleCard({
article: item
})
.margin({ top: 20 })
}
}, (item: Article) => item.id)
}
.padding(20)
.scrollBar(BarState.Off)
.backgroundColor(0xF1F3F5)
}
}
@Component
struct ArticleCard {
@ObjectLink article: Article;
handleLiked() {
this.article.isLiked = !this.article.isLiked;
this.article.likesCount = this.article.isLiked ? this.article.likesCount + 1 : this.article.likesCount - 1;
}
build() {
Row() {
// 此处'app.media.icon'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。
Image($r('app.media.icon'))
.width(80)
.height(80)
.margin({ right: 20 })
Column() {
Text(this.article.title)
.fontSize(20)
.margin({ bottom: 8 })
Text(this.article.brief)
.fontSize(16)
.fontColor(Color.Gray)
.margin({ bottom: 8 })
Row() {
// 此处app.media.iconLiked'，'app.media.iconUnLiked'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。
Image(this.article.isLiked ? $r('app.media.iconLiked') : $r('app.media.iconUnLiked'))
.width(24)
.height(24)
.margin({ right: 8 })
Text(this.article.likesCount.toString())
.fontSize(16)
}
.onClick(() => this.handleLiked())
.justifyContent(FlexAlign.Center)
}
.alignItems(HorizontalAlign.Start)
.width('80%')
.height('100%')
}
.padding(20)
.borderRadius(12)
.backgroundColor('#FFECECEC')
.height(120)
.width('100%')
.justifyContent(FlexAlign.SpaceBetween)
}
}
```
上述代码的初始运行效果（左图）和点击第1个文章卡片上的点赞图标后的运行效果（右图）如下图所示。
图7数据源数组项子属性变化案例运行效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163836.49459599113047788821519423630973:50001231000000:2800:BDF013F0D1D5C6424FACACA150400971D2A420F66D7F869F3E7FDDE9E9DEA73F.png)
在本示例中，Article类被@Observed装饰器修饰。父组件ArticleListView传入Article对象实例给子组件ArticleCard，子组件使用@ObjectLink装饰器接收该实例。
拖拽排序
当ForEach在List组件下使用，并且设置了onMove事件，ForEach每次迭代都生成一个ListItem时，可以使能拖拽排序。拖拽排序离手后，如果数据位置发生变化，则会触发onMove事件，上报数据移动原始索引号和目标索引号。在onMove事件中，需要根据上报的起始索引号和目标索引号修改数据源。数据源修改前后，要保持每个数据的键值不变，只是顺序发生变化，才能保证落位动画正常执行。
```typescript
@Entry
@Component
struct ForEachSort {
@State arr: Array<string> = [];
build() {
Column() {
// 点击此按钮会触发ForEach重新渲染
Button('Add one item')
.onClick(() => {
this.arr.push('10');
})
.width(300)
.margin(10)
List() {
ForEach(this.arr, (item: string) => {
ListItem() {
Text(item.toString())
.fontSize(16)
.textAlign(TextAlign.Center)
.size({ height: 100, width: "100%" })
}.margin(10)
.borderRadius(10)
.backgroundColor("#FFFFFFFF")
}, (item: string) => item)
.onMove((from: number, to: number) => {
// 以下两行代码是为了确保拖拽后屏幕上组件的顺序与数组arr中每一项的顺序保持一致。
// 若注释以下两行，第一步拖拽排序，第二步在arr末尾插入一项，触发ForEach渲染，此时屏上组件的顺序会跟数组arr中每一项的顺序一致，而不是维持第一步拖拽后的顺序，意味着拖拽排序在ForEach渲染后失效了。
let tmp = this.arr.splice(from, 1);
this.arr.splice(to, 0, tmp[0]);
})
}
.width('100%')
.height('100%')
.backgroundColor("#FFDCDCDC")
}
}
aboutToAppear(): void {
for (let i = 0; i < 10; i++) {
this.arr.push(i.toString());
}
}
}
```
图8ForEach拖拽排序效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163836.33628433577931651113861927706613:50001231000000:2800:BED86B069B6C6D43F1CA7F9D017119D27003953950ED87E642FA0225185EDCCC.gif)
注释掉onMove事件调用中的两行代码，点击Add one item触发渲染后的效果如下图所示。
图9ForEach拖拽排序效果在重新渲染后没有保留
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163836.41798887425019012964507156262900:50001231000000:2800:8D9C41ECD1EB148FA13C34434ED12EE0F0073BA70C49FFD1BD0F907F2E00600D.png)
使用建议
不推荐案例
开发者在使用ForEach的过程中，若对于键值生成规则的理解不够充分，可能会出现错误的使用方式。错误使用一方面会导致功能层面问题，例如渲染结果非预期，另一方面会导致性能层面问题，例如渲染性能降低。
渲染结果非预期
在本示例中，通过设置ForEach的第三个参数KeyGenerator函数，自定义键值生成规则为数据源的索引index的字符串类型值。当点击父组件Parent中“在第1项后插入新项”文本组件后，界面会出现非预期的结果。
```typescript
@Entry
@Component
struct Parent {
@State simpleList: Array<string> = ['one', 'two', 'three'];
build() {
Column() {
Button() {
Text('在第1项后插入新项').fontSize(30)
}
.onClick(() => {
this.simpleList.splice(1, 0, 'new item');
})
ForEach(this.simpleList, (item: string) => {
ChildItem({ item: item })
}, (item: string, index: number) => index.toString())
}
.justifyContent(FlexAlign.Center)
.width('100%')
.height('100%')
.backgroundColor(0xF1F3F5)
}
}
@Component
struct ChildItem {
@Prop item: string;
build() {
Text(this.item)
.fontSize(30)
}
}
```
上述代码的初始渲染效果和点击“在第1项后插入新项”文本组件后的渲染效果如下图所示。
图10渲染结果非预期运行效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163836.88341181580995427790519769003328:50001231000000:2800:D1094D3F0686A6B90FDE86CB71DFAFAA66B420E1FC083F6D10264F0C07CEDD15.gif)
ForEach在首次渲染时，创建的键值依次为"0"、"1"、"2"。
插入新项后，数据源simpleList变为['one', 'new item', 'two', 'three']，框架监听到@State装饰的数据源长度变化触发ForEach重新渲染。
ForEach依次遍历新数据源，遍历数据项"one"时生成键值"0"，存在相同键值，因此不创建新组件。继续遍历数据项"new item"时生成键值"1"，存在相同键值，因此不创建新组件。继续遍历数据项"two"生成键值"2"，存在相同键值，因此不创建新组件。最后遍历数据项"three"时生成键值"3"，不存在相同键值，创建内容为"three"的新组件并渲染。
从以上可以看出，当最终键值生成规则包含index时，期望的界面渲染结果为['one', 'new item', 'two', 'three']，而实际的渲染结果为['one', 'two', 'three', 'three']，渲染结果不符合开发者预期。因此，开发者在使用ForEach时应尽量避免最终键值生成规则中包含index。
渲染性能降低
在本示例中，ForEach的第三个参数KeyGenerator函数处于缺省状态。根据上述键值生成规则，此例使用框架默认的键值生成规则，即最终键值为字符串index + '__' + JSON.stringify(item)。当点击“在第1项后插入新项”文本组件后，ForEach将需要为第2个数组项以及其后的所有项重新创建组件。
```typescript
@Entry
@Component
struct Parent {
@State simpleList: Array<string> = ['one', 'two', 'three'];
build() {
Column() {
Button() {
Text('在第1项后插入新项').fontSize(30)
}
.onClick(() => {
this.simpleList.splice(1, 0, 'new item');
console.info(`[onClick]: simpleList is [${this.simpleList.join(', ')}]`);
})
ForEach(this.simpleList, (item: string) => {
ChildItem({ item: item })
})
}
.justifyContent(FlexAlign.Center)
.width('100%')
.height('100%')
.backgroundColor(0xF1F3F5)
}
}
@Component
struct ChildItem {
@Prop item: string;
aboutToAppear() {
console.info(`[aboutToAppear]: item is ${this.item}`);
}
build() {
Text(this.item)
.fontSize(50)
}
}
```
以上代码的初始渲染效果和点击"在第1项后插入新项"文本组件后的渲染效果如下图所示。
图11渲染性能降低案例运行效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163836.76779957788253370487012421688696:50001231000000:2800:9950AB36FEE8BD9741B4ECF1849805C26DF9DCDD1A5C1FFCF4B030807D649E61.gif)
点击“在第1项后插入新项”文本组件后，DevEco Studio的日志打印结果如下所示。
图12渲染性能降低案例日志打印图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163836.99828354064583253702269996140098:50001231000000:2800:070CE5DD0A44DCA6BE1AA8A7DD3068DB0BD547F5D451CC1FCEC161A896D91359.png)
插入新项后，ForEach为new item、 two、 three三个数组项创建了对应的组件ChildItem，并执行了组件的aboutToAppear()生命周期函数。这是因为：
尽管此示例中界面渲染的结果符合预期，但每次插入一条新数组项时，ForEach都会为从该数组项起后面的所有数组项全部重新创建组件。当数据源数据量较大或组件结构复杂时，由于组件无法得到复用，将导致性能体验不佳。因此，除非必要，否则不推荐将第三个参数KeyGenerator函数处于缺省状态，以及在键值生成规则中包含数据项索引index。
正确渲染并保证效率的ForEach写法是：
```typescript
ForEach(this.simpleList, (item: string) => {
ChildItem({ item: item })
}, (item: string) => item)  // 需要保证key唯一
```
提供了第三个参数KeyGenerator，在这个例子中，对数据源的不同数据项生成不同的key，并且对同一个数据项每次生成相同的key。
数据变化不渲染
点击按钮Like/UnLike first article，第一个组件会切换点赞手势和后面的点赞数量，但是点击按钮Replace first article之后再点击按钮Like/UnLike first article就不生效了。这是因为，替换articleList[0]之后，articleList这个状态变量发生变化，触发ForEach重新渲染，但是新的articleList[0]生成的key没有变，ForEach不会将数据更新同步给子组件，因此第一个组件仍然绑定旧的articleList[0]。新articleList[0]的属性发生变更，第一个组件感知不到，不会重新渲染。点击点赞手势，会触发渲染。因为变更的是跟组件绑定的数组项的属性，组件会感知并重新渲染。
```typescript
@Observed
class Article {
id: string;
title: string;
brief: string;
isLiked: boolean;
likesCount: number;
constructor(id: string, title: string, brief: string, isLiked: boolean, likesCount: number) {
this.id = id;
this.title = title;
this.brief = brief;
this.isLiked = isLiked;
this.likesCount = likesCount;
}
}
@Entry
@Component
struct ArticleListView {
@State articleList: Array<Article> = [
new Article('001', '第0篇文章', '文章简介内容', false, 100),
new Article('002', '第1篇文章', '文章简介内容', false, 100),
new Article('003', '第2篇文章', '文章简介内容', false, 100),
new Article('004', '第4篇文章', '文章简介内容', false, 100),
new Article('005', '第5篇文章', '文章简介内容', false, 100),
new Article('006', '第6篇文章', '文章简介内容', false, 100),
];
build() {
Column() {
Button('Replace first article')
.onClick(() => {
this.articleList[0] = new Article('001', '第0篇文章', '文章简介内容', false, 100);
})
.width(300)
.margin(10)
Button('Like/Unlike first article')
.onClick(() => {
this.articleList[0].isLiked = !this.articleList[0].isLiked;
this.articleList[0].likesCount =
this.articleList[0].isLiked ? this.articleList[0].likesCount + 1 : this.articleList[0].likesCount - 1;
})
.width(300)
.margin(10)
List() {
ForEach(this.articleList, (item: Article) => {
ListItem() {
ArticleCard({
article: item
})
.margin({ top: 20 })
}
}, (item: Article) => item.id)
}
.padding(20)
.scrollBar(BarState.Off)
.backgroundColor(0xF1F3F5)
}
}
}
@Component
struct ArticleCard {
@ObjectLink article: Article;
handleLiked() {
this.article.isLiked = !this.article.isLiked;
this.article.likesCount = this.article.isLiked ? this.article.likesCount + 1 : this.article.likesCount - 1;
}
build() {
Row() {
// 此处'app.media.icon'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。
Image($r('app.media.icon'))
.width(80)
.height(80)
.margin({ right: 20 })
Column() {
Text(this.article.title)
.fontSize(20)
.margin({ bottom: 8 })
Text(this.article.brief)
.fontSize(16)
.fontColor(Color.Gray)
.margin({ bottom: 8 })
Row() {
// 此处app.media.iconLiked'，'app.media.iconUnLiked'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。
Image(this.article.isLiked ? $r('app.media.iconLiked') : $r('app.media.iconUnLiked'))
.width(24)
.height(24)
.margin({ right: 8 })
Text(this.article.likesCount.toString())
.fontSize(16)
}
.onClick(() => this.handleLiked())
.justifyContent(FlexAlign.Center)
}
.alignItems(HorizontalAlign.Start)
.width('80%')
.height('100%')
}
.padding(20)
.borderRadius(12)
.backgroundColor('#FFECECEC')
.height(120)
.width('100%')
.justifyContent(FlexAlign.SpaceBetween)
}
}
```
图13数据变化不渲染
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163836.07543159897502408342780883476605:50001231000000:2800:59BC97871726B276D081E7F326FCF836E5454485D7990B076E638B9A00EBD9CF.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach
爬取时间: 2025-04-28 07:03:56
来源: Huawei Developer
API参数说明见：LazyForEach API参数说明。
LazyForEach从提供的数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。当在滚动容器中使用了LazyForEach，框架会根据滚动容器可视区域按需创建组件，当组件滑出可视区域外时，框架会进行组件销毁回收以降低内存占用。
使用限制
键值生成规则
在LazyForEach循环渲染过程中，系统会为每个item生成一个唯一且持久的键值，用于标识对应的组件。当这个键值变化时，ArkUI框架将视为该数组元素已被替换或修改，并会基于新的键值创建一个新的组件。
LazyForEach提供了一个名为keyGenerator的参数，这是一个函数，开发者可以通过它自定义键值的生成规则。如果开发者没有定义keyGenerator函数，则ArkUI框架会使用默认的键值生成函数，即(item: Object, index: number) => { return viewId + '-' + index.toString(); }, viewId在编译器转换过程中生成，同一个LazyForEach组件内其viewId是一致的。
组件创建规则
在确定键值生成规则后，LazyForEach的第二个参数itemGenerator函数会根据组件创建规则为数据源的每个数组项创建组件。组件的创建包括两种情况：LazyForEach首次渲染和LazyForEach非首次渲染。
首次渲染
生成不同键值
在LazyForEach首次渲染时，会根据上述键值生成规则为数据源的每个数组项生成唯一键值，并创建相应的组件。
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(`Hello ${i}`);
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: string) => {
ListItem() {
Row() {
Text(item).fontSize(50)
.onAppear(() => {
console.info(`appear: ${item}`);
})
}.margin({ left: 10, right: 10 })
}
}, (item: string) => item)
}.cachedCount(5)
}
}
```
在上述代码中，键值生成规则是keyGenerator函数的返回值item。在LazyForEach循环渲染时，其为数据源数组项依次生成键值Hello 0、Hello 1 ... Hello 20，并创建对应的ListItem子组件渲染到界面上。
运行效果如下图所示。
图1LazyForEach正常首次渲染
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.98205126621587058265018611062792:50001231000000:2800:B19342CC542F4D1D8F23C50E432D16BD4FD300A84D3A6B6EF5E6F3114E8C58BD.gif)
键值相同时错误渲染
当不同数据项生成的键值相同时，框架的行为是不可预测的。例如，在以下代码中，LazyForEach渲染的数据项键值均相同，在滑动过程中，LazyForEach会对划入划出当前页面的子组件进行预加载，而新建的子组件和销毁的原子组件具有相同的键值，框架可能存在取用缓存错误的情况，导致子组件渲染有问题。
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(`Hello ${i}`);
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: string) => {
ListItem() {
Row() {
Text(item).fontSize(50)
.onAppear(() => {
console.info(`appear: ${item}`);
})
}.margin({ left: 10, right: 10 })
}
}, (item: string) => 'same key')
}.cachedCount(5)
}
}
```
运行效果如下图所示。
图2LazyForEach存在相同键值
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.38216735576968339145439152612438:50001231000000:2800:AFA8C5B79A3A2137413F02C8179F6AB3EB3F6B5EE00568E5DB276697E0DA57EB.gif)
非首次渲染
当LazyForEach数据源发生变化，需要再次渲染时，开发者应根据数据源的变化情况调用listener对应的接口，通知LazyForEach做相应的更新，各使用场景如下。
添加数据
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(`Hello ${i}`);
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: string) => {
ListItem() {
Row() {
Text(item).fontSize(50)
.onAppear(() => {
console.info(`appear: ${item}`);
})
}.margin({ left: 10, right: 10 })
}
.onClick(() => {
// 点击追加子组件
this.data.pushData(`Hello ${this.data.totalCount()}`);
})
}, (item: string) => item)
}.cachedCount(5)
}
}
```
当我们点击LazyForEach的子组件时，首先调用数据源data的pushData方法，该方法会在数据源末尾添加数据并调用notifyDataAdd方法。在notifyDataAdd方法内会又调用listener.onDataAdd方法，该方法会通知LazyForEach在该处有数据添加，LazyForEach便会在该索引处新建子组件。
运行效果如下图所示。
图3LazyForEach添加数据
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.30162467926470234048769551776411:50001231000000:2800:1A538B1EEE543ACCE999C2333AC2697A3A8FCC0E423C3A256A6E291D0FD9D5E9.gif)
删除数据
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public getAllData(): string[] {
return this.dataArray;
}
public pushData(data: string): void {
this.dataArray.push(data);
}
public deleteData(index: number): void {
this.dataArray.splice(index, 1);
this.notifyDataDelete(index);
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(`Hello ${i}`);
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: string, index: number) => {
ListItem() {
Row() {
Text(item).fontSize(50)
.onAppear(() => {
console.info(`appear: ${item}`);
})
}.margin({ left: 10, right: 10 })
}
.onClick(() => {
// 点击删除子组件
this.data.deleteData(this.data.getAllData().indexOf(item));
})
}, (item: string) => item)
}.cachedCount(5)
}
}
```
当我们点击LazyForEach的子组件时，首先调用数据源data的deleteData方法，该方法会删除数据源对应索引处的数据并调用notifyDataDelete方法。在notifyDataDelete方法内会又调用listener.onDataDelete方法，该方法会通知LazyForEach在该处有数据删除，LazyForEach便会在该索引处删除对应子组件。
运行效果如下图所示。
图4LazyForEach删除数据
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.90051230831802886139834303573581:50001231000000:2800:75A163EF5412ADD23F8E3224956BCDE981A16A2D7905E6A80F4CC7FA60623806.gif)
交换数据
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public getAllData(): string[] {
return this.dataArray;
}
public pushData(data: string): void {
this.dataArray.push(data);
}
public moveData(from: number, to: number): void {
let temp: string = this.dataArray[from];
this.dataArray[from] = this.dataArray[to];
this.dataArray[to] = temp;
this.notifyDataMove(from, to);
}
}
@Entry
@Component
struct MyComponent {
private moved: number[] = [];
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(`Hello ${i}`);
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: string, index: number) => {
ListItem() {
Row() {
Text(item).fontSize(50)
.onAppear(() => {
console.info(`appear: ${item}`);
})
}.margin({ left: 10, right: 10 })
}
.onClick(() => {
this.moved.push(this.data.getAllData().indexOf(item));
if (this.moved.length === 2) {
// 点击交换子组件
this.data.moveData(this.moved[0], this.moved[1]);
this.moved = [];
}
})
}, (item: string) => item)
}.cachedCount(5)
}
}
```
当我们首次点击LazyForEach的子组件时，在moved成员变量内存入要移动的数据索引，再次点击LazyForEach另一个子组件时，我们将首次点击的子组件移到此处。调用数据源data的moveData方法，该方法会将数据源对应数据移动到预期的位置并调用notifyDataMove方法。在notifyDataMove方法内会又调用listener.onDataMove方法，该方法通知LazyForEach在该处有数据需要移动，LazyForEach便会将from和to索引处的子组件进行位置调换。
运行效果如下图所示。
图5LazyForEach交换数据
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.04985952662111981299146455565845:50001231000000:2800:AB2AC59EB2E2718A16ED7A236FB81858F6C55F0D2677F5E163A21DF9D4C15CEE.gif)
改变单个数据
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
}
public changeData(index: number, data: string): void {
this.dataArray.splice(index, 1, data);
this.notifyDataChange(index);
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(`Hello ${i}`);
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: string, index: number) => {
ListItem() {
Row() {
Text(item).fontSize(50)
.onAppear(() => {
console.info(`appear: ${item}`);
})
}.margin({ left: 10, right: 10 })
}
.onClick(() => {
this.data.changeData(index, item + '00');
})
}, (item: string) => item)
}.cachedCount(5)
}
}
```
当我们点击LazyForEach的子组件时，首先改变当前数据，然后调用数据源data的changeData方法，在该方法内会调用notifyDataChange方法。在notifyDataChange方法内会又调用listener.onDataChange方法，该方法通知LazyForEach组件该处有数据发生变化，LazyForEach便会在对应索引处重建子组件。
运行效果如下图所示。
图6LazyForEach改变单个数据
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.51525926886512253775977525722811:50001231000000:2800:4D5CD69EBEA06679A52B95ACFD2F45E3FC48C8F17F62F5804856FEB3A75E6BA6.gif)
改变多个数据
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
}
public reloadData(): void {
this.notifyDataReload();
}
public modifyAllData(): void {
this.dataArray = this.dataArray.map((item: string) => {
return item + '0';
});
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(`Hello ${i}`);
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: string, index: number) => {
ListItem() {
Row() {
Text(item).fontSize(50)
.onAppear(() => {
console.info(`appear: ${item}`);
})
}.margin({ left: 10, right: 10 })
}
.onClick(() => {
this.data.modifyAllData();
this.data.reloadData();
})
}, (item: string) => item)
}.cachedCount(5)
}
}
```
当我们点击LazyForEach的子组件时，首先调用data的modifyAllData方法改变了数据源中的所有数据，然后调用数据源的reloadData方法，在该方法内会调用notifyDataReload方法。在notifyDataReload方法内会又调用listener.onDataReloaded方法，通知LazyForEach需要重建所有子节点。LazyForEach会将原所有数据项和新所有数据项一一做键值比对，若有相同键值则使用缓存，若键值不同则重新构建。
运行效果如下图所示。
图7LazyForEach改变多个数据
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.78458817584793575115019210035774:50001231000000:2800:7EB9655F7F39CF1C15FB110B494FADE21BC594A112DB414AD54F776C5122F4D8.gif)
精准批量修改数据
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public operateData(): void {
console.info(`[${this.dataArray.join(', ')}]`);
this.dataArray.splice(4, 0, this.dataArray[1]);
this.dataArray.splice(1, 1);
let temp = this.dataArray[4];
this.dataArray[4] = this.dataArray[6];
this.dataArray[6] = temp;
this.dataArray.splice(8, 0, 'Hello 1', 'Hello 2');
this.dataArray.splice(12, 2);
console.info(`[${this.dataArray.join(', ')}]`);
this.notifyDatasetChange([
{ type: DataOperationType.MOVE, index: { from: 1, to: 3 } },
{ type: DataOperationType.EXCHANGE, index: { start: 4, end: 6 } },
{ type: DataOperationType.ADD, index: 8, count: 2 },
{ type: DataOperationType.DELETE, index: 10, count: 2 }]);
}
public init(): void {
this.dataArray.splice(0, 0, 'Hello a', 'Hello b', 'Hello c', 'Hello d', 'Hello e', 'Hello f', 'Hello g', 'Hello h',
'Hello i', 'Hello j', 'Hello k', 'Hello l', 'Hello m', 'Hello n', 'Hello o', 'Hello p', 'Hello q', 'Hello r');
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
this.data.init();
}
build() {
Column() {
Text('change data')
.fontSize(10)
.backgroundColor(Color.Blue)
.fontColor(Color.White)
.borderRadius(50)
.padding(5)
.onClick(() => {
this.data.operateData();
})
List({ space: 3 }) {
LazyForEach(this.data, (item: string, index: number) => {
ListItem() {
Row() {
Text(item).fontSize(35)
.onAppear(() => {
console.info(`appear: ${item}`);
})
}.margin({ left: 10, right: 10 })
}
}, (item: string) => item + new Date().getTime())
}.cachedCount(5)
}
}
}
```
onDatasetChange接口允许开发者一次性通知LazyForEach进行数据添加、删除、移动和交换等操作。在上述例子中，点击“change data”文本后,第二项数据被移动到第四项位置，第五项与第七项数据交换位置，并且从第九项开始添加了数据"Hello 1"和"Hello 2"，同时从第十一项开始删除了两项数据。
图8LazyForEach改变多个数据
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.00640787481569863072813436834604:50001231000000:2800:56FA1BFF236629937FBC62D539BF47FE51FC81A5C1FCD740E3C69D8DCA58E668.gif)
第二个例子，直接给数组赋值，不涉及 splice 操作。operations直接从比较原数组和新数组得到。
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public operateData(): void {
this.dataArray =
['Hello x', 'Hello 1', 'Hello 2', 'Hello b', 'Hello c', 'Hello e', 'Hello d', 'Hello f', 'Hello g', 'Hello h'];
this.notifyDatasetChange([
{ type: DataOperationType.CHANGE, index: 0 },
{ type: DataOperationType.ADD, index: 1, count: 2 },
{ type: DataOperationType.EXCHANGE, index: { start: 3, end: 4 } },
]);
}
public init(): void {
this.dataArray = ['Hello a', 'Hello b', 'Hello c', 'Hello d', 'Hello e', 'Hello f', 'Hello g', 'Hello h'];
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
this.data.init();
}
build() {
Column() {
Text('Multi-Data Change')
.fontSize(10)
.backgroundColor(Color.Blue)
.fontColor(Color.White)
.borderRadius(50)
.padding(5)
.onClick(() => {
this.data.operateData();
})
List({ space: 3 }) {
LazyForEach(this.data, (item: string, index: number) => {
ListItem() {
Row() {
Text(item).fontSize(35)
.onAppear(() => {
console.info(`appear: ${item}`);
})
}.margin({ left: 10, right: 10 })
}
}, (item: string) => item + new Date().getTime())
}.cachedCount(5)
}
}
}
```
图9LazyForEach改变多个数据
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.45043813615585105820842705905368:50001231000000:2800:F5F204F8BADA6688FDB5BDDFB75605B08519BA123281B4A8AFDD223105CC467D.gif)
使用该接口时有如下注意事项。
第一个例子清楚地显示了这一点:
```typescript
// 修改之前的数组
["Hello a","Hello b","Hello c","Hello d","Hello e","Hello f","Hello g","Hello h","Hello i","Hello j","Hello k","Hello l","Hello m","Hello n","Hello o","Hello p","Hello q","Hello r"]
// 修改之后的数组
["Hello a","Hello c","Hello d","Hello b","Hello g","Hello f","Hello e","Hello h","Hello 1","Hello 2","Hello i","Hello j","Hello m","Hello n","Hello o","Hello p","Hello q","Hello r"]
```
"Hello b" 从第2项变成第4项，因此第一个 operation 为 { type: DataOperationType.MOVE, index: { from: 1, to: 3 } }。
"Hello e" 跟 "Hello g" 对调了，而 "Hello e" 在修改前的原数组中的 index=4，"Hello g" 在修改前的原数组中的 index=6, 因此第二个 operation 为 { type: DataOperationType.EXCHANGE, index: { start: 4, end: 6 } }。
"Hello 1","Hello 2" 在 "Hello h" 之后插入，而 "Hello h" 在修改前的原数组中的 index=7，因此第三个 operation 为 { type: DataOperationType.ADD, index: 8, count: 2 }。
"Hello k","Hello l" 被删除了，而 "Hello k" 在原数组中的 index=10，因此第四个 operation 为 { type: DataOperationType.DELETE, index: 10, count: 2 }。
改变数据子属性
若仅靠LazyForEach的刷新机制，当item变化时若想更新子组件，需要将原来的子组件全部销毁再重新构建，在子组件结构较为复杂的情况下，靠改变键值去刷新渲染性能较低。因此框架提供了@Observed与@ObjectLink机制进行深度观测，可以做到仅刷新使用了该属性的组件，提高渲染性能。开发者可根据其自身业务特点选择使用哪种刷新方式。
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: StringData[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): StringData {
return this.dataArray[index];
}
public pushData(data: StringData): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
@Observed
class StringData {
message: string;
constructor(message: string) {
this.message = message;
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(new StringData(`Hello ${i}`));
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: StringData, index: number) => {
ListItem() {
ChildComponent({ data: item })
}
.onClick(() => {
item.message += '0';
})
}, (item: StringData, index: number) => index.toString())
}.cachedCount(5)
}
}
@Component
struct ChildComponent {
@ObjectLink data: StringData;
build() {
Row() {
Text(this.data.message).fontSize(50)
.onAppear(() => {
console.info(`appear: ${this.data.message}`);
})
}.margin({ left: 10, right: 10 })
}
}
```
此时点击LazyForEach子组件改变item.message时，重渲染依赖的是ChildComponent的@ObjectLink成员变量对其子属性的监听，此时框架只会刷新Text(this.data.message)，不会去重建整个ListItem子组件。
图10LazyForEach改变数据子属性
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.38148261759337083311325913718185:50001231000000:2800:A06EECA90C56A13940A72AAC945C6B788BB1C70EFACC646774FAAC6979FA73D1.gif)
使用状态管理V2
状态管理V2提供了@ObservedV2与@Trace装饰器可以实现对属性的深度观测，使用@Local和@Param可以实现对子组件的刷新管理，仅刷新使用了对应属性的组件。
嵌套类属性变化观测
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: StringData[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): StringData {
return this.dataArray[index];
}
public pushData(data: StringData): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
class StringData {
firstLayer: FirstLayer;
constructor(firstLayer: FirstLayer) {
this.firstLayer = firstLayer;
}
}
class FirstLayer {
secondLayer: SecondLayer;
constructor(secondLayer: SecondLayer) {
this.secondLayer = secondLayer;
}
}
class SecondLayer {
thirdLayer: ThirdLayer;
constructor(thirdLayer: ThirdLayer) {
this.thirdLayer = thirdLayer;
}
}
@ObservedV2
class ThirdLayer {
@Trace forthLayer: String;
constructor(forthLayer: String) {
this.forthLayer = forthLayer;
}
}
@Entry
@ComponentV2
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(new StringData(new FirstLayer(new SecondLayer(new ThirdLayer(`Hello ${i}`)))));
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: StringData, index: number) => {
ListItem() {
Text(item.firstLayer.secondLayer.thirdLayer.forthLayer.toString()).fontSize(50)
.onClick(() => {
item.firstLayer.secondLayer.thirdLayer.forthLayer += '!';
})
}
}, (item: StringData, index: number) => index.toString())
}.cachedCount(5)
}
```
@ObservedV2与@Trace用于装饰类以及类中的属性，配合使用能深度观测被装饰的类和属性。示例中，展示了深度嵌套类结构下，通过@ObservedV2和@Trace实现对多层嵌套属性变化的观测和子组件刷新。当点击子组件Text修改被@Trace修饰的嵌套类最内层的类成员属性时，仅重新渲染依赖了该属性的组件。
组件内部状态
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: StringData[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): StringData {
return this.dataArray[index];
}
public pushData(data: StringData): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
@ObservedV2
class StringData {
@Trace message: string;
constructor(message: string) {
this.message = message;
}
}
@Entry
@ComponentV2
struct MyComponent {
data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(new StringData(`Hello ${i}`));
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: StringData, index: number) => {
ListItem() {
Row() {
Text(item.message).fontSize(50)
.onClick(() => {
// 修改@ObservedV2装饰类中@Trace装饰的变量，触发刷新此处Text组件
item.message += '!';
})
ChildComponent()
}
}
}, (item: StringData, index: number) => index.toString())
}.cachedCount(5)
}
}
@ComponentV2
struct ChildComponent {
@Local message: string = '?';
build() {
Row() {
Text(this.message).fontSize(50)
.onClick(() => {
// 修改@Local装饰的变量，触发刷新此处Text组件
this.message += '?';
})
}
}
}
```
@Local使得自定义组件内被修饰的变量具有观测其变化的能力，该变量必须在组件内部进行初始化。示例中，点击Text组件修改item.message会触发变量更新并刷新使用该变量的组件，ChildComponent中@Local装饰的变量message变化时也能刷新子组件。
组件外部输入
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: StringData[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): StringData {
return this.dataArray[index];
}
public pushData(data: StringData): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
@ObservedV2
class StringData {
@Trace message: string;
constructor(message: string) {
this.message = message;
}
}
@Entry
@ComponentV2
struct MyComponent {
data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(new StringData(`Hello ${i}`));
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: StringData, index: number) => {
ListItem() {
ChildComponent({ data: item.message })
.onClick(() => {
item.message += '!';
})
}
}, (item: StringData, index: number) => index.toString())
}.cachedCount(5)
}
}
@ComponentV2
struct ChildComponent {
@Param @Require data: string = '';
build() {
Row() {
Text(this.data).fontSize(50)
}
}
}
```
使用@Param装饰器可以让子组件接受外部输入的参数，实现父子组件之间的数据同步。在MyComponent中创建子组件时，将变量item.message传递，使用@Param修饰的变量data与之关联。点击ListItem中的组件修改item.message，数据变化会从父组件传递到子组件，并且触发子组件的刷新。
拖拽排序
当LazyForEach在List组件下使用，并且设置了onMove事件，可以使能拖拽排序。拖拽排序离手后，如果数据位置发生变化，则会触发onMove事件，上报数据移动原始索引号和目标索引号。在onMove事件中，需要根据上报的起始索引号和目标索引号修改数据源。onMove中修改数据源不需要调用DataChangeListener中接口通知数据源变化。
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public moveDataWithoutNotify(from: number, to: number): void {
let tmp = this.dataArray.splice(from, 1);
this.dataArray.splice(to, 0, tmp[0]);
}
public pushData(data: string): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
@Entry
@Component
struct Parent {
private data: MyDataSource = new MyDataSource();
aboutToAppear(): void {
for (let i = 0; i < 100; i++) {
this.data.pushData(i.toString());
}
}
build() {
Row() {
List() {
LazyForEach(this.data, (item: string) => {
ListItem() {
Text(item.toString())
.fontSize(16)
.textAlign(TextAlign.Center)
.size({ height: 100, width: "100%" })
}.margin(10)
.borderRadius(10)
.backgroundColor("#FFFFFFFF")
}, (item: string) => item)
.onMove((from: number, to: number) => {
this.data.moveDataWithoutNotify(from, to);
})
}
.width('100%')
.height('100%')
.backgroundColor("#FFDCDCDC")
}
}
}
```
图11LazyForEach拖拽排序效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.63499784175861745952420862467177:50001231000000:2800:FD9E7B125000A42096C9DC5D0E2C9255C6112616A8ECEDC8BA85486A4CEAC031.gif)
常见问题
渲染结果非预期
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
public deleteData(index: number): void {
this.dataArray.splice(index, 1);
this.notifyDataDelete(index);
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(`Hello ${i}`);
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: string, index: number) => {
ListItem() {
Row() {
Text(item).fontSize(50)
.onAppear(() => {
console.info(`appear: ${item}`);
})
}.margin({ left: 10, right: 10 })
}
.onClick(() => {
// 点击删除子组件
this.data.deleteData(index);
})
}, (item: string) => item)
}.cachedCount(5)
}
}
```
图12LazyForEach删除数据非预期
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.68040137910543302688769536799878:50001231000000:2800:51BB933F2129DA363E663CDE0EF5416274C4CE72DE6B6435F10803E3F3CB8745.gif)
当我们多次点击子组件时，会发现删除的并不一定是我们点击的那个子组件。原因是当我们删除了某一个子组件后，位于该子组件对应的数据项之后的各数据项，其index均应减1，但实际上后续的数据项对应的子组件仍然使用的是最初分配的index，其itemGenerator中的index并没有发生变化，所以删除结果和预期不符。
修复代码如下所示。
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
public deleteData(index: number): void {
this.dataArray.splice(index, 1);
this.notifyDataDelete(index);
}
public reloadData(): void {
this.notifyDataReload();
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(`Hello ${i}`);
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: string, index: number) => {
ListItem() {
Row() {
Text(item).fontSize(50)
.onAppear(() => {
console.info(`appear: ${item}`);
})
}.margin({ left: 10, right: 10 })
}
.onClick(() => {
// 点击删除子组件
this.data.deleteData(index);
// 重置所有子组件的index索引
this.data.reloadData();
})
}, (item: string, index: number) => item + index.toString())
}.cachedCount(5)
}
}
```
在删除一个数据项后调用reloadData方法，重建后面的数据项，以达到更新index索引的目的。要保证reloadData方法重建数据项，必须保证数据项能生成新的key。这里用了item + index.toString()保证被删除数据项后面的数据项都被重建。如果用item + Date.now().toString()替代，那么所有数据项都生成新的key，导致所有数据项都被重建。这种方法，效果是一样的，只是性能略差。
图13修复LazyForEach删除数据非预期
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.86399902795909463180564566365773:50001231000000:2800:31E2EA8B8E9DA3C61978D73514546783D5161DB1626C13C7A6FBAE9133959CE2.gif)
重渲染时图片闪烁
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: StringData[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): StringData {
return this.dataArray[index];
}
public pushData(data: StringData): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
public reloadData(): void {
this.notifyDataReload();
}
}
class StringData {
message: string;
imgSrc: Resource;
constructor(message: string, imgSrc: Resource) {
this.message = message;
this.imgSrc = imgSrc;
}
}
@Entry
@Component
struct MyComponent {
private moved: number[] = [];
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
// 此处'app.media.img'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。
this.data.pushData(new StringData(`Hello ${i}`, $r('app.media.img')));
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: StringData, index: number) => {
ListItem() {
Column() {
Text(item.message).fontSize(50)
.onAppear(() => {
console.info(`appear: ${item.message}`);
})
Image(item.imgSrc)
.width(500)
.height(200)
}.margin({ left: 10, right: 10 })
}
.onClick(() => {
item.message += '00';
this.data.reloadData();
})
}, (item: StringData, index: number) => JSON.stringify(item))
}.cachedCount(5)
}
}
```
图14LazyForEach仅改变文字但是图片闪烁问题
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.15896238452525034238419704243295:50001231000000:2800:022141A75C67C5898DD768D0181B11601E449BA74170BCF46186D6F64E9E97F8.gif)
在我们点击ListItem子组件时，我们只改变了数据项的message属性，但是LazyForEach的刷新机制会导致整个ListItem被重建。由于Image组件是异步刷新，所以视觉上图片会发生闪烁。为了解决这种情况我们应该使用@ObjectLink和@Observed去单独刷新使用了item.message的Text组件。
修复代码如下所示。
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: StringData[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): StringData {
return this.dataArray[index];
}
public pushData(data: StringData): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
// @Observed类装饰器 和 @ObjectLink 用于在涉及嵌套对象或数组的场景中进行双向数据同步
@Observed
class StringData {
message: string;
imgSrc: Resource;
constructor(message: string, imgSrc: Resource) {
this.message = message;
this.imgSrc = imgSrc;
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
// 此处'app.media.img'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。
this.data.pushData(new StringData(`Hello ${i}`, $r('app.media.img')));
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: StringData, index: number) => {
ListItem() {
ChildComponent({ data: item })
}
.onClick(() => {
item.message += '0';
})
}, (item: StringData, index: number) => index.toString())
}.cachedCount(5)
}
}
@Component
struct ChildComponent {
// 用状态变量来驱动UI刷新，而不是通过Lazyforeach的api来驱动UI刷新
@ObjectLink data: StringData;
build() {
Column() {
Text(this.data.message).fontSize(50)
.onAppear(() => {
console.info(`appear: ${this.data.message}`);
})
Image(this.data.imgSrc)
.width(500)
.height(200)
}.margin({ left: 10, right: 10 })
}
}
```
图15修复LazyForEach仅改变文字但是图片闪烁问题
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163837.88634850610073733893039520869707:50001231000000:2800:800F4EF48716FCAC61047A82010124F5809F0EA1B1445F6E617A88CC489EA870.gif)
@ObjectLink属性变化UI未更新
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: StringData[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): StringData {
return this.dataArray[index];
}
public pushData(data: StringData): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
@Observed
class StringData {
message: NestedString;
constructor(message: NestedString) {
this.message = message;
}
}
@Observed
class NestedString {
message: string;
constructor(message: string) {
this.message = message;
}
}
@Entry
@Component
struct MyComponent {
private moved: number[] = [];
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(new StringData(new NestedString(`Hello ${i}`)));
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: StringData, index: number) => {
ListItem() {
ChildComponent({ data: item })
}
.onClick(() => {
item.message.message += '0';
})
}, (item: StringData, index: number) => JSON.stringify(item) + index.toString())
}.cachedCount(5)
}
}
@Component
struct ChildComponent {
@ObjectLink data: StringData;
build() {
Row() {
Text(this.data.message.message).fontSize(50)
.onAppear(() => {
console.info(`appear: ${this.data.message.message}`);
})
}.margin({ left: 10, right: 10 })
}
}
```
图16ObjectLink属性变化后UI未更新
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163838.22858233513275685660197124593498:50001231000000:2800:12549C109107233CE19797CED5529551200FD600FD03AC0E7FB7DF2034FAA0A0.gif)
@ObjectLink装饰的成员变量仅能监听到其子属性的变化，再深入嵌套的属性便无法观测到了，因此我们只能改变它的子属性去通知对应组件重新渲染，具体请查看@ObjectLink与@Observed的详细使用方法和限制条件。
修复代码如下所示。
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: StringData[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): StringData {
return this.dataArray[index];
}
public pushData(data: StringData): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
@Observed
class StringData {
message: NestedString;
constructor(message: NestedString) {
this.message = message;
}
}
@Observed
class NestedString {
message: string;
constructor(message: string) {
this.message = message;
}
}
@Entry
@Component
struct MyComponent {
private moved: number[] = [];
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(new StringData(new NestedString(`Hello ${i}`)));
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: StringData, index: number) => {
ListItem() {
ChildComponent({ data: item })
}
.onClick(() => {
// @ObjectLink装饰的成员变量仅能监听到其子属性的变化，再深入嵌套的属性便无法观测到
item.message = new NestedString(item.message.message + '0');
})
}, (item: StringData, index: number) => JSON.stringify(item) + index.toString())
}.cachedCount(5)
}
}
@Component
struct ChildComponent {
@ObjectLink data: StringData;
build() {
Row() {
Text(this.data.message.message).fontSize(50)
.onAppear(() => {
console.info(`appear: ${this.data.message.message}`);
})
}.margin({ left: 10, right: 10 })
}
}
```
图17修复ObjectLink属性变化后UI更新
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163838.18457801918550668543869921178854:50001231000000:2800:6BFAE5098567FBF726380CC6B55D8E363F6B09A5983E381244A3C05F1375DD78.gif)
在List内使用屏幕闪烁
在List的onScrollIndex方法中调用onDataReloaded有产生屏幕闪烁的风险。
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
operateData(): void {
const totalCount = this.dataArray.length;
const batch = 5;
for (let i = totalCount; i < totalCount + batch; i++) {
this.dataArray.push(`Hello ${i}`);
}
this.notifyDataReload();
}
}
@Entry
@Component
struct MyComponent {
private moved: number[] = [];
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 10; i++) {
this.data.pushData(`Hello ${i}`);
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: string, index: number) => {
ListItem() {
Row() {
Text(item)
.width('100%')
.height(80)
.backgroundColor(Color.Gray)
.onAppear(() => {
console.info(`appear: ${item}`);
})
}.margin({ left: 10, right: 10 })
}
}, (item: string) => item)
}.cachedCount(10)
.onScrollIndex((start, end, center) => {
if (end === this.data.totalCount() - 1) {
console.info('scroll to end');
this.data.operateData();
}
})
}
}
```
当List下拉到底的时候，屏闪效果如下图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163838.32569164489008389992555852512078:50001231000000:2800:A475DF32FEE5163C03F912DC6948AF9FC25A5A4D9278351C099D301F318D5F81.gif)
用onDatasetChange代替onDataReloaded，不仅可以修复闪屏的问题，还能提升加载性能。
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
operateData(): void {
const totalCount = this.dataArray.length;
const batch = 5;
for (let i = totalCount; i < totalCount + batch; i++) {
this.dataArray.push(`Hello ${i}`);
}
// 替换 notifyDataReload
this.notifyDatasetChange([{ type: DataOperationType.ADD, index: totalCount - 1, count: batch }]);
}
}
@Entry
@Component
struct MyComponent {
private moved: number[] = [];
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 10; i++) {
this.data.pushData(`Hello ${i}`);
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: string, index: number) => {
ListItem() {
Row() {
Text(item)
.width('100%')
.height(80)
.backgroundColor(Color.Gray)
.onAppear(() => {
console.info(`appear: ${item}`);
})
}.margin({ left: 10, right: 10 })
}
}, (item: string) => item)
}.cachedCount(10)
.onScrollIndex((start, end, center) => {
if (end === this.data.totalCount() - 1) {
console.info('scroll to end');
this.data.operateData();
}
})
}
}
```
修复后的效果如下图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163838.77624705425979706950374416058277:50001231000000:2800:DA1F486E7CA7BD3E3C2192A3E29FFABB715115B1E65F42E072F366E8BD353453.gif)
组件复用渲染异常
@Reusable与@ComponentV2混用会导致组件渲染异常。
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: StringData类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: StringData[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): StringData {
return this.dataArray[index];
}
public pushData(data: StringData): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
class StringData {
message: string;
constructor(message: string) {
this.message = message;
}
}
@Entry
@ComponentV2
struct MyComponent {
data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 30; i++) {
this.data.pushData(new StringData(`Hello${i}`));
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (item: StringData, index: number) => {
ListItem() {
ChildComponent({ data: item })
.onAppear(() => {
console.info(`onAppear: ${item.message}`);
})
}
}, (item: StringData, index: number) => index.toString())
}.cachedCount(5)
}
}
@Reusable
@Component
struct ChildComponent {
@State data: StringData = new StringData('');
aboutToAppear(): void {
console.info(`aboutToAppear: ${this.data.message}`);
}
aboutToRecycle(): void {
console.info(`aboutToRecycle: ${this.data.message}`);
}
// 对复用的组件进行数据更新
aboutToReuse(params: Record<string, ESObject>): void {
this.data = params.data as StringData;
console.info(`aboutToReuse: ${this.data.message}`);
}
build() {
Row() {
Text(this.data.message).fontSize(50)
}
}
}
```
反例中，在@ComponentV2装饰的组件MyComponent中，LazyForEach列表中使用了@Reusable装饰的组件ChildComponent，导致组件渲染失败，观察日志可以看到组件触发了onAppear，但是没有触发aboutToAppear。
将@ComponentV2修改为@Component可以修复渲染异常。修复后，当滑动事件触发组件节点下树时，对应的可复用组件ChildComponent从组件树上被加入到复用缓存中而不是被销毁，并触发aboutToRecycle事件，打印日志信息。当滑动需要显示新的节点时，会将可复用的组件从复用缓存中重新加入到节点树，并触发aboutToReuse刷新组件数据，并打印日志信息。
组件不刷新
开发者需要定义合适的键值生成函数，返回与目标数据相关联的键值。目标数据发生改变时，LazyForEach识别到键值改变才会刷新对应组件。
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
private dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
public updateAllData(): void {
this.dataArray = this.dataArray.map((item: string) => item + `!`);
this.notifyDataReload();
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 20; i++) {
this.data.pushData(`Hello ${i}`);
}
}
build() {
Column() {
Button(`update all`)
.onClick(() => {
this.data.updateAllData();
})
List({ space: 3 }) {
LazyForEach(this.data, (item: string) => {
ListItem() {
Text(item).fontSize(50)
}
})
}.cachedCount(5)
}
}
}
```
点击按钮更新数据，组件不刷新。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163838.27625151923482686016049247014912:50001231000000:2800:469B75E7FE7EA6740631B678B6C27B36C7149EC8E6AF2A2A7DB16EC76B83F3C2.gif)
LazyForEach依赖生成的键值判断是否刷新子组件，如果更新的数据没有改变键值（如示例中开发者没有定义键值生成函数，此时键值仅与组件索引index有关，更新数据时键值不变），则LazyForEach不会刷新对应组件。
```typescript
LazyForEach(this.data, (item: string) => {
ListItem() {
Text(item).fontSize(50)
}
}, (item: string) => item) // 定义键值生成函数
```
定义键值生成函数后，点击按钮更新数据，组件刷新。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163838.16211136010229344410947234326699:50001231000000:2800:F02CFD8C5F26AA3EF02E478EB0A7F89A13785CCEBBA81F1277A72DCBF81EE296.gif)
懒加载失效
支持数据懒加载的父组件基于自身和子组件的高度或宽度计算可视范围内应布局的子节点数量，高度或宽度的缺失会导致部分场景懒加载失效。如下示例，在纵向布局中，首次渲染时子组件的高度缺失，所有数据项对应组件都会被创建。
```typescript
/** BasicDataSource代码见文档末尾BasicDataSource示例代码: string类型数组的BasicDataSource代码 **/
class MyDataSource extends BasicDataSource {
public dataArray: string[] = [];
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
public pushData(data: string): void {
this.dataArray.push(data);
this.notifyDataAdd(this.dataArray.length - 1);
}
}
@Entry
@Component
struct MyComponent {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 100; i++) {
this.data.pushData(``);
}
}
build() {
List() {
LazyForEach(this.data, (item: string, index: number) => {
ChildComponent({ message: item, index: index })
// 子组件未设置默认高度，首次渲染时所有数据项对应组件都被创建
// .height(60)
}, (item: string, index: number) => item + index)
}
.cachedCount(2)
}
}
@Component
struct ChildComponent {
message: string = ``;
index: number = -1;
aboutToAppear(): void {
console.info(`about to appear ${this.index}`);
}
build() {
Text(this.message).fontSize(50)
}
}
```
上述示例由于子组件ChildComponent的变量message初始值为空字符串，导致其内部的Text组件高度为 0，同时子组件未显式设置默认高度（如.height(60)），因此在首次渲染时所有子组件的高度均被计算为0。父组件List在基于高度计算可视范围时，判断所有子组件均位于可视区域内，导致懒加载机制失效，最终触发了全部数据项对应组件的创建（可通过日志观察到所有about to appear打印）。
为子组件设置默认高度，确保父组件能正确计算可视范围，从而恢复此场景下懒加载功能。
```typescript
List() {
LazyForEach(this.data, (item: string, index: number) => {
ChildComponent({ message: item, index: index })
// 设置子组件默认高度，首次渲染懒加载生效
.height(60)
}, (item: string, index: number) => item + index)
}
.cachedCount(2)
```
BasicDataSource示例代码
string类型数组的BasicDataSource代码
```typescript
// BasicDataSource实现了IDataSource接口，用于管理listener监听，以及通知LazyForEach数据更新
class BasicDataSource implements IDataSource {
private listeners: DataChangeListener[] = [];
private originDataArray: string[] = [];
public totalCount(): number {
return 0;
}
public getData(index: number): string {
return this.originDataArray[index];
}
// 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听
registerDataChangeListener(listener: DataChangeListener): void {
if (this.listeners.indexOf(listener) < 0) {
console.info('add listener');
this.listeners.push(listener);
}
}
// 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听
unregisterDataChangeListener(listener: DataChangeListener): void {
const pos = this.listeners.indexOf(listener);
if (pos >= 0) {
console.info('remove listener');
this.listeners.splice(pos, 1);
}
}
// 通知LazyForEach组件需要重载所有子组件
notifyDataReload(): void {
this.listeners.forEach(listener => {
listener.onDataReloaded();
});
}
// 通知LazyForEach组件需要在index对应索引处添加子组件
notifyDataAdd(index: number): void {
this.listeners.forEach(listener => {
listener.onDataAdd(index);
// 写法2：listener.onDatasetChange([{type: DataOperationType.ADD, index: index}]);
});
}
// 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件
notifyDataChange(index: number): void {
this.listeners.forEach(listener => {
listener.onDataChange(index);
// 写法2：listener.onDatasetChange([{type: DataOperationType.CHANGE, index: index}]);
});
}
// 通知LazyForEach组件需要在index对应索引处删除该子组件
notifyDataDelete(index: number): void {
this.listeners.forEach(listener => {
listener.onDataDelete(index);
// 写法2：listener.onDatasetChange([{type: DataOperationType.DELETE, index: index}]);
});
}
// 通知LazyForEach组件将from索引和to索引处的子组件进行交换
notifyDataMove(from: number, to: number): void {
this.listeners.forEach(listener => {
listener.onDataMove(from, to);
// 写法2：listener.onDatasetChange(
//         [{type: DataOperationType.EXCHANGE, index: {start: from, end: to}}]);
});
}
notifyDatasetChange(operations: DataOperation[]): void {
this.listeners.forEach(listener => {
listener.onDatasetChange(operations);
});
}
}
```
StringData类型数组的BasicDataSource代码
```typescript
class BasicDataSource implements IDataSource {
private listeners: DataChangeListener[] = [];
private originDataArray: StringData[] = [];
public totalCount(): number {
return 0;
}
public getData(index: number): StringData {
return this.originDataArray[index];
}
registerDataChangeListener(listener: DataChangeListener): void {
if (this.listeners.indexOf(listener) < 0) {
console.info('add listener');
this.listeners.push(listener);
}
}
unregisterDataChangeListener(listener: DataChangeListener): void {
const pos = this.listeners.indexOf(listener);
if (pos >= 0) {
console.info('remove listener');
this.listeners.splice(pos, 1);
}
}
notifyDataReload(): void {
this.listeners.forEach(listener => {
listener.onDataReloaded();
});
}
notifyDataAdd(index: number): void {
this.listeners.forEach(listener => {
listener.onDataAdd(index);
});
}
notifyDataChange(index: number): void {
this.listeners.forEach(listener => {
listener.onDataChange(index);
});
}
notifyDataDelete(index: number): void {
this.listeners.forEach(listener => {
listener.onDataDelete(index);
});
}
notifyDataMove(from: number, to: number): void {
this.listeners.forEach(listener => {
listener.onDataMove(from, to);
});
}
notifyDatasetChange(operations: DataOperation[]): void {
this.listeners.forEach(listener => {
listener.onDatasetChange(operations);
});
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-contentslot
爬取时间: 2025-04-28 07:04:10
来源: Huawei Developer
用于渲染并管理Native层使用C-API创建的组件。
支持混合模式开发，当容器是ArkTS组件，子组件在Native侧创建时，推荐使用ContentSlot占位组件。
接口
ArkTS侧接口
| 接口名 | 描述 |
| --- | --- |
| ContentSlot(content: Content) | Content作为ContentSlot的管理器，通过Native侧提供的接口，可以注册并触发ContentSlot的上下树事件回调以及管理ContentSlot的子组件。 |
```typescript
abstract class Content {
}
```
Native侧接口
| 接口名 | 描述 |
| --- | --- |
| OH_ArkUI_NodeContent_RegisterCallback(ArkUI_NodeContentHandle content, ArkUI_NodeContentCallback callback) | 向管理器Content上注册事件。 |
| OH_ArkUI_NodeContentEvent_GetEventType(ArkUI_NodeContentEvent* event) | 获取Content上触发的事件类型。 |
| OH_ArkUI_NodeContent_AddNode(ArkUI_NodeContentHandle content, ArkUI_NodeHandle node) | 在Content上添加子组件。 |
| OH_ArkUI_NodeContent_InsertNode(ArkUI_NodeContentHandle content, ArkUI_NodeHandle node, int32_t position) | 在Content上插入子组件。 |
| OH_ArkUI_NodeContent_RemoveNode(ArkUI_NodeContentHandle content, ArkUI_NodeHandle node) | 在Content上移除子组件。 |
| OH_ArkUI_GetNodeContentFromNapiValue(napi_env env, napi_value value, ArkUI_NodeContentHandle* content) | 在Native侧获取ArkTS侧Content指针。 |
| OH_ArkUI_NodeContentEvent_GetNodeContentHandle(ArkUI_NodeContentEvent* event) | 获取触发上下树事件的Content对象。 |
| OH_ArkUI_NodeContent_SetUserData(ArkUI_NodeContentHandle content, void* userData) | 在Content上设置用户自定义属性。 |
| OH_ArkUI_NodeContent_GetUserData(ArkUI_NodeContentHandle content) | 在Content上获取用户自定义属性。 |
|  typedef enum { NOTE_CONTENT_EVENT_ON_ATTACH_TO_WINDOW = 0, NOTE_CONTENT_EVENT_ON_DETACH_FROM_WINDOW = 1, } ArkUI_NodeContentEventType | Content上会触发的上树和下树两种事件类型。 |
typedef enum {
NOTE_CONTENT_EVENT_ON_ATTACH_TO_WINDOW = 0,
NOTE_CONTENT_EVENT_ON_DETACH_FROM_WINDOW = 1,
} ArkUI_NodeContentEventType
开发实现
ArkTS侧代码实现
```typescript
import { nativeNode } from 'libNativeNode.so'; // 开发者自己实现的so
import { NodeContent } from '@kit.ArkUI';
@Entry
@Component
struct Parent {
private nodeContent: Content = new NodeContent();
aboutToAppear() {
// 通过C-API创建节点，并添加到管理器nodeContent上
nativeNode.createNativeNode(this.nodeContent);
}
build() {
Column() {
// 显示nodeContent管理器里存放的Native侧的组件
ContentSlot(this.nodeContent)
}
}
}
```
Native侧代码实现
Napi的基础开发知识请查看以下文档：开发导读。
本章节仅描述实现ContentSlot相关逻辑代码。创建C侧组件，具体请查看使用NDK接口构建UI。
注册上下树事件，并通过事件获取对应的Content对象
添加子组件
插入子组件
删除子组件
设置自定义属性
获取自定义属性


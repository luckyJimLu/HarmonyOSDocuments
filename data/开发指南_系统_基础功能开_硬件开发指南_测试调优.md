# 合并文件
合并时间: 2025-04-28 19:43:20

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/basic-services-kit-V14
爬取时间: 2025-04-28 18:50:36
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/basic-services-kit-overview-V14
爬取时间: 2025-04-28 18:50:50
来源: Huawei Developer
Basic Services Kit（基础服务）作为基础服务套件，为应用开发者提供常用的基础能力。比如常用的剪贴板读写、文件上传下载、文件压缩、文件打印、进程间/线程间通信、设备管理、应用账号管理等能力都由本Kit提供。
使用场景
Basic Services Kit为开发者提供了多种基础能力，满足开发者不同场景的开发需求。
典型使用场景举例：
-  剪贴板读写：
-  文件上传下载：
-  进程间/线程间通信：
能力范围
根据不同使用场景分类，本Kit主要包含如下能力：
-  数据文件处理：
-  进程间/线程间通信：
-  设备管理：
-  其他：
与其他kit的关系
-  ArkTS Kit：ArkTS Kit中的多线程并发(Worker和Taskpool)需要使用本Kit中的Emitter进行线程间通信。
-  Ability Kit：Ability Kit中的进程间通信需要使用本Kit中的公共事件。
-  Core File Kit：与Core File Kit的使用场景不同，Core File Kit主要提供访问和管理文件的能力，开发者可以在应用文件访问和文件分享、应用数据备份恢复等场景使用Core File Kit进行开发，而涉及到文件压缩、文件上传下载、文件打印等场景时需要使用本Kit进行开发。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/app-events-V14
爬取时间: 2025-04-28 18:51:04
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/common-event-communication-V14
爬取时间: 2025-04-28 18:51:27
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/common-event-overview-V14
爬取时间: 2025-04-28 18:51:41
来源: Huawei Developer
CES（Common Event Service，公共事件服务）为应用程序提供订阅、发布、退订公共事件的能力。
公共事件分类
公共事件从系统角度可分为：系统公共事件和自定义公共事件。
公共事件按发送方式可分为：无序公共事件、有序公共事件和粘性公共事件。
运作机制
每个应用都可以按需订阅公共事件，订阅成功，当公共事件发布时，系统会将其发送给对应的应用。这些公共事件可能来自系统、其他应用和应用自身。
图1公共事件示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170506.26607607457522525964430892527492:50001231000000:2800:ECCB238A43DB3F0C985E40717DAE156F0AD1E6A88A8904CCC4A889A3D55B0143.png)
安全注意事项

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/common-event-subscription-V14
爬取时间: 2025-04-28 18:51:54
来源: Huawei Developer
场景介绍
动态订阅是指当应用在运行状态时对某个公共事件进行订阅，在运行期间如果有订阅的事件发布那么订阅了这个事件的应用将会收到该事件及其传递的参数。
例如，某应用希望在其运行期间收到电量过低的事件，并根据该事件降低其运行功耗，那么该应用便可动态订阅电量过低事件，收到该事件后关闭一些非必要的任务来降低功耗。
订阅部分系统公共事件需要先申请权限，订阅这些事件所需要的权限请见公共事件权限列表。
订阅者对象的生命周期需要接入方管理，不再使用时需主动销毁释放，避免内存泄漏。
接口说明
详细接口见接口文档。
| 接口名 | 接口描述 |
| --- | --- |
| createSubscriber(subscribeInfo: CommonEventSubscribeInfo, callback: AsyncCallback<CommonEventSubscriber>): void | 创建订阅者对象（callback）。 |
| createSubscriber(subscribeInfo: CommonEventSubscribeInfo): Promise<CommonEventSubscriber> | 创建订阅者对象（promise）。 |
| subscribe(subscriber: CommonEventSubscriber, callback: AsyncCallback<CommonEventData>): void | 订阅公共事件。 |
开发步骤
1.  导入模块。
```typescript
import { BusinessError, commonEventManager } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
const TAG: string = 'ProcessModel';
const DOMAIN_NUMBER: number = 0xFF00;
```
2.  创建订阅者信息，详细的订阅者信息数据类型及包含的参数请见CommonEventSubscribeInfo文档介绍。
```typescript
// 用于保存创建成功的订阅者对象，后续使用其完成订阅及退订的动作
let subscriber: commonEventManager.CommonEventSubscriber | null = null;
// 订阅者信息，其中的event字段需要替换为实际的事件名称。
let subscribeInfo: commonEventManager.CommonEventSubscribeInfo = {
events: ['event'], // 订阅灭屏公共事件
};
```
3.  创建订阅者，保存返回的订阅者对象subscriber，用于执行后续的订阅、退订、接收事件回调等操作。
```typescript
// 创建订阅者回调
commonEventManager.createSubscriber(subscribeInfo, (err: BusinessError, data: commonEventManager.CommonEventSubscriber) => {
if (err) {
hilog.error(DOMAIN_NUMBER, TAG, `Failed to create subscriber. Code is ${err.code}, message is ${err.message}`);
return;
}
hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in creating subscriber.');
subscriber = data;
})
```
4.  创建订阅回调函数，订阅回调函数会在接收到事件时触发。订阅回调函数返回的data内包含了公共事件的名称、发布者携带的数据等信息，公共事件数据的详细参数和数据类型请见CommonEventData文档介绍。
```typescript
// 订阅公共事件回调
if (subscriber !== null) {
commonEventManager.subscribe(subscriber, (err: BusinessError, data: commonEventManager.CommonEventData) => {
if (err) {
hilog.error(DOMAIN_NUMBER, TAG, `Failed to subscribe common event. Code is ${err.code}, message is ${err.message}`);
return;
}
// ...
})
} else {
hilog.error(DOMAIN_NUMBER, TAG, `Need create subscriber`);
}
```
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/common-event-unsubscription-V14
爬取时间: 2025-04-28 18:52:08
来源: Huawei Developer
场景介绍
动态订阅者完成业务需求后，应主动取消订阅。通过调用unsubscribe()方法，取消订阅事件。
接口说明
| 接口名 | 接口描述 |
| --- | --- |
| unsubscribe(subscriber: CommonEventSubscriber, callback?: AsyncCallback<void>) | 取消订阅公共事件。 |
开发步骤
1.  导入模块。
```typescript
import { BusinessError, commonEventManager } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
const TAG: string = 'ProcessModel';
const DOMAIN_NUMBER: number = 0xFF00;
```
2.  根据动态订阅公共事件章节的步骤来订阅某个事件。
3.  调用CommonEvent中的unsubscribe()方法取消订阅某事件。
```typescript
// subscriber为订阅事件时创建的订阅者对象
if (subscriber !== null) {
commonEventManager.unsubscribe(subscriber, (err: BusinessError) => {
if (err) {
hilog.error(DOMAIN_NUMBER, TAG, `Failed to unsubscribe. code is ${err.code}, message is ${err.message}`);
} else {
hilog.info(DOMAIN_NUMBER, TAG, `Succeeded in unsubscribing.`);
subscriber = null;
}
})
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/common-event-publish-V14
爬取时间: 2025-04-28 18:52:22
来源: Huawei Developer
场景介绍
当需要发布某个自定义公共事件时，可以通过publish()方法发布事件。发布的公共事件可以携带数据，供订阅者解析并进行下一步处理。
已发出的粘性公共事件后来订阅者也可以接收到，其他公共事件都需要先订阅再接收，订阅参考公共事件订阅章节。
接口说明
详细接口见接口文档。
| 接口名 | 接口描述 |
| --- | --- |
| publish(event: string, callback: AsyncCallback<void>) | 发布公共事件。 |
| publish(event: string, options: CommonEventPublishData, callback: AsyncCallback<void>) | 指定发布信息并发布公共事件。 |
发布不携带信息的公共事件
不携带信息的公共事件，只能发布无序公共事件。
1.  导入模块。
```typescript
import { BusinessError, commonEventManager } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
const TAG: string = 'ProcessModel';
const DOMAIN_NUMBER: number = 0xFF00;
```
2.  传入需要发布的事件名称和回调函数，发布事件。
```typescript
// 发布公共事件，其中的event字段需要替换为实际的事件名称。
commonEventManager.publish('event', (err: BusinessError) => {
if (err) {
hilog.error(DOMAIN_NUMBER, TAG, `Publish failed, code is ${JSON.stringify(err.code)}, message is ${JSON.stringify(err.message)}`);
} else {
//...
hilog.info(DOMAIN_NUMBER, TAG, `Publish success`);
}
});
```
发布携带信息的公共事件
携带信息的公共事件，可以发布为无序公共事件、有序公共事件和粘性事件，可以通过参数CommonEventPublishData的isOrdered、isSticky的字段进行设置。
1.  导入模块。
```typescript
import { BusinessError, commonEventManager } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
const TAG: string = 'ProcessModel';
const DOMAIN_NUMBER: number = 0xFF00;
```
2.  构建需要发布的公共事件信息。
```typescript
// 公共事件相关信息
let options: commonEventManager.CommonEventPublishData = {
code: 1, // 公共事件的初始代码
data: 'initial data', // 公共事件的初始数据
};
```
3.  传入需要发布的事件名称、需要发布的指定信息和回调函数，发布事件。
```typescript
// 发布公共事件，其中的event字段需要替换为实际的事件名称。
commonEventManager.publish('event', options, (err: BusinessError) => {
if (err) {
hilog.error(DOMAIN_NUMBER, TAG, `Failed to publish common event. Code is ${err.code}, message is ${err.message}`);
} else {
//...
hilog.info(DOMAIN_NUMBER, TAG, `Succeeded in publishing common event.`);
}
});
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/itc-with-emitter-V14
爬取时间: 2025-04-28 18:52:36
来源: Huawei Developer
Emitter是一种作用在进程内的事件处理机制，为应用程序提供订阅事件、发布事件、取消事件订阅的能力。
场景介绍
Emitter用于同一进程内相同线程或不同线程间的事件处理，事件异步执行。使用时需要先订阅一个事件，然后发布该事件，发布完成后Emitter会将已发布的事件分发给订阅者，订阅者就会执行该事件订阅时设置的回调方法。当不需要订阅该事件时应及时取消订阅释放Emitter资源。
运作机制
Emitter通过维护一个内部事件队列，来进行任务分发。应用需要先订阅某个事件并设置好该事件的回调方法，当应用程序发布事件后，就会往队列里面插入一个事件。任务队列会串行执行队列里面的任务，执行任务时会调用该任务订阅者的回调方法进行事件处理。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170507.78375497514801404324509773767093:50001231000000:2800:56364EE866C7CDFBC171963764E0378C75D7656F8271753571718D98CF1E8C3B.png)
接口说明
详细请参见Emitter接口文档。
| 接口名 | 用途 | 说明 |
| --- | --- | --- |
| on | 订阅事件 | 持续订阅事件，直至该事件被取消订阅。 |
| once | 订阅事件 | 订阅事件一次。 |
| emit | 发布事件 | 发布事件一次。 |
| off | 取消事件订阅 | 取消事件订阅后，将不再接收该事件的消息。 |
开发步骤
使用Emitter实现事件订阅、事件发送以及事件删除，开发步骤如下。
1.  导入模块。
```typescript
import { emitter } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
const TAG: string = 'ProcessModel';
const DOMAIN_NUMBER: number = 0xFF00;
```
2.  订阅事件。 订阅事件使用on（持续订阅）或者once（单次订阅）接口进行订阅，设置要订阅的事件以及接收到事件后的回调函数。
```typescript
// 定义一个eventId为1的事件。
let event: emitter.InnerEvent = {
eventId: 1
};
// on订阅事件，收到eventId为1的事件后执行回调函数。
emitter.on(event, () => {
hilog.info(DOMAIN_NUMBER, TAG, 'on callback');
});
```
3.  发送事件。 发送事件使用emit接口进行发送，设置要发送的事件以及要传递的参数。
```typescript
// 定义一个eventId为1的事件，事件优先级为Low。
let event: emitter.InnerEvent = {
eventId: 1,
priority: emitter.EventPriority.LOW
};
//订阅该事件，并接收eventData数据。
emitter.once(event, (eventData : emitter.EventData) => {
hilog.info(DOMAIN_NUMBER, TAG, 'enter callback, eventData-content:' + eventData?.data?.content);
hilog.info(DOMAIN_NUMBER, TAG, 'enter callback, eventData-id:' + eventData?.data?.id);
hilog.info(DOMAIN_NUMBER, TAG, 'enter callback, eventData-isEmpty:' + eventData?.data?.isEmpty);
});
let eventData: emitter.EventData = {
data: {
content: 'emitter',
id: 1,
isEmpty: false
}
};
// 发送eventId为1的事件，事件内容为eventData。
emitter.emit(event, eventData);
```
4.  取消事件订阅。 当不需要订阅某个事件时，需要及时取消订阅避免造成内存泄漏。 取消事件订阅使用off接口进行取消，设置要取消的事件ID。
```typescript
// 取消eventId为1的事件。
emitter.off(1);
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/account-management-V14
爬取时间: 2025-04-28 18:52:49
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/application-account-V14
爬取时间: 2025-04-28 18:53:03
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/manage-application-account-V14
爬取时间: 2025-04-28 18:53:57
来源: Huawei Developer
应用开发者可以使用应用账号SDK管理本应用的账号数据。
能力限制：应用卸载场景下，被卸载应用的账号数据会被删除；本地账号删除场景下，被删除本地账号下的所有应用的账号数据会被删除。
开发准备
1.  导入应用账号模块。
```typescript
import { appAccount, BusinessError } from '@kit.BasicServicesKit';
```
2.  获取应用账号的实例对象。
```typescript
const appAccountManager = appAccount.createAppAccountManager();
```
创建应用账号
用户在应用中登录后，开发者可以在系统中创建一个关联的应用账号，后续可以基于此账号进行数据管理。
具体开发实例如下：
1.  参数准备，指定账号名和可选配置。
```typescript
let name: string = "ZhangSan";
let options: appAccount.CreateAccountOptions = {
customData: {
age: '10'
}
};
```
2.  调用createAccount接口，根据名称和选项创建应用账号。
```typescript
try {
await appAccountManager.createAccount(name, options);
console.log('createAccount successfully');
} catch (err) {
console.log('createAccount failed, error: ' + JSON.stringify(err));
}
```
查询应用账号列表
具体开发实例如下：
调用getAllAccounts接口查询账号列表。
```typescript
appAccountManager.getAllAccounts().then((data: appAccount.AppAccountInfo[]) => {
console.debug('getAllAccounts successfully, data: ' + JSON.stringify(data));
}).catch((err: BusinessError) => {
console.debug('getAllAccounts failed, error: ' + JSON.stringify(err));
});
```
存取账号的凭据
具体开发实例如下：
1.  准备参数，指定账号名、凭据类型和凭据。
```typescript
let name: string = 'ZhangSan';
let credentialType: string = 'PIN_SIX';
let credential: string = 'xxxxxx';
```
2.  调用getCredential接口，获取账号的凭据。
```typescript
appAccountManager.getCredential(name, credentialType).then((data: string) => {
console.log('getCredential successfully, data: ' + data);
}).catch((err: BusinessError) => {
console.log('getCredential failed, error: ' + JSON.stringify(err));
});
```
3.  调用setCredential接口，设置账号的凭据。
```typescript
appAccountManager.setCredential(name, credentialType, credential).then(() => {
console.log('setCredential successfully');
}).catch((err: BusinessError) => {
console.log('setCredential failed: ' + JSON.stringify(err));
});
```
存取账号的自定义数据
具体开发实例如下：
1.  准备参数，指定账号名和自定义键值。
```typescript
let name: string = 'ZhangSan';
let key: string = 'age';
let value: string = '12';
```
2.  调用setCustomData接口，设置账号的自定义数据。
```typescript
appAccountManager.setCustomData(name, key, value).then(() => {
console.log('setCustomData successfully');
}).catch((err: BusinessError) => {
console.log('setCustomData failed: ' + JSON.stringify(err));
});
```
3.  调用getCustomData接口，获取账号的自定义数据。
```typescript
appAccountManager.getCustomData(name, key).then((data: string) => {
console.log('getCustomData successfully, data: ' + data);
}).catch((err: BusinessError) => {
console.log('getCustomData failed, error: ' + JSON.stringify(err));
});
```
存取账号的授权令牌
具体开发实例如下：
1.  准备参数，指定账号名、账号所有者、授权类型和授权令牌。
```typescript
let name: string = 'ZhangSan';
let owner: string = 'com.example.accountjsdemo';
let authType: string = 'getSocialData';
let token: string = 'xxxxxx';
```
2.  调用setAuthToken接口，设置指定授权类型的授权令牌。
```typescript
appAccountManager.setAuthToken(name, authType, token).then(() => {
console.log('setAuthToken successfully');
}).catch((err: BusinessError) => {
console.log('setAuthToken failed: ' + JSON.stringify(err));
});
```
3.  调用getAuthToken接口，获取指定授权类型的授权令牌。
```typescript
appAccountManager.getAuthToken(name, owner, authType).then((data: string) => {
console.log('getAuthToken successfully, data: ' + data);
}).catch((err: BusinessError) => {
console.log('getAuthToken failed, error: ' + JSON.stringify(err));
});
```
删除应用账号
用户退出登录后，应用需及时将相应的应用账号从系统中删除。
具体开发实例如下：
指定要删除的账号名称，调用removeAccount接口删除账号。
```typescript
let name: string = 'Zhangsan';
appAccountManager.removeAccount(name).then(() => {
console.log('removeAccount successfully');
}).catch((err: BusinessError) => {
console.log('removeAccount failed, error: ' + JSON.stringify(err));
});
```
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/usb-V14
爬取时间: 2025-04-28 18:54:10
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/usb-overview-V14
爬取时间: 2025-04-28 18:55:04
来源: Huawei Developer
基本概念
USB服务是应用访问底层的一种设备抽象概念。开发者根据提供的USB API，可以获取设备列表、控制设备访问权限、以及与连接的设备进行数据传输、控制命令传输等。
运作机制
USB服务系统包含USB API、USB Service、USB HAL。
图1USB服务运作机制
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170507.01395544830374294839912168031872:50001231000000:2800:8A5F067A599D8686FA8638111AF833F89419F36B7DEDE7C04C0A8073CEA713A6.png)
-  USB API：提供USB的基础API，主要包含查询USB设备列表、批量数据传输、控制命令传输、权限控制等。
-  USB Service：主要实现HAL层数据的接收、解析、分发以及对设备的管理等。
-  USB HAL层：提供给用户态可直接调用的驱动能力接口。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/usb-guidelines-V14
爬取时间: 2025-04-28 18:55:17
来源: Huawei Developer
场景介绍
Host模式下，可以获取到已经连接的USB设备列表，并根据需要打开和关闭设备、控制设备权限、进行数据传输等。
接口说明
USB服务主要提供的功能有：查询USB设备列表、批量数据传输、控制命令传输、权限控制等。
USB类开放能力如下，具体请查阅API参考文档。
表1USB类的开放能力接口
| 接口名 | 描述 |
| --- | --- |
| hasRight(deviceName: string): boolean | 判断是否有权访问该设备。 |
| requestRight(deviceName: string): Promise<boolean> | 请求软件包的临时权限以访问设备。使用Promise异步回调。 |
| removeRight(deviceName: string): boolean | 移除软件包对设备的访问权限。 |
| connectDevice(device: USBDevice): Readonly<USBDevicePipe> | 根据getDevices()返回的设备信息打开USB设备。如果USB服务异常，可能返回undefined，注意需要对接口返回值做判空处理。 |
| getDevices(): Array<Readonly<USBDevice>> | 获取接入主设备的USB设备列表。如果没有设备接入，那么将会返回一个空的列表。开发者模式关闭时，如果没有设备接入，接口可能返回undefined，注意需要对接口返回值做判空处理。 |
| setConfiguration(pipe: USBDevicePipe, config: USBConfiguration): number | 设置设备的配置。 |
| setInterface(pipe: USBDevicePipe, iface: USBInterface): number | 设置设备的接口。 |
| claimInterface(pipe: USBDevicePipe, iface: USBInterface, force ?: boolean): number | 注册通信接口。 |
| bulkTransfer(pipe: USBDevicePipe, endpoint: USBEndpoint, buffer: Uint8Array, timeout ?: number): Promise<number> | 批量传输。 |
| closePipe(pipe: USBDevicePipe): number | 关闭设备消息控制通道。 |
| releaseInterface(pipe: USBDevicePipe, iface: USBInterface): number | 释放注册过的通信接口。 |
| getFileDescriptor(pipe: USBDevicePipe): number | 获取文件描述符。 |
| getRawDescriptor(pipe: USBDevicePipe): Uint8Array | 获取原始的USB描述符。如果USB服务异常，可能返回undefined，注意需要对接口返回值做判空处理。 |
| usbControlTransfer(pipe: USBDevicePipe, requestparam: USBDeviceRequestParams, timeout?: number): Promise<number> | 控制传输。 |
开发步骤
USB设备可作为Host设备连接Device设备进行数据传输。开发示例如下：
1.  获取设备列表。
```typescript
// 导入USB接口api包。
import { usbManager } from '@kit.BasicServicesKit';
// 获取设备列表。
let deviceList : Array<usbManager.USBDevice> = usbManager.getDevices();
/*
deviceList结构示例
[
{
name: "1-1",
serial: "",
manufacturerName: "",
productName: "",
version: "",
vendorId: 7531,
productId: 2,
clazz: 9,
subClass: 0,
protocol: 1,
devAddress: 1,
busNum: 1,
configs: [
{
id: 1,
attributes: 224,
isRemoteWakeup: true,
isSelfPowered: true,
maxPower: 0,
name: "1-1",
interfaces: [
{
id: 0,
protocol: 0,
clazz: 9,
subClass: 0,
alternateSetting: 0,
name: "1-1",
endpoints: [
{
address: 129,
attributes: 3,
interval: 12,
maxPacketSize: 4,
direction: 128,
number: 1,
type: 3,
interfaceId: 0,
}
]
}
]
}
]
}
]
*/
```
2.  获取设备操作权限。
```typescript
import { usbManager } from '@kit.BasicServicesKit';
import { BusinessError } from '@kit.BasicServicesKit';
let deviceName : string = deviceList[0].name;
// 申请操作指定的device的操作权限。
usbManager.requestRight(deviceName).then((hasRight : boolean) => {
console.info("usb device request right result: " + hasRight);
}).catch((error : BusinessError)=> {
console.info("usb device request right failed : " + error);
});
```
3.  打开Device设备。
```typescript
// 打开设备，获取数据传输通道。
let pipe : usbManager.USBDevicePipe = usbManager.connectDevice(deviceList[0]);
let interface1 : usbManager.USBInterface = deviceList[0].configs[0].interfaces[0];
/*
打开对应接口，在设备信息（deviceList）中选取对应的interface。
interface1为设备配置中的一个接口。
*/
usbManager.claimInterface(pipe, interface1, true);
```
4.  数据传输。当前仅支持批量传输和控制传输。
```typescript
import { usbManager } from '@kit.BasicServicesKit';
import { BusinessError } from '@kit.BasicServicesKit';
/*
读取数据，在device信息中选取对应数据接收的endpoint来做数据传输
（endpoint.direction == 0x80）；dataUint8Array是要读取的数据，类型为Uint8Array。
*/
let inEndpoint : usbManager.USBEndpoint = interface1.endpoints[2];
let outEndpoint : usbManager.USBEndpoint = interface1.endpoints[1];
let dataUint8Array : Uint8Array = new Uint8Array(1024);
usbManager.bulkTransfer(pipe, inEndpoint, dataUint8Array, 15000).then((dataLength : number) => {
if (dataLength >= 0) {
console.info("usb readData result Length : " + dataLength);
} else {
console.info("usb readData failed : " + dataLength);
}
}).catch((error : BusinessError) => {
console.info("usb readData error : " + JSON.stringify(error));
});
// 发送数据，在device信息中选取对应数据发送的endpoint来做数据传输。（endpoint.direction == 0）
usbManager.bulkTransfer(pipe, outEndpoint, dataUint8Array, 15000).then((dataLength : number) => {
if (dataLength >= 0) {
console.info("usb writeData result write length : " + dataLength);
} else {
console.info("writeData failed");
}
}).catch((error : BusinessError) => {
console.info("usb writeData error : " + JSON.stringify(error));
});
```
5.  释放接口，关闭设备。
```typescript
usbManager.releaseInterface(pipe, interface1);
usbManager.closePipe(pipe);
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/faqs-usb-V14
爬取时间: 2025-04-28 18:55:31
来源: Huawei Developer
手机USB连接个人电脑时使用usbManager.getDevices获取的设备列表为空
问题现象
手机通过USB方式与个人电脑连接后，在手机侧使用usbManager.getDevices获取设备列表为空，未将个人电脑识别为USB设备。
可能原因
USB设备包括主设备（Host）和从设备（Device）。主设备负责数据传输以及端口管理，从设备为被管理的对象。
usbManager.getDevices接口的作用，是在当前设备作为主设备时去获取所连接的从设备列表。
基于上述情况：
-  设备（如手机）USB连接个人电脑时，个人电脑默认是主设备，手机是从设备。 此时在手机侧调用usbManager.getDevices接口查询到设备列表为空，属于正常现象。
-  设备（如手机）USB连接鼠标键盘时，手机默认是主设备，鼠标键盘时从设备。 此时在手机侧调用usbManager.getDevices接口可以查询到设备列表。
解决措施
确保当前设备作为主设备，所连接的设备为从设备。（部分设备支持主、从两种USB设备模式。此时需要将设备设置为从设备模式，方可被主设备获取。）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/pasteboard-V14
爬取时间: 2025-04-28 18:55:45
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/get-pastedata-permission-guidelines-V14
爬取时间: 2025-04-28 18:55:58
来源: Huawei Developer
概述
API version 12及之后，系统为提升用户隐私安全保护能力，剪贴板读取接口增加权限管控。
涉及接口如下：
| 名称 | 说明 |
| --- | --- |
| getData( callback: AsyncCallback<PasteData>): void | 读取系统剪贴板内容，使用callback异步回调。 |
| getData(): Promise<PasteData> | 读取系统剪贴板内容，使用Promise异步回调。 |
| getDataSync(): PasteData | 读取系统剪贴板内容, 此接口为同步接口。 |
| getUnifiedData(): Promise<udc.UnifiedData> | 从系统剪贴板中读取统一数据对象的数据。 |
| getUnifiedDataSync(): udc.UnifiedData | 从系统剪贴板中读取统一数据对象的数据，此接口为同步接口。 |
| OH_UdmfData * OH_Pasteboard_GetData (OH_Pasteboard *pasteboard, int *status) | 获取剪贴板中的数据。 |
访问剪贴板内容
剪贴板为应用提供如下两种访问内容的方式。
-  使用安全控件 使用安全控件访问剪贴板内容的应用，可以无需申请权限。 已经使用了安全控件的应用无需做任何适配就可以访问剪贴板内容。
-  申请ohos.permission.READ_PASTEBOARD权限 ohos.permission.READ_PASTEBOARD是受限的user_grant（用户授权）权限，使用自定义控件的应用可以通过申请ohos.permission.READ_PASTEBOARD权限，在用户授权的场景下访问剪贴板内容。 权限申请步骤：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/use_pasteboard_to_copy_and_paste-V14
爬取时间: 2025-04-28 18:56:52
来源: Huawei Developer
场景介绍
剪贴板为开发者提供数据的复制粘贴能力。
当需要使用复制粘贴等功能时，例如：复制文字内容到备忘录中粘贴，复制图库照片到文件管理粘贴，就可以通过剪贴板来完成。
约束限制
使用基础数据类型进行复制粘贴
剪贴板支持使用基础数据类型进行复制粘贴，当前支持的基础数据类型有文本、HTML、URI、Want、PixelMap。JS接口与NDK接口支持数据类型不完全一致，使用时须匹配接口支持类型。
新开发的应用建议使用本方案实现复制粘贴功能。
JS接口与NDK接口数据类型对应关系
| JS数据类型 | NDK数据类型 |
| --- | --- |
| MIMETYPE_PIXELMAP : "pixelMap" | UDMF_META_OPENHARMONY_PIXEL_MAP : "HarmonyOS.pixle-map" |
| MIMETYPE_TEXT_HTML : "text/html" | UDMF_META_HTML : "general.html" |
| MIMETYPE_TEXT_PLAIN : "text/plain" | UDMF_META_PLAIN_TEXT : "general.plain-text" |
| MIMETYPE_TEXT_URI : "text/uri" | UDMF_META_GENERAL_FILE_URI : "general.file-uri" |
| MIMETYPE_TEXT_WANT : "text/want" | NDK接口不支持该数据类型。 |
JS数据类型对应剪贴板类型，详见ohos.pasteboard。
NDK数据类型对应统一数据管理框架，详见UDMF。
接口说明
详细接口见接口文档。
使用剪贴板getData接口获取到uri类型数据之后，请使用文件管理的fs.copy接口获取文件。
| 名称 | 说明 |
| --- | --- |
| setData(data: PasteData, callback: AsyncCallback<void>): void | 将数据写入系统剪贴板，使用callback异步回调。 |
| setData(data: PasteData): Promise<void> | 将数据写入系统剪贴板，使用Promise异步回调。 |
| getData( callback: AsyncCallback<PasteData>): void | 读取系统剪贴板内容，使用callback异步回调。 |
| getData(): Promise<PasteData> | 读取系统剪贴板内容，使用Promise异步回调。 |
| getDataSync(): PasteData | 读取系统剪贴板内容, 此接口为同步接口，不能与SetData同线程调用。 |
示例代码
```typescript
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
import { BusinessError, pasteboard } from '@kit.BasicServicesKit';
export default class EntryAbility extends UIAbility {
async onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): Promise<void> {
// 获取系统剪贴板对象
let text = "test";
// 创建一条纯文本类型的剪贴板内容对象
let pasteData = pasteboard.createData(pasteboard.MIMETYPE_TEXT_PLAIN, text);
// 将数据写入系统剪贴板
let systemPasteboard = pasteboard.getSystemPasteboard();
await systemPasteboard.setData(pasteData);
//从系统剪贴板中读取数据
systemPasteboard.getData().then((data) => {
let outputData = data;
// 从剪贴板数据中获取条目数量
let recordCount = outputData.getRecordCount();
// 从剪贴板数据中获取对应条目信息
for (let i = 0; i < recordCount; i++) {
let record = outputData.getRecord(i).toPlainText();
console.log('Get data success, record:' + record);
}
}).catch((error: BusinessError) => {
// 处理异常场景
})
}
}
```
使用统一数据类型进行复制粘贴
为了方便剪贴板与其他应用间进行数据交互，减少数据类型适配的工作量，剪贴板支持使用统一数据对象进行复制粘贴。详细的统一数据对象请见标准化数据通路文档介绍。
剪贴板支持使用基础数据类型进行复制粘贴，当前支持的基础数据类型有文本、HTML。JS接口与NDK接口支持数据类型不完全一致，使用时须匹配接口支持类型。
接口说明
详细接口见接口文档。
| 名称 | 说明 |
| --- | --- |
| setUnifiedData(data: udc.UnifiedData): Promise<void> | 将统一数据对象的数据写入系统剪贴板。 |
| setUnifiedDataSync(data: udc.UnifiedData): void | 将统一数据对象的数据写入系统剪贴板，此接口为同步接口。 |
| getUnifiedData(): Promise<udc.UnifiedData> | 从系统剪贴板中读取统一数据对象的数据。 |
| getUnifiedDataSync(): udc.UnifiedData | 从系统剪贴板中读取统一数据对象的数据，此接口为同步接口。 |
示例代码
```typescript
import {unifiedDataChannel, uniformTypeDescriptor} from '@kit.ArkData';
import {BusinessError, pasteboard} from '@kit.BasicServicesKit';
// 构造一条PlainText数据,并书写获取延时数据的函数。
let plainTextData = new unifiedDataChannel.UnifiedData();
let GetDelayPlainText = ((dataType:string) => {
let plainText = new unifiedDataChannel.PlainText();
plainText.details = {
Key: 'delayPlaintext',
Value: 'delayPlaintext',
};
plainText.textContent = 'delayTextContent';
plainText.abstract = 'delayTextContent';
plainTextData.addRecord(plainText);
return plainTextData;
});
// 向系统剪贴板中存入一条PlainText数据。
let SetDelayPlainText = (() => {
plainTextData.properties.shareOptions = unifiedDataChannel.ShareOptions.CROSS_APP;
// 跨应用使用时设置为CROSS_APP，本应用内使用时设置为IN_APP
plainTextData.properties.getDelayData = GetDelayPlainText;
pasteboard.getSystemPasteboard().setUnifiedData(plainTextData).then(()=>{
// 存入成功，处理正常场景
}).catch((error: BusinessError) => {
// 处理异常场景
});
})
// 从系统剪贴板中读取这条text数据
let GetPlainTextUnifiedData = (() => {
pasteboard.getSystemPasteboard().getUnifiedData().then((data) => {
let outputData = data;
let records = outputData.getRecords();
if (records[0].getType() == uniformTypeDescriptor.UniformDataType.PLAIN_TEXT) {
let record = records[0] as unifiedDataChannel.PlainText;
console.log('GetPlainText success, type:' + records[0].getType + ', details:' +
JSON.stringify(record.details) + ', textContent:' + record.textContent + ', abstract:' + record.abstract);
} else {
console.log('Get Plain Text Data No Success, Type is: ' + records[0].getType());
}
}).catch((error: BusinessError) => {
//处理异常场景
})
})
```
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/native-use-pasteboard-V14
爬取时间: 2025-04-28 18:57:05
来源: Huawei Developer
场景介绍
剪贴板为开发者提供数据的复制粘贴能力。支持对纯文本、超本文、URI等内容的操作。
基本概念
约束限制
接口说明
详细接口见Pasteboard文档。
| 接口名称 | 描述 |
| --- | --- |
| OH_PasteboardObserver* OH_PasteboardObserver_Create() | 创建一个剪贴板数据变更观察者对象。 |
| OH_PasteboardObserver_Destroy(OH_PasteboardObserver* observer) | 销毁剪贴板数据变更观察者对象。 |
| int OH_PasteboardObserver_SetData(OH_PasteboardObserver* observer, void* context, const Pasteboard_Notify callback, const Pasteboard_Finalize finalize) | 将剪贴板变更回调函数设置到剪贴板数据变更观察者对象中。 |
| OH_Pasteboard* OH_Pasteboard_Create() | 创建一个剪贴板实例。 |
| void OH_Pasteboard_Destroy(OH_Pasteboard* pasteboard) | 销毁剪贴板实例。 |
| int OH_Pasteboard_Subscribe(OH_Pasteboard* pasteboard, int type, const OH_PasteboardObserver* observer) | 订阅剪贴板的数据变更。 |
| int OH_Pasteboard_Unsubscribe(OH_Pasteboard* pasteboard, int type, const OH_PasteboardObserver* observer) | 取消对剪贴板数据变更的订阅。 |
| bool OH_Pasteboard_IsRemoteData(OH_Pasteboard* pasteboard) | 判断剪贴板中的数据是否来自远端设备。 |
| int OH_Pasteboard_GetDataSource(OH_Pasteboard* pasteboard, char* source, unsigned int len) | 获取剪贴板中数据的数据源。 |
| bool OH_Pasteboard_HasType(OH_Pasteboard* pasteboard, const char* type) | 判断剪贴板中是否有指定类型的数据。 |
| bool OH_Pasteboard_HasData(OH_Pasteboard* pasteboard) | 检查剪贴板中是否有数据。 |
| OH_UdmfData* OH_Pasteboard_GetData(OH_Pasteboard* pasteboard, int* status) | 获取剪贴板中的数据。 |
| int OH_Pasteboard_SetData(OH_Pasteboard* pasteboard, OH_UdmfData* data) | 向剪贴板中写入数据。 |
| int OH_Pasteboard_ClearData(OH_Pasteboard* pasteboard) | 清空剪贴板中的数据。 |
| void (*Pasteboard_Notify)(void* context, Pasteboard_NotifyType type) | 剪贴板中数据变更回调函数。 |
| void (*Pasteboard_Finalize)(void* context) | 剪贴板数据变更观察者对象销毁时，释放context上下文资源。 |
开发步骤
1.  添加动态链接库。
2.  引用头文件。
3.  定义剪贴板变化监听的回调函数。
4.  订阅剪贴板变化。
5.  向剪贴板写入数据。
6.  从剪贴板读取数据。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/pasteboard-time-lapse-copy-and-paste-V14
爬取时间: 2025-04-28 18:57:19
来源: Huawei Developer
场景介绍
剪贴板服务主要提供管理系统剪贴板的能力，为系统复制、粘贴功能提供支持。
反复执行复制操作时，剪贴板缓存中会存储多余数据从而导致内存增加，为了优化内存以及后续支持指定数据类型粘贴，剪贴板提供了延迟复制粘贴的功能。
用户复制使用延迟复制技术的应用内的数据时，该条真实数据不会立即写入剪贴板服务的缓存中，而是等需要粘贴时，再从应用获取数据。
约束限制
使用基于Record级别的延迟复制粘贴（推荐）
本方案可以在粘贴前查询数据type信息，应用可以据此决定是否向剪贴板请求数据，因此建议使用本方案实现延迟复制功能。
接口说明
详细接口见Pasteboard文档和UDMF接口文档。
| 名称 | 说明 |
| --- | --- |
| OH_UdmfRecordProvider* OH_UdmfRecordProvider_Create() | 创建一个指向统一数据提供者的指针。 |
| int OH_UdmfRecordProvider_SetData(OH_UdmfRecordProvider* provider, void* context, const OH_UdmfRecordProvider_GetData callback, const UdmfData_Finalize finalize) | 设置统一数据提供者的回调函数。 |
| int OH_UdmfRecord_SetProvider(OH_UdmfRecord* pThis, const char* const* types, unsigned int count, OH_UdmfRecordProvider* provider) | 将统一数据提供者配置到OH_UdmfRecord中。 |
| int OH_Pasteboard_SetData(OH_Pasteboard* pasteboard, OH_UdmfData* data) | 向剪贴板中写入数据。 |
| OH_UdmfData * OH_Pasteboard_GetData (OH_Pasteboard* pasteboard, int* status) | 获取剪贴板中的数据。 |
| OH_UdmfRecord** OH_UdmfData_GetRecords(OH_UdmfData* pThis, unsigned int* count) | 获取OH_UdmfData中全部的数据记录。 |
开发步骤
下面以纯文本类型和HTML类型数据为例，说明如何向剪贴板服务设置延迟复制数据。
为了代码可读性，代码中省略了各个步骤操作结果的校验，实际开发中需要确认每次调用的成功。
1.  引用头文件。
2.  定义OH_UdmfRecordProvider的数据提供函数和实例注销回调函数。
3.  在剪贴板中准备延迟复制数据。需要注意，此步骤完成后纯文本类型数据与HTML类型数据并未真正写入剪贴板服务，只有当数据使用者从OH_UdmfRecord中获取OH_UdsPlainText或OH_UdsHtml时，才会触发上文定义的GetDataCallback数据提供函数，从中得到数据。
4.  从剪贴板获取延迟复制数据。
5.  使用完毕后需要及时释放相关对象的内存。
使用基于PasteData级别的延迟复制粘贴
本方案不支持粘贴前对数据type的查询。
接口说明
| 名称 | 说明 |
| --- | --- |
| setUnifiedData(data: udc.UnifiedData): Promise<void> | 将统一数据类型的数据写入系统剪贴板，在使用延迟复制粘贴功能时，不可与getUnifiedDataSync同线程调用。 |
| setUnifiedDataSync(data: udc.UnifiedData): void | 将统一数据类型的数据写入系统剪贴板，此接口为同步接口，在使用延迟复制粘贴功能时，不可与getUnifiedDataSync同线程调用。 |
| getUnifiedData(): Promise<udc.UnifiedData> | 从系统剪贴板中读取统一数据类型的数据。 |
| getUnifiedDataSync(): udc.UnifiedData | 从系统剪贴板中读取统一数据类型的数据，此接口为同步接口，在使用延迟复制粘贴功能时，不可与setUnifiedData和setUnifiedDataSync同线程调用。 |
| setAppShareOptions(shareOptions: ShareOption): void | 应用设置本应用剪贴板数据的可粘贴范围。 |
| removeAppShareOptions(): void | 应用删除本应用设置的剪贴板数据可粘贴范围配置。 |
开发步骤
1.  导入pasteboard,unifiedDataChannel和uniformTypeDescriptor模块。
2.  构造一条PlainText数据,并书写获取延时数据的函数。
```typescript
let plainTextData = new unifiedDataChannel.UnifiedData();
let GetDelayPlainText = ((dataType:string) => {
let plainText = new unifiedDataChannel.PlainText();
plainText.details = {
Key: 'delayPlaintext',
Value: 'delayPlaintext',
};
plainText.textContent = 'delayTextContent';
plainText.abstract = 'delayTextContent';
plainTextData.addRecord(plainText);
return plainTextData;
});
```
3.  向系统剪贴板中存入一条PlainText数据。
```typescript
let SetDelayPlainText = (() => {
plainTextData.properties.shareOptions = unifiedDataChannel.ShareOptions.CROSS_APP;
// 跨应用使用时设置为CROSS_APP，本应用内使用时设置为IN_APP
plainTextData.properties.getDelayData = GetDelayPlainText;
pasteboard.getSystemPasteboard().setUnifiedData(plainTextData).then(()=>{
// 存入成功，处理正常场景
}).catch((error: BusinessError) => {
// 处理异常场景
});
})
```
4.  从系统剪贴板中读取这条text数据。
```typescript
let GetPlainTextUnifiedData = (() => {
pasteboard.getSystemPasteboard().getUnifiedData().then((data) => {
let outputData = data;
let records = outputData.getRecords();
if (records[0].getType() == uniformTypeDescriptor.UniformDataType.PLAIN_TEXT) {
let record = records[0] as unifiedDataChannel.PlainText;
console.log('GetPlainText success, type:' + records[0].getType + ', details:' +
JSON.stringify(record.details) + ', textContent:' + record.textContent + ', abstract:' + record.abstract);
} else {
console.log('Get Plain Text Data No Success, Type is: ' + records[0].getType());
}
}).catch((error: BusinessError) => {
//处理异常场景
})
})
```
5.  应用设置本应用剪贴板数据的可粘贴范围。
```typescript
let systemPasteboard: pasteboard.SystemPasteboard = pasteboard.getSystemPasteboard();
try {
systemPasteboard.setAppShareOptions(pasteboard.ShareOption.INAPP);
console.info('Set app share options success.');
} catch (err) {
let error: BusinessError = err as BusinessError;
//处理异常场景
}
```
6.  应用删除本应用设置的剪贴板数据可粘贴范围配置。
```typescript
let systemPasteboard: pasteboard.SystemPasteboard = pasteboard.getSystemPasteboard();
try {
systemPasteboard.removeAppShareOptions();
console.info('Remove app share options success.');
} catch (err) {
let error: BusinessError = err as BusinessError;
//处理异常场景
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/upload-download-V14
爬取时间: 2025-04-28 18:57:33
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/app-file-upload-download-V14
爬取时间: 2025-04-28 18:57:46
来源: Huawei Developer
应用可以将应用文件上传到网络服务器，也可以从网络服务器下载网络资源文件到本地应用文件目录。
上传应用文件
开发者可以使用上传下载模块（ohos.request）的上传接口将本地文件上传。文件上传过程使用系统服务代理完成，在api12中request.agent.create接口增加了设置代理地址参数，支持用户设置自定义代理地址。
当前上传应用文件功能，仅支持上传应用缓存文件路径（cacheDir）下的文件。
使用上传下载模块，需声明权限：ohos.permission.INTERNET。
以下示例代码演示两种将应用缓存文件路径下的文件上传至网络服务器的方式:
```typescript
// 方式一:request.uploadFile
// pages/xxx.ets
import { common } from '@kit.AbilityKit';
import fs from '@ohos.file.fs';
import { BusinessError, request } from '@kit.BasicServicesKit';
// 获取应用文件路径
let context = getContext(this) as common.UIAbilityContext;
let cacheDir = context.cacheDir;
// 新建一个本地应用文件
let file = fs.openSync(cacheDir + '/test.txt', fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);
fs.writeSync(file.fd, 'upload file test');
fs.closeSync(file);
// 上传任务配置项
let files: Array<request.File> = [
//uri前缀internal://cache 对应cacheDir目录
{ filename: 'test.txt', name: 'test', uri: 'internal://cache/test.txt', type: 'txt' }
]
let data: Array<request.RequestData> = [{ name: 'name', value: 'value' }];
let uploadConfig: request.UploadConfig = {
url: 'https://xxx',
header: {
'key1':'value1',
'key2':'value2'
},
method: 'POST',
files: files,
data: data
}
// 将本地应用文件上传至网络服务器
try {
request.uploadFile(context, uploadConfig)
.then((uploadTask: request.UploadTask) => {
uploadTask.on('complete', (taskStates: Array<request.TaskState>) => {
for (let i = 0; i < taskStates.length; i++) {
console.info(`upload complete taskState: ${JSON.stringify(taskStates[i])}`);
}
});
})
.catch((err: BusinessError) => {
console.error(`Invoke uploadFile failed, code is ${err.code}, message is ${err.message}`);
})
} catch (error) {
let err: BusinessError = error as BusinessError;
console.error(`Invoke uploadFile failed, code is ${err.code}, message is ${err.message}`);
}
```
```typescript
// 方式二:request.agent
// pages/xxx.ets
import { common } from '@kit.AbilityKit';
import fs from '@ohos.file.fs';
import { BusinessError, request } from '@kit.BasicServicesKit';
// 获取应用文件路径
let context = getContext(this) as common.UIAbilityContext;
let cacheDir = context.cacheDir;
// 新建一个本地应用文件
let file = fs.openSync(cacheDir + '/test.txt', fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);
fs.writeSync(file.fd, 'upload file test');
fs.closeSync(file);
let attachments: Array<request.agent.FormItem> = [{
name: "test",
value: [
{
filename: "test.txt",
path: "./test.txt",
},
]
}];
let config: request.agent.Config = {
action: request.agent.Action.UPLOAD,
url: 'http://xxx',
mode: request.agent.Mode.FOREGROUND,
overwrite: true,
method: "POST",
headers: {
'key1':'value1',
'key2':'value2'
},
data: attachments,
saveas: "./"
};
request.agent.create(getContext(), config).then((task: request.agent.Task) => {
task.start((err: BusinessError) => {
if (err) {
console.error(`Failed to start the upload task, Code: ${err.code}  message: ${err.message}`);
return;
}
});
task.on('progress', async(progress) => {
console.warn(`/Request upload status ${progress.state}, uploaded ${progress.processed}`);
})
task.on('completed', async() => {
console.warn(`/Request upload completed`);
//该方法需用户管理任务生命周期，任务结束后调用remove释放task对象
request.agent.remove(task.tid);
})
}).catch((err: BusinessError) => {
console.error(`Failed to create a upload task, Code: ${err.code}, message: ${err.message}`);
});
```
下载网络资源文件至应用文件目录
开发者可以使用上传下载模块（ohos.request）的下载接口将网络资源文件下载到应用文件目录。对已下载的网络资源文件，开发者可以使用基础文件IO接口（ohos.file.fs）对其进行访问，使用方式与应用文件访问一致。文件下载过程使用系统服务代理完成，在api12中request.agent.create接口增加了设置代理地址参数，支持用户设置自定义代理地址。
当前网络资源文件仅支持下载至应用文件目录。
使用上传下载模块，需声明权限：ohos.permission.INTERNET。
以下示例代码演示两种将网络资源文件下载到应用文件目录的方式：
```typescript
// 方式一:request.downloadFile
// pages/xxx.ets
// 将网络资源文件下载到应用文件目录并读取一段内容
import { common } from '@kit.AbilityKit';
import fs from '@ohos.file.fs';
import { BusinessError, request } from '@kit.BasicServicesKit';
import { buffer } from '@kit.ArkTS';
// 获取应用文件路径
let context = getContext(this) as common.UIAbilityContext;
let filesDir = context.filesDir;
try {
request.downloadFile(context, {
url: 'https://xxxx/xxxx.txt',
filePath: filesDir + '/xxxx.txt'
}).then((downloadTask: request.DownloadTask) => {
downloadTask.on('complete', () => {
console.info('download complete');
let file = fs.openSync(filesDir + '/xxxx.txt', fs.OpenMode.READ_WRITE);
let arrayBuffer = new ArrayBuffer(1024);
let readLen = fs.readSync(file.fd, arrayBuffer);
let buf = buffer.from(arrayBuffer, 0, readLen);
console.info(`The content of file: ${buf.toString()}`);
fs.closeSync(file);
})
}).catch((err: BusinessError) => {
console.error(`Invoke downloadTask failed, code is ${err.code}, message is ${err.message}`);
});
} catch (error) {
let err: BusinessError = error as BusinessError;
console.error(`Invoke downloadFile failed, code is ${err.code}, message is ${err.message}`);
}
```
```typescript
// 方式二:request.agent
// pages/xxx.ets
// 将网络资源文件下载到应用文件目录并读取一段内容
import { BusinessError, request } from '@kit.BasicServicesKit';
let context = getContext(this) as common.UIAbilityContext;
let filesDir = context.filesDir;
let config: request.agent.Config = {
action: request.agent.Action.DOWNLOAD,
url: 'https://xxxx/test.txt',
saveas: 'xxxx.txt',
gauge: true,
overwrite: true,
network: request.agent.Network.WIFI,
};
request.agent.create(context, config).then((task: request.agent.Task) => {
task.start((err: BusinessError) => {
if (err) {
console.error(`Failed to start the download task, Code: ${err.code}  message: ${err.message}`);
return;
}
});
task.on('progress', async(progress) => {
console.warn(`/Request download status ${progress.state}, downloaded ${progress.processed}`);
})
task.on('completed', async() => {
console.warn(`/Request download completed`);
let file = fs.openSync(filesDir + '/xxxx.txt', fs.OpenMode.READ_WRITE);
let arrayBuffer = new ArrayBuffer(1024);
let readLen = fs.readSync(file.fd, arrayBuffer);
let buf = buffer.from(arrayBuffer, 0, readLen);
console.info(`The content of file: ${buf.toString()}`);
fs.closeSync(file);
//该方法需用户管理任务生命周期，任务结束后调用remove释放task对象
request.agent.remove(task.tid);
})
}).catch((err: BusinessError) => {
console.error(`Failed to create a download task, Code: ${err.code}, message: ${err.message}`);
});
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ffrt-kit-V14
爬取时间: 2025-04-28 18:58:00
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ffrt-overview-V14
爬取时间: 2025-04-28 18:58:14
来源: Huawei Developer
简介
FFRT: Function Flow Runtime，一种并发编程框架，旨在简化并发编程和任务调度的复杂性。FFRT采用基于任务的调度方式，开发者只需关注任务及其依赖关系，而无需处理底层的线程和计算资源；同时，FFRT采用基于协程的任务执行方式，可以提高任务并行度、提升线程利用率并充分利用多核平台的计算资源，保证系统对所有资源的集约化管理，最终解决系统线程资源滥用问题，打造极致用户体验。
基本概念
简要说明一下FFRT开发指南中出现或将会出现的一些基本概念：
两种编程模型对比
|   | 线程编程模型 | 任务编程模型 |
| --- | --- | --- |
| 并行度挖掘方式 | 程序员通过创建多线程并把任务分配到每个线程中执行来挖掘运行时的并行度。 | 程序员（编译器工具或语言特性配合）静态编程时将应用分解成任务及其数据依赖关系，运行时调度器分配任务到工作线程执行。 |
| 谁负责线程创建 | 程序员负责创建线程，线程编程模型无法约束线程的创建，滥用可能造成系统中大量线程。 | FFRT运行时负责工作线程池的创建和管理由调度器负责，程序员无法直接创建线程。 |
| 负载均衡 | 程序员静态编程时将任务映射到线程，映射不合理或任务执行时间不确定造成线程负载不均。 | FFRT运行时根据线程执行状态调度就绪任务到空闲线程执行，减轻了线程负载不均问题。 |
| 调度开销 | 线程调度由内核态调度器完成，调度开销大。 | FFRT运行时在用户态以协程方式调度执行，相比内核线程调度机制更为轻量，减小调度的开销，并可通过硬化调度卸载进一步减小调度开销。 |
| 依赖表达 | 线程创建时即处于可执行状态，执行时与其他线程同步操作，增加线程切换。 | FFRT运行时根据任务创建时显式表达的输入依赖和输出依赖关系判断任务可执行状态，当输入依赖不满足时，任务不被调度执行。 |
FFRT任务编程模型
FFRT编程模型允许开发者通过任务及其依赖关系描述的方式进行应用开发，其主要特性包括Task-Based、Queue-Enabled和Graph-Driven。
Task-Based特性
Task-Based指在Function Flow编程模型中开发者以任务方式来组织应用程序表达，运行时以任务粒度执行调度。
FFRT编程模型中的任务包含以下主要特征：
任务颗粒度影响应用执行性能，颗粒度过小增加调度开销，颗粒度过大降低并行度。FFRT编程模型中任务的目标颗粒度最小为100us量级，开发者应注意合理控制任务颗粒度。
Queue-Enabled特性
Queue-Enabled指在Function Flow编程模型中开发者可以利用任务队列来约束任务的执行顺序和并发度。任务队列包括串行队列和并发队列，两者具有不同的使用场景：
Queue-Enabled特性为开发者提供了灵活的任务调度方式，开发者可以根据具体需求选择合适的任务执行策略，从而优化应用程序的性能。
Graph-Driven特性
Graph-Driven指Function Flow编程模型中开发者可以通过构建任务依赖图，来管理任务之间的依赖关系，实现复杂任务流的高效调度。
Function Flow编程模型支持两种方式构建任务依赖图：
开发者可以根据各自业务的特点选择合适的任务依赖图构建方式，从而达到简化业务模型，降低开发难度的作用。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ffrt-concurrency-paradigm-V14
爬取时间: 2025-04-28 18:58:27
来源: Huawei Developer
为了应对实际业务中，任务执行顺序固定、灵活优先级调度以及复杂的任务依赖关系等场景，FFRT支持串行队列、并发队列和图依赖三种不同的并发范式。
串行队列（Serial Queue）
串行队列并发范式常用于解决以下场景中的问题：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170508.05401300261164281296975840077203:50001231000000:2800:FC86F59F0AAA924B08F467F4C5E84627CA2DBB6DC4F0C8714748FE54D737EBD5.png)
串行队列并发范式开发样例可以参考串行队列(C)/串行队列(C++)
并发队列（Concurrent Queue）
并发队列并发范式常用于解决以下场景中的问题：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170508.97939761197336401072228927211277:50001231000000:2800:2B8B39AB03F7664A10F9BF8B0BAFA54175F776CF8B309B9B4D97FD3AC1457D8F.png)
并发队列并发范式开发样例可以参考并发队列(C)/并发队列(C++)
图依赖并发（Task Graph）
图依赖并发范式常用于解决以下场景中的问题：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170508.14863500816817779840824750062376:50001231000000:2800:B011158B14FDA5C83E0C0747071D092FA1FA37AEB32CB563BA19537911DBB104.png)
图依赖并发范式开发样例可以参考图依赖并发(C)/图依赖并发(C++)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ffrt-example-c-V14
爬取时间: 2025-04-28 18:58:41
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ffrt-concurrency-serial-queue-c-V14
爬取时间: 2025-04-28 18:58:54
来源: Huawei Developer
概述
FFRT串行队列基于协程调度模型实现，提供高效的消息队列功能，支持异步通信、流量削峰、无锁化状态和资源管理以及架构解耦等多种业务场景。FFRT串行队列支持以下功能：
示例：异步日志系统
举例实现一个异步日志系统，主线程将日志任务提交到队列，后台线程从队列中取出任务并写入文件。这种方式既能保证日志的顺序性，又能避免文件写入操作阻塞主线程。
借助FFRT并行化框架API，开发者只需专注于业务逻辑的实现，无需关注异步线程管理、线程安全及调度效率等问题。
用例简化了异常处理和线程安全相关的一些逻辑，实现代码如下所示：
C风格构建FFRT任务需要一些额外的封装，封装方式为公共代码，与具体业务场景无关，使用方可以考虑用公共机制封装管理。
接口说明
上述样例中涉及到主要的FFRT的接口包括：
| 名称 | 描述 |
| --- | --- |
| ffrt_queue_create | 创建队列。 |
| ffrt_queue_destroy | 销毁队列。 |
| ffrt_queue_submit | 提交一个任务到队列中调度执行。 |
约束限制

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ffrt-concurrency-concurrent-queue-c-V14
爬取时间: 2025-04-28 18:59:08
来源: Huawei Developer
概述
FFRT并发队列提供了设置任务优先级（Priority）和队列并发度的能力，使得队列中的任务能同时在多个线程上执行，获得更高的并行效果。
示例：银行服务系统
举例实现一个银行服务系统，每个客户向系统提交一个服务请求，可以区分普通用户和VIP用户，VIP用户的服务请求可以优先得到执行。
银行系统中有2个窗口，可以并行取出用户提交的服务请求办理。可以利用FFRT的并行队列范式做如下建模：
实现代码如下所示：
C风格构建FFRT任务需要一些额外的封装，封装方式为公共代码，与具体业务场景无关，使用方可以考虑用公共机制封装管理。
接口说明
上述样例中涉及到主要的FFRT的接口包括：
| 名称 | 描述 |
| --- | --- |
| ffrt_queue_create | 创建队列。 |
| ffrt_queue_destroy | 销毁队列。 |
| ffrt_task_attr_set_queue_priority | 设置队列任务优先级。 |
| ffrt_queue_attr_set_max_concurrency | 设置并发队列的并发度。 |
约束限制

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ffrt-concurrency-graph-c-V14
爬取时间: 2025-04-28 18:59:22
来源: Huawei Developer
概述
FFRT图依赖并发范式支持任务依赖和数据依赖两种方式构建任务依赖图。任务依赖图中每个节点表示一个任务，边表示任务之间的依赖关系。任务依赖分为输入依赖in_deps和输出依赖out_deps。
构建任务依赖图的两种不同方式：
任务依赖
当任务句柄出现在一个任务的in_deps中时，任务句柄对应的任务是该任务的前置任务；当任务句柄出现在一个任务的out_deps中时，任务句柄对应的任务是该任务的后继任务。
任务依赖适用于任务之间有明确顺序或逻辑流程要求的场景，例如：
数据依赖
当数据对象的签名出现在一个任务的in_deps中时，该任务称为数据对象的消费者任务，消费者任务执行不改变其输入数据对象的内容；
当数据对象的签名出现在任务的out_deps中时，该任务称为数据对象的生产者任务，生产者任务执行改变其输出数据对象的内容，从而生成该数据对象的一个新的版本。
数据依赖适用于任务之间通过数据生产和消费关系来触发执行的场景。
一个数据对象可能存在多个版本，每个版本对应一个生产者任务和零个，一个或多个消费者任务，根据生产者任务和消费者任务的下发顺序定义数据对象的多个版本的顺序，以及每个版本所对应的生产者和消费者任务。
数据依赖解除的任务进入就绪状态允许被调度执行，依赖解除状态指任务所有输入数据对象版本的生产者任务执行完成，且所有输出数据对象版本的所有消费者任务执行完成的状态。
FFRT在运行时可动态构建任务之间的基于生产者/消费者的数据依赖关系并遵循任务数据依赖状态执行调度，包括：
-  Producer-Consumer依赖 一个数据对象版本的生产者任务和该数据对象版本的消费者任务之间形成的依赖关系，也称为Read-after-Write依赖。
-  Consumer-Producer依赖 一个数据对象版本的消费者任务和该数据对象的下一个版本的生产者任务之间形成的依赖关系，也称为Write-after-Read依赖。
-  Producer-Producer依赖 一个数据对象版本的生产者任务和该数据对象的下一个版本的生产者任务之间形成的依赖关系，也称为Write-after-Write依赖。
例如，存在一组任务与数据A的关系表述为：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170508.02195355609329183191390996496011:50001231000000:2800:30A1EE768E9E6A6F073A8D1A4B00E6CFF21CB973659C795D78E3CD93E097899B.png)
为表述方便，本文中的数据流图均以圆圈表示Task，方块表示数据。
可以得出以下结论：
示例：流媒体视频处理
用户上传视频到流媒体平台，处理步骤包含：视频解析A、视频转码B、视频缩略图生成C、视频水印添加D和视频发布E，其中步骤B和步骤C可以并行执行。任务流程如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170509.25708104818094146945203066413933:50001231000000:2800:E773E0AE9F86793CB6CCDC75736F948686E4EBA5B63363E3EB9E5F006EA1AD2F.png)
借助FFRT提供了图依赖并发范式，可以描述任务依赖关系，同时并行化上述视频处理流程，代码如下所示：
C风格构建FFRT任务需要一些额外的封装，封装方式为公共代码，与具体业务场景无关，使用方可以考虑用公共机制封装管理。
预期的输出可能为：
示例：斐波那契数列
斐波那契数列中每个数字是前两个数字之和，计算斐波那契数的过程可以很好地通过数据对象来表达任务依赖关系。使用FFRT并发编程框架计算斐波那契数的代码如下所示：
预期输出为：
示例中将fibonacci(x-1)和fibonacci(x-2)作为两个任务提交给FFRT，在两个任务完成之后将结果进行累加。虽然单个任务只是拆分成两个子任务，但是子任务又可以继续进行拆分，因此整个计算图的并行度是非常高的。
各个任务在FFRT内部形成了一颗调用树：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170509.90388729140021514260344474034180:50001231000000:2800:FBB822BA9FABB522A997F1F40E56A6E3CC72F6507EE7BDD5BBFEE99D31EB2CE8.png)
接口说明
上述样例中涉及到主要的FFRT的接口包括：
| 名称 | 描述 |
| --- | --- |
| ffrt_submit_base | 提交任务调度执行。 |
| ffrt_submit_h_base | 提交任务调度执行并返回任务句柄。 |
| ffrt_wait_deps | 等待依赖的任务完成，当前任务开始执行。 |
约束限制

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ffrt-example-cpp-V14
爬取时间: 2025-04-28 18:59:35
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ffrt-concurrency-serial-queue-cpp-V14
爬取时间: 2025-04-28 18:59:49
来源: Huawei Developer
概述
FFRT串行队列基于协程调度模型实现，提供高效的消息队列功能，支持异步通信、流量削峰、无锁化状态和资源管理以及架构解耦等多种业务场景。FFRT串行队列支持以下功能：
示例：异步日志系统
举例实现一个异步日志系统，主线程将日志任务提交到队列，后台线程从队列中取出任务并写入文件。这种方式既能保证日志的顺序性，又能避免文件写入操作阻塞主线程。
借助FFRT并行化框架API，开发者只需专注于业务逻辑的实现，无需关注异步线程管理、线程安全及调度效率等问题。
用例简化了异常处理和线程安全相关的一些逻辑，实现代码如下所示：
接口说明
上述样例中涉及到主要的FFRT的接口包括：
| 名称 | 描述 |
| --- | --- |
| class queue | 队列类。 |
| sleep_for | 延迟一定时间。 |
如何使用FFRT C++ API详见：C++接口使用指导
约束限制

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ffrt-concurrency-concurrent-queue-cpp-V14
爬取时间: 2025-04-28 19:00:02
来源: Huawei Developer
概述
FFRT并发队列提供了设置任务优先级（Priority）和队列并发度的能力，使得队列中的任务能同时在多个线程上执行，获得更高的并行效果。
示例：银行服务系统
举例实现一个银行服务系统，每个客户向系统提交一个服务请求，可以区分普通用户和VIP用户，VIP用户的服务请求可以优先得到执行。
银行系统中有2个窗口，可以并行取出用户提交的服务请求办理。可以利用FFRT的并行队列范式做如下建模：
实现代码如下所示：
接口说明
上述样例中涉及到主要的FFRT的接口包括：
| 名称 | 描述 |
| --- | --- |
| class task_attr | 任务属性类。 |
| class queue_attr | 队列属性类。 |
| class queue | 队列类。 |
如何使用FFRT C++ API详见：C++接口使用指导
约束限制

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ffrt-concurrency-graph-cpp-V14
爬取时间: 2025-04-28 19:00:16
来源: Huawei Developer
概述
FFRT图依赖并发范式支持任务依赖和数据依赖两种方式构建任务依赖图。任务依赖图中每个节点表示一个任务，边表示任务之间的依赖关系。任务依赖分为输入依赖in_deps和输出依赖out_deps。
构建任务依赖图的两种不同方式：
任务依赖
当任务句柄出现在一个任务的in_deps中时，任务句柄对应的任务是该任务的前置任务；当任务句柄出现在一个任务的out_deps中时，任务句柄对应的任务是该任务的后继任务。
任务依赖适用于任务之间有明确顺序或逻辑流程要求的场景，例如：
数据依赖
当数据对象的签名出现在一个任务的in_deps中时，该任务称为数据对象的消费者任务，消费者任务执行不改变其输入数据对象的内容；
当数据对象的签名出现在任务的out_deps中时，该任务称为数据对象的生产者任务，生产者任务执行改变其输出数据对象的内容，从而生成该数据对象的一个新的版本。
数据依赖适用于任务之间通过数据生产和消费关系来触发执行的场景。
一个数据对象可能存在多个版本，每个版本对应一个生产者任务和零个，一个或多个消费者任务，根据生产者任务和消费者任务的下发顺序定义数据对象的多个版本的顺序，以及每个版本所对应的生产者和消费者任务。
数据依赖解除的任务进入就绪状态允许被调度执行，依赖解除状态指任务所有输入数据对象版本的生产者任务执行完成，且所有输出数据对象版本的所有消费者任务执行完成的状态。
FFRT在运行时可动态构建任务之间的基于生产者/消费者的数据依赖关系并遵循任务数据依赖状态执行调度，包括：
-  Producer-Consumer依赖 一个数据对象版本的生产者任务和该数据对象版本的消费者任务之间形成的依赖关系，也称为Read-after-Write依赖。
-  Consumer-Producer依赖 一个数据对象版本的消费者任务和该数据对象的下一个版本的生产者任务之间形成的依赖关系，也称为Write-after-Read依赖。
-  Producer-Producer依赖 一个数据对象版本的生产者任务和该数据对象的下一个版本的生产者任务之间形成的依赖关系，也称为Write-after-Write依赖。
例如，存在一组任务与数据A的关系表述为：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170510.58071015896786819220907681324608:50001231000000:2800:207D383CFEE8184645252910FC488EF7E0ABAA18CF622714154B4D6E96AD986A.png)
为表述方便，本文中的数据流图均以圆圈表示Task，方块表示数据。
可以得出以下结论：
示例：流媒体视频处理
用户上传视频到流媒体平台，处理步骤包含：视频解析A、视频转码B、视频缩略图生成C、视频水印添加D和视频发布E，其中步骤B和步骤C可以并行执行。任务流程如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170510.32275172877405269546077956963282:50001231000000:2800:FBFDDB761D18B24944BABD8F3B532F42B7B6067660AB04921C8600A296807784.png)
借助FFRT提供了图依赖并发范式，可以描述任务依赖关系，同时并行化上述视频处理流程，代码如下所示：
预期的输出可能为：
示例：斐波那契数列
斐波那契数列中每个数字是前两个数字之和，计算斐波那契数的过程可以很好地通过数据对象来表达任务依赖关系。使用FFRT并发编程框架计算斐波那契数的代码如下所示：
预期输出为：
示例中将fibonacci(x-1)和fibonacci(x-2)作为两个任务提交给FFRT，在两个任务完成之后将结果进行累加。虽然单个任务只是拆分成两个子任务，但是子任务又可以继续进行拆分，因此整个计算图的并行度是非常高的。
各个任务在FFRT内部形成了一颗调用树：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170510.72467128315890532281314740224916:50001231000000:2800:BA5287E14B5CCCEC6449C697CA9B16B6B9F45CCD1A1C693EAB0C0908D51227E2.png)
接口说明
上述样例中涉及到主要的FFRT的接口包括：
| 名称 | 描述 |
| --- | --- |
| submit | 提交任务调度执行。 |
| submit_h | 提交任务调度执行并返回任务句柄。 |
| wait | 等待上下文所有任务完成。 |
如何使用FFRT C++ API详见：C++接口使用指导
约束限制

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ffrt-development-guideline-V14
爬取时间: 2025-04-28 19:00:30
来源: Huawei Developer
介绍
FFRT编程模型是一种基于任务和数据驱动的并发编程模型，允许开发者通过任务及其依赖关系描述的方式进行应用开发。
通过FFRT编程模型，开发者可专注于应用功能开发，由FFRT在运行时根据任务依赖状态和可用执行资源自动并发调度和执行任务。
本文用于指导开发者基于FFRT编程模型实现并行编程。
维测
超时监测
FFRT提供开发者队列级和任务级超时维测机制，用来监控用户业务中承载重要职责的队列和任务在FFRT调度的端到端时间。
任务超时时执行的回调函数进程范围内唯一，需要在任务提交之前由业务方配置到FFRT中，不支持在提交任务或任务超时检测过程中配置。
具体接口包括：
| C++接口 | C接口 | 描述 |
| --- | --- | --- |
| queue_attr::timeout | ffrt_queue_attr_set_timeout | 设置队列超时时间。 |
| queue_attr::callback | ffrt_queue_attr_set_callback | 设置队列超时回调函数。 |
长耗时任务监测
机制
样例
在对应进程日志中搜索RecordSymbolAndBacktrace关键字，对应的日志示例如下：
该维测会打印出Worker上执行时间超过阈值的任务堆栈、Worker线程号、执行时间，请自行根据堆栈找对应组件确认阻塞原因。
注意事项
不涉及。
运行信息转储
机制
FFRT提供一个对外的接口ffrt_dump以便转储FFRT子系统运行时的内部信息，主要包含：
在当前进程发生freeze时，OH的DFX模块会主动调用ffrt_dump接口转储FFRT的信息，落盘到freeze文件中，存储到/data/log/faultlog/faultlogger/目录下，用户可以直接利用该文件中的任务调用栈信息定位对应任务的卡顿问题。
样例
注意事项
由于OH DFX模块在freeze时有处理时间的要求，低概率会导致ffrt_dump中收集的信息不全，freeze处理时间耗尽，此时落盘的信息会有缺失。
黑匣子日志
机制
进程Crash发生时，FFRT模块收到信号（SIGABRT、SIGBUS、SIGFPE、SIGILL、SIGSTKFLT、SIGSTOP、SIGSYS和SIGTRAP），将FFRT当前重要的运行时信息保存至faultlog中，包括：正在运行的task；当前Worker的运行信息和调用栈信息；当前普通任务信息；当前队列任务信息等。用户可利用这些信息中的内容辅助定位Crash问题。
样例
注意事项
不涉及。
Trace打点
机制
FFRT任务的调度和执行过程中，利用了OH系统的Trace打点能力，对任务在FFRT框架中的状态流转做了实时跟踪，用户可以借助Trace图形化工具来分析任务的行为是否符合预期。
样例
1.  启动Trace抓取
```shell
hdc shell "hitrace -t 10 -b 20480 -o /data/local/tmp/in_systrace.ftrace sched freq idle ffrt"
# -t：指定trace采集时长，在采集过程中所有的trace记录会落盘保存
# -b：指定trace记录缓存大小，buffer不足的情况下可能导致部分记录被覆盖没有落盘
# -o：指定trace落盘存储路径
```
2.  图形化工具呈现 将Trace落盘的文件从设备中取出来，借助图形化工具进行分析，例如：Perfetto。
注意事项
用户也可以在自己业务代码中加入Trace打点，以界定问题的范围。需注意在高频调用流程中，加入Trace打点会有系统开销，会对业务性能造成影响。
Debug日志
机制
-  FFRT默认不开启Debug级别的日志，用户可以通过命令的方式打开，以获取更丰富的维测信息支撑开发阶段的问题定位。
-  打开FFRT Debug日志开关：
```shell
hdc shell hilog -b DEBUG -D 0xD001719
```
-  恢复默认FFRT INFO日志级别:
```shell
hdc shell hilog -b INFO -D 0xD001719
```
样例
注意事项
由于FFRT是系统底座，支撑大量上层业务及框架的运行，全局打开Debug日志会导致日志超限，影响其他模块日志的正常输出。
开发步骤
以下步骤描述了如何使用FFRT提供的Native API接口，创建并行任务和串行队列任务以及销毁相应资源。
1.  在项目CMakeLists.txt中添加动态链接库：
2.  在项目中包含对应的头文件：
3.  对执行的函数进行封装：
4.  设置任务属性值，包括QoS等级、任务名称等，具体可以参考接口文档。
5.  提交任务。
6.  任务提交完成后销毁相应资源。
使用建议
建议1：函数化
做到纯函数的好处在于：1. 能够最大化挖掘并行度，2.避免DataRace和锁的问题。
在实际中，可以根据场景放松纯函数的约束，但前提是：
建议2：使用FFRT提供的替代API
建议3：Deadline机制
建议4：从线程模型迁移
建议5：推荐使用C++接口
约束限制
线程局部变量使用约束
FFRT Task中使用线程局部变量存在风险，说明如下：
线程绑定使用约束
标准库同步原语使用约束
FFRT任务中使用标准库的互斥锁可能发生死锁，需要更换为FFRT提供的互斥锁，说明如下：
对进程fork()场景的支持说明
以动态库方式部署FFRT
输入输出依赖数量的限制
常见反模式
C API中初始化FFRT对象后，对象的置空与销毁由用户负责
-  为保证较高的性能，FFRT的C API中内部不包含对对象的销毁状态的标记，用户需要合理地进行资源的释放，重复调用各个对象的销毁操作，其结果是未定义的。
-  错误示例1，重复调用销毁函数可能造成不可预知的数据损坏：
-  错误示例2，未调用销毁函数会造成内存泄漏：
-  建议示例，仅调用一次销毁函数，如有必要可进行置空：
变量生命周期错误
-  FFRT提交任务中应注意对象或资源在其生命周期内可能出现的误用，这些错误会导致程序崩溃、数据损坏或者难以调试的问题。
-  错误示例1，变量生命周期已结束导致的UAF问题：
-  错误示例2，互斥锁生命周期已结束继续使用导致功能异常：
Using FFRT in DevEco IDE
Using FFRT C API
NDK（Native Development Kit）是HarmonyOS SDK提供的Native API的集合，方便开发者使用C或C++语言实现应用的关键功能。
FFRT C API已集成在NDK中，在DevEco IDE中可以直接使用对应的接口。
Using FFRT C++ API
FFRT的部署依赖FFRT动态库libffrt.so和一组头文件，其中动态库仅导出C接口，C++接口调用C接口，并基于头文件的方式将API中的C++元素编译到用户的动态库中，从而保证了ABI兼容性。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170510.13953166374297973642150594359641:50001231000000:2800:6FD9CFADE002968470F8378E0917F4634EC8059FF24EC848B4A381A291B4D16D.png)
如果要使用FFRT C++ API，需要使用FFRT三方库@ppd/ffrt，该三方库是由FFRT官方维护的FFRT C++ API库。
在模块目录下执行三方库安装命令：
```shell
ohpm install @ppd/ffrt
```
也可以直接在oh-package.json5文件中配置对应的依赖，由IDE自动进行三方库下载安装。
同时在模块CMakeLists.txt文件中添加依赖：
至此就可以在代码中使用FFRT C++接口：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ffrt-api-guideline-c-V14
爬取时间: 2025-04-28 19:00:44
来源: Huawei Developer
任务管理
ffrt_deps_t
声明
参数
描述
ffrt_dependence_t作用等同C++的dependence，ffrt_deps_t作用等同C++的std::vector<dependence>。
样例
ffrt_task_attr_t
声明
描述
任务的属性描述，在提交普通任务或者队列任务时，可以通过ffrt_task_attr_t来配置其属性。
方法
ffrt_task_attr_init
参数
返回值
描述
ffrt_task_attr_destroy
参数
描述
ffrt_task_attr_set_name
参数
描述
ffrt_task_attr_get_name
参数
返回值
描述
ffrt_task_attr_set_qos
参数
描述
ffrt_task_attr_get_qos
参数
返回值
描述
ffrt_task_attr_set_delay
参数
描述
ffrt_task_attr_get_delay
参数
返回值
描述
ffrt_task_attr_set_queue_priority
参数
描述
ffrt_task_attr_get_queue_priority
参数
返回值
描述
ffrt_task_attr_set_stack_size
参数
描述
ffrt_task_attr_get_stack_size
参数
返回值
描述
样例
ffrt_alloc_auto_managed_function_storage_base
声明
参数
返回值
描述
分配了一块内存空间，内存空间头部为ffrt_function_header_t结构体（返回指针可转换为ffrt_function_header_t*指针使用）。头部后留有64字节的可用空间，用户可自定义使用该空间，通常用于入参或返回值的存储。
样例
-  样例1：生成一个不带参数和返回值的任务执行体：
-  样例2：生成一个带参数和返回值的任务执行体：
ffrt_submit_base
声明
参数
描述
提交一个普通任务，任务支持相关属性设置，在输入依赖解除后任务可调度执行，任务执行完成后解除输出依赖。
样例
-  样例1：提交带属性的任务：
-  样例2：提交带数据依赖的任务：
ffrt_submit_h_base
声明
参数
返回值
描述
相比于ffrt_submit_base接口，增加了任务句柄的返回值。
样例
ffrt_task_handle_inc_ref
声明
参数
返回值
描述
通过任务句柄增加对应任务的引用计数，每次调用引用计数加一。用于控制任务的生命周期使用，当引用计数不为零时，对应的任务资源不会被释放。注意ffrt_submit_h_base返回的ffrt_task_handle_t默认已有一个引用计数。通过ffrt_task_handle_destroy销毁ffrt_task_handle_t时默认减去一个引用计数。
ffrt_task_handle_dec_ref
声明
参数
返回值
描述
通过任务句柄减去对应任务的引用计数，每次调用引用计数减一。
ffrt_task_handle_destroy
声明
参数
描述
销毁任务句柄，同时默认减去一个任务引用计数。
ffrt_wait
声明
描述
同步等待所有前序提交的同级任务完成。
样例
ffrt_wait_deps
声明
参数
描述
同步对应的数据依赖解除。
样例
ffrt_this_task_update_qos
声明
参数
返回值
描述
在任务执行过程中，动态修改任务的QoS等级。注意该接口在任务的函数闭包内使用，修改的是当前正在执行的任务的QoS等级，接口调用会使任务先挂起一次再恢复执行。
样例
ffrt_this_task_get_qos
声明
返回值
描述
获取当前正在执行任务的QoS等级。
样例
ffrt_this_task_get_id
声明
返回值
描述
获取当前正在执行任务的id。
样例
任务队列
ffrt_queue_attr_t
声明
描述
用于配置队列的属性，如 QoS、超时时间、回调函数和最大并发数。
方法
ffrt_queue_attr_init
参数
返回值
描述
ffrt_queue_attr_destroy
参数
描述
ffrt_queue_attr_set_qos
参数
描述
ffrt_queue_attr_get_qos
参数
返回值
描述
ffrt_queue_attr_set_timeout
参数
描述
ffrt_queue_attr_get_timeout
参数
返回值
描述
ffrt_queue_attr_set_callback
参数
描述
ffrt_queue_attr_get_callback
参数
返回值
描述
ffrt_queue_attr_set_max_concurrency
参数
描述
ffrt_queue_attr_get_max_concurrency
参数
返回值
描述
样例
ffrt_queue_t
声明
描述
队列指针，提供一系列C接口支持队列任务的提交、取消、等待和排队任务数量查询。
方法
ffrt_queue_create
参数
返回值
描述
ffrt_queue_destroy
参数
描述
ffrt_queue_submit
参数
描述
ffrt_queue_submit_h
参数
返回值
描述
ffrt_queue_wait
参数
描述
ffrt_queue_cancel
参数
返回值
描述
ffrt_get_main_queue
返回值
描述
ffrt_get_current_queue
返回值
描述
样例
同步原语
ffrt_mutexattr_t
声明
描述
方法
ffrt_mutexattr_init
参数
返回值
描述
ffrt_mutexattr_destroy
参数
返回值
描述
ffrt_mutexattr_settype
参数
返回值
描述
ffrt_mutexattr_gettype
参数
返回值
描述
样例
ffrt_mutex_t
声明
描述
方法
ffrt_mutex_init
参数
返回值
描述
ffrt_mutex_destroy
参数
返回值
描述
ffrt_mutex_lock
参数
返回值
描述
ffrt_mutex_unlock
参数
返回值
描述
ffrt_mutex_trylock
参数
返回值
描述
样例
ffrt_cond_t
声明
描述
方法
ffrt_cond_init
参数
返回值
描述
ffrt_cond_destroy
参数
返回值
描述
ffrt_cond_signal
参数
返回值
描述
ffrt_cond_broadcast
参数
返回值
描述
ffrt_cond_wait
参数
返回值
描述
ffrt_cond_timedwait
参数
返回值
描述
样例
阻塞原语
ffrt_usleep
声明
参数
描述
样例
协同原语
ffrt_yield
声明
描述
样例
定时器
ffrt_timer_t
声明
描述
提供定时器相关的功能。
方法
ffrt_timer_start
声明
参数
返回值
描述
ffrt_timer_stop
声明
参数
返回值
描述
样例
-  样例1：使用单次定时器：
-  样例2：使用循环定时器：
循环
ffrt_loop_t
声明
描述
提供循环相关的功能。
方法
ffrt_loop_create
声明
参数
返回值
描述
ffrt_loop_destroy
声明
参数
返回值
描述
ffrt_loop_run
声明
参数
返回值
描述
ffrt_loop_stop
声明
参数
描述
ffrt_loop_epoll_ctl
声明
参数
返回值
描述
ffrt_loop_timer_start
声明
参数
返回值
描述
ffrt_loop_timer_stop
声明
参数
返回值
描述
样例
-  样例1：循环与并发队列：
-  样例2：循环、并发队列和定时器：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/input-kit-V14
爬取时间: 2025-04-28 19:00:57
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/input-overview-V14
爬取时间: 2025-04-28 19:01:11
来源: Huawei Developer
功能介绍
Input Kit（多模输入Kit）为多种输入设备提供服务，如触控板、触摸屏、鼠标、键盘等。通过对这些输入设备上报驱动事件的归一化处理，确保不同输入设备与用户交互体验统一和流畅。
Input Kit除了提供基础的输入事件服务之外，还提供了获取输入设备列表、改变鼠标光标样式等功能和接口。
运作机制
多模输入能力作为系统为应用提供的一种基础服务，通过处理上报的输入设备驱动事件，完成输入事件管理、接收、预处理、分发，通过inner SDK与JSkit上报应用，具体运行机制如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170510.42964079553489156450873292378845:50001231000000:2800:15E7D579020B0843D6977776B5FD7E77AC8F867288C39ADBF11EC2AF890F984F.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/inputdevice-guidelines-V14
爬取时间: 2025-04-28 19:01:25
来源: Huawei Developer
场景介绍
输入设备管理提供设备热插拔监听、查询指定设备的键盘类型等能力。使用场景例如：当用户需要输入文本时，输入法会根据当前是否插入了物理键盘来决定是否弹出虚拟键盘，开发者可以通过监听设备热插拔判断是否有物理键盘插入。
导入模块
接口说明
输入设备管理常用接口如下表所示，接口详细介绍请参考ohos.multimodalInput.inputDevice文档。
| 接口名称 | 描述 |
| --- | --- |
| getDeviceList(): Promise<Array<number>> | 获取输入设备列表。 |
| getKeyboardType(deviceId: number): Promise<KeyboardType> | 获取输入设备的键盘类型。 |
| on(type: "change", listener: Callback<DeviceListener>): void | 监听输入设备的热插拔事件。 |
| off(type: "change", listener?: Callback<DeviceListener>): void | 取消监听输入设备的热插拔事件。 |
虚拟键盘弹出检测
当用户需要输入文本时，输入法会根据当前是否插入了物理键盘来决定是否弹出虚拟键盘，开发者可以通过监听设备热插拔，判断是否有物理键盘插入。
开发步骤

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/pointerstyle-guidelines-V14
爬取时间: 2025-04-28 19:01:38
来源: Huawei Developer
场景介绍
鼠标光标控制提供鼠标光标显示和隐藏、光标样式查询和设置的能力。使用场景例如：用户在全屏观看视频时，开发者可以控制鼠标光标的显示隐藏；当用户执行取色时，开发者可以将鼠标光标样式切换为取色器样式。
导入模块
接口说明
鼠标光标控制常用接口如下表所示，接口详细介绍请参见ohos.multimodalInput.pointer文档。
| 接口名称 | 描述 |
| --- | --- |
| isPointerVisible(callback: AsyncCallback<boolean>): void | 获取鼠标指针显示或隐藏状态。 |
| setPointerVisible(visible: boolean, callback: AsyncCallback<void>): void | 设置鼠标指针显示或隐藏状态，该接口会影响全局鼠标光标的显示状态。 |
| setPointerStyle(windowId: number, pointerStyle: PointerStyle, callback: AsyncCallback<void>): void | 设置鼠标光标样式，该接口会影响指定窗口鼠标光标样式。 |
| getPointerStyle(windowId: number, callback: AsyncCallback<PointerStyle>): void | 查询鼠标光标样式。 |
设置鼠标光标隐藏
用户在全屏观看视频时，可以调用鼠标光标的隐藏接口设置鼠标光标不可见，提升用户体验。
开发步骤
设置鼠标光标样式
当开发者设计取色器特性时，可以将鼠标光标样式切换为取色器样式，完成取色后，设置鼠标光标样式为默认样式，该接口设置和查询当前应用内指定窗口的光标样式，总共可设置43种光标样式，具体参考光标样式。
开发步骤

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/monitor-guidelines-V14
爬取时间: 2025-04-28 19:01:52
来源: Huawei Developer
功能介绍
多模提供为应用提供了按键、输入事件（鼠标、触屏和轴事件）监听能力，当前仅支持录屏类应用。使用场景例如：用户在录屏应用开启录屏时，需要监听设备的按键、鼠标、触摸和轴事件。
接口说明
创建和删除事件监听相关接口如下表所示，接口详细介绍请参考Input文档。
| 接口名称 | 描述 |
| --- | --- |
| Input_Result OH_Input_AddKeyEventMonitor(Input_KeyEventCallback callback) | 创建按键事件监听。 |
| Input_Result OH_Input_AddMouseEventMonitor(Input_MouseEventCallback callback) | 创建鼠标事件监听。 |
| Input_Result OH_Input_AddTouchEventMonitor(Input_TouchEventCallback callback) | 创建触摸事件监听。 |
| Input_Result OH_Input_AddAxisEventMonitorForAll(Input_AxisEventCallback callback) | 创建所有类型轴事件监听。 |
| Input_Result OH_Input_AddAxisEventMonitor(InputEvent_AxisEventType axisEventType, Input_AxisEventCallback callback) | 创建指定类型轴事件监听。 |
| Input_Result OH_Input_RemoveKeyEventMonitor(Input_KeyEventCallback callback) | 删除按键事件监听。 |
| Input_Result OH_Input_RemoveMouseEventMonitor(Input_MouseEventCallback callback) | 删除鼠标事件监听。 |
| Input_Result OH_Input_RemoveTouchEventMonitor(Input_TouchEventCallback callback) | 删除触摸事件监听。 |
| Input_Result OH_Input_RemoveAxisEventMonitorForAll(Input_AxisEventCallback callback) | 删除所有类型轴事件监听。 |
| Input_Result OH_Input_RemoveAxisEventMonitor(InputEvent_AxisEventType axisEventType, Input_AxisEventCallback callback) | 删除指定类型轴事件监听。 |
开发步骤
链接动态库
调用创建和删除事件拦截前，需链接相关动态库。链接动态库的方法是，在CMakeList.txt文件中新增如下配置：
申请所需权限
应用需要在module.json5中添加下面权限的配置，详细的配置方法参考声明声明权限文档。
```json
"requestPermissions": [
{
"name": "ohos.permission.INPUT_MONITORING"
}
]
```
创建事件监听
按键事件
鼠标事件
触摸事件
轴事件

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/interceptor-guidelines-V14
爬取时间: 2025-04-28 19:02:05
来源: Huawei Developer
功能介绍
多模为应用提供了创建和删除按键、输入事件（鼠标、触摸和轴事件）拦截的能力。使用场景例如：云桌面应用需要拦截按键、鼠标、触摸和轴事件。
接口说明
创建和删除事件拦截相关接口如下表所示，接口详细介绍请参考Input文档。
| 接口名称 | 描述 |
| --- | --- |
| Input_Result OH_Input_AddKeyEventInterceptor(Input_KeyEventCallback callback, Input_InterceptorOptions *option) | 创建按键事件拦截。 |
| Input_Result OH_Input_AddInputEventInterceptor(Input_InterceptorEventCallback *callback, Input_InterceptorOptions *option) | 创建输入事件拦截，包含鼠标、触摸和轴事件。 |
| Input_Result OH_Input_RemoveKeyEventInterceptor() | 删除按键事件拦截。 |
| Input_Result OH_Input_RemoveInputEventInterceptor() | 删除输入事件拦截，包含鼠标、触摸和轴事件。 |
开发步骤
链接动态库
调用创建和删除事件拦截前，需链接相关动态库。链接动态库的方法是，在CMakeList.txt文件中做下面例子所示的配置：
申请所需权限
应用需要在module.json5中添加下面权限的配置，详细的配置方法参考声明声明权限文档。
```json
"requestPermissions": [
{
"name": "ohos.permission.INTERCEPT_INPUT_EVENT"
}
]
```
创建事件拦截
按键事件
输入拦截（鼠标、触摸和轴事件）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/mdm-kit-V14
爬取时间: 2025-04-28 19:02:20
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/mdm-kit-intro-V14
爬取时间: 2025-04-28 19:02:34
来源: Huawei Developer
业务介绍
移动设备管理（Mobile Device Management）是一种企业级的IT应用解决方案，用于管理并保护公司设备上的数据和应用程序。MDM可以通过集中管理、远程配置和监控来保障设备和数据的安全性和稳定性。它广泛应用于企业和政府机构，以确保员工和客户使用的设备和数据受到保护，实现企业高效管理、安全使用设备。
实现原理
框架层和服务层提供了enterprise_device_management部件和enterprise_device_management_ext部件，enterprise_device_management部件提供了设备管理应用程序框架和基本设备管理能力，enterprise_device_management_ext部件为1+8设备提供扩展的企业设备管理能力。设备管理应用通过EnterpriseAdminExtensionAbility来调用MDM Kit中的接口，实现管理设备的意图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170511.34500398402393767968390580103153:50001231000000:2800:6997AD8B5B9D739B68AF09BC999B3858B2198BFB63757140F2171E9C91A5A6DB.png)
约束与限制
-  SDK版本为5.0.0（API 12）及以上。
-  仅支持Stage模型。
-  仅支持HarmonyOS NEXT设备。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/mdm-kit-guide-V14
爬取时间: 2025-04-28 19:02:47
来源: Huawei Developer
功能介绍
设备管理应用可以提供企业设备管理与事件监听、应用管理、禁用管理、安全管理、设备设置、设备控制、设备信息获取、硬件外设管理、系统管理、网络通信管理等功能。具体功能内容可参考接口说明。
设备管理应用：具备企业设备管理扩展能力的应用。
开发步骤
要完成一个设备管理应用开发，需要完成以下步骤：
1.  申请资质。
2.  创建EnterpriseAdminExtensionAbility。
3.  声明接口所需权限。
4.  MDM功能开发与调试。
5.  分发部署。
申请资质
在开发应用前，需要在AppGallery Connect中配置项目和应用信息。包括：
创建EnterpriseAdminExtensionAbility
请参阅EnterpriseAdminExtensionAbility开发指南完成EnterpriseAdminExtensionAbility的创建。
声明接口所需权限
在申请权限前，请保证符合权限使用的基本原则。然后在工程Module对应的module.json5配置文件中"requestPermissions"标签下声明要使用的接口所需的权限。例如：
```typescript
"requestPermissions": [
{
"name": "ohos.permission.MANAGE_ENTERPRISE_DEVICE_ADMIN"
},
]
```
所需要申请的权限请参考具体接口，这里提供了企业设备管理的链接，可基于该文档查看MDM Kit内其他API文档。
声明的MDM权限必须在申请MDM应用的证书和Profile时完成申请，否则后面应用还是无法获取到该权限。
MDM功能开发
1.  导包。MDM Kit目前包含应用管理、通信管理、安全管理、限制策略、系统内管理、设备设置和查询、设备控制等多种类型的API。请根据业务需求。以下为导入adminManager和restrictions的示例。
```typescript
import { adminManager, restrictions } from '@kit.MDMKit';
```
2.  调用接口，实现相应的功能。以下为禁用设备Wi-Fi的示例。
```typescript
import { Want } from '@kit.AbilityKit';
let wantTemp: Want = {
bundleName: 'com.example.xxx',
abilityName: 'EnterpriseAdminAbility',
};
try {
restrictions.setDisallowedPolicy(wantTemp, "wifi", true);
console.info("disable wifi success.");
} catch (error) {
console.info("disable wifi fail.");
}
```
调试说明
由于MDM接口需要在激活企业设备管理扩展能力后使用，调试时需通过hdc命令来激活/解除激活扩展能力，命令如下：
正式使用时，在同一设备上只能能激活一个超级设备管理应用。
调试之前，需要完成资质申请。
分发部署
暂不支持，即将发布，敬请期待。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/mdm-kit-admin-V14
爬取时间: 2025-04-28 19:03:02
来源: Huawei Developer
概述
企业设备管理扩展能力，是设备管理应用必备组件。当开发者为企业开发设备管理应用时，需继承EnterpriseAdminExtensionAbility，在EnterpriseAdminExtensionAbility实例中实现MDM业务逻辑，EnterpriseAdminExtensionAbility实现了系统管理状态变化通知功能，并定义了管理应用激活、去激活、应用安装、卸载事件等回调接口。
接口说明
| 类名 | 接口名称 | 描述 |
| --- | --- | --- |
| EnterpriseAdminExtensionAbility | onAdminEnabled(): void | 设备管理器应用激活回调方法 |
| EnterpriseAdminExtensionAbility | onAdminDisabled(): void | 设备管理器应用去激活回调方法 |
| EnterpriseAdminExtensionAbility | onBundleAdded(bundleName: string): void | 应用安装回调方法 |
| EnterpriseAdminExtensionAbility | onBundleRemoved(bundleName: string): void | 应用卸载回调方法 |
onAdminEnabled：由企业管理员或者员工部署设备管理应用，激活设备管理器，系统通知设备管理应用设备管理应用已激活DeviceAdmin权限。设备管理应用可在onAdminEnabled回调函数中进行初始化策略设置。
onAdminDisabled：由系统或者员工去激活设备管理器，通知去激活DeviceAdmin权限，应用可以通知企业管理员设备已脱管。
onBundleAdded: 企业应用管理场景下，企业管理员订阅应用安装事件，端侧应用安装和卸载事件通知设备管理应用，设备管理应用可以在回调函数中进行事件上报，通知企业管理员。
onBundleRemoved: 企业应用管理场景下，企业管理员订阅应用卸载事件，端侧应用安装和卸载事件通知设备管理应用，设备管理应用可以在回调函数中进行事件上报，通知企业管理员。
开发步骤
新建一个工程后，结构如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170511.73569115834418109886292372919625:50001231000000:2800:6A01936678BCBD580A91C248531E678FEF96017DE4DE3DC010A647AF62C13287.png)
首先，创建一个EnterpriseAdmin类型的ExtensionAbility（也就是EnterpriseAdminExtensionAbility）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170511.32632950705303842199078108664657:50001231000000:2800:0E16C349DF113AFB439F4740B1D301061097FFD1249EE3C58B169BF9FC0CA422.png)
其次，打开新建的EnterpriseAdminAbility文件，导入EnterpriseAdminExtensionAbility模块，使其继承EnterpriseAdminExtensionAbility并加上需要的应用通知回调方法，如onAdminEnabled()、onAdminDisabled()等回调方法。当设备管理员应用被激活或者去激活时，则可以在对应回调方法中接受系统发送通知。
```typescript
import { EnterpriseAdminExtensionAbility } from '@kit.MDMKit';
export default class EnterpriseAdminAbility extends EnterpriseAdminExtensionAbility {
// 设备管理器应用激活回调方法，应用可在此回调函数中进行初始化策略设置。
onAdminEnabled() {
console.info("onAdminEnabled");
}
// 设备管理器应用去激活回调方法，应用可在此回调函数中通知企业管理员设备已脱管。
onAdminDisabled() {
console.info("onAdminDisabled");
}
// 应用安装回调方法，应用可在此回调函数中进行事件上报，通知企业管理员。
onBundleAdded(bundleName: string) {
console.info("EnterpriseAdminAbility onBundleAdded bundleName:" + bundleName);
}
// 应用卸载回调方法，应用可在此回调函数中进行事件上报，通知企业管理员。
onBundleRemoved(bundleName: string) {
console.info("EnterpriseAdminAbility onBundleRemoved bundleName" + bundleName);
}
};
```
最后，在工程Module对应的module.json5配置文件中将EnterpriseAdminAbility注册为ExtensionAbility，type标签需要设置为“enterpriseAdmin”，srcEntry标签表示当前ExtensionAbility组件所对应的代码路径。
```typescript
"extensionAbilities": [
{
"name": "EnterpriseAdminAbility",
"type": "enterpriseAdmin",
"exported": true,
"srcEntry": "./ets/enterpriseadminability/EnterpriseAdminAbility.ets"
}
]
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/status-bar-extension-kit-guide-V14
爬取时间: 2025-04-28 19:03:16
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/statusbar-extension-introduction-V14
爬取时间: 2025-04-28 19:03:29
来源: Huawei Developer
Status Bar Extension Kit（状态栏开放服务）提供了在状态栏中添加应用图标、管理图标等一系列方法，为应用提供可以在状态栏与用户进行交互的功能。
Status Bar Extension Kit（状态栏开放服务）只支持中国境内（不包含中国香港、中国澳门、中国台湾）。
场景介绍
当应用启动时或者应用运行过程中，应用可以通过本模块提供的接口向状态栏添加图标、移除图标、更新图标相关信息等，用户可以通过点击或者右键点击呼出弹窗或者菜单，进行快速操作。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/statusbar-extension-guide-V14
爬取时间: 2025-04-28 19:03:43
来源: Huawei Developer
应用接入状态栏之后，状态栏会显示应用自定义的图标，图标提供左键显示自定义弹窗以及右键显示菜单的功能；应用退出时，状态栏图标会随着应用进程的销毁而消失。
接口说明
Status Bar Extension Kit（状态栏开放服务）相关API仅在2in1设备上生效。
以下列出应用接入状态栏的相关API，具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| addToStatusBar(context: common.Context, statusBarItem: StatusBarItem): void | 添加应用图标到状态栏。 |
| removeFromStatusBar(context: common.Context): void | 移除状态栏的应用图标。 |
| updateQuickOperationHeight(context: common.Context, height: number): void | 更新状态栏图标左键弹窗应用定制区域的高度。 |
| updateStatusBarMenu(context: common.Context, statusBarGroupMenus: Array<StatusBarGroupMenu>): void | 更新接入状态栏图标的右键菜单内容。 |
| updateStatusBarIcon(context: common.Context, statusBarIcon: StatusBarIcon): void | 更新状态栏图标。 |
| on(type: 'statusBarIconClick', callback: Callback<emitter.EventData>): void | 监听状态栏图标点击事件。 |
| off(type: 'statusBarIconClick', callback?: Callback<emitter.EventData>): void | 注销状态栏图标点击事件。 |
| on(type: 'rightMenuClick', callback: Callback<emitter.EventData>): void | 监听状态栏右键菜单点击事件。 |
| off(type: 'rightMenuClick', callback?: Callback<emitter.EventData>): void | 注销状态栏右键菜单点击事件。 |
接口名
描述
addToStatusBar(context: common.Context, statusBarItem: StatusBarItem): void
添加应用图标到状态栏。
removeFromStatusBar(context: common.Context): void
移除状态栏的应用图标。
updateQuickOperationHeight(context: common.Context, height: number): void
更新状态栏图标左键弹窗应用定制区域的高度。
updateStatusBarMenu(context: common.Context, statusBarGroupMenus: Array<StatusBarGroupMenu>): void
更新接入状态栏图标的右键菜单内容。
updateStatusBarIcon(context: common.Context, statusBarIcon: StatusBarIcon): void
更新状态栏图标。
on(type: 'statusBarIconClick', callback: Callback<emitter.EventData>): void
监听状态栏图标点击事件。
off(type: 'statusBarIconClick', callback?: Callback<emitter.EventData>): void
注销状态栏图标点击事件。
on(type: 'rightMenuClick', callback: Callback<emitter.EventData>): void
监听状态栏右键菜单点击事件。
off(type: 'rightMenuClick', callback?: Callback<emitter.EventData>): void
注销状态栏右键菜单点击事件。
开发步骤
1.
```typescript
import { statusBarManager, StatusBarViewExtensionAbility } from '@kit.StatusBarExtensionKit';
import { UIExtensionContentSession, Want } from '@kit.AbilityKit';
import { image } from '@kit.ImageKit';
```
2.
```typescript
let TAG = 'MyStatusBarViewExtAbility';
export default class MyStatusBarViewAbility extends StatusBarViewExtensionAbility {
onCreate() {
console.info(TAG, `onCreate`);
}
onSessionCreate(want: Want, session: UIExtensionContentSession) {
console.info(TAG, `onSessionCreate, want: ${want.abilityName}`);
// pages/StatusBarPage为状态栏图标左键业务弹窗显示的页面
session.loadContent('pages/StatusBarPage');
}
onForeground() {
console.info(TAG, `onForeground`);
}
onBackground() {
console.info(TAG, `onBackground`);
}
onSessionDestroy(session: UIExtensionContentSession) {
console.info(TAG, `onSessionDestroy`);
}
onDestroy() {
console.info(TAG, `onDestroy`);
}
}
```
3.
```typescript
"extensionAbilities": [
{
"name": "MyStatusBarViewAbility",
"icon": "$media:startIcon",
"description": "statusBar",
"type": "statusBarView",
"exported": true,
// 此处为MyStatusBarViewAbility类所在的文件路径
"srcEntry": "./ets/statusbarviewextensionability/MyStatusBarViewAbility.ets"
}
]
```
4.
```typescript
let context = getContext(this);
// 获取resourceManager资源管理器
const resourceMgr = context.resourceManager;
// 创建white pixelMap，需在资源rawfile文件夹中预置testWhite.png图片，图片大小为24vp * 24vp
const whiteFileData = resourceMgr.getRawFileContentSync('testWhite.png');
const whiteBuffer = whiteFileData.buffer;
const whiteImageSource = image.createImageSource(whiteBuffer);
let whitePixelMap = await whiteImageSource.createPixelMap();
// 创建black pixelMap，需在资源rawfile文件夹中预置testBlack.png图片，图片大小为24vp * 24vp
const blackFileData = resourceMgr.getRawFileContentSync('testBlack.png');
const blackBuffer = blackFileData.buffer;
const blackImageSource = image.createImageSource(blackBuffer);
let blackPixelMap = await blackImageSource.createPixelMap();
// 构建图标信息
let icon: statusBarManager.StatusBarIcon = {
white: whitePixelMap,
black: blackPixelMap
}
```
5.
```typescript
// 构建左键业务弹窗信息
let operation: statusBarManager.QuickOperation = {
// 此处abilityName为上述配置的module.json5中配置的自定义StatusBarViewExtensionAbility名称
abilityName: "MyStatusBarViewAbility",
title: "测试Demo",
height: 300,
// 可缺省
moduleName: 'entry'
};
```
6.
```typescript
// 构建右键菜单项内容
let subMenus: Array<statusBarManager.StatusBarSubMenuItem> = [];
let subMenuItemAction: statusBarManager.StatusBarMenuAction = {
abilityName: "EntryAbility"
}
let subMenu: statusBarManager.StatusBarSubMenuItem = {
subTitle: "子菜单项",
menuAction: subMenuItemAction
}
subMenus.push(subMenu);
let statusBarMenuItems: Array<statusBarManager.StatusBarMenuItem> = [];
let menuItem: statusBarManager.StatusBarMenuItem = {
title: "一级菜单项",
// 一级menuAction和subMenu两项不可都缺省
subMenu: subMenus
};
statusBarMenuItems.push(menuItem);
let statusBarGroupMenus: Array<statusBarManager.StatusBarGroupMenu> = [];
statusBarGroupMenus.push(statusBarMenuItems);
```
7.
```typescript
// 构建添加到状态栏的图标详细信息
let item: statusBarManager.StatusBarItem = {
icons: icon,
quickOperation: operation,
// 该参数可选
statusBarGroupMenu: statusBarGroupMenus
};
try {
statusBarManager.addToStatusBar(context, item);
} catch (error) {
console.error(`addToStatusBar failed. error code: ${error.code}, error message: ${error.message}`);
}
```
8.
```typescript
// 构建右键菜单项内容
let subMenus: Array<statusBarManager.StatusBarSubMenuItem> = [];
let subMenuItemAction: statusBarManager.StatusBarMenuAction = {
abilityName: "EntryAbility"
}
let subMenu: statusBarManager.StatusBarSubMenuItem = {
subTitle: "二级菜单项",
menuAction: subMenuItemAction
}
subMenus.push(subMenu);
let statusBarMenuItems: Array<statusBarManager.StatusBarMenuItem> = [];
let menuItem: statusBarManager.StatusBarMenuItem = {
title: "一级菜单项",
// 一级menuAction和subMenu两项不可都缺省
subMenu: subMenus
};
statusBarMenuItems.push(menuItem);
let statusBarGroupMenus: Array<statusBarManager.StatusBarGroupMenu> = [];
statusBarGroupMenus.push(statusBarMenuItems);
let context = getContext(this);
try {
statusBarManager.updateStatusBarMenu(context, statusBarGroupMenus);
} catch (error) {
console.error(`updateStatusBarMenu failed. error code: ${error.code}, error message: ${error.message}`);
}
```
9.
```typescript
let context = getContext(this);
let height = 200;
statusBarManager.updateQuickOperationHeight(context, height);
```
10.
```typescript
let context = getContext(this);
// 获取resourceManager资源管理器
const resourceMgr = context.resourceManager;
// 创建white pixelMap，需在资源rawfile文件夹中预置testWhite.png图片，图片大小为24vp * 24vp
const whiteFileData = resourceMgr.getRawFileContentSync('testWhite.png');
const whiteBuffer = whiteFileData.buffer;
const whiteImageSource = image.createImageSource(whiteBuffer);
let whitePixelMap = await whiteImageSource.createPixelMap();
// 创建black pixelMap，需在资源rawfile文件夹中预置testBlack.png图片，图片大小为24vp * 24vp
const blackFileData = resourceMgr.getRawFileContentSync('testBlack.png');
const blackBuffer = blackFileData.buffer;
const blackImageSource = image.createImageSource(blackBuffer);
let blackPixelMap = await blackImageSource.createPixelMap();
// 构建图标信息
let icons: statusBarManager.StatusBarIcon = {
white: whitePixelMap,
black: blackPixelMap
}
statusBarManager.updateStatusBarIcon(context, icons);
```
11.
```typescript
private onStatusBarIconClick = (eventData: emitter.EventData) => {
// 自定义图标点击业务
let data = eventData.data;
if (data) {
switch data['iconClickType'] {
case 'leftClickType':
// 自定义左键点击业务
break;
default:
break;
}
}
}
// 监听状态栏图标点击事件
statusBarManager.on('statusBarIconClick', this.onStatusBarIconClick);
// 注销状态栏图标点击事件
statusBarManager.off('statusBarIconClick', this.onStatusBarIconClick);
```
12.
```typescript
private onRightMenuClick = (eventData: emitter.EventData) => {
// 自定义图标右键菜单点击业务
let data = eventData.data;
if (data) {
let menuCode = data['menuCode'];
// 处理点击菜单项业务
}
}
// 监听状态栏图标右键菜单点击事件
statusBarManager.on('rightMenuClick', this.onRightMenuClick);
// 注销状态栏图标右键菜单点击事件
statusBarManager.off('rightMenuClick', this.onRightMenuClick);
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/system-debug-optimize-V14
爬取时间: 2025-04-28 19:03:57
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/performance-analysis-kit-V14
爬取时间: 2025-04-28 19:04:11
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/performance-analysis-kit-overview-V14
爬取时间: 2025-04-28 19:04:24
来源: Huawei Developer
Performance Analysis Kit（性能分析服务）为开发者提供应用事件、日志、跟踪分析工具，可观测应用运行时状态，用于行为分析、故障分析、安全分析、统计分析，帮助开发者持续改进应用体验。
使用场景
能力范围
亮点/特征
便捷的构建APM系统
强悍的异常处理机制
全面的基础维测能力
故障分析
基于 Performance Analysis Kit（性能分析服务），为开发者提供了完善的故障检测、异常处理等能力。由于故障种类异常繁多，产品和软件业务不同，故障的原因和表现也千差万别，因此分析定位疑难问题是对工程师经验、能力、智慧的多重考验。稳定性是应用的重要质量属性，很大程度上决定了应用的开发效率和交付成本，严重影响应用质量和体验。通常可以通过开发态和运行态的故障管理设计来提升版本质量，包括故障检测、故障分析、定位、恢复、质量度量等。
为了帮助开发者更好更快的定位和解决各位应用稳定性故障，本章节还会介绍JS Crash、CppCrash、AppFreeze、资源泄露等故障的通用定位方法以及一些通用分析案例。相关内容需要开发者有编程语言、操作系统等基础知识，案例分析过程还会关联 DevEco Studio 相关能力以及 SDK 相关套件的基础运用和实践。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hilog-dev-V14
爬取时间: 2025-04-28 19:04:38
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hilog-guidelines-arkts-V14
爬取时间: 2025-04-28 19:04:51
来源: Huawei Developer
在应用开发过程中，可在关键代码处输出日志信息。在运行应用后，通过查看日志信息来分析应用执行情况（如应用是否正常运行、代码运行时序、运行逻辑分支是否正常等）。
系统提供不同的API供开发者调用并输出日志信息，即HiLog与console。两个API在使用时略有差异，本文重点介绍HiLog的用法，console的具体用法可查看API参考console。
接口说明
HiLog中定义了DEBUG、INFO、WARN、ERROR、FATAL五种日志级别，并提供了对应的方法输出不同级别的日志，接口如下表所示，具体说明可查阅API参考文档。
| 接口名 | 功能描述 |
| --- | --- |
| isLoggable(domain: number, tag: string, level: LogLevel) | 在打印日志前调用该接口，检查指定领域标识、日志标识和级别的日志是否可以打印。 |
| debug(domain: number, tag: string, format: string, ...args: any[]) | 输出DEBUG级别日志。仅用于应用/服务调试。 在DevEco Studio的terminal窗口或cmd里，通过命令“hdc shell hilogcat”设置可打印日志的等级为DEBUG。 |
| info(domain: number, tag: string, format: string, ...args: any[]) | 输出INFO级别日志。表示普通的信息。 |
| warn(domain: number, tag: string, format: string, ...args: any[]) | 输出WARN级别日志。表示存在警告。 |
| error(domain: number, tag: string, format: string, ...args: any[]) | 输出ERROR级别日志。表示存在错误。 |
| fatal(domain: number, tag: string, format: string, ...args: any[]) | 输出FATAL级别日志。表示出现致命错误、不可恢复错误。 |
输出DEBUG级别日志。仅用于应用/服务调试。
在DevEco Studio的terminal窗口或cmd里，通过命令“hdc shell hilogcat”设置可打印日志的等级为DEBUG。
参数解析
-  isLoggable()和具体日志打印接口使用的domain和tag应保持一致。
-  isLoggable()使用的level，应和具体日志打印接口级别保持一致。
-  domain：用于指定输出日志所对应的业务领域，取值范围为0x0000~0xFFFF，开发者可以根据需要进行自定义。
-  tag：用于指定日志标识，可以为任意字符串，建议标识调用所在的类或者业务行为。tag最多为31字节，超出后会截断，不建议使用中文字符，可能出现乱码或者对齐问题。
-  level：用于指定日志级别。取值见LogLevel。
-  format：格式字符串，用于日志的格式化输出。日志打印的格式化参数需按照“%{private flag}specifier”的格式打印。 格式字符串中可以设置多个参数，例如格式字符串为“%s World”，“%s”为参数类型为string的变参标识，具体取值在args中定义。
-  args：可以为0个或多个参数，是格式字符串中参数类型对应的参数列表。参数的数量、类型必须与格式字符串中的标识一一对应。
| 隐私标识符（private flag） | 说明 |
| --- | --- |
| private | 表示日志打印结果不可见，输出结果为<private>。 |
| public | 表示日志打印结果可见，明文显示参数。 |
| 无 | 缺省值默认为private，日志打印结果不可见。 |
| 格式说明符（specifier） | 说明 | 示例 |
| --- | --- | --- |
| d/i | 支持打印number和bigint类型。 | 123 |
| s | 支持打印string、undefined、boolean和null类型。 | "123" |
约束与限制
日志打印最多打印4096字节，超出限制文本将被截断。
开发示例
在按钮中增加一个单击事件，单击按钮时打印一条日志。
1.  新建一个工程，选择“Empty Ability”。
2.  工程配置界面中，Model选择“Stage”。
3.  在Project窗口单击entry > src > main > ets > pages，打开工程中的Index.ets文件，添加一个按钮，单击按钮打印日志。 示例代码如下： 以输出一条INFO级别的信息为例，表示输出一条普通信息，格式字符串为： 其中变参"%{public}s"为公共的字符串，%{public}d为公共的整型数。
```typescript
// Index.ets
import { hilog } from '@kit.PerformanceAnalysisKit';
@Entry
@Component
struct Index {
build() {
Row() {
Column() {
// 添加按钮，以响应用户点击
Button() {
Text('Next')
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
.type(ButtonType.Capsule)
.margin({
top: 20
})
.backgroundColor('#0D9FFB')
.width('40%')
.height('5%')
// 跳转按钮绑定onClick事件，点击时打印日志
.onClick(() => {
hilog.isLoggable(0xFF00, "testTag", hilog.LogLevel.INFO);
hilog.info(0xFF00, "testTag", "%{public}s World %{public}d", "hello", 3);
})
}
.width('100%')
}
.height('100%')
}
}
```
4.  在真机上运行该工程，单击应用/服务界面上的“Next”按钮。
5.  在DevEco Studio的底部，切换到“Log”窗口，设置日志的过滤条件。 选择当前的设备及进程，日志级别选择Verbose，搜索内容设置为“testTag”。此时窗口仅显示符合条件的日志。 打印日志结果为“hello World 3”。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hilog-guidelines-ndk-V14
爬取时间: 2025-04-28 19:05:05
来源: Huawei Developer
在应用开发过程中，可在关键代码处输出日志信息。在运行应用后，通过查看日志信息来分析应用执行情况（如应用是否正常运行、代码运行时序、运行逻辑分支是否正常等）。
HiLog日志系统，提供给系统框架、服务、以及应用，用于打印日志，记录用户操作、系统运行状态等。
接口说明
HiLog中定义了DEBUG、INFO、WARN、ERROR、FATAL五种日志级别，并提供了对应的方法输出不同级别的日志，接口如下表所示，具体说明可查阅API参考文档。
| 方法/宏 | 接口描述 |
| --- | --- |
| bool OH_LOG_IsLoggable(unsigned int domain, const char *tag, LogLevel level) | 检查指定domain、tag和日志级别的日志是否可以打印。 如果指定日志可以打印则返回true；否则返回false。 |
| int OH_LOG_Print(LogType type, LogLevel level, unsigned int domain, const char *tag, const char *fmt, ...) | 输出指定domain、tag和日志级别的日志，并按照printf格式类型和隐私指示确定需要输出的变参。 打印成功则返回日志总字节数；失败则返回-1。 |
| #define OH_LOG_DEBUG(type, ...) ((void)OH_LOG_Print((type), LOG_DEBUG, LOG_DOMAIN, LOG_TAG, __VA_ARGS__)) | DEBUG级别写日志，宏封装接口。 |
| #define OH_LOG_INFO(type, ...) ((void)OH_LOG_Print((type), LOG_INFO, LOG_DOMAIN, LOG_TAG, __VA_ARGS__)) | INFO级别写日志，宏封装接口。 |
| #define OH_LOG_WARN(type, ...) ((void)OH_LOG_Print((type), LOG_WARN, LOG_DOMAIN, LOG_TAG, __VA_ARGS__)) | WARN级别写日志，宏封装接口。 |
| #define OH_LOG_ERROR(type, ...) ((void)OH_LOG_Print((type), LOG_ERROR, LOG_DOMAIN, LOG_TAG, __VA_ARGS__)) | ERROR级别写日志，宏封装接口。 |
| #define OH_LOG_FATAL(type, ...) ((void)OH_LOG_Print((type), LOG_FATAL, LOG_DOMAIN, LOG_TAG, __VA_ARGS__)) | FATAL级别写日志，宏封装接口。 |
| void OH_LOG_SetCallback(LogCallback callback) | 注册函数，注册后可通过LogCallback回调获取本进程所有的hilog日志。 |
检查指定domain、tag和日志级别的日志是否可以打印。
如果指定日志可以打印则返回true；否则返回false。
输出指定domain、tag和日志级别的日志，并按照printf格式类型和隐私指示确定需要输出的变参。
打印成功则返回日志总字节数；失败则返回-1。
参数解析
OH_LOG_IsLoggable()和OH_LOG_Print()使用的domain、tag和level应保持一致。
-  domain：用于指定输出日志所对应的业务领域，取值范围为0x0000~0xFFFF，开发者可以根据需要进行自定义。
-  tag：用于指定日志标识，可以为任意字符串，建议标识调用所在的类或者业务行为。tag最多为31字节，超出后会截断，不建议使用中文字符，可能出现乱码或者对齐问题。
-  level：用于指定日志级别。取值见LogLevel。
-  fmt：格式字符串，用于日志的格式化输出。日志打印的格式化参数需按照“%{private flag}specifier”的格式打印。 格式字符串中可以设置多个参数，例如格式字符串为“%s World”，“%s”为参数类型为string的变参标识，具体取值在args中定义。
-  args：可以为0个或多个参数，是格式字符串中参数类型对应的参数列表。参数的数量、类型必须与格式字符串中的标识一一对应。
| 隐私标识符（private flag） | 说明 |
| --- | --- |
| private | 表示日志打印结果不可见，输出结果为<private>。 |
| public | 表示日志打印结果可见，明文显示参数。 |
| 无 | 缺省值默认为private，日志打印结果不可见。 |
| 格式说明符（specifier） | 说明 | 示例 |
| --- | --- | --- |
| d/i | 支持打印number、bool和bigint类型。 | 123 |
| s | 支持打印string、undefined和null类型。 | "123" |
约束与限制
日志打印最多打印4096字节，超出限制文本将被截断。
开发步骤
1.  在CMakeLists.txt中新增libhilog_ndk.z.so链接：
2.  在源文件中包含hilog头文件, 并定义domain、tag宏：
3.  打印日志，以打印ERROR级别的日志为例：
4.  输出结果：
日志回调接口使用示例
回调函数里面不允许再调用hilog接口打印日志，不然会死循环

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-V14
爬取时间: 2025-04-28 19:05:19
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-intro-V14
爬取时间: 2025-04-28 19:05:32
来源: Huawei Developer
HiAppEvent是在系统层面为应用开发者提供的一种事件打点机制，帮助应用记录在运行过程中发生的故障信息、统计信息、安全信息、用户行为信息，支撑开发者分析应用的运行情况。以便进一步统计分析访问数、日常用户活跃数量、用户操作习惯以及其他影响用户使用产品的关键因素。
基本概念
打点：记录由用户操作引起的变化，提供业务数据信息，供开发、产品、运维分析。
事件设计规范
-  事件领域：标识事件的领域，建议设置为业务模块名称，以便于区分不同的业务模块。
-  事件名称：指定事件的名称，建议设置为具体的业务名称，以便于描述实际的业务意义。
-  事件类型：指定事件的类型，支持以下四种类型事件：
-  事件参数：指定事件的参数，每个事件可以包含一组参数，建议设置为事件属性或事件发生上下文信息，以便于描述事件的详细信息。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/event-subscription-V14
爬取时间: 2025-04-28 19:05:46
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/app-event-V14
爬取时间: 2025-04-28 19:06:00
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-app-events-arkts-V14
爬取时间: 2025-04-28 19:06:53
来源: Huawei Developer
HiAppEvent提供了事件订阅接口，用于本地获取应用事件。
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考应用事件打点API文档。
打点接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| write(info: AppEventInfo, callback: AsyncCallback<void>): void | 应用事件异步打点方法，使用callback方式作为异步回调。 |
| write(info: AppEventInfo): Promise<void> | 应用事件异步打点方法，使用Promise方式作为异步回调。 |
订阅接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| addWatcher(watcher: Watcher): AppEventPackageHolder | 添加应用事件观察者，以添加对应用事件的订阅。 |
| removeWatcher(watcher: Watcher): void | 移除应用事件观察者，以移除对应用事件的订阅。 |
开发步骤
以实现对用户点击按钮行为的事件打点及订阅为例，说明开发步骤。
1.  新建一个ArkTS应用工程，编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，导入依赖模块：
```typescript
import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';
```
2.  编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets” 文件，在onCreate函数中添加对用户点击按钮事件的订阅，示例代码如下：
```typescript
hiAppEvent.addWatcher({
// 开发者可以自定义观察者名称，系统会使用名称来标识不同的观察者
name: "watcher1",
// 开发者可以订阅感兴趣的应用事件，此处是订阅了按钮事件
appEventFilters: [{ domain: "button" }],
// 开发者可以设置订阅回调触发的条件，此处是设置为事件打点数量满足1个
triggerCondition: { row: 1 },
// 开发者可以自行实现订阅回调函数，以便对订阅获取到的事件打点数据进行自定义处理
onTrigger: (curRow: number, curSize: number, holder: hiAppEvent.AppEventPackageHolder) => {
// 返回的holder对象为null，表示订阅过程发生异常，因此在记录错误日志后直接返回
if (holder == null) {
hilog.error(0x0000, 'testTag', "HiAppEvent holder is null");
return;
}
hilog.info(0x0000, 'testTag', `HiAppEvent onTrigger: curRow=%{public}d, curSize=%{public}d`, curRow, curSize);
let eventPkg: hiAppEvent.AppEventPackage | null = null;
// 根据设置阈值大小（默认为512KB）去获取订阅事件包，直到将订阅数据全部取出
// 返回的事件包对象为null，表示当前订阅数据已被全部取出，此次订阅回调触发结束
while ((eventPkg = holder.takeNext()) != null) {
// 开发者可以对事件包中的事件打点数据进行自定义处理，此处是将事件打点数据打印在日志中
hilog.info(0x0000, 'testTag', `HiAppEvent eventPkg.packageId=%{public}d`, eventPkg.packageId);
hilog.info(0x0000, 'testTag', `HiAppEvent eventPkg.row=%{public}d`, eventPkg.row);
hilog.info(0x0000, 'testTag', `HiAppEvent eventPkg.size=%{public}d`, eventPkg.size);
for (const eventInfo of eventPkg.data) {
hilog.info(0x0000, 'testTag', `HiAppEvent eventPkg.info=%{public}s`, eventInfo);
}
}
}
});
```
3.  编辑工程中的“entry > src > main > ets > pages > Index.ets” 文件，导入依赖模块：
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';
```
4.  编辑工程中的“entry > src > main > ets > pages > Index.ets” 文件，添加一个按钮并在其onClick函数中进行事件打点，以记录按钮点击事件，示例代码如下：
```typescript
Button("writeTest").onClick(()=>{
// 在按钮点击函数中进行事件打点，以记录按钮点击事件
let eventParams: Record<string, number> = { 'click_time': 100 };
let eventInfo: hiAppEvent.AppEventInfo = {
// 事件领域定义
domain: "button",
// 事件名称定义
name: "click",
// 事件类型定义
eventType: hiAppEvent.EventType.BEHAVIOR,
// 事件参数定义
params: eventParams,
};
hiAppEvent.write(eventInfo).then(() => {
hilog.info(0x0000, 'testTag', `HiAppEvent success to write event`)
}).catch((err: BusinessError) => {
hilog.error(0x0000, 'testTag', `HiAppEvent err.code: ${err.code}, err.message: ${err.message}`)
});
})
```
5.  点击DevEco Studio界面中的运行按钮，运行应用工程，然后在应用界面中点击按钮“writeTest”，触发一次按钮点击事件打点。
6.  可以在Log窗口看到按钮点击事件打点成功的日志，以及触发订阅回调后对打点事件数据的处理日志：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-app-events-ndk-V14
爬取时间: 2025-04-28 19:07:07
来源: Huawei Developer
HiAppEvent提供了事件订阅接口，用于本地获取应用事件。
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考HiAppEvent。
打点接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| int OH_HiAppEvent_Write(const char *domain, const char *name, enum EventType type, const ParamList list) | 实现对参数为列表类型的应用事件打点。 |
订阅接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| int OH_HiAppEvent_AddWatcher (HiAppEvent_Watcher *watcher) | 添加应用事件观察者，以添加对应用事件的订阅。 |
| int OH_HiAppEvent_RemoveWatcher (HiAppEvent_Watcher *watcher) | 移除应用事件观察者，以移除对应用事件的订阅。 |
开发步骤
以实现对用户点击按钮行为的事件打点及订阅为例，说明开发步骤：
1.  新建Native C++工程，并将jsoncpp导入到新建工程内，目录结构如下：
2.  编辑"CMakeLists.txt"文件，添加源文件及动态库：
3.  编辑"napi_init.cpp"文件，导入依赖的文件，并定义LOG_TAG：
4.  订阅应用事件： onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法： onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：
5.  onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法：
6.  onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：
7.  编辑"napi_init.cpp"文件，添加button事件打点接口：
8.  编辑"napi_init.cpp"文件，将RegisterWatcher和WriteAppEvent注册为ArkTS接口： 编辑"index.d.ts"文件，定义ArkTS接口：
9.  编辑"EntryAbility.ets"文件，在onCreate()函数中新增接口调用：
```typescript
// 导入依赖模块
import testNapi from 'libentry.so'
// 在onCreate()函数中新增接口调用
// 启动时，注册应用事件观察者
testNapi.registerWatcher();
```
10.  编辑"Index.ets"文件，新增按钮触发打点事件：
```typescript
import testNapi from 'libentry.so'
Button("button_click").onClick(() => {
testNapi.writeAppEvent();
})
```
11.  可以在Log窗口看到对应用事件数据的处理日志：
12.  移除应用事件观察者：
13.  销毁应用事件观察者：
-  onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法：
-  onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/system-events-V14
爬取时间: 2025-04-28 19:07:21
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crash-events-V14
爬取时间: 2025-04-28 19:07:35
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-crash-events-V14
爬取时间: 2025-04-28 19:07:48
来源: Huawei Developer
HiAppEvent提供接口用于订阅系统崩溃事件。
崩溃事件信息中params属性的详细描述如下：
params属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| time | number | 事件触发时间，单位为毫秒。 |
| crash_type | string | 崩溃类型。支持JsError和NativeCrash两种崩溃类型。 |
| foreground | boolean | 应用是否处于前台状态。 |
| bundle_version | string | 应用版本。 |
| bundle_name | string | 应用名称。 |
| pid | number | 应用的进程id。 |
| uid | number | 应用的用户id。 |
| uuid | string | 故障id。 |
| exception | object | 异常信息，详见exception属性。NativeCrash类型的崩溃事件详见exception属性（NativeCrash类型）。exception只包含故障简要信息，具体的故障定位信息见external_log文件。 |
| hilog | string[] | 日志信息，最多显示100行hilog日志，更多hilog日志通过故障日志文件获取。 |
| threads | object[] | 全量线程调用栈，详见thread属性。仅NativeCrash类型的崩溃事件提供。 |
| external_log12+ | string[] | 故障日志文件路径。故障日志文件包括CPPCRASH，JSERROR。开发者可通过该路径下的文件，完成CPPCRASH问题分析及JSERROR问题分析。为避免目录空间超限（限制参考log_over_limit），导致新生成的日志文件写入失败，日志文件处理完后请及时删除。 |
| log_over_limit12+ | boolean | 生成的故障日志文件与已存在的日志文件总大小是否超过5M上限。true表示超过上限，日志写入失败；false表示未超过上限。 |
exception属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| name | string | 异常类型。 |
| message | string | 异常原因。 |
| stack | string | 异常调用栈。 |
exception属性（NativeCrash类型）：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| message | string | 异常原因。 |
| signal | object | 信号信息，详见signal属性。 |
| thread_name | string | 线程名。 |
| tid | number | 线程id。 |
| frames | object[] | 线程调用栈，详见frame属性。 |
signal属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| signo | number | 信号值(siginfo_t中的si_signo属性) |
| code | number | 信号值二级分类（siginfo_t中的si_code属性） |
| address | string | 信号错误地址（siginfo_t中的si_address属性） |
信号值&信号值二级分类详解
thread属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| thread_name | string | 线程名。 |
| tid | number | 线程id。 |
| frames | object[] | 线程调用栈，详见frame属性。 |
frame属性(C/C++帧)：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| file | string | 文件名。 |
| symbol | string | 函数名称。 |
| buildId | string | 文件唯一标识。 |
| pc | string | pc寄存器地址。 |
| offset | number | 函数偏移量。 |
frame属性(JS帧)：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| file | string | 文件名。 |
| symbol | string | 函数名称。 |
| column | number | 异常所在行。 |
| line | number | 异常所在列。 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-crash-events-arkts-V14
爬取时间: 2025-04-28 19:08:04
来源: Huawei Developer
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考应用事件打点API文档。
使用ArkTS接口订阅崩溃事件，包含JsError和NativeCrash两种崩溃类型。
事件自定义参数设置接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| setEventParam(params: Record<string, ParamType>, domain: string, name?: string): Promise<void> | 事件自定义参数设置方法。 |
订阅接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| addWatcher(watcher: Watcher): AppEventPackageHolder | 添加应用事件观察者，以添加对应用事件的订阅。 |
| removeWatcher(watcher: Watcher): void | 移除应用事件观察者，以移除对应用事件的订阅。 |
开发步骤
以实现对用户点击按钮触发崩溃场景生成的崩溃事件订阅为例，说明开发步骤。
1.  新建一个ArkTS应用工程，编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，导入依赖模块：
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';
```
2.  编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，在onCreate函数中设置事件的自定义参数，示例代码如下：
```typescript
// 开发者完成参数键值对赋值
let params: Record<string, hiAppEvent.ParamType> = {
"test_data": 100,
};
// 开发者可以设置崩溃事件的自定义参数
hiAppEvent.setEventParam(params, hiAppEvent.domain.OS, hiAppEvent.event.APP_CRASH).then(() => {
hilog.info(0x0000, 'testTag', `HiAppEvent success to set svent param`);
}).catch((err: BusinessError) => {
hilog.error(0x0000, 'testTag', `HiAppEvent code: ${err.code}, message: ${err.message}`);
});
```
3.  编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，在onCreate函数中添加系统事件的订阅，示例代码如下：
```typescript
hiAppEvent.addWatcher({
// 开发者可以自定义观察者名称，系统会使用名称来标识不同的观察者
name: "watcher",
// 开发者可以订阅感兴趣的系统事件，此处是订阅了崩溃事件
appEventFilters: [
{
domain: hiAppEvent.domain.OS,
names: [hiAppEvent.event.APP_CRASH]
}
],
// 开发者可以自行实现订阅实时回调函数，以便对订阅获取到的事件数据进行自定义处理
onReceive: (domain: string, appEventGroups: Array<hiAppEvent.AppEventGroup>) => {
hilog.info(0x0000, 'testTag', `HiAppEvent onReceive: domain=${domain}`);
for (const eventGroup of appEventGroups) {
// 开发者可以根据事件集合中的事件名称区分不同的系统事件
hilog.info(0x0000, 'testTag', `HiAppEvent eventName=${eventGroup.name}`);
for (const eventInfo of eventGroup.appEventInfos) {
// 开发者可以对事件集合中的事件数据进行自定义处理，此处是将事件数据打印在日志中
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.domain=${eventInfo.domain}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.name=${eventInfo.name}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.eventType=${eventInfo.eventType}`);
// 开发者可以获取到崩溃事件发生的时间戳
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.time=${eventInfo.params['time']}`);
// 开发者可以获取到崩溃事件发生的崩溃类型
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.crash_type=${eventInfo.params['crash_type']}`);
// 开发者可以获取到崩溃应用的前后台状态
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.foreground=${eventInfo.params['foreground']}`);
// 开发者可以获取到崩溃应用的版本信息
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.bundle_version=${eventInfo.params['bundle_version']}`);
// 开发者可以获取到崩溃应用的包名
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.bundle_name=${eventInfo.params['bundle_name']}`);
// 开发者可以获取到崩溃应用的进程id
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.pid=${eventInfo.params['pid']}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.uid=${eventInfo.params['uid']}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.uuid=${eventInfo.params['uuid']}`);
// 开发者可以获取到崩溃事件发生的异常类型、异常原因和异常调用栈
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.exception=${JSON.stringify(eventInfo.params['exception'])}`);
// 开发者可以获取到崩溃事件发生时日志信息
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.hilog.size=${eventInfo.params['hilog'].length}`);
// 开发者可以获取到崩溃事件发生时的故障日志文件
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.external_log=${JSON.stringify(eventInfo.params['external_log'])}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.log_over_limit=${eventInfo.params['log_over_limit']}`);
// 开发者可以获取到崩溃事件的自定义数据test_data
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.test_data=${eventInfo.params['test_data']}`);
}
}
}
});
```
4.  编辑工程中的“entry > src > main > ets > pages > Index.ets”文件，添加按钮并在其onClick函数构造崩溃场景，以触发崩溃事件，示例代码如下：
```typescript
Button("appCrash").onClick(()=>{
// 在按钮点击函数中构造一个crash场景，触发应用崩溃事件
let result: object = JSON.parse("");
})
```
5.  点击DevEco Studio界面中的运行按钮，运行应用工程，然后在应用界面中点击按钮“appCrash”，触发一次崩溃事件。崩溃事件发生后，系统会根据崩溃类型（JsError或NativeCrash）采用不同的栈回溯方式生成崩溃日志，然后再进行回调。其中NativeCrash栈回溯耗时约2秒，实际耗时与业务线程数量、进程间通信耗时有关。JsError触发进程内栈回溯，NativeCrash触发进程外栈回溯，因此NativeCrash栈回溯会比JsError栈回溯更耗时。用户可以订阅崩溃事件，栈回溯完成后会异步上报，不会阻塞当前业务。
6.  若应用未捕获崩溃异常，则系统处理崩溃后应用退出，应用下次启动后HiAppEvent将崩溃事件上报给应用已注册的监听，完成回调。 若应用主动捕获崩溃异常，如下两种场景，HiAppEvent事件将会在应用退出前回调。 场景1：异常处理中未主动退出，应用发生崩溃后将不会退出。例如采用errorManger.on方法捕获JsError崩溃；应用主动注册NativeCrash崩溃信号处理函数未主动退出。 场景2：异常处理耗时太久，应用退出时机延后。 HiAppEvent上报事件完成回调后，可以在Log窗口看到对系统事件数据的处理日志：
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-crash-events-ndk-V14
爬取时间: 2025-04-28 19:08:59
来源: Huawei Developer
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考HiAppEvent。
使用C/C++接口订阅崩溃事件，包含JsError和NativeCrash两种崩溃类型。
订阅接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| int OH_HiAppEvent_AddWatcher(HiAppEvent_Watcher *watcher) | 添加应用事件观察者，以添加对应用事件的订阅。 |
| int OH_HiAppEvent_RemoveWatcher (HiAppEvent_Watcher *watcher) | 移除应用事件观察者，以移除对应用事件的订阅。 |
开发步骤
以实现对用户点击按钮触发崩溃场景生成的崩溃事件订阅为例，说明开发步骤。
1.  新建Native C++工程，并将jsoncpp导入到新建工程内，目录结构如下：
2.  编辑"CMakeLists.txt"文件，添加源文件及动态库：
3.  编辑"napi_init.cpp"文件，导入依赖的文件，并定义LOG_TAG：
4.  订阅系统事件： onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法： onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：
5.  onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法：
6.  onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：
7.  将RegisterWatcher注册为ArkTS接口： 编辑"napi_init.cpp"文件，将RegisterWatcher注册为ArkTS接口： 编辑"index.d.ts"文件，定义ArkTS接口：
8.  编辑"EntryAbility.ets"文件，在onCreate()函数中新增接口调用：
```typescript
// 导入依赖模块
import testNapi from 'libentry.so'
// 在onCreate()函数中新增接口调用
// 启动时，注册系统事件观察者
testNapi.registerWatcher();
```
9.  编辑"Index.ets"文件，新增按钮触发崩溃事件：
```typescript
Button("appCrash").onClick(() => {
JSON.parse("");
})
```
10.  点击DevEco Studio界面中的运行按钮，运行应用工程，然后在应用界面中点击按钮“appCrash”，触发一次崩溃事件。崩溃事件发生后，系统会根据崩溃类型（JsError或NativeCrash）采用不同的栈回溯方式生成崩溃日志，然后再进行回调。其中NativeCrash栈回溯耗时约2秒，实际耗时与业务线程数量、进程间通信耗时有关。JsError触发进程内栈回溯，NativeCrash触发进程外栈回溯，因此NativeCrash栈回溯会比JsError栈回溯更耗时。用户可以订阅崩溃事件，栈回溯完成后会异步上报，不会阻塞当前业务。
11.  若应用未捕获崩溃异常，则系统处理崩溃后应用退出，应用下次启动后HiAppEvent将崩溃事件上报给应用已注册的监听，完成回调。 若应用主动捕获崩溃异常，如下两种场景，HiAppEvent事件将会在应用退出前回调。 场景1：异常处理中未主动退出，应用发生崩溃后将不会退出。例如采用errorManger.on方法捕获JsError崩溃；应用主动注册NativeCrash崩溃信号处理函数未主动退出。 场景2：异常处理耗时太久，应用退出时机延后。 HiAppEvent上报事件完成回调后，可以在Log窗口看到对系统事件数据的处理日志：
12.  移除事件观察者：
13.  销毁事件观察者：
-  onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法：
-  onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/freeze-events-V14
爬取时间: 2025-04-28 19:09:52
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-freeze-events-V14
爬取时间: 2025-04-28 19:10:06
来源: Huawei Developer
HiAppEvent提供接口用于订阅系统卡死事件。
卡死事件信息中params属性的详细描述如下：
params属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| time | number | 事件触发时间，单位为毫秒。 |
| foreground | boolean | 应用是否处于前台状态。 |
| bundle_version | string | 应用版本。 |
| bundle_name | string | 应用名称。 |
| process_name | string | 应用的进程名称。 |
| pid | number | 应用的进程id。 |
| uid | number | 应用的用户id。 |
| uuid | string | 故障id。 |
| exception | object | 异常信息，详见exception属性。 |
| hilog | string[] | 日志信息。 |
| event_handler | string[] | 主线程未处理消息。 |
| event_handler_size_3s | string | THREAD_BLOCK事件3s时任务栈中任务数。 |
| event_handler_size_6s | string | THREAD_BLOCK事件6s时任务栈中任务数。 |
| peer_binder | string[] | binder调用信息。 |
| threads | object[] | 全量线程调用栈，详见thread属性。 |
| memory | object | 内存信息，详见memory属性。 |
| external_log12+ | string[] | 故障日志文件路径。为避免目录空间超限（限制参考log_over_limit），导致新生成的日志文件写入失败，日志文件处理完后请及时删除。 |
| log_over_limit12+ | boolean | 生成的故障日志文件与已存在的日志文件总大小是否超过5M上限。true表示超过上限，日志写入失败；false表示未超过上限。 |
exception属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| name | string | 异常类型。 |
| message | string | 异常原因。 |
thread属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| thread_name | string | 线程名。 |
| tid | number | 线程id。 |
| frames | object[] | 线程调用栈，详见frame属性。 |
frame属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| symbol | string | 函数名称。 |
| file | string | 文件名。 |
| buildId | string | 文件唯一标识。 |
| pc | string | pc寄存器地址。 |
| offset | number | 函数偏移量。 |
memory属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| rss | number | 进程实际占用内存大小，单位KB。 |
| vss | number | 进程向系统申请的虚拟内存大小，单位KB。 |
| pss | number | 进程实际使用的物理内存大小，单位KB。 |
| sys_free_mem | number | 空闲内存大小，单位KB。 |
| sys_avail_mem | number | 可用内存大小，单位KB。 |
| sys_total_mem | number | 总内存大小，单位KB。 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-freeze-events-arkts-V14
爬取时间: 2025-04-28 19:10:20
来源: Huawei Developer
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考应用事件打点API文档。
事件自定义参数设置接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| setEventParam(params: Record<string, ParamType>, domain: string, name?: string): Promise<void> | 事件自定义参数设置方法。 |
订阅接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| addWatcher(watcher: Watcher): AppEventPackageHolder | 添加应用事件观察者，以添加对应用事件的订阅。 |
| removeWatcher(watcher: Watcher): void | 移除应用事件观察者，以移除对应用事件的订阅。 |
开发步骤
以实现对用户点击按钮触发卡死场景生成的卡死事件订阅为例，说明开发步骤。
1.  新建一个ArkTS应用工程，编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，导入依赖模块：
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';
```
2.  编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，在onCreate函数中设置事件的自定义参数，示例代码如下：
```typescript
// 开发者完成参数键值对赋值
let params: Record<string, hiAppEvent.ParamType> = {
"test_data": 100,
};
// 开发者可以设置卡死事件的自定义参数
hiAppEvent.setEventParam(params, hiAppEvent.domain.OS, hiAppEvent.event.APP_FREEZE).then(() => {
hilog.info(0x0000, 'testTag', `HiAppEvent success to set svent param`);
}).catch((err: BusinessError) => {
hilog.error(0x0000, 'testTag', `HiAppEvent code: ${err.code}, message: ${err.message}`);
});
```
3.  编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，在onCreate函数中添加系统事件的订阅，示例代码如下：
```typescript
hiAppEvent.addWatcher({
// 开发者可以自定义观察者名称，系统会使用名称来标识不同的观察者
name: "watcher",
// 开发者可以订阅感兴趣的系统事件，此处是订阅了卡死事件
appEventFilters: [
{
domain: hiAppEvent.domain.OS,
names: [hiAppEvent.event.APP_FREEZE]
}
],
// 开发者可以自行实现订阅实时回调函数，以便对订阅获取到的事件数据进行自定义处理
onReceive: (domain: string, appEventGroups: Array<hiAppEvent.AppEventGroup>) => {
hilog.info(0x0000, 'testTag', `HiAppEvent onReceive: domain=${domain}`);
for (const eventGroup of appEventGroups) {
// 开发者可以根据事件集合中的事件名称区分不同的系统事件
hilog.info(0x0000, 'testTag', `HiAppEvent eventName=${eventGroup.name}`);
for (const eventInfo of eventGroup.appEventInfos) {
// 开发者可以对事件集合中的事件数据进行自定义处理，此处是将事件数据打印在日志中
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.domain=${eventInfo.domain}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.name=${eventInfo.name}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.eventType=${eventInfo.eventType}`);
// 开发者可以获取到卡死事件发生的时间戳
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.time=${eventInfo.params['time']}`);
// 开发者可以获取到卡死应用的前后台状态
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.foreground=${eventInfo.params['foreground']}`);
// 开发者可以获取到卡死应用的版本信息
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.bundle_version=${eventInfo.params['bundle_version']}`);
// 开发者可以获取到卡死应用的包名
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.bundle_name=${eventInfo.params['bundle_name']}`);
// 开发者可以获取到卡死应用的进程名称
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.process_name=${eventInfo.params['process_name']}`);
// 开发者可以获取到卡死应用的进程id
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.pid=${eventInfo.params['pid']}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.uid=${eventInfo.params['uid']}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.uuid=${eventInfo.params['uuid']}`);
// 开发者可以获取到卡死事件发生的异常类型、异常原因
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.exception=${JSON.stringify(eventInfo.params['exception'])}`);
// 开发者可以获取到卡死事件发生时日志信息
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.hilog.size=${eventInfo.params['hilog'].length}`);
// 开发者可以获取到卡死事件发生时主线程未处理消息
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.event_handler.size=${eventInfo.params['event_handler'].length}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.event_handler_size_3s=${eventInfo.params['event_handler_size_3s']}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.event_handler_size_6s=${eventInfo.params['event_handler_size_6s']}`);
// 开发者可以获取到卡死事件发生时同步binder调用信息
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.peer_binder.size=${eventInfo.params['peer_binder'].length}`);
// 开发者可以获取到卡死事件发生时全量线程调用栈
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.threads.size=${eventInfo.params['threads'].length}`);
// 开发者可以获取到卡死事件发生时内存信息
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.memory=${JSON.stringify(eventInfo.params['memory'])}`);
// 开发者可以获取到卡死事件发生时的故障日志文件
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.external_log=${JSON.stringify(eventInfo.params['external_log'])}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.log_over_limit=${eventInfo.params['log_over_limit']}`);
// 开发者可以获取到卡死事件的自定义数据test_data
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.test_data=${eventInfo.params['test_data']}`);
}
}
}
});
```
4.  编辑工程中的“entry > src > main > ets > pages > Index.ets”文件，添加按钮并在其onClick函数构造卡死场景，以触发卡死事件，示例代码如下：
```typescript
Button("appFreeze").onClick(()=>{
// 在按钮点击函数中构造一个freeze场景，触发应用卡死事件
setTimeout(() => {
while (true) {}
}, 1000)
})
```
5.  点击DevEco Studio界面中的运行按钮，运行应用工程，然后在应用界面中点击按钮“appFreeze”，触发一次卡死事件。
6.  应用卡死退出后，重新进入应用可以在Log窗口看到对系统事件数据的处理日志：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-freeze-events-ndk-V14
爬取时间: 2025-04-28 19:10:34
来源: Huawei Developer
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考HiAppEvent。
订阅接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| int OH_HiAppEvent_AddWatcher (HiAppEvent_Watcher *watcher) | 添加应用事件观察者，以添加对应用事件的订阅。 |
| int OH_HiAppEvent_RemoveWatcher (HiAppEvent_Watcher *watcher) | 移除应用事件观察者，以移除对应用事件的订阅。 |
开发步骤
以实现对用户点击按钮触发卡顿场景生成的卡顿事件订阅为例，说明开发步骤。
1.  新建Native C++工程，并将jsoncpp导入到新建工程内，目录结构如下：
2.  编辑"CMakeLists.txt"文件，添加源文件及动态库：
3.  编辑"napi_init.cpp"文件，导入依赖的文件，并定义LOG_TAG：
4.  订阅系统事件： onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法： onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：
5.  onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法：
6.  onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：
7.  将RegisterWatcher注册为ArkTS接口： 编辑"napi_init.cpp"文件，将RegisterWatcher注册为ArkTS接口： 编辑"index.d.ts"文件，定义ArkTS接口：
8.  编辑"EntryAbility.ets"文件，在onCreate()函数中新增接口调用：
```typescript
// 导入依赖模块
import testNapi from 'libentry.so'
// 在onCreate()函数中新增接口调用
// 启动时，注册系统事件观察者
testNapi.registerWatcher();
```
9.  编辑"Index.ets"文件，新增按钮触发卡顿事件：
```typescript
Button("appFreeze").onClick(() => {
setTimeout(()=>{
while(true) {}
}, 1000)
})
```
10.  点击DevEco Studio界面中的运行按钮，运行应用工程，然后在应用界面中点击按钮“appFreeze”，触发一次卡死事件。
11.  应用工程崩溃退出后再次运行可以在Log窗口看到对系统事件数据的处理日志：
12.  移除事件观察者：
13.  销毁事件观察者：
-  onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法：
-  onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/resource-leak-events-V14
爬取时间: 2025-04-28 19:10:47
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-resourceleak-events-V14
爬取时间: 2025-04-28 19:11:01
来源: Huawei Developer
HiAppEvent提供接口用于订阅系统资源泄漏事件。
资源泄漏事件信息中params属性的详细描述如下：
params属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| time | number | 事件触发时间，单位为毫秒。 |
| bundle_version | string | 应用版本。 |
| bundle_name | string | 应用名称。 |
| pid | number | 应用的进程id。 |
| uid | number | 应用的用户id。 |
| resource_type | string | 资源类型，取值范围详见resource_type属性。 |
| memory | object | （resource_type为pss_memory或js_heap专有）内存信息，详见memory属性。 |
| fd | object | （resource_type为fd专有）文件描述符信息，详见fd属性。 |
| thread | object | （resource_type为thread专有）线程信息，详见thread属性。 |
| external_log | string[] | 故障日志文件路径。为避免目录空间超限（限制参考log_over_limit），导致新生成的日志文件写入失败，日志文件处理完后请及时删除。 |
| log_over_limit | Boolean | 生成的故障日志文件与已存在的日志文件总大小是否超过2G上限。true表示超过上限，日志写入失败；false表示未超过上限。 |
resource_type属性：
| 取值 | 说明 |
| --- | --- |
| pss_memory | pss内存泄漏。 |
| js_heap | js内存泄漏。 |
| fd | fd资源泄漏。 |
| thread | 线程泄漏。 |
memory属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| rss | number | （resource_type为pss_memory专有）进程实际占用内存大小，单位KB。 |
| vss | number | （resource_type为pss_memory专有）进程向系统申请的虚拟内存大小，单位KB。 |
| pss | number | （resource_type为pss_memory专有）进程实际使用的物理内存大小，单位KB。 |
| sys_free_mem | number | （resource_type为pss_memory专有）空闲内存大小，单位KB。 |
| sys_avail_mem | number | （resource_type为pss_memory专有）可用内存大小，单位KB。 |
| sys_total_mem | number | （resource_type为pss_memory专有）总内存大小，单位KB。 |
| limit_size | number | （resource_type为js_heap专有）基线大小，单位KB。 |
| live_object_size | number | （resource_type为js_heap专有）实际使用内存大小，单位KB。 |
fd属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| num | number | fd总数量。 |
| top_fd_type | string | 数量最多的fd类型。 |
| top_fd_num | number | top_fd_type的数量。 |
thread属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| num | number | thread总数量。 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-resourceleak-events-arkts-V14
爬取时间: 2025-04-28 19:11:15
来源: Huawei Developer
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考应用事件打点API文档。
| 接口名 | 描述 |
| --- | --- |
| addWatcher(watcher: Watcher): AppEventPackageHolder | 添加应用事件观察者，以添加对应用事件的订阅。 |
| removeWatcher(watcher: Watcher): void | 移除应用事件观察者，以移除对应用事件的订阅。 |
开发步骤
以实现对发生内存泄漏场景生成的资源泄漏事件订阅为例，说明开发步骤。
1.  新建一个ArkTS应用工程，编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，导入依赖模块：
```typescript
import { hiAppEvent, hilog, hidebug } from '@kit.PerformanceAnalysisKit';
```
2.  编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，在onCreate函数中添加系统事件的订阅，示例代码如下：
```typescript
hiAppEvent.addWatcher({
// 开发者可以自定义观察者名称，系统会使用名称来标识不同的观察者
name: "watcher",
// 开发者可以订阅感兴趣的系统事件，此处是订阅了资源泄漏事件
appEventFilters: [
{
domain: hiAppEvent.domain.OS,
names: [hiAppEvent.event.RESOURCE_OVERLIMIT]
}
],
// 开发者可以自行实现订阅实时回调函数，以便对订阅获取到的事件数据进行自定义处理
onReceive: (domain: string, appEventGroups: Array<hiAppEvent.AppEventGroup>) => {
hilog.info(0x0000, 'testTag', `HiAppEvent onReceive: domain=${domain}`);
for (const eventGroup of appEventGroups) {
// 开发者可以根据事件集合中的事件名称区分不同的系统事件
hilog.info(0x0000, 'testTag', `HiAppEvent eventName=${eventGroup.name}`);
for (const eventInfo of eventGroup.appEventInfos) {
// 开发者可以获取到资源泄漏事件发生时内存信息
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.memory=${JSON.stringify(eventInfo)}`);
}
}
}
});
```
3.  编辑工程中的“entry > src > main > ets > pages > Index.ets”文件，添加按钮并在其onClick函数构造资源泄漏场景，以触发资源泄漏事件。 此处需要使用hidebug.setAppResourceLimit设置内存限制，造成内存内存泄漏，需要同步在“开发者选项”中打开“系统资源泄漏日志”(打开或关闭开关均需重启设备)。接口示例代码如下：
```typescript
import hidebug from "@ohos.hidebug";
@Entry
@Component
struct Index {
@State leakedArray: string[][] = [];
build() {
Column() {
Row() {
Column() {
Button("pss leak")
.onClick(() => {
hidebug.setAppResourceLimit("pss_memory", 1024, true);
for (let i = 0; i < 20 * 1024; i++) {
this.leakedArray.push(new Array(1).fill("leak"));
}
})
}
}
.height('100%')
.width('100%')
}
}
}
```
4.  点击DevEco Studio界面中的运行按钮，运行应用工程，等待15~30分钟，会上报应用内存泄漏事件。 同一个应用，24小时内至多上报一次内存泄漏，如果短时间内要二次上报，需要重启设备。
5.  内存泄漏事件上报后，系统会回调应用的onReceive函数，可以在Log窗口看到对系统事件数据的处理日志：
6.  当前基于HarmonyOS构建的商用OS，在nolog版本中开放了应用发生OOM场景下订阅虚拟机堆快照的功能。应用需要依次调用 hidebug.setAppResourceLimit 和 hiAppEvent.addWatcher，且在 AppScope/app.json5 文件中配置如下环境变量： 因堆快照文件大小约为0.4至1.2GB（zip压缩后约为50至100MB），体积较大，因此系统会对堆快照的生成次数做管控，具体规格如下： 若整机剩余存储空间不足30GB，则不触发oomdump功能。 开发者在调试期间，可通过将系统时间调整至7天后并重启设备的方式重置应用触发oomdump的次数，以便快速完成功能适配与验证。 请应用在收到该订阅事件后，首先从事件的external_log字段中获取堆快照文件存储路径，并将其尽快搬移或上传云，然后再删除原堆快照文件，否则可能会因应用沙箱路径目录剩余存储空间不足(最大2GB)导致下次堆快照文件无法生成。 json5配置文件中的value字段内容格式支持键值对集合“key1:value1;key2:value2;...”。目前系统仅支持配置如上键值对的应用，在nolog版本使能oomdump功能。 订阅后生成的.log日志文件需要将后缀名修改为.rawheap文件，再通过translator工具转换为.heapsnapshot文件，通过DevEco Studio或浏览器打开展示，详情见Snapshot离线导入。
7.  若整机剩余存储空间不足30GB，则不触发oomdump功能。 开发者在调试期间，可通过将系统时间调整至7天后并重启设备的方式重置应用触发oomdump的次数，以便快速完成功能适配与验证。
-  若整机剩余存储空间不足30GB，则不触发oomdump功能。 开发者在调试期间，可通过将系统时间调整至7天后并重启设备的方式重置应用触发oomdump的次数，以便快速完成功能适配与验证。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-resourceleak-events-ndk-V14
爬取时间: 2025-04-28 19:11:29
来源: Huawei Developer
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考HiAppEvent。
订阅接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| int OH_HiAppEvent_AddWatcher(HiAppEvent_Watcher *watcher) | 添加应用事件观察者，以添加对应用事件的订阅。 |
| int OH_HiAppEvent_RemoveWatcher(HiAppEvent_Watcher *watcher) | 移除应用事件观察者，以移除对应用事件的订阅。 |
开发步骤
1.  新建Native C++工程，并将jsoncpp导入到新建工程内，目录结构如下：
2.  编辑"CMakeLists.txt"文件，添加源文件及动态库：
3.  编辑"napi_init.cpp"文件，导入依赖的文件，并定义LOG_TAG：
4.  订阅系统事件： onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法： onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：
5.  onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法：
6.  onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：
7.  将RegisterWatcher注册为ArkTS接口： 编辑"napi_init.cpp"文件，将RegisterWatcher注册为ArkTS接口： 编辑"index.d.ts"文件，定义ArkTS接口：
8.  编辑"EntryAbility.ets"文件，在onCreate()函数中新增接口调用：
```typescript
import testNapi from 'libentry.so'
import hidebug from '@kit.PerformanceAnalysisKit'
export default class EntryAbility extends UIAbility {
onCreate(want, launchParam) {
// 启动时，注册系统事件观察者
testNapi.registerWatcher();
}
}
```
9.  编辑工程中的“entry > src > main > ets > pages > Index.ets”文件，添加按钮并在其onClick函数构造资源泄漏场景，以触发资源泄漏事件。 此处需要使用hidebug.setAppResourceLimit设置内存限制，造成内存内存泄漏，需要同步在“开发者选项”中打开“系统资源泄漏日志”(打开或关闭开关均需重启设备)。接口示例代码如下：
```typescript
import hidebug from "@ohos.hidebug";
@Entry
@Component
struct Index {
@State leakedArray: string[][] = [];
build() {
Column() {
Row() {
Column() {
Button("pss leak")
.onClick(() => {
hidebug.setAppResourceLimit("pss_memory", 1024, true);
for (let i = 0; i < 20 * 1024; i++) {
this.leakedArray.push(new Array(1).fill("leak"));
}
})
}
}
.height('100%')
.width('100%')
}
}
}
```
10.  点击DevEco Studio界面中的运行按钮，运行应用工程，等待15~30分钟，会上报应用内存泄漏事件。 同一个应用，24小时内至多上报一次内存泄漏，如果短时间内要二次上报，需要重启设备。
11.  内存泄漏事件上报后，可以在Log窗口看到对系统事件数据的处理日志：
12.  移除事件观察者：
13.  销毁事件观察者：
-  onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法：
-  onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/address-sanitizer-events-V14
爬取时间: 2025-04-28 19:11:43
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-address-sanitizer-events-V14
爬取时间: 2025-04-28 19:11:57
来源: Huawei Developer
HiAppEvent提供接口用于订阅系统踩内存事件。
踩内存事件信息中params属性的详细描述如下：
params属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| time | number | 事件触发时间，单位为毫秒。 |
| bundle_version | string | 应用版本。 |
| bundle_name | string | 应用名称。 |
| pid | number | 应用的进程id。 |
| uid | number | 应用的用户id。 |
| type | string | 地址越界错误类型，取值范围详见type属性。 |
| external_log | string[] | 故障日志文件路径。为避免目录空间超限（限制参考log_over_limit），导致新生成的日志文件写入失败，日志文件处理完后请及时删除。 |
| log_over_limit | boolean | 生成的故障日志文件与已存在的日志文件总大小是否超过5M上限。true表示超过上限，日志写入失败；false表示未超过上限。 |
type属性：
| 取值 | 说明 |
| --- | --- |
| alloc-dealloc-mismatch | 内存分配和释放方式不匹配。 |
| allocation-size-too-big | 当分配对堆来说太大时发现的错误。 |
| calloc-overflow | calloc分配内存错误。 |
| container-overflow | 容器溢出。 |
| double-free | 释放已释放的内存。 |
| dynamic-stack-buffer-overflow | 缓冲区访问超出堆栈分配对象的边界。 |
| global-buffer-overflow | 全局缓冲区溢出。 |
| heap-buffer-overflow | 堆缓冲区溢出。 |
| heap-use-after-free | 使用已释放的堆内存。 |
| invalid-allocation-alignment | 无效的内存分配对齐方式。 |
| memcpy-param-overlap | memcpy不支持重叠内存。 |
| new-delete-type-mismatch | 内存释放大小与分配大小不一致。 |
| stack-buffer-overflow | 堆栈缓冲区溢出。 |
| stack-buffer-underflow | 堆栈缓冲区下溢。 |
| stack-use-after-return | 在返回后使用堆栈内存。 |
| stack-use-after-scope | 使用超出范围的堆栈内存。 |
| strcat-param-overlap | 在重叠缓冲区中移动内存导致的错误。 |
| use-after-poison | 使用已中毒的内存。 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-address-sanitizer-events-arkts-V14
爬取时间: 2025-04-28 19:12:10
来源: Huawei Developer
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考应用事件打点API文档。
| 接口名 | 描述 |
| --- | --- |
| addWatcher(watcher: Watcher): AppEventPackageHolder | 添加应用事件观察者，以添加对应用事件的订阅。 |
| removeWatcher(watcher: Watcher): void | 移除应用事件观察者，以移除对应用事件的订阅。 |
开发步骤
以实现对写数组越界场景生成的踩内存事件订阅为例，说明开发步骤。
1.  新建Native C++工程，目录结构如下：
2.  编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，导入依赖模块：
```typescript
import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';
```
3.  编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，在onCreate函数中添加系统事件的订阅，示例代码如下：
```typescript
hiAppEvent.addWatcher({
// 开发者可以自定义观察者名称，系统会使用名称来标识不同的观察者
name: "watcher",
// 开发者可以订阅感兴趣的系统事件，此处是订阅了踩内存事件
appEventFilters: [
{
domain: hiAppEvent.domain.OS,
names: [hiAppEvent.event.ADDRESS_SANITIZER]
}
],
// 开发者可以自行实现订阅系统事件回调函数，以便对订阅获取到的事件数据进行自定义处理
onReceive: (domain: string, appEventGroups: Array<hiAppEvent.AppEventGroup>) => {
hilog.info(0x0000, 'testTag', `HiAppEvent onReceive: domain=${domain}`);
for (const eventGroup of appEventGroups) {
// 开发者可以根据事件集合中的事件名称区分不同的系统事件
hilog.info(0x0000, 'testTag', `HiAppEvent eventName=${eventGroup.name}`);
for (const eventInfo of eventGroup.appEventInfos) {
// 开发者可以对事件集合中的事件数据进行自定义处理，此处是将事件数据打印在日志中
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.domain=${eventInfo.domain}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.name=${eventInfo.name}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.eventType=${eventInfo.eventType}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.time=${eventInfo.params['time']}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.bundle_version=${eventInfo.params['bundle_version']}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.bundle_name=${eventInfo.params['bundle_name']}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.pid=${eventInfo.params['pid']}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.uid=${eventInfo.params['uid']}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.type=${eventInfo.params['type']}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.external_log=${JSON.stringify(eventInfo.params['external_log'])}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.log_over_limit=${eventInfo.params['log_over_limit']}`);
}
}
}
});
```
4.  编辑“entry > src > main > cpp > types > libentry > index.d.ts”文件，完整示例代码如下：
```typescript
export const test: () => void;
```
5.  编辑“entry > src > main > cpp > napi_init.cpp”文件，该文件实现地址越界场景，并提供NAPI接口给应用层代码调用，完整示例代码如下：
6.  编辑工程中的“entry > src > main > ets > pages > Index.ets”文件，新增按钮触发踩内存事件：
```typescript
import testNapi from 'libentry.so'
@Entry
@Component
struct Index {
build() {
Row() {
Column() {
Button("address-sanitizer").onClick(() => {
testNapi.test();
})
}
.width('100%')
}
.height('100%')
}
}
```
7.  点击DevEco Studio界面中的“entry”，点击“Edit Configurations”，点击“Diagnostics”，勾选“Address Sanitizer”，保存设置。点击DevEco Studio界面中的运行按钮，运行应用工程，然后在应用界面中点击按钮“address-sanitizer”，触发一次踩内存事件。应用崩溃后重新进入应用，可以在Log窗口看到对系统事件数据的处理日志：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-address-sanitizer-events-ndk-V14
爬取时间: 2025-04-28 19:12:24
来源: Huawei Developer
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考HiAppEvent。
订阅接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| int OH_HiAppEvent_AddWatcher (HiAppEvent_Watcher *watcher) | 添加应用事件观察者，以添加对应用事件的订阅。 |
| int OH_HiAppEvent_RemoveWatcher (HiAppEvent_Watcher *watcher) | 移除应用事件观察者，以移除对应用事件的订阅。 |
开发步骤
以实现对写数组越界场景生成的踩内存事件订阅为例，说明开发步骤。
1.  新建Native C++工程，并将jsoncpp导入到新建工程内，目录结构如下：
2.  编辑"CMakeLists.txt"文件，添加源文件及动态库：
3.  编辑"napi_init.cpp"文件，导入依赖的文件，并定义LOG_TAG：
4.  订阅系统事件： onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法： onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：
5.  onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法：
6.  onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：
7.  构造地址越界错误： 编辑"napi_init.cpp"文件，定义Test方法, 方法中对一个整数数组进行越界访问：
8.  将RegisterWatcher和Test注册为ArkTS接口： 编辑"napi_init.cpp"文件，将RegisterWatcher和Test注册为ArkTS接口： 编辑"index.d.ts"文件，定义ArkTS接口：
9.  编辑"EntryAbility.ets"文件，在onCreate()函数中新增接口调用：
```typescript
// 导入依赖模块
import testNapi from 'libentry.so'
// 在onCreate()函数中新增接口调用
// 启动时，注册系统事件观察者
testNapi.registerWatcher();
```
10.  编辑“entry > src > main > ets > pages > Index.ets”文件，新增按钮触发踩内存事件：
```typescript
import testNapi from 'libentry.so'
@Entry
@Component
struct Index {
build() {
Row() {
Column() {
Button("address-sanitizer").onClick(() => {
testNapi.test();
})
}
.width('100%')
}
.height('100%')
}
}
```
11.  点击DevEco Studio界面中的“entry”，点击“Edit Configurations”，点击“Diagnostics”，勾选“Address Sanitizer”，保存设置。点击DevEco Studio界面中的运行按钮，运行应用工程，然后在应用界面中点击按钮“address-sanitizer”，触发一次踩内存事件。应用崩溃后重新进入应用，可以在Log窗口看到对系统事件数据的处理日志：
12.  移除事件观察者：
13.  销毁事件观察者：
-  onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法：
-  onTrigger类型观察者： 编辑"napi_init.cpp"文件，定义OnTrigger类型观察者相关方法：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/main-thread-jank-events-V14
爬取时间: 2025-04-28 19:12:38
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-mainthreadjank-events-V14
爬取时间: 2025-04-28 19:12:51
来源: Huawei Developer
HiAppEvent提供接口用于订阅主线程超时事件。
主线程超时事件信息中params属性的详细描述如下：
params属性：
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| time | number | 事件触发时间，单位为毫秒。 |
| bundle_version | string | 应用版本。 |
| bundle_name | string | 应用名称。 |
| pid | number | 应用的进程id。 |
| uid | number | 应用的用户id。 |
| begin_time | number | 主线程任务开始时间。 |
| end_time | number | 主线程任务结束时间。 |
| external_log | string[] | 主线程超时日志文件路径。为避免目录空间超限（限制参考log_over_limit），导致新生成的日志文件写入失败，日志文件处理完后请及时删除。 |
| log_over_limit | boolean | 生成的主线程超时日志文件与已存在的日志文件总大小是否超过10M上限。true表示超过上限，日志写入失败；false表示未超过上限。 |
主线程超时事件时间规格
1.  启动时间 主线程超时采样栈（150ms < 主线程处理时长 < 450ms）。同一个应用的PID一个生命周期仅会触发一次主线程超时事件采样栈。 主线程超时采样Trace（主线程处理时长 > 450ms）。同一个应用的UID一天仅会触发一次主线程超时事件采样trace。 启动主线程超时检测抓取trace的功能的前提：开发者使用nolog版本，开发者模式处于关闭状态； log和nolog版本：在手机中，点击设置——搜索关键字“关于本机”——软件版本进行查看。log版本会以log结尾； 关闭开发者模式后， 可能无法使用DevEco Studio。因此，可以提前安装应用，再关闭开发者模式。
2.  抓栈时间 主线程处理事件超时后，开始执行周期性任务检测，每隔155ms检测主线程是否再次发生超时事件(1 <= 检测次数 <= 2)，共三种情况： (1) 第一次检测发现超时事件，开始执行堆栈采样，每隔155ms采样一次，共采样10次堆栈，第11次收集堆栈并上报事件，结束检测。 (2) 第一次检测未发生超时事件，第二次检测发现超时事件，开始执行堆栈采样，每隔155ms采样一次，共采样10次堆栈，第11次收集堆栈并上报事件，结束检测。 (3) 两次检测均未发现超时事件，结束检测。
3.  抓trace时间 主线程超时抓Trace调用录制函数后，每隔150ms检测主线程是否再次发生超时事件(检测次数 = 20)，其中，只要在20个间隔检测时，有一次主线程事件超时150ms，3s检测结束后落盘trace。 (1) 20次检测均未发生主线程超时150ms事件。 (2) 20次检测至少有一次发生主线程超时150ms事件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170521.92878808411516764658896288458156:50001231000000:2800:37935CCACA88B3C954238397DDA329C17E70219A19A4D578BF1795D06E586203.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170521.29558024353824298830283789092844:50001231000000:2800:93DBCDBB6E410E239428AB7AD519A1249974AB7CFF39277B923279F7ED5F5D44.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170521.45591412180057816502445964104604:50001231000000:2800:A0270F8DADD82ED6C1D996599FBB279C81FB5BB45A871BAFB9C8A712BF1BB505.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170521.39258314630217461515001240459254:50001231000000:2800:035101F6CFE317DFD7134A568905162C505E15AFBE410A4067F4B9D0D999858F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170521.48249772882740985333488671701741:50001231000000:2800:9D1892CA52F06EB5097B25EB30E577A1E279822B16C9E37BE51B0DA92E0FABA5.png)
主线程超时事件规格
1.  日志老化规格 一般情况，栈文件的大小为7-10KB，trace文件大小为3-6M。应用沙箱内的watchdog目录最大保存10M内容，超出后，需要用户手动清理文件。目录地址：/data/app/el2/100/log/应用bundle name/watchdog。
2.  事件里如何获取日志：从external_logs中获取日志路径。
3.  抓栈功能目前只支持ARM64架构，抓栈结果为解析后的混合栈信息，包含native帧和JS帧。 抓栈结果部分示例如下： 每次抓栈拷贝16KB主线程调用栈信息进行回栈解析，所以每一次抓栈结果最多可以展示进程16KB调用信息，共进行10次，重复栈帧会聚合在一起，不同调用层次通过行缩进进行区分，最终以树型方式进行展示。当抓栈失败（如主线程阻塞在内核或信号被屏蔽等情况）时，将会输出"/proc/self/wchan"文件内容。 展示结果中每一行表示一个栈信息，每一行栈帧信息所表示的意义可以按如下方式解读： native帧格式如下： JS帧格式如下：
4.  trace规格简介 trace大小为1-5M，对于trace文件的解析可以使用smpartperf在线工具进行解读。 导入trace文件后页面解读：从上往下主要展示时间轴、cpu使用率、cpu使用情况、进程间通讯数据的方法调用情况、进程、线程和方法调用情况，由此可以在事件维度上对这些数据进行直观展示。 更多对trace文件使用的介绍可以参考：web端加载trace说明。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-mainthreadjank-events-arkts-V14
爬取时间: 2025-04-28 19:13:05
来源: Huawei Developer
主线程超时事件规格说明
请参考主线程超时事件介绍。
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考应用事件打点API文档。
| 接口名 | 描述 |
| --- | --- |
| addWatcher(watcher: Watcher): AppEventPackageHolder | 添加应用事件观察者，以添加对应用事件的订阅。 |
| removeWatcher(watcher: Watcher): void | 移除应用事件观察者，以移除对应用事件的订阅。 |
开发步骤
本例以订阅主线程超时事件，发生主线程超时触发采样栈场景为例，说明开发步骤。
1.  新建一个ArkTS应用工程，编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，导入依赖模块：
```typescript
import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';
```
2.  编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，在onCreate函数中添加系统事件的订阅，示例代码如下：
```typescript
hiAppEvent.addWatcher({
// 开发者可以自定义观察者名称，系统会使用名称来标识不同的观察者
name: "watcher",
// 开发者可以订阅感兴趣的系统事件，此处是订阅了主线程超时事件
appEventFilters: [
{
domain: hiAppEvent.domain.OS,
names: [hiAppEvent.event.MAIN_THREAD_JANK]
}
],
// 开发者可以自行实现订阅实时回调函数，以便对订阅获取到的事件数据进行自定义处理
onReceive: (domain: string, appEventGroups: Array<hiAppEvent.AppEventGroup>) => {
hilog.info(0x0000, 'testTag', `HiAppEvent onReceive: domain=${domain}`);
for (const eventGroup of appEventGroups) {
// 开发者可以根据事件集合中的事件名称区分不同的系统事件
hilog.info(0x0000, 'testTag', `HiAppEvent eventName=${eventGroup.name}`);
for (const eventInfo of eventGroup.appEventInfos) {
// 开发者可以对事件集合中的事件数据进行自定义处理，此处是将事件数据打印在日志中
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.domain=${eventInfo.domain}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.name=${eventInfo.name}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.eventType=${eventInfo.eventType}`);
// 开发者可以获取到主线程超时事件发生的时间戳
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.time=${eventInfo.params['time']}`);
// 开发者可以获取到主线程超时应用的版本信息
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.bundle_version=${eventInfo.params['bundle_version']}`);
// 开发者可以获取到主线程超时应用的包名
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.bundle_name=${eventInfo.params['bundle_name']}`);
// 开发者可以获取到主线程超时应用的pid、uid
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.pid=${eventInfo.params['pid']}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.uid=${eventInfo.params['uid']}`);
// 开发者可以获取主线程处理开始和结束时间
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.begin_time=${eventInfo.params['begin_time']}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.end_time=${eventInfo.params['end_time']}`);
// 开发者可以获取到主线程超时事件发生时的故障日志文件
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.external_log=${JSON.stringify(eventInfo.params['external_log'])}`);
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.params.log_over_limit=${eventInfo.params['log_over_limit']}`);
}
}
}
});
```
3.  编辑工程中的“entry > src > main > ets > pages> Index.ets”文件，添加一个Button控件onClick中实现主线程超时代码，示例代码如下：
```typescript
Button("timeOut350")
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
let t = Date.now();
while (Date.now() - t <= 350) {}
})
```
4.  点击DevEco Studio界面中的运行按钮，运行应用工程，连续点击两次timeOut350按钮，会触发主线程超时事件。
5.  主线程超时事件上报后，系统会回调应用的onReceive函数，可以在Log窗口看到对系统事件数据的处理日志： 主线程超时事件采样栈示例： 主线程超时事件采样trace，与采样栈的结果大致相同，不同的地方： 栈： external_log=["/data/storage/el2/log/watchdog/MAIN_THREAD_JANK_yyyyMMDDHHmmss_xxxx.txt"]。xxxx：代表进程pid。 trace： external_log=[""/data/storage/el2/log/watchdog/MAIN_THREAD_JANK_unix时间戳_xxxx.trace"]。xxxx：代表进程pid。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-mainthreadjank-events-ndk-V14
爬取时间: 2025-04-28 19:13:19
来源: Huawei Developer
主线程超时事件规格说明
请参考主线程超时事件介绍。
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考HiAppEvent。
订阅接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| int OH_HiAppEvent_AddWatcher(HiAppEvent_Watcher *watcher) | 添加应用事件观察者，以添加对应用事件的订阅。 |
| int OH_HiAppEvent_RemoveWatcher(HiAppEvent_Watcher *watcher) | 移除应用事件观察者，以移除对应用事件的订阅。 |
开发步骤
本例以订阅主线程超时事件，发生主线程超时触发采样栈场景为例，说明开发步骤。
1.  新建Native C++工程，并将jsoncpp导入到新建工程内，目录结构如下：
2.  编辑"CMakeLists.txt"文件，添加源文件及动态库：
3.  编辑"napi_init.cpp"文件，导入依赖的文件，并定义LOG_TAG：
4.  订阅系统事件： onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法：
5.  onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法：
6.  将RegisterWatcher注册为ArkTS接口： 编辑"napi_init.cpp"文件，将RegisterWatcher注册为ArkTS接口： 编辑"index.d.ts"文件，定义ArkTS接口：
7.  编辑工程中的“entry > src > main > ets > entryability> EntryAbility.ets”文件，在onCreate()函数中新增接口调用：
```typescript
// 导入依赖模块
import testNapi from 'libentry.so'
// 在onCreate()函数中新增接口调用
// 启动时，注册系统事件观察者
testNapi.registerWatcher();
```
8.  编辑工程中的“entry > src > main > ets > pages> Index.ets”文件，添加一个Button控件onClick中实现主线程超时代码，示例代码如下：
```typescript
Button("timeOut350")
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
let t = Date.now();
while (Date.now() - t <= 350) {}
})
```
9.  点击DevEco Studio界面中的运行按钮，运行应用工程，连续点击两次timeOut350按钮，会触发主线程超时事件。
10.  主线程超时事件上报后，可以在Log窗口看到对系统事件数据的处理日志：
11.  移除事件观察者：
12.  销毁事件观察者：
-  onReceive类型观察者： 编辑"napi_init.cpp"文件，定义onReceive类型观察者相关方法：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/u542f_u52a8_u8017_u65f6_u4e8b_u4ef6-V14
爬取时间: 2025-04-28 19:13:32
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-app-launch-event-V14
爬取时间: 2025-04-28 19:13:46
来源: Huawei Developer
启动耗时事件介绍
HiAppEvent提供接口用于订阅启动耗时事件。
启动耗时事件机制
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170522.78844737398297931705019940123452:50001231000000:2800:7E23D6F73F5A30184176ABB3F7E94E9E64EB15FB9874EB2AA2FA626E1F339234.png)
animation_finish_time：系统定义的启动耗时，开发者无法干预，该时间为手指离开屏幕到启动动效结束的时间。
extend_time：开发者定制的启动耗时，该时间为手指离开屏幕到开发者调用reportDrawnCompleted接口的时间。开发者可以根据业务需要在合适的时机调用reportDrawnCompleted接口，不调用或手指离开屏幕后5s未调用则该指标大小为0。
事件params属性描述
| 名称  | 类型  | 说明  |
| --- | --- | --- |
| time  | number  | 事件生成时间，单位为毫秒。  |
| bundle_version  | string  | 应用版本。  |
| bundle_name  | string  | 应用名称。  |
| process_name  | string  | 应用进程名称。  |
| start_type  | number  | 冷热启动。0：冷启动，1：热启动。  |
| icon_input_time  | number  | 点击桌面应用图标离手时间戳，单位为毫秒。  |
| animation_finish_time  | number  | 动效完成耗时，单位为毫秒。  |
| extend_time  | number  | 手指离开屏幕到开发者调用reportDrawnCompleted接口时间，单位为毫秒。  |
名称
类型
说明
time
number
事件生成时间，单位为毫秒。
bundle_version
string
应用版本。
bundle_name
string
应用名称。
process_name
string
应用进程名称。
start_type
number
冷热启动。0：冷启动，1：热启动。
icon_input_time
number
点击桌面应用图标离手时间戳，单位为毫秒。
animation_finish_time
number
动效完成耗时，单位为毫秒。
extend_time
number
手指离开屏幕到开发者调用reportDrawnCompleted接口时间，单位为毫秒。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-app-launch-arkts-V14
爬取时间: 2025-04-28 19:14:00
来源: Huawei Developer
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考应用事件打点API文档。
| 接口名 | 描述 |
| --- | --- |
| addWatcher(watcher: Watcher): AppEventPackageHolder | 添加应用事件观察者，以添加对应用事件的订阅。 |
| removeWatcher(watcher: Watcher): void | 移除应用事件观察者，以移除对应用事件的订阅。 |
接口名
描述
addWatcher(watcher: Watcher): AppEventPackageHolder
添加应用事件观察者，以添加对应用事件的订阅。
removeWatcher(watcher: Watcher): void
移除应用事件观察者，以移除对应用事件的订阅。
开发步骤
以实现对用户运行应用工程生成的启动耗时事件订阅为例，说明开发步骤。
1.  编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，在onCreate函数中添加系统事件的订阅，示例代码如下： 系统在监控应用启动时依赖特定关键事件的记录，若这些事件在5秒内全部上报，系统将立即生成APP_LAUNCH事件，并通过回调函数将事件内容传递给应用；若关键事件存在缺失，系统将在5秒后根据实际接收到的关键事件生成APP_LAUNCH事件。在生成APP_LAUNCH事件的过程中，若应用出现退出或崩溃，onReceive回调接口可能不会被触发，从而导致事件上报失败。当应用重新启动时，将上报前次未发送的启动耗时事件。
```typescript
import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';
hiAppEvent.addWatcher({
// 开发者可以自定义观察者名称，系统会使用名称来标识不同的观察者
name: "watcher",
// 开发者可以订阅感兴趣的系统事件，此处是订阅了启动耗时事件
appEventFilters: [
{
domain: hiAppEvent.domain.OS,
names: [hiAppEvent.event.APP_LAUNCH]
}
],
// 开发者可以自行实现订阅回调函数，以便对订阅获取到的事件数据进行自定义处理
onReceive: (domain: string, appEventGroups: Array<hiAppEvent.AppEventGroup>) => {
hilog.info(0x0000, 'testTag', `HiAppEvent onReceive: domain=${domain}`);
for (const eventGroup of appEventGroups) {
// 开发者可以根据事件集合中的事件名称区分不同的系统事件
hilog.info(0x0000, 'testTag', `HiAppEvent eventName=${eventGroup.name}`);
for (const eventInfo of eventGroup.appEventInfos) {
// 开发者可以对事件集合中的事件数据进行自定义处理，此处是将事件数据打印在日志中
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo=${JSON.stringify(eventInfo)}`);
}
}
}
});
```
2.  点击DevEco Studio界面中的运行按钮，运行应用工程，添加系统事件订阅者，退出应用，再次点击桌面应用图标，触发一次启动耗时事件。
3.  应用工程再次启动可以在Log窗口看到对系统事件数据的处理日志：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/u6ed1_u52a8_u4e22_u5e27_u4e8b_u4ef6-V14
爬取时间: 2025-04-28 19:14:14
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-scroll-jank-event-V14
爬取时间: 2025-04-28 19:14:27
来源: Huawei Developer
HiAppEvent提供接口用于订阅滑动丢帧事件。
滑动丢帧事件信息中params属性的详细描述如下：
params属性：
| 名称  | 类型  | 说明  |
| --- | --- | --- |
| time  | number  | 事件生成时间，单位为毫秒。  |
| bundle_version  | string  | 应用版本。  |
| bundle_name  | string  | 应用名称。  |
| process_name  | string  | 应用进程名称。  |
| ability_name  | string  | 应用界面名称。  |
| begin_time  | number  | 滑动开始时间，单位为毫秒。  |
| duration  | number  | 持续时间，单位为毫秒。  |
| total_app_frames  | number  | 应用线程绘帧总数。  |
| total_app_missed_frames  | number  | 应用线程丢帧总数。  |
| max_app_frametime  | number  | 应用线程最大单帧耗时，单位毫秒。  |
| max_app_seq_frames  | number  | 应用线程最长连续丢帧。  |
| total_render_frames  | number  | 图形绘帧总数。  |
| total_render_missed_frames  | number  | 图形丢帧总数。  |
| max_render_frametime  | number  | 图形最大单帧耗时，单位毫秒。  |
| max_render_seq_frames  | number  | 图形线程最长连续丢帧。  |
名称
类型
说明
time
number
事件生成时间，单位为毫秒。
bundle_version
string
应用版本。
bundle_name
string
应用名称。
process_name
string
应用进程名称。
ability_name
string
应用界面名称。
begin_time
number
滑动开始时间，单位为毫秒。
duration
number
持续时间，单位为毫秒。
total_app_frames
number
应用线程绘帧总数。
total_app_missed_frames
number
应用线程丢帧总数。
max_app_frametime
number
应用线程最大单帧耗时，单位毫秒。
max_app_seq_frames
number
应用线程最长连续丢帧。
total_render_frames
number
图形绘帧总数。
total_render_missed_frames
number
图形丢帧总数。
max_render_frametime
number
图形最大单帧耗时，单位毫秒。
max_render_seq_frames
number
图形线程最长连续丢帧。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-scroll-jank-arkts-V14
爬取时间: 2025-04-28 19:14:41
来源: Huawei Developer
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考应用事件打点API文档。
| 接口名 | 描述 |
| --- | --- |
| addWatcher(watcher: Watcher): AppEventPackageHolder | 添加应用事件观察者，以添加对应用事件的订阅。 |
| removeWatcher(watcher: Watcher): void | 移除应用事件观察者，以移除对应用事件的订阅。 |
接口名
描述
addWatcher(watcher: Watcher): AppEventPackageHolder
添加应用事件观察者，以添加对应用事件的订阅。
removeWatcher(watcher: Watcher): void
移除应用事件观察者，以移除对应用事件的订阅。
开发步骤
以实现对用户滑动列表触发丢帧生成的滑动丢帧事件订阅为例，说明开发步骤。
1.  编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，在onCreate函数中添加系统事件的订阅，示例代码如下：
```typescript
import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';
hiAppEvent.addWatcher({
// 开发者可以自定义观察者名称，系统会使用名称来标识不同的观察者
name: "watcher",
// 开发者可以订阅感兴趣的系统事件，此处是订阅了滑动丢帧事件
appEventFilters: [
{
domain: hiAppEvent.domain.OS,
names: [hiAppEvent.event.SCROLL_JANK]
}
],
// 开发者可以自行实现订阅回调函数，以便对订阅获取到的事件数据进行自定义处理
onReceive: (domain: string, appEventGroups: Array<hiAppEvent.AppEventGroup>) => {
hilog.info(0x0000, 'testTag', `HiAppEvent onReceive: domain=${domain}`);
for (const eventGroup of appEventGroups) {
// 开发者可以根据事件集合中的事件名称区分不同的系统事件
hilog.info(0x0000, 'testTag', `HiAppEvent eventName=${eventGroup.name}`);
for (const eventInfo of eventGroup.appEventInfos) {
// 开发者可以对事件集合中的事件数据进行自定义处理，此处是将事件数据打印在日志中
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo=${JSON.stringify(eventInfo)}`);
}
}
}
});
```
2.  编辑工程中的“entry > src > main > ets > pages > Index.ets”文件，添加一个列表控件，在列表的滚动事件中做一些耗时操作，示例代码如下：
```typescript
// 模拟列表元素
private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]
// 创建List控件
List({ space: 10 }) {
ForEach(this.arr, (item: number) => {
ListItem() {
Text(`${item}`)
.width('100%')
.height(100)
.fontSize(20)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.borderRadius(10)
.backgroundColor(0x007DFF)
}
})
}
.onScrollIndex((firstIndex: number) => {
let i = 1;
while (i<10000) { // 在列表滑动事件中做一些耗时操作
console.log("do something");
i++;
}
})
```
3.  点击DevEco Studio界面中的运行按钮，运行应用工程，在页面中滑动列表，当系统检测到故障时触发滑动丢帧事件。
4.  可以在Log窗口看到对系统事件数据的处理日志：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/u9ad8_u8d1f_u8f7d_u4e8b_u4ef6-V14
爬取时间: 2025-04-28 19:14:55
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-cpu-usage-high-event-V14
爬取时间: 2025-04-28 19:15:08
来源: Huawei Developer
HiAppEvent提供接口用于订阅CPU高负载事件。
CPU高负载事件信息中params属性的详细描述如下：
params属性：
| 名称  | 类型  | 说明  |
| --- | --- | --- |
| time  | number  | 事件生成时间，单位为毫秒。  |
| bundle_version  | string  | 应用版本。  |
| bundle_name  | string  | 应用名称。  |
| foreground  | boolean  | 应用是否处于前台状态。  |
| usage  | number  | 单核CPU平均使用率，单位百分比。  |
| begin_time  | number  | 采集开始时间，单位为毫秒。  |
| end_time  | number  | 采集结束时间，单位为毫秒。  |
| external_log  | string[]  | 故障日志文件路径。为避免目录空间超限（限制参考log_over_limit），导致新生成的日志文件写入失败，日志文件处理完后请及时删除。  |
| log_over_limit  | boolean  | 生成的故障日志文件与已存在的日志文件总大小是否超过5M上限。true表示超过上限，日志写入失败；false表示未超过上限。  |
| threads  | object[]  | Top5线程调用栈，详见thread属性。  |
名称
类型
说明
time
number
事件生成时间，单位为毫秒。
bundle_version
string
应用版本。
bundle_name
string
应用名称。
foreground
boolean
应用是否处于前台状态。
usage
number
单核CPU平均使用率，单位百分比。
begin_time
number
采集开始时间，单位为毫秒。
end_time
number
采集结束时间，单位为毫秒。
external_log
string[]
故障日志文件路径。为避免目录空间超限（限制参考log_over_limit），导致新生成的日志文件写入失败，日志文件处理完后请及时删除。
log_over_limit
boolean
生成的故障日志文件与已存在的日志文件总大小是否超过5M上限。true表示超过上限，日志写入失败；false表示未超过上限。
threads
object[]
Top5线程调用栈，详见thread属性。
thread属性：
| 名称  | 类型  | 说明  |
| --- | --- | --- |
| name  | string  | 线程名。  |
| tid  | number  | 线程id。  |
| usage  | number  | 多核平均负载，如需换算单核负载需乘以核数。  |
名称
类型
说明
name
string
线程名。
tid
number
线程id。
usage
number
多核平均负载，如需换算单核负载需乘以核数。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-cpu-usage-high-arkts-V14
爬取时间: 2025-04-28 19:15:22
来源: Huawei Developer
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考应用事件打点API文档。
| 接口名 | 描述 |
| --- | --- |
| addWatcher(watcher: Watcher): AppEventPackageHolder | 添加应用事件观察者，以添加对应用事件的订阅。 |
| removeWatcher(watcher: Watcher): void | 移除应用事件观察者，以移除对应用事件的订阅。 |
接口名
描述
addWatcher(watcher: Watcher): AppEventPackageHolder
添加应用事件观察者，以添加对应用事件的订阅。
removeWatcher(watcher: Watcher): void
移除应用事件观察者，以移除对应用事件的订阅。
开发步骤
以实现应用内多线程执行死循环生成的CPU高负载事件订阅为例，说明开发步骤。
1.  编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，在onCreate函数中添加系统事件的订阅，示例代码如下：
```typescript
import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';
hiAppEvent.addWatcher({
// 开发者可以自定义观察者名称，系统会使用名称来标识不同的观察者
name: "watcher",
// 开发者可以订阅感兴趣的系统事件，此处是订阅了崩溃事件
appEventFilters: [
{
domain: hiAppEvent.domain.OS,
names: [hiAppEvent.event.CPU_USAGE_HIGH]
}
],
// 开发者可以自行实现订阅实时回调函数，以便对订阅获取到的事件数据进行自定义处理
onReceive: (domain: string, appEventGroups: Array<hiAppEvent.AppEventGroup>) => {
hilog.info(0x0000, 'testTag', `HiAppEvent onReceive: domain=${domain}`);
for (const eventGroup of appEventGroups) {
// 开发者可以根据事件集合中的事件名称区分不同的系统事件
hilog.info(0x0000, 'testTag', `HiAppEvent eventName=${eventGroup.name}`);
for (const eventInfo of eventGroup.appEventInfos) {
// 开发者可以对事件集合中的事件数据进行自定义处理，此处是将事件数据打印在日志中
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo=${JSON.stringify(eventInfo)}`);
}
}
}
});
```
2.  工程中添加“entry > src > main > ets > workers> worker.ets”文件，构造一个死循环，接收到主线程的消息后触发CPU高负载事件，完整示例代码如下：
```typescript
import { worker } from '@kit.ArkTS';
let workerPort = worker.workerPort;
workerPort.onmessage = (message) => {
eatCpu();
}
function eatCpu(): void {
let val:number = 0;
while (true) {
val++;
}
}
```
3.  工程中添加“entry > src > main > ets > tester> CpuTester.ets”文件，在CpuTester 类中的start方法中开启多个线程的死循环，以触发多线程的CPU高负载事件，完整示例代码如下：
```typescript
import { worker } from '@kit.ArkTS';
export default class CpuTester {
workerInstance: worker.ThreadWorker = new worker.ThreadWorker('entry/ets/workers/worker.ets');
start(threadNum: number) {
for (let index = 0; index < threadNum; index++) {
this.workerInstance = new worker.ThreadWorker('entry/ets/workers/worker.ets');
this.workerInstance.postMessage('msg');
}
}
}
```
4.  编辑工程中的“entry > src > main > ets > pages > Index.ets”文件，添加“CPU加压”按钮并在其onClick函数构造多线程执行死循环，以触发CPU高负载事件，完整示例代码如下：
```typescript
import CpuTester from '../tester/CpuTester';
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
@State enable: boolean = true;
@State threadNum: number = 5;
cpuTester: CpuTester = new CpuTester();
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Button('CPU加压')
.fontSize(18)
.margin(12)
.fontWeight(FontWeight.Bold)
.enabled(this.enable)
.onClick(() => {
this.cpuTester.start(this.threadNum);
this.enable = false;
})
}
.width('100%')
}
.height('100%')
}
}
```
5.  点击DevEco Studio界面中的运行按钮，运行应用工程，然后在应用界面中点击“CPU加压”按钮，触发CPU高负载事件。应用保持在前台且屏幕处于亮屏状态，五到十分钟之后可以在Log窗口看到对系统事件数据的处理日志：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/24h_u529f_u8017_u5668_u4ef6_u5206-V14
爬取时间: 2025-04-28 19:15:35
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-battery-usage-event-V14
爬取时间: 2025-04-28 19:15:49
来源: Huawei Developer
HiAppEvent提供接口用于24h功耗器件分解统计事件，每日0点统计应用耗电数据并上报。
24h功耗器件分解统计事件信息中params属性的详细描述如下：
params属性：
| 名称  | 类型  | 说明  |
| --- | --- | --- |
| time  | number  | 事件生成时间，单位为毫秒。  |
| bundle_version  | string  | 应用版本。  |
| bundle_name  | string  | 应用名称。  |
| begin_time  | number  | 采集开始时间，单位为毫秒。  |
| end_time  | number  | 采集结束时间，单位为毫秒。  |
| foreground_usage  | Array<number>  | 每小时前台使用时长，单位为毫秒。  |
| background_usage  | Array<number>  | 每小时后台使用时长，单位为毫秒。  |
| cpu_foreground_energy  | Array<number>  | 每小时CPU器件前台耗电量预估值，单位为毫安秒。  |
| cpu_background_energy  | Array<number>  | 每小时CPU器件后台耗电量预估值，单位为毫安秒。  |
| gpu_foreground_energy  | Array<number>  | 每小时GPU器件前台耗电量预估值，单位为毫安秒。  |
| gpu_background_energy  | Array<number>  | 每小时GPU器件后台耗电量预估值，单位为毫安秒。  |
| ddr_foreground_energy  | Array<number>  | 每小时DDR器件前台耗电量预估值，单位为毫安秒。  |
| ddr_background_energy  | Array<number>  | 每小时DDR器件后台耗电量预估值，单位为毫安秒。  |
| display_foreground_energy  | Array<number>  | 每小时display器件前台耗电量预估值，单位为毫安秒。  |
| display_background_energy  | Array<number>  | 每小时display器件后台耗电量预估值，单位为毫安秒。  |
| audio_foreground_energy  | Array<number>  | 每小时audio器件前台耗电量预估值，单位为毫安秒。  |
| audio_background_energy  | Array<number>  | 每小时audio器件后台耗电量预估值，单位为毫安秒。  |
| modem_foreground_energy  | Array<number>  | 每小时modem器件前台耗电量预估值，单位为毫安秒。  |
| modem_background_energy  | Array<number>  | 每小时modem器件后台耗电量预估值，单位为毫安秒。  |
| rom_foreground_energy  | Array<number>  | 每小时rom器件前台耗电量预估值，单位为毫安秒。  |
| rom_background_energy  | Array<number>  | 每小时rom器件后台耗电量预估值，单位为毫安秒。  |
| wifi_foreground_energy  | Array<number>  | 每小时wifi器件前台耗电量预估值，单位为毫安秒。  |
| wifi_background_energy  | Array<number>  | 每小时wifi器件后台耗电量预估值，单位为毫安秒。  |
| others_foreground_energy  | Array<number>  | 每小时其他器件前台耗电量预估值，单位为毫安秒。  |
| others_background_energy  | Array<number>  | 每小时其他器件后台耗电量预估值，单位为毫安秒。  |
名称
类型
说明
time
number
事件生成时间，单位为毫秒。
bundle_version
string
应用版本。
bundle_name
string
应用名称。
begin_time
number
采集开始时间，单位为毫秒。
end_time
number
采集结束时间，单位为毫秒。
foreground_usage
Array<number>
每小时前台使用时长，单位为毫秒。
background_usage
Array<number>
每小时后台使用时长，单位为毫秒。
cpu_foreground_energy
Array<number>
每小时CPU器件前台耗电量预估值，单位为毫安秒。
cpu_background_energy
Array<number>
每小时CPU器件后台耗电量预估值，单位为毫安秒。
gpu_foreground_energy
Array<number>
每小时GPU器件前台耗电量预估值，单位为毫安秒。
gpu_background_energy
Array<number>
每小时GPU器件后台耗电量预估值，单位为毫安秒。
ddr_foreground_energy
Array<number>
每小时DDR器件前台耗电量预估值，单位为毫安秒。
ddr_background_energy
Array<number>
每小时DDR器件后台耗电量预估值，单位为毫安秒。
display_foreground_energy
Array<number>
每小时display器件前台耗电量预估值，单位为毫安秒。
display_background_energy
Array<number>
每小时display器件后台耗电量预估值，单位为毫安秒。
audio_foreground_energy
Array<number>
每小时audio器件前台耗电量预估值，单位为毫安秒。
audio_background_energy
Array<number>
每小时audio器件后台耗电量预估值，单位为毫安秒。
modem_foreground_energy
Array<number>
每小时modem器件前台耗电量预估值，单位为毫安秒。
modem_background_energy
Array<number>
每小时modem器件后台耗电量预估值，单位为毫安秒。
rom_foreground_energy
Array<number>
每小时rom器件前台耗电量预估值，单位为毫安秒。
rom_background_energy
Array<number>
每小时rom器件后台耗电量预估值，单位为毫安秒。
wifi_foreground_energy
Array<number>
每小时wifi器件前台耗电量预估值，单位为毫安秒。
wifi_background_energy
Array<number>
每小时wifi器件后台耗电量预估值，单位为毫安秒。
others_foreground_energy
Array<number>
每小时其他器件前台耗电量预估值，单位为毫安秒。
others_background_energy
Array<number>
每小时其他器件后台耗电量预估值，单位为毫安秒。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiappevent-watcher-battery-usage-arkts-V14
爬取时间: 2025-04-28 19:16:03
来源: Huawei Developer
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考应用事件打点API文档。
| 接口名 | 描述 |
| --- | --- |
| addWatcher(watcher: Watcher): AppEventPackageHolder | 添加应用事件观察者，以添加对应用事件的订阅。 |
| removeWatcher(watcher: Watcher): void | 移除应用事件观察者，以移除对应用事件的订阅。 |
接口名
描述
addWatcher(watcher: Watcher): AppEventPackageHolder
添加应用事件观察者，以添加对应用事件的订阅。
removeWatcher(watcher: Watcher): void
移除应用事件观察者，以移除对应用事件的订阅。
开发步骤
以实现对应用内多线程执行耗时操作生成的24h功耗器件分解统计事件订阅为例，说明开发步骤。
1.  编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，在onCreate函数中添加系统事件的订阅，示例代码如下：
```typescript
import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';
hiAppEvent.addWatcher({
// 开发者可以自定义观察者名称，系统会使用名称来标识不同的观察者
name: "watcher",
// 开发者可以订阅感兴趣的系统事件，此处是订阅了应用24h功耗器件分解统计事件
appEventFilters: [
{
domain: hiAppEvent.domain.OS,
names: [hiAppEvent.event.BATTERY_USAGE]
}
],
// 开发者可以自行实现订阅实时回调函数，以便对订阅获取到的事件数据进行自定义处理
onReceive: (domain: string, appEventGroups: Array<hiAppEvent.AppEventGroup>) => {
hilog.info(0x0000, 'testTag', `HiAppEvent onReceive: domain=${domain}`);
for (const eventGroup of appEventGroups) {
// 开发者可以根据事件集合中的事件名称区分不同的系统事件
hilog.info(0x0000, 'testTag', `HiAppEvent eventName=${eventGroup.name}`);
for (const eventInfo of eventGroup.appEventInfos) {
// 开发者可以对事件集合中的事件数据进行自定义处理，此处是将事件数据打印在日志中
hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo=${JSON.stringify(eventInfo)}`);
}
}
}
});
```
2.  开发者自测试可跳过此步骤，仅需完成应用安装后并断开充电（充电状态下测试会导致无数据上报），使用应用5分钟以上。 4）安装运行测试应用到测试机上，断开USB（2in1设备还需要断开充电线）； 5）打开测试应用，然后在应用界面中点击“CPU加压”按钮，持续十分钟，测试过程保持屏幕长亮。
```typescript
import { worker } from '@kit.ArkTS';
let workerPort = worker.workerPort;
workerPort.onmessage = (message) => {
eatCpu();
}
function eatCpu(): void {
let val:number = 0;
while (true) {
val++;
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hitracemeter-V14
爬取时间: 2025-04-28 19:16:16
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hitracemeter-guidelines-arkts-V14
爬取时间: 2025-04-28 19:16:30
来源: Huawei Developer
简介
HiTraceMeter提供系统性能打点接口。开发者通过在关键代码位置调用HiTraceMeter接口提供的API接口，能够有效跟踪进程轨迹、查看系统性能。
基本概念
HiTraceMeter Tag：跟踪数据使用类别分类，称作HiTraceMeter Tag或HiTraceMeter Category。一般每个软件子系统对应一个Tag，该Tag在打点API中以类别Tag参数传入。HiTraceMeter命令行工具采集跟踪数据时，只采集给定的Tag类别选项指定的跟踪数据。
实现原理
1.  应用程序通过HiTraceMeter函数接口进行打点，HiTraceMeter函数将跟踪数据通过内核sysfs文件接口输出到内核的ftrace数据缓冲区。
2.  HiTraceMeter命令行工具读取内核ftrace缓冲区中的跟踪数据，将文本格式的跟踪数据保存到设备侧的文件中。
接口说明
性能打点跟踪接口由HiTraceMeter模块提供，详细API请参考性能打点跟踪API参考。
| 接口名 | 描述 |
| --- | --- |
| hiTraceMeter.startTrace(name: string, taskId: number) | 异步时间片跟踪接口，标记一个预跟踪耗时任务的开始。taskId是trace中用来表示关联的ID,如果有多个name相同的任务并行执行，则每次调用startTrace的taskId不同；如果具有相同name的任务是串行执行的，则taskId可以相同。 |
| hiTraceMeter.finishTrace(name: string, taskId: number) | 异步时间片跟踪接口，name和taskId必须与流程开始的hiTraceMeter.startTrace对应参数值保持一致。 |
| hiTraceMeter.traceByValue(name: string, value: number) | 整数跟踪接口，用来标记一个预跟踪的数值变量，该变量的数值会不断变化。 |
HiTraceMeter打点接口按功能/行为分类，主要分三类：同步时间片跟踪接口、异步时间片跟踪接口和整数跟踪接口。无论同步时间片跟踪接口还是异步时间片跟踪接口，接口本身都是同步接口，不是异步接口，都用在同一线程中，不支持跨线程打点和分析。
开发步骤
在应用启动执行页面加载后，开始分布式跟踪；完成业务之后，停止分布式跟踪。
1.  新建一个ArkTS应用工程，在“Project”窗口点击“entry > src > main > ets > pages > index”，打开工程中的“index.ets”文件；在页面执行加载后，在自己的业务中调用hiTraceMeter的接口，进行性能打点跟踪，以任务名name为myTraceTest为例， 示例代码如下：
```typescript
import hiTraceMeter from '@ohos.hiTraceMeter';
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'Hello Hitrace';
let traceCount = 0;
// 第一个跟踪任务开始
hiTraceMeter.startTrace("myTraceTest", 1001);
// 开始计数任务
traceCount++;
hiTraceMeter.traceByValue("myTestCount", traceCount);
// 业务流程
console.log(`myTraceTest running, taskid: 1001`);
// 第二个跟踪任务开始，同时第一个跟踪的同名任务还没结束，出现了并行执行，对应接口的taskId需要不同。
hiTraceMeter.startTrace("myTraceTest", 1002);
// 开始计数任务
traceCount++;
hiTraceMeter.traceByValue("myTestCount", traceCount);
// 业务流程
console.log(`myTraceTest running, taskid: 1002`);
// 结束taskId为1001的跟踪任务
hiTraceMeter.finishTrace("myTraceTest", 1001);
// 结束taskId为1002的跟踪任务
hiTraceMeter.finishTrace("myTraceTest", 1002);
})
}
.width('100%')
}
.height('100%')
}
}
```
2.  运行项目，单击DevEco Studio界面上的运行按钮，然后可通过hitrace命令获取跟踪任务的相关日志。 在 DevEco Studio Terminal 中执行如下命令： 执行抓取trace命令后，先在设备中执行自己的业务调用逻辑，继续依次执行如下命令： 抓取trace成功的数据如下所示：
```shell
PS D:\xxx\xxx> hdc shell
$ hitrace --trace_begin app
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hitracemeter-guidelines-ndk-V14
爬取时间: 2025-04-28 19:16:43
来源: Huawei Developer
HiTrace为开发者提供业务流程调用链跟踪的维测接口。该接口所提供的功能，可以帮助开发者迅速获取指定业务流程调用链的运行日志、定位跨设备/跨进程/跨线程的故障问题。
接口说明
性能打点跟踪接口由HiTraceMeter模块提供，详细API请参考性能打点跟踪API参考。
| 方法 | 接口描述 |
| --- | --- |
| void OH_HiTrace_StartTrace(const char* name) | 开启一个同步时间片跟踪事件 |
| void OH_HiTrace_FinishTrace() | 结束一个同步时间片跟踪事件 |
| void OH_HiTrace_StartAsyncTrace(const char* name, int32_t taskId) | 开启一个异步时间片跟踪事件 |
| void OH_HiTrace_FinishAsyncTrace(const char* name, int32_t taskId) | 结束一个异步时间片跟踪事件 |
| void OH_HiTrace_CountTrace(const char* name, int64_t count) | 整数跟踪事件 |
参数解析
| 参数名 | 类型 | 必填 | 说明 |
| --- | --- | --- | --- |
| name | string | 是 | 要跟踪的数值变量名称。 |
| taskId | number | 是 | 用来表示关联的ID,如果有多个name相同的任务是并行执行的，则每次调用startTrace的taskId不同。 |
| count | number | 是 | 变量的值。 |
开发示例
1.  在CMakeLists.txt中新增libhitrace_ndk.z.so链接。
2.  在源文件中引用hitrace头文件。
3.  在需要打点的地方进行性能打点，以异步打点为例（示例代码为默认的hello.cpp的一部分，使用时只需要按照示例的使用方法将接口-参看接口说明，放在需要的地方即可）。
4.  将编译好的hap包推送到设备上安装，cmd窗口执行hdc shell连上设备后执行命令：hitrace --trace_begin app。
```shell
capturing trace...
```
5.  设备上重复点击几次新安装的hap，然后在shell窗口dump trace查看结果，命令是：hitrace --trace_dump | grep hitraceTest。
```shell
<...>-2477    (-------) [001] ....   396.427165: tracing_mark_write: S|2477|H:hitraceTest 123
<...>-2477    (-------) [001] ....   396.427196: tracing_mark_write: F|2477|H:hitraceTest 123
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hitracemeter-view-V14
爬取时间: 2025-04-28 19:16:57
来源: Huawei Developer
通过DevEco Studio可视化界面查看
开发者可使用 DevEco Studio Profiler 的 CPU Insight 功能，可视化展示 HiTraceMeter 日志内容，分析应用/服务的 CPU 使用率和线程的运行状态，查看指定时间段内程序在 CPU 上的执行耗时情况，具体使用指导请参考CPU活动分析：CPU分析。
通过命令行工具查看
1.  根据 hdc 命令行工具指导，完成环境准备，可以使用 hdc shell 命令正常连接设备。
2.  在 DevEco Studio 的 Terminal 窗口或主机命令行窗口执行 hdc shell 命令连接设备，在设备上执行hitrace命令开启 HiTraceMeter 日志抓取服务。
```shell
PS D:\xxx\xxx> hdc shell
# hitrace --trace_begin app
```
3.  在设备上运行包含 HiTraceMeter 打点的相关程序。
4.  转储 HiTraceMeter 文本日志，该日志中包含步骤 3 中的 HiTraceMeter 打点信息。
```shell
# hitrace --trace_dump
```
5.  在设备上执行 hitrace 命令结束 HiTraceMeter 日志抓取服务。
```shell
# hitrace --trace_finish
```
6.  退出设备，进入主机，将设备中 HiTraceMeter 文本日志导出到当前目录。
```shell
# exit
PS D:\xxx\xxx> hdc file recv /data/local/tmp/trace.ftrace ./
```
7.  可在 HiTraceMeter 文本日志中搜索打点名称等关键字查看打点是否成功。
8.  HiTraceMeter 文本日志可视化分析。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hitracechain-V14
爬取时间: 2025-04-28 19:17:11
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hitracechain-guidelines-arkts-V14
爬取时间: 2025-04-28 19:17:24
来源: Huawei Developer
简介
HiTraceChain是基于云计算分布式跟踪调用链思想，在端侧业务流程（涉及跨线程、跨进程、跨设备）中的一种轻量级实现。hiTraceChain在业务控制面流程中，生成和传递唯一跟踪标识，在业务流程中输出的各类信息中（包括应用事件、系统时间、日志等）记录该跟踪标识。在调试、问题定位过程中，开发者可以通过该唯一跟踪标识将本次业务流程端到端的各类信息快速关联起来。hiTraceChain为开发者提供业务流程调用链跟踪的维测接口，帮助开发者迅速获取指定业务流程调用链的运行日志，定位跨设备/跨进程/跨线程的故障问题。
基本概念
chainId：分布式跟踪标识，属于HiTraceId的一部分，用于标识当前跟踪的业务流程。
接口说明
分布式跟踪接口由hiTraceChain模块提供，详细API请参考分布式跟踪API参考。
分布式跟踪接口功能介绍：
| 接口名 | 描述 |
| --- | --- |
| hiTraceChain.begin(name: string, flags?: number = HiTraceFlag.DEFAULT) | 开始跟踪。 |
| hiTraceChain.end(id: HiTraceId) | 结束跟踪。 |
开发步骤
以构造单次应用事件打点的业务说明分布式调用链的使用方法。
1.  新建一个ets应用工程，编辑工程中的“entry > src > main > ets > pages > index.ets” 文件，添加一个按钮，完整示例代码如下：
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
import { hiAppEvent, hilog, hiTraceChain } from '@kit.PerformanceAnalysisKit';
@Entry
@Component
struct Index {
@State message: string = 'Start writing an app event'
build() {
Row() {
Column() {
Button(this.message)
.fontSize(20)
.margin(5)
.width(350)
.height(60)
.fontWeight(FontWeight.Bold)
.onClick(() => {
try {
// 业务开始前，开启分布式跟踪。
let traceId = hiTraceChain.begin("Write a new app event", hiTraceChain.HiTraceFlag.INCLUDE_ASYNC)
// 在按钮点击函数中进行事件打点，以记录按钮点击事件
let eventParams: Record<string, number> = { 'click_time': 100 }
let eventInfo: hiAppEvent.AppEventInfo = {
// 事件领域定义
domain: "button",
// 事件名称定义
name: "click",
// 事件类型定义
eventType: hiAppEvent.EventType.BEHAVIOR,
// 事件参数定义
params: eventParams,
}
hiAppEvent.write(eventInfo).then(() => {
hilog.info(0x0000, 'testTag', `Succeed to write an app event`)
// 业务结束，关闭分布式跟踪。
hiTraceChain.end(traceId)
}).catch((err: BusinessError) => {
hilog.error(0x0000, 'testTag', `HiAppEvent err.code: ${err.code}, err.message: ${err.message}`)
})
} catch (err) {
console.error(`error message is ${(err as BusinessError).message}`)
}
})
}
.width('100%')
}
.height('100%')
}
}
```
2.  点击DevEco Studio界面中的运行按钮，运行应用工程，然后在应用界面中点击“Start writing an app event”按钮，触发业务逻辑。
3.  在Log窗口查看分布式跟踪的相关信息，使用“.[([0-9a-zA-Z]{15}).].*”过滤日志，查看该业务的分布式跟踪信息。hap进程号为“21519”，点击按钮触发的系统事件打点业务涉及到“21519”与“23924”两个线程，通过值为“a92ab94c18e1341”的chainId可以有效跟踪涉及该业务的所有线程的日志信息。
跨进程/跨设备分布式跟踪说明
跨进程/跨设备分布式跟踪依赖于HarmonyOS各模块相应业务接口的napi实现是否存在进程及设备之间的通信调用。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hitracechain-guidelines-ndk-V14
爬取时间: 2025-04-28 19:17:38
来源: Huawei Developer
简介
HiTraceChain是基于云计算分布式跟踪调用链思想，在端侧业务流程（涉及跨线程、跨进程、跨设备）中的一种轻量级实现。HiTraceChain在业务控制面流程中，生成和传递唯一跟踪标识，在业务流程中输出的各类信息中（包括应用事件、系统时间、日志等）记录该跟踪标识。在调试、问题定位过程中，开发者可以通过该唯一跟踪标识将本次业务流程端到端的各类信息快速关联起来。HiTraceChain为开发者提供业务流程调用链跟踪的维测接口，帮助开发者迅速获取指定业务流程调用链的运行日志，定位跨设备/跨进程/跨线程的故障问题。
接口说明
分布式跟踪接口由HiTraceChain模块提供，详细API请参考性能打点跟踪API参考。
| 方法 | 接口描述 |
| --- | --- |
| HiTraceId OH_HiTrace_BeginChain(const char *name, int flags) | 开始跟踪 |
| void OH_HiTrace_EndChain() | 停止跟踪 |
| HiTraceId OH_HiTrace_GetId() | 从当前线程TLS中获取跟踪标识 |
| void OH_HiTrace_SetId(const HiTraceId *id) | 将id设置为当前线程的跟踪id |
| void OH_HiTrace_ClearId(void) | 清除当前线程的跟踪ID并将其设置为无效 |
| HiTraceId OH_HiTrace_CreateSpan(void) | 根据当前线程的跟踪id创建一个新的span id |
| void OH_HiTrace_Tracepoint(HiTrace_Communication_Mode mode, HiTrace_Tracepoint_Type type, const HiTraceId *id, const char *fmt, ...) | 打印hitrace信息，包括跟踪ID信息 |
| void OH_HiTrace_InitId(HiTraceId *id) | 初始化HiTraceId结构体 |
| void OH_HiTrace_IdFromBytes(HiTraceId *id, const uint8_t *pIdArray, int len) | 根据字节数组创建跟踪HiTraceId结构体 |
| bool OH_HiTrace_IsIdValid(const HiTraceId *id) | 判断trace id是否有效 |
| bool OH_HiTrace_IsFlagEnabled(const HiTraceId *id, HiTrace_Flag flag) | 判断跟踪id是否启用了跟踪标志 |
| void OH_HiTrace_EnableFlag(const HiTraceId *id, HiTrace_Flag flag) | 启用跟踪ID的指定跟踪标志 |
| int OH_HiTrace_GetFlags(const HiTraceId *id) | 获取HiTraceId结构体中设置的的标志位 |
| void OH_HiTrace_SetFlags(HiTraceId *id, int flags) | 设置跟踪标志位到HiTraceId结构体中 |
| uint64_t OH_HiTrace_GetChainId(const HiTraceId *id) | 获取跟踪链ID |
| void OH_HiTrace_SetChainId(HiTraceId *id, uint64_t chainId) | 设置跟踪链ID到HiTraceId结构体中 |
| uint64_t OH_HiTrace_GetSpanId(const HiTraceId *id) | 获取当前HiTraceId结构体中的分支ID |
| void OH_HiTrace_SetSpanId(HiTraceId *id, uint64_t spanId) | 设置分支ID到HiTraceId结构体中 |
| uint64_t OH_HiTrace_GetParentSpanId(const HiTraceId *id) | 获取当前HiTraceId结构体中的父分支ID |
| void OH_HiTrace_SetParentSpanId(HiTraceId *id, uint64_t parentSpanId) | 设置父分支ID到HiTraceId结构体中 |
| int OH_HiTrace_IdToBytes(const HiTraceId* id, uint8_t* pIdArray, int len) | 将HiTraceId结构体转换为字节数组，用于缓存或者通信传递 |
开发示例
1.  在Deveco Studio新建Native C++应用，默认生成的项目中包含index.ets文件，在entry\src\main\cpp目录下会自动生成一个cpp文件(hello.cpp或napi_init.cpp，本示例以hello.cpp文件名为例)。 index.ets代码如下，onClick中调用了testNapi的add函数，该函数在hello.cpp中定义。
```typescript
import hilog from '@ohos.hilog';
import testNapi from 'libentry.so'
@Entry
@Component
struct Index {
@State message: string = 'Hello World'
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
hilog.info(0x0000, 'testTag', 'Test NAPI 2 + 3 = %{public}d', testNapi.add(2, 3));
})
}
.width('100%')
}
.height('100%')
}
}
```
2.  在CMakeLists.txt中新增libhitrace_ndk.z.so链接。
3.  在hello.cpp文件中引用hitrace头文件。
4.  在hello.cpp的Add函数中，使用OH_HiTrace_BeginChain函数开启一个跟踪链，使用OH_HiTrace_EndChain关闭跟踪。
5.  运行项目，会在设备上自动生成一个hap应用，点击hap上的“Hello World”文字，会调用hello.cpp中的add函数，查看hitrace日志，会出现如下信息：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hichecker-V14
爬取时间: 2025-04-28 19:17:51
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hichecker-guidelines-arkts-V14
爬取时间: 2025-04-28 19:18:05
来源: Huawei Developer
简介
HiChecker可以作为应用开发阶段使用的检测工具，用于检测代码运行过程中部分易忽略的问题，如应用线程出现耗时调用、应用进程中元能力资源泄露等问题。开发者可以通过日志记录或进程crash等形式查看具体问题并进行修改，提升应用的使用体验。
基本概念
规则常量：HiChecker使用常量来表示已有的告警规则或者检测规则，一个常量表示一种规则，可以通过HiChecker的接口控制规则的添加和删除。
实现原理
1.  应用程序通过HiChecker函数接口控制规则的增删查改。
2.  子系统有耗时调用或者Ability资源泄露时通过HiChecker通知有对应规则的事件发生，HiChecker检测条件满足时做对应的操作。
约束与限制
接口说明
检测模式接口由HiChecker模块提供，详细API请参考检测模式API参考。
| 接口名 | 描述 |
| --- | --- |
| hichecker.addCheckRule(rule: bigint) | 需要添加的规则 |
| hichecker.removeCheckRule(rule: bigint) | 需要删除的规则 |
| hichecker.containsCheckRule(rule: bigint) | 需要查询的规则 |
开发步骤
在应用启动执行页面加载后，开始检测；完成业务之后，停止检测。
1.  新建一个ArkTS应用工程，在“Project”窗口点击“entry > src > main > ets > entryability ”，打开工程中的“EntryAbility.ets”文件；在页面执行加载后，在自己的业务中调用HiChecker的接口，添加检测规则， 示例代码如下：
```typescript
import { window } from '@kit.ArkUI';
import { image } from '@kit.ImageKit';
import { UIAbility, Want, AbilityConstant } from '@kit.AbilityKit';
import { hichecker, hilog } from '@kit.PerformanceAnalysisKit';
export default class EntryAbility extends UIAbility {
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
// 添加检测规则，规则意义见检测模式API参考
hichecker.addCheckRule(hichecker.RULE_CAUTION_PRINT_LOG|hichecker.RULE_THREAD_CHECK_SLOW_PROCESS);
let filePath: string = this.context.cacheDir + '/test.JPG';
const imageSourceApi: image.ImageSource = image.createImageSource(filePath);
const imagePackerApi = image.createImagePacker();
let packOpts: image.PackingOption = { format:"image/jpeg", quality:98 };
imagePackerApi.packing(imageSourceApi, packOpts);
// 以上5行通过image子系统触发检测规则
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreateend');
}
onDestroy() {
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
}
onWindowStageCreate(windowStage: window.WindowStage) {
// Main window is created, set main page for this ability
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
windowStage.loadContent('pages/Index', (err, data) => {
if (err.code) {
hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
return;
}
hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
});
}
onWindowStageDestroy() {
// Main window is destroyed, release UI related resources
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
}
onForeground() {
// Ability has brought to foreground
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
}
onBackground() {
// Ability has back to background
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
}
}
```
2.  在shell中依次执行如下命令： 安装hap后运行，shell窗口有如下调用栈信息说明检测成功（调用栈为触发检测规则时的调用栈）
```shell
hdc shell
hilog|grep -i hichecker
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hidebug-V14
爬取时间: 2025-04-28 19:18:18
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hidebug-guidelines-arkts-V14
爬取时间: 2025-04-28 19:18:32
来源: Huawei Developer
HiDebug对外提供系统调试相关功能的接口，包括应用进程的静态堆内存（native heap）信息、应用进程内存占用PSS（Proportional Set Size）信息的获取等，也可完成虚拟机内存切片导出，虚拟机CPU Profiling采集等操作。
接口说明
| 接口名 | 描述 |
| --- | --- |
| hidebug.getNativeHeapSize | 获取内存分配器统计的进程持有的堆内存大小（含分配器元数据）。 |
| hidebug.getNativeHeapAllocatedSize | 获取内存分配器统计的进程业务分配的堆内存大小。 |
| hidebug.getNativeHeapFreeSize | 获取内存分配器持有的缓存内存大小。 |
| hidebug.getPss | 获取应用进程实际使用的物理内存大小。 |
| hidebug.getVss | 获取应用进程虚拟耗用内存大小。 |
| hidebug.getSharedDirty | 获取进程的共享脏内存大小。 |
| hidebug.getPrivateDirty | 获取进程的私有脏内存大小。 |
| hidebug.getCpuUsage | 获取进程的CPU使用率。 |
| hidebug.getServiceDump | 获取系统服务信息。 |
| hidebug.dumpJsHeapData | 虚拟机堆导出。 |
| hidebug.startJsCpuProfiling | 启动虚拟机Profiling方法跟踪。 |
| hidebug.stopJsCpuProfiling | 停止虚拟机Profiling方法跟踪。 |
| hidebug.getAppVMMemoryInfo | 获取VM内存相关信息。 |
| hidebug.getAppThreadCpuUsage | 获取应用线程CPU使用情况。 |
| hidebug.startAppTraceCapture | 启动应用trace采集。 |
| hidebug.stopAppTraceCapture | 停止应用trace采集。 |
| hidebug.getAppMemoryLimit | 获取应用程序进程内存限制。 |
| hidebug.getSystemCpuUsage | 获取系统的CPU资源占用情况。 |
| hidebug.setAppResourceLimit | 设置应用的fd数量、线程数量、js内存或者native内存资源限制。 |
| hidebug.getAppNativeMemInfo | 获取应用进程内存信息。 |
| hidebug.getSystemMemInfo | 获取系统内存信息。 |
| hidebug.getVMRuntimeStats | 获取系统gc全部统计信息。 |
| hidebug.getVMRuntimeStat | 根据参数获取指定的系统gc统计信息。 |
| hidebug.isDebugState | 获取应用进程被调试状态。 |
| hidebug.getGraphicsMemory | 使用异步方式获取应用显存大小。 |
| hidebug.getGraphicsMemorySync | 使用同步方式获取应用显存大小。 |
HiDebug的具体用法可查看API参考API参考文档。
开发示例
下文将展示如何在应用内增加一个按钮，并单击该按钮以调用hidebug接口。
1.  新建一个工程，选择“Empty Ability”。
2.  工程配置界面中，Model选择“Stage”。
3.  在Project窗口单击entry > src > main > ets > pages，打开工程中的Index.ets文件， 新增一个方法调用hidebug接口，本文以hidebug.getSystemCpuUsage()为例，其他接口可参考API参考文档。 给文本Text组件添加一个点击事件，示例代码如下：
```typescript
import { hidebug } from '@kit.PerformanceAnalysisKit';
import { BusinessError } from '@kit.BasicServicesKit';
function testHidebug(event?: ClickEvent) {
try {
console.info(`getSystemCpuUsage: ${hidebug.getSystemCpuUsage()}`)
} catch (error) {
console.error(`error code: ${(error as BusinessError).code}, error msg: ${(error as BusinessError).message}`);
}
}
```
4.  在真机上运行该工程，单击应用/服务界面上的“Hello World”文本。
5.  在DevEco Studio的底部，切换到“Log”窗口，设置日志的过滤条件为“testTag”。 此时窗口将显示通过hidebug.getSystemCpuUsage()接口获取的CPU使用率的相关日志。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hidebug-guidelines-ndk-V14
爬取时间: 2025-04-28 19:18:45
来源: Huawei Developer
HiDebug模块对外提供应用调试功能。
接口说明
| 接口名 | 描述 |
| --- | --- |
| OH_HiDebug_GetSystemCpuUsage | 获取系统的CPU资源占用情况百分比。 |
| OH_HiDebug_GetAppCpuUsage | 获取进程的CPU使用率百分比。 |
| OH_HiDebug_GetAppThreadCpuUsage | 获取应用所有线程CPU使用情况。 |
| OH_HiDebug_FreeThreadCpuUsage | 释放线程数据结构。 |
| OH_HiDebug_GetSystemMemInfo | 获取系统内存信息。 |
| OH_HiDebug_GetAppNativeMemInfo | 获取应用程序进程的内存信息。 |
| OH_HiDebug_GetAppMemoryLimit | 获取应用程序进程的内存限制。 |
| OH_HiDebug_StartAppTraceCapture | 启动应用trace采集。 |
| OH_HiDebug_StopAppTraceCapture | 停止应用trace采集。 |
| OH_HiDebug_GetGraphicsMemory | 获取应用显存大小。 |
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考HiDebug。
开发步骤
下文将展示如何在应用内增加一个按钮，并单击该按钮以调用Hidebug Ndk接口。
1.  新建Native C++工程，目录结构如下：
2.  编辑"CMakeLists.txt"文件，添加库依赖：
3.  编辑"napi_init.cpp"文件，导入依赖的文件，并定义LOG_TAG及测试方法： 本示例中以OH_HiDebug_GetSystemCpuUsage接口为例，调用该接口并输出返回值，其他接口请参考HiDebug。
4.  将TestHidebugNdk注册为ArkTS接口： 编辑"napi_init.cpp"文件，将TestHidebugNdk注册为ArkTS接口： 编辑"index.d.ts"文件，定义ArkTS接口：
5.  编辑"Index.ets"文件，给文本Text组件添加一个点击事件，示例代码如下：
```typescript
import testNapi from 'libentry.so'
@Entry
@Component
struct Index {
@State message: string = 'Hello World'
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(testNapi.testHidebugNdk);//添加点击事件，触发testHidebugNdk方法。
}
.width('100%')
}
.height('100%')
}
}
```
6.  点击DevEco Studio界面中的运行按钮，运行应用工程，点击"Hello world"文本。
7.  在DevEco Studio的底部，切换到“Log”窗口，设置日志的过滤条件为“testTag”。 此时窗口将显示通过OH_HiDebug_GetSystemCpuUsage()接口获取的CPU使用率的相关日志。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hicollie-V14
爬取时间: 2025-04-28 19:18:59
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hicollie-guidelines-ndk-V14
爬取时间: 2025-04-28 19:19:12
来源: Huawei Developer
HiCollie模块对外提供检测业务线程卡死、卡顿，以及上报卡死事件的能力。
接口说明
| 接口名 | 描述 |
| --- | --- |
| OH_HiCollie_Init_StuckDetection | 注册应用业务线程卡死的周期性检测任务。用户实现回调函数，用于定时检测业务线程卡死情况。 |
| OH_HiCollie_Init_JankDetection | 注册应用业务线程卡顿检测的回调函数。线程卡顿监控功能需要开发者实现两个卡顿检测回调函数，分别放在业务线程处理事件的前后。作为插桩函数，监控业务线程处理事件执行情况。 |
| OH_HiCollie_Report | 用于上报应用业务线程卡死事件，生成超时故障日志，辅助定位应用超时问题。结合OH_HiCollie_Init_StuckDetection接口配套使用，先初始化卡死检测，出现卡死时，再上报事件。 |
业务线程卡死故障日志是以appfreeze-开头，生成在”设备/data/log/faultlog/faultlogger/”路径下。该日志文件名格式为“appfreeze-应用包名-应用UID-秒级时间”。具体规格可参考：appfreeze-应用无响应日志分析。
业务线程卡顿故障日志规格，可参考：主线程超时事件时间规格和主线程超时事件规格。
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考HiCollie。
开发步骤
下文将展示如何在应用内增加一个按钮，并单击该按钮以调用HiCollie Ndk接口。
1.  新建Native C++工程，并将jsoncpp导入到新建工程内，目录结构如下：
2.  编辑"CMakeLists.txt"文件，添加源文件及动态库：
3.  编辑"napi_init.cpp"文件，导入依赖的文件，并定义LOG_TAG及测试方法：
4.  将TestHiCollieNdk注册为ArkTS接口： 编辑"napi_init.cpp"文件，将TestHiCollieNdk注册为ArkTS接口： 编辑"index.d.ts"文件，定义ArkTS接口：
5.  编辑"Index.ets"文件：
```typescript
import testNapi from 'libentry.so'
@Entry
@Component
struct Index {
@State message: string = 'Hello World'
build() {
Row() {
Column() {
Button("testHiCollieJankNdk")
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(testNapi.testHiCollieJankNdk);//添加点击事件，触发testHiCollieJankNdk方法。
Button("testHiCollieStuckNdk")
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(testNapi.testHiCollieStuckNdk);//添加点击事件，触发testHiCollieStuckNdk方法。
}
.width('100%')
}
.height('100%')
}
}
```
6.  点击DevEco Studio界面中的运行按钮，运行应用工程。
7.  在DevEco Studio的底部，切换到“Log”窗口，设置日志的过滤条件为“testTag”。 （1）等待10s，再点击"testHiCollieJankNdk"按钮（线程启动10s内，不进行卡顿检测）。 此时窗口将显示通过OH_HiCollie_Init_JankDetection接口获取的应用业务线程采样栈的超时信息。 生成栈文件目录地址：/data/app/el2/100/log/应用bundle name/watchdog/BUSSINESS_THREAD_JANK_XXX.txt。 （2）点击"testHiCollieStuckNdk"按钮。 此时窗口将显示通过OH_HiCollie_Init_StuckDetection接口，初始化卡死检测回调函数。可以根据实际业务场景，自行定义卡死检测函数。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/error-manager-V14
爬取时间: 2025-04-28 19:19:27
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/errormanager-guidelines-V14
爬取时间: 2025-04-28 19:19:40
来源: Huawei Developer
场景介绍
当应用的代码存在规范问题或错误时，会在运行中产生异常和错误，如应用未捕获异常、应用生命周期超时等。在错误产生后，应用会异常退出。错误日志通常会保存在用户本地存储上，不方便开发者定位问题。所以，应用开发者可以使用错误管理的接口，在应用退出前，及时将相关错误及日志上报到开发者的服务平台来定位问题。
使用errormanager接口监听异常和错误后，应用不会退出，建议在回调函数执行完后，增加同步退出操作，如果只是为了获取错误日志，建议使用hiappevent。
接口说明
应用错误管理接口由errorManager模块提供，开发者可以通过import引入，详见开发示例。
错误管理接口功能介绍：
| 接口名称 | 说明 |
| --- | --- |
| on(type: "error", observer: ErrorObserver): number | 注册错误监听接口，当系统监测到应用异常时会回调该监听。该接口为同步接口，返回值为注册的监听对象对应的序号。 |
| off(type: "error", observerId: number, callback: AsyncCallback<void>): void | 以callback的形式解除注册监听，传入的number为之前注册监听时返回的序号。 |
| off(type: "error", observerId: number): Promise<void> | 以Promise的形式解除注册监听，传入的number为之前注册监听时返回的序号。 |
| on(type: 'loopObserver', timeout: number, observer: LoopObserver): void12+ | 注册主线程消息处理耗时监听器，当系统监测到应用主线程事件处理超时时会回调该监听。只能在主线程调用，多次注册后，后一次的注册会覆盖前一次的。 |
| off(type: 'loopObserver', observer?: LoopObserver): void12+ | 解除应用主线程消息处理耗时监听。 |
当采用callback作为异步回调时，可以在callback中进行下一步处理。当采用Promise对象返回时，可以在Promise对象中类似地处理接口返回值。具体结果码说明见解除注册结果码。
错误监听(ErrorObserver)接口功能介绍：
| 接口名称 | 说明 |
| --- | --- |
| onUnhandledException(errMsg: string): void | 系统回调接口，应用注册后，当应用产生未捕获的异常时的回调。 |
| onException?(errObject: Error): void | 系统回调接口，应用注册后，当应用产生异常上报js层时的回调。 |
应用主线程监听(LoopObserver)接口功能介绍：
| 接口名称 | 说明 |
| --- | --- |
| onLoopTimeOut?(timeout: number): void12+ | 系统回调接口，应用注册后，当应用主线程处理事件超时的回调。 |
解除注册结果码
| 结果码 | 原因 |
| --- | --- |
| 0 | 正常返回 |
| -1 | 传入的number不存在 |
| -2 | 参数错误 |
开发示例
建议在异常回调函数处理的最后，增加同步退出操作，否则可能出现多次异常回调的现象。
```typescript
import { AbilityConstant, errorManager, UIAbility, Want } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import process from '@ohos.process';
let registerId = -1;
let callback: errorManager.ErrorObserver = {
onUnhandledException: (errMsg) => {
console.log(errMsg);
},
onException: (errorObj) => {
console.log('onException, name: ', errorObj.name);
console.log('onException, message: ', errorObj.message);
if (typeof(errorObj.stack) === 'string') {
console.log('onException, stack: ', errorObj.stack);
}
//回调函数执行完，采用同步退出方式，避免多次触发异常
let pro = new process.ProcessManager();
pro.exit(0);
}
}
let abilityWant: Want;
export default class EntryAbility extends UIAbility {
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
console.log("[Demo] EntryAbility onCreate");
registerId = errorManager.on("error", callback);
abilityWant = want;
}
onDestroy() {
console.log("[Demo] EntryAbility onDestroy");
errorManager.off("error", registerId, (result) => {
console.log("[Demo] result " + result.code + ";" + result.message);
});
}
onWindowStageCreate(windowStage: window.WindowStage) {
// Main window is created, set main page for this ability
console.log("[Demo] EntryAbility onWindowStageCreate");
windowStage.loadContent("pages/index", (err, data) => {
if (err.code) {
console.error('Failed to load the content. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in loading the content. Data: ' + JSON.stringify(data));
});
}
onWindowStageDestroy() {
// Main window is destroyed, release UI related resources
console.log("[Demo] EntryAbility onWindowStageDestroy");
}
onForeground() {
// Ability has brought to foreground
console.log("[Demo] EntryAbility onForeground");
}
onBackground() {
// Ability has back to background
console.log("[Demo] EntryAbility onBackground");
}
};
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/apprecovery-guidelines-V14
爬取时间: 2025-04-28 19:19:54
来源: Huawei Developer
场景介绍
应用在运行中不可避免会产生一些非预期的行为，如运行时抛出未处理的异常和错误，违反框架的调用/运行约束等。
系统默认对异常的处理方式为进程退出，如果应用使用过程中产生了用户数据，直接退出可能会导致用户工作中断，数据丢失。
如果应用在AbilityStage中使能应用恢复功能，并对临时数据进行保存，应用非预期退出后的下一次启动会恢复先前的状态和数据，给用户更连贯的使用体验。这里状态包括应用的页面栈以及onSaveState接口中保存的数据。
API 9上的应用恢复接口支持单Ability的Stage模型应用开发。支持JsError故障时的状态保存与自动重启。
API 10在API 9的基础上新增支持多Ability的Stage模型应用开发。支持AppFreeze故障时的状态保存回调。支持应用被管控模式杀死后，下次启动的状态恢复。
接口说明
应用故障恢复接口由appRecovery模块提供，开发者可以通过import引入，详见开发示例。
应用恢复接口功能介绍
| 接口名称 | 说明 |
| --- | --- |
| enableAppRecovery(restart?: RestartFlag, saveOccasion?: SaveOccasionFlag, saveMode?: SaveModeFlag) : void;9+ | 使能应用恢复功能，参数按顺序填入。该接口调用后，应用从启动器启动时第一个Ability支持恢复。 |
| saveAppState(): boolean;9+ | 主动保存当前应用中支持恢复的Ability的状态。 |
| restartApp(): void;9+ | 重启当前进程，并启动由setRestartWant指定的Ability，如果未指定，将重新拉起处于前台且支持恢复的Ability。 |
| saveAppState(context?: UIAbilityContext): boolean;10+ | 主动保存由Context指定的Ability状态。 |
| setRestartWant(want: Want): void;10+ | 设置主动调用restartApp以及RestartFlag不为NO_RESTART时重启的Ability。该Ability必须在同一个包名下，且必须为UIAbility。 |
由于上述接口可能在故障处理时使用，所以不会返回异常，需要开发者熟悉使用的场景。
enableAppRecovery:需要在应用初始化阶段调用，比如AbilityStage的OnCreate调用。具体其各参数定义详见参数说明。
saveAppState:调用后框架会回调当前进程中所有支持恢复的Ability的onSaveState方法，如果在onSaveState方法中同意保存数据，则会将相关数据及Ability的页面栈持久化到应用的本地缓存。如果需要保存指定Ability，则需要指定Ability对应的Context。
setRestartWant:指定由appRecovery发起重启的Ability。
restartApp:调用后框架会杀死当前应用进程，并重新拉起由setRestartWant指定的Ability，其中启动原因为APP_RECOVERY。API 9以及未使用setRestartWant指定Ability的场景，会拉起最后一个支持恢复且在前台的Ability，如果当前前台的Ability不支持恢复，则应用表现闪退。如果重启的Ability存在已经保存的状态，这些状态数据会在Ability的OnCreate生命周期回调的want参数中作为wantParam属性传入。两次重启的间隔应大于一分钟，一分钟之内重复调用此接口只会退出应用不会重启应用。自动重启的行为与主动重启一致。
应用恢复状态管理示意
从API 10起，应用恢复的场景不仅局限于异常时自动重启。所以需要理解应用何时会加载恢复的状态。
一句话概括就是如果应用任务的上次退出不是由用户发起的，且应用存在用于恢复的状态，应用下一次由用户拉起时的启动原因会被设为APP_RECOVERY，并清理该任务的恢复状态。
应用恢复状态标识会在状态保存接口主动或者被动调用时设置。在该应用正常退出或者应用异常退出重启后使用了该状态时清理。正常退出目前包括用户按后退键退出以及用户清理最近任务。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170523.11108634036363505166956553917207:50001231000000:2800:E575D4737539DC921E5C2E57BF718065BE7D0C6B56F73F996AE955E2C1D31677.png)
应用卡死的状态保存及恢复
API 10开始支持应用卡死时的状态保存。JsError故障时，onSaveState接口在主线程进行回调。对于AppFreeze故障，主线程可能处于卡死的状态，onSaveState会在非主线程进行回调。其主要流程如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170523.30701322133353928953026782132842:50001231000000:2800:87F9E4AB82BEE0DA6E290671844CFA75EE03CB8AB81E540E099E2836862CE95D.png)
由于卡死时的回调不在JS线程上执行，onSaveState回调中的代码建议不要使用import进来的Native动态库，禁止访问主线程创建的thread_local对象。
框架故障管理流程示意
故障管理是应用提升用户体验的重要手段。应用程序框架为开发者提供了故障监听、故障恢复、以及故障查询三种方式来管理应用的故障。
-  故障监听指的是通过errorManager注册ErrorObserver，监听故障的发生，并通知到监听方。
-  故障恢复指的是appRecovery，及故障发生后，将应用重启恢复到故障之前的状态。
-  故障查询指的是faultLogger通过其查询接口获取当前的故障信息。
下图中并没有标记faultLogger的调用时机，开发者可以根据应用启动时传入的LastExitReason来决定是否调用faultLogger查询上次的故障信息。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170523.88360400177082085750233593106127:50001231000000:2800:952DF014E933D8B99E276066C0EE4B5EEF953DE20FA8FFA14AE43C5985FFD56C.png)
这里建议应用开发者使用errorManager对应用的异常进行处理，处理完成后开发者可以选择调用状态保存接口并主动重启应用。
如果开发者没有注册ErrorObserver也没有使能应用恢复，则按照系统的默认逻辑执行进程退出。用户可以选择从启动器再次打开应用。
如果开发者使能应用恢复，框架会首先检查当前故障是否支持状态保存以及开发者是否配置了状态保存，如果支持则会回调Ability的onSaveState的接口。最后重启应用。
应用故障管理接口支持场景
通常的故障类型有JS程序Crash、应用程序卡死、C++程序Crash。Crash故障时应用一般都会被关闭。Freeze故障为应用无响应卡屏场景。应用上层无需关注故障类型，底层恢复框架会根据故障类型来实现不同场景的故障管理。
| 故障名称 | 故障监听 | 状态保存 | 自动重启 | 日志查询 |
| --- | --- | --- | --- | --- |
| JS_CRASH | 支持 | 支持 | 支持 | 支持 |
| APP_FREEZE | 不支持 | 支持 | 支持 | 支持 |
| CPP_CRASH | 不支持 | 不支持 | 不支持 | 支持 |
这里状态保存指的是故障时状态保存，对于应用卡死场景，开发者可以采用定时保存状态或者在Ability切入后台后自动保存的方式最大限度的保护用户数据。
开发示例
使能开启自恢复特性
开发者需要在应用模块初始化时使能appRecovery功能。下面为示例的AbilityStage。
```typescript
import { AbilityStage, appRecovery } from '@kit.AbilityKit';
export default class MyAbilityStage extends AbilityStage {
onCreate() {
console.info("[Demo] MyAbilityStage onCreate");
appRecovery.enableAppRecovery(appRecovery.RestartFlag.ALWAYS_RESTART,
appRecovery.SaveOccasionFlag.SAVE_WHEN_ERROR | appRecovery.SaveOccasionFlag.SAVE_WHEN_BACKGROUND,
appRecovery.SaveModeFlag.SAVE_WITH_FILE);
}
}
```
配置支持恢复的Ability
Ability的配置清单一般的名字为module.json5。
```json
{
"abilities": [
{
"name": "EntryAbility",
"recoverable": true,
}]
}
```
数据保存和恢复
在使能appRecovery功能后，开发者可以在Ability中采用主动保存状态，主动恢复或者选择被动恢复的方式使用appRecovery功能。
下面为示例的EntryAbility。
导包
```typescript
import { AbilityConstant, appRecovery, errorManager } from '@kit.AbilityKit';
```
主动触发保存和恢复
```typescript
import { appRecovery, errorManager, UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
let registerId = -1;
let callback: errorManager.ErrorObserver = {
onUnhandledException(errMsg) {
console.log(errMsg);
appRecovery.saveAppState();
appRecovery.restartApp();
}
}
export default class EntryAbility extends UIAbility {
onWindowStageCreate(windowStage: window.WindowStage) {
// Main window is created, set main page for this ability
console.log("[Demo] EntryAbility onWindowStageCreate");
registerId = errorManager.on('error', callback);
windowStage.loadContent("pages/index", (err, data) => {
if (err.code) {
console.error('Failed to load the content. Cause:' + JSON.stringify(err));
return;
}
console.info('Succeeded in loading the content. Data: ' + JSON.stringify(data));
})
}
}
```
callback触发appRecovery.saveAppState()调用后，会触发EntryAbility的onSaveState(state, wantParams)函数回调。
```typescript
import { AbilityConstant, UIAbility } from '@kit.AbilityKit';
export default class EntryAbility extends UIAbility {
onSaveState(state:AbilityConstant.StateType, wantParams: Record<string, Object>) {
// Ability has called to save app data
console.log("[Demo] EntryAbility onSaveState");
wantParams["myData"] = "my1234567";
return AbilityConstant.OnSaveResult.ALL_AGREE;
}
}
```
callback触发后appRecovery.restartApp()调用后，应用会重启，重启后会走到EntryAbility的onCreate(want, launchParam)函数，保存的数据会在want参数的parameters里。
```typescript
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
let abilityWant: Want;
export default class EntryAbility extends UIAbility {
storage: LocalStorage | undefined = undefined;
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
console.log("[Demo] EntryAbility onCreate");
abilityWant = want;
if (launchParam.launchReason == AbilityConstant.LaunchReason.APP_RECOVERY) {
this.storage = new LocalStorage();
if (want.parameters) {
let recoveryData = want.parameters["myData"];
this.storage.setOrCreate("myData", recoveryData);
this.context.restoreWindowStage(this.storage);
}
}
}
}
```
```typescript
import { errorManager, UIAbility } from '@kit.AbilityKit';
let registerId = -1;
export default class EntryAbility extends UIAbility {
onWindowStageDestroy() {
// Main window is destroyed, release UI related resources
console.log("[Demo] EntryAbility onWindowStageDestroy");
errorManager.off('error', registerId, (err) => {
console.error("[Demo] err:", err);
});
}
}
```
被动保存和恢复
被动保存和恢复依赖恢复框架底层触发，无需注册监听ErrorObserver callback，只需实现Ability的onSaveState接口数据保存和onCreate接口数据恢复流程即可。
```typescript
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
let abilityWant: Want;
export default class EntryAbility extends UIAbility {
storage: LocalStorage | undefined = undefined
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
console.log("[Demo] EntryAbility onCreate");
abilityWant = want;
if (launchParam.launchReason == AbilityConstant.LaunchReason.APP_RECOVERY) {
this.storage = new LocalStorage();
if (want.parameters) {
let recoveryData = want.parameters["myData"];
this.storage.setOrCreate("myData", recoveryData);
this.context.restoreWindowStage(this.storage);
}
}
}
onSaveState(state:AbilityConstant.StateType, wantParams: Record<string, Object>) {
// Ability has called to save app data
console.log("[Demo] EntryAbility onSaveState");
wantParams["myData"] = "my1234567";
return AbilityConstant.OnSaveResult.ALL_AGREE;
}
}
```
故障Ability的重启恢复标记
发生故障的Ability再次重新启动时，在调度onCreate生命周期里，参数want的parameters成员会有ABILITY_RECOVERY_RESTART标记数据，并且值为true。
```typescript
import { AbilityConstant, UIAbility, Want, wantConstant } from '@kit.AbilityKit';
export default class EntryAbility extends UIAbility {
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
if (want.parameters === undefined) {
return;
}
if (want.parameters[wantConstant.Params.ABILITY_RECOVERY_RESTART] != undefined &&
want.parameters[wantConstant.Params.ABILITY_RECOVERY_RESTART] == true) {
console.log("This ability need to recovery");
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/fault-analysis-V14
爬取时间: 2025-04-28 19:20:08
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/jscrash-guidelines-V14
爬取时间: 2025-04-28 19:20:21
来源: Huawei Developer
当未处理的JS异常导致应用意外退出时，应用会在抛出未处理的异常时崩溃并且会生成对应的JS Crash崩溃日志文件。开发者可通过错误日志查看引起崩溃的代码位置及分析应用崩溃的原因。
本文将分别介绍JS Crash异常捕获场景，JS Crash故障分析思路，以及典型分析案例。
JS Crash异常检测能力
JS Crash日志规格
以下是进程崩溃日志信息中对应字段解释。
JS Crash多为应用问题，开发者可通过崩溃文件中的 Error message 和 StackTrace 来定位问题。
JS Crash异常捕获场景
JS Crash异常根据不同的异常场景，在 Reason 字段进行了分类，分为Error、TypeError、SyntaxError、RangeError等错误类型。
-  自定义 Error 类：Error 是最基本的错误类型，其他的错误类型都继承自该类型。Error 对象主要有两个重要属性 message 和 name 分别表示错误信息和错误名称。程序运行过程中抛出的异常一般都有具体的类型，Error 类型一般都是开发人员自己抛出的异常。
-  TypeError（类型错误）类：运行时最常见的异常，表示变量或参数不是预期类型。
-  SyntaxError（语法错误）类：语法错误也称为解析错误。语法错误在任何编程语言中都是最常见的错误类型，表示不符合编程语言的语法规范。
-  RangeError（边界错误）类：表示超出有效范围时发生的异常，主要的有以下几种情况：
-  ReferenceError —— 引用错误：引用一个不存在的变量时发生的错误，每当我们创建一个变量时，变量名称都会写入一个变量存储中心中，这个变量存储中心就像键值存储一样，每当我们引用变量时，它都去存储中找到 key并提取并返回 value，如果我们要找的变量不在存储中，就会抛出 ReferenceError。
-  URI Error —— URL错误：在调用 URI 相关的方法中 URL 无效时抛出的异常，主要包括 encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape() 和 unescape() 几个函数 。
问题定位思路
获取日志
进程崩溃日志是一种故障日志，与应用无响应日志、JS应用崩溃等都由FaultLogger模块管理，可通过以下方式获取：
-  方式一：通过DevEco Studio获取日志 DevEco Studio会收集设备“/data/log/faultlog/faultlogger/”路径下的进程崩溃故障日志并归档在FaultLog下，获取日志的方法可参考DevEco Studio使用指南-FaultLog。
-  方式二：通过hiAppEvent接口订阅 hiAppEvent 提供了故障订阅接口，可以订阅各类故障打点，详见HiAppEvent介绍。
根因分析
JS Crash问题分析一般根据上述异常的场景，结合错误信息、调用栈定位到源码，可得出基本的分析结论。对于调用栈的分析有以下几种情况。
1. StackTrace 场景分类
JS Crash故障日志中，StackTrace 字段存放的是 JS Crash 异常的调用栈信息，StackTrace 的显示分为以下几种场景。
1.  JS调用栈可直接通过超链接跳转到对应错误代码行，栈顶即为问题第一现场，如下样例所示。
2.  异常代码调用栈 Stack Cannot get SourceMap info, dump raw stack，表示因SourceMap转换失败，仅展示eTS栈对应编译后产物中代码行号，可通过超链接跳转到对应错误代码行，如下样例所示。
3.  异常代码调用栈包含 SourceMap is not initialized yet ，表示因SourceMap转换非常耗时，改为通过异步线程去进行初始化，导致会出现SourceMap没初始化完成就有异常产生的情况。针对这种情况增加这行日志来提示开发者。eTS栈对应编译后产物中代码行号，可通过超链接跳转到对应错误代码行。如下样例所示。
4.  异常代码调用栈中打印native栈，栈顶一般为libark_jsruntime.so动态库，这是因为JS异常最后都会经过虚拟机抛出。从崩溃栈从上往下找，libace_napi.z.so的上一帧一般是抛出异常的现场。如下样例所示。
```shell
Device info:xxx
Build info:xxx-xxx x.x.x.xxx(xxxx)
Fingerprint:89f2b64b24d642b0fc64e3a7cf68ca39fecaa580ff5736bb9d6706ea4cdf2c93
Module name:com.xxx.xxx
Version:1.0.0
VersionCode:1000000
PreInstalled:No
Foreground:No
Pid:14325
Uid:20020145
Reason:ReferenceError
Error name:ReferenceError
Error message:Cannot find module 'com.xxx.xxx/entry/EntryAbility' , which is application Entry Point
Stacktrace:
SourceMap is not initialized yet
#01 pc 000000000028ba3b /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#02 pc 00000000001452ff /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#03 pC 0000000000144c9f /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#04 pc 00000000001c617b /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#05 pc 00000000004c3cb7 /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#06 pc 00000000004c045f /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#07 pc 000000000038034f /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#08 pc 00000000004b2d9b /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#09 pc 0000000000037e7f /system/libó4/platformsdk/libace_napi.z.so(10ceafd39b5354314d2fe3059b8f9e4f)
#10 pc 00000000000484cf /system/lib64/platformsdk/libruntime.z.so(3f6305a3843fae1de148a06eec4bd014) <- 异常抛出位置
#11 pc 000000000004fce7 /system/libó4/platformsdk/libruntime.z.so(3f6305a3843fae1de148a06eec4bd014)
#12 pc 000000000004e9fb /system/libó4/platformsdk/libruntime.z.so(3f6305a3843fae1de148a06eec4bd014)
#13 pc 000000000004eb7b /system/libó4/platformsdk/libruntime.z.so(3f6305a3843fae1de148a06eec4bd014)
#14 pc 000000000004f5c7 /system/libó4/platformsdk/libruntime.z.so(3f6305a3843fae1de148a06eec4bd014)
#15 pc 00000000000303cf /system/lib64/platformsdk/libuiabilitykit_native.z.so(3203F4CCe84a43b519d0a731dfOdb1a3)
```
2. 调用栈分析
调用栈分析会有如下两种情况：
-  情况一：可跳转至引起错误的代码行 如果FaultLog的堆栈信息中的链接或偏移地址指向的是当前工程中的某行代码，该段信息将被转换为超链接形式，在DevEco Studio中点击后跳转至对应代码行。
-  情况二：不可跳转至引起错误的代码行或者跳转代码位置不存在 如出现Cannot get Source Map info, dump raw stack信息代表js栈转换ets行列号失败，在DevEco Studio中点击链接会跳转到不正确的代码位置或不存在的代码行位置。 应用代码运行出错时，会打印错误栈信息。如果ts栈转换ets行列号失败时错误栈的后缀仍显示为ets，开发者需要在build目录下编译中间产物以生成ts代码，在js代码中定位对应错误代码行。可参考：应用堆栈解析。
分析案例
本章节将基于现在开发者所遇到的高频的两类JS Crash故障进行案例介绍，包含 TypeError 和 Error 类。
TypeError类案例分析
TypeError类问题在实际应用开发调试运行过程中是最常见的JS Crash类型，其表示为变量不是预期类型，在代码层面则为对变量的使用未进行事先的校验，在错误日志中报错多表现为如下：
案例一：更新跟手动效相关属性时偶现JS Crash
1.  获取JS Crash日志如下：
2.  提取日志关键信息 通过日志信息可以确定为Type Error类问题，由异常信息得知是在读取needRenderTranslate对象时报错，该对象为undefined。最后可以通过异常代码调用栈，获取错误产生位置。
Cannot get SourceMap info, dump raw stack 信息表示该应用为release包安装，JS栈转换eTS行列号失败，可考虑使用应用堆栈解析来解析行号。
1.  定位到具体代码 通过以上 JS 堆栈和报错变量分析，能够定位到具体函数示例如下：
2.  修改方案 上述分析已经明确为 sceneContainerSessionList 的成员变量 needRenderTranslate 在使用的过程中可能存在为 undefined 的情况。对于这类问题，需要增加保护性判断，可直接规避此类问题。具体修改方法可以如下，在访问对象前增加 '?' 操作符进行判断保护。
3.  思考与建议 对于这类问题，需要我们在编码阶段充分考虑对象访问的安全性，确保必要的判空处理。同时很多场景单纯的判空可能只能是规避问题，还需要结合业务看看是否是原始对象构造或赋值的逻辑存在问题。
Error 类案例分析
Error 类问题一般是开发者或JS库主动抛出来的JS异常。
这类问题目前有两种场景：
1. 如果是当前应用程序遇到无法解决的只能终止当前业务的故障，需要考虑抛出JS异常来终止业务并生成故障日志。
2. 依赖使用JS库或者其他的模块接口，对于可能抛出异常的接口，需要考虑使用 try-catch 机制进行捕获，否则也会终止当前业务。
案例一：如何主动抛出一个自定义的JS异常来终止程序
开发者自主抛出JS异常，可通过如下代码实现：
通过上述开发过程基于 DevEco Studio FaultLog工具收集到的故障日志，可以基于JS异常栈直接定位到抛异常的位置。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170524.12534806595357984590455061517572:50001231000000:2800:967E3CE431F060AE7A5DB22DAA2049E6B5E9F1FADB30B37BBE5D6FA68C542FDA.png)
遇到这类问题的解决思路，仍旧是通过故障日志定位到具体的代码行，检视上下文来分析问题即可。
案例二：因未处理三方接口抛出的JS异常导致的JS Crash问题
1.  获取JS Crash 日志核心内容如下
2.  提取日志关键信息 通过日志信息可以确定为 Error 类问题，为代码主动抛出的异常。最后可以通过异常代码调用栈，获取错误产生位置。
Cannot get SourceMap info, dump raw stack 信息表示该应用为release包安装，JS栈转换eTS行列号失败，可考虑使用应用堆栈解析来解析行号。
1.  定位到具体代码 通过以上 JS 堆栈，能够定位到 NetSpeedController.ts 文件中具体代码片段如下，异常抛出位置为 wifiManager.on 函数调用。
2.  修改方案 通过分析 wifiManager.on 源码，得知该函数内存在部分场景会抛出内容为 BussinessError 2501000: Operation failed. 的 JS 异常，对于此类问题，识别当前业务异常不会导致当前程序无法运行下去，考虑使用 try-catch 机制对异常进行捕获处理。具体的修改方法可参考如下:
3.  思考与建议 对于这类问题，我们可以考虑在编码阶段灵活的运用 JS 异常机制，来识别各类异常场景；同时对于使用可能会抛异常的接口，也需要考虑是否需要捕获该异常，避免影响应用主体业务。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/cppcrash-guidelines-V14
爬取时间: 2025-04-28 19:20:36
来源: Huawei Developer
进程崩溃指C/C++运行时崩溃。FaultLogger模块提供进程崩溃故障检测、日志采集、日志存储、日志上报的能力，为开发者提供详细的维测日志以辅助故障定位。
本文将分别介绍进程崩溃检测能力、崩溃问题定位分析思路，以及具体的案例分析。在使用本指导分析处理崩溃日志前，需要开发者了解C/C++程序堆栈信息的基础知识。
Cpp Crash异常检测能力
进程崩溃基于posix信号机制，目前主要支持对以下崩溃异常信号的处理：
| 信号值(signo) | 信号 | 解释 | 触发原因 |
| --- | --- | --- | --- |
| 4 | SIGILL | 非法指令。 | 进程执行了非法、格式错误、未知或特权指令。 |
| 5 | SIGTRAP | 断点或陷阱异常。 | 异常或trap指令发生。 |
| 6 | SIGABRT | 进程终止。 | 进程异常终止，通常为进程自身调用标准函数库的abort()函数。 |
| 7 | SIGBUS | 非法内存访问。 | 进程访问了对齐或者不存在的物理地址。 |
| 8 | SIGFPE | 浮点异常。 | 进程执行了错误的算术运算，如除数为0、浮点溢出、整数溢出等。 |
| 11 | SIGSEGV | 无效内存访问。 | 进程访问了无效内存引用。 |
| 16 | SIGSTKFLT | 栈错误。 | 处理器执行了错误的栈操作，如栈空时弹出、栈满时压入。 |
| 31 | SIGSYS | 错误的系统调用。 | 系统调用时使用了错误或非法参数。 |
以上部分故障信号，根据具体的场景还有二级分类(code)：
SIGILL是一个在Unix和类Unix操作系统中的信号，它表示非法指令异常。SIGILL信号通常由以下几种类型的问题场景引起：
| 二级分类 | 信号字符串 | 解释 | 触发原因 |
| --- | --- | --- | --- |
| 1 | ILL_ILLOPC | 非法操作码异常 | 这种异常通常发生在执行不被CPU支持的指令时，或者在尝试执行特权指令时。 |
| 2 | ILL_ILLOPN | 非法操作数异常 | 这种异常通常发生在指令使用了不正确的操作数，或者是操作数的类型不正确时。 |
| 3 | ILL_ILLADR | 非法地址异常 | 这种异常通常发生在程序尝试访问无效的内存地址时，或者是在尝试执行未对齐的内存访问时。 |
| 4 | ILL_ILLTRP | 非法陷阱异常 | 这种异常通常发生在程序尝试执行一个非法的陷阱指令时，或者是在尝试执行一个未定义的操作时。 |
| 5 | ILL_PRVOPC | 特权操作码异常 | 这种异常通常发生在普通用户尝试执行特权指令时。 |
| 6 | ILL_PRVREG | 特权寄存器异常 | 这种异常通常发生在普通用户尝试访问特权寄存器时。 |
| 7 | ILL_COPROC | 协处理器异常 | 这种异常通常发生在程序尝试使用未定义的协处理器指令时。 |
| 8 | ILL_BADSTK | 无效的堆栈异常 | 这种异常通常发生在程序尝试在无效的堆栈地址上执行操作时，或者是在堆栈溢出时。 |
SIGTRAP信号通常用于调试和跟踪程序的执行。下面是上面列出的四种SIGTRAP信号类别的问题场景介绍：
| 二级分类 | 信号字符串 | 解释 | 触发原因 |
| --- | --- | --- | --- |
| 1 | TRAP_BRKPT | 软件断点 | 这个信号是由软件断点引起的，当程序执行到设置的断点时会触发该信号。软件断点通常用于调试程序，可以在程序的关键位置设置断点，以便在调试时暂停程序的执行并检查变量值等信息。 |
| 2 | TRAP_TRACE | 单步调试 | 这个信号是由单步执行引起的，当程序执行单个指令时会触发该信号。单步执行通常用于调试程序，可以逐步执行程序并检查每个指令的执行结果。 |
| 3 | TRAP_BRANCH | 分支跟踪 | 这个信号是由分支指令引起的，当程序执行分支指令时会触发该信号。分支指令通常用于控制程序的执行流程，例如if语句和循环语句等。 |
| 4 | TRAP_HWBKPT | 硬件断点 | 这个信号是由硬件断点引起的，当程序执行到设置的硬件断点时会触发该信号。硬件断点通常用于调试程序，可以在程序的关键位置设置断点，以便在调试时暂停程序的执行并检查变量值等信息。与软件断点不同的是，硬件断点是由CPU硬件实现的，因此可以在程序执行过程中实时检测断点是否被触发。 |
SIGBUS是一种由操作系统向进程发送的信号，通常表示内存访问错误。其中，不同的信号类别表示不同的错误场景：
| 二级分类 | 信号字符串 | 解释 | 触发原因 |
| --- | --- | --- | --- |
| 1 | BUS_ADRALN | 内存地址对齐错误 | 这种错误通常发生在尝试访问未对齐的内存地址时，例如尝试访问一个4字节整数的非偶数地址。 |
| 2 | BUS_ADRERR | 非法内存地址错误 | 这种错误通常发生在尝试访问不属于进程地址空间的内存地址时，例如尝试访问一个空指针。 |
| 3 | BUS_OBJERR | 对象访问错误 | 这种错误通常发生在尝试访问一个已经被删除或未初始化的对象时。 |
| 4 | BUS_MCEERR_AR | 硬件内存校验错误 | 发生在访问内存时检测到校验和错误。 |
| 5 | BUS_MCEERR_AO | 硬件内存校验错误 | 发生在访问内存时检测到地址和校验和错误。 |
SIGFPE是一个信号，它表示浮点异常或算术异常。下面是这些SIGFPE信号类别的问题场景：
| 二级分类 | 信号字符串 | 解释 | 触发原因 |
| --- | --- | --- | --- |
| 1 | FPE_INTDIV | 整数除法错误 | 这个信号表示整数除法中的除数为零的情况。当一个程序尝试进行整数除法，但除数为零时，会发出这个信号。 |
| 2 | FPE_INTOVF | 整数溢出错误 | 这个信号表示整数除法中的除数为负数的情况。当一个程序尝试进行整数除法，但除数为负数时，会发出这个信号。 |
| 3 | FPE_FLTDIV | 浮点除法错误 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。 |
| 4 | FPE_FLTOVF | 浮点溢出错误 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。 |
| 5 | FPE_FLTUND | 浮点下溢错误 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。 |
| 6 | FPE_FLTRES | 浮点结果未定义错误 | 这个信号表示浮点数除法中的除数为正数的情况。当一个程序尝试进行浮点数除法，但除数为正数时，会发出这个信号。 |
| 7 | FPE_FLTINV | 无效浮点操作错误 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。 |
| 8 | FPE_FLTSUB | 浮点陷阱错误 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。 |
SIGSEGV是一种信号，它表示进程试图访问一个不属于它的内存地址，或者试图访问一个已被操作系统标记为不可访问的内存地址。SIGSEGV信号通常是由以下两种情况引起的：
| 二级分类 | 信号字符串 | 解释 | 触发原因 |
| --- | --- | --- | --- |
| 1 | SEGV_MAPERR | 不存在的内存地址 | 进程试图访问一个不存在的内存地址，或者试图访问一个没有映射到进程地址空间的内存地址。这种情况通常是由于程序中的指针错误或内存泄漏引起的。 |
| 2 | SEGV_ACCERR | 不可访问的内存地址 | 进程试图访问一个已被操作系统标记为不可访问的内存地址，例如只读内存或没有执行权限的内存。这种情况通常是由于程序中的缓冲区溢出或者试图修改只读内存等错误引起的。 |
二级分类(code)除了以上根据信号值(signo)维度分类，还可以根据信号产生的原因维度分类。其中根据信号值(signo)维度分类是每个信号值(signo)特有的，根据信号产生的原因维度分类是所有信号值(signo)共有的，当前已有信号产生原因分类的code值如下：
| 二级分类 | 信号字符串 | 解释 | 触发原因 |
| --- | --- | --- | --- |
| 0 | SI_USER | 用户空间信号 | 该信号是由用户空间的进程发送给另一个进程的，通常是通过 kill() 系统调用发送的。例如，当用户在终端中按下Ctrl+C时，会发送一个SIGINT信号给前台进程组中的所有进程。 |
| 0x80 | SI_KERNEL | 内核信号 | 该信号是由内核发送给进程的，通常是由内核检测到某些错误或异常情况时发出的。例如，当进程访问无效的内存地址或者执行非法指令时，内核会发送一个SIGSEGV信号给进程。 |
| -1 | SI_QUEUE | sigqueue()函数信号 | 该信号是由sigqueue()系统调用发送的，可以携带一个附加的整数值和一个指针。通常用于进程间高级通信，例如传递数据或者通知进程某个事件已经发生。 |
| -2 | SI_TIMER | 定时器信号 | 该信号是由定时器发送的，通常用于定时任务或者周期性任务的执行。例如，当一个定时器到期时，内核会向进程发送一个SIGALRM信号。 |
| -3 | SI_MESGQ | 消息队列信号 | 该信号是由消息队列发送的，通常用于进程间通信。例如，当一个进程向一个消息队列发送消息时，内核会向接收进程发送一个SIGIO信号。 |
| -4 | SI_ASYNCIO | 异步I/O信号 | 该信号是由异步I/O操作发送的，通常用于非阻塞I/O操作。例如，当一个文件描述符上的I/O操作完成时，内核会向进程发送一个SIGIO信号。 |
| -5 | SI_SIGIO | 同步I/O信号 | 该信号是由异步I/O操作发送的，通常用于非阻塞I/O操作。例如，当一个文件描述符上的I/O操作完成时，内核会向进程发送一个SIGIO信号。 |
| -6 | SI_TKILL | tkill()函数信号 | 该信号是由tkill()系统调用发送的，与kill()系统调用类似，但是可以指定发送信号的线程ID。通常用于多线程程序中，向指定线程发送信号。 |
问题定位步骤与思路
崩溃日志获取
进程崩溃日志是一种故障日志，与应用无响应日志、JS应用崩溃等都由FaultLogger模块进行管理，可通过以下方式获取：
-  方式一：通过DevEco Studio获取日志 DevEco Studio会收集设备/data/log/faultlog/faultlogger/路径下的进程崩溃故障日志到FaultLog下，根据进程名和故障和时间分类显示。获取日志的方法参见：DevEco Studio使用指南-FaultLog。
-  方式二：通过hiAppEvent接口订阅 hiAppEvent 提供了故障订阅接口，可以订阅各类故障打点，详见HiAppEvent介绍。
日志格式 - 空指针故障场景
该场景会在日志中打印出提示信息，表明故障很有可能是因为空指针解引用导致
以下是一份DevEco Studio归档在FaultLog的进程崩溃日志的核心内容，与设备/data/log/faultlog/faultlogger下归档的日志内容相同。
日志格式 - 栈溢出故障场景
该场景会在日志中打印出提示信息，表明故障很有可能是因为栈溢出导致。核心日志如下：
日志格式 - 栈覆盖故障场景
在栈覆盖场景下，由于栈上内存被踩，无法成功回溯栈帧，该场景会在日志中打印出提示信息，说明回栈失败并尝试从线程栈里解析获取不可靠的调用栈，尽可能提供开发者信息以分析问题。核心日志如下：
日志格式 - 异步线程场景故障
（目前支持ARM64架构，且在调试应用（HAP_DEBUGGABLE）下开启）
当异步线程发生崩溃后，把提交该异步任务的线程的栈也打印出来，帮助定位由于异步任务提交者造成的崩溃问题。崩溃线程的调用栈和其提交线程的调用栈用SubmitterStacktrace分割开。核心日志如下：
基于崩溃栈定位行号
方式一：DevEco Studio 开发者环境下，支持调用栈直接跳转到对应行号
在应用开发场景，对于应用自身的动态库，生成的cppcrash堆栈可直接跳转到代码行处，支持Native栈帧和JS栈帧，无需开发者自行进行解行号操作。对于部分未能解析跳转到对应行号的栈帧，可参考方式二解析。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170524.36291553504776994130935304405699:50001231000000:2800:1B93C47583FCEA1E141D975AA5B95EF33C75FCB78BB6D87CC3D5E9C9A952455A.png)
方式二：通过SDK llvm-addr2line 工具定位行号
1.  获取符号表 获取崩溃栈中so文件对应的带符号版本，保证与应用/系统内运行时的so文件版本一致。 对于应用自身的动态库，经DevEco编译构建，生成在工程的 /build/default/intermediates/libs 目录下，默认是带符号的版本。可通过Linux file 命令查询二进制文件的 BuildID 以核对是否匹配。其中，BuildID 是用于标识二进制文件的唯一标识符，通常由编译器在编译时生成，not stripped 表示该动态库是包含符号表的。 **说明：**对于系统动态库符号表，随版本进行归档。
2.  通过 llvm-addr2line 工具定位行号 llvm-addr2line 工具归档在：[SDK DIR PATH]\HarmonyOS\11\native\llvm\bin 路径下。根据实际的SDK版本路径略有不同，开发者请自行识别或在路径下搜索。 例如有堆栈如下（有省略）： 基于SDK llvm-addr2line解析行号如下所示： llvm-addr2line 逐行解析的命令为：llvm-addr2line.exe -fCpie libutils.z.so 偏移量，偏移量可以多个一起解：llvm-addr2line.exe -fCpie libxxx.so 0x1bc868 0x1be28c xxx。使用llvm-addr2line后，如果得出的行号看起来不是很正确，可以考虑对 地址进行微调(如减1)，或者考虑关闭一些编译优化。
方式三：通过 DevEco Studio hstack 工具解析堆栈信息
hstack是DevEco Studio为开发人员提供的用于将release应用混淆后的crash堆栈还原为源码对应堆栈的工具，支持Windows、Mac、Linux三个平台。DevEco Studio hstack使用指南
结合业务检视代码
根据基于崩溃栈定位行号章节中介绍的三种方式获取到栈顶对应的行号后，回到代码中，检视上下文。如下图所示，hello.cpp中的48行是一个空指针解引用的代码问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170524.04031280786967797822136604604376:50001231000000:2800:81E1FD2B6F897F4878FD8363D0A9DED1C2ACCC24323461B946D1565720546C69.png)
本场景是一个故障构造的应用，实际的场景往往不会这么简单，需要结合实际业务进行分析。
反汇编（可选）
一般而言，如果是比较明确的问题，反编译定位到代码行就能够定位；较少数的情况，比如定位到某一行里面调用的方法有多个参数，参数又涉及到结构体等，就需要借助反汇编来进一步分析。
参考案例
CPPCRASH日志头部信息如下：
分析步骤：
1.  根据pc寄存器地址找到对应的汇编指令，根据汇编指令找到当前操作 在CPPCRASH日志文件中找到栈顶的PC地址，并反汇编对应的ELF(使用unstrip的so，llvm-objdump -d -l xxx.so)。 例如参考案例在执行00000000000a87e4地址对应的指令时发生data_abort，反编译对应buildId(3c3e7fb27680dc2ee99aa08dd0f81e85)的libc.so, 反汇编查看a87e4偏移地址显示的信息: 根据反汇编显示的源码文件位置175行，查看对应memcpy.S源文件代码:
2.  根据寄存器值，结合上下文推测当前操作的代码对象 通常x0寄存器为函数的第一个参数，x1为第二个参数，x2为第三个，依次类推；如果为类的方法，x0为对象的地址指针，其后x1、x2、x3为依次类推，注意函数参数超过5个会压入堆栈中。 栈顶函数void* memcpy(void* restrict dest, void* restrict src, size_t n)的调用参数，x0为目的地址dest, x1为源地址，x2为拷贝字节数； 在CPPCRASH日志文件中找到对应的三个寄存器值，结合错误访问地址0x0000005b3b46c000，判断出问题的参数为x1对应的src源地址参数:
3.  判断代码对象的故障类型 通过CPPCRASH日志中Memory near registers查看寄存器附近内存地址值: 由上判断是一个读取越界的问题，出问题的参数为memcpy的buf和bufSize， 此时只需要分析代码中调用memcpy时传入的参数逻辑即可。
4.  持续跟踪出问题对象的参数来源，结合代码与流水日志排查问题 排查方向一：排查参数对象的有效性、范围是否合法，例如buf的实际大小是否与传入的bufSize一致； 排查方向二：参数对象的生命周期是否合法，例如buf是否已被释放，是否存在多线程操作被踩内存； 排查方向三：通过参数对象访问函数的上下文，排查参数的不合理操作逻辑，例如跟踪buf和bufsize的操作逻辑，增加调试信息，锁定不合理操作逻辑。 代码片段： 通过持续追踪buf和bufSize的来源，最终来确定buf与bufSize在连续拷贝后不匹配，bufSize最终大于实际buf大小导致越界读取。
CppCrash 常见问题分类与原因
-  空指针解引用 NULL pointer dereference 形如 SIGSEGV(SEGV_MAPERR)@0x00000000 或 cppcrash日志的Register中打印的r0，r1 等传参寄存器的值为0时，应首先考虑调用时是否传入了空指针。 形如 SIGSEGV(SEGV_MAPERR)@0x0000000c 或 cppcrash日志Register中打印的r1 等传参寄存器的值为一个很小的值时应考虑调用入参的结构体成员是否包含空指针。
-  程序主动终止SIGABRT 一般为用户/框架/C库主动触发，大部分场景下跳过C库/abort发起的框架库的第一帧即为崩溃原因，这里主要检测的是资源使用类的问题，如线程创建，文件描述符使用，接口调用时序等。
-  SIGSEGV无效内存访问
-  use after free问题 返回临时变量、野指针：比如返回栈变量的引用，释放后未置空继续访问。
-  栈溢出：如递归调用，析构函数相互调用，特殊的栈(信号栈)中使用大块栈内存。 创建一个 RecursiveClass 对象时，它的构造函数被调用。销毁这个对象时，它的析构函数被调用。在析构函数中，创建了一个新的RecursiveClass对象，这会导致递归调用，直到栈溢出。递归调用导致了无限的函数调用，最终导致栈空间耗尽，程序崩溃。
-  二进制不匹配：通常由ABI（应用程序二进制接口）不匹配引起，如自己编译二进制与实际运行的二进制接口存在差异，数据结构定义存在差异，这种一般会产生随机的崩溃栈。
-  踩内存：使用有效的野指针，并修改了其中的内存为非法值，访问越界，覆盖了正常的数据这种一般会产生随机的崩溃栈。
-  SIGBUS (Aligment)考虑对指针进行强转之后地址是否已经处于非对齐状态。
分析案例
本章节从信号分类、问题场景分类和维测工具分类三个维度来对CppCrash典型问题进行分析和归纳。
信号分类，侧重对常见崩溃信号覆盖介绍，各类信号提供一个典型案例。
问题场景分类，侧重归纳目前高频问题背后的通用场景，各类场景提供一个典型案例。
维测工具分类，侧重总结各类维测工具如果使用类分析相应的问题，各类工具提供一个典型案例。
从信号维度分析问题
类型一：SIGSEGV类崩溃问题
SIGSEGV信号伴随着程序发生段错误（Segmentation Fault）故障，其故障场景为当程序试图访问不被允许访问的内存区域（比如，尝试写一块属于操作系统的内存），或以错误的类型访问内存区域（比如，尝试写一块只读内存）。概括有如下几点：
SIGSEGV在很多时候是由于指针越界引起的，但并不是所有的指针越界都会引发SIGSEGV。如果不解引用越界指针，是不会引起SIGSEGV崩溃的。而且即使解引用了一个越界的指针，也不一定会引起SIGSEGV。SIGSEGV涉及到操作系统、C库、编译器、链接器各方面的内容，以如下具体的例子来说明。
1.  错误的访问类型 样例代码如下： 这是最常见的一个例子。此例中，"hello world" 作为一个常量字符串，在编译后会被放在 .rodata 节（GCC），最后链接生成目标程序时 .rodata 节会被合并到 text segment 与代码段放在一起，故其所处内存区域是只读的。这就是错误的访问类型引起的 SIGSEGV(SEGV_ACCERR) 崩溃。
2.  访问不属于进程地址空间的内存 样例代码如下： 在这个例子中，我们访问了一个属于内核的地址。当然很少会有人这样写程序，但程序可能在不经意的情况下做出这样的行为，产生SIGSEGV(SEGV_MAPERR)@0xffffffcfc42ae6f4的崩溃。本例中的CppCrash故障日志（仅展示核心日志内容）如下：
3.  访问不存在的内存 样例代码如下： 在实际情况中，此例中的空指针可能指向用户态地址空间，但其所指向的页面实际不存在，便是最常见的空指针解引用的场景，这类场景CppCrash日志会识别出来，并在Reason字段打印推断信息 Reason:Signal:SIGSEGV(SEGV_MAPERR)@000000000000000000  probably caused by NULL pointer dereference，如下图所示：
4.  重复free 样例代码如下： 重复释放内存的场景，系统会抛出 SIGSEGV(SI_TKILL) 类故障提示为非法的内存操作，如下图所示： 以上是 SIGSEGV 类崩溃比较常见的原因，除此之外还有栈溢出内存访问、堆溢出内存访问、访问全局区野指针、函数跳转到一个非法的地址上执行，以及非法的系统调用参数等一些场景都有可能触发 SIGSEGV 。SIGSEGV和操作系统栈分配回收、编译器有着密切的联系。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170524.80981659357092442316191220315555:50001231000000:2800:4EBF93788E8626934F6CFBADC9F57D5ADD06E51F0E9A1C5B7EAE88471B5C5873.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170524.26364019326977598450444857407923:50001231000000:2800:A8B444E98F80A20BB0DEC9AC61A634A61D3EEA8A06F688F80D95085BE892B1D2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170524.52787369363507095312458475454980:50001231000000:2800:969D510FFB522DC8BC8834DE169AC00A3DE01277F5DE9F7450DCCCDCE9CEBA93.png)
类型二：SIGABRT类崩溃问题
SIGABRT信号被发送到进程，告诉进程中止。既可以进程自己调用C标准库的abort()函数，信号通常由进程本身发起，也可以跟其他信号一样从外部发送给进程。
1.  执行abort函数 样例代码如下： 该场景是主动调用 abort() 函数构造，对应的场景是各基础库可能会存在一些安全校验，对于识别为会导致进程无法安全运行性的场景，会主动 abort。对应如下场景如下图所示，会将进程退出前的最后一条fatal级别日志打印到崩溃日志中。
2.  执行assert函数 样例代码如下： 除了调用 abort() 函数外，C++中的另一个异常处理机制还包括 assert() 函数，其他的还有 exit() 函数，异常捕获机制（try-catch）、exception类等。assert用于校验当前函数执行流程中的一些数据，校验失败进程会主动 abort。对应的故障场景如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170524.30703046680465956127891445647907:50001231000000:2800:11B696A5C74F2A2239CC37193D45E512FB3F9F7D1BB6CFF548A416AECF795A88.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170524.87406991131769538178304639688953:50001231000000:2800:70F01BD1978E25D6DE1DC5FFCA9CC853702F449CD904981416C5D3368BFAAAB0.png)
从场景维度分析问题
类型一：内存访问类崩溃问题
问题背景
每次崩溃地址0x7f82764b70都在libace_napi_ark.z.so的可读可执行段上。崩溃原因是需要对地址进行写操作，而对应的maps段只有可读、可执行权限没有写权限，当进程试图访问不被允许访问的内存区域时，进程发生内存访问类崩溃。
崩溃调用栈如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170524.64205886406893747219168299077570:50001231000000:2800:6B61BAD31F93ABCBA123D2BFD79FCBEB3CF155F397FB42F0BD6C04664299AD84.png)
定位思路
每次地址出错都很有规律，但node地址不应该落在libace_napi_ark.z.so，从此类问题的现象来看，很有可能是踩内存问题。踩内存问题可使用ASAN工具排查问题。于是后续使用ASAN版本进行压测复现，也找到了稳定必现的场景。ASAN版本检测出来的问题也和上面崩溃栈反映的问题一致。堆栈报的是heap-use-after-free，实际上是对同一个address进行重复释放，只是在重复释放那次操作时，使用该地址去访问了其对象成员，进而报出了UAF问题。
ASAN核心日志如下：
根据堆栈继续分析，
JsiWeak析构或重置的时候会触发其成员(类型为JsiObject/JsiValue/JsiFunction)父类JsiType中CopyableGlobal被释放，如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170525.48390022521532629538637397686124:50001231000000:2800:C76D810E1158B842C05C8253790388B3E065BC08BC1764A59CAC409FBEED847B.png)
运行时在GC过程中IterateWeakEcmaGlobalStorage，会对无callback的WeakNode调用DisposeGlobalHandle操作，也对其进行释放，如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170525.66419783345694326550325097185530:50001231000000:2800:52B761C7BC66FC8380AC0A88B65E9EE816FD244FBC0B9697B39F493D61FC1431.png)
因此，对于同一个WeakNode，可能会存在两个入口释放。如果是GC过程中IterateWeakEcmaGlobalStorage先释放，因为无callback回调通知到JsiWeak进行清理，JsiWeak那边仍保存一个对已释放的WeakNode引用，即CopyableGlobal；当前面讲的WeakNode所在的NodeList被整体释放，归还给操作系统后，JsiWeak处保留的CopyableGlobal再释放，就会存在double-free问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170525.45658201908695229588731524010073:50001231000000:2800:8814B7DDDEE71AC6C19DF84778F18E17CD1DC319223826AD4A14528C1BC1337A.png)
修改方法
JsiWeak调用SetWeakCallback，传入callback，在GC过程中IterateWeakEcmaGlobalStorage释放WeakNode时，通知JsiWeak对其保存的CopyableGlobal进行重置，确保同一个地址不被double-free。
建议与总结
使用内存时应考虑是否存在重复释放或者未释放的可能，另外定位内存访问类崩溃问题（一般是SIGSEGV类型问题）时，如果根据崩溃栈分析问题无头绪时，应优先考虑跑ASAN版本复现问题。
类型二：多线程类问题
问题背景
napi_env释放后仍被使用。
问题场景
napi接口的env传入非法，崩溃栈直接挂在NativeEngineInterface::ClearLastError()中，根据日志打印env地址定位，发现是env被释放后仍然被使用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170525.53520362287145402476543143064377:50001231000000:2800:0776C4F701FE6588318E92579B1E582713C64E8C3504770C57C2D3A6809D727D.png)
核心崩溃栈如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170525.01344546799364935999422181083242:50001231000000:2800:2A2CAEED45CC8EA105D74C92CBB0208E8F77D5C73DFD556CF4278744231BE8BB.png)
修改方法
一个线程的创建的env，不要传给另一个线程使用。
建议与总结
对于多线程类问题可以打开方舟多线程检测功能，能够更加方便定位问题，见工具类方舟多线程检测章节。
注：napi接口中的env，是引擎创建时候的arkNativeEngine。
类型三：生命周期类问题
问题背景
开发者在写native代码创建napi_value时，需要配合napi_handle_scope一起使用。napi_handle_scope的作用是管理napi_value的生命周期，napi_value只能在napi_handle_scope的作用域范围内进行使用，离开napi_handle_scope作用域范围后，napi_value及它所持有的js对象的生命周期不再得到保护，一旦引用计数为0，就会被GC回收掉，此时再去使用napi_value就会访问已释放的内存，产生问题。
问题场景
napi_value其实是个裸指针（结构体指针），其作用是持有js对象，用于保持js对象的生命周期，保证js对象不被GC当成垃圾对象回收。napi_handle_scope用来管理napi_value，离开napi_handle_scope作用域之后，napi_value由GC回收，napi_value不再持有js对象（不再保护js对象生命周期）。
定位思路
根据崩溃栈反编译找到出现问题的napi接口的上层接口，在上层接口内找到出问题的napi_value，检查napi_value的使用范围是否超出了napi_handle_scope的作用域范围。
案例
napi_value超出NAPI框架的scope，如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170525.45560445515329873052064448738480:50001231000000:2800:3ECD48481683B7DD00287491CA3A1E73551F022B9DC3B2DE16FDA66451A09CD6.png)
js侧通过Add接口添加数据，native侧以napi_value保存到vector，js侧通过get接口获取添加的数据，native侧将保存的napi_value以数组形式返回回去，然后js侧读取数据的属性。出现报错：Can not get Prototype on non ECMA Object。跨napi的native_value未使用napi_ref保存，导致native_value失效。
注：NAPI框架的scope即napi_handle_scope，napi开发者可以通过napi_handle_scope来管理napi_value的生命周期。框架层的scope嵌入在js call native的端到端流程中，即进入开发者自己写的native方法前open scope，native方法结束后close scope。
类型四：指针类问题
问题背景
智能指针使用之前未判空，造成进程运行时发生空指针解引用崩溃问题。
问题影响
进程发生崩溃，影响进程的稳定运行，非预期退出。
定位思路
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170525.70109950391320012732060493154000:50001231000000:2800:E1CCA6403ABD58CFE842BEF79E9C27F736521F97EA8E9D011D7753467536910A.png)
空指针类型崩溃可以从故障原因得到提示信息。通过llvm-addr2line解行号发现业务代码中在使用智能指针之前未对智能指针判空，对空地址进行访问导致崩溃产生。
修复方法
对所有使用该指针的地方进行保护性判空。
建议与总结
指针在使用之前应该要进行判空处理，防止访问空指针造成进程崩溃退出。
配合工具分析问题
工具一：ASAN
ASAN使用指南
工具二：方舟多线程检测
基本原理
js是单线程的，操作js对象只允许发生在创建该js线程上，否则将会有多线程安全问题（主线程创建的js对象只能在主线程上操作，worker创建的js对象只能在worker线程上操作）。napi接口会直接涉及到对象的操作，因此绝大部分（95%）的napi接口只允许在js线程上使用。多线程检测机制检测的是：当前线程和使用的vm/env中的js thread id是否一致，若不一致，则表明vm/env被跨线程使用，存在多线程安全问题。常见问题有：1. 非js线程使用napi接口，2. napi接口使用其他线程的env。
使用方法
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170525.63660823510645973184455029887418:50001231000000:2800:C02E69682EDFDF4F4CE99C8597AE9FFC6A74A66A80F370D9E66F3E8ED2AC3172.png)
DevEco勾选Multi Thread Check选项即可开启方舟多线程检测功能。
使用场景
如果crash日志的堆栈难以分析，出现概率也相对比较高，对于此类问题，应该考虑开启多线程检测。 开启多线程检测之后，如果cpp_crash日志中fatal信息为Fatal: ecma_vm cannot run in multi-thread! thread:3096 currentThread:3550，则发生了多线程安全问题，意思是当前线程号为3550，而使用的js thread却是3096线程创建出来的，跨线程使用vm。
案例
打开后重新触发崩溃，如果是多线程问题，会显示fatal 信息，参考如下:
该信息意思是当前线程号为17585，而使用的 js thread 却是17688 线程创建出来的，跨线程使用 vm。vm 就是 js thread 的 napi_env__* ，运行线程代码的环境，一个线程使用一个 vm。
崩溃日志核心部分如下所示：
多线程问题分析步骤：
i. 检查 libace_napi.z.so 下面的第一个栈帧，上图为xxxxx.so，判断是否把 17688 线程的 napi_env 传给了 17585 线程；
ii. 如果 libace_napi.z.so 下面的栈帧没有明显的 napi_env 参数传递，需要检查是否以结构体成员变量的方式传递；
工具三：objdump
使用方法
objdump二进制是系统侧工具，开发者需要具备HarmonyOS编译环境，项目代码在gitee上可获取，命令如下：
工具在工程目录下prebuilts/clang/ohos/linux-x86_64/llvm/bin/llvm-objdump，命令如下：
使用场景
有些情况下，通过addr2line只能看出代码某一行有问题，无法确认具体是哪个变量异常，此时可以通过objdump反汇编并结合cppcrash寄存器内容，进一步确认具体崩溃原因。
案例
日志内容如下：
首先先用addr2line查看出错的行，如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170525.43575772223922213379499941451476:50001231000000:2800:BB1FC6D592490352544AEA817A74C083B3FDF4CA8D1A6ECC0B7133FCF8F69F7D.png)
能看出的信息是判断IsYongSpace的时候访问到了空指针挂了，能够大概猜测出来是Region是空指针。
继续使用objdump反汇编，搜索出错地址4492d4 , 对应的汇编指令如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170525.82142229478912163426562218074582:50001231000000:2800:9D1390BA2467D79907B98625A747EEA1A6102618B11956C5DAE10E478CD135F3.png)
查看x20寄存器，发现为0x000000000000000，x20从上面可以看出是基于x2做位运算(清除掉后18位，典型的Region::ObjectAddressToRange操作)。这样分析之后，就清楚了，x2为MarkObject函数的第二个参数object，x20为变量objectRegion，如下：
上面ldrb w8, [x20]对应 packedData_.flags_.spaceFlag_ 是因为，packedData_是region的第一个域，flags_是packedData_的第一个域，spaceFlag_是flags_的第一个域，所以直接取objectRegion地址对应的第一个字节。
查看汇编代码需要熟悉常见的汇编指令，以及传参规则，例如对于c++非inline的成员函数r0一般保存的是this指针。另外，由于编译器优化，源码和汇编代码对应关系可能不是很直观，我们可以根据代码中的一些特征值(常量)，较快地找到对应关系。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/appfreeze-guidelines-V14
爬取时间: 2025-04-28 19:20:51
来源: Huawei Developer
用户在使用应用时会出现点击没反应、应用无响应等情况，其超过一定时间限制后即被定义为应用无响应(appfreeze)。系统提供了检测应用无响应的机制，并生成appfreeze日志供应用开发分析。
本文仅适用于Stage模型下的应用使用。且在根据本文分析日志前，需要开发者对JS在系统中运行情况、C++程序堆栈信息有相关基础知识，并对应用相关的子系统有一定了解。
应用无响应检测能力点
目前应用无响应检测从以下维度检测，应用开发者了解其原理对定位和分析appfreeze故障非常有帮助。
| 故障类型 | 说明 |
| --- | --- |
| THREAD_BLOCK_6S | 应用主线程卡死超时 |
| APP_INPUT_BLOCK | 用户输入响应超时 |
| LIFECYCLE_TIMEOUT | Ability生命周期切换超时 |
THREAD_BLOCK_6S 应用主线程卡死超时
该故障出现表示当前应用主线程有卡死或者执行任务过多的情况，影响任务执行的流畅度和体验。
该事件的检测原理是：应用的watchdog线程定期向主线程插入判活检测，并在自己线程插入超时上报机制。当判活检测超过3s没有被执行，会上报THREAD_BLOCK_3S警告事件；超过6s依然没有被执行，会上报THREAD_BLOCK_6S主线程卡死事件。两个事件匹配生成THREAD_BLOCK的应用无响应日志。
检测原理如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170525.92908254886726992570663865178511:50001231000000:2800:B5B4C35B563BD0C7220070EDF2F7E53622DFBEE16DCC08B166CE6B710E92B746.png)
APP_INPUT_BLOCK 用户输入响应超时
该故障是指用户的点击事件超过一定时间限制未得到响应，严重影响当前用户体验。
该事件的检测原理是：用户点击应用的按钮时，输入系统会向应用侧发送点击事件，但超时未收到应用侧的响应反馈回执，则上报该故障。
检测原理如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170525.90294109882199278181516073354615:50001231000000:2800:E87F2A13C049308CA06C4F9FB726C71B4282D5EB0F89479AA80832237B44DD25.png)
生命周期切换超时
生命周期切换超时分为Ability生命周期切换超时和PageAbility生命周期切换超时。
该故障出现在生命周期切换的过程中，影响当前应用内Ability的切换或者不同PageAbility之间的切换。
该事件的检测原理是：通过获取不同生命周期切换的过程，在生命周期切换开始的位置向watchdog线程插入超时任务，在生命周期切换完成之后移除超时任务，固定时间内未成功移除将上报故障。
生命周期切换超时由LIFECYCLE_HALF_TIMEOUT和LIFECYCLE_TIMEOUT两个事件组合而成。LIFECYCLE_HALF_TIMEOUT作为LIFECYCLE_TIMEOUT的警告事件，抓取binder等信息。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170526.69150183754806351870549109057374:50001231000000:2800:8168655092144C1032C451C07FB301BF9ADFC7B8C1A52E71345B120C0CBC98DF.png)
不同的生命周期，超时的时间不一样：
| 生命周期 | 超时时间 |
| --- | --- |
| Load | 10s |
| Terminate | 10s |
| Connect | 3s |
| Disconnect | 0.5s |
| Foreground | 5s |
| Background | 3s |
应用无响应日志分析
应用无响应(appfreeze)故障需要结合应用无响应日志和流水hilog日志一起分析。
当前示例仅提供一个分析方法，请开发者根据具体问题具体分析。
应用无响应日志主要分以下几个模块信息：
日志头部信息
| 字段 | 说明 |
| --- | --- |
| Reason | 应用无响应原因，与应用无响应检测能力点对应 |
| PID | 发生故障时候的pid，可以用于在流水日志中搜索相关进程信息 |
| PACKAGE_NAME | 应用进程包名 |
日志主干通用信息
以上三种日志都包含以下几部分信息，可以通过搜索“主要信息字段”在日志中找到对应的位置：
| 主要信息字段 | 说明 |
| --- | --- |
| EVENTNAME | 应用无响应原因，或者组成卡死检测的不同事件 |
| TIMESTAMP | 发生故障时上报事件的时刻，可以根据应用无响应检测能力点中说明的超时时间，在相应流水日志中缩小查看日志的时间范围 |
| PID | 发生故障时候的pid，可以与发生时间和超时时间配合用于在流水日志中搜索相关进程信息 |
| PACKAGE_NAME | 应用进程包名 |
| MSG | 发生故障时dump信息或者说明信息，后面具体说明 |
| BinderCatcher | 进程与其他系统进程间通信的调用信息，显示调用等待时间长的情况 |
| PeerBinder Stacktrace | 当前进程相关的对端进程有卡死，会抓取对端的进程堆栈 |
| cpuusage | 当前时间段整机CPU使用情况 |
| memory | 当前时间当前进程的内存使用情况 |
在整机高负载的情况下，采用低开销方式获取调用栈或抓栈超时的情况，可能损失函数符号和build-id信息。
MSG字段信息主要包括卡死上报的原因，以及当前应用主线程的队列中任务堆积信息。
主线程队列中任务堆积信息包括：
-  当前正在运行的任务以及任务启动的时间：如果跟当前日志上报的时间相差很大，则当前运行的任务就是卡死的主要任务事件。
-  历史任务时间：可判断是否由于历史任务过多且每一个任务执行都占一定时间，导致当前的新任务运行时无法及时响应。
-  堆积中还没有执行的任务。
当前进程堆栈示例：
通过搜索pid对应的数字找到应用栈信息。以下堆栈示例表明窗口通过IPC向系统发送事件时，停留在IPC通信阶段。
```shell
OpenStacktraceCatcher -pid==1561 packageName is com.example.myapplication
Result: 0 ( no error )
Timestamp:2017-08-0817:06:53.000
Pid:1561
Uid:20010039
Process name:com.example.myapplication
Tid:1561,Name:i.myapplication
#00 pc 0017888c /system/lib/libark_jsruntime.so
#01 pc 00025779 /system/lib/platformsdk/libipc_core.z.so(OHOS:BinderConnector:WriteBinder(unsigned Long,void*)+56)
#02 pc 000265a5 /system/lib/platformsdk/libipc_core.z.so(OHOS:BinderInvoker:TransactWithDriver(bool)+216)
#03 pc 0002666f /system/lib/platformsdk/libipc_core.z.so(OHOS:BinderInvoker:StartWorkLoop()+18)
#04 pc 000270a9 /system/lib/platformsdk/libipc_core.z.so(OHOS:BinderInvoker:JoinThread(bool)+32)
#05 pc 00023783 /system/lib/platformsdk/libipc_core.z.so(OHOS:IPCWorkThread:ThreadHandler(void*)+290)
#06 pc 00e1c6f7 /system/lib/libace.z.so
#07 pc 0091bbdd /system/lib/libace.z.so
#08 pc 0092fd9d /system/lib/libace.z.so
#09 pc 0092fa5f /system/lib/libace.z.so
#10 pc 0092cd6b /system/lib/libace.z.so
#11 pc 009326a9 /system/lib/libace.z.so
#12 pc 0093054b /system/lib/libace.z.so
#13 pc 009324f3 /system/lib/libace.z.so
#14 pc 003989e1 /system/lib/libace.z.so
#15 pc 0045dd4b /system/lib/libace.z.so
#16 pc 00d24fef /system/lib/libace.z.so
#17 pc 0041e6e9 /system/lib/libace.z.so
#18 pc 0000b4d9 /system/lib/platformsdk/libeventhandler.z.so(OHOS:AppExecFwk:EventHandler:DistributeEvent(std::__h:unique_ptr<0 #19 pc 00012829 /system/lib/platformsdk/libeventhandler.z.so))
#20 pc 00011841 /system/lib/platformsdk/libeventhandler.z.so(OHOS:AppExecFwk:EventRunner:Run()+64)
#21 pc 00054a8b /system/lib/libappkit_native.z.so(OHOS:AppExecFwk:MainThread:Start()+278)
#22 pc 00011503 /system/bin/appspawn
#23 pc 0001141f /system/bin/appspawn
#24 pc 0000ee97 /system/bin/appspawn
```
BinderCatcher信息示例：
通过搜索pid对应的数字找到当前进程与哪个进程在通信，同步的通信等待的时长。
示例表明当前1561进程向685进程请求通信，等待超过10s没有得到响应。
PeerBinder Stacktrace信息示例：
示例表明对端卡死进程685的堆栈信息。
cpuusage信息示例：
整机CPU信息。
memory信息示例：
当前进程内存信息。
日志主干特异性信息(应用主线程卡死超时)
Reason是THREAD_BLOCK_6S的日志。根据前面的应用主线程卡死超时的原理可知，THREAD_BLOCK由THREAD_BLOCK_3S和THREAD_BLOCK_6S两部分组成。将两部分日志对比分析，可更准确的判断是卡死还是执行任务过多造成无法响应的情况。
THREAD_BLOCK_3S在日志的前部分，THREAD_BLOCK_6S在THREAD_BLOCK_3S后面写入。可以通过EVENTNAME字段搜索两个事件在日志中的位置。
两个事件中都包含MSG字段，该字段在应用主线程卡死超时故障中写入了当前主线程处理队列的信息，可查看在两个时间点中主线程事件处理队列排队情况。
示例日志显示了在Low priority的队列中05:06:18.145的事件一直在处理，THREAD_BLOCK_3S和THREAD_BLOCK_6S的队列都显示其存在。这说明主线程卡死不是任务过多情况。
由于THREAD_BLOCK_6S是主线程卡死，进程堆栈信息只需要关注主线程的堆栈(主线程线程号跟进程号相同)。当前示例日志主线程堆栈显示通过ArkUI控件到JS运行，说明卡死在Js代码中。3S和6S都是这个位置的堆栈，说明JS有卡死，但原因排除任务过多导致。
THREAD_BLOCK_3S：
THREAD_BLOCK_6S：
再结合流水日志查看当前应用侧是在执行哪块代码。
一般情况下可以查看以上通用日志信息内容，判断是否存在对端通信卡死，整机CPU消耗很高导致当前应用响应不过来，内存泄漏，内存非常多导致任务无法运行的情况。
日志主干特异性信息(用户输入响应超时)
Reason是APP_INPUT_BLOCK，表明用户点击事件超过5s没有得到反馈。
MSG信息是这个事件的说明：用户的输入没有得到响应。
APP_INPUT_BLOCK的日志信息可以参考通用日志信息进行分析。需特别说明的是，一般情况下用户输入无响应大概率主线程也会卡死。可以结合两个日志的三个堆栈、两个BinderCatcher信息，进行对比查看。如果没有主线程卡死的日志，说明有可能在输入事件之前有大量的细碎的其他事件，细碎的事件不足以卡死主线程，但是数量比较多导致用户的输入事件响应不过来。
日志主干特异性信息(生命周期切换超时)
Reason是LIFECYCLE_TIMEOUT的日志与上文THREAD_BLOCK_6S和THREAD_BLOCK_3S一样都是有两个事件。分别是LIFECYCLE_HALF_TIMEOUT和LIFECYCLE_TIMEOUT。
MSG说明当前是什么生命周期的超时。
示例可以看出，LIFECYCLE_TIMEOUT的可以看出Ability在切换后台的时候超时，可以按照上面生命周期切换超时的超时时间来找流水日志等信息。
LIFECYCLE_TIMEOUT：
其他的日志信息可以参考通用日志信息进行分析。需要特别说明的是，一般情况下生命周期切换大概率主线程也会卡死。可以结合两个日志的三个堆栈、两个BinderCatcher信息，进行对比查看。
应用退出
当应用发生以下故障时，为了保证可恢复，会杀死应用。
| 故障类型 | 说明 |
| --- | --- |
| THREAD_BLOCK_6S | 应用主线程卡死超时 |
| APP_INPUT_BLOCK | 用户输入响应超时 |
| LIFECYCLE_TIMEOUT | Ability生命周期切换超时 |
定位步骤与思路
定位应用无响应问题，首先需要开发者获取相关日志，再通过日志记录的问题基本信息，结合hilog日志和trace来定位出无响应问题的发生的具体位置。
获取日志
应用无响应日志是一种故障日志，与Native进程崩溃、JS应用崩溃、系统进程异常等都由FaultLog模块管理，可通过以下方式获取日志：
-  方式一：通过DevEco Studio获取日志 DevEco Studio会收集设备的故障日志并归档到FaultLog下。具体可参考[DevEco Studio使用指南-FaultLog](DevEco Studio使用指南-FaultLog](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ide-fault-log-V5)。
-  方式二：通过hiAppEvent接口订阅 hiAppEvent 提供了故障订阅接口，可以订阅各类故障打点，详见HiAppEvent介绍。
确认基本信息
获取直接卡死应用的进程号，是否处于前台等基础信息
获取故障发生时间点
故障上报时间点。
不同故障类型的不同场景下的检测时长汇总表格。
| THREAD_BLOCK_6S | APP_INPUT_BLOCK | LIFECYCLE_TIMEOUT |
| --- | --- | --- |
| 前台应用：6s 后台应用 ：3s * 5 + 6s = 21s | 5s | Load：10s Active：5s Inactive：0.5s Terminate：10s Connect：3s Disconnect：0.5s Restart：5s Foreground：5s Background：3s |
前台应用：6s
后台应用 ：3s * 5 + 6s = 21s
Load：10s
Active：5s
Inactive：0.5s
Terminate：10s
Connect：3s
Disconnect：0.5s
Restart：5s
Foreground：5s
Background：3s
说明：
1、THREAD_BLOCK_3S / LIFECYCLE_HALF_TIMEOUT 的检测时长是相应THREAD_BLOCK_6S / LIFECYCLE_TIMEOUT的一半，warning 级别，不会单独上报日志；THREAD_BLOCK_6S / LIFECYCLE_TIMEOUT 是 error 级别，整合了本身和其一半检测时长故障的日志一同上报；
2、前台应用发生THREAD_BLOCK_3S后即可触发后续THREAD_BLOCK_6S事件；
3、后台应用存在计数器 backgroundReportCount_ = 0，发生THREAD_BLOCK_3S后 +1 累计到 5 次后才会上报 （即连续发生5次 THREAD_BLOCK_3S 事件，计数不清零，才会上报THREAD_BLOCK_6S 事件，可知后台应用THREAD_BLOCK_3S 与THREAD_BLOCK_6S 检测时长依次为 18s 与 21s。
通过故障上报时间点往前推检测时长可得到故障发生的具体时间。
查看 eventHandler 信息
开发者可以通过 “mainHandler dump is” 关键字搜索日志中的 eventHandler dump 信息。
1、dump begin curTime & Current Running
当前任务运行时长 = dump begin curTime - trigger time, 如示例中当前任务运行达到27s。
若任务运行时长 > 故障检测时长，表示当前正在运行的任务是导致应用卡死的任务，需对该任务进行排查。
若任务运行时长较小，表示当前任务仅是检测时间区间内主线程运行的任务之一，主要耗时不一定是该任务，建议优先查看近期耗时最长任务（History event queue information中）。该情形多为线程繁忙导致的watchdog无法调度执行。
2、 History event queue information
可以从历史任务队列中寻找故障发生时间区间内较为耗时的任务。其中CompleteTime time 为空的任务是当前任务。
任务运行耗时 = CompleteTime time - trigger time。
筛选出耗时较高的任务，排查其运行情况。
3、VIP priority event queue information
为保障第一时间响应用户，用户输入事件传递链中的任务都属于高优先级任务。此任务事件队列均由系统创建，通常记录用户输入->屏幕->窗口->ArkUI->应用的传输过程，与三方应用事件无关，开发者无需额外关注。
4、High priority event queue information
watchdog 任务位于此优先级队列中，观察 watchdog 任务队列发现其是每隔 3s 发送一次。
对比 warning/block 事件，观察 watchdog 任务在队列中的移动情况。
warning:
block:
以上示例中可发现 block 队列相比于 warning 队列更长了，而对应的第一个任务没有发生变化，可能存在两种情况：
查看 stack 信息
通过得到的 Pid、Tid 查看对应的 stack，存在以下几种情况：
1、有明确卡死堆栈信息
so 明确等锁卡死，通过反编译获取对应代码行，排查代码上下文解决 bug
2、卡在 ipc 请求
3、warning/error 栈一致，栈顶为业务同步执行代码
warning/error 栈均为：
```shell
Tid:14727, Name:xxx
# 00 pc 00000000001c4c60 /system/lib/ld-musl-aarch64.so.1(pread+72)(b168f10a179cf6050a309242262e6a17)
# 01 pc 0000000000049154 /system/lib64/platformsdk/libsqlite.z.so(unixRead+180)(48485aa23da681fc87d8dc0b4be3e34c)
# 02 pc 0000000000053e98 /system/lib64/platformsdk/libsqlite.z.so(readDbPage+116)(48485aa23da681fc87d8dc0b4be3e34c)
# 03 pc 0000000000053d48 /system/lib64/platformsdk/libsqlite.z.so(getPageNormal+864)(48485aa23da681fc87d8dc0b4be3e34c)
# 04 pc 00000000000757a0 /system/lib64/platformsdk/libsqlite.z.so(getAndInitPage+216)(48485aa23da681fc87d8dc0b4be3e34c)
# 05 pc 0000000000077658 /system/lib64/platformsdk/libsqlite.z.so(moveToLeftmost+164)(48485aa23da681fc87d8dc0b4be3e34c)
# 06 pc 000000000006aa34 /system/lib64/platformsdk/libsqlite.z.so(sqlite3VdbeExec+34532)(48485aa23da681fc87d8dc0b4be3e34c)
# 07 pc 000000000002e424 /system/lib64/platformsdk/libsqlite.z.so(sqlite3_step+644)(48485aa23da681fc87d8dc0b4be3e34c)
# 08 pc 00000000000b1a70 /system/lib64/platformsdk/libnative_rdb.z.so(FillSharedBlockOpt+408)(5e8443def4695e8c791e5f847035ad9f)
# 09 pc 0000000000082a94 /system/lib64/platformsdk/libnative_rdb.z.so(OHOS::NativeRdb::SqliteStatement::FillBlockInfo(OHOS::NativeRdb::SharedBlockInfo*) const+76)(5e8443def4695e8c791e5f847035ad9f)
# 10 pc 00000000000b4214 /system/lib64/platformsdk/libnative_rdb.z.so(OHOS::NativeRdb::SqliteSharedResultSet::ExecuteForSharedBlock(OHOS::AppDataFwk::SharedBlock*, int, int, bool)+236)(5e8443def4695e8c791e5f847035ad9f)
```
结合trace进一步确认，排查调用的单一栈顶函数逻辑是否执行超时。
4、 瞬时栈，warning/error 栈不一致
warning 栈：
error 栈：
此时栈是在线程的运行过程中抓的，没有规律，说明线程未卡死；线程繁忙场景，需结合trace和 hilog 判断应用具体运行场景，针对场景进行优化。
查看 binder 信息
binder信息抓取时机：存在半周期检测的故障类型是在warning事件产生后获取；其他则在block事件后获取。
1、获取binder调用链
以上示例为参考：从故障进程的主线程出发，存在 35854:35854 -> 52462:52462 -> 1386:0 的调用链关系，结合对端进程堆栈信息排查对端阻塞原因。
2、线程号为0
表示该应用为IPC_FULL，即应用的ipc线程都在使用中，没有空闲线程分配来完成本次请求，导致阻塞，如上面示例中的1386进程，可参照其stack分析:
可以看到此时 1386 进程处于 ready 态的线程为 0，验证了上述说法。此情况说明该进程的其他ipc线程可能全部被阻塞了，需要分析排查为什么其他ipc线程不释放。常见场景为：某一ipc线程持锁阻塞，导致其他线程等锁卡死。
另一种情况为 free_async_space 消耗殆尽，导致新的ipc线程没有足够的 buffer 空间完成请求。值得说明的是，同步和异步请求都会消耗该值，常见场景为：某短时间段内大批量异步请求。
3、waitTime过小
waitTime 表示的是本次ipc通信时长，如果该值远小于故障检测时长，我们有理由确认本次ipc请求并不是卡死的根本原因。
一种典型的场景是：应用侧主线程在短时间内多次ipc请求，总请求时长过长导致故障。
排查方向：
- 单次请求是否在预期时长内（例如：规格在20ms的请求接口异常情形下达到1s），排查接口性能不达预期的原因。
- 应用测频繁调用场景是否合理。
4、无调用关系，栈为ipc栈
确定是否为瞬时栈，即warning/block栈是否一致，可能场景是：warning为ipc栈，block栈为其他瞬时栈，表明抓取binder时ipc请求已经结束，本次ipc请求耗时并不长。
需要提到的是：binder信息并不是在发生故障时刻实时获取的，有一定的延迟性；对于存在半周期检测的故障类型来说，binder抓取比较准确，绝大多数都可以在故障时间段内完成采集；而其他故障类型在上报存在延迟的情况下可能抓取到非现场binder。
当然，结合trace分析更能直观查看binder的耗时情况。
结合 hilog
DFX 相关日志
1、故障上报（reportEvent）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170526.25377364197282577982011384167156:50001231000000:2800:EE07C7F5A32AC1218E579D6E0566AE903F8D88705ACCE98C30E602BB98681F64.png)
2、抓栈（signal: 35）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170526.60018738519483308045391837527795:50001231000000:2800:53C31028D959C051E91B0ED23C40B0AC40C10C4F6FEE1088BCFD1C25EC070585.png)
3、后台应用检测（5次后上报），21s 左右
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170526.69223025134594216838618799999571:50001231000000:2800:051C39F5D2485417937C0003925337D9B943BF64423165969112AE6D7A2C3D57.png)
4、记录查杀原因
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170526.71118627913472676173200483736151:50001231000000:2800:9D64C19897ADAE7E9DE0F8BF20EB4EFB55AB7F5DF1A2DA7040B17CB8686F8CC4.png)
5、APPFREEZE kill 卡死应用
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170526.49129935974819039289105164306858:50001231000000:2800:F7EB8058CFC8FF75B5A1D3BEF53BF2B45A79CB87870587CC485AB12A39920FCA.png)
一般分析步骤
根据故障日志确定上报时间点，再根据具体场景下的故障类型推断卡死开始发生的时间点，查看对应时间段的hilog日志，分析日志得出应用对应线程运行状态：
-  应用日志完全无打应输出：卡死在最后日志打印的接口调用处 ... 例如上图案例：APP_INPUT_BLOCK 类型在 07:24:08.167 上报，应用主线程在 07:24:01.581 后就没有打印了，可排查是否为 FormManagerService: [form_mgr_proxy.cpp(GetFormsInfoByApp:1128)] 中的逻辑超时。
-  应用频繁打印输出日志：分析对应输出表示的场景及其合理性 例如上图案例：进程在被 APP_FREEZE 杀死前在大量输出，对应的 ImageEffect 领域需排查此日志是否正常。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170526.59424964532430591353632127539348:50001231000000:2800:AB09DE43F1669B4018D6979900D101017B79A7E6EAC8E15CD2130AF416A3B45A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170526.70180823281268062464126283674048:50001231000000:2800:3F5E397FC6761EC7E4A48814A1C35EF825926A1F30AE09EA0AF7906A3866AB6C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170526.80857852271354308178445258818584:50001231000000:2800:3E26A3E6F7CE88D5E83B70C6BE2DDFB2200BD00669C6E92FEA1F92570FBA6CCC.png)
结合 trace
存在以下可能：
1、进程每一小段业务时间并不长，但是较长时间段运行非常密集，占满了主线程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170526.91670087978774324567903634647104:50001231000000:2800:45404815E94C2D538072699DA13AB9CFC257DEBC8A81C784B1896505D72F7379.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170526.61840218389762015198176335124032:50001231000000:2800:4B5130D9DB70508507E5C55454BD1E0EEC07D8B72A32C84697B545EFB0D6A127.png)
上图案例为：PriviewArea::updateShotComponent（更新组件） -> animator （执行动画）-> 密集的动画执行过程达 9.2s；
线程繁忙地循环执行某业务，分析每一小段业务：
-  不符合业务场景（此处不应该频繁调用），分析业务代码，为何会循环执行；
-  符合业务场景，分析每一小段业务是否耗时超过预期，性能为何不满足设计规格。
2、进程执行某一函数接口超时
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170527.21825260105929015378892946726332:50001231000000:2800:51F137D53827CD5085A2D5AD2E172365F68BD5BB9A3690C7E7D3C4A5216DE864.png)
上图案例为：OHOS::AppExecFwk::FormMgrAdapter::GetFormsInfoByApp 接口执行时长达到 8s。
分析案例
ThreadBlock 类典型案例——未正确使用锁
背景/原理
xxxservice 上报 THREAD_BLOCK_6S 的 appfreeze 问题。
错误代码案例
第4行加锁，第6行函数返回失败后，第6行直接返回未解锁，导致其他线程一直等锁。
影响/报错
后台应用卡死，用户无感知，但是相关功能不可用。
定位思路
提取故障日志关键类别信息。
从 Foreground 值可看出该应用此时处于后台，可推断出当真正的 3s 事件上报上来时，后台应用已卡18s前。
THREAD_BLOCK_3S 上报的时间为 08:24:29:612；
THREAD_BLOCK_6S 上报的时间为 08:24:32:638；相隔 3s 符合预期。
3s 上报时会去抓取此时的 EventHandler 信息，时间为 08:24:29.413，符合预期上报的原因为：App main thread is not response! 主线程无响应，当前正在运行的任务开始时间为 08:24:01.514。
watchdog 任务位于高优先级队列（High priority event queue），如下图可发现：每隔 3s 就会抛一个任务到主线程去，符合预期。
THREAD_BLOCK_3S、THREAD_BLOCK_6S 的队列一致，6s 较 3s 多了一个 event。
最早的一个 event send time 为08:24:11.388，与 3s 上报上来的时间 08:24:29:612 刚好差 18s，符合预期。
以上可总结：应用主线程从 08:24:01.514 开始运行本次任务，第一次 3s 检测开始时间为 08:24:11.388，真正开始卡住的时间在 08:24:11 左右。
查看主线程栈：从 xxx_request_client.so -> libsamgr_proxy.z.so -> libipc_core.z.so(OHOS::BinderConnector::WriteBinder)
可知：此时主线程发起了一个 ipc 请求，对端进程未返回导致卡死，如下堆栈所示。
查看 binderCatcher：此时 43675 的主线程正在与 979 进程通信，抓 binder 时已经卡了 27s。
查看 979 进程主线程栈：xxxserver 在等待锁释放。该问题即为典型的锁使用不当，导致的等锁卡死。
反编译即可确定对应卡锁代码行，结合上下文检测锁的使用。
修改方法
修改为：
结合上下文，合理调整锁的使用。
推荐建议（问题总结）
1、多线程交互时需要格外注意时序、死锁问题。
APP_INPUT_BLOCK 类典型案例——组件全量刷新
背景
用户在切换主题时突然卡死，有 sceneboard 的 appfreeze 问题上报。
该问题为线程繁忙导致卡死。
错误代码实例
对于组件的刷新复用，是通过组件的 key 值来控制的，当页面更新时，若组件的 key 不变，会复用之前的组件；若 key 值变化，会更新组件及其子组件。
该函数用户生成桌面组件的 key，关联有 themeStyle，当用户在桌面连续切换主题时，导致组件反复全量刷新，导致卡死。
```typescript
private getForeachKey(item: xxx): string {
...
return `${item.xxx2}${item.xxx2}...${item.themeStyle}`;
}
```
影响
用户在合一桌面切换主题时页面高概率卡死，点击无响应，而后闪退到锁屏界面。
严重影响用户使用体验。
定位思路
提取故障关键信息。
APP_INPUT_BLOCK 是事件上报的时间为14:40:59:440
上报的原因是：User input does not respond! 用户输入事件没有响应
可以看到当前是在主线程上(Thread ID == Pid)，正在运行的任务从14:40:53.499开始运行，直到 Fault time14:40:58都还没有运行完。
用户输入事件需要第一时间响应，所以同 watchdog 一样都在 High priority event queue。
可以看到此时已经有 200+ 的 input event 在队列中阻塞住没有处理了。
从逻辑来看，input event 触发应用主线程任务开始执行，但是 6s 还没有执行完，没有反馈，导致 ANR 超时；
因此我们只需要关心 input 触发了应用执行什么任务，该任务为什么会执行超时即可。
主线程栈：此时运行时状态，栈顶的 ark_jsruntime GetCurrentThreadId 也不是持锁阻塞或耗时很长函数，抓到的栈为瞬时栈，没有参考意义。
接下来排查流水日志：
首先找到上报 APP_INPUT_BLOCK 的时间点，大概在 13:40:59.448 左右，且从这里我们可以看到在事件上报完后，dfx 将卡死的 scb 杀掉。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170527.85191442761955842823218592973229:50001231000000:2800:909D6BBBEC2BCCDC4588E095F16B145008DAAE9C708C8B3177BEEE00E87BC66E.png)
往前推 6s 左右，可以看到在 14:40:53.498 左右，有一个点击事件发给了 scb。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170527.64356444106913734469494552619661:50001231000000:2800:33291FCD2A15E3026A48421CB85E556519C4268D4DFC1957B4FB209F4C574CBF.png)
在这之间的 6s 存在大量的 scb 日志，判断是在做更新渲染。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170527.32595988890344702309612656671571:50001231000000:2800:D0F506A32C050528378803C9DEB2E43E0DBC3372AE9C352E052CBD33C250ED92.png)
看下对应时间点的 trace：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170527.44332772814310816803137682597390:50001231000000:2800:0C49D89A5D06F8836FAD926EE00515C75FD532C84769967F58361E42D7FC27B2.png)
发现 scb 主线程被占满，确实很繁忙。选择耗时较长的任务，是CustomNodeUpdate SwiperPage，后续就需要排查为啥这个组件里一直在做刷新。
根据对应领域排查后发现：swiperPage上把 themeStyle 加入到了 key 里面，key 变了就会走控件新建流程
即当用户切换主题或者切换图标风格时，会造成桌面上控件的全量新建，导致主线程繁忙，导致输入事件未响应
修改方法
仅当切换桌面组件风格时，才触发桌面组件的刷新，缩小刷新范围。
```typescript
+ if (!CheckEmptyUtils.isEmpty(themeStyleInfo.iconResourcePath) &&
+     themeStyleInfo.iconResourcePath !== this.themeStyle.iconResourcePath) {
+     this.isStyleChanged = true;
+     this.themeStyle.iconResourcePath = themeStyleInfo.iconResourcePath; --> themeStyle 与 iconResourcePath 关联
+ }
```
推荐建议（问题总结）
1、用户点击触发页面更新时，需要合理控制页面刷新的范围，考虑大量组件、频繁刷新等场景。
LIFECYCLE_TIMEOUT 类典型案例——加载云图
背景/原理
用户在打开云笔记时应用卡死后闪退。
错误代码实例
循环中同步获取云图。
```typescript
public static xxxFunction(fileUris: string[]): void {
...
for (const fileuril of fileUrils) {
let file = fs.openSync(fileUri, fs.OpenMode.READ_ONLY);
...
}
...
}
```
影响/报错
应用拉起、切前台等过程中卡死并闪退。
定位思路
以 notepad LIFECYCLE_TIMEOUT 为例，提取故障关键信息：
查看 MSG 信息：foreground timeout，对应时长为 5s。
LIFECYCLE_HALF_TIMEOUT 上报时间为10:04:57:538；
LIFECYCLE_TIMEOUT 上报时间为10:04:59:965；相隔 2.5s 左右，符合预期。
任务开始的时间为10:04:54.798，离 LIFECYCLE_HALF_TIMEOUT 相隔 2.5s 左右，符合预期。
看对应的堆栈信息：libfs.z.so -> libdatashare_consumer.z.so -> libipc_core.z.so
通过 binder 可以看出在与 5235 进程通信，时长大于 2.5s，符合预期。
5235 为媒体库进程，该堆栈无有效信息。
```shell
PeerBinder Stacktrace --
PeerBinderCatcher start catcher stacktrace for pid : 5235
Result: 0 ( no error )
Timestamp:2024-02-01 10:04:57.000
Pid:5235
Uid:20020079
Process name:com.medialibrary.medialibrarydata
Tid:5235, Name:edialibrarydata
# 00 pc 0000000000142d1c /system/lib/ld-musl-aarch64.so.1(epoll_wait+84)(4ca73cff61bea7c4a687eb0f71c9df69)
# 01 pc 000000000000fb74 /system/lib64/chipset-pub-sdk/libeventhandler.z.so(OHOS::AppExecFwk::EpollIoWaiter::WaitFor(std::__h::unique_lock<std::__h::mutex>&, long)+224)(a4d21072c08fd3ac639d5cf5b8fb8b51)
# 02 pc 0000000000019df8 /system/lib64/chipset-pub-sdk/libeventhandler.z.so(OHOS::AppExecFwk::EventQueue::WaitUntilLocked(std::__h::chrono::time_point<std::__h::chrono::steady_clock, std::__h::chrono::duration<long long, std::__h::ratio<1l, 1000000000l>>> const&, std::__h::unique_lock<std::__h::mutex>&)+180)(a4d21072c08fd3ac639d5cf5b8fb8b51)
# 03 pc 0000000000019c6c /system/lib64/chipset-pub-sdk/libeventhandler.z.so(OHOS::AppExecFwk::EventQueue::GetEvent()+128)(a4d21072c08fd3ac639d5cf5b8fb8b51)
# 04 pc 00000000000202b8 /system/lib64/chipset-pub-sdk/libeventhandler.z.so(OHOS::AppExecFwk::(anonymous namespace)::EventRunnerImpl::Run()+1164)(a4d21072c08fd3ac639d5cf5b8fb8b51)
# 05 pc 0000000000022388 /system/lib64/chipset-pub-sdk/libeventhandler.z.so(OHOS::AppExecFwk::EventRunner::Run()+120)(a4d21072c08fd3ac639d5cf5b8fb8b51)
# 06 pc 000000000007ea08 /system/lib64/platformsdk/libappkit_native.z.so(OHOS::AppExecFwk::MainThread::Start()+772)(183fe2babcfdd3e1ea4bca16a0e26a5d)
# 07 pc 0000000000011ac8 /system/bin/appspawn(RunChildProcessor+236)(7b715884c45cfe57b22df46fdaeeca88)
# 08 pc 0000000000034684 /system/bin/appspawn(AppSpawnChild+264)(7b715884c45cfe57b22df46fdaeeca88)
# 09 pc 00000000000344f4 /system/bin/appspawn(AppSpawnProcessMsg+380)(7b715884c45cfe57b22df46fdaeeca88)
# 10 pc 00000000000305a0 /system/bin/appspawn(OnReceiveRequest+1820)(7b715884c45cfe57b22df46fdaeeca88)
# 11 pc 0000000000017c58 /system/lib64/chipset-pub-sdk/libbegetutil.z.so(HandleRecvMsg_+260)(22f33d1b0218f31bad0dcc75cf348b90)
# 12 pc 00000000000178fc /system/lib64/chipset-pub-sdk/libbegetutil.z.so(HandleStreamEvent_+148)(22f33d1b0218f31bad0dcc75cf348b90)
# 13 pc 0000000000015478 /system/lib64/chipset-pub-sdk/libbegetutil.z.so(ProcessEvent+112)(22f33d1b0218f31bad0dcc75cf348b90)
# 14 pc 0000000000015090 /system/lib64/chipset-pub-sdk/libbegetutil.z.so(RunLoop_+308)(22f33d1b0218f31bad0dcc75cf348b90)
# 15 pc 000000000002eff4 /system/bin/appspawn(AppSpawnRun+116)(7b715884c45cfe57b22df46fdaeeca88)
# 16 pc 000000000001f438 /system/bin/appspawn(main+724)(7b715884c45cfe57b22df46fdaeeca88)
# 17 pc 00000000000a0974 /system/lib/ld-musl-aarch64.so.1(libc_start_main_stage2+64)(4ca73cff61bea7c4a687eb0f71c9df69)
# 18 pc 000000000001106c /system/bin/appspawn(_start_c+76)(7b715884c45cfe57b22df46fdaeeca88)
```
以上可以得到信息：应用通过文件系统 Open::Sync 同步通过 uri 加载文件，调用到 datashare 请求媒体库文件数据。
查看对应时间点的流水信息：进程调用 datashare 加载云图后卡死，与堆栈信息吻合。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170527.29224260691792685069746767744892:50001231000000:2800:080429B978C46F54E7D25826DAC2A34F2D983C194358C0B87CB31287C2A10810.png)
查看具体代码：
在循环中同步加载 fileUri ，这种明显是不合理的，当弱网或者同时加载大量数据的条件下，极易出现卡死情况，应用侧需要整改。
修改方法
同步加载改为异步加载，并用标志位来标识是否加载完，用户界面展示加载中效果。
```typescript
public static xxxFunction(fileUris: string[]): void {
...
for (const fileuril of fileUrils) {
let file = fs.openSync(fileUri, fs.OpenMode.READ_ONLY);
...
}
...
}
```
修改为：
```typescript
public static async xxxFunction(fileUris: string[]): void {
...
AppStorage.setOrCreate<boolean>('isLoadingPic', true); --> 用于页面 load 效果展示
for (const fileuril of fileUrils) {
let file = await fs.open(fileUri, fs.OpenMode.READ_ONLY);
...
}
...
}
```
推荐建议（问题总结）
1、请求云侧数据需要验证充分，有网、弱网、无网场景下；
2、不要在应用生命周期函数中做耗时操作。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/resource-leak-guidelines-V14
爬取时间: 2025-04-28 19:21:05
来源: Huawei Developer
资源泄漏是指句柄/线程/内存等资源超过系统设定上限，部分资源甚至失去了管控能力，此时系统可能出现卡死/重启等异常情况。LeakDetector模块提供资源泄漏检测、判决、维测日志抓取、日志上报的能力，为开发者提供详细的维测日志以辅助故障定位。
本文将分别介绍资源泄漏检测能力、泄漏问题定位分析思路，以及具体的案例分析。
资源泄漏检测能力
| 泄漏类型  | 检测机制  |
| --- | --- |
| 句柄泄漏（FD_LEAK）  | 60s一次遍历进程，获取进程fd句柄总数，超过阈值（5000个）时抓取详细句柄信息，同步上报泄漏  |
| 线程泄漏（THREAD_LEAK）  | 60s一次遍历进程，获取进程的总线程数，超过阈值（700个）时抓取详细线程名信息，同步上报泄漏  |
| 内存泄漏（MEMORY_LEAK）  | js泄漏（JS_LEAK）  | 虚拟机内部进行插桩，当heap使用量超过85% 或者 触发OOM时会抓取heapdump，同步上报该故障  |
| native内存泄漏（PSS_MEMORY）  | 以应用进程平均动态峰值内存作为基线，60s一次轮询监控，当动态内存峰值超过基线值2倍，判定泄漏，同时触发管控  |
| ashmem/ion/gpu等内存泄漏 （KERNEL_MEMORY）  | 基于ashmem/ion/gpu的基线值，超过基线值时会判定泄漏，同步抓取维测信息  |
泄漏类型
检测机制
句柄泄漏（FD_LEAK）
60s一次遍历进程，获取进程fd句柄总数，超过阈值（5000个）时抓取详细句柄信息，同步上报泄漏
线程泄漏（THREAD_LEAK）
60s一次遍历进程，获取进程的总线程数，超过阈值（700个）时抓取详细线程名信息，同步上报泄漏
内存泄漏（MEMORY_LEAK）
js泄漏（JS_LEAK）
虚拟机内部进行插桩，当heap使用量超过85%或者触发OOM时会抓取heapdump，同步上报该故障
native内存泄漏（PSS_MEMORY）
以应用进程平均动态峰值内存作为基线，60s一次轮询监控，当动态内存峰值超过基线值2倍，判定泄漏，同时触发管控
ashmem/ion/gpu等内存泄漏 （KERNEL_MEMORY）
基于ashmem/ion/gpu的基线值，超过基线值时会判定泄漏，同步抓取维测信息
以上使用的基线都是默认设置，如果生态在开发过程中需要自行设定基线，可以参考生态通过API接口设置基线文档使用。
日志获取和日志规格
泄漏日志获取
资源泄漏日志由LeakDetector模块进行管理，可通过以下方式获取：
-  DevEco Testing工具会收集设备/data/log/resource_leak/路径下的资源泄漏故障日志，根据进程名、故障和时间分类显示。 泄漏类型 日志文件名称 句柄泄漏（FD_LEAK） [pid]_fd_leak.txt 线程泄漏（THREAD_LEAK） [pid]_thread_leak.txt 内存泄漏（MEMORY_LEAK） js泄漏（JS_LEAK） memleak-js-[process_name]-[pid]-[tid]-[timestamp].rawheap native内存泄漏（PSS_MEMORY） memleak-native-[process_name]-[pid]-sample.txt memleak-native-[process_name]-[pid]-smaps.txt memleak-native-[process_name]-[pid]-[timestamp].txt ashmem/ion/gpu等内存泄漏 （KERNEL_MEMORY） memleak-kernel-[module]-0-sample.txt memleak-kernel-[module]-0-[timestamp].txt
-  DevEco Studio的profiler模块提供Allocation（获取native调用栈profiler）和Snapshot（获取JS层heapdump）两种采集方式：
| 泄漏类型  | 日志文件名称  |
| --- | --- |
| 句柄泄漏（FD_LEAK）  | [pid]_fd_leak.txt  |
| 线程泄漏（THREAD_LEAK）  | [pid]_thread_leak.txt  |
| 内存泄漏（MEMORY_LEAK）  | js泄漏（JS_LEAK）  | memleak-js-[process_name]-[pid]-[tid]-[timestamp].rawheap  |
| native内存泄漏（PSS_MEMORY）  | memleak-native-[process_name]-[pid]-sample.txt memleak-native-[process_name]-[pid]-smaps.txt memleak-native-[process_name]-[pid]-[timestamp].txt  |
| ashmem/ion/gpu等内存泄漏 （KERNEL_MEMORY）  | memleak-kernel-[module]-0-sample.txt memleak-kernel-[module]-0-[timestamp].txt  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170527.98323873924251315842648598346512:50001231000000:2800:058FD47CE6379ECDB71F97AB32354AB51FB0F09E2A599F3E18C29A71A000362B.png)
-  hiAppEvent对外提供了故障订阅接口，可以订阅各类故障打点，详见HiAppEvent介绍，其中资源泄漏的订阅方式详见资源泄漏事件介绍。资源泄漏故障日志存于/data/storage/el2/log/resourcelimit/路径，日志名统一为RESOURCE_OVERLIMIT_[TIMESTAMP]_[PID].log，可根据日志内容区分文件类型。
句柄泄漏日志规格
故障日志文件名：[pid]_fd_leak.txt（方式一） 或 RESOURCE_OVERLIMIT_[TIMESTAMP]_[PID].log（方式三）
日志头部信息
| 字段  | 说明  |
| --- | --- |
| time  | 故障发生时间  |
| pid  | 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息  |
| process  | 应用进程包名  |
| leaked fd nums  | 判定泄漏时获取的句柄数量 （快照）  |
字段
说明
time
故障发生时间
pid
发生故障进程的pid，可以用于在流水日志中搜索相关进程信息
process
应用进程包名
leaked fd nums
判定泄漏时获取的句柄数量 （快照）
句柄类型详细信息
特殊类型句柄维测信息
如果Leaked fd Top 10的 TOP句柄信息属于ashmem/socket/pipe/sync_file/dmabuf 这五类特殊类型，且该类型的句柄个数超过1000个，日志中会增加整机详细的维测信息，具体如下：
-  ashmem（即共享内存），如下，由于TOP 1的句柄类型为ashmem，此时抓取了整机ashmem内存的详细信息，里面每一行都是一个单独的ashmem块。 字段 说明 Process_name 持有该ashmem内存块的应用进程包名 Process_ID 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息 Fd 该进程持有的句柄 Applicant_Pid 申请该ashmem内存块的进程pid，可根据识别这个ashmem的来源 Ashmem_name 共享内存的名字，由用户态通过ioctl设置，用来判断存储的资源类型，指向不同的领域 Size 单个ashmem块的大小（单位：B）
-  socket通信，如下，由于TOP 1的句柄类型为socket，此时抓取了整机socket内存的详细信息。 字段 说明 ProcessName 持有该socket内存块的应用进程包名 ProcessID 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息 Fd 该进程持有的句柄 inode 文件系统对象信息 PeerTid 对端tid（对于有连接的socket，无连接为0）
-  pipe通信，如下，由于TOP 1的句柄类型为pipe，此时以fd维度抓取了整机pipe内存的详细信息。 字段 说明 ProcessName 持有该pipe内存块的应用进程包名 ProcessID 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息 Fd 该进程持有的句柄 PipeName 管道名 inode 文件系统对象信息 MaxUsage 最大使用量 NumAccounted 累计大小量 RingSize RingBuf大小
-  字段 说明 ProcessName 持有该sync_file内存块的应用进程包名 ProcessID 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息 Fd 该进程持有的句柄 FenceName sync_file名字 inode 文件系统对象信息 FenceNum fence个数 TimelineName fence的Timeline名字 DriverName 驱动名字 Status fence的状态 Timestamp fence的时间戳
-  字段 说明 Process name 持有该ion内存块的应用进程包名 Process ID 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息 Fd 该进程持有的句柄 size buffer内存大小（单位：B） magic buffer唯一标识 buf->pid 申请者的pid buf->task_comm 申请buffer的进程名 句柄栈信息 当判定句柄泄漏后，会hook 该进程的pipe/open等系统调用10分钟，抓取调用栈，并基于相同调用栈聚类。如下每一行都是一个调用栈，调用顺序为从右到左，其中num后面的数字表示这个调用栈总共有多少个，bt后面为具体调用栈。具体栈信息可通过addr2line解析到对应的函数。 1、这里统计的是10分钟内全量申请句柄的调用栈，并没有将已经close的去掉。 2、栈信息只有在log版本直接存在，nolog版本若未开“开发者模式”，则不抓取栈信息，如果发现不存在栈信息，可以打开开发者模式抓取。
| 字段  | 说明  |
| --- | --- |
| Process_name  | 持有该ashmem内存块的应用进程包名  |
| Process_ID  | 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息  |
| Fd  | 该进程持有的句柄  |
| Applicant_Pid  | 申请该ashmem内存块的进程pid，可根据识别这个ashmem的来源  |
| Ashmem_name  | 共享内存的名字，由用户态通过ioctl设置，用来判断存储的资源类型，指向不同的领域  |
| Size  | 单个ashmem块的大小（单位：B）  |
| 字段  | 说明  |
| --- | --- |
| ProcessName  | 持有该socket内存块的应用进程包名  |
| ProcessID  | 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息  |
| Fd  | 该进程持有的句柄  |
| inode  | 文件系统对象信息  |
| PeerTid  | 对端tid（对于有连接的socket，无连接为0）  |
| 字段  | 说明  |
| --- | --- |
| ProcessName  | 持有该pipe内存块的应用进程包名  |
| ProcessID  | 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息  |
| Fd  | 该进程持有的句柄  |
| PipeName  | 管道名  |
| inode  | 文件系统对象信息  |
| MaxUsage  | 最大使用量  |
| NumAccounted  | 累计大小量  |
| RingSize  | RingBuf大小  |
| 字段  | 说明  |
| --- | --- |
| ProcessName  | 持有该sync_file内存块的应用进程包名  |
| ProcessID  | 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息  |
| Fd  | 该进程持有的句柄  |
| FenceName  | sync_file名字  |
| inode  | 文件系统对象信息  |
| FenceNum  | fence个数  |
| TimelineName  | fence的Timeline名字  |
| DriverName  | 驱动名字  |
| Status  | fence的状态  |
| Timestamp  | fence的时间戳  |
| 字段  | 说明  |
| --- | --- |
| Process name  | 持有该ion内存块的应用进程包名  |
| Process ID  | 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息  |
| Fd  | 该进程持有的句柄  |
| size  | buffer内存大小（单位：B）  |
| magic  | buffer唯一标识  |
| buf->pid  | 申请者的pid  |
| buf->task_comm  | 申请buffer的进程名  |
线程泄漏日志规格
故障日志文件名：[pid]_thread_leak.txt （方式一） 或 RESOURCE_OVERLIMIT_[TIMESTAMP]_[PID].log（方式三）
日志头部信息
| 字段  | 说明  |
| --- | --- |
| time  | 检测到线程泄漏的时间  |
| pid  | 发生故障进程的pid，用于在流水中查询相关进程信息  |
| vss  | 单个进程全部可访问的地址空间，其大小可能包括还尚未在内存中驻留的部分  |
| rss  | 单个进程实际占用的内存大小，包括该进程所使用共享库全部内存大小。  |
| process  | 发生故障的应用包名  |
| summary  | 判定泄漏时进程线程总数  |
字段
说明
time
检测到线程泄漏的时间
pid
发生故障进程的pid，用于在流水中查询相关进程信息
vss
单个进程全部可访问的地址空间，其大小可能包括还尚未在内存中驻留的部分
rss
单个进程实际占用的内存大小，包括该进程所使用共享库全部内存大小。
process
发生故障的应用包名
summary
判定泄漏时进程线程总数
线程类泄漏详细信息
-  字段 说明 tid 检测到泄漏时未释放线程的线程号 thread_name 未释放的线程名 start_time(jiffies) 线程创建时间
| 字段  | 说明  |
| --- | --- |
| tid  | 检测到泄漏时未释放线程的线程号  |
| thread_name  | 未释放的线程名  |
| start_time(jiffies)  | 线程创建时间  |
内存泄漏日志规格
JS内存泄漏
故障日志文件名：memleak-js-[process_name]-[pid]-[tid]-[timestamp].rawheap（方式一） 或 RESOURCE_OVERLIMIT_[TIMESTAMP]_[PID].log（方式三）
该文件记录了对象的详细信息。rawheap文件使用translator工具转换为heapsnapshot文件后，通过IDE或浏览器打开展示，详情见snapshot解析。
native内存泄漏
故障日志文件名：泄漏日志获取中方式一和方式三文件名不同，方式三为RESOURCE_OVERLIMIT_[TIMESTAMP]_[PID].log，根据内容区分，方式一如下所示：
-  字段 说明 threshold 系统设定的该进程基线（也可由应用自身通过setAppResourceLimit接口设置） PssMemory 记录了realtime时刻采集的PSS值，用于和threshold比较
| 字段  | 说明  |
| --- | --- |
| threshold  | 系统设定的该进程基线（也可由应用自身通过setAppResourceLimit接口设置）  |
| PssMemory  | 记录了realtime时刻采集的PSS值，用于和threshold比较  |
-  字段 说明 threshold 系统设定的该进程基线（也可由应用自身通过setAppResourceLimit接口设置） PssMemory 记录了realtime时刻采集的PSS值，用于和threshold比较 LOGGER_MEMCHECK_MEMINFO 下方记录了整机meminfo内存信息，如MemTotal、MemFree等 LOGGER_MEMCHECK_SMAPS_INFO 下方记录了该进程的smaps汇总信息 LOGGER_MEMCHECK_DETIAL_INFO 下方记录了该进程的jemalloc快照详细信息
| 字段  | 说明  |
| --- | --- |
| threshold  | 系统设定的该进程基线（也可由应用自身通过setAppResourceLimit接口设置）  |
| PssMemory  | 记录了realtime时刻采集的PSS值，用于和threshold比较  |
| LOGGER_MEMCHECK_MEMINFO  | 下方记录了整机meminfo内存信息，如MemTotal、MemFree等  |
| LOGGER_MEMCHECK_SMAPS_INFO  | 下方记录了该进程的smaps汇总信息  |
| LOGGER_MEMCHECK_DETIAL_INFO  | 下方记录了该进程的jemalloc快照详细信息  |
-  注意：系统自动抓的调用栈（memleak-native-[process_name]-[pid]-[timestamp].txt）无法直接在IDE打开，需要修改后缀名为.nas。在不同操作系统中，修改文件后缀名（文件扩展名）的方式存在差异，具体请参考相应操作系统的操作指导。 点击Call Trees可以看到抓取进程的调用栈，筛选“Created & Existing”，根据没有释放的内存占比排序，展开可查看详细进程调用信息，优先排查内存占用较高的堆栈。 部分栈单看Existing可能感觉泄漏不大或者和检测到的内存峰值相差很多，但是栈里只是抓取的15分钟内的堆栈信息和内存申请，很多进程泄漏是以几十甚至几百小时为单位的，长时间的泄漏达到上报时的泄漏大小。 同样选择“Created & Existing”，表示在hook抓取内存申请未释放的。长度越长代表在剩余内存中占用越多，优先排查。
-  注意：系统自动抓的调用栈（memleak-native-[process_name]-[pid]-[timestamp].txt）无法直接在IDE打开，需要修改后缀名为.nas。在不同操作系统中，修改文件后缀名（文件扩展名）的方式存在差异，具体请参考相应操作系统的操作指导。
-  点击Call Trees可以看到抓取进程的调用栈，筛选“Created & Existing”，根据没有释放的内存占比排序，展开可查看详细进程调用信息，优先排查内存占用较高的堆栈。 部分栈单看Existing可能感觉泄漏不大或者和检测到的内存峰值相差很多，但是栈里只是抓取的15分钟内的堆栈信息和内存申请，很多进程泄漏是以几十甚至几百小时为单位的，长时间的泄漏达到上报时的泄漏大小。
-  同样选择“Created & Existing”，表示在hook抓取内存申请未释放的。长度越长代表在剩余内存中占用越多，优先排查。
-  注意：系统自动抓的调用栈（memleak-native-[process_name]-[pid]-[timestamp].txt）无法直接在IDE打开，需要修改后缀名为.nas。在不同操作系统中，修改文件后缀名（文件扩展名）的方式存在差异，具体请参考相应操作系统的操作指导。
-  点击Call Trees可以看到抓取进程的调用栈，筛选“Created & Existing”，根据没有释放的内存占比排序，展开可查看详细进程调用信息，优先排查内存占用较高的堆栈。 部分栈单看Existing可能感觉泄漏不大或者和检测到的内存峰值相差很多，但是栈里只是抓取的15分钟内的堆栈信息和内存申请，很多进程泄漏是以几十甚至几百小时为单位的，长时间的泄漏达到上报时的泄漏大小。
-  同样选择“Created & Existing”，表示在hook抓取内存申请未释放的。长度越长代表在剩余内存中占用越多，优先排查。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170527.28075451746761582917312754378084:50001231000000:2800:134ED3EC9A09EE06EACFB2E1B85F21C0C6831E6B45D853C2C4C69CCF5442EE1E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170527.54741221786489560325373253984976:50001231000000:2800:A458E1B771E5CF664E67A5225E811821F280CBDC5623D5A4397A4A9F76BFE493.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.67134060774013776646054689951465:50001231000000:2800:EDE5D60CE53FB4B8873DB2199FACE8979560B4CCD2F0D990931B0257C5B42E77.png)
ashmem/gpu/ion内存泄漏
-  字段 说明 memoryName 内核内存类型（ashmem/gpu/ion） softThreshold 设定的软门限（超过8个采样周期，即30+分钟超过软门限后判定泄漏） hardThreshold 设定的硬门限（单次超过硬门限后判定泄漏） topMemory 检测到的内核内存峰值 time(s) 采样kernel内存的时间 kernelMemory(KB) 抓取的内核内存峰值 realtime 抓取该内存峰值的时间点
| 字段  | 说明  |
| --- | --- |
| memoryName  | 内核内存类型（ashmem/gpu/ion）  |
| softThreshold  | 设定的软门限（超过8个采样周期，即30+分钟超过软门限后判定泄漏）  |
| hardThreshold  | 设定的硬门限（单次超过硬门限后判定泄漏）  |
| topMemory  | 检测到的内核内存峰值  |
| time(s)  | 采样kernel内存的时间  |
| kernelMemory(KB)  | 抓取的内核内存峰值  |
| realtime  | 抓取该内存峰值的时间点  |
-  检测到ashmem/gpu/ion内存泄漏时，会抓取整机ashmem/gpu/ion内存信息，ashmem/ion与句柄泄漏ashmem/dmabuf日志规格相同，参考ashmem/dmabuf类型句柄，gpu内存规格信息如下： 一个ctx为一个进程，根据used summary识别哪个进程占用最大进行分析，然后进一步分析channel(按照单个对象大小排序)确定是否存在泄漏，如下4 / 160 表示有4个对象，总大小160B，即单个对象大小40B。
问题定位步骤与思路
句柄泄漏问题分析方法
案例一：
某应用上报句柄泄漏，/data/storage/el1/bundle/entry.hap句柄个数 5000+，推测entry.hap泄漏。
分析：
1.包管理接口问题，open hap未释放句柄，但这个问题只报在应用进程内，且只有XXX应用单应用上，其他未复现，暂时排除；
2.应用自身问题，不断open 这个文件句柄未释放，传递给三方能力开发者（确认为该问题）。
案例二：
某service上报句柄泄漏，/system/lib占用的so句柄个数超过5000+
1.  dlopen获取的句柄的位置如下，fd存在saProfile，需要进一步查看saProfile的释放时机。 搜索saProfile的释放位置，发现只有在ParseUtil对象析构时才会释放fd资源。 找到调用者的位置，发现定义了一个类内的私有变量，而这个类的对象一直没析构，导致profileParser_一直没析构，从而导致fd资源一直未释放。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.43321939763233286389038043574879:50001231000000:2800:F9F4006C41499A1D5249E715D0824ECD6DCF87C41534A318024AFC164893AACD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.45578244000368676388329377018975:50001231000000:2800:9735B56A0C8080F83B55DDE8F148379DB5962C7A55E05881345D352852D89BBC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.77501169632403026210616141024284:50001231000000:2800:B3FCE1A659161EEF23BFD2521D0C4F32B950ED73BA64DB318CF6F45660B2DEDF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.87240878942589689801391691912711:50001231000000:2800:4657E8F5659D6900CEF99C129129AB3FB83554C04AD26B4A6D23A9E4FB7A883A.png)
线程泄漏分析方法
推荐建议：
分析方法和案例：
案例1：
某应用netweok和Network File Thread 线程泄漏，运维态泄漏检测机制抓取的日志如下：
1.  故障日志发现network和Network File Thread线程皆占用309个，流水日志发现一直在断网重连。
2.  查看代码发现每个httpclient都会创建单独线程，流水日志中追踪该申请和释放日志。
3.  发现业务需要主动调用releaseHttpClient才能释放线程，领域未感知。
4.
5.  导入@ohos.net.http使用url请求能力的应用，一定要释放线程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.28855117786588780390422407400641:50001231000000:2800:C87664BE21FA2F5F3C763F4A134605E46F6B8D29FE026B5EF161E019E3A7E1B9.png)
案例2：
某应用总线程数超700，上报线程泄漏。
1.
2.  查看线程快照发现栈顶都是__pthread_cond_timedwait，线程都处于等待唤醒，但是线程数较多，优先排查线程创建的地方，往下发现全部归属于libijkplayer.so 内部（开发者so）的线程池，怀疑线程池过大造成。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.94395075704384402696024755954369:50001231000000:2800:B45409B18C7E6DB80AEA92B5A7ACE5357E715D5E9CCF454F6D649E9788E775DB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.61957891825082328895685362635063:50001231000000:2800:E5A6C677A00B0449D850A4CC3813F4286C543A2D7AF114E2467CC4AAC749C9CC.png)
内存泄漏分析方法
JS泄漏
应用侧声明的class、struct、enum，以及通过new创建的实例对象、build中声明的组件、lambda表达式创建的匿名函数，对应在ArkTs虚拟机中都会创建对应的内存对象，虚拟机会自动在内存对象的属性中引用依赖上下文的闭包环境，从而产生隐式的一些引用关系，比较容易产生内存泄漏。
1.
2.  Statistics功能可以用来查看全量内存信息，Comparison功能可以用来对比两份内存快照。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.69946391664866300815002612594415:50001231000000:2800:97CC6723A8BBE791E8A7430E8BA11A74437607E7A303DC7F0C6375A3D1E1DD4D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.19088494668499460078272413817535:50001231000000:2800:C15BE84D5C58E5291633681B86560F9591FB338E76A1B024D700AF9AE9764C0F.png)
如下：
1.  每次抓snapshot会触发1次GC，snapshot文件中展示的对象都是经过GC后因GC根可达无法释放的对象。
Native泄漏
1.  某应用 PSS泄漏，峰值内存TopPssMemory为1.3GB左右，且内存一直增长。
2.  泄漏类型 判定方法 定位方法 虚拟机对象泄漏 搜索关键字“ArkTS”，PSS和SWAP PSS列的值加起来，如果超过总PSS内存的50%，则说明是虚拟机对象内存过大 同JS泄漏 heapdump分析方法 堆内存泄漏 搜索关键字“jemalloc”，PSS和SWAP PSS列的值加起来，如果超过总PSS内存的50%，则说明是堆内存过大 基于nmd和profiler分析 堆内存泄漏有两种可能： 1、调用ARKUI的接口或者开发者的so，直接malloc申请的堆内存过大 2、虚拟机对象持有堆内存引用，对象泄漏导致native内存过大 ashmem泄漏 搜索关键字“/dev/ashmem”，如果超过总PSS内存的50%，则说明是ashmem内存过大 同ashmem泄漏分析方法 1、开发者使用image组件、pixmap组件可能未释放 2、开发者直接通过系统调用申请 anon类型较大 单个anon类型占用内存较大 怀疑mmap内存未释放，直接排查profiler栈，框选 All Anonymous VM，筛选Created & Existing，排查内存占用最多的部分 本例当前应用 jemalloc大小 1GB左右，怀疑堆内存泄漏。 nmd看堆内存总共1.3GB左右： native malloc detail记录抓取进程native日志时内存的快照信息，主要关注其size和allocated两列，有没有哪一块特别大，如果有，假设size为a（如64），就去调用栈中搜索size为a的内存申请，重点分析这行调用栈，极可能是泄漏点。 size向下取整，要看一下所有size的块里面哪个比较大。 Size：用户申请的内存经过对齐后的大小，jemalloc对齐size的分割是按照一个特定算法算的，8字节是最小单位，从第二个size开始，最小step是16，一个size到它的两倍size之间有4个分档。用户态传入的申请大小会向下对齐到离它最近的size中。 Allocated：这个size申请的总内存 如下图： 单次申请80字节的堆内存有135MB左右 单次申请128字节的堆内存有312MB左右 优先怀疑这两个内存块。框选All Heap，解析profiler，选择Created & Existing。 搜索80字节的，排查该堆栈： 搜索128字节的，排查该堆栈： 将堆栈反馈给三方能力开发者。
3.  泄漏类型 判定方法 定位方法 虚拟机对象泄漏 搜索关键字“ArkTS”，PSS和SWAP PSS列的值加起来，如果超过总PSS内存的50%，则说明是虚拟机对象内存过大 同JS泄漏 heapdump分析方法 堆内存泄漏 搜索关键字“jemalloc”，PSS和SWAP PSS列的值加起来，如果超过总PSS内存的50%，则说明是堆内存过大 基于nmd和profiler分析 堆内存泄漏有两种可能： 1、调用ARKUI的接口或者开发者的so，直接malloc申请的堆内存过大 2、虚拟机对象持有堆内存引用，对象泄漏导致native内存过大 ashmem泄漏 搜索关键字“/dev/ashmem”，如果超过总PSS内存的50%，则说明是ashmem内存过大 同ashmem泄漏分析方法 1、开发者使用image组件、pixmap组件可能未释放 2、开发者直接通过系统调用申请 anon类型较大 单个anon类型占用内存较大 怀疑mmap内存未释放，直接排查profiler栈，框选 All Anonymous VM，筛选Created & Existing，排查内存占用最多的部分
4.  nmd看堆内存总共1.3GB左右： native malloc detail记录抓取进程native日志时内存的快照信息，主要关注其size和allocated两列，有没有哪一块特别大，如果有，假设size为a（如64），就去调用栈中搜索size为a的内存申请，重点分析这行调用栈，极可能是泄漏点。 size向下取整，要看一下所有size的块里面哪个比较大。 Size：用户申请的内存经过对齐后的大小，jemalloc对齐size的分割是按照一个特定算法算的，8字节是最小单位，从第二个size开始，最小step是16，一个size到它的两倍size之间有4个分档。用户态传入的申请大小会向下对齐到离它最近的size中。 Allocated：这个size申请的总内存 如下图： 单次申请80字节的堆内存有135MB左右 单次申请128字节的堆内存有312MB左右 优先怀疑这两个内存块。框选All Heap，解析profiler，选择Created & Existing。 搜索80字节的，排查该堆栈： 搜索128字节的，排查该堆栈： 将堆栈反馈给三方能力开发者。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.80572085855705881535163047506240:50001231000000:2800:558A4AABD4747BD72566FC6ED11BB8A4CA679554833785EA7D4222E2AD2BFC67.png)
-  泄漏类型 判定方法 定位方法 虚拟机对象泄漏 搜索关键字“ArkTS”，PSS和SWAP PSS列的值加起来，如果超过总PSS内存的50%，则说明是虚拟机对象内存过大 同JS泄漏 heapdump分析方法 堆内存泄漏 搜索关键字“jemalloc”，PSS和SWAP PSS列的值加起来，如果超过总PSS内存的50%，则说明是堆内存过大 基于nmd和profiler分析 堆内存泄漏有两种可能： 1、调用ARKUI的接口或者开发者的so，直接malloc申请的堆内存过大 2、虚拟机对象持有堆内存引用，对象泄漏导致native内存过大 ashmem泄漏 搜索关键字“/dev/ashmem”，如果超过总PSS内存的50%，则说明是ashmem内存过大 同ashmem泄漏分析方法 1、开发者使用image组件、pixmap组件可能未释放 2、开发者直接通过系统调用申请 anon类型较大 单个anon类型占用内存较大 怀疑mmap内存未释放，直接排查profiler栈，框选 All Anonymous VM，筛选Created & Existing，排查内存占用最多的部分
| 泄漏类型  | 判定方法  | 定位方法  |
| --- | --- | --- |
| 虚拟机对象泄漏  | 搜索关键字“ArkTS”，PSS和SWAP PSS列的值加起来，如果超过总PSS内存的50%，则说明是虚拟机对象内存过大  | 同JS泄漏 heapdump分析方法  |
| 堆内存泄漏  | 搜索关键字“jemalloc”，PSS和SWAP PSS列的值加起来，如果超过总PSS内存的50%，则说明是堆内存过大  | 基于nmd和profiler分析 堆内存泄漏有两种可能： 1、调用ARKUI的接口或者开发者的so，直接malloc申请的堆内存过大 2、虚拟机对象持有堆内存引用，对象泄漏导致native内存过大  |
| ashmem泄漏  | 搜索关键字“/dev/ashmem”，如果超过总PSS内存的50%，则说明是ashmem内存过大  | 同ashmem泄漏分析方法 1、开发者使用image组件、pixmap组件可能未释放 2、开发者直接通过系统调用申请  |
| anon类型较大  | 单个anon类型占用内存较大  | 怀疑mmap内存未释放，直接排查profiler栈，框选 All Anonymous VM，筛选Created & Existing，排查内存占用最多的部分  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.37510763433753794970292930629602:50001231000000:2800:21E26A6D360495DEFEBC685400CFAD1BFD078C9BACA49B64F18056C726ABE45D.png)
-  nmd看堆内存总共1.3GB左右： native malloc detail记录抓取进程native日志时内存的快照信息，主要关注其size和allocated两列，有没有哪一块特别大，如果有，假设size为a（如64），就去调用栈中搜索size为a的内存申请，重点分析这行调用栈，极可能是泄漏点。 size向下取整，要看一下所有size的块里面哪个比较大。 Size：用户申请的内存经过对齐后的大小，jemalloc对齐size的分割是按照一个特定算法算的，8字节是最小单位，从第二个size开始，最小step是16，一个size到它的两倍size之间有4个分档。用户态传入的申请大小会向下对齐到离它最近的size中。 Allocated：这个size申请的总内存 如下图： 单次申请80字节的堆内存有135MB左右 单次申请128字节的堆内存有312MB左右 优先怀疑这两个内存块。框选All Heap，解析profiler，选择Created & Existing。 搜索80字节的，排查该堆栈： 搜索128字节的，排查该堆栈： 将堆栈反馈给三方能力开发者。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.61095541373698372537090061994677:50001231000000:2800:18C7887B52530D6FC9C73C0C494434CD10873F092480BC53C40947189DCDEDCC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170528.14490550598271001900865852465964:50001231000000:2800:D18631AA928B7407763719D7220EACC776C2BF5F41D593838AC59770B9A5165A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170529.65668166288541486369951972008197:50001231000000:2800:251B379124BFA56AD2BAD5B5C7E8C426FF0BF3857AA6AEBEF838EE9CFAE89D88.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170529.10952941182497901360692677085355:50001231000000:2800:ACCCCA75DF95C1E5A791808683F06F0C0C96F8450D6087C31D424B91528167C7.png)
ashmem泄漏
图片共享内存一般有以下几种命名方式：
这些内存都是由图片编解码框架提供的编解码工具申请的，申请代码如下：
解码框架本身没有问题，一旦完成解码，ashmem的所有权会转移给C++的PixelMap对象，如果是ashmem泄漏，基本上可以断定是C++层的PixelMap泄漏。
开发者首先排查是否存在如下可能：
图片文件句柄泄漏问题分析
-  smaps中存在数量较多的图片文件路径为名称的内存块。
-  从jsheap中可以看到，js侧ForEach数据源未发生泄漏，可以暂时排除应用业务逻辑的问题。 分析代码后发现以下两处怀疑点： 1.sceneSessionManager.getSessionSnapshot接口内部native实现是否可能存在泄漏； 2.getImageInfo中实现引用了文件句柄，导致泄漏。 通过注释代码后，可以定位到泄漏点在getImageInfo内部image.createImageSource，属于工具范围存在句柄泄漏。
-  应用侧对于不用的PixelMap要及时释放引用，每个未释放的PixelMap都会在底层产生一条/dev/ashmem/XXXX RawData 的共享内存占用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170529.41956716534333160305015970113890:50001231000000:2800:7708D9ACF96DD196B7C07BC9F5DE465D82D7448D5B66407A6105C19788370FAD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170529.29916310087320006638435172993794:50001231000000:2800:E3032300155EBAE0C86DA00978B00D2DDDC4180D23FB4D21B8B704718009B963.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170529.80437619840088152028207673237936:50001231000000:2800:10C0BF01D6630F2AC80FD100EC8EE1F4842598AC4D1324544C2BCA11AD1C307B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170529.64494455702275801097640888470850:50001231000000:2800:255F1496453364128C794242E1212D811D25CC57A6B27D710F70EA135FE0AD5B.png)
ion泄漏
1.
2.  如果上述两种情况都不存在，那么很有可能ArkUI组件内部实现存在PixelMap泄漏。
3.  如果上述两种情况都不存在，那么很有可能ArkUI组件内部实现存在PixelMap泄漏。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170529.08980827259518323646183215326234:50001231000000:2800:67367C3F91A36D665925C05501477FADC950B0E95E41F0BDA468CF5FA0583CE5.png)
-  如果上述两种情况都不存在，那么很有可能ArkUI组件内部实现存在PixelMap泄漏。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170529.55447036455743815896284402476138:50001231000000:2800:9605BEF478C94B21B945CD66F67262112D2C091D060169597BDA14F651928018.png)
自定义pixmap name
从历史经验看，ION和ashmem的泄漏只要是由于pixmap使用异常，为了提升定位效率，华为侧提供了一个API接口，应用/service自己设定ashmem和ION的name，与pixmap绑定，出现ION和ashmem泄漏后会打印name，直接判断是哪张图片泄漏，反推至对应的问题组件。
提供的API接口使用方法可参考：
JS层API：setMemoryNameSync
native层API：OH_PixelmapNative_SetMemoryName
建议Name按照 窗口+组件+图片序号自定义，如果出现批量组件图片内存未释放，可快速定位
修改方法示例：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170529.73054233915210925661003299157698:50001231000000:2800:54A5E3199B64330DED5400CFC98470516245360D0946BE3594623548F4D253B0.png)
ashmem日志结果示例展示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170529.37912494200577379581757571125356:50001231000000:2800:8730F4CC5AD4EC901AFF3C2D5ACAC2C56D24B8DB367E6BF01DA7D30D514CEB46.png)
ion日志结果示例展示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170529.10067892593449721394492818030503:50001231000000:2800:3EB16AF5F726A91F3F41F972A96ED09D98FA7D5877A99091081CDE710F6E8153.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/test-kit-V14
爬取时间: 2025-04-28 19:21:18
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/test-kit-overview-V14
爬取时间: 2025-04-28 19:21:32
来源: Huawei Developer
Test Kit为开发者提供了自动化测试框架，框架提供单元测试和UI测试能力，支持编写ArkTS语言的单元和UI自动化测试脚本，通过测试结果查看相应功能的实现效果。
单元测试能力：提供自动化测试的基础接口和运行机制，主要能力如下：
UI测试能力：提供UI自动化测试能力，其脚本执行基于单元测试能力进行，主要能力如下：
具体使用方法请参考自动化测试框架使用指导。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/debugging-commands-V14
爬取时间: 2025-04-28 19:21:45
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hdc-V14
爬取时间: 2025-04-28 19:21:59
来源: Huawei Developer
hdc（HarmonyOS Device Connector）是为开发人员提供的用于调试的命令行工具，通过该工具可以在windows/linux/mac系统上与设备进行交互。
hdc分为三部分：
client：运行在电脑端的进程，开发者在执行hdc命令时启动该进程，命令结束后进程退出。
server：运行在电脑端的后台服务进程，用来管理client进程和设备端的daemon进程之间的数据交互，以及设备发现等。
daemon：作为守护进程运行在设备端，用来响应电脑端server发来的请求。
关系如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170529.52401492676063085624184863231479:50001231000000:2800:B1A88D4BAC52F76E53C9330E4DBC79065A226B4DDF0DDC8C61A61081111010DD.png)
hdc client在启动时，默认会判断server是否正在运行，如果没有运行则会启动一个新的hdc程序作为server，运行在后台。
hdc server运行时，默认会监听PC的8710端口，开发者可通过设置系统环境变量OHOS_HDC_SERVER_PORT自定义监听的端口号。
环境准备
hdc工具通过HarmonyOS SDK获取，存放于SDK的toolchains目录下。
（可选）命令行直接执行hdc程序
开发者可通过命令行进入SDK的toolchains目录，在目录中执行hdc相关命令进行调试。
为了方便在命令行中直接执行hdc程序，开发者也可以将hdc程序文件路径添加到操作系统命令搜索路径的环境变量中。
例如，Windows系统可以添加到系统环境变量Path中。
（可选）server监听端口配置
hdc server启动时，默认会监听PC的8710端口，hdc client使用tcp协议通过此端口连接server。如果PC的8710端口已经被使用或者希望使用其他端口，可以通过添加环境变量OHOS_HDC_SERVER_PORT到系统环境变量中来修改server启动时监听的端口号。
例如，添加变量名为：OHOS_HDC_SERVER_PORT，变量值可设置为任意未被占用的端口，如18710。
环境变量配置完成后，关闭并重启命令行或其他使用到HarmonyOS SDK的软件。
hdc命令列表
全局参数
全局参数是指运行部分hdc命令时，可以跟随在hdc后面的参数，例如：
选择指定的设备执行命令，使用-t参数：
```shell
hdc -t connect-key shell echo "Hello world"
```
| 参数 | 说明 |
| --- | --- |
| -t | 连接指定的目标设备，连接一台设备时为可选参数，连接多台设备时为必选参数。 |
| -l | 可选参数，指定运行时日志等级，范围为数字0-6，默认为3（LOG_INFO）。 |
| -s | 可选参数，指定客户端连接服务端时，服务进程的网络监听参数，格式为ip:port。 |
| -p | 可选参数，绕过对服务进程的查询步骤，用于快速执行客户端命令。 |
| -m | 可选参数，使用前台启动模式启动服务进程。 |
命令列表
| 命令 | 说明 |
| --- | --- |
| list targets | 查询已连接的所有目标设备。 |
| wait | 等待设备正常连接。 |
| tmode usb | 该命令已经废弃，不会实际操作设备连接通道，需要在设备设置界面通过USB调试开关进行设置。 |
| tmode port | 打开设备网络连接通道。 |
| tmode port close | 关闭设备网络连接通道。 |
| tconn | 指定连接设备：通过“IP地址：端口号”来指定连接的设备。 |
| shell | 在设备侧执行单次命令。 |
| install | 安装指定的应用文件。 |
| uninstall | 卸载指定的应用包。 |
| file send | 从本地发送文件至远端设备。 |
| file recv | 从远端设备发送文件至本地。 |
| fport ls | 列出全部转发端口转发任务。 |
| fport | 设置正向端口转发任务：监听“主机端口”，接收请求并进行转发， 转发到“设备端口”。 |
| rport | 设置反向端口转发任务：监听“设备端口”，接收请求并进行转发，转发到“主机端口”。 |
| fport rm | 删除指定的端口转发任务。 |
| start | 启动hdc服务进程。 |
| kill | 终止hdc服务进程。 |
| hilog | 打印设备端的日志信息。 |
| jpid | 显示设备上所有开启了JDWP调试协议的应用的PID。 |
| track-jpid | 实时显示设备上开启了JDWP调试协议的应用的PID和应用名。 |
| target boot | 重启目标设备。 |
| keygen | 生成一个新的秘钥对。 |
| version | 打印hdc版本信息，也可使用hdc -v打印版本信息。 |
| checkserver | 获取客户进程与服务进程版本信息。 |
全局参数在使用时需要放在命令之前。
基本使用方法
在使用hdc前，请在设备上开启usb调试功能，用usb线连接设备和PC。
查询连接的设备
```shell
hdc list targets
```
执行shell命令
```shell
hdc shell echo "Hello world"
```
获取帮助
| 命令 | 说明 |
| --- | --- |
| -h [verbose] | 显示hdc相关的帮助信息。可选参数：verbose，显示详细的帮助信息。 |
| help | 显示hdc相关的帮助信息。 |
显示hdc相关的帮助信息，命令格式如下：
```shell
hdc -h [verbose]
hdc help
```
返回值：
| 返回值 | 说明 |
| --- | --- |
| HarmonyOS device connector(HDC) ... ---------------------------------global commands:---------------------------------- -h/help [verbose]                     - Print hdc help, 'verbose' for more other cmds ...（此处省略详细帮助信息）  | hdc命令使用帮助信息 |
HarmonyOS device connector(HDC) ...
---------------------------------global commands:----------------------------------
-h/help [verbose]                     - Print hdc help, 'verbose' for more other cmds
...（此处省略详细帮助信息）
使用方法：
```shell
hdc -h
hdc help
// 显示详细帮助信息
hdc -h verbose
```
使用注意事项
-  使用hdc时如出现异常，可尝试通过hdc kill -r命令杀掉异常进程并重启hdc服务。
-  如出现hdc list targets获取不到设备信息的情况，参见设备无法识别章节。
设备连接管理
查询设备列表
通过命令list targets，查询已连接的所有目标设备。
添加-v参数，则会打印设备详细信息。
命令格式如下：
```shell
hdc list targets [-v]
```
返回值：
| 返回值 | 说明 |
| --- | --- |
| 设备标识符列表 | 已连接的设备标识符列表，-t参数使用的connect-key即为此信息。 |
| [Empty] | 没有查询到设备信息。 |
使用方法：
```shell
hdc list targets
hdc list targets -v
```
连接指定的目标设备
连接单台设备时，执行命令无需指定设备标识符；
连接了多台设备时，每次执行命令时需要使用-t参数指定目标设备的标识符，命令格式如下：
```shell
hdc -t [connect-key] [command]
```
参数：
| 参数名 | 说明 |
| --- | --- |
| connect-key | 设备标识符，即为hdc list targets返回的信息。 |
| command | hdc支持的命令。 |
connect-key为每个设备唯一的标识符。如果通过usb连接，标识符为序列号；如果通过网络连接设备，标识符为“IP地址:端口号”。
返回值：
| 返回值 | 说明 |
| --- | --- |
| 命令执行返回内容 | 请参考对应命令的返回值。 |
| [Fail]Not match target founded, check connect-key please | 没有找到与connect-key匹配的设备。 |
| [Fail]Device not founded or connected | 设备未找到或尚未连接。 |
| [Fail]ExecuteCommand need connect-key? please confirm a device by help info | 多设备连接时需要指定一个设备。 |
| Unknown operation command... | 不支持的命令。 |
返回的错误提示信息后续会调整优化，请勿用于自动化脚本或程序的结果判断。
使用方法：
该方法需要与具体的操作命令搭配使用，下面以shell命令举例：
```shell
hdc list targets  // 查询已连接的所有目标设备的connect-key
hdc -t [connect-key] shell // -t 后面添加的connect-key需要替换为指定的设备标识符
```
等待设备正常连接
命令格式如下：
```shell
hdc wait // 等待设备正常连接
hdc -t connect-key wait // 等待指定的设备正常连接，connect-key需要替换为指定的设备标识符
```
返回值：
| 返回值 | 说明 |
| --- | --- |
| 无 | hdc wait命令执行后，识别到正常连接的设备后结束。 |
使用方法：
```shell
hdc wait
hdc -t connect-key wait
```
常见连接场景
USB连接场景
| 确认项 | 正常 | 异常处理 |
| --- | --- | --- |
| USB调试选项 | 开启 | 设备的USB调试模式如无法自动开启，请尝试重启设备。 |
| USB数据连接线 | 使用USB数据连接线连接到调试PC的USB接口 | 如使用低带宽、无数据通信功能的USB连接线可能导致无法识别HDC设备，建议更换官方USB数据连接线。 |
| USB接口 | 主板直出USB接口（台式机为后面板的USB接口，笔记本为机身的USB接口） | 如使用转接头/拓展坞/台式机前面板USB接口，存在带宽低和USB同步异常等问题，会导致频繁断连，推荐使用直连方式连接PC和设备。 |
| hdc环境变量 | 终端命令行输入hdc -h有回显帮助信息内容 | 参见环境准备章节。 |
| 驱动 | 连接HDC设备后，设备管理器通用串行总线设备存在设备"HDC Device"或"HDC Interface" | 参见设备无法识别章节。 |
1.  PC通过USB连接设备。
2.  查看已连接设备，执行以下命令： 返回值中存在对应设备的标识符，即为usb连接成功。
```shell
hdc list targets
```
3.  可以查询到设备后，即可运行设备相关命令和设备进行交互。如果希望不带设备标识符进行USB命令操作，需要确认设备不在tcp连接模式（hdc list targets查询的设备不包含IP:port形式的连接信息），直接连接即可，例如：
```shell
hdc shell
```
TCP连接场景
TCP调试功能尚未稳定，请谨慎用于生产环境。
| 确认项 | 正常 | 异常处理 |
| --- | --- | --- |
| 网络连接 | PC、手机设备处于同一网络。 | 连接同一WiFi或手机开启热点。 |
| 网络状态 | telnet IP:port正常，网速稳定。 | 请选择稳定的网络连接方式。 |
| hdc环境变量 | 终端命令行输入hdc -h有回显帮助信息内容 | 参见环境准备章节。 |
1.  在设备设置界面打开无线调试开关。
2.  记录设备界面显示的监听端口号，记为PORT，用于后面的tcp连接。
3.  通过tcp连接设备（需要事先知道设备IP和打开的PORT），执行以下命令： IP地址可在设备侧的设置里面查看到，端口号为上一步设备无线调试界面显示的端口号。
```shell
hdc tconn IP:PORT
```
4.  查看已连接设备，执行以下命令： 返回值为IP:PORT形式即为连接成功。
```shell
hdc list targets
```
5.  如果需要关闭TCP连接模式，可以在设备中关闭无线调试开关。
远程连接场景
远程连接场景是指客户端通过网络远程连接服务端，客户端和服务端在不同的PC运行，服务端连接设备。
远程连接如图所示:
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170530.17474032363878892459502328655578:50001231000000:2800:1D048A1CA2F4BE4296434B69E9B8ECCAE58F9B51322B5688915753101247635B.png)
hdc client（客户端）在PC1中运行，hdc server（服务端）在PC2中运行，PC2中的hdc server连接设备。
-  连接命令 远程连接使用-s参数来指定服务端的网络参数，包括地址和端口号，该设置只在当前命令执行期间有效，命令格式如下： 参数： 返回值： 使用方法： 当命令行中明确使用 -s 参数指定服务端口时，系统将忽略OHOS_HDC_SERVER_PORT环境变量中定义的端口设置。
```shell
hdc -s [ip]:[port] [command]
```
-  连接步骤 服务端通过USB连接到对应的HDC设备后执行以下命令： 客户端连接需要确保可以连通服务端IP地址，满足前述条件后执行以下命令：
```shell
hdc kill          // 关闭本地hdc服务
hdc -s IP:8710 -m // 启动网络转发的hdc服务
// 其中IP为服务端自身的IP，windows可通过ipconfig查询，unix系统可通过ifconfig查询
// 8710为默认端口号，也可设置为其他端口号如：18710
// 启动后服务端将打印日志
```
| 命令 | 说明 |
| --- | --- |
| -s | 指定当前服务进程的网络监听参数。 |
| 参数 | 说明 |
| --- | --- |
| ip | 指定监听的IP地址，支持IPv4和IPv6。 |
| port | 指定监听的端口，范围：1~65535。 |
| command | hdc支持的命令。 |
| 返回值 | 说明 |
| --- | --- |
| Connect server failed | 与服务进程建立连接失败。 |
| -s content port incorrect. | 端口号超出可设置范围（1~65535）。 |
usb调试和无线调试切换
用于连接模式切换的命令如下表所示：
当前推荐通过设备端的usb调试开关和无线调试开关来控制连接通道的开启和关闭。
| 命令 | 说明 |
| --- | --- |
| tmode usb | 该命令已经废弃，不会实际操作设备连接通道，需要在设备设置界面通过USB调试开关进行设置。 |
| tmode port [port-number] | 打开设备网络连接通道：设备端daemon进程会重启，已建立的USB连接会中断，需要重新连接。 |
| tmode port close | 关闭设备网络连接通道：设备端daemon进程会重启，已建立的USB连接会中断，需要重新连接。 |
| tconn [IP]:[port] [-remove] | 连接指定的设备，通过“IP地址：端口号”来指定连接的设备，使用-remove参数断开连接。 |
1.  打开设备网络连接通道，命令格式如下： 参数： 返回值： 使用方法： 切换前，请确保条件满足：远端设备与近端PC处于同一网络，且PC可ping通远端设备IP。 如不满足以上条件请勿使用该命令进行切换。 执行完毕后，远端daemon进程将会退出并重启，USB连接将会断开，需要重新连接。
```shell
hdc tmode port [port-number]
```
2.  关闭设备网络连接通道，命令格式如下： 返回值： 使用方法： 执行完毕后，远端daemon进程将会退出并重启，USB连接将会断开，需要重新连接。
```shell
hdc tmode port close
```
3.  通过TCP连接指定的设备，命令格式如下： 参数： 返回值： 使用方法：
```shell
hdc tconn [IP]:[port] [-remove]
```
| 参数 | 参数说明 |
| --- | --- |
| port-number | 监听连接的网络端口号，范围:1~65535。 |
| 返回值 | 说明 |
| --- | --- |
| Set device run mode successful. | 打开成功。 |
| [Fail]ExecuteCommand need connect-key | 打开失败，设备列表无设备，无法打开设备无线调试通道。 |
| [Fail]Incorrect port range | 端口号超出可设置范围（1~65535）。 |
| 返回值 | 说明 |
| --- | --- |
| [Fail]ExecuteCommand need connect-key | 设备列表无设备，无法执行命令。 |
| 参数 | 参数说明 |
| --- | --- |
| [IP]:[port] | 设备的IP地址与端口号。 |
| -remove | 可选参数，断开指定设备的连接。 |
| 返回值 | 说明 |
| --- | --- |
| Connect OK | 连接成功 |
| [Info]Target is connected, repeat opration | 设备当前已连接 |
| [Fail]Connect failed | 连接失败 |
执行交互命令
命令格式如下：
```shell
hdc shell [command]
```
参数：
| 参数 | 说明 |
| --- | --- |
| [command] | 需要在设备侧执行的单次命令，不同类型或版本的系统支持的command命令有所差异，可以通过hdc shell ls /system/bin查阅支持的命令列表。当前许多命令都是由toybox提供，可通过 hdc shell toybox --help 获取命令帮助。 |
返回值：
| 返回值 | 说明 |
| --- | --- |
| 交互命令返回内容 | 返回内容详情请参见其他交互命令返回内容。 |
| /bin/sh: XXX : inaccessible or not found | 不支持的交互命令。 |
使用方法：
```shell
hdc shell ps -ef
hdc shell help -a // 查询全部可用命令
```
应用管理
| 命令 | 说明 |
| --- | --- |
| install src | 安装指定的应用文件。 |
| uninstall packageName | 卸载指定的应用包package包名。 |
1.  安装APP package，命令格式如下： 参数： 返回值： 使用方法： 以安装example.hap包为例：
```shell
hdc install [-r|-s] src
```
2.  卸载应用，命令格式如下： 参数： 返回值： 使用方法： 以卸载com.example.hello包为例：
```shell
hdc uninstall [-k|-s] packageName
```
| 参数名 | 说明 |
| --- | --- |
| src | 应用安装包的文件名 |
| -r | 替换已存在应用（.hap） |
| -s | 安装一个共享包（.hsp） |
| 返回值 | 说明 |
| --- | --- |
| AppMod finish | 成功情况下返回安装信息和AppMod finish。 |
| 具体安装失败原因 | 失败情况下返回具体安装失败信息。 |
| 参数名 | 说明 |
| --- | --- |
| packageName | 应用安装包。 |
| -k | 保留/data和/cache目录。 |
| -s | 卸载共享包。 |
| 返回值 | 说明 |
| --- | --- |
| AppMod finish | 成功情况下返回卸载信息和AppMod finish。 |
| 具体卸载失败原因 | 失败情况下返回具体卸载失败信息。 |
文件传输
| 命令 | 说明 |
| --- | --- |
| file send localpath remotepath | 从本地发送文件至远端设备。 |
| file recv remotepath localpath | 从远端设备发送文件至本地。 |
1.  从本地发送文件至远端设备，命令格式如下： 参数： 返回值： 文件发送成功，返回传输成功的结果信息。文件发送失败，返回传输失败的具体信息。 使用方法：
```shell
hdc file send [-a|-sync|-z|-m] localpath remotepath
```
2.  从远端设备发送文件至本地，命令格式如下： 参数： 返回值： 文件接收成功，返回传输成功的结果信息。文件接收失败，返回传输失败的具体信息。 使用方法：
```shell
hdc file recv [-a|-sync|-z|-m] remotepath localpath
```
| 参数名 | 说明 |
| --- | --- |
| localpath | 本地待发送的文件路径。 |
| remotepath | 远程待接收的文件路径。 |
| -a | 保留文件时间戳。 |
| -sync | 只传输文件mtime有更新的文件。 |
| -z | 通过LZ4格式压缩传输，此功能未开放，请勿使用。 |
| -m | 文件传输时同步文件DAC权限，uid，gid，MAC权限。 |
| 参数名 | 说明 |
| --- | --- |
| localpath | 本地待接收的文件路径。 |
| remotepath | 远程待发送的文件路径。 |
| -a | 保留文件时间戳。 |
| -sync | 只传输文件mtime有更新的文件。 |
| -z | 通过LZ4格式压缩传输，此功能未开放，请勿使用。 |
| -m | 文件传输时同步文件DAC权限，uid，gid，MAC权限。 |
端口转发
| 命令 | 说明 |
| --- | --- |
| fport ls | 列出全部转发端口转发任务。 |
| fport localnode remotenode | 设置正向端口转发任务：监听“主机端口”，接收请求并进行转发， 转发到“设备端口”。 |
| rport remotenode localnode | 设置反向端口转发任务：监听“设备端口”，接收请求并进行转发，转发到“主机端口”。 |
| fport rm taskstr | 删除指定的端口转发任务。 |
PC端支持的端口转发类型：tcp。
设备端支持的端口转发类型：tcp，dev，localabstract，localfilesystem，jdwp，ark。
1.  列出全部转发端口转发任务，命令格式如下： 返回值： 使用方法：
```shell
hdc fport ls
```
2.  设置正向端口转发任务，执行后将设置指定的“主机端口”转发数据到“设备端口”转发任务，命令格式如下： 返回值： 使用方法：
```shell
hdc fport localnode remotenode
```
3.  设置反向端口转发任务，执行后将设置指定的“设备端口”转发数据到“主机端口”转发任务，命令格式如下： 返回值： 使用方法：
```shell
hdc rport remotenode localnode
```
4.  删除端口转发任务，执行后将指定的转发任务删除，命令格式如下： 参数： 返回值： 使用方法：
```shell
hdc fport rm taskstr
```
| 返回值 | 说明 |
| --- | --- |
| tcp:1234 tcp:1080 [Forward] | 正向端口转发任务 |
| tcp:2080 tcp:2345 [Reverse] | 反向端口转发任务 |
| [empty] | 无端口转发任务 |
| 返回值 | 说明 |
| --- | --- |
| Forwardport result:OK | 端口转发任务设置正常。 |
| [Fail]Incorrect forward command | 端口转发任务设置失败，端口转发参数错误。 |
| [Fail]TCP Port listen failed at XXXX | 端口转发任务设置失败，本地转发端口被占用。 |
| 返回值 | 说明 |
| --- | --- |
| Forwardport result:OK | 端口转发任务设置正常。 |
| [Fail]Incorrect forward command | 端口转发任务设置失败，端口转发参数错误。 |
| [Fail]TCP Port listen failed at XXXX | 端口转发任务设置失败，本地转发端口被占用。 |
| 参数 | 说明 |
| --- | --- |
| taskstr | 端口转发任务，形如 tcp:XXXX tcp:XXXX。 |
| 返回值 | 说明 |
| --- | --- |
| Remove forward ruler success, ruler:tcp:XXXX tcp:XXXX | 端口转发任务删除正常。 |
| [Fail]Remove forward ruler failed, ruler is not exist tcp:XXXX tcp:XXXX | 端口转发任务删除失败，不存在指定的转发任务。 |
服务进程管理
| 命令 | 说明 |
| --- | --- |
| start [-r] | 启动hdc服务进程，使用-r参数触发服务进程重新启动。 |
| kill [-r] | 终止hdc服务进程，使用-r参数触发服务进程重新启动。 |
| -p | 绕过对服务进程的查询步骤，用于快速执行客户端命令。 |
| -m | 使用前台启动模式启动服务进程。 |
1.  启动hdc服务进程，命令格式如下： 返回值： 使用方法： 当启动hdc服务进程且系统未检测到运行的服务进程时，日志等级的设置优先级如下：若同时指定了-l参数和配置了OHOS_HDC_LOG_LEVEL环境变量，则使用环境变量配置的日志等级；如果仅指定了-l参数，则采用该参数配置的日志等级；若两者均未指定，则服务进程将以默认的LOG_INFO等级启动。
```shell
hdc start [-r]
```
2.  终止hdc服务进程，命令格式如下： 返回值： 使用方法：
```shell
hdc kill [-r]
```
3.  绕过对服务进程的查询步骤，用于快速执行客户端命令，命令格式如下： 参数： 返回值： 使用方法： 在未指定 -p 参数的情况下直接执行 command 命令时，客户端将首先检查本地是否已有运行的服务进程。若系统未检测到运行的服务进程，客户端将自动启动服务进程，并建立连接以传递命令；若系统检测到运行的服务进程，客户端将直接与该后台服务建立连接并下发相应的命令。
```shell
hdc -p [command]
```
4.  使用前台启动模式启动服务进程，命令格式如下： 返回值： 使用方法：
```shell
hdc -m
```
| 返回值 | 说明 |
| --- | --- |
| 无返回值 | 服务进程启动成功 |
| 返回值 | 说明 |
| --- | --- |
| Kill server finish | 服务进程终止成功 |
| [Fail]具体失败信息 | 服务进程终止失败 |
| 参数 | 说明 |
| --- | --- |
| command | hdc支持的命令 |
| 返回值 | 说明 |
| --- | --- |
| Connect server failed | 与服务进程建立连接失败 |
| 返回值 | 说明 |
| --- | --- |
| Initial failed | 服务进程初始化失败。 |
| [I][1970-01-01 00:00:00.000][abcd][session.cpp:25] Program running. Ver: X.X.Xa Pid:12345 | 正常打印对应等级的日志，显示服务端活动状态。 |
设备操作
| 命令 | 说明 |
| --- | --- |
| hilog [-h] | 打印设备端的日志信息，可通过hdc hilog -h查阅支持的参数列表。 |
| jpid | 显示设备上所有开启了JDWP调试协议的应用的PID。 |
| track-jpid [-a|-p] | 实时显示设备上开启了JDWP调试协议的应用的PID和应用名，不加参数只显示debug的应用的进程，使用-a参数显示debug和release应用的进程，使用-p参数不显示debug和release的标签。 |
| target boot [-bootloader|-recovery] | 重启目标设备，使用-bootloader参数重启后进入fastboot模式，使用-recovery参数重启后进入recovery模式。 |
| target boot [MODE] | 重启目标设备，加参数重启后进入相应的模式，其中MODE为/bin/begetctl命令中reboot支持的参数。 |
1.  打印设备端的日志信息，命令格式如下： 参数： 返回值： 使用方法：
```shell
hdc hilog [-h]
```
2.  显示设备上所有开启了JDWP调试协议的进程的PID，命令格式如下： 返回值： 使用方法：
```shell
hdc jpid
```
3.  实时显示设备上开启了JDWP调试协议的进程的PID和应用名，命令格式如下： 参数： 返回值： 使用方法：
```shell
track-jpid [-a|-p]
```
4.  重启目标设备，命令格式如下： 参数： 重启后进入MODE模式，MODE为/bin/begetctl命令中reboot支持的参数。 可通过hdc shell "/bin/begetctl -h | grep reboot"查看。 使用方法：
```shell
target boot [-bootloader|-recovery]
target boot [MODE]
```
| 参数 | 说明 |
| --- | --- |
| [-h] | hilog支持的参数，可通过hdc hilog -h查阅支持的参数列表。 |
| 返回值 | 说明 |
| --- | --- |
| 返回具体信息 | 抓取的日志信息。 |
| 返回值 | 说明 |
| --- | --- |
| 进程号列表 | 开启了JDWP调试协议的应用的PID。 |
| [empty] | 无开启了JDWP调试协议的进程。 |
| 参数 | 说明 |
| --- | --- |
| 不加参数 | 只显示debug的应用的进程号和包名/进程名。 |
| -a | 显示debug和release应用的进程号和包名/进程名。 |
| -p | 显示debug和release应用的进程号和包名/进程名，但不显示debug和release的标签。 |
| 返回值 | 说明 |
| --- | --- |
| 进程号和包名/进程名列表 | - |
| [empty] | 不加参数时表示无开启了JDWP调试协议的debug应用的进程，使用-a或-p参数时表示无开启了JDWP调试协议的进程。 |
| 参数名 | 说明 |
| --- | --- |
| 不加参数 | 重启设备 |
| -bootloader | 重启后进入fastboot模式。 |
| -recovery | 重启后进入recovery模式。 |
| MODE | 重启后进入MODE模式，MODE为/bin/begetctl命令中reboot支持的参数。  可通过hdc shell "/bin/begetctl -h | grep reboot"查看。  |
安全相关命令
| 命令 | 说明 |
| --- | --- |
| keygen FILE | 生成一个新的秘钥对，并将私钥和公钥分别保存到FILE和FILE.pub，其中文件名FILE可自定义。 |
1.  生成一个新的秘钥对，命令格式如下： 参数： 使用方法：
```shell
hdc keygen FILE
```
| 参数 | 说明 |
| --- | --- |
| FILE | FILE为自定义的文件名 |
查询版本号
| 命令 | 说明 |
| --- | --- |
| -v/version | 打印hdc版本信息。 |
| checkserver | 获取客户端与服务进程版本。 |
1.  显示hdc的版本信息，命令格式如下： 返回值： 使用方法：
```shell
hdc -v/version
```
2.  获取客户端与服务进程版本，命令格式如下： 返回值： 使用方法：
```shell
hdc checkserver
```
| 返回值 | 说明 |
| --- | --- |
| Ver: X.X.Xa | hdc（SDK）的版本信息。 |
| 返回值 | 说明 |
| --- | --- |
| Client version: Ver: X.X.Xa, Server version: Ver: X.X.Xa | client（客户端），server（服务进程）版本号。 |
hdc调试日志
server端日志
指定运行时日志等级
hdc运行时日志等级，默认为LOG_INFO，命令格式如下：
```shell
hdc -l [level] [command]
```
参数：
| 参数 | 说明 |
| --- | --- |
| [level] | 指定运行时日志等级 0：LOG_OFF 1：LOG_FATAL 2：LOG_WARN 3：LOG_INFO 4：LOG_DEBUG 5：LOG_ALL  6：LOG_LIBUSB。  |
| command | hdc支持的命令。 |
指定运行时日志等级
0：LOG_OFF
1：LOG_FATAL
2：LOG_WARN
3：LOG_INFO
4：LOG_DEBUG
5：LOG_ALL
6：LOG_LIBUSB。
返回值：
| 返回值 | 说明 |
| --- | --- |
| 命令执行返回内容 | 请参考对应命令的返回值。 |
| 日志信息 | 对应指定的运行时等级日志打印。 |
使用方法：
客户端打印LOG_DEBUG级别日志，以执行shell ls为例，命令示例如下:
```shell
hdc -l 5 shell ls
```
服务进程前台模式启动指定LOG_LIBUSB级别日志，命令示例如下:
```shell
hdc kill && hdc -l 6 -m
```
-m参数指定以前台模式启动服务进程，可以直接观察前台日志输出，按下Ctrl+C退出进程。
服务进程后台启动模式指定LOG_LIBUSB级别日志，命令示例如下:
```shell
hdc kill && hdc -l 6 start
```
以后台模式启动，可以在hdc.log中观察日志输出，日志路径可以查看日志获取章节的描述。
日志获取
执行以下命令开启日志获取：
```shell
hdc kill
hdc -l5 start
```
收集到的完整日志存放路径：
| 平台 | 路径 | 备注 |
| --- | --- | --- |
| Windows | %temp%\hdc.log | 实际路径参考，实际使用请替换用户名变量 C:\Users\用户名\AppData\Local\Temp\hdc.log。  |
| Linux | /tmp/hdc.log | - |
| MacOS | $TMPDIR/hdc.log | - |
实际路径参考，实际使用请替换用户名变量
C:\Users\用户名\AppData\Local\Temp\hdc.log。
日志相关环境变量：
| 环境变量名称 | 默认值 | 说明 |
| --- | --- | --- |
| OHOS_HDC_LOG_LEVEL | 5 | 用于配置服务进程日志记录级别，日志级别详情参考： server端日志指定运行时日志等级章节。  |
用于配置服务进程日志记录级别，日志级别详情参考：
server端日志指定运行时日志等级章节。
环境变量配置方法：
以下通过配置OHOS_HDC_LOG_LEVEL环境变量为例，配置环境变量值为：5，介绍环境变量配置方法。
| 操作系统 | 配置方法 |
| --- | --- |
| Windows | 在此电脑 > 属性 > 高级系统设置 > 高级 > 环境变量中，添加环境变量名称为OHOS_HDC_LOG_LEVEL，变量值为5。配置完毕后点击确认。环境变量配置完成后，关闭并重启命令行或其他使用到HarmonyOS SDK的软件，以生效新配置的环境变量。 |
| Linux | 在~/.bash_profile文件末尾追加内容export OHOS_HDC_LOG_LEVEL=5并保存后，执行source ~/.bash_profile生效当前环境变量。 |
| MacOS | 在~/.zshrc文件末尾追加内容export OHOS_HDC_LOG_LEVEL=5并保存后，执行source ~/.zshrc生效当前环境变量。环境变量配置完成后，关闭并重启命令行或其他使用到HarmonyOS SDK的软件，以生效新配置的环境变量。 |
设备端日志
开启hilog日志工具，获取对应日志，命令如下：
```shell
hdc shell hilog -w start                              // 开启hilog日志落盘
hdc shell ls /data/log/hilog                          // 查看已落盘hilog日志
hdc file recv /data/log/hilog                         // 获取hilog已落盘日志（包含内核日志）
```
常见问题
设备无法识别
现象描述
命令行执行hdc list targets命令后，返回结果为[empty]。
可能原因&解决方法
可通过以下方式排查。
-  情况一：查看设备管理是否显示HDC设备。 Windows环境： 在设备管理器>通用串行总线设备中是否显示HDC Device（单一端口设备）或HDC Interface（复合端口设备）。 Linux环境： 在命令行执行lsusb,在返回的内容中查看是否有HDC Device（单一端口设备）或HDC Interface（复合端口设备）。 MacOS环境： 使用系统信息或系统概述来查看USB设备，步骤如下： 按住键盘上的Option键，点按菜单。 选取系统信息或系统概述。 在随后出现的窗口中，选择左边的USB。 在随后显示的设备树查看是否有HDC Device（单一端口设备）或HDC Interface（复合端口设备）。 可采取的解决方法 以上环境如没有显示HDC设备，则说明无法识别设备，可以根据实际场景尝试以下方法：
-  按住键盘上的Option键，点按菜单。
-  选取系统信息或系统概述。
-  在随后出现的窗口中，选择左边的USB。
-  在随后显示的设备树查看是否有HDC Device（单一端口设备）或HDC Interface（复合端口设备）。
-  情况二：存在USB设备，但是驱动损坏，显示"HDC Device"⚠警告图标。 现象描述：该问题常见于Windows环境，现象为设备管理器>通用串行总线设备中，HDC Device显示为黄标警告，且描述信息为该设备无法正常工作。可尝试重新安装驱动解决，如重新安装驱动无法解决，可以尝试更换USB连接数据线/拓展坞/USB接口。 重新安装驱动的方法 打开设备管理器，右键点击存在警告图标的HDC Device； 出现的菜单中点击更新驱动程序； 出现的提示窗口（第1/3个）中，选取浏览我的电脑以查找驱动程序； 出现的提示窗口（第2/3个）中，选取让我从计算机上的可用驱动程序列表中选取； 出现的提示窗口（第3/3个）中，取消勾选显示兼容硬件，选择厂商：WinUSB设备，选择型号：WinUSB设备，选择完成后点击下一步按钮。
-  打开设备管理器，右键点击存在警告图标的HDC Device；
-  出现的菜单中点击更新驱动程序；
-  出现的提示窗口（第1/3个）中，选取浏览我的电脑以查找驱动程序；
-  出现的提示窗口（第2/3个）中，选取让我从计算机上的可用驱动程序列表中选取；
-  出现的提示窗口（第3/3个）中，取消勾选显示兼容硬件，选择厂商：WinUSB设备，选择型号：WinUSB设备，选择完成后点击下一步按钮。
-  情况三：连接设备时出现[Fail]Failed to communicate with daemon。 现象描述：命令行执行hdc相关命令，执行失败返回[Fail]Failed to communicate with daemon。 可能存在以下原因，可参考排查： 常见于hdc和hdc_std使用同一端口，同时运行时OHOS_HDC_SERVER_PORT设置的端口互相冲突（未设置则使用默认端口8710，仍然会冲突），注意只运行其中一个。其他软件占用hdc默认端口也会导致该问题发生。
-  情况四：连接设备时出现Connect server failed。 出现该现象，可能有如下原因： 端口抢占 解决方法如下： 排查自带hdc的软件进程。 包括自带hdc的软件（DevEco Studio、DevEco Testing），如存在请关闭这些软件后再执行hdc相关命令。 查询HDC端口情况。 以设置的OHOS_HDC_SERVER_PORT为8710端口为例，在不同平台查询命令如下： Unix： Windows: 如存在抢占的软件，可以关闭该软件进程或者更换OHOS_HDC_SERVER_PORT环境变量为其他端口号。 排查未关闭的其他版本hdc server。 Windows： 使用任务管理器>详细信息查询hdc.exe进程,右键打开文件所在位置，核对位置是否为配置的环境变量中的hdc文件位置，如果不一致，可尝试结束hdc.exe进程(hdc kill或者任务管理器直接结束进程)并重新执行hdc命令。（关闭hdc server后执行hdc命令会重新启动hdc server） Unix： 使用ps -ef |grep hdc查询hdc后台server进程，核对进程启动位置是否为配置的环境变量中的hdc文件位置，如果不一致，可尝试结束hdc进程(hdc kill或者kill -9 hdc进程的PID)并重新执行hdc命令。（关闭hdc server后执行hdc命令会重新启动hdc server） 注册表异常 解决方法：清理注册表，步骤如下： 同时按下Win+R键，启动运行工具，输入栏输入regedit打开注册表。 注册表地址栏输入以下内容并按下回车，即可进入USB类设备驱动程序的注册表。 找到UpperFilters键，右键修改编辑，备份并清空其中数值数据内容（如清空后无法解决问题可依照备份恢复）。 刷新设备管理器/插拔USB接口/重启计算机。
```shell
netstat -an |grep 8710
```
-  端口抢占 解决方法如下： 排查自带hdc的软件进程。 包括自带hdc的软件（DevEco Studio、DevEco Testing），如存在请关闭这些软件后再执行hdc相关命令。 查询HDC端口情况。 以设置的OHOS_HDC_SERVER_PORT为8710端口为例，在不同平台查询命令如下： Unix： Windows: 如存在抢占的软件，可以关闭该软件进程或者更换OHOS_HDC_SERVER_PORT环境变量为其他端口号。 排查未关闭的其他版本hdc server。 Windows： 使用任务管理器>详细信息查询hdc.exe进程,右键打开文件所在位置，核对位置是否为配置的环境变量中的hdc文件位置，如果不一致，可尝试结束hdc.exe进程(hdc kill或者任务管理器直接结束进程)并重新执行hdc命令。（关闭hdc server后执行hdc命令会重新启动hdc server） Unix： 使用ps -ef |grep hdc查询hdc后台server进程，核对进程启动位置是否为配置的环境变量中的hdc文件位置，如果不一致，可尝试结束hdc进程(hdc kill或者kill -9 hdc进程的PID)并重新执行hdc命令。（关闭hdc server后执行hdc命令会重新启动hdc server）
```shell
netstat -an |grep 8710
```
-  排查自带hdc的软件进程。 包括自带hdc的软件（DevEco Studio、DevEco Testing），如存在请关闭这些软件后再执行hdc相关命令。
-  查询HDC端口情况。 以设置的OHOS_HDC_SERVER_PORT为8710端口为例，在不同平台查询命令如下： Unix： Windows: 如存在抢占的软件，可以关闭该软件进程或者更换OHOS_HDC_SERVER_PORT环境变量为其他端口号。
```shell
netstat -an |grep 8710
```
-  排查未关闭的其他版本hdc server。 Windows： 使用任务管理器>详细信息查询hdc.exe进程,右键打开文件所在位置，核对位置是否为配置的环境变量中的hdc文件位置，如果不一致，可尝试结束hdc.exe进程(hdc kill或者任务管理器直接结束进程)并重新执行hdc命令。（关闭hdc server后执行hdc命令会重新启动hdc server） Unix： 使用ps -ef |grep hdc查询hdc后台server进程，核对进程启动位置是否为配置的环境变量中的hdc文件位置，如果不一致，可尝试结束hdc进程(hdc kill或者kill -9 hdc进程的PID)并重新执行hdc命令。（关闭hdc server后执行hdc命令会重新启动hdc server）
-  注册表异常 解决方法：清理注册表，步骤如下： 同时按下Win+R键，启动运行工具，输入栏输入regedit打开注册表。 注册表地址栏输入以下内容并按下回车，即可进入USB类设备驱动程序的注册表。 找到UpperFilters键，右键修改编辑，备份并清空其中数值数据内容（如清空后无法解决问题可依照备份恢复）。 刷新设备管理器/插拔USB接口/重启计算机。
```shell
计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{88bae032-5a81-49f0-bc3d-a4ff138216d6}
```
-  同时按下Win+R键，启动运行工具，输入栏输入regedit打开注册表。
-  注册表地址栏输入以下内容并按下回车，即可进入USB类设备驱动程序的注册表。
```shell
计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{88bae032-5a81-49f0-bc3d-a4ff138216d6}
```
-  找到UpperFilters键，右键修改编辑，备份并清空其中数值数据内容（如清空后无法解决问题可依照备份恢复）。
-  刷新设备管理器/插拔USB接口/重启计算机。
1.  按住键盘上的Option键，点按菜单。
2.  选取系统信息或系统概述。
3.  在随后出现的窗口中，选择左边的USB。
4.  在随后显示的设备树查看是否有HDC Device（单一端口设备）或HDC Interface（复合端口设备）。
1.  打开设备管理器，右键点击存在警告图标的HDC Device；
2.  出现的菜单中点击更新驱动程序；
3.  出现的提示窗口（第1/3个）中，选取浏览我的电脑以查找驱动程序；
4.  出现的提示窗口（第2/3个）中，选取让我从计算机上的可用驱动程序列表中选取；
5.  出现的提示窗口（第3/3个）中，取消勾选显示兼容硬件，选择厂商：WinUSB设备，选择型号：WinUSB设备，选择完成后点击下一步按钮。
-  端口抢占 解决方法如下： 排查自带hdc的软件进程。 包括自带hdc的软件（DevEco Studio、DevEco Testing），如存在请关闭这些软件后再执行hdc相关命令。 查询HDC端口情况。 以设置的OHOS_HDC_SERVER_PORT为8710端口为例，在不同平台查询命令如下： Unix： Windows: 如存在抢占的软件，可以关闭该软件进程或者更换OHOS_HDC_SERVER_PORT环境变量为其他端口号。 排查未关闭的其他版本hdc server。 Windows： 使用任务管理器>详细信息查询hdc.exe进程,右键打开文件所在位置，核对位置是否为配置的环境变量中的hdc文件位置，如果不一致，可尝试结束hdc.exe进程(hdc kill或者任务管理器直接结束进程)并重新执行hdc命令。（关闭hdc server后执行hdc命令会重新启动hdc server） Unix： 使用ps -ef |grep hdc查询hdc后台server进程，核对进程启动位置是否为配置的环境变量中的hdc文件位置，如果不一致，可尝试结束hdc进程(hdc kill或者kill -9 hdc进程的PID)并重新执行hdc命令。（关闭hdc server后执行hdc命令会重新启动hdc server）
```shell
netstat -an |grep 8710
```
-  排查自带hdc的软件进程。 包括自带hdc的软件（DevEco Studio、DevEco Testing），如存在请关闭这些软件后再执行hdc相关命令。
-  查询HDC端口情况。 以设置的OHOS_HDC_SERVER_PORT为8710端口为例，在不同平台查询命令如下： Unix： Windows: 如存在抢占的软件，可以关闭该软件进程或者更换OHOS_HDC_SERVER_PORT环境变量为其他端口号。
```shell
netstat -an |grep 8710
```
-  排查未关闭的其他版本hdc server。 Windows： 使用任务管理器>详细信息查询hdc.exe进程,右键打开文件所在位置，核对位置是否为配置的环境变量中的hdc文件位置，如果不一致，可尝试结束hdc.exe进程(hdc kill或者任务管理器直接结束进程)并重新执行hdc命令。（关闭hdc server后执行hdc命令会重新启动hdc server） Unix： 使用ps -ef |grep hdc查询hdc后台server进程，核对进程启动位置是否为配置的环境变量中的hdc文件位置，如果不一致，可尝试结束hdc进程(hdc kill或者kill -9 hdc进程的PID)并重新执行hdc命令。（关闭hdc server后执行hdc命令会重新启动hdc server）
-  注册表异常 解决方法：清理注册表，步骤如下： 同时按下Win+R键，启动运行工具，输入栏输入regedit打开注册表。 注册表地址栏输入以下内容并按下回车，即可进入USB类设备驱动程序的注册表。 找到UpperFilters键，右键修改编辑，备份并清空其中数值数据内容（如清空后无法解决问题可依照备份恢复）。 刷新设备管理器/插拔USB接口/重启计算机。
```shell
计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{88bae032-5a81-49f0-bc3d-a4ff138216d6}
```
-  同时按下Win+R键，启动运行工具，输入栏输入regedit打开注册表。
-  注册表地址栏输入以下内容并按下回车，即可进入USB类设备驱动程序的注册表。
```shell
计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{88bae032-5a81-49f0-bc3d-a4ff138216d6}
```
-  找到UpperFilters键，右键修改编辑，备份并清空其中数值数据内容（如清空后无法解决问题可依照备份恢复）。
-  刷新设备管理器/插拔USB接口/重启计算机。
1.  排查自带hdc的软件进程。 包括自带hdc的软件（DevEco Studio、DevEco Testing），如存在请关闭这些软件后再执行hdc相关命令。
2.  查询HDC端口情况。 以设置的OHOS_HDC_SERVER_PORT为8710端口为例，在不同平台查询命令如下： Unix： Windows: 如存在抢占的软件，可以关闭该软件进程或者更换OHOS_HDC_SERVER_PORT环境变量为其他端口号。
```shell
netstat -an |grep 8710
```
3.  排查未关闭的其他版本hdc server。 Windows： 使用任务管理器>详细信息查询hdc.exe进程,右键打开文件所在位置，核对位置是否为配置的环境变量中的hdc文件位置，如果不一致，可尝试结束hdc.exe进程(hdc kill或者任务管理器直接结束进程)并重新执行hdc命令。（关闭hdc server后执行hdc命令会重新启动hdc server） Unix： 使用ps -ef |grep hdc查询hdc后台server进程，核对进程启动位置是否为配置的环境变量中的hdc文件位置，如果不一致，可尝试结束hdc进程(hdc kill或者kill -9 hdc进程的PID)并重新执行hdc命令。（关闭hdc server后执行hdc命令会重新启动hdc server）
1.  同时按下Win+R键，启动运行工具，输入栏输入regedit打开注册表。
2.  注册表地址栏输入以下内容并按下回车，即可进入USB类设备驱动程序的注册表。
```shell
计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{88bae032-5a81-49f0-bc3d-a4ff138216d6}
```
3.  找到UpperFilters键，右键修改编辑，备份并清空其中数值数据内容（如清空后无法解决问题可依照备份恢复）。
4.  刷新设备管理器/插拔USB接口/重启计算机。
hdc无法运行
现象描述
使用命令行执行hdc.exe/hdc 二进制文件无法运行。
可能原因&解决方法
-  运行环境异常 Linux运行环境：建议使用Ubuntu18.04及以上64版本，如出现libc++.so引用错误，请使用ldd/readelf等命令检查库引用。 MacOS运行环境：建议使用MacOS 11及以上版本。 Windows运行环境：建议使用Windows10/Windows11 64位版本，如低版本缺失WinUSB库/驱动，请使用Zadig工具更新。对于符合设备，需要使用Zadig工具安装libusb-win32驱动。详情请见：Zadig链接。
-  运行方式不当：请使用命令行依照正确命令运行hdc工具，而非鼠标双击文件。
其他问题排查常用步骤

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/aa-tool-V14
爬取时间: 2025-04-28 19:22:13
来源: Huawei Developer
Ability assistant（Ability助手，简称为aa），是用于启动应用和启动测试用例的工具，为开发者提供基本的应用调试和测试能力，例如启动应用组件、强制停止进程、打印应用组件相关信息等。
环境要求
在使用本工具前，开发者需要先获取hdc工具，执行hdc shell。
本文中命令介绍均基于交互式命令环境。如果直接执行hdc shell [aa命令]，则需要采用""来包裹aa命令，确保命令中的传参能被正确识别。示例如下：
aa工具命令列表
| 命令 | 描述 |
| --- | --- |
| -h/help | 帮助命令。用于查询aa支持的命令信息。 |
| start | 启动命令。用于启动一个应用组件，目标组件可以是FA模型的PageAbility和ServiceAbility组件，也可以是Stage模型的UIAbility和ServiceExtensionAbility组件，且目标组件相应配置文件中的exported标签不能配置为false。 |
| stop-service | 停止命令。用于停止ServiceAbility。 |
| dump(deprecated) | 打印命令。用于打印应用组件的相关信息。 |
| force-stop | 强制停止进程命令。通过bundleName强制停止一个进程。 |
| test | 启动测试框架命令。根据所携带的参数启动测试框架。 |
| attach | 进入调试模式命令。通过bundleName使指定应用进入调试模式。 |
| detach | 退出调试模式命令。通过bundleName使指定应用退出调试模式。 |
| appdebug | 等待调试命令。用于设置、取消设置应用等待调试状态，以及获取处于等待调试状态的应用包名和持久化信息。等待调试状态只对debug类型应用生效。appdebug的设置命令只对单个应用生效，当重复设置时，应用包名与持久化状态会替换成最新设置内容。 |
| process | 应用调试/调优命令。对应用进行调试或调优，IDE用该命令集成调试和调优工具。 |
帮助命令（help）
启动命令（start）
启动一个应用组件，目标组件可以是FA模型的PageAbility和ServiceAbility组件，也可以是Stage模型的UIAbility和ServiceExtensionAbility组件，且目标组件相应配置文件中的exported标签不能配置为false。
启动命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助信息。 |
| -d | 可选参数，deviceId。 |
| -a | 可选参数，abilityName。 |
| -b | 可选参数，bundleName。 |
| -m | 可选参数，moduleName。 |
| -U | 可选参数，URI。 |
| -A | 可选参数，action。 |
| -e | 可选参数，entity。 |
| -t | 可选参数，type。 |
| --pi | 可选参数，整型类型键值对。 |
| --pb | 可选参数，布尔类型键值对。 |
| --ps | 可选参数，字符串类型键值对。 |
| --psn | 可选参数，空字符串关键字。 |
| --wl | 可选参数，windowLeft，窗口左边距，单位px。 约束： 仅当2in1设备处于开发者模式下，且被启动应用采用调试签名时，该字段生效。 |
| --wt | 可选参数，windowTop，窗口上边距，单位px。 约束： 仅当2in1设备处于开发者模式下，且被启动应用采用调试签名时，该字段生效。 |
| --wh | 可选参数，windowHeight，窗口高度，单位px。 约束： 仅当2in1设备处于开发者模式下，且被启动应用采用调试签名时，该字段生效。 |
| --ww | 可选参数，windowWidth，窗口宽度，单位px。 约束： 仅当2in1设备处于开发者模式下，且被启动应用采用调试签名时，该字段生效。 |
| -R | 可选参数，调试时是否开启多线程错误检测。携带该参数代表开启，不携带代表关闭。 说明： 从API version 14开始，支持该参数。 |
| -S | 可选参数，调试时是否进入应用沙箱。携带该参数代表进入，不携带代表不进入。 |
| -D | 可选参数，调试模式。 |
| -p | 可选参数，调优命令。命令由调用方自定义。 |
可选参数，windowLeft，窗口左边距，单位px。
约束：
仅当2in1设备处于开发者模式下，且被启动应用采用调试签名时，该字段生效。
可选参数，windowTop，窗口上边距，单位px。
约束：
仅当2in1设备处于开发者模式下，且被启动应用采用调试签名时，该字段生效。
可选参数，windowHeight，窗口高度，单位px。
约束：
仅当2in1设备处于开发者模式下，且被启动应用采用调试签名时，该字段生效。
可选参数，windowWidth，窗口宽度，单位px。
约束：
仅当2in1设备处于开发者模式下，且被启动应用采用调试签名时，该字段生效。
可选参数，调试时是否开启多线程错误检测。携带该参数代表开启，不携带代表关闭。
说明：从API version 14开始，支持该参数。
返回值：
当启动成功时，返回"start ability successfully."；当启动失败时，返回"error: failed to start ability."，同时会包含相应的失败信息。
示例：
以隐式启动Ability为例。
本例中仅介绍了部分字段的使用。关于Ability匹配的详细规则参考显式Want与隐式Want匹配规则。
-  目标应用：修改module.json5配置，为目标Ability配置uris。
```json
{
"name": "TargetAbility",
// ......
"exported": true,
"skills": [
{
"actions":[
"ohos.want.action.viewData"
],
"uris":[
{
"scheme": "myscheme",
"host": "www.test.com",
"port": "8080",
"path": "path",
}
]
}
]
}
```
-  拉起方应用: 隐式启动Ability。 如果需要拉起应用的页面，可以使用-U命令，示例如下： 在上述基础上，如果需要携带参数，可以使用如下命令： UIAbility获取传入参数示例如下： 如果需要拉起浏览器并跳转指定页面，可以使用-A -U命令，示例如下： 本例中以https://www.example.com为例，请根据实际情况替换为真实的网址。
-  如果需要拉起应用的页面，可以使用-U命令，示例如下：
-  在上述基础上，如果需要携带参数，可以使用如下命令： UIAbility获取传入参数示例如下：
-  如果需要拉起浏览器并跳转指定页面，可以使用-A -U命令，示例如下： 本例中以https://www.example.com为例，请根据实际情况替换为真实的网址。
-  如果需要拉起应用的页面，可以使用-U命令，示例如下：
-  在上述基础上，如果需要携带参数，可以使用如下命令： UIAbility获取传入参数示例如下：
-  如果需要拉起浏览器并跳转指定页面，可以使用-A -U命令，示例如下： 本例中以https://www.example.com为例，请根据实际情况替换为真实的网址。
停止命令（stop-service）
用于停止ServiceAbility。
停止命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助信息。 |
| -d | 可选参数，deviceId。 |
| -a | 必选参数，abilityName。 |
| -b | 必选参数，bundleName。 |
| -m | 可选参数，moduleName。 |
返回值：
当成功停止ServiceAbility时，返回"stop service ability successfully."；当停止失败时，返回"error: failed to stop service ability."。
示例：
打印命令（dump(deprecated)）
用于打印应用组件的相关信息。
aa dump命令从API version 7开始支持，从API version 9废弃，替换命令为hidumper-s AbilityManagerService。
打印命令参数列表
| 参数 | 二级参数 | 参数说明 |
| --- | --- | --- |
| -h/--help | - | 帮助信息。 |
| -a/--all | - | 打印所有mission内的应用组件信息。 |
| -l/--mission-list | type（缺省打印全部） | 服务侧为了方便管理任务链，内部维护了4种类型的任务链。 可取值： - NORMAL：正常启动的任务链(比如A拉起B拉起C, 则对应的任务链是A->B->C) - DEFAULT_STANDARD：已经被破坏的任务链中的任务, 启动模式为multiton的任务被放到该任务链中, 这里面的任务之间没有关联关系 - DEFAULT_SINGLE：已经被破坏的任务链中的任务, 启动模式为singleton的任务被放到该任务链中, 这里面的任务之间没有关联关系 - LAUNCHER：launcher的任务链 |
| -e/--extension | elementName | 打印扩展组件信息。 |
| -u/--userId | UserId | 打印指定UserId的栈信息，需要和其他参数组合使用，例如aa dump -a -u 100、aa dump -d -u 100。 |
| -d/--data | - | 打印DataAbility相关信息。 |
| -i/--ability | AbilityRecord ID | 打印指定应用组件详细信息。 |
| -c/--client | - | 打印应用组件详细信息，需要和其他参数组合使用，例如aa dump -a -c、aa dump -i 21 -c。 |
| -p/--pending | - | 打印pendingWant信息，需要和其他参数组合使用，例如aa dump -a -p。 |
| -r/--process | - | 打印应用进程信息，需要和其他参数组合使用，例如aa dump -a -r。 |
服务侧为了方便管理任务链，内部维护了4种类型的任务链。
可取值：
- NORMAL：正常启动的任务链(比如A拉起B拉起C, 则对应的任务链是A->B->C)
- DEFAULT_STANDARD：已经被破坏的任务链中的任务, 启动模式为multiton的任务被放到该任务链中, 这里面的任务之间没有关联关系
- DEFAULT_SINGLE：已经被破坏的任务链中的任务, 启动模式为singleton的任务被放到该任务链中, 这里面的任务之间没有关联关系
- LAUNCHER：launcher的任务链
示例：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170531.08833069609207259279600561216643:50001231000000:2800:893E2A6440B04B45A48E100655EA0D488B4A20BDA7A7C3296CC46742C68CCD2B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170531.49645281617997103050279127077320:50001231000000:2800:4C5B5B7A5945AD0A04ECFF90F5EB80800B2F20D8AEC5E2F5199B14AF878521BE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170531.90271386229771087913525417514314:50001231000000:2800:77D6EAD990E99474274FE2302A5F2BDC8C7C028E9200430C0EA112D6715B9988.png)
强制停止进程命令（force-stop）
通过bundleName强制停止一个进程。
返回值：
当成功强制停止该进程时，返回"force stop process successfully."；当强制停止失败时，返回"error: failed to force stop process."。
示例：
启动测试框架命令（test）
根据所携带的参数启动测试框架。
关于class、level、size、testType等参数的详细说明请参见aa test命令执行配置参数。
启动测试框架命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助信息。 |
| -b | 必选参数，bundleName。 |
| -s unittest | 必选参数，testRunner。 |
| -p | 可选参数，testRunner的packageName。 说明：该可选参数仅可在FA模型下使用。 |
| -m | 可选参数，testRunner的moduleName。 说明：该可选参数仅可在Stage模型下使用。 |
| -s class | 可选参数，指定要执行的测试套或测试用例。 |
| -s level | 可选参数，指定要执行用例的用例级别。 |
| -s size | 可选参数，指定要执行用例的用例规模。 |
| -s testType | 可选参数，指定要执行用例的用例类型。 |
| -s timeout | 可选参数，测试用例执行的超时时间（单位ms），默认为5000。 |
| -s <any-key> | 可选参数，任意键值对。 |
| -w | 可选参数，指定测试运行时间（单位ms）。 |
| -D | 可选参数，调试模式。 |
可选参数，testRunner的packageName。
说明：该可选参数仅可在FA模型下使用。
可选参数，testRunner的moduleName。
说明：该可选参数仅可在Stage模型下使用。
返回值：
当成功启动测试框架时，返回"user test started."；当启动失败时，返回"error: failed to start user test."和对应的错误信息。
示例：
进入调试模式命令（attach）
通过bundleName使指定应用进入调试模式。
进入调试模式命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助信息。 |
| -b | 必选参数，bundleName。 |
返回值：
当应用成功进入调试模式时，返回"attach app debug successfully."；当给定参数不合法时，返回"fail: unknown option."并打印帮助信息。
示例：
退出调试模式命令（detach）
通过bundleName使指定应用退出调试模式。
退出调试模式命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助信息。 |
| -b | 必选参数，bundleName。 |
返回值：
当应用成功退出调试模式时，返回"detach app debug successfully."；当给定参数不合法时，返回"fail: unknown option."并打印帮助信息。
示例：
等待调试命令（appdebug）
用于设置、取消设置应用等待调试状态，以及获取处于等待调试状态的应用包名和持久化信息。等待调试状态只对debug类型应用生效。appdebug的设置命令只对单个应用生效，当重复设置时，应用包名与持久化状态会替换成最新设置内容。
等待调试命令参数列表
| 参数 | 二级参数 | 参数说明 |
| --- | --- | --- |
| -h/--help | - | 帮助信息。 |
| -b/--bundlename | bundleName | 为指定应用设置等待调试状态。设置时，不会进行包名合法化的校验。 |
| -p/--persist | - | 可选参数；持久化标志位，加入该参数，代表持续设置应用为等待调试状态，无论重启设备、重装应用都可以持续生效；不加入该参数，代表等待调试状态仅可以在重启设备前生效一次。需要和-b参数组合使用，例如：aa appdebug -b <bundleName> -p。 |
| -c/--cancel | - | 取消等待调试状态。 |
| -g/--get | - | 获取等待调试状态的应用包名和持久化信息。 |
返回值：
当执行成功时，返回"app debug successfully."；当执行失败时，返回"error: failed to app debug."；当失败原因为非开发者模式时，返回"error: not developer mode."。
示例：
应用调试/调优命令（process）
对应用进行调试或调优，IDE用该命令集成调试和调优工具。
应用调试/调优命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助信息。 |
| -b | 必选参数，bundleName。 |
| -a | 必选参数，abilityName。 |
| -m | 可选参数，moduleName。 |
| -p | 可选参数，调优命令，与-D必须二选一。命令由调用方自定义。 |
| -D | 可选参数，调试命令，与-p必须二选一。命令由调用方自定义。 |
| -S | 可选参数，进入应用沙箱。 |
返回值：
当执行成功时，返回"start native process successfully."；当执行失败时，返回"error: failed to start native process."；当给定参数不合法时，返回"error: option requires a value."并打印帮助信息。
示例：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/bm-tool-V14
爬取时间: 2025-04-28 19:22:27
来源: Huawei Developer
Bundle Manager（包管理工具，简称bm）是实现应用安装、卸载、更新、查询等功能的工具，bm为开发者提供基本的应用安装包的调试能力。
环境要求
在使用本工具前，开发者需要先获取hdc工具，执行hdc shell。
bm工具命令列表
| 命令 | 描述 |
| --- | --- |
| help | 帮助命令，用于查询bm支持的命令信息。 |
| install | 安装命令，用于安装应用。 |
| uninstall | 卸载命令，用于卸载应用。 |
| dump | 查询命令，用于查询应用的相关信息。 |
| clean | 清理命令，用于清理应用的缓存和数据。此命令在root版本下可用，在user版本下打开开发者模式可用。其它情况不可用。 |
| get | 获取udid命令，用于获取设备的udid。 |
| quickfix | 快速修复相关命令，用于执行补丁相关操作，如补丁安装、补丁查询。 |
| compile | 应用执行编译AOT命令。 |
| copy-ap | 把应用的ap文件拷贝到/data/local/pgo目录下，供shell用户读取文件。 |
| dump-dependencies | 查询应用依赖的模块信息。 |
| dump-shared | 查询应用间HSP应用信息。 |
| dump-overlay | 打印overlay应用的overlayModuleInfo。 |
| dump-target-overlay | 打印目标应用的所有关联overlay应用的overlayModuleInfo。 |
帮助命令（help）
安装命令（install）
安装命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h | 帮助信息。 |
| -p | 必选参数，指定路径和多个HAP同时安装。 |
| -r | 可选参数，覆盖安装一个HAP。默认值为覆盖安装。 |
| -s | 根据场景判断，安装应用间HSP时为必选参数，其他场景为可选参数。安装应用间共享库， 每个路径目录下只能存在一个同包名的HSP。 |
| -w | 可选参数，安装HAP时指定bm工具等待时间，最小的等待时长为5s，最大的等待时长为600s, 默认缺省为5s。 |
示例：
卸载命令（uninstall）
卸载命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h | 帮助信息。 |
| -n | 必选参数，指定Bundle名称卸载应用。 |
| -m | 可选参数，指定卸载应用的一个模块。默认卸载所有模块。 |
| -k | 可选参数，卸载应用时保存应用数据。默认卸载应用时不保存应用数据。 |
| -s | 根据场景判断，安装应用间HSP时必选参数，其他场景为可选参数。卸载指定的共享库。 |
| -v | 可选参数，指定共享包的版本号。默认卸载同包名的所有共享包。 |
示例：
查询应用信息命令（dump）
查询命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h | 帮助信息。 |
| -a | 可选参数，查询系统已经安装的所有应用。 |
| -n | 可选参数，查询指定Bundle名称的详细信息。 |
| -s | 可选参数，查询指定Bundle名称下的快捷方式信息。 |
| -d | 可选参数，查询指定设备中的包信息。默认查询当前设备。 |
示例：
清理命令（clean）
清理命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h | 帮助信息。 |
| -c -n | -n为必选参数，-c为可选参数。清除指定Bundle名称的缓存数据。 |
| -d -n | -n为必选参数，-d为可选参数。清除指定Bundle名称的数据目录。 |
| -i | 可选参数，清除分身应用的数据目录。默认为0。 |
示例：
获取udid命令（get）
获取udid命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h | 帮助信息。 |
| -u | 必选参数，获取设备的udid。 |
示例：
快速修复命令（quickfix）
注：hqf文件制作方式可参考HQF打包指令。
快速修复命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h | 帮助信息。 |
| -a -f | -a为可选参数，指定-a后，-f为必选参数。执行快速修复补丁安装命令，file-path对应hqf文件，支持传递1个或多个hqf文件，或传递hqf文件所在的目录。 |
| -q -b | -q为可选参数，指定-q后，-b为必选参数，未指定-q。根据包名查询补丁信息。 |
| -r -b | -r为可选参数，指定-r后，-b为必选参数。根据包名卸载未使能的补丁。 |
| -t | 可选参数，快速修复应用到指定目标路径。 |
| -d | 可选参数，应用快速修复调试模式。 |
示例：
共享库查询命令（dump-shared）
共享库查询命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h | 帮助信息。 |
| -a | 可选参数，查询系统中已安装所有共享库。 |
| -n | 可选参数，查询指定共享库包名的详细信息。 |
| -m | 可选参数，查询指定共享库包名和模块名的详细信息。 |
示例：
共享库依赖关系查询命令（dump-dependencies）
显示指定应用和指定模块依赖的共享库信息。
共享库依赖关系查询命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h | 帮助信息。 |
| -n | 必选参数，查询指定共享库包名的详细信息。 |
| -m | 可选参数，查询指定应用指定模块依赖的共享库信息。 |
示例：
应用执行编译AOT命令（compile）
应用执行编译AOT命令。
compile命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h | 帮助信息。 |
| -a | 可选参数，编译所有应用。 |
| -m | 可选参数，可选值为partial或者full。根据包名编译应用。 |
| -r | 可选参数，移除应用的结果。 |
示例：
拷贝ap文件命令（copy-ap）
拷贝ap文件到指定应用的/data/local/pgo路径。
copy-ap命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h | 帮助信息。 |
| -a | 可选参数，默认所有包相关ap文件。拷贝所有包相关ap文件。 |
| -n | 可选参数，默认当前应用包名。根据包名拷贝对应包相关的ap文件。 |
示例：
查询overlay应用信息命令（dump-overlay）
打印overlay应用的overlayModuleInfo。
dump-overlay命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h | 帮助信息。 |
| -b | 必选参数，获取指定应用的所有OverlayModuleInfo信息。 |
| -m | 可选参数，默认当前应用主模块名。根据指定的包名和module名查询OverlayModuleInfo信息。 |
| -t | 可选参数，根据指定的包名和目标module名查询OverlayModuleInfo信息。 |
示例：
查询应用的overlay相关信息命令（dump-target-overlay）
查询目标应用的所有关联overlay应用的overlayModuleInfo信息。
dump-target-overlay命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h | 帮助信息。 |
| -b | 必选参数，获取指定应用的所有OverlayBundleInfo信息。 |
| -m | 可选参数，默认当前应用主模块名。根据指定的包名和module名查询OverlayBundleInfo信息。 |
示例：
bm工具错误码
9568320 签名文件不存在
错误信息
Failed to install bundle, no signature file.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170531.86213037353088664334685741822134:50001231000000:2800:FCB9F113DB7E41659FE7940221ED0DC85DC2A767EE43B460671301467C4C8412.png)
错误描述
用户安装未签名的HAP包。
可能原因
HAP包没有签名。
处理步骤
1.  使用手动签名，请参考手动签名。
9568347 解析本地so文件失败
错误信息
Error: install parse native so failed.
错误描述
在启动调试或运行C++应用/服务时，安装HAP包出现错误，提示“error: install parse native so failed”错误信息。
可能原因
设备支持的Abi类型与C++工程中配置的Abi类型不匹配。
-  如果工程依赖的三方库包含so文件，请确保oh_modules/三方库/libs目录包含有设备支持的Abi目录，如libs/arm64-v8a、/libs/x86_64。 对于HarmonyOS应用，在DevEco Studio NEXT Developer Beta1（5.0.3.200）及以上版本不支持编译armeabi-v7a架构的so文件。
处理步骤
1.  若返回结果为armeabi-v7a/armeabi/arm64-v8a/x86/x86_64中的一个或多个，需要在“abiFilters”参数中至少包含返回结果中的一个Abi类型。
2.  若返回结果为armeabi-v7a/armeabi/arm64-v8a/x86/x86_64中的一个或多个，需要在“abiFilters”参数中至少包含返回结果中的一个Abi类型。
-  若返回结果为armeabi-v7a/armeabi/arm64-v8a/x86/x86_64中的一个或多个，需要在“abiFilters”参数中至少包含返回结果中的一个Abi类型。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.05181322571590107697317749439991:50001231000000:2800:7EA92AC4B2FBA7DDB07B233F7141EDF2A6645BA106DC2E0B76823CAA6BC01A05.png)
9568344 解析配置文件失败
错误信息
Error: install parse profile prop check error.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.69126313759744680417825504825278:50001231000000:2800:19EB73FB9872B38CA7523E4C2FE38F9482FA9B94034EA5FF750B48297A925CBD.png)
错误描述
在启动调试或运行应用/服务时，安装HAP出现错误，提示“error: install parse profile prop check error”错误信息。
可能原因
处理步骤
9568305 依赖的模块不存在
错误信息
Error: dependent module does not exist.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.66431608135696422419148228161019:50001231000000:2800:7E6CD433C4A34D14FCBDCFAB3A02E7EB0B09819C44A9659FA4CF3CE64A3FC8A6.png)
错误描述
在启动调试或运行应用/服务时，安装HAP出现错误，提示“error: dependent module does not exist”错误信息。
可能原因
运行/调试的应用依赖的动态共享包（SharedLibrary）模块未安装导致安装报错。
处理步骤
1.  先安装依赖的动态共享包（SharedLibrary）模块，再在应用运行配置页勾选Keep Application Data，点击OK保存配置，再运行/调试。
2.  在运行配置页，选择Deploy Multi Hap标签页，勾选Deploy Multi Hap Packages，选择依赖的模块，点击OK保存配置，再进行运行/调试。
3.  单击Run > Edit Configurations，在General中，勾选Auto Dependencies。点击OK保存配置，再运行/调试。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.57540535883103340563831707274016:50001231000000:2800:AEAB4793837A2BBB43DB492852CD8039B9848961B83403DC76A0DE40F5484A41.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.97645120207451080719266958893126:50001231000000:2800:8C2928B818B1B2779DEC4591E0FEC72FC7A98A02E1B9DB27C40D8BAC40331F21.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.84540407826700424527775582933448:50001231000000:2800:48DF2ED340E0B2394A531DC6ACD09E8C477D0FDC239F487BFAD2B2D6F49E463E.png)
9568259 安装解析配置文件缺少字段
错误信息
Error: install parse profile missing prop.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.80065946329988868928632674670739:50001231000000:2800:EE803C37FEDAD2F288C90561BD89F32D8F68436693A6423CC615F9AA1AFB99F2.png)
错误描述
在启动调试或运行应用/服务时，安装HAP出现错误，提示“error: install parse profile missing prop”错误信息。
可能原因
配置文件app.json5和module.json5中必填字段缺失。
处理步骤
-  方法1：请参考app.json5配置文件和module.json5配置文件查看并补充必填字段。
-  方法2：通过hilog日志判断缺失字段。 开启落盘命令： 落盘位置：/data/log/hilog。 打开日志查看“profile prop %{public}s is mission”。如“profile prop icon is mission”表示“icon”字段缺失。
9568258 安装应用的releaseType与已安装应用的releaseType不相同
错误信息
Error: install releaseType target not same.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.63370760536120138053279415918262:50001231000000:2800:4276C468714929D1023ED23F81CF14DF84401B056E7A2DB20DA7469986D70CA2.png)
错误描述
在启动调试或运行应用/服务时，安装HAP出现错误，提示“error: install releaseType target not same”错误信息。
可能原因
处理步骤
9568322 由于应用来源不可信，签名验证失败
错误信息
Error: signature verification failed due to not trusted app source.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.22167367322059283078999187206572:50001231000000:2800:42FC0F9F6306BAAD96CECD0BA38C8EC50B0F9187E66BDC5B0115827E1F968182.png)
错误描述
在启动调试或运行应用/服务时，安装HAP出现错误，提示“error: signature verification failed due to not trusted app source”错误信息。
可能原因
-  场景一：签名中未包含该调试设备的UDID。
-  场景二：签名时使用了发布证书和发布profile文件。发布证书签名的应用不能启动调试或运行。
处理步骤
-  场景一： 使用自动签名。在连接设备后，重新为应用进行签名。 如果使用的是手动签名，对于HarmonyOS应用，请参考手动签名，在UnsgnedDebugProfileTemplate.json文件中添加该调试设备的UDID。
-  使用自动签名。在连接设备后，重新为应用进行签名。
-  如果使用的是手动签名，对于HarmonyOS应用，请参考手动签名，在UnsgnedDebugProfileTemplate.json文件中添加该调试设备的UDID。
-  场景二：使用调试证书和调试profile文件重新签名应用。
1.  使用自动签名。在连接设备后，重新为应用进行签名。
2.  如果使用的是手动签名，对于HarmonyOS应用，请参考手动签名，在UnsgnedDebugProfileTemplate.json文件中添加该调试设备的UDID。
9568289 权限请求失败导致安装失败
错误信息
Error: install failed due to grant request permissions failed.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.64900700901703086375784706777304:50001231000000:2800:921811D229187636492D2D61DECE584847644B13C0B9CF5761836DAA293B388C.png)
错误描述
在启动调试或运行应用/服务时，安装HAP出现错误，提示“error: install failed due to grant request permissions failed”错误信息。
可能原因
默认应用等级为normal，只能使用normal等级的权限，如果使用了system_basic或system_core等级的权限，将导致报错。
处理步骤
9568297 由于设备sdk版本较低导致安装失败
错误信息
Error: install failed due to older sdk version in the device.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.34032437694086569971861936119657:50001231000000:2800:533440C9B515CA545D654A36553F13569B30BDFAAD2A28D9A21198497D7BA414.png)
错误描述
在启动调试或运行应用/服务时，安装HAP出现错误，提示“error: install failed due to older sdk version in the device”错误信息。
可能原因
该问题是由于编译打包所使用的SDK版本与设备镜像版本不匹配。
处理步骤
-  场景一：设备上的镜像版本低于编译打包的SDK版本，请更新设备镜像版本。查询设备镜像版本命令： 如果镜像提供的api版本为10，且应用编译所使用的SDK版本也为10，仍出现该报错，可能是由于镜像版本较低，未兼容新版本SDK校验规则，请将镜像版本更新为最新版本。
-  场景二：对于需要运行在HarmonyOS设备上的应用，请确认runtimeOS已改为HarmonyOS。
9568332 签名不一致导致安装失败
错误信息
Error: install sign info inconsistent.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.09490705863892883155332442282827:50001231000000:2800:1777953B03BC2D459F64E54F2BCC2F093F90F2A1476B769AB7065D9F7CF95796.png)
错误描述
在启动调试或运行应用/服务时，安装HAP出现错误，提示“error: install sign info inconsistent”错误信息。
可能原因
处理步骤
9568329 签名信息验证失败
错误信息
Error: verify signature failed.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.35011548120952158056974557268411:50001231000000:2800:41C2790BC2F1EB383AC078B75653B75500090E6ADBEB836AE0AE9A5B1E16ED92.png)
错误描述
签名信息中的包名与应用的包名（bundleName）不一致。
可能原因
-  场景一：用户导入了三方提供的HSP模块，且该HSP既非集成态HSP，又非同包名的HSP，造成包名不一致。
-  场景二：用户使用了错误的签名文件（后缀为.p7b）进行签名，造成包名不一致。
处理步骤
-  场景一：HSP只能给同包名的应用使用，只有集成态HSP可以给不同包名的应用使用。需要用户与三方开发者确认，三方开发者应提供集成态HSP、或同包名的HSP给用户使用。
-  场景二：检查签名流程和签名证书，参考应用/服务签名。
9568266 安装权限拒绝
错误信息
Error: install permission denied.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170532.23425356144858627201389442742662:50001231000000:2800:08681363D165DF7D50B25FE9F6FA6E2E4E0C2F6055051698AC1056BCD30ACFF0.png)
错误描述
使用hdc install安装HAP时出现错误，提示“code:9568266 error: install permission denied”错误信息。
可能原因
hdc install不能安装release签名的企业应用。
处理步骤
9568337 安装解析失败
错误信息
Error: install parse unexpected.
错误描述
应用推送到设备安装时，报错包管理打开hap文件失败。
可能原因
-  场景一：设备system分区存储空间已满，导致hdc file send文件后，因存储空间不足导致设备中文件损坏。
-  场景二：推送hap包到设备过程hap包损坏。
处理步骤
-  场景一：查看设备system分区存储空间，若已满，清理存储满足安装所需空间。
-  场景二：查看本地hap与推送到设备上hap的md5值，若不一致则表示推送过程hap损毁，请尝试重传。
9568316 数据代理中APL权限字段描述权限低
错误信息
Error: apl of required permission in proxy data is too low.
错误描述
proxyData标签requiredReadPermission和requiredWritePermission属性验证失败。
可能原因
用户工程module.json中，proxyData标签requiredReadPermission和requiredWritePermission属性验证失败，这两个属性要求system_basic或system_core权限等级。
处理步骤
9568315 数据代理URI错误
错误信息
Error: uri in proxy data is wrong.
错误描述
proxyData标签uri属性验证失败。
可能原因
用户工程module.json中，proxyData标签uri属性验证失败，不满足uri格式要求。
处理步骤
9568336 应用调试类型与已安装应用不一致
错误信息
Error: install debug type not same.
错误描述
应用调试类型（app.json的debug字段）与已安装应用不一致。
可能原因
开发者使用DevEco Studio的debug按钮安装了应用，后面打包之后又通过hdc install方式安装。
处理步骤
9568296 包类型错误
错误信息
Error: install failed due to error bundle type.
错误描述
bundleType错误导致应用安装失败。
可能原因
新安装应用的bundleType与已安装的有相同bundleName应用不一致。
处理步骤
-  方法一：卸载已安装的应用，重新安装新应用。
-  方法二：修改应用的bundleType，与已安装应用保持一致。
9568292 UserID为0的用户只能安装singleton应用
错误信息
Error: install failed due to zero user can only install singleton app.
错误描述
UserID 0用户只允许安装singleton权限应用，singleton权限应用只允许被UserID 0用户安装。
可能原因
singleton权限应用安装未指定UserID 0。
处理步骤
9568263 无法降级安装
错误信息
Error: install version downgrade.
错误描述
正在安装应用的VersionCode小于系统中已安装应用的VersionCode，安装失败。
可能原因
正在安装应用的VersionCode小于系统中已安装应用的VersionCode。
处理步骤
9568304 应用不支持当前设备类型
错误信息
Error: device type is not supported.
错误描述
正在安装的应用不支持当前设备类型，安装失败。
可能原因
正在安装的应用不支持当前设备类型。
处理步骤
9568317 应用的多进程配置与系统配置不匹配
错误信息
Error: isolationMode does not match the system.
错误描述
安装应用时，设置的isolationMode与系统配置项允许的系统配置不匹配。
可能原因
-  场景一：设备支持隔离模式，即persist.bms.supportIsolationMode为true时，HAP配置的isolationMode为nonisolationOnly。
-  场景二：设备不支持隔离模式，即persist.bms.supportIsolationMode为false时，HAP配置的isolationMode为isolationOnly。
处理步骤
9568315 数据代理的uri属性错误
错误信息
Error: uri in proxy data is wrong.
错误描述
应用module.json文件中proxyData标签的uri属性验证失败。
可能原因
uri不满足格式规范。
处理步骤
9568310 兼容策略不同
错误信息
Error: compatible policy not same.
错误描述
新包与已安装包兼容策略不同。
可能原因
处理步骤
9568391 包管理服务已停止
错误信息
Error: bundle manager service is died.
错误描述
包管理服务已停止。
可能原因
系统出现未知的异常，导致包管理服务已停止或者异常退出。
处理步骤
1.  重启手机后再次尝试安装应用。
2.  重复上述步骤3到5次后依旧安装失败，请查询设备的/data/log/faultlog/faultlogger/目录下是否存在包含foundation字样的crash文件。
9568393 验证代码签名失败
错误信息
Error: verify code signature failed.
错误描述
验证代码签名失败。
可能原因
包没有代码签名信息。
处理步骤
9568257 验证pkcs7文件失败
错误信息
Error: fail to verify pkcs7 file.
错误描述
验证pkcs7文件失败。
可能原因
应用当前使用的签名不符合HarmonyOS应用签名要求。
处理步骤
在为应用/服务签名时勾选“Support HarmonyOS”，完成HarmonyOS应用签名后再次启动调试或运行应用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170533.25514057962141759247990631266830:50001231000000:2800:AA11A3D1F7D42CA20276A79CA6FC5C2CA12308095CAF59E95EB2531AAE352B3C.png)
9568401 调试包仅支持运行在开发者模式设备
错误信息
Error: debug bundle can only be installed in developer mode.
错误描述
调试包仅支持运行在开发者模式设备。
可能原因
终端设备未开启“开发者模式”。
处理步骤
9568386 卸载的应用不存在
错误信息
Error: uninstall missing installed bundle.
错误描述
卸载的应用不存在。
可能原因
要卸载的应用没有安装。
处理步骤
9568388 企业设备管理不允许卸载该应用
错误信息
Error: Failed to uninstall the HAP because the uninstall is forbidden by enterprise device management.
错误描述
企业设备管理不允许卸载该应用。
可能原因
应用被设置为不允许被卸载。
处理步骤
9568284 安装版本不匹配
错误信息
Error: install version not compatible.
错误描述
安装版本不匹配。
可能原因
当前安装HSP的版本信息与已安装HAP的版本信息不匹配。
安装HSP时会做如下校验：
处理步骤
9568287 安装包entry模块数量不合规
错误信息
Error: install invalid number of entry hap.
错误描述
安装包entry模块数量不合规。
可能原因
安装包中entry模块有多个。一个应用只能有一个entry模块，可以有多个feature模块。
处理步骤
9568281 安装包vendor不一致
错误信息
Error: install vendor not same.
错误描述
安装包vendor不一致。
可能原因
app.json5文件中app的vendor字段配置不一致。
处理步骤
9568274 安装服务错误
错误信息
Error: install installd service error.
错误描述
安装服务错误。
可能原因
安装服务异常。
处理步骤
9568314 安装应用间共享库失败
错误信息
Error: Failed to install the HSP because installing a shared bundle specified by hapFilePaths is not allowed.
错误描述
安装应用间共享库失败。
可能原因
安装应用间共享HSP时使用“hdc app install ***”指令。
处理步骤
9568359 安装设置selinux失败
错误信息
Error: installd set selinux label failed.
错误描述
安装设置selinux失败。
可能原因
签名配置文件中APL字段错误。APL有“normal”、“system_basic”和“system_core”三种等级。
处理步骤
1.  确认签名文件p7b中apl字段是否有误。
2.  若apl字段有误，修改UnsgnedReleasedProfileTemplate.json文件中apl字段，并重新签名。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170533.62570458793345477444076096751287:50001231000000:2800:79DFBEEC411914EB8AC644B5992FF91400A7F11494C3D710C8F8A20569C78850.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170533.50531972609196878667202184319591:50001231000000:2800:91E022248122A5CDCB7F57A88BECB4139D42C1346D21B5B2077CF2AA8B030806.png)
9568403 安装加密校验失败
错误信息
Error: check encryption failed.
错误描述
安装加密校验失败。
可能原因
可能是镜像版本较老；或者HAP包lib目录内非so文件导致。
处理步骤
9568417 签名校验失败
错误信息
Error: bundle cannot be installed because the appId is not same with preinstalled bundle.
错误描述
签名校验失败。
可能原因
安装的应用与已经预置的同包名应用签名不一致。
处理步骤
9568278 安装包的版本号不一致
错误信息
error: install version code not same.
可能原因
处理步骤

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/packing-unpacking-V14
爬取时间: 2025-04-28 19:22:40
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/packing-tool-V14
爬取时间: 2025-04-28 19:22:54
来源: Huawei Developer
打包工具用于在程序编译完成后，对编译出的文件等进行打包，以供安装发布。开发者可以使用DevEco Studio进行打包，也可使用打包工具的JAR包进行打包，JAR包通常存放在SDK路径下的toolchains目录中。
打包工具支持生成：Ability类型的模块包（HAP）、动态共享包（HSP）、应用程序包（App）、快速修复模块包（HQF）、快速修复包（APPQF）。
约束与限制
打包工具需要运行在Java8及其以上环境。
HAP打包指令
开发者可以使用打包工具的JAR包对模块进行打包，通过传入打包选项、文件路径，生成所需的HAP包。
-  Stage模型示例：
-  FA模型示例：
表1HAP打包指令参数说明
| 指令 | 是否必选项 | 选项 | 描述 | 备注 |
| --- | --- | --- | --- | --- |
| --mode | 是 | hap | 打包类型。 | NA |
| --json-path | 是 | NA | .json文件路径.FA模型文件名必须为config.json；Stage模型文件名必须为module.json。 | NA |
| --profile-path | 否 | NA | CAPABILITY.profile文件路径。 | NA |
| --maple-so-path | 否 | NA | maple so文件输入路径，so文件路径，文件名必须以.so为后缀。如果是多个so需要用“，”分隔。 | NA |
| --maple-so-dir | 否 | NA | maple so目录输入路径。 | NA |
| --dex-path | 否 | NA | dex文件路径，文件名必须以.dex为后缀。如果是多个dex需要用“，”分隔。  dex文件路径也可以为目录。  | NA |
| --lib-path | 否 | NA | lib库文件路径。 | NA |
| --resources-path | 否 | NA | resources资源包路径。 | NA |
| --index-path | 否 | NA | .index文件路径，文件名必须为resources.index。 | NA |
| --pack-info-path | 否 | NA | pack.info文件路径，文件名必须为pack.info。 | NA |
| --rpcid-path | 否 | NA | rpcid.sc文件路径，文件名必须为rpcid.sc。 | NA |
| --js-path | 否 | NA | 存放js文件目录路径。 | 仅stage模型生效 |
| --ets-path | 否 | NA | 存放ets文件目录路径。 | 仅stage模型生效 |
| --out-path | 是 | NA | 目标文件路径，文件名必须以.hap为后缀。 | NA |
| --force | 否 | true或者false | 默认值为false，如果为true，表示当目标文件存在时，强制删除。 | NA |
| --an-path | 否 | NA | 存放an文件的路径。 | 仅stage模型生效 |
| --ap-path | 否 | NA | 存放ap文件的路径。 | 仅stage模型生效 |
| --dir-list | 否 | NA | 可指定目标文件夹列表，将其打入HAP包内。 | NA |
| --compress-level | 否 | number | 压缩等级，默认值1，可选等级1-9。在应用配置compressNativeLibs参数为true的情况下生效，数值越大压缩率越高、压缩速度越慢。 | NA |
| --pkg-context-path | 否 | NA | 可指定语境信息表文件路径，文件名必须为pkgContextInfo.json。 | 仅stage模型生效 |
| --hnp-path | 否 | NA | 指定native软件包文件路径，将native软件包打入HAP包内。 | NA |
dex文件路径，文件名必须以.dex为后缀。如果是多个dex需要用“，”分隔。
dex文件路径也可以为目录。
HSP打包指令
HSP包实现了多个HAP对文件的共享，开发者可以使用打包工具的jar包对应用进行打包，通过传入打包选项、文件路径，生成所需的HSP包。
示例：
表2HSP打包指令参数说明
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | hsp | 打包类型。 |
| --json-path | 是 | NA | .json文件路径，文件名必须为module.json。 |
| --profile-path | 否 | NA | CAPABILITY.profile文件路径。 |
| --dex-path | 否 | NA | 1.dex文件路径，文件名必须以.dex为后缀。如果是多个dex需要用“，”分隔。 2.dex文件路径也可以为目录。  |
| --lib-path | 否 | NA | lib库文件路径。 |
| --resources-path | 否 | NA | resources资源包路径。 |
| --index-path | 否 | NA | .index文件路径，文件名必须为resources.index。 |
| --pack-info-path | 否 | NA | pack.info文件路径，文件名必须为pack.info。 |
| --js-path | 否 | NA | 存放js文件目录路径。 |
| --ets-path | 否 | NA | 存放ets文件目录路径。 |
| --out-path | 是 | NA | 目标文件路径，文件名必须以.hsp为后缀。 |
| --force | 否 | true或者false | 默认值为false，如果为true，表示当目标文件存在时，强制删除。 |
| --compress-level | 否 | number | 压缩等级，默认值1，可选等级1-9。在应用配置compressNativeLibs参数为true的情况下生效，数值越大压缩率越高、压缩速度越慢。 |
| --pkg-context-path | 否 | NA | 可指定语境信息表文件路径，文件名必须为pkgContextInfo.json。 |
1.dex文件路径，文件名必须以.dex为后缀。如果是多个dex需要用“，”分隔。
2.dex文件路径也可以为目录。
App打包指令
开发者可以使用打包工具的jar包对应用进行打包，通过传入打包选项、文件路径，生成所需的App包。App包用于上架应用市场。
App打包时HAP合法性校验：在对工程内的HAP包打包生成App包时，需要保证被打包的每个HAP在json文件中配置的bundleName、versionCode、minCompatibleVersionCode、debug、minAPIVersion、targetAPIVersion相同，moduleName唯一。对于FA模型，还需要保证json文件中配置的package唯一。HAP模块之间需要保证apiReleaseType相同，HSP模块不校验apiReleaseType。
打包App时的压缩规则：打包App时，对release模式的HAP、HSP包会进行压缩，对debug模式的HAP、HSP包不会压缩。
从API version 12开始，App打包不再对versionName校验。
示例：
表3App打包指令参数说明
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | app | 多个HAP需满足HAP的合法性校验。 |
| --hap-path | 否 | NA | HAP包文件路径，文件名必须以.hap为后缀。如果是多个HAP包需要用“，”分隔。 HAP包文件路径也可以是目录。  |
| --hsp-path | 否 | NA | HSP包文件路径，文件名必须以.hsp为后缀。如果是多个HSP包需要用“，”分隔。 HSP包文件路径也可以是目录。  |
| --pack-info-path | 是 | NA | 文件名必须为pack.info。 |
| --out-path | 是 | NA | 目标文件路径，文件名必须以.app为后缀。 |
| --signature-path | 否 | NA | 签名路径。 |
| --certificate-path | 否 | NA | 证书路径。 |
| --pack-res-path | 否 | NA | pack.res快照文件路径。 |
| --force | 否 | true或者false | 默认值为false，如果为true，表示当目标文件存在时，强制删除。 |
| --encrypt-path | 否 | NA | 文件名必须为encrypt.json 。 |
HAP包文件路径，文件名必须以.hap为后缀。如果是多个HAP包需要用“，”分隔。
HAP包文件路径也可以是目录。
HSP包文件路径，文件名必须以.hsp为后缀。如果是多个HSP包需要用“，”分隔。
HSP包文件路径也可以是目录。
多工程打包指令
多工程打包适用于多个团队开发同一个应用，但不方便共享代码的情况。开发者通过传入已经打好的HAP、HSP和App包，将多个包打成一个最终的App包，并上架应用市场。
多工程打包HAP合法性校验：需要保证被打包的每个HAP在json文件中配置的bundleName、versionCode、minCompatibleVersionCode、debug属性相同，minAPIVersion、targetAPIVersion、compileSdkVersion、compileSdkType相同，moduleName唯一，同一设备entry唯一。对于FA模型，还需要保证json文件中配置的package唯一。HAP模块之间需要保证apiReleaseType相同，HSP模块不校验apiReleaseType。
从API version 12开始，多工程打包不再对versionName校验。
示例：
表4多工程打包指令参数说明
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | multiApp | 打包类型，在将多个HAP打入同一个App时，需保证每个HAP满足合法性校验规则。 |
| --hap-list | 否 | HAP的路径 | HAP包文件路径，文件名必须以.hap为后缀。如果是多个HAP包需要”，“分隔。 HAP文件路径也可以是目录。  |
| --hsp-list | 否 | HSP的路径 | HSP包文件路径，文件名必须以.hsp为后缀。如果是多个HSP包需要”，“分隔。 HSP文件路径也可以是目录。  |
| --app-list | 否 | App的路径 | App文件路径，文件名必须以.app为后缀。如果是多个App包需要用”，“分隔。 App文件路径也可以是目录。 --hap-list，--hsp-list，--app-list不可以都不传。  |
| --out-path | 是 | NA | 目标文件路径，文件名必须以.app为后缀。 |
| --force | 否 | true或者false | 默认值为false，如果为true，表示当目标文件存在时，强制删除。 |
| --encrypt-path | 否 | encrypt.json的路径 | 文件名必须为encrypt.json。 |
HAP包文件路径，文件名必须以.hap为后缀。如果是多个HAP包需要”，“分隔。
HAP文件路径也可以是目录。
HSP包文件路径，文件名必须以.hsp为后缀。如果是多个HSP包需要”，“分隔。
HSP文件路径也可以是目录。
App文件路径，文件名必须以.app为后缀。如果是多个App包需要用”，“分隔。
App文件路径也可以是目录。
--hap-list，--hsp-list，--app-list不可以都不传。
HQF打包指令
HQF包适用于应用存在一些问题，需要紧急修复的场景。开发者可以使用打包工具的jar包对应用进行打包，通过传入打包选项、文件路径，生成所需的HQF包。
示例:
表5HQF打包指令参数说明
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | hqf | 打包类型。 |
| --json-path | 是 | NA | .json文件路径，文件名必须为patch.json。 |
| --lib-path | 否 | NA | lib库文件的路径。 |
| --ets-path | 否 | NA | 存放ets文件目录路径。 |
| --resources-path | 否 | NA | resources资源包路径。 |
| --out-path | 是 | NA | 目标文件路径，文件名必须以.hqf为后缀。 |
| --force | 否 | true或者false | 默认值为false，如果为true，表示当目标文件存在时，强制删除。 |
APPQF打包指令
APPQF包由一个或多个HQF文件组成。这些HQF包在应用市场会从APPQF包中拆分出来，再被分发到具体的设备上。开发者可以使用打包工具的jar包对应用进行打包，通过传入打包选项、文件路径，生成所需的APPQF包。
示例:
表6APPQF打包指令参数说明
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | appqf | 打包类型。 |
| --hqf-list | 是 | NA | HQF文件路径，多个HQF以英文逗号隔开。 |
| --out-path | 是 | NA | 目标文件路径，文件名必须以.appqf为后缀。 |
| --force | 否 | true或者false | 默认值为false，如果为true，表示当目标文件存在时，强制删除。 |
版本归一指令（versionNormalize）
同一个App中，所有HAP、HSP包的versionName和versionCode需要保持一致。当只有一个HAP或HSP需要修改升级时，可以调用此命令，将多个HAP、HSP的版本统一。本命令会修改所传入的HAP、HSP的版本号和版本名称，并在指定目录生成修改后的同名HAP、HSP，以及一个version_record.json文件，用于记录所有HAP、HSP原有的版本号、版本名称。
示例：
表7versionNormalize指令参数说明
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | versionNormalize | 命令类型。 |
| --input-list | 是 | HAP或HSP的路径 | 1.HAP或HSP包文件路径，文件名必须以.HAP或.HSP为后缀。如果是多个HAP或HSP包需要“,”分隔。 2.传入目录时，会读取目录下所有的HAP和HSP文件。  |
| --version-code | 是 | 版本号 | 指定的版本号，HAP、HSP的版本号会被修改为该版本。需要为整数，且不小于所有传入的HAP、HSP的版本号。 |
| --version-name | 是 | 版本名称 | 指定的版本名称，HAP、HSP的版本名称会被修改为该版本名称。 |
| --out-path | 是 | NA | 目标文件路径，需要为一个目录。 |
1.HAP或HSP包文件路径，文件名必须以.HAP或.HSP为后缀。如果是多个HAP或HSP包需要“,”分隔。
2.传入目录时，会读取目录下所有的HAP和HSP文件。
包名归一指令（packageNormalize）
此命令可以修改传入的HSP的包名和版本号，并在指定目录生成修改后的同名HSP。
示例：
表8参数含义及规范
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | packageNormalize | 命令类型。 |
| --hsp-list | 是 | HSP的路径 | 1.HSP包文件路径，文件名必须以.hsp为后缀。如果是多个HSP包需要“,”分隔。 2.HSP包目录。  |
| --bundle-name | 是 | 包名 | 指定的包名，HSP的包名会被修改为指定的包名。 |
| --version-code | 是 | 版本号 | 指定的版本号，HSP的版本号会被修改为该版本号。需要为整数，且大于0。 |
| --out-path | 是 | NA | 目标文件路径，需要为一个目录。 |
1.HSP包文件路径，文件名必须以.hsp为后缀。如果是多个HSP包需要“,”分隔。
2.HSP包目录。
res模式打包指令
此命令用于打包元服务快照资源。
示例：
表9参数含义及规范
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | res | 命令类型。 |
| --entrycard-path | 是 | NA | 快照目录的路径。 |
| --pack-info-path | 是 | NA | pack.info文件路径。 |
| --out-path | 是 | NA | 目标文件路径，文件名必须以.res为后缀。 |
| --force | 否 | true或者false | 默认值为false，如果为true，表示当目标文件存在时，强制删除。 |
fastApp模式打包指令
开发者可以使用打包工具的jar包对应用进行打包，通过传入打包选项、HAP、HSP包文件目录路径，生成所需的App包。App包用于上架应用市场。
App打包时HAP合法性校验：在对工程内的HAP包打包生成App包时，需要保证被打包的每个HAP在json文件中配置的bundleName、versionCode、minCompatibleVersionCode、debug、minAPIVersion、targetAPIVersion相同，moduleName唯一。HAP模块之间需要保证apiReleaseType相同，HSP模块不校验apiReleaseType。
打包App时的压缩规则：打包App时，对release模式的HAP、HSP包会进行压缩，对debug模式的HAP、HSP包不会压缩。
示例：
表10参数含义及规范
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | fastApp | 多个HAP需满足HAP的合法性校验。 |
| --hap-path | 否 | NA | HAP包文件目录路径，目录内要包含一个完整的HAP包的所有文件。允许传入多个路径，多个路径需要用英文“,”分隔。 |
| --hsp-path | 否 | NA | 1.HSP包文件路径，文件名必须以.hsp为后缀。如果是多个HSP包需要用英文“,”分隔。2.HSP包文件目录路径，目录内要包含一个完整的HSP包的所有文件。允许传入多个路径，多个路径需要用英文“,”分隔。 |
| --pack-info-path | 是 | NA | 文件名必须为pack.info。 |
| --out-path | 是 | NA | 目标文件路径，文件名必须以.app为后缀。 |
| --signature-path | 否 | NA | 签名路径。 |
| --certificate-path | 否 | NA | 证书路径。 |
| --pack-res-path | 否 | NA | pack.res快照文件路径。 |
| --force | 否 | true或者false | 默认值为false，如果为true，表示当目标文件存在时，强制删除。 |
| --encrypt-path | 否 | NA | 文件名必须为encrypt.json。 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/unpacking-tool-V14
爬取时间: 2025-04-28 19:23:07
来源: Huawei Developer
拆包工具是HarmonyOS提供的一种调测工具，支持通过命令行方式将HAP、HSP、App等文件解压成文件夹，并且提供Java接口对HAP、HSP、App等文件进行解析。
拆包所用的app_unpacking_tool.jar，可以在本地下载的HarmonyOS的SDK库中找到。
约束与限制
拆包工具需要运行在Java8及其以上环境。
拆包指令说明
HAP包模式拆包指令
开发者可以使用拆包工具的jar包对应用进行拆包，通过传入拆包选项、文件路径，将HAP包解压出来。
示例
参数含义及规范
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | hap | 拆包类型。 |
| --hap-path | 是 | NA | HAP包路径。 |
| --rpcid | 否 | true或者false | 是否单独将rpcid文件从HAP包中提取到指定目录，如果为true，将仅提取rpcid文件，不对HAP包进行拆包。 |
| --out-path | 是 | NA | 拆包目标文件路径。 |
| --force | 否 | true或者false | 默认值为false，如果为true，表示当目标文件存在时，强制删除。 |
App包模式拆包指令
开发者可以使用拆包工具的jar包对应用进行拆包，通过传入拆包选项、文件路径，将App包解压出来。
示例
参数含义及规范
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | app | 拆包类型。 |
| --app-path | 是 | NA | App包路径。 |
| --out-path | 是 | NA | 拆包目标文件路径。 |
| --force | 否 | true或者false | 默认值为false，如果为true，表示当目标文件存在时，强制删除。 |
从HAP包中获取rpcid文件
开发者可以使用拆包工具的jar包对应用进行拆包，通过传入拆包选项、文件路径，获取应用的rpcid。
示例
参数含义及规范
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | hap | 拆包类型。 |
| --rpcid | 否 | true或者false | 是否单独将rpcid文件从HAP包中提取到指定目录，如果为true，将仅提取rpcid文件，不对HAP包进行拆包。 |
| --hap-path | 是 | NA | HAP包路径。 |
| --out-path | 是 | NA | 拆包rpcid目标文件路径。 |
| --force | 否 | true或者false | 默认值为false，如果为true，表示当目标文件存在时，强制删除。 |
HSP包模式拆包指令
开发者可以使用拆包工具的jar包对应用进行拆包，通过传入拆包选项、文件路径，将HSP包解压出来。
示例
参数含义及规范
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | hsp | 拆包类型。 |
| --hsp-path | 是 | NA | HSP包路径。 |
| --out-path | 是 | NA | 拆包目标文件路径。 |
| --force | 否 | true或者false | 默认值为false，如果为true，表示当目标文件存在时，强制删除。 |
APPQF模式拆包指令
开发者可以使用拆包工具的jar包对应用进行拆包，通过传入拆包选项、文件路径，将APPQF包解压出来。
示例
参数含义及规范
| 指令 | 是否必选项 | 选项 | 描述 |
| --- | --- | --- | --- |
| --mode | 是 | appqf | 拆包类型。 |
| --appqf-path | 是 | NA | APPQF包路径。 |
| --out-path | 是 | NA | 拆包目标文件路径。 |
| --force | 否 | true或者false | 默认值为false，如果为true，表示当目标文件存在时，强制删除。 |
包解析接口
包解析接口仅用于应用市场对打好的HAP、HSP、App等包进行解析，获取其中配置文件等信息。
接口目录
| 类名 | 接口原型 | 类型 | 接口详细描述 |
| --- | --- | --- | --- |
| UncompressEntrance | UncompressResult parseApp(String appPath,String parseMode,String deviceType,String hapName) | Java接口 | 接口功能：根据参数解析app包的pack.info信息 输入参数：app包路径，解析参数 返回值：UncompressResult |
| UncompressEntrance | UncompressResult parseApp(InputStream input,String parseMode,String deviceType,String hapName,String outPath) | Java接口 | 接口功能：根据参数解析app包的pack.info信息 输入参数：app文件流，解析参数 返回值：UncompressResult |
| UncompressEntrance | UncompressResult parseHap(String hapPath) | Java接口 | 接口功能：根据参数解析app包的json配置文件 输入参数：HAP包路径，解析参数 返回值：UncompressResult |
| UncompressEntrance | UncompressResult parseHap(InputStream input) | Java接口 | 接口功能：根据参数解析app包的json配置文件 输入参数：HAP包文件流，解析参数 返回值：UncompressResult |
拆包工具信息字段
UncompressResult（Bundle信息）结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| result | boolean | 标识此次解析是否成功 | NA |
| message | String | 解析失败时返回失败原因 | NA |
| packInfos | List<PackInfo> | bundle中pack.info文件的packages信息 | NA |
| profileInfos | List<profileInfo> | 应用的配置信息 | NA |
| profileInfosStr | List<String> | 应用的配置信息 | NA |
| icon | String | 返回入口组件的icon路径，如果没有入口组件，则返回第一个组件的icon信息 | NA |
| label | String | 返回入口组件的label，如果没有入口组件，则返回第一个组件的label信息 | NA |
| packageSize | long | 表示App包的大小，单位字节 | NA |
PackInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| name | String | 包名 | NA |
| moduleName | String | HAP名称 | NA |
| moduleType | String | module的类型 | NA |
| deviceType | List<String> | 表示当前HAP包所支持的设备类型 | NA |
| deliveryWithInstall | boolean | 标识当前HAP是否在用户主动安装的时候安装 | NA |
ProfileInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| hapName | String | 标识当前解析的HAP包名称 | NA |
| appInfo | AppInfo结构体（见下述AppInfo） | 标识App信息的结构体（见下述AppInfo信息） | NA |
| deviceConfig | Map<String,DeviceConfig> | 标识设备信息 | 存储类型为Map<String,String>，存储设备类型名称及对应设备类型的信息，在stage模型中，这个字段存储在app结构体中 |
| hapInfo | HapInfo结构体（见下述HapInfo） | 标识HAP包中module信息（见下述HapInfo信息） | NA |
AppInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| bundleName | String | 标识App的包名称 | NA |
| vendor | String | 标识App的供应商信息 | NA |
| relatedBundleName | String | 标识App相关bundle的包名 | NA |
| versionName | String | 标识App中的versionName信息 | NA |
| versionCode | String | 标识App中的versionCode信息 | NA |
| targetApiVersion | int | 标识应用运行需要的API目标版本 | NA |
| compatibleApiVersion | int | 标识应用兼容的API版本 | NA |
| appName | String | 标识显示在桌面上的ability的label | NA |
| appNameEN | String | 标识显示在桌面上的ability的label | NA |
| releaseType | String | 标识应用运行需要的API目标版本的类型 | NA |
| shellVersionCode | String | 标识应用的API版本号 | NA |
| shellVersionName | String | 标识应用的API版本名称 | NA |
| multiFrameworkBundle | boolean | 标识应用框架 | NA |
| debug | boolean | 标识应用是否可调试 | NA |
| icon | String | 标识应用的图标路径 | NA |
| label | String | 标识应用的label | NA |
| description | String | 标识应用的描述信息 | stage模型新增 |
| minCompatibleVersionCode | int | 标识应用能够兼容的最低版本号 | NA |
| distributedNotificationEnabled | boolean | 标记该应用是否开启分布式通知 | stage模型新增 |
| bundleType | String | 标识bundle的类型，取值： - app：应用 - atomicService：元服务  - shared：应用间共享库  | NA |
| compileSdkVersion | String | 标识编译该应用时使用的sdk版本 | 仅限API10及以后的应用 |
| compileSdkType | String | 标识编译该应用时使用的sdk类别 | 仅限API10及以后的应用 |
| labels | HashMap<String, String> | 标识多语言应用程序AppJson的标签。 | NA |
| descriptions | HashMap<String, String> | 标识多语言应用程序AppJson的说明。 | NA |
标识bundle的类型，取值：
- app：应用
- atomicService：元服务
- shared：应用间共享库
HapInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| appModel | AppModel枚举值 | 标识应用的框架模型 - FA：FA模型 - STAGE：Stage模型  | NA |
| packageStr | String | 标识应用的包信息 | FA模型特有 |
| name | String | 标识当前module的名字 | NA |
| description | String | 标识HAP包的描述信息 | FA模型特有 |
| supportedModes | List<String> | 标识HAP包的支持的模式 | NA |
| abilities | List<AbilityInfo> | 标识HAP包ability信息 | NA |
| defPermissions | List<DefPermission> | 标识HAP包DefPermission信息 | NA |
| definePermissions | List<DefinePermission> | 标识HAP包DefinePermission信息 | NA |
| defPermissionsGroups | List<DefPermissionsGroups> | 标识HAP包DefPermissionsGroups 信息 | NA |
| distro | Distro结构体 | 标识HAP包的distro信息 | NA |
| reqCapabilities | List<String> | 标识HAP包reqCapabilities信息 | NA |
| deviceType | List<String> | 标识HAP可以运行在哪类设备上 | 对应stage模型中的deviceTypes |
| metaData | MetaData结构体（见下述metaData） | 标识HAP的自定义元信息 | NA |
| dependencies | List<DependencyItem> | 标识HAP包DependencyItem信息 | NA |
| isJs | boolean | 标识该应用是否是js应用 | FA模型特有 |
| reqPermissions | list<ReqPermission> | 标识应用申请的权限的集合 | 对应stage模型的requestPermissions |
| commonEvents | CommonEvent结构体（见下述CommonEvent） | 标识静态事件 | NA |
| shortcuts | list<Shortcut> | 标识应用的shortcuts信息 | NA |
| distroFilter | DistroFilter结构体 | 标识应用市场按设备形态分发的信息 | NA |
| srcEntrance | String | 标识应用对应的入口代码路径 | stage模型新增 |
| process | String | 标识HAP的进程名 | stage模型新增 |
| mainElement | String | 标识HAP的入口ability名称或者extension名称 | stage模型新增，FA模型将mainAbility的值赋值给mainElement |
| uiSyntax | String | 定义该JS Component的语法类型 | stage模型新增 |
| pages | List<String> | 列举JS Component中每个页面信息 | stage模型新增 |
| extensionAbilityInfos | List<ExtensionAbilityInfo> | 描述extensionAbility的配置信息 | stage模型新增 |
| moduleAtomicService | ModuleAtomicService结构体（见下述ModuleAtomicService） | 描述HAP的元服务信息 | NA |
| formInfos | List<AbilityFormInfo> | 描述卡片的信息 | NA |
| descriptions | HashMap<String, String> | 标识HAP的说明信息 | NA |
| compressedSize | long | 标识HAP包压缩后的大小，单位字节 | NA |
| originalSize | long | 标识HAP包的原始大小，单位字节 | NA |
标识应用的框架模型
- FA：FA模型
- STAGE：Stage模型
AbilityInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| name | String | 标识当前ability的逻辑名 | NA |
| description | String | 标识ability的描述 | NA |
| descriptionRes | String | 标识ability资源的描述 | NA |
| icon | String | 标识ability图标 | NA |
| iconPath | String | 标识ability图标路径 | NA |
| label | String | 标识ability对用户显示的名称 | NA |
| labelRes | String | 标识ability对用户显示的名称资源 | NA |
| type | String | 标识ability类型 | Stage模型下该值直接赋予page类型 |
| formsEnabled | boolean | 标识ability卡片是否使能 | NA |
| formInfo | FormInfo结构体 | 描述卡片的信息 | NA |
| uri | String | 标识ability的uri信息 | FA模型支持 |
| launchType | String | 标识ability中的launcherType信息 | NA |
| orientation | String | 标识ability中的orientation信息 | NA |
| visible | boolean | 标识ability中的visible信息 | NA |
| grantPermission | boolean | 标识ability中的grantPermission信息 | NA |
| readPermission | String | 标识ability中的readPermission信息 | NA |
| writePermission | String | 标识ability中的writePermission信息 | NA |
| uriPermissionMode | String | 标识ability中的uriPermissionMode信息 | NA |
| uriPermissionPath | String | 标识ability中的uriPermissionPath信息 | NA |
| directLaunch | boolean | 标识ability中的directLaunch信息 | NA |
| mission | String | 标识ability中的mission信息 | NA |
| targetAbility | String | 标识ability中的targetAbility信息 | NA |
| multiUserShared | boolean | 标识ability中的multiUserShared信息 | NA |
| supportPipMode | boolean | 标识ability中的supportPipMode信息 | NA |
| srcLanguage | String | 标识ability中的srcLanguage信息 | NA |
| srcPath | String | 标识ability中的srcPath信息 | NA |
| srcEntrance | String | 标识ability中的srcEntrance信息 | NA |
| continuable | boolean | 标识ability中的continuable信息 | NA |
| metaData | MetaData结构体（见下述MetaData） | 标识ability的自定义元信息 | NA |
| configChanges | List<String> | 标识ability中的configChanges信息 | NA |
| formInfos | List<AbilityFormInfo> | 标识ability中的forms信息 | NA |
| permissions | List<String> | 标识ability中的permissions信息 | NA |
| skills | List<SkillInfo> | 标识ability中的skills信息 | NA |
| backgroundModes | List<String> | 标识ability中的backgroundModes信息 | NA |
| labels | HashMap<String, String> | 标识多语言下ability对用户显示的名称 | NA |
| descriptions | HashMap<String, String> | 标识多语言下ability的描述 | NA |
Distro结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| moduleName | String | 标识当前module的名字 | 对应Stage模型中module结构体中的moduleName字段 |
| moduleType | String | 标识当前HAP的类型 | 对应Stage模型中module结构体中的moduleType字段 |
| deliveryWithInstall | boolean | 标识当前HAP是否在用户主动安装的时候安装 | 对应Stage模型中module结构体中的deliveryWithInstall字段 |
| installationFree | int | 标识当前HAP是否支持免安装特性 | 对应Stage模型中module结构体中的installationFree字段，json文件中如果配置了该字段为true，返回1，配置为false，返回0，未配置返回2 |
| virtualMachine | String | 标识当前HAP运行的目标虚拟机类型，供云端分发使用，如应用市场和分发中心 | 对应Stage模型中module结构体中的virtualMachine字段 |
MetaData结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| parameters | List<MetaDataInfo> | 标识Metadata的参数信息 | FA模型特有，stage模型废弃 |
| results | List<MetaDataInfo> | 标识Metadata的results信息 | FA模型特有，stage模型废弃 |
| customizeDatas | List<CustomizeData> | 标识Metadata的customizeDatas信息 | NA |
MetaDataInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| name | String | 标识MetaDataInfo的name信息 | FA模型特有，stage模型废弃 |
| description | String | 标识MetaDataInfo的description信息 | FA模型特有，stage模型废弃 |
| type | String | 标识MetaDataInfo的type信息 | FA模型特有，stage模型废弃 |
CustomizeData结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| name | String | 标识CustomizeData的name信息 | 对应stage模型的metadata |
| value | String | 标识CustomizeData的value信息 | 对应stage模型的metadata |
| extra | String | 标识CustomizeData的extra信息 | 对应stage模型的metadata |
ReqPermission结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| name | String | 标识ReqPermission的名称信息 | NA |
| reason | String | 当申请的权限为user_grant权限时此字段必填，描述申请权限的原因 | NA |
| usedScene | UsedScene结构体（见下述UsedScene） | 描述权限使用的场景和时机。场景类型有：ability、调用时机（when），可配置多个ability | NA |
| reasons | HashMap<String, String> | 当申请的权限为user_grant权限时此字段必填，描述申请权限的原因 | NA |
UsedScene结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| ability | List<String> | 标识需要使用到该权限的元能力（ability），该标签值为数组形式 | NA |
| when | String | 标识使用该权限的时机，值为inuse/always，表示为仅允许前台使用和前后台都可使用 | NA |
Shortcut结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| shortcutId | String | 标识ShortCut的Id | NA |
| label | String | 标识ShortCut的标签信息 | NA |
| icon | String | 标识ShortCut的图标信息 | NA |
| intents | List<IntentInfo> | 标识快捷方式内定义的目标intent信息集合，每个intent可配置两个子标签，targetClass,targetBundle | NA |
| labels | HashMap<String, String> | 标识多语言下ShortCut对用户显示的名称 | NA |
IntentInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| targetClass | String | 快捷方式目标类型 | NA |
| targetBundle | String | 快捷方式目标包名 | NA |
DistroFilter结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| apiVersion | ApiVersion结构体 | 标识DistroFilter中的apiVersion信息 | NA |
| screenShape | ScreenShape结构体 | 标识DistroFilter中的screenShape信息 | NA |
| screenDensity | ScreenDensity结构体 | 标识DistroFilter中的screenDensity信息 | NA |
| screenWindow | ScreenWindow结构体 | 标识DistroFilter中的screenWindow信息 | NA |
| countryCode | CountryCode结构体 | 标识DistroFilter中的countryCode信息 | NA |
ApiVersion结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| policy | String | 标识结构体中的policy信息 | NA |
| value | List<String> | 标识结构体中的value信息 | NA |
ScreenShape结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| policy | String | 标识结构体中的policy信息 | NA |
| value | List<String> | 标识结构体中的value信息 | NA |
ScreenDensity结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| policy | String | 标识结构体中的policy信息 | NA |
| value | List<String> | 标识结构体中的value信息 | NA |
ScreenWindow结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| policy | String | 标识结构体中的policy信息 | NA |
| value | List<String> | 标识结构体中的value信息 | NA |
CountryCode结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| policy | String | 标识结构体中的policy信息 | NA |
| value | List<String> | 标识结构体中的value信息 | NA |
ExtensionAbilityInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| name | String | 标识当前extensionAbility的逻辑名 | stage模型支持 |
| srcEntrance | String | 标识extensionAbility所对应的js代码路径 | stage模型支持 |
| icon | String | 标签标识extensionAbility图标 | stage模型支持 |
| label | String | 标识extensionAbility对用户显示的名称 | stage模型支持 |
| description | String | 标识extensionAbility的描述 | stage模型支持 |
| type | String | 标识extensionAbility的类型：form、workScheduler、inputMethod、service、accessibility、dataShare、fileShare、wallpaper、backup | stage模型支持，目前仅解析了form、staticSubscriber的信息、其他类型（如：workScheduler、inputMethod、service、accessibility、dataShare、fileShare、wallpaper、backup）暂未解析 |
| permissions | List<String> | 标识被其它应用的ability调用时需要申请的权限的集合 | stage模型支持 |
| readPermission | String | 标识读取ability的数据所需的权限 | stage模型支持 |
| writePermission | String | 标识向ability写数据所需的权限 | stage模型支持 |
| visible | boolean | 标识extensionAbility是否可以被其它应用调用 | stage模型支持 |
| skills | List<SkillInfo> | 标识extensionAbility能够接收的意图的特征集 | stage模型支持 |
| metadataInfos | List<ModuleMetadataInfo> | 标识extensionAbility能够接收的元数据信息 | stage模型支持 |
| metadata | MetaData结构体 | 标识extensionAbility的元信息 | 将metadata中的信息赋值到CustomizeData中 |
| uri | String | 标识extensionAbility提供的数据uri | stage模型支持 |
| descriptions | HashMap<String, String> | 标识多语言下extensionAbility的描述 | NA |
| labels | HashMap<String, String> | 标识多语言下extensionAbility对用户显示的名称 | NA |
SkillInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| actions | List<String> | 标识能够接收的意图的action值的集合 | NA |
| entities | List<String> | 标识能够接收的意图的元能力的类别集合 | NA |
UriInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| schema | String | 标识ModuleUriInfo的范式信息 | NA |
| host | String | 标识ModuleUriInfo的宿主信息 | NA |
| port | String | 标识ModuleUriInfo的端口信息 | NA |
| pathStartWith | String | 标识ModuleUriInfo的路径前缀 | NA |
| pathRegex | String | 标识ModuleUriInfo的路径正则信息 | NA |
| path | String | 标识ModuleUriInfo的路径信息 | NA |
| type | String | 标识ModuleUriInfo的种类 | NA |
AbilityFormInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| name | String | 标识forms的名称 | NA |
| type | String | 标签标识卡片的类型 | NA |
| updateEnabled | boolean | 标识该卡片是否支持定时刷新 | NA |
| scheduledUpdateTime | String | 标签标识卡片顶点刷新的时间，采用24小时计数，精确到分钟 | NA |
| updateDuration | int | 标识卡片定时刷新的更新频率，单位为30分钟，取值为30的倍数值 | NA |
| supportDimensions | List<String> | 标识卡片外观规格，取值为”1 * 2“，”2 * 2“，”2 * 4“，”4 * 4“ | NA |
| defaultDimension | String | 标识卡片默认外观规格，取值必须在supportDimensions配置的列表中 | NA |
| MetaData | MetaData | 标识卡片的自定义信息 | NA |
| description | String | 标识forms的描述 | stage模型新增 |
| src | String | 标签JS卡片对应的UI代码 | NA |
| windowInfo | ModuleWindowInfo结构体 | 标签能力窗体的窗口。 | NA |
| isDefault | boolean | 标识该卡片是否为默认卡片，每个HAP有且只能有一个默认卡片 | NA |
| colorMode | String | 标识卡片的色调，取值为auto、dark、light其中之一 | NA |
| formConfigAbility | String | 标识卡片调整的Ability名称 | NA |
| formVisibleNotify | String | 标识卡片是否被允许使用卡片可见性通知 | NA |
| providerAbility | String | 卡片的提供方所在的Ability或者extension名称，1.FA模型：如果卡片配置在service类型的ability中，providerAbility配置为mainAbility 2.FA模型：如果卡片配置在Page类型的Ability中，providerAbility配置为当前Ability 3.FA模型：如果没有配置mainAbility，providerAbility配置为当前HAP包中的优先使用system.home，否则第一个page的Ability 4.stage模型中（follow上述规则），providerAbility配置为mainElement | NA |
| descriptions | HashMap<String, String> | 标识多语言下ability的描述 | NA |
CommonEvent结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| name | String | 当前静态公共事件对应的类名 | Stage模型从staticSubscriber类型的Extension中获取 |
| permission | String | 标识实现该静态公共事件需要申请的权限 | Stage模型从staticSubscriber类型的Extension中获取 |
| data | List<String> | 当前静态公共时间需要携带的额外数据数组 | Stage模型从staticSubscriber类型的Extension中获取 |
| type | List<String> | 配置当前静态公共时间的类别数组 | Stage模型从staticSubscriber类型的Extension中获取 |
| events | List<String> | 标识能够接收的意图的event值的集合 | Stage模型从staticSubscriber类型的Extension中获取 |
DependencyItem结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| bundleName | String | 共享包的bundleName | NA |
| moduleName | String | 共享包的moduleName | NA |
| versionCode | String | 共享包的版本号 | NA |
ModuleAtomicService结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| preloadItems | list<PreloadItem> | 预加载对象 | NA |
PreloadItem结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| moduleName | String | 预加载的模块名 | NA |
DeviceConfig结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| targetReqSdk | String | 标识应用程序DeviceConfig的目标请求Sdk版本 | NA |
| compatibleReqSdk | String | 标识应用程序DeviceConfig的兼容请求Sdk版本 | NA |
| jointUserid | String | 标识应用程序DeviceConfig的jointUserid | NA |
| process | String | 标识应用程序DeviceConfig的进程 | NA |
| arkFlag | String | 标识应用程序DeviceConfig的arkFlag | NA |
| targetArkVersion | String | 标识应用程序DeviceConfig的targetArkVersion | NA |
| compatibleArkVersion | String | 标识应用程序DeviceConfig的兼容ArkVersion | NA |
| directLaunch | boolean | 标识应用程序DeviceConfig的直接启动 | NA |
| distributedNotificationEnabled | boolean | 标识应用程序AppJson的distributedNotificationEnabled | NA |
DefPermission结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| name | String | 标识指示DefPermission的名称 | NA |
| grantMode | String | 标识DefPermission的grantMode | NA |
| group | String | 标识DefPermission的组 | NA |
| label | String | 标识DefPermission的标签 | NA |
| description | String | 标识DefPermission的描述 | NA |
| availableScope | List<String> | 标识DefPermission的可用范围 | NA |
| labels | HashMap<String, String> | 标识多语言应用程序DefPermission的标签 | NA |
| descriptions | HashMap<String, String> | 标识多语言应用程序DefPermission的说明 | NA |
DefinePermission结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| name | String | 标识DefinePermission的名称 | NA |
| grantMode | String | 标识DefinePermission的grantMode | NA |
| availableLevel | String | 标识DefinePermission的组 | NA |
| provisionEnable | boolean | 标识模块定义权限的提供启用 | NA |
| distributedSceneEnable | boolean | 标识ModuleDefinePermissions的distributedSceneEnable | NA |
| label | String | 标识DefinePermission的标签 | NA |
| description | String | 标识DefinePermission的描述 | NA |
| descriptions | HashMap<String, String> | 标识多语言应用程序DefinePermission的说明 | NA |
| labels | HashMap<String, String> | 标识多语言应用程序DefinePermission的标签 | NA |
DefPermissionsGroups结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| name | String | 标识DefPermissionGroup的名称 | NA |
| order | String | 标识DefPermissionGrou的顺序 | NA |
| icon | String | 标识DefPermissionGroup的图标 | NA |
| label | String | 标识DefPermissionGroup的标签 | NA |
| description | String | 标识DefPermissionGroup的描述 | NA |
| request | boolean | 标识DefPermissionGroup的请求 | NA |
FormInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| formEntity | List<String> | 标识formInfo的formEntity | NA |
| minHeight | String | 标识formInfo的最小高度 | NA |
| defaultHeight | String | 标识formInfo的默认高度 | NA |
| minWidth | String | 标识formInfo的最小宽度 | NA |
| defaultWidth | String | 标识formInfo的默认宽度 | NA |
ModuleMetadataInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| name | String | 标识ModuleMetadataInfo的名称 | NA |
| value | String | 标识ModuleMetadataInfo的值 | NA |
| resource | String | 标识ModuleMetadataInfo的资源 | NA |
ModuleWindowInfo结构体信息
| 字段 | 类型 | 描述 | 备注 |
| --- | --- | --- | --- |
| designWidth | int | 标识模块已用场景的设计宽度 | NA |
| autoDesignWidth | boolean | 标识ModuleUsedScene的autoDesignWidth | NA |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/app-check-tool-V14
爬取时间: 2025-04-28 19:23:21
来源: Huawei Developer
简介
扫描工具可用于分析检测应用安装包，根据不同的参数设定，扫描指定路径的HAP、HSP、App包内容并输出检测结果报告，为开发者优化包结构或排查问题提供数据支撑。目前扫描工具支持以下几种分析统计：
-  统计分析各类型文件的总大小和占比。
工具扫描结果默认以JSON和HTML两种文件格式输出。
扫描工具app_check_tool.jar需要从SDK路径下的toolchains目录中获取。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170533.70591270124466441659504934917800:50001231000000:2800:38DF697F934C45A8DF2FE44F0CAA05A1EDA7AC6F288A1F48F794DB0BF298DC0E.png)
约束与限制
扫描重复文件示例
命令示例：
扫描重复文件指令参数说明
| 指令 | 是否必选项 | 描述 |
| --- | --- | --- |
| --input | 是 | 指定传入的HAP、HSP、App包文件路径。 |
| --out-path | 是 | 指定结果输出文件夹目录。 |
| --stat-duplicate | 否 | 是否扫描重复文件。默认为false。 true：启用。 false：不启用。  |
是否扫描重复文件。默认为false。
true：启用。
false：不启用。
JSON统计结果：
扫描重复文件字段信息
| 字段 | 类型 | 描述 |
| --- | --- | --- |
| taskType | int | 取值为1，表示扫描重复文件。 |
| taskDesc | String | 任务的详细描述。 |
| param | String | 扫描程序传入参数。 |
| startTime | String | 任务开始时间。 |
| stopTime | String | 任务结束时间。 |
| result | Struct | 参考下表。 |
重复文件统计结果字段信息
| 字段 | 类型 | 描述 |
| --- | --- | --- |
| md5 | String | 相同文件的MD5值。 |
| size | int | 相同文件的大小。单位为Byte。 |
| files | Vector<String> | 相同文件名的对应路径。 |
扫描超出指定大小的文件示例
命令示例：
扫描超出指定大小的文件的指令参数说明
| 指令 | 是否必选项 | 描述 |
| --- | --- | --- |
| --input | 是 | 指定传入的HAP、HSP、App包文件路径。 |
| --out-path | 是 | 指定结果输出文件夹目录。 |
| --stat-file-size | 否 | 扫描超过设定大小的文件，单位KB  范围为 0-4294967295 KB。  |
扫描超过设定大小的文件，单位KB
范围为 0-4294967295 KB。
JSON统计结果：
扫描超出指定大小的文件字段信息
| 字段 | 类型 | 描述 |
| --- | --- | --- |
| taskType | int | 取值为2，表示扫描超出指定大小文件。 |
| taskDesc | String | 任务的详细描述。 |
| param | String | 扫描程序传入参数。 |
| startTime | String | 任务开始时间。 |
| stopTime | String | 任务结束时间。 |
| result | Struct | 参考下表。 |
超出指定大小的文件统计结果字段信息
| 字段 | 类型 | 描述 |
| --- | --- | --- |
| file | String | 扫描的大文件的对应路径。 |
| size | int | 扫描的大文件的对应大小，单位为Byte。 |
统计各类型文件大小占比示例
命令示例：
统计各类型文件大小占比指令参数说明
| 指令 | 是否必选项 | 描述 |
| --- | --- | --- |
| --input | 是 | 指定传入的HAP、HSP、App包文件路径。 |
| --out-path | 是 | 指定结果输出文件夹目录。 |
| --stat-suffix | 否 | 是否统计各类型文件大小及占比。默认为false。 true：启用。 false：不启用。  |
是否统计各类型文件大小及占比。默认为false。
true：启用。
false：不启用。
JSON统计结果：
统计各类型文件大小占比字段信息
| 字段 | 类型 | 描述 |
| --- | --- | --- |
| taskType | int | 取值为3，表示统计各类型文件大小占比。 |
| taskDesc | String | 任务的详细描述。 |
| param | String | 扫描程序传入参数。 |
| startTime | String | 任务开始时间。 |
| stopTime | String | 任务结束时间。 |
| pathList | Vector<String> | 多个HAP、HSP包的路径。 |
| result | Struct | 参考下表。 |
各类型文件大小占比统计结果字段信息
| 字段 | 类型 | 描述 |
| --- | --- | --- |
| suffix | String | 同类型文件后缀名。 |
| totalSize | int | 扫描的同类型 文件的总大小，单位为Byte。  |
| files | Stuct | 参考下表。 |
扫描的同类型
文件的总大小，单位为Byte。
同类型文件的对应路径和大小字段信息
| 字段 | 类型 | 描述 |
| --- | --- | --- |
| file | String | 文件路径。 |
| size | int | 文件的大小。 |
| compress | bool | 是否是压缩文件(仅so类型文件展示)。 true：是压缩文件。 false：不是压缩文件。  |
是否是压缩文件(仅so类型文件展示)。
true：是压缩文件。
false：不是压缩文件。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/cem-tool-V14
爬取时间: 2025-04-28 19:23:34
来源: Huawei Developer
Common Event Manager（公共事件管理工具， 简称cem）是实现公共事件信息打印、发布公共事件等功能的工具，为开发者提供基本的公共事件调试和测试能力，例如打印所有公共事件订阅者、已发送公共事件和接受者、模拟发布公共事件等。
环境要求
在使用本工具前，开发者需要先获取hdc工具，执行hdc shell。
cem工具命令列表
| 命令 | 描述 |
| --- | --- |
| help | 帮助命令，用于显示cem相关的帮助信息。 |
| publish | 发布命令，用于发布公共事件。 |
| dump | 打印命令，用于打印公共事件相关信息。 |
帮助命令（help）
发布命令（publish）
发布命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -e/--event | 必选参数，发布事件名称。 |
| -o/--ordered | 可选参数，发布有序事件，默认发布无序事件。 |
| -c/--code | 可选参数，公共事件结果码。 |
| -d/--data | 可选参数，公共事件携带数据。 |
| -h/--help | 帮助信息。 |
示例：
打印命令（dump）
当前工具区分eng与user版本。dump命令仅支持在eng版本中使用，在user版本中使用会出现报错error: user version cannot use dump。
打印命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -a/--all | 打印开机以来所有已发送的公共事件及其具体信息。 |
| -e/--event | 查询特定名称事件的具体信息。 |
| -h/--help | 帮助信息。 |
示例：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/anm-tool-V14
爬取时间: 2025-04-28 19:23:48
来源: Huawei Developer
Advanced Notification Manager（通知管理工具，简称anm）是实现通知打印、设置通知参数等功能的工具，为开发者提供基本的通知调试和测试能力，例如打印已发布通知详细信息、设置通知缓存个数、使能通知等。
环境要求
在使用本工具前，开发者需要先获取hdc工具，执行hdc shell。
当前工具仅支持在eng版本中使用，在user版本中使用会出现报错error: user version cannot use setting。
anm工具命令列表
| 命令 | 描述 |
| --- | --- |
| help | 帮助命令，用于显示anm相关的帮助信息。 |
| dump | 打印命令，用于打印通知相关信息。 |
| setting | 设置命令，用于设置通知参数。 |
帮助命令（help）
打印命令（dump）
打印命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -A/--active | 打印所有活跃的通知信息。 |
| -R/--recent | 打印最近的通知信息。 |
| -D/--distributed | 打印来自其他设备的分布式通知信息。 |
| -b/--bundle | 可选参数，设置指定的Bundle名称打印。 |
| -u/--user-id | 可选参数，设置指定的用户ID打印。 |
| -h/--help | 帮助信息。 |
示例：
设置命令（setting）
设置命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -c/--recent-count | 设置保存在内存中的最近通知的最大个数。 |
| -e/--enable-notification | 设置通知使能开关。 |
| -h/--help | 帮助信息。 |
示例：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/edm-tool-V14
爬取时间: 2025-04-28 19:24:01
来源: Huawei Developer
Enterprise Device Manager（企业设备管理工具，简称为edm），为设备管理应用提供调试和测试能力，例如激活企业设备管理拓展能力、解除激活企业设备管理拓展能力。
环境要求
在使用本工具前，开发者需要先获取hdc工具，执行hdc shell。
edm工具命令列表
| 命令 | 描述 |
| --- | --- |
| help | 帮助命令，用于查询edm支持的命令信息。 |
| enable-admin | 激活命令，用于激活企业设备管理拓展能力，目标组件必须为enterpriseAdmin类型的ExtensionAbility。 |
| disable-admin | 解除激活命令，用于解除激活企业设备管理拓展能力。 |
帮助命令（help）
激活命令（enable-admin）
激活命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助信息。 |
| -n/--bundle-name | 必选参数，bundleName。 |
| -a/--ability-name | 必选参数，abilityName。 |
示例：
解除激活命令（disable-admin）
解除激活命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助信息。 |
| -n/--bundle-name | 必选参数，bundleName。 |
示例：
edm工具错误信息
error: command requires option
错误描述
未传入bundleName和abilityName。
可能原因
未传入bundleName和abilityName。
处理步骤
1、如果当前使用的命令是enable-admin，请补充-n <bundle-name>和-a <ability-name>参数。
2、如果当前使用的命令是disable-admin，请补充-n <bundle-name>参数。
error: -n, --bundle-name option requires an argument
错误描述
传入的bundleName为空。
可能原因
传入的bundleName为空。
处理步骤
检查-n后的参数，请补充bundleName。
error: -a, --ability-name option requires an argument
错误描述
传入的abilityName为空。
可能原因
传入的abilityName为空。
处理步骤
检查-a后的参数，请补充abilityName。
error: unknown option
错误描述
传入了未知的参数。
可能原因
传入了未知的参数。
处理步骤
请确认参数是否在参数列表中。
error: -n <bundle-name> is expected
错误描述
未传入bundleName。
可能原因
未传入bundleName。
处理步骤
请补充-n <bundle-name>。
error: -a <ability-name> is expected
错误描述
未传入abilityName。
可能原因
未传入abilityName。
处理步骤
请补充-a <ability-name>。
error: the administrator ability component is invalid
错误描述
传入的bundleName或者abilityName不正确或者不是enterpriseAdmin类型的ExtensionAbility。
可能原因
1、传入的bundleName不正确。
2、传入的abilityName不正确。
3、传入的不是enterpriseAdmin类型的ExtensionAbility。
处理步骤
查询应用的bundleName和enterpriseAdmin类型的ExtensionAbility的abilityName，并将其传入到参数中。
error: failed to enable the administrator application of the device
错误描述
激活失败。
可能原因
1、传入的bundleName不正确。
2、传入的不是enterpriseAdmin类型的ExtensionAbility。
3、存在已激活的正式的enterpriseAdmin类型的ExtensionAbility。
处理步骤
1、查询应用的bundleName和enterpriseAdmin类型的ExtensionAbility的abilityName，并将其传入到参数中。
2、请使用未被管控的设备进行调试。
error: failed to disable the administrator application of the device
错误描述
解除激活失败。
可能原因
1、此组件未被激活。
2、此组件不是通过hdc命令被激活的。
3、解除激活失败。
处理步骤
查询可以被hdc命令解除激活的应用的bundleName，并将其传入到参数中。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/restool-V14
爬取时间: 2025-04-28 19:24:15
来源: Huawei Developer
简介
restool是一种应用工程资源编译工具，通过编译资源文件创建资源索引、解析资源，开发者可以调用资源管理接口获取到对应资源。restool工具保存在sdk安装目录下的toolchains子目录。
参数说明
restool当前支持以下命令选项:
| 选项 | 是否可缺省 | 是否存在入参 | 描述 |
| --- | --- | --- | --- |
| -i | 不可缺省 | 带参数 | 指定需要构建的资源目录或者需要构建的资源中间件。同一个命令可以多次指定。 具体可参考如下编译资源命令。 |
| -j | 不可缺省 | 带参数 | 指定config.json或者module.json文件路径。 |
| -o | 不可缺省 | 带参数 | 指定已编译资源的输出路径。 |
| -p | 不可缺省 | 带参数 | 指定编译资源的bundle名称。 |
| -r | 不可缺省 | 带参数 | 指定资源的头文件路径，有三种格式：“.txt”、“.js”、“.h”。 |
| -e | 可缺省 | 带参数 | 指定生成资源的起始ID值，例如：0x01000000,范围[0x01000000, 0x06FFFFFF),[0x08000000, 0x41FFFFFF) |
| -f | 可缺省 | 不带参数 | 如果输出路径已经存在。强制删除，重新生成。 |
| -h | 可缺省 | 不带参数 | 查看工具帮助信息。 |
| -m | 可缺省 | 带参数 | 多模块联合编译时，指定多个模块名。用“，”连接。 |
| -x | 可缺省 | 带参数 | 指定生成中间文件的资源目录或单个资源路径。同一个命令可以多次指定。 |
| -z | 可缺省 | 不带参数 | 针对资源中间文件目录，生成编译结果。 |
| -v | 可缺省 | 不带参数 | 查看工具版本号。 |
| --ids | 可缺省 | 带参数 | 指定生成id_defined.json的输出目录。 |
| --defined-ids | 可缺省 | 带参数 | 指定id_defined.json文件路径，一般都是通过--ids生成。 id_defined.json包含资源类型、名称及其ID的列表。 开发者可以自定义id_defined.json中的资源ID。 |
| --icon-check | 可缺省 | 不带参数 | 开启icon和startWindowIcon的PNG图片校验功能。 |
| --target-config | 可缺省 | 带参数 | 与“-i”命令同时使用，支持选择编译。 参数说明：指定要包含的配置。 |
指定需要构建的资源目录或者需要构建的资源中间件。同一个命令可以多次指定。
具体可参考如下编译资源命令。
指定id_defined.json文件路径，一般都是通过--ids生成。
id_defined.json包含资源类型、名称及其ID的列表。
开发者可以自定义id_defined.json中的资源ID。
与“-i”命令同时使用，支持选择编译。
参数说明：指定要包含的配置。
target-config参数说明
支持参数配置类型：MccMnc、Locale、Orientation、Device、ColorMode、Density。
参数格式说明：配置之间用“;”分割，配置中的值用“[]”封装，并使用“,”分割。
MccMnc匹配规则：Mcc（国家码）必须相同；Mnc（网络码）不存在时默认匹配，否则Mnc须相同才匹配。
Locale匹配规则：Locale匹配需满足以下三条规则。
1、语言须相同。
2、脚本（文字）不存在时默认匹配，否则必须相同。
3、国家或地区不存在时默认匹配，否则必须相同。
参数举例说明：Locale[zh_CN,en_US];Device[phone]，该参数过滤其他语言，保留能匹配上zh_CN和en_US的语言；过滤其他设备，保留phone；其他参数（如MccMnc、Orientation等）配置不过滤均保留。
使用实例
例如：entry目录结构如下
编译资源
编译资源的方式有两种，分别是全量资源编译和增量资源编译。
1、全量资源编译，命令如下：
2、增量资源编译，具体步骤如下：
步骤一：生成资源中间件，命令如下:
步骤二：编译资源中间件，命令如下:
固定资源ID
固定资源ID，具体步骤如下：
步骤一：创建id_defined.json文件。创建方式有两种，分别是通过命令行和自定义。
步骤二：完成资源ID固定。完成固定的方式有两种，通过命令一完成固定或者将自定义的id_definded.json放在resource/base/element/目录下后通过命令二完成固定。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/param-tool-V14
爬取时间: 2025-04-28 19:24:28
来源: Huawei Developer
param是为开发人员提供用于操作系统参数的工具，该工具只支持标准系统。
环境要求
param工具命令列表
| 选项 | 说明 |
| --- | --- |
| -h | 获取param支持的命令。 |
| ls [-r] [name] | 显示匹配name的系统参数信息。带"-r"则根据参数权限获取信息，不带"-r"则直接获取参数信息。 |
| get [name] | 获取指定name系统参数的值；若不指定任何name，则返回所有系统参数。 |
| set name value | 设置指定name系统参数的值为value。 |
| wait name [value] [timeout] | 同步等待指定name系统参数与指定值value匹配。value支持模糊匹配，如"*"表示任何值，"val*"表示只匹配前三个val字符。timeout为等待时间（单位：s），不设置则默认为30s。 |
| save | 保存persist参数到工作空间。 |
获取param支持的命令
-  获取param支持的命令，命令格式如下：
获取系统参数信息
-  显示匹配name的系统参数信息，命令格式如下： 示例
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170533.81664050158435781447122416459499:50001231000000:2800:7F81DE335698FC49DD65C3CEC596BAA2BD30D0121C76FA71A0239E5EC7914542.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.20100708849236878099953355586371:50001231000000:2800:DABBC325E15C8E4D99D66E6F85E51D1306F89BE14A3045B84FD12E032B4335EB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.48861440774683070546838212383125:50001231000000:2800:5F3FB24245BC42AFBDA8C2DE8565C52560BAE9EE7A0C2B9EC5F1DB2A81C61FDE.png)
获取系统参数的值
-  获取指定name系统参数的值，命令格式如下： 示例
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.07862609046731818139205774316528:50001231000000:2800:BDAED69F8EE86CFE61C72FBDD4709955744386DB08585D6DCD5CA5E86627C621.png)
设置系统参数的值
-  设置指定name系统参数的值为value，命令格式如下： 示例
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.52721849916566995974457706967445:50001231000000:2800:556965D85C72FF2E14650CBB5C82C0A8249D7B3E2E32A955231449B9E3A33BCF.png)
等待系统参数值匹配
-  同步等待指定name系统参数与指定值value匹配，命令格式如下： 示例
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.04252474723637267436818525385824:50001231000000:2800:9C2F0B570F60ACAE834B472DE85ED7B7C62C7D1D6D9C971C686012B59C15F9F6.png)
保存persist(可持久化)参数
-  保存persist(可持久化)参数到工作空间，命令格式如下： 示例
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.46425674903384668723090955354584:50001231000000:2800:0A53716CEE15B7A30B22FC22E2539C970C71EF0C6908E7C69936FD6C56BC5E36.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/power-shell-V14
爬取时间: 2025-04-28 19:24:42
来源: Huawei Developer
power-shell是实现设备电源状态转换等功能的工具，为开发者提供基本的设备电源状态调试能力，例如：熄屏、唤醒、设置电源模式等。
环境要求
开发者在使用本工具前需开启开发者模式，且需要获取hdc工具，执行hdc shell。
power-shell命令工具列表
| 命令 | 描述 |
| --- | --- |
| help | 帮助命令，显示power-shell支持的命令信息。 |
| setmode | 设置电源模式命令，用来设置当前设备的电源模式。 |
| wakeup | 亮屏命令，用来唤醒系统并亮屏。 |
| suspend | 熄屏命令，用来暂停系统并熄屏。 |
| timeout | 自动熄屏命令，用来覆盖或恢复系统设置中自动熄屏时间。 |
帮助命令
设置电源模式命令
设置电源模式命令列表
| 命令 | 描述 |
| --- | --- |
| power-shell setmode -h | 显示setmode支持的命令信息。 |
| power-shell setmode 600 | 正常模式。 |
| power-shell setmode 601 | 省电模式。 |
| power-shell setmode 602 | 性能模式。 |
| power-shell setmode 603 | 超级省电模式。 |
示例：
亮屏命令
亮屏命令列表
| 命令 | 描述 |
| --- | --- |
| power-shell wakeup | 亮屏。 |
示例：
熄屏命令
熄屏命令列表
| 命令 | 描述 |
| --- | --- |
| power-shell suspend | 熄屏。 |
示例：
自动熄屏命令
自动熄屏命令参数列表
| 参数 | 参数说明 |
| --- | --- |
| -o <time> | 必选参数，设置自动熄屏时间。[time]单位为毫秒。 |
| -r | 必选参数，恢复到当前系统设置中的自动熄屏时间。 |
示例：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/openharmony_sdk_upgrade_assistant-V14
爬取时间: 2025-04-28 19:24:56
来源: Huawei Developer
简介
HarmonyOS SDK 升级助手，用于帮助开发者快速解决HarmonyOS应用SDK升级导致的API不兼容问题。
由于HarmonyOS SDK Beta版本不承诺API稳定性，在SDK升级后，可能存在API不兼容的问题，应用开发者对现在工程切换API版本后，需要适配API接口及其底层行为的变更，存在一定的升级成本；因此HarmonyOS提供了SDK升级助手，可以帮助开发者快速了解升级适配全貌，并通过工具提示快速适配升级，显著提高SDK升级效率。
约束与限制
使用教程
工具安装
1.在DevEco Studio主菜单栏中点击 "File" > "Settings..."。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.84282817363454950106293878258450:50001231000000:2800:FB6A81553F9D6F02020B43F43053E9717A14E1F0571FED13FB3635F90B305309.png)
2.在Settings弹出框界面，选中"Plugins"进入IDE插件模块。
3.点击"Marketplace"选项，在下方搜索框中输入"HarmonyOS SDK Upgrade Assistant"。
4.点击搜索到的插件右方"Install"按钮进行下载安装，安装完成之后点击"Apply"按钮，重启IDE即安装成功（注意：插件安装完成后需要重启IDE）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.61773412113272208965653449610362:50001231000000:2800:E473DBE21BBAECC86E1824B255FF33B65C9B5356E4E6EAF406C4698F383FC14A.png)
使用工具
辅助升级插件安装好后，打开需要升级的HarmonyOS工程。
工程加载完毕后，点击窗口上方主菜单栏的"UpdateCheck" > "Start"。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.42189053404801008605372642412606:50001231000000:2800:DC59BA6FFFC7F42697C93203B13369C879342C325AB6401EA9B40E83B87C620B.png)
手动选择旧版本SDK路径，需要选择到“ets”文件夹。新版本SDK路径将通过IDE配置文件及当前应用配置的SDK版本自动获取。路径选择完成后，点击“OK”按钮，开始生成辅助升级报告。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.80983649050079828515706792309061:50001231000000:2800:491F8F73AA96BBE20780C0E204284EC2005A197ABDECFC7C2F264E286A219B89.png)
报告生成成功后，将弹窗提示，点击“OK”按钮，关闭当前弹窗。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.92978903253591122078941501960831:50001231000000:2800:90AD93F4B7282C761DDA2078101FE6723B972CD9D60B2B7A280DB299E91B28E0.png)
根据弹窗提示，打开下方工具栏内UpdateReport按钮，查看升级报告。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.72040606701296769376108385159142:50001231000000:2800:BBA26CB5768CECBCF9B578D92B01D40EE556FFEDA36AB7ADE9F50C2B04767346.png)
报告功能点介绍
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.70941734277416782567470588876618:50001231000000:2800:304CEE6559FE595D94F1710C7E469CD64E69673A23887172D0BA57FB49754E49.png)
打包构建
1.interface仓中 cloneapi_diff工具(对比两个版本SDK里的API差异)和collect_application_api工具(用于解析并汇总应用中使用到的API)到本地。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170534.67274896226142031455922152831517:50001231000000:2800:25D1DC6E51D72E8F47B0CDC18CB2D0B7E6C5FB46FDFBACD2BBED66A013983AC5.png)
2.在本地api_diff工具和collect_application_api工具目录下进入终端，进行安装和编译。
需保证node.js版本为14.
输入命令：npm install，之后进行构建：npm run build。构建成功之后，会在对应的工具文件夹下生成dist=>build=>api-diff.js和dist=>build=>api-collector.js。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170535.97024573438641908180754633102535:50001231000000:2800:27BFB20238315FA053BA8550373CCA12AF777EE031D388C5DFC2B483F3EE1970.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170535.60804552117308292656392438298767:50001231000000:2800:C71D6A551DDD608C1ADA550C3C9FB1EAE2DA214E993D525BA20E6162A1B0392D.png)
3.在本地磁盘的最后一个盘符，创建名为'updateCheck'文件夹，内部分别创建'api-diff'和'collect_application_api'文件夹。
将步骤3中的api-diff.js文件放置'api-diff'文件夹下，collect_application_api文件夹下libs文件夹以及api-collector.js放置在'collect_application_api'文件夹下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170535.98306501561966460022680503340869:50001231000000:2800:86472A23DE40BCB28F46B80EDABA81C584E731174A3789DF6BB50FB513CA3849.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170535.34297023529732353701472830202930:50001231000000:2800:881AE36B4C8216AF8988463D49F75DB432872940CE6F331DF59736AE28AF888D.png)
4.升级辅助工具源码clone下来之后，在idea上打开，需要配置gradle环境，并且在src同级目录下新建'build.gradle.kts'文件，将下面内容粘贴至文件中，刷新gradle，在idea右侧gradle工具栏即可运行项目和打包成插件。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/atm-tool-V14
爬取时间: 2025-04-28 19:25:09
来源: Huawei Developer
Access Token Manager (程序访问控制管理工具，简称atm工具)，是用于查询应用进程的权限、使用类型等信息的工具，为开发者提供了根据tokenid、包名、进程名等信息进行访问控制管理的能力。
环境说明
在使用本工具前，开发者需要先获取hdc工具，执行hdc shell。
atm工具命令列表
| 命令 | 描述 |
| --- | --- |
| help | 帮助命令，显示atm支持的命令信息。 |
| dump | 查询命令，用于查询访问控制相关数据信息。 |
帮助命令
查询命令
下表所列命令中，-t、-v为必选参数，-i、-b、-n、-p为可选参数。对atm dump -v命令，-i和-p参数可以组合使用；对atm dump -t命令，-i、-b、-n参数只能单独使用。
| 参数 | 参数说明 |
| --- | --- |
| -h | 帮助信息。 |
| -t | 必选参数，查询系统中所有应用进程信息。 |
| -t -i <token-id> | 可选参数，通过应用进程的tokenid，查询该应用的基本信息以及对应的权限信息。 |
| -t -b <bundle-name> | 可选参数，通过应用进程的包名bundle-name，查询该应用的基本信息以及对应的权限信息。 |
| -t -n <process-name> | 可选参数，通过应用进程的进程名process-name，查询该应用的基本信息以及对应的权限信息。 |
| -v | 必选参数，查询系统中所有应用进程的权限使用类型。 |
| -v -i <token-id> | 可选参数，通过应用进程的tokenid，查询该应用的权限使用类型。 |
| -v -p <permission-name> | 可选参数，通过权限名，查询该权限的使用类型。 |
示例：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hilog-V14
爬取时间: 2025-04-28 19:25:23
来源: Huawei Developer
HiLog日志系统，提供给系统框架、服务、以及应用，用于打印日志，记录用户操作、系统运行状态等。开发者可以通过hilog命令行查询相关日志信息。
环境要求
-  根据hdc命令行工具指导，完成环境准备。
-  正常连接设备。
命令行说明
| 短选项 | 长选项 | 参数 | 说明 |
| --- | --- | --- | --- |
| -h | --help | - | 帮助命令。 |
| 缺省 | 缺省 | - | 阻塞读日志，不退出。 |
| -x | --exit | - | 非阻塞读日志，读完退出。 |
| -g | - | - | 查询buffer的大小，配合-t指定某一类型使用，默认app和core。 |
| -G | --buffer-size | <size> | 设置指定<type>日志类型缓冲区的大小，配合-t指定某一类型使用，默认app和core， 可使用B/K/M为单位，范围为64K-16M。 |
| -r | - | - | 清除buffer日志，配合-t指定某一类型使用，默认app和core。 |
| -k | - | <on/off> | Kernel日志读取开关控制。 |
|   |   | on | 打开读取kernel日志。 |
|   |   | off | 关闭读取kernel日志。 |
| -s | --statistics |   | 查询统计信息，需配合-t或-D使用。 |
| -S | - | - | 清除统计信息，需配合-t或-D使用。 |
| -Q | - | <control-type> | 流控缺省配额开关控制。 |
|   |   | pidon | 进程流控开关打开。 |
|   |   | pidoff | 进程流控开关关闭。 |
|   |   | domainon | domain流控开关打开。 |
|   |   | domainoff | domain流控开关关闭。 |
| -L | --level | <level> | 指定级别的日志，示例：-L D/I/W/E/F。 |
| -t | --type | <type> | 指定类型的日志，示例：-t app/core/init/only_prerelease。app为应用日志，core为系统日志，init为启动日志，only_prerelease为仅在系统release版本前打印的日志，应用开发者无需关注。 |
| -D | --domain | <domain> | 指定domain。 |
| -T | --tag | <tag> | 指定tag。 |
| -a | --head | <n> | 只显示前<n>行日志。 |
| -z | --tail | <n> | 只显示后<n>行日志。 |
| -P | --pid | <pid> | 标识不同的pid。 |
| -e | --regex | <expr> | 只打印日志消息与<expr>匹配的行，其中<expr>是一个正则表达式。 |
| -f | --filename | <filename> | 设置落盘的文件名。 |
| -l | --length | <length> | 设置落盘的文件大小，需要大于等于64K。 |
| -n | --number | <number> | 设置落盘文件的个数。 |
| -j | --jobid | <jobid> | 设置落盘任务的ID。 |
| -w | --write | <control> | 落盘任务控制。 |
|   |   | query | 落盘任务查询。 |
|   |   | start | 落盘任务开始，命令行参数为文件名、单文件大小、落盘算法、rotate文件数目。 |
|   |   | stop | 落盘任务停止。 |
|   |   | refresh | 刷新缓冲区的日志到落盘文件。 |
|   |   | clear | 删除已经落盘的日志文件。 |
| -m | --stream | <algorithm> | 落盘方式控制。 |
|   |   | none | 无压缩方式落盘。 |
|   |   | zlib | zlib压缩算法落盘，落盘文件为.gz。 |
|   |   | zstd | zstd压缩算法落盘，落盘文件为.zst。 |
| -v | --format | <format> | 显示格式控制。 |
|   |   | time | 显示本地时间。 |
|   |   | color | 显示不同级别显示不同颜色，参数缺省级别颜色模式处理（按黑白方式）。 |
|   |   | epoch | 显示相对1970时间。 |
|   |   | monotonic | 显示相对启动时间。 |
|   |   | usec | 显示微秒精度时间。 |
|   |   | nsec | 显示纳秒精度时间。 |
|   |   | year | 显示将年份添加到显示的时间。 |
|   |   | zone | 显示将本地时区添加到显示的时间。 |
|   |   | wrap | 日志换行显示时，新行不增加时间戳等前缀。 |
| -b | --baselevel | <loglevel> | 设置可打印日志的最低等级：D(DEBUG)/I(INFO)/W(WARN)/E(ERROR)/F(FATAL)。 |
常用命令
查看帮助命令
使用样例：
非阻塞读日志
使用样例：
查看日志缓冲区大小
使用样例：
修改日志缓冲区大小
使用样例：
清除缓冲区日志
使用样例：
内核日志读取开关控制
使用样例：
查询统计信息
使用样例：
统计信息说明
清除统计信息
使用样例：
进程流控开关
使用样例：
domain流控开关
使用样例：
查看指定级别日志
使用样例：
查看指定类型日志
使用样例：
查看指定domain日志
使用样例：
查看指定TAG日志
使用样例：
查看缓冲区前n行日志
使用样例：
查看缓冲区后n行日志
使用样例：
查看指定进程日志
使用样例：
查看符合正则匹配关键字的日志
使用样例：
查看、设置落盘任务
查询当前任务： hilog -w query
开启hilog落盘任务，并且设置落盘文件数量为1000个： hilog -w start -n 1000
开启kmsglog落盘任务，并且设置落盘文件数量为100个： hilog -w start -n 100 -t kmsg
停止当前落盘任务： hilog -w stop
开启kmsglog落盘任务，并且设置落盘规则，其中压缩方式可以为zlib，zstd，none。以设置规则为例：文件名为kmsglog，大小为2M，数量为100个, 其压缩方式为zlib压缩，命令行为： hilog -w start -t kmsg -f kmsglog -l 2M -n 100 -m zlib
使用样例：
设置日志显示格式
使用样例：
设置可打印日志的最低等级
使用样例：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hidumper-V14
爬取时间: 2025-04-28 19:25:37
来源: Huawei Developer
HiDumper为开发、测试人员提供统一的系统信息获取工具，可帮助使用者分析，定位问题。
环境要求
-  根据hdc命令行工具指导，完成环境准备。
-  正常连接设备。
命令行说明
| 选项 | 说明 |
| --- | --- |
| -h | 帮助命令。 |
| -lc | 列出系统信息集群。 |
| -ls | 列出系统能力。 |
| -c | 获取系统信息集群详细信息。 |
| -c [base system] | 获取"base"或者"system"信息集群详细信息。 |
| -s | 获取所有系统能力详细信息。 |
| -s [SA0 SA1] | 获取一个或多个系统能力详细信息。 |
| -s [SA] -a ["option"] | 执行单个系统能力的特定选项。SA表示系统能力名称，option表示该系统能力支持的选项。可通过 -s [SA] -a ["-h"] 获取单个系统能力支持的所有选项。 |
| -e | 获取崩溃历史记录的故障日志。 |
| --net [pid] | 获取网络信息。如果指定了进程的pid，则只输出该进程的网络流量使用信息。 |
| --storage [pid] | 获取存储信息。如果指定了进程的pid，则只输出该进程的io信息。 |
| -p [pid] | 获取进程信息，包括进程和线程的列表和信息。 |
| --cpuusage [pid] | 获取CPU使用率,按进程和类别分类；如果指定pid，则获取指定pid的CPU使用信息。 |
| --cpufreq | 获取CPU每个核的真实频率。 |
| --mem [pid] | 获取总内存占用率；如果指定pid，则获取指定pid的内存占用率。 |
| --zip | 保存命令输出到/data/log/hidumper下的压缩文件。 |
| --ipc pid/-a --start-stat/stop-stat/stat | 统计一段时间进程IPC信息，如果使用-a则统计所有进程IPC数据，--start-stat开始统计，--stat获取统计数据，--stop-stat结束统计。 |
| --mem-smaps pid [-v] | 获取pid内存统计信息，数据来源于/proc/pid/smaps，使用-v指定更多详细信息。 (仅限制debug版本使用) |
| --mem-jsheap pid [-T tid] [--gc] [--leakobj] | pid 必选参数。命令触发所有线程gc和快照导出。如果指定线程的tid，只触发该线程gc和快照导出；如果指定--gc，只触发gc不做快照导出；如果指定--leakobj，则获取泄露对象的列表。 |
常用命令
1.  查看帮助命令。 使用样例：
2.  列出系统信息集群。 使用样例：
3.  列出系统能力。 使用样例：
4.  获取系统信息集群详细信息。 使用样例：
5.  获取"base"或者"system"信息集群详细信息。 使用样例：
6.  获取所有系统能力详细信息，命令格式如下： 使用样例：
7.  获取一个或多个系统能力详细信息，命令格式如下： 使用样例：
8.  执行单个系统能力的特定选项。 获取RenderService的使用帮助，命令格式如下： 使用样例： 获取对应surface的刷新帧率，可以使用以下命令，返回值为surface刷新帧对应的时间戳。 使用样例： 为开发者提供使设备不自动息屏的能力。-t参数使设备不自动息屏，-f参数使设备恢复自动息屏，或者设备重启使设备恢复自动息屏。 使用样例：
9.  获取Faultlog模块生成的崩溃历史信息。 使用样例：
10.  获取网络信息；如果指定了进程的pid，则只获取该进程的网络流量使用信息。 使用样例：
11.  获取存储信息。如果指定了进程的pid，则只输出该进程的io信息。 使用样例：
12.  获取进程信息，包括进程、线程的列表等信息。 该命令在release版本只支持导出debug应用的进程信息。 如何区分debug/release版本： 命令1：执行hdc shell "param get|grep const.debuggable"查看输出为0还是1。 命令2：执行hdc shell "param get|grep const.product.software.version"查看当前版本是否包含"log"字符串。 release版本:命令1执行结果为0且命令2不包含"log"字符串 debug版本:非release版本即为debug版本 使用样例：
13.  获取CPU使用率，根据进程和类别分类展示。 使用样例：
14.  获取CPU每个核的真实频率。 使用样例：
15.  获取设备中所有pid的内存信息。 使用样例： 获取设备中指定pid的内存信息。 使用样例： Graph字段统计方式为：计算/proc/process_dmabuf_info节点下该进程使用的内存大小。
16.  保存命令输出到/data/log/hidumper下的压缩文件。 使用样例：
17.  统计一段时间进程IPC信息，如果使用-a则统计所有进程IPC数据，指定pid则统计对应进程的IPC数据。--start-stat开始统计，--stat获取统计数据，--stop-stat结束统计。 使用样例： 使用样例：
18.  导出指定进程内存信息的详细使用情况。 该命令仅限debug版本使用，release版本不可用。 如何区分debug/release版本：请查看hidumper -p中说明。 使用样例：
19.  运行hidumper --mem-jsheap pid [-T tid] [--gc] [--leakobj]pid 必选参数。命令触发所有线程gc和快照导出。如果指定线程的tid，只触发该线程gc和快照导出；如果指定--gc，只触发gc不做快照导出;如果指定--leakobj，则获取泄露对象的列表。(仅限debug版本使用) 该命令在release版本只支持导出debug应用的快照信息。 如何区分debug和release版本：请查看hidumper -p中说明。 导出的jsheap文件一般位于/data/log/faultlog/temp或/data/log/reliability/resource_leak/memory_leak下 使用样例：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hitrace-V14
爬取时间: 2025-04-28 19:25:51
来源: Huawei Developer
HiTrace为开发者提供业务流程调用链跟踪的维测接口。通过使用该接口所提供的功能，帮助开发者迅速获取指定业务流程调用链的运行日志，定位跨设备、跨进程、跨线程的故障问题。
环境要求
-  根据hdc命令行工具指导，完成环境准备。
-  正常连接设备。
命令行说明
| 命令 | 含义说明 |
| --- | --- |
| -h | 帮助命令。 |
| -l | 查看tag列表。 |
| --trace_begin | 开始捕获trace。 |
| --trace_finish | 结束捕获trace。 |
| --trace_dump | 导出trace信息。 |
| -b N | 设置用于存储和读取trace的缓冲区大小(buffer size KB)。默认的缓冲区大小为2048 KB。 |
| -t N | 设置hitrace运行时长，单位为秒（默认为5秒），取决于分析所需的时间。 |
| -o | 文件名指定目标文件的名称（默认为stdout）。 |
| -z | 压缩捕获的跟踪。 |
| --trace_clock | 设置向trace添加时间戳的时钟类型，可以是引导（默认）、全局、单声道、正常运行时间或性能。 |
| --trace_finish_nodump | 停止捕获trace时不打印trace信息。 |
| --start_bgsrv | 开启快照模式trace采集服务。 |
| --dump_bgsrv | 触发快照模式trace输出到文件。 |
| --stop_bgsrv | 关闭快照模式trace采集服务。 |
快照模式定义为固定trace标签的trace采集服务，默认情况不落盘，开发者可通过 --dump_bgsrv 命令触发当前时刻的trace转储，trace为二进制格式，文件默认生成在 /data/log/hitrace 目录下，文件命名格式为trace-YYMMDDHHmmSS@[BOOT_TIME].sys。可通过smpartperf在线工具进行查看。
常用命令
在hdc shell执行如下命令：
1.  查看hitrace包含的tag。 使用样例：
2.  开始抓指定tag的trace。 使用样例：
3.  结束抓trace。 使用样例1： 使用样例2：
4.  设置抓trace的一些信息：hitrace -b 10240 -t 10 -o /data/local/tmp/test2.ftrace app ability。 使用样例：
5.  导出trace信息。 使用样例1： 使用样例2：
6.  开启快照模式trace采集服务。 使用样例：
7.  快照模式导出trace。 默认将trace信息保存至/data/log/hitrace/文件夹下，文件命名格式为trace-YYMMDDHHmmSS@[BOOT_TIME].sys，抓到的是二进制trace。可通过smpartperf在线工具进行查看。 使用样例：
8.  关闭快照模式trace采集服务。 使用样例：
9.  抓取trace后进行压缩。 使用样例：
10.  设置trace的输出时钟为boot(设备系统时间)。
使用样例：
使用样例：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/hiperf-V14
爬取时间: 2025-04-28 19:26:05
来源: Huawei Developer
hiperf为开发人员提供用于调试的命令行工具，用于抓取特定程序或者系统的性能数据，类似内核的perf工具，该工具支持在 Windows/Linux/Mac 等操作系统上运行。
环境要求
-  根据hdc命令行工具指导，完成环境准备。
-  正常连接设备。
hiperf命令行说明
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助命令。 |
| --debug | 输出debug级别日志。 |
| --hilog | 日志写入hilog。 |
| --logpath | 日志路径。 |
| --logtag | 日志等级。 |
| --mixlog | 混合日志输出。 |
| --much | 输出尽可能多的日志。 |
| --nodebug | 无日志输出。 |
| --verbose | 输出verbose级别日志。 |
帮助命令
可用 --help 查看帮助。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170535.56012752826991705695438388356485:50001231000000:2800:169AD97F78F86F8DE7D259DE8ED0467C15B93EC4F1A47E816FDAE0A2FD078C30.png)
使用如下命令查看子功能的帮助信息。
list命令
可列出设备上支持的所有事件名称，事件名称用于 stat 和 record 的 -e 和 -g 参数。
list命令参数说明
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助命令。 |
| hw | 硬件事件。 |
| sw | 软件事件。 |
| tp | tracepoint事件。 |
| cache | 硬件缓存事件。 |
| raw | 原始pmu事件。 |
使用help命令查询支持的事件类型。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170536.54111626267416262790421849334614:50001231000000:2800:29A96A428E39CB8C22945C91AEECAFB84A0BE5E87E89B6A652009F45E327FC1A.png)
下面列出了设备支持的HW事件，并且会提示哪些事件此设备不支持。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170536.02203485605800725392667381281310:50001231000000:2800:ED4034120EF2D32CFBCDC2B1B792F6303658D4CD0530C0A927A5C49E36E033BF.png)
record命令
采样指定目标程序，并且将采样数据保存到指定的文件中(默认为/data/local/tmp/perf.data)。
record命令参数说明
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助命令。 |
| -a | 采集整机信息，用于评估所有进程、线程。 |
| --exclude-hiperf | 不采集hiperf本身数据。 |
| -c | 设置采集的cpuid,只采集这些cpu数据。 |
| --cpu-limit | 设置采集时cpu最大占比，取值范围：1 - 100，默认25。 |
| -d | 采集时长。 |
| -f | 采集频率，默认4000次每秒，不能和--period一起使用。 |
| --period | 设置采集事件周期，多少事件采集一次，不能和-f一起使用。 |
| -e | 采集事件，以逗号隔开。 |
| -g | 采集事件群组，以逗号隔开。 |
| --no-inherit | 不采集子进程数据。 |
| -p | 采集进程ID，以逗号隔开，不能和-a一起使用。 |
| -t | 采集线程ID，以逗号隔开，不能和-a一起使用。 |
| --exclude-tid | 不采集线程ID，以逗号隔开，不能和-a一起使用。 |
| --exclude-thread | 不采集线程名，以逗号隔开，不能和-a一起使用。 |
| --offcpu | 跟踪线程何时脱离cpu调度。 |
| -j | 分支堆栈采样，过滤器支持any、any_call、any_ret、ind_call、ind_jmp、cond、call。 |
| -s/--callstack | 设置回栈模式。 |
| --kernel-callchain | 采集内核态堆栈，必须和-s fp/dwarf一起使用。 |
| --callchain-useronly | 只收集用户态堆栈。 |
| --delay-unwind | -s dwarf被设置时栈会在录制时展开，设置此选项栈会在录制后展开。 |
| --disable-unwind | -s dwarf被设置时，默认情况下，录制时堆栈将不会展开。 |
| --disable-callstack-expand | -s dwarf被设置时，破除64K栈限制，默认情况下合并callstack构建更完整的调用堆栈，可能有时候会不准确。 |
| --enable-debuginfo-symbolic | -s fp/dwarf被设置时，elf在.gnu_debugdata段的符号会被解析，默认不解析。 |
| --clockid | 设置采集时钟类型，支持monotonic 和 monotonic_raw。 |
| --symbol-dir | 在线符号化符号表文件路径。 |
| -m | mmap页数量，取值范围：2 - 1024，默认1024。 |
| --app | 采集的应用程序名，以逗号隔开，应用程序必须是debuggable模式，应用程序未启动时会等待20s。 |
| --chkms | 设置查询的间隔时间，取值范围：1 - 200，默认10。 |
| --data-limit | 输出数据达到指定大小停止采集，默认无限制。 |
| -o | 设置输出文件路径。 |
| -z | 以压缩文件形式输出。 |
| --restart | 收集应用启动的性能指标信息，如果进程在30秒内未启动，记录将退出。 |
| --verbose | 输出更详细的报告。 |
| --control [command] | 采集命令控制参数。命令包括prepare/start/pause/resume/stop。 |
| --dedup_stack | 删除记录中的重复堆栈，不能和-a一起使用。 |
| --cmdline-size | 设置/sys/kernel/tracing/saved_cmdlines_size节点的值，取值范围：512 - 4096。 |
| --report | 采集后回栈报告，不能和-a一起使用。 |
| --dumpoptions | dump命令选项。 |
对指定的PID为267的进程采样10秒，并且使用dwarf回栈。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170536.98172111875022977919348436107687:50001231000000:2800:6E4BDAADCF17B44D03B97476E623F49F07DB53065E437DBAD235859D962E76CB.png)
stat命令
监听指定目标程序，周期性打印性能计数器的值。
stat命令参数说明
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助命令。 |
| -a | 采集整机信息，用于评估所有进程、线程。 |
| -c | 设置采集的cpuid,限制采集哪些cpu数据。 |
| -d | 采集时长。 |
| -i | 设置每隔多少ms打印stat信息。 |
| -e | 采集事件，以逗号隔开。 |
| -g | 采集事件群组，以逗号隔开。 |
| --no-inherit | 不采集子进程数据。 |
| -p | 采集进程ID，以逗号隔开，不能和-a一起使用。 |
| -t | 采集线程ID，以逗号隔开，不能和-a一起使用。 |
| --app | 采集的应用程序名，以逗号隔开，应用程序必须是debuggable模式，应用程序未启动时会等待10秒。 |
| --chkms | 设置查询的间隔时间，取值范围：1 - 200，默认10。 |
| --per-core | 每个cpu核的打印计数。 |
| --pre-thread | 每个线程的打印计数。 |
| --restart | 收集应用启动的性能指标信息，如果进程在30秒内未启动，记录将退出。 |
| --verbose | 输出更详细的报告。 |
| --dumpoptions | dump命令选项。 |
下面展示了一个 stats 监听2349进程在CPU0上3秒的性能计数器命令。
dump命令
此命令主要以不加以处理的方式直接读取perf.data的数据，开发和测试人员可核对其中原始采样数据的正确性。
dump命令参数说明
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助命令。 |
| --head | 只输出数据头和属性。 |
| -d | 只输出数据段。 |
| -f | 只输出附加功能。 |
| --syspath | 符号表文件路径。 |
| -i | 资源文件路径。 |
| -o | 输出文件路径，未设置则输出到屏幕。 |
| --elf | 输出elf文件。 |
| --proto | 输出protobuf格式数据。 |
| --export | 将用户堆栈数据导出到某个分割文件，使用此命令生成ut数据。 |
使用dump命令将/data/local/tmp/perf.data文件读取出来，输出到/data/local/tmp/perf.dump文件中。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170536.67613376785692550677513966581627:50001231000000:2800:D8EA6055EC3B8F2F5767DCC8AEE1C5B668E7E248456DA510382BFEF1C7205942.png)
report命令
此命令主要用于展示相关采样数据（从perf.data中读取）并且转换为用户需要的格式（比如Json或者ProtoBuf）。
report命令参数说明
| 参数 | 参数说明 |
| --- | --- |
| -h/--help | 帮助命令。 |
| --symbol-dir | 符号表文件路径。 |
| --limit-percent | 只显示前面多少百分比的内容。 |
| -s | 显示回栈模式。 |
| --call-stack-limit-percent | 只显示前面多少百分比的堆栈内容。 |
| -i | 资源文件路径，默认perf.data。 |
| -o | 输出文件路径，未设置则输出到屏幕。 |
| --proto | 输出protobuf格式数据。 |
| --json | 输出json格式数据。 |
| --diff | 显示-i --diff两个文件的不同。 |
| --branch | 从地址而不是ip地址显示分支。 |
| --<keys> <keyname1>[,keyname2][,...] | 可选关键字：comms、pids、tids、dsos、funcs、from_dsos、from_funcs，例如： --comms hiperf。 |
| --sort [key1],[key2],[...] | 按关键字排序。 |
| --hide_count | 报告中不显示数值。 |
| --dumpoptions | dump命令选项。 |
范例输出普通报告的命令，限制为占比不超过1%。
脚本
一般用户用脚本执行采样操作，可生成可视化的火焰图。工具可在developtools_hiperf仓库中获取。
1.  采样。 由 command_script.py 完成，它是 report 命令的包装脚本。 对指定包名采样，包名是 com.ohos.launch。 对特定进程采样，进程名称是 hdcd。
2.  收集符号表。 由 recv_binary_cache.py 完成，它主要根据 perf.data 里面记录的相关文件和库以及它们的 buildid， 在用户指定的路径中去寻找对应的 ELF 作为符号表文件用于回栈或者打印函数名等。 指定了2个符号表路径的位置。 对应的符号表文件会复制到 binary_cache 文件夹，优先检查用户给出的符号表位置，如果没有则复制设备中的文件。
3.  生成火焰图。 由 make_report.py 完成，将采样后的数据导出为HTML展示页面。 产生HTML文件，默认的文件名是 hiperf_report.html。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/command-line-utilities-V14
爬取时间: 2025-04-28 19:27:30
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/toybox-V14
爬取时间: 2025-04-28 19:27:44
来源: Huawei Developer
toybox 是一个轻量级的Linux命令行工具集合，它将常用的Linux命令行工具合并到一个单独的可执行文件中。
前置条件
使用方法1
使用方法2
命令行说明
toybox的执行方式有两种：
-  toybox [command] [arguments...]
-  直接执行 [command] [arguments...]
其中 [command] 可被替换为toybox支持的任意命令（可通过输入不带参数的toybox命令查询）。
[arguments...] 为[command]所需要的参数。
当前版本中，不同设备对toybox的支持情况存在差异。开发者可直接执行toybox获取设备支持的全量命令。
帮助命令
格式：toybox [--long | --help | --version | [command] [arguments...]]
| 选项 | 参数 | 说明 |
| --- | --- | --- |
| --help | NA | 显示命令帮助。 |
| --long | NA | 显示支持的所有命令的路径。 |
| --version | NA | 显示版本号。 |
| NA | NA | 显示所有[command]支持的命令。 |
| [command] | [arguments] | 执行具体的命令。大部分命令也支持--help和--version参数。 |
格式：help [-ah] [command]
| 参数 | 说明 |
| --- | --- |
| command | 显示command的帮助。[command] 可被替换为toybox支持的任意命令。 |
| 选项 | 说明 |
| --- | --- |
| -a | 显示所有命令的帮助。 |
| -h | 以html格式显示帮助。 |
数学与计算机基础函数
| 命令 | 说明 |
| --- | --- |
| ascii | 显示acsii编码表。 usage: ascii  |
| factor | 分解质因数。 usage: factor NUMBER...  |
| mcookie | 生成128位强随机数。 usage: mcookie [-vV]  |
| mkpasswd | 对密码进行加密。 usage: mkpasswd [-P FD] [-m TYPE] [-S SALT] [PASSWORD] [SALT]  |
| uuidgen | 创建并打印新的RFC4122随机UUID。 usage: uuidgen  |
显示acsii编码表。
usage: ascii
分解质因数。
usage: factor NUMBER...
生成128位强随机数。
usage: mcookie [-vV]
对密码进行加密。
usage: mkpasswd [-P FD] [-m TYPE] [-S SALT] [PASSWORD] [SALT]
创建并打印新的RFC4122随机UUID。
usage: uuidgen
终端操作
| 命令 | 说明 |
| --- | --- |
| chvt | 切换到虚拟终端N。 usage: chvt N  |
| chroot | 以指定的根目录运行命令。 usage: chroot NEWROOT [COMMAND [ARG...]]  |
| clear | 清空终端。 usage: clear  |
| nohup | 运行一个独立于终端的命令。 usage: nohup COMMAND [ARG...]  |
| tty | 显示连接到标准输入设备的终端的名称。 usage: tty [-s]  |
| reset | 复位终端。 usage: reset  |
| microcom | 简单串口终端。 usage: microcom [-s SPEED] [-X] DEVICE  |
切换到虚拟终端N。
usage: chvt N
以指定的根目录运行命令。
usage: chroot NEWROOT [COMMAND [ARG...]]
清空终端。
usage: clear
运行一个独立于终端的命令。
usage: nohup COMMAND [ARG...]
显示连接到标准输入设备的终端的名称。
usage: tty [-s]
复位终端。
usage: reset
简单串口终端。
usage: microcom [-s SPEED] [-X] DEVICE
sh逻辑命令
| 命令 | 说明 |
| --- | --- |
| false | 返回非零值。 usage: false  |
| sh | shell命令解释器 |
| test | 通过执行测试返回true或false。没有参数时返回false。 usage: test [-bcdefghLPrSsuwx PATH] [-nz STRING] [-t FD] [X ?? Y]  |
| true | 返回零。 usage: true  |
| yes | 反复输出行直到被杀死。如果没有参数，则输出“y”。 usage: yes [args...]  |
返回非零值。
usage: false
通过执行测试返回true或false。没有参数时返回false。
usage: test [-bcdefghLPrSsuwx PATH] [-nz STRING] [-t FD] [X ?? Y]
返回零。
usage: true
反复输出行直到被杀死。如果没有参数，则输出“y”。
usage: yes [args...]
系统操作
| 命令 | 说明 |
| --- | --- |
| acpi | 查询电源、温度状态。 usage: acpi [-abctV]  |
| arch | 打印系统名称。 usage: arch  |
| dmesg | 显示或控制内核环形缓冲区。 usage: dmesg [-Cc] [-r | -t | -T] [-n LEVEL] [-s SIZE] [-w]  |
| dnsdomainname | 显示系统的名称（与 hostname -d 一致）。 usage: dnsdomainname  |
| getconf | 获取系统配置值，部分值需要path参数。 usage: getconf -a [PATH] | -l | NAME [PATH]  |
| env | 设置命令调用的环境，或列出环境变量。 usage: env [-i] [-u NAME] [NAME=VALUE...] [COMMAND [ARG...]]  |
| hostname | 获取当前主机名。 usage: hostname [-bdsf] [-F FILENAME] [newname]  |
| insmod | 加载内核模块。 usage: insmod MODULE [MODULE_OPTIONS]  |
| logger | 记录系统日志。 usage: logger [-s] [-t TAG] [-p [FACILITY.]PRIORITY] [message...]  |
| lsmod | 显示当前已经加载的模块，他们的大小和依赖。 usage: lsmod  |
| mix | 显示OSS声道，或者设置音量。 usage: mix [-d DEV] [-c CHANNEL] [-l VOL] [-r RIGHT]  |
| modinfo | 显示内核模块信息。 usage: modinfo [-0] [-b basedir] [-k kernel] [-F field] [module | file...]  |
| nproc | 打印处理器数量。 usage: nproc [--all]  |
| oneit | 简单的初始化程序。 usage: oneit [-p] [-c /dev/tty0] command [...]  |
| partprobe | 通知内核分区表已经变化。 usage: partprobe DEVICE...  |
| pivot_root | 修改根目录。 usage: pivot_root OLD NEW  |
| printenv | 打印环境变量。 usage: printenv [-0] [env_var...]  |
| reboot/halt/poweroff | 重启/停止/关机。 usage: reboot/halt/poweroff [-fn]  |
| rfkill | 开启/关闭无线设备。 usage: rfkill COMMAND [DEVICE]  |
| rmmod | 卸载内核模块。 usage: rmmod [-wf] [MODULE]  |
| sendevent | 发送Linux输入事件。 usage: sendevent DEVICE TYPE CODE VALUE  |
| swapoff | 停用交换空间。 usage: swapoff swapregion  |
| swapon | 在指定的设备或文件上，使能内存交换。 usage: swapon [-d] [-p priority] filename  |
| switch_root | 切换根目录，并执行新的INIT程序。 usage: switch_root [-c /dev/console] NEW_ROOT NEW_INIT...  |
| uname | 打印系统信息。 usage: uname [-asnrvm]  |
| vmstat | 打印虚拟内存信息。 usage: vmstat [-n] [DELAY [COUNT]]  |
查询电源、温度状态。
usage: acpi [-abctV]
打印系统名称。
usage: arch
显示或控制内核环形缓冲区。
usage: dmesg [-Cc] [-r | -t | -T] [-n LEVEL] [-s SIZE] [-w]
显示系统的名称（与 hostname -d 一致）。
usage: dnsdomainname
获取系统配置值，部分值需要path参数。
usage: getconf -a [PATH] | -l | NAME [PATH]
设置命令调用的环境，或列出环境变量。
usage: env [-i] [-u NAME] [NAME=VALUE...] [COMMAND [ARG...]]
获取当前主机名。
usage: hostname [-bdsf] [-F FILENAME] [newname]
加载内核模块。
usage: insmod MODULE [MODULE_OPTIONS]
记录系统日志。
usage: logger [-s] [-t TAG] [-p [FACILITY.]PRIORITY] [message...]
显示当前已经加载的模块，他们的大小和依赖。
usage: lsmod
显示OSS声道，或者设置音量。
usage: mix [-d DEV] [-c CHANNEL] [-l VOL] [-r RIGHT]
显示内核模块信息。
usage: modinfo [-0] [-b basedir] [-k kernel] [-F field] [module | file...]
打印处理器数量。
usage: nproc [--all]
简单的初始化程序。
usage: oneit [-p] [-c /dev/tty0] command [...]
通知内核分区表已经变化。
usage: partprobe DEVICE...
修改根目录。
usage: pivot_root OLD NEW
打印环境变量。
usage: printenv [-0] [env_var...]
重启/停止/关机。
usage: reboot/halt/poweroff [-fn]
开启/关闭无线设备。
usage: rfkill COMMAND [DEVICE]
卸载内核模块。
usage: rmmod [-wf] [MODULE]
发送Linux输入事件。
usage: sendevent DEVICE TYPE CODE VALUE
停用交换空间。
usage: swapoff swapregion
在指定的设备或文件上，使能内存交换。
usage: swapon [-d] [-p priority] filename
切换根目录，并执行新的INIT程序。
usage: switch_root [-c /dev/console] NEW_ROOT NEW_INIT...
打印系统信息。
usage: uname [-asnrvm]
打印虚拟内存信息。
usage: vmstat [-n] [DELAY [COUNT]]
时间日期
| 命令 | 说明 |
| --- | --- |
| cal | 打印日历。 usage: cal [[month] year]  |
| date | 设置/获取当前日期/时间。 usage: date [-u] [-r FILE] [-d DATE] [+DISPLAY_FORMAT] [SET]  |
| hwclock | 获取/设置硬件时钟。 usage: hwclock [-rswtluf]  |
| sleep | 等待设置的时间后再退出。可以是小数。可选的后缀可以是“m”（分钟）、“h”（小时）、“d”（天）或“s”（秒，默认值）。 usage: sleep DURATION  |
| time | 运行命令行并报告真实时间、用户时间和系统时间（以秒为单位）。(真实时间=时钟时间，用户时间=命令代码使用cpu的时间，系统时间=操作系统使用cpu的时间。) usage: time [-pv] COMMAND [ARGS...]  |
| uptime | 显示当前时间，系统运行了多长时间，用户数量，以及过去1、5和15分钟的系统负载平均值。 usage: uptime [-ps]  |
| usleep | 等待设置的时间后再退出，单位微秒。 usage: usleep MICROSECONDS  |
打印日历。
usage: cal [[month] year]
设置/获取当前日期/时间。
usage: date [-u] [-r FILE] [-d DATE] [+DISPLAY_FORMAT] [SET]
获取/设置硬件时钟。
usage: hwclock [-rswtluf]
等待设置的时间后再退出。可以是小数。可选的后缀可以是“m”（分钟）、“h”（小时）、“d”（天）或“s”（秒，默认值）。
usage: sleep DURATION
运行命令行并报告真实时间、用户时间和系统时间（以秒为单位）。(真实时间=时钟时间，用户时间=命令代码使用cpu的时间，系统时间=操作系统使用cpu的时间。)
usage: time [-pv] COMMAND [ARGS...]
显示当前时间，系统运行了多长时间，用户数量，以及过去1、5和15分钟的系统负载平均值。
usage: uptime [-ps]
等待设置的时间后再退出，单位微秒。
usage: usleep MICROSECONDS
登录用户操作
| 命令 | 说明 |
| --- | --- |
| groups | 打印用户所在的组。 usage: groups [user]  |
| id | 打印用户和组ID。 usage: id [-nGgru] [USER...]  |
| login | 用户登录。 usage: login [-p] [-h host] [-f USERNAME] [USERNAME]  |
| logname/whoami | 打印当前用户名。 usage: logname/whoami  |
| passwd | 更新用户的认证令牌。 usage: passwd [-a ALGO] [-dlu] [USER]  |
| who | 打印有关已登录用户的信息。  usage: who  |
| w | 显示用户登录情况和登录时间。 usage: w  |
打印用户所在的组。
usage: groups [user]
打印用户和组ID。
usage: id [-nGgru] [USER...]
用户登录。
usage: login [-p] [-h host] [-f USERNAME] [USERNAME]
打印当前用户名。
usage: logname/whoami
更新用户的认证令牌。
usage: passwd [-a ALGO] [-dlu] [USER]
打印有关已登录用户的信息。
usage: who
显示用户登录情况和登录时间。
usage: w
进程操作
| 命令 | 说明 |
| --- | --- |
| chrt | 获取/设置一个进程的调度策略和优先级。 usage: chrt [-Rmofrbi] {-p PID [PRIORITY] | [PRIORITY COMMAND...]}  |
| iorenice | 显示/修改一个进程的IO优先级。 usage: iorenice PID [CLASS] [PRIORITY]  |
| iotop | 根据I/O对进程排序。 usage: iotop [-AaKObq] [-n NUMBER] [-d SECONDS] [-p PID,] [-u USER,]  |
| ionice | 显示/修改一个进程的IO调度优先级。 usage: ionice [-t] [-c CLASS] [-n LEVEL] [COMMAND...|-p PID]  |
| kill | 向进程发送信号。 usage: kill [-l [SIGNAL] | -s SIGNAL | -SIGNAL] pid...  |
| killall | 向具有给定名称的所有进程发送信号（默认：SIGTERM）。 usage: killall [-l] [-iqv] [-SIGNAL | -s SIGNAL] PROCESS_NAME...  |
| killall5 | 对当前会话以外的所有进程发送信号。 usage: killall5 [-l [SIGNAL]] [-SIGNAL | -s SIGNAL] [-o PID]...  |
| pidof | 打印具有给定名称的所有进程的PID。 usage: pidof [-s] [-o omitpid[,omitpid...]] [NAME...]  |
| pkill | 按照进程名来杀死进程。 usage: pkill [-fnovx] [-SIGNAL | -l SIGNAL] [PATTERN] [-G GID,] [-g PGRP,] [-P PPID,] [-s SID,] [-t TERM,] [-U UID,] [-u EUID,]  |
| pmap | 查看进程的内存映射情况。 usage: pmap [-xq] [pids...]  |
| ps | 显示进程信息。 usage: ps [-AadefLlnwZ] [-gG GROUP,] [-k FIELD,] [-o FIELD,] [-p PID,] [-t TTY,] [-uU USER,]  |
| pwdx | 打印进程的工作目录。 usage: pwdx PID...  |
| renice | 调整进程/组/用户级别的进程优先级。 usage: renice [-gpu] -n increment ID ...  |
| setsid | 在新的会话中运行命令。 usage: setsid [-t] command [args...]  |
| taskset | 启动一个仅在指定处理器上运行的任务，或者修改已经存在的进程的处理器偏好。 usage: taskset [-ap] [mask] [PID | cmd [args...]]  |
| timeout | 创建子进程执行命令，如果子进程超时未退出，则向子进程发送一个信号。DURATION可以是小数。可选的后缀可以是“m”（分钟）、“h”（小时）、“d”（天）或“s”（秒，默认值）。 usage: timeout [-k DURATION] [-s SIGNAL] DURATION COMMAND...  |
| top | 实时显示进程信息。 usage: top [-Hhbq] [-k FIELD,] [-o FIELD,] [-s SORT] [-n NUMBER] [-m LINES] [-d SECONDS] [-p PID,] [-u USER,]  |
| nice | 以指定的优先级运行命令。 usage: nice [-n PRIORITY] COMMAND [ARG...]  |
| nsenter | 在特定的命名空间中运行指令。 usage: nsenter [-t pid] [-F] [-i] [-m] [-n] [-p] [-u] [-U] COMMAND...  |
| ulimit/prlimit | 显示或者设置进程的资源限制。 usage: ulimit/prlimit [-P PID] [-SHRacdefilmnpqrstuv] [LIMIT]  |
| unshare | 给一个进程创建新的命名空间，部分属性不与父进程共享。 usage: unshare [-imnpuUr] COMMAND...  |
| watch | 每隔-n秒运行一次参数中的命令，显示执行结果。按q退出。 usage: watch [-teb] [-n SEC] PROG ARGS  |
| xargs | 运行命令行一次或多次，附加标准输入设备中的参数。 usage: xargs [-0prt] [-s NUM] [-n NUM] [-E STR] COMMAND...  |
获取/设置一个进程的调度策略和优先级。
usage: chrt [-Rmofrbi] {-p PID [PRIORITY] | [PRIORITY COMMAND...]}
显示/修改一个进程的IO优先级。
usage: iorenice PID [CLASS] [PRIORITY]
根据I/O对进程排序。
usage: iotop [-AaKObq] [-n NUMBER] [-d SECONDS] [-p PID,] [-u USER,]
显示/修改一个进程的IO调度优先级。
usage: ionice [-t] [-c CLASS] [-n LEVEL] [COMMAND...|-p PID]
向进程发送信号。
usage: kill [-l [SIGNAL] | -s SIGNAL | -SIGNAL] pid...
向具有给定名称的所有进程发送信号（默认：SIGTERM）。
usage: killall [-l] [-iqv] [-SIGNAL | -s SIGNAL] PROCESS_NAME...
对当前会话以外的所有进程发送信号。
usage: killall5 [-l [SIGNAL]] [-SIGNAL | -s SIGNAL] [-o PID]...
打印具有给定名称的所有进程的PID。
usage: pidof [-s] [-o omitpid[,omitpid...]] [NAME...]
按照进程名来杀死进程。
usage: pkill [-fnovx] [-SIGNAL | -l SIGNAL] [PATTERN] [-G GID,] [-g PGRP,] [-P PPID,] [-s SID,] [-t TERM,] [-U UID,] [-u EUID,]
查看进程的内存映射情况。
usage: pmap [-xq] [pids...]
显示进程信息。
usage: ps [-AadefLlnwZ] [-gG GROUP,] [-k FIELD,] [-o FIELD,] [-p PID,] [-t TTY,] [-uU USER,]
打印进程的工作目录。
usage: pwdx PID...
调整进程/组/用户级别的进程优先级。
usage: renice [-gpu] -n increment ID ...
在新的会话中运行命令。
usage: setsid [-t] command [args...]
启动一个仅在指定处理器上运行的任务，或者修改已经存在的进程的处理器偏好。
usage: taskset [-ap] [mask] [PID | cmd [args...]]
创建子进程执行命令，如果子进程超时未退出，则向子进程发送一个信号。DURATION可以是小数。可选的后缀可以是“m”（分钟）、“h”（小时）、“d”（天）或“s”（秒，默认值）。
usage: timeout [-k DURATION] [-s SIGNAL] DURATION COMMAND...
实时显示进程信息。
usage: top [-Hhbq] [-k FIELD,] [-o FIELD,] [-s SORT] [-n NUMBER] [-m LINES] [-d SECONDS] [-p PID,] [-u USER,]
以指定的优先级运行命令。
usage: nice [-n PRIORITY] COMMAND [ARG...]
在特定的命名空间中运行指令。
usage: nsenter [-t pid] [-F] [-i] [-m] [-n] [-p] [-u] [-U] COMMAND...
显示或者设置进程的资源限制。
usage: ulimit/prlimit [-P PID] [-SHRacdefilmnpqrstuv] [LIMIT]
给一个进程创建新的命名空间，部分属性不与父进程共享。
usage: unshare [-imnpuUr] COMMAND...
每隔-n秒运行一次参数中的命令，显示执行结果。按q退出。
usage: watch [-teb] [-n SEC] PROG ARGS
运行命令行一次或多次，附加标准输入设备中的参数。
usage: xargs [-0prt] [-s NUM] [-n NUM] [-E STR] COMMAND...
设备节点操作
| 命令 | 说明 |
| --- | --- |
| blkid | 打印文件系统的类型，标签和UUID等信息。 usage: blkid [-s TAG] [-UL] DEV...  |
| blockdev | 对每个命令中的块设备调用ioctl。 usage: blockdev --OPTION... BLOCKDEV...  |
| devmem | 通过 /dev/mem 读写物理地址。 usage: devmem ADDR [WIDTH [DATA]]  |
| df | 显示命令行中列出的每个文件系统的总共、已使用和空闲的磁盘空间。无参数时显示已装载的所有文件系统。 usage: df [-HPkhi] [-t type] [FILESYSTEM ...]  |
| du | 显示磁盘使用情况，文件和目录占用的空间。 usage: du [-d N] [-askxHLlmc] [file...]  |
| eject | 弹出设备，默认为 /dev/cdrom 。 usage: eject [-stT] [DEVICE]  |
| free | 显示物理内存和交换空间的总量、可用量和已用量。 usage: free [-bkmgt]  |
| freeramdisk | 释放特定ramdisk的所有内存。 usage: freeramdisk [RAM device]  |
| fsfreeze | 冻结或解冻一个文件系统。 usage: fsfreeze {-f | -u} MOUNTPOINT  |
| fstype | 打印文件系统的类型。 usage: fstype DEV...  |
| fsync | 将文件状态与存储设备同步。 usage: fsync [-d] [FILE...]  |
| i2cdetect | 检测 i2c 设备。 usage:  i2cdetect [-ary] BUS [FIRST LAST]   i2cdetect -F BUS  i2cdetect -l  |
| i2cdump | 打印所有 i2c 寄存器。 usage: i2cdump [-fy] BUS CHIP  |
| i2cget | 读取 i2c 寄存器。 usage: i2cget [-fy] BUS CHIP ADDR  |
| i2cset | 写 i2c 寄存器。 usage: i2cset [-fy] BUS CHIP ADDR VALUE... MODE  |
| losetup | 设置循环设备。 usage: losetup [-cdrs] [-o OFFSET] [-S SIZE] {-d DEVICE... | -j FILE | -af | {DEVICE FILE}}  |
| lspci | 显示 PCI 设备信息。 usage: lspci [-ekmn] [-i FILE ]  |
| lsusb | 显示 USB 设备信息。 usage: lsusb  |
| makedevs | 创建一系列特殊的文件，包括块设备文件，字符设备文件等。 usage: makedevs [-d device_table] rootdir  |
| mount | 在目录上挂载新的文件系统。如果没有参数，则显示现有的挂载。 usage: mount [-afFrsvw] [-t TYPE] [-o OPTION,] [[DEVICE] DIR]  |
| mountpoint | 检查目录或者设备是否是挂载点。 usage:  mountpoint [-qd] DIR   mountpoint [-qx] DEVICE  |
| sync | 将缓存的数据写到磁盘，。 usage: sync  |
| sysctl | 读写 /proc/sys 下的系统控制数据。 usage: sysctl [-aAeNnqw] [-p [FILE] | KEY[=VALUE]...]  |
| tunctl | 创建或删除tun/tap虚拟以太设备。 usage: tunctl [-dtT] [-u USER] NAME  |
| vconfig | 创建或删除虚拟以太设备。 usage: vconfig COMMAND [OPTIONS]  |
| umount | 取消挂载文件系统。 usage: umount [-a [-t TYPE[,TYPE...]]] [-vrfD] [DIR...]  |
打印文件系统的类型，标签和UUID等信息。
usage: blkid [-s TAG] [-UL] DEV...
对每个命令中的块设备调用ioctl。
usage: blockdev --OPTION... BLOCKDEV...
通过 /dev/mem 读写物理地址。
usage: devmem ADDR [WIDTH [DATA]]
显示命令行中列出的每个文件系统的总共、已使用和空闲的磁盘空间。无参数时显示已装载的所有文件系统。
usage: df [-HPkhi] [-t type] [FILESYSTEM ...]
显示磁盘使用情况，文件和目录占用的空间。
usage: du [-d N] [-askxHLlmc] [file...]
弹出设备，默认为 /dev/cdrom 。
usage: eject [-stT] [DEVICE]
显示物理内存和交换空间的总量、可用量和已用量。
usage: free [-bkmgt]
释放特定ramdisk的所有内存。
usage: freeramdisk [RAM device]
冻结或解冻一个文件系统。
usage: fsfreeze {-f | -u} MOUNTPOINT
打印文件系统的类型。
usage: fstype DEV...
将文件状态与存储设备同步。
usage: fsync [-d] [FILE...]
检测 i2c 设备。
usage:
i2cdetect [-ary] BUS [FIRST LAST]
i2cdetect -F BUS
i2cdetect -l
打印所有 i2c 寄存器。
usage: i2cdump [-fy] BUS CHIP
读取 i2c 寄存器。
usage: i2cget [-fy] BUS CHIP ADDR
写 i2c 寄存器。
usage: i2cset [-fy] BUS CHIP ADDR VALUE... MODE
设置循环设备。
usage: losetup [-cdrs] [-o OFFSET] [-S SIZE] {-d DEVICE... | -j FILE | -af | {DEVICE FILE}}
显示 PCI 设备信息。
usage: lspci [-ekmn] [-i FILE ]
显示 USB 设备信息。
usage: lsusb
创建一系列特殊的文件，包括块设备文件，字符设备文件等。
usage: makedevs [-d device_table] rootdir
在目录上挂载新的文件系统。如果没有参数，则显示现有的挂载。
usage: mount [-afFrsvw] [-t TYPE] [-o OPTION,] [[DEVICE] DIR]
检查目录或者设备是否是挂载点。
usage:
mountpoint [-qd] DIR
mountpoint [-qx] DEVICE
将缓存的数据写到磁盘，。
usage: sync
读写 /proc/sys 下的系统控制数据。
usage: sysctl [-aAeNnqw] [-p [FILE] | KEY[=VALUE]...]
创建或删除tun/tap虚拟以太设备。
usage: tunctl [-dtT] [-u USER] NAME
创建或删除虚拟以太设备。
usage: vconfig COMMAND [OPTIONS]
取消挂载文件系统。
usage: umount [-a [-t TYPE[,TYPE...]]] [-vrfD] [DIR...]
网络操作
| 命令 | 说明 |
| --- | --- |
| ftpget/ftpput | 与FTP服务器沟通，支持读、写、列举文件等操作。ftpget自带-g选项。ftpput自带-s选项。 usage: ftpget/ftpput [-cvgslLmMdD] [-p PORT] [-P PASSWORD] [-u USER] HOST [LOCAL] REMOTE  |
| ifconfig | 显示或配置网络接口。 usage: ifconfig [-aS] [INTERFACE [ACTION...]]  |
| nbd-client | 创建nbd客户端。 usage: nbd-client [-ns] HOST PORT DEVICE  |
| netstat | 显示网络信息。 usage: netstat [-pWrxwutneal]  |
| ping/ping6 | 检测网络连通性。ping6自带-6选项。 usage: ping/ping6 [OPTIONS] HOST  |
| sntp | SNTP客户端。 usage: sntp [-saSdDqm] [-r SHIFT] [-m ADDRESS] [-p PORT] [SERVER]  |
| telnet | 连接telnet服务器。 usage: telnet HOST [PORT]  |
| traceroute/traceroute6 | 跟踪报文到HOST的路径。traceroute6自带-6选项。 usage: traceroute [-46FUIldnvr] [-f 1ST_TTL] [-m MAXTTL] [-p PORT] [-q PROBES] [-s SRC_IP] [-t TOS] [-w WAIT_SEC] [-g GATEWAY] [-i IFACE] [-z PAUSE_MSEC] HOST [BYTES] usage: traceroute6 [-dnrv] [-m MAXTTL] [-p PORT] [-q PROBES][-s SRC_IP] [-t TOS] [-w WAIT_SEC] [-i IFACE] HOST [BYTES]  |
| wget | 从网络上下载资源。 usage: wget [OPTIONS]... [URL] [OPTIONS] = --max-redirect x -d -O filename -p data  |
与FTP服务器沟通，支持读、写、列举文件等操作。ftpget自带-g选项。ftpput自带-s选项。
usage: ftpget/ftpput [-cvgslLmMdD] [-p PORT] [-P PASSWORD] [-u USER] HOST [LOCAL] REMOTE
显示或配置网络接口。
usage: ifconfig [-aS] [INTERFACE [ACTION...]]
创建nbd客户端。
usage: nbd-client [-ns] HOST PORT DEVICE
显示网络信息。
usage: netstat [-pWrxwutneal]
检测网络连通性。ping6自带-6选项。
usage: ping/ping6 [OPTIONS] HOST
SNTP客户端。
usage: sntp [-saSdDqm] [-r SHIFT] [-m ADDRESS] [-p PORT] [SERVER]
连接telnet服务器。
usage: telnet HOST [PORT]
跟踪报文到HOST的路径。traceroute6自带-6选项。
usage: traceroute [-46FUIldnvr] [-f 1ST_TTL] [-m MAXTTL] [-p PORT] [-q PROBES] [-s SRC_IP] [-t TOS] [-w WAIT_SEC] [-g GATEWAY] [-i IFACE] [-z PAUSE_MSEC] HOST [BYTES]
usage: traceroute6 [-dnrv] [-m MAXTTL] [-p PORT] [-q PROBES][-s SRC_IP] [-t TOS] [-w WAIT_SEC] [-i IFACE] HOST [BYTES]
从网络上下载资源。
usage: wget [OPTIONS]... [URL]
[OPTIONS] = --max-redirect x -d -O filename -p data
文件操作
| 命令 | 说明 |
| --- | --- |
| awk | awk是一个处理文本的工具，可对文档内容进行筛选、分析。 usage: awk [-F sepstring] [-v assignment]... program [argument...]  or: awk [-F sepstring] -f progfile [-f progfile]... [-v assignment]... [argument...]  |
| base64 | 通过base64算法进行加密/解密。 usage: base64 [-di] [-w COLUMNS] [FILE...]  |
| basename | 返回删除后缀的路径名的非目录部分。 usage: basename [-a] [-s SUFFIX] NAME... | NAME [SUFFIX]  |
| bunzip2 | 解压bz格式的文件。 usage: bunzip2 [-cftkv] [FILE...]  |
| bzcat | 解压列举的文件到标准输出。 usage: bzcat [FILE...]  |
| cat | 复制（连接）文件到标准输出设备。如果未列出任何文件，则从标准输入设备复制。“-”代表标准输入设备。 usage: cat [-etuv] [FILE...]  |
| chattr | 修改Linux ext2文件系统的文件属性。 usage: chattr [-R] [-+=AacDdijsStTu] [-v version] [File...]  |
| chcon | 修改文件的SELinux安全上下文。 usage: chcon [-hRv] CONTEXT FILE...  |
| chgrp/chown | 修改文件的组。 usage: chgrp/chown [-RHLP] [-fvh] group file...  |
| chmod | 更改列出的文件的模式（使用-R递归）。 usage: chmod [-R] MODE FILE...  |
| cksum | 对于每个文件，输出crc32的校验和、长度和文件名。如果未列出任何文件，则从标准输入设备复制。“-”代表标准输入设备。 usage: cksum [-IPLN] [file...]  |
| cmp | 比较文件的内容（如果只给出一个，则与标准输入设备进行比较），可选在开始时跳过字节。 usage: cmp [-l] [-s] FILE1 [FILE2 [SKIP1 [SKIP2]]]  |
| comm | 读取FILE1和FILE2（这两个文件应该是有序的），并生成三个文本列作为输出：仅在FILE1中的行；仅在FILE2中的行；在两个文件中都有的行。“-”代表标准输入设备。 usage: comm [-123] FILE1 FILE2  |
| count | 将标准输入设备复制到标准输出设备，将简单的进度指示器显示到标准错误输出stderr。 usage: count  |
| cp | 将文件从SOURCE复制到DEST。如果有多个源，DEST必须是一个目录。 usage: cp [-adfHiLlnPpRrsTv] [--preserve=motcxa] [-t TARGET] SOURCE... [DEST]  |
| cpio | 从“newc”格式的cpio档案中中读写文件。 usage: cpio -{o|t|i|p DEST} [-v] [--verbose] [-F FILE] [--no-preserve-owner]  [ignored: -mdu -H newc]  |
| crc32 | 输出每个文件的crc32校验和。 usage: crc32 [file...]  |
| cut | 将每个FILE中的行的选定部分打印到标准输出。每个选择列表以逗号分隔，可以是数字（从1开始计数）或破折号分隔的范围(其中X-表示X到行尾，-X表示从开始到X)。 usage: cut [-Ds] [-bcfF LIST] [-dO DELIM] [FILE...]  |
| dd | 用于转换和复制文件的命令，可以用于创建磁盘镜像、备份数据、转换字符编码等任务。 usage:  dd [if=FILE] [of=FILE] [ibs=N] [obs=N] [iflag=FLAGS] [oflag=FLAGS]  [bs=N] [count=N] [seek=N] [skip=N]  [conv=notrunc|noerror|sync|fsync] [status=noxfer|none]  |
| diff | 比较文件/文件夹，输出差异。 usage: diff [-abBdiNqrTstw] [-L LABEL] [-S FILE] [-U LINES] FILE1 FILE2  |
| dirname | 显示路径的目录部分。 usage: dirname PATH...  |
| dos2unix | 将换行符格式从dos“\r\n”转换为unix“\n”。如果没有列出文件，从标准输入设备获取输入。“-”代表标准输入设备。 usage: dos2unix [FILE...]  |
| echo | 将每个参数写入标准输出设备，每个参数之间有一个空格，后跟一个换行符。 usage: echo [-neE] [args...]  |
| grep/egrep/fgrep | 显示匹配正则表达式的行。如果没有-e，则第一个参数为要匹配的正则表达式。没有文件（或“-”文件名）读取标准输入设备。如果匹配，则返回0；如果找不到匹配，则返回1；如果命令错误，则返回2。 egrep自带-E选项，fgrep自带-F选项。E和F选项不能同时选。 usage: grep/egrep/fgrep [-EFrivwcloqsHbhn] [-ABC NUM] [-m MAX] [-e REGEX]... [-MS PATTERN]... [-f REGFILE] [FILE]...  |
| gzip | 压缩文件。 usage: gzip [-19cdfk] [FILE...]  |
| expand | 根据输入参数将制表符展开为空格。 usage: expand [-t TABLIST] [FILE...]  |
| fallocate | 让文件系统给文件预留空间。 usage: fallocate [-l size] [-o offset] file  |
| file | 检查给定的文件并描述其内容类型。 usage: file [-bhLs] [file...]  |
| find | 在目录中搜索匹配的文件。 usage: find [-HL] [DIR...] [<options>]  |
| flock | 管理文件锁(advisory lock)。 usage: flock [-sxun] fd  |
| fmt | 将输入重新格式化为给定行长的换行，保留现有的缩进级别，写入标准输出设备。 usage: fmt [-w WIDTH] [FILE...]  |
| gunzip | 解压文件。如果没有文件，则从标准输入设备解压到标准输出设备。成功后，输入文件将被删除并替换为新的没有.gz后缀的文件。 usage: gunzip [-cfk] [FILE...]  |
| head | 将文件中的第一行复制到标准输出设备中。如果未列出任何文件，从标准输入设备拷贝. “-”代表标准输入设备 usage: head [-n number] [file...]  |
| hexedit | 十六进制文件编辑器，所有修改立刻写入磁盘。 usage: hexedit FILENAME  |
| iconv | 转换文件编码。 usage: iconv [-f FROM] [-t TO] [FILE...]  |
| inotifyd | 在文件系统事件出现的时候，运行特定的程序。 usage: inotifyd PROG FILE[:MASK] ...  |
| install | 复制文件并设置文件属性。 usage: install [-dDpsv] [-o USER] [-g GROUP] [-m MODE] [-t TARGET] [SOURCE...] [DEST]  |
| link | 创建文件的硬链接。 usage: link FILE NEWLINK  |
| ln | 在 FROM 和 TO 之间创建软/硬链接。 usage: ln [-sfnv] [-t DIR] [FROM...] TO  |
| ls | 查看当前目录有哪些文件/文件夹。 usage: ls [-ACFHLRSZacdfhiklmnpqrstux1] [--color[=auto]] [directory...]  |
| lsattr | 列出Linux文件系统中的文件属性。标志字母在chattr帮助中定义。 usage: lsattr [-Radlv] [Files...]  |
| lsof | 列出属于所有活跃进程的所有打开的文件，或使用列出的FILE的进程。 usage: lsof [-lt] [-p PID1,PID2,...] [FILE...]  |
| md5sum | 计算每个输入文件的哈希，如果没有，则从标准输入设备读取。每个输入文件输出一行哈希后跟文件名。 usage: md5sum [-bcs] [FILE]...  |
| mkdir | 创建一个或多个目录。 usage: mkdir [-vp] [-m mode] [dirname...]  |
| mkfifo | 创建FIFO文件（命名管道）。 usage: mkfifo [NAME...]  |
| mkswap | 创建Linux的交换空间。 usage: mkswap [-L LABEL] DEVICE  |
| mktemp | 安全地创建一个新文件“DIR/TEMPLATE”并打印其名称。 usage: mktemp [-dqu] [-p DIR] [TEMPLATE]  |
| mknod | 创建一个特殊的文件(b为块设备，c或u为字符设备，p为命名管道)。 usage: mknod [-m MODE] NAME TYPE [MAJOR MINOR]  |
| more | 查看文件，一次一页。 usage: more [FILE...]  |
| mv | 移动或重命名文件。 usage: mv [-finTv] [-t TARGET] SOURCE... [DEST]  |
| nl | 给输入的文件添加行号。 usage: nl [-E] [-l #] [-b MODE] [-n STYLE] [-s SEPARATOR] [-v #] [-w WIDTH] [FILE...]  |
| od | 以八进制/十六进制格式转储数据。 usage: od [-bcdosxv] [-j #] [-N #] [-w #] [-A doxn] [-t acdfoux[#]]  |
| paste | 从每个输入文件中合并相应的行。 usage: paste [-s] [-d DELIMITERS] [FILE...]  |
| patch | 将统一的diff应用于一个或多个文件。 usage: patch [-d DIR] [-i file] [-p depth] [-Rlsu] [--dry-run]  |
| pgrep | 查找进程。PATTERN是扩展正则表达式，用于命令名称的检测。 usage: pgrep [-clfnovx] [-d DELIM] [-L SIGNAL] [PATTERN] [-G GID,] [-g PGRP,] [-P PPID,] [-s SID,] [-t TERM,] [-U UID,] [-u EUID,]  |
| printf | 使用C语言的printf语法，根据Format格式化并打印参数。 usage: printf FORMAT [ARGUMENT...]  |
| pwd | 打印工作（当前）目录。 usage: pwd [-L | -P]  |
| readahead | 将文件预加载到磁盘缓存中。 usage: readahead FILE...  |
| readlink | 如果没有选项，则显示symlink指向什么，如果不是symlink则返回错误。 usage: readlink FILE...  |
| realpath | 显示规范绝对路径名。 usage: realpath FILE...  |
| rev | 逆向输出每一行。 usage: rev [FILE...]  |
| rm | 删除文件。 usage: rm [-fiRrv] FILE...  |
| rmdir | 删除一个或多个目录。 usage: rmdir [-p] [dirname...]  |
| sed | 流编辑器。将编辑脚本应用于输入行。 usage: sed [-inrzE] [-e SCRIPT]... | SCRIPT [-f SCRIPT_FILE]... [FILE...]  |
| seq | 从头到尾按递增计数。省略参数默认值为1。使用两个参数作为第一个和最后一个。参数可以是负数或浮点数。 usage: seq [-w | -f fmt_str] [-s sep_str] [first] [increment] last  |
| setfattr | 写入 POSIX 扩展属性。 usage: setfattr [-h] [-x | -n NAME] [-v VALUE] FILE...  |
| sha1sum/sha256sum | 计算sha系列哈希值。 usage: sha?sum [-bcs] [FILE]...  |
| shred | 安全的删除文件（用随机数据覆盖文件内容）。 usage: shred [-fuz] [-n COUNT] [-s SIZE] FILE...  |
| sort | 对从输入文件（或标准输入设备）到标准输出设备的所有文本行进行排序。 usage: sort [-Mbcdfginrsuz] [FILE...] [-k#[,#[x]] [-t X]] [-o FILE]  |
| split | 将输入（或标准输入设备）数据复制到一系列输出（或“x”）文件，使用按字母顺序递增的后缀（aa,ab,ac...az,ba,bb...）。 usage: split [-a SUFFIX_LEN] [-b BYTES] [-l LINES] [INPUT [OUTPUT]]  |
| stat | 显示文件或文件系统的状态。 usage: stat [-tfL] [-c FORMAT] FILE...  |
| strings | 在二进制文件中显示可打印字符串。 usage: strings [-fo] [-t oxd] [-n LEN] [FILE...]  |
| tac | 以相反的顺序输出行。 usage: tac [FILE...]  |
| tail | 将文件中的最后几行复制到标准输出设备中。“-”代表标准输入设备。 usage: tail [-n|c NUMBER] [-f] [FILE...]  |
| tar | 在.tar文件中创建、解压缩或列出文件。 usage: tar [-cxt] [-fvohmjkOS] [-XTCf NAME] [FILES]  |
| tee | 将标准输入设备复制到每个列出的文件，也复制到标准输出设备。“-”代表标准输出设备。 usage: tee [-ai] [file...]  |
| touch | 更新每个FILE的访问和修改时间为当前时间。 usage: touch [-amch] [-d DATE] [-t TIME] [-r FILE] FILE...  |
| truncate | 设置文件的长度，必要时稀疏扩展。 usage: truncate [-c] -s SIZE file...  |
| uniq | 报告或过滤文件中的重复行。 usage: uniq [-cduiz] [-w maxchars] [-f fields] [-s char] [input_file [output_file]]  |
| unix2dos | 将换行符格式从unix“\n”转换为dos“\r\n”。如果没有列出文件，从标准输入设备获取输入。“-”代表标准输入设备。 usage: unix2dos [FILE...]  |
| unlink | 删除文件。 usage: unlink FILE  |
| uudecode | 从标准输入设备（或INFILE）解码文件。 usage: uudecode [-o OUTFILE] [INFILE]  |
| uuencode | 标准输入设备（或文件）进行编码，输出到标准输出设备，在输出中包含encode-filename。 usage: uuencode [-m] [file] encode-filename  |
| wc | 统计输入中的行数、单词和字符。 usage: wc -lwcm [FILE...]  |
| which | 在$PATH中搜索与文件名匹配的可执行文件。 usage: which [-a] filename ...  |
| xxd | 以16进制的形式显示文件内容。若没有列出任何文件，从标准输入设备复制。 usage: xxd [-c n] [-g n] [-i] [-l n] [-o n] [-p] [-r] [-s n] [file]  |
| zcat | 将文件解压缩到标准输出设备。比如“gzip -dc”。  usage: zcat [FILE...]  |
awk是一个处理文本的工具，可对文档内容进行筛选、分析。
usage: awk [-F sepstring] [-v assignment]... program [argument...]
or: awk [-F sepstring] -f progfile [-f progfile]... [-v assignment]... [argument...]
通过base64算法进行加密/解密。
usage: base64 [-di] [-w COLUMNS] [FILE...]
返回删除后缀的路径名的非目录部分。
usage: basename [-a] [-s SUFFIX] NAME... | NAME [SUFFIX]
解压bz格式的文件。
usage: bunzip2 [-cftkv] [FILE...]
解压列举的文件到标准输出。
usage: bzcat [FILE...]
复制（连接）文件到标准输出设备。如果未列出任何文件，则从标准输入设备复制。“-”代表标准输入设备。
usage: cat [-etuv] [FILE...]
修改Linux ext2文件系统的文件属性。
usage: chattr [-R] [-+=AacDdijsStTu] [-v version] [File...]
修改文件的SELinux安全上下文。
usage: chcon [-hRv] CONTEXT FILE...
修改文件的组。
usage: chgrp/chown [-RHLP] [-fvh] group file...
更改列出的文件的模式（使用-R递归）。
usage: chmod [-R] MODE FILE...
对于每个文件，输出crc32的校验和、长度和文件名。如果未列出任何文件，则从标准输入设备复制。“-”代表标准输入设备。
usage: cksum [-IPLN] [file...]
比较文件的内容（如果只给出一个，则与标准输入设备进行比较），可选在开始时跳过字节。
usage: cmp [-l] [-s] FILE1 [FILE2 [SKIP1 [SKIP2]]]
读取FILE1和FILE2（这两个文件应该是有序的），并生成三个文本列作为输出：仅在FILE1中的行；仅在FILE2中的行；在两个文件中都有的行。“-”代表标准输入设备。
usage: comm [-123] FILE1 FILE2
将标准输入设备复制到标准输出设备，将简单的进度指示器显示到标准错误输出stderr。
usage: count
将文件从SOURCE复制到DEST。如果有多个源，DEST必须是一个目录。
usage: cp [-adfHiLlnPpRrsTv] [--preserve=motcxa] [-t TARGET] SOURCE... [DEST]
从“newc”格式的cpio档案中中读写文件。
usage: cpio -{o|t|i|p DEST} [-v] [--verbose] [-F FILE] [--no-preserve-owner]
[ignored: -mdu -H newc]
输出每个文件的crc32校验和。
usage: crc32 [file...]
将每个FILE中的行的选定部分打印到标准输出。每个选择列表以逗号分隔，可以是数字（从1开始计数）或破折号分隔的范围(其中X-表示X到行尾，-X表示从开始到X)。
usage: cut [-Ds] [-bcfF LIST] [-dO DELIM] [FILE...]
用于转换和复制文件的命令，可以用于创建磁盘镜像、备份数据、转换字符编码等任务。
usage:
dd [if=FILE] [of=FILE] [ibs=N] [obs=N] [iflag=FLAGS] [oflag=FLAGS]
[bs=N] [count=N] [seek=N] [skip=N]
[conv=notrunc|noerror|sync|fsync] [status=noxfer|none]
比较文件/文件夹，输出差异。
usage: diff [-abBdiNqrTstw] [-L LABEL] [-S FILE] [-U LINES] FILE1 FILE2
显示路径的目录部分。
usage: dirname PATH...
将换行符格式从dos“\r\n”转换为unix“\n”。如果没有列出文件，从标准输入设备获取输入。“-”代表标准输入设备。
usage: dos2unix [FILE...]
将每个参数写入标准输出设备，每个参数之间有一个空格，后跟一个换行符。
usage: echo [-neE] [args...]
显示匹配正则表达式的行。如果没有-e，则第一个参数为要匹配的正则表达式。没有文件（或“-”文件名）读取标准输入设备。如果匹配，则返回0；如果找不到匹配，则返回1；如果命令错误，则返回2。
egrep自带-E选项，fgrep自带-F选项。E和F选项不能同时选。
usage: grep/egrep/fgrep [-EFrivwcloqsHbhn] [-ABC NUM] [-m MAX] [-e REGEX]... [-MS PATTERN]... [-f REGFILE] [FILE]...
压缩文件。
usage: gzip [-19cdfk] [FILE...]
根据输入参数将制表符展开为空格。
usage: expand [-t TABLIST] [FILE...]
让文件系统给文件预留空间。
usage: fallocate [-l size] [-o offset] file
检查给定的文件并描述其内容类型。
usage: file [-bhLs] [file...]
在目录中搜索匹配的文件。
usage: find [-HL] [DIR...] [<options>]
管理文件锁(advisory lock)。
usage: flock [-sxun] fd
将输入重新格式化为给定行长的换行，保留现有的缩进级别，写入标准输出设备。
usage: fmt [-w WIDTH] [FILE...]
解压文件。如果没有文件，则从标准输入设备解压到标准输出设备。成功后，输入文件将被删除并替换为新的没有.gz后缀的文件。
usage: gunzip [-cfk] [FILE...]
将文件中的第一行复制到标准输出设备中。如果未列出任何文件，从标准输入设备拷贝. “-”代表标准输入设备
usage: head [-n number] [file...]
十六进制文件编辑器，所有修改立刻写入磁盘。
usage: hexedit FILENAME
转换文件编码。
usage: iconv [-f FROM] [-t TO] [FILE...]
在文件系统事件出现的时候，运行特定的程序。
usage: inotifyd PROG FILE[:MASK] ...
复制文件并设置文件属性。
usage: install [-dDpsv] [-o USER] [-g GROUP] [-m MODE] [-t TARGET] [SOURCE...] [DEST]
创建文件的硬链接。
usage: link FILE NEWLINK
在 FROM 和 TO 之间创建软/硬链接。
usage: ln [-sfnv] [-t DIR] [FROM...] TO
查看当前目录有哪些文件/文件夹。
usage: ls [-ACFHLRSZacdfhiklmnpqrstux1] [--color[=auto]] [directory...]
列出Linux文件系统中的文件属性。标志字母在chattr帮助中定义。
usage: lsattr [-Radlv] [Files...]
列出属于所有活跃进程的所有打开的文件，或使用列出的FILE的进程。
usage: lsof [-lt] [-p PID1,PID2,...] [FILE...]
计算每个输入文件的哈希，如果没有，则从标准输入设备读取。每个输入文件输出一行哈希后跟文件名。
usage: md5sum [-bcs] [FILE]...
创建一个或多个目录。
usage: mkdir [-vp] [-m mode] [dirname...]
创建FIFO文件（命名管道）。
usage: mkfifo [NAME...]
创建Linux的交换空间。
usage: mkswap [-L LABEL] DEVICE
安全地创建一个新文件“DIR/TEMPLATE”并打印其名称。
usage: mktemp [-dqu] [-p DIR] [TEMPLATE]
创建一个特殊的文件(b为块设备，c或u为字符设备，p为命名管道)。
usage: mknod [-m MODE] NAME TYPE [MAJOR MINOR]
查看文件，一次一页。
usage: more [FILE...]
移动或重命名文件。
usage: mv [-finTv] [-t TARGET] SOURCE... [DEST]
给输入的文件添加行号。
usage: nl [-E] [-l #] [-b MODE] [-n STYLE] [-s SEPARATOR] [-v #] [-w WIDTH] [FILE...]
以八进制/十六进制格式转储数据。
usage: od [-bcdosxv] [-j #] [-N #] [-w #] [-A doxn] [-t acdfoux[#]]
从每个输入文件中合并相应的行。
usage: paste [-s] [-d DELIMITERS] [FILE...]
将统一的diff应用于一个或多个文件。
usage: patch [-d DIR] [-i file] [-p depth] [-Rlsu] [--dry-run]
查找进程。PATTERN是扩展正则表达式，用于命令名称的检测。
usage: pgrep [-clfnovx] [-d DELIM] [-L SIGNAL] [PATTERN] [-G GID,] [-g PGRP,] [-P PPID,] [-s SID,] [-t TERM,] [-U UID,] [-u EUID,]
使用C语言的printf语法，根据Format格式化并打印参数。
usage: printf FORMAT [ARGUMENT...]
打印工作（当前）目录。
usage: pwd [-L | -P]
将文件预加载到磁盘缓存中。
usage: readahead FILE...
如果没有选项，则显示symlink指向什么，如果不是symlink则返回错误。
usage: readlink FILE...
显示规范绝对路径名。
usage: realpath FILE...
逆向输出每一行。
usage: rev [FILE...]
删除文件。
usage: rm [-fiRrv] FILE...
删除一个或多个目录。
usage: rmdir [-p] [dirname...]
流编辑器。将编辑脚本应用于输入行。
usage: sed [-inrzE] [-e SCRIPT]... | SCRIPT [-f SCRIPT_FILE]... [FILE...]
从头到尾按递增计数。省略参数默认值为1。使用两个参数作为第一个和最后一个。参数可以是负数或浮点数。
usage: seq [-w | -f fmt_str] [-s sep_str] [first] [increment] last
写入 POSIX 扩展属性。
usage: setfattr [-h] [-x | -n NAME] [-v VALUE] FILE...
计算sha系列哈希值。
usage: sha?sum [-bcs] [FILE]...
安全的删除文件（用随机数据覆盖文件内容）。
usage: shred [-fuz] [-n COUNT] [-s SIZE] FILE...
对从输入文件（或标准输入设备）到标准输出设备的所有文本行进行排序。
usage: sort [-Mbcdfginrsuz] [FILE...] [-k#[,#[x]] [-t X]] [-o FILE]
将输入（或标准输入设备）数据复制到一系列输出（或“x”）文件，使用按字母顺序递增的后缀（aa,ab,ac...az,ba,bb...）。
usage: split [-a SUFFIX_LEN] [-b BYTES] [-l LINES] [INPUT [OUTPUT]]
显示文件或文件系统的状态。
usage: stat [-tfL] [-c FORMAT] FILE...
在二进制文件中显示可打印字符串。
usage: strings [-fo] [-t oxd] [-n LEN] [FILE...]
以相反的顺序输出行。
usage: tac [FILE...]
将文件中的最后几行复制到标准输出设备中。“-”代表标准输入设备。
usage: tail [-n|c NUMBER] [-f] [FILE...]
在.tar文件中创建、解压缩或列出文件。
usage: tar [-cxt] [-fvohmjkOS] [-XTCf NAME] [FILES]
将标准输入设备复制到每个列出的文件，也复制到标准输出设备。“-”代表标准输出设备。
usage: tee [-ai] [file...]
更新每个FILE的访问和修改时间为当前时间。
usage: touch [-amch] [-d DATE] [-t TIME] [-r FILE] FILE...
设置文件的长度，必要时稀疏扩展。
usage: truncate [-c] -s SIZE file...
报告或过滤文件中的重复行。
usage: uniq [-cduiz] [-w maxchars] [-f fields] [-s char] [input_file [output_file]]
将换行符格式从unix“\n”转换为dos“\r\n”。如果没有列出文件，从标准输入设备获取输入。“-”代表标准输入设备。
usage: unix2dos [FILE...]
删除文件。
usage: unlink FILE
从标准输入设备（或INFILE）解码文件。
usage: uudecode [-o OUTFILE] [INFILE]
标准输入设备（或文件）进行编码，输出到标准输出设备，在输出中包含encode-filename。
usage: uuencode [-m] [file] encode-filename
统计输入中的行数、单词和字符。
usage: wc -lwcm [FILE...]
在$PATH中搜索与文件名匹配的可执行文件。
usage: which [-a] filename ...
以16进制的形式显示文件内容。若没有列出任何文件，从标准输入设备复制。
usage: xxd [-c n] [-g n] [-i] [-l n] [-o n] [-p] [-r] [-s n] [file]
将文件解压缩到标准输出设备。比如“gzip -dc”。
usage: zcat [FILE...]
常见问题
报错："Unknown command xxx"
在命令行中输入"xxx" 或 "toybox xxx" 或 "help xxx"时，如果遇到报错 "Unknown command xxx"，表示toybox不支持xxx命令。
如果该命令在本文的描述中，则证明产品未编译该命令。如需帮助请通过“华为开发者联盟官网”->“支持”，在线提单方式获取支持。
报错："Operation not permitted"/"Permission denied"
toybox存在大量操作文件和进程的命令，如果调用者缺少对被操作对象的权限，就会报错。
1.  SELinux拦截。可以在内核日志中搜索"avc: denied"关键字。 例子： 如果出现类似 avc: denied { xxx } for comm="ls" xxxxxx 的日志，表示命令ls触发了SELinux拦截。
如遇权限缺失问题，又需要执行该命令，可通过“华为开发者联盟官网”->“支持”，在线提单方式获取支持。
其他Linux标准报错
toybox大部分命令为对内核的调用，出错时会通过perror打印Linux内核错误码对应的文本。
常见的错误有："File exists"/"Not a directory"/"Read-only file system"等。
这些为Linux标准错误，可以参考Linux相关资料查询报错原因。请根据具体报错，检查命令的参数或者命令的格式是否出现错误。
例子：
试图在只读文件系统中进行创建文件的操作，会有报错 "Read-only file system"。
cat可以打印文件内容，如果试图cat一个目录，会有报错 "Is a directory"。
试图用ls命令查看一个不存在的文件或目录，会有报错 "No such file or directory"。
命令与toybox描述不符合
如果发现在shell下输入"命令 参数"的表现与"toybox 命令 参数"不一致，可能有两种原因导致。
对于time/test/pwd/realpath/ulimit/kill等命令，shell会直接使用自己的实现。
此时如果想要调用toybox命令，请使用"toybox [command] [arguments...]"的格式。
此时如果想要调用toybox命令，请使用"toybox [command] [arguments...]"的格式。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/mediatool-V14
爬取时间: 2025-04-28 19:27:57
来源: Huawei Developer
mediatool是一个轻量级的命令行工具集合，开发者可通过此工具操作媒体库资源。媒体库中的图片视频资源会在系统图库中显示。
前置条件
命令行说明
mediatool recv
```shell
mediatool recv <resource-uri> <dest-path>
```
该命令能够将<resource-uri>指定uri对应的媒体库资源的源文件内容导出到<dest-path>指定的设备路径下。
<dest-path>可以指定为待创建文件路径或者文件夹路径，若为文件夹路径则会导出到该文件夹下，文件保留媒体库中的名字。
当<dest-path>指定待创建文件路径时，不能是已经存在文件的路径。
文件导出成功后会打印导出文件的路径。
媒体库资源uri可以通过mediatool query获取。
将<resource-uri>指定为all则能够将所有媒体库资源的源文件导出。当<resource-uri>为all时，<dest-path>必须为文件夹路径。
<dest-path>只支持/data/local/tmp下的路径。
使用示例：
```shell
> mediatool recv file://media/Photo/3 /data/local/tmp/out.jpg
Table Name: Photos
/data/local/tmp/out.jpg
```
mediatool delete
```shell
mediatool delete <resource-uri>
```
该命令能够彻底删除<resource-uri>指定uri的媒体库资源。被删除的资源无法恢复，请谨慎执行。
媒体库资源uri可以通过或者mediatool query获取。
将<resource-uri>指定为all则指定删除所有媒体库资源，并重置媒体库的所有数据。
使用示例：
```shell
> mediatool delete file://media/Photo/3
[SUCCESS] delete success.
> mediatool delete all # delete all 执行成功不会有任何打印
```
mediatool query
```shell
mediatool query <display-name> [-p] [-u]
```
该命令能够查询出所有名字为<display-name>的媒体库资源，返回资源源文件真实路径或媒体资源uri。默认返回源文件真实路径。
| 选项 | 说明 |
| --- | --- |
| -p | 返回媒体资源源文件在设备中的真实路径。（默认） |
| -u | 返回媒体资源uri。不能与-p选项同时使用。 |
使用示例：
```shell
# 所查询媒体资源存在
> mediatool query MyImage.jpg
find 1 result:
path
/storage/cloud/100/files/Photo/2/IMG_1721381297_001.jpg
# 所查询媒体资源不存在
> mediatool query non_exist.jpg
find 0 result
# 查询的名字格式不正确
> mediatool query IMG_001
The displayName format is not correct!
# 查询媒体资源源文件路径
> mediatool query MyImage.jpg -p
find 1 result:
path
/storage/cloud/100/files/Photo/2/IMG_1721381297_001.jpg
# 查询媒体资源uri
> mediatool query MyImage.jpg -u
find 1 result:
uri
"file://media/Photo/2/IMG_1721381297_001/MyImage.jpg"
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicedebug-tool-V14
爬取时间: 2025-04-28 19:28:11
来源: Huawei Developer
devicedebug工具向开发者提供对调试应用发送信号的能力，目前仅支持向AMS管理的debug类型的应用进程的pid发送signal信号，达到终止对应pid进程的能力。
在使用本工具前，开发者需要先获取hdc工具，执行hdc shell。
表1devicedebug工具命令列表
| 命令 | 描述 |
| --- | --- |
| help/-h | 帮助命令，显示devicedebug支持的命令信息。 |
| kill | 终止进程命令，用来终止对应pid进程。 |
帮助命令
表2help命令列表
| 命令 | 描述 |
| --- | --- |
| devicedebug help | 显示devicedebug支持的命令信息。 |
示例：
终止进程命令
用于向debug类型的应用进程发送signal（1-64）信号，应用进程接受到信号后终止对应pid进程。
表3kill命令列表
| 命令 | 描述 |
| --- | --- |
| help/-h | 帮助信息。 |
| -<signal> <pid> | 必选字段，signal（1-64）为终止信号，终止pid对应的debug类型的应用进程。 |
返回值：
当pid对应的进程为非应用进程时，返回"devicedebug: kill: {pid}: No such app process"；当pid对应的进程为非debug类型的应用进程时，返回"devicedebug: kill: process: {pid} is not debuggable app"。
示例：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/rawheap-translator-V14
爬取时间: 2025-04-28 19:28:25
来源: Huawei Developer
使用场景
为方便开发者定位问题，当前应用在ArkTS内存OOM时会自动进行Heapdump，虚拟机会扫描并保存当前堆上的所有对象信息，生成rawheap文件。该文件以二进制形式保存，开发者可从SDK中toolchains路径下获取rawheap_translator工具进行解析，转换成heapsnapshot文件，可通过DevEco Studio打开查看。
使用指导
工具获取
当前工具适配了OHOS、Windows、Linux、MacOS平台，获取方法如下：
-  设备内获取：/bin/rawheap_translator，可在oh设备使用；
-  SDK中获取：不同平台工具在SDK路径下toolchains目录获取，可在对应平台下使用。
环境配置
-  Windows环境变量设置方法 在此电脑 > 属性 > 高级系统设置 > 高级 > 环境变量 > Path > 编辑 中，将rawheap_translator.exe所在路径添加到 Path，环境变量配置完成后，请重启电脑，即可在cmd窗口执行rawheap_translator命令。
-  MacOS环境变量设置方法 1）打开终端工具，执行以下命令，根据输出结果分别执行不同命令。 echo $SHELL a. 如果输出结果为/bin/bash，则执行以下命令，打开.bash_profile文件。 vi ~/.bash_profile b. 如果输出结果为/bin/zsh，则执行以下命令，打开.zshrc文件。 vi ~/.zshrc 2）单击字母“i”，进入Insert模式。 3）输入以下内容，添加PATH信息。 export PATH=$PATH:/path/to/your/rawheap_translator 4）编辑完成后，单击Esc键，退出编辑模式，然后输入“:wq”，单击Enter键保存。 5）执行以下命令，使配置的环境变量生效。 a. 如果步骤a时打开的是.bash_profile文件，请执行如下命令： source ~/.bash_profile b. 如果步骤a时打开的是.zshrc文件，请执行如下命令： source ~/.zshrc 6）环境变量配置完成后，重启电脑。
使用方法
解析命令
参数列表
| 选项 | 描述 | 举例 |
| --- | --- | --- |
| <rawheap_file> | 必选参数，OOM时生成的rawheap文件路径： /data/log/reliability/resource_leak/memory_leak  | 解析指定目录(如：D:\temp\rawheap)下的rawheap文件： rawheap_translator D:\temp\rawheap\xxx.rawheap 解析当前目录下的rawheap文件： rawheap_translator xxx.rawheap  |
| [heapsnapshot_file] | 可选参数，指定生成的文件名称和路径，后缀名必须是heapsnapshot； 不指定则默认为当前路径，生成的文件名如：hprof_2024-11-19-21-13-20.heapsnapshot  | 解析当前目录下的rawheap文件，并在指定路径(如：D:\temp)下生成的heapsnapshot: rawheap_translator xxx.rawheap D:\temp\xxx.heapsnapshot 解析当前目录下的rawheap文件，并在当前路径下生成的heapsnapshot: rawheap_translator xxx.rawheap xxx.heapsnapshot  |
必选参数，OOM时生成的rawheap文件路径：
/data/log/reliability/resource_leak/memory_leak
解析指定目录(如：D:\temp\rawheap)下的rawheap文件：
rawheap_translator D:\temp\rawheap\xxx.rawheap
解析当前目录下的rawheap文件：
rawheap_translator xxx.rawheap
可选参数，指定生成的文件名称和路径，后缀名必须是heapsnapshot；
不指定则默认为当前路径，生成的文件名如：hprof_2024-11-19-21-13-20.heapsnapshot
解析当前目录下的rawheap文件，并在指定路径(如：D:\temp)下生成的heapsnapshot:
rawheap_translator xxx.rawheap D:\temp\xxx.heapsnapshot
解析当前目录下的rawheap文件，并在当前路径下生成的heapsnapshot:
rawheap_translator xxx.rawheap xxx.heapsnapshot
[heapsnapshot_file] 需要指向具有读写权限的路径，如果未指定参数，需要保证当前执行cmd命令时所在目录具有读写权限。
以windows为例:
D:> ...\rawheap_translator.exe ...\example.rawheap 命令中，需要保证“D:\”路径具有读写权限。
解析命令示例
OHOS设备中解析示例
通过hdc shell命令拉起解析工具，设备内工具路径：/bin/rawheap_translator，推荐指定生成heapsnapshot文件路径在/data/local/tmp下，其他路径可能面临没有写权限问题。
Windows系统中解析示例
打开cmd并进入rawheap文件路径，调用解析工具命令，指定在当前路径下生成heapsnapshot文件。
Linux系统中解析示例
进入rawheap文件路径，调用解析工具命令，指定在当前路径下生成heapsnapshot文件。
MacOS系统中解析示例
打开终端并进入rawheap文件路径，调用解析工具命令，指定在当前路径下生成heapsnapshot文件。
文件参考规格
rawheap文件大小、生成耗时，与当前ArkTS堆内存大小、存活对象数量强正相关（如下表所示），因此OOM场景下当ArkTS堆内存占用较大、存活对象数量较多时，生成的rawheap文件耗时会较长，文件也会较大。开发者可订阅资源泄漏事件，自定义事件处理逻辑。
为了方便开发者判断上报rawheap文件到服务器所带来的性能和流量开销，下表还给出了当前rawheap文件被压缩后的文件大小，一般压缩比是10:1，不同压缩工具略有差异，仅供开发者参考。
| ArkTS堆内存（MB） | 存活对象数量（个） | 生成耗时（s） | rawheap文件（MB） | 压缩后文件（MB） |
| --- | --- | --- | --- | --- |
| 11.00 | 99812 | 0.08 | 7.00 | 0.77 |
| 25.30 | 250059 | 0.17 | 19.00 | 1.90 |
| 50.40 | 496134 | 0.29 | 38.00 | 3.55 |
| 72.00 | 759037 | 0.49 | 54.00 | 4.77 |
| 104.00 | 47232 | 0.14 | 102.00 | 8.25 |
| 130.00 | 1308804 | 0.92 | 100.00 | 10.40 |
| 152.00 | 1493272 | 1.12 | 117.00 | 11.50 |
| 187.00 | 1838800 | 1.50 | 144.00 | 13.00 |
| 354.00 | 50704 | 0.31 | 352.00 | 27.25 |
| 643.00 | 7772538 | 2.63 | 444.00 | 51.00 |
| 750.00 | 6163456 | 3.64 | 605.00 | 59.55 |
常见问题
工具版本过低
工具解析时，提示：The rawheap file's version 2.0.0 is not matched the current rawheap translator, please use the newest version of the translator!
原因：当前工具版本低于rawheap文件版本，升级工具可解决。
文件没有权限
工具解析时，提示：FileStream: open file failed!
原因：生成文件路径下没有写文件权限，指定到有写权限路径下可解决。参考路径：/data/local/tmp。


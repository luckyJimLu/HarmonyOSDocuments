合并文件: harmonyos-guides_20250424_053715.txt, harmonyos-guides_20250424_053842.txt, harmonyos-guides_20250424_053855.txt, harmonyos-guides_20250424_053909.txt, harmonyos-guides_20250424_053923.txt, harmonyos-guides_20250424_053936.txt
合并时间: 2025-04-24 05:41:15
来源: Huawei Developer


==================================================
文件: harmonyos-guides_20250424_053715.txt
==================================================

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-migration-background
爬取时间: 2025-04-24 05:37:15
来源: Huawei Developer

程序稳定性

动态类型语言，例如JavaScript（简称JS），可以使得开发者非常快速地编写代码，但是同时，它也使得程序容易在运行时产生非预期的错误。例如在代码中，如果开发者没有检查一个值是否为undefined，那么程序有可能在运行时崩溃，给开发者造成不便。如果能在代码开发阶段检查此类问题是更有好处的。TS通过标注类型帮助开发者检查错误，许多错误在编译时可以被编译器检测出来，不用等到程序运行时。但是，即使是TS也有局限性，它不强制要求对变量进行类型标注，导致很多编译时检查无法开展。ArkTS尝试克服这些缺点，它强制使用静态类型，旨在通过更严格的类型检查以减少运行时错误。

下面这个例子展示了ArkTS通过强制严格的类型检查来提高代码稳定性和正确性。

显式初始化类的属性

ArkTS要求类的所有属性在声明时或者在构造函数中显式地初始化，这和TS中的strictPropertyInitialization检查一致。以下的代码片段是非严格模式下的TS代码。

收起深色代码主题复制classPerson{name:string// undefinedsetName(n:string):void{this.name= n}getName():string{// 开发者使用"string"作为返回类型，这隐藏了name可能为"undefined"的事实。// 更合适的做法是将返回类型标注为"string | undefined"，以告诉开发者这个API所有可能的返回值的类型。returnthis.name}}letbuddy =newPerson()// 假设代码中没有对name的赋值，例如没有调用"buddy.setName('John')"buddy.getName().length;// 运行时异常：name is undefined

收起深色代码主题复制

收起

深色代码主题复制

深色代码主题

复制

``` classPerson{name:string// undefinedsetName(n:string):void{this.name= n}getName():string{// 开发者使用"string"作为返回类型，这隐藏了name可能为"undefined"的事实。// 更合适的做法是将返回类型标注为"string | undefined"，以告诉开发者这个API所有可能的返回值的类型。returnthis.name}}letbuddy =newPerson()// 假设代码中没有对name的赋值，例如没有调用"buddy.setName('John')"buddy.getName().length;// 运行时异常：name is undefined ```

classPerson{

class

Person

name:string// undefined

name

string

// undefined

setName(n:string):void{

setName

n

void

this.name= n

this

}

getName():string{

getName

// 开发者使用"string"作为返回类型，这隐藏了name可能为"undefined"的事实。

// 更合适的做法是将返回类型标注为"string | undefined"，以告诉开发者这个API所有可能的返回值的类型。

returnthis.name

return

letbuddy =newPerson()

let

new

// 假设代码中没有对name的赋值，例如没有调用"buddy.setName('John')"

buddy.getName().length;// 运行时异常：name is undefined

length

// 运行时异常：name is undefined

由于ArkTS要求属性显式初始化，代码应该像下面这样写。

收起深色代码主题复制classPerson{name:string=''setName(n:string):void{this.name= n}// 类型为"string"，不可能为"null"或者"undefined"getName():string{returnthis.name}}letbuddy =newPerson()// 假设代码中没有对name的赋值，例如没有调用"buddy.setName('John')"buddy.getName().length;// 0, 没有运行时异常

``` classPerson{name:string=''setName(n:string):void{this.name= n}// 类型为"string"，不可能为"null"或者"undefined"getName():string{returnthis.name}}letbuddy =newPerson()// 假设代码中没有对name的赋值，例如没有调用"buddy.setName('John')"buddy.getName().length;// 0, 没有运行时异常 ```

name:string=''

''

// 类型为"string"，不可能为"null"或者"undefined"

buddy.getName().length;// 0, 没有运行时异常

// 0, 没有运行时异常

如果name可以是undefined，那么它的类型应该在代码中被精确地标注。

收起深色代码主题复制classPerson{name?:string// 可能为undefinedsetName(n:string):void{this.name= n}// 编译时错误：name可能为"undefined"，所以不能将这个API的返回类型标注为"string"getNameWrong():string{returnthis.name}getName():string|undefined{// 返回类型匹配name的类型returnthis.name}}letbuddy =newPerson()// 假设代码中没有对name的赋值，例如没有调用"buddy.setName('John')"// 编译时错误：编译器认为下一行代码有可能访问"undefined"的属性，报错buddy.getName().length;// 编译失败buddy.getName()?.length;// 编译成功，没有运行时错误

``` classPerson{name?:string// 可能为undefinedsetName(n:string):void{this.name= n}// 编译时错误：name可能为"undefined"，所以不能将这个API的返回类型标注为"string"getNameWrong():string{returnthis.name}getName():string|undefined{// 返回类型匹配name的类型returnthis.name}}letbuddy =newPerson()// 假设代码中没有对name的赋值，例如没有调用"buddy.setName('John')"// 编译时错误：编译器认为下一行代码有可能访问"undefined"的属性，报错buddy.getName().length;// 编译失败buddy.getName()?.length;// 编译成功，没有运行时错误 ```

name?:string// 可能为undefined

// 可能为undefined

// 编译时错误：name可能为"undefined"，所以不能将这个API的返回类型标注为"string"

getNameWrong():string{

getNameWrong

getName():string|undefined{// 返回类型匹配name的类型

undefined

// 返回类型匹配name的类型

// 编译时错误：编译器认为下一行代码有可能访问"undefined"的属性，报错

buddy.getName().length;// 编译失败

// 编译失败

buddy.getName()?.length;// 编译成功，没有运行时错误

// 编译成功，没有运行时错误

程序性能

为了保证程序的正确性，动态类型语言不得不在运行时检查对象的类型。例如，JS不允许访问undefined的属性。但是检查一个值是否为undefined的唯一的办法是在运行时进行一次类型检查。所有的JS引擎都会做如下的事：如果一个值不是undefined，那么可以访问其属性，否则抛出异常。现代JS引擎可以很好地对这类操作进行优化，但是总有一些运行时的检查是无法被消除的，这就使得程序变慢了。由于TS总是先被编译成JS，所以在TS代码中，也会面临相同的问题。ArkTS解决了这个问题。由于使能了静态类型检查，ArkTS代码将会被编译成方舟字节码文件，而不是JS代码。因此，ArkTS运行速度更快，更容易被进一步地优化。

Null Safety

收起深色代码主题复制functionnotify(who:string, what:string) {console.log(`Dear${who}, a message for you:${what}`)}notify('Jack','You look great today')

``` functionnotify(who:string, what:string) {console.log(`Dear${who}, a message for you:${what}`)}notify('Jack','You look great today') ```

functionnotify(who:string, what:string) {

function

notify

who:string, what:string

console.log(`Dear${who}, a message for you:${what}`)

console

log

`Dear${who}, a message for you:${what}`

${who}

${what}

notify('Jack','You look great today')

'Jack'

'You look great today'

在大多数情况下，函数notify会接受两个string类型的变量作为输入，产生一个新的字符串。但是，如果将一些特殊值作为输入，例如notify(null, undefined)，情况会怎么样呢？

程序仍会正常运行，输出预期值：Dear null, a message for you: undefined。一切看起来正常，但是请注意，为了保证该场景下程序的正确性，引擎总是在运行时进行类型检查，执行类似以下的伪代码。

收起深色代码主题复制function__internal_tostring(s:any):string{if(typeofs ==='string')returnsif(s ===undefined)return'undefined'if(s ===null)return'null'// ...}

``` function__internal_tostring(s:any):string{if(typeofs ==='string')returnsif(s ===undefined)return'undefined'if(s ===null)return'null'// ...} ```

function__internal_tostring(s:any):string{

__internal_tostring

s:any

any

if(typeofs ==='string')

if

typeof

'string'

returns

if(s ===undefined)

return'undefined'

'undefined'

if(s ===null)

null

return'null'

'null'

// ...

现在想象一下，如果函数notify是某些复杂的负载场景中的一部分，而不仅仅是打印日志，那么在运行时执行像__internal_tostring的类型检查将会是一个性能问题。

如果可以保证在运行时，只有string类型的值（不会是其他值，例如null或者undefined）可以被传入函数notify呢？在这种情况下，因为可以确保没有其他边界情况，像__internal_tostring的检查就是多余的了。对于这个场景，这样的机制叫做“null-safety”，也就是说，保证null不是一个合法的string类型变量的值。如果ArkTS有了这个特性，类型不符合的代码将无法编译。

收起深色代码主题复制functionnotify(who:string, what:string) {console.log(`Dear${who}, a message for you:${what}`)}notify('Jack','You look great today')notify(null,undefined)// 编译时错误

``` functionnotify(who:string, what:string) {console.log(`Dear${who}, a message for you:${what}`)}notify('Jack','You look great today')notify(null,undefined)// 编译时错误 ```

notify(null,undefined)// 编译时错误

// 编译时错误

TS通过打开编译选项strictNullChecks来实现此特性。但是TS是被编译成JS的，而JS没有这个特性，因此严格null检查只在编译时起作用。从程序稳定性和性能角度考虑，ArkTS将“null-safety”视为一个重要的特性。这就是为什么ArkTS强制进行严格null检查，在ArkTS中，上面的代码总是编译报错。作为交换，这样的代码可以给ArkTS引擎带来更多的信息和有关值的类型保证，这有助于更好地优化性能。

.ets代码兼容性

在API version 10之前，ArkTS（.ets文件）完全采用了标准TS的语法。从API version 10 Release起，ArkTS的语法规则基于上述设计考虑进行了明确定义，同时，SDK增加了在编译流程中对.ets文件的ArkTS语法检查，通过编译告警或编译失败提示开发者适配新的ArkTS语法。

根据工程的compatibleSdkVersion，具体策略如下：

compatibleSdkVersion >= 10 为标准模式。在该模式下，对.ets文件，违反ArkTS语法规则的代码会导致工程编译失败，需要完全适配ArkTS语法后方可编译成功。

compatibleSdkVersion < 10 为兼容模式。在该模式下，对.ets文件，以warning形式提示违反ArkTS语法规则的所有代码。尽管违反ArkTS语法规则的工程在兼容模式下仍可编译成功，但是需要完全适配ArkTS语法后方可在标准模式下编译成功。

支持与TS/JS的交互

ArkTS支持与TS/JS的高效互操作，在当前版本上，ArkTS运行时兼容动态类型对象语义。在与TS/JS交互的场景下，将TS/JS的数据和对象在ArkTS中当作ArkTS的数据和对象使用时，可能会绕过ArkTS的静态编译检查，造成非预期的行为或引入额外的开销。

收起深色代码主题复制// lib.tsexportclassC{v:string}exportletc =newC()// app.etsimport{ C, c }from'./lib'functionfoo(c: C) {c.v.length}foo(c)// 运行时异常：v is undefined

``` // lib.tsexportclassC{v:string}exportletc =newC()// app.etsimport{ C, c }from'./lib'functionfoo(c: C) {c.v.length}foo(c)// 运行时异常：v is undefined ```

// lib.ts

exportclassC{

export

C

v:string

v

exportletc =newC()

// app.ets

import{ C, c }from'./lib'

import

from

'./lib'

functionfoo(c: C) {

foo

c: C

c.v.length

foo(c)// 运行时异常：v is undefined

// 运行时异常：v is undefined

方舟运行时兼容TS/JS

在API version 11上，HarmonyOS SDK中的TypeScript版本为4.9.5，target字段为es2017。在应用中，开发者可以使用ECMA2017+的语法进行TS/JS开发。

应用环境限制

强制使用严格模式（use strict）

禁止使用eval()

禁止使用with() {}

禁止以字符串为代码创建函数

与标准TS/JS的差异

标准TS/JS中，JSON的数字格式，小数点后必须跟着数字，如2.e3这类科学计数法不被允许，报出SyntaxError。在方舟运行时中，允许使用这类科学计数法。


==================================================
文件: harmonyos-guides_20250424_053842.txt
==================================================

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/introduction-to-arkts
爬取时间: 2025-04-24 05:38:42
来源: Huawei Developer

基本知识

声明

ArkTS通过声明引入变量、常量、函数和类型。

类型

运算符

语句

函数

函数声明

函数声明引入一个函数，包含其名称、参数列表、返回类型和函数体。

以下示例是一个简单的函数，包含两个string类型的参数，返回类型为string：

收起深色代码主题复制functionadd(x:string, y:string):string{letz:string=`${x}${y}`;returnz;}

收起深色代码主题复制

收起

深色代码主题复制

深色代码主题

复制

``` functionadd(x:string, y:string):string{letz:string=`${x}${y}`;returnz;} ```

functionadd(x:string, y:string):string{

function

add

x:string, y:string

string

letz:string=`${x}${y}`;

let

z

`${x}${y}`

${x}

${y}

returnz;

return

}

在函数声明中，必须为每个参数标记类型。如果参数为可选参数，那么允许在调用函数时省略该参数。函数的最后一个参数可以是rest参数。

可选参数

可选参数的格式可为name?: Type。

收起深色代码主题复制functionhello(name?:string) {if(name ==undefined) {console.log('Hello!');}else{console.log(`Hello,${name}!`);}}

``` functionhello(name?:string) {if(name ==undefined) {console.log('Hello!');}else{console.log(`Hello,${name}!`);}} ```

functionhello(name?:string) {

hello

name?:string

if(name ==undefined) {

if

undefined

console.log('Hello!');

console

log

'Hello!'

}else{

else

console.log(`Hello,${name}!`);

`Hello,${name}!`

${name}

可选参数的另一种形式为设置的参数默认值。如果在函数调用中这个参数被省略了，则会使用此参数的默认值作为实参。

收起深色代码主题复制functionmultiply(n:number, coeff:number=2):number{returnn * coeff;}multiply(2);// 返回2*2multiply(2,3);// 返回2*3

``` functionmultiply(n:number, coeff:number=2):number{returnn * coeff;}multiply(2);// 返回2*2multiply(2,3);// 返回2*3 ```

functionmultiply(n:number, coeff:number=2):number{

multiply

n:number, coeff:number=2

number

2

returnn * coeff;

multiply(2);// 返回2*2

// 返回2*2

multiply(2,3);// 返回2*3

3

// 返回2*3

Rest参数

函数的最后一个参数可以是rest参数。rest参数的格式为...restArgs。rest参数允许函数接收一个由剩余实参组成的数组，用于处理不定数量的参数输入。

收起深色代码主题复制functionsum(...numbers:number[]):number{letres =0;for(letnofnumbers)res += n;returnres;}sum();// 返回0sum(1,2,3);// 返回6

``` functionsum(...numbers:number[]):number{letres =0;for(letnofnumbers)res += n;returnres;}sum();// 返回0sum(1,2,3);// 返回6 ```

functionsum(...numbers:number[]):number{

sum

...numbers:number[]

letres =0;

0

for(letnofnumbers)

for

of

res += n;

returnres;

sum();// 返回0

// 返回0

sum(1,2,3);// 返回6

1

// 返回6

返回类型

如果可以从函数体内推断出函数返回类型，则可在函数声明中省略标注返回类型。

收起深色代码主题复制// 显式指定返回类型functionfoo():string{return'foo'; }// 推断返回类型为stringfunctiongoo() {return'goo'; }

``` // 显式指定返回类型functionfoo():string{return'foo'; }// 推断返回类型为stringfunctiongoo() {return'goo'; } ```

// 显式指定返回类型

functionfoo():string{return'foo'; }

foo

'foo'

// 推断返回类型为string

functiongoo() {return'goo'; }

goo

'goo'

不需要返回值的函数的返回类型可以显式指定为void或省略标注。这类函数不需要返回语句。

以下示例中两种函数声明方式都是有效的：

收起深色代码主题复制functionhi1() {console.log('hi'); }functionhi2():void{console.log('hi'); }

``` functionhi1() {console.log('hi'); }functionhi2():void{console.log('hi'); } ```

functionhi1() {console.log('hi'); }

hi1

'hi'

functionhi2():void{console.log('hi'); }

hi2

void

函数的作用域

函数中定义的变量和其他实例仅可以在函数内部访问，不能从外部访问。

如果函数中定义的变量与外部作用域中已有实例同名，则函数内的局部变量定义将覆盖外部定义。

函数调用

调用函数以执行其函数体，实参值会赋值给函数的形参。

如果函数定义如下：

收起深色代码主题复制functionjoin(x:string, y:string):string{letz:string=`${x}${y}`;returnz;}

``` functionjoin(x:string, y:string):string{letz:string=`${x}${y}`;returnz;} ```

functionjoin(x:string, y:string):string{

join

则此函数的调用需要包含两个string类型的参数：

收起深色代码主题复制letx =join('hello','world');console.log(x);

``` letx =join('hello','world');console.log(x); ```

letx =join('hello','world');

'hello'

'world'

console.log(x);

函数类型

函数类型通常用于定义回调：

收起深色代码主题复制typetrigFunc =(x:number) =>number// 这是一个函数类型functiondo_action(f: trigFunc) {f(3.141592653589);// 调用函数}do_action(Math.sin);// 将函数作为参数传入

``` typetrigFunc =(x:number) =>number// 这是一个函数类型functiondo_action(f: trigFunc) {f(3.141592653589);// 调用函数}do_action(Math.sin);// 将函数作为参数传入 ```

typetrigFunc =(x:number) =>number// 这是一个函数类型

type

(x:number) =>

x:number

// 这是一个函数类型

functiondo_action(f: trigFunc) {

do_action

f: trigFunc

f(3.141592653589);// 调用函数

f

3.141592653589

// 调用函数

do_action(Math.sin);// 将函数作为参数传入

Math

sin

// 将函数作为参数传入

箭头函数（又名Lambda函数）

函数可以定义为箭头函数，例如：

收起深色代码主题复制letsum = (x:number,y:number):number=>{returnx + y;}

``` letsum = (x:number,y:number):number=>{returnx + y;} ```

letsum = (x:number,y:number):number=>{

x

y

number=>

returnx + y;

箭头函数的返回类型可以省略；省略时，返回类型通过函数体推断。

表达式可以指定为箭头函数，使表达更简短，因此以下两种表达方式是等价的：

收起深色代码主题复制letsum1= (x:number, y:number) => {returnx + y; }letsum2= (x:number, y:number) => x + y

``` letsum1= (x:number, y:number) => {returnx + y; }letsum2= (x:number, y:number) => x + y ```

letsum1= (x:number, y:number) => {returnx + y; }

sum1

x:number, y:number

letsum2= (x:number, y:number) => x + y

sum2

闭包

闭包是由函数及声明该函数的环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。

在下例中，f函数返回了一个闭包，它捕获了count变量，每次调用z，count的值会被保留并递增。

收起深色代码主题复制functionf():() =>number{letcount =0;letg = ():number=>{ count++;returncount; };returng;}letz =f();z();// 返回：1z();// 返回：2

``` functionf():() =>number{letcount =0;letg = ():number=>{ count++;returncount; };returng;}letz =f();z();// 返回：1z();// 返回：2 ```

functionf():() =>number{

() =>

letcount =0;

letg = ():number=>{ count++;returncount; };

returng;

letz =f();

z();// 返回：1

// 返回：1

z();// 返回：2

// 返回：2

函数重载

我们可以通过编写重载，指定函数的不同调用方式。具体方法为，为同一个函数写入多个同名但签名不同的函数头，函数实现紧随其后。

收起深色代码主题复制functionfoo(x:number):void;/* 第一个函数定义 */functionfoo(x:string):void;/* 第二个函数定义 */functionfoo(x:number|string):void{/* 函数实现 */}foo(123);// OK，使用第一个定义foo('aa');// OK，使用第二个定义

``` functionfoo(x:number):void;/* 第一个函数定义 */functionfoo(x:string):void;/* 第二个函数定义 */functionfoo(x:number|string):void{/* 函数实现 */}foo(123);// OK，使用第一个定义foo('aa');// OK，使用第二个定义 ```

functionfoo(x:number):void;/* 第一个函数定义 */

/* 第一个函数定义 */

functionfoo(x:string):void;/* 第二个函数定义 */

x:string

/* 第二个函数定义 */

functionfoo(x:number|string):void{/* 函数实现 */

x:number|string

/* 函数实现 */

foo(123);// OK，使用第一个定义

123

// OK，使用第一个定义

foo('aa');// OK，使用第二个定义

'aa'

// OK，使用第二个定义

不允许重载函数有相同的名字以及参数列表，否则将会编译报错。

类

类声明引入一个新类型，并定义其字段、方法和构造函数。

在以下示例中，定义了Person类，该类具有字段name和surname、构造函数和方法fullName：

收起深色代码主题复制classPerson{name:string='';surname:string='';constructor(n:string,sn:string) {this.name= n;this.surname= sn;}fullName():string{returnthis.name+' '+this.surname;}}

``` classPerson{name:string='';surname:string='';constructor(n:string,sn:string) {this.name= n;this.surname= sn;}fullName():string{returnthis.name+' '+this.surname;}} ```

classPerson{

class

Person

name:string='';

name

''

surname:string='';

surname

constructor(n:string,sn:string) {

constructor

n

sn

this.name= n;

this

this.surname= sn;

fullName():string{

fullName

returnthis.name+' '+this.surname;

' '

定义类后，可以使用关键字new创建实例：

收起深色代码主题复制letp =newPerson('John','Smith');console.log(p.fullName());

``` letp =newPerson('John','Smith');console.log(p.fullName()); ```

letp =newPerson('John','Smith');

new

'John'

'Smith'

console.log(p.fullName());

或者，可以使用对象字面量创建实例：

收起深色代码主题复制classPoint{x:number=0;y:number=0;}letp:Point= {x:42,y:42};

``` classPoint{x:number=0;y:number=0;}letp:Point= {x:42,y:42}; ```

classPoint{

Point

x:number=0;

y:number=0;

letp:Point= {x:42,y:42};

p

42

字段

字段是直接在类中声明的某种类型的变量。

类可以具有实例字段或者静态字段。

方法

方法属于类。类可以定义实例方法或者静态方法。静态方法属于类本身，只能访问静态字段。而实例方法既可以访问静态字段，也可以访问实例字段，包括类的私有字段。

构造函数

类声明可以包含用于初始化对象状态的构造函数。

构造函数定义如下：

收起深色代码主题复制constructor([parameters]) {// ...}

``` constructor([parameters]) {// ...} ```

constructor([parameters]) {

// ...

如果未定义构造函数，则会自动创建具有空参数列表的默认构造函数，例如：

收起深色代码主题复制classPoint{x:number=0;y:number=0;}letp =newPoint();

``` classPoint{x:number=0;y:number=0;}letp =newPoint(); ```

letp =newPoint();

在这种情况下，默认构造函数使用字段类型的默认值来初始化实例中的字段。

可见性修饰符

类的方法和属性都可以使用可见性修饰符。

可见性修饰符包括：private、protected和public。默认可见性为public。

对象字面量

对象字面量是一个表达式，可用于创建类实例并提供一些初始值。它在某些情况下更方便，可以用来代替new表达式。

对象字面量的表示方式是：封闭在花括号对({})中的'属性名：值'的列表。

收起深色代码主题复制classC{n:number=0;s:string='';}letc: C = {n:42,s:'foo'};

``` classC{n:number=0;s:string='';}letc: C = {n:42,s:'foo'}; ```

classC{

C

n:number=0;

s:string='';

s

letc: C = {n:42,s:'foo'};

c

ArkTS是静态类型语言，如上述示例所示，对象字面量只能在可以推导出该字面量类型的上下文中使用。其他正确的例子：

收起深色代码主题复制classC{n:number=0;s:string='';}functionfoo(c: C) {}letc: Cc = {n:42,s:'foo'};// 使用变量的类型foo({n:42,s:'foo'});// 使用参数的类型functionbar(): C {return{n:42,s:'foo'};// 使用返回类型}

``` classC{n:number=0;s:string='';}functionfoo(c: C) {}letc: Cc = {n:42,s:'foo'};// 使用变量的类型foo({n:42,s:'foo'});// 使用参数的类型functionbar(): C {return{n:42,s:'foo'};// 使用返回类型} ```

functionfoo(c: C) {}

c: C

letc: C

c = {n:42,s:'foo'};// 使用变量的类型

// 使用变量的类型

foo({n:42,s:'foo'});// 使用参数的类型

// 使用参数的类型

functionbar(): C {

bar

return{n:42,s:'foo'};// 使用返回类型

// 使用返回类型

也可以在数组元素类型或类字段类型中使用：

收起深色代码主题复制classC{n:number=0;s:string='';}letcc: C[] = [{n:1,s:'a'}, {n:2,s:'b'}];

``` classC{n:number=0;s:string='';}letcc: C[] = [{n:1,s:'a'}, {n:2,s:'b'}]; ```

letcc: C[] = [{n:1,s:'a'}, {n:2,s:'b'}];

cc

'a'

'b'

抽象类

带有修饰符abstract的类称为抽象类。抽象类可用于表示一组更具体的概念所共有的概念。

如果尝试创建抽象类的实例，则会发生编译时的错误：

收起深色代码主题复制abstractclassX{field:number;constructor(p:number) {this.field= p;}}letx =newX(666)//编译时错误：不能创建抽象类的具体实例

``` abstractclassX{field:number;constructor(p:number) {this.field= p;}}letx =newX(666)//编译时错误：不能创建抽象类的具体实例 ```

abstractclassX{

abstract

X

field:number;

field

constructor(p:number) {

p:number

this.field= p;

letx =newX(666)//编译时错误：不能创建抽象类的具体实例

666

//编译时错误：不能创建抽象类的具体实例

抽象类的子类可以是抽象类也可以是非抽象类。抽象父类的非抽象子类可以实例化。因此，执行抽象类的构造函数和该类非静态字段的字段初始化器：

收起深色代码主题复制abstractclassBase{field:number;constructor(p:number) {this.field= p;}}classDerivedextendsBase{constructor(p:number) {super(p);}}

``` abstractclassBase{field:number;constructor(p:number) {this.field= p;}}classDerivedextendsBase{constructor(p:number) {super(p);}} ```

abstractclassBase{

Base

classDerivedextendsBase{

Derived

extends

super(p);

super

接口

接口声明引入新类型。接口是定义代码协定的常见方式。

任何一个类的实例只要实现了特定接口，就可以通过该接口实现多态。

接口通常包含属性和方法的声明

示例：

收起深色代码主题复制interfaceStyle{color:string;// 属性}interfaceAreaSize{calculateAreaSize():number;// 方法的声明someMethod():void;// 方法的声明}

``` interfaceStyle{color:string;// 属性}interfaceAreaSize{calculateAreaSize():number;// 方法的声明someMethod():void;// 方法的声明} ```

interfaceStyle{

interface

Style

color:string;// 属性

color

// 属性

interfaceAreaSize{

AreaSize

calculateAreaSize():number;// 方法的声明

calculateAreaSize

// 方法的声明

someMethod():void;// 方法的声明

someMethod

实现接口的类示例：

收起深色代码主题复制// 接口：interfaceAreaSize{calculateAreaSize():number;// 方法的声明someMethod():void;// 方法的声明}// 实现：classRectangleSizeimplementsAreaSize{privatewidth:number=0;privateheight:number=0;someMethod():void{console.log('someMethod called');}calculateAreaSize():number{this.someMethod();// 调用另一个方法并返回结果returnthis.width*this.height;}}

``` // 接口：interfaceAreaSize{calculateAreaSize():number;// 方法的声明someMethod():void;// 方法的声明}// 实现：classRectangleSizeimplementsAreaSize{privatewidth:number=0;privateheight:number=0;someMethod():void{console.log('someMethod called');}calculateAreaSize():number{this.someMethod();// 调用另一个方法并返回结果returnthis.width*this.height;}} ```

// 接口：

// 实现：

classRectangleSizeimplementsAreaSize{

RectangleSize

implements

privatewidth:number=0;

private

width

privateheight:number=0;

height

someMethod():void{

console.log('someMethod called');

'someMethod called'

calculateAreaSize():number{

this.someMethod();// 调用另一个方法并返回结果

// 调用另一个方法并返回结果

returnthis.width*this.height;

接口属性

接口属性可以是字段、getter、setter或getter和setter组合的形式。

属性字段只是getter/setter对的便捷写法。以下表达方式是等价的：

收起深色代码主题复制interfaceStyle{color:string;}

``` interfaceStyle{color:string;} ```

color:string;

收起深色代码主题复制interfaceStyle{getcolor():string;setcolor(x:string);}

``` interfaceStyle{getcolor():string;setcolor(x:string);} ```

getcolor():string;

get

setcolor(x:string);

set

实现接口的类也可以使用以下两种方式：

收起深色代码主题复制interfaceStyle{color:string;}classStyledRectangleimplementsStyle{color:string='';}

``` interfaceStyle{color:string;}classStyledRectangleimplementsStyle{color:string='';} ```

classStyledRectangleimplementsStyle{

StyledRectangle

color:string='';

收起深色代码主题复制interfaceStyle{color:string;}classStyledRectangleimplementsStyle{private_color:string='';getcolor():string{returnthis._color; }setcolor(x:string) {this._color= x; }}

``` interfaceStyle{color:string;}classStyledRectangleimplementsStyle{private_color:string='';getcolor():string{returnthis._color; }setcolor(x:string) {this._color= x; }} ```

private_color:string='';

_color

getcolor():string{returnthis._color; }

setcolor(x:string) {this._color= x; }

接口继承

接口可以继承其他接口，如下面的示例所示：

收起深色代码主题复制interfaceStyle{color:string;}interfaceExtendedStyleextendsStyle{width:number;}

``` interfaceStyle{color:string;}interfaceExtendedStyleextendsStyle{width:number;} ```

interfaceExtendedStyleextendsStyle{

ExtendedStyle

width:number;

继承接口包含被继承接口的所有属性和方法，还可以添加自己的属性和方法。

抽象类和接口

抽象类与接口都无法实例化。抽象类是类的抽象，抽象类用来捕捉子类的通用特性，接口是行为的抽象。在ArkTS中抽象类与接口的区别如下：

一个类只能继承一个抽象类，而一个类可以实现一个或多个接口；

接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；

抽象类里面可以有方法的实现，但是接口完全都是抽象的，不存在方法的实现；

抽象类可以有构造函数，而接口不能有构造函数。

泛型类型和函数

泛型类型和函数允许创建的代码在各种类型上运行，而不仅支持单一类型。

泛型类和接口

类和接口可以定义为泛型，将参数添加到类型定义中，如以下示例中的类型参数Element：

收起深色代码主题复制classCustomStack<Element> {publicpush(e:Element):void{// ...}}

``` classCustomStack<Element> {publicpush(e:Element):void{// ...}} ```

classCustomStack<Element> {

CustomStack

Element

publicpush(e:Element):void{

public

push

e

要使用类型CustomStack，必须为每个类型参数指定类型实参：

收起深色代码主题复制lets =newCustomStack<string>();s.push('hello');

``` lets =newCustomStack<string>();s.push('hello'); ```

lets =newCustomStack<string>();

s.push('hello');

编译器在使用泛型类型和函数时会确保类型安全。参见以下示例：

收起深色代码主题复制lets =newCustomStack<string>();s.push(55);// 将会产生编译时错误

``` lets =newCustomStack<string>();s.push(55);// 将会产生编译时错误 ```

s.push(55);// 将会产生编译时错误

55

// 将会产生编译时错误

泛型约束

泛型类型的类型参数可以被限制只能取某些特定的值。例如，MyHashMap<Key, Value>这个类中的Key类型参数必须具有hash方法。

收起深色代码主题复制interfaceHashable{hash():number;}classMyHashMap<KeyextendsHashable,Value> {publicset(k: Key, v: Value) {leth = k.hash();// ...其他代码...}}

``` interfaceHashable{hash():number;}classMyHashMap<KeyextendsHashable,Value> {publicset(k: Key, v: Value) {leth = k.hash();// ...其他代码...}} ```

interfaceHashable{

Hashable

hash():number;

hash

classMyHashMap<KeyextendsHashable,Value> {

MyHashMap

Key

Value

publicset(k: Key, v: Value) {

k: Key, v: Value

leth = k.hash();

// ...其他代码...

在上面的例子中，Key类型扩展了Hashable，Hashable接口的所有方法都可以为key调用。

泛型函数

使用泛型函数可编写更通用的代码。比如返回数组最后一个元素的函数：

收起深色代码主题复制functionlast(x:number[]):number{returnx[x.length-1];}last([1,2,3]);// 3

``` functionlast(x:number[]):number{returnx[x.length-1];}last([1,2,3]);// 3 ```

functionlast(x:number[]):number{

last

x:number[]

returnx[x.length-1];

length

last([1,2,3]);// 3

// 3

如果需要为任何数组定义相同的函数，使用类型参数将该函数定义为泛型：

收起深色代码主题复制functionlast<T>(x: T[]): T {returnx[x.length-1];}

``` functionlast<T>(x: T[]): T {returnx[x.length-1];} ```

functionlast<T>(x: T[]): T {

现在，该函数可以与任何数组一起使用。

在函数调用中，类型实参可以显式或隐式设置：

收起深色代码主题复制// 显式设置的类型实参last<string>(['aa','bb']);last<number>([1,2,3]);// 隐式设置的类型实参// 编译器根据调用参数的类型来确定类型实参last([1,2,3]);

``` // 显式设置的类型实参last<string>(['aa','bb']);last<number>([1,2,3]);// 隐式设置的类型实参// 编译器根据调用参数的类型来确定类型实参last([1,2,3]); ```

// 显式设置的类型实参

last<string>(['aa','bb']);

'bb'

last<number>([1,2,3]);

// 隐式设置的类型实参

// 编译器根据调用参数的类型来确定类型实参

last([1,2,3]);

泛型默认值

泛型类型的类型参数可以设置默认值。这样可以不指定实际的类型实参，而只使用泛型类型名称。下面的示例展示了类和函数的这一点。

收起深色代码主题复制classSomeType{}interfaceInterface<T1 =SomeType> { }classBase<T2=SomeType> { }classDerived1extendsBaseimplementsInterface{ }// Derived1在语义上等价于Derived2classDerived2extendsBase<SomeType>implementsInterface<SomeType> { }functionfoo<T =number>(): T {// ...}foo();// 此函数在语义上等价于下面的调用foo<number>();

``` classSomeType{}interfaceInterface<T1 =SomeType> { }classBase<T2=SomeType> { }classDerived1extendsBaseimplementsInterface{ }// Derived1在语义上等价于Derived2classDerived2extendsBase<SomeType>implementsInterface<SomeType> { }functionfoo<T =number>(): T {// ...}foo();// 此函数在语义上等价于下面的调用foo<number>(); ```

classSomeType{}

SomeType

interfaceInterface<T1 =SomeType> { }

Interface

classBase<T2=SomeType> { }

T2

classDerived1extendsBaseimplementsInterface{ }

Derived1

// Derived1在语义上等价于Derived2

classDerived2extendsBase<SomeType>implementsInterface<SomeType> { }

Derived2

functionfoo<T =number>(): T {

foo();

// 此函数在语义上等价于下面的调用

foo<number>();

空安全

默认情况下，ArkTS中的所有类型都是不可为空的，因此类型的值不能为空。这类似于TypeScript的严格空值检查模式（strictNullChecks），但规则更严格。

在下面的示例中，所有行都会导致编译时错误：

收起深色代码主题复制letx:number=null;// 编译时错误lety:string=null;// 编译时错误letz:number[] =null;// 编译时错误

``` letx:number=null;// 编译时错误lety:string=null;// 编译时错误letz:number[] =null;// 编译时错误 ```

letx:number=null;// 编译时错误

null

// 编译时错误

lety:string=null;// 编译时错误

letz:number[] =null;// 编译时错误

可以为空值的变量定义为联合类型T | null。

收起深色代码主题复制letx:number|null=null;x =1;// okx =null;// okif(x !=null) {/* do something */}

``` letx:number|null=null;x =1;// okx =null;// okif(x !=null) {/* do something */} ```

letx:number|null=null;

x =1;// ok

// ok

x =null;// ok

if(x !=null) {/* do something */}

/* do something */

非空断言运算符

后缀运算符!可用于断言其操作数为非空。

应用于可空类型的值时，它的编译时类型变为非空类型。例如，类型将从T | null更改为T：

收起深色代码主题复制classA{value:number=0;}functionfoo(a: A |null) {a.value;// 编译时错误：无法访问可空值的属性a!.value;// 编译通过，如果运行时a的值非空，可以访问到a的属性；如果运行时a的值为空，则发生运行时异常}

``` classA{value:number=0;}functionfoo(a: A |null) {a.value;// 编译时错误：无法访问可空值的属性a!.value;// 编译通过，如果运行时a的值非空，可以访问到a的属性；如果运行时a的值为空，则发生运行时异常} ```

classA{

A

value:number=0;

value

functionfoo(a: A |null) {

a: A |null

a.value;// 编译时错误：无法访问可空值的属性

// 编译时错误：无法访问可空值的属性

a!.value;// 编译通过，如果运行时a的值非空，可以访问到a的属性；如果运行时a的值为空，则发生运行时异常

// 编译通过，如果运行时a的值非空，可以访问到a的属性；如果运行时a的值为空，则发生运行时异常

空值合并运算符

空值合并二元运算符??用于检查左侧表达式的求值是否等于null或者undefined。如果是，则表达式的结果为右侧表达式；否则，结果为左侧表达式。

换句话说，a ?? b等价于三元运算符(a != null && a != undefined) ? a : b。

在以下示例中，getNick方法如果设置了昵称，则返回昵称；否则，返回空字符串：

收起深色代码主题复制classPerson{// ...nick:string|null=null;getNick():string{returnthis.nick??'';}}

``` classPerson{// ...nick:string|null=null;getNick():string{returnthis.nick??'';}} ```

nick:string|null=null;

nick

getNick():string{

getNick

returnthis.nick??'';

可选链

在访问对象属性时，如果该属性是undefined或者null，可选链运算符会返回undefined。

收起深色代码主题复制classPerson{nick:string|null=null;spouse?:PersonsetSpouse(spouse:Person):void{this.spouse= spouse;}getSpouseNick():string|null|undefined{returnthis.spouse?.nick;}constructor(nick:string) {this.nick= nick;this.spouse=undefined;}}

``` classPerson{nick:string|null=null;spouse?:PersonsetSpouse(spouse:Person):void{this.spouse= spouse;}getSpouseNick():string|null|undefined{returnthis.spouse?.nick;}constructor(nick:string) {this.nick= nick;this.spouse=undefined;}} ```

spouse?:Person

setSpouse(spouse:Person):void{

setSpouse

spouse

this.spouse= spouse;

getSpouseNick():string|null|undefined{

getSpouseNick

returnthis.spouse?.nick;

constructor(nick:string) {

nick:string

this.nick= nick;

this.spouse=undefined;

说明：getSpouseNick的返回类型必须为string | null | undefined，因为该方法可能返回null或者undefined。

可选链可以任意长，可以包含任意数量的?.运算符。

在以下示例中，如果一个Person的实例有不为空的spouse属性，且spouse有不为空的nick属性，则输出spouse.nick。否则，输出undefined：

收起深色代码主题复制classPerson{nick:string|null=null;spouse?:Person;constructor(nick:string) {this.nick= nick;this.spouse=undefined;}}letp:Person=newPerson('Alice');p.spouse?.nick;// undefined

``` classPerson{nick:string|null=null;spouse?:Person;constructor(nick:string) {this.nick= nick;this.spouse=undefined;}}letp:Person=newPerson('Alice');p.spouse?.nick;// undefined ```

spouse?:Person;

letp:Person=newPerson('Alice');

'Alice'

p.spouse?.nick;// undefined

// undefined

模块

程序可划分为多组编译单元或模块。

每个模块都有其自己的作用域，即，在模块中创建的任何声明（变量、函数、类等）在该模块之外都不可见，除非它们被显式导出。

与此相对，从另一个模块导出的变量、函数、类、接口等必须首先导入到模块中。

导出

可以使用关键字export导出顶层的声明。

未导出的声明名称被视为私有名称，只能在声明该名称的模块中使用。

收起深色代码主题复制exportclassPoint{x:number=0;y:number=0;constructor(x:number, y:number) {this.x= x;this.y= y;}}exportletOrigin=newPoint(0,0);exportfunctionDistance(p1: Point, p2: Point):number{returnMath.sqrt((p2.x- p1.x) * (p2.x- p1.x) + (p2.y- p1.y) * (p2.y- p1.y));}

``` exportclassPoint{x:number=0;y:number=0;constructor(x:number, y:number) {this.x= x;this.y= y;}}exportletOrigin=newPoint(0,0);exportfunctionDistance(p1: Point, p2: Point):number{returnMath.sqrt((p2.x- p1.x) * (p2.x- p1.x) + (p2.y- p1.y) * (p2.y- p1.y));} ```

exportclassPoint{

export

constructor(x:number, y:number) {

this.x= x;

this.y= y;

exportletOrigin=newPoint(0,0);

Origin

exportfunctionDistance(p1: Point, p2: Point):number{

Distance

p1: Point, p2: Point

returnMath.sqrt((p2.x- p1.x) * (p2.x- p1.x) + (p2.y- p1.y) * (p2.y- p1.y));

sqrt

导入

顶层语句

顶层语句是指在模块的最外层直接编写的语句，这些语句不被包裹在任何函数、类、块级作用域中。顶层语句包括变量声明、函数声明、表达式等。

关键字

关键字this只能在类的实例方法中使用。

示例

收起深色代码主题复制classA{count:string='a';m(i:string):void{this.count= i;}}

``` classA{count:string='a';m(i:string):void{this.count= i;}} ```

count:string='a';

count

m(i:string):void{

m

i

this.count= i;

使用限制：

不支持this类型

不支持在函数和类的静态方法中使用this

收起深色代码主题复制classA{n:number=0;f1(arg1:this) {}// 编译时错误，不支持this类型staticf2(arg1:number) {this.n= arg1;// 编译时错误，不支持在类的静态方法中使用this}}functionfoo(arg1:number) {this.n= i;// 编译时错误，不支持在函数中使用this}

``` classA{n:number=0;f1(arg1:this) {}// 编译时错误，不支持this类型staticf2(arg1:number) {this.n= arg1;// 编译时错误，不支持在类的静态方法中使用this}}functionfoo(arg1:number) {this.n= i;// 编译时错误，不支持在函数中使用this} ```

f1(arg1:this) {}// 编译时错误，不支持this类型

f1

arg1:this

// 编译时错误，不支持this类型

staticf2(arg1:number) {

static

f2

arg1:number

this.n= arg1;// 编译时错误，不支持在类的静态方法中使用this

// 编译时错误，不支持在类的静态方法中使用this

functionfoo(arg1:number) {

this.n= i;// 编译时错误，不支持在函数中使用this

// 编译时错误，不支持在函数中使用this

关键字this的指向:

调用实例方法的对象

正在构造的对象

ArkUI支持

本节演示ArkTS为创建图形用户界面（GUI）程序提供的机制。ArkUI基于TypeScript提供了一系列扩展能力，以声明式地描述应用程序的GUI以及GUI组件间的交互。


==================================================
文件: harmonyos-guides_20250424_053855.txt
==================================================

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-coding-style-guide
爬取时间: 2025-04-24 05:38:55
来源: Huawei Developer

目标和适用范围

本文参考业界标准及实践，结合ArkTS语言特点，为提高代码的规范、安全、性能提供编码指南。

本文适用于开发者进行系统开发或者应用开发时，使用ArkTS编写代码的场景。

规则来源

ArkTS在保持TypeScript基本语法风格的基础上，进一步强化静态检查和分析。本文部分规则筛选自《OpenHarmony应用TS&JS编程指南》，为ArkTS语言新增的语法添加了规则，旨在提高代码可读性、执行性能。

章节概览

代码风格

包含命名和格式。

编程实践

包含声明与初始化、数据类型、运算与表达式、异常等。

参考了《OpenHarmony应用TS&JS编程指南》中的规则，对其中ArkTS语言不涉及的部分作了去除，为ArkTS语言新增的语法添加了规则。

术语和定义

术语缩略语中文解释ArkTS无ArkTS编程语言TypeScriptTSTypeScript编程语言JavaScriptJSJavaScript编程语言ESObject无在ArkTS跨语言调用的场景中，用以标注JS/TS对象的类型

总体原则

规则分为两个级别：要求、建议。

要求：表示原则上应该遵从。本文所有内容目前均为针对ArkTS的要求。

建议：表示该条款属于最佳实践，可结合实际情况考虑是否纳入。

命名

为标识符取一个好名字，提高代码可读性

【描述】

好的标识符命名，应遵循以下基本原则：

能清晰的表达意图，避免使用单个字母、未成惯例的缩写来命名

使用正确的英文单词并符合英文语法，不要使用中文拼音

能区分出意思，避免造成误导

类名、枚举名、命名空间名采用UpperCamelCase风格

【级别】建议

类采用首字母大写的驼峰命名法。

类名通常是名词或名词短语，例如Person、Student、Worker。不应使用动词，也应该避免类似Data、Info这样的模糊词。

【正例】

收起深色代码主题复制// 类名classUser{username:stringconstructor(username:string) {this.username= username;}sayHi() {console.log('hi'+this.username);}}// 枚举名enumUserType{TEACHER=0,STUDENT=1};// 命名空间namespaceBase64Utils{functionencrypt() {// todo encrypt}functiondecrypt() {// todo decrypt}};

收起深色代码主题复制

收起

深色代码主题复制

深色代码主题

复制

``` // 类名classUser{username:stringconstructor(username:string) {this.username= username;}sayHi() {console.log('hi'+this.username);}}// 枚举名enumUserType{TEACHER=0,STUDENT=1};// 命名空间namespaceBase64Utils{functionencrypt() {// todo encrypt}functiondecrypt() {// todo decrypt}}; ```

// 类名

classUser{

class

User

username:string

username

string

constructor(username:string) {

constructor

this.username= username;

this

}

sayHi() {

sayHi

console.log('hi'+this.username);

console

log

'hi'

// 枚举名

enumUserType{

enum

UserType

TEACHER=0,

TEACHER

0

STUDENT=1

STUDENT

1

};

// 命名空间

namespaceBase64Utils{

namespace

Base64Utils

functionencrypt() {

function

encrypt

// todo encrypt

functiondecrypt() {

decrypt

// todo decrypt

变量名、方法名、参数名采用lowerCamelCase风格

函数的命名通常是动词或动词短语，采用小驼峰命名，示例如下：

load + 属性名()

put + 属性名()

is + 布尔属性名()

has + 名词/形容词()

动词()

动词 + 宾语()变量的名字通常是名词或名词短语，应采用小驼峰命名，以便于理解其含义。

动词 + 宾语()

变量的名字通常是名词或名词短语，应采用小驼峰命名，以便于理解其含义。

收起深色代码主题复制letmsg ='Hello world';functionsendMsg(msg:string){// todo send message}letuserName ='Zhangsan';functionfindUser(userName:string){// todo find user by user name}

``` letmsg ='Hello world';functionsendMsg(msg:string){// todo send message}letuserName ='Zhangsan';functionfindUser(userName:string){// todo find user by user name} ```

letmsg ='Hello world';

let

'Hello world'

functionsendMsg(msg:string){

functionsendMsg(msg:string)

sendMsg

msg:string

// todo send message

letuserName ='Zhangsan';

'Zhangsan'

functionfindUser(userName:string){

functionfindUser(userName:string)

findUser

userName:string

// todo find user by user name

常量名、枚举值名采用全部大写，单词间使用下划线隔开

常量命名，应该由全大写单词与下划线组成，单词间用下划线分割。常量命名要尽量表达完整的语义。

收起深色代码主题复制constMAX_USER_SIZE =10000;enumUserType{TEACHER =0,STUDENT =1};

``` constMAX_USER_SIZE =10000;enumUserType{TEACHER =0,STUDENT =1}; ```

constMAX_USER_SIZE =10000;

const

10000

TEACHER =0,

STUDENT =1

避免使用否定的布尔变量名，布尔型的局部变量或方法需加上表达是非意义的前缀

布尔型的局部变量建议加上表达是非意义的前缀，比如is，也可以是has、can、should等。但是，当使用逻辑非运算符，并出现双重否定时，会出现理解问题，比如!isNotError，意味着什么，不是很好理解。因此，应避免定义否定的布尔变量名。

【反例】

收起深色代码主题复制letisNoError =true;letisNotFound =false;functionempty(){}functionnext(){}

``` letisNoError =true;letisNotFound =false;functionempty(){}functionnext(){} ```

letisNoError =true;

true

letisNotFound =false;

false

functionempty(){}

functionempty()

empty

functionnext(){}

functionnext()

next

收起深色代码主题复制letisError =false;letisFound =true;functionisEmpty(){}functionhasNext(){}

``` letisError =false;letisFound =true;functionisEmpty(){}functionhasNext(){} ```

letisError =false;

letisFound =true;

functionisEmpty(){}

functionisEmpty()

isEmpty

functionhasNext(){}

functionhasNext()

hasNext

格式

使用空格缩进，禁止使用tab字符

只允许使用空格(space)进行缩进。

建议大部分场景优先使用2个空格，换行导致的缩进优先使用4个空格。

不允许插入制表符Tab。当前几乎所有的集成开发环境（IDE）和代码编辑器都支持配置将Tab键自动扩展为2个空格输入，应在代码编辑器中配置使用空格进行缩进。

收起深色代码主题复制classDataSource{id:number=0title:string=''content:string=''}constdataSource:DataSource[] = [{id:1,title:'Title 1',content:'Content 1'},{id:2,title:'Title 2',content:'Content 2'}];functiontest(dataSource:DataSource[]) {if(!dataSource.length) {return;}for(letdataofdataSource) {if(!data|| !data.id|| !data.title|| !data.content) {continue;}// some code}// some code}

``` classDataSource{id:number=0title:string=''content:string=''}constdataSource:DataSource[] = [{id:1,title:'Title 1',content:'Content 1'},{id:2,title:'Title 2',content:'Content 2'}];functiontest(dataSource:DataSource[]) {if(!dataSource.length) {return;}for(letdataofdataSource) {if(!data|| !data.id|| !data.title|| !data.content) {continue;}// some code}// some code} ```

classDataSource{

DataSource

id:number=0

id

number

title:string=''

title

''

content:string=''

content

constdataSource:DataSource[] = [

dataSource

{

id:1,

title:'Title 1',

'Title 1'

content:'Content 1'

'Content 1'

},

id:2,

2

title:'Title 2',

'Title 2'

content:'Content 2'

'Content 2'

];

functiontest(dataSource:DataSource[]) {

test

if(!dataSource.length) {

if

length

return;

return

for(letdataofdataSource) {

for

data

of

if(!data|| !data.id|| !data.title|| !data.content) {

continue;

continue

// some code

行宽不超过120个字符

代码行宽不宜过长，否则不利于阅读。

控制行宽可以间接的引导程序员去缩短函数、变量的命名，减少嵌套的层数，精炼注释，提升代码可读性。

建议每行字符数不要超过120个；除非超过120能显著增加可读性，并且不会隐藏信息。

例外：如果一行注释包含了超过120个字符的命令或URL，则可以保持一行，以方便复制、粘贴和通过grep查找；预处理的error信息在一行便于阅读和理解，即使超过120个字符。

条件语句和循环语句的实现必须使用大括号

在if、for、do、while等语句的执行体加大括号{}是一种最佳实践，因为省略大括号容易导致错误，并且降低代码的清晰度。

收起深色代码主题复制if(condition)console.log('success');for(letidx =0; idx <5; ++idx)console.log(idx);

``` if(condition)console.log('success');for(letidx =0; idx <5; ++idx)console.log(idx); ```

if(condition)

console.log('success');

'success'

for(letidx =0; idx <5; ++idx)

5

console.log(idx);

收起深色代码主题复制if(condition) {console.log('success');}for(letidx =0; idx <5; ++idx) {console.log(idx);}

``` if(condition) {console.log('success');}for(letidx =0; idx <5; ++idx) {console.log(idx);} ```

if(condition) {

for(letidx =0; idx <5; ++idx) {

switch语句的case和default需缩进一层

switch的case和default要缩进一层（2个空格）。开关标签之后换行的语句，需再缩进一层（2个空格）。

收起深色代码主题复制switch(condition) {case0: {doSomething();break;}case1: {doOtherthing();break;}default:break;}

``` switch(condition) {case0: {doSomething();break;}case1: {doOtherthing();break;}default:break;} ```

switch(condition) {

switch

case0: {

case

doSomething();

doSomething

break;

break

case1: {

doOtherthing();

doOtherthing

default:

default

表达式换行需保持一致性，运算符放行末

当语句过长，或者可读性不佳时，需要在合适的地方换行。

换行时将操作符放在行末，表示“未结束，后续还有”，保持与常用的格式化工具的默认配置一致。

收起深色代码主题复制// 假设条件语句超出行宽if (userCount > MAX_USER_COUNT ||userCount < MIN_USER_COUNT) {doSomething();}

``` // 假设条件语句超出行宽if (userCount > MAX_USER_COUNT ||userCount < MIN_USER_COUNT) {doSomething();} ```

// 假设条件语句超出行宽

if (userCount > MAX_USER_COUNT ||

userCount < MIN_USER_COUNT) {

多个变量定义和赋值语句不允许写在一行

【级别】要求

每个语句的变量声明都应只声明一个变量。

这种方式更易添加变量声明，不用考虑将;变成,，以免引入错误。另外，每个语句只声明一个变量，用debugger逐个调试也很方便，而不是一次跳过所有变量。

收起深色代码主题复制letmaxCount = 10, isCompleted =false;letpointX, pointY;pointX = 10; pointY = 0;

``` letmaxCount = 10, isCompleted =false;letpointX, pointY;pointX = 10; pointY = 0; ```

letmaxCount = 10, isCompleted =false;

letpointX, pointY;

pointX = 10; pointY = 0;

收起深色代码主题复制letmaxCount = 10;letisCompleted =false;letpointX = 0;letpointY = 0;

``` letmaxCount = 10;letisCompleted =false;letpointX = 0;letpointY = 0; ```

letmaxCount = 10;

letisCompleted =false;

letpointX = 0;

letpointY = 0;

空格应该突出关键字和重要信息，避免不必要的空格

空格应该突出关键字和重要信息。总体建议如下：

if, for, while, switch等关键字与左括号(之间加空格。

在函数定义和调用时，函数名称与参数列表的左括号(之间不加空格。

关键字else或catch与其之前的大括号}之间加空格。

任何打开大括号({)之前加空格，有两个例外：a) 在作为函数的第一个参数或数组中的第一个元素时，对象之前不用加空格，例如：foo({ name: 'abc' })。b) 在模板中，不用加空格，例如：abc${name}。

任何打开大括号({)之前加空格，有两个例外：

a) 在作为函数的第一个参数或数组中的第一个元素时，对象之前不用加空格，例如：foo({ name: 'abc' })。

b) 在模板中，不用加空格，例如：abc${name}。

二元操作符(+ - * = < > <= >= === !== && ||)前后加空格；三元操作符(? :)符号两侧均加空格。

数组初始化中的逗号和函数中多个参数之间的逗号后加空格。

在逗号(,)或分号(;)之前不加空格。

数组的中括号([])内侧不要加空格。

不要出现多个连续空格。在某行中，多个空格若不是用来作缩进的，通常是个错误。

收起深色代码主题复制// if 和左括号 ( 之间没有加空格if(isJedi) {fight();}// 函数名fight和左括号 ( 之间加了空格function fight (): void {console.log('Swooosh!');}

``` // if 和左括号 ( 之间没有加空格if(isJedi) {fight();}// 函数名fight和左括号 ( 之间加了空格function fight (): void {console.log('Swooosh!');} ```

// if 和左括号 ( 之间没有加空格

if(isJedi) {

fight();

fight

// 函数名fight和左括号 ( 之间加了空格

function fight (): void {

console.log('Swooosh!');

.log

收起深色代码主题复制// if 和左括号之间加一个空格if (isJedi) {fight();}// 函数名fight和左括号 ( 之间不加空格functionfight(): void {console.log('Swooosh!');}

``` // if 和左括号之间加一个空格if (isJedi) {fight();}// 函数名fight和左括号 ( 之间不加空格functionfight(): void {console.log('Swooosh!');} ```

// if 和左括号之间加一个空格

if (isJedi) {

// 函数名fight和左括号 ( 之间不加空格

functionfight(): void {

收起深色代码主题复制if(flag) {// ...}else{// else 与其前面的大括号 } 之间没有加空格// ...}

``` if(flag) {// ...}else{// else 与其前面的大括号 } 之间没有加空格// ...} ```

if(flag) {

// ...

}else{// else 与其前面的大括号 } 之间没有加空格

else

// else 与其前面的大括号 } 之间没有加空格

收起深色代码主题复制if(flag) {// ...}else{// else 与其前面的大括号 } 之间增加空格// ...}

``` if(flag) {// ...}else{// else 与其前面的大括号 } 之间增加空格// ...} ```

}else{// else 与其前面的大括号 } 之间增加空格

// else 与其前面的大括号 } 之间增加空格

收起深色代码主题复制functionfoo(){// 函数声明时，左大括号 { 之前加个空格// ...}bar('attr', { // 左大括号前加个空格age:'1 year',sbreed:'Bernese Mountain Dog',});

``` functionfoo(){// 函数声明时，左大括号 { 之前加个空格// ...}bar('attr', { // 左大括号前加个空格age:'1 year',sbreed:'Bernese Mountain Dog',}); ```

functionfoo(){// 函数声明时，左大括号 { 之前加个空格

functionfoo()

foo

// 函数声明时，左大括号 { 之前加个空格

bar('attr', { // 左大括号前加个空格

bar

'attr'

age:'1 year',

age

'1 year'

sbreed:'Bernese Mountain Dog',

sbreed

'Bernese Mountain Dog'

});

收起深色代码主题复制constarr = [1,2,3];// 数组初始化中的逗号后面加个空格，逗号前面不加空格myFunc(bar, foo, baz);// 函数的多个参数之间的逗号后加个空格，逗号前面不加空格

``` constarr = [1,2,3];// 数组初始化中的逗号后面加个空格，逗号前面不加空格myFunc(bar, foo, baz);// 函数的多个参数之间的逗号后加个空格，逗号前面不加空格 ```

constarr = [1,2,3];// 数组初始化中的逗号后面加个空格，逗号前面不加空格

3

// 数组初始化中的逗号后面加个空格，逗号前面不加空格

myFunc(bar, foo, baz);// 函数的多个参数之间的逗号后加个空格，逗号前面不加空格

myFunc

// 函数的多个参数之间的逗号后加个空格，逗号前面不加空格

建议字符串使用单引号

较为约定俗成，单引号优于双引号。

收起深色代码主题复制letmessage ="world";console.log(message);

``` letmessage ="world";console.log(message); ```

letmessage ="world";

"world"

console.log(message);

收起深色代码主题复制letmessage ='world';console.log(message);

``` letmessage ='world';console.log(message); ```

letmessage ='world';

'world'

对象字面量属性超过4个，需要都换行

对象字面量要么每个属性都换行，要么所有属性都在同一行。当对象字面量属性超过4个的时候，建议统一换行。

收起深色代码主题复制interfaceI{name:stringage:numbervalue:numbersum:numberfoo:booleanbar:boolean}letobj:I= {name:'tom',age:16,value:1,sum:2,foo:true,bar:false}

``` interfaceI{name:stringage:numbervalue:numbersum:numberfoo:booleanbar:boolean}letobj:I= {name:'tom',age:16,value:1,sum:2,foo:true,bar:false} ```

interfaceI{

interface

I

name:string

name

age:number

value:number

value

sum:number

sum

foo:boolean

boolean

bar:boolean

letobj:I= {name:'tom',age:16,value:1,sum:2,foo:true,bar:false}

obj

'tom'

16

letobj:I= {

name:'tom',

age:16,

value:1,

sum:2,

foo:true,

bar:false

把else/catch放在if/try代码块关闭括号的同一行

在写条件语句时，建议把else放在if代码块关闭括号的同一行。同样，在写异常处理语句时，建议把catch也放在try代码块关闭括号的同一行。

收起深色代码主题复制if (isOk) {doThing1();doThing2();}else {doThing3();}

``` if (isOk) {doThing1();doThing2();}else {doThing3();} ```

if (isOk) {

doThing1();

doThing1

doThing2();

doThing2

else {

doThing3();

doThing3

收起深色代码主题复制if (isOk) {doThing1();doThing2();} else {doThing3();}

``` if (isOk) {doThing1();doThing2();} else {doThing3();} ```

} else {

收起深色代码主题复制try {doSomething();}catch (err) {// 处理错误}

``` try {doSomething();}catch (err) {// 处理错误} ```

try {

catch (err) {

// 处理错误

收起深色代码主题复制try {doSomething();} catch (err) {// 处理错误}

``` try {doSomething();} catch (err) {// 处理错误} ```

} catch (err) {

大括号{和语句在同一行

应保持一致的大括号风格。建议将大括号放在控制语句或声明语句同一行的位置。

收起深色代码主题复制functionfoo(){// ...}

``` functionfoo(){// ...} ```

functionfoo(){

建议添加类属性的可访问修饰符

在ArkTS中，提供了private, protected和public可访问修饰符。默认情况下一个属性的可访问修饰符为public。选取适当的可访问修饰符可以提升代码的安全性、可读性。注意：如果类中包含private属性，无法通过对象字面量初始化该类。

收起深色代码主题复制classC{count: number =0getCount(): number {returnthis.count}}

``` classC{count: number =0getCount(): number {returnthis.count}} ```

classC{

C

count: number =0

getCount(): number {

returnthis.count

收起深色代码主题复制classC{privatecount: number =0publicgetCount(): number {returnthis.count}}

``` classC{privatecount: number =0publicgetCount(): number {returnthis.count}} ```

privatecount: number =0

private

publicgetCount(): number {

public

不建议省略浮点数小数点前后的0

在ArkTS中，浮点值会包含一个小数点，没有要求小数点之前或之后必须有一个数字。在小数点前面和后面均添加数字可以提高代码可读性。

收起深色代码主题复制constnum =.5;constnum =2.;constnum =-.7;

``` constnum =.5;constnum =2.;constnum =-.7; ```

constnum =.5;

.5

constnum =2.;

2.

constnum =-.7;

-.7

收起深色代码主题复制constnum =0.5;constnum =2.0;constnum =-0.7;

``` constnum =0.5;constnum =2.0;constnum =-0.7; ```

constnum =0.5;

0.5

constnum =2.0;

2.0

constnum =-0.7;

-0.7

判断变量是否为Number.NaN时必须使用Number.isNaN()方法

在ArkTS中，Number.NaN是Number类型的一个特殊值。它被用来表示非数值，这里的数值是指在IEEE浮点数算术标准中定义的双精度64位格式的值。

因为在ArkTS中Number.NaN独特之处在于它不等于任何值，包括它本身，与Number.NaN进行比较的结果是令人困惑：Number.NaN !== Number.NaN or Number.NaN != Number.NaN的值都是true。

因此，必须使用Number.isNaN()函数来测试一个值是否是Number.NaN。

收起深色代码主题复制if(foo ==Number.NaN) {// ...}if(foo !=Number.NaN) {// ...}

``` if(foo ==Number.NaN) {// ...}if(foo !=Number.NaN) {// ...} ```

if(foo ==Number.NaN) {

Number

NaN

if(foo !=Number.NaN) {

收起深色代码主题复制if(Number.isNaN(foo)) {// ...}if(!Number.isNaN(foo)) {// ...}

``` if(Number.isNaN(foo)) {// ...}if(!Number.isNaN(foo)) {// ...} ```

if(Number.isNaN(foo)) {

isNaN

if(!Number.isNaN(foo)) {

数组遍历优先使用Array对象方法

对于数组的遍历处理，应该优先使用Array对象方法，如：forEach(), map(), every(), filter(), find(), findIndex(), reduce(), some()。

收起深色代码主题复制constnumbers= [1,2,3,4,5];// 依赖已有数组来创建新的数组时，通过for遍历，生成一个新数组constincreasedByOne:number[] = [];for(leti=0;i<numbers.length;i++) {increasedByOne.push(numbers[i] +1);}

``` constnumbers= [1,2,3,4,5];// 依赖已有数组来创建新的数组时，通过for遍历，生成一个新数组constincreasedByOne:number[] = [];for(leti=0;i<numbers.length;i++) {increasedByOne.push(numbers[i] +1);} ```

constnumbers= [1,2,3,4,5];

numbers

4

// 依赖已有数组来创建新的数组时，通过for遍历，生成一个新数组

constincreasedByOne:number[] = [];

increasedByOne

for(leti=0;i<numbers.length;i++) {

i

increasedByOne.push(numbers[i] +1);

push

收起深色代码主题复制constnumbers = [1,2,3,4,5];// better: 使用map方法是更好的方式constincreasedByOne:number[] = numbers.map(num=>num +1);

``` constnumbers = [1,2,3,4,5];// better: 使用map方法是更好的方式constincreasedByOne:number[] = numbers.map(num=>num +1); ```

constnumbers = [1,2,3,4,5];

// better: 使用map方法是更好的方式

constincreasedByOne:number[] = numbers.map(num=>num +1);

map

num=>

num

不要在控制性条件表达式中执行赋值操作

控制性条件表达式常用于if、while、for、?:等条件判断中。

在控制性条件表达式中执行赋值，常常导致意料之外的行为，且代码的可读性非常差。

收起深色代码主题复制// 在控制性判断中赋值不易理解if(isFoo =false) {// ...}

``` // 在控制性判断中赋值不易理解if(isFoo =false) {// ...} ```

// 在控制性判断中赋值不易理解

if(isFoo =false) {

收起深色代码主题复制constisFoo = someBoolean;// 在上面赋值，if条件判断中直接使用if(isFoo) {// ...}

``` constisFoo = someBoolean;// 在上面赋值，if条件判断中直接使用if(isFoo) {// ...} ```

constisFoo = someBoolean;// 在上面赋值，if条件判断中直接使用

// 在上面赋值，if条件判断中直接使用

if(isFoo) {

在finally代码块中，不要使用return、break、continue或抛出异常，避免finally块非正常结束

在finally代码块中，直接使用return、break、continue、throw语句，或由于调用方法的异常未处理，会导致finally代码块无法正常结束。非正常结束的finally代码块会影响try或catch代码块中异常的抛出，也可能会影响方法的返回值。所以要保证finally代码块正常结束。

收起深色代码主题复制function foo() {try{// ...return1;}catch(err) {// ...return2;}finally{return3;}}

``` function foo() {try{// ...return1;}catch(err) {// ...return2;}finally{return3;}} ```

function foo() {

try{

try

return1;

}catch(err) {

catch

return2;

}finally{

finally

return3;

收起深色代码主题复制functionfoo() {try{// ...return1;}catch(err) {// ...return2;}finally{console.log('XXX!');}}

``` functionfoo() {try{// ...return1;}catch(err) {// ...return2;}finally{console.log('XXX!');}} ```

functionfoo() {

console.log('XXX!');

'XXX!'

避免使用ESObject

ESObject主要用在ArkTS和TS/JS跨语言调用场景中的类型标注，在非跨语言调用场景中使用ESObject标注类型，会引入不必要的跨语言调用，造成额外性能开销。

收起深色代码主题复制// lib.etsexportinterfaceI{sum:number}exportfunctiongetObject(value:number):I{letobj:I= {sum:value};returnobj}// app.etsimport{getObject}from'lib'letobj:ESObject=getObject(123);

``` // lib.etsexportinterfaceI{sum:number}exportfunctiongetObject(value:number):I{letobj:I= {sum:value};returnobj}// app.etsimport{getObject}from'lib'letobj:ESObject=getObject(123); ```

// lib.ets

exportinterfaceI{

export

exportfunctiongetObject(value:number):I{

getObject

letobj:I= {sum:value};

returnobj

// app.ets

import{getObject}from'lib'

import

from

'lib'

letobj:ESObject=getObject(123);

ESObject

123

收起深色代码主题复制// lib.etsexportinterfaceI{sum:number}exportfunctiongetObject(value:number):I{letobj:I= {sum:value};returnobj}// app.etsimport{getObject,I}from'lib'letobj:I=getObject(123);

``` // lib.etsexportinterfaceI{sum:number}exportfunctiongetObject(value:number):I{letobj:I= {sum:value};returnobj}// app.etsimport{getObject,I}from'lib'letobj:I=getObject(123); ```

import{getObject,I}from'lib'

letobj:I=getObject(123);

使用T[]表示数组类型

ArkTS提供了两种数组类型的表示方式：T[]和Array<T>。为了代码的可读性，建议所有数组类型均用T[]来表示。

收起深色代码主题复制letx:Array<number> = [1,2,3];lety:Array<string> = ['a','b','c'];

``` letx:Array<number> = [1,2,3];lety:Array<string> = ['a','b','c']; ```

letx:Array<number> = [1,2,3];

x

Array

lety:Array<string> = ['a','b','c'];

y

'a'

'b'

'c'

收起深色代码主题复制// 统一使用T[]语法letx:number[] = [1,2,3];lety:string[] = ['a','b','c'];

``` // 统一使用T[]语法letx:number[] = [1,2,3];lety:string[] = ['a','b','c']; ```

// 统一使用T[]语法

letx:number[] = [1,2,3];

lety:string[] = ['a','b','c'];


==================================================
文件: harmonyos-guides_20250424_053909.txt
==================================================

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/typescript-to-arkts-migration-guide
爬取时间: 2025-04-24 05:39:09
来源: Huawei Developer

概述

本节罗列了ArkTS不支持或部分支持的TypeScript特性。完整的列表以及详细的代码示例和重构建议，请参考约束说明。更多案例请参考适配指导案例。

强制使用静态类型

静态类型是ArkTS最重要的特性之一。如果程序采用静态类型，即所有类型在编译时都是已知的，那么开发者就能够容易理解代码中使用了哪些数据结构。同时，由于所有类型在程序实际运行前都是已知的，编译器可以提前验证代码的正确性，从而可以减少运行时的类型检查，有助于提升性能。

基于上述考虑，ArkTS中禁止使用any类型。

示例

收起深色代码主题复制// 不支持：letres:any=some_api_function('hello','world');// `res`是什么？错误代码的数字？字符串？对象？// 该如何处理它？// 支持：classCallResult{publicsucceeded():boolean{ ... }publicerrorMessage():string{ ... }}letres:CallResult=some_api_function('hello','world');if(!res.succeeded()) {console.log('Call failed: '+ res.errorMessage());}

收起深色代码主题复制

收起

深色代码主题复制

深色代码主题

复制

``` // 不支持：letres:any=some_api_function('hello','world');// `res`是什么？错误代码的数字？字符串？对象？// 该如何处理它？// 支持：classCallResult{publicsucceeded():boolean{ ... }publicerrorMessage():string{ ... }}letres:CallResult=some_api_function('hello','world');if(!res.succeeded()) {console.log('Call failed: '+ res.errorMessage());} ```

// 不支持：

letres:any=some_api_function('hello','world');

let

res

any

some_api_function

'hello'

'world'

// `res`是什么？错误代码的数字？字符串？对象？

// 该如何处理它？

// 支持：

classCallResult{

class

CallResult

publicsucceeded():boolean{ ... }

public

succeeded

boolean

publicerrorMessage():string{ ... }

errorMessage

string

}

letres:CallResult=some_api_function('hello','world');

if(!res.succeeded()) {

if

console.log('Call failed: '+ res.errorMessage());

console

log

'Call failed: '

any类型在TypeScript中并不常见，只有大约1%的TypeScript代码库使用。一些代码检查工具（例如ESLint）也制定一系列规则来禁止使用any。因此，虽然禁止any将导致代码重构，但重构量很小，有助于整体性能提升。

禁止在运行时变更对象布局

为实现最佳性能，ArkTS要求在程序执行期间不能更改对象的布局。换句话说，ArkTS禁止以下行为：

向对象中添加新的属性或方法。

从对象中删除已有的属性或方法。

将任意类型的值赋值给对象属性。

TypeScript编译器已经禁止了许多此类操作。然而，有些操作还是有可能绕过编译器的，例如，使用as any转换对象的类型，或者在编译TS代码时关闭严格类型检查的配置，或者在代码中通过@ts-ignore忽略类型检查。

在ArkTS中，严格类型检查不是可配置项。ArkTS强制进行部分严格类型检查，并通过规范禁止使用any类型，禁止在代码中使用@ts-ignore。

收起深色代码主题复制classPoint{publicx:number=0publicy:number=0constructor(x:number, y:number) {this.x= x;this.y= y;}}// 无法从对象中删除某个属性，从而确保所有Point对象都具有属性xletp1 =newPoint(1.0,1.0);deletep1.x;// 在TypeScript和ArkTS中，都会产生编译时错误delete(p1asany).x;// 在TypeScript中不会报错；在ArkTS中会产生编译时错误// Point类没有定义命名为z的属性，在程序运行时也无法添加该属性letp2 =newPoint(2.0,2.0);p2.z='Label';// 在TypeScript和ArkTS中，都会产生编译时错误(p2asany).z='Label';// 在TypeScript中不会报错；在ArkTS中会产生编译时错误// 类的定义确保了所有Point对象只有属性x和y，并且无法被添加其他属性letp3 =newPoint(3.0,3.0);letprop =Symbol();// 在TypeScript中不会报错；在ArkTS中会产生编译时错误(p3asany)[prop] = p3.x;// 在TypeScript中不会报错；在ArkTS中会产生编译时错误p3[prop] = p3.x;// 在TypeScript和ArkTS中，都会产生编译时错误// 类的定义确保了所有Point对象的属性x和y都具有number类型，因此，无法将其他类型的值赋值给它们letp4 =newPoint(4.0,4.0);p4.x='Hello!';// 在TypeScript和ArkTS中，都会产生编译时错误(p4asany).x='Hello!';// 在TypeScript中不会报错；在ArkTS中会产生编译时错误// 使用符合类定义的Point对象：functiondistance(p1: Point, p2: Point):number{returnMath.sqrt((p2.x- p1.x) * (p2.x- p1.x) + (p2.y- p1.y) * (p2.y- p1.y));}letp5 =newPoint(5.0,5.0);letp6 =newPoint(6.0,6.0);console.log('Distance between p5 and p6: '+distance(p5, p6));

``` classPoint{publicx:number=0publicy:number=0constructor(x:number, y:number) {this.x= x;this.y= y;}}// 无法从对象中删除某个属性，从而确保所有Point对象都具有属性xletp1 =newPoint(1.0,1.0);deletep1.x;// 在TypeScript和ArkTS中，都会产生编译时错误delete(p1asany).x;// 在TypeScript中不会报错；在ArkTS中会产生编译时错误// Point类没有定义命名为z的属性，在程序运行时也无法添加该属性letp2 =newPoint(2.0,2.0);p2.z='Label';// 在TypeScript和ArkTS中，都会产生编译时错误(p2asany).z='Label';// 在TypeScript中不会报错；在ArkTS中会产生编译时错误// 类的定义确保了所有Point对象只有属性x和y，并且无法被添加其他属性letp3 =newPoint(3.0,3.0);letprop =Symbol();// 在TypeScript中不会报错；在ArkTS中会产生编译时错误(p3asany)[prop] = p3.x;// 在TypeScript中不会报错；在ArkTS中会产生编译时错误p3[prop] = p3.x;// 在TypeScript和ArkTS中，都会产生编译时错误// 类的定义确保了所有Point对象的属性x和y都具有number类型，因此，无法将其他类型的值赋值给它们letp4 =newPoint(4.0,4.0);p4.x='Hello!';// 在TypeScript和ArkTS中，都会产生编译时错误(p4asany).x='Hello!';// 在TypeScript中不会报错；在ArkTS中会产生编译时错误// 使用符合类定义的Point对象：functiondistance(p1: Point, p2: Point):number{returnMath.sqrt((p2.x- p1.x) * (p2.x- p1.x) + (p2.y- p1.y) * (p2.y- p1.y));}letp5 =newPoint(5.0,5.0);letp6 =newPoint(6.0,6.0);console.log('Distance between p5 and p6: '+distance(p5, p6)); ```

classPoint{

Point

publicx:number=0

x

number

0

publicy:number=0

y

constructor(x:number, y:number) {

constructor

x:number, y:number

this.x= x;

this

this.y= y;

// 无法从对象中删除某个属性，从而确保所有Point对象都具有属性x

letp1 =newPoint(1.0,1.0);

new

1.0

deletep1.x;// 在TypeScript和ArkTS中，都会产生编译时错误

delete

// 在TypeScript和ArkTS中，都会产生编译时错误

delete(p1asany).x;// 在TypeScript中不会报错；在ArkTS中会产生编译时错误

as

// 在TypeScript中不会报错；在ArkTS中会产生编译时错误

// Point类没有定义命名为z的属性，在程序运行时也无法添加该属性

letp2 =newPoint(2.0,2.0);

2.0

p2.z='Label';// 在TypeScript和ArkTS中，都会产生编译时错误

z

'Label'

(p2asany).z='Label';// 在TypeScript中不会报错；在ArkTS中会产生编译时错误

// 类的定义确保了所有Point对象只有属性x和y，并且无法被添加其他属性

letp3 =newPoint(3.0,3.0);

3.0

letprop =Symbol();// 在TypeScript中不会报错；在ArkTS中会产生编译时错误

Symbol

(p3asany)[prop] = p3.x;// 在TypeScript中不会报错；在ArkTS中会产生编译时错误

p3[prop] = p3.x;// 在TypeScript和ArkTS中，都会产生编译时错误

// 类的定义确保了所有Point对象的属性x和y都具有number类型，因此，无法将其他类型的值赋值给它们

letp4 =newPoint(4.0,4.0);

4.0

p4.x='Hello!';// 在TypeScript和ArkTS中，都会产生编译时错误

'Hello!'

(p4asany).x='Hello!';// 在TypeScript中不会报错；在ArkTS中会产生编译时错误

// 使用符合类定义的Point对象：

functiondistance(p1: Point, p2: Point):number{

function

distance

p1: Point, p2: Point

returnMath.sqrt(

return

Math

sqrt

(p2.x- p1.x) * (p2.x- p1.x) + (p2.y- p1.y) * (p2.y- p1.y)

);

letp5 =newPoint(5.0,5.0);

5.0

letp6 =newPoint(6.0,6.0);

6.0

console.log('Distance between p5 and p6: '+distance(p5, p6));

'Distance between p5 and p6: '

修改对象布局会影响代码的可读性以及运行时性能。从开发者的角度来说，在某处定义类，然后又在其他地方修改实际的对象布局，很容易引起困惑乃至引入错误。此外，这点还需要额外的运行时支持，增加了执行开销。这一点与静态类型的约束也冲突：既然已决定使用显式类型，为什么还需要添加或删除属性呢？

当前，只有少数项目允许在运行时变更对象布局，一些常用的代码检查工具也增加了相应的限制规则。这个约束只会导致少量代码重构，但会提升性能。

限制运算符的语义

为获得更好的性能并鼓励开发者编写更清晰的代码，ArkTS限制了一些运算符的语义。详细的语义限制，请参考约束说明。

收起深色代码主题复制// 一元运算符`+`只能作用于数值类型：lett = +42;// 合法运算lets = +'42';// 编译时错误

``` // 一元运算符`+`只能作用于数值类型：lett = +42;// 合法运算lets = +'42';// 编译时错误 ```

// 一元运算符`+`只能作用于数值类型：

lett = +42;// 合法运算

42

// 合法运算

lets = +'42';// 编译时错误

'42'

// 编译时错误

使用额外的语义重载语言运算符会增加语言规范的复杂度，而且，开发者还被迫牢记所有可能的例外情况及对应的处理规则。在某些情况下，产生一些不必要的运行时开销。

当前只有不到1%的代码库使用该特性。因此，尽管限制运算符的语义需要重构代码，但重构量很小且非常容易操作，并且，通过重构能使代码更清晰、具备更高性能。

不支持 structural typing

假设两个不相关的类T和U拥有相同的publicAPI：

收起深色代码主题复制classT{publicname:string=''publicgreet():void{console.log('Hello, '+this.name);}}classU{publicname:string=''publicgreet():void{console.log('Greetings, '+this.name);}}

``` classT{publicname:string=''publicgreet():void{console.log('Hello, '+this.name);}}classU{publicname:string=''publicgreet():void{console.log('Greetings, '+this.name);}} ```

classT{

T

publicname:string=''

name

''

publicgreet():void{

greet

void

console.log('Hello, '+this.name);

'Hello, '

classU{

U

console.log('Greetings, '+this.name);

'Greetings, '

能把类型为T的值赋给类型为U的变量吗？

收起深色代码主题复制letu: U =newT();// 是否允许？

``` letu: U =newT();// 是否允许？ ```

letu: U =newT();// 是否允许？

u

// 是否允许？

能把类型为T的值传递给接受类型为U的参数的函数吗？

收起深色代码主题复制functiongreeter(u: U) {console.log('To '+ u.name);u.greet();}lett: T =newT();greeter(t);// 是否允许？

``` functiongreeter(u: U) {console.log('To '+ u.name);u.greet();}lett: T =newT();greeter(t);// 是否允许？ ```

functiongreeter(u: U) {

greeter

u: U

console.log('To '+ u.name);

'To '

u.greet();

lett: T =newT();

t

greeter(t);// 是否允许？

换句话说，我们将采取下面哪种方法呢：

T和U没有继承关系或没有implements相同的接口，但由于它们具有相同的publicAPI，它们“在某种程度上是相等的”，所以上述两个问题的答案都是“是”；

T和U没有继承关系或没有implements相同的接口，应当始终被视为完全不同的类型，因此上述两个问题的答案都是“否”。

采用第一种方法的语言支持structural typing，而采用第二种方法的语言则不支持structural typing。目前TypeScript支持structural typing，而ArkTS不支持。

structural typing是否有助于生成清晰、易理解的代码，关于这一点并没有定论。那为什么ArkTS不支持structural typing呢？

因为对structural typing的支持是一个重大的特性，需要在语言规范、编译器和运行时进行大量的考虑和仔细的实现。另外，由于ArkTS使用静态类型，运行时为了支持这个特性需要额外的性能开销。

鉴于此，当前我们还不支持该特性。根据实际场景的需求和反馈，我们后续会重新加以考虑。更多案例和建议请参考约束说明。

约束说明

对象的属性名必须是合法的标识符

规则：arkts-identifiers-as-prop-names

级别：错误

在ArkTS中，对象的属性名不能为数字或字符串。例外：ArkTS支持属性名为字符串字面量和枚举中的字符串值。通过属性名访问类的属性，通过数值索引访问数组元素。

TypeScript

收起深色代码主题复制varx = {'name':'x',2:'3'};console.log(x['name']);console.log(x[2]);

``` varx = {'name':'x',2:'3'};console.log(x['name']);console.log(x[2]); ```

varx = {'name':'x',2:'3'};

var

'name'

'x'

2

'3'

console.log(x['name']);

console.log(x[2]);

ArkTS

收起深色代码主题复制classX{publicname:string=''}letx: X = {name:'x'};console.log(x.name);lety = ['a','b','c'];console.log(y[2]);// 在需要通过非标识符（即不同类型的key）获取数据的场景中，使用Map<Object, some_type>。letz =newMap<Object,string>();z.set('name','1');z.set(2,'2');console.log(z.get('name'));console.log(z.get(2));enumTest{A ='aaa',B ='bbb'}letobj:Record<string,number> = {[Test.A]:1,// 枚举中的字符串值[Test.B]:2,// 枚举中的字符串值['value']:3// 字符串字面量}

``` classX{publicname:string=''}letx: X = {name:'x'};console.log(x.name);lety = ['a','b','c'];console.log(y[2]);// 在需要通过非标识符（即不同类型的key）获取数据的场景中，使用Map<Object, some_type>。letz =newMap<Object,string>();z.set('name','1');z.set(2,'2');console.log(z.get('name'));console.log(z.get(2));enumTest{A ='aaa',B ='bbb'}letobj:Record<string,number> = {[Test.A]:1,// 枚举中的字符串值[Test.B]:2,// 枚举中的字符串值['value']:3// 字符串字面量} ```

classX{

X

letx: X = {name:'x'};

console.log(x.name);

lety = ['a','b','c'];

'a'

'b'

'c'

console.log(y[2]);

// 在需要通过非标识符（即不同类型的key）获取数据的场景中，使用Map<Object, some_type>。

letz =newMap<Object,string>();

Map

Object

z.set('name','1');

set

'1'

z.set(2,'2');

'2'

console.log(z.get('name'));

get

console.log(z.get(2));

enumTest{

enum

Test

A ='aaa',

'aaa'

B ='bbb'

'bbb'

letobj:Record<string,number> = {

obj

Record

[Test.A]:1,// 枚举中的字符串值

A

1

// 枚举中的字符串值

[Test.B]:2,// 枚举中的字符串值

B

['value']:3// 字符串字面量

'value'

3

// 字符串字面量

不支持Symbol()API

规则：arkts-no-symbol

TypeScript中的Symbol()API用于在运行时生成唯一的属性名称。由于该API的常见使用场景在静态类型语言中没有意义，因此，ArkTS不支持Symbol()API。在ArkTS中，对象布局在编译时就确定了，且不能在运行时被更改。

ArkTS只支持Symbol.iterator。

不支持以#开头的私有字段

规则：arkts-no-private-identifiers

ArkTS不支持使用#符号开头声明的私有字段。改用private关键字。

收起深色代码主题复制classC{#foo:number=42}

``` classC{#foo:number=42} ```

classC{

C

#foo:number=42

foo

收起深色代码主题复制classC{privatefoo:number=42}

``` classC{privatefoo:number=42} ```

privatefoo:number=42

private

类型、命名空间的命名必须唯一

规则：arkts-unique-names

类型（类、接口、枚举）、命名空间的命名必须唯一，且与其他名称（例如：变量名、函数名）不同。

收起深色代码主题复制letX:stringtypeX =number[]// 类型的别名与变量同名

``` letX:stringtypeX =number[]// 类型的别名与变量同名 ```

letX:string

typeX =number[]// 类型的别名与变量同名

type

// 类型的别名与变量同名

收起深色代码主题复制letX:stringtypeT =number[]// 为避免名称冲突，此处不允许使用X

``` letX:stringtypeT =number[]// 为避免名称冲突，此处不允许使用X ```

typeT =number[]// 为避免名称冲突，此处不允许使用X

// 为避免名称冲突，此处不允许使用X

使用let而非var

规则：arkts-no-var

let关键字可以在块级作用域中声明变量，帮助程序员避免错误。因此，ArkTS不支持var，请使用let声明变量。

收起深色代码主题复制functionf(shouldInitialize:boolean) {if(shouldInitialize) {varx ='b';}returnx;}console.log(f(true));// bconsole.log(f(false));// undefinedletupperLet =0;{varscopedVar =0;letscopedLet =0;upperLet =5;}scopedVar =5;// 可见scopedLet =5;// 编译时错误

``` functionf(shouldInitialize:boolean) {if(shouldInitialize) {varx ='b';}returnx;}console.log(f(true));// bconsole.log(f(false));// undefinedletupperLet =0;{varscopedVar =0;letscopedLet =0;upperLet =5;}scopedVar =5;// 可见scopedLet =5;// 编译时错误 ```

functionf(shouldInitialize:boolean) {

f

shouldInitialize:boolean

if(shouldInitialize) {

varx ='b';

returnx;

console.log(f(true));// b

true

// b

console.log(f(false));// undefined

false

// undefined

letupperLet =0;

{

varscopedVar =0;

letscopedLet =0;

upperLet =5;

5

scopedVar =5;// 可见

// 可见

scopedLet =5;// 编译时错误

收起深色代码主题复制functionf(shouldInitialize:boolean):string{letx:string='a';if(shouldInitialize) {x ='b';}returnx;}console.log(f(true));// bconsole.log(f(false));// aletupperLet =0;letscopedVar =0;{letscopedLet =0;upperLet =5;}scopedVar =5;scopedLet =5;//编译时错误

``` functionf(shouldInitialize:boolean):string{letx:string='a';if(shouldInitialize) {x ='b';}returnx;}console.log(f(true));// bconsole.log(f(false));// aletupperLet =0;letscopedVar =0;{letscopedLet =0;upperLet =5;}scopedVar =5;scopedLet =5;//编译时错误 ```

functionf(shouldInitialize:boolean):string{

letx:string='a';

x ='b';

console.log(f(false));// a

// a

letscopedVar =0;

scopedVar =5;

scopedLet =5;//编译时错误

//编译时错误

使用具体的类型而非any或unknown

规则：arkts-no-any-unknown

ArkTS不支持any和unknown类型。显式指定具体类型。

收起深色代码主题复制letvalue1:anyvalue1 =true;value1 =42;letvalue2:unknownvalue2 =true;value2 =42;

``` letvalue1:anyvalue1 =true;value1 =42;letvalue2:unknownvalue2 =true;value2 =42; ```

letvalue1:any

value1

value1 =true;

value1 =42;

letvalue2:unknown

value2

unknown

value2 =true;

value2 =42;

收起深色代码主题复制letvalue_b:boolean=true;// 或者 let value_b = trueletvalue_n:number=42;// 或者 let value_n = 42letvalue_o1:Object=true;letvalue_o2:Object=42;

``` letvalue_b:boolean=true;// 或者 let value_b = trueletvalue_n:number=42;// 或者 let value_n = 42letvalue_o1:Object=true;letvalue_o2:Object=42; ```

letvalue_b:boolean=true;// 或者 let value_b = true

value_b

// 或者 let value_b = true

letvalue_n:number=42;// 或者 let value_n = 42

value_n

// 或者 let value_n = 42

letvalue_o1:Object=true;

value_o1

letvalue_o2:Object=42;

value_o2

使用class而非具有call signature的类型

规则：arkts-no-call-signatures

ArkTS不支持对象类型中包含call signature。

收起深色代码主题复制typeDescribableFunction= {description:string(someArg:string):string// call signature}functiondoSomething(fn: DescribableFunction):void{console.log(fn.description+' returned '+fn(''));}

``` typeDescribableFunction= {description:string(someArg:string):string// call signature}functiondoSomething(fn: DescribableFunction):void{console.log(fn.description+' returned '+fn(''));} ```

typeDescribableFunction= {

DescribableFunction

description:string

description

(someArg:string):string// call signature

someArg

// call signature

functiondoSomething(fn: DescribableFunction):void{

doSomething

fn: DescribableFunction

console.log(fn.description+' returned '+fn(''));

' returned '

fn

收起深色代码主题复制classDescribableFunction{description:stringpublicinvoke(someArg:string):string{returnsomeArg;}constructor() {this.description='desc';}}functiondoSomething(fn: DescribableFunction):void{console.log(fn.description+' returned '+ fn.invoke(''));}doSomething(newDescribableFunction());

``` classDescribableFunction{description:stringpublicinvoke(someArg:string):string{returnsomeArg;}constructor() {this.description='desc';}}functiondoSomething(fn: DescribableFunction):void{console.log(fn.description+' returned '+ fn.invoke(''));}doSomething(newDescribableFunction()); ```

classDescribableFunction{

publicinvoke(someArg:string):string{

invoke

returnsomeArg;

constructor() {

this.description='desc';

'desc'

console.log(fn.description+' returned '+ fn.invoke(''));

doSomething(newDescribableFunction());

使用class而非具有构造签名的类型

规则：arkts-no-ctor-signatures-type

ArkTS不支持对象类型中的构造签名。改用类。

收起深色代码主题复制classSomeObject{}typeSomeConstructor= {new(s:string):SomeObject}functionfn(ctor: SomeConstructor) {returnnewctor('hello');}

``` classSomeObject{}typeSomeConstructor= {new(s:string):SomeObject}functionfn(ctor: SomeConstructor) {returnnewctor('hello');} ```

classSomeObject{}

SomeObject

typeSomeConstructor= {

SomeConstructor

new(s:string):SomeObject

s

functionfn(ctor: SomeConstructor) {

ctor: SomeConstructor

returnnewctor('hello');

ctor

收起深色代码主题复制classSomeObject{publicf:stringconstructor(s:string) {this.f= s;}}functionfn(s:string):SomeObject{returnnewSomeObject(s);}

``` classSomeObject{publicf:stringconstructor(s:string) {this.f= s;}}functionfn(s:string):SomeObject{returnnewSomeObject(s);} ```

classSomeObject{

publicf:string

constructor(s:string) {

this.f= s;

functionfn(s:string):SomeObject{

s:string

returnnewSomeObject(s);

仅支持一个静态块

规则：arkts-no-multiple-static-blocks

ArkTS不允许类中有多个静态块，如果存在多个静态块语句，请合并到一个静态块中。

收起深色代码主题复制classC{statics:stringstatic{C.s='aa'}static{C.s= C.s+'bb'}}

``` classC{statics:stringstatic{C.s='aa'}static{C.s= C.s+'bb'}} ```

statics:string

static

static{

C.s='aa'

'aa'

C.s= C.s+'bb'

'bb'

收起深色代码主题复制classC{statics:stringstatic{C.s='aa'C.s= C.s+'bb'}}

``` classC{statics:stringstatic{C.s='aa'C.s= C.s+'bb'}} ```

说明

当前不支持静态块的语法。支持该语法后，在.ets文件中使用静态块须遵循本约束。

不支持index signature

规则：arkts-no-indexed-signatures

ArkTS不允许index signature，改用数组。

收起深色代码主题复制// 带index signature的接口：interfaceStringArray{[index:number]:string}functiongetStringArray():StringArray{return['a','b','c'];}constmyArray:StringArray=getStringArray();constsecondItem = myArray[1];

``` // 带index signature的接口：interfaceStringArray{[index:number]:string}functiongetStringArray():StringArray{return['a','b','c'];}constmyArray:StringArray=getStringArray();constsecondItem = myArray[1]; ```

// 带index signature的接口：

interfaceStringArray{

interface

StringArray

[index:number]:string

index

functiongetStringArray():StringArray{

getStringArray

return['a','b','c'];

constmyArray:StringArray=getStringArray();

const

myArray

constsecondItem = myArray[1];

收起深色代码主题复制classX{publicf:string[] = []}letmyArray: X =newX();constsecondItem = myArray.f[1];

``` classX{publicf:string[] = []}letmyArray: X =newX();constsecondItem = myArray.f[1]; ```

publicf:string[] = []

letmyArray: X =newX();

constsecondItem = myArray.f[1];

使用继承而非intersection type

规则：arkts-no-intersection-types

目前ArkTS不支持intersection type，可以使用继承作为替代方案。

收起深色代码主题复制interfaceIdentity{id:numbername:string}interfaceContact{email:stringphoneNumber:string}typeEmployee=Identity&Contact

``` interfaceIdentity{id:numbername:string}interfaceContact{email:stringphoneNumber:string}typeEmployee=Identity&Contact ```

interfaceIdentity{

Identity

id:number

id

name:string

interfaceContact{

Contact

email:string

email

phoneNumber:string

phoneNumber

typeEmployee=Identity&Contact

Employee

收起深色代码主题复制interfaceIdentity{id:numbername:string}interfaceContact{email:stringphoneNumber:string}interfaceEmployeeextendsIdentity,Contact{}

``` interfaceIdentity{id:numbername:string}interfaceContact{email:stringphoneNumber:string}interfaceEmployeeextendsIdentity,Contact{} ```

interfaceEmployeeextendsIdentity,Contact{}

extends

不支持this类型

规则：arkts-no-typing-with-this

ArkTS不支持this类型，改用显式具体类型。

收起深色代码主题复制interfaceListItem{getHead():this}classC{n:number=0m(c:this) {// ...}}

``` interfaceListItem{getHead():this}classC{n:number=0m(c:this) {// ...}} ```

interfaceListItem{

ListItem

getHead():this

getHead

n:number=0

n

m(c:this) {

m

c:this

// ...

收起深色代码主题复制interfaceListItem{getHead():ListItem}classC{n:number=0m(c: C) {// ...}}

``` interfaceListItem{getHead():ListItem}classC{n:number=0m(c: C) {// ...}} ```

getHead():ListItem

m(c: C) {

c: C

不支持条件类型

规则：arkts-no-conditional-types

ArkTS不支持条件类型别名，引入带显式约束的新类型，或使用Object重写逻辑。

不支持infer关键字。

收起深色代码主题复制typeX<T> = Textendsnumber?T:nevertypeY<T> = TextendsArray<inferItem> ?Item:never

``` typeX<T> = Textendsnumber?T:nevertypeY<T> = TextendsArray<inferItem> ?Item:never ```

typeX<T> = Textendsnumber?T:never

never

typeY<T> = TextendsArray<inferItem> ?Item:never

Array

Item

收起深色代码主题复制// 在类型别名中提供显式约束typeX1<Textendsnumber> = T// 用Object重写，类型控制较少，需要更多的类型检查以确保安全typeX2<T> =Object// Item必须作为泛型参数使用，并能正确实例化typeYI<Item, TextendsArray<Item>> =Item

``` // 在类型别名中提供显式约束typeX1<Textendsnumber> = T// 用Object重写，类型控制较少，需要更多的类型检查以确保安全typeX2<T> =Object// Item必须作为泛型参数使用，并能正确实例化typeYI<Item, TextendsArray<Item>> =Item ```

// 在类型别名中提供显式约束

typeX1<Textendsnumber> = T

X1

// 用Object重写，类型控制较少，需要更多的类型检查以确保安全

typeX2<T> =Object

X2

// Item必须作为泛型参数使用，并能正确实例化

typeYI<Item, TextendsArray<Item>> =Item

YI

不支持在constructor中声明字段

规则：arkts-no-ctor-prop-decls

ArkTS不支持在constructor中声明类字段。在class中声明这些字段。

收起深色代码主题复制classPerson{constructor(protectedssn:string,privatefirstName:string,privatelastName:string) {this.ssn= ssn;this.firstName= firstName;this.lastName= lastName;}getFullName():string{returnthis.firstName+' '+this.lastName;}}

``` classPerson{constructor(protectedssn:string,privatefirstName:string,privatelastName:string) {this.ssn= ssn;this.firstName= firstName;this.lastName= lastName;}getFullName():string{returnthis.firstName+' '+this.lastName;}} ```

classPerson{

Person

constructor(

protectedssn:string,

protected

privatefirstName:string,

privatelastName:string

) {

this.ssn= ssn;

ssn

this.firstName= firstName;

firstName

this.lastName= lastName;

lastName

getFullName():string{

getFullName

returnthis.firstName+' '+this.lastName;

' '

收起深色代码主题复制classPerson{protectedssn:stringprivatefirstName:stringprivatelastName:stringconstructor(ssn:string, firstName:string, lastName:string) {this.ssn= ssn;this.firstName= firstName;this.lastName= lastName;}getFullName():string{returnthis.firstName+' '+this.lastName;}}

``` classPerson{protectedssn:stringprivatefirstName:stringprivatelastName:stringconstructor(ssn:string, firstName:string, lastName:string) {this.ssn= ssn;this.firstName= firstName;this.lastName= lastName;}getFullName():string{returnthis.firstName+' '+this.lastName;}} ```

protectedssn:string

privatefirstName:string

constructor(ssn:string, firstName:string, lastName:string) {

ssn:string, firstName:string, lastName:string

接口中不支持构造签名

规则：arkts-no-ctor-signatures-iface

ArkTS不支持在接口中使用构造签名。改用函数或者方法。

收起深色代码主题复制interfaceI {new(s:string): I}functionfn(i: I) {returnnewi('hello');}

``` interfaceI {new(s:string): I}functionfn(i: I) {returnnewi('hello');} ```

interfaceI {

new(s:string): I

functionfn(i: I) {

i: I

returnnewi('hello');

i

收起深色代码主题复制interfaceI {create(s:string): I}functionfn(i: I) {returni.create('hello');}

``` interfaceI {create(s:string): I}functionfn(i: I) {returni.create('hello');} ```

create(s:string): I

create

returni.create('hello');

不支持索引访问类型

规则：arkts-no-aliases-by-index

ArkTS不支持索引访问类型。

不支持通过索引访问字段

规则：arkts-no-props-by-index

ArkTS不支持动态声明字段，不支持动态访问字段。只能访问已在类中声明或者继承可见的字段，访问其他字段将会造成编译时错误。

使用点操作符访问字段，例如（obj.field），不支持索引访问（obj[field]）。

ArkTS支持通过索引访问TypedArray（例如Int32Array）中的元素。

收起深色代码主题复制classPoint{x:string=''y:string=''}letp:Point= {x:'1',y:'2'};console.log(p['x']);classPerson{name:string=''age:number=0;[key:string]:string|number}letperson:Person= {name:'John',age:30,email:'***@example.com',phoneNumber:'18*********',}

``` classPoint{x:string=''y:string=''}letp:Point= {x:'1',y:'2'};console.log(p['x']);classPerson{name:string=''age:number=0;[key:string]:string|number}letperson:Person= {name:'John',age:30,email:'***@example.com',phoneNumber:'18*********',} ```

x:string=''

y:string=''

letp:Point= {x:'1',y:'2'};

p

console.log(p['x']);

name:string=''

age:number=0;

age

[key:string]:string|number

key

letperson:Person= {

person

name:'John',

'John'

age:30,

30

email:'***@example.com',

'***@example.com'

phoneNumber:'18*********',

'18*********'

收起深色代码主题复制classPoint{x:string=''y:string=''}letp:Point= {x:'1',y:'2'};console.log(p.x);classPerson{name:stringage:numberemail:stringphoneNumber:stringconstructor(name:string, age:number, email:string,phoneNumber:string) {this.name= name;this.age= age;this.email= email;this.phoneNumber= phoneNumber;}}letperson =newPerson('John',30,'***@example.com','18*********');console.log(person['name']);// 编译时错误console.log(person.unknownProperty);// 编译时错误letarr =newInt32Array(1);arr[0];

``` classPoint{x:string=''y:string=''}letp:Point= {x:'1',y:'2'};console.log(p.x);classPerson{name:stringage:numberemail:stringphoneNumber:stringconstructor(name:string, age:number, email:string,phoneNumber:string) {this.name= name;this.age= age;this.email= email;this.phoneNumber= phoneNumber;}}letperson =newPerson('John',30,'***@example.com','18*********');console.log(person['name']);// 编译时错误console.log(person.unknownProperty);// 编译时错误letarr =newInt32Array(1);arr[0]; ```

console.log(p.x);

age:number

constructor(name:string, age:number, email:string,

name:string, age:number, email:string,

phoneNumber:string) {

this.name= name;

this.age= age;

this.email= email;

this.phoneNumber= phoneNumber;

letperson =newPerson('John',30,'***@example.com','18*********');

console.log(person['name']);// 编译时错误

console.log(person.unknownProperty);// 编译时错误

unknownProperty

letarr =newInt32Array(1);

Int32Array

arr[0];

不支持structural typing

规则：arkts-no-structural-typing

ArkTS不支持structural typing，编译器无法比较两种类型的publicAPI并决定它们是否相同。使用其他机制，例如继承、接口或类型别名。

收起深色代码主题复制interfaceI1 {f():string}interfaceI2 {// I2等价于I1f():string}classX{n:number=0s:string=''}classY{// Y等价于Xn:number=0s:string=''}letx =newX();lety =newY();console.log('Assign X to Y');y = x;console.log('Assign Y to X');x = y;functionfoo(x: X) {console.log(x.n+ x.s);}// 由于X和Y的API是等价的，所以X和Y是等价的foo(newX());foo(newY());

``` interfaceI1 {f():string}interfaceI2 {// I2等价于I1f():string}classX{n:number=0s:string=''}classY{// Y等价于Xn:number=0s:string=''}letx =newX();lety =newY();console.log('Assign X to Y');y = x;console.log('Assign Y to X');x = y;functionfoo(x: X) {console.log(x.n+ x.s);}// 由于X和Y的API是等价的，所以X和Y是等价的foo(newX());foo(newY()); ```

interfaceI1 {

f():string

interfaceI2 {// I2等价于I1

// I2等价于I1

s:string=''

classY{// Y等价于X

Y

// Y等价于X

letx =newX();

lety =newY();

console.log('Assign X to Y');

'Assign X to Y'

y = x;

console.log('Assign Y to X');

'Assign Y to X'

x = y;

functionfoo(x: X) {

x: X

console.log(x.n+ x.s);

// 由于X和Y的API是等价的，所以X和Y是等价的

foo(newX());

foo(newY());

收起深色代码主题复制interfaceI1 {f():string}typeI2=I1// I2是I1的别名classB{n:number=0s:string=''}// D是B的继承类，构建了子类型和父类型的关系classDextendsB{constructor() {super()}}letb =newB();letd =newD();console.log('Assign D to B');b = d;// 合法赋值，因为B是D的父类// 将b赋值给d将会引起编译时错误// d = binterfaceZ {n:numbers:string}// 类X implements 接口Z，构建了X和Y的关系classXimplementsZ {n:number=0s:string=''}// 类Y implements 接口Z，构建了X和Y的关系classYimplementsZ {n:number=0s:string=''}letx: Z =newX();lety: Z =newY();console.log('Assign X to Y');y = x// 合法赋值，它们是相同的类型console.log('Assign Y to X');x = y// 合法赋值，它们是相同的类型functionfoo(c: Z):void{console.log(c.n+ c.s);}// 类X和类Y implement 相同的接口，因此下面的两个函数调用都是合法的foo(newX());foo(newY());

``` interfaceI1 {f():string}typeI2=I1// I2是I1的别名classB{n:number=0s:string=''}// D是B的继承类，构建了子类型和父类型的关系classDextendsB{constructor() {super()}}letb =newB();letd =newD();console.log('Assign D to B');b = d;// 合法赋值，因为B是D的父类// 将b赋值给d将会引起编译时错误// d = binterfaceZ {n:numbers:string}// 类X implements 接口Z，构建了X和Y的关系classXimplementsZ {n:number=0s:string=''}// 类Y implements 接口Z，构建了X和Y的关系classYimplementsZ {n:number=0s:string=''}letx: Z =newX();lety: Z =newY();console.log('Assign X to Y');y = x// 合法赋值，它们是相同的类型console.log('Assign Y to X');x = y// 合法赋值，它们是相同的类型functionfoo(c: Z):void{console.log(c.n+ c.s);}// 类X和类Y implement 相同的接口，因此下面的两个函数调用都是合法的foo(newX());foo(newY()); ```

typeI2=I1// I2是I1的别名

I2

I1

// I2是I1的别名

classB{

// D是B的继承类，构建了子类型和父类型的关系

classDextendsB{

D

super()

super

letb =newB();

letd =newD();

console.log('Assign D to B');

'Assign D to B'

b = d;// 合法赋值，因为B是D的父类

// 合法赋值，因为B是D的父类

// 将b赋值给d将会引起编译时错误

// d = b

interfaceZ {

n:number

// 类X implements 接口Z，构建了X和Y的关系

classXimplementsZ {

implements

// 类Y implements 接口Z，构建了X和Y的关系

classYimplementsZ {

letx: Z =newX();

lety: Z =newY();

y = x// 合法赋值，它们是相同的类型

// 合法赋值，它们是相同的类型

x = y// 合法赋值，它们是相同的类型

functionfoo(c: Z):void{

c: Z

console.log(c.n+ c.s);

// 类X和类Y implement 相同的接口，因此下面的两个函数调用都是合法的

需要显式标注泛型函数类型实参

规则：arkts-no-inferred-generic-params

如果可以从传递给泛型函数的参数中推断出具体类型，ArkTS允许省略泛型类型实参。否则，省略泛型类型实参会发生编译时错误。

禁止仅基于泛型函数返回类型推断泛型类型参数。

收起深色代码主题复制functionchoose<T>(x: T,y: T): T {returnMath.random() <0.5?x: y;}letx =choose(10,20);// 推断choose<number>(...)lety =choose('10',20);// 编译时错误functiongreet<T>(): T {return'Hello'asT;}letz =greet()// T的类型被推断为“unknown”

``` functionchoose<T>(x: T,y: T): T {returnMath.random() <0.5?x: y;}letx =choose(10,20);// 推断choose<number>(...)lety =choose('10',20);// 编译时错误functiongreet<T>(): T {return'Hello'asT;}letz =greet()// T的类型被推断为“unknown” ```

functionchoose<T>(x: T,y: T): T {

returnMath.random() <0.5?x: y;

random

0.5

letx =choose(10,20);// 推断choose<number>(...)

choose

10

20

// 推断choose<number>(...)

lety =choose('10',20);// 编译时错误

'10'

functiongreet<T>(): T {

return'Hello'asT;

'Hello'

letz =greet()// T的类型被推断为“unknown”

// T的类型被推断为“unknown”

收起深色代码主题复制functionchoose<T>(x: T,y: T): T {returnMath.random() <0.5?x: y;}letx =choose(10,20);// 推断choose<number>(...)lety =choose('10',20);// 编译时错误functiongreet<T>(): T {return'Hello'asT;}letz = greet<string>();

``` functionchoose<T>(x: T,y: T): T {returnMath.random() <0.5?x: y;}letx =choose(10,20);// 推断choose<number>(...)lety =choose('10',20);// 编译时错误functiongreet<T>(): T {return'Hello'asT;}letz = greet<string>(); ```

letz = greet<string>();

需要显式标注对象字面量的类型

规则：arkts-no-untyped-obj-literals

在ArkTS中，需要显式标注对象字面量的类型，否则，将发生编译时错误。在某些场景下，编译器可以根据上下文推断出字面量的类型。

在以下上下文中不支持使用字面量初始化类和接口：

初始化具有any、Object或object类型的任何对象

初始化带有方法的类或接口

初始化包含自定义含参数的构造函数的类

初始化带readonly字段的类

例子1

收起深色代码主题复制leto1 = {n:42,s:'foo'};leto2:Object= {n:42,s:'foo'};leto3:object= {n:42,s:'foo'};letoo:Object[] = [{n:1,s:'1'}, {n:2,s:'2'}];

``` leto1 = {n:42,s:'foo'};leto2:Object= {n:42,s:'foo'};leto3:object= {n:42,s:'foo'};letoo:Object[] = [{n:1,s:'1'}, {n:2,s:'2'}]; ```

leto1 = {n:42,s:'foo'};

'foo'

leto2:Object= {n:42,s:'foo'};

o2

leto3:object= {n:42,s:'foo'};

o3

object

letoo:Object[] = [{n:1,s:'1'}, {n:2,s:'2'}];

oo

收起深色代码主题复制classC1{n:number=0s:string=''}leto1:C1= {n:42,s:'foo'};leto2:C1= {n:42,s:'foo'};leto3:C1= {n:42,s:'foo'};letoo:C1[] = [{n:1,s:'1'}, {n:2,s:'2'}];

``` classC1{n:number=0s:string=''}leto1:C1= {n:42,s:'foo'};leto2:C1= {n:42,s:'foo'};leto3:C1= {n:42,s:'foo'};letoo:C1[] = [{n:1,s:'1'}, {n:2,s:'2'}]; ```

classC1{

C1

leto1:C1= {n:42,s:'foo'};

o1

leto2:C1= {n:42,s:'foo'};

leto3:C1= {n:42,s:'foo'};

letoo:C1[] = [{n:1,s:'1'}, {n:2,s:'2'}];

例子2

收起深色代码主题复制classC2{s:stringconstructor(s:string) {this.s='s ='+ s;}}leto4:C2= {s:'foo'};

``` classC2{s:stringconstructor(s:string) {this.s='s ='+ s;}}leto4:C2= {s:'foo'}; ```

classC2{

C2

this.s='s ='+ s;

's ='

leto4:C2= {s:'foo'};

o4

收起深色代码主题复制classC2{s:stringconstructor(s:string) {this.s='s ='+ s;}}leto4 =newC2('foo');

``` classC2{s:stringconstructor(s:string) {this.s='s ='+ s;}}leto4 =newC2('foo'); ```

leto4 =newC2('foo');

例子3

收起深色代码主题复制classC3{readonlyn:number=0readonlys:string=''}leto5:C3= {n:42,s:'foo'};

``` classC3{readonlyn:number=0readonlys:string=''}leto5:C3= {n:42,s:'foo'}; ```

classC3{

C3

readonlyn:number=0

readonly

readonlys:string=''

leto5:C3= {n:42,s:'foo'};

o5

收起深色代码主题复制classC3{n:number=0s:string=''}leto5:C3= {n:42,s:'foo'};

``` classC3{n:number=0s:string=''}leto5:C3= {n:42,s:'foo'}; ```

例子4

收起深色代码主题复制abstractclassA{}leto6: A = {};

``` abstractclassA{}leto6: A = {}; ```

abstractclassA{}

abstract

leto6: A = {};

o6

收起深色代码主题复制abstractclassA{}classCextendsA{}leto6: C = {};// 或 let o6: C = new C()

``` abstractclassA{}classCextendsA{}leto6: C = {};// 或 let o6: C = new C() ```

classCextendsA{}

leto6: C = {};// 或 let o6: C = new C()

// 或 let o6: C = new C()

例子5

收起深色代码主题复制classC4{n:number=0s:string=''f() {console.log('Hello');}}leto7:C4= {n:42,s:'foo',f:() =>{}};

``` classC4{n:number=0s:string=''f() {console.log('Hello');}}leto7:C4= {n:42,s:'foo',f:() =>{}}; ```

classC4{

C4

f() {

console.log('Hello');

leto7:C4= {n:42,s:'foo',f:() =>{}};

o7

() =>

收起深色代码主题复制classC4{n:number=0s:string=''f() {console.log('Hello');}}leto7 =newC4();o7.n=42;o7.s='foo';

``` classC4{n:number=0s:string=''f() {console.log('Hello');}}leto7 =newC4();o7.n=42;o7.s='foo'; ```

leto7 =newC4();

o7.n=42;

o7.s='foo';

例子6

收起深色代码主题复制classPoint{x:number=0y:number=0}functiongetPoint(o: Point):Point{returno;}// TS支持structural typing，可以推断p的类型为Pointletp = {x:5,y:10};getPoint(p);// 可通过上下文推断出对象字面量的类型为PointgetPoint({x:5,y:10});

``` classPoint{x:number=0y:number=0}functiongetPoint(o: Point):Point{returno;}// TS支持structural typing，可以推断p的类型为Pointletp = {x:5,y:10};getPoint(p);// 可通过上下文推断出对象字面量的类型为PointgetPoint({x:5,y:10}); ```

x:number=0

y:number=0

functiongetPoint(o: Point):Point{

getPoint

o: Point

returno;

// TS支持structural typing，可以推断p的类型为Point

letp = {x:5,y:10};

getPoint(p);

// 可通过上下文推断出对象字面量的类型为Point

getPoint({x:5,y:10});

收起深色代码主题复制classPoint{x:number=0y:number=0// 在字面量初始化之前，使用constructor()创建一个有效对象。// 由于没有为Point定义构造函数，编译器将自动添加一个默认构造函数。}functiongetPoint(o: Point):Point{returno;}// 字面量初始化需要显式定义类型letp:Point= {x:5,y:10};getPoint(p);// getPoint接受Point类型，字面量初始化生成一个Point的新实例getPoint({x:5,y:10});

``` classPoint{x:number=0y:number=0// 在字面量初始化之前，使用constructor()创建一个有效对象。// 由于没有为Point定义构造函数，编译器将自动添加一个默认构造函数。}functiongetPoint(o: Point):Point{returno;}// 字面量初始化需要显式定义类型letp:Point= {x:5,y:10};getPoint(p);// getPoint接受Point类型，字面量初始化生成一个Point的新实例getPoint({x:5,y:10}); ```

// 在字面量初始化之前，使用constructor()创建一个有效对象。

// 由于没有为Point定义构造函数，编译器将自动添加一个默认构造函数。

// 字面量初始化需要显式定义类型

letp:Point= {x:5,y:10};

// getPoint接受Point类型，字面量初始化生成一个Point的新实例

对象字面量不能用于类型声明

规则：arkts-no-obj-literals-as-types

ArkTS不支持使用对象字面量声明类型，可以使用类或者接口声明类型。

收起深色代码主题复制leto: {x:number,y:number} = {x:2,y:3}typeS =Set<{x:number,y:number}>

``` leto: {x:number,y:number} = {x:2,y:3}typeS =Set<{x:number,y:number}> ```

leto: {x:number,y:number} = {

o

x:2,

y:3

typeS =Set<{x:number,y:number}>

Set

收起深色代码主题复制classO{x:number=0y:number=0}leto: O = {x:2,y:3};typeS =Set<O>

``` classO{x:number=0y:number=0}leto: O = {x:2,y:3};typeS =Set<O> ```

classO{

O

leto: O = {x:2,y:3};

typeS =Set<O>

数组字面量必须仅包含可推断类型的元素

规则：arkts-no-noninferrable-arr-literals

本质上，ArkTS将数组字面量的类型推断为数组所有元素的联合类型。如果其中任何一个元素的类型无法根据上下文推导出来（例如，无类型的对象字面量），则会发生编译时错误。

收起深色代码主题复制leta = [{n:1,s:'1'}, {n:2,s:'2'}];

``` leta = [{n:1,s:'1'}, {n:2,s:'2'}]; ```

leta = [{n:1,s:'1'}, {n:2,s:'2'}];

收起深色代码主题复制classC{n:number=0s:string=''}leta1 = [{n:1,s:'1'}asC, {n:2,s:'2'}asC];// a1的类型为“C[]”leta2: C[] = [{n:1,s:'1'}, {n:2,s:'2'}];// a2的类型为“C[]”

``` classC{n:number=0s:string=''}leta1 = [{n:1,s:'1'}asC, {n:2,s:'2'}asC];// a1的类型为“C[]”leta2: C[] = [{n:1,s:'1'}, {n:2,s:'2'}];// a2的类型为“C[]” ```

leta1 = [{n:1,s:'1'}asC, {n:2,s:'2'}asC];// a1的类型为“C[]”

// a1的类型为“C[]”

leta2: C[] = [{n:1,s:'1'}, {n:2,s:'2'}];// a2的类型为“C[]”

a2

// a2的类型为“C[]”

使用箭头函数而非函数表达式

规则：arkts-no-func-expressions

ArkTS不支持函数表达式，使用箭头函数。

收起深色代码主题复制letf =function(s:string) {console.log(s);}

``` letf =function(s:string) {console.log(s);} ```

letf =function(s:string) {

console.log(s);

收起深色代码主题复制letf= (s:string) => {console.log(s);}

``` letf= (s:string) => {console.log(s);} ```

letf= (s:string) => {

不支持使用类表达式

规则：arkts-no-class-literals

ArkTS不支持使用类表达式，必须显式声明一个类。

收起深色代码主题复制constRectangle=class{constructor(height:number, width:number) {this.height= height;this.width= width;}heightwidth}constrectangle =newRectangle(0.0,0.0);

``` constRectangle=class{constructor(height:number, width:number) {this.height= height;this.width= width;}heightwidth}constrectangle =newRectangle(0.0,0.0); ```

constRectangle=class{

Rectangle

constructor(height:number, width:number) {

height:number, width:number

this.height= height;

height

this.width= width;

width

constrectangle =newRectangle(0.0,0.0);

0.0

收起深色代码主题复制classRectangle{constructor(height:number, width:number) {this.height= height;this.width= width;}height:numberwidth:number}constrectangle =newRectangle(0.0,0.0);

``` classRectangle{constructor(height:number, width:number) {this.height= height;this.width= width;}height:numberwidth:number}constrectangle =newRectangle(0.0,0.0); ```

classRectangle{

height:number

width:number

类不允许implements

规则：arkts-implements-only-iface

ArkTS不允许类被implements，只有接口可以被implements。

收起深色代码主题复制classC{foo() {}}classC1implementsC {foo() {}}

``` classC{foo() {}}classC1implementsC {foo() {}} ```

foo() {}

classC1implementsC {

收起深色代码主题复制interfaceC {foo():void}classC1implementsC {foo() {}}

``` interfaceC {foo():void}classC1implementsC {foo() {}} ```

interfaceC {

foo():void

不支持修改对象的方法

规则：arkts-no-method-reassignment

ArkTS不支持修改对象的方法。在静态语言中，对象的布局是确定的。一个类的所有对象实例享有同一个方法。

如果需要为某个特定的对象增加方法，可以封装函数或者使用继承的机制。

收起深色代码主题复制classC{foo() {console.log('foo');}}functionbar() {console.log('bar');}letc1 =newC();letc2 =newC();c2.foo= bar;c1.foo();// fooc2.foo();// bar

``` classC{foo() {console.log('foo');}}functionbar() {console.log('bar');}letc1 =newC();letc2 =newC();c2.foo= bar;c1.foo();// fooc2.foo();// bar ```

foo() {

console.log('foo');

functionbar() {

bar

console.log('bar');

'bar'

letc1 =newC();

letc2 =newC();

c2.foo= bar;

c1.foo();// foo

// foo

c2.foo();// bar

// bar

收起深色代码主题复制classC{foo() {console.log('foo');}}classDerivedextendsC{foo() {console.log('Extra');super.foo();}}functionbar() {console.log('bar');}letc1 =newC();letc2 =newC();c1.foo();// fooc2.foo();// fooletc3 =newDerived();c3.foo();// Extra foo

``` classC{foo() {console.log('foo');}}classDerivedextendsC{foo() {console.log('Extra');super.foo();}}functionbar() {console.log('bar');}letc1 =newC();letc2 =newC();c1.foo();// fooc2.foo();// fooletc3 =newDerived();c3.foo();// Extra foo ```

classDerivedextendsC{

Derived

console.log('Extra');

'Extra'

super.foo();

c2.foo();// foo

letc3 =newDerived();

c3.foo();// Extra foo

// Extra foo

类型转换仅支持as T语法

规则：arkts-as-casts

在ArkTS中，as关键字是类型转换的唯一语法，错误的类型转换会导致编译时错误或者运行时抛出ClassCastException异常。ArkTS不支持使用<type>语法进行类型转换。

当需要将primitive类型（如number或boolean）转换成引用类型时，请使用new表达式。

收起深色代码主题复制classShape{}classCircleextendsShape{x:number=5}classSquareextendsShape{y:string='a'}functioncreateShape():Shape{returnnewCircle();}letc1 = <Circle>createShape();letc2 =createShape()asCircle;// 如果转换错误，不会产生编译时或运行时报错letc3 =createShape()asSquare;console.log(c3.y);// undefined// 在TS中，由于`as`关键字不会在运行时生效，所以`instanceof`的左操作数不会在运行时被装箱成引用类型lete1 = (5.0asNumber)instanceofNumber;// false// 创建Number对象，获得预期结果：lete2 = (newNumber(5.0))instanceofNumber;// true

``` classShape{}classCircleextendsShape{x:number=5}classSquareextendsShape{y:string='a'}functioncreateShape():Shape{returnnewCircle();}letc1 = <Circle>createShape();letc2 =createShape()asCircle;// 如果转换错误，不会产生编译时或运行时报错letc3 =createShape()asSquare;console.log(c3.y);// undefined// 在TS中，由于`as`关键字不会在运行时生效，所以`instanceof`的左操作数不会在运行时被装箱成引用类型lete1 = (5.0asNumber)instanceofNumber;// false// 创建Number对象，获得预期结果：lete2 = (newNumber(5.0))instanceofNumber;// true ```

classShape{}

Shape

classCircleextendsShape{x:number=5}

Circle

classSquareextendsShape{y:string='a'}

Square

functioncreateShape():Shape{

createShape

returnnewCircle();

letc1 = <Circle>createShape();

letc2 =createShape()asCircle;

// 如果转换错误，不会产生编译时或运行时报错

letc3 =createShape()asSquare;

console.log(c3.y);// undefined

// 在TS中，由于`as`关键字不会在运行时生效，所以`instanceof`的左操作数不会在运行时被装箱成引用类型

lete1 = (5.0asNumber)instanceofNumber;// false

Number

instanceof

// false

// 创建Number对象，获得预期结果：

lete2 = (newNumber(5.0))instanceofNumber;// true

// true

收起深色代码主题复制classShape{}classCircleextendsShape{x:number=5}classSquareextendsShape{y:string='a'}functioncreateShape():Shape{returnnewCircle();}letc2 =createShape()asCircle;// 运行时抛出ClassCastException异常：letc3 =createShape()asSquare;// 创建Number对象，获得预期结果：lete2 = (newNumber(5.0))instanceofNumber;// true

``` classShape{}classCircleextendsShape{x:number=5}classSquareextendsShape{y:string='a'}functioncreateShape():Shape{returnnewCircle();}letc2 =createShape()asCircle;// 运行时抛出ClassCastException异常：letc3 =createShape()asSquare;// 创建Number对象，获得预期结果：lete2 = (newNumber(5.0))instanceofNumber;// true ```

// 运行时抛出ClassCastException异常：

不支持JSX表达式

规则：arkts-no-jsx

不支持使用JSX。

一元运算符+、-和~仅适用于数值类型

规则：arkts-no-polymorphic-unops

ArkTS仅允许一元运算符用于数值类型，否则会发生编译时错误。与TypeScript不同，ArkTS不支持隐式将字符串转换成数值，必须进行显式转换。

收起深色代码主题复制leta = +5;// 5（number类型）letb = +'5';// 5（number类型）letc = -5;// -5（number类型）letd = -'5';// -5（number类型）lete = ~5;// -6（number类型）letf = ~'5';// -6（number类型）letg = +'string';// NaN（number类型）functionreturnTen():string{return'-10';}functionreturnString():string{return'string';}letx = +returnTen();// -10（number类型）lety = +returnString();// NaN

``` leta = +5;// 5（number类型）letb = +'5';// 5（number类型）letc = -5;// -5（number类型）letd = -'5';// -5（number类型）lete = ~5;// -6（number类型）letf = ~'5';// -6（number类型）letg = +'string';// NaN（number类型）functionreturnTen():string{return'-10';}functionreturnString():string{return'string';}letx = +returnTen();// -10（number类型）lety = +returnString();// NaN ```

leta = +5;// 5（number类型）

// 5（number类型）

letb = +'5';// 5（number类型）

'5'

letc = -5;// -5（number类型）

// -5（number类型）

letd = -'5';// -5（number类型）

lete = ~5;// -6（number类型）

// -6（number类型）

letf = ~'5';// -6（number类型）

letg = +'string';// NaN（number类型）

'string'

// NaN（number类型）

functionreturnTen():string{

returnTen

return'-10';

'-10'

functionreturnString():string{

returnString

return'string';

letx = +returnTen();// -10（number类型）

// -10（number类型）

lety = +returnString();// NaN

// NaN

收起深色代码主题复制leta = +5;// 5（number类型）letb = +'5';// 编译时错误letc = -5;// -5（number类型）letd = -'5';// 编译时错误lete = ~5;// -6（number类型）letf = ~'5';// 编译时错误letg = +'string';// 编译时错误functionreturnTen():string{return'-10';}functionreturnString():string{return'string';}letx = +returnTen();// 编译时错误lety = +returnString();// 编译时错误

``` leta = +5;// 5（number类型）letb = +'5';// 编译时错误letc = -5;// -5（number类型）letd = -'5';// 编译时错误lete = ~5;// -6（number类型）letf = ~'5';// 编译时错误letg = +'string';// 编译时错误functionreturnTen():string{return'-10';}functionreturnString():string{return'string';}letx = +returnTen();// 编译时错误lety = +returnString();// 编译时错误 ```

letb = +'5';// 编译时错误

letd = -'5';// 编译时错误

letf = ~'5';// 编译时错误

letg = +'string';// 编译时错误

letx = +returnTen();// 编译时错误

lety = +returnString();// 编译时错误

不支持delete运算符

规则：arkts-no-delete

ArkTS中，对象布局在编译时就确定了，且不能在运行时被更改。因此，删除属性的操作没有意义。

收起深色代码主题复制classPoint{x?:number=0.0y?:number=0.0}letp =newPoint();deletep.y;

``` classPoint{x?:number=0.0y?:number=0.0}letp =newPoint();deletep.y; ```

x?:number=0.0

y?:number=0.0

letp =newPoint();

deletep.y;

收起深色代码主题复制// 可以声明一个可空类型并使用null作为缺省值classPoint{x:number|null=0y:number|null=0}letp =newPoint();p.y=null;

``` // 可以声明一个可空类型并使用null作为缺省值classPoint{x:number|null=0y:number|null=0}letp =newPoint();p.y=null; ```

// 可以声明一个可空类型并使用null作为缺省值

x:number|null=0

null

y:number|null=0

p.y=null;

仅允许在表达式中使用typeof运算符

规则：arkts-no-type-query

ArkTS仅支持在表达式中使用typeof运算符，不允许使用typeof作为类型。

收起深色代码主题复制letn1 =42;lets1 ='foo';console.log(typeofn1);// 'number'console.log(typeofs1);// 'string'letn2:typeofn1lets2:typeofs1

``` letn1 =42;lets1 ='foo';console.log(typeofn1);// 'number'console.log(typeofs1);// 'string'letn2:typeofn1lets2:typeofs1 ```

letn1 =42;

lets1 ='foo';

console.log(typeofn1);// 'number'

typeof

// 'number'

console.log(typeofs1);// 'string'

// 'string'

letn2:typeofn1

n2

lets2:typeofs1

s2

收起深色代码主题复制letn1 =42;lets1 ='foo';console.log(typeofn1);// 'number'console.log(typeofs1);// 'string'letn2:numberlets2:string

``` letn1 =42;lets1 ='foo';console.log(typeofn1);// 'number'console.log(typeofs1);// 'string'letn2:numberlets2:string ```

letn2:number

lets2:string

部分支持instanceof运算符

规则：arkts-instanceof-ref-types

在TypeScript中，instanceof运算符的左操作数的类型必须为any类型、对象类型，或者它是类型参数，否则结果为false。在ArkTS中，instanceof运算符的左操作数的类型必须为引用类型（例如，对象、数组或者函数），否则会发生编译时错误。此外，在ArkTS中，instanceof运算符的左操作数不能是类型，必须是对象的实例。

不支持in运算符

规则：arkts-no-in

由于在ArkTS中，对象布局在编译时是已知的并且在运行时无法修改，因此，不支持in运算符。如果仍需检查某些类成员是否存在，使用instanceof代替。

收起深色代码主题复制classPerson{name:string=''}letp =newPerson();letb ='name'inp;// true

``` classPerson{name:string=''}letp =newPerson();letb ='name'inp;// true ```

letp =newPerson();

letb ='name'inp;// true

in

收起深色代码主题复制classPerson{name:string=''}letp =newPerson();letb = pinstanceofPerson;// true，且属性name一定存在

``` classPerson{name:string=''}letp =newPerson();letb = pinstanceofPerson;// true，且属性name一定存在 ```

letb = pinstanceofPerson;// true，且属性name一定存在

// true，且属性name一定存在

不支持解构赋值

规则：arkts-no-destruct-assignment

ArkTS不支持解构赋值。可使用其他替代方法，例如，使用临时变量。

收起深色代码主题复制let[one, two] = [1,2];// 此处需要分号[one, two] = [two, one];lethead, tail[head, ...tail] = [1,2,3,4];

``` let[one, two] = [1,2];// 此处需要分号[one, two] = [two, one];lethead, tail[head, ...tail] = [1,2,3,4]; ```

let[one, two] = [1,2];// 此处需要分号

// 此处需要分号

[one, two] = [two, one];

lethead, tail

[head, ...tail] = [1,2,3,4];

4

收起深色代码主题复制letarr:number[] = [1,2];letone = arr[0];lettwo = arr[1];lettmp = one;one = two;two = tmp;letdata:Number[] = [1,2,3,4];lethead = data[0];lettail:Number[] = [];for(leti =1; i < data.length; ++i) {tail.push(data[i]);}

``` letarr:number[] = [1,2];letone = arr[0];lettwo = arr[1];lettmp = one;one = two;two = tmp;letdata:Number[] = [1,2,3,4];lethead = data[0];lettail:Number[] = [];for(leti =1; i < data.length; ++i) {tail.push(data[i]);} ```

letarr:number[] = [1,2];

arr

letone = arr[0];

lettwo = arr[1];

lettmp = one;

one = two;

two = tmp;

letdata:Number[] = [1,2,3,4];

data

lethead = data[0];

lettail:Number[] = [];

tail

for(leti =1; i < data.length; ++i) {

for

length

tail.push(data[i]);

push

逗号运算符,仅用在for循环语句中

规则：arkts-no-comma-outside-loops

为了方便理解执行顺序，在ArkTS中，逗号运算符仅适用于for循环语句中。注意与声明变量、函数参数传递时的逗号分隔符不同。

收起深色代码主题复制for(leti =0, j =0; i <10; ++i, j +=2) {// ...}letx =0;x = (++x, x++);// 1

``` for(leti =0, j =0; i <10; ++i, j +=2) {// ...}letx =0;x = (++x, x++);// 1 ```

for(leti =0, j =0; i <10; ++i, j +=2) {

letx =0;

x = (++x, x++);// 1

// 1

收起深色代码主题复制for(leti =0, j =0; i <10; ++i, j +=2) {// ...}// 通过语句表示执行顺序，而非逗号运算符letx =0;++x;x = x++;

``` for(leti =0, j =0; i <10; ++i, j +=2) {// ...}// 通过语句表示执行顺序，而非逗号运算符letx =0;++x;x = x++; ```

// 通过语句表示执行顺序，而非逗号运算符

++x;

x = x++;

不支持解构变量声明

规则：arkts-no-destruct-decls

ArkTS不支持解构变量声明。它是一个依赖于结构兼容性的动态特性并且解构声明中的名称必须和被解构对象中的属性名称一致。

收起深色代码主题复制classPoint{x:number=0.0y:number=0.0}functionreturnZeroPoint():Point{returnnewPoint();}let{x, y} =returnZeroPoint();

``` classPoint{x:number=0.0y:number=0.0}functionreturnZeroPoint():Point{returnnewPoint();}let{x, y} =returnZeroPoint(); ```

x:number=0.0

y:number=0.0

functionreturnZeroPoint():Point{

returnZeroPoint

returnnewPoint();

let{x, y} =returnZeroPoint();

收起深色代码主题复制classPoint{x:number=0.0y:number=0.0}functionreturnZeroPoint():Point{returnnewPoint();}// 创建一个局部变量来处理每个字段letzp =returnZeroPoint();letx = zp.x;lety = zp.y;

``` classPoint{x:number=0.0y:number=0.0}functionreturnZeroPoint():Point{returnnewPoint();}// 创建一个局部变量来处理每个字段letzp =returnZeroPoint();letx = zp.x;lety = zp.y; ```

// 创建一个局部变量来处理每个字段

letzp =returnZeroPoint();

letx = zp.x;

lety = zp.y;

不支持在catch语句标注类型

规则：arkts-no-types-in-catch

在TypeScript的catch语句中，只能标注any或unknown类型。由于ArkTS不支持这些类型，应省略类型标注。

收起深色代码主题复制try{// ...}catch(a:unknown) {// 处理异常}

``` try{// ...}catch(a:unknown) {// 处理异常} ```

try{

try

}catch(a:unknown) {

catch

a

// 处理异常

收起深色代码主题复制try{// ...}catch(a) {// 处理异常}

``` try{// ...}catch(a) {// 处理异常} ```

}catch(a) {

不支持for .. in

规则：arkts-no-for-in

由于在ArkTS中，对象布局在编译时是确定的、并且不能在运行时被改变，所以不支持使用for .. in迭代一个对象的属性。对于数组来说，可以使用常规的for循环。

收起深色代码主题复制leta:string[] = ['1.0','2.0','3.0'];for(letiina) {console.log(a[i]);}

``` leta:string[] = ['1.0','2.0','3.0'];for(letiina) {console.log(a[i]);} ```

leta:string[] = ['1.0','2.0','3.0'];

'1.0'

'2.0'

'3.0'

for(letiina) {

console.log(a[i]);

收起深色代码主题复制leta:string[] = ['1.0','2.0','3.0'];for(leti =0; i < a.length; ++i) {console.log(a[i]);}

``` leta:string[] = ['1.0','2.0','3.0'];for(leti =0; i < a.length; ++i) {console.log(a[i]);} ```

for(leti =0; i < a.length; ++i) {

不支持映射类型

规则：arkts-no-mapped-types

ArkTS不支持映射类型，使用其他语法来表示相同的语义。

收起深色代码主题复制typeOptionsFlags<Type> = {[PropertyinkeyofType]:boolean}

``` typeOptionsFlags<Type> = {[PropertyinkeyofType]:boolean} ```

typeOptionsFlags<Type> = {

OptionsFlags

Type

[PropertyinkeyofType]:boolean

Property

收起深色代码主题复制classC{n:number=0s:string=''}classCFlags{n:boolean=falses:boolean=false}

``` classC{n:number=0s:string=''}classCFlags{n:boolean=falses:boolean=false} ```

classCFlags{

CFlags

n:boolean=false

s:boolean=false

不支持with语句

规则：arkts-no-with

ArkTS不支持with语句，使用其他语法来表示相同的语义。

收起深色代码主题复制with(Math) {// 编译时错误, 但是仍能生成JavaScript代码letr:number=42;letarea:number=PI* r * r;}

``` with(Math) {// 编译时错误, 但是仍能生成JavaScript代码letr:number=42;letarea:number=PI* r * r;} ```

with(Math) {// 编译时错误, 但是仍能生成JavaScript代码

with

// 编译时错误, 但是仍能生成JavaScript代码

letr:number=42;

r

letarea:number=PI* r * r;

area

PI

收起深色代码主题复制letr:number=42;letarea:number=Math.PI* r * r;

``` letr:number=42;letarea:number=Math.PI* r * r; ```

letarea:number=Math.PI* r * r;

限制throw语句中表达式的类型

规则：arkts-limited-throw

ArkTS只支持抛出Error类或其派生类的实例。禁止抛出其他类型（例如number或string）的数据。

收起深色代码主题复制throw4;throw'';thrownewError();

``` throw4;throw'';thrownewError(); ```

throw4;

throw

throw'';

thrownewError();

Error

收起深色代码主题复制thrownewError();

``` thrownewError(); ```

限制省略函数返回类型标注

规则：arkts-no-implicit-return-types

ArkTS在部分场景中支持对函数返回类型进行推断。当return语句中的表达式是对某个函数或方法进行调用，且该函数或方法的返回类型没有被显著标注时，会出现编译时错误。在这种情况下，请标注函数返回类型。

收起深色代码主题复制// 只有在开启noImplicitAny选项时会产生编译时错误functionf(x:number) {if(x <=0) {returnx;}returng(x);}// 只有在开启noImplicitAny选项时会产生编译时错误functiong(x:number) {returnf(x -1);}functiondoOperation(x:number, y:number) {returnx + y;}f(10);doOperation(2,3);

``` // 只有在开启noImplicitAny选项时会产生编译时错误functionf(x:number) {if(x <=0) {returnx;}returng(x);}// 只有在开启noImplicitAny选项时会产生编译时错误functiong(x:number) {returnf(x -1);}functiondoOperation(x:number, y:number) {returnx + y;}f(10);doOperation(2,3); ```

// 只有在开启noImplicitAny选项时会产生编译时错误

functionf(x:number) {

x:number

if(x <=0) {

returng(x);

g

functiong(x:number) {

returnf(x -1);

functiondoOperation(x:number, y:number) {

doOperation

returnx + y;

f(10);

doOperation(2,3);

收起深色代码主题复制// 需标注返回类型：functionf(x:number):number{if(x <=0) {returnx;}returng(x);}// 可以省略返回类型，返回类型可以从f的类型标注推导得到functiong(x:number):number{returnf(x -1);}// 可以省略返回类型functiondoOperation(x:number, y:number) {returnx + y;}f(10);doOperation(2,3);

``` // 需标注返回类型：functionf(x:number):number{if(x <=0) {returnx;}returng(x);}// 可以省略返回类型，返回类型可以从f的类型标注推导得到functiong(x:number):number{returnf(x -1);}// 可以省略返回类型functiondoOperation(x:number, y:number) {returnx + y;}f(10);doOperation(2,3); ```

// 需标注返回类型：

functionf(x:number):number{

// 可以省略返回类型，返回类型可以从f的类型标注推导得到

functiong(x:number):number{

// 可以省略返回类型

不支持参数解构的函数声明

规则：arkts-no-destruct-params

ArkTS要求实参必须直接传递给函数，且必须指定到形参。

收起深色代码主题复制functiondrawText({ text ='', location: [x, y] = [0,0], bold =false}) {text;x;y;bold;}drawText({text:'Hello, world!',location: [100,50],bold:true});

``` functiondrawText({ text ='', location: [x, y] = [0,0], bold =false}) {text;x;y;bold;}drawText({text:'Hello, world!',location: [100,50],bold:true}); ```

functiondrawText({ text ='', location: [x, y] = [0,0], bold =false}) {

drawText

{ text ='', location: [x, y] = [0,0], bold =false}

text;

x;

y;

bold;

drawText({text:'Hello, world!',location: [100,50],bold:true});

text

'Hello, world!'

location

100

50

bold

收起深色代码主题复制functiondrawText(text:String, location:number[], bold:boolean) {letx = location[0];lety = location[1];text;x;y;bold;}functionmain() {drawText('Hello, world!', [100,50],true);}

``` functiondrawText(text:String, location:number[], bold:boolean) {letx = location[0];lety = location[1];text;x;y;bold;}functionmain() {drawText('Hello, world!', [100,50],true);} ```

functiondrawText(text:String, location:number[], bold:boolean) {

text:String, location:number[], bold:boolean

String

letx = location[0];

lety = location[1];

functionmain() {

main

drawText('Hello, world!', [100,50],true);

不支持在函数内声明函数

规则：arkts-no-nested-funcs

ArkTS不支持在函数内声明函数，改用lambda函数。

收起深色代码主题复制functionaddNum(a:number, b:number):void{// 函数内声明函数functionlogToConsole(message:string):void{console.log(message);}letresult = a + b;// 调用函数logToConsole('result is '+ result);}

``` functionaddNum(a:number, b:number):void{// 函数内声明函数functionlogToConsole(message:string):void{console.log(message);}letresult = a + b;// 调用函数logToConsole('result is '+ result);} ```

functionaddNum(a:number, b:number):void{

addNum

a:number, b:number

// 函数内声明函数

functionlogToConsole(message:string):void{

logToConsole

message:string

console.log(message);

letresult = a + b;

// 调用函数

logToConsole('result is '+ result);

'result is '

收起深色代码主题复制functionaddNum(a:number, b:number):void{// 使用lambda函数代替声明函数letlogToConsole:(message:string) =>void= (message:string):void=>{console.log(message);}letresult = a + b;logToConsole('result is '+ result);}

``` functionaddNum(a:number, b:number):void{// 使用lambda函数代替声明函数letlogToConsole:(message:string) =>void= (message:string):void=>{console.log(message);}letresult = a + b;logToConsole('result is '+ result);} ```

// 使用lambda函数代替声明函数

letlogToConsole:(message:string) =>void= (message:string):void=>{

(message:string) =>

message

void=>

不支持在函数和类的静态方法中使用this

规则：arkts-no-standalone-this

ArkTS不支持在函数和类的静态方法中使用this，只能在类的实例方法中使用this。

收起深色代码主题复制functionfoo(i:string) {this.count= i;// 只有在开启noImplicitThis选项时会产生编译时错误}classA{count:string='a'm = foo}leta =newA();console.log(a.count);// 打印aa.m('b');console.log(a.count);// 打印b

``` functionfoo(i:string) {this.count= i;// 只有在开启noImplicitThis选项时会产生编译时错误}classA{count:string='a'm = foo}leta =newA();console.log(a.count);// 打印aa.m('b');console.log(a.count);// 打印b ```

functionfoo(i:string) {

i:string

this.count= i;// 只有在开启noImplicitThis选项时会产生编译时错误

count

// 只有在开启noImplicitThis选项时会产生编译时错误

classA{

count:string='a'

m = foo

leta =newA();

console.log(a.count);// 打印a

// 打印a

a.m('b');

console.log(a.count);// 打印b

// 打印b

收起深色代码主题复制classA{count:string='a'm(i:string):void{this.count= i;}}functionmain():void{leta =newA();console.log(a.count);// 打印aa.m('b');console.log(a.count);// 打印b}

``` classA{count:string='a'm(i:string):void{this.count= i;}}functionmain():void{leta =newA();console.log(a.count);// 打印aa.m('b');console.log(a.count);// 打印b} ```

m(i:string):void{

this.count= i;

functionmain():void{

不支持生成器函数

规则：arkts-no-generators

目前ArkTS不支持生成器函数，使用async或await机制进行并行任务处理。

收起深色代码主题复制function*counter(start:number, end:number) {for(leti = start; i <= end; i++) {yieldi;}}for(letnumofcounter(1,5)) {console.log(num);}

``` function*counter(start:number, end:number) {for(leti = start; i <= end; i++) {yieldi;}}for(letnumofcounter(1,5)) {console.log(num);} ```

function*counter(start:number, end:number) {

counter

start:number, end:number

for(leti = start; i <= end; i++) {

yieldi;

yield

for(letnumofcounter(1,5)) {

of

console.log(num);

收起深色代码主题复制asyncfunctioncomplexNumberProcessing(num:number):Promise<number> {// ...returnnum;}asyncfunctionfoo() {for(leti =1; i <=5; i++) {awaitcomplexNumberProcessing(i);}}foo()

``` asyncfunctioncomplexNumberProcessing(num:number):Promise<number> {// ...returnnum;}asyncfunctionfoo() {for(leti =1; i <=5; i++) {awaitcomplexNumberProcessing(i);}}foo() ```

asyncfunctioncomplexNumberProcessing(num:number):Promise<number> {

async

complexNumberProcessing

num:number

Promise

returnnum;

asyncfunctionfoo() {

for(leti =1; i <=5; i++) {

awaitcomplexNumberProcessing(i);

await

foo()

使用instanceof和as进行类型保护

规则：arkts-no-is

ArkTS不支持is运算符，必须用instanceof运算符替代。在使用之前，必须使用as运算符将对象转换为需要的类型。

收起深色代码主题复制classFoo{foo:string=''common:string=''}classBar{bar:string=''common:string=''}functionisFoo(arg:any): arg isFoo{returnarg.foo!==undefined;}functiondoStuff(arg: Foo | Bar) {if(isFoo(arg)) {console.log(arg.foo);// OKconsole.log(arg.bar);// 编译时错误}else{console.log(arg.foo);// 编译时错误console.log(arg.bar);// OK}}doStuff({foo:123,common:'123'});doStuff({bar:123,common:'123'});

``` classFoo{foo:string=''common:string=''}classBar{bar:string=''common:string=''}functionisFoo(arg:any): arg isFoo{returnarg.foo!==undefined;}functiondoStuff(arg: Foo | Bar) {if(isFoo(arg)) {console.log(arg.foo);// OKconsole.log(arg.bar);// 编译时错误}else{console.log(arg.foo);// 编译时错误console.log(arg.bar);// OK}}doStuff({foo:123,common:'123'});doStuff({bar:123,common:'123'}); ```

classFoo{

Foo

foo:string=''

common:string=''

common

classBar{

Bar

bar:string=''

functionisFoo(arg:any): arg isFoo{

isFoo

arg:any

returnarg.foo!==undefined;

undefined

functiondoStuff(arg: Foo | Bar) {

doStuff

arg: Foo | Bar

if(isFoo(arg)) {

console.log(arg.foo);// OK

// OK

console.log(arg.bar);// 编译时错误

}else{

else

console.log(arg.foo);// 编译时错误

console.log(arg.bar);// OK

doStuff({foo:123,common:'123'});

123

'123'

doStuff({bar:123,common:'123'});

收起深色代码主题复制classFoo{foo:string=''common:string=''}classBar{bar:string=''common:string=''}functionisFoo(arg:Object):boolean{returnarginstanceofFoo;}functiondoStuff(arg:Object):void{if(isFoo(arg)) {letfooArg = argasFoo;console.log(fooArg.foo);// OKconsole.log(arg.bar);// 编译时错误}else{letbarArg = argasBar;console.log(arg.foo);// 编译时错误console.log(barArg.bar);// OK}}functionmain():void{doStuff(newFoo());doStuff(newBar());}

``` classFoo{foo:string=''common:string=''}classBar{bar:string=''common:string=''}functionisFoo(arg:Object):boolean{returnarginstanceofFoo;}functiondoStuff(arg:Object):void{if(isFoo(arg)) {letfooArg = argasFoo;console.log(fooArg.foo);// OKconsole.log(arg.bar);// 编译时错误}else{letbarArg = argasBar;console.log(arg.foo);// 编译时错误console.log(barArg.bar);// OK}}functionmain():void{doStuff(newFoo());doStuff(newBar());} ```

functionisFoo(arg:Object):boolean{

arg:Object

returnarginstanceofFoo;

functiondoStuff(arg:Object):void{

letfooArg = argasFoo;

console.log(fooArg.foo);// OK

letbarArg = argasBar;

console.log(barArg.bar);// OK

doStuff(newFoo());

doStuff(newBar());

部分支持展开运算符

规则：arkts-no-spread

ArkTS仅支持使用展开运算符展开数组、Array的子类和TypedArray（例如Int32Array）。仅支持使用在以下场景中：

传递给剩余参数时；

复制一个数组到数组字面量。

收起深色代码主题复制functionfoo(x:number, y:number, z:number) {// ...}letargs: [number,number,number] = [0,1,2];foo(...args);

``` functionfoo(x:number, y:number, z:number) {// ...}letargs: [number,number,number] = [0,1,2];foo(...args); ```

functionfoo(x:number, y:number, z:number) {

x:number, y:number, z:number

letargs: [number,number,number] = [0,1,2];

args

foo(...args);

收起深色代码主题复制functionlog_numbers(x:number, y:number, z:number) {// ...}letnumbers:number[] = [1,2,3];log_numbers(numbers[0], numbers[1], numbers[2]);

``` functionlog_numbers(x:number, y:number, z:number) {// ...}letnumbers:number[] = [1,2,3];log_numbers(numbers[0], numbers[1], numbers[2]); ```

functionlog_numbers(x:number, y:number, z:number) {

log_numbers

letnumbers:number[] = [1,2,3];

numbers

log_numbers(numbers[0], numbers[1], numbers[2]);

收起深色代码主题复制letpoint2d = {x:1,y:2};letpoint3d = { ...point2d,z:3};

``` letpoint2d = {x:1,y:2};letpoint3d = { ...point2d,z:3}; ```

letpoint2d = {x:1,y:2};

letpoint3d = { ...point2d,z:3};

收起深色代码主题复制classPoint2D{x:number=0;y:number=0}classPoint3D{x:number=0;y:number=0;z:number=0constructor(p2d: Point2D, z:number) {this.x= p2d.x;this.y= p2d.y;this.z= z;}}letp3d =newPoint3D({x:1,y:2}asPoint2D,3);classDerivedFromArrayextendsUint16Array{};letarr1 = [1,2,3];letarr2 =newUint16Array([4,5,6]);letarr3 =newDerivedFromArray([7,8,9]);letarr4 = [...arr1,10, ...arr2,11, ...arr3];

``` classPoint2D{x:number=0;y:number=0}classPoint3D{x:number=0;y:number=0;z:number=0constructor(p2d: Point2D, z:number) {this.x= p2d.x;this.y= p2d.y;this.z= z;}}letp3d =newPoint3D({x:1,y:2}asPoint2D,3);classDerivedFromArrayextendsUint16Array{};letarr1 = [1,2,3];letarr2 =newUint16Array([4,5,6]);letarr3 =newDerivedFromArray([7,8,9]);letarr4 = [...arr1,10, ...arr2,11, ...arr3]; ```

classPoint2D{

Point2D

x:number=0;y:number=0

classPoint3D{

Point3D

x:number=0;y:number=0;z:number=0

constructor(p2d: Point2D, z:number) {

p2d: Point2D, z:number

this.x= p2d.x;

this.y= p2d.y;

this.z= z;

letp3d =newPoint3D({x:1,y:2}asPoint2D,3);

classDerivedFromArrayextendsUint16Array{};

DerivedFromArray

Uint16Array

letarr1 = [1,2,3];

letarr2 =newUint16Array([4,5,6]);

6

letarr3 =newDerivedFromArray([7,8,9]);

7

8

9

letarr4 = [...arr1,10, ...arr2,11, ...arr3];

11

接口不能继承具有相同方法的两个接口

规则：arkts-no-extend-same-prop

在TypeScript中，如果一个接口继承了具有相同方法的两个接口，则该接口必须使用联合类型来声明该方法的返回值类型。在ArkTS中，由于一个接口中不能包含两个无法区分的方法（例如两个参数列表相同但返回类型不同的方法），因此，接口不能继承具有相同方法的两个接口。

收起深色代码主题复制interfaceMover{getStatus(): {speed:number}}interfaceShaker{getStatus(): {frequency:number}}interfaceMoverShakerextendsMover,Shaker{getStatus(): {speed:numberfrequency:number}}classCimplementsMoverShaker{privatespeed:number=0privatefrequency:number=0getStatus() {return{speed:this.speed,frequency:this.frequency};}}

``` interfaceMover{getStatus(): {speed:number}}interfaceShaker{getStatus(): {frequency:number}}interfaceMoverShakerextendsMover,Shaker{getStatus(): {speed:numberfrequency:number}}classCimplementsMoverShaker{privatespeed:number=0privatefrequency:number=0getStatus() {return{speed:this.speed,frequency:this.frequency};}} ```

interfaceMover{

Mover

getStatus(): {speed:number}

getStatus

speed

interfaceShaker{

Shaker

getStatus(): {frequency:number}

frequency

interfaceMoverShakerextendsMover,Shaker{

MoverShaker

getStatus(): {

speed:number

frequency:number

classCimplementsMoverShaker{

privatespeed:number=0

privatefrequency:number=0

getStatus() {

return{speed:this.speed,frequency:this.frequency};

收起深色代码主题复制classMoveStatus{publicspeed:numberconstructor() {this.speed=0;}}interfaceMover{getMoveStatus():MoveStatus}classShakeStatus{publicfrequency:numberconstructor() {this.frequency=0;}}interfaceShaker{getShakeStatus():ShakeStatus}classMoveAndShakeStatus{publicspeed:numberpublicfrequency:numberconstructor() {this.speed=0;this.frequency=0;}}classCimplementsMover,Shaker{privatemove_status:MoveStatusprivateshake_status:ShakeStatusconstructor() {this.move_status=newMoveStatus();this.shake_status=newShakeStatus();}publicgetMoveStatus():MoveStatus{returnthis.move_status;}publicgetShakeStatus():ShakeStatus{returnthis.shake_status;}publicgetStatus():MoveAndShakeStatus{return{speed:this.move_status.speed,frequency:this.shake_status.frequency};}}

``` classMoveStatus{publicspeed:numberconstructor() {this.speed=0;}}interfaceMover{getMoveStatus():MoveStatus}classShakeStatus{publicfrequency:numberconstructor() {this.frequency=0;}}interfaceShaker{getShakeStatus():ShakeStatus}classMoveAndShakeStatus{publicspeed:numberpublicfrequency:numberconstructor() {this.speed=0;this.frequency=0;}}classCimplementsMover,Shaker{privatemove_status:MoveStatusprivateshake_status:ShakeStatusconstructor() {this.move_status=newMoveStatus();this.shake_status=newShakeStatus();}publicgetMoveStatus():MoveStatus{returnthis.move_status;}publicgetShakeStatus():ShakeStatus{returnthis.shake_status;}publicgetStatus():MoveAndShakeStatus{return{speed:this.move_status.speed,frequency:this.shake_status.frequency};}} ```

classMoveStatus{

MoveStatus

publicspeed:number

this.speed=0;

getMoveStatus():MoveStatus

getMoveStatus

classShakeStatus{

ShakeStatus

publicfrequency:number

this.frequency=0;

getShakeStatus():ShakeStatus

getShakeStatus

classMoveAndShakeStatus{

MoveAndShakeStatus

classCimplementsMover,Shaker{

privatemove_status:MoveStatus

move_status

privateshake_status:ShakeStatus

shake_status

this.move_status=newMoveStatus();

this.shake_status=newShakeStatus();

publicgetMoveStatus():MoveStatus{

returnthis.move_status;

publicgetShakeStatus():ShakeStatus{

returnthis.shake_status;

publicgetStatus():MoveAndShakeStatus{

return{

speed:this.move_status.speed,

frequency:this.shake_status.frequency

};

不支持声明合并

规则：arkts-no-decl-merging

ArkTS不支持类、接口的声明合并。

收起深色代码主题复制interfaceDocument{createElement(tagName:any):Element}interfaceDocument{createElement(tagName:string):HTMLElement}interfaceDocument{createElement(tagName:number):HTMLDivElementcreateElement(tagName:boolean):HTMLSpanElementcreateElement(tagName:string,value:number):HTMLCanvasElement}

``` interfaceDocument{createElement(tagName:any):Element}interfaceDocument{createElement(tagName:string):HTMLElement}interfaceDocument{createElement(tagName:number):HTMLDivElementcreateElement(tagName:boolean):HTMLSpanElementcreateElement(tagName:string,value:number):HTMLCanvasElement} ```

interfaceDocument{

Document

createElement(tagName:any):Element

createElement

tagName

Element

createElement(tagName:string):HTMLElement

HTMLElement

createElement(tagName:number):HTMLDivElement

HTMLDivElement

createElement(tagName:boolean):HTMLSpanElement

HTMLSpanElement

createElement(tagName:string,value:number):HTMLCanvasElement

value

HTMLCanvasElement

收起深色代码主题复制interfaceDocument{createElement(tagName:number):HTMLDivElementcreateElement(tagName:boolean):HTMLSpanElementcreateElement(tagName:string,value:number):HTMLCanvasElementcreateElement(tagName:string):HTMLElementcreateElement(tagName:Object):Element}

``` interfaceDocument{createElement(tagName:number):HTMLDivElementcreateElement(tagName:boolean):HTMLSpanElementcreateElement(tagName:string,value:number):HTMLCanvasElementcreateElement(tagName:string):HTMLElementcreateElement(tagName:Object):Element} ```

createElement(tagName:Object):Element

接口不能继承类

规则：arkts-extends-only-class

ArkTS不支持接口继承类，接口只能继承接口。

收起深色代码主题复制classControl{state:number=0}interfaceSelectableControlextendsControl{select():void}

``` classControl{state:number=0}interfaceSelectableControlextendsControl{select():void} ```

classControl{

Control

state:number=0

state

interfaceSelectableControlextendsControl{

SelectableControl

select():void

select

收起深色代码主题复制interfaceControl{state:number}interfaceSelectableControlextendsControl{select():void}

``` interfaceControl{state:number}interfaceSelectableControlextendsControl{select():void} ```

interfaceControl{

state:number

不支持构造函数类型

规则：arkts-no-ctor-signatures-funcs

ArkTS不支持使用构造函数类型，改用lambda函数。

收起深色代码主题复制classPerson{constructor(name:string,age:number) {}}typePersonCtor=new(name:string,age:number) =>PersonfunctioncreatePerson(Ctor: PersonCtor, name:string, age:number):Person{returnnewCtor(name, age);}constperson =createPerson(Person,'John',30);

``` classPerson{constructor(name:string,age:number) {}}typePersonCtor=new(name:string,age:number) =>PersonfunctioncreatePerson(Ctor: PersonCtor, name:string, age:number):Person{returnnewCtor(name, age);}constperson =createPerson(Person,'John',30); ```

name:string,

) {}

typePersonCtor=new(name:string,age:number) =>Person

PersonCtor

functioncreatePerson(Ctor: PersonCtor, name:string, age:number):Person

createPerson

Ctor: PersonCtor, name:string, age:number

returnnewCtor(name, age);

Ctor

constperson =createPerson(Person,'John',30);

收起深色代码主题复制classPerson{constructor(name:string,age:number) {}}typePersonCtor=(n:string, a:number) =>PersonfunctioncreatePerson(Ctor: PersonCtor, n:string, a:number):Person{returnCtor(n, a);}letImpersonizer:PersonCtor= (n:string,a:number):Person=>{returnnewPerson(n, a);}constperson =createPerson(Impersonizer,'John',30);

``` classPerson{constructor(name:string,age:number) {}}typePersonCtor=(n:string, a:number) =>PersonfunctioncreatePerson(Ctor: PersonCtor, n:string, a:number):Person{returnCtor(n, a);}letImpersonizer:PersonCtor= (n:string,a:number):Person=>{returnnewPerson(n, a);}constperson =createPerson(Impersonizer,'John',30); ```

typePersonCtor=(n:string, a:number) =>Person

(n:string, a:number) =>

n:string, a:number

functioncreatePerson(Ctor: PersonCtor, n:string, a:number):Person{

Ctor: PersonCtor, n:string, a:number

returnCtor(n, a);

letImpersonizer:PersonCtor= (n:string,a:number):Person=>{

Impersonizer

Person=>

returnnewPerson(n, a);

constperson =createPerson(Impersonizer,'John',30);

只能使用类型相同的编译时表达式初始化枚举成员

规则：arkts-no-enum-mixed-types

ArkTS不支持使用在运行期间才能计算的表达式来初始化枚举成员。此外，枚举中所有显式初始化的成员必须具有相同的类型。

收起深色代码主题复制enumE1{A =0xa,B =0xb,C =Math.random(),D =0xd,E// 推断出0xe}enumE2{A =0xa,B ='0xb',C =0xc,D ='0xd'}

``` enumE1{A =0xa,B =0xb,C =Math.random(),D =0xd,E// 推断出0xe}enumE2{A =0xa,B ='0xb',C =0xc,D ='0xd'} ```

enumE1{

E1

A =0xa,

0xa

B =0xb,

0xb

C =Math.random(),

D =0xd,

0xd

E// 推断出0xe

// 推断出0xe

enumE2{

E2

B ='0xb',

'0xb'

C =0xc,

0xc

D ='0xd'

'0xd'

收起深色代码主题复制enumE1{A =0xa,B =0xb,C =0xc,D =0xd,E// 推断出0xe}enumE2{A ='0xa',B ='0xb',C ='0xc',D ='0xd'}

``` enumE1{A =0xa,B =0xb,C =0xc,D =0xd,E// 推断出0xe}enumE2{A ='0xa',B ='0xb',C ='0xc',D ='0xd'} ```

A ='0xa',

'0xa'

C ='0xc',

'0xc'

不支持enum声明合并

规则：arkts-no-enum-merging

ArkTS不支持enum声明合并。

收起深色代码主题复制enumColorSet{RED,GREEN}enumColorSet{YELLOW=2}enumColorSet{BLACK=3,BLUE}

``` enumColorSet{RED,GREEN}enumColorSet{YELLOW=2}enumColorSet{BLACK=3,BLUE} ```

enumColorSet{

ColorSet

RED,

RED

GREEN

YELLOW=2

YELLOW

BLACK=3,

BLACK

BLUE

收起深色代码主题复制enumColorSet{RED,GREEN,YELLOW,BLACK,BLUE}

``` enumColorSet{RED,GREEN,YELLOW,BLACK,BLUE} ```

GREEN,

YELLOW,

BLACK,

命名空间不能被用作对象

规则：arkts-no-ns-as-obj

ArkTS不支持将命名空间用作对象，可以使用类或模块。

收起深色代码主题复制namespaceMyNamespace{exportletx:number}letm =MyNamespace;m.x=2;

``` namespaceMyNamespace{exportletx:number}letm =MyNamespace;m.x=2; ```

namespaceMyNamespace{

namespace

MyNamespace

exportletx:number

export

letm =MyNamespace;

m.x=2;

收起深色代码主题复制namespaceMyNamespace{exportletx:number}MyNamespace.x=2;

``` namespaceMyNamespace{exportletx:number}MyNamespace.x=2; ```

MyNamespace.x=2;

不支持命名空间中的非声明语句

规则：arkts-no-ns-statements

在ArkTS中，命名空间用于定义标志符可见范围，只在编译时有效。因此，不支持命名空间中的非声明语句。可以将非声明语句写在函数中。

收起深色代码主题复制namespaceA {exportletx:numberx =1;}

``` namespaceA {exportletx:numberx =1;} ```

namespaceA {

x =1;

收起深色代码主题复制namespaceA {exportletx:numberexportfunctioninit() {x =1;}}// 调用初始化函数来执行A.init();

``` namespaceA {exportletx:numberexportfunctioninit() {x =1;}}// 调用初始化函数来执行A.init(); ```

exportfunctioninit() {

init

// 调用初始化函数来执行

A.init();

不支持require和import赋值表达式

规则：arkts-no-require

ArkTS不支持通过require导入，也不支持import赋值表达式，改用import。

收起深色代码主题复制importm =require('mod')

``` importm =require('mod') ```

importm =require('mod')

import

require

'mod'

收起深色代码主题复制import*asmfrom'mod'

``` import*asmfrom'mod' ```

import*asmfrom'mod'

from

不支持export = ...语法

规则：arkts-no-export-assignment

ArkTS不支持export = ...语法，改用常规的export或import。

收起深色代码主题复制// module1export=PointclassPoint{constructor(x:number, y:number) {}staticorigin =newPoint(0,0)}// module2importPt=require('module1')letp =Pt.Point.origin;

``` // module1export=PointclassPoint{constructor(x:number, y:number) {}staticorigin =newPoint(0,0)}// module2importPt=require('module1')letp =Pt.Point.origin; ```

// module1

export=Point

constructor(x:number, y:number) {}

staticorigin =newPoint(0,0)

// module2

importPt=require('module1')

Pt

'module1'

letp =Pt.Point.origin;

origin

收起深色代码主题复制// module1exportclassPoint{constructor(x:number, y:number) {}staticorigin =newPoint(0,0)}// module2import*asPtfrom'module1'letp =Pt.Point.origin

``` // module1exportclassPoint{constructor(x:number, y:number) {}staticorigin =newPoint(0,0)}// module2import*asPtfrom'module1'letp =Pt.Point.origin ```

exportclassPoint{

import*asPtfrom'module1'

letp =Pt.Point.origin

不支持ambient module声明

规则：arkts-no-ambient-decls

由于ArkTS本身有与JavaScript交互的机制，ArkTS不支持ambient module声明。

收起深色代码主题复制declaremodule'someModule'{exportfunctionnormalize(s:string):string;}

``` declaremodule'someModule'{exportfunctionnormalize(s:string):string;} ```

declaremodule'someModule'{

declare

module

'someModule'

exportfunctionnormalize(s:string):string;

normalize

收起深色代码主题复制// 从原始模块中导入需要的内容import{ normalize }from'someModule'

``` // 从原始模块中导入需要的内容import{ normalize }from'someModule' ```

// 从原始模块中导入需要的内容

import{ normalize }from'someModule'

不支持在模块名中使用通配符

规则：arkts-no-module-wildcards

由于在ArkTS中，导入是编译时而非运行时行为，因此，不支持在模块名中使用通配符。

收起深色代码主题复制// 声明declaremodule'*!text'{constcontent:stringexportdefaultcontent}// 使用代码importfileContentfrom'some.txt!text'

``` // 声明declaremodule'*!text'{constcontent:stringexportdefaultcontent}// 使用代码importfileContentfrom'some.txt!text' ```

// 声明

declaremodule'*!text'{

'*!text'

constcontent:string

content

exportdefaultcontent

default

// 使用代码

importfileContentfrom'some.txt!text'

'some.txt!text'

收起深色代码主题复制// 声明declarenamespaceN {functionfoo(x:number):number}// 使用代码import*asmfrom'module'console.log('N.foo called: '+ N.foo(42));

``` // 声明declarenamespaceN {functionfoo(x:number):number}// 使用代码import*asmfrom'module'console.log('N.foo called: '+ N.foo(42)); ```

declarenamespaceN {

functionfoo(x:number):number

import*asmfrom'module'

'module'

console.log('N.foo called: '+ N.foo(42));

'N.foo called: '

不支持通用模块定义(UMD)

规则：arkts-no-umd

ArkTS不支持通用模块定义（UMD）。因为在ArkTS中没有“脚本”的概念（相对于“模块”）。此外，在ArkTS中，导入是编译时而非运行时特性。改用export和import语法。

收起深色代码主题复制// math-lib.d.tsexportconstisPrime(x:number):booleanexportasnamespacemathLib// 脚本中mathLib.isPrime(2)

``` // math-lib.d.tsexportconstisPrime(x:number):booleanexportasnamespacemathLib// 脚本中mathLib.isPrime(2) ```

// math-lib.d.ts

exportconstisPrime(x:number):boolean

isPrime

exportasnamespacemathLib

// 脚本中

mathLib.isPrime(2)

收起深色代码主题复制// math-lib.d.tsnamespacemathLib {exportisPrime(x:number):boolean}// 程序中import{ mathLib }from'math-lib'mathLib.isPrime(2)

``` // math-lib.d.tsnamespacemathLib {exportisPrime(x:number):boolean}// 程序中import{ mathLib }from'math-lib'mathLib.isPrime(2) ```

namespacemathLib {

exportisPrime(x:number):boolean

// 程序中

import{ mathLib }from'math-lib'

'math-lib'

不支持new.target

规则：arkts-no-new-target

ArkTS没有原型的概念，因此不支持new.target。此特性不符合静态类型的原则。

不支持确定赋值断言

规则：arkts-no-definite-assignment

级别：警告

ArkTS不支持确定赋值断言，例如：let v!: T。改为在声明变量的同时为变量赋值。

收起深色代码主题复制letx!:number// 提示：在使用前将x初始化initialize();functioninitialize() {x =10;}console.log('x = '+ x);

``` letx!:number// 提示：在使用前将x初始化initialize();functioninitialize() {x =10;}console.log('x = '+ x); ```

letx!:number// 提示：在使用前将x初始化

// 提示：在使用前将x初始化

initialize();

initialize

functioninitialize() {

x =10;

console.log('x = '+ x);

'x = '

收起深色代码主题复制functioninitialize():number{return10;}letx:number=initialize();console.log('x = '+ x);

``` functioninitialize():number{return10;}letx:number=initialize();console.log('x = '+ x); ```

functioninitialize():number{

return10;

letx:number=initialize();

不支持在原型上赋值

规则：arkts-no-prototype-assignment

ArkTS没有原型的概念，因此不支持在原型上赋值。此特性不符合静态类型的原则。

收起深色代码主题复制letC =function(p) {this.p= p;// 只有在开启noImplicitThis选项时会产生编译时错误}C.prototype= {m() {console.log(this.p);}}C.prototype.q=function(r:string) {returnthis.p== r;}

``` letC =function(p) {this.p= p;// 只有在开启noImplicitThis选项时会产生编译时错误}C.prototype= {m() {console.log(this.p);}}C.prototype.q=function(r:string) {returnthis.p== r;} ```

letC =function(p) {

this.p= p;// 只有在开启noImplicitThis选项时会产生编译时错误

C.prototype= {

prototype

m() {

console.log(this.p);

C.prototype.q=function(r:string) {

q

r:string

returnthis.p== r;

收起深色代码主题复制classC{p:string=''m() {console.log(this.p);}q(r:string) {returnthis.p== r;}}

``` classC{p:string=''m() {console.log(this.p);}q(r:string) {returnthis.p== r;}} ```

p:string=''

q(r:string) {

不支持globalThis

规则：arkts-no-globalthis

由于ArkTS不支持动态更改对象的布局，因此不支持全局作用域和globalThis。

收起深色代码主题复制// 全局文件中varabc =100;// 从上面引用'abc'letx = globalThis.abc;

``` // 全局文件中varabc =100;// 从上面引用'abc'letx = globalThis.abc; ```

// 全局文件中

varabc =100;

// 从上面引用'abc'

letx = globalThis.abc;

abc

收起深色代码主题复制// file1exportletabc:number=100;// file2import*asMfrom'file1'letx = M.abc;

``` // file1exportletabc:number=100;// file2import*asMfrom'file1'letx = M.abc; ```

// file1

exportletabc:number=100;

// file2

import*asMfrom'file1'

'file1'

letx = M.abc;

不支持一些utility类型

规则：arkts-no-utility-types

ArkTS仅支持Partial、Required、Readonly和Record，不支持TypeScript中其他的Utility Types。

对于Partial<T>类型，泛型参数T必须为类或者接口类型。

对于Record类型的对象，通过索引访问到的值的类型是包含undefined的联合类型。

不支持对函数声明属性

规则：arkts-no-func-props

由于ArkTS不支持动态改变函数对象布局，因此，不支持对函数声明属性。

不支持Function.apply和Function.call

规则：arkts-no-func-apply-call

ArkTS不允许使用标准库函数Function.apply和Function.call。标准库使用这些函数来显式设置被调用函数的this参数。在ArkTS中，this的语义仅限于传统的OOP风格，函数体中禁止使用this。

不支持Function.bind

规则：arkts-no-func-bind

ArkTS不允许使用标准库函数Function.bind。标准库使用这些函数来显式设置被调用函数的this参数。在ArkTS中，this的语义仅限于传统的OOP风格，函数体中禁止使用this。

不支持as const断言

规则：arkts-no-as-const

ArkTS不支持as const断言。在标准TypeScript中，as const用于标注字面量的相应字面量类型，而ArkTS不支持字面量类型。

收起深色代码主题复制// 'hello'类型letx ='hello'asconst;// 'readonly [10, 20]'类型lety = [10,20]asconst;// '{ readonly text: 'hello' }'类型letz = {text:'hello'}asconst;

``` // 'hello'类型letx ='hello'asconst;// 'readonly [10, 20]'类型lety = [10,20]asconst;// '{ readonly text: 'hello' }'类型letz = {text:'hello'}asconst; ```

// 'hello'类型

letx ='hello'asconst;

// 'readonly [10, 20]'类型

lety = [10,20]asconst;

// '{ readonly text: 'hello' }'类型

letz = {text:'hello'}asconst;

收起深色代码主题复制// 'string'类型letx:string='hello';// 'number[]'类型lety:number[] = [10,20];classLabel{text:string=''}// 'Label'类型letz:Label= {text:'hello'}

``` // 'string'类型letx:string='hello';// 'number[]'类型lety:number[] = [10,20];classLabel{text:string=''}// 'Label'类型letz:Label= {text:'hello'} ```

// 'string'类型

letx:string='hello';

// 'number[]'类型

lety:number[] = [10,20];

classLabel{

Label

text:string=''

// 'Label'类型

letz:Label= {

text:'hello'

不支持导入断言

规则：arkts-no-import-assertions

由于在ArkTS中，导入是编译时而非运行时特性，因此，ArkTS不支持导入断言。在运行时检查导入的API是否正确，对于静态类型的语言来说是没有意义的。改用常规的import语法。

收起深色代码主题复制import{ obj }from'something.json'assert {type:'json'}

``` import{ obj }from'something.json'assert {type:'json'} ```

import{ obj }from'something.json'assert {type:'json'}

'something.json'

'json'

收起深色代码主题复制// 编译时将检查导入T的正确性import{ something }from'module'

``` // 编译时将检查导入T的正确性import{ something }from'module' ```

// 编译时将检查导入T的正确性

import{ something }from'module'

限制使用标准库

规则：arkts-limited-stdlib

ArkTS不允许使用TypeScript或JavaScript标准库中的某些接口。大部分接口与动态特性有关。ArkTS中禁止使用以下接口：

全局对象的属性和方法：eval

Object：__proto__、__defineGetter__、__defineSetter__、

__lookupGetter__、__lookupSetter__、assign、create、

defineProperties、defineProperty、freeze、

fromEntries、getOwnPropertyDescriptor、getOwnPropertyDescriptors、

getOwnPropertySymbols、getPrototypeOf、

hasOwnProperty、is、isExtensible、isFrozen、

isPrototypeOf、isSealed、preventExtensions、

propertyIsEnumerable、seal、setPrototypeOf

Reflect：apply、construct、defineProperty、deleteProperty、

getOwnPropertyDescriptor、getPrototypeOf、

isExtensible、preventExtensions、

setPrototypeOf

Proxy：handler.apply()、handler.construct()、

handler.defineProperty()、handler.deleteProperty()、handler.get()、

handler.getOwnPropertyDescriptor()、handler.getPrototypeOf()、

handler.has()、handler.isExtensible()、handler.ownKeys()、

handler.preventExtensions()、handler.set()、handler.setPrototypeOf()

强制进行严格类型检查

规则：arkts-strict-typing

在编译阶段，会进行TypeScript严格模式的类型检查，包括：

noImplicitReturns,

strictFunctionTypes,

strictNullChecks,

strictPropertyInitialization。

收起深色代码主题复制// 只有在开启noImplicitReturns选项时会产生编译时错误functionfoo(s:string):string{if(s !='') {console.log(s);returns;}else{console.log(s);}}letn:number=null;// 只有在开启strictNullChecks选项时会产生编译时错误

``` // 只有在开启noImplicitReturns选项时会产生编译时错误functionfoo(s:string):string{if(s !='') {console.log(s);returns;}else{console.log(s);}}letn:number=null;// 只有在开启strictNullChecks选项时会产生编译时错误 ```

// 只有在开启noImplicitReturns选项时会产生编译时错误

functionfoo(s:string):string{

if(s !='') {

returns;

letn:number=null;// 只有在开启strictNullChecks选项时会产生编译时错误

// 只有在开启strictNullChecks选项时会产生编译时错误

收起深色代码主题复制functionfoo(s:string):string{console.log(s);returns;}letn1:number|null=null;letn2:number=0;

``` functionfoo(s:string):string{console.log(s);returns;}letn1:number|null=null;letn2:number=0; ```

letn1:number|null=null;

n1

letn2:number=0;

在定义类时，如果无法在声明时或者构造函数中初始化某实例属性，那么可以使用确定赋值断言符!来消除strictPropertyInitialization的报错。

使用确定赋值断言符会增加代码错误的风险，开发者需要保证该实例属性在被使用前已被赋值，否则可能会产生运行时异常。

使用确定赋值断言符会增加运行时的类型检查，从而增加额外的运行时开销，所以应尽可能避免使用确定赋值断言符。

使用确定赋值断言符将产生warning: arkts-no-definite-assignment。

收起深色代码主题复制classC{name:string// 只有在开启strictPropertyInitialization选项时会产生编译时错误age:number// 只有在开启strictPropertyInitialization选项时会产生编译时错误}letc =newC();

``` classC{name:string// 只有在开启strictPropertyInitialization选项时会产生编译时错误age:number// 只有在开启strictPropertyInitialization选项时会产生编译时错误}letc =newC(); ```

name:string// 只有在开启strictPropertyInitialization选项时会产生编译时错误

// 只有在开启strictPropertyInitialization选项时会产生编译时错误

age:number// 只有在开启strictPropertyInitialization选项时会产生编译时错误

letc =newC();

收起深色代码主题复制classC{name:string=''age!:number// warning: arkts-no-definite-assignmentinitAge(age:number) {this.age= age;}}letc =newC();c.initAge(10);

``` classC{name:string=''age!:number// warning: arkts-no-definite-assignmentinitAge(age:number) {this.age= age;}}letc =newC();c.initAge(10); ```

age!:number// warning: arkts-no-definite-assignment

// warning: arkts-no-definite-assignment

initAge(age:number) {

initAge

c.initAge(10);

不允许通过注释关闭类型检查

规则：arkts-strict-typing-required

在ArkTS中，类型检查不是可选项。不允许通过注释关闭类型检查，不支持使用@ts-ignore和@ts-nocheck。

收起深色代码主题复制// @ts-nocheck// ...// 关闭了类型检查后的代码// ...lets1:string=null;// 没有报错// @ts-ignorelets2:string=null;// 没有报错

``` // @ts-nocheck// ...// 关闭了类型检查后的代码// ...lets1:string=null;// 没有报错// @ts-ignorelets2:string=null;// 没有报错 ```

// @ts-nocheck

// 关闭了类型检查后的代码

lets1:string=null;// 没有报错

s1

// 没有报错

// @ts-ignore

lets2:string=null;// 没有报错

收起深色代码主题复制lets1:string|null=null;// 没有报错，合适的类型lets2:string=null;// 编译时报错

``` lets1:string|null=null;// 没有报错，合适的类型lets2:string=null;// 编译时报错 ```

lets1:string|null=null;// 没有报错，合适的类型

// 没有报错，合适的类型

lets2:string=null;// 编译时报错

// 编译时报错

允许.ets文件import.ets/.ts/.js文件源码, 不允许.ts/.js文件import.ets文件源码

规则：arkts-no-ts-deps

.ets文件可以import.ets/.ts/.js文件源码，但是.ts/.js文件不允许import.ets文件源码。

收起深色代码主题复制// app.etsexportclassC{// ...}// lib.tsimport{ C }from'app'

``` // app.etsexportclassC{// ...}// lib.tsimport{ C }from'app' ```

// app.ets

exportclassC{

// lib.ts

import{ C }from'app'

'app'

收起深色代码主题复制// lib1.etsexportclassC{// ...}// lib2.etsimport{ C }from'lib1'

``` // lib1.etsexportclassC{// ...}// lib2.etsimport{ C }from'lib1' ```

// lib1.ets

// lib2.ets

import{ C }from'lib1'

'lib1'

class不能被用作对象

规则：arkts-no-classes-as-obj

在ArkTS中，class声明的是一个新的类型，不是一个值。因此，不支持将class用作对象（例如将class赋值给一个对象）。

不支持在import语句前使用其他语句

规则：arkts-no-misplaced-imports

在ArkTS中，除动态import语句外，所有import语句需要放在所有其他语句之前。

收起深色代码主题复制classC{s:string=''n:number=0}importfoofrom'module1'

``` classC{s:string=''n:number=0}importfoofrom'module1' ```

importfoofrom'module1'

收起深色代码主题复制importfoofrom'module1'classC{s:string=''n:number=0}import('module2').then(() =>{}).catch(() =>{})// 动态import

``` importfoofrom'module1'classC{s:string=''n:number=0}import('module2').then(() =>{}).catch(() =>{})// 动态import ```

import('module2').then(() =>{}).catch(() =>{})// 动态import

'module2'

then

// 动态import

限制使用ESObject类型

规则：arkts-limited-esobj

为了防止动态对象（来自.ts/.js文件）在静态代码（.ets文件）中的滥用，ESObject类型在ArkTS中的使用是受限的。唯一允许使用ESObject类型的场景是将其用在局部变量的声明中。ESObject类型变量的赋值也是受限的，只能被来自跨语言调用的对象赋值，例如：ESObject、any、unknown、匿名类型等类型的变量。禁止使用静态类型的值（在.ets文件中定义的）初始化ESObject类型变量。ESObject类型变量只能用在跨语言调用的函数里或者赋值给另一个ESObject类型变量。

收起深色代码主题复制// lib.d.tsdeclarefunctionfoo():any;declarefunctionbar(a:any):number;// main.etslete0:ESObject=foo();// 编译时错误：ESObject类型只能用于局部变量functionf() {lete1 =foo();// 编译时错误：e1的类型是anylete2:ESObject=1;// 编译时错误：不能用非动态值初始化ESObject类型变量lete3:ESObject= {};// 编译时错误：不能用非动态值初始化ESObject类型变量lete4:ESObject= [];// 编译时错误：不能用非动态值初始化ESObject类型变量lete5:ESObject='';// 编译时错误：不能用非动态值初始化ESObject类型变量e5['prop'];// 编译时错误：不能访问ESObject类型变量的属性e5[1];// 编译时错误：不能访问ESObject类型变量的属性e5.prop;// 编译时错误：不能访问ESObject类型变量的属性lete6:ESObject=foo();// OK，显式标注ESObject类型lete7 = e6;// OK，使用ESObject类型赋值bar(e7);// OK，ESObject类型变量传给跨语言调用的函数}

``` // lib.d.tsdeclarefunctionfoo():any;declarefunctionbar(a:any):number;// main.etslete0:ESObject=foo();// 编译时错误：ESObject类型只能用于局部变量functionf() {lete1 =foo();// 编译时错误：e1的类型是anylete2:ESObject=1;// 编译时错误：不能用非动态值初始化ESObject类型变量lete3:ESObject= {};// 编译时错误：不能用非动态值初始化ESObject类型变量lete4:ESObject= [];// 编译时错误：不能用非动态值初始化ESObject类型变量lete5:ESObject='';// 编译时错误：不能用非动态值初始化ESObject类型变量e5['prop'];// 编译时错误：不能访问ESObject类型变量的属性e5[1];// 编译时错误：不能访问ESObject类型变量的属性e5.prop;// 编译时错误：不能访问ESObject类型变量的属性lete6:ESObject=foo();// OK，显式标注ESObject类型lete7 = e6;// OK，使用ESObject类型赋值bar(e7);// OK，ESObject类型变量传给跨语言调用的函数} ```

// lib.d.ts

declarefunctionfoo():any;

declarefunctionbar(a:any):number;

a:any

// main.ets

lete0:ESObject=foo();// 编译时错误：ESObject类型只能用于局部变量

e0

ESObject

// 编译时错误：ESObject类型只能用于局部变量

functionf() {

lete1 =foo();// 编译时错误：e1的类型是any

// 编译时错误：e1的类型是any

lete2:ESObject=1;// 编译时错误：不能用非动态值初始化ESObject类型变量

e2

// 编译时错误：不能用非动态值初始化ESObject类型变量

lete3:ESObject= {};// 编译时错误：不能用非动态值初始化ESObject类型变量

e3

lete4:ESObject= [];// 编译时错误：不能用非动态值初始化ESObject类型变量

e4

lete5:ESObject='';// 编译时错误：不能用非动态值初始化ESObject类型变量

e5

e5['prop'];// 编译时错误：不能访问ESObject类型变量的属性

'prop'

// 编译时错误：不能访问ESObject类型变量的属性

e5[1];// 编译时错误：不能访问ESObject类型变量的属性

e5.prop;// 编译时错误：不能访问ESObject类型变量的属性

prop

lete6:ESObject=foo();// OK，显式标注ESObject类型

e6

// OK，显式标注ESObject类型

lete7 = e6;// OK，使用ESObject类型赋值

// OK，使用ESObject类型赋值

bar(e7);// OK，ESObject类型变量传给跨语言调用的函数

// OK，ESObject类型变量传给跨语言调用的函数


==================================================
文件: harmonyos-guides_20250424_053923.txt
==================================================

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-more-cases
爬取时间: 2025-04-24 05:39:23
来源: Huawei Developer

arkts-identifiers-as-prop-names

应用代码

收起深色代码主题复制interfaceW {bundleName:stringaction:stringentities:string[]}letwantInfo: W = {'bundleName':'com.huawei.hmos.browser','action':'ohos.want.action.viewData','entities': ['entity.system.browsable']}

收起深色代码主题复制

收起

深色代码主题复制

深色代码主题

复制

``` interfaceW {bundleName:stringaction:stringentities:string[]}letwantInfo: W = {'bundleName':'com.huawei.hmos.browser','action':'ohos.want.action.viewData','entities': ['entity.system.browsable']} ```

interfaceW {

interface

bundleName:string

bundleName

string

action:string

action

entities:string[]

entities

}

letwantInfo: W = {

let

wantInfo

'bundleName':'com.huawei.hmos.browser',

'bundleName'

'com.huawei.hmos.browser'

'action':'ohos.want.action.viewData',

'action'

'ohos.want.action.viewData'

'entities': ['entity.system.browsable']

'entities'

'entity.system.browsable'

建议改法

收起深色代码主题复制interfaceW {bundleName:stringaction:stringentities:string[]}letwantInfo: W = {bundleName:'com.huawei.hmos.browser',action:'ohos.want.action.viewData',entities: ['entity.system.browsable']}

``` interfaceW {bundleName:stringaction:stringentities:string[]}letwantInfo: W = {bundleName:'com.huawei.hmos.browser',action:'ohos.want.action.viewData',entities: ['entity.system.browsable']} ```

bundleName:'com.huawei.hmos.browser',

action:'ohos.want.action.viewData',

entities: ['entity.system.browsable']

arkts-no-any-unknown

按照业务逻辑，将代码中的any, unknown改为具体的类型

收起深色代码主题复制functionprintObj(obj:any) {console.log(obj);}printObj('abc');

``` functionprintObj(obj:any) {console.log(obj);}printObj('abc'); ```

functionprintObj(obj:any) {

function

printObj

obj:any

any

console.log(obj);

console

log

printObj('abc');

'abc'

收起深色代码主题复制functionprintObj(obj:string) {console.log(obj);}printObj('abc');

``` functionprintObj(obj:string) {console.log(obj);}printObj('abc'); ```

functionprintObj(obj:string) {

obj:string

标注JSON.parse返回值类型

收起深色代码主题复制classA{v:number=0s:string=''foo(str:string) {lettmpStr =JSON.parse(str);if(tmpStr.add!=undefined) {this.v= tmpStr.v;this.s= tmpStr.s;}}}

``` classA{v:number=0s:string=''foo(str:string) {lettmpStr =JSON.parse(str);if(tmpStr.add!=undefined) {this.v= tmpStr.v;this.s= tmpStr.s;}}} ```

classA{

class

A

v:number=0

v

number

0

s:string=''

s

''

foo(str:string) {

foo

str:string

lettmpStr =JSON.parse(str);

JSON

parse

if(tmpStr.add!=undefined) {

if

add

undefined

this.v= tmpStr.v;

this

this.s= tmpStr.s;

收起深色代码主题复制classA{v:number=0s:string=''foo(str:string) {lettmpStr:Record<string,Object> =JSON.parse(str);if(tmpStr.add!=undefined) {this.v= tmpStr.vasnumber;this.s= tmpStr.sasstring;}}}

``` classA{v:number=0s:string=''foo(str:string) {lettmpStr:Record<string,Object> =JSON.parse(str);if(tmpStr.add!=undefined) {this.v= tmpStr.vasnumber;this.s= tmpStr.sasstring;}}} ```

lettmpStr:Record<string,Object> =JSON.parse(str);

tmpStr

Record

Object

this.v= tmpStr.vasnumber;

as

this.s= tmpStr.sasstring;

使用Record类型

收起深色代码主题复制functionprintProperties(obj:any) {console.log(obj.name);console.log(obj.value);}

``` functionprintProperties(obj:any) {console.log(obj.name);console.log(obj.value);} ```

functionprintProperties(obj:any) {

printProperties

console.log(obj.name);

name

console.log(obj.value);

value

收起深色代码主题复制functionprintProperties(obj: Record<string,Object>) {console.log(obj.nameasstring);console.log(obj.valueasstring);}

``` functionprintProperties(obj: Record<string,Object>) {console.log(obj.nameasstring);console.log(obj.valueasstring);} ```

functionprintProperties(obj: Record<string,Object>) {

obj: Record<string,Object>

console.log(obj.nameasstring);

console.log(obj.valueasstring);

arkts-no-call-signature

使用函数类型来替代。

收起深色代码主题复制interfaceI {(value:string):void;}functionfoo(fn: I) {fn('abc');}foo((value:string) =>{console.log(value);})

``` interfaceI {(value:string):void;}functionfoo(fn: I) {fn('abc');}foo((value:string) =>{console.log(value);}) ```

interfaceI {

(value:string):void;

void

functionfoo(fn: I) {

fn: I

fn('abc');

fn

foo((value:string) =>{

(value:string) =>

value:string

console.log(value);

})

收起深色代码主题复制typeI =(value:string) =>voidfunctionfoo(fn: I) {fn('abc');}foo((value:string) =>{console.log(value);})

``` typeI =(value:string) =>voidfunctionfoo(fn: I) {fn('abc');}foo((value:string) =>{console.log(value);}) ```

typeI =(value:string) =>void

type

arkts-no-ctor-signatures-type

收起深色代码主题复制classController{value:string=''constructor(value:string) {this.value= value;}}typeControllerConstructor= {new(value:string):Controller;}classMenu{controller:ControllerConstructor=ControllercreateController() {if(this.controller) {returnnewthis.controller(123);}returnnull;}}lett =newMenu();console.log(t.createController()!.value);

``` classController{value:string=''constructor(value:string) {this.value= value;}}typeControllerConstructor= {new(value:string):Controller;}classMenu{controller:ControllerConstructor=ControllercreateController() {if(this.controller) {returnnewthis.controller(123);}returnnull;}}lett =newMenu();console.log(t.createController()!.value); ```

classController{

Controller

value:string=''

constructor(value:string) {

constructor

this.value= value;

typeControllerConstructor= {

ControllerConstructor

new(value:string):Controller;

new

classMenu{

Menu

controller:ControllerConstructor=Controller

controller

createController() {

createController

if(this.controller) {

returnnewthis.controller(123);

return

123

returnnull;

null

lett =newMenu();

console.log(t.createController()!.value);

收起深色代码主题复制classController{value:string=''constructor(value:string) {this.value= value;}}typeControllerConstructor=() =>Controller;classMenu{controller:ControllerConstructor=() =>{returnnewController('abc');}createController() {if(this.controller) {returnthis.controller();}returnnull;}}lett:Menu=newMenu();console.log(t.createController()!.value);

``` classController{value:string=''constructor(value:string) {this.value= value;}}typeControllerConstructor=() =>Controller;classMenu{controller:ControllerConstructor=() =>{returnnewController('abc');}createController() {if(this.controller) {returnthis.controller();}returnnull;}}lett:Menu=newMenu();console.log(t.createController()!.value); ```

typeControllerConstructor=() =>Controller;

() =>

controller:ControllerConstructor=() =>{

returnnewController('abc');

returnthis.controller();

lett:Menu=newMenu();

t

arkts-no-indexed-signatures

使用Record类型来替代。

收起深色代码主题复制functionfoo(data: { [key:string]:string}) {data['a'] ='a';data['b'] ='b';data['c'] ='c';}

``` functionfoo(data: { [key:string]:string}) {data['a'] ='a';data['b'] ='b';data['c'] ='c';} ```

functionfoo(data: { [key:string]:string}) {

data: { [key:string]:string}

data['a'] ='a';

'a'

data['b'] ='b';

'b'

data['c'] ='c';

'c'

收起深色代码主题复制functionfoo(data: Record<string,string>) {data['a'] ='a';data['b'] ='b';data['c'] ='c';}

``` functionfoo(data: Record<string,string>) {data['a'] ='a';data['b'] ='b';data['c'] ='c';} ```

functionfoo(data: Record<string,string>) {

data: Record<string,string>

arkts-no-typing-with-this

收起深色代码主题复制classC{getInstance():this{returnthis;}}

``` classC{getInstance():this{returnthis;}} ```

classC{

C

getInstance():this{

getInstance

returnthis;

收起深色代码主题复制classC{getInstance(): C {returnthis;}}

``` classC{getInstance(): C {returnthis;}} ```

getInstance(): C {

arkts-no-ctor-prop-decls

收起深色代码主题复制classPerson{constructor(readonlyname:string) {}getName():string{returnthis.name;}}

``` classPerson{constructor(readonlyname:string) {}getName():string{returnthis.name;}} ```

classPerson{

Person

constructor(readonlyname:string) {}

readonlyname:string

readonly

getName():string{

getName

returnthis.name;

收起深色代码主题复制classPerson{name:stringconstructor(name:string) {this.name= name;}getName():string{returnthis.name;}}

``` classPerson{name:stringconstructor(name:string) {this.name= name;}getName():string{returnthis.name;}} ```

name:string

constructor(name:string) {

this.name= name;

arkts-no-ctor-signatures-iface

收起深色代码主题复制classController{value:string=''constructor(value:string) {this.value= value;}}interfaceControllerConstructor{new(value:string):Controller;}classMenu{controller:ControllerConstructor=ControllercreateController() {if(this.controller) {returnnewthis.controller('abc');}returnnull;}}lett =newMenu();console.log(t.createController()!.value);

``` classController{value:string=''constructor(value:string) {this.value= value;}}interfaceControllerConstructor{new(value:string):Controller;}classMenu{controller:ControllerConstructor=ControllercreateController() {if(this.controller) {returnnewthis.controller('abc');}returnnull;}}lett =newMenu();console.log(t.createController()!.value); ```

interfaceControllerConstructor{

returnnewthis.controller('abc');

arkts-no-props-by-index

可以转换成Record类型，用来访问对象的属性。

收起深色代码主题复制import{ router }from'@kit.ArkUI';letparams:Object= router.getParams();letfunNum:number= params['funNum'];lettarget:string= params['target'];

``` import{ router }from'@kit.ArkUI';letparams:Object= router.getParams();letfunNum:number= params['funNum'];lettarget:string= params['target']; ```

import{ router }from'@kit.ArkUI';

import

from

'@kit.ArkUI'

letparams:Object= router.getParams();

params

getParams

letfunNum:number= params['funNum'];

funNum

'funNum'

lettarget:string= params['target'];

target

'target'

收起深色代码主题复制import{ router }from'@kit.ArkUI';letparams = router.getParams()asRecord<string,string|number>;letfunNum:number= params.funNumasnumber;lettarget:string= params.targetasstring;

``` import{ router }from'@kit.ArkUI';letparams = router.getParams()asRecord<string,string|number>;letfunNum:number= params.funNumasnumber;lettarget:string= params.targetasstring; ```

letparams = router.getParams()asRecord<string,string|number>;

letfunNum:number= params.funNumasnumber;

lettarget:string= params.targetasstring;

arkts-no-inferred-generic-params

收起深色代码主题复制classA{str:string=''}classBextendsA{}classCextendsA{}letarr:Array<A> = [];letoriginMenusMap:Map<string, C> =newMap(arr.map(item=>[item.str, (iteminstanceofC) ?item:null]));

``` classA{str:string=''}classBextendsA{}classCextendsA{}letarr:Array<A> = [];letoriginMenusMap:Map<string, C> =newMap(arr.map(item=>[item.str, (iteminstanceofC) ?item:null])); ```

str:string=''

str

classBextendsA{}

B

extends

classCextendsA{}

letarr:Array<A> = [];

arr

Array

letoriginMenusMap:Map<string, C> =newMap(arr.map(item=>[item.str, (iteminstanceofC) ?item:null]));

originMenusMap

Map

map

item=>

item

instanceof

收起深色代码主题复制classA{str:string=''}classBextendsA{}classCextendsA{}letarr:Array<A> = [];letoriginMenusMap:Map<string, C |null> =newMap<string, C |null>(arr.map<[string, C |null]>(item=>[item.str, (iteminstanceofC) ?item:null]));

``` classA{str:string=''}classBextendsA{}classCextendsA{}letarr:Array<A> = [];letoriginMenusMap:Map<string, C |null> =newMap<string, C |null>(arr.map<[string, C |null]>(item=>[item.str, (iteminstanceofC) ?item:null])); ```

letoriginMenusMap:Map<string, C |null> =newMap<string, C |null>(arr.map<[string, C |null]>(item=>[item.str, (iteminstanceofC) ?item:null]));

原因

(item instanceof C) ? item: null 需要声明类型为C | null，由于编译器无法推导出map的泛型类型参数，需要显式标注。

arkts-no-regexp-literals

收起深色代码主题复制letregex:RegExp=/\s*/g;

``` letregex:RegExp=/\s*/g; ```

letregex:RegExp=/\s*/g;

regex

RegExp

/\s*/g

收起深色代码主题复制letregexp:RegExp=newRegExp('\\s*','g');

``` letregexp:RegExp=newRegExp('\\s*','g'); ```

letregexp:RegExp=newRegExp('\\s*','g');

regexp

'\\s*'

'g'

如果正则表达式中使用了标志符，需要将其作为new RegExp()的参数。

arkts-no-untyped-obj-literals

从SDK中导入类型，标注object literal类型

收起深色代码主题复制constarea = {pixels:newArrayBuffer(8),offset:0,stride:8,region: {size: {height:1,width:2},x:0,y:0}}

``` constarea = {pixels:newArrayBuffer(8),offset:0,stride:8,region: {size: {height:1,width:2},x:0,y:0}} ```

constarea = {

const

pixels:newArrayBuffer(8),

pixels

ArrayBuffer

8

offset:0,

offset

stride:8,

stride

region: {size: {height:1,width:2},x:0,y:0}

region

size

height

1

width

2

x

y

收起深色代码主题复制import{ image }from'@kit.ImageKit';constarea: image.PositionArea= {pixels:newArrayBuffer(8),offset:0,stride:8,region: {size: {height:1,width:2},x:0,y:0}}

``` import{ image }from'@kit.ImageKit';constarea: image.PositionArea= {pixels:newArrayBuffer(8),offset:0,stride:8,region: {size: {height:1,width:2},x:0,y:0}} ```

import{ image }from'@kit.ImageKit';

'@kit.ImageKit'

constarea: image.PositionArea= {

area

PositionArea

用class为object literal标注类型，需要class的构造函数无参数

收起深色代码主题复制classTest{value:number=1constructor(value:number) {this.value= value;}}lett:Test= {value:2};

``` classTest{value:number=1constructor(value:number) {this.value= value;}}lett:Test= {value:2}; ```

classTest{

Test

value:number=1

constructor(value:number) {

value:number

lett:Test= {value:2};

建议改法1

收起深色代码主题复制// 去除构造函数classTest{value:number=1}lett:Test= {value:2};

``` // 去除构造函数classTest{value:number=1}lett:Test= {value:2}; ```

// 去除构造函数

建议改法2

收起深色代码主题复制// 使用newclassTest{value:number=1constructor(value:number) {this.value= value;}}lett:Test=newTest(2);

``` // 使用newclassTest{value:number=1constructor(value:number) {this.value= value;}}lett:Test=newTest(2); ```

// 使用new

lett:Test=newTest(2);

收起深色代码主题复制classC{value:number=1constructor(n:number) {if(n <0) {thrownewError('Negative');}this.value= n;}}lets: C =newC(-2);//抛出异常lett: C = {value: -2};//ArkTS不支持

``` classC{value:number=1constructor(n:number) {if(n <0) {thrownewError('Negative');}this.value= n;}}lets: C =newC(-2);//抛出异常lett: C = {value: -2};//ArkTS不支持 ```

constructor(n:number) {

n:number

if(n <0) {

thrownewError('Negative');

throw

Error

'Negative'

this.value= n;

lets: C =newC(-2);//抛出异常

//抛出异常

lett: C = {value: -2};//ArkTS不支持

//ArkTS不支持

例如在上面的例子中，如果允许使用C来标注object literal的类型，那么上述代码中的变量t会导致行为的二义性。ArkTS禁止通过object literal来绕过这一行为。

用class/interface为object literal标注类型，需要使用identifier作为object literal的key

收起深色代码主题复制classTest{value:number=0}letarr:Test[] = [{'value':1},{'value':2},{'value':3}]

``` classTest{value:number=0}letarr:Test[] = [{'value':1},{'value':2},{'value':3}] ```

value:number=0

letarr:Test[] = [

{

'value':1

'value'

},

'value':2

'value':3

3

]

收起深色代码主题复制classTest{value:number=0}letarr:Test[] = [{value:1},{value:2},{value:3}]

``` classTest{value:number=0}letarr:Test[] = [{value:1},{value:2},{value:3}] ```

value:1

value:2

value:3

使用Record为object literal标注类型，需要使用字符串作为object literal的key

收起深色代码主题复制letobj:Record<string,number|string> = {value:123,name:'abc'}

``` letobj:Record<string,number|string> = {value:123,name:'abc'} ```

letobj:Record<string,number|string> = {

obj

value:123,

name:'abc'

收起深色代码主题复制letobj:Record<string,number|string> = {'value':123,'name':'abc'}

``` letobj:Record<string,number|string> = {'value':123,'name':'abc'} ```

'value':123,

'name':'abc'

'name'

函数参数类型包含index signature

收起深色代码主题复制functionfoo(obj: { [key:string]:string}):string{if(obj !=undefined&& obj !=null) {returnobj.value1+ obj.value2;}return'';}

``` functionfoo(obj: { [key:string]:string}):string{if(obj !=undefined&& obj !=null) {returnobj.value1+ obj.value2;}return'';} ```

functionfoo(obj: { [key:string]:string}):string{

obj: { [key:string]:string}

if(obj !=undefined&& obj !=null) {

returnobj.value1+ obj.value2;

value1

value2

return'';

收起深色代码主题复制functionfoo(obj: Record<string,string>):string{if(obj !=undefined&& obj !=null) {returnobj.value1+ obj.value2;}return'';}

``` functionfoo(obj: Record<string,string>):string{if(obj !=undefined&& obj !=null) {returnobj.value1+ obj.value2;}return'';} ```

functionfoo(obj: Record<string,string>):string{

obj: Record<string,string>

函数实参使用了object literal

收起深色代码主题复制(fn) => {fn({value:123,name:''});}

``` (fn) => {fn({value:123,name:''});} ```

(fn) => {

fn({value:123,name:''});

收起深色代码主题复制classT{value:number=0name:string=''}(fn:(v: T) =>void) => {fn({value:123,name:''});}

``` classT{value:number=0name:string=''}(fn:(v: T) =>void) => {fn({value:123,name:''});} ```

classT{

T

name:string=''

(fn:(v: T) =>void) => {

(v: T) =>

v: T

class/interface 中包含方法

收起深色代码主题复制interfaceT {foo(value:number):number}lett:T = {foo:(value) =>{returnvalue } };

``` interfaceT {foo(value:number):number}lett:T = {foo:(value) =>{returnvalue } }; ```

interfaceT {

foo(value:number):number

lett:T = {foo:(value) =>{returnvalue } };

(value) =>

收起深色代码主题复制interfaceT {foo:(value:number) =>number}lett:T = {foo:(value) =>{returnvalue } };

``` interfaceT {foo:(value:number) =>number}lett:T = {foo:(value) =>{returnvalue } }; ```

foo:(value:number) =>number

(value:number) =>

收起深色代码主题复制classT{foo:(value:number) =>number=(value:number) =>{returnvalue;}}lett:T =newT();

``` classT{foo:(value:number) =>number=(value:number) =>{returnvalue;}}lett:T =newT(); ```

foo:(value:number) =>number=(value:number) =>{

returnvalue;

lett:T =newT();

class/interface中声明的方法应该被所有class的实例共享。ArkTS不支持通过object literal改写实例方法。ArkTS支持函数类型的属性。

export default对象

收起深色代码主题复制exportdefault{onCreate() {// ...},onDestroy() {// ...}}

``` exportdefault{onCreate() {// ...},onDestroy() {// ...}} ```

exportdefault{

export

default

onCreate() {

onCreate

// ...

onDestroy() {

onDestroy

收起深色代码主题复制classTest{onCreate() {// ...}onDestroy() {// ...}}exportdefaultnewTest()

``` classTest{onCreate() {// ...}onDestroy() {// ...}}exportdefaultnewTest() ```

exportdefaultnewTest()

通过导入namespace获取类型

收起深色代码主题复制// test.d.etsdeclarenamespacetest {interfaceI {id:string;type:number;}functionfoo(name:string, option: I):void;}exportdefaulttest;// app.etsimport{ test }from'test';letoption = {id:'',type:0};test.foo('', option);

``` // test.d.etsdeclarenamespacetest {interfaceI {id:string;type:number;}functionfoo(name:string, option: I):void;}exportdefaulttest;// app.etsimport{ test }from'test';letoption = {id:'',type:0};test.foo('', option); ```

// test.d.ets

declarenamespacetest {

declare

namespace

id:string;

id

type:number;

functionfoo(name:string, option: I):void;

name:string, option: I

exportdefaulttest;

// app.ets

import{ test }from'test';

'test'

letoption = {id:'',type:0};

test.foo('', option);

收起深色代码主题复制// test.d.etsdeclarenamespacetest {interfaceI {id:string;type:number;}functionfoo(name:string, option: I):void;}exportdefaulttest;// app.etsimport{ test }from'test';letoption: test.I= {id:'',type:0};test.foo('', option);

``` // test.d.etsdeclarenamespacetest {interfaceI {id:string;type:number;}functionfoo(name:string, option: I):void;}exportdefaulttest;// app.etsimport{ test }from'test';letoption: test.I= {id:'',type:0};test.foo('', option); ```

letoption: test.I= {id:'',type:0};

option

I

对象字面量缺少类型，根据test.foo分析可以得知，option的类型来源于声明文件，那么只需要将类型导入即可。

注意到在test.d.ets中，I是定义在namespace中的，所以在ets文件中，先导入namespace，再通过名称获取相应的类型。

object literal传参给Object类型

收起深色代码主题复制functionemit(event:string, ...args:Object[]):void{}emit('', {'action':11,'outers':false});

``` functionemit(event:string, ...args:Object[]):void{}emit('', {'action':11,'outers':false}); ```

functionemit(event:string, ...args:Object[]):void{}

emit

event:string, ...args:Object[]

emit('', {

'action':11,

11

'outers':false

'outers'

false

});

收起深色代码主题复制functionemit(event:string, ...args:Object[]):void{}letemitArg:Record<string,number|boolean> = {'action':11,'outers':false}emit('', emitArg);

``` functionemit(event:string, ...args:Object[]):void{}letemitArg:Record<string,number|boolean> = {'action':11,'outers':false}emit('', emitArg); ```

letemitArg:Record<string,number|boolean> = {

emitArg

boolean

emit('', emitArg);

arkts-no-obj-literals-as-types

收起深色代码主题复制typePerson= {name:string,age:number}

``` typePerson= {name:string,age:number} ```

typePerson= {name:string,age:number}

age

收起深色代码主题复制interfacePerson{name:string,age:number}

``` interfacePerson{name:string,age:number} ```

interfacePerson{

name:string,

age:number

arkts-no-noninferrable-arr-literals

收起深色代码主题复制letpermissionList = [{name:'设备信息',value:'用于分析设备的续航、通话、上网、SIM卡故障等'},{name:'麦克风',value:'用于反馈问题单时增加语音'},{name:'存储',value:'用于反馈问题单时增加本地文件附件'}]

``` letpermissionList = [{name:'设备信息',value:'用于分析设备的续航、通话、上网、SIM卡故障等'},{name:'麦克风',value:'用于反馈问题单时增加语音'},{name:'存储',value:'用于反馈问题单时增加本地文件附件'}] ```

letpermissionList = [

{name:'设备信息',value:'用于分析设备的续航、通话、上网、SIM卡故障等'},

'设备信息'

'用于分析设备的续航、通话、上网、SIM卡故障等'

{name:'麦克风',value:'用于反馈问题单时增加语音'},

'麦克风'

'用于反馈问题单时增加语音'

{name:'存储',value:'用于反馈问题单时增加本地文件附件'}

'存储'

'用于反馈问题单时增加本地文件附件'

为对象字面量声明类型

收起深色代码主题复制classPermissionItem{name?:stringvalue?:string}letpermissionList:PermissionItem[] = [{name:'设备信息',value:'用于分析设备的续航、通话、上网、SIM卡故障等'},{name:'麦克风',value:'用于反馈问题单时增加语音'},{name:'存储',value:'用于反馈问题单时增加本地文件附件'}]

``` classPermissionItem{name?:stringvalue?:string}letpermissionList:PermissionItem[] = [{name:'设备信息',value:'用于分析设备的续航、通话、上网、SIM卡故障等'},{name:'麦克风',value:'用于反馈问题单时增加语音'},{name:'存储',value:'用于反馈问题单时增加本地文件附件'}] ```

classPermissionItem{

PermissionItem

name?:string

value?:string

letpermissionList:PermissionItem[] = [

permissionList

arkts-no-method-reassignment

收起深色代码主题复制classC{add(left:number,right:number):number{returnleft + right;}}functionsub(left:number, right:number):number{returnleft - right;}letc1 =newC();c1.add= sub;

``` classC{add(left:number,right:number):number{returnleft + right;}}functionsub(left:number, right:number):number{returnleft - right;}letc1 =newC();c1.add= sub; ```

add(left:number,right:number):number{

left

right

returnleft + right;

functionsub(left:number, right:number):number{

sub

left:number, right:number

returnleft - right;

letc1 =newC();

c1.add= sub;

收起深色代码主题复制classC{add:(left:number, right:number) =>number=(left:number, right:number) =>{returnleft + right;}}functionsub(left:number, right:number):number{returnleft - right;}letc1 =newC();c1.add= sub;

``` classC{add:(left:number, right:number) =>number=(left:number, right:number) =>{returnleft + right;}}functionsub(left:number, right:number):number{returnleft - right;}letc1 =newC();c1.add= sub; ```

add:(left:number, right:number) =>number=

(left:number, right:number) =>

(left:number, right:number) =>{

arkts-no-polymorphic-unops

收起深色代码主题复制leta = +'5';letb = -'5';letc = ~'5';letd = +'string';

``` leta = +'5';letb = -'5';letc = ~'5';letd = +'string'; ```

leta = +'5';

'5'

letb = -'5';

letc = ~'5';

letd = +'string';

'string'

收起深色代码主题复制leta =Number.parseInt('5');letb = -Number.parseInt('5');letc = ~Number.parseInt('5');letd =newNumber('string');

``` leta =Number.parseInt('5');letb = -Number.parseInt('5');letc = ~Number.parseInt('5');letd =newNumber('string'); ```

leta =Number.parseInt('5');

Number

parseInt

letb = -Number.parseInt('5');

letc = ~Number.parseInt('5');

letd =newNumber('string');

arkts-no-type-query

收起深色代码主题复制// module1.tsclassC{value:number=0}exportletc =newC()// module2.tsimport{ c }from'./module1'lett:typeofc = {value:123};

``` // module1.tsclassC{value:number=0}exportletc =newC()// module2.tsimport{ c }from'./module1'lett:typeofc = {value:123}; ```

// module1.ts

exportletc =newC()

// module2.ts

import{ c }from'./module1'

'./module1'

lett:typeofc = {value:123};

typeof

收起深色代码主题复制// module1.tsclassC{value:number=0}export{ C }// module2.tsimport{ C }from'./module1'lett: C = {value:123};

``` // module1.tsclassC{value:number=0}export{ C }// module2.tsimport{ C }from'./module1'lett: C = {value:123}; ```

export{ C }

import{ C }from'./module1'

lett: C = {value:123};

arkts-no-in

使用Object.keys判断属性是否存在

收起深色代码主题复制functiontest(str:string, obj: Record<string,Object>) {returnstrinobj;}

``` functiontest(str:string, obj: Record<string,Object>) {returnstrinobj;} ```

functiontest(str:string, obj: Record<string,Object>) {

test

str:string, obj: Record<string,Object>

returnstrinobj;

in

收起深色代码主题复制functiontest(str:string, obj: Record<string,Object>) {for(letiofObject.keys(obj)) {if(i == str) {returntrue;}}returnfalse;}

``` functiontest(str:string, obj: Record<string,Object>) {for(letiofObject.keys(obj)) {if(i == str) {returntrue;}}returnfalse;} ```

for(letiofObject.keys(obj)) {

for

of

keys

if(i == str) {

returntrue;

true

returnfalse;

arkts-no-destruct-assignment

收起深色代码主题复制letmap =newMap<string,string>([['a','a'], ['b','b']]);for(let[key, value]ofmap) {console.log(key);console.log(value);}

``` letmap =newMap<string,string>([['a','a'], ['b','b']]);for(let[key, value]ofmap) {console.log(key);console.log(value);} ```

letmap =newMap<string,string>([['a','a'], ['b','b']]);

for(let[key, value]ofmap) {

console.log(key);

使用数组

收起深色代码主题复制letmap =newMap<string,string>([['a','a'], ['b','b']]);for(letarrofmap) {letkey = arr[0];letvalue = arr[1];console.log(key);console.log(value);}

``` letmap =newMap<string,string>([['a','a'], ['b','b']]);for(letarrofmap) {letkey = arr[0];letvalue = arr[1];console.log(key);console.log(value);} ```

for(letarrofmap) {

letkey = arr[0];

letvalue = arr[1];

arkts-no-types-in-catch

收起深色代码主题复制import{BusinessError}from'@kit.BasicServicesKit'try{// ...}catch(e:BusinessError) {console.error(e.message, e.code);}

``` import{BusinessError}from'@kit.BasicServicesKit'try{// ...}catch(e:BusinessError) {console.error(e.message, e.code);} ```

import{BusinessError}from'@kit.BasicServicesKit'

BusinessError

'@kit.BasicServicesKit'

try{

try

}catch(e:BusinessError) {

catch

e

console.error(e.message, e.code);

error

message

code

收起深色代码主题复制import{BusinessError}from'@kit.BasicServicesKit'try{// ...}catch(error) {lete:BusinessError= errorasBusinessError;console.error(e.message, e.code);}

``` import{BusinessError}from'@kit.BasicServicesKit'try{// ...}catch(error) {lete:BusinessError= errorasBusinessError;console.error(e.message, e.code);} ```

}catch(error) {

lete:BusinessError= errorasBusinessError;

arkts-no-for-in

收起深色代码主题复制interfacePerson{[name:string]:string}letp:Person= {name:'tom',age:'18'};for(lettinp) {console.log(p[t]);// log: "tom", "18"}

``` interfacePerson{[name:string]:string}letp:Person= {name:'tom',age:'18'};for(lettinp) {console.log(p[t]);// log: "tom", "18"} ```

[name:string]:string

letp:Person= {

p

name:'tom',

'tom'

age:'18'

'18'

};

for(lettinp) {

console.log(p[t]);// log: "tom", "18"

// log: "tom", "18"

收起深色代码主题复制letp:Record<string,string> = {'name':'tom','age':'18'};for(leteleofObject.entries(p)) {console.log(ele[1]);// log: "tom", "18"}

``` letp:Record<string,string> = {'name':'tom','age':'18'};for(leteleofObject.entries(p)) {console.log(ele[1]);// log: "tom", "18"} ```

letp:Record<string,string> = {

'name':'tom',

'age':'18'

'age'

for(leteleofObject.entries(p)) {

entries

console.log(ele[1]);// log: "tom", "18"

arkts-no-mapped-types

收起深色代码主题复制classC{a:number=0b:number=0c:number=0}typeOptionsFlags= {[Propertyinkeyof C]:string}

``` classC{a:number=0b:number=0c:number=0}typeOptionsFlags= {[Propertyinkeyof C]:string} ```

a:number=0

a

b:number=0

b

c:number=0

c

typeOptionsFlags= {

OptionsFlags

[Propertyinkeyof C]:string

Property

收起深色代码主题复制classC{a:number=0b:number=0c:number=0}typeOptionsFlags=Record<keyof C,string>

``` classC{a:number=0b:number=0c:number=0}typeOptionsFlags=Record<keyof C,string> ```

typeOptionsFlags=Record<keyof C,string>

arkts-limited-throw

收起深色代码主题复制import{BusinessError}from'@kit.BasicServicesKit'functionThrowError(error: BusinessError) {throwerror;}

``` import{BusinessError}from'@kit.BasicServicesKit'functionThrowError(error: BusinessError) {throwerror;} ```

functionThrowError(error: BusinessError) {

ThrowError

error: BusinessError

throwerror;

收起深色代码主题复制import{BusinessError}from'@kit.BasicServicesKit'functionThrowError(error: BusinessError) {throwerrorasError;}

``` import{BusinessError}from'@kit.BasicServicesKit'functionThrowError(error: BusinessError) {throwerrorasError;} ```

throwerrorasError;

throw语句中值的类型必须为Error或者其继承类，如果继承类是一个泛型，会有编译期报错。建议使用as将类型转换为Error。

arkts-no-standalone-this

函数内使用this

收起深色代码主题复制functionfoo() {console.log(this.value);}letobj = {value:'abc'};foo.apply(obj);

``` functionfoo() {console.log(this.value);}letobj = {value:'abc'};foo.apply(obj); ```

functionfoo() {

console.log(this.value);

letobj = {value:'abc'};

foo.apply(obj);

apply

使用类的方法实现,如果该方法被多个类使用,可以考虑采用继承的机制

收起深色代码主题复制classTest{value:string=''constructor(value:string) {this.value= value}foo() {console.log(this.value);}}letobj:Test=newTest('abc');obj.foo();

``` classTest{value:string=''constructor(value:string) {this.value= value}foo() {console.log(this.value);}}letobj:Test=newTest('abc');obj.foo(); ```

this.value= value

foo() {

letobj:Test=newTest('abc');

obj.foo();

将this作为参数传入

收起深色代码主题复制functionfoo(obj: Test) {console.log(obj.value);}classTest{value:string=''}letobj:Test= {value:'abc'};foo(obj);

``` functionfoo(obj: Test) {console.log(obj.value);}classTest{value:string=''}letobj:Test= {value:'abc'};foo(obj); ```

functionfoo(obj: Test) {

obj: Test

letobj:Test= {value:'abc'};

foo(obj);

建议改法3

将属性作为参数传入

收起深色代码主题复制functionfoo(value:string) {console.log(value);}classTest{value:string=''}letobj:Test= {value:'abc'};foo(obj.value);

``` functionfoo(value:string) {console.log(value);}classTest{value:string=''}letobj:Test= {value:'abc'};foo(obj.value); ```

functionfoo(value:string) {

foo(obj.value);

class的静态方法内使用this

收起深色代码主题复制classTest{staticvalue:number=123staticfoo():number{returnthis.value}}

``` classTest{staticvalue:number=123staticfoo():number{returnthis.value}} ```

staticvalue:number=123

static

staticfoo():number{

returnthis.value

收起深色代码主题复制classTest{staticvalue:number=123staticfoo():number{returnTest.value}}

``` classTest{staticvalue:number=123staticfoo():number{returnTest.value}} ```

returnTest.value

arkts-no-spread

收起深色代码主题复制// test.d.etsdeclarenamespacetest {interfaceI {id:string;type:number;}functionfoo(): I;}exportdefaulttest// app.etsimporttestfrom'test';lett: test.I= {...test.foo(),type:0}

``` // test.d.etsdeclarenamespacetest {interfaceI {id:string;type:number;}functionfoo(): I;}exportdefaulttest// app.etsimporttestfrom'test';lett: test.I= {...test.foo(),type:0} ```

functionfoo(): I;

exportdefaulttest

importtestfrom'test';

lett: test.I= {

...test.foo(),

type:0

收起深色代码主题复制// test.d.etsdeclarenamespacetest {interfaceI {id:string;type:number;}functionfoo(): I;}exportdefaulttest// app.etsimporttestfrom'test';lett: test.I= test.foo();t.type=0;

``` // test.d.etsdeclarenamespacetest {interfaceI {id:string;type:number;}functionfoo(): I;}exportdefaulttest// app.etsimporttestfrom'test';lett: test.I= test.foo();t.type=0; ```

lett: test.I= test.foo();

t.type=0;

ArkTS中，对象布局在编译期是确定的。如果需要将一个对象的所有属性展开赋值给另一个对象可以通过逐个属性赋值语句完成。在本例中，需要展开的对象和赋值的目标对象类型恰好相同，可以通过改变该对象属性的方式重构代码。

arkts-no-ctor-signatures-funcs

在class内声明属性，而不是在构造函数上。

收起深色代码主题复制classController{value:string=''constructor(value:string) {this.value= value}}typeControllerConstructor=new(value:string) =>Controller;classMenu{controller:ControllerConstructor=ControllercreateController() {if(this.controller) {returnnewthis.controller('abc');}returnnull;}}lett =newMenu()console.log(t.createController()!.value)

``` classController{value:string=''constructor(value:string) {this.value= value}}typeControllerConstructor=new(value:string) =>Controller;classMenu{controller:ControllerConstructor=ControllercreateController() {if(this.controller) {returnnewthis.controller('abc');}returnnull;}}lett =newMenu()console.log(t.createController()!.value) ```

typeControllerConstructor=new(value:string) =>Controller;

lett =newMenu()

console.log(t.createController()!.value)

收起深色代码主题复制classController{value:string=''constructor(value:string) {this.value= value;}}typeControllerConstructor=() =>Controller;classMenu{controller:ControllerConstructor=() =>{returnnewController('abc') }createController() {if(this.controller) {returnthis.controller();}returnnull;}}lett:Menu=newMenu();console.log(t.createController()!.value);

``` classController{value:string=''constructor(value:string) {this.value= value;}}typeControllerConstructor=() =>Controller;classMenu{controller:ControllerConstructor=() =>{returnnewController('abc') }createController() {if(this.controller) {returnthis.controller();}returnnull;}}lett:Menu=newMenu();console.log(t.createController()!.value); ```

controller:ControllerConstructor=() =>{returnnewController('abc') }

arkts-no-globalthis

由于无法为globalThis添加静态类型，只能通过查找的方式访问globalThis的属性，造成额外的性能开销。另外，无法为globalThis的属性标记类型，无法保证对这些属性操作的安全和高性能。因此ArkTS不支持globalThis。

建议按照业务逻辑根据import/export语法实现数据在不同模块的传递。

必要情况下，可以通过构造的单例对象来实现全局对象的功能。(说明：不能在har中定义单例对象，har在打包时会在不同的hap中打包两份，无法实现单例。)

构造单例对象

收起深色代码主题复制// 构造单例对象exportclassGlobalContext{privateconstructor() {}privatestaticinstance:GlobalContext;private_objects =newMap<string,Object>();publicstaticgetContext():GlobalContext{if(!GlobalContext.instance) {GlobalContext.instance=newGlobalContext();}returnGlobalContext.instance;}getObject(value:string):Object|undefined{returnthis._objects.get(value);}setObject(key:string,objectClass:Object):void{this._objects.set(key, objectClass);}}

``` // 构造单例对象exportclassGlobalContext{privateconstructor() {}privatestaticinstance:GlobalContext;private_objects =newMap<string,Object>();publicstaticgetContext():GlobalContext{if(!GlobalContext.instance) {GlobalContext.instance=newGlobalContext();}returnGlobalContext.instance;}getObject(value:string):Object|undefined{returnthis._objects.get(value);}setObject(key:string,objectClass:Object):void{this._objects.set(key, objectClass);}} ```

// 构造单例对象

exportclassGlobalContext{

GlobalContext

privateconstructor() {}

private

privatestaticinstance:GlobalContext;

instance

private_objects =newMap<string,Object>();

publicstaticgetContext():GlobalContext{

public

getContext

if(!GlobalContext.instance) {

GlobalContext.instance=newGlobalContext();

returnGlobalContext.instance;

getObject(value:string):Object|undefined{

getObject

returnthis._objects.get(value);

_objects

get

setObject(key:string,objectClass:Object):void{

setObject

key

objectClass

this._objects.set(key, objectClass);

set

收起深色代码主题复制// file1.tsexportclassTest{value:string='';foo():void{globalThis.value=this.value;}}// file2.tsglobalThis.value;

``` // file1.tsexportclassTest{value:string='';foo():void{globalThis.value=this.value;}}// file2.tsglobalThis.value; ```

// file1.ts

exportclassTest{

value:string='';

foo():void{

globalThis.value=this.value;

// file2.ts

globalThis.value;

收起深色代码主题复制// file1.tsimport{GlobalContext}from'../GlobalContext'exportclassTest{value:string='';foo():void{GlobalContext.getContext().setObject('value',this.value);}}// file2.tsimport{GlobalContext}from'../GlobalContext'GlobalContext.getContext().getObject('value');

``` // file1.tsimport{GlobalContext}from'../GlobalContext'exportclassTest{value:string='';foo():void{GlobalContext.getContext().setObject('value',this.value);}}// file2.tsimport{GlobalContext}from'../GlobalContext'GlobalContext.getContext().getObject('value'); ```

import{GlobalContext}from'../GlobalContext'

'../GlobalContext'

GlobalContext.getContext().setObject('value',this.value);

GlobalContext.getContext().getObject('value');

arkts-no-func-apply-bind-call

使用标准库中接口

收起深色代码主题复制letarr:number[] = [1,2,3,4];letstr =String.fromCharCode.apply(null,Array.from(arr));

``` letarr:number[] = [1,2,3,4];letstr =String.fromCharCode.apply(null,Array.from(arr)); ```

letarr:number[] = [1,2,3,4];

4

letstr =String.fromCharCode.apply(null,Array.from(arr));

String

fromCharCode

收起深色代码主题复制letarr:number[] = [1,2,3,4];letstr =String.fromCharCode(...Array.from(arr));

``` letarr:number[] = [1,2,3,4];letstr =String.fromCharCode(...Array.from(arr)); ```

letstr =String.fromCharCode(...Array.from(arr));

bind定义方法

收起深色代码主题复制classA{value:string=''foo:Function=() =>{}}classTest{value:string='1234'obj: A = {value:this.value,foo:this.foo.bind(this)}foo() {console.log(this.value);}}

``` classA{value:string=''foo:Function=() =>{}}classTest{value:string='1234'obj: A = {value:this.value,foo:this.foo.bind(this)}foo() {console.log(this.value);}} ```

foo:Function=() =>{}

Function

value:string='1234'

'1234'

obj: A = {

value:this.value,

foo:this.foo.bind(this)

bind

收起深色代码主题复制classA{value:string=''foo:Function=() =>{}}classTest{value:string='1234'obj: A = {value:this.value,foo: ():void=>this.foo()}foo() {console.log(this.value);}}

``` classA{value:string=''foo:Function=() =>{}}classTest{value:string='1234'obj: A = {value:this.value,foo: ():void=>this.foo()}foo() {console.log(this.value);}} ```

foo: ():void=>this.foo()

void=>

收起深色代码主题复制classA{value:string=''foo:Function=() =>{}}classTest{value:string='1234'foo:() =>void=() =>{console.log(this.value);}obj: A = {value:this.value,foo:this.foo}}

``` classA{value:string=''foo:Function=() =>{}}classTest{value:string='1234'foo:() =>void=() =>{console.log(this.value);}obj: A = {value:this.value,foo:this.foo}} ```

foo:() =>void=() =>{

foo:this.foo

使用apply

收起深色代码主题复制classA{value:string;constructor(value:string) {this.value= value;}foo() {console.log(this.value);}}leta1 =newA('1');leta2 =newA('2');a1.foo();a1.foo.apply(a2);

``` classA{value:string;constructor(value:string) {this.value= value;}foo() {console.log(this.value);}}leta1 =newA('1');leta2 =newA('2');a1.foo();a1.foo.apply(a2); ```

value:string;

leta1 =newA('1');

'1'

leta2 =newA('2');

'2'

a1.foo();

a1.foo.apply(a2);

收起深色代码主题复制classA{value:string;constructor(value:string) {this.value= value;}foo() {this.fooApply(this);}fooApply(a: A) {console.log(a.value);}}leta1 =newA('1');leta2 =newA('2');a1.foo();a1.fooApply(a2);

``` classA{value:string;constructor(value:string) {this.value= value;}foo() {this.fooApply(this);}fooApply(a: A) {console.log(a.value);}}leta1 =newA('1');leta2 =newA('2');a1.foo();a1.fooApply(a2); ```

this.fooApply(this);

fooApply

fooApply(a: A) {

a: A

console.log(a.value);

a1.fooApply(a2);

arkts-limited-stdlib

Object.fromEntries()

收起深色代码主题复制letentries =newMap([['foo',123],['bar',456]]);letobj =Object.fromEntries(entries);

``` letentries =newMap([['foo',123],['bar',456]]);letobj =Object.fromEntries(entries); ```

letentries =newMap([

['foo',123],

'foo'

['bar',456]

'bar'

456

]);

letobj =Object.fromEntries(entries);

fromEntries

收起深色代码主题复制letentries =newMap([['foo',123],['bar',456]]);letobj:Record<string,Object> = {};entries.forEach((value, key) =>{if(key !=undefined&& key !=null) {obj[key] = value;}})

``` letentries =newMap([['foo',123],['bar',456]]);letobj:Record<string,Object> = {};entries.forEach((value, key) =>{if(key !=undefined&& key !=null) {obj[key] = value;}}) ```

letobj:Record<string,Object> = {};

entries.forEach((value, key) =>{

forEach

(value, key) =>

value, key

if(key !=undefined&& key !=null) {

obj[key] = value;

使用Number的属性和方法

ArkTS不允许使用全局对象的属性和方法： Infinity, NaN, isFinite, isNaN, parseFloat, parseInt

可以使用Number的属性和方法： Infinity, NaN, isFinite, isNaN, parseFloat, parseInt

收起深色代码主题复制NaN;isFinite(123);parseInt('123');

``` NaN;isFinite(123);parseInt('123'); ```

NaN;

NaN

isFinite(123);

isFinite

parseInt('123');

'123'

收起深色代码主题复制Number.NaN;Number.isFinite(123);Number.parseInt('123');

``` Number.NaN;Number.isFinite(123);Number.parseInt('123'); ```

Number.NaN;

Number.isFinite(123);

Number.parseInt('123');

arkts-strict-typing(StrictModeError)

strictPropertyInitialization

收起深色代码主题复制interfaceI {name:string}classA{}classTest{a:number;b:string;c:boolean;d: I;e: A;}

``` interfaceI {name:string}classA{}classTest{a:number;b:string;c:boolean;d: I;e: A;} ```

classA{}

a:number;

b:string;

c:boolean;

d: I;

d

e: A;

收起深色代码主题复制interfaceI {name:string}classA{}classTest{a:number;b:string;c:boolean;d: I = {name:'abc'};e: A |null=null;constructor(a:number, b:string, c:boolean) {this.a= a;this.b= b;this.c= c;}}

``` interfaceI {name:string}classA{}classTest{a:number;b:string;c:boolean;d: I = {name:'abc'};e: A |null=null;constructor(a:number, b:string, c:boolean) {this.a= a;this.b= b;this.c= c;}} ```

d: I = {name:'abc'};

e: A |null=null;

constructor(a:number, b:string, c:boolean) {

a:number, b:string, c:boolean

this.a= a;

this.b= b;

this.c= c;

Type *** | null is not assignable to type ***

收起深色代码主题复制classA{bar() {}}functionfoo(n:number) {if(n ===0) {returnnull;}returnnewA();}functiongetNumber() {return5;}leta:A =foo(getNumber());a.bar();

``` classA{bar() {}}functionfoo(n:number) {if(n ===0) {returnnull;}returnnewA();}functiongetNumber() {return5;}leta:A =foo(getNumber());a.bar(); ```

bar() {}

bar

functionfoo(n:number) {

if(n ===0) {

returnnewA();

functiongetNumber() {

getNumber

return5;

5

leta:A =foo(getNumber());

a.bar();

收起深色代码主题复制classA{bar() {}}functionfoo(n:number) {if(n ===0) {returnnull;}returnnewA();}functiongetNumber() {return5;}leta: A |null=foo(getNumber());a?.bar();

``` classA{bar() {}}functionfoo(n:number) {if(n ===0) {returnnull;}returnnewA();}functiongetNumber() {return5;}leta: A |null=foo(getNumber());a?.bar(); ```

leta: A |null=foo(getNumber());

a?.bar();

严格属性初始化检查

在class中，如果一个属性没有初始化，且没有在构造函数中被赋值，那么ArkTS将报错。

1.一般情况下，建议按照业务逻辑在声明时初始化属性，或者在构造函数中为属性赋值。如：

收起深色代码主题复制//code with errorclassTest{value:numberflag:boolean}//方式一，在声明时初始化classTest{value:number=0flag:boolean=false}//方式二，在构造函数中赋值classTest{value:numberflag:booleanconstructor(value:number, flag:boolean) {this.value= value;this.flag= flag;}}

``` //code with errorclassTest{value:numberflag:boolean}//方式一，在声明时初始化classTest{value:number=0flag:boolean=false}//方式二，在构造函数中赋值classTest{value:numberflag:booleanconstructor(value:number, flag:boolean) {this.value= value;this.flag= flag;}} ```

//code with error

flag:boolean

flag

//方式一，在声明时初始化

flag:boolean=false

//方式二，在构造函数中赋值

constructor(value:number, flag:boolean) {

value:number, flag:boolean

this.flag= flag;

2.对于对象类型（包括函数类型）A，如果不确定如何初始化，建议按照以下方式之一进行初始化

 方式(i) prop: A | null = null

 方式(ii) prop?: A

 方式三(iii) prop： A | undefined = undefined

从性能角度来说，null类型只用在编译期的类型检查中，对虚拟机的性能无影响。而undefined | A被视为联合类型，运行时可能有额外的开销。

从代码可读性、简洁性的角度来说，prop?:A是prop： A | undefined = undefined的语法糖，推荐使用可选属性的写法

严格函数类型检查

收起深色代码主题复制functionfoo(fn: (value?:string) =>void, value:string):void{}foo((value:string) =>{},'');//error

``` functionfoo(fn: (value?:string) =>void, value:string):void{}foo((value:string) =>{},'');//error ```

functionfoo(fn: (value?:string) =>void, value:string):void{}

fn: (value?:string) =>void, value:string

foo((value:string) =>{},'');//error

//error

收起深色代码主题复制functionfoo(fn: (value?:string) =>void, value:string):void{}foo((value?:string) =>{},'');

``` functionfoo(fn: (value?:string) =>void, value:string):void{}foo((value?:string) =>{},''); ```

foo((value?:string) =>{},'');

(value?:string) =>

例如，在以下的例子中，如果编译期不开启严格函数类型的检查，那么该段代码可以编译通过，但是在运行时会产生非预期的行为。具体来看，在foo的函数体中，一个undefined被传入fn（这是可以的，因为fn可以接受undefined），但是在代码第6行foo的调用点，传入的(value： string) => { console.log(value.toUpperCase()) }的函数实现中，始终将参数value当做string类型，允许其调用toUpperCase方法。如果不开启严格函数类型的检查，那么这段代码在运行时，会出现在undefined上无法找到属性的错误。

收起深色代码主题复制functionfoo(fn: (value?:string) =>void, value:string):void{letv:string|undefined=undefined;fn(v);}foo((value:string) =>{console.log(value.toUpperCase()) },'');// Cannot read properties of undefined (reading 'toUpperCase')

``` functionfoo(fn: (value?:string) =>void, value:string):void{letv:string|undefined=undefined;fn(v);}foo((value:string) =>{console.log(value.toUpperCase()) },'');// Cannot read properties of undefined (reading 'toUpperCase') ```

functionfoo(fn: (value?:string) =>void, value:string):void{

letv:string|undefined=undefined;

fn(v);

foo((value:string) =>{console.log(value.toUpperCase()) },'');// Cannot read properties of undefined (reading 'toUpperCase')

toUpperCase

// Cannot read properties of undefined (reading 'toUpperCase')

为了避免运行时的非预期行为，如果在编译时开启了严格类型检查，这段代码将编译不通过，从而可以提醒开发者修改代码，保证程序安全。

严格空值检查

收起深色代码主题复制classTest{privatevalue?:stringpublicprintValue () {console.log(this.value.toLowerCase());}}lett =newTest();t.printValue();

``` classTest{privatevalue?:stringpublicprintValue () {console.log(this.value.toLowerCase());}}lett =newTest();t.printValue(); ```

privatevalue?:string

publicprintValue () {

console.log(this.value.toLowerCase());

toLowerCase

lett =newTest();

t.printValue();

printValue

在编写代码时，建议减少可空类型的使用。如果对变量、属性标记了可空类型，那么在使用它们之间，需要进行空值的判断，根据是否为空值处理不同的逻辑。

收起深色代码主题复制classTest{privatevalue?:stringpublicprintValue () {if(this.value) {console.log(this.value.toLowerCase());}}}lett =newTest();t.printValue();

``` classTest{privatevalue?:stringpublicprintValue () {if(this.value) {console.log(this.value.toLowerCase());}}}lett =newTest();t.printValue(); ```

if(this.value) {

在第一段代码中，如果编译期不开启严格空值检查，那么该段代码可以编译通过，但是在运行时会产生非预期的行为。这是因为t的属性value为undefined（这是因为value?: string是value: string | undefined = undefined的语法糖），在第11行调用printValue方法时，由于在该方法体内未对this.value的值进行空值检查，而直接按照string类型访问其属性，这就导致了运行时的错误。为了避免运行时的非预期行为，如果在编译时开起来严格空值检查，这段代码将编译不通过从而可以提醒开发者修改代码（如按照第二段代码的方式），保证程序安全。

函数返回类型不匹配

收起深色代码主题复制classTest{handleClick:(action:string, externInfo?:string) =>void|null=null;}

``` classTest{handleClick:(action:string, externInfo?:string) =>void|null=null;} ```

handleClick:(action:string, externInfo?:string) =>void|null=null;

handleClick

(action:string, externInfo?:string) =>

action:string, externInfo?:string

在这种写法下，函数返回类型被解析为 void | undefined，需要添加括号用来区分union类型。

收起深色代码主题复制classTest{handleClick: ((action:string, externInfo?:string) =>void) |null=null;}

``` classTest{handleClick: ((action:string, externInfo?:string) =>void) |null=null;} ```

handleClick: ((action:string, externInfo?:string) =>void) |null=null;

'***' is of type 'unknown'

收起深色代码主题复制try{}catch(error) {console.log(error.message);}

``` try{}catch(error) {console.log(error.message);} ```

console.log(error.message);

收起深色代码主题复制import{BusinessError}from'@kit.BasicServicesKit'try{}catch(error) {console.log((errorasBusinessError).message);}

``` import{BusinessError}from'@kit.BasicServicesKit'try{}catch(error) {console.log((errorasBusinessError).message);} ```

console.log((errorasBusinessError).message);

Type '*** | null' is not assignable to type '***'

收起深色代码主题复制classA{value:numberconstructor(value:number) {this.value= value;}}functionfoo(v:number): A |null{if(v >0) {returnnewA(v);}returnnull;}leta: A =foo();

``` classA{value:numberconstructor(value:number) {this.value= value;}}functionfoo(v:number): A |null{if(v >0) {returnnewA(v);}returnnull;}leta: A =foo(); ```

functionfoo(v:number): A |null{

v:number

if(v >0) {

returnnewA(v);

leta: A =foo();

修改变量a的类型：let a: A | null = foo()。

收起深色代码主题复制classA{value:numberconstructor(value:number) {this.value= value;}}functionfoo(v:number): A |null{if(v >0) {returnnewA(v);}returnnull;}leta: A |null=foo(123);if(a !=null) {// 非空分支}else{// 处理null}

``` classA{value:numberconstructor(value:number) {this.value= value;}}functionfoo(v:number): A |null{if(v >0) {returnnewA(v);}returnnull;}leta: A |null=foo(123);if(a !=null) {// 非空分支}else{// 处理null} ```

leta: A |null=foo(123);

if(a !=null) {

// 非空分支

}else{

else

// 处理null

如果可以断定此处调用foo一定返回非空值，可以使用非空断言!。

收起深色代码主题复制classA{value:numberconstructor(value:number) {this.value= value;}}functionfoo(v:number): A |null{if(v >0) {returnnewA(v);}returnnull;}leta: A =foo(123)!;

``` classA{value:numberconstructor(value:number) {this.value= value;}}functionfoo(v:number): A |null{if(v >0) {returnnewA(v);}returnnull;}leta: A =foo(123)!; ```

leta: A =foo(123)!;

Cannot invoke an object which possibly 'undefined'

收起深色代码主题复制interfaceA {foo?:() =>void}leta:A = {foo:() =>{} };a.foo();

``` interfaceA {foo?:() =>void}leta:A = {foo:() =>{} };a.foo(); ```

interfaceA {

foo?:() =>void

leta:A = {foo:() =>{} };

a.foo();

收起深色代码主题复制interfaceA {foo:() =>void}leta: A = {foo:() =>{} };a.foo();

``` interfaceA {foo:() =>void}leta: A = {foo:() =>{} };a.foo(); ```

foo:() =>void

leta: A = {foo:() =>{} };

收起深色代码主题复制interfaceA {foo?:() =>void}leta: A = {foo:() =>{} };if(a.foo) {a.foo();}

``` interfaceA {foo?:() =>void}leta: A = {foo:() =>{} };if(a.foo) {a.foo();} ```

if(a.foo) {

在原先代码的定义中，foo是可选属性，有可能为undefined，对undefined的调用会导致报错。建议按照业务逻辑判断是否需要为可选属性。如果确实需要，那么在访问到该属性后需要进行空值检查。

Variable '***' is used before being assigned

收起深色代码主题复制classTest{value:number=0}leta:Testtry{a = {value:1};}catch(e) {a.value;}a.value;

``` classTest{value:number=0}leta:Testtry{a = {value:1};}catch(e) {a.value;}a.value; ```

leta:Test

a = {value:1};

}catch(e) {

a.value;

收起深色代码主题复制classTest{value:number=0}leta:Test|null=null;try{a = {value:1};}catch(e) {if(a) {a.value;}}if(a) {a.value;}

``` classTest{value:number=0}leta:Test|null=null;try{a = {value:1};}catch(e) {if(a) {a.value;}}if(a) {a.value;} ```

leta:Test|null=null;

if(a) {

对于primitive types，可以根据业务逻辑赋值，例如0，''，false。

对于对象类型，可以将类型修改为和null的联合类型，并赋值null，使用时需要进行非空检查。

Function lacks ending return statement and return type does not include 'undefined'.

收起深色代码主题复制functionfoo(a:number):number{if(a >0) {returna;}}

``` functionfoo(a:number):number{if(a >0) {returna;}} ```

functionfoo(a:number):number{

a:number

if(a >0) {

returna;

根据业务逻辑，在else分支中返回合适的数值

收起深色代码主题复制functionfoo(a:number):number|undefined{if(a >0) {returna;}return}

``` functionfoo(a:number):number|undefined{if(a >0) {returna;}return} ```

functionfoo(a:number):number|undefined{

arkts-strict-typing-required

收起深色代码主题复制// @ts-nocheckvara:any=123;

``` // @ts-nocheckvara:any=123; ```

// @ts-nocheck

vara:any=123;

var

收起深色代码主题复制leta:number=123;

``` leta:number=123; ```

leta:number=123;

ArkTS不支持通过注释的方式绕过严格类型检查。首先将注释（// @ts-nocheck或者// @ts-ignore）删去，再根据报错信息修改其他代码。

Importing ArkTS files to JS and TS files is not allowed

arkts-no-tsdeps

不允许.ts、.js文件import.ets文件源码。

方式1.将.ts文件的后缀修改成ets，按照ArkTS语法规则适配代码。

方式2.将.ets文件中被.ts文件依赖的代码单独抽取到.ts文件中。

arkts-no-special-imports

收起深色代码主题复制importtype{A, B, C, D }from'***'

``` importtype{A, B, C, D }from'***' ```

importtype{A, B, C, D }from'***'

'***'

收起深色代码主题复制import{A, B, C, D }from'***'

``` import{A, B, C, D }from'***' ```

import{A, B, C, D }from'***'

arkts-no-classes-as-obj

使用class构造实例

收起深色代码主题复制classController{value:string=''constructor(value:string) {this.value= value}}interfaceControllerConstructor{new(value:string):Controller;}classMenu{controller:ControllerConstructor=ControllercreateController() {if(this.controller) {returnnewthis.controller('abc');}returnnull;}}lett =newMenu();console.log(t.createController()!.value);

``` classController{value:string=''constructor(value:string) {this.value= value}}interfaceControllerConstructor{new(value:string):Controller;}classMenu{controller:ControllerConstructor=ControllercreateController() {if(this.controller) {returnnewthis.controller('abc');}returnnull;}}lett =newMenu();console.log(t.createController()!.value); ```

收起深色代码主题复制classController{value:string=''constructor(value:string) {this.value= value}}typeControllerConstructor=() =>Controller;classMenu{controller:ControllerConstructor=() =>{returnnewController('abc'); }createController() {if(this.controller) {returnthis.controller();}returnnull;}}lett:Menu=newMenu();console.log(t.createController()!.value);

``` classController{value:string=''constructor(value:string) {this.value= value}}typeControllerConstructor=() =>Controller;classMenu{controller:ControllerConstructor=() =>{returnnewController('abc'); }createController() {if(this.controller) {returnthis.controller();}returnnull;}}lett:Menu=newMenu();console.log(t.createController()!.value); ```

controller:ControllerConstructor=() =>{returnnewController('abc'); }

访问静态属性

收起深色代码主题复制classC1{staticvalue:string='abc'}classC2{staticvalue:string='def'}functiongetValue(obj:any) {returnobj['value'];}console.log(getValue(C1));console.log(getValue(C2));

``` classC1{staticvalue:string='abc'}classC2{staticvalue:string='def'}functiongetValue(obj:any) {returnobj['value'];}console.log(getValue(C1));console.log(getValue(C2)); ```

classC1{

C1

staticvalue:string='abc'

classC2{

C2

staticvalue:string='def'

'def'

functiongetValue(obj:any) {

getValue

returnobj['value'];

console.log(getValue(C1));

console.log(getValue(C2));

收起深色代码主题复制classC1{staticvalue:string='abc'}classC2{staticvalue:string='def'}functiongetC1Value():string{returnC1.value;}functiongetC2Value():string{returnC2.value;}console.log(getC1Value());console.log(getC2Value());

``` classC1{staticvalue:string='abc'}classC2{staticvalue:string='def'}functiongetC1Value():string{returnC1.value;}functiongetC2Value():string{returnC2.value;}console.log(getC1Value());console.log(getC2Value()); ```

functiongetC1Value():string{

getC1Value

returnC1.value;

functiongetC2Value():string{

getC2Value

returnC2.value;

console.log(getC1Value());

console.log(getC2Value());

arkts-no-side-effects-imports

改用动态import

收起深色代码主题复制import'module'

``` import'module' ```

import'module'

'module'

收起深色代码主题复制import('module')

``` import('module') ```

import('module')

arkts-no-func-props

收起深色代码主题复制functionfoo(value:number):void{console.log(value.toString());}foo.add=(left:number, right:number) =>{returnleft + right;}foo.sub=(left:number, right:number) =>{returnleft - right;}

``` functionfoo(value:number):void{console.log(value.toString());}foo.add=(left:number, right:number) =>{returnleft + right;}foo.sub=(left:number, right:number) =>{returnleft - right;} ```

functionfoo(value:number):void{

console.log(value.toString());

toString

foo.add=(left:number, right:number) =>{

foo.sub=(left:number, right:number) =>{

收起深色代码主题复制classFoo{staticfoo(value:number):void{console.log(value.toString());}staticadd(left:number,right:number):number{returnleft + right;}staticsub(left:number,right:number):number{returnleft - right;}}

``` classFoo{staticfoo(value:number):void{console.log(value.toString());}staticadd(left:number,right:number):number{returnleft + right;}staticsub(left:number,right:number):number{returnleft - right;}} ```

classFoo{

Foo

staticfoo(value:number):void{

staticadd(left:number,right:number):number{

staticsub(left:number,right:number):number{

arkts-limited-esobj

收起深色代码主题复制// lib.d.tsdeclarefunctionfoo():any;// main.etslete0:ESObject=foo();functionf() {lete1 =foo();lete2:ESObject=1;lete3:ESObject= {};lete4:ESObject='';}

``` // lib.d.tsdeclarefunctionfoo():any;// main.etslete0:ESObject=foo();functionf() {lete1 =foo();lete2:ESObject=1;lete3:ESObject= {};lete4:ESObject='';} ```

// lib.d.ts

declarefunctionfoo():any;

// main.ets

lete0:ESObject=foo();

e0

ESObject

functionf() {

f

lete1 =foo();

lete2:ESObject=1;

e2

lete3:ESObject= {};

e3

lete4:ESObject='';

e4

收起深色代码主题复制// lib.d.tsdeclarefunctionfoo():any;// main.etsinterfaceI {}functionf() {lete0:ESObject=foo();lete1:ESObject=foo();lete2:number=1;lete3: I = {};lete4:string='';}

``` // lib.d.tsdeclarefunctionfoo():any;// main.etsinterfaceI {}functionf() {lete0:ESObject=foo();lete1:ESObject=foo();lete2:number=1;lete3: I = {};lete4:string='';} ```

interfaceI {}

lete1:ESObject=foo();

e1

lete2:number=1;

lete3: I = {};

lete4:string='';

拷贝

浅拷贝

TypeScript

收起深色代码主题复制functionshallowCopy(obj:object):object{letnewObj = {};Object.assign(newObj, obj);returnnewObj;}

``` functionshallowCopy(obj:object):object{letnewObj = {};Object.assign(newObj, obj);returnnewObj;} ```

functionshallowCopy(obj:object):object{

shallowCopy

obj:object

object

letnewObj = {};

Object.assign(newObj, obj);

assign

returnnewObj;

ArkTS

收起深色代码主题复制functionshallowCopy(obj:object):object{letnewObj:Record<string,Object> = {};for(letkeyofObject.keys(obj)) {newObj[key] = obj[key];}returnnewObj;}

``` functionshallowCopy(obj:object):object{letnewObj:Record<string,Object> = {};for(letkeyofObject.keys(obj)) {newObj[key] = obj[key];}returnnewObj;} ```

letnewObj:Record<string,Object> = {};

newObj

for(letkeyofObject.keys(obj)) {

newObj[key] = obj[key];

深拷贝

收起深色代码主题复制functiondeepCopy(obj:object):object{letnewObj =Array.isArray(obj) ? [] : {};for(letkeyinobj) {if(typeofobj[key] ==='object') {newObj[key] =deepCopy(obj[key]);}else{newObj[key] = obj[key];}}returnnewObj;}

``` functiondeepCopy(obj:object):object{letnewObj =Array.isArray(obj) ? [] : {};for(letkeyinobj) {if(typeofobj[key] ==='object') {newObj[key] =deepCopy(obj[key]);}else{newObj[key] = obj[key];}}returnnewObj;} ```

functiondeepCopy(obj:object):object{

deepCopy

letnewObj =Array.isArray(obj) ? [] : {};

isArray

for(letkeyinobj) {

if(typeofobj[key] ==='object') {

'object'

newObj[key] =deepCopy(obj[key]);

收起深色代码主题复制functiondeepCopy(obj:object):object{letnewObj:Record<string,Object> |Object[] =Array.isArray(obj) ? [] : {};for(letkeyofObject.keys(obj)) {if(typeofobj[key] ==='object') {newObj[key] =deepCopy(obj[key]);}else{newObj[key] = obj[key];}}returnnewObj;}

``` functiondeepCopy(obj:object):object{letnewObj:Record<string,Object> |Object[] =Array.isArray(obj) ? [] : {};for(letkeyofObject.keys(obj)) {if(typeofobj[key] ==='object') {newObj[key] =deepCopy(obj[key]);}else{newObj[key] = obj[key];}}returnnewObj;} ```

letnewObj:Record<string,Object> |Object[] =Array.isArray(obj) ? [] : {};

状态管理使用典型场景

Struct组件外使用状态变量

由于struct和class不同，不建议把this作为参数传递到struct外部使用，避免引起实例引用无法释放的情况，导致内存泄露。建议将状态变量对象传递到struct外面使用，通过修改对象的属性，来触发UI刷新。

不推荐用法

收起深色代码主题复制exportclassMyComponentController{item:MyComponent=null;setItem(item: MyComponent) {this.item= item;}changeText(value:string) {this.item.value= value;}}@ComponentexportdefaultstructMyComponent{publiccontroller:MyComponentController=null;@Statevalue:string='Hello World';build() {Column() {Text(this.value).fontSize(50)}}aboutToAppear() {if(this.controller)this.controller.setItem(this);// 不建议把this作为参数传递到struct外部使用}}@Entry@ComponentstructObjThisOldPage{controller =newMyComponentController();build() {Column() {MyComponent({controller:this.controller})Button('change value').onClick(() =>{this.controller.changeText('Text');})}}}

``` exportclassMyComponentController{item:MyComponent=null;setItem(item: MyComponent) {this.item= item;}changeText(value:string) {this.item.value= value;}}@ComponentexportdefaultstructMyComponent{publiccontroller:MyComponentController=null;@Statevalue:string='Hello World';build() {Column() {Text(this.value).fontSize(50)}}aboutToAppear() {if(this.controller)this.controller.setItem(this);// 不建议把this作为参数传递到struct外部使用}}@Entry@ComponentstructObjThisOldPage{controller =newMyComponentController();build() {Column() {MyComponent({controller:this.controller})Button('change value').onClick(() =>{this.controller.changeText('Text');})}}} ```

exportclassMyComponentController{

MyComponentController

item:MyComponent=null;

MyComponent

setItem(item: MyComponent) {

setItem

item: MyComponent

this.item= item;

changeText(value:string) {

changeText

this.item.value= value;

@Component

exportdefaultstructMyComponent{

publiccontroller:MyComponentController=null;

@Statevalue:string='Hello World';

@State

'Hello World'

build() {

build

Column() {

Column

Text(this.value)

Text

.fontSize(50)

fontSize

50

aboutToAppear() {

aboutToAppear

if(this.controller)

this.controller.setItem(this);// 不建议把this作为参数传递到struct外部使用

// 不建议把this作为参数传递到struct外部使用

@Entry

structObjThisOldPage{

ObjThisOldPage

controller =newMyComponentController();

MyComponent({controller:this.controller})

Button('change value').onClick(() =>{

Button

'change value'

onClick

this.controller.changeText('Text');

'Text'

推荐用法

收起深色代码主题复制classCC{value:string='1';constructor(value:string) {this.value= value;}}exportclassMyComponentController{item:CC=newCC('1');setItem(item: CC) {this.item= item;}changeText(value:string) {this.item.value= value;}}@ComponentexportdefaultstructMyComponent{publiccontroller:MyComponentController|null=null;@Statevalue:CC=newCC('Hello World');build() {Column() {Text(`${this.value.value}`).fontSize(50)}}aboutToAppear() {if(this.controller)this.controller.setItem(this.value);}}@Entry@ComponentstructStyleExample{controller:MyComponentController=newMyComponentController();build() {Column() {MyComponent({controller:this.controller})Button('change value').onClick(() =>{this.controller.changeText('Text');})}}}

``` classCC{value:string='1';constructor(value:string) {this.value= value;}}exportclassMyComponentController{item:CC=newCC('1');setItem(item: CC) {this.item= item;}changeText(value:string) {this.item.value= value;}}@ComponentexportdefaultstructMyComponent{publiccontroller:MyComponentController|null=null;@Statevalue:CC=newCC('Hello World');build() {Column() {Text(`${this.value.value}`).fontSize(50)}}aboutToAppear() {if(this.controller)this.controller.setItem(this.value);}}@Entry@ComponentstructStyleExample{controller:MyComponentController=newMyComponentController();build() {Column() {MyComponent({controller:this.controller})Button('change value').onClick(() =>{this.controller.changeText('Text');})}}} ```

classCC{

CC

value:string='1';

item:CC=newCC('1');

setItem(item: CC) {

item: CC

publiccontroller:MyComponentController|null=null;

@Statevalue:CC=newCC('Hello World');

Text(`${this.value.value}`)

`${this.value.value}`

${this.value.value}

this.controller.setItem(this.value);

structStyleExample{

StyleExample

controller:MyComponentController=newMyComponentController();

Struct支持联合类型的方案

下面这段代码有arkts-no-any-unknown的报错，由于struct不支持泛型，建议使用联合类型，实现自定义组件类似泛型的功能。

收起深色代码主题复制classData{aa:number=11;}@Entry@ComponentstructDatauionOldPage{@Statearray:Data[] = [newData(),newData(),newData()];@BuildercomponentCloser(data: Data) {Text(data.aa+'').fontSize(50)}build() {Row() {Column() {ForEachCom({arrayList:this.array,closer:this.componentCloser})}.width('100%')}.height('100%')}}@ComponentexportstructForEachCom{arrayList:any[];// struct不支持泛型，有arkts-no-any-unknown报错@BuilderParamcloser:(data:any) =>void=this.componentCloser;// struct不支持泛型，有arkts-no-any-unknown报错@BuildercomponentCloser() {}build() {Column() {ForEach(this.arrayList,(item:any) =>{// struct不支持泛型，有arkts-no-any-unknown报错Row() {this.closer(item)}.width('100%').height(200).backgroundColor('#eee')})}}}

``` classData{aa:number=11;}@Entry@ComponentstructDatauionOldPage{@Statearray:Data[] = [newData(),newData(),newData()];@BuildercomponentCloser(data: Data) {Text(data.aa+'').fontSize(50)}build() {Row() {Column() {ForEachCom({arrayList:this.array,closer:this.componentCloser})}.width('100%')}.height('100%')}}@ComponentexportstructForEachCom{arrayList:any[];// struct不支持泛型，有arkts-no-any-unknown报错@BuilderParamcloser:(data:any) =>void=this.componentCloser;// struct不支持泛型，有arkts-no-any-unknown报错@BuildercomponentCloser() {}build() {Column() {ForEach(this.arrayList,(item:any) =>{// struct不支持泛型，有arkts-no-any-unknown报错Row() {this.closer(item)}.width('100%').height(200).backgroundColor('#eee')})}}} ```

classData{

Data

aa:number=11;

aa

structDatauionOldPage{

DatauionOldPage

@Statearray:Data[] = [newData(),newData(),newData()];

array

@Builder

componentCloser(data: Data) {

componentCloser

data: Data

Text(data.aa+'').fontSize(50)

Row() {

Row

ForEachCom({arrayList:this.array,closer:this.componentCloser})

ForEachCom

arrayList

closer

.width('100%')

'100%'

.height('100%')

exportstructForEachCom{

arrayList:any[];// struct不支持泛型，有arkts-no-any-unknown报错

// struct不支持泛型，有arkts-no-any-unknown报错

@BuilderParamcloser:(data:any) =>void=this.componentCloser;// struct不支持泛型，有arkts-no-any-unknown报错

@BuilderParam

(data:any) =>

data:any

componentCloser() {

ForEach(this.arrayList,(item:any) =>{// struct不支持泛型，有arkts-no-any-unknown报错

ForEach

(item:any) =>

item:any

this.closer(item)

}.width('100%').height(200).backgroundColor('#eee')

200

backgroundColor

'#eee'

收起深色代码主题复制classData{aa:number=11;}classModel{aa:string='11';}typeUnionData=Data|Model;@Entry@ComponentstructDatauionPage{array:UnionData[] = [newData(),newData(),newData()];@BuildercomponentCloser(data: UnionData) {if(datainstanceofData) {Text(data.aa+'').fontSize(50)}}build() {Row() {Column() {ForEachCom({arrayList:this.array,closer:this.componentCloser})}.width('100%')}.height('100%')}}@ComponentexportstructForEachCom{arrayList:UnionData[] = [newData(),newData(),newData()];@BuilderParamcloser:(data: UnionData) =>void=this.componentCloser;@BuildercomponentCloser() {}build() {Column() {ForEach(this.arrayList,(item: UnionData) =>{Row() {this.closer(item)}.width('100%').height(200).backgroundColor('#eee')})}}}

``` classData{aa:number=11;}classModel{aa:string='11';}typeUnionData=Data|Model;@Entry@ComponentstructDatauionPage{array:UnionData[] = [newData(),newData(),newData()];@BuildercomponentCloser(data: UnionData) {if(datainstanceofData) {Text(data.aa+'').fontSize(50)}}build() {Row() {Column() {ForEachCom({arrayList:this.array,closer:this.componentCloser})}.width('100%')}.height('100%')}}@ComponentexportstructForEachCom{arrayList:UnionData[] = [newData(),newData(),newData()];@BuilderParamcloser:(data: UnionData) =>void=this.componentCloser;@BuildercomponentCloser() {}build() {Column() {ForEach(this.arrayList,(item: UnionData) =>{Row() {this.closer(item)}.width('100%').height(200).backgroundColor('#eee')})}}} ```

classModel{

Model

aa:string='11';

'11'

typeUnionData=Data|Model;

UnionData

structDatauionPage{

DatauionPage

array:UnionData[] = [newData(),newData(),newData()];

componentCloser(data: UnionData) {

data: UnionData

if(datainstanceofData) {

arrayList:UnionData[] = [newData(),newData(),newData()];

@BuilderParamcloser:(data: UnionData) =>void=this.componentCloser;

(data: UnionData) =>

ForEach(this.arrayList,(item: UnionData) =>{

(item: UnionData) =>

item: UnionData


==================================================
文件: harmonyos-guides_20250424_053936.txt
==================================================

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-high-performance-programming
爬取时间: 2025-04-24 05:39:36
来源: Huawei Developer

概述

本文主要提供应用性能敏感场景下的高性能编程的相关建议，助力开发者开发出高性能的应用。高性能编程实践，是在开发过程中逐步总结出来的一些高性能的写法和建议，在业务功能实现过程中，要同步思考并理解高性能写法的原理，运用到代码逻辑实现中。ArkTS编程规范可参考ArkTS编程规范。

声明与表达式

使用const声明不变的变量

不变的变量推荐使用const声明。

收起深色代码主题复制constindex =10000;// 该变量在后续过程中未发生改变，建议声明成常量

收起深色代码主题复制

收起

深色代码主题复制

深色代码主题

复制

``` constindex =10000;// 该变量在后续过程中未发生改变，建议声明成常量 ```

constindex =10000;// 该变量在后续过程中未发生改变，建议声明成常量

const

10000

// 该变量在后续过程中未发生改变，建议声明成常量

number类型变量避免整型和浮点型混用

针对number类型，运行时在优化时会区分整型和浮点型数据。建议避免在初始化后改变数据类型。

收起深色代码主题复制letintNum =1;intNum =1.1;// 该变量在声明时为整型数据，建议后续不要赋值浮点型数据letdoubleNum =1.1;doubleNum =1;// 该变量在声明时为浮点型数据，建议后续不要赋值整型数据

``` letintNum =1;intNum =1.1;// 该变量在声明时为整型数据，建议后续不要赋值浮点型数据letdoubleNum =1.1;doubleNum =1;// 该变量在声明时为浮点型数据，建议后续不要赋值整型数据 ```

letintNum =1;

let

1

intNum =1.1;// 该变量在声明时为整型数据，建议后续不要赋值浮点型数据

1.1

// 该变量在声明时为整型数据，建议后续不要赋值浮点型数据

letdoubleNum =1.1;

doubleNum =1;// 该变量在声明时为浮点型数据，建议后续不要赋值整型数据

// 该变量在声明时为浮点型数据，建议后续不要赋值整型数据

数值计算避免溢出

常见的可能导致溢出的数值计算包括如下场景，溢出之后，会导致引擎走入慢速的溢出逻辑分支处理，影响后续的性能。

针对加法、减法、乘法、指数运算等运算操作，应避免数值大于INT32_MAX或小于INT32_MIN。

针对&（and）、>>>（无符号右移）等运算操作，应避免数值大于INT32_MAX。

循环中常量提取，减少属性访问次数

在循环中会大量进行一些常量的访问操作，如果该常量在循环中不会改变，可以提取到循环外部，减少属性访问的次数。

收起深色代码主题复制classTime{staticstart:number=0;staticinfo:number[] = [1,2,3,4,5,6,7,8,9,10,11,12];}functiongetNum(num:number):number{lettotal:number=348;for(letindex:number=0x8000; index >0x8; index >>=1) {// 此处会多次对Time的info及start进行查找，并且每次查找出来的值是相同的total += ((Time.info[num -Time.start] & index) !==0) ?1:0;}returntotal;}

``` classTime{staticstart:number=0;staticinfo:number[] = [1,2,3,4,5,6,7,8,9,10,11,12];}functiongetNum(num:number):number{lettotal:number=348;for(letindex:number=0x8000; index >0x8; index >>=1) {// 此处会多次对Time的info及start进行查找，并且每次查找出来的值是相同的total += ((Time.info[num -Time.start] & index) !==0) ?1:0;}returntotal;} ```

classTime{

class

Time

staticstart:number=0;

static

start

number

0

staticinfo:number[] = [1,2,3,4,5,6,7,8,9,10,11,12];

info

2

3

4

5

6

7

8

9

10

11

12

}

functiongetNum(num:number):number{

function

getNum

num:number

lettotal:number=348;

total

348

for(letindex:number=0x8000; index >0x8; index >>=1) {

for

index

0x8000

0x8

// 此处会多次对Time的info及start进行查找，并且每次查找出来的值是相同的

total += ((Time.info[num -Time.start] & index) !==0) ?1:0;

returntotal;

return

优化后代码如下，可以将Time.info[num - Time.start]进行常量提取操作，这样可以大幅减少属性的访问次数，性能收益明显。

收起深色代码主题复制classTime{staticstart:number=0;staticinfo:number[] = [1,2,3,4,5,6,7,8,9,10,11,12];}functiongetNum(num:number):number{lettotal:number=348;constinfo =Time.info[num -Time.start];// 从循环中提取不变量for(letindex:number=0x8000; index >0x8; index >>=1) {if((info & index) !=0) {total++;}}returntotal;}

``` classTime{staticstart:number=0;staticinfo:number[] = [1,2,3,4,5,6,7,8,9,10,11,12];}functiongetNum(num:number):number{lettotal:number=348;constinfo =Time.info[num -Time.start];// 从循环中提取不变量for(letindex:number=0x8000; index >0x8; index >>=1) {if((info & index) !=0) {total++;}}returntotal;} ```

constinfo =Time.info[num -Time.start];// 从循环中提取不变量

// 从循环中提取不变量

if((info & index) !=0) {

if

total++;

函数

建议使用参数传递函数外的变量

使用闭包会造成额外的闭包创建和访问开销。在性能敏感场景中，建议使用参数传递函数外的变量来替代使用闭包。

收起深色代码主题复制letarr = [0,1,2];functionfoo():number{returnarr[0] + arr[1];}foo();

``` letarr = [0,1,2];functionfoo():number{returnarr[0] + arr[1];}foo(); ```

letarr = [0,1,2];

functionfoo():number{

foo

returnarr[0] + arr[1];

foo();

建议使用参数传递函数外的变量来，替代使用闭包。

收起深色代码主题复制letarr = [0,1,2];functionfoo(array:number[]):number{returnarray[0] + array[1];}foo(arr);

``` letarr = [0,1,2];functionfoo(array:number[]):number{returnarray[0] + array[1];}foo(arr); ```

functionfoo(array:number[]):number{

array:number[]

returnarray[0] + array[1];

foo(arr);

避免使用可选参数

函数的可选参数表示参数可能为undefined，在函数内部使用该参数时，需要进行非空值的判断，造成额外的开销。

收起深色代码主题复制functionadd(left?:number, right?:number):number|undefined{if(left !=undefined&& right !=undefined) {returnleft + right;}returnundefined;}

``` functionadd(left?:number, right?:number):number|undefined{if(left !=undefined&& right !=undefined) {returnleft + right;}returnundefined;} ```

functionadd(left?:number, right?:number):number|undefined{

add

left?:number, right?:number

undefined

if(left !=undefined&& right !=undefined) {

returnleft + right;

returnundefined;

根据业务需要，将函数参数声明为必须参数。可以考虑使用默认参数。

收起深色代码主题复制functionadd(left:number=0, right:number=0):number{returnleft + right;}

``` functionadd(left:number=0, right:number=0):number{returnleft + right;} ```

functionadd(left:number=0, right:number=0):number{

left:number=0, right:number=0

数组

数值数组推荐使用TypedArray

如果是涉及纯数值计算的场合，推荐使用TypedArray数据结构。

优化前

收起深色代码主题复制constarr1 =newArray<number>([1,2,3]);constarr2 =newArray<number>([4,5,6]);letres =newArray<number>(3);for(leti =0; i <3; i++) {res[i] = arr1[i] + arr2[i];}

``` constarr1 =newArray<number>([1,2,3]);constarr2 =newArray<number>([4,5,6]);letres =newArray<number>(3);for(leti =0; i <3; i++) {res[i] = arr1[i] + arr2[i];} ```

constarr1 =newArray<number>([1,2,3]);

new

Array

constarr2 =newArray<number>([4,5,6]);

letres =newArray<number>(3);

for(leti =0; i <3; i++) {

res[i] = arr1[i] + arr2[i];

优化后

收起深色代码主题复制consttypedArray1 =newInt8Array([1,2,3]);consttypedArray2 =newInt8Array([4,5,6]);letres =newInt8Array(3);for(leti =0; i <3; i++) {res[i] = typedArray1[i] + typedArray2[i];}

``` consttypedArray1 =newInt8Array([1,2,3]);consttypedArray2 =newInt8Array([4,5,6]);letres =newInt8Array(3);for(leti =0; i <3; i++) {res[i] = typedArray1[i] + typedArray2[i];} ```

consttypedArray1 =newInt8Array([1,2,3]);

Int8Array

consttypedArray2 =newInt8Array([4,5,6]);

letres =newInt8Array(3);

res[i] = typedArray1[i] + typedArray2[i];

避免使用稀疏数组

运行时在分配超过1024大小的数组或者针对稀疏数组，会采用hash表的方式来存储元素。在该模式下，相比于用偏移访问数组元素速度较慢。在代码开发时，应尽量避免数组变成稀疏数组。

收起深色代码主题复制// 直接分配100000大小的数组，运行时会处理成用hash表来存储元素letcount =100000;letresult:number[] =newArray(count);// 创建数组后，直接在9999处赋值，会变成稀疏数组letresult:number[] =newArray();result[9999] =0;

``` // 直接分配100000大小的数组，运行时会处理成用hash表来存储元素letcount =100000;letresult:number[] =newArray(count);// 创建数组后，直接在9999处赋值，会变成稀疏数组letresult:number[] =newArray();result[9999] =0; ```

// 直接分配100000大小的数组，运行时会处理成用hash表来存储元素

letcount =100000;

100000

letresult:number[] =newArray(count);

result

// 创建数组后，直接在9999处赋值，会变成稀疏数组

letresult:number[] =newArray();

result[9999] =0;

9999

避免使用联合类型数组

避免使用联合类型数组。避免在数值数组中混合使用整型数据和浮点型数据。

收起深色代码主题复制letarrNum:number[] = [1,1.1,2];// 数值数组中混合使用整型数据和浮点型数据letarrUnion: (number|string)[] = [1,'hello'];// 联合类型数组

``` letarrNum:number[] = [1,1.1,2];// 数值数组中混合使用整型数据和浮点型数据letarrUnion: (number|string)[] = [1,'hello'];// 联合类型数组 ```

letarrNum:number[] = [1,1.1,2];// 数值数组中混合使用整型数据和浮点型数据

arrNum

// 数值数组中混合使用整型数据和浮点型数据

letarrUnion: (number|string)[] = [1,'hello'];// 联合类型数组

arrUnion

string

'hello'

// 联合类型数组

根据业务需要，将相同类型的数据放置在同一数组中。

收起深色代码主题复制letarrInt:number[] = [1,2,3];letarrDouble:number[] = [0.1,0.2,0.3];letarrString:string[] = ['hello','world'];

``` letarrInt:number[] = [1,2,3];letarrDouble:number[] = [0.1,0.2,0.3];letarrString:string[] = ['hello','world']; ```

letarrInt:number[] = [1,2,3];

arrInt

letarrDouble:number[] = [0.1,0.2,0.3];

arrDouble

0.1

0.2

0.3

letarrString:string[] = ['hello','world'];

arrString

'world'

异常

避免频繁抛出异常

创建异常时会构造异常的栈帧，造成性能损耗。在性能敏感场景下，例如在for循环语句中，避免频繁抛出异常。

收起深色代码主题复制functiondiv(a:number, b:number):number{if(a <=0|| b <=0) {thrownewError('Invalid numbers.')}returna / b}functionsum(num:number):number{letsum =0try{for(lett =1; t <100; t++) {sum +=div(t, num)}}catch(e) {console.log(e.message)}returnsum}

``` functiondiv(a:number, b:number):number{if(a <=0|| b <=0) {thrownewError('Invalid numbers.')}returna / b}functionsum(num:number):number{letsum =0try{for(lett =1; t <100; t++) {sum +=div(t, num)}}catch(e) {console.log(e.message)}returnsum} ```

functiondiv(a:number, b:number):number{

div

a:number, b:number

if(a <=0|| b <=0) {

thrownewError('Invalid numbers.')

throw

Error

'Invalid numbers.'

returna / b

functionsum(num:number):number{

sum

letsum =0

try{

try

for(lett =1; t <100; t++) {

100

sum +=div(t, num)

}catch(e) {

catch

console.log(e.message)

console

log

message

returnsum

收起深色代码主题复制functiondiv(a:number, b:number):number{if(a <=0|| b <=0) {returnNaN}returna / b}functionsum(num:number):number{letsum =0for(lett =1; t <100; t++) {if(t <=0|| num <=0) {console.log('Invalid numbers.')}sum +=div(t, num)}returnsum}

``` functiondiv(a:number, b:number):number{if(a <=0|| b <=0) {returnNaN}returna / b}functionsum(num:number):number{letsum =0for(lett =1; t <100; t++) {if(t <=0|| num <=0) {console.log('Invalid numbers.')}sum +=div(t, num)}returnsum} ```

returnNaN

NaN

if(t <=0|| num <=0) {

console.log('Invalid numbers.')


# 合并文件
合并时间: 2025-05-01 10:12:24

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-package-structure
爬取时间: 2025-05-01 09:24:54
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-desktop-shortcuts
爬取时间: 2025-05-01 09:25:09
来源: Huawei Developer
概述
随着应用的功能越来越复杂，用户在使用应用时，找到某个功能的操作步骤也在变得更加繁琐。为了提升用户体验，可以对应用中常用的功能创建对应的桌面快捷方式，以达到快速启动应用、一键直达特定功能等目的。例如相机应用的 “快速拍照”、便签应用的 “新建便签” 和地图应用的常用地点导航等功能的快捷方式，用户通过快捷方式可以快速进入特定功能页面，既能大大提高操作效率，同时也增加了用户对应用的依赖性。使用快捷方式，还可以实现个性化定制的需求，创建多个快捷方式，以满足个性化的工作流程和操作偏好。
场景介绍
以导航场景为例，当用户使用地图应用导航时，通常是先搜索目的地，然后开始导航。为了提升导航效率和提高操作便捷性，可以给该地图应用添加常去地点的导航快捷方式，如去公司、回家等。添加常去地点（例如公司、家等）的快捷方式后，用户即可通过长按应用图标，打开快捷方式入口，快速开启导航。
快捷方式创建成功后，可以通过以下两种方式快速启动相应的导航功能：
-
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151024.25175015083576206089130416520439:50001231000000:2800:342CEBE0DA22661001E012B9800946DD4A85F82F47F463112DCF119A2F4AB7C3.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151024.20449751271089014444614891691203:50001231000000:2800:8D3DA5D7F7306D7FB176EC11FF571492F6201DB57153F628863B9517BBF9E684.gif)
本文以单HAP包为场景，讲述了快捷方式的实现步骤。多HAP包的场景下， 步骤与单HAP包一致，都是在entry文件夹下进行shortcuts_config.json的创建和module.json5的配置。
实现原理
关键技术
使用shortcuts来配置应用的快捷方式，其标签值为数组，包含四个子标签shortcutId、label、icon、wants。
-  属性名称 含义 bundleName 表示快捷方式的目标包名。 moduleName 表示快捷方式的目标模块名。 abilityName 表示快捷方式的目标组件名。 parameters 表示拉起快捷方式时的自定义数据，仅支持配置字符串类型的数据。其中键值均最大支持1024长度的字符串。
| 属性名称  | 含义  |
| --- | --- |
| bundleName  | 表示快捷方式的目标包名。  |
| moduleName  | 表示快捷方式的目标模块名。  |
| abilityName  | 表示快捷方式的目标组件名。  |
| parameters  | 表示拉起快捷方式时的自定义数据，仅支持配置字符串类型的数据。其中键值均最大支持1024长度的字符串。  |
shortcuts配置完成后，还需要在module.json5配置文件中配置metadata字段来指定应用的快捷方式配置文件，从而完成快捷方式的基本配置。
通过在module.json5配置文件中配置metadata字段的快捷方式是一种在系统中创建的可以快速访问应用程序或特定功能的链接，与卡片的区别在于：快捷方式只允许跳转至某个具体的UIAbility，无法直接跳转至非入口页面，且最多可以配置四个快捷方式。
实现流程
给地图应用添加常用地点的导航快捷方式需要进行如下步骤：
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-cross-module-resource-access
爬取时间: 2025-05-01 09:25:23
来源: Huawei Developer
概述
随着应用复杂度的增加，将应用划分为多个独立的模块有助于提高代码的可维护性和可扩展性。特别是在大型项目中，不同团队负责不同的模块（如HAR/HSP模块），当某些资源（如图标、颜色、字符串等）被多个模块复用时，可以将其集中管理在某个模块中给其他模块使用，从而减少重复定义，便于资源管理，提升开发效率。
在HarmonyOS中应用模块化设计一般使用HAR和HSP来共享资源，本文将介绍如何实现跨模块访问HAR和HSP里面的资源。
跨模块访问HAR资源
跨模块（HAP、HSP或HAR）访问HAR资源和访问模块自身资源一样，可以使用下面两种方法访问资源：
1.  此方法适合简单的、静态的资源引用场景，比如在UI组件中直接引用。通过$('app.type.name')或$rawfile('name')访问资源，其中，app为resources目录中定义的资源；type为资源类型或资源的存放位置；name为资源名，开发者定义资源时确定。
2.  此方法提供的API更为丰富，适用于构建更加复杂的应用逻辑，比如图像效果处理。通过本应用上下文获取ResourceManager后，调用不同资源管理接口访问不同资源。例如：resourceManager.getStringSync('string_in_har1').id可获取字符串资源，推荐使用资源id作为入参的方式使用，这种方式性能更好，具体可以参考：避免使用耗时接口中关ResourceManager的介绍。
在编译构建HAP时，DevEco Studio会从HAP模块及依赖的模块中收集资源文件，如果不同模块下的资源文件出现重名冲突时，DevEco Studio会按照以下优先级进行覆盖（优先级由高到低）：
跨模块访问HSP资源
跨模块（HAP、HSP或HAR）访问HSP资源一般有以下三种方法，下面详细介绍这三种方法的使用场景和优缺点。
1.  使用场景 适合简单的、静态的资源引用场景，比如在UI组件中直接引用。 优点 使用简单，易于理解。 缺点 不能直接获取到值，不方便对数据进行处理。 实现方式 然后使用$r或$rawfile语法，并指定HSP模块名称（HSP模块module.json5中module的name属性），资源访问格式如下： 其中，[hsp]是HSP模块名，type是资源类型，而name是资源名称。下面示例代码中加载的资源来自名为“hsp1”的HSP模块：
2.  使用场景 根据业务逻辑需要对资源文件数据进行处理，比如图片编解码、字符串拼接处理，适合少量数据的使用。 优点 使用相对简单，不需要添加依赖。 缺点 因为需要开发者手动写资源的名称，且使用方无法感知HSP内部的资源名称变化，当引用的数据量比较多的时候，建议使用第三种方法访问资源。 实现方式 通过createModuleContext(context, moduleName)接口创建同应用中不同module的上下文，获取resourceManager对象后，调用不同资源管理接口访问不同资源。
3.  使用场景 根据业务逻辑需要对资源文件数据进行处理，比如图片编解码、字符串拼接处理。 优点 缺点 需要封装管理类，开发稍显复杂。 实现方式 跨包访问HSP内资源时，推荐实现一个资源管理类，以封装对外导出的资源，其具体实现如下。
1.
2.
3.
```typescript
import { ResManager } from 'hsp1';
@Entry
@Component
struct GetHspResource {
aboutToAppear(): void {
let stringInHsp1 = getContext(this).resourceManager.getStringSync(ResManager.getDesc());
Logger.info(`stringInHsp1 is : ${stringInHsp1}`);
}
build() {
Column() {
Text(ResManager.getDesc())
// ...
Image(ResManager.getPic())
// ...
}
// ...
}
}
```
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-program-framework
爬取时间: 2025-05-01 09:25:36
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-jump-between-application
爬取时间: 2025-05-01 09:25:52
来源: Huawei Developer
概述
在现代应用使用场景中，应用间的跳转已成为提升用户体验的核心功能之一。它使用户能够在不同的应用之间快捷切换，从而轻松完成复杂的任务。无论是从购物应用无缝跳转到支付应用完成交易，还是通过推广链接直接进入应用市场进行版本更新，这些操作都涉及到应用间跳转的需求。系统提供了应用间跳转的统一打开体验，典型场景一步直达，适配各种主流场景的跨应用跳转诉求，更多场景（例如导航等）提供系统面板保障打开结果可信，打开体验便捷、一致。
Web页面拉起应用的场景，请参见：Web和应用的跳转与拉起。
实现原理
方案介绍
应用跳转过程中，会从当前正在使用的应用（全文称之为调用方）跳转到需要跳转的目标应用（全文称之为目标方）中，系统为开发者提供了两种主要的应用间跳转方式：App Linking和Deep Linking。
两者都可以实现应用间的快速跳转，但在实现细节、安全表现与用户体验上有着不同的表现。详细请参见应用链接分类。
基于安全性和用户体验的全面考量，建议优先采用App Linking技术。与Deep Linking相比，App Linking提供了更高的安全性，避免了仿冒风险，并提升了用户在应用间跳转时的整体使用体验。
本文将重点介绍App Linking下如何实现应用跳转。
场景示例
以华为商城为例，在华为商城应用已安装与未安装情况下，分别从备忘录应用与浏览器应用打开App Linking地址对应效果。
| 应用是否已安装  | 通过备忘录应用跳转  | 效果示意图  |
| --- | --- | --- |
| 是  | 用户进入备忘录App中点击被分享的商品链接，即可直接跳转至华为商城App的商品详情页。  |   |
| 否  | 用户点击分享的商品链接后，会跳转至浏览器显示链接对应的Web页面，该页面展示的是目标应用在AGC（AppGallery Connect）上注册的URL内容。  |   |
应用是否已安装
通过备忘录应用跳转
效果示意图
是
用户进入备忘录App中点击被分享的商品链接，即可直接跳转至华为商城App的商品详情页。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151025.13402230351270408339630897367405:50001231000000:2800:6658063773ABAE9157C7B4BC9DC2B1D82593637C0CB0AEE6C31665F18CA45220.png)
否
用户点击分享的商品链接后，会跳转至浏览器显示链接对应的Web页面，该页面展示的是目标应用在AGC（AppGallery Connect）上注册的URL内容。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151025.96860963584991498339277070861667:50001231000000:2800:EA90E1ACE51F3B75BD1B95E117FE12B1973E9ADABE56E2936991A77FA8EF606B.png)
| 应用是否已安装  | 通过浏览器应用跳转  | 效果示意图  |
| --- | --- | --- |
| 是  | 用户在浏览器中输入专用URL地址，并选择“打开App”选项，即可直接跳转到华为商城App的商品详情页。  |   |
| 否  | 浏览器页面提供“下载App”选项。用户选择该选项后，会跳转至华为应用市场App的相关应用详情页，以完成应用的下载和安装。  |   |
应用是否已安装
通过浏览器应用跳转
效果示意图
是
用户在浏览器中输入专用URL地址，并选择“打开App”选项，即可直接跳转到华为商城App的商品详情页。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151025.86164354881299976833400536416198:50001231000000:2800:A9EF991EBE604FEDA5A0D6BC3F1A5BCFBA3A44A9419208791F2477811FF059EB.png)
否
浏览器页面提供“下载App”选项。用户选择该选项后，会跳转至华为应用市场App的相关应用详情页，以完成应用的下载和安装。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151025.17357882667167184710524072834813:50001231000000:2800:CC134D5B6DD14DA17F2555103DC18A6F613052C3D5246BF3DB6C75A7B5DF1A3D.png)
应用跳转适配流程
在进入应用跳转开发前，首先需要了解使用App Linking跳转方式开发的整体开发流程，如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151025.50616931616922850249349290901701:50001231000000:2800:FAE7B80CA5FD97C8E0091360C6A8B8AFA39A2F0117E0C29CC61437A426B3A33C.jpg)
目标方配置：目标方需要对外提供经过配置的App Linking链接，具体配置方式请参见被拉起应用开发指导，若遇到问题可以参考常见问题总结。配置过程中有以下建议。
调用方拉起步骤：
拉起指定应用
场景描述
开发者可以在ArkTS页面中通过App Linking实现直接拉起指定应用的功能，这不仅提升了用户的使用体验，还为应用的分享和传播提供了便利，有以下常见场景。
用户从应用市场分享了一个应用给其他用户，希望点击消息可以跳转到对应应用的应用市场详情界面。本章节以社交分享的场景为例介绍实现。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151025.97122263063801192185639337789651:50001231000000:2800:010853B1870486A8A0300B1AC966FFC036FD549D9B27441B80E0D5635BC68A91.gif)
开发流程
1.  目标应用在适配App Linking过程中，如涉及到敏感数据不建议使用URL参数方式接收，而建议使用openLinkOptions的parameters参数进行接收，避免敏感数据泄漏。
拉起指定应用并获取返回结果
场景描述
用户A分享了一个待支付商品给用户B，用户B进入到购物类应用支付后，返回调用方查看支付结果，该场景下会涉及到调用方向目标方传递参数（需要支付的商品），目标方完成操作后携带参数返回给调用方（支付的结果），实现效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151025.80363622167325987996662180062495:50001231000000:2800:5B4C324257A39D798872AC4510AD1A04F0AC7672D04360E33082B90199D6F65D.gif)
开发流程
1.  注意backToCallerAbilityWithResult()需要在module.json5配置文件中配置linkFeature并保证应用已上线应用市场，具体可参考linkFeature标签说明，在该回调中可以取得目标方传递的参数信息，此处取到目标方返回的支付状态码，若返回状态码为200表示成功支付，向用户发出提示。 开发者在开发阶段如需使用一键返回能力，可修改配置/data/service/el1/public/ecological_rule_mgr_service下的"intentInfos":[{"intentListId":10,"SPUList":["pay","intent"]}]进行调试。
拉起指定类型应用
场景描述
在该场景下开发者并不指定某个具体应用，而是以用户意图的角度，由系统查询出当前设备内符合条件的所有应用，由用户自行选择在哪个应用中执行后续逻辑。实际的业务场景例如用户A给用户B分享了一个地理位置，用户B点击该消息后，系统会查询出设备内已安装的所有地图导航类的应用，由用户自行选择在哪个应用中执行后续逻辑操作。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151026.94779248681073905980628631725428:50001231000000:2800:5551F43FDF8AB5D778E86DB09A729355FF941D6514B56ABE4ABD537BA1A99008.gif)
开发流程
以下参考代码以调用方拉起地图导航为例，开发者可以参考拉起指定类型的应用来实现更多类型应用的拉起。
拉起系统应用
HarmonyOS提供封装了部分常用的系统应用的接口，开发者可以通过查询拉起系统应用来使用系统能力。
常见问题总结
如何查看App Linking是否在AGC上配置成功
开发者可通过点击项目内的“增长”下的“App Linking”菜单栏查看App Linking链接地址的配置状态，若为成功则表明AGC上App Linking配置成功。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151026.84613966273601814920182907246195:50001231000000:2800:540993BE1727881E8CEDF3F0AF5EE6D1E83433CFCF2E9A798CEA46394AAA25C8.png)
AGC中App Linking显示配置失败如何解决
问题现象
App Linking菜单栏查看App Linking链接地址的配置状态如下图，显示红色圆点并文本提示失败。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151026.13879907635638465596909519108026:50001231000000:2800:5569458A3202D0F0D5DEFA00CAF6506B94DBF5DE089D639832A1A476DD007EA6.png)
解决措施
若上述检查无误，建议求助网站运维侧人员，共同解决。
AGC上显示了配置成功，但是配置到目标方后无法拉起如何解决
问题现象
AGC上显示链接地址配置成功，但是配置到目标方后，尝试使用openLink()或其他拉起方式，应用并未成功拉起。
可能原因
解决措施
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-web-app-jump-and-pull-up
爬取时间: 2025-05-01 09:26:06
来源: Huawei Developer
概述
在使用ArkTS与ArkWeb进行混合开发时，应用内的部分页面使用了前端相关能力进行了开发，结合Web组件进行了页面加载，在这种场景下涉及到从ArkWeb加载的页面向其他页面跳转，以及从ArkWeb页面拉起应用。
本文将从以下几个方面介绍ArkWeb页面跳转以及拉起应用相关的知识。
ArkWeb页面与ArkTS页面互相跳转
ArkWeb页面跳转ArkWeb页面
开发者在做Hybrid App混合开发时，Web页面的跳转可以直接在前端侧使用HTML提供的a标签来进行跳转，修改href为跳转后的地址即可。
ArkTS页面跳转ArkWeb页面
在HarmonyOS应用开发中，会有Web页面和ArkTS页面互相之间进行跳转的场景，例如列表页用了ArkTS进行开发，而详情页设计上只有简单的内容展示并没有复杂的逻辑操作，于是使用了Web开发并使用了ArkTS中的Web组件进行了加载，在这种场景下，从列表页跳转到详情页就是从ArkTS页面跳转到Web页面，在这种场景下，开发者只需要在ArkTS页面对应的事件回调函数中使用路由栈提供的跳转功能即可实现。关于Navigation组件的使用开发者可以参考：组件导航（Navigation）。
ArkWeb页面跳转ArkTS页面
同样开发者也会有从Web页面跳转到ArkTS页面的场景，例如刚刚的场景中希望返回到ArkTS页面，就是从Web页面跳转回ArkTS页面的场景，在这种场景下，实现步骤如下：
1.  开发者可以根据业务场景自行定义href，此处的定义的href并不作为a标签跳转后的地址，而是会在ArkTS侧进行跳转拦截，当检测到该链接时执行自定义逻辑。
ArkWeb页面指定应用跳转
开发者在HarmonyOS应用内使用了Web页面做了部分页面的实现，同时出于推广，或者需要在其他应用内处理一些逻辑等目的，需要拉起其他的指定应用，例如跳转到支付应用进行支付，在这些场景下，就需要用到指定应用跳转的相关知识，首先在实现方案上，指定应用跳转建议使用如下两种方案：
方案1：使用Deep Linking。
```json
"querySchemes": [
"appScheme"
],
```
```typescript
Navigation(this.navPathStack) {
Column() {
Web({
src: $rawfile('index2.html'),
controller: this.controller
})
.zoomAccess(false)
.onLoadIntercept((event) => {
const url: string = event.data.getRequestUrl();
if (url === 'third-party://pages/toThirdApp') {
const link: string = "appScheme://www.test.com:80/path1";
if (!bundleManager.canOpenLink(link)) {
return true;
}
// Configuration parameter.
const openLinkOptions: OpenLinkOptions = {
appLinkingOnly: false,
parameters: {
name: 'test'
}
};
// Open the application using the openLink interface.
this.context.openLink(link, openLinkOptions).then(() => {
console.info('open link success.');
}).catch((err: BusinessError) => {
console.error(`open link failed. Code is ${err.code}, message is ${err.message}`);
})
}
return url !== 'resource://rawfile/index2.html';
})
}
}
```
方案2：当开发者希望无论应用是否已安装，用户都可以访问到链接对应的内容，当应用安装时优先打开应用去呈现内容；当应用未安装时，则打开浏览器呈现Web版的内容，就可以使用App Linking的方式，App Linking配置可以参考：使用App Linking实现应用间跳转，以下为在ArkWeb页面中使用App Linking进行跳转的操作步骤。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151026.23640522986989007793349390555313:50001231000000:2800:2929561462BD57940E72A27368EED5D69977900F95454045A2C789682165F841.png)
因此，Deep Linking适用于需要在已安装的应用之间进行跳转，实现相对简单，但当无应用匹配时用户体验不佳。而App Linking适用于社交分享、广告引流等需要外部链接访问应用的场景，以及对安全性和用户体验要求较高的场景。AppLinking在Deep Linking的基础上增加了域名校验，提高了链接的安全性和可靠性，且无论应用是否安装，用户都能访问内容。
ArkWeb页面指定类型跳转
在某些场景下，系统存在多个同类的应用，希望由用户按个人偏好自行选择在哪个应用中进行处理，例如用户收到了一个地址，而系统内有多个导航软件，希望让用户自行选择偏好的软件进行导航。实现上开发者可以参考：拉起指定类型的应用，以下参考代码以调用方拉起地图导航类应用为例。
ArkWeb页面跳转系统应用页面
从ArkWeb页面拉起系统应用界面，也是一个常见的场景，例如开发者有发布图片的需求，而且图片上传的界面在前端界面已经有了实现并且做了多端适配，现在希望复用原有的界面，但是具体的图片选择的逻辑以及上传的逻辑希望修改成ArkTS侧的实现。实现步骤如下：
```typescript
Navigation(this.navPathStack) {
Column() {
Web({
src: $rawfile('index3.html'),
controller: this.controller
})
.zoomAccess(false)
.onLoadIntercept((event) => {
const url: string = event.data.getRequestUrl();
if (url === 'photo://pages/selectPhoto') {
const photoSelectOptions = new photoAccessHelper.PhotoSelectOptions();
photoSelectOptions.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE; // 过滤选择媒体文件类型为IMAGE
photoSelectOptions.maxSelectNumber = 5; // 选择媒体文件的最大数目
let uris: Array<string> = [];
const photoViewPicker = new photoAccessHelper.PhotoViewPicker();
photoViewPicker.select(photoSelectOptions)
.then((photoSelectResult: photoAccessHelper.PhotoSelectResult) => {
uris = photoSelectResult.photoUris;
console.info('photoViewPicker.select to file succeed and uris are:' + uris);
})
.catch((err: BusinessError) => {
console.error(`Invoke photoViewPicker.select failed, code is ${err.code}, message is ${err.message}`);
})
}
return url !== 'resource://rawfile/index3.html';
})
}
}
.hideTitleBar(true)
.navDestination(this.PageMap)
```
更多拉起系统应用的方式，开发者可以参考：拉起系统应用。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-form-kit
爬取时间: 2025-05-01 09:26:19
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-card-update-and-data-interaction
爬取时间: 2025-05-01 09:26:40
来源: Huawei Developer
概述
服务卡片给用户提供一目了然的信息内容，具有易用可见、智能可选和多端可变的特点，提供给用户简洁、高效的体验。系统通过卡片开发服务（Form Kit），提供了丰富的服务卡片开发能力，涵盖了卡片的创建、交互、更新与管理等多个方面，使开发者能够高效完成个性化服务卡片的开发。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151026.05895128611153814428399726812037:50001231000000:2800:E895BAD001E5A7F7D45877EB12ECCFD87ECCCF8DD9B82B5DE681C74E91B09A4C.png)
卡片更新场景
服务卡片通常用于展示最新的信息或数据。通过卡片更新机制，开发者可以确保卡片上展示的内容是最新的，从而满足用户对实时信息的需求。例如，新闻应用可以通过更新卡片来展示最新的新闻标题和摘要，天气应用可以通过更新卡片来提供最新的天气信息。
卡片更新的频率和策略直接影响用户体验。如果卡片内容长时间不更新，用户可能会认为应用不活跃或不可靠，从而降低对应用的信任度和使用频率。相反，通过合理的卡片更新机制，可以保持卡片内容的新鲜感和吸引力，提升用户的使用体验和满意度。
通常需要进行卡片数据加载或卡片更新的场景有以下几种类型：
| 场景类型  | 场景描述  |
| --- | --- |
| 主动刷新  | 添加卡片时，初始化卡片数据。例如，从桌面添加卡片，弹出卡片预览弹窗时，进行卡片数据初始化加载。    | 卡片UI交互时，进行卡片更新。例如，点击卡片刷新按钮，更新卡片推荐内容；音乐类卡片点击播放按钮，拉起应用至后台播放音乐，更新播放按钮状态。    | 应用侧交互引起变化，更新数据到卡片。例如，在应用侧点击收藏按钮改变文章的收藏状态时，同步更新卡片的收藏状态。    |
| 被动刷新  | 定时更新、定点更新以及指定下次刷新时间间隔更新。例如，定时更新新闻卡片的推荐内容。  |
场景类型
场景描述
主动刷新
-  例如，从桌面添加卡片，弹出卡片预览弹窗时，进行卡片数据初始化加载。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151027.58808025389466084229474626545642:50001231000000:2800:5DF3105190435AF62387FFA902350855A41C5FC0B2EA3FC2696DF1E1ECFF2E89.png)
-  例如，点击卡片刷新按钮，更新卡片推荐内容；音乐类卡片点击播放按钮，拉起应用至后台播放音乐，更新播放按钮状态。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151027.80325459764081421039897829894245:50001231000000:2800:EA0A29BBC9F63CD7BB3B2029D27EF2977E4876A99821C10E7AE8CFA3E2C0882A.gif)
-  例如，在应用侧点击收藏按钮改变文章的收藏状态时，同步更新卡片的收藏状态。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151027.60799504867939425646003409089539:50001231000000:2800:3D1D44195AF4FDFFE5AC3A2A0734DE9FAC74B908C9A4312773C4CA331820C079.gif)
被动刷新
本文将以实现卡片更新与数据交互功能示例应用为例，介绍卡片数据交互流程、如何实现常见的卡片更新场景以及卡片更新开发过程中的常见问题和注意事项。
实现原理
卡片运行机制简介
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151027.45620081053531708680508385933704:50001231000000:2800:133E7357A95B0D4D9C6C0BD205EF946169846C76B6A61157D1DED67F68FA0310.png)
以天气卡片为例，天气应用作为卡片提供方，提供天气卡片的显示内容、控件布局和卡片交互处理逻辑。例如，天气卡片显示地点、温度和天气情况，点击卡片跳转至天气应用等。此时，桌面作为卡片使用方，即卡片的宿主应用，控制天气卡片在桌面中展示的位置并展示卡片内容。ArkTS服务卡片的实现依赖ArkTS卡片框架的能力，卡片框架管理卡片生命周期和刷新机制，负责卡片页面的渲染。如下图所示，卡片提供方和使用方都依赖于卡片框架，天气应用提供的天气卡片，其添加、删除和刷新依赖框架的卡片管理服务，桌面展示天气卡片内容依赖框架的卡片渲染服务。关于卡片提供方、使用方和卡片框架的详细内容可参考ArkTS卡片实现原理。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151027.37732746998594030052796504202701:50001231000000:2800:B309710AAB85A4BD2A4FA0930C5D229FD36A95A49E198FC8E36617F2A6C8CB74.png)
卡片数据交互
卡片更新场景的实现，依赖于FormExtensionAbility生命周期、FormProvider模块提供的updateForm()接口和卡片框架提供的卡片刷新机制。如下图所示，应用主进程和应用的卡片进程是两个独立的进程，应用主进程持有UIAbility，应用的卡片进程持有FormExtensionAbility。卡片的UI页面由系统服务统一进行渲染，由卡片使用方（例如桌面）进行呈现。如果卡片数据不依赖于应用主进程，在卡片进程中使用卡片框架能力就能实现卡片更新。如果卡片数据依赖于应用主进程，应用主进程使用FormProvider模块提供的updateForm()接口更新卡片时，需要明确卡片ID，所以卡片ID在添加卡片时需要进行存储，此类场景下需要借助卡片框架和数据存储等系统能力，保证应用主进程和卡片进程的卡片ID数据一致性。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151028.76797456129165336792832597750696:50001231000000:2800:649459A7C0C223D0959A93A81F4C308F0AA333ADFCFFEC89536B2CD69F2F52F4.png)
本文主要介绍由卡片或应用UI交互引起的、由系统刷新机制定时或定点触发的卡片更新场景。一般情况下，卡片实现这几种常见场景就可以满足用户对卡片信息更新的诉求。还有一类是需要实时更新信息的应用卡片，例如出行打车类卡片，用户对信息的实时性要求很高，这类场景可以通过Push Kit（推送服务）的能力来实现，详细可参考推送卡片刷新消息。
卡片数据初始化
场景描述
添加卡片时需要对卡片进行数据初始化，卡片创建及卡片配置参考ArkTS卡片开发指导，本章节将对卡片数据初始化的流程进行介绍。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151028.96898613616061171987430074440266:50001231000000:2800:17E462FCF74987F6A7B3F6BAE91A36AD348AA25C9D65169412BDDBE53F1A58F8.png)
开发流程
添加卡片时，卡片数据初始化流程：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151028.29236668905356622257739140236700:50001231000000:2800:4A849BDE8E37A932DE2FAFA3C3E2AE0F6FEBFD5F5F6FBBD4B85B5D6463A23B95.png)
桌面长按应用图标待展示卡片列表时，首先触发FormExtensionAbility生命周期接口onAddForm()。使用卡片参数枚举FormParam可以从生命周期接口onAddForm()的入参want中取出卡片的相关信息如卡片标识、卡片名称、卡片宽高等。针对必要的信息可以进行判断或者保存等操作。
```typescript
import { Want } from '@kit.AbilityKit';
import { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
// ...
const TAG: string = 'EntryFormAbility';
export default class EntryFormAbility extends FormExtensionAbility {
onAddForm(want: Want): formBindingData.FormBindingData {
if(!want || !want.parameters) {
hilog.error(0x0000, TAG, `FormAbility onAddForm want or want.parameters is undefined`);
return formBindingData.createFormBindingData('');
}
let formName: string = want.parameters[formInfo.FormParam.NAME_KEY] as string;
let formId: string = want.parameters[formInfo.FormParam.IDENTITY_KEY] as string;
// ...
return formBindingData.createFormBindingData('');
}
// ...
}
```
创建需要返回卡片的数据类，可以是包含若干键值对的Object或JSON格式的字符串。使用卡片数据绑定模块formBindingData的createFormBindingData()接口封装卡片需要使用的数据类，作为生命周期接口onAddForm()的返回值并传递给卡片。
说明：若onAddForm()接口中无法直接构建数据类作为接口返回值初始化卡片，例如依赖数据库查询结果或等待网络数据等使用异步的场景，可以使用FormProvider模块提供的updateForm()接口将异步获取的数据推送至卡片。
```typescript
import { systemDateTime } from '@kit.BasicServicesKit';
import { Want } from '@kit.AbilityKit';
import { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { CardListItemData, CommonData, FormData } from '../common/CommonData';
// ...
const TAG: string = 'EntryFormAbility';
export default class EntryFormAbility extends FormExtensionAbility {
onAddForm(want: Want): formBindingData.FormBindingData {
if(!want || !want.parameters) {
hilog.error(0x0000, TAG, `FormAbility onAddForm want or want.parameters is undefined`);
return formBindingData.createFormBindingData('');
}
let formName: string = want.parameters[formInfo.FormParam.NAME_KEY] as string;
let formId: string = want.parameters[formInfo.FormParam.IDENTITY_KEY] as string;
// ...
if (formName === 'card_info_refresh') {
let formData = new FormData(formId);
formData.formTime = systemDateTime.getTime().toString();
let formInfo: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);
return formInfo;
}
// ...
return formBindingData.createFormBindingData('');
}
// ...
}
```
卡片页面使用页面级的UI状态存储LocalStorage接收onAddForm()接口传递的数据。使用装饰器@LocalStorageProp装饰的状态变量接收数据类的详细信息，装饰器@LocalStorageProp(key)中的key值需与数据类的键值一一对应。使用获取的数据初始化卡片页面。
```typescript
let storageLocal = new LocalStorage();
@Entry(storageLocal)
@Component
struct WidgetCard {
// ...
@LocalStorageProp('formTime') @Watch('onFormTimeChange') formTime: string = '';
@LocalStorageProp('formId') formId: string = '';
// ...
onFormTimeChange() {
// ...
}
// ...
build() {
// ...
}
}
```
长按App图标，弹出下拉菜单点击卡片，或者长按某张卡片，选择更多卡片，弹出“卡片加桌弹窗”时，所有的卡片都会触发onAddForm()生命周期回调。
手动关闭卡片加桌弹窗或息屏，退出“卡片加桌弹窗”时，会触发所有卡片的onRemoveForm()生命周期回调。
点击“添加至桌面”添加卡片时，退出“卡片加桌弹窗”，会触发除当前加桌卡片之外的其他卡片的onRemoveForm()生命周期回调。
卡片UI交互引起卡片更新
场景描述
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151028.56304122310120093076221749781063:50001231000000:2800:D075BE71E7EBB7C41EE70BF3F5783066989E88A54DA7C05657634A4EE030F7B5.gif)
一般情况下，简单的卡片UI交互会引起卡片更新。例如，智能家电控制类卡片，通过卡片控制家电开关时，卡片上的开关状态会随设备状态而改变；点击新闻类卡片刷新按钮，从网络获取最新数据更新推荐内容列表。这类更新场景可以通过message事件实现，仅在卡片进程就可以完成卡片更新。
开发流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151029.35078838120372483682141852682819:50001231000000:2800:EC9D5B568E9753BA0CCABC59293CD43F155FA24925F7A72617297414C1367A66.png)
在卡片页面注册onClick()点击事件，动态卡片使用postCardAction()接口，静态卡片使用FormLink组件触发事件。本文以动态卡片为例，在点击事件回调中调用postCardAction()接口，action参数选择message触发message事件。message事件未设置abilityName参数时，默认拉起FormExtensionAbility。
message事件拉起FormExtensionAbility后触发onFormEvent()生命周期，构建卡片需要更新的数据类，调用updateForm()接口推送数据至卡片。卡片页面中使用LocalStorageProp装饰的状态变量更新后触发卡片更新。
```typescript
import { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { CardListItemData, CommonData, FormData } from '../common/CommonData';
// ...
const TAG: string = 'EntryFormAbility';
export default class EntryFormAbility extends FormExtensionAbility {
// ...
onFormEvent(formId: string, message: string) {
// ...
let formData = new FormData(formId);
// ...
let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);
formProvider.updateForm(formId, formMsg).then(() => {
hilog.info(0x0000, TAG, 'updateForm success.');
}).catch((error: Error) => {
hilog.error(0x0000, TAG, 'updateForm failed.%s', JSON.stringify(error));
});
}
// ...
}
```
拉起应用至后台时更新卡片
场景描述
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151029.43208141808982380865319759244196:50001231000000:2800:073592466E7BE65A57F3261D6D93350C1317F0A88AA9835C14F2BEE4489E8D1F.gif)
卡片UI交互引起卡片更新，实现和应用在前台时相同的功能。例如，音乐类卡片，点击播放或切换按钮，拉起后台播放音乐，同时更新卡片上的播放状态。这类更新场景可以通过call事件实现，需要在卡片进程拉起应用主进程至后台时更新卡片。
开发流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151029.25407656356823765260634003506621:50001231000000:2800:08C52FCFB1F3C746AF6C2871199ABBB8842AC5D177E3102DDF0FB28EA61A6EF1.png)
在卡片页面注册onClick()点击事件，本文以动态卡片为例，在回调中调用postCardAction()接口（静态卡片使用静态用的FormLink），action参数选择call并配置需要调用的方法和传递的数据，触发call事件后台拉起指定UIAbility。配置参数注意以下限制：
在被拉起的UIAbility的onCreate()生命周期中，需要配置监听call事件所需的方法，监听的方法名与call事件配置的method保持一致。通过readString()方法读取传递的字符串值后，使用JSON.parse()解析传递的参数。使用传递的formId并构建更新卡片需要的数据类型，调用updateForm()接口推送数据至卡片。
注意，进程退出时需在onDestroy()生命周期中解除监听；监听配置的方法需返回实现rpc.Parcelable()接口的数据类。
```typescript
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { formBindingData, formInfo, formProvider } from '@kit.FormKit';
import { rpc } from '@kit.IPCKit';
import { CardListItemData, CommonData, FormData } from '../common/CommonData';
// ...
const TAG: string = 'EntryAbility';
export default class EntryAbility extends UIAbility {
private callFunc = (data: rpc.MessageSequence): MyParcelable => {
let params: Record<string, string> = JSON.parse(data.readString());
if (params.formId !== undefined) {
let formId: string = params.formId;
let formData = new FormData(formId);
// ...
let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);
formProvider.updateForm(formId, formMsg).then((data) => {
hilog.info(0x0000, TAG, 'updateForm success.', JSON.stringify(data));
}).catch((error: Error) => {
hilog.info(0x0000, TAG, 'updateForm failed.', JSON.stringify(error));
});
}
return new MyParcelable(1);
};
// ...
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
// ...
this.callee.on('updateCardInfo', this.callFunc);
// ...
}
// ...
onDestroy(): void {
// ...
try {
this.callee.off('updateCardInfo');
// ...
} catch (err) {
hilog.error(0x0000, TAG, 'Failed to disconnect callee. Cause: %{public}s', JSON.stringify(err) ?? '');
}
}
// ...
}
class MyParcelable implements rpc.Parcelable {
num: number;
constructor(num: number) {
this.num = num;
}
marshalling(dataOut: rpc.MessageSequence): boolean {
dataOut.writeInt(this.num);
return true;
}
unmarshalling(dataIn: rpc.MessageSequence): boolean {
this.num = dataIn.readInt();
return true;
}
}
```
提供方应用需要具备后台运行权限（ohos.permission.KEEP_BACKGROUND_RUNNING）。
从卡片跳转到应用后更新卡片
场景描述
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151030.89573853997701212381208878090706:50001231000000:2800:407B8D32FB3F869011BF1EEC6A32FB3B62126EA35A5C7FBF519BD31F40A3927F.gif)
卡片UI交互跳转至应用后，引起卡片更新。用于定时更新类卡片手动触发卡片更新。例如，天气类卡片，点击卡片跳转至应用，应用实时刷新天气，同时更新卡片展示的天气数据。这类更新场景可以通过router事件实现，需要从卡片进程跳转至应用主进程后进行卡片更新。
开发流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151030.24022916713080755334673233923798:50001231000000:2800:B7468D243CFA0D3259C192EADD1E4D1DD9B25C140A1B1705CCE3353ADD263C03.png)
在卡片页面注册onClick()点击事件，在回调中调用postCardAction()接口，action参数选择router触发router事件。router事件拉起指定的UIAbility，使用abilityName进行配置。
在UIAbility中接收router事件并获取参数。若UIAbility未在后台运行，触发onCreate生命周期回调。若UIAbility已在后台运行，会触发onNewWant()生命周期回调。生命周期参数want包含卡片相关信息，执行卡片相关操作。判断params中包含的参数，构建卡片更新需要的数据类，调用updateForm()接口推送数据至卡片。
```typescript
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { formBindingData, formInfo, formProvider } from '@kit.FormKit';
import { CardListItemData, CommonData, FormData } from '../common/CommonData';
// ...
const TAG: string = 'EntryAbility';
export default class EntryAbility extends UIAbility {
// ...
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
// ...
this.updateInfo(want);
// ...
}
// ...
onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {
this.updateInfo(want);
}
private updateInfo(want: Want) {
if (!want || !want.parameters || want.parameters[formInfo.FormParam.IDENTITY_KEY] === undefined) {
return;
}
let message: string = (JSON.parse(want.parameters?.params as string))?.message;
if (message === 'Router refresh card.') {
let formId = want.parameters[formInfo.FormParam.IDENTITY_KEY].toString();
let formData = new FormData(formId);
// ...
let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);
formProvider.updateForm(formId, formMsg)
.then((data) => {
hilog.info(0x0000, TAG, 'updateForm success.', JSON.stringify(data));
})
.catch((error: Error) => {
hilog.info(0x0000, TAG, 'updateForm failed.', JSON.stringify(error));
});
}
}
// ...
}
```
从应用更新数据到卡片
场景描述
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151030.27284356756908492542980470777347:50001231000000:2800:74263203E3C8BC77F3380716B711C5655B6E4D1C2D95FFED6D1D0D506900255D.png)
以应用点击收藏场景为例。卡片展示内容在应用内数据列表中，当点击应用内收藏按钮，收藏状态应同步至卡片。
开发流程
应用侧UI交互引起卡片数据变化时：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151030.54479839750808025052611559810628:50001231000000:2800:E8F9816C4C79C3C6FE48D46A47FB1D717A9C5B680A522A25859CB2BBCBDED292.png)
图片展示卡片创建时，在onAddForm()生命周期中使用首选项保存卡片ID至卡片ID列表及卡片当前状态。
```typescript
import { Want } from '@kit.AbilityKit';
import { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { CardListItemData, CommonData, FormData } from '../common/CommonData';
import { PreferencesUtil } from '../common/utils/PreferencesUtil';
const TAG: string = 'EntryFormAbility';
export default class EntryFormAbility extends FormExtensionAbility {
onAddForm(want: Want): formBindingData.FormBindingData {
if(!want || !want.parameters) {
hilog.error(0x0000, TAG, `FormAbility onAddForm want or want.parameters is undefined`);
return formBindingData.createFormBindingData('');
}
let formName: string = want.parameters[formInfo.FormParam.NAME_KEY] as string;
let formId: string = want.parameters[formInfo.FormParam.IDENTITY_KEY] as string;
let util = PreferencesUtil.getInstance();
let preferences = util.getPreferences(this.context);
// Save form id using preferences.
util.addFormId(preferences, formId);
// ...
let key: string = `${formId}_show_index`;
let data = util.getFormInitData(key, preferences);
if (formName === 'card_info_update') {
// Save the index of the data items currently displayed on the card.
util.preferencesPut(preferences, key, data.id);
let formData = new FormData(formId);
formData.cardList.push(data);
let formInfo: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);
return formInfo;
}
return formBindingData.createFormBindingData('');
}
// ...
}
```
应用侧收藏按钮注册onClick()事件，事件回调触发时，使用首选项更新收藏状态，查询当前正在展示该收藏状态变化的数据的卡片，更新收藏状态到对应卡片。
```typescript
Row() {
// ...
}
.onClick(() => {
let util = PreferencesUtil.getInstance();
let preferences = util.getPreferences(getContext(this));
this.statusArr[this.itemData.id] = !this.statusArr[this.itemData.id]
this.itemData.favour = this.statusArr[this.itemData.id!];
util.preferencesPut(preferences, 'statusArr', this.statusArr)
// Update page display data.
AppStorage.set('statusArr', [...this.statusArr]);
let idArr = PreferencesUtil.getInstance().getFormIds(preferences);
if (idArr.length > 0) {
idArr.forEach((formId: string) => {
if (preferences.getSync(`${formId}_show_index`, -1) as number === this.itemData.id) {
let formData = new FormData(formId);
formData.cardList = [this.itemData];
let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);
formProvider.updateForm(formId, formMsg).then(() => {
hilog.info(0x0000, TAG, `updateForm success.`);
}).catch((error: Error) => {
hilog.error(0x0000, TAG, `updateForm failed: ${JSON.stringify(error)}`);
});
}
})
}
})
```
定时、定点更新卡片
场景描述
使用天气类或日历类应用时，卡片需要每日更新当日最新数据，方便用户获取最及时的信息。新闻阅读类卡片展示热点文章列表时，需要随时间变化进行定时更新。
服务卡片支持通过定时刷新及定点刷新的方式实现以上场景。
在使用定时和定点刷新功能之前，需要在form_config.json配置文件中设置updateEnabled字段为true，以启用周期性刷新功能。出于安全及性能考虑，每张卡片每天最多通过定时方式触发刷新50次，定时刷新包含卡片配置项updateDuration和调用setFormNextRefreshTime方法两种方式，当达到50次配额后，无法通过定时方式再次触发刷新，刷新次数会在每天的0点重置。
开发流程
定时刷新
定时刷新表示在指定的时间间隔后自动刷新卡片内容。可以在form_config.json配置文件的updateDuration字段中进行设置。卡片定时刷新的更新周期updateDuration字段的单位为30分钟，即最短为半小时（1 * 30min）刷新一次。当取值为0时，表示该参数不生效，当取值为正整数N时，表示刷新周期为30*N分钟。
定时刷新触发后，系统调用onUpdateForm()的生命周期回调函数，使用updateForm()方法更新卡片内容。
```typescript
import { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';
import { CardListItemData, CommonData, FormData } from '../common/CommonData';
// ...
export default class EntryFormAbility extends FormExtensionAbility {
// ...
onUpdateForm(formId: string) {
// ...
let formData = new FormData(formId);
// ...
let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);
formProvider.updateForm(formId, formMsg);
}
// ...
}
```
定点刷新
定点刷新表示在每天的某个指定的时间点自动刷新卡片内容。通过在form_config.json文件中配置scheduledUpdateTime字段实现，例如配置为14:00。定点刷新触发后，系统调用FormExtensionAbility的onUpdateForm()生命周期回调，相关操作参考定时刷新。
注意，当同时配置了定时刷新updateDuration和定点刷新scheduledUpdateTime时，定时刷新的优先级更高。为实现定点刷新updateDuration需要配置为0，配置大于0的数字时会导致定点刷新不生效。
更多注意事项参考卡片定时刷新和定点刷新。
常见问题
如何刷新指定类型的多个卡片
刷新所有同类卡片首先需要保存同类卡片的formId。在onAddForm()生命周期中，通过判断卡片名称，卡片宽高等信息，识别同类型卡片，将formId分类并持久化，如使用首选项或RDB。
应用侧更新状态需同步卡片时，从持久化的数据中获取该类型的formId数组，遍历数组调用formProvider.updateForm()推送卡片更新需要的数据。当卡片移除时，需要在onRemoveForm()生命周期中判断formId是否在该类型数组中，若存在需删除该数据项并更新持久化数据。
如何管理当前已加桌的所有卡片ID
长按App图标，弹出下拉菜单点击卡片，或者长按某张卡片，选择更多卡片，弹出“卡片加桌弹窗”时，所有的卡片都会触发onAddForm()生命周期回调。手动关闭卡片加桌弹窗或息屏，退出“卡片加桌弹窗”时，会触发所有卡片的onRemoveForm()生命周期回调。点击“添加至桌面”添加卡片时，退出“卡片加桌弹窗”，会触发除当前加桌卡片之外的其他卡片的onRemoveForm()生命周期回调。
当触发onAddForm()生命周期回调时，将卡片ID存储到数据库。当触发onRemoveForm()生命周期回调时，将卡片ID从数据库删除。数据库中未被删除的卡片ID，即是当前已加桌的所有卡片ID。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-music-card
爬取时间: 2025-05-01 09:27:00
来源: Huawei Developer
概述
服务卡片，简称“卡片”，是HarmonyOS系统一种呈现信息和交互操作的载体，在应用或元服务中提取关键信息和核心操作，以卡片的形式展示在桌面上，用户通过与服务卡片交互即可实现服务直达，减少交互层级，提升用户体验。
典型的服务卡片使用场景有音乐服务卡片。音乐服务卡片将音乐APP的重要信息与核心功能操作前置到卡片上，以卡片的形式呈现给用户，如音乐播控、歌单推荐、心动歌词等。用户可通过音乐服务卡片快速访问音乐APP的核心功能，无需打开完整的应用界面。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151031.68410665683410751883820462908703:50001231000000:2800:8E16E2DBC4E17FCD128A99DD5A28CD228FA52FD517EA67D3695E7223D1DF99BC.png)
本文将以音乐服务卡片场景为例，分别介绍音乐播控、歌单推荐、心动歌词三种服务卡片的实现，包括卡片设计和功能开发，以及开发中常见的一些问题。通过本案例，开发者可以更加深入的了解服务卡片与应用的交互和卡片的数据更新机制，快速高效的进行精美的服务卡片开发。
场景介绍
音乐播控
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151031.04061972046023326370730429135280:50001231000000:2800:EA81F8508A4E5DAEE142470EDCE30080C8182F0BB73A3E4E0C70A3EBFFE0B6B3.png)
场景定义：
歌单推荐
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151031.97917567079168990301753161783469:50001231000000:2800:39F3D25D2FCEDD130D614237F1DF2B40E4F1B67275D7D582675ED2F8FFF3C498.png)
场景定义：
心动歌词
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151031.95403960181367626381384540319884:50001231000000:2800:CE68C962C0A8D8E92C4341AF30A055F91EBF8E982F8E8C445BFCC6872683F4A5.png)
场景定义：
卡片设计
在设计方面，服务卡片需要遵循突出服务内容、明确划分有限的操作空间、展示必要的信息和图片以及轻量交互体验原则，关于卡片内容设计遵循卡片内容设计规范，例如卡片沉浸式体验设计，包含图片和用色丰富的沉浸式卡片，背景色吸取内容图中的色彩。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151031.17773729599429230887701541127911:50001231000000:2800:9CC31EB82C4EB79806967C1EF0FD2EDBFC3D8FDC482B67586C476A0D554BDCF3.png)
音乐播控、歌单推荐和心动歌词卡片设计效果如下所示：
| 卡片名称  | 卡片规格  | 功能简介  | 卡片效果1  | 卡片效果2  | 桌面效果  |
| --- | --- | --- | --- | --- | --- |
| 音乐播控  | [2x2] [2x4]  | 音乐播放控制，点击上一曲/下一曲，音乐封面会跟随歌曲切换。音乐收藏/取消收藏功能  |   |   |   |
| 歌单推荐  | [1x2] [2x4]  | 点击我的收藏跳转到应用收藏列表。点击热门歌单，跳转到歌单列表。  |   |   |   |
| 心动歌词  | [2x4] [4x4]  | 展示心动歌词，以及歌曲信息。点击卡片拉起对应歌曲播放页面。  |   |   |    |
卡片名称
卡片规格
功能简介
卡片效果1
卡片效果2
桌面效果
音乐播控
[2x2] [2x4]
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151031.47626395189008061373155113658408:50001231000000:2800:2ECC6CC50C8A576E90ECD38C1180BCE5DE0D17B48358C62304CF060A24B7750F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151031.18408701882381113821478868790363:50001231000000:2800:619EC8C1FFE36CC62B51DC3D040EC314A60564E34B84A411DAB618172BBDC523.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151031.42412731521086828640425457408484:50001231000000:2800:EF0759C7F161762F2395A19C2CCD73DA8F1598AA5B0003C6EDE3D8939DBDF1AC.png)
歌单推荐
[1x2] [2x4]
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151031.72114288354599156846557896977465:50001231000000:2800:5A5A5630325732F28D135CD4CCAB2BFBBAAFB33B42A44D8A58A97607183D7A4A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151031.07545878887181970646528663378817:50001231000000:2800:2FBA7DF57BE47195B3877FE2C6DEB30DD1D66B6F9916F116189049ADB03EAD59.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151032.00775951262776650494410779813313:50001231000000:2800:8E622C8C7EBF453E58B3D456A2E9976410D12024B392C4B2CB71E18102E8C16D.png)
心动歌词
[2x4] [4x4]
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151032.89856399336576264754144135303254:50001231000000:2800:3CD4592C752564B6A5EDFD8EA40C3EF22E0192499611CE1C8BF79CF91846A16E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151032.45927189866877728309778618885507:50001231000000:2800:80C599F21E2102569BE6AF5891A2A2B323C4B68294FDDF6CD6C7D8B96B886674.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151032.82065919871849733667485153070402:50001231000000:2800:540A43667E66C1E8DD59E663337EB590F976C2051AC9D9386EB04DE492D6E5A8.png)
实现方案
整体方案
音乐应用作为卡片提供方，提供音乐服务卡片的内容显示、控件布局和卡片交互处理逻辑。桌面作为卡片使用方，即卡片的宿主应用，控制卡片在桌面中展示的位置和内容。卡片框架管理卡片生命周期和刷新机制，负责卡片页面的渲染。关于卡片提供方、使用方和卡片框架的详细内容可参考ArkTS卡片实现原理。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151032.51061379467929641975060338559465:50001231000000:2800:7803736B02AB8946B2BDC27C753D9913957DA97CA2E432BB6102585E35FEAAE4.png)
音乐应用包含UIAbility（主进程）和FormExtensionAbility（卡片进程）两个进程。其中，主进程包含音乐播控、收藏、热门歌单等功能模块；卡片进程是卡片业务逻辑模块，提供卡片创建、刷新、销毁等生命周期回调。如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151032.56472958826031497751597177691325:50001231000000:2800:788440125F977ECA19F3ABC0D42768B04EF37962269C407278F17453C3834E79.png)
开发者可以根据FormExtensionAbility生命周期回调，在对应回调方法中处理卡片数据持久化、卡片数据更新等操作，FormExtensionAbility生命周期回调时机和功能实现说明如下表所示：
| 生命周期  | 回调时机  |
| --- | --- |
| onAddForm  | 长按APP图标/卡片后点击“服务卡片”拉起卡片视图后  |
| onUpdateForm  | 定时更新、定点更新、卡片使用方主动请求更新时执行回调  |
| onFormEvent  | 用户触发了卡片上的postCardAction或FormLink中的message事件  |
| onRemoveForm  | 长按卡片选择“移除”后  |
生命周期
回调时机
onAddForm
长按APP图标/卡片后点击“服务卡片”拉起卡片视图后
onUpdateForm
定时更新、定点更新、卡片使用方主动请求更新时执行回调
onFormEvent
用户触发了卡片上的postCardAction或FormLink中的message事件
onRemoveForm
长按卡片选择“移除”后
关键技术
在服务卡片开发中，我们会使用多种关键技术共同来实现不同类型的卡片，比如卡片规格的选择、卡片的沉浸式效果、卡片的更新以及数据持久化等。具体关键技术介绍如下：
1.  音乐播控卡片具有播放/暂停、上一曲/下一曲、收藏等功能，需较强的播控逻辑和交互处理，更适合选择动态卡片；歌单推荐和心动歌词仅需要页面跳转功能，业务逻辑和交互都比较简单，选择静态卡片更合适。
2.  沉浸式卡片设计能给用户带来更好的视觉体验，开发者可以使用@ohos.effectKit模块的ColorPicker的getMainColor()方法获取歌曲封面图像主色，作为卡片的背景色，使卡片和歌曲封面融为一体达到卡片沉浸效果。此外，在一些场景下，还可以给卡片添加背景图片，使用Image组件的blur属性或者@ohos.effectKit模块的blur()方法给图片做模糊化处理，来达到卡片沉浸效果。
3.  针对音乐服务卡片这种多类型多规格的卡片场景，推荐使用关系型数据库relationalStore进行卡片数据持久化存储。 应用主进程通过FormProvider的updateForm()方法实现卡片的主动刷新，例如更新歌曲信息、歌词信息等；在FormExtensionAbility的onUpdateForm()生命周期回调方法中实现卡片被动刷新逻辑，例如定时和定点刷新。 关于服务卡片的数据交互和更新机制，具体可以参考：卡片更新与数据交互。
卡片实现方案
音乐播控卡片
歌单推荐卡片
心动歌词卡片
场景实现
音乐播控卡片
实现步骤
音乐播控卡片的主要实现步骤如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151032.32774203613654924499266417606088:50001231000000:2800:F5744CEE45228F22DD938307EEE498526D6341315927E21BF58B3BB01F962A02.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151032.58617184501230203063641799233706:50001231000000:2800:02FB08F756EEEE6D66B9782576D1263EF8A7A132E3822C7F0FE9112AC478D420.png)
音乐播控卡片的详细开发流程如下：
1.  分别创建2x2和2x4两个规格的动态卡片，动态卡片的创建可以参考创建一个ArkTS卡片。对于比较复杂的布局，优先考虑使用相对布局RelativeContainer来减少性能开销。由于2x4卡片包含了2x2卡片的功能，下面将以2x4卡片为例介绍音乐播控卡片实现。 在卡片布局文件中定义卡片所需要的变量信息，使用@LocalStorageProp装饰器修饰，用于接收应用侧传递过来的数据，其中isPlay与isCollected分别表示歌曲的播放和收藏状态，根据状态的不同展示不同的图标，示例代码如下：
2.  在音乐应用中，EntryFormAbility继承了FormExtensionAbility类并实现了其生命周期回调方法。当预览卡片时，会触发EntryFormAbility的onAddForm()回调方法，在此方法中可以获取卡片名称、卡片ID等信息。开发者可以根据卡片名称判断是否为音乐播控卡片，如果是，则调用FormUtils.updateMusicControlCard()方法更新卡片数据。FormUtils是卡片管理工具类，封装了卡片添加、删除、更新等相关功能。示例代码如下： 由于在卡片进程FormExtensionAbility中无法直接获取歌曲播放状态，需要应用主进程来主动更新卡片播放状态。可以通过FormExtensionAbility给卡片传递一个isNeedRequestUpdate标识，当卡片收到该标识后，给应用主进程发送call事件主动更新卡片信息。 音乐播控卡片订阅到isNeedRequestUpdate变化后，发送call事件请求卡片更新。 应用主进程EntryAbility收到call事件后，根据卡片ID对卡片数据进行更新。 在卡片更新前需要获取卡片更新的相关数据，获取音乐播放状态isPlay、播放的歌曲信息songItem以及从数据库中获取歌曲的收藏状态，然后调用FormUtils的updateForm()方法更新卡片。
```typescript
// src/main/ets/entryformability/EntryFormAbility.ets
export default class EntryFormAbility extends FormExtensionAbility {
onAddForm(want: Want) {
// ...
if (want.parameters) {
let formId = want.parameters['ohos.extra.param.key.form_identity'] as string;
let formName = want.parameters['ohos.extra.param.key.form_name'] as string;
if (formName === 'PlayControlCard2x2' || formName === 'PlayControlCard2x4') {
FormUtils.updateMusicControlCard(formId, true);
}
}
return formBindingData.createFormBindingData('');
}
};
```
3.  音乐播控卡片有2x2和2x4两种规格，每种规格都可创建多个卡片。为确保切换歌曲时所有相关卡片的信息同步更新，需根据每个卡片的唯一ID和类型进行统一管理。因此，应将这些信息持久化存储，以便在需要时查询并准确刷新卡片内容，保持数据一致性。 当用户长按桌面应用图标以展示卡片列表时，会触发EntryFormAbility的生命周期方法onAddForm()。在此回调函数中，可以利用关系型数据库relationalStore保存卡片的相关信息，如卡片ID、名称等。而当卡片被移除时，则应在onRemoveForm()回调函数中同步删除数据库中的相应记录，示例代码如下：
```typescript
// src/main/ets/entryformability/EntryFormAbility.ets
export default class EntryFormAbility extends FormExtensionAbility {
onAddForm(want: Want) {
Logger.info(TAG, 'onAddForm')
if (want.parameters) {
let formId = want.parameters['ohos.extra.param.key.form_identity'] as string;
let formDimension = want.parameters['ohos.extra.param.key.form_dimension'] as string;
let formName = want.parameters['ohos.extra.param.key.form_name'] as string;
let formInfo = new FormInfo();
formInfo.formId = formId;
formInfo.formDimension = formDimension;
formInfo.formName = formName;
Logger.info(TAG, `onAddForm formInfo: ${JSON.stringify(formInfo)}`);
FormRdbHelper.getInstance(this.context).insertForm(formInfo);
// ...
}
return formBindingData.createFormBindingData('');
}
// ...
onRemoveForm(formId: string) {
Logger.info(TAG, 'onRemoveForm');
// Called to notify the form provider that a specified form has been destroyed.
FormRdbHelper.getInstance(this.context).deleteForm(formId);
}
// ...
};
```
4.  为了确保卡片和应用的播放状态始终保持同步，无论是在音乐应用的播放页面还是在桌面卡片上点击播放、暂停、上一首或下一首按钮，都应即时更新卡片和应用的播放界面信息。 4.1 发送音乐播控相关的call事件 给“播放/暂停”等播控相关的组件绑定onClick事件，调用postCardAction接口触发call事件，向音乐应用发送音乐播控信息。postCardAction方法封装在ActionUtils里面，参数action为事件类型，值为FormCarAction.CALL（枚举值为“call”）；method为方法名，用于触发UIAbility中对应的方法；type为播控操作类型，例如PlayActionType.PLAY表示播放。 4.2 订阅和处理卡片发送的call事件 在EntryAbility（即应用主进程的入口UIAbility）的onCreate方法中，使用callee.on()方法订阅卡片发送的call事件。当EntryAbility接收到call事件后，根据事件类型playActionType，调用MediaService中的playByAction()方法来控制音乐播放。MediaService封装了AVPlayer的媒体播放功能，如歌曲资源加载、播放/暂停等，具体实现可以参考音乐服务卡片示例代码中的MediaService.ets源码。 4.3 根据媒体播放状态更新卡片和应用播放界面信息 点击卡片的播放/暂停等按钮，拉起EntryAbility至后台播放/暂停歌曲时，卡片上的播放状态需要同步更新。 在EntryAbility的onCreate方法中，调用MediaService的setOnPlayStateCall()方法监听播放状态（如播放/暂停、上一曲/下一曲）变化。在setOnPlayStateCall()回调函数中，将播放状态isPlay和歌曲信息保存到AppStorage，以同步刷新应用界面。然后调用FormUtils的updateMusicControlCards()方法更新卡片数据，示例代码如下： 卡片的更新需要根据卡片的ID进行更新，通过调用formProvider.updateForm()方法来实现。所以在更新卡片之前，需先从数据库中获取所有待更新的卡片集合，随后遍历该集合，依据formId批量更新2x2和2x4两种规格的所有相关音乐播控卡片，确保它们的数据一致性。更新的内容包括播放状态（isPlay）、歌手名（singer）和歌曲封面（musicCover）等。 批量更新卡片 通过卡片切换歌曲，卡片和应用均更新数据 通过应用切换歌曲，卡片和应用均更新数据 4.4 应用进程被销毁前更新播放状态 当应用进程被销毁的时候，如果此时音乐卡片处于播放状态（显示暂停图标），应用应该更新卡片为未播放的状态（显示播放图标），并将状态更新同步到卡片UI。应用主进程被销毁前会触发EntryAbility里面的onDestroy()生命周期回调方法，在此方法中执行卡片更新逻辑，更新卡片播放状态isPlay为false。示例代码如下：
5.  收藏功能和音乐播控的实现方式相同，都是通过call事件拉起应用主进程至后台，应用主进程通过callee.on()监听到收藏的call事件后，进行收藏业务处理，然后更新卡片。 5.1 卡片发送收藏call事件给应用 首先在卡片侧给收藏图标添加onClick事件，绑定postAction事件，发送收藏操作call事件。变量isCollected表示收藏状态，用于接收应用更新的收藏状态数据。 5.2 订阅和处理卡片发送的收藏call事件 在EntryAbility的onCreate方法中订阅卡片发送的收藏call事件，获取call事件携带的参数collectActionType，collectActionType为CollectAction.COLLECTED的时候表示收藏操作，为CollectAction.UNCOLLECTED的时候，表示取消收藏。根据collectActionType的值更新数据库中的收藏状态数据，再更新卡片的收藏状态。 5.3 批量更新卡片 卡片的收藏状态更新，和播控状态更新逻辑相同，同样需要批量更新多个播控卡片，在更新前需要在数据库中查询所有桌面上的音乐播控卡片，然后遍历更新。 同理应用主进程进行收藏/取消收藏操作时，也需要更新卡片，使卡片和应用主进程收藏状态保持一致。给歌曲列表项的收藏图标，绑定onClick事件，调用FormUtils工具类的updateCardCollectStatus()方法更新卡片收藏状态。
6.  整个卡片的色调跟随歌曲封面图片来进行变化，这种沉浸式效果会给用户不断变化的视觉感受，防止了固定的UI色彩造成用户的审美疲劳。可以利用effectKit图像效果的智能取色ColorPicker取出歌曲封面图片的主颜色，以实现沉浸式UI效果。当歌曲切换的时候，可以先对歌曲封面图片进行取色，将歌曲封面图片的颜色imageColorHex更新给卡片。 使用effectKit模块的colorPicker.getMainColorSync()方法，获取封面图片主要颜色，转化为十六进制格式数据。 卡片侧获取到图片颜色imageColorHex后，颜色的数据格式为rgb，可以使用linearGradient属性，给imageColorHex设置不同的透明度，做渐变色处理，使卡片背景平滑过渡自然。 智能取色Picker目前支持取出PixelMap图片中的主要颜色、平均颜色、饱和度最高、以及占比靠前的颜色。在沉浸式UI中应避免出现纯白色或者纯黑色的色调背景，防止服务卡片的其他组件及内容受到影响。
```typescript
// src/main/ets/utils/FormUtils.ets
class FormUtils {
// ...
public async updateMusicControlCards(context: Context, songItem: SongItem, isPlay: boolean) {
let imageDealData = await ImageUtils.getImageDealData(context, songItem.label);
let formList: Array<FormInfo> = await FormRdbHelper.getInstance(context).queryFormByName('PlayControlCard');
formList.forEach(formInfo => {
let formData = new FormControlData();
// ...
formData.imageColorHex = imageDealData.imageColorHex;
this.updateForm(formData.formId, formData);
});
}
// ...
}
```
7.  当用户点击卡片播控组件（“播放/暂停”等播控相关组件）以外的区域时，可以通过router事件来实现，拉起应用主进程的EntryAbility。 给卡片最外层布局RelativeContainer绑定onClick事件，通过postCardAction发送router事件，设置参数type的值为RouterType.PLAYER，表示该router事件的目的是拉起播放页面。 如果EntryAbility未在后台运行，拉起UIAbility的时候会触发onCreate生命周期回调；如果EntryAbility已在后台运行，会触发onNewWant()生命周期回调。可以分别在EntryAbility的onCreate和onNewWant中获取卡片传递过来的router事件参数type。当type为RouterType.PLAYER时，使用AppStorage设置isShowPlay为true，用来拉起播放界面。 播放页面是通过bindContentCover方法绑定的一个弹窗，通过状态变量isShowPlay来控制其显示和隐藏，isShowPlay使用@StorageLink装饰器修饰用于接收EntryAbility中isShowPlay的值，示例代码如下：
```typescript
// src/main/ets/widget/pages/PlayControlCard2x4.ets
let storageUpdateCall = new LocalStorage();
@Entry(storageUpdateCall)
@Component
struct PlayControlCard2x4 {
@LocalStorageProp('songId') songId: string = '';
// ...
build() {
RelativeContainer() {
// ...
}
.height('100%')
.width('100%')
.padding(12)
.onClick(() => {
ActionUtils.jumpPlayPage(this);
})
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151032.06792751868015748515829241308206:50001231000000:2800:9F8D294FC0E718F344F60A8C75D7BAF84A767EBAE5C1A6FE5A376F61BC0A3722.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151032.74324082787752976545413077938080:50001231000000:2800:5CD38E0C51C43308F4C714F4709559192AB1C4F3BD5FBE3F17E61A6E860EA5D3.png)
| 批量更新卡片  | 通过卡片切换歌曲，卡片和应用均更新数据  | 通过应用切换歌曲，卡片和应用均更新数据  |
| --- | --- | --- |
|   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151032.50105445991217453218981341146759:50001231000000:2800:41698A556F1EEF601D546E77008C97A8F43D78F7738CF1C6A493B225B06940C9.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151032.34630266174583610695278099970985:50001231000000:2800:7FC23AD644DDB0020477B9ED8D01379A395A9C12D932D01EB0D8DBE814C2A458.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151032.22703734806702490374793153492701:50001231000000:2800:C83338ABFB693214B889D75A58B1D289DA3E11B634A9FD00A4D272FC74251281.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151033.99425643196688167710778438073775:50001231000000:2800:D180912CD1945CFFDBD76AA5EFD918B41EE6EB9E6D7440CDFE765B7BE27BBE65.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151033.74023343713543289919983596454088:50001231000000:2800:0E4A08B6EC00608832B8E2A57295F4C63AD780CC3E4AEE88853ED8541223828B.gif)
歌单推荐卡片
歌单推荐有1x2和2x4两个规格的卡片，效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151033.81438884278633603595175635516307:50001231000000:2800:A2713B77D653A7771F0594B80449AC914DCFF250CE83BBBDDAE0EEE2635B303E.png)
实现步骤
1.  歌单推荐封面图片加载的是网络图片，加载网络图片需要申请ohos.permission.INTERNET权限。在卡片预览的时候会进行下载网络图片，并更新到卡片。网络图片的下载以及如何更新到卡片，开发者可以参考：刷新本地图片和网络图片。 1.1首先在EntryFormAbility的onAddForm()方法中，调用FormUtils的updateRecommendedCard()方法更新卡片，示例代码如下。 1.2然后在updateRecommendedCard()方法中下载网络图片，并将图片添加到缓存中，接着调用updateForm()方法更新卡片。 1.3最后在卡片中Image组件通过入参(memory://fileName)的方式来进行加载缓存中的图片。 卡片加载的图片过大可能会导致卡片白屏，建议卡片加载的图片大小不能超过2M，在加载卡片图片前需要判断下图片是否过大，如果过大可以采取压缩的方案，图片压缩可以参考FAQ：如何将PixelMap压缩到指定大小以下。
```typescript
// src/main/ets/entryformability/EntryFormAbility.ets
export default class EntryFormAbility extends FormExtensionAbility {
onAddForm(want: Want) {
if (want.parameters) {
let formId = want.parameters['ohos.extra.param.key.form_identity'] as string;
let formName = want.parameters['ohos.extra.param.key.form_name'] as string;
// ...
if (formName === 'RecommendedMusic1x2' || formName === 'RecommendedMusic2x4') {
// 更新歌单推荐卡片
FormUtils.updateRecommendedCard(this.context, formId, IMAGE_URL1)
}
}
return formBindingData.createFormBindingData('');
// ...
}
}
```
2.  下面将以2x4卡片实现为例进行介绍，歌单推荐卡片使用的是静态卡片，通过FormLink组件进行跳转，有以下三种跳转场景。 2.1 在卡片中使用FormLink组件绑定router事件。 2.2 在EntryAbility的生命周期中处理跳转事件。 通过router事件拉起应用后，在应用侧EntryAbility的onCreate和onNewWant中接收到这三个事件以及事件携带的参数，为了区分，此处新增一个参数type，根据type，应用侧收到事件后可以做响应的业务处理。此处最外层的FormLink仅仅是拉起应用，不需要处理。后续处理“跳转收藏页面”和“跳转热门歌单”两个事件，示例代码如下： 2.3 在MainPage中根据参数跳转收藏页和热门歌单页面。 在音乐应用中，“我的收藏”页面是首页Tabs的一个页签。通过更新AppStorage中的mainTabIndex值来切换页面，其中1表示“我的收藏”标签页。首页通过@StorageLink监听mainTabIndex的变化以实现页面切换。 跳转热门歌单，是当用户点击卡片上的“热门歌单”拉起应用后，音乐应用会从首页自动跳转到热门歌单列表页面。这一过程通过在MainPage的onPageShow回调函数中判断isToPlaylists参数来实现，如果该参数为true，则使用pageStack.pushPathByName()方法跳转到热门歌单页面。示例代码如下： 在通过卡片多次拉起应用进行页面路由时，可能会导致页面栈中同一页面出现多次，从而使得返回操作需要执行多次。为了避免这种情况，应对页面跳转逻辑进行优化，具体处理方法可以参考：多次点击服务卡片拉起应用指定页面后，该页面在路由栈内存在多个，导致返回上一面需要多次返回操作。 跳转效果如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151033.81962487941987159767231993394612:50001231000000:2800:7C7C9DBA1A403F5E71487FD35064B14E4D7CFB1D45FC4323A2C814352B231481.gif)
心动歌词卡片
本章将介绍心动歌词卡片的两大核心功能：歌词卡片数据更新和沉浸式卡片设计。歌词卡片数据通过定时刷新来更新卡片数据，而沉浸式卡片则通过设置背景色和背景图片来增强视觉体验。
实现步骤
1.  本示例中歌词卡片是通过定时刷新的方式进行刷新，首先需要在卡片配置文件form_config中进行配置，设置updateEnabled参数的值为true，表示卡片支持周期性刷新（包含定时刷新和定点刷新），设置updateDuration参数的值为1，表示每隔30分钟会进行刷新卡片，参数配置如下： 接着在EntryFormAbility的onUpdateForm()回调方法中，对卡片数据进行刷新。由于onUpdateForm()方法中的参数只有formId，而本示涉及三种类型的卡片（乐播控、歌单推荐和心动歌词），因此需要依据formId查询数据库以获取卡片的具体信息。若查询到的卡片的formName为”LyricsCard”，则执行相应的数据更新操作。示例代码如下：
2.  使用Stack堆叠布局，将歌曲封面作为底部背景图，设置图片大小'200%'、透明度0.5、以及模糊度100，开发者可以根据设计自行调节。使用歌曲封面图片的颜色imageColor作为卡片背景色，imageColor的获取可参考音乐播控卡片章节。示例代码如下： 效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151033.53968861078902428955532283442422:50001231000000:2800:6B9C8A4794DD3D4C19AB468BFE514544BC514DA9971493E9F1F9AF5944A95CC9.png)
常见问题
多次点击服务卡片拉起应用指定页面后，该页面在路由栈内存在多个，导致返回上一面需要多次返回操作。
应用在接收到对应的router跳转事件后，处理跳转的时候需要判断跳转的页面是否已经在路由栈的栈顶，如果在的话需要替换当前的页面，如果不在的话，重新push这个页面到栈。下面以Navigation跳转路由页面为例：
手机重启/解锁后卡片内图片消失，出现白屏
该问题可能是卡片加载的图片过大导致的，在加载卡片图片前需要判断图片是否过大，如果过大可以采取压缩的方案，图片压缩可以参考FAQ：如何将PixelMap压缩到指定大小以下。关于卡片图片加载规格限制说明可以参考：刷新本地图片和网络图片。
手机重启后卡片数据变回兜底内容
卡片框架在重启时是使用onAddForm()回调方法的返回值，若应用重启前调用updateForm()更新的数据和onAddForm()方法返回的数据不一致，可能导致设备重启前后卡片数据不一致，因此需要对数据做持久化处理。例如使用关系型数据库存储卡片最新数据，在FormExtensionAbility的onAddForm()生命周期回调中，获取数据库中的最新数据后，使用updateForm()方法更新卡片。
在卡片生命周期和应用UIAbility生命周期获取的temp目录不同，需要分别获取，不能一次存储两端使用。
卡片更新时图片存储在从UIAbility的context获取的temp路径下，与创建时拉起的FormExtensionAbility的temp路径不同。若直接用数据库取出的数据进行卡片更新，会导致图片不能加载。因此，如果在FormExtensionAbility中，从数据库中取到卡片最新数据后，需要再次获取FormExtensionAbility下的temp路径打开本地/网络图片，获取到对应的fd之后再进行数据绑定刷新。
如何进行卡片渲染问题定位？
可以在DevEco Studio中查看日志，选择“com.ohos.formrenderservice”卡片渲染服务查看error日志看具体卡片渲染报错原因。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-arkts-language
爬取时间: 2025-05-01 09:27:13
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-arkts-high-performance
爬取时间: 2025-05-01 09:27:26
来源: Huawei Developer
概述
高性能编程指的是在语法使用过程中，通过优化一些影响性能的代码片段，使代码以最优的方式执行。以下实践是在开发过程中总结的高性能写法和建议，包括变量声明、属性访问、数值计算、数据结构使用以及函数声明与使用等内容。在实现业务功能时，应理解高性能写法的原理，并将其应用于代码逻辑中。
变量声明
使用const声明常量
对于初期明确不会改变的变量，尽量使用const进行初始化，这里的常量包含基础类型和引用类型。通过const保证地址不会发生变化，能够极大减少由于编码时误操作导致的赋值等行为，造成对原有逻辑的改变，声明为const能够在编辑时及时发现错误。其中当const声明的是引用类型时，引用类型内部的属性变化是允许的，对于这种不存在地址变化的情况下，也建议使用const声明。
【反例】
【正例】
指定number的类型
对于number类型，编译器在优化时会区分int和double类型。开发者在初始化number类型的变量时，如果预期是整数类型就初始化为0，小数类型就初始化为0.0，避免将一个number类型初始化为undefined或者null。
【正例】
```typescript
function calAddSum(addNum: number): number {
// count预期是int，不要声明成undefined/null或0.0，直接初始化为0
let count = 0;
count += addNum;
return count;
}
```
减少使用ESObject
ESObject主要用于在ArkTS和TS/JS跨语言调用的场景中作为类型标注，在非跨语言场景中使用ESObject标注类型，会引入不必要的跨语言调用，造成额外的性能开销，建议在非跨语言调用的场景下，避免使用ESObject，引入明确的类型进行注释。
【反例】
【正例】
2、在使用该方法的文件app.ets，引入对应的类型
属性访问
减少变量的属性查找
在要求性能的场景下，建议通过使用将全局变量存储为局部变量的方式来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快。重复的访问同一个变量，将造成不必要的消耗，尤其当类似的访问出现在循环过程中，其对于性能的影响更大。
在实际中可能会遇到在循环中会大量进行一些常量的访问操作，该常量在循环中不会改变，可以提取到循环外部，减少属性访问的次数。例如下面这个用例，Time是一个包含了日期信息的对象，Time.Info是记录日期的数组，示例中对于Time.INFO[year - Time.START]的访问，在每一次循环中，都会执行一次。
【反例】
【正例】
给类属性添加访问修饰符
在ArkTS中，对于类结构的属性提供了private、protected和public可访问修饰符。默认情况下一个属性的可访问修饰符为public。选取适当的可访问修饰符可以提升代码的安全性、可读性。
【反例】
```typescript
class Counter {
// 没有设置访问修饰符默认为public
count: number = 0;
getCount(): number {
return this.count;
}
}
// 访问时
const counter:Counter = new Counter();
console.info(counter.count.toString()); // 可以通过实例访问
console.info(counter.getCount().toString());
```
【正例】
当设置为private时，无法通过对象字面量的方式初始化类，在有需要通过字面量创建、或者直接访问属性时，设置为public。
数值计算
数值计算使用TypedArray
如果是纯数值计算的场合，推荐使用TypedArray数据结构。TypedArray类型化数组是一种类似数组的对象，其提供了一种用于在内存缓冲中访问原始二进制数据的机制。在一些图像数据处理、加解密的数据计算过程中使用TypedArray可以提高数据处理的效率，因为TypedArray是基于ArrayBuffer实现，在性能方面也能够进行较大提升。
【反例】
```typescript
const array1 = new Array(1, 2, 3);  // 针对这一场景，建议不要使用new Array(1, 2, 3)
const array2 = new Array(4, 5, 6);  // 针对这一场景，建议不要使用new Array(4, 5, 6)
const res = new Array<number>(3);
for (let i = 0; i < 3; i++) {
res[i] = array1[i] + array2[i];
}
```
【正例】
数据结构的使用
选取合适的数据结构
有些时候会采用Record的方式作为临时容器来处理属性存取的逻辑，例如如下案例中，对于info执行的操作是set存储以及读取的操作，这里更好的方式是采用标准内置Map以及基础类库提供的高性能容器类如HashMap。HashMap是ArkTS提供的高性能容器类，底层使用红黑树实现，提供了高性能的数据读写操作，可以用来实现快速读写键值。
【反例】
```typescript
class InfoUtil {
getInfo(t1: string, t2: string): string {
if (t1 === t2) {
return "";
}
// 此处使用Record普通对象作为容器
let info: Record<string, string> = {};
this.setInfo(info);
let t3 = info[t2];
return (t3 != null) ? t3 : "";
}
setInfo(info: Record<string, string>) {
// 接口内部实际上进行的是map的操作
info.aaa = 'aaa';
info.bbb = 'bbb';
info.ccc = 'ccc';
}
}
```
【正例】
避免造成稀疏数组
分配数组时，需要避免使用如下的方式进行处理。当虚拟机在分配大小超过1024大小的数组时，会变成用哈希表来存储元素，相对数组用偏移来访问元素速度较慢，在开发时，尽量避免数组变成稀疏数组。
【反例】
```typescript
// 下面情形会变成稀疏数组
// 1. 直接分配100000大小的数组，虚拟机会处理成用hash表来存储元素
let count = 100000;
let result: number[] = new Array(count);
// 2. 分配数组之后直接，在9999处初始化，会变成稀疏数组
result[9999] = 0;
```
函数声明与使用
函数内部变量尽量使用参数传递
能传递参数的尽量传递参数，不要使用闭包，闭包作为参数会多一次闭包的创建和访问。在普通函数中，修改外部作用域的变量时，建议通过函数的参数传递，因为在直接声明时引用外部作用域的变量，如果没有及时清理，可能有内存泄漏的风险。ArkTS中函数参数是引用类型时，作用于引用类型的修改会进行引用传递，函数内对形参的修改也会作用在实参上。
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-performance-no-closures规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
【反例】
【正例】
减少使用嵌套export */import *的方式
减少使用嵌套export *的方式全量导出
【反例】在使用export *导出方法时，中间不要嵌套多层文件，层层不断导出“export * from ...”
```typescript
// Numbers.ets
export const One: number = 1;
// ...
// 此处嵌套多层export *
// Utils.ets
export * from './Numbers';
// SecondPage.ets
export * from './Utils';
// Index.ets
import * from './SecondPage';
```
Numbers文件导出变量One，需要在Index.ets中使用，但在Utils文件中export * from './Numbers'，在SecondPage文件再次 export * from './Utils'，中间嵌套多层导出文件，直到最后在实际引用方Index.ets文件中 import * from './SecondPage'。
【正例】优化后，去掉冗余嵌套的export，即在Index.ets中直接import { One } from './Numbers'
```typescript
// Numbers.ets
export const One: number = 1;
// Index.ets
import { One } from './Numbers';
```
由于依赖模块解析采用深度优先遍历的方式来遍历模块依赖关系图中每一个模块记录，会先从入口文件的第一个导入语句开始一层层往更深层查找，直到最后一个没有导入语句的模块为止，连接好这个模块的导出变量之后又会回到上一级的模块重复这个步骤，因此多层export *的使用会导致依赖模块解析、文件执行阶段耗时增长。
减少import *的方式全量引用
应用程序加载过程中，需要使用不同模块中的变量或函数，通常开发者会将相同类型的变量或函数放在同一个工具类文件中，使用时通过import的方式引入对应的模块，当工具类中存在较多暴露函数或变量时，推荐按需引用使用到的变量代替“import  *”的方式，可以减少该阶段中.ets文件执行耗时，即减少文件中所有export变量的初始化过程。
【反例】Index.ets中使用“import * as nm from '../utils/Numbers'”。
```typescript
// Index.ets
import * as nm from '../utils/Numbers'; // 不推荐import *的方式
hilog.info(0x0000, 'testTag', '%{public}d', nm.One); // 此处仅用到变量One
// Numbers.ets
export const One: number = 1;
export const Two: number = 2;
// ...
// 此处省略100000条数据
```
【正例】Index.ets中使用“import { One } from '../utils/Numbers'”。
```typescript
// Index.ets
import { One } as nm from '../utils/Numbers'; // 推荐按需引用变量
hilog.info(0x0000, 'testTag', '%{public}d', One); // 此处仅用到变量One
// Numbers.ets
export const One: number = 1;
export const Two: number = 2;
// ...
// 此处省略100000条数据
```
延迟加载Lazy-Import使用指导
随着应用功能持续增加，应用规模不断扩大，依赖的模块文件逐渐变多，应用冷启动加载模块的时间也越来越长。而在实际冷启动过程中执行了很多应用整体依赖但当前未使用的文件，此时可以通过延迟加载Lazy-Import的方法延缓对这些冗余文件的加载，使待加载文件在冷启动阶段不被加载，而在后续导出变量被真正使用时再同步加载执行文件，节省资源以提高应用冷启动性能。
Lazy-Import与动态加载的区别
Lazy-Import与动态加载都可以实现主动延后特定文件的执行时间，帮助设备均摊性能消耗，缓解特定时段性能压力的能力。
|    | 动态加载  | Lazy-Import  |
| --- | --- | --- |
| 语法示例  | let A= await import("./A");  | import lazy { A } from "./A"  |
| 性能开销  | 创建异步任务开销。执行到动态加载时，触发依赖模块的模块解析+源码执行。  | Lazy-Import的模块解析耗时在冷启动依旧会触发遍历。导入的变量A被使用到时，触发模块的源码执行。  |
| 使用位置  | 代码块/运行逻辑中使用  | 需要写在源码开头  |
| 是否可以运行时拼接待加载模块名  | 是  | 否  |
| 加载时序  | 异步  | 同步  |
动态加载
Lazy-Import
语法示例
let A= await import("./A");
import lazy { A } from "./A"
性能开销
使用位置
代码块/运行逻辑中使用
需要写在源码开头
是否可以运行时拼接待加载模块名
是
否
加载时序
异步
同步
开发者在使用动态加载时，需要将静态加载的代码（同步导入）改写成动态加载语法（异步导入），修改量较大。如果希望通过动态加载在冷启动阶段产生优化，需要明确感知被动态加载文件不会在冷启动时执行，否则会增大冷启动开销（放入异步队列等）。相较于动态加载，使用Lazy-Import延迟加载，开发者只需要在import语法中增加lazy关键字，使用更加方便。
关于Lazy Import的实现限制可以参考：Lazy Import语法规格
使用场景
下述例子中A文件被引用，在应用启动到点击按钮的这段时间里，A文件并没有被实际执行，在冷启动阶段加载A文件的行为属于冗余。
```typescript
// A为任意可以被引入的ets文件
import { A } from "./A"
@Entry
@Component
struct Index {
build() {
RelativeContainer() {
Button('点击执行A')
.onClick(() => {
console.log('执行A' + A)
})
}
// ...
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151033.78869771995565615826976371986742:50001231000000:2800:26101A28902F6E73505BC9760D298B364AF29B15411B1DE9F919F78BE73C1428.png)
通过抓取Trace图查看调用栈可发现，应用在冷启动时加载了A文件。
使用方法
ArkTS冗余文件检测工具
在规避冗余文件时，首先需要筛选出哪些依赖文件在冷启动时未被使用，此时可以使用ArkTS冗余文件检测工具，梳理出冷启动加载过程中未被使用的文件名单。
目前不支持打开混淆编译的应用进行冗余文件分析。
工具使用
1.  persist.ark.properties的默认值为0x105c（即关闭状态）。
2.  大致结构：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151034.04695381113030276164415016681028:50001231000000:2800:B0CBB0C212098CE68F43105185FBFE28F79AB9ABE60E8B4E0C846F01DC72B4A5.png)
Lazy-Import示例
在通过工具筛选出冗余文件后，开发者可选择在引入时添加lazy关键字对文件进行标识，表示该文件可被延迟加载。
```typescript
import lazy { A } from "./A"
@Entry
@Component
struct Index {
build() {
RelativeContainer() {
Button('点击执行A')
.onClick(() => {
console.log('执行A' + A)
})
}
.height('100%')
.width('100%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151034.84010552376178577172375061733362:50001231000000:2800:C92D68E1D59C9484A1CEEFF1757B6F36E70528B40D7BBF40844380BA260FEAB7.png)
通过抓取Trace图查看调用栈可发现，使用Lazy-Import标识后，应用在冷启动时不再加载A文件。
关于Lazy-Import的基础使用方法请参考官方文档：延迟加载。
性能分析
|    | 加载文件耗时（微秒us）  |
| --- | --- |
| 优化前  | 412us  |
| 优化后  | 350us  |
加载文件耗时（微秒us）
优化前
412us
优化后
350us
根据上述优化前后案例Trace图对比分析，使用延迟加载后应用冷启动时不再加载A文件，在资源加载阶段减少因加载冗余文件产生的耗时约15%，提高了应用冷启动性能。（由于案例仅演示场景，优化数据仅做参考，在实际业务中随着引用文件的复杂度提高，引用文件数量增多，优化效果也会随之提升。）

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-comparative_practice_of_taskpool_and_worker
爬取时间: 2025-05-01 09:27:40
来源: Huawei Developer
概述
ArkTS提供了TaskPool与Worker两种多线程并发方案，下面我们将从其工作原理、使用效果对比两种方案的差异，进而选择适用于ArkTS图片编辑场景的并发方案。
TaskPool和Worker工作原理
TaskPool与Worker两种多线程并发能力均是基于 Actor并发模型实现的。Worker主、子线程通过收发消息进行通信；TaskPool基于Worker做了更多场景化的功能封装，例如支持任务组TaskGroup、任务优先级设置、取消任务等功能，且可以根据任务数量进行自动的扩容与缩容，还可以根据任务优先级进行任务调度。
Worker工作原理
Worker拥有独立的运行环境，每个Worker线程和主线程一样拥有自己的内存空间、消息队列（MessageQueue）、事件轮询机制（EventLoop）、调用栈（CallStack）等。线程之间通过Message进行交互，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151034.09518523331347000918279637690684:50001231000000:2800:051D0DEDB8DDC93F48900972DE95FF4A82D089C87568B3F102443127CDDFFDC4.png)
在多核的情况下（下图中的CPU 1和CPU 2同时工作），多个Worker线程（下图中的Worker thread1和Worker thread2）可以同时执行，因此Worker线程做到了真正的并发，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151034.87903742659489037308184353871946:50001231000000:2800:6C3CFBAA4718E4028F204D9764C4F7A4A3F3B50F911ACF45BD1A5EC7EC8A066B.png)
TaskPool工作原理
TaskPool在Worker之上实现了调度器和Worker线程池。在主线程（ArkTS Main Thread）中调用execute接口会将待执行的任务方法及参数信息，根据设置的任务优先级放入任务队列（TaskQueue）中等待调度执行。调度器会依据调度算法（优先级，防饥饿），从优先级队列中取出任务进行序列化，放入TaskPool中的Worker线程池，工作线程（ArkTS Worker Thread）根据调度器的安排执行任务方法，并将任务处理结果进行反序列化，最终以Promise-Then的方式返回给主线程。TaskPool的工作线程池会根据待执行的任务数量，任务的执行时间进行相应的扩容与缩容。原理图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151034.70221615581552470853587996507418:50001231000000:2800:781B68196F84E11AA2053227601C6FE4BE50BAF56B3D055D4D9E4CA9C8463E0A.png)
TaskPool与Worker并发方案对比
使用场景
本章节主要介绍Worker与TaskPool并发方案在ArkTS图片编辑场景下的使用及性能差异。分别从编码效率、线程创建耗时、数据传输、任务执行耗时、应用运行内存占用几个维度进行分析，对比不同方案各自的优缺点，以供开发者在遇到不同场景时参考。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151034.14478875680719624953984809735294:50001231000000:2800:548338D632B28B0C5318A4C00CFAAB909D306D43396844A79044A5DBE123596D.gif)
编码效率对比
使用Worker处理图片
使用Worker并发处理图片时需要开发者根据任务量的多少，控制Worker实例运行的数量，最多可以同时运行64个实例。为了避免产生大量的线程创建开销，需要开发者尽量复用已创建线程处理耗时任务，任务执行完成时需要及时销毁Worker，以免线程资源长期被占用影响其他任务的执行。具体请参见Worker注意事项。
使用Worker进行图片处理分以下步骤：
1.
2.
3.
```typescript
// 子线程接收任务并计算
WorkerPort.onmessage = function (event: MessageEvents) {
let bufferArray = event.data.buf;
let last = event.data.last;
let cur = event.data.cur;
let index = event.data.index;
let buffer = adjustImageValue(bufferArray, last, cur); // 像素计算执行
let output = new WorkerBuffer(buffer, index);
WorkerPort.postMessage(output); // 将计算结果发给主线程
}
export function async adjustImageValue(bufferArray: ArrayBuffer, last: number, cur: number) {
return execColorInfo(bufferArray, last, cur, HSVIndex.VALUE);
}
// 图片像素计算
export function execColorInfo(bufferArray: ArrayBuffer, last: number, cur: number, hsvIndex: number) {
...
const newBufferArr = bufferArray;
let colorInfo = new Uint8Array(newBufferArr);
for (let i = 0; i < colorInfo?.length; i += CommonConstants.PIXEL_STEP) {
const hsv = rgb2hsv(colorInfo[i + RGBIndex.RED], colorInfo[i + RGBIndex.GREEN], colorInfo[i + RGBIndex.BLUE]);
let rate = cur / last;
hsv[hsvIndex] *= rate;
const rgb = hsv2rgb(hsv[HSVIndex.HUE], hsv[HSVIndex.SATURATION], hsv[HSVIndex.VALUE]);
colorInfo[i + RGBIndex.RED] = rgb[RGBIndex.RED];
colorInfo[i + RGBIndex.GREEN] = rgb[RGBIndex.GREEN];
colorInfo[i + RGBIndex.BLUE] = rgb[RGBIndex.BLUE];
}
return newBufferArr;
}
```
4.
基于以上示例代码，可以发现使用Worker需要关注任务池个数上限，并管理Worker线程的生命周期，当任务数较多时难免会增加代码的复杂度。
使用TaskPool处理图片
TaskPool提供了比较简洁的API接口，开发者只需把任务方法、参数传入execute接口，等待任务执行完成返回结果就行了，无需关注线程的创建，系统会自动根据任务量多少进行扩容及缩容。TaskPool还提供了一些常用功能，支持任务组TaskGroup、配置任务优先级、任务取消，以满足开发者更多的开发场景。本实践利用TaskGroup任务组的能力，将一个大的任务拆分成多个小的任务放进一个任务组中等待调度执行。
使用TaskPool进行图片处理步骤如下，其中根据任务数对图片数据进行拆分、图片像素点的计算，以及任务结果的合并与Worker的处理逻辑一致，在此不再赘述。
1.
2.
使用TaskPool并发方案处理耗时任务代码写法比较简洁，开发者更容易上手。TaskPool支持任务组、任务优先级、取消任务等能力，为开发者提供了更多场景的的选择。
根据以上示例代码对比可以看出，使用Worker需要开发者关注线程数量的上限，管理线程生命周期，随着任务的增多也会增加线程管理的复杂度。使用TaskPool并发方案处理耗时任务代码写法比Worker简洁，开发者很容易上手。TaskPool支持任务组、任务优先级、取消任务等能力，为开发者提供了更多场景选择。
数据传输
使用Worker与TaskPool处理并发任务时需要将数据从主线程传递到任务池的执行线程。目前支持传输的数据对象可以分为普通对象、ArrayBuffer对象、SharedArrayBuffer对象、Transferable对象、Sendable对象五种，具体可参考指南文档。Worker与TaskPool均提供了两种传递数据的方式。
其中Worker提供postMessage接口，TaskPool提供了setTransferList接口，开发者可以根据实际需要，调整参数控制采用哪种方式传递数据。
TaskPool与Worker底层都是采用了同一套序列化与反序列化的机制。主要差异体现在TaskPool支持任务方法的传递，而Worker的任务方法需要写在对应的Worker.js文件中，相较于Worker，TaskPool多了任务方法的序列化与反序列化步骤。我们以TaskPool在任务数为1时（任务方法、参数、运行结果）的序列化与反序列化为例，统计一下序列化与反序列化的相关数据如下表所示：
|    | 序列化数据量（bytes）  | 序列化时间（μs）  | 序列化效率（B/μs）  | 反序列化时间（μs）  | 反序列化效率（B/μs）  |
| --- | --- | --- | --- | --- | --- |
| 方法  | 58  | 9.549  | 6.833  | 43.749  | 1.457  |
| 参数  | 217  | 36.111  | 6.023  | 115.294  | 1.933  |
| 结果  | 47  | 16.667  | 2.990  | 85.243  | 0.567  |
序列化数据量（bytes）
序列化时间（μs）
序列化效率（B/μs）
反序列化时间（μs）
反序列化效率（B/μs）
方法
58
9.549
6.833
43.749
1.457
参数
217
36.111
6.023
115.294
1.933
结果
47
16.667
2.990
85.243
0.567
上面实验待编辑图片有24520520个像素字节数，如果采用转移控制权的方式，序列化的数据就小很多且效率高。采用深拷贝方式的话会增加序列化与反序列化的开销。在宿主线程将数据（支持控制权转移）传递给执行线程后，不需要紧接着对数据进行访问的场景，推荐使用转移控制权的方式，这样可以提升数据传输效率。
TaskPool与Worker都具有转移控制权、深拷贝两种方式，Worker不支持任务方法的传递，只能将任务方法写在Worker.js文件中。TaskPool支持任务方法的传递，因此相较于Worker，TaskPool多了任务方法的序列化与反序列化步骤。数据传输两者差异不大。
任务执行完成耗时对比
分别在中载、重载环境下运行，随着任务数的增多，图片编辑完成任务耗时，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151034.08554286118884626366652921922668:50001231000000:2800:5EB70183FA34A0977413D8B2465D40592738355B09F2C9F04E61EBB60679454E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151034.58508446794085767163840777383653:50001231000000:2800:8AC062739DEBB300EA68926B8AAA93880DC44E13CA75219AE492339318CEEE61.png)
从模型实验数据可以看出：
经过以上中载、重载环境下的对比实验可以发现，并发可以带来约50%~65%收益，但并不是任务数越多越好，需要开发者根据任务及计算情况自己控制；
随着任务数的增多TaskPool逐渐优于Worker，这是由于TaskPool支持高优先级设置，在系统资源不足时，高优先级的任务更容易获得系统资源，所以TaskPool执行耗时任务相对Worker稍快一些。
从中载模型实验数据可以看出：
经过以上中载、重载环境下的对比实验可以发现，并发可以带来约50%~65%收益，但并不是任务数越多越好，需要开发者根据任务及计算情况自己控制；随着任务数的增多在重载环境下TaskPool与Worker耗时差异比在中载环境下大，这是由于TaskPool支持高优先级设置，在系统资源不足时，高优先级的任务更容易获得系统资源，所以TaskPool执行耗时任务相对Worker稍快一些；中载环境下由于系统资源充足，TaskPool的高优先设置效果没有那么明显，所以TaskPool与Worker完成任务耗时几乎相当。
运行时内存占用对比
分别在中载、重载环境下，随着任务数的增多，统计图片编辑前一刻与完成任务时刻应用内存增量的变化情况，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151034.17727162385932178571436199526448:50001231000000:2800:E8CBCD61CFA97097D65C28EA539AACD56F9B4D835315CB9245C93C40F5C5F6E3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151035.62163348009016076352290635612379:50001231000000:2800:9E3C1A4E28B2A5BE5C38A851A1344AA50E6155C24CA2870D3C37B424DB003BDA.png)
从以上实验数据可以看出：
任务数较少时使用Worker与TaskPool的运行内存差别不大，随着任务数的增多TaskPool的运行内存明显比Worker大。
这是由于TaskPool在Worker之上做了更多场景化封装，TaskPool实现了调度器和Worker线程池，随着任务数的增多，运行时会多占用一些内存空间，待任务执行完毕之后都会进行回收和释放。
总结
| 对比维度  | Worker  | TaskPool  |
| --- | --- | --- |
| 编码效率  | Worker需要开发者关注线程数量的上限，管理线程生命周期，随着任务的增多也会增加线程管理的复杂度。  | TaskPool简单易用，开发者很容易上手。  |
| 数据传输  | TaskPool与Worker都具有转移控制权、深拷贝两种方式，Worker不支持任务方法的传递，只能将任务方法写在Worker.js文件中。  | 传输方式与Worker相同；TaskPool支持任务方法的传递，因此相较于Worker，TaskPool多了任务方法的序列化与反序列化步骤。数据传输两者差异不大。  |
| 任务执行耗时  | 任务数较少时优于TaskPool，当任务数大于8后逐渐落后于TaskPool  | 任务数较少时劣于Worker，随着任务数的增多，TaskPool的高优先级任务模式能够更容易的抢占到系统资源，因此完成任务耗时比Worker少。  |
| 运行时内存占用  | 运行时占用内存较少。  | 随着任务数的增多占用内存比Worker高。  |
对比维度
Worker
TaskPool
编码效率
Worker需要开发者关注线程数量的上限，管理线程生命周期，随着任务的增多也会增加线程管理的复杂度。
TaskPool简单易用，开发者很容易上手。
数据传输
TaskPool与Worker都具有转移控制权、深拷贝两种方式，Worker不支持任务方法的传递，只能将任务方法写在Worker.js文件中。
传输方式与Worker相同；TaskPool支持任务方法的传递，因此相较于Worker，TaskPool多了任务方法的序列化与反序列化步骤。数据传输两者差异不大。
任务执行耗时
任务数较少时优于TaskPool，当任务数大于8后逐渐落后于TaskPool
任务数较少时劣于Worker，随着任务数的增多，TaskPool的高优先级任务模式能够更容易的抢占到系统资源，因此完成任务耗时比Worker少。
运行时内存占用
运行时占用内存较少。
随着任务数的增多占用内存比Worker高。
本实践只对比了编码效率、线程创建耗时、数据传输、任务执行耗时、应用运行内存占用方面TaskPool与Worker的差异，更多参见TaskPool和Worker的对比。
经过以上实验分析，ArkTS图片编辑任务在重载模型下单任务执行耗时119s，4个任务时耗时41s（比单任务并发有50%~65%的收益），为非执行长耗时任务场景，从场景、编码效率等方面考量选择TaskPool方案比较合适。开发者可以根据自己业务的实际运用场景选择适合自己的并发方案。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-taskpool_usage_specifications_and_faqs
爬取时间: 2025-05-01 09:27:54
来源: Huawei Developer
概述
任务池（TaskPool）基于池化思想和任务机制，提供了一系列并发API，旨在充分发挥多核CPU的优势，降低主线程负载，提高程序性能。使用TaskPool进行开发需遵守一些规范，并综合业务和并发特性，细分场景使用。违反这些规范可能会导致性能劣化，引起稳定性或者其他非预期的问题。
本文就TaskPool错误使用导致的一些诸如应用报错、业务异常、资源消耗过大等问题进行了分析，并总结出了一些使用规范，以帮助开发者更好的使用TaskPool进行应用开发。
TaskPool使用规范
根据业务场景合理划分项目结构，避免在子线程中直接或间接引入UI
场景描述
在工程中导入文件和HAR时，某些文件使用了如@Observed、AppStorage等UI装饰器或状态变量，这些UI装饰器或状态变量即使没有被显式调用也可能会被解析执行。然而目前子线程并不支持UI属性，当解析到这些UI装饰器或状态变量时，会抛出异常并返回，导致本模块的解析会被中断。访问这些包含UI的文件中的某些变量时可能会抛出错误：xxx is not initialized ，导致功能失效甚至crash。如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151035.73497374559936177458910748021484:50001231000000:2800:60FAEF90EA213D85DE4134D5522558645DD94455D3811743D0860FE75553DE73.png)
另外在一些复杂项目中，即使本模块未发生改动，也可能由于SDK或其他依赖模块发生变更而导致该问题。此类问题排查起来较为困难，因此推荐在开发和迭代阶段就做好相应的约束和验证。
反例
```typescript
// a.ets
import { hilog } from '@kit.PerformanceAnalysisKit';
@Observed
class Foo {
constructor() {
hilog.info(0xFF00, "sampleTag", "this is class Foo");
}
}
export class Bar {
constructor() {
hilog.info(0xFF00, "sampleTag", "this is class Bar");
}
}
```
本例中，在a.ets中声明了2个class（Foo和Bar），其中class Foo被@Observed修饰。当在子线程中尝试new Bar时，解析执行到@Observed会抛出异常，并不会继续执行class Bar的逻辑，导致Bar属于未定义变量，访问时会抛出异常: Bar is not initialized。
正例
```typescript
// b.ets
export class Foo {
id: number = 0;
}
```
将原先涉及UI的class（此处为Bar）剥离到单独的文件中，子线程再去导入不涉及UI的class（此处为Foo），这样就能确保应用正确运行。这样划分结构有利于提高程序正确性、执行效率和可维护性。
在长时任务中注册监听事件，避免在非长时任务中使用带有监听性质的接口
场景描述
通常监听接口具有长时属性，当在子线程注册监听接口并执行回调事件时，即使当该任务执行返回后，监听接口仍然会生效，并且触发时间不确定。由于TaskPool使能了负载均衡机制，对于非长时任务，会在任务执行完成后尝试回收空闲线程。
如果注册了监听接口的子线程已经被释放，而此时其他线程又向该子线程发送事件则会导致功能异常或者未定义行为，比如crash。
因此，当开发者有监听需求时，推荐使用长时任务，主动管理任务所在线程的生命周期。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151035.75251434252930963848122666183007:50001231000000:2800:2871CBDCA62324ACA9B8AB5209CF7596F4590ED2061A20FB7EBEB18A73D3A937.png)
反例
如在上述反例中，在concurrentFunc()中使用了http API，其中on接口监听headersReceive事件，当相关事件到来时调用回调。从concurrentFunc()的角度来说，注册完on接口，该任务的逻辑也就完成和返回了。回调如果不调用，执行该任务的线程就一直处于空闲状态。一段时间后，该线程可能会被释放，如果此时headersReceive事件再次到来，就会引起非预期行为。
正例
需要根据业务诉求合理选择任务类型。像http类的监听性质的接口适合使用长时任务，同时主动管理任务所在线程的生命周期，在具体逻辑执行完成后调用terminateTask()接口(通常在拿到结果时调用，即await之后或then逻辑里)，释放资源，避免造成执行长时任务的线程长时间不释放。
使用emitter和LongTask()的组合实现回调场景的通信诉求，避免在回调函数中使用SendData()
场景描述
TaskPool提供了支持TaskPool子线程和宿主线程通信的接口SendData()。作为TaskPool提供的接口，SendData()能够安全的将子线程的数据传输到宿主线程。
然而SendData()接口依赖于Task，生命周期同Task一致。考虑到微任务和异步事件的特性，回调函数可能在TaskPool任务结果返回后才会被处理。此时Task可能已经被销毁，如果再去调用依赖Task的接口SendData()是不合理和不安全的。TaskPool在这种情况下会抛出异常，如果这种异常是在任务返回后调用抛出的，还将会遗留在线程中不被处理，因此需避免在回调函数中使用SendData()。
如果有需要，推荐使用emitter，emitter能够方便地实现宿主线程和子线程之间的双向通信。另外emitter的on接口具有监听性质，在没有取消注册的情况下，能在任意时间被触发，因此需要在LongTask()中注册。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151035.84996156514078396948381219885802:50001231000000:2800:28950C11A1FDD5B705FFA6F0F514663152530ED2264FD4C2970F1E2A2395BE9E.png)
反例
在上述反例中，使用了异步接口，并在then中使用了SendData()。从执行流来看，wrongConcurrentFunc()会先调用Promise.resolve()生成并返回一个promise。此时，并没有其他可执行逻辑，因此会直接返回，即出了wrongConcurrentFunc()的作用域。之后在执行微任务队列时，then中的回调逻辑会被执行，且不在wrongConcurrentFunc()的作用域中执行，因此会抛出异常：SendData is not called in the concurrent function。
正例
正例中仍使用了Promise then的用法，区别于反例，在then的逻辑里使用了emitter来代替SendData()接口。同时将correctConcurrentFunc()这个任务声明为LongTask()，并使用terminateTask()手动管理生命周期，在实现功能的同时也能够保证程序的正确性。
根据业务场景和性能数据控制并发度
场景描述
使用TaskPool存在一定执行成本，对于耗时长的任务（同步或者异步回调阶段耗时）可以抛到TaskPool中去执行，而耗时十分短的任务则可以直接放在主线程执行。
同时合理划分业务粒度，对于一组相关联的任务，可以使用任务组TaskGroup。等待所有子任务都处理完再继续向下处理，从而保证业务代码整体性和可维护性。对于某些不紧急的查询任务，则可以将这些任务收集起来，在一些较为空闲的时间段再抛到任务池中执行。
在合适的场景下也可以使用SequenceRunner等API，以避免短时间内大量任务连续进入任务池，使线程数瞬间提升到最大。主线程连续处理大量任务密集返回时的回调和微任务会阻塞UI，影响用户体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151035.36996727834807539487929590874867:50001231000000:2800:7A047B2BA1C4E8578A0538F01825B396335CC9EADB839D2F65B17375C5C2DC22.png)
```typescript
// Sample5.ets
import { taskpool } from '@kit.ArkTS';
@Concurrent
function imageProcessing(dataSlice: ArrayBuffer): ArrayBuffer {
// 步骤1: 具体的图像处理操作及其他耗时操作
return dataSlice;
}
function histogramStatistic(pixelBuffer: ArrayBuffer): void {
// 步骤2: 分成三段并发调度
let number: number = pixelBuffer.byteLength / 3;
let buffer1: ArrayBuffer = pixelBuffer.slice(0, number);
let buffer2: ArrayBuffer = pixelBuffer.slice(number, number * 2);
let buffer3: ArrayBuffer = pixelBuffer.slice(number * 2);
let group: taskpool.TaskGroup = new taskpool.TaskGroup();
group.addTask(imageProcessing, buffer1);
group.addTask(imageProcessing, buffer2);
group.addTask(imageProcessing, buffer3);
taskpool.execute(group, taskpool.Priority.HIGH).then((ret: Object) => {
// 步骤3: 结果数组汇总处理
})
}
```
上例是一段处理图片的代码。在示例中将图片buffer分成3段，使用TaskPool的TaskGroup接口分发一组任务到多个子线程计算，同时接收多个结果，再返回UI线程展示。
正确处理业务逻辑异常情况，避免Task损耗
场景描述
在TaskPool并发场景下，调用接口需要保证匹配，例如open()接口和close()接口要对应，使用了setInterval()后也需要调用clearInterval()。如果接口不匹配，在退出阶段可能会有些句柄未正常关闭，这将会导致线程不能被释放。当线程较多时，这种情况对常驻内存会有较大影响。
推荐使用try...catch...来处理业务逻辑可能出现的异常。例如当taskpool.execute()传入的参数可能发生异常时，使用外层try...catch...及时捕获，当子线程中的task可能出现异常时，则可以使用.catch进行捕获。
例1
```typescript
// Sample4.ets
@Concurrent
function correctConcurrentFunc() {
let count: number = 0;
let id = setInterval(() => {
count++;
if (count == 10) {
hilog.info(0xFF00, 'sampleTag', "the value has reached the threshold");
clearInterval(id);
}
}, 1000);
}
```
在子线程使用定时器setInterval()模拟了一个定时任务，当定时条件满足条件后，主动使用clearInterval()将定时器取消，能够保证线程在空闲时能被正常释放。
例2
在创建并执行Task时，模拟误传入标注了@Observed的class Foo，构建序列化错误场景。通常对于taskpool抛出的异常，会使用.catch的形式来捕获。但对于taskpool.execute()的序列化逻辑，此时Promise还未被创建，所以也无法被.catch捕获，因此此处使用外层的try...catch...来捕获异常
例3
例3中对于子线程抛出的异常，使用了.catch的方式，异常能被正确捕获，打印也符合预期。
ArkTS线程间传递对象遵守序列化
场景描述
目前序列化支持的数据类型有普通对象、ArrayBuffer对象、SharedArrayBuffer对象、Transferable对象（NativeBinding对象）、Sendable对象五种，不支持代理和Promise等类型。因为序列化导致的失败，日志中会有“taskpool: failed to serialize arguments.”或者 "taskpool: failed to serialize result.”，可以通过过滤ArkCompiler Error日志查看具体类型报错，并根据类型排查代码（返回值的传递同样不支持这些类型）。
反例1
反例1中尝试动态import加载一个模块，返回到主线程使用，因module不支持序列化，出现报错。
反例2
反例2中尝试返回一个pending状态的promise，目前会被拦截，需要在当前线程完成对promise的操作。
常见问题
使用TaskPool时不遵循最小化导入原则有什么影响
根据ECMA规范，导入方法和变量的时候，JavaScript运行时会根据开发者指定的入口文件开始深度遍历import链上的每个文件，并先从叶子节点执行文件。每个文件只会运行一次，然后存放在线程缓存中，后续加载可直接获取。
对于TaskPool中的ConcurrentFunction()，虽然使能了精准import机制，在ConcurrentFunction()的最顶层仅会导入当前执行所需要的模块。但是对于较大的模块或在当前模块内依赖导入的其他模块，在系统侧是无法优化的。
如上面的例子，模块a、b、c虽然都被引用了，但ConcurrentFunction()中仅仅使用了模块a，因此在TaskPool中执行concurrentFunc()函数，仅有模块a会被解析执行。但a中所有依赖的模块仍然都会被解析执行。
另一种常见的情形是导入HAR包，当使用 import { case } from '@ohos/common' 导入时，前端会翻译成 import { case } from '@ohos/common/index'。由于index文件是整个HAR包导出的接口，虽然开发者可能只是想使用其中一个接口，但实际上却执行了整个HAR包(包括HAR包中导入的文件)，导致较大的耗时。虽然这部分耗时在子线程，但是也会对任务的执行耗时和内存产生较大影响。
一般来说，在子线程中导入HAR包通常仅是使用其中某些独立的方法，在这种情况下，采用精准导入的方法可以带来比较明显的收益。比如使用import { case } from '@ohos/common/xxx/xxx/case' 来导入具体文件(需要考虑可操作性)，或者将这个方法封装到一个全新的文件，这样仅解析这个单独的文件即可。
因此在使用TaskPool时应该遵循最小化导入原则，尤其避免在独立的任务中引入大量不相关文件或者HAR。
子线程使用同步接口和异步接口有什么差异 ，使用哪种接口比较合适
TaskPool线程池线程的最大数量是有限的，当前策略是maxThreads=CPU核数 -1，因此基于当前的设备，正常情况下线程数上限为11个。当所有线程都被占用时，后续的任务可能不会被及时调度。因此，在工作线程中推荐使用异步接口而非同步接口，在等待I/O时能够及时处理新入队的任务，避免任务池阻塞。
以文件系统copy为例，以下提供了同步和异步两种接口。由于文件拷贝比较耗时，推荐在子线程使用异步接口。
同步：
异步：
使用Sendable传输数据与使用深拷贝传输数据有什么差异
默认情况下，Sendable数据被分配在共享堆SharedHeap中，其在ArkTS并发实例间是通过引用传递数据。区别于深拷贝的方式，在trace上的直观表现是序列化和反序列化的时间明显减少，因此非常适用于性能敏感的场景。
比如从网络数据库获取数据，可以将获取数据的逻辑改造到子线程中，并将期望获取的业务模型声明为Sendable。子线程中获取到JSON数据、转换并生成模型数据后，通过Sendable以引用的方式传回到主线程，这样能显著减少主线程的负载。
另外由于子线程不支持UI属性，放入子线程的数据需要同UI剥离出来，返回的数据需要使用合理的方式同UI结合并渲染。对于这种Sendable对象和UI的组合使用可以参考ArkUI的新特性makeObserved。将makeObserved和@Sendable配合使用满足了应用开发中，在子线程做大数据处理，在UI线程做ViewModel的显示和观察数据的需求。
此外，Sendable特性支持共享模块。对于一些工具类单例，由于线程隔离的特性，需要在子线程调用时使用Init重新初始化一次。在使用共享模块后，可以保证多线程内共享一个单例，优化写法，提升易用性。对一些耗时的SDK，如果能使用共享模块，也可以将初始化阶段下沉到子线程，主线程使用的时候将不用重新初始化相关模块，能够有效提升性能。
Napi回调耗时长如何处理
ArkTS的执行是在单线程中进行的，这意味着异步函数不会自己创建线程。 即使用了TaskPool，任务在任务池的子线程执行，但是结果逻辑是需要返回到任务的宿主线程处理的。
一般来说，对于异步任务，开发者在ArkTS线程调用接口，对应接口会返回promise并挂起，异步逻辑则在工作线程中执行。异步逻辑执行完成后，通过线程间通信机制把结果返回到ArkTS线程。回到ArkTS线程后对应的Trace表示为Napi complete，在这一阶段会调用napi_resolve_deferred。
当Promise状态变为Fulfield之后会执行微任务队列，即执行开发者定义的await之后的逻辑或者then的逻辑。这段耗时和微任务的逻辑和数量密切相关，Napi complete的Trace也会统计这段耗时。这段耗时并不是系统造成的，而是开发者自己的代码的耗时。如果耗时较长，例如在forEach里对返回的数据做复杂的加工处理，渲染UI等，可能会有掉帧的风险。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-ui-framework
爬取时间: 2025-05-01 09:28:07
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-developing-high-performance-ui
爬取时间: 2025-05-01 09:28:20
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-ui-component-performance-optimization
爬取时间: 2025-05-01 09:28:33
来源: Huawei Developer
应用启动到UI页面展示过程包含框架初始化、页面加载和布局渲染三个步骤。其中页面加载和布局渲染的主要流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151035.80093669940352588481290530125313:50001231000000:2800:0EDAA3496B51B2CFAF76CB3DBEF32E7BAF8857FB084C826A0CF9B04E0DF6CA9E.png)
可以看到，应用启动后页面加载和渲染的性能与FrameNode树上的节点数量以及每个节点上的属性相关。因此，为缩短页面加载和布局渲染时长，在前端使用UI组件时可以考虑以下优化方案：
避免在自定义组件的生命周期内执行高耗时操作
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151035.94737385752849659516267079621578:50001231000000:2800:A9324B208A7F829FC1B56AFE434C928BFA32CB88ACF200F02C207F088AE6182F.png)
如上图所示，自定义组件创建完成之后，在build函数执行之前，将先执行aboutToAppear()生命周期回调函数。此时若在该函数中执行耗时操作，将阻塞UI渲染，增加UI主线程负担。因此，应尽量避免在自定义组件的生命周期内执行高耗时操作。对于复杂计算的耗时场景，可以将计算结果进行缓存处理。对于不需要等待结果的高耗时任务，可以采用多线程处理该任务，通过并发的方式避免主线程阻塞。在aboutToAppear()生命周期函数内建议只做当前组件的初始化逻辑，其他业务逻辑可以按需提前或延后处理。假设在首页视频列表中的子组件内需要初始化创建一个复杂播放器对象，该对象的创建非常耗时。若在该组件的aboutToAppear()函数中创建该对象，当首页加载渲染时，列表内每个子组件的渲染都将等待相应的播放器对象初始化创建完成，此时页面加载将非常耗时甚至可能出现白屏。伪代码如下:
```typescript
@Component
export struct VideoCard{
// ...
aboutToAppear(): void {
// 创建复杂对象任务，若该任务执行耗时1s，则组件将在1s后再渲染
this.createComplexVideoPlayer();
}
// ...
}
@Component
export struct CardList {
@State videoList: VideoItem[] = getVideoList();
build() {
List() {
ForEach(this.videoList, (item: VideoItem) => {
ListItem() {
VideoCard({ item })
}
}, (item: VideoItem) => item.id)
}
}
}
```
对于该场景，可以考虑将创建播放器对象任务的时机延后。如，计算当前组件出现在页面中的位置，当子组件滑动到页面的三分之一处时再创建播放器对象并播放视频。此时，页面首次渲染时，不会出现主线程阻塞。示例代码如下：
正例
```typescript
@Component
export struct VideoCard {
@State isVideoInit: boolean = false;
// ...
build() {
Column() {
// 视频播放组件
}
.onAreaChange((old, newValue) => {
if (!this.isVideoInit) {
let positionY: number = newValue.position.y as number
if (positionY < screenHeight / 3) {
this.createComplexVideoPlayer();
this.isVideoInit= true;
}
}
})
}
// ...
}
@Component
export struct CardList {
@State videoList: VideoItem[] = getVideoList();
build() {
List() {
ForEach(this.videoList, (item: VideoItem) => {
ListItem() {
VideoCard({ item })
}
}, (item: VideoItem) => item.id)
}
}
}
```
例如在生命周期aboutToAppear中应该避免使用ResourceManager的getXXXSync接口入参中直接使用资源信息，推荐使用资源id作为入参，推荐用法为：resourceManager.getStringSync($r('app.string.test').id)。 下面以getStringSync为例，测试一下这两种参数在方法中的使用是否会有耗时区别。
反例
```typescript
import { hiTraceMeter } from '@kit.PerformanceAnalysisKit';
@Entry
@Component
struct Index {
@State message: string = 'getStringSync';
aboutToAppear(): void {
hiTraceMeter.startTrace('getStringSync', 1);
// getStringSync接口的入参直接使用资源，未使用资源ID
getContext().resourceManager.getStringSync($r('app.string.app_name'));
hiTraceMeter.finishTrace('getStringSync', 1);
}
build() {
RelativeContainer() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
.height('100%')
.width('100%')
}
}
```
可以通过冷启动分析：Launch分析工具抓取Trace，根据hiTraceMeter性能打点，查看耗时为1.956ms。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151035.14233183557384896061027550479490:50001231000000:2800:23E08AC50461235E6A2A50AE4758147180B25B266397F19143612BBA82E1A1F9.png)
正例
```typescript
import { hiTraceMeter } from '@kit.PerformanceAnalysisKit';
@Entry
@Component
struct Index {
@State message: string = 'getStringSyncAfter';
aboutToAppear(): void {
hiTraceMeter.startTrace('getStringSyncAfter', 2);
// getStringSync接口的入参使用了资源ID
getContext().resourceManager.getStringSync($r('app.string.app_name').id);
hiTraceMeter.finishTrace('getStringSyncAfter', 2);
}
build() {
RelativeContainer() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
.height('100%')
.width('100%')
}
}
```
可以通过冷启动分析：Launch分析工具抓取Trace，根据hiTraceMeter性能打点，查看耗时为0.071ms。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151035.88506125813064359657617077656825:50001231000000:2800:A1CAD3AF2F61D3C95534ED56FDEE34780F18CE7E92E28F42C6383D96EDFC8E3C.png)
| 写法  | 耗时情况  |
| --- | --- |
| 资源信息为参数：getStringSync($r('app.string.app_name'))  | 1.956ms  |
| 资源ID为参数：getStringSync($r('app.string.app_name').id)  | 0.071ms  |
写法
耗时情况
资源信息为参数：getStringSync($r('app.string.app_name'))
1.956ms
资源ID为参数：getStringSync($r('app.string.app_name').id)
0.071ms
可得出结论：参数为资源信息时比参数为资源ID值时耗时更多。所以当需要使用类似方法时，使用资源ID值作为参数更优，可有效减少自定义组件生命周期耗时。
按需注册组件属性
在使用组件开发应用UI界面时，会为每个组件设置属性，进行UI样式、行为等逻辑处理。当应用中单个组件设置了大量属性且该组件在应用中被大量使用时，单个组件的设置对应用的整体性能会产生较大影响。比如，在RN框架开发中，单个组件需要设置21个属性，且该组件在ForEach循环中使用。在该场景下，由于不知道应用实际需要使用哪些属性，因此把所有的属性通过属性方法的方式设置到组件上。而在实际使用中，大部分应用只会用到其中很少的几个属性，其他属性均维持默认值，这导致了大量属性的冗余设置。该场景示例代码片段如下：
从该场景中可以看到，在应用开发中，当注册了大量冗余属性的组件需要在视图上批量展示时对性能有较大影响。此时，可以考虑采用AttributeModifier动态注册组件属性的方式，替换使用属性方法静态注册组件属性的方式。
使用AttributeModifier动态注册组件属性相比于直接在组件上使用属性方法静态注册组件属性，主要存在以下两点区别：
以一个简单的公共头像组件为例演示AttributeModifier方案的性能收益。公共头像组件要求对于有用户头像的数据，界面展示用户头像图片。对于没有用户头像的数据，界面展示灰色背景和用户名的第一个字符。现列表展示1000个头像组件，界面效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151036.95120517544178153754007246198948:50001231000000:2800:52756A9BD3E4E600D0440BDDEC40E78E055143B3652D289CA8012CB23C6CB983.png)
将方案改为采用AttributeModifier动态注册属性的方式，需要新增自定义类实现AttributeModifier接口，并修改Avatar组件的属性注册逻辑。具体改动代码如下：
```typescript
// 1.自定义属性修改器，该类实现了AttributeModifier接口
class RowModifier implements AttributeModifier<RowAttribute> {
private customImage: ResourceStr = '';
private static instance: RowModifier;
constructor() {}
setCustomImage(customImage: ResourceStr) {
this.customImage = customImage;
return this;
}
// 采用单例模式，避免为每个组件都创建一个新的修改器，增加创建产生的性能开销
public static getInstance(): RowModifier {
if (!RowModifier.instance) {
RowModifier.instance = new RowModifier();
}
return RowModifier.instance;
}
// 2.实现AttributeModifier接口的applyNormalAttribute方法，自定义属性设置的逻辑
applyNormalAttribute(instance: RowAttribute) {
if (this.customImage) {
instance.backgroundImage(this.customImage);
instance.backgroundImageSize(ImageSize.Cover);
} else {
instance.backgroundColor(DEFAULT_BACKGROUND_COLOR);
instance.justifyContent(FlexAlign.Center);
// instance.padding(2)
// instance.margin(2)
// instance.opacity(1)
// instance.clip(false)
// instance.layoutWeight(1)
// instance.backgroundBlurStyle(BlurStyle.NONE)
// instance.alignItems(VerticalAlign.Center)
// instance.borderWidth(1)
// instance.borderColor(Color.Pink)
// instance.borderStyle(BorderStyle.Solid)
// instance.expandSafeArea([SafeAreaType.SYSTEM])
// instance.rotate({ angle: 5 })
// instance.responseRegion({x: 0})
//instance.mouseResponseRegion({x: 0})
// instance.constraintSize({minWidth: 25})
// instance.hitTestBehavior(HitTestMode.Default)
//instance.backgroundImagePosition(Alignment.Center)
//instance.foregroundBlurStyle(BlurStyle.NONE)
}
instance.size({ width: 50, height: 50 });
instance.borderRadius(25);
}
}
@Component
struct Avatar {
@ObjectLink user: User;
build() {
Row() {
if (!this.user.avatarImage) {
Text(this.user.name.charAt(0))
.fontSize(28)
.fontColor(Color.White)
.fontWeight(FontWeight.Bold)
}
}
// 3.将自定义RowModifier类作为参数传入，实现按需注册属性
.attributeModifier(RowModifier.getInstance().setCustomImage(this.user.avatarImage))
}
}
```
对于上述两种方案，逐渐增加注册的属性个数，通过DevEco Studio提供的场景化调优工具DevEco Profiler获取两个方案的页面加载耗时（PageRouterManager::LoadPage）和应用侧首帧耗时（First Frame - App Phase），对比如下：
|    | 静态注册属性  | 动态注册属性  |
| --- | --- | --- |
| 注册的属性个数  | 6个  | 12个  | 18个  | 24个  | 6个  | 12个  | 18个  | 24个  |
| PageRouterManager::LoadPage  | 639ms900μs  | 668ms624μs  | 719ms139μs  | 764ms437μs  | 640ms989μs  | 662ms112μs  | 705ms407μs  | 717ms294μs  |
| First Frame - App Phase  | 45ms554μs  | 45ms638μs  | 52ms918μs  | 52ms643μs  | 44ms603μs  | 43ms923μs  | 46ms709μs  | 46ms355μs  |
静态注册属性
动态注册属性
注册的属性个数
6个
12个
18个
24个
6个
12个
18个
24个
PageRouterManager::LoadPage
639ms900μs
668ms624μs
719ms139μs
764ms437μs
640ms989μs
662ms112μs
705ms407μs
717ms294μs
First Frame - App Phase
45ms554μs
45ms638μs
52ms918μs
52ms643μs
44ms603μs
43ms923μs
46ms709μs
46ms355μs
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151036.01121227517006313884585052919622:50001231000000:2800:D793963B3E21DA6D682C15D70CE75AA4BD685761B9244FD319AE9A24DFCD0786.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151036.69576267553555888647978066999685:50001231000000:2800:426BC8A7B81DF811BF97F24D10B87E54809753B39C5C544AA7FA54C9B4B67948.png)
可以看到，当注册的属性个数较少时，使用动态注册的方案收益并不明显。当注册的属性个数递增时，动态注册的收益效果同步线性递增。
优先使用@Builder方法代替自定义组件
在ArkUI中使用自定义组件时，在build阶段将在后端FrameNode树创建一个相应的CustomNode节点，在渲染阶段时也会创建对应的RenderNode节点，如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151036.04805740053325129109357591135618:50001231000000:2800:77664DA18DE208C38CB1A6A8CEFAC0B09CC68BBB5000BF4349441D60F68E0572.png)
因此，在应用开发时，减少自定义组件的使用，尤其是自定义组件在循环中的使用，将成倍减少FrameNode节点树上CustomNode节点数量，有效缩短页面的加载和渲染时长。当在应用中使用自定义组件时，可以优先考虑使用@Builder函数代替自定义组件，@Builder函数不会在后端FrameNode节点树上创建一个新的树节点。如，在使用ForEach循环展示卡片列表信息时，若卡片组件仅作展示，无需使用自定义组件的复杂能力如生命周期函数时，可以创建一个@Builder函数代替创建自定义卡片组件，界面展示如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151036.70877271674664767100514308224293:50001231000000:2800:7B44FEB55260007217249BCBEA2D32D57BDF9DB2AD05D5AA613DE9B8E70A95E8.png)
使用自定义组件方案，示例代码如下：
改用@Builder函数的方式代替自定义组件UserCard的方案，具体修改的代码如下:
将组件数量从30个递增到3000个，通过profiler获取页面加载标签PageRouterManager::LoadPage和页面UI刷新任务标签UITaskScheduler::FlushTask的耗时，对比两种方案的耗时如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151036.08475509316815618808413704711440:50001231000000:2800:BD2CD3730EA6939CF41EB5A02AB9F831EE52748ADA781A334192B0151CBA728A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151036.42691633418731511264068744262509:50001231000000:2800:707D63B9FD33682C610BF3135535B993EA8A013A71C3C97F2F750BF327565064.png)
通过对比图可以看到，@Builder方案在页面加载和刷新UI页面（包括布局、渲染和动画）方面优于自定义组件方案。随着组件个数增加，收益也线性增加。
合理使用布局容器组件
对于需要展示大量组件的场景，通常会使用布局容器组件，以达到快速实现页面布局的需求。在使用布局容器组件时，由于一次需要展示多个组件，可能出现首帧耗时过长甚至掉帧问题。此时可以考虑对容器组件内的子组件进行按需加载或懒加载等处理，对于相同结构的组件也可以使用组件复用能力。针对每个布局容器组件的性能优化可以参考《合理使用布局》。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-improve-layout-performance
爬取时间: 2025-05-01 09:28:47
来源: Huawei Developer
ArkUI框架执行流程
在使用ArkUI开发中，我们通过布局组件和基础组件进行界面描述，这些描述会呈现出一个组件树的结构，基础组件在其中为叶子结点，布局组件则是中间节点，可以把这棵树称之为应用组件树。当用户执行交互（滑动，点击等行为）时会触发界面修改，界面的修改本质上是通过触发这棵组件树的重新渲染，来实现应用界面更新的过程。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151036.68588481332947527811009990605897:50001231000000:2800:27AF02BDA0A94AFD6A2ABF10B0C598852B3270E47B60D25DC7E7A37D535629BB.jpg)
应用界面更新的过程主要分为两个过程：数据处理过程和UI更新过程。
1、数据处理过程中主要是对状态数据进行更新，状态数据指得是所定义的@State等相关的数据。数据变化时，会有一定的更新耗时，并且数据关联的组件数量，也影响下一步UI更新的耗时，那么对于开发过程需要关注的，就是避免无效的数据更新导致冗余的UI更新操作。关于这部分的优化措施可以参考《状态管理最佳实践》。
2、UI更新过程中则是对需要更新的元素进行更新操作，对应的元素会经历Build、Measure、Layout和Render等阶段。其中Build是执行组件创建和组件标脏的过程，Measure是对组件的宽高进行测量的阶段，Layout是对元素进行在屏幕上位置进行摆放的阶段，而Render则是根据测量和布局得到的大小位置等信息，进行提交绘制的过程。
在初次进入页面的时候，所有的组件都会参与到界面的渲染中（换句说法，初次渲染的时候，可以认为所有的组件都需要更新）。
UI更新过程
UI更新过程包含组件标脏过程以及布局过程。在初次加载时，所有的组件都会经历这几个阶段（除去if/else条件为否的分支以及LazyForEach中未在可视区的内容），而在界面更新时（如列表滑动，切换显示隐藏状态，触发页面元素内容样式位置大小等变化等场景下），并不需要把页面所有的组件对象重新创建一遍，而是只需要对需要更新部分进行更新，而需要更新部分则是脏节点数组里包含的内容，UI线程处理过程会先将脏节点进行Build，Build的过程会按照组件id，依次更新组件设置的属性，如果属性发生改变，则进行组件标脏，其中布局属性（width、height、padding、margin等）发生改变会标记为布局脏，找到布局边界，进行子树更新，而非布局（Color、BackgroundColor、opacity等）属性仅会影响自身属性，不会进行子树查找。
多数情况下，需要我们关注的是重新布局带来的影响。如果某个组件的布局发生变化，一般也会对其他组件的布局也会产生影响，所以当有组件的布局发生变化，最简单的办法就是对整棵树进行重新布局，但是这样对整棵树进行重新布局的代价太大，所以需要降低重新布局带来的成本。实际上在一些特定场景下，组件发生变化后只需要对部分组件进行重新布局。标脏过程就是用来确定布局最小影响范围，来减少对整棵树进行重新布局的代价，而这个影响范围就是布局边界以内。
一般来讲，如果一个组件设置了固定的宽高尺寸，那这个组件就是布局边界。其内部组件布局的变化，不会影响到此布局边界外部的布局情况，那么在查找的时候，只需要在布局边界内部判断哪些组件的布局会受到影响，可以避免在整棵树结构的查找过程。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151036.32824917120867899059883005838992:50001231000000:2800:8118121FA3CC6B3E1AB80E40270A62F3987E5CEA8F5C4B0860F19040EC2FA050.jpg)
确定实际的脏节点数组后，根据脏节点数组来拿到对应的脏节点对象，通过递归遍历children进行Measure过程，如果该对象布局参数没有发生变化，就会跳过对应的Measure阶段。当Measure执行完成后，进行layout阶段。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151036.11809738094795946286043390648762:50001231000000:2800:8864B11B7BEB6EFE394AAD4778BCF6DA85F6FE205CAE771084031A85820D4A3B.jpg)
从以上的过程可以看出，影响UI更新过程的主要因素是参与更新的节点数量。
在初次加载的时候，由于所有的节点都要参与全过程，那么如果对首帧渲染的速度有要求，就需要降低整体页面的组件节点数量。
在页面内容更新过程中，由于状态变量的变化导致UI的更新，可以利用布局边界减少子树更新的数量以及减少布局的计算。
精简节点数
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-remove-container-without-property规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
布局阶段是采用递归遍历所有节点的方式进行组件位置和大小的计算， 如果嵌套层级过深，将带来了更多的中间节点，在布局测算阶段下，额外的节点数将导致更多的计算过程，造成性能劣化。我们通过模拟了10、100、500、1000层Row嵌套的情况下，通过Profiler工具抓取Launch数据查看对应的首帧绘制，以及页面Measure/Layout时间进行对比。
然后进一步对比了在平铺的情况下，Row内组件个数在10、100、500、1000的条件下，使用Profiler工具抓取Launch的数据情况，得到如下结果如表1所示。
|  对比指标 |  10 |  100 |  500 |  1000 |
| --- | --- | --- | --- | --- |
|   嵌套/层 |  首帧绘制 |  3.2ms |  5.8ms |  17.3ms |  32ms |
|  Measure |  1.88ms |  2.89ms |  5.93ms |  10.46ms |
|  Layout |  0.38ms |  1.12ms |  5.26ms |  10.88ms |
|   平铺 /个 |  首帧绘制 |  3.6ms |  4.5ms |  14ms |  24.3ms |
|  Measure |  2.15ms |  2.31ms |  5.61ms |  9.26ms |
|  Layout |  0.39ms |  1.38ms |  4.74ms |  9.92ms |
对比指标
10
100
500
1000
嵌套/层
首帧绘制
3.2ms
5.8ms
17.3ms
32ms
Measure
1.88ms
2.89ms
5.93ms
10.46ms
Layout
0.38ms
1.12ms
5.26ms
10.88ms
平铺 /个
首帧绘制
3.6ms
4.5ms
14ms
24.3ms
Measure
2.15ms
2.31ms
5.61ms
9.26ms
Layout
0.39ms
1.38ms
4.74ms
9.92ms
以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151036.77543021533234513224482826332227:50001231000000:2800:C4590292CE28757E11AB1EFBFD8714D5A2B1B3F2FEBE1A74D07DA2162404D3EF.png)
根据以上数据对比发现，组件平铺和嵌套在相同组件个数的情况下，其性能差异不大，并且整体上趋势保持一致，随着组件数量增加呈现线性增长的劣化，由此可以得到结论，真正影响布局性能的因素是参与布局的节点数量。所以在进行布局时，应该尽量减少整体的节点数，来减少布局的性能劣化。
针对减少总节点，主要有两个方向：
移除冗余节点
对于常出现冗余的情况，例如可能会在Row容器包含一个同样也是Row容器的子级。这种嵌套实际是多余的，并且会给布局层次结构造成不必要的开销。
由于其中Row容器父子布局方向相同，所以可以去掉Image和Text外层的Row来减少层级，如果视图更加复杂，布局在渲染时，会产生没有必要的计算。
尽管在这里只是多了一层，但是实际开发中的布局往往非常复杂，冗余带来的开销可能非常影响布局性能，尤其是在列表中动态创建组件时，带来的性能影响是显著的。
使用扁平化布局减少节点数
在某些情况下，开发者所实现的布局在嵌套层级上是没有冗余的，但是嵌套层级仍然较深，可能无法通过调整现有的布局方案，使其不包含多余的布局，唯一的解决方案可能是，通过切换到完全不同的布局类型来实现层次结构的扁平化。
例如图1中元素结构示意图，传统使用线性布局的情况下，总共存在4层嵌套、共15个节点，并且其中并没有冗余的嵌套节点。而扁平化布局是一种让页面结构变浅变宽的方式，通过一些高级组件如RelativeContainer、Grid等容器，可以让元素在平面上展开。这种布局方式能够有效减少由于使用线性布局带来的嵌套深度，将其用于描述布局的容器节点进行优化，达到精简节点数的目的。图一中将线性布局改成相对布局的情况下，嵌套2层、总共10个节点，相比之下前后少了5个节点。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151037.72065306532605579564066867815058:50001231000000:2800:1225D11A0A8D762B6B51A9087AE0ED19076FAFFC056B894A19747911EFC2E583.png)
这种方式对于布局的影响主要体现在：
所以当页面不存在冗余节点时，可以考虑是否能够通过替换为更高级的布局使得页面扁平化，来达到减少节点数的目的。主要方式可以参考：
利用布局边界减少布局计算
对于组件的宽高不需要自适应的情况下，建议在UI描述时给定组件的宽高数值，当其组件外部的容器尺寸发生变化时，例如拖拽缩放等场景下，如果组件本身的宽高是固定的，理论上来讲，该组件在布局阶段不会参与Measure阶段，其节点中保存了对应的大小信息，如果组件内容较多时，由于避免了其中组件整体的测算过程，性能会带来较大的提升。
对比的结果如下：
|  对比指标/ms |  限定容器的宽高为固定值 |  未设置容器的宽高 |  限定容器的宽高为百分比 |
| --- | --- | --- | --- |
|  首帧绘制 |  60.20ms |  59.99ms |  60.50ms |
|  Measure |  17.80ms |  17.76ms |  16.92ms |
|  Layout |  5.5ms |  4.91ms |  4.92ms |
|  重新绘制 |  2.0ms |  38.45ms |  42.62ms |
|  重绘的Measure |  0.50ms |  18.87ms |  20.93ms |
|  重绘的Layout |  0.12ms |  1.41ms |  1.80ms |
对比指标/ms
限定容器的宽高为固定值
未设置容器的宽高
限定容器的宽高为百分比
首帧绘制
60.20ms
59.99ms
60.50ms
Measure
17.80ms
17.76ms
16.92ms
Layout
5.5ms
4.91ms
4.92ms
重新绘制
2.0ms
38.45ms
42.62ms
重绘的Measure
0.50ms
18.87ms
20.93ms
重绘的Layout
0.12ms
1.41ms
1.80ms
由上数据可以发现：
分析原因可以得到，这是由于首次绘制的情况下，无论是否设置宽高属性，都会对所有组件进行布局和测算的过程，来得到最终的组件大小和位置。而当触发按钮修改外层Column的宽度时，也就是触发重新绘制的情况下，给定容器宽高为固定值的性能远远优于未设置宽高和设置百分比宽高，这是由于对于未设置宽高以及设置百分比宽高的情况下，在外层容器宽高发生变化时，组件本身也会触发重新进行Measure的过程，对组件的宽高进行重新测算，导致其布局时间很长，而设置了固定宽高的组件，则不会经过这一过程，而是直接使用初次绘制时保留的节点大小数据，减少了测算的时间，这对于性能的提升是尤为明显的，尤其是当组件内的内容十分复杂的情况下。
所以对于能够在初期给定宽高的组件，在进行UI描述时尽量给定宽高数值，能够减少由于容器尺寸变化造成的重新测算过程的性能。
合理使用渲染控制语法
合理控制元素显示与隐藏
控制元素显示与隐藏是一种常见的场景，使用Visibility.None、if条件判断等都能够实现该效果。其中if条件判断控制的是组件的创建、布局阶段，visibility属性控制的是元素在布局阶段是否参与布局渲染。使用时如果使用的方式不当，将引起性能上的问题。
对于不同的场景下，需要选择合适的手段，根据性能或者内存要求选择不同的实现方式：
通过对一个复杂的视图结构，例如以下示例代码中，对包含100个Image组件的Column容器进行显示与隐藏控制，分别采用if条件判断和visibility属性的方式进行控制。
在相同的测试环境下，分别测试在初次加载页面，以及改变状态变量this.visible的值来修改显示隐藏的情况下，通过Profiler工具抓取的布局时Measure、Layout以及组件创建的时长。
在初次加载的情况下的测试结果如下：
|  对比指标 |  if判断条件为true |  if判断条件为false |  Visibility.Visible |  Visibility.None |
| --- | --- | --- | --- | --- |
|  组件创建时间 |  13.67ms |  3.83ms |  13.38ms |  13.26ms |
|  Measure |  2.83ms |  0.92ms |  2.58ms |  2.24ms |
|  Layout |  3.79ms |  0.30ms |  2.14ms |  0.39ms |
对比指标
if判断条件为true
if判断条件为false
Visibility.Visible
Visibility.None
组件创建时间
13.67ms
3.83ms
13.38ms
13.26ms
Measure
2.83ms
0.92ms
2.58ms
2.24ms
Layout
3.79ms
0.30ms
2.14ms
0.39ms
以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。
通过以上数据可以发现：
在切换显示状态的情况下的结果如下：
|  对比指标 |  if判断条件为true |  if判断条件为false |  Visibility.Visible |  Visibility.None |
| --- | --- | --- | --- | --- |
|  组件创建时间 |  13.67ms |  3.83ms |  \ |  \ |
|  Measure |  3.10ms |  0.13ms |  0.19ms |  0.10ms |
|  Layout |  1.64ms |  0.60ms |  0.27ms |  0.07ms |
对比指标
if判断条件为true
if判断条件为false
Visibility.Visible
Visibility.None
组件创建时间
13.67ms
3.83ms
\
\
Measure
3.10ms
0.13ms
0.19ms
0.10ms
Layout
1.64ms
0.60ms
0.27ms
0.07ms
以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。
在切换显示状态的情况下：
综上所述，在控制组件显示与隐藏时，建议遵循以下原则来选择使用控制方式：
长列表使用懒加载与组件复用
在列表场景下会采用List、Grid、WaterFlow等组件配合ForEach或者LazyForEach来实现，ForEach适合内容长度确定，内容在两屏以内的列表。LazyForEach适合长度超过两屏的列表情况，并且当内容布局相对固定的情况下，配合组件复用的方式来减少滑动过程中的组件创建。在长列表加载性能优化中，介绍了较为详细的实践案例，这里我们仅引用一些关键性能收益数据。
懒加载
针对长列表这一场景，在本地模拟了10、100、1000、10000条数据，分别使用ForEach、LazyForEach，来测试关闭和开启懒加载情况下的完全显示所用时间、列表挂载时间、独占内存，并分析了其滑动过程中的丢帧率。其中，列表挂载时间是指创建组件和组件挂载数据的总时长。最终，使用DevEco Studio的Profiler工具检测下述指标，得到的数据如下所示：
|  ForEach对比指标 |  10条数据 |  100条数据 |  1000条数据 |  10000条数据 |
| --- | --- | --- | --- | --- |
|  完全显示所用时间 |  1s 741ms |  1s 786ms |  1s 942ms |  5s 841ms |
|  列表挂载时间 |  87ms |  88ms |  135ms |  3s 291ms |
|  独占内存（滑动完成后） |  38.2MB |  48.7MB |  83.7MB |  560.1MB |
|  丢帧率 |  0.0% |  3.8% |  4.5% |  58.2% |
ForEach对比指标
10条数据
100条数据
1000条数据
10000条数据
完全显示所用时间
1s 741ms
1s 786ms
1s 942ms
5s 841ms
列表挂载时间
87ms
88ms
135ms
3s 291ms
独占内存（滑动完成后）
38.2MB
48.7MB
83.7MB
560.1MB
丢帧率
0.0%
3.8%
4.5%
58.2%
|  LazyForEach对比指标 |  10条数据 |  100条数据 |  1000条数据 |  10000条数据 |
| --- | --- | --- | --- | --- |
|  完全显示所用时间 |  1s 544ms |  1s 486ms |  1s 652ms |  1s 707ms |
|  列表挂载时间 |  88ms |  89ms |  94ms |  97ms |
|  独占内存（滑动完成后） |  38.1MB |  44.6MB |  46.3MB |  82.9MB |
|  丢帧率 |  0.0% |  2.3% |  3.6% |  6.6% |
LazyForEach对比指标
10条数据
100条数据
1000条数据
10000条数据
完全显示所用时间
1s 544ms
1s 486ms
1s 652ms
1s 707ms
列表挂载时间
88ms
89ms
94ms
97ms
独占内存（滑动完成后）
38.1MB
44.6MB
46.3MB
82.9MB
丢帧率
0.0%
2.3%
3.6%
6.6%
从测试数据可以看出：
组件复用
对于使用LazyForEach的情况下，在滑动过程中由于要动态创建组件，会出现BuildLazyItem的耗时，通过组件复用能力，可以减少滑动过程中的组件创建耗时，而组件复用BuildRecycle耗时极短，进一步优化滑动时的性能。
对比长列表案例中开启组件复用和未开启的情况下，其数据如下：
|  组件复用 |  组件复用前 |  组件复用后 |
| --- | --- | --- |
|  丢帧率 |  3.7% |  0% |
|  BuildLazyItem耗时 |  10.277ms |  0.749ms |
|  BuildRecycle耗时 |  不涉及 |  0.221ms |
|  单帧总耗时 |  13.430ms |  7.310ms |
组件复用
组件复用前
组件复用后
丢帧率
3.7%
0%
BuildLazyItem耗时
10.277ms
0.749ms
BuildRecycle耗时
不涉及
0.221ms
单帧总耗时
13.430ms
7.310ms
可以发现列表滑动时丢帧率明显降低，这是因为，List列表开启了组件复用，不会执行BuildLazyItem这个耗时操作，后续创建新组件节点时，会直接复用缓存区中的节点，这样就大幅节约了组件重新创建的时间。
合理使用布局组件
选择合适的布局组件
在布局时，子组件会根据父组件的布局算法得到相应的排列规则，然后按照规则进行子组件位置的摆放。不同的布局容器使用的布局算法对性能带来的影响不同。开发者应该根据场景选用合适的布局，除非必须，尽量减少使用性能差的布局组件。
我们常用的基础布局组件包含以下组件：
上述布局都属于线性布局，顾名思义，在线性布局中排布的组件是按照特定的方向线性放置，如横向/纵向/Z序方向。除上述布局类型外，还有一些复杂布局能力，如Flex、List、Grid、RelativeContainer和自定义布局等。
复杂布局提供了场景化的能力，解决一种或者多种布局场景。但是在一些场景下，不恰当的使用这些高级组件，可能带来更多的性能消耗。
我们通过对不同的布局方式，设置对应容器相同的嵌套深度为5、总元素节点为20个Text的情况下，来对比其性能消耗。通过Profiler工具获取其首帧绘制时间进行对比。对比结果如下表：
|  对比指标 |  Column/Row |  Stack |  Flex |  RelativeContainer |  Grid/GridItem |
| --- | --- | --- | --- | --- | --- |
|  首帧绘制 |  7.13ms |  7.34ms |  11.71ms |  9.13ms |  12.62ms |
|  Measure |  2.63ms |  2.70ms |  7.59ms |  3.59ms |  8.68ms |
|  Layout |  0.74ms |  0.77ms |  0.83ms |  0.77ms |  0.92ms |
对比指标
Column/Row
Stack
Flex
RelativeContainer
Grid/GridItem
首帧绘制
7.13ms
7.34ms
11.71ms
9.13ms
12.62ms
Measure
2.63ms
2.70ms
7.59ms
3.59ms
8.68ms
Layout
0.74ms
0.77ms
0.83ms
0.77ms
0.92ms
以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。
可以发现，在布局深度和节点数相同的情况下：
以上数据都是基于相同布局层数和节点数的情况下的对比结果，反应了布局本身的相对性能消耗，并不意味着使用了该组件性能就一定差，也并非任何情况下使用基础组件都能够保持良好的性能，因为在一些情况下，使用高级组件能够大大减少嵌套层数和节点数，其带来的性能提升反而高于组件本身的性能消耗。所以在使用布局时尽量遵循以下原则：
Scroll嵌套List场景下，给定List组件宽高
在使用Scroll容器组件嵌套List组件加载长列表时，若不指定List的宽高尺寸，则默认全部加载。
Scroll嵌套List时：
在如下代码案例中，通过Scroll嵌套List，对比List设置宽度和不设置的情况下：
不设置宽高的代码样例如下：
```typescript
import { MyDataSource } from './MyDataSource';
@Entry
@Component
struct NotSetHeightTestPage {
private data: MyDataSource = new MyDataSource();
build() {
Scroll() {
List() {
LazyForEach(this.data, (item: string, index: number ) => {
ListItem() {
Row() {
Text('item value: ' + item + (index + 1)).fontSize(20).margin(10)
}
}
})
}
}
}
}
```
设置固定高度的代码如下：
```typescript
import { MyDataSource } from './MyDataSource';;
@Entry
@Component
struct SetHeightTestPage {
private data: MyDataSource = new MyDataSource();
build() {
Scroll() {
List() {
LazyForEach(this.data, (item: string, index: number ) => {
ListItem() {
Row() {
Text('item value: ' + item + (index + 1)).fontSize(20).margin(10)
}
}
})
}.width('100%').height(500)
}
}
}
```
通过DevEco Studio的Profiler抓取launch数据可以得到如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151037.52222960878925556930983646213241:50001231000000:2800:E9C27F2EE65C07E5E9DFDBBA1C75C35955599AA10964FDA40F3A28E79D46D326.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151037.22514607511332388574303969371575:50001231000000:2800:603C1D382F20E2C7FE0A69256E0C985CA34ADC204BFDB494F2D80CF2AB0B8845.png)
|  对比数据 |  List宽高不固定 |  List宽高固定 |
| --- | --- | --- |
|  布局任务数量LayoutTasks/个 |  100 |  12 |
|  布局时间/ms |  32.43 |  6.08 |
对比数据
List宽高不固定
List宽高固定
布局任务数量LayoutTasks/个
100
12
布局时间/ms
32.43
6.08
未设置宽高的情况下，在进行布局时，从FlushLayoutTask以及FlushRenderTask的数据可以看到参与布局的组件数量是100个，设置了List宽高的情况下，从FlushLayoutTask以及FlushRenderTask的数据可以看到参与布局的组件数量是12个。说明对于Scroll嵌套List的情况下，如果不设置List宽高，由于Scroll是可滚动容器，其高度为无穷大，List在不设置的高度的情况下，高度也为无穷大，所以此时会创建所有的内容。而设置了高度的情况下，只会创建给定高度内的组件内容，所以为12个。体现在布局时间上，没有设置宽高的情况下，总体布局时间是32.43ms，设置了固定宽高数值的情况下，时间为6.08ms，大幅提升了首次加载时的性能。
问题定位工具
性能是一个涉及许多方面的复杂问题。DevEco Studio提供了工具可以为您提供关于性能瓶颈发生位置的明确提示，使用工具Profiler 查看性能参数可以参考使用DevEco Profiler进行性能调优，使用ArkUI Inspector查看组件树结构可以参考布局分析。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-component-nesting-optimization
爬取时间: 2025-05-01 09:29:00
来源: Huawei Developer
本文通过原理概念、优化场景和实践数据对比三个角度，详细介绍了组件嵌套的优化，着重从优化场景角度为开发者阐明组件嵌套的优化场景以及优化策略。
原理概述
本章节将从原理角度分析，通过ArkUI框架的执行流程，以及自定义组件的生命周期两个角度，来分析组件过度嵌套对性能的影响。
ArkUI框架执行流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151037.52929226934445329565209243886515:50001231000000:2800:6C651E8EA9259253EA57B2FBB7F3CB8D0A93F3E168C90207D15FB7A8445E31AE.png)
如上图所示，可以看到ArkUI框架的执行顺序：
自定义组件的生命周期
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151037.56044926361058887661371776348759:50001231000000:2800:571EDD42BC7650EB78A64851BACD5D129934943FFE9CD1F262DF61FA1757DAA2.png)
如上图所示，自定义组件创建完成之后，在build函数执行之前，将先执行aboutToAppear()生命周期回调函数。执行完build函数后，还会有一些事件监听函数，例如可以使用onPageShow监听页面显示事件，onPageHide函数可以监听页面隐藏事件。最终在自定义组件析构销毁前执行aboutToDisappear函数。
具体的页面和自定义组件生命周期可以参考《页面和自定义组件生命周期》。
组件过度嵌套对性能的影响
组件嵌套是指一个组件包含另一个或多个组件的情况，这种嵌套关系可以形成组件树的结构。从最外层组件的类型来看，可以分为自定义组件嵌套和原生组件嵌套。
从ArkUI框架的执行流程上分析，布局时会采用递归遍历所有节点的方式进行组件位置和大小的计算。嵌套层级过深将带来更多的中间节点，在布局测算阶段下，额外的节点数将导致更多的计算过程，造成性能消耗。
从自定义组件的生命周期的角度上分析，如果自定义组件过度嵌套，则会有大量的生命周期函数需要执行，消耗性能。
详细的组件嵌套性能数据分析可参考《精简节点数》。
优化场景
优先使用@Builder方法代替自定义组件
自定义组件与自定义构建函数概念定义如下：
自定义组件：用@Component修饰的struct结构体称为自定义组件，在自定义组件中可以定义函数/变量、build()方法、组件的生命周期回调等。自定义组件具有可组合、可重用和数据驱动UI更新的特点。
自定义构建函数：@Builder装饰的函数称为“自定义构建函数”，分为组件内自定义构建函数和全局自定义构建函数。@Builder所装饰的函数遵循build()函数语法规则，开发者可以将重复使用的UI元素抽象成一个方法，在build方法里调用。
自定义组件和自定义构建函数（@Builder）的主要区别如下：
整体上，自定义组件在实际应用开发场景中更加通用、灵活。自定义构建函数（@Builder）由于不支持定义变量和生命周期等限制，在使用场景上灵活性受限，多用在插槽或系统提供的组件/方法里面属性传值类型为Builder类型场景中。
根据上面自定义组件与自定义构建函数的区别可以看出，由于@Builder不涉及生命周期，在自定义组件大量嵌套的场景中，更加轻量级的@Builder在性能方面更加出色。
因此，当自定义组件不涉及到状态变量和自定义生命周期时，可以优先使用@Builder替换自定义组件，提升性能。
优化策略
自定义组件示例代码：
自定义构建函数示例代码：
具体可以参考UI组件性能优化-优先使用@Builder方法代替自定义组件。
减少自定义组件产生多余节点
自定义组件自身为非渲染节点，仅是组件树和状态数据的组合，常规使用自定义组件时并不会产生多余的节点。但是给自定义组件添加属性后，会将自定义组件作为一个整体节点进行处理。对内部的组件树进行操作，如背景色绘制、圆角绘制等都会作用在该节点上。
通过DevEco Studio内置ArkUI Inspector工具，查看组件树结构可以看到，相比使用@Builder方法，组件树多一个自定义组件节点，所以优先使用@Builder方法代替自定义组件减少了自定义组件节点数量。而给自定义组件添加属性，会在自定义组件外部会创建一个“__Common__”类型的节点，如下图所示。为了避免这类“__Common__”节点的创建，可以将自定义组件的属性移至内部，或者动态设置自定义组件的属性。减少自定义组件产生多余节点，可以使总节点数量降低，从而提升性能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151037.15934032330292240545757314612471:50001231000000:2800:6F4F37AA7E1B0EEDAD67611406F897470698C044CF5ECD92F136CE9F6B91A4D3.png)
将自定义组件的属性移至内部
当需要给自定义组件添加属性时，一般少量属性的场景下，可以将这些属性移至自定义组件内部，具体优化示例如下所示。
反例：
正例：
动态设置自定义组件的属性
ArkUI提供了动态属性设置的接口，支持使用自定义AttributeModifier构建组件并配置属性。当需要给自定义组件设置较多属性时，如果将所有的属性设置都内移，会出现传递参数过多的问题，同时也会创建更多状态变量，增加参数的传递耗时。虽然减少了节点数量，但是性能没有得到有效提升。推荐使用自定义AttributeModifier的方式来动态设置自定义组件的属性，减少节点数量的同时，也避免了参数过多导致耗时的问题，具体优化示例如下所示。
选择合适的布局组件
复杂布局提供了场景化的能力，解决一种或者多种布局场景。但是在一些场景下，不恰当的使用这些高级组件，可能带来更多的性能消耗。
优化策略：
具体可以参考合理使用布局-合理使用布局组件
删除无用的Stack/Column/Row嵌套，移除冗余节点
在组件嵌套的情况中，可以找到一些无用的容器组件嵌套。在考虑组件嵌套优化中，可以删除掉无用容器组件嵌套，移除冗余节点，从而避免冗余节点对性能的消耗。
优化方式：
反例：
正例：
优先使用组件属性代替嵌套组件
在实现文本浮层、按压遮罩或颜色叠加等场景时，通常会采用Stack布局嵌套组件的方式。实际上有些场景直接使用组件属性或借助系统API的能力就能实现，例如使用overlay属性可以实现浮层场景，使用ColorMetrics可以实现颜色叠加效果。直接使用组件属性的方式可以减少Stack布局嵌套组件的使用，从而减少嵌套组件带来的节点数。以文本浮层场景为例，如下图所示，使用overlay属性实现文本浮层比Stack组件嵌套方式少了一层Stack节点。开发这一类场景时，推荐优先使用组件属性代替嵌套组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151037.04765228482756360959994259148455:50001231000000:2800:A127B167B854F32A22458035C539F6C7BF1C694E2B8BB1B76304E8215538C638.png)
使用overlay属性实现浮层
使用overlay属性可以直接给组件添加浮层，实现堆叠的效果，常见的场景有文本浮层、按压遮罩等。相较于Stack布局嵌套组件的方式，使用overlay属性减少了Stack组件节点的创建。以增加文本浮层为例，具体优化示例如下所示。更多使用overlay属性实现浮层场景的示例可参考浮层-示例。
反例：
正例：
使用ColorMetrics实现颜色叠加
系统通过ColorMetrics接口提供了颜色计算能力，可以用于颜色叠加显示的场景。同样，与Stack布局嵌套组件的方式相比，直接使用ColorMetrics能力可以减少Stack层的布局节点，具体优化示例如下所示。
反例：
正例：
```typescript
import { ColorMetrics } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
@Component
struct ColorMeasure {
@Prop isSelected: boolean = false;
build() {
Column()
.width('100%')
.height(100)
.backgroundColor(this.isSelected ? this.getBlendColor(Color.Blue, "#99000000").color : Color.Grey)
.borderRadius(12)
.alignItems(HorizontalAlign.Center)
.justifyContent(FlexAlign.Center)
}
getBlendColor(baseColor: ResourceColor, addColor: ResourceColor): ColorMetrics {
if (!baseColor || !addColor) {
return ColorMetrics.resourceColor(Color.Black);
}
let sourceColor: ColorMetrics;
try {
sourceColor = ColorMetrics.resourceColor(baseColor).blendColor(ColorMetrics.resourceColor(addColor));
} catch (err) {
let error = err as BusinessError;
console.error(`Failed to blend color, code = ${error.code}, message =${error.message}`);
sourceColor = ColorMetrics.resourceColor(addColor);
}
return sourceColor;
}
}
@Entry
@Component
struct ColorMetricsExample {
@State isSelected: boolean = false;
build() {
Scroll() {
Column() {
ColorMeasure({ isSelected: this.isSelected })
.onClick(() => {
this.isSelected = !this.isSelected;
})
}
}
}
}
```
实践数据对比
关于实践数据对比部分，具体可以参考合理使用布局和UI组件性能优化的数据对比部分。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-status-management
爬取时间: 2025-05-01 09:29:14
来源: Huawei Developer
概述
在声明式UI编程范式中，UI是应用程序状态的函数，应用程序状态的修改会更新相应的UI界面。ArkUI采用了MVVM模式，其中ViewModel将数据与视图绑定在一起，更新数据的时候直接更新视图。如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151037.53587731498710075600172980637390:50001231000000:2800:416A4C9F4944E017841EE76DD3710A9253F48502C2E28AEAB7921135877FE691.png)
ArkUI提供了一系列装饰器实现ViewModel的能力，如@Prop、@Link、@Provide、LocalStorage等。当自定义组件内变量被装饰器装饰时变为状态变量，状态变量的改变会引起UI的渲染刷新。
在ArkUI的开发过程中，如果没有选择合适的装饰器或合理的控制状态更新范围，可能会导致以下问题：
1. 状态和UI的不一致，如同一状态的界面元素展示的UI不同，或UI界面展示的不是最新的状态。
2. 非必要的UI视图刷新，如只修改局部组件状态时导致组件所在页面的整体刷新。
当用户与界面产生交互行为时，状态的修改是通过事件驱动处理的。事件的处理可以在应用的任何地方，如果没有进行适当的逻辑处理管理也会导致代码冗余和不利于维护。
本文旨在从装饰器的选择、使用以及状态的逻辑处理管理方面解决以上问题，以实现更好的状态管理。
合理选择装饰器
避免不必要的状态变量的使用
删除冗余的状态变量标记
状态变量的管理有一定的开销，应在合理场景使用，普通的变量用状态变量标记可能会导致性能劣化。
反例1
以上示例中变量translateObj，buttonMsg没有关联任何UI组件，没有关联任何UI组件的状态变量不应该定义为状态变量，否则读写状态变量都会影响性能。
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-remove-redundant-state-var规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
反例2
以上示例中变量buttonMsg仅有读取操作，没有修改操作，未修改过的状态变量不应定义为状态变量，否则读状态变量会影响性能。
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-remove-unchanged-state-var规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
正例
```typescript
@Observed
class Translate {
translateX: number = 20;
}
@Entry
@Component
struct UnnecessaryState1 {
@State translateObj: Translate = new Translate(); // 同时存在读写操作，并关联了Button组件，推荐使用状态变量
buttonMsg = 'I am button'; // 仅读取变量buttonMsg的值，没有任何写的操作，直接使用一般变量即可
build() {
Column() {
Button(this.buttonMsg)
.onClick(() => {
animateTo({
duration: 50
}, () => {
this.translateObj.translateX = (this.translateObj.translateX + 50) % 150; // 点击时给变量translateObj重新赋值
})
})
}
.translate({
x: this.translateObj.translateX // 读取translateObj中的值
})
}
}
```
在代码中，buttonMsg变量因仅用于读取操作而被定义为普通成员变量，而translateObj变量则因需要根据用户事件改变其x值以驱动动画效果，故被定义为状态变量，并实时更新UI以显示动画。
建议使用临时变量替换状态变量
状态变量发生变化时，ArkUI会查询依赖该状态变量的组件并执行依赖该状态变量的组件的更新方法，完成组件渲染的行为。通过使用临时变量的计算代替直接操作状态变量，可以使ArkUI仅在最后一次状态变量变更时查询并渲染组件，减少不必要的行为，从而提高应用性能。状态变量行为可参考@State装饰器：组件内状态。
反例
```typescript
@Entry
@Component
struct Index {
@State message: string = '';
// 定义改变状态变量的方法（多次修改状态变量）
appendMsg(newMsg: string) {
this.message += newMsg;
this.message += ';';
this.message += '<br/>';
}
build() {
Column() {
Button('点击打印日志')
.onClick(() => {
this.appendMsg('操作状态变量'); // 调用封装的改变状态变量的方法
})
.width('90%')
.backgroundColor(Color.Blue)
.fontColor(Color.White)
.margin({ top: 10})
}
.justifyContent(FlexAlign.Start)
.alignItems(HorizontalAlign.Center)
.margin({  top: 15 })
}
}
```
正例
```typescript
@Entry
@Component
struct UnnecessaryState2 {
@State message: string = '';
// 定义改变状态变量的方法（方法执行过程中操作中间变量，状态变量只修改一次）
appendMsg(newMsg: string) {
let message = this.message;
message += newMsg;
message += ';';
message += '<br/>';
this.message = message;
}
build() {
Column() {
Button('点击打印日志')
.onClick(() => {
this.appendMsg('操作临时变量'); // 调用封装的改变状态变量的方法
})
.width('90%')
.backgroundColor(Color.Blue)
.fontColor(Color.White)
.margin({ top: 10 })
}
.justifyContent(FlexAlign.Start)
.alignItems(HorizontalAlign.Center)
.margin({ top: 15 })
}
}
```
最小化状态共享范围
在没有强烈的业务需求下，尽可能按照状态需要共享的最小范围选择合适的装饰器。应用开发过程中，按照组件颗粒度，状态一般分为组件内独享的状态和组件间需要共享的状态。
组件内独享的状态
组件内独享的状态的生命周期和组件同步，状态的定义和更新都在组件内，组件销毁，状态也随即消失。常见于界面UI元素数据，比如当前按钮是否可用、文字是否高亮等。组件内独享的状态使用@State装饰器，被@State装饰器修饰后状态的修改只会触发当前组件实例的重新渲染。如下图主题列表上单个主题组件内使用@State修饰主题是否被选中的变量，当在界面点击主题时在组件内直接修改状态值。此时，只有当前主题的组件实例会重新渲染，其他主题组件不会重新渲染。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151038.95461687088138362349560622301166:50001231000000:2800:656FEF82ECD3186210AC20BCDE49C8AB006A046C911A6D392532451B962B16A5.png)
组件间需要共享的状态
组件间需要共享的状态，按照共享范围从小到大依次有三种场景：父子组件间共享状态，不同子树上组件间共享状态和不同组件树间共享状态。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151038.50120155688179652860902549367942:50001231000000:2800:A7699D3A032C1C4A6CEF6E1F68E6AEB35B43D555767204B56D8C178BA4D78C91.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151038.34847477130354749426869850117477:50001231000000:2800:C01FBD5791884A046EEC9BF36EED7EDF58E4925327F1502DA2B850925A5A0739.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151038.28051848710216866371604513867200:50001231000000:2800:3558AF6D4C24305B091A192F95014C1056164A13961645396442BE1F8E3EBA3A.jpg)
对于上述三种场景，ArkUI提供了@State+@Prop、@State+@Link、@State+@Observed+@ObjectLink、@Provide+@Consume、AppStorage、LocalStorage六种装饰器组合以解决不同范围内的组件间状态共享。按照共享范围能力从小到大，各装饰器组合的共享范围能力和生命周期如下：
按照软件开发原则，应优先选择共享范围能力小的装饰器方案，减少不同模块间的数据耦合，便于状态及时回收。建议选择装饰器的优先级为：@State+@Prop、@State+@Link、@State+@Observed+@ObjectLink > @Provide+@Consume > LocalStorage > AppStorage。
减少不必要的参数层层传递
当按照上述优先级选择装饰器时，由于@State+@Prop、@State+@Link、@State+@Observed+@ObjectLink三种方案的实现方式是逐级向下传递状态，当共享状态的组件间层级相差较大时，会出现状态层层传递的现象。对于状态传递过程中途经的全部组件，都需要增加入参接收该状态再将状态传递给子组件。对于没有使用该状态的中间组件而言，这是“额外的消耗”，不利于代码的维护和拓展。尤其是当业务体系庞大时，需求变更容易出现“牵一发而动全身”的问题。
以“HMOS世界App”中路由状态为例，其“探索”Tab和“我的”Tab界面组件如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151038.27746445324492206776425201279871:50001231000000:2800:76C49DBB93707DFBF32D8BF24B754FB587EF92FCFA5840FF6B07E334C1E89A3C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151038.77660121695883401415938267577226:50001231000000:2800:D3712F51F698B267418B3C75A84ABDD1EE107C946689E4C551280643D4F7BCA6.png)
项目中使用Navigation组件管理路由，定义“appNavigationStack”变量表示应用当前的路由信息。现“DiscoverView”组件和“ResourceListView”组件需要共享路由信息状态。按照@State+@Prop层层传递的方案，当前各组件的设计如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151038.27728015070504875201000550461408:50001231000000:2800:54284442C3D34171826C11276BB11E4B4CCC7E1AB6F7C44829BF973209AB197A.jpg)
可以看到，为了实现“ResourceListView”组件和“DiscoverView”组件共享状态，将状态定义在两者的最近公共祖先“MainPage”组件上。对公共祖先到两个需要共享路由状态的组件路径上的所有组件使用@Prop装饰器接收“appNavigationStack”参数，层层传递，直到两个需要共享状态的组件。
若此时产品需要新增功能，该功能要求在“DiscoverView”组件的后代“ActionButtonView”组件上新增对路由信息的判断逻辑。此时开发者需修改上述各个组件设计如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151038.36987617039203369236594703932658:50001231000000:2800:347D012E7E0C134197036E876450120486284593165F3795232DFB8CCD01FB50.jpg)
可以看到，新功能的逻辑原本只是在“ActionButtonView”这一个组件中使用，开发者却需要修改从“DiscoverView”组件到“ActionButtonView”组件路径上3个组件的结构。若当业务后续再次变更为无需使用该状态时，也同样需要修改多个组件。这显然不是很好的实现方案。
此时使用@Provide+@Consume方案更为合理。同样是“ResourceListView”组件和“DiscoverView”组件共享状态，此方案各组件设计如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151039.03594941748413483242178127492851:50001231000000:2800:C800528F485C7CAB011FA27082DB551FC03FA6C91C24C11A427BC1BD8E3C69D3.jpg)
通过在最顶部组件“MainPage”中注入key值为“appNavigationStack”的路由信息状态，其后代组件均可以通过@Consume装饰器获取该状态值。当业务变动需要“DiscoverView”的后代“ActionButtonView”组件也共享路由信息时，此方案只需在组件“ActionButtonView”上使用@Consume装饰器直接获取路由信息状态，而无需修改其他组件。此时各组件设计如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151039.04812244538810463986641927842005:50001231000000:2800:84D6E9F6E0CCD79E5239B1B164289CE59336D0E4212B74940FEF96D96F9498F7.jpg)
因此当共享状态的组件间跨层级较深时，或共享的信息对于整个组件树是“全局”的存在时，选择@Provide+@Consume的装饰器组合代替层层传递的方式，能够提升代码的可维护性和可拓展性。
按照状态复杂度选择装饰器
对于上述具有相同优先级的装饰器选择方案@State+@Prop、@State+@Link和@State+@Observed+@ObjectLink。在选择方案时，需要结合具体的业务场景和状态数据结构的复杂度。这三种不同的装饰器组合方案在内存消耗、性能消耗和对数据类型的支持能力都不相同，如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151039.47088677122636635526619383602107:50001231000000:2800:53DDCE4012A712DDA080BACD9F9AE4384A2F47352340FE066FE30D9DB750E649.jpg)
结合三个方案的特性，在选择时有如下建议：
总结
在实际开发中，合理选择装饰器主要包含以下三步：
1.首先根据状态需要共享的范围大小，尽量选择共享能力小的装饰器方案，优先级依次为@State+@Prop、@State+@Link或@State+@Observed+@ObjectLink > @Provide+@Consume > LocalStorage > AppStorage。
2.当共享的状态的组件间层级相差较大时，为避免较差的代码可扩展性和可维护性，@Provide+@Consume的方案要优于层层传递的共享方案。
3.对于具有相同优先级的@State+@Prop、@State+@Link或@State+@Observed+@ObjectLink 三个方案，应结合状态的复杂程度和装饰器各自的特性选择。
实际开发中，应根据业务需求衡量优先级选择合适的装饰器，整体可参考如下建议：
精细化拆分复杂状态
对于AppStorage的使用，由于其作用范围最广，开发者为了方便开发容易将各种状态存入其中以达到共享的目的，这通常会造成大量的性能损失。
这是因为，在ArkUI中状态的修改刷新是粗颗粒的。使用装饰器修饰对象类型状态时，ArkUI能监听到对象本身值的变化以及对象的属性值的变化。当对象属性值发生变化后，ArkUI会以整个对象颗粒度通知所有使用了该状态的组件重新渲染，而不是按属性颗粒度大小通知使用了该变化属性的组件重新渲染。
对AppStorage的使用，以“HMOS世界App”中共享用户信息和用户收藏信息为例，描述如何拆分状态存储。用户信息和用户收藏信息涉及的模块和界面展示如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151039.28416735969664792973467999525400:50001231000000:2800:AD0DB98F129267492F143EB64B10E7E74FB9B5C74532E239DB9DC514AE5A8B02.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151039.25876097485836577319526852358902:50001231000000:2800:C3F7A44ACD69C3B266D1AC4C1A08BA52DCA08A1BE8E05D67CD608610458E5BA0.png)
现在“探索“模块和“我的“模块需要共享用户的收藏列表信息，只需要共享收藏的文章id数组即可。不同模块间的状态共享考虑将其也存储在AppStorage中，有如下两种存储方案：
1. 收藏信息也是用户信息的一部分，将收藏信息作为用户信息userData的一个属性，存储在当前AppStorage里key值为“userData”的变量上。
2. 收藏信息单独存入AppStorage中，不与用户信息userData绑定。
第一种方案的代码实现如下：
这种实现方案下，当用户在“UserInfoView ”组件上重新修改用户描述信息userData.description属性值时，属性值变化将同步回AppStorage中。ArkUI监听到AppStorage中key值为“userData”的值变化，随后通知所有使用了AppStorage中key值为“userData”的组件重新渲染。
在上述界面中，“我的“模块中展示用户信息的组件“UserInfoView ”会重新渲染。由于“探索”模块的文章卡片组件ArticleCardView 通过@StorageLink装饰器绑定了AppStorage中key值为“userData”的变量，所有的文章卡片组件也都会重新渲染。而这些组件与用户描述信息无关，不应该被描述信息的修改变化影响，从而导致渲染刷新。
改为使用上述第二种方案实现，代码如下：
在此方案中，由于文章卡片组件没有绑定AppStorage中key值为“userData”的变量，当用户编辑修改了用户描述userData.description的值时， 文章卡片组件不会重新渲染。
并且，当用户点击文章卡片上的收藏按钮修改文章收藏状态时，变化同步回AppStorage中的key值为“collectedIds”的变量。ArkUI监听到AppStorage中key值为“collectedIds”的值变化，只会通知所有绑定了AppStorage中key值为“collectedIds”变量的组件重新渲染，不会造成“我的“模块用户信息组件“UserInfoView ”重新渲染。
因此，从性能的角度考虑，在使用LocalStorage或AppStorage装饰器存储状态变量时需要合理设计状态的数据结构，避免无意义的渲染刷新。
过分追求状态结构拆分可能在某些场景导致组件设计过度，不利于维护。此时，可以将对象或类上经常一起改变的几个属性聚合成一个新的对象或类模型，并使用@Observed装饰器修饰，再作为属性挂载到之前的对象或类上。通过此方法，当属性变化时ArkUI只会通知变化给新的对象或类，不会通知最上层的对象。这样既可以有效的减少无用渲染次数，又能使代码更好维护。
如类ClassA上存在属性b、c、d。其中c和d经常一起发生变化，即当c的状态修改时同时也要修改d的状态。
此时，将c和d组合在一起做为新的类ClassE的属性并使用@Observed装饰器修饰。对于ClassA去掉c、d属性，新增属性e且其类型为ClassE，设计如下：
使用此方案，在AppStorage中存入数据结构为ClassA的变量。当ClassA实例的属性e中的属性c的值变化时，ArkUI框架会通知使用ClassE实例的组件重新渲染，不会通知所有使用AppStorage中ClassA实例的组件更新，即只使用了ClassA实例b属性的组件不会重新渲染。
集中化状态修改逻辑
在使用@Link装饰器时，开发者可以直接在@Link装饰器接收状态的组件内部修改状态。当多个子组件修改状态的逻辑基本相同时，建议将状态的修改集中到单个函数中，以提升逻辑的可复用性、代码的可维护性和可测试性。
如在“HMOS世界App”的探索模块首页上点击资讯卡片、文章卡片或顶部轮播图时，都会跳转到详情页，交互效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151039.40641773276236110524628126922040:50001231000000:2800:10C9091104711EA06F188197384C7F99FC569E6DF702124B41297DF88FFC1300.png)
可以看到，通过将子组件的相似逻辑提升到父组件中集中处理，相同的逻辑代码只需要写一份。否则，上述代码需要在“BannerView ”、“HotFeedsView”、“TechArticlesView”三个组件各写一份跳转逻辑处理代码。当业务逻辑变动时，也只需修改单个函数“jumpDetail”。在开发中，除了界面逻辑可以集中在界面处理，业务逻辑也可以抽取成单个文件集中处理，解耦UI与数据便于逻辑复用。适当的对逻辑进行集中处理，能有效提升代码的可维护性和可复用性。
使用监听和订阅精准控制组件刷新
多个组件依赖对象中的不同属性时，直接关联该对象会出现改变任一属性所有组件都刷新的现象，可以通过将类中的属性拆分组合成新类的方式精准控制组件刷新。
在多个组件依赖同一个数据源并根据数据源变化刷新组件的情况下，直接关联数据源会导致每次数据源改变都刷新所有组件。为精准控制组件刷新，可以采取以下策略。
使用 @Watch 装饰器监听数据源
在组件中使用@Watch装饰器监听数据源，当数据变化时执行业务逻辑，确保只有满足条件的组件进行刷新。
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/multiple-associations-state-var-check规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
反例
在下面的示例代码中，多个组件直接关联同一个数据源，但是未使用@Watch装饰器和Emitter事件驱动更新，导致了冗余的组件刷新。
```typescript
@Entry
@Component
struct Index {
@State currentIndex: number = 0; // 当前选中的列表项下标
private listData: string[] = [];
aboutToAppear(): void {
for (let i = 0; i < 10; i++) {
this.listData.push(`组件 ${i}`);
}
}
build() {
Row() {
Column() {
List() {
ForEach(this.listData, (item: string, index: number) => {
ListItem() {
ListItemComponent({ item: item, index: index, currentIndex: this.currentIndex })
}
})
}
.alignListItem(ListItemAlign.Center)
}
.width('100%')
}
.height('100%')
}
}
@Component
struct ListItemComponent {
@Prop item: string;
@Prop index: number; // 列表项的下标
@Link currentIndex: number;
private sizeFont: number = 50;
isRender(): number {
console.info(`ListItemComponent ${this.index} Text is rendered`);
return this.sizeFont;
}
build() {
Column() {
Text(this.item)
.fontSize(this.isRender())// 根据当前列表项下标index与currentIndex的差值来动态设置文本的颜色
.fontColor(Math.abs(this.index - this.currentIndex) <= 1 ? Color.Red : Color.Blue)
.onClick(() => {
this.currentIndex = this.index;
})
}
}
}
```
上述示例中，每个ListItemComponent组件点击Text后会将当前点击的列表项下标index赋值给currentIndex，@Link装饰的状态变量currentIndex变化后，父组件Index和所有ListItemComponent组件中的Index值都会同步发生改变。然后，在所有ListItemComponent组件中，根据列表项下标index与currentIndex的差值的绝对值是否小于等于1来决定Text的颜色，如果满足条件，则文本显示为红色，否则显示为蓝色，下面是运行效果图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151040.42532540430720389265679783395315:50001231000000:2800:5567D89A25F04BF05FBAC89AE1A2987658DBAE97E8853AEC18F8FBA3427D1DA1.gif)
可以看到每次点击后即使其中部分Text组件的颜色并没有发生改变，所有的Text组件也都会刷新。这是由于ListItemComponent组件中的Text组件直接关联了currentIndex，而不是根据currentIndex计算得到的颜色。
针对上述父子组件层级关系的场景，推荐使用状态装饰器@Watch监听数据源。当数据源改变时，在@Watch的监听回调中执行业务逻辑。组件关联回调的处理结果，而不是直接关联数据源。
正例
下面是对上述示例的优化，展示如何通过@Watch装饰器实现精准刷新。
```typescript
@Entry
@Component
struct UseWatchListener {
@State currentIndex: number = 0; // 当前选中的列表项下标
private listData: string[] = [];
aboutToAppear(): void {
for (let i = 0; i < 10; i++) {
this.listData.push(`组件 ${i}`);
}
}
build() {
Row() {
Column() {
List() {
ForEach(this.listData, (item: string, index: number) => {
ListItem() {
ListItemComponent({ item: item, index: index, currentIndex: this.currentIndex })
}
})
}
.height('100%')
.width('100%')
.alignListItem(ListItemAlign.Center)
}
.width('100%')
}
.height('100%')
}
}
@Component
struct ListItemComponent {
@Prop item: string;
@Prop index: number; // 列表项的下标
@Link @Watch('onCurrentIndexUpdate') currentIndex: number;
@State color: Color = Math.abs(this.index - this.currentIndex) <= 1 ? Color.Red : Color.Blue;
isRender(): number {
console.info(`ListItemComponent ${this.index} Text is rendered`);
return 50;
}
onCurrentIndexUpdate() {
// 根据当前列表项下标index与currentIndex的差值来动态修改color的值
this.color = Math.abs(this.index - this.currentIndex) <= 1 ? Color.Red : Color.Blue;
}
build() {
Column() {
Text(this.item)
.fontSize(this.isRender())
.fontColor(this.color)
.onClick(() => {
this.currentIndex = this.index;
})
}
}
}
```
上述代码中，ListItemComponent组件中的状态变量currentIndex使用@Watch装饰，Text组件直接关联新的状态变量color。当currentIndex发生变化时，会触发onCurrentIndexUpdate方法，在其中将表达式的运算结果赋值给状态变量color。只有color的值发生变化时，Text组件才会重新渲染，运行效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151040.46524928875754234825196157283860:50001231000000:2800:0DFC9B632F471C94AB169B925850988672EE3990E5CDF16E2BE2DE638BB11656.gif)
被依赖的数据源仅在父子或兄弟关系的组件中传递时，可以参考上述示例，使用@State/@Link/@Watch装饰器进行状态管理，实现组件的精准刷新。
当组件关系层级较多但都归属于同一个确定的组件树时，推荐使用@Provide/@Consume传递数据，使用@Watch装饰器监听数据变化，在监听回调中执行业务逻辑。
使用自定义事件发布订阅
当组件关系复杂或跨越层级过多时，推荐使用EventHub或者Emitter自定义事件发布订阅的方式。当数据源改变时发布事件，依赖该数据源的组件通过订阅事件来获取数据源的改变，完成业务逻辑的处理，从而实现组件的精准刷新。
下面通过部分示例代码介绍使用方式，ButtonComponent组件作为交互组件触发数据变更，ListItemComponent组件接收数据做相应的UI刷新。
```typescript
import { ButtonComponent } from '../components/ButtonComponent';
import { ListItemComponent } from '../components/ListItemComponent';
@Entry
@Component
struct UseEmitterPublish {
listData: string[] = ['A', 'B', 'C', 'D', 'E', 'F'];
build() {
Column() {
Row() {
Column() {
ButtonComponent()
}
}
Column() {
Column() {
List() {
ForEach(this.listData, (item: string, index: number) => {
ListItemComponent({ myItem: item, index: index })
})
}
.height('100%')
.width('100%')
.alignListItem(ListItemAlign.Center)
}
}
}
}
}
```
由于ButtonComponent组件和ListItemComponent组件的组件关系较为复杂，因此在ButtonComponent组件中的Button回调中，可以使用emitter.emit发送事件，在ListItemComponent组件中订阅事件。在事件触发的回调中接收数据value，通过业务逻辑决定是否修改状态变量color，从而实现精准控制ListItemComponent组件中Text的刷新。
总结
状态管理是MVVM模式中十分复杂的问题，为解决其中状态和视图一致性、渲染性能体验、代码可复用性和可维护性四个问题，本文主要有以下建议点：

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-fair-use-animation
爬取时间: 2025-05-01 09:29:34
来源: Huawei Developer
概述
动画是应用开发中必不可少的部分，它可以使应用程序更加生动和易于互动，一方面可以提升用户体验、增强视觉吸引力，另一方面可以引导用户操作、提高信息传达效率。应用程序中，页面层级间的转场、点击交互、手势操控都可以添加动画。合理使用动画可以通过以下两个方面考虑：
在使用动画时，需要根据具体场景和用户需求进行合理的设计和运用，并且需要注意动画的性能影响，及时采取相应的优化措施。通过合理使用动画，可以提升动画的感知流畅度和运行流畅度，从而提升应用程序的用户体验和性能。
提升动画感知流畅度
HarmonyOS动效引力体系，围绕回归本源设计理念，打造了自然、流畅、品质一体的操作体验。基于视觉效果设计，可以将动效划分为特征动效、转场动效、手势动效、微动效、插画动效。在特征动效中呈现出天体运动“力”的即视感；转场动效表现出物体在运动过程中“力”的秩序感；手势动效打造出元素运动互相影响“力”的控制感；微动效和插画动效辅助HarmonyOS动效引力体系，增加用户的操作趣味性和浏览愉悦感。动效要始终围绕操作符合用户心理预期，物体运动符合真实世界，元素表现形态凸显产品的品牌与调性，从用户感知角度提升流畅度。
HarmonyOS系统为开发者提供了丰富的动画能力，在实际开发过程中，需要把上述UX设计视角转换为开发实现视角，即使用HarmonyOS系统提供的动画能力来实现UX设计的场景和动效，一般来说需要采取如下步骤完成视角转换：
通过以上步骤，开发者可以将UX设计视角转换为开发实现视角，并将设计师提供的动效转化为具体的代码实现。这样可以确保应用在实际使用中达到设计的预期效果，提升动画感知流畅度并提供良好的用户体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151040.92427857170973620981482494359526:50001231000000:2800:A123253A9E9679007C0A8D62078A9B466CA6E10DAC2A114A288BDAA9C0478B07.png)
动效场景设计
在设计动效过程中，要清楚地理解动效在系统中承载的作用，动效能体现页面的流畅过渡、对象的明确提示、元素的层级关系、产品的品牌印象等。
特征动效
特征动效主要打造 “天体拟物感知”，提供一种天体拟物的品牌效应和宇宙空间感的交互体验，它将力赋予元素，更直观地传递出形象化、拟物化、动态化的设计理念，在不同场景上表达新颖个性的同时又凸显了独特的产品调性。它可以广泛应用于开场动画、加载动画、下载动画等场景。
特征动效是指在用户界面中突出某个特定元素的动画效果。通过特征动效，可以吸引用户的注意力，提升用户体验。例如，在一个应用程序中，当用户点击”下载”按钮时，渐变显示出进度条并动态加载(如下图所示)。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151040.51029828536774601738240007378832:50001231000000:2800:1A42E785CC0405183E355E4326B3FF87A34EE94988B7AE65497BCBC5C8843817.gif)
转场动效
转场动效是指在不同页面或视图之间切换时使用的动画效果。通过转场动效，可以平滑地过渡到下一个页面或视图，增加界面间的连贯性和流畅性。
HarmonyOS系统为开发者提供了丰富的转场动效库，使开发者能够轻松实现各种转场动画效果。开发者可以根据具体需求，在应用的不同场景中应用这些转场动效，以提升用户体验和界面的吸引力。需要注意的是，为了最佳的用户体验，开发者应根据界面的功能和特点，合理选择转场动效，并遵循动效的使用准则，以确保转场动效在视觉和交互上的一致性。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151040.35332183978836161972712569116496:50001231000000:2800:5A1C925C02B9EF1D76F03818C228B1867E9E9BB4363B0D6870BDE1F329D2CD2F.gif)
手势动效
手势动效是指根据用户的手势操作而产生的动画效果。通过手势动效，可以增强用户与设备之间的互动体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151040.41600092819724213152412672021301:50001231000000:2800:CB89FE05868E66DEA24BE4C3E5F4536D669A154A542D763A410E6EFABFC67344.gif)
微动效
微动效是指在界面中细微的动画效果，用于增加界面的生动感和交互性。微动效可以体现在按钮的点击效果、图标的变化、文本的出现等。例如，当用户打开某个面板时，可以使用微小的缩放或颜色变化来体现（如图所示）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151040.11669242266929049174679753399089:50001231000000:2800:F87DAB95838AD3AB41D160EA71146643F1CA8863730D04EA44CCE87B0176CD2F.gif)
插画动效
插画动效是指在界面中应用的基于插画的动画效果。通过插画动效，可以为界面增添趣味和个性化。例如，在一个游戏应用中，可以使用插画动效来展示角色的动作、表情或者场景的变化（如图所示）。
通过动画的方式丰富视觉元素所要表达的信息，可以引导解读功能信息并串联前后画面，便于用户理解，也使画面表现更富有生命力。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151040.17366154960106865708081418096770:50001231000000:2800:FEF458947D662F54F3B3D263A635328B6DC87909B135176D1536FBA021278726.gif)
动画能力选型
开发人员接收到设计需求后，需要选择合适的动画能力完成该设计。HarmonyOS为开发者提供了系统能力、资源调用、三方库三种方式，在选择动画能力时，开发者需要考虑目标和需求以及效率和质量，合理选择能够满足需求的工具、追求高效率和高质量的结果导向，帮助应用实现更好的动画效果。
系统能力
资源调用
三方库
动画实践案例
使用显式动画实现特征动效
在本场景中，圆形按钮上会依次出现多个水波状圆环，这些圆环从中心向外进行扩散，进而凸显功能，实现效果如图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151040.67361660556475982674583354613152:50001231000000:2800:FBD9AE157C89A548C8FE868EB1AC88B3E7AA4B2305883202D11ACBEE250F4100.gif)
水波圆环以圆形按钮为中心，将多个圆形图层逐渐向外扩展放大，每个圆形图层的动画开始时间稍微错开，进而形成多个水波圆环依次扩散的效果。其动效实现步骤如下。
实现圆形图层，通过Stack将圆形图层与Button组件进行重叠。
实现圆形图层的放大动效，并设置延迟时间。
使用关键帧动画实现微动效
如图所示，在本场景中，在登录页面前需要勾选相关的协议，如果未勾选相关协议，提示框将会通过左右移动进行提示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151040.14484440688353366298693023465272:50001231000000:2800:B1154EAABE8A8475AF2C49FB7C47523E0058DE076A5F914382397B0C50D7B65D.gif)
提示框左右移动提醒是将提示框进行左移，然后再进行右移，如此往复循环多次。其动效可以分为提示框左移和提示框右移两段，可以使用keyframeAnimateTo接口实现分段的动画效果，实现步骤如下所示。
通过keyframeAnimateTo来设置关键帧动画。
设置onClick事件，通过onClick事件调用关键帧动画。
使用属性动画实现手势动效
在本场景中，页面主要分为标题和列表两个部分，当向下滑动列表时，标题会跟随下滑手势扩展显示详细信息，其实现效果如下所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151041.57776348625427218611422526309648:50001231000000:2800:FD0F36BF486D0CE5B2053C2B5FBFF1F07E921E77497728931DD4DFCF1C0EF8E9.gif)
在实现下拉缩放详情中，主要包含了两个部分，分别是列表下拉的手势和下拉后标题和列表的动画，详细实现步骤如下。
实现手势事件方法。当手指按下时，触发TouchType.Down事件记录当前触碰的位置。手指按压态在屏幕上移动时，可以通过当前的位置与初始位置进行比较，判断手势是否为向上或向下滑动，进而变更列表的高度。
为列表设置触摸事件onTouch和属性动画，实现标题区域缩放的效果。
通过animation属性动画实现标题内容平移，从而达到标题整体缩放的效果。
提升动画感知流畅度总结
在应用开发中，动画可以为用户界面增添生动、流畅的交互效果，提升用户对应用的好感度。然而，滥用动画也会导致应用性能下降，消耗过多的系统资源，甚至影响用户体验。
本文重点描述了如何在特定设计场景下充分利用HarmonyOS提供的动画能力，以确保动画既能够增强用户体验，又不至于对应用性能造成负面影响。开发者需要在实现动画效果时，注意控制动画的复杂度和频率，以节约系统资源，提升应用的性能表现。提升动画感知流畅度需要考虑以下几点：
合理利用HarmonyOS提供的动画能力可以有效提升应用的用户体验和吸引力，但开发者需要在设计和实现过程中综合考虑动画的使用场景、频率以及对系统资源的影响，扬长避短，确保应用的性能和稳定性。
提升动画运行流畅度
动画在应用开发中扮演着重要的角色，能够提升用户体验，传达信息，引导用户操作，提升应用品质和增加视觉吸引力。而动画的性能表现也至关重要，优化可以从属性更新和布局等几个方面考虑，尽可能减少冗余刷新。本文将介绍如下5种优化手段，通过这些优化手段的单个使用或组合使用，可以对动画帧率、应用卡顿等方面带来优化，提升性能和用户体验：
下文将通过5个测试来验证上述优化方法的收益，以证明这些优化手段的可行性。综合考虑业界共识指标和实际用户使用体验，测试将对比分析如下几个关键指标：
测试表明，当系统提供的接口可以实现所需动画效果时，其性能明显优于使用自定义动画实现，自定义动画大量的计算会导致其在应用侧大量丢帧，而系统提供的接口不依赖应用侧计算，更加流畅顺滑；实现位移、缩放、旋转等布局变化动画时，使用图形变换属性替换布局属性实现动画可以将丢帧率从8.1%降至3.7%，且明显减少了大卡顿次数；而多个参数相同的动画闭包同时实现时，将变化属性放入一个动画闭包可以使丢帧率从9.6%降低至4.0%；同样的，避免在两个动画闭包之间更新状态也可以降低动画的丢帧率。
使用系统提供的动画接口
一般而言，在HarmonyOS应用开发中，动画设计实现可以通过自定义动画或系统提供的动画接口两种方式来实现。
-  自定义动画是指通过编写自定义的动画逻辑和计算过程来实现特定的动画效果。开发人员可以根据应用的需求和设计要求，使用自定义的动画算法和逻辑来创建独特的动画效果。自定义动画的优势在于可以实现非常个性化的动画效果，并且能够完全控制动画的每一个细节，但需要开发人员具备一定的动画算法和计算能力。
-  系统动画接口是指通过使用系统提供的动画框架和接口来实现动画效果。在移动应用开发中，通常会使用属性动画来实现各种动画效果。通过可动画属性改变引起UI上产生的连续视觉效果，即为属性动画。属性动画是最基础易懂的动画，ArkUI提供两种属性动画接口animateTo和animation驱动组件属性按照动画曲线等动画参数进行连续的变化，产生属性动画。使用系统提供的动画接口可以简化动画的实现过程，并且能够充分利用系统优化的动画计算和渲染能力，从而提高动画的性能和流畅度。
场景设计
针对同一界面多个按钮同时缩放的场景（如下图所示），分别用自定义动画、属性动画、显式动画实现。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151041.46394697222694212352620413065804:50001231000000:2800:3243DC68A1042A9F3FBC4A56E3243678D8127981C0D601017FC5DD3336309A73.gif)
自定义动画
播放动画时，系统需要在一个刷新周期内完成动画变化曲线的计算，完成组件布局绘制等操作。使用了自定义动画，动画曲线计算过程很容易引起UI线程高负载，易导致丢帧。
使用自定义动画实现按键缩放，具体实现代码如下：
系统动画接口
系统提供的动画接口，只需设置曲线类型、终点位置、时长等信息，就能够满足常用的动画功能，减少UI主线程的负载。
性能分析
使用DevEco Studio的Profiler工具检测下述指标，得到的数据如下所示：
|    | 自定义动画  | 属性动画  | 显式动画  |
| --- | --- | --- | --- |
| 丢帧率（%）  | 9.2%  | 0%  | 0%  |
| 最大连续丢帧数（帧）  | 7  | 0  | 0  |
| 平均1s大卡顿次数（次/s）  | 1.50  | 0  | 0  |
自定义动画
属性动画
显式动画
丢帧率（%）
9.2%
0%
0%
最大连续丢帧数（帧）
7
0
0
平均1s大卡顿次数（次/s）
1.50
0
0
分析结论：
1）使用自定义动画实现计算量较大的动画时，丢帧率高达9.2%，最大连续丢失7帧，平均每秒发生大卡顿1.5次。
2）使用系统动画接口实现相同效果时，属性动画接口和显式动画接口都能够达到0丢帧。
这一结果表明，系统动画接口内部实现对开发者是透明的，已经进行了尽可能的性能优化，避免开发者使用自定义动画时产生不必要的性能劣化。自定义动画适合实现个性化的、复杂的动画效果，而系统提供的动画接口则适合实现常见的动画效果并且能够获得更好的性能表现。因此，在动画能够使用系统提供的接口实现的情况下，开发者应尽量使用系统提供的接口实现，保持动画的流畅性和稳定性，提升应用的性能表现。
使用图形变换属性变化组件
在应用开发中，改动组件的布局显示可以通过改动布局属性、改动图形变换属性两种方式来实现。
-  常见的布局属性包括位置、大小、内边距、外边距、对齐方式、权重等。当这些布局属性发生改变时，界面将重新布局以适应新的属性值。
-  图形变换属性是指对组件布局结果的变换操作，如平移、旋转、缩放等操作。通过改变这些图形变换属性，可以实现对组件布局完成后，在界面上的位置和形态进行动态变换。
布局属性和图形变换属性的可替换关系如下表所示：
| 图形变换属性  | 布局属性  |
| --- | --- |
| rotate  | /  |
| translate  | position、offset  |
| scale  | width、height、Size  |
| transform  | /  |
图形变换属性
布局属性
rotate
/
translate
position、offset
scale
width、height、Size
transform
/
表格中的对应关系仅供参考，开发者可以自行发掘更多的替代关系。
场景设计
针对同一界面多个图片同时缩放并位移的场景（如下图所示），分别通过改变布局属性、改变图形变换属性实现。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151041.97047874041839106133466931384501:50001231000000:2800:1E6D70E3C0CA0EF9493E4B56A4787050BB7B326D3EFBD407E926F1D5EF8B7DEE.gif)
改变布局属性
布局属性发生变化时，系统需要重新计算组件的位置和大小，然后进行重新布局。这个过程需要消耗大量的计算资源和时间，尤其是在界面中包含大量组件或者复杂布局时，性能开销会更加明显。
通过组件的width、height、position属性来改变组件大小和位置，具体代码实现如下：
改变图形变换属性
图形变换只是对组件的显示效果进行变换，而不会改变其在布局中的位置和大小，因此不会触发重新布局的计算过程。这使得使用图形变换属性来实现动画效果时，能够提升界面的流畅性和性能表现。
通过组件的scale、translate属性来改变组件大小和位置，具体代码实现如下：
性能分析
使用DevEco Studio的Profiler工具检测下述指标，得到的数据如下所示：
|    | 改变布局属性  | 改变图形变换属性  |
| --- | --- | --- |
| 丢帧率（%）  | 8.1%  | 3.7%  |
| 最大连续丢帧数（帧）  | 8  | 2  |
| 平均1s大卡顿次数（次/s）  | 0.48  | 0  |
改变布局属性
改变图形变换属性
丢帧率（%）
8.1%
3.7%
最大连续丢帧数（帧）
8
2
平均1s大卡顿次数（次/s）
0.48
0
分析结论：
1）使用布局属性改变图片大小和位置时，丢帧率为8.1%，最多连续丢失8帧，平均每秒发生大卡顿0.48次。
2）使用图形变化属性改变图片大小和位置时，丢帧率降到了3.7%，最多连续丢失2帧，在相同时长内没有发生大卡顿。
这一结果表明，使用图形变化属性改变图片大小和位置时，能够显著降低丢帧率和大卡顿的发生频率。界面布局是非常耗时的操作，因此频繁地改动布局属性会导致界面性能下降，出现卡顿现象，影响用户体验。因此，在动画能够使用图形变化属性实现的情况下，开发者应尽量使用图形变化属性实现，保持动画的流畅性和稳定性，提升应用的性能表现。
参数相同时使用同一个animateTo
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-combine-same-arg-animateto规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
每次调用animateTo方法，都会触发一次属性变化，这意味着在每次动画执行时都需要进行动画前后的对比，以确定属性的变化情况。当多次连续调用animateTo时，会增加额外的布局计算和绘制开销，从而降低性能表现。特别是当这些animateTo操作针对同一个组件的属性时，会导致该组件更新的次数增加，进一步影响性能。
在实际开发中，如果多个属性需要以相同的动画参数进行变化，推荐将它们放到同一个动画闭包中执行。通过将多个属性的动画操作合并到同一个动画闭包中，可以减少对组件的多次更新，避免重复的布局计算和绘制操作，提升动画效果的性能。
除了性能方面的优势，将多个属性的动画操作合并到同一个动画闭包中还有助于提高代码的可读性和维护性。通过集中管理相关联的属性变化，可以使代码结构更加清晰，便于后续的维护和修改。
场景设计
针对多个相同组件同时修改多个属性的场景（如下图所示），分别使用多个animateTo闭包和一个animateTo闭包实现。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151041.65521888070445230347373679460652:50001231000000:2800:5F05C7E9D6CB67713E5769552FDF3AF977274A28F396F1D23C3DB90727A19717.gif)
代码实现
性能分析
使用DevEco Studio的Profiler工具检测下述指标，得到的数据如下所示：
|    | 多个animateTo闭包  | 一个animateTo闭包  |
| --- | --- | --- |
| 丢帧率（%）  | 9.6%  | 4.0%  |
| 最大连续丢帧数（帧）  | 9  | 4  |
| 平均1s大卡顿次数（次/s）  | 1.01  | 0.24  |
多个animateTo闭包
一个animateTo闭包
丢帧率（%）
9.6%
4.0%
最大连续丢帧数（帧）
9
4
平均1s大卡顿次数（次/s）
1.01
0.24
分析结论：
1）将四个属性变化动画分别放在四个animateTo动画闭包中，丢帧率为9.6%，最多连续丢失9帧，平均每秒发生大卡顿1.01次。
2）将四个属性变化动画合入一个animateTo动画闭包中，丢帧率降到了4.0%，最多连续丢失4帧，平均每秒发生大卡顿0.24次。
这一结果表明，将多个属性变化动画合并到同一个animateTo动画闭包中能够显著降低丢帧率和大卡顿的发生频率。合并动画操作可以减少不必要的布局计算和绘制开销，从而提升动画的流畅性和性能表现，有助于优化动画效果的性能。
多次animateTo时统一更新状态变量
使用animateTo方法执行动画时，会对执行动画闭包前后的状态进行对比，然后只对差异部分进行动画处理。
在动画执行过程中，脏节点是指在界面上需要进行重新绘制的区域。如果状态发生了变化，ArkUI会跟踪这些变化，并在动画闭包执行前进行状态对比，相关的脏节点会被标记为需要刷新，以便在动画闭包执行前对这些脏节点进行重新绘制。这样，只有发生变化的部分才会被纳入动画处理，而不需要重新绘制整个界面。
这种差异对比的方式能够显著减少不必要的绘制操作，提高动画的性能和流畅度。
场景设计
针对多个相同组件修改多个属性进行动画的场景（如下图所示），分别使用在多个animateTo之间更新状态变量、在animateTo之前显式指定属性初值、在animateTo之前使用原始状态实现。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151041.42370110230487357000829206607481:50001231000000:2800:A33E2D51AD32267A332A32560A47E8BC8CF355555632EAE7AF593CE2E4EB4E3B.gif)
在多个animateTo之间更新状态变量
如果多个animateTo之间存在状态更新，会导致执行下一个animateTo之前又存在需要更新的脏节点，可能造成冗余更新，其动画更新流程如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151041.66117933194310267898092130634365:50001231000000:2800:30C99E0EA40EBAD53AA72DADB0CBE658A6E42DB54186EFBD12F9600C01D89891.png)
在第一个animateTo前，重新设置了w属性，所以Row组件需要更新一次。在第一个animateTo的动画闭包中，改变了w属性，所以Row组件又需要更新一次并对比产生宽高动画。第二个animateTo前，重新设置了color属性，所以Row组件又需要更新一次。在第二个animateTo的动画闭包中，改变了color属性，所以Row组件再更新一次并产生了背景色动画。Row组件总共更新了4次属性。
此外还更改了与动画无关的状态h，如果不需要改变无关状态，则不应改变造成冗余更新。
其具体代码实现如下：
统一更新状态变量
在animateTo之前显式的指定所有需要动画的属性初值，统一更新到节点中，然后再做动画，其动画更新流程如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151041.48480446226970516244497707464359:50001231000000:2800:50E8BF968A959F04D99B91F9815A9CCF9D2F37F7B968F556451965024153EDFB.png)
在第一个animateTo之前，重新设置了w和color属性，所以Row需要更新一次。在第一个animateTo的动画闭包中，改变了w属性，所以Row组件需要更新一次并对比产生宽高动画。在第二个animateTo之前，由于没有执行额外的语句，不存在需要更新的脏状态变量和脏节点，无需更新。在第二个animateTo的动画闭包中，改变了color属性，所以Row组件再更新一次并产生了背景色动画。Row组件总共更新了3次属性。
其具体代码实现如下：
在animateTo之前使用原始状态，让动画从原始状态过渡到指定状态，其动画更新流程如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151041.67508946415740460016262042222800:50001231000000:2800:DFB837EA84EEB371DBDE00E7FD609D01A41723ADF2B410883D640A4EA529EC10.png)
在第一个animateTo之前，不存在需要更新的脏状态变量和脏节点，无需更新。在第一个animateTo的动画闭包中，改变了w属性，所以Row组件需要更新一次并对比产生宽高动画。在第二个animateTo之前，由于也没有执行额外的语句，不存在需要更新的脏状态变量和脏节点，无需更新。在第二个animateTo的动画闭包中，改变了color属性，所以Row组件再更新一次并产生了背景色动画。Row组件总共更新了2次属性。
其具体代码实现如下：
性能分析
使用DevEco Studio的Profiler工具检测下述指标，得到的数据如下所示：
|    | 在多个animateTo之间更新状态变量  | 在animateTo之前显式指定属性初值  | 在animateTo之前使用原始状态  |
| --- | --- | --- | --- |
| 丢帧率（%）  | 9.1%  | 5.4%  | 3.5%  |
| 最大连续丢帧数（帧）  | 15  | 10  | 5  |
| 平均1s大卡顿次数（次/s）  | 0.67  | 0.23  | 0.10  |
在多个animateTo之间更新状态变量
在animateTo之前显式指定属性初值
在animateTo之前使用原始状态
丢帧率（%）
9.1%
5.4%
3.5%
最大连续丢帧数（帧）
15
10
5
平均1s大卡顿次数（次/s）
0.67
0.23
0.10
分析结论：
1）在多个animateTo之间更新状态变量时，丢帧率高达9.1%，最大连续丢失15帧，平均每秒发生大卡顿0.67次。
2）在animateTo之前显式指定属性初值时，丢帧率降到了5.4%，最多连续丢失10帧，平均每秒发生大卡顿0.23次。
3）在animateTo之前使用原始状态时，丢帧率降到了3.5%，最多连续丢失5帧，平均每秒发生大卡顿0.10次。
在进行属性变化动画时，显式指定属性初值或者使用原始状态作为动画的起始状态能够显著降低丢帧率和大卡顿的发生频率。因此，在进行动画操作时，合理管理状态变量的更新和初始值设定对于优化动画效果的性能至关重要，开发者应根据需要，尽可能地避免在多个animateTo之间更新状态变量，从而提升动画的流畅性和性能表现。
使用renderGroup
renderGroup是组件通用方法，它代表了渲染绘制的一个组合。其核心功能就是标记组件，在绘制阶段将组件和其子组件的绘制结果进行合并并缓存，以达到复用的效果，从而降低绘制负载。
首次绘制组件时，若组件被标记为启用renderGroup状态，将对组件和其子组件进行离屏绘制，将绘制结果进行缓存。此后当需要重新绘制组件时，就会优先使用缓存而不必重新绘制，从而降低绘制负载，优化渲染性能。组件渲染流程图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151042.07951784066861949049295518565090:50001231000000:2800:6F33CCAF7EE44DF2A2BA42E3FCE01AA9435C3F37A1A17FF776D76882A6D087E1.png)
在进行缓存更新时，需要满足以下三个条件：
在进行缓存清理时，需要满足以下任意条件：
具体缓存管理流程图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151042.51297990581719671702447989887002:50001231000000:2800:7F1791CD3B011C871BC3B73374F73A5DF96F907031DEC3BCED35BF372D1C1A6B.png)
为了能使renderGroup功能生效，组件存在以下约束。
场景设计
此案例在同一个页面下使用了固定的图片和文本内容，并且每个组件统一使用旋转和缩放的动效，并且重复使用了60个这样的组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151042.31506927935298812454930276098687:50001231000000:2800:AA75D7F06D98FFF9127418C72783B885F5F0F1D9C7E463DF52F9351FE942FBC0.gif)
代码实现
实现页面中需要使用的组件，并设置renderGroup属性，用@StorageLink修饰绑定renderGroupFlag标识。renderGroup属性的设置要满足父组件统一应用动效，子组件无动效，所以，动效在父组件上统一实现，未在IconItem上设置动效。在Flex组件中，Image和Text都无动效设置，所以在最外层Flex上设置renderGroup属性即可。
具体代码如下所示：
实现展示的页面，将控制renderGroup的标识renderGroupFlag通过APPStorage进行存储。
性能分析
使用DevEco Studio的Profiler工具检测下述指标，得到的数据如下所示：
|    | 未开启renderGroup  | 开启renderGroup  |
| --- | --- | --- |
| 丢帧率（%）  | 52.3%  | 0%  |
| 最大连续丢帧数（帧）  | 36  | 0  |
| 平均1s大卡顿次数（次/s）  | 2.3  | 0  |
未开启renderGroup
开启renderGroup
丢帧率（%）
52.3%
0%
最大连续丢帧数（帧）
36
0
平均1s大卡顿次数（次/s）
2.3
0
分析结论：
1）未开启renderGroup时，在render_service侧的丢帧率为52.3%，最多连续丢失36帧，平均每秒发生大卡顿2.3次。
2）开启renderGroup时，既没有发生卡顿，也没有发生丢帧的情况，其丢帧率为0%。
这一结果表明，在满足上述的约束后，使用renderGroup时，能够显著降低丢帧率、最大连续丢帧数和平均1s大卡顿次数。因此，在单一页面上存在大量应用动效的组件，且组件和其子组件各属性保持固定、组件统一应用动效时，开发者可以使用renderGroup来提升应用的性能，保证应用及动画的流畅性。
提升动画运行流畅度总结
本文通过5个测试验证了使用系统提供的动画接口、使用图形变换属性变化组件布局、参数相同时使用同一个animateTo、多次animateTo时统一更新状态变量、使用renderGroup这五项措施的有效性。
动画的性能表现对于用户体验、设备资源消耗、应用稳定性和流量消耗等方面都具有重要意义：
在实际开发中，开发人员可以结合本文提出的四项措施，并根据具体场景和需求进行优化，从而达到更好的动画性能表现。
合理使用动画总结
在实际开发过程中，开发者应该充分认识到动画对用户体验的重要性。动画不仅可以增强应用的吸引力，还能够提升用户的参与感和操作的直观性。
本文通过两个角度介绍了如何合理使用动画：
总之，合理使用动画对于提升用户体验至关重要。开发者需要从UX设计视角转换为开发实现视角，充分认识动画在用户体验中的作用和意义，并通过合理的实现和性能优化来提升动画的效果和稳定性。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-page-transition
爬取时间: 2025-05-01 09:29:50
来源: Huawei Developer
概述
页面间转场是用户从一个页面切换到另一个页面时的过程，一个无缝流畅的转场动效可以提升用户的交互体验。从主页到详情页、从列表页到结果页都需要去设置一些转场动效使得用户体验更加流畅。基于用户行为和应用设计模式，总结出了一些常见的转场场景，包括层级转场、搜索转场、新建转场、编辑转场、通用转场、跨应用转场。针对这些转场场景，根据“人因研究”（在 HarmonyOS 中，通过大量的人因研究为UX设计提供了系统性的科学指导），给各位开发者推荐一些适合本场景下转场动效，常见的转场动效有左右位移遮罩动效、一镜到底动效等。
HarmonyOS为开发者提供了丰富的转场能力，如UIAbility转场、页面路由转场、组件转场。同时，HarmonyOS提供了一些基于场景化封装的相关高级模板化转场，如导航转场、模态转场、共享元素转场，来实现页面之间的转场效果。
在实际开发过程中，需要把上述UX设计视角转换为开发实现视角，即使用HarmonyOS提供的转场能力和动画能力来实现UX设计的场景和动效。在视角转化上，包含了分析UX设计视角、设计转场方案、使用转场与动画能力、使用高级模板化转场、调试和优化，详细可以参考《合理使用动画》。通过以上步骤，开发者可以将UX设计视角转换为开发实现视角，并将设计师提供的转场场景和动效转化为具体的代码实现。这样可以确保应用在实际使用中达到设计的预期效果，并提供良好的用户体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151042.19097177689823449443212775125147:50001231000000:2800:67D257DF6FB8865D34037EEB8FE435AF026FF686D3C22DD4A7596372E4D2FDE5.png)
转场场景设计
转场动效
HarmonyOS系统为开发者提供了丰富的转场动效库，使开发者能够轻松实现各种转场动画效果。以下是一些在HarmonyOS系统中提供的转场动效：
开发者可以根据具体需求，在应用的不同场景中应用这些转场动效，以提升用户体验和界面的吸引力。需要注意的是，为了最佳的用户体验，开发者应根据界面的功能和特点，合理选择转场动效，并遵循动效的使用准则，以确保转场动效在视觉和交互上的一致性。具体实现效果，请参考下一章节案例。
转场场景
层级转场
层级转场是指在用户界面中，从一个层级结构的界面状态转换到另一个层级结构的界面状态的过程，它通常用于在应用中进行页面间的导航和视图层级的变化。层级转场的场景可以划分为卡片、图表展开和列表展开：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151042.61715814729015793615330636992612:50001231000000:2800:1D9B5E95D3FBF11A905704B6F573748025D585494F03B71F526C6C2F3150BFC7.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151042.56593367630585275605263230191203:50001231000000:2800:8E18781D8248BBA9D900ABE16C616ECE1DB3D638B2730D4AE3B7D0BB44BE1206.gif)
对于层级转场，推荐使用系统转场，页面转场采用左右位移的运动方式，不应单帧直接切换或上下位移切换，曲线优先使用弹簧曲线。
搜索转场
搜索转场是指在用户执行搜索操作，如在搜索栏中输入关键词并按下搜索按钮，或者直接触摸搜索图标时，应用改变应用页面以显示搜索结果的过程。它包含了固定搜索区域和非固定搜索区域两种情况：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151042.77121242741851235377258732789902:50001231000000:2800:214CD3CB5FB944EEA5B3BE24E63E12AB4DF8670980FE51C6D78613E9A2A5F154.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151042.09472717134026812171086288286627:50001231000000:2800:33D7FE89F449EBEFA45776BBD74EF2B3BD34B41C2568E74BB3C9DDB4B27C62FE.gif)
对于搜索转场，推荐使用共享元素转场，搜索框作为持续存在的元素串联前后两个界面，其他元素可采用淡入淡出或者其他过渡方式，不应单帧切换或非共享元素的方式转场。
新建转场
新建转场是指用户创建新内容或实体时，应用页面发生的过渡效果，它可以让用户感知到新的事物的添加或创建，并提供一种连贯和引人注目的视觉切换。由于新建页面中需要完成整个页面的替换，推荐开发者使用左右位移遮罩作为转场动效，如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151042.44196266856216324253797830652070:50001231000000:2800:AABD4B0BB5B413C978831F00A8ED178C748E49163E7BF066B81D622E95BDD053.gif)
对于新建转场，推荐使用系统转场，页面转场采用左右位移的运动方式，不应单帧直接切换或上下位移切换，曲线优先使用弹簧曲线。
编辑转场
用户对现有内容或实体进行编辑时，例如点击“编辑”按钮，选择要编辑的项目或内容，或者执行其他与编辑相关的动作，应用应提供动效引导用户进入一个用于编辑现有内容的页面，修改所需的信息。在这个场景下，开发者需要达成的视觉效果是从编辑按键处弹出编辑页面，类似于单体卡片展开的效果。但由于一般的编辑按键并没有分明的外框，并不适用一镜到底的动效，此时淡入淡出能够提供类似于一镜到底的效果，如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151042.01669498128467433232651547580216:50001231000000:2800:F6301B53C628B4067031BFD0CC8AC829372CB0A27F830E841CDCCCB2A66A49CD.gif)
对于编辑转场，推荐使用系统转场，页面转场采用淡入淡出的过渡方式，不应单帧直接切换或位移切换。
通用转场
通用转场是一种广泛适用于不同情境和应用类型的页面过渡效果，目的是提供一种通用的、可重复使用的方式，以改善用户页面之间的切换，增强用户体验。其关键点在于要适用各种应用情境，包括不同类型的应用（例如社交媒体、电子商务、新闻等）和不同操作（例如导航、搜索、编辑等）。这就需要一种通用的、不需要复杂操作的动效来完成跳转任务，而缩放能够满足绝大多数用户的需求和视觉体验感受，如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151043.44545839876248452622589002803435:50001231000000:2800:1489E1A937C263F110F422BC2231680723C1D6D56B5BE5C373D14AB7DD6094D9.gif)
跨应用转场
跨应用转场是指用户从一个应用程序切换到另一个应用程序，用户能够无缝地从一个应用切换到另一个应用，而不会感到中断或不适。和以上几类转场都不同的是，用户点击应用内的链接、按钮或执行其他与外部应用交互的动作后，页面的跳转已经不仅仅存在于页面与页面之间，而是应用与应用之间，为此，推荐开发者使用专为此设计的左右间隔位移动效，跳转效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151043.80303932878768005557487785660900:50001231000000:2800:878AE251BD4D4BD042E992CEAF7078BCC5EC950D3D499BEE8F12062723D60185.gif)
场景解构
转场是由交互行为引起的界面变化，分析界面元素在过程中的意义，定义其在转场中所在的类型，并将它们进行分类，元素所属的类别会影响它们使用怎样的转场能力，同时也将决定用什么类型的曲线和时长。
-  如上图中示例，①是进场元素，②是出场元素，③是持续元素，④是静⽌元素。 接下来，开发者需要根据分析的元素类型选择合适的转场能力，并综合考虑元素和页面的整体感官效果。不同的元素类型可能需要不同的转场方式来展现其特定的特征和交互效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151043.54002675343769587609001740540209:50001231000000:2800:8BC18CC75FFD3176D5A324408DA586774E9E59FFC93B4CCB48066842AB830420.gif)
转场场景开发
转场能力
开发人员接收到设计需求后，需要选择合适的转场能力完成该设计。HarmonyOS为开发者提供了UIAbility转场、页面路由和组件转场三种方式，在选择转场方式时，开发者需要考虑用户体验、界面一致性和业务需求，确保所选导航组件能够提供直观、易用的导航方式，帮助应用实现更好的转场效果。
动画能力
转场动画是指对将要出现或消失的组件做动画，对始终出现的组件做动画应使用属性动画。转场动画主要为了让开发者从繁重的消失节点管理中解放出来，如果用属性动画做组件转场，开发者需要在动画结束回调中删除组件节点。同时，由于动画结束前已经删除的组件节点可能会重新出现，还需要在结束回调中增加对节点状态的判断。
转场动画分为基础转场和高级模板化转场，出现/消失转场是一种基础转场，是对新增、消失的控件实现动画效果的能力。为了简化开发者工作，HarmonyOS提供了以下高级模板，将属性动画和出现消失动画封装，开发者只需调用接口，可以轻松的完成页面转场：
在实现组件出现和消失的动画效果时，相比于组件动画（animateTo），推荐优先使用transition。因为animateTo需要在动画前后做两次属性更新，而transition只需做一次条件改变更新，性能更好。此外，使用transition可以避免在结束回调中做复杂逻辑处理，开发实现更容易。
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-use-transition-to-replace-animateto规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
最佳实践案例
共享元素转场实现搜索转场
场景描述
在日常的各类应用交互场景中，搜索转场是极为常见的页面转场。通过点击当前页面的搜索栏会跳转进入搜索输入页面，详细效果如下所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151043.79424040400532210842731586606527:50001231000000:2800:46666D3AE8AAB419B3FA59C6F252405F0176464A1D4CA485CC76C44BF7C5C4E5.gif)
实现原理
在本案例中，搜索框会在转场中持续存在，且在转场前后有位置上的变化，可以使用共享元素转场让搜索框在转场过程中进行丝滑的上下文过渡。其实现步骤如下所示。
开发步骤
在转场前页面的搜索组件上设置geometryTransition属性，并设置显示动画animateTo，其中curve为动画曲线。
```typescript
@Entry
@Component
struct SearchLongTakeTransitionPageOne {
@State translateY: number = 0;
@State transitionEffect: TransitionEffect = TransitionEffect.IDENTITY;
private pageInfos: NavPathStack = new NavPathStack();
private showSearchPage(): void {
this.transitionEffect = TransitionEffect.OPACITY;
animateTo({
curve: curves.interpolatingSpring(0, 1, 342, 38)
}, () => {
this.pageInfos.pushPath({ name: 'SearchLongTakeTransitionPageTwo' }, false);
})
}
build() {
NavDestination() {
Column({ space: 20 }) {
Search({ placeholder: 'Search' })
.height(40)
.placeholderColor($r('sys.color.mask_secondary'))
.width('100%')
.geometryTransition('SEARCH_ONE_SHOT_DEMO_TRANSITION_ID', { follow: true })
.backgroundColor('#0D000000')
.defaultFocus(false)
.focusOnTouch(false)
.focusable(false)
.onTouch((event: TouchEvent) => {
if (event.type === TouchType.Up) {
this.showSearchPage();
}
})
}
.size({
width: '90%',
height: '100%'
})
}
.transition(TransitionEffect.OPACITY)
.backgroundColor('#F1F3F5')
.title(getResourceString($r('app.string.search_title'), this))
.onReady((context: NavDestinationContext) => {
this.pageInfos = context.pathStack;
})
.onBackPressed(() => {
this.transitionEffect = TransitionEffect.IDENTITY;
this.pageInfos.pop(true);
return true;
})
}
}
```
在转场后的搜索组件上绑定唯一ID。
模态转场模板实现通用转场
场景描述
如图所示，在进入第一个页面时为半模态转场，通过半模态展现多种登录的方式。点击进入第二个页面时为全模态转场，展示了手机验证码登录页面。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151043.68112814755053896213429345825702:50001231000000:2800:F8E4CF15328C3CA7462EB41C02A5054DBFCB51D94C191029AF0F5BDCD4129EC3.gif)
实现原理
在半模态转场和全模态转场中，两者实现的步骤基本相同，具体调用的接口有差异，详细实现步骤如下所示。
开发步骤
总结与回顾
合理使用页面间转场是提升用户体验的重要技术之一，在应用开发过程中，通过动效的运用，可以使应用界面更加生动、流畅，并且能够引导用户的注意力，提高用户的操作效率。合理使用动效需要考虑以下几点：
在应用开发过程中，开发者可以借助HarmonyOS中提供的导航组件和转场动效，简化开发流程，提高开发效率，实现符合规范要求的转场动效效果。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-component-reuse-scenarios-methods
爬取时间: 2025-05-01 09:30:05
来源: Huawei Developer
概述
组件复用是优化用户界面性能，提升应用流畅度的一种重要手段，通过复用已存在的组件节点而非创建新的节点，从而确保UI线程的流畅性与响应速度。
组件复用针对的是自定义组件，只要发生了相同自定义组件销毁和再创建的场景，都可以使用组件复用，例如滑动列表场景，会出现大量重复布局的创建，使用组件复用可以大幅度降低了因频繁创建与销毁组件带来的性能损耗。
然而，面对复杂的业务场景或者布局嵌套的场景下，组件复用使用不当，可能会导致复用失效或者性能提升不能最大化。例如列表中存在多种布局形态的列表项，无法直接复用。
本文基于对常见的布局类型进行划分，通过合理使用组件复用方式，帮助开发者更好的理解和实施组件复用策略以优化应用性能。
组件复用实现方法
组件复用的实现方式主要有以下两种：
系统提供的组件复用的行为，是将子组件放在父组件的复用缓存池里，缓存池是一个Map套Array的数据结构，以reuseId为key，具有相同reuseId的组件在同一个List中，可以相互复用，reuseId默认是自定义组件的名字。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151043.41366316440964679167184887030320:50001231000000:2800:BCB07EA24AB2D2ABAAB258CB777B915C9ADD2312AC4C894035019F195CD18B4F.png)
根据这个原理系统提供的组件复用有如下两条约束和限制：
-  如果想要子组件B之间进行复用，可以将复用组件改为@Builder函数，然后将子组件B使用@Reusable修饰，这样子组件的缓存池就会在父组件上共享，具体可以参考下文的组合型复用类型的实现。
-  对于这种嵌套比较多的情况下，导致想要复用的组件不在一个父组件的场景下，可以使用BuilderNode实现全局复用。具体可以参考全局自定义组件复用实现。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151043.15659030919439607720258998496128:50001231000000:2800:04C965FBFFDA5B0B2E805745C53935463FC3A8C506CAF5C93D1589CA2966D1A1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151043.44794055643421295801554848714388:50001231000000:2800:E47D074A23727974CB193716FC09A15F8E6402D46C140F8B74D0975F291C9E69.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151043.42860594170741915955834478036341:50001231000000:2800:F3B787C5116BDE583A9D0806A83CCB4C9E08ECF30261087A4EBFB59C1CE97168.png)
复用类型详解
组件复用基于不同的布局效果和复用的诉求，可以分为以下五种类型。
| 复用类型  | 描述  | 复用思路  |
| --- | --- | --- |
| 标准型  | 复用组件之间布局完全相同  | 标准复用  |
| 有限变化型  | 复用组件之间布局有所不同，但是类型有限  | 使用reuseId或者独立成不同自定义组件  |
| 组合型  | 复用组件之间布局有不同，情况非常多，但是拥有共同的子组件  | 将复用组件改为@Builder，让内部子组件相互之间复用  |
| 全局型  | 组件可在不同的父组件中复用，并且不适合使用@Builder  | 使用BuilderNode自定义复用组件池，在整个应用中自由流转  |
| 嵌套型  | 复用组件的子组件的子组件存在差异  | 采用化归思想将嵌套问题转化为上面四种标准类型来解决  |
复用类型
描述
复用思路
标准型
复用组件之间布局完全相同
标准复用
有限变化型
复用组件之间布局有所不同，但是类型有限
使用reuseId或者独立成不同自定义组件
组合型
复用组件之间布局有不同，情况非常多，但是拥有共同的子组件
将复用组件改为@Builder，让内部子组件相互之间复用
全局型
组件可在不同的父组件中复用，并且不适合使用@Builder
使用BuilderNode自定义复用组件池，在整个应用中自由流转
嵌套型
复用组件的子组件的子组件存在差异
采用化归思想将嵌套问题转化为上面四种标准类型来解决
下面将以滑动列表的场景为例介绍5种复用类型的使用场景，为了方便描述，下文将需要复用的自定义组件如ListItem的内容组件，叫做复用组件，将其下层的自定义组件叫做子组件、复用组件上层的自定义组件叫做父组件。为了更直观，下面每一种复用类型都会通过简易的图形展示组件的布局方式，并且为了便于分辨，布局相同的子组件使用同一种形状图形表示。
标准型
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151043.44684317098747129765128765243153:50001231000000:2800:5545009E9AEFF2AC4901386484F514680EB045A7BE4A7A042D6D9ED9E5E092D0.png)
这是一个标准的组件复用场景，一个滚动容器内的复用组件布局相同，只有数据不同，这种类型的组件复用可以直接参考资料组件复用。其缓存池如下，因为该场景只有一个复用组件，所以在缓存中只有一个复用组件list：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151044.54250154626769809910330953044146:50001231000000:2800:CF64CCCADABA8231572AE0A1380293497A81985830D2B9B7ABC825A1E03C8925.png)
典型场景如下，列表Item布局基本完全相同。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151044.76937341405351874863592016800124:50001231000000:2800:BB8B38084103852F6DC0F4845717838F387FF28A53FEC5C829C5A6005420EB88.png)
标准型组件复用的示例代码如下：
```typescript
@Entry
@Component
struct ReuseType1 {
// ...
build() {
Column() {
List() {
LazyForEach(this.dataSource, (item: string) => {
ListItem() {
CardView({ item: item })
}
}, (item: string) => item)
}
}
}
}
// 复用组件
@Reusable
@Component
export struct CardView {
@State item: string = '';
aboutToReuse(params: Record<string, Object>): void {
this.item = params.item as string;
}
// ...
}
```
有限变化型
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151044.27127808629390665497190895087236:50001231000000:2800:95ED7A1AF09CF0B6C7EA9ED928D4EA27DE16764DFAC026D4018ACBF027DA443F.png)
如上图所示，有限变化型指的是父组件内存在多个类型的复用单元，这些类型的单元布局有所不同，根据业务逻辑的差异可以分为以下两种情况：
下面将分别介绍这两种场景下的组件复用方法。
类型1和类型2布局不同，业务逻辑不同：因为两种类型的组件布局会对应应用不同的业务处理逻辑，建议将两种类型的组件分别使用两个不同的自定义组件，分别进行复用。给复用组件1和复用组件2设置不同的reuseId，此时组件复用池内的状态如下图所示，复用组件1和复用组件2处于不同的复用list中。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151044.49301726656768833532282777202661:50001231000000:2800:D97CD6CDF5D8F12B4FF1F6743ADA7B5DAFFB59B2A2F359794E29493D3B53BA2C.png)
例如下面的列表场景，列表项布局差距比较大，有多图片的列表项，有单图片的列表项：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151044.14785545536968245895390976010364:50001231000000:2800:C01374C48F8E6193A8EF22BF002F0E2066EC2AA708BD1A8332447D01234A7ADC.png)
实现方式可参考以下示例代码：
类型1和类型2布局不同，但是很多业务逻辑公用：在这种情况下，如果将组件分为两个自定义组件进行复用，会存在代码冗余问题。根据布局的差异，可以给同一个组件设置不同的reuseId从而复用同一个组件，达到逻辑代码的复用。
根据组件复用原理与使用可知，复用组件是依据reuseId来区分复用缓存池的，而自定义组件的名称就是默认的reuseId。因此，为复用组件显式设置两个不同的reuseId与使用两个自定义组件进行复用，对于 ArkUI 而言，复用逻辑完全相同，复用池也一样，只不过复用池中复用组件的list以reuseId作为标识，如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151044.14811542621097067292732284150004:50001231000000:2800:533AE73183213BA0DBA062638702232F5883E18B395D4ED7125928FBD9837DD8.png)
例如下面这个场景，布局差异比较小，业务逻辑一样都是跳转到页面详情。这种情况复用同一个组件，只需要使用if/else条件语句来控制布局的结构，就可以实现，同时可以复用跳转详情的公用逻辑代码。但是这样会导致在不同逻辑会反复去修改布局，造成性能损耗。开发者可以根据不同的条件，设置不同的reuseId来标识需要复用的组件，省去重复执行if的删除重创逻辑，提高组件复用的效率和性能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151044.31385809826940992043084177550663:50001231000000:2800:14701857E580800F7ADA26621E1B8EFAFEB4C4EFA5D9E02E383C9CF2D3FB8B72.png)
实现方式可以参考以下示例：
```typescript
@Entry
@Component
struct ReuseType2B {
// ...
build() {
Column() {
List() {
LazyForEach(this.dataSource, (item: MemoInfo) => {
ListItem() {
MemoItem({ memoItem: item })// 使用reuseId进行组件复用的控制
.reuseId((item.imageSrc !== '') ? 'withImage' : 'noImage')
}
}, (item: MemoInfo) => JSON.stringify(item))
}
}
}
}
@Reusable
@Component
export default struct MemoItem {
@State memoItem: MemoInfo = MEMO_DATA[0];
aboutToReuse(params: Record<string, Object>) {
this.memoItem = params.memoItem as MemoInfo;
}
build() {
Row() {
// ...
if (this.memoItem.imageSrc !== '') {
Image($r(this.memoItem.imageSrc))
.width(90)
.aspectRatio(1)
.borderRadius(10)
}
}
// ...
}
}
```
组合型
这种类型中复用组件之间存在不同，并且情况比较多，但拥有共同的子组件。如果使用有限变化型的组件复用方式，将所有类型的复用组件写成自定义组件分别复用，不同复用组件（组件名不同或者reuseId不同）之间相同子组件无法复用，因为它们在缓存池的不同List中。
对此可以将复用组件转变为@Builder函数，使复用组件内部共同的子组件的缓存池在父组件上共享，此时组件复用池内的状态如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151044.00871713955886157983410110726888:50001231000000:2800:ADA0D8CB6F214C5D73495F54965564E8AB05E3C9E2350CD3F267CE6341C058CB.png)
典型场景如下图，这个列表的Item有多种组合方式。但是每个Item上面和下面的布局是一样的，中间部分的布局有所不同，有单一图片、视频、九宫等等。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151044.23845925100047722419841842790827:50001231000000:2800:A1061C7FD05C09B3ED87486E35051BC71A6E8A8F3BFE62F1CA79E899E7014B93.png)
示例代码如下，列举了单一图片、视频和九宫格图片三种类型的列表项目，使用Builder函数后将子组件组合成三种不同的类型，使内部共同的子组件就处于同一个父组件FriendsMomentsPage下。对这些子组件使用组件复用时，他们的缓存池也会在父组件上共享，节省组件创建时的消耗。
全局型
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151044.64975344480476075865706059350227:50001231000000:2800:AE3A7A3E986319A33C003E915604D384583FE8D8CF62A9FCD15CC2DE0B964B4A.png)
默认的组件复用行为，是将子组件放在父组件的缓存池里，受到这个限制，不同父组件中的相同子组件无法复用，推荐的解决方案是将父组件改为builder函数，让子组件共享组件复用池，但是由于在一些应用场景下，父组件承载了复杂的带状态的业务逻辑，而builder是无状态的，修改会导致难以维护，因此开发者可以使用BuilderNode自行管理组件复用池。
如下图所示，有时候应用在多个tab页之间切换，tab页之间结构类似，需要在tab页之间复用组件，提升页面切换性能。或者有些应用在组合型场景下，由于复用组件内部含有较多带状态的业务逻辑，所以不适合改为Builder函数。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151044.25019493922164443047822978673976:50001231000000:2800:5C9DB5803E4096D8C7D97D57CD0760871F6ECD9382B4E5127C6D44012A17CB15.gif)
针对这种类型的组件复用场景，可以通过BuilderNode自定义缓存池，将要复用的组件封装在BuilderNode中，将BuilderNode的NodeController作为复用的最小单元，自行管理复用池。具体实现可以参考料全局自定义组件复用实现。
嵌套型
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151044.37446297732199999282575601909205:50001231000000:2800:35B8897EA5C26E27020FADE853A2404960F6BD9BA834A850F3835987FF67B78F.png)
嵌套型是指复用组件的子组件的子组件之间存在差异的复用场景。如上图所示，列表项复用组件1之间的差异是子组件B的子组件不一样，有子组件C、D、E三种。这种情况可以运行化归的思想，将复杂的问题转化为已知的、简单的问题
嵌套型实际上是上面四种类型的组合，以上图为例，可以通过有限变化型的方案，将子组件B变为子组件B1/B2/B3，这样问题就变成了一个标准的有限变化型，A/B1/C、A/B2/D、A/B3/E会分别作为一个组合进行复用，复用池如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151045.06455411706615836615593485877657:50001231000000:2800:A344AE2B09F1425A69E7AE1C81BDDE33EDAA7A43B6B6C31A20BFBD0C84923FD0.png)
下面列举一个简单的示例介绍嵌套型的使用：
或者通过组合型的方案，将子组件B改为@Builder函数，使子组件C、D、E和子组件A在同一组件层级。然后分别给子组件A、C、D、E添加@Reusable装饰器，使他们能够单独复用，具体实现可以参考组合型，改造成组合型之后复用池如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151045.12172364571689331180352333150722:50001231000000:2800:66C45EA8C50A1AE4B60142A20551B32215DA6B5F650D70840B16F80BA3E771F0.png)
下面还是以朋友圈为例，如果复用组件的嵌套比较复杂，复用组件内部含有带状态的业务逻辑，不适合改为Builder函数，这种情况可能就不适合使用组合型了，这时候可以尝试通过有限变化型来复用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151045.83813199485754173827363288281464:50001231000000:2800:6A795CDD00C12BC23DE82DD6BCB05B9CDBCDD1622CA315BEBFB8AA85D069733F.png)
图中列表项的复用组件为CardItem，子组件由三部分组成ItemTop、ItemMiddle以及ItemBottom，其中ItemMiddle子组件（即复用组件CardItem子组件的子组件）之间有差异，对于这种情况的复用，可以将子ItemMiddle组件变为ItemMiddle1、ItemMiddle2、ItemMiddle3，这样就变成了一个有限变化型复用。示例代码如下：
总结
组件复用需要根据具体的业务场景，选择合理的复用方案，才能更好的优化应用性能。开发者可以根据表1 组件复用类型说明中描述，选择具体的复用类型。
同时需要注意的是有时候可能会遇到组件复用失效的场景，开发者可以参考失效场景，了解避免组件复用失效和检查组件复用是否失效的方法。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-component-reuse
爬取时间: 2025-05-01 09:30:19
来源: Huawei Developer
概述
HarmonyOS应用框架提供了组件复用能力：可复用组件从组件树上移除时，会进入到一个回收缓存区，后续创建新组件节点时，会复用缓存区中的节点，节约组件重新创建的时间。
本文会介绍如何使用组件复用机制提升应用帧率。
组件复用原理与使用
原理介绍
组件复用机制如下：
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-use-reusable-component规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
图1组件复用原理图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151045.91394353896812201943358202162138:50001231000000:2800:999144728E65F12763CA946615B917454B649503C8621D49EF34BAD93517A643.png)
1、@Reusable表示组件可以被复用，结合LazyForEach懒加载一起使用，可以进一步解决列表滑动场景的瓶颈问题，提供滑动场景下高性能创建组件的方式来提升滑动帧率。
2、CustomNode是一种自定义的虚拟节点，它可以用来缓存列表中的某些内容，以提高性能和减少不必要的渲染。通过使用CustomNode，可以实现只渲染当前可见区域内的数据项，将未显示的数据项缓存起来，从而减少渲染的数量，提高性能。
3、RecycleManager是一种用于优化资源利用的回收管理器。当一个数据项滚出屏幕时，不会立即销毁对应的视图对象，而是将该视图对象放入复用池中。当新的数据项需要在屏幕上展示时，RecycleManager会从复用池中取出一个已经存在的视图对象，并将新的数据绑定到该视图上，从而避免频繁的创建和销毁过程。通过使用RecycleManager，可以大大减少创建和销毁视图的次数，提高列表的滚动流畅度和性能表现。
4、CachedRecycleNodes是CustomNode的一个集合，常是用于存储被回收的CustomNode对象，以便在需要时进行复用。
需要注意的是，虽然这里是使用List组件进行举例，但是不代表组件复用只能用在滚动容器里，只要是发生了相同自定义组件销毁和再创建的场景，都可以使用组件复用。
使用规则
组件复用的示例代码如下：
```typescript
// xxx.ets
export class Message {
value: string | undefined;
constructor(value: string) {
this.value = value
}
}
@Entry
@Component
struct Index {
@State switch: boolean = true
build() {
Column() {
Button('Hello World')
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.switch = !this.switch
})
if (this.switch) {
Child({ message: new Message('Child') })
// 如果只有一个复用的组件，可以不用设置reuseId
.reuseId('Child')
}
}
.height("100%")
.width('100%')
}
}
@Reusable
@Component
struct Child {
@State message: Message = new Message('AboutToReuse');
aboutToReuse(params: Record<string, ESObject>) {
console.info("Recycle Child")
this.message = params.message as Message
}
build() {
Column() {
Text(this.message.value)
.fontSize(20)
}
.borderWidth(2)
.height(100)
}
}
```
1.@Reusable：自定义组件被@Reusable装饰器修饰，即表示其具备组件复用的能力。
2.aboutToReuse：当一个可复用的自定义组件从复用缓存中重新加入到节点树时，触发aboutToReuse生命周期回调，并将组件的构造参数传递给aboutToReuse。
3.reuseId：用于标记自定义组件复用组，当组件回收复用时，复用框架将根据组件的reuseId来划分组件的复用组。如果只有一个复用的组件，可以不用设置reuseId。
组件复用优化方法
减少组件复用的嵌套层级
在组件复用场景下，过深的自定义组件的嵌套会增加组件复用的使用难度，比如需要逐个实现所有嵌套组件中aboutToReuse回调实现数据更新；因此推荐优先使用@Builder替代自定义组件，减少嵌套层级，利于维护且能提升页面加载速度。正反例如下：
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-replace-nested-reusable-component-by-builder规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
反例：
上述反例的操作中，在复用的自定义组件中嵌套了新的自定义组件。ArkUI中使用自定义组件时，在build阶段将在在后端FrameNode树创建一个相应的CustomNode节点，在渲染阶段时也会创建对应的RenderNode节点。会造成组件复用下，CustomNode创建和RenderNod渲染的耗时。且嵌套的自定义组件InteractiveButton，也需要实现aboutToReuse来进行数据的刷新。
正例：
上述正例的操作中，在复用的自定义组件中用@Builder来代替了自定义组件。避免了CustomNode节点创建和RenderNode渲染的耗时。
优化状态管理，精准控制组件刷新范围使用
1.使用attributeUpdater精准控制组件属性的刷新，避免组件不必要的属性刷新。
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-use-attributeUpdater-control-refresh-scope规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
复用场景常用在高频的刷新场景，精准控制组件的刷新范围可以有效减少主线程渲染负载，提升滑动性能。正反例如下：
反例：
上述反例的操作中，通过aboutToReuse对fontColor状态变量更新，进而导致组件的全部属性进行刷新，造成不必要的耗时。可以考虑对需要更新的组件的属性，进行精准刷新，避免不必要的重绘和渲染。
正例：
上述正例的操作中，通过attributeUpdater属性来对Text组件需要刷新的fontColor属性进行精准刷新，避免Text其它不需要更改的属性的刷新。
2.使用@Link/@ObjectLink替代@Prop减少深拷贝，提升组件创建速度
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-use-object-link-to-replace-prop规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
在父子组件数据同步时，如果仅仅是需要父组件向子组件同步数据，不存在子组件数据变化同步给父组件的场景。建议使用@Link/@ObjectLink替代@Prop，@Prop在装饰变量时会进行深拷贝，在拷贝的过程中除了基本类型、Map、Set、Date、Array外，都会丢失类型。正反例如下：
反例：
上述反例的操作中，父子组件之间的数据同步用了@Prop来进行，各@Prop装饰的变量在初始化时都在本地拷贝了一份数据。会增加创建时间及内存的消耗，造成性能问题。
正例：
上述正例的操作中，父子组件之间的数据同步用了@ObjectLink来进行，子组件@ObjectLink包装类把当前this指针注册给父组件，会直接将父组件的数据同步给子组件，实现父子组件数据的双向同步，降低子组件创建时间和内存消耗。
3.避免对@Link/@ObjectLink/@Prop等自动更新的状态变量，在aboutToReuse方法中再进行更新
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-avoid-update-auto-state-var-in-aboutToReuse规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
在父子组件数据同步时，如果子组件已经使用了建议使用@Link/@ObjectLink/@Prop等会自动同步父子组件数据且驱动组件刷新的状态变量。则不需要再在aboutToReuse方法中再进行数据更新，此操作会造成不必要的方法执行和变量更新的耗时。正反例如下：
反例：
上述反例的操作中，子组件中moment变量被@ObjectLink修饰，把当前this指针注册给父组件，会直接将父组件的数据同步给子组件，实现数据刷新。重新在aboutToReuse中刷新，如果刷新涉及的变量较多、变量中成员变量复杂，可能会造成较大性能开销。
正例：
上述正例的操作中，子组件中moment变量被@ObjectLink修饰，把当前this指针注册给父组件，会直接将父组件的数据同步给子组件，实现数据刷新。
复用组件嵌套结构会变更的场景，使用reuseId标记不同结构的组件构成
在自定义组件复用的场景中，如果使用if/else条件语句来控制布局的结构，会导致在不同逻辑创建不同布局结构嵌套的组件，从而造成组件树结构的不同。此时我们应该使用reuseId来区分不同结构的组件，确保系统能够根据reuseId缓存各种结构的组件，提升复用性能。正反例如下：
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-suggest-reuseid-for-if-else-reusable-component规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
反例：
上述反例的操作中，通过if来控制组件树走不同的分支，分别选择是否创建Flex组件。导致更新if分支时仍然可能走删除重创的逻辑。考虑采用根据不同的分支设置不同的reuseId来提高复用的性能。
正例：
上述正例的操作中，通过reuseId来标识需要复用的组件，省去重复执行if的删除重创逻辑，提高组件复用的效率和性能。
使用状态变量替代函数/方法作为复用组件创建时的入参
由于在组件复用的场景下，每次复用都需要重新创建组件关联的数据对象，导致重复执行入参中的函数来获取入参结果。如果函数中存在耗时操作，会严重影响性能。正反例如下：
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-no-func-as-arg-for-reusable-component规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
反例：
上述反例的操作中，复用的子组件参数sum是通过耗时函数生成。该函数在每次组件复用时都需要执行，会造成性能问题，甚至是列表滑动过程中的卡顿丢帧现象。
正例：
上述正例的操作中，通过耗时函数countAndRecord生成的结果不变，可以将其放到页面初始渲染时执行一次，将结果赋值给this.sum。在复用组件的参数传递时，通过this.sum来进行。避免使用函数/方法作为复用组件创建时的入参，可以减少重复执行入参中的函数所带来的性能消耗。
与懒加载，缓存列表项复用
列表滑动等场景时，组件复用能力推荐搭配LazyForEach懒加载与缓存列表项共同使用以达到性能最优效果。
搭配LazyForEach懒加载时，只有直接写在LazyForEach内的组件，复用才能生效。
例如LazyForEach懒加载里面直接写的是父组件A，父组件A包含有@Reusable装饰器标识的子组件B，但此时子组件B不会实现组件复用。
关于LazyForEach懒加载的详细原理可以参考懒加载原理介绍。
具体开发场景的性能优化，可以参考长列表加载性能优化、瀑布流性能优化。
失效场景
组件复用约束与限制
检查失效方法
1.直接排查在List/Grid/WaterFlow等组件内，自定义组件是否标记为@Reusable。若未进行标记，则先对其进行标记，复用效果不理想的情况，可在调优工具中进行具体分析。关于调优的内容可参考性能分析简介。
2.通过Profiler调优工具抓取Trace，可以识别是否发生丢帧，判断子组件创建的次数。具体分析过程与数据对比可参考长列表加载性能优化-组件复用性能分析。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-lazyforeach-optimization
爬取时间: 2025-05-01 09:30:32
来源: Huawei Developer
概述
懒加载LazyForEach是一种延迟加载的技术，它是在需要的时候才加载数据或资源，并在每次迭代过程中创建相应的组件，而不是一次性将所有内容都加载出来。懒加载通常应用于长列表、网格、瀑布流等数据量较大、子组件可重复使用的场景，当用户滚动页面到相应位置时，才会触发资源的加载，以减少组件的加载时间，提高应用性能，提升用户体验。
懒加载原理介绍
渲染过程
在声明式描述语句中，有两种方式控制列表、网格等容器类组件的渲染，分别为循环渲染（ForEach）和数据懒加载（LazyForEach）。
-  ForEach循环渲染的过程如下： 其数据加载、组件树挂载、页面渲染的示意图如下所示： 如果列表数据较少，数据一次性全量加载不是性能瓶颈时，可以直接使用ForEach；但是当数据量大、组件结构复杂的情况下ForEach会出现性能瓶颈。这是因为要一次性加载所有的列表数据，创建所有组件节点并完成组件树的构建，在数据量大时会非常耗时，从而导致页面启动时间过长。另外，屏幕可视区外的组件虽然不会显示在屏幕上，但是仍然会占用内存。在系统处于高负载的情况下，更容易出现性能问题，极限情况下甚至会导致应用异常退出。
-  LazyForEach懒加载的原理和渲染过程如下： 其数据加载、组件树挂载、页面渲染的示意图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151045.42798135734240137551019561270836:50001231000000:2800:F913858118BD9F02F0F8C11D30CC176451C3FC31E41C16078E670E84CEEECCB8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151045.65226071308640903655259638060605:50001231000000:2800:8EC721D70A5CDCA2249ADDE05BAAB079466078F6171EB0FE8FF24AEE23512B0C.png)
LazyForEach实现了按需加载，针对列表数据量大、列表组件复杂的场景，减少了页面首次启动时一次性加载数据的时间消耗，减少了内存峰值。不过在长列表滑动的过程中，因为需要根据用户的滑动行为不断地加载新的内容，这需要进行额外的数据请求和处理，会增加滑动时的计算量，从而对性能产生一定的影响。然而，合理使用LazyForEach的按需加载能力，通过在滑动停止或达到某个阈值时才进行加载，可以减少不必要的计算和请求，从而提高性能，给用户带来更好的体验。总之，在实现按需加载的场景中，需要综合考虑性能和用户体验的平衡，合理地优化加载逻辑和渲染方式，以提升整体的性能表现。
键值生成规则和组件创建规则
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-no-stringify-in-lazyforeach-key-generator规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
在使用LazyForEach时，我们需要分别实现数据源dataSource、键值生成函数keyGenerator、子组件生成函数itemGenerator。其中，数据源为IDataSource类型，需要开发者实现该接口。keyGenerator是一个函数，用于为每个item生成一个唯一且持久的键值以标识对应的组件，开发者可以通过它自定义键值的生成规则，关于键值生成规则，详情可参考键值生成规则。LazyForEach的itemGenerator函数会根据键值生成规则为数据源的每个数组项创建组件，组件的创建分为首次渲染和非首次渲染两种情况，详情可参考组件创建规则。
在使用LazyForEach进行组件复用时，键值生成函数keyGenerator中不推荐使用stringify。在复杂的业务场景中，使用stringify会对item对象进行序列化，最终把item转换成字符串，这过程需要消耗大量的时间和计算资源，从而导致页面性能降低。
常见使用场景
LazyForEach作为常见的渲染控制的方式之一，常用的使用场景有长列表加载、无限瀑布流等。
长列表加载
长列表作为应用开发中最常见的开发场景之一，通常会包含成千上万个列表项，在此场景下，直接使用循环渲染ForEach一次性加载所有的列表项，会导致渲染时间过长，影响用户体验。而使用数据懒加载LazyForEach替换循环渲染ForEach，可以按需加载列表项，从而提升列表性能。数据懒加载的示例代码可以参考LazyForEach。
虽然，按需加载列表项可以优化长列表性能，但在快速滑动长列表的场景下，可能会来不及加载需要显示的列表项，导致出现白块的现象，从而影响用户体验。而在ArkUI中，List容器提供了cachedCount属性，LazyForEach可以结合cachedCount属性一起使用，能够避免白块的现象。cachedCount可以设置列表中ListItem/ListItemGroup的预加载数量，并且只在LazyForEach中生效，即cachedCount只能与LazyForEach一起使用。除了List容器，其他容器Grid、Swiper以及WaterFlow也都包含cachedCount属性。cachedCount的使用方法如下所示。
此外，HarmonyOS应用框架提供了组件复用能力，可以结合LazyForEach一起使用，进一步优化长列表的性能。组件复用会把组件树上将要移除的组件进行回收，回收的组件会进入到一个回收缓存区。后续创建新组件节点时，会复用缓存区中的节点，节约组件重新创建的时间。关于组件复用的详细原理可以参考组件复用。针对长列表加载的性能优化，可以参考优化长列表加载慢丢帧问题。
无限瀑布流
瀑布流的内容呈现方式类似瀑布流一样，从上往下依次排列，每一列的高度不一定相同，整体呈现出瀑布流的视觉效果。在瀑布流中，经常使用LazyForEach实现数据按需加载，同时，结合onReachEnd、onScrollIndex方法实现无限瀑布流，关于瀑布流的优化详情可以参考优化瀑布流加载慢丢帧问题。
常见失效场景
使用限制
在LazyForEach的使用上，有一些限制条件和限制场景，详细的限制条件请参考使用限制，常见的限制场景总结如下：
检查失效方法
当LazyForEach失效时，可能出现渲染错误、卡顿等现象，开发者可以使用日志、Profiler调优工具等方法来定位具体的问题。常见检查LazyForEach的失效方法有如下几种方式：
```typescript
LazyForEach(this.data, (lazyForEachItem: string) => {
ListItem() {
Row() {
Text(lazyForEachItem).fontSize(50)
}.margin({ left: 10, right: 10 })
}.onAppear(() => {
// 通过onAppear记录组件创建的次数
console.info("appear:" + lazyForEachItem)
})
}, (item: string) => {
// 在键值生成函数keyGenerator中打印键值
console.info("key:" + item)
return item;
})
```
1.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151046.16503999615522068215404085425678:50001231000000:2800:3130A0C04F84E339D1289CF26EC76352AFAE094C00083B31D5B58CAA2D506B87.png)
键值相同导致渲染错乱
在LazyForEach的键值生成规则中，每个item对应着一个唯一且持久的键值，用于标识对应的组件。当不同的数据项有相同的键值时，框架可能找不到正确的数据项，导致子组件渲染错误。关于键值错误导致渲染错乱的案例，详情可以参考首次渲染中的示例。
ListItem过于复杂导致丢帧
当使用LazyForEach时，如果子组件ListItem过于复杂，在子组件创建时，将产生大量的布局计算耗时，最终导致该帧丢帧。关键代码如下所示。
```typescript
@Entry
@Component
struct Index {
private data: MyDataSource = new MyDataSource();
aboutToAppear() {
for (let i = 0; i <= 30; i++) {
this.data.pushData(`Hello ${i}`)
}
}
build() {
List({ space: 3 }) {
LazyForEach(this.data, (lazyForEachItem: string) => {
ListItem() {
Column() {
ForEach(this.data.getAllData(), (forEachItem: string) => {
ListItem() {
Row() {
Text(lazyForEachItem + forEachItem).fontSize(50)
.onAppear(() => {
console.info("appear:" + lazyForEachItem)
})
}.margin({ left: 10, right: 10 })
}
}, (item: string) => item)
}
}
}, (item: string) => item)
}.cachedCount(5)
}
}
```
Scroll嵌套List导致按需加载失效
当Scroll容器嵌套List组件加载长列表时，若不指定List的宽高尺寸，则默认加载全部ListItem，导致按需加载失效，甚至会导致应用卡顿、崩溃，详细案例可参考合理使用布局。
GridItem未设置高度导致按需加载失效
当使用Grid容器时，如果GridItem没有设置高度，会加载所有子组件，设置了GridItem的宽高，会加载Grid显示区域内的子组件。参考案例代码如下：
```typescript
@Entry
@Component
struct Index {
private data: MyDataSource = new MyDataSource();
private scroller: Scroller = new Scroller();
aboutToAppear() {
for (let i = 0; i <= 30; i++) {
this.data.pushData(`Hello ${i}`)
}
}
build() {
Column() {
Grid(this.scroller) {
LazyForEach(this.data, (lazyForEachItem: string) => {
GridItem() {
Text(lazyForEachItem)
.fontSize(50)
.width('100%')
}
.onAppear(() => {
console.info("appear:" + lazyForEachItem)
})
}, (item: string) => {
return item;
})
}
.columnsTemplate('1fr')
.enableScrollInteraction(true)
.width('100%')
.height(800)
.cachedCount(5)
}
.width('100%')
.height(700)
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-time-optimization-of-the-main-thread
爬取时间: 2025-05-01 09:30:47
来源: Huawei Developer
概述
在应用开发实践中，有效避免主线程执行冗余与易耗时操作是至关重要的策略。此举能有效降低主线程负载，提升UI的响应速度。面对高频回调接口在短时间内密集触发的场景，需要避免接口内的耗时操作，尽量保证主线程不被长时间占用，从而防止阻塞UI渲染，引发界面卡顿或掉帧现象。本文介绍开发过程中常见的冗余操作，常见的高频回调场景以及其他主线程优化思路。
常见冗余操作
在软件开发中，冗余操作指的是那些不必要、重复执行且对程序功能无实质性贡献的操作。这些操作不仅会浪费计算资源，还可能降低程序的运行效率，特别是在高频调用的场景下，其负面影响更为显著。下面列举一些release版本中常见的冗余操作：
-  建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-avoid-empty-callback规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
【反例】：release版本中冗余日志打印，Trace打点，以及无业务代码的空回调
```typescript
import { hiTraceMeter } from '@kit.PerformanceAnalysisKit';
// 冗余操作反例
@Entry
@Component
struct RedundantOperation {
private arr: number[] = [];
aboutToAppear(): void {
for (let i = 0; i < 500; i++) {
this.arr[i] = i;
}
}
build() {
Scroll() {
List() {
ForEach(this.arr, (item: number) => {
ListItem() {
Text('TextItem' + item)
}
.onAreaChange((oldValue, newValue) => {
// 无任何业务操作
})
.width('100%')
.height(100)
}, (item: number) => item.toString())
}
.divider({ strokeWidth: 3, color: Color.Gray })
}
.width('100%')
.height('100%')
.onWillScroll(() => {
hiTraceMeter.startTrace('ScrollSlide', 1001);
console.debug('Debug', ('内容：' + '日志'));
// 业务逻辑
// ...
hiTraceMeter.finishTrace('ScrollSlide', 1001);
})
}
}
```
【正例】：release版本中删除冗余的debug日志，Trace打点以及无业务代码的空回调
```typescript
// 冗余操作正例
@Entry
@Component
struct NoRedundantOperation {
private arr: number[] = [];
aboutToAppear(): void {
for (let i = 0; i < 500; i++) {
this.arr[i] =i;
}
}
build() {
Scroll() {
List() {
ForEach(this.arr, (item: number) => {
ListItem() {
Text('TextItem' + item)
}
.width('100%')
.height(100)
}, (item: number) => item.toString())
}
.divider({ strokeWidth: 3, color: Color.Gray })
}
.width('100%')
.height('100%')
.onWillScroll(() => {
// 业务逻辑
// ...
})
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151046.88906398989290696194845212760049:50001231000000:2800:129B422218E7BDBA2CE7D5FA7CB8BC67E824721203B24E88917D59A57FB7DAE6.png)
通过上图可知，在3.5s的滑动过程中，总计触发了424次日志打印以及Trace追踪，打印一次日志的平均耗时为84μs，由此可以计算出冗余的debug日志浪费了35.616ms。release版本建议删除无效日志的打印。
对于回调函数体内不包含任何业务逻辑代码的冗余回调而言，即使开发者在回调函数内部未进行任何实质性的操作，只要注册了回调接口，如onAreaChange，系统底层仍会耗费资源去监测对应事件的发生，例如计算组件的位置或大小变化，并将这些数据传递给ArkTS侧。即使这些数据最终在ArkTS层没有被有效利用，底层的计算和通信开销已然存在。所以，为了避免不必要的资源消耗，提升应用性能，应当仔细审查并移除这类无实际用途的回调函数注册。开发过程中，除了需要避免冗余操作，还需要注意避免在高频回调场景执行耗时操作，接下来介绍一下高频回调场景以及需要避免的耗时操作。
高频回调场景
高频回调接口通常是指在应用程序运行过程中会被频繁触发的事件或回调函数，以下常见高频回调场景中需要避免执行耗时操作:
高频事件回调
例如，触摸事件、拖拽事件、移动事件、组件区域变化事件、滑动事件等系统事件在应用程序运行过程中会被频繁触发，如果在这些回调接口中执行耗时操作，将导致引用出现卡顿丢帧的问题。下方是基于Scroll组件滑动时会高频调用onWillScroll的场景，分析性能差异。
场景案例
【案例一】在onWillScroll回调中执行耗时操作
```typescript
// onWillScroll高频回调场景反例
@Entry
@Component
struct NegativeOfOnScroll {
private arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
count(): number {
let temp: number = 0;
for (let i = 0; i < 1000000; i++) {
temp += 1;
}
return temp;
}
build() {
Scroll() {
List() {
ForEach(this.arr, (item: number) => {
ListItem() {
Text('TextItem' + item)
}
.width('100%')
.height(100)
}, (item: number) => item.toString())
}
.divider({ strokeWidth: 3, color: Color.Gray })
}
.width('100%')
.height('100%')
.onWillScroll(() => {
hiTraceMeter.startTrace('ScrollSlide', 1001);
console.log('Scroll', 'TextItem');
// 耗时操作
this.count();
// 业务逻辑
// ...
hiTraceMeter.finishTrace('ScrollSlide', 1001);
})
}
}
```
【案例二】onWillScroll回调中不执行耗时操作
```typescript
// onWillScroll高频回调场景正例
@Entry
@Component
struct PositiveOfOnScroll {
private arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
build() {
Scroll() {
List() {
ForEach(this.arr, (item: number) => {
ListItem() {
Text('TextItem' + item)
}
.width('100%')
.height(100)
}, (item: number) => item.toString())
}
.divider({ strokeWidth: 3, color: Color.Gray })
}
.width('100%')
.height('100%')
.onWillScroll(() => {
hiTraceMeter.startTrace('ScrollSlide', 1001);
console.log('Scroll', 'TextItem');
// 业务逻辑
// ...
hiTraceMeter.finishTrace('ScrollSlide', 1001);
})
}
}
```
结果对比
下面将通过自定义Trace打点，统计不同案例场景下，单次onWillScroll事件回调的耗时差异，帧率差异以及分析。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151046.38485956556876694675192541203806:50001231000000:2800:45A4EB52316EB75B294130613BC00C2C77E54DA56C98365050C09637DE56F5A4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151046.26109274149658514813197912426500:50001231000000:2800:B58ECB20B65C0A59888AC60C6813BD49AB61A0A9E513F2B88E757CCA38EDF658.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151046.48890534652801259939668865734708:50001231000000:2800:BBC6F5F4D5EDE95B1A00A67F92D20968CB21068E91F75FFFFEF09F88B88A9971.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151046.75717986433137951242253749244428:50001231000000:2800:1E69FF4716153DBAD7C6D572C71EA76141B9EFE53AD7CAC4777C490BAF636235.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151046.81298232464346250747221178483718:50001231000000:2800:AE18C8187B505653B4F06DEBAB552DB0C2E4CDB6EB91F18E1DA97408A289443C.png)
通过图2、图3可知，onWillScroll事件回调中带有耗时操作，会占用主线程20ms左右的时间。由图4可知在具有耗时操作的滑动过程中，丢帧率高达87.5%。观察图6卡顿首帧Trace的详细信息发现，原本期望完成时间为8.3ms。因为onWillScroll中耗时操作的影响，使得实际处理时间为25ms，远超期望时间，短时间内连续触发该回调就会导致发生连续丢帧现象。因此在开发过程中，开发者应该尽量避免在高频事件回调中处理耗时操作，否则将导致应用性能大幅下降。
本案例在onWillScroll事件回调的开始开启打点追踪，在事件回调结束前停止性能打点追踪，用以测试有无耗时操作的性能差异。关于本例中使用性能打点的介绍，请参考性能打点。案例中关于帧率检测，丢帧分析，请参考帧率和丢帧分析实践。
由于本章节各场景的帧率数据统计以及分析步骤与方式大体一致，下文将不再对各场景的帧率进行重复统计分析。
组件复用回调
在滑动场景中，使用组件复用通常需要用生命周期回调aboutToReuse去更新组件的状态变量。在滑动时，aboutToReuse会被频繁调用。如果在aboutToReuse中进行了耗时操作，将导致应用出现卡顿丢帧的问题。下面的案例将基于Grid懒加载组件复用场景进行分析。
场景案例
【反例】：在aboutToReuse中进行耗时操作
```typescript
// ...
// 这里用循环函数模拟耗时操作
count(): number {
let temp: number = 0;
for (let index = 0; index < 1000000; index++) {
temp += 1;
}
return temp;
}
aboutToReuse(params: Record<string, number>) {
hiTraceMeter.startTrace('ReuseOfGrid', 1001);
this.item = params.item;
// 模拟耗时操作
this.count();
hiTraceMeter.finishTrace('ReuseOfGrid', 1001);
}
// ...
```
【正例】：在aboutToReuse中不进行耗时操作
```typescript
// ...
aboutToReuse(params: Record<string, number>) {
hiTraceMeter.startTrace('ReuseOfGrid', 1001);
this.item = params.item;
hiTraceMeter.finishTrace('ReuseOfGrid', 1001);
}
// ...
```
结果对比
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151046.12423721949073199574504751674854:50001231000000:2800:0ED7AE35FAEFE9A2250F7E8952B7C2E75CCD752EC8AB45F4996D3CC1A2B7C75A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151046.96785558079362053230161193651711:50001231000000:2800:D1E356330F105F94A84BC228FC67FFD5B3D2C0033964032F138A29F2E6D4928B.png)
如图7所示，从反例Trace中“H:ReuseOfGrid”标签可以看出，单个aboutToReuse执行耗时20ms。而从图8正例Trace中“H:ReuseOfGrid”标签看，单个aboutToReuse执行耗时仅56μs。带有耗时操作的单个aboutToReuse执行耗时远超期望时间8.3ms，在Grid滑动高频调用aboutToReuse的场景中，将会导致应用连续丢帧卡顿，性能大幅下降。因此，组件复用时应避免在aboutToReuse中执行耗时操作。
组件生命周期回调
在需要频繁创建和销毁组件的场景中，将会频繁调用组件生命周期回调aboutToAppear，aboutToDisappear。下面是一个使用条件渲染，通过点击按钮切换自定义组件A和B来模拟频繁创建和销毁组件的场景示例。
在自定义组件A，B的生命周期回调函数aboutToAppear和aboutToDisappear中加入耗时操作。
```typescript
@Entry
@Component
struct MyComponent {
// 切换自定义组件标志位
@State flag: boolean = false;
build() {
Column({ space: 10 }) {
Button('switch custom component')
.onClick(() => {
// 点击按钮切换自定义组件
this.flag = !this.flag;
})
// 使用条件渲染，通过点击按钮来模拟频繁创建和销毁组件的场景
if (this.flag) {
// 自定义组件A
CustomComponentA()
} else {
// 自定义组件B
CustomComponentB()
}
}
.width('100%')
.height('100%')
}
}
@Component
struct CustomComponentA {
aboutToAppear() {
let temp = 0;
for (let i = 0; i < 1000000; i++) {
temp += 1;
}
console.log('CustomComponentA aboutToAppear');
}
aboutToDisappear() {
let temp = 0;
for (let i = 0; i < 1000000; i++) {
temp += 1;
}
console.log('CustomComponentA aboutToDisappear');
}
build() {
Column()
.backgroundColor(Color.Blue)
.width(200)
.height(200)
}
}
@Component
struct CustomComponentB {
aboutToAppear() {
let temp = 0;
for (let i = 0; i < 1000000; i++) {
temp += 1;
}
console.log('CustomComponentB aboutToAppear');
}
aboutToDisappear() {
let temp = 0;
for (let i = 0; i < 1000000; i++) {
temp += 1;
}
console.log('CustomComponentB aboutToDisappear');
}
build() {
Column()
.backgroundColor(Color.Red)
.width(200)
.height(200)
}
}
```
因为示例中使用了条件渲染，每次销毁前一个自定义组件都会调用一次aboutToDisappear函数，然后创建新的自定义组件时，又会调用一次aboutToAppear，所以调用较为频繁。因此，在频繁创建和销毁组件的场景中，应尽量避免在aboutToAppear，aboutToDisappear中执行耗时操作。
循环渲染
在懒加载滑动场景中，框架会根据滚动容器可视区域按需创建组件，关于懒加载接口的描述如下
```typescript
LazyForEach(
dataSource: IDataSource,             // 需要进行数据迭代的数据源
itemGenerator: (item: Object, index: number) => void,  // 子组件生成函数
keyGenerator?: (item: Object, index: number) => string // 键值生成函数
): void
```
所以在滑动时框架会频繁调用子组件生成函数itemGenerator，键值生成函数keyGenerator以及dataSource获取索引数据函数的getData函数。如果在itemGenerator，keyGenerator，getData中执行了耗时操作（比如传入耗时的函数作为入参），就会导致应用出现卡顿丢帧的问题。
三种函数的正反例效果类似，故本次只针对itemGenerator进行测试，下面依然基于Grid懒加载组件复用场景进行分析。
本案例中子组件生成函数itemGenerator以及键值生成函数keyGenerator详细信息，请参考LazyForEach。获取索引数据函数getData的说明，请参考IDataSource说明
本案例中懒加载的子组件生成函数即GridItem组件的生成函数。
```typescript
// ...
aboutToAppear() {
// ...
}
// 模拟耗时操作
itemGeneratorFunc(item: number): number {
let temp: number = 0;
for (let index = 0; index < 1000000; index++) {
temp += 1;
}
item += temp;
return item;
}
build() {
Column({ space: 5 }) {
Grid() {
LazyForEach(this.data, (item: number) => {
GridItem() {
// 使用可复用自定义组件
ReusableChildComponent({ item: this.itemGeneratorFunc(item) })
}
}, (item: string) => item)
}
// ...
}
}
```
【正例】：itemGenerator不执行耗时操作
```typescript
// 耗时操作计算的值
private timeConsumingValue: number = 0;
// 耗时操作代码在其他执行
// ...
// 这里用循环函数模拟耗时操作
async itemGeneratorFunc() {
let temp: number = 0;
for (let index = 0; index < 1000000; index++) {
temp += 1;
}
this.timeConsumingValue = temp;
}
build() {
Column({ space: 5 }) {
Grid() {
LazyForEach(this.data, (item: number) => {
GridItem() {
// 使用可复用自定义组件
ReusableChildComponent({ item: item + this.timeConsumingValue })
}
}, (item: string) => item)
}
// ...
}
}
```
结果对比
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151046.83025773123622523088575026824016:50001231000000:2800:A674223A8E419C812A8083E1E2FF46E02479DD647A5604F8277EC71ACB1C71FC.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151047.86637335437913472527132304157306:50001231000000:2800:86C3C6BBDEEE43122C5A71C8D661DFE18F14DED11A68D4C73DABA7BA5F9A96BB.gif)
图9是在itemGenerator入参函数中执行耗时操作的滑动效果，可以明显看出滑动时存在卡顿，item节点刷新慢等问题。图10是在aboutToAppear中执行耗时操作，把耗时操作计算的值timeConsumingValue传入itemGenerator的滑动效果，可以看出滑动效果流畅，无卡顿问题。
因此，在懒加载滑动场景中，应避免在LazyForEach的itemGenerator，keyGenerator，getData中执行耗时操作，可以有效减少应用卡顿丢帧的问题，提升用户体验。
组件属性
组件单一属性刷新时，组件的其他属性也会同时进行刷新。在需要频繁刷新组件属性的场景中，如果组件中其他不需要刷新的属性使用了耗时的函数作为入参。那么在刷新组件某个属性时，组件中那些实际上不需要去刷新的属性将会去调用耗时函数，导致不必要的性能损耗，同时也会引起应用卡顿丢帧的问题。
下面是一个点击按钮改变Row组件宽度的示例
【反例】：Row组件的高度以耗时函数作为入参
```typescript
@Entry
@Component
export struct NegativeOfProperty {
// Row宽度
@State rowWidth: number = 100;
getHeight(): number {
let height: number = 0;
// 这里用循环函数模拟耗时操作
for (let index = 0; index < 1000000; index++) {
height += 0.0001;
}
return height;
}
build() {
Column({ space: 10 }) {
Button('change row width')
.onClick(() => {
this.rowWidth = this.rowWidth + 20;
if (this.rowWidth > 200) {
this.rowWidth = 100;
}
})
Row()
.width(this.rowWidth)
.height(this.getHeight())
.backgroundColor(Color.Blue)
}
.width('100%')
.height('100%')
}
}
```
【正例】：使用任务池taskpool处理耗时操作后返回结果给Row的高度rowHeight
```typescript
import { taskpool } from '@kit.ArkTS'; // 任务池
@Concurrent
function getHeight(): number {
let height: number = 0;
// 这里用循环函数模拟耗时操作
for (let index = 0; index < 1000000; index++) {
height += 0.0001;
}
console.log('Scenario 4 call getHeight');
return height;
}
// 执行getHeight()
taskpool.execute(getHeight).then((value: Object) => {
AppStorage.setOrCreate('height', value);
});
@Entry
@Component
struct PositiveOfProperty {
// Row宽度
@State rowWidth: number = 100;
// Row高度
@StorageLink('height') rowHeight: number = 0;
// 点击按钮改变Row宽度的次数
private count: number = 0;
build() {
Column({ space: 10 }) {
Button('change row width')
.onClick(() => {
this.rowWidth = this.rowWidth + 20;
this.count++;
console.log('Scenario 4 change row width count:' + this.count);
if (this.rowWidth > 200) {
this.rowWidth = 100;
}
})
Row()
.width(this.rowWidth)
.height(this.rowHeight)
.backgroundColor(Color.Blue)
}
.width('100%')
.height('100%')
}
}
```
在组件单一属性刷新时，组件的其他属性也会同时进行刷新。每次点击按钮改变Row组件宽度时，Row的高度也会同时刷新。反例每次改变Row组件宽度rowWidth，都会调用一次耗时的Row高度入参函数getHeight()。正例在页面加载时通过taskpool方式仅执行一次耗时的getHeight()。然后返回结果直接赋值给Row高度变量rowHeight。后续每次改变Row组件宽度rowWidth时,不需要重复调用耗时的getHeight()，有效减少了不必要的性能开销。
因此，在高频刷新组件属性的场景中，应避免在组件的属性中执行耗时操作（如属性使用耗时的函数入参），能有效减少应用卡顿丢帧的情况，提升用户体验。
其他主线程优化思路
当主线程中遇到一些难以避免的耗时操作时，可以从以下角度进行性能优化：
避免使用耗时接口
在应用开发中，经常会调用系统提供的接口，比如读取本地文件、处理服务端数据等等。若对接口使用不合理，可能引起延迟、卡顿、丢帧等性能问题。以如下系统提供的接口为例，总结了使用中的注意事项。下面以ResourceManager同步获取资源的接口为例进行分析。
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-use-taskpool-for-web-request规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
ResourceManager
ResourceManager通过getXXXSync接口同步获取资源的方式有两种，1、通过resource对象获取resourceManager.getStringSync($r('app.string.test'))；2、通过id获取resourceManager.getStringSync($r('app.string.test').id)。 下面以getStringSync为例，测试一下这两种参数在方法中的使用是否会有耗时区别。
```typescript
import { hiTraceMeter } from '@kit.PerformanceAnalysisKit';
@Entry
@Component
struct GetStrOfResource {
@State message: string = 'getStringSync';
aboutToAppear(): void {
hiTraceMeter.startTrace('getStringSync', 1);
// getStringSync接口的入参直接使用资源，未使用资源ID
getContext().resourceManager.getStringSync($r('app.string.test'));
hiTraceMeter.finishTrace('getStringSync', 1);
}
build() {
RelativeContainer() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
.height('100%')
.width('100%')
}
}
```
```typescript
import { hiTraceMeter } from '@kit.PerformanceAnalysisKit';
@Entry
@Component
struct GetStrOfId {
@State message: string = 'getStringSyncAfter';
aboutToAppear(): void {
hiTraceMeter.startTrace('getStringSyncAfter', 2);
// getStringSync接口的入参使用了资源ID
getContext().resourceManager.getStringSync($r('app.string.test').id);
hiTraceMeter.finishTrace('getStringSyncAfter', 2);
}
build() {
RelativeContainer() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
.height('100%')
.width('100%')
}
}
```
结果对比
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151047.87626623516010262730740420932656:50001231000000:2800:00BED6D0B36012310452E33DC8B629CCB640EED963ABCF5C26BFA199545BA99E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151047.23220909900753717316493100498543:50001231000000:2800:D2C3A565D521D336F0050CD7219F6E4AD960B853997EC7E21CB1696E1E70E557.png)
getStringSync参数为资源信息时（1.956ms）比参数为资源ID值时（0.071ms）耗时更多，因为通过resource对象获取资源时，获取的是拷贝对象，获取过程中发生了一次深拷贝，而通过资源ID获取子元素，直接获取原对象的引用。所以当需要使用类似方法时，使用资源ID值作为参数更优。
通过本案例可以发现，同一接口的不同使用方式存在着性能差异，在开发过程中应该选择耗时更少、性能更优的接口，避免因此引起的延迟卡顿丢帧等性能问题。
wordBreak属性
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-use-word-break-to-replace-zero-width-space规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
零宽空格（Zero Width Space, ZWSP）是一个特殊的Unicode字符。它是一个不可见的字符，其宽度为零，不占用任何可见空间。在文本处理系统中，尽管它在视觉上是不可见的，但它在文本中确实存在，并可以作为潜在的断点，即允许在此位置断开行。这意味着如果一行文本过长需要自动换行时，文本可以在零宽空格的位置进行折行，而不影响单词的完整性。
虽然零宽空格在许多情况下都是有用的，但它也可能引起问题，特别是在文本处理和数据清洗中。不注意这些看不见的字符可能导致数据的意外错误、搜索失败、数据不一致等问题。因此，在处理来自不同源的文本数据时，了解和考虑这些不可见字符是非常重要的。
避免在文本组件内使用零宽空格(\u200b)的形式来设置断行规则，推荐使用wordBreak，wordBreak在使用性能方面优于零宽空格。例如推荐用法为：Text(this.diskName).wordBreak(WordBreak.BREAK_ALL)。
常见高耗时接口有：getInspectorByKey、getInspectorTree、sendEventByKey、sendTouchEvent、sendKeyEvent、sendMouseEvent。
以上接口由于耗时长，建议仅用于应用测试阶段。
使用多线程能力
在主线程面临耗时操作时，采用多线程能力是一种高效的优化手段。通过将耗时任务分配给后台线程并行执行，主线程可以继续处理其他任务，保持应用的流畅性和响应性。这种方式能够充分利用多核处理器的计算能力，提高程序的执行效率，减少用户等待时间，从而提升整体的用户体验。
场景案例
列表无限滑动的场景，在即将触底的时候需要进行数据请求，如果在主线程中直接处理请求数据，可能会导致滑动动画被中断。如果回调函数处理的耗时较长，会直接阻塞主线程，卡顿就会非常明显。使用异步执行的方式进行异步调用，回调函数的执行还是会在主线程，一样会阻塞UI绘制和渲染。
以瀑布流使用案例为基础进行代码改造,得到如下代码,瀑布流在即将触底时调用异步函数mockRequestData获取新数据，并将新数据写入数据源。异步函数mockRequestData用于模拟耗时的网络请求，从rawfile目录下读取数据，将数据处理后返回。
```typescript
build() {
Column({ space: 2 }) {
WaterFlow() {
LazyForEach(this.dataSource, (item: number) => {
FlowItem() {
// ...
}
.onAppear(() => {
// 即将触底时提前增加数据
if (item + 20 === this.dataSource.totalCount()) {
//  模拟网络获取数据引起的耗时，
this.mockRequestData().then((data: Item[]) => {
for (let i = 0; i < data.length; i++) {
this.dataSource.addLastItem();
}
})
}
})
// ...
}, (item: string) => item)
}
// ...
}
}
async mockRequestData(): Promise<Item[]> {
let res: ResponseData = new ResponseData();
// data.json是存在本地的json数据，大小大约20M,模拟从网络端获取数据
await getContext().resourceManager.getRawFileContent('data.json').then((data: Uint8Array) => {
// 解析json
let str = buffer.from(data).toString();
res = JSON.parse(str);
})
return dataToItem(res.data);
}
```
使用profiler工具抓取Trace：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151047.43185020191554398382062108650142:50001231000000:2800:FA85BDCE917EC330A9FF8ABC2E633E8AB40123E5C82D7E19DDB5E978148CEC7D.png)
从图中可以看到，在主线程中出现了大块的耗时，直接导致用户在滑动的时候能感受到明显的卡顿。异步回调函数最后也由主线程执行，所以应该尽量避免在回调函数中执行耗时操作。可以使用系统自带的TaskPool多线程能力，将耗时任务交由子线程执行，避免主线程的长时间阻塞，以下为使用TaskPool优化后的代码：
```typescript
build() {
Column({ space: 2 }) {
WaterFlow() {
LazyForEach(this.dataSource, (item: number) => {
FlowItem() {
// ...
}
.onAppear(() => {
// 即将触底时提前增加数据
if (item + 20 === this.dataSource.totalCount()) {
//模拟网络获取数据引起的耗时，
taskPoolExecute().then((data: Item[]) => {
for (let i = 0; i < data.length; i++) {
this.dataSource.addLastItem();
}
})
}
})
// ...
}, (item: string) => item)
}
// ...
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151047.34716086484337443609239774331428:50001231000000:2800:DB9F5F67C080FF68564DC2DFD3627DE1DDA643424B3E2EF9783CD1EEA50B9906.png)
通过上图可以看出，使用多线程能力TaskPool后，将原先在主线程中的获取资源的任务getRawFileContent转移到了TaskWorker线程，避免了获取资源导致的主线程长时间阻塞，但是TaskWorker将结果返回给主线程，主线程反序列化数据的过程中依然会消耗一定时间，接下来在泳道图中搜索"H:Deserialize"标签查看主线程反序列化耗时。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151047.31249106446369706899467259098833:50001231000000:2800:19F0C1A13E5CAD5F54FD398A3529B9F1AEA094C72DEEC336EFF9D186159E8DA8.png)
从图中可以看出主线程在反序列化TaskWorker线程返回的数据依然存在12ms的耗时，超过当前测试设备的Vsync周期（8.3ms），应用可能会因此引起卡顿。针对跨线程的序列化耗时问题，系统提供了@Sendable装饰器来实现内存共享，可以在返回的Item类上使用@Sendable装饰器，继续优化性能。
@Sendable装饰器
@Sendable装饰器可以实现数据在多线程间的传递行为是引用传递，使用方式如下：
关于@Sendable装饰器的详细介绍以及使用限制，请参考Sendable开发指导。
上述示例代码中在TaskWorker线程返回的Item对象上使用了@Sendable，系统会使用共享内存的方式处理使用了@Sendable的类，从而降低反序列化的开销，抓取Trace图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151047.38643038366116356045370162486813:50001231000000:2800:C39A040D4A218DF37618C476505342BC7F0167A6C1EBC589987DB0F32FE5DA97.png)
从图中可以看出反序列化的耗时由12ms减少到1.6ms，明显减少了主线程的阻塞时间，所以当主线程需要反序列化其他线程返回的大量数据时，可以使用@Sendable装饰器减少主线程的时间消耗。
开发过程中，在主线程执行一些耗时任务，可能会阻塞UI渲染导致卡顿、掉帧等性能问题。具有如下优化思路
示例代码
主线程耗时操作优化指导

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-global-custom-component-reuse
爬取时间: 2025-05-01 09:31:01
来源: Huawei Developer
概述
默认的组件复用行为，是将子组件放在父组件的缓存池里。受到这个限制，不同父组件中的相同子组件无法复用。推荐的解决方案是将父组件改为builder函数，让子组件共享组件复用池。但是由于在一些应用场景下，父组件承载了复杂的带状态的业务逻辑，而builder是无状态的，修改会导致难以维护。因此开发者可以使用BuilderNode自行管理组件复用池，也可以通过使用全局组件复用池三方库nodepool来实现全局组件复用。
实现思路
组件复用原理
在ArkUI中，当页面退出时，系统默认会销毁页面上的所有节点及其对应的NodeItem实例，以释放资源。为了提升性能和资源利用率，应用侧可以主动保存NodeItem实例。通过这种方法，能够有效延长这些NodeItem实例的生命周期，避免不必要的重建开销，从而在后续页面或组件的创建过程中实现快速复用。
下图为复用池中NodeItem实例跟随NodeContainer组件创建与销毁的复用过程。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151047.08875075335756178909785578022553:50001231000000:2800:AA8E090C45DDDD89D4270CB66928D64C312731C1C4B9FAABB8CB0F5D48ED54EA.png)
数据结构
NodeItem继承NodeController，并实现makeNode方法，创建组件。NodePool通过HashMap管理NodeItem的复用和回收。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151047.52577596552636964965732800230260:50001231000000:2800:590064845B46816C20DDB01AAFBC29DCF44464849408F0AFCF2FA4D5B99048B2.png)
应用场景
在应用开发中，会遇到需要页面切换的场景，比如某些视频APP的首页，就是一个List（标题）+Swiper（列表页面）实现的Tabs切换场景。Swiper中每个页面都使用瀑布流加载视频列表，各个瀑布流中的子组件有可能是相同的布局，为了提升应用性能，就会有跨页面复用子组件的需求。但是在ArkUI提供的常规复用中，复用池是放在父组件中的，这就导致跨页面时无法复用上一个页面瀑布流中的子组件。此时就可以使用BuilderNode自定义一个全局的组件复用池，根据页面状态创建、回收、复用子组件，实现组件的跨页面复用。
组件复用性能对比
下面通过常规复用和自定义组件复用池两种方式，对比组件复用的性能。
常规复用
```typescript
Swiper() {
ForEach(this.index % 2 === 0 ? banners1 : banners2, (res: Resource) => {
Image(res)
.width('100%')
.height('100%')
})
}
.loop(true)
.width('100%')
.height(200)
.nestedScroll(SwiperNestedScrollMode.SELF_FIRST)
WaterFlow() {
LazyForEach(this.dataSource, (item: ViewItem, index: number) => {
FlowItemComp({
item: item,
updater: (item: ViewItem) => {
this.fillNewData(item)
},
})
.reuseId('reuse_type_')
}, (item: string) => item)
}
.columnsTemplate("1fr 1fr")
.columnsGap(10)
.rowsGap(5)
.backgroundColor(0xFAEEE0)
.width('100%')
.height('100%')
```
-  编译运行后，点击Tabs切换页面，然后抓取Trace，通过图1中选择的区域可以看到，切换Tabs时，每个页面的首帧耗时（从DispatchTouchEvent标签开始，到sendCommands标签结束）都在20-30ms左右。这是因为使用@Reusable的组件复用，是使用了父组件的复用池。FlowItemComp的父组件是WaterFlow，Tab切换时新页面的WaterFlow会被重新创建，这就导致前一个页面的复用池是无法使用的，只能重新创建所有的子组件。 图1 常规复用Trace图
```typescript
// 需要添加@Reusable装饰器，并实现aboutToReuse接口用于组件复用时刷新数据
@Reusable
@Component
export struct FlowItemComp {
// ...
build() {
// ...
}
// 通过aboutToReuse接口刷新复用后的数据
aboutToReuse(params: ESObject): void {
this.item = params.item
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151048.91150034387334947965338785344538:50001231000000:2800:222EB57D09AE0782C1E61C8D8457C26C2757B8BCAB4AE8750BA3438B33DF1E84.png)
自定义组件复用池
```typescript
// 全局组件复用池
export class NodePool {
private static instance: NodePool;
// ...
private constructor() {
this.nodePool = new HashMap();
this.idGen = 0;
}
// 使用单例模式，用于全局管理组件复用池
public static getInstance() {
if (!NodePool.instance) {
NodePool.instance = new NodePool();
}
return NodePool.instance;
}
// ...
}
```
```typescript
// 回收子组件到复用池中
public recycleNode(type: string, node: NodeItem) {
let nodeArray: Array<NodeItem> = this.nodePool.get(type);
if (!nodeArray) {
nodeArray = new Array();
this.nodePool.set(type, nodeArray);
}
nodeArray.push(node);
}
```
编译运行后，点击Tabs切换页面，然后抓取Trace，通过图2中的选择区域可以看到，第一个页面的首帧耗时和常规复用是差不多的，但是后面3个页面的耗时大幅减少，只有13ms和16ms左右。这是因为第一个页面创建时自定义复用池里没有被回收的子组件，所以会和常规复用一样，需要直接创建新的子组件。而切换到第三个页面时，第一个页面中的子组件被回收到了自定义复用池NodePool中，当第三个页面被创建时，会先去复用池中查找可用的子组件直接使用，减少了创建子组件的时间。
图2 自定义组件复用池Trace图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151048.98528124022954144776669723868859:50001231000000:2800:0119B35BF3508F0BEED760FB1D4A955D4D89D0E5A95F6EF64F058820FD75D79B.png)
性能数据对比
| 页面  | 首页  | 风景  | 商品  | 旅游  | 头像  |
| --- | --- | --- | --- | --- | --- |
| 创建耗时（优化前）  | 46.8ms  | 27.2ms  | 25.2ms  | 22.3ms  | 30.3ms  |
| 创建耗时（优化后）  | 57.1ms  | 29.2ms  | 13.0ms  | 15.9ms  | 16.9ms  |
页面
首页
风景
商品
旅游
头像
创建耗时（优化前）
46.8ms
27.2ms
25.2ms
22.3ms
30.3ms
创建耗时（优化后）
57.1ms
29.2ms
13.0ms
15.9ms
16.9ms
使用onIdle进行组件预创建
在上一个章节的优化示例中，第一次进入首页时耗时依旧较高。这是因为第一次进入时，自定义组件复用池中没有组件可以复用，全部需要重新创建。要解决这个问题，可以提前预创建组件复用池中的组件，减少进入首页的启动耗时。目前，应用冷启动是一个比较好的预创建组件的时机。当组件数量较多时，集中预创建本身也耗时较长，容易导致主线程阻塞。ArkUI中提供了onIdle回调接口，可以返回每一帧帧尾的空闲时间，在帧尾空闲时逐步进行预创建是一个比较好的分摊主线程负载的方式。
示例代码
下面的代码，模拟了应用冷启动的流程，在应用启动后先进入广告页（Index页面），并在广告页进行组件预创建。
```typescript
// 继承NodeController，创建可以复用的子组件
export class NodeItem extends NodeController {
// ...
// 预创建BuildNode
prebuild(uiContext: UIContext) {
this.node = new BuilderNode(uiContext);
this.node.build(this.builder, this.data);
}
}
// 全局组件复用池
export class NodePool {
// ...
public preBuild(type: string, item: ESObject, builder: WrappedBuilder<ESObject>, uiContext: UIContext) {
if (type) {
let nodeItem: NodeItem | undefined = new NodeItem();
nodeItem.builder = builder;
nodeItem.data.data = item;
nodeItem.type = type;
// 预创建组件
nodeItem.prebuild(uiContext);
// 将预创建的组件回收到复用池中，便于后续复用
this.recycleNode(type, nodeItem);
}
}
// ...
}
```
1.
2.
3.
4.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151048.76237349829559566257708433324494:50001231000000:2800:47D4587BD5A6E9097E23DC0BA40A3878DFFB356B1F67C0024189350992FF6D6B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151048.47926671375395924225696410950628:50001231000000:2800:BA729E0C05B2BAD5DAD72694319B160CB82D439240EF7B61624D220BEA97D744.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151048.39495103159507222322321906965173:50001231000000:2800:CD8FE2D042419DCD3DD911C072ECD3791D36F912CA5AA5FBE3C4D4F1F0B3CF96.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151048.82252310545446195446766288262119:50001231000000:2800:C5972B72465B33E43A05C4E6D8D5A93D1FD2DD6C1EC18552AE78ABC6AEFD67EA.gif)
优化方案
前文中可以看到，在冷启动时进行预创建，当组件数量较多时，会引起主线程的阻塞，增加冷启动耗时。为了解决这个问题，可以通过onIdle回调方法，将组件预创建分布到每一帧帧尾的空闲时间中执行。这样一来，预创建过程就被平摊在多个周期里执行，避免对冷启动时间的过度影响，进而优化启动速度和用户体验。
实现思路
当系统执行完全部任务后，会将帧尾的空闲时间通知到onIdle回调。此时，如果组件复用池中有需要预创建的组件，则判断空闲时间是否足够进行预创建。如果时间充足，则进行组件预创建，否则将onIdle回调传递到下一帧中执行，直到所有的组件全部预创建完成。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151048.40972011603147466965245332752971:50001231000000:2800:FEC4614B9D3C22F9B5B0DFB23899B6FD5CD537B6BF13039F7A895F653E84BF01.png)
优化代码
下面的代码，将对组件预创建进行优化，把预创建分摊到帧尾的空闲时间中进行。
```typescript
// onIdle回调，返回帧尾空闲时间idleTimeInNano。
onIdle(idleTimeInNano: number): void {
// 当预创建的组件数量已经超过模拟数据的数量，则停止预创建
if (this.todoCount >= this.viewItems.length) {
return;
}
// 当前时间，后续用于计算本帧剩余空闲时间。
let cur: number = systemDateTime.getTime(true);
// 帧尾空闲时间，后续用于计算本帧剩余空闲时间。
let timeLeft = idleTimeInNano;
// 当帧尾空闲时间大于1ms时，执行预创建。
// 此处空闲时间限制设置了1ms，即空闲时间少于1ms时，本帧不再进行组件的预创建，而是将帧回调传递到下一帧，开发者可以根据自身业务、组件复杂度进行设置，预留足够的空闲时间。
while (timeLeft >= 1000000) {
```
1.
2.
3.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151048.62730726804863620855348792123454:50001231000000:2800:C3F5247DF3C432F23096D2154C450810D2CE13D165094B0850DC587E973596E4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151048.84773402356199693609710661263056:50001231000000:2800:A901BADC7F5C7EF348BC05ECE2F78C08E77059844710C95E1AB2453C1D209E35.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151048.81688842314158441965788240653326:50001231000000:2800:102111F4A041A54225F86AFAA1AA10A2D8380179C92FB8A5B5C8DDA0C8FE0553.gif)
性能对比
通过前两个章节可以看到，使用onIdle进行闲时组件预创建时，性能优化效果明显，能够在预创建复用池组件的前提下，减少冷启动时间。
| 优化前  | 133ms  |
| --- | --- |
| 优化后  | 8ms  |
优化前
133ms
优化后
8ms
使用约束
1. 开发者需要根据业务准确预估组件预创建耗时，同时将业务逻辑颗粒度拆小，以便能够拆分到多个onIdle时机中完成。例如，单个组件预创建耗时在2ms左右，帧尾空闲时间只有1ms，那么就不能在当前帧进行预创建，而是延迟到下一帧中执行。
2. 需要合理控制自定义组件复用池中组件预创建的数量，否则内存占用较多，可能会影响性能。
总结
在父组件内部进行组件复用时，使用常规复用是可以解决问题的，而且使用简单，只需要添加@Reusable装饰器并且实现aboutToReuse。但是由于复用池的局限性，不同的父组件想要复用相同子组件时就会失效。而自定义组件复用池，可以实现跨页面的组件复用，并在闲时对组件进行预创建，加快组件的加载速度。但是实现起来也比较复杂，需要开发者自己维护复用池。可使用全局组件复用池三方库：nodepool
相关工程源码参考：node_pool
常见问题
示例代码中为什么不使用ArkUI提供的Tabs+TabContent组件，而是要用List+Swiper组件实现？
Tabs中不支持使用LazyForEach，只能使用ForEach。如果使用ForEach，那么在页面创建时会将所有的TabContent全部创建，并且切换时无法回收子组件（不会执行aboutToDisappear），这就导致自定义复用池NodePool中是空的，每次创建时都获取不到组件，只能重新创建，使组件复用失去了效果。并且因为多创建了一个NodeContainer组件，耗时会比常规复用更长。
NodeController中aboutToDisappear接口，是否和自定义组件生命周期中的aboutToDisappear相同？
NodeController中aboutToDisappear与自定义组件生命周期的aboutToDisappear含义不同，在复用时也会走到aboutToDisappear，在外层复用场景，会导致重复挂载。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-dispose-highly-loaded-component-render
爬取时间: 2025-05-01 09:31:16
来源: Huawei Developer
概述
在应用开发中，页面内列表结构复杂，每个列表项包含的组件较多，就会导致嵌套层级较深，从而引起组件负载加重，绘制耗时增长。
在这种情况下，转场或者列表滑动的时候列表项就会一次性加载大量的数据，此时可以采用分帧渲染，将本来一帧内加载的数据分成多帧加载，但是分帧渲染需要开发者计算每帧中加载多少数据，操作复杂，因此在必要的情况下才推荐使用。
实现原理
原理说明
单帧内绘制多个特点各不相同的组件时，会同时创建数量较多的GraphicsPipelines，引发后续整个Flush阶段的耗时延长，从而导致单帧耗时超长。对于这种单帧内组件负载重、加载数据多和绘制耗时长的问题场景，开发者可以根据实际的业务逻辑、应用页面布局和数据量，提前计算规划出需要通过多少帧完成加载以及每帧具体加载的数据。应用页面实际加载绘制的时候，结合页面的布局，使用帧回调监听修改状态变量或补充数据到数据结构等方式，对每一帧需要处理的渲染数据进行计算和设置，保证每一帧内只处理提前设置好的数据。因为已经设置了帧回调监听，具体的页面组件加载数据时，只需要通过状态变量或者数据结构，即可实现按帧分批加载数据。这样就达到了原本在一帧中加载的数据分到多帧加载的目的，有效减少了首帧的耗时，避免首帧卡顿现象的出现。如下图所示，将一帧数据拆分到三帧示例：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151048.94968924804449928198663351019303:50001231000000:2800:0B91197A5C4D5B4231CEDEDCFCE625CA48C4ED41DF48A3C92DC2832BF1F06433.png)
具体实现
在高负载场景下使用分帧渲染的关键操作是把数据拆分到每一帧中加载，但这个过程中加载新的数据时可能会将已有数据再次绘制，因此需要搭配合理的页面布局来避免重绘。可以通过if或ForEach两种方法来实现布局，两种方法的更新机制如下：
因此在分帧逐步加载数据时使用上述两种方法不会引起重绘。并且在页面布局时可以给分帧渲染的外部容器组件设置宽高，这样组件本身不会触发重新进行Measure的过程，对组件的宽高不会重新测算，避免因外部容器大小改变引起重绘，详情可参考合理使用布局。
保证页面不会重绘后，在实际开发过程中为了逐步增加页面数据，可以使用ArkTS中提供的displaySync（可变帧率）API接口，通过Vsync信号控制数据刷新的时机，来实现绘制内容帧率的控制。先通过页面UI中aboutToAppear()添加帧回调监听并开启监听，Vsync信号变化时触发帧回调执行应用逻辑，计算每帧加载的数据，改变ViewModel数据。ViewModel数据改变后驱动页面或组件执行build()，使用if或ForEach分帧迭代渲染绘制UI并控制刷新范围。最后可以在aboutToDisappear()里停止帧回调监听。
具体操作流程如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151048.57580744998080898348231608011551:50001231000000:2800:88F145D62BD3300F79D0BE7A42322375AAAA2A81000CEC333FB12D2B0C2582E9.png)
转场场景
由于业务需求，从当前页面进入一个新页面时，会有转场动画播放，并且在动画首帧中加载新页面所需要的数据。如果数据量较多，那么动画首帧的响应时延就会变长，导致后面动画帧延迟播放的情况。从一个页面到新页面转场流程图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151049.71570237627351653482354756416565:50001231000000:2800:3A1D3FD9FF4EDAAF42C530B5B442C399AC09CA426289F62EBC0AA2435C87355B.png)
解决思路
既然转场时一次性加载大量的数据会导致卡顿情况，那么采用分帧渲染将数据拆分成多份并分批次进行加载就是一种解决思路。
转场场景分帧：转场时会在动画首帧加载新页面的数据，采用分帧策略就是将首帧加载的数据拆分，将数据拆分到后面的帧加载，新页面打开后List列表只展示两个列表项，因此在首帧加载显示两条数据，其余缓存数据可以在第二帧加载。该方法的优点是减少动画首帧的响应时间，缺点是转场动画完成时延变长。
转场场景效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151049.63061035654736729438423088658205:50001231000000:2800:C2B05BBF8C636A198E696A7FBCEB266E28C850AFC912035FA9425E384607B3B1.gif)
在分帧前会在转场动画的首帧将层叠组件和列表可见区域与缓存区域的数据全部加载，而分帧后在首帧加载层叠组件和列表前两项的数据，在第二帧加载缓存区域的列表数据。分帧前后示意图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151049.87320983295220250845462100728683:50001231000000:2800:22AC357150BCBC19D4E93D4D0BC9902F61AD1DA85F6F8CA52411275A13031B3C.png)
常规代码
通常情况下，在自定义列表组件中一次性加载全部数据，更新所有的列表项。
```typescript
@Component
export struct TransitionScene {
private productData: ProductDetailSource = new ProductDetailSource();
aboutToAppear() {
this.productData.getProductData();
}
build() {
WaterFlow() {
LazyForEach(this.productData, (item: ProductDetailModel) => {
FlowItem() {
// ...
}
}, (item: ProductDetailModel) => item.id.toString())
}
// ...
}
}
```
这段代码里，在组件即将出现时回调aboutToAppear()接口，将数据放入productData中，并通过瀑布流加载。编译运行后，可以通过Trace图看到，转场动画的首帧耗时21ms左右，这是因为在点击进入页面时将数据全部放入瀑布流，在235970帧中需要计算每个子组件的尺寸，导致了响应时间增长。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151049.76989203914494095152105672971411:50001231000000:2800:CC7F8E2953D6C1A4701444BD6AF65BCD209B8FAD3451AE4DB799E255EDE52283.png)
优化代码
在aboutToAppear()接口中添加displaySync的帧回调，并将数据拆分进行加载。
在这段代码中，aboutToAppear()接口中并没有一次性加载全部数据，而是将数据拆分，在帧回调中分成2次进行加载，编译运行后，通过Trace图可以看到，动画首帧的耗时是12ms。相较于优化前的代码，不再是首帧占据大量的时间，而是将耗时分摊到了后面的动画帧中。当数据量更大时，可以将数据进行更多次拆分，将不会直接出现在屏幕上的数据放到第二帧或者第三帧中进行加载，降低首帧的响应时延。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151049.38155426540629659757534641421164:50001231000000:2800:3040DC37F361ED656AB9BF6F87FB317EA425372E4FF07BDCD1CABCB2B475FB0C.png)
对使用分帧前后进行分析，得到的数据如下表所示：
| 使用分帧  | 使用分帧前  | 使用分帧后  |
| --- | --- | --- |
| 首帧耗时  | 21ms  | 12ms  |
| 第二帧耗时  | 4ms  | 13ms  |
使用分帧
使用分帧前
使用分帧后
首帧耗时
21ms
12ms
第二帧耗时
4ms
13ms
在使用分帧后动画首帧与第二帧分别是12ms和13ms，如果依然没有达到期望的帧率，可以继续将数据拆分。
滑动场景
在日历应用中，需要在一个List里面加载每个月的全部天数，包括公历和农历日期，这样在一个ItemView复用组件中就会有很多数据加载，当列表滑动的时候，通过组件复用的aboutToReuse()接口设置新的数据，就会导致ItemView内所有组件一起刷新，可能会引起掉帧卡顿现象。
解决思路
由于一次性加载大量数据、刷新大量组件会导致卡顿丢帧，那么减少一次性加载的数据量就是一种解决方法。但是由于业务需求，需要加载的数据总量和绘制的组件数量是不能减少的，那么就可以考虑采用分帧渲染。
滑动场景分帧：滑动日历列表，复用ItemView组件，更新每月天数包含阴历和阳历，一次更新所有天数，数据量大，可以使用分帧策略，将每月日期数据进行拆分，一帧只更新5天数据，在使用ForEach循环每月的天数时，因为一次只更新5天数据，ForEach会根据key值更新对应的天数，从而避免在一帧中更新所有数据。该方法优点是可以将数据拆分在多帧中加载，缺点是操作比较麻烦，需要开发者根据实际情况计算一帧中加载的数据量，维护较为复杂。
滑动场景效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151049.97613222811370538326986651685131:50001231000000:2800:F9EA21B7BEFA29C4079839F6EECCD87F618858F906321E8C150484C7405B542B.gif)
分帧前后示意图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151049.84266244470447470496426683932171:50001231000000:2800:A73DE408AD3BC6CA20F450103FEE45CC21850D9851361863F1CBB5373B9B609D.png)
常规代码
通常情况下，会在aboutToReuse()中设置新的数据，并一次性绘制所有的组件。
在上面的代码中，通过组件复用，在ItemView的aboutToReuse()接口中，将一个月的数据直接设置到状态变量monthItem中，这样下面的Flex就会收到状态变量变更的消息通知，从而刷新组件中的数据。编译运行后，进入日历页面，然后滑动列表到最底端，分析下图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151049.98606605075488130777006836996535:50001231000000:2800:1ED61FA44CE0FE2103EEFC34E0AB271129C9252B6EF983F1B32A81B31ABE648B.png)
优化代码
通过displaySync中的帧回调方法，将数据拆分到每一帧中进行加载和绘制，只需要在帧回调中修改自定义子组件ItemView中加载数据的方式。
首先，需要在ItemView中第一次使用时创建displaySync对象，设置期望帧率，添加帧回调的监听，然后进行启动。
然后，在监听中添加更新数据的代码。这里将每个月的数据更新拆分开来，第一步用来更新月份数据和计算总的执行步骤，最后一步将计数数据清空， 方便下一次数据的写入，其余需要执行步骤的多少根据每次加载数据量会有所改变。
最后，在aboutToReuse接口中将数据放入数组中，用于帧回调中开始执行数据更新。
分析下面trace图，在211618中，开始调用aboutToReuse接口，由于只是将数据放入一个temp数组中，并没有更新复用组件中的数据，所以这一帧并没有发生延长现象。
在211619中开始逐步更新复用组件中的数据，在第一帧中更新月份和周的数据，但是由于前一帧（211618）中并没有更新当前复用组件中的数据，所以在211619中并不需要绘制组件，所以此帧耗时依旧很短。
结合代码可以看到，在211620中放入了5天的日期数据，由于前一帧（211619）只是设置了2条数据，并且只有1条会更新，所以这一帧的绘制时间也不会超时。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151049.14197470274928492005316546673642:50001231000000:2800:431E93A933D427CF76E80D976930364F8414FF741134AD47FBA8D4CB502D0CD3.png)
和前一帧（211620）一样，此帧（211621）中更新了5天的日期数据，并且会重新测量上一帧中更新数据的5个Text组件尺寸（箭头1），而其余的组件由于数据并没有变动，所以测量被略过了（箭头2）。
后面的帧是类似的，每次只会放入5天的数据，并且更新上一帧中设置的数据所关联的Text组件。由于每次更新的组件数量较少，每帧基本上都能在规定的时间内（1秒120帧，即8ms一帧）绘制完成，所以延长帧就会较少。这样不论列表中数据多还是少，都不会引起掉帧现象的发生。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151049.15890594482223975648545450449607:50001231000000:2800:635AB3179157C720495723368899BD6D7E6A96B8CB3DE83E61D5B3C7112B057D.png)
| 使用分帧  | 使用分帧前  | 使用分帧后  |
| --- | --- | --- |
| 渲染帧率  | 113fps  | 120fps  |
| 丢帧率  | 5.8%  | 0%  |
使用分帧
使用分帧前
使用分帧后
渲染帧率
113fps
120fps
丢帧率
5.8%
0%
在使用displaySync时不建议将ExpectedFrameRateRange中的expected、min、max都设置为120，否则会干扰系统的可变帧率机制运行，产生不必要的负载，进而影响到整机的性能和功耗，详情请参考场景策略建议。
总结
通过上面的示例代码和优化过程，可以看到在列表中使用组件复用时，一次性全部加载时可能会引起掉帧。虽然在数据量较少时，单帧绘制的延长并不会引起掉帧，但是数据量变多后，这种延长帧的影响就会比较明显。根据自己实际业务需求合理使用分帧策略进行数据拆分后，可以有效减少延长帧的发生，从而减少掉帧引起的性能问题。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-redundancy-refresh-guide
爬取时间: 2025-05-01 09:31:32
来源: Huawei Developer
简介
自定义组件中的变量被状态装饰器（@State，@Prop等）装饰后成为状态变量，而状态变量的改变会引起使用该变量的UI组件渲染刷新。状态变量的不合理使用可能会带来冗余刷新等性能问题。开发者可以使用状态变量组件定位工具（hidumper）获取状态管理相关信息，例如自定义组件拥有的状态变量、状态变量的同步对象和关联组件等，了解状态变量影响UI的范围，写出高性能应用代码。
下面通过一个点击按钮更改状态变量引起组件刷新的场景示例，结合hidumper工具，介绍状态变量使用范围不当，导致UI冗余刷新的问题定位。
示例代码
在以下代码中，创建了自定义组件ComponentA、SpecialImage，每个组件都拥有一些状态变量和UI组件。组件ComponentA中存在Move和Scale两个按钮，在按钮的点击回调中改变状态变量的值刷新相应的组件。
运行上述示例并分别点击按钮，可以看到点击Move按钮和Scale按钮时组件SpecialImage都出现了刷新，运行效果图如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151049.13352197932936070321801032407646:50001231000000:2800:B519A4942A77E724C61B1B19EC4C80038177F2D58104573A20FCB33E8049F14B.gif)
点击Move按钮的时候SpecialImage组件却发生了旋转动画，这就造成了冗余刷新。
问题定位
下面通过这个示例代码结合hidumper工具来介绍冗余刷新的问题定位。
1. 首先在设备上打开应用，进入ComponentA组件所在的页面。
2. 使用以下命令获取示例应用的窗口Id。当前运行的示例应用包名为performancelibrary，可以在输出结果中找到对应窗口名performancelibrary0的WinId，即为应用的窗口Id。或者当应用正处于前台运行时，Focus window的值就是应用的窗口Id。此处示例应用的窗口Id为11，后面的流程中使用的命令都需要指定窗口Id。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151050.71870601474626435812473328717270:50001231000000:2800:EA1B1B4331278FF2F6322E555D7E5FAB93D1A3B3012CCCCF0B06698D58BE8FAB.png)
3. 基于上一步获取的窗口Id 11，使用-viewHierarchy命令携带-r 参数递归打印应用的自定义组件树。
打印应用的自定义组件树结果如下：
从结果中找到目标组件ComponentA，后面括号中的内容即为组件ComponentA的节点Id 70。
4. 使用命令-stateVariables携带参数-viewId（参数的值为ComponentA的节点Id）获取自定义组件ComponentA中的状态变量信息。
打印组件ComponentA的状态变量信息如下：
结果显示ComponentA拥有@Link/@Consume类型的状态变量uiStyle。每条状态变量的详细信息都包含状态变量的所属组件、同步对象和关联组件。
5. 以状态变量uiStyle为例。
① Sync peers表示uiStyle在自定义组件SpecialImage中存在@Link/@Consume类型的状态变量specialImageUiStyle订阅数据变化。
② Dependent components表示在ComponentA组件中存在组件Stack[75]和Image[77]使用了状态变量uiStyle，关联组件的数量为2。
所以当uiStyle变化时，影响的组件范围为自定义组件SpecialImage以及系统组件Stack[75]和Image[77]。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151050.30703811809688662441044606847625:50001231000000:2800:07FBC08D94420FE2562D1BBC6647592AA92D5E3821817D8FAE5F0FF1687DF2C9.png)
示例中组件SpecialImage仅使用了uiStyle传递到specialImageUiStyle中的属性scaleX、scaleY。但点击Move按钮修改uiStyle中的属性translateY时，引起的uiStyle变化也会导致组件SpecialImage的刷新。所以，可以将uiStyle中的属性scaleX、scaleY提取到状态变量scaleStyle中，属性translateX和translateY提取到状态变量translateStyle中，仅传递scaleStyle给组件SpecialImage，避免不必要的刷新。
由于提取后存在Class的嵌套，因此需要使用@Observed/@ObjectLink装饰器装饰相应的Class和状态变量。修改后的部分代码如下：
修改后的示例运行效果图如下，只有点击Scale按钮时SpecialImage产生刷新现象，点击Move按钮时SpecialImage不会刷新。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151050.71952527963738740568131495152229:50001231000000:2800:EEC077146C58B6AEE3E5367FF61E1D03A46553AF053237F8EC80B53D5718C33B.gif)
可以使用上文步骤再次获取ComponentA组件的状态变量信息如下，可以看到ComponentA中状态变量scaleStyle影响组件SpecialImage[74]和Image[78]，状态变量translateStyle影响组件Stack[76]，translateStyle的变化不会再导致SpecialImage的刷新。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-ui-component-encapsulation
爬取时间: 2025-05-01 09:31:46
来源: Huawei Developer
概述
在应用开发中，通常需要对ArkUI组件进行封装以便业务复用，主要包含以下几种ArkUI组件封装复用的典型业务场景：
本文将针对以上业务场景，具体说明各场景及其实现方案。
公用组件封装
场景描述
在应用开发过程中，不同的业务场景可能需要使用相同功能或样式的ArkUI组件。例如，登录页面登录按钮和购物页面结算按钮可能样式相同。该场景常用方法是抽取相同样式的逻辑部分，并将其封装成一个自定义组件到公共组件库中。在业务场景开发时，统一从公共组件库获取封装好的公用组件。
以Button组件为例，当多处业务场景需要使用相同样式的Button组件时，将通用逻辑封装成一个MyButton自定义组件，并在通用逻辑中定制了公共的fontSize和fontColor属性。当需要把MyButton组件以Button扩展组件的形式集成到公共组件库中，提供给外部其他团队使用时，为了使它具备Button的所有基础能力并支持以链式调用的方式使用Button组件的属性接口，需要在MyButton组件内穷举所有的Button属性。自定义组件的代码如下：
在使用MyButton组件时，若需修改组件显示内容text和点击动画效果stateEffect时（其他Button独有的属性用法相同），需要以参数的形式传入：
当前方案的缺点如下：
实现原理
为解决上述方案缺点，ArkTS为每个系统组件提供了attributeModifier属性方法。该方法将组件属性设置分离到系统提供的AttributeModifier接口实现类实例中，通过自定义Class类实现AttributeModifier接口对系统组件属性进行扩展。通过AttributeModifier实现公用组件有如下两种方案：
方案一：提供方对外提供封装好的自定义组件。
以封装系统组件Button为例，该方案实现步骤如下:
方案二：提供方对外提供AttributeModifier接口的实现类。
```typescript
// src/main/ets/pages/CommonComponent.ets
@Component
struct Index {
modifier = new MyButtonModifier()
.stateEffect(true)
.type(ButtonType.Capsule)
build() {
Row() {
Button('Capsule Button')
.attributeModifier(this.modifier)
}
.width('100%')
.height('100%')
}
}
```
对比两种方案，若需要抽取复用的公用组件为单一类型，如Button或Text，推荐使用方案二。若需要抽取复用的组件为多个系统组件的组合，如组件中包含Image组件和Text组件，则推荐使用方案一。
开发流程
若需抽取一个包含系统组件Image组件和Text组件的公用组件，效果展示如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151050.13617370711835285393859510439105:50001231000000:2800:56AA393B610C147639638F3D4A7A7FE6087579AC4D1298C1AE1070B0D406EBC1.png)
针对固定组合的组件封装采用方案一，实现上述效果的示例代码如下：
弹窗组件封装
场景描述
在应用开发中，通常会遇到自定义弹窗的场景，这些业务场景可能需要实现自定义弹窗的结构和样式。这时提供方可以封装一个传入自定义构建函数的工具类，将类对外导出。使用方可以引入该类，将自定义弹窗结构的@Builder函数作为参数传给封装好的静态类函数中，实现自定义弹窗。
实现原理
通过使用UIContext中获取到的PromptAction对象来实现自定义弹窗工具类的封装。首先通过UIContext实例中的getPromptAction函数获取到promptAction对象，然后通过创建ComponentContent定义自定义弹窗的内容，将自定义弹窗内容作为参数传入promptAction对象的openCustomDialog函数中。使用方通过PromptAction对象封装的工具类接口打开弹窗就会显示自定义弹窗的内容，从而实现自定义的弹窗结构与样式。
开发流程
以使用方点击按钮后展示自定义弹窗场景为例，若需实现下图效果，基于promptAction封装弹窗工具类和使用步骤如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151050.27481673016085829755967376269491:50001231000000:2800:211E1E0F94E8EBC56556D9EC3552477F072B5BA89FF5625EE50F9F334CDDDE13.gif)
1. 使用方通过全局@Builder封装弹窗结构。
2. 提供方通过promptAction对象封装弹窗工具类可以分为三步：
```typescript
// src/main/ets/model/PopViewUtil.ets
static closeDialog(type: PopViewShowType): void {
let uiContext = AppStorage.get<UIContext>('uiContext');
if (uiContext) {
let prompt = uiContext.getPromptAction();
let sameTypeList = PopViewUtils.shareInstance().infoList.filter((model) => {
return model.popType === type;
})
let info = sameTypeList[sameTypeList.length - 1];
if (info.com) {
PopViewUtils.shareInstance().infoList = PopViewUtils.shareInstance().infoList.filter((model) => {
return model.com !== info.com;
})
prompt.closeCustomDialog(info.com);
}
}
}
```
3.使用方调用弹窗工具类传入封装好的弹窗结构实现自定义弹窗
组件工厂类封装
场景描述
如下图所示，团队A实现了一个组件工厂类并供外部使用，该类封装了多个组件。业务团队B在不同业务需求开发场景下，希望通过组件名从组件工厂类实例获取对应的组件。例如，B团队向工厂实例中里传入组件名参数"Radio"，可以获取到对应的Radio组件模板。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151050.32574656750764062816997895298173:50001231000000:2800:2123D2792E81E68194AD822ADA4E57A160CE35F2C1CE06EB395DA7C950D5FF59.png)
实现原理
对于该场景，考虑使用Map结构将封装的各个组件存入，使用时通过Map的key值获取相应组件。对于单个组件的传递，目前系统提供了@Builder装饰器，该装饰器使得装饰后的函数遵循自定义组件build()函数语法规则。当@Builder装饰的方法作为参数传递使用时，可以将@Builder方法传入wrapBuilder函数中实现组件的传递使用。通过组件工厂的封装和传递，避免了在调用方的build()函数内使用多个if else展示不同组件的写法，实现了简洁的组件封装形式。
开发流程
组件工厂以Map结构存储各种组件，其中key为组件名，value为WrappedBuilder对象。该对象支持赋值和传递，是系统提供的wrapBuilder函数的返回值。组件工厂场景的实现主要包含以下步骤：
```typescript
// src/main/ets/view/FactoryMap.ets
// 定义组件工厂Map
let factoryMap: Map<string, object> = new Map();
// 将需要工厂化的组件存入到组件工厂中
factoryMap.set('Radio', wrapBuilder(myRadio));
factoryMap.set('Checkbox', wrapBuilder(myCheckbox));
// 导出组件工厂
export { factoryMap };
```
使用wrapBuilder方法有以下限制：
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-ui-dynamic-operations
爬取时间: 2025-05-01 09:31:59
来源: Huawei Developer
概述
为了解决页面、组件加载缓慢的问题，ArkUI框架提供了动态操作以实现组件预创建，并允许应用在运行时根据实际需要加载渲染相应的组件。动态操作包含动态创建组件（动态添加组件）、动态卸载组件（动态删除组件）等相关操作。动态创建组件指在非build生命周期中进行组件创建，即在build生命周期前提前创建组件。通过动态创建组件，不但可以节省组件创建的时间，提升用户体验，还可以将独立的逻辑进行封装，有助于应用模块化开发。动态卸载组件是对动态创建的组件进行卸载、删除。
组件预创建原理
在声明式范式中，组件仅在build环节中被创建，开发者无法在其他生命周期阶段进行组件的创建，从而引起页面加载慢等问题。与声明式范式不同，ArkUI框架提供的UI动态操作支持组件的预创建。组件预创建可以满足开发者在非build生命周期中进行组件创建，创建后的组件可以进行属性设置、布局计算等操作。之后在页面加载时进行使用，可以极大提升页面响应速度。
如下图所示，利用组件预创建机制，可以利用动画执行过程空闲时间进行组件预创建和属性设置。在动画结束后，再进行属性和布局的更新，节省了组件创建的时间，从而加快了页面渲染。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151050.63520554140094937082137922223597:50001231000000:2800:DD22A015CE7F006247561F07D62B6F4B7C5C2DDE84D68F2B1E9A5DCBA69348E2.jpg)
FrameNode自定义节点在动态布局场景下的优势
减少自定义组件创建开销
在采用声明式开发范式中，若使用ArkUI的自定义组件对节点树中的每个节点进行定义，往往会遇到节点创建效率低下的问题。
这主要是因为每个节点在ArkTS引擎中都需要分配内存空间来存储应用程序的自定义组件和状态变量。在节点创建过程中，还必须执行组件ID、组件闭包以及状态变量之间的依赖关系收集等操作。
相比之下，使用ArkUI的FrameNode，可以避免创建自定义组件对象和状态变量对象，无需进行依赖收集，从而显著提升组件创建的速度。
组件更新更快
在动态布局类框架的更新场景中，通常存在一个由树形数据结构ViewModelA创建的UI组件树TreeA。当需要使用新的数据结构ViewModelB来更新TreeA时，尽管声明式开发范式可以实现数据驱动的自动更新，但这一过程中却伴随着大量的diff操作，如下图所示。对于ArkTS引擎而言，在对一个复杂组件树（深度超过30层，包含100至200个组件）执行diff算法时，几乎无法在120Hz的刷新率下保持满帧运行。然而，使用ArkUI的FrameNode扩展，框架能够自主掌控更新流程，实现高效的按需剪枝。特别是针对那些仅服务于少数特定业务的动态布局框架，利用这一扩展，可以实现快速的更新操作。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151050.31540633135853865862426607627701:50001231000000:2800:FD0EA483BA382632E622BED6D8209D18ECC06A862E6C434A54DF3C54A85FE62F.png)
直接操作组件树
使用声明式开发范式还存在组件树结构更新操作困难的痛点，比如将组件树中的一个子树从当前子节点完整移到另一个子节点，使用声明式开发范式无法直接调整组件实例的结构关系，只能通过重新渲染整棵组件树的方式实现上述操作。而使用ArkUI的FrameNode扩展，则可以通过操作FrameNode来很方便的操控该子树，将其移植到另一个节点，这样只会进行局部渲染刷新，性能更优。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151051.20104062062726507569446765129817:50001231000000:2800:67B96BF610812C4752F3426DDEC07DFFEB39B6CAA285C1FB594017B69E15CEDF.png)
组件动态添加、更新和删除：
动态添加组件
动态添加组件包括以下步骤：
-  首先，准备好需要挂载的节点，代码如下所示。
```typescript
import { BuilderNode, FrameNode, NodeController } from '@kit.ArkUI';
class Params {
text: string = 'Hello World';
constructor(text: string) {
this.text = text;
}
}
@Builder
function buildText(params: Params) {
Column() {
Text(params.text)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.margin({bottom: 36})
}
}
......
```
-  NodeController为抽象类，需要继承并实现NodeController，代码如下所示。
-  首先，使用构造函数创建BuilderNode实例。创建BuilderNode对象的时候必须要传入对应的UIContext对象。若BuilderNode作为RenderNode的子节点存在，要求设置RenderOptions的selfIdealSize属性。 然后，使用BuilderNode的build方法，构建组件树。方法build()需要传入两个参数，第一个参数为通过wrapBuilder()封装的全局@Builder方法。第二个参数为对应的@Builder方法所需的参数对象。若@Builder方法不带参数或者存在默认参数，则build()的第二个参数可以不设置。
-  显示自定义节点依赖声明式渲染容器NodeContainer以及对应的控制类NodeController。 NodeController的makeNode方法返回的节点会显示在对应的NodeContainer中。由于makeNode需要返回的为一个FrameNode，因此如果预期显示BuilderNode的时候需要调用对应的BuilderNode的getFrameNode的方法，获取其根节点，详细代码如上TextNodeController中所示。 然后，在页面内新增声明式渲染容器NodeContainer，创建工具类NodeController。通过NodeController将MakeNode中返回的节点在声明式渲染容器中进行显示。
-  更新自定义节点，可参考BuilderNode的update方法。
动态删除组件
通过条件控制语句可以将NodeContainer节点进行移除或者显示。如示例代码，将this.isShow更改为false则将节点从界面上移除。
```typescript
// ...
@Entry
@Component
struct Index {
@State message: string = "hello";
@State isShow: boolean = true;
private textNodeController: TextNodeController = new TextNodeController(this.message);
build() {
Row() {
Column() {
if (this.isShow) {
NodeContainer(this.textNodeController)
.width('100%')
.height(100)
.backgroundColor('#FFF0F0F0')
}
Button('isShow')
.onClick(() => {
this.isShow = false;
})
}
.width('100%')
.height('100%')
}
.height('100%')
}
}
```
动态更新组件
动态将NodeContainer上的节点替换，依赖于NodeController的makeNode和rebuild方法。rebuild方法会触发makeNode的回调，刷新NodeContainer上显示的节点；makeNode方法返回的为null，则移除NodeContainer下挂载的节点。
开发者可以根据实际情况创建新的节点，参考示例代码如下所示：
```typescript
// ...
@Entry
@Component
struct Index {
@State message: string = "hello";
@State isShow: boolean = true;
private textNodeController: TextNodeController = new TextNodeController(this.message);
// private count = 0;
build() {
Row() {
Column() {
if (this.isShow) {
NodeContainer(this.textNodeController)
.width('100%')
.height(100)
.backgroundColor('#FFF0F0F0')
}
Button('replaceNode')
.onClick(() => {
this.textNodeController.replaceBuilderNode(this.buildNewNode());
})
}
.width('100%')
.height('100%')
}
.height('100%')
}
buildNewNode(): BuilderNode<[Params]> {
let uiContext: UIContext = this.getUIContext();
let message = 'newNode';
let textNode = new BuilderNode<[Params]>(uiContext);
textNode.build(wrapBuilder<[Params]>(buildText), new Params(message))
return textNode;
}
}
```
NodeController生命周期
NodeController用于控制和反馈对应的NodeContainer上的节点的行为，需要与NodeContainer一起使用。下面，对其常用生命周期函数进行说明。
列表流广告组件实践案例
场景描述
App广告有一种场景是列表流广告，即在应用的列表流中穿插展示广告条目，旨在将广告无缝融入用户的浏览体验中，使其看起来像是正常的内容（广告条目需要加标记区别展示），从而吸引用户的注意力并提高参与度，例如新闻列表中的广告条目、商品列表中的广告条目等。
这种广告的布局和内容在开发阶段不确定（可能是图文、视频等形式中的一种），其通常是在运行阶段，依赖服务器下发的数据进行逻辑映射后，再执行布局的构建、内容的加载显示。所以在实际的开发中，应用需要使用动态创建组件的能力去实现该列表流广告。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151051.17219232971448260390126012653681:50001231000000:2800:135FCA1D45599261878F1CD55A5DFBE972337522BE68078BA396EC45090D0F09.png)
实现方案
开发步骤
1.  示例代码中用CardData(true, id)表示广告数据对象。
2.
3.
```typescript
// entry/src/main/ets/components/AdController.ets
// Customizing the Interface for Obtaining the NodeController
export const getAdNodeController = (uiContext: UIContext, id: string): AdNodeController | undefined => {
let baseNode = new AdNodeController();
nodeMap.set(id, baseNode);
baseNode.initAd(uiContext, id, queryAdById(id));
return nodeMap.get(id);
}
function queryAdById(id: string): string {
if (Number(id) % 2 === 0) {
return 'pic';
} else {
return 'video';
}
}
```
4.
5.
6.
动态生成页面实践案例
场景描述
下面使用视频首页刷新图片资源作为场景，来介绍如何使用ArkUI的FrameNode来实现动态布局。
ArkUI的声明式扩展使用
一个简化的动态布局类框架的DSL一般会使用JSON、XML等数据交换格式来描述UI，下面使用JSON为例进行说明。本案例相关核心字段含义如下表所示：
| 标签  | 含义  |
| --- | --- |
| type  | 描述UI组件的类型，通常与原生组件存在一一对应的关系，也可能是封装的某种组件  |
| content  | 文本，图片类组件的内容  |
| css  | 描述UI组件的布局特性  |
| children  | 当前组件的子组件  |
标签
含义
type
描述UI组件的类型，通常与原生组件存在一一对应的关系，也可能是封装的某种组件
content
文本，图片类组件的内容
css
描述UI组件的布局特性
children
当前组件的子组件
性能对比
以场景示例中的两种方案实现，通过DevEco Studio的Profile工具抓取Trace进行性能分析比对。
1.
2.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151052.64973728575371285884836070222972:50001231000000:2800:60E3529B44A54381F126E50069BEC837319DC8C1D87134001982ABBE9195F243.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151052.11129053080634039678449077907650:50001231000000:2800:F934843475EC6A34803C210E8789565DAB19A3DA3774FFEA66B1F38D2DC4B404.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-landscape-and-portrait-development
爬取时间: 2025-05-01 09:32:13
来源: Huawei Developer
概述
横竖屏切换功能即实现应用内既支持竖屏显示也支持横屏显示的效果。对于应用内不同页面显示方向不同的情况，需要在应用逻辑中，动态修改窗口方向，来实现该效果，例如包含视频播放功能的应用，首页内容是采用竖屏方式，而视频详情页则采用横屏方式展示。
本文主要介绍横竖屏功能的开发过程中需要关注的内容，包括如下部分：
窗口旋转说明
目前在HarmonyOS系统中，窗口的旋转形态包括以下四种，窗口的状态对应真机实际状态如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151052.11871582192345610075856951894325:50001231000000:2800:22840D4166F5D0C37D38642E72B773D681F6E6999E74AB225275AB49C738A557.png)
有两种设置窗口旋转策略的方式：
一、通过module.json5文件中“orientation”字段进行设置
二、在代码中通过调用窗口window的setPreferredOrientation方法进行设置
这两种方式触发设置旋转的时机不同，总的来说，module.json5文件中的字段在窗口启动时就会生效，对于应用启动时就需要设置横屏或者竖屏的应用，需要进行配置。而setPreferredOrientation是在调用该方法时进行窗口方向的设置，用于在应用启动之后，还需要改变显示方向的场景。
配置module.json5的orientation字段
此字段配置的是应用启动时的窗口显示状态，对于开屏时就需要以默认的横屏或者竖屏方式显示，需要在此字段进行相应的配置：
其支持的参数可以参考module.json5配置项中orientation字段相关配置的orientation字段说明：
根据应用默认的旋转行为进行相应的配置：
-  一、仅支持横屏，建议配置landscape为默认旋转策略。 二、支持在横屏和反向横屏中切换，建议设置为auto_rotation_landscape。
对于需要通过控制中心进行旋转锁定控制的，可以选择字段后方带有restricted字段的旋转策略，此字段表示旋转行为受到控制中心按钮控制，开关打开情况下，不随设备方向旋转，关闭情况下，则会发生跟随设备旋转。
以如下文件管理应用为例，在系统关闭了旋转锁定后，应用的页面都会随着手机旋转而发生展示上的切换，而打开时则不会发生旋转行为，此时就需要配置为auto_rotation_restricted。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151052.44327677599122257104330088264475:50001231000000:2800:FDE71ECCF70284A4153F60B46A6CD2A4AE173EC6AF1408D8FE414B0AF96FA06D.jpg)
调用窗口的setPreferredOrientation方法
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151052.63443723792461545361115957887216:50001231000000:2800:5594922653A44BF1DC3A25F15922D987FBAC1057FC9D48869049CDFCE434A013.png)
此类应用在进入时为竖屏，而在视频播放页面可以显示为横屏，则需要支持用户临时修改窗口方向。由于setPreferredOrientation方法调用的是窗口的显示方向，是整个应用窗口级别都发生了旋转，窗口将一直保持最后一次设置窗口方向的效果，即使发生页面跳转等行为窗口方向也不会发生变化。
视频类应用横竖屏开发
为了实现应用的横竖屏功能，我们需要从以下技术方面进行考虑：
1、设置窗口的旋转策略
2、监听屏幕的窗口变化
3、进行布局适配
设置窗口的旋转策略
首先需要对应用启动时的旋转策略进行设置，具体可以参考配置module.json5的Orientation字段，这里我们以实现了一多开发为例，满足直板机和平板设备不同的策略，设置为follow_desktop，这个字段主要解决在不同设备上默认旋转策略不同的问题。
在具体需要实现横竖屏切换的页面上，例如视频播放页面支持横屏，但是首页的内容是支持仅竖屏的，那么就需要在进入对应的页面时，采用window窗口提供的设置窗口方向的能力，通过setPreferredOrientation将窗口显示的方向修改为横屏、竖屏的状态。在使用时，需根据应用自身的旋转策略选择相应的参数，可以封装如下方法，进行旋转策略的设置。
具体如下：通过getContext拿到对应的UIAbilityContext，并通过context拿到对应的windowStage实例，然后通过windowStage.getMainWindowSync同步方法拿到对应的窗口实例win，然后调用setPreferredOrientation方法设置窗口方向。
```typescript
setOrientation(orientation: number) {
this.windowClass.setPreferredOrientation(orientation).then(() => {
console.info('setWindowOrientation: ' + orientation + ' Succeeded.');
}).catch((err: BusinessError) => {
console.info('setWindowOrientation: ' + orientation + ' Failed. Cause: ' + JSON.stringify(err));
});
}
```
以视频播放为例，不仅需要可以通过系统控制横竖屏，也支持用户在系统锁定旋转的情况下，手动设置横屏状态，即需要满足以下条件：
1、应用跟随传感器旋转。
2、受到控制中心的旋转锁定按钮控制。
3、支持用户使用应用时，在页面中临时调用设置方向能力，如点击全屏按钮进行切换。
要实现以上效果，可以使用窗口的能力设置orientation的枚举类型进行相应的旋转，由于要提供临时设置方向的能力，用户在手动点击全屏按钮时，相当于需要手动触发横竖屏切换，如果此时关闭了旋转锁定，那么窗口需要能够跟随传感器一起发生旋转，所以可以使用以下枚举中的能力，临时调用旋转，并让其后续也能支持跟随传感器。
| orientation枚举值  | 枚举数值  | 效果描述  |
| --- | --- | --- |
| USER_ROTATION_PORTRAIT  | 13  | 调用时临时旋转到竖屏，之后跟随传感器自动旋转，受控制中心的旋转开关控制，且可旋转方向受系统判定。  |
| USER_ROTATION_LANDSCAPE  | 14  | 调用时临时旋转到横屏，之后跟随传感器自动旋转，受控制中心的旋转开关控制，且可旋转方向受系统判定。  |
orientation枚举值
枚举数值
效果描述
USER_ROTATION_PORTRAIT
13
调用时临时旋转到竖屏，之后跟随传感器自动旋转，受控制中心的旋转开关控制，且可旋转方向受系统判定。
USER_ROTATION_LANDSCAPE
14
调用时临时旋转到横屏，之后跟随传感器自动旋转，受控制中心的旋转开关控制，且可旋转方向受系统判定。
然后来分析旋转方向：对于视频播放的应用，一般旋转方向不会旋转到反向竖屏（由UX需求决定），即只旋转到竖屏、横屏和反向横屏。并且用户在使用时，点击切换按钮时，根据用户习惯，一般默认是旋转到横屏状态，然后支持跟随传感器旋转到反向横屏。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151052.61772670189365390957667885124814:50001231000000:2800:80784EF745393FD09D4DE89768CF2514497196A7F702ABAE4A39A3DAA3AD3EE3.png)
在需要用户点击的地方，需要根据进入全屏和退出全屏分别执行相应的逻辑，需要使用的方向状态如下：
设置为横屏时，对应窗口方向为横屏状态：this.setOrientation(window.Orientation.USER_ROTATION_LANDSCAPE)，例如进入播放页时，进行竖屏 -> 横屏切换;
设置为竖屏时，对应窗口方向为竖屏状态：this.setOrientation(window.Orientation.USER_ROTATION_PORTRAIT)，例如在返回竖屏状态时，进行横屏 -> 竖屏切换;
需要注意的是，由于setPreferredOrientation方法调用改变的是窗口的显示方向，所以如果在进入视频播放页时，手动调用了旋转到横屏，那么在退出时也需要手动调用该接口，使窗口回到之前的竖屏状态。
监听窗口变化
由于传感器变化或者用户手动设置窗口方向时，窗口的显示会发生变化，对应窗口的尺寸也会发生改变，此时可以通过拿到窗口的宽高，并对宽高进行对比，判断当前显示是竖屏还是横屏状态，并利用该数据对布局进行适配。
监听窗口尺寸的变化可以通过window.on('windowSizeChange')进行实现。具体的措施如下，在需要进行横竖屏切换的页面进行以下窗口的监听，一般建议是在aboutToAppear中执行：
并在aboutToDisappear中取消监听：
需要注意的是，当用户手动触发setOrientation设置为横屏状态时，即使当前手机处于垂直方向，窗口的状态也是横屏方向，即如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151052.54466705542435384405067254857831:50001231000000:2800:F8F047512BACE3B2925C2AEF22EF40BD38110F48A80662FC3115FBDF2995ED74.png)
此时，窗口的宽是竖屏状态下的高，高变为竖屏状态的宽。所以在监听窗口变化时，可以通过窗口的宽高大小关系，来确定当前窗口的方向，并决定实际的横竖屏状态。
进行布局适配
对应视频播放这类应用，属于只有播放窗口需要进行横竖屏，所以只需要对视频播放的组件内容进行横屏并进入全屏，所以可以利用UI状态更新的特点，来让播窗变为全屏，将播窗的尺寸定义为@State状态，并设置到Xcomponent组件上。
将状态变量与播窗绑定。
并且在之前监听窗口变化的回调中，对XComponentWidth和XComponentHeight进行动态修改，完成窗口变化时横屏和竖屏的视频窗口布局。需要注意的是，在横屏时，视频播放的宽高应该和窗口的宽高一样，并且需要进入全屏状态。而竖屏时，视频播放的宽应该等于窗口的宽，但是高度应该是按照播窗比例乘以窗口的宽进行设置，并退出全屏状态。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151052.05217932764896980498982355718331:50001231000000:2800:99C2606751467B87510D0C1C8F99AD73F5ADEF8C307FE82B7E74DD5AAA17FF1A.png)
具体实现如下，进入视频详情页面内需要监听窗口尺寸的变化，并根据当前状态，实现对横竖屏状态的监听，根据状态变化修改对应XComponent的宽高，实现全屏或者隐藏状态栏和导航条的逻辑。
需要注意的是，对于视频全屏效果，建议采用沉浸式开发，沉浸式效果的实现，可以参考开发应用沉浸式效果。
上述代码完成的是直板机上的旋转逻辑，在进入页面时进行窗口变化的监听，需要在退出页面时关闭监听功能。另外，对于在平板下，如果旋转行为只会触发页面旋转，不触发视频播窗的全屏，需要进行特殊处理。
所以这里还需要对旋转行为进行一个限制，只有在直板机设备上才能让发生旋转时，将播窗全屏，对应平板上，部分情况下并不需要视频播窗全屏而是直接将布局进行旋转。
锁定屏幕功能
部分视频应用支持屏幕锁定功能，在全屏状态下，实现对功能按钮的隐藏，并临时锁定屏幕的旋转，避免用户误触其他操作按钮。屏幕锁定后，应用可以在横屏和反向横屏之间翻转，不可由横屏旋转为竖屏，解锁后，如果当前屏幕处于竖屏，则应该恢复到竖屏显示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151053.49493493955894399402466788372429:50001231000000:2800:8F782CB219272D6E250150BAFF23452FBCC781668D949D58B8521EAA32E23112.png)
针对上述功能可以考虑如下实现：
1、判断当前控制中心的开关状态，如果是已经锁定情况下，则不需要进行额外处理
2、锁定时设置旋转策略为AUTO_ROTATION_LANDSCAPE，即支持横屏和反向横屏旋转，不受控制中心控制
3、解锁时需要回到支持三向旋转，即支持横屏、竖屏、反向横屏，并受到控制中心控制
可以由上述推断功能实现得到如下代码：
对于需要在折叠屏状态下对旋转逻辑进行单独处理的情况，可以封装如下方法isExpandedOrHalfFolded方法，来判断当前设备是否为折叠屏展开态，处于折叠屏展开态情况下，不会触发旋转逻辑。
当要对设备控制中心状态进行监听时，可以通过setting.registerKeyObserver，监听控制中心变化，其中orientationLockState是当前设备控制中心的状态，当设备控制中心的状态为“0”时，即代表旋转功能被系统锁定，此时在处理锁定功能代码中不需要进行旋转逻辑的处理，因为在控制中心旋转开关关闭的情况下，屏幕的旋转行为会收到限制，所以首先要考虑对控制中心的旋转锁定状态进行判断，可以参考如下代码实现对设备控制中心的状态监听：
排除了当前设备后，即可以进行通过应用内锁定按钮进行逻辑判断，锁定状态下，调用setOrientation设置为Landscape，此时可以在横屏和反向横屏旋转，解锁后，恢复到三向（横屏、竖屏、反向横屏）旋转策略：
游戏类应用横屏开发
对于游戏类应用，以横屏游戏居多，此类应用不需要在应用内进行开关控制，所以只需要在module.json5配置文件中进行相应的配置即可。一般有以下几种情况：
默认仅为横屏
如果该应用默认为横屏状态，那么则需要在module.json5中的“orientation”字段进行配置为landscape。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151053.77714435054914710806294182661685:50001231000000:2800:E461B3D211BB7D9E97007A5468DAFC27A69AA462FC93994CAFD4DB89F41573B3.png)
支持横屏和反向横屏
如果应用需要根据设备方向，决定是横屏还是反向横屏，则可以对module.json5配置中“orientation”设置为auto_rotation_landscape。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151053.34739859373552403207896364896761:50001231000000:2800:72AEDE24CDCD972D571A429C45CFBF06159091FA0E8E3248C05AA5C78E8E1362.png)
如果需要跟随控制中心的旋转锁定，则可以选择配置为"auto_rotation_landscape_restricted"
支持竖屏切换横屏
此类适用于一些游戏大厅等应用，由于游戏大厅内，主页可能为竖屏，部分应用为横屏。那么从竖屏进入横屏时，则需要调用设置窗口旋转方法进行窗口控制，具体案例可以参考视频播放的横竖屏切换。
性能优化
由于在窗口旋转时，屏幕的尺寸会发生变化，界面会发生重新布局，为了提高横竖屏切换时的流畅度，需要进行相应的性能优化。
使用自定义组件冻结
旋转时，由于整窗一起旋转，会导致页面重新布局，但是实际上需要展示的可能只有播放内容，对于其他的组件可以使用自定义组件冻结功能，避免由于旋转导致的UI更新操作。例如视频播放底下的详情内容，可能是单独的组件。
对图片使用autoResize
如果当前旋转页面存在一些图片，未经合理的裁剪，图片过大，可以对图片设置autoResize属性，使图片裁剪到合适的大小进行绘制。该属性的作用是将组件显示区域作为绘制的图源尺寸，可以减少内存占用，例如原图是1920*1080，但是显示区域是200*100，则在解码时会降低采样编码到200*100尺寸。
排查一些耗时操作
排查当前页面是否存在一些冗余的OnAreaChange事件、blur模糊或者一些线性变化linearGradient的属性，这些都比较耗时，可以根据是否必须使用来决定是否进行优化。
其他常见问题
Tabs栏中的视频横屏播放，无法隐藏Tabs栏
对于首页中有部分视频可以直接播放，并且不会跳转至详情页播放的，需要支持直接在首页发生旋转，当前可以通过设置XComponent的宽高实现，但是会发现即使全屏后，Tabs栏并不会消失。而是会一起发生旋转并存在于页面上。解决方案如下：
进入全屏时，隐藏Tabs，退出全屏时，展示Tabs栏。
如何解决直板机和平板上默认旋转行为不一致的问题?
对于部分应用，在直板手机上默认是采用竖屏显示的策略，但是在平板或者折叠屏上，是需要支持自动旋转的，如果在Ability的生命周期中调用setPreferredOrientation，可能会出现在应用启动时，出现旋转动画的情况，所以可以将module.json5文件中的“orientation”字段设置为“follow_desktop”。
通过调用window.getLastWindow的方式获取窗口实例出现延迟，如何解决？
由于getLastWindow底层原因，需要经过查找获取实例，一定程度上会有性能损耗，可能会出现已经发生横屏或者竖屏切换的情况下，状态栏还没切换的情况。对此类场景的同步要求较高情况下，可以使用windowStage.getMainWindowSync的同步方式获取窗口实例。
自动旋转和旋转锁定按钮的关系是什么？与Orientation字段的关系如何判断？
控制中心的旋转开关控制的是当前是否可以跟随屏幕旋转,“旋转锁定”高亮状态是锁定，不可旋转。“旋转锁定”灰色是解锁状态，可以旋转。对于希望跟随控制中心的旋转开关的行为，可以选择带RESTRICTED后缀字段的旋转方式。
例如想实现跟随控制中心的自动旋转，如果想旋转到横屏，竖屏，反向横屏，反向竖屏。则可以设置为AUTO_ROTATION_RESTRICTED。
如果不想跟随控制中心的控制开关，那么只需要设置为AUTO_ROTATION，此时应用的旋转不受到控制中心的锁定控制。其他的旋转方式同理。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-custome-dialog-development-practice
爬取时间: 2025-05-01 09:32:28
来源: Huawei Developer
概述
弹窗是应用开发需要实现的基础功能，通常用来展示用户当前需要或用户必须关注的信息或操作，可用于广告、中奖、警告、软件更新等与用户交互响应的操作。在应用开发中，经常需要实现自定义UI和功能要求，系统弹窗往往无法满足需求，此时就需要使用到自定义弹窗。
自定义弹窗选型
合理选择不同的系统能力实现弹窗，有利于提升应用开发效率，实现更好的功能需求，因此了解自定义弹窗的选型和差异非常重要。目前在HarmonyOS中实现自定义弹窗有以下方式:
不同弹窗在使用上存在其局限性，详情可以参考如下表格中的能力支持情况:
| 场景描述  | ArkUI自定义弹窗  | Navigation  | 应用子窗口  |
| --- | --- | --- | --- |
| @CustomDialog  | promptAction  | bindsheet  | UIContext PromptAction  | UIContext OverlayManager  | NavDestination Dialog  | windowStage.createSubWindowWithOptions  |
| 页面解耦  | ×  | ×  | ×  | √  | √  | √  | √  |
| 路由解耦  | √  | √  | √  | √  | √  | ×  | √  |
| 事件分发到页面  | ×  | ×  | ×  | ×  | √  | √  | ×  |
| 切换页面弹窗不消失  | ×  | ×  | √  | √  | ×  | √  | √  |
| 弹窗侧滑拦截/响应  | √  | √  | √  | √  | ×  | √  | √  |
| 弹窗蒙层  | √  | √  | √  | √  | √  | √  | ×  |
| 弹窗样式自定义（背景、圆角等）  | √  | √  | √  | √  | √  | √  | ⍻ (不支持圆角)  |
| 自定义弹窗显示 和退出动画  | √  | √  | ×  | √  | ⍻ (默认不支持动画，可通过自定义动画的方式配置）  | ⍻ (默认不支持动画，可通过自定义动画的方式配置）  | ×  |
| 键盘避让模式选择  | √  | √  | ×  | √  | ⍻ (结合窗口设置)  | ⍻ (结合窗口设置)  | √  |
场景描述
ArkUI自定义弹窗
Navigation
应用子窗口
@CustomDialog
promptAction
bindsheet
UIContext PromptAction
UIContext OverlayManager
NavDestination Dialog
windowStage.createSubWindowWithOptions
页面解耦
×
×
×
√
√
√
√
路由解耦
√
√
√
√
√
×
√
事件分发到页面
×
×
×
×
√
√
×
切换页面弹窗不消失
×
×
√
√
×
√
√
弹窗侧滑拦截/响应
√
√
√
√
×
√
√
弹窗蒙层
√
√
√
√
√
√
×
弹窗样式自定义（背景、圆角等）
√
√
√
√
√
√
⍻ (不支持圆角)
自定义弹窗显示
和退出动画
√
√
×
√
⍻ (默认不支持动画，可通过自定义动画的方式配置）
⍻ (默认不支持动画，可通过自定义动画的方式配置）
×
键盘避让模式选择
√
√
×
√
⍻ (结合窗口设置)
⍻ (结合窗口设置)
√
下面根据常见开发场景，选用对应弹窗的实现方案。
常见场景问题解决方案
了解了自定义弹窗的对比和使用区别后，接下来，我们通过场景下几个常见的问题，来介绍如何选择合适的自定义弹窗。
与页面解耦的全局弹窗
在应用开发的过程中，开发者要实现在不关联页面的情况下进行弹窗，此时需要对弹窗进行封装。
典型场景
实现思路
可以使用UIContext.getPromptAction.openCustomDialog的方式，创建并弹出对应的自定义弹窗，支持弹窗和页面解耦。
示例代码
效果演示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151053.00512855642429244195790502311158:50001231000000:2800:8F46AA08B5D8EEE0ADF431EF1EED9987501D81EE7F66F525411EE78CB1D10F24.gif)
拦截物理返回按钮、手势滑动关闭弹窗
用户只能通过按钮关闭弹窗，不允许使用物理返回按钮、手势滑动关闭弹窗。
典型场景
实现思路
方式一 基于UIContext.getPromptAction弹窗，使用弹窗的选项对象中的onWillDismiss交互式关闭回调函数，支持物理拦截返回。当用户执行点击遮障层关闭、左滑/右滑、三键back、键盘ESC关闭交互操作时，如果注册该回调函数，则不会立刻关闭弹窗。在回调函数中可以通过DismissReason得到关闭弹窗的操作类型，从而根据原因选择是否能关闭弹窗。
示例代码
```typescript
import { PromptAction } from '@kit.ArkUI';
import { hilog } from '@kit.PerformanceAnalysisKit';
@Component
export struct InterceptReturn01 {
private context: UIContext = this.getUIContext();
private promptAction: PromptAction = this.getUIContext().getPromptAction();
private customDialogComponentId: number = 0;
@Consume('NavPathStack') pageStack: NavPathStack;
@Builder
customDialogComponent() {
Column() {
Row() {
Text('Title')
.fontSize(20)
.fontWeight(FontWeight.Bold)
}
.width('100%')
.height(56)
.justifyContent(FlexAlign.Center)
Text('This is a dialog content.')
.fontSize(14)
Button('CONFIRM')
.fontSize(16)
.fontColor('#0A59F7')
.backgroundColor(Color.White)
.onClick(() => {
this.context.getPromptAction().closeCustomDialog(this.customDialogComponentId);
})
.width('100%')
.margin({
top: 8,
bottom: 16
})
}
.padding({
left: 24,
right: 24
})
.justifyContent(FlexAlign.Center)
.alignItems(HorizontalAlign.Center)
.backgroundColor(Color.White)
.borderRadius(32)
.margin({
left: 16,
right: 16
})
}
build() {
NavDestination() {
Column() {
Row() {
Button('OPEN')
.fontSize(16)
.width('100%')
.borderRadius(20)
.margin({ bottom: 16 })
.backgroundColor('#0A59F7')
.onClick(() => {
this.promptAction.openCustomDialog({
builder: () => {
this.customDialogComponent()
},
alignment: DialogAlignment.Center,
maskColor: 'rgba(0, 0, 0, 0.2)',
onWillDismiss: (dismissDialogAction: DismissDialogAction) => {
hilog.info(0xFF00, 'testTag', JSON.stringify(dismissDialogAction.reason));
}
}).then((dialogId: number) => {
this.customDialogComponentId = dialogId
})
})
}
.width('100%')
.alignItems(VerticalAlign.Center)
}
.width('100%')
.height('100%')
.padding({
left: 16,
right: 16
})
.justifyContent(FlexAlign.End)
}
}
}
```
效果演示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151053.75221010397429743382468997499918:50001231000000:2800:39E5B241FF53B20BBC9171AF9A0C4A30BBB3E2ECE7F0DF179D143A5A7C6AF061.gif)
方式二 可以基于Navigation自定义弹窗实现，使用NavDestination的回调函数onBackPressed，当与Navigation绑定的页面栈中存在内容时，此回调生效。当点击物理返回按钮或使用手势滑动时，触发该回调。返回值为true时，表示重写返回键逻辑，即可实现拦截。
示例代码
效果演示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151053.39732568079777377196585298679454:50001231000000:2800:8649BBF1A1FF90F8DCB258565BC3727BFC31554E062C0CEE59F527B9D3F18094.gif)
切换页面弹窗不消失
点击弹窗中的按钮或链接打开新页面，返回后自定义弹窗还在原页面上展示。
典型场景
用户首次进入应用需要进行权限配置，弹出弹窗后，点击跳转到隐私详情页面，返回后弹窗还在显示。
实现思路
NavDestinationMode.DIALOG弹窗存在于路由栈中，可以实现切换页面弹窗不消失。
示例代码
效果演示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151053.65124088809543587742276944413057:50001231000000:2800:C97BFD659182744859CC581ECAC6862F5C0EE427F1E15531487C7E28ABC8DDFE.gif)
自定义弹窗显示和退出动画
典型场景
在应用开发中，系统弹窗的显示和退出动画往往不满足需求，若要实现自定义弹窗出入动画，可以使用以下方式，例如：1）渐隐渐显的方式弹出，2）从左往右弹出，从右往左收回，3）从下往上的抽屉式弹出、关闭时从上往下收回。我们以渐隐渐显的方式为例，来介绍自定义弹窗的显示和退出动画。
实现思路
可以基于UIContext.getPromptAction弹窗实现，通过CustomDialogOptions自定义弹窗的内容，BaseDialogOptions弹窗选项transition参数可以设置弹窗显示和退出的过渡效果。
示例代码
效果演示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151053.37011784472593248779146149199874:50001231000000:2800:C1BF47FFD3B1AB20E162D55B8FBFC18DF9994C1A70B4B3E6FF68C6342B346C69.gif)
总结
本文从自定义弹窗选型对比、使用场景的角度，主要介绍了以下弹窗的使用区别：
同时对于开发者在弹窗使用中经常遇到的问题，给出详细的解决方案，帮助开发者快速选择自定义弹窗的实现方式，提升开发效率。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-gestures-practice
爬取时间: 2025-05-01 09:32:42
来源: Huawei Developer
概述
在复杂的应用界面中，多个组件嵌套时同时绑定手势事件，或者同一个组件同时绑定多个手势，都有可能导致手势事件产生冲突，达不到用户的预期效果。
本文从事件响应的机制入手，介绍手势触发的基本流程，以及如何响应手势事件，了解背后的执行原理，并用来解决冲突问题等。主要包括以下内容：
事件响应链收集
在HarmonyOS开发中，触摸事件（onTouch事件）是用户与设备交互的基础，是所有手势事件组成的基础，有Down，Move，Up，Cancel四种触摸事件的类型。手势均由触摸事件组成，例如，点击为Down+Up，滑动为Down+一系列Move+Up。
触摸事件的分发由触摸测试（TouchTest）结果决定，其结果会直接决定哪些控件的事件加入事件响应链（事件响应成员组成的链表），并最终按照响应链顺序判定是否消费。因此了解触摸事件的响应链收集过程，有助于开发者处理手势事件冲突问题。
ArkUI事件响应链收集，根据右子树（按组件布局的先后层级）优先的后序遍历流程。下面通过一个示例来介绍响应链收集的流程，示例伪代码如下：
其中A是最外层组件，B和D是A的子组件，C是B的子组件，E是D的子组件。界面效果示例以及组件树结构图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151053.00246248070978592907284338127804:50001231000000:2800:892BF6F628F30987A33FCAE691C81FFD9D9D0FEF191C39F4E5243A5B55C8157F.png)
用户触摸的动作如果发生在组件C上，事件响应链收集的流程如下，根据右子树（按组件布局的先后层级）优先的后序遍历流程，因为触摸点不在右边的树上，所以事件会从左边树的C节点开始往上传，触摸事件（onTouch事件）是冒泡事件默认会向上一直传递下去，直到被消费或者丢弃，允许多个组件同时触发。最终收集到的响应链是C->B->A。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151053.22513727234954622536113023892704:50001231000000:2800:11EFC1939DE989DFB614617845E006C1C8807AEB89A6BD0B89BB97106702DDDC.png)
用户触摸的动作如果发生在组件E上，事件响应链收集的流程如下，根据右子树优先的后序遍历流程，所以事件会从右边树的D节点开始往上传。虽然触摸点在组件D和组件B的交集上，但组件D的hitTestBehavior属性默认为HitTestMode.Default，D组件收集到事件后会阻塞兄弟节点（组件B），所以没有收集组件A的左子树，最终收集到的响应链是E->D->A。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151053.05880614958882629601075118504417:50001231000000:2800:E0D56309539BC4E92400CC3664E6BD0B0DD7A11C5118013CBFFA487534370B7B.png)
上面介绍的事件响应链是系统默认的行为，如果需要改变响应的成员，比如触摸组件E的时候，希望把事件传递给B，该怎么实现呢？开发者可以通过设置D组件的hitTestMode属性为HitTestMode.None或者HitTestMode.Transparent来实现，比如设置为HitTestMode.Transparent，那么组件D自身进行触摸测试，同时不阻塞兄弟及父组件。最终收集到的响应链是E->D->B->A。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151054.95507897129278887494558382012776:50001231000000:2800:366DC2A31FFB1F4DDBE888B2AA8E5F32CAF7B49DB2AA590B21F88A27166E38D1.png)
又例如触摸E组件的时候，只希望E响应触摸事件，不让其它组件响应触摸事件。可以通过stopPropagation来阻止事件冒泡，阻止触摸事件往上传递；也可以通过设置E组件的hitTestMode属性为HitTestMode.Block来实现，那么最终收集到的响应链成员只有组件E。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151054.30790086420870722044228432666352:50001231000000:2800:351CE4C592CD45D497E38B4C6C772822F8F78CE5CCD0D4618FF973FF6C43BBA4.png)
除了hitTestMode和stopPropagation，影响事件响应链的更多因素可以参考：触摸测试控制。
手势响应
前面根据事件响应链收集，确定了响应链成员和事件响应的顺序。然而往往在处理一些业务的时候，需要给组件/不同组件添加更多的手势和事件，比如onClick、API手势gesture 等等，那么哪个事件会得到响应呢？这就需要了解手势响应的优先级了，本节将主要介绍手势的优先级和手势的控制。
手势响应优先级
手势按是否为系统内置手势，可以分为以下两类：
除了触摸事件（onTouch事件）外的所有手势与事件，均是通过基础手势或者组合手势实现的。例如，拖拽事件是由长按手势和滑动手势组成的一个顺序手势。
在默认情况下，这些手势为非冒泡事件，当父组件和子组件绑定同类型的手势时，父子组件绑定的手势事件会发生竞争，子组件会优先识别绑定的手势。
因此，除非显式声明允许多个手势同时成功，否则同一时间只会有一个手势响应。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151054.51645402361868519603526571910373:50001231000000:2800:47B4AAB6DD5E08D5E14095053E5A02944BAEA5C87557FC54EEBF0F8D347D17F0.png)
手势响应控制
上面介绍了手势默认的优先级顺序，在父子组件嵌套时，父子组件均绑定了手势或事件，或者同一个组件同时绑定多个手势时，根据业务逻辑可能需要对手势是否需要响应、分发给谁响应、响应的顺序等做出控制。那么有哪些控制手段呢？下面列举了一些手势响应的控制方法。
1 手势绑定
绑定手势方法
设置绑定手势的方法可以实现在多层级场景下，当父组件与子组件绑定了相同的手势时，设置不同的绑定手势方法有不同的响应优先级。手势绑定支持常规手势绑定方法（gesture）、带优先级手势绑定方法（priorityGesture）、并行手势绑定方法（parallelGesture）。
| 绑定手势方法  | 功能规格  | 配参1  | 配参2  | 约束  |
| --- | --- | --- | --- | --- |
| gesture  | 绑定手势事件，父子组件交叠区域均绑定，响应子组件  | GestureType  | GestureMask  | 与通用事件抢占  |
| priorityGesture  | 当父组件配置priorityGesture时，优先识别父组件priorityGesture绑定的手势。  | GestureType  | GestureMask  | 与通用事件抢占  |
| parallelGesture  | 父组件绑定parallelGesture时，父子组件相同的手势事件都可以触发  | GestureType  | GestureMask  | 无  |
绑定手势方法
功能规格
配参1
配参2
约束
gesture
绑定手势事件，父子组件交叠区域均绑定，响应子组件
GestureType
GestureMask
与通用事件抢占
priorityGesture
当父组件配置priorityGesture时，优先识别父组件priorityGesture绑定的手势。
GestureType
GestureMask
与通用事件抢占
parallelGesture
父组件绑定parallelGesture时，父子组件相同的手势事件都可以触发
GestureType
GestureMask
无
前面讲到的手势的优先级是默认的，在加入了priorityGesture和parallelGesture绑定方法后，手势的响应顺序如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151054.31800194882391976810225864296130:50001231000000:2800:8265706AD0C6DE0B93B20BEEF2BBBDBEBA1A405E7D06A7F61243F4962752FBCC.png)
GestureMask枚举说明
| 名称  | 描述  |
| --- | --- |
| Normal  | 不屏蔽子组件的手势，按照默认手势识别顺序进行识别。  |
| IgnoreInternal  | 屏蔽子组件的手势，包括子组件上的系统内置的手势，如子组件为List组件时，内置的滑动手势同样会被屏蔽。 若父子组件区域存在部分重叠，则只会屏蔽父子组件重叠的部分。  |
名称
描述
Normal
不屏蔽子组件的手势，按照默认手势识别顺序进行识别。
IgnoreInternal
屏蔽子组件的手势，包括子组件上的系统内置的手势，如子组件为List组件时，内置的滑动手势同样会被屏蔽。 若父子组件区域存在部分重叠，则只会屏蔽父子组件重叠的部分。
不同手势绑定配参方案规格
| 父手势  | 子手势  | GestureMask（父）  | 交叠区域相同事件响应方  | 交叠区域不同事件响应方  |
| --- | --- | --- | --- | --- |
| gesture  | gesture  | default  | 子组件  | 各自响应  |
| gesture  | gesture  | IgnoreInternal  | 父组件  | 父组件  |
| priorityGesture  | gesture  | default  | 父组件  | 各自响应  |
| priorityGesture  | gesture  | IgnoreInternal  | 父组件  | 父组件  |
| parallelGesture  | gesture  | default  | 各自响应  | 各自响应  |
| parallelGesture  | gesture  | IgnoreInternal  | 父组件  | 父组件  |
父手势
子手势
GestureMask（父）
交叠区域相同事件响应方
交叠区域不同事件响应方
gesture
gesture
default
子组件
各自响应
gesture
gesture
IgnoreInternal
父组件
父组件
priorityGesture
gesture
default
父组件
各自响应
priorityGesture
gesture
IgnoreInternal
父组件
父组件
parallelGesture
gesture
default
各自响应
各自响应
parallelGesture
gesture
IgnoreInternal
父组件
父组件
组合手势（GestureGroup）
手势组合是指多种手势组合为复合手势，通过GestureGroup属性，可以给同一个组件添加多个手势，支持连续识别、并行识别和互斥识别模式。开发者可以根据业务需求，选择合适的组合模式。
| 接口  | 可选模式  | 描述  | 注册事件  |
| --- | --- | --- | --- |
| GestureGroup  | Sequence  | 手势顺序队列，需要按预定的手势组顺序执行，有一个失败则全部失败  | onCancel  |
| GestureGroup  | Parallel  | 手势组合，直到所有已识别的手势执行完  | 无  |
| GestureGroup  | Exclusive  | 互斥识别，成功完成一个手势，则完成手势任务  | 无  |
接口
可选模式
描述
注册事件
GestureGroup
Sequence
手势顺序队列，需要按预定的手势组顺序执行，有一个失败则全部失败
onCancel
GestureGroup
Parallel
手势组合，直到所有已识别的手势执行完
无
GestureGroup
Exclusive
互斥识别，成功完成一个手势，则完成手势任务
无
2独占事件控制
通过monopolizeEvents属性设置组件是否独占事件，事件范围包括组件自带的事件和开发者自定义的点击、触摸、手势事件。先响应事件的控件作为第一响应者，在手指离开屏幕前其他组件不会响应任何事件。
在一个窗口内，设置了独占控制的组件上的事件如果首先响应，则本次交互只允许此组件上设置的事件响应，窗口内其他组件上的事件不会响应。
如果开发者通过parallelGesture绑定了与子组件同时触发的手势，如PanGesture，子组件设置了独占控制且首个响应事件，则父组件的手势不会响应。
3自定义手势判定
为组件提供自定义手势判定能力。开发者可根据需要，在手势识别期间，根据自己的业务逻辑来决定是否响应手势。使用onGestureJudgeBegin方法对手势进行判定，开发者可以根据自身业务逻辑，选择是否响应自定义手势。
4手势拦截增强
为组件提供手势拦截能力。开发者可根据需要，将系统内置手势和响应链上更高优先级的手势做并行化处理，并可以动态控制手势事件的触发。
5responseRegion和hitTestBehavior
影响触摸测试的因素同样也可能会影响到手势的响应流程。例如responseRegion属性和hitTestBehavior属性可以控制Touch事件的分发，从而可以影响到onTouch事件和手势的响应。而绑定手势方法属性可以控制手势的竞争从而影响手势的响应，但不会影响到onTouch事件。
6 ArkUI组件自身的属性控制手势响应
ArkUI组件自身的属性，也可以对手势事件的响应做出控制。例如Grid、List、Scroll、Swiper、WaterFlow等滚动容器组件提供了nestedScroll属性，来解决和父组件的嵌套滚动的冲突问题；例如Swiper组件的disableSwipe可以设置禁用组件滑动切换的功能；又例如List组件可以通过设置enableScrollInteraction属性来设置是否支持手势滚动列表。
常见手势冲突问题
前面列举了一些常用的手势响应的控制方法，接下来我们通过这些方法来解决以下一些常见的手势响应冲突问题。
滚动容器嵌套滚动容器事件冲突
1 Scroll组件嵌套List组件滑动事件冲突
Scroll组件嵌套List组件，子组件List组件的滑动手势优先级高于父组件Scroll的滑动手势，所以当List列表滚动时，不会响应Scroll组件的滚动事件，List不会和Scroll一起滚动。如果需要List和Scroll组件同步滚动可以使用nestedScroll属性来解决，设置向前向后两个方向上的嵌套滚动模式，实现与父组件的滚动联动。
使用nestedScroll属性设置List组件的嵌套滚动方式，NestedScrollMode设置成SELF_FIRST时，List组件滚动到页面边缘后，父组件继续滚动。NestedScrollMode设置为PARENT_FIRST时，父组件先滚动，滚动至边缘后通知List组件继续滚动。示例代码如下：
2 List、Scroller等滚动容器嵌套Web组件，滑动事件冲突
比如List组件嵌套Web组件，当Web加载的网页中也包含滚动视图的时候，这时候上下滚动Web组件，不能和List列表整体一起滑动。这是因为Web的滑动事件和List组件的冲突，如果想让Web随List一起整体滚动，解决方案和前面的例子一样，给Web组件添加nestedScroll属性。
具体实现可以参考：Web组件嵌套滚动。
使用组合手势同时绑定多个同类型手势冲突
例如给组件同时设置单击和双击的点击手势TapGesture，按如下方式设置发现双击手势失效了，这是因为在互斥识别的组合手势中，手势会按声明的顺序进行识别，若有一个手势识别成功，则结束手势识别。因为单击手势放在了前面，所以当双击的时候会优先识别了单击手势，单击成功后后面的双击回调就不会执行了。
可以设置手势为并行识别来解决，设置对应的GestureMode为Parallel：
系统手势和自定义手势之间冲突
对于一般同类型的手势，系统手势优先于自定义手势执行，可以通过priorityGesture或者parallelGesture的方式来绑定自定义手势，例如下面这个示例：
图片长按手势响应失败或冲突，在Image控件上添加长按手势后，长按图片无法响应对应方法，而是图片放大的动画，示例代码如下：
```typescript
import { promptAction } from '@kit.ArkUI';
@Entry
@Component
struct GesturesConflictScene3 {
@State message: string = 'Hello World';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Image($r('app.media.startIcon'))
.margin({ top: 100 })
.width(360)
.height(360)
.gesture(
LongPressGesture({ repeat: true })
.onAction((event: GestureEvent) => {
})// 长按动作一结束触发
.onActionEnd(() => {
promptAction.showToast({ message: 'Long Press' });
})
)
}
.width('100%')
}
.height('100%')
}
}
```
这是因为Image组件内置的长按动画和用户自定义的长按手势LongPressGesture冲突了。可以使用priorityGesture绑定手势的方式替代gesture的方式，这样就会只响应自定义手势LongPressGesture了。如果需要两者都执行可以使用parallelGesture的绑定方式。
手势事件透传
和触摸事件一样，手势事件也可以通过hitTestBehavior属性来进行透传，例如下面这个示例，上层的Column组件设置hitTestBehavior属性为hitTestMode.none后，可以将滑动手势SwipeGesture透传给被覆盖的Column组件。hitTestMode.none：自身不接收事件，但不会阻塞兄弟组件和子组件继续做触摸测试。
多点触控场景下手势冲突
当一个页面中有多个组件可以响应手势事件，在多个手指触控的情况下，多个组件可能会同时响应手势事件，从而导致业务异常。ArkUI提供了手势独占的属性monopolizeEvents，设置需要单独响应事件的组件的monopolizeEvents属性为true，可以解决这一问题。
例如下面这个示例，给按钮Button1设置了.monopolizeEvents(true)之后，当手指首先触摸在Button1之后，在手指离开之前，其它组件的手势和事件都不会触发。
动态控制自定义手势是否响应
在手势识别期间，开发者决定是否响应手势，例如下面的示例代码，通过onGestureJudgeBegin回调方法在手势识别期间进行判定，当手势为GestureType.DRAG的时候，不响应该手势，所以会使定义的onDragStart事件失效。
```typescript
@Entry
@Component
struct GesturesConflictScene6 {
@State message: string = 'Hello World';
build() {
Column()
.width('100%')
.height(200)
.backgroundColor(Color.Brown)
.onDragStart(() => {
console.info('GesturesConflictScene6 Drag start.');
})
.gesture(
TapGesture({ count: 1 })
.tag('tap1')
.onAction(() => {
console.info('GesturesConflictScene6 TapGesture onAction.');
}),
)
.onGestureJudgeBegin((gestureInfo: GestureInfo, event: BaseGestureEvent) => {
if (gestureInfo.type === GestureControl.GestureType.LONG_PRESS_GESTURE) {
let longPressEvent = event as LongPressGestureEvent;
console.info('GesturesConflictScene6: ' + longPressEvent.repeat);
}
if (gestureInfo.type === GestureControl.GestureType.DRAG) {
// 返回 REJECT 会使拖动手势失败
return GestureJudgeResult.REJECT;
} else if (gestureInfo.tag === 'tap1' && event.pressure > 10) {
return GestureJudgeResult.CONTINUE
}
return GestureJudgeResult.CONTINUE;
})
}
}
```
父组件如何管理子组件手势
父子组件嵌套滚动发生手势冲突，父组件有机制可以干预子组件的手势响应。下面例子介绍了如何使用手势拦截增强，在外层Scroll组件的shouldBuiltInRecognizerParallelWith和onGestureRecognizerJudgeBegin回调中，动态控制内外层Scroll手势事件的滚动。
1 首先在父组件Scroll的shouldBuiltInRecognizerParallelWith方法中收集需做并行处理的手势。下面示例代码中收集到了子组件的手势识别器childRecognizer，使其和父组件的手势识别器currentRecognizer并行处理。
2 调用onGestureRecognizerJudgeBegin方法，判断滚动组件是否滑动划到顶部或者底部，做业务逻辑处理，通过动态控制手势识别器是否可用，来决定并行处理器的childRecognizer和currentRecognizer是否可用。
```typescript
@Entry
@Component
struct GesturesConflictScene7 {
scroller: Scroller = new Scroller();
scroller2: Scroller = new Scroller();
private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
private childRecognizer: GestureRecognizer = new GestureRecognizer();
private currentRecognizer: GestureRecognizer = new GestureRecognizer();
build() {
Stack({ alignContent: Alignment.TopStart }) {
Scroll(this.scroller) { // 外部滚动容器
Column() {
Text('Scroll Area')
.width('100%')
.height(150)
.backgroundColor(0xFFFFFF)
.borderRadius(15)
.fontSize(16)
.textAlign(TextAlign.Center)
.margin({ top: 10 })
Scroll(this.scroller2) { // 内部滚动容器
Column() {
Text('Scroll Area2')
.width('100%')
.height(150)
.backgroundColor(0xFFFFFF)
.borderRadius(15)
.fontSize(16)
.textAlign(TextAlign.Center)
.margin({ top: 10 })
Column() {
ForEach(this.arr, (item: number) => {
Text(item.toString())
.width('100%')
.height(200)
.backgroundColor(0xFFFFFF)
.borderRadius(15)
.fontSize(20)
.textAlign(TextAlign.Center)
.margin({ top: 10 })
}, (item: string) => item)
}
.width('100%')
}
}
.id('innerScroll')
.scrollBar(BarState.Off) // 滚动条常驻显示
.width('100%')
.height(800)
}.width('100%')
}
.id('outerScroll')
.height(600)
.scrollBar(BarState.Off) // 滚动条常驻显示
.shouldBuiltInRecognizerParallelWith((current: GestureRecognizer, others: Array<GestureRecognizer>) => {
for (let i = 0; i < others.length; i++) {
let target = others[i].getEventTargetInfo();
if (target) {
if (target.getId() === 'innerScroll' && others[i].isBuiltIn() &&
others[i].getType() === GestureControl.GestureType.PAN_GESTURE) { // 找到将要组成并行手势的识别器
this.currentRecognizer = current; // 保存当前组件的识别器
this.childRecognizer = others[i]; // 保存将要组成并行手势的识别器
return others[i]; // 返回将要组成并行手势的识别器
}
}
}
return undefined;
})
.onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer,
others: Array<GestureRecognizer>) => { // 在识别器即将要成功时，根据当前组件状态，设置识别器使能状态
if (current) {
let target = current.getEventTargetInfo();
if (target) {
if (target.getId() === 'outerScroll' && current.isBuiltIn() &&
current.getType() === GestureControl.GestureType.PAN_GESTURE) {
if (others) {
for (let i = 0; i < others.length; i++) {
let target = others[i].getEventTargetInfo() as ScrollableTargetInfo;
if (target instanceof ScrollableTargetInfo && target.getId() == 'innerScroll') { // 找到响应链上对应并行的识别器
let panEvent = event as PanGestureEvent;
if (target.isEnd()) { // isEnd返回当前滚动类容器组件是否在底部 根据当前组件状态以及移动方向动态控制识别器使能状态
if (panEvent && panEvent.offsetY < 0) {
this.childRecognizer.setEnabled(false) // 到底上拉
this.currentRecognizer.setEnabled(true)
} else {
this.childRecognizer.setEnabled(true)
this.currentRecognizer.setEnabled(false)
}
} else if (target.isBegin()) {
if (panEvent.offsetY > 0) { // 开始的时候下拉
this.childRecognizer.setEnabled(false)
this.currentRecognizer.setEnabled(true)
} else {
this.childRecognizer.setEnabled(true)
this.currentRecognizer.setEnabled(false)
}
} else {
this.childRecognizer.setEnabled(true)
this.currentRecognizer.setEnabled(false)
}
}
}
}
}
}
}
return GestureJudgeResult.CONTINUE;
})
}
.width('100%')
.height('100%')
.backgroundColor(0xF1F3F5)
.padding(12)
}
}
```
总结
手势冲突在界面开发中往往不可避免，特别是在复杂的应用界面中。针对不同的冲突场景和手势交互需求，需要选择合适的解决方案。可以参考前面介绍的影响触摸测试因素，以及手势响应控制里面的方法，进行尝试。
希望通过对本篇文章的阅读，能帮助您解决常见的一些手势事件冲突问题。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-hmrouter
爬取时间: 2025-05-01 09:33:00
来源: Huawei Developer
概述
HMRouter是HarmonyOS上页面跳转的场景解决方案，主要解决页面间相互跳转的问题，开发者可以参考HMRouter使用说明进行安装配置与快速上手，本文主要以实际开发中的各项场景为例，介绍HMRouter路由框架的使用。HMRouter路由框架提供了下列功能特性：
该框架底层对Navigation相关能力进行了封装，帮助开发者减少对Navigation相关细节内容的关注、提高开发效率，同时该框架对页面跳转能力进行了增强，例如其中的路由拦截、单例页面等。下文以页面跳转、弹窗提示、转场动效、数据加载、维测场景为切入点，介绍HMRouter路由框架的使用。
页面跳转场景
页面跳转与返回
HMRouter提供了基于自定义注解的页面跳转与返回功能，使用步骤如下：
多次页面跳转，返回指定页面
当页面跳转路径如HomePage->PageA->PageB->PageC，开发者希望在PageC的页面逻辑中直接返回到HomePage并携带参数，开发者仅需使用HMRouterMgr提供的pop方法，传入要返回目标页面的pageUrl、传递的参数param，即可直接带参返回到指定页面。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151054.96137689936291440121477664508481:50001231000000:2800:C4ABF2F17F2B64E4D81FCF36115F8A46CD857F1878772893CB246ABE8C3F21DD.png)
应用未登录，点击跳转登录页的校验场景
应用中经常会有当用户未登录应用时，点击某些应用内容会自动跳转到登录页面的场景，在使用HMRouter对此场景进行实现时，可以采用以下步骤：
运行效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151054.72088866794775887909824817874960:50001231000000:2800:4507A899E350D80CF35C9979D37F9417CC0BA958C9D875E2E2BC15D8DEBE36C5.gif)
实现单例页面的跳转
当应用中存在初始化加载资源消耗大且有复用需求的页面时，就可以使用单例页面。典型的业务场景如视频类应用中的视频播放页面，此类页面通常需要加载视频解码器资源并对其初始化，且该页面在视频类应用中会频繁出现。实现上开发者只需要配置@HMRouter注解参数中的singleton参数为true即可。
弹窗提示场景
实现弹窗类型的页面
在HMRouter路由框架中，开发者只需要设置@HMRouter注解的dialog配置为true即可将当前页面作为弹窗使用。
返回时弹窗，提示用户是否确认返回
运行效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151054.63781347344918358974369723909111:50001231000000:2800:D45DA06B22BFB31C354B8AD41BD74CD6E0AF58BA140097484D0ADFBDDFBBEBE5.gif)
首页两次返回退出应用
该场景下用户第一次触发应用返回退出时向用户提示“再次返回退出”，第二次用户触发返回操作时应用真正退出。实现上可参考以下步骤：
```typescript
@HMLifecycle({ lifecycleName: 'ExitAppLifecycle' })
export class ExitAppLifecycle implements IHMLifecycle {
lastTime: number = 0;
onBackPressed(ctx: HMLifecycleContext): boolean  {
let time = new Date().getTime();
if (time - this.lastTime > 1000) {
this.lastTime = time;
ctx.uiContext.getPromptAction().showToast({
message: '再次返回退出应用',
duration: 1000,
});
return true;
} else {
return false;
}
}
}
```
运行效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151054.93572619299812504468233512165485:50001231000000:2800:75539BED1930000A07002012B065CC04A904E173D6E1D029D19292C4A2318386.gif)
转场动效场景
全局自定义转场动效
-  定义完成后，只需要将实例传入HMNavigation组件的standardAnimator参数即可。
-  将创建好的实例作为dialogAnimator的参数进行传入即可。
特定页面设置自定义转场
开发者可以自定义动画类并实现IHMAnimator接口中的effect方法，该方法会将页面进出场的效果对象enterHandle与exitHandle作为参数传入，可通过参数对象上的start、finish方法，设置对应效果的起止状态，支持设置的常用属性还有：
以下代码示例表示入场时由屏幕底部以线性速度向屏幕顶部运动，入场动画持续时长为400ms。出场时从屏幕顶部以线性速度向屏幕底部运动，出场动画持续时长也为400ms。
自定义动画定义完成后，其实例可以作为push/replace方法的animator参数进行传入。
运行效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151054.96554775952519433145347734466029:50001231000000:2800:1DBE98A72E8DDABD2A83E3A0AB46509ADCBE48F92B01F0F66004963E63AD09CB.gif)
根据条件呈现不同转场动效
相同的页面可能在不同情况下出现不同的转场效果，常见的有短视频播放时的评论页面弹出时的转场：
此处以评论区组件打开的视角进行动画定义，定义竖屏播放时评论区进出场动画如下：
定义短视频横屏播放时评论区进出场动画如下：
最后根据条件选择不同的动效，例如此处根据视频播放方向是否为横向，在页面跳转时使用不同的animator值。
运行效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151054.10785894036226343340451064388706:50001231000000:2800:092BC01BF3E3074D5E4E00311DA15D46F818BFCD53E6349EB4F7650316E916B1.gif)
交互式转场
当应用中有页面的进出场效果与用户手势操作同步的诉求时，即当用户手指在屏幕上移动时，页面跟随用户手势移动，可以参考以下实现，通过IHMAnimator的interactive函数控制动画播放进度，在actionStart中判断向右移动执行页面返回操作，在updateProgress更新动画进度，在actionEnd中获取到动画的最终状态，根据最终状态判断是继续执行动画与页面返回还是关闭动画取消页面返回。
```typescript
@HMAnimator({ animatorName: 'liveInteractiveAnimator' })
export class LiveInteractiveAnimator implements IHMAnimator {
effect(enterHandle: HMAnimatorHandle, exitHandle: HMAnimatorHandle): void {
// ...
}
interactive(handle: HMAnimatorHandle): void {
handle.actionStart((event: GestureEvent) => {
if (event.offsetX > 0) {
HMRouterMgr.pop()
}
})
handle.updateProgress((event, proxy, operation, startOffset) => {
if (!proxy?.updateTransition || !startOffset) {
return
}
let offset = event.fingerList[0].localX - startOffset;
if (offset < 0) {
proxy?.updateTransition(0)
return;
}
let rectWidth = event.target.area.width as number
let rate = offset / rectWidth
proxy?.updateTransition(rate)
})
handle.actionEnd((event, proxy, operation, startOffset) => {
if (!startOffset) {
return
}
let rectWidth = event.target.area.width as number
let rate = (event.fingerList[0].localX - startOffset) / rectWidth
if (rate > 0.4) {
proxy?.finishTransition()
} else {
proxy?.cancelTransition?.()
}
})
}
}
```
运行效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151054.90870599307049406261414327642002:50001231000000:2800:E58B028CED882043C213734F399762D4B536E9E27DC8D03AB00B93FD0E2FF718.gif)
数据加载场景
数据请求预加载，与页面跳转并行化
该场景下，开发者希望提前网络请求的位置并在其他线程中执行网络请求而不阻塞主线程，代码实现参考如下步骤。
```typescript
@Concurrent
async function networkRequest(lifecycle: string): Promise<string> {
// ...
}
```
```typescript
@HMLifecycle({ lifecycleName: 'requestLifecycle' })
export class ExampleLifecycle implements IHMLifecycle {
requestModel: RequestModel = new RequestModel()
onPrepare(): void {
console.log(this.requestModel.data);
let task: taskpool.Task = new taskpool.Task(networkRequest, 'onPrepare');
taskpool.execute(task).then((res: Object) => {
console.log(res + '');
})
}
// ...
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151055.79024289896197383284794869039302:50001231000000:2800:03030BB23FF592574B2C1E5820A987A6D74F038113BC4247BE49C6A39E9A2307.png)
页面重开数据恢复
该场景下当页面关闭时，之前浏览的相关记录依然存在，典型的场景例如短视频评论，当用户打开评论区页进行翻阅后停留在某处，此时关闭评论区再打开，评论内容会任然停留在上一次浏览的位置。实现上可以参考如下步骤。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151055.01496212685990482909620114919880:50001231000000:2800:74AA7AA16DE3985363EDED560AA40EFD8DEC4277843076A212A1C959A779159C.png)
维测场景
页面埋点开发
当需要统计类似于页面加载耗时等数据，或者有其他自定义打点数据需要统计时，可以使用生命周期回调，在对应的位置进行打点，以下示例为页面停留时长的数据打点统计，实现上参考以下步骤：
```typescript
@HMLifecycle({ lifecycleName: 'PageDurationLifecycle', global: true })
export class PageDurationLifecycle implements IHMLifecycle {
private time: number = 0;
onShown(): void {
this.time = new Date().getTime();
}
onHidden(ctx: HMLifecycleContext): void {
const duration = new Date().getTime() - this.time;
console.log(`Page ${ctx.navContext?.pathInfo.name} stay ${duration}`);
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151055.75226725298370820249105603035710:50001231000000:2800:18DDB0DD0F19A60DE148651EE8FDCE46BC991FAA5C94DC373F7512DF858451A1.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-image-white-lump-solution
爬取时间: 2025-05-01 09:33:14
来源: Huawei Developer
概述
在通过Image组件加载网络图片时，通常会经历四个关键阶段：组件创建、图片资源下载、图片解码和刷新。当加载的图片资源过大时，Image组件会在图片数据下载和解码完成后才刷新图片。这一过程中，由于图片下载较耗时，未成功加载的图片常常表现为空白或占位图（一般为白色或淡色），这可能引发“Image 白块”现象。为了提升用户体验并提高性能，应尽量避免这种情况。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151055.59501533736722317013801089579646:50001231000000:2800:D0167D2172C6D18882E5AD9750FA4857FACCB3FF9A927536AC660ACA60FCA860.png)
为了减少白块的出现，开发者可以采用预下载的方式，可以将网络图片通过应用沙箱的方式进行提前缓存，将图片下载解码提前到组件创建之前执行，当Image组件加载时从应用沙箱中获取缓存数据。非首次请求时会判断应用沙箱里是否存在资源，如存在直接从缓存里获取，不再重复下载，减少Image加载大的网络图片时白屏或白块出现时长较长的问题，提升用户体验。
1. 开发者在使用Image加载较大的网络图片时，网络下载推荐使用HTTP工具提前预下载。
2. 在预下载之后，开发者可根据业务自行选择数据处理方式，如将预下载后得到的ArrayBuffer转成BASE64、使用应用沙箱提前缓存、直接转PixelMap、或是业务上自行处理ArrayBuffer等多种方式灵活处理数据后，传给Image组件。
使用场景
当子页面需要加载很大的网络图片时，可以在父页面提前将网络数据预下载到应用沙箱中，子组件加载时从沙箱中读取，减少白块出现时长。
场景案例
开发者使用Navigation组件时，通常会在主页引入子页面组件，在按钮中添加方法实现跳转子页面组件。当子页面中需展示一张较大的网络图片时，而Image未设置占位图时，会出现点击按钮后，子组件的Image组件位置出现长时间的Image白块现象。
本文将以应用沙箱提前缓存举例，给出减少Image白块出现时长的一种优化方案。
【优化前】：使用Image组件直接加载网络地址
以下为部分示例代码：
【优化后】：子页面PageOne中需展示一张较大的网络图片，在父组件的aboutToAppear()中提前发起网络请求，并做判断文件是否存在，已下载的不再重复请求，存储在应用沙箱中。当父页面点击按钮跳转子页面PageOne，此时触发pixMap请求读取应用沙箱中已缓存解码的网络图片并存储在LocalStorage中，通过在子页面的Image中传入被@StorageLink修饰的变量ImageData进行数据刷新，图片送显。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151055.65158332491974840103024084410611:50001231000000:2800:D2ABDD7F381A790DDC4562EEEFD755068A7D666A3462BE4944BDF559539B754E.png)
以下为关键示例代码：
性能分析
下面，使用trace对优化前后性能进行对比分析。
【优化前】
分析阶段的起点为父页面点击按钮开始计时即trace的H:DispatchTouchEvent，结束点为子页面图片渲染的首帧出现即H:CreateImagePixelMap标签后的第一个Vsync，记录白块出现时间为1.3s，其中以H:HttpRequestInner的标签起始为起点到H:DownloadImageSuccess标签结束为终点记录时间，即为网络下载耗时1.2s，因此使用Image直接加载网络图片时，出现长时间Image白块，其原因是需要等待网络下载资源完成。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151056.77582322906376096521703506032834:50001231000000:2800:DFE64B9731F5472D7116C9CA92833D6ACB0177647E7B2D43E4917A9B6DB56E16.png)
【优化后】
分析阶段的起点为父页面点击按钮开始计时即trace的H:DispatchTouchEvent，结束点为子页面图片渲染的首帧出现即H:CreateImagePixelMap标签后的第一个Vsync，记录白块出现时间为32.6ms，其中记录H:HttpRequestInner的标签耗时即为提前网络下载的耗时1.16s，对比白块时长可知提前预下载可以减少白块出现时长。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151056.99890767544250525981027352776906:50001231000000:2800:B5FC0ECA532ACA03623541E868834EFFF87CE67AAABDCA0FD6996630AAF5B68C.png)
网络下载耗时实际受到网络波动影响，优化前后的网络下载耗时数据总体差异在1s内，提供的性能数值仅供参考。
效果对比
| （优化前）直接使用Image加载网络数据，未使用预下载  | （优化后）使用预下载  |
| --- | --- |
|    |    |
（优化前）直接使用Image加载网络数据，未使用预下载
（优化后）使用预下载
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151056.87266419934417217640254181636022:50001231000000:2800:24050412945EBC141DF7A6CF63777C79DB517392C58D0F0D9C13E32AFB47D062.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151056.81219706930838230092830646085462:50001231000000:2800:CDD405A531C80E1F7ED2D7799F2D8547A219D41F2C7B004A6CE12D59433E57A5.gif)
性能对比
对比数据如下：
| 方案  | 白块出现时长(毫秒)  | 白块出现时长  |
| --- | --- | --- |
| （优化前）直接使用Image加载网络数据，未使用预下载  | 1300  | 图片位置白块出现时间较长  |
| （优化后）使用预下载  | 32.6  | 图片位置白块出现时间较短  |
方案
白块出现时长(毫秒)
白块出现时长
（优化前）直接使用Image加载网络数据，未使用预下载
1300
图片位置白块出现时间较长
（优化后）使用预下载
32.6
图片位置白块出现时间较短
1.测试数据仅限于示例程序，不同设备特性和具体应用场景的多样性，所获得的性能数据存在差异，提供的数值仅供参考。
2.由于该方案仅将下载解码网络图片的步骤提前，不会影响内存等应用数据。开发者可自行管理解码后的PixelMap，主动实现图片的复用和缓存。
由此可见，加载网络图片时，使用预下载，提前处理网络请求并从应用沙箱中读取缓存数据的方式，可以减少用户可见Image白屏或白块出现时长，提升用户体验。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-carousel-graphic-works
爬取时间: 2025-05-01 09:33:29
来源: Huawei Developer
概述
图文作品播放是一种常见的功能，它的特点是：由多张图片组成一个合集，图片可以自动进行轮播，也可以手动去进行图片切换。自动轮播时，图片下方的进度条缓慢加载至完成状态；手动切换时，图片下方的进度条瞬间切换至已完成状态或未完成状态。
由于Swiper组件自带的导航点指示器目前只支持数字和圆点的样式，不支持对应的特殊样式，因此需要通过自定义指示器（即进度条）来模拟底部的导航条效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151056.70591919933529337952954532559294:50001231000000:2800:A7C2A464403962A8E1DE4E698885853932318548DDF81E9AEB5111A4FAB1829F.gif)
本文中将通过场景介绍、技术选型和实现方案三个部分来进行介绍。
场景介绍
常见的图文作品，可以自动循环播放和手动切换播放合集中的图片。
技术选型
从技术角度看，图文作品轮播效果可通过Swiper组件和它的指示器的联动效果实现，由于Swiper组件的指示器无法自定义，所以需要拆开实现：
示意效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151056.31503437399860035022892516613552:50001231000000:2800:9C0461CB93827121D88B36F1759CEF4CE8CF8C4235043BA6A559A63E0B9412B2.png)
实现方案
图片区域实现
图片区域需要使用Swiper组件来实现。将图片合集的数据传入Swiper组件后，需要对Swiper组件设置一些属性，来完成图片自动轮播效果：
```typescript
Swiper(this.swiperController) {
LazyForEach(this.data, (item: PhotoData, index: number) => {
Image($r(`app.media.` + item.id))
.width(this.foldStatus === 2 ? '100%' : '70%')
.height('100%')
}, (item: PhotoData) => JSON.stringify(item))
}
.loop(!this.slide ? true : false)
.autoPlay(!this.slide ? true : false)
.interval(3000)
.indicator(false)
```
示意效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151056.49189704788175839500579276976800:50001231000000:2800:6F6425EC3482D93F2AC5F0D5FD866F65F5AFE04359558A920E8F55295D939F8D.gif)
底部导航点设计
底部导航点（进度条）有三种样式：未完成状态的样式、已完成状态的样式和正在进行进度增长的样式。
创建自定义组件progressComponent。
示意效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151057.72527705451567006706867235777076:50001231000000:2800:A1A408FD41B0D679BD51410C5E557454525C2655F386F7D1F86DA4CE17155CE2.gif)
上述代码中，this.progressData为图片集合的数组，this.currentIndex为当前播放的图片在图片集合数组中的索引，index为进度条对应的图片在图片集合数组中的索引。当this.currentIndex >= index时，表示图片集合数组中索引0-index的进度条都是已完成状态。
当图片集合手动播放时，随着图片的切换，下方进度条会跟随着切换为已完成状态或未完成状态。此时，开发者需要给Swiper组件添加onGestureSwipe事件，来判断页面是否跟手滑动。
```typescript
Swiper(this.swiperController) {
// ...
}
.onGestureSwipe((index: number, extraInfo: SwiperAnimationEvent) => {
this.slide = true;
})
```
slide为布尔值，用来判断页面是否跟手滑动。默认值为false，当页面跟手滑动时，slide的值为true。
上述内容介绍了如何实现图文作品中自动播放和手动播放的功能，其中包括场景介绍、技术选型和代码实现等。由于Swiper组件的指示器只有两种显示模式，且不支持自定义样式。所以，开发者需要通过自定义Swiper指示器，来实现进度条切换效果。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-comment-reply-pop-up-window
爬取时间: 2025-05-01 09:33:45
来源: Huawei Developer
概述
评论回复模块在图文和视频应用中被广泛使用，包含编辑区域、好友列表、常用表情列表和表情面板（见下图），它允许用户进行输入文字、表情、@好友、选择图片等操作。该模块一般以弹窗的形式展现给用户，通常在图文、视频界面中直接弹出，或者在评论列表上层弹出，本文将从评论列表上层弹出这种相对复杂的场景出发，重点对以下几个方面进行介绍，为开发者提供评论回复弹窗模块开发的最佳实践。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151057.57760805952696334440709722324487:50001231000000:2800:A7EB11E5EC6ED118FFB51ACDDA5F9610A1D0A547F972EDFA39732FF77C80F5D7.png)
为方便阅读，下面表格对本文常出现的模块名称进行说明：
| 模块名称  | 对应图1中序号  |
| --- | --- |
| 评论列表  | 1  |
| 好友列表  | 2  |
| 编辑区域  | 3  |
| 常用表情列表  | 4  |
| 软键盘  | 5  |
| 表情面板  | 6  |
模块名称
对应图1中序号
评论列表
1
好友列表
2
编辑区域
3
常用表情列表
4
软键盘
5
表情面板
6
参考资料
实现原理
弹窗组件选型
通过对CustomDialog自定义弹窗、bindSheet半模态弹窗、Navigation Dialog三种弹窗方案进行尝试，发现自定义弹窗和半模态弹窗有一定规格限制，会产生一些无法避免的问题，最终选用Navigation Dialog方案实现评论模块弹窗。以下对三种方案优劣势进行一个详细的说明。
-  方案优势： 方案劣势： promptAction.openCustomDialog与自定义弹窗呈现效果相同，不再赘述。
-  方案优势： 方案劣势：
-  方案优势： 方案劣势：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151057.17290653042260686881989514360206:50001231000000:2800:E3F728961F86D578712F948A2F37F22F8CDAAD45069309F2B0155A66D4793A18.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151057.80957199029246802483005856320756:50001231000000:2800:5C1B652E802BF37758A1139C21610197DECDF68AE5B374BB3C243A4C78D4C022.gif)
Navigation Dialog在z轴的层级较低，评论模块如果基于该方案实现，那么在其他使用了CustomDialog、bindSheet的弹窗模块（例如评论列表）中调用评论模块，评论模块会在其他弹窗模块下层，所以其他弹窗模块也需要一同改为Navigation Dialog实现，通过路由栈进行弹窗层级的控制。
编辑区域组件及方法选型
编辑区域支持输入文字、表情、@好友等内容。目前支持图文混排和文本交互式编辑的组件，RichEditor是不二的选择。针对添加表情，可使用RichEditorController.addImageSpan方法实现。@好友可使用RichEditorController.addTextSpan和RichEditorController.addBuilderSpan两种方法实现，通过以下对两种方法的分析对比，最终选择addBuilderSpan实现@好友功能。
为了方便表述，下文对通过addTextSpan、addImageSpan、addBuilderSpan方法添加到编辑区域的内容分别命名为textSpan、imageSpan、builderSpan。
关键场景实现
弹窗显示
在视频页面点击消息按钮，弹出评论列表页面弹窗。在评论列表页点击写评论按钮，弹出评论模块弹窗。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151057.38721686980224443083314930815038:50001231000000:2800:9E837E7B1E6A70C90562B10453B4612D441743AA26460A596A48302762DF4419.gif)
基于Navigation的弹窗方案，Navigation的mode属性需要设置为NavigationMode.Stack。弹窗需要全屏显示，Navigation则需要添加在最外层组件上。
弹窗模块需要用NavDestination包裹，设置NavDestination的mode属性为NavDestinationMode.DIALOG弹窗类型，设置expandSafeArea属性为[SafeAreaType.KEYBOARD]扩展安全区域，不避让软键盘，以解决CustomDialog的问题。并在弹窗内容下层通过Stack添加遮罩，点击可关闭弹窗，考虑到多个弹窗模块要进行相同的处理，将弹窗模块封装为组件，评论列表和评论模块调用该组件则无需关注弹窗相关的交互，只需关注弹窗中需要展示的内容即可。
各个弹窗模块的弹出和关闭通过路由的进栈出栈控制，弹窗的层级关系通过路由进栈的顺序来控制。
软键盘和表情面板切换适配
点击编辑区域表情按钮，软键盘切换为表情面板，表情按钮图标变成键盘图标。再次点击，表情面板切换回软键盘，按钮图标由键盘变回表情。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151057.00865451771865645239423620881997:50001231000000:2800:62559D5AB676B6A4570413AD64CC50A2FCDEFDFDDAEB2CAFDBD74D0EB8A0E6A9.gif)
本文选择自定义键盘来控制软键盘和表情面板的切换。通过设置RichEditor.customKeyboard为表情面板组件的构建函数EmojiKeyboard，来展示表情面板，设置该属性为undefined，则展示默认软键盘。通过这种方式在软键盘与表情面板切换时也无需手动进行richEditor焦点的处理。
为保证切换软键盘和表情面板时，评论模块整体高度不发生改变，则需要获取软键盘高度对表情面板高度进行计算和手动设置。有可能软键盘高度被手动更改，所以需要通过keyboardHeightChange事件对软键盘高度进行监听，当高度大于0时，更新记录软键盘高度的状态变量。注意在组件销毁前取消对应的监听事件。
如图1效果图所示，对比软键盘显示界面和表情面板显示界面可知，表情面板的高度 = 常用表情列表的高度 + 软键盘的高度。由于弹窗不避让软键盘和自定义键盘，在切换到软键盘时，需要一个占位元素来将软键盘上方区域顶起，且高度为软键盘的高度。同理，切换到表情面板时，需要将占位元素的高度设置为表情面板的高度（即常用表情列表的高度 + 软键盘的高度）。
评论弹窗模块高度适配代码：
表情面板高度适配代码：
编辑区功能
编辑区通常包括输入文字、表情、@好友、选择图片功能，本节通过效果图展示结合代码讲解的方式对上述功能开发做相应介绍。
-  在软键盘上方常用表情列表点击表情图片，或者切换到表情面板点击表情图片，会在编辑区域光标后方添加对应的表情内容。 在表情面板或常用表情列表中点击表情时可通过RichEditorController.addImageSpan在编辑区域进行添加图片表情，注意需要设置offset属性为当前光标位置，当前光标的位置可通过RichEditorController.getCaretOffset获取。这样使得表情在当前光标后添加，否则默认在内容的最后方添加，后文类似的添加操作都遵循此规则。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151058.52133592204448312560407473874139:50001231000000:2800:D0D0584524B2D0DB06AC18FDE8F04B418EA480F8F9FBAC5A7ACF5CFBF083C90E.gif)
-  点击编辑区域@按钮，或在软键盘输入@符号，会展示好友列表。点击好友列表中好友头像，会在编辑区域添加@好友内容。 点击@按钮时，通过RichEditorController.addTextSpan添加@符号，并显示好友列表。同时需要监听RichEditor.aboutToIMEInput事件 ，该事件在输入内容前触发回调，在回调中获取要输入的内容，如果输入的内容为@，则相当于点击了@按钮的效果，这样统一了点击@按钮和键盘输入@的逻辑，方便后续一些细节的处理。 在好友列表中点击好友头像时，通过RichEditorController.getSpans可以获取光标前一个span的内容，若光标前一个span是内容为@的textSpan，则先删除，然后通过RichEditorController.addBuilderSpan将“@[好友昵称]”以指定的样式作为一个整体添加到编辑区域中。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151058.81215485581674596228894157481068:50001231000000:2800:CEC6A85C77A21B4D384032D22C5548E319019D72799A506B9620D8D48D5888C1.gif)
-  点击软键盘删除按钮，如果要编辑区域光标前删除的内容是builderSpan（@好友）且没有被选中，则进行选中，否则直接删除光标前的内容。选中内容会作为整体删除。 监听RichEditor.aboutToDelete事件，可通过回调中返回false阻止编辑区域默认的删除行为。在第一次删除builderSpan（@好友）的时候，先使用RichEditorController.setSelection对整体进行选中，再次点击删除键时选中内容在RichEditor中会默认被整体删除。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151058.13400959820171103457471954398273:50001231000000:2800:66ACDDEA7932896C1ED0B00A7884B87E63BF986C10FC4D0B6F625B083A261168.gif)
-  在编辑区域输入文字、表情、@好友内容，点击发送按钮，获取编辑区域内容，并弹窗展示内容以及@好友中好友的相关信息。 可以通过RichEditorController.getSpans来获取编辑区域所有的内容，获取到的内容在getSpans方法的返回值中表现为RichEditorTextSpanResult和RichEditorImageSpanResult两种类型。上文中提到过文字、图片表情、@好友三种内容与这两种类型的对应关系如下表： 本文中的定义 对应编辑区域内容 添加方式 getSpans方法返回值中对应的类型 textSpan 连续的文字 键盘输入或RichEditorController.addTextSpan RichEditorTextSpanResult imageSpan 图片表情 RichEditorController.addImageSpan RichEditorImageSpanResult builderSpan @[好友昵称] RichEditorController.addBuilderSpan RichEditorImageSpanResult textSpan可通过RichEditorTextSpanResult.value获取文字内容。imageSpan可通过RichEditorImageSpanResult.valueResourceStr获取图片资源。但是builderSpan在RichEditorImageSpanResult中获取不到任何相关的内容信息，所以在点击好友头像添加@好友内容时需要手动将这些builderSpan进行维护。 实际开发中编辑区域不同类型的内容往往需要一种统一的数据结构来表达，方便传输和存储。该数据结构需要不仅能对编辑区域内容进行记录，也需要有携带一些额外信息的能力，比如携带@好友相关的用户信息。本文定义为RichEditorSpan。（实际开发中需要的属性字段根据需求灵活调整）。 使用RichEditorSpan[]类型的数组builderSpans来维护@好友时的builderSpan，需要注意的是要保证每个builderSpan在数组中的顺序要与实际内容中出现的顺序一致。在添加builderSpan时，通过计算当前光标位置前面builderSpan的个数，来确定添加到builderSpans数组中的位置，并把需要携带的好友信息放入data属性中。 发送评论时，将获取到的内容用RichEditorSpan[]类型的数组richEditorSpans进行统一地表达。通过getSpans获取所有内容，如果是textSpan，通过value属性取出文字内容，设置RichEditorSpan.type为text，如果是imageSpan，通过valueResourceStr属性获取图片资源，设置RichEditorSpan.type为image。如果是builderSpan，按顺序从数组builderSpans中获取，并将他们按顺序添加到richEditorSpans中。 最终生成的richEditorSpans数据格式如下： 当需要展示评论内容时，只需要对richEditorSpans进行遍历，根据type属性，分别对文字、表情、@好友进行展示逻辑的处理。具体展示形式开发者根据实际需求确定。
-  点击图片按钮拉起系统相册，选择本地图片进行上传。该功能使用场景相对独立，本文不详细介绍。开发者需要进一步了解详情，可参考以下sample。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151058.24286703633471774484779955947740:50001231000000:2800:90C04BD8827DD4AF636FB1C86F6ED08242785FBA602D1240D9434BEA79980ADD.png)
| 本文中的定义  | 对应编辑区域内容  | 添加方式  | getSpans方法返回值中对应的类型  |
| --- | --- | --- | --- |
| textSpan  | 连续的文字  | 键盘输入或RichEditorController.addTextSpan  | RichEditorTextSpanResult  |
| imageSpan  | 图片表情  | RichEditorController.addImageSpan  | RichEditorImageSpanResult  |
| builderSpan  | @[好友昵称]  | RichEditorController.addBuilderSpan  | RichEditorImageSpanResult  |
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-tab-practice
爬取时间: 2025-05-01 09:33:59
来源: Huawei Developer
概述
不同的页签导航在基本功能上，会因产品形态的不同衍生出不同样式的UI效果。本文为满足开发者对于不同导航样式的需求，介绍了多种导航的实现。
本文基于常见应用的页签导航效果，给出对应的实现方案。不同页签导航效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151058.88620486229129804338539498876239:50001231000000:2800:9B29FCC65B9819AA9ABA3C378BB356BC35BD0C139FA6E5116B6784BA2C99B1F9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151058.21288328742093097590316459507592:50001231000000:2800:3EE74990B4FD35208DAE229B14672EAC464D96230337EE393C7CF2EF4699F427.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151058.71602411939330085186324536168509:50001231000000:2800:9C4129132351C693CF1E0A6FB7E55E3FE240D8E738480C50BF94F7DBE5AB3A3C.png)
底部导航
基础底部导航
基础底部导航属于常规导航，一般以图标加文字的形式展示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151058.59474626203266082718226551256992:50001231000000:2800:CAB803620B614FF835252C70C571AF0EB850A417991021C2F6974A4CE3856A35.png)
舵式底部导航
舵式导航是基础底部导航的一种扩展，中间按钮一般为核心功能，并且在设计效果上中心图标可以超出导航条的高度，两侧为普通操作按钮。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151059.74394747626445373979693504278764:50001231000000:2800:7D44298EAED449372DB7AA91607B4A8969286E994320F89BFFBA8355E161E9F4.png)
```typescript
// entry/src/main/ets/pages/RudderStyleTab.ets
Flex() {
ForEach(this.tabArray, (item: BottomTabModel, index: number) => {
this.Tab(item.selectImage, item.defaultImage, item.title, item.middleMode, index)
}, (item: BottomTabModel, index: number) => JSON.stringify(item) + index)
}
```
顶部导航
居左对齐样式
居左对齐导航属于常规导航，由于Tabs组件导航只能居中展示，无法通过tabBar属性设置导航条。为实现居左对齐样式，可使用自定义布局替代tabBar控制按钮对齐方向。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151059.96721004424844107676890689390616:50001231000000:2800:7973BF3EA58C5CA7A2D5037FD50513B8A557B69BE12BBB669964BFC6A228C779.png)
```typescript
// entry/src/main/ets/pages/LeftTab.ets
@Builder
tab(tabName: string, _tabItem: number, tabIndex: number) {
Row() {
Text(tabName)
.fontSize(16)
.lineHeight(22)
.fontColor(tabIndex === this.currentIndex ? '#0A59F7' : '#E6000000')
.id(tabIndex.toString())
.onAreaChange((_, newValue: Area) => {
if (this.currentIndex === tabIndex && (this.indicatorLeftMargin === 0 || this.indicatorWidth === 0)) {
let positionX: number;
let width: number = Number.parseFloat(newValue.width.toString());
if (newValue.position.x !== undefined) {
positionX = Number.parseFloat(newValue.position.x?.toString())
this.indicatorLeftMargin = Number.isNaN(positionX) ? 0 : positionX;
}
this.indicatorWidth = width;
}
})
}
.justifyContent(FlexAlign.Center)
.constraintSize({ minWidth: 35 })
.width(64)
.height(35)
.onClick(() => {
this.controller.changeIndex(tabIndex);
this.currentIndex = tabIndex;
})
}
```
可滑动居左对齐样式
可滑动导航样式在居左对齐基础上增加滑动功能，适合页签数较多场景。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151059.36548977740136706266701589810543:50001231000000:2800:8EC30B80ECCC25488AA627B20128AE026A38C2CE61C6683A9847E5B1457E1AF0.png)
实现方式与居左对齐样式相同，唯一区别在于导航布局中嵌套List组件实现可滑动效果。
下划线样式
下划线导航样式属于常规导航，以文字加下划线的形式展示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151059.39784770593817046406799700216578:50001231000000:2800:AE729A79E45361FFF258097E51BE3EFBF3D599686406CFF2EB5120BDE38B0CB5.gif)
背景高亮式
背景高亮导航样式属于常规导航，通过背景色突出选中页签。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151059.10985600421653410671290159887062:50001231000000:2800:9B62FFF83BEFCC3CDC74D39D3F36E0D3B3EFB2096D48BF40FD98ED3930A4420B.png)
文字缩放式
文字缩放式导航样式属于常规导航，通过字体加粗放大突出选中页签。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151059.72015854485160278554390653710220:50001231000000:2800:D75E247B177E12D0A9185D0A96E6DD4774A85738335F58103BFA5B65E31FAB7B.png)
双层嵌套式
双层嵌套样式拥有两层导航，外层嵌套内层，与单层导航相比可以容纳更多页签。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151059.15382114332665587019901518567775:50001231000000:2800:A14A6390A9642DC1D31037964FE98788A5AE2BA0D3C477E3C027071ABC748FC1.png)
外层导航通过在TabContent组件设置tabBar属性，其中TabContent中嵌套List和子级Tabs。List组件嵌套subTabBuilder自定义组件实现内层导航。子级Tabs组件嵌套TabContent组件实现内容区。
侧边导航
基础侧边导航
属于侧边导航类，通过List去实现左侧导航条区域。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151059.31100577718461074957875358189904:50001231000000:2800:920DDD65713E368BFDE1F8999673940C4EF5346DDC63F163842CE6BC5965FDBE.png)
基础侧边导航使用左右布局：左侧通过List组件与ListItem组件实现导航布局，右侧实现导航内容区。
抽屉式侧边导航
抽屉式导航属于侧边导航类，核心思路是“隐藏”，点击入口或侧滑可以像“抽屉”一样拉出菜单。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151059.34795010827506774275014451819802:50001231000000:2800:21F54EEB4F81287C0BFEB408D0D9BFCEEAF30D90FCB669E2440032EC6F070E09.gif)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-window-practice
爬取时间: 2025-05-01 09:34:32
来源: Huawei Developer
概述
智慧多窗是一种多任务处理解决方案，允许用户在同一时间、同一屏幕上以悬浮窗或分屏的方式同时运行多个应用窗口。在智慧多窗的显示模式下，用户可以根据自己的需求，合理安排应用窗口的位置和大小。目前智慧多窗的形式，主要包含悬浮窗和分屏。
-
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151059.99314082657361732464355305814504:50001231000000:2800:D011756CD480153DA1860315E2E1649C09F7D681FE3CFED2063EBE02382FCD0F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151100.56892370321696866805549227179775:50001231000000:2800:CC66FACB9620FD84E8C8BB35367D0414E848772837FB7459821B310369581CCB.png)
由于应用从全屏进入智慧多窗（悬浮窗/分屏）模式后，窗口尺寸、宽高比例会发生变化，往往会产生一些布局的适配问题。例如，分屏后页面内容显示不全无法滑动、视频被压缩导致宽高比不正确，应用开启悬浮窗后内容和状态栏的重叠区域无法响应用户操作等。
本文将主要介绍悬浮窗/分屏布局适配方案，以及智慧多窗开发过程中的一些常见问题以及解决方案，来帮助开发者快速适配智慧多窗布局开发，提升用户使用体验。
在阅读本文前开发者可以先了解下关于智慧多窗的UX设计规范，具体可以参考多窗口交互。
智慧多窗适配方案
悬浮窗和分屏功能是由系统提供的能力，不需要开发者单独开发功能，所以开发者只需要考虑应用悬浮或者分屏之后应用界面的适配问题。
首先开发者需要考虑应用是否需要支持悬浮窗/分屏能力，如果确定应用需要支持悬浮窗/分屏能力，则需要考虑布局适配问题，进行布局一多适配。在一些特殊的场景下，比如沉浸模式下，顶部窗口控制条遮挡住了重要信息或者重叠区域有事件需要响应的时候，需要考虑控制条的避让适配；横向游戏和视频需要考虑横向悬浮窗适配。开发者可以参考下面的流程图进行智慧多窗适配。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151100.78481229098141782048198571771517:50001231000000:2800:671FAB1081BC3EB2162385B02527A509903DAA44D9B3A6F5B0E442576CA458C5.png)
配置声明支持智慧多窗
当应用需要配置是否支持悬浮窗/分屏能力时，可以通过在module.json5配置文件中abilities标签下添加supportWindowMode字段来实现，supportWindowMode属性主要标识当前UIAbility所支持的窗口模式，详细请参见应用声明支持智慧多窗。
一多布局适配
在使用多窗口功能时，窗口的尺寸会发生变化，可能影响布局。以下是两种情况的具体描述：
这种对比说明，在多窗口使用时，需要特别注意布局的可视性和内容的可访问性，以确保用户体验。
关于不同设备悬浮窗宽高比、应用分屏窗口高度比例详细请参见应用布局适配智慧多窗。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151100.89035777276085554484323321607163:50001231000000:2800:E6F75537CA9999B0AE73C11155AECC5A6E3F7F0AE63E0E4CE947FF957175D0C1.png)
针对应用进入悬浮窗/分屏出现的页面内容截断、挤压、堆叠等问题，开发者可以参考一次开发，多端部署中关于页面开发的一多适配，通过自适应布局和响应式布局，来使应用自适应窗口的大小变化。例如示例布局适配问题节：界面被截断，无法上下滑动，使用了一多的延伸能力。
沉浸模式下顶部窗口控制条避让适配
沉浸式布局是指应用布局不避让状态栏、导航栏以及智慧多窗顶部横条，这可能发生组件与顶部横条的重叠，导致文字遮挡、点击事件冲突等情况。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151100.05919657589125681352717824320830:50001231000000:2800:8FE5EB645138E6D8524D03270202AD8CBD914905918F41BBA5865CBA9D931EF1.png)
顶部横条的避让可通过以下两种方式适配，具体可以参考顶部窗口控制条避让适配智慧多窗。
顶部横条的避让具体实践可以参考：沉浸模式下顶部窗口控制条避让问题。
横向游戏和视频横向悬浮窗适配
悬浮窗默认是竖向的，但是对于横向游戏和视频应用，横向的悬浮窗体验会更好。开发者可以通过在module.json5配置文件中abilities标签下的preferMultiWindowOrientation属性增加“landscape”或者“landscape_auto”配合API以声明应用支持横向悬浮窗或上下分屏模式。
preferMultiWindowOrientation属性主要标识当前UIAbility组件多窗布局方向，具体可以参考应用声明支持智慧多窗中关于preferMultiWindowOrientation的属性的描述。当设置preferMultiWindowOrientation属性为“landscape_auto”表示多窗布局动态可变为横向，需要配合API（enableLandscapeMultiWindow/disableLandscapeMultiWindow）使用，建议视频类应用配置，视频播放界面适配横屏悬浮窗效果图如下，具体使用可以参考：横向悬浮窗适配问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151100.95401519170271971532494400600814:50001231000000:2800:41FECC5A3B2BBEB659930796B51429E06A8117D488B6ABA7C54F87EDF8B32AA7.gif)
常见问题
为了帮助开发者快速对智慧多窗进行布局适配，下面列举了一些常见的智慧多窗布局适配问题，接下来介绍如何使用前面讲到的一些适配方案来解决这些问题。
下面将常见问题分为以下三类，开发者可以使用前面对应的适配方案进行适配：
布局适配问题
1.  问题现象 应用分屏后内容显示不全，无法通过上下滑动展示未显示的内容。 优化前示例代码如下： 可能原因 应用只适配了全屏大小，当应用分屏/悬浮窗后，窗口会变小，导致页面显示不全，超出窗口的区域无法显示。 解决措施 使用一多的延伸能力，增加Scroll组件，让列表或者文字区域可以按照指定方向滑动，优化后示例代码如下： 优化后效果如下图所示。
2.  问题现象 视频播放界面分屏后，视频被截断显示不全。 可能原因 在进入分屏页面，窗口的height变成了屏幕的1/2，应用没有对这种情况进适配，导致Xcomponent宽度没变为之前的1/2导致视屏形变。优化前示例代码如下： 解决措施 使用布局约束的aspectRatio属性指定XComponent组件的宽高比，设置aspectRatio属性后，组件宽高会受父组件内容区大小限制。 优化后效果如下图所示。
3.  问题现象 Video组件在分屏状态下，视频播放界面被截断显示不全。 优化前示例代码如下： 可能原因 给Video组件宽高设置的均为100%，Video组件默认保持宽高比进行缩小或者放大，使得视频铺满屏幕。当应用分屏后，由于窗口宽度不变，高度变为原来的1/2，Video组件的高度会超出窗口高度，导致视频显示不全。 解决措施 给Video组件设置.objectFit(ImageFit.Contain)属性，使视频保持宽高进行缩小或者放大，使得视频完全显示在Video组件边界内，优化后示例代码如下： 优化后效果如下图所示。
4.  问题现象 子组件显示超出了父组件范围，无法通过上下滑动显示完全。 优化前示例代码如下： 可能原因 子组件设置为了固定值，当应用分屏的时候，屏幕高度变为原来的1/2，父组件高度会随之变小。如果此时子组件高度大于父组件，就会导致子组件无法完全显示。 解决措施 子组件使用constraintSize约束子组件跟随父容器的大小，建议用子组件占用父组件的高度百分比，而不是绝对值，优化后示例代码如下： 优化后效果如下图所示：
5.  问题现象 应用进入分屏后，随着窗口变小，Image组件显示不全，页面布局显示异常。 优化前示例代码如下： 可能原因 在进入分屏页面，窗口的height变成了屏幕的1/2，导致image组件的height变小，image图片形变。 解决措施 推荐开发者通过一多的隐藏能力来实现，按照其预设的显示优先级，随容器组件尺寸变化显示或隐藏，通过设置布局优先级（displayPriority属性）来控制显隐。示例代码如下： 优化后效果如下图所示：
6.  问题现象 进入分屏后弹窗页面内容显示错乱，底部按钮挡住弹窗内容。 优化前示例代码如下： 可能原因 应用未考虑分屏窗口尺寸变小的情况，弹窗高度设置为固定值，且底部按钮使用position属性设置了固定位置，导致整体布局错乱。 解决措施 使用constraintSize属性给弹窗高度限定最大值，同时使用Scroll组件包裹弹窗内容区域（一多的延伸能力），通过给内容区域的Column组件设置layoutWeight（一多的占比能力）属性，是其占据剩余空间，使操作按钮居于底部显示。当内容高度超过内容区域高度的时候可以滚动进行查看，优化后示例代码如下： 优化后效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151100.43074774130359622640223986776389:50001231000000:2800:2C54912D592D49F6E0683FF0B998EEEA7014D580E28B0DB21B6E71EF5A8D9E10.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151100.13282261429272457762045862217770:50001231000000:2800:7454BA2B651E2EDD79B4D8BF868AD2E520544F679A1600EB6F9194A86BF81F0F.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151100.06576271745910713741227304348886:50001231000000:2800:20F00504D7461D5D98C089FCAF8723A8281D8F00B71D6B0D0755C813BD421FE3.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151101.06374114358711320284532787410332:50001231000000:2800:FB260B8F6EED2FD3058D4A5384EE5827BF8E6417575583CD8EC6088614FE4B50.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151101.22539933721668454356262499905022:50001231000000:2800:ABC5F9F9AE222EB89B8644C7C36A62BCFBA20C5351B05F701B7617BA93B771A5.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151101.98367008119071366480238924949420:50001231000000:2800:5123E13F2868AEF3271115758C51CA9856A4A18EE1893ABF24A5DA53A5D666B0.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151101.89729989048813130642906613916127:50001231000000:2800:6FF5AA2AD46FD7429C232A1A520E7E505FA3A588C6F869E2EC9DA6BB9EC6B46C.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151101.11672919248639642639600533989317:50001231000000:2800:F0DD1E35AFA312F8C1874DCC57FA893FD3966C8E24F7709F42D94645CC36CEEF.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151101.94016861343618059882471024018389:50001231000000:2800:1405AD9304998125D8A89E4E6EF31A2F119A83EAEB08E24856D36DC4FC001DE7.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151102.55551182750054245885317058071993:50001231000000:2800:0D70CEF6836BF8EDDF1AD13B1C9BBBF0E395F012F6E90DB7240D910DB455543A.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151102.06816353647608795497270692515554:50001231000000:2800:B0EF49770C46D938FF9F1A9C21431F18146DB705B533CA560544E72406F7FBC6.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151102.93528403884091645945089815795782:50001231000000:2800:566C3045A9FE93C97F88B75AF9311F1229DCA7D39D4DB13705483B366A817E5A.gif)
沉浸模式下顶部窗口控制条避让问题
沉浸式应用在悬浮窗场景下顶部操作栏无法操作
问题现象
应用分屏后视图和悬浮窗顶部重合的区域无法响应操作。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151102.98775237497557406589101610038111:50001231000000:2800:1E944306EE8097E036E3C8581F3D123CFC8E57B54CFD9DECA660734024BBEC3F.gif)
优化前示例代码如下：
```typescript
@Component
export struct Question7Incorrect {
private windowClass = (getContext(this) as common.UIAbilityContext).windowStage.getMainWindowSync();
aboutToAppear(): void {
this.windowClass.setSpecificSystemBarEnabled('status', false);
}
aboutToDisappear(): void {
this.windowClass.setSpecificSystemBarEnabled('status', true);
}
build() {
NavDestination() {
Stack() {
// ...
Row() {
Image($r('app.media.icon_pause'))
// ...
.onClick(() => {
promptAction.showToast({
message: 'Action success'
});
})
}
.height('100%')
.width('100%')
.justifyContent(FlexAlign.End)
.alignItems(VerticalAlign.Top)
}
}
.hideTitleBar(true)
}
}
```
可能原因
沉浸式应用顶部没有避让，导致悬浮窗顶部bar与应用的顶部区域重叠，重叠区域中的按钮无法响应点击事件。
解决措施
通过getWindowAvoidArea接口可获取屏幕顶部需要规避的矩阵区域topRect，获取到该值后应用可对应做布局避让。同时可通过on('avoidAreaChange')监听系统规避区域变化以进行布局的动态调整。具体可以参考顶部窗口控制条避让适配智慧多窗，优化后示例代码如下：
优化后效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151102.30235207784667253722498799132754:50001231000000:2800:4DAB5461B0E62EBABC4B0A4F954CA98474A0404C5336065735BEAA3E19B371AF.gif)
横向悬浮窗适配问题
视频播放未适配横向悬浮窗
问题现象
视频或者游戏类应用在横屏模式下，开启悬浮窗后，页面没有适配横屏，导致内容显示不全或者观看体验不好。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151102.48108308282898311424272030434354:50001231000000:2800:EC015D638CF47346AC021DC8CE7A2F08C1E567D18B55A718A06334F3DFD3DD61.gif)
优化前示例代码如下：
可能原因
悬浮窗默认是竖屏，需要应用主动适配横屏的属性值
解决措施
开发者可以通过在module.json5配置文件中abilities标签下的preferMultiWindowOrientation属性增加“landscape_auto”。
该场景下多窗布局动态可变为横向，需要配合API（enableLandscapeMultiWindow / disableLandscapeMultiWindow）使用。
```typescript
@Component
export struct Question8Correct {
private windowClass = (getContext(this) as common.UIAbilityContext).windowStage.getMainWindowSync();
aboutToAppear(): void {
this.windowClass.enableLandscapeMultiWindow();
}
aboutToDisappear(): void {
this.windowClass.disableLandscapeMultiWindow();
}
build() {
// ...
}
}
```
优化后效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151102.82918564327994875333911494768903:50001231000000:2800:167E42F8080650B4C89FF65A6B8B42DE2710EE629208EAC8ACFD84A782EFCF02.gif)
总结
智慧多窗中的悬浮窗和分屏能力是系统提供的，开发者不需要为进行功能开发，但是开发者需要重点关注是悬浮窗/分屏模式下的应用的布局适配问题。下面总结了一些常见的布局适配经验：

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-grid-drag-swap
爬取时间: 2025-05-01 09:34:50
来源: Huawei Developer
概述
Grid网格元素拖拽交换功能在应用中经常会被使用，如当编辑九宫格图片需要拖拽图片改变排序时，就会使用到该功能。当网格中图片进行拖拽交换时，元素排列会跟随图片拖拽的位置而发生变化，并且会有对应的动画效果，以达到良好的用户体验。
Grid网格布局一般由Grid容器组件和子组件GridItem构建生成，Grid用于设置网格布局相关参数，GridItem定义子组件相关特征。网格布局中含有网格元素，当给Grid容器组件设置editMode属性为true时，可开启Grid组件的编辑模式。开启编辑模式后，还需要给GridItem组件绑定长按、拖拽等手势。最后，需要添加显式动画，并设置相应的动画效果。最终，呈现出网格元素拖拽交换的动效过程，如下示意图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151102.38136658049300377115316801145195:50001231000000:2800:0EE24243CBDC24E800D169F38E43385800737F9CCBF6FEBD75D04C9BD318D6EF.gif)
实现原理
关键技术
Grid网格元素拖拽交换功能实现是通过Grid容器组件、组合手势、显式动画结合来实现的。
Grid组件当前支持GridItem拖拽动画，通过给Grid容器组件设置supportAnimation为true，即可开启动画效果。但仅支持在滚动模式下（设置rowsTemplate、columnsTemplate其中一个）支持动画。且仅在大小规则的Grid中支持拖拽动画，跨行或跨列场景不支持。因此，在跨行或跨列场景下，需要通过自定义Gird布局、自定义手势和显式动画来实现拖拽交换的效果。
开发流程
在需要拖拽交换的场景中：
相同大小网格元素，长按拖拽
场景描述
在编辑九宫格等多图的场景中，长按图片（网格元素）可以拖拽交换排序，拖拽图片的过程中，旁边的图片也会即时移动，以产生新的宫格排布。
示意效果图如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151103.57429745026007821094785366106279:50001231000000:2800:4400B67B9F8EF0F7D8CEE053C9DBFAE534874AD0A633D0207A6D045F2BDF0FA5.gif)
开发步骤
```typescript
Grid() {
ForEach(this.numbers, (item: number) => {
GridItem() {
Image($r(`app.media.image${item}`))
.width('100%')
.height(this.curBp === 'md' ? 131 : 105)
.draggable(false)
.animation({ curve: Curve.Sharp, duration: 300 })
}
}, (item: number) => item.toString())
}
.width(this.curBp === 'md' ? '66%' : '100%')
.scrollBar(BarState.Off)
.columnsTemplate('1fr 1fr 1fr')
.columnsGap(this.curBp === 'md' ? 6 : 4)
.rowsGap(this.curBp === 'md' ? 6 : 4)
.height(this.curBp === 'md' ? 406 : 323)
```
```typescript
changeIndex(index1: number, index2: number) {
let tmp = this.numbers.splice(index1, 1);
this.numbers.splice(index2, 0, tmp[0]);
}
```
```typescript
.onItemDragStart((_, itemIndex: number) => {
this.imageNum = this.numbers[itemIndex];
return this.pixelMapBuilder();
})
.onItemDrop((_, itemIndex: number, insertIndex: number,
isSuccess: boolean) => {
if (!isSuccess || insertIndex >= this.numbers.length) {
return;
}
this.changeIndex(itemIndex, insertIndex);
})
```
不同大小网格元素，长按拖拽
场景描述
在一些展示设备的场景中，会有大小不同的网格元素。当用户想改变设备排序时，可以长按设备图片（网格元素）拖拽交换排序，拖拽的过程中，也会改变排列顺序，以产生新的宫格排布。
示意效果图如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151103.34981975250871809099308244484907:50001231000000:2800:E43AA76BB4284DE6BA26153BB9FC2E91D8082117F3F83283B17A9CBFD2E67BE6.gif)
开发步骤
两个Grid之间网格元素交换
当场景涉及两个Grid之间的网格元素交换时，可使用GridObjectSortComponent组件来实现。可以点击添加或者移除按钮，对网格元素进行交换。详细实现步骤请参见：示例。开发者也可以在GridObjectSortComponent组件的源码基础上进行相应修改，实现更加丰富的功能。
网格元素直接拖拽，不需长按
场景描述
在不需要长按拖拽的场景下，开发者可以将元素设置成直接拖拽，无需长按，即可完成元素的拖拽交换。
示意效果图如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151103.61866255559996388265625049525790:50001231000000:2800:EDB65992A2660EAFF286563D1F6F476CF7921502C416C7C8A64860A386FEAFA0.gif)
开发步骤
网格元素长按后，显示抖动动画
场景描述
在设备列表页面时，如果想要移除设备，在选中设备并长按后，可对网格元素进行编辑。此时，设备图片会有抖动的效果。
示意效果图如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151103.14829797031498629239799883764238:50001231000000:2800:12D9A1C1B834E0EB05510E0C0C56873CF782483855EC1C026D63DBEECBEE9F74.gif)
开发步骤
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-immersive
爬取时间: 2025-05-01 09:35:09
来源: Huawei Developer
概述
沉浸式模式通常指让应用的界面更加专注于内容，不希望用户被无关元素干扰。在移动端应用中，全屏窗口元素包括状态栏、应用界面和导航栏（如下图），沉浸式页面开发常通过将应用页面延伸到状态栏和导航栏的方式，来达到以下目的：
本文将介绍沉浸式页面的实现方案、原理以及提供以下常见沉浸式页面开发场景下一些适配问题的解决方案。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151103.64385866971524913718565724859937:50001231000000:2800:A8D62124DB75E33E0A9B2750479D2CC5CEE9D3E2E3D53CEA1EDFF09A2ED1C0DB.png)
实现原理
关键技术
沉浸式页面开发通常分为以下两步：
1.  由于避让区本身是有内容展示，如状态栏中的电量、时间等系统信息，或是手势交互，如导航条点击或上滑，在实现应用页面沉浸式效果后，往往会和避让区域产生UI元素的遮挡、视觉上的违和或交互上的冲突等问题，开发者可以针对不同场景选择以下方式对避让区和应用页面进行适配。
实现沉浸式效果方案对比
一般来说，整个应用（所有页面）都需要沉浸式效果，可以选择设置窗口全屏方案统一实现，针对具体页面的避让场景设置padding；单个页面或者仅需要将背景延伸到状态栏和导航栏，页面内容（子组件）希望避让状态栏和导航栏，使用expandSafeArea属性扩展对应组件安全区域来实现沉浸式效果更为方便。以下对两种方案的差异进行详细的说明。
| 原始布局  | 方案一：设置窗口全屏模式布局  | 方案二：扩展组件安全区域布局  |
| --- | --- | --- |
|   |   |   |
原始布局
方案一：设置窗口全屏模式布局
方案二：扩展组件安全区域布局
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151104.85137349649014003720884430342104:50001231000000:2800:F1EB16597E1FF79529D87EB772CCF261C4E9DEE6096C0DEE6350806ED8B40B0D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151104.43120758889083165063341705009614:50001231000000:2800:B340D8CF5C5BCEC625C1E37174C6F37A3745D4F8A637BED314CC5BE9605AACCD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151104.89324185006021856257915566759632:50001231000000:2800:CDC098BD1061D17A6C03469325F747A23F968F039DC6C5CD7A164A10337151D0.png)
顶部或底部背景延伸场景
场景描述
页面背景需要延伸到状态栏和导航条区域，页面内容在安全区展示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151104.54937911186083543668214039505757:50001231000000:2800:EB095A0530A18B434A6F302D6125E7A34D64F06289656574E49CD946F3865F97.png)
开发步骤
-  给设置背景色的组件设置expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])，使背景色延伸到状态栏和导航条。由于expandSafeArea属性不影响子组件的布局，所以Tabs组件内的内容默认在安全区域布局，避让状态栏和导航条。
顶部图片延伸场景
场景描述
页面顶部的图片要延伸到状态栏中去，形成沉浸式效果。顶部的返回按钮等交互组件，要合理避让状态栏。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151104.80874099078075374047450132514438:50001231000000:2800:D91CC5A6732D51FEB4C9D936E1CC0D620F498CA1C0499BC1DAC61E1AABCD552E.gif)
开发步骤
滚动列表底部延伸场景
场景描述
在列表滚动场景中，滚动时内容可与导航条区域重合，滚动到底部时，底部内容需避让导航条。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151105.49537343088191104933656485124520:50001231000000:2800:248BCF753E2D93673ADC45DD585FF83A87AFF8B5246594C52BD19A70C2397974.gif)
开发步骤
全屏沉浸式场景
场景描述
在一些视频播放或游戏类的沉浸式页面中，为了更好的观看或操作体验，往往需要隐藏状态栏和导航栏。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151105.30461274144230542610929081596897:50001231000000:2800:4BECE783337A487B361250A4F3F1FC4581C70304C027F8A66D747B40BF041336.gif)
开发步骤
在页面显示或隐藏时，使用Window.setWindowLayoutFullScreen()方法设置窗口是否为全屏模式，使用Window.setWindowSystemBarEnable()方法设置状态栏和导航条显隐。
挖孔区避让场景
场景描述
在一些需要最大程度利用屏幕可视区域的场景，需要在状态栏显示一些重要信息或操作按钮时，不仅需要隐藏原始的状态栏和导航栏，还需要针对不同挖孔区域的信息进行避让。
| 挖孔区域在中间（Mate 60 Pro）  | 挖孔区域在侧边（Mate X5）  |
| --- | --- |
|   |   |
挖孔区域在中间（Mate 60 Pro）
挖孔区域在侧边（Mate X5）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151105.88532751116794606605616031303199:50001231000000:2800:B43E9BEEBD0317A7F0076CA44A086394A4C8A5A8BEB58CF7F0DDD4CA9F6B578A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151105.26614744388717358954577569407463:50001231000000:2800:807AF015559D06E7CCE2D9DD8D5580380CE49405B2A589BBD86452B74720BC50.png)
开发步骤
深色背景下状态栏颜色适配场景
场景描述
在某些将深色背景延伸到状态栏的沉浸式页面中，需要设置状态栏时间文字、信号图标、电量图标等内容为浅色进行适配，避免状态栏内容不清晰，以此提升用户的视觉体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151105.68306763167555170722217174681024:50001231000000:2800:DF612AC4204F00C966C561D90EEDA7F330F26DC03CB721087FE8CB3976965AAB.png)
开发步骤
常见问题
在A页面跳转B页面时使用setWindowLayoutFullScreen()方法让页面变沉浸式，在B页面的aboutToDisappear生命周期中退出沉浸式，回到A页面，A页面会由沉浸式效果过度为非沉浸式效果
给组件设置了expandSafeArea属性不生效
设置expandSafeArea属性常会触碰以下限制，导致组件并没有扩展安全区域。
更多限制场景可参考API参考中expandSafeArea章节的说明部分。
某些场景下没有使用setWindowLayoutFullScreen()方法或expandSafeArea属性，页面也延伸到了状态栏或导航栏
在页面中使用了以下组件，且满足expandSafeArea属性生效条件，则会有默认的扩展安全区域行为。开发者可重写该属性覆盖默认行为。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-dark-mode-adaptation
爬取时间: 2025-05-01 09:35:24
来源: Huawei Developer
概述
深色模式（Dark Mode）又称之为暗色模式，是与日常应用使用过程中的浅色模式（Light Mode）相对应的一种UI主题。深色模式最早来源于人机交互领域的研究和实践，该模式并非简单地将页面背景变为黑色，文字内容变为白色，而是提供一整套适配深色模式的应用配色主题。深色模式相较浅色模式更加柔和，能减少亮度对用户眼睛造成的刺激和疲劳，此外深色模式能在一定程度上降低应用功耗，提升续航表现。
应用深色模式适配，需遵循基本的UX设计原则，保障应用页面内容的易读性、舒适性和一致性，具体可参考深色模式设计原则。应用适配过程主要包含字体颜色、元素背景色等颜色资源的适配，媒体资源如图片图标的适配，以及系统状态栏的适配，此外需要对一些特殊情况如使用了Web组件加载的Web页面进行处理。
本文主要将介绍深色模式的适配过程，同时会列举出适配过程中的常见问题及解决方案。
实现原理
当系统切换到深色模式后，应用内可能会出现部分内容切换到深色主题的情况，例如状态栏、弹窗背景色、系统控件等，会导致应用内页面效果错乱。
为应对上述情况，需要对应用进行深色模式下的内容适配，目前该适配主要依靠资源目录。当系统对应的设置项发生变化后（如系统语言、深浅色模式等），应用会自动加载对应资源目录下的资源文件。
系统为深色模式预留了dark目录，该目录在应用创建时默认不存在，在进行深色模式适配时，需要开发者在src/main/resources中手动地创建出dark目录，将深色模式所需的资源放置到该目录下。对于浅色模式所需的资源，可以放入默认存在的src/main/resources/base目录下。
在进行资源定义时，需要在base目录与dark目录中定义同名的资源。例如在base/element/color.json文件中定义text_color为黑色，在dark/element/color.json文件中定义text_color为白色，那么当深浅色切换时，应用内使用了$('app.color.text_color ')作为颜色值的元素会自动切换到对应的颜色，而无需使用其他逻辑判断进行控制。
一般情况下深浅色模式切换不会导致应用界面产生结构上的变化，而是页面结构一致但是采用不同的主题配色、配图等，使得整个应用在切换到深色模式后依然保持自然美观，以下为深色模式适配的UX示例。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151106.95417428285069258987813753272840:50001231000000:2800:23A66241780D7CBDB1F13409D9BC36FFDBBABF0092ECC5DB30AA1D235FE3E086.png)
从上图中可以看到，在应用进行深色模式适配过程中主要的适配项有颜色资源适配、媒体资源适配、状态栏适配，除此之外若应用内使用了Web组件加载了Web内容，那么还需对Web页面适配深色模式，具体适配方案可点击对应链接跳转到具体章节查看。
目前业内应用向用户提供的深浅色模式切换有以下两种常见方式。
-  实现上，需要开发者使用setColorMode()方法将ColorMode设置为COLOR_MODE_NOT_SET（未设置颜色模式），然后应用在运行过程中就可以自动感知到系统颜色模式切换，若应用完成了深浅色模式适配，将自动切换到对应的颜色模式。
-  实现上，切换深色模式需要调用setColorMode()方法将ColorMode设置为COLOR_MODE_DARK（深色模式），切换浅色模式需要将ColorMode设置为COLOR_MODE_LIGHT（浅色模式），这样就可以完成对应用深浅色的手动控制。
综上分析，深色模式适配内容如下表所示。
| 适配项  | 适配内容  | 适配方式  |
| --- | --- | --- |
| 颜色资源适配  | 组件背景色，字体颜色等  | 使用受支持的系统资源使用color.json资源文件  |
| 媒体资源适配  | 应用内使用到的图片、图标等  | SVG类型图标可使用fillColor()属性使用media资源目录  |
| 状态栏适配  | 深浅模式下不同的状态栏表现，包括状态栏的背景色以及状态栏内时间等内容的字体颜色  | 对应用背景色进行深浅色适配根据当前深浅色状态动态设置状态栏字体颜色  |
| Web内容适配  | 应用内使用Web组件加载的Web内容  | 参考Web组件设置深色模式  |
适配项
适配内容
适配方式
颜色资源适配
组件背景色，字体颜色等
媒体资源适配
应用内使用到的图片、图标等
状态栏适配
深浅模式下不同的状态栏表现，包括状态栏的背景色以及状态栏内时间等内容的字体颜色
Web内容适配
应用内使用Web组件加载的Web内容
参考Web组件设置深色模式
深色模式适配
颜色资源适配
| 浅色模式  | 深色模式  |
| --- | --- |
|    |    |
浅色模式
深色模式
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151106.33723522911808506651325381109651:50001231000000:2800:A8FDA6305A7968B18E3257CC5FCC549FEC0D0CB389E38363E7F9EEF7BEA09AF8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151106.44331727638954983264928392560224:50001231000000:2800:B387A7C51FCD13DF0084A605939771D2B4E4540354742300E841C30C475FC552.png)
上述页面效果在浅色模式下显示正常，但是当切换到深色模式后 ，弹窗内文字与弹窗背景色不满足背景色对比度不低于5:1，用户识别弹窗内容困难。上述效果的关键问题在于使用自定义弹窗时，若未手动指定弹窗背景色，系统默认对弹窗背景色做了深浅色适配，但是弹窗内的具体内容特别是开发者的自定义内容无法自动适配深色模式，于是当系统切换到深色模式下，弹窗背景色自动深色，而弹窗内容保持与浅色模式一致的颜色，导致内容无法看清，该类问题对应解决方案有以下两种。
| 浅色模式  | 深色模式  |
| --- | --- |
|    |   |
浅色模式
深色模式
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151106.73696366456019957261158876357723:50001231000000:2800:97405F099D732AAD628733CBFD258E1BC4D8639BE6F0AEF090AD13535D7160C5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151106.52870283724658557864226092759094:50001231000000:2800:9FDA678188E00A58AE89C12BBE9713C3CC0AEA703D096FE1038E88565C23C2F2.png)
媒体资源适配
媒体资源适配即在深浅模式下采用不同颜色表现的图片或图标等媒体资源，从而达成更好的用户体验，以下为应用内的图标未适配深色模式的效果示例，未适配内容以黄虚线框出。
| 浅色模式  | 深色模式  |
| --- | --- |
|    |    |
浅色模式
深色模式
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151106.99632551465426372315143571637339:50001231000000:2800:F9159000C65AE240B6594A190E9209B863E242AF4B8444F8F1BF98AF51A544EF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151106.16985459180658270119108131591989:50001231000000:2800:BABD128F40E0EA3902E7B8A70FDB564F68DA6B9B4CEF2E2C42AA122114F4DB1B.png)
上述错误示例效果的关键问题在于对于应用内的图标并未做深色模式下的适配，于是图标的颜色与应用浅色时一致，而两者对比度过低，导致切换到深色模式后应用内图标无法看清，媒体资源的适配有以下两种方式。
| 浅色模式  | 深色模式  |
| --- | --- |
|   |    |
浅色模式
深色模式
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151107.49146714309081046233662271792678:50001231000000:2800:10EA11C1D203EC095DDE90A1403824F4FFC65C9BE6BD918C4BDAF57E31D07744.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151107.50806642128923251393264487313276:50001231000000:2800:F9D75DB69EA6952CAA7E66431608864269C87173868299D0A036CB909EE9F2D6.png)
状态栏适配
状态栏适配即在深浅色模式下，采用不同的状态栏背景色与字体颜色。若应用未启用沉浸式，那么默认情况下，浅色模式下状态栏为白底黑字，深色模式下状态栏为黑底白字。当应用启用了沉浸式，状态栏背景色与应用背景色保持一致，而状态栏文字会默认在浅色模式下保持黑色，而在深色模式下保持白色，若应用在浅色模式下设置了深色背景或在深色模式下设置了浅色背景，都会导致状态栏背景色与状态栏字体颜色对比度过低，导致显示异常。错误效果示例如下图，应用设置了沉浸式并在浅色模式下具有纯黑色的背景色，导致状态栏的日期电量等文本内容无法看清。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151107.49005435524107769955262307426583:50001231000000:2800:1950475F2A7A1B3324A28B61A46885BB8D11BCE03B9B2A8517399260ED3EC6F5.png)
上述错误效果的主要问题在于页面的背景色固定为黑色，当系统切换到浅色模式后，状态栏文字默认切换到黑色，此时状态栏背景色与文字颜色一致，于是状态栏中的文字就不可见了，此类问题修改方案有以下两种。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151107.20644772919799498082326262325241:50001231000000:2800:976B070D5A3B0074C76EA3693830B65239183259CDFDFE94262D89D2A8CA3443.png)
Web页面适配深色模式
Web页面的内容不会自动跟随系统颜色模式进行切换。
若需要Web内容进行深浅色适配，就需要在Web页面内通过媒体查询的方式单独设置深色模式下的页面样式，并通过Web组件的darkMode()属性来控制Web页面是否启用深色模式。
具体实现开发者可参考：Web组件设置深色模式。
常见问题
开发者自定义的弹窗无法跟随或只有部分内容跟随系统深浅色变换
可能原因
若自定义弹窗未手动指定背景色，那么系统默认对弹窗的背景色做了深色模式适配，但弹窗内的内容特别是自定义的内容，无法自动跟随系统深色模式的切换发生变化。
解决措施
参考上述适配过程对弹窗内容进行适配。
媒体资源适配时显示文件已存在
问题现象
当开发者适配媒体资源时（如图片图标等），出现对应资源在另外的目录已存在的弹窗。
解决措施
直接点击弹窗内的“continue”按钮即可，并不会导致适配错误。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-one-shot-to-the-end
爬取时间: 2025-05-01 09:35:51
来源: Huawei Developer
概述
一镜到底动效是页面切换时对相同或者相似的两个元素做的一种位置、大小等属性匹配的过渡动画效果，有助于提升用户操作任务的效率，增强视觉的流畅感，同时也增强动效的品质感，是转场设计中重点推荐的技法。如下例所示，在点击图片后，该图片消失，同时在另一个位置出现新的图片，二者之间内容相同，可以对它们添加一镜到底动效。图1为不添加一镜到底动效的效果，图2为添加一镜到底动效的效果，一镜到底的效果能够让二者的出现消失产生联动，使得内容切换过程显得灵动自然而不生硬。
| 不添加一镜到底动效  | 添加一镜到底动效  |
| --- | --- |
|   |   |
不添加一镜到底动效
添加一镜到底动效
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151107.04960832163418333124239158564006:50001231000000:2800:FC5A9C98FD36FCEA236920CA8FF8A2CA765DD94C04092DB8D544DAC469808F5F.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151107.09226144672725742511558370059449:50001231000000:2800:481E320B3122CDA5615BEBD8D4A612DB4CF2BEC3B3C76F03EDBC84DA828E9484.gif)
实现原理
一镜到底动效中整个页面会以一种平滑的方式从一个场景过渡到另一个场景。这种转场效果常用于展示不同页面之间的关联性，能够给用户带来流畅的视觉体验。
根据场景，可以将一镜到底动效分为两类：
-  共享元素一般是转场前后持续存在的界面元素，即上文提到的持续元素，是在转场发生后希望用户关注到的焦点元素，它增强了转场的连续感。如下图，搜索框是共享元素。
-  当一组元素在过渡时包含明确的边界，可使用容器来让转换过程有连续感。容器通过大小、高度、圆角等属性进行补间过渡转换，容器内的元素可通过淡入淡出或共享元素的手法进行过渡。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151107.31502720030854619145342219097970:50001231000000:2800:1DE8303C2939310FF6CAA97174DCA63339B0ABD6E7C721218888D97F721F0BEC.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151108.12279543556641591264418395765589:50001231000000:2800:AAF3DE0E08A84A6FC8370195F1EF9BEE75C665D1D4412D2AD75CC548FE6B3A13.gif)
根据场景，可以将本文的案例分为以下两类。
| 场景分类  | 场景案例  | 实现方式  |
| --- | --- | --- |
| 共享元素转场  | 图片展开：双指放大  | 属性动画+节点迁移  |
| 图片展开：查看大图  | geometryTransition接口+位移缩放  |
| 图片移动：半模态  | 属性动画+节点迁移  |
| 图标（搜索框、头像等）展开  | geometryTransition接口+显示动画  |
| 共享容器转场  | 卡片展开  | Navigation自定义动画+位移缩放  |
| 列表展开  | geometryTransition接口+显示动画  |
| “图书”翻页展开一镜到底  | Navigation自定义动画+旋转  |
| 视频展开  | Navigation自定义动画+节点迁移  |
场景分类
场景案例
实现方式
共享元素转场
图片展开：双指放大
属性动画+节点迁移
图片展开：查看大图
geometryTransition接口+位移缩放
图片移动：半模态
属性动画+节点迁移
图标（搜索框、头像等）展开
geometryTransition接口+显示动画
共享容器转场
卡片展开
Navigation自定义动画+位移缩放
列表展开
geometryTransition接口+显示动画
“图书”翻页展开一镜到底
Navigation自定义动画+旋转
视频展开
Navigation自定义动画+节点迁移
一镜到底动效的实现需要转场能力和动画能力组合使用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151108.44312787236219053752061713757538:50001231000000:2800:D8AC722FE2C22025C72833FF0AA991817BA31F27AC5243F1F14860F193378795.png)
其中组件转场有三种方式实现，开发者可以根据需要选择合适的方式实现：
| 方式  | 特点  | 适用场景  |
| --- | --- | --- |
| 使用容器进行节点迁移  | 通过使用NodeController，将组件从一个容器迁移到另一个容器，在开始迁移时，需要根据前后两个布局的位置大小等信息对组件添加位移及缩放，确保迁移开始时组件能够对齐初始布局，避免出现视觉上的跳变现象。之后再添加动画将位移及缩放等属性复位，实现组件从初始布局到目标布局的一镜到底过渡效果。  | 适用于新建对象开销大的场景，如视频直播组件点击转为全屏等。  |
| 使用geometryTransition接口共享元素转场  | 利用系统能力，转场前后两个组件调用geometryTransition接口绑定同一id，同时将转场逻辑置于animateTo动画闭包内，这样系统侧会自动为二者添加一镜到底的过渡效果。  | 此方式适用于创建新节点开销小的场景。  |
| 使用Navigation自定义动画转场  | 进行路由跳转，customNavContentTransition事件提供自定义转场动画的能力。  | 适用于页面切换转场，如标题页和详情页之间的转场。  |
方式
特点
适用场景
使用容器进行节点迁移
通过使用NodeController，将组件从一个容器迁移到另一个容器，在开始迁移时，需要根据前后两个布局的位置大小等信息对组件添加位移及缩放，确保迁移开始时组件能够对齐初始布局，避免出现视觉上的跳变现象。之后再添加动画将位移及缩放等属性复位，实现组件从初始布局到目标布局的一镜到底过渡效果。
适用于新建对象开销大的场景，如视频直播组件点击转为全屏等。
使用geometryTransition接口共享元素转场
利用系统能力，转场前后两个组件调用geometryTransition接口绑定同一id，同时将转场逻辑置于animateTo动画闭包内，这样系统侧会自动为二者添加一镜到底的过渡效果。
此方式适用于创建新节点开销小的场景。
使用Navigation自定义动画转场
进行路由跳转，customNavContentTransition事件提供自定义转场动画的能力。
适用于页面切换转场，如标题页和详情页之间的转场。
使用容器进行节点迁移
NodeContainer作为一个占位容器组件，主要是用于自定义节点以及自定义节点树的显示和复用。NodeController提供了一系列生命周期回调，通过makeNode()回调返回一个FrameNode节点树的根节点。将FrameNode节点树挂载到对应的NodeContainer下。同时提供了aboutToAppear()、aboutToDisappear()、aboutToResize()、onTouchEvent()、rebuild()五个回调方法用于监听对应的NodeContainer的状态。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151108.70876064356057308954204877164556:50001231000000:2800:CC69CE861B48F9000D3D3E7B4E7192DF30802EB6D5D51A959C32DB82721FEDAB.gif)
举个简单的例子，例如上图，卡片状态可以分为两个形态，折叠态和展开态。开发者可以将折叠态和展开态分为两个节点NodeContainer1和NodeContainer2来控制二者之间的相互切换。NodeController触发onRemove()方法使NodeContainer1下树，调用update方法更新卡片的展开状态，节点迁移至NodeContainer2，并触发动画。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151108.73098533419337649323662670944969:50001231000000:2800:678B019A1F75A4EB03697109D2E950F4EE478B127D1DB9B32CF84AA75B3B0087.png)
使用geometryTransition接口共享元素转场
geometryTransition接口用于组件内隐式共享元素转场，在视图状态切换过程中提供丝滑的上下文继承过渡体验。
geometryTransition的使用方式为对需要添加一镜到底动效的两个组件使用geometryTransition接口绑定同一id，这样在其中一个组件消失同时另一个组件创建出现的时候，系统会对二者添加一镜到底动效。
geometryTransition绑定两个对象的实现方式使得geometryTransition区别于其他方法，最适合用于两个不同对象之间完成一镜到底。
使用Navigation自定义动画转场
Navigation通过customNavContentTransition事件提供自定义转场动画的能力，通过如下三步可以定义一个自定义的转场动画。
元素转场案例
图片展开一镜到底
-  图片使用双指放大转场显示图片详情页。 通过NodeContainer组件实现跨节点迁移，通过手势捏合来控制节点的上下树，达成一镜到底动效。
```typescript
// src/main/ets/feature/ImageLongTakeTransition/PinchToShareImage/PinchToShareImagePageOne.ets
@StorageProp('expand') @Watch('goToPageTwo') num1: number = 0;
// ...
goToPageTwo() {
let param: Record<string, Object> = {};
param['onBack'] = () => { this.restoreNodeController() };
this.pageInfo.pushPath({ name: 'PinchToShareImagePageTwo', param }, false);
this.imageGalleryNodeController = undefined;
}
```
```typescript
// src/main/ets/feature/ImageLongTakeTransition/PinchToShareImage/PinchToShareImagePageOne.ets
@StorageProp('expand') @Watch('goToPageTwo') num1: number = 0;
// ...
goToPageTwo() {
let param: Record<string, Object> = {};
param['onBack'] = () => { this.restoreNodeController() };
this.pageInfo.pushPath({ name: 'PinchToShareImagePageTwo', param }, false);
this.imageGalleryNodeController = undefined;
}
```
```typescript
// src/main/ets/feature/ImageLongTakeTransition/PinchToShareImage/PinchToShareImagePageTwo.ets
NavDestination() {
NodeContainer(this.imageGalleryNodeController)
}
.mode(NavDestinationMode.DIALOG)
.height('100%')
.width('100%')
.hideTitleBar(true)
.onReady((context: NavDestinationContext) => {
this.pageInfo = context.pathStack;
const param = context.pathInfo?.param as Record<string, Object>;
this.onBack = param['onBack'] as () => void;
})
.onBackPressed(() => {
AppStorage.setOrCreate('reset', new Date());
animateTo({ duration: 300, curve: Curve.EaseIn }, () => {
this.backToPageOne();
})
return true;
})
```
-  比如图片在九宫格中显示，点击查看大图，同时还支持手势下拉返回到九宫格。 设置geometryTransition属性将图片首页和大图页面的图片绑定同一id值，结合属性动画效果实现一镜到底效果。核心代码如下：
```typescript
// src/main/ets/feature/ImageLongTakeTransition/ShowLargeImageWithGesture/ShowLargeImageWithGesturePageOne.ets
NavDestination() {
Column() {
Grid(this.scroller) {
ForEach(this.data, (item: number) => {
GridItem() {
if (this.clickedIndex !== item || (this.isFirstPageShow)) {
Image($r(`app.media.img_${item % 9}`))
.width('100%')
.height('100%')
.objectFit(ImageFit.Cover)
.id('item2_' + item)
.onClick(() => {
this.onItemClick(item);
})
.geometryTransition(this.clickedIndex === item ? 'app.media.img_' + item.toString() : '')
.transition(TransitionEffect.opacity(0.99))
}
}
.width(px2vp(381))
.height(px2vp(381))
}, (item: number) => item + '')
}
.rowsTemplate('1fr 1fr 1fr')
.columnsTemplate('1fr 1fr 1fr')
.columnsGap(2)
.rowsGap(2)
.size({
width: px2vp(1169),
height: px2vp(1169)
})
.margin({ top: 16 })
}
}
.title(getResourceString($r('app.string.semiView_larger_image_modal'),this))
.height('100%')
.width('100%')
.onReady((context: NavDestinationContext) => {
this.pageInfo = context.pathStack;
})
```
```typescript
// src/main/ets/feature/ImageLongTakeTransition/ShowLargeImageWithGesture/ShowLargeImageWithGesturePageOne.ets
NavDestination() {
Column() {
Grid(this.scroller) {
ForEach(this.data, (item: number) => {
GridItem() {
if (this.clickedIndex !== item || (this.isFirstPageShow)) {
Image($r(`app.media.img_${item % 9}`))
.width('100%')
.height('100%')
.objectFit(ImageFit.Cover)
.id('item2_' + item)
.onClick(() => {
this.onItemClick(item);
})
.geometryTransition(this.clickedIndex === item ? 'app.media.img_' + item.toString() : '')
.transition(TransitionEffect.opacity(0.99))
}
}
.width(px2vp(381))
.height(px2vp(381))
}, (item: number) => item + '')
}
.rowsTemplate('1fr 1fr 1fr')
.columnsTemplate('1fr 1fr 1fr')
.columnsGap(2)
.rowsGap(2)
.size({
width: px2vp(1169),
height: px2vp(1169)
})
.margin({ top: 16 })
}
}
.title(getResourceString($r('app.string.semiView_larger_image_modal'),this))
.height('100%')
.width('100%')
.onReady((context: NavDestinationContext) => {
this.pageInfo = context.pathStack;
})
```
```typescript
// src/main/ets/feature/ImageLongTakeTransition/ShowLargeImageWithGesture/ShowLargeImageWithGesturePageOne.ets
onItemClick(index: number): void {
let param: Record<string, Object> = {};
this.needFollow = false;
this.clickedIndex = index;
param['selectedIndex'] = this.clickedIndex;
param['onIndexChange'] = (index: number) => {
this.onIndexChange(index);
};
param['onBackToFirstPage'] = () => {
this.onBack();
}
animateTo({
duration: 250,
curve: Curve.EaseIn,
}, () => {
this.pageInfo.pushPath({ name: 'ShowLargeImageWithGesturePageTwo', param: param }, false);
this.isFirstPageShow = false;
})
}
```
-  图片从页面向半模态弹窗中转场显示。 利用NodeContainer组件实现跨节点迁移，将半模态SheetOptions中的mode设置为SheetMode.EMBEDDED，该模式下新起的页面可以覆盖在半模态弹窗上，页面返回后该半模态依旧存在，半模态面板内容不丢失。通过属性动画，展示组件从初始界面至半模态页面的一镜到底动效，并在动画结束时关闭页面，并将该组件迁移至半模态页面。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151108.92489630143655277522857432020681:50001231000000:2800:AE205540FCCE9ED9A8BA356AB17CC909731DEE9CCAF8F39F0899639AAE1E50E0.gif)
```typescript
// src/main/ets/feature/ImageLongTakeTransition/PinchToShareImage/PinchToShareImagePageOne.ets
@StorageProp('expand') @Watch('goToPageTwo') num1: number = 0;
// ...
goToPageTwo() {
let param: Record<string, Object> = {};
param['onBack'] = () => { this.restoreNodeController() };
this.pageInfo.pushPath({ name: 'PinchToShareImagePageTwo', param }, false);
this.imageGalleryNodeController = undefined;
}
```
```typescript
// src/main/ets/feature/ImageLongTakeTransition/PinchToShareImage/PinchToShareImagePageTwo.ets
NavDestination() {
NodeContainer(this.imageGalleryNodeController)
}
.mode(NavDestinationMode.DIALOG)
.height('100%')
.width('100%')
.hideTitleBar(true)
.onReady((context: NavDestinationContext) => {
this.pageInfo = context.pathStack;
const param = context.pathInfo?.param as Record<string, Object>;
this.onBack = param['onBack'] as () => void;
})
.onBackPressed(() => {
AppStorage.setOrCreate('reset', new Date());
animateTo({ duration: 300, curve: Curve.EaseIn }, () => {
this.backToPageOne();
})
return true;
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151108.81002637217030463330999912842327:50001231000000:2800:BA9269942AC53FF8B5F42746CC4C134FA3A8E6D07C121FE31C9691902B36E366.gif)
```typescript
// src/main/ets/feature/ImageLongTakeTransition/ShowLargeImageWithGesture/ShowLargeImageWithGesturePageOne.ets
NavDestination() {
Column() {
Grid(this.scroller) {
ForEach(this.data, (item: number) => {
GridItem() {
if (this.clickedIndex !== item || (this.isFirstPageShow)) {
Image($r(`app.media.img_${item % 9}`))
.width('100%')
.height('100%')
.objectFit(ImageFit.Cover)
.id('item2_' + item)
.onClick(() => {
this.onItemClick(item);
})
.geometryTransition(this.clickedIndex === item ? 'app.media.img_' + item.toString() : '')
.transition(TransitionEffect.opacity(0.99))
}
}
.width(px2vp(381))
.height(px2vp(381))
}, (item: number) => item + '')
}
.rowsTemplate('1fr 1fr 1fr')
.columnsTemplate('1fr 1fr 1fr')
.columnsGap(2)
.rowsGap(2)
.size({
width: px2vp(1169),
height: px2vp(1169)
})
.margin({ top: 16 })
}
}
.title(getResourceString($r('app.string.semiView_larger_image_modal'),this))
.height('100%')
.width('100%')
.onReady((context: NavDestinationContext) => {
this.pageInfo = context.pathStack;
})
```
```typescript
// src/main/ets/feature/ImageLongTakeTransition/ShowLargeImageWithGesture/ShowLargeImageWithGesturePageOne.ets
onItemClick(index: number): void {
let param: Record<string, Object> = {};
this.needFollow = false;
this.clickedIndex = index;
param['selectedIndex'] = this.clickedIndex;
param['onIndexChange'] = (index: number) => {
this.onIndexChange(index);
};
param['onBackToFirstPage'] = () => {
this.onBack();
}
animateTo({
duration: 250,
curve: Curve.EaseIn,
}, () => {
this.pageInfo.pushPath({ name: 'ShowLargeImageWithGesturePageTwo', param: param }, false);
this.isFirstPageShow = false;
})
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151108.03417957832383916156540014905769:50001231000000:2800:2130B42630024B51DF5876C2A612C1DD25E5046262D3E7BD7689FB12D0E0FDB6.gif)
图标（搜索框、头像等）展开一镜到底
搜索框点击后，转场到搜索结果页面。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151108.90153846671975091514505354897235:50001231000000:2800:939DBEF3A1AA0282E4F20F8709170CDCD948F3814678F6D6B48BA1A3A8EEC510.gif)
将搜索框首页与搜索框页面的Search组件同时设置geometryTransition属性，并绑定同一id值。设置显式动画和transition属性的转场效果，实现搜索框的一镜到底效果。
```typescript
// src/main/ets/feature/SearchLongTakeTransition/SearchLongTakeTransitionPageOne.ets
private showSearchPage(): void {
this.transitionEffect = TransitionEffect.OPACITY;
animateTo({
curve: curves.interpolatingSpring(0, 1, 342, 38)
}, () => {
this.pageInfos.pushPath({ name: 'SearchLongTakeTransitionPageTwo' }, false);
})
}
build() {
NavDestination() {
Column({ space: 20 }) {
Search({ placeholder: 'Search' })
.height(40)
.placeholderColor($r('sys.color.mask_secondary'))
.width('100%')
.geometryTransition('SEARCH_ONE_SHOT_DEMO_TRANSITION_ID', { follow: true })
.backgroundColor('#0D000000')
.defaultFocus(false)
.focusOnTouch(false)
.focusable(false)
.onTouch((event: TouchEvent) => {
if (event.type === TouchType.Up) {
this.showSearchPage();
}
})
}
.size({
width: '90%',
height: '100%'
})
}
.transition(TransitionEffect.OPACITY)
.backgroundColor('#F1F3F5')
.title(getResourceString($r('app.string.search_title'), this))
.onReady((context: NavDestinationContext) => {
this.pageInfos = context.pathStack;
})
.onBackPressed(() => {
this.transitionEffect = TransitionEffect.IDENTITY;
this.pageInfos.pop(true);
return true;
})
}
```
容器转场案例
卡片、列表展开一镜到底
在瀑布流或列表流布局中，当用户点击其中一个卡片或列表项时，应用将执行平滑的转场动画，引导用户从概览页面切换到详情页面。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151108.46456765180405829360365189249828:50001231000000:2800:3BF21D1D1086F3FD2ACA1C433D1C2FFE43E32D19414673A59D7D15F7B2840AC1.gif)
使用WaterFlow和LazyForEach实现卡片列表瀑布流。利用Navigation的自定义导航转场动画能力，通过customNavContentTransition配置列表页与详情页的自定义导航转场动画，结合componentSnapshot将卡片进行截图避免跳转页面白屏。
列表一镜到底效果图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151109.11588013412683078898869113844062:50001231000000:2800:9FD04835EF055265C75948CF23DA0BFBF5E9F338CF2B7F004D16C795BD3ACBD6.gif)
将列表项与详情页面同时设置geometryTransition属性，并绑定同一id值。每个列表项设置显式动画和transition属性的转场效果，实现列表展开的一镜到底效果。
“图书”翻页展开一镜到底
阅读类应用中，点击一本“图书”的图标后，模拟图书翻页展开的效果，转场到书本内容页面，同时支持手势返回。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151109.68180833442954123160704986685382:50001231000000:2800:77675D9B4777BF011310F373D586F8D9A2BD8900FB6A283502BC37D2F62095BB.gif)
利用Navigation的自定义导航转场动画能力，通过customNavContentTransition配置书籍页与详情页的自定义导航转场动画实现图书翻页一镜到底效果。使用rotate属性实现书籍封页的旋转效果。
```typescript
// src/main/ets/feature/BookFlipLongTakeTransition/BookFlipLongTakeTransitionPageOne.ets
private onColumnClicked(bookId: string, bookCoverUrl: string, toBookId?: string, prePageCallback?: () => void): void {
CustomTransition.getInstance().unRegisterNavParam(this.pageId);
const fromCardItemInfo: RectInfoInPx =
ComponentAttrUtils.getRectInfoById(WindowUtils.window.getUIContext(), bookId);
let param: Record<string, Object> = {};
param['fromCardItemInfo'] = fromCardItemInfo;
param['bookCoverUrl'] = bookCoverUrl;
if (toBookId) {
const toCardItemInfo: RectInfoInPx =
ComponentAttrUtils.getRectInfoById(WindowUtils.window.getUIContext(), toBookId);
param['toCardItemInfo'] = toCardItemInfo;
}
if (prePageCallback) {
param['prePageCallback'] = prePageCallback;
}
this.pageInfos.pushPath({ name: 'BookFlipLongTakeTransitionPageTwo', param: param });
}
build() {
NavDestination() {
Scroll() {
Column({ space: 12 }) {
// 一镜到底返回至第一个位置
Grid() {
ForEach(this.dataSource, (item: BookItem, index: number) => {
GridItem() {
Image($r(item.coverImageUrl))
.id(item.id)
.width('100%')
.onClick(() => {
this.onColumnClicked(item.id, item.coverImageUrl, this.dataSource[0].id, () => {
this.dataSource.sort((a, b) => b.timestamp - a.timestamp);
})
this.dataSource[index].timestamp = Number(new Date());
})
}
.width(this.columnWidth)
}, (item: BookItem) => JSON.stringify(item))
}
.padding({
left: 12,
right: 12,
top: 12
})
.columnsTemplate(this.columnType)
.columnsGap(10)
.rowsGap(10)
// 一镜到底返回至原位置
Column({ space: 12 }) {
Text($r('app.string.recent_reading'))
.fontSize(16)
.fontWeight(FontWeight.Medium)
.fontColor(Color.Gray)
Swiper(this.swiperController) {
ForEach(this.recentData, (item: BookItem) => {
GridItem() {
Image($r(item.coverImageUrl))
.id(item.id)
.onClick(() => {
this.onColumnClicked(item.id, item.coverImageUrl);
})
}
}, (item: BookItem) => JSON.stringify(item))
}
.indicator(false)
.displayCount(3)
.loop(false)
.itemSpace(10)
}
.padding({
left: 12,
right: 12
})
.alignItems(HorizontalAlign.Start)
}
}
}
// ...
}
```
视频展开一镜到底
视频组件从一个页面向目标页面的转场，在一镜到底的过程中，视频需要持续播放。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151109.76852289357272126306316316483910:50001231000000:2800:C0E616739CCD8AFCD69762E77604317C7EAC04CF7E6402BD8337452DFB80EFD1.gif)
使用WaterFlow和LazyForEach实现卡片列表瀑布流。利用NodeController实现组件的跨节点迁移，通过customNavContentTransition配置概览页与视频详情的自定义导航转场动画，给节点的迁移过程赋予一镜到底效果。
```typescript
// src/main/ets/feature/VideoLongTakeTransition/CustomNavigation/CustomNavigationPageOne.ets
NavDestination() {
WaterFlow() {
LazyForEach(this.dataSource, (_: CardAttr, index: number) => {
FlowItem() {
VideoCardComponent({
isPlaying: false,
index,
onColumnClicked: (prePageCallback) => {
this.onColumnClicked(`xComponent_${index}`, prePageCallback)
}
})
}
.width('100%')
.borderRadius(10)
.clip(true)
.id('FlowItem_' + index.toString())
}, (item: string) => item)
}
.edgeEffect(EdgeEffect.Spring)
.onScrollIndex((first: number) => {
this.scrollFirstIndex = first;
})
.padding(12)
.columnsTemplate(this.columnType)
.columnsGap(12)
.rowsGap(10)
.width('100%')
.height('100%')
}
.backgroundColor(Constants.DEFAULT_BG_COLOR)
.title(getResourceString($r('app.string.vedio_title'),this))
.onReady((context: NavDestinationContext) => {
this.pageInfos = context.pathStack;
if (context.navDestinationId) {
this.pageId = context.navDestinationId;
}
})
.onDisAppear(() => {
CustomTransition.getInstance().unRegisterNavParam(this.pageId);
})
```
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-global-state-management-state-store
爬取时间: 2025-05-01 09:36:05
来源: Huawei Developer
概述
使用ArkUI开发页面时，多组件状态共享是我们经常会遇到的场景；ArkUI通过装饰器，例如@State+@Prop/@Link、@Provide+@Consume实现父子组件状态共享，但是这样会造成状态数据耦合。
StateStore作为ArkUI状态与UI解耦的解决方案，支持全局维护状态，优雅地解决状态共享的问题。让开发者在开发过程中实现状态与UI解耦，多个组件可以方便地共享和更新全局状态，将状态管理逻辑从组件逻辑中分离出来，简化维护。
StateStore提供了下列功能特性：
ArkUI状态管理现状
在多组件状态共享的场景中，我们常常遇到的问题是，当多个组件需要共享相同的状态时，必须通过它们的共同父组件来传递和维护这些状态数据。
例如，我们实现如下图待办列表的新增与删除功能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151109.53131529791001013907454768504664:50001231000000:2800:8C17594C4A1FF0F6DE562FE4605937D08F77C8CED5DDB700EBBD9C790BFE9AF6.png)
新增和删除功能按钮分别位于两个兄弟组件中。在开发时，父组件需要维护一个listDatas列表，并通过@Link装饰器实现数据的双向同步，从而实现兄弟组件之间的状态同步。删除功能和新增功能逻辑分别由两个子组件处理，但是这两个组件都需要引入与UI渲染无关的listDatas数据，造成了状态与UI的高耦合。使得状态管理变得复杂，难以维护和扩展。组件结构图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151109.35738433055254501042153822856014:50001231000000:2800:F65E7851114941606FE1A0C96797DE34DE3F2F152F293D5BB9252E43FD41026A.png)
引入StateStore库后，开发者可以将listDatas数据存储在全局仓库（Store）中，组件从Store中获取数据进行UI渲染，并通过向Store发送事件来更新数据。这样，状态更新逻辑被集中管理，组件无需额外引入状态进行逻辑处理，从而实现了状态与UI的低耦合。组件结构图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151109.74739092394030359886418258222124:50001231000000:2800:4BB6EABBE3004301361847A5E08F440E59B9B3F72BD124AA9AEBBCD2D70776D2.png)
实现原理
StateStore运行原理是基于ArkUI的状态管理特性（@Observed和@ObservedV2）实现全局状态管理。统一由UI分发事件指令，状态管理仓库触发对应的状态更新逻辑，实现状态与UI解耦。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151109.93045303322190026642221300227511:50001231000000:2800:1524433AF2157DF8077A799ED6242EF3180B7CFED9B624DC67EDF0E7AD953E26.png)
核心概念解释
-  View构成了用户界面，它包含了丰富的页面UI组件，并响应用户操作。当用户和UI进行交互时，View会通过dispatch方法分发Action事件，从而触发状态更新的流程。
-  Store作为状态管理的核心，主要向外部提供两个关键方法：getState()和dispatch(action)。getState()方法允许外部获取当前的状态信息，而dispatch(action)方法则用于接收并处理来自UI的Action事件。
-  Reducer是一个专门负责状态刷新逻辑的函数。它会根据传入的Action事件指令，对状态进行更新。每一个Action事件都携带着特定的指令，Reducer会根据这些指令来精确地修改状态。
-  Dispatch是UI侧与Store进行交互的桥梁，也是UI侧触发状态更新的唯一途径。UI侧通过调用Dispatch方法，将封装了事件类型的Action对象发送到Store，从而触发后续的状态更新流程。
-  Action是一个用于描述指示发生了何种事件的对象。它包含了两个重要的属性：type和payload。type属性用于标识事件的类型，而payload属性则携带了事件相关的具体数据。通过这两个属性，Action能够完整地描述一个事件，并引导Reducer进行状态更新。
UI刷新原理
数据改变刷新UI的能力依赖系统侧@Observed/@ObservedV2对数据的观测能力，StateStore不接管数据驱动UI更新。
以上概念与基本使用参考StateStore
开发步骤
1.  开发者使用@Observed或@ObservedV2修饰业务数据，并生成实例对象。
2.  开发者需要定义状态处理函数，该函数类型为Reducer。该函数负责根据业务逻辑来更新数据。
3.  为了集中管理状态更新，开发者使用StateStore.createStore方法来创建一个状态管理仓库（即Store对象）。在调用createStore方法时，需要传入业务数据的对象实例和业务逻辑函数，以便为Store对象绑定相应的初始状态和Reducer。
4.  在组件内部，开发者通过调用Store对象的getState()方法来获取业务数据，并据此编写UI结构。这样，组件即可根据获取到的数据进行渲染。
5.  这一步的目的是告诉store对象，你要做什么；例如，我们需要添加某个数据，则创建一个添加事件——AddAction。 事件定义好后，需要某个操作来触发事件，即我们在UI中通过dispatch(AddAction)发送该添加事件给store，接受到事件后会通知实际处理者——Reducer，根据接受到的AddAction事件处理对应的添加逻辑，修改状态数据。 Reducer类型函数的逻辑被触发后，状态会随之更新。借助系统提供的@Observed或@ObservedV2装饰器的监听能力，UI能够与状态保持同步刷新。
6.  这一步的目的是告诉store对象，你要做什么；例如，我们需要添加某个数据，则创建一个添加事件——AddAction。
7.  事件定义好后，需要某个操作来触发事件，即我们在UI中通过dispatch(AddAction)发送该添加事件给store，接受到事件后会通知实际处理者——Reducer，根据接受到的AddAction事件处理对应的添加逻辑，修改状态数据。
8.  Reducer类型函数的逻辑被触发后，状态会随之更新。借助系统提供的@Observed或@ObservedV2装饰器的监听能力，UI能够与状态保持同步刷新。
1.  这一步的目的是告诉store对象，你要做什么；例如，我们需要添加某个数据，则创建一个添加事件——AddAction。
2.  事件定义好后，需要某个操作来触发事件，即我们在UI中通过dispatch(AddAction)发送该添加事件给store，接受到事件后会通知实际处理者——Reducer，根据接受到的AddAction事件处理对应的添加逻辑，修改状态数据。
3.  Reducer类型函数的逻辑被触发后，状态会随之更新。借助系统提供的@Observed或@ObservedV2装饰器的监听能力，UI能够与状态保持同步刷新。
使用StateStore实现状态与UI解耦
场景描述
在开发复杂应用时，状态与UI的强耦合常常导致代码臃肿、难以维护，尤其是在多个组件需要共享状态时，这种问题尤为突出。使用StateStore，开发者可以将状态管理逻辑完全从UI中抽离，实现状态的集中式管理和更新，进而简化代码结构、提高可维护性。
本节以备忘录应用为例，演示如何通过StateStore实现多个组件的状态共享与更新，同时保持UI层的纯粹性。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151110.77954901984694973558262008573382:50001231000000:2800:443B2DAF12E09D8DDBF474C658CF87E9F63FE2FC89C5CECFA433D6B8F0BFC5E2.png)
开发步骤
1.  使用@ObservedV2定义页面需要的数据TodoList、TodoItem。
```typescript
@ObservedV2
export class TodoStoreModel {
@Trace todoList: TodoItemData[] = [];
@Trace isShow: boolean = false;
addTaskTextInputValue: string = '';
// ...
@Computed
get uncompletedTodoList(): TodoItemData[] {
return this.todoList.filter(item =>!item.selected);
}
@Computed
get completedTodoList(): TodoItemData[] {
return this.todoList.filter(item => item.selected);
}
}
```
2.  如下例子中：Index组件内，通过getState()方法获取状态数据并绑定UI，通过dispatch触发GetTodoList事件获取全量数据并更新状态；TodoItem子组件中通过dispatch方法派发一个CompleteTodoItem事件来改变全局状态，将当前项设置为已完成。
通过StateStore库的使用，在UI上就没有任何状态更新逻辑，UI层面只需要关注界面描述和事件分发，保持了UI层的纯粹性。UI界面通过事件触发dispatch操作发送Action给Store来执行具体的逻辑，达到UI和状态解耦的效果。
子线程同步数据库
场景描述
在HarmonyOS开发中，子线程无法直接修改或者操作UI状态。这种限制导致子线程在完成复杂任务处理后，需要额外的逻辑将任务结果同步到主线程进行状态更新。
为了解决这一问题，StateStore提供了SendableAction机制，使开发者可以在子线程中采用与主线程一致的方式分发Action，无需关注状态更新逻辑。
在本节中，我们将通过在子线程中同步数据库的场景，介绍如何在子线程中发送状态更新事件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151110.62249931382546473105843279799098:50001231000000:2800:EE2787A5CA856C903FC39FACE87467024B2280012E343CCD92591D12CC0B69EC.gif)
上图效果图中，用户点击同步数据库按钮，子线程去读写数据库，同时更新进度条。
开发步骤
```typescript
@Sendable
export class ToDoItemSendable implements lang.ISendable {
id: number;
detail: string;
selected: boolean;
state: number;
constructor(id: number, detail: string, selected: boolean = false) {
this.id = id;
this.selected = selected;
this.detail = detail;
this.state = 0;
}
}
```
1.  通过StateStore.createSendableAction方法定义一个sendableAction事件，它的作用于Action的作用一致，在子线程中需要使用taskpool的sendData发送一个sendableAction事件。 createSendableAction方法接受三个参数分别是：
2.  主线程中使用onReceiveData接收sendData发送的sendableAction事件，然后调用StateStore.receiveSendableAction来执行这个事件通知reducer修改状态。
状态更新日志埋点
场景描述
在状态管理过程中，复杂业务逻辑往往需要在状态更新前后插入额外的处理逻辑，例如记录状态更新日志、请求鉴权等。这些逻辑如果直接耦合在状态管理的核心流程中，会导致代码冗杂且难以维护。
为了解决这一问题，中间件应运而生。中间件是一种灵活的扩展机制，能够在Action分发到Reducer处理的流程中插入自定义逻辑，从而解耦通用功能和核心状态管理逻辑。
在本节中，我们将通过日志埋点场景，展示如何利用中间件优雅地扩展状态管理功能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151110.49217782929712171862125972045054:50001231000000:2800:DDE988F2749DC611610E9AAA712F78681A6D9CBF87255135099F42E6F0337A04.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151110.27214905532328683230381671304312:50001231000000:2800:BB6BDDB6AC805D9415EE8BF17A9259FCDA66A79CB51BF8B647866AA4EE69C0D9.png)
开发步骤
1.  开发者根据业务逻辑需要来实现beforeAction和afterAction两个钩子方法，分别在状态更新前后执行自定义逻辑。
在Store中注册LogMiddleware后，所有状态更新逻辑执行前都会触发LogMiddleware的beforeAction 逻辑打印日志，状态更新逻辑执行后也会触发afterAction 逻辑打印日志。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-picture-preview
爬取时间: 2025-05-01 09:36:22
来源: Huawei Developer
概述
图片预览器是常见的开发应用场景。在诸多日常使用的软件中，图片预览器都是提升用户体验的关键组件。它允许用户在上传、分享或编辑图片之前，先对图片进行预览，从而确保图片的质量和效果符合预期。本文章将深入探讨实现图片预览器过程中的几个复杂场景，具体包括：图片如何“跟手”，如何计算并合理限制图片的边界，以及如何解决Swiper组件与滑动手势之间产生的冲突问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151110.44995458894039798256233376372703:50001231000000:2800:EB538AEFBF06BB7D71137C4E925106A36C12CD61368484AA62BC2E9FB7514E80.gif)
实现原理
场景描述
基础的图片预览器功能包括如下操作：
其中，缩放图片是通过矩阵变换功能matrix4来实现的，图片的平移是通过属性translate来实现的。
关键技术
图片预览器中的图片查看功能，主要由大图界面来承担，交互操作相对复杂。下面，简要梳理一下大图界面中基本手势的处理与计算方式。
“跟手”的原理
“跟手”操作细分为两大类别：平移“跟手”与缩放“跟手”。
在平移“跟手”中，无论用户的手指如何在屏幕上滑动，其触摸点相对于图片所保持的百分比位置始终保持不变。缩放“跟手”，则是在图片依据用户手势进行缩放调整时，用户手势的中心点不仅相对于屏幕上的坐标保持不变，而且相对于图片内容的百分比位置也保持不变。如下图所示，屏幕是蓝色区域，初始图片是橙色区域，放大后的图片是灰色区域。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151110.15387522013398186573709626242520:50001231000000:2800:B13AC75523C89E853CC1DD2DCE4DC1C99978B23715283B5E41E982B06974E086.png)
假定当前图片位置是<lastScale, offsetX, offsetY>，控件原始宽高为<w, h>，本次缩放图片的缩放值为scale，缩放的中心点百分比位置为<centerX, centerY>，偏移为<offX, offY>，计算终点位置设为<scale', offsetX', offsetY'>。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151110.24684714804234657312376850247828:50001231000000:2800:8390486CBD36B3D9BF2D535C74F3BF4EF9F66FDE073765D4BBC4510F03EEC192.png)
如上图所示，假定缩放时，未发生偏移，蓝色看作交互开始时的控件，橙色是交互后的控件，如果缩放中心点在图片中心（图1），那么控件最终的offset没有任何变化；如果缩放中心在最左边缘（图3），在放大的过程中，整个控件的中心向右发生了偏移。由此，可以计算出图片的最终位置。其中，图2、图3中的问号代表图片的偏移量，而图中的橙色圆点是图片缩放操作的中心点。
-  = lastScale * scale
-  = (offsetX + offX) +  (0.5 - centerX) * 控件大小变化之差 = (offsetX + offX) +  (0.5 - centerX) * (w * lastScale - w * lastScale * scale) = (offsetX + offX) +  (0.5 - centerX) * w * (scale - 1) * lastScale = (offsetX + offX) +  (0.5 - centerX) * w * (1 - scale) * lastScale
-  = (offsetY + offY) + (0.5 - centerY) * h * (1 - scale) * lastScale 缩放中心百分比位置<centerX , centerY>计算。如下图，橙色为手机屏幕，触摸点反馈的坐标(x,y)是相较屏幕左上角的（假设控件布满全屏）。
-  = ( 触摸点坐标x- X方向图片左上角的坐标）/  图片的宽度 = ( 触摸点坐标x- ( ( 组件屏幕的宽度 - 当前图片的宽度) / 2 +上次图片X方向的偏移量)) / 图片的宽度
-  = ( 触摸点坐标y- Y方向图片左上角的坐标 ) /  图片的高度 = ( 触摸点坐标y- ( ( 组件屏幕的高度 - 当前图片的高度) / 2 +上次图片Y方向的偏移量)) / 图片的高度
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151110.97172912181998028199657161128338:50001231000000:2800:FCE5A7C669146598E08CDDE10864A7D4031C4DBB81C991786FF0DEEFBB58272A.png)
边界限制的原理
边界计算涉及两个方面：当前图片显示边界计算、offset范围计算。
假定下面两个图中显示区域为黑框区域，当前放大倍率是curScale。
如下图，当X方向offset到达上界时图片上边缘x坐标等于0：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151110.55940397051911043769273772510772:50001231000000:2800:FF62F0E058DEF6C568A2CA87F6EDB38C1F7B3F87202287393E874B5B5048607D.png)
到达下界时，图片右边缘与显示区域右边缘重合：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151111.47615871178338229232230483464871:50001231000000:2800:715A7A233D8E366803029A7AB6EE1164DDCEC1FAF9CAE13B6C17E9C4DB680376.png)
Y方向同理，上下界为：
场景实现
跟手的实现
跟手技术细分为两大类别：平移“跟手”与缩放“跟手”，接下来，将对这两者进行讲解。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151111.23682265453510619624630966860823:50001231000000:2800:E76A35146823B13570197150231C18689D780EC517051F125C3B1F6ABA9BFB64.gif)
1.  = Math.max((centerX - ((this.componentWidth - ( (this.imageWidth * this.lastScale))) / 2 + this.lastOffsetX)) / (this.imageWidth * this.lastScale), 0) = Math.max((捏合手势中心点的X轴坐标 - ((组件屏幕的宽度 - (图片的宽度 * 上次图片的缩放值)) / 2 + 上次图片Y方向的偏移量)) / ( 图片的宽度 * 上次图片的缩放值 ), 0) = Math.max((centerY - ((this.componentHeight - (this.imageHeight * this.lastScale)) / 2 + this.lastOffsetY)) / (this.imageHeight * this.lastScale), 0) = Math.max((捏合手势中心点的Y轴坐标 - ((组件屏幕的高度 - (图片的高度 * 上次图片的缩放值)) / 2 + 上次图片Y方向的偏移量)) / (图片的高度 * 上次图片的缩放值), 0)
2.  = Math.max((centerX - ((this.componentWidth - ( (this.imageWidth * this.lastScale))) / 2 + this.lastOffsetX)) / (this.imageWidth * this.lastScale), 0) = Math.max((捏合手势中心点的X轴坐标 - ((组件屏幕的宽度 - (图片的宽度 * 上次图片的缩放值)) / 2 + 上次图片Y方向的偏移量)) / ( 图片的宽度 * 上次图片的缩放值 ), 0)
3.  = Math.max((centerY - ((this.componentHeight - (this.imageHeight * this.lastScale)) / 2 + this.lastOffsetY)) / (this.imageHeight * this.lastScale), 0) = Math.max((捏合手势中心点的Y轴坐标 - ((组件屏幕的高度 - (图片的高度 * 上次图片的缩放值)) / 2 + 上次图片Y方向的偏移量)) / (图片的高度 * 上次图片的缩放值), 0)
-  = Math.max((centerX - ((this.componentWidth - ( (this.imageWidth * this.lastScale))) / 2 + this.lastOffsetX)) / (this.imageWidth * this.lastScale), 0) = Math.max((捏合手势中心点的X轴坐标 - ((组件屏幕的宽度 - (图片的宽度 * 上次图片的缩放值)) / 2 + 上次图片Y方向的偏移量)) / ( 图片的宽度 * 上次图片的缩放值 ), 0)
-  = Math.max((centerY - ((this.componentHeight - (this.imageHeight * this.lastScale)) / 2 + this.lastOffsetY)) / (this.imageHeight * this.lastScale), 0) = Math.max((捏合手势中心点的Y轴坐标 - ((组件屏幕的高度 - (图片的高度 * 上次图片的缩放值)) / 2 + 上次图片Y方向的偏移量)) / (图片的高度 * 上次图片的缩放值), 0)
边界限制的实现
1.  调用自定义initCurrentImageInfo()方法，计算出当前图片的宽度this.imageModel.imageWidth和高度this.imageModel.imageHeight。 调用自定义windowSize()方法，计算出当前组件的宽度this.componentWidth和高度this.componentHeight。
2.  当图片滑动至左边界或右边界时，this.isDisableSwipe会被设置为false；此时，Swiper组件将激活滑动切换功能，允许用户切换图片。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151111.64401733907257203331877813060637:50001231000000:2800:B5991FA18C1D3053CA168FFAA0E7E6D38CD8E13D80841550D0450C3FEEEE674B.gif)
实现Swiper组件与滑动手势冲突的解决方案
当Swiper组件与PanGesture滑动手势事件在同一组件上并发作用时，两者之间的冲突会导致Swiper无法正常切换图片。下面，将详细讲解如何有效解决Swiper组件与滑动手势之间的冲突问题。
常见问题
在Swiper组件中，当为图片子组件配置了PanGesture后，swiper无法正常翻页，该如何解决手势冲突？
是用Swiper组件的disableSwipe属性，进行动态赋值，在图片保持默认尺寸或图片在放大状态下已触及边界时，将disableSwipe属性设置为true，从而使得Swiper能够切换图片；当图片处于放大状态且尚未到达边界时，则将disableSwipe属性设为false，此时Swiper的切换功能将被禁用。
当图片被放大后，若在拖动图片的过程中，该如何控制其边界，确保图片不会超出显示区域的界限？
该问题涉及到图片边界的约束。主要涉及两个方面：当前图片显示边界计算以及offset范围计算。当前图片显示边界计算可得出当前图片显示的位置，左右上下是否与显示区域边界对齐，如果已经对齐，则不能继续往某个方向继续拖动。平移/缩放时必须对offset作限制，否则图片将被移出显示区域或是手势结束后周围有黑边。只需在手势交互时根据当前的scale计算得出offset的范围即可（超出边界时取边界作为结果），即可对图片边界进行限制。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-page-brightness-settings
爬取时间: 2025-05-01 09:36:37
来源: Huawei Developer
概述
在“视频播放”和“付款码展示”这两种典型场景下，应用需要在不同的页面分别设置不同的屏幕亮度，用户也可以自定义调节屏幕亮度，并且随着页面跳转而自动恢复系统亮度设置。
本文将这两种典型场景拆分为三个功能，让开发者理解并掌握页面亮度设置开发的流程与细节。
原理
当前亮度设置的能力由窗口提供，设置亮度后，如果没有再次修改，亮度将不会发生变化（仅在应用内生效，退出应用恢复系统默认亮度）。
窗口作为亮度设置的媒介，窗口的改变会使得该窗口下所有页面的亮度都跟随改变，所以需要一套记录页面和监听页面变化的机制，动态设置不同页面下的亮度。
视频播放页面亮度调节
场景描述
视频播放场景，支持用户在视频页调节屏幕亮度，调整完亮度退出页面后其他页面仍为系统亮度，再次进入视频页，屏幕亮度会自动恢复成页面之前保存的亮度。
开发步骤
调节屏幕亮度：
1.维护页面与亮度的映射关系
```typescript
private static brightnessMap: Map<string, number> =
new Map([[Constants.NAV_DESTINATION_DEFAULT, this.DEFAULT_BRIGHTNESS],
[Constants.NAV_DESTINATION_ITEM_PAY_CODE, this.MAX_BRIGHTNESS]]);
```
2.在视频播放器组件上添加滑动组件Slider
3.通过滑动组件调节屏幕亮度，并将调节的亮度值缓存
4. 返回首页，恢复屏幕默认亮度，重新进入视频播放页，恢复最后一次在视频播放页设置的亮度
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151111.37299251513327583870740203470928:50001231000000:2800:79D9696891686794CB39976118EE0C0130A0B835358E2D0556D47BC86588640B.gif)
【说明】录屏无法录制亮度变化，以真机为准
视频播放时页面常亮设置
场景描述
视频播放场景，在视频播放期间，即使用户没有屏幕交互操作，也希望保持屏幕常亮，直至视频播放完成或退出视频播放页。
开发步骤
1.视频播放时保持屏幕常亮，暂停或退出页面，取消屏幕常亮
2.设置屏幕常亮接口
```typescript
/**
* Keep screen brightness
*
* @param isKeepOn true：keep；false:cancel keep
*/
public static setWindowKeepScreenState(isKeepOn: boolean): void {
try {
BrightnessUtil.windowClass?.setWindowKeepScreenOn(isKeepOn, (err: BusinessError) => {
const errCode: number = err.code;
if (errCode) {
hilog.error(0x0000, TAG, `Failed set window keep screen state, errorCode: ${err.code}`);
return;
}
hilog.info(0x0000, TAG, `Success set window keep screen state`);
});
} catch (err) {
hilog.error(0x0000, TAG, `Failed set window keep screen state, errorCode: ${err.code}`);
}
}
```
实现效果
见图1 视频播放
【说明】录屏无法录制亮度变化，以真机为准
付款码页面高亮设置
场景描述
一些包含支付功能的应用，用户进入付款码页面，应用自动设置屏幕最高亮度，退出付款码页面，恢复屏幕默认亮度。
开发步骤
1.内存中维护一个页面与亮度的映射关系
```typescript
private static brightnessMap: Map<string, number> =
new Map([[Constants.NAV_DESTINATION_DEFAULT, this.DEFAULT_BRIGHTNESS],
[Constants.NAV_DESTINATION_ITEM_PAY_CODE, this.MAX_BRIGHTNESS]]);
```
2.监听页面切换事件，进入付款码页面，设置高亮，返回首页，恢复屏幕默认亮度
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151111.56108754151259446643420630075615:50001231000000:2800:768558CB650EB94010C1E11A44FC59960B019492BE0B1722230D9AFF5E831673.gif)
【说明】录屏无法录制亮度变化，以真机为准
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-common-list-flows
爬取时间: 2025-05-01 09:36:58
来源: Huawei Developer
概述
列表流是采用以“行”为单位进行内容排列的布局形式，每“行”列表项通过文本、图片等不同形式的组合，高效地显示结构化的信息，当列表项内容超过屏幕大小时，可以提供滚动功能。列表流具有排版整齐、重点突出、对比方便、浏览速度快等特点。同时列表流也具有非常广泛的使用场景，例如：应用首页、通讯录、音乐列表、购物清单等。
列表流主要使用List组件，按垂直方向线性排列子组件ListItemGroup或ListItem，混合渲染任意数量的图文视图，从而构建列表内容。在实际场景中，一般会根据需要，结合其它基础组件，形成相对复杂的交互功能。
本文将介绍以下列表流场景的实现：
多类型列表项场景
场景描述
List组件作为整个首页长列表的容器，通过ListItem对不同模块进行视图界面定制，常用于门户首页、商城首页等多类型视图展示的列表信息流场景。
本场景以应用首页为例，将除页面顶部搜索框区域的其它内容，放在List组件内部，进行整体页面的构建。进入页面后，下滑刷新模拟网络请求；滑动页面列表内容，景区标题吸顶；滑动到页面底部，上滑模拟请求添加数据。
| 页面整体结构图  | 页面效果图  |
| --- | --- |
|   |   |
页面整体结构图
页面效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151111.55366775698472135057923391190843:50001231000000:2800:4CFABD36BCB83C31EF9BAFA924786F459007A66B17DA937DACBEC03D532AA22C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151112.99846051447899734610924182605680:50001231000000:2800:F743EBE9FCA74442F7F869CC9F416F0E2353773FD4BE0511D47344B0B276B0E8.png)
实现原理
根据列表内部各部分视图对应数据类型的区别，渲染不同的ListItem子组件。
Refresh组件可以进行页面下拉操作并显示刷新动效，List组件配合使用Swiper、Grid等基础组件用于页面的整体构建，再通过List组件的sticky属性、onReachEnd()事件和Refresh组件的onRefreshing()事件，实现下滑模拟刷新、上滑模拟添加数据及列表标题吸顶的效果。
开发步骤
1.  实现效果：
2.  实现效果：
3.  实现效果：
4.  实现效果：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151112.87252085328753821994051579438371:50001231000000:2800:B19EB10BA8AD1F5F7E1A4307775BBB4BFE86B02D8A85BCEF0CB7A0B1EA552CCE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151112.40923094616911250730065551168620:50001231000000:2800:FFD464C8377E909EC733ED4D0CB69DAE581E79D4BC8A6EDD8804451F7DB756DB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151112.07699793439415689616066109911639:50001231000000:2800:8B40D561AE1E43900B4A5690AFB7AAD8F1160312BE9A0F4F64036016B243DDCC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151112.60462182345813952282091987693710:50001231000000:2800:C1E7AFEA05AAC876F4F16E32003978ABF5D9F07EFDBC7A4B69E26FB821147875.png)
实现效果
| 模拟下拉刷新+标题吸顶效果  | 上滑加载更多效果  |
| --- | --- |
|   |   |
模拟下拉刷新+标题吸顶效果
上滑加载更多效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151112.48074466585534593226354186964312:50001231000000:2800:34D7D02486B22AF5CD50D3153132FD25AA91BDBCEB4E2F8DE11CDB5B2B42F897.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151112.47025689239057623100408453255783:50001231000000:2800:1BBF14805959DF56FAF3B5529210084F8487B73923329FB24734BE6AAFF74556.gif)
Tabs吸顶场景
场景描述
Tabs嵌套List的吸顶效果，常用于新闻、资讯类应用的首页。
本场景以Tabs页签首页内容为例，在首页TabContent的内容区域使用List组件配合其它组件，构建下方列表数据内容。进入页面后，向上滑动内容，中间Tabs页签区域实现吸顶展示的效果。
| 页面整体结构图  | 页面效果图  |
| --- | --- |
|   |   |
页面整体结构图
页面效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151112.15439283505458134217085429743905:50001231000000:2800:74996BE7C225A9F075A987D69ACDC3B5B52371E3253CCCCE071A0DF888462C66.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151113.27261259730574479390862600152577:50001231000000:2800:74F593F6BA1C16AC1FB21C2B8CE370668C9716A1EDB10813EC7E3F0B0AF896B8.png)
实现原理
Tabs组件可以在页面内快速实现视图内容的切换，让用户能够聚焦于当前显示的内容，并对页面内容进行分类，提高页面空间利用率。
通过Tabs组件，配合使用Stack、Scroll、Search以及List等基础组件构建完整页面，再使用List组件的nestedScroll属性，结合calc计算高度，实现中间Tabs页签区域吸顶展示的效果。
开发步骤
1.  实现效果：
2.  实现效果：
3.  实现效果：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151113.43476517084859627199071183570836:50001231000000:2800:3F7510393994C0EDEBD638DF90529D26CFC6D992790025B69CBFE4DC8BA36CF7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151113.23753450016729492699741481847175:50001231000000:2800:5ABBED5C845AA32F0D1E48126F479CB42DA97DC961DF252D491B99A5D9C4B959.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151113.04003084594469120462812057142402:50001231000000:2800:77BBCF9C15C9DD43A4C60D12C025D90CE23D17A29E5F672AF8D2C1737495AA35.png)
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151113.15505668662654448793963262658555:50001231000000:2800:747EDD85340B5C89D4665BA3A3A013069359E00CCB0042D274CD7C01CBDD4A99.gif)
分组吸顶场景
场景描述
双列表同向联动，右边字母列表用于快速索引，内容列表根据首字母进行分组，常用于通讯录、城市选择、分组选择等页面。
本场景以城市列表页面为例，左侧城市列表数据和右侧字母导数据通过List组件来展示，并通过Stack组件使两个列表数据分层显示。在进入页面后，通过滑动左侧城市列表数据，列表字母标题吸顶展示，对应右侧字母导航内容高亮显示；点击右侧字母导航内容，左侧城市列表展示对应内容。
| 页面整体结构图  | 页面效果图  |
| --- | --- |
|   |   |
页面整体结构图
页面效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151113.21096712428471443512130502715546:50001231000000:2800:D6D4DF9A6CD92C997F8941AC3DFC33B009092392B02DCA768EF47673D2C6B0BE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151113.96696059852891346960746473489277:50001231000000:2800:6C30DD25D89266BA4FD35101BF61ACF896E31D1B07D26851BE9E8D9B097E10B3.png)
实现原理
左侧List作为城市列表，右侧List为城市首字母快捷导航列表，通过ListItem对对应数据进行渲染展示，并使用Stack堆叠容器组件，字母导航列表覆盖城市列表上方，再给对应List添加sticky属性和onScrollIndex()方法，实现两个列表数据间的联动效果。
开发步骤
```typescript
// 右侧字母导航内容
Column() {
List({ scroller: this.navListScroller }) {
ForEach(this.groupWorldList, (item: string, index: number) => {
ListItem() {
Text(item)
// ...
}
}, (item: string) => item)
}
}
```
```typescript
Stack({ alignContent: Alignment.End }) {
// 左侧城市列表数据
List({ scroller: this.cityScroller }) {
// ...
}
// ...
.onScrollIndex((index: number) => {
// 通过selectNavIndex状态变量与index联动，控制导航列表选中状态，城市列表中有当前城市和热门城市内容，这里index需要减2
this.selectNavIndex = index - 2;
})
// 右侧字母导航内容
Column() {
List({ scroller: this.navListScroller }) {
ForEach(this.groupWorldList, (item: string, index: number) => {
ListItem() {
Text(item)
// ...
.onClick(() => {
this.selectNavIndex = index; // 当前被点击导航内容的索引值
// 通过cityScroller的scrollToIndex方法，控制滑动城市列表指定index，城市列表中有当前城市和热门城市内容，这里index需要加2
this.cityScroller.scrollToIndex(index + 2, false, ScrollAlign.START);
})
}
}, (item: string) => item)
}
}
// ...
}
```
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151113.78174985306228626315620129276830:50001231000000:2800:F7F3BC2C43F92BE694FB28982B9EE1C30233E45218CBEDEAC38DA531A8D05B83.gif)
二级联动场景
场景描述
通过左边一级列表的选择，联动更新右边二级列表的数据，常用于商品分类选择、编辑风格等二级类别选择页面。
本场景以商品分类列表页面为例，分别通过List组件，对左侧分类导航和右侧导航内容进行展示。在进入页面后，点击左侧分类导航，右侧展示对应导航分类详情列表数据；滑动右侧列表内容，列表标题吸顶展示，左侧对应导航内容则高亮显示。
| 页面整体结构图  | 页面效果图  |
| --- | --- |
|   |   |
页面整体结构图
页面效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151113.37435988486019623634642709975589:50001231000000:2800:917AE9366BE416402844810FAD1A606DFF808F95EFDDE7FB6E336B75A57793A8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151114.82522003207784443131657886920851:50001231000000:2800:477FBABE0CAF464FEAAE132A3676D961C698F4757991C81F2BC967EE86E88944.png)
实现原理
左右各用一个List实现，分别设置其onScrollIndex()事件，左侧List在回调中判断数据项切换时，调用右侧List滚动到相应类别的对应位置，右侧同理。
开发步骤
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151114.24952215116014641989417987101151:50001231000000:2800:0CB64BD2E5938D783701BA7B8ABA1E49E9DA63FF8B738B0570A47A696AE0F8A8.gif)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-hadss_dialoghub
爬取时间: 2025-05-01 09:37:12
来源: Huawei Developer
概述
在HarmonyOS开发中，弹窗是每个应用都会遇到的场景，其重要性不容忽视。一方面，弹窗可以作为一种即时反馈机制，向用户传递重要的信息或提示，如登录提示、网络请求状态、操作确认等。这些弹窗通常具有模态或半模态特性，能够暂时阻断用户的其他操作，确保用户能够注意到并处理这些信息。另一方面，弹窗还可以用于展示广告、推广内容或引导用户进行下一步操作。例如，在App首页或某些关键页面，通过弹窗展示全屏广告或引导用户参与某项活动，可以有效地提升用户参与度。为了方便开发者在HarmonyOS上高效使用不同的弹窗能力，DialogHub解决方案应运而生。
DialogHub作为ArkUI弹窗能力的解决方案，提供了以下功能特性：
1.  确保弹窗与页面生命周期紧密绑定，页面销毁时自动清理弹窗资源。 在页面切换或导航时，自动检查并隐藏旧页面的弹窗。
2.  提供弹窗状态管理，区分弹窗是否正在显示、是否已关闭。 提供监听机制，允许开发者在弹窗状态变化时执行自定义逻辑，包括弹出、即将弹出、关闭、即将关闭4种状态。
3.  精简链式调用的API设计，确保常用弹窗可以通过简洁的语法创建。 提供默认配置，减少不必要的参数设置，提高调用效率。
4.  允许开发者自定义模板并保存到模板库中，便于后续复用。
5.  提供更灵活的层级管理机制，允许开发者动态调整弹窗的Z轴顺序。 提供层级冲突的解决策略，如新旧置顶弹窗的解决策略。 允许开发者自定义手势透传的行为，如是否允许手势穿透弹窗作用到底层页面。 提供更多自定义属性，如弹窗的动画效果、背景颜色、圆角半径等。
6.  提供属性值的动态更新机制，允许开发者在弹窗显示过程中修改属性。
本文主要以实际开发中的各项场景为例，介绍DialogHub的使用。
实现原理
开发流程
前提
开发者参考DialogHub使用说明进行安装配置。
弹窗能力开发流程
通过DialogHub直接创建弹窗然后进行显示或者销毁。
1.  调用 DialogHub 的 getToast()等接口，获取不同类型的弹窗构造器 DialogBuilder。
2.  调用 DialogBuilder 的 setContent()、setAnimation()等接口，配置弹窗的具体内容、动画效果、样式等。
3.  调用 DialogBuilder 的 build() 接口，创建弹窗实例 InfDialog 对象。
4.  调用 InfDialog 对象的 show() 方法显示弹窗。 调用 InfDialog 对象的 dismiss() 方法销毁弹窗。
模板复用能力开发流程
开发者自定义模板并注册到模板库中，便于后续复用。
1.  调用 DialogHub 的 createToastTemplate()等接口，创建不同类型弹窗的模板构造器 DialogTemplate。
2.  调用 DialogTemplate 的 setContent()、setAnimation()等接口，配置模板的具体内容、动画效果、样式等。
3.  调用 DialogTemplate 的 register() 接口，将配置好的模板注册并存储。
4.  调用 DialogHub 的 getToastTemplate()等接口，根据模板名称获取对应的 DialogBuilder。 然后按照弹窗能力开发流程中的步骤2~4，使用 DialogBuilder 配置并显示弹窗。 获取模板后配置的属性(如动画、位置等)只针对当前弹窗对象生效，不会修改模板内容。
5.  调用 DialogHub 的 updateToastTemplate()、updatePopupTemplate() 等接口，更新对应模板名称的配置，并重新注册。
6.  调用 DialogHub 的 removeTemplate() 接口，删除对应模板名称的弹窗模板。
7.  调用 DialogHub 的 isTemplateExist() 接口，判断指定模板名称的弹窗模板是否已被注册。
常见业务弹窗
纯文本有持续时间的提示窗
一个简单的文本Toast弹窗，到达指定时间后消失。setDuration()设置Toast持续时间。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151114.06726722258363651922643185522394:50001231000000:2800:C966F1505F4AB33734B18F44E0066DAB5C597F22720179920463F38E3C0F0A3E.png)
指定位置弹窗的非模态弹窗
在屏幕底部弹出SnakeBar，该弹窗可以响应用户点击跳转页面或者关闭弹窗。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151114.83574129267079382609168178801492:50001231000000:2800:AD44BBA70052D1157630997F6ACDB48B7AD9537AEAE4278D9C3A46C0BE37BE6E.png)
会定时消失且带弹出动效的弹窗
实现一个定时弹窗，6s自动关闭。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151114.46273226410599833540439947179894:50001231000000:2800:0246A58D1D19E61180097E58B9F252EFD3F2A1659460B390003A616DB3BE1BC3.png)
会避让键盘的弹窗
通过setConfig()的keyboardAvoidMode可以配置避让模式，CustomKeyboardAvoidMode.CONTENT_AVOID为弹窗内容避让。
requestFocusWhenShow配置为true，弹窗显示时，弹窗自动获焦。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151114.57047992426162540898075364197071:50001231000000:2800:54690BDCD35BEE02319064681A83B7600FBD3969760FFABB778C0834B6FBEB09.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151114.99712466270277178223419933073281:50001231000000:2800:FB030E496A304EA424C678CC221A75321159922B331599834B65814AB9342E74.png)
指向选定组件的带箭头弹窗
通过getPopup()构造Popup弹窗实例，setStyle()中enableArrow、arrowOffset、arrowWidth、arrowHeight可配置箭头属性；
setConfig()中preferPlacement可配置箭头偏向。
绑定组件需要调用setComponentTargetId(targetCompId)，targetCompId组件id标识确保唯一，否则会报错且弹窗位置异常。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151114.58185409475408462338577602154031:50001231000000:2800:C9DA774CB6DDC50E4F3E2840AAF13814C73DDB03F3AD833DC0FE7B891C74C572.png)
点击蒙层自动关闭的弹窗
弹出此类型弹窗需要打开isModel蒙层开关，并将autoDismiss设置为true
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151115.83084467891876657960785451122477:50001231000000:2800:08B938354CA4527ACC9F76332FFEA2DA6BF48772118ACBF1115C58A55833C379.png)
可主动关闭的弹窗
能够通过点击弹窗按钮关闭弹窗，设置弹窗Content时，调用setOperableContent()，并将DialogHub的Dismiss事件作为参数传递给Builder。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151115.69574952962010370392071934936921:50001231000000:2800:C853EC2C34D1134835CF7C4439C18C9BE3CD8322E38DA628B912C17F5A41EB35.png)
能够动态调整高度的底部弹窗
实现动态调整弹窗高度，不同高度展示不同弹窗内容。
```typescript
this.adjustSheetDialog.addLifeCycleListener({
onHeightDidChange: (h: number) => {
let vpValue = px2vp(h)
if (vpValue <= CommonConstant.SHEET_MIDDLE && sheetParams.type != 0) {
sheetParams.type = 0
this.adjustSheetDialog?.updateContent(sheetParams)
} else if (vpValue > CommonConstant.SHEET_MIDDLE && sheetParams.type != 1) {
sheetParams.type = 1
this.adjustSheetDialog?.updateContent(sheetParams)
}
},
// ...
})
```
sheet类型弹窗须调用setComponentTargetId(targetCompId)以实现页面级弹窗，并且保证绑定的组件id存在。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151115.22662358373009486516244362454643:50001231000000:2800:3C38B618D06C935C79B11B785E286BE6D48F7C4DFF05226D55E972516DA6182A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151115.12356591985644899978172262597869:50001231000000:2800:BD1B6EA7C3E02EDBFB8043CAAC3D1386159F85F2BBEA40CBC3A71D72A11CF596.png)
应用感知弹窗的打开、关闭
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151115.10825519783065687829685935184990:50001231000000:2800:6FC29403D3C4858FF21E357395E4181360FA6F333434B00AFF934FF8ED2CAC31.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151115.31599767904435043867404521658747:50001231000000:2800:7D1F887D2090622F501E70962146E1F7744240FA05B697FFEA47874CF208F5CA.png)
弹窗与周边的交互
弹窗存在时如何定义返回手势是退出页面或关闭弹窗
配置状态变量backCloseDialog，设置true表示返回手势作用于弹窗，false表示作用于页面。
在onBackPressed()中拦截手势并选择是退出页面还是关闭最上层弹窗
用户可以透过弹窗内容操作页面
弹出Toast类型的弹窗，或者主动调用setConfig()设置passThroughGesture为true，可实现弹窗内容透传手势。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151115.69632141036215334053350568017061:50001231000000:2800:3F058255198179ED07CA9CCB15E36562C8E184061CD6B5B0901E66218CDB8C44.png)
需要向页面返回数据的弹窗
给Builder参数传递修改页面数据的回调函数，在Builder里面进行调用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151115.97934268285003063620152027573183:50001231000000:2800:34082CFAD9988C6ACEE3300ED30EC5BF5659255571681F07BBDFC38DDE2A7A36.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151115.73428560715440977867002847417093:50001231000000:2800:956C707D6EDE9F0925E0DB8188AE7ADB9E5885D7E8D9981E971C70C606DB5C41.png)
父页面刷新正在展示的弹窗内容
修改Builder参数内容，再调用updateContent()进行修改。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151115.70918592110424136304304406735720:50001231000000:2800:BBF4C280088EB041DE5359B5A0384B661125C56CFC70F6EB56C631A3241DCE75.png)
页面需要感知当前页面是否存在弹窗
DialogHub注册页面弹窗数监听，当前页面弹窗数量发生变化会触发。
```typescript
DialogHub.addEventListener({
OnCurentPageDialogNumberChange: (newNum: number, oldNum: number) => {
this.dialogNum = newNum;
}
})
```
存在跳转链接的弹窗
点击弹窗上特定内容，跳转到其他页面。
router：在弹窗Builder里通过router模板跳转。
Navigation：将pageInfos传入弹窗Builder，然后在弹窗里进行push页面。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151115.58304939802320060550164003469167:50001231000000:2800:1E773C72E8770F291C3451FE64EBD17644F614D99CC384FFE03C339629DCFE8B.png)
折叠屏展开态不同位置的弹窗
弹窗默认在屏幕中间；通过设置弹窗偏移量可以在不同位置进行弹窗。
弹窗在左半屏：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151115.95992857838922941048873723120206:50001231000000:2800:90A9A85CDDAD10297B5E8FA117BA51B599497A3CA277C385CF638035F3B49105.png)
弹窗在右半屏：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151116.75169363058842946552943552486031:50001231000000:2800:0579334AEBADB6D29180AE3570DCBD84CA442CED7D1AE9B71AE48F8CC461C3E3.png)
弹窗内容复用场景
通过自定义弹窗模版进行弹窗
定义一个可复用的弹窗
将弹窗实例对象记录，下次弹窗复用。
多个弹窗并存场景
新弹窗被已有弹窗抑制
-  可以通过弹窗A对象的getStatus()方法获取弹窗A的状态，以判断是否允许弹窗B弹出。
-  通过调用DialogHub的getCurrentPageDialogs()方法获取当前页面的弹窗数量，判断数量是否为0，并据此控制弹窗C的弹出。
开发者可以控制弹窗层级实现弹窗的相互覆盖
常见问题
如何处理弹窗的获焦问题
-  开发者可以配置弹窗的requestFocusWhenShow属性实现：弹窗弹出时，将页面的焦点转移到弹窗中。进而实现会避让键盘的弹窗的效果。
Popup绑定组件，id报错
组件标识id需要开发者保证唯一性。setComponentTargetId()设置绑定的组件id后，如果id有问题，会导致在show的时候报错且弹窗位置异常。
调用build()与show()接口后，无法继续添加属性
调用build()接口后返回的是Dialog实例，只提供更新配置的接口。
removeTemplate()后，使用模板创建的弹窗实例可以继续显示
删除模板不影响之前通过模板已经创建的弹窗的显示和相关调用。
调用isTemplateExist()判断模板存在，getxxxTemplate模板报错50000003
模板创建和获取时，需要保证弹窗类型一致，否则无法获取模板并报错，错误码50000003。
可在获取模板前调用queryTemplate()查询模板的弹窗类型。
Toast弹窗置顶策略
Toast弹窗默认为置顶弹窗，且置顶冲突策略为TopDialogPriority.NEW_FIRST。
键盘避让模式变化
在使用DialogHub进行弹窗后，会将页面键盘避让模式修改为RESIZE，当页面无弹窗或者页面跳转时，避让模式还原。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-long-snapshot-practice
爬取时间: 2025-05-01 09:37:28
来源: Huawei Developer
概述
在移动应用中，标准的截图方法仅能捕捉当前屏幕显示的内容，对于超出屏幕可视区域的长页面或文档而言，这种方式显得不够便捷。当用户截图分享和保存（如聊天记录、网页文章、活动海报等）的内容较长的时候，需要用户多次截图来保证内容完整性。为了解决这一问题，本文将介绍长截图功能，使用户能够一键截取整个页面的长图，更轻松地分享和保存信息。
长截图功能适用于支持滚动的UI组件，比如List组件、Scroll组件、Web组件等。本文将以List组件和Web组件为例来介绍长截图功能的开发，分别通过控制器Scroller和WebviewController，结合组件截图模块componentSnapshot，实现长截图功能。
实现原理
List组件和Web组件实现长截图功能的原理相同，均可以通过模拟用户滚动行为，然后使用componentSnapshot.get()方法逐步截取不同位置的画面，将这些画面通过拼接得到长截图。Web组件通过WebviewController的相关API控制组件滚动，List组件通过Scroller的相关API控制组件滚动。
长截图拼接原理如下，将每次滚动新进入屏幕的内容裁剪后，拼接到之前的屏幕截图，依次类推。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151116.74959056887604623892432799625530:50001231000000:2800:E72C2193864FF751072A2837A4EEB2737B365129C4161C967980667CEAD38ECD.png)
长截图主要流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151116.54940560858534435021422396116401:50001231000000:2800:62345D1850F3DA038E2F8C9CA45773DD0F46EBC79FC213F313D50FBCBF506272.png)
在长截图的拼接过程中，所有截图会被暂时缓存到内存中。对于无限滚动或数据量较大的场景，应当限制单张截图的高度，以防止过高的内存占用影响应用性能。
滚动组件长截图
List、Scroll、Grid、WaterFlow等滚动组件均是通过Scroller来控制组件滚动，本章将以List组件为例来介绍滚动组件长截图的实现。下面介绍了滚动组件两种常见的长截图场景，一键截图和滚动截图。
一键截图
场景描述
一键截图将组件数据从顶部截取到底部，在截图过程中用户看不到界面的滚动，做到无感知滚动截图。这种方案一般用于分享截图、保存数据量较少的场景。
实现效果
点击“一键截图”，会生成整个列表的长截图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151116.19341389529398632456433204474551:50001231000000:2800:BAF1054C8BFA36C534A1C5B7EE2A9EE44F8C778E64D09A0AF127691551A060B8.gif)
开发流程
1.  1.1 为List滚动组件绑定Scroller控制器，以控制其滚动行为，并给List组件绑定自定义的id。 1.2 通过onDidScroll()方法实时监听并获取滚动偏移量，确保截图拼接位置的准确性。 1.3 同时，利用onAreaChange()事件获取List组件的尺寸，以便精确计算截图区域的大小。
```typescript
// src/main/ets/view/ScrollSnapshot.ets
@Component
export struct ScrollSnapshot {
private scroller: Scroller = new Scroller();
private listComponentWidth: number = 0;
private listComponentHeight: number = 0;
// The current offset of the List component
private curYOffset: number = 0;
// Value of each scroll
private scrollHeight: number = 0;
// ...
build() {
// ...
Stack() {
// ...
// 1.1 Bind the Scroller controller to the list scrolling component and define the customized ID.
List({
scroller: this.scroller
})// ...
.id(LIST_ID)
// 1.2 Obtains the scrolling offset.
.onDidScroll(() => {
this.curYOffset = this.scroller.currentOffset().yOffset;
})
.onAreaChange((oldValue, newValue) => {
// 1.3 Obtains the width and height of a component.
this.listComponentWidth = newValue.width as number;
this.listComponentHeight = newValue.height as number;
})
}
}
}
```
2.  “一键截图”功能确保在滚动截图过程中用户不会察觉到页面的滚动。通过截取当前屏幕生成遮罩图覆盖列表，并记录此时的滚动偏移量（yOffsetBefore），便于后续完成滚动截图之后，恢复到之前记录的偏移量，使用户无感知页面变化。 为保证截图的完整性，设置完遮罩图后，同样利用scrollTo()方法将列表暂时滚至顶部，确保截图从最顶端开始。
```typescript
// src/main/ets/view/ScrollSnapshot.ets
@Component
export struct ScrollSnapshot {
// Component coverage during screenshot process
@State componentMaskImage: PixelMap | undefined = undefined;
// The current offset of the List component
private curYOffset: number = 0;
// Backup component location before screenshot
private yOffsetBefore: number = 0;
// ...
// One-click screenshot
async onceSnapshot() {
// Initialize state before screenshot
await this.beforeSnapshot();
// Start scrolling screenshots in a loop
await this.snapAndMerge();
// Restore scroll component state
await this.afterSnapshot();
// ...
}
async beforeSnapshot() {
// Offset before scrolling
this.yOffsetBefore = this.curYOffset;
// Take a screenshot of the loaded List component as a cover image for the List component
this.componentMaskImage = await componentSnapshot.get(LIST_ID);
this.scroller.scrollTo({
xOffset: 0,
yOffset: 0,
animation:
{
duration: 200
}
});
// ...
// Delay ensures that the scroll has reached the top
await CommonUtils.sleep(200);
}
build() {
// ...
Stack() {
// The mask layer during the screenshot process prevents users from noticing the rapid sliding of the screen and improves user experience.
if (this.componentMaskImage) {
Image(this.componentMaskImage)
// ...
}
List({
scroller: this.scroller
})//...
.id(LIST_ID)
.onDidScroll(() => {
this.curYOffset = this.scroller.currentOffset().yOffset;
})
}
}
}
```
3.  3.1 记录每次滚动的位置到数组scrollYOffsets中，并使用componentSnapshot.get(LIST_ID) 方法获取当前画面的截图。 3.2 如果非首次截图，则使用crop方法截取从底部滚动进来的区域，然后调用pixmap.readPixelsSync(area)方法将截图数据读取到缓冲区域area中，并将area通过集合进行保存，用于后续截图拼接。 3.3 如果页面没有滚动到底部，继续滚动，继续递归调用snapAndMerge()方法进行截图；如果到达底部，则调用mergeImage()方法拼接所有收集到的图像片段，生成完整的长截图；同时还需限制截图的高度，以防过大的截图占用过多内存，影响应用性能，例如这里设置截长截图高度不超过5000。
4.  使用image.createPixelMapSync()方法创建长截图longPixelMap，并遍历之前保存的图像片段数据 (this.areaArray)，构建image.PositionArea对象area，然后调用longPixelMap.writePixelsSync(area) 方法将这些片段逐个写入到正确的位置，从而拼接成一个完整的长截图。
5.  通过安全控件SaveButton结合photoAccessHelper模块保存截图到相册。
滚动截图
场景描述
此方案允许用户控制长截图的起止位置，增加了使用的灵活性。它适用于大数据量场景，方便用户选择性保存滚动组件中的特定数据。
实现效果
点击“滚动截图”按钮后，列表将自动滚动。点击列表中的任意条目时，滚动会立即停止，并开始截取从滚动开始到停止这段时间内的数据截图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151116.90161722876996785988694686746390:50001231000000:2800:8F98FBDAD579EE23A2323C9662106BBCFC5B947788D9D7BF51D2BD1CD9574CC1.gif)
功能实现
“滚动截图”功能的实现流程与前述的“一键截图”一样，因此这里不再重复详述整个过程，而仅聚焦于其中的几个关键差异点，例如滚动的控制和偏移量的记录，分别如下面1和2所描述。
1.  当准备开始截图时，将isEnableScroll设置为false以禁用滚动交互。而当用户点击列表项以确定截图结束位置时，使用scroller.scrollBy(0, 0)方法确保列表立即停止滑动。
Web组件长截图
场景描述
Web组件的长截图功能与之前介绍的滚动组件长截图在使用场景上相似，两者均旨在为用户提供快速便捷的数据信息分享和保存方式。主要区别在于，Web组件专门针对网页内容进行截图，确保用户能够完整地捕获和分享浏览的网页信息。
实现效果
点击“截图”按钮即可完成整个网页的长截图，并可将截图保存至相册。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151116.10881703084690898576904130674464:50001231000000:2800:3CF0E2F18130E6FEB0182DAB3936CFA0F44208B803679864F40BE236C53E984B.gif)
功能实现
Web组件的长截图可以通过前文介绍的滚动截图方案以及使用WebView提供的webPageSnapshot()方法进行全量截图。本章将重点介绍webPageSnapshot()方法的使用方法，而滚动截图的相关信息已在前文详述。
使用滚动截图的方式进行长截图
Web组件滚动长截图和滚动组件长截图开发流程大体一样，主要是控制组件的滚动的方法不同。List组件使用的是Scroller，而Web组件使用的是webViewController。
在滚动截图过程中，webViewController负责控制Web组件的滚动，通过调用webViewController.scrollBy()方法来实现。为了判断是否已滚动到底部，使用this.webViewController.getPageHeight() 方法获取网页内容的总高度，并将当前偏移量this.curYOffset加上组件自身的高度与网页总高度进行比较。如果两者的和小于网页总高度，则表示尚未触底。
使用webPageSnapshot()方法进行网页全量截图
此外，Web组件还可以使用webPageSnapshot()方法进行网页全量截图，比较适合结构简单、静态元素的页面长截图。如果网页中有动态资源，结构相对复杂，比如有固定的标题头等，推荐上面的滚动长截图方案。使用webPageSnapshot()方法实现长截图的步骤如下：
```typescript
async getWebSize() {
const SCRIPT = '[document.documentElement.scrollWidth, document.documentElement.scrollHeight]';
try {
this.webviewController.runJavaScriptExt(SCRIPT).then((result) => {
if (result.getType() === webview.JsMessageType.ARRAY) {
this.h5Width = (result.getArray() as number[])[0];
this.h5Height = (result.getArray() as number[])[1];
Logger.info(TAG, `h5Width is ${this.h5Width}, h5Height is ${this.h5Height}`);
}
});
} catch (error) {
Logger.error(TAG, `Run script to get web page size failed. Error: ${JSON.stringify(error)}`);
}
}
```
加载网络html文件时，需要在entry/src/main路径下的module.json5中配置网络权限。示例代码如下所示：
完整示例代码如下：
```typescript
import { webview } from '@kit.ArkWeb';
const TAG = 'WebComponent';
const url: string = 'https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-dev-guide';
@Entry
@Component
struct WebComponent {
@State h5Width: number = 0;
@State h5Height: number = 0;
@State longPixelMap: PixelMap | undefined = undefined;
private webviewController: webview.WebviewController = new webview.WebviewController();
aboutToAppear(): void {
webview.WebviewController.initializeWebEngine();
webview.WebviewController.enableWholeWebPageDrawing();
webview.WebviewController.prepareForPageLoad(url, true, 2);
}
async getWebSize() {
const SCRIPT = '[document.documentElement.scrollWidth, document.documentElement.scrollHeight]';
try {
this.webviewController.runJavaScriptExt(SCRIPT).then((result) => {
if (result.getType() === webview.JsMessageType.ARRAY) {
this.h5Width = (result.getArray() as number[])[0];
this.h5Height = (result.getArray() as number[])[1];
console.info(TAG, `h5Width is ${this.h5Width}, h5Height is ${this.h5Height}`);
}
});
} catch (error) {
console.error(TAG, `Run script to get web page size failed. Error: ${JSON.stringify(error)}`);
}
}
async webSnapshot() {
try {
this.webviewController.webPageSnapshot({ id: 'webTest', size: { width: this.h5Width, height: this.h5Height } },
async (error, result) => {
if (result) {
this.longPixelMap = result.imagePixelMap;
}
});
} catch (error) {
console.error(TAG, `webPageSnapshot err : ${JSON.stringify(error)}`);
}
}
build() {
Stack() {
Web({
src: url,
controller: this.webviewController
})
.id('webTest')
Scroll() {
Column() {
Image(this.longPixelMap)
.width('80%')
}
}
Button('WebPageSnapshot')
.onClick(() => {
this.webSnapshot();
})
}
}
}
```
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-2in1-window-shape
爬取时间: 2025-05-01 09:37:41
来源: Huawei Developer
概述
一般情况下，UI开发都是在矩形窗口上操作，但在PC/2in1设备上，应用还可以使用各类异形窗口来展现交互内容。这里的异形是指除默认矩形以外的形状，包括但不限于圆形、三角形、以及其他不规则的形状等。开发者通过使用这些异形形状的窗口，结合窗口中的内容展示UI交互的多样性，一定程度上能够提升应用体验。类似的示例有：文字应用中的放大镜、带指示箭头的气泡框、提供辅助功能的悬浮窗等。
本文主要介绍在PC/2in1设备上实现异形窗口。根据窗口的形状类别，可分为以下场景：
实现原理
在创建窗口时，ArkUI以宽、高为参数描绘窗口初始大小，其形状默认为矩形，可以通过设置掩码改变窗口最终呈现的形状。
该掩码是一个二维数组，其大小对应初始窗口的宽和高，所以可以把该数组中的元素与窗口中的像素一一对应起来；数组中的每一项值只能是0或1，其中数字0表示窗口对应位置的像素是透明的，数字1代表对应像素不透明。
简单来说，掩码即是由数字1描绘的窗口形状点阵图。具体使用可参考setWindowMask()接口。
开发流程
掩码windowMask二维数组的大小需要与窗口初始宽、高一致，且每项值只能是0或1，否则设置的形状不会生效。
图形形状窗口
场景案例
待开发的异形窗口，其形状是具有一定规则的几何图形，通过描述语言能得到精确且唯一的形状。本节以下面两种形状的实现为例进行说明：直径为500的圆形；底500、高500的等腰三角形。
创建子窗口
在得到异形窗口前，需要先创建一个默认的矩形窗口，开发步骤如下：
1.
2.
设置窗口形状
1.
2.
3.
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151117.86868146589184548566979976763741:50001231000000:2800:65F2BE2D77C05E47317674477C485E8217141186143FBBC1CA17CD67FF05729E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151117.95826787577788676694105121782366:50001231000000:2800:77748E29E7D0BD51FEF078816DEDE943BAC70AD2B9103B5E17BC8530580302FF.png)
不规则形状窗口
场景案例
待开发的异形窗口，呈现出不规则的形状。这种情况通常先由设计人员提供图形文件，开发人员以文件为输入，基于ArkUI提供的图片处理能力，转化为相应的形状掩码，最后实现不规则的窗口形状。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151117.77910950051957579974544353354144:50001231000000:2800:FA76B2BABAC551C9FA4B4579FD1AD028D4C774FC2D3FCF55E3651EE9287086B1.png)
本节以上图为例说明不规则形状窗口的实现过程。
开发步骤
首先同样需要先创建子窗口，然后再依以下步骤开发。
1.
2.
```typescript
// entry/src/main/ets/utils/WindowUtils.ets
export async function getPicMask(width: number, height: number, picPath: string): Promise<number[][]> {
const maskArray: number[][] = new Array(height).fill(null).map(() => new Array(width).fill(0));
const pixelMap: image.PixelMap = await image2PixelMap(picPath, width, height);
const pixelArrayBuffer: ArrayBuffer = new ArrayBuffer(width * height * 4);
await pixelMap.readPixelsToBuffer(pixelArrayBuffer);
const allPixels: number[] = [];
const unit8Pixels: Uint8Array = new Uint8Array(pixelArrayBuffer);
for (let i = 0, j = 0; i < unit8Pixels.length; i += 4, j++) {
// unit8Pixels[i+3] is alpha channel of BGRA_8888
allPixels[j] = unit8Pixels[i + 3] > 0 ? 1 : 0;
}
pixelMap.release()
let k = 0;
for (let i = 0; i < width; i++) {
for (let j = 0; j < height; j++) {
maskArray[i][j] = allPixels[k++];
}
}
return maskArray;
}
```
3.
```typescript
// entry/src/main/ets/utils/WindowUtils.ets
async function setWindowShape(win: window.Window, width: number,
height: number, getMaskFunc: (w: number, h: number, picPath?: string) => Promise<number[][]>,
picPath?: string): Promise<void> {
const windowMask = await getMaskFunc(width, height, picPath);
if (canIUse('SystemCapability.Window.SessionManager')) {
win.setWindowMask(windowMask);
} else {
hilog.info(0x0000, 'Simple', 'can not use SessionManager syscap');
}
}
/**
* Set the window with pic shape
* @param win The target window
* @param width The original window width
* @param height The original window height
* @param picPath The pic path in rawfile
*/
export async function setWindowPicShape(win: window.Window, width: number,
height: number, picPath: string): Promise<void> {
setWindowShape(win, width, height, (w, h, picPath) => {
return getPicMask(w, h, picPath!)
}, picPath)
}
```
4.
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151117.19502498488877030554013967389059:50001231000000:2800:035A0F497570DAB934E873A666C54CD289124DE2DF27054AC85361C613DDF7C3.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-web-development
爬取时间: 2025-05-01 09:37:54
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-arkweb_rendering_framework
爬取时间: 2025-05-01 09:38:08
来源: Huawei Developer
概述
Hybrid应用开发是介于Web应用和系统应用两者之间的应用开发技术，兼具“系统应用良好交互体验”的优势和“Web应用跨平台开发”的优势。其主要原理是由Native通过JSBridge通道提供统一的API，然后用Html/CSS实现界面，JS来写业务逻辑，能够调用系统API，最终的页面在WebView中显示。
Hybrid应用鸿蒙化方案
整体架构
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151117.45865213306727861308592561036764:50001231000000:2800:84DAC2944B317A998B9ADDB8208EFE228A70876BEE3ECD44BDBEE8D293ABAEBD.png)
方案设计
Hybrid应用鸿蒙化方案主要集中在双端通信JSBridge实现、拓展接口实现，以及基于同层渲染的原生组件实现。JSBridge是前端与ArkTS进行双向通信的桥梁。通过JSBridge，前端应用能访问到ArkTS侧实现的拓展接口，实现更丰富的业务功能。视图层方面，可以使用系统提供的同层渲染能力，把部分性能要求比较高的前端组件改成ArkTS实现，以达到更好的体验效果。下图蓝色背景的方框图展示了上述三点所处的框架位置：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151117.56246868505352526943045197766123:50001231000000:2800:DC6E9DCDF19DD7B98A895804157CDAC0B8BBC9838910CA65D7E3D56B612AF388.png)
业务实现中的关键点
Hybrid应用鸿蒙化方案主要围绕双端通信、API鸿蒙化、组件鸿蒙化三方面进行开发。双端通信：JS侧使用ArkTS的通道，是鸿蒙化的基石；API鸿蒙化：针对JS侧平台相关的API，提供一套HarmonyOS版本的实现；组件鸿蒙化：针对Web组件，以同层渲染的方式提供替代组件，以提升组件的性能与交互体验。
双端通信
JSBridge扮演Webview进程与ArkUI主进程沟通的桥梁，是一种双向通信的机制。HarmonyOS系统提供Web组件以及@ohos.web.webview等ArkWeb API来进行Web开发。可以通过WebMessagePort以及javaScriptProxy代理的方式实现JSBridge。
前端可以使用native.makePhoneCall(..) 的方式进行调用。且方法的参数支持基本类型、字典对象、函数等，对于JSBridge的设计提供了便利。关于Web.javaScriptProxy以及WebviewController.registerJavaScriptProxy()的使用方法可以参考《前端页面调用应用侧函数》。
通过对比，javaScriptProxy注入对象的方式构造JSBridge是一个比较好的技术选型。建议JSBridge的实现基于注入机制进行设计，并考虑分层设计来提高其通用性和灵活性，下图展示一种分层设计思路：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151117.30632154675401355518759000444005:50001231000000:2800:F31C7C624C5B70FBD9F223A2C89352D931AFF15EA62C976CA6FAE54FDA0F5377.png)
1.  在JS侧，nativeCall方法提供打包转换能力。如下面示例，把信息数据序列化成字符串后传递给通信层： 在ArkTS侧，通道层call方法反序列化字符串生成信息对象，并调用对应channelType的处理方法处理信息：
```typescript
nativeCall: function (channelType: string, object: any) {
var objectJson = JSON.stringify(object);
var resultJson = window.JSBridge && window.JSBridge.nativeMethod(channelType, objectJson);
return resultJson && JSON.parse(resultJson);
}
```
JSBridge的设计是否合理关系到应用的性能，开发者也可以考虑是否需要批量缓存请求再统一发送请求来减少请求次数，或者把不变的请求结果进行缓存等等。
API鸿蒙化
H5业务设计中除了使用W3C API外，还可以使用ArkTS侧API拓展来访问设备。如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151117.35066471913704273702320400536613:50001231000000:2800:E78B2B30BDA3A9E2CE252557C874A637CB252576F34C814509F12A5ACFD4BC97.png)
系统高阶API是对系统API的一层封装，实现更符合业务要求的接口。拓展API的规范设计具有较大的灵活性，建议对API的参数，返回值类型格式进行限制，使用基本类型或者简单的字典对象，尽量避免使用复杂的类型的参数或返回值，可以参考比较成熟的小程序框架，其规范格式可以分成三种类型：
设计过程中可以把API都汇聚到一个对象作为属性字段存在，方便在切面视角增加统一的参数、返回值加工处理，拦截处理。示意图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151117.52984293494068401556635134537450:50001231000000:2800:901CF838898FDC18A29F84E6DF7DA6E65431D99EE47AC6A65B5341E0DA81625F.png)
组件鸿蒙化
HarmonyOS提供同层渲染能力把原生组件直接渲染到WebView层级，从而获得更大的灵活性以及性能上获得更好表现。开发者可通过Web组件同层渲染相关属性来进行控制：enableNativeEmbedMode开关控制；onNativeEmbedLifecycleChange处理同层渲染生命周期：CREATE/UPDATE/DESTROY；onNativeEmbedGestureEvent处理交互事件。同层渲染功能要求前端页面文件中显式使用embed标签，并且embed标签内type必须以“native/”开头。使用Vue等框架可以方便地进一步封装embed标签生成自定义组件，并增加更多属性、事件和方法，通过JSBridge与ArkTS侧进行同步。在ArkTS侧，对应地需要自定义实现一个原生组件或者使用系统内置组件，通过NodeContainer组件进行动态挂载。同层渲染的原理如下：
开发角度：前端页面开发者使用<embed>标签来表示使用原生组件；应用开发者使用NodeContainer关联离屏节点树，使用makeNode接口在H5页面上渲染出组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151117.84873194198582311342137788944500:50001231000000:2800:11DDDF0B073BB0332CBA2B5C7968A7247DCC51473C5BE3EEE9A33254256E7537.png)
离屏节点动态上下树：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151117.69928661980944379292482944174346:50001231000000:2800:9F3C0F1987FBB5F23F86F4B566D1F0ED56998AA4A14F1E205B1F21AEC9D17B30.png)
1）开发者初始构建一个NodeContainer对象表示一个空的占位符。NodeContainer里面内容为空时，在初始化的时候大小为0，不参与布局。
2）NodeController持有buildnode对象，通过makeNode接口将buildnode对象 返回给NodeContainer，来实现动态上树。
3） NodeController里面rebuild方法，触发NodeContainer重新调用makeNode接口。 makeNode接口若返回空，则实现动态下树。
使用Vue框架结合embed标签示例：
在ArkTS侧，可以扩展NodeController来统一管理同层渲染节点。其makeNode接口实现示例如下：
实现中可以使用map容器把embedType和离屏节点的builder函数进行关联，当makeNode执行时，取出embedType对应的builder函数来创建rootNode节点，最后把rootNode节点关联的FrameNode返回，达到离屏节点动态上树、H5渲染出原生组件的效果。同层渲染可以参考文档《同层渲染绘制Video和Button组件》

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-render-web-using-same-layer-render
爬取时间: 2025-05-01 09:38:21
来源: Huawei Developer
概述
在使用Web组件加载H5页面时，经常会有输入框、视频的场景，这些场景在H5中的组件性能体验欠佳。想要更加流畅的体验，必须要将原生组件放到Web组件上。在什么场景下应该在Web组件上使用原生组件：
目前要实现在Web组件上使用原生组件有两种方案：
方案一：直接使用Stack将组件堆叠到H5页面上。
方案二：使用同层渲染，使用Web组件和原生组件交互的方式，将原生组件替代Web组件中部分组件，提升交互体验和性能。
以上两种方案经过性能对比后，同层渲染比非同层渲染的性能要更好。
什么是同层渲染
同层渲染是一种优化技术，用于提高Web组件页面的渲染性能。同层渲染会将位于同一个图层的元素一起渲染，以减少重绘和重排的次数，从而提高页面的渲染效率。
同层渲染和非同层渲染的区别如下：
图1同层渲染和非同层渲染区别
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151117.53579590573897754216312917975590:50001231000000:2800:C4A1C1D6B039AE332146569567BD649AB0D00A55663F87474C70F7930353AA59.png)
场景示例
以下分别采用非同层渲染和同层渲染的两种方式，加载相同的商城组件到相同的H5页面上，并抓取Trace对比两者之间的区别，页面效果与场景实例源码的核心部分如下：
图2页面效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151117.14127119336475036116747868835405:50001231000000:2800:5980EB15CCB47B0E8D47D588C2773E95F117931D203C097E951DDD7B811B3957.png)
提供承载的H5页面代码如下：
商品数据代码如下：
商城组件代码如下：
Web组件首次加载原生组件方案对比
首先的想法是，将原生组件内容使用H5实现，直接用Web组件加载页面。但是，用H5开发页面时，需要使用到JS和CSS，甚至一些前端框架进行页面的开发，并且动效和体验都不如原生组件。因此采用同层渲染和非同层渲染两种方案进行对比。
使用非同层渲染
底层使用空白的H5页面，用任意标签进行占位，然后在H5页面上方层叠一个原生组件。原生组件需要在Web组件加载完成后，获取到标签大小位置后，在对应位置展示。
需要在H5侧添加getEmbedSize方法来获取元素大小，代码如下：
使用Stack层叠Web组件和SearchComponent组件，代码如下：
上述的方案只是限于底层H5网页比较简单，如果H5页面比较复杂，就会发现原生组件是很难去定位，而且在性能上，Web组件是整体渲染的，即使被原生组件遮住的部分也需要渲染消耗性能。
使用同层渲染
同层渲染简单来说就是，底层使用空白的H5页面，用Embed标签进行占位，ArkTS使用NodeContainer来占位，最后将Web侧的surfaceId和原生组件绑定，渲染在NodeContainer上。这里给出一些大致步骤：
Web组件加载原生组件性能收益对比
本节以Web组件加载原生组件的场景，抓取Trace图进行分析。下面的Trace图上的红线处Web组件加载完成，蓝线处原生组件加载显示完成。
使用非同层渲染加载
图3非同层渲染的Trace图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151118.72182296025986054893831986060956:50001231000000:2800:F534152BEE1FA139A70573B603B0E2A3BA900DFE9C1BE930C36A420592D204AC.png)
非同层渲染的分析：
使用同层渲染加载
图4同层渲染的Trace图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151118.10172341196941265512143433549183:50001231000000:2800:6BDBA7E0949C7A1A47BBFAF9B4DFE62682985E0437F5322642EDCC2177F3103D.png)
同层渲染的分析：
页面加载场景总结
下表为各种方法完成原生组件加载（蓝线）前后几帧render_service侧的耗时对比（-1为完成前一帧，1为完成后一帧，以此类推）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151118.72244294702015917410433372279811:50001231000000:2800:46A8A877690E236C5A82D862C6F193521415EDCE7AF9D198C31C87EE368C49A7.png)
从此表格可以看出，非同层渲染会导致render_service侧每帧耗时大幅提升，同层渲染相比起非同层渲染，并不影响render_service侧的每帧耗时。
列表滑动场景性能收益对比
本节以列表滑动场景，抓取Trace图进行分析。在此场景下，对比同层渲染和非同层渲染的每一帧的结构如下所示：
使用非同层渲染
图5非同层渲染滑动时单帧图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151118.12703512326220046023711085449915:50001231000000:2800:A4D5C45E37D7F3BF66E95CC50F7E238A3420441B68FB331314196359B935EAD8.png)
使用同层渲染
图6同层渲染滑动时单帧图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151118.65607646713727953830077065311083:50001231000000:2800:C185BB56143D24DDC5BDEF13EA10E0A8183364FBB29802BB4AD994B9EC6D8DF0.png)
上述两张图经过对比也可以发现，非同层渲染的render_service每一帧的耗时大幅增加，，结论和上述保持一致，再次验证了同样的结果。
总结
在Web组件中渲染原生组件时，采用同层渲染方式比起非同层渲染可以将图片渲染提前到原生组件加载完成前，且同层渲染将位于同一个图层的元素一起渲染，降低绘制任务，提升了性能。同时使用同层渲染可以实现更多功能，比如根据尺寸调整组件大小等功能，从而避免繁琐操作。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-video-adaptation-based-web
爬取时间: 2025-05-01 09:38:38
来源: Huawei Developer
概述
在Web页面中，通常会包含一些像图片、视频一类的媒体资源，在使用Web组件加载这一类页面时，就会遇到视频播放适配的问题，本文汇总了以下常见的Web页面内视频适配场景：
全屏播放视频
场景描述
默认情况下，网页中的视频点击全屏按钮后，会在移动设备上以竖屏形式播放视频，同时也无法兼容手势返回，对于用户而言，竖屏播放视频画面有限，更希望视频能够以横屏全屏的形式播放，同时使用手势返回后，只退出全屏播放，而不是返回到桌面，在这种情况下，就需要开发者对Web视频做全屏播放的适配。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151118.71218001107803404943465923858439:50001231000000:2800:E6E220897F6FD3D68FFE1DC3FA087CF850523B3C889C4981B4F87C108545D2CF.gif)
实现原理
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151118.15206749674247979097090609862680:50001231000000:2800:766635B7500F9F018979E78F29E4D6C596465A11935957CCE9891CE292E3A380.png)
全屏播放视频首先需要Web页面做沉浸式展示，才能保证在进入全屏显示后，视频能够在非安全区展示。具体实现可以参考开发应用沉浸式效果。
为解决点击全屏后视频竖屏显示的情况，需要在Web页面进入全屏的事件回调onFullScreenEnter()中，通过手动setPreferredOrientation()接口将屏幕设置为横屏显示。
为保证退出全屏后，页面继续保持正常的竖屏显示，需要在Web页面退出全屏的事件回调onFullScreenExit()中，手动通过setPreferredOrientation()接口将屏幕设置为竖屏显示。
需要注意的是，在页面进入全屏后，需要兼容通过返回手势触发退出全屏的逻辑，具体实现上，需要在触发手势返回的事件回调中，首先判断当前应用是否处于全屏显示，若处于则触发退出全屏，返回手势触发有以下两类。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151118.44015300738101005843370884703122:50001231000000:2800:4B1F54107CA8581D7493F1E06209841DB3DB0A5542AC8E86DDF51C110791F412.gif)
实现步骤
进入全屏播放
```typescript
// src/main/ets/pages/Index.ets
@Entry
@Component
struct Index {
// ...
private windowClass: window.Window | null = null;
private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
aboutToAppear(): void {
window.getLastWindow(this.context).then((windowClass) => this.windowClass = windowClass);
// ...
}
/**
* Changes the preferred orientation of the window.
*
* @param orientation - The preferred orientation to set. This should be a value from the `window.Orientation` enum.
* @returns void - This function does not return any value.
*/
changeOrientation(orientation: window.Orientation) {
this.windowClass?.setPreferredOrientation(orientation);
}
build() {
// ...
}
}
```
```typescript
// src/main/ets/pages/Index.ets
@Entry
@Component
struct Index {
private isFullScreen: boolean = false;
private handler: FullScreenExitHandler | null = null;
// ...
build() {
Column() {
Web({
src: $rawfile(/zh/.test(this.language) ? 'index_cn.html' : 'index_en.html'),
controller: this.webController
})
// ...
.onFullScreenEnter((event) => {
this.handler = event.handler;
this.changeOrientation(window.Orientation.LANDSCAPE);
this.isFullScreen = true;
})
}
}
}
```
退出全屏播放
长按复制视频链接
场景描述
长按复制视频链接经常被应用于社交分享的场景，用户在应用内看到感兴趣的视频内容希望分享给周边的人，通过长按希望分享的视频选中“复制视频链接地址”选项，可以帮助用户快捷准确地获取到视频的链接地址。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151118.21867317012810025559602726896539:50001231000000:2800:99E8B9F4C58759480AF909FC24C5AEA0DF64D5772F3321E046970678FBCE0E74.gif)
实现原理
长按复制视频链接功能在实现上有以下两个关键部分。
开发步骤
```typescript
//src/main/ets/view/CustomPopupMenu.ets
/**
* A custom popup menu Builder.
*
* @param uri - The URI for which the popup menu will be built.
* @param context - The UI context in which the popup menu will be used. This should be an instance of `common.UIAbilityContext`.
* @param openDownloadDialog - A function that, when called, will open a download dialog.
* @param closeDownloadDialog - A function that, when called, will close the download dialog.
* @param changeIsShow - A function that, when called, will change the visibility of certain UI elements.
*/
@Builder
export function customPopupMenuBuilder(
uri: string,
context: common.UIAbilityContext,
openDownloadDialog: Function,
closeDownloadDialog: Function,
changeIsShow: Function
) {
Column() {
Menu() {
ForEach(menus, (menu: MenuItem) => {
MenuItem({
content: menu.text
})
.height(singlePopupHeight)
.onClick(() => {
try {
menu.caller && menu.caller(uri, context, openDownloadDialog, closeDownloadDialog);
changeIsShow();
} catch (e) {
hilog.error(0x000, Constants.TAG, `some error happend, ${JSON.stringify(e)}`);
}
})
}, (menu: MenuItem) => menu.id)
}
.width(popupWidth)
}
}
```
长按下载视频
场景描述
长按下载视频经常用于提供给用户本地缓存感兴趣的视频内容的能力，用户可以直接长按感兴趣的视频内容打开弹窗，选择“下载视频”将其保存到设备本地，下载后的视频也可以通过社交分享渠道进行分享。
实现原理
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151118.42124200698564760206601308280045:50001231000000:2800:8CF7433D2720080B7DDD0DCA6D5CA3DA3EC7EA38CF2A1F48D85E249540399BC2.png)
长按视频区域后，可通过在onContextMenuShow()接口中的事件参数event.param.getSourceUrl()获取到视频链接地址。
开发者可参考使用Web组件的下载能力，通过绑定WebDownloadDelegate委托类进行下载控制与状态感知，该类会通过以下四个回调注册方法通知下载状态。
通过Web组件关联的WebviewController调用startDownload()并传入视频链接地址触发下载。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151118.11236684368591236431716232132022:50001231000000:2800:C53D19277F8B84E9E465D253CA7712B34E3C687707BB3E24E33B47762739C49A.gif)
开发步骤
```typescript
// src/main/ets/utils/WebDownloadManager.ets
export class WebDownloadManager extends AbstractWebDownloadManager
implements ControllerManager {
// ...
// Define the download delegate instance.
private delegate: webview.WebDownloadDelegate = new webview.WebDownloadDelegate();
// ...
public start(controllerName: string, path: string, url: string): Promise<string> {
return new Promise((resolve, reject) => {
const controller = this.getController(controllerName);
// ...
// Associate the download delegate with the webview controller.
controller?.setDownloadDelegate(this.delegate);
// ...
});
}
// ...
}
```
总结
本文提供了Web页面内视频的相关适配实践，包括解决视频全屏播放默认竖屏、获取到视频链接地址并写入到剪贴板、通过Web组件提供的相关能力下载网页视频，开发者可结合本文根据实际业务需求进行Web页面内视频的适配。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-input-method-framework
爬取时间: 2025-05-01 09:38:52
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-keyboard-layout-adapt
爬取时间: 2025-05-01 09:39:07
来源: Huawei Developer
概述
软键盘是用户进行交互的重要途径之一，同时软键盘的弹出和收起，可能会影响到正在显示的UI元素，影响用户体验，出现如下常见的软键盘布局适配问题：
本文将介绍以下知识帮助开发者了解软键盘的弹出和收起的控制、避让机制以及软键盘常见问题的解决方法。
软键盘的弹出收起和监听
当用户点击输入框的时候，默认会弹出软键盘。但是某些场景下，需要对软键盘的弹出和收起进行控制。比如点击空白区希望收起软键盘、进入页面的时候希望页面中的输入框能主动获焦并且弹出软键盘等，此外开发者可能需要根据软键盘的弹出和收起状态、软键盘的弹出高度来进行页面布局调整。本节将介绍软键盘的弹出收起控制、获取软键盘高度以及安全区域高度变化监听。
主动获焦弹出软键盘
有时候进入页面，希望页面中的输入框能主动获焦并且弹出软键盘，方便用户直接输入，比如点击应用首页的搜索框，进入应用搜索页面。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151119.71810712358170962702759494788320:50001231000000:2800:B6A52C99B4F6E52DAD915526CA34130320F28DD676EAA0169DE3369C601AAE29.gif)
可以通过将输入框的defaultFocus设置为true来实现。
代码控制弹出软键盘
开发者可以使用全局的焦点控制对象FocusController的requestFocus方法，通过组件的id将焦点转移到组件树对应的实体节点，并且弹出软键盘。例如下面这个新增地址的示例，当用户未输入信息的时候，点击保存按钮，提示用户输入信息，并且弹出输入框，便于用户直接输入。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151119.10740310356455348914233808923684:50001231000000:2800:2A3F59B44610E0F807752471C1448E5F234E992B3F323EF348EA94FB0C49758F.gif)
示例如下：
代码控制收起软键盘
通过全局的焦点控制对象FocusController的clearFocus方法，软键盘收起，例如下面的商品列表页面，点击搜索会收起软键盘。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151119.76148695006019986362198339423473:50001231000000:2800:0436EA779CC4565849926D27C7B7D5B6F2ACB5852F2986F585EF12927408FF25.gif)
示例代码如下：
监听获取软键盘高度
开发者还可以通过获取软键盘高度、监听软键盘的弹出和收起状态，来调整组件的位置来适配界面或者显示隐藏某些组件。通过window模块的on('keyboardHeightChange')方法开启固定态软键盘高度变化的监听，实时获取软键盘宽高。例如下面这个示例软键盘弹起后显示表情栏，软键盘收起后隐藏表情栏。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151119.24696427830173832446179611468614:50001231000000:2800:ED63F6D5EF982CBA2EE5EF8F740F8B46DB71922F22775FE28605D8637FD6537E.png)
上面效果图的实现示例代码如下，通过on('keyboardHeightChange')方法实时获取软键盘高度赋值给变量keyboardHeight，当keyboardHeight为0的时候表示软键盘处于收起状态，此时隐藏表情栏；keyboardHeight不为0的时候表示软键盘处于弹出状态，此时显示表情栏。
```typescript
import { window } from '@kit.ArkUI';
@Entry
@Component
struct GetKeyboardHeightDemo {
@State keyboardHeight: number = 0; // 软键盘高度
aboutToAppear(): void {
window.getLastWindow(getContext(this)).then(currentWindow => {
currentWindow.on('keyboardHeightChange', (data: number) => {
this.keyboardHeight = px2vp(data);
})
})
}
build() {
Column() {
// ...
TextInput()
if (this.keyboardHeight > 0) {
Row() { // 表情栏
// ...
}
// ...
}
}
}
}
```
监听获取安全区域高度
通过window模块的on('avoidAreaChange')方法开启当前窗口系统规避区变化的监听，获取内容可视区域大小，同时也可以监听软键盘的弹出收起。开发者可以根据软键盘弹出之后的可视区域大小去动态的调整布局中组件的高度去适配界面。具体运用可以参考软键盘避让常见问题中通过监听软键盘弹出，实现软键盘避让示例。
```typescript
import { window } from '@kit.ArkUI';
@Entry
@Component
struct GetSafeAreaHeightDemo {
@State screenHeight: number = 0; // 安全区域高度
@State isKeyBoardHidden: boolean = false; // 软键盘是否隐藏
aboutToAppear(): void {
window.getLastWindow(getContext(this)).then(currentWindow => {
let property = currentWindow.getWindowProperties();
let avoidArea = currentWindow.getWindowAvoidArea(window.AvoidAreaType.TYPE_KEYBOARD);
// 初始化显示区域高度
this.screenHeight = px2vp(property.windowRect.height - avoidArea.topRect.height - avoidArea.bottomRect.height);
// 开启当前窗口系统规避区变化的监听
currentWindow.on('avoidAreaChange', data => {
if (data.type !== window.AvoidAreaType.TYPE_KEYBOARD) {
return;
}
if (data.area.bottomRect.height <= 0) {
this.isKeyBoardHidden = true;
} else {
this.isKeyBoardHidden = false;
}
this.screenHeight = px2vp(property.windowRect.height -data.area.topRect.height - data.area.bottomRect.height);
console.info(`screen height is: ${this.screenHeight}`);
})
})
}
build() {
Column() {
TextInput()
}
}
}
```
软键盘避让机制
解决软键盘的界面适配问题，首先需要了解在HarmonyOS系统中软键盘的避让机制是怎么样的。
软键盘默认避让效果
为了确保输入框不被软键盘挡住，系统默认提供了输入框避让软键盘的能力，结合下面这个输入框列表，介绍软键盘避让的主要表现形式。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151119.05610857402286015778931108538065:50001231000000:2800:C255546FD4CD31434395A665A99047A2DCD0CDB3A6C3B5866B2B71B935C6729C.png)
-
-
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151119.70156019880163588521812325939764:50001231000000:2800:BA5DA27F48DD6EBC2E3700025E73ACA85CBBEC472F16B0643413C799C59697EA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151119.85321348170212452526541476584764:50001231000000:2800:51A3E0D5C98268E891C34AD5B9EEDC4839194BA0C8C588332EF517F593CA94E6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151119.67433091449792300902159095355802:50001231000000:2800:11311651C4C22E43AB944330DE14DFBE329A801E298E0D433CDB2A2DF91B0E5E.png)
但是系统默认的软键盘避让形式只能保证输入框不被遮挡，输入框下方的组件可能就会被软键盘挡住，解决这一问题，这就需要了解软键盘的避让模式了。
软键盘避让模式
当用户在输入时，为了确保输入框不会被键盘遮挡，系统提供了避让模式来解决这一问题。开发者可以通过setKeyboardAvoidMode控制虚拟键盘抬起时页面的避让模式，键盘抬起时默认页面避让模式为上抬模式，下面列举了上抬模式和压缩模式。
-  示意效果如下，上抬整个页面实现软键盘避让：
-  示意效果如下，通过压缩内容区域高度实现软键盘避让：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151119.59497068655343051931057670784417:50001231000000:2800:0E94CC0518733B51B979D1E528BE195D01AE6CA911917BE7BAF58954F2FE1846.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151119.47636754870741921619785461877882:50001231000000:2800:A55D749ED4AF852FA3A8D0C4A001D1643BB8AD0D0C42807418B7F2C33FB4E128.png)
设置组件不避让软键盘
前面介绍的避让模式，组件会为了避让软键盘而产生位移。有时希望组件不要避让软键盘，比如软键盘的避让模式为上抬模式时，想要顶部的标题栏不要上抬。这种需求该怎么实现呢？这就需要了解安全区域和expandSafeArea属性了。
通过expandSafeArea属性支持组件不改变布局情况下扩展其绘制区域至安全区外，当设置expandSafeArea属性type为SafeAreaType.KEYBOARD的时候，即expandSafeArea([SafeAreaType.KEYBOARD])，系统会将软键盘区域视作安全区，从而不会避让软键盘。如果您希望某些组件不避让软键盘弹出，可以给组件设置expandSafeArea属性。
组件避让软键盘的示例效果如下，软键盘弹出时页面整体上抬，自定义标题栏固定不动，具体实现可以参考软键盘弹出导致布局错位的示例。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151119.69043417077837528861049213665026:50001231000000:2800:7575A073E67D08364F889B9C67921BD453BB26EACCA597581C30F4DE232B666E.png)
软键盘避让常见问题
下面列举一些常见的软键盘适配问题，帮助开发者了解软键盘的适配方法。
重要信息被软键盘遮挡
例如下面这个电子邮件的示例，内容由三部分组成：标题栏、内容区域和底部操作栏。当点击输入内容的输入框，软键盘会挡住底部的操作栏，影响用户体验，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151120.53634669670993882593018446876101:50001231000000:2800:A532F9288270462AFEB2AB2A939F3FD55F8A79AFDDF8411CAACCF9467C643A7C.png)
对应的示例代码如下，其中标题栏和底部操作栏都是固定的高度56，内容区域高度是非固定高度layoutWeight(1)，自适应高度。
开发者可以通过设置软键盘的避让模式为KeyboardAvoidMode.RESIZE（压缩模式），来解决底部操作栏被遮挡的问题，设置该属性后，软键盘的避让会通过压缩内容区域的高度来实现。示例代码如下：
需要注意的是内容区域高度的设置需要用百分比的方式实现，效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151120.51730226788711299166378940124604:50001231000000:2800:A498780F9629682C364C8AF30CC2DD6B7129B0DDE2CA2F7D5E9BF241E0A67037.png)
通过监听软键盘弹出，实现软键盘避让
上面这个示例开发者还可以通过window模块的getWindowAvoidArea方法，监听获取软键盘弹出，获取安全显示区域高度动态设置页面高度。示例代码如下：
当系统的避让机制可能满足不了开发者的一些需求的时候，开发者可以尝试监听软键盘弹出，根据获取的安全区域或者软键盘高度，来调整布局大小和位置来避让软键盘。
软键盘弹出导致布局错位
内容向上滚动避让，顶部固定
例如下面这样的一个聊天界面，顶部是一个自定义的标题，下方为可滚动聊天消息区域，底部是消息输入框，示例代码如下：
但是由于软键盘避让默认是上抬模式，会把整个页面向上抬起，所以标题也会被顶上去，如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151120.45290105473403122820134103919618:50001231000000:2800:29B028EAECE9109187F3C59CE8758585B4B9512E9E793B5682C631F93A5F660E.png)
现在需求希望顶部标题固定，点击底部输入框软键盘弹起的时候，标题不上抬，只有内容区域上抬。效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151120.03636664553807768882996935350008:50001231000000:2800:B45258A6BE91D0505B358C2C48769214A6A42CA0D071FA29A53BA25CD3D8F170.png)
想要顶部标题不被软键盘向上抬，需要给对应的组件设置 .expandSafeArea([SafeAreaType.KEYBOARD])}属性，使标题组件不避让键盘，示例代码如下：
具体实现可以参考Sample代码Keyboard。
软键盘弹出导致弹窗过度上抬
自定义弹窗被键盘顶起，影响用户体验
在软键盘系统避让机制中介绍过，弹窗为避让软键盘会进行避让，整体向上抬，这样可能会影响用户体验。比如下面这个评论里列表的弹窗，使用@CustomDialog实现的，示例代码如下：
当用户点击弹窗底部的输入框的时候，弹窗会整体上抬，输入框上抬的距离也过多。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151120.39569141823552280537672782905118:50001231000000:2800:C692137CBA995BE673D6671EC4532AE2FED914D9FCE983F25BF599BD9B32090A.png)
为了解决以上问题，可以使用Navigation.Dialog，通过设置NavDestination的mode为NavDestinationMode.DIALOG弹窗类型，此时整个NavDestination默认透明显示，示例代码如下：
```typescript
@Entry
@Component
struct NavDestinationModeDemo {
@Provide('NavPathStack') pageStack: NavPathStack = new NavPathStack()
@Builder
PagesMap(name: string) {
if (name === 'DialogPage') {
DialogPage()
}
}
build() {
Navigation(this.pageStack) {
Column() {
Button('click me')
.onClick(() => {
this.pageStack.pushPathByName('DialogPage', '');
})
}
.height('100%')
.width('100%')
.justifyContent(FlexAlign.Center)
}
.mode(NavigationMode.Stack)
.navDestination(this.PagesMap)
}
}
@Component
export struct DialogPage {
@Consume('NavPathStack') pageStack: NavPathStack;
listData: string[] = ['评论1', '评论2', '评论3', '评论4', '评论5', '评论6', '评论7', '评论8'];
build() {
NavDestination() {
Stack({ alignContent: Alignment.Bottom }) {
Column() {
Text('评论')
.fontSize(20)
.fontWeight(FontWeight.Medium)
List() {
ForEach(this.listData, (item: string) => {
ListItem() {
Text(item)
.height(80)
.fontSize(20)
}
}, (item: string) => item)
}
.scrollBar(BarState.Off)
.width('100%')
.layoutWeight(1)
TextInput({ placeholder: 'Please input content' })
.height(40)
.width('100%')
}
.backgroundColor(Color.White)
.height('75%')
.width('100%')
.padding(12)
}
.height('100%')
.width('100%')
}
.backgroundColor('rgba(0,0,0,0.2)')
.hideTitleBar(true)
.mode(NavDestinationMode.DIALOG)
}
}
```
此外还需要设置软键盘避让模式为压缩模式，示例代码如下：
运行效果如下，点击输入框后，内容区域会进行压缩，弹窗整体不会发生上抬。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151120.68122877371350297512623154536073:50001231000000:2800:F33380C51D60063CF3799A58A4CBF721D96E84137250B11B3A87DAFA945A6931.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-custom-keyboard
爬取时间: 2025-05-01 09:39:23
来源: Huawei Developer
概述
自定义键盘是一种简易的键盘替换系统默认键盘，允许用户根据实际业务场景和习惯偏好，调整键盘的布局和位置、添加额外的功能键，使输入更加便捷和舒适，从而提升整体的用户体验。同时自定义键盘也可以增强用户输入的安全性，避免敏感信息被截取或者泄露。
本文将从以下几个方面介绍自定义键盘的实现和使用：
自定义键盘的实现
自定义键盘的实现包括以下几个步骤：
自定义键盘布局实现
自定义键盘的布局以自定义组件的方式呈现，根据具体业务场景由开发者实现。自定义键盘的高度通过自定义组件根节点的height属性设置，宽度不可设置，默认铺满屏幕。
以Grid方式实现数字键盘布局示例：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151120.59566701251356148134858802329429:50001231000000:2800:BA9159C7C4903074AABDCFB2CF58401A39E9DC026A1F6BEF501466D2C079F3A2.gif)
```typescript
// entry/src/main/ets/view/NumberKeyboard.ets
@Component
export struct NumberKeyboard {
@Consume inputText: string;
@Consume keyBoardController: KeyboardController;
layoutOptions: GridLayoutOptions = {
regularSize: [1, 1],
irregularIndexes: [14, 16],
onGetIrregularSizeByIndex: (index: number) => {
if (index === 14) {
return [2, 1];
}
return [1, 2];
}
}
build() {
Grid(undefined, this.layoutOptions) {
ForEach(numberKeyboardData, (item: Menu) => {
GridItem() {
Button(item.text, { type: ButtonType.Normal })
.onClick(() => {
this.inputText = this.keyBoardController.onInput(item.text);
})
.fontColor(Color.Black)
.backgroundColor(item.backgroundColor)
.borderRadius(Constants.KEYBOARD_BUTTON_RADIUS)
.fontSize(Constants.KEYBOARD_BUTTON_FONTSIZE_18)
.padding(0)
.width(item.width)
.height(item.height)
}
}, (item: string) => JSON.stringify(item))
}
.columnsTemplate('1fr 1fr 1fr 1fr 1fr')
.rowsGap($r('app.float.number_keyboard_grid_gap'))
.columnsGap($r('app.float.number_keyboard_grid_gap'))
}
}
```
输入控件绑定自定义键盘布局
输入控件（TextArea、TextInput、RichEditor、Search）支持通过customKeyboard属性绑定自定义键盘布局。绑定自定义键盘后，输入控件获取焦点时，不会拉起系统键盘，而是加载指定的自定义键盘。本文后续以TextInput控件为例进行介绍。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151120.64880921637160857973261750896731:50001231000000:2800:3CB66B3FEA392103E654AF5ACF2CEA0A6CE9298701DF2198946860CFE9EF905D.gif)
代码示例如下：
自定义键盘输入控制
自定义键盘可以拦截手势事件，通过对状态变量的修改，实现文本的输入。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151120.80630755425165941195623304004855:50001231000000:2800:B4DF3D5BF0ADD4A887FA1E95C21412C237569A2484E28C8DC0D962D76487B599.gif)
以英文键盘为例，监听EnglishButton的onClick事件，修改状态变量。
通过对状态变量inputText的修改，实现文本输入。
自定义键盘光标控制
通过监听TextInput的onTextSelectionChange生命周期，获取初始光标位置、文本输入后，调用TextInputController的caretPosition方法，设置最终光标位置。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151120.81318198800244041212821616492778:50001231000000:2800:FA9D75A9A10AEFD5B2CB792A37A294A345FFE3493815981682A03D3B6F75F27D.gif)
获取光标位置：
设置光标位置：
自定义键盘弹出与收起
通过对焦点进行控制，可以实现键盘的弹出和收起，参考软键盘的弹出收起和监听。
开发者也可以通过TextInputController的stopEditing方法控制键盘关闭，下面的自定义键盘示例中，点击确认按键关闭自定义键盘。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151120.14726676549369086217930221589880:50001231000000:2800:4BA4975F9972CB54A71D4D57A21EADBC3B7D1AF40AD498E1604A312D9C6105B6.gif)
自定义键盘和系统键盘的切换
当需要实现同一个输入框内可以切换自定义键盘和系统键盘时，可以通过如下方式实现：
Tab栏点击“123”、“ABC”按钮，this.isCustomKeyboardAttach为true，TextInput绑定自定义键盘；点击“中文”按钮，this.isCustomKeyboardAttach为false，切换系统键盘。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151120.47277079872940093169964211161454:50001231000000:2800:16F06B8274E9390A0F5C723D4ACC61235154282444B2A9FEAA3905976ED2BACC.gif)
自定义键盘的布局避让
使用系统提供的自定义键盘避让功能
为了确保输入框不被自定义键盘挡住，系统默认提供了输入框避让自定义键盘的能力。在TextInput组件的customKeyboard属性设置supportAvoidance为true，开启系统提供的自定义键盘避让功能。键盘的避让机制和常见问题的解决方法，可以参考软键盘布局适配场景介绍。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151121.23395841716772916030128539359200:50001231000000:2800:B0A6038B152D0D91E2986BF6BD43A1E9A1C41B355F23AB45C894C370CC62A749.gif)
系统默认的自定义键盘避让功能只能保证输入框不被遮挡，输入框下方的组件可能会被自定义键盘挡住，如上图中所示，输入框下方的tab栏被自定义键盘挡住。为解决这一问题，需要开发者自己实现自定义键盘的避让功能。
开发者自己实现自定义键盘的避让功能
开发者需要监听自定义键盘根节点的onAreaChange生命周期，获取自定义键盘的高度，根据实际场景设置布局的避让。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151121.48837993265439920591564187781872:50001231000000:2800:A08EABCB03DFACB9981D8A8A2B967011CC71662D572CC502C781758C4911D286.gif)
监听自定义键盘布局的onAreaChange生命周期，通过newValue.height获取自定义键盘弹出时的高度，根据实际业务场景计算布局避让高度avoidHeight。
```typescript
// entry/src/main/ets/view/CustomKeyboard.ets
@Component
export struct CustomKeyboard {
// ...
build() {
Column() {
// ...
}
.onAreaChange((oldValue: Area, newValue: Area) => {
this.customKeyboardHeight = Number(newValue.height);
let avoidHeight: number = (this.isCustomKeyboardAttach ? this.customKeyboardHeight : this.systemKeyboardHeight)
- this.bottomRectHeight;
this.keyBoardController.changeAvoidHeight(avoidHeight);
})
// ...
}
}
```
通过emitter的方式，发送自定义键盘高度变化的通知。
接收到高度变化通知后，根据实际业务场景，设置页面的避让高度。
自定义键盘实现防截屏
用户使用自定义键盘输入敏感信息时，可以设置禁止截屏，有效防止他人在未经许可的情况下获取用户的敏感信息，从而保护用户的隐私安全。具体实现参考如何实现防截屏功能。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-local-file
爬取时间: 2025-05-01 09:39:35
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-local-file-and-data-multithreaded-io
爬取时间: 2025-05-01 09:39:49
来源: Huawei Developer
概述
应用中的每个进程都会有一个主线程，主线程主要承担执行UI绘制操作、管理ArkTS引擎实例的创建和销毁、分发和处理事件、管理Ability生命周期等职责，具体可参见线程模型概述。在主线程中执行耗时操作将会引起UI绘制卡顿，因此，开发应用时应当尽量避免将耗时的操作放在主线程中执行。ArkTS提供了多线程并发能力，多线程并发允许在同一时间段内同时执行多段代码，本文介绍如何利用多线程解决密集型文件和数据库读写时造成主线程阻塞的问题。
实现原理
在密集型读写操作时，由于系统会进行大量任务分发和数据拷贝，这两项任务均会阻塞主线程，系统提供了TaskPool和Sendable避免阻塞。
其中，任务池（TaskPool）旨在为应用程序构建多线程运行环境，它具有易用性，并且可以避免对于主线程的占用；Sendable对象则提供了并发实例间高效的通信效率，凭借其引用传递的能力，在多并发实例的数据交互等场景中可避免传统通信方式的效率低下问题，从而进一步提升系统在密集型读写这类复杂场景下的性能表现，为系统的高效稳定运行提供有力支持。
使用TaskPool进行读写
本章介绍使用TaskPool进行读写的方案，以及讨论其对于性能的提升。
实现原理
任务池（TaskPool）作用是为应用程序提供一个多线程的运行环境，降低整体资源的消耗、提高系统的整体性能，且开发者无需关心线程实例的生命周期。更多原理请详见TaskPool简介。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151121.59082144985587939115302960638783:50001231000000:2800:8308B43FC86DD52C4A2EAC1752BBB02462540712CB24B09CDB5EA455171EFD66.png)
TaskPool在执行密集型I/O读写方面具有以下优势：
TaskPool文件读写
开发步骤
TaskPool关系型数据库读写
开发步骤
使用Sendable进一步提升性能
在上一章节中介绍了如何使用TaskPool进行读写，解决了密集型读写场景下任务分发的的问题，但是实际开发中还面临密集的数据传递问题，系统提供了@Sendable进行解决，本章我们介绍如何在TaskPool基础上使用@Sendable。
实现原理
为了实现Sendable数据在不同并发实例间的引用传递，Sendable共享对象会分配在共享堆中，以实现跨并发实例的内存共享。
共享堆（SharedHeap）是进程级别的堆空间，与虚拟机本地堆（LocalHeap）不同的是，LocalHeap只能被单个并发实例访问，而SharedHeap可以被所有线程访问。一个Sendable共享对象的跨线程行为是引用传递。因此，Sendable可能被多个并发实例引用，判断Sendable共享对象是否存活，取决于所有并发实例的对象是否存在对此Sendable共享对象的引用，更多原理请见Sendable的实现原理。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151121.58461193944068931048006229095765:50001231000000:2800:F7DB234655E2C78C62F6D65F8F45BCACA5823BA9715DF9B62AC439015BFB1702.png)
在密集型I/O处理场景中，文件读写会涉及大量数据的传输，而数据库读写则通常被封装成class进行传递，Sendable用引用代替拷贝，可以有效的降低序列化时间，从而提升性能，Sendable主要可以解决两个场景的问题：
文件读写大数据使用@Sendable传输
开发步骤
```typescript
@Sendable
class Content {
content: string;
constructor(content: string) {
this.content = content;
}
}
```
关系型数据库读写使用@Sendable
开发步骤

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-ndk-development
爬取时间: 2025-05-01 09:40:02
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-file-native-side
爬取时间: 2025-05-01 09:40:16
来源: Huawei Developer
概述
在对文件处理性能要求高的场景中，Native侧访问文件处理数据比在ArkTS侧操作文件有更高的效率和更快的响应，例如处理大文件、复杂的文件操作以及实时通信等低时延场景。根据文件位置的不同，应用在Native侧访问文件可以分为以下三种类型：
本文将针对这三种场景给出具体的实现方案。
访问应用沙箱文件
应用沙箱是一种以安全防护为目的的隔离机制，避免数据受到恶意路径穿越访问。在这种沙箱的保护机制下，应用可见的目录范围即为“应用沙箱目录”，沙箱中的文件就需要通过沙箱路径去进行访问。Native侧获取沙箱路径的方案有两种：
方案一：ArkTS侧获取沙箱路径传递给Native侧访问文件
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151121.41671886480246073902031507387322:50001231000000:2800:C73F4548FD1EB7E17BEAD513E9C5DD1105B9D4524AF04E70A242FD6501F2437F.png)
实现方案
这里以访问沙箱文件并写入文本的场景为例，实现方案分为Native侧定义操作文件的方法和ArkTS侧调用该方法两部分。
第一部分：在Native侧定义一个方法，用于接收沙箱路径并将文本写入到文件中。
```typescript
export const transferSandboxPath: (path: string, contents: string) => void;
```
第二部分：在Native侧访问沙箱文件写数据的功能实现后，在ArkTS侧调用该方法。
通过上述步骤，实现了在Native侧通过ArkTS侧传递的沙箱路径访问与操作应用沙箱文件的方案。
效果展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151121.72022393256272360538247786392153:50001231000000:2800:FA82B4DA02050076F25168E33DF609D754AFF0A51424943CE6A91EDF37F39F44.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151121.07920322560028965349529878057567:50001231000000:2800:2893516FB4C1DC1DFCB48384EBFF2770F5F506488BE4F7E216CE2AB6559F8A8D.png)
方案二：Native侧直接拼接沙箱路径访问文件
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151121.69399898566833102038378505524022:50001231000000:2800:3D3230CBAE30534E62060FE42FDC87C359F88EB149FEC77DABDE09366E78ECDB.png)
实现方案
这里同样以访问沙箱文件并写入文本的场景为例，实现方案分为Native侧定义操作文件的方法和ArkTS侧调用该方法两部分。
第一部分：在Native侧定义一个方法，用于拼接沙箱路径并将文本写入到文件中。
```typescript
export const splicePath: (contents: string) => void;
```
第二部分：Native侧访问沙箱文件写数据的功能实现后，在ArkTS侧调用该方法。
通过上述步骤，实现了在Native侧通过拼接沙箱路径访问与操作应用沙箱文件的方案。
效果展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151121.90860715211713740839838082735962:50001231000000:2800:AE26BB075DF5AB0C31D880FC397AD729A322F6EB496F6CF8498A336EB46073BC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151121.84971030476425719955455317615451:50001231000000:2800:522E6DCFEE42A9D16541DA998BD9EC472FBAAA1ADAC21EFA631BA637FDC707B1.png)
访问应用包内资源文件
Native侧可以通过Resource Manager操作应用资源文件中的Rawfile目录和文件，这里以Native侧读取Rawfile文件内容的场景为例介绍该方案。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151121.20932541749512520864136617634988:50001231000000:2800:EEA1D83177890CFDF541C4B494BE44B2F8F5495AC3CA608917757D16D387A212.png)
实现方案
实现方案分为Native侧定义操作文件的方法和ArkTS侧调用该方法两部分。
第一部分：在Native侧定义一个读取文件的方法，注意使用Resource Manager需要引用头文件rawfile/raw_file_manager.h，并在工程的cmakelists.txt文件中链接动态库librawfile.z.so。
```typescript
export const transferResourceMgr: (resMgr: resourceManager.ResourceManager, path: string) => string;
```
第二部分：Native侧访问Rawfile文件读数据的功能实现后，在ArkTS侧调用该方法。
通过上述步骤，实现了在Native侧通过ArkTS侧传递的Resource Manager访问与读取应用资源文件的方案。
效果展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151122.58040473206124475738562504817019:50001231000000:2800:D7B776341EE6E6E1A5EBB677116E291DF33B93B21A1BC0E30AC43A30EB7EF4AC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151122.36918792024677409228860685591771:50001231000000:2800:7147BCD33B5DB8A448671EBFABCC40D58DDFB18EB2D8EA0F6C14EE9E0C6BDC7A.png)
访问公共目录文件
系统公共目录下储存的是用户文件，应用对用户文件的操作需要提前获取用户授权，或由用户操作完成。我们可以通过系统预置的文件选择器（FilePicker）实现该能力，目前主要有创建文件、写入和读取三类操作，创建文件可以直接使用picker，针对Native侧，有如下两种场景：
场景一：写数据到公共目录文件
场景描述
ArkTS侧通过文件picker在公共目录下创建文件，并传递文件描述符到Native侧，Native侧通过文件描述符打开文件并将数据写入到文件中。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151122.45064280314077518143994159593575:50001231000000:2800:4EBA62E44C937A14EE817CB8D2992C72B4C8E2F844F58684F845ADE7A7307C3A.png)
实现方案
实现方案分为Native侧定义操作文件的方法和ArkTS侧调用该方法两部分。
第一部分：在Native侧定义一个方法，用于接收文件描述符并将数据写入到文件中，注意使用文件描述符操作文件需要引用头文件unistd.h。
```typescript
export const writeFileUsingPickerFd: (fd: number, contents: string) => string;
```
第二部分：Native侧访问公共目录文件写数据的功能实现后，在ArkTS侧调用该方法。
```typescript
// entry/src/main/ets/common/utils/FileOperate.ets
async function WriteFileByPicker(contents: string): Promise<string> {
//配置picker选择信息
const documentSelectOptions = new picker.DocumentSelectOptions();
documentSelectOptions.maxSelectNumber = 1;
documentSelectOptions.fileSuffixFilters = ['.txt'];
let uris: Array<string> = [];
const documentViewPicker = new picker.DocumentViewPicker();
//拉起picker选择文件
return await documentViewPicker.select(documentSelectOptions).then((documentSelectResult: Array<string>) => {
uris = documentSelectResult;
let uri: string = uris[0];
let path: string = new fileUri.FileUri(uri).path;
console.info(`Open The File path is [${uri}]`);
let file = fs.openSync(path, fs.OpenMode.WRITE_ONLY);
//调用native方法写文件
let res = FileAccess.writeFileUsingPickerFd(file.fd, contents);
fs.closeSync(file.fd);
return res;
}).catch((error: BusinessError) => {
console.error(`Open The file failed, error code is [${error.code}], error message is [${error.message}]`);
return 'Write Failed by Picker';
})
}
```
通过上述步骤，实现了在Native侧通过ArkTS侧picker传递的文件资源描述符访问公共目录文件并写入内容的方案。
效果展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151122.05669501840890126647026031223815:50001231000000:2800:D95332A5D91FB895EB2D3FBA77995575847AEB98B869B3E7864809AE18CD3493.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151122.29059087076802450101970433325356:50001231000000:2800:7E145CA737A36F242C4D377BDE370A20282C2CB53302FFFBF152134D24122D3F.png)
场景二：从公共目录文件中读取数据
场景描述
ArkTS侧通过文件picker选择文件，并传递文件描述符到Native侧，Native侧通过文件描述符打开文件并读取文件数据。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151122.65126813821389563983679287207005:50001231000000:2800:0A9A4112B71A775A7B04FEB556FDC543A4E7D520A9F3FC25AB168C88CAD5725C.png)
实现方案
实现方案分为Native侧定义操作文件的方法和ArkTS侧调用该方法两部分。
第一部分：在Native侧定义一个方法，用于接收文件描述符并将数据写入到文件中，注意使用文件描述符操作文件需要引用头文件unistd.h。
```typescript
export const readFileUsingPickerFd: (fd: number) => string;
```
第二部分：Native侧访问公共目录文件读数据的功能实现后，在ArkTS侧调用该方法。
```typescript
// entry/src/main/ets/common/utils/FileOperate.ets
async function ReadFileByPicker(): Promise<string> {
//配置picker选择信息
const documentSelectOptions = new picker.DocumentSelectOptions();
documentSelectOptions.maxSelectNumber = 1;
documentSelectOptions.fileSuffixFilters = ['.txt'];
//拉起picker选择文件
let uris: Array<string> = [];
const documentViewPicker = new picker.DocumentViewPicker();
return await documentViewPicker.select(documentSelectOptions).then((documentSelectResult: Array<string>) => {
uris = documentSelectResult;
let uri: string = uris[0];
let path: string = new fileUri.FileUri(uri).path;
console.info(`The Opened File path is [${uri}]`);
let file = fs.openSync(path, fs.OpenMode.READ_ONLY);
//调用native方法读文件
let res = FileAccess.readFileUsingPickerFd(file.fd);
fs.closeSync(file.fd);
return res;
}).catch((error: BusinessError) => {
console.error(`Open The file failed, error code is [${error.code}], error message is [${error.message}]`);
return 'Read Failed by Picker!';
})
}
```
通过上述步骤，实现了在Native侧通过ArkTS侧picker传递的文件资源描述符访问公共目录文件并读取内容的方案。
效果展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151122.10439593158637331154957309824658:50001231000000:2800:3AD37DB4E3D8916D7C3F0FF4060E3C274A85105F5FD3E01887D8075752B60327.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151122.61939993160310220815782456707895:50001231000000:2800:508239C52203FE340CDFE836B22F69BEE9D6399A770F4CD246F9A299E862322D.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-complex-type-pass
爬取时间: 2025-05-01 09:40:29
来源: Huawei Developer
概述
开发者为了提高程序运行效率，通常需要将一些运算量较大的内容放在C++环境中运行，因此经常需要进行ArkTS与C++之间的数据传递。本文以常见的五种数据类型：Array(uint8Array)、Object、HashMap、PixelMap、Class为例，向开发者介绍如何进行复杂参数的跨语言传递。
在开始介绍不同场景的开发流程之前，请注意，跨语言数据传递，需要使用Node-API。因此，在新建项目后，请手动新建Native模块，方法如图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151122.59410637421893604091051131528061:50001231000000:2800:0849D8EC0AB6A3B9BC2A81AC3D61FE11A5EF20444D45CAE483624DD9872C28E9.png)
场景案例
arrayBuffer类型数据交互
本章以简单的数组传递场景为例，在ArkTS侧输入一个Uint8Array数组，传递到C++侧，再构造另一个数组，并返回ArkTS侧。
以此为例，介绍ArrayBuffer类型的数据如何相互传递使用。除数组外，string等连续数据类型也可参考本段。
实现原理
ArrayBuffer是一种用于表示通用的、固定长度的原始二进制数据缓冲区的对象。在C++侧接受该类型参数时一般会通过Node-API提供的函数（如napi_get_arraybuffer_info）获取到ArrayBuffer的数据指针和长度，从而可以访问和操作这些数据。
从C++侧传递ArrayBuffer数据到ArkTS侧时，通常会在C++层创建出一个数据缓冲区（如std::vector<uint8_t>）并填充所需的数据。然后使用Node-API提供的函数（如napi_create_arraybuffer和napi_create_typedarray）在ArkTS侧创建一个新的ArrayBuffer对象，并将其与C++层的数据缓冲区关联起来。最后传递该对象到ArkTS侧。
开发步骤
1.  使用时将Uint8Array类型的数据作为参数传入uint8ArrayPassing函数即可。
2.  在这段代码中，先用三个函数获取关键信息： napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_get_typedarray_info：用于在Node-API模块中获得某个TypedArray的各种属性。 napi_get_arraybuffer_info：获取ArrayBuffer的底层数据缓冲区和长度。 之后，通过循环配合指针和偏移量，读取其中的数据，并将其存入inputArray中。 在这段代码中，先用两个函数构建buffer和array： 之后，通过循环，将数据压入output_buffer，再返回output_array，即完成了uint8Array类型数据向ArkTS的传递。
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151122.66321751717654300386868630454597:50001231000000:2800:C573ABA80E05DD326BCFB02A571D739C797CC96AEA4A255BC671E10DE4627B57.png)
object类型数据交互
本章通过模拟一个“排号机”应用，向开发者介绍如何进行object数据类型的相互传递，以及如何解析、修改其中的数据。
实现原理
Object类是所有其他类型的基类。在C++侧接收该类型参数时一般会通过Node-API提供的函数（如napi_get_named_property）来获取object对象的某个属性，从而操作其属性值。
从C++侧传递object类型到ArkTS侧时，可以利用Node-API封装好的接口（napi_create_object_with_named_properties）直接通过传递参数数组的方式构建出一个带有给定属性值的object类型对象。
开发步骤
1.  特别的，此处还需定义需要使用的object数据类型。
2.  napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_get_named_property：负责获取并储存inputObj中的属性。 napi_get_value_int32：负责将获取到的inputAge属性解析为int32数据，并存入age中。 napi_get_boolean：负责将需要返回的boolean属性写入对应的napi_value量中。 napi_create_int32：负责将需要返回的int32属性写入对应的napi_value量中。 napi_create_object_with_named_properties：负责构造需要返回的object。
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151122.53294276261490677246064450851319:50001231000000:2800:F8D9127D07CE355E865D3991E7ACC17C1B917710AC7CA687DF4A1ECA4588E96D.png)
hashMap类型数据交互
本章通过模拟一个“积分累计”应用，每次输入对象的本次积分，并返回所有对象的累积积分。向开发者介绍如何进行hashMap数据类型的相互传递，以及如何解析、修改其中的数据。
实现原理
hashMap是一种基于哈希表的Map接口实现的数据结构。在C++侧接受改类型参数时，由于C++没有可以直接接收该类型参数的数据类型，所以一般采用两种方式进行传递。
1.传递数组：分别将HashMap的key、value作为数组取出，然后将两个数组传递至C++侧并组装成Map进行数据处理。
2.传递JSON：将HashMap转为Json字符串传递至C++侧，在C++侧通过反序列化的方式构造成Map类型数据进行处理。
同样的，从C++侧传递Map类型到ArkTS侧时，需要将Map序列化成Json字符串传递到ArkTS，然后在ArkTS侧进行反序列化获取对应参数。
开发步骤
1.  此外，由于程序不支持直接传递hashMap类型，因此需要使用其他数据类型作为媒介。 有两种主流方案： 本文以前者为例，后者可参考：如何实现ArkTS与C/C++的HashMap转换 之后，将Record类型数据通过JSON.stringify序列化后即可传入C++侧。
2.  其中hashMapPassingNapi2Ts与hashMapPassingTs2Napi分别负责数据从ArkTS至C++传递与反向传递。同时，在C++侧，也需完成序列化和反序列化，本文采用nlohmann三方库完成此操作。 napi_get_cb_info：负责从ArkTS侧获取输入参数。 value2String：将napi_value数据解析为string的过程包装为一个函数，方便多次调用。 nlohmann::json::parse：负责将string反序列化为map<string, int>类型数据。 此处stringSize需要+1，这是因为napi_value是一个C的结构体指针，C语言的字符串实际上是使用空字符 \0 结尾的一维字符数组。而napi_get_value_string_utf8返回的stringSize，其长度不含结尾的\0。为了保证写入valueString的内容包含结尾的\0，所以需要+1。 nlohmann::ordered_json：负责将map序列化。 dump：负责将序列化后的数据转换为string类型。 string2value：将string转换为napi_value的过程包装为一个函数，方便多次调用。 napi_create_string_utf8：负责将string类型数据转换为napi_value类型。
3.  JSON.parse：此函数只能将string反序列化为object，因此还需额外一步将其转换为hashMap类型。
```typescript
// entry/src/main/ets/pages/HashMapPage.ets
let receiveObj: object = JSON.parse(receiveStr);
let receiveMap: HashMap<string, number> = new HashMap();
Object.entries(receiveObj).forEach((value: [string, number]) => {
receiveMap.set(value[0], value[1]);
})
```
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151122.11845471198423556343084603158922:50001231000000:2800:FF498FCF6931E3483E675C6FC15AEEC8CBCA913573D58744275BFC8B5EAC2AE0.png)
pixelMap类型数据交互
本章以图片处理应用为例，介绍如何进行pixelMap类型数据交互。
除本文介绍的方法外，也可通过readPixelsToBuffer将其转换为Uint8Array类型，进行处理。此方案可以参考arrayBuffer类型数据交互，本文不作介绍。
在进行应用开发之前，开发者需要打开native工程的src/main/cpp/CMakeLists.txt，在target_link_libraries依赖中添加image的libpixelmap_ndk.z.so
实现原理
PixelMap 是一种用于显示图像的数据结构。在C++侧接收该类型参数的时候，可以直接调用libpixelmap.so库中的函数直接通过ArkTS侧的pixelmap对象构造出Native侧的pixelmap类型对象（NativePixelMap），进而对其进行数据处理。
由于pixelMap类似一个C++语言中的指针，通过上述操作之后更改了其指向的内容，因此在ArkTS侧通过设定延迟可以直接触发ArkTS侧的图像自渲染，从而实现ArkTS页面刷新，直接显示修改后的图像。
开发步骤
1.  createPixelMap：负责将从imageResource加载的图片解码为pixelMap格式。
2.  napi_get_cb_info：负责从ArkTS侧获取输入参数。 OH_PixelMap_InitNativePixelMap：负责初始化NativePixelMap对象。 OH_PixelMap_SetOpacity：负责修改NativePixelMap中的不透明度。 其他诸如旋转、缩放等操作可以参考使用Image处理PixelMap数据。 输入的TSPixelMap与生成的NativePixelMap共享内存空间，因此直接调用相关方法修改NativePixelMap对象，即可同步影响TSPixelMap对象。所以此处无需回传数据。
3.  这是因为pixelMap类似一个C语言指针，只更改其指向的内容，其本身值未变，不会引发自动重渲染。此处设定的延迟也是为了确保重渲染可以触发。
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151123.86021441155135039366912615718405:50001231000000:2800:0AE8C47C10163A1B829768AC3FD1F07D94A0628E42E54DA2F8472CA6129A92CC.png)
class类型数据，ArkTS传递至C++
本章以简单的计算器为例，介绍如何进行class类型数据交互。由于两侧传递方式差异较大，因此分为两章讲解。
本章讲解ArkTS传递至C++。
实现原理
ArkTS语言中，class（类）是用于定义对象的模板，并拥有特有的属性和方法。在C++侧接收该类型时与object类型基本一致，一般会通过Node-API提供的函数（如napi_get_named_property）来获取到的class对象的某个属性，从而操作其属性值。
开发步骤
1.  classPassingTs2Napi：负责将class从ArkTS传递至Napi，之后返回一个string作为结果。 napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_get_named_property：第一次调用，负责将方法名为"add"的方法存入变量add中。 napi_create_int32：负责将入参解析为int32，并存入数组arr中。 napi_call_function：负责在C++工程中调用从ArkTS传入的class的方法，需要使用上两步获得的入参数组arr和方法add。 napi_get_named_property：第二次调用，负责将名为"result"的属性存入param_result中。 value2String、string2value：负责napi_value与string类型之间的相互转换，实现方法详见hashMap类型数据交互。
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151123.92068064710203612844312985569297:50001231000000:2800:87C4AEABDBADD280E306AED1197DA066D69821431AF96DA2F6094BB545E37819.png)
class类型数据，C++传递至ArkTS
本章仍以简单的计算器为例，介绍class类型数据如何从C++传递至ArkTS。
实现原理
从C++侧传递class类型到ArkTS侧时，需要在C++侧对C++类方法进行Napi适配，然后再init函数中通过napi_define_class建立ArkTS类方法与C++侧方法的映射关系，然后将对应的class对象挂载到export上导出。注意：需要在index.d.ts文件中声明需要传递的class。
开发步骤
1.  此处需要使用get和set关键字定义访问器，不能直接引用、修改属性。
```typescript
// entry/src/main/cpp/types/libentry/Index.d.ts
export class SampleClassNapi2Ts {
private _hintStr: string;
constructor(hintStr: string);
times(a: number, b: number): string;
public get hintStr();
public set hintStr(value:string);
}
```
2.  在调用时，用法与其他寻常的ArkTS的class一样。无需特别注意。
3.  此处使用ostringstream输出流，以便完成字符串的构造。因此需要提前导入sstream。 同时，还需依次完成供ArkTS调用的访问器、构造函数和方法。 napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_unwrap：负责解析ArkTS class中包装的C++ class，并使用指针c_class_obj进行储存。 string2value：负责将obj->hintStr转换为napi_value，作为输出。此函数的实现方法详见hashMap类型数据交互。 ArkTS侧调用hintStr的值的时候，需要调用此函数，从而获得C++侧的hintStr的值。 初始化阶段的访问器，napi_unwrap后获得的c_class_obj可能为空指针，所以必须验空。下同。 napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_unwrap：负责将传入的ArkTS class解包，获取与其绑定的C++ class，并使用指针c_class_obj进行储存。 napi_get_value_int32：负责将入参解析为int32并存入value0/value1中。 napi_get_cb_info：负责从ArkTS侧获取输入参数。 value2String：负责将入参转换为string。此函数的实现方法详见hashMap类型数据交互。 napi_set_named_property：负责对指定的object加入一个新属性，并指定属性名。ArkTS侧调用的时候，将使用此处指定的名称。
4.  napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_unwrap：负责将传入的ArkTS class解包，获取与其绑定的C++ class，并使用指针c_class_obj进行储存。 napi_get_value_int32：负责将入参解析为int32并存入value0/value1中。
5.  napi_get_cb_info：负责从ArkTS侧获取输入参数。 value2String：负责将入参转换为string。此函数的实现方法详见hashMap类型数据交互。 napi_set_named_property：负责对指定的object加入一个新属性，并指定属性名。ArkTS侧调用的时候，将使用此处指定的名称。
6.  需要先在DevEco Studio预生成的Init函数中，定义一个classProp，并写入class对应的访问器与方法 并调用napi_define_class和napi_set_named_property完成ArkTS class 与C++ class的关联与设置。从而令ArkTS可以调用C++中的class。
1.  napi_get_cb_info：负责从ArkTS侧获取输入参数。 napi_unwrap：负责将传入的ArkTS class解包，获取与其绑定的C++ class，并使用指针c_class_obj进行储存。 napi_get_value_int32：负责将入参解析为int32并存入value0/value1中。
1.  napi_get_cb_info：负责从ArkTS侧获取输入参数。 value2String：负责将入参转换为string。此函数的实现方法详见hashMap类型数据交互。 napi_set_named_property：负责对指定的object加入一个新属性，并指定属性名。ArkTS侧调用的时候，将使用此处指定的名称。
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151123.57810813002440267909283548800935:50001231000000:2800:01D8B423A84D99CE2EFFE66DEC637CFB6FA86774BE944F5306C9C45992275129.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-cross-module-reference
爬取时间: 2025-05-01 09:40:43
来源: Huawei Developer
概述
在大型应用开发中，应用通常会分为多个业务模块，业务模块常会以HSP或HAR包的形式提供SDK能力，这些SDK往往会提供Native接口给HAP模块的Native层直接调用，从而实现应用的复杂功能。而如何在Native侧跨HAR/HSP模块进行接口调用，是开发者经常遇到的问题。本文将介绍Native侧跨HAR/HSP模块调用两种典型场景，包括调用Native方法和调用ArkTS方法，以方便开发者更好的掌握Native侧跨模块调用的能力。
实现原理
如图1所示，Native侧跨HAR/HSP模块调用原理主要包括以下步骤。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151123.23577808413053831803574184968473:50001231000000:2800:B9273B855A7C2B336225401DE1C443ECD7E7F761B56CA73D3F0F52686A5B5264.png)
Native侧跨HAR/HSP模块调用Native方法
如下图所示，Native侧跨HAR/HSP模块调用Native方法的调用链路为Module1 ArkTS -> Module1 Native -> Module2 Native。在HarmonyOS项目中，Native侧跨模块调用Native方法实际就是C++侧调用，需要配置编译链接依赖。其实现的关键是在Module2（HSP/HAR）模块的build-profile.json5中配置头文件导出，并在CMakeLists.txt中进行配置，将源文件配置到so中。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151123.53924582380123755622357071261480:50001231000000:2800:B8A01EB8AA7302473FC767841EA7234EFF15BA57849E42091E825BBBEBF7B5FB.png)
开发流程
在Native侧跨HAR/HSP模块调用Native方法中，需要实现Module1（HAP）的ArkTS 侧调用Module1（HSP/HAR）的Native 侧、Module1（HAP）的Native 侧调用Module2（HSP/HAR）的Native 侧。在当前场景下，跨模块调用HAR模块和HSP模块的方式相同，当前以跨模块调用HAR模块为例，详细流程如下所示。
1.  napi_har.cpp代码如下所示。 napi_har.h代码如下所示。
1.  static_module::add中第一个参数static_module是module2的模块名称，第二个参数add是module2编译出来的so名称（不需要带上lib）。默认情况下，module2的模块名称与so名称相同，为了方便说明，在本案例中将so名称修改成了add。
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151123.28938087046162372390010677352847:50001231000000:2800:E4ED5A96D40F03B51BB1477230FAAC8F7BDCAFCEF34CACC22981974AEDCF94C9.gif)
Native侧跨HAR/HSP模块调用ArkTS方法
如下图所示，Native侧跨HAR/HSP模块调用ArkTS方法是Native侧跨HAR/HSP模块调用Native方法的基础上调用ArkTS方法。其关键是在Module2中获取Module1中的上下文napi_env，并根据上下文napi_env加载模块、调用对应的ArkTS方法。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151123.40336301502872398074262185959082:50001231000000:2800:15CF8954D3C6CFF695E9F4AF64FAA2887938EE142F678B553D4719D520E601EF.png)
开发流程
Native侧跨HAR/HSP模块调用ArkTS方法具体实现方法如下所示。
1.  napi_har.h代码如下所示。 napi_har.cpp代码如下所示。
```typescript
// staticModule\src\main\ets\utils\Util.ets
export function add(a: number, b: number): number {
return a + b;
}
```
1.  napi_har.cpp代码如下所示。
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151123.40586302656612251853098345754011:50001231000000:2800:81E3DBB12341597B29AAC225F504BB270DF7520E9BCC91C5015F96620A07F264.gif)
常见问题
跨HSP模块调用和跨HAR模块调用的区别
HSP模块和HAR模块被调用时，主要的区别在Module2 Native调用Module2 ArkTS中，在调用napi_load_module_with_info加载模块时的入参有一些区别，其他的流程都是一样的。
如图所示，编译构建后，HAR模块被打包到各个模块之中，所以其入口模块仍然是HAP模块，napi_load_module_with_info中第2个参数的模块名称要填HAP模块中oh-package.json5中定义的依赖HAR的名称，而不是HAR模块的实际名称。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151123.48766059228543414639928783208255:50001231000000:2800:2B894BB70B713E175C9238ABC393C595DABFC2978430CE273B24CB64CC619C3E.png)
当被调用模块Module2是HSP，HSP是独立的模块，其入口模块就是HSP本模块，所以napi_load_module_with_info第2个参数的模块名就是他自己的模块名。
是否支持直接依赖HAR模块和HSP模块的三方so（即依赖传递问题）？
当前HAR模块和HSP模块都不支持依赖传递。
多包依赖同一so时，最终打包后的so有多少份？
如果多个HAR模块同时依赖commonHar的so，同一模块的同名so在打包后可以通过覆盖策略只保留一份。
如果多个HSP模块同时依赖commonHar的so，在编译构建的时，会将依赖的so编译打包到最终的编译产物里，所以每一个.hsp文件都会有一个so。
报错找不到HAR/HSP模块的ArkTS文件
问题现象
调用HAR/HSP模块的ArkTS文件时，可能会遇到以下报错：
可能原因
可能原因是工程级的build-profile.json5中的useNormalizedOHMUrl设置参数为false。
解决措施
在调用模块Module1的build-profile.json5里面添加如下配置。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-dynamic-link-library
爬取时间: 2025-05-01 09:40:56
来源: Huawei Developer
概述
在实际项目中，业务功能可能由不同“团队/组织”提供，如：团队A开发功能编译生成so库，团队B引用so库进行后续开发。so库可以将项目的不同功能模块化，提升代码的复用性和工程的可维护性。团队开发过程中引用三方so库的场景可分为两种：
下面针对这两种场景给出具体的实现方案。
Native侧引用三方so库
按照实际开发场景可分为两部分：编译生成so库和在Native侧引用so库。
第一部分：开发功能函数，编译生成so库。具体操作可参考：使用命令行CMake构建NDK工程。
第二部分：在Native侧引用so库调用功能函数。可以采用如下两种方案：
通过编译动态链接库的方式引用
实现原理
将so库加入到工程中，在Native侧使用CMake编译动态链接库，通过include引用头文件调用功能函数。
开发步骤
以引用一个加法计算so库为例，具体实现步骤如下：
1.
2.  在ArkTS侧调用Native侧提供的接口进行加法计算。
```typescript
// src/main/cpp/types/libentry/index.d.ts
// 导出Native侧提供的加法计算接口
export const nativeAdd: (a: number, b: number) => number;
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151124.85128227555705552059329796535751:50001231000000:2800:B972F9011FBE42B6A6EE3E91BD1B26A5D22FF28D54103A8D5F9201CBC02025EF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151124.71195408969712409104789159548170:50001231000000:2800:D7F69EEB99F34C2F732CB97E8F6373BC8BA9198FD2F72A763000693ADA466E3A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151124.39429407725989836044302738003756:50001231000000:2800:3D2AF470C62A8A095121FF6A1D025A7412A6F6D1CA422619D93A824ADACC6B4A.png)
通过调用dlopen的方式引用
实现原理
将so库加入到工程中，在ArkTS侧将so库的沙箱路径传递至Native侧，在Native侧使用dlopen解析so库调用功能函数。但是需要注意，该方案只能引用C语言编译模式生成的so库，因此用于生成so库的.h头文件需要用extern "C" {}包裹。
开发步骤
以引用一个减法计算so库为例，具体实现步骤如下：
1.
2.  此处需要使用so库的沙箱路径，而不是其真实路径。
3.  在ArkTS侧调用Native侧提供的接口进行减法计算。
```typescript
// src/main/cpp/types/libentry/index.d.ts
// 导出Native侧提供的减法计算接口
export const nativeSub: (a: number, b: number, path: string) => number;
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151124.15660316116175496174001512531688:50001231000000:2800:0A4CDF1B67EEE7697D83AFFB6EBE40EF6954BE16B6821E9C51C14C46950EB991.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151124.65890922637393628497924295138752:50001231000000:2800:D664147AC6EAA67EFE670507B9E974B07F3D9EC3845B2374477B681D342F32B4.png)
ArkTS侧引用三方so库
按照实际开发场景可分为两部分：生成适配Native的so库和在ArkTS侧引用so库。
第一部分：开发功能函数，编译生成so库并适配Native。具体操作可参考：使用命令行CMake构建NDK工程。
第二部分：在ArkTS侧通过配置模块动态依赖的方式引用so库。
通过配置模块动态依赖引用
实现原理
将so库和对应的Native侧接口文件加入到工程中，在工程中配置so库对应的模块动态依赖，在ArkTS侧通过import引入依赖接口调用so库。但是需要注意该方案只能引用适配Native的so库，因此在编译生成so库时需要实现功能函数并向Napi注册其Native侧接口，提供对应的Native侧接口文件index.d.ts和配置文件oh-package.json5。
开发步骤
以引用一个乘法计算so库为例，具体实现步骤如下：
1.
2.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151124.03017701590661360661519051763876:50001231000000:2800:8676988DCD9381911A84D7700075B6A89F61114A43A6A98191C8366944EE251C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151124.86251488394304703864738048712225:50001231000000:2800:C4D6206AB29E1593A615261DC99B44E5DFEA8DC5E66620E0305C935180301501.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151124.50794944118476808033918164286326:50001231000000:2800:E4ADFE357E083119DB700652B37107F2AEC64B3D3D26F113A820A62CC6E081E1.png)
常见问题
如何在同一个工程中实现三方so库的编译和引用？
可以在工程中创建两个Module，通过其中一个Module编译生成加法、减法和乘法运算so库，通过另外一个Module引用三方so库，进行结果验证。
参考链接
在集成三方so库时，.so库文件和.h头文件一定要置于上述方法的路径下吗？
不一定。原则上.so库文件和.h头文件可以置于需要引用so库的工程目录的任意位置，但是需要在工程的CMakeLists.txt文件中修改文件配置。如：将add.h头文件和libnativeAdd.so库文件放置在entry的根目录下，需要在CMakeLists.txt文件中通过include_directories命令添加entry的根目录作为头文件路径，并修改target_link_libraries命令中需要预加载的加法so库的路径，才能保证so库链接成功。
代码示例
在纯ArkTS工程中如何引用三方so库？
纯ArkTS工程可以通过配置模块动态依赖的方式引用so库。但是需要注意，在引用过程中除了将已经适配Native的xxx.so库文件置于entry/libs对应的架构目录下外，还需要将编译三方so库时配套产生的libc++_xxx.so库文件置于该目录下。
示例如下
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151124.68142914779123760986004707446695:50001231000000:2800:327073B12E56D0333C44243B202BA1ABAC921D025D94E81FB98A34196CC70F28.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151124.35558644762179511354168317281224:50001231000000:2800:C2BDD92B40BFD5972E0C9D1B0757CC25C0E8B9AA9D7DD0FC5F5EFC7D74889012.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-thread-priority-setting
爬取时间: 2025-05-01 09:41:10
来源: Huawei Developer
概述
在现代软件开发中，多线程或多进程的并发处理已成为常态。在多线程环境中，不同线程执行的任务可能具有不同的重要性和紧急程度。在高负载情况下，系统资源（如CPU时间）变得尤为宝贵，此时若关键线程（例如UI渲染线程）因频繁被非关键线程抢占而无法获得足够的连续执行时间和资源保障，可能会导致画面卡顿、延迟等问题，从而严重影响用户体验。
解决思路
在负载较重的时候，为了让关键的任务能够拿到足够的资源，整机会依据任务的重要性，给任务分配相应的时间片，重要性越高的任务，可以分配到越多的时间片。那么开发者在可以识别自己应用中的关键线程的情况下，针对各个线程的任务紧急程度，给予关键线程相对较高的QoS等级以防止被其他线程打断，从而保证应用的流畅运行和更好的用户体验。
QoS
服务质量（QoS）一文介绍了QoS的基本概念、原理、各个QoS等级适用的场景及负载特征及相关接口的用法。
在操作系统层面，QoS等级是一种用于区分不同线程优先级和服务质量的技术。通常系统会自动识别主线程，并在前台焦点情况下为其配置高于开放给应用开发者调用的QoS等级，以确保其优先执行。
与ArkTS端taskpool.Priority的线程优先级类似，QoS提供的优先级等级也都会相对应的映射到内核的优先级上。不过QoS提供的等级更多，自适应调度策略更强，他们属于两套不同的逻辑。
FFRT（Function Flow运行时）的QoS提供了ffrt_qos_inherit（-1）到ffrt_qos_user_initiated（3）5个优先等级，它与当前的QoS接口有着同一套底层逻辑。差别在于当前开发所用的QoS接口是直接开放给应用线程的，而FFRT的QoS则是面向任务的优先级配置，关于线程编程模型和任务编程模型的对比详见FFRT 概述。
场景示例
下面是一个在高负载情况下，配置了不同QoS等级的两个关键线程完成相同计算任务所花时间的对比图，从界面的运行结果可以看到在高负载情况下，配置了高优先级的线程执行完计算所花的时间更少一些。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151124.88169059980950520367889204533327:50001231000000:2800:8DA15F4EADAEF7BDB57E0E2540991A92136D5C77FB835818A213C79F879FAD68.gif)
具体实现步骤如下：
1、实现负载线程所要完成的任务。
2、实现高、低QoS等级计算线程（关键线程）所要完成的计算任务（斐波那契数列计算）。先通过OH_QoS_SetThreadQoS接口设置当前线程的QoS等级，再执行 DoFib() 斐波那契数列计算。
3、然后分别将计算线程（关键线程）设置低、高QoS等级来对比两者在相同的高负载情况下完成相同层级的斐波那契数列计算所花时间。
计算线程（线程id：39260）设置低QoS等级trace图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151124.96188196971660421051315767082976:50001231000000:2800:496B441BAE2A6EFF62CA874283131FB8066690B797CCF35F99C4949701D974A5.png)
如上图所示，计算线程执行完计算任务耗时726.8毫秒。
计算线程（线程id：39204）设置高QoS等级trace图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151124.25223307214919858302449403337449:50001231000000:2800:D01C478E0172FFFC994BF43B7A029170DECA4D4EE8F3008A2CE774AE5215EC15.png)
如上图所示，计算线程执行完计算任务耗时323.9毫秒。
该示例只在高负载压力下有效。
在低负载情况下，由于系统资源相对充足，即使不进行特别的优先级设置，大多数线程也能够得到足够的cpu时间来完成任务，因而效果并不明显。
总结
| 方案  | 斐波那契数列项数  | 计算耗时  |
| --- | --- | --- |
| 低Qos等级 QOS_BACKGROUND  | 34  | 726.8毫秒  |
| 高Qos等级 QOS_USER_INTERACTIVE  | 34  | 323.9毫秒  |
方案
斐波那契数列项数
计算耗时
低Qos等级 QOS_BACKGROUND
34
726.8毫秒
高Qos等级 QOS_USER_INTERACTIVE
34
323.9毫秒
通过上述对比可以发现，高负载压力下，高QoS优先级的线程可以更快的执行完计算任务。因此在实践中我们通过合理设置线程优先级，给关键线程以相对较高的QoS等级可以有效地避免关键线程被打断，从而保证应用程序的稳定性和响应性。
由于整机资源有限，若应用内部方法均设置高QoS等级，将导致资源相互抢占。此外，高QoS等级线程会相比低等级线程获取更多资源，过度提升线程QoS等级可能引起其他线程饥饿，从而影响整个系统的稳定运行。因此，线程QoS等级的设置需要结合具体应用场景和需求。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-native-sub-main-comm
爬取时间: 2025-05-01 09:41:23
来源: Huawei Developer
概述
开发者在Native侧进行开发实践时，经常会遇到一些耗时的任务，例如I/O操作、域名解析以及复杂计算等。这些任务如果直接在主线程中执行，将会严重阻塞主线程，影响后续任务的正常流程，进而导致用户界面响应延迟甚至卡顿。
为了提升代码性能，通常会将这类耗时任务放在Native子线程中执行。通常情况下，Native子线程可以独立完成自己的任务，但是很多时候需要将数据从主线程传递到Native子线程，或者将Native子线程的执行结果返回给主线程。
在多线程环境中，有一个关键问题是如何安全地在后台线程（Native侧子线程）和UI主线程之间进行通信。ArkTS函数通常只能在主线程里调用，如果Native侧通过std::thread或pthread创建了子线程，那么主线程中的上下文环境和数据（napi_env、napi_value以及napi_ref）是不能直接在子线程上下文中使用的。
为确保正确性，当Native侧在子线程完成其计算或处理后，若需要回调ArkTS函数，必须先通过线程同步机制将结果传递回主线程，然后才能安全地在主线程环境中调用ArkTS函数。针对这个问题，可以采用以下方案来解决。
推荐开发者使用线程安全函数作为Native侧子线程与UI主线程的通信手段。
如果线程安全函数确实不能满足开发需要，开发者可以使用libuv库自定义Loop然后通过uv_async_send方法进行线程间通信。
另外，libuv库中的uv_queue_work接口也可以实现线程间通信，但存在以下弊端：
更多libuv库的方案策略可以查看API参考：libuv。
实现原理
基于线程安全函数机制
HarmonyOS Node-API提供了一系列线程安全函数相关的接口，通过这些接口可以在Native侧创建一个可以在多线程间共享并安全使用的函数对象。在创建过程中，需要指定一些关键信息，如ArkTS回调函数、异步资源标识符、缓冲队列容量、初始线程数等。这些信息将用于确保函数在多线程环境下的正确性和安全性。通过这个机制，子线程可以将数据传递给主线程，主线程接收到数据后会调用ArkTS回调函数进行处理。
调用流程图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151125.10073076051784620652542060431578:50001231000000:2800:40D27C6901EDEC762B9BAE05076F356E9F7B918E72C9EEDD1D650A6847099AC9.png)
首先ArkTS侧会传递一个回调函数到Native侧，然后在Native侧创建一个线程安全函数，此线程安全函数会绑定一个回调函数（通过napi_call_threadsafe_function调用线程安全函数时，会触发该函数），接着需要保存后续需要用到的上下文信息及参数，然后拆分子线程（子线程绑定了要用到的上下文信息及参数）。
Native侧子线程分配到系统资源之后会执行对应的业务逻辑，通过Node-API提供的线程安全函数相关的接口调用前面声明的线程安全函数，该线程安全函数会被push到主线程的事件循环中等待事件调度执行。
线程安全函数在事件循环中得到调度后会通过napi_call_back接口调用ArkTS回调函数。
开发步骤
基于libuv异步库的uv_async_send方法
libuv库提供了一个函数uv_async_send，用于在非阻塞事件循环中异步发送信号。uv_async_send函数允许用户在不同的线程或者事件循环的不同部分之间发送信号，从而触发某些操作而不需要直接调用阻塞函数。uv_async_send的核心原理是利用事件循环（event-loop）和内部消息队列来实现线程间的通信。具体来说，它允许一个线程（通常是工作线程）发送信号给主线程上的事件循环，从而触发主线程上的某个回调函数。因此利用该原理可以在主线程中定义用于回调ArkTS侧函数的回调函数，待子线程中业务逻辑执行完成后通过uv_async_send接口实现在子线程中通知主线程执行回调，进而实现对ArkTS侧函数的调用。
调用流程图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151125.36022581082237662974240746076944:50001231000000:2800:2BF29786DD3B2A682E2A3D1226400496644226E89F8AC1A34B7EE5A7481ADCDF.png)
首先ArkTS侧会传递一个回调函数到Native侧，Native侧接收到后会保存后续需要用到的上下文信息及参数，接着自定义一个Loop，该Loop会在主线程中执行，然后初始化async句柄并绑定后续需要在主线程调用的回调函数，运行自定义Loop。接着拆分子线程（子线程绑定了要用到的上下文信息及参数）。
Native侧子线程分配到系统资源之后在子线程中调用uv_async_send方法通知主线程调用与async绑定的函数。
运行在主线程的自定义Loop接收到信号后，会调用之前async句柄绑定的回调函数，然后就可以在该函数中调用ArkTS回调函数。
开发步骤
场景案例
本节将以分别使用线程安全函数和libuv异步库实现以下操作，在Native侧拆分子线程执行业务逻辑，子线程业务逻辑完成之后回到主线程执行ArkTS侧传入的ArkTS回调函数，从而完成了对ArkTS端变量值的加30操作。
从ArkTS侧传递给Native侧的函数引用，其生命周期仅限于它所在的作用域内。若要确保在超出该作用域后仍能继续使用这个函数引用，需要采取适当的方法来延长其生命周期。可以通过调用napi_create_reference接口为ArkTS对象创建一个引用(reference)。这样可以避免对象因垃圾回收机制而被提前释放，从而有效地延长它的生命周期。然而，在创建引用之后，务必牢记要在不再需要该引用时，调用napi_delete_reference来释放引用，以防止内存泄漏问题的发生。
基于线程安全函数机制实现
```typescript
// 声明ArkTS侧函数
@State value: number = 0;
work: Function = (param: number) => {
param += 30;
this.value = param;
return param;
}
```
1.  threadSafeCase接口接收到ArkTS传入的回调函数后通过napi_create_threadsafe_function创建一个线程安全函数tsFn，tsFn会回调主线程中的ThreadSafeCallJs方法，然后在ThreadSafeCallJs方法中调用ArkTS侧传入的回调函数。 在拆分子线程时，需要保存上下文信息及ArkTS函数引用，保存完之后拆分子线程。
2.  在子线程中通过napi_call_threadsafe_function调用线程安全函数tsFn，把CallbackContext结构体数据作为参数传入线程安全函数。开发者可以根据自身实际需求在子线程中添加相应的业务操作。
3.  通过上面保存的上下文信息及ArkTS函数引用回调ArkTS回调函数实现加30操作。
结果展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151125.39540141950813154410051549840469:50001231000000:2800:396D834B9A29005BFFA220AF54405E02D62567A97C8FC2669B1C0FA984224D83.png)
基于libuv异步库的uv_async_send方法实现
使用libuv异步库需要在CMakeLists.txt文件中添加libuv.so依赖，并在使用libuv接口的代码文件中引用其头文件uv.h，例如这里我们在napi_init文件中引用。
1.  在ArkTS侧实现一个回调函数，参数为param，函数体中对参数param加30后刷新变量value，并返回最新的param值。将回调函数作为参数调用Native侧的libUvCase接口。
```typescript
// 声明ArkTS侧函数
@State value: number = 0;
work: Function = (param: number) => {
param += 30;
this.value = param;
return param;
}
```
2.  首先定义两个全局变量，用于存储Loop和async句柄。
结果展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151125.24995464177461462686878775702972:50001231000000:2800:3416CB2251E45B74FF60F0ABC002626B99A68B3AA55BFC77D0F8787CCEAABF3E.png)
常见问题
如何在Native侧调用ArkTS侧异步方法，并获取异步计算结果到Native侧
可以参考如下链接：在Native侧调用ArkTS侧异步方法。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-web-development-practices
爬取时间: 2025-05-01 09:41:36
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-network-reconnection
爬取时间: 2025-05-01 09:41:51
来源: Huawei Developer
概述
网络重连是指在网络连接出现中断或异常断开的情况下，设备或应用程序重新建立网络连接的过程。对于许多依赖网络的业务和应用来说，网络重连能够确保在网络出现短暂中断后，业务能够快速恢复，减少因网络故障导致的业务中断时间，提高业务的连续性和可靠性。例如，在线金融交易、远程医疗、音视频播放等对实时性和连续性要求较高的业务，网络重连功能至关重要。根据应用的实际场景，网络重连可以分为以下多种方式。
网络超时重连
场景描述
在网络请求中，经常会遇到网络波动、服务器宕机等情况，从而导致网络不可用、网络超时等问题。为了减少网络超时等带来的影响，在实际应用开发中经常使用超时机制和重试机制。如HTTP请求列表数据时，设置HTTP连接超时和请求重试。
实现原理
网络超时分为网络连接超时和网络读取超时。
网络重试常用的策略有定时重试、指数退避重试、随机退避重试等。
在设置重试策略时，需要根据实际的场景来进行设置，既要考虑网络超时的时间，还需要关注重试的次数和时间间隔，避免网络资源浪费。
开发步骤
在HarmonyOS中，在Http、RCP发生错误或者超时后，都可以使用网络超时重连的机制。HTTP超时重连的实现步骤如下所示。
HTTP超时重连的代码如下所示：
```typescript
// entry/src/main/ets/pages/HTTPReconnection
async getHttpRequest(url: string, retry: number): Promise<number | undefined> {
try {
return await this.httpRequest?.requestInStream(url,
{ method: http.RequestMethod.GET, connectTimeout: 6000, readTimeout: 60000 })
.then((data: number) => {
if (data === 408 || data === 500 && retry > 0) {
return new Promise((resolve: Function) => {
setTimeout(() => {
resolve(this.getHttpRequest(url, retry - 1));
}, 2000);
});
} else {
return data;
}
});
} catch (err) {
this.isDownload = false;
promptAction.showToast({ message: $r('app.string.download_error') });
return;
}
}
```
RCP超时重连的实现与HTTP的实现步骤类似，RCP超时重连的代码如下所示：
网络切换重连
场景描述
在当下这个数字化时代，大部分的应用确实离不开网络，网络已经深度渗透到各类应用场景之中。然而，在网络状态切换后，如何继续保持网络连接是许多应用需要处理的问题。
实现原理
网络切换主要分为网络类型切换和无网络与有网络之间的切换。针对网络切换的场景，HarmonyOS提供了网络连接管理能力，用于查询网络信息、监听网络连接的变化等。
在实现网络切换重连上，主要包含以下步骤。
开发步骤
调用connection的register方法订阅网络变化通知，同时，订阅netCapabilitiesChange网络能力变化事件，订阅netLost网络丢失事件。在设备从有网络到无网络状态会触发netLost事件，从无网络到有网络会触发netCapabilitiesChange事件。而在网络类型切换时，也会触发netLost事件和netCapabilitiesChange事件，开发者可以根据实际场景需要在netCapabilitiesChange事件中，将网络类型及网络状态存储在AppStorage中。
```typescript
// entry/src/main/ets/utils/ConnectionUtil
private netCon: connection.NetConnection = connection.createNetConnection();
register() {
this.netCon.register((error: BusinessError) => {
Logger.error('net register:' + JSON.stringify(error));
});
}
netCapabilitiesChange() {
this.netCon.on('netCapabilitiesChange', (data: connection.NetCapabilityInfo) => {
let netAvailable = false;
data.netCap.networkCap?.forEach((value) => {
if (value === connection.NetCap.NET_CAPABILITY_INTERNET) {
netAvailable = true;
}
})
Logger.info('ConnectionUtil.netAvailable:' + netAvailable);
AppStorage.setOrCreate('netAvailable', netAvailable);
})
this.netCon.on('netLost', (data: connection.NetHandle) => {
AppStorage.setOrCreate('netAvailable', false);
Logger.info("WifiChangeListen-- Succeeded to get data: " + JSON.stringify(data));
});
}
```
使用AppStorage存储应用全局网络状态。
使用@Watch监听状态变量的变化，并根据对应的变化和实际应用场景重新连接网络。
无网络切换有网络后重连下载效果图如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151406.15892283601694847915914719335693:50001231000000:2800:50A713AD35EED99B7F6BBA5DF22214E558858A84C1E299006D4EA3F7379EFFAB.gif)
应用前后台切换后重连
场景描述
应用在使用TCPSocket、UDPSocket等通信时，如果未申请长时任务或短时任务，当应用退到后台一段时间后，可能遇到网络不可用或网络资源异常的情况，并且将应用切回前台后，继续使用之前的TCPSocket、UDPSocket等连接对象继续和服务器通信也可能出现网络异常。
实现原理
在HarmonyOS中，应用切换到后台2秒后，应用的网络资源会被冻结，并且在12秒后进行释放。此时，再继续使用网络资源，就会出现网络不可用的情况。如果应用有后台使用网络资源的场景，可以使用短时任务或长时任务。
由于Socket通信是基于IP和端口进行通信的，在应用退到后台后，网络资源被冻结时会清空TCP、UDP连接对象的IP和端口，但是不会释放连接对象。在应用切换到前台后，系统会给连接对象重新分配新的IP和端口，继续使用之前的连接对象与服务器进行通信时，服务器会认为同一个连接对象前后IP和端口不一致，从而导致通信不可信、网络异常。
应用前后台切换后网络重连在实现上有以下两个关键部分。
开发步骤
前后台切换时，在UIAbility组件生命周期中存储前后台状态。
使用@StorageProp同步前后台状态，并使用@Watch监听状态变化。
前后台切换网络重连实现效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151406.97821147011105751112213716834353:50001231000000:2800:F06A23C28EF99D7CAEF40B14D847798870981404D17FF418B9C817F61E7A2D68.gif)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-rcp-based-network-request
爬取时间: 2025-05-01 09:42:04
来源: Huawei Developer
概述
Remote Communication Kit中的@hms.collaboration.rcp(后续简称RCP）指的是远程通信平台（remote communication platform），RCP提供了网络数据请求功能，相较于Network Kit中HTTP请求能力，RCP更具易用性，且拥有更多的功能。在开发过程中，如果有些场景使用Network Kit中HTTP请求能力达不到预期或无法实现，那么就可以尝试使用RCP中的数据请求功能来实现。
接下来，本文将先介绍RCP与HTTP的区别，然后从使用RCP实现基础的网络请求、多表单提交、双向证书校验、DNS的相关设置、请求与响应拦截和捕获有关HTTP请求/响应流的详细信息等几个场景来介绍RCP拥有的能力。
RCP与HTTP的区别
为了方便了解RCP与HTTP的区别，可以从功能分类、功能名称和功能描述这三个方面进行对比，主要区别如下：
| 功能分类  | 功能名称  | 功能描述  | HTTP  | RCP  |
| --- | --- | --- | --- | --- |
| 基础功能  | 发送PATCH类型请求  | 以PATCH的方式请求  | 不支持  | 支持  |
| 基础功能  | 设置会话中URL的基地址  | 会话中URL的基地址将自动加在URL前面，除非URL是一个绝对的URL  | 不支持  | 支持  |
| 基础功能  | 取消自动重定向  | HTTP请求不会自动重定向  | 不支持  | 支持  |
| 基础功能  | 拦截请求和响应  | 在请求后或响应前进行拦截  | 不支持  | 支持  |
| 基础功能  | 取消请求  | 发送请求前取消、发送请求过程中取消、请求接收后取消  | 不支持  | 支持  |
| 基础功能  | 响应缓存  | 是否使用缓存，请求时优先读取缓存。缓存跟随当前进程生效，新缓存会替换旧缓存  | 不支持  | 支持  |
| 基础功能  | 设置响应数据的类型  | 设置数据以何种方式返回，将要响应的数据类型可设置为string、object、arraybuffer等类型  | 支持  | 不支持  |
| 基础功能  | 定义允许的HTTP响应内容的最大字节数  | 服务器成功响应时，在获取数据前校验响应内容的最大字节数  | 支持  | 不支持  |
| 证书验证  | 自定义证书校验  | 自定义逻辑校验客户端和服务端的证书，判断是否可以连接  | 不支持  | 支持  |
| 证书验证  | 忽略SSL校验  | 在建立SSL连接时不验证服务器端的SSL证书  | 不支持  | 支持  |
| DNS  | 自定义DNS解析  | 包括自定义DNS服务器或静态DNS规则  | 不支持  | 支持  |
| RCP特有  | 捕获详细的跟踪信息  | 在会话中的HTTP请求期间捕获详细的跟踪信息。跟踪有助于调试、性能分析和深入了解通信过程中的数据流  | 不支持  | 支持  |
| RCP特有  | 数据打点，获取HTTP请求的具体数据  | HTTP请求各阶段的定时信息  | 不支持  | 支持  |
功能分类
功能名称
功能描述
HTTP
RCP
基础功能
发送PATCH类型请求
以PATCH的方式请求
不支持
支持
基础功能
设置会话中URL的基地址
会话中URL的基地址将自动加在URL前面，除非URL是一个绝对的URL
不支持
支持
基础功能
取消自动重定向
HTTP请求不会自动重定向
不支持
支持
基础功能
拦截请求和响应
在请求后或响应前进行拦截
不支持
支持
基础功能
取消请求
发送请求前取消、发送请求过程中取消、请求接收后取消
不支持
支持
基础功能
响应缓存
是否使用缓存，请求时优先读取缓存。缓存跟随当前进程生效，新缓存会替换旧缓存
不支持
支持
基础功能
设置响应数据的类型
设置数据以何种方式返回，将要响应的数据类型可设置为string、object、arraybuffer等类型
支持
不支持
基础功能
定义允许的HTTP响应内容的最大字节数
服务器成功响应时，在获取数据前校验响应内容的最大字节数
支持
不支持
证书验证
自定义证书校验
自定义逻辑校验客户端和服务端的证书，判断是否可以连接
不支持
支持
证书验证
忽略SSL校验
在建立SSL连接时不验证服务器端的SSL证书
不支持
支持
DNS
自定义DNS解析
包括自定义DNS服务器或静态DNS规则
不支持
支持
RCP特有
捕获详细的跟踪信息
在会话中的HTTP请求期间捕获详细的跟踪信息。跟踪有助于调试、性能分析和深入了解通信过程中的数据流
不支持
支持
RCP特有
数据打点，获取HTTP请求的具体数据
HTTP请求各阶段的定时信息
不支持
支持
实现基础的网络请求
发送请求
通过RCP模块能够发起基础的网络请求，如GET、POST、HEAD、PUT、DELETE、PATCH、OPTIONS等请求。以PATCH请求为例，开发过程中经常会遇到发送请求修改资源的场景，假设有一个UserInfo，里面有userId、userName、 userGender等10个字段。可编辑功能因为需求，在某个特别的页面里只能修改userName，这时就可以用PATCH请求，来更新局部资源。
实现思路
在创建session会话后，通过创建请求对象并传入第二个参数且指定为PATCH，然后通过session.fetch()发起请求即可。
核心代码
设置会话中URL的基地址
会话中URL的基地址是在发起请求时用作请求地址的前缀。 当我们向服务器发起请求时，该请求的最终的请求地址由会话中URL的基地址与请求路径来构建的。 这使得我们可以将服务器的主机地址与公共路径隔离开来，方便管理和维护。
实现思路
会话中URL的基地址可通过RCP模块中的SessionConfiguration来进行设置，在sessionConfig对象中设置“baseAddress：'http://api.example.com' ”即可。
核心代码
实现多表单提交
开发过程中时常会遇到多表单提交的场景，例如在同页面下tab栏可切换多个Form表单组件，但只有一个提交按钮，各组件下的表单数据需要被一起提交。此时可以使用RCP模块中的MultipartForm来实现多表单提交的场景。
实现思路
在创建session会话后，通过new rcp.Request()的第四个参数传入MultipartForm，然后通过rcp.fetch()发起POST请求将多个表单数据携带上传至服务端。
核心代码
实现双向证书校验
为验证服务端和客户端之间的身份和数据完整性，确保通信的安全性，可使用RCP接口能力实现双向证书校验能力。
详情请参见：双向证书校验
实现对DNS的定制设置
通过RCP模块，能够实现对DNS的定制设置。开发人员可以按自己的需要配置DNS，包括自定义DNS服务器、自定义静态DNS规则和配置HTTPS上的DNS，都可以通过DnsConfiguration设置。DnsConfiguration中可设置dnsRules、dnsOverHttps。
-  自定义DNS服务器（DnsServers）：可指定自定义的DNS服务器提供解析服务。 自定义静态DNS（StaticDnsRules）：有些时候，默认的DNS不能正常解析部分域名，就需要手动添加静态DNS。添加静态DNS后，如果hostname匹配，则优先使用指定的地址。 自定义动态DNS（DynamicDnsRules）：除了添加静态DNS外，还可以添加动态DNS。动态DNS可看作一个可以根据hostname和port直接返回IP地址的函数，如果设置，则优先使用函数中返回的地址。
-  DNS over HTTPS配置（DnsOverHttpsConfiguration）：配置HTTPS上的DNS（DOH）设置，以加密的HTTPS协议进行DNS解析请求，避免原始DNS协议中用户的DNS解析请求被窃听或者修改的问题，来达到保护用户隐私的目的。如果设置，则优先使用DNS服务器解析的地址。
自定义DNS服务器
实现思路
先配置自定义的DNS服务器customDnsServers，在创建session会话时，通过requestConfiguration传入dns对象，指定dns对象中的dnsRules为customDnsServers。
核心代码
自定义静态DNS
实现思路
先配置静态DNS规则staticDnsRules，在创建session会话时，通过requestConfiguration传入dns对象，指定dns对象中的dnsRules为staticDnsRules 。
配置HTTPS上的DNS
实现思路
先创建HTTPS上的DNS对象dohConfig，在创建session会话时，通过requestConfiguration传入dns对象，指定dns对象中的dnsOverHttps为dohConfig 。
实现请求与响应拦截
使用拦截器可以方便的对HTTP的请求与响应进行修改，您可以创建拦截器链，按需定制一组拦截器对您的网络请求/响应进行修改。RCP模块提供了拦截器能力，在SessionConfiguration中添加Interceptors参数，传入自定义的拦截器，即可在HTTP请求和响应的过程中添加拦截器功能。
拦截器工作原理
客户端发送HTTP请求，到达目标服务器之前，可以使用拦截器对HTTP的请求进行修改。如下图，定义了链式拦截器，ResponseCachingInterceptor拦截器（下文以拦截器1代替）和ResponseHeaderRemoveInterceptor拦截器（下文以拦截器2代替）。请求先被拦截器1拦截，该拦截器中可以对请求的响应结果进行缓存。然后经过拦截器2，最后到达Internet。当请求到达目标服务器，服务器返回请求响应的结果给客户端之前，可以使用拦截器对HTTP的响应进行修改。如下图，响应先被拦截器2拦截，在响应返回给应用前检查和修改服务器的请求头。然后经过拦截器1，最后客户端接收响应结果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151406.38424856658136151414839786270468:50001231000000:2800:B5AEB13D64A15E97FBF65D3BF38A394553AA79C7FB58133384F6A2BA90B55D36.png)
ResponseCachingInterceptor拦截器和ResponseHeaderRemoveInterceptor拦截器都是自定义拦截器，需要开发者通过代码去实现内部逻辑。
拦截器的定义和使用
下面将介绍如何自定义拦截器，定义ResponseCachingInterceptor拦截器和ResponseHeaderRemoveInterceptor拦截器实现rcp.Interceptor，可在intercept()方法中根据业务需求自定义处理逻辑，实现对请求/响应的修改。
核心代码
下面将介绍如何使用拦截器，可通过RCP模块中的SessionConfiguration来进行设置，在sessionConfig对象中设置interceptors，即可在请求/响应中添加拦截器。
核心代码
捕获有关HTTP请求/响应流的详细信息
当需要采集应用中HTTP请求的详细跟踪信息时，可以使用TracingConfiguration进行相关配置。TracingConfiguration中可以设置verbose（启用详细跟踪）、infoToCollect（配置要收集的特定类型的信息事件）、collectTimeInfo（在跟踪过程中是否应收集与时间相关的信息）、httpEventsHandler（为HTTP请求/响应过程中的特定操作定义响应处理程序的回调）四个参数。
下面将以获取HTTP请求/响应时的数据接收时、请求头接收时、数据传输完成时等详细信息为例，进行介绍。
实现思路
通过配置TracingConfiguration中的参数，来捕获HTTP请求/响应时的详细信息。
核心代码
本文主要介绍了基于RCP实现基础的网络请求、多表单提交、双向证书校验、DNS相关设置、请求与响应拦截、HTTP请求期间捕获详细的跟踪信息等。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-network-management
爬取时间: 2025-05-01 09:42:18
来源: Huawei Developer
概述
本章主要介绍了网络管理中网络连接管理、网络信息查询和网络状态监听等。
在需要使用网络时，通常有两种选择：蜂窝网络或WiFi网络。当成功连接蜂窝网络或WiFi网络后，若应用需要区分当前连接的具体网络类型，可通过网络连接管理功能进行查询。当使用场景发生变化时，需要对网络状态进行监听，如查询当前网络是否可用、判断网络质量的优劣等，并据此做出切换网络或提示用户等操作，从而提升用户体验。
本文章是为了帮助开发者了解网络管理中常用的查询方式：
帮助开发者了解如何进行网络状态变化的监听：
网络管理
查询网络连接信息
获取当前网络连接类型
当需要判断当前使用的网络是蜂窝或者WiFi时，可以通过以下步骤实现：
1.
核心代码
判断当前网络是否可用
使用网络前，例如打开一个应用时，需要检查当前连接的网络是否可用。如果可用，则正常进行网络请求；如果不可用，则需要提示用户网络不可用。判断当前连接的网络是否可用，可以通过以下步骤实现：
核心代码
```typescript
judgeHasNet(): boolean {
try {
let netHandle = connection.getDefaultNetSync();
if (!netHandle || netHandle.netId === 0) {
return false;
}
let netCapability = connection.getNetCapabilitiesSync(netHandle);
let cap = netCapability.networkCap || [];
if (cap.includes(connection.NetCap.NET_CAPABILITY_VALIDATED)) {
//connection.NetCap.NET_CAPABILITY_VALIDATED，该值代表网络是通的，能够发起HTTP和HTTPS的请求。
// 网络信息变化，网络可用
return true;
} else {
// 网络信息变化，网络不可用
return false;
}
} catch (e) {
let err = e as BusinessError;
console.error("JudgeHasNet" + JSON.stringify(err));
}
return false;
}
```
查询网络路由信息、网络链路信息
当需要进行网络故障诊断、网络性能优化、考虑网络安全需求时，需要查询网络路由信息、网络链路信息等，可以通过以下步骤实现：
核心代码
查询当前网络信息
蜂窝网络查询
下面将介绍蜂窝网络的相关查询，主要包括获取网络状态、查询当前网络是3G/4G/5G和判断主卡的Radio是否打开等。
获取网络状态
当需要查询手机卡注册网络的运营商名称、是否处于漫游状态、设备的网络注册状态等信息时，可以通过以下步骤实现：
1.
核心代码
查询当前网络是3G/4G/5G
视频播放应用在5G网络下可以默认加载超高清视频，以充分利用高速带宽；在4G网络下加载高清视频；而在3G网络下，为了避免卡顿，可能只加载标清视频。如何控制加载对应清晰度的视频，就需要查询当前网络是3G/4G/5G，可以通过以下步骤实现：
signalType的值对应网络类型如下：
| 值  | 网络类型  |
| --- | --- |
| GSM  | 2G  |
| CDMA  | 2G  |
| WCDMA  | 3G  |
| TDSCDMA  | 3G  |
| LTE  | 4G  |
| NR  | 5G  |
值
网络类型
GSM
2G
CDMA
2G
WCDMA
3G
TDSCDMA
3G
LTE
4G
NR
5G
核心代码
```typescript
getSignalType(){
let slotId: number = 0;
radio.getSignalInformation(slotId, (err: BusinessError, data: Array<radio.SignalInformation>) => {
if (err) {
console.error(`getSignalInformation failed, callback: err->${JSON.stringify(err)}`);
return;
}
console.log(`getSignalInformation success, callback: data->${JSON.stringify(data)}`);
let signalType = data[0].signalType;
console.log(`signalType is: ${signalType}`);
});
}
```
判断主卡的Radio是否打开
当用户在国外或者其他运营商的网络覆盖区域时，主卡Radio打开可能会导致手机自动连接到其他网络并产生漫游费用。因此，判断主卡Radio的状态可以让用户提前做好防范措施。判断主卡的Radio是否打开，可以通过以下步骤实现：
核心代码
```typescript
getRadioStatus(){
radio.isRadioOn((err: BusinessError, data: boolean) => {
if (err) {
console.error(`isRadioOn failed, callback: err->${JSON.stringify(err)}`);
return;
}
console.log(`isRadioOn success, callback: data->${JSON.stringify(data)}`);
});
}
```
WiFi查询
下面将介绍WiFi网络的相关查询，主要包括查询WLAN是否已使能、查询WLAN是否已连接、获取扫描到的热点列表、获取当前连接WiFi的信号强度和添加候选网络配置等。
查询WLAN是否已使能
查询WLAN是否已使能，可以帮助用户快速了解自己是否可以使用WiFi网络进行连接。并且当WiFi跟蜂窝同时存在时，有助于实现网络连接的无缝切换。查询WLAN是否已使能，可以通过以下步骤实现：
1.
核心代码
查询WLAN是否已连接
查询WLAN是否已连接是判断能否通过WiFi 进行各种网络活动的直接方式。只有在 WLAN 连接成功后，用户才能利用 WiFi网络的带宽优势进行诸如高清视频播放、大文件下载、在线游戏等对网络带宽和稳定性要求较高的操作。查询WLAN是否已连接，可以通过以下步骤实现：
核心代码
获取扫描到的热点列表
当用户想连接热点时，就需要通过获取扫描到的热点列表来查找对应热点。获取扫描到的热点列表，可以通过以下步骤实现：
核心代码
获取当前连接WiFi的信号强度
在下载大文件或观看高清视频时，如果WiFi信号强度不足，可能会导致下载速度缓慢、视频卡顿等问题。通过获取信号强度，用户可以初步判断当前网络是否能够满足其对速度的需求。获取当前连接WiFi的信号强度，可以通过以下步骤实现：
核心代码
添加候选网络配置
添加候选网络配置可以让设备在当前连接的网络出现问题（如信号丢失、网络故障等）或者用户离开当前网络覆盖范围时，自动尝试连接其他预先配置的候选网络。添加候选网络配置，可以通过以下步骤实现：
核心代码
```typescript
addCandidateConfig() {
try {
let config: wifiManager.WifiDeviceConfig = {
ssid: "****",
preSharedKey: "****",
securityType: 0
}
wifiManager.addCandidateConfig(config).then(result => {
console.info("result:" + JSON.stringify(result));
}).catch((err: number) => {
console.error("failed:" + JSON.stringify(err));
});
} catch (error) {
console.error("failed:" + JSON.stringify(error));
}
}
```
网络状态监听
监听网络可用与丢失
在日常使用网络中，当使用WiFi或者蜂窝时，如果信号良好，且手机、电脑、平板等可以顺利连接到网络，并进行在线视频播放、浏览网页、下载文件等操作，这些就是网络可用的典型场景。
而设备故障、信号干扰、网络拥堵、网络服务提供商的服务器故障、维护或升级都可能会导致网络丢失。为了提升用户上网体验，就需要对网络是否可用、网络是否丢失等进行监听，然后做出相应的处理。
网络连接管理中提供了对网络状态监听的方法，开发时定义了相关的监听方法后，在不同场景下会触发不同的事件，如：
网络丢失和网络不可用并非是一个概念，网络丢失和网络不可用的区别如下：
在播放视频时，可能会遇到无网络的情况，此时需要监听网络是否可用或者丢失，来实现对视频无网络时暂停、有网络时自动播放的能力，提升用户播放视频时的体验。通过注册监听网络相关变化，注册监听步骤如下：
核心代码
connection.createNetConnection()方法中有两个可选传入参，netSpecifier和timeout。其中netSpecifier指定关注的网络的各项特征；timeout是超时时间(单位是毫秒)；netSpecifier是timeout的必要条件，两者都没有则表示关注默认网络。
播放视频可使用Video组件实现，如果开发者想自定义视频播放，请参考视频播放。
当网络不可用时，调用暂停方法，暂停视频播放。
有网络后，调用播放方法，开始视频播放。
上述过程中可能会涉及到WiFi切换，当需要判断WiFi是否切换，需要监听WLAN状态改变事件和WLAN连接状态改变事件，步骤如下：
核心代码
```typescript
wifiChangeListen() {
this.netCon = connection.createNetConnection({
netCapabilities: {
bearerTypes: [connection.NetBearType.BEARER_WIFI]
}
});
// 先使用register接口注册订阅事件
this.netCon.register((error: BusinessError) => {
console.log(JSON.stringify(error));
});
// 订阅网络可用事件。调用register后，才能接收到此事件通知
this.netCon.on('netAvailable', (data: connection.NetHandle) => {
console.info("WifiChangeListen-- Succeeded to get data: " + JSON.stringify(data));
});
// 订阅网络丢失事件。调用register后，才能接收到此事件通知
this.netCon.on('netLost', (data: connection.NetHandle) => {
console.info("WifiChangeListen-- Succeeded to get data: " + JSON.stringify(data));
});
let recvPowerNotifyFunc = (result: number) => {
console.info("WifiChangeListen-- Receive power state change event: " + result);
}
let recvWifiConnectionChangeFunc = (result: number) => {
console.info("WifiChangeListen-- Receive wifi connection change event: " + result);
}
// 注册事件
wifiManager.on("wifiStateChange", recvPowerNotifyFunc);
wifiManager.on("wifiConnectionChange", recvWifiConnectionChangeFunc);
}
```
其中状态改变事件的枚举：
| 枚举值  | 说明  |
| --- | --- |
| 0  | 未激活。  |
| 1  | 已激活。  |
| 2  | 激活中。  |
| 3  | 去激活中。  |
枚举值
说明
0
未激活。
1
已激活。
2
激活中。
3
去激活中。
连接状态改变事件的枚举：
| 枚举值  | 说明  |
| --- | --- |
| 0  | 已断开。  |
| 1  | 已连接。  |
枚举值
说明
0
已断开。
1
已连接。
设备从无网络到有网络会触发netAvailable事件、netCapabilitiesChange事件和netConnectionPropertiesChange事件；
设备从有网络到无网络状态会触发netLost事件；
设备从WiFi切换到蜂窝会先触发netLost事件（WiFi丢失），之后触发 netAvailable事件（蜂窝可用）。
弱网下网络切换
在播放视频时，可能会遇到弱网的环境，如乘坐高铁时、人员密集的场所等。这个时候需要监听网络状态以及网络质量，来实现提示用户进行网络切换或者对视频的清晰度做出相应调整，如：
1）在WiFi弱信号的情况下，默认网络可能会切换到蜂窝网络。
2）在蜂窝网络弱信号的情况下，默认网络会优先切换到WiFi。
3）在网络质量低的环境下，自动降低并切换视频的清晰度。
判断是否是弱网环境的步骤如下：
1.
核心代码
判断是否为弱网可以通过下面3种方式：
-  根据网络质量评估信息，如NetworkQos(linkUpBandwidth/linkDownBandwidth/rttMs/linkUpBufferDelayMs/linkUpBufferCongestionPercent)，应用自定义门限来判决为弱网。
在弱网环境下，可以使用网络连接迁移能力，在通过系统发起多网迁移（WiFi<->蜂窝，主卡<->副卡等）的过程中，给应用提供连接迁移开始和完成通知，应用可根据连接迁移通知的建议进行重建，给用户带来平滑、高速、低时延的上网体验。
1.
核心代码
视频播放时，还可以通过判断当前网络质量来对视频的清晰度进行调整。若网络质量低，则切换视频到较低的清晰度。
1.
核心代码
```typescript
netQualityListen() {
try {
netQuality.on('netQosChange', (list: Array<netQuality.NetworkQos>) => {
if (list.length > 0) {
list.forEach((qos) => {
// 回调信息处理
console.info(`Succeeded receive netQosChange info`);
let lowNetQuality: boolean = false;
// 根据网络质量的相关信息，判断当前网络质量的高低。此处逻辑需要自定义实现，如果是低质量，则lowNetQuality为true。
// 如果网络质量低，则切换视频清晰度。
if(lowNetQuality){
this.toggleLowDefinition();
}
});
}
});
} catch (err) {
console.error('errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);
}
}
```
示例代码
网络管理与状态监听

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-bluetooth-low-energy
爬取时间: 2025-05-01 09:42:31
来源: Huawei Developer
概述
蓝牙（Bluetooth）是一种无线通信技术，被广泛应用于各种电子设备之间的短距离数据传输和连接。而低功耗蓝牙（Bluetooth Low Energy，简称 BLE）是一种能够在低功耗情况下进行通信的蓝牙技术。与传统蓝牙相比，BLE的功耗更低，适用于需要长时间运行的低功耗设备，如智能手表、健康监测设备、智能家居等。
本文适用于低功耗蓝牙通信相关的开发，主要介绍了基于BLE进行蓝牙扫描管理、蓝牙连接状态管理、蓝牙设备特征值同步三个场景，并分别从服务端和客户端描述其相关实现。
实现原理
实现低功耗蓝牙通信的能力主要步骤如下：
首先服务端需要创建实例，成功创建后，需要添加对应服务，才能开启BLE广播，向客户端传递相关信息。当服务端开启BLE广播后，还需要订阅BLE连接状态，即对连接状态进行监听。当连接状态变化时，如断开连接，则此时需要关闭BLE广播。在服务端接收到客户端发起的连接请求和发起的特征值订阅请求后，才能向客户端传递特征值信息。
而客户端同样需要创建实例，并获取相关服务，才能通过蓝牙扫描到服务端，并发起连接请求和特征值订阅请求。客户端也需要监听连接状态，当断开连接时，关闭对应的监听能力。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151406.43165965459959312883540425953525:50001231000000:2800:C4F818637517F22FFB45B64A714CA6CF0F814D0E52885E3C1851D8399664F516.png)
关键技术
实现低功耗蓝牙通信能力需要使用@ohos.bluetooth.ble (蓝牙ble模块)中提供的API能力，服务端使用的API主要包括创建服务器实例、发送BLE广播、特征值变化通知等；客户端使用的API主要包括蓝牙连接、订阅蓝牙低功耗设备的特征值变化、订阅蓝牙低功耗设备的连接状态变化事件等。
开发流程
在需要使用低功耗蓝牙进行通信的场景中：
服务端
客户端
蓝牙扫描管理
场景描述
BLE扫描主要分为被动扫描和主动扫描两种模式。被动扫描是指设备监听周围的广播信息，不主动发起连接请求；而主动扫描则会在接收到广播的同时，向广播设备发送扫描请求，以获取更详尽的设备信息。
蓝牙扫描管理是在主动扫描中，对扫描出的结果进行管理。主动扫描时，不仅可以设置扫描参数，还能处理扫描结果。如扫描时设置扫描时间间隔、扫描持续时间等；扫描出结果后，可对设备列表更新，并过滤相关设备信息。
实现原理
蓝牙扫描步骤如下：
首先服务端需要检查蓝牙状态，如未开启蓝牙，则需要向用户申请开启蓝牙；如已开启，则开启广播。然后客户端也需要检查蓝牙状态，如未开启蓝牙，则需要向用户申请开启蓝牙；如已开启，则设置扫描参数，并启动蓝牙扫描。根据扫描结果来处理相关设备信息并展示，然后主动发起蓝牙连接请求，连接远端设备。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151406.68881001856093490384073965128214:50001231000000:2800:33386E00DE7D9B8944C053117C76EFD347625DBD9DA20B518EB6857515604299.png)
关键技术
服务端：
客户端：
实现流程
服务端
1.
2.
3.
4.
客户端
1.
2.
3.
蓝牙连接状态管理
蓝牙连接状态管理可实时监测蓝牙连接的质量，包括信号强度、数据传输速率、误码率等指标。在蓝牙设备连接后，经常会遇到服务端、客户端连接状态改变的情况，例如客户端连接后，服务端关闭广播导致连接断开。针对此问题，在进行蓝牙设备开发的时候，需要对蓝牙的连接进行管理。
实现原理
在服务端与客户端进行连接的相关操作时，注册对应的监听事件。如监听蓝牙设备开关状态、监听蓝牙状态变化等。当对应状态发生变化时，即可通过回调函数来处理相应逻辑。
关键技术
服务端：
1.调用on('stateChange')方法订阅蓝牙设备开关状态事件。
2.调用on('connectionStateChange')方法订阅蓝牙状态变化事件。
客户端：
1.订阅蓝牙设备开关状态事件，与服务端步骤1一致。
2.调用on('BLEConnectionStateChange')订阅蓝牙低功耗设备的连接状态变化事件。
实现流程
服务端
1.
2.  （1）根据蓝牙的状态BluetoothState进行处理，如果当前蓝牙开启，AppStorage存储当前蓝牙状态为true，表示蓝牙可用，并开启广播。
3.  （1）根据连接状态设置连接设备ID。
客户端
1.
2.  （1）根据蓝牙的状态BluetoothState进行处理，如果当前蓝牙开启，则发起BLE扫描流程。
3.
蓝牙设备特征值同步
在低功耗蓝牙通信中，特征值是数据的基本单元，它是一种用于存储或传输特定类型数据的实体。许多蓝牙设备需要实时传输数据，如运动传感器将加速度、陀螺仪等数据传输到手机应用。如果特征值不同步，数据可能会出现延迟、丢失或者错误的顺序，导致接收端（如手机应用）无法准确地对运动状态进行分析，像在运动步数统计中，可能会少计或多计步数。
实现原理
在服务端与客户端连接成功后，服务端通过调用相关接口，主动通知客户端特征值发生变化；而客户端需要调用接口向服务端来订阅特征值变化，当特征值变化时，客户端即可接收到相关变化信息。
关键技术
服务端：
1.调用notifyCharacteristicChanged方法主动通知已连接的客户端设备，特征值变化。
客户端：
1.调用setCharacteristicChangeNotification接口向服务端发送设置通知此特征值请求。
2.调用on('BLECharacteristicChange')订阅蓝牙低功耗设备的特征值变化事件。
（1）根据UUID对服务进行过滤，获取服务特征值配置。
（2）调用setCharacteristicChangeNotification，向服务端发送设置通知此特征值请求。
（3）调用writeDescriptorValue，向低功耗蓝牙设备特定的描述符写入二进制数据。
实现流程
服务端
1.
2.
客户端
1.
2.
3.
常见问题
设备连接后调用getServices()获取不到数据
通过on('BLEConnectionStateChange')接口订阅连接状态，连接状态订阅中返回状态值为2的时候，表示连接成功，之后再调用getServices()获取数据。
扫描获取的deviceId与真实地址不同
基于信息安全考虑，此处获取的设备地址为随机MAC地址。配对成功后，该地址不会变更；已配对设备取消配对后重新扫描或蓝牙服务下电时，该随机地址会变更。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-rcp-file-transfer
爬取时间: 2025-05-01 09:42:49
来源: Huawei Developer
概述
Remote Communication Kit（远场通信服务）是HarmonyOS系统提供对HTTP发起数据请求的NAPI封装，通过@hms.collaboration.rcp（后续简称RCP）模块将相关能力开放给开发者。
在现代应用开发中，文件上传与下载是较为常见的需求，本文将通过对带进度的上传下载、断点续传、后台文件上传下载场景的详细讲解，为开发者提供基于RCP的文件上传与下载的开发实践。
关键技术说明
文件下载
文件上传
-  类型 可使用该类型的请求方法 对应原始http请求头和请求体类型 rcp.UploadFromFile Session.uploadFromFile()、Session.post()、Session.fetch() 请求头content-type为application/octet-stream；请求体使用binary二进制格式 rcp.UploadFromStream Session.uploadFromStream()、Session.post()、Session.fetch() 请求头content-type为application/octet-stream；请求体使用binary二进制格式 rcp.MultipartForm Session.post()、Session.fetch() 请求头content-type为multipart/form-data；请求体使用form-data格式
| 类型  | 可使用该类型的请求方法  | 对应原始http请求头和请求体类型  |
| --- | --- | --- |
| rcp.UploadFromFile  | Session.uploadFromFile()、Session.post()、Session.fetch()  | 请求头content-type为application/octet-stream；请求体使用binary二进制格式  |
| rcp.UploadFromStream  | Session.uploadFromStream()、Session.post()、Session.fetch()  | 请求头content-type为application/octet-stream；请求体使用binary二进制格式  |
| rcp.MultipartForm  | Session.post()、Session.fetch()  | 请求头content-type为multipart/form-data；请求体使用form-data格式  |
带进度的上传下载
场景描述
用户可选择服务器文件并点击下载，下载过程中能够显示下载进度。点击上传按钮，可拉起系统相册，选中相册文件并确认后，将其上传至服务器，并显示上传进度。
| 下载效果图  | 上传效果图  |
| --- | --- |
|   |   |
下载效果图
上传效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151406.43311285331725039302191240640461:50001231000000:2800:C2924C6C586DAC99270C78A08417A16EECF34B3141E749AFD7F42D56BC9DC42C.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151407.80621507469543851963693808063735:50001231000000:2800:3C88B1D3867A6606B71E689A31EA479C4C5A7152D30E2622A767E64E3D102AF1.gif)
实现原理
关键技术
下载流程
上传流程
开发步骤
在使用Remote Communication Kit相关能力前，需配置以下权限。详细参考申请权限步骤。
为避免在每个RCP发起请求的响应中重复判断状态码和处理异常情况，可利用rcp.Interceptor提供的拦截器对响应进行统一处理。对于非200、206状态码的响应， 使其返回失败的promise，并对请求失败情况进行统一的弹窗提示。具体的拦截逻辑可根据业务需求灵活设置。
```typescript
export class StatusCodeInterceptor implements rcp.Interceptor {
async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {
const url = context.request.url;
return next.handle(context).then((res: rcp.Response) => {
if ([200, 206].includes(res.statusCode)) {
return Promise.resolve(res);
} else {
const message = `Failed to ${url}: statusCode is ${res.statusCode}, message is ${res.toString()}`;
Logger.error(message);
showErrorMessage(message);
return Promise.reject(new Error(message));
}
}).catch((err: BusinessError) => {
Logger.error(`Failed to ${url}: Code is ${err.code}, message is ${err.data}`);
// cancel request don't show err message prompt.
if (err.code !== 1007900992) {
showErrorMessage(JSON.stringify(err.data));
}
return Promise.reject(err);
});
}
}
```
在rcp.sessionConfiguration中配置请求的基地址baseAddress、相关拦截器interceptors、超时时间timeout和添加进度监听回调方法的对象httpEventsHandler。
断点续传
场景描述
在下载一些大文件时，可能会出现网络环境不稳定的情况，一旦网络波动导致传输中断，则需要从头开始重新下载，会极大浪费时间与流量，此时断点续传功能就显得尤为重要。本节通过手动暂停下载方式，讲解断点续传的关键原理和步骤。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151407.76296095494974246066847912952296:50001231000000:2800:FBB6BDF4F04D76D4E6943304FEC30EFAA67BC8FDFED6D5DCF26CB8FE07B9E3DD.gif)
实现原理
关键技术
开发流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151407.46155900534663135663639443461035:50001231000000:2800:D9ABCDC0C3FB06E13EFE04E96580BD587BE7681C067E59A12802395C19D7FC9E.png)
开发步骤
```typescript
export function getFileSize(fileName: string): Promise<number> {
const session = rcp.createSession(genSessionConfig());
return session.head(`/${fileName}`).then(res => {
const contentLength = res.headers['content-length'];
return contentLength ? Number(contentLength): 0;
}).finally(() => {
session.close();
});
}
```
后台文件上传下载
场景描述
在应用切换到后台时，需要继续保持文件上传或下载，在后台静默完成文件传输。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151407.99227175576496651908726778161775:50001231000000:2800:313CB534888AF96716701388A4AF534BA4828B2DB5CE909D1303358E24309537.gif)
实现原理
关键技术
开发流程
开发步骤
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-file-transmission-based-on-sfft
爬取时间: 2025-05-01 09:43:17
来源: Huawei Developer
概述
文件传输（包括上传和下载）是应用程序中极为常见的功能。然而，当应用使用HTTP协议传输长视频、数据集、压缩包等通常超过100MB的大文件时，由于网络不稳定等因素，传输过程可能会耗时较长或直接失败。因此，针对大文件传输的性能优化尤为必要，开发者需要采用特定的策略来确保传输的高效性和可靠性。
目前，super_fast_file_trans（以下简称SFFT）库提供了针对大文件传输过程中的多线程下载、分片上传、断点续传、断点续下及自动重试等特性的完整封装，帮助开发者快速实现大文件传输场景，提高开发效率，开发者可参考Sample工程进行安装配置与快速上手。下文将以上述SFFT支持的各个特性为例，介绍SFFT的使用。
多线程下载
场景描述
多线程下载是一种通过同时开启多个线程，并行下载文件不同部分的文件传输特性，能够充分利用带宽资源，显著提升下载速度，尤其适用于下载大文件或在网络带宽受限的环境下下载文件。其核心原理是将文件分割为多个小块，由多个线程同时下载这些部分，并发写入到本地文件中，从而实现高效、稳定的下载。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151407.64319931886580334691107438663993:50001231000000:2800:1839203ADFDD12EA7AA18B69FAB4BB897A0D6C6D2F9B549A7615B32E03E83B8F.png)
实现原理
SFFT基于TaskPool和@kit.RemoteCommunicationKit（后续简称RCP）实现了多线程下载，实现流程如下：
当使用多线程下载时：
开发步骤
SFFT三方库使用RCP发送HTTP请求，因此使用了以下权限。权限设置详情参考应用权限。
以下代码默认应用已经安装并导入了SFFT三方库，详细的三方库安装教程可以参考"如何使用ohpm引入三四方库"。
实现效果
当使用SFFT进行大文件多线程下载时，下载速率相比于单线程下的普通下载，可以得到明显地提升。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151407.25549370958895293760922666890842:50001231000000:2800:1B19393038B2C003E0DAF8C46B1CB0371FA4045A09AEA141DE506173ED4C69DB.gif)
分片上传
场景描述
分片上传是一种将本地大文件分成多个小块（分片）后，分别上传的特性，可提升传输效率并减少网络波动的影响。若某个分片上传失败，只需重传该分片，无需重新上传整个文件。结合断点续传技术，即使传输被中断也能继续上传，确保上传过程的稳定性，特别适合复杂的网络环境。分片上传需要服务端支持将多个小文件合并成完整文件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151407.35242714286463023406589850284560:50001231000000:2800:CF1D777F75047DCA340924A4E49755320985F4521FC547B16660E4F36AE78E5B.png)
实现原理
SFFT基于RCP实现了分片上传，实现步骤如下：
开发步骤
实现效果
当使用SFFT进行大文件分片上传时，上传速率相比于不使用分片上传，可以得到明显地提升。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151408.15504409750194201741195511339129:50001231000000:2800:C114F676B726D826250DFEB53962E5F6A0F20226FFA475516E68FF67EEBCFE9E.gif)
断点续传/断点续下
场景描述
断点续传/断点续下是指在文件下载或上传过程中，因网络中断、程序崩溃等异常导致传输中断后，应用能够从中断处继续传输剩余文件数据的特性。
这一特性尤其适用于大文件传输场景。在数据传输过程中，应用会周期性地自动保存断点信息，以应对突发中断。当应用再次恢复到正常运行状态时，即可从本地读取断点信息，继续传输文件的剩余部分。这种传输方式能有效应对网络不稳定的问题，减少因网络波动而造成的传输失败，节省流量消耗，为用户提供流畅、可靠的传输体验。
实现原理
断点续下
在SFFT中，断点续下基于上述多线程下载原理，结合关系型数据库RDB实现。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151408.54529149348985255048750281730722:50001231000000:2800:96701F7E1CB61442EFCDCBC994E5692D7DA757F9F357ECB49EC8F1B3D67C4175.png)
当使用断点续下时：
断点续传
在SFFT中，断点续下基于上述分片上传原理，结合RDB实现。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151408.11849550789903761444706010237024:50001231000000:2800:7B42E2A5D2FB2A3C981AB87B960BD8557DC2E4A17F900CB89BD858FAC5DD5BD2.png)
当使用断点续传时：
开发步骤
实现效果
当使用SFFT进行大文件传输时，文件能从应用退出时的传输断点处重新传输。
| 断点续下  | 断点续传  |
| --- | --- |
|   |   |
断点续下
断点续传
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151408.60048233804649938309185244113058:50001231000000:2800:937F9946110D2B469BDB8B7208BE5363A1CF4B1FE00B5348EA35C23D0E5C4C2C.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151408.43063810310328860081513966230039:50001231000000:2800:31EFC3C1F17DD45724EF65F0FDFA2E92FD9FFBF11D8B56BB78F5EC10EB56CB07.gif)
自动重连
场景描述
自动重连是指当文件传输失败时，应用根据异常类型自动尝试重新连接服务端，并继续传输文件数据的特性，目的是为了减少异常情况下的人工干预，确保任务顺利完成。该特性需要断点续下或断点续传支持。
实现原理
当使用自动重连时：
开发步骤
实现效果
当使用SFFT进行大文件传输时，应用能在网络条件恢复时自动重新连接。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151408.61632125106102151404971455734811:50001231000000:2800:D649BA22045D9C2E08A7CD0A9ECA25CA28171FF511466DABA1D2A6887C40DBC2.gif)
服务端要求
下载文件
SFFT依赖服务端支持实现多线程下载，因此服务端需满足以下要求：
上传文件
SFFT依赖服务端支持实现分片下载，因此服务端需满足以下要求：
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-third-party-camera
爬取时间: 2025-05-01 09:43:36
来源: Huawei Developer
概述
本文针对三方相机开发场景，基于HarmonyOS提供的相机开放能力，实现系统相机级别的效果和能力，比如分辨率、动图、视频防抖、连续变焦等。
效果展示
| 功能  | 系统相机  | 三方相机  |
| --- | --- | --- |
| 连续变焦  |   |   |
| 视频防抖：开启前  |    |
| 视频防抖：开启后  |   |   |
| 照片HDR：主摄  |   |   |
| 照片HDR：广角  |   |   |
| 照片HDR：长焦  |   |   |
功能
系统相机
三方相机
连续变焦
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151011.95213355848238831446963211796252:50001231000000:2800:19CC64034834FB80B390AA5AA09FD06E874FA561EEBE725E08162E80310DCD85.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151011.63420287368580674794500170002160:50001231000000:2800:39068943D7EAFEDF3E7FE7411E997F227E5AB12202DE24D8EDA32D38B79CF8E1.gif)
视频防抖：开启前
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151011.87308776228889335950415054573810:50001231000000:2800:0E33EAE83688641E5ACB20AA26BC4BB71CA4332C9E33DAF10C0D07D6F9CD0A33.gif)
视频防抖：开启后
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151012.62691980888989351644848550590974:50001231000000:2800:56F4D70FF8E0B185BD5331D8AE576B0D53E7194833F05C0C6E0D982BAF29B49C.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151012.84291049750256239786537639787507:50001231000000:2800:01B50C0CDCE496243DA23906377EE764304B93460BA82DB6C13B863CF598BF8D.gif)
照片HDR：主摄
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151013.96160083880658048305828628986395:50001231000000:2800:B899C63B93EE62C1AF750970A6D9ACDDE79A7933C4EB0EBFA393C4AF88BCA33E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151013.15022062894990698783941100096239:50001231000000:2800:BE56E01E9B6B21CC37B53C21E421D5C71A7C029EB69B42E0390D1E9D53E35BDA.png)
照片HDR：广角
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151013.46630240268288948470811199801332:50001231000000:2800:EBA8AD336F65020227C97D33DFBE1A9CEB6DE96FD1DFEDC8732CB8B4E8A05B33.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151013.20021469031240688882060123292078:50001231000000:2800:41FA30E02ADF326BFAD98B6C96766D713732A7832461B91007760ABB067C60CB.png)
照片HDR：长焦
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151013.17861495219418728493954352819350:50001231000000:2800:B516B6C5B84B0D22C8622157559E1793546964826CA5C5AF702D4A3186480015.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151013.82022425302584603262727632009172:50001231000000:2800:065DAA225056E81B3CBA8D2B1F955248FBAB95CA80CD36A1CD74B026E68E0DF1.png)
场景使用说明
适用范围
本场景主要适用于第三方应用调用系统相机能力，实现系统级相机效果。
限制版本Developer Beta1及以上。
场景优势
| 场景分类  | 三方相机  | 系统相机  |
| --- | --- | --- |
| 多摄连续变焦（画面亮度，颜色一致）  | 支持  | 支持  |
| 视频防抖  | 支持  | 支持  |
| 照片高动态HDR  | 支持  | 支持  |
场景分类
三方相机
系统相机
多摄连续变焦（画面亮度，颜色一致）
支持
支持
视频防抖
支持
支持
照片高动态HDR
支持
支持
场景分析
典型场景
| 场景名称  | 描述  | 实现方案  |
| --- | --- | --- |
| 拍照  | 照片拍摄  | Camera kit  |
| 录像  | 视频录制  | AVRecorder和Camera kit  |
| 动态照片  | 动态照片拍摄以及预览  | Camera kit和MovingPhotoView组件  |
场景名称
描述
实现方案
拍照
照片拍摄
Camera kit
录像
视频录制
AVRecorder和Camera kit
动态照片
动态照片拍摄以及预览
Camera kit和MovingPhotoView组件
场景实现
场景整体介绍
原理介绍
三方相机开放能力采用与系统相机统一底层接口调用方式，使最终的拍摄保持系统级效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151014.28955503372508738304512342774904:50001231000000:2800:A67B0753FEB6E45BEB291A1E59C892360DEEF59AC3F00C9E21436FC5F0AF9C1A.png)
整体流程
本场景解决方案按照如下流程实现三方相机效果，推荐开发者参考相同流程进行接入，以保证更好体验：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151014.93227738096619156027187423945401:50001231000000:2800:455ABD890CF1D8E1AAAD314CA757D25266F0CE8E25C40341776A8DE671FA0DBD.png)
拍照
如图1所示，应用可以点击底部圆形按钮拍摄照片，同时可以调节变焦，闪光灯等参数。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151014.44149832906157945957392711910285:50001231000000:2800:46DF16647958AA9F70B8FEB7FDF9FAB9EB43632D9B0A372CC814EF5B32234721.png)
时序图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151014.43643932556077449716227863647168:50001231000000:2800:6AB4A58301B40002FE1E38EEC515398859F9E67A0364C5DBE421E81934D1B303.png)
关键点说明
需要获得将照片存入图库的权限。
关键代码片段
1、创建CameraManager对象，需要通过UIContext创建，用来对相机进行操作。
2、获取相机列表，系统会提供前置和后置相机，供开发者选择切换。
3、选择摄像头，创建输入流，作为预览流和拍照流的提供方。
4、获取相机设备支持的输出流能力，此处指定NORMAL_PHOTO获取的是照片流，用来创建拍照输出流和预览输出流。
5、创建预览输出流，通过surfaceId绑定显示组件XComponent。
6、创建拍照输出流，可以输出照片文件。
7、创建相机会话，用于控制修改拍照参数。
8、开始配置会话，向会话中添加各路输入输出流，之后可以拍照。
9、调节闪光灯，通过FLASH_MODE_CLOSE设置为关闭，目前支持关闭，自动，常亮，打开。
10、调节自动变焦模式，通过FOCUS_MODE_CONTINUOUS_AUTO设置为自动模式。目前支持连续自动对焦、自动对焦、手动对焦。
11、调节相机焦距，超出范围则只保留支持范围的值。
12、点击拍照，通过QUALITY_LEVEL_HIGH选择高质量模式。
13、保存图片，此处需要调用系统图库接口photoAccessHelper。
14、预览图片，应用将跳转进入系统图库应用进行预览，需要传入对应的图库uri。
API使用链接
相机管理
相册管理模块
录像
用户在应用界面上点击按钮开始录制，再次点击红色按钮结束录制，同时可以调节变焦，闪光灯，分辨率，视频防抖等参数
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151014.56959579084926369148243389720417:50001231000000:2800:4536B4C6D841EEA84C9CF421086E6928CEDF7C27BF14CA9878E4B260351B6953.png)
时序图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151014.63446763770335939606857368209308:50001231000000:2800:5F4DF667C87CEEBC347CD512736F7EA4A8717AB18149DB6BEC5A36DB11384AD0.png)
关键点说明
需要获得将照片存入图库的权限。
关键代码片段
1、创建CameraManager对象，需要通过UIContext创建，用来对相机进行操作。
2、获取相机列表，系统会提供前置和后置相机，供开发者选择切换。
3、选择摄像头，创建输入流，作为预览流和拍照流的提供方。
4、获取相机设备支持的输出流能力，此处指定NORMAL_VIDEO获取的是视频流，用来创建视频输出流和视频预览输出流。
5、创建预览输出流，通过surfaceId绑定显示组件XComponent。
6、创建视频输出流，可以输出视频文件。
7、创建相机会话，用于控制修改视频参数。
8、开始配置会话，向会话中添加各路输入输出流，之后可以开始录像。
9、通过avRecorder开始录像。
10、通过avRecorder停止录像。
11、保存视频，注意需要将文件uri转化为fd赋值给AVRecorderConfig。
12、预览视频，应用将跳转进入系统图库应用进行预览，需要传入对应的图库uri。
API使用链接
相机管理
相册管理模块
动态照片
拍照按钮触发动态照片拍摄，限制在3s，效果如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151014.80400717136038474957350132027073:50001231000000:2800:8E3A3693804A63D244675D82FD1440EDBBDFD853DE9D7C39EEE8602A2040D4EA.gif)
时序图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151015.97520345050817919378274717340456:50001231000000:2800:530832209719F9A009D37889FC5868B8F66DD24C3AFDB0972AFAF1AE404C018F.png)
关键点说明
使能动态照片前需要分段式拍照能力。固定拍摄时间固3s。
关键代码片段
1、创建拍照输出流。
2、查询当前设备当前模式是否支持动态照片能力。
3、使能动态照片拍照能力。
4、预览需要使用MovingPhotoView，长按图片会播放动图。
API使用链接
相机管理
相册管理模块
动态照片
相关技术参考
相机服务
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-camera-shot2see
爬取时间: 2025-05-01 09:43:49
来源: Huawei Developer
概述
相机拍照性能依赖算法处理的速度，而处理效果依赖算法的复杂度，算法复杂度越高的情况下会导致处理时间就越长。目前系统相机开发有两种相机拍照方案，分别是相机分段式拍照和相机单段式拍照：
分段式拍照和单段式拍照返回的图片在全质量图的情况下图片质量是一致的，但是在低质量的情况下单段式拍照的图片质量要优于分段式拍照。如果开发者不需要获取全质量图并且也不考虑Shot2See的完成时延，建议使用单段式拍照，否则的话，建议使用分段式拍照。本篇文章主要以相机Shot2See场景为例，来展示分段式拍照Shot2See的完成时延要低于单段式拍照。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151015.11676093100645845000536086709630:50001231000000:2800:806E6D5C461F16EC38E95FBD27EE819E39147ADED50651CA385492A8EE005ED0.png)
效果展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151015.62605025360441586450045126270317:50001231000000:2800:DF56B856FA89D798D1E42352D26E6B6768B1CFBA8AB2EB811878E0B94D29F17E.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151015.87451925809471512123990482735248:50001231000000:2800:A98900719ACBED7072AD66B120C9FFBEBDBAEF659730471EBB9AF3695136F454.gif)
从上述效果图中可以看出，分段式拍照从用户点击拍照控件到在缩略图显示区域显示缩略图的耗时比单段式拍照要短。
性能对比分析方式
静态校验：在相机类应用中，如果使用单段式拍照，拍照过程中该场景下仅会返回一张图片，将图片用作Shot2See后的缩略图则会导致Shot2See完成时延比较长。
动态校验：开发者可以通过DevEco Studio中的Profiler工具去抓取Trace，获取到Trace之后，根据PhotoOutputNapi::Capture和OnBufferAvailable找到对应的Trace Marker，并通过两者之间的时间段来分析耗时，单段式拍照的时长为1900ms，而分段式拍照的时长为672.7ms。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151016.75531468670100626743628417660848:50001231000000:2800:89CAEE85DF225C0EF4515A079E725F189B6F918DA468166437B960552DCA1A7B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151016.90030003909797950710901496284156:50001231000000:2800:FE4E8EB42B39462D8B93F2C34FA3329BA9B0C4A593C0287F222D642940923A98.png)
性能对比分析表
| 拍照实现方式  | 耗时(局限不同设备和场景，数据仅供参考)  |
| --- | --- |
| 单段式拍照  | 1900ms  |
| 分段式拍照  | 672.7ms  |
拍照实现方式
耗时(局限不同设备和场景，数据仅供参考)
单段式拍照
1900ms
分段式拍照
672.7ms
优化思路：在需要加快Shot2See完成时延的场景下，使用相机框架开发的分段式拍照方案，加快阶段一照片生成的速度。
场景示例
下面以应用中相机Shot2See（拍照之后自动跳转到照片编辑界面）为例，通过单段式拍照和分段式拍照的性能功耗对比，来展示两者的性能差异。
单段式拍照：
单段式拍照使用了on(type: 'photoAvailable', callback: AsyncCallback<Photo>): void接口注册了高质量图的监听，默认不使能分段式拍照。具体操作步骤如下所示：
1.相机媒体数据写入XComponent组件中，用来显示图像效果。具体代码如下所示：
2.initCamera函数完成一个相机生命周期初始化的过程。
(1)getCameraManager获取CameraMananger相机管理器类。
(2)getSupportedCameras和getSupportedOutputCapability方法获取支持的camera设备以及设备能力集。
(3)createPreviewOutput和createPhotoOutput方法创建预览输出和拍照输出对象。
(4) CameraInput的open方法打开相机输入。
(5) onCameraStatusChange函数创建CameraManager注册回调。
(6) 最后调用sessionFlowFn函数创建并开启Session。具体代码如下所示：
3.确定拍照输出流。通过cameraManager.createPhotoOutput方法创建拍照输出流，参数为CameraOutputCapability类中的photoProfiles属性。
4.触发拍照。通过photoOutput类的capture方法，执行拍照任务。该方法有两个参数，分别为拍照设置参数的setting以及回调函数，setting中可以设置照片的质量和旋转角度。具体代码如下所示：
5.设置拍照photoAvailable的回调来获取Photo对象，点击拍照按钮，触发此回调函数，调用getComponent方法根据图像的组件类型从图像中获取组件缓存ArrayBuffer，使用createImageSource方法来创建图片源实例，最后通过createPixelMap获取PixelMap对象。注意:如果已经注册了photoAssetAvailable回调，并且在Session开始之后又注册了photoAvailable回调，会导致流被重启。不建议开发者同时注册photoAvailable和photoAssetAvailable。
以上代码中执行handleImageInfo函数来对PixelMap进行全局存储并跳转到预览页面。具体代码如下所示：
6.进入到预览界面，通过GlobalContext.get().getT<image.PixelMap>('imageInfo')方法获取PixelMap信息，并通过Image组件进行渲染显示。
分段式拍照：
分段式拍照是应用下发拍照任务后，系统将分多阶段上报不同质量的图片。在一阶段，系统快速上报低质量图，应用通过on(type: 'photoAssetAvailable', callback: AsyncCallback<photoAccessHelper.PhotoAsset>): void接口会收到一个PhotoAsset对象，通过该对象可调用媒体库接口，读取图片或落盘图片。在二阶段，分段式子服务会根据系统压力以及定制化场景进行调度，将后处理好的原图回传给媒体库，替换低质量图。具体操作步骤如下所示：
由于分段式拍照和单段式拍照步骤1-步骤4相同，就不再进行赘述。
5.设置拍照photoAssetAvailable的回调来获取photoAsset，点击拍照按钮，触发此回调函数，然后执行handlePhotoAssetCb函数来完成photoAsset全局的存储并跳转到预览页面。
以上代码中执行handleImageInfo函数来对photoAsset进行全局存储并跳转到预览页面。具体代码如下所示：
6.进入预览界面通过GlobalContext.get().getT<image.PixelMap>('imageInfo')方法获取PhotoAsset信息，执行requestImage函数中的photoAccessHelper.MediaAssetManager.requestImageData方法根据不同的策略模式，请求图片资源数据，这里的请求策略为均衡模式BALANCE_MODE， 最后分段式子服务会根据系统压力以及定制化场景进行调度，将后处理好的原图回传给媒体库来替换低质量图。具体代码如下所示：
7.将步骤6获取的PixelMap对象数据通过Image组件进行渲染显示。
总结
通过分段式拍照，确保低质量图可接受的基础上，加快了Shot2See的完成时延，同时第二段保证了高质量照片不损失图片效果，达到与系统相机一致的拍照质量。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-audio-interaction-practice
爬取时间: 2025-05-01 09:44:06
来源: Huawei Developer
概述
对于音频播放类应用，除了歌曲播控的基础能力外，各种交互场景的设计也对用户体验有着重要的影响。本文以音乐播放器应用为例，从应用与用户、播放设备以及其他应用的交互三方面入手，分别对典型使用场景给出示例方案，为应用带来灵活多样、符合用户直觉的交互体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151016.32058600734321710888696604359624:50001231000000:2800:30029C3657A6C08AD0D53E478B717608DBAD922B241021C27B7E0292EE2788E6.gif)
场景分析
根据当前HarmonyOS APP开发过程中遇到的实际音频类应用业务场景，总结提炼出如下典型场景，设计其交互功能与方案以供参考：
| 场景分类  | 典型场景  | 场景描述  |
| --- | --- | --- |
| 与用户交互  | 播控中心操控  | 无需进入应用直接通过播控中心操控歌曲状态  |
| 后台播放音乐  | 应用位于后台长时间持续播放音乐  |
| 与音频播放设备交互  | 播放设备的状态发生改变  | 新设备可用、旧设备不可用、用户切换设备场景的适配方案  |
| 响应播放设备的指令  | 蓝牙耳机控制应用播放状态  |
| 用户主动切换播放设备  | 通过投播组件选择播放设备  |
| 与其他应用交互  | 与其他应用音频冲突  | 被其他音频打断、与其他音频并发  |
场景分类
典型场景
场景描述
与用户交互
播控中心操控
无需进入应用直接通过播控中心操控歌曲状态
后台播放音乐
应用位于后台长时间持续播放音乐
与音频播放设备交互
播放设备的状态发生改变
新设备可用、旧设备不可用、用户切换设备场景的适配方案
响应播放设备的指令
蓝牙耳机控制应用播放状态
用户主动切换播放设备
通过投播组件选择播放设备
与其他应用交互
与其他应用音频冲突
被其他音频打断、与其他音频并发
与用户交互
播控中心控制音乐状态
在应用接入播控中心后，用户可以直接通过播控中心修改音频播放状态，如暂停/播放、下一首、切换播放模式、拖动进度条等，应用内的音频信息和状态也会同步显示在播控中心界面上，使得用户与应用的交互更加灵活易用。同时与播控中心交互使用的AVSession还管控着应用的后台播放能力，因此对于音乐类应用一般推荐接入播控中心，具体适用场景可以参考应用接入AVSession场景介绍。
应用与播控中心交互的过程如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151016.90352382502924185442594749353775:50001231000000:2800:24DC5FF46F47F771CE953063B862B8642372F595AC75C02D547280CD879A2346.png)
由图可见，应用的接入流程可以主要分为三个部分：创建AVSession、监听播控中心通知以及向播控中心上报应用状态，以下分别给出具体实现：
```typescript
import { avSession } from '@kit.AVSessionKit';
// ...
export class AVSessionController {
private context: common.UIAbilityContext | undefined = undefined;
private AVSession: avSession.AVSession | undefined = undefined;
private songList: SongItem[] = [];
private musicIndex: number | undefined = undefined;
private audioRendererController: AudioRendererController | undefined = undefined;
// ...
private async initAVSession() {
this.context = AppStorage.get('context');
if (!this.context) {
Logger.info(TAG, `session create failed : conext is undefined`);
return;
}
this.audioRendererController = AppStorage.get('audioRendererController');
if (!this.audioRendererController) {
Logger.info(TAG, `session create failed : audioRendererController is undefined`);
return;
}
this.AVSession = await avSession.createAVSession(this.context, "PLAY_AUDIO", 'audio');
await this.AVSession.activate();
// ...
}
// ...
}
```
1.  适配后效果如图，应用内的歌词、播放进度、收藏状态、循环模式、歌曲信息与播控中心展示状态一致：
```typescript
// 设置收藏状态
private setFavoriteState(isFavorite: boolean) {
if (this.AVSession) {
this.AVSession.setAVPlaybackState({ isFavorite }, (err: BusinessError) => {
if (err) {
Logger.error(TAG, `SetAVPlaybackState BusinessError: code: ${err.code}, message: ${err.message}`);
} else {
Logger.info(TAG, 'SetAVPlaybackState successfully');
}
});
}
}
// 设置进度条状态
public setProgressState(ms: number) {
if (this.AVSession) {
this.AVSession.setAVPlaybackState({
position: {
elapsedTime: ms,
updateTime: new Date().getTime()
}
}, (err: BusinessError) => {
if (err) {
Logger.error(TAG, `SetAVPlaybackState BusinessError: code: ${err.code}, message: ${err.message}`);
} else {
Logger.info(TAG, 'SetAVPlaybackState successfully');
}
});
}
}
// 设置播放暂停状态
public setPlayState(isPlay: boolean) {
if (this.AVSession) {
this.AVSession.setAVPlaybackState({
state: isPlay ? avSession.PlaybackState.PLAYBACK_STATE_PLAY : avSession.PlaybackState.PLAYBACK_STATE_PAUSE,
}, (err: BusinessError) => {
if (err) {
Logger.error(TAG, `SetAVPlaybackState BusinessError: code: ${err.code}, message: ${err.message}`);
} else {
Logger.info(TAG, 'SetAVPlaybackState successfully');
}
});
}
}
// ...
// 设置循环模式
public async setLoopModeState(AVSessionLoopMode: avSession.LoopMode) {
if (this.AVSession) {
this.AVSession.setAVPlaybackState({ loopMode: AVSessionLoopMode }, (err: BusinessError) => {
if (err) {
Logger.error(TAG, `SetAVPlaybackState BusinessError: code: ${err.code}, message: ${err.message}`);
} else {
Logger.info(TAG, 'SetAVPlaybackState successfully');
}
});
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151017.21117313719503126708089601855691:50001231000000:2800:E8831D9F9A7D8062CB2ACCE227EDB447ADCEBA69E5A8EEA556EF01763E1066E8.png)
后台播放音乐
实现播控中心的接入后，解除了必须进入应用才能调整播放状态的限制，但应用退到后台状态后很快就会被挂起，导致歌曲中断。此时在接入AVSession的基础上还需要申请长时任务，保证歌曲能在后台一直保持播放状态，达到连贯的听歌体验，具体实现方式如下：
```typescript
import { wantAgent, common } from '@kit.AbilityKit';
import { backgroundTaskManager } from '@kit.BackgroundTasksKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { Logger } from './Logger';
const TAG = 'BackgroundUtil';
export class BackgroundUtil {
// 申请长时后台任务
public static startContinuousTask(context?: common.UIAbilityContext): void {
if (!context) {
Logger.error(TAG, 'startContinuousTask failed', `context undefined`);
return;
}
let wantAgentInfo: wantAgent.WantAgentInfo = {
wants: [
{
bundleName: context.abilityInfo.bundleName,
abilityName: context.abilityInfo.name
}
],
operationType: wantAgent.OperationType.START_ABILITY,
requestCode: 0,
wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]
};
wantAgent.getWantAgent(wantAgentInfo).then((wantAgentObj: Object) => {
try {
backgroundTaskManager.startBackgroundRunning(context,
backgroundTaskManager.BackgroundMode.AUDIO_PLAYBACK, wantAgentObj).then(() => {
Logger.info('this audioRenderer: ', 'startBackgroundRunning succeeded');
}).catch((error: BusinessError) => {
Logger.error('this audioRenderer: ', `startBackgroundRunning failed Cause: code ${error.code}`);
});
} catch (error) {
Logger.error(TAG, `startBackgroundRunning failed.message ${(error as BusinessError).message}`);
}
});
}
// 停止长时后台任务
public static stopContinuousTask(context: common.UIAbilityContext): void {
try {
backgroundTaskManager.stopBackgroundRunning(context).then(() => {
Logger.info('this audioRenderer: ', 'stopBackgroundRunning succeeded');
}).catch((error: BusinessError) => {
Logger.error('this audioRenderer: ', `stopBackgroundRunning failed Cause: code ${error.code}`);
});
} catch (error) {
Logger.error(TAG, `stopBackgroundRunning failed. message ${(error as BusinessError).message}`);
}
}
}
```
```typescript
// 释放audioRenderer
public async release() {
if (this.audioRenderer && this.context) {
try {
await this.audioRenderer.release().catch((err: BusinessError) => {
Logger.error(TAG, `release failed,code is ${err.code},message is ${err.message}}`);
})
this.avSessionController?.unregisterSessionListener();
BackgroundUtil.stopContinuousTask(this.context);
Logger.info(TAG, 'release success');
} catch (e) {
Logger.error(TAG, `release failed,audioRenderer is undefined`);
}
}
}
```
与播放设备交互
播放设备状态发生改变
当应用连接的播放设备状态发生改变时，需要及时做出对应的处理，从音频流输出目标的切换、音频播放状态的改变到应用界面的更新，都应该与系统行为以及用户直觉相符，来保证交互体验的一致性，以下分别对各种变更场景给出适配方案：
1.  新设备上线时，会触发播放设备自动切换，切换的优先级按下图所示，个人类设备高于公共类设备，同一优先级遵循后入优先原则。因此如果一开始通过扬声器播放，接入耳机后会自动切换至耳机播放，无需应用主动切换。 应用可以通过监听outputDeviceChangeWithInfo事件来感知外放设备的切换，新设备上线对应的变更原因是AudioStreamDeviceChangeReason.REASON_NEW_DEVICE_AVAILABLE，如上所述这种情况切换到新的设备播放的行为是系统行为，应用不需要主动改变输出设备；如果有特殊业务逻辑如接入新设备时暂停播放或者对新接入设备进行管理等，可在此类回调中进行处理。
2.  类型 处理建议 游戏场景 不进行暂停 音乐场景 根据回调进行暂停 听书场景 根据回调进行暂停 视频场景 根据回调进行暂停 应用同样可以监听设备变更事件并对AudioStreamDeviceChangeReason.REASON_OLD_DEVICE_UNAVAILABLE的场景进行处理，在回调中根据当前播放设备类型选择后续行为，例如为扬声器时暂停，为其他设备则继续播放。 注意具有佩戴检测能力的蓝牙耳机入耳、摘下时会通过播控中心分别对应用发送播放和暂停的通知，应用可以通过监听播控中心指令而非设备变更事件来适配此类操作。
3.  当用户通过投播组件主动切换输出设备时，系统会自动切换到新选择的设备播放音频，应用可以对变更原因为AudioStreamDeviceChangeReason.REASON_OVERRODE的事件处理自己的业务逻辑，接入投播组件可以参考主动切换播放设备。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151017.99347112913983406082046797027702:50001231000000:2800:B4FFEC157EF081EF12423182624772BBC4E30C93AA89CD21BDCBD7A8F2C69FD1.png)
| 类型  | 处理建议  |
| --- | --- |
| 游戏场景  | 不进行暂停  |
| 音乐场景  | 根据回调进行暂停  |
| 听书场景  | 根据回调进行暂停  |
| 视频场景  | 根据回调进行暂停  |
示例代码如下，分别对各种类型的设备状态改变事件做出对应的处理：
```typescript
private setOutputDeviceChangeCallback() {
if (!this.audioRenderer) {
return;
}
this.audioRenderer.on('outputDeviceChangeWithInfo', this.outputDeviceChangeCallback);
}
private outputDeviceChangeCallback: (deviceChangeInfo: audio.AudioStreamDeviceChangeInfo) => void =
(deviceChangeInfo: audio.AudioStreamDeviceChangeInfo) => {
Logger.info(TAG, `DeviceInfo id: ${deviceChangeInfo.devices[0].id}`);
Logger.info(TAG, `DeviceInfo name: ${deviceChangeInfo.devices[0].name}`);
Logger.info(TAG, `DeviceInfo address: ${deviceChangeInfo.devices[0].address}`);
Logger.info(TAG, `Device change reason: ${deviceChangeInfo.changeReason}`);
if (deviceChangeInfo.changeReason === audio.AudioStreamDeviceChangeReason.REASON_NEW_DEVICE_AVAILABLE) {
// 新设备可用，应用按需适配业务逻辑
} else if (deviceChangeInfo.changeReason === audio.AudioStreamDeviceChangeReason.REASON_OLD_DEVICE_UNAVAILABLE) {
// 旧设备不可用，暂停播放
Logger.info(TAG, `Device change reason: ${deviceChangeInfo.changeReason}`);
this.pause();
} else if (deviceChangeInfo.changeReason === audio.AudioStreamDeviceChangeReason.REASON_OVERRODE) {
// 用户强选设备，应用按需适配业务逻辑
}
}
```
响应播放设备指令
通过有线耳机、蓝牙耳机实现对音频的播放、暂停、上一首、下一首等基本操作，需要应用接入播控中心，并注册播控命令事件监听，以便响应播控中心下发的命令。应用通过蓝牙耳机发送指令与直接点击播控中心控制音频机制相同，因此接入播控中心监听播控指令即可，具体接入过程可参考播控中心控制音乐状态。
用户主动切换播放设备
将投播组件布局在页面的合理位置，点击选择音频输出设备，如图所示可以从本机扬声器切换到已连接的蓝牙耳机：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151017.95929032572672148832272790355358:50001231000000:2800:640BA5F48A918E7BA47392E258279C647012B7709073D6FD94E80ADFA17526E2.gif)
与其他应用交互
与其他应用音频冲突
当与其他应用的音频发生冲突，多个音频流同时播放时，系统预设了音频打断策略，对多音频的并发进行管控，只有持有音频焦点的音频流才可以正常播放，避免多个音频流无序并发播放的现象出现。为了维持应用和系统的状态一致性，保证符合用户直觉的交互体验，推荐应用处理音频焦点变化，并在收到音频打断事件（InterruptEvent）时做出相应处理。对于音乐类应用，被各种处理音频焦点变化类型的其他应用音频打断场景和效果如下表所示：
| 先播应用音频类型  | 后播应用音频类型  | 打断效果  |
| --- | --- | --- |
| 音乐  | 闹钟  | 后播应用播放时，先播应用暂停播放；后播应用停止播放后，先播应用恢复播放  |
| 电话  |
| 铃声  |
| VOIP 铃声(全屏呼叫/呼叫页面/横幅呼叫)  |
| VOIP 通话  |
| VOIP MESSAGE(微信语音/畅联)  |
| 导航  | 后播应用播放时，先播应用降低音量持续播放；后播应用停止播放后，先播应用恢复音量继续播放  |
| TextReader控件朗读语音  |
| 语音助手类短语音  |
| 音乐  | 后播应用播放时，先播应用停止播放；后播应用停止播放后，先播应用不再恢复播放  |
| 视频  |
| 游戏  | 先播、后播应用并发混音播放  |
| 系统音效(锁屏/按键)  |
先播应用音频类型
后播应用音频类型
打断效果
音乐
闹钟
后播应用播放时，先播应用暂停播放；后播应用停止播放后，先播应用恢复播放
电话
铃声
VOIP 铃声(全屏呼叫/呼叫页面/横幅呼叫)
VOIP 通话
VOIP MESSAGE(微信语音/畅联)
导航
后播应用播放时，先播应用降低音量持续播放；后播应用停止播放后，先播应用恢复音量继续播放
TextReader控件朗读语音
语音助手类短语音
音乐
后播应用播放时，先播应用停止播放；后播应用停止播放后，先播应用不再恢复播放
视频
游戏
先播、后播应用并发混音播放
系统音效(锁屏/按键)
如表所示，根据应用打断效果主要可以分为四个类型：暂停后恢复、降低音量后恢复、停止后不恢复和并发播放，以下分别对这四类场景给出适配方案：
1.  后播音频类型为闹钟/电话/铃声/VOIP音频时，先播音频暂停播放；待后播音频播放完毕后，先播音频恢复播放。应用可以注册焦点事件监听，当此类打断事件发生时，系统会自动暂停先播音频，应用侧会接收到INTERRUPT_HINT_PAUSE事件，此时只需更新播放和UI界面状态为暂停态即可，不需要主动停止音频流。当后播音频结束后，应用接收到INTERRUPT_HINT_RESUME事件，此时系统不会主动继续播放先播音频，应用需主动调用播放方法续播音频流。
2.  当后播应用音频类型为导航/TextReader语音/语音助手类语音播报时，先播音频应降低音量持续播放；后播音频播报结束后，先播音频恢复音量继续播放。注意此类打断事件的音量降低/恢复行为是系统行为，应用无需主动调整音量。在降低音量和恢复时会分别收到INTERRUPT_HINT_DUCK和INTERRUPT_HINT_UNDUCK回调，应用可以在回调中按需更新页面状态或处理其他业务逻辑。
3.  当后播应用音频类型为音乐/视频时，音乐终止播放；后播音频停止后，音乐不恢复播放。应用可以注册焦点事件监听，接收到INTERRUPT_HINT_STOP事件时，停止音乐播放，并更新UI界面。
综上四种情况，在audioRenderer.on('audioInterrupt')回调中分别对各种打断类型场景做出对应处理，并实现静音播放接口及设置音频会话策略为暂停模式，示例代码实现如下：
```typescript
// 监听音频打断事件
private setInterruptCallback() {
if (!this.audioRenderer) {
return;
}
this.audioRenderer.on('audioInterrupt', this.interruptCallback);
}
// 在回调中处理各类打断事件
private interruptCallback: (interruptEvent: audio.InterruptEvent) => void =
(interruptEvent: audio.InterruptEvent) => {
if (interruptEvent.forceType === audio.InterruptForceType.INTERRUPT_FORCE) {
switch (interruptEvent.hintType) {
case audio.InterruptHint.INTERRUPT_HINT_PAUSE:
// 此分支表示系统已将音频流暂停（临时失去焦点），为保持状态一致，应用需切换至音频暂停状态
// 临时失去焦点：待其他音频流释放音频焦点后，本音频流会收到resume对应的音频打断事件，到时可自行继续播放
this.updateIsPlay(false);
break;
case audio.InterruptHint.INTERRUPT_HINT_STOP:
// 此分支表示系统已将音频流停止（永久失去焦点），为保持状态一致，应用需切换至音频暂停状态
// 永久失去焦点：后续不会再收到任何音频打断事件，若想恢复播放，需要用户主动触发。
this.updateIsPlay(false);
this.pause();
break;
case audio.InterruptHint.INTERRUPT_HINT_DUCK:
// 此分支表示系统已将音频音量降低（默认降到正常音量的20%）
// 此时应用可以处理当音量降低时的业务逻辑
break;
case audio.InterruptHint.INTERRUPT_HINT_UNDUCK:
// 此分支表示系统已将音频音量恢复正常
// 此时应用可以处理当音量恢复时的业务逻辑
break;
default:
break;
}
} else if (interruptEvent.forceType === audio.InterruptForceType.INTERRUPT_SHARE) {
switch (interruptEvent.hintType) {
case audio.InterruptHint.INTERRUPT_HINT_RESUME:
// 此分支表示临时失去焦点后被暂停的音频流此时可以继续播放，建议应用继续播放，切换至音频播放状态
// 若应用此时不想继续播放，可以忽略此音频打断事件，不进行处理即可
this.start();
break;
default:
break;
}
}
}
// ...
// 通过用户首选项数据设置静音并发模式
private async setSilentModeAndMixWithOthersFromPrefer() {
if (!this.audioRenderer || !this.context) {
return;
}
let formIds: string[] = await PreferencesUtil.getInstance().getFormIds(this.context);
let isSupportSilent = false;
if (formIds.includes(SILENT_ID)) {
isSupportSilent = true;
} else {
isSupportSilent = false;
}
AppStorage.setOrCreate('isSilentMode', isSupportSilent);
this.audioRenderer.setSilentModeAndMixWithOthers(isSupportSilent);
}
// 通过按钮设置静音并发模式
public async setSilentModeAndMixWithOthers(isSupportSilent: boolean = false) {
if (!this.audioRenderer || !this.context) {
return;
}
let audioManger = audio.getAudioManager();
let audioSessionManager: audio.AudioSessionManager = audioManger.getSessionManager();
let strategy: audio.AudioSessionStrategy = {
concurrencyMode: audio.AudioConcurrencyMode.CONCURRENCY_PAUSE_OTHERS
};
let formIds: string[] = await PreferencesUtil.getInstance().getFormIds(this.context);
if (isSupportSilent) {
if (!formIds.includes(SILENT_ID)) {
await PreferencesUtil.getInstance().addFormId(this.context, SILENT_ID);
}
this.audioRenderer.setSilentModeAndMixWithOthers(isSupportSilent);
// 停用AudioSession后，系统发INTERRUPT_HINT_RESUME给之前被打断的音频流
audioSessionManager.deactivateAudioSession().then(() => {
Logger.info(TAG, 'deactivateAudioSession SUCCESS');
}).catch((err: BusinessError) => {
Logger.error(TAG, `ERROR: ${err}`);
});
} else {
// 需要先激活AudioSession，再解除静音
audioSessionManager.activateAudioSession(strategy).then(() => {
Logger.info(TAG, 'activateAudioSession SUCCESS');
}).catch((err: BusinessError) => {
Logger.error(TAG, `ERROR: ${err}`);
});
if (formIds.includes(SILENT_ID)) {
await PreferencesUtil.getInstance().removeFormId(this.context, SILENT_ID);
}
this.audioRenderer.setSilentModeAndMixWithOthers(isSupportSilent);
}
AppStorage.setOrCreate('isSilentMode', isSupportSilent);
}
```
检测应用音频冲突适配完整性
这里提供了一个音频检测应用，开发者可以用来检测自己开发的音频应用在不同场景下的功能完备度和准确性等，帮助开发者修复音频焦点类的应用功能问题。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-video-playback-development-practice
爬取时间: 2025-05-01 09:44:20
来源: Huawei Developer
概述
本文适用于视频播放类应用的开发，针对市场上主流视频播放类应用的常见场景，介绍了如何基于HarmonyOS能力快速实现视频播放应用。
从用户交互和音频流状态变更两个维度，指导开发者基于HarmonyOS提供的媒体和ArkUI等能力，实现视频前后台播放控制、播放形态切换、音频焦点切换、播放设备切换等场景，可以为视频播放应用提供灵活的交互体验和良好的观看效果。
在阅读本文之前，建议开发者先熟悉视频播放器《AVPlayer实现》，如果应用希望实现短视频播放功能，还需要参考《在线短视频流畅切换》。
场景分析
| 场景名称  | 子场景名称  | 描述  | 实现方案  |
| --- | --- | --- | --- |
| 与用户交互   | 播放进度控制  | 进度条控制。  | 使用Slider组件实现进度条，在其onChange回调中触发进度调节。  |
| 手势调节播放进度。  | 通过给组件绑定手势识别，来实现手势调节播放进度。  |
| 显示进度条弹窗。  | 给进度条添加Popup弹窗。  |
| 播放形态切换  | 横竖屏切换。  | 基于窗口能力实现全屏播放。  |
| 悬浮窗播放。  | 应用布局适配智慧多窗。  |
| 播控中心控制视频状态  | 应用响应播控中心通知，向播控中心同步视频信息状态。  | 监听AVSession播放状态事件。  |
| 视频后台播放  | 应用至于后台时可以继续播放。  | 基于AVSession Kit和Background Tasks Kit申请长时任务。  |
| 滑动调节音量及亮度  | 视频全屏播放时，可以滑动屏幕调节音量及亮度。  | 使用AVVolumePanel组件控制音量，使用Slider组件及setWindowBrightness方法控制亮度。  |
| 音频流状态变更  | 多音频并发打断  | 视频应用被其他应用的音频打断做出对应的行为。  | AVPlayer监听音频打断事件。  |
| 播放设备切换  | 视频应用连接的播放设备状态发生变更时做出对应的行为。  | AVPlayer监听设备音频流输出变化。  |
场景名称
子场景名称
描述
实现方案
与用户交互
播放进度控制
进度条控制。
使用Slider组件实现进度条，在其onChange回调中触发进度调节。
手势调节播放进度。
通过给组件绑定手势识别，来实现手势调节播放进度。
显示进度条弹窗。
给进度条添加Popup弹窗。
播放形态切换
横竖屏切换。
基于窗口能力实现全屏播放。
悬浮窗播放。
应用布局适配智慧多窗。
播控中心控制视频状态
应用响应播控中心通知，向播控中心同步视频信息状态。
监听AVSession播放状态事件。
视频后台播放
应用至于后台时可以继续播放。
基于AVSession Kit和Background Tasks Kit申请长时任务。
滑动调节音量及亮度
视频全屏播放时，可以滑动屏幕调节音量及亮度。
使用AVVolumePanel组件控制音量，使用Slider组件及setWindowBrightness方法控制亮度。
音频流状态变更
多音频并发打断
视频应用被其他应用的音频打断做出对应的行为。
AVPlayer监听音频打断事件。
播放设备切换
视频应用连接的播放设备状态发生变更时做出对应的行为。
AVPlayer监听设备音频流输出变化。
与用户交互
播放进度控制
进度条控制
进度条作为视频应用的一个基础能力，可以通过点击或拖动进度条来调节视频播放进度。采用Slider组件实现进度条功能，根据Slider组件属性设置进度条样式，并在其onChange()事件中触发视频播放器AVPlayer的seek()方法，实现视频进度的控制。
手势调节播放进度
通常视频播放应用还可以支持手势滑动来调节播放的进度，可以给组件绑定手势识别，来实现在视频界面左右滑动调节视频播放进度的能力，手势类型选择PanGesture（平移手势）。
显示进度条弹窗
在正常浏览视频的过程中，应用会记录用户的浏览历史，当再次切换到原视频时，根据历史数据在进度条上以弹窗的形式显示相关信息。并且让弹窗跟随滑块位置移动，弹窗保留1秒后消失。同时历史数据的保留跟随视频组件的生命周期存亡。
由于Slider自带的showTips无法对弹窗样式进行自定义，只支持圆形气泡，且无法自定义控制弹窗的显示时长和出现时机。所以我们通过创建一个和Slider滑块大小一致的透明Stack，并计算滑块在屏幕中的位置，将计算的位置数据同步设置给Stack，并给Stack绑定Popup弹窗跟随Slider滑块运动。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151017.80468196202942912963671912845545:50001231000000:2800:3A3C28F64C89551A6558718A15B6BB9BCCF9B862C0FF3257CB3B437E12DCF103.png)
关键代码：
通过给Slider组件绑定区域变化事件onAreaChange()，计算滑动位置信息。
Stack透明块大小、位置设置以及给Stack绑定Popup弹窗。
播放形态切换
横竖屏切换
横竖屏切换是视频应用常见的功能，用户会根据自己喜好选择在横屏或竖屏模式下观看。
设置窗口旋转策略有两种方式：
这两种方式触发设置旋转的时机不同，module.json5文件中的字段在窗口启动时就会生效，对于应用启动时就需要设置横屏或者竖屏的应用，可以进行配置。而setPreferredOrientation()是在调用该方法时进行窗口方向的设置，用于在应用启动之后，还需要改变显示方向的场景。
本示例主要介绍通过使用窗口的setPreferredOrientation()方法来实现应用的横竖屏切换能力，下面给出具体实现方案，更多详情可参考横竖屏开发实践。
1.  当进入首页视频列表时，仅支持竖屏，要切换视频播放页面为横屏时，采用window窗口能力，通过setPreferredOrientation()将窗口显示的方向修改为横屏、竖屏的状态。在使用时，根据应用自身的旋转策略选择相应的参数。窗口显示方向类型枚举可以参考：window.Orientation。
2.  当用户手动设置窗口方向时，窗口的显示会发生变化，对应窗口的size也会发生改变，此时可以通过拿到窗口的宽高，并对宽高进行对比，判断当前显示是竖屏还是横屏状态，并利用该数据对布局进行适配。监听窗口尺寸的变化可以通过window.on('windowSizeChange')进行实现。
悬浮窗播放
视频应用添加悬浮窗能力，可以让用户在观看视频时，临时处理另一个任务或短时间多任务并行使用，如边看视频边浏览网页等行为，更多可参考应用布局适配智慧多窗。
1.  首先需要通过对module.json5配置文件中abilities标签下的supportWindowMode属性增加“floating”字段或使用缺省值以声明应用支持悬浮窗。 因为本视频应用需要支持横向和竖向悬浮窗两种能力，所以还需对abilities标签下的preferMultiWindowOrientation属性设置为landscape_auto，来标识当前UIAbility组件多窗布局方向。
2.  由于应用从全屏进入悬浮窗后，应用的窗口尺寸会发生变化，所以应用需要根据不同的窗口尺寸调整自身布局。可以通过窗口的on('windowSizeChange')方法实现对窗口尺寸大小变化的监听。再根据窗口的尺寸变化，更新调整自身应用布局以实现适配。
```typescript
public setWindowStage(windowStage: window.WindowStage): void {
this.windowStage = windowStage;
this.windowStage.getMainWindow((err, windowClass: window.Window) => {
// ...
this.mainWindowClass = windowClass;
const properties = windowClass.getWindowProperties(); // 获取窗口信息
// ...
AppStorage.setOrCreate('deviceWidth', properties.windowRect.width); // 设置窗口宽度
AppStorage.setOrCreate('deviceHeight', properties.windowRect.height); // 设置窗口高度
// ...
});
}
```
```typescript
public setWindowStage(windowStage: window.WindowStage): void {
this.windowStage = windowStage;
this.windowStage.getMainWindow((err, windowClass: window.Window) => {
// ...
this.mainWindowClass = windowClass;
const properties = windowClass.getWindowProperties(); // 获取窗口信息
// ...
AppStorage.setOrCreate('deviceWidth', properties.windowRect.width); // 设置窗口宽度
AppStorage.setOrCreate('deviceHeight', properties.windowRect.height); // 设置窗口高度
// ...
});
}
```
播控中心控制视频状态
用户除了在视频界面控制视频状态外，还可以通过给应用接入AVSession播控中心，使用户在播控中心也能看到当前播放视频的信息，并通过播控中心直接对视频进行快进、快退、拖动进度、播放暂停、切换、调节音量等操作。同时应用内的视频状态与信息也会与播控中心相互同步，避免了只有在视频界面才能控制视频状态的单一场景，更多详情可参考应用接入AVSession场景介绍。
1.  在AvSessionController初始化时，通过createAVSession()创建AVSession实例并激活媒体会话，视频应用选择会话类型为video。开发者可根据应用的类型选择对应的会话。
2.  应用可以通过setAVMetadata()把会话的一些元数据信息设置给系统，从而在播控中心界面进行展示。如媒体ID（assetId）、标题（title）、播控中心显示的图片（mediaImage）、媒体时长（duration）等。
3.  当用户操作媒体会话控制方的界面时，例如点击播控中心的卡片，可以拉起此处配置的UIAbility。将封装的WantAgent通过setLaunchAbility()配置给媒体会话，更多关于WantAgent的信息请参考WantAgent。
4.  便于响应用户通过播控中心下发的播控命令，比如播放、暂停、停止、快进、快退等。同时只有设置了相关的事件回调，播控中心上对应的按钮才会亮起，否则为置灰状态。
5.  当视频状态发生改变时，需要通过setAVPlaybackState()向播控中心上报视频状态，来达到播控中心与应用的状态同步，包括播放状态（state）、播放位置（position）、当前媒体播放时长（duration）等。
视频后台播放
用户在观看视频时，会遇到退出视频应用至后台的情况。当应用退到后台时，应用进程很快就会被挂机，所以为满足视频可以在后台持续播放的能力，需要对视频应用申请长时任务，来防止应用进程挂起。同时配合AVSession播控能力，用户可以做到在后台直接与视频应用进行交互，达到更加灵活的体验效果。更多可参考Background Tasks Kit。
只有使用了媒体会话服务（AVSession）的音视频应用，才能申请长时任务实现后台播放。
接入流程和关键代码
1.  在module.json5配置文件中申请ohos.permission.KEEP_BACKGROUND_RUNNING权限和配置后台模式audioPlayback。
2.  通过获取到的UIAbility上下文和wantAgent模块下getWantAgent()方法获取WantAgent对象，使用BackgroundTasksKit的startBackgroundRunning()、stopBackgroundRunning()方法分别申请和取消后台运行任务，长时任务类型选择AUDIO_PLAYBACK，表示视频后台播放。
3.  在AVSession创建和释放时，分别申请和销毁后台长时任务。
滑动调节音量及亮度
在全屏播放视频的场景下，滑动调节音量及亮度是一项非常实用的功能，它允许用户在不离开视频播放界面的情况下，快速调整音量和亮度，展示音量及亮度大小，以获得更好的观影体验。该功能分为两部分，左侧滑动调整音量，右侧滑动调整亮度。
左侧滑动调节音量
在屏幕的左侧区域，使用AVVolumePanel组件显示系统音量面板，绑定PanGesture滑动手势事件，设置滑动方向为竖直方向，当Pan手势在移动过程中，上滑增加或者下滑减少音量，实现控制系统音量的功能。
右侧滑动调节亮度
在屏幕的右侧区域，使用Slider组件设置一个亮度面板，绑定PanGesture滑动手势事件，设置滑动方向为竖直方向，当Pan手势在移动过程中调用setWindowBrightness方法，实现上滑增加或者下滑减少亮度的功能。
音频流状态交互
多音频并发打断
当多个音频流并发播放时，如果系统不加管控，会造成多音频流混音播放，容易让用户感到嘈杂，造成不好的用户体验。为了解决这个问题，系统预设了音频打断策略，对多音频播放的并发进行管控，只有持有音频焦点的音频流才可以正常播放，避免出现多个音频流无序并发播放的现象。当音频打断事件发生时，系统会根据预设策略，对音频流做出相应的操作，并向音频流状态变化的应用发送音频打断事件。更多详情可以参考处理音频焦点事件。
通过给AVPlayer设置on('audioInterrupt')函数进行监听，当收到音频打断事件（InterruptEvent）时，应用根据其内容做出相应的处理策略。
1、如果使用了AvPlayer播放视频，audioRendererInfo会被默认设置成Movie，应用无需处理。
2、使用on('audioInterrupt')监听音频打断时，要注意使用的视频资源必须有音频流，否则无法触发音频打断事件。
音频打断状态图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151017.78746989917113667395633774722909:50001231000000:2800:D2ECD6EB8F3717AD12D155FFE58ADC45986C04855B08BD24B9C6A63C641313C3.jpg)
以下分别对四种打断场景进行说明：
先暂停后恢复场景
场景描述：视频正常播放中，当后播应用音频类型为闹钟/电话/铃声时，视频暂停播放，待后播应用音频结束后，视频恢复播放。
降低音量后恢复场景
场景描述：视频正常播放中，当后播应用音频类型为导航/TextReader控件朗读语音/语音助手类短语音时，视频会降低音量持续播放，待后播应用音频结束后，视频音量恢复。
停止后不恢复场景
场景描述：视频正常播放中，当后播应用音频类型为音乐/视频/VOIP时，当前视频停止播放，且后播应用音频结束后，视频不会恢复。
后播应用响起时，视频应用会监听到音频打断类型为InterruptForceType.INTERRUPT_FORCE（强制打断），中断提示为InterruptHint.INTERRUPT_HINT_STOP（音频结束）事件，此时系统内部会自动停止视频播放，但AVPlayer播放器状态不会自动改变，应用需要根据自身需求做出相应处理，如主动调用AVPlayer的暂停接口保证视频状态。
并发混音场景
场景描述：视频正常播放中，当后播应用音频类型为游戏/系统音效(锁屏/按键)时，视频会与后播应用并发播放。此场景为系统默认行为，应用无需适配。
关键代码：
播放设备切换
当应用使用的播放设备状态发生改变时，需要根据不同的场景及时做出相应的处理，来保证视频状态与交互体验的一致，如：视频播放状态变化、目标设备切换、视频界面的更新等。
实现方式通过对AVPlayer注册on('audioOutputDeviceChangeWithInfo')监听事件，来感知播放设备的切换，并根据流设备的变更原因，实现对应的切换规则。
1、如果没有对AVPlayer注册on('audioOutputDeviceChangeWithInfo')监听，当识别到连接的播放设备时，音频流会自动切换到目标设备上。当播放设备断开时，播放器内部不会自动暂停。
2、如果应用想实现自己的设备切换规则，可以注册on('audioOutputDeviceChangeWithInfo')监听，交由应用自行处理业务逻辑。
播放设备切换场景：
-  新设备上线时，系统会触发播放设备自动切换，无需应用主动处理。例如当手机使用扬声器播放视频时，连接到耳机后，会自动选择连接的耳机作为播放设备。 新设备来连接时，应用通过注册的audioOutputDeviceChangeWithInfo监听事件，获取到播放设备变更的原因为AudioStreamDeviceChangeReason.REASON_NEW_DEVICE_AVAILABLE，同时系统会默认切换到新设备上继续播放。如果应用对改场景有特殊需求，可在回调中自行处理业务逻辑。
-  当正在使用的播放设备断开时，应用可以根据使用场景选择暂停视频播放。例如：当断开连接的耳机时，视频暂停。 此时应用通过audioOutputDeviceChangeWithInfo监听事件，获取到设备变更原因为AudioStreamDeviceChangeReason.REASON_OLD_DEVICE_UNAVAILABLE，此处系统不会将播放器自动暂停，应用可以结合业务自行处理需求规则，如暂停视频播放。
-  用户从界面选择切换音频流输出设备时，系统会自动选择新的设备播放，audioOutputDeviceChangeWithInfo监听事件获取到的变更原因为AudioStreamDeviceChangeReason.REASON_OVERRODE，应用结合业务自行处理。本篇示例未涉及该场景，只在此处进行说明，详情可以参考响应音频流输出设备变更。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-online-video-playback-lags-practice
爬取时间: 2025-05-01 09:44:33
来源: Huawei Developer
概述
在观看在线视频时，流畅播放是至关重要的。当使用AVPlayer+XComponent渲染播放在线视频时，有时会遇到在线视频播放卡顿的问题。这种情况可能是设备网络环境较差或需要加载高码率片源，导致视频缓冲时间不足，造成在线视频播放卡顿。当视频缓冲时间不足时，设备需要不断地从服务器上下载视频数据，这会导致视频播放卡顿或者停止播放。为了解决这个问题，通过合理地设置preferredBufferDuration属性可以增加视频缓冲时间，从而确保视频播放的流畅性。
实现原理
缓冲区工作过程
对于缓冲区而言，下载线程是生产端，读取线程则是消费端。生产端是将数据写入到缓冲区中，消费端则是从缓冲区读取数据，下面将介绍下缓冲区中的几个水线概念。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151017.72963341938298731966786913227952:50001231000000:2800:1B9ADE371FA88BAADDD6349BD101237AA61847E9116AFE9AFC354473FE70A8BF.png)
如上图所示：
| 水线  | 默认值  | 说明  |
| --- | --- | --- |
| 起播水线  | 若下载速率 >= 码率场景，起播水线取值：0.3秒 * 码率 若下载速率 < 码率场景，起播水线取值：5秒 * 码率 若起播水线小于10KB，取10KB  | 在快速起播和顺滑播放间进行一个相对合理的分割。  |
| 止播水线  | 单次读取数据量，若小于5KB则取5KB  | 避免将缓冲区中的可用数据耗尽。  |
| 下载启动水线  | 480KB  | 降低线程启动频率，进行集中下载，降低cpu及指令书消耗。  |
| 下载暂停水线  | 缓冲区大小  | 当缓冲区写满时，停止下载，支持修改。  |
水线
默认值
说明
起播水线
若下载速率 >= 码率场景，起播水线取值：0.3秒 * 码率
若下载速率 < 码率场景，起播水线取值：5秒 * 码率
若起播水线小于10KB，取10KB
在快速起播和顺滑播放间进行一个相对合理的分割。
止播水线
单次读取数据量，若小于5KB则取5KB
避免将缓冲区中的可用数据耗尽。
下载启动水线
480KB
降低线程启动频率，进行集中下载，降低cpu及指令书消耗。
下载暂停水线
缓冲区大小
当缓冲区写满时，停止下载，支持修改。
开发流程
setMediaSource中的preferredBufferDuration是AVPlayer的一个属性，用于设置播放器的缓冲区大小。AVPlayer会根据preferredBufferDuration属性的值来决定缓冲区的大小。preferredBufferDuration属性的实现原理是通过设置缓冲区大小来保证播放的流畅性和稳定性，在线视频播放流程如下：
合理设置缓冲区大小
为应对弱网及高码率片源的卡顿，用户需根据资源文件的大小设置尽可能大的缓冲区。这样在卡顿时，可以保证缓冲区能够缓存起播水线的数据量，从而避免卡成幻灯片的情况使用Drawing自绘制能力提升性能出现，保证卡顿后播放的连续性。
| 默认缓冲区大小  | 用户自定义缓冲区大小  |
| --- | --- |
| 20MB  | 5MB ~ 20MB  |
默认缓冲区大小
用户自定义缓冲区大小
20MB
5MB ~ 20MB
AVPlayer支持用户自定义缓冲区大小，可通过setMediaSource接口设置PlaybackStrategy中的preferredBufferDuration。
preferredBufferDuration的单位为秒，缓冲区大小将设置为preferredBufferDuration * 1MB。
例如，preferredBufferDuration设置为20秒，缓冲区大小将设置为20MB。示例可参考视频播放。缓冲区的大小是根据资源文件的大小来设置的，缓冲区大小需要大于整个媒体文件大小。如果媒体文件大小超过用户自定义缓冲区最大值20MB，此时可将缓冲区设置为最大值20MB。
本文的测试场景为弱网条件下使用AVPlayer+XComponent渲染播放一个大小为56MB的在线视频。
| 用户自定义缓冲区大小  | 卡顿率（卡顿率=卡顿次数/播放时间）  |
| --- | --- |
| 5MB  | 65.79%  |
| 10MB  | 28.95%  |
| 20MB  | 5.26%  |
用户自定义缓冲区大小
卡顿率（卡顿率=卡顿次数/播放时间）
5MB
65.79%
10MB
28.95%
20MB
5.26%
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151017.91259355821530385753718361290281:50001231000000:2800:C63BCCB563D88C5FDEC711CFF2AD29A7AA3516B7466C015E9E3DC4A880EB6E66.png)
从实验数据可以看出：
常见问题
设置preferredBufferDuration后，刚开始视频正常播放，但当用户拖动进度条后，为什么视频卡顿暂停播放？
读取尚未缓存位置的数据，包括用户拖动进度条，及部分特殊片源在播放过程中会来回跳跃下载数据。缓冲区中读取所需的数据量可能会低于止播水线，此时会暂停播放开始缓存数据，缓存至起播水线后继续播放，该缓存时间即为卡顿时间。如果媒体文件未大于20MB，可根据媒体文件的大小来这设置preferredBufferDuration的大小。如果媒体文件的大小大于20MB，只需要设置默认值20MB就能最大程度的减少卡顿。
因为缓冲区大小所占的是应用内存，假设同时创建10个实例，视频设置的缓冲区为20MB，此时缓冲区所占的应用内存为200MB，对应用性能会有影响。如果根据媒体文件大小设置缓冲区，可以最低程度的减少设置缓冲区对应用性能带来的影响。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-audio-video-synchronization
爬取时间: 2025-05-01 09:44:47
来源: Huawei Developer
概述
精确的音视频同步是媒体播放的关键性能指标之一。通常来说，录音设备上同时录制的音频和视频在播放设备（例如手机，电视，媒体播放器）上播放的时候也需要做到同步。目前手机播放器在输出设备为蓝牙耳机时会出现严重音视频不同步现象，严重影响用户体验。
本文旨在指导第三方视频播放应用正确获取并使用音频相关信息来保证播放时的音视频同步。
如果开发者使用自研播放器引擎而非AVPlayer，也可以参考该解决方案思路实现优化。
| 帧  | 解释  |
| --- | --- |
| I帧(I-frame)  | 内部画面（intra picture）或关键帧（key frame）。I帧是一个全帧压缩的编码帧，包含了一幅完整的图像数据。  |
| P帧(P-frame)  | 前向预测编码帧（predictive-frame）。P帧不是完整的数据帧，而是只包含与前面I帧或P帧的差异数据。  |
| B帧(B-frame)  | 双向预测内插编码帧（bi-directional interpolated prediction frame）。B帧也是一个压缩帧，它同时参考前面的I帧或P帧和后面的P帧来进行编码。  |
帧
解释
I帧(I-frame)
内部画面（intra picture）或关键帧（key frame）。I帧是一个全帧压缩的编码帧，包含了一幅完整的图像数据。
P帧(P-frame)
前向预测编码帧（predictive-frame）。P帧不是完整的数据帧，而是只包含与前面I帧或P帧的差异数据。
B帧(B-frame)
双向预测内插编码帧（bi-directional interpolated prediction frame）。B帧也是一个压缩帧，它同时参考前面的I帧或P帧和后面的P帧来进行编码。
实现原理
音视频数据的最小处理单元称为帧。音频流和视频流都被分割成帧，所有帧都被标记为需要按特定的时间戳显示。音频和视频可以独立下载和解码，但具有匹配时间戳的音频和视频帧应同时呈现，以达到音视频（A/V）同步的效果。
音画同步标准
| 时间差范围  | 主观体验  |
| --- | --- |
| [-80ms,25ms]  | 无法察觉  |
| [-125ms,45ms]  | 能够察觉  |
| [-185ms,90ms]  | 无法接受  |
时间差范围
主观体验
[-80ms,25ms]
无法察觉
[-125ms,45ms]
能够察觉
[-185ms,90ms]
无法接受
以上标准基于一倍速场景。
理论上，因为音频通路存在时延，要保证播放时的音视频同步，有三种解决方案可用：
三种方案的优缺点对比如下：
| 方案名称  | 优点  | 缺点  |
| --- | --- | --- |
| 连续播放音频帧  | 用户肉眼的敏感度较弱，不易察觉视频微小的调整。视频刷新时间的调整相对便捷。  | 如果视频帧率不稳定或渲染延迟大，可能导致视频卡顿或跳帧。  |
| 使用系统时间作为参考  | 可以最大限度的保证音频和视频都不发生跳帧行为。  | 需要额外依赖系统时钟，增加了系统复杂性和维护成本。系统时钟的准确性对同步效果影响较大，如果系统时钟不准确，可能导致同步效果大打折扣。  |
| 使用视频播放作为参考  | 音频可根据视频帧进行调整，减少音频跳帧的情况。  | 音频播放可能会出现等待或加速的情况，相较于视频会对用户的影响更为严重和明显。如果视频帧率不稳定，可能导致音频同步困难。  |
方案名称
优点
缺点
连续播放音频帧
如果视频帧率不稳定或渲染延迟大，可能导致视频卡顿或跳帧。
使用系统时间作为参考
可以最大限度的保证音频和视频都不发生跳帧行为。
使用视频播放作为参考
音频可根据视频帧进行调整，减少音频跳帧的情况。
第一个方案是唯一一个具有连续音频数据流的选项，其没有对音频帧的显示时间、播放速度或持续时间进行任何调整。这些参数的任何调整都很容易被人耳注意到，并导致音频干扰故障。处理这些故障需要对音频重新采样，然而重新采样会导致音调的改变。
因此，一般的多媒体应用多使用音频播放位置作为主时间参考。以下章节主要以此解决方案进行说明（其他两个选项不在本文档的范围内）。
连续播放音帧方案示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151018.18759659033112280124999738361937:50001231000000:2800:18E10C8C7A9F1B969C5A415F8689956ED5FEB7DD818E65C097AAB6EF0A9B9A18.png)
音频和视频的管道必须同时以相同的时间戳呈现每帧数据。音频播放位置用作主时间参考，而视频管道只输出与最新渲染音频帧匹配的视频帧。对于所有可能的实现，精确计算最后一次呈现的音频时间戳是至关重要的。OH_AudioRenderer_GetTimestamp()接口用以查询音频管道各个阶段的音频时间戳和延迟信息，此信息可用于控制视频管道，使视频帧与音频帧匹配。
基于以上示意图，具体来说，在监听到视频帧的时候，首先去获取当前音频渲染位置，在获取成功的情况下计算该视频帧PTS与当前音频渲染位置的延迟时间，对延迟时间进行如下判断确定送显策略。
连续播放音频帧方案
场景描述
综合上述三种方案的优缺点对比，此处采用主流的连续播放音频帧方案。使用音频播放位置作为主时间参考，并将视频播放位置与其匹配，使音画同步指标达到用户无法察觉的[-80ms,25ms]范围。
该解决方案使用：
最终实现音画同步[-80ms,25ms]的效果。
开发步骤
1.  音频启动前，timestamp和framePosition返回结果为0。为避免出现卡顿等问题，暂不同步，视频帧直接送显。
2.  视频帧较早时，等待一段时间送显。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-deal-stride-solution
爬取时间: 2025-05-01 09:45:00
来源: Huawei Developer
概述
开发者在使用相机服务时，如果仅用于预览流展示，通常使用XComponent组件实现，如果需要获取每帧图像做二次处理（例如获取每帧图像完成二维码识别或人脸识别场景），可以通过ImageReceiver中imageArrival事件监听预览流每帧数据，解析图像内容。在解析图像内容时，如果未考虑stride，直接通过使用width*height读取图像内容去解析图像，会导致相机预览异常，从而出现相机预览花屏的现象。
当开发者获取预览流每帧图像buffer后，若发现图片内容出现花屏堆叠状，出现“相机预览花屏”现象，此时需要排查解析每帧图像，当预览流图像stride与width不一致时，需要对stride进行无效像素的去除处理。
实现原理
在计算机图形学和图像处理中，stride通常指的是在内存中存储多维数组（如图像或纹理）时，行与行之间的字节间隔，即每一行的起始地址与下一行的起始地址之间的距离，在本文中stride指的是图像的一行数据在内存中实际占用的字节数，为了内存对齐和提高读取效率的要求，通常大于图像的宽度。
stride在不同的平台底层上报的值不同，开发者需根据实际业务获取stride后做处理适配。在本文中通过预览流帧数据的返回值image.Component.rowStride获取stride。
如下图：在一个width为3，height为3，stride为4的图片上（例如定义了一个480*480分辨率的图像），实际分配内存并不是width*height即3*3（此处为定义的预览流分辨率的宽高比，即实际分配内存不是480*480），而是stride*height即4*3，这样实现了内存对齐，方便硬件处理。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151018.70222451878672622562977608326257:50001231000000:2800:8F3A892AB065AA89FAE8C0D3B0D11EF84D70B486EF4E9CBE846D31FE6DCC91E3.png)
如果开发者根据width和height数据去处理像素数据，即把0x00-0x09地址的数据当做像素去处理，就会出现解析了错误的像素数据的问题，并且使用了无效的像素0x03，0x07，会导致图片无法正常显示导致“相机花屏”现象。因此，要根据stride值处理预览数据流，去除无效的像素后送显，才能获取正确的预览流图像。
场景案例
以一种高频的用户使用场景为例，应用需要定义一个1080*1080分辨率的预览流图像，此时的stride在相关平台的返回值为1088，此时需要对stride进行处理，处理无效像素后解析出正确的像素数据，避免出现预览流花屏。
【反例】未处理stride：当开发者创建PixelMap解析buffer时，直接按照宽去读取每行数据，没有处理stride，此时若解析了无效像素数据并传给Image组件直接送显，可能会出现预览流花屏现象。
以下为部分示例代码：
【正例一】开发者使用width，height，stride三个值，处理相机预览流数据，处理stride方法一如下。
分两种情况：
【正例二】开发者使用width，height，stride三个值，处理相机预览流数据，处理stride方法二如下。
分两种情况：
效果对比
| （反例）未处理stride  | （正例）处理stride的方案一  | （正例）处理stride的方案二  |
| --- | --- | --- |
|    |    |    |
（反例）未处理stride
（正例）处理stride的方案一
（正例）处理stride的方案二
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151018.29894818556215800720472333172608:50001231000000:2800:E0EB311B8432BB4414D6265828FB4B02F64D10D0D1F238946190C1A02C688804.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151018.01445578356575716672113134457863:50001231000000:2800:0E9F8321B8344455D3D7CEE2D7C08B9D04F1BA56AC2E113F4309F71D22DBE791.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151018.24643678748959008947824881001838:50001231000000:2800:7DBDF249903460D0129C1FE406918E48927B66C6461A390601E35DE7E44C3420.gif)
常见问题
如何获取相机预览流帧数据
通过ImageReceiver中imageArrival事件监听获取底层返回的图像数据，详细请参见双路预览(ArkTS)。
如何获取预览流图像的stride的值
可以通过预览流帧数据的返回值image.Component.rowStride获取stride。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-video-thumbnail
爬取时间: 2025-05-01 09:45:16
来源: Huawei Developer
概述
视频缩略图是视频的静态预览图像，是从视频中截取的某一帧画面，经常用作视频的封面。在视频浏览、分享和管理等场景中使用可以帮助用户快速浏览和选择想要的内容，提高用户的使用体验。HarmonyOS提供了对应的模块能力，帮助开发者获取视频文件的缩略图。根据应用获取缩略图策略的不同，可以分为以下两种场景：
获取视频默认缩略图
实现原理
视频的默认缩略图一般为视频的第一帧，可以通过PhotoAsset类的getThumbnail()方法获取。这里以获取图库视频缩略图场景为例。
开发步骤
使用getAsset()和getThumbnail()方法需要申请受限开放权限'ohos.permission.READ_IMAGEVIDEO'，对于需要克隆、备份或同步图片/视频类文件的应用可申请获取该权限，并通过getAlbums()方法获取相册资源再调用这两个方法获取缩略图。或者通过picker的方式可以在不获取权限的情况下，使用这两个方法来访问用户指定的图库资源获取缩略图。本文中的示例使用的是第二种picker的方式。
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151018.24226782832056377587151614662885:50001231000000:2800:3E21E622E125F6533822FB5246DB3E2A55BD66A36A72975895D6826F2923B6B1.gif)
选取视频帧作为缩略图
实现原理
HarmonyOS提供视频缩略图获取类AVImageGenerator用于选取视频指定时间的帧作为缩略图，这里以选取图库视频缩略图场景为例。
开发步骤
```typescript
//src/main/ets/pages/Index.ets
/**
* Obtain video resources through AVImageGenerator.
*/
async imageGeneratorGetThumbnail() {
this.photoUtils.selectVideo().then(async (result: string) => {
// ...
this.fileAlbum = fileIo.openSync(result, fileIo.OpenMode.READ_ONLY);
this.avFileDescriptor = { fd: this.fileAlbum.fd };
// ...
}
).catch((error: BusinessError) => {
hilog.error(0x0000, TAG,
`Invoke imageGeneratorGetThumbnail failed!, error code: ${error.code}, message: ${error.message}`);
})
}
```
```typescript
//src/main/ets/common/utils/PhotoUtils.ets
/**
* Get video infos through video file descriptor.
* @param avFileDescriptor AVFileDescriptor of video.
* @returns the size infos of video.
*/
async getVideoData(avFileDescriptor: media.AVFileDescriptor): Promise<VideoSizeData> {
let videoSize: VideoSizeData = new VideoSizeData();
let avMetaDataExtractor: media.AVMetadataExtractor = await media.createAVMetadataExtractor();
avMetaDataExtractor.fdSrc = avFileDescriptor;
let metadata = await avMetaDataExtractor.fetchMetadata();
videoSize.photoSize.width = parseInt(metadata.videoWidth as string);
videoSize.photoSize.height = parseInt(metadata.videoHeight as string);
if (metadata.duration) {
videoSize.totalTime = parseInt(metadata.duration);
}
avMetaDataExtractor.release();
return videoSize;
}
```
```typescript
//src/main/ets/pages/Index.ets
/**
* Obtain a frame at a certain point in time of the video.
* @param time A certain point in time of the video.
*/
async fetchFrameByTime(time: number) {
this.pixelMap = await this.avImageGenerator?.fetchFrameByTime(time,
media.AVImageQueryOptions.AV_IMAGE_QUERY_CLOSEST_SYNC, this.videoSize.photoSize);
}
```
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151019.73836561832880769542223716317696:50001231000000:2800:68DF4F968A62451ABE8CF7AE91B841B6EA36470ABB97D29C6939D3EB71F85AFE.gif)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-hdrvivid
爬取时间: 2025-05-01 09:45:30
来源: Huawei Developer
概述
随着5G、光纤等网络技术的普及，终端显示能力进一步提升，“真实”、“沉浸”的超高清音视频体验时代已到来。高动态范围（High-Dynamic Range，简称HDR）作为超高清音视频产业的关键技术之一，比传统的标准动态范围（Standard Dynamic Range，简称SDR）拥有更广的色域和更高的动态范围（动态范围指的是亮度最大值和最小值的比值），为图像保留更多细节。超高清HDR加上宽色域能让视频亮度层次和色彩的呈现更真实、更自然。
HDRVivid是由华为主导开发的高动态范围视频技术标准，中文名为“菁彩影像”。它受亮度、对比度、色深、色域等因素影响，是一种提高画面亮度及对比度的画面处理技术。 其技术特点与优势为：
目前涉及到的HDR场景包括：HDR视频录制、HDR视频播放、视频转码（HDR2SDR）、HDR图片拍照等。本文旨在向开发者介绍，如何使用HarmonyOS的系统能力进行常用场景的开发：
HDRVivid视频录制
HDRVivid视频录制是一种先进的视频录制技术，它基于动态元数据对亮度、对比度和颜色进行逐个场景优化，为显示终端提供更加准确的动态映射方式。
HDRVivid视频录制的开发和主流格式视频录制的开发基本一致，差异点体现在部分参数的配置上。
HarmonyOS上开发录制视频的功能一般有两个方案：
使用Camera+AVRecorder录制
实现原理
应用通过调用AVRecorder实现视频录制时，先通过Camera接口调用相机服务，通过视频HDI捕获图像数据送显至应用，同时送至AVRecorder的录制服务，录制服务将图像数据编码后封装至文件中，实现视频录制功能。流程图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151019.15886867759125692638360680353875:50001231000000:2800:D3E296A4F510C032053D1234C978C0C71082EF4A2C74690DE61F5E9AA7C44AB9.png)
使用Camera+AVRecorder录制HDRVivid视频，与录制普通视频的区别主要在于：
开发步骤
针对以上四点不同，开发视频录制功能时，可参考以下步骤（详细开发步骤可参考HDR Vivid相机录像(ArkTS)）：
```typescript
// 创建并配置相机会话
try {
this.captureSession = this.cameraManager.createSession(camera.SceneMode.NORMAL_VIDEO) as camera.VideoSession;
} catch (error) {
// ...
}
// ...
try {
this.captureSession.beginConfig();
} catch (error) {
// ...
}
// ...
try {
await this.captureSession.commitConfig();
} catch (error) {
// ...
}
let mode: camera.VideoStabilizationMode = camera.VideoStabilizationMode.AUTO;
// 查询是否支持视频防抖
let isSupported: boolean = false;
try {
isSupported = this.captureSession.isVideoStabilizationModeSupported(mode);
Logger.info(TAG, `isVideoStabilizationModeSupported: ${JSON.stringify(isSupported)}`);
} catch (error) {
// 失败返回错误码error.code并处理
let err = error as BusinessError;
Logger.error(`The isVideoStabilizationModeSupported call failed. error code: ${err.code}`);
}
if (isSupported) {
// 设置视频防抖
this.captureSession.setVideoStabilizationMode(mode);
let activeVideoStabilizationMode = this.captureSession.getActiveVideoStabilizationMode();
Logger.info(`activeVideoStabilizationMode: ${activeVideoStabilizationMode}`);
} else {
Logger.error(`videoStabilizationMode: ${mode} is not support`);
}
// Camera Session配置颜色空间为BT2020_HLG_LIMIT
if (isSupported) {
let colorSpace: colorSpaceManager.ColorSpace = colorSpaceManager.ColorSpace.BT2020_HLG_LIMIT;
let colorSpaces: Array<colorSpaceManager.ColorSpace> = [];
try {
colorSpaces = this.captureSession.getSupportedColorSpaces();
} catch (error) {
let err = error as BusinessError;
Logger.error(`The getSupportedColorSpaces call failed. error code: ${err.code}`);
}
let isSupportedColorSpaces = colorSpaces.indexOf(colorSpace) >= 0;
if (isSupportedColorSpaces) {
Logger.info(`setColorSpace: ${colorSpace}`);
try {
this.captureSession.setColorSpace(colorSpace);
} catch (error) {
let err = error as BusinessError;
Logger.error(`The setColorSpace call failed, error code: ${err.code}`);
}
let activeColorSpace: colorSpaceManager.ColorSpace = this.captureSession.getActiveColorSpace();
Logger.info(`activeColorSpace: ${activeColorSpace}`);
} else {
Logger.error(`colorSpace: ${colorSpace} is not support`);
}
}
try {
await this.captureSession.start();
} catch (error) {
let err = error as BusinessError;
Logger.error(TAG, `captureSession start error: ${JSON.stringify(err)}`);
}
```
使用Camera+AVCodec录制
实现原理
应用通过调用AVCodec实现视频录制时，先通过Camera接口调用相机服务，通过视频HDI捕获图像数据送显至应用，同时送至AVCodec的编码模块将图像数据编码后封装至文件中，实现视频录制功能。流程图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151019.73868720068580172979113631284055:50001231000000:2800:9EC1CD3BE17E43898F5E310FC8C2983B9EA382412E364BCC03C7E43A2899E668.png)
使用Camera+AVCodec录制HDRVivid视频，与录制普通视频的区别主要在于：
开发步骤
针对以上四点不同，使用Camera+AVCodec开发HDRVivid视频录制功能时，可参考以下步骤（详细开发步骤可参考HDRVivid视频录制）：
HDRVivid视频播放
要实现HDRVivid视频播放，通常需要在视频播放流程中进行特定的处理，这包括：视频文件解析、解码器配置和渲染处理。
相对于主流格式视频播放的开发，HDRVivid视频播放的开发与其流程基本一致，只在解码格式上有所区别。下面将从解码格式上来讲解在HarmonyOS上进行视频开发的主要两种方案：
使用系统播放器AVPlayer开发
实现原理
AVPlayer提供功能完善一体化播放能力，应用只需要提供流媒体来源，不负责数据解析和解码就可达成播放效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151019.91655732691881707567389069122226:50001231000000:2800:04E60BB2915A85B8B13811974B076FA01CE49A647E2BB8DDB61AA33FB069E7D9.png)
开发步骤
使用系统播放器AVPlayer开发视频播放功能，主要开发步骤为（详细开发步骤可参考使用AVPlayer播放视频（ArkTS））：
```typescript
// 创建AVPlayer实例
public initAVPlayer() {
media.createAVPlayer().then((player: media.AVPlayer) => {
if (player !== null) {
this.avPlayer = player;
// this.curSource.video为本地视频路径，this.curSource.url为网络视频路径
if (this.curSource.video) {
let fileDescriptor = this.context?.resourceManager.getRawFdSync(this.curSource.video);
if (fileDescriptor) {
let avFileDescriptor: media.AVFileDescriptor =
{ fd: fileDescriptor.fd, offset: fileDescriptor.offset, length: fileDescriptor.length };
this.avPlayer.fdSrc = avFileDescriptor;
}
} else {
this.avPlayer.url = this.curSource.url;
}
// ...
} else {
Logger.error(TAG, 'createAVPlayer fail');
}
}).catch((error: BusinessError) => {
Logger.error(TAG, `AVPlayer catchCallback, error message:${error.message}`);
});
}
```
```typescript
private setStateChangeCallback(avPlayer: media.AVPlayer) {
avPlayer.on('stateChange', async (state: string) => {
switch (state) {
// ...
case 'initialized':
Logger.info(TAG, 'AVPlayer state initialized called.' + ` this.curIndex:${this.curIndex}`);
avPlayer.surfaceId = this.surfaceID;
avPlayer.prepare();
break;
case 'prepared':
// ...
break;
// ...
}
})
}
```
```typescript
public playVideo() {
// ...
}
public pauseVideo() {
// ...
}
public stopVideo() {
// ...
}
public seek(seekTime: number) {
// ...
}
```
使用系统解码器AVCodec开发
实现原理
AVCodec模块的Native API接口，可以完成视频解码功能，即将媒体数据在系统侧解码成YUV文件或送显至应用上。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151019.50673092491365565584402719228319:50001231000000:2800:4EF79E13E80CFC0019C926709FB65B5187471B30DC0642D0CFBA6D7F0117910B.png)
开发步骤
使用系统解码器AVCodec开发HDRVivid视频播放功能，主要开发步骤为（详细开发步骤可参考HDR Vivid视频播放）：
HDRVivid视频转码成SDR视频
实现原理
将HDRVivid视频转码成SDR视频是一个涉及多个技术要点的复杂过程。通过合理的转码处理，可以确保视频内容在不同设备上都能呈现出更好的效果，不仅优化了视频的播放体验，还可以满足更广泛受众的需求，提高市场影响力。
开发步骤
HarmonyOS提供了Native侧的VideoProcessing函数，可以将HDRVivid视频转码成SDR视频，主要的开发步骤为（详细开发步骤可参考视频色彩空间转换）：

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-image_get_and_save
爬取时间: 2025-05-01 09:45:45
来源: Huawei Developer
概述
应用在业务流程中常常有获取设备图片用于编辑、分享等的需求，可能还需要读取图片信息、将图像保存到本地等。本文介绍了HarmonyOS上几种常见的获取图片的方式、获取后读取图片信息、以及将图片保存在本地的操作，可供开发者学习和参考。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151019.37745165886088832527906117118054:50001231000000:2800:C73B509B880FF754D3347754F0F34CD1F4827B8AA2507B294AE1B8A4DE70AA02.gif)
获取图片
在HarmonyOS上，从智能终端获取图片的方式主要有两种：
以下针对两种场景分别进行介绍。
从相册获取图片
HarmonyOS提供了两种便捷方法来从相册中获取图片，一种是基于PhotoPickerComponent（下文统称PhotoPicker组件）来在应用中直接访问相册中的图片或视频，另一种是使用PhotoViewPicker接口拉起系统相册后选择图片或视频文件。
实现原理
PhotoPicker组件是一个ArkUI组件，应用在页面中嵌入该组件，可以直接展示系统相册中的图片或视频文件，无需额外申请权限。用户可以直接在组件中选择想要的图片或视频文件。PhotoViewPicker是图库选择器，应用使用此接口可以跳转到系统相册选择一个或多个图片/视频，然后将所选的图片/视频以uris的形式传递回应用。
因此，如果开发者接受在应用页面中直接显示系统相册，则推荐使用PhotoPicker组件；如果开发者不希望系统相册在应用页面中占据空间，则推荐使用PhotoViewPicker跳转到系统相册应用里去选择图片或视频。
开发步骤
基于PhotoPicker组件获取图片的开发步骤可以参考指南使用PhotoPicker组件访问图片/视频，使用PhotoViewPicker拉起系统相册获取图片的开发步骤可以参考指南使用Picker选择媒体库资源。
拍照获取图片
除了从相册获取图片外，应用还可以通过拍照来获取图片。对于拍照这一行为，HarmonyOS上提供了系统相机和自定义相机两种选项。应用可以通过拉起系统相机拍照并获得一张照片，也可以自行实现自定义相机来拍照获取照片
实现原理
CameraPicker是系统提供的相机选择器，可以拉起系统相机为应用提供拍照或录像功能，结果以uri的形式返回给应用。系统还提供了一整套相机服务接口（包含ArkTS API和C API）给开发者用于开发适合自身需求的自定义相机功能，对自定义相机开发有诉求的开发者可以参考Camera Kit，本文不再赘述。
开发步骤
使用CameraPicker的参考代码如下：
读取图片信息
实现原理
HarmonyOS提供了ImageSource图片源类用于获取图片相关信息，既可以读取图片大小、像素格式等基本信息，也可以读取EXIF信息，如曝光时间、光圈值等。
开发步骤
首先基于前文获得的图片uri，创建一个ImageSource实例，然后调用相关方法即可读取图片信息。
读取基本信息：
读取EXIF信息：
保存图片
对于已经编辑处理后的PixelMap图像，如果想要保存到本地，可以选择保存到文件目录或者是系统相册中。
保存到文件目录
实现原理
ImagePacker是HarmonyOS提供的图片打包器类，可以用于图片压缩和打包。在创建ImagePacker实例后，可以调用packToFile方法将PixelMap对象编码打包进文件，保存的路径可以指定具有写权限的文件目录，具体可以参考指南使用ImagePacker完成图片编码。
保存到系统相册
实现原理
要将PixelMap保存到系统相册，可以通过先将pixelmap保存到文件目录的方法，获得图片uri后，使用安全控件或者弹窗授权的方式保存到系统相册，具体可参考保存媒体库资源开发指南。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-graphic-drawing-practices
爬取时间: 2025-05-01 09:45:58
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-drawing-capability-improve-performance
爬取时间: 2025-05-01 09:46:11
来源: Huawei Developer
概述
Canvas画布组件是用来显示自绘内容的组件，它具有保留历史绘制内容、增量绘制的特点。Canvas有CanvasRenderingContext2D/OffscreenCanvasRenderingContext2D和DrawingRenderingContext两套API，应用使用两套绘制API绘制的内容都可以在绑定的Canvas组件上显示。其中CanvasRenderingContext2D按照W3C标准封装了Native Drawing接口，可以方便快速复用Web应用的绘制逻辑，因此非常适用于Web应用和游戏、快速原型设计、数据可视化、在线绘图板、教学工具或创意应用等场景。
为了遵循W3C标准，实现过程中进行了多层的封装，涉及一些数据结构的转换，不如原生API那样接近硬件，因此对于性能要求比较高绘制比较复杂或者硬件依赖性比较强的场景如高性能游戏开发、专业图形处理软件、桌面或移动应用等，使用Canvas CanvasRenderingContext2D绘制会存在一定的卡顿、掉帧等性能问题，此时可以直接使用Native Drawing接口自绘制替代Canvas CanvasRenderingContext2D绘制来提升绘制性能。
| 方案  | 适用场景  | 特点  |
| --- | --- | --- |
| 使用Canvas CanvasRenderingContext2D  | Web应用和游戏、快速原型设计、数据可视化、在线绘图板、教学工具、创意应用  | 场景简单、跨平台、快捷灵活、兼容性强、开发维护成本低、性能要求低。  |
| 使用Native Drawing  | 高性能游戏开发、专业图形处理软件、桌面或移动应用开发  | 场景复杂、资源管理精细、硬件依赖强、与平台深度集成、定制化、性能要求高。  |
方案
适用场景
特点
使用Canvas CanvasRenderingContext2D
Web应用和游戏、快速原型设计、数据可视化、在线绘图板、教学工具、创意应用
场景简单、跨平台、快捷灵活、兼容性强、开发维护成本低、性能要求低。
使用Native Drawing
高性能游戏开发、专业图形处理软件、桌面或移动应用开发
场景复杂、资源管理精细、硬件依赖强、与平台深度集成、定制化、性能要求高。
原理机制
由于Canvas CanvasRenderingContext2D绘制本质上是对Native Drawing接口的封装，相对于直接使用Native Drawing接口，Canvas CanvasRenderingContext2D在实现过程中进行了多层的封装，涉及一些数据结构的转换。如果图片绘制比较复杂，执行的绘制指令可能会成倍数的增长，进而绘制性能下降的更加严重，导致卡顿、掉帧等问题。下面以实现在背景图上绘制1000个透明空心圆的玻璃效果来对比两者的性能差异。
场景示例
下图是一个绘制1000个透明空心圆与背景图融合的绘制场景，下面分别使用Canvas CanvasRenderingContext2D和Native侧的Drawing来实现该场景，并分析两者的性能差异。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151006.14623113349808191570175584445278:50001231000000:2800:18A3F00EBB0FEFA15B11DEB387B16221C560261E25091F4B1C51CC9FC1A6658D.gif)
使用Canvas CanvasRenderingContext2D绘制
Canvas CanvasRenderingContext2D使用globalCompositeOperation属性来实现各种图层混合模式，此处将该属性的值设置为destination-out来实现透明空心圆。具体实现步骤如下：
1.  使用Canvas CanvasRenderingContext2D绘制的trace图，可以看到绘制1000个圆圈耗时14.9毫秒。
```typescript
// entry\src\main\ets\view\GlassCoverView.ets
import { hiTraceMeter } from '@kit.PerformanceAnalysisKit';
/**
* 玻璃蒙层效果
*/
@Preview
@Component
export default struct GlassCoverView {
@Prop @Watch('onDraw') pointsToDraw: number[][] = [];
private settings = new RenderingContextSettings(true);
private renderContext = new CanvasRenderingContext2D(this.settings);
private viewWidth: number = 0;
private viewHeight: number = 0;
build() {
Stack() {
Canvas(this.renderContext)
.width('100%')
.height('100%')
.onAreaChange((_: Area, newValue: Area) => {
this.handleAreaChange(newValue);
})
}
.height('100%')
.width('100%')
}
private handleAreaChange(area: Area): void {
this.viewWidth = parseInt(area.width.toString());
this.viewHeight = parseInt(area.height.toString());
this.onDraw();
}
private onDraw(): void {
const canvas = this.renderContext;
canvas.reset();
if (canvas === undefined) {
return;
}
// 空心透明圆圈
hiTraceMeter.startTrace('slow', 1);
console.info('debug: slow start');
// 保存绘图上下文
canvas.save();
// 清空给定矩形内的指定像素
canvas.clearRect(0, 0, this.viewWidth, this.viewHeight);
// 指定绘制的填充色
canvas.fillStyle = '#77CCCCCC';
// 填充一个矩形
canvas.fillRect(0, 0, this.viewWidth, this.viewHeight);
// 绘制空心圆圈
canvas.globalCompositeOperation = 'destination-out';
canvas.fillStyle = '#CCCCCC';
this.pointsToDraw.forEach((xy: number[]) => {
this.drawOneCell(canvas, xy[0] * this.viewWidth, xy[1] * this.viewHeight, px2vp(15));
})
canvas.fill();
// 对保存的绘图上下文进行恢复
canvas.restore();
console.info('debug: slow end');
hiTraceMeter.finishTrace('slow', 1);
}
/**
* 根据指定的位置及宽度绘制圆
*/
private drawOneCell(canvas: CanvasRenderer, x: number, y: number, width: number): void {
canvas.moveTo(x + width, y);
canvas.arc(x, y, width, 0, Math.PI * 2);
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151006.24763206093595878404438511906749:50001231000000:2800:BE0406322D32D16E23D370C57CF819C7CAB2761F212E50D969064DBEF2C57FC7.png)
使用Native侧Drawing绘制
Native Drawing主要使用分层接口OH_Drawing_CanvasSaveLayer和融合接口OH_Drawing_BrushSetBlendMode来实现多图融合效果。通过在前端创建一个自绘制节点RenderNode，并将图形绘制上下文及背景图参数通过Native侧暴露的接口传入，由Native使用相应Drawing接口进行绘制。具体实现步骤如下：
1.  新建一个自绘制渲染节点，并定义一个NodeController，对该节点进行管理。
2.  使用Native侧Drawing绘制trace图，可以看到绘制1000个圆圈耗时2.4毫秒，相较于Canvas CanvasRenderingContext2D绘制有较大的性能提升。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151006.03285149618493534318461463169308:50001231000000:2800:32B15D64529AAC6AAD4E2E281C64F552F3082D1645C6D662470741803D4E77FF.png)
效果对比
| 方案  | 圆圈数量  | 耗时  |
| --- | --- | --- |
| Canvas CanvasRenderingContext2D 画透明圈  | 1000  | 14.9毫秒  |
| Native Drawing画透明圈  | 1000  | 2.4毫秒  |
方案
圆圈数量
耗时
Canvas CanvasRenderingContext2D 画透明圈
1000
14.9毫秒
Native Drawing画透明圈
1000
2.4毫秒
通过上述对比可以发现，在实现较大数量透明空心圆这样的复杂的绘制场景，相比于Canvas CanvasRenderingContext2D，使用NativeDrawing可以得到明显的性能提升。以上只是实现透明空心圆融合场景，针对实心圆及其他融合场景（如globalCompositeOperation属性的其他值），由于实现机制的不同，绘制指令数量也存在差异，从而性能数据会存在一些差异。实际应用中，可以根据实际情况，在对性能要求不高的情况采用Canvas CanvasRenderingContext2D，如果对性能要求比较高，建议使用NativeDrawing进行绘制。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-add-watermark
爬取时间: 2025-05-01 09:46:25
来源: Huawei Developer
概述
在软件开发中，水印是一种在应用页面、图片或文档中嵌入的标记，它通常采用文字或图案的形式展现。水印通常有以下用途：
本文通过图文与代码结合的方式，对以下几种常见的水印添加场景进行讲解，旨在让开发者理解水印添加的基本原理以及掌握开发的流程与细节。
页面上添加水印
场景描述
某个页面背景上添加水印文字，实现效果图如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151007.74044876558144101900252106325254:50001231000000:2800:3458179CCB94FD0050D0A19B9A14C2420D5CEC3B019F1475054BA5244DEF083E.png)
实现原理
关键技术
Canvas提供画布组件，用于自定义绘制图形。使用CanvasRenderingContext2D对象在Canvas组件上进行绘制，其中fillText()方法用于绘制文本，drawImage()方法用于图像绘制。
开发流程
开发步骤
1.  最终通过CanvasRenderingContext2D.fillText()方法进行水印文字的绘制。
```typescript
// entry/src/main/ets/component/Watermark.ets
@Component
export struct Watermark {
private settings: RenderingContextSettings = new RenderingContextSettings(true);
private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);
// ...
build() {
Canvas(this.context)
.width('100%')
.height('100%')
.hitTestBehavior(HitTestMode.Transparent)
.onReady(() => this.draw())
}
}
```
```typescript
// entry/src/main/ets/component/Watermark.ets
@Component
export struct Watermark {
private settings: RenderingContextSettings = new RenderingContextSettings(true);
private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);
// ...
build() {
Canvas(this.context)
.width('100%')
.height('100%')
.hitTestBehavior(HitTestMode.Transparent)
.onReady(() => this.draw())
}
}
```
2.  最终通过CanvasRenderingContext2D.fillText()方法进行水印文字的绘制。
3.
4.
5.  方式一：使用Stack将水印组件叠加在UI组件上层。 方式二：设置UI组件的overlay属性，使水印组件作为UI组件的浮层显示。
```typescript
// entry/src/main/ets/component/Watermark.ets
@Component
export struct Watermark {
private settings: RenderingContextSettings = new RenderingContextSettings(true);
private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);
// ...
build() {
Canvas(this.context)
.width('100%')
.height('100%')
.hitTestBehavior(HitTestMode.Transparent)
.onReady(() => this.draw())
}
}
```
1.  最终通过CanvasRenderingContext2D.fillText()方法进行水印文字的绘制。
2.
3.
-
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151007.49043761373773655374729539812927:50001231000000:2800:EEFCD2E2614B3DAD7139A015C74A48CC710D9745289A0E14FCBBCE4B372007A7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151007.58135134321986653664415027895136:50001231000000:2800:6F43949C3A2F24038DC7D398CAE3EE09D4C6594D26CBA01859CF5E53F4AA9F9B.png)
如果需要多个页面或应用全局添加水印，可将上述方式二中的watermarkBuilder封装到一个单独的文件，export出一个全局的watermarkBuilder。在需要添加水印页面的根节点上添加.overlay绑定watermarkBuilder即可。
图片上添加水印
场景描述
保存的图片、拍照生成的图片等场景，需要添加水印。实现效果图如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151007.87001326402386113489951315687462:50001231000000:2800:84DA71B49E00A49BB0C5F227EB189E6A8C2DC54F26EA2B351E176CECBC5BC866.png)
实现原理
关键技术
OffscreenCanvas提供离屏画布，与Canvas使用场景区别在于是否需要将画布渲染在屏幕上。使用OffscreenCanvasRenderingContext2D在OffscreenCanvas上进行离屏绘制，其中fillText()方法用于绘制文本，drawImage()方法用于图像绘制。
开发流程
开发步骤
PDF文档添加水印
场景描述
在PDF预览页面点击添加水印按钮，生成带水印的PDF文档，并显示在预览页面中。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151007.63037339617470150896524207396754:50001231000000:2800:B2CFB69DA1BA281802CE0F669CE64364201F5EA9283D02B2EB11A21F38EC101D.png)
实现原理
关键技术
pdfService模块为应用提供统一管理PDF页面的页眉页脚、水印、背景、批注、书签的能力。pdfService.TextWatermarkInfo类和pdfService.ImageWatermarkInfo分别提供创建文本水印和图片水印的能力。pdfService.PdfDocument类提供与文档相关能力，其中addWatermark()方法用于添加水印。
开发流程
开发步骤
```typescript
// entry/src/main/ets/pages/WatermarkPdfPage.ets
async showInPdfView(filePath: string) {
this.hasWatermark = true;
this.controller.releaseDocument();
await this.controller.loadDocument(filePath);
this.controller.setPageFit(pdfService.PageFit.FIT_WIDTH);
}
```
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-image-processing-practices
爬取时间: 2025-05-01 09:46:38
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-fuzzy-scene-performance-optimization
爬取时间: 2025-05-01 09:46:51
来源: Huawei Developer
概述
模糊效果是一种常见的图像处理技术，它通过减弱图像细节，去除干扰，使焦点更加鲜明。如下图所示，模糊效果不仅能增强界面空间感，还能清晰区分元素层级，是图像处理领域中一项常用且重要的技术手段。但当这一效果融入动态变化，便催生了模糊动效。模糊动效被广泛应用于页面之间的转场、图像元素的缩放等需要突出内容或改变用户关注点的场景中。
由于模糊算法需要对组件进行精细的像素级处理，当组件需要实时刷新时，这要求在极短的单个视频帧周期内完成模糊化处理。若组件同时还承担着繁重的动画渲染任务，则会进一步加剧计算资源的消耗，容易导致模糊效果处理时间不足，无法按时完成模糊动效，最终引发卡顿、丢帧等不良现象。
因此，随着应用的广泛普及，模糊动效的性能优化愈发显得至关重要。鉴于系统为开发者提供的静态模糊和动态模糊两种动效能力，本文将对比静态与动态模糊在“转场结合图片模糊”的应用场景下的性能差异，建议开发者在组件背景和内容无需实时更新的场景中，推荐使用静态模糊，可以减少应用卡顿与丢帧，提升用户体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151007.87152907393182450968113700349084:50001231000000:2800:F729E76C8575595CB95AA921160C41445793A24ABED91EE00905A27FB756AB58.png)
使用场景
在介绍静态模糊和动态模糊之前，需要说明动态模糊和静态模糊的区别在于要模糊的内容是不是动态更新的，如对视频做模糊就是动态模糊，对图片做模糊就是静态模糊。
场景示例
下面将在常见的“转场结合图片模糊”的应用场景下（全屏模态转场拉起一个图片设置模糊的模态页面)，分别采用动态模糊和静态模糊，进行性能分析对比。需要说明，由于静态模糊和动态模糊底层采用的算法不同，动态模糊blur和静态模糊blur设置的模糊半径数值并不等效。为了从效果一致性的维度来更准确的比较两者的性能差异，这里将动态模糊和静态模糊场景的模糊半径的数值尽可能的调整到类似的模糊效果来进行对比。动态模糊blur设置13，静态模糊blur设置3的图片模糊效果较为接近，作为本例中效果一致性较为近似的等效条件。
下面是使用动态模糊对图片进行模糊处理的场景示例。通过直接对Image组件设置blur，为Image添加模糊效果。
```typescript
import { window } from '@kit.ArkUI';
@Component
export struct MotionBlur {
@Consume('navPathStack') navPathStack: NavPathStack;
@State isShowMotionBlur: boolean = false;
@State bottomSafeHeight: number = 0; // bottom navigation bar height
aboutToAppear() {
window.getLastWindow(getContext(this), (err, windowBar) => {
if (err.code) {
return;
}
// get the height of the bottom navigation bar
this.bottomSafeHeight =
px2vp(windowBar.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR).bottomRect.height);
windowBar.setWindowLayoutFullScreen(true);
});
}
// modal page with dynamically blurred image settings
@Builder
motionBlurBuilder() {
Stack({ alignContent: Alignment.Bottom }) {
Image($r('app.media.test'))
.width('100%')
.height('100%')
.objectFit(ImageFit.Fill)
.blur(13) // add motion blur effect
Button('close')
.width('90%')
.height(40)
.margin({ bottom: this.bottomSafeHeight + 16 })
.onClick(() => {
this.isShowMotionBlur = false;
})
}
.width('100%')
.height('100%')
}
build() {
NavDestination() {
Column() {
Button('motion blur')
.width('90%')
.height(40)
.onClick(() => {
this.isShowMotionBlur = true;
})
.bindContentCover(this.isShowMotionBlur, this.motionBlurBuilder(), {
modalTransition: ModalTransition.DEFAULT
})
}
.padding({ bottom: this.bottomSafeHeight + 16 })
.width('100%')
.height('100%')
.justifyContent(FlexAlign.End)
}
.hideTitleBar(true)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151007.37310748544811410853549992084340:50001231000000:2800:EC07B8D208B31A3AF784DD86724726D62282694C91F7C2220C636B3ECFCB1C88.gif)
下面是使用静态模糊对图片进行模糊处理的场景示例。主要步骤如下：
```typescript
import { image } from '@kit.ImageKit';
import { effectKit } from '@kit.ArkGraphics2D';
import { window } from '@kit.ArkUI';
@Component
export struct StaticBlur {
@Consume('navPathStack') navPathStack: NavPathStack;
@State isShowStaticBlur: boolean = false;
@State pixelMap: image.PixelMap | undefined = undefined;
@State imgSource: image.ImageSource | undefined = undefined;
@State bottomSafeHeight: number = 0; // bottom navigation bar height
aboutToAppear() {
window.getLastWindow(getContext(this), (err, windowBar) => {
if (err.code) {
return;
}
// get the height of the bottom navigation bar
this.bottomSafeHeight =
px2vp(windowBar.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR).bottomRect.height);
windowBar.setWindowLayoutFullScreen(true);
});
}
async staticBlur() {
let context = getContext(this);
let resourceMgr = context.resourceManager; // retrieve the resourceManager object
const fileData = await resourceMgr.getRawFileContent('test.png'); // retrieve images from the rawfile directory
let buffer: ArrayBuffer = fileData.buffer.slice(0); // create an ArrayBuffer instance
this.imgSource = image.createImageSource(buffer); // create an image source instance
// create attributes for pixels
let opts: image.InitializationOptions = {
editable: true, // is it editable
pixelFormat: 3, // pixel format. 3 represents RGBA_8888
size: {
// create image size
height: 4,
width: 6
}
};
// create PixelMap
await this.imgSource.createPixelMap(opts).then((pixelMap: image.PixelMap) => {
const blurRadius = 3;
let headFilter = effectKit.createEffect(pixelMap); // create Filter Instance
if (headFilter !== null) {
headFilter.blur(blurRadius); // set static blur. Add the blur effect to the effect list
// retrieve the image of the source image with the added linked list effect PixelMap
headFilter.getEffectPixelMap().then((pixelMap: image.PixelMap) => {
this.pixelMap = pixelMap;
});
}
})
}
@Builder
staticBlurBuilder() {
Stack({ alignContent: Alignment.Bottom }) {
Image(this.pixelMap)
.width('100%')
.height('100%')
.objectFit(ImageFit.Fill)
Button('close')
.width('90%')
.height(40)
.margin({ bottom: this.bottomSafeHeight + 16 })
.onClick(() => {
this.isShowStaticBlur = false;
})
}
.width('100%')
.height('100%')
}
build() {
NavDestination() {
Column() {
Button('static blur')
.width('90%')
.height(40)
.onClick(() => {
this.isShowStaticBlur = true;
// set static blur
this.staticBlur();
})
.bindContentCover(this.isShowStaticBlur, this.staticBlurBuilder(), {
modalTransition: ModalTransition.DEFAULT
})
}
.padding({ bottom: this.bottomSafeHeight + 16 })
.width('100%')
.height('100%')
.justifyContent(FlexAlign.End)
}
.hideTitleBar(true)
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151008.85289899848881886902195545201990:50001231000000:2800:F9CA3C0836361384B3384EBBD4D045B95EEED140709838E631FDD16C608703B6.gif)
效果对比
下面使用DevEco Studio内置的Profiler中的帧率分析工具Frame抓取点击按钮触发转场过程的trace来分析静态模糊和动态模糊场景下的性能差异。需要说明，由于场景示例通过点击按钮触发转场，所以可以通过User Events（用户输入事件）的Click标签定位到转场过程的起点为Click标签结束位置。转场过程的终点为连续的RenderFrame（执行GPU绘制）标签不再连续的位置。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151008.88952437011828740307214213524116:50001231000000:2800:443874A4FF81FEA7C2D4FA48F208802BD501CBBF415E246A22119B6E164207C0.png)
如上图所示，通过RenderFrame（执行GPU绘制）标签可以看出，动态模糊转场平均渲染耗时为6.113ms。同时从Present Fence（图形上屏信号）标签可以看出动态模糊转场平均帧率为108.0fps。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151008.00766495398734342429493793521602:50001231000000:2800:AF406907A906690F3C9C8346AD5871ACC5EC8F08D157802CE21620D12F05DA82.png)
如上图所示，通过RenderFrame标签可以看出，静态模糊转场平均渲染耗时为3.357ms。同时从Present Fence标签可以看出静态模糊转场平均帧率为119.9fps。和动态模糊转场相比平均渲染耗时减少了约45%（性能耗时数据因应用场景、设备型号版本而异，以实测为准）。
由此可见，在模糊效果类似的条件下，静态模糊的性能要优于动态模糊。这源于底层实现机制的差异：静态模糊只需完成一次性的模糊处理，有效减轻了实时渲染的负担；而动态模糊则需要对每一帧进行连续的模糊计算，尽管在理想情况下能够营造出更为平滑和连贯的视觉过渡效果，但同时也显著增加了渲染的复杂度和资源消耗，若页面过于复杂，反而可能导致卡顿或丢帧现象的发生。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-gpu-acceleration-practices
爬取时间: 2025-05-01 09:47:04
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-maleoon-gpu-best-practices
爬取时间: 2025-05-01 09:47:18
来源: Huawei Developer
概述
本文档主要指导开发者如何在马良（Maleoon）GPU上达到最佳的性能表现，只针对Maleoon GPU的优化实践，帮助开发者高效完成渲染任务，如果想要达成该目标，首先需要通过Graphics Profiler等GPU分析工具，找到当前的能效瓶颈点，并遵循以下两个基本优化原则进行性能调优。本文所有优化建议，都将围绕这两个基本优化原则展开。
图形渲染的基本流程如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151008.27555334186203484966137680152186:50001231000000:2800:910039E34A90142EEAB48C571BDA372A36A8E2C71E05EAAA31182FAC4AFE0769.jpg)
本文档主要适用于以下开发者：
熟悉图形标准API（Vulkan或OpenGL ES）、了解shader编码，有一定GPU性能优化基础。
CPU优化
Memory
仅适用于Vulkan。
vkAllocateMemory为了避免分配的内存没有真正被渲染线程使用，造成内存浪费，采用了延迟分配（protected memory除外）的处理。在调用vkBindImageMemory || vkBindBufferMemory || vkMapMemory（如果内存支持VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT属性）时会真正分配内存，但是需要在此之前调用vkAllocateMemory分配device memory对象。
【推荐】
根据资源需求，选择最为匹配的内存类型进行内存分配，相同类型的memory按照用户实际需求一次分配大块size用于不同类型的资源（比如index buffer、vertex buffer及uniform buffer），可以提升内存申请的效率。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151008.67894099714502502256453737979391:50001231000000:2800:6EE098D0C98F267773FE165DF7EDAF21B93E58312CC5C0F21169A3C905F78B77.jpg)
【不推荐】
频繁使用vkAllocateMemory。设备内存申请次数支持的最大数量可以通过maxMemoryAllocationCount limits属性获取。
2. Device Memory访问
仅适用于Vulkan。
按照spec描述的内存类型范围支持4种类型：
对于不同类型的memory资源，有不同的使用方法：
-  以上这两个操作对性能都有一定的消耗。
【推荐】
【不推荐】
从CPU non-cache的内存中频繁回读数据，会影响性能。
Pipeline
仅适用于Vulkan。
Pipeline是整个渲染过程的状态集合，包括可编程的shader和不可编程的fixed function state，其参数配置影响整个渲染过程的执行效率。
1. Shader Stage
【推荐】
【不推荐】
2. Fixed State
【推荐】
【不推荐】
使能depth test时，开启alpha to coverage。
【影响】
使能multisample，消耗多倍GPU运行资源，降低执行效率。
Shader编译
仅适用于OpenGL ES。
Shader的首次编译（glCompileShader，glLinkProgram）耗时长，若在应用运行时进行实时编译，容易引起卡顿和丢帧，影响用户体验。
【推荐】
建议将Shader编译提前至应用启动时进行。
【不推荐】
在应用运行时实时编译Shader。
Command Buffer
Command buffer usage flags会影响command buffer的执行性能。当使用了SIMULTANEOUS_USE_BIT时，会降低command buffer的执行性能。如果在renderpass内使用secondary command buffer，flags不会有影响。
【推荐】
使用ONE_TIME_SUBMIT_BIT flag创建Command Buffer。
【不推荐】
除了用在renderpass内的secondary command buffer，其他类型的command buffer使用SIMULTANEOUS_USE_BIT。
Draw Call Batching
游戏下发的draw call数量越多，带来的CPU开销越多，整体的性能越差，建议合并draw call来降低CPU侧的开销。
【推荐】
一些典型的Draw call Batching场景：
-  所使用的vertex buffers或者texture等资源变化，这些draw可以通过合并vertex buffer或使用texture arrays等方式来合并。
-  通常绘制石头、树、灌木丛等情况，游戏会使用多个相同几何形状的instance去绘制，这种情况建议使用instance draw来完成。
【不推荐】
GPU优化
Vertex shading
1. 精度
为了规避Vertex shader计算位置信息的偏差导致后续shader stage误差放大，Maleoon GPU上vertex shader精度统一按照highp实现。
【推荐】
建议使用highp设置。
2. InstanceID
InstanceID经常会参与uniform buffer索引值的计算，此种情况下，Maleoon GPU会根据是否能有效减小load mem的次数从而开启Single InstanceID优化。此优化可以保证每组任务运行时InstanceID一致，从而每组任务load mem只用执行first thread一次load即可拿到整组对应数据。进一步，如果此shader所有uniform不超过1024 bytes大小，此uniform buffer可以完全放在constant register里面，即可通过Maleoon GPU特有的relative constant register代替此load mem操作，性能最优。
【推荐】
【示例】
原始shader：
推荐shader：
3. 顶点排布
Maleoon GPU是Tile-Based架构的GPU，对于Tile-Based架构的GPU，有一个单独的pass（binning pass）仅用于计算顶点着色器的顶点位置。因此，如果输入的顶点位置相关属性与所有其他属性存储在同一个buffer中，则binning pass获取vertex shader输入时，由于memory的连续读取粒度较大，将会导致实际读取到较多对该shader无效的输入数据，内存带宽将会增加很多。
【推荐】
将顶点相关的属性存储在独立buffer中。
Per-Fragment Test
Overdraw
Overdraw作为影响GPU性能的核心问题之一，开发者可以对于不透明的primitive进行排序，让后面的primitive可以被剔除，GPU也在硬件层次上支持不依赖primitive排序的剔除方案。
Maleoon GPU内部有一套针对Depth Test的硬件优化，主要功能是对传统图形管线Depth Test的补充优化，目的是在更早期阶段，以较粗的粒度区块，提前剔除掉一些无效的绘制，从而更好的减少后级管线的开销。
Renderpass整体的CompareOp是以第一次满足“可进行深度剔除”时的Op为主要方向，例如，一段Renderpass有3个draw，它们的Depth Test通过条件分别为less (不满足剔除条件) 、 greater (满足剔除约束) 、 greater (不满足剔除约束)，则该段Renderpass以greater为主要方向进行深度剃除。
【推荐】
【不推荐】
Fragment Shading
1. Renderpass
1.1 基本配置
Vulkan
Vulkan API明确定义了每个attachment在渲染开始和结束时行为，比如API接口中的loadOp定义了GPU如何在渲染开始时初始化片上内存，storeOp定义了渲染结束时是否需要写回主内存。
【推荐】
【不推荐】
OpenGL ES
OpenGL ES并没有明确的API来定义render pass的开始和结束，而是由GPU驱动根据framebuffer的绑定调用来推断的。
一个framebuffer的render pass通常开始于该framebuffer的target被绑定为GL_DRAW_FRAMEBUFFER，结束于换绑另一个framebuffer为GL_DRAW_FRAMEBUFFER。
【推荐】
【不推荐】
-  每次FBO切换GPU都需要完成上下文切换从而带来开销。通常开发者都注意不会频繁做不必要的FBO切换，然而有一些特殊场景比较容易忽略。 例如，用户先clear FBO A，然后在另一个FBO B上开始一个新的render pass，最后再回到FBO A上开始渲染。这样第一个clear操作将开始一个单独包含clear操作的render pass，最终实际上有3个render pass被执行，且第3个渲染过程将有额外的回读操作。如果将第一个clear操作往后移动到真正相关的FBO渲染之前，将仅生成2个render pass，并且不会出现额外的回读操作。
1.2 Multisample
对于MSAA的大多数场景，multisample attachment一般只需要保留在GPU内部的片上内存中，无需写回到主内存中，只需要解析为singlesample attachment，然后将singlesample attachment写回到主内存，即multisample attachment的额外带宽永远不会写回到主内存，可以提高效率。
Vulkan
【推荐】
【不推荐】
OpenGL ES
【推荐】
使用GL_EXT_multisampled_render_to_texture扩展，实现将GPU片上multisampled数据resolve后直接写回到一个非multisampled纹理中。
【不推荐】
先将multisampled数据写回内存中的multisampled纹理中，然后再通过调用glBlitFramebuffer来实现resolve。
2. Texture Prefetch
Texture Prefetch是Maleoon GPU上一种资源预读取的加速技术。通过在shader执行前，对采样操作进行预读取，可以加速shader执行。
【推荐】
shader中texture prefetch需要满足以下条件：
-  gvec4 texture(gsampler2D sampler, vec2 P, [float bias]); bias is imm value or some other uniform variable gvec4 textureLod(gsampler2D sampler, vec2 P, float lod); lod is imm value or some other uniform variable gvec4 textureProj(gsampler2D sampler, vec4(or vec3) P, [float bias]); bias = 0.0 (or no bias parameter) gvec4 textureLodOffset(gsampler2D sampler, vec2 P, float lod, ivec2 offset); lod is imm value or some other uniform variable
| gvec4 texture(gsampler2D sampler, vec2 P, [float bias]); bias is imm value or some other uniform variable  |
| --- |
| gvec4 textureLod(gsampler2D sampler, vec2 P, float lod); lod is imm value or some other uniform variable  |
| gvec4 textureProj(gsampler2D sampler, vec4(or vec3) P, [float bias]); bias = 0.0 (or no bias parameter)  |
| gvec4 textureLodOffset(gsampler2D sampler, vec2 P, float lod, ivec2 offset); lod is imm value or some other uniform variable  |
【不推荐】
在fragment shader中的if条件语句中直接使用来自vertex shader的坐标进行prefetch，以免带来不必要的带宽开销。
【示例】
推荐shader：
3. Texture Reuse
Texture Reuse是一种指令的合并方法，因为在Fragment Shader中texture使用频率较高，且消耗的资源较大，所以Maleoon GPU使用了Texture Reuse来优化符合条件的2D Texture。
【推荐】
Texture Reuse可以分为三种模式：TSLOOP、POLOOP和OFFSETLOOP。
-  推荐shader：
-  offset支持immediate。 推荐shader：
-  offset支持immediate和uniform。 推荐shader：
对于这三类texture，Maleoon GPU会对其进行reuse，减少传输的次数，降低功耗。
4. 高阶采样
基于Texture Reuse做进一步优化，可以在采样单元直接计算出运算结果，支持POLOOP和OFFSETLOOP。
【推荐】
根据texture reuse的不同使用场景加入了三种高阶采样优化：Convolution、Max和Min。
-  sampler支持lowp/mediump，weight支持mediump，可以为immediate或者uniform 推荐shader：
-  sampler支持lowp/mediump 推荐shader：
-  sampler支持lowp/mediump 推荐shader：
对于这三类texture，Maleoon GPU在reuse基础上进一步减少传输的信息，降低功耗。
Blend
Maleoon GPU上，Blend可以通过Fixed Funcion（硬件加速）的方式，或者软件shader的方式实现，具体的影响因素包括采用的blend mode和进行blend的color attachment的format。
【推荐】
-  仅适用于Maleoon 910 GPU。
【不推荐】
-  仅适用于Maleoon 910 GPU。
Transfer
仅适用于Vulkan。
通过transfer命令，用户可以执行GPU上数据的拷贝。在拷贝时，将数据对齐到合适的alignment以及适当合并拷贝的区域将有助于性能提升。
【推荐】
Compute
1. Compute Shading
1.1 Workgroup size
Workgroup size大小调优是一种简单有效的优化方法。
【推荐】
1.2 Barrier
不管是数据并行和任务并行有时候不可避免存在相关性，需要等待其他任务或者数据才能进行下一步计算，这时要用到同步机制，OpenCL同步机制称为Barrier。
【推荐】
如果Workgroup size小于32(simd32)，硬件可以保证workgroup中的所有线程在一个warp中。因此开发者可以省略workgroup级别的Barrier，从而提升性能。
1.3 Loop Reduction
Loop Reduction是用OpenCL有效实现数组求和，Maleoon GPU支持Vulkan与OpenCL的subgroup特性。
【推荐】
尽量使用subgroup特性各类extension实现Loop reduction。
2. OpenCL
2.1 API使用
OpenCL作为一个支持多种计算设备的框架，提供了多个标准API以应对不同场景，使用具有很大的灵活性。为了引导OpenCL API使用者在Maleoon GPU上获取更好性能，给出以下OpenCL API的使用推荐。
【推荐】
-  OpenCL的算子在应用开始阶段，只编译一次，然后把binary保存下来，后面在应用中直接使用，减少多次编译引起的耗时。
-  GPU的shader优点是多核多线程操作，clEnqueueNDRangeKernel的work-items数量应该尽可能的大，充分发挥多warps的优势。
-  在调用一个或者多个clEnqueueNDRange()后，再执行clFlush()，最后调用clWaitForEvent()。同步操作需要在任务下发后在CPU侧进行等待，，阻塞CPU任务执行。
2.2 Kernel算子
Kernel算子是OpenCL的核心模块，算子的写法会影响OpenCL程序的性能，体现在主机和设备间的数据传输、算子执行的并行度、内存的访问模式等。为了使OpenCL Kernel算子在Maleoon GPU上获取更好性能，给出以下Kernel算子的用法推荐。
【推荐】
-  通常在精度允许的情况下，可以使用half_or native_等内建函数版本，这样可以获取比数学函数更好的性能。
-  对于精度不高，计算单元负载大的场景，可以使用-cl-fast-relaxed-math。
-  如果在流程中有一系列算子，算子的数据复合度很高，并且算子的逻辑很简单，考虑将小kernel进行适当的合并，但是如果数据没有依赖性的算子就尽可能不要合并。
-  如果一些算子逻辑中有大量的barrier，或者寄存器使用量太大，可以考虑对这类算子进行拆分，降低单个算子使用寄存器的数目，以提升warp的并行度。
-  使用向量化的逻辑提升数据加载的效率和EU的指令数目，可以考虑vload16()等操作。
-  需要避免在OpenCL算子中使用大量的临时变量，而且使用尽可能集中，减少寄存器的使用，汇编指令中寄存器的使用量超过64时，会大大降低warp的并行度。
-  算子中使用const关键字等，方便编译时优化为常量寄存器。
-  使用hv_clcc离线编译binary的方式替换在线编译的方式，减少编译器编译binary的时间，提升整体性能。
-  通过vload3加载global memory时，内存需要按照vector4的格式进行数据对齐。
-  针对uniform的buffer，使用constant和max_constant_size关键字，把相关参数存入到FAU常量寄存器中，节省多个线程加载数据的执行时间。
【不推荐】
-  在算子中对数据进行类型转换，可能会导致数据的对齐格式发生变化，那么在加载数据时需要额外的操作，会拉低执行效率。
-  对于global内存，不要在算法内部进行数据的转换。例如，输入的全局内存是int*或者short *，不要让它转换为char*再作一个偏移，然后又转换为int*或者short*的类型，这样只读buffer优化就无法使用，无法将只读buffer带宽大的优势体现出来。
-  Warp中的多个线程尽可能走同一跳转分支，如果算法中包含的分支数太多，例如switch，if，while等操作，使得warp中各个线程会走不同的分支逻辑。这样会导致ALU把所有的分支逻辑都走一遍，降低算子的性能。
-  在算子中使用大量global memory的atomic操作，会拉低warp的并行度，建议使用shared memory的atomic。
Window System Integration
仅适用于Vulkan。
通过vkCreateSwapchainKHR创建交换链，用于呈现绘制结果。用户可以通过VkSwapchainCreateInfoKHR-> minImageCount自定义交换链中可供使用的image的数量。App会通过vkAcquireNextImageKHR从交换链中申请出一个可用的image资源，执行绘制任务，然后通过vkQueuePresentKHR将完成绘制的image送回交换链并呈现绘制结果。
用户可以定义一个非常大的minImageCount来保证每次都能申请到可用的image资源，但若GPU能在远低于Vsync的时间内完成绘制，则该行为可能会导致画面存在撕裂感，并显著增加内存开销。若绘制任务负载很重，GPU无法在一个Vsync周期内完成绘制，则一个很小的minImageCount（例如2）会导致帧率的显著降低。
【推荐】
Resource
1. Texture
1.1 HEBC
HEBC是Maleoon GPU独有的硬件压缩算法，纹理的数据以无损的压缩格式存储，降低了数据传输的功耗和带宽，需要参考以下条件来使能HEBC。
Vulkan
【推荐】
-  序号 可支持的format 1 FORMAT_A4B4G4R4_UNORM=2 2 FORMAT_A4R4G4B4_UNORM=3 3 FORMAT_B5G6R5_UNORM=4 4 FORMAT_R5G6B5_UNORM=5 5 FORMAT_A1B5G5R5_UNORM=6 6 FORMAT_A1R5G5B5_UNORM=7 7 FORMAT_B5G5R5A1_UNORM=8 8 FORMAT_R8_UNORM=9 9 FORMAT_R8_UINT=13 10 FORMAT_R8_SINT=14 11 FORMAT_R8G8_UNORM=16 12 FORMAT_R8G8_UINT=20 13 FORMAT_R8G8_SINT=21 14 FORMAT_R8G8B8_UNORM=23 15 FORMAT_R8G8B8_UINT=27 16 FORMAT_R8G8B8_SINT=28 17 FORMAT_R8G8B8_SRGB=29 18 FORMAT_B8G8R8_UNORM=30 19 FORMAT_B8G8R8_UINT=34 20 FORMAT_B8G8R8_SINT=35 21 FORMAT_B8G8R8_SRGB=36 22 FORMAT_R8G8B8A8_UNORM=37 23 FORMAT_R8G8B8A8_UINT=41 24 FORMAT_R8G8B8A8_SINT=42 25 FORMAT_R8G8B8A8_SRGB=43 26 FORMAT_B8G8R8A8_UNORM=44 27 FORMAT_B8G8R8A8_UINT=48 28 FORMAT_B8G8R8A8_SINT=49 29 FORMAT_B8G8R8A8_SRGB=50 30 FORMAT_B10G10R10A2_UNORM=58 31 FORMAT_B10G10R10A2_UINT=62 32 FORMAT_R10G10B10A2_UNORM=64 33 FORMAT_R10G10B10A2_UINT=68 34 FORMAT_R16_UINT=74 35 FORMAT_R16_SINT=75 36 FORMAT_R16_SFLOAT=76 37 FORMAT_R16G16_UINT=81 38 FORMAT_R16G16_SINT=82 39 FORMAT_R16G16_SFLOAT=83 40 FORMAT_R16G16B16_UINT=88 41 FORMAT_R16G16B16_SINT=89 42 FORMAT_R16G16B16_SFLOAT=90 43 FORMAT_R16G16B16A16_UINT=95 44 FORMAT_R16G16B16A16_SINT=96 45 FORMAT_R16G16B16A16_SFLOAT=97 46 FORMAT_R32_UINT=98 47 FORMAT_R32_SINT=99 48 FORMAT_R32_SFLOAT=100 49 FORMAT_R11G11B10_UFLOAT=122 50 FORMAT_D16_UNORM=124 51 FORMAT_D24_X8_UNORM=125 52 FORMAT_D32_SFLOAT=126 53 FORMAT_D24_UNORM_S8_UINT=129 54 FORMAT_D32_SFLOAT_S8_UINT=130
| 序号  | 可支持的format  |
| --- | --- |
| 1  | FORMAT_A4B4G4R4_UNORM=2  |
| 2  | FORMAT_A4R4G4B4_UNORM=3  |
| 3  | FORMAT_B5G6R5_UNORM=4  |
| 4  | FORMAT_R5G6B5_UNORM=5  |
| 5  | FORMAT_A1B5G5R5_UNORM=6  |
| 6  | FORMAT_A1R5G5B5_UNORM=7  |
| 7  | FORMAT_B5G5R5A1_UNORM=8  |
| 8  | FORMAT_R8_UNORM=9  |
| 9  | FORMAT_R8_UINT=13  |
| 10  | FORMAT_R8_SINT=14  |
| 11  | FORMAT_R8G8_UNORM=16  |
| 12  | FORMAT_R8G8_UINT=20  |
| 13  | FORMAT_R8G8_SINT=21  |
| 14  | FORMAT_R8G8B8_UNORM=23  |
| 15  | FORMAT_R8G8B8_UINT=27  |
| 16  | FORMAT_R8G8B8_SINT=28  |
| 17  | FORMAT_R8G8B8_SRGB=29  |
| 18  | FORMAT_B8G8R8_UNORM=30  |
| 19  | FORMAT_B8G8R8_UINT=34  |
| 20  | FORMAT_B8G8R8_SINT=35  |
| 21  | FORMAT_B8G8R8_SRGB=36  |
| 22  | FORMAT_R8G8B8A8_UNORM=37  |
| 23  | FORMAT_R8G8B8A8_UINT=41  |
| 24  | FORMAT_R8G8B8A8_SINT=42  |
| 25  | FORMAT_R8G8B8A8_SRGB=43  |
| 26  | FORMAT_B8G8R8A8_UNORM=44  |
| 27  | FORMAT_B8G8R8A8_UINT=48  |
| 28  | FORMAT_B8G8R8A8_SINT=49  |
| 29  | FORMAT_B8G8R8A8_SRGB=50  |
| 30  | FORMAT_B10G10R10A2_UNORM=58  |
| 31  | FORMAT_B10G10R10A2_UINT=62  |
| 32  | FORMAT_R10G10B10A2_UNORM=64  |
| 33  | FORMAT_R10G10B10A2_UINT=68  |
| 34  | FORMAT_R16_UINT=74  |
| 35  | FORMAT_R16_SINT=75  |
| 36  | FORMAT_R16_SFLOAT=76  |
| 37  | FORMAT_R16G16_UINT=81  |
| 38  | FORMAT_R16G16_SINT=82  |
| 39  | FORMAT_R16G16_SFLOAT=83  |
| 40  | FORMAT_R16G16B16_UINT=88  |
| 41  | FORMAT_R16G16B16_SINT=89  |
| 42  | FORMAT_R16G16B16_SFLOAT=90  |
| 43  | FORMAT_R16G16B16A16_UINT=95  |
| 44  | FORMAT_R16G16B16A16_SINT=96  |
| 45  | FORMAT_R16G16B16A16_SFLOAT=97  |
| 46  | FORMAT_R32_UINT=98  |
| 47  | FORMAT_R32_SINT=99  |
| 48  | FORMAT_R32_SFLOAT=100  |
| 49  | FORMAT_R11G11B10_UFLOAT=122  |
| 50  | FORMAT_D16_UNORM=124  |
| 51  | FORMAT_D24_X8_UNORM=125  |
| 52  | FORMAT_D32_SFLOAT=126  |
| 53  | FORMAT_D24_UNORM_S8_UINT=129  |
| 54  | FORMAT_D32_SFLOAT_S8_UINT=130  |
OpenGL ES
【推荐】
-  序号 可支持的format 1 GL_RGB8_OES 2 GL_RGBA8_OES 3 GL_BGRA8_EXT 4 GL_RGBA4 5 GL_RGB565 6 GL_RGB5_A1 7 GL_DEPTH_COMPONENT16 8 GL_DEPTH_COMPONENT24_OES 9 GL_DEPTH24_STENCIL8_OES 10 GL_DEPTH_COMPONENT32F 11 GL_DEPTH32F_STENCIL8 12 GL_RGB10_EXT 13 GL_RGB10_A2_EXT 14 GL_R8_EXT 15 GL_RG8_EXT 16 GL_R16F 17 GL_RG16F 18 GL_RGBA16F 19 GL_R11F_G11F_B10F 20 GL_SRGB8_ALPHA8 21 GL_RGB10_A2UI 22 GL_RGBA16UI 23 GL_RGBA8UI 24 GL_RGBA16IGL_RGBA8I
| 序号  | 可支持的format  |
| --- | --- |
| 1  | GL_RGB8_OES  |
| 2  | GL_RGBA8_OES  |
| 3  | GL_BGRA8_EXT  |
| 4  | GL_RGBA4  |
| 5  | GL_RGB565  |
| 6  | GL_RGB5_A1  |
| 7  | GL_DEPTH_COMPONENT16  |
| 8  | GL_DEPTH_COMPONENT24_OES  |
| 9  | GL_DEPTH24_STENCIL8_OES  |
| 10  | GL_DEPTH_COMPONENT32F  |
| 11  | GL_DEPTH32F_STENCIL8  |
| 12  | GL_RGB10_EXT  |
| 13  | GL_RGB10_A2_EXT  |
| 14  | GL_R8_EXT  |
| 15  | GL_RG8_EXT  |
| 16  | GL_R16F  |
| 17  | GL_RG16F  |
| 18  | GL_RGBA16F  |
| 19  | GL_R11F_G11F_B10F  |
| 20  | GL_SRGB8_ALPHA8  |
| 21  | GL_RGB10_A2UI  |
| 22  | GL_RGBA16UI  |
| 23  | GL_RGBA8UI  |
| 24  | GL_RGBA16IGL_RGBA8I  |
【不推荐】
通过glBindImageTexture绑定到image unit的已经被压缩的纹理，在被imageLoad/imageStore访问时，驱动侧会触发解压缩流程。
解压缩后的纹理在之后的渲染过程中不会被重新压缩，都是以非压缩的状态存在。
1.2 Filtering
各向异性滤波（Anisotropic Filtering）被用来避免mip-map的过度模糊效应，然而各向异性滤波和三线性滤波会降低纹理采样的性能。Maleoon GPU上，YUV纹理暂不支持各向异性滤波。
【推荐】
为了在Maleoon GPU上获得更好的性能，我们建议：
1.3 三通道Texture Buffer
仅适用于OpenGL ES。
使用GLSL texelFetch指令采样三通道的Texture Buffer，对性能有一定的影响，开发者尽量避免。
【不推荐】
使用GLSL texelFetch指令采样三通道的Texture Buffer。
1.4 Feedback Loops
一张纹理同时被采样和写出，spec定义该同读同写场景为feedback loops，feedback loops的结果未定义。
【不推荐】
使用feedback loops。
2. Buffer
仅适用于OpenGL ES。
如果glMapBufferRange包含MAP_UNSYNCHRONIZED_BIT 标记位，GPU驱动无需关注buffer内存状态，直接将该buffer地址返回给用户。即使buffer内存正在被使用，也不会报错，后续该buffer内存读写操作所导致的结果都是未定义的。这个标志允许开发者在不等待之前操作完成的情况下映射buffer，可能会提高性能，但同时也带来了数据错误的风险。
【推荐】
如果可以保证buffer没有任何的读写依赖，调用glMapBufferRange时包含MAP_UNSYNCHRONIZED_BIT标记位，有助于提升性能。
【不推荐】
不能保证buffer没有任何的读写依赖，调用glMapBufferRange时不要包含MAP_UNSYNCHRONIZED_BIT标记位，否则会有数据错误的风险。
Synchronization
仅适用于Vulkan。
Vulkan提供了多种不同的同步原语供App使用，用户可以用这些同步原语来保证GPU任务的执行时序，从而保证执行结果符合预期。其中Barrier、Event、Semaphore等同步原语都可以作为GPU任务间同步的工具，用户可以下发srcStageMask和dstStageMask来指定被等待的pipelineStages和等待的pipelineStages。
由于一般游戏应用中，graphics jobs是用来绘制游戏画面的，负载比较大且直接影响帧率。所以尽量不要让其他类型的Jobs（如Transfer、Compute）阻塞graphics jobs。如果有这类需要，应该尽量考虑消除或减少阻塞的时间。
【推荐】
例如以下序列，compute执行时graphics是闲置的，导致graphics并发度低。
Job的执行顺序如下图所示，可见graphics jobs之间存在较大空隙，compute和graphics jobs为串行执行。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151009.05348853092130934172695546075184:50001231000000:2800:0E11945223080447EF6385E64FF9D2DF230374CFF2E4BFC101B34533C462D2D0.jpg)
为了避免以上情况出现，compute执行时，尽量让可以并行的graphics任务与compute同时执行。API序列如下所示：
Job的执行顺序如下图所示，此时compute和graphics jobs可以并发执行。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151009.20346982508004752024503664441575:50001231000000:2800:221401B20E0F6DE0DA45B77369BFFCBC9A30A9AA9D4D027D8A70961F34D05F71.jpg)
【不推荐】
影响
不恰当的同步操作可能会使Maleoon GPU不同类型的Jobs并行度变差，从而导致GPU性能受损。
Subpass Merge
仅适用于Vulkan。
Vulkan支持多subpass渲染，该功能使得GPU能够从一个subpass获取color attachment和depthstencil attachment，无需写回到主内存，直接在片上将它们用作后续subpass中的input attachment，这个优化叫做subpass merge。
在一些应用场景下（例如延迟着色场景），通过多subpass配置，成功merge-subpass，则会大大提高效率。
Maleoon GPU硬件支持在满足以下条件时，允许后面的subpass按照合适的tiler粒度和执行顺序直接从tile buffer上读取前面的subpass的输出结果来使用，从而避免出现“写出到DDR”和“从DDR读回”这样一个来回高耗带宽的数据存取过程。
【推荐】
当merge-subpass满足以下条件，能够实现merge-subpass方案。
-  仅适用于Maleoon 910 GPU。
【不推荐】
Shader编码优化
不要使用较复杂shader
相比于CPU优化，在做GPU优化时，需要特别关注shader并发执行的情况，发挥GPU并行计算的能力，这个比做好单个shader的优化更加重要。这种并发分两个层面，一方面是不同的shader之间，如果无依赖，要尽量并发的执行，另一方面是同一个shader，不同的线程（vertex/pixel…）要尽可能的并发执行。
Shader执行所需的资源，在GPC/EU等层级上可能会有独占的情况，即如果一个shader申请了过多的资源，那其它shader可能无法并发执行，例如如果一个shader使用了过多GPR资源，那么在一个EU里并发一个warp任务，导致GPU算力发挥不了。移动端GPU资源更加紧凑，需要更加注意。
【推荐】
建议不要使用超过800行的shader，如果确实需要如此复杂的计算量，可以尝试拆分为多个shader来执行。虽然相同计算量下拆分draw会有额外开销，但是可以提升EU并发度，避免GPU卡在个别的几个shader上，阻塞了其它shader的执行。总体而言性能更佳。
内存访问向量化
Maleoon GPU在内存访问操作上使用向量化是更加高效的行为，向量化的内存访问可以减少访问cycle和带宽。
【推荐】
推荐shader写法：
【不推荐】
原始shader写法：
尽量使用低精度
Maleoon GPU同时支持高精度和低精度，并且在软硬件上对低精度运算进行了深度优化。
【推荐】
推荐shader写法：
【不推荐】
以下场景不建议使用低精度运算：
原始shader写法：
生成优化的SPIR-V
如果使用HLSL/GLSL开发vulkan应用，一般需要通过工具转换生成SPIR-V格式的shader，但是转换过程中可能与原本HLSL/GLSL有差异。
【推荐】
建议使用glslang 11.0及以上版本，并确认生成的SPIR-V包含了足够的优化信息，例如relaxed-precision描述等。
Uniforms
Maleoon GPU可以将部分uniform data转换成shader core的register，从而减少频繁的uniform data load。
【推荐】
【不推荐】
以下uniform data无法转换成register：
Uniform Expressions
Maleoon GPU通过协处理器，可以在draw call执行前，在协处理器上完成一部分标量运算，主要包括了uniform和立即数相关表达式的计算，计算结果提供给整个draw call使用。因此，在Maleoon GPU上uniform expressions不会占用GPU运行的时间。
【推荐】
通过调整计算顺序，合并uniform和立即数的计算过程，减少uniform计算和普通计算频繁交替。
Uniform Relative Indexing
Maleoon GPU对于Uniform relative indexing的一般做法为将动态索引的完整uniform buffer放在mem中，再通过运行时计算出来的index从mem中load出对应的uniform value。
【推荐】
【示例】
原始shader写法：
推荐shader写法：
Branch
分支（branching）在GPU上代价较大，原因如下：
【推荐】
【不推荐】
有些shader为了兼容性，会把memory的relative indexing改成if-else或者switch-case，这种太多分支操作写法对GPU不友好，导致性能很差。Maleoon GPU是支持所有memory类型的relative indexing，并且有些场景编译器还能优化，所以请保留relative indexing。
【示例】
原始shader写法：
推荐shader写法：
Loop
Loop运行过程中，会产生较多的分叉，且会有大量的分支指令，性能在GPU上较差。
【推荐】
如果一定要使用loop，建议使用如下的for循环：
推荐shader：
【不推荐】
原始shader：

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-location-service
爬取时间: 2025-05-01 09:47:33
来源: Huawei Developer
概述
在实际应用开发过程中，经常需要用到移动终端设备的位置信息，比如查看所在城市天气、出行打车、旅行导航以及观察运动轨迹等。关于位置定位，位置服务提供了两种定位方式，分别为GNSS定位和网络定位，如下表所示：
| 定位方式  | 说明  | 优点  |
| --- | --- | --- |
| GNSS定位  | 基于全球导航卫星系统，包含GPS、GLONASS、北斗、Galileo等，通过导航卫星、设备芯片提供的定位算法，来确定设备准确位置。  | 定位精准  |
| 网络定位  | 通过网络进行定位，包括WLAN、蓝牙定位、基站定位。  | 定位速度快  |
定位方式
说明
优点
GNSS定位
基于全球导航卫星系统，包含GPS、GLONASS、北斗、Galileo等，通过导航卫星、设备芯片提供的定位算法，来确定设备准确位置。
定位精准
网络定位
通过网络进行定位，包括WLAN、蓝牙定位、基站定位。
定位速度快
利用系统的位置定位能力，可以在多种开发场景中获得实时准确的位置信息。本文将介绍如下四种常见的定位场景，并给出其具体实现方案，帮助开发者更好地掌握位置定位的基本原理和开发流程。
当前位置定位
开发者可以根据实际业务诉求，设置相应的定位策略获取设备的当前位置信息，不同定位策略对应表1 定位方式介绍中不同的定位方式。
实现原理
位置服务提供getCurrentLocation()接口来获取当前位置信息，该接口需要用户设置关键参数——定位请求信息。定位请求信息包含定位方式优先级、单次定位超时时间等，分为CurrentLocationRequest和SingleLocationRequest两种类型。两种类型对应的定位优先级分别为LocationRequestPriority和LocatingPriority。
开发步骤
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151019.63867979041855305380974988228732:50001231000000:2800:3B9C641D67D1B1F2FB9315B8BA6FD082E1B21305DB7F661DC04C9B9F22B99D44.png)
实时位置定位
开发者可以根据实际用户活动场景或功耗场景，设置相应的定位策略持续获取设备的位置信息，不同定位策略对应表1 定位方式介绍中不同的定位方式。
实现原理
位置服务通过on('locationChange')接口订阅位置变化情况，实现持续获取设备位置信息的场景诉求。该订阅服务需要申请定位请求信息LocationRequest或者ContinuousLocationRequest，并在请求信息中设置定位场景类型和位置信息上报时间间隔。
开发步骤
1.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151019.54074432843980400488644042627760:50001231000000:2800:E02C488C74476DCF2501D16C70BFB5120E0D387173418974A9696AA022DBA411.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151020.32278832279317113873501937578510:50001231000000:2800:B2B25491FF1FCE18A866640F9E6E8A939B6EE9E33CFFE5602B2B1BEB9AA0511F.png)
应用后台定位
当用户将应用切至后台且依然需要获取设备的位置信息时，可以使用该方式进行后台定位。
实现原理
应用后台定位需要申请后台定位权限ohos.permission.LOCATION_IN_BACKGROUND和长时任务权限ohos.permission.KEEP_BACKGROUND_RUNNING。申请了相关权限后，开启任务模式为定位导航的长时任务，并在其回调接口中通过on('locationChange')订阅位置变化情况，在应用后台持续获取当前位置信息。
开发步骤
1.  申请长时任务权限 设置长时任务模式为定位导航类型
2.  开启长时任务 订阅位置变化情况
3.  关闭长时任务 关闭位置变化订阅
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151020.18203192677950807767294685180250:50001231000000:2800:5687090DD4CB5F8B25A8F7EE1B87CD813766BD24F232CDB1A5D2AAEEE668B46E.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151020.58935487511439332303166562965987:50001231000000:2800:9B1C8EA6A12FDDDFC08EFCB6A58AA19399CBB04B7B2FA3E4FDC23510A64A4F56.png)
历史定位获取
当用户设备网络信号较弱或者对系统功耗比较敏感时，可以先获取系统缓存的最新位置，即最近一次的历史定位信息。
实现原理
位置服务通过getLastLocation()接口来获取系统缓存的最新位置信息。该接口参数列表为空，返回值为Location位置信息。
开发步骤
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151020.21018050338711962152895790182718:50001231000000:2800:1D4338ACCA3EF64848DD364EFD1B029708C016EB6F268034D10F3C79622273F2.png)
常见问题
位置定位不准或者位置信息有偏差
问题现象
在定位过程中，获取的定位结果不准确，或者将定位结果标记在地图上时出现偏差。
可能原因
解决措施
位置定位失败
问题现象
无法使用定位功能获取位置信息。
可能原因
解决措施
系统缓存位置信息不准确
问题现象
使用getCurrentLocation()接口获取当前定位信息后，再使用getLastLocation()接口获取缓存定位信息，两次获取的定位信息不一致。
可能原因
所有应用公用系统中的同一份缓存定位信息，有可能在两次接口调用之间有其他应用发起定位，刷新了系统中的缓存定位信息。
解决措施
对比获取定位信息的时间，根据时间判断缓存定位信息是否更新。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-intent-recommend-practice
爬取时间: 2025-05-01 09:47:47
来源: Huawei Developer
概述
意图框架是HarmonyOS系统级的意图标准体系。将应用和元服务的业务功能智慧分发给不同的系统入口，以“音乐播放”为例，HarmonyOS将业务分发给“小艺建议”，提供了桌面大流量曝光，同时为开发者实现业务增长。习惯推荐类别下典型场景主要分为常用接续、常用复访以及常用推新三大类。比如“音乐播放”就属于常用接续场景。具体可参考习惯推荐典型场景。
接入意图框架首先需要确定特性类别和具体意图，详细请参见Intents Kit接入流程。
本文以“音乐播放”意图为例，详细讲解意图接入与开发全过程。
音乐播放开发
以“音乐播放”为例，从意图注册、意图共享以及意图调用三大块介绍意图运行的开发过程。如果应用支持播放功能并且需要实现推荐播放接续，例如音乐、长视频以及课程的播放接续，可以参考本文。首先需要在设置中开启意图框架调试，如下图所示。确保意图框架调试开启且在界面成功展示设备支测试应用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151004.78853709204308709163001398426875:50001231000000:2800:A33107DB0D5AF330F6D8B024B4258130E3CE878ED3D5D60DD3408EA538FD636F.png)
开发步骤
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151004.77853694271001910587954209203021:50001231000000:2800:369D5954D2C2B675EC7C0AB4B71A94BD1B3C4FB22807EEFB5EEB6658583BB414.png)
1.
```typescript
static async shareIntent(context: Context, input: string): Promise<string> {
Logger.debug(TAG, 'shareIntent');
let insightIntents: insightIntent.InsightIntent[];
try {
let insightIntents: insightIntent.InsightIntent[] = JSON.parse(input);
if (!insightIntents || insightIntents.length === 0){
Logger.error(TAG, 'shareIntent: json invalid.');
return 'shareIntent: json invalid.';
}
return await insightIntent.shareIntent(context, insightIntents).then(() => {
Logger.info(TAG, 'shareIntent success');
return 'share intent success';
}, (err: BusinessError) => {
Logger.error(TAG, `shareIntent error message: ${JSON.stringify(err)}`);
return `shareIntent error message: ${JSON.stringify(err)}`;
});
} catch (err) {
Logger.error(TAG, 'shareIntent fail', err);
}
return Promise.reject('shareIntent fail');
}
```
2.  前后台模式 启动模式 触发生命周期 foreground 冷启动 onCreate->onWindowStageCreate->onExecuteInUIAbilityForegroundMode 热启动 onNewWant->onExecuteInUIAbilityForegroundMode background 冷启动 onCreate->onExecuteInUIAbilityBackgroundMode 热启动 onExecuteInUIAbilityBackgroundMode 本示例中采取foreground模式，可以在onCreate()或者onNewWant()解析want和launchParam。通过launchReason区分是否是意图调用拉起的Ability，如果是则解析want中的参数，并且将参数result存储在AppStorage中。如果是在真实开发中意图调用传参字段可以在开发前和接口方协商。 want解析完毕后，会触发onExecuteInUIAbilityForegroundMode()方法进行真正逻辑处理，根据意图名称去分发处理方法并且返回一个Promise，成功调用code返回0，失败时返回-1。 如果想删除掉意图，可以调用insightIntent.deleteIntent()，在注册文件只有一个意图的情况下卡片入口会消失。运行效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151006.31911553694977122548388030589290:50001231000000:2800:FBA37B87C0963C123F5BCD8868A1956607BE24BA7EA21EA966CB0C3BA5F1273E.png)
| 前后台模式  | 启动模式  | 触发生命周期  |    |
| --- | --- | --- | --- |
| foreground  | 冷启动  | onCreate->onWindowStageCreate->onExecuteInUIAbilityForegroundMode  |    |
|    | 热启动  | onNewWant->onExecuteInUIAbilityForegroundMode  |    |
| background  | 冷启动  | onCreate->onExecuteInUIAbilityBackgroundMode  |    |
|    | 热启动  | onExecuteInUIAbilityBackgroundMode  |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151006.78020016632390745054381181369011:50001231000000:2800:77161F619A86A445A853B147CBC2BBB6BAB8D8DC107F7BB10B9FB0C059BAAFE3.gif)
在真机设备上，小艺建议卡片不会实时刷新。可以通过点击卡片中的服务，重新返回到桌面后，进行卡片刷新。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-gn-adapts-to-harmonyos
爬取时间: 2025-05-01 09:48:01
来源: Huawei Developer
概述
本文将介绍如何在GN工程中配置HarmonyOS工具链，然后通过HarmonyOS工具链编译出可以在HarmonyOS环境下使用的三方库。
HarmonyOS编译子系统是以GN和Ninja构建为基座，对构建和配置粒度进行部件化抽象、对内建模块进行功能增强、对业务模块进行功能扩展的系统，该系统提供以下基本功能：
Ninja：是一个专注于快速编译的小型构建系统。
GN：Generate Ninja的缩写，用于产生Ninja文件。
编译环境配置
1.  使用 WSL 在 Windows 上安装 Linux。 Ubuntu分发版本获取及安装说明。 编译环境目前主要支持Ubuntu18.04和Ubuntu20.04。
2.  从HarmonyOS官网门户选择Linux版本的Command Line Tools下载即可。 下载链接。
3.  任意位置创建工作目录depot_tools，cd到自己创建的目录，拉取工具（需要网络环境）： 将depot_tools的路径加到环境变量中： 编译.bashrc文件将depot_tools路径信息加到最后一行。 在.bashrc文件的最后添加下面一行代码。 此处需配置绝对路径信息，例如这里创建的本地路径是/mnt/d/my_code/depot_tools，故此处配置如上图。 刷新环境变量使其生效：
4.  直接输入指令sudo apt install python可能会安装失败，需要先输入sudo apt update更新一下可用包的最新列表。 判断python是否安装成功： 输入python显示python版本即可。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151408.31798242400677784142769105269498:50001231000000:2800:C7BB8B1555DD66393CBD39C54A1A3AEC0CCCE8B60C70610F27B5C8C6A1639AF7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151408.59307958744074252600616501979174:50001231000000:2800:8BF7274533CC41444F0A518FCF46E8B4093E9EADCAAA4211E5421E7AA6FAED10.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.31324475827895934081806635186829:50001231000000:2800:8A2B87B36993A918D9DA0DBEEBE15909507A2EA46784161C14C1FA7DEF3C116E.png)
GN构建工程适配流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.90736675534827260472105611908306:50001231000000:2800:AEC69BCCC22C3BBFD12F084FE6718082E51EF29DAAF704C779DB880FB5F5BE1E.png)
首先，需要添加HarmonyOS平台的宏定义；然后配置好HarmonyOS平台的工具链信息（包括clang工具链，sysroot以及clang版本）；接着需要在toolchain路径下配置各个架构的ohos_clang_toolchain；然后扩充gcc_toolchain模版功能，配置HarmonyOS用于启动引导程序的.o文件信息。剩下的就是需要设置一些HarmonyOS的编译参数（主要是基础的编译选项、宏定义等）；然后在BUILD.gn中不同架构平台的分支处，添加对应的HarmonyOS平台的分支，其中未适配HarmonyOS的三方库可以先走Linux分支的编译配置。更加详细的信息可参考下节的适配案例。
webRTC适配案例
本文将通过webRTC的GN构建工程案例来对上一章节的流程进行实操讲解。WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。下面我们来了解下如何通过GN构建工程将webRTC适配到HarmonyOS系统上。
适配流程
1.  这里主要在build/config/BUILDCONFIG.gn文件中适配HarmonyOS的default_compiler_configs和_default_toolchain。在GN工程里面，BUILDCONFIG.gn是第一位被解析的，里面定义的变量相当于全局变量，可以被后续所有的.gn文件使用。我们编译过程中可能会配置一些编译选项以及一些头文件搜索路径。default_compiler_configs指向的文件里面会包括一些默认的编译选项以及头文件搜索路径等等。_default_toolchain指向了一个工具链相关的函数。具体修改点如下：
2.  不同平台的工具链会有一些差别，所以需要使用HarmonyOS的工具链。这里主要修改config/clang/clang.gni文件。.gni文件类似于GN的头文件，会被import到各个.gn文件中使用其定义的一些变量。该文件中的核心修改点在于配置指向HarmonyOS SDK的工具链路径。另外还需修改clang_use_chrome_plugins的值为false，HarmonyOS中默认clang_use_chrome_plugins值为false，不设置可能会报错find-bad-constructs文件找不到。 此处ohos_sdk_native_root的值需要对应修改为自己本地HarmonyOS SDK中的native的路径。具体修改点如下：
3.  这里主要修改build/config/sysroot.gni文件，sysroot里面包含了许多头文件搜索路径，配置了sysroot之后，编译过程中会去该目录下搜索需要的头文件。SDK里面会提供大量的头文件，这些头文件都会放在sysroot目录下，所以我们需要引入HarmonyOS对应的sysroot。具体修改点如下：
4.  这里主要修改build/toolchain/toolchain.gni文件，在该文件中配置HarmonyOS对应的clang版本号。具体修改点如下：
5.  这里主要是在build/toolchain路径下新建一个ohos/BUILD.gn文件，用于配置ohos_clang_toolchain，里面主要配置了HarmonyOS用于启动引导程序的.o文件。同时设置HarmonyOS不同架构(主要包括ohos_clang_arm、ohos_clang_arm64、ohos_clang_x86_64)的ohos_clang_toolchain配置信息。具体添加内容如下：
6.  主要修改/build/toolchain/gcc_toolchain.gni文件。GN工程里面默认会配置gcc_toolchain，里面会包括一些tool，例如tool("cc")、tool("cxx")、tool("tolink")等等，编译不同的内容时调用其对应的配置项。这里主要是需要修改tool("solink")、tool("solink_module")中的rspfile_content配置以及tool("link")中的link_comand配置。我们需要在gcc_toolchain.gni中template("gcc_toolchain")下添加几个参数（libs_section_prefix、libs_section_postfix 、solink_libs_section_prefix、solink_libs_section_postfix ）的识别。这几个参数是指向了上一步骤中配置的用于启动引导程序的.o文件。这些参数会在我们需要修改的rspfile_content、link_comand中用到。具体修改如下： 修改tool("solink")和tool("solink_module")中的rspfile_content为rspfile_content = "-Wl,--whole-archive {{inputs}} {{solibs}} -Wl,--no-whole-archive $solink_libs_section_prefix {{libs}} $solink_libs_section_postfix"，这里需要用到刚刚定义的参数信息。具体修改如下： 修改tool("link")中link_command为link_command = "$ld {{ldflags}}${extra_ldflags} -o \"$unstripped_outfile\" $libs_section_prefix $start_group_flag @\"$rspfile\" {{solibs}} {{libs}} $end_group_flag $libs_section_postfix"，这里需要用到刚刚定义的参数信息。
7.  这里需要在build/config路径下新建一个ohos/BUILD.gn文件，该文件主要是定义了一个config("compiler")，该config会被注册到所有的编译目标，该config里面主要设置了基础的编译选项、宏定义等。 此处ohos_clang_base_path  的值需要对应修改为自己本地HarmonyOS SDK中的llvm的路径。具体添加内容如下：
8.  保证可以正确走HarmonyOS支持的编译分支。这里主要是为了防止clang版本号校验失败导致异常。具体修改如下：
9.  当前部分三方库还未适配HarmonyOS，涉及到时可以先走linux的编译配置，例如：需要获取config.h文件时。 修改modules/video_capture的BUILD.gn。具体修改如下： 修改third_party/zlib的BUILD.gn。具体修改如下： 修改third_party/libevent中的BUILD.gn。HarmonyOS SDK中没有queue.h头文件，需要使用compat dir目录下的queue.h头文件。具体修改如下：
10.  先通过GN命令生成对应的ninja文件，然后使用ninja编译命令进行编译。 可以根据需要在编译指令中添加对应参数信息。 查看具体编译命令： 可以在gn gen命令中添加--ninja-args="-v -dkeeprsp"用于查看具体编译命令，这个命令将会在编译过程中打印详细的编译命令，并且保留编译过程中生成的rsp文件。 查看一个目标被谁依赖： 例如gn refs out/intermediate/arm64_72 //pc:rtc_pc_base。这个命令将显示与目标//pc:rtc_pc_base相关的所有依赖项并列出所有引用了该目标的其他目标或文件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.12603816933909894682246550476307:50001231000000:2800:8C9512A3E03A142970F96FD41D018A5863A7DAC0EF86BB48BA7AD8C0433D7C58.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.43471799859894771069530276383344:50001231000000:2800:6026CF593FE760E867AABC95C3B78114BEEE5B060730F77ABAA0C6DDE6389D68.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.50803636385449756238922797120080:50001231000000:2800:B1882F5887C13C815BE22A883B64D12FDCCECAFC87075750A74325E5214438BF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.25282478615712545420031266431284:50001231000000:2800:5019B65D5807AEA123D3D906FF820212B7C7146BA3CF14AC36033B392CC16F45.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.35484416075265703252444113038358:50001231000000:2800:7D19765850EFDAECA9E2645C12E42D4C288BA264329FDB21079B829B097840D9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.91154070100502660102871766519797:50001231000000:2800:93036294889BA4EB4B58FF7F3EE28DB88B2B5F5DF2240FC1945A2FCBCB0ED2B6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.19970066091515062201274830494094:50001231000000:2800:6D00FD39A1C55D2387A90B316E9EEFF015F5CD8F95A1B9B79823250CAC62636C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.01902274334631575663185910593944:50001231000000:2800:B6B31CE91D13F4401B66364214231F5A2EB9B6BA74BD7086E52CA1E9019DC23B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.26155679920251566008137767090507:50001231000000:2800:8CD263306C15F8D048C64250603D45220DA190B0EFA2A527BC9F76D5C10BA567.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.34075654330092101425465639590067:50001231000000:2800:119EECBE7783E433870928853F7B4AC7466B76C54CE64E7367EC0BD5D337E241.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.87553357254188679464174609862408:50001231000000:2800:969EE8D49849F359BB7F7C0A9E5808617B6E4E7948249F1C3949F121A1632CE2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.06132500755980234149198081624171:50001231000000:2800:94B5E0AE47BDAC53DAD4A0C1D2A2B5E4F1C35938A5B64F395B03CC40AFB4A7A4.png)
常见问题总结
在对webRTC的GN工程进行HarmonyOS工具链适配过程中，遇到了一些常见问题场景。下面针对这些问题做一个具体分析。
1.  问题详情： 问题原因/解决措施： 三方库内部没有做对is_ohos的判断，导致走到错误分支。当前很多业务模块还未适配HarmonyOS，暂时可以走linux分支以保证正常编译。 具体修改： 修改third_party/zlib的BUILD.gn文件。
2.  问题详情： 问题原因/解决措施： 缺少pkg-config插件，安装该插件。 具体指令：
3.  问题详情： 问题原因/解决措施： 编译过程中会提示部分配置不识别，需要将这些配置项删除。 具体修改： 在build/config/compiler/BUILD.gn中删除以下配置。
4.  问题详情： 问题原因/解决措施： 编译器驱动程序有时（很少）会在调用之前发出警告。实际的链接器需要确保这些警告是否也被视为致命错误。为了避免编译中出现因警告而造成出错，可以添加编译参数treat_warnings_as_errors = false，或者去除config(treat_warnings_as_errors)中配置的“-Werror”，详情如下： 具体修改：
5.
6.
7.  问题详情： 问题原因/解决措施： rtc_base/platform_thread_types.cc未识别到is_ohos导致内部走错分支导致异常。目前HarmonyOS支持的接口是gettid()，rtc_base/platform_thread_types.cc需要识别到is_ohos然后调用gettid()。由于当前很多业务模块还未进行识别，暂时需要走linux分支，故需要保留linux的定义。 具体修改：
8.
9.
10.  fatal error: 'sys/queue.h' file not found 问题详情： 问题原因/解决措施： 找不到config.h头文件，libevent尚未适配HarmonyOS，需要添加is_ohos的判断并走linux的文件路径寻找config.h。 找不到'sys/queue.h'文件，HarmonyOS SDK中没有queue.h头文件，需要使用compat dir目录下的queue.h头文件。 具体修改： 修改third_party/libevent中的BUILD.gn。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151409.30203880376727377199449810987670:50001231000000:2800:735557C72657D4CFAD9C7E95C73CC1199CE6BFC150A4C8CE565FE1ED41AF32E0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.92472045158063397061959530950593:50001231000000:2800:3C717969E38F037F8EEBEFFD5E141B05EA4948B374B85BB678B01D3E8A9FA99F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.62686388538227061988078420588505:50001231000000:2800:07704F14D3DD08914F444E332704A77AD01D230A884F6733AC2C2331D9FECF40.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.06063473722933730658249131727437:50001231000000:2800:4BE3E200D668EE1F65C122EE47644558C3B9BF94612C9133AEDD02B6C3EEA7EF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.73982037376026358370414288502436:50001231000000:2800:8EE4061A20CEAEAFA51EEE42AE05C20D5FA434A4BDB914672EC5CD1CA0A83DF8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.68315289541323037540385238802761:50001231000000:2800:8151C81F1331C60D8AEA23863E54693CD5F4D8EA7D970713CD925EEAC67FAA0D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.51401504885495550946245769768802:50001231000000:2800:40451A53A4872D8AC13722D415FA0C15CE77A247584FFDE2CC6802FA972A1A25.png)
-
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.27887759503667499974700868639567:50001231000000:2800:161CE748A3EA5D163558F8034123456897D0B0804030B4D31CFFB0DA45447779.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.30852040676674240003950899898510:50001231000000:2800:E048E602E9F9CE06BF7D87E032772A053D2ABBB2B361AAD3BF9638206168242C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.46054800473900707190417175869955:50001231000000:2800:7F91D9F4E31A863865529E7E27F0647522A71A413F9B86015DA0C38D61716D5B.png)
-
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.36077619278056054777973521601514:50001231000000:2800:22FFF20D2E078303D8CD657B0C7CA74BD78272D589BD02B01F01AAC75D17F966.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.31872466842510661639565912459788:50001231000000:2800:3AC74FCB938F238B76E1C61A88805B805EE995CC009024DA4EE8528360222474.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.95657639494912905676901540507806:50001231000000:2800:6D1B9F5489DFFBB02BF02FB3C7A4811B86FF62C3FC80EEF820C1EB6C8F916F3D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.18784734133715029316368006423879:50001231000000:2800:68ACE300EFA3C3E9DCE42B6B8BE53758F56704A13B4831BD551C1C383404AD88.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151410.07226881485250898855444682412668:50001231000000:2800:6A824C5F8821A4DFB624CB8AFAA07322A0A816B3939A41FAB2038DD0C512CE97.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-cmake-adapts-to-harmonyos
爬取时间: 2025-05-01 09:48:14
来源: Huawei Developer
概述
CMake是一个跨平台的构建工具，用于管理构建过程、编译、链接和打包软件项目，它可以生成Makefile等用于不同操作系统和编译器的构建脚本。CMake的配置过程是跨平台的，因此可以在不同的操作系统上运行，例如Linux、Windows和macOS。
CMake构建过程可分为以下三个主要步骤：
CMake构建三方库适配流程
本小节介绍如何在Linux环境下，使用CMake构建工具通过ohos sdk编译cJSON三方库源码，生成ohos平台三方库的so及二进制文件。
环境准备
1.  开发者可以选择熟悉的发行版来进行环境搭建，这里以Ubuntu为例，Ubuntu目前主要支持Ubuntu18.04和Ubuntu20.04。
编译三方库
1.  为防止污染源码目录文件，推荐在三方库源码目录新建一个编译目录，用于生成需要编译的配置文件。 本用例中在cJSON目录下新建一个build目录：
2.  参数说明： 部分文件产物说明：
3.  执行make对cJSON进行编译：
4.  编译成功后开发者可以通过file命令查看文件的属性，以此判断交叉编译是否成功，如下信息显示libcjson.so为aarch64架构文件，即交叉编译成功：
应用中集成使用三方库
请参考：三方动态链接库（.so）集成开发实践。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-make-adapts-to-harmonyos
爬取时间: 2025-05-01 09:48:28
来源: Huawei Developer
概述
Make是一个标准的Unix构建工具，用于自动化编译过程。它可以读取Makefile中的规则和依赖项，并根据这些规则来构建源代码，Make会检查源代码文件的时间戳，以确定哪些文件需要重新编译。Make会自动解决依赖关系并按正确的顺序编译源文件，通过在终端中运行Make命令，Make将根据Makefile中的指令逐步构建代码，生成最终的可执行程序或库文件。
Makefile文件是一个文本文件，它定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，以及哪些文件需要重新编译。这些规则包括文件的编译方式、库文件的创建方法，以及最终生成的可执行文件的制作过程。Makefile文件描述了整个工程的编译、连接等规则，包括源文件的依赖关系和编译顺序。通过编写Makefile文件，开发者可以自动化地构建和管理工程项目，极大地提高了开发效率。
二者关系：
Makefile是Make工具的配置文件，用于描述项目的构建规则和依赖关系。Make工具则根据这些规则和依赖关系，来决定哪些文件需要重新构建，从而实现自动化构建过程。二者共同作用，提高了软件开发的效率和便利性。
Make构建三方库适配流程
本小节介绍如何在Linux环境下，使用Make构建工具通过ohos sdk编译bzip2三方库源码，生成ohos平台三方库的so及二进制文件。
环境准备
编译三方库
1.  因为需要适配ohos，所以需要将非ohos的工具链配置为ohos的工具链。 通过分析源库的Makefile文件可知，以下几个内容需要进行重新配置： 环境变量作用： 默认配置Linux下gcc的编译命令，编译时需要配置成HarmonyOS交叉编译命令。 PREFIX：用于指定安装路径的前缀。 默认配置的安装目录为系统的/usr/local/下，如果需要执行安装的话，需配置成用户目录下。
2.  环境变量作用： 默认配置Linux下gcc的编译命令，编译时需要配置成HarmonyOS交叉编译命令。
3.  PREFIX：用于指定安装路径的前缀。 默认配置的安装目录为系统的/usr/local/下，如果需要执行安装的话，需配置成用户目录下。
4.  分析完Makefile后，即可配置交叉编译命令进行编译（xxx需要改为自己的文件路径）。 参数说明： 注：CC配置时，除了配置为交叉编译的clang外，还需要配置target的架构，即配置成aarch64位，按此配置编译出来的文件才能在64位设备上运行，如若需要编译32位的文件，则target配置成arm-linux-ohos即可。
5.  编译时配置了aarch64-linux-ohos，因此生成的文件属性为ARM aarch64，交叉编译成功。
6.  通过之前分析Makefile可以知道，在安装时需要配置PREFIX这个安装路径的变量：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151411.36908793641877452699224695204640:50001231000000:2800:B15F7DBF6189D0471BEA83F4F176ED6BC5E990B93BB775B36F321AAAF3A8FD59.png)
1.  环境变量作用： 默认配置Linux下gcc的编译命令，编译时需要配置成HarmonyOS交叉编译命令。
2.  PREFIX：用于指定安装路径的前缀。 默认配置的安装目录为系统的/usr/local/下，如果需要执行安装的话，需配置成用户目录下。
应用中集成使用三方库
请参考：三方动态链接库（.so）集成开发实践。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-configure-adapts-to-harmonyos
爬取时间: 2025-05-01 09:48:41
来源: Huawei Developer
概述
Configure是一个用于自动化软件编译和安装的工具，它可以帮助开发者编译和安装源代码，以便生成可执行文件和库文件。在编译和安装软件时，通常需要一系列步骤，例如设置编译选项、检查依赖库、生成配置文件等，Configure可以通过读取软件的源代码，自动化这些步骤，简化软件的编译和安装过程。其原理是根据系统环境和用户设置来生成Makefile文件，Makefile文件是一个包含编译选项和依赖关系的脚本，可以自动化编译和安装软件。
Configure工具的主要作用：
Configure构建三方库适配流程
本小节介绍如何在Linux环境下，使用Configure构建工具通过ohos sdk编译jpeg三方库源码，生成ohos平台三方库的so及二进制文件。
环境准备
编译三方库
1.  由Configure的帮助信息可以知道，jpeg交叉编译需要配置主机（编译完后需要运行的系统机器）、交叉编译命令以及配置安装路径等选项。
2.  安装路径以及host配置可以在./configure时执行（xxx表示自定义安装路径），host此处以配置arm64位为例。 执行完./configure未提示任何错误，即说明配置成功，在当前目录会生成Makefile文件。
应用中集成使用三方库
请参考：三方动态链接库（.so）集成开发实践。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-lycium-adapts-to-harmonyos
爬取时间: 2025-05-01 09:48:54
来源: Huawei Developer
概述
随着技术的不断发展，移动应用开发需求也越来越大，在传统移动应用开发过程中，开发者需要面对较为繁琐的配置和环境搭建，这使开发成本变得更高。为解决这类问题，通过使用lycium工具，可以帮助开发者实现快速开发，简化开发流程，减少开发耗时。
lycium是一款协助开发者通过shell语言实现C/C++三方库快速交叉编译，并在HarmonyOS上快速验证的编译框架工具。
开发者只需要设置对应C/C++三方库的编译方式以及编译参数，通过lycium就能快速的构建出能在HarmonyOS上运行的二进制文件。
本文将以openssl为例，介绍如何通过lycium工具快速编译三方库。
通过lycium工具快速编译三方库
本小节介绍如何在Linux环境下，使用lycium工具通过ohos sdk快速编译openssl三方库源码。
编译环境准备
1.  为简化开发中命令的配置，针对arm架构以及aarch64架构集成了几个编译命令，存放在lycium/Buildtools目录下。在使用lycium工具前，需要将这些编译命令拷贝到SDK对应的目录下，具体操作如下：
2.  为简化开发中命令的配置，针对arm架构以及aarch64架构集成了几个编译命令，存放在lycium/Buildtools目录下。在使用lycium工具前，需要将这些编译命令拷贝到SDK对应的目录下，具体操作如下：
1.  为简化开发中命令的配置，针对arm架构以及aarch64架构集成了几个编译命令，存放在lycium/Buildtools目录下。在使用lycium工具前，需要将这些编译命令拷贝到SDK对应的目录下，具体操作如下：
编译三方库
1.  lycium框架提供了HPKBUILD文件供开发者对相应的C/C++三方库的编译配置。 每个编译脚本都需要按照该规则定义相应的变量以及对应的5个函数，其中变量标明必填的，需要根据库信息正确填写，否则会导致编译失败。 填写示例参考如下： openssl的编译构建方式是configure编译构建，configure交叉编译是需要配置host类型，且需要配置对应的环境变量，框架中集成了环境变量设置的接口，封装在envset.sh中，因此除了基本信息外，还需要定义一个host变量以及导入envset.sh文件，基本变量配置参考如下： 在prepare()函数中创建编译目录，配置对应架构的环境变量： build()函数使用configure命令生成Makefile并执行make指令： openssl测试时需要单独通过编译目标depend生成测试用例，因此需要修改对应的check()函数。在check函数中执行make depend，并在执行完后清理对应的环境变量，以及在该函数后面通过注释说明该库在设备上的测试方法。 package()和cleanbuild()函数，使用模板默认的即可。
2.  每个编译脚本都需要按照该规则定义相应的变量以及对应的5个函数，其中变量标明必填的，需要根据库信息正确填写，否则会导致编译失败。 填写示例参考如下： openssl的编译构建方式是configure编译构建，configure交叉编译是需要配置host类型，且需要配置对应的环境变量，框架中集成了环境变量设置的接口，封装在envset.sh中，因此除了基本信息外，还需要定义一个host变量以及导入envset.sh文件，基本变量配置参考如下： 在prepare()函数中创建编译目录，配置对应架构的环境变量： build()函数使用configure命令生成Makefile并执行make指令： openssl测试时需要单独通过编译目标depend生成测试用例，因此需要修改对应的check()函数。在check函数中执行make depend，并在执行完后清理对应的环境变量，以及在该函数后面通过注释说明该库在设备上的测试方法。 package()和cleanbuild()函数，使用模板默认的即可。
3.  配置完三方库的编译方式参数后，在lycium目录执行./build.sh openssl（openssl即为创建的目录名称），进行自动编译三方库，并打包安装到当前目录的usr/pkgname/ARCH目录（pkgname为三方库名称，ARCH为架构名称）。 当未报错且日志打印ALL JOBS DONE!!!时，表示三方库编译成功。
4.  编译成功后进入lycium/usr目录下，可查看编译生成的文件。
1.  每个编译脚本都需要按照该规则定义相应的变量以及对应的5个函数，其中变量标明必填的，需要根据库信息正确填写，否则会导致编译失败。 填写示例参考如下： openssl的编译构建方式是configure编译构建，configure交叉编译是需要配置host类型，且需要配置对应的环境变量，框架中集成了环境变量设置的接口，封装在envset.sh中，因此除了基本信息外，还需要定义一个host变量以及导入envset.sh文件，基本变量配置参考如下： 在prepare()函数中创建编译目录，配置对应架构的环境变量： build()函数使用configure命令生成Makefile并执行make指令： openssl测试时需要单独通过编译目标depend生成测试用例，因此需要修改对应的check()函数。在check函数中执行make depend，并在执行完后清理对应的环境变量，以及在该函数后面通过注释说明该库在设备上的测试方法。 package()和cleanbuild()函数，使用模板默认的即可。
应用中集成使用三方库
1.  为更好管理应用集成的三方库，需要在应用工程的cpp目录新建一个thirdparty目录，将生成的二进制文件以及头文件拷贝到该目录下。 如下图所示，xxx代表三方库名称，xxx文件夹下包含了aarch64架构以及arm架构两种方式生成的二进制文件，每种架构目录下包含了该库的头文件目录include以及二进制文件目录lib。 如果三方库二进制文件为so文件，还需要将so文件拷贝到工程目录的entry/libs/${OHOS_ARCH}/目录下，如下图： 动态库引用注意事项： 拷贝方法：不通过压缩直接将so文件拷贝到windows，或将so文件压缩成.zip格式拷贝到windows，正确拷贝so文件后，so文件大小应该与原库实体文件大小一致。 如果将so文件以tar、gz、7z、bzip2等压缩方式拷贝到windows后在解压，其文件是实体库的软连接，大小和实体库大小不一致，文件也不能正常使用。
2.
3.  拷贝方法：不通过压缩直接将so文件拷贝到windows，或将so文件压缩成.zip格式拷贝到windows，正确拷贝so文件后，so文件大小应该与原库实体文件大小一致。 如果将so文件以tar、gz、7z、bzip2等压缩方式拷贝到windows后在解压，其文件是实体库的软连接，大小和实体库大小不一致，文件也不能正常使用。
4.  配置链接只需要在cpp目录的CMakeLists.txt文件中添加对应target_link_libraries即可（动态库链接和静态库链接，只需填写一个）。
5.  在cpp目录的CMakeLists.txt文件中添加对应target_include_directories即可：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151411.37437349676674552579891427339036:50001231000000:2800:A05AE7B24F005D066DD8665CBCBC9EB579F76BDD8317AC88369048994D45C2C0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151411.93764299097153346659294006287316:50001231000000:2800:AFD87D973867955200F3F8F51AAC116B35B444D074B202874BDF736516419945.png)
1.
2.  拷贝方法：不通过压缩直接将so文件拷贝到windows，或将so文件压缩成.zip格式拷贝到windows，正确拷贝so文件后，so文件大小应该与原库实体文件大小一致。 如果将so文件以tar、gz、7z、bzip2等压缩方式拷贝到windows后在解压，其文件是实体库的软连接，大小和实体库大小不一致，文件也不能正常使用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151411.67056855355383219762877790692935:50001231000000:2800:C7132CE21A232D08A3B50338EC184B4AAF5A8BAC88C8AAB797A73C2F873EE573.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151411.67422274226329897250547759227506:50001231000000:2800:830A33903E5710DEED63479908FF424832C039030C6BE7C59979E6CD45F5B71A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151411.75832519829890329607339103587250:50001231000000:2800:4EF73DE0A368C244941A07797645E646955328E4217A2380D291F3BA2C280ECF.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-custom-hvigor-plugin
爬取时间: 2025-05-01 09:49:08
来源: Huawei Developer
概述
在进行编译构建的过程中，开发者可以通过定制hvigor插件，扩展构建逻辑，实现个性化的打包流程。
定制hvigor插件，通常有以下目的：
-  每个项目可能有独特的构建需求和流程，定制插件可以根据项目的具体要求来扩展hvigor构建的功能。
-  定制插件可以将某些复杂的构建逻辑封装在同一个地方，使得项目的构建配置更加清晰和易于维护。可以自动化执行某些特定任务，减少手动干预，确保构建过程的一致可靠。
-  在团队开发中，定制插件可以确保所有团队成员使用相同的构建流程和标准，减少因个人配置差异导致的问题，从而提升团队协作的效率。
具体到应用场景上，定制插件可以根据不同的构建需求调整编译产物属性，从而实现灵活的构建管理。
本文以自定义编译产物的文件名及路径为案例来介绍如何定制hvigor插件。
基本概念
定制hvigor插件开发时，涉及以下概念：
实现原理
定制hvigor插件，就是在编译构建的过程中插入开发者需要的自定义任务，将这些自定义任务抽象后封装成可复用的部分，通过输出plugin插件的目标形式，实现编译构建个性化逻辑的复用和共享分发。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151411.40293114258883018920701014089933:50001231000000:2800:CF27926B591ED02F33DB151E2D2CAAFB19CE6AB223C004D1C669E02D228A6861.png)
如上图所示，hvigor插件的工作原理：
开发流程
hvigor主要提供了两种方式以实现插件的开发：
两种方式的核心逻辑实现类似，都是以TS文件编写Task任务方法，区别主要在共享和应用方式上。
二者对比如下：
|    | 插件项目  | 代码开发  | 共享方式  | 插件使用  | 特点总结  |
| --- | --- | --- | --- | --- | --- |
| 基于hvigorfile脚本  | 不创建项目  | 直接编辑工程/模块中hvigorfile.ts文件  | 不发布，复制代码实现共享  | 代码逻辑直接应用于编辑工程/模块  | 开发使用快速；共享复用不方便  |
| 基于typescript项目  | 新建npm项目  | 新建custom-plugin.ts文件  | npm打包发布共享，或离线包共享  | hvigor-config.json5中配置插件依赖，或安装离线包  | 易于分发、共享和维护；发布使用流程相对多  |
插件项目
代码开发
共享方式
插件使用
特点总结
基于hvigorfile脚本
不创建项目
直接编辑工程/模块中hvigorfile.ts文件
不发布，复制代码实现共享
代码逻辑直接应用于编辑工程/模块
开发使用快速；共享复用不方便
基于typescript项目
新建npm项目
新建custom-plugin.ts文件
npm打包发布共享，或离线包共享
hvigor-config.json5中配置插件依赖，或安装离线包
易于分发、共享和维护；发布使用流程相对多
下文的场景实例采用基于typescript项目开发的方法描述，开发者也可以将插件逻辑代码直接写于hvigorfile.ts中，切换为基于hvigorfile脚本开发的实现方式。
定制hvigor插件涉及的相关能力，可查阅扩展构建API。
自定义编译产物的文件名及路径
场景描述
以名为library的module生成HAR包为例，默认情况下，HAR包编译产物的生成路径在library/build/default/outputs/default目录下，文件名为library.har。
而开发者在用于生产的环境中，可能需要根据项目情况，使编译产物输出到指定路径，并更改其文件名，例如：带有版本号的文件名，或带有开发者名称等信息的文件名。
下面示例中用oh-package.json5中配置的属性修改HAR包文件名，同时将生成路径改为library/build/default/outputs/target。
开发步骤
1.
```typescript
import fs from 'fs'
interface OhPackage {
name: string;
version: number;
description: string;
author: string;
}
export function renameHarTask(str?: string) {
return {
pluginId: 'RenameHarTaskID',
apply(pluginContext) {
pluginContext.registerTask({
// 编写自定义任务
name: 'renameHarTask',
run: (taskContext) => {
// 读取oh-package.json5，解析出version
const packageFile = taskContext.modulePath+'\\oh-package.json5';
console.log('file: ', packageFile);
let fileContent = fs.readFileSync(packageFile, 'utf8');
console.log(fileContent);
const content: OhPackage = JSON.parse(fileContent);
const version = content.version;
const author = content.author;
console.log('renameHarTask: ', taskContext.moduleName, taskContext.modulePath);
const sourceFile = taskContext.modulePath + '\\build\\default\\outputs\\default\\' + taskContext.moduleName + '.har';
const targetPath = taskContext.modulePath + '\\build\\default\\outputs\\target\\';
const targetFile = targetPath
+ taskContext.moduleName + '-' + version + '-' + author +'.har';
console.log('renameHarTask: sourceFile: ', sourceFile);
console.log('renameHarTask: targetFile: ', targetFile);
// 创建目录
fs.mkdir(targetPath, { recursive: true }, (err) => {
if (err) throw err;
// 移动并修改产物文件名
fs.rename(sourceFile, targetFile, (err)=> {
console.log('err: ' + err);
});
});
},
// 确认自定义任务插入位置
dependencies: ['default@PackageHar'],
postDependencies: ['assembleHar']
})
}
}
}
```
2.
3.
4.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151411.00458794650768240411771420871674:50001231000000:2800:22F07C78987820AD631003DF64E73A3DA821E354B52831066F7B93A36FACF54F.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-target
爬取时间: 2025-05-01 09:49:25
来源: Huawei Developer
概述
多目标产物在HarmonyOS系统中的应用主要体现在软件开发与分发方面，特别是针对不同用户群体、不同业务场景的需求进行定制化开发。多目标产物为开发者提供了更加灵活和高效的开发方式，使得应用能够更好地适应市场需求和变化。通过定制化开发，还可以更好地满足用户的个性化需求，提升用户体验。
基本概念
在构建过程中，鸿蒙构建系统会根据配置文件中定义的product和target信息，生成相应的构建产物。对于每个target，构建系统会生成一个对应的HAP/HSP/HAR。这个HAP/HSP/HAR包含了该target所需的所有代码和资源。对于每个product，构建系统会生成一个包含了其所有依赖的target的App包。这个App包可以用于发布和上架到应用市场。
应用场景
主要应用场景:
针对以上场景，开发者需要通过修改build-profile.json5、module.json5等配置文件，定义出不同的product和target。在这些配置文件中，开发者不仅可以为每个target指定不同的设备类型、源码集、资源等，并且还可以根据业务需要为不同的product分配不同的target。然后在构建过程中，构建工具会根据这些配置生成不同的target，然后通过不同的target搭配构建出不同的product产物。
本文将通过一个具体的案例来介绍如何配置不同资源以及如何构建出多目标产物。
实现原理
HarmonyOS多目标产物支持HAP（应用安装的基本单位，每个HAP都对应一个应用模块）、HAR（静态共享包）、HSP（动态共享包）以及App（由多个HAP打包一起上架的完整应用程序）包多种类型的包，以满足不同业务场景下的应用开发和定制需求。
多目标产物定制项
目前多目标产物支持的定制项信息如下表所示，表中已给出每一项的作用。详细的每一个定制项的配置方法可以参考：配置多目标产物。
| 多目标模块  | 定制项  | 作用  |
| --- | --- | --- |
| HAP  | HAP包名（artifactName）  | 产品生成的应用包名称，可由数字、英文字母、中划线、下划线和英文句号（.）组成，支持输入版本号。  |
| 设备类型（deviceType）  | 用于配置支持的设备类型，如Phone、Tablet等。  |
| 源码集（source）  | target的源码范围： pages：定制pages源码目录的page页面，数组长度至少为1。sourceRoots：定制差异化代码空间，数组长度至少为1。  |
| 资源（resource）  | 配置需要的资源文件路径，支持配置多个资源文件路径。  |
| 分发规则（distributionFilter）  | 针对多target存在相同设备类型deviceType的场景，相同设备类型的target需要指定分发规则distributionFilter。  |
| 产物分包（preloads）  | 对于元服务，每一个target均可以指定preloads的分包。  |
| abilities能力项（icon、label和launchType）  | 定制产物图标、名称、启动模式。  |
| so库依赖（nativeLib-filter）  | 定制打包so库的过滤规则。  |
| HAR/HSP  | 设备类型（deviceType）  | 用于配置支持的设备类型，如Phone、Tablet等。  |
| so库依赖（nativeLib-filter）  | 定制打包so库的过滤规则。  |
| 源码集（source）  | target的源码范围： pages：定制pages源码目录的page页面，数组长度至少为1。sourceRoots：定制差异化代码空间，数组长度至少为1。  |
| 资源（resource）  | 配置需要的资源文件路径，支持配置多个资源文件路径。  |
| App  | App包名和供应商名称(artifactName、vendor)  | 指定产物命名和供应商名称。  |
| bundleName  | 定义工程的bundleName信息，在签名的时候可以选择对应的bundleName进行签名。如果product未定义bundleName，则采用工程默认的bundleName。  |
| bundleType  | 定义产物类型： bundleType值为app，表示产物为应用；bundleType值为atomicService，表示产物为元服务。  |
| 签名配置信息(signingConfig)  | 为不同产物定制不同的签名文件。  |
| 应用图标、名称（icon、label）  | 为不同产物定制不同的图标和名称。  |
| 依赖的模块（modules）  | 定义product中包含的target，每个product可以指定一个或多个target。  |
多目标模块
定制项
作用
HAP
HAP包名（artifactName）
产品生成的应用包名称，可由数字、英文字母、中划线、下划线和英文句号（.）组成，支持输入版本号。
设备类型（deviceType）
用于配置支持的设备类型，如Phone、Tablet等。
源码集（source）
target的源码范围：
资源（resource）
配置需要的资源文件路径，支持配置多个资源文件路径。
分发规则（distributionFilter）
针对多target存在相同设备类型deviceType的场景，相同设备类型的target需要指定分发规则distributionFilter。
产物分包（preloads）
对于元服务，每一个target均可以指定preloads的分包。
abilities能力项（icon、label和launchType）
定制产物图标、名称、启动模式。
so库依赖（nativeLib-filter）
定制打包so库的过滤规则。
HAR/HSP
设备类型（deviceType）
用于配置支持的设备类型，如Phone、Tablet等。
so库依赖（nativeLib-filter）
定制打包so库的过滤规则。
源码集（source）
target的源码范围：
资源（resource）
配置需要的资源文件路径，支持配置多个资源文件路径。
App
App包名和供应商名称(artifactName、vendor)
指定产物命名和供应商名称。
bundleName
定义工程的bundleName信息，在签名的时候可以选择对应的bundleName进行签名。如果product未定义bundleName，则采用工程默认的bundleName。
bundleType
定义产物类型：
签名配置信息(signingConfig)
为不同产物定制不同的签名文件。
应用图标、名称（icon、label）
为不同产物定制不同的图标和名称。
依赖的模块（modules）
定义product中包含的target，每个product可以指定一个或多个target。
综上所述，App、HAP、HAR、HSP包目前并不支持配置所有配置项的差异化定制，开发者在开发过程中需要根据已支持的配置项合理的进行多目标定制。
构建原理图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151411.38126673330912005959820042864428:50001231000000:2800:ECE75BD02357ACB4E55AF4483CE0A97E1B2EBAD76911232BD28A23B691EE19DC.png)
如图所示，在HarmonyOS应用开发过程中，一个应用通常包含多个HAR/HAP/HSP模块。每个HAR/HAP/HSP模块可以通过配置模块级的build-profile.json文件定义多个target，每个target可以定制不同的资源（具体可参考上文定制项介绍）。因此形成了具有差异性的target，如：Module A通过定制生成了TargetA-1、TargetA-2；Module B通过定制生成了TargetB-1、TargetB-2、TargetB-3；Module C通过定制生成了TargetC-1、TargetC-2。然后通过配置工程级的build-profile.json定义多个product，每个product可以依赖不同的Target并且配置不同的App产物定制项。因此形成了具有差异的product，如：依赖TargetA-1、TargetB-1、TargetC-1构建出App-product1；依赖TargetB-3、TargetC-2构建出App-product2。最终在构建工程时选择相应的product就可以显示出对应的定制效果。
开发流程
场景案例
本节主要根据一个案例介绍构建多目标产物的流程和方法，该案例可以由同一套源代码构建出Official版本（官方版）和Test版本（测试版）两个product工程。两个工程的实现效果如下：
Official版本：工程会在首页中显示Official版的资源以及一个页面跳转按钮，该页面是一个HAP模块页面。通过点击按钮可以跳转到Official版定制页面，该页面是一个HAR模块页面，其中包含了一个运算器。该运算器支持加法和减法。
Test版本：工程会在首页中显示Test版的资源以及一个页面跳转按钮，该页面是一个HAP模块页面。通过点击按钮可以跳转到Test版定制页面，该页面是一个HAR模块页面，其中包含了一个普通版的运算器。该运算器仅支持减法。
该案例包含了HAP、HAR、APP相关定制项，具体差异项信息如下：
| 定制模块  | Official版本定制项  | Test版本定制项  |
| --- | --- | --- |
| HAP模块(target)  | target名称officialsource源码集-pages资源文件目录source源码集-sourceRoots  | target名称testsource源码集-pages资源文件目录source源码集-sourceRoots  |
| HAR模块(target)  | target名称officialbuildProfileFields自定义参数产物名称source源码集-sourceRoots资源文件目录剔除的.so文件  | target名称testbuildProfileFields自定义参数产物名称source源码集-sourceRoots资源文件目录  |
| App工程（product）  | product名称official产物bundleName签名配置信息应用图标依赖的target  | product名称official产物bundleName签名配置信息应用图标依赖的target  |
定制模块
Official版本定制项
Test版本定制项
HAP模块(target)
HAR模块(target)
App工程（product）
1.  首先，根据上面案例设计和定制项表格可以确认我们需要定制两个product版本，即Official版本和Test版本。每个product需要依赖两个模块，即一个HAP模块和一个HAR模块。
2.  HAP模块：在模块级build-profile.json5文件中配置。 上述配置文件代码中，配置了official版本与test版本的target名称、source源码集-pages、source源码集-sourceRoots以及资源文件路径，因此我们需要在对应的目录结构下创建我们配置的文件以及目录。针对以上配置信息，我们需要创建pages目录下的Index.ets文件、src目录下的test_pages和official_pages目录以及src/main目录下的resource_test和resource_official目录。 在配置不同target的资源文件目录时，可以配置多个资源文件目录，建议将共有的资源文件放置到默认的资源文件目录中，将有差异的资源部分放置到定制的资源文件目录中，然后在配置资源目录时将默认的资源目录和定制的资源目录都加上。例如：案例中即给不同版本配置了两个资源目录，一个用于存放共有资源，一个存放不同target的差异性资源。 如果target引用的多个资源文件目录下，存在同名的资源，则在构建打包过程中，将按照配置的资源文件目录顺序进行选择。例如，上述official版target引用的资源中，resource_official和resource中存在同名的资源文件，则resource_official中的资源会被打包到HAP中。 * 配置文件中，default为创建工程时默认生成的target，一般无需特殊处理。 HAR模块：在模块级build-profile.json5文件中配置。 上述配置文件代码中，配置了official版本与test版本的target名称、buildProFields自定义参数、产物名称、source源码集-sourceRoots以及资源文件目录，并且在official版本中剔除了无需打包的.so文件。同样的，我们也需要创建我们需要的文件目录，因此我们需要在该HAR模块的src/main/目录下创建resources_test和resources_official文件夹，在src/目录下创建official_pages和test_pages文件夹。
3.  App工程：在工程级build-profile.json5文件中配置。 在该配置文件中，配置了product名称、产物bundleName、签名配置信息、应用图标、依赖的target信息。这里需要注意的是，依赖的HAR模块需要在引用他的模块内配置依赖关系。我们的案例是在entry模块里调用的HAR包，所以需要在其对应的oh-package.json5文件中配置dependencies依赖。
4.  在上述配置文件中，配置了HAP模块的source源码集-sourceRoots目录，official版本与test版本分别对应src/official_pages和src/test_pages。 分别在对应的sourceRoots目录下创建同名ets文件并创建同名同类型的方法，例如：示例中创建的是VersionInfo.ets文件。添加如下代码： src/official_pages/VersionInfo.ets src/test_pages/VersionInfo.ets 在Index.ets文件中，通过import packageName的方式，省略sourceRoot，可以实现不同target下的差异化构建（ import xxx from '<packageName>/sourceFileName'）。该能力具体可参考：source源码集-sourceRoots配置。 在上述配置文件中，我们配置了HAR模块的资源文件路径，official版本和test版本分别对应src/main/resources_official和src/main/resources_test文件。 分别在对应的资源文件目录下添加同名图片资源和json字符串。例如：示例中分别在资源文件目录下的media文件中放入同名的HarImage.jpg图片（图片内容不同），并在element文件下的string.json中添加同名参数"title_description"（其对应的"value"值不相同）。 在页面中直接引用对应同名资源即可，代码如下： 在先前的案例中，已经介绍了如何在sourceRoot目录配置的差异性代码空间中实现对同名文件中的同名方法的调用。这里主要介绍在不同的target中如何调用不同名的文件中的不同方法。 首先，需要通过配置文件中配置的自定义参数生成相应的BuildProfile.ets文件。上述HAR模块的配置文件中，我们配置了buildProfileFields自定义参数"productName",在official和test版本中分别配置了不同的值"official"和"test"。这样我们构建不同的产物版本就会生成不同的"productName"值，用于在代码工程中区分不同的产物版本。 然后，分别在official和test的对应的sourceRoots目录下创建不同的ets文件，并导出相应的组件。如示例中在HAR模块的src/official_pages目录下创建了OfficialSecondPages.ets并export了一个OfficialSecond组件，然后在src/test_pages目录下创建了TestSecondPages.ets并export了一个TestSecond组件。这两个组件中分别包含了不同的页面信息。 最后在首页中import相应的方法实现跳转逻辑。具体代码如下： 导入方法及组件： 定义页面跳转逻辑：接收到不同的参数值跳转不同页面。 为按钮添加点击属性，并传递自定义参数，用于实现Navigation路由跳转：
5.  在上述配置文件中，配置了HAP模块的source源码集-sourceRoots目录，official版本与test版本分别对应src/official_pages和src/test_pages。 分别在对应的sourceRoots目录下创建同名ets文件并创建同名同类型的方法，例如：示例中创建的是VersionInfo.ets文件。添加如下代码： src/official_pages/VersionInfo.ets src/test_pages/VersionInfo.ets 在Index.ets文件中，通过import packageName的方式，省略sourceRoot，可以实现不同target下的差异化构建（ import xxx from '<packageName>/sourceFileName'）。该能力具体可参考：source源码集-sourceRoots配置。
6.  在上述配置文件中，我们配置了HAR模块的资源文件路径，official版本和test版本分别对应src/main/resources_official和src/main/resources_test文件。 分别在对应的资源文件目录下添加同名图片资源和json字符串。例如：示例中分别在资源文件目录下的media文件中放入同名的HarImage.jpg图片（图片内容不同），并在element文件下的string.json中添加同名参数"title_description"（其对应的"value"值不相同）。 在页面中直接引用对应同名资源即可，代码如下：
7.  在先前的案例中，已经介绍了如何在sourceRoot目录配置的差异性代码空间中实现对同名文件中的同名方法的调用。这里主要介绍在不同的target中如何调用不同名的文件中的不同方法。 首先，需要通过配置文件中配置的自定义参数生成相应的BuildProfile.ets文件。上述HAR模块的配置文件中，我们配置了buildProfileFields自定义参数"productName",在official和test版本中分别配置了不同的值"official"和"test"。这样我们构建不同的产物版本就会生成不同的"productName"值，用于在代码工程中区分不同的产物版本。 然后，分别在official和test的对应的sourceRoots目录下创建不同的ets文件，并导出相应的组件。如示例中在HAR模块的src/official_pages目录下创建了OfficialSecondPages.ets并export了一个OfficialSecond组件，然后在src/test_pages目录下创建了TestSecondPages.ets并export了一个TestSecond组件。这两个组件中分别包含了不同的页面信息。 最后在首页中import相应的方法实现跳转逻辑。具体代码如下： 导入方法及组件： 定义页面跳转逻辑：接收到不同的参数值跳转不同页面。 为按钮添加点击属性，并传递自定义参数，用于实现Navigation路由跳转：
8.  首先点击DevEco Studio工具右上角的Product按钮，即图中的1号标识处，然后在2号标识处选择对应的product工程，选择完工程之后会自动映射出我们文件中已经依赖的target，最后点击Apply应用。上述操作完成之后就可以点击运行按钮查看多目标产物效果了。本案例运行效果图如下：
-  在上述配置文件中，配置了HAP模块的source源码集-sourceRoots目录，official版本与test版本分别对应src/official_pages和src/test_pages。 分别在对应的sourceRoots目录下创建同名ets文件并创建同名同类型的方法，例如：示例中创建的是VersionInfo.ets文件。添加如下代码： src/official_pages/VersionInfo.ets src/test_pages/VersionInfo.ets 在Index.ets文件中，通过import packageName的方式，省略sourceRoot，可以实现不同target下的差异化构建（ import xxx from '<packageName>/sourceFileName'）。该能力具体可参考：source源码集-sourceRoots配置。
-  在上述配置文件中，我们配置了HAR模块的资源文件路径，official版本和test版本分别对应src/main/resources_official和src/main/resources_test文件。 分别在对应的资源文件目录下添加同名图片资源和json字符串。例如：示例中分别在资源文件目录下的media文件中放入同名的HarImage.jpg图片（图片内容不同），并在element文件下的string.json中添加同名参数"title_description"（其对应的"value"值不相同）。 在页面中直接引用对应同名资源即可，代码如下：
-  在先前的案例中，已经介绍了如何在sourceRoot目录配置的差异性代码空间中实现对同名文件中的同名方法的调用。这里主要介绍在不同的target中如何调用不同名的文件中的不同方法。 首先，需要通过配置文件中配置的自定义参数生成相应的BuildProfile.ets文件。上述HAR模块的配置文件中，我们配置了buildProfileFields自定义参数"productName",在official和test版本中分别配置了不同的值"official"和"test"。这样我们构建不同的产物版本就会生成不同的"productName"值，用于在代码工程中区分不同的产物版本。 然后，分别在official和test的对应的sourceRoots目录下创建不同的ets文件，并导出相应的组件。如示例中在HAR模块的src/official_pages目录下创建了OfficialSecondPages.ets并export了一个OfficialSecond组件，然后在src/test_pages目录下创建了TestSecondPages.ets并export了一个TestSecond组件。这两个组件中分别包含了不同的页面信息。 最后在首页中import相应的方法实现跳转逻辑。具体代码如下： 导入方法及组件： 定义页面跳转逻辑：接收到不同的参数值跳转不同页面。 为按钮添加点击属性，并传递自定义参数，用于实现Navigation路由跳转：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151411.72687083085091677155732049624328:50001231000000:2800:A73BD37E66CB8A908FC393FF87A27AF51998B48EC44357A4AF9CD2CEDCA399EA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151411.67833210417305802867741190434548:50001231000000:2800:7992F2E2346908708B03A341879838F7FACF481F89C25CDAF81BC9171AA760B5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151411.78875184684280876420323223702359:50001231000000:2800:52C95D557648043FEB6B83281562B88D64F6B6B591289088804F9587F22B0E1E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151412.73319311133728456143620667839118:50001231000000:2800:DC17F94D32C87850D3B07D99A53836B17F1B5F3BC1F45CE2D308F3C8608E0673.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151412.20519266503612523442660433933353:50001231000000:2800:A9A8044B9C81707B5ED04FAD2E74058A50578E3B897A0D8290FC2AFD19C6AD23.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151412.59411670154278598141317873433753:50001231000000:2800:618773E1EDA6D737586B791A2C5440ADD58BB7B6B09F84ECEA4DA76F7064A48C.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151412.01372822258344038983577741460896:50001231000000:2800:281E505190241D71A53CF7444682BE05DF99422413547F215A1DF8138B65C81B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151412.55802106515914194696844224460219:50001231000000:2800:CA99C0EB3322096A445B94BFAE19F3E8C47A262E3C12545BC04F2DD378798BBC.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151412.38046530562372279169091021855754:50001231000000:2800:AF7857D9F3F014FB5E105513F6001385A371A949F46358F61904CFB95DEEECBD.gif)
常见问题
如何为不同的product产物配置签名信息？
配置工程级的build-porfile.json5文件.
首先需要在每个product下添加配置项"signingConfig"。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151412.60073491081874143500515010441821:50001231000000:2800:45F438E79E5544CEED9C76A4B02FF4DFA9D799EC29C02A4502F634C281791FF0.png)
然后进入到签名配置页面，点击加号，添加签名信息：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151412.39096262798307819983290807459065:50001231000000:2800:6508F2760D47F416A56142064FF9389BAB9F898DBAC1524AEB5FDC00C6A6F130.png)
然后选择对应的bundle name，并填写上面配置的"signingConfig"信息（每个product产物都需要配置）：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151412.88777619561507504711559719697277:50001231000000:2800:93DC4ADA198D8D5E1893923E460FEB9053B426FC03FDC5C6ACE7E7F4531E8508.png)
点击ok之后，进行签名即可。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151412.99971031420761335030834770325159:50001231000000:2800:D14CC5E6B1F9FCA7AC5F00E4B088C1F27308432BEDED021F4A1CC2FBABA45725.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/changelog
爬取时间: 2025-05-01 09:49:39
来源: Huawei Developer
2025年4月30日
新增文档
新增文档3篇，包括特性解决方案、系统和媒体。
特性解决方案
系统
媒体
2025年3月26日
新增文档
新增文档2篇，包括特性解决方案和应用质量。
特性解决方案
应用质量
删除文档
删除文档2篇。
特性解决方案
应用质量
2025年2月28日
目录结构变更
变更背景
为了更好地满足开发者在不同阶段的多样化需求，提升开发者的使用体验，对最佳实践目录结构进行了优化调整。最佳实践的目录结构从按照功能领域进行划分，优化为按照开发者旅程的维度进行分类。
无论是初学者还是有经验的开发者，都能够依据自身的开发进程快速定位到所需的最佳实践内容，更加直观地获取全面的指导信息，从而提高开发效率，加速HarmonyOS项目的开发进程。
变更内容
为了提升开发者的使用体验，对最佳实践的目录结构进行优化。
最佳实践结构目录优化调整：全文分为架构设计、功能开发、工具使用和文档变更说明四个类型。为给予开发者更好的文档阅读和使用体验，最佳实践按照架构设计、功能开发和工具使用三大类重新编排目录。变更前后如下图所指示：
变更效果
通过此次变更，实现了以下效果：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.28225692930664389728998816228772:50001231000000:2800:BF04C32E7655274B2362200359865940C43E0E2B6CAB916E2808D9B46895E0A7.png)
新增文档
新增文档2篇，包括媒体和文档变更说明。
媒体
文档变更说明
删除文档
删除文档2篇。
应用质量
应用架构
2025年1月26日
新增文档
新增60篇文章，包括HarmonyOS特征、业务场景与解决方案、功耗、安全、稳定性和功能开发模块。
HarmonyOS特征
业务场景与解决方案
功耗
安全
稳定性
功能开发
2024年12月27日
新增文档
新增11篇文章，包括HarmonyOS特征、业务场景与解决方案、功耗性能、安全和功能开发模块。
HarmonyOS特征
业务场景与解决方案
功耗性能
安全
功能开发
2024年11月27日
性能目录结构优化
变更内容
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.47210422198914674562674154201873:50001231000000:2800:629F7CE361515EBADC55A8A23944B262D180B7B584AFBB30980D7DDAA0487889.png)
新增文档
新增29篇文章，包括性能、安全、功能开发和工具开发模块。
-  应用闪屏问题解决方案：介绍在开发过程中遇到屏幕闪烁问题的原因分析、解决方案的具体步骤和注意事项等。
开发工具
优化文档
设备运行效果图优化
本次最佳实践优化内容为最佳实践设备运行效果图优化。对文档中的手机、折叠屏、平板、2in1、智慧屏和手表设备运行效果图进行了整体的优化，均加上了对应的真机机框效果。
前后对比效果如表所示。
| 设备名称  | 优化前  | 优化后  |
| --- | --- | --- |
| 手机  |   |   |
| 折叠屏  |   |   |
| 平板  |   |   |
| 2in1  |   |   |
| 智慧屏  |   |   |
| 手表  |   |   |
设备名称
优化前
优化后
手机
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.31202619767909072270117669536932:50001231000000:2800:6F93C9627B2B026D499FEED9AA239216900488991CBDAE8901808D4AB5DF6ED8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.82875268576848101323635866638697:50001231000000:2800:E81FE3E4650DD2B5AC5937A9500B31137BB289D269B038B9B26CF02ECCCEC395.png)
折叠屏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.94781095123165459693311649044581:50001231000000:2800:F35E56DF393373E1D610EAF00F9B8012AA09E408B5B7ADE4FB08F5F597014231.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.15469162836636372044811215389794:50001231000000:2800:CAF05FA7A1CE7C79AF5710C3B9F3F6C20D70A702B3A113731CBBB145A2346A42.png)
平板
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.30159188982110708325865290027400:50001231000000:2800:709D251308120F5875E51B8F17B90270A2AC0C80F3285928CA310CBD6F43BF8E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.71576486328039980768303436383497:50001231000000:2800:216C21E9EB88B944FEDFEF29BAD7AA2DAF2EDDA2A8F350652305CB0F5796CDF9.png)
2in1
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.05145112495156883009972446857180:50001231000000:2800:990E99E9B3F8B94DE87C4C3E4BB899AD51976C5412EAEC57EA63A2AC0F5212FE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171002.74080083649281865648971431764696:50001231000000:2800:E78D98B4AD399E91BCF78C196ED7F69F924F2F1256A925FCDF7D0E9EACA83D9F.png)
智慧屏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171003.47659370297901890712414256725491:50001231000000:2800:A1D16FB2E4A1797BED9CA7C7551D09FA13E60037CE5FACE7D2284671D911433A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171003.45205396289175613794169241129885:50001231000000:2800:AC0F26439E96973124331F2228982A0776BBE0E48FE4077918F5F77387F3E80A.png)
手表
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171003.90177685961323949914061315302741:50001231000000:2800:844409E55FD9C93218A70CDB32942A056FD71570CC3FA3EF0356D25F541A78CB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430171003.96261995619814516681054945430426:50001231000000:2800:D3729C730F3D7450696EB76CA9E21CA895A98C2081EBCC25A531F5F97C782401.png)
删除文档
删除文档2篇。
HarmonyOS特征
性能
2024年10月31日
归一化模板
针对系统级解决方案和场景化解决方案进行重新设计。从本期开始，新增的最佳实践内容均会采用新的内容结构进行呈现。存量内容会在后续陆续进行完成优化。
新增文档
新增文档29篇，包括HarmonyOS特征、性能、功耗、安全、功能开发和工具开发。
HarmonyOS特征
性能
功耗
安全
功能开发
开发工具
删除文档
删除文档1篇。
业务场景与解决方案
2024年9月27日
新增文档
新增文档7篇，包括HarmonyOS特征、功能开发和开发工具。
HarmonyOS特征：
功能开发：
开发工具：
删除文档
删除文档1篇。
功能开发
2024年8月30日
新增文档
新增13篇文章，包括HarmonyOS特征、业务场景与解决方案、性能、安全、功能开发和工具开发模块。
HarmonyOS特征
业务场景与解决方案
性能
功能开发
开发工具
删除文档
删除文档1篇。
功能开发
2024年7月30日
新增文档
新增11篇文章，包括业务场景与解决方案、性能、运维和功能开发模块。
业务场景与解决方案
性能
运维
功能开发
2024年7月12日
新增文档
新增16篇文章，包括HarmonyOS特征、业务场景与解决方案、功耗和功能开发模块。
HarmonyOS特征
业务场景与解决方案
功耗
功能开发
2024年5月
新增文档
新增7篇文章，包括HarmonyOS特征、业务场景与解决方案、性能、功耗和功能开发模块。
HarmonyOS特征
业务场景与解决方案
性能
功耗
功能开发
2024年4月
新增文档
新增9篇文章，包括HarmonyOS特征、性能、安全、运维和功能开发模块。
HarmonyOS特征
性能
安全
运维
功能开发
2024年3月
新增文档
新增12篇文章，包括HarmonyOS特征、架构、性能、安全、功能开发和开发工具模块。
HarmonyOS特征
架构
性能
安全
功能开发
开发工具
2024年1月
新增文档
新增9篇文章，包括HarmonyOS特征、性能、安全和功能开发模块。
HarmonyOS特征
性能
安全
功能开发
2023年11月
新增文档
新增11篇文章，包括HarmonyOS特征、性能、功耗、安全和功能开发模块。
HarmonyOS特征
性能
功耗
安全
功能开发
2023年9月
新增文档
新增8篇文章，包括HarmonyOS特征、架构、性能和功能开发模块。
HarmonyOS特征
架构
性能
功能开发


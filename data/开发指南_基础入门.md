# 合并文件
合并时间: 2025-04-27 21:50:14

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-dev-guide
爬取时间: 2025-04-27 21:36:15
来源: Huawei Developer
应用开发文档用于指导开发者通过HarmonyOS SDK提供的开放能力完成应用开发。在使用应用开发文档前，推荐您通过知识地图了解应用开发完整旅程。
在应用开发的文档中，您可以获取到如下内容。
入门
入门可以帮助开发者了解应用开发的基本方法。
通过这一部分内容的学习和初步实践，开发者可以快速构建出首个HarmonyOS应用，掌握应用程序包结构、资源文件的使用、以及ArkTS的核心功能和语法等基础知识，为后续的应用开发奠定基础。
开发
从HarmonyOS NEXT Developer Preview1（API 11）版本开始，HarmonyOS SDK以Kit维度提供丰富、完备的开放能力，涵盖应用框架、系统、媒体、图形、应用服务、AI六大领域，例如：
- 应用框架相关Kit开放能力：Ability Kit（程序框架服务）、ArkUI（方舟UI框架）等。
- 系统相关Kit开放能力：Universal Keystore  Kit（密钥管理服务）、Network Kit（网络服务）等。
- 媒体相关Kit开放能力：Audio Kit（音频服务）、Media Library Kit（媒体文件管理服务）等。
- 图形相关Kit开放能力：ArkGraphics 2D（方舟2D图形服务）、Graphics Accelerate Kit（图形加速服务）等。
- 应用服务相关Kit开放能力：Game Service Kit（游戏服务）、Location Kit（位置服务）等。
- AI相关Kit开放能力：Intents Kit（意图框架服务）、HiAI Foundation Kit（HiAI Foundation服务）等。
我们针对重点开放能力提供了开发指导，助力开发者高效开发。详情请参见“开发”目录下相关内容。
工具
DevEco Studio工具是HarmonyOS应用开发推荐的IDE工具。
在工具部分，讲解了DevEco Studio工具的详细用法，包括使用该工具进行工程创建、应用签名、应用调试、应用安装运行的指导。
API参考
API参考提供了HarmonyOS SDK各Kit开放能力的全量组件和接口的说明文档，可以帮助开发者快速查找到指定接口的详细描述和调用方法。详情请参见API参考。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/quick-start
爬取时间: 2025-04-27 21:36:28
来源: Huawei Developer
- 开发准备
- 构建第一个ArkTS应用（Stage模型）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/start-overview
爬取时间: 2025-04-27 21:36:42
来源: Huawei Developer
本文档适用于HarmonyOS应用开发的初学者。通过构建一个简单的具有页面跳转/返回功能的应用（如下图所示），快速了解工程目录的主要文件，熟悉HarmonyOS应用开发流程。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163447.26821339556492083375917047334556:50001231000000:2800:B14E4B6140FC10D048530739B0418FE71BF022CE8C17AE8104DD4077EB8A80A8.png)
在开始之前，您需要了解有关HarmonyOS应用的一些基本概念：UI框架的简单说明、应用模型的基本概念。
基本概念
UI框架
HarmonyOS提供了一套UI开发框架，即方舟开发框架（ArkUI框架）。方舟开发框架可为开发者提供应用UI开发所必需的能力，比如多种组件、布局计算、动画能力、UI交互、绘制等。
方舟开发框架针对不同目的和技术背景的开发者提供了两种开发范式，分别是基于ArkTS的声明式开发范式（简称“声明式开发范式”）和兼容JS的类Web开发范式（简称“类Web开发范式”）。以下是两种开发范式的简单对比。
| 开发范式名称  | 语言生态  | UI更新方式  | 适用场景  | 适用人群  |
| --- | --- | --- | --- | --- |
| 声明式开发范式  | ArkTS语言  | 数据驱动更新  | 复杂度较大、团队合作度较高的程序  | 移动系统应用开发人员、系统应用开发人员  |
| 类Web开发范式  | JS语言  | 数据驱动更新  | 界面较为简单的程序应用和卡片  | Web前端开发人员  |
开发范式名称
语言生态
UI更新方式
适用场景
适用人群
声明式开发范式
ArkTS语言
数据驱动更新
复杂度较大、团队合作度较高的程序
移动系统应用开发人员、系统应用开发人员
类Web开发范式
JS语言
数据驱动更新
界面较为简单的程序应用和卡片
Web前端开发人员
更多UI框架的开发内容及指导，详见UI开发。
应用模型
应用模型是HarmonyOS为开发者提供的应用程序所需能力的抽象提炼，它提供了应用程序必备的组件和运行机制。有了应用模型，开发者可以基于一套统一的模型进行应用开发，使应用开发更简单、高效。
随着系统的演进发展，HarmonyOS先后提供了两种应用模型：
- FA（Feature Ability）模型：HarmonyOS API 7开始支持的模型，已经不再主推。FA模型开发可见FA模型开发概述。快速入门章节不再对此展开提供开发指导。
- Stage模型：HarmonyOS API 9开始新增的模型，是目前主推且会长期演进的模型。在该模型中，由于提供了AbilityStage、WindowStage等类作为应用组件和Window窗口的“舞台”，因此称这种应用模型为Stage模型。Stage模型开发可见Stage模型开发概述。快速入门以此为例提供开发指导。
FA模型和Stage模型的整体架构和设计思想等更多区别，请见应用模型。
快速入门提供了一个含有两个页面的开发实例，并基于Stage模型构建第一个ArkTS应用，以便开发者理解以上基本概念及应用开发流程。
工具准备
请安装最新版DevEco Studio。
完成上述操作及基本概念的理解后，可参照构建第一个ArkTS应用（Stage模型）进行下一步体验和学习。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/start-with-ets-stage
爬取时间: 2025-04-27 21:36:56
来源: Huawei Developer
为确保运行效果，本文以使用最新DevEco Studio版本为例。
创建ArkTS工程
1.  若开发者需要进行Native相关工程的开发，请选择Native C++模板，更多模板的使用和说明请见工程模板介绍。
2.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163447.23647959631493524583156981990595:50001231000000:2800:C1E98718CD48FB83CF877AD97152CBE9FD21595F09264C45C965864C68476C69.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163447.14975380765051786748713122744353:50001231000000:2800:5AF72C7578C579A57068B4FF65A49FBC188BE288D45E29710864D4EF661C07D1.png)
ArkTS工程目录结构（Stage模型）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163447.83020484504170391819695726631480:50001231000000:2800:49090223CE24A88D8AAEC735A75B5CD5802AD61D70DFC3CC0A46A1C5B8CD2890.png)
- AppScope > app.json5：应用的全局配置信息，详见app.json5配置文件。
- entry：HarmonyOS工程模块，编译构建生成一个HAP包。src > main > ets：用于存放ArkTS源码。src > main > ets > entryability：应用/服务的入口。src > main > ets > entrybackupability：应用提供扩展的备份恢复能力。src > main > ets > pages：应用/服务包含的页面。src > main > resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件，详见资源分类与访问。src > main > module.json5：模块配置文件。主要包含HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。具体的配置文件说明，详见module.json5配置文件。build-profile.json5：当前的模块信息 、编译信息配置项，包括buildOption、targets配置等。hvigorfile.ts：模块级编译构建任务脚本。obfuscation-rules.txt：混淆规则文件。混淆开启后，在使用Release模式进行编译时，会对代码进行编译、混淆及压缩处理，保护代码资产。详见开启代码混淆。oh-package.json5：用来描述包名、版本、入口文件（类型声明文件）和依赖项等信息。
- src > main > ets：用于存放ArkTS源码。
- src > main > ets > entryability：应用/服务的入口。
- src > main > ets > entrybackupability：应用提供扩展的备份恢复能力。
- src > main > ets > pages：应用/服务包含的页面。
- src > main > resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件，详见资源分类与访问。
- src > main > module.json5：模块配置文件。主要包含HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。具体的配置文件说明，详见module.json5配置文件。
- build-profile.json5：当前的模块信息 、编译信息配置项，包括buildOption、targets配置等。
- hvigorfile.ts：模块级编译构建任务脚本。
- obfuscation-rules.txt：混淆规则文件。混淆开启后，在使用Release模式进行编译时，会对代码进行编译、混淆及压缩处理，保护代码资产。详见开启代码混淆。
- oh-package.json5：用来描述包名、版本、入口文件（类型声明文件）和依赖项等信息。
- oh_modules：用于存放三方库依赖信息。
- build-profile.json5：工程级配置信息，包括签名signingConfigs、产品配置products等。其中products中可配置当前运行环境，默认为HarmonyOS。
- hvigorfile.ts：工程级编译构建任务脚本。
- oh-package.json5：主要用来描述全局配置，如：依赖覆盖（overrides）、依赖关系重写（overrideDependencyMap）和参数化配置（parameterFile）等。
- src > main > ets：用于存放ArkTS源码。
- src > main > ets > entryability：应用/服务的入口。
- src > main > ets > entrybackupability：应用提供扩展的备份恢复能力。
- src > main > ets > pages：应用/服务包含的页面。
- src > main > resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件，详见资源分类与访问。
- src > main > module.json5：模块配置文件。主要包含HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。具体的配置文件说明，详见module.json5配置文件。
- build-profile.json5：当前的模块信息 、编译信息配置项，包括buildOption、targets配置等。
- hvigorfile.ts：模块级编译构建任务脚本。
- obfuscation-rules.txt：混淆规则文件。混淆开启后，在使用Release模式进行编译时，会对代码进行编译、混淆及压缩处理，保护代码资产。详见开启代码混淆。
- oh-package.json5：用来描述包名、版本、入口文件（类型声明文件）和依赖项等信息。
构建第一个页面
1.  工程同步完成后，在Project窗口，点击entry > src > main > ets > pages，打开Index.ets文件，进行页面的编写。 针对本文中使用文本/按钮来实现页面跳转/返回的应用场景，页面均使用Row和Column组件来组建布局。对于更多复杂元素对齐的场景，可选择使用RelativeContainer组件进行布局。 Index.ets文件的示例如下：
```typescript
// Index.ets
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
.width('100%')
}
.height('100%')
}
}
```
2.  在默认页面基础上，我们添加一个Button组件，作为按钮响应用户点击，从而实现跳转到另一个页面。Index.ets文件的示例如下：
```typescript
// Index.ets
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
// 添加按钮，以响应用户点击
Button() {
Text('Next')
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
.type(ButtonType.Capsule)
.margin({
top: 20
})
.backgroundColor('#0D9FFB')
.width('40%')
.height('5%')
}
.width('100%')
}
.height('100%')
}
}
```
3.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163447.94259063632364815889842874820656:50001231000000:2800:C5DECE7E8F96DDBBED40B01287B56CE7BC60FE192B93DF41572F150EF550822A.png)
构建第二个页面
1.  新建第二个页面文件。在Project窗口，打开entry > src > main > ets，右键点击pages文件夹，选择New > ArkTS File，命名为Second，点击回车键。可以看到文件目录结构如下： 开发者也可以在右键点击pages文件夹时，选择New > Page> Empty Page，命名为Second，点击Finish完成第二个页面的创建。使用此种方式则无需再进行下文中第二个页面路由的手动配置。 配置第二个页面的路由。在Project窗口，打开entry > src > main > resources > base > profile，在main_pages.json文件中的"src"下配置第二个页面的路由"pages/Second"。示例如下：
```json
{
"src": [
"pages/Index",
"pages/Second"
]
}
```
2.  新建第二个页面文件。在Project窗口，打开entry > src > main > ets，右键点击pages文件夹，选择New > ArkTS File，命名为Second，点击回车键。可以看到文件目录结构如下： 开发者也可以在右键点击pages文件夹时，选择New > Page> Empty Page，命名为Second，点击Finish完成第二个页面的创建。使用此种方式则无需再进行下文中第二个页面路由的手动配置。
3.  配置第二个页面的路由。在Project窗口，打开entry > src > main > resources > base > profile，在main_pages.json文件中的"src"下配置第二个页面的路由"pages/Second"。示例如下：
```json
{
"src": [
"pages/Index",
"pages/Second"
]
}
```
4.  参照第一个页面，在第二个页面添加Text组件、Button组件等，并设置其样式。Second.ets文件的示例如下：
```typescript
// Second.ets
@Entry
@Component
struct Second {
@State message: string = 'Hi there';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Button() {
Text('Back')
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
.type(ButtonType.Capsule)
.margin({
top: 20
})
.backgroundColor('#0D9FFB')
.width('40%')
.height('5%')
}
.width('100%')
}
.height('100%')
}
}
```
- 新建第二个页面文件。在Project窗口，打开entry > src > main > ets，右键点击pages文件夹，选择New > ArkTS File，命名为Second，点击回车键。可以看到文件目录结构如下：说明开发者也可以在右键点击pages文件夹时，选择New > Page> Empty Page，命名为Second，点击Finish完成第二个页面的创建。使用此种方式则无需再进行下文中第二个页面路由的手动配置。
- 配置第二个页面的路由。在Project窗口，打开entry > src > main > resources > base > profile，在main_pages.json文件中的"src"下配置第二个页面的路由"pages/Second"。示例如下：
{"src":["pages/Index","pages/Second"]}
- {
- "src":[
- "pages/Index",
- "pages/Second"
- ]
- }
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163447.61303038005480126815766340432112:50001231000000:2800:D66B2ECC8FF5FA8143135B7E1D1C828325330791BD7286EB397AA254E0E3355A.png)
实现页面间的跳转
页面间的导航可以通过页面路由router来实现。页面路由router根据页面url找到目标页面，从而实现跳转。使用页面路由请导入router模块。
如果需要实现更好的转场动效，推荐使用Navigation。
1.  在第一个页面中，跳转按钮绑定onClick事件，点击按钮时跳转到第二页。Index.ets文件的示例如下：
```typescript
// Index.ets
// 导入页面路由模块
import { router } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
// 添加按钮，以响应用户点击
Button() {
Text('Next')
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
.type(ButtonType.Capsule)
.margin({
top: 20
})
.backgroundColor('#0D9FFB')
.width('40%')
.height('5%')
// 跳转按钮绑定onClick事件，点击时跳转到第二页
.onClick(() => {
console.info(`Succeeded in clicking the 'Next' button.`)
// 跳转到第二页
router.pushUrl({ url: 'pages/Second' }).then(() => {
console.info('Succeeded in jumping to the second page.')
}).catch((err: BusinessError) => {
console.error(`Failed to jump to the second page. Code is ${err.code}, message is ${err.message}`)
})
})
}
.width('100%')
}
.height('100%')
}
}
```
2.  在第二个页面中，返回按钮绑定onClick事件，点击按钮时返回到第一页。Second.ets文件的示例如下：
```typescript
// Second.ets
// 导入页面路由模块
import { router } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
@Entry
@Component
struct Second {
@State message: string = 'Hi there';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Button() {
Text('Back')
.fontSize(30)
.fontWeight(FontWeight.Bold)
}
.type(ButtonType.Capsule)
.margin({
top: 20
})
.backgroundColor('#0D9FFB')
.width('40%')
.height('5%')
// 返回按钮绑定onClick事件，点击按钮时返回到第一页
.onClick(() => {
console.info(`Succeeded in clicking the 'Back' button.`)
try {
// 返回第一页
router.back()
console.info('Succeeded in returning to the first page.')
} catch (err) {
let code = (err as BusinessError).code;
let message = (err as BusinessError).message;
console.error(`Failed to return to the first page. Code is ${code}, message is ${message}`)
}
})
}
.width('100%')
}
.height('100%')
}
}
```
3.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163447.75296375733255835059465677419396:50001231000000:2800:FAF2F06BA3BD5A3A8A07319FDEF00D4468F0F5BD740017D4072509952CB9ADE1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163448.63048433057449151688130507022964:50001231000000:2800:354BBFB8C5AB9DE2ACF35BFC14807AD8DC0907FA6D12FCC59523FE1855F161FB.png)
使用真机运行应用
1.
2.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163448.10453372014233773223771791110329:50001231000000:2800:1288B17EF6A81DEDDCCAC953885AD6CADE2E2D1CDA76709AC0855697FB52F089.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163448.35834379736264620569274947043182:50001231000000:2800:8BB487C71891A1D9D81B52BA9A52C53CFDB44B357099DAAD8DF0C8230A854533.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163448.27888397725781839956133493806654:50001231000000:2800:8E4C2AA5D6F9D929C2F871B481DC3295C3029A0BC9671086AB383672A4B3099C.png)
恭喜您已经基于Stage模型构建完成第一个ArkTS应用，快来探索更多的HarmonyOS功能吧。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/development-fundamentals
爬取时间: 2025-04-27 21:37:09
来源: Huawei Developer
- 应用程序包术语
- 应用程序包基础知识
- 应用配置文件（Stage模型）
- 应用配置文件（FA模型）
- 典型场景的开发指导

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-package-glossary
爬取时间: 2025-04-27 21:37:23
来源: Huawei Developer
E
ExtensionAbility
Stage模型中的组件类型名，即ExtensionAbility组件，提供特定场景（如卡片、输入法）的扩展能力，满足更多的使用场景。
F
FA
Feature Ability，在FA模型中代表有界面的Ability，用于与用户进行交互。
FA模型
API version 8及更早版本支持的应用模型，已经不再主推。建议使用新的Stage模型进行开发。
H
HAP
Harmony Ability Package，一个HAP文件包含应用的所有内容，由代码、资源、三方库及应用配置文件组成，其文件后缀名为.hap。
HAR
Harmony Archive Package，静态共享包，编译态复用。可以包含代码、C++库、资源和配置文件，其文件后缀名为.har，用于实现代码和资源的共享。
HSP
Harmony Shared Package，动态共享包，运行时复用。可以包含代码、C++库、资源和配置文件，其文件后缀名为.hsp，用于实现代码和资源的共享。
M
Module
模块，应用的一部分，每个模块都有单独的module.json5配置文件。项目工程中，Entry、Feature、HSP和HAR均为应用的一个模块。
P
PA
Particle Ability，在FA模型中代表无界面的Ability，主要为Feature Ability提供支持，例如作为后台服务提供计算能力，或作为数据仓库提供数据访问能力。
S
Stage模型
API version 9开始新增的应用模型，提供UIAbility、ExtensionAbility两大类应用组件。由于该模型还提供了AbilityStage、WindowStage等类作为应用组件和Window窗口的“舞台”，因此称之为Stage模型。
U
UIAbility
Stage模型中的组件类型名，即UIAbility组件，包含UI，提供展示UI的能力，主要用于和用户交互。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-package-fundamentals
爬取时间: 2025-04-27 21:37:37
来源: Huawei Developer
- 应用程序包概述
- 应用程序包结构
- 应用程序包开发与使用
- 应用程序包安装卸载与更新

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-package-overview
爬取时间: 2025-04-27 21:37:50
来源: Huawei Developer
在基于Stage模型开发应用之前，开发者需要了解应用的设计机制、应用程序包结构等基础知识。
应用与应用程序包
用户应用程序泛指运行在设备的操作系统之上，为用户提供特定服务的程序，简称“应用”。一个应用所对应的软件包文件，称为“应用程序包”。
当前系统提供了应用程序包开发、安装、查询、更新、卸载的管理机制，便于开发者开发和管理应用。同时，系统还屏蔽了不同的芯片平台的差异（包括x86/ARM，32位/64位等），应用程序包在不同的芯片平台都能够安装运行，这使得开发者可以聚焦于应用的功能实现。
应用的多Module设计机制
- 支持模块化开发：一个应用通常会包含多种功能，将不同的功能特性按模块来划分和管理是一种良好的设计方式。在开发过程中，我们可以将每个功能模块作为一个独立的Module进行开发，Module中可以包含源代码、资源文件、第三方库、配置文件等，每一个Module可以独立编译，实现特定的功能。这种模块化、松耦合的应用管理方式有助于应用的开发、维护与扩展。
- 支持多设备适配：一个应用往往需要适配多种设备类型，在采用多Module设计的应用中，每个Module都会标注所支持的设备类型。有些Module支持全部类型的设备，有些Module只支持某一种或几种类型的设备（比如平板），那么在应用市场分发应用包时，也能够根据设备类型做精准的筛选和匹配，从而将不同的包合理的组合和部署到对应的设备上。
Module类型
Module按照使用场景可以分为两种类型：
- Ability类型的Module：用于实现应用的功能和特性。每一个Ability类型的Module编译后，会生成一个以.hap为后缀的文件，我们称其为HAP（Harmony Ability Package）包。HAP包可以独立安装和运行，是应用安装的基本单位，一个应用中可以包含一个或多个HAP包，具体包含如下两种类型。entry类型的Module：应用的主模块，包含应用的入口界面、入口图标和主功能特性，编译后生成entry类型的HAP。每一个应用分发到同一类型的设备上的应用程序包，只能包含唯一一个entry类型的HAP，也可以不包含。feature类型的Module：应用的动态特性模块，编译后生成feature类型的HAP。一个应用中可以包含一个或多个feature类型的HAP，也可以不包含。
- entry类型的Module：应用的主模块，包含应用的入口界面、入口图标和主功能特性，编译后生成entry类型的HAP。每一个应用分发到同一类型的设备上的应用程序包，只能包含唯一一个entry类型的HAP，也可以不包含。
- feature类型的Module：应用的动态特性模块，编译后生成feature类型的HAP。一个应用中可以包含一个或多个feature类型的HAP，也可以不包含。
- Library类型的Module：用于实现代码和资源的共享。同一个Library类型的Module可以被其他的Module多次引用，合理地使用该类型的Module，能够降低开发和维护成本。Library类型的Module分为Static和Shared两种类型，编译后会生成共享包。Static Library：静态共享库。编译后会生成一个以.har为后缀的文件，即静态共享包HAR（Harmony Archive）。Shared Library：动态共享库。编译后会生成一个以.hsp为后缀的文件，即动态共享包HSP（Harmony Shared Package）。说明实际上，Shared Library编译后除了会生成一个.hsp文件，还会生成一个.har文件。这个.har文件中包含了HSP对外导出的接口，应用中的其他模块需要通过.har文件来引用HSP的功能。为了表述方便，我们通常认为Shared Library编译后生成HSP。HAR与HSP两种共享包的主要区别体现在：共享包类型编译和运行方式发布和引用方式HARHAR中的代码和资源跟随使用方编译，如果有多个使用方，它们的编译产物中会存在多份相同拷贝。注意：编译HAR时，建议开启混淆能力，保护代码资产。HAR除了支持应用内引用，还可以独立打包发布，供其他应用引用。HSPHSP中的代码和资源可以独立编译，运行时在一个进程中代码也只会存在一份。HSP一般随应用进行打包，当前支持应用内和集成态HSP。应用内HSP只支持应用内引用，集成态HSP支持发布到ohpm私仓和跨应用引用。图1HAR和HSP在APP包中的形态示意图
- Static Library：静态共享库。编译后会生成一个以.har为后缀的文件，即静态共享包HAR（Harmony Archive）。
- Shared Library：动态共享库。编译后会生成一个以.hsp为后缀的文件，即动态共享包HSP（Harmony Shared Package）。
- entry类型的Module：应用的主模块，包含应用的入口界面、入口图标和主功能特性，编译后生成entry类型的HAP。每一个应用分发到同一类型的设备上的应用程序包，只能包含唯一一个entry类型的HAP，也可以不包含。
- feature类型的Module：应用的动态特性模块，编译后生成feature类型的HAP。一个应用中可以包含一个或多个feature类型的HAP，也可以不包含。
- Static Library：静态共享库。编译后会生成一个以.har为后缀的文件，即静态共享包HAR（Harmony Archive）。
- Shared Library：动态共享库。编译后会生成一个以.hsp为后缀的文件，即动态共享包HSP（Harmony Shared Package）。
| 共享包类型 | 编译和运行方式 | 发布和引用方式 |
| --- | --- | --- |
| HAR | HAR中的代码和资源跟随使用方编译，如果有多个使用方，它们的编译产物中会存在多份相同拷贝。 注意：编译HAR时，建议开启混淆能力，保护代码资产。  | HAR除了支持应用内引用，还可以独立打包发布，供其他应用引用。 |
| HSP | HSP中的代码和资源可以独立编译，运行时在一个进程中代码也只会存在一份。 | HSP一般随应用进行打包，当前支持应用内和集成态HSP。应用内HSP只支持应用内引用，集成态HSP支持发布到ohpm私仓和跨应用引用。 |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163448.01907612198694507325790621667804:50001231000000:2800:24484CC251A392090C36B7343BB40A06638446CCF6724B4D5EB46F52DB677415.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-package-structure
爬取时间: 2025-04-27 21:38:04
来源: Huawei Developer
- Stage模型应用程序包结构
- FA模型应用程序包结构

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-package-structure-stage
爬取时间: 2025-04-27 21:38:17
来源: Huawei Developer
为了让开发者能对应用程序包在不同阶段的形态有更加清晰的认知，分别对开发态、编译态、发布态的应用程序结构展开介绍。
开发态包结构
在DevEco Studio上创建一个项目工程，并尝试创建多个不同类型的Module。根据实际工程中的目录对照本章节进行学习，可以有助于理解开发态的应用程序结构。
图1项目工程结构示意图（以实际为准）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163448.18246028731183456914878899976860:50001231000000:2800:BF28CC39EE8BEE0FEE78E169544204FF3F384F50DF6BC993A6F8CAF24850B26D.png)
工程结构主要包含的文件类型及用途如下：
- AppScope目录由DevEco Studio自动生成，不可更改。
- Module目录名称可以由DevEco Studio自动生成（比如entry、library等），也可以自定义。为了便于说明，下表中统一采用Module_name表示。
| 文件类型 | 说明 |
| --- | --- |
| 配置文件 |  包括应用级配置信息、以及Module级配置信息： - AppScope > app.json5：app.json5配置文件，用于声明应用的全局配置信息，比如应用Bundle名称、应用名称、应用图标、应用版本号等。 - Module_name > src > main > module.json5：module.json5配置文件，用于声明Module基本信息、支持的设备类型、所含的组件信息、运行所需申请的权限等。 |
| ArkTS源码文件 | Module_name > src > main > ets：用于存放Module的ArkTS源码文件（.ets文件）。 |
| 资源文件 |  包括应用级资源文件、以及Module级资源文件，支持图形、多媒体、字符串、布局文件等，详见资源分类与访问。 - AppScope > resources ：用于存放应用需要用到的资源文件。 - Module_name > src > main > resources ：用于存放该Module需要用到的资源文件。 |
| 其他配置文件 |  用于编译构建，包括构建配置文件、编译构建任务脚本、混淆规则文件、依赖的共享包信息等。 - build-profile.json5：工程级或Module级的构建配置文件，包括应用签名、产品配置等。 - hvigorfile.ts：应用级或Module级的编译构建任务脚本，开发者可以自定义编译构建工具版本、控制构建行为的配置参数。 - obfuscation-rules.txt：混淆规则文件。混淆开启后，在使用Release模式进行编译时，会对代码进行编译、混淆及压缩处理，保护代码资产。 - oh-package.json5：用于存放依赖库的信息，包括所依赖的三方库和共享包。 |
包括应用级配置信息、以及Module级配置信息：
-AppScope > app.json5：app.json5配置文件，用于声明应用的全局配置信息，比如应用Bundle名称、应用名称、应用图标、应用版本号等。
-Module_name > src > main > module.json5：module.json5配置文件，用于声明Module基本信息、支持的设备类型、所含的组件信息、运行所需申请的权限等。
包括应用级资源文件、以及Module级资源文件，支持图形、多媒体、字符串、布局文件等，详见资源分类与访问。
-AppScope > resources：用于存放应用需要用到的资源文件。
-Module_name > src > main > resources：用于存放该Module需要用到的资源文件。
用于编译构建，包括构建配置文件、编译构建任务脚本、混淆规则文件、依赖的共享包信息等。
-build-profile.json5：工程级或Module级的构建配置文件，包括应用签名、产品配置等。
-hvigorfile.ts：应用级或Module级的编译构建任务脚本，开发者可以自定义编译构建工具版本、控制构建行为的配置参数。
-obfuscation-rules.txt：混淆规则文件。混淆开启后，在使用Release模式进行编译时，会对代码进行编译、混淆及压缩处理，保护代码资产。
-oh-package.json5：用于存放依赖库的信息，包括所依赖的三方库和共享包。
编译态包结构
不同类型的Module编译后会生成对应的HAP、HAR、HSP等文件，开发态视图与编译态视图的对照关系如下：
图2开发态与编译态的工程结构视图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163448.60557270990854979711205278481223:50001231000000:2800:018DC9F30DFE69ADC4BA2E2501614972C2EAD5D1A5FEEC5FC1A68589D3A08B55.png)
从开发态到编译态，Module中的文件会发生如下变更：
- ets目录：ArkTS源码编译生成.abc文件。
- resources目录：AppScope目录下的资源文件会合入到Module下面资源目录中，如果两个目录下存在重名文件，编译打包后只会保留AppScope目录下的资源文件。
- module配置文件：AppScope目录下的app.json5文件字段会合入到Module下面的module.json5文件之中，编译后生成HAP或HSP最终的module.json文件。
在编译HAP和HSP时，会把他们所依赖的HAR直接编译到HAP和HSP中。
发布态包结构
每个应用中至少包含一个.hap文件，可能包含若干个.hsp文件、也可能不含，一个应用中的所有.hap与.hsp文件合在一起称为Bundle，其对应的bundleName是应用的唯一标识（详见app.json5配置文件中的bundleName标签）。
当应用发布上架到应用市场时，需要将Bundle打包为一个.app后缀的文件用于上架，这个.app文件称为App Pack（Application Package），与此同时，DevEco Studio工具自动会生成一个pack.info文件。pack.info文件描述了App Pack中每个HAP和HSP的属性，包含APP中的bundleName和versionCode信息、以及Module中的name、type和abilities等信息。
- App Pack是发布上架到应用市场的基本单元，但是不能在设备上直接安装和运行。
- 在应用签名、云端分发、端侧安装时，都是以HAP/HSP为单位进行签名、分发和安装的。
图3编译发布与上架部署流程图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163448.76306737244935176458393437225397:50001231000000:2800:F133A33536AEC152794267081D3B1B94290EB6C0E643434C644F571D6CF58B63.png)
选择合适的包类型
HAP、HAR、HSP三者的功能和使用场景总结对比如下：
| Module类型 | 包类型 | 说明 |
| --- | --- | --- |
| Ability | HAP | 应用的功能模块，可以独立安装和运行，必须包含一个entry类型的HAP，可选包含一个或多个feature类型的HAP。 |
| Static Library | HAR |  静态共享包，编译态复用。 - 支持应用内共享，也可以发布后供其他应用使用。 - 作为二方库，发布到OHPM私仓，供公司内部其他应用使用。 - 作为三方库，发布到OHPM中心仓，供其他应用使用。 - 多包（HAP/HSP）引用相同的HAR时，会造成多包间代码和资源的重复拷贝，从而导致应用包膨大。 - 注意：编译HAR时，建议开启混淆能力，保护代码资产。 |
| Shared Library | HSP |  动态共享包，运行时复用。 - 当多包（HAP/HSP）同时引用同一个共享包时，采用HSP替代HAR，可以避免HAR造成的多包间代码和资源的重复拷贝，从而减小应用包大小。 |
静态共享包，编译态复用。
- 支持应用内共享，也可以发布后供其他应用使用。
- 作为二方库，发布到OHPM私仓，供公司内部其他应用使用。
- 作为三方库，发布到OHPM中心仓，供其他应用使用。
- 多包（HAP/HSP）引用相同的HAR时，会造成多包间代码和资源的重复拷贝，从而导致应用包膨大。
- 注意：编译HAR时，建议开启混淆能力，保护代码资产。
动态共享包，运行时复用。
- 当多包（HAP/HSP）同时引用同一个共享包时，采用HSP替代HAR，可以避免HAR造成的多包间代码和资源的重复拷贝，从而减小应用包大小。
HAP、HSP、HAR支持的规格对比如下，其中“√”表示是，“×”表示否。
开发者可以根据实际场景所需的能力，选择相应类型的包进行开发。在后续的章节中还会针对如何使用HAP、HAR、HSP分别展开详细介绍。
| 规格 | HAP | HAR | HSP |
| --- | --- | --- | --- |
| 支持在配置文件中声明UIAbility组件 | √ | √ | √ |
| 支持在配置文件中声明ExtensionAbility组件 | √ | × | × |
| 支持在配置文件中声明pages页面 | √ | × | √ |
| 支持包含资源文件与.so文件 | √ | √ | √ |
| 支持依赖其他HAR文件 | √ | √ | √ |
| 支持依赖其他HSP文件 | √ | √ | √ |
| 支持在设备上独立安装运行 | √ | × | × |
- 如果HAR支持声明pages页面，那么当HAR被打包到HAP或HSP中时，其内部声明的pages页面可能会与HAP/HSP中的pages页面存在相对路径上的重复，这将导致无法根据相对路径识别特定的路由页面。因此，HAR不支持在配置文件中声明pages页面，但可以包含pages页面，并通过命名路由的方式进行跳转。
- 由于HSP仅支持应用内共享，如果HAR依赖了HSP，则该HAR文件仅支持应用内共享，不支持发布到二方仓或三方仓供其他应用使用，否则会导致编译失败。
- HAR和HSP均不支持循环依赖，也不支持依赖传递。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-package-structure-fa
爬取时间: 2025-04-27 21:38:30
来源: Huawei Developer
基于FA模型开发的应用，其应用程序包结构如下图应用程序包结构（FA模型）所示。开发者需要熟悉应用程序包结构相关的基本概念。
FA模型与Stage模型不同之处在于HAP内部文件存放位置不同，FA模型将所有的资源文件、库文件和代码文件都放在assets文件夹中，在文件夹内部进一步区分。
- config.json是应用配置文件，DevEco Studio会自动生成一部分模块代码，开发者按需修改其中的配置。详细字段请参见应用配置文件。
- assets是HAP所有的资源文件、库文件和代码文件的集合，内部可以分为entry和js文件夹。entry文件夹中存放的是resources目录和resources.index文件。
- resources目录用于存放应用的资源文件（字符串、图片等），便于开发者使用和维护，详见资源文件的使用。
- resources.index是资源索引表，由DevEco Studio调用SDK工具生成。
- js文件夹中存放的是编译后的代码文件。
- pack.info是Bundle中用于描述每个HAP属性的文件，例如app中的bundleName和versionCode信息、module中的name、type和abilities等信息，由DevEco Studio工具构建Bundle包时自动生成。
图1应用程序包结构（FA模型）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163449.09311215615614553960590001764273:50001231000000:2800:3A40F21B6C85C245435BA456BBFB8C4641C05EF38247CDB43131F91A3BF1F665.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-package-dev
爬取时间: 2025-04-27 21:38:43
来源: Huawei Developer
- HAP
- HAR
- HSP

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hap-package
爬取时间: 2025-04-27 21:38:57
来源: Huawei Developer
HAP（Harmony Ability Package）是应用安装和运行的基本单元。HAP包是由代码、资源、第三方库、配置文件等打包生成的模块包，其主要分为两种类型：entry和feature。
- entry：应用的主模块，作为应用的入口，提供了应用的基础功能。
- feature：应用的动态特性模块，作为应用能力的扩展，可以根据用户的需求和设备类型进行选择性安装。
应用程序包可以只包含一个基础的entry包，也可以包含一个基础的entry包和多个功能性的feature包。
使用场景
- 单HAP场景：如果只包含UIAbility组件，无需使用ExtensionAbility组件，优先采用单HAP（即一个entry包）来实现应用开发。虽然一个HAP中可以包含一个或多个UIAbility组件，为了避免不必要的资源加载，推荐采用“一个UIAbility+多个页面”的方式。
- 多HAP场景：如果应用的功能比较复杂，需要使用ExtensionAbility组件，可以采用多HAP（即一个entry包+多个feature包）来实现应用开发，每个HAP中包含一个UIAbility组件或者一个ExtensionAbility组件。在这种场景下，可能会存在多个HAP引用相同的库文件，导致重复打包的问题。
约束限制
- 不支持导出接口和ArkUI组件，给其他模块使用。
- 多HAP场景下，App Pack包中同一设备类型的所有HAP中必须有且只有一个Entry类型的HAP，Feature类型的HAP可以有一个或者多个，也可以没有。
- 多HAP场景下，同一应用中的所有HAP的配置文件中的bundleName、versionCode、versionName、minCompatibleVersionCode、debug、minAPIVersion、targetAPIVersion、apiReleaseType相同，同一设备类型的所有HAP对应的moduleName标签必须唯一。HAP打包生成App Pack包时，会对上述参数配置进行校验。
- 多HAP场景下，同一应用的所有HAP、HSP的签名证书要保持一致。上架应用市场是以App Pack形式上架，应用市场分发时会将所有HAP从App Pack中拆分出来，同时对其中的所有HAP进行重签名，这样保证了所有HAP签名证书的一致性。在调试阶段，开发者通过命令行或DevEco Studio将HAP安装到设备上时，要保证所有HAP签名证书一致，否则会出现安装失败的问题。
创建
下面简要介绍如何通过DevEco Studio新建一个HAP模块。
1.  创建工程，构建第一个ArkTS应用。
2.  在工程目录上单击右键，选择New > Module。
3.  在弹出的对话框中选择Empty Ability模板，单击Next。
4.  在Module配置界面，配置Module name，选择Module Type和Device Type，然后单击Next。
5.  在Ability配置界面，配置Ability name，然后单击Finish完成创建。
开发
- HAP中支持添加UIAbility组件或ExtensionAbility组件，添加pages页面。具体操作可参考应用/服务开发。
- HAP中支持引用HAR或HSP共享包，详见HAR的使用、HSP的使用。
调试
通过DevEco Studio编译打包，生成单个或者多个HAP，即可基于HAP进行调试。如需根据不同的部署环境、目标人群、运行环境等，将同一个HAP定制编译为不同版本，请参见定制编译指导。
开发者可以采用DevEco Studio或者hdc工具进行调试：
- 方法一：使用DevEco Studio进行调试，详见应用程序包调试方法。
- 方法二：使用hdc工具进行调试。在调试前，需要先安装或更新HAP，此处有两种方式：直接使用hdc安装、更新HAP。HAP的路径为开发平台上的文件路径，以Windows开发平台为例，命令参考如下：
// 安装、更新，多HAP可以指定多个文件路径hdc install entry.hap feature.hap// 执行结果install bundle successfully.// 卸载hdc uninstall com.example.myapplication// 执行结果uninstall bundle successfully.先执行hdc shell，再使用bm工具安装、更新HAP。HAP的文件路径为真机上的文件路径，命令参考如下：
// 先执行hdc shell才能使用bm工具hdc shell// 安装、更新，多HAP可以指定多个文件路径bm install -p /data/app/entry.hap /data/app/feature.hap// 执行结果install bundle successfully.// 卸载bm uninstall -n com.example.myapplication// 执行结果uninstall bundle successfully.完成HAP安装或更新后，即可参考相关调试命令进行调试。
- 直接使用hdc安装、更新HAP。HAP的路径为开发平台上的文件路径，以Windows开发平台为例，命令参考如下：
// 安装、更新，多HAP可以指定多个文件路径hdc install entry.hap feature.hap// 执行结果install bundle successfully.// 卸载hdc uninstall com.example.myapplication// 执行结果uninstall bundle successfully.
- // 安装、更新，多HAP可以指定多个文件路径
- hdc install entry.hap feature.hap
- // 执行结果
- install bundle successfully.
- // 卸载
- hdc uninstall com.example.myapplication
- // 执行结果
- uninstall bundle successfully.
- 先执行hdc shell，再使用bm工具安装、更新HAP。HAP的文件路径为真机上的文件路径，命令参考如下：
// 先执行hdc shell才能使用bm工具hdc shell// 安装、更新，多HAP可以指定多个文件路径bm install -p /data/app/entry.hap /data/app/feature.hap// 执行结果install bundle successfully.// 卸载bm uninstall -n com.example.myapplication// 执行结果uninstall bundle successfully.
- // 先执行hdc shell才能使用bm工具
- hdc shell
- // 安装、更新，多HAP可以指定多个文件路径
- bm install -p /data/app/entry.hap /data/app/feature.hap
- // 执行结果
- install bundle successfully.
- // 卸载
- bm uninstall -n com.example.myapplication
- // 执行结果
- uninstall bundle successfully.
- 直接使用hdc安装、更新HAP。HAP的路径为开发平台上的文件路径，以Windows开发平台为例，命令参考如下：
// 安装、更新，多HAP可以指定多个文件路径hdc install entry.hap feature.hap// 执行结果install bundle successfully.// 卸载hdc uninstall com.example.myapplication// 执行结果uninstall bundle successfully.
- // 安装、更新，多HAP可以指定多个文件路径
- hdc install entry.hap feature.hap
- // 执行结果
- install bundle successfully.
- // 卸载
- hdc uninstall com.example.myapplication
- // 执行结果
- uninstall bundle successfully.
- 先执行hdc shell，再使用bm工具安装、更新HAP。HAP的文件路径为真机上的文件路径，命令参考如下：
// 先执行hdc shell才能使用bm工具hdc shell// 安装、更新，多HAP可以指定多个文件路径bm install -p /data/app/entry.hap /data/app/feature.hap// 执行结果install bundle successfully.// 卸载bm uninstall -n com.example.myapplication// 执行结果uninstall bundle successfully.
- // 先执行hdc shell才能使用bm工具
- hdc shell
- // 安装、更新，多HAP可以指定多个文件路径
- bm install -p /data/app/entry.hap /data/app/feature.hap
- // 执行结果
- install bundle successfully.
- // 卸载
- bm uninstall -n com.example.myapplication
- // 执行结果
- uninstall bundle successfully.
示例代码
- 多HAP

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/har-package
爬取时间: 2025-04-27 21:39:11
来源: Huawei Developer
HAR（Harmony Archive）是静态共享包，可以包含代码、C++库、资源和配置文件。通过HAR可以实现多个模块或多个工程共享ArkUI组件、资源等相关代码。
使用场景
- 支持应用内共享，也可以发布后供其他应用使用。
- 作为二方库，发布到OHPM私仓，供公司内部其他应用使用。
- 作为三方库，发布到OHPM中心仓，供其他应用使用。
- 多包（HAP/HSP）引用相同的HAR时，会造成多包间代码和资源的重复拷贝，从而导致应用包膨大。
约束限制
- HAR不支持在设备上单独安装/运行，只能作为应用模块的依赖项被引用。
- HAR不支持在配置文件中声明ExtensionAbility组件，但支持UIAbility组件。说明如果使用startAbility接口拉起HAR中的UIAbility，接口参数中的moduleName取值需要为依赖该HAR的HAP/HSP的moduleName。
- HAR不支持在配置文件中声明pages页面，但是可以包含pages页面，并通过Navigation跳转的方式进行跳转。
- HAR不支持引用AppScope目录中的资源。在编译构建时，AppScope中的内容不会打包到HAR中，因此会导致HAR资源引用失败。
- HAR可以依赖其他HAR，但不支持循环依赖，也不支持依赖传递。
创建
通过DevEco Studio创建一个HAR模块，详见创建库模块。
开发
介绍如何导出HAR的ArkUI组件、接口、资源，供其他应用或当前应用的其他模块引用。
Index.ets文件是HAR导出声明文件的入口，HAR需要导出的接口，统一在Index.ets文件中导出。Index.ets文件是DevEco Studio默认自动生成的，用户也可以自定义，在模块的oh-package.json5文件中的main字段配置入口声明文件，配置如下所示：
```json
{
"main": "Index.ets"
}
```
导出ArkUI组件
通过export导出ArkUI组件，示例如下：
```typescript
// library/src/main/ets/components/mainpage/MainPage.ets
@Component
export struct MainPage {
@State message: string = 'HAR MainPage';
build() {
Column() {
Row() {
Text(this.message)
.fontSize(32)
.fontWeight(FontWeight.Bold)
}
.margin({ top: '32px' })
.height(56)
.width('624px')
Flex({ justifyContent: FlexAlign.Center, alignItems: ItemAlign.Center, alignContent: FlexAlign.Center }) {
Column() {
Image($r('app.media.pic_empty')).width('33%')
Text($r('app.string.empty'))
.fontSize(14)
.fontColor($r('app.color.text_color'))
}
}.width('100%')
.height('90%')
}
.width('100%')
.height('100%')
.backgroundColor($r('app.color.page_background'))
}
}
```
HAR对外暴露的接口，在Index.ets导出文件中声明如下所示：
```typescript
// library/Index.ets
export { MainPage } from './src/main/ets/components/mainpage/MainPage';
```
导出类和方法
通过export导出类和方法，支持导出多个类和方法，示例如下所示：
```typescript
// library/src/main/ets/test.ets
export class Log {
static info(msg: string) {
console.info(msg);
}
}
export function func() {
return 'har func';
}
export function func2() {
return 'har func2';
}
```
HAR对外暴露的接口，在Index.ets导出文件中声明如下所示：
```typescript
// library/Index.ets
export { Log } from './src/main/ets/test';
export { func } from './src/main/ets/test';
export { func2 } from './src/main/ets/test';
```
导出native方法
在HAR中也可以包含C++编写的so。对于so中的native方法，HAR通过以下方式导出，以导出liblibrary.so的加法接口add为例：
```typescript
// library/src/main/ets/utils/nativeTest.ets
import native from 'liblibrary.so';
export function nativeAdd(a: number, b: number): number {
let result: number = native.add(a, b);
return result;
}
```
HAR对外暴露的接口，在Index.ets导出文件中声明如下所示：
```typescript
// library/Index.ets
export { nativeAdd } from './src/main/ets/utils/nativeTest';
```
导出资源
在编译构建HAP时，DevEco Studio会从HAP模块及依赖的模块中收集资源文件，如果不同模块下的资源文件出现重名冲突时，DevEco Studio会按照以下优先级进行覆盖（优先级由高到低）：
- AppScope（仅Stage模型支持）。
- HAP包自身模块。
- 依赖的HAR模块，如果依赖的多个HAR之间有资源冲突，会按照工程oh-package.json5中dependencies下的依赖顺序进行覆盖，依赖顺序在前的优先级较高。例如下方示例中dayjs和lottie中包含同名文件时，会优先使用dayjs中的资源。说明如果在AppScope/HAP模块/HAR模块的国际化目录中配置了资源，在相同的国际化限定词下，合并的优先级也遵循上述规则。同时，国际化限定词中配置的优先级高于在base中的配置。如：在AppScope的base中配置了资源字段，在HAR模块的en_US中配置了同样的资源字段，则在en_US的使用场景中，会更优先使用HAR模块中配置的资源字段。
使用
介绍如何配置HAR依赖，并引用HAR的ArkUI组件、接口、资源。
引用HAR前，需要先配置对HAR的依赖，详见引用HAR文件和资源。
引用HAR的ArkUI组件
HAR的依赖配置成功后，可以引用HAR的ArkUI组件。通过import引入HAR导出的ArkUI组件，示例如下所示：
```typescript
// entry/src/main/ets/pages/IndexSec.ets
import { MainPage } from 'library';
@Entry
@Component
struct IndexSec {
build() {
Row() {
// 引用HAR的ArkUI组件
MainPage()
}
.height('100%')
}
}
```
引用HAR的类和方法
通过import引用HAR导出的类和方法，示例如下所示：
```typescript
// entry/src/main/ets/pages/Index.ets
import { Log } from 'library';
import { func } from 'library';
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Column() {
Text(this.message)
.fontFamily('HarmonyHeiTi')
.fontWeight(FontWeight.Bold)
.fontSize(32)
.fontWeight(700)
.fontColor($r('app.color.text_color'))
.textAlign(TextAlign.Start)
.margin({ top: '32px' })
.width('624px')
//引用HAR的ets类和方法
Button($r('app.string.button'))
.id('button')
.height(48)
.width('624px')
.margin({ top: '4%' })
.type(ButtonType.Capsule)
.fontFamily('HarmonyHeiTi')
.borderRadius($r('sys.float.ohos_id_corner_radius_button'))
.backgroundColor($r('app.color.button_background'))
.fontColor($r('sys.color.ohos_id_color_foreground_contrary'))
.fontSize($r('sys.float.ohos_id_text_size_button1'))
.onClick(() => {
// 引用HAR的类和方法
Log.info('har msg');
this.message = 'func return: ' + func();
})
}
.width('100%')
.backgroundColor($r('app.color.page_background'))
.height('100%')
}
}
```
引用HAR的native方法
通过import引用HAR导出的native方法，示例如下所示：
```typescript
// entry/src/main/ets/pages/Index.ets
import { nativeAdd } from 'library';
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Column() {
Text(this.message)
.fontFamily('HarmonyHeiTi')
.fontWeight(FontWeight.Bold)
.fontSize(32)
.fontWeight(700)
.fontColor($r('app.color.text_color'))
.textAlign(TextAlign.Start)
.margin({ top: '32px' })
.width('624px')
//引用HAR的native方法
Button($r('app.string.native_add'))
.id('nativeAdd')
.height(48)
.width('624px')
.margin({ top: '4%', bottom: '6%' })
.type(ButtonType.Capsule)
.fontFamily('HarmonyHeiTi')
.borderRadius($r('sys.float.ohos_id_corner_radius_button'))
.backgroundColor($r('app.color.button_background'))
.fontColor($r('sys.color.ohos_id_color_foreground_contrary'))
.fontSize($r('sys.float.ohos_id_text_size_button1'))
.onClick(() => {
this.message = 'result: ' + nativeAdd(1, 2);
})
}
.width('100%')
.backgroundColor($r('app.color.page_background'))
.height('100%')
}
}
```
引用HAR的资源
通过$r引用HAR中的资源，例如在HAR模块的src/main/resources里添加字符串资源（在string.json中定义，name：hello_har）和图片资源（icon_har.png），然后在Entry模块中引用该字符串和图片资源的示例如下所示：
```typescript
// entry/src/main/ets/pages/Index.ets
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Column() {
// 引用HAR的字符串资源
Text($r('app.string.hello_har'))
.id('stringHar')
.fontFamily('HarmonyHeiTi')
.fontColor($r('app.color.text_color'))
.fontSize(24)
.fontWeight(500)
.margin({ top: '40%' })
List() {
ListItem() {
// 引用HAR的图片资源
Image($r('app.media.icon_har'))
.id('iconHar')
.borderRadius('48px')
}
.margin({ top: '5%' })
.width('312px')
}
.alignListItem(ListItemAlign.Center)
}
.width('100%')
.backgroundColor($r('app.color.page_background'))
.height('100%')
}
}
```
编译
HAR可以作为二方库和三方库提供给其他应用使用，如果需要对代码资产进行保护时，建议开启混淆能力。
混淆能力开启后，DevEco Studio在构建HAR时，会对代码进行编译、混淆及压缩处理，保护代码资产。
HAR模块原先默认开启混淆能力，会对API 10及以上的HAR模块，且编译模块为release时，自动进行简单的代码混淆；从DevEco Studio 5.0.3.600开始，新建工程默认关闭代码混淆功能，可以在HAR模块的build-profile.json5文件中的ruleOptions字段下的enable进行开启混淆，详情请见代码混淆，配置如下所示：
```json
{
"apiType": "stageMode",
"buildOption": {
},
"buildOptionSet": [
{
"name": "release",
"arkOptions": {
"obfuscation": {
"ruleOptions": {
"enable": true,
"files": [
"./obfuscation-rules.txt"
]
},
"consumerFiles": [
"./consumer-rules.txt"
]
}
}
},
],
"targets": [
{
"name": "default"
}
]
}
```
编译生成TS文件
在HAR中使用Sendable时，开启该配置。
使用限制
在依赖TS HAR时，禁止引用TS HAR中的ArkUI组件。
HAR模块中arkts文件编译后，默认产物为js文件，想要将产物修改为ts文件，可以在HAR模块下的module.json5文件中将"metadata"字段下的"name"设置为“UseTsHar”，配置如下所示：
```json
{
"module": {
"name": "TsClosedHar",
"type": "har",
"deviceTypes": [
"default",
"tablet",
"2in1"
],
"metadata": [
{
"name": "UseTsHar",
"value": "true"
}
]
}
}
```
发布
详见发布HAR。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/in-app-hsp
爬取时间: 2025-04-27 21:39:24
来源: Huawei Developer
HSP（Harmony Shared Package）是动态共享包，可以包含代码、C++库、资源和配置文件，通过HSP可以实现代码和资源的共享。HSP不支持独立发布，而是跟随其宿主应用的APP包一起发布，与宿主应用同进程，具有相同的包名和生命周期。
应用内HSP：在编译过程中与应用包名（bundleName）强耦合，只能给某个特定的应用使用。
集成态HSP：构建、发布过程中，不与特定的应用包名耦合；使用时，工具链支持自动将集成态HSP的包名替换成宿主应用包名，并且会重新签名生成一个新的HSP包，作为宿主应用的安装包，这个新的HSP也属于应用内HSP。
使用场景
- 多个HAP/HSP共用的代码和资源放在同一个HSP中，可以提高代码、资源的可重用性和可维护性，同时编译打包时也只保留一份HSP代码和资源，能够有效控制应用包大小。
- HSP在运行时按需加载，有助于提升应用性能。
- 同一个组织内部的多个应用之间，可以使用集成态HSP实现代码和资源的共享。
约束限制
- HSP不支持在设备上单独安装/运行，需要与依赖该HSP的HAP一起安装/运行。HSP的版本号必须与HAP版本号一致。
- HSP不支持在配置文件中声明ExtensionAbility组件，但支持在配置文件中声明UIAbility（除入口ability外）组件。
- HSP可以依赖其他HAR或HSP，但不支持循环依赖，也不支持依赖传递。
循环依赖：例如有三个HSP，HSP-A、HSP-B和HSP-C，循环依赖指HSP-A依赖HSP-B，HSP-B依赖HSP-C，HSP-C又依赖HSP-A。
依赖传递：例如有三个HSP，HSP-A、HSP-B和HSP-C，依赖关系是HSP-A依赖HSP-B，HSP-B依赖HSP-C。不支持传递依赖指HSP-A可以使用HSP-B的方法和组件，但是HSP-A不能直接使用HSP-C的方法和组件。
创建
通过DevEco Studio创建一个HSP模块，详见创建HSP模块，我们以创建一个名为library的HSP模块为例。基本的工程目录结构如下：
开发
介绍如何导出HSP的ArkUI组件、接口、资源，供应用内的其他HAP/HSP引用。
导出ArkUI组件
ArkUI组件可以通过export导出，例如：
```typescript
// library/src/main/ets/components/MyTitleBar.ets
@Component
export struct MyTitleBar {
build() {
Row() {
Text($r('app.string.library_title'))
.id('library')
.fontFamily('HarmonyHeiTi')
.fontWeight(FontWeight.Bold)
.fontSize(32)
.fontColor($r('app.color.text_color'))
}
.width('100%')
}
}
```
对外暴露的接口，需要在入口文件index.ets中声明：
```typescript
// library/index.ets
export { MyTitleBar } from './src/main/ets/components/MyTitleBar';
```
导出类和方法
通过export导出类和方法，例如：
```typescript
// library/src/main/ets/utils/test.ets
export class Log {
static info(msg: string): void {
console.info(msg);
}
}
export function add(a: number, b: number): number {
return a + b;
}
export function minus(a: number, b: number): number {
return a - b;
}
```
对外暴露的接口，需要在入口文件index.ets中声明：
```typescript
// library/index.ets
export { Log, add, minus } from './src/main/ets/utils/test';
```
导出native方法
在HSP中也可以包含C++编写的so。对于so中的native方法，HSP通过间接的方式导出，以导出liblibrary.so的乘法接口multi为例：
```typescript
// library/src/main/ets/utils/nativeTest.ets
import native from 'liblibrary.so';
export function nativeMulti(a: number, b: number): number {
let result: number = native.multi(a, b);
return result;
}
```
对外暴露的接口，需要在入口文件index.ets中声明：
```typescript
// library/index.ets
export { nativeMulti } from './src/main/ets/utils/nativeTest';
```
通过$r访问HSP中的资源
在组件中，经常需要使用字符串、图片等资源。HSP中的组件需要使用资源时，一般将其所用资源放在HSP包内，而非放在HSP的使用方处，以符合高内聚低耦合的原则。
在工程中，常通过$r/$rawfile的形式引用应用资源。可以用$r/$rawfile访问本模块resources目录下的资源，如访问resources目录下定义的图片src/main/resources/base/media/example.png时，可以用$r("app.media.example")。有关$r/$rawfile的详细使用方式，请参阅文档资源分类与访问中“资源访问-应用资源”小节。
不推荐使用相对路径的方式，容易引用错误路径。例如：
当要引用上述同一图片资源时，在HSP模块中使用Image("../../resources/base/media/example.png")，实际上该Image组件访问的是HSP调用方（如entry）下的资源entry/src/main/resources/base/media/example.png。
```typescript
// library/src/main/ets/pages/Index.ets
// 正确用例
Image($r('app.media.example'))
.id('example')
.borderRadius('48px')
// 错误用例
Image("../../resources/base/media/example.png")
.id('example')
.borderRadius('48px')
```
导出HSP中的资源
跨包访问HSP内资源时，推荐实现一个资源管理类，以封装对外导出的资源。采用这种方式，具有如下优点：
- HSP开发者可以控制自己需要导出的资源，不需要对外暴露的资源可以不用导出。
- 使用方无须感知HSP内部的资源名称。当HSP内部的资源名称发生变化时，也不需要使用方跟着修改。
其具体实现如下：
将需要对外提供的资源封装为一个资源管理类：
```typescript
// library/src/main/ets/ResManager.ets
export class ResManager{
static getPic(): Resource{
return $r('app.media.pic');
}
static getDesc(): Resource{
return $r('app.string.shared_desc');
}
}
```
对外暴露的接口，需要在入口文件index.ets中声明：
```typescript
// library/index.ets
export { ResManager } from './src/main/ets/ResManager';
```
使用
介绍如何引用HSP中的接口，以及如何通过页面路由实现HSP的pages页面跳转与返回。
引用HSP中的接口
要使用HSP中的接口，首先需要在使用方的oh-package.json5中配置对它的依赖，详见引用动态共享包。
依赖配置成功后，就可以像使用HAR一样调用HSP的对外接口了。例如，上面的library已经导出了下面这些接口：
```typescript
// library/index.ets
export { Log, add, minus } from './src/main/ets/utils/test';
export { MyTitleBar } from './src/main/ets/components/MyTitleBar';
export { ResManager } from './src/main/ets/ResManager';
export { nativeMulti } from './src/main/ets/utils/nativeTest';
```
在使用方的代码中，可以这样使用：
```typescript
// entry/src/main/ets/pages/index.ets
import { Log, add, MyTitleBar, ResManager, nativeMulti } from 'library';
import { BusinessError } from "@kit.BasicServicesKit";
const TAG = 'Index';
@Entry
@Component
struct Index {
@State message: string = '';
build() {
Column() {
List() {
ListItem() {
MyTitleBar()
}
.margin({ left: '35px', top: '32px' })
ListItem() {
Text(this.message)
.fontFamily('HarmonyHeiTi')
.fontSize(18)
.textAlign(TextAlign.Start)
.width('100%')
.fontWeight(FontWeight.Bold)
}
.width('685px')
.margin({ top: 30, bottom: 10 })
ListItem() {
// ResManager返回的Resource对象，可以传给组件直接使用，也可以从中取出资源来使用
Image(ResManager.getPic())
.id('image')
.borderRadius('48px')
}
.width('685px')
.margin({ top: 10, bottom: 10 })
.padding({ left: 12, right: 12, top: 4, bottom: 4 })
ListItem() {
Text($r('app.string.add'))
.fontSize(18)
.textAlign(TextAlign.Start)
.width('100%')
.fontWeight(500)
.height('100%')
}
.id('add')
.borderRadius(24)
.width('685px')
.height('84px')
.backgroundColor($r('sys.color.ohos_id_color_foreground_contrary'))
.margin({ top: 10, bottom: 10 })
.padding({ left: 12, right: 12, top: 4, bottom: 4 })
.onClick(() => {
Log.info('add button click!');
this.message = 'result: ' + add(1, 2);
})
ListItem() {
Text($r('app.string.get_string_value'))
.fontSize(18)
.textAlign(TextAlign.Start)
.width('100%')
.fontWeight(500)
.height('100%')
}
.id('getStringValue')
.borderRadius(24)
.width('685px')
.height('84px')
.backgroundColor($r('sys.color.ohos_id_color_foreground_contrary'))
.margin({ top: 10, bottom: 10 })
.padding({ left: 12, right: 12, top: 4, bottom: 4 })
.onClick(() => {
// 先通过当前上下文获取hsp模块的上下文，再获取hsp模块的resourceManager，然后再调用resourceManager的接口获取资源
getContext()
.createModuleContext('library')
.resourceManager
.getStringValue(ResManager.getDesc())
.then(value => {
console.log('getStringValue is ' + value);
this.message = 'getStringValue is ' + value;
})
.catch((err: BusinessError) => {
console.error('getStringValue promise error is ' + err);
});
})
ListItem() {
Text($r('app.string.native_multi'))
.fontSize(18)
.textAlign(TextAlign.Start)
.width('100%')
.fontWeight(500)
.height('100%')
}
.id('nativeMulti')
.borderRadius(24)
.width('685px')
.height('84px')
.backgroundColor($r('sys.color.ohos_id_color_foreground_contrary'))
.margin({ top: 10, bottom: 10 })
.padding({ left: 12, right: 12, top: 4, bottom: 4 })
.onClick(() => {
Log.info('nativeMulti button click!');
this.message = 'result: ' + nativeMulti(3, 4);
})
}
.alignListItem(ListItemAlign.Center)
}
.width('100%')
.backgroundColor($r('app.color.page_background'))
.height('100%')
}
}
```
页面跳转和返回
开发者想在entry模块中，添加一个按钮跳转至library模块中的menu页面（路径为：library/src/main/ets/pages/library_menu.ets），那么可以在使用方的代码（entry模块下的Index.ets，路径为：entry/src/main/ets/pages/Index.ets）里这样使用：
```typescript
// entry/src/main/ets/pages/Index.ets
@Entry
@Component
struct Index {
@State message: string = '';
pathStack: NavPathStack = new NavPathStack();
build() {
Navigation(this.pathStack) {
Column() {
List() {
ListItem() {
Text($r('app.string.click_to_menu'))
.fontSize(18)
.textAlign(TextAlign.Start)
.width('100%')
.fontWeight(500)
.height('100%')
}
.id('clickToMenu')
.borderRadius(24)
.width('685px')
.height('84px')
.backgroundColor($r('sys.color.ohos_id_color_foreground_contrary'))
.margin({ top: 10, bottom: 10 })
.padding({
left: 12,
right: 12,
top: 4,
bottom: 4
})
.onClick(() => {
this.pathStack.pushPathByName('library_menu', null)
})
}
.alignListItem(ListItemAlign.Center)
}
.width('100%')
.backgroundColor($r('app.color.page_background'))
.height('100%')
}.title("Navigation_index")
.mode(NavigationMode.Stack)
}
}
```
在library下新增page文件（library/src/main/ets/pages/library_menu.ets），其中'back_to_index'的按钮返回上一页。
```typescript
// library/src/main/ets/pages/library_menu.ets
@Builder
export function PageOneBuilder() {
Library_Menu()
}
@Entry
@Component
export struct Library_Menu {
@State message: string = 'Hello World';
pathStack: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Row() {
Column() {
Text(this.message)
.fontSize($r('app.float.page_text_font_size'))
.fontWeight(FontWeight.Bold)
.onClick(() => {
this.message = 'Welcome';
})
Button("back_to_index").fontSize(50).onClick(() => {
this.pathStack.pop();
})
}
.width('100%')
}
.height('100%')
}.title('Library_Menu')
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack
})
}
}
```
需要在library模块下新增route_map.json文件（library/src/main/resources/base/profile/route_map.json）。
在library模块下的配置文件（library/src/main/module.json5）中配置json文件。
页面跳转和页面返回都使用了Navigation的特性，详情参考Navigation跳转。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-package-install-uninstall
爬取时间: 2025-04-27 21:39:38
来源: Huawei Developer
本章节简要介绍应用程序包的安装卸载流程、以及应用程序包的两种更新方式。
应用程序包的安装卸载
开发者可以通过调试命令进行应用的安装和卸载，可参考编译发布与上架部署流程图。
图1应用程序包安装和卸载流程（开发者）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163449.51010303328844748561489366735250:50001231000000:2800:02DAC784A2F16E39C2E123FE6B17F55AF9A84EB83B7064E905008FDC532CA903.png)
开发者将应用上架应用市场后，终端设备用户可以在终端设备上使用应用市场进行应用的安装和卸载。
图2应用程序包安装和卸载流程（终端设备用户）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163449.35067043748059699341684928061784:50001231000000:2800:B38BB89CEAC03480AD480E372FFA46EEDB18F71A909ACB1CB20E0D5117D6B7C1.png)
应用程序包的更新
对于开发者，应用程序包的更新，首先需要更新app.json5配置文件中的versionCode版本号字段，通过IDE打包后在应用市场发布，发布流程与首次发布一致。对于终端设备用户，可以通过以下两种方式更新应用程序包：
- 应用市场内更新：新版本应用通过应用市场上架后，应用市场通知终端用户该应用有新版本，终端用户可以根据通知到应用市场（客户端）进行应用升级。
- 应用内检测升级：终端用户启动应用时，应用市场检测到该应用有新版本会通知终端用户，可以到应用市场进行应用的下载更新。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-configuration-file-stage
爬取时间: 2025-04-27 21:39:52
来源: Huawei Developer
- 应用配置文件概述（Stage模型）
- app.json5配置文件
- module.json5配置文件

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-configuration-file-overview-stage
爬取时间: 2025-04-27 21:40:05
来源: Huawei Developer
每个应用项目的代码目录下必须包含应用配置文件，这些配置文件会向编译工具、操作系统和应用市场提供应用的基本信息。
在基于Stage模型开发的应用项目代码下，都存在一个app.json5配置文件、以及一个或多个module.json5配置文件。
app.json5配置文件主要包含以下内容：
- 应用的全局配置信息，包含应用的Bundle名称、开发厂商、版本号等基本信息。
- 特定设备类型的配置信息。
module.json5配置文件主要包含以下内容：
- Module的基本配置信息，包含Module名称、类型、描述、支持的设备类型等基本信息。
- 应用组件信息，包含UIAbility组件和ExtensionAbility组件的描述信息。
- 应用运行过程中所需的权限信息。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-configuration-file
爬取时间: 2025-04-27 21:40:19
来源: Huawei Developer
配置文件示例
先通过一个示例，整体认识一下app.json5配置文件。
```json
{
"app": {
"bundleName": "com.application.myapplication",
"vendor": "example",
"versionCode": 1000000,
"versionName": "1.0.0",
"icon": "$media:layered_image",
"label": "$string:app_name",
"description": "$string:description_application",
"minAPIVersion": 9,
"targetAPIVersion": 9,
"apiReleaseType": "Release",
"debug": false,
"car": {
"minAPIVersion": 8
},
"targetBundleName": "com.application.test",
"targetPriority": 50,
"appEnvironments": [
{
"name":"name1",
"value": "value1"
}
],
"maxChildProcess": 5,
"multiAppMode": {
"multiAppModeType": "multiInstance",
"maxCount": 5
},
"hwasanEnabled": false,
"ubsanEnabled": false,
"cloudFileSyncEnabled": false,
"configuration": "$profile:configuration"
},
}
```
配置文件标签
app.json5配置文件包含以下标签。
表1app.json5配置文件标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| bundleName |  标识应用的Bundle名称，用于标识应用的唯一性。命名规则如下 ： - 必须为以点号（.）分隔的字符串，且至少包含三段，每段中仅允许使用英文字母、数字、下划线（_）。 - 首段以英文字母开头，非首段以数字或英文字母开头，每一段以数字或者英文字母结尾。 - 不允许多个点号（.）连续出现。 - 字符串最小长度为7字节，最大长度128字节。 - 推荐采用反域名形式命名（如“com.example.demo”，建议第一级为域名后缀com，第二级为厂商/个人名，第三级为应用名，也可以多级）。 对于随系统源码编译的应用，建议命名为“com.ohos.demo”形式，其中的ohos标识系统应用。 | 字符串 | 该标签不可缺省。 |
| bundleType |  标识应用的Bundle类型，用于区分应用或者元服务。支持的取值如下： - app：当前Bundle为应用。 - atomicService：当前Bundle为元服务。 - shared：当前Bundle为共享库应用，预留字段。 - appService：当前Bundle为系统级共享库应用，仅供系统应用使用。 | 字符串 | 该标签可缺省，缺省值为app。 |
| debug |  标识应用是否可调试。 - true：可调试，一般用于开发阶段。 - false：不可调试，一般用于发布阶段。 | 布尔值 | 由DevEco Studio编译构建时生成。该标签可缺省，缺省值为false。 |
| icon | 标识应用的图标，取值为图标资源文件的索引。 | 字符串 | 该标签不可缺省。 |
| label | 标识应用的名称，取值为字符串资源的索引，字符串长度不超过63字节。 | 字符串 | 该标签不可缺省。 |
| description | 标识应用的描述信息，取值为长度不超过255字节的字符串，内容为描述信息的字符串资源索引。该字段可用于应用信息展示，如在应用的关于页面，取该字段展示应用描述信息。 | 字符串 | 该标签可缺省，缺省值为空。 |
| vendor | 标识对应用开发厂商的描述，取值为长度不超过255字节的字符串。该字段可用于展示开发厂商信息，如在应用的关于页面，取该字段展示开发厂商信息。 | 字符串 | 该标签可缺省，缺省值为空。 |
| versionCode |  标识应用的版本号，取值为小于2^31次方的正整数。此数字仅用于确定某个版本是否比另一个版本更新，数值越大表示版本越高。 开发者可以将该值设置为任何正整数，但是必须确保应用的新版本都使用比旧版本更大的值。 | 数值 | 该标签不可缺省。 |
| versionName |  标识向用户展示的应用版本号。 取值为长度不超过127字节的字符串，仅由数字和点构成，推荐采用“A.B.C.D”四段式的形式。四段式推荐的含义如下所示。 第一段：主版本号/Major，范围0~99，重大修改的版本，如实现新的大功能或重大变化。 第二段：次版本号/Minor，范围0~99，表示实现较突出的特点，如新功能添加或大问题修复。 第三段：特性版本号/Feature，范围0~99，标识规划的新版本特性。 第四段：修订版本号/Patch，范围0~999，表示维护版本，如修复bug。 | 字符串 | 该标签不可缺省。 |
| minCompatibleVersionCode | 标识应用能够兼容的最低历史版本号，用于应用多设备之间协同、数据迁移、跨设备兼容性判断，该字段为预留字段，暂未使用。取值范围为0~2147483647。 | 数值 | 该标签可缺省，缺省值等于versionCode标签值。 |
| minAPIVersion | 标识应用运行需要的SDK的API最小版本。取值范围为0~2147483647。 | 数值 | 应用编译构建时由build-profile.json5中的compatibleSdkVersion自动生成。 |
| targetAPIVersion | 标识应用运行需要的API目标版本。取值范围为0~2147483647。 | 数值 | 应用编译构建时由build-profile.json5中的compileSdkVersion自动生成。 |
| apiReleaseType |  标识应用运行需要的API目标版本的类型，采用字符串类型表示。取值为“CanaryN”、“BetaN”或者“Release”，其中，N代表大于零的整数。 - Canary：受限发布的版本。 - Beta：公开发布的Beta版本。 - Release：公开发布的正式版本。 | 字符串 | 应用编译构建时根据当前使用的SDK的Stage自动生成。即便手动配置了取值，编译构建时也会被覆盖。 |
| accessible | 标识应用是否能访问应用的安装目录，仅针对Stage模型的系统应用和预置应用生效。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| multiProjects |  标识当前工程是否支持多个工程的联合开发。 - true：当前工程支持多个工程的联合开发。多工程开发可参考多工程构建。 - false：当前工程不支持多个工程的联合开发。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| asanEnabled |  标识应用程序是否开启asan检测，用于辅助定位buffer越界造成的crash问题。 - true：当前工程开启asan检测。 - false：当前工程不开启asan检测。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| tablet |  标识对tablet设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion。 如果使用该属性对tablet设备做了特殊配置，则应用在tablet设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 | 对象 | 该标签可缺省，缺省时tablet设备使用app.json5公共区域配置的属性值。 |
| tv |  标识对tv设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion。 如果使用该属性对tv设备做了特殊配置，则应用在tv设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 | 对象 | 该标签可缺省，缺省时tv设备使用app.json5公共区域配置的属性值。 |
| wearable |  标识对wearable设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion。 如果使用该属性对wearable设备做了特殊配置，则应用在wearable设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 | 对象 | 该标签可缺省，缺省时wearable设备使用app.json5公共区域配置的属性值。 |
| car |  标识对car设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion。 如果使用该属性对car设备做了特殊配置，则应用在car设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 | 对象 | 该标签可缺省，缺省时car设备使用app.json5公共区域配置的属性值。 |
| default |  标识对default设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion。 如果使用该属性对default设备做了特殊配置，则应用在default设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 | 对象 | 该标签可缺省，缺省时default设备使用app.json5公共区域配置的属性值。 |
| targetBundleName | 标识当前包所指定的目标应用, 标签值的取值规则和范围与bundleName标签一致。配置该字段的应用为具有overlay特征的应用。 | 字符串 | 该标签可缺省，缺省值为空。 |
| targetPriority | 标识当前应用的优先级，取值范围为1~100。配置targetBundleName字段之后，才支持配置该字段。 | 数值 | 该标签可缺省, 缺省值为1。 |
| generateBuildHash |  标识当前应用的所有HAP和HSP是否由打包工具生成哈希值。 该字段配置为true时，该应用下的所有HAP和HSP都会由打包工具生成对应的哈希值。系统OTA升级时，若应用的versionCode保持不变，可根据哈希值判断应用是否需要升级。 说明： 该字段仅对预置应用生效。 | 布尔值 | 该标签可缺省, 缺省值为false。 |
| GWPAsanEnabled |  标识应用程序是否开启GWP-asan堆内存检测工具，用于对内存越界、内存释放后使用等内存破坏问题进行分析。 - true：当前工程开启GWP-asan检测。 - false：当前工程不开启GWP-asan检测。 | 布尔值 | 该标签可缺省, 缺省值为false。 |
| appEnvironments | 标识当前模块配置的应用环境变量。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| maxChildProcess | 标识当前应用自身可创建的子进程的最大个数，取值范围为0到512，0表示不限制，当应用有多个模块时，以entry模块的配置为准。 | 数值 | 该标签可缺省，缺省时使用系统配置的默认值。 |
| multiAppMode | 标识当前应用配置的多开模式。仅bundleType为app的应用的entry或feature模块配置有效，存在多个模块时，以entry模块的配置为准。 | 对象 | 该标签可缺省，缺省值为空。 |
| hwasanEnabled |  标识应用程序是否开启HWAsan检测。HWAsan(HardWare-assisted AddressSanitizer)是利用Top-Byte-Ignore特性实现的增强版Asan，与Asan相比HWAsan的内存开销更低，检测到的内存错误范围更大。 - true：当前工程开启HWAsan检测。 - false：当前工程不开启HWAsan检测。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| ubsanEnabled |  标识应用程序是否开启UBsan检测。 UBsan(Undefined Behavior Sanitizer)是一个用于运行时检测程序中未定义行为的工具，旨在帮助开发人员发现代码中潜在的错误和漏洞。 - true：当前工程开启UBsan检测。 - false：当前工程不开启UBsan检测。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| cloudFileSyncEnabled |  标识当前应用是否启用端云文件同步能力。 - true：当前应用启用端云文件同步能力。 - false：当前应用不启用端云文件同步能力。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| configuration |  标识当前应用字体大小跟随系统配置的能力。 该标签是一个profile文件资源，用于指定描述应用字体大小跟随系统变更的配置文件。 | 字符串 | 该标签可缺省，缺省时configuration使用不跟随系统默认设定。 |
标识应用的Bundle名称，用于标识应用的唯一性。命名规则如下 ：
- 必须为以点号（.）分隔的字符串，且至少包含三段，每段中仅允许使用英文字母、数字、下划线（_）。
- 首段以英文字母开头，非首段以数字或英文字母开头，每一段以数字或者英文字母结尾。
- 不允许多个点号（.）连续出现。
- 字符串最小长度为7字节，最大长度128字节。
- 推荐采用反域名形式命名（如“com.example.demo”，建议第一级为域名后缀com，第二级为厂商/个人名，第三级为应用名，也可以多级）。
对于随系统源码编译的应用，建议命名为“com.ohos.demo”形式，其中的ohos标识系统应用。
标识应用的Bundle类型，用于区分应用或者元服务。支持的取值如下：
- app：当前Bundle为应用。
- atomicService：当前Bundle为元服务。
- shared：当前Bundle为共享库应用，预留字段。
- appService：当前Bundle为系统级共享库应用，仅供系统应用使用。
标识应用是否可调试。
- true：可调试，一般用于开发阶段。
- false：不可调试，一般用于发布阶段。
标识应用的版本号，取值为小于2^31次方的正整数。此数字仅用于确定某个版本是否比另一个版本更新，数值越大表示版本越高。
开发者可以将该值设置为任何正整数，但是必须确保应用的新版本都使用比旧版本更大的值。
标识向用户展示的应用版本号。
取值为长度不超过127字节的字符串，仅由数字和点构成，推荐采用“A.B.C.D”四段式的形式。四段式推荐的含义如下所示。
第一段：主版本号/Major，范围0~99，重大修改的版本，如实现新的大功能或重大变化。
第二段：次版本号/Minor，范围0~99，表示实现较突出的特点，如新功能添加或大问题修复。
第三段：特性版本号/Feature，范围0~99，标识规划的新版本特性。
第四段：修订版本号/Patch，范围0~999，表示维护版本，如修复bug。
标识应用运行需要的API目标版本的类型，采用字符串类型表示。取值为“CanaryN”、“BetaN”或者“Release”，其中，N代表大于零的整数。
- Canary：受限发布的版本。
- Beta：公开发布的Beta版本。
- Release：公开发布的正式版本。
标识当前工程是否支持多个工程的联合开发。
- true：当前工程支持多个工程的联合开发。多工程开发可参考多工程构建。
- false：当前工程不支持多个工程的联合开发。
标识应用程序是否开启asan检测，用于辅助定位buffer越界造成的crash问题。
- true：当前工程开启asan检测。
- false：当前工程不开启asan检测。
标识对tablet设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion。
如果使用该属性对tablet设备做了特殊配置，则应用在tablet设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。
标识对tv设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion。
如果使用该属性对tv设备做了特殊配置，则应用在tv设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。
标识对wearable设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion。
如果使用该属性对wearable设备做了特殊配置，则应用在wearable设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。
标识对car设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion。
如果使用该属性对car设备做了特殊配置，则应用在car设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。
标识对default设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion。
如果使用该属性对default设备做了特殊配置，则应用在default设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。
标识当前应用的所有HAP和HSP是否由打包工具生成哈希值。
该字段配置为true时，该应用下的所有HAP和HSP都会由打包工具生成对应的哈希值。系统OTA升级时，若应用的versionCode保持不变，可根据哈希值判断应用是否需要升级。
说明：
该字段仅对预置应用生效。
标识应用程序是否开启GWP-asan堆内存检测工具，用于对内存越界、内存释放后使用等内存破坏问题进行分析。
- true：当前工程开启GWP-asan检测。
- false：当前工程不开启GWP-asan检测。
标识应用程序是否开启HWAsan检测。HWAsan(HardWare-assisted AddressSanitizer)是利用Top-Byte-Ignore特性实现的增强版Asan，与Asan相比HWAsan的内存开销更低，检测到的内存错误范围更大。
- true：当前工程开启HWAsan检测。
- false：当前工程不开启HWAsan检测。
标识应用程序是否开启UBsan检测。
UBsan(Undefined Behavior Sanitizer)是一个用于运行时检测程序中未定义行为的工具，旨在帮助开发人员发现代码中潜在的错误和漏洞。
- true：当前工程开启UBsan检测。
- false：当前工程不开启UBsan检测。
标识当前应用是否启用端云文件同步能力。
- true：当前应用启用端云文件同步能力。
- false：当前应用不启用端云文件同步能力。
标识当前应用字体大小跟随系统配置的能力。
该标签是一个profile文件资源，用于指定描述应用字体大小跟随系统变更的配置文件。
icon标签
此标签标识应用的图标和对分层图标配置文件的索引。
分层图标的配置方式如下：
1.  将图标的前景资源和背景资源放在AppScope/resources/base/media目录下，或使用目录下默认存放的前景资源和背景资源。
2.  上述media目录下存在一个分层图标配置文件（layered_image.json），在文件中引用前景资源和背景资源，详见图标资源规范。
分层图标配置文件示例：
```json
{
"layered-image"：
{
"background":"$media:background", //背景资源
"foreground":"$media:foreground" //前景资源
}
}
```
icon标签示例：
```json
{
"app":{
"icon":"$media:layered_image"
}
}
```
appEnvironments标签
此标签标识应用配置的环境变量。应用运行时有时会依赖一些三方库，这些三方库会使用到一些自定义的环境变量，为了不修改三方库的实现逻辑，可以在工程的配置文件中设置自定义的环境变量，以供运行时期使用。
表2appEnvironments标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识环境变量的变量名称。取值为长度不超过4096字节的字符串。 | 字符串 | 该标签可缺省，缺省值为空。 |
| value | 标识环境变量的值。取值为长度不超过4096字节的字符串。 | 字符串 | 该标签可缺省，缺省值为空。 |
appEnvironments标签示例：
```json
{
"app": {
"appEnvironments": [
{
"name":"name1",
"value": "value1"
}
]
}
}
```
multiAppMode标签
应用多开模式。
表3multiAppMode标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| multiAppModeType |  标识应用多开模式类型，支持的取值如下： - multiInstance：多实例模式。该字段仅支持2in1设备，常驻进程不支持该字段。 - appClone：应用分身模式。 | 字符串 | 该标签不可缺省。 |
| maxCount |  标识最大允许的应用多开个数，支持的取值如下： - multiInstance模式：取值范围1~10。 - appClone模式：取值范围1~5。 | 数值 | 该标签不可缺省。 |
标识应用多开模式类型，支持的取值如下：
- multiInstance：多实例模式。该字段仅支持2in1设备，常驻进程不支持该字段。
- appClone：应用分身模式。
标识最大允许的应用多开个数，支持的取值如下：
- multiInstance模式：取值范围1~10。
- appClone模式：取值范围1~5。
multiAppMode标签示例：
```json
{
"app": {
"multiAppMode": {
"multiAppModeType": "appClone",
"maxCount": 5
}
}
}
```
configuration标签
该标签是一个profile文件资源，用于指定描述应用字体大小跟随系统变更的配置文件。
configuration标签示例：
```json
{
"app": {
"configuration": "$profile:configuration"
}
}
```
在开发视图的AppScope/resources/base/profile下面定义配置文件configuration.json，其中文件名"configuration"可自定义，需要和configuration标签指定的信息对应。配置文件中列举了当前应用字体大小跟随系统变化的属性。
表4configuration标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| fontSizeScale |  应用字体大小是否跟随系统，支持的取值如下： - followSystem：跟随系统。 - nonFollowSystem：不跟随系统。 | 字符串 | 该标签可缺省，缺省值为nonFollowSystem。 |
| fontSizeMaxScale |  应用字体大小选择跟随系统后，配置的最大比例，支持的取值：1、1.15、1.3、1.45、1.75、2、3.2。 fontSizeScale为nonFollowSystem时，该项不生效。 | 字符串 | 该标签可缺省，缺省值为3.2。 |
应用字体大小是否跟随系统，支持的取值如下：
- followSystem：跟随系统。
- nonFollowSystem：不跟随系统。
应用字体大小选择跟随系统后，配置的最大比例，支持的取值：1、1.15、1.3、1.45、1.75、2、3.2。
fontSizeScale为nonFollowSystem时，该项不生效。
configuration标签示例：
```json
{
"configuration": {
"fontSizeScale": "followSystem",
"fontSizeMaxScale": "3.2"
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file
爬取时间: 2025-04-27 21:40:33
来源: Huawei Developer
配置文件示例
先通过一个示例，整体认识一下module.json5配置文件。
```json
{
"module": {
"name": "entry",
"type": "entry",
"description": "$string:module_desc",
"mainElement": "EntryAbility",
"deviceTypes": [
"tv",
"tablet"
],
"deliveryWithInstall": true,
"installationFree": false,
"pages": "$profile:main_pages",
"virtualMachine": "ark",
"metadata": [
{
"name": "string",
"value": "string",
"resource": "$profile:distributionFilter_config"
}
],
"abilities": [
{
"name": "EntryAbility",
"srcEntry": "./ets/entryability/EntryAbility.ts",
"description": "$string:EntryAbility_desc",
"icon": "$media:icon",
"label": "$string:EntryAbility_label",
"startWindowIcon": "$media:icon",
"startWindowBackground": "$color:start_window_background",
"exported": true,
"skills": [
{
"entities": [
"entity.system.home"
],
"actions": [
"ohos.want.action.home"
]
}
]
}
],
"requestPermissions": [
{
"name": "ohos.abilitydemo.permission.PROVIDER",
"reason": "$string:reason",
"usedScene": {
"abilities": [
"FormAbility"
],
"when": "inuse"
}
}
]
},
"targetModuleName": "feature",
"targetPriority": 50,
"isolationMode": "nonisolationFirst"
}
```
配置文件标签
module.json5配置文件包含以下标签。
表1module.json5配置文件标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name |  标识当前Module的名称，确保该名称在整个应用中唯一。命名规则如下 ： - 由字母、数字和下划线组成，且必须以字母开头。 - 最大长度31字节。 应用升级时允许修改该名称，但需要应用适配Module相关数据目录的迁移，详见文件管理接口。 | 字符串 | 该标签不可缺省。 |
| type |  标识当前Module的类型。支持的取值如下： - entry：应用的主模块。 - feature：应用的动态特性模块。 - har：静态共享包模块。 - shared：动态共享包模块。 | 字符串 | 该标签不可缺省。 |
| srcEntry | 标识当前Module所对应入口UIAbility或者ExtensionAbility的代码路径，需要和mainElement字段指向同一个UIAbility或者ExtensionAbility，取值为长度不超过127字节的字符串。 | 字符串 | 该标签可缺省，缺省值为空。 |
| description | 标识当前Module的描述信息，开发者可以通过该字段描述当前模块的功能与作用，取值为长度不超过255字节的字符串，可以采用字符串资源索引格式。 | 字符串 | 该标签可缺省，缺省值为空。 |
| mainElement | 标识当前Module的入口UIAbility名称或者ExtensionAbility名称，需要和srcEntry字段指向同一个UIAbility或者ExtensionAbility，取值为长度不超过255字节的字符串。 | 字符串 | 该标签可缺省，缺省值为空。 |
| deviceTypes |  标识当前Module可以运行在哪类设备上。 说明： 当存在多个模块时，各模块中的配置可以不一致，但必须包含所需的设备类型以确保正常运行。 | 字符串数组 | 该标签不可缺省。 |
| deliveryWithInstall |  标识当前Module是否在用户主动安装的时候安装，即该Module对应的HAP是否跟随应用一起安装。 - true：主动安装时安装。 - false：主动安装时不安装。 | 布尔值 | 该标签不可缺省。 |
| installationFree |  标识当前Module是否支持免安装特性。 - true：表示支持免安装特性，且符合免安装约束。 - false：表示不支持免安装特性。 说明： 当bundleType为元服务时，该字段需要配置为true。反之，该字段需要配置为false。 | 布尔值 | 该标签不可缺省。 |
| virtualMachine | 标识当前Module运行的目标虚拟机类型，供云端分发使用，如应用市场和分发中心。如果目标虚拟机类型为ArkTS引擎，则其值为“ark+版本号”。 | 字符串 | 该标签由IDE构建HAP的时候自动插入。 |
| pages | 标识当前Module的profile资源，用于列举每个页面信息，取值为长度不超过255字节的字符串。 | 字符串 | 在有UIAbility的场景下，该标签不可缺省。 |
| metadata | 标识当前Module的自定义元信息，可通过资源引用的方式配置distributionFilter、shortcuts等信息。只对当前Module、UIAbility、ExtensionAbility生效。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| abilities | 标识当前Module中UIAbility的配置信息，只对当前UIAbility生效。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| extensionAbilities | 标识当前Module中ExtensionAbility的配置信息，只对当前ExtensionAbility生效。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| definePermissions | 标识系统资源hap定义的权限，不支持应用自定义权限。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| requestPermissions | 标识当前应用运行时需向系统申请的权限集合。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| testRunner | 标识用于测试当前Module的测试框架的配置。 | 对象 | 该标签可缺省，缺省值为空。 |
| atomicService | 标识当前应用是元服务时，有关元服务的相关配置。 | 对象 | 该标签可缺省，缺省值为空。 |
| dependencies | 标识当前模块运行时依赖的共享库列表。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| targetModuleName | 标识当前包所指定的目标module，确保该名称在整个应用中唯一。取值为长度不超过31字节的字符串，不支持中文。配置该字段的Module具有overlay特性。仅在动态共享包（HSP）中适用。 | 字符串 | 该标签可缺省，缺省值为空。 |
| targetPriority | 标识当前Module的优先级，取值范围为1~100。配置targetModuleName字段之后，才需要配置该字段。仅在动态共享包（HSP）中适用。 | 整型数值 | 该标签可缺省，缺省值为1。 |
| proxyData | 标识当前Module提供的数据代理列表。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| isolationMode |  标识当前Module的多进程配置项。支持的取值如下： - nonisolationFirst：优先在非独立进程中运行。 - isolationFirst：优先在独立进程中运行。 - isolationOnly：只在独立进程中运行。 - nonisolationOnly：只在非独立进程中运行。 说明： 1.仅2in1和tablet设备支持将当前Module设置为独立进程。 2.该字段仅对HAP生效。 | 字符串 | 该标签可缺省，缺省值为nonisolationFirst。 |
| generateBuildHash |  标识当前HAP/HSP是否由打包工具生成哈希值。当配置为true时，如果系统OTA升级时应用versionCode保持不变，可根据哈希值判断应用是否需要升级。 该字段仅在app.json5文件中的generateBuildHash字段为false时使能。 说明： 该字段仅对预置应用生效。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| compressNativeLibs |  标识libs库是否以压缩存储的方式打包到HAP。 - true：libs库以压缩方式存储。 - false：libs库以不压缩方式存储。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| libIsolation |  用于区分同应用不同HAP下的.so文件，以防止.so冲突。 - true：当前HAP的.so文件会储存在libs目录中以Module名命名的路径下。 - false：当前HAP的.so文件会直接储存在libs目录中。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| fileContextMenu |  标识当前HAP的右键菜单配置项。取值为长度不超过255字节的字符串。 说明： 仅在PC/2in1设备上生效。 | 字符串 | 该标签可缺省，缺省值为空。 |
| querySchemes | 标识允许当前应用进行跳转查询的URL schemes，只允许entry类型模块配置，最多50个，每个字符串取值不超过128字节。 | 字符串数组 | 该标签可缺省，缺省值为空。 |
| routerMap | 标识当前模块配置的路由表路径。取值为长度不超过255字节的字符串。 | 字符串 | 该标签可缺省，缺省值为空。 |
| appEnvironments | 标识当前模块配置的应用环境变量，只允许entry和feature模块配置。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| appStartup | 标识当前Module启动框架配置路径，仅在Entry中生效。 | 字符串 | 该标签可缺省，缺省值为空。 |
| hnpPackages | 标识当前应用包含的Native软件包信息。只允许entry类型模块配置。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| abilitySrcEntryDelegator |  标识当前Module需要重定向到的UIAbility的名称，与abilityStageSrcEntryDelegator字段组合使用，共同指定重定向的目标对象。 说明： 1.从API version 17开始，支持该字段。 2.当UIAbility是通过startAbilityByCall接口启动时，该字段不生效。 3.不支持在HAR的配置文件中配置该字段，也不支持重定向到HAR的UIAbility。 | 字符串 | 该标签可缺省，缺省值为空。 |
| abilityStageSrcEntryDelegator |  标识当前Module需要重定向到的UIAbility对应的Module名称（不可为当前Module名称），与abilitySrcEntryDelegator字段组合使用，共同指定重定向的目标对象。 说明： 1.从API version 17开始，支持该字段。 2.当UIAbility是通过startAbilityByCall接口启动时，该字段不生效。 3.不支持在HAR的配置文件中配置该字段，也不支持重定向到HAR的UIAbility。 | 字符串 | 该标签可缺省，缺省值为空。 |
标识当前Module的名称，确保该名称在整个应用中唯一。命名规则如下 ：
- 由字母、数字和下划线组成，且必须以字母开头。
- 最大长度31字节。
应用升级时允许修改该名称，但需要应用适配Module相关数据目录的迁移，详见文件管理接口。
标识当前Module的类型。支持的取值如下：
- entry：应用的主模块。
- feature：应用的动态特性模块。
- har：静态共享包模块。
- shared：动态共享包模块。
标识当前Module可以运行在哪类设备上。
说明：
当存在多个模块时，各模块中的配置可以不一致，但必须包含所需的设备类型以确保正常运行。
标识当前Module是否在用户主动安装的时候安装，即该Module对应的HAP是否跟随应用一起安装。
- true：主动安装时安装。
- false：主动安装时不安装。
标识当前Module是否支持免安装特性。
- true：表示支持免安装特性，且符合免安装约束。
- false：表示不支持免安装特性。
说明：
当bundleType为元服务时，该字段需要配置为true。反之，该字段需要配置为false。
标识当前Module的多进程配置项。支持的取值如下：
- nonisolationFirst：优先在非独立进程中运行。
- isolationFirst：优先在独立进程中运行。
- isolationOnly：只在独立进程中运行。
- nonisolationOnly：只在非独立进程中运行。
说明：
1.仅2in1和tablet设备支持将当前Module设置为独立进程。
2.该字段仅对HAP生效。
标识当前HAP/HSP是否由打包工具生成哈希值。当配置为true时，如果系统OTA升级时应用versionCode保持不变，可根据哈希值判断应用是否需要升级。
该字段仅在app.json5文件中的generateBuildHash字段为false时使能。
说明：
该字段仅对预置应用生效。
标识libs库是否以压缩存储的方式打包到HAP。
- true：libs库以压缩方式存储。
- false：libs库以不压缩方式存储。
用于区分同应用不同HAP下的.so文件，以防止.so冲突。
- true：当前HAP的.so文件会储存在libs目录中以Module名命名的路径下。
- false：当前HAP的.so文件会直接储存在libs目录中。
标识当前HAP的右键菜单配置项。取值为长度不超过255字节的字符串。
说明：
仅在PC/2in1设备上生效。
标识当前Module需要重定向到的UIAbility的名称，与abilityStageSrcEntryDelegator字段组合使用，共同指定重定向的目标对象。
说明：
1.从API version 17开始，支持该字段。
2.当UIAbility是通过startAbilityByCall接口启动时，该字段不生效。
3.不支持在HAR的配置文件中配置该字段，也不支持重定向到HAR的UIAbility。
标识当前Module需要重定向到的UIAbility对应的Module名称（不可为当前Module名称），与abilitySrcEntryDelegator字段组合使用，共同指定重定向的目标对象。
说明：
1.从API version 17开始，支持该字段。
2.当UIAbility是通过startAbilityByCall接口启动时，该字段不生效。
3.不支持在HAR的配置文件中配置该字段，也不支持重定向到HAR的UIAbility。
deviceTypes标签
表2deviceTypes标签说明
| 设备类型 | 枚举值 | 说明 |
| --- | --- | --- |
| 手机 | phone | - |
| 平板 | tablet | - |
| PC/2in1 | 2in1 | 即PC设备，主要交互方式以多窗口、多任务及键盘鼠标操作为主，充分发挥设备的生产力属性。在HarmonyOS文档中，所有“2in1”均代表“PC/2in1”。 |
| 智慧屏 | tv | - |
| 智能手表 | wearable | 系统能力较丰富的手表，具备电话功能。 |
| 车机 | car | - |
deviceTypes示例：
```json
{
"module": {
"name": "myHapName",
"type": "feature",
"deviceTypes" : [
"tablet"
]
}
}
```
pages标签
该标签是一个profile文件资源，用于指定描述页面信息的配置文件。
```json
{
"module": {
// ...
"pages": "$profile:main_pages", // 通过profile下的资源文件配置
}
}
```
在开发视图的resources/base/profile下面定义配置文件main_pages.json，其中文件名"main_pages"可自定义，需要和pages标签指定的信息对应。配置文件中列举了当前应用组件中的页面信息，包含页面的路由信息和显示窗口相关的配置。
表3pages标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| src | 标识当前Module中所有页面的路由信息，包括页面路径和页面名称。其中，页面路径是以当前Module的src/main/ets为基准。该标签取值为一个字符串数组，其中每个元素表示一个页面。 | 字符串数组 | 该标签不可缺省。 |
| window | 标识用于定义与显示窗口相关的配置。 | 对象 | 该标签可缺省，缺省值为空。 |
表4window标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| designWidth | 标识页面设计基准宽度。以此为基准，根据实际设备宽度来缩放元素大小。 | 数值 | 可缺省，缺省值为720px。 |
| autoDesignWidth | 标识页面设计基准宽度是否自动计算。当配置为true时，designWidth将会被忽略，设计基准宽度由设备宽度与屏幕密度计算得出。 | 布尔值 | 可缺省，缺省值为false。 |
```json
{
"src": [
"pages/index/mainPage",
"pages/second/payment",
"pages/third/shopping_cart",
"pages/four/owner"
],
"window": {
"designWidth": 720,
"autoDesignWidth": false
}
}
```
metadata标签
该标签标识HAP的自定义元信息，标签值为数组类型，包含name、value、resource三个子标签。
表5metadata标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识数据项的名称，取值为长度不超过255字节的字符串。 | 字符串 | 该标签可缺省，缺省值为空。 |
| value | 标识数据项的值，取值为长度不超过255字节的字符串。 | 字符串 | 该标签可缺省，缺省值为空。 |
| resource | 标识定义用户自定义数据格式，取值为长度不超过255字节的字符串，内容为标识该数据的资源索引。 | 字符串 | 该标签可缺省，缺省值为空。 |
metadata标签可配置主窗的默认大小和位置（单位为vp），name为ohos.ability.window.height表示主窗默认高度，name为ohos.ability.window.width表示主窗默认宽度，name为ohos.ability.window.left表示主窗默认左边的位置，其配置格式为(对齐方式)(+|-偏移量)，对齐方式包括center、left和right，默认值为left，偏移量为0时可以省略，name为ohos.ability.window.top表示主窗顶部的位置，对齐方式包括center、top和bottom，默认值为top，两者同时省略按照系统默认层叠规格。
metadata标签可配置使能移除启动页功能，name为enable.remove.starting.window，value可配置为true/false，未配置则默认为false。
resource属性值使用“$profile:文件名”的方式指定文件所在位置，$profile表示资源的路径为工程中的/resources/base/profile目录下。例如$profile:shortcuts_config指定了/resources/base/profile/shortcuts_config.json配置文件。
```json
{
"module": {
"metadata": [{
"name": "module_metadata",
"value": "a test demo for module metadata",
"resource": "$profile:shortcuts_config"
}],
"abilities": [{
"metadata": [{
"name": "ability_metadata",
"value": "a test demo for ability",
"resource": "$profile:config_file"
},
{
"name": "ability_metadata_2",
"value": "a string test",
"resource": "$profile:config_file"
},
{
"name": "ohos.ability.window.height",
"value": "987"
},
{
"name": "ohos.ability.window.width",
"value": "1300"
},
{
"name": "ohos.ability.window.left",
"value": "right-50"
},
{
"name": "ohos.ability.window.top",
"value": "center+50"
},
{
"name": "enable.remove.starting.window",
"value": "true"
}],
}],
"extensionAbilities": [{
"metadata": [{
"name": "extensionAbility_metadata",
"value": "a test for extensionAbility",
"resource": "$profile:config_file"
},
{
"name": "extensionAbility_metadata_2",
"value": "a string test",
"resource": "$profile:config_file"
}],
}]
}
}
```
abilities标签
abilities标签描述UIAbility组件的配置信息，标签值为数组类型，该标签下的配置只对当前UIAbility生效。
表6abilities标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识当前UIAbility组件的名称，确保该名称在整个应用中唯一。取值为长度不超过127字节的字符串，不支持中文。 | 字符串 | 该标签不可缺省。 |
| srcEntry | 标识入口UIAbility的代码路径，取值为长度不超过127字节的字符串。 | 字符串 | 该标签不可缺省。 |
| launchType |  标识当前UIAbility组件的启动模式，支持的取值如下： - multiton：多实例模式，每次启动创建一个新实例。 - singleton：单实例模式，仅第一次启动创建新实例。 - specified：指定实例模式，运行时由开发者决定是否创建新实例。 - standard：multiton的曾用名，效果与多实例模式一致。 | 字符串 | 该标签可缺省，该标签缺省为“singleton”。 |
| description | 标识当前UIAbility组件的描述信息，开发者可以通过该字段描述当前组件的功能与作用，取值为长度不超过255字节的字符串。要求采用描述信息的资源索引，以支持多语言。 | 字符串 | 该标签可缺省，缺省值为空。 |
| icon | 标识当前UIAbility组件的图标，取值为图标资源文件的索引。 | 字符串 | 该标签可缺省，缺省值为空。 |
| label | 标识当前UIAbility组件对用户显示的名称，要求采用该名称的资源索引，以支持多语言。取值为长度不超过255字节的字符串。 | 字符串 | 该标签可缺省，缺省值为空。 |
| permissions |  标识当前UIAbility组件自定义的权限信息。当其他应用访问该UIAbility时，需要申请相应的权限信息。 一个数组元素为一个权限名称。通常采用反向域名格式（不超过255字节），取值为系统预定义的权限。 | 字符串数组 | 该标签可缺省，缺省值为空。 |
| metadata | 标识当前UIAbility组件的元信息。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| exported |  标识当前UIAbility组件是否可以被其他应用调用。 - true：表示可以被其他应用调用。 - false：表示不可以被其他应用调用，包括无法被aa工具命令拉起应用。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| continuable |  标识当前UIAbility组件是否支持跨端迁移。 - true：表示支持迁移。 - false：表示不支持迁移。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| skills |  标识当前UIAbility组件或ExtensionAbility组件能够接收的Want特征集，为数组格式。 配置规则： - 对于Entry类型的HAP，应用可以配置多个具有入口能力的skills标签（即配置了action.system.home和entity.system.home）。 - 对于Feature类型的HAP，只有应用可以配置具有入口能力的skills标签，服务不允许配置。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| backgroundModes |  标识当前UIAbility组件的长时任务集合，指定用于满足特定类型的长时任务。 长时任务类型有如下： - dataTransfer：通过网络/对端设备进行数据下载、备份、分享、传输等。 - audioPlayback：音频播放。 - audioRecording：录音。 - location：定位、导航。 - bluetoothInteraction：蓝牙扫描、连接、传输（穿戴）。 - multiDeviceConnection：多设备互联。 - taskKeeping：计算。 | 字符串数组 | 该标签可缺省，缺省值为空。 |
| startWindowIcon | 标识当前UIAbility组件启动页面图标资源文件的索引，取值为长度不超过255字节的字符串。 | 字符串 | 该标签不可缺省。 |
| startWindowBackground |  标识当前UIAbility组件启动页面背景颜色资源文件的索引，取值为长度不超过255字节的字符串。 取值示例：$color:red。 | 字符串 | 该标签不可缺省。 |
| removeMissionAfterTerminate |  标识当前UIAbility组件销毁后，是否从任务列表中移除任务。 - true表示销毁后移除任务。 - false表示销毁后不移除任务。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| orientation |  标识当前UIAbility组件启动时的方向，支持配置枚举和启动方向资源索引。枚举支持的取值如下： - unspecified：未指定方向，由系统自动判断显示方向。 - landscape：横屏。 - portrait：竖屏。 - follow_recent：跟随背景窗口的旋转模式。 - landscape_inverted：反向横屏。 - portrait_inverted：反向竖屏。 - auto_rotation：随传感器旋转。 - auto_rotation_landscape：传感器横屏旋转，包括横屏和反向横屏。 - auto_rotation_portrait：传感器竖屏旋转，包括竖屏和反向竖屏。 - auto_rotation_restricted：传感器开关打开，方向可随传感器旋转。 - auto_rotation_landscape_restricted：传感器开关打开，方向可随传感器旋转为横屏， 包括横屏和反向横屏。 - auto_rotation_portrait_restricted：传感器开关打开，方向随可传感器旋转为竖屏， 包括竖屏和反向竖屏。 - locked：传感器开关关闭，方向锁定。 - auto_rotation_unspecified：受开关控制和由系统判定的自动旋转模式。 - follow_desktop：跟随桌面的旋转模式。 配置启动方向的资源索引时，取值为长度不超过255字节的字符串。 启动方向资源索引配置示例：$string:orientation。 | 字符串 | 该标签可缺省，缺省值为unspecified。 |
| supportWindowMode |  标识当前UIAbility组件所支持的窗口模式。支持的取值如下： - fullscreen：全屏模式。 - split：分屏模式。 - floating：悬浮窗模式。 | 字符串数组 |  该标签可缺省，缺省值为 ["fullscreen", "split", "floating"]。 |
| maxWindowRatio | 标识当前UIAbility组件支持的最大的宽高比。该标签最小取值为0。 | 数值 | 该标签可缺省，缺省值为平台支持的最大的宽高比。 |
| minWindowRatio | 标识当前UIAbility组件支持的最小的宽高比。该标签最小取值为0。 | 数值 | 该标签可缺省，缺省值为平台支持的最小的宽高比。 |
| maxWindowWidth |  标识当前UIAbility组件支持的最大的窗口宽度，宽度单位为vp。 最小取值为minWindowWidth，最大取值为平台支持的最大窗口宽度。窗口尺寸可以参考窗口大小限制。 | 数值 | 该标签可缺省，缺省值为平台支持的最大的窗口宽度。 |
| minWindowWidth |  标识当前UIAbility组件支持的最小的窗口宽度， 宽度单位为vp。 最小取值为平台支持的最小窗口宽度，最大取值为maxWindowWidth。窗口尺寸可以参考窗口大小限制。 | 数值 | 该标签可缺省，缺省值为平台支持的最小的窗口宽度。 |
| maxWindowHeight |  标识当前UIAbility组件支持的最大的窗口高度， 高度单位为vp。 最小取值为minWindowHeight，最大取值为平台支持的最大窗口高度。 窗口尺寸可以参考窗口大小限制。 | 数值 | 该标签可缺省，缺省值为平台支持的最大的窗口高度。 |
| minWindowHeight |  标识当前UIAbility组件支持的最小的窗口高度， 高度单位为vp。 最小取值为平台支持的最小窗口高度，最大取值为maxWindowHeight。窗口尺寸可以参考窗口大小限制。 | 数值 | 该标签可缺省，缺省值为平台支持的最小的窗口高度。 |
| recoverable |  标识当前UIAbility组件是否支持在检测到应用故障后，恢复到应用原界面。 - true：支持检测到出现故障后，恢复到原界面。 - false：不支持检测到出现故障后，恢复到原界面。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| isolationProcess |  标识组件能否运行在独立的进程中。 - true：表示能运行在独立的进程中。 - false：表示不能运行在独立的进程中。 说明： 仅2in1和tablet设备支持将UIAbility设置为独立进程。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| excludeFromDock |  标识当前UIAbility组件是否支持从dock区域隐藏图标。 - true：表示在dock区域隐藏。 - false：表示不能在dock区域隐藏。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| preferMultiWindowOrientation |  标识当前UIAbility组件多窗布局方向： - default：缺省值，参数不配置默认值，建议其他应用类配置。 - portrait：多窗布局方向为竖向，建议竖向游戏类应用配置。 - landscape：多窗布局方向为横向，配置后支持横屏悬浮窗和上下分屏，建议横向游戏类应用配置。 - landscape_auto：多窗布局动态可变为横向，需要配合API enableLandScapeMultiWindow/disableLandScapeMultiWindow使用，建议视频类应用配置。 | 字符串 | 该标签可缺省，缺省值为default。 |
| continueType | 标识当前UIAbility组件的跨端迁移类型。 | 字符串数组 | 该标签可缺省，缺省值为当前组件的名称。 |
| continueBundleName |  标识当前应用支持跨端迁移的其它应用名称列表。 说明： 不能配置为本应用包名，仅为了做异包名迁移使用。 | 字符串数组 | 该标签可缺省，缺省值为空。 |
| process |  标识组件的进程标签。 说明： 仅在2in1设备上生效，UIAbility组件和type为embeddedUI的ExtensionAbility组件标签一致时运行在同一个进程中。 | 字符串 | 该标签可缺省，缺省值为空。 |
标识当前UIAbility组件的启动模式，支持的取值如下：
- multiton：多实例模式，每次启动创建一个新实例。
- singleton：单实例模式，仅第一次启动创建新实例。
- specified：指定实例模式，运行时由开发者决定是否创建新实例。
- standard：multiton的曾用名，效果与多实例模式一致。
标识当前UIAbility组件自定义的权限信息。当其他应用访问该UIAbility时，需要申请相应的权限信息。
一个数组元素为一个权限名称。通常采用反向域名格式（不超过255字节），取值为系统预定义的权限。
标识当前UIAbility组件是否可以被其他应用调用。
- true：表示可以被其他应用调用。
- false：表示不可以被其他应用调用，包括无法被aa工具命令拉起应用。
标识当前UIAbility组件是否支持跨端迁移。
- true：表示支持迁移。
- false：表示不支持迁移。
标识当前UIAbility组件或ExtensionAbility组件能够接收的Want特征集，为数组格式。
配置规则：
- 对于Entry类型的HAP，应用可以配置多个具有入口能力的skills标签（即配置了action.system.home和entity.system.home）。
- 对于Feature类型的HAP，只有应用可以配置具有入口能力的skills标签，服务不允许配置。
标识当前UIAbility组件的长时任务集合，指定用于满足特定类型的长时任务。
长时任务类型有如下：
- dataTransfer：通过网络/对端设备进行数据下载、备份、分享、传输等。
- audioPlayback：音频播放。
- audioRecording：录音。
- location：定位、导航。
- bluetoothInteraction：蓝牙扫描、连接、传输（穿戴）。
- multiDeviceConnection：多设备互联。
- taskKeeping：计算。
标识当前UIAbility组件启动页面背景颜色资源文件的索引，取值为长度不超过255字节的字符串。
取值示例：$color:red。
标识当前UIAbility组件销毁后，是否从任务列表中移除任务。
- true表示销毁后移除任务。
- false表示销毁后不移除任务。
标识当前UIAbility组件启动时的方向，支持配置枚举和启动方向资源索引。枚举支持的取值如下：
- unspecified：未指定方向，由系统自动判断显示方向。
- landscape：横屏。
- portrait：竖屏。
- follow_recent：跟随背景窗口的旋转模式。
- landscape_inverted：反向横屏。
- portrait_inverted：反向竖屏。
- auto_rotation：随传感器旋转。
- auto_rotation_landscape：传感器横屏旋转，包括横屏和反向横屏。
- auto_rotation_portrait：传感器竖屏旋转，包括竖屏和反向竖屏。
- auto_rotation_restricted：传感器开关打开，方向可随传感器旋转。
- auto_rotation_landscape_restricted：传感器开关打开，方向可随传感器旋转为横屏， 包括横屏和反向横屏。
- auto_rotation_portrait_restricted：传感器开关打开，方向随可传感器旋转为竖屏， 包括竖屏和反向竖屏。
- locked：传感器开关关闭，方向锁定。
- auto_rotation_unspecified：受开关控制和由系统判定的自动旋转模式。
- follow_desktop：跟随桌面的旋转模式。
配置启动方向的资源索引时，取值为长度不超过255字节的字符串。
启动方向资源索引配置示例：$string:orientation。
标识当前UIAbility组件所支持的窗口模式。支持的取值如下：
- fullscreen：全屏模式。
- split：分屏模式。
- floating：悬浮窗模式。
该标签可缺省，缺省值为
["fullscreen", "split", "floating"]。
标识当前UIAbility组件支持的最大的窗口宽度，宽度单位为vp。
最小取值为minWindowWidth，最大取值为平台支持的最大窗口宽度。窗口尺寸可以参考窗口大小限制。
标识当前UIAbility组件支持的最小的窗口宽度， 宽度单位为vp。
最小取值为平台支持的最小窗口宽度，最大取值为maxWindowWidth。窗口尺寸可以参考窗口大小限制。
标识当前UIAbility组件支持的最大的窗口高度， 高度单位为vp。
最小取值为minWindowHeight，最大取值为平台支持的最大窗口高度。 窗口尺寸可以参考窗口大小限制。
标识当前UIAbility组件支持的最小的窗口高度， 高度单位为vp。
最小取值为平台支持的最小窗口高度，最大取值为maxWindowHeight。窗口尺寸可以参考窗口大小限制。
标识当前UIAbility组件是否支持在检测到应用故障后，恢复到应用原界面。
- true：支持检测到出现故障后，恢复到原界面。
- false：不支持检测到出现故障后，恢复到原界面。
标识组件能否运行在独立的进程中。
- true：表示能运行在独立的进程中。
- false：表示不能运行在独立的进程中。
说明：
仅2in1和tablet设备支持将UIAbility设置为独立进程。
标识当前UIAbility组件是否支持从dock区域隐藏图标。
- true：表示在dock区域隐藏。
- false：表示不能在dock区域隐藏。
标识当前UIAbility组件多窗布局方向：
- default：缺省值，参数不配置默认值，建议其他应用类配置。
- portrait：多窗布局方向为竖向，建议竖向游戏类应用配置。
- landscape：多窗布局方向为横向，配置后支持横屏悬浮窗和上下分屏，建议横向游戏类应用配置。
- landscape_auto：多窗布局动态可变为横向，需要配合API enableLandScapeMultiWindow/disableLandScapeMultiWindow使用，建议视频类应用配置。
标识当前应用支持跨端迁移的其它应用名称列表。
说明：
不能配置为本应用包名，仅为了做异包名迁移使用。
标识组件的进程标签。
说明：
仅在2in1设备上生效，UIAbility组件和type为embeddedUI的ExtensionAbility组件标签一致时运行在同一个进程中。
abilities示例：
```json
{
"abilities": [{
"name": "EntryAbility",
"srcEntry": "./ets/entryability/EntryAbility.ets",
"launchType":"singleton",
"description": "$string:description_main_ability",
"icon": "$media:layered_image",
"label": "Login",
"permissions": [],
"metadata": [],
"exported": true,
"continuable": true,
"skills": [{
"actions": ["ohos.want.action.home"],
"entities": ["entity.system.home"],
"uris": []
}],
"backgroundModes": [
"dataTransfer",
"audioPlayback",
"audioRecording",
"location",
"bluetoothInteraction",
"multiDeviceConnection",
"wifiInteraction",
"voip",
"taskKeeping"
],
"startWindowIcon": "$media:icon",
"startWindowBackground": "$color:red",
"removeMissionAfterTerminate": true,
"orientation": "$string:orientation",
"supportWindowMode": ["fullscreen", "split", "floating"],
"maxWindowRatio": 3.5,
"minWindowRatio": 0.5,
"maxWindowWidth": 2560,
"minWindowWidth": 1400,
"maxWindowHeight": 300,
"minWindowHeight": 200,
"excludeFromDock": false,
"preferMultiWindowOrientation": "default",
"isolationProcess": false,
"continueType": [
"continueType1",
"continueType2"
],
"continueBundleName": [
"com.example.myapplication1",
"com.example.myapplication2"
],
"process": ":processTag"
}]
}
```
skills标签
该标签标识UIAbility组件或者ExtensionAbility组件能够接收的Want的特征。
表7skills标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| actions |  标识能够接收的Action值集合，取值通常为系统预定义的action值，也允许自定义。 一个skill中不建议配置多个action，否则可能导致无法匹配预期场景。 | 字符串数组 | 该标签可缺省，缺省值为空。 |
| entities |  标识能够接收的Entity值的集合。 一个skill中不建议配置多个entity，否则可能导致无法匹配预期场景。 | 字符串数组 | 该标签可缺省，缺省值为空。 |
| uris | 标识与Want中URI（Uniform Resource Identifier）相匹配的集合。数组允许的最大数量为512。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| permissions |  标识当前UIAbility组件自定义的权限信息。当其他应用访问该UIAbility时，需要申请相应的权限信息。 一个数组元素为一个权限名称。通常采用反向域名格式（不超过255字节），取值为系统预定义的权限。 | 字符串数组 | 该标签可缺省，缺省值为空。 |
| domainVerify | 标识是否开启域名校验。 | 布尔值 | 该标签可缺省，缺省值为false。 |
标识能够接收的Action值集合，取值通常为系统预定义的action值，也允许自定义。
一个skill中不建议配置多个action，否则可能导致无法匹配预期场景。
标识能够接收的Entity值的集合。
一个skill中不建议配置多个entity，否则可能导致无法匹配预期场景。
标识当前UIAbility组件自定义的权限信息。当其他应用访问该UIAbility时，需要申请相应的权限信息。
一个数组元素为一个权限名称。通常采用反向域名格式（不超过255字节），取值为系统预定义的权限。
表8uris标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| scheme | 标识URI的协议名部分，常见的有http、https、file、ftp等。 | 字符串 | uris中仅配置type时可以缺省，缺省值为空，否则不可缺省。 |
| host |  标识URI的主机地址部分，该字段在scheme存在时才有意义。常见的方式： - 域名方式，如example.com。 - IP地址方式，如10.10.10.1。 | 字符串 | 该标签可缺省，缺省值为空。 |
| port | 标识URI的端口部分。如http默认端口为80，https默认端口是443，ftp默认端口是21。该字段在scheme和host都存在时才有意义。 | 字符串 | 该标签可缺省，缺省值为空。 |
| path | pathStartWith | pathRegex | 标识URI的路径部分，path、pathStartWith和pathRegex配置时三选一。path标识URI与want中的路径部分全匹配，pathStartWith标识URI与want中的路径部分允许前缀匹配，pathRegex标识URI与want中的路径部分允许正则匹配。该字段在scheme和host都存在时才有意义。 | 字符串 | 该标签可缺省，缺省值为空。 |
| type | 标识与Want相匹配的数据类型，使用MIME（Multipurpose Internet Mail Extensions）类型规范和UniformDataType类型规范。可与scheme同时配置，也可以单独配置。 | 字符串 | 该标签可缺省，缺省值为空。 |
| utd | 标识与Want相匹配的标准化数据类型，适用于分享等场景。 | 字符串 | 该标签可缺省，缺省值为空。 |
| maxFileSupported | 对于指定类型的文件，标识一次能接收或打开的最大数量，适用于分享等场景，需要与utd配合使用。 | 整数 | 该标签可缺省，缺省值为0。 |
| linkFeature | 标识URI提供的功能类型（如文件打开、分享、导航等），用于实现应用间跳转。取值为长度不超过127字节的字符串，不支持中文。同一Bundle中声明的linkFeature数量不能超过150个。详情见linkFeature标签说明。 | 字符串 | 该标签可缺省，缺省值为空。 |
标识URI的主机地址部分，该字段在scheme存在时才有意义。常见的方式：
- 域名方式，如example.com。
- IP地址方式，如10.10.10.1。
skills示例：
```json
{
"abilities": [
{
"skills": [
{
"actions": [
"action.system.home"
],
"entities": [
"entity.system.home"
],
"uris": [
{
"scheme":"http",
"host":"example.com",
"port":"80",
"path":"path",
"type": "text/*",
"linkFeature": "Login"
}
],
"permissions": [],
"domainVerify": false
}
]
}
]
}
```
extensionAbilities标签
描述extensionAbilities的配置信息，标签值为数组类型，该标签下的配置只对当前extensionAbilities生效。
表9extensionAbilities标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识当前ExtensionAbility组件的名称，确保该名称在整个应用中唯一，取值为长度不超过127字节的字符串。 | 字符串 | 该标签不可缺省。 |
| srcEntry | 标识当前ExtensionAbility组件所对应的代码路径，取值为长度不超过127字节的字符串。 | 字符串 | 该标签不可缺省。 |
| description | 标识当前ExtensionAbility组件的描述，开发者可以通过该字段描述当前组件的功能与作用，取值为长度不超过255字节的字符串，可以是对描述内容的资源索引，用于支持多语言。 | 字符串 | 该标签可缺省，缺省值为空。 |
| icon | 标识当前ExtensionAbility组件的图标，取值为资源文件的索引。如果ExtensionAbility组件被配置为MainElement，该标签必须配置。 | 字符串 | 该标签可缺省，缺省值为空。 |
| label | 标识当前ExtensionAbility组件对用户显示的名称，取值为该名称的资源索引，以支持多语言，字符串长度不超过255字节。如果ExtensionAbility被配置当前Module的mainElement时，该标签必须配置，且要确保应用内唯一。 | 字符串 | 该标签可缺省，缺省值为空。 |
| type |  标识当前ExtensionAbility组件的类型，支持的取值如下： - form：卡片的ExtensionAbility。 - workScheduler：延时任务的ExtensionAbility。 - inputMethod：输入法的ExtensionAbility。 - accessibility：辅助能力的ExtensionAbility。 - wallpaper：壁纸的ExtensionAbility。 - backup：数据备份的ExtensionAbility。 - thumbnail：获取文件缩略图的ExtensionAbility，开发者可以对自定义文件类型的文件提供缩略。 - preview：该ExtensionAbility会将文件解析后在一个窗口中显示，开发者可以通过将此窗口组合到其他应用窗口中。 - print：打印框架的ExtensionAbility。 - push：推送的ExtensionAbility。 - driver：驱动框架的ExtensionAbility。 - remoteNotification：远程通知的ExtensionAbility。 - remoteLocation：远程定位的ExtensionAbility。 - voip：网络音视频通话的ExtensionAbility。 - action：自定义操作业务模板的ExtensionAbility，为开发者提供基于UIExtension的自定义操作业务模板。 - embeddedUI：嵌入式UI扩展能力，提供跨进程界面嵌入的能力。 - insightIntentUI：为开发者提供能被小艺意图调用，以窗口形态呈现内容的扩展能力。 - ads：广告业务的ExtensionAbility，与AdComponent控件组合使用，将广告页面展示到其他应用中。仅支持设备厂商使用。 - photoEditor：图片编辑业务的ExtensionAbility，为开发者提供基于UIExtension的图片编辑业务模版。 - appAccountAuthorization：应用账号授权扩展能力的ExtensionAbility，用于处理账号授权请求，比如账号登录授权。 - autoFill/password：用于账号和密码自动填充业务的ExtensionAbility，支持数据的保存、填充能力。 - hms/account：应用账号管理能力的ExtensionAbility。 - autoFill/smart：用于情景化场景自动填充业务的ExtensionAbility，支持数据的保存、填充能力。 - statusBarView：一步直达的ExtensionAbility。 - recentPhoto：最近照片推荐的ExtensionAbility。 - fence：地理围栏的ExtensionAbility。 - callerInfoQuery：企业联系人查询的ExtensionAbility。 | 字符串 | 该标签不可缺省。 |
| permissions |  标识当前ExtensionAbility组件自定义的权限信息。当其他应用访问该ExtensionAbility时，需要申请相应的权限信息。 一个数组元素为一个权限名称。通常采用反向域名格式（最大255字节），取值为系统预定义的权限。 | 字符串数组 | 该标签可缺省，缺省值为空。 |
| readPermission | 标识读取当前ExtensionAbility组件数据所需的权限，取值为长度不超过255字节的字符串。仅当ExtensionAbility组件的type为dataShare时支持配置该标签。 | 字符串 | 该标签可缺省，缺省值为空。 |
| writePermission | 标识向当前ExtensionAbility组件写数据所需的权限，取值为长度不超过255字节的字符串。仅当ExtensionAbility组件的type为dataShare时支持配置该标签。 | 字符串 | 该标签可缺省，缺省值为空。 |
| uri |  标识当前ExtensionAbility组件提供的数据URI，取值为长度不超过255字节的字符数组，用反向域名的格式表示。 说明： 该标签在type为dataShare类型的ExtensionAbility时，不可缺省。 | 字符串 | 该标签可缺省，缺省值为空。 |
| skills |  标识当前ExtensionAbility组件能够接收的Want的特征集。 配置规则：entry包可以配置多个具有入口能力的skills标签（配置了action.system.home和entity.system.home）的ExtensionAbility，其中第一个配置了skills标签的ExtensionAbility中的label和icon作为服务或应用的label和icon。 说明： 服务的Feature包不能配置具有入口能力的skills标签。 应用的Feature包可以配置具有入口能力的skills标签。 | 数组 | 该标签可缺省，缺省值为空。 |
| metadata |  标识当前ExtensionAbility组件的元信息。 说明： 该标签在type为form时，不可缺省，且必须存在一个name为ohos.extension.form的对象值，其对应的resource值不能缺省，为卡片的二级资源引用。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| exported |  标识当前ExtensionAbility组件是否可以被其他应用调用。 - true：表示可以被其他应用调用。 - false：表示不可以被其他应用调用，包括无法被aa工具命令拉起应用。 | 布尔值 | 该标签可缺省，缺省值为false。 |
| extensionProcessMode |  标识当前ExtensionAbility组件的多进程实例模型,当前只对UIExtensionAbility以及从UIExtensionAbility扩展的ExtensionAbility生效。 - instance：表示该ExtensionAbility每个实例一个进程。 - type：表示该ExtensionAbility实例都运行在同一个进程里，与其他ExtensionAbility分离进程。 - bundle：表示该ExtensionAbility实例都运行在应用统一进程里，与其他配置了bundle模型的ExtensionAbility共进程。 - runWithMainProcess：表示该ExtensionAbility和应用主进程共进程，只有一步直达的ExtensionAbility可以配置runWithMainProcess。 | 字符串 | 该标签可缺省，缺省值为空。 |
| dataGroupIds | 标识当前ExtensionAbility组件的dataGroupId集合。如果当前ExtensionAbility组件所在的应用在应用市场申请的证书里groupIds也申请了某个dataGroupId，那么当前ExtensionAbility组件可以和应用共享这一个dataGroupId生成的目录，所以ExtensionAbility组件的dataGroupId需要是应用的证书中groupIds字段里配置的才能生效。 且该字段仅在当前ExtensionAbility组件存在独立的沙箱目录时生效。详见dataGroupId申请流程。 | 字符串数组 | 该标签可缺省，缺省值为空。 |
| process |  标识组件的进程标签，只有type为embeddedUI时可以配置该字段。 说明： 仅在2in1设备上生效，UIAbility组件和ExtensionAbility组件标签一致时运行在同一个进程中。 | 字符串 | 该标签可缺省，缺省值为空。 |
标识当前ExtensionAbility组件的类型，支持的取值如下：
- form：卡片的ExtensionAbility。
- workScheduler：延时任务的ExtensionAbility。
- inputMethod：输入法的ExtensionAbility。
- accessibility：辅助能力的ExtensionAbility。
- wallpaper：壁纸的ExtensionAbility。
- backup：数据备份的ExtensionAbility。
- thumbnail：获取文件缩略图的ExtensionAbility，开发者可以对自定义文件类型的文件提供缩略。
- preview：该ExtensionAbility会将文件解析后在一个窗口中显示，开发者可以通过将此窗口组合到其他应用窗口中。
- print：打印框架的ExtensionAbility。
- push：推送的ExtensionAbility。
- driver：驱动框架的ExtensionAbility。
- remoteNotification：远程通知的ExtensionAbility。
- remoteLocation：远程定位的ExtensionAbility。
- voip：网络音视频通话的ExtensionAbility。
- action：自定义操作业务模板的ExtensionAbility，为开发者提供基于UIExtension的自定义操作业务模板。
- embeddedUI：嵌入式UI扩展能力，提供跨进程界面嵌入的能力。
- insightIntentUI：为开发者提供能被小艺意图调用，以窗口形态呈现内容的扩展能力。
- ads：广告业务的ExtensionAbility，与AdComponent控件组合使用，将广告页面展示到其他应用中。仅支持设备厂商使用。
- photoEditor：图片编辑业务的ExtensionAbility，为开发者提供基于UIExtension的图片编辑业务模版。
- appAccountAuthorization：应用账号授权扩展能力的ExtensionAbility，用于处理账号授权请求，比如账号登录授权。
- autoFill/password：用于账号和密码自动填充业务的ExtensionAbility，支持数据的保存、填充能力。
- hms/account：应用账号管理能力的ExtensionAbility。
- autoFill/smart：用于情景化场景自动填充业务的ExtensionAbility，支持数据的保存、填充能力。
- statusBarView：一步直达的ExtensionAbility。
- recentPhoto：最近照片推荐的ExtensionAbility。
- fence：地理围栏的ExtensionAbility。
- callerInfoQuery：企业联系人查询的ExtensionAbility。
标识当前ExtensionAbility组件自定义的权限信息。当其他应用访问该ExtensionAbility时，需要申请相应的权限信息。
一个数组元素为一个权限名称。通常采用反向域名格式（最大255字节），取值为系统预定义的权限。
标识当前ExtensionAbility组件提供的数据URI，取值为长度不超过255字节的字符数组，用反向域名的格式表示。
说明：
该标签在type为dataShare类型的ExtensionAbility时，不可缺省。
标识当前ExtensionAbility组件能够接收的Want的特征集。
配置规则：entry包可以配置多个具有入口能力的skills标签（配置了action.system.home和entity.system.home）的ExtensionAbility，其中第一个配置了skills标签的ExtensionAbility中的label和icon作为服务或应用的label和icon。
说明：
服务的Feature包不能配置具有入口能力的skills标签。
应用的Feature包可以配置具有入口能力的skills标签。
标识当前ExtensionAbility组件的元信息。
说明：
该标签在type为form时，不可缺省，且必须存在一个name为ohos.extension.form的对象值，其对应的resource值不能缺省，为卡片的二级资源引用。
标识当前ExtensionAbility组件是否可以被其他应用调用。
- true：表示可以被其他应用调用。
- false：表示不可以被其他应用调用，包括无法被aa工具命令拉起应用。
标识当前ExtensionAbility组件的多进程实例模型,当前只对UIExtensionAbility以及从UIExtensionAbility扩展的ExtensionAbility生效。
- instance：表示该ExtensionAbility每个实例一个进程。
- type：表示该ExtensionAbility实例都运行在同一个进程里，与其他ExtensionAbility分离进程。
- bundle：表示该ExtensionAbility实例都运行在应用统一进程里，与其他配置了bundle模型的ExtensionAbility共进程。
- runWithMainProcess：表示该ExtensionAbility和应用主进程共进程，只有一步直达的ExtensionAbility可以配置runWithMainProcess。
标识组件的进程标签，只有type为embeddedUI时可以配置该字段。
说明：
仅在2in1设备上生效，UIAbility组件和ExtensionAbility组件标签一致时运行在同一个进程中。
extensionAbilities示例：
```json
{
"extensionAbilities": [
{
"name": "FormName",
"srcEntry": "./form/MyForm.ts",
"icon": "$media:icon",
"label" : "$string:extension_name",
"description": "$string:form_description",
"type": "form",
"permissions": ["ohos.abilitydemo.permission.PROVIDER"],
"readPermission": "",
"writePermission": "",
"exported": true,
"uri":"scheme://authority/path/query",
"skills": [{
"actions": [],
"entities": [],
"uris": [],
"permissions": []
}],
"metadata": [
{
"name": "ohos.extension.form",
"resource": "$profile:form_config",
}
],
"extensionProcessMode": "instance",
"dataGroupIds": [
"testGroupId1"
]
}
]
}
```
shortcuts标签
shortcuts标识应用的快捷方式信息。标签值为数组，包含四个子标签shortcutId、label、icon、wants。
metadata中指定shortcut信息，其中：
- name：指定shortcuts的名称，使用ohos.ability.shortcuts作为shortcuts信息的标识。
- resource：指定shortcuts信息的资源位置。
表11shortcuts标签说明
| 属性名称 | 含义 | 类型 | 是否可缺省 |
| --- | --- | --- | --- |
| shortcutId | 标识快捷方式的ID，取值为长度不超过63字节的字符串。不推荐通过资源索引的方式（$string）配置该字段。 | 字符串 | 该标签不可缺省。 |
| label | 标识快捷方式的标签信息，即快捷方式对外显示的文字描述信息。取值为长度不超过255字节的字符串，可以是描述性内容，也可以是标识label的资源索引。 | 字符串 | 该标签可缺省，缺省值为空。 |
| icon | 标识快捷方式的图标，取值为资源文件的索引。 | 字符串 | 该标签可缺省，缺省值为空。 |
| wants | 标识快捷方式内定义的目标wants信息集合，在调用launcherBundleManager的startShortcut接口时，会拉起wants标签里的第一个目标组件，推荐只配置一个wants元素。 | 对象 | 该标签可缺省，缺省为空。 |
1.  在/resources/base/profile/目录下配置shortcuts_config.json配置文件。
```json
{
"shortcuts": [
{
"shortcutId": "id_test1",
"label": "$string:shortcut",
"icon": "$media:aa_icon",
"wants": [
{
"bundleName": "com.ohos.hello",
"moduleName": "entry",
"abilityName": "EntryAbility",
"parameters": {
"testKey": "testValue"
}
}
]
}
]
}
```
2.  在module.json5配置文件的abilities标签中，针对需要添加快捷方式的UIAbility进行配置metadata标签，使shortcut配置文件对该UIAbility生效。
```json
{
"module": {
// ...
"abilities": [
{
"name": "EntryAbility",
"srcEntry": "./ets/entryability/EntryAbility.ets",
// ...
"skills": [
{
"entities": [
"entity.system.home"
],
"actions": [
"action.system.home"
]
}
],
"metadata": [
{
"name": "ohos.ability.shortcuts",
"resource": "$profile:shortcuts_config"
}
]
}
]
}
}
```
wants标签
此标签用于标识快捷方式内定义的目标wants信息集合。
表11-1wants标签说明
| 属性名称 | 含义 | 类型 | 是否可缺省 |
| --- | --- | --- | --- |
| bundleName | 表示快捷方式的目标包名。 | 字符串 | 该标签不可缺省。 |
| moduleName | 表示快捷方式的目标模块名。 | 字符串 | 该标签可缺省。 |
| abilityName | 表示快捷方式的目标组件名。 | 字符串 | 该标签不可缺省。 |
| parameters | 表示拉起快捷方式时的自定义数据，仅支持配置字符串类型的数据。其中键值均最大支持1024长度的字符串。 | 对象 | 该标签可缺省。 |
data标签示例：
```json
{
"wants": [
{
"bundleName": "com.ohos.hello",
"moduleName": "entry",
"abilityName": "EntryAbility",
"parameters": {
"testKey": "testValue"
}
}
]
}
```
distributionFilter标签
该标签用于定义HAP对应的细分设备规格的分发策略，以便在应用市场进行云端分发应用包时做精准匹配。
该标签从API10及以后版本开始生效，API9及以前版本使用distroFilter标签。
- 适用场景：当一个工程中存在多个Entry，且多个Entry配置的deviceTypes存在交集时，则需要通过该标签进行区分。比如下面的两个Entry都支持tablet类型，就需要通过该标签进行区分。
// entry1支持的设备类型{"module":{"name":"entry1","type":"entry","deviceTypes":["tv","tablet"]}}
// entry2支持的设备类型{"module":{"name":"entry2","type":"entry","deviceTypes":["car","tablet"]}}
- // entry1支持的设备类型
- {
- "module":{
- "name":"entry1",
- "type":"entry",
- "deviceTypes":[
- "tv",
- "tablet"
- ]
- }
- }
- // entry2支持的设备类型
- {
- "module":{
- "name":"entry2",
- "type":"entry",
- "deviceTypes":[
- "car",
- "tablet"
- ]
- }
- }
- 配置规则：该标签支持配置四个属性，包括屏幕形状(screenShape)、窗口分辨率(screenWindow)、屏幕像素密度(screenDensity)、设备所在国家与地区(countryCode)，详见下表。在分发应用包时，通过deviceTypes与这四个属性的匹配关系，唯一确定一个用于分发到设备的HAP。如果需要配置该标签，则至少包含一个属性。如果一个Entry中配置了任意一个或多个属性，则其他Entry也必须包含相同的属性。screenShape和screenWindow属性仅用于轻量级智能穿戴设备。
- 如果需要配置该标签，则至少包含一个属性。
- 如果一个Entry中配置了任意一个或多个属性，则其他Entry也必须包含相同的属性。
- screenShape和screenWindow属性仅用于轻量级智能穿戴设备。
- 配置方式：该标签需要配置在/resources/base/profile资源目录下，并在metadata的resource字段中引用。
- 如果需要配置该标签，则至少包含一个属性。
- 如果一个Entry中配置了任意一个或多个属性，则其他Entry也必须包含相同的属性。
- screenShape和screenWindow属性仅用于轻量级智能穿戴设备。
表12distributionFilter标签配置说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| screenShape | 标识屏幕形状的支持策略。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| screenWindow | 标识应用运行时的窗口分辨率的支持策略。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| screenDensity | 标识屏幕的像素密度（dpi：Dot Per Inch）的支持策略。 | 对象数组 | 该标签可缺省，缺省值为空。 |
| countryCode | 标识国家与地区的支持策略，取值参考ISO-3166-1标准。支持多个国家和地区枚举定义。 | 对象数组 | 该标签可缺省，缺省值为空。 |
screenShape标签
表13screenShape标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| policy |  标识条件属性的过滤规则。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。 | 字符串 | 该标签不可缺省。 |
| value | 支持的取值为circle（圆形）、rect（矩形）。例如，针对智能穿戴设备，可为圆形表盘和矩形表盘分别提供不同的HAP。 | 字符串数组 | 该标签不可缺省。 |
标识条件属性的过滤规则。
- exclude：表示需要排除的value属性。
- include：表示需要包含的value属性。
screenWindow标签
表14screenWindow标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| policy |  标识条件属性的过滤规则。当前取值仅支持“include”。 - include：表示需要包含的value属性。 | 字符串 | 该标签不可缺省。 |
| value | 单个字符串的取值格式为“宽 * 高”，取值为整数像素值，例如“454 * 454”。 | 字符串数组 | 该标签不可缺省。 |
标识条件属性的过滤规则。当前取值仅支持“include”。
- include：表示需要包含的value属性。
screenDensity标签
表15screenDensity标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| policy |  标识条件属性的过滤规则。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。 | 字符串 | 该标签不可缺省。 |
| value |  标识屏幕的像素密度（dpi :Dot Per Inch）。支持的取值如下： - sdpi：表示小规模的屏幕密度（Small-scale Dots per Inch），适用于dpi取值为(0,120]的设备。 - mdpi：表示中规模的屏幕密度（Medium-scale Dots Per Inch），适用于dpi取值为(120,160]的设备。 - ldpi：表示大规模的屏幕密度（Large-scale Dots Per Inch），适用于dpi取值为(160,240]的设备。 - xldpi：表示大规模的屏幕密度（Extra Large-scale Dots Per Inch），适用于dpi取值为(240,320]的设备。 - xxldpi：表示大规模的屏幕密度（Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(320，480]的设备。 - xxxldpi：表示大规模的屏幕密度（Extra Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(480, 640]的设备。 | 字符串数组 | 该标签不可缺省。 |
标识条件属性的过滤规则。
- exclude：表示需要排除的value属性。
- include：表示需要包含的value属性。
标识屏幕的像素密度（dpi :Dot Per Inch）。支持的取值如下：
- sdpi：表示小规模的屏幕密度（Small-scale Dots per Inch），适用于dpi取值为(0,120]的设备。
- mdpi：表示中规模的屏幕密度（Medium-scale Dots Per Inch），适用于dpi取值为(120,160]的设备。
- ldpi：表示大规模的屏幕密度（Large-scale Dots Per Inch），适用于dpi取值为(160,240]的设备。
- xldpi：表示大规模的屏幕密度（Extra Large-scale Dots Per Inch），适用于dpi取值为(240,320]的设备。
- xxldpi：表示大规模的屏幕密度（Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(320，480]的设备。
- xxxldpi：表示大规模的屏幕密度（Extra Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(480, 640]的设备。
countryCode标签
表16countryCode标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| policy |  标识条件属性的过滤规则。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。 | 字符串 | 该标签不可缺省。 |
| value | 标识应用需要分发的国家地区码。 | 字符串数组 | 该标签不可缺省。 |
标识条件属性的过滤规则。
- exclude：表示需要排除的value属性。
- include：表示需要包含的value属性。
示例如下：
1.  在开发视图的resources/base/profile下面定义配置文件distributionFilter_config.json，文件名可以自定义。
```json
{
"distributionFilter": {
"screenShape": {
"policy": "include",
"value": [
"circle",
"rect"
]
},
"screenWindow": {
"policy": "include",
"value": [
"454*454",
"466*466"
]
},
"screenDensity": {
"policy": "exclude",
"value": [
"ldpi",
"xldpi"
]
},
"countryCode": { // 支持在中国分发
"policy": "include",
"value": [
"CN"
]
}
}
}
```
2.  在module.json5配置文件的module标签中定义metadata信息。
```json
{
"module": {
// ...
"metadata": [
{
"name": "ohos.module.distribution",
"resource": "$profile:distributionFilter_config",
}
]
}
}
```
testRunner标签
此标签用于支持对测试框架的配置。
表17testRunner标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识测试框架对象名称，取值为长度不超过255字节的字符串。 | 字符串 | 不可缺省。 |
| srcPath | 标识测试框架代码路径，取值为长度不超过255字节的字符串。 | 字符串 | 不可缺省。 |
testRunner标签示例：
```json
{
"module": {
// ...
"testRunner": {
"name": "myTestRunnerName",
"srcPath": "etc/test/TestRunner.ts"
}
}
}
```
atomicService标签
此标签用于支持对元服务的配置。此标签仅在app.json中bundleType指定为atomicService时使能。
表18atomicService标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| preloads | 标识元服务中预加载列表。 | 对象数组 | 该标签可缺省，缺省值为空。 |
表19preloads标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| moduleName | 标识元服务中当前模块被加载时，需预加载的模块名。不能配置自身modulename，且必须有对应的模块，取值为长度不超过31字节的字符串。 | 字符串 | 该标签不可缺省。 |
atomicService标签示例：
```json
{
"module": {
"atomicService": {
"preloads":[
{
"moduleName":"feature"
}
]
}
}
}
```
dependencies标签
此标签标识模块运行时依赖的共享库列表。
表20dependencies标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| bundleName | 标识当前模块依赖的共享包包名。取值为长度7~128字节的字符串。 | 字符串 | 该标签可缺省，缺省值为空。 |
| moduleName | 标识当前模块依赖的共享包模块名。取值为长度不超过31字节的字符串。 | 字符串 | 该标签不可缺省。 |
| versionCode | 标识当前共享包的版本号。取值范围为0~2147483647。 | 数值 | 该标签可缺省，缺省值为空。 |
dependencies标签示例：
```json
{
"module": {
"dependencies": [
{
"bundleName":"com.share.library",
"moduleName": "library",
"versionCode": 10001
}
]
}
}
```
proxyData标签
此标签标识模块提供的数据代理列表，仅限entry和feature配置。
表21proxyData标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| uri | 标识用于访问该数据代理的URI，不同的数据代理配置的URI不可重复，且需要满足datashareproxy://当前应用包名/xxx的格式。取值为长度不超过255字节的字符串。 | 字符串 | 该标签不可缺省。 |
| requiredReadPermission | 标识从该数据代理中读取数据所需要的权限，若不配置，则其他应用无法使用该代理。非系统应用配置的权限的等级需为system_basic或system_core，系统应用配置的权限的等级没有限制。权限等级可以参考权限列表。取值为长度不超过255字节的字符串。 | 字符串 | 该标签可缺省，缺省值为空。 |
| requiredWritePermission | 标识向该数据代理中写入数据所需要的权限，若不配置，则其他应用无法使用该代理。非系统应用配置的权限的等级需为system_basic或system_core，系统应用配置的权限的等级没有限制。权限等级可以参考权限列表。取值为长度不超过255字节的字符串。 | 字符串 | 该标签可缺省，缺省值为空。 |
| metadata | 标识该数据代理的元信息，只支持配置name和resource字段。 | 对象 | 该标签可缺省，缺省值为空。 |
proxyData标签示例：
```json
{
"module": {
"proxyData": [
{
"uri":"datashareproxy://com.ohos.datashare/event/Meeting",
"requiredReadPermission": "ohos.permission.GET_BUNDLE_INFO",
"requiredWritePermission": "ohos.permission.GET_BUNDLE_INFO",
"metadata": {
"name": "datashare_metadata",
"resource": "$profile:datashare"
}
}
]
}
}
```
routerMap标签
此标签标识模块配置的路由表的路径。
routerMap配置文件描述模块的路由表信息，routerMap标签值为数组类型。
表22routerMap标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识跳转页面的名称。取值为长度不超过1023字节的字符串。 | 字符串 | 该标签不可缺省。 |
| pageSourceFile | 标识页面在模块内的路径。取值为长度不超过255字节的字符串。 | 字符串 | 该标签不可缺省。 |
| buildFunction | 标识被@Builder修饰的函数，该函数描述页面的UI。取值为长度不超过1023字节的字符串。 | 字符串 | 该标签不可缺省。 |
| data | 标识字符串类型的自定义数据。 每个自定义数据字符串取值不超过128字节。 | 对象 | 该标签可缺省，缺省值为空。 |
| customData | 标识任意类型的自定义数据，总长度不超过4096字节。 | 对象 | 该标签可缺省，缺省值为空。 |
示例如下：
1.  在开发视图的resources/base/profile下面定义配置文件，文件名可以自定义，例如：router_map.json。
```json
{
"routerMap": [
{
"name": "DynamicPage1",
"pageSourceFile": "src/main/ets/pages/pageOne.ets",
"buildFunction": "myFunction",
"customData": {
"stringKey": "data1",
"numberKey": 123,
"booleanKey": true,
"objectKey": {
"name": "test"
},
"arrayKey": [
{
"id": 123
}
]
}
},
{
"name": "DynamicPage2",
"pageSourceFile": "src/main/ets/pages/pageTwo.ets",
"buildFunction": "myBuilder",
"data": {
"key1": "data1",
"key2": "data2"
}
}
]
}
```
2.  在module.json5配置文件的module标签中定义routerMap字段，指向定义的路由表配置文件，例如："routerMap": "$profile:router_map"。
data标签
此标签用于支持在路由表中配置自定义的字符串数据。
data标签示例：
```json
{
"routerMap": [
{
"name": "DynamicPage",
"pageSourceFile": "src/main/ets/pages/pageOne.ets",
"buildFunction": "myBuilder",
"data": {
"key1": "data1",
"key2": "data2"
}
}
]
}
```
customData标签
此标签用于支持在路由表中配置自定义数据。
customData对象内部，可以填入任意类型的自定义数据。
customData标签示例：
```json
{
"routerMap": [
{
"name": "DynamicPage",
"pageSourceFile": "src/main/ets/pages/pageOne.ets",
"buildFunction": "myBuilder",
"customData": {
"stringKey": "data1",
"numberKey": 123,
"booleanKey": true,
"objectKey": {
"name": "test"
},
"arrayKey": [
{
"id": 123
}
]
}
}
]
}
```
appEnvironments标签
此标签标识模块配置的应用环境变量。
表23appEnvironments标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识环境变量的变量名称。取值为长度不超过4096字节的字符串。 | 字符串 | 该标签可缺省，缺省值为空。 |
| value | 标识环境变量的值。取值为长度不超过4096字节的字符串。 | 字符串 | 该标签可缺省，缺省值为空。 |
appEnvironments标签示例：
```json
{
"module": {
"appEnvironments": [
{
"name":"name1",
"value": "value1"
}
]
}
}
```
definePermissions标签
该标签仅支持系统资源hap定义权限，不支持应用自定义权限。权限定义方式参见系统资源权限定义。
表24definePermissions标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识权限的名称，该标签最大长度为255字节。 | 字符串 | 不可缺省。 |
| grantMode |  标识权限的授予方式，支持如下两种授予模式如下： - system_grant：安装后系统自动授予该权限。 - user_grant：使用时动态申请，用户授权后才可使用。 | 字符串 | 可缺省，缺省值为system_grant。 |
| availableLevel |  标识权限限制类别，可选值如下： - system_core：系统核心权限。 - system_basic：系统基础权限。 - normal：普通权限。所有应用允许申请的权限。 | 字符串 | 可缺省，缺省值为normal。 |
| provisionEnable | 标识权限是否支持证书方式申请权限，包括高级别的权限。配置为true标识开发者可以通过provision方式申请权限。 | 布尔值 | 可缺省，缺省值为true。 |
| distributedSceneEnabled | 标识权限是否支持分布式场景下使用该权限。 | 布尔值 | 可缺省，缺省值为false。 |
| label | 标识权限的简短描述，配置为对描述内容的资源索引。 | 字符串 | 可缺省，缺省值为空。 |
| description | 标识权限的详细描述，可以是字符串，或者是对描述内容的资源索引。 | 字符串 | 可缺省，缺省值为空。 |
标识权限的授予方式，支持如下两种授予模式如下：
- system_grant：安装后系统自动授予该权限。
- user_grant：使用时动态申请，用户授权后才可使用。
标识权限限制类别，可选值如下：
- system_core：系统核心权限。
- system_basic：系统基础权限。
- normal：普通权限。所有应用允许申请的权限。
definePermissions标签示例：
```json
{
"module" : {
"definePermissions": [
{
"name": "ohos.abilitydemo.permission.PROVIDER",
"grantMode": "system_grant",
"availableLevel": "system_core",
"provisionEnable": true,
"distributedSceneEnable": false,
"label": "$string:EntryAbility_label"
}
]
}
}
```
hnpPackages标签
该标签标识应用包含的Native软件包信息。
表25hnpPackages标签说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| package | 标识Native软件包名称。 | 字符串 | 该标签不可缺省。 |
| type |  标识Native软件包类型。支持的取值如下： - public：公有类型。 - private：私有类型。 | 字符串 | 该标签不可缺省。 |
标识Native软件包类型。支持的取值如下：
- public：公有类型。
- private：私有类型。
hnpPackages示例：
```json
{
"module" : {
"hnpPackages": [
{
"package": "hnpsample.hnp",
"type": "public"
}
]
}
}
```
fileContextMenu标签
该标签用来标识当前HAP的右键菜单配置项，是一个profile文件资源，用于指定描述应用注册右键菜单配置文件。仅在PC/2in1设备上生效。
fileContextMenu标签示例
```json
{
"module": {
// ...
"fileContextMenu": "$profile:menu" // 通过profile下的资源文件配置
}
}
```
在开发视图的resources/base/profile下面定义配置文件menu.json，其中文件名“menu.json”可自定义，需要和fileContextMenu标签指定的信息对应。配置文件中描述了当前应用注册的右键菜单的项目和响应行为。
配置文件根节点名称为fileContextMenu，为对象数组，标识当前module注册右键菜单的数量。（单模块和单应用注册数量不能超过5个，配置超过数量当前只解析随机5个）
表26fileContextMenu标签配置说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| abilityName | 表示当前右键菜单对应的需要拉起的ability名称。 | 字符串 | 不可缺省 |
| menuItem |  右键菜单显示的信息。命名建议： 原则一：[动作]+[应用名]，中文示例：用{App}打开、用{App} ({Plugin}插件) 打开；英文示例：Open with {App}、Open with {App} ({Plugin})。 原则二：[动作]+[目的]，示例：压缩为{文件名}、压缩至{路径}、用{App}转换为{格式}。 | 资源id | 不可缺省 |
| menuHandler | 一个ability可以创建多个右键菜单， 用该字段来区分用户拉起的不同右键菜单项。该字段在用户点击右键菜单执行时，会作为参数传递给右键菜单应用。 | 字符串 | 不可缺省 |
| menuContext | 定义展示该菜单项需要的上下文，可以支持多种情况，类型为数组。 | 对象数组 | 不可缺省 |
右键菜单显示的信息。命名建议：
原则一：[动作]+[应用名]，中文示例：用{App}打开、用{App} ({Plugin}插件) 打开；英文示例：Open with {App}、Open with {App} ({Plugin})。
原则二：[动作]+[目的]，示例：压缩为{文件名}、压缩至{路径}、用{App}转换为{格式}。
表27menuContext标签配置说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| menuKind |  表示单击如下类型时会触发右键菜单。取值范围如下： - 0：空白处 - 1：文件 - 2：文件夹 - 3：文件和文件夹 | 数值 | 不可缺省 |
| menuRule |  表示采用什么方式选择文件或文件夹时，会触发右键菜单。取值范围如下： - single：单选 - multi：多选 - both：单选或多选 | 字符串 | 仅当menuKind为1或2时，才会读取该字段，此时不可缺省。 |
| fileSupportType |  表示当选中的文件列表里包含指定的文件类型时，显示右键菜单。 当该字段取值为["*"]时，将会读取fileNotSupportType字段。 当该字段取值为[]时，将不做任何处理。 | 字符串数组 | 仅当menuKind为1时，才会读取该字段，此时不可缺省。 |
| fileNotSupportType |  表示当选中的文件列表里包含这些文件类型时，不显示该右键菜单。 仅当menuKind为1、且fileSupportType为["*"]时，才会读取该字段。 | 字符串数组 | 可缺省，缺省值为空。 |
表示单击如下类型时会触发右键菜单。取值范围如下：
- 0：空白处
- 1：文件
- 2：文件夹
- 3：文件和文件夹
表示采用什么方式选择文件或文件夹时，会触发右键菜单。取值范围如下：
- single：单选
- multi：多选
- both：单选或多选
表示当选中的文件列表里包含指定的文件类型时，显示右键菜单。
当该字段取值为["*"]时，将会读取fileNotSupportType字段。
当该字段取值为[]时，将不做任何处理。
表示当选中的文件列表里包含这些文件类型时，不显示该右键菜单。
仅当menuKind为1、且fileSupportType为["*"]时，才会读取该字段。
resources/base/profile路径下的menu.json资源文件示例如下：
```json
{
"fileContextMenu": [
{
"abilityName": "EntryAbility",
"menuItem": "$string:module_desc",
"menuHandler": "openCompress",
"menuContext": [
{
"menuKind": 0
},
{
"menuKind": 1,
"menuRule": "both",
"fileSupportType": [
".rar",
".zip"
],
"fileNotSupportType": [
""
]
},
{
"menuKind": 2,
"menuRule": "single"
},
{
"menuKind": 3
}
]
}
]
}
```
响应行为
应用进行右键扩展菜单注册后，在文件管理器通过右键操作拉起菜单，该菜单中会有“更多”选项。点击“更多”选项后，会出现注册后的menuItem列表，点击任意一个选项后，文件管理器默认通过startAbility的方式拉起三方应用，除了指定三方应用的包名和ability名之外，want中的parameter中，也会传入如下字段：
表28want中parameter字段说明
| 参数名 | 值 | 类型 |
| --- | --- | --- |
| menuHandler | 对应注册配置文件中menuHandler的值。 | 字符串 |
| uriList | 用户在具体文件上触发右键的uri值，如果空白处响应，此值为空，单个文件响应，数组长度1，多个文件响应则传入对应所有文件的uri值。 | 字符串数组 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-configuration-file-fa
爬取时间: 2025-04-27 21:40:47
来源: Huawei Developer
- 应用配置文件概述（FA模型）
- app对象内部结构
- deviceConfig内部结构
- module对象内部结构

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-configuration-file-overview-fa
爬取时间: 2025-04-27 21:41:01
来源: Huawei Developer
每个应用项目必须在项目的代码目录下加入配置文件，这些配置文件会向编译工具、操作系统和应用市场提供描述应用的基本信息。
应用配置文件需申明以下内容：
- 应用的软件Bundle名称，应用的开发厂商，版本号等应用的基本配置信息，这些信息被要求设置在app这个字段下。
- 应用的组件的基本信息，包括所有的Ability，设备类型，组件的类型以及当前组件所使用的语法类型。
- 应用在具体设备上的配置信息，这些信息会影响应用在设备上的具体功能。
在FA模型的应用开发过程中，需要在config.json配置文件中对应用的包结构进行声明。
配置文件的内部结构
config.json由app、deviceConfig和module三个部分组成，缺一不可。
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| app | 标识应用的全局配置信息。同一个应用的不同HAP的app配置必须保持一致。 | 对象 | 不可缺省。 |
| deviceConfig | 标识应用在具体设备上的配置信息。 | 对象 | 不可缺省。 |
| module | 标识HAP的配置信息。该标签下的配置只对当前HAP生效。 | 对象 | 不可缺省。 |
config.json示例：
```json
{
"app": {
"vendor": "example",
"bundleName": "com.example.demo",
"version": {
"code": 1000000,
"name": "1.0.0"
}
},
"deviceConfig": {
},
"module": {
"mainAbility": ".MainAbility_entry",
"deviceType": [
"tablet"
],
"commonEvents": [
{
"name": ".EntryAbility",
"permission": "ohos.permission.GET_BUNDLE_INFO",
"data": [
"com.example.demo",
"100"
],
"events": [
"install",
"update"
]
}
],
"abilities": [
{
"skills": [
{
"entities": [
"entity.system.home"
],
"actions": [
"action.system.home"
]
}
],
"orientation": "unspecified",
"visible": true,
"srcPath": "MainAbility_entry",
"name": ".MainAbility_entry",
"srcLanguage": "ets",
"icon": "$media:icon",
// $string:MainAbility_entry_desc为资源索引
"description": "$string:MainAbility_entry_desc",
"formsEnabled": false,
// $string:MainAbility_entry_label为资源索引
"label": "$string:MainAbility_entry_label",
"type": "page",
"launchType": "multiton"
}
],
"distro": {
"moduleType": "entry",
"installationFree": false,
"deliveryWithInstall": true,
"moduleName": "myapplication"
},
"package": "com.example.myapplication",
"srcPath": "",
"name": ".myapplication",
"js": [
{
"mode": {
"syntax": "ets",
"type": "pageAbility"
},
"pages": [
"pages/index"
],
"name": ".MainAbility_entry",
"window": {
"designWidth": 720,
"autoDesignWidth": false
}
}
]
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-structure
爬取时间: 2025-04-27 21:41:15
来源: Huawei Developer
app对象包含应用全局配置信息，内部结构如下：
表1app对象内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| bundleName | 标识应用的Bundle名称，用于标识应用的唯一性。Bundle名称是由字母、数字、下划线（_）和点号（.）组成的字符串，必须以字母开头。支持的字符串长度为7~128字节。Bundle名称通常采用反向域名形式表示（例如，"com.example.myapplication"）。建议第一级为域名后缀"com"，第二级为厂商/个人名，也可以采用多级。 | 字符串 | 不可缺省。 |
| vendor | 标识对应用开发厂商的描述。字符串长度不超过255字节。 | 字符串 | 可缺省，缺省值为空。 |
| version | 标识应用的版本信息。 | 对象 | 不可缺省。 |
| apiVersion | 标识应用程序所依赖的操作系统 API版本。 | 对象 | 可缺省，缺省值为空。 |
| smartWindowSize | 标识应用在模拟器中运行时使用的屏幕尺寸。 | 字符串 | 可缺省，缺省值为空。 |
| smartWindowDeviceType | 标识应用在模拟器中运行时可以模拟的设备。 | 字符串数组 | 可缺省，缺省值为空。 |
| asanEnabled | 标识应用程序是否开启asan检测，用于辅助定位buffer越界造成的crash问题。 - true：当前工程开启asan检测。 - false：当前工程不开启asan检测。  | 布尔值 | 可缺省，缺省值false。 |
标识应用程序是否开启asan检测，用于辅助定位buffer越界造成的crash问题。
- true：当前工程开启asan检测。
- false：当前工程不开启asan检测。
version对象内部结构
表2version对象内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识应用的版本号，用于向应用的终端用户呈现。取值可以自定义，长度不超过127字节。自定义规则如下：API5及更早的版本：推荐使用三段数字版本号（也兼容两段式版本号），如A.B.C（也兼容A.B），其中A、B、C取值为0-999范围内的整数。除此之外不支持其他格式。 A段，一般表示主版本号（Major）。 B段，一般表示次版本号（Minor）。 C段，一般表示修订版本号（Patch）。API6版本起：推荐采用四段式数字版本号，如A.B.C.D，其中A、B、C取值为0-99范围内的整数，D的取值为0-999范围内的整数。 A段，一般表示主版本号（Major）。 B段，一般表示次版本号（Minor）。 C段，一般表示特性版本号（Feature）。 D段，一般表示修订版本号（Patch）。  | 数值 | 不可缺省。 |
| code | 标识应用的版本号，仅用于操作系统管理该应用，不对应用的终端用户呈现。取值规则如下：API5及更早版本：二进制32位以内的非负整数，需要从version.name的值转换得到。转换规则为：code值=A * 1,000,000 + B * 1,000 + C例如，version.name字段取值为2.2.1，则code值为2002001。API6版本起：code的取值不与version.name字段的取值关联，开发者可自定义code取值，取值范围为2^31以内的非负整数，但是每次应用版本的更新，均需要更新code字段的值，新版本code取值必须大于旧版本code的值。 | 数值 | 不可缺省。 |
| minCompatibleVersionCode | 标识应用可兼容的最低版本号，用于跨设备场景下，判断其他设备上该应用的版本是否兼容。格式与version.code字段的格式要求相同。 | 数值 | 可缺省，缺省值为code标签值。 |
标识应用的版本号，用于向应用的终端用户呈现。取值可以自定义，长度不超过127字节。自定义规则如下：API5及更早的版本：推荐使用三段数字版本号（也兼容两段式版本号），如A.B.C（也兼容A.B），其中A、B、C取值为0-999范围内的整数。除此之外不支持其他格式。
A段，一般表示主版本号（Major）。
B段，一般表示次版本号（Minor）。
C段，一般表示修订版本号（Patch）。API6版本起：推荐采用四段式数字版本号，如A.B.C.D，其中A、B、C取值为0-99范围内的整数，D的取值为0-999范围内的整数。
A段，一般表示主版本号（Major）。
B段，一般表示次版本号（Minor）。
C段，一般表示特性版本号（Feature）。
D段，一般表示修订版本号（Patch）。
apiVersion内部结构
表3apiVersion内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| compatible | 运行应用所需要的最低API版本，取值范围为0~2147483647。 | 数值 | 配置在build.profile中，打包时由DevEco Studio填充到config.json中。 |
| target | 用于标识应用运行时使用的API版本，取值范围为0~2147483647。 | 数值 | 配置在build.profile中，打包时由DevEco Studio填充到config.json中。 |
| releaseType | 用于标识应用运行时SDK的状态。 canary：面向特定开发者早期预览版本，不承诺质量，不承诺API稳定。 beta：公开发布的Beta版本，早期Beta版本不承诺API稳定，经历若干次发布后，通过Release Notes对开发者声明该Beta版本为API稳定里程碑，后续版本的API冻结。 release：正式发布版本，承诺质量，API不可变更。当版本处于此状态时版本号中不呈现Stage字段。  | 字符串 | 配置在build.profile中，打包时由DevEco Studio填充到config.json中。 |
用于标识应用运行时SDK的状态。
canary：面向特定开发者早期预览版本，不承诺质量，不承诺API稳定。
beta：公开发布的Beta版本，早期Beta版本不承诺API稳定，经历若干次发布后，通过Release Notes对开发者声明该Beta版本为API稳定里程碑，后续版本的API冻结。
release：正式发布版本，承诺质量，API不可变更。当版本处于此状态时版本号中不呈现Stage字段。
app对象示例
```json
"app": {
"bundleName": "com.example.myapplication",
"vendor": "example",
"version": {
"code": 8,
"name": "8.0.1"
},
"apiVersion": {
"compatible": 8,
"target": 9,
"releaseType": "Beta1"
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/deviceconfig-structure
爬取时间: 2025-04-27 21:41:29
来源: Huawei Developer
deviceConfig包含设备上的应用配置信息，可以包含default、tv、car、wearable等属性。default标签内的配置适用于所有通用设备，其他设备类型如果有特殊的需求，则需要在该设备类型的标签下进行配置。
deviceConfig对象内部结构
表1deviceConfig对象内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| default | 能够使用全部系统能力的设备。 | 对象 | 可缺省，缺省值为空。 |
| tablet | 标识平板的应用配置信息。 | 对象 | 可缺省，缺省值为空。 |
| tv | 标识智慧屏特有的应用配置信息。 | 对象 | 可缺省，缺省值为空。 |
| car | 标识车机特有的应用配置信息。 | 对象 | 可缺省，缺省值为空。 |
| wearable | 标识智能穿戴特有的应用配置信息。 | 对象 | 可缺省，缺省值为空。 |
上表中各类设备对象的内部结构说明参见deviceConfig设备对象内部结构。
deviceConfig设备对象内部结构
表2deviceConfig设备对象内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| process | 标识应用或者Ability的进程名。如果在deviceConfig标签下配置了process标签，则该应用的所有Ability都运行在这个进程中。如果在abilities标签下也为某个Ability配置了process标签，则该Ability就运行在这个进程中。该标签最大长度为31。 | 字符串 | 可缺省，缺省值为空。 |
| keepAlive | 标识应用是否始终保持运行状态，仅支持系统应用配置，三方应用配置不生效。该标签为布尔类型，可缺省，缺省值为false，如果配置为true，应用将始终保持为运行状态，并在系统启动的时候被系统驱动起来，应用进程退出后，系统也会重新启动应用进程。 | 布尔值 | 可缺省，缺省值为false。 |
| supportBackup | 标识应用是否支持备份和恢复。如果配置为"false"，则不支持为该应用执行备份或恢复操作。 | 布尔值 | 可缺省，缺省值为false。 |
| compressNativeLibs | 标识libs库是否以压缩存储的方式打包到HAP。如果配置为"false"，则libs库以不压缩的方式存储。 | 布尔值 | 可缺省，缺省值为false。 |
| network | 标识网络安全性配置。该标签允许应用通过配置文件的安全声明来自定义其网络安全，无需修改应用代码。 | 对象 | 可缺省，缺省值为空。 |
network对象的内部结构
表3network对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| cleartextTraffic | 标识是否允许应用使用明文网络流量（例如，明文HTTP）。 - true：允许应用使用明文流量的请求。 - false：拒绝应用使用明文流量的请求。  | 布尔值 | 可缺省，缺省值为false。 |
| securityConfig | 标识应用的网络安全配置信息。 | 对象 | 可缺省，缺省为空。 |
标识是否允许应用使用明文网络流量（例如，明文HTTP）。
- true：允许应用使用明文流量的请求。
- false：拒绝应用使用明文流量的请求。
securityConfig对象的内部结构
表4securityConfig对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| domainSettings | 标识自定义的网域范围的安全配置，支持多层嵌套，即一个domainSettings对象中允许嵌套更小网域范围的domainSettings对象。 | 对象类型 | 可缺省，缺省为空。 |
domainSettings对象内部结构
表5domainSettings对象内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| cleartextPermitted | 标识自定义的网域范围内是否允许明文流量传输。当cleartextTraffic和security同时存在时，自定义网域是否允许明文流量传输以cleartextPermitted的取值为准。 - true：允许明文流量传输。 - false：拒绝明文流量传输。  | 布尔类型 | 可缺省，缺省值为空。 |
| domains | 标识域名配置信息，包含两个参数：subdomains和name。 - subdomains：表示是否包含子域名，为布尔类型。取值为"true"时，表示该规则将与相应网域及所有子网域（包括子网域的子网域）匹配；取值为"false"时，表示该规则仅适用于精确匹配项。 - name：表示域名名称，为字符串类型。  | 对象数组 | 可缺省，缺省值为空。 |
标识自定义的网域范围内是否允许明文流量传输。当cleartextTraffic和security同时存在时，自定义网域是否允许明文流量传输以cleartextPermitted的取值为准。
- true：允许明文流量传输。
- false：拒绝明文流量传输。
标识域名配置信息，包含两个参数：subdomains和name。
- subdomains：表示是否包含子域名，为布尔类型。取值为"true"时，表示该规则将与相应网域及所有子网域（包括子网域的子网域）匹配；取值为"false"时，表示该规则仅适用于精确匹配项。
- name：表示域名名称，为字符串类型。
deviceConfig示例
```json
"deviceConfig": {
"default": {
"process": "com.example.test.example",
"supportBackup": false,
"network": {
"cleartextTraffic": true,
"securityConfig": {
"domainSettings": {
"cleartextPermitted": true,
"domains": [
{
"subdomains": true,
"name": "example.ohos.com"
}
]
}
}
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-structure
爬取时间: 2025-04-27 21:41:43
来源: Huawei Developer
module对象包含HAP的配置信息。
表1module对象内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| mainAbility | 服务中心图标露出的Ability，常驻进程拉起时会启动mainAbility。 | 字符串 | 可缺省，缺省值为空。 |
| package | 标识HAP的包结构名称，在应用内保证唯一性。采用反向域名格式（建议与HAP的工程目录保持一致）。字符串长度为1-127个字节。 | 字符串 | 不可缺省。 |
| name | 标识HAP的类名。采用反向域名方式标识，前缀要与同级的package标签指定的包名一致，也可采用"."开头的命名方式。字符串长度不超过255字节。 | 字符串 | 可缺省，缺省值为空。 |
| description | 标识HAP的描述信息。字符串长度不超过255字节。如果字符串超出长度或者需要支持多语言，可以采用资源索引的方式添加描述内容。 | 字符串 | 可缺省，缺省值为空。 |
| supportedModes | 标识应用支持的运行模式，当前只定义了驾驶模式（drive）。该标签只适用于车机。 | 字符串数组 | 可缺省，缺省值为空。 |
| deviceType | 标识允许Ability运行的设备类型。系统预定义的设备类型包括：tablet(平板)、tv（智慧屏）、car(车机)、wearable(智能穿戴)、litewearable(运动表)等。 | 字符串数组 | 不可缺省。 |
| distro | 标识HAP发布的具体描述。 | 对象 | 不可缺省。 |
| metaData | 标识HAP的元信息。 | 对象 | 可缺省，缺省值为空。 |
| abilities | 标识当前模块内的所有Ability。采用对象数据格式。 | 对象数组 | 可缺省，缺省值为空。 |
| js | 标识基于ArkUI框架开发的JS模块集合，其中的每个元素代表一个JS模块的信息。 | 对象数组 | 可缺省，缺省值为空。 |
| shortcuts | 标识应用的快捷方式信息。采用对象数组格式，其中的每个元素表示一个快捷方式对象。 | 对象数组 | 可缺省，缺省值为空。 |
| reqPermissions | 标识应用运行时向系统申请的权限。 | 对象数组 | 可缺省，缺省值为空。 |
| colorMode |  标识应用自身的颜色模式，目前支持如下三种模式： - dark：表示按照深色模式选取资源。 - light：表示按照浅色模式选取资源。 - auto：表示跟随系统的颜色模式值选取资源。 | 字符串 | 可缺省，缺省值为"auto"。 |
| distroFilter | 该标签下的子标签均为可选字段，用于定义HAP对应的细分设备规格的分发策略，以便应用市场在云端分发HAP时做精准匹配。该标签需要配置在/resource/profile资源目录下；在进行分发时，通过deviceType与下表属性的匹配关系，唯一确定一个用于分发到设备的HAP。 | 对象 | 可缺省，缺省值为空。但当应用中包含多个entry模块时，必须配置该标签。 |
| commonEvents | 定义了公共事件静态订阅者的信息，该字段中需要声明静态订阅者的名称、权限要求及订阅事件列表信息，当订阅的公共事件发送时，该公共事件静态订阅者将被拉起。这里的静态订阅者区分于常用的动态订阅者，前者无需在业务代码中主动调用订阅事件的接口，在公共事件发布时可能未被拉起，而动态订阅者则在业务代码中主动调用公共事件订阅的相关API，因此需要应用处于活动状态。 | 对象数组 | 可缺省，缺省为空。 |
| entryTheme | 此标签标识系统内部主题的关键字。将标记值设置为名称的资源索引。 | 字符串 | 可缺省，缺省值为空。 |
| testRunner | 此标签用于支持对测试框架的配置。 | 对象 | 可缺省，缺省值为空。 |
| generateBuildHash | 标识当前HAP/HSP是否由打包工具生成哈希值。如果存在，则在系统OTA升级但应用的version下的code保持不变时，可根据哈希值判断应用是否需要升级。 注：该字段仅对预置应用生效。 | 布尔值 | 该标签可缺省, 缺省值为false。 |
| libIsolation |  用于区分同应用不同hap下的so文件，以防止so冲突。 - true：当前hap的so会储存在libs目录中以Module名命名的路径下。 - false：当前hap的so会直接储存在libs目录中。 | 布尔值 | 该标签可缺省, 缺省值为false。 |
标识应用自身的颜色模式，目前支持如下三种模式：
- dark：表示按照深色模式选取资源。
- light：表示按照浅色模式选取资源。
- auto：表示跟随系统的颜色模式值选取资源。
注：该字段仅对预置应用生效。
用于区分同应用不同hap下的so文件，以防止so冲突。
- true：当前hap的so会储存在libs目录中以Module名命名的路径下。
- false：当前hap的so会直接储存在libs目录中。
module示例：
```json
{
"module": {
"mainAbility": ".EntryAbility",
"deviceType": [
"default",
"tablet"
],
"abilities": [
{
"skills": [
{
"entities": [
"entity.system.home"
],
"actions": [
"action.system.home"
]
}
],
"orientation": "unspecified",
"visible": true,
"srcPath": "EntryAbility",
"name": ".EntryAbility",
"srcLanguage": "ets",
"icon": "$media:icon",
"description": "$string:MainAbility_desc",
"formsEnabled": false,
"label": "$string:MainAbility_label",
"type": "page",
"launchType": "multiton"
}
],
"distro": {
"moduleType": "entry",
"installationFree": false,
"deliveryWithInstall": true,
"moduleName": "entry"
},
"package": "com.example.entry",
"srcPath": "",
"name": ".entry",
"js": [
{
"mode": {
"syntax": "ets",
"type": "pageAbility"
},
"pages": [
"pages/Index"
],
"name": ".EntryAbility",
"window": {
"designWidth": 720,
"autoDesignWidth": false
}
}
]
}
}
```
distro对象内部结构
表2distro对象内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| moduleName | 标识当前HAP的名称，最大长度为31个字节。 在应用升级时，该名称允许修改，但需要应用适配Module相关数据目录的迁移，可使用文件操作接口。 | 字符串 | 不可缺省。 |
| moduleType | 标识当前HAP的类型，包括三种类型：entry、feature和har。 | 字符串 | 不可缺省。 |
| installationFree | 标识当前HAP是否支持免安装特性。true：表示支持免安装特性，且符合免安装约束。false：表示不支持免安装特性。另外还需注意：当entry.hap该字段配置为true时，与该entry.hap相关的所有feature.hap该字段也需要配置为true。当entry.hap该字段配置为false时，与该entry.hap相关的各feature.hap该字段可按业务需求配置true或false。 | 布尔值 | 不可缺省。 |
| deliveryWithInstall | 标识当前HAP是否在用户主动安装HAP所在应用的时候一起安装。true： 安装应用时当前HAP随应用一起下载安装。false：安装应用时当前HAP并不下载安装，后续使用是按需下载。 | 布尔值 | 不可缺省。 |
distro示例：
```json
"distro": {
"moduleName": "ohos_entry",
"moduleType": "entry",
"installationFree": true,
"deliveryWithInstall": true
}
```
metadata对象内部结构
表3metadata对象内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| parameters | 标识调用Ability时所有调用参数的元信息。每个调用参数的元信息由以下三个标签组成：description、name、type。 | 对象数组 | 可缺省，缺省值为空。 |
| results | 标识Ability返回值的元信息。每个返回值的元信息由以下三个标签组成：description、name、type。 | 对象数组 | 可缺省，缺省值为空。 |
| customizeData | 该标签标识父级组件的自定义元信息，Parameters和results在application不可配。 | 对象数组 | 可缺省，缺省值为空。 |
parameters对象内部结构
表4parameters对象内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| description | 标识对调用参数的描述，可以是表示描述内容的字符串，也可以是对描述内容的资源索引以支持多语言。该标签最大长度为255个字节。 | 字符串 | 可缺省，缺省值为空。 |
| name | 标识调用参数的名称。该标签最大长度为255个字节。 | 字符串 | 不可缺省。 |
| type | 标识调用参数的类型，如Integer。 | 字符串 | 不可缺省。 |
results对象内部结构
表5results对象内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| description | 标识对返回值的描述，可以是表示描述内容的字符串，也可以是对描述内容的资源索引以支持多语言。该标签最大长度为255个字节。 | 字符串 | 可缺省，缺省值为空。 |
| name | 标识返回值的名字。该标签最大长度为255个字节。 | 字符串 | 可缺省，缺省值为空。 |
| type | 标识返回值的类型，如Integer。 | 字符串 | 不可缺省。 |
customizeData对象的内部结构
表6customizeData对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识数据项的键名称，字符串类型（最大长度255字节）。 | 字符串 | 可缺省，缺省值为空。 |
| value | 标识数据项的值名称，字符串类型（最大长度255字节）。 | 字符串 | 可缺省，缺省值为空。 |
| extra | 标识用户自定义数据格式，标签值为标识该数据的资源的索引值。 | 字符串 | 可缺省，缺省值为空。 |
metadata对象示例：
```json
"metaData": {
"parameters" : [{
"name" : "a test for metadata parameter",
"type" : "Float",
// "$string:parameters_description"为文件资源索引值
"description" : "$string:parameters_description"
}],
"results" : [{
"name" : "a test for metadata result",
"type" : "Float",
"description" : "$string:results_description"
}],
"customizeData" : [{
"name" : "a customizeData",
"value" : "string",
"extra" : "$string:customizeData_description"
}]
}
```
deviceType标签
表7deviceType标签配置说明
| 设备类型 | 枚举值 | 说明 |
| --- | --- | --- |
| 平板 | tablet | - |
| 智慧屏 | tv | - |
| 智能手表 | wearable | 系统能力较丰富的手表，具备电话功能。 |
| 运动表 | litewearable | - |
| 车机 | car | - |
| 默认设备 | default | 能够使用全部系统能力的设备。 |
abilities对象的内部结构
表8abilities对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| process | 运行应用程序或Ability的进程名称。如果在deviceConfig标记中配置了进程，则应用程序的所有能力都在此进程中运行。您还可以为特定能力设置流程属性，以便该能力可以在此流程中运行。如果此属性设置为与其他应用程序相同的进程名称，则所有这些应用程序可以在同一进程中运行，前提是他们具有相同的联合用户ID和相同的签名。该标签最大字节数为31个字节。 | 字符串 | 可缺省，缺省值为空。 |
| name |  标识Ability名称。取值可采用反向域名方式表示，由包名和类名组成，如"com.example.myapplication.EntryAbility"；也可采用"."开头的类名方式表示，如".EntryAbility"。 Ability的名称，需在一个应用的范围内保证唯一。说明：在使用DevEco Studio新建项目时，默认生成首个Ability的配置，即"config.json"中"EntryAbility"的配置。如使用其他IDE工具，可自定义名称。该标签最大长度为127个字节。 | 字符串 | 不可缺省。 |
| description | 标识对Ability的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。该标签最大长度为255个字节。 | 字符串 | 可缺省，缺省值为空。 |
| icon |  标识Ability图标资源文件的索引。取值示例：$media:ability_icon。如果在该Ability的skills属性中，actions的取值包含 "action.system.home"，entities取值中包含"entity.system.home"，则该Ability的icon将同时作为应用的icon。如果存在多个符合条件的Ability，则取位置靠前的Ability的icon作为应用的icon。 说明：应用的"icon"和"label"是用户可感知配置项，需要区别于当前所有已有的应用"icon"或"label"（至少有一个不同）。 | 字符串 | 可缺省，缺省值为空。 |
| label |  标识Ability对用户显示的名称。取值是对该名称的资源索引，支持多语言，例：$string:ability_label。如果在该Ability的skills属性中，actions的取值包含 "action.system.home"，entities取值中包含"entity.system.home"，则该Ability的label将同时作为应用的label。如果存在多个符合条件的Ability，则取位置靠前的Ability的label作为应用的label。 说明： 应用的"icon"和"label"是用户可感知配置项，需要区别于当前所有已有的应用"icon"或"label"（至少有一个不同）。该标签为资源文件中定义的字符串的引用，或以"{}"包括的字符串。该标签最大长度为255个字节。 | 字符串 | 可缺省，缺省值为空。 |
| uri | 标识Ability的统一资源标识符。该标签最大长度为255个字节。 | 字符串 | 可缺省，对于data类型的Ability不可缺省。 |
| launchType |  标识Ability的启动模式，支持"multiton"和"singleton"两种模式： multiton：表示该Ability可以有多实例。该模式适用于大多数应用场景。 singleton：表示该Ability在所有任务栈中仅可以有一个实例。例如，具有全局唯一性的呼叫来电界面即采用"singleton"模式。该标签仅适用于默认设备、平板、智慧屏、车机、智能穿戴。 | 字符串 | 可缺省，缺省值为"singleton"。 |
| visible |  标识Ability是否可以被其他应用调用。 true：可以被其他应用调用。 false：不能被其他应用调用，包括无法被aa工具命令拉起应用。 | 布尔类型 | 可缺省，缺省值为"false"。 |
| permissions | 标识其他应用的Ability调用此Ability时需要申请的权限集合，一个数组元素为一个权限名称。通常采用反向域名格式（最大255字节），取值为系统预定义的权限。 | 字符串数组 | 可缺省，缺省值为空。 |
| skills | 标识Ability能够接收的want的特征。 | 对象数组 | 可缺省，缺省值为空。 |
| deviceCapability | 标识Ability运行时要求设备具有的能力，采用字符串数组的格式表示。该标签为数组，支持最多配置512个元素，单个元素最大字节长度为64。 | 字符串数组 | 可缺省，缺省值为空。 |
| metaData | 元数据。 | 对象 | 可缺省，缺省值为空。 |
| type |  标识Ability的类型。取值范围如下： page：表示基于Page模板开发的FA，用于提供与用户交互的能力。 service：表示基于Service模板开发的PA，用于提供后台运行任务的能力。 data：表示基于Data模板开发的PA，用于对外部提供统一的数据访问对象。 CA：表示支持其他应用以窗口方式调起该Ability。 | 字符串 | 不可缺省。 |
| orientation |  标识该Ability的显示模式。该标签仅适用于page类型的Ability。取值范围如下： unspecified：由系统自动判断显示方向。 landscape：横屏模式。 portrait：竖屏模式。 followRecent：跟随栈中最近的应用。 | 字符串 | 可缺省，缺省值为"unspecified"。 |
| backgroundModes |  标识后台服务的类型，可以为一个服务配置多个后台服务类型。该标签仅适用于service类型的Ability。取值范围如下： dataTransfer：通过网络/对端设备进行数据下载、备份、分享、传输等。 audioPlayback：音频播放。 audioRecording：录音。 pictureInPicture：画中画、小窗口播放视频。 voip：音视频电话、VOIP。 location：定位、导航。 bluetoothInteraction：蓝牙扫描、连接、传输。 wifiInteraction：Wi-Fi扫描、连接、传输。 screenFetch：录屏、截屏。 multiDeviceConnection：多设备互联。 | 字符串数组 | 可缺省，缺省值为空。 |
| grantPermission | 指定是否可以向Ability内任何数据授予权限。 | 布尔值 | 可缺省，缺省值为空。 |
| readPermission | 标识读取Ability的数据所需的权限。该标签仅适用于data类型的Ability。取值为长度不超过255字节的字符串。该标签仅适用于默认设备、平板、智慧屏、车机、智能穿戴。 | 字符串 | 可缺省，缺省为空。 |
| writePermission | 标识向Ability写数据所需的权限。该标签仅适用于data类型的Ability。取值为长度不超过255字节的字符串。 | 字符串 | 可缺省，缺省为空。 |
| configChanges |  标识Ability关注的系统配置集合。当已关注的配置发生变更后，Ability会收到onConfigurationUpdated回调。取值范围： mcc：表示IMSI移动设备国家/地区代码（MCC）发生变更。典型场景：检测到SIM并更新MCC。 mnc：IMSI移动设备网络代码（MNC）发生变更。典型场景：检测到SIM并更新MNC。 locale：表示语言区域发生变更。典型场景：用户已为设备文本的文本显示选择新的语言类型。 layout：表示屏幕布局发生变更。典型场景：当前有不同的显示形态都处于活跃状态。 fontSize：表示字号发生变更。典型场景：用户已设置新的全局字号。 orientation：表示屏幕方向发生变更。典型场景：用户旋转设备。 density：表示显示密度发生变更。典型场景：用户可能指定不同的显示比例，或当前有不同的显示形态同时处于活跃状态。 size：显示窗口大小发生变更。 smallestSize：显示窗口较短边的边长发生变更。 colorMode：颜色模式发生变更。 | 字符串数组 | 可缺省，缺省为空。 |
| mission | 标识Ability指定的任务栈。该标签仅适用于page类型的Ability。默认情况下应用中所有Ability同属一个任务栈。 | 字符串 | 可缺省，缺省为应用的包名。 |
| targetAbility | 标识当前Ability重用的目标Ability。该标签仅适用于page类型的Ability。如果配置了targetAbility属性，则当前Ability（即别名Ability）的属性中仅name、icon、label、visible、permissions、skills生效，其他属性均沿用targetAbility中的属性值。目标Ability必须与别名Ability在同一应用中，且在配置文件中目标Ability必须在别名之前进行声明。 | 字符串 | 可缺省，缺省值为空。表示当前Ability不是一个别名Ability。 |
| formsEnabled |  标识Ability是否支持卡片（forms）功能。该标签仅适用于page类型的Ability。 true：支持卡片能力。 false：不支持卡片能力。 | 布尔值 | 可缺省，缺省值为false。 |
| forms | 标识服务卡片的属性。该标签仅当formsEnabled为"true"时，才能生效。 | 对象数组 | 可缺省，缺省值为空。 |
| srcLanguage | Ability开发语言的类型，开发者创建工程时由开发者手动选择开发语言。取值如下："js"、"ets"、"java"。 | 字符串 | 可缺省，缺省值为"js"。 |
| srcPath | 该标签标识Ability对应的JS组件代码路径，该标签最大长度为127字节。 | 字符串 | 不可缺省。 |
| uriPermission | 标识该Ability有权访问的应用程序数据。此属性由模式和路径子属性组成。此属性仅对类型提供者的能力有效。 | 对象 | 可缺省，缺省值为空。 |
| startWindowIcon | 标识该Ability启动页面图标资源文件的索引。该标签仅适用于page类型的Ability。取值示例：$media:icon。 | 字符串 | 可缺省，缺省值为空。 |
| startWindowBackground | 标识该Ability启动页面背景颜色资源文件的索引。该标签仅适用于page类型的Ability。取值示例：$color:red。 | 字符串 | 可缺省，缺省值为空。 |
| removeMissionAfterTerminate | 该标签标识Ability销毁后是否从任务列表中移除任务。该标签仅适用于page类型的Ability。true表示销毁后移除任务， false表示销毁后不移除任务。 | 布尔值 | 可缺省，缺省值为false。 |
标识Ability名称。取值可采用反向域名方式表示，由包名和类名组成，如"com.example.myapplication.EntryAbility"；也可采用"."开头的类名方式表示，如".EntryAbility"。
Ability的名称，需在一个应用的范围内保证唯一。说明：在使用DevEco Studio新建项目时，默认生成首个Ability的配置，即"config.json"中"EntryAbility"的配置。如使用其他IDE工具，可自定义名称。该标签最大长度为127个字节。
标识Ability图标资源文件的索引。取值示例：$media:ability_icon。如果在该Ability的skills属性中，actions的取值包含 "action.system.home"，entities取值中包含"entity.system.home"，则该Ability的icon将同时作为应用的icon。如果存在多个符合条件的Ability，则取位置靠前的Ability的icon作为应用的icon。
说明：应用的"icon"和"label"是用户可感知配置项，需要区别于当前所有已有的应用"icon"或"label"（至少有一个不同）。
标识Ability对用户显示的名称。取值是对该名称的资源索引，支持多语言，例：$string:ability_label。如果在该Ability的skills属性中，actions的取值包含 "action.system.home"，entities取值中包含"entity.system.home"，则该Ability的label将同时作为应用的label。如果存在多个符合条件的Ability，则取位置靠前的Ability的label作为应用的label。
说明： 应用的"icon"和"label"是用户可感知配置项，需要区别于当前所有已有的应用"icon"或"label"（至少有一个不同）。该标签为资源文件中定义的字符串的引用，或以"{}"包括的字符串。该标签最大长度为255个字节。
标识Ability的启动模式，支持"multiton"和"singleton"两种模式：
multiton：表示该Ability可以有多实例。该模式适用于大多数应用场景。
singleton：表示该Ability在所有任务栈中仅可以有一个实例。例如，具有全局唯一性的呼叫来电界面即采用"singleton"模式。该标签仅适用于默认设备、平板、智慧屏、车机、智能穿戴。
标识Ability是否可以被其他应用调用。
true：可以被其他应用调用。
false：不能被其他应用调用，包括无法被aa工具命令拉起应用。
标识Ability的类型。取值范围如下：
page：表示基于Page模板开发的FA，用于提供与用户交互的能力。
service：表示基于Service模板开发的PA，用于提供后台运行任务的能力。
data：表示基于Data模板开发的PA，用于对外部提供统一的数据访问对象。
CA：表示支持其他应用以窗口方式调起该Ability。
标识该Ability的显示模式。该标签仅适用于page类型的Ability。取值范围如下：
unspecified：由系统自动判断显示方向。
landscape：横屏模式。
portrait：竖屏模式。
followRecent：跟随栈中最近的应用。
标识后台服务的类型，可以为一个服务配置多个后台服务类型。该标签仅适用于service类型的Ability。取值范围如下：
dataTransfer：通过网络/对端设备进行数据下载、备份、分享、传输等。
audioPlayback：音频播放。
audioRecording：录音。
pictureInPicture：画中画、小窗口播放视频。
voip：音视频电话、VOIP。
location：定位、导航。
bluetoothInteraction：蓝牙扫描、连接、传输。
wifiInteraction：Wi-Fi扫描、连接、传输。
screenFetch：录屏、截屏。
multiDeviceConnection：多设备互联。
标识Ability关注的系统配置集合。当已关注的配置发生变更后，Ability会收到onConfigurationUpdated回调。取值范围：
mcc：表示IMSI移动设备国家/地区代码（MCC）发生变更。典型场景：检测到SIM并更新MCC。
mnc：IMSI移动设备网络代码（MNC）发生变更。典型场景：检测到SIM并更新MNC。
locale：表示语言区域发生变更。典型场景：用户已为设备文本的文本显示选择新的语言类型。
layout：表示屏幕布局发生变更。典型场景：当前有不同的显示形态都处于活跃状态。
fontSize：表示字号发生变更。典型场景：用户已设置新的全局字号。
orientation：表示屏幕方向发生变更。典型场景：用户旋转设备。
density：表示显示密度发生变更。典型场景：用户可能指定不同的显示比例，或当前有不同的显示形态同时处于活跃状态。
size：显示窗口大小发生变更。
smallestSize：显示窗口较短边的边长发生变更。
colorMode：颜色模式发生变更。
标识Ability是否支持卡片（forms）功能。该标签仅适用于page类型的Ability。
true：支持卡片能力。
false：不支持卡片能力。
不允许应用隐藏入口图标
系统对无图标应用实施严格管控，防止一些恶意应用故意配置无入口图标，导致用户找不到软件所在的位置，无法操作卸载应用，在一定程度上保证用户终端设备的安全。
入口图标的设置:需要在配置文件（config.json）中abilities配置下设置icon，label以及skills，而且skills的配置下必须同时包含“ohos.want.action.home” 和 “entity.system.home”。
如果应用确需隐藏入口图标，需要配置AllowAppDesktopIconHide应用特权。详细的入口图标及入口标签的显示规则如下。
- HAP中包含Page类型的PageAbility配置文件（config.json）中abilities配置中设置了入口图标该应用没有隐藏图标的特权系统将使用该PageAbility配置的icon作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到该PageAbility首页。系统将使用该PageAbility配置的label作为入口标签，并显示在桌面上（如果没有配置label，返回包名）。该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。配置文件（config.json）中abilities配置中未设置入口图标该应用没有隐藏图标的特权系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。系统将使用应用的包名作为入口标签，并显示在桌面上。该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 配置文件（config.json）中abilities配置中设置了入口图标该应用没有隐藏图标的特权系统将使用该PageAbility配置的icon作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到该PageAbility首页。系统将使用该PageAbility配置的label作为入口标签，并显示在桌面上（如果没有配置label，返回包名）。该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 该应用没有隐藏图标的特权系统将使用该PageAbility配置的icon作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到该PageAbility首页。系统将使用该PageAbility配置的label作为入口标签，并显示在桌面上（如果没有配置label，返回包名）。
- 系统将使用该PageAbility配置的icon作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到该PageAbility首页。
- 系统将使用该PageAbility配置的label作为入口标签，并显示在桌面上（如果没有配置label，返回包名）。
- 该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 配置文件（config.json）中abilities配置中未设置入口图标该应用没有隐藏图标的特权系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。系统将使用应用的包名作为入口标签，并显示在桌面上。该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 该应用没有隐藏图标的特权系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。系统将使用应用的包名作为入口标签，并显示在桌面上。
- 系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。
- 系统将使用应用的包名作为入口标签，并显示在桌面上。
- 该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- HAP中不包含Page类型的PageAbility该应用没有隐藏图标的特权系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。系统将使用应用的包名作为入口标签，并显示在桌面上。该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 该应用没有隐藏图标的特权系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。系统将使用应用的包名作为入口标签，并显示在桌面上。
- 系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。
- 系统将使用应用的包名作为入口标签，并显示在桌面上。
- 该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 配置文件（config.json）中abilities配置中设置了入口图标该应用没有隐藏图标的特权系统将使用该PageAbility配置的icon作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到该PageAbility首页。系统将使用该PageAbility配置的label作为入口标签，并显示在桌面上（如果没有配置label，返回包名）。该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 该应用没有隐藏图标的特权系统将使用该PageAbility配置的icon作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到该PageAbility首页。系统将使用该PageAbility配置的label作为入口标签，并显示在桌面上（如果没有配置label，返回包名）。
- 系统将使用该PageAbility配置的icon作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到该PageAbility首页。
- 系统将使用该PageAbility配置的label作为入口标签，并显示在桌面上（如果没有配置label，返回包名）。
- 该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 配置文件（config.json）中abilities配置中未设置入口图标该应用没有隐藏图标的特权系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。系统将使用应用的包名作为入口标签，并显示在桌面上。该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 该应用没有隐藏图标的特权系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。系统将使用应用的包名作为入口标签，并显示在桌面上。
- 系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。
- 系统将使用应用的包名作为入口标签，并显示在桌面上。
- 该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 该应用没有隐藏图标的特权系统将使用该PageAbility配置的icon作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到该PageAbility首页。系统将使用该PageAbility配置的label作为入口标签，并显示在桌面上（如果没有配置label，返回包名）。
- 系统将使用该PageAbility配置的icon作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到该PageAbility首页。
- 系统将使用该PageAbility配置的label作为入口标签，并显示在桌面上（如果没有配置label，返回包名）。
- 该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 系统将使用该PageAbility配置的icon作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到该PageAbility首页。
- 系统将使用该PageAbility配置的label作为入口标签，并显示在桌面上（如果没有配置label，返回包名）。
- 桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 该应用没有隐藏图标的特权系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。系统将使用应用的包名作为入口标签，并显示在桌面上。
- 系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。
- 系统将使用应用的包名作为入口标签，并显示在桌面上。
- 该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。
- 系统将使用应用的包名作为入口标签，并显示在桌面上。
- 桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 该应用没有隐藏图标的特权系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。系统将使用应用的包名作为入口标签，并显示在桌面上。
- 系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。
- 系统将使用应用的包名作为入口标签，并显示在桌面上。
- 该应用具有隐藏图标的特权桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
- 系统将使用系统默认图标作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面（参考下图）。
- 系统将使用应用的包名作为入口标签，并显示在桌面上。
- 桌面查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
图1应用的详情页示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163450.78364556647121038425919673677780:50001231000000:2800:03451B57CF0ACD7B702190BDCDE57FA6C7E299A409FBB7EFF92CD36D3EB00729.jpg)
注：应用详情页面中显示的label可能与桌面上显示的不同。如果非Page类型的PageAbility配置了入口图标和label，那么详情页中显示的即为配置的。
uriPermission对象的内部结构
表9uriPermission对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| path | uriPermission标识的路径，该标签最大字节长度为255个字节。 | 字符串 | 不可缺省。 |
| mode | uriPermission的匹配模式。 | 字符串 | 可缺省，缺省值为default。 |
abilities示例：
```json
"abilities": [
{
"name": ".EntryAbility",
"description": "test main ability",
// $media:ic_launcher 为媒体类资源
"icon": "$media:ic_launcher",
// $string:example 为字符串类资源
"label": "$string:example",
"launchType": "multiton",
"orientation": "unspecified",
"permissions": [],
"visible": true,
"skills": [
{
"actions": [
"action.system.home"
],
"entities": [
"entity.system.home"
]
}
],
"configChanges": [
"locale",
"layout",
"fontSize",
"orientation"
],
"type": "page",
"startWindowIcon": "$media:icon",
"startWindowBackground": "$color:red",
"removeMissionAfterTerminate": true
},
{
"name": ".PlayService",
"description": "example play ability",
"icon": "$media:ic_launcher",
"label": "$string:example",
"launchType": "multiton",
"orientation": "unspecified",
"visible": false,
"skills": [
{
"actions": [
"action.play.music",
"action.stop.music"
],
"entities": [
"entity.audio"
]
}
],
"type": "service",
"backgroundModes": [
"audioPlayback"
]
},
{
"name": ".UserADataAbility",
"type": "data",
"uri": "dataability://com.example.world.test.UserADataAbility",
"visible": true
}
]
```
skills对象的内部结构
表10skills对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| actions | 标识能够接收的want的action值，可以包含一个或多个action。取值通常为系统预定义的action值。 | 字符串数组 | 可缺省，缺省值为空。 |
| entities | 标识能够接收的want的Ability的类别（如视频、桌面应用等），可以包含一个或多个entity。 | 字符串数组 | 可缺省，缺省值为空。 |
| uris |  该标签标识向want过滤器添加数据规范集合。该规范可以是只有数据类型（mimeType属性），可以是只有URI，也可以是既有数据类型又有URI。 URI由其各个部分的单独属性指定：<scheme>://<host>:<port>[<path>|<pathStartWith>|<pathRegex>]。该标签可缺省，缺省值为空。 其中，scheme字段配置为uri时必配；当只设置数据类型（mimeType）时，则scheme字段为非必配项。 | 对象数组 | 可缺省，缺省值为空。 |
该标签标识向want过滤器添加数据规范集合。该规范可以是只有数据类型（mimeType属性），可以是只有URI，也可以是既有数据类型又有URI。
URI由其各个部分的单独属性指定：<scheme>://<host>:<port>[<path>|<pathStartWith>|<pathRegex>]。该标签可缺省，缺省值为空。
其中，scheme字段配置为uri时必配；当只设置数据类型（mimeType）时，则scheme字段为非必配项。
uris对象的内部结构
表11uris对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| scheme | 标识uri的scheme值。 | 字符串 | 不可缺省。 |
| host | 标识uri的host值。 | 字符串 | 可缺省，缺省值为空。 |
| port | 标识uri的port值。 | 字符串 | 可缺省，缺省值为空。 |
| pathStartWith | 标识uri的pathStartWith值。 | 字符串 | 可缺省，缺省值为空。 |
| path | 标识uri的path值。 | 字符串 | 可缺省，缺省值为空。 |
| pathRegx | 标识uri的pathRegx值。 | 字符串 | 可缺省，缺省值为空。 |
| type |  标识uri的type值。type为MIME-TYPE属性，为资源的媒体类型，常见的类型有"audio/aac"，"text/css"等。 注意：只支持*/*、mainType/*的通配符格式，不支持mainType/subType.*的通配符格式，mainType为标准媒体类型。 | 字符串 | 可缺省，缺省值为空。 |
标识uri的type值。type为MIME-TYPE属性，为资源的媒体类型，常见的类型有"audio/aac"，"text/css"等。
注意：只支持*/*、mainType/*的通配符格式，不支持mainType/subType.*的通配符格式，mainType为标准媒体类型。
skills示例：
```json
"skills": [
{
"actions": [
"action.system.home"
],
"entities": [
"entity.system.home"
],
"uris": [
{
"scheme": "http",
"host": "www.example.com",
"port": "8080",
"path": "query/student/name",
"type": "text/*"
}
]
}
]
```
reqPermissions权限申请
表12reqPermissions权限申请字段说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 需要使用的权限名称。 | 字符串 | 否 |
| reason | 描述申请权限的原因。需要做多语种适配。 | 字符串 | 分情况：当申请的权限为user_grant时，必须填写此字段，否则不允许在应用市场上架；其他权限可缺省，缺省为空。 |
| usedScene |  描述权限使用的场景和时机。场景类型如下两种： - ability：ability的名称，可配置多个。 - when：调用时机，可填的值有inuse（使用时）、always（始终）。 | 对象 |  可缺省，缺省值为空。 when可缺省，缺省值为"inuse"。 |
描述权限使用的场景和时机。场景类型如下两种：
- ability：ability的名称，可配置多个。
- when：调用时机，可填的值有inuse（使用时）、always（始终）。
可缺省，缺省值为空。
when可缺省，缺省值为"inuse"。
usedScene对象内部结构
表13usedScene对象内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| ability | 标识哪些Ability需要此权限，里面配置Ability的名称。 | 字符串数组 | 可以缺省，缺省表示所有Ability都需要此权限。 |
| when |  标识此权限的使用时间： inuse: 使用时需要此权限。 always: 所有时间都需要此权限。 | 枚举值 | 可缺省，缺省值为空。 |
标识此权限的使用时间：
inuse: 使用时需要此权限。
always: 所有时间都需要此权限。
js对象的内部结构
表14js对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识JS Component的名字。 | 字符串 | 不可缺省。 |
| pages | 标识JS Component的页面用于列举JS Component中每个页面的路由信息，格式为“页面路径+页面名称”。其中，页面路径是以当前Ability的srcPath字段取值为基准，例如srcPath取值为EntryAbility，则JS Component页面路径需要从EntryAbility的下一层开始描述。该标签取值为数组，数组第一个元素代表JS FA首页。 | 字符串数组 | 不可缺省。 |
| window | 用于定义与显示窗口相关的配置。 | 对象 | 可缺省，缺省值见表15。 |
| type |  标识JS应用的类型。取值范围如下： normal：标识该JS Component为应用实例。 form：标识该JS Component为卡片实例。 | 字符串 | 可缺省，缺省值为"normal"。 |
| mode | 定义JS组件的开发模式。 | 对象 | 可缺省，缺省值为空。 |
标识JS应用的类型。取值范围如下：
normal：标识该JS Component为应用实例。
form：标识该JS Component为卡片实例。
window对象的内部结构
表15window对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| designWidth | 标识页面设计基准宽度。以此为基准，根据实际设备宽度来缩放元素大小。 | 数值 | 可缺省，缺省值为720px。 |
| autoDesignWidth | 标识页面设计基准宽度是否自动计算。当配置为true时，designWidth将会被忽略，设计基准宽度由设备宽度与屏幕密度计算得出。 | 布尔值 | 可缺省，缺省值为false。 |
mode对象的内部结构
表16mode对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| type | 定义JS组件的功能类型。 | 字符串，取值为"pageAbility"、"form" | 可缺省，缺省值为pageAbility。 |
| syntax | 定义JS组件的语法类型。 | 字符串，取值为"hml"，"ets" | 可缺省，默认值为"hml"。 |
js示例：
```json
"js": [
{
"name": ".EntryAbility",
"pages": [
"pages/index",
"pages/detail/detail"
],
"window": {
"designWidth": 720,
"autoDesignWidth": false
},
"type": "form",
"mode": {
"syntax": "ets",
"type": "pageAbility"
}
}
]
```
shortcuts对象的内部结构
表17shortcuts对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| shortcutId | 标识快捷方式的ID。字符串的最大长度为63字节。 | 字符串 | 不可缺省。 |
| label | 标识快捷方式的标签信息，即快捷方式对外显示的文字描述信息。取值可以是描述性内容，也可以是标识label的资源索引。字符串最大长度为63字节。 | 字符串 | 可缺省，缺省为空。 |
| icon | 标识快捷方式的图标信息。取值为表示icon的资源索引。 | 字符串 | 可缺省，缺省为空。 |
| intents | 标识快捷方式内定义的目标intent信息集合，每个intent可配置两个子标签，targetClass, targetBundle。 | 对象数组 | 可缺省，缺省为空。 |
intents对象的内部结构
表18intents对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| targetClass | 标识快捷方式目标类名。 | 字符串 | 可缺省，缺省值为空。 |
| targetBundle | 标识快捷方式目标Ability所在应用的包名。 | 字符串 | 可缺省，缺省值为空。 |
shortcuts示例：
```json
"shortcuts": [
{
"shortcutId": "id",
// $string:shortcut 为配置的字符串资源值
"label": "$string:shortcut",
"intents": [
{
"targetBundle": "com.example.world.test",
"targetClass": "com.example.world.test.entry.EntryAbility"
}
]
}
]
```
forms对象的内部结构
表19forms对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识卡片的类名。字符串最大长度为127字节。 | 字符串 | 不可缺省。 |
| description | 标识卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。 | 字符串 | 可缺省，缺省为空。 |
| isDefault |  标识该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。 true：默认卡片。 false：非默认卡片。 | 布尔值 | 不可缺省。 |
| type |  标识卡片的类型。取值范围如下： JS：JS卡片。 Java：Java卡片。 | 字符串 | 不可缺省。 |
| colorMode |  标识卡片的主题样式，取值范围如下： auto：自适应。 dark：深色主题。 light：浅色主题。 | 字符串 | 可缺省，缺省值为"auto"。 |
| supportDimensions |  标识卡片支持的外观规格，取值范围： 1 * 2：表示1行2列的二宫格。 2 * 1：表示2行1列的二宫格。 2 * 2：表示2行2列的四宫格。 2 * 4：表示2行4列的八宫格。 4 * 4：表示4行4列的十六宫格。 | 字符串数组 | 不可缺省。 |
| defaultDimension | 标识卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 | 字符串 | 不可缺省。 |
| updateEnabled |  标识卡片是否支持周期性刷新，取值范围： true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。 false：表示不支持周期性刷新。 | 布尔类型 | 不可缺省。 |
| scheduledUpdateTime | 标识卡片的定点刷新的时刻，采用24小时制，精确到分钟。 | 字符串 | 可缺省，缺省值为"0:0"。 |
| updateDuration |  标识卡片定时刷新的更新周期，单位为30分钟，取值为自然数。 当取值为0时，表示该参数不生效。 当取值为正整数N时，表示刷新周期为30*N分钟。 | 数值 | 可缺省，缺省值为"0"。 |
| formConfigAbility | 标识用于调整卡片的设施或活动的名称。 | 字符串 | 可缺省，缺省值为空。 |
| jsComponentName | 标识JS卡片的Component名称。字符串最大长度为127字节。仅当卡片类型为JS卡片时，需要配置该标签。 | 字符串 | 可缺省，缺省值为空。 |
| metaData | 标识卡片的自定义信息，包含customizeData数组标签。 | 对象 | 可缺省，缺省值为空。 |
| formVisibleNotify |  标识是否允许卡片使用卡片可见性通知。 true：允许。 false：不允许。 | 布尔值 | 可缺省，缺省值为false。 |
标识该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。
true：默认卡片。
false：非默认卡片。
标识卡片的类型。取值范围如下：
JS：JS卡片。
Java：Java卡片。
标识卡片的主题样式，取值范围如下：
auto：自适应。
dark：深色主题。
light：浅色主题。
标识卡片支持的外观规格，取值范围：
1 * 2：表示1行2列的二宫格。
2 * 1：表示2行1列的二宫格。
2 * 2：表示2行2列的四宫格。
2 * 4：表示2行4列的八宫格。
4 * 4：表示4行4列的十六宫格。
标识卡片是否支持周期性刷新，取值范围：
true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。
false：表示不支持周期性刷新。
标识卡片定时刷新的更新周期，单位为30分钟，取值为自然数。
当取值为0时，表示该参数不生效。
当取值为正整数N时，表示刷新周期为30*N分钟。
标识是否允许卡片使用卡片可见性通知。
true：允许。
false：不允许。
customizeData对象内部结构
表20customizeData对象内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识数据项的键名称。字符串最大长度为255字节。 | 字符串 | 可缺省，缺省值为空。 |
| value | 标识数据项的值。字符串最大长度为255字节。 | 字符串 | 可缺省，缺省值为空。 |
| extra | 标识当前custom数据的格式，取值为表示extra的资源值。 | 字符串 | 可缺省，缺省值为空。 |
forms示例：
```json
"forms": [
{
"name": "Form_Js",
"description": "It's Js Form",
"type": "JS",
"jsComponentName": "card",
"colorMode": "auto",
"isDefault": true,
"updateEnabled": true,
"scheduledUpdateTime": "11:00",
"updateDuration": 1,
"defaultDimension": "2*2",
"supportDimensions": [
"2*2",
"2*4",
"4*4"
]
},
{
"name": "Form_Js",
"description": "It's JS Form",
"type": "Js",
"colorMode": "auto",
"isDefault": false,
"updateEnabled": true,
"scheduledUpdateTime": "21:05",
"updateDuration": 1,
"defaultDimension": "1*2",
"supportDimensions": [
"1*2"
],
"landscapeLayouts": [
"$layout:ability_form"
],
"portraitLayouts": [
"$layout:ability_form"
],
"formConfigAbility": "ability://com.example.myapplication.fa/.EntryAbility",
"metaData": {
"customizeData": [
{
"name": "originWidgetName",
"value": "com.example.weather.testWidget"
}
]
}
}
]
```
distroFilter对象的内部结构
表21distroFilter对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| apiVersion | 标识支持的apiVersion范围。 | 对象数组 | 可缺省，缺省值为空。 |
| screenShape | 标识屏幕形状的支持策略。 | 对象数组 | 可缺省，缺省值为空。 |
| screenWindow | 标识应用运行时窗口的分辨率支持策略。该字段仅支持对轻量级智能穿戴设备进行配置。 | 对象数组 | 可缺省，缺省值为空。 |
| screenDensity | 标识屏幕的像素密度（dpi：Dots Per Inch）。 | 对象数组 | 可缺省，缺省值为空。 |
| countryCode | 标识分发应用时的国家码。具体值参考ISO-3166-1的标准，支持多个国家和地区的枚举定义。 | 对象数组 | 可缺省，缺省值为空。 |
apiVersion对象的内部结构
表22apiVersion对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| policy |  标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。 | 字符串 | 不可缺省。 |
| value | 支持的取值为API Version存在的整数值，例如4、5、6。场景示例：某应用，针对相同设备型号，同时在网的为使用API 5和API 6开发的两个软件版本，则允许上架2个entry类型的安装包，分别支持到对应设备侧软件版本的分发。 | 数组 | 不可缺省。 |
标识该子属性取值规则。配置为“exclude”或“include”。
- exclude：表示需要排除的value属性。
- include：表示需要包含的value属性。
screenShape对象的内部结构
表23screenShape对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| policy |  标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。 | 字符串 | 不可缺省。 |
| value | 支持的取值为API Version存在的整数值，例如4、5、6。场景示例：某应用，针对相同设备型号，同时在网的为使用API 5和API 6开发的两个软件版本，则允许上架2个entry类型的安装包，分别支持到对应设备侧软件版本的分发。 | 数组 | 不可缺省。 |
标识该子属性取值规则。配置为“exclude”或“include”。
- exclude：表示需要排除的value属性。
- include：表示需要包含的value属性。
screenWindow对象的内部结构
表24screenWindow对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| policy |  标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。 | 字符串 | 不可缺省。 |
| value | 支持的取值为API Version存在的整数值，例如4、5、6。场景示例：某应用，针对相同设备型号，同时在网的为使用API 5和API 6开发的两个软件版本，则允许上架2个entry类型的安装包，分别支持到对应设备侧软件版本的分发。 | 数组 | 不可缺省。 |
标识该子属性取值规则。配置为“exclude”或“include”。
- exclude：表示需要排除的value属性。
- include：表示需要包含的value属性。
screenDensity对象的内部结构
表25screenDensity对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| policy |  标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。 | 字符串 | 不可缺省。 |
| value |  取值范围如下： sdpi：表示小规模的屏幕密度（Small-scale Dots Per Inch），适用于dpi取值为（0,120]的设备。 mdpi：表示中规模的屏幕密度(Medium-scale Dots Per Inch)，适用于dpi取值为（120,160]的设备。 ldpi：表示大规模的屏幕密度(Large-scale Dots Per Inch)，适用于dpi取值为（160,240]的设备。 xldpi：表示特大规模的屏幕密度(Extra Large-scale Dots Per Inch)，适用于dpi取值为（240,320]的设备。 xxldpi：表示超大规模的屏幕密度(Extra Extra Large-scale Dots Per Inch)，适用于dpi取值为（320,480]的设备。 xxxldpi：表示超特大规模的屏幕密度(Extra Extra Extra Large-scale Dots Per Inch)，适用于dpi取值为（480,640]的设备。 | 数组 | 不可缺省。 |
标识该子属性取值规则。配置为“exclude”或“include”。
- exclude：表示需要排除的value属性。
- include：表示需要包含的value属性。
取值范围如下：
sdpi：表示小规模的屏幕密度（Small-scale Dots Per Inch），适用于dpi取值为（0,120]的设备。
mdpi：表示中规模的屏幕密度(Medium-scale Dots Per Inch)，适用于dpi取值为（120,160]的设备。
ldpi：表示大规模的屏幕密度(Large-scale Dots Per Inch)，适用于dpi取值为（160,240]的设备。
xldpi：表示特大规模的屏幕密度(Extra Large-scale Dots Per Inch)，适用于dpi取值为（240,320]的设备。
xxldpi：表示超大规模的屏幕密度(Extra Extra Large-scale Dots Per Inch)，适用于dpi取值为（320,480]的设备。
xxxldpi：表示超特大规模的屏幕密度(Extra Extra Extra Large-scale Dots Per Inch)，适用于dpi取值为（480,640]的设备。
countryCode对象的内部结构
表26countryCode对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| policy |  标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。 | 字符串 | 不可缺省。 |
| value | 该标签标识应用需要分发的国家码，标签为字符串数组，子串表示支持的国家或地区，由两个大写字母表示。 | 字符串数组 | 不可缺省。 |
标识该子属性取值规则。配置为“exclude”或“include”。
- exclude：表示需要排除的value属性。
- include：表示需要包含的value属性。
distroFilter示例：
```json
"distroFilter":  {
"apiVersion": {
"policy": "include",
"value": [4,5]
},
"screenShape": {
"policy": "include",
"value": ["circle","rect"]
},
"screenWindow": {
"policy": "include",
"value": ["454*454","466*466"]
},
"screenDensity":{
"policy": "exclude",
"value": ["ldpi","xldpi"]
},
"countryCode": {
"policy":"include",
"value":["CN","HK"]
}
}
```
commonEvents对象的内部结构
表27commonEvents对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识静态公共事件名称，该标签最大长度为127字节。 | 字符串 | 不可缺省。 |
| permission | 此标签标识实现静态公共事件所需要申请的权限，该标签最大长度为255字节。 | 字符串 | 可缺省，缺省值为空。 |
| data | 标识配置当前静态公共事件要携带的附加数据数组。 | 字符串数组 | 可缺省，缺省值为空。 |
| type | 该标签用于配置当前静态公共事件的分类数组。 | 字符串数组 | 可缺省，缺省值为空。 |
| events | 此标签标识可接收的意图的一组事件值。一般由系统预定义，也可以自定义。 | 字符串数组 | 不可缺省。 |
commonEvents示例：
```json
"commonEvents": [
{
"name": ".EntryAbility",
"permission": "ohos.permission.GET_BUNDLE_INFO",
"data": [
"com.example.demo",
"100"
],
"events": [
"install",
"update"
]
}
]
```
testRunner对象的内部结构
表28testRunner对象的内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识测试框架对象名称，该标签最大长度为255字节。 | 字符串 | 不可缺省。 |
| srcPath | 标识测试框架代码路径，该标签最大长度为255字节。 | 字符串 | 不可缺省。 |
```json
"testRunner": {
"name": "myTestRunnerName",
"srcPath": "etc/test/TestRunner.ts"
}
```
definePermission仅支持系统应用配置，三方应用配置不生效。
definePermissions对象内部结构
表29definePermissions对象内部结构说明
| 属性名称 | 含义 | 数据类型 | 是否可缺省 |
| --- | --- | --- | --- |
| name | 标识权限的名称，该标签最大长度为255字节。 | 字符串 | 不可缺省。 |
| grantMode |  标识权限的授予方式，支持如下两种授予模式如下： - system_grant：安装后系统自动授予该权限。 - user_grant：使用时动态申请，用户授权后才可使用。 | 字符串 | 可缺省，缺省值为system_grant。 |
| availableLevel |  标识权限限制类别，可选值如下： - system_core：系统核心权限。 - system_basic：系统基础权限。 - normal：普通权限。所有应用允许申请的权限。 | 字符串 | 可缺省，缺省值为normal。 |
| provisionEnable | 标识权限是否支持证书方式申请权限，包括高级别的权限。配置为true标识开发者可以通过provision方式申请权限。 | 布尔值 | 可缺省，缺省值为true。 |
| distributedSceneEnabled | 标识权限是否支持分布式场景下使用该权限。 | 布尔值 | 可缺省，缺省值为false。 |
| label | 标识权限的简短描述，配置为对描述内容的资源索引。 | 字符串 | 可缺省，缺省值为空。 |
| description | 标识权限的详细描述，可以是字符串（最大长度为255字节），或者为对描述内容的资源索引。 | 字符串 | 可缺省，缺省值为空。 |
标识权限的授予方式，支持如下两种授予模式如下：
- system_grant：安装后系统自动授予该权限。
- user_grant：使用时动态申请，用户授权后才可使用。
标识权限限制类别，可选值如下：
- system_core：系统核心权限。
- system_basic：系统基础权限。
- normal：普通权限。所有应用允许申请的权限。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-typical-scenarios
爬取时间: 2025-04-27 21:41:56
来源: Huawei Developer
- 集成态HSP
- HAR转HSP指导
- HSP转HAR指导
- 创建应用静态快捷方式
- 创建应用分身
- 创建应用多实例
- 配置分层图标

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/integrated-hsp
爬取时间: 2025-04-27 21:42:10
来源: Huawei Developer
集成态HSP是应用内HSP的一种中间编译产物，目的就是解决使用方的bundleName和签名之间的强耦合问题。
HSP只能给bundleName一样的项目使用，集成态HSP可以给不同的bundleName的工程集成使用。
使用场景
集团内部有多个应用，多个应用中都有一个相同的动态共享包。为了节约开发成本，实现代码和资源的共享，多个应用可以共享一个基建HSP(集成态HSP)。
约束限制
- 集成态HSP只支持Stage模型。
- 集成态HSP需要API12及以上版本，需要在工程级的build-profile.json5文件中，将useNormalizedOHMUrl字段设置为true。
开发使用说明
1.  创建方-集成态HSP-工程配置：集成态HSP需要在工程级的build-profile.json5文件中，将useNormalizedOHMUrl字段设置为true。
```json
// created_party_project/build-profile.json5
{
"app": {
"products": [
{
"name": "default",
"signingConfig": "default",
"compatibleSdkVersion": "5.0.0(12)",
"runtimeOS": "HarmonyOS",
"buildOption": {
"strictMode": {
"useNormalizedOHMUrl": true
}
}
// ...
}
]
// ...
}
}
```
2.  创建方-集成态HSP-模块配置：修改模块级构建配置文件build-profile.json5，设置配置项integratedHsp为true，指定构建的HSP模块为集成态HSP。
```json
// created_party_project/library/build-profile.json5
{
"apiType": "stageMode",
"buildOption": {
"arkOptions": {
"integratedHsp": true
}
}
}
```
3.  创建方-集成态HSP-打包配置（tgz包）。 (1) 配置项目签名信息，详见应用/服务签名； (2) 配置release模式； (3) 选择library目录，Build -> Make Module 'library'。
4.  使用方-创建目录拷贝文件，在entry目录下新建libs目录，将集成态打包产物tgz包拷贝到libs目录下。
5.  使用方-工程依赖配置：使用方主模块下oh-package.json5配置文件中添加依赖。
```json
// user_project/entry/oh-package.json5
"dependencies": {
"hsp": "./libs/library-default.tgz"
}
```
6.  使用方-工程配置：集成态HSP需要在工程级的build-profile.json5文件中，将useNormalizedOHMUrl字段设置为true。 安装运行应用前，使用方工程必须配置项目签名信息，详见应用/服务签名。
```json
// user_project/build-profile.json5
{
"app": {
"products": [
{
"name": "default",
"signingConfig": "default",
"compatibleSdkVersion": "5.0.0(12)",
"runtimeOS": "HarmonyOS",
"buildOption": {
"strictMode": {
"useNormalizedOHMUrl": true
}
}
}
]
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163450.34304301292998924169996417581537:50001231000000:2800:3D61A1525135F82FE2F6F93F4FC2CE73078A2BB3898B4092A7B6CD62A93D2212.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/har-to-hsp
爬取时间: 2025-04-27 21:42:24
来源: Huawei Developer
目前HAR的使用存在打包多份，包膨胀的问题，导致整体应用包的体积很大，HSP可以很好地解决该问题，本文介绍了HAR转HSP的步骤，主要是通过配置项的变更将HAR工程变成HSP工程。
HAR转HSP的操作步骤
1.  修改HAR模块下的module.json5文件，修改type字段为shared，新增deliveryWithInstall和pages字段。
```json
// MyApplication\library\src\main\module.json5
{
"module": {
"type": "shared",
"deliveryWithInstall": true,
"pages": "$profile:main_pages"
// ...
}
}
```
2.  在resources下的base，en_US和zh_CN的element下新增一个string字段shared_desc。
```json
// MyApplication\library\src\main\resources\base\element\string.json
{
"string": [
{
"name": "shared_desc",
"value": "description"
}
]
}
```
3.  在resources\base下新增profile文件夹，在profile下新增一个main_pages.json文件，并配置如下内容。
```json
// MyApplication\library\src\main\resources\base\profile\main_pages.json
{
"src": [
"pages/PageIndex"
]
}
```
4.  在ets目录下新增pages目录，并在pages目录下新增PageIndex.ets文件，并配置如下内容。
```typescript
// MyApplication\library\src\main\ets\pages\PageIndex.ets
@Entry
@Component
struct PageIndex {
@State message: string = 'hello world';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
.width('100%')
}
.height('100%')
}
}
```
5.  删除HAR模块的build-profile.json5文件中的consumerFiles字段配置。
6.  修改HAR模块的hvigorfile.ts文件，将下面内容替换该文件内容。
```typescript
// MyApplication\library\hvigorfile.ts
import { hspTasks } from '@ohos/hvigor-ohos-plugin';
export default {
system: hspTasks,  /* Built-in plugin of Hvigor. It cannot be modified. */
plugins:[]         /* Custom plugin to extend the functionality of Hvigor. */
}
```
7.  修改oh-package.json5文件，新增packageType配置。
```json
// MyApplication\library\oh-package.json5
{
"packageType": "InterfaceHar"
}
```
8.  修改项目根目录下的配置文件build-profile.json5，在modules标签下找到library的配置，新增targets标签。
```json
// MyApplication\build-profile.json5
"modules": [
{
"name": "library",
"srcPath": "./library",
"targets": [
{
"name": "default",
"applyToProducts": [
"default"
]
}
]
}
]
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hsp-to-har
爬取时间: 2025-04-27 21:42:37
来源: Huawei Developer
HSP存在bundleName和签名的一致性要求，而且在调试阶段需要先安装HSP包，导致多模块集成开发存在很多集成的问题，在此场景下推荐使用HAR包的方式提供能力。本文通过配置项的变更将HSP工程变成HAR工程。
HSP转HAR的操作步骤
1.  修改HSP模块下的module.json5文件，type字段值修改成har，删除deliveryWithInstall和pages字段。
```json
// MyApplication\library\src\main\module.json5
{
"module": {
"name": "har",
"type": "har",
"deviceTypes": [
"default",
"tablet",
"2in1"
]
}
}
```
2.  在resource\base\profile文件夹下，删除main_pages.json文件。
3.  修改HSP模块的hvigorfile.ts文件，将下面内容替换该文件内容。
```typescript
// MyApplication\library\hvigorfile.ts
import { harTasks } from '@ohos/hvigor-ohos-plugin';
export default {
system: harTasks,  /* Built-in plugin of Hvigor. It cannot be modified. */
plugins:[]         /* Custom plugin to extend the functionality of Hvigor. */
}
```
4.  修改HSP模块的oh-package.json5文件，删除packageType配置。
5.  修改项目级的配置文件build-profile.json5，在modules模块下找到HSP的配置信息，删除HSP配置下的targets。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/typical-scenario-configuration
爬取时间: 2025-04-27 21:42:51
来源: Huawei Developer
静态快捷方式是一种在系统中创建的可以快速访问应用程序或特定功能的链接。它通常可以在长按应用图标，以图标和相应的文字出现在应用图标的上方，用户可以迅速启动对应应用程序的组件。使用快捷方式，可以提高效率，节省了查找和打开对应的组件时间；也可以实现个性化定制的需求，创建多个快捷方式，以满足个性化的工作流程和操作偏好。应用配置静态快捷方式，在桌面上展示的效果如下图：
安装该应用后，在桌面上长按该应用图标，在应用的图标上方会出现开发者配置的快捷方式（“添加收藏”和“分享好友”），点击对应的标签，即可拉起对应的组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163450.56495445747253518606590570479912:50001231000000:2800:7DDDDEBD11B4B3A2176D889F309F9F877ABC517403CB69A983AB910F3A330161.jpg)
配置方法
下面介绍在工程中配置静态快捷方式的方法。
1.  配置快捷方式的配置文件。 开发者若要配置静态快捷方式，可以在某个模块的/resources/base/profile/目录下配置快捷方式的配置文件，如shortcuts_config.json。
```json
{
"shortcuts": [
{
"shortcutId": "id_test1",  // 标识快捷方式，在应用有多个快捷方式时，该字段可作为快捷方式的唯一标识符
"label": "$string:share",  // 标识该快捷方式对外显示的文字
"icon": "$media:share_icon",  // 标识该快捷方式对外显示的图片
"wants": [
{
"bundleName": "com.ohos.hello",   // 对应该快捷方式对应拉起组件的包名
"moduleName": "entry",    // 对应该快捷方式对应拉起组件的模块名
"abilityName": "EntryAbility",   // 对应该快捷方式对应拉起组件的组件名
"parameters": {
"testKey": "testValue"   // 表示拉起快捷方式时的自定义数据
}
}
]
}
]
}
```
2.  在应用module.json5文件中配置metadata指向快捷方式的配置文件。
```json
{
"module": {
// ...
"abilities": [
{
"name": "EntryAbility",
"srcEntry": "./ets/entryability/EntryAbility.ets",
// ...
"metadata": [
{
"name": "ohos.ability.shortcuts",  // 配置快捷方式，该值固定为ohos.ability.shortcuts
"resource": "$profile:shortcuts_config"  // 指定shortcuts信息的资源位置
}
]
}
]
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-clone
爬取时间: 2025-04-27 21:43:04
来源: Huawei Developer
应用分身能实现在一个设备上安装多个相同的应用，实现多个账号同时登录使用和运行并且互不影响。主要应用场景有社交账号双开、游戏大小号双开等，无需账号切换，从而省去频繁登录的繁琐。
创建应用分身后，在桌面上会出现多个应用图标相同的应用，其中拥有下角标的应用图标为分身应用。
主应用与分身应用的关系：
- 主应用和分身应用共享同一个应用。例如，当主应用更新/升级时，主应用与分身应用都会同步更新，包括应用的图标（icon）和名称（label）、应用特性本身的新特性等。
- 主应用和分身应用，其对应的使能和相关配置都是独立的，数据也是彼此隔离。
- 当主应用被卸载时，会同步卸载掉所有的分身应用。而卸载分身应用不会出现这样的情况。
效果图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163450.60422457964205579273506779786713:50001231000000:2800:7FE83129C3749E2CA1ACD6275BE40D039B3A2889EE3852811A75500B38C12568.png)
约束与限制
输入法应用配置分身无效，无法创建应用分身。
应用分身的开发步骤
1.  应用分身的配置方法。 在工程项目中对AppScope/app.json5配置文件配置multiAppMode字段。具体配置如下：
```json
{
"app": {
"multiAppMode": {
"multiAppModeType": "appClone",
"maxCount": 2
}
}
}
```
2.  创建分身应用。 首先将已配置好的工程编译打包安装到设备上。 然后打开设置>系统>应用分身，点击“创建分身”。 最后返回到桌面查看是否创建成功。 图中的三个应用都是独立的进程，运行、数据、通知等，都是彼此独立的。
3.  首先将已配置好的工程编译打包安装到设备上。
4.  然后打开设置>系统>应用分身，点击“创建分身”。
5.  最后返回到桌面查看是否创建成功。 图中的三个应用都是独立的进程，运行、数据、通知等，都是彼此独立的。
- 首先将已配置好的工程编译打包安装到设备上。
- 然后打开设置>系统>应用分身，点击“创建分身”。
- 最后返回到桌面查看是否创建成功。图中的三个应用都是独立的进程，运行、数据、通知等，都是彼此独立的。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163450.34917611712355907345911560725059:50001231000000:2800:F7033BD0D9D4243A94445988127E0981C2BF66DB41383ABBADE1A5C1BE77928A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163450.36036641059007871463557704089110:50001231000000:2800:F5BAEBC5BDF0F12984BF329D38DAE993A5C0632A9D92EB5C27FA672D57B59ECE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163450.96136866352149306839492260889493:50001231000000:2800:C93440430FB048721AC2640CA99D03E58049489F043F9C0A955F94FC170BE782.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163450.98359365241331966429306205108345:50001231000000:2800:2874EE520BDE6F956AA757DBCB278CD0ED347BCF138B2F9A96CADD0F83771374.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/multiinstance
爬取时间: 2025-04-27 21:43:19
来源: Huawei Developer
应用多实例是一个应用允许开多个页面运行，实现多个账号同时登录使用和运行并且互不影响。主要应用场景有社交账户多开、游戏大小号多开等，无需切换账号，从而省去频繁登录的繁琐。
桌面上的多个应用进程页面都是独立的进程，各个进程的运行、通知等都是彼此独立的；各实例共享数据，可通过账号进行切换。
应用多实例间的关系：
- 多实例的应用图标相同。
- 各实例共享数据，可通过账号进行切换。
约束限制
应用多实例仅支持2in1设备。
应用多实例的开发步骤
1.  应用多实例的配置方法。 在工程项目中对App/app.json5配置文件配置multiAppMode字段。具体配置如下：
```json
{
"app": {
"multiAppMode": {
"multiAppModeType": "multiInstance",
"maxCount": 5
}
}
}
```
2.  创建应用多实例。
- 将已配置好的工程编译打包安装到设备上。
- 首次右击桌面应用图标打开一个应用进程，然后再次右击刚才打开的应用图标，选择“打开”。此时桌面会呈现同一个应用的两个应用进程页面。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/layered-image
爬取时间: 2025-04-27 21:43:32
来源: Huawei Developer
应用图标如果采用分层图标（包括前景图和背景图两层），可以参考本章节进行配置。图标规范详见图标资源规范，图标配置规则详见图标配置。
配置步骤
1.  将前景资源和背景资源文件放在“AppScope\resources\base\media”文件下。 本例中采用的前景资源和背景资源的文件名分别为“foreground.png”和“background.png”。
```json
{
"layered-image":
{
"background" : "$media:background",
"foreground" : "$media:foreground"
}
}
```
```json
{
"app": {
"icon": "$media:layered_image",
// ...
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/resource-categories-and-access
爬取时间: 2025-04-27 21:43:47
来源: Huawei Developer
应用开发过程中，经常需要用到颜色、字体、间距、图标等资源，在不同的设备或配置中，这些资源的值可能不同。
- 应用资源：借助资源文件能力，开发者在应用中自定义资源，自行管理这些资源在不同的设备或配置中的表现。
- 系统资源：开发者可以在应用UX设计关于资源的介绍，获取支持的色彩、字体等系统资源ID及其在不同配置下的取值；在主题图标库获取支持的系统图标资源。
资源分类
应用开发中使用的各类资源文件，需要放入特定子目录中存储管理。资源目录的示例如下所示，base目录、限定词目录、rawfile目录、resfile目录称为资源目录，element、media、profile称为资源组目录。
stage模型多工程情况下，共有的资源文件放到AppScope下的resources目录。
资源目录示例：
资源目录
base目录
base目录是默认存在的目录，二级子目录element用于存放字符串、颜色、布尔值等基础元素，media、profile存放媒体、动画、布局等资源文件。
目录中的资源文件会被编译成二进制文件，并赋予资源文件ID。通过指定资源类型（type）和资源名称（name）访问。
限定词目录
限定词目录需要开发者根据开发需要自行创建，二级子目录element、media、profile用于存放字符串、颜色、布尔值等基础元素，以及媒体、动画、布局等资源文件。
同样，目录中的资源文件会被编译成二进制文件，并赋予资源文件ID。通过指定资源类型（type）和资源名称（name）来访问。
限定词目录的命名要求
限定词目录可以由一个或多个表征应用场景或设备特征的限定词组合而成，包括移动国家码和移动网络码、语言、文字、国家或地区、横竖屏、设备类型、颜色模式和屏幕密度等维度，限定词之间通过下划线（_）或者中划线（-）连接。开发者在创建限定词目录时，需要遵守限定词目录的命名规则。
- 限定词的组合顺序：移动国家码_移动网络码-语言_文字_国家或地区-横竖屏-设备类型-颜色模式-屏幕密度。开发者可以根据应用的使用场景和设备特征，选择其中的一类或几类限定词组成目录名称。
- 限定词的连接方式：语言、文字、国家或地区之间采用下划线（_）连接，移动国家码和移动网络码之间也采用下划线（_）连接，除此之外的其他限定词之间均采用中划线（-）连接。例如：zh_Hant_CN、zh_CN-car-ldpi。
- 限定词的取值范围：每类限定词的取值必须符合限定词取值要求表中的条件，如表2。否则，将无法匹配目录中的资源文件。
表2 限定词取值要求
| 限定词类型 | 含义与取值说明 |
| --- | --- |
| 移动国家码和移动网络码 |  移动国家码（MCC）和移动网络码（MNC）的值取自设备注册的网络。 MCC可与MNC合并使用，使用下划线（_）连接，也可以单独使用。例如：mcc460表示中国，mcc460_mnc00表示中国_中国移动。 详细取值范围，请查阅ITU-T E.212（国际电联相关标准）。 |
| 语言 |  表示设备使用的语言类型，由2~3个小写字母组成。例如：zh表示中文，en表示英语，mai表示迈蒂利语。 详细取值范围，请查阅ISO 639（ISO制定的语言编码标准）。 |
| 文字 |  表示设备使用的文字类型，由1个大写字母（首字母）和3个小写字母组成。例如：Hans表示简体中文，Hant表示繁体中文。 详细取值范围，请查阅ISO 15924（ISO制定的文字编码标准）。 |
| 国家或地区 |  表示用户所在的国家或地区，由2~3个大写字母或者3个数字组成。例如：CN表示中国，GB表示英国。 详细取值范围，请查阅ISO 3166-1（ISO制定的国家和地区编码标准）。 |
| 横竖屏 |  表示设备的屏幕方向，取值如下： - vertical：竖屏 - horizontal：横屏 |
| 设备类型 |  表示设备的类型，取值如下： - phone：手机 - car：车机 - tablet：平板 - tv：智慧屏 - wearable：智能穿戴 - 2in1：PC设备 |
| 颜色模式 |  表示设备的颜色模式，取值如下： - dark：深色模式 - light：浅色模式 |
| 屏幕密度 |  表示设备的屏幕密度（单位为dpi），取值如下： - sdpi：表示小规模的屏幕密度（Small-scale Dots Per Inch），适用于dpi取值为(0, 120]的设备。 - mdpi：表示中规模的屏幕密度（Medium-scale Dots Per Inch），适用于dpi取值为(120, 160]的设备。 - ldpi：表示大规模的屏幕密度（Large-scale Dots Per Inch），适用于dpi取值为(160, 240]的设备。 - xldpi：表示特大规模的屏幕密度（Extra Large-scale Dots Per Inch），适用于dpi取值为(240, 320]的设备。 - xxldpi：表示超大规模的屏幕密度（Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(320, 480]的设备。 - xxxldpi：表示超特大规模的屏幕密度（Extra Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(480, 640]的设备。 |
移动国家码（MCC）和移动网络码（MNC）的值取自设备注册的网络。
MCC可与MNC合并使用，使用下划线（_）连接，也可以单独使用。例如：mcc460表示中国，mcc460_mnc00表示中国_中国移动。
详细取值范围，请查阅ITU-T E.212（国际电联相关标准）。
表示设备使用的语言类型，由2~3个小写字母组成。例如：zh表示中文，en表示英语，mai表示迈蒂利语。
详细取值范围，请查阅ISO 639（ISO制定的语言编码标准）。
表示设备使用的文字类型，由1个大写字母（首字母）和3个小写字母组成。例如：Hans表示简体中文，Hant表示繁体中文。
详细取值范围，请查阅ISO 15924（ISO制定的文字编码标准）。
表示用户所在的国家或地区，由2~3个大写字母或者3个数字组成。例如：CN表示中国，GB表示英国。
详细取值范围，请查阅ISO 3166-1（ISO制定的国家和地区编码标准）。
表示设备的屏幕方向，取值如下：
- vertical：竖屏
- horizontal：横屏
表示设备的类型，取值如下：
- phone：手机
- car：车机
- tablet：平板
- tv：智慧屏
- wearable：智能穿戴
- 2in1：PC设备
表示设备的颜色模式，取值如下：
- dark：深色模式
- light：浅色模式
表示设备的屏幕密度（单位为dpi），取值如下：
- sdpi：表示小规模的屏幕密度（Small-scale Dots Per Inch），适用于dpi取值为(0, 120]的设备。
- mdpi：表示中规模的屏幕密度（Medium-scale Dots Per Inch），适用于dpi取值为(120, 160]的设备。
- ldpi：表示大规模的屏幕密度（Large-scale Dots Per Inch），适用于dpi取值为(160, 240]的设备。
- xldpi：表示特大规模的屏幕密度（Extra Large-scale Dots Per Inch），适用于dpi取值为(240, 320]的设备。
- xxldpi：表示超大规模的屏幕密度（Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(320, 480]的设备。
- xxxldpi：表示超特大规模的屏幕密度（Extra Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(480, 640]的设备。
rawfile目录
支持创建多层子目录，子目录名称可以自定义，文件夹内可以自由放置各类资源文件。
目录中的资源文件会被直接打包进应用，不经过编译，也不会被赋予资源文件ID。通过指定文件路径和文件名访问。
resfile目录
支持创建多层子目录，子目录名称可以自定义，文件夹内可以自由放置各类资源文件。
目录中的资源文件会被直接打包进应用，不经过编译，也不会被赋予资源文件ID。应用安装后，resfile资源会被解压到应用沙箱路径，通过Context属性resourceDir获取到resfile资源目录后，可通过文件路径访问，且该路径仅能以只读方式访问。
资源组目录
资源组目录包括element、media、profile三种类型的资源文件，用于存放特定类型资源。
表3 资源组目录说明
| 目录类型 | 说明 | 资源文件 |
| --- | --- | --- |
| element |  表示元素资源，以下每一类数据都采用相应的JSON文件来表征（目录下仅支持文件类型）。 - boolean，布尔型 - color，颜色 - float，浮点型，范围是-2^128-2^128 - intarray，整型数组 - integer，整型，范围是-2^31-2^31-1 - plural，复数形式 - strarray，字符串数组 - string，字符串，格式化字符串请参考API文档 |  element目录中的文件名称建议与下面的文件名保持一致。每个文件中只能包含同一类型的数据。 - boolean.json - color.json - float.json - intarray.json - integer.json - plural.json - strarray.json - string.json |
| media |  表示媒体资源，包括图片、音频、视频等非文本格式的文件（目录下只支持文件类型）。 图片和音视频的类型说明见表4和表5。 | 文件名可自定义，例如：icon.png。 |
| profile | 表示自定义配置文件，其文件内容可通过包管理接口获取（目录下只支持json文件类型）。 | 文件名可自定义，例如：test_profile.json。 |
表示元素资源，以下每一类数据都采用相应的JSON文件来表征（目录下仅支持文件类型）。
- boolean，布尔型
- color，颜色
- float，浮点型，范围是-2^128-2^128
- intarray，整型数组
- integer，整型，范围是-2^31-2^31-1
- plural，复数形式
- strarray，字符串数组
- string，字符串，格式化字符串请参考API文档
element目录中的文件名称建议与下面的文件名保持一致。每个文件中只能包含同一类型的数据。
- boolean.json
- color.json
- float.json
- intarray.json
- integer.json
- plural.json
- strarray.json
- string.json
表示媒体资源，包括图片、音频、视频等非文本格式的文件（目录下只支持文件类型）。
图片和音视频的类型说明见表4和表5。
媒体资源类型说明
表4 图片资源类型说明
| 格式 | 文件后缀名 |
| --- | --- |
| JPEG | .jpg |
| PNG | .png |
| GIF | .gif |
| SVG | .svg |
| WEBP | .webp |
| BMP | .bmp |
表5 音视频资源类型说明
| 格式 | 支持的文件类型 |
| --- | --- |
| H.264 AVC | .3gp |
| Baseline Profile (BP) | .mp4 |
资源文件示例
color.json文件的内容如下：
标准的十六进制颜色值由六位十六进制数字组成，下面的value值前两位表示透明度，后六位表示颜色值。
```json
{
"color": [
{
"name": "color_hello",
"value": "#ffff0000"
},
{
"name": "color_world",
"value": "#ff0000ff"
}
]
}
```
float.json文件的内容如下：
```json
{
"float": [
{
"name": "font_hello",
"value": "28.0fp"
},
{
"name": "font_world",
"value": "20.0fp"
}
]
}
```
string.json文件的内容如下：
```json
{
"string": [
{
"name": "string_hello",
"value": "Hello"
},
{
"name": "string_world",
"value": "World"
},
{
"name": "message_arrive",
"value": "We will arrive at %1$s."
},
{
"name": "message_notification",
"value": "Hello, %1$s!,You have %2$d new messages."
}
]
}
```
plural.json文件的内容如下：
```json
{
"plural": [
{
"name": "eat_apple",
"value": [
{
"quantity": "one",
"value": "%d apple"
},
{
"quantity": "other",
"value": "%d apples"
}
]
}
]
}
```
创建资源目录和资源文件
在resources目录下，可按照限定词目录命名规则，以及资源组目录支持的文件类型，创建资源目录和资源组目录，添加特定类型资源。DevEco Studio支持同时创建资源目录和资源文件，也支持单独创建资源目录或资源文件。
创建资源目录和资源文件
在resources目录右键菜单选择“New > Resource File”，可同时创建资源目录和资源文件，文件默认创建在base目录的对应资源组。如果选择了限定词，则会按照命名规范自动生成限定词和资源组目录，并将文件创建在限定词目录中。
图中File name为需要创建的文件名。Resource type为资源组类型，默认是element。Root Element为资源类型。Avaliable qualifiers为供选择的限定词目录，通过右边的小箭头可添加或者删除。
创建的目录名自动生成，格式固定为“限定词.资源组”，例如：创建一个限定词为dark的element目录，自动生成的目录名称为“dark/element”。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163451.64617117486265594345019011327963:50001231000000:2800:38351E645440E20ED50B164A01DE53CDD4BEA72553AF2815F44D1D9840969F32.png)
创建资源目录
在resources目录右键菜单选择“New > Resource Directory”，可创建资源目录，默认创建的是base目录。如果选择了限定词，则会按照命名规范自动生成限定词和资源组目录。确定限定词后，选择资源组类型，当前资源组类型支持Element、Media、Profile三种，创建后生成资源目录。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163451.91301902065063955341890876610999:50001231000000:2800:361D39347BD0FD5AD5299F5B351E5AF16D388AAC9F3CEC2175E6037DA83D5CBA.png)
创建资源文件
在资源组目录（element、media、profile）的右键菜单选择“New > XXX Resource File”，即可创建对应资源组目录的资源文件。例如，在element目录下可新建Element Resource File。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163451.71122387064749493863973782661534:50001231000000:2800:DDE66DFCCFF8384CDF433667F1D41B965EC109C6966198BCA7A3687E640AEC3D.png)
资源可翻译特性
功能介绍
当应用引用的字符串资源需要支持国际化多语言翻译时，可使用attr属性标记字符串翻译范围和翻译状态。attr属性不参与资源编译，只标记字符串是否翻译。
未配置attr属性，默认需要翻译。
attr支持属性
| 名称 | 类型 | 说明 |
| --- | --- | --- |
| translatable | boolean |  标记字符串是否需要翻译。 true：需要翻译。 false：不需要翻译。 |
| priority | string |  标记字符串翻译状态。 code：未翻译。 translate：翻译未验证。 LT：翻译已验证。 customer：用户定制字符串。 |
标记字符串是否需要翻译。
true：需要翻译。
false：不需要翻译。
标记字符串翻译状态。
code：未翻译。
translate：翻译未验证。
LT：翻译已验证。
customer：用户定制字符串。
使用约束
可翻译特性使能范围：base目录下string、strarray、plural类型资源。
示例
string资源配置attr属性示例如下，其中string1字符串被标记为不需要翻译，string2字符串被标记为需要翻译且翻译已验证。
```json
{
"string": [
{
"name": "string1",
"value": "1",
"attr": {
"translatable": false
}
},
{
"name": "string2",
"value": "Hello world!",
"attr": {
"translatable": true,
"priority": "LT"
}
}
]
}
```
资源访问
单HAP包应用资源
- 通过$r或$rawfile访问资源。对于color、float、string、plural、media、profile等类型的资源，通过$r('app.type.name')形式访问。其中，app为resources目录中定义的资源；type为资源类型；name为资源名，开发者定义资源时确定。对于string.json中使用多个占位符的情况，通过$r('app.string.label','aaa','bbb',444)形式访问。对于rawfile目录资源，通过"$rawfile('filename')"形式访问。其中，filename为rawfile目录下文件的相对路径，文件名需要包含后缀，路径开头不可以"/"开头。说明rawfile的native的访问方式请参考Rawfile开发指导。
资源组目录下的“资源文件示例”显示了.json文件内容，包含color.json文件、string.json文件和plural.json文件，访问应用资源时需先了解.json文件的使用规范。
资源的具体使用方法如下：
```typescript
//通过$r('app.type.name')访问
Text($r('app.string.string_hello'))
.fontColor($r('app.color.color_emphasize'))
.fontSize($r('app.float.text_size_headline1'))
.fontFamily($r('app.string.font_family_medium'))
.backgroundColor($r('app.color.color_palette_aux1'))
Image($r('app.media.app_icon'))
.border({
color: $r('app.color.color_palette_aux1'),
radius: $r('app.float.corner_radius_button'), width: 2
})
.margin({
top: $r('app.float.elements_margin_horizontal_m'),
bottom: $r('app.float.elements_margin_horizontal_l')
})
.height(200)
.width(300)
//对占位符，通过$r('app.string.label','aaa','bbb',444)访问
Text($r('app.string.message_notification','LiHua',2))
```
- 通过本应用上下文获取ResourceManager后，调用不同资源管理接口访问不同资源。例如：getContext().resourceManager.getStringByNameSync('test') 可获取字符串资源；getContext().resourceManager.getRawFd('rawfilepath') 可获取Rawfile所在hap包的descriptor信息，访问rawfile文件时需{fd, offset, length}一起使用。
跨HAP/HSP包应用资源
bundle相同，跨module访问
- 通过createModuleContext(context, moduleName)接口创建同应用中不同module的上下文，获取resourceManager对象后，调用不同资源管理接口访问不同资源。
- 通过"$r"或"$rawfile"访问资源。具体操作如下：1.在entry的oh-package.json5文件中添加依赖。如"dependencies": {"library":"file":../library}2.这里是列表文本[hsp].type.name获取资源。其中，hsp为hsp模块名，type为资源类型，name为资源名称，示例如下：
Text($r('[hsp].string.test_string')).fontSize($r('[hsp].float.font_size')).fontColor($r('[hsp].color.font_color'))Image($rawfile('[hsp].icon.png'))3.使用变量获取资源。示例如下：
@Entry@ComponentstructIndex{text:string='[hsp].string.test_string';fontSize:string='[hsp].float.font_size';fontColor:string='[hsp].color.font_color';image:string='[hsp].media.string';rawfile:string='[hsp].icon.png';build() {Row() {Text($r(this.text)).fontSize($r(this.fontSize)).fontColor($r(this.fontColor))Image($r(this.image))Image($rawfile(this.rawfile))}}}说明hsp包名必须写在[]内，rawfile下有多层目录，需要从rawfile下面第一个目录开始写，如"$rawfile('[hsp].oneFile/twoFile/icon.png')"，使用"$r"和"$rawfile"跨包访问HSP包资源无法提供编译时的资源校验，需要开发者自行保证使用资源存在于对应包中。
- Text($r('[hsp].string.test_string'))
- .fontSize($r('[hsp].float.font_size'))
- .fontColor($r('[hsp].color.font_color'))
- Image($rawfile('[hsp].icon.png'))
- @Entry
- @Component
- structIndex{
- text:string='[hsp].string.test_string';
- fontSize:string='[hsp].float.font_size';
- fontColor:string='[hsp].color.font_color';
- image:string='[hsp].media.string';
- rawfile:string='[hsp].icon.png';
- build() {
- Row() {
- Text($r(this.text))
- .fontSize($r(this.fontSize))
- .fontColor($r(this.fontColor))
- Image($r(this.image))
- Image($rawfile(this.rawfile))
- }
- }
- }
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250427163451.52506726072970118050948391804288:50001231000000:2800:440608A456299F0F2EE87430EE59F516D7BD0B207E8A65BDE8F888ABDA4CA684.png)
系统资源
开发者可以在应用UX设计关于资源的介绍，获取支持的色彩、字体等系统资源ID及其在不同配置下的取值；在主题图标库获取支持的图标资源，获取到图标资源后可通过SymbolGlyph对图标颜色等进一步设置。
对于系统资源，可以通过“$r('sys.type.resource_name')”的形式访问。其中，sys表示系统资源；type为资源类型，取值包括“color”、“float”、“string”、“media”、“symbol”；resource_name为资源名称。
- 仅声明式开发范式支持使用系统资源。
- 对于系统预置应用，建议使用系统资源；对于三方应用，可以根据需要选择使用系统资源或自定义应用资源。
- 当前，界面加载的系统资源字体进行显示时（可以在配置中system/etc/fontconfig.json文件中查看），默认使用的字体是鸿蒙黑体（HarmonyOS Sans），支持的范围是中文编码字符集GB18030-2022（级别一/级别二）。
```typescript
Text('Hello')
.fontColor($r('sys.color.ohos_id_color_emphasize'))
.fontSize($r('sys.float.ohos_id_text_size_headline1'))
.fontFamily($r('sys.string.ohos_id_text_font_family_medium'))
.backgroundColor($r('sys.color.ohos_id_color_palette_aux1'))
Image($r('sys.media.ohos_app_icon'))
.border({
color: $r('sys.color.ohos_id_color_palette_aux1'),
radius: $r('sys.float.ohos_id_corner_radius_button'), width: 2
})
.margin({
top: $r('sys.float.ohos_id_elements_margin_horizontal_m'),
bottom: $r('sys.float.ohos_id_elements_margin_horizontal_l')
})
.height(200)
.width(300)
```
资源匹配
应用使用某资源时，系统会根据当前设备状态优先从相匹配的限定词目录中寻找该资源。只有当resources目录中没有与设备状态匹配的限定词目录，或者在限定词目录中找不到该资源时，才会去base目录中查找。rawfile是原始文件目录，不会根据设备状态去匹配不同的资源。
限定词目录与设备状态的匹配规则
- 在为设备匹配对应的资源文件时，限定词目录匹配的优先级从高到低依次为：移动国家码和移动网络码 > 区域（可选组合：语言、语言_文字、语言_国家或地区、语言_文字_国家或地区）> 横竖屏 > 设备类型 > 颜色模式 > 屏幕密度。
- 如果限定词目录中包含移动国家码和移动网络码、语言、文字、横竖屏、设备类型、颜色模式限定词，则对应限定词的取值必须与当前的设备状态完全一致，该目录才能够参与设备的资源匹配。例如，限定词目录“zh_CN-car-ldpi”不能参与“en_US”设备的资源匹配。
- 如果存在多个屏幕密度限定词目录，则优先向上匹配最接近的屏幕密度限定词目录，否则向下匹配最为接近的屏幕密度限定词目录。例如，假设存在限定词目录“xldpi”和“xxldpi”，设备屏幕密度为“xxldpi”，则会匹配“xxldpi”限定词目录。
应用界面加载资源规则，更多请参考国际化和本地化文档。
获取指定配置的资源
基本概念
开发者可以在工程的resource目录下添加限定词目录，满足多语言、深浅色模式等不同类型的系统设置。然而，在获取资源时，由于限定词目录匹配规则，只能筛选出最匹配的资源，无法获取其它目录资源。
应用如果有获取指定配置的资源的诉求，可以通过以下方法进行获取。
接口说明
| 接口名 | 描述 |
| --- | --- |
| getOverrideResourceManager(configuration?: Configuration) : ResourceManager | 获取可以加载指定配置的资源的资源管理对象，使用同步方式返回。 |
| getOverrideConfiguration() : Configuration | 获取指定的配置，使用同步方式返回。 |
| updateOverrideConfiguration(configuration: Configuration) : void | 更新指定的配置。 |
示例
以获取非当前系统语言的资源为例，说明如何获取指定配置的资源，假设工程中中文、英文、德文的资源目录定义了如下同名资源：
- entry/src/main/resources/zh_CN/element/string.json
```json
{
"string": [
{
"name": "greetings",
"value": "你好，世界"
}
]
}
```
- entry/src/main/resources/en_US/element/string.json
```json
{
"string": [
{
"name": "greetings",
"value": "Hello, world"
}
]
}
```
- entry/src/main/resources/de_DE/element/string.json
```json
{
"string": [
{
"name": "greetings",
"value": "Hallo, Welt"
}
]
}
```
在Index.ets中，分别获取三种语言的资源并显示在文本框中，运行设备当前系统语言为中文，entry/src/main/ets/pages/Index.ets的代码如下：
```typescript
@Entry
@Component
struct Index {
@State englishString: string = ""
@State germanString: string = ""
getString(): string {
let resMgr = getContext().resourceManager
let resId = $r('app.string.greetings').id
//获取符合当前系统语言地区、颜色模式、分辨率等配置的资源
let currentLanguageString = resMgr.getStringSync(resId)
//获取符合当前系统颜色模式、分辨率等配置的英文资源
let overrideConfig = resMgr.getOverrideConfiguration()
overrideConfig.locale = "en_US" //指定资源的语言为英语，地区为美国
let overrideResMgr = resMgr.getOverrideResourceManager(overrideConfig)
this.englishString = overrideResMgr.getStringSync(resId)
//获取符合当前系统颜色模式、分辨率等配置的德文资源
overrideConfig.locale = "de_DE" //指定资源的语言为德语，地区为德国
overrideResMgr.updateOverrideConfiguration(overrideConfig) //等效于resMgr.updateOverrideConfiguration(overrideConfig)
this.germanString = overrideResMgr.getStringSync(resId)
return currentLanguageString
}
build() {
Row() {
Column() {
Text(this.getString())
.fontSize(50)
.fontWeight(FontWeight.Bold)
Text(this.englishString)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Text(this.germanString)
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
.width('100%')
}
.height('100%')
}
}
```
overlay机制
overlay是一种资源替换机制，针对不同品牌、产品的显示风格，开发者可以在不重新打包业务逻辑hap的情况下，通过配置和使用overlay资源包，实现应用界面风格变换。overlay资源包只包含资源文件、资源索引文件和配置文件。
- 动态overlay使用方式
1、对应的overlay资源包需要放在对应应用安装路径下，通过hdc install的方式安装。如应用com.example.overlay的安装路径：data/app/el1/bundle/public/com.example.overlay/。
2、应用通过addResource(path)，实现资源覆盖；通过removeResource(path)，实现overlay删除。overlay资源路径需经过元能力的getContext().bundleCodeDir获取此应用对应的沙箱根目录，由应用的沙箱根目录+overlay资源包名称组成。如：let path = getContext().bundleCodeDir + "overlay资源包名称"，其对应沙箱路径为：/data/storage/el1/bundle/overlay资源包名称。
- 静态overlay配置方式
包内overlay资源包中的配置文件app.json5中支持的字段：
包内overlay资源包中的配置文件module.json5中支持的字段：
- targetModuleName: 字符串类型，指定要overlay的应用中的目标module。
- targetPriority： 整数类型，指定overlay优先级。
- 不支持Ability、ExtensionAbility、Permission等其他字段的配置。
- overlay不支持json类型的图片配置。
在DevEco Studio中创建应用工程时，module的配置文件module.json5中包含targetModuleName和targetPriority字段时，该module将会在安装阶段被识别为overlay特征的module。overlay特征的module一般是为设备上存在的非overlay特征的module提供覆盖的资源文件，以便于targetModuleName指向的module在运行阶段可以使用overlay资源文件展示不同的颜色，标签，主题等等。
该功能默认使能，其使能及去使能请参考包管理接口。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/learning-arkts
爬取时间: 2025-04-27 21:44:00
来源: Huawei Developer
- 初识ArkTS语言
- ArkTS语言介绍
- ArkTS编程规范
- 从TypeScript到ArkTS的适配指导
- ArkTS高性能编程实践

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-get-started
爬取时间: 2025-04-27 21:44:14
来源: Huawei Developer
ArkTS是HarmonyOS优选的主力应用开发语言。ArkTS围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展，保持了TS的基本风格，同时通过规范定义强化开发期静态检查和分析，提升程序执行稳定性和性能。
从API version 10开始，ArkTS进一步通过规范强化静态检查和分析，对比标准TS的差异可以参考从TypeScript到ArkTS的适配规则：
- 强制使用静态类型：静态类型是ArkTS最重要的特性之一。如果使用静态类型，那么程序中变量的类型就是确定的。同时，由于所有类型在程序实际运行前都是已知的，编译器可以验证代码的正确性，从而减少运行时的类型检查，有助于性能提升。
- 禁止在运行时改变对象布局：为实现最大性能，ArkTS要求在程序执行期间不能更改对象布局。
- 限制运算符语义：为获得更好的性能并鼓励开发者编写更清晰的代码，ArkTS限制了一些运算符的语义。比如，一元加法运算符只能作用于数字，不能用于其他类型的变量。
- 不支持Structural typing：对Structural typing的支持需要在语言、编译器和运行时进行大量的考虑和仔细的实现，当前ArkTS不支持该特性。根据实际场景的需求和反馈，我们后续会重新考虑。
ArkTS兼容TS/JavaScript(简称JS)生态，开发者可以使用TS/JS进行开发或复用已有代码。HarmonyOS系统对TS/JS支持的详细情况参见兼容TS/JS的约束。
未来，ArkTS会结合应用开发/运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。
如需更详细了解ArkTS语言，可见ArkTS具体指南。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/introduction-to-arkts
爬取时间: 2025-04-27 21:44:28
来源: Huawei Developer
ArkTS是一种为构建高性能应用而设计的编程语言。ArkTS在继承TypeScript语法的基础上进行了优化，以提供更高的性能和开发效率。
随着移动设备在人们的日常生活中变得越来越普遍，许多编程语言在设计之初没有考虑到移动设备，导致应用的运行缓慢、低效、功耗大，针对移动环境的编程语言优化需求也越来越大。ArkTS是专为解决这些问题而设计的，聚焦于提高运行效率。
目前流行的编程语言TypeScript是在JavaScript基础上通过添加类型定义扩展而来的，而ArkTS则是TypeScript的进一步扩展。TypeScript深受开发者的喜爱，因为它提供了一种更结构化的JavaScript编码方法。ArkTS旨在保持TypeScript的大部分语法，为现有的TypeScript开发者实现无缝过渡，让移动开发者快速上手ArkTS。
ArkTS的一大特性是它专注于低运行时开销。ArkTS对TypeScript的动态类型特性施加了更严格的限制，以减少运行时开销，提高执行效率。通过取消动态类型特性，ArkTS代码能更有效地被运行前编译和优化，从而实现更快的应用启动和更低的功耗。
与JavaScript的互通性是ArkTS语言设计中的关键考虑因素。鉴于许多移动应用开发者希望重用其TypeScript和JavaScript代码和库，ArkTS提供了与JavaScript的无缝互通，使开发者可以很容易地将JavaScript代码集成到他们的应用中。这意味着开发者可以利用现有的代码和库进行ArkTS开发。
本教程将指导开发者了解ArkTS的核心功能、语法和最佳实践，使开发者能够使用ArkTS高效构建高性能的移动应用。
如需更详细了解ArkTS语言，可见ArkTS具体指南和DevEco Studio。
基本知识
声明
ArkTS通过声明引入变量、常量、函数和类型。
变量声明
以关键字let开头的声明引入变量，该变量在程序执行期间可以具有不同的值。
```typescript
let hi: string = 'hello';
hi = 'hello, world';
```
常量声明
以关键字const开头的声明引入只读常量，该常量只能被赋值一次。
```typescript
const hello: string = 'hello';
```
对常量重新赋值会造成编译时错误。
自动类型推断
由于ArkTS是一种静态类型语言，所有数据的类型都必须在编译时确定。
但是，如果一个变量或常量的声明包含了初始值，那么开发者就不需要显式指定其类型。ArkTS规范中列举了所有允许自动推断类型的场景。
以下示例中，两条声明语句都是有效的，两个变量都是string类型：
```typescript
let hi1: string = 'hello';
let hi2 = 'hello, world';
```
类型
基本类型和引用类型
基本数据类型包括number、string等简单类型，它们可以准确地表示单一的数据类型。基本类型确保数据在存储和访问时是直接的，比较时直接比较其值。
ArkTS中的引用类型如对象、数组和函数等，是通过引用访问的复杂数据结构。对象和数组可以包含多个值或键值对，函数则可以封装可执行的代码逻辑。引用类型在内存中通过指针访问数据，修改引用会影响原始数据。
number类型
ArkTS提供number类型，任何整数和浮点数都可以被赋给此类型的变量。
数字字面量包括整数字面量和十进制浮点数字面量。
整数字面量包括以下类别：
- 由数字序列组成的十进制整数。例如：0、117、-345
- 以0x（或0X）开头的十六进制整数，可以包含数字（0-9）和字母a-f或A-F。例如：0x1123、0x00111、-0xF1A7
- 以0o（或0O）开头的八进制整数，只能包含数字（0-7）。例如：0o777
- 以0b（或0B）开头的二进制整数，只能包含数字0和1。例如：0b11、0b0011、-0b11
浮点字面量包括以下：
- 十进制整数，可为有符号数（即，前缀为“+”或“-”）
- 小数点（“.”）
- 小数部分（由十进制数字字符串表示）
- 以“e”或“E”开头的指数部分，后跟有符号（即，前缀为“+”或“-”）或无符号整数
示例：
```typescript
let n1 = 3.14;
let n2 = 3.141592;
let n3 = .5;
let n4 = 1e2;
function factorial(n: number): number {
if (n <= 1) {
return 1;
}
return n * factorial(n - 1);
}
factorial(n1)  //  7.660344000000002
factorial(n2)  //  7.680640444893748
factorial(n3)  //  1
factorial(n4)  //  9.33262154439441e+157
```
number类型在表示大整数时会造成精度丢失。在开发时可以按需使用bigInt类型来确保精度：
```typescript
let bigIntger: BigInt = BigInt('999999999999999999999999999999999999999999999999999999999999');
console.log('bigIntger' + bigIntger.toString());
```
boolean类型
boolean类型由true和false两个逻辑值组成。
通常在条件语句中使用boolean类型的变量：
```typescript
let isDone: boolean = false;
// ...
if (isDone) {
console.log ('Done!');
}
```
string类型
string代表字符序列；可以使用转义字符来表示字符。
字符串字面量由单引号（'）或双引号（"）之间括起来的零个或多个字符组成。字符串字面量还有一特殊形式，是用反向单引号（`）括起来的模板字面量。
```typescript
let s1 = 'Hello, world!\n';
let s2 = "this is a string";
let a = 'Success';
let s3 = `The result is ${a}`;
```
void类型
void类型用于指定函数没有返回值。
此类型只有一个值，同样是void。由于void是引用类型，因此它可以用于泛型类型参数。
```typescript
class Class<T> {
//...
}
let instance: Class <void>
```
Object类型
Object类型是所有引用类型的基类型。任何值，包括基本类型的值（它们会被自动装箱），都可以直接被赋给Object类型的变量。object类型则用于表示除基本类型外的类型。
array类型
array，即数组，是由可赋值给数组声明中指定的元素类型的数据组成的对象。
数组可由数组复合字面量（即用方括号括起来的零个或多个表达式的列表，其中每个表达式为数组中的一个元素）来赋值。数组的长度由数组中元素的个数来确定。数组中第一个元素的索引为0。
以下示例将创建包含三个元素的数组：
```typescript
let names: string[] = ['Alice', 'Bob', 'Carol'];
```
enum类型
enum类型，又称枚举类型，是预先定义的一组命名值的值类型，其中命名值又称为枚举常量。
使用枚举常量时必须以枚举类型名称为前缀。
```typescript
enum ColorSet { Red, Green, Blue }
let c: ColorSet = ColorSet.Red;
```
常量表达式可以用于显式设置枚举常量的值。
```typescript
enum ColorSet { White = 0xFF, Grey = 0x7F, Black = 0x00 }
let c: ColorSet = ColorSet.Black;
```
Union类型
union类型，即联合类型，是由多个类型组合成的引用类型。联合类型包含了变量可能的所有类型。
```typescript
class Cat {
name: string = 'cat';
// ...
}
class Dog {
name: string = 'dog';
// ...
}
class Frog {
name: string = 'frog';
// ...
}
type Animal = Cat | Dog | Frog | number;
// Cat、Dog、Frog是一些类型（类或接口）
let animal: Animal = new Cat();
animal = new Frog();
animal = 42;
// 可以将类型为联合类型的变量赋值为任何组成类型的有效值
```
可以用不同的机制获取联合类型中特定类型的值。
示例：
```typescript
class Cat { sleep () {}; meow () {} }
class Dog { sleep () {}; bark () {} }
class Frog { sleep () {}; leap () {} }
type Animal = Cat | Dog | Frog;
function foo(animal: Animal) {
if (animal instanceof Frog) {
animal.leap();  // animal在这里是Frog类型
}
animal.sleep(); // Animal具有sleep方法
}
```
Aliases类型
Aliases类型为匿名类型（数组、函数、对象字面量或联合类型）提供名称，或为已有类型提供替代名称。
```typescript
type Matrix = number[][];
type Handler = (s: string, no: number) => string;
type Predicate <T> = (x: T) => boolean;
type NullableObject = Object | null;
```
运算符
赋值运算符
赋值运算符=，使用方式如x=y。
复合赋值运算符将赋值与运算符组合在一起，其中x op = y等于x = x op y。
复合赋值运算符列举如下：+=、-=、*=、/=、%=、<<=、>>=、>>>=、&=、|=、^=。
比较运算符
| 运算符 | 说明 |
| --- | --- |
| === | 如果两个操作数严格相等（对于不同类型的操作数认为是不相等的），则返回true。 |
| !== | 如果两个操作数严格不相等（对于不同类型的操作数认为是不相等的），则返回true。 |
| == | 如果两个操作数相等，则返回true。 |
| != | 如果两个操作数不相等，则返回true。 |
| > | 如果左操作数大于右操作数，则返回true。 |
| >= | 如果左操作数大于或等于右操作数，则返回true。 |
| < | 如果左操作数小于右操作数，则返回true。 |
| <= | 如果左操作数小于或等于右操作数，则返回true。 |
算术运算符
一元运算符为-、+、--、++。
二元运算符列举如下：
| 运算符 | 说明 |
| --- | --- |
| + | 加法 |
| - | 减法 |
| * | 乘法 |
| / | 除法 |
| % | 除法后余数 |
位运算符
| 运算符 | 说明 |
| --- | --- |
| a & b | 按位与：如果两个操作数的对应位都为1，则将这个位设置为1，否则设置为0。 |
| a | b | 按位或：如果两个操作数的相应位中至少有一个为1，则将这个位设置为1，否则设置为0。 |
| a ^ b | 按位异或：如果两个操作数的对应位不同，则将这个位设置为1，否则设置为0。 |
| ~ a | 按位非：反转操作数的位。 |
| a << b | 左移：将a的二进制表示向左移b位。 |
| a >> b | 算术右移：将a的二进制表示向右移b位，带符号扩展。 |
| a >>> b | 逻辑右移：将a的二进制表示向右移b位，左边补0。 |
逻辑运算符
| 运算符 | 说明 |
| --- | --- |
| a && b | 逻辑与 |
| a || b | 逻辑或 |
| ! a | 逻辑非 |
语句
If语句
if语句用于需要根据逻辑条件执行不同语句的场景。当逻辑条件为真时，执行对应的一组语句，否则执行另一组语句（如果有的话）。
else部分也可能包含if语句。
if语句如下所示：
```typescript
if (condition1) {
// 语句1
} else if (condition2) {
// 语句2
} else {
// else语句
}
```
条件表达式可以是任何类型。但是对于boolean以外的类型，会进行隐式类型转换：
```typescript
let s1 = 'Hello';
if (s1) {
console.log(s1); // 打印“Hello”
}
let s2 = 'World';
if (s2.length != 0) {
console.log(s2); // 打印“World”
}
```
Switch语句
使用switch语句来执行与switch表达式值匹配的代码块。
switch语句如下所示：
```typescript
switch (expression) {
case label1: // 如果label1匹配，则执行
// ...
// 语句1
// ...
break; // 可省略
case label2:
case label3: // 如果label2或label3匹配，则执行
// ...
// 语句23
// ...
break; // 可省略
default:
// 默认语句
}
```
如果switch表达式的值等于某个label的值，则执行相应的语句。
如果没有任何一个label值与表达式值相匹配，并且switch具有default子句，那么程序会执行default子句对应的代码块。
break语句（可选的）允许跳出switch语句并继续执行switch语句之后的语句。
如果没有break语句，则执行switch中的下一个label对应的代码块。
条件表达式
条件表达式由第一个表达式的布尔值来决定返回其它两个表达式中的哪一个。
示例如下：
```typescript
condition ? expression1 : expression2
```
如果condition的值为真值（转换后为true的值），则使用expression1作为该表达式的结果；否则，使用expression2。
示例：
```typescript
let message = Math.random() > 0.5 ? 'Valid' : 'Failed';
```
For语句
for语句会被重复执行，直到循环退出语句值为false。
for语句如下所示：
```typescript
for ([init]; [condition]; [update]) {
statements
}
```
for语句的执行流程如下：
1、 执行init表达式（如有）。此表达式通常初始化一个或多个循环计数器。
2、 计算condition。如果它为真值（转换后为true的值），则执行循环主体的语句。如果它为假值（转换后为false的值），则for循环终止。
3、 执行循环主体的语句。
4、 如果有update表达式，则执行该表达式。
5、 回到步骤2。
示例：
```typescript
let sum = 0;
for (let i = 0; i < 10; i += 2) {
sum += i;
}
```
For-of语句
使用for-of语句可遍历数组或字符串。示例如下：
```typescript
for (forVar of expression) {
statements
}
```
示例：
```typescript
for (let ch of 'a string object') {
/* process ch */
}
```
While语句
只要condition为真值（转换后为true的值），while语句就会执行statements语句。示例如下：
```typescript
while (condition) {
statements
}
```
示例：
```typescript
let n = 0;
let x = 0;
while (n < 3) {
n++;
x += n;
}
```
Do-while语句
如果condition的值为真值（转换后为true的值），那么statements语句会重复执行。示例如下：
```typescript
do {
statements
} while (condition)
```
示例：
```typescript
let i = 0;
do {
i += 1;
} while (i < 10)
```
Break语句
使用break语句可以终止循环语句或switch。
示例：
```typescript
let x = 0;
while (true) {
x++;
if (x > 5) {
break;
}
}
```
如果break语句后带有标识符，则将控制流转移到该标识符所包含的语句块之外。
示例：
```typescript
let x = 1;
label: while (true) {
switch (x) {
case 1:
// statements
break label; // 中断while语句
}
}
```
Continue语句
continue语句会停止当前循环迭代的执行，并将控制传递给下一个迭代。
示例：
```typescript
let sum = 0;
for (let x = 0; x < 100; x++) {
if (x % 2 == 0) {
continue;
}
sum += x;
}
```
Throw和Try语句
throw语句用于抛出异常或错误：
```typescript
throw new Error('this error')
```
try语句用于捕获和处理异常或错误：
```typescript
try {
// 可能发生异常的语句块
} catch (e) {
// 异常处理
}
```
下面的示例中throw和try语句用于处理除数为0的错误：
```typescript
class ZeroDivisor extends Error {}
function divide (a: number, b: number): number{
if (b == 0) throw new ZeroDivisor();
return a / b;
}
function process (a: number, b: number) {
try {
let res = divide(a, b);
console.log('result: ' + res);
} catch (x) {
console.log('some error');
}
}
```
支持finally语句：
```typescript
function processData(s: string) {
let error: Error | null = null;
try {
console.log('Data processed: ' + s);
// ...
// 可能发生异常的语句
// ...
} catch (e) {
error = e as Error;
// ...
// 异常处理
// ...
} finally {
if (error != null) {
console.log(`Error caught: input='${s}', message='${error.message}'`);
}
}
}
```
函数
函数声明
函数声明引入一个函数，包含其名称、参数列表、返回类型和函数体。
以下示例是一个简单的函数，包含两个string类型的参数，返回类型为string：
```typescript
function add(x: string, y: string): string {
let z: string = `${x} ${y}`;
return z;
}
```
在函数声明中，必须为每个参数标记类型。如果参数为可选参数，那么允许在调用函数时省略该参数。函数的最后一个参数可以是rest参数。
可选参数
可选参数的格式可为name?: Type。
```typescript
function hello(name?: string) {
if (name == undefined) {
console.log('Hello!');
} else {
console.log(`Hello, ${name}!`);
}
}
```
可选参数的另一种形式为设置的参数默认值。如果在函数调用中这个参数被省略了，则会使用此参数的默认值作为实参。
```typescript
function multiply(n: number, coeff: number = 2): number {
return n * coeff;
}
multiply(2);  // 返回2*2
multiply(2, 3); // 返回2*3
```
Rest参数
函数的最后一个参数可以是rest参数。rest参数的格式为...restArgs。rest参数允许函数接收一个由剩余实参组成的数组，用于处理不定数量的参数输入。
```typescript
function sum(...numbers: number[]): number {
let res = 0;
for (let n of numbers)
res += n;
return res;
}
sum(); // 返回0
sum(1, 2, 3); // 返回6
```
返回类型
如果可以从函数体内推断出函数返回类型，则可在函数声明中省略标注返回类型。
```typescript
// 显式指定返回类型
function foo(): string { return 'foo'; }
// 推断返回类型为string
function goo() { return 'goo'; }
```
不需要返回值的函数的返回类型可以显式指定为void或省略标注。这类函数不需要返回语句。
以下示例中两种函数声明方式都是有效的：
```typescript
function hi1() { console.log('hi'); }
function hi2(): void { console.log('hi'); }
```
函数的作用域
函数中定义的变量和其他实例仅可以在函数内部访问，不能从外部访问。
如果函数中定义的变量与外部作用域中已有实例同名，则函数内的局部变量定义将覆盖外部定义。
函数调用
调用函数以执行其函数体，实参值会赋值给函数的形参。
如果函数定义如下：
```typescript
function join(x: string, y: string): string {
let z: string = `${x} ${y}`;
return z;
}
```
则此函数的调用需要包含两个string类型的参数：
```typescript
let x = join('hello', 'world');
console.log(x);
```
函数类型
函数类型通常用于定义回调：
```typescript
type trigFunc = (x: number) => number // 这是一个函数类型
function do_action(f: trigFunc) {
f(3.141592653589); // 调用函数
}
do_action(Math.sin); // 将函数作为参数传入
```
箭头函数（又名Lambda函数）
函数可以定义为箭头函数，例如：
```typescript
let sum = (x: number, y: number): number => {
return x + y;
}
```
箭头函数的返回类型可以省略；省略时，返回类型通过函数体推断。
表达式可以指定为箭头函数，使表达更简短，因此以下两种表达方式是等价的：
```typescript
let sum1 = (x: number, y: number) => { return x + y; }
let sum2 = (x: number, y: number) => x + y
```
闭包
闭包是由函数及声明该函数的环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。
在下例中，f函数返回了一个闭包，它捕获了count变量，每次调用z，count的值会被保留并递增。
```typescript
function f(): () => number {
let count = 0;
let g = (): number => { count++; return count; };
return g;
}
let z = f();
z(); // 返回：1
z(); // 返回：2
```
函数重载
我们可以通过编写重载，指定函数的不同调用方式。具体方法为，为同一个函数写入多个同名但签名不同的函数头，函数实现紧随其后。
```typescript
function foo(x: number): void;            /* 第一个函数定义 */
function foo(x: string): void;            /* 第二个函数定义 */
function foo(x: number | string): void {  /* 函数实现 */
}
foo(123);     //  OK，使用第一个定义
foo('aa'); // OK，使用第二个定义
```
不允许重载函数有相同的名字以及参数列表，否则将会编译报错。
类
类声明引入一个新类型，并定义其字段、方法和构造函数。
在以下示例中，定义了Person类，该类具有字段name和surname、构造函数和方法fullName：
```typescript
class Person {
name: string = '';
surname: string = '';
constructor (n: string, sn: string) {
this.name = n;
this.surname = sn;
}
fullName(): string {
return this.name + ' ' + this.surname;
}
}
```
定义类后，可以使用关键字new创建实例：
```typescript
let p = new Person('John', 'Smith');
console.log(p.fullName());
```
或者，可以使用对象字面量创建实例：
```typescript
class Point {
x: number = 0;
y: number = 0;
}
let p: Point = {x: 42, y: 42};
```
字段
字段是直接在类中声明的某种类型的变量。
类可以具有实例字段或者静态字段。
实例字段
实例字段存在于类的每个实例上。每个实例都有自己的实例字段集合。
要访问实例字段，需要使用类的实例。
```typescript
class Person {
name: string = '';
age: number = 0;
constructor(n: string, a: number) {
this.name = n;
this.age = a;
}
getName(): string {
return this.name;
}
}
let p1 = new Person('Alice', 25);
p1.name;
let p2 = new Person('Bob', 28);
p2.getName();
```
静态字段
使用关键字static将字段声明为静态。静态字段属于类本身，类的所有实例共享一个静态字段。
要访问静态字段，需要使用类名：
```typescript
class Person {
static numberOfPersons = 0;
constructor() {
// ...
Person.numberOfPersons++;
// ...
}
}
Person.numberOfPersons;
```
字段初始化
为了减少运行时的错误和获得更好的执行性能，
ArkTS要求所有字段在声明时或者构造函数中显式初始化。这和标准TS中的strictPropertyInitialization模式一样。
以下代码是在ArkTS中不合法的代码。
```typescript
class Person {
name: string; // undefined
setName(n:string): void {
this.name = n;
}
getName(): string {
// 开发者使用"string"作为返回类型，这隐藏了name可能为"undefined"的事实。
// 更合适的做法是将返回类型标注为"string | undefined"，以告诉开发者这个API所有可能的返回值。
return this.name;
}
}
let jack = new Person();
// 假设代码中没有对name赋值，例如调用"jack.setName('Jack')"
jack.getName().length; // 运行时异常：name is undefined
```
在ArkTS中，应该这样写代码。
```typescript
class Person {
name: string = '';
setName(n:string): void {
this.name = n;
}
// 类型为'string'，不可能为"null"或者"undefined"
getName(): string {
return this.name;
}
}
let jack = new Person();
// 假设代码中没有对name赋值，例如调用"jack.setName('Jack')"
jack.getName().length; // 0, 没有运行时异常
```
接下来的代码展示了如果name的值可以是undefined，那么应该如何写代码。
```typescript
class Person {
name?: string; // 可能为`undefined`
setName(n:string): void {
this.name = n;
}
// 编译时错误：name可以是"undefined"，所以这个API的返回值类型不能仅定义为string类型
getNameWrong(): string {
return this.name;
}
getName(): string | undefined { // 返回类型匹配name的类型
return this.name;
}
}
let jack = new Person();
// 假设代码中没有对name赋值，例如调用"jack.setName('Jack')"
// 编译时错误：编译器认为下一行代码有可能会访问undefined的属性，报错
jack.getName().length;  // 编译失败
jack.getName()?.length; // 编译成功，没有运行时错误
```
getter和setter
setter和getter可用于提供对对象属性的受控访问。
在以下示例中，setter用于禁止将_age属性设置为无效值：
```typescript
class Person {
name: string = '';
private _age: number = 0;
get age(): number { return this._age; }
set age(x: number) {
if (x < 0) {
throw Error('Invalid age argument');
}
this._age = x;
}
}
let p = new Person();
p.age; // 输出0
p.age = -42; // 设置无效age值会抛出错误
```
在类中可以定义getter或者setter。
方法
方法属于类。类可以定义实例方法或者静态方法。静态方法属于类本身，只能访问静态字段。而实例方法既可以访问静态字段，也可以访问实例字段，包括类的私有字段。
实例方法
以下示例说明了实例方法的工作原理。
calculateArea方法通过将高度乘以宽度来计算矩形的面积：
```typescript
class RectangleSize {
private height: number = 0;
private width: number = 0;
constructor(height: number, width: number) {
this.height = height;
this.width = width;
}
calculateArea(): number {
return this.height * this.width;
}
}
```
必须通过类的实例调用实例方法：
```typescript
let square = new RectangleSize(10, 10);
square.calculateArea(); // 输出：100
```
静态方法
使用关键字static将方法声明为静态。静态方法属于类本身，只能访问静态字段。
静态方法定义了类作为一个整体的公共行为。
必须通过类名调用静态方法：
```typescript
class Cl {
static staticMethod(): string {
return 'this is a static method.';
}
}
console.log(Cl.staticMethod());
```
继承
一个类可以继承另一个类（称为基类），并使用以下语法实现多个接口：
```typescript
class [extends BaseClassName] [implements listOfInterfaces] {
// ...
}
```
继承类继承基类的字段和方法，但不继承构造函数。继承类可以新增定义字段和方法，也可以覆盖其基类定义的方法。
基类也称为“父类”或“超类”。继承类也称为“派生类”或“子类”。
示例：
```typescript
class Person {
name: string = '';
private _age = 0;
get age(): number {
return this._age;
}
}
class Employee extends Person {
salary: number = 0;
calculateTaxes(): number {
return this.salary * 0.42;
}
}
```
包含implements子句的类必须实现列出的接口中定义的所有方法，但使用默认实现定义的方法除外。
```typescript
interface DateInterface {
now(): string;
}
class MyDate implements DateInterface {
now(): string {
// 在此实现
return 'now';
}
}
```
父类访问
关键字super可用于访问父类的实例字段、实例方法和构造函数。在实现子类功能时，可以通过该关键字从父类中获取所需接口：
```typescript
class RectangleSize {
protected height: number = 0;
protected width: number = 0;
constructor (h: number, w: number) {
this.height = h;
this.width = w;
}
draw() {
/* 绘制边界 */
}
}
class FilledRectangle extends RectangleSize {
color = ''
constructor (h: number, w: number, c: string) {
super(h, w); // 父类构造函数的调用
this.color = c;
}
draw() {
super.draw(); // 父类方法的调用
// super.height -可在此处使用
/* 填充矩形 */
}
}
```
方法重写
子类可以重写其父类中定义的方法的实现。重写的方法必须具有与原始方法相同的参数类型和相同或派生的返回类型。
```typescript
class RectangleSize {
// ...
area(): number {
// 实现
return 0;
}
}
class Square extends RectangleSize {
private side: number = 0;
area(): number {
return this.side * this.side;
}
}
```
方法重载签名
通过重载签名，指定方法的不同调用。具体方法为，为同一个方法写入多个同名但签名不同的方法头，方法实现紧随其后。
```typescript
class C {
foo(x: number): void;            /* 第一个签名 */
foo(x: string): void;            /* 第二个签名 */
foo(x: number | string): void {  /* 实现签名 */
}
}
let c = new C();
c.foo(123);     // OK，使用第一个签名
c.foo('aa'); // OK，使用第二个签名
```
如果两个重载签名的名称和参数列表均相同，则为错误。
构造函数
类声明可以包含用于初始化对象状态的构造函数。
构造函数定义如下：
```typescript
constructor ([parameters]) {
// ...
}
```
如果未定义构造函数，则会自动创建具有空参数列表的默认构造函数，例如：
```typescript
class Point {
x: number = 0;
y: number = 0;
}
let p = new Point();
```
在这种情况下，默认构造函数使用字段类型的默认值来初始化实例中的字段。
派生类的构造函数
构造函数函数体的第一条语句可以使用关键字super来显式调用直接父类的构造函数。
```typescript
class RectangleSize {
constructor(width: number, height: number) {
// ...
}
}
class Square extends RectangleSize {
constructor(side: number) {
super(side, side);
}
}
```
构造函数重载签名
我们可以通过编写重载签名，指定构造函数的不同调用方式。具体方法为，为同一个构造函数写入多个同名但签名不同的构造函数头，构造函数实现紧随其后。
```typescript
class C {
constructor(x: number)             /* 第一个签名 */
constructor(x: string)             /* 第二个签名 */
constructor(x: number | string) {  /* 实现签名 */
}
}
let c1 = new C(123);      // OK，使用第一个签名
let c2 = new C('abc');    // OK，使用第二个签名
```
如果两个重载签名的名称和参数列表均相同，则为错误。
可见性修饰符
类的方法和属性都可以使用可见性修饰符。
可见性修饰符包括：private、protected和public。默认可见性为public。
Public（公有）
public修饰的类成员（字段、方法、构造函数）在程序的任何可访问该类的地方都是可见的。
Private（私有）
private修饰的成员不能在声明该成员的类之外访问，例如：
```typescript
class C {
public x: string = '';
private y: string = '';
set_y (new_y: string) {
this.y = new_y; // OK，因为y在类本身中可以访问
}
}
let c = new C();
c.x = 'a'; // OK，该字段是公有的
c.y = 'b'; // 编译时错误：'y'不可见
```
Protected（受保护）
protected修饰符的作用与private修饰符非常相似，不同点是protected修饰的成员允许在派生类中访问，例如：
```typescript
class Base {
protected x: string = '';
private y: string = '';
}
class Derived extends Base {
foo() {
this.x = 'a'; // OK，访问受保护成员
this.y = 'b'; // 编译时错误，'y'不可见，因为它是私有的
}
}
```
对象字面量
对象字面量是一个表达式，可用于创建类实例并提供一些初始值。它在某些情况下更方便，可以用来代替new表达式。
对象字面量的表示方式是：封闭在花括号对({})中的'属性名：值'的列表。
```typescript
class C {
n: number = 0;
s: string = '';
}
let c: C = {n: 42, s: 'foo'};
```
ArkTS是静态类型语言，如上述示例所示，对象字面量只能在可以推导出该字面量类型的上下文中使用。其他正确的例子：
```typescript
class C {
n: number = 0;
s: string = '';
}
function foo(c: C) {}
let c: C
c = {n: 42, s: 'foo'};  // 使用变量的类型
foo({n: 42, s: 'foo'}); // 使用参数的类型
function bar(): C {
return {n: 42, s: 'foo'}; // 使用返回类型
}
```
也可以在数组元素类型或类字段类型中使用：
```typescript
class C {
n: number = 0;
s: string = '';
}
let cc: C[] = [{n: 1, s: 'a'}, {n: 2, s: 'b'}];
```
Record类型的对象字面量
泛型Record<K, V>用于将类型（键类型）的属性映射到另一个类型（值类型）。常用对象字面量来初始化该类型的值：
```typescript
let map: Record<string, number> = {
'John': 25,
'Mary': 21,
}
map['John']; // 25
```
类型K可以是字符串类型或数值类型，而V可以是任何类型。
```typescript
interface PersonInfo {
age: number;
salary: number;
}
let map: Record<string, PersonInfo> = {
'John': { age: 25, salary: 10},
'Mary': { age: 21, salary: 20}
}
```
抽象类
带有修饰符abstract的类称为抽象类。抽象类可用于表示一组更具体的概念所共有的概念。
如果尝试创建抽象类的实例，则会发生编译时的错误：
```typescript
abstract class X {
field: number;
constructor(p: number) {
this.field = p;
}
}
let x = new X(666)  //编译时错误：不能创建抽象类的具体实例
```
抽象类的子类可以是抽象类也可以是非抽象类。抽象父类的非抽象子类可以实例化。因此，执行抽象类的构造函数和该类非静态字段的字段初始化器：
```typescript
abstract class Base {
field: number;
constructor(p: number) {
this.field = p;
}
}
class Derived extends Base {
constructor(p: number) {
super(p);
}
}
```
抽象方法
带有abstract修饰符的方法称为抽象方法，抽象方法可以被声明但不能被实现。
只有抽象类内才能有抽象方法，如果非抽象类具有抽象方法，则会发生编译时错误：
```typescript
class Y {
abstract method(p: string)  //编译时错误：抽象方法只能在抽象类内。
}
```
接口
接口声明引入新类型。接口是定义代码协定的常见方式。
任何一个类的实例只要实现了特定接口，就可以通过该接口实现多态。
接口通常包含属性和方法的声明
示例：
```typescript
interface Style {
color: string; // 属性
}
interface AreaSize {
calculateAreaSize(): number; // 方法的声明
someMethod(): void;     // 方法的声明
}
```
实现接口的类示例：
```typescript
// 接口：
interface AreaSize {
calculateAreaSize(): number; // 方法的声明
someMethod(): void;     // 方法的声明
}
// 实现：
class RectangleSize implements AreaSize {
private width: number = 0;
private height: number = 0;
someMethod(): void {
console.log('someMethod called');
}
calculateAreaSize(): number {
this.someMethod(); // 调用另一个方法并返回结果
return this.width * this.height;
}
}
```
接口属性
接口属性可以是字段、getter、setter或getter和setter组合的形式。
属性字段只是getter/setter对的便捷写法。以下表达方式是等价的：
```typescript
interface Style {
color: string;
}
```
```typescript
interface Style {
get color(): string;
set color(x: string);
}
```
实现接口的类也可以使用以下两种方式：
```typescript
interface Style {
color: string;
}
class StyledRectangle implements Style {
color: string = '';
}
```
```typescript
interface Style {
color: string;
}
class StyledRectangle implements Style {
private _color: string = '';
get color(): string { return this._color; }
set color(x: string) { this._color = x; }
}
```
接口继承
接口可以继承其他接口，如下面的示例所示：
```typescript
interface Style {
color: string;
}
interface ExtendedStyle extends Style {
width: number;
}
```
继承接口包含被继承接口的所有属性和方法，还可以添加自己的属性和方法。
抽象类和接口
抽象类与接口都无法实例化。抽象类是类的抽象，抽象类用来捕捉子类的通用特性，接口是行为的抽象。在ArkTS中抽象类与接口的区别如下：
- 一个类只能继承一个抽象类，而一个类可以实现一个或多个接口；
- 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
- 抽象类里面可以有方法的实现，但是接口完全都是抽象的，不存在方法的实现；
- 抽象类可以有构造函数，而接口不能有构造函数。
泛型类型和函数
泛型类型和函数允许创建的代码在各种类型上运行，而不仅支持单一类型。
泛型类和接口
类和接口可以定义为泛型，将参数添加到类型定义中，如以下示例中的类型参数Element：
```typescript
class CustomStack<Element> {
public push(e: Element):void {
// ...
}
}
```
要使用类型CustomStack，必须为每个类型参数指定类型实参：
```typescript
let s = new CustomStack<string>();
s.push('hello');
```
编译器在使用泛型类型和函数时会确保类型安全。参见以下示例：
```typescript
let s = new CustomStack<string>();
s.push(55); // 将会产生编译时错误
```
泛型约束
泛型类型的类型参数可以被限制只能取某些特定的值。例如，MyHashMap<Key, Value>这个类中的Key类型参数必须具有hash方法。
```typescript
interface Hashable {
hash(): number;
}
class MyHashMap<Key extends Hashable, Value> {
public set(k: Key, v: Value) {
let h = k.hash();
// ...其他代码...
}
}
```
在上面的例子中，Key类型扩展了Hashable，Hashable接口的所有方法都可以为key调用。
泛型函数
使用泛型函数可编写更通用的代码。比如返回数组最后一个元素的函数：
```typescript
function last(x: number[]): number {
return x[x.length - 1];
}
last([1, 2, 3]); // 3
```
如果需要为任何数组定义相同的函数，使用类型参数将该函数定义为泛型：
```typescript
function last<T>(x: T[]): T {
return x[x.length - 1];
}
```
现在，该函数可以与任何数组一起使用。
在函数调用中，类型实参可以显式或隐式设置：
```typescript
// 显式设置的类型实参
last<string>(['aa', 'bb']);
last<number>([1, 2, 3]);
// 隐式设置的类型实参
// 编译器根据调用参数的类型来确定类型实参
last([1, 2, 3]);
```
泛型默认值
泛型类型的类型参数可以设置默认值。这样可以不指定实际的类型实参，而只使用泛型类型名称。下面的示例展示了类和函数的这一点。
```typescript
class SomeType {}
interface Interface <T1 = SomeType> { }
class Base <T2 = SomeType> { }
class Derived1 extends Base implements Interface { }
// Derived1在语义上等价于Derived2
class Derived2 extends Base<SomeType> implements Interface<SomeType> { }
function foo<T = number>(): T {
// ...
}
foo();
// 此函数在语义上等价于下面的调用
foo<number>();
```
空安全
默认情况下，ArkTS中的所有类型都是不可为空的，因此类型的值不能为空。这类似于TypeScript的严格空值检查模式（strictNullChecks），但规则更严格。
在下面的示例中，所有行都会导致编译时错误：
```typescript
let x: number = null;    // 编译时错误
let y: string = null;    // 编译时错误
let z: number[] = null;  // 编译时错误
```
可以为空值的变量定义为联合类型T | null。
```typescript
let x: number | null = null;
x = 1;    // ok
x = null; // ok
if (x != null) { /* do something */ }
```
非空断言运算符
后缀运算符!可用于断言其操作数为非空。
应用于可空类型的值时，它的编译时类型变为非空类型。例如，类型将从T | null更改为T：
```typescript
class A {
value: number = 0;
}
function foo(a: A | null) {
a.value;   // 编译时错误：无法访问可空值的属性
a!.value;  // 编译通过，如果运行时a的值非空，可以访问到a的属性；如果运行时a的值为空，则发生运行时异常
}
```
空值合并运算符
空值合并二元运算符??用于检查左侧表达式的求值是否等于null或者undefined。如果是，则表达式的结果为右侧表达式；否则，结果为左侧表达式。
换句话说，a ?? b等价于三元运算符(a != null && a != undefined) ? a : b。
在以下示例中，getNick方法如果设置了昵称，则返回昵称；否则，返回空字符串：
```typescript
class Person {
// ...
nick: string | null = null;
getNick(): string {
return this.nick ?? '';
}
}
```
可选链
在访问对象属性时，如果该属性是undefined或者null，可选链运算符会返回undefined。
```typescript
class Person {
nick: string | null = null;
spouse?: Person
setSpouse(spouse: Person): void {
this.spouse = spouse;
}
getSpouseNick(): string | null | undefined {
return this.spouse?.nick;
}
constructor(nick: string) {
this.nick = nick;
this.spouse = undefined;
}
}
```
说明：getSpouseNick的返回类型必须为string | null | undefined，因为该方法可能返回null或者undefined。
可选链可以任意长，可以包含任意数量的?.运算符。
在以下示例中，如果一个Person的实例有不为空的spouse属性，且spouse有不为空的nick属性，则输出spouse.nick。否则，输出undefined：
```typescript
class Person {
nick: string | null = null;
spouse?: Person;
constructor(nick: string) {
this.nick = nick;
this.spouse = undefined;
}
}
let p: Person = new Person('Alice');
p.spouse?.nick; // undefined
```
模块
程序可划分为多组编译单元或模块。
每个模块都有其自己的作用域，即，在模块中创建的任何声明（变量、函数、类等）在该模块之外都不可见，除非它们被显式导出。
与此相对，从另一个模块导出的变量、函数、类、接口等必须首先导入到模块中。
导出
可以使用关键字export导出顶层的声明。
未导出的声明名称被视为私有名称，只能在声明该名称的模块中使用。
```typescript
export class Point {
x: number = 0;
y: number = 0;
constructor(x: number, y: number) {
this.x = x;
this.y = y;
}
}
export let Origin = new Point(0, 0);
export function Distance(p1: Point, p2: Point): number {
return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
}
```
导入
静态导入
导入声明用于导入从其他模块导出的实体，并在当前模块中提供其绑定。导入声明由两部分组成：
- 导入路径，用于指定导入的模块；
- 导入绑定，用于定义导入的模块中的可用实体集和使用形式（限定或不限定使用）。
导入绑定可以有几种形式。
假设模块具有路径“./utils”和导出实体“X”和“Y”。
导入绑定* as A表示绑定名称“A”，通过A.name可访问从导入路径指定的模块导出的所有实体：
```typescript
import * as Utils from './utils';
Utils.X // 表示来自Utils的X
Utils.Y // 表示来自Utils的Y
```
导入绑定{ ident1, ..., identN }表示将导出的实体与指定名称绑定，该名称可以用作简单名称：
```typescript
import { X, Y } from './utils';
X // 表示来自utils的X
Y // 表示来自utils的Y
```
如果标识符列表定义了ident as alias，则实体ident将绑定在名称alias下：
```typescript
import { X as Z, Y } from './utils';
Z // 表示来自Utils的X
Y // 表示来自Utils的Y
X // 编译时错误：'X'不可见
```
动态导入
应用开发的有些场景中，如果希望根据条件导入模块或者按需导入模块，可以使用动态导入代替静态导入。
import()语法通常称为动态导入（dynamic import），是一种类似函数的表达式，用来动态导入模块。以这种方式调用，将返回一个promise。
如下例所示，import(modulePath)可以加载模块并返回一个promise，该promise resolve为一个包含其所有导出的模块对象。该表达式可以在代码中的任意位置调用。
```typescript
// Calc.ts
export function add(a:number, b:number):number {
let c = a + b;
console.info('Dynamic import, %d + %d = %d', a, b, c);
return c;
}
// Index.ts
import("./Calc").then((obj: ESObject) => {
console.info(obj.add(3, 5));
}).catch((err: Error) => {
console.error("Module dynamic import error: ", err);
});
```
如果在异步函数中，可以使用let module = await import(modulePath)。
```typescript
// say.ts
export function hi() {
console.log('Hello');
}
export function bye() {
console.log('Bye');
}
```
那么，可以像下面这样进行动态导入：
```typescript
async function test() {
let ns = await import('./say');
let hi = ns.hi;
let bye = ns.bye;
hi();
bye();
}
```
更多的使用动态import的业务场景和使用实例见动态import。
导入HarmonyOS SDK的开放能力
HarmonyOS SDK提供的开放能力（接口）也需要在导入声明后使用。可直接导入接口模块来使用该模块内的所有接口能力，例如：
```typescript
import UIAbility from '@ohos.app.ability.UIAbility';
```
从HarmonyOS NEXT Developer Preview 1版本开始引入Kit概念。SDK对同一个Kit下的接口模块进行了封装，开发者在示例代码中可通过导入Kit的方式来使用Kit所包含的接口能力。其中，Kit封装的接口模块可查看SDK目录下Kit子目录中各Kit的定义。
通过导入Kit方式使用开放能力有三种方式：
- 方式一：导入Kit下单个模块的接口能力。例如：
import{UIAbility}from'@kit.AbilityKit';
- import{UIAbility}from'@kit.AbilityKit';
- 方式二：导入Kit下多个模块的接口能力。例如：
import{UIAbility,Ability,Context}from'@kit.AbilityKit';
- import{UIAbility,Ability,Context}from'@kit.AbilityKit';
- 方式三：导入Kit包含的所有模块的接口能力。例如：
import*asmodulefrom'@kit.AbilityKit';其中，“module”为别名，可自定义，然后通过该名称调用模块的接口。说明方式三可能会导入过多无需使用的模块，导致编译后的HAP包太大，占用过多资源，请谨慎使用。
- import*asmodulefrom'@kit.AbilityKit';
顶层语句
顶层语句是指在模块的最外层直接编写的语句，这些语句不被包裹在任何函数、类、块级作用域中。顶层语句包括变量声明、函数声明、表达式等。
关键字
this
关键字this只能在类的实例方法中使用。
示例
```typescript
class A {
count: string = 'a';
m(i: string): void {
this.count = i;
}
}
```
使用限制：
- 不支持this类型
- 不支持在函数和类的静态方法中使用this
示例
```typescript
class A {
n: number = 0;
f1(arg1: this) {} // 编译时错误，不支持this类型
static f2(arg1: number) {
this.n = arg1;  // 编译时错误，不支持在类的静态方法中使用this
}
}
function foo(arg1: number) {
this.n = i;       // 编译时错误，不支持在函数中使用this
}
```
关键字this的指向:
- 调用实例方法的对象
- 正在构造的对象

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-coding-style-guide
爬取时间: 2025-04-27 21:44:42
来源: Huawei Developer
目标和适用范围
本文参考业界标准及实践，结合ArkTS语言特点，为提高代码的规范、安全、性能提供编码指南。
本文适用于开发者进行系统开发或者应用开发时，使用ArkTS编写代码的场景。
规则来源
ArkTS在保持TypeScript基本语法风格的基础上，进一步强化静态检查和分析。本文部分规则筛选自《OpenHarmony应用TS&JS编程指南》，为ArkTS语言新增的语法添加了规则，旨在提高代码可读性、执行性能。
章节概览
代码风格
包含命名和格式。
编程实践
包含声明与初始化、数据类型、运算与表达式、异常等。
参考了《OpenHarmony应用TS&JS编程指南》中的规则，对其中ArkTS语言不涉及的部分作了去除，为ArkTS语言新增的语法添加了规则。
术语和定义
| 术语 | 缩略语 | 中文解释 |
| --- | --- | --- |
| ArkTS | 无 | ArkTS编程语言 |
| TypeScript | TS | TypeScript编程语言 |
| JavaScript | JS | JavaScript编程语言 |
| ESObject | 无 | 在ArkTS跨语言调用的场景中，用以标注JS/TS对象的类型 |
总体原则
规则分为两个级别：要求、建议。
要求：表示原则上应该遵从。本文所有内容目前均为针对ArkTS的要求。
建议：表示该条款属于最佳实践，可结合实际情况考虑是否纳入。
命名
为标识符取一个好名字，提高代码可读性
【描述】
好的标识符命名，应遵循以下基本原则：
- 能清晰的表达意图，避免使用单个字母、未成惯例的缩写来命名
- 使用正确的英文单词并符合英文语法，不要使用中文拼音
- 能区分出意思，避免造成误导
类名、枚举名、命名空间名采用UpperCamelCase风格
【级别】建议
【描述】
类采用首字母大写的驼峰命名法。
类名通常是名词或名词短语，例如Person、Student、Worker。不应使用动词，也应该避免类似Data、Info这样的模糊词。
【正例】
```typescript
// 类名
class User {
username: string
constructor(username: string) {
this.username = username;
}
sayHi() {
console.log('hi' + this.username);
}
}
// 枚举名
enum UserType {
TEACHER = 0,
STUDENT = 1
};
// 命名空间
namespace Base64Utils {
function encrypt() {
// todo encrypt
}
function decrypt() {
// todo decrypt
}
};
```
变量名、方法名、参数名采用lowerCamelCase风格
【级别】建议
【描述】
函数的命名通常是动词或动词短语，采用小驼峰命名，示例如下：
1.  动词 + 宾语() 变量的名字通常是名词或名词短语，应采用小驼峰命名，以便于理解其含义。
【正例】
常量名、枚举值名采用全部大写，单词间使用下划线隔开
【级别】建议
【描述】
常量命名，应该由全大写单词与下划线组成，单词间用下划线分割。常量命名要尽量表达完整的语义。
【正例】
避免使用否定的布尔变量名，布尔型的局部变量或方法需加上表达是非意义的前缀
【级别】建议
【描述】
布尔型的局部变量建议加上表达是非意义的前缀，比如is，也可以是has、can、should等。但是，当使用逻辑非运算符，并出现双重否定时，会出现理解问题，比如!isNotError，意味着什么，不是很好理解。因此，应避免定义否定的布尔变量名。
【反例】
【正例】
格式
使用空格缩进，禁止使用tab字符
【级别】建议
【描述】
只允许使用空格(space)进行缩进。
建议大部分场景优先使用2个空格，换行导致的缩进优先使用4个空格。
不允许插入制表符Tab。当前几乎所有的集成开发环境（IDE）和代码编辑器都支持配置将Tab键自动扩展为2个空格输入，应在代码编辑器中配置使用空格进行缩进。
【正例】
行宽不超过120个字符
【级别】建议
【描述】
代码行宽不宜过长，否则不利于阅读。
控制行宽可以间接的引导程序员去缩短函数、变量的命名，减少嵌套的层数，精炼注释，提升代码可读性。
建议每行字符数不要超过120个；除非超过120能显著增加可读性，并且不会隐藏信息。
例外：如果一行注释包含了超过120个字符的命令或URL，则可以保持一行，以方便复制、粘贴和通过grep查找；预处理的error信息在一行便于阅读和理解，即使超过120个字符。
条件语句和循环语句的实现必须使用大括号
【级别】建议
【描述】
在if、for、do、while等语句的执行体加大括号{}是一种最佳实践，因为省略大括号容易导致错误，并且降低代码的清晰度。
【反例】
【正例】
switch语句的case和default需缩进一层
【级别】建议
【描述】
switch的case和default要缩进一层（2个空格）。开关标签之后换行的语句，需再缩进一层（2个空格）。
【正例】
表达式换行需保持一致性，运算符放行末
【级别】建议
【描述】
当语句过长，或者可读性不佳时，需要在合适的地方换行。
换行时将操作符放在行末，表示“未结束，后续还有”，保持与常用的格式化工具的默认配置一致。
【正例】
多个变量定义和赋值语句不允许写在一行
【级别】要求
【描述】
每个语句的变量声明都应只声明一个变量。
这种方式更易添加变量声明，不用考虑将;变成,，以免引入错误。另外，每个语句只声明一个变量，用debugger逐个调试也很方便，而不是一次跳过所有变量。
【反例】
【正例】
空格应该突出关键字和重要信息，避免不必要的空格
【级别】建议
【描述】
空格应该突出关键字和重要信息。总体建议如下：
1.  任何打开大括号({)之前加空格，有两个例外： a) 在作为函数的第一个参数或数组中的第一个元素时，对象之前不用加空格，例如：foo({ name: 'abc' })。 b) 在模板中，不用加空格，例如：abc${name}。
【反例】
【正例】
【反例】
【正例】
【正例】
【正例】
建议字符串使用单引号
【级别】建议
【描述】
较为约定俗成，单引号优于双引号。
【反例】
【正例】
对象字面量属性超过4个，需要都换行
【级别】建议
【描述】
对象字面量要么每个属性都换行，要么所有属性都在同一行。当对象字面量属性超过4个的时候，建议统一换行。
【反例】
【正例】
把else/catch放在if/try代码块关闭括号的同一行
【级别】建议
【描述】
在写条件语句时，建议把else放在if代码块关闭括号的同一行。同样，在写异常处理语句时，建议把catch也放在try代码块关闭括号的同一行。
【反例】
【正例】
【反例】
【正例】
大括号{和语句在同一行
【级别】建议
【描述】
应保持一致的大括号风格。建议将大括号放在控制语句或声明语句同一行的位置。
【反例】
【正例】
编程实践
建议添加类属性的可访问修饰符
【级别】建议
【描述】
在ArkTS中，提供了private, protected和public可访问修饰符。默认情况下一个属性的可访问修饰符为public。选取适当的可访问修饰符可以提升代码的安全性、可读性。注意：如果类中包含private属性，无法通过对象字面量初始化该类。
【反例】
【正例】
不建议省略浮点数小数点前后的0
【级别】建议
【描述】
在ArkTS中，浮点值会包含一个小数点，没有要求小数点之前或之后必须有一个数字。在小数点前面和后面均添加数字可以提高代码可读性。
【反例】
【正例】
判断变量是否为Number.NaN时必须使用Number.isNaN()方法
【级别】要求
【描述】
在ArkTS中，Number.NaN是Number类型的一个特殊值。它被用来表示非数值，这里的数值是指在IEEE浮点数算术标准中定义的双精度64位格式的值。
因为在ArkTS中Number.NaN独特之处在于它不等于任何值，包括它本身，与Number.NaN进行比较的结果是令人困惑：Number.NaN !== Number.NaN or Number.NaN != Number.NaN的值都是true。
因此，必须使用Number.isNaN()函数来测试一个值是否是Number.NaN。
【反例】
【正例】
数组遍历优先使用Array对象方法
【级别】要求
【描述】
对于数组的遍历处理，应该优先使用Array对象方法，如：forEach(), map(), every(), filter(), find(), findIndex(), reduce(), some()。
【反例】
【正例】
```typescript
const numbers = [1, 2, 3, 4, 5];
// better: 使用map方法是更好的方式
const increasedByOne: number[] = numbers.map(num => num + 1);
```
不要在控制性条件表达式中执行赋值操作
【级别】要求
【描述】
控制性条件表达式常用于if、while、for、?:等条件判断中。
在控制性条件表达式中执行赋值，常常导致意料之外的行为，且代码的可读性非常差。
【反例】
【正例】
在finally代码块中，不要使用return、break、continue或抛出异常，避免finally块非正常结束
【级别】要求
【描述】
在finally代码块中，直接使用return、break、continue、throw语句，或由于调用方法的异常未处理，会导致finally代码块无法正常结束。非正常结束的finally代码块会影响try或catch代码块中异常的抛出，也可能会影响方法的返回值。所以要保证finally代码块正常结束。
【反例】
【正例】
避免使用ESObject
【级别】建议
【描述】
ESObject主要用在ArkTS和TS/JS跨语言调用场景中的类型标注，在非跨语言调用场景中使用ESObject标注类型，会引入不必要的跨语言调用，造成额外性能开销。
【反例】
【正例】
使用T[]表示数组类型
【级别】建议
【描述】
ArkTS提供了两种数组类型的表示方式：T[]和Array<T>。为了代码的可读性，建议所有数组类型均用T[]来表示。
【反例】
【正例】

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/typescript-to-arkts-migration
爬取时间: 2025-04-27 21:44:56
来源: Huawei Developer
- ArkTS语法适配背景
- 从TypeScript到ArkTS的适配规则
- 适配指导案例

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-migration-background
爬取时间: 2025-04-27 21:45:50
来源: Huawei Developer
ArkTS在保持TypeScript（简称TS）基本语法风格的基础上，进一步通过规范强化静态检查和分析，使得在程序开发期能检测更多错误，提升程序稳定性，并实现更好的运行性能。本文将进一步解释为什么建议将TS代码适配为ArkTS代码。
程序稳定性
动态类型语言，例如JavaScript（简称JS），可以使得开发者非常快速地编写代码，但是同时，它也使得程序容易在运行时产生非预期的错误。例如在代码中，如果开发者没有检查一个值是否为undefined，那么程序有可能在运行时崩溃，给开发者造成不便。如果能在代码开发阶段检查此类问题是更有好处的。TS通过标注类型帮助开发者检查错误，许多错误在编译时可以被编译器检测出来，不用等到程序运行时。但是，即使是TS也有局限性，它不强制要求对变量进行类型标注，导致很多编译时检查无法开展。ArkTS尝试克服这些缺点，它强制使用静态类型，旨在通过更严格的类型检查以减少运行时错误。
下面这个例子展示了ArkTS通过强制严格的类型检查来提高代码稳定性和正确性。
显式初始化类的属性
ArkTS要求类的所有属性在声明时或者在构造函数中显式地初始化，这和TS中的strictPropertyInitialization检查一致。以下的代码片段是非严格模式下的TS代码。
```typescript
class Person {
name: string // undefined
setName(n: string): void {
this.name = n
}
getName(): string {
// 开发者使用"string"作为返回类型，这隐藏了name可能为"undefined"的事实。
// 更合适的做法是将返回类型标注为"string | undefined"，以告诉开发者这个API所有可能的返回值的类型。
return this.name
}
}
let buddy = new Person()
// 假设代码中没有对name的赋值，例如没有调用"buddy.setName('John')"
buddy.getName().length; // 运行时异常：name is undefined
```
由于ArkTS要求属性显式初始化，代码应该像下面这样写。
```typescript
class Person {
name: string = ''
setName(n: string): void {
this.name = n
}
// 类型为"string"，不可能为"null"或者"undefined"
getName(): string {
return this.name
}
}
let buddy = new Person()
// 假设代码中没有对name的赋值，例如没有调用"buddy.setName('John')"
buddy.getName().length; // 0, 没有运行时异常
```
如果name可以是undefined，那么它的类型应该在代码中被精确地标注。
```typescript
class Person {
name?: string // 可能为undefined
setName(n: string): void {
this.name = n
}
// 编译时错误：name可能为"undefined"，所以不能将这个API的返回类型标注为"string"
getNameWrong(): string {
return this.name
}
getName(): string | undefined { // 返回类型匹配name的类型
return this.name
}
}
let buddy = new Person()
// 假设代码中没有对name的赋值，例如没有调用"buddy.setName('John')"
// 编译时错误：编译器认为下一行代码有可能访问"undefined"的属性，报错
buddy.getName().length;  // 编译失败
buddy.getName()?.length; // 编译成功，没有运行时错误
```
程序性能
为了保证程序的正确性，动态类型语言不得不在运行时检查对象的类型。例如，JS不允许访问undefined的属性。但是检查一个值是否为undefined的唯一的办法是在运行时进行一次类型检查。所有的JS引擎都会做如下的事：如果一个值不是undefined，那么可以访问其属性，否则抛出异常。现代JS引擎可以很好地对这类操作进行优化，但是总有一些运行时的检查是无法被消除的，这就使得程序变慢了。由于TS总是先被编译成JS，所以在TS代码中，也会面临相同的问题。ArkTS解决了这个问题。由于使能了静态类型检查，ArkTS代码将会被编译成方舟字节码文件，而不是JS代码。因此，ArkTS运行速度更快，更容易被进一步地优化。
Null Safety
```typescript
function notify(who: string, what: string) {
console.log(`Dear ${who}, a message for you: ${what}`)
}
notify('Jack', 'You look great today')
```
在大多数情况下，函数notify会接受两个string类型的变量作为输入，产生一个新的字符串。但是，如果将一些特殊值作为输入，例如notify(null, undefined)，情况会怎么样呢？
程序仍会正常运行，输出预期值：Dear null, a message for you: undefined。一切看起来正常，但是请注意，为了保证该场景下程序的正确性，引擎总是在运行时进行类型检查，执行类似以下的伪代码。
```typescript
function __internal_tostring(s: any): string {
if (typeof s === 'string')
return s
if (s === undefined)
return 'undefined'
if (s === null)
return 'null'
// ...
}
```
现在想象一下，如果函数notify是某些复杂的负载场景中的一部分，而不仅仅是打印日志，那么在运行时执行像__internal_tostring的类型检查将会是一个性能问题。
如果可以保证在运行时，只有string类型的值（不会是其他值，例如null或者undefined）可以被传入函数notify呢？在这种情况下，因为可以确保没有其他边界情况，像__internal_tostring的检查就是多余的了。对于这个场景，这样的机制叫做“null-safety”，也就是说，保证null不是一个合法的string类型变量的值。如果ArkTS有了这个特性，类型不符合的代码将无法编译。
```typescript
function notify(who: string, what: string) {
console.log(`Dear ${who}, a message for you: ${what}`)
}
notify('Jack', 'You look great today')
notify(null, undefined) // 编译时错误
```
TS通过打开编译选项strictNullChecks来实现此特性。但是TS是被编译成JS的，而JS没有这个特性，因此严格null检查只在编译时起作用。从程序稳定性和性能角度考虑，ArkTS将“null-safety”视为一个重要的特性。这就是为什么ArkTS强制进行严格null检查，在ArkTS中，上面的代码总是编译报错。作为交换，这样的代码可以给ArkTS引擎带来更多的信息和有关值的类型保证，这有助于更好地优化性能。
.ets代码兼容性
在API version 10之前，ArkTS（.ets文件）完全采用了标准TS的语法。从API version 10 Release起，ArkTS的语法规则基于上述设计考虑进行了明确定义，同时，SDK增加了在编译流程中对.ets文件的ArkTS语法检查，通过编译告警或编译失败提示开发者适配新的ArkTS语法。
根据工程的compatibleSdkVersion，具体策略如下：
- compatibleSdkVersion >= 10 为标准模式。在该模式下，对.ets文件，违反ArkTS语法规则的代码会导致工程编译失败，需要完全适配ArkTS语法后方可编译成功。
- compatibleSdkVersion < 10 为兼容模式。在该模式下，对.ets文件，以warning形式提示违反ArkTS语法规则的所有代码。尽管违反ArkTS语法规则的工程在兼容模式下仍可编译成功，但是需要完全适配ArkTS语法后方可在标准模式下编译成功。
支持与TS/JS的交互
ArkTS支持与TS/JS的高效互操作，在当前版本上，ArkTS运行时兼容动态类型对象语义。在与TS/JS交互的场景下，将TS/JS的数据和对象在ArkTS中当作ArkTS的数据和对象使用时，可能会绕过ArkTS的静态编译检查，造成非预期的行为或引入额外的开销。
```typescript
// lib.ts
export class C {
v: string
}
export let c = new C()
// app.ets
import { C, c } from './lib'
function foo(c: C) {
c.v.length
}
foo(c)  //  运行时异常：v is undefined
```
方舟运行时兼容TS/JS
在API version 11上，HarmonyOS SDK中的TypeScript版本为4.9.5，target字段为es2017。在应用中，开发者可以使用ECMA2017+的语法进行TS/JS开发。
应用环境限制
与标准TS/JS的差异
标准TS/JS中，JSON的数字格式，小数点后必须跟着数字，如2.e3这类科学计数法不被允许，报出SyntaxError。在方舟运行时中，允许使用这类科学计数法。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/typescript-to-arkts-migration-guide
爬取时间: 2025-04-27 21:46:05
来源: Huawei Developer
ArkTS通过规范约束了TypeScript（简称TS）中过于灵活而影响开发正确性或者给运行时带来不必要额外开销的特性。本文罗列了所有在ArkTS中限制的TS特性，并提供了重构代码的建议。ArkTS保留了TS大部分的语法特性，对于本文中没有约束的TS特性，则说明ArkTS完全支持它们。例如：ArkTS支持自定义装饰器，语法上和TS一致。按照本文提供的约束进行代码重构后的代码仍为合法有效的TS代码。
示例
包含关键字var的原始TypeScript代码：
```typescript
function addTen(x: number): number {
var ten = 10;
return x + ten;
}
```
重构后的代码：
```typescript
function addTen(x: number): number {
let ten = 10;
return x + ten;
}
```
级别
约束分为两个级别：错误、警告。
- 错误: 必须要遵从的约束。如果不遵从该约束，将会导致程序编译失败。
- 警告: 推荐遵从的约束。尽管现在违反该约束不会影响编译流程，但是在将来，违反该约束可能将会导致程序编译失败。
不支持的特性
目前，不支持的特性主要包括：
- 与降低运行时性能的动态类型相关的特性。
- 需要编译器额外支持从而导致项目构建时间增加的特性。
根据开发者的反馈以及更多实际场景的数据，我们将来可能进一步缩小不支持特性的范围。
概述
本节罗列了ArkTS不支持或部分支持的TypeScript特性。完整的列表以及详细的代码示例和重构建议，请参考约束说明。更多案例请参考适配指导案例。
强制使用静态类型
静态类型是ArkTS最重要的特性之一。如果程序采用静态类型，即所有类型在编译时都是已知的，那么开发者就能够容易理解代码中使用了哪些数据结构。同时，由于所有类型在程序实际运行前都是已知的，编译器可以提前验证代码的正确性，从而可以减少运行时的类型检查，有助于提升性能。
基于上述考虑，ArkTS中禁止使用any类型。
示例
```typescript
// 不支持：
let res: any = some_api_function('hello', 'world');
// `res`是什么？错误代码的数字？字符串？对象？
// 该如何处理它？
// 支持：
class CallResult {
public succeeded(): boolean { ... }
public errorMessage(): string { ... }
}
let res: CallResult = some_api_function('hello', 'world');
if (!res.succeeded()) {
console.log('Call failed: ' + res.errorMessage());
}
```
any类型在TypeScript中并不常见，只有大约1%的TypeScript代码库使用。一些代码检查工具（例如ESLint）也制定一系列规则来禁止使用any。因此，虽然禁止any将导致代码重构，但重构量很小，有助于整体性能提升。
禁止在运行时变更对象布局
为实现最佳性能，ArkTS要求在程序执行期间不能更改对象的布局。换句话说，ArkTS禁止以下行为：
- 向对象中添加新的属性或方法。
- 从对象中删除已有的属性或方法。
- 将任意类型的值赋值给对象属性。
TypeScript编译器已经禁止了许多此类操作。然而，有些操作还是有可能绕过编译器的，例如，使用as any转换对象的类型，或者在编译TS代码时关闭严格类型检查的配置，或者在代码中通过@ts-ignore忽略类型检查。
在ArkTS中，严格类型检查不是可配置项。ArkTS强制进行部分严格类型检查，并通过规范禁止使用any类型，禁止在代码中使用@ts-ignore。
示例
```typescript
class Point {
public x: number = 0
public y: number = 0
constructor(x: number, y: number) {
this.x = x;
this.y = y;
}
}
// 无法从对象中删除某个属性，从而确保所有Point对象都具有属性x
let p1 = new Point(1.0, 1.0);
delete p1.x;           // 在TypeScript和ArkTS中，都会产生编译时错误
delete (p1 as any).x;  // 在TypeScript中不会报错；在ArkTS中会产生编译时错误
// Point类没有定义命名为z的属性，在程序运行时也无法添加该属性
let p2 = new Point(2.0, 2.0);
p2.z = 'Label';           // 在TypeScript和ArkTS中，都会产生编译时错误
(p2 as any).z = 'Label';   // 在TypeScript中不会报错；在ArkTS中会产生编译时错误
// 类的定义确保了所有Point对象只有属性x和y，并且无法被添加其他属性
let p3 = new Point(3.0, 3.0);
let prop = Symbol();      // 在TypeScript中不会报错；在ArkTS中会产生编译时错误
(p3 as any)[prop] = p3.x; // 在TypeScript中不会报错；在ArkTS中会产生编译时错误
p3[prop] = p3.x;          // 在TypeScript和ArkTS中，都会产生编译时错误
// 类的定义确保了所有Point对象的属性x和y都具有number类型，因此，无法将其他类型的值赋值给它们
let p4 = new Point(4.0, 4.0);
p4.x = 'Hello!';          // 在TypeScript和ArkTS中，都会产生编译时错误
(p4 as any).x = 'Hello!'; // 在TypeScript中不会报错；在ArkTS中会产生编译时错误
// 使用符合类定义的Point对象：
function distance(p1: Point, p2: Point): number {
return Math.sqrt(
(p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y)
);
}
let p5 = new Point(5.0, 5.0);
let p6 = new Point(6.0, 6.0);
console.log('Distance between p5 and p6: ' + distance(p5, p6));
```
修改对象布局会影响代码的可读性以及运行时性能。从开发者的角度来说，在某处定义类，然后又在其他地方修改实际的对象布局，很容易引起困惑乃至引入错误。此外，这点还需要额外的运行时支持，增加了执行开销。这一点与静态类型的约束也冲突：既然已决定使用显式类型，为什么还需要添加或删除属性呢？
当前，只有少数项目允许在运行时变更对象布局，一些常用的代码检查工具也增加了相应的限制规则。这个约束只会导致少量代码重构，但会提升性能。
限制运算符的语义
为获得更好的性能并鼓励开发者编写更清晰的代码，ArkTS限制了一些运算符的语义。详细的语义限制，请参考约束说明。
示例
```typescript
// 一元运算符`+`只能作用于数值类型：
let t = +42;   // 合法运算
let s = +'42'; // 编译时错误
```
使用额外的语义重载语言运算符会增加语言规范的复杂度，而且，开发者还被迫牢记所有可能的例外情况及对应的处理规则。在某些情况下，产生一些不必要的运行时开销。
当前只有不到1%的代码库使用该特性。因此，尽管限制运算符的语义需要重构代码，但重构量很小且非常容易操作，并且，通过重构能使代码更清晰、具备更高性能。
不支持 structural typing
假设两个不相关的类T和U拥有相同的publicAPI：
```typescript
class T {
public name: string = ''
public greet(): void {
console.log('Hello, ' + this.name);
}
}
class U {
public name: string = ''
public greet(): void {
console.log('Greetings, ' + this.name);
}
}
```
能把类型为T的值赋给类型为U的变量吗？
```typescript
let u: U = new T(); // 是否允许？
```
能把类型为T的值传递给接受类型为U的参数的函数吗？
```typescript
function greeter(u: U) {
console.log('To ' + u.name);
u.greet();
}
let t: T = new T();
greeter(t); // 是否允许？
```
换句话说，我们将采取下面哪种方法呢：
- T和U没有继承关系或没有implements相同的接口，但由于它们具有相同的publicAPI，它们“在某种程度上是相等的”，所以上述两个问题的答案都是“是”；
- T和U没有继承关系或没有implements相同的接口，应当始终被视为完全不同的类型，因此上述两个问题的答案都是“否”。
采用第一种方法的语言支持structural typing，而采用第二种方法的语言则不支持structural typing。目前TypeScript支持structural typing，而ArkTS不支持。
structural typing是否有助于生成清晰、易理解的代码，关于这一点并没有定论。那为什么ArkTS不支持structural typing呢？
因为对structural typing的支持是一个重大的特性，需要在语言规范、编译器和运行时进行大量的考虑和仔细的实现。另外，由于ArkTS使用静态类型，运行时为了支持这个特性需要额外的性能开销。
鉴于此，当前我们还不支持该特性。根据实际场景的需求和反馈，我们后续会重新加以考虑。更多案例和建议请参考约束说明。
约束说明
对象的属性名必须是合法的标识符
规则：arkts-identifiers-as-prop-names
级别：错误
在ArkTS中，对象的属性名不能为数字或字符串。例外：ArkTS支持属性名为字符串字面量和枚举中的字符串值。通过属性名访问类的属性，通过数值索引访问数组元素。
TypeScript
```typescript
var x = { 'name': 'x', 2: '3' };
console.log(x['name']);
console.log(x[2]);
```
ArkTS
```typescript
class X {
public name: string = ''
}
let x: X = { name: 'x' };
console.log(x.name);
let y = ['a', 'b', 'c'];
console.log(y[2]);
// 在需要通过非标识符（即不同类型的key）获取数据的场景中，使用Map<Object, some_type>。
let z = new Map<Object, string>();
z.set('name', '1');
z.set(2, '2');
console.log(z.get('name'));
console.log(z.get(2));
enum Test {
A = 'aaa',
B = 'bbb'
}
let obj: Record<string, number> = {
[Test.A]: 1,   // 枚举中的字符串值
[Test.B]: 2,   // 枚举中的字符串值
['value']: 3   // 字符串字面量
}
```
不支持Symbol()API
规则：arkts-no-symbol
级别：错误
TypeScript中的Symbol()API用于在运行时生成唯一的属性名称。由于该API的常见使用场景在静态类型语言中没有意义，因此，ArkTS不支持Symbol()API。在ArkTS中，对象布局在编译时就确定了，且不能在运行时被更改。
ArkTS只支持Symbol.iterator。
不支持以#开头的私有字段
规则：arkts-no-private-identifiers
级别：错误
ArkTS不支持使用#符号开头声明的私有字段。改用private关键字。
TypeScript
```typescript
class C {
#foo: number = 42
}
```
ArkTS
```typescript
class C {
private foo: number = 42
}
```
类型、命名空间的命名必须唯一
规则：arkts-unique-names
级别：错误
类型（类、接口、枚举）、命名空间的命名必须唯一，且与其他名称（例如：变量名、函数名）不同。
TypeScript
```typescript
let X: string
type X = number[] // 类型的别名与变量同名
```
ArkTS
```typescript
let X: string
type T = number[] // 为避免名称冲突，此处不允许使用X
```
使用let而非var
规则：arkts-no-var
级别：错误
let关键字可以在块级作用域中声明变量，帮助程序员避免错误。因此，ArkTS不支持var，请使用let声明变量。
TypeScript
```typescript
function f(shouldInitialize: boolean) {
if (shouldInitialize) {
var x = 'b';
}
return x;
}
console.log(f(true));  // b
console.log(f(false)); // undefined
let upperLet = 0;
{
var scopedVar = 0;
let scopedLet = 0;
upperLet = 5;
}
scopedVar = 5; // 可见
scopedLet = 5; // 编译时错误
```
ArkTS
```typescript
function f(shouldInitialize: boolean): string {
let x: string = 'a';
if (shouldInitialize) {
x = 'b';
}
return x;
}
console.log(f(true));  // b
console.log(f(false)); // a
let upperLet = 0;
let scopedVar = 0;
{
let scopedLet = 0;
upperLet = 5;
}
scopedVar = 5;
scopedLet = 5; //编译时错误
```
使用具体的类型而非any或unknown
规则：arkts-no-any-unknown
级别：错误
ArkTS不支持any和unknown类型。显式指定具体类型。
TypeScript
```typescript
let value1: any
value1 = true;
value1 = 42;
let value2: unknown
value2 = true;
value2 = 42;
```
ArkTS
```typescript
let value_b: boolean = true; // 或者 let value_b = true
let value_n: number = 42; // 或者 let value_n = 42
let value_o1: Object = true;
let value_o2: Object = 42;
```
使用class而非具有call signature的类型
规则：arkts-no-call-signatures
级别：错误
ArkTS不支持对象类型中包含call signature。
TypeScript
```typescript
type DescribableFunction = {
description: string
(someArg: string): string // call signature
}
function doSomething(fn: DescribableFunction): void {
console.log(fn.description + ' returned ' + fn(''));
}
```
ArkTS
```typescript
class DescribableFunction {
description: string
public invoke(someArg: string): string {
return someArg;
}
constructor() {
this.description = 'desc';
}
}
function doSomething(fn: DescribableFunction): void {
console.log(fn.description + ' returned ' + fn.invoke(''));
}
doSomething(new DescribableFunction());
```
使用class而非具有构造签名的类型
规则：arkts-no-ctor-signatures-type
级别：错误
ArkTS不支持对象类型中的构造签名。改用类。
TypeScript
```typescript
class SomeObject {}
type SomeConstructor = {
new (s: string): SomeObject
}
function fn(ctor: SomeConstructor) {
return new ctor('hello');
}
```
ArkTS
```typescript
class SomeObject {
public f: string
constructor (s: string) {
this.f = s;
}
}
function fn(s: string): SomeObject {
return new SomeObject(s);
}
```
仅支持一个静态块
规则：arkts-no-multiple-static-blocks
级别：错误
ArkTS不允许类中有多个静态块，如果存在多个静态块语句，请合并到一个静态块中。
TypeScript
```typescript
class C {
static s: string
static {
C.s = 'aa'
}
static {
C.s = C.s + 'bb'
}
}
```
ArkTS
```typescript
class C {
static s: string
static {
C.s = 'aa'
C.s = C.s + 'bb'
}
}
```
说明
当前不支持静态块的语法。支持该语法后，在.ets文件中使用静态块须遵循本约束。
不支持index signature
规则：arkts-no-indexed-signatures
级别：错误
ArkTS不允许index signature，改用数组。
TypeScript
```typescript
// 带index signature的接口：
interface StringArray {
[index: number]: string
}
function getStringArray(): StringArray {
return ['a', 'b', 'c'];
}
const myArray: StringArray = getStringArray();
const secondItem = myArray[1];
```
ArkTS
```typescript
class X {
public f: string[] = []
}
let myArray: X = new X();
const secondItem = myArray.f[1];
```
使用继承而非intersection type
规则：arkts-no-intersection-types
级别：错误
目前ArkTS不支持intersection type，可以使用继承作为替代方案。
TypeScript
```typescript
interface Identity {
id: number
name: string
}
interface Contact {
email: string
phoneNumber: string
}
type Employee = Identity & Contact
```
ArkTS
```typescript
interface Identity {
id: number
name: string
}
interface Contact {
email: string
phoneNumber: string
}
interface Employee extends Identity,  Contact {}
```
不支持this类型
规则：arkts-no-typing-with-this
级别：错误
ArkTS不支持this类型，改用显式具体类型。
TypeScript
```typescript
interface ListItem {
getHead(): this
}
class C {
n: number = 0
m(c: this) {
// ...
}
}
```
ArkTS
```typescript
interface ListItem {
getHead(): ListItem
}
class C {
n: number = 0
m(c: C) {
// ...
}
}
```
不支持条件类型
规则：arkts-no-conditional-types
级别：错误
ArkTS不支持条件类型别名，引入带显式约束的新类型，或使用Object重写逻辑。
不支持infer关键字。
TypeScript
```typescript
type X<T> = T extends number ? T: never
type Y<T> = T extends Array<infer Item> ? Item: never
```
ArkTS
```typescript
// 在类型别名中提供显式约束
type X1<T extends number> = T
// 用Object重写，类型控制较少，需要更多的类型检查以确保安全
type X2<T> = Object
// Item必须作为泛型参数使用，并能正确实例化
type YI<Item, T extends Array<Item>> = Item
```
不支持在constructor中声明字段
规则：arkts-no-ctor-prop-decls
级别：错误
ArkTS不支持在constructor中声明类字段。在class中声明这些字段。
TypeScript
```typescript
class Person {
constructor(
protected ssn: string,
private firstName: string,
private lastName: string
) {
this.ssn = ssn;
this.firstName = firstName;
this.lastName = lastName;
}
getFullName(): string {
return this.firstName + ' ' + this.lastName;
}
}
```
ArkTS
```typescript
class Person {
protected ssn: string
private firstName: string
private lastName: string
constructor(ssn: string, firstName: string, lastName: string) {
this.ssn = ssn;
this.firstName = firstName;
this.lastName = lastName;
}
getFullName(): string {
return this.firstName + ' ' + this.lastName;
}
}
```
接口中不支持构造签名
规则：arkts-no-ctor-signatures-iface
级别：错误
ArkTS不支持在接口中使用构造签名。改用函数或者方法。
TypeScript
```typescript
interface I {
new (s: string): I
}
function fn(i: I) {
return new i('hello');
}
```
ArkTS
```typescript
interface I {
create(s: string): I
}
function fn(i: I) {
return i.create('hello');
}
```
不支持索引访问类型
规则：arkts-no-aliases-by-index
级别：错误
ArkTS不支持索引访问类型。
不支持通过索引访问字段
规则：arkts-no-props-by-index
级别：错误
ArkTS不支持动态声明字段，不支持动态访问字段。只能访问已在类中声明或者继承可见的字段，访问其他字段将会造成编译时错误。
使用点操作符访问字段，例如（obj.field），不支持索引访问（obj[field]）。
ArkTS支持通过索引访问TypedArray（例如Int32Array）中的元素。
TypeScript
```typescript
class Point {
x: string = ''
y: string = ''
}
let p: Point = {x: '1', y: '2'};
console.log(p['x']);
class Person {
name: string = ''
age: number = 0;
[key: string]: string | number
}
let person: Person = {
name: 'John',
age: 30,
email: '***@example.com',
phoneNumber: '18*********',
}
```
ArkTS
```typescript
class Point {
x: string = ''
y: string = ''
}
let p: Point = {x: '1', y: '2'};
console.log(p.x);
class Person {
name: string
age: number
email: string
phoneNumber: string
constructor(name: string, age: number, email: string,
phoneNumber: string) {
this.name = name;
this.age = age;
this.email = email;
this.phoneNumber = phoneNumber;
}
}
let person = new Person('John', 30, '***@example.com', '18*********');
console.log(person['name']);     // 编译时错误
console.log(person.unknownProperty); // 编译时错误
let arr = new Int32Array(1);
arr[0];
```
不支持structural typing
规则：arkts-no-structural-typing
级别：错误
ArkTS不支持structural typing，编译器无法比较两种类型的publicAPI并决定它们是否相同。使用其他机制，例如继承、接口或类型别名。
TypeScript
```typescript
interface I1 {
f(): string
}
interface I2 { // I2等价于I1
f(): string
}
class X {
n: number = 0
s: string = ''
}
class Y { // Y等价于X
n: number = 0
s: string = ''
}
let x = new X();
let y = new Y();
console.log('Assign X to Y');
y = x;
console.log('Assign Y to X');
x = y;
function foo(x: X) {
console.log(x.n + x.s);
}
// 由于X和Y的API是等价的，所以X和Y是等价的
foo(new X());
foo(new Y());
```
ArkTS
```typescript
interface I1 {
f(): string
}
type I2 = I1 // I2是I1的别名
class B {
n: number = 0
s: string = ''
}
// D是B的继承类，构建了子类型和父类型的关系
class D extends B {
constructor() {
super()
}
}
let b = new B();
let d = new D();
console.log('Assign D to B');
b = d; // 合法赋值，因为B是D的父类
// 将b赋值给d将会引起编译时错误
// d = b
interface Z {
n: number
s: string
}
// 类X implements 接口Z，构建了X和Y的关系
class X implements Z {
n: number = 0
s: string = ''
}
// 类Y implements 接口Z，构建了X和Y的关系
class Y implements Z {
n: number = 0
s: string = ''
}
let x: Z = new X();
let y: Z = new Y();
console.log('Assign X to Y');
y = x // 合法赋值，它们是相同的类型
console.log('Assign Y to X');
x = y // 合法赋值，它们是相同的类型
function foo(c: Z): void {
console.log(c.n + c.s);
}
// 类X和类Y implement 相同的接口，因此下面的两个函数调用都是合法的
foo(new X());
foo(new Y());
```
需要显式标注泛型函数类型实参
规则：arkts-no-inferred-generic-params
级别：错误
如果可以从传递给泛型函数的参数中推断出具体类型，ArkTS允许省略泛型类型实参。否则，省略泛型类型实参会发生编译时错误。
禁止仅基于泛型函数返回类型推断泛型类型参数。
TypeScript
```typescript
function choose<T>(x: T, y: T): T {
return Math.random() < 0.5 ? x: y;
}
let x = choose(10, 20);   // 推断choose<number>(...)
let y = choose('10', 20); // 编译时错误
function greet<T>(): T {
return 'Hello' as T;
}
let z = greet() // T的类型被推断为“unknown”
```
ArkTS
```typescript
function choose<T>(x: T, y: T): T {
return Math.random() < 0.5 ? x: y;
}
let x = choose(10, 20);   // 推断choose<number>(...)
let y = choose('10', 20); // 编译时错误
function greet<T>(): T {
return 'Hello' as T;
}
let z = greet<string>();
```
需要显式标注对象字面量的类型
规则：arkts-no-untyped-obj-literals
级别：错误
在ArkTS中，需要显式标注对象字面量的类型，否则，将发生编译时错误。在某些场景下，编译器可以根据上下文推断出字面量的类型。
在以下上下文中不支持使用字面量初始化类和接口：
- 初始化具有any、Object或object类型的任何对象
- 初始化带有方法的类或接口
- 初始化包含自定义含参数的构造函数的类
- 初始化带readonly字段的类
例子1
TypeScript
```typescript
let o1 = {n: 42, s: 'foo'};
let o2: Object = {n: 42, s: 'foo'};
let o3: object = {n: 42, s: 'foo'};
let oo: Object[] = [{n: 1, s: '1'}, {n: 2, s: '2'}];
```
ArkTS
```typescript
class C1 {
n: number = 0
s: string = ''
}
let o1: C1 = {n: 42, s: 'foo'};
let o2: C1 = {n: 42, s: 'foo'};
let o3: C1 = {n: 42, s: 'foo'};
let oo: C1[] = [{n: 1, s: '1'}, {n: 2, s: '2'}];
```
例子2
TypeScript
```typescript
class C2 {
s: string
constructor(s: string) {
this.s = 's =' + s;
}
}
let o4: C2 = {s: 'foo'};
```
ArkTS
```typescript
class C2 {
s: string
constructor(s: string) {
this.s = 's =' + s;
}
}
let o4 = new C2('foo');
```
例子3
TypeScript
```typescript
class C3 {
readonly n: number = 0
readonly s: string = ''
}
let o5: C3 = {n: 42, s: 'foo'};
```
ArkTS
```typescript
class C3 {
n: number = 0
s: string = ''
}
let o5: C3 = {n: 42, s: 'foo'};
```
例子4
TypeScript
```typescript
abstract class A {}
let o6: A = {};
```
ArkTS
```typescript
abstract class A {}
class C extends A {}
let o6: C = {}; // 或 let o6: C = new C()
```
例子5
TypeScript
```typescript
class C4 {
n: number = 0
s: string = ''
f() {
console.log('Hello');
}
}
let o7: C4 = {n: 42, s: 'foo', f: () => {}};
```
ArkTS
```typescript
class C4 {
n: number = 0
s: string = ''
f() {
console.log('Hello');
}
}
let o7 = new C4();
o7.n = 42;
o7.s = 'foo';
```
例子6
TypeScript
```typescript
class Point {
x: number = 0
y: number = 0
}
function getPoint(o: Point): Point {
return o;
}
// TS支持structural typing，可以推断p的类型为Point
let p = {x: 5, y: 10};
getPoint(p);
// 可通过上下文推断出对象字面量的类型为Point
getPoint({x: 5, y: 10});
```
ArkTS
```typescript
class Point {
x: number = 0
y: number = 0
// 在字面量初始化之前，使用constructor()创建一个有效对象。
// 由于没有为Point定义构造函数，编译器将自动添加一个默认构造函数。
}
function getPoint(o: Point): Point {
return o;
}
// 字面量初始化需要显式定义类型
let p: Point = {x: 5, y: 10};
getPoint(p);
// getPoint接受Point类型，字面量初始化生成一个Point的新实例
getPoint({x: 5, y: 10});
```
对象字面量不能用于类型声明
规则：arkts-no-obj-literals-as-types
级别：错误
ArkTS不支持使用对象字面量声明类型，可以使用类或者接口声明类型。
TypeScript
```typescript
let o: {x: number, y: number} = {
x: 2,
y: 3
}
type S = Set<{x: number, y: number}>
```
ArkTS
```typescript
class O {
x: number = 0
y: number = 0
}
let o: O = {x: 2, y: 3};
type S = Set<O>
```
数组字面量必须仅包含可推断类型的元素
规则：arkts-no-noninferrable-arr-literals
级别：错误
本质上，ArkTS将数组字面量的类型推断为数组所有元素的联合类型。如果其中任何一个元素的类型无法根据上下文推导出来（例如，无类型的对象字面量），则会发生编译时错误。
TypeScript
```typescript
let a = [{n: 1, s: '1'}, {n: 2, s: '2'}];
```
ArkTS
```typescript
class C {
n: number = 0
s: string = ''
}
let a1 = [{n: 1, s: '1'} as C, {n: 2, s: '2'} as C]; // a1的类型为“C[]”
let a2: C[] = [{n: 1, s: '1'}, {n: 2, s: '2'}];    // a2的类型为“C[]”
```
使用箭头函数而非函数表达式
规则：arkts-no-func-expressions
级别：错误
ArkTS不支持函数表达式，使用箭头函数。
TypeScript
```typescript
let f = function (s: string) {
console.log(s);
}
```
ArkTS
```typescript
let f = (s: string) => {
console.log(s);
}
```
不支持使用类表达式
规则：arkts-no-class-literals
级别：错误
ArkTS不支持使用类表达式，必须显式声明一个类。
TypeScript
```typescript
const Rectangle = class {
constructor(height: number, width: number) {
this.height = height;
this.width = width;
}
height
width
}
const rectangle = new Rectangle(0.0, 0.0);
```
ArkTS
```typescript
class Rectangle {
constructor(height: number, width: number) {
this.height = height;
this.width = width;
}
height: number
width: number
}
const rectangle = new Rectangle(0.0, 0.0);
```
类不允许implements
规则：arkts-implements-only-iface
级别：错误
ArkTS不允许类被implements，只有接口可以被implements。
TypeScript
```typescript
class C {
foo() {}
}
class C1 implements C {
foo() {}
}
```
ArkTS
```typescript
interface C {
foo(): void
}
class C1 implements C {
foo() {}
}
```
不支持修改对象的方法
规则：arkts-no-method-reassignment
级别：错误
ArkTS不支持修改对象的方法。在静态语言中，对象的布局是确定的。一个类的所有对象实例享有同一个方法。
如果需要为某个特定的对象增加方法，可以封装函数或者使用继承的机制。
TypeScript
```typescript
class C {
foo() {
console.log('foo');
}
}
function bar() {
console.log('bar');
}
let c1 = new C();
let c2 = new C();
c2.foo = bar;
c1.foo(); // foo
c2.foo(); // bar
```
ArkTS
```typescript
class C {
foo() {
console.log('foo');
}
}
class Derived extends C {
foo() {
console.log('Extra');
super.foo();
}
}
function bar() {
console.log('bar');
}
let c1 = new C();
let c2 = new C();
c1.foo(); // foo
c2.foo(); // foo
let c3 = new Derived();
c3.foo(); // Extra foo
```
类型转换仅支持as T语法
规则：arkts-as-casts
级别：错误
在ArkTS中，as关键字是类型转换的唯一语法，错误的类型转换会导致编译时错误或者运行时抛出ClassCastException异常。ArkTS不支持使用<type>语法进行类型转换。
当需要将primitive类型（如number或boolean）转换成引用类型时，请使用new表达式。
TypeScript
```typescript
class Shape {}
class Circle extends Shape { x: number = 5 }
class Square extends Shape { y: string = 'a' }
function createShape(): Shape {
return new Circle();
}
let c1 = <Circle> createShape();
let c2 = createShape() as Circle;
// 如果转换错误，不会产生编译时或运行时报错
let c3 = createShape() as Square;
console.log(c3.y); // undefined
// 在TS中，由于`as`关键字不会在运行时生效，所以`instanceof`的左操作数不会在运行时被装箱成引用类型
let e1 = (5.0 as Number) instanceof Number; // false
// 创建Number对象，获得预期结果：
let e2 = (new Number(5.0)) instanceof Number; // true
```
ArkTS
```typescript
class Shape {}
class Circle extends Shape { x: number = 5 }
class Square extends Shape { y: string = 'a' }
function createShape(): Shape {
return new Circle();
}
let c2 = createShape() as Circle;
// 运行时抛出ClassCastException异常：
let c3 = createShape() as Square;
// 创建Number对象，获得预期结果：
let e2 = (new Number(5.0)) instanceof Number; // true
```
不支持JSX表达式
规则：arkts-no-jsx
级别：错误
不支持使用JSX。
一元运算符+、-和~仅适用于数值类型
规则：arkts-no-polymorphic-unops
级别：错误
ArkTS仅允许一元运算符用于数值类型，否则会发生编译时错误。与TypeScript不同，ArkTS不支持隐式将字符串转换成数值，必须进行显式转换。
TypeScript
```typescript
let a = +5;    // 5（number类型）
let b = +'5';    // 5（number类型）
let c = -5;    // -5（number类型）
let d = -'5';    // -5（number类型）
let e = ~5;    // -6（number类型）
let f = ~'5';    // -6（number类型）
let g = +'string'; // NaN（number类型）
function returnTen(): string {
return '-10';
}
function returnString(): string {
return 'string';
}
let x = +returnTen();  // -10（number类型）
let y = +returnString(); // NaN
```
ArkTS
```typescript
let a = +5;    // 5（number类型）
let b = +'5';    // 编译时错误
let c = -5;    // -5（number类型）
let d = -'5';    // 编译时错误
let e = ~5;    // -6（number类型）
let f = ~'5';    // 编译时错误
let g = +'string'; // 编译时错误
function returnTen(): string {
return '-10';
}
function returnString(): string {
return 'string';
}
let x = +returnTen();  // 编译时错误
let y = +returnString(); // 编译时错误
```
不支持delete运算符
规则：arkts-no-delete
级别：错误
ArkTS中，对象布局在编译时就确定了，且不能在运行时被更改。因此，删除属性的操作没有意义。
TypeScript
```typescript
class Point {
x?: number = 0.0
y?: number = 0.0
}
let p = new Point();
delete p.y;
```
ArkTS
```typescript
// 可以声明一个可空类型并使用null作为缺省值
class Point {
x: number | null = 0
y: number | null = 0
}
let p = new Point();
p.y = null;
```
仅允许在表达式中使用typeof运算符
规则：arkts-no-type-query
级别：错误
ArkTS仅支持在表达式中使用typeof运算符，不允许使用typeof作为类型。
TypeScript
```typescript
let n1 = 42;
let s1 = 'foo';
console.log(typeof n1); // 'number'
console.log(typeof s1); // 'string'
let n2: typeof n1
let s2: typeof s1
```
ArkTS
```typescript
let n1 = 42;
let s1 = 'foo';
console.log(typeof n1); // 'number'
console.log(typeof s1); // 'string'
let n2: number
let s2: string
```
部分支持instanceof运算符
规则：arkts-instanceof-ref-types
级别：错误
在TypeScript中，instanceof运算符的左操作数的类型必须为any类型、对象类型，或者它是类型参数，否则结果为false。在ArkTS中，instanceof运算符的左操作数的类型必须为引用类型（例如，对象、数组或者函数），否则会发生编译时错误。此外，在ArkTS中，instanceof运算符的左操作数不能是类型，必须是对象的实例。
不支持in运算符
规则：arkts-no-in
级别：错误
由于在ArkTS中，对象布局在编译时是已知的并且在运行时无法修改，因此，不支持in运算符。如果仍需检查某些类成员是否存在，使用instanceof代替。
TypeScript
```typescript
class Person {
name: string = ''
}
let p = new Person();
let b = 'name' in p; // true
```
ArkTS
```typescript
class Person {
name: string = ''
}
let p = new Person();
let b = p instanceof Person; // true，且属性name一定存在
```
不支持解构赋值
规则：arkts-no-destruct-assignment
级别：错误
ArkTS不支持解构赋值。可使用其他替代方法，例如，使用临时变量。
TypeScript
```typescript
let [one, two] = [1, 2]; // 此处需要分号
[one, two] = [two, one];
let head, tail
[head, ...tail] = [1, 2, 3, 4];
```
ArkTS
```typescript
let arr: number[] = [1, 2];
let one = arr[0];
let two = arr[1];
let tmp = one;
one = two;
two = tmp;
let data: Number[] = [1, 2, 3, 4];
let head = data[0];
let tail: Number[] = [];
for (let i = 1; i < data.length; ++i) {
tail.push(data[i]);
}
```
逗号运算符,仅用在for循环语句中
规则：arkts-no-comma-outside-loops
级别：错误
为了方便理解执行顺序，在ArkTS中，逗号运算符仅适用于for循环语句中。注意与声明变量、函数参数传递时的逗号分隔符不同。
TypeScript
```typescript
for (let i = 0, j = 0; i < 10; ++i, j += 2) {
// ...
}
let x = 0;
x = (++x, x++); // 1
```
ArkTS
```typescript
for (let i = 0, j = 0; i < 10; ++i, j += 2) {
// ...
}
// 通过语句表示执行顺序，而非逗号运算符
let x = 0;
++x;
x = x++;
```
不支持解构变量声明
规则：arkts-no-destruct-decls
级别：错误
ArkTS不支持解构变量声明。它是一个依赖于结构兼容性的动态特性并且解构声明中的名称必须和被解构对象中的属性名称一致。
TypeScript
```typescript
class Point {
x: number = 0.0
y: number = 0.0
}
function returnZeroPoint(): Point {
return new Point();
}
let {x, y} = returnZeroPoint();
```
ArkTS
```typescript
class Point {
x: number = 0.0
y: number = 0.0
}
function returnZeroPoint(): Point {
return new Point();
}
// 创建一个局部变量来处理每个字段
let zp = returnZeroPoint();
let x = zp.x;
let y = zp.y;
```
不支持在catch语句标注类型
规则：arkts-no-types-in-catch
级别：错误
在TypeScript的catch语句中，只能标注any或unknown类型。由于ArkTS不支持这些类型，应省略类型标注。
TypeScript
```typescript
try {
// ...
} catch (a: unknown) {
// 处理异常
}
```
ArkTS
```typescript
try {
// ...
} catch (a) {
// 处理异常
}
```
不支持for .. in
规则：arkts-no-for-in
级别：错误
由于在ArkTS中，对象布局在编译时是确定的、并且不能在运行时被改变，所以不支持使用for .. in迭代一个对象的属性。对于数组来说，可以使用常规的for循环。
TypeScript
```typescript
let a: string[] = ['1.0', '2.0', '3.0'];
for (let i in a) {
console.log(a[i]);
}
```
ArkTS
```typescript
let a: string[] = ['1.0', '2.0', '3.0'];
for (let i = 0; i < a.length; ++i) {
console.log(a[i]);
}
```
不支持映射类型
规则：arkts-no-mapped-types
级别：错误
ArkTS不支持映射类型，使用其他语法来表示相同的语义。
TypeScript
```typescript
type OptionsFlags<Type> = {
[Property in keyof Type]: boolean
}
```
ArkTS
```typescript
class C {
n: number = 0
s: string = ''
}
class CFlags {
n: boolean = false
s: boolean = false
}
```
不支持with语句
规则：arkts-no-with
级别：错误
ArkTS不支持with语句，使用其他语法来表示相同的语义。
TypeScript
```typescript
with (Math) { // 编译时错误, 但是仍能生成JavaScript代码
let r: number = 42;
let area: number = PI * r * r;
}
```
ArkTS
```typescript
let r: number = 42;
let area: number = Math.PI * r * r;
```
限制throw语句中表达式的类型
规则：arkts-limited-throw
级别：错误
ArkTS只支持抛出Error类或其派生类的实例。禁止抛出其他类型（例如number或string）的数据。
TypeScript
```typescript
throw 4;
throw '';
throw new Error();
```
ArkTS
```typescript
throw new Error();
```
限制省略函数返回类型标注
规则：arkts-no-implicit-return-types
级别：错误
ArkTS在部分场景中支持对函数返回类型进行推断。当return语句中的表达式是对某个函数或方法进行调用，且该函数或方法的返回类型没有被显著标注时，会出现编译时错误。在这种情况下，请标注函数返回类型。
TypeScript
```typescript
// 只有在开启noImplicitAny选项时会产生编译时错误
function f(x: number) {
if (x <= 0) {
return x;
}
return g(x);
}
// 只有在开启noImplicitAny选项时会产生编译时错误
function g(x: number) {
return f(x - 1);
}
function doOperation(x: number, y: number) {
return x + y;
}
f(10);
doOperation(2, 3);
```
ArkTS
```typescript
// 需标注返回类型：
function f(x: number): number {
if (x <= 0) {
return x;
}
return g(x);
}
// 可以省略返回类型，返回类型可以从f的类型标注推导得到
function g(x: number): number {
return f(x - 1);
}
// 可以省略返回类型
function doOperation(x: number, y: number) {
return x + y;
}
f(10);
doOperation(2, 3);
```
不支持参数解构的函数声明
规则：arkts-no-destruct-params
级别：错误
ArkTS要求实参必须直接传递给函数，且必须指定到形参。
TypeScript
```typescript
function drawText({ text = '', location: [x, y] = [0, 0], bold = false }) {
text;
x;
y;
bold;
}
drawText({ text: 'Hello, world!', location: [100, 50], bold: true });
```
ArkTS
```typescript
function drawText(text: String, location: number[], bold: boolean) {
let x = location[0];
let y = location[1];
text;
x;
y;
bold;
}
function main() {
drawText('Hello, world!', [100, 50], true);
}
```
不支持在函数内声明函数
规则：arkts-no-nested-funcs
级别：错误
ArkTS不支持在函数内声明函数，改用lambda函数。
TypeScript
```typescript
function addNum(a: number, b: number): void {
// 函数内声明函数
function logToConsole(message: string): void {
console.log(message);
}
let result = a + b;
// 调用函数
logToConsole('result is ' + result);
}
```
ArkTS
```typescript
function addNum(a: number, b: number): void {
// 使用lambda函数代替声明函数
let logToConsole: (message: string) => void = (message: string): void => {
console.log(message);
}
let result = a + b;
logToConsole('result is ' + result);
}
```
不支持在函数和类的静态方法中使用this
规则：arkts-no-standalone-this
级别：错误
ArkTS不支持在函数和类的静态方法中使用this，只能在类的实例方法中使用this。
TypeScript
```typescript
function foo(i: string) {
this.count = i; // 只有在开启noImplicitThis选项时会产生编译时错误
}
class A {
count: string = 'a'
m = foo
}
let a = new A();
console.log(a.count); // 打印a
a.m('b');
console.log(a.count); // 打印b
```
ArkTS
```typescript
class A {
count: string = 'a'
m(i: string): void {
this.count = i;
}
}
function main(): void {
let a = new A();
console.log(a.count);  // 打印a
a.m('b');
console.log(a.count);  // 打印b
}
```
不支持生成器函数
规则：arkts-no-generators
级别：错误
目前ArkTS不支持生成器函数，使用async或await机制进行并行任务处理。
TypeScript
```typescript
function* counter(start: number, end: number) {
for (let i = start; i <= end; i++) {
yield i;
}
}
for (let num of counter(1, 5)) {
console.log(num);
}
```
ArkTS
```typescript
async function complexNumberProcessing(num: number): Promise<number> {
// ...
return num;
}
async function foo() {
for (let i = 1; i <= 5; i++) {
await complexNumberProcessing(i);
}
}
foo()
```
使用instanceof和as进行类型保护
规则：arkts-no-is
级别：错误
ArkTS不支持is运算符，必须用instanceof运算符替代。在使用之前，必须使用as运算符将对象转换为需要的类型。
TypeScript
```typescript
class Foo {
foo: string = ''
common: string = ''
}
class Bar {
bar: string = ''
common: string = ''
}
function isFoo(arg: any): arg is Foo {
return arg.foo !== undefined;
}
function doStuff(arg: Foo | Bar) {
if (isFoo(arg)) {
console.log(arg.foo);  // OK
console.log(arg.bar);  // 编译时错误
} else {
console.log(arg.foo);  // 编译时错误
console.log(arg.bar);  // OK
}
}
doStuff({ foo: 123, common: '123' });
doStuff({ bar: 123, common: '123' });
```
ArkTS
```typescript
class Foo {
foo: string = ''
common: string = ''
}
class Bar {
bar: string = ''
common: string = ''
}
function isFoo(arg: Object): boolean {
return arg instanceof Foo;
}
function doStuff(arg: Object): void {
if (isFoo(arg)) {
let fooArg = arg as Foo;
console.log(fooArg.foo);   // OK
console.log(arg.bar);    // 编译时错误
} else {
let barArg = arg as Bar;
console.log(arg.foo);    // 编译时错误
console.log(barArg.bar);   // OK
}
}
function main(): void {
doStuff(new Foo());
doStuff(new Bar());
}
```
部分支持展开运算符
规则：arkts-no-spread
级别：错误
ArkTS仅支持使用展开运算符展开数组、Array的子类和TypedArray（例如Int32Array）。仅支持使用在以下场景中：
TypeScript
```typescript
function foo(x: number, y: number, z: number) {
// ...
}
let args: [number, number, number] = [0, 1, 2];
foo(...args);
```
ArkTS
```typescript
function log_numbers(x: number, y: number, z: number) {
// ...
}
let numbers: number[] = [1, 2, 3];
log_numbers(numbers[0], numbers[1], numbers[2]);
```
TypeScript
```typescript
let point2d = { x: 1, y: 2 };
let point3d = { ...point2d, z: 3 };
```
ArkTS
```typescript
class Point2D {
x: number = 0; y: number = 0
}
class Point3D {
x: number = 0; y: number = 0; z: number = 0
constructor(p2d: Point2D, z: number) {
this.x = p2d.x;
this.y = p2d.y;
this.z = z;
}
}
let p3d = new Point3D({ x: 1, y: 2 } as Point2D, 3);
class DerivedFromArray extends Uint16Array {};
let arr1 = [1, 2, 3];
let arr2 = new Uint16Array([4, 5, 6]);
let arr3 = new DerivedFromArray([7, 8, 9]);
let arr4 = [...arr1, 10, ...arr2, 11, ...arr3];
```
接口不能继承具有相同方法的两个接口
规则：arkts-no-extend-same-prop
级别：错误
在TypeScript中，如果一个接口继承了具有相同方法的两个接口，则该接口必须使用联合类型来声明该方法的返回值类型。在ArkTS中，由于一个接口中不能包含两个无法区分的方法（例如两个参数列表相同但返回类型不同的方法），因此，接口不能继承具有相同方法的两个接口。
TypeScript
```typescript
interface Mover {
getStatus(): { speed: number }
}
interface Shaker {
getStatus(): { frequency: number }
}
interface MoverShaker extends Mover, Shaker {
getStatus(): {
speed: number
frequency: number
}
}
class C implements MoverShaker {
private speed: number = 0
private frequency: number = 0
getStatus() {
return { speed: this.speed, frequency: this.frequency };
}
}
```
ArkTS
```typescript
class MoveStatus {
public speed: number
constructor() {
this.speed = 0;
}
}
interface Mover {
getMoveStatus(): MoveStatus
}
class ShakeStatus {
public frequency: number
constructor() {
this.frequency = 0;
}
}
interface Shaker {
getShakeStatus(): ShakeStatus
}
class MoveAndShakeStatus {
public speed: number
public frequency: number
constructor() {
this.speed = 0;
this.frequency = 0;
}
}
class C implements Mover, Shaker {
private move_status: MoveStatus
private shake_status: ShakeStatus
constructor() {
this.move_status = new MoveStatus();
this.shake_status = new ShakeStatus();
}
public getMoveStatus(): MoveStatus {
return this.move_status;
}
public getShakeStatus(): ShakeStatus {
return this.shake_status;
}
public getStatus(): MoveAndShakeStatus {
return {
speed: this.move_status.speed,
frequency: this.shake_status.frequency
};
}
}
```
不支持声明合并
规则：arkts-no-decl-merging
级别：错误
ArkTS不支持类、接口的声明合并。
TypeScript
```typescript
interface Document {
createElement(tagName: any): Element
}
interface Document {
createElement(tagName: string): HTMLElement
}
interface Document {
createElement(tagName: number): HTMLDivElement
createElement(tagName: boolean): HTMLSpanElement
createElement(tagName: string, value: number): HTMLCanvasElement
}
```
ArkTS
```typescript
interface Document {
createElement(tagName: number): HTMLDivElement
createElement(tagName: boolean): HTMLSpanElement
createElement(tagName: string, value: number): HTMLCanvasElement
createElement(tagName: string): HTMLElement
createElement(tagName: Object): Element
}
```
接口不能继承类
规则：arkts-extends-only-class
级别：错误
ArkTS不支持接口继承类，接口只能继承接口。
TypeScript
```typescript
class Control {
state: number = 0
}
interface SelectableControl extends Control {
select(): void
}
```
ArkTS
```typescript
interface Control {
state: number
}
interface SelectableControl extends Control {
select(): void
}
```
不支持构造函数类型
规则：arkts-no-ctor-signatures-funcs
级别：错误
ArkTS不支持使用构造函数类型，改用lambda函数。
TypeScript
```typescript
class Person {
constructor(
name: string,
age: number
) {}
}
type PersonCtor = new (name: string, age: number) => Person
function createPerson(Ctor: PersonCtor, name: string, age: number): Person
{
return new Ctor(name, age);
}
const person = createPerson(Person, 'John', 30);
```
ArkTS
```typescript
class Person {
constructor(
name: string,
age: number
) {}
}
type PersonCtor = (n: string, a: number) => Person
function createPerson(Ctor: PersonCtor, n: string, a: number): Person {
return Ctor(n, a);
}
let Impersonizer: PersonCtor = (n: string, a: number): Person => {
return new Person(n, a);
}
const person = createPerson(Impersonizer, 'John', 30);
```
只能使用类型相同的编译时表达式初始化枚举成员
规则：arkts-no-enum-mixed-types
级别：错误
ArkTS不支持使用在运行期间才能计算的表达式来初始化枚举成员。此外，枚举中所有显式初始化的成员必须具有相同的类型。
TypeScript
```typescript
enum E1 {
A = 0xa,
B = 0xb,
C = Math.random(),
D = 0xd,
E // 推断出0xe
}
enum E2 {
A = 0xa,
B = '0xb',
C = 0xc,
D = '0xd'
}
```
ArkTS
```typescript
enum E1 {
A = 0xa,
B = 0xb,
C = 0xc,
D = 0xd,
E // 推断出0xe
}
enum E2 {
A = '0xa',
B = '0xb',
C = '0xc',
D = '0xd'
}
```
不支持enum声明合并
规则：arkts-no-enum-merging
级别：错误
ArkTS不支持enum声明合并。
TypeScript
```typescript
enum ColorSet {
RED,
GREEN
}
enum ColorSet {
YELLOW = 2
}
enum ColorSet {
BLACK = 3,
BLUE
}
```
ArkTS
```typescript
enum ColorSet {
RED,
GREEN,
YELLOW,
BLACK,
BLUE
}
```
命名空间不能被用作对象
规则：arkts-no-ns-as-obj
级别：错误
ArkTS不支持将命名空间用作对象，可以使用类或模块。
TypeScript
```typescript
namespace MyNamespace {
export let x: number
}
let m = MyNamespace;
m.x = 2;
```
ArkTS
```typescript
namespace MyNamespace {
export let x: number
}
MyNamespace.x = 2;
```
不支持命名空间中的非声明语句
规则：arkts-no-ns-statements
级别：错误
在ArkTS中，命名空间用于定义标志符可见范围，只在编译时有效。因此，不支持命名空间中的非声明语句。可以将非声明语句写在函数中。
TypeScript
```typescript
namespace A {
export let x: number
x = 1;
}
```
ArkTS
```typescript
namespace A {
export let x: number
export function init() {
x = 1;
}
}
// 调用初始化函数来执行
A.init();
```
不支持require和import赋值表达式
规则：arkts-no-require
级别：错误
ArkTS不支持通过require导入，也不支持import赋值表达式，改用import。
TypeScript
```typescript
import m = require('mod')
```
ArkTS
```typescript
import * as m from 'mod'
```
不支持export = ...语法
规则：arkts-no-export-assignment
级别：错误
ArkTS不支持export = ...语法，改用常规的export或import。
TypeScript
```typescript
// module1
export = Point
class Point {
constructor(x: number, y: number) {}
static origin = new Point(0, 0)
}
// module2
import Pt = require('module1')
let p = Pt.Point.origin;
```
ArkTS
```typescript
// module1
export class Point {
constructor(x: number, y: number) {}
static origin = new Point(0, 0)
}
// module2
import * as Pt from 'module1'
let p = Pt.Point.origin
```
不支持ambient module声明
规则：arkts-no-ambient-decls
级别：错误
由于ArkTS本身有与JavaScript交互的机制，ArkTS不支持ambient module声明。
TypeScript
```typescript
declare module 'someModule' {
export function normalize(s: string): string;
}
```
ArkTS
```typescript
// 从原始模块中导入需要的内容
import { normalize } from 'someModule'
```
不支持在模块名中使用通配符
规则：arkts-no-module-wildcards
级别：错误
由于在ArkTS中，导入是编译时而非运行时行为，因此，不支持在模块名中使用通配符。
TypeScript
```typescript
// 声明
declare module '*!text' {
const content: string
export default content
}
// 使用代码
import fileContent from 'some.txt!text'
```
ArkTS
```typescript
// 声明
declare namespace N {
function foo(x: number): number
}
// 使用代码
import * as m from 'module'
console.log('N.foo called: ' + N.foo(42));
```
不支持通用模块定义(UMD)
规则：arkts-no-umd
级别：错误
ArkTS不支持通用模块定义（UMD）。因为在ArkTS中没有“脚本”的概念（相对于“模块”）。此外，在ArkTS中，导入是编译时而非运行时特性。改用export和import语法。
TypeScript
```typescript
// math-lib.d.ts
export const isPrime(x: number): boolean
export as namespace mathLib
// 脚本中
mathLib.isPrime(2)
```
ArkTS
```typescript
// math-lib.d.ts
namespace mathLib {
export isPrime(x: number): boolean
}
// 程序中
import { mathLib } from 'math-lib'
mathLib.isPrime(2)
```
不支持new.target
规则：arkts-no-new-target
级别：错误
ArkTS没有原型的概念，因此不支持new.target。此特性不符合静态类型的原则。
不支持确定赋值断言
规则：arkts-no-definite-assignment
级别：警告
ArkTS不支持确定赋值断言，例如：let v!: T。改为在声明变量的同时为变量赋值。
TypeScript
```typescript
let x!: number // 提示：在使用前将x初始化
initialize();
function initialize() {
x = 10;
}
console.log('x = ' + x);
```
ArkTS
```typescript
function initialize(): number {
return 10;
}
let x: number = initialize();
console.log('x = ' + x);
```
不支持在原型上赋值
规则：arkts-no-prototype-assignment
级别：错误
ArkTS没有原型的概念，因此不支持在原型上赋值。此特性不符合静态类型的原则。
TypeScript
```typescript
let C = function(p) {
this.p = p; // 只有在开启noImplicitThis选项时会产生编译时错误
}
C.prototype = {
m() {
console.log(this.p);
}
}
C.prototype.q = function(r: string) {
return this.p == r;
}
```
ArkTS
```typescript
class C {
p: string = ''
m() {
console.log(this.p);
}
q(r: string) {
return this.p == r;
}
}
```
不支持globalThis
规则：arkts-no-globalthis
级别：警告
由于ArkTS不支持动态更改对象的布局，因此不支持全局作用域和globalThis。
TypeScript
```typescript
// 全局文件中
var abc = 100;
// 从上面引用'abc'
let x = globalThis.abc;
```
ArkTS
```typescript
// file1
export let abc: number = 100;
// file2
import * as M from 'file1'
let x = M.abc;
```
不支持一些utility类型
规则：arkts-no-utility-types
级别：错误
ArkTS仅支持Partial、Required、Readonly和Record，不支持TypeScript中其他的Utility Types。
对于Partial<T>类型，泛型参数T必须为类或者接口类型。
对于Record类型的对象，通过索引访问到的值的类型是包含undefined的联合类型。
不支持对函数声明属性
规则：arkts-no-func-props
级别：错误
由于ArkTS不支持动态改变函数对象布局，因此，不支持对函数声明属性。
不支持Function.apply和Function.call
规则：arkts-no-func-apply-call
级别：错误
ArkTS不允许使用标准库函数Function.apply和Function.call。标准库使用这些函数来显式设置被调用函数的this参数。在ArkTS中，this的语义仅限于传统的OOP风格，函数体中禁止使用this。
不支持Function.bind
规则：arkts-no-func-bind
级别：警告
ArkTS不允许使用标准库函数Function.bind。标准库使用这些函数来显式设置被调用函数的this参数。在ArkTS中，this的语义仅限于传统的OOP风格，函数体中禁止使用this。
不支持as const断言
规则：arkts-no-as-const
级别：错误
ArkTS不支持as const断言。在标准TypeScript中，as const用于标注字面量的相应字面量类型，而ArkTS不支持字面量类型。
TypeScript
```typescript
// 'hello'类型
let x = 'hello' as const;
// 'readonly [10, 20]'类型
let y = [10, 20] as const;
// '{ readonly text: 'hello' }'类型
let z = { text: 'hello' } as const;
```
ArkTS
```typescript
// 'string'类型
let x: string = 'hello';
// 'number[]'类型
let y: number[] = [10, 20];
class Label {
text: string = ''
}
// 'Label'类型
let z: Label = {
text: 'hello'
}
```
不支持导入断言
规则：arkts-no-import-assertions
级别：错误
由于在ArkTS中，导入是编译时而非运行时特性，因此，ArkTS不支持导入断言。在运行时检查导入的API是否正确，对于静态类型的语言来说是没有意义的。改用常规的import语法。
TypeScript
```typescript
import { obj } from 'something.json' assert { type: 'json' }
```
ArkTS
```typescript
// 编译时将检查导入T的正确性
import { something } from 'module'
```
限制使用标准库
规则：arkts-limited-stdlib
级别：错误
ArkTS不允许使用TypeScript或JavaScript标准库中的某些接口。大部分接口与动态特性有关。ArkTS中禁止使用以下接口：
全局对象的属性和方法：eval
Object：__proto__、__defineGetter__、__defineSetter__、
__lookupGetter__、__lookupSetter__、assign、create、
defineProperties、defineProperty、freeze、
fromEntries、getOwnPropertyDescriptor、getOwnPropertyDescriptors、
getOwnPropertySymbols、getPrototypeOf、
hasOwnProperty、is、isExtensible、isFrozen、
isPrototypeOf、isSealed、preventExtensions、
propertyIsEnumerable、seal、setPrototypeOf
Reflect：apply、construct、defineProperty、deleteProperty、
getOwnPropertyDescriptor、getPrototypeOf、
isExtensible、preventExtensions、
setPrototypeOf
Proxy：handler.apply()、handler.construct()、
handler.defineProperty()、handler.deleteProperty()、handler.get()、
handler.getOwnPropertyDescriptor()、handler.getPrototypeOf()、
handler.has()、handler.isExtensible()、handler.ownKeys()、
handler.preventExtensions()、handler.set()、handler.setPrototypeOf()
强制进行严格类型检查
规则：arkts-strict-typing
级别：错误
在编译阶段，会进行TypeScript严格模式的类型检查，包括：
noImplicitReturns,
strictFunctionTypes,
strictNullChecks,
strictPropertyInitialization。
TypeScript
```typescript
// 只有在开启noImplicitReturns选项时会产生编译时错误
function foo(s: string): string {
if (s != '') {
console.log(s);
return s;
} else {
console.log(s);
}
}
let n: number = null; // 只有在开启strictNullChecks选项时会产生编译时错误
```
ArkTS
```typescript
function foo(s: string): string {
console.log(s);
return s;
}
let n1: number | null = null;
let n2: number = 0;
```
在定义类时，如果无法在声明时或者构造函数中初始化某实例属性，那么可以使用确定赋值断言符!来消除strictPropertyInitialization的报错。
使用确定赋值断言符会增加代码错误的风险，开发者需要保证该实例属性在被使用前已被赋值，否则可能会产生运行时异常。
使用确定赋值断言符会增加运行时的类型检查，从而增加额外的运行时开销，所以应尽可能避免使用确定赋值断言符。
使用确定赋值断言符将产生warning: arkts-no-definite-assignment。
TypeScript
```typescript
class C {
name: string  // 只有在开启strictPropertyInitialization选项时会产生编译时错误
age: number   // 只有在开启strictPropertyInitialization选项时会产生编译时错误
}
let c = new C();
```
ArkTS
```typescript
class C {
name: string = ''
age!: number      // warning: arkts-no-definite-assignment
initAge(age: number) {
this.age = age;
}
}
let c = new C();
c.initAge(10);
```
不允许通过注释关闭类型检查
规则：arkts-strict-typing-required
级别：错误
在ArkTS中，类型检查不是可选项。不允许通过注释关闭类型检查，不支持使用@ts-ignore和@ts-nocheck。
TypeScript
```typescript
// @ts-nocheck
// ...
// 关闭了类型检查后的代码
// ...
let s1: string = null; // 没有报错
// @ts-ignore
let s2: string = null; // 没有报错
```
ArkTS
```typescript
let s1: string | null = null; // 没有报错，合适的类型
let s2: string = null; // 编译时报错
```
允许.ets文件import.ets/.ts/.js文件源码, 不允许.ts/.js文件import.ets文件源码
规则：arkts-no-ts-deps
级别：错误
.ets文件可以import.ets/.ts/.js文件源码，但是.ts/.js文件不允许import.ets文件源码。
TypeScript
```typescript
// app.ets
export class C {
// ...
}
// lib.ts
import { C } from 'app'
```
ArkTS
```typescript
// lib1.ets
export class C {
// ...
}
// lib2.ets
import { C } from 'lib1'
```
class不能被用作对象
规则：arkts-no-classes-as-obj
级别：警告
在ArkTS中，class声明的是一个新的类型，不是一个值。因此，不支持将class用作对象（例如将class赋值给一个对象）。
不支持在import语句前使用其他语句
规则：arkts-no-misplaced-imports
级别：错误
在ArkTS中，除动态import语句外，所有import语句需要放在所有其他语句之前。
TypeScript
```typescript
class C {
s: string = ''
n: number = 0
}
import foo from 'module1'
```
ArkTS
```typescript
import foo from 'module1'
class C {
s: string = ''
n: number = 0
}
import('module2').then(() => {}).catch(() => {})  // 动态import
```
限制使用ESObject类型
规则：arkts-limited-esobj
级别：警告
为了防止动态对象（来自.ts/.js文件）在静态代码（.ets文件）中的滥用，ESObject类型在ArkTS中的使用是受限的。唯一允许使用ESObject类型的场景是将其用在局部变量的声明中。ESObject类型变量的赋值也是受限的，只能被来自跨语言调用的对象赋值，例如：ESObject、any、unknown、匿名类型等类型的变量。禁止使用静态类型的值（在.ets文件中定义的）初始化ESObject类型变量。ESObject类型变量只能用在跨语言调用的函数里或者赋值给另一个ESObject类型变量。
ArkTS
```typescript
// lib.d.ts
declare function foo(): any;
declare function bar(a: any): number;
// main.ets
let e0: ESObject = foo(); // 编译时错误：ESObject类型只能用于局部变量
function f() {
let e1 = foo();        // 编译时错误：e1的类型是any
let e2: ESObject = 1;  // 编译时错误：不能用非动态值初始化ESObject类型变量
let e3: ESObject = {}; // 编译时错误：不能用非动态值初始化ESObject类型变量
let e4: ESObject = []; // 编译时错误：不能用非动态值初始化ESObject类型变量
let e5: ESObject = ''; // 编译时错误：不能用非动态值初始化ESObject类型变量
e5['prop'];            // 编译时错误：不能访问ESObject类型变量的属性
e5[1];                 // 编译时错误：不能访问ESObject类型变量的属性
e5.prop;               // 编译时错误：不能访问ESObject类型变量的属性
let e6: ESObject = foo(); // OK，显式标注ESObject类型
let e7 = e6;              // OK，使用ESObject类型赋值
bar(e7);                  // OK，ESObject类型变量传给跨语言调用的函数
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-more-cases
爬取时间: 2025-04-27 21:46:19
来源: Huawei Developer
本文通过更多应用场景中的案例，提供在ArkTS语法规则下将TS代码适配成ArkTS代码的建议。各章以ArkTS语法规则英文名称命名，每个案例提供适配前的TS代码和适配后的ArkTS代码。
arkts-identifiers-as-prop-names
应用代码
```typescript
interface W {
bundleName: string
action: string
entities: string[]
}
let wantInfo: W = {
'bundleName': 'com.huawei.hmos.browser',
'action': 'ohos.want.action.viewData',
'entities': ['entity.system.browsable']
}
```
建议改法
```typescript
interface W {
bundleName: string
action: string
entities: string[]
}
let wantInfo: W = {
bundleName: 'com.huawei.hmos.browser',
action: 'ohos.want.action.viewData',
entities: ['entity.system.browsable']
}
```
arkts-no-any-unknown
按照业务逻辑，将代码中的any, unknown改为具体的类型
```typescript
function printObj(obj: any) {
console.log(obj);
}
printObj('abc');
```
建议改法
```typescript
function printObj(obj: string) {
console.log(obj);
}
printObj('abc');
```
标注JSON.parse返回值类型
应用代码
```typescript
class A {
v: number = 0
s: string = ''
foo(str: string) {
let tmpStr = JSON.parse(str);
if (tmpStr.add != undefined) {
this.v = tmpStr.v;
this.s = tmpStr.s;
}
}
}
```
建议改法
```typescript
class A {
v: number = 0
s: string = ''
foo(str: string) {
let tmpStr: Record<string, Object> = JSON.parse(str);
if (tmpStr.add != undefined) {
this.v = tmpStr.v as number;
this.s = tmpStr.s as string;
}
}
}
```
使用Record类型
应用代码
```typescript
function printProperties(obj: any) {
console.log(obj.name);
console.log(obj.value);
}
```
建议改法
```typescript
function printProperties(obj: Record<string, Object>) {
console.log(obj.name as string);
console.log(obj.value as string);
}
```
arkts-no-call-signature
使用函数类型来替代。
应用代码
```typescript
interface I {
(value: string): void;
}
function foo(fn: I) {
fn('abc');
}
foo((value: string) => {
console.log(value);
})
```
建议改法
```typescript
type I = (value: string) => void
function foo(fn: I) {
fn('abc');
}
foo((value: string) => {
console.log(value);
})
```
arkts-no-ctor-signatures-type
应用代码
```typescript
class Controller {
value: string = ''
constructor(value: string) {
this.value = value;
}
}
type ControllerConstructor = {
new (value: string): Controller;
}
class Menu {
controller: ControllerConstructor = Controller
createController() {
if (this.controller) {
return new this.controller(123);
}
return null;
}
}
let t = new Menu();
console.log(t.createController()!.value);
```
建议改法
```typescript
class Controller {
value: string = ''
constructor(value: string) {
this.value = value;
}
}
type ControllerConstructor = () => Controller;
class Menu {
controller: ControllerConstructor = () => {
return new Controller('abc');
}
createController() {
if (this.controller) {
return this.controller();
}
return null;
}
}
let t: Menu = new Menu();
console.log(t.createController()!.value);
```
arkts-no-indexed-signatures
使用Record类型来替代。
应用代码
```typescript
function foo(data: { [key: string]: string }) {
data['a'] = 'a';
data['b'] = 'b';
data['c'] = 'c';
}
```
建议改法
```typescript
function foo(data: Record<string, string>) {
data['a'] = 'a';
data['b'] = 'b';
data['c'] = 'c';
}
```
arkts-no-typing-with-this
应用代码
```typescript
class C {
getInstance(): this {
return this;
}
}
```
建议改法
```typescript
class C {
getInstance(): C {
return this;
}
}
```
arkts-no-ctor-prop-decls
应用代码
```typescript
class Person {
constructor(readonly name: string) {}
getName(): string {
return this.name;
}
}
```
建议改法
```typescript
class Person {
name: string
constructor(name: string) {
this.name = name;
}
getName(): string {
return this.name;
}
}
```
arkts-no-ctor-signatures-iface
应用代码
```typescript
class Controller {
value: string = ''
constructor(value: string) {
this.value = value;
}
}
interface ControllerConstructor {
new (value: string): Controller;
}
class Menu {
controller: ControllerConstructor = Controller
createController() {
if (this.controller) {
return new this.controller('abc');
}
return null;
}
}
let t = new Menu();
console.log(t.createController()!.value);
```
建议改法
```typescript
class Controller {
value: string = ''
constructor(value: string) {
this.value = value;
}
}
type ControllerConstructor = () => Controller;
class Menu {
controller: ControllerConstructor = () => {
return new Controller('abc');
}
createController() {
if (this.controller) {
return this.controller();
}
return null;
}
}
let t: Menu = new Menu();
console.log(t.createController()!.value);
```
arkts-no-props-by-index
可以转换成Record类型，用来访问对象的属性。
应用代码
```typescript
import { router } from '@kit.ArkUI';
let params: Object = router.getParams();
let funNum: number = params['funNum'];
let target: string = params['target'];
```
建议改法
```typescript
import { router } from '@kit.ArkUI';
let params = router.getParams() as Record<string, string | number>;
let funNum: number = params.funNum as number;
let target: string = params.target as string;
```
arkts-no-inferred-generic-params
应用代码
```typescript
class A {
str: string = ''
}
class B extends A {}
class C extends A {}
let arr: Array<A> = [];
let originMenusMap:Map<string, C> = new Map(arr.map(item => [item.str, (item instanceof C) ? item: null]));
```
建议改法
```typescript
class A {
str: string = ''
}
class B extends A {}
class C extends A {}
let arr: Array<A> = [];
let originMenusMap: Map<string, C | null> = new Map<string, C | null>(arr.map<[string, C | null]>(item => [item.str, (item instanceof C) ? item: null]));
```
原因
(item instanceof C) ? item: null 需要声明类型为C | null，由于编译器无法推导出map的泛型类型参数，需要显式标注。
arkts-no-regexp-literals
应用代码
```typescript
let regex: RegExp = /\s*/g;
```
建议改法
```typescript
let regexp: RegExp = new RegExp('\\s*','g');
```
原因
如果正则表达式中使用了标志符，需要将其作为new RegExp()的参数。
arkts-no-untyped-obj-literals
从SDK中导入类型，标注object literal类型
应用代码
```typescript
const area = {
pixels: new ArrayBuffer(8),
offset: 0,
stride: 8,
region: { size: { height: 1,width:2 }, x: 0, y: 0 }
}
```
建议改法
```typescript
import { image } from '@kit.ImageKit';
const area: image.PositionArea = {
pixels: new ArrayBuffer(8),
offset: 0,
stride: 8,
region: { size: { height: 1, width: 2 }, x: 0, y: 0 }
}
```
用class为object literal标注类型，需要class的构造函数无参数
应用代码
```typescript
class Test {
value: number = 1
constructor(value: number) {
this.value = value;
}
}
let t: Test = { value: 2 };
```
建议改法1
```typescript
// 去除构造函数
class Test {
value: number = 1
}
let t: Test = { value: 2 };
```
建议改法2
```typescript
// 使用new
class Test {
value: number = 1
constructor(value: number) {
this.value = value;
}
}
let t: Test = new Test(2);
```
原因
```typescript
class C {
value: number = 1
constructor(n: number) {
if (n < 0) {
throw new Error('Negative');
}
this.value = n;
}
}
let s: C = new C(-2);     //抛出异常
let t: C = { value: -2 };    //ArkTS不支持
```
例如在上面的例子中，如果允许使用C来标注object literal的类型，那么上述代码中的变量t会导致行为的二义性。ArkTS禁止通过object literal来绕过这一行为。
用class/interface为object literal标注类型，需要使用identifier作为object literal的key
应用代码
```typescript
class Test {
value: number = 0
}
let arr: Test[] = [
{
'value': 1
},
{
'value': 2
},
{
'value': 3
}
]
```
建议改法
```typescript
class Test {
value: number = 0
}
let arr: Test[] = [
{
value: 1
},
{
value: 2
},
{
value: 3
}
]
```
使用Record为object literal标注类型，需要使用字符串作为object literal的key
应用代码
```typescript
let obj: Record<string, number | string> = {
value: 123,
name: 'abc'
}
```
建议改法
```typescript
let obj: Record<string, number | string> = {
'value': 123,
'name': 'abc'
}
```
函数参数类型包含index signature
应用代码
```typescript
function foo(obj: { [key: string]: string}): string {
if (obj != undefined && obj != null) {
return obj.value1 + obj.value2;
}
return '';
}
```
建议改法
```typescript
function foo(obj: Record<string, string>): string {
if (obj != undefined && obj != null) {
return obj.value1 + obj.value2;
}
return '';
}
```
函数实参使用了object literal
应用代码
```typescript
(fn) => {
fn({ value: 123, name:'' });
}
```
建议改法
```typescript
class T {
value: number = 0
name: string = ''
}
(fn: (v: T) => void) => {
fn({ value: 123, name: '' });
}
```
class/interface 中包含方法
应用代码
```typescript
interface T {
foo(value: number): number
}
let t:T = { foo: (value) => { return value } };
```
建议改法1
```typescript
interface T {
foo: (value: number) => number
}
let t:T = { foo: (value) => { return value } };
```
建议改法2
```typescript
class T {
foo: (value: number) => number = (value: number) => {
return value;
}
}
let t:T = new T();
```
原因
class/interface中声明的方法应该被所有class的实例共享。ArkTS不支持通过object literal改写实例方法。ArkTS支持函数类型的属性。
export default对象
应用代码
```typescript
export default {
onCreate() {
// ...
},
onDestroy() {
// ...
}
}
```
建议改法
```typescript
class Test {
onCreate() {
// ...
}
onDestroy() {
// ...
}
}
export default new Test()
```
通过导入namespace获取类型
应用代码
```typescript
// test.d.ets
declare namespace test {
interface I {
id: string;
type: number;
}
function foo(name: string, option: I): void;
}
export default test;
// app.ets
import { test } from 'test';
let option = { id: '', type: 0 };
test.foo('', option);
```
建议改法
```typescript
// test.d.ets
declare namespace test {
interface I {
id: string;
type: number;
}
function foo(name: string, option: I): void;
}
export default test;
// app.ets
import { test } from 'test';
let option: test.I = { id: '', type: 0 };
test.foo('', option);
```
原因
对象字面量缺少类型，根据test.foo分析可以得知，option的类型来源于声明文件，那么只需要将类型导入即可。
注意到在test.d.ets中，I是定义在namespace中的，所以在ets文件中，先导入namespace，再通过名称获取相应的类型。
object literal传参给Object类型
应用代码
```typescript
function emit(event: string, ...args: Object[]): void {}
emit('', {
'action': 11,
'outers': false
});
```
建议改法
```typescript
function emit(event: string, ...args: Object[]): void {}
let emitArg: Record<string, number | boolean> = {
'action': 11,
'outers': false
}
emit('', emitArg);
```
arkts-no-obj-literals-as-types
应用代码
```typescript
type Person = { name: string, age: number }
```
建议改法
```typescript
interface Person {
name: string,
age: number
}
```
arkts-no-noninferrable-arr-literals
应用代码
```typescript
let permissionList = [
{ name: '设备信息', value: '用于分析设备的续航、通话、上网、SIM卡故障等' },
{ name: '麦克风', value: '用于反馈问题单时增加语音' },
{ name: '存储', value: '用于反馈问题单时增加本地文件附件' }
]
```
建议改法
为对象字面量声明类型
```typescript
class PermissionItem {
name?: string
value?: string
}
let permissionList: PermissionItem[] = [
{ name: '设备信息', value: '用于分析设备的续航、通话、上网、SIM卡故障等' },
{ name: '麦克风', value: '用于反馈问题单时增加语音' },
{ name: '存储', value: '用于反馈问题单时增加本地文件附件' }
]
```
arkts-no-method-reassignment
应用代码
```typescript
class C {
add(left: number, right: number): number {
return left + right;
}
}
function sub(left: number, right: number): number {
return left - right;
}
let c1 = new C();
c1.add = sub;
```
建议改法
```typescript
class C {
add: (left: number, right: number) => number =
(left: number, right: number) => {
return left + right;
}
}
function sub(left: number, right: number): number {
return left - right;
}
let c1 = new C();
c1.add = sub;
```
arkts-no-polymorphic-unops
应用代码
```typescript
let a = +'5';
let b = -'5';
let c = ~'5';
let d = +'string';
```
建议改法
```typescript
let a = Number.parseInt('5');
let b = -Number.parseInt('5');
let c = ~Number.parseInt('5');
let d = new Number('string');
```
arkts-no-type-query
应用代码
```typescript
// module1.ts
class C {
value: number = 0
}
export let c = new C()
// module2.ts
import { c } from './module1'
let t: typeof c = { value: 123 };
```
建议改法
```typescript
// module1.ts
class C {
value: number = 0
}
export { C }
// module2.ts
import { C } from './module1'
let t: C = { value: 123 };
```
arkts-no-in
使用Object.keys判断属性是否存在
应用代码
```typescript
function test(str: string, obj: Record<string, Object>) {
return str in obj;
}
```
建议改法
```typescript
function test(str: string, obj: Record<string, Object>) {
for (let i of Object.keys(obj)) {
if (i == str) {
return true;
}
}
return false;
}
```
arkts-no-destruct-assignment
应用代码
```typescript
let map = new Map<string, string>([['a', 'a'], ['b', 'b']]);
for (let [key, value] of map) {
console.log(key);
console.log(value);
}
```
建议改法
使用数组
```typescript
let map = new Map<string, string>([['a', 'a'], ['b', 'b']]);
for (let arr of map) {
let key = arr[0];
let value = arr[1];
console.log(key);
console.log(value);
}
```
arkts-no-types-in-catch
应用代码
```typescript
import { BusinessError } from '@kit.BasicServicesKit'
try {
// ...
} catch (e: BusinessError) {
console.error(e.message, e.code);
}
```
建议改法
```typescript
import { BusinessError } from '@kit.BasicServicesKit'
try {
// ...
} catch (error) {
let e: BusinessError = error as BusinessError;
console.error(e.message, e.code);
}
```
arkts-no-for-in
应用代码
```typescript
interface Person {
[name: string]: string
}
let p: Person = {
name: 'tom',
age: '18'
};
for (let t in p) {
console.log(p[t]);  // log: "tom", "18"
}
```
建议改法
```typescript
let p: Record<string, string> = {
'name': 'tom',
'age': '18'
};
for (let ele of Object.entries(p)) {
console.log(ele[1]);  // log: "tom", "18"
}
```
arkts-no-mapped-types
应用代码
```typescript
class C {
a: number = 0
b: number = 0
c: number = 0
}
type OptionsFlags = {
[Property in keyof C]: string
}
```
建议改法
```typescript
class C {
a: number = 0
b: number = 0
c: number = 0
}
type OptionsFlags = Record<keyof C, string>
```
arkts-limited-throw
应用代码
```typescript
import { BusinessError } from '@kit.BasicServicesKit'
function ThrowError(error: BusinessError) {
throw error;
}
```
建议改法
```typescript
import { BusinessError } from '@kit.BasicServicesKit'
function ThrowError(error: BusinessError) {
throw error as Error;
}
```
原因
throw语句中值的类型必须为Error或者其继承类，如果继承类是一个泛型，会有编译期报错。建议使用as将类型转换为Error。
arkts-no-standalone-this
函数内使用this
应用代码
```typescript
function foo() {
console.log(this.value);
}
let obj = { value: 'abc' };
foo.apply(obj);
```
建议改法1
使用类的方法实现,如果该方法被多个类使用,可以考虑采用继承的机制
```typescript
class Test {
value: string = ''
constructor (value: string) {
this.value = value
}
foo() {
console.log(this.value);
}
}
let obj: Test = new Test('abc');
obj.foo();
```
建议改法2
将this作为参数传入
```typescript
function foo(obj: Test) {
console.log(obj.value);
}
class Test {
value: string = ''
}
let obj: Test = { value: 'abc' };
foo(obj);
```
建议改法3
将属性作为参数传入
```typescript
function foo(value: string) {
console.log(value);
}
class Test {
value: string = ''
}
let obj: Test = { value: 'abc' };
foo(obj.value);
```
class的静态方法内使用this
应用代码
```typescript
class Test {
static value: number = 123
static foo(): number {
return this.value
}
}
```
建议改法
```typescript
class Test {
static value: number = 123
static foo(): number {
return Test.value
}
}
```
arkts-no-spread
应用代码
```typescript
// test.d.ets
declare namespace test {
interface I {
id: string;
type: number;
}
function foo(): I;
}
export default test
// app.ets
import test from 'test';
let t: test.I = {
...test.foo(),
type: 0
}
```
建议改法
```typescript
// test.d.ets
declare namespace test {
interface I {
id: string;
type: number;
}
function foo(): I;
}
export default test
// app.ets
import test from 'test';
let t: test.I = test.foo();
t.type = 0;
```
原因
ArkTS中，对象布局在编译期是确定的。如果需要将一个对象的所有属性展开赋值给另一个对象可以通过逐个属性赋值语句完成。在本例中，需要展开的对象和赋值的目标对象类型恰好相同，可以通过改变该对象属性的方式重构代码。
arkts-no-ctor-signatures-funcs
在class内声明属性，而不是在构造函数上。
应用代码
```typescript
class Controller {
value: string = ''
constructor(value: string) {
this.value = value
}
}
type ControllerConstructor = new (value: string) => Controller;
class Menu {
controller: ControllerConstructor = Controller
createController() {
if (this.controller) {
return new this.controller('abc');
}
return null;
}
}
let t = new Menu()
console.log(t.createController()!.value)
```
建议改法
```typescript
class Controller {
value: string = ''
constructor(value: string) {
this.value = value;
}
}
type ControllerConstructor = () => Controller;
class Menu {
controller: ControllerConstructor = () => { return new Controller('abc') }
createController() {
if (this.controller) {
return this.controller();
}
return null;
}
}
let t: Menu = new Menu();
console.log(t.createController()!.value);
```
arkts-no-globalthis
由于无法为globalThis添加静态类型，只能通过查找的方式访问globalThis的属性，造成额外的性能开销。另外，无法为globalThis的属性标记类型，无法保证对这些属性操作的安全和高性能。因此ArkTS不支持globalThis。
1.  建议按照业务逻辑根据import/export语法实现数据在不同模块的传递。
2.  必要情况下，可以通过构造的单例对象来实现全局对象的功能。(说明：不能在har中定义单例对象，har在打包时会在不同的hap中打包两份，无法实现单例。)
构造单例对象
```typescript
// 构造单例对象
export class GlobalContext {
private constructor() {}
private static instance: GlobalContext;
private _objects = new Map<string, Object>();
public static getContext(): GlobalContext {
if (!GlobalContext.instance) {
GlobalContext.instance = new GlobalContext();
}
return GlobalContext.instance;
}
getObject(value: string): Object | undefined {
return this._objects.get(value);
}
setObject(key: string, objectClass: Object): void {
this._objects.set(key, objectClass);
}
}
```
应用代码
```typescript
// file1.ts
export class Test {
value: string = '';
foo(): void {
globalThis.value = this.value;
}
}
// file2.ts
globalThis.value;
```
建议改法
```typescript
// file1.ts
import { GlobalContext } from '../GlobalContext'
export class Test {
value: string = '';
foo(): void {
GlobalContext.getContext().setObject('value', this.value);
}
}
// file2.ts
import { GlobalContext } from '../GlobalContext'
GlobalContext.getContext().getObject('value');
```
arkts-no-func-apply-bind-call
使用标准库中接口
应用代码
```typescript
let arr: number[] = [1, 2, 3, 4];
let str = String.fromCharCode.apply(null, Array.from(arr));
```
建议改法
```typescript
let arr: number[] = [1, 2, 3, 4];
let str = String.fromCharCode(...Array.from(arr));
```
bind定义方法
应用代码
```typescript
class A {
value: string = ''
foo: Function = () => {}
}
class Test {
value: string = '1234'
obj: A = {
value: this.value,
foo: this.foo.bind(this)
}
foo() {
console.log(this.value);
}
}
```
建议改法1
```typescript
class A {
value: string = ''
foo: Function = () => {}
}
class Test {
value: string = '1234'
obj: A = {
value: this.value,
foo: (): void => this.foo()
}
foo() {
console.log(this.value);
}
}
```
建议改法2
```typescript
class A {
value: string = ''
foo: Function = () => {}
}
class Test {
value: string = '1234'
foo: () => void = () => {
console.log(this.value);
}
obj: A = {
value: this.value,
foo: this.foo
}
}
```
使用apply
应用代码
```typescript
class A {
value: string;
constructor (value: string) {
this.value = value;
}
foo() {
console.log(this.value);
}
}
let a1 = new A('1');
let a2 = new A('2');
a1.foo();
a1.foo.apply(a2);
```
建议改法
```typescript
class A {
value: string;
constructor (value: string) {
this.value = value;
}
foo() {
this.fooApply(this);
}
fooApply(a: A) {
console.log(a.value);
}
}
let a1 = new A('1');
let a2 = new A('2');
a1.foo();
a1.fooApply(a2);
```
arkts-limited-stdlib
Object.fromEntries()
应用代码
```typescript
let entries = new Map([
['foo', 123],
['bar', 456]
]);
let obj = Object.fromEntries(entries);
```
建议改法
```typescript
let entries = new Map([
['foo', 123],
['bar', 456]
]);
let obj: Record<string, Object> = {};
entries.forEach((value, key) => {
if (key != undefined && key != null) {
obj[key] = value;
}
})
```
使用Number的属性和方法
ArkTS不允许使用全局对象的属性和方法： Infinity, NaN, isFinite, isNaN, parseFloat, parseInt
可以使用Number的属性和方法： Infinity, NaN, isFinite, isNaN, parseFloat, parseInt
应用代码
```typescript
NaN;
isFinite(123);
parseInt('123');
```
建议改法
```typescript
Number.NaN;
Number.isFinite(123);
Number.parseInt('123');
```
arkts-strict-typing(StrictModeError)
strictPropertyInitialization
应用代码
```typescript
interface I {
name:string
}
class A {}
class Test {
a: number;
b: string;
c: boolean;
d: I;
e: A;
}
```
建议改法
```typescript
interface I {
name:string
}
class A {}
class Test {
a: number;
b: string;
c: boolean;
d: I = { name:'abc' };
e: A | null = null;
constructor(a:number, b:string, c:boolean) {
this.a = a;
this.b = b;
this.c = c;
}
}
```
Type *** | null is not assignable to type ***
应用代码
```typescript
class A {
bar() {}
}
function foo(n: number) {
if (n === 0) {
return null;
}
return new A();
}
function getNumber() {
return 5;
}
let a:A = foo(getNumber());
a.bar();
```
建议改法
```typescript
class A {
bar() {}
}
function foo(n: number) {
if (n === 0) {
return null;
}
return new A();
}
function getNumber() {
return 5;
}
let a: A | null = foo(getNumber());
a?.bar();
```
严格属性初始化检查
在class中，如果一个属性没有初始化，且没有在构造函数中被赋值，那么ArkTS将报错。
建议改法
1.一般情况下，建议按照业务逻辑在声明时初始化属性，或者在构造函数中为属性赋值。如：
```typescript
//code with error
class Test {
value: number
flag: boolean
}
//方式一，在声明时初始化
class Test {
value: number = 0
flag: boolean = false
}
//方式二，在构造函数中赋值
class Test {
value: number
flag: boolean
constructor(value: number, flag: boolean) {
this.value = value;
this.flag = flag;
}
}
```
2.对于对象类型（包括函数类型）A，如果不确定如何初始化，建议按照以下方式之一进行初始化
​ 方式(i) prop: A | null = null
​ 方式(ii) prop?: A
​ 方式三(iii) prop： A | undefined = undefined
- 从性能角度来说，null类型只用在编译期的类型检查中，对虚拟机的性能无影响。而undefined | A被视为联合类型，运行时可能有额外的开销。
- 从代码可读性、简洁性的角度来说，prop?:A是prop： A | undefined = undefined的语法糖，推荐使用可选属性的写法
严格函数类型检查
应用代码
```typescript
function foo(fn: (value?: string) => void, value: string): void {}
foo((value: string) => {}, ''); //error
```
建议改法
```typescript
function foo(fn: (value?: string) => void, value: string): void {}
foo((value?: string) => {}, '');
```
原因
例如，在以下的例子中，如果编译期不开启严格函数类型的检查，那么该段代码可以编译通过，但是在运行时会产生非预期的行为。具体来看，在foo的函数体中，一个undefined被传入fn（这是可以的，因为fn可以接受undefined），但是在代码第6行foo的调用点，传入的(value： string) => { console.log(value.toUpperCase()) }的函数实现中，始终将参数value当做string类型，允许其调用toUpperCase方法。如果不开启严格函数类型的检查，那么这段代码在运行时，会出现在undefined上无法找到属性的错误。
```typescript
function foo(fn: (value?: string) => void, value: string): void {
let v: string | undefined = undefined;
fn(v);
}
foo((value: string) => { console.log(value.toUpperCase()) }, ''); // Cannot read properties of undefined (reading 'toUpperCase')
```
为了避免运行时的非预期行为，如果在编译时开启了严格类型检查，这段代码将编译不通过，从而可以提醒开发者修改代码，保证程序安全。
严格空值检查
应用代码
```typescript
class Test {
private value?: string
public printValue () {
console.log(this.value.toLowerCase());
}
}
let t = new Test();
t.printValue();
```
建议改法
在编写代码时，建议减少可空类型的使用。如果对变量、属性标记了可空类型，那么在使用它们之间，需要进行空值的判断，根据是否为空值处理不同的逻辑。
```typescript
class Test {
private value?: string
public printValue () {
if (this.value) {
console.log(this.value.toLowerCase());
}
}
}
let t = new Test();
t.printValue();
```
原因
在第一段代码中，如果编译期不开启严格空值检查，那么该段代码可以编译通过，但是在运行时会产生非预期的行为。这是因为t的属性value为undefined（这是因为value?: string是value: string | undefined = undefined的语法糖），在第11行调用printValue方法时，由于在该方法体内未对this.value的值进行空值检查，而直接按照string类型访问其属性，这就导致了运行时的错误。为了避免运行时的非预期行为，如果在编译时开起来严格空值检查，这段代码将编译不通过从而可以提醒开发者修改代码（如按照第二段代码的方式），保证程序安全。
函数返回类型不匹配
应用代码
```typescript
class Test {
handleClick: (action: string, externInfo?: string) => void | null = null;
}
```
建议改法
在这种写法下，函数返回类型被解析为 void | undefined，需要添加括号用来区分union类型。
```typescript
class Test {
handleClick: ((action: string, externInfo?: string) => void) | null = null;
}
```
'***' is of type 'unknown'
应用代码
```typescript
try {
} catch (error) {
console.log(error.message);
}
```
建议改法
```typescript
import { BusinessError } from '@kit.BasicServicesKit'
try {
} catch (error) {
console.log((error as BusinessError).message);
}
```
Type '*** | null' is not assignable to type '***'
应用代码
```typescript
class A {
value: number
constructor(value: number) {
this.value = value;
}
}
function foo(v: number): A | null {
if (v > 0) {
return new A(v);
}
return null;
}
let a: A = foo();
```
建议改法1
修改变量a的类型：let a: A | null = foo()。
```typescript
class A {
value: number
constructor(value: number) {
this.value = value;
}
}
function foo(v: number): A | null {
if (v > 0) {
return new A(v);
}
return null;
}
let a: A | null = foo(123);
if (a != null) {
// 非空分支
} else {
// 处理null
}
```
建议改法2
如果可以断定此处调用foo一定返回非空值，可以使用非空断言!。
```typescript
class A {
value: number
constructor(value: number) {
this.value = value;
}
}
function foo(v: number): A | null {
if (v > 0) {
return new A(v);
}
return null;
}
let a: A = foo(123)!;
```
Cannot invoke an object which possibly 'undefined'
应用代码
```typescript
interface A {
foo?: () => void
}
let a:A = { foo: () => {} };
a.foo();
```
建议改法1
```typescript
interface A {
foo: () => void
}
let a: A = { foo: () => {} };
a.foo();
```
建议改法2
```typescript
interface A {
foo?: () => void
}
let a: A = { foo: () => {} };
if (a.foo) {
a.foo();
}
```
原因
在原先代码的定义中，foo是可选属性，有可能为undefined，对undefined的调用会导致报错。建议按照业务逻辑判断是否需要为可选属性。如果确实需要，那么在访问到该属性后需要进行空值检查。
Variable '***' is used before being assigned
应用代码
```typescript
class Test {
value: number = 0
}
let a: Test
try {
a = { value: 1};
} catch (e) {
a.value;
}
a.value;
```
建议改法
```typescript
class Test {
value: number = 0
}
let a: Test | null = null;
try {
a = { value:1 };
} catch (e) {
if (a) {
a.value;
}
}
if (a) {
a.value;
}
```
原因
对于primitive types，可以根据业务逻辑赋值，例如0，''，false。
对于对象类型，可以将类型修改为和null的联合类型，并赋值null，使用时需要进行非空检查。
Function lacks ending return statement and return type does not include 'undefined'.
应用代码
```typescript
function foo(a: number): number {
if (a > 0) {
return a;
}
}
```
建议改法1
根据业务逻辑，在else分支中返回合适的数值
建议改法2
```typescript
function foo(a: number): number | undefined {
if (a > 0) {
return a;
}
return
}
```
arkts-strict-typing-required
应用代码
```typescript
// @ts-nocheck
var a: any = 123;
```
建议改法
```typescript
let a: number = 123;
```
原因
ArkTS不支持通过注释的方式绕过严格类型检查。首先将注释（// @ts-nocheck或者// @ts-ignore）删去，再根据报错信息修改其他代码。
Importing ArkTS files to JS and TS files is not allowed
arkts-no-tsdeps
不允许.ts、.js文件import.ets文件源码。
建议改法
方式1.将.ts文件的后缀修改成ets，按照ArkTS语法规则适配代码。
方式2.将.ets文件中被.ts文件依赖的代码单独抽取到.ts文件中。
arkts-no-special-imports
应用代码
```typescript
import type {A, B, C, D } from '***'
```
建议改法
```typescript
import {A, B, C, D } from '***'
```
arkts-no-classes-as-obj
使用class构造实例
应用代码
```typescript
class Controller {
value: string = ''
constructor(value: string) {
this.value = value
}
}
interface ControllerConstructor {
new (value: string): Controller;
}
class Menu {
controller: ControllerConstructor = Controller
createController() {
if (this.controller) {
return new this.controller('abc');
}
return null;
}
}
let t = new Menu();
console.log(t.createController()!.value);
```
建议改法
```typescript
class Controller {
value: string = ''
constructor(value: string) {
this.value = value
}
}
type ControllerConstructor = () => Controller;
class Menu {
controller: ControllerConstructor = () => { return new Controller('abc'); }
createController() {
if (this.controller) {
return this.controller();
}
return null;
}
}
let t: Menu = new Menu();
console.log(t.createController()!.value);
```
访问静态属性
应用代码
```typescript
class C1 {
static value: string = 'abc'
}
class C2 {
static value: string = 'def'
}
function getValue(obj: any) {
return obj['value'];
}
console.log(getValue(C1));
console.log(getValue(C2));
```
建议改法
```typescript
class C1 {
static value: string = 'abc'
}
class C2 {
static value: string = 'def'
}
function getC1Value(): string {
return C1.value;
}
function getC2Value(): string {
return C2.value;
}
console.log(getC1Value());
console.log(getC2Value());
```
arkts-no-side-effects-imports
改用动态import
应用代码
```typescript
import 'module'
```
建议改法
```typescript
import('module')
```
arkts-no-func-props
应用代码
```typescript
function foo(value: number): void {
console.log(value.toString());
}
foo.add = (left: number, right: number) => {
return left + right;
}
foo.sub = (left: number, right: number) => {
return left - right;
}
```
建议改法
```typescript
class Foo {
static foo(value: number): void {
console.log(value.toString());
}
static add(left: number, right: number): number {
return left + right;
}
static sub(left: number, right: number): number {
return left - right;
}
}
```
arkts-limited-esobj
应用代码
```typescript
// lib.d.ts
declare function foo(): any;
// main.ets
let e0: ESObject = foo();
function f() {
let e1 = foo();
let e2: ESObject = 1;
let e3: ESObject = {};
let e4: ESObject = '';
}
```
建议改法
```typescript
// lib.d.ts
declare function foo(): any;
// main.ets
interface I {}
function f() {
let e0: ESObject = foo();
let e1: ESObject = foo();
let e2: number = 1;
let e3: I = {};
let e4: string = '';
}
```
拷贝
浅拷贝
TypeScript
```typescript
function shallowCopy(obj: object): object {
let newObj = {};
Object.assign(newObj, obj);
return newObj;
}
```
ArkTS
```typescript
function shallowCopy(obj: object): object {
let newObj: Record<string, Object> = {};
for (let key of Object.keys(obj)) {
newObj[key] = obj[key];
}
return newObj;
}
```
深拷贝
TypeScript
```typescript
function deepCopy(obj: object): object {
let newObj = Array.isArray(obj) ? [] : {};
for (let key in obj) {
if (typeof obj[key] === 'object') {
newObj[key] = deepCopy(obj[key]);
} else {
newObj[key] = obj[key];
}
}
return newObj;
}
```
ArkTS
```typescript
function deepCopy(obj: object): object {
let newObj: Record<string, Object> | Object[] = Array.isArray(obj) ? [] : {};
for (let key of Object.keys(obj)) {
if (typeof obj[key] === 'object') {
newObj[key] = deepCopy(obj[key]);
} else {
newObj[key] = obj[key];
}
}
return newObj;
}
```
状态管理使用典型场景
Struct组件外使用状态变量
由于struct和class不同，不建议把this作为参数传递到struct外部使用，避免引起实例引用无法释放的情况，导致内存泄露。建议将状态变量对象传递到struct外面使用，通过修改对象的属性，来触发UI刷新。
不推荐用法
```typescript
export class MyComponentController {
item: MyComponent = null;
setItem(item: MyComponent) {
this.item = item;
}
changeText(value: string) {
this.item.value = value;
}
}
@Component
export default struct MyComponent {
public controller: MyComponentController = null;
@State value: string = 'Hello World';
build() {
Column() {
Text(this.value)
.fontSize(50)
}
}
aboutToAppear() {
if (this.controller)
this.controller.setItem(this); // 不建议把this作为参数传递到struct外部使用
}
}
@Entry
@Component
struct ObjThisOldPage {
controller = new MyComponentController();
build() {
Column() {
MyComponent({ controller: this.controller })
Button('change value').onClick(() => {
this.controller.changeText('Text');
})
}
}
}
```
推荐用法
```typescript
class CC {
value: string = '1';
constructor(value: string) {
this.value = value;
}
}
export class MyComponentController {
item: CC = new CC('1');
setItem(item: CC) {
this.item = item;
}
changeText(value: string) {
this.item.value = value;
}
}
@Component
export default struct MyComponent {
public controller: MyComponentController | null = null;
@State value: CC = new CC('Hello World');
build() {
Column() {
Text(`${this.value.value}`)
.fontSize(50)
}
}
aboutToAppear() {
if (this.controller)
this.controller.setItem(this.value);
}
}
@Entry
@Component
struct StyleExample {
controller: MyComponentController = new MyComponentController();
build() {
Column() {
MyComponent({ controller: this.controller })
Button('change value').onClick(() => {
this.controller.changeText('Text');
})
}
}
}
```
Struct支持联合类型的方案
下面这段代码有arkts-no-any-unknown的报错，由于struct不支持泛型，建议使用联合类型，实现自定义组件类似泛型的功能。
不推荐用法
```typescript
class Data {
aa: number = 11;
}
@Entry
@Component
struct DatauionOldPage {
@State array: Data[] = [new Data(), new Data(), new Data()];
@Builder
componentCloser(data: Data) {
Text(data.aa + '').fontSize(50)
}
build() {
Row() {
Column() {
ForEachCom({ arrayList: this.array, closer: this.componentCloser })
}
.width('100%')
}
.height('100%')
}
}
@Component
export struct ForEachCom {
arrayList: any[]; // struct不支持泛型，有arkts-no-any-unknown报错
@BuilderParam closer: (data: any) => void = this.componentCloser; // struct不支持泛型，有arkts-no-any-unknown报错
@Builder
componentCloser() {
}
build() {
Column() {
ForEach(this.arrayList, (item: any) => { // struct不支持泛型，有arkts-no-any-unknown报错
Row() {
this.closer(item)
}.width('100%').height(200).backgroundColor('#eee')
})
}
}
}
```
推荐用法
```typescript
class Data {
aa: number = 11;
}
class Model {
aa: string = '11';
}
type UnionData = Data | Model;
@Entry
@Component
struct DatauionPage {
array: UnionData[] = [new Data(), new Data(), new Data()];
@Builder
componentCloser(data: UnionData) {
if (data instanceof Data) {
Text(data.aa + '').fontSize(50)
}
}
build() {
Row() {
Column() {
ForEachCom({ arrayList: this.array, closer: this.componentCloser })
}
.width('100%')
}
.height('100%')
}
}
@Component
export struct ForEachCom {
arrayList: UnionData[] = [new Data(), new Data(), new Data()];
@BuilderParam closer: (data: UnionData) => void = this.componentCloser;
@Builder
componentCloser() {
}
build() {
Column() {
ForEach(this.arrayList, (item: UnionData) => {
Row() {
this.closer(item)
}.width('100%').height(200).backgroundColor('#eee')
})
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-high-performance-programming
爬取时间: 2025-04-27 21:46:33
来源: Huawei Developer
概述
本文主要提供应用性能敏感场景下的高性能编程的相关建议，助力开发者开发出高性能的应用。高性能编程实践，是在开发过程中逐步总结出来的一些高性能的写法和建议，在业务功能实现过程中，要同步思考并理解高性能写法的原理，运用到代码逻辑实现中。ArkTS编程规范可参考ArkTS编程规范。
声明与表达式
使用const声明不变的变量
不变的变量推荐使用const声明。
number类型变量避免整型和浮点型混用
针对number类型，运行时在优化时会区分整型和浮点型数据。建议避免在初始化后改变数据类型。
数值计算避免溢出
常见的可能导致溢出的数值计算包括如下场景，溢出之后，会导致引擎走入慢速的溢出逻辑分支处理，影响后续的性能。
- 针对加法、减法、乘法、指数运算等运算操作，应避免数值大于INT32_MAX或小于INT32_MIN。
- 针对&（and）、>>>（无符号右移）等运算操作，应避免数值大于INT32_MAX。
循环中常量提取，减少属性访问次数
在循环中会大量进行一些常量的访问操作，如果该常量在循环中不会改变，可以提取到循环外部，减少属性访问的次数。
优化后代码如下，可以将Time.info[num - Time.start]进行常量提取操作，这样可以大幅减少属性的访问次数，性能收益明显。
函数
建议使用参数传递函数外的变量
使用闭包会造成额外的闭包创建和访问开销。在性能敏感场景中，建议使用参数传递函数外的变量来替代使用闭包。
建议使用参数传递函数外的变量来，替代使用闭包。
避免使用可选参数
函数的可选参数表示参数可能为undefined，在函数内部使用该参数时，需要进行非空值的判断，造成额外的开销。
根据业务需要，将函数参数声明为必须参数。可以考虑使用默认参数。
数组
数值数组推荐使用TypedArray
如果是涉及纯数值计算的场合，推荐使用TypedArray数据结构。
优化前
优化后
避免使用稀疏数组
运行时在分配超过1024大小的数组或者针对稀疏数组，会采用hash表的方式来存储元素。在该模式下，相比于用偏移访问数组元素速度较慢。在代码开发时，应尽量避免数组变成稀疏数组。
避免使用联合类型数组
避免使用联合类型数组。避免在数值数组中混合使用整型数据和浮点型数据。
根据业务需要，将相同类型的数据放置在同一数组中。
异常
避免频繁抛出异常
创建异常时会构造异常的栈帧，造成性能损耗。在性能敏感场景下，例如在for循环语句中，避免频繁抛出异常。
优化前
优化后

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/glossary
爬取时间: 2025-04-27 21:46:46
来源: Huawei Developer
A
abc文件
方舟字节码（ArkCompiler Bytecode）文件，是ArkCompiler的编译工具链以源代码作为输入编译生成的产物，其文件后缀名为.abc。在发布态，abc文件会被打包到HAP中。
ANS
Advanced Notification Service，通知增强服务，是HarmonyOS中负责处理通知的订阅、发布和更新等操作的系统服务。
Atomic Service，元服务
原名原子化服务，是HarmonyOS提供的一种面向未来的服务提供方式，是有独立入口的（用户可通过点击服务卡片打开元服务）、免安装的（无需显式安装，由系统程序框架后台安装后即可使用）用户应用程序形态。
ArkUI
方舟开发框架，是为HarmonyOS平台开发极简、高性能、跨设备应用设计研发的UI开发框架，支撑开发者高效地构建跨设备应用UI界面。
ArkCompiler
方舟编译器，是华为自研的统一编程平台，包含编译器、工具链、运行时等关键部件，支持高级语言在多种芯片平台的编译与运行，可支撑传统应用、元服务运行在手机、个人电脑、平板、电视、汽车和智能穿戴等多种设备上的需求。
D
DFX
Design For X（也称Design For eXcellence），是面向产品生命周期各环节的设计，其中X代表产品生命周期的某一个环节或特性。例如DFR表示Design for Reliability，即可靠性设计；DFT表示Design for Testability，即可测试性设计。DFX设计涵盖了产品所有的非功能性设计，包括研发、制造、运维、服务等环节，对产品效率、成本、质量、体验等至关重要。
DV
Device Virtualization，设备虚拟化，通过虚拟化技术可以实现不同设备的能力和资源融合。
E
ExtensionAbility
Stage模型中的组件类型名，即ExtensionAbility组件，提供特定场景（如卡片、输入法）的扩展能力，满足更多的使用场景。
F
FA
Feature Ability，在FA模型中代表有界面的Ability，用于与用户进行交互。
FA模型
HarmonyOS早期版本开始支持的应用模型，已经不再主推。建议使用新的Stage模型进行开发。
H
HAP
Harmony Ability Package，一个HAP文件包含应用的所有内容，由代码、资源、三方库及应用配置文件组成，其文件后缀名为.hap。
HarmonyOS
HarmonyOS是新一代的智能终端操作系统，为不同设备的智能化、互联与协同提供了统一的语言。带来简洁、流畅、连续、安全可靠的全场景交互体验。
2024年HarmonyOS以全新架构发布，命名为HarmonyOS NEXT。HarmonyOS NEXT于2024年6月21日公开发布首个Developer Beta版本，并于2024年10月22日正式公开发布首个Release版本（版本号5.0.0）。HarmonyOS NEXT采用OpenHarmony作为操作系统底座，并通过OpenHarmony兼容性标准认证。全新架构下的HarmonyOS实现了对全场景体验的底层优化，系统更流畅，隐私安全能力更强大。给消费者带来更高效、更流畅、更便捷、更安全的智能化操作体验。
HDF
Hardware Driver Foundation，硬件驱动框架，用于提供统一外设访问能力和驱动开发、管理框架。
HML
HarmonyOSMarkup Language，是一套类HTML的标记语言。通过组件、事件构建出页面的内容。页面具备数据绑定、事件绑定、列表渲染、条件渲染等高级能力。
Hop，流转
在HarmonyOS中泛指涉及多端的分布式操作。流转能力打破设备界限，多设备联动，使用户应用程序可分可合、可流转，实现如邮件跨设备编辑、多设备协同健身、多屏游戏等分布式业务。
流转为开发者提供更广的使用场景和更新的产品视角，强化产品优势，实现体验升级。
I
IDN
Intelligent Distributed Networking，是HarmonyOS特有的分布式组网能力单元。开发者可以通过IDN获取分布式网络内的设备列表和设备状态信息，以及注册分布式网络内设备的在网状态变化信息。
K
Kit
是一个功能内聚的开放能力集合，可以支撑开发者完成一个特定场景的功能开发。
M
Manual hop，用户手动流转
是指开发者在用户应用程序中内嵌规范的流转图标，使用户可以手动选择合适的可选设备进行流转。用户点击图标后，会调起系统提供的流转面板。面板中会展示出用户应用程序的信息及可流转的设备，引导用户进行后续的流转操作。
MSDP
Mobile Sensing Development Platform，移动感知平台。MSDP子系统提供分布式融合感知能力，借助HarmonyOS分布式能力，汇总融合来自多个设备的多种感知源，从而精确感知用户的空间状态、移动状态、手势、运动健康等多种状态，构建全场景泛在基础感知能力，支撑智慧生活新体验。
Multi-device collaboration，多端协同
是一种实现用户应用程序流转的技术方案。指多端上的不同FA/PA同时运行、或者接替运行实现完整的业务；或者，多端上的相同FA/PA同时运行实现完整的业务。
O
OpenHarmony
2020年，华为将HarmonyOS基础能力捐赠给开放原子开源基金会，形成OpenHarmony开源项目。OpenHarmony能够提供操作系统底层能力，包括应用框架及UI框架，基础服务（如分布式管理、数据、文件等），基础应用（如桌面、设置的基本能力，以及日历、联系人等基础应用）。
P
PA
Particle Ability，在FA模型中代表无界面的Ability，主要为Feature Ability提供支持，例如作为后台服务提供计算能力，或作为数据仓库提供数据访问能力。
PC/2in1
即PC设备，主要交互方式以多窗口、多任务及键盘鼠标操作为主，可充分发挥设备的生产力属性。在HarmonyOS文档中，所有“2in1”均指“PC/2in1”。
S
SDK
Software Development Kit，软件开发工具包，是用于创建应用软件的开发工具和开放能力的集合。
Service widget，服务卡片
将用户应用程序的重要信息以服务卡片的形式展示在桌面，用户可通过快捷手势使用卡片，以达到服务直达、减少层级跳转的目的。
Stage模型
HarmonyOS 3.1 Develper Preview版本开始新增的应用模型，提供UIAbility、ExtensionAbility两大类应用组件。由于该模型还提供了AbilityStage、WindowStage等类作为应用组件和Window窗口的“舞台”，因此称之为Stage模型。
Super virtual device，超级虚拟终端
亦称超级终端，通过分布式技术将多个终端的能力进行整合，存放在一个虚拟的硬件资源池里，根据业务需要统一管理和调度终端能力，来对外提供服务。
System suggested hop，系统推荐流转
是指当用户使用用户应用程序时，所处环境中存在使用体验更优的可选设备，则系统自动为用户推荐该设备，用户可确认是否启动流转。
U
UIAbility
Stage模型中的组件类型名，即UIAbility组件，包含UI，提供展示UI的能力，主要用于和用户交互。
UX
也称UE，即User Experience，用户体验，是用户在使用一个产品或系统之前、使用期间和使用之后的全部感受。


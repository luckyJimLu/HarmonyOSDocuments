# 合并文件
合并时间: 2025-04-29 19:56:43

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ar-engine-kit-guide-V14
爬取时间: 2025-04-29 19:26:25
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-introduction-V14
爬取时间: 2025-04-29 19:26:40
来源: Huawei Developer
AR Engine（AR引擎服务）是一个用于在HarmonyOS上构建增强现实应用的引擎，提供了运动跟踪、环境跟踪和命中检测等空间计算能力。通过这些能力，您的应用可以实现虚拟世界与现实世界的融合，给消费者提供全新的视觉体验和交互方式。
能力介绍
AR Engine包含三大能力，分别是运动跟踪能力、环境跟踪能力和命中检测能力。
运动跟踪能力
AR Engine通过获取终端设备摄像头数据，结合图像特征和惯性传感器（IMU），计算设备位置（沿x、y、z轴方向位移）和姿态（绕x、y、z轴旋转），实现6自由度（6DoF）运动跟踪能力。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.36580936241346317711375675485613:50001231000000:2800:3A88771F2B262E97FCA1431C16151B0A12A638B74AE73E4A58E54CD4DA5003DA.jpg)
环境跟踪能力
AR Engine通过检测和跟踪设备周围的平面及语义，实现环境跟踪能力。环境跟踪能力包括：平面检测、平面语义、目标语义。
-  检测水平和竖直平面（如地面、墙面等），并识别平面边界。您的应用可使用这些平面来放置虚拟物体。
-  检测不同的平面类型。当前支持的平面类型共8种，分别为：墙面、地面、座椅面、桌面、天花板、门面、窗面、床面。
-  当目标物体位于平面上时，检测目标物体的形状，当前包括矩形和圆形。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.55398716818836484160582243375845:50001231000000:2800:DCCD67077A506048CE5663120AA67ABD8AF753F53FA0C1AC580D30013B747D09.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.70775924239134537401410348676001:50001231000000:2800:759562BD593447BB96EFDE4AE9C81FA4BE0CBFC72573788AC6CFC495A65F90FB.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.82255988675395829703518712840858:50001231000000:2800:91F626C94658F9C8BBCB27A60247DE8471597EB5547B102B90931011FB686D47.jpg)
命中检测能力
AR Engine通过命中检测（Hit Testing）技术，将终端设备屏幕上的兴趣点映射为现实环境中的兴趣点。命中检测以现实环境中的兴趣点为源，发出一条射线连接到摄像头所在位置，返回射线与平面（或特征点）的交点。通过命中检测能力，用户可以通过点击终端设备屏幕，选中现实环境中的兴趣点，与虚拟物体进行交互。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.81296534452255862533808992258555:50001231000000:2800:C3F113E6DEB5D5988A801E90DCBF7623BFFE2C70DFB072F003DC2135BC1F09C4.jpg)
场景介绍
通过以上能力，您可以实现AR场景的应用开发，如AR物体摆放等，为用户提供虚实融合的全新交互体验。
AR物体摆放：通过摄像头构建AR虚拟世界，支持用户在虚拟世界中放置虚拟物体。AR物体摆放可用于虚拟家具试用等，实现虚拟与现实世界融合。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-preparations-V14
爬取时间: 2025-04-29 19:26:54
来源: Huawei Developer
软件要求
硬件要求
| 设备类型  | 产品系列  | 产品型号  |
| --- | --- | --- |
|   手机  | Mate系列  | Mate 60，Mate 60 RS 非凡大师，Mate 60 Pro，Mate 60 Pro+，Mate 70，Mate 70 RS 非凡大师，Mate 70 Pro，Mate 70 Pro+，Mate X5，Mate X6，Mate XT 非凡大师  |
| Pura系列  | Pura 70，Pura 70 Pro，Pura 70 Pro+，Pura 70 Ultra  |
| Noval系列  | Nova 12 Pro  |
| Pocket系列  | Pocket 2  |
| 平板  | MatePad系列  | MatePad Pro 13.2  |
设备类型
产品系列
产品型号
手机
Mate系列
Mate 60，Mate 60 RS 非凡大师，Mate 60 Pro，Mate 60 Pro+，Mate 70，Mate 70 RS 非凡大师，Mate 70 Pro，Mate 70 Pro+，Mate X5，Mate X6，Mate XT 非凡大师
Pura系列
Pura 70，Pura 70 Pro，Pura 70 Pro+，Pura 70 Ultra
Noval系列
Nova 12 Pro
Pocket系列
Pocket 2
平板
MatePad系列
MatePad Pro 13.2
环境搭建
请参考应用开发准备完成基本准备工作。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-arsession-V14
爬取时间: 2025-04-29 19:27:07
来源: Huawei Developer
对于任何AR应用，您首先需要创建一个AR会话（AREngine_ARSession），用于管理AR Engine的系统状态。
创建AR会话
应用开始时，您可以调用HMS_AREngine_ARSession_Create函数创建一个AR会话。
自定义配置AR会话
您可以创建一个AREngine_ARConfig对象来配置当前AR会话。如缺省，则使用默认配置。
具体可配置项，请参考API参考。
销毁AR会话
应用结束时，您可以调用HMS_AREngine_ARSession_Destroy函数销毁当前的AR会话。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-hitresult-and-tracking-V14
爬取时间: 2025-04-29 19:27:21
来源: Huawei Developer
设备位姿描述了物体在真实世界中的位置和朝向。AR Engine提供了世界坐标下6自由度（6DoF）的位姿计算，包括物体的位置（沿x、y、z轴方向位移）和朝向（绕x、y、z轴旋转）。通过AR Engine，您可以实时获取设备在空间中任意时刻的位姿。
创建ARSession
您可以参考管理AR会话创建ARSession。
世界坐标系
设备位姿一般在世界坐标系下进行表示。世界坐标系描述了真实物理空间中物体的绝对位置，其正方向如图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.82193010564084874308414328026366:50001231000000:2800:7ABB2BA748576DAE4C85DA298E1468B99B00BED07A4ED83E001836B495F0E981.jpg)
AR Engine会帮助您自动完成世界坐标系初始化。
获取设备当前位姿
AR Engine中，设备位姿由一个7维向量描述，包括旋转量和位移量。其中旋转量是一组四元数，描述了设备相对于坐标原点的旋转状态；位移量是一组三维向量，描述了设备相对于坐标原点的平移状态，如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.33105549589191700666840665755295:50001231000000:2800:C955AC03DEAD14F9D5F2683ADC002E5DB9FE174487527C2F15EAD3F5D26DCFBA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.17283017305828414386988438611191:50001231000000:2800:E9A6837C055F1517CFEEA81635459304B6E5C1F698BA997EE0A9048FE84D0AAC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.65986382693314632752877824084405:50001231000000:2800:3C0DD671A78DD99F2822C9A67943101B48A6FCB467029A6169C2F93FFCE87453.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.39001666001834042507842658025318:50001231000000:2800:269D6E05583BA517038D56A3D3FF7A957EEEFF8FA7B0A64B662C8CDBD85D6290.jpg)
通过旋转分量和平移分量，您可以完备的描述设备位姿在空间中任意时刻的位姿状态。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-get-plane-V14
爬取时间: 2025-04-29 19:27:35
来源: Huawei Developer
本章节介绍如何通过AR Engine进行平面检测。通过学习本章节，您可以检测当前环境中的平面，并在您的应用中处理这些平面。
创建ARSession
您可以参考管理AR会话创建ARSession。
创建平面对象列表
识别当前环境中的平面
调用HMS_AREngine_ARSession_GetAllTrackables函数，检测当前环境中的所有平面，并将结果存放在planeList中。
获取平面数量
调用HMS_AREngine_ARTrackableList_GetSize函数获取平面数量，结果存放在planeListSize中。
在您的应用环境中，可能存在0个、1个或多个平面。
当planeListSize等于0时，表示当前环境中不存在平面。
当planeListSize等于1时，表示当前环境中仅存在1个平面。
当planeListSize大于1时，表示当前环境中存在多个平面。
获取平面实例
当存在1个或多个平面时，您可以依次遍历planeList获取所有平面对象。
对于第i个平面，创建并获取可跟踪对象，并将其转化为平面对象AREngine_ARPlane。
AR Engine中，任何物体都被定义为可跟踪对象AREngine_ARTrackable。平面也是一种可跟踪对象，您可以通过类型转换reinterpret_cast将可跟踪对象AREngine_ARTrackable转化为平面对象AREngine_ARPlane。
销毁平面对象列表

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-arsession-V14
爬取时间: 2025-04-29 19:27:48
来源: Huawei Developer
对于任何AR应用，您首先需要创建一个AR会话（AREngine_ARSession），用于管理AR Engine的系统状态。
创建AR会话
应用开始时，您可以调用HMS_AREngine_ARSession_Create函数创建一个AR会话。
自定义配置AR会话
您可以创建一个AREngine_ARConfig对象来配置当前AR会话。如缺省，则使用默认配置。
具体可配置项，请参考API参考。
销毁AR会话
应用结束时，您可以调用HMS_AREngine_ARSession_Destroy函数销毁当前的AR会话。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-get-plane-target-V14
爬取时间: 2025-04-29 19:27:49
来源: Huawei Developer
对于检测到的平面，您可以通过AR Engine识别该平面的语义，包括墙面、地面、座椅面、桌面、天花板、门面、窗面、床面。
创建AR会话
创建AR会话并配置为平面语义识别模式。
检测环境中的平面
进行平面语义识别之前，您需要先检测环境中的平面。您可以参考检测环境中的平面完成平面检测过程，并获取环境中的平面数量。当存在平面时，您可以继续下面的步骤。
初始化平面语义标签
创建并初始化平面语义标签label，用于描述平面的语义。
平面语义标签定义为枚举类型，包括9种枚举值（1种未知类型+8种平面类型）。
识别平面类型

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-hitresult-and-tracking-V14
爬取时间: 2025-04-29 19:28:01
来源: Huawei Developer
设备位姿描述了物体在真实世界中的位置和朝向。AR Engine提供了世界坐标下6自由度（6DoF）的位姿计算，包括物体的位置（沿x、y、z轴方向位移）和朝向（绕x、y、z轴旋转）。通过AR Engine，您可以实时获取设备在空间中任意时刻的位姿。
创建ARSession
您可以参考管理AR会话创建ARSession。
世界坐标系
设备位姿一般在世界坐标系下进行表示。世界坐标系描述了真实物理空间中物体的绝对位置，其正方向如图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.82193010564084874308414328026366:50001231000000:2800:7ABB2BA748576DAE4C85DA298E1468B99B00BED07A4ED83E001836B495F0E981.jpg)
AR Engine会帮助您自动完成世界坐标系初始化。
获取设备当前位姿
AR Engine中，设备位姿由一个7维向量描述，包括旋转量和位移量。其中旋转量是一组四元数，描述了设备相对于坐标原点的旋转状态；位移量是一组三维向量，描述了设备相对于坐标原点的平移状态，如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.33105549589191700666840665755295:50001231000000:2800:C955AC03DEAD14F9D5F2683ADC002E5DB9FE174487527C2F15EAD3F5D26DCFBA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.17283017305828414386988438611191:50001231000000:2800:E9A6837C055F1517CFEEA81635459304B6E5C1F698BA997EE0A9048FE84D0AAC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.65986382693314632752877824084405:50001231000000:2800:3C0DD671A78DD99F2822C9A67943101B48A6FCB467029A6169C2F93FFCE87453.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165905.39001666001834042507842658025318:50001231000000:2800:269D6E05583BA517038D56A3D3FF7A957EEEFF8FA7B0A64B662C8CDBD85D6290.jpg)
通过旋转分量和平移分量，您可以完备的描述设备位姿在空间中任意时刻的位姿状态。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-get-plane-shape-V14
爬取时间: 2025-04-29 19:28:03
来源: Huawei Developer
本章节介绍如何对目标物体进行形状识别，可识别的形状包括矩形和圆形。
创建AR会话
创建AR会话并配置为目标形状识别模式。
创建可跟踪对象列表
创建一个可跟踪对象列表targetList，用于存放AR Engine运行过程中检测到的所有可跟踪对象。
获取当前环境中的可跟踪对象
调用HMS_AREngine_ARSession_GetAllTrackables函数，检测当前环境中的所有可跟踪对象，并将结果存放在targetList中。
获取可跟踪对象数量
调用HMS_AREngine_ARTrackableList_GetSize函数获取当前可跟踪对象数量，结果存放在targetSize中。
当targetSize等于0时，代表当前环境中无可跟踪对象。
当targetSize等于1时，代表当前环境中仅存在1个可跟踪对象。
当targetSize大于1时，代表当前环境中存在多个可跟踪对象。
遍历并识别物体形状
1.  其中，AREngine_ARTargetShapeLabel为枚举类型，描述了目标物体形状。
销毁可跟踪对象列表

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-get-plane-V14
爬取时间: 2025-04-29 19:28:15
来源: Huawei Developer
本章节介绍如何通过AR Engine进行平面检测。通过学习本章节，您可以检测当前环境中的平面，并在您的应用中处理这些平面。
创建ARSession
您可以参考管理AR会话创建ARSession。
创建平面对象列表
识别当前环境中的平面
调用HMS_AREngine_ARSession_GetAllTrackables函数，检测当前环境中的所有平面，并将结果存放在planeList中。
获取平面数量
调用HMS_AREngine_ARTrackableList_GetSize函数获取平面数量，结果存放在planeListSize中。
在您的应用环境中，可能存在0个、1个或多个平面。
当planeListSize等于0时，表示当前环境中不存在平面。
当planeListSize等于1时，表示当前环境中仅存在1个平面。
当planeListSize大于1时，表示当前环境中存在多个平面。
获取平面实例
当存在1个或多个平面时，您可以依次遍历planeList获取所有平面对象。
对于第i个平面，创建并获取可跟踪对象，并将其转化为平面对象AREngine_ARPlane。
AR Engine中，任何物体都被定义为可跟踪对象AREngine_ARTrackable。平面也是一种可跟踪对象，您可以通过类型转换reinterpret_cast将可跟踪对象AREngine_ARTrackable转化为平面对象AREngine_ARPlane。
销毁平面对象列表

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-plane-detection-V14
爬取时间: 2025-04-29 19:28:17
来源: Huawei Developer
概要
本章节通过AR Engine识别设备周围的平面，并允许用户在平面上放置虚拟物体，实现虚拟和现实的融合。AR物体摆放可用于虚拟家具、数字展厅等应用，给用户提供虚实结合的新体验。通过本示例，您可以学习并掌握如何使用AR Engine开发一款AR应用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165906.54794367667935969946000926953158:50001231000000:2800:3B9535BC7509AD7A03F13584438C476DD970AEF165CAC5D2CE5D6392A6C1F258.jpg)
本章节涉及的AR Engine能力如下：
业务流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165906.43386461636216666262255223514338:50001231000000:2800:BA21F9883AB100FB2F0B56E217C455EF7528F24D54EF842AFC6262D365E0E6F6.png)
接口说明
以下接口为AR物体摆放相关接口。详细接口和说明，请参考接口文档。
| 接口名 | 描述 |
| --- | --- |
| HMS_AREngine_ARSession_Create | 创建一个新的AREngine_ARSession会话。 |
| HMS_AREngine_ARSession_Update | 更新AREngine的计算结果。 |
| HMS_AREngine_ARFrame_Create | 创建一个新的AREngine_ARFrame对象，将指针存储到中*outFrame。 |
| HMS_AREngine_ARSession_SetDisplayGeometry | 设置显示的高和宽（以像素为单位）。该高和宽是显示view的高和宽，如果不一致，会导致显示相机预览出错。 |
| HMS_AREngine_ARSession_SetCameraGLTexture | 设置可用于存储相机预览流数据的openGL纹理。 |
| HMS_AREngine_ARSession_GetAllTrackables | 获取所有指定类型的可跟踪对像集合。 |
| HMS_AREngine_ARTrackableList_AcquireItem | 从可跟踪列表中获取指定index的对象。 |
| HMS_AREngine_ARPlane_GetCenterPose | 获取从平面的局部坐标系到世界坐标系转换的位姿信息。 |
| HMS_AREngine_ARHitResultList_Create | 创建一个命中检测结果对象列表。 |
| HMS_AREngine_ARFrame_HitTest | 根据屏幕上兴趣点位置获取命中检测结果。 |
| HMS_AREngine_ARHitResultList_GetSize | 获取命中检测结果对象列表中包含的对象数。 |
| HMS_AREngine_ARHitResultList_GetItem | 在命中检测结果列表中获取指定索引的命中检测结果对象。 |
| HMS_AREngine_ARHitResult_Create | 创建一个空的命中检测结果对象。 |
| HMS_AREngine_ARHitResult_AcquireNewAnchor | 在碰撞命中位置创建一个新的锚点。 |
| HMS_AREngine_ARHitResult_AcquireTrackable | 获取被命中的可追踪对象。 |
| HMS_AREngine_ARFrame_AcquireCamera | 获取当前帧的相机参数对象。 |
| HMS_AREngine_ARPose_Create | 分配并初始化一个新的位姿对象。 |
| HMS_AREngine_ARCamera_GetPose | 获取当前相机对象在AR世界空间中的位姿。 |
接口名
描述
HMS_AREngine_ARSession_Create
创建一个新的AREngine_ARSession会话。
HMS_AREngine_ARSession_Update
更新AREngine的计算结果。
HMS_AREngine_ARFrame_Create
创建一个新的AREngine_ARFrame对象，将指针存储到中*outFrame。
HMS_AREngine_ARSession_SetDisplayGeometry
设置显示的高和宽（以像素为单位）。该高和宽是显示view的高和宽，如果不一致，会导致显示相机预览出错。
HMS_AREngine_ARSession_SetCameraGLTexture
设置可用于存储相机预览流数据的openGL纹理。
HMS_AREngine_ARSession_GetAllTrackables
获取所有指定类型的可跟踪对像集合。
HMS_AREngine_ARTrackableList_AcquireItem
从可跟踪列表中获取指定index的对象。
HMS_AREngine_ARPlane_GetCenterPose
获取从平面的局部坐标系到世界坐标系转换的位姿信息。
HMS_AREngine_ARHitResultList_Create
创建一个命中检测结果对象列表。
HMS_AREngine_ARFrame_HitTest
根据屏幕上兴趣点位置获取命中检测结果。
HMS_AREngine_ARHitResultList_GetSize
获取命中检测结果对象列表中包含的对象数。
HMS_AREngine_ARHitResultList_GetItem
在命中检测结果列表中获取指定索引的命中检测结果对象。
HMS_AREngine_ARHitResult_Create
创建一个空的命中检测结果对象。
HMS_AREngine_ARHitResult_AcquireNewAnchor
在碰撞命中位置创建一个新的锚点。
HMS_AREngine_ARHitResult_AcquireTrackable
获取被命中的可追踪对象。
HMS_AREngine_ARFrame_AcquireCamera
获取当前帧的相机参数对象。
HMS_AREngine_ARPose_Create
分配并初始化一个新的位姿对象。
HMS_AREngine_ARCamera_GetPose
获取当前相机对象在AR世界空间中的位姿。
开发步骤
本章节给出了关键开发步骤，完整代码可以参考示例代码。
创建Native C++工程
使用DevEco Studio创建一个Native C++工程。具体请参考使用Node-API实现跨语言交互开发流程。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165906.79563533565504763130506995473471:50001231000000:2800:C7AE646EB5ABF3C5321A992B4911AC03B3750EB37D1C32BF49838D8AE4C2B0E7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165906.11094131050939683252829067057803:50001231000000:2800:BB044B7D6A1C25A871BEE897734C4285FB9C9F7A8F29BA674720BF3CAA7BD39E.png)
申请权限
AR Engine需要使用相机、加速度传感器以及陀螺仪传感器权限，开发者可参考声明权限中的方式进行声明。其中相机权限需要用户手动进行授权，可参考向用户申请授权。
| 权限名 | 说明 | 授权方式 |
| --- | --- | --- |
| ohos.permission.CAMERA | 允许使用相机 | user_grant |
| ohos.permission.ACCELEROMETER | 允许使用加速度传感器 | system_grant |
| ohos.permission.GYROSCOPE | 允许使用陀螺仪传感器 | system_grant |
权限名
说明
授权方式
ohos.permission.CAMERA
允许使用相机
user_grant
ohos.permission.ACCELEROMETER
允许使用加速度传感器
system_grant
ohos.permission.GYROSCOPE
允许使用陀螺仪传感器
system_grant
声明Native接口
ArkTs接口声明。
```typescript
// 此代码可参考示例代码：ArSample/entry/src/main/cpp/types/libentry/index.d.ts。
import { resourceManager } from '@kit.LocalizationKit';
export const start:(id:string)=>void;
export const show:(id:string)=>void;
export const hide:(id:string)=>void;
export const update:(id:string)=>number;
export const stop:(id:string)=>void;
export const init:(resmgr : resourceManager.ResourceManager)=>void;
```
具体Native接口实现可参考示例代码。
创建UI界面
创建一个UI界面，用于显示相机预览画面，并定时触发每一帧绘制。
```typescript
// 此代码可参考示例代码：ArSample/entry/src/main/ets/pages/ArWorld.ets。
import { Logger } from '../utils/Logger';
import arEngineDemo from 'libentry.so';
import { resourceManager } from '@kit.LocalizationKit';
import { display } from '@kit.ArkUI';
@Entry
@Component
struct ArWorld {
private xcomponentId = 'ArWorld';
private resMgr: resourceManager.ResourceManager = getContext(this).resourceManager;
private interval: number = -1;
private isUpdate: boolean = true;
aboutToAppear() {
Logger.debug('aboutToAppear ' + this.xcomponentId);
arEngineDemo.init(this.resMgr);
arEngineDemo.start(this.xcomponentId);
display.on("foldStatusChange", (foldStatus: display.FoldStatus) => {
Logger.info('foldStatusChange display on ' + foldStatus);
if (foldStatus === display.FoldStatus.FOLD_STATUS_EXPANDED
|| foldStatus === display.FoldStatus.FOLD_STATUS_FOLDED) {
arEngineDemo.stop(this.xcomponentId);
arEngineDemo.init(this.resMgr);
// 调用Native的start接口，创建ARSession。
arEngineDemo.start(this.xcomponentId);
arEngineDemo.show(this.xcomponentId);
}
})
}
aboutToDisappear() {
Logger.debug('aboutToDisappear ' + this.xcomponentId);
arEngineDemo.stop(this.xcomponentId);
}
onPageShow() {
this.isUpdate = true;
Logger.debug('onPageShow ' + this.xcomponentId);
arEngineDemo.show(this.xcomponentId);
}
onPageHide() {
Logger.debug('onPageHide ' + this.xcomponentId);
this.isUpdate = false;
arEngineDemo.hide(this.xcomponentId);
}
build() {
Column() {
XComponent({ id: this.xcomponentId, type: XComponentType.SURFACE, libraryname: 'entry' })
.onLoad(() => {
Logger.debug('XComponent onLoad ' + this.xcomponentId);
this.interval = setInterval(() => {
if (this.isUpdate) {
// 调用Native的update，更新AR Engine每一帧的计算结果
arEngineDemo.update(this.xcomponentId);
}
}, 33); // 控制帧率为30fps（每33毫秒刷新一帧）。
})
.width('100%')
.height('100%')
.onDestroy(() => {
Logger.debug('XComponent onDestroy ' + this.xcomponentId);
clearInterval(this.interval);
})
.backgroundColor(Color.White)
}
.justifyContent(FlexAlign.SpaceAround)
.alignItems(HorizontalAlign.Center)
.backgroundColor(Color.White)
.borderRadius(24)
.width('100%')
.height('100%')
}
}
```
引入AR Engine
创建AR场景
获取平面
1.  这里直接获取相机的视图矩阵和相机的投影矩阵，是为了便于渲染。获取相机运动中的位姿变化，还可以调用HMS_AREngine_ARCamera_GetPose函数配合HMS_AREngine_ARPose_GetPoseRaw函数进行获取。详细可参考获取设备位姿。
2.  调用HMS_AREngine_ARPlane_GetPolygon函数获取平面的二维顶点坐标数组格式为[x1，z1，x2，z2，...]。这些值均在平面局部坐标系的x-z平面中定义，须先调用HMS_AREngine_ARPlane_GetCenterPose函数获取从平面的局部坐标系到世界坐标系转换的位姿数据，然后调用HMS_AREngine_ARPose_GetMatrix函数将位姿数据转换成4X4的矩阵，该矩阵与局部坐标系的坐标点做乘法，可以得到局部坐标系到世界坐标系的转换。
3.  具体绘制请参考示例代码。
点击屏幕
1.  添加头文件：native_interface_xcomponent.h。
2.  碰撞结果按照交点与设备的距离从近到远进行排序，存放在碰撞结果列表中。
放置虚拟物体
1.  调用HMS_AREngine_ARAnchor_GetPose函数获取锚点位姿，并基于该位姿绘制虚拟模型。 详细的模型绘制可参见示例代码。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-get-plane-target-V14
爬取时间: 2025-04-29 19:28:28
来源: Huawei Developer
对于检测到的平面，您可以通过AR Engine识别该平面的语义，包括墙面、地面、座椅面、桌面、天花板、门面、窗面、床面。
创建AR会话
创建AR会话并配置为平面语义识别模式。
检测环境中的平面
进行平面语义识别之前，您需要先检测环境中的平面。您可以参考检测环境中的平面完成平面检测过程，并获取环境中的平面数量。当存在平面时，您可以继续下面的步骤。
初始化平面语义标签
创建并初始化平面语义标签label，用于描述平面的语义。
平面语义标签定义为枚举类型，包括9种枚举值（1种未知类型+8种平面类型）。
识别平面类型

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-commonest-error-V14
爬取时间: 2025-04-29 19:28:30
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-get-plane-shape-V14
爬取时间: 2025-04-29 19:28:42
来源: Huawei Developer
本章节介绍如何对目标物体进行形状识别，可识别的形状包括矩形和圆形。
创建AR会话
创建AR会话并配置为目标形状识别模式。
创建可跟踪对象列表
创建一个可跟踪对象列表targetList，用于存放AR Engine运行过程中检测到的所有可跟踪对象。
获取当前环境中的可跟踪对象
调用HMS_AREngine_ARSession_GetAllTrackables函数，检测当前环境中的所有可跟踪对象，并将结果存放在targetList中。
获取可跟踪对象数量
调用HMS_AREngine_ARTrackableList_GetSize函数获取当前可跟踪对象数量，结果存放在targetSize中。
当targetSize等于0时，代表当前环境中无可跟踪对象。
当targetSize等于1时，代表当前环境中仅存在1个可跟踪对象。
当targetSize大于1时，代表当前环境中存在多个可跟踪对象。
遍历并识别物体形状
1.  其中，AREngine_ARTargetShapeLabel为枚举类型，描述了目标物体形状。
销毁可跟踪对象列表

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-faq-1-V14
爬取时间: 2025-04-29 19:28:43
来源: Huawei Developer
现象描述
调用HMS_AREngine_ARPlane_GetPolygonSize获取检测到平面的二维顶点数组大小时报错：“plane is nullptr!”，返回错误码：401。
可能原因
初次打开应用还未识别到平面，调用HMS_AREngine_ARSession_GetAllTrackables获取的可跟踪对象列表为空，导致后续HMS_AREngine_ARTrackableList_AcquireItem获取对应索引的对象也为空，使用前未做有效性判断，使用时出现无效参数错误。
处理步骤
从AR Engine获取平面之后需判断其有效性后使用，例如：进行非空判断。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-plane-detection-V14
爬取时间: 2025-04-29 19:28:55
来源: Huawei Developer
概要
本章节通过AR Engine识别设备周围的平面，并允许用户在平面上放置虚拟物体，实现虚拟和现实的融合。AR物体摆放可用于虚拟家具、数字展厅等应用，给用户提供虚实结合的新体验。通过本示例，您可以学习并掌握如何使用AR Engine开发一款AR应用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165906.54794367667935969946000926953158:50001231000000:2800:3B9535BC7509AD7A03F13584438C476DD970AEF165CAC5D2CE5D6392A6C1F258.jpg)
本章节涉及的AR Engine能力如下：
业务流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165906.43386461636216666262255223514338:50001231000000:2800:BA21F9883AB100FB2F0B56E217C455EF7528F24D54EF842AFC6262D365E0E6F6.png)
接口说明
以下接口为AR物体摆放相关接口。详细接口和说明，请参考接口文档。
| 接口名 | 描述 |
| --- | --- |
| HMS_AREngine_ARSession_Create | 创建一个新的AREngine_ARSession会话。 |
| HMS_AREngine_ARSession_Update | 更新AREngine的计算结果。 |
| HMS_AREngine_ARFrame_Create | 创建一个新的AREngine_ARFrame对象，将指针存储到中*outFrame。 |
| HMS_AREngine_ARSession_SetDisplayGeometry | 设置显示的高和宽（以像素为单位）。该高和宽是显示view的高和宽，如果不一致，会导致显示相机预览出错。 |
| HMS_AREngine_ARSession_SetCameraGLTexture | 设置可用于存储相机预览流数据的openGL纹理。 |
| HMS_AREngine_ARSession_GetAllTrackables | 获取所有指定类型的可跟踪对像集合。 |
| HMS_AREngine_ARTrackableList_AcquireItem | 从可跟踪列表中获取指定index的对象。 |
| HMS_AREngine_ARPlane_GetCenterPose | 获取从平面的局部坐标系到世界坐标系转换的位姿信息。 |
| HMS_AREngine_ARHitResultList_Create | 创建一个命中检测结果对象列表。 |
| HMS_AREngine_ARFrame_HitTest | 根据屏幕上兴趣点位置获取命中检测结果。 |
| HMS_AREngine_ARHitResultList_GetSize | 获取命中检测结果对象列表中包含的对象数。 |
| HMS_AREngine_ARHitResultList_GetItem | 在命中检测结果列表中获取指定索引的命中检测结果对象。 |
| HMS_AREngine_ARHitResult_Create | 创建一个空的命中检测结果对象。 |
| HMS_AREngine_ARHitResult_AcquireNewAnchor | 在碰撞命中位置创建一个新的锚点。 |
| HMS_AREngine_ARHitResult_AcquireTrackable | 获取被命中的可追踪对象。 |
| HMS_AREngine_ARFrame_AcquireCamera | 获取当前帧的相机参数对象。 |
| HMS_AREngine_ARPose_Create | 分配并初始化一个新的位姿对象。 |
| HMS_AREngine_ARCamera_GetPose | 获取当前相机对象在AR世界空间中的位姿。 |
接口名
描述
HMS_AREngine_ARSession_Create
创建一个新的AREngine_ARSession会话。
HMS_AREngine_ARSession_Update
更新AREngine的计算结果。
HMS_AREngine_ARFrame_Create
创建一个新的AREngine_ARFrame对象，将指针存储到中*outFrame。
HMS_AREngine_ARSession_SetDisplayGeometry
设置显示的高和宽（以像素为单位）。该高和宽是显示view的高和宽，如果不一致，会导致显示相机预览出错。
HMS_AREngine_ARSession_SetCameraGLTexture
设置可用于存储相机预览流数据的openGL纹理。
HMS_AREngine_ARSession_GetAllTrackables
获取所有指定类型的可跟踪对像集合。
HMS_AREngine_ARTrackableList_AcquireItem
从可跟踪列表中获取指定index的对象。
HMS_AREngine_ARPlane_GetCenterPose
获取从平面的局部坐标系到世界坐标系转换的位姿信息。
HMS_AREngine_ARHitResultList_Create
创建一个命中检测结果对象列表。
HMS_AREngine_ARFrame_HitTest
根据屏幕上兴趣点位置获取命中检测结果。
HMS_AREngine_ARHitResultList_GetSize
获取命中检测结果对象列表中包含的对象数。
HMS_AREngine_ARHitResultList_GetItem
在命中检测结果列表中获取指定索引的命中检测结果对象。
HMS_AREngine_ARHitResult_Create
创建一个空的命中检测结果对象。
HMS_AREngine_ARHitResult_AcquireNewAnchor
在碰撞命中位置创建一个新的锚点。
HMS_AREngine_ARHitResult_AcquireTrackable
获取被命中的可追踪对象。
HMS_AREngine_ARFrame_AcquireCamera
获取当前帧的相机参数对象。
HMS_AREngine_ARPose_Create
分配并初始化一个新的位姿对象。
HMS_AREngine_ARCamera_GetPose
获取当前相机对象在AR世界空间中的位姿。
开发步骤
本章节给出了关键开发步骤，完整代码可以参考示例代码。
创建Native C++工程
使用DevEco Studio创建一个Native C++工程。具体请参考使用Node-API实现跨语言交互开发流程。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165906.79563533565504763130506995473471:50001231000000:2800:C7AE646EB5ABF3C5321A992B4911AC03B3750EB37D1C32BF49838D8AE4C2B0E7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165906.11094131050939683252829067057803:50001231000000:2800:BB044B7D6A1C25A871BEE897734C4285FB9C9F7A8F29BA674720BF3CAA7BD39E.png)
申请权限
AR Engine需要使用相机、加速度传感器以及陀螺仪传感器权限，开发者可参考声明权限中的方式进行声明。其中相机权限需要用户手动进行授权，可参考向用户申请授权。
| 权限名 | 说明 | 授权方式 |
| --- | --- | --- |
| ohos.permission.CAMERA | 允许使用相机 | user_grant |
| ohos.permission.ACCELEROMETER | 允许使用加速度传感器 | system_grant |
| ohos.permission.GYROSCOPE | 允许使用陀螺仪传感器 | system_grant |
权限名
说明
授权方式
ohos.permission.CAMERA
允许使用相机
user_grant
ohos.permission.ACCELEROMETER
允许使用加速度传感器
system_grant
ohos.permission.GYROSCOPE
允许使用陀螺仪传感器
system_grant
声明Native接口
ArkTs接口声明。
```typescript
// 此代码可参考示例代码：ArSample/entry/src/main/cpp/types/libentry/index.d.ts。
import { resourceManager } from '@kit.LocalizationKit';
export const start:(id:string)=>void;
export const show:(id:string)=>void;
export const hide:(id:string)=>void;
export const update:(id:string)=>number;
export const stop:(id:string)=>void;
export const init:(resmgr : resourceManager.ResourceManager)=>void;
```
具体Native接口实现可参考示例代码。
创建UI界面
创建一个UI界面，用于显示相机预览画面，并定时触发每一帧绘制。
```typescript
// 此代码可参考示例代码：ArSample/entry/src/main/ets/pages/ArWorld.ets。
import { Logger } from '../utils/Logger';
import arEngineDemo from 'libentry.so';
import { resourceManager } from '@kit.LocalizationKit';
import { display } from '@kit.ArkUI';
@Entry
@Component
struct ArWorld {
private xcomponentId = 'ArWorld';
private resMgr: resourceManager.ResourceManager = getContext(this).resourceManager;
private interval: number = -1;
private isUpdate: boolean = true;
aboutToAppear() {
Logger.debug('aboutToAppear ' + this.xcomponentId);
arEngineDemo.init(this.resMgr);
arEngineDemo.start(this.xcomponentId);
display.on("foldStatusChange", (foldStatus: display.FoldStatus) => {
Logger.info('foldStatusChange display on ' + foldStatus);
if (foldStatus === display.FoldStatus.FOLD_STATUS_EXPANDED
|| foldStatus === display.FoldStatus.FOLD_STATUS_FOLDED) {
arEngineDemo.stop(this.xcomponentId);
arEngineDemo.init(this.resMgr);
// 调用Native的start接口，创建ARSession。
arEngineDemo.start(this.xcomponentId);
arEngineDemo.show(this.xcomponentId);
}
})
}
aboutToDisappear() {
Logger.debug('aboutToDisappear ' + this.xcomponentId);
arEngineDemo.stop(this.xcomponentId);
}
onPageShow() {
this.isUpdate = true;
Logger.debug('onPageShow ' + this.xcomponentId);
arEngineDemo.show(this.xcomponentId);
}
onPageHide() {
Logger.debug('onPageHide ' + this.xcomponentId);
this.isUpdate = false;
arEngineDemo.hide(this.xcomponentId);
}
build() {
Column() {
XComponent({ id: this.xcomponentId, type: XComponentType.SURFACE, libraryname: 'entry' })
.onLoad(() => {
Logger.debug('XComponent onLoad ' + this.xcomponentId);
this.interval = setInterval(() => {
if (this.isUpdate) {
// 调用Native的update，更新AR Engine每一帧的计算结果
arEngineDemo.update(this.xcomponentId);
}
}, 33); // 控制帧率为30fps（每33毫秒刷新一帧）。
})
.width('100%')
.height('100%')
.onDestroy(() => {
Logger.debug('XComponent onDestroy ' + this.xcomponentId);
clearInterval(this.interval);
})
.backgroundColor(Color.White)
}
.justifyContent(FlexAlign.SpaceAround)
.alignItems(HorizontalAlign.Center)
.backgroundColor(Color.White)
.borderRadius(24)
.width('100%')
.height('100%')
}
}
```
引入AR Engine
创建AR场景
获取平面
1.  这里直接获取相机的视图矩阵和相机的投影矩阵，是为了便于渲染。获取相机运动中的位姿变化，还可以调用HMS_AREngine_ARCamera_GetPose函数配合HMS_AREngine_ARPose_GetPoseRaw函数进行获取。详细可参考获取设备位姿。
2.  调用HMS_AREngine_ARPlane_GetPolygon函数获取平面的二维顶点坐标数组格式为[x1，z1，x2，z2，...]。这些值均在平面局部坐标系的x-z平面中定义，须先调用HMS_AREngine_ARPlane_GetCenterPose函数获取从平面的局部坐标系到世界坐标系转换的位姿数据，然后调用HMS_AREngine_ARPose_GetMatrix函数将位姿数据转换成4X4的矩阵，该矩阵与局部坐标系的坐标点做乘法，可以得到局部坐标系到世界坐标系的转换。
3.  具体绘制请参考示例代码。
点击屏幕
1.  添加头文件：native_interface_xcomponent.h。
2.  碰撞结果按照交点与设备的距离从近到远进行排序，存放在碰撞结果列表中。
放置虚拟物体
1.  调用HMS_AREngine_ARAnchor_GetPose函数获取锚点位姿，并基于该位姿绘制虚拟模型。 详细的模型绘制可参见示例代码。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-faq-2-V14
爬取时间: 2025-04-29 19:28:56
来源: Huawei Developer
现象描述
使用运动跟踪能力时，摄像头被遮挡一段时间后再放开遮挡，调用HMS_AREngine_ARPose_GetPoseRaw函数获取的平移分量或旋转分量存在较大跳变。
可能原因
AR引擎通过摄像头采集数据感知当前设备在现实世界中的位姿，摄像头被遮挡后，AR引擎无法准确感知设备在现实世界的位姿变化，放开遮挡后，如果继续调用HMS_AREngine_ARSession_Update，AR引擎会尝试基于遮挡前识别到的数据进行恢复，如果当前摄像头采集数据和遮挡前类似，就可能会导致错误匹配到旧的结果，从而产生数据跳变。
处理步骤
如通过HMS_AREngine_ARCamera_GetTrackingState函数获取的状态为ARENGINE_TRACKING_STATE_PAUSED，可以通过函数：HMS_AREngine_ARCamera_GetTrackingStateReason进一步获取暂停原因，如暂停原因是ARENGINE_TRACKING_STATE_REASON_INSUFFICIENT_FEATURES或ARENGINE_TRACKING_STATE_REASON_EXCESSIVE_MOTION，建议在您的应用中提示用户，并在恢复后（HMS_AREngine_ARCamera_GetTrackingState获取的状态为：ARENGINE_TRACKING_STATE_TRACKING时）重新做session初始化，见：创建AR会话。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-commonest-error-V14
爬取时间: 2025-04-29 19:29:08
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-faq-1-V14
爬取时间: 2025-04-29 19:29:22
来源: Huawei Developer
现象描述
调用HMS_AREngine_ARPlane_GetPolygonSize获取检测到平面的二维顶点数组大小时报错：“plane is nullptr!”，返回错误码：401。
可能原因
初次打开应用还未识别到平面，调用HMS_AREngine_ARSession_GetAllTrackables获取的可跟踪对象列表为空，导致后续HMS_AREngine_ARTrackableList_AcquireItem获取对应索引的对象也为空，使用前未做有效性判断，使用时出现无效参数错误。
处理步骤
从AR Engine获取平面之后需判断其有效性后使用，例如：进行非空判断。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-faq-4-V14
爬取时间: 2025-04-29 19:29:37
来源: Huawei Developer
现象描述
某些特殊场景下，如使用环境附近存在强磁场，手机处于高负载场景下（后台开启很多应用或长时间使用导致手机发烫），或者扫描到重复纹理（见下图）时，可能出现识别到的平面无法锚定到现实世界中，或者通过HMS_AREngine_ARCamera_GetPose接口获取的位姿信息出现大幅度跳变等现象。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165909.75364858508215690410358848976036:50001231000000:2800:F531DCF1B145BC512351C9754F3E3ECF27743623772EA3E31DD7E0D1DAC28ED7.jpg)
可能原因
AR引擎通过获取到的加速度计传感器和磁力计传感器的信息进行平面计算和相机位姿计算，上述特殊场景下，系统传感器数据可能会存在异常，从而导致平面漂移或者位姿跳变的现象发生。
处理步骤
建议应用对通过HMS_AREngine_ARCamera_GetPose接口获取到的位姿数据，按照实际应用使用场景进行滤波，如步行导航场景，应用可以缓存多帧数据，通过多帧数据可以计算得到运动速度，如果检测到此速度明显高于步行速度，证明此时AR数据已经不可信，可以丢弃此数据或者重启AR算法。
计算运动速度：x,y,z为在t时刻的位姿数据的位移量。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165910.39366749509330706199595653320834:50001231000000:2800:0EDA1A593476BE8A1851A3D2AA64C027085D19B254A9017CB48DCB9B493C01AF.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics-2d-V14
爬取时间: 2025-04-29 19:29:51
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-faq-3-V14
爬取时间: 2025-04-29 19:29:53
来源: Huawei Developer
现象描述
使用环境跟踪能力时，如果输入图像中有反光、光线暗、有弱纹理（输入图像颜色变化小），识别到的点云数量会变少甚至没有，出平面时间也会变长或无法生成平面。
1.
2.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165907.02653438899885600185243006385310:50001231000000:2800:54D36B105B674B721FA0C91158DA42AC79E08020B94566E9D590549C9B555CA9.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165907.84162256181136111499419606653846:50001231000000:2800:83769C8EDC7C6EFA93EEE2C5111EBAB8E63F7645757793D903FAF08EEE209E68.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165908.50073992313758007069916134803442:50001231000000:2800:D16B6A4AF8BE17C9E8F8DFA1ACA53C2878FEF9825A21F59AA995E9658380287F.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165908.74461926191249633950173872476506:50001231000000:2800:0F7A79D1155683CB42A9D03472BE0EE0268856DB6C5B7D3DFFF78BC8BB1F9EB5.jpg)
可能原因
AR引擎通过输入的图像数据进行平面上特征点的计算，如果输入图像数据中存在反光、光线暗和弱纹理，AR引擎计算后只能得到很少的点，而平面根据识别到的点云生成，因此会导致平面出现慢或者不出现的现象发生。
处理步骤
建议应用在持续无法获取点云或平面数据时，提示用户移动相机，避免画面中持续出现反光、光线暗或弱纹理。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics2d-introduction-V14
爬取时间: 2025-04-29 19:30:04
来源: Huawei Developer
ArkGraphics 2D（方舟2D图形服务 ）主要提供图形绘制与显示相关的能力。开发者可以基于一套统一的图形接口进行应用开发，使应用开发更简单、高效。
能力范围
-  提供图像处理的一些基本能力，包括对当前图像的亮度调节、模糊化、灰度调节、智能取色等。具体可见@ohos.effectKit (图像效果)。
-  提供管理抽象化色域对象的基础能力，包括色域的创建、色域基础属性的获取等。具体可见@ohos.graphics.colorSpaceManager (色彩管理)与@ohos.graphics.sendableColorSpaceManager (可共享的色彩管理)。
-  提供可针对不同形式的内容指定帧率的能力，可用于开发者自绘制内容。具体可见可变帧率简介。
-  提供高动态显示的相关能力，具体可见@ohos.graphics.hdrCapability (HDR能力)。
-  提供自绘制的相关能力，开发者可根据需要，自定义绘制实现UI效果，可自定义绘制基础形状、文本、图片等。具体可见@ohos.graphics.drawing (绘制模块)。
-  提供图形绘制与显示相关的Native能力，包括NativeWindow、NativeBuffer、NativeImage、NativeVsync、Drawing等模块。
使用场景
-  图像效果处理：开发者可根据不同的UI效果需要，使用effectKit模块实现图像的效果处理，以提升用户浏览体验。
-  设置图像色域：开发者可根据设计需求使用图像文件并设置色域信息，实现图像广色域效果的绘制和显示。
-  定制帧率场景：支持开发者根据不同内容和需要，定制帧率进行绘制。比如不同游戏场景和界面时，设置不同的帧率，以提升用户体验流畅性并达到平衡功耗的效果。
-  自绘制场景：开发者可根据不同的UI效果和场景需要，使用Drawing等模块实现除ArkUI组件外的自定义组件或者自定义UI效果的绘制和显示。
亮点特征
-  同个窗口支持多个帧率：支持为同个窗口的不同内容，比如动画或自绘制UI，定制不同的绘制帧率，不同内容之间独立运行。
-  支持帧率动态配置，兼顾体验与功耗：支持三方框架根据UI场景，动态请求绘制帧率，比如游戏、视频等业务，兼顾流畅体验与功耗体验。
-  支持录制回放机制，提升交互体验：支持录制命令的缓存，可对绘制指令进行回放，以提升UI绘制的跟手性。
-  支持多种渲染后端：一次开发，支持多种渲染绘制后端，以降低多端适配成本，并满足应用的差异化需求。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arengine-faq-4-V14
爬取时间: 2025-04-29 19:30:08
来源: Huawei Developer
现象描述
某些特殊场景下，如使用环境附近存在强磁场，手机处于高负载场景下（后台开启很多应用或长时间使用导致手机发烫），或者扫描到重复纹理（见下图）时，可能出现识别到的平面无法锚定到现实世界中，或者通过HMS_AREngine_ARCamera_GetPose接口获取的位姿信息出现大幅度跳变等现象。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165909.75364858508215690410358848976036:50001231000000:2800:F531DCF1B145BC512351C9754F3E3ECF27743623772EA3E31DD7E0D1DAC28ED7.jpg)
可能原因
AR引擎通过获取到的加速度计传感器和磁力计传感器的信息进行平面计算和相机位姿计算，上述特殊场景下，系统传感器数据可能会存在异常，从而导致平面漂移或者位姿跳变的现象发生。
处理步骤
建议应用对通过HMS_AREngine_ARCamera_GetPose接口获取到的位姿数据，按照实际应用使用场景进行滤波，如步行导航场景，应用可以缓存多帧数据，通过多帧数据可以计算得到运动速度，如果检测到此速度明显高于步行速度，证明此时AR数据已经不可信，可以丢弃此数据或者重启AR算法。
计算运动速度：x,y,z为在t时刻的位姿数据的位移量。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165910.39366749509330706199595653320834:50001231000000:2800:0EDA1A593476BE8A1851A3D2AA64C027085D19B254A9017CB48DCB9B493C01AF.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/displaysync-V14
爬取时间: 2025-04-29 19:30:18
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics-2d-V14
爬取时间: 2025-04-29 19:30:22
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/displaysync-overview-V14
爬取时间: 2025-04-29 19:30:31
来源: Huawei Developer
随着设备屏幕的不断演进，当前主流设备采用LTPO屏幕，此类屏幕支持在多个档位之间切换屏幕帧率。
对于快速变化的内容，如射击游戏，交互动画等，显示帧率越高，画面越流畅，但是相对的功耗也会越高。
而低速变化的内容，如游戏大厅，时钟更新动画等，画面更新频率较低，使用相对低的显示帧率，用户也不会觉得卡顿，但是相对的功耗就比较低。
基于显示内容的可变帧率能力，在具备LTPO屏幕的设备上，可以达到性能体验和功耗间的平衡。
HarmonyOS支持可变帧率能力，开发者通过使用可变帧率接口，进行相关业务开发，可以享受可变帧率特性带来的功耗收益。
使用场景
可变帧率能力支持开发者自定义应用业务的帧率，其常见的使用场景：
运作机制
可变帧率为应用开发中的动画组件、XComponent组件、UI绘制等提供一种基础帧率配置和能力。
开发者通过设置有效的期望绘制帧率后，系统会收集设置的请求帧率，进行决策和分发，在渲染管线上进行分频，尽量能够满足开发者的期望帧率。
约束与限制
开发者设置的期望帧率值不能代表最终实际效果，会受限于系统能力和屏幕刷新率。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics2d-introduction-V14
爬取时间: 2025-04-29 19:30:36
来源: Huawei Developer
ArkGraphics 2D（方舟2D图形服务 ）主要提供图形绘制与显示相关的能力。开发者可以基于一套统一的图形接口进行应用开发，使应用开发更简单、高效。
能力范围
-  提供图像处理的一些基本能力，包括对当前图像的亮度调节、模糊化、灰度调节、智能取色等。具体可见@ohos.effectKit (图像效果)。
-  提供管理抽象化色域对象的基础能力，包括色域的创建、色域基础属性的获取等。具体可见@ohos.graphics.colorSpaceManager (色彩管理)与@ohos.graphics.sendableColorSpaceManager (可共享的色彩管理)。
-  提供可针对不同形式的内容指定帧率的能力，可用于开发者自绘制内容。具体可见可变帧率简介。
-  提供高动态显示的相关能力，具体可见@ohos.graphics.hdrCapability (HDR能力)。
-  提供自绘制的相关能力，开发者可根据需要，自定义绘制实现UI效果，可自定义绘制基础形状、文本、图片等。具体可见@ohos.graphics.drawing (绘制模块)。
-  提供图形绘制与显示相关的Native能力，包括NativeWindow、NativeBuffer、NativeImage、NativeVsync、Drawing等模块。
使用场景
-  图像效果处理：开发者可根据不同的UI效果需要，使用effectKit模块实现图像的效果处理，以提升用户浏览体验。
-  设置图像色域：开发者可根据设计需求使用图像文件并设置色域信息，实现图像广色域效果的绘制和显示。
-  定制帧率场景：支持开发者根据不同内容和需要，定制帧率进行绘制。比如不同游戏场景和界面时，设置不同的帧率，以提升用户体验流畅性并达到平衡功耗的效果。
-  自绘制场景：开发者可根据不同的UI效果和场景需要，使用Drawing等模块实现除ArkUI组件外的自定义组件或者自定义UI效果的绘制和显示。
亮点特征
-  同个窗口支持多个帧率：支持为同个窗口的不同内容，比如动画或自绘制UI，定制不同的绘制帧率，不同内容之间独立运行。
-  支持帧率动态配置，兼顾体验与功耗：支持三方框架根据UI场景，动态请求绘制帧率，比如游戏、视频等业务，兼顾流畅体验与功耗体验。
-  支持录制回放机制，提升交互体验：支持录制命令的缓存，可对绘制指令进行回放，以提升UI绘制的跟手性。
-  支持多种渲染后端：一次开发，支持多种渲染绘制后端，以降低多端适配成本，并满足应用的差异化需求。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/displaysync-animation-V14
爬取时间: 2025-04-29 19:30:44
来源: Huawei Developer
在应用开发中，属性动画和显式动画能够使用可选参数ExpectedFrameRateRange，为不同的动画配置不同的期望绘制帧率。
请求属性动画的绘制帧率
定义文本组件的属性动画，请求绘制帧率为60，范例如下：
```typescript
Text()
.animation({
duration: 1200,
iterations: 10,
expectedFrameRateRange: { // 设置属性动画的帧率范围
expected: 60, // 设置动画的期望帧率为60hz
min: 0, // 设置帧率范围
max: 120, // 设置帧率范围
},
})
```
请求显式动画的绘制帧率
定义按钮组件的显式动画，请求绘制帧率为30，范例如下：
```typescript
Button()
.onClick(() => {
animateTo({
duration: 1200,
iterations: 10,
expectedFrameRateRange: { // 设置显式动画的帧率范围
expected: 30, // 设置动画的期望帧率为30hz
min: 0, // 设置帧率范围
max: 120, // 设置帧率范围
},
}, () => {
})
})
```
完整示例
```typescript
@Entry
@Component
struct AnimationToAnimationDemo {
@State isAnimation: boolean = false;
@State translateX1: number = -100;
@State translateX2: number = -100;
@State translateX3: number = -100;
build() {
Column() {
Row() {
Text('30')
.fontWeight(FontWeight.Bold)
.fontSize(16)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.borderRadius(10)
.backgroundColor(0xF56C6C)
.width(80)
.height(80)
.translate({ x: this.translateX1 })
}
.height('20%')
Row() {
Text('40')
.fontWeight(FontWeight.Bold)
.fontSize(16)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.borderRadius(10)
.backgroundColor(0x2E8B57)
.width(80)
.height(80)
.translate({ x: this.translateX2 })
}
.height('20%')
Row() {
Text('60')
.fontWeight(FontWeight.Bold)
.fontSize(16)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.borderRadius(10)
.backgroundColor(0x008B8B)
.width(80)
.height(80)
.translate({ x: this.translateX3 })
.animation({
duration: 1200,
iterations: 10,
playMode: PlayMode.AlternateReverse,
expectedFrameRateRange: { // 设置属性动画的帧率范围
expected: 60, // 设置动画的期望帧率为60hz
min: 0, // 设置帧率范围
max: 120, // 设置帧率范围
},
})
}
.height('20%')
Row() {
Button('Start')
.id('PropertyAnimationStart')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 10, left: 5 })
.fontColor(Color.White)
.onClick(() => {
this.isAnimation = !this.isAnimation;
this.translateX3 = this.isAnimation ? 100 : -100;
animateTo({
duration: 1200,
iterations: 10,
playMode: PlayMode.AlternateReverse,
expectedFrameRateRange: { // 设置显式动画的帧率范围
expected: 30, // 设置动画的期望帧率为30hz
min: 0, // 设置帧率范围
max: 120, // 设置帧率范围
},
}, () => {
this.translateX1 = this.isAnimation ? 100 : -100;
})
animateTo({
duration: 1200,
iterations: 10,
playMode: PlayMode.AlternateReverse,
expectedFrameRateRange: { // 设置显式动画的帧率范围
expected: 40, // 设置动画的期望帧率为40hz
min: 0, // 设置帧率范围
max: 120, // 设置帧率范围
},
}, () => {
this.translateX2 = this.isAnimation ? 100 : -100;
})
})
.width('40%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
}
.width('100%')
.justifyContent(FlexAlign.Center)
.shadow(ShadowStyle.OUTER_DEFAULT_SM)
.alignItems(VerticalAlign.Bottom)
.layoutWeight(1)
}
.width('100%')
.justifyContent(FlexAlign.Center)
.shadow(ShadowStyle.OUTER_DEFAULT_SM)
.layoutWeight(1)
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/displaysync-V14
爬取时间: 2025-04-29 19:30:50
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/displaysync-ui-V14
爬取时间: 2025-04-29 19:30:57
来源: Huawei Developer
如果开发者需要以独立的帧率绘制更新操作UI界面时，可以通过DisplaySync来实现。应用中绘制内容的帧率可以使用DisplaySync实例来控制，具体请查阅@ohos.graphics.displaySync(可变帧率)。
开发步骤
此处以不同帧率改变文件组件字体大小为例，来模拟不同UI绘制帧率的效果。
1.  导入模块。
```typescript
import { displaySync } from '@kit.ArkGraphics2D';
```
2.  定义和构建DisplaySync对象。
```typescript
@Entry
@Component
struct Index {
// 定义两个DisplaySync变量，未初始化
private backDisplaySyncSlow: displaySync.DisplaySync | undefined = undefined;
private backDisplaySyncFast: displaySync.DisplaySync | undefined = undefined;
}
```
3.  定义两个文本组件。
```typescript
@State drawFirstSize: number = 25;
@State drawSecondSize: number = 25;
@Builder doSomeRenderFirst() {
Text('30')
.fontSize(this.drawFirstSize)
}
@Builder doSomeRenderSecond() {
Text('60')
.fontSize(this.drawSecondSize)
}
```
4.  通过DisplaySync实例设置帧率和注册订阅函数。 订阅函数运行于UI主线程，故涉及UI线程的耗时操作不应运行于订阅函数中，以免影响性能。
```typescript
CreateDisplaySyncSlow() {
let range : ExpectedFrameRateRange = { // 创建和配置帧率参数
expected: 30, // 设置期望绘制帧率为30hz
min: 0, // 配置帧率范围
max: 120 // 配置帧率范围
};
let draw30 = (intervalInfo: displaySync.IntervalInfo) => { // 订阅回调函数，字体大小在25到150之间变化
if (this.isBigger_30) {
this.drawFirstSize += 1;
if (this.drawFirstSize > 150) {
this.isBigger_30 = false;
}
} else {
this.drawFirstSize -= 1;
if (this.drawFirstSize < 25) {
this.isBigger_30 = true;
}
}
};
this.backDisplaySyncSlow = displaySync.create(); // 创建DisplaySync实例
this.backDisplaySyncSlow.setExpectedFrameRateRange(range); // 设置帧率
this.backDisplaySyncSlow.on("frame", draw30); // 订阅frame事件和注册订阅函数
}
```
5.  开始每帧回调。 创建的DisplaySync实例在start使能后需要aboutToDisappear函数中进行stop操作并置空，避免内存泄漏问题。
```typescript
Button('Start')
.id('CustomDrawStart')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 10, left: 5 })
.fontColor(Color.White)
.onClick((): void => {
if (this.backDisplaySyncSlow == undefined) {
this.CreateDisplaySyncSlow();
}
if (this.backDisplaySyncFast == undefined) {
this.CreateDisplaySyncFast();
}
if (this.backDisplaySyncSlow) {
this.backDisplaySyncSlow.start();
}
if (this.backDisplaySyncFast) {
this.backDisplaySyncFast.start();
}
})
.width('20%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
```
6.  结束每帧回调。
```typescript
Button('Stop')
.id('CustomDrawStop')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 10, left: 5 })
.fontColor(Color.White)
.onClick((): void => {
if (this.backDisplaySyncSlow) {
this.backDisplaySyncSlow.stop();
}
if (this.backDisplaySyncFast) {
this.backDisplaySyncFast.stop();
}
})
.width('20%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
```
完整示例
```typescript
import { displaySync } from '@kit.ArkGraphics2D';
@Entry
@Component
struct Index {
@State drawFirstSize: number = 25;
@State drawSecondSize: number = 25;
private backDisplaySyncSlow: displaySync.DisplaySync | undefined = undefined;
private backDisplaySyncFast: displaySync.DisplaySync | undefined = undefined;
private isBigger_30:boolean = true;
private isBigger_60:boolean = true;
@Builder doSomeRenderFirst() {
Text('30')
.fontSize(this.drawFirstSize)
}
@Builder doSomeRenderSecond() {
Text('60')
.fontSize(this.drawSecondSize)
}
CreateDisplaySyncSlow() {
// 定义期望绘制帧率
let range : ExpectedFrameRateRange = {
expected: 30,
min: 0,
max: 120
};
let draw30 = (intervalInfo: displaySync.IntervalInfo) => {
if (this.isBigger_30) {
this.drawFirstSize += 1;
if (this.drawFirstSize > 150) {
this.isBigger_30 = false;
}
} else {
this.drawFirstSize -= 1;
if (this.drawFirstSize < 25) {
this.isBigger_30 = true;
}
}
};
this.backDisplaySyncSlow = displaySync.create(); // 创建DisplaySync实例
this.backDisplaySyncSlow.setExpectedFrameRateRange(range); // 设置帧率
this.backDisplaySyncSlow.on("frame", draw30); // 订阅frame事件和注册订阅函数
}
CreateDisplaySyncFast() {
// 定义期望绘制帧率
let range : ExpectedFrameRateRange = {
expected: 60,
min: 0,
max: 120
};
let draw60 = (intervalInfo: displaySync.IntervalInfo) => {
if (this.isBigger_60) {
this.drawSecondSize += 1;
if (this.drawSecondSize > 150) {
this.isBigger_60 = false;
}
} else {
this.drawSecondSize -= 1;
if (this.drawSecondSize < 25) {
this.isBigger_60 = true;
}
}
};
this.backDisplaySyncFast= displaySync.create(); // 创建DisplaySync实例
this.backDisplaySyncFast.setExpectedFrameRateRange(range); // 设置帧率
this.backDisplaySyncFast.on("frame", draw60); // 订阅frame事件和注册订阅函数
}
aboutToDisappear() {
if (this.backDisplaySyncSlow) {
this.backDisplaySyncSlow.stop(); // DisplaySync失能关闭
this.backDisplaySyncSlow = undefined; // 实例置空
}
if (this.backDisplaySyncFast) {
this.backDisplaySyncFast.stop(); // DisplaySync失能关闭
this.backDisplaySyncFast = undefined; // 实例置空
}
}
build() {
Column() {
Row() {
this.doSomeRenderFirst();
}
.height('40%')
Row() {
this.doSomeRenderSecond();
}
.height('40%')
Row() {
Button('Start')
.id('CustomDrawStart')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 10, left: 5 })
.fontColor(Color.White)
.onClick((): void => {
if (this.backDisplaySyncSlow == undefined) {
this.CreateDisplaySyncSlow();
}
if (this.backDisplaySyncFast == undefined) {
this.CreateDisplaySyncFast();
}
if (this.backDisplaySyncSlow) {
this.backDisplaySyncSlow.start(); // DisplaySync使能开启
}
if (this.backDisplaySyncFast) {
this.backDisplaySyncFast.start(); // DisplaySync使能开启
}
})
.width('20%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
Button('Stop')
.id('CustomDrawStop')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 10, left: 5 })
.fontColor(Color.White)
.onClick((): void => {
if (this.backDisplaySyncSlow) {
this.backDisplaySyncSlow.stop(); // DisplaySync失能关闭
}
if (this.backDisplaySyncFast) {
this.backDisplaySyncFast.stop(); // DisplaySync失能关闭
}
})
.width('20%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
}
.width('100%')
.justifyContent(FlexAlign.Center)
.shadow(ShadowStyle.OUTER_DEFAULT_SM)
.alignItems(VerticalAlign.Bottom)
.layoutWeight(1)
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/displaysync-overview-V14
爬取时间: 2025-04-29 19:31:03
来源: Huawei Developer
随着设备屏幕的不断演进，当前主流设备采用LTPO屏幕，此类屏幕支持在多个档位之间切换屏幕帧率。
对于快速变化的内容，如射击游戏，交互动画等，显示帧率越高，画面越流畅，但是相对的功耗也会越高。
而低速变化的内容，如游戏大厅，时钟更新动画等，画面更新频率较低，使用相对低的显示帧率，用户也不会觉得卡顿，但是相对的功耗就比较低。
基于显示内容的可变帧率能力，在具备LTPO屏幕的设备上，可以达到性能体验和功耗间的平衡。
HarmonyOS支持可变帧率能力，开发者通过使用可变帧率接口，进行相关业务开发，可以享受可变帧率特性带来的功耗收益。
使用场景
可变帧率能力支持开发者自定义应用业务的帧率，其常见的使用场景：
运作机制
可变帧率为应用开发中的动画组件、XComponent组件、UI绘制等提供一种基础帧率配置和能力。
开发者通过设置有效的期望绘制帧率后，系统会收集设置的请求帧率，进行决策和分发，在渲染管线上进行分频，尽量能够满足开发者的期望帧率。
约束与限制
开发者设置的期望帧率值不能代表最终实际效果，会受限于系统能力和屏幕刷新率。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/displaysync-xcomponent-V14
爬取时间: 2025-04-29 19:31:11
来源: Huawei Developer
对于基于XComponent进行Native开发的业务，可以请求独立的绘制帧率进行内容开发，如游戏、自绘制UI框架对接等场景。
接口说明
| 函数名称 | 说明 |
| --- | --- |
| OH_NativeXComponent_SetExpectedFrameRateRange (OH_NativeXComponent *component, OH_NativeXComponent_ExpectedRateRange *range) | 设置帧期望的帧率范围。 |
| OH_NativeXComponent_RegisterOnFrameCallback (OH_NativeXComponent *component, OH_NativeXComponent_OnFrameCallback *callback) | 设置每帧回调函数，同时启动每帧回调。 |
| OH_NativeXComponent_UnRegisterOnFrameCallback (OH_NativeXComponent *component) | 取消注册的每帧回调函数，同时停止调用回调函数。 |
开发步骤
本范例是通过Drawing在Native侧实现图形的绘制，并将其呈现在NativeWindow上，具体可参考使用Drawing实现图形绘制与显示。
1.  定义ArkTS接口文件XComponentContext.ts，用来对接Native层。
```typescript
export default interface XComponentContext {
register(): void;
unregister(): void;
};
```
2.  定义演示页面，包含两个XComponent组件。
```typescript
import XComponentContext from "../interface/XComponentContext";
@Entry
@Component
struct Index {
private xComponentContext1: XComponentContext | undefined = undefined;
private xComponentContext2: XComponentContext | undefined = undefined;
build() {
Column() {
Row() {
XComponent({ id: 'xcomponentId_30', type: 'surface', libraryname: 'entry' })
.onLoad((xComponentContext) => {
this.xComponentContext1 = xComponentContext as XComponentContext;
}).width('832px')
}.height('40%')
Row() {
XComponent({ id: 'xcomponentId_120', type: 'surface', libraryname: 'entry' })
.onLoad((xComponentContext) => {
this.xComponentContext2 = xComponentContext as XComponentContext;
}).width('832px') // Multiples of 64
}.height('40%')
}
}
}
```
3.  Native层配置帧率和注册回调函数。
```typescript
static void TestCallback(OH_NativeXComponent *component, uint64_t timestamp, uint64_t targetTimestamp) // 定义每帧的回调函数
{
// ...
// 获取XComponent的surface大小
int32_t xSize = OH_NativeXComponent_GetXComponentSize(component, nativeWindow, &width, &height);
if ((xSize == OH_NATIVEXCOMPONENT_RESULT_SUCCESS) && (render != nullptr)) {
render->Prepare();
render->Create();
if (id == "xcomponentId_30") {
// 30Hz绘制时,每帧移动的距离为16像素
render->ConstructPath(16, 16, render->defaultOffsetY);
}
if (id == "xcomponentId_120") {
// 120Hz绘制时，每帧移动的距离为4像素
render->ConstructPath(4, 4, render->defaultOffsetY);
}
// ...
}
}
```
4.  TS层注册和取消注册每帧回调。
```typescript
Row() {
Button('Start')
.id('Start')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 20, right: 6, left: 6 })
.onClick(() => {
if (this.xComponentContext1) {
this.xComponentContext1.register();
}
if (this.xComponentContext2) {
this.xComponentContext2.register();
}
})
.width('30%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
Button('Stop')
.id('Stop')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 20, left: 6 })
.onClick(() => {
if (this.xComponentContext1) {
this.xComponentContext1.unregister();
}
if (this.xComponentContext2) {
this.xComponentContext2.unregister();
}
})
.width('30%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/displaysync-animation-V14
爬取时间: 2025-04-29 19:31:16
来源: Huawei Developer
在应用开发中，属性动画和显式动画能够使用可选参数ExpectedFrameRateRange，为不同的动画配置不同的期望绘制帧率。
请求属性动画的绘制帧率
定义文本组件的属性动画，请求绘制帧率为60，范例如下：
```typescript
Text()
.animation({
duration: 1200,
iterations: 10,
expectedFrameRateRange: { // 设置属性动画的帧率范围
expected: 60, // 设置动画的期望帧率为60hz
min: 0, // 设置帧率范围
max: 120, // 设置帧率范围
},
})
```
请求显式动画的绘制帧率
定义按钮组件的显式动画，请求绘制帧率为30，范例如下：
```typescript
Button()
.onClick(() => {
animateTo({
duration: 1200,
iterations: 10,
expectedFrameRateRange: { // 设置显式动画的帧率范围
expected: 30, // 设置动画的期望帧率为30hz
min: 0, // 设置帧率范围
max: 120, // 设置帧率范围
},
}, () => {
})
})
```
完整示例
```typescript
@Entry
@Component
struct AnimationToAnimationDemo {
@State isAnimation: boolean = false;
@State translateX1: number = -100;
@State translateX2: number = -100;
@State translateX3: number = -100;
build() {
Column() {
Row() {
Text('30')
.fontWeight(FontWeight.Bold)
.fontSize(16)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.borderRadius(10)
.backgroundColor(0xF56C6C)
.width(80)
.height(80)
.translate({ x: this.translateX1 })
}
.height('20%')
Row() {
Text('40')
.fontWeight(FontWeight.Bold)
.fontSize(16)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.borderRadius(10)
.backgroundColor(0x2E8B57)
.width(80)
.height(80)
.translate({ x: this.translateX2 })
}
.height('20%')
Row() {
Text('60')
.fontWeight(FontWeight.Bold)
.fontSize(16)
.fontColor(Color.White)
.textAlign(TextAlign.Center)
.borderRadius(10)
.backgroundColor(0x008B8B)
.width(80)
.height(80)
.translate({ x: this.translateX3 })
.animation({
duration: 1200,
iterations: 10,
playMode: PlayMode.AlternateReverse,
expectedFrameRateRange: { // 设置属性动画的帧率范围
expected: 60, // 设置动画的期望帧率为60hz
min: 0, // 设置帧率范围
max: 120, // 设置帧率范围
},
})
}
.height('20%')
Row() {
Button('Start')
.id('PropertyAnimationStart')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 10, left: 5 })
.fontColor(Color.White)
.onClick(() => {
this.isAnimation = !this.isAnimation;
this.translateX3 = this.isAnimation ? 100 : -100;
animateTo({
duration: 1200,
iterations: 10,
playMode: PlayMode.AlternateReverse,
expectedFrameRateRange: { // 设置显式动画的帧率范围
expected: 30, // 设置动画的期望帧率为30hz
min: 0, // 设置帧率范围
max: 120, // 设置帧率范围
},
}, () => {
this.translateX1 = this.isAnimation ? 100 : -100;
})
animateTo({
duration: 1200,
iterations: 10,
playMode: PlayMode.AlternateReverse,
expectedFrameRateRange: { // 设置显式动画的帧率范围
expected: 40, // 设置动画的期望帧率为40hz
min: 0, // 设置帧率范围
max: 120, // 设置帧率范围
},
}, () => {
this.translateX2 = this.isAnimation ? 100 : -100;
})
})
.width('40%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
}
.width('100%')
.justifyContent(FlexAlign.Center)
.shadow(ShadowStyle.OUTER_DEFAULT_SM)
.alignItems(VerticalAlign.Bottom)
.layoutWeight(1)
}
.width('100%')
.justifyContent(FlexAlign.Center)
.shadow(ShadowStyle.OUTER_DEFAULT_SM)
.layoutWeight(1)
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/displaysoloist-native-guidelines-V14
爬取时间: 2025-04-29 19:31:24
来源: Huawei Developer
如果开发者想在独立线程中进行帧率控制的Native侧业务，可以通过DisplaySoloist来实现，如游戏、自绘制UI框架对接等场景。
开发者可以选择多个DisplaySoloist实例共享一个线程，也可以选择每个DisplaySoloist实例独占一个线程。
接口说明
| 函数名称 | 说明 |
| --- | --- |
| OH_DisplaySoloist* OH_DisplaySoloist_Create (bool useExclusiveThread) | 创建一个OH_DisplaySoloist实例。 |
| OH_DisplaySoloist_Destroy (OH_DisplaySoloist * displaySoloist) | 销毁一个OH_DisplaySoloist实例。 |
| OH_DisplaySoloist_Start (OH_DisplaySoloist * displaySoloist, OH_DisplaySoloist_FrameCallback callback, void * data ) | 设置每帧回调函数，每次VSync信号到来时启动每帧回调。 |
| OH_DisplaySoloist_Stop (OH_DisplaySoloist * displaySoloist) | 停止请求下一次VSync信号，并停止调用回调函数callback。 |
| OH_DisplaySoloist_SetExpectedFrameRateRange (OH_DisplaySoloist* displaySoloist, DisplaySoloist_ExpectedRateRange* range) | 设置期望帧率范围。 |
开发示例
本范例是通过Drawing在Native侧实现图形的绘制，通过异步线程设置期望的帧率，再根据帧率进行图形的绘制并将其呈现在NativeWindow上，图形绘制部分可参考使用Drawing实现图形绘制与显示。
添加开发依赖
添加动态链接库
CMakeLists.txt中添加以下lib。
头文件
开发步骤
1.  定义ArkTS接口文件XComponentContext.ts，用来对接Native层。
```typescript
export default interface XComponentContext {
register(): void;
unregister(): void;
destroy(): void;
};
```
2.  定义演示页面，包含两个XComponent组件。
```typescript
import XComponentContext from "../interface/XComponentContext";
@Entry
@Component
struct Index {
private xComponentContext1: XComponentContext | undefined = undefined;
private xComponentContext2: XComponentContext | undefined = undefined;
build() {
Column() {
Row() {
XComponent({ id: 'xcomponentId30', type: 'surface', libraryname: 'entry' })
.onLoad((xComponentContext) => {
this.xComponentContext1 = xComponentContext as XComponentContext;
}).width('640px')
}.height('40%')
Row() {
XComponent({ id: 'xcomponentId120', type: 'surface', libraryname: 'entry' })
.onLoad((xComponentContext) => {
this.xComponentContext2 = xComponentContext as XComponentContext;
}).width('640px') // 64的倍数
}.height('40%')
}
}
}
```
3.  在 Native C++层获取NativeXComponent。建议使用单例模式保存XComponent。此步骤需要在napi_init的过程中处理。 创建一个PluginManger单例类，用于管理NativeXComponent。 SampleXComponent类会在后面的绘制图形中创建。
4.  Native层配置帧率和注册回调函数。 定义每帧回调函数内容。 使用DisplaySoloist接口配置帧率和注册每帧回调函数。
5.  TS层注册和取消注册每帧回调，销毁OH_DisplaySoloist实例。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/displaysync-ui-V14
爬取时间: 2025-04-29 19:31:30
来源: Huawei Developer
如果开发者需要以独立的帧率绘制更新操作UI界面时，可以通过DisplaySync来实现。应用中绘制内容的帧率可以使用DisplaySync实例来控制，具体请查阅@ohos.graphics.displaySync(可变帧率)。
开发步骤
此处以不同帧率改变文件组件字体大小为例，来模拟不同UI绘制帧率的效果。
1.  导入模块。
```typescript
import { displaySync } from '@kit.ArkGraphics2D';
```
2.  定义和构建DisplaySync对象。
```typescript
@Entry
@Component
struct Index {
// 定义两个DisplaySync变量，未初始化
private backDisplaySyncSlow: displaySync.DisplaySync | undefined = undefined;
private backDisplaySyncFast: displaySync.DisplaySync | undefined = undefined;
}
```
3.  定义两个文本组件。
```typescript
@State drawFirstSize: number = 25;
@State drawSecondSize: number = 25;
@Builder doSomeRenderFirst() {
Text('30')
.fontSize(this.drawFirstSize)
}
@Builder doSomeRenderSecond() {
Text('60')
.fontSize(this.drawSecondSize)
}
```
4.  通过DisplaySync实例设置帧率和注册订阅函数。 订阅函数运行于UI主线程，故涉及UI线程的耗时操作不应运行于订阅函数中，以免影响性能。
```typescript
CreateDisplaySyncSlow() {
let range : ExpectedFrameRateRange = { // 创建和配置帧率参数
expected: 30, // 设置期望绘制帧率为30hz
min: 0, // 配置帧率范围
max: 120 // 配置帧率范围
};
let draw30 = (intervalInfo: displaySync.IntervalInfo) => { // 订阅回调函数，字体大小在25到150之间变化
if (this.isBigger_30) {
this.drawFirstSize += 1;
if (this.drawFirstSize > 150) {
this.isBigger_30 = false;
}
} else {
this.drawFirstSize -= 1;
if (this.drawFirstSize < 25) {
this.isBigger_30 = true;
}
}
};
this.backDisplaySyncSlow = displaySync.create(); // 创建DisplaySync实例
this.backDisplaySyncSlow.setExpectedFrameRateRange(range); // 设置帧率
this.backDisplaySyncSlow.on("frame", draw30); // 订阅frame事件和注册订阅函数
}
```
5.  开始每帧回调。 创建的DisplaySync实例在start使能后需要aboutToDisappear函数中进行stop操作并置空，避免内存泄漏问题。
```typescript
Button('Start')
.id('CustomDrawStart')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 10, left: 5 })
.fontColor(Color.White)
.onClick((): void => {
if (this.backDisplaySyncSlow == undefined) {
this.CreateDisplaySyncSlow();
}
if (this.backDisplaySyncFast == undefined) {
this.CreateDisplaySyncFast();
}
if (this.backDisplaySyncSlow) {
this.backDisplaySyncSlow.start();
}
if (this.backDisplaySyncFast) {
this.backDisplaySyncFast.start();
}
})
.width('20%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
```
6.  结束每帧回调。
```typescript
Button('Stop')
.id('CustomDrawStop')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 10, left: 5 })
.fontColor(Color.White)
.onClick((): void => {
if (this.backDisplaySyncSlow) {
this.backDisplaySyncSlow.stop();
}
if (this.backDisplaySyncFast) {
this.backDisplaySyncFast.stop();
}
})
.width('20%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
```
完整示例
```typescript
import { displaySync } from '@kit.ArkGraphics2D';
@Entry
@Component
struct Index {
@State drawFirstSize: number = 25;
@State drawSecondSize: number = 25;
private backDisplaySyncSlow: displaySync.DisplaySync | undefined = undefined;
private backDisplaySyncFast: displaySync.DisplaySync | undefined = undefined;
private isBigger_30:boolean = true;
private isBigger_60:boolean = true;
@Builder doSomeRenderFirst() {
Text('30')
.fontSize(this.drawFirstSize)
}
@Builder doSomeRenderSecond() {
Text('60')
.fontSize(this.drawSecondSize)
}
CreateDisplaySyncSlow() {
// 定义期望绘制帧率
let range : ExpectedFrameRateRange = {
expected: 30,
min: 0,
max: 120
};
let draw30 = (intervalInfo: displaySync.IntervalInfo) => {
if (this.isBigger_30) {
this.drawFirstSize += 1;
if (this.drawFirstSize > 150) {
this.isBigger_30 = false;
}
} else {
this.drawFirstSize -= 1;
if (this.drawFirstSize < 25) {
this.isBigger_30 = true;
}
}
};
this.backDisplaySyncSlow = displaySync.create(); // 创建DisplaySync实例
this.backDisplaySyncSlow.setExpectedFrameRateRange(range); // 设置帧率
this.backDisplaySyncSlow.on("frame", draw30); // 订阅frame事件和注册订阅函数
}
CreateDisplaySyncFast() {
// 定义期望绘制帧率
let range : ExpectedFrameRateRange = {
expected: 60,
min: 0,
max: 120
};
let draw60 = (intervalInfo: displaySync.IntervalInfo) => {
if (this.isBigger_60) {
this.drawSecondSize += 1;
if (this.drawSecondSize > 150) {
this.isBigger_60 = false;
}
} else {
this.drawSecondSize -= 1;
if (this.drawSecondSize < 25) {
this.isBigger_60 = true;
}
}
};
this.backDisplaySyncFast= displaySync.create(); // 创建DisplaySync实例
this.backDisplaySyncFast.setExpectedFrameRateRange(range); // 设置帧率
this.backDisplaySyncFast.on("frame", draw60); // 订阅frame事件和注册订阅函数
}
aboutToDisappear() {
if (this.backDisplaySyncSlow) {
this.backDisplaySyncSlow.stop(); // DisplaySync失能关闭
this.backDisplaySyncSlow = undefined; // 实例置空
}
if (this.backDisplaySyncFast) {
this.backDisplaySyncFast.stop(); // DisplaySync失能关闭
this.backDisplaySyncFast = undefined; // 实例置空
}
}
build() {
Column() {
Row() {
this.doSomeRenderFirst();
}
.height('40%')
Row() {
this.doSomeRenderSecond();
}
.height('40%')
Row() {
Button('Start')
.id('CustomDrawStart')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 10, left: 5 })
.fontColor(Color.White)
.onClick((): void => {
if (this.backDisplaySyncSlow == undefined) {
this.CreateDisplaySyncSlow();
}
if (this.backDisplaySyncFast == undefined) {
this.CreateDisplaySyncFast();
}
if (this.backDisplaySyncSlow) {
this.backDisplaySyncSlow.start(); // DisplaySync使能开启
}
if (this.backDisplaySyncFast) {
this.backDisplaySyncFast.start(); // DisplaySync使能开启
}
})
.width('20%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
Button('Stop')
.id('CustomDrawStop')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 10, left: 5 })
.fontColor(Color.White)
.onClick((): void => {
if (this.backDisplaySyncSlow) {
this.backDisplaySyncSlow.stop(); // DisplaySync失能关闭
}
if (this.backDisplaySyncFast) {
this.backDisplaySyncFast.stop(); // DisplaySync失能关闭
}
})
.width('20%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
}
.width('100%')
.justifyContent(FlexAlign.Center)
.shadow(ShadowStyle.OUTER_DEFAULT_SM)
.alignItems(VerticalAlign.Bottom)
.layoutWeight(1)
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/overdraw-dfx-guidelines-V14
爬取时间: 2025-04-29 19:31:37
来源: Huawei Developer
当应用页面布局的嵌套程度过深时，应用渲染阶段会存在一些组件的绘制指令被其他组件的绘制指令部分或完全覆盖遮挡的情况，造成冗余的CPU、GPU等计算资源的使用。这种一个屏幕上的像素点被重复绘制了多次的情况被称为过度绘制（Overdraw）。开发者可通过系统提供的过度绘制调试指令，查看引起过度绘制的组件位置及其层级，从而减轻应用渲染时的负载。
本文将分别介绍过度绘制调试功能的使用方式，以及如何进行过度绘制的分析和优化。
使用方式
系统提供的过度绘制调试功能，可通过shell进行开启或者关闭。
-  使用前提：需在系统设置中开启开发者模式。
-  开启过度绘制调试功能：
-  关闭过度绘制调试功能：
-  查看是否开启了过度绘制调试功能： true表示开启了过度绘制功能，false则表示未开启。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.48701428473151332695455713208479:50001231000000:2800:30498967CDC760F5F255CD19543E1BAEF503070BD9463F2E8C4A2B20A17872E6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.40129307752724788516414829994651:50001231000000:2800:AF0BAA700FDB565D5CA3BB64DFACDF65C0EEB64046437E013357CB7103029A83.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.34291047310167567775868702583159:50001231000000:2800:5F6FF124D7F9428ACD5F0D968D7D552B85A0C3390AAC84670CC6777E409E01FF.png)
过度绘制组件分析
开启了过度绘制调试功能后，打开应用界面，存在过度绘制情况的像素会被代表着不同级别的颜色方框高亮出来，其颜色越深代表过度绘制情况越严重，对应关系如下：
以下是一个存在冗余的背景颜色嵌套问题的示例应用程序，及其对应的开启过度绘制调试功能的界面显示情况。
```typescript
@Entry
@Component
struct Index {
@State message: string = 'Hello World'
build() {
Row() {
Column() {
Column() {
Column() {
Column() {
Column() {
Text("Hello World")
}
.width('80%')
.height('80%')
.backgroundColor(Color.White)
}
.width('80%')
.height('80%')
.backgroundColor(Color.White)
}
.width('80%')
.height('80%')
.backgroundColor(Color.White)
}
.width('80%')
.height('80%')
.backgroundColor(Color.White)
}
.width('80%')
}
.height('80%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.84888835500039876586891897288878:50001231000000:2800:C3DFA70ABDE035A833CD43FFE036E9DE130EA68FCEEAC27FC4F19460CB6582F2.png)
编译安装后打开过度绘制调试功能，应用界面如上图所示。
可以发现，从Hello World文字组件开始，由内到外的这几个Column组件在界面上分别显示为深红色-浅红色-绿色-蓝紫色-原色。这种现象说明，随着嵌套程度的加深，每一个Column组件的背景颜色绘制都会带来一次过度绘制。
另外，状态栏、侧边栏等系统界面也会在过度绘制调试功能中被统计到，此为正常现象。
如何减少过度绘制现象
通过上文所述的调试功能可以帮助我们发现应用界面里存在的过度绘制问题，通常我们建议采用如下方式减少过度绘制的现象：
-  通过显隐控制或者if-else条件，减少页面上冗余的组件。
-  减少被完全遮挡的组件上的绘制指令，如背景颜色、组件内容等。
-  采用扁平化布局，减少组件嵌套深度，比如将大小相近、功能类似的布局组件合并为一个组件等。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/displaysync-xcomponent-V14
爬取时间: 2025-04-29 19:31:43
来源: Huawei Developer
对于基于XComponent进行Native开发的业务，可以请求独立的绘制帧率进行内容开发，如游戏、自绘制UI框架对接等场景。
接口说明
| 函数名称 | 说明 |
| --- | --- |
| OH_NativeXComponent_SetExpectedFrameRateRange (OH_NativeXComponent *component, OH_NativeXComponent_ExpectedRateRange *range) | 设置帧期望的帧率范围。 |
| OH_NativeXComponent_RegisterOnFrameCallback (OH_NativeXComponent *component, OH_NativeXComponent_OnFrameCallback *callback) | 设置每帧回调函数，同时启动每帧回调。 |
| OH_NativeXComponent_UnRegisterOnFrameCallback (OH_NativeXComponent *component) | 取消注册的每帧回调函数，同时停止调用回调函数。 |
开发步骤
本范例是通过Drawing在Native侧实现图形的绘制，并将其呈现在NativeWindow上，具体可参考使用Drawing实现图形绘制与显示。
1.  定义ArkTS接口文件XComponentContext.ts，用来对接Native层。
```typescript
export default interface XComponentContext {
register(): void;
unregister(): void;
};
```
2.  定义演示页面，包含两个XComponent组件。
```typescript
import XComponentContext from "../interface/XComponentContext";
@Entry
@Component
struct Index {
private xComponentContext1: XComponentContext | undefined = undefined;
private xComponentContext2: XComponentContext | undefined = undefined;
build() {
Column() {
Row() {
XComponent({ id: 'xcomponentId_30', type: 'surface', libraryname: 'entry' })
.onLoad((xComponentContext) => {
this.xComponentContext1 = xComponentContext as XComponentContext;
}).width('832px')
}.height('40%')
Row() {
XComponent({ id: 'xcomponentId_120', type: 'surface', libraryname: 'entry' })
.onLoad((xComponentContext) => {
this.xComponentContext2 = xComponentContext as XComponentContext;
}).width('832px') // Multiples of 64
}.height('40%')
}
}
}
```
3.  Native层配置帧率和注册回调函数。
```typescript
static void TestCallback(OH_NativeXComponent *component, uint64_t timestamp, uint64_t targetTimestamp) // 定义每帧的回调函数
{
// ...
// 获取XComponent的surface大小
int32_t xSize = OH_NativeXComponent_GetXComponentSize(component, nativeWindow, &width, &height);
if ((xSize == OH_NATIVEXCOMPONENT_RESULT_SUCCESS) && (render != nullptr)) {
render->Prepare();
render->Create();
if (id == "xcomponentId_30") {
// 30Hz绘制时,每帧移动的距离为16像素
render->ConstructPath(16, 16, render->defaultOffsetY);
}
if (id == "xcomponentId_120") {
// 120Hz绘制时，每帧移动的距离为4像素
render->ConstructPath(4, 4, render->defaultOffsetY);
}
// ...
}
}
```
4.  TS层注册和取消注册每帧回调。
```typescript
Row() {
Button('Start')
.id('Start')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 20, right: 6, left: 6 })
.onClick(() => {
if (this.xComponentContext1) {
this.xComponentContext1.register();
}
if (this.xComponentContext2) {
this.xComponentContext2.register();
}
})
.width('30%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
Button('Stop')
.id('Stop')
.fontSize(14)
.fontWeight(500)
.margin({ bottom: 20, left: 6 })
.onClick(() => {
if (this.xComponentContext1) {
this.xComponentContext1.unregister();
}
if (this.xComponentContext2) {
this.xComponentContext2.unregister();
}
})
.width('30%')
.height(40)
.shadow(ShadowStyle.OUTER_DEFAULT_LG)
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphic-drawing-and-display-V14
爬取时间: 2025-04-29 19:31:51
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/displaysoloist-native-guidelines-V14
爬取时间: 2025-04-29 19:31:56
来源: Huawei Developer
如果开发者想在独立线程中进行帧率控制的Native侧业务，可以通过DisplaySoloist来实现，如游戏、自绘制UI框架对接等场景。
开发者可以选择多个DisplaySoloist实例共享一个线程，也可以选择每个DisplaySoloist实例独占一个线程。
接口说明
| 函数名称 | 说明 |
| --- | --- |
| OH_DisplaySoloist* OH_DisplaySoloist_Create (bool useExclusiveThread) | 创建一个OH_DisplaySoloist实例。 |
| OH_DisplaySoloist_Destroy (OH_DisplaySoloist * displaySoloist) | 销毁一个OH_DisplaySoloist实例。 |
| OH_DisplaySoloist_Start (OH_DisplaySoloist * displaySoloist, OH_DisplaySoloist_FrameCallback callback, void * data ) | 设置每帧回调函数，每次VSync信号到来时启动每帧回调。 |
| OH_DisplaySoloist_Stop (OH_DisplaySoloist * displaySoloist) | 停止请求下一次VSync信号，并停止调用回调函数callback。 |
| OH_DisplaySoloist_SetExpectedFrameRateRange (OH_DisplaySoloist* displaySoloist, DisplaySoloist_ExpectedRateRange* range) | 设置期望帧率范围。 |
开发示例
本范例是通过Drawing在Native侧实现图形的绘制，通过异步线程设置期望的帧率，再根据帧率进行图形的绘制并将其呈现在NativeWindow上，图形绘制部分可参考使用Drawing实现图形绘制与显示。
添加开发依赖
添加动态链接库
CMakeLists.txt中添加以下lib。
头文件
开发步骤
1.  定义ArkTS接口文件XComponentContext.ts，用来对接Native层。
```typescript
export default interface XComponentContext {
register(): void;
unregister(): void;
destroy(): void;
};
```
2.  定义演示页面，包含两个XComponent组件。
```typescript
import XComponentContext from "../interface/XComponentContext";
@Entry
@Component
struct Index {
private xComponentContext1: XComponentContext | undefined = undefined;
private xComponentContext2: XComponentContext | undefined = undefined;
build() {
Column() {
Row() {
XComponent({ id: 'xcomponentId30', type: 'surface', libraryname: 'entry' })
.onLoad((xComponentContext) => {
this.xComponentContext1 = xComponentContext as XComponentContext;
}).width('640px')
}.height('40%')
Row() {
XComponent({ id: 'xcomponentId120', type: 'surface', libraryname: 'entry' })
.onLoad((xComponentContext) => {
this.xComponentContext2 = xComponentContext as XComponentContext;
}).width('640px') // 64的倍数
}.height('40%')
}
}
}
```
3.  在 Native C++层获取NativeXComponent。建议使用单例模式保存XComponent。此步骤需要在napi_init的过程中处理。 创建一个PluginManger单例类，用于管理NativeXComponent。 SampleXComponent类会在后面的绘制图形中创建。
4.  Native层配置帧率和注册回调函数。 定义每帧回调函数内容。 使用DisplaySoloist接口配置帧率和注册每帧回调函数。
5.  TS层注册和取消注册每帧回调，销毁OH_DisplaySoloist实例。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphic-drawing-overview-V14
爬取时间: 2025-04-29 19:32:05
来源: Huawei Developer
场景介绍
应用在开发中，经常需要针对不同的元素内容进行绘制，开发者通常可以选择直接使用ArkUI组件来绘制想要的元素或效果，但有些自定义图形或效果无法满足，此时可以选择使用Drawing来实现灵活的自定义绘制效果。另外，ArkUI组件具备直接上屏显示的能力，而Drawing更加关注绘制，需要依靠其他模块来完成绘制结果的上屏显示。
绘制能力范围及实现流程
图1图形绘制主要能力
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.02941696142207367911236614995353:50001231000000:2800:85B40CE81839C83450F4C1BBBA9ED805BF10DE258F128C88609A69AACF45A5EA.jpg)
ArkGraphics 2D基于2D图像渲染引擎为开发者提供了一系列灵活多样的图形绘制接口。主要分为画布操作、绘制效果、图元绘制几方面，各部分支持能力关键列举如上图所示，后续可能支持更多相关能力，此处不再一一呈现，具体可关注对应API参考文档。
画布操作、绘制效果、图元绘制也是实现图形绘制的关键步骤和流程，具体可见下图。
图2图形绘制的实现流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.78471052028729532546193212454753:50001231000000:2800:205DEC1EAACE48F472B79E067142F6859A487995DD53E37ABF51B990D0487D36.jpg)
2D图形绘制过程和实际作画的过程是相似的，上图即以绘制经过旋转的红色填充矩形为例，提供了图形绘制的流程。主要实现流程和步骤如下：
1.  创建画布（必选）：画布作为图形绘制的承载，是最基本最关键的。在进行图形绘制时，需要先创建画布，确保图形可承载，才能进行后续的相关设置和操作。
2.  进行画布操作（可选）：创建画布之后，可以基于画布进一步进行相关操作，比如裁剪、旋转、缩放等等。此步骤为可选步骤，开发者可以根据具体的场景需求选择进行对应的画布操作。
3.  设置绘制效果（可选）：绘制效果主要通过画刷（Brush）和画笔（Pen）实现。画笔针对的是图形轮廓，画刷针对的是图形内部区域。通过画刷和画笔，可以实现丰富多样的填充效果和描边效果，开发者可根据具体UI效果和需要选择设置相关效果。如果不设置绘制效果，会使用默认的绘制效果。
4.  绘制图元（必选）：图形绘制最后一步即为图元的绘制，不论多么复杂的图形，都是基础图元的不同组合，当前ArkGraphics 2D支持多种图元的绘制。创建Canvas画布并完成相关操作和设置后，开发者再选择对应的图元进行绘制即可完成图形绘制的全部流程。
如何显示绘制结果
以上内容主要呈现了ArkGraphics 2D基于2D图像渲染引擎的主要绘制能力和实现流程，基于画布完成绘制后，还需要将绘制结果上屏显示才能完整实现屏幕上可见的图形UI内容。
当前Drawing依赖的显示方式主要有以下两种：
1.  通过RenderNode上屏显示（ArkTS）：通过RenderNode获取Canvas，进行绘制，由RenderNode将绘制结果上屏显示，具体可参考画布的获取与绘制结果的显示（ArkTS）。
2.  通过XComponent上屏显示（C/C++）：创建Canvas，进行绘制，将绘制结果拷贝到buffer，由XComponent将绘制结果上屏显示，具体实现可参考画布的获取与绘制结果的显示（C/C++）。
与Canvas画布组件的关系
Canvas组件也具有自绘制的能力，目前有CanvasRenderingContext2D/OffscreenCanvasRenderingContext2D和DrawingRenderingContext两套API，应用使用两套绘制API绘制的内容都可以在绑定的Canvas组件上显示。
其中CanvasRenderingContext2D按照W3C标准封装了ArkGraphics 2D中Native Drawing的相关接口，可以方便快速复用Web应用的绘制逻辑，因此非常适用于Web应用和游戏、快速原型设计、数据可视化、在线绘图板、教学工具或创意应用等场景。
Canvas组件的底层也使用了Native Drawing接口来实现绘制功能，在绘制能力上两者没有本质的区别。但因为多层封装的实现过程，使得Canvas组件不如Native Drawing原生API接近硬件，因此对于性能要求比较高、绘制比较复杂、硬件依赖性比较强的场景，如专业图形处理软件、桌面或移动应用等，使用Canvas组件绘制可能会存在一定的卡顿、掉帧等性能问题，此时可以使用Native Drawing接口的自绘制能力，确保应用的绘制性能。
约束限制
针对图形绘制过程中，使用的单位为像素单位px。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/overdraw-dfx-guidelines-V14
爬取时间: 2025-04-29 19:32:10
来源: Huawei Developer
当应用页面布局的嵌套程度过深时，应用渲染阶段会存在一些组件的绘制指令被其他组件的绘制指令部分或完全覆盖遮挡的情况，造成冗余的CPU、GPU等计算资源的使用。这种一个屏幕上的像素点被重复绘制了多次的情况被称为过度绘制（Overdraw）。开发者可通过系统提供的过度绘制调试指令，查看引起过度绘制的组件位置及其层级，从而减轻应用渲染时的负载。
本文将分别介绍过度绘制调试功能的使用方式，以及如何进行过度绘制的分析和优化。
使用方式
系统提供的过度绘制调试功能，可通过shell进行开启或者关闭。
-  使用前提：需在系统设置中开启开发者模式。
-  开启过度绘制调试功能：
-  关闭过度绘制调试功能：
-  查看是否开启了过度绘制调试功能： true表示开启了过度绘制功能，false则表示未开启。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.48701428473151332695455713208479:50001231000000:2800:30498967CDC760F5F255CD19543E1BAEF503070BD9463F2E8C4A2B20A17872E6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.40129307752724788516414829994651:50001231000000:2800:AF0BAA700FDB565D5CA3BB64DFACDF65C0EEB64046437E013357CB7103029A83.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.34291047310167567775868702583159:50001231000000:2800:5F6FF124D7F9428ACD5F0D968D7D552B85A0C3390AAC84670CC6777E409E01FF.png)
过度绘制组件分析
开启了过度绘制调试功能后，打开应用界面，存在过度绘制情况的像素会被代表着不同级别的颜色方框高亮出来，其颜色越深代表过度绘制情况越严重，对应关系如下：
以下是一个存在冗余的背景颜色嵌套问题的示例应用程序，及其对应的开启过度绘制调试功能的界面显示情况。
```typescript
@Entry
@Component
struct Index {
@State message: string = 'Hello World'
build() {
Row() {
Column() {
Column() {
Column() {
Column() {
Column() {
Text("Hello World")
}
.width('80%')
.height('80%')
.backgroundColor(Color.White)
}
.width('80%')
.height('80%')
.backgroundColor(Color.White)
}
.width('80%')
.height('80%')
.backgroundColor(Color.White)
}
.width('80%')
.height('80%')
.backgroundColor(Color.White)
}
.width('80%')
}
.height('80%')
}
}
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.84888835500039876586891897288878:50001231000000:2800:C3DFA70ABDE035A833CD43FFE036E9DE130EA68FCEEAC27FC4F19460CB6582F2.png)
编译安装后打开过度绘制调试功能，应用界面如上图所示。
可以发现，从Hello World文字组件开始，由内到外的这几个Column组件在界面上分别显示为深红色-浅红色-绿色-蓝紫色-原色。这种现象说明，随着嵌套程度的加深，每一个Column组件的背景颜色绘制都会带来一次过度绘制。
另外，状态栏、侧边栏等系统界面也会在过度绘制调试功能中被统计到，此为正常现象。
如何减少过度绘制现象
通过上文所述的调试功能可以帮助我们发现应用界面里存在的过度绘制问题，通常我们建议采用如下方式减少过度绘制的现象：
-  通过显隐控制或者if-else条件，减少页面上冗余的组件。
-  减少被完全遮挡的组件上的绘制指令，如背景颜色、组件内容等。
-  采用扁平化布局，减少组件嵌套深度，比如将大小相近、功能类似的布局组件合并为一个组件等。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphic-drawing-and-display-V14
爬取时间: 2025-04-29 19:32:23
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphic-drawing-overview-V14
爬取时间: 2025-04-29 19:32:36
来源: Huawei Developer
场景介绍
应用在开发中，经常需要针对不同的元素内容进行绘制，开发者通常可以选择直接使用ArkUI组件来绘制想要的元素或效果，但有些自定义图形或效果无法满足，此时可以选择使用Drawing来实现灵活的自定义绘制效果。另外，ArkUI组件具备直接上屏显示的能力，而Drawing更加关注绘制，需要依靠其他模块来完成绘制结果的上屏显示。
绘制能力范围及实现流程
图1图形绘制主要能力
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.02941696142207367911236614995353:50001231000000:2800:85B40CE81839C83450F4C1BBBA9ED805BF10DE258F128C88609A69AACF45A5EA.jpg)
ArkGraphics 2D基于2D图像渲染引擎为开发者提供了一系列灵活多样的图形绘制接口。主要分为画布操作、绘制效果、图元绘制几方面，各部分支持能力关键列举如上图所示，后续可能支持更多相关能力，此处不再一一呈现，具体可关注对应API参考文档。
画布操作、绘制效果、图元绘制也是实现图形绘制的关键步骤和流程，具体可见下图。
图2图形绘制的实现流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.78471052028729532546193212454753:50001231000000:2800:205DEC1EAACE48F472B79E067142F6859A487995DD53E37ABF51B990D0487D36.jpg)
2D图形绘制过程和实际作画的过程是相似的，上图即以绘制经过旋转的红色填充矩形为例，提供了图形绘制的流程。主要实现流程和步骤如下：
1.  创建画布（必选）：画布作为图形绘制的承载，是最基本最关键的。在进行图形绘制时，需要先创建画布，确保图形可承载，才能进行后续的相关设置和操作。
2.  进行画布操作（可选）：创建画布之后，可以基于画布进一步进行相关操作，比如裁剪、旋转、缩放等等。此步骤为可选步骤，开发者可以根据具体的场景需求选择进行对应的画布操作。
3.  设置绘制效果（可选）：绘制效果主要通过画刷（Brush）和画笔（Pen）实现。画笔针对的是图形轮廓，画刷针对的是图形内部区域。通过画刷和画笔，可以实现丰富多样的填充效果和描边效果，开发者可根据具体UI效果和需要选择设置相关效果。如果不设置绘制效果，会使用默认的绘制效果。
4.  绘制图元（必选）：图形绘制最后一步即为图元的绘制，不论多么复杂的图形，都是基础图元的不同组合，当前ArkGraphics 2D支持多种图元的绘制。创建Canvas画布并完成相关操作和设置后，开发者再选择对应的图元进行绘制即可完成图形绘制的全部流程。
如何显示绘制结果
以上内容主要呈现了ArkGraphics 2D基于2D图像渲染引擎的主要绘制能力和实现流程，基于画布完成绘制后，还需要将绘制结果上屏显示才能完整实现屏幕上可见的图形UI内容。
当前Drawing依赖的显示方式主要有以下两种：
1.  通过RenderNode上屏显示（ArkTS）：通过RenderNode获取Canvas，进行绘制，由RenderNode将绘制结果上屏显示，具体可参考画布的获取与绘制结果的显示（ArkTS）。
2.  通过XComponent上屏显示（C/C++）：创建Canvas，进行绘制，将绘制结果拷贝到buffer，由XComponent将绘制结果上屏显示，具体实现可参考画布的获取与绘制结果的显示（C/C++）。
与Canvas画布组件的关系
Canvas组件也具有自绘制的能力，目前有CanvasRenderingContext2D/OffscreenCanvasRenderingContext2D和DrawingRenderingContext两套API，应用使用两套绘制API绘制的内容都可以在绑定的Canvas组件上显示。
其中CanvasRenderingContext2D按照W3C标准封装了ArkGraphics 2D中Native Drawing的相关接口，可以方便快速复用Web应用的绘制逻辑，因此非常适用于Web应用和游戏、快速原型设计、数据可视化、在线绘图板、教学工具或创意应用等场景。
Canvas组件的底层也使用了Native Drawing接口来实现绘制功能，在绘制能力上两者没有本质的区别。但因为多层封装的实现过程，使得Canvas组件不如Native Drawing原生API接近硬件，因此对于性能要求比较高、绘制比较复杂、硬件依赖性比较强的场景，如专业图形处理软件、桌面或移动应用等，使用Canvas组件绘制可能会存在一定的卡顿、掉帧等性能问题，此时可以使用Native Drawing接口的自绘制能力，确保应用的绘制性能。
约束限制
针对图形绘制过程中，使用的单位为像素单位px。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/canvas-get-result-draw-V14
爬取时间: 2025-04-29 19:32:50
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/canvas-get-result-draw-arkts-V14
爬取时间: 2025-04-29 19:33:03
来源: Huawei Developer
场景介绍
Canvas即画布，提供绘制基本图形的能力，用于在屏幕上绘制图形和处理图形。开发者可以通过Canvas实现自定义的绘图效果，增强应用的用户体验。
Canvas是图形绘制的核心，本章中提到的所有绘制操作（包括基本图形的绘制、文字的绘制、图片的绘制、图形变换等）都是基于Canvas的。
目前ArkTS有两种获取Canvas的方式：获取可直接显示的Canvas画布、获取离屏的Canvas，前者在调用绘制接口之后无需进行额外的操作即可完成绘制结果的上屏显示，而后者需要依靠已有的显示手段来显示绘制结果。
获取可直接显示的Canvas画布
通过RenderNode获取可直接上屏显示的Canvas画布。
1.  添加自定义RenderNode。
2.  添加自定义NodeController。
3.  重写自定义RenderNode的draw()函数，获取Canvas进行自定义的绘制操作，即本章下文中的内容。
4.  将自定义NodeController进行显示。
```typescript
import { UIContext, NodeController, FrameNode, RenderNode, DrawContext } from '@kit.ArkUI';
import { drawing } from '@kit.ArkGraphics2D';
// 1. 自定义RenderNode
export class MyRenderNode extends RenderNode {
async draw(context: DrawContext) {
const canvas = context.canvas
// 3. 自定义的绘制相关操作
const brush = new drawing.Brush()
brush.setColor({red: 255, blue: 0, green: 0, alpha: 255})
canvas.attachBrush(brush)
canvas.drawRect({left: 0, right: 300, top: 0, bottom: 300})
}
}
// 2. 自定义NodeController
export class MyNodeController extends NodeController {
private rootNode: FrameNode | null = null;
myRenderNode = new MyRenderNode();
makeNode(uiContext: UIContext): FrameNode {
this.rootNode = new FrameNode(uiContext);
if (this.rootNode === null) {
return this.rootNode
}
const renderNode = this.rootNode.getRenderNode();
if (renderNode !== null) {
this.myRenderNode.backgroundColor = 0xffffffff;
this.myRenderNode.frame = { x: 0, y: 0, width: 4800, height: 4800 };
this.myRenderNode.pivot = { x: 0.2, y: 0.8 }
this.myRenderNode.scale = { x: 1, y: 1 }
renderNode.appendChild(this.myRenderNode);
renderNode.clipToFrame = true
}
return this.rootNode;
}
}
@Entry
@Component
struct RenderTest {
@State message: string = 'hello'
build() {
Row() {
Column() {
// 4. 将自定义NodeController进行显示
NodeContainer(new MyNodeController())
.width('100%')
}
.width('100%')
.height('80%')
}
.height('100%')
}
}
```
离屏Canvas画布的获取与显示
1.  添加自定义RenderNode。
2.  添加自定义NodeController。
3.  在MyNodeController的aboutToAppear()函数中创建PixeMap。
4.  重写自定义RenderNode的draw()函数，在其中获取离屏Canvas进行绘制：
5.  将自定义NodeController进行显示。
```typescript
import { UIContext, NodeController, FrameNode, RenderNode, DrawContext } from '@kit.ArkUI';
import { image } from '@kit.ImageKit';
import { taskpool } from '@kit.ArkTS';
import { drawing } from '@kit.ArkGraphics2D';
// 1. 自定义RenderNode
export class MyRenderNode extends RenderNode {
pixelMap: image.PixelMap | null = null;
setPixelMap(pixelMap: image.PixelMap) {
this.pixelMap = pixelMap
}
async draw(context: DrawContext) {
const canvas = context.canvas
if (this.pixelMap != null) {
// 4.1 利用3中创建的PixelMap构造离屏Canvas
const canvas_ = new drawing.Canvas(this.pixelMap);
// 4.2 离屏绘制
const brush = new drawing.Brush();
brush.setColor({ alpha: 255, red: 255, green: 0, blue: 0 });
canvas_.attachBrush(brush);
canvas_.drawRect({left:0,right:100,top:0,bottom:100});
// 4.3 将离屏Canvas的绘制结果交给RenderNode
canvas.drawImage(this.pixelMap, 0, 0);
}
}
}
@Concurrent
async function CreatePixelMapAsync() {
const color : ArrayBuffer = new ArrayBuffer(40000);  // 40000为需要创建的像素buffer大小，取值为：height * width *4
let opts : image.InitializationOptions = { editable: true, pixelFormat: 3, size: { height: 100, width: 100 } }
const pixel = await image.createPixelMap(color, opts);
return pixel;
}
// 2. 自定义NodeController
export class MyNodeController extends NodeController {
private rootNode: FrameNode | null = null;
myRenderNode = new MyRenderNode();
// 3. 在MyNodeController的aboutToAppear中创建PixeMap
aboutToAppear(): void {
let task = new taskpool.Task(CreatePixelMapAsync);
taskpool.execute(task).then((pixel:Object)=>{
this.myRenderNode.setPixelMap(pixel as image.PixelMap)
this.myRenderNode.invalidate()
})
}
makeNode(uiContext: UIContext): FrameNode {
this.rootNode = new FrameNode(uiContext);
if (this.rootNode === null) {
return this.rootNode
}
const renderNode = this.rootNode.getRenderNode();
if (renderNode !== null) {
this.myRenderNode.backgroundColor = 0xffffffff;
this.myRenderNode.frame = { x: 0, y: 0, width: 4800, height: 4800 };
this.myRenderNode.pivot = { x: 0.2, y: 0.8 }
this.myRenderNode.scale = { x: 1, y: 1 }
renderNode.appendChild(this.myRenderNode);
renderNode.clipToFrame = true
}
return this.rootNode;
}
}
@Entry
@Component
struct RenderTest {
@State message: string = 'hello'
nodeController = new MyNodeController()
build() {
Row() {
Column() {
// 5. 将自定义NodeController进行显示
NodeContainer(this.nodeController)
.width('100%')
}
.width('100%')
.height('80%')
}
.height('100%')
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/canvas-get-result-draw-c-V14
爬取时间: 2025-04-29 19:33:16
来源: Huawei Developer
场景介绍
Canvas即画布，提供绘制基本图形的能力，用于在屏幕上绘制图形和处理图形。开发者可以通过Canvas实现自定义的绘图效果，增强应用的用户体验。
Canvas是图形绘制的核心，本章中提到的所有绘制操作（包括基本图形的绘制、文字的绘制、图片的绘制、图形变换等）都是基于Canvas的。
目前C/C++有两种获取Canvas的方式：获取可直接上屏显示的Canvas、获取离屏的Canvas，前者在调用绘制接口之后无需进行额外的操作即可完成绘制结果的上屏显示，而后者需要依靠已有的显示手段来显示绘制结果。
接口说明
创建Canvas常用接口如下表所示，详细的使用和参数说明请见drawing_canvas.h。
| 接口 | 描述 |
| --- | --- |
| OH_Drawing_Canvas* OH_Drawing_CanvasCreate (void) | 用于创建一个画布对象。 |
| void OH_Drawing_CanvasBind (OH_Drawing_Canvas*, OH_Drawing_Bitmap*) | 用于将一个位图对象绑定到画布中，使得画布绘制的内容输出到位图中。 |
| OH_Drawing_Canvas* OH_Drawing_SurfaceGetCanvas (OH_Drawing_Surface *) | 通过surface对象获取画布对象。 |
获取可直接显示的Canvas画布
通过XComponent获取可直接显示的Canvas画布。
1.  从XComponent对应的NativeWindow中获取BufferHandle对象。NativeWindow相关的API请参考_native_window。
2.  从BufferHandle中获取对应的内存地址。
3.  创建窗口画布。
4.  利用上一步中得到的Canvas进行自定义的绘制操作，即本章下文中的内容。
5.  利用XComponent完成显示。
离屏Canvas画布的获取与显示
目前有两种创建离屏Canvas的方式：创建CPU后端Canvas、创建GPU后端Canvas，这两种Canvas都需要依靠XComponent来完成绘制结果的上屏显示。由于历史原因，早期的Canvas都是CPU后端Canvas。目前已经支持GPU后端Canvas，GPU的并行计算能力更强，更适合图形绘制。但GPU后端Canvas对部分场景的支持还有欠缺，比如复杂的路径，对于简短文字的绘制性能也比不上CPU后端Canvas。
CPU后端Canvas的创建与显示
目前C/C++接口的绘制需要依赖于NativeWindow，CPU后端Canvas需要先离屏绘制，生成位图（Bitmap），再借助XComponent将位图上屏。
1.  导入依赖的相关头文件。
2.  创建基于CPU的Canvas。需要通过OH_Drawing_BitmapCreate()接口创建一个位图对象（具体可参考图片绘制），并通过OH_Drawing_CanvasBind()接口将位图绑定到Canvas中，从而使得Canvas绘制的内容可以输出到位图中。 如果需要将背景设置为白色，需要执行以下步骤：
3.  将上一步中创建的位图绘制到窗口画布上。
GPU后端Canvas的创建与显示
GPU后端Canvas指画布是基于GPU进行绘制的，GPU的并行计算能力优于CPU，适用于绘制图片或区域相对大的场景，但目前GPU后端的Canvas针对绘制复杂路径的能力还有欠缺。同CPU后端Canvas，目前C/C++接口的绘制需要依赖于XComponent，GPU后端Canvas需要先离屏绘制再借助XComponent上屏。
1.  导入依赖的头文件。
2.  创建GPU后端Cnavas。GPU后端Canvas需要借助Surface对象来获取，需先创建surface，surface的API请参考drawing_surface.h。目前drawing支持基于OpenGL的GPU后端绘制，所以需要先通过OH_Drawing_GpuContextCreateFromGL接口创建绘图上下文，再将这个上下文作为参数创建surface，最后通过OH_Drawing_SurfaceGetCanvas接口从surface中获取到canvas。 如果需要将背景设置为白色，需要执行以下步骤：
3.  将上一步中的绘制结果拷贝到窗口画布上。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/canvas-get-result-draw-arkts-V14
爬取时间: 2025-04-29 19:33:30
来源: Huawei Developer
场景介绍
Canvas即画布，提供绘制基本图形的能力，用于在屏幕上绘制图形和处理图形。开发者可以通过Canvas实现自定义的绘图效果，增强应用的用户体验。
Canvas是图形绘制的核心，本章中提到的所有绘制操作（包括基本图形的绘制、文字的绘制、图片的绘制、图形变换等）都是基于Canvas的。
目前ArkTS有两种获取Canvas的方式：获取可直接显示的Canvas画布、获取离屏的Canvas，前者在调用绘制接口之后无需进行额外的操作即可完成绘制结果的上屏显示，而后者需要依靠已有的显示手段来显示绘制结果。
获取可直接显示的Canvas画布
通过RenderNode获取可直接上屏显示的Canvas画布。
1.  添加自定义RenderNode。
2.  添加自定义NodeController。
3.  重写自定义RenderNode的draw()函数，获取Canvas进行自定义的绘制操作，即本章下文中的内容。
4.  将自定义NodeController进行显示。
```typescript
import { UIContext, NodeController, FrameNode, RenderNode, DrawContext } from '@kit.ArkUI';
import { drawing } from '@kit.ArkGraphics2D';
// 1. 自定义RenderNode
export class MyRenderNode extends RenderNode {
async draw(context: DrawContext) {
const canvas = context.canvas
// 3. 自定义的绘制相关操作
const brush = new drawing.Brush()
brush.setColor({red: 255, blue: 0, green: 0, alpha: 255})
canvas.attachBrush(brush)
canvas.drawRect({left: 0, right: 300, top: 0, bottom: 300})
}
}
// 2. 自定义NodeController
export class MyNodeController extends NodeController {
private rootNode: FrameNode | null = null;
myRenderNode = new MyRenderNode();
makeNode(uiContext: UIContext): FrameNode {
this.rootNode = new FrameNode(uiContext);
if (this.rootNode === null) {
return this.rootNode
}
const renderNode = this.rootNode.getRenderNode();
if (renderNode !== null) {
this.myRenderNode.backgroundColor = 0xffffffff;
this.myRenderNode.frame = { x: 0, y: 0, width: 4800, height: 4800 };
this.myRenderNode.pivot = { x: 0.2, y: 0.8 }
this.myRenderNode.scale = { x: 1, y: 1 }
renderNode.appendChild(this.myRenderNode);
renderNode.clipToFrame = true
}
return this.rootNode;
}
}
@Entry
@Component
struct RenderTest {
@State message: string = 'hello'
build() {
Row() {
Column() {
// 4. 将自定义NodeController进行显示
NodeContainer(new MyNodeController())
.width('100%')
}
.width('100%')
.height('80%')
}
.height('100%')
}
}
```
离屏Canvas画布的获取与显示
1.  添加自定义RenderNode。
2.  添加自定义NodeController。
3.  在MyNodeController的aboutToAppear()函数中创建PixeMap。
4.  重写自定义RenderNode的draw()函数，在其中获取离屏Canvas进行绘制：
5.  将自定义NodeController进行显示。
```typescript
import { UIContext, NodeController, FrameNode, RenderNode, DrawContext } from '@kit.ArkUI';
import { image } from '@kit.ImageKit';
import { taskpool } from '@kit.ArkTS';
import { drawing } from '@kit.ArkGraphics2D';
// 1. 自定义RenderNode
export class MyRenderNode extends RenderNode {
pixelMap: image.PixelMap | null = null;
setPixelMap(pixelMap: image.PixelMap) {
this.pixelMap = pixelMap
}
async draw(context: DrawContext) {
const canvas = context.canvas
if (this.pixelMap != null) {
// 4.1 利用3中创建的PixelMap构造离屏Canvas
const canvas_ = new drawing.Canvas(this.pixelMap);
// 4.2 离屏绘制
const brush = new drawing.Brush();
brush.setColor({ alpha: 255, red: 255, green: 0, blue: 0 });
canvas_.attachBrush(brush);
canvas_.drawRect({left:0,right:100,top:0,bottom:100});
// 4.3 将离屏Canvas的绘制结果交给RenderNode
canvas.drawImage(this.pixelMap, 0, 0);
}
}
}
@Concurrent
async function CreatePixelMapAsync() {
const color : ArrayBuffer = new ArrayBuffer(40000);  // 40000为需要创建的像素buffer大小，取值为：height * width *4
let opts : image.InitializationOptions = { editable: true, pixelFormat: 3, size: { height: 100, width: 100 } }
const pixel = await image.createPixelMap(color, opts);
return pixel;
}
// 2. 自定义NodeController
export class MyNodeController extends NodeController {
private rootNode: FrameNode | null = null;
myRenderNode = new MyRenderNode();
// 3. 在MyNodeController的aboutToAppear中创建PixeMap
aboutToAppear(): void {
let task = new taskpool.Task(CreatePixelMapAsync);
taskpool.execute(task).then((pixel:Object)=>{
this.myRenderNode.setPixelMap(pixel as image.PixelMap)
this.myRenderNode.invalidate()
})
}
makeNode(uiContext: UIContext): FrameNode {
this.rootNode = new FrameNode(uiContext);
if (this.rootNode === null) {
return this.rootNode
}
const renderNode = this.rootNode.getRenderNode();
if (renderNode !== null) {
this.myRenderNode.backgroundColor = 0xffffffff;
this.myRenderNode.frame = { x: 0, y: 0, width: 4800, height: 4800 };
this.myRenderNode.pivot = { x: 0.2, y: 0.8 }
this.myRenderNode.scale = { x: 1, y: 1 }
renderNode.appendChild(this.myRenderNode);
renderNode.clipToFrame = true
}
return this.rootNode;
}
}
@Entry
@Component
struct RenderTest {
@State message: string = 'hello'
nodeController = new MyNodeController()
build() {
Row() {
Column() {
// 5. 将自定义NodeController进行显示
NodeContainer(this.nodeController)
.width('100%')
}
.width('100%')
.height('80%')
}
.height('100%')
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/canvas-get-result-draw-c-V14
爬取时间: 2025-04-29 19:33:43
来源: Huawei Developer
场景介绍
Canvas即画布，提供绘制基本图形的能力，用于在屏幕上绘制图形和处理图形。开发者可以通过Canvas实现自定义的绘图效果，增强应用的用户体验。
Canvas是图形绘制的核心，本章中提到的所有绘制操作（包括基本图形的绘制、文字的绘制、图片的绘制、图形变换等）都是基于Canvas的。
目前C/C++有两种获取Canvas的方式：获取可直接上屏显示的Canvas、获取离屏的Canvas，前者在调用绘制接口之后无需进行额外的操作即可完成绘制结果的上屏显示，而后者需要依靠已有的显示手段来显示绘制结果。
接口说明
创建Canvas常用接口如下表所示，详细的使用和参数说明请见drawing_canvas.h。
| 接口 | 描述 |
| --- | --- |
| OH_Drawing_Canvas* OH_Drawing_CanvasCreate (void) | 用于创建一个画布对象。 |
| void OH_Drawing_CanvasBind (OH_Drawing_Canvas*, OH_Drawing_Bitmap*) | 用于将一个位图对象绑定到画布中，使得画布绘制的内容输出到位图中。 |
| OH_Drawing_Canvas* OH_Drawing_SurfaceGetCanvas (OH_Drawing_Surface *) | 通过surface对象获取画布对象。 |
获取可直接显示的Canvas画布
通过XComponent获取可直接显示的Canvas画布。
1.  从XComponent对应的NativeWindow中获取BufferHandle对象。NativeWindow相关的API请参考_native_window。
2.  从BufferHandle中获取对应的内存地址。
3.  创建窗口画布。
4.  利用上一步中得到的Canvas进行自定义的绘制操作，即本章下文中的内容。
5.  利用XComponent完成显示。
离屏Canvas画布的获取与显示
目前有两种创建离屏Canvas的方式：创建CPU后端Canvas、创建GPU后端Canvas，这两种Canvas都需要依靠XComponent来完成绘制结果的上屏显示。由于历史原因，早期的Canvas都是CPU后端Canvas。目前已经支持GPU后端Canvas，GPU的并行计算能力更强，更适合图形绘制。但GPU后端Canvas对部分场景的支持还有欠缺，比如复杂的路径，对于简短文字的绘制性能也比不上CPU后端Canvas。
CPU后端Canvas的创建与显示
目前C/C++接口的绘制需要依赖于NativeWindow，CPU后端Canvas需要先离屏绘制，生成位图（Bitmap），再借助XComponent将位图上屏。
1.  导入依赖的相关头文件。
2.  创建基于CPU的Canvas。需要通过OH_Drawing_BitmapCreate()接口创建一个位图对象（具体可参考图片绘制），并通过OH_Drawing_CanvasBind()接口将位图绑定到Canvas中，从而使得Canvas绘制的内容可以输出到位图中。 如果需要将背景设置为白色，需要执行以下步骤：
3.  将上一步中创建的位图绘制到窗口画布上。
GPU后端Canvas的创建与显示
GPU后端Canvas指画布是基于GPU进行绘制的，GPU的并行计算能力优于CPU，适用于绘制图片或区域相对大的场景，但目前GPU后端的Canvas针对绘制复杂路径的能力还有欠缺。同CPU后端Canvas，目前C/C++接口的绘制需要依赖于XComponent，GPU后端Canvas需要先离屏绘制再借助XComponent上屏。
1.  导入依赖的头文件。
2.  创建GPU后端Cnavas。GPU后端Canvas需要借助Surface对象来获取，需先创建surface，surface的API请参考drawing_surface.h。目前drawing支持基于OpenGL的GPU后端绘制，所以需要先通过OH_Drawing_GpuContextCreateFromGL接口创建绘图上下文，再将这个上下文作为参数创建surface，最后通过OH_Drawing_SurfaceGetCanvas接口从surface中获取到canvas。 如果需要将背景设置为白色，需要执行以下步骤：
3.  将上一步中的绘制结果拷贝到窗口画布上。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/canvas-operation-state-c-V14
爬取时间: 2025-04-29 19:33:57
来源: Huawei Developer
场景介绍
创建或获取得到Canvas画布之后，可以基于画布进一步地进行图形操作和状态处理。画布操作属于可选操作，开发者可以根据场景需要进行。需要先进行画布操作，再进行后续绘制，只有这样画布操作才有效果。
常见的画布操作如下：
-  裁剪。
-  矩阵变换，如平移、缩放、旋转等。
-  状态保存与恢复。
裁剪操作
裁剪是图形处理中的常见操作，裁剪针对的是画布本身，可以用于限制绘图区域，只在指定的区域内容进行绘制。需要先进行裁剪操作，再进行绘制，才会有对应效果。
当前支持的裁剪操作主要如下：
-  裁剪矩形。
-  裁剪圆角矩形。
-  裁剪自定义路径。
-  裁剪一个区域。
接口说明
裁剪操作常用接口如下表所示，详细的使用和参数说明请见drawing_canvas.h。
| 接口 | 描述 |
| --- | --- |
| void OH_Drawing_CanvasClipRect (OH_Drawing_Canvas *, const OH_Drawing_Rect *, OH_Drawing_CanvasClipOp clipOp, bool doAntiAlias) | 用于裁剪一个矩形。 |
| void OH_Drawing_CanvasClipRoundRect (OH_Drawing_Canvas *, const OH_Drawing_RoundRect *, OH_Drawing_CanvasClipOp clipOp, bool doAntiAlias) | 用于裁剪一个圆角矩形。 |
| void OH_Drawing_CanvasClipPath (OH_Drawing_Canvas *, const OH_Drawing_Path *, OH_Drawing_CanvasClipOp clipOp, bool doAntiAlias) | 用于裁剪一个自定义路径。 |
| OH_Drawing_ErrorCode OH_Drawing_CanvasClipRegion (OH_Drawing_Canvas *canvas, const OH_Drawing_Region *region, OH_Drawing_CanvasClipOp clipOp) | 用于裁剪一个区域。 |
开发示例
此处以在画布上裁剪矩形为例给出示例和效果图，其他裁剪操作的逻辑基本相同，注意调用对应的接口并确保要裁剪的数据类型对应准确即可，此处不再一一展开。具体详细的使用和参数说明请见drawing_canvas.h。
使用OH_Drawing_CanvasClipRect接口裁剪矩形。有以下四个入参：
-  第一个参数是画布Canvas，裁剪操作将在这个画布上进行。请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）。
-  第二个参数是要裁剪的矩形区域。
-  第三个参数是裁剪的操作类型，包括交集（INTERSECT）和差集（DIFFERENCE）。
-  第四个参数表示是否需要进行抗锯齿处理。
| 原始图 | 裁剪后的图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.09976275932865591106022420475414:50001231000000:2800:1084E58469B98CC01F020FBF629F936CA018CDD6B5A1A1F4F1C72ADE882A6F7C.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.61879951083173902820165396672393:50001231000000:2800:94B6C2C0B0F518CBAB49D14D2B820AE8E27D371959916CDD6CEA3B7271CFD323.jpg)
矩阵变化操作
矩阵变换也是常见的画布操作，是一种坐标系的转换，用于进行图形的变化。
当前支持的矩阵变换主要如下：
-  平移
-  缩放
-  旋转
接口说明
矩阵变换操作常用接口如下表所示，详细的使用和参数说明请见drawing_matrix.h。
| 接口 | 描述 |
| --- | --- |
| void OH_Drawing_CanvasTranslate (OH_Drawing_Canvas *, float dx, float dy) | 用于平移画布一段距离。 |
| void OH_Drawing_CanvasScale (OH_Drawing_Canvas *, float sx, float sy) | 用于画布缩放。 |
| void OH_Drawing_CanvasRotate (OH_Drawing_Canvas *, float degrees, float px, float py) | 用于画布旋转一定的角度，正数表示顺时针旋转，负数反之。 |
| void OH_Drawing_CanvasSkew (OH_Drawing_Canvas *, float sx, float sy) | 用于画布倾斜变换。等同于将当前画布矩阵左乘（premultiply）倾斜变换矩阵，并应用到画布上。其中倾斜变换矩阵为：|1 sx 0| |sy 1 0| |0 0 1|。 |
平移
使用OH_Drawing_MatrixCreateTranslation()接口实现画布平移。接口接受2个参数，分别为水平方向和垂直方向的平移量，单位为px。
简单示例和示意图如下所示：
| 原始图 | 平移后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.09279390992882841182403239173204:50001231000000:2800:C4CD7E2A54FD7AF507D6FECF2AD1168BD40EC1F38A27B6FADDAD2E7055E429DB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.46835249561833799338615733405220:50001231000000:2800:66CCF9C5FD79D1ABA88947086F93B211E1C4405AC7FAEAAD5F34FD1FE502B006.png)
旋转
使用OH_Drawing_MatrixCreateRotation()接口实现画布旋转，接口接受3个参数，分别为：旋转角度、旋转中心的x坐标和y坐标。
简单示例和示意图如下所示：
| 原始图 | 旋转后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.41125685692171259410180098283020:50001231000000:2800:C2EEAE0D0C794DDC9129FCC3883500DF8890AE892003703705AAC750764C11C8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.21348883730849958848339707251386:50001231000000:2800:5EAE29E3883E386DB925B199C2A418F849E728CFA4A1A1F0D78E38C411D1E67B.png)
缩放
使用OH_Drawing_MatrixCreateScale()接口进行画布缩放，接口接受4个参数，分别为沿x轴和y轴的缩放因子、旋转中心的x轴和y轴坐标。
简单示例和示意图如下所示：
| 原始图 | 放大后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.12567231968799542371875865229047:50001231000000:2800:089A5D7089536A895D16C6C3D9687CAFDD9A207B2CE9CC15D10FCF455E57D159.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.37404972780909457468417176280584:50001231000000:2800:567E4A97E894707A41D73BD33DC5227B6B7E06EAE6AE25116D1959ACA3EC016C.png)
画布状态保存与恢复
保存操作用于保存当前画布的状态到一个栈顶，恢复操作用于恢复保存在栈顶的画布状态，恢复操作一旦执行，保存和恢复操作中间一系列平移、缩放、剪裁等操作都会被清除。
接口说明
画布状态保存与恢复使用的接口如下表所示，详细的使用和参数说明请见drawing_canvas.h。
| 接口 | 描述 |
| --- | --- |
| void OH_Drawing_CanvasSave (OH_Drawing_Canvas *) | 用于保存当前画布的状态（画布矩阵）到一个栈顶。 |
| void OH_Drawing_CanvasRestore (OH_Drawing_Canvas *) | 用于恢复保存在栈顶的画布状态（画布矩阵）。 |
| void OH_Drawing_CanvasRestoreToCount (OH_Drawing_Canvas *, uint32_t saveCount) | 用于恢复到指定数量的画布状态（画布矩阵）。 |
开发示例
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.86539686281141927145286826307404:50001231000000:2800:E653D44EDAC87D4EFC376757790A45E66FBCEC969B14D1B8C97C9DDC90160197.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/canvas-operation-state-arkts-V14
爬取时间: 2025-04-29 19:34:11
来源: Huawei Developer
场景介绍
创建或获取得到Canvas画布之后，可以基于画布进一步地进行图形操作和状态处理。画布操作属于可选操作，开发者可以根据场景需要进行。需要先进行画布操作，再进行后续绘制，只有这样画布操作才有效果。
常见的画布操作如下：
-  裁剪。
-  矩阵变换，如平移、缩放、旋转等。
-  状态保存与恢复。
更多画布操作和具体接口参数使用，请见drawing.Canvas。
裁剪操作
裁剪是图形处理中的常见操作，裁剪针对的是画布本身，可以用于限制绘图区域，只在指定的区域内容进行绘制。需要先进行裁剪操作，再进行绘制，才会有对应效果。
当前支持的裁剪操作主要如下：
-  裁剪矩形。
-  裁剪圆角矩形。
-  裁剪自定义路径。
-  裁剪一个区域。
接口说明
裁剪操作常用接口如下表所示，详细的使用和参数说明请见drawing.Canvas。
| 接口 | 描述 |
| --- | --- |
| clipRect(rect: common2D.Rect, clipOp?: ClipOp, doAntiAlias?: boolean): void | 用于裁剪一个矩形。 |
| clipRoundRect(roundRect: RoundRect, clipOp?: ClipOp, doAntiAlias?: boolean): void | 用于裁剪一个圆角矩形。 |
| clipPath(path: Path, clipOp?: ClipOp, doAntiAlias?: boolean): void | 用于裁剪一个自定义路径。 |
| clipRegion(region: Region, clipOp?: ClipOp): void | 用于裁剪一个区域。 |
开发示例
此处以在画布上裁剪矩形为例给出示例和效果图，其他裁剪操作的逻辑基本相同，注意调用对应的接口并确保要裁剪的数据类型对应准确即可，此处不再一一展开。具体详细的使用和参数说明请见drawing.Canvas。
使用clipRect()接口裁剪矩形。有以下3个入参：
-  rect是要裁剪的矩形区域。
-  clipOp是裁剪方式，包括交集（INTERSECT）和差集（DIFFERENCE），具体可见ClipOp。
-  doAntiAlias表示是否需要抗锯齿处理，如果为true则启用抗锯齿功能，在绘制图形时会对图形的边缘像素进行半透明的模糊处理，如果为false则不开启。
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置颜色为蓝色
brush.setColor(0xFF, 0x00,  0x00, 0xFF);
// 设置画刷填充效果
canvas.attachBrush(brush);
// 创建矩形对象
let rect: common2D.Rect = { left: 200, top: 200, right: 600, bottom: 600 };
// 裁剪矩形区域
canvas.clipRect(rect);
// 绘制圆形
canvas.drawCircle(300, 300, 300);
// 去除填充效果
canvas.detachBrush();
```
| 原始图 | 裁剪后的图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.08347967468601722052469520159700:50001231000000:2800:50D83FDE6D4B2FADFD175CCFDC37EC54E40DEDC1BB688BCC2A86670908EDBEAE.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.62229466902399501294766505386005:50001231000000:2800:E1B81CF76C924D9E845861AE2CDC7FC49BD2E5DE9CE3B63E541B526DE31D7C5A.jpg)
矩阵变化操作
矩阵变换也是常见的画布操作，是一种坐标系的转换，用于进行图形的变化。
当前支持的矩阵变换主要如下：
-  平移
-  缩放
-  旋转
接口说明
矩阵变换操作常用接口如下表所示，详细的使用和参数说明请见drawing.Canvas。
| 接口 | 描述 |
| --- | --- |
| translate(dx: number, dy: number): void | 用于平移画布一段距离。 |
| scale(sx: number, sy: number): void | 用于画布缩放。 |
| rotate(degrees: number, sx: number, sy: number): void | 用于画布旋转一定的角度，正数表示顺时针旋转，负数反之。 |
| skew(sx: number, sy: number) : void | 用于画布倾斜变换，包括水平轴和垂直轴上的偏移。 |
平移
使用translate()接口实现画布平移。接口接受2个参数，分别为水平方向和垂直方向的平移量，单位为px。
简单示例和示意图如下所示：
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置颜色为红色
brush.setColor(0xFF, 0xFF, 0x00, 0x00);
// 设置画刷填充效果
canvas.attachBrush(brush);
// 执行平移操作
canvas.translate(300, 300);
// 绘制矩形
canvas.drawRect({ left: 200, top: 200, right: 600, bottom: 600 });
// 去除填充效果
canvas.detachBrush();
```
| 原始图 | 平移后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165911.66850554702519875401481454275949:50001231000000:2800:0F2297C1301B2DE9CEEA695F27DC49E1997CD9EE57DD303017869657BB0C6B8B.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.80250656234129305389617096476521:50001231000000:2800:EAFBFA4A90E0C1D0BD8D05E087BF958CFAA9DD61911FE579295CAF0AF22CA4BD.jpg)
旋转
使用rotate()接口实现画布旋转，接口接受3个参数，分别为：旋转角度、旋转中心的x坐标和y坐标。
简单示例和示意图如下所示：
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置颜色为红色
brush.setColor(0xFF, 0xFF, 0x00, 0x00);
// 设置画刷填充效果
canvas.attachBrush(brush);
// 顺时针旋转45度
canvas.rotate(45, 200, 200);
// 绘制矩形
canvas.drawRect({ left: 200, top: 200, right: 600, bottom: 600 });
// 去除填充效果
canvas.detachBrush();
```
| 原始图 | 旋转后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.40096684765775038479661879081513:50001231000000:2800:545DD1A3971270F6D2581549B94E0CB8C5AE4F37897D086C5C6362F58FA35332.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.83690630892809599786754770941699:50001231000000:2800:F4BD7F34544DBE780C4946494486E6FD536303DD88E72BD6A09D6952C4BF76A9.jpg)
缩放
使用scale()接口进行画布缩放，接口接受2个参数，分别为沿x轴和y轴的缩放因子。
简单示例和示意图如下所示：
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置颜色为红色
brush.setColor({ alpha: 0xFF, red: 0xFF, green: 0x00, blue: 0x00 });
// 设置画刷填充效果
canvas.attachBrush(brush);
// 执行放大操作
canvas.scale(2, 2);
// 绘制矩形
canvas.drawRect({ left: 200, top: 200, right: 600, bottom: 600 });
// 去除填充效果
canvas.detachBrush();
```
| 原始图 | 缩放后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.10735893302699521687854757194717:50001231000000:2800:9D6124F5C97A0BB045A2494617CEF7525B06E2E6D5FC0E86619AB5F6D3DB397D.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.83775125184144882244746543934822:50001231000000:2800:04089C2E5F0903636CFDAAC25780639B4640625308B34691391878945278B175.jpg)
画布状态保存与恢复
保存操作用于保存当前画布的状态到一个栈顶，恢复操作用于恢复保存在栈顶的画布状态，恢复操作一旦执行，保存和恢复操作中间一系列平移、缩放、剪裁等操作都会被清除。
接口说明
画布状态保存与恢复使用的接口如下表所示，详细的使用和参数说明请见canvas。
| 接口 | 描述 |
| --- | --- |
| save(): void; | 用于保存当前画布的状态（画布矩阵）到一个栈顶。 |
| restore(): void; | 用于恢复保存在栈顶的画布状态（画布矩阵）。 |
| restoreToCount(count: number): void; | 用于恢复到指定数量的画布状态（画布矩阵）。 |
简单示例和示意图如下所示：
```typescript
// 创建画笔
let pen = new drawing.Pen();
// 设置颜色为红色
pen.setColor({ alpha: 0xFF, red: 0xFF, green: 0x00, blue: 0x00 });
// 设置描边宽度为20px
pen.setStrokeWidth(20);
// 设置画笔描边效果
canvas.attachPen(pen);
// 保存操作，当前是不存在放大等操作的，这个原始状态会被保存下来
canvas.save();
// x轴和y轴放行分别放大2倍
canvas.scale(2, 2);
// 绘制圆形，因为执行过放大操作，所以此时绘制的是大圆
canvas.drawCircle(300, 300, 200);
// 恢复操作，恢复到没有放大的原始状态
canvas.restore();
// 绘制圆形，因为已经恢复到没有放大的原始状态，所以此时绘制的是小圆
canvas.drawCircle(300, 300, 200);
// 去除描边效果
canvas.detachPen();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.14664121713678630126890974254440:50001231000000:2800:0405CD0016569B8105A090774BBEC33F542638650DCC360B136DA49789D617D1.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/canvas-operation-state-c-V14
爬取时间: 2025-04-29 19:34:24
来源: Huawei Developer
场景介绍
创建或获取得到Canvas画布之后，可以基于画布进一步地进行图形操作和状态处理。画布操作属于可选操作，开发者可以根据场景需要进行。需要先进行画布操作，再进行后续绘制，只有这样画布操作才有效果。
常见的画布操作如下：
-  裁剪。
-  矩阵变换，如平移、缩放、旋转等。
-  状态保存与恢复。
裁剪操作
裁剪是图形处理中的常见操作，裁剪针对的是画布本身，可以用于限制绘图区域，只在指定的区域内容进行绘制。需要先进行裁剪操作，再进行绘制，才会有对应效果。
当前支持的裁剪操作主要如下：
-  裁剪矩形。
-  裁剪圆角矩形。
-  裁剪自定义路径。
-  裁剪一个区域。
接口说明
裁剪操作常用接口如下表所示，详细的使用和参数说明请见drawing_canvas.h。
| 接口 | 描述 |
| --- | --- |
| void OH_Drawing_CanvasClipRect (OH_Drawing_Canvas *, const OH_Drawing_Rect *, OH_Drawing_CanvasClipOp clipOp, bool doAntiAlias) | 用于裁剪一个矩形。 |
| void OH_Drawing_CanvasClipRoundRect (OH_Drawing_Canvas *, const OH_Drawing_RoundRect *, OH_Drawing_CanvasClipOp clipOp, bool doAntiAlias) | 用于裁剪一个圆角矩形。 |
| void OH_Drawing_CanvasClipPath (OH_Drawing_Canvas *, const OH_Drawing_Path *, OH_Drawing_CanvasClipOp clipOp, bool doAntiAlias) | 用于裁剪一个自定义路径。 |
| OH_Drawing_ErrorCode OH_Drawing_CanvasClipRegion (OH_Drawing_Canvas *canvas, const OH_Drawing_Region *region, OH_Drawing_CanvasClipOp clipOp) | 用于裁剪一个区域。 |
开发示例
此处以在画布上裁剪矩形为例给出示例和效果图，其他裁剪操作的逻辑基本相同，注意调用对应的接口并确保要裁剪的数据类型对应准确即可，此处不再一一展开。具体详细的使用和参数说明请见drawing_canvas.h。
使用OH_Drawing_CanvasClipRect接口裁剪矩形。有以下四个入参：
-  第一个参数是画布Canvas，裁剪操作将在这个画布上进行。请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）。
-  第二个参数是要裁剪的矩形区域。
-  第三个参数是裁剪的操作类型，包括交集（INTERSECT）和差集（DIFFERENCE）。
-  第四个参数表示是否需要进行抗锯齿处理。
| 原始图 | 裁剪后的图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.09976275932865591106022420475414:50001231000000:2800:1084E58469B98CC01F020FBF629F936CA018CDD6B5A1A1F4F1C72ADE882A6F7C.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.61879951083173902820165396672393:50001231000000:2800:94B6C2C0B0F518CBAB49D14D2B820AE8E27D371959916CDD6CEA3B7271CFD323.jpg)
矩阵变化操作
矩阵变换也是常见的画布操作，是一种坐标系的转换，用于进行图形的变化。
当前支持的矩阵变换主要如下：
-  平移
-  缩放
-  旋转
接口说明
矩阵变换操作常用接口如下表所示，详细的使用和参数说明请见drawing_matrix.h。
| 接口 | 描述 |
| --- | --- |
| void OH_Drawing_CanvasTranslate (OH_Drawing_Canvas *, float dx, float dy) | 用于平移画布一段距离。 |
| void OH_Drawing_CanvasScale (OH_Drawing_Canvas *, float sx, float sy) | 用于画布缩放。 |
| void OH_Drawing_CanvasRotate (OH_Drawing_Canvas *, float degrees, float px, float py) | 用于画布旋转一定的角度，正数表示顺时针旋转，负数反之。 |
| void OH_Drawing_CanvasSkew (OH_Drawing_Canvas *, float sx, float sy) | 用于画布倾斜变换。等同于将当前画布矩阵左乘（premultiply）倾斜变换矩阵，并应用到画布上。其中倾斜变换矩阵为：|1 sx 0| |sy 1 0| |0 0 1|。 |
平移
使用OH_Drawing_MatrixCreateTranslation()接口实现画布平移。接口接受2个参数，分别为水平方向和垂直方向的平移量，单位为px。
简单示例和示意图如下所示：
| 原始图 | 平移后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.09279390992882841182403239173204:50001231000000:2800:C4CD7E2A54FD7AF507D6FECF2AD1168BD40EC1F38A27B6FADDAD2E7055E429DB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.46835249561833799338615733405220:50001231000000:2800:66CCF9C5FD79D1ABA88947086F93B211E1C4405AC7FAEAAD5F34FD1FE502B006.png)
旋转
使用OH_Drawing_MatrixCreateRotation()接口实现画布旋转，接口接受3个参数，分别为：旋转角度、旋转中心的x坐标和y坐标。
简单示例和示意图如下所示：
| 原始图 | 旋转后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.41125685692171259410180098283020:50001231000000:2800:C2EEAE0D0C794DDC9129FCC3883500DF8890AE892003703705AAC750764C11C8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165912.21348883730849958848339707251386:50001231000000:2800:5EAE29E3883E386DB925B199C2A418F849E728CFA4A1A1F0D78E38C411D1E67B.png)
缩放
使用OH_Drawing_MatrixCreateScale()接口进行画布缩放，接口接受4个参数，分别为沿x轴和y轴的缩放因子、旋转中心的x轴和y轴坐标。
简单示例和示意图如下所示：
| 原始图 | 放大后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.12567231968799542371875865229047:50001231000000:2800:089A5D7089536A895D16C6C3D9687CAFDD9A207B2CE9CC15D10FCF455E57D159.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.37404972780909457468417176280584:50001231000000:2800:567E4A97E894707A41D73BD33DC5227B6B7E06EAE6AE25116D1959ACA3EC016C.png)
画布状态保存与恢复
保存操作用于保存当前画布的状态到一个栈顶，恢复操作用于恢复保存在栈顶的画布状态，恢复操作一旦执行，保存和恢复操作中间一系列平移、缩放、剪裁等操作都会被清除。
接口说明
画布状态保存与恢复使用的接口如下表所示，详细的使用和参数说明请见drawing_canvas.h。
| 接口 | 描述 |
| --- | --- |
| void OH_Drawing_CanvasSave (OH_Drawing_Canvas *) | 用于保存当前画布的状态（画布矩阵）到一个栈顶。 |
| void OH_Drawing_CanvasRestore (OH_Drawing_Canvas *) | 用于恢复保存在栈顶的画布状态（画布矩阵）。 |
| void OH_Drawing_CanvasRestoreToCount (OH_Drawing_Canvas *, uint32_t saveCount) | 用于恢复到指定数量的画布状态（画布矩阵）。 |
开发示例
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.86539686281141927145286826307404:50001231000000:2800:E653D44EDAC87D4EFC376757790A45E66FBCEC969B14D1B8C97C9DDC90160197.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/drawing-effect-V14
爬取时间: 2025-04-29 19:34:38
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/basic-drawing-effect-arkts-V14
爬取时间: 2025-04-29 19:34:38
来源: Huawei Developer
场景介绍
在进行绘制时，可以进行一些基础效果的设置，比如设置填充颜色、设置抗锯齿、设置图形描边、设置图形线条连接样式等。
主要通过画刷（Brush）设置填充基础效果，通过画笔（Pen）设置描边基础效果。
填充效果
可以通过画刷设置基础的填充颜色，还可以通过画刷使用混合模式、着色器效果、滤波器效果等实现更多复杂绘制效果，具体可见复杂绘制效果。
接口说明
使用画刷（Brush）设置绘制效果的常用接口如下表所示，详细的使用和参数请见drawing.Brush。
| 接口 | 描述 |
| --- | --- |
| attachBrush(brush: Brush): void | 用于设置画刷给画布，画布将会使用设置的画刷样式和颜色去填充绘制的图形形状。 |
| setColor(alpha: number, red: number, green: number, blue: number): void | 用于设置画刷的颜色属性，颜色属性描述了画刷填充图形时使用的颜色。 |
| setAntiAlias(aa: boolean) : void | 用于设置画刷的抗锯齿属性，设置为true则画刷在绘制图形时会对图形的边缘像素进行半透明的模糊处理，以使图形边缘更加平滑。 |
| detachBrush(): void | 用于去除画布中的画刷，执行后画布将不使用此前设置的画刷，恢复到默认填充效果。 |
开发步骤
1.  创建画刷Brush对象。
```typescript
const brush = new drawing.Brush();
```
2.  使用画刷设置基础绘制效果，例如设置填充颜色、开启抗锯齿效果等。 可使用setColor()接口设置填充颜色。 可使用setAntiAlias()接口开启抗锯齿效果，以使图形边缘更加平滑。
```typescript
brush.setColor(0xFF, 0xFF, 0x00, 0x00);
```
3.  使用attachBrush()接口给Canvas画布设置画刷。
```typescript
canvas.attachBrush(brush);
```
4.  按需绘制图元，具体可见图元绘制一节。
5.  当不需要填充效果时，可以使用detachBrush()接口去除画布中的画刷。
```typescript
canvas.detachBrush();
```
描边效果
可以通过画笔设置基础的描边颜色，还可以通过画笔使用混合模式、路径效果、着色器效果、滤波器效果等实现更多复杂绘制效果，具体可见复杂绘制效果。
接口说明
使用画笔（Pen）设置绘制效果的常用接口如下表所示，详细的使用和参数请见drawing.Pen。
| 接口 | 描述 |
| --- | --- |
| attachPen(pen: Pen): void | 用于设置画笔给画布，画布将会使用设置画笔的样式和颜色去绘制图形形状的轮廓。 |
| setColor(alpha: number, red: number, green: number, blue: number): void | 用于设置画笔的颜色属性，颜色属性描述了画笔绘制图形轮廓时使用的颜色。 |
| setStrokeWidth(width: number) : void | 用于设置画笔的线宽。0线宽被视作特殊的极细线宽，在绘制时始终会被绘制为1像素，不随画布的缩放而改变；负数线宽在实际绘制时会被视作0线宽。 |
| setAntiAlias(aa: boolean) : void | 用于设置画笔的抗锯齿属性，设置为true则画笔在绘制图形时会对图形的边缘像素进行半透明的模糊处理。 |
| setCapStyle(style: CapStyle): void | 用于设置画笔线帽样式。 |
| setJoinStyle(style: JoinStyle): void | 用于设置画笔绘制转角的样式。 |
| detachPen(): void | 用于去除画布中的画笔，执行后画布将不去绘制图形形状的轮廓，恢复到默认的填充效果。 |
开发步骤
1.  创建画笔Pen对象。
```typescript
let pen = new drawing.Pen();
```
2.  使用attachPen()接口给Canvas画布设置画笔。画布将会使用设置的画笔样式和颜色等绘制图形轮廓。
```typescript
canvas.attachPen(pen);
```
3.  使用画笔设置具体的描边效果（可选以下的一个或者多个效果）。 可使用setColor()接口设置画笔颜色，对应为绘制图形轮廓时使用的颜色。 可使用setStrokeWidth()接口设置画笔的线宽。 可使用setAntiAlias()接口设置画笔抗锯齿，以使图形绘制边缘更平滑。 可使用setCapStyle()接口设置画笔线帽样式。 CapStyle线帽样式可选分类对应如下： 可使用setJoinStyle()接口设置画笔转角样式。 JoinStyle转角样式可选分类对应如下：
```typescript
// 设置颜色为红色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
```
4.  可使用setColor()接口设置画笔颜色，对应为绘制图形轮廓时使用的颜色。
```typescript
// 设置颜色为红色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
```
5.  可使用setStrokeWidth()接口设置画笔的线宽。
```typescript
pen.setStrokeWidth(15);
```
6.  可使用setAntiAlias()接口设置画笔抗锯齿，以使图形绘制边缘更平滑。
```typescript
pen.setAntiAlias(true);
```
7.  可使用setCapStyle()接口设置画笔线帽样式。 CapStyle线帽样式可选分类对应如下：
```typescript
pen.setCapStyle(drawing.CapStyle.SQUARE_CAP);
```
8.  可使用setJoinStyle()接口设置画笔转角样式。 JoinStyle转角样式可选分类对应如下：
```typescript
pen.setJoinStyle(drawing.JoinStyle.ROUND_JOIN);
```
9.  按需绘制图元，具体可见图元绘制一节。
10.  当不需要描边效果时，可以使用detachPen()接口去除画布中的画笔。
```typescript
canvas.detachPen();
```
-  可使用setColor()接口设置画笔颜色，对应为绘制图形轮廓时使用的颜色。
```typescript
// 设置颜色为红色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
```
-  可使用setStrokeWidth()接口设置画笔的线宽。
```typescript
pen.setStrokeWidth(15);
```
-  可使用setAntiAlias()接口设置画笔抗锯齿，以使图形绘制边缘更平滑。
```typescript
pen.setAntiAlias(true);
```
-  可使用setCapStyle()接口设置画笔线帽样式。 CapStyle线帽样式可选分类对应如下：
```typescript
pen.setCapStyle(drawing.CapStyle.SQUARE_CAP);
```
-  可使用setJoinStyle()接口设置画笔转角样式。 JoinStyle转角样式可选分类对应如下：
```typescript
pen.setJoinStyle(drawing.JoinStyle.ROUND_JOIN);
```
| 线帽样式 | 说明 | 示意图 |
| --- | --- | --- |
| FLAT_CAP | 没有线帽样式，线条头尾端点处横切。 |  |
| SQUARE_CAP | 线帽的样式为方框，线条的头尾端点处多出一个方框，方框宽度和线段一样宽，高度是线段宽度的一半。 |  |
| ROUND_CAP | 线帽的样式为圆弧，线条的头尾端点处多出一个半圆弧，半圆的直径与线段宽度一致。 |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.53556081379638672419438452515891:50001231000000:2800:92809429DAA623245A46A7F26750CB45DB7BFC03076F6A243CB1B29F54FA07DB.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.16854282697047897252645405483106:50001231000000:2800:66211B1BCD95B7B385939A7017EDB6C5CD73693F82B3EEB75C0BF6E61596B5D3.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.99274149269117357231775007854269:50001231000000:2800:2A580C6FDA656C8A5E37F67E45D1282075D624D5F4B686B0450BC5E0243D88CB.jpg)
| 转角样式 | 说明 | 示意图 |
| --- | --- | --- |
| MITER_JOIN | 转角类型为尖角 |  |
| ROUND_JOIN | 转角类型为圆头 |  |
| BEVEL_JOIN | 转角类型为平头 |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.78458274450201116338770215778963:50001231000000:2800:645B094E5DE086D5CA7256E87028CE3D401406C63BAC85C40199FFBAA427191A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.22650104964970191958708810571661:50001231000000:2800:32C8D18FAD0757B97892AD34CEB8A78D264037D93CC97A586C8CA227063724A5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.52091578148132682296380209247337:50001231000000:2800:FB86BFCC28A178D0DDBBF4704E85FDCBA22BE231AC78BF272320286531CA4E21.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/complex-drawing-effect-arkts-V14
爬取时间: 2025-04-29 19:34:52
来源: Huawei Developer
除了基础填充颜色、描边颜色和一些样式设置的绘制效果外，还支持通过画刷和画笔实现更多复杂的绘制效果。比如：
-  混合模式。
-  路径效果，如虚线效果。
-  着色器效果，如线性渐变、径向渐变等。
-  滤波效果，如模糊效果等。
混合模式
混合模式可以用于画笔或画刷，它定义了如何将源像素（要绘制的内容）与目标像素（已存在于画布上的内容）进行组合。
可以使用setBlendMode()接口将混合模式应用于画刷或画笔中，该接口需要接受一个参数BlendMode，即混合模式的类型，具体可参考BlendMode。
此处以使用画刷设置叠加混合模式为例（为了防止混合模式的效果被背景色干扰，示例中的canvas并未设置背景色，使用的是默认的黑色背景），关键示例和效果示意图如下所示：
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置目标像素颜色，即矩形的颜色
brush.setColor(0xFF, 0xFF,  0x00, 0x00);
// 将目标像素的画刷效果设置到Canvas中
canvas.attachBrush(brush);
// 创建矩形对象
let rect: common2D.Rect = { left: 100, top: 100, right: 600, bottom: 600 };
// 绘制矩形（目标像素）
canvas.drawRect(rect);
// 设置源像素颜色，即圆形的颜色
brush.setColor(0xFF, 0x00,  0x00, 0xFF);
// 设置混合模式为叠加模式
brush.setBlendMode(drawing.BlendMode.PLUS);
// 将源像素的画刷效果设置到Canvas中
canvas.attachBrush(brush);
// 绘制圆（源像素）
canvas.drawCircle(600, 600, 300);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.60134965771775957812906056169371:50001231000000:2800:C28C8E02789CD73B66440D2A83DE2C00701F9B6DC5D60B31A61F57A513CE0B77.png)
路径效果
路径效果如虚线效果，只用于画笔。
可使用createDashPathEffect()接口设置路径效果。接口接受2个参数，分别为：
-  浮点数数组intervals：表示虚线或者点线的间隔。
-  浮点数phase：表示在intervals数组中的偏移量，即从数组的哪个位置开始应用虚线或点线效果。
此处以绘制矩形虚线路径效果为例，关键示例和效果示意图如下所示：
```typescript
// 创建画笔
let pen = new drawing.Pen();
// 设置线宽
pen.setStrokeWidth(10.0);
// 设置颜色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
// 表示10px的实线，5px的间隔，2px的实线，5px的间隔，以此循环
let intervals = [10, 5, 2, 5];
// 设置虚线路径效果
let effect = drawing.PathEffect.createDashPathEffect(intervals, 0);
pen.setPathEffect(effect);
// 设置画笔描边效果
canvas.attachPen(pen);
// 创建矩形
let rect: common2D.Rect = { left: 200, top: 200, right: 1000, bottom: 700 };
// 绘制矩形
canvas.drawRect(rect);
// 去除描边效果
canvas.detachPen();
```
| 原始图 | 设置虚线效果后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.22243888360824413240131043636621:50001231000000:2800:4230F18EEB3F6628260824F10A2073BD8FD9145CEECBA83744DC14E682875124.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.71469374674747544582087508302828:50001231000000:2800:0A26B75A64102F987939A2B853ABCA50499D931CF4F89E46A1743D0EA29DEE27.jpg)
着色器效果
着色器效果基于画刷或画笔实现，可使用setShaderEffect()接口设置画刷或画笔的着色器效果。当前支持不同的着色器效果，如线性渐变着色器效果、径向渐变着色器效果、扇形渐变着色器效果。
着色器相关接口和具体参数的说明请见ShaderEffect。
线性渐变着色器效果
可使用createLinearGradient()接口创建想要设置的线性渐变着色器效果。接口接受6个参数，分别是开始点、结束点、颜色数组、平铺模式、相对位置数组以及矩阵对象。
-  开始点和结束点用来确定渐变方向。
-  颜色数组用于存储渐变使用到的颜色。
-  相对位置数组则用于确定每种颜色在渐变中的相对位置，如果相对位置为空，颜色将会被均匀地分布在开始点和结束点之间。
-  矩阵对象，用于对着色器做矩阵变换，默认为null，表示单位矩阵。
-  平铺模式用于确定如何在渐变区域之外继续渐变效果，平铺模式分为以下4类：
此处以绘制矩形并使用画刷设置线性渐变着色器效果为例，关键示例和效果示意图如下所示：
```typescript
let startPt: common2D.Point = { x: 100, y: 100 };
let endPt: common2D.Point = { x: 900, y: 900 };
let colors = [0xFFFFFF00, 0xFFFF0000, 0xFF0000FF];
// 创建线性渐变着色器
let shaderEffect = drawing.ShaderEffect.createLinearGradient(startPt, endPt, colors, drawing.TileMode.CLAMP);
// 创建画刷
let brush = new drawing.Brush();
// 设置线性着色器
brush.setShaderEffect(shaderEffect);
// 设置画刷填充效果
canvas.attachBrush(brush);
let rect: common2D.Rect = { left: 100, top: 100, right: 900, bottom: 900 };
// 绘制矩形
canvas.drawRect(rect);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.44288052312109553193919989916066:50001231000000:2800:E26CFE02A044620E1E7302906BF5730945CA487A595B7EF6FFC08E26A14092E1.png)
径向渐变着色器效果
可使用createRadialGradient()接口创建想要设置的径向渐变着色器效果。接口接受6个参数，分别是圆心坐标（centerPt）、半径（radius）、颜色数组（colors）、平铺模式（TileMode）、相对位置数组（pos）以及矩阵对象（matrix）。
其实现方式与线性渐变着色器类似，不同的是，径向渐变是由圆心开始向外径向渐变的。
此处以绘制矩形并使用画刷设置径向渐变着色器效果为例，关键示例和效果示意图如下所示：
```typescript
let centerPt: common2D.Point = { x: 500, y: 500 };
let colors = [0xFFFF0000, 0xFF00FF00, 0xFF0000FF];
// 创建径向渐变着色器
let shaderEffect = drawing.ShaderEffect.createRadialGradient(centerPt, 600, colors, drawing.TileMode.CLAMP);
// 创建画刷
let brush = new drawing.Brush();
// 设置径向渐变着色器
brush.setShaderEffect(shaderEffect);
// 设置画刷填充效果
canvas.attachBrush(brush);
let rect: common2D.Rect = { left: 100, top: 100, right: 900, bottom: 900 };
// 绘制矩形
canvas.drawRect(rect);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.40756766615057629126145928196215:50001231000000:2800:33D678DE70B92A2A427433721669B0117FBF82D3C4DE4B04039D873B81A60A9B.jpg)
扇形渐变着色器效果
可使用createSweepGradient接口创建想要设置的扇形渐变着色器效果。接口接受7个参数，分别是圆心坐标（centerPt）、颜色数组（colors）、平铺模式（TileMode）、扇形渐变的起始角度（startAngle）、扇形渐变的结束角度（endAngle）、相对位置数组（pos）以及矩阵对象（matrix）。
其实现方式也与线性渐变着色器类似，不同的是，扇形渐变是在围绕中心点旋转的过程中渐变。
此处以绘制矩形并使用画刷设置扇形渐变着色器效果为例，关键示例和效果示意图如下所示：
```typescript
let centerPt: common2D.Point = { x: 500, y: 500 };
let colors = [0xFF00FFFF, 0xFFFF00FF, 0xFFFFFF00];
// 创建扇形渐变着色器
let shaderEffect = drawing.ShaderEffect.createSweepGradient(centerPt, colors, drawing.TileMode.CLAMP, 0, 360);
// 创建画刷
let brush = new drawing.Brush();
// 设置扇形渐变着色器
brush.setShaderEffect(shaderEffect);
// 设置画刷填充效果
canvas.attachBrush(brush);
let rect: common2D.Rect = { left: 100, top: 100, right: 900, bottom: 900 };
// 绘制矩形
canvas.drawRect(rect);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.00953927651162515984126518973267:50001231000000:2800:8408B2BBDA7F2BF0F4948A688AA7AB35610B8D437120AA6CEAD317BB23580191.jpg)
滤波器效果
滤波器效果可基于画刷或画笔实现。当前支持不同的滤波器效果，比如图像滤波器、颜色滤波器、蒙版滤波器。
滤波器相关接口和具体参数的说明请见ImageFilter。
颜色滤波器效果
颜色滤波器可基于画笔或画刷实现，颜色滤波器的相关接口和具体参数的说明请见ColorFilter。
目前可实现多种颜色滤波器，包括如下：
-  具有混合模式的颜色滤波器。
-  具有5x4颜色矩阵的颜色滤波器。
-  将SRGB的伽玛曲线应用到RGB颜色通道的颜色滤波器。
-  将RGB颜色通道应用于SRGB的伽玛曲线的颜色滤波器。
-  将其输入的亮度值乘以透明度通道， 并将红色、绿色和蓝色通道设置为零的颜色滤波器。
-  由两个颜色滤波器组合而成的颜色滤波器。
此处以具有5x4颜色矩阵的颜色滤波器为例。
可使用createMatrixColorFilter()接口创建具有5x4颜色矩阵的颜色滤波器。接口接受1个参数，表示为颜色矩阵，它是一个长度为20的浮点数数组。数组格式如下：
[ a0, a1, a2, a3, a4 ]
[ b0, b1, b2, b3, b4 ]
[ c0, c1, c2, c3, c4 ]
[ d0, d1, d2, d3, d4 ]
对于每个原始的像素颜色色值（R, G, B, A），变换后的色值（R', G', B', A'）计算公式为：
R' = a0*R + a1*G + a2*B + a3*A + a4
G' = b0*R + b1*G + b2*B + b3*A + b4
B' = c0*R + c1*G + c2*B + c3*A + c4
A' = d0*R + d1*G + d2*B + d3*A + d4
此处以绘制矩形并使用画刷设置具有5x4颜色矩阵的颜色滤波器效果为例，关键示例和效果示意图如下所示：
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置颜色
brush.setColor(0xFF, 0xFF, 0x00, 0x00);
// 设置颜色矩阵
let matrix: Array<number> = [
1, 0, 0, 0, 0,
0, 1, 0, 0, 0,
0, 0, 0.5, 0.5, 0,
0, 0, 0.5, 0.5, 0
];
// 创建5x4颜色矩阵的颜色滤波器
let filter = drawing.ColorFilter.createMatrixColorFilter(matrix);
// 设置颜色滤波器
brush.setColorFilter(filter);
// 设置画刷填充效果
canvas.attachBrush(brush);
let rect: common2D.Rect = { left: 300, top: 300, right: 900, bottom: 900 };
// 绘制矩形
canvas.drawRect(rect);
// 去除填充效果
canvas.detachBrush();
```
| 原始图 | 设置5x4颜色矩阵的颜色滤波器后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.70259392731629427432624819874270:50001231000000:2800:D565A2F02843D7571AA21E3CB06706EE64895918504826C70EC3311131D65DE2.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.31517505797622464666429597978439:50001231000000:2800:3C84F9B73E952B3B89A6871414DF662AB1A07AD466F490F51B34A108C04166C2.jpg)
图像滤波器效果
图像滤波器可基于画笔或画刷来实现，图像滤波器的相关接口和具体参数的说明请见ImageFilter。
目前只支持两种图像滤波器：
-  基于颜色滤波器的图像滤波器。 可通过createFromColorFilter()接口实现，接口接受2个参数，颜色滤波器colorFilter和图像滤波器imageFilter，即把颜色滤波器的效果叠加到图像滤波器imageFilter上，imageFilter可为空，imageFilter为空则只添加颜色滤波器效果。
-  具有模糊效果的图像滤波器。 可通过createBlurImageFilter()接口实现，接口接受4个参数，sigmaX，sigmaY，cTileMode和imageFilter。sigmaX和sigmaY是模糊的标准差，cTileMode是平铺模式，imageFilter是输入的图像滤波器。 最终效果即为在输入的图像滤波器imageFilter的基础上进行模糊化处理，即滤波器效果可叠加，imageFilter可为空，imageFilter为空则只添加模糊效果。
此处以绘制矩形并使用画笔添加模糊效果的图像滤波器效果为例，关键示例和效果示意图如下所示：
```typescript
// 设置画笔
let pen = new drawing.Pen();
// 设置线宽
pen.setStrokeWidth(10.0);
// 设置颜色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
// 创建模糊效果图像滤波器
let filter = drawing.ImageFilter.createBlurImageFilter(20, 20, drawing.TileMode.CLAMP);
// 设置图像滤波器
pen.setImageFilter(filter);
// 设置画笔描边效果
canvas.attachPen(pen);
let rect: common2D.Rect = { left: 300, top: 300, right: 900, bottom: 900 };
// 绘制矩形
canvas.drawRect(rect);
// 去除描边效果
canvas.detachPen();
```
| 原始图 | 设置模糊效果后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.40283988596367380681269983110399:50001231000000:2800:07E64B6F7139EFE1FCE4687833FC29B09FD882418CF15637AB490E5866201E12.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.57004075370294294780935490492369:50001231000000:2800:8F69F83DA5EE23E392958FF53E1FC2AF6B6D045A11CC7E73C0D520D23108D306.jpg)
蒙版滤波器效果
蒙版滤波器的模糊效果仅对透明度和形状边缘进行模糊处理，相对于图像滤波器的模糊效果来说计算成本更低。
蒙版滤波器可基于画笔或画刷实现，蒙版滤波器的相关接口和具体参数的说明请见MaskFilter。
可使用createBlurMaskFilter()接口创建想要设置具有模糊效果的蒙版滤波器。接口接受2个参数，分别为：
-  blurType：用于指定要应用的模糊类型，详细分类请参考BlurType。
-  sigma：用于指定要应用的高斯模糊的标准差，标准差必须大于0。
此处以绘制矩形并使用画笔设置蒙版滤波器效果为例，关键示例和效果示意图如下所示：
```typescript
// 创建画笔
let pen = new drawing.Pen();
// 设置线宽
pen.setStrokeWidth(10.0);
// 设置颜色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
// 创建模糊效果的蒙版滤波器
let filter = drawing.MaskFilter.createBlurMaskFilter(drawing.BlurType.NORMAL, 20);
// 设置模糊效果
pen.setMaskFilter(filter);
// 设置画笔描边效果
canvas.attachPen(pen);
let rect: common2D.Rect = { left: 300, top: 300, right: 900, bottom: 900 };
// 绘制矩形
canvas.drawRect(rect);
// 去除描边效果
canvas.detachPen();
```
| 原始图 | 设置模糊效果后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.12261051714583166911090855601115:50001231000000:2800:E81AA17814829EAAA065143246671498AD3CF36CDDE2ED8AD37018A88D6CDB22.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.26054480013174323776377478025663:50001231000000:2800:373CFCA93C1ABE29B2F7117ABE38239420D57ADF4581C3BDDFBDFF1380561ED0.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/basic-drawing-effect-arkts-V14
爬取时间: 2025-04-29 19:35:05
来源: Huawei Developer
场景介绍
在进行绘制时，可以进行一些基础效果的设置，比如设置填充颜色、设置抗锯齿、设置图形描边、设置图形线条连接样式等。
主要通过画刷（Brush）设置填充基础效果，通过画笔（Pen）设置描边基础效果。
填充效果
可以通过画刷设置基础的填充颜色，还可以通过画刷使用混合模式、着色器效果、滤波器效果等实现更多复杂绘制效果，具体可见复杂绘制效果。
接口说明
使用画刷（Brush）设置绘制效果的常用接口如下表所示，详细的使用和参数请见drawing.Brush。
| 接口 | 描述 |
| --- | --- |
| attachBrush(brush: Brush): void | 用于设置画刷给画布，画布将会使用设置的画刷样式和颜色去填充绘制的图形形状。 |
| setColor(alpha: number, red: number, green: number, blue: number): void | 用于设置画刷的颜色属性，颜色属性描述了画刷填充图形时使用的颜色。 |
| setAntiAlias(aa: boolean) : void | 用于设置画刷的抗锯齿属性，设置为true则画刷在绘制图形时会对图形的边缘像素进行半透明的模糊处理，以使图形边缘更加平滑。 |
| detachBrush(): void | 用于去除画布中的画刷，执行后画布将不使用此前设置的画刷，恢复到默认填充效果。 |
开发步骤
1.  创建画刷Brush对象。
```typescript
const brush = new drawing.Brush();
```
2.  使用画刷设置基础绘制效果，例如设置填充颜色、开启抗锯齿效果等。 可使用setColor()接口设置填充颜色。 可使用setAntiAlias()接口开启抗锯齿效果，以使图形边缘更加平滑。
```typescript
brush.setColor(0xFF, 0xFF, 0x00, 0x00);
```
3.  使用attachBrush()接口给Canvas画布设置画刷。
```typescript
canvas.attachBrush(brush);
```
4.  按需绘制图元，具体可见图元绘制一节。
5.  当不需要填充效果时，可以使用detachBrush()接口去除画布中的画刷。
```typescript
canvas.detachBrush();
```
描边效果
可以通过画笔设置基础的描边颜色，还可以通过画笔使用混合模式、路径效果、着色器效果、滤波器效果等实现更多复杂绘制效果，具体可见复杂绘制效果。
接口说明
使用画笔（Pen）设置绘制效果的常用接口如下表所示，详细的使用和参数请见drawing.Pen。
| 接口 | 描述 |
| --- | --- |
| attachPen(pen: Pen): void | 用于设置画笔给画布，画布将会使用设置画笔的样式和颜色去绘制图形形状的轮廓。 |
| setColor(alpha: number, red: number, green: number, blue: number): void | 用于设置画笔的颜色属性，颜色属性描述了画笔绘制图形轮廓时使用的颜色。 |
| setStrokeWidth(width: number) : void | 用于设置画笔的线宽。0线宽被视作特殊的极细线宽，在绘制时始终会被绘制为1像素，不随画布的缩放而改变；负数线宽在实际绘制时会被视作0线宽。 |
| setAntiAlias(aa: boolean) : void | 用于设置画笔的抗锯齿属性，设置为true则画笔在绘制图形时会对图形的边缘像素进行半透明的模糊处理。 |
| setCapStyle(style: CapStyle): void | 用于设置画笔线帽样式。 |
| setJoinStyle(style: JoinStyle): void | 用于设置画笔绘制转角的样式。 |
| detachPen(): void | 用于去除画布中的画笔，执行后画布将不去绘制图形形状的轮廓，恢复到默认的填充效果。 |
开发步骤
1.  创建画笔Pen对象。
```typescript
let pen = new drawing.Pen();
```
2.  使用attachPen()接口给Canvas画布设置画笔。画布将会使用设置的画笔样式和颜色等绘制图形轮廓。
```typescript
canvas.attachPen(pen);
```
3.  使用画笔设置具体的描边效果（可选以下的一个或者多个效果）。 可使用setColor()接口设置画笔颜色，对应为绘制图形轮廓时使用的颜色。 可使用setStrokeWidth()接口设置画笔的线宽。 可使用setAntiAlias()接口设置画笔抗锯齿，以使图形绘制边缘更平滑。 可使用setCapStyle()接口设置画笔线帽样式。 CapStyle线帽样式可选分类对应如下： 可使用setJoinStyle()接口设置画笔转角样式。 JoinStyle转角样式可选分类对应如下：
```typescript
// 设置颜色为红色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
```
4.  可使用setColor()接口设置画笔颜色，对应为绘制图形轮廓时使用的颜色。
```typescript
// 设置颜色为红色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
```
5.  可使用setStrokeWidth()接口设置画笔的线宽。
```typescript
pen.setStrokeWidth(15);
```
6.  可使用setAntiAlias()接口设置画笔抗锯齿，以使图形绘制边缘更平滑。
```typescript
pen.setAntiAlias(true);
```
7.  可使用setCapStyle()接口设置画笔线帽样式。 CapStyle线帽样式可选分类对应如下：
```typescript
pen.setCapStyle(drawing.CapStyle.SQUARE_CAP);
```
8.  可使用setJoinStyle()接口设置画笔转角样式。 JoinStyle转角样式可选分类对应如下：
```typescript
pen.setJoinStyle(drawing.JoinStyle.ROUND_JOIN);
```
9.  按需绘制图元，具体可见图元绘制一节。
10.  当不需要描边效果时，可以使用detachPen()接口去除画布中的画笔。
```typescript
canvas.detachPen();
```
-  可使用setColor()接口设置画笔颜色，对应为绘制图形轮廓时使用的颜色。
```typescript
// 设置颜色为红色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
```
-  可使用setStrokeWidth()接口设置画笔的线宽。
```typescript
pen.setStrokeWidth(15);
```
-  可使用setAntiAlias()接口设置画笔抗锯齿，以使图形绘制边缘更平滑。
```typescript
pen.setAntiAlias(true);
```
-  可使用setCapStyle()接口设置画笔线帽样式。 CapStyle线帽样式可选分类对应如下：
```typescript
pen.setCapStyle(drawing.CapStyle.SQUARE_CAP);
```
-  可使用setJoinStyle()接口设置画笔转角样式。 JoinStyle转角样式可选分类对应如下：
```typescript
pen.setJoinStyle(drawing.JoinStyle.ROUND_JOIN);
```
| 线帽样式 | 说明 | 示意图 |
| --- | --- | --- |
| FLAT_CAP | 没有线帽样式，线条头尾端点处横切。 |  |
| SQUARE_CAP | 线帽的样式为方框，线条的头尾端点处多出一个方框，方框宽度和线段一样宽，高度是线段宽度的一半。 |  |
| ROUND_CAP | 线帽的样式为圆弧，线条的头尾端点处多出一个半圆弧，半圆的直径与线段宽度一致。 |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.53556081379638672419438452515891:50001231000000:2800:92809429DAA623245A46A7F26750CB45DB7BFC03076F6A243CB1B29F54FA07DB.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.16854282697047897252645405483106:50001231000000:2800:66211B1BCD95B7B385939A7017EDB6C5CD73693F82B3EEB75C0BF6E61596B5D3.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.99274149269117357231775007854269:50001231000000:2800:2A580C6FDA656C8A5E37F67E45D1282075D624D5F4B686B0450BC5E0243D88CB.jpg)
| 转角样式 | 说明 | 示意图 |
| --- | --- | --- |
| MITER_JOIN | 转角类型为尖角 |  |
| ROUND_JOIN | 转角类型为圆头 |  |
| BEVEL_JOIN | 转角类型为平头 |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.78458274450201116338770215778963:50001231000000:2800:645B094E5DE086D5CA7256E87028CE3D401406C63BAC85C40199FFBAA427191A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.22650104964970191958708810571661:50001231000000:2800:32C8D18FAD0757B97892AD34CEB8A78D264037D93CC97A586C8CA227063724A5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.52091578148132682296380209247337:50001231000000:2800:FB86BFCC28A178D0DDBBF4704E85FDCBA22BE231AC78BF272320286531CA4E21.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/basic-drawing-effect-c-V14
爬取时间: 2025-04-29 19:35:06
来源: Huawei Developer
场景介绍
在进行绘制时，可以进行一些基础效果的设置，比如设置填充颜色、设置抗锯齿、设置图形描边、设置图形线条连接样式等。
主要通过画刷（Brush）设置填充基础效果，通过画笔（Pen）设置描边基础效果。
填充效果
可以通过画刷设置基础的填充颜色，还可以通过画刷使用混合模式、着色器效果、滤波器效果等实现更多复杂绘制效果，具体可见复杂绘制效果。
接口说明
使用画刷（Brush）设置绘制效果的常用接口如下表所示，详细的使用和参数请见drawing_brush。
| 接口 | 描述 |
| --- | --- |
| OH_Drawing_Brush* OH_Drawing_BrushCreate (void) | 用于创建一个画刷对象。 |
| void OH_Drawing_CanvasAttachBrush (OH_Drawing_Canvas*, const OH_Drawing_Brush*) | 用于设置画刷给画布，画布将会使用设置的画刷样式和颜色去填充绘制的图形形状。 |
| void OH_Drawing_BrushSetColor (OH_Drawing_Brush* , uint32_t color) | 用于设置画刷的颜色属性，颜色属性描述了画刷填充图形时使用的颜色，用一个32位（ARGB）的变量表示。 |
| void OH_Drawing_BrushSetAntiAlias (OH_Drawing_Brush* , bool) | 用于设置画刷的抗锯齿属性，设置为true则画刷在绘制图形时会对图形的边缘像素进行半透明的模糊处理，以使图形边缘更加平滑。 |
| void OH_Drawing_CanvasDetachBrush (OH_Drawing_Canvas*) | 用于去除画布中的画刷，执行后画布将不使用此前设置的画刷，恢复到默认的填充效果。 |
| void OH_Drawing_BrushDestroy (OH_Drawing_Brush*) | 用于销毁画刷对象并回收该对象占有的内存。 |
开发步骤
1.  使用OH_Drawing_BrushCreate()接口创建画刷Brush对象。
2.  使用画刷设置基础绘制效果（可选以下的一个或者多个效果）。 可使用OH_Drawing_BrushSetColor()接口设置填充颜色。 color是一个32位（ARGB）的变量，例如0xffff0000。 可使用OH_Drawing_BrushSetAntiAlias()接口开启抗锯齿效果，以使图形边缘更加平滑。
3.  可使用OH_Drawing_BrushSetColor()接口设置填充颜色。 color是一个32位（ARGB）的变量，例如0xffff0000。
4.  可使用OH_Drawing_BrushSetAntiAlias()接口开启抗锯齿效果，以使图形边缘更加平滑。
5.  使用OH_Drawing_CanvasAttachBrush()接口给Canvas画布设置画刷。接口接受两个参数，一个是画布对象Canvas，请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）；另一个是要画设置的画刷对象。画布将会使用设置的画刷样式和颜色等填充图形。
6.  按需绘制图元，具体可见图元绘制一节。
7.  当不需要填充效果时，可以使用OH_Drawing_CanvasDetachBrush()去除。入参为画布对象Canvas。
8.  当不再需要画刷进行效果填充时，请及时使用OH_Drawing_BrushDestroy()接口销毁Brush对象。
-  可使用OH_Drawing_BrushSetColor()接口设置填充颜色。 color是一个32位（ARGB）的变量，例如0xffff0000。
-  可使用OH_Drawing_BrushSetAntiAlias()接口开启抗锯齿效果，以使图形边缘更加平滑。
描边效果
可以通过画笔设置基础的描边颜色，还可以通过画笔使用混合模式、路径效果、着色器效果、滤波器效果等实现更多复杂绘制效果，具体可见复杂绘制效果。
接口说明
使用画笔（Pen）设置绘制效果的常用接口如下表所示，详细的使用和参数请见drawing_pen。
| 接口 | 描述 |
| --- | --- |
| OH_Drawing_Pen* OH_Drawing_PenCreate (void) | 用于创建一个画笔对象。 |
| void OH_Drawing_CanvasAttachPen (OH_Drawing_Canvas* , const OH_Drawing_Pen* ) | 用于设置画笔给画布，画布将会使用设置画笔的样式和颜色去绘制图形形状的轮廓。 |
| void OH_Drawing_PenSetColor (OH_Drawing_Pen* , uint32_t color) | 用于设置画笔的颜色属性，颜色属性描述了画笔绘制图形轮廓时使用的颜色，用一个32位（ARGB）的变量表示。 |
| void OH_Drawing_PenSetWidth (OH_Drawing_Pen* , float width) | 用于设置画笔的线宽。0线宽被视作特殊的极细线宽，在绘制时始终会被绘制为1像素，不随画布的缩放而改变；负数线宽在实际绘制时会被视作0线宽。 |
| void OH_Drawing_PenSetAntiAlias (OH_Drawing_Pen* , bool ) | 用于设置画笔的抗锯齿属性，设置为true则画笔在绘制图形时会对图形的边缘像素进行半透明的模糊处理。 |
| void OH_Drawing_PenSetCap (OH_Drawing_Pen* , OH_Drawing_PenLineCapStyle) | 用于设置画笔线帽样式。 |
| void OH_Drawing_PenSetJoin (OH_Drawing_Pen* , OH_Drawing_PenLineJoinStyle) | 用于设置画笔绘制转角的样式。 |
| void OH_Drawing_CanvasDetachPen (OH_Drawing_Canvas*) | 用于去除画布中的画笔，执行后后画布将不去绘制图形形状的轮廓，恢复到默认的填充效果。 |
| void OH_Drawing_PenDestroy (OH_Drawing_Pen*) | 用于销毁画笔对象并回收该对象占有的内存。 |
开发步骤
1.  使用OH_Drawing_PenCreate()接口创建画笔Pen对象。
2.  使用OH_Drawing_CanvasAttachPen()接口给Canvas画布设置画笔。接口接受两个参数，一个是画布对象Canvas，请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）；另一个是要画设置的画笔对象。画布将会使用设置的画笔样式和颜色等绘制图形轮廓。
3.  使用画笔设置具体的描边效果（可选以下的一个或者多个效果）。 可使用OH_Drawing_PenSetColor()接口设置画笔颜色，对应为绘制图形轮廓时使用的颜色。 color是一个32位（ARGB）的变量，例如0xffff0000。 可使用OH_Drawing_PenSetWidth()接口设置画笔的线宽。 width指线宽的像素值。 可使用OH_Drawing_PenSetAntiAlias()接口设置画笔抗锯齿，以使图形绘制边缘更平滑。 可使用OH_Drawing_PenSetCap()接口设置画笔线帽样式。 OH_Drawing_PenLineCapStyle线帽样式可选分类对应如下： 可使用OH_Drawing_PenSetJoin()接口设置画笔转角样式。 OH_Drawing_PenLineJoinStyle转角样式可选分类对应如下：
4.  可使用OH_Drawing_PenSetColor()接口设置画笔颜色，对应为绘制图形轮廓时使用的颜色。 color是一个32位（ARGB）的变量，例如0xffff0000。
5.  可使用OH_Drawing_PenSetWidth()接口设置画笔的线宽。 width指线宽的像素值。
6.  可使用OH_Drawing_PenSetAntiAlias()接口设置画笔抗锯齿，以使图形绘制边缘更平滑。
7.  可使用OH_Drawing_PenSetCap()接口设置画笔线帽样式。 OH_Drawing_PenLineCapStyle线帽样式可选分类对应如下：
8.  可使用OH_Drawing_PenSetJoin()接口设置画笔转角样式。 OH_Drawing_PenLineJoinStyle转角样式可选分类对应如下：
9.  按需绘制图元，具体可见图元绘制一节。
10.  当不需要描边效果时，可以使用OH_Drawing_CanvasDetachPen()去除。入参为画布对象Canvas，请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）。
11.  当不再需要画笔进行描边时，请及时使用OH_Drawing_PenDestroy()接口销毁Pen对象。
-  可使用OH_Drawing_PenSetColor()接口设置画笔颜色，对应为绘制图形轮廓时使用的颜色。 color是一个32位（ARGB）的变量，例如0xffff0000。
-  可使用OH_Drawing_PenSetWidth()接口设置画笔的线宽。 width指线宽的像素值。
-  可使用OH_Drawing_PenSetAntiAlias()接口设置画笔抗锯齿，以使图形绘制边缘更平滑。
-  可使用OH_Drawing_PenSetCap()接口设置画笔线帽样式。 OH_Drawing_PenLineCapStyle线帽样式可选分类对应如下：
-  可使用OH_Drawing_PenSetJoin()接口设置画笔转角样式。 OH_Drawing_PenLineJoinStyle转角样式可选分类对应如下：
| 线帽样式 | 说明 | 示意图 |
| --- | --- | --- |
| FLAT_CAP | 没有线帽样式，线条头尾端点处横切。 |  |
| SQUARE_CAP | 线帽的样式为方框，线条的头尾端点处多出一个方框，方框宽度和线段一样宽，高度是线段宽度的一半。 |  |
| ROUND_CAP | 线帽的样式为圆弧，线条的头尾端点处多出一个半圆弧，半圆的直径与线段宽度一致。 |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.00621822529314705867163221055016:50001231000000:2800:CDBA916BE79950D448FF9DE72D34CA34E127EC36302602187D8E59593C418BFC.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.84654048196278932031886037448566:50001231000000:2800:6E210F43219D23319A58C20CB2F791BD3AFA081754CEB346D17BB06C38CB8589.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.62607452663293760725618313225798:50001231000000:2800:5C410260566B4372ED8A0484A2D90C6B05477630F279205A748D19CCC970E455.jpg)
| 转角样式 | 说明 | 示意图 |
| --- | --- | --- |
| MITER_JOIN | 转角类型为尖角 |  |
| ROUND_JOIN | 转角类型为圆头 |  |
| BEVEL_JOIN | 转角类型为平头 |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.97926790319608085831310132101301:50001231000000:2800:95AAF22E40D18285EA9B5B406A3DC18D446B05EDE2FB4FE52EBA59A010E2965E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.45833673799356547773596613478915:50001231000000:2800:4DC52C1A3112221AF3AF01DA0BA2A5DACFAFA48111A7BED3E4416E40FF3FFAAC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.41742585859289228033041390418103:50001231000000:2800:BC6930D6E0912B0A14D1A65E96ED03066E8DDD81A7E9D5687838132E5B832BD0.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/complex-drawing-effect-arkts-V14
爬取时间: 2025-04-29 19:35:19
来源: Huawei Developer
除了基础填充颜色、描边颜色和一些样式设置的绘制效果外，还支持通过画刷和画笔实现更多复杂的绘制效果。比如：
-  混合模式。
-  路径效果，如虚线效果。
-  着色器效果，如线性渐变、径向渐变等。
-  滤波效果，如模糊效果等。
混合模式
混合模式可以用于画笔或画刷，它定义了如何将源像素（要绘制的内容）与目标像素（已存在于画布上的内容）进行组合。
可以使用setBlendMode()接口将混合模式应用于画刷或画笔中，该接口需要接受一个参数BlendMode，即混合模式的类型，具体可参考BlendMode。
此处以使用画刷设置叠加混合模式为例（为了防止混合模式的效果被背景色干扰，示例中的canvas并未设置背景色，使用的是默认的黑色背景），关键示例和效果示意图如下所示：
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置目标像素颜色，即矩形的颜色
brush.setColor(0xFF, 0xFF,  0x00, 0x00);
// 将目标像素的画刷效果设置到Canvas中
canvas.attachBrush(brush);
// 创建矩形对象
let rect: common2D.Rect = { left: 100, top: 100, right: 600, bottom: 600 };
// 绘制矩形（目标像素）
canvas.drawRect(rect);
// 设置源像素颜色，即圆形的颜色
brush.setColor(0xFF, 0x00,  0x00, 0xFF);
// 设置混合模式为叠加模式
brush.setBlendMode(drawing.BlendMode.PLUS);
// 将源像素的画刷效果设置到Canvas中
canvas.attachBrush(brush);
// 绘制圆（源像素）
canvas.drawCircle(600, 600, 300);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.60134965771775957812906056169371:50001231000000:2800:C28C8E02789CD73B66440D2A83DE2C00701F9B6DC5D60B31A61F57A513CE0B77.png)
路径效果
路径效果如虚线效果，只用于画笔。
可使用createDashPathEffect()接口设置路径效果。接口接受2个参数，分别为：
-  浮点数数组intervals：表示虚线或者点线的间隔。
-  浮点数phase：表示在intervals数组中的偏移量，即从数组的哪个位置开始应用虚线或点线效果。
此处以绘制矩形虚线路径效果为例，关键示例和效果示意图如下所示：
```typescript
// 创建画笔
let pen = new drawing.Pen();
// 设置线宽
pen.setStrokeWidth(10.0);
// 设置颜色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
// 表示10px的实线，5px的间隔，2px的实线，5px的间隔，以此循环
let intervals = [10, 5, 2, 5];
// 设置虚线路径效果
let effect = drawing.PathEffect.createDashPathEffect(intervals, 0);
pen.setPathEffect(effect);
// 设置画笔描边效果
canvas.attachPen(pen);
// 创建矩形
let rect: common2D.Rect = { left: 200, top: 200, right: 1000, bottom: 700 };
// 绘制矩形
canvas.drawRect(rect);
// 去除描边效果
canvas.detachPen();
```
| 原始图 | 设置虚线效果后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165913.22243888360824413240131043636621:50001231000000:2800:4230F18EEB3F6628260824F10A2073BD8FD9145CEECBA83744DC14E682875124.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.71469374674747544582087508302828:50001231000000:2800:0A26B75A64102F987939A2B853ABCA50499D931CF4F89E46A1743D0EA29DEE27.jpg)
着色器效果
着色器效果基于画刷或画笔实现，可使用setShaderEffect()接口设置画刷或画笔的着色器效果。当前支持不同的着色器效果，如线性渐变着色器效果、径向渐变着色器效果、扇形渐变着色器效果。
着色器相关接口和具体参数的说明请见ShaderEffect。
线性渐变着色器效果
可使用createLinearGradient()接口创建想要设置的线性渐变着色器效果。接口接受6个参数，分别是开始点、结束点、颜色数组、平铺模式、相对位置数组以及矩阵对象。
-  开始点和结束点用来确定渐变方向。
-  颜色数组用于存储渐变使用到的颜色。
-  相对位置数组则用于确定每种颜色在渐变中的相对位置，如果相对位置为空，颜色将会被均匀地分布在开始点和结束点之间。
-  矩阵对象，用于对着色器做矩阵变换，默认为null，表示单位矩阵。
-  平铺模式用于确定如何在渐变区域之外继续渐变效果，平铺模式分为以下4类：
此处以绘制矩形并使用画刷设置线性渐变着色器效果为例，关键示例和效果示意图如下所示：
```typescript
let startPt: common2D.Point = { x: 100, y: 100 };
let endPt: common2D.Point = { x: 900, y: 900 };
let colors = [0xFFFFFF00, 0xFFFF0000, 0xFF0000FF];
// 创建线性渐变着色器
let shaderEffect = drawing.ShaderEffect.createLinearGradient(startPt, endPt, colors, drawing.TileMode.CLAMP);
// 创建画刷
let brush = new drawing.Brush();
// 设置线性着色器
brush.setShaderEffect(shaderEffect);
// 设置画刷填充效果
canvas.attachBrush(brush);
let rect: common2D.Rect = { left: 100, top: 100, right: 900, bottom: 900 };
// 绘制矩形
canvas.drawRect(rect);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.44288052312109553193919989916066:50001231000000:2800:E26CFE02A044620E1E7302906BF5730945CA487A595B7EF6FFC08E26A14092E1.png)
径向渐变着色器效果
可使用createRadialGradient()接口创建想要设置的径向渐变着色器效果。接口接受6个参数，分别是圆心坐标（centerPt）、半径（radius）、颜色数组（colors）、平铺模式（TileMode）、相对位置数组（pos）以及矩阵对象（matrix）。
其实现方式与线性渐变着色器类似，不同的是，径向渐变是由圆心开始向外径向渐变的。
此处以绘制矩形并使用画刷设置径向渐变着色器效果为例，关键示例和效果示意图如下所示：
```typescript
let centerPt: common2D.Point = { x: 500, y: 500 };
let colors = [0xFFFF0000, 0xFF00FF00, 0xFF0000FF];
// 创建径向渐变着色器
let shaderEffect = drawing.ShaderEffect.createRadialGradient(centerPt, 600, colors, drawing.TileMode.CLAMP);
// 创建画刷
let brush = new drawing.Brush();
// 设置径向渐变着色器
brush.setShaderEffect(shaderEffect);
// 设置画刷填充效果
canvas.attachBrush(brush);
let rect: common2D.Rect = { left: 100, top: 100, right: 900, bottom: 900 };
// 绘制矩形
canvas.drawRect(rect);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.40756766615057629126145928196215:50001231000000:2800:33D678DE70B92A2A427433721669B0117FBF82D3C4DE4B04039D873B81A60A9B.jpg)
扇形渐变着色器效果
可使用createSweepGradient接口创建想要设置的扇形渐变着色器效果。接口接受7个参数，分别是圆心坐标（centerPt）、颜色数组（colors）、平铺模式（TileMode）、扇形渐变的起始角度（startAngle）、扇形渐变的结束角度（endAngle）、相对位置数组（pos）以及矩阵对象（matrix）。
其实现方式也与线性渐变着色器类似，不同的是，扇形渐变是在围绕中心点旋转的过程中渐变。
此处以绘制矩形并使用画刷设置扇形渐变着色器效果为例，关键示例和效果示意图如下所示：
```typescript
let centerPt: common2D.Point = { x: 500, y: 500 };
let colors = [0xFF00FFFF, 0xFFFF00FF, 0xFFFFFF00];
// 创建扇形渐变着色器
let shaderEffect = drawing.ShaderEffect.createSweepGradient(centerPt, colors, drawing.TileMode.CLAMP, 0, 360);
// 创建画刷
let brush = new drawing.Brush();
// 设置扇形渐变着色器
brush.setShaderEffect(shaderEffect);
// 设置画刷填充效果
canvas.attachBrush(brush);
let rect: common2D.Rect = { left: 100, top: 100, right: 900, bottom: 900 };
// 绘制矩形
canvas.drawRect(rect);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.00953927651162515984126518973267:50001231000000:2800:8408B2BBDA7F2BF0F4948A688AA7AB35610B8D437120AA6CEAD317BB23580191.jpg)
滤波器效果
滤波器效果可基于画刷或画笔实现。当前支持不同的滤波器效果，比如图像滤波器、颜色滤波器、蒙版滤波器。
滤波器相关接口和具体参数的说明请见ImageFilter。
颜色滤波器效果
颜色滤波器可基于画笔或画刷实现，颜色滤波器的相关接口和具体参数的说明请见ColorFilter。
目前可实现多种颜色滤波器，包括如下：
-  具有混合模式的颜色滤波器。
-  具有5x4颜色矩阵的颜色滤波器。
-  将SRGB的伽玛曲线应用到RGB颜色通道的颜色滤波器。
-  将RGB颜色通道应用于SRGB的伽玛曲线的颜色滤波器。
-  将其输入的亮度值乘以透明度通道， 并将红色、绿色和蓝色通道设置为零的颜色滤波器。
-  由两个颜色滤波器组合而成的颜色滤波器。
此处以具有5x4颜色矩阵的颜色滤波器为例。
可使用createMatrixColorFilter()接口创建具有5x4颜色矩阵的颜色滤波器。接口接受1个参数，表示为颜色矩阵，它是一个长度为20的浮点数数组。数组格式如下：
[ a0, a1, a2, a3, a4 ]
[ b0, b1, b2, b3, b4 ]
[ c0, c1, c2, c3, c4 ]
[ d0, d1, d2, d3, d4 ]
对于每个原始的像素颜色色值（R, G, B, A），变换后的色值（R', G', B', A'）计算公式为：
R' = a0*R + a1*G + a2*B + a3*A + a4
G' = b0*R + b1*G + b2*B + b3*A + b4
B' = c0*R + c1*G + c2*B + c3*A + c4
A' = d0*R + d1*G + d2*B + d3*A + d4
此处以绘制矩形并使用画刷设置具有5x4颜色矩阵的颜色滤波器效果为例，关键示例和效果示意图如下所示：
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置颜色
brush.setColor(0xFF, 0xFF, 0x00, 0x00);
// 设置颜色矩阵
let matrix: Array<number> = [
1, 0, 0, 0, 0,
0, 1, 0, 0, 0,
0, 0, 0.5, 0.5, 0,
0, 0, 0.5, 0.5, 0
];
// 创建5x4颜色矩阵的颜色滤波器
let filter = drawing.ColorFilter.createMatrixColorFilter(matrix);
// 设置颜色滤波器
brush.setColorFilter(filter);
// 设置画刷填充效果
canvas.attachBrush(brush);
let rect: common2D.Rect = { left: 300, top: 300, right: 900, bottom: 900 };
// 绘制矩形
canvas.drawRect(rect);
// 去除填充效果
canvas.detachBrush();
```
| 原始图 | 设置5x4颜色矩阵的颜色滤波器后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.70259392731629427432624819874270:50001231000000:2800:D565A2F02843D7571AA21E3CB06706EE64895918504826C70EC3311131D65DE2.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.31517505797622464666429597978439:50001231000000:2800:3C84F9B73E952B3B89A6871414DF662AB1A07AD466F490F51B34A108C04166C2.jpg)
图像滤波器效果
图像滤波器可基于画笔或画刷来实现，图像滤波器的相关接口和具体参数的说明请见ImageFilter。
目前只支持两种图像滤波器：
-  基于颜色滤波器的图像滤波器。 可通过createFromColorFilter()接口实现，接口接受2个参数，颜色滤波器colorFilter和图像滤波器imageFilter，即把颜色滤波器的效果叠加到图像滤波器imageFilter上，imageFilter可为空，imageFilter为空则只添加颜色滤波器效果。
-  具有模糊效果的图像滤波器。 可通过createBlurImageFilter()接口实现，接口接受4个参数，sigmaX，sigmaY，cTileMode和imageFilter。sigmaX和sigmaY是模糊的标准差，cTileMode是平铺模式，imageFilter是输入的图像滤波器。 最终效果即为在输入的图像滤波器imageFilter的基础上进行模糊化处理，即滤波器效果可叠加，imageFilter可为空，imageFilter为空则只添加模糊效果。
此处以绘制矩形并使用画笔添加模糊效果的图像滤波器效果为例，关键示例和效果示意图如下所示：
```typescript
// 设置画笔
let pen = new drawing.Pen();
// 设置线宽
pen.setStrokeWidth(10.0);
// 设置颜色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
// 创建模糊效果图像滤波器
let filter = drawing.ImageFilter.createBlurImageFilter(20, 20, drawing.TileMode.CLAMP);
// 设置图像滤波器
pen.setImageFilter(filter);
// 设置画笔描边效果
canvas.attachPen(pen);
let rect: common2D.Rect = { left: 300, top: 300, right: 900, bottom: 900 };
// 绘制矩形
canvas.drawRect(rect);
// 去除描边效果
canvas.detachPen();
```
| 原始图 | 设置模糊效果后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.40283988596367380681269983110399:50001231000000:2800:07E64B6F7139EFE1FCE4687833FC29B09FD882418CF15637AB490E5866201E12.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.57004075370294294780935490492369:50001231000000:2800:8F69F83DA5EE23E392958FF53E1FC2AF6B6D045A11CC7E73C0D520D23108D306.jpg)
蒙版滤波器效果
蒙版滤波器的模糊效果仅对透明度和形状边缘进行模糊处理，相对于图像滤波器的模糊效果来说计算成本更低。
蒙版滤波器可基于画笔或画刷实现，蒙版滤波器的相关接口和具体参数的说明请见MaskFilter。
可使用createBlurMaskFilter()接口创建想要设置具有模糊效果的蒙版滤波器。接口接受2个参数，分别为：
-  blurType：用于指定要应用的模糊类型，详细分类请参考BlurType。
-  sigma：用于指定要应用的高斯模糊的标准差，标准差必须大于0。
此处以绘制矩形并使用画笔设置蒙版滤波器效果为例，关键示例和效果示意图如下所示：
```typescript
// 创建画笔
let pen = new drawing.Pen();
// 设置线宽
pen.setStrokeWidth(10.0);
// 设置颜色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
// 创建模糊效果的蒙版滤波器
let filter = drawing.MaskFilter.createBlurMaskFilter(drawing.BlurType.NORMAL, 20);
// 设置模糊效果
pen.setMaskFilter(filter);
// 设置画笔描边效果
canvas.attachPen(pen);
let rect: common2D.Rect = { left: 300, top: 300, right: 900, bottom: 900 };
// 绘制矩形
canvas.drawRect(rect);
// 去除描边效果
canvas.detachPen();
```
| 原始图 | 设置模糊效果后的效果图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.12261051714583166911090855601115:50001231000000:2800:E81AA17814829EAAA065143246671498AD3CF36CDDE2ED8AD37018A88D6CDB22.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165914.26054480013174323776377478025663:50001231000000:2800:373CFCA93C1ABE29B2F7117ABE38239420D57ADF4581C3BDDFBDFF1380561ED0.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/complex-drawing-effect-c-V14
爬取时间: 2025-04-29 19:35:20
来源: Huawei Developer
除了基础填充颜色、描边颜色和一些样式设置的绘制效果外，还支持通过画刷和画笔实现更多复杂的绘制效果。比如：
-  混合模式
-  路径效果，如虚线效果。
-  着色器效果，如线性渐变、径向渐变等。
-  滤波效果，如模糊效果等。
混合模式
混合模式可以用于画笔或画刷，它定义了如何将源像素（要绘制的内容）与目标像素（已存在于画布上的内容）进行组合。
可以使用OH_Drawing_BrushSetBlendMode()接口将混合模式应用于画刷中，使用OH_Drawing_PenSetBlendMode接口将混合模式应用于画笔中。这两个接口都需要接受一个参数OH_Drawing_BlendMode，即混合模式的类型，具体可参考BlendMode。
此处以使用画刷设置叠加混合模式为例（为了防止混合模式的效果被背景色干扰，示例中的canvas并未设置背景色，使用的是默认的黑色背景），关键示例和效果示意图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.55928481978050527484771436072971:50001231000000:2800:B1AB5908E711FB281CF425A1F6D466150D7D9C2B44AE5307BCA2F93183D35B90.png)
路径效果
路径效果如虚线效果，只用于画笔。
可使用OH_Drawing_CreateDashPathEffect()接口设置路径效果。接口接受3个参数，分别为：
-  浮点数数组intervals：表示虚线或者点线的间隔。
-  整数count：表示intervals数组中的元素数量。
-  浮点数phase：表示在intervals数组中的偏移量，即从数组的哪个位置开始应用虚线或点线效果。
此处以绘制矩形虚线路径效果为例，关键示例和效果示意图如下所示：
| 不设置虚线路径效果的示意图 | 设置虚线效果的示意图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.92381453047000542004663233314920:50001231000000:2800:486D774B0961684C4F0518914859D1616CE453BC743645D5C80C8D47BA4F01CE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.40904308804198876836272859000324:50001231000000:2800:17290B38AB357336D2A172CCB278FA01BF74663014E1AF4066D65C87009DFD9B.png)
着色器效果
着色器效果基于画刷或画笔实现，可使用OH_Drawing_BrushSetShaderEffect()接口设置画刷的着色器效果，或者使用 OH_Drawing_PenSetShaderEffect接口设置画笔的着色器效果。当前支持不同的着色器效果，如线性渐变着色器效果、径向渐变着色器效果、扇形渐变着色器效果。
着色器相关接口和具体参数的说明请见drawing_shader_effect。
线性渐变着色器效果
可使用OH_Drawing_ShaderEffectCreateLinearGradient()接口创建想要设置的线性渐变着色器效果。接口接受6个参数，分别为开始点、结束点、颜色数组、相对位置数组、颜色数组的大小以及平铺模式。
-  开始点和结束点用来确定渐变方向。
-  颜色数组用于存储渐变使用到的颜色。
-  相对位置数组则用于确定每种颜色在渐变中的相对位置，如果相对位置为空，颜色将会被均匀地分布在开始点和结束点之间。
-  平铺模式用于确定如何在渐变区域之外继续渐变效果，平铺模式分为以下4类：
此处以绘制矩形并使用画刷设置线性渐变着色器效果为例，关键示例和效果示意图如下所示：
此例绘制的具有线性渐变着色器效果的矩形如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.49370205483504535161648752329880:50001231000000:2800:956F29E11CC0369747311E70D531228011058BA3F105BD4ED5F322DC23A7D405.png)
径向渐变着色器效果
可使用OH_Drawing_ShaderEffectCreateRadialGradient()接口创建想要设置的径向渐变着色器效果。接口接受6个参数，分别为圆心坐标（centerPt）、半径（radius）、颜色数组（colors）、相对位置数组（pos）、颜色和位置的数量（size）以及平铺模式（OH_Drawing_TileMode）。
其实现方式与线性渐变着色器类似，不同的是，径向渐变是由圆心开始向外径向渐变的。
此处以绘制矩形并使用画刷设置径向渐变着色器效果为例，关键示例和效果示意图如下所示：
此例绘制的具有径向渐变着色器效果的矩形如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.73831412244898234939508438213683:50001231000000:2800:C3A3ED4FEC9A9736AB828315021535E7E38CF75258382F9071BE2D835DCFCF0D.png)
扇形渐变着色器效果
可使用OH_Drawing_ShaderEffectCreateSweepGradient()接口创建想要设置的扇形渐变着色器效果。接口接受5个参数，分别是中心点、颜色数组、相对位置数组、颜色和相对位置的数量以及平铺模式。
其实现方式也与线性渐变着色器类似，不同的是，扇形渐变是在围绕中心点旋转的过程中渐变。
此处以绘制矩形并使用画刷设置扇形渐变着色器效果为例，关键示例和效果示意图如下所示：
此例绘制的具有扇形渐变着色器效果的矩形如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.15208266064348463574230968023488:50001231000000:2800:7EB80711DA2229F43D02E5CF4BF8A2F2914C429C7353A6DE001FDD208FE4E0F5.png)
滤波器效果
滤波器效果可基于画刷或画笔实现。可使用OH_Drawing_PenSetFilter()接口设置画笔的滤波器效果，或者使用OH_Drawing_BrushSetFilter()接口设置画刷的滤波器效果。当前支持不同的滤波器效果，比如图像滤波器、颜色滤波器、蒙版滤波器。
滤波器相关接口和具体参数的说明请见drawing_filter.h。
颜色滤波器效果
颜色滤波器可基于画笔或画刷实现，颜色滤波器的相关接口和具体参数的说明请见drawing_color_filter.h。
目前可实现多种颜色滤波器，包括如下：
-  具有混合模式的颜色滤波器。
-  具有5x4颜色矩阵的颜色滤波器。
-  将SRGB的伽玛曲线应用到RGB颜色通道的颜色滤波器。
-  将RGB颜色通道应用于SRGB的伽玛曲线的颜色滤波器。
-  将其输入的亮度值乘以透明度通道， 并将红色、绿色和蓝色通道设置为零的颜色滤波器。
-  由两个颜色滤波器组合而成的颜色滤波器。
此处以具有5x4颜色矩阵的颜色滤波器为例。
可使用OH_Drawing_ColorFilterCreateMatrix()接口创建具有5x4颜色矩阵的颜色滤波器。接口接受1个参数，表示为颜色矩阵，它是一个长度为20的浮点数数组。数组格式如下：
[ a0, a1, a2, a3, a4 ]
[ b0, b1, b2, b3, b4 ]
[ c0, c1, c2, c3, c4 ]
[ d0, d1, d2, d3, d4 ]
对于每个原始的像素颜色色值（R, G, B, A），变换后的色值（R', G', B', A'）计算公式为：
R' = a0*R + a1*G + a2*B + a3*A + a4
G' = b0*R + b1*G + b2*B + b3*A + b4
B' = c0*R + c1*G + c2*B + c3*A + c4
A' = d0*R + d1*G + d2*B + d3*A + d4
此处以绘制矩形并使用画刷设置具有5x4颜色矩阵的颜色滤波器效果为例，关键示例和效果示意图如下所示：
| 不设置颜色滤波器效果的示意图 | 设置5x4颜色矩阵的颜色滤波器效果的示意图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.72883214651147791996597290986202:50001231000000:2800:8A76358462462098641028FDB9896EF3E6E5B3FB93AAB8F8013FE5C8BDB26A90.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.80578175783436530643544749926435:50001231000000:2800:C24E7380DC44AD5A8250FE3C8730C7A189D121E2DBCA1261367FACAFC07F5468.png)
图像滤波器效果
图像滤波器可基于画笔或画刷来实现，图像滤波器的相关接口和具体参数的说明请见drawing_image_filter.h。
目前只支持两种图像滤波器：
-  基于颜色滤波器的图像滤波器。 可通过OH_Drawing_ImageFilterCreateFromColorFilter()接口实现，接口接受2个参数，颜色滤波器colorFilter和图像滤波器input，即把颜色滤波器的效果叠加到图像滤波器input上，input可为空，input为空则只添加颜色滤波器效果。
-  具有模糊效果的图像滤波器。 可通过OH_Drawing_ImageFilterCreateBlur()接口实现，接口接受4个参数，分别为X轴上的模糊标准差、Y轴上的模糊标准差、平铺模式和图像滤波器（input）。 最终效果即为在输入的图像滤波器（input）的基础上进行模糊化处理，即滤波器效果可叠加，input可为空，input为空则只添加模糊效果。
此处以绘制矩形并使用画笔添加模糊效果的图像滤波器效果为例，关键示例和效果示意图如下所示：
| 不设置图像滤波器效果的示意图 | 设置图像滤波器效果的示意图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.12613551913108794084299928566093:50001231000000:2800:BEF73C5D24AA61D1099FEE4E5EA11707C9F0E746BE29E14B6B146E10F45E9696.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.22090270629793691176811178991419:50001231000000:2800:FC05070BDDDF82ED1C4B1E8908534E1B3C75BB5011F6D59EF85CD4F8B6329C7F.png)
蒙版滤波器效果
蒙版滤波器的模糊效果仅对透明度和形状边缘进行模糊处理，相对于图像滤波器的模糊效果来说计算成本更低。
蒙版滤波器可基于画笔或画刷实现，蒙版滤波器的相关接口和具体参数的说明请见drawing_mask_filter.h。
可使用H_Drawing_MaskFilterCreateBlur()接口创建想要设置具有模糊效果的蒙版滤波器。接口接受3个参数，分别为：
-  blurType：用于指定要应用的模糊类型，详细分类请参考BlurType。
-  sigma：用于指定要应用的高斯模糊的标准差，标准差必须大于0。
-  respectCTM：指定模糊的标准差是否会被CTM（coordinate transformation matrix，坐标变换矩阵）修改，默认为true，表示会被对应修改。
此处以绘制矩形并使用画笔设置蒙版滤波器效果为例，关键示例和效果示意图如下所示：
| 不设置蒙版滤波器效果的示意图 | 设置蒙版滤波器效果的示意图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.54526884407880677639430812236061:50001231000000:2800:5B0E2AADC4DE0DEBB90A6916E96ED2A5EB3E1C4F0D48774B1A08B2999665586E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.27567840953524584343174674243421:50001231000000:2800:A35523B6E95E007A52E2B54C47065D26B2B2A12EFA953A2167FF71F455B69C0E.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/basic-drawing-effect-c-V14
爬取时间: 2025-04-29 19:35:32
来源: Huawei Developer
场景介绍
在进行绘制时，可以进行一些基础效果的设置，比如设置填充颜色、设置抗锯齿、设置图形描边、设置图形线条连接样式等。
主要通过画刷（Brush）设置填充基础效果，通过画笔（Pen）设置描边基础效果。
填充效果
可以通过画刷设置基础的填充颜色，还可以通过画刷使用混合模式、着色器效果、滤波器效果等实现更多复杂绘制效果，具体可见复杂绘制效果。
接口说明
使用画刷（Brush）设置绘制效果的常用接口如下表所示，详细的使用和参数请见drawing_brush。
| 接口 | 描述 |
| --- | --- |
| OH_Drawing_Brush* OH_Drawing_BrushCreate (void) | 用于创建一个画刷对象。 |
| void OH_Drawing_CanvasAttachBrush (OH_Drawing_Canvas*, const OH_Drawing_Brush*) | 用于设置画刷给画布，画布将会使用设置的画刷样式和颜色去填充绘制的图形形状。 |
| void OH_Drawing_BrushSetColor (OH_Drawing_Brush* , uint32_t color) | 用于设置画刷的颜色属性，颜色属性描述了画刷填充图形时使用的颜色，用一个32位（ARGB）的变量表示。 |
| void OH_Drawing_BrushSetAntiAlias (OH_Drawing_Brush* , bool) | 用于设置画刷的抗锯齿属性，设置为true则画刷在绘制图形时会对图形的边缘像素进行半透明的模糊处理，以使图形边缘更加平滑。 |
| void OH_Drawing_CanvasDetachBrush (OH_Drawing_Canvas*) | 用于去除画布中的画刷，执行后画布将不使用此前设置的画刷，恢复到默认的填充效果。 |
| void OH_Drawing_BrushDestroy (OH_Drawing_Brush*) | 用于销毁画刷对象并回收该对象占有的内存。 |
开发步骤
1.  使用OH_Drawing_BrushCreate()接口创建画刷Brush对象。
2.  使用画刷设置基础绘制效果（可选以下的一个或者多个效果）。 可使用OH_Drawing_BrushSetColor()接口设置填充颜色。 color是一个32位（ARGB）的变量，例如0xffff0000。 可使用OH_Drawing_BrushSetAntiAlias()接口开启抗锯齿效果，以使图形边缘更加平滑。
3.  可使用OH_Drawing_BrushSetColor()接口设置填充颜色。 color是一个32位（ARGB）的变量，例如0xffff0000。
4.  可使用OH_Drawing_BrushSetAntiAlias()接口开启抗锯齿效果，以使图形边缘更加平滑。
5.  使用OH_Drawing_CanvasAttachBrush()接口给Canvas画布设置画刷。接口接受两个参数，一个是画布对象Canvas，请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）；另一个是要画设置的画刷对象。画布将会使用设置的画刷样式和颜色等填充图形。
6.  按需绘制图元，具体可见图元绘制一节。
7.  当不需要填充效果时，可以使用OH_Drawing_CanvasDetachBrush()去除。入参为画布对象Canvas。
8.  当不再需要画刷进行效果填充时，请及时使用OH_Drawing_BrushDestroy()接口销毁Brush对象。
-  可使用OH_Drawing_BrushSetColor()接口设置填充颜色。 color是一个32位（ARGB）的变量，例如0xffff0000。
-  可使用OH_Drawing_BrushSetAntiAlias()接口开启抗锯齿效果，以使图形边缘更加平滑。
描边效果
可以通过画笔设置基础的描边颜色，还可以通过画笔使用混合模式、路径效果、着色器效果、滤波器效果等实现更多复杂绘制效果，具体可见复杂绘制效果。
接口说明
使用画笔（Pen）设置绘制效果的常用接口如下表所示，详细的使用和参数请见drawing_pen。
| 接口 | 描述 |
| --- | --- |
| OH_Drawing_Pen* OH_Drawing_PenCreate (void) | 用于创建一个画笔对象。 |
| void OH_Drawing_CanvasAttachPen (OH_Drawing_Canvas* , const OH_Drawing_Pen* ) | 用于设置画笔给画布，画布将会使用设置画笔的样式和颜色去绘制图形形状的轮廓。 |
| void OH_Drawing_PenSetColor (OH_Drawing_Pen* , uint32_t color) | 用于设置画笔的颜色属性，颜色属性描述了画笔绘制图形轮廓时使用的颜色，用一个32位（ARGB）的变量表示。 |
| void OH_Drawing_PenSetWidth (OH_Drawing_Pen* , float width) | 用于设置画笔的线宽。0线宽被视作特殊的极细线宽，在绘制时始终会被绘制为1像素，不随画布的缩放而改变；负数线宽在实际绘制时会被视作0线宽。 |
| void OH_Drawing_PenSetAntiAlias (OH_Drawing_Pen* , bool ) | 用于设置画笔的抗锯齿属性，设置为true则画笔在绘制图形时会对图形的边缘像素进行半透明的模糊处理。 |
| void OH_Drawing_PenSetCap (OH_Drawing_Pen* , OH_Drawing_PenLineCapStyle) | 用于设置画笔线帽样式。 |
| void OH_Drawing_PenSetJoin (OH_Drawing_Pen* , OH_Drawing_PenLineJoinStyle) | 用于设置画笔绘制转角的样式。 |
| void OH_Drawing_CanvasDetachPen (OH_Drawing_Canvas*) | 用于去除画布中的画笔，执行后后画布将不去绘制图形形状的轮廓，恢复到默认的填充效果。 |
| void OH_Drawing_PenDestroy (OH_Drawing_Pen*) | 用于销毁画笔对象并回收该对象占有的内存。 |
开发步骤
1.  使用OH_Drawing_PenCreate()接口创建画笔Pen对象。
2.  使用OH_Drawing_CanvasAttachPen()接口给Canvas画布设置画笔。接口接受两个参数，一个是画布对象Canvas，请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）；另一个是要画设置的画笔对象。画布将会使用设置的画笔样式和颜色等绘制图形轮廓。
3.  使用画笔设置具体的描边效果（可选以下的一个或者多个效果）。 可使用OH_Drawing_PenSetColor()接口设置画笔颜色，对应为绘制图形轮廓时使用的颜色。 color是一个32位（ARGB）的变量，例如0xffff0000。 可使用OH_Drawing_PenSetWidth()接口设置画笔的线宽。 width指线宽的像素值。 可使用OH_Drawing_PenSetAntiAlias()接口设置画笔抗锯齿，以使图形绘制边缘更平滑。 可使用OH_Drawing_PenSetCap()接口设置画笔线帽样式。 OH_Drawing_PenLineCapStyle线帽样式可选分类对应如下： 可使用OH_Drawing_PenSetJoin()接口设置画笔转角样式。 OH_Drawing_PenLineJoinStyle转角样式可选分类对应如下：
4.  可使用OH_Drawing_PenSetColor()接口设置画笔颜色，对应为绘制图形轮廓时使用的颜色。 color是一个32位（ARGB）的变量，例如0xffff0000。
5.  可使用OH_Drawing_PenSetWidth()接口设置画笔的线宽。 width指线宽的像素值。
6.  可使用OH_Drawing_PenSetAntiAlias()接口设置画笔抗锯齿，以使图形绘制边缘更平滑。
7.  可使用OH_Drawing_PenSetCap()接口设置画笔线帽样式。 OH_Drawing_PenLineCapStyle线帽样式可选分类对应如下：
8.  可使用OH_Drawing_PenSetJoin()接口设置画笔转角样式。 OH_Drawing_PenLineJoinStyle转角样式可选分类对应如下：
9.  按需绘制图元，具体可见图元绘制一节。
10.  当不需要描边效果时，可以使用OH_Drawing_CanvasDetachPen()去除。入参为画布对象Canvas，请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）。
11.  当不再需要画笔进行描边时，请及时使用OH_Drawing_PenDestroy()接口销毁Pen对象。
-  可使用OH_Drawing_PenSetColor()接口设置画笔颜色，对应为绘制图形轮廓时使用的颜色。 color是一个32位（ARGB）的变量，例如0xffff0000。
-  可使用OH_Drawing_PenSetWidth()接口设置画笔的线宽。 width指线宽的像素值。
-  可使用OH_Drawing_PenSetAntiAlias()接口设置画笔抗锯齿，以使图形绘制边缘更平滑。
-  可使用OH_Drawing_PenSetCap()接口设置画笔线帽样式。 OH_Drawing_PenLineCapStyle线帽样式可选分类对应如下：
-  可使用OH_Drawing_PenSetJoin()接口设置画笔转角样式。 OH_Drawing_PenLineJoinStyle转角样式可选分类对应如下：
| 线帽样式 | 说明 | 示意图 |
| --- | --- | --- |
| FLAT_CAP | 没有线帽样式，线条头尾端点处横切。 |  |
| SQUARE_CAP | 线帽的样式为方框，线条的头尾端点处多出一个方框，方框宽度和线段一样宽，高度是线段宽度的一半。 |  |
| ROUND_CAP | 线帽的样式为圆弧，线条的头尾端点处多出一个半圆弧，半圆的直径与线段宽度一致。 |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.00621822529314705867163221055016:50001231000000:2800:CDBA916BE79950D448FF9DE72D34CA34E127EC36302602187D8E59593C418BFC.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.84654048196278932031886037448566:50001231000000:2800:6E210F43219D23319A58C20CB2F791BD3AFA081754CEB346D17BB06C38CB8589.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.62607452663293760725618313225798:50001231000000:2800:5C410260566B4372ED8A0484A2D90C6B05477630F279205A748D19CCC970E455.jpg)
| 转角样式 | 说明 | 示意图 |
| --- | --- | --- |
| MITER_JOIN | 转角类型为尖角 |  |
| ROUND_JOIN | 转角类型为圆头 |  |
| BEVEL_JOIN | 转角类型为平头 |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.97926790319608085831310132101301:50001231000000:2800:95AAF22E40D18285EA9B5B406A3DC18D446B05EDE2FB4FE52EBA59A010E2965E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.45833673799356547773596613478915:50001231000000:2800:4DC52C1A3112221AF3AF01DA0BA2A5DACFAFA48111A7BED3E4416E40FF3FFAAC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.41742585859289228033041390418103:50001231000000:2800:BC6930D6E0912B0A14D1A65E96ED03066E8DDD81A7E9D5687838132E5B832BD0.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/primitive-drawing-V14
爬取时间: 2025-04-29 19:35:33
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/complex-drawing-effect-c-V14
爬取时间: 2025-04-29 19:35:45
来源: Huawei Developer
除了基础填充颜色、描边颜色和一些样式设置的绘制效果外，还支持通过画刷和画笔实现更多复杂的绘制效果。比如：
-  混合模式
-  路径效果，如虚线效果。
-  着色器效果，如线性渐变、径向渐变等。
-  滤波效果，如模糊效果等。
混合模式
混合模式可以用于画笔或画刷，它定义了如何将源像素（要绘制的内容）与目标像素（已存在于画布上的内容）进行组合。
可以使用OH_Drawing_BrushSetBlendMode()接口将混合模式应用于画刷中，使用OH_Drawing_PenSetBlendMode接口将混合模式应用于画笔中。这两个接口都需要接受一个参数OH_Drawing_BlendMode，即混合模式的类型，具体可参考BlendMode。
此处以使用画刷设置叠加混合模式为例（为了防止混合模式的效果被背景色干扰，示例中的canvas并未设置背景色，使用的是默认的黑色背景），关键示例和效果示意图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.55928481978050527484771436072971:50001231000000:2800:B1AB5908E711FB281CF425A1F6D466150D7D9C2B44AE5307BCA2F93183D35B90.png)
路径效果
路径效果如虚线效果，只用于画笔。
可使用OH_Drawing_CreateDashPathEffect()接口设置路径效果。接口接受3个参数，分别为：
-  浮点数数组intervals：表示虚线或者点线的间隔。
-  整数count：表示intervals数组中的元素数量。
-  浮点数phase：表示在intervals数组中的偏移量，即从数组的哪个位置开始应用虚线或点线效果。
此处以绘制矩形虚线路径效果为例，关键示例和效果示意图如下所示：
| 不设置虚线路径效果的示意图 | 设置虚线效果的示意图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.92381453047000542004663233314920:50001231000000:2800:486D774B0961684C4F0518914859D1616CE453BC743645D5C80C8D47BA4F01CE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.40904308804198876836272859000324:50001231000000:2800:17290B38AB357336D2A172CCB278FA01BF74663014E1AF4066D65C87009DFD9B.png)
着色器效果
着色器效果基于画刷或画笔实现，可使用OH_Drawing_BrushSetShaderEffect()接口设置画刷的着色器效果，或者使用 OH_Drawing_PenSetShaderEffect接口设置画笔的着色器效果。当前支持不同的着色器效果，如线性渐变着色器效果、径向渐变着色器效果、扇形渐变着色器效果。
着色器相关接口和具体参数的说明请见drawing_shader_effect。
线性渐变着色器效果
可使用OH_Drawing_ShaderEffectCreateLinearGradient()接口创建想要设置的线性渐变着色器效果。接口接受6个参数，分别为开始点、结束点、颜色数组、相对位置数组、颜色数组的大小以及平铺模式。
-  开始点和结束点用来确定渐变方向。
-  颜色数组用于存储渐变使用到的颜色。
-  相对位置数组则用于确定每种颜色在渐变中的相对位置，如果相对位置为空，颜色将会被均匀地分布在开始点和结束点之间。
-  平铺模式用于确定如何在渐变区域之外继续渐变效果，平铺模式分为以下4类：
此处以绘制矩形并使用画刷设置线性渐变着色器效果为例，关键示例和效果示意图如下所示：
此例绘制的具有线性渐变着色器效果的矩形如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.49370205483504535161648752329880:50001231000000:2800:956F29E11CC0369747311E70D531228011058BA3F105BD4ED5F322DC23A7D405.png)
径向渐变着色器效果
可使用OH_Drawing_ShaderEffectCreateRadialGradient()接口创建想要设置的径向渐变着色器效果。接口接受6个参数，分别为圆心坐标（centerPt）、半径（radius）、颜色数组（colors）、相对位置数组（pos）、颜色和位置的数量（size）以及平铺模式（OH_Drawing_TileMode）。
其实现方式与线性渐变着色器类似，不同的是，径向渐变是由圆心开始向外径向渐变的。
此处以绘制矩形并使用画刷设置径向渐变着色器效果为例，关键示例和效果示意图如下所示：
此例绘制的具有径向渐变着色器效果的矩形如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.73831412244898234939508438213683:50001231000000:2800:C3A3ED4FEC9A9736AB828315021535E7E38CF75258382F9071BE2D835DCFCF0D.png)
扇形渐变着色器效果
可使用OH_Drawing_ShaderEffectCreateSweepGradient()接口创建想要设置的扇形渐变着色器效果。接口接受5个参数，分别是中心点、颜色数组、相对位置数组、颜色和相对位置的数量以及平铺模式。
其实现方式也与线性渐变着色器类似，不同的是，扇形渐变是在围绕中心点旋转的过程中渐变。
此处以绘制矩形并使用画刷设置扇形渐变着色器效果为例，关键示例和效果示意图如下所示：
此例绘制的具有扇形渐变着色器效果的矩形如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.15208266064348463574230968023488:50001231000000:2800:7EB80711DA2229F43D02E5CF4BF8A2F2914C429C7353A6DE001FDD208FE4E0F5.png)
滤波器效果
滤波器效果可基于画刷或画笔实现。可使用OH_Drawing_PenSetFilter()接口设置画笔的滤波器效果，或者使用OH_Drawing_BrushSetFilter()接口设置画刷的滤波器效果。当前支持不同的滤波器效果，比如图像滤波器、颜色滤波器、蒙版滤波器。
滤波器相关接口和具体参数的说明请见drawing_filter.h。
颜色滤波器效果
颜色滤波器可基于画笔或画刷实现，颜色滤波器的相关接口和具体参数的说明请见drawing_color_filter.h。
目前可实现多种颜色滤波器，包括如下：
-  具有混合模式的颜色滤波器。
-  具有5x4颜色矩阵的颜色滤波器。
-  将SRGB的伽玛曲线应用到RGB颜色通道的颜色滤波器。
-  将RGB颜色通道应用于SRGB的伽玛曲线的颜色滤波器。
-  将其输入的亮度值乘以透明度通道， 并将红色、绿色和蓝色通道设置为零的颜色滤波器。
-  由两个颜色滤波器组合而成的颜色滤波器。
此处以具有5x4颜色矩阵的颜色滤波器为例。
可使用OH_Drawing_ColorFilterCreateMatrix()接口创建具有5x4颜色矩阵的颜色滤波器。接口接受1个参数，表示为颜色矩阵，它是一个长度为20的浮点数数组。数组格式如下：
[ a0, a1, a2, a3, a4 ]
[ b0, b1, b2, b3, b4 ]
[ c0, c1, c2, c3, c4 ]
[ d0, d1, d2, d3, d4 ]
对于每个原始的像素颜色色值（R, G, B, A），变换后的色值（R', G', B', A'）计算公式为：
R' = a0*R + a1*G + a2*B + a3*A + a4
G' = b0*R + b1*G + b2*B + b3*A + b4
B' = c0*R + c1*G + c2*B + c3*A + c4
A' = d0*R + d1*G + d2*B + d3*A + d4
此处以绘制矩形并使用画刷设置具有5x4颜色矩阵的颜色滤波器效果为例，关键示例和效果示意图如下所示：
| 不设置颜色滤波器效果的示意图 | 设置5x4颜色矩阵的颜色滤波器效果的示意图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.72883214651147791996597290986202:50001231000000:2800:8A76358462462098641028FDB9896EF3E6E5B3FB93AAB8F8013FE5C8BDB26A90.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.80578175783436530643544749926435:50001231000000:2800:C24E7380DC44AD5A8250FE3C8730C7A189D121E2DBCA1261367FACAFC07F5468.png)
图像滤波器效果
图像滤波器可基于画笔或画刷来实现，图像滤波器的相关接口和具体参数的说明请见drawing_image_filter.h。
目前只支持两种图像滤波器：
-  基于颜色滤波器的图像滤波器。 可通过OH_Drawing_ImageFilterCreateFromColorFilter()接口实现，接口接受2个参数，颜色滤波器colorFilter和图像滤波器input，即把颜色滤波器的效果叠加到图像滤波器input上，input可为空，input为空则只添加颜色滤波器效果。
-  具有模糊效果的图像滤波器。 可通过OH_Drawing_ImageFilterCreateBlur()接口实现，接口接受4个参数，分别为X轴上的模糊标准差、Y轴上的模糊标准差、平铺模式和图像滤波器（input）。 最终效果即为在输入的图像滤波器（input）的基础上进行模糊化处理，即滤波器效果可叠加，input可为空，input为空则只添加模糊效果。
此处以绘制矩形并使用画笔添加模糊效果的图像滤波器效果为例，关键示例和效果示意图如下所示：
| 不设置图像滤波器效果的示意图 | 设置图像滤波器效果的示意图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165915.12613551913108794084299928566093:50001231000000:2800:BEF73C5D24AA61D1099FEE4E5EA11707C9F0E746BE29E14B6B146E10F45E9696.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.22090270629793691176811178991419:50001231000000:2800:FC05070BDDDF82ED1C4B1E8908534E1B3C75BB5011F6D59EF85CD4F8B6329C7F.png)
蒙版滤波器效果
蒙版滤波器的模糊效果仅对透明度和形状边缘进行模糊处理，相对于图像滤波器的模糊效果来说计算成本更低。
蒙版滤波器可基于画笔或画刷实现，蒙版滤波器的相关接口和具体参数的说明请见drawing_mask_filter.h。
可使用H_Drawing_MaskFilterCreateBlur()接口创建想要设置具有模糊效果的蒙版滤波器。接口接受3个参数，分别为：
-  blurType：用于指定要应用的模糊类型，详细分类请参考BlurType。
-  sigma：用于指定要应用的高斯模糊的标准差，标准差必须大于0。
-  respectCTM：指定模糊的标准差是否会被CTM（coordinate transformation matrix，坐标变换矩阵）修改，默认为true，表示会被对应修改。
此处以绘制矩形并使用画笔设置蒙版滤波器效果为例，关键示例和效果示意图如下所示：
| 不设置蒙版滤波器效果的示意图 | 设置蒙版滤波器效果的示意图 |
| --- | --- |
|  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.54526884407880677639430812236061:50001231000000:2800:5B0E2AADC4DE0DEBB90A6916E96ED2A5EB3E1C4F0D48774B1A08B2999665586E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.27567840953524584343174674243421:50001231000000:2800:A35523B6E95E007A52E2B54C47065D26B2B2A12EFA953A2167FF71F455B69C0E.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/primitive-drawing-overview-V14
爬取时间: 2025-04-29 19:35:47
来源: Huawei Developer
无论多复杂的图形，都是由基础的图元组合而来。Canvas画布提供了丰富的图元绘制功能，可以满足各种基础图元的绘制需求。本节介绍了几何形状绘制（点、圆、矩形等），图片绘制和字块绘制，并提供了示例代码，开发者可以在此基础上实现需要的UI效果。
图元绘制是图形绘制的最后一步，图元绘制之前需要先创建Canvas并按需设置必要的绘制效果。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/geometric-shape-drawing-arkts-V14
爬取时间: 2025-04-29 19:36:00
来源: Huawei Developer
场景介绍
当前支持绘制的几何形状，主要包括以下几种：
-  点
-  圆弧
-  圆
-  路径
-  区域
-  矩形
-  圆角矩形
大部分的几何形状均可以选择使用画笔或者使用画刷来实现绘制，其中点的绘制只能使用画笔。
接口说明
几何形状绘制的常用接口如下表所示，详细的使用和参数说明请见drawing.Canvas。
| 接口 | 描述 |
| --- | --- |
| drawPoint(x: number, y: number): void | 用于画一个点。 |
| drawArc(arc: common2D.Rect, startAngle: number, sweepAngle: number): void | 用于画一个弧。 |
| drawCircle(x: number, y: number, radius: number): void | 用于画一个圆形。 |
| drawPath(path: Path): void | 用于画一个自定义路径。 |
| drawRegion(region: Region): void | 用于画一块区域。 |
| drawRect(left: number, top: number, right: number, bottom: number): void | 用于画一个矩形。 |
| drawRoundRect(roundRect: RoundRect): void | 用于画一个圆角矩形。 |
绘制点
点只能基于画笔在画布上进行绘制，通过使用drawPoint()接口绘制点。绘制点需要接受两个参数，分别为需要绘制的点的x坐标和y坐标。
简单示例如下：
```typescript
// 设置画笔
let pen = new drawing.Pen();
// 设置颜色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
// 设置线宽
pen.setStrokeWidth(40);
// 设置画笔描边效果
canvas.attachPen(pen);
// 绘制5个点
canvas.drawPoint(200, 200);
canvas.drawPoint(400, 400);
canvas.drawPoint(600, 600);
canvas.drawPoint(800, 800);
canvas.drawPoint(1000, 1000);
// 去除描边效果
canvas.detachPen();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.02471092744693931851476241532308:50001231000000:2800:EF7B57BF5448D53598C60A738B54780C3EDD85D4F84760C4996A327907CA4BE1.jpg)
绘制圆弧
可以使用画笔或画刷在画布上进行圆弧的绘制，通过使用drawArc()接口绘制圆弧。
绘制圆弧需要一个矩形（common2D.Rect），以矩形的边为轮廓进行绘制，还需要两个参数，分别表示弧形的起始角度（startAngle）和扫描角度（sweepAngle）。
此处以使用画笔绘制圆弧为例，简单示例如下：
```typescript
// 创建画笔
let pen = new drawing.Pen();
// 设置颜色
pen.setColor({ alpha: 0xFF, red: 0xFF, green: 0x00, blue: 0x00 });
// 设置线宽
pen.setStrokeWidth(20);
// 设置画笔描边效果
canvas.attachPen(pen);
// 创建矩形对象
const rect: common2D.Rect = {left:100, top:200, right:1000, bottom:600};
// 绘制矩形
canvas.drawArc(rect, 0, 180);
// 去除描边效果
canvas.detachPen();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.04600972823915703002425891282805:50001231000000:2800:FFFC4904FAE0C9BD964C5A5BDD491FC99B4F782455494F63A929B33553AF2508.png)
绘制圆
可以使用画笔或画刷在画布上进行圆的绘制，通过使用drawCircle()接口绘制圆。
绘制圆需要圆心点的x坐标和y坐标，以及圆半径（radius）。
此处以使用画笔绘制圆为例，简单示例如下：
```typescript
// 创建画笔
let pen = new drawing.Pen();
// 设置颜色
pen.setColor({ alpha: 0xFF, red: 0xFF, green: 0x00, blue: 0x00 });
// 设置线宽
pen.setStrokeWidth(20);
// 设置画笔描边效果
canvas.attachPen(pen);
// 绘制圆
canvas.drawCircle(630, 630, 500);
// 去除描边效果
canvas.detachPen();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.88031966958795809597108210699667:50001231000000:2800:E3CED05768256424EF449C0B5D391E431539917CCE03DE41310029CAE5D8D665.jpg)
绘制路径
可以使用画笔或画刷在画布上进行路径的绘制，路径具体可以用于绘制直线、弧线、贝塞尔曲线等，也可以通过路径组合的方式组成其他复杂的形状。
绘制路径的相关接口和实现如下，详细的使用和参数说明请见Path。常用的接口如下：
1.  使用new drawing.Path()可以创建一个路径对象。
2.  使用moveTo()接口可以设置自定义路径的起始点位置。
3.  使用lineTo()接口可以添加一条从起始点或路径的最后点位置（若路径没有内容则默认为(0,0)）到目标点位置的线段。
此处以使用画笔和画刷绘制五角星为例，简单示例如下：
```typescript
let height_ = 1800;
let width_ = 1800;
let len = height_ / 4;
let aX = width_ / 3;
let aY = height_ / 6;
let dX = aX - len * Math.sin(18.0);
let dY = aY + len * Math.cos(18.0);
let cX = aX + len * Math.sin(18.0);
let cY = dY;
let bX = aX + (len / 2.0);
let bY = aY + Math.sqrt((cX - dX) * (cX - dX) + (len / 2.0) * (len / 2.0));
let eX = aX - (len / 2.0);
let eY = bY;
// 创建一个path对象，然后使用接口连接成一个五角星形状
let path = new drawing.Path();
// 指定path的起始位置
path.moveTo(aX, aY);
// 用直线连接到目标点
path.lineTo(bX, bY);
path.lineTo(cX, cY);
path.lineTo(dX, dY);
path.lineTo(eX, eY);
// 闭合形状，path绘制完毕
path.close()
// 创建画笔对象
let pen = new drawing.Pen();
// 设置抗锯齿
pen.setAntiAlias(true);
// 设置描边颜色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
// 设置线宽
pen.setStrokeWidth(10.0);
// 设置画笔描边效果
canvas.attachPen(pen);
// 创建画刷
let brush = new drawing.Brush();
// 设置填充颜色
brush.setColor(0xFF, 0x00, 0xFF, 0x00);
// 设置画刷填充效果
canvas.attachBrush(brush);
// 绘制路径
canvas.drawPath(path);
// 去除填充效果
canvas.detachBrush();
// 去除描边效果
canvas.detachPen();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.32017807764769828685760688146491:50001231000000:2800:43685372C29F9A44122C8E227879449D44A2740139E0F2DB11F6A42D480EFB9E.jpg)
绘制区域
区域不是一个特定的形状，可以设置为指定的矩形或路径，也可以对两个区域进行组合操作。可以使用画笔或画刷对区域进行绘制。详细的API说明请参考Region。
目前支持设置矩形区域和路径区域，分别通过setRect()接口和setPath()接口来设置。
此处以使用画刷绘制矩形的组合区域为例，示例如下：
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置颜色
brush.setColor(0xFF, 0xFF,  0x00, 0x00);
// 设置画刷填充效果
canvas.attachBrush(brush);
// 创建左上角的region1
let region1 = new drawing.Region();
region1.setRect(100, 100, 600, 600);
// 创建右下角的region2
let region2 = new drawing.Region();
region2.setRect(300, 300, 900, 900);
// 将两个区域以XOR的方式组合
region1.op(region2, drawing.RegionOp.XOR);
// 绘制区域
canvas.drawRegion(region1);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.68469558858641663915664760926095:50001231000000:2800:8FBA310096AD70D0F5F65827215114AEA8655FD6C4E9CF70B17A71A9E519C576.jpg)
绘制矩形
可以使用画笔或画刷在画布上进行矩形的绘制。使用drawRect()接口绘制矩形。接口需要传入四个浮点数，分别表示矩形的左、上、右、下四个位置的坐标，连接这4个坐标形成一个矩形。
此处以使用画刷绘制矩形为例，简单示例如下：
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置颜色
brush.setColor(0xFF, 0xFF,  0x00, 0x00);
// 设置画刷填充效果
canvas.attachBrush(brush);
// 绘制矩形
canvas.drawRect(200, 200, 1000, 700);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.34403283362652707978783574120908:50001231000000:2800:515E13FCCDFD59A7DBD66A8E2B1B9FBC83A7D383E4F2CA93A6A68AF3043F2869.png)
绘制圆角矩形
可以使用画笔或画刷在画布上进行圆角矩形的绘制。使用drawRoundRect()接口绘制圆角矩形。接口接受1个入参roundRect，对应为圆角矩形对象。
圆角矩形对象通过new drawing.RoundRect()接口构造，构造函数接受3个参数，分别为：
-  common2D.Rect（矩形对象），圆角矩形是在该矩形的基础上切圆角形成。
-  x轴上的圆角半径。
-  y轴上的圆角半径。
此处以使用画刷绘制圆角矩形为例，简单示例代码如下：
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置颜色
brush.setColor(0xFF, 0xFF, 0x00, 0x00);
// 设置画刷填充效果
canvas.attachBrush(brush);
// 创建矩形对象
let rect: common2D.Rect = { left: 200, top: 200, right: 1000, bottom: 700 };
// 创建圆角矩形对象
let rrect = new drawing.RoundRect(rect, 30, 30);
// 绘制圆角矩形
canvas.drawRoundRect(rrect);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.43234402895526100927236988598001:50001231000000:2800:1CA68CE3CC5E23C2CC4F6B9617308EE6BE2C197F9680EFB32A4A334995515E9E.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/pixelmap-drawing-arkts-V14
爬取时间: 2025-04-29 19:36:13
来源: Huawei Developer
位图是一种用于在内存中存储和表示图像的数据结构，它是一个未经过压缩的像素集合，而JPEG或PNG等格式的图片是压缩格式的，两者并不相同。如果需要将JPEG或PNG绘制到屏幕上，需要先解码成位图格式，具体可参考图片处理服务（Image Kit）图片解码相关章节。
目前Drawing（ArkTS）中位图绘制需要依赖PixelMap，它可以用于读取或写入图像数据以及获取图像信息。详细的API介绍请参考PixelMap。
1.  创建PixelMap。 有多个API接口可以创建PixelMap，下文以createPixelMapSync()为例。更多创建方式和接口请见@ohos.multimedia.image (图片处理)模块。 createPixelMapSync()函数接受两个参数，第一个参数为图像像素数据的缓冲区，用于初始化PixelMap的像素。第二个参数为创建像素的属性，包括透明度、尺寸、缩略值、像素格式和是否可编辑。
```typescript
// 图片宽高
let width = 600;
let height = 400;
// 字节长度，RGBA_8888每个像素占4字节
let bytelength = width * height * 4;
const color: ArrayBuffer = new ArrayBuffer(bytelength);
let bufferArr = new Uint8Array(color);
for (let i = 0; i < bufferArr.length; i += 4) {
// 遍历并编辑每个像素，从而形成红绿蓝相间的条纹
bufferArr[i] = 0x00;
bufferArr[i+1] = 0x00;
bufferArr[i+2] = 0x00;
bufferArr[i+3] = 0xFF;
let n = Math.floor(i / 80) % 3;
if (n == 0) {
bufferArr[i] = 0xFF;
} else if (n == 1) {
bufferArr[i+1] = 0xFF;
} else {
bufferArr[i+2] = 0xFF;
}
}
// 设置像素属性
let opts: image.InitializationOptions = { editable: true, pixelFormat: image.PixelMapFormat.RGBA_8888, size: { height: height, width: width }}
// 创建PixelMap
let pixelMap : image.PixelMap = image.createPixelMapSync(color, opts);
```
2.  （可选）编辑PixelMap中的像素。如果没有编辑像素的需求，此步骤可以省略。 有多个API接口可以编辑PixelMap中的像素，下文以writePixelsSync()为例。更多方式和接口的使用可见PixelMap。
```typescript
// 设置编辑区域的宽高
let inner_width = 400;
let inner_height = 200;
// 编辑区域的字节长度，RGBA_8888每个像素占4字节
let inner_bytelength = inner_width * inner_height * 4;
const inner_color: ArrayBuffer = new ArrayBuffer(inner_bytelength);
let inner_bufferArr = new Uint8Array(inner_color);
for (let i = 0; i < inner_bufferArr.length; i += 4) {
// 编辑区域的像素都设置为黑白相间条纹
let n = Math.floor(i / 80) % 2;
if (n == 0) {
inner_bufferArr[i] = 0x00;
inner_bufferArr[i+1] = 0x00;
inner_bufferArr[i+2] = 0x00;
} else {
inner_bufferArr[i] = 0xFF;
inner_bufferArr[i+1] = 0xFF;
inner_bufferArr[i+2] = 0xFF;
}
inner_bufferArr[i+3] = 0xFF;
}
// 设置编辑区域的像素、宽高、偏移量等
const area: image.PositionArea = {
pixels: inner_color,
offset: 0,
stride: inner_width * 4,
region: { size: { height: inner_height, width: inner_width }, x: 100, y: 100 }
};
// 编辑位图，形成中间的黑白相间条纹
pixelMap.writePixelsSync(area);
```
3.  绘制PixelMap。 绘制PixelMap时需要通过Canva相关接口绘制位图，下文以drawImage()为例。更多方式和接口的使用请见drawing.Canvas。 drawImage()函数接受4个参数，第一个就是上文中创建的PixelMap，第二个是绘制图片位置的左上角x轴坐标，第三个是左上角y轴坐标，第四个为采样选项对象，默认为不使用任何参数构造的原始采样选项对象。 绘制效果如下：
```typescript
canvas.drawImage(pixelMap, 300, 300);
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.44790371942951826889421030541367:50001231000000:2800:E46C0340BDF8452E1CDC4FF231280211C54789DC82DCDB3848BEB77243A24399.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/geometric-shape-drawing-arkts-V14
爬取时间: 2025-04-29 19:36:26
来源: Huawei Developer
场景介绍
当前支持绘制的几何形状，主要包括以下几种：
-  点
-  圆弧
-  圆
-  路径
-  区域
-  矩形
-  圆角矩形
大部分的几何形状均可以选择使用画笔或者使用画刷来实现绘制，其中点的绘制只能使用画笔。
接口说明
几何形状绘制的常用接口如下表所示，详细的使用和参数说明请见drawing.Canvas。
| 接口 | 描述 |
| --- | --- |
| drawPoint(x: number, y: number): void | 用于画一个点。 |
| drawArc(arc: common2D.Rect, startAngle: number, sweepAngle: number): void | 用于画一个弧。 |
| drawCircle(x: number, y: number, radius: number): void | 用于画一个圆形。 |
| drawPath(path: Path): void | 用于画一个自定义路径。 |
| drawRegion(region: Region): void | 用于画一块区域。 |
| drawRect(left: number, top: number, right: number, bottom: number): void | 用于画一个矩形。 |
| drawRoundRect(roundRect: RoundRect): void | 用于画一个圆角矩形。 |
绘制点
点只能基于画笔在画布上进行绘制，通过使用drawPoint()接口绘制点。绘制点需要接受两个参数，分别为需要绘制的点的x坐标和y坐标。
简单示例如下：
```typescript
// 设置画笔
let pen = new drawing.Pen();
// 设置颜色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
// 设置线宽
pen.setStrokeWidth(40);
// 设置画笔描边效果
canvas.attachPen(pen);
// 绘制5个点
canvas.drawPoint(200, 200);
canvas.drawPoint(400, 400);
canvas.drawPoint(600, 600);
canvas.drawPoint(800, 800);
canvas.drawPoint(1000, 1000);
// 去除描边效果
canvas.detachPen();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.02471092744693931851476241532308:50001231000000:2800:EF7B57BF5448D53598C60A738B54780C3EDD85D4F84760C4996A327907CA4BE1.jpg)
绘制圆弧
可以使用画笔或画刷在画布上进行圆弧的绘制，通过使用drawArc()接口绘制圆弧。
绘制圆弧需要一个矩形（common2D.Rect），以矩形的边为轮廓进行绘制，还需要两个参数，分别表示弧形的起始角度（startAngle）和扫描角度（sweepAngle）。
此处以使用画笔绘制圆弧为例，简单示例如下：
```typescript
// 创建画笔
let pen = new drawing.Pen();
// 设置颜色
pen.setColor({ alpha: 0xFF, red: 0xFF, green: 0x00, blue: 0x00 });
// 设置线宽
pen.setStrokeWidth(20);
// 设置画笔描边效果
canvas.attachPen(pen);
// 创建矩形对象
const rect: common2D.Rect = {left:100, top:200, right:1000, bottom:600};
// 绘制矩形
canvas.drawArc(rect, 0, 180);
// 去除描边效果
canvas.detachPen();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.04600972823915703002425891282805:50001231000000:2800:FFFC4904FAE0C9BD964C5A5BDD491FC99B4F782455494F63A929B33553AF2508.png)
绘制圆
可以使用画笔或画刷在画布上进行圆的绘制，通过使用drawCircle()接口绘制圆。
绘制圆需要圆心点的x坐标和y坐标，以及圆半径（radius）。
此处以使用画笔绘制圆为例，简单示例如下：
```typescript
// 创建画笔
let pen = new drawing.Pen();
// 设置颜色
pen.setColor({ alpha: 0xFF, red: 0xFF, green: 0x00, blue: 0x00 });
// 设置线宽
pen.setStrokeWidth(20);
// 设置画笔描边效果
canvas.attachPen(pen);
// 绘制圆
canvas.drawCircle(630, 630, 500);
// 去除描边效果
canvas.detachPen();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.88031966958795809597108210699667:50001231000000:2800:E3CED05768256424EF449C0B5D391E431539917CCE03DE41310029CAE5D8D665.jpg)
绘制路径
可以使用画笔或画刷在画布上进行路径的绘制，路径具体可以用于绘制直线、弧线、贝塞尔曲线等，也可以通过路径组合的方式组成其他复杂的形状。
绘制路径的相关接口和实现如下，详细的使用和参数说明请见Path。常用的接口如下：
1.  使用new drawing.Path()可以创建一个路径对象。
2.  使用moveTo()接口可以设置自定义路径的起始点位置。
3.  使用lineTo()接口可以添加一条从起始点或路径的最后点位置（若路径没有内容则默认为(0,0)）到目标点位置的线段。
此处以使用画笔和画刷绘制五角星为例，简单示例如下：
```typescript
let height_ = 1800;
let width_ = 1800;
let len = height_ / 4;
let aX = width_ / 3;
let aY = height_ / 6;
let dX = aX - len * Math.sin(18.0);
let dY = aY + len * Math.cos(18.0);
let cX = aX + len * Math.sin(18.0);
let cY = dY;
let bX = aX + (len / 2.0);
let bY = aY + Math.sqrt((cX - dX) * (cX - dX) + (len / 2.0) * (len / 2.0));
let eX = aX - (len / 2.0);
let eY = bY;
// 创建一个path对象，然后使用接口连接成一个五角星形状
let path = new drawing.Path();
// 指定path的起始位置
path.moveTo(aX, aY);
// 用直线连接到目标点
path.lineTo(bX, bY);
path.lineTo(cX, cY);
path.lineTo(dX, dY);
path.lineTo(eX, eY);
// 闭合形状，path绘制完毕
path.close()
// 创建画笔对象
let pen = new drawing.Pen();
// 设置抗锯齿
pen.setAntiAlias(true);
// 设置描边颜色
pen.setColor(0xFF, 0xFF, 0x00, 0x00);
// 设置线宽
pen.setStrokeWidth(10.0);
// 设置画笔描边效果
canvas.attachPen(pen);
// 创建画刷
let brush = new drawing.Brush();
// 设置填充颜色
brush.setColor(0xFF, 0x00, 0xFF, 0x00);
// 设置画刷填充效果
canvas.attachBrush(brush);
// 绘制路径
canvas.drawPath(path);
// 去除填充效果
canvas.detachBrush();
// 去除描边效果
canvas.detachPen();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.32017807764769828685760688146491:50001231000000:2800:43685372C29F9A44122C8E227879449D44A2740139E0F2DB11F6A42D480EFB9E.jpg)
绘制区域
区域不是一个特定的形状，可以设置为指定的矩形或路径，也可以对两个区域进行组合操作。可以使用画笔或画刷对区域进行绘制。详细的API说明请参考Region。
目前支持设置矩形区域和路径区域，分别通过setRect()接口和setPath()接口来设置。
此处以使用画刷绘制矩形的组合区域为例，示例如下：
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置颜色
brush.setColor(0xFF, 0xFF,  0x00, 0x00);
// 设置画刷填充效果
canvas.attachBrush(brush);
// 创建左上角的region1
let region1 = new drawing.Region();
region1.setRect(100, 100, 600, 600);
// 创建右下角的region2
let region2 = new drawing.Region();
region2.setRect(300, 300, 900, 900);
// 将两个区域以XOR的方式组合
region1.op(region2, drawing.RegionOp.XOR);
// 绘制区域
canvas.drawRegion(region1);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.68469558858641663915664760926095:50001231000000:2800:8FBA310096AD70D0F5F65827215114AEA8655FD6C4E9CF70B17A71A9E519C576.jpg)
绘制矩形
可以使用画笔或画刷在画布上进行矩形的绘制。使用drawRect()接口绘制矩形。接口需要传入四个浮点数，分别表示矩形的左、上、右、下四个位置的坐标，连接这4个坐标形成一个矩形。
此处以使用画刷绘制矩形为例，简单示例如下：
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置颜色
brush.setColor(0xFF, 0xFF,  0x00, 0x00);
// 设置画刷填充效果
canvas.attachBrush(brush);
// 绘制矩形
canvas.drawRect(200, 200, 1000, 700);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.34403283362652707978783574120908:50001231000000:2800:515E13FCCDFD59A7DBD66A8E2B1B9FBC83A7D383E4F2CA93A6A68AF3043F2869.png)
绘制圆角矩形
可以使用画笔或画刷在画布上进行圆角矩形的绘制。使用drawRoundRect()接口绘制圆角矩形。接口接受1个入参roundRect，对应为圆角矩形对象。
圆角矩形对象通过new drawing.RoundRect()接口构造，构造函数接受3个参数，分别为：
-  common2D.Rect（矩形对象），圆角矩形是在该矩形的基础上切圆角形成。
-  x轴上的圆角半径。
-  y轴上的圆角半径。
此处以使用画刷绘制圆角矩形为例，简单示例代码如下：
```typescript
// 创建画刷
let brush = new drawing.Brush();
// 设置颜色
brush.setColor(0xFF, 0xFF, 0x00, 0x00);
// 设置画刷填充效果
canvas.attachBrush(brush);
// 创建矩形对象
let rect: common2D.Rect = { left: 200, top: 200, right: 1000, bottom: 700 };
// 创建圆角矩形对象
let rrect = new drawing.RoundRect(rect, 30, 30);
// 绘制圆角矩形
canvas.drawRoundRect(rrect);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165916.43234402895526100927236988598001:50001231000000:2800:1CA68CE3CC5E23C2CC4F6B9617308EE6BE2C197F9680EFB32A4A334995515E9E.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/textblock-drawing-arkts-V14
爬取时间: 2025-04-29 19:36:27
来源: Huawei Developer
场景介绍
字块（TextBlob）是指文本的集合。无论是单个的文字还是大块的文本，都可以通过字块来绘制。
本节聚焦于文字的绘制效果，除了基本的字块绘制之外，还可以给文字添加各种绘制效果。常见的字块绘制场景包括文字描边、文字渐变等，更多效果请见绘制效果。
基本字块绘制
Canvas通过drawTextBlob()来绘制字块。函数接受三个参数：TextBlob字块对象，以及文字基线左端点的x坐标和y坐标。
画布Canvas对象具体可见画布的获取与绘制结果的显示（ArkTS）。
字块对象可以通过多种方式创建得到，详细的字块创建方式和接口使用请参考TextBlob。
此处以使用makeFromString()接口创建字块为例，接口接受3个参数，分别为：
-  需要显示的字符串text。
-  font字型对象。其中font用于设置和获取字体的各种属性，如字体大小、文本样式、字体对齐方式、字体渲染方式、字体描边方式等，详细的API介绍请参考Font。
-  文本编码方式。当前支持的文本编码方式如下：
基本效果的示例代码和效果图如下：
```typescript
// 创建字型对象
const font = new drawing.Font();
// 设置字体大小
font.setSize(100);
// 创建字块对象
const textBlob = drawing.TextBlob.makeFromString("Hello world", font, drawing.TextEncoding.TEXT_ENCODING_UTF8);
// 绘制字块
canvas.drawTextBlob(textBlob, 200, 300);
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.62622135717024545335307045748370:50001231000000:2800:099C02DE99C3BBA8FDAAC6CED1D1F0189EAEB8D3242C49FA4B8411E7ADB5A975.jpg)
文字描边
基于基本的字块绘制，还可以通过画笔实现文字描边效果，描边效果的更多介绍请参考描边效果。
文字描边的简要示例和示意图如下：
```typescript
// 创建画笔
let pen = new drawing.Pen();
// 设置抗锯齿
pen.setAntiAlias(true);
// 设置描边线宽
pen.setStrokeWidth(3.0);
// 设置描边颜色
pen.setColor(0xFF, 0xFF,  0x00, 0x00);
// 创建字型对象
const font = new drawing.Font();
// 设置字体大小
font.setSize(100);
// 添加画笔描边效果
canvas.attachPen(pen);
// 创建字块对象
const textBlob = drawing.TextBlob.makeFromString("Hello world", font, drawing.TextEncoding.TEXT_ENCODING_UTF8);
// 绘制字块
canvas.drawTextBlob(textBlob, 200, 300);
// 去除描边效果
canvas.detachPen();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.72214813278711532308411694271570:50001231000000:2800:72D00AA41625ADEBEDB8459887639C76CD543D5DEB5B2889E9F998584B5BBDF4.jpg)
文字渐变
基于基本字块绘制，还可以通过着色器实现文字渐变的效果，着色器的更多介绍请参考着色器效果。
以下为文字添加了线性渐变着色器效果的简要示例和示意图：
```typescript
let startPt: common2D.Point = { x: 100, y: 100 };
let endPt: common2D.Point = { x: 900, y: 900 };
let colors = [0xFFFFFF00, 0xFFFF0000, 0xFF0000FF];
// 创建线性渐变着色器
let shaderEffect = drawing.ShaderEffect.createLinearGradient(startPt, endPt, colors, drawing.TileMode.CLAMP);
// 创建画刷
let brush = new drawing.Brush();
// 设置着色器
brush.setShaderEffect(shaderEffect);
// 添加画刷填充效果
canvas.attachBrush(brush);
// 创建字型
const font = new drawing.Font();
// 设置字体大小
font.setSize(200);
// 创建字块
const textBlob = drawing.TextBlob.makeFromString("Hello world", font, drawing.TextEncoding.TEXT_ENCODING_UTF8);
// 绘制字块
canvas.drawTextBlob(textBlob, 100, 300);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.35773408864359652088396805361358:50001231000000:2800:9F8D4EAE730F08CE7F7D3E8C964643AAE1B162BF6C049CF14762ADAEA7B98D69.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/geometric-shape-drawing-c-V14
爬取时间: 2025-04-29 19:36:40
来源: Huawei Developer
场景介绍
当前支持绘制的几何形状，主要包括以下几种：
-  点
-  圆弧
-  圆
-  路径
-  区域
-  矩形
-  圆角矩形
大部分的几何形状均可以选择使用画笔或者使用画刷来实现绘制，其中点的绘制只能使用画笔。
接口说明
几何形状绘制的常用接口如下表所示，详细的使用和参数说明请见drawing_canvas.h。
| 接口 | 描述 |
| --- | --- |
| OH_Drawing_Point* OH_Drawing_PointCreate (float x, float y) | 用于创建一个坐标点对象。 |
| OH_Drawing_ErrorCode OH_Drawing_CanvasDrawPoint (OH_Drawing_Canvas *canvas, const OH_Drawing_Point2D *point) | 用于画一个点。 |
| OH_Drawing_Rect* OH_Drawing_RectCreate (float left, float top, float right, float bottom) | 用于创建一个矩形对象。 |
| void OH_Drawing_CanvasDrawArc (OH_Drawing_Canvas*, const OH_Drawing_Rect*, float startAngle, float sweepAngle) | 用于画一个弧。 |
| void OH_Drawing_CanvasDrawCircle (OH_Drawing_Canvas*, const OH_Drawing_Point*, float radius) | 用于画一个圆形。 |
| OH_Drawing_Path* OH_Drawing_PathCreate (void) | 用于创建一个路径对象。 |
| void OH_Drawing_CanvasDrawPath (OH_Drawing_Canvas*, const OH_Drawing_Path*) | 用于画一个自定义路径。 |
| OH_Drawing_Region* OH_Drawing_RegionCreate (void) | 用于创建一个区域对象。 |
| void OH_Drawing_CanvasDrawRegion (OH_Drawing_Canvas*, const OH_Drawing_Region*) | 用于画一块区域。 |
| void OH_Drawing_CanvasDrawRect (OH_Drawing_Canvas*, const OH_Drawing_Rect*) | 用于画一个矩形。 |
| OH_Drawing_RoundRect* OH_Drawing_RoundRectCreate (const OH_Drawing_Rect*, float xRad, float yRad) | 用于创建一个圆角矩形对象。 |
| void OH_Drawing_CanvasDrawRoundRect (OH_Drawing_Canvas*, const OH_Drawing_RoundRect*) | 用于画一个圆角矩形。 |
绘制点
点只能基于画笔在画布上进行绘制，通过使用OH_Drawing_CanvasDrawPoint()接口绘制点。接口接受两个参数，一个是画布对象Canvas，请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）；另一个是要绘制的点的指针。
简单示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.51611071484765506853887548920225:50001231000000:2800:2A49E662354AA7605F98C52C215E1A46CFDDC6A4FEDDFBC8F4EDAD6B8DE23A3E.png)
绘制圆弧
可以使用画笔或画刷在画布上进行圆弧的绘制，通过使用OH_Drawing_CanvasDrawArc()接口绘制圆弧。使用接口需要传入4个参数，分别如下：
-  需要画布对象Canvas，请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）。
-  绘制圆弧还需要一个矩形，会以矩形的边为轮廓进行绘制。
-  需要一个浮点参数，表示弧形的起始角度。
-  需要另一个浮点参数，表示弧形的扫描角度。
此处以使用画笔绘制圆弧为例，简单示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.94584926007469533542195543736185:50001231000000:2800:2EEEE47EB75EFB0AEB42937764BE846718A9B39FAE30BFBD9A7AF1DC2E2AF15D.png)
绘制圆
可以使用画笔或画刷在画布上进行圆的绘制，通过使用OH_Drawing_CanvasDrawCircle()接口绘制圆。使用接口需要传入3个参数，分别如下：
-  需要画布对象Canvas，请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）。
-  绘制圆还需要一个指向圆心点对象的指针，会以此点为圆心进行绘制。
-  最后需要一个浮点参数，表示圆的半径。
此处以使用画笔绘制圆为例，简单示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.91346172784426918542679240277299:50001231000000:2800:9F36735765DA04499A73EEF0F025F6A4D1F2867ED93E84C9917C842CF6A27F27.png)
绘制路径
可以使用画笔或画刷在画布上进行路径的绘制，路径具体可以用于绘制直线、弧线、贝塞尔曲线等，也可以通过路径组合的方式组成其他复杂的形状。
绘制路径的相关接口和实现如下，详细的使用和参数说明请见drawing_path。常用的接口如下：
1.  使用OH_Drawing_PathCreate()接口可以创建一个路径对象。
2.  使用OH_Drawing_PathMoveTo()接口可以设置自定义路径的起始点位置。
3.  使用OH_Drawing_PathLineTo()接口可以添加一条从起始点或路径的最后点位置（若路径没有内容则默认为(0,0)）到目标点位置的线段。
此处以使用画笔和画刷绘制五角星为例，示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.98068594806672197638873184793505:50001231000000:2800:627C14EC3115B6AF942628B9F3492894629C3A9CA84232F7A54FF370A182EFF2.png)
绘制区域
区域不是一个特定的形状，可以设置为指定的矩形或路径，也可以对两个区域进行组合操作。可以使用画笔或画刷在画布上进行区域的绘制。详细的API说明请参考drawing_region.h。
目前支持设置矩形区域和路径区域，分别通过OH_Drawing_RegionSetRect()接口和OH_Drawing_RegionSetPath()接口来设置。
此处以使用画刷绘制矩形的组合区域为例，示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.22736017026847255996009593533134:50001231000000:2800:3147480271A9AD80F785EC01888836E13228657197F6546925B46AA4FE683321.jpg)
绘制矩形
可以使用画笔或画刷在画布上进行矩形的绘制。使用OH_Drawing_RectCreate()接口创建矩形。接口需要传入四个浮点数，分别表示矩形的左、上、右、下四个位置的坐标，连接这4个坐标形成一个矩形。
简单示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.24877548944758685547528203520334:50001231000000:2800:D5617B806926A6B046E7CA512D09112487EAD359AAFC234C96BA5206B8017B7F.png)
绘制圆角矩形
可以使用画笔或画刷在画布上进行圆角矩形的绘制。使用OH_Drawing_RoundRectCreate()接口创建圆角矩形。接口需要传入3个参数，分别如下：
-  需要传入指向OH_Drawing_Rect矩形对象的指针，用于在此矩形的基础上切圆角进行绘制。
-  需要一个浮点参数，表示x轴上的圆角半径。
-  还需要一个浮点参数，表示y轴上的圆角半径。
简单示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.54087678639638073913502976776249:50001231000000:2800:D0B1B1E0D03F151FB8F9FDF293882401D081A92ADCACDFB7F0316DD7A47C40A7.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/textblock-drawing-arkts-V14
爬取时间: 2025-04-29 19:36:53
来源: Huawei Developer
场景介绍
字块（TextBlob）是指文本的集合。无论是单个的文字还是大块的文本，都可以通过字块来绘制。
本节聚焦于文字的绘制效果，除了基本的字块绘制之外，还可以给文字添加各种绘制效果。常见的字块绘制场景包括文字描边、文字渐变等，更多效果请见绘制效果。
基本字块绘制
Canvas通过drawTextBlob()来绘制字块。函数接受三个参数：TextBlob字块对象，以及文字基线左端点的x坐标和y坐标。
画布Canvas对象具体可见画布的获取与绘制结果的显示（ArkTS）。
字块对象可以通过多种方式创建得到，详细的字块创建方式和接口使用请参考TextBlob。
此处以使用makeFromString()接口创建字块为例，接口接受3个参数，分别为：
-  需要显示的字符串text。
-  font字型对象。其中font用于设置和获取字体的各种属性，如字体大小、文本样式、字体对齐方式、字体渲染方式、字体描边方式等，详细的API介绍请参考Font。
-  文本编码方式。当前支持的文本编码方式如下：
基本效果的示例代码和效果图如下：
```typescript
// 创建字型对象
const font = new drawing.Font();
// 设置字体大小
font.setSize(100);
// 创建字块对象
const textBlob = drawing.TextBlob.makeFromString("Hello world", font, drawing.TextEncoding.TEXT_ENCODING_UTF8);
// 绘制字块
canvas.drawTextBlob(textBlob, 200, 300);
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.62622135717024545335307045748370:50001231000000:2800:099C02DE99C3BBA8FDAAC6CED1D1F0189EAEB8D3242C49FA4B8411E7ADB5A975.jpg)
文字描边
基于基本的字块绘制，还可以通过画笔实现文字描边效果，描边效果的更多介绍请参考描边效果。
文字描边的简要示例和示意图如下：
```typescript
// 创建画笔
let pen = new drawing.Pen();
// 设置抗锯齿
pen.setAntiAlias(true);
// 设置描边线宽
pen.setStrokeWidth(3.0);
// 设置描边颜色
pen.setColor(0xFF, 0xFF,  0x00, 0x00);
// 创建字型对象
const font = new drawing.Font();
// 设置字体大小
font.setSize(100);
// 添加画笔描边效果
canvas.attachPen(pen);
// 创建字块对象
const textBlob = drawing.TextBlob.makeFromString("Hello world", font, drawing.TextEncoding.TEXT_ENCODING_UTF8);
// 绘制字块
canvas.drawTextBlob(textBlob, 200, 300);
// 去除描边效果
canvas.detachPen();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.72214813278711532308411694271570:50001231000000:2800:72D00AA41625ADEBEDB8459887639C76CD543D5DEB5B2889E9F998584B5BBDF4.jpg)
文字渐变
基于基本字块绘制，还可以通过着色器实现文字渐变的效果，着色器的更多介绍请参考着色器效果。
以下为文字添加了线性渐变着色器效果的简要示例和示意图：
```typescript
let startPt: common2D.Point = { x: 100, y: 100 };
let endPt: common2D.Point = { x: 900, y: 900 };
let colors = [0xFFFFFF00, 0xFFFF0000, 0xFF0000FF];
// 创建线性渐变着色器
let shaderEffect = drawing.ShaderEffect.createLinearGradient(startPt, endPt, colors, drawing.TileMode.CLAMP);
// 创建画刷
let brush = new drawing.Brush();
// 设置着色器
brush.setShaderEffect(shaderEffect);
// 添加画刷填充效果
canvas.attachBrush(brush);
// 创建字型
const font = new drawing.Font();
// 设置字体大小
font.setSize(200);
// 创建字块
const textBlob = drawing.TextBlob.makeFromString("Hello world", font, drawing.TextEncoding.TEXT_ENCODING_UTF8);
// 绘制字块
canvas.drawTextBlob(textBlob, 100, 300);
// 去除填充效果
canvas.detachBrush();
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.35773408864359652088396805361358:50001231000000:2800:9F8D4EAE730F08CE7F7D3E8C964643AAE1B162BF6C049CF14762ADAEA7B98D69.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/pixelmap-drawing-c-V14
爬取时间: 2025-04-29 19:36:54
来源: Huawei Developer
位图是一种用于在内存中存储和表示图像的数据结构，它是一个未经过压缩的像素集合，而JPEG或PNG等格式的图片是压缩格式的，两者并不相同。如果需要将JPEG或PNG绘制到屏幕上，需要先解码成位图格式，具体可参考图片处理服务（Image Kit）图片解码相关章节。
目前Drawing（C/C++）中位图绘制需要依赖PixelMap，它可以用于读取或写入图像数据以及获取图像信息。详细的API介绍请参考drawing_pixel_map.h。
有多个API接口可以创建PixelMap，下文以使用OH_Drawing_PixelMapGetFromOhPixelMapNative()为例。
1.  添加链接库。 在Native工程的src/main/cpp/CMakeLists.txt，添加如下链接库：
2.  创建OH_PixelmapNative像素图对象。 PixelMap需要从图像框架定义的像素图对象（OH_PixelmapNative）中获取，所以需要先通过OH_PixelmapNative_CreatePixelmap()创建OH_PixelmapNative。该函数接受4个参数，第一个参数为图像像素数据的缓冲区，用于初始化PixelMap的像素。第二个参数是缓冲区长度。第三个参数是位图格式（包括长、宽、颜色类型、透明度类型等）。第四个参数即OH_PixelmapNative对象，作为出参使用。
3.  创建PixelMap。 通过OH_Drawing_PixelMapGetFromOhPixelMapNative()函数从OH_PixelmapNative中获取PixelMap。
4.  绘制PixelMap。 需要通过OH_Drawing_CanvasDrawPixelMapRect()绘制位图PixelMap。函数接受5个参数，分别为画布Canvas、PixelMap对象、PixelMap中像素的截取区域、画布中显示的区域以及采样选项对象。 其中采样选项对象（OH_Drawing_SamplingOptions）表示了从原始像素数据（即Bitmap）中采样以生成新的像素值的具体方式，具体可见drawing_sampling_options.h。
5.  绘制完成后释放相关对象。 绘制效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.86235489134938097727378195350378:50001231000000:2800:2E4A950F760D0BCAF9990A320EFB0A717F255BC87E1A8932323F16AFD6DA304E.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/geometric-shape-drawing-c-V14
爬取时间: 2025-04-29 19:37:07
来源: Huawei Developer
场景介绍
当前支持绘制的几何形状，主要包括以下几种：
-  点
-  圆弧
-  圆
-  路径
-  区域
-  矩形
-  圆角矩形
大部分的几何形状均可以选择使用画笔或者使用画刷来实现绘制，其中点的绘制只能使用画笔。
接口说明
几何形状绘制的常用接口如下表所示，详细的使用和参数说明请见drawing_canvas.h。
| 接口 | 描述 |
| --- | --- |
| OH_Drawing_Point* OH_Drawing_PointCreate (float x, float y) | 用于创建一个坐标点对象。 |
| OH_Drawing_ErrorCode OH_Drawing_CanvasDrawPoint (OH_Drawing_Canvas *canvas, const OH_Drawing_Point2D *point) | 用于画一个点。 |
| OH_Drawing_Rect* OH_Drawing_RectCreate (float left, float top, float right, float bottom) | 用于创建一个矩形对象。 |
| void OH_Drawing_CanvasDrawArc (OH_Drawing_Canvas*, const OH_Drawing_Rect*, float startAngle, float sweepAngle) | 用于画一个弧。 |
| void OH_Drawing_CanvasDrawCircle (OH_Drawing_Canvas*, const OH_Drawing_Point*, float radius) | 用于画一个圆形。 |
| OH_Drawing_Path* OH_Drawing_PathCreate (void) | 用于创建一个路径对象。 |
| void OH_Drawing_CanvasDrawPath (OH_Drawing_Canvas*, const OH_Drawing_Path*) | 用于画一个自定义路径。 |
| OH_Drawing_Region* OH_Drawing_RegionCreate (void) | 用于创建一个区域对象。 |
| void OH_Drawing_CanvasDrawRegion (OH_Drawing_Canvas*, const OH_Drawing_Region*) | 用于画一块区域。 |
| void OH_Drawing_CanvasDrawRect (OH_Drawing_Canvas*, const OH_Drawing_Rect*) | 用于画一个矩形。 |
| OH_Drawing_RoundRect* OH_Drawing_RoundRectCreate (const OH_Drawing_Rect*, float xRad, float yRad) | 用于创建一个圆角矩形对象。 |
| void OH_Drawing_CanvasDrawRoundRect (OH_Drawing_Canvas*, const OH_Drawing_RoundRect*) | 用于画一个圆角矩形。 |
绘制点
点只能基于画笔在画布上进行绘制，通过使用OH_Drawing_CanvasDrawPoint()接口绘制点。接口接受两个参数，一个是画布对象Canvas，请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）；另一个是要绘制的点的指针。
简单示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.51611071484765506853887548920225:50001231000000:2800:2A49E662354AA7605F98C52C215E1A46CFDDC6A4FEDDFBC8F4EDAD6B8DE23A3E.png)
绘制圆弧
可以使用画笔或画刷在画布上进行圆弧的绘制，通过使用OH_Drawing_CanvasDrawArc()接口绘制圆弧。使用接口需要传入4个参数，分别如下：
-  需要画布对象Canvas，请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）。
-  绘制圆弧还需要一个矩形，会以矩形的边为轮廓进行绘制。
-  需要一个浮点参数，表示弧形的起始角度。
-  需要另一个浮点参数，表示弧形的扫描角度。
此处以使用画笔绘制圆弧为例，简单示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.94584926007469533542195543736185:50001231000000:2800:2EEEE47EB75EFB0AEB42937764BE846718A9B39FAE30BFBD9A7AF1DC2E2AF15D.png)
绘制圆
可以使用画笔或画刷在画布上进行圆的绘制，通过使用OH_Drawing_CanvasDrawCircle()接口绘制圆。使用接口需要传入3个参数，分别如下：
-  需要画布对象Canvas，请确保已创建或获取得到画布Canvas，具体可见画布的获取与绘制结果的显示（C/C++）。
-  绘制圆还需要一个指向圆心点对象的指针，会以此点为圆心进行绘制。
-  最后需要一个浮点参数，表示圆的半径。
此处以使用画笔绘制圆为例，简单示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.91346172784426918542679240277299:50001231000000:2800:9F36735765DA04499A73EEF0F025F6A4D1F2867ED93E84C9917C842CF6A27F27.png)
绘制路径
可以使用画笔或画刷在画布上进行路径的绘制，路径具体可以用于绘制直线、弧线、贝塞尔曲线等，也可以通过路径组合的方式组成其他复杂的形状。
绘制路径的相关接口和实现如下，详细的使用和参数说明请见drawing_path。常用的接口如下：
1.  使用OH_Drawing_PathCreate()接口可以创建一个路径对象。
2.  使用OH_Drawing_PathMoveTo()接口可以设置自定义路径的起始点位置。
3.  使用OH_Drawing_PathLineTo()接口可以添加一条从起始点或路径的最后点位置（若路径没有内容则默认为(0,0)）到目标点位置的线段。
此处以使用画笔和画刷绘制五角星为例，示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.98068594806672197638873184793505:50001231000000:2800:627C14EC3115B6AF942628B9F3492894629C3A9CA84232F7A54FF370A182EFF2.png)
绘制区域
区域不是一个特定的形状，可以设置为指定的矩形或路径，也可以对两个区域进行组合操作。可以使用画笔或画刷在画布上进行区域的绘制。详细的API说明请参考drawing_region.h。
目前支持设置矩形区域和路径区域，分别通过OH_Drawing_RegionSetRect()接口和OH_Drawing_RegionSetPath()接口来设置。
此处以使用画刷绘制矩形的组合区域为例，示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.22736017026847255996009593533134:50001231000000:2800:3147480271A9AD80F785EC01888836E13228657197F6546925B46AA4FE683321.jpg)
绘制矩形
可以使用画笔或画刷在画布上进行矩形的绘制。使用OH_Drawing_RectCreate()接口创建矩形。接口需要传入四个浮点数，分别表示矩形的左、上、右、下四个位置的坐标，连接这4个坐标形成一个矩形。
简单示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.24877548944758685547528203520334:50001231000000:2800:D5617B806926A6B046E7CA512D09112487EAD359AAFC234C96BA5206B8017B7F.png)
绘制圆角矩形
可以使用画笔或画刷在画布上进行圆角矩形的绘制。使用OH_Drawing_RoundRectCreate()接口创建圆角矩形。接口需要传入3个参数，分别如下：
-  需要传入指向OH_Drawing_Rect矩形对象的指针，用于在此矩形的基础上切圆角进行绘制。
-  需要一个浮点参数，表示x轴上的圆角半径。
-  还需要一个浮点参数，表示y轴上的圆角半径。
简单示例如下：
效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.54087678639638073913502976776249:50001231000000:2800:D0B1B1E0D03F151FB8F9FDF293882401D081A92ADCACDFB7F0316DD7A47C40A7.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/pixelmap-drawing-c-V14
爬取时间: 2025-04-29 19:37:20
来源: Huawei Developer
位图是一种用于在内存中存储和表示图像的数据结构，它是一个未经过压缩的像素集合，而JPEG或PNG等格式的图片是压缩格式的，两者并不相同。如果需要将JPEG或PNG绘制到屏幕上，需要先解码成位图格式，具体可参考图片处理服务（Image Kit）图片解码相关章节。
目前Drawing（C/C++）中位图绘制需要依赖PixelMap，它可以用于读取或写入图像数据以及获取图像信息。详细的API介绍请参考drawing_pixel_map.h。
有多个API接口可以创建PixelMap，下文以使用OH_Drawing_PixelMapGetFromOhPixelMapNative()为例。
1.  添加链接库。 在Native工程的src/main/cpp/CMakeLists.txt，添加如下链接库：
2.  创建OH_PixelmapNative像素图对象。 PixelMap需要从图像框架定义的像素图对象（OH_PixelmapNative）中获取，所以需要先通过OH_PixelmapNative_CreatePixelmap()创建OH_PixelmapNative。该函数接受4个参数，第一个参数为图像像素数据的缓冲区，用于初始化PixelMap的像素。第二个参数是缓冲区长度。第三个参数是位图格式（包括长、宽、颜色类型、透明度类型等）。第四个参数即OH_PixelmapNative对象，作为出参使用。
3.  创建PixelMap。 通过OH_Drawing_PixelMapGetFromOhPixelMapNative()函数从OH_PixelmapNative中获取PixelMap。
4.  绘制PixelMap。 需要通过OH_Drawing_CanvasDrawPixelMapRect()绘制位图PixelMap。函数接受5个参数，分别为画布Canvas、PixelMap对象、PixelMap中像素的截取区域、画布中显示的区域以及采样选项对象。 其中采样选项对象（OH_Drawing_SamplingOptions）表示了从原始像素数据（即Bitmap）中采样以生成新的像素值的具体方式，具体可见drawing_sampling_options.h。
5.  绘制完成后释放相关对象。 绘制效果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165917.86235489134938097727378195350378:50001231000000:2800:2E4A950F760D0BCAF9990A320EFB0A717F255BC87E1A8932323F16AFD6DA304E.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/textblock-drawing-c-V14
爬取时间: 2025-04-29 19:37:34
来源: Huawei Developer
场景介绍
字块（TextBlob）是指文本的集合。无论是单个的文字还是大块的文本，都可以通过字块来绘制。
本节聚焦于文字的绘制效果，除了基本的字块绘制之外，还可以给文字添加各种绘制效果。常见的字块绘制场景包括文字描边、文字渐变等，更多效果请见绘制效果。
基本字块绘制
使用OH_Drawing_CanvasDrawTextBlob()接口绘制字块，接口接受4个参数，分别为：画布Canvas对象、字块对象、文字基线左端点的x坐标和y坐标。
画布Canvas对象具体可见画布的获取与绘制结果的显示（C/C++）。
字块对象可以通过多种方式创建得到，详细的字块创建方式请参考drawing_text_blob.h。
此处以使用OH_Drawing_TextBlobCreateFromString()接口创建字块为例，接口接受3个参数，分别为：
-  需要显示的文本字符串内容。
-  指向OH_Drawing_Font字体对象的指针。OH_Drawing_Font用于设置和获取字体的各种属性，如字体大小、文本样式、字体对齐方式、字体渲染方式、字体描边方式等，详细的API介绍请参考draw_font。
-  文本编码方式。
简单示例和示意图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165918.08055619923906548514313882980920:50001231000000:2800:1B09899D227CD543E912381E7F0293486E3A038F22D0368DC4340A42FF31D160.jpg)
文字描边
基于基本的字块绘制，还可以通过画笔实现文字描边效果，描边效果的更多介绍请参考描边效果。
文字描边的简要示例和示意图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165918.09701401526829004213690062036067:50001231000000:2800:B76EE604ABEF7FD1E47C455D4199A5FD72D15131FD5D5190177D91357B41D51D.jpg)
文字渐变
基于基本字块绘制，还可以通过着色器实现文字渐变的效果，着色器的更多介绍请参考着色器效果。
以下为文字添加了线性渐变着色器效果的简要示例和示意图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165918.55350316014205511616987153007328:50001231000000:2800:930A780FE870D8C42AB77147F12ECD5AF8AF91BB8A6CD6F3F59A4A142CBBA6E5.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/text-js-guidelines-V14
爬取时间: 2025-04-29 19:37:47
来源: Huawei Developer
场景介绍
@ohos.graphics.text模块提供了接口创建复杂的文本段落，包括多样的文本样式、段落样式、换行规则等，并最终将这些信息转换为能在屏幕上高效渲染的布局数据。
接口说明
@ohos.graphics.text常用接口如下表所示，详细的接口说明请参考@ohos.graphics.text。
| 接口名 | 描述 |
| --- | --- |
| pushStyle(textStyle: TextStyle): void | 设置成最新的文本样式。 |
| addText(text: string): void | 用于向正在构建的文本段落中插入具体的文本字符串。 |
| addPlaceholder(placeholderSpan: PlaceholderSpan): void | 用于在构建文本段落时插入占位符。 |
| build(): Paragraph | 用于完成段落的构建过程，生成一个可用于后续排版渲染的段落对象。 |
| paint(canvas: drawing.Canvas, x: number, y: number): void | 在画布上以坐标点 (x, y) 为左上角位置绘制文本。 |
开发步骤
使用TextEngine进行文字绘制与显示时，需要使用@ohos.graphics.text模块的字体管理器和段落样式、段落生成器创建文本段落，最终在应用上显示文本。
本文以实现段落文字的创建与显示为例，给出具体的开发指导。
添加开发依赖
依赖文件
接下来介绍如何使用text接口进行文本绘制。
绘制文本
以下步骤描述了如何使用@ohos.graphics.text模块的接口创建段落对象以及显示段落文本。
1.  创建RenderNode子类。创建RenderNode子类MyRenderNode，并在其中定义绘图函数draw，下方第2步及第3步为draw函数的具体实现。RenderNode中包含树结构的操作，以及对绘制属性的操作。
2.  创建canvas并设置画笔和画刷样式。使用Pen接口创建一个画笔实例pen，并设置抗锯齿、颜色、线宽等属性，画笔用于形状边框线的绘制。使用Brush接口创建一个画刷实例brush，并设置填充颜色，画刷用于形状内部的填充。使用canvas中的attachPen和attachBrush接口将画笔画刷的实例设置到画布实例中。
3.  绘制文本。使用TextStyle接口创建一个文本样式实例myTextStyle，示例只设置了文本颜色，使用ParagraphStyle接口创建一个段落样式实例myParagraphStyle，并设置文本样式等属性，使用FontCollection接口创建一个字体管理器实例fontCollection，使用ParagraphBuilder的接口，以myParagraphStyle和fontCollection为参数创建一个段落生成器实例ParagraphGraphBuilder，并调用其接口使文本样式更新以及添加段落文本，在调用build()接口生成段落实例paragraph，最后调用paint接口在屏幕上显示。
4.  创建MyRenderNode对象。以上1到3步构建出了MyRenderNode类并在其中定义了绘图的主要函数，接下来创建一个MyRenderNode对象，并设置它的像素格式。
5.  创建NodeController子类。创建NodeController的子类MyNodeController，并在其中定义创建FrameNode的函数。NodeController定义了节点容器的控制器，控制着容器里在生命周期中的节点。FrameNode定义了节点的基本类型，并包含一个RenderNode。
6.  创建添加节点的接口。在第5步中创建的MyNodeController类中创建添加RenderNode的接口。
7.  创建删除节点的接口。在第5步中创建的MyNodeController类中创建删除RenderNode的接口。
8.  绘制图形和文字。创建MyNodeController实例并将其存入NodeContainer，添加button控件供用户点击，并调用已定义的接口。
9.  绘制与显示的效果图如下：
| 主页 | 绘制文字(不设置wordBreak) | 绘制文字(设置wordBreak) |
| --- | --- | --- |
|  |  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165918.47873658598362681030235917870529:50001231000000:2800:942B06E9AC12C1BB8C9378A5774DD8D03A49A8AD2965DC0D8EC3FA67F717D66E.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165918.43397396416324247658693683243064:50001231000000:2800:17374F37E00F5CF5BBC8F183BE58BF2428429EB2D6DD6EA86AAB9B7EF68646A0.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165918.48078788281870116223213591942191:50001231000000:2800:C117069462E8250C1FC541D3DF30761D9C321047FE6468A485EAD6DCF19B662D.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/theme-font-c-V14
爬取时间: 2025-04-29 19:38:00
来源: Huawei Developer
场景介绍
主题字体，特指系统主题应用中能使用的字体，属于一种特殊的自定义字体。可以通过相关接口调用使能主题应用中的主题字体。
实现机制
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165918.60018668200728672444052216861509:50001231000000:2800:54E8766F6D20E499AD356414C31F3C810C90B19AC95ED0D96AB9BB370FF83640.jpg)
针对主题字的切换使用，应用方应确保订阅主题字变更事件，当接收字体变更事件后，由应用方主动调用页面刷新才能实现主题字的切换，否则主题字只能在重启应用后才生效；主题字的绘制需要使用OH_Drawing_GetFontCollectionGlobalInstance来获取全局字体集对象，仅该接口返回的对象拥有主题字体信息。
由OH_Drawing_CreateSharedFontCollection创建的字体集对象不包含主题字信息，无法用于绘制主题字。
接口说明
注册使用主题字体的常用接口如下表所示，详细接口说明请参考Drawing。
| 接口名 | 描述 |
| --- | --- |
| OH_Drawing_FontCollection* OH_Drawing_GetFontCollectionGlobalInstance(void) | 获取全局的字体集对象OH_Drawing_FontCollection。 |
| onConfigurationUpdate() | 系统配置更新时调用。 主题应用当前仅提供ArkTS接口发布变更事件，需要应用自行处理进行跨语言调用。 |
接口名
描述
OH_Drawing_FontCollection* OH_Drawing_GetFontCollectionGlobalInstance(void)
获取全局的字体集对象OH_Drawing_FontCollection。
onConfigurationUpdate()
系统配置更新时调用。
主题应用当前仅提供ArkTS接口发布变更事件，需要应用自行处理进行跨语言调用。
开发步骤
1.  newConfig变化时，会自动触发onConfigurationUpdate函数。应用可从发送的配置信息获取fontId，通过判断是否与应用本地保存的fontId一致来识别主题字的切换。若不一致则刷新本地fontId，并调用C++代码刷新排版结果。
2.  导入头文件。
3.  注册主题字体作用于字体管理集全局对象，故必须使用OH_Drawing_GetFontCollectionGlobalInstance获取全局字体集对象进行绘制。如若使用OH_Drawing_CreateSharedFontCollection或OH_Drawing_CreateFontCollection创建字体集对象，无法使用主题字体。OH_Drawing_GetFontCollectionGlobalInstance获取的全局字体集不允许释放，释放会造成字体绘制紊乱问题。
4.
5.
效果展示
以下展示了在系统主题应用中切换使用不同主题字体后，对应的文字渲染效果。
不同主题字体显示效果不同，此处仅示意。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165918.82740890150969137420489011425825:50001231000000:2800:6F88E6DA78EBA0073EB24298F9A901DC7E9931EFD598D321D3F30BA34DE4E010.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/native-buffer-guidelines-V14
爬取时间: 2025-04-29 19:38:14
来源: Huawei Developer
场景介绍
NativeBuffer是提供共享内存的模块。开发者可以通过NativeBuffer接口实现共享内存的申请、使用、属性查询、释放等操作。
针对NativeBuffer，常见的开发场景如下：
接口说明
| 接口名 | 描述 |
| --- | --- |
| OH_NativeBuffer_Alloc (const OH_NativeBuffer_Config *config) | 通过OH_NativeBuffer_Config创建OH_NativeBuffer实例，每次调用都会产生一个新的OH_NativeBuffer实例。本接口需要与OH_NativeBuffer_Unreference接口配合使用，否则会存在内存泄露。 |
| OH_NativeBuffer_Reference (OH_NativeBuffer *buffer) | 将OH_NativeBuffer对象的引用计数增加1。 |
| OH_NativeBuffer_Unreference (OH_NativeBuffer *buffer) | 将OH_NativeBuffer对象的引用计数减1，当引用计数为0的时候，该NativeBuffer对象会被析构掉。 |
| OH_NativeBuffer_GetConfig (OH_NativeBuffer *buffer, OH_NativeBuffer_Config *config) | 用于获取OH_NativeBuffer的属性。 |
| OH_NativeBuffer_Map (OH_NativeBuffer *buffer, void **virAddr) | 将OH_NativeBuffer对应的ION内存映射到进程空间。 |
| OH_NativeBuffer_Unmap (OH_NativeBuffer *buffer) | 将OH_NativeBuffer对应的ION内存从进程空间移除。 |
| OH_NativeBuffer_GetSeqNum (OH_NativeBuffer *buffer) | 获取OH_NativeBuffer的序列号。 |
详细的接口说明请参考native_buffer。
开发步骤
以下步骤描述了如何使用NativeBuffer提供的Native API接口，创建OH_NativeBuffer实例获取内存的属性信息，并把对应的ION内存映射到进程空间。
添加动态链接库
CMakeLists.txt中添加以下lib。
头文件
1.  创建OH_NativeBuffer实例。
2.  将OH_NativeBuffer对应的ION内存映射到进程空间。 应用如需要访问这块buffer的内存空间，需要通过OH_NativeBuffer_Map接口将buffer对应的ION内存映射到进程空间。
3.  获取内存的属性信息。
4.  销毁OH_NativeBuffer。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/text-js-guidelines-V14
爬取时间: 2025-04-29 19:38:19
来源: Huawei Developer
场景介绍
@ohos.graphics.text模块提供了接口创建复杂的文本段落，包括多样的文本样式、段落样式、换行规则等，并最终将这些信息转换为能在屏幕上高效渲染的布局数据。
接口说明
@ohos.graphics.text常用接口如下表所示，详细的接口说明请参考@ohos.graphics.text。
| 接口名 | 描述 |
| --- | --- |
| pushStyle(textStyle: TextStyle): void | 设置成最新的文本样式。 |
| addText(text: string): void | 用于向正在构建的文本段落中插入具体的文本字符串。 |
| addPlaceholder(placeholderSpan: PlaceholderSpan): void | 用于在构建文本段落时插入占位符。 |
| build(): Paragraph | 用于完成段落的构建过程，生成一个可用于后续排版渲染的段落对象。 |
| paint(canvas: drawing.Canvas, x: number, y: number): void | 在画布上以坐标点 (x, y) 为左上角位置绘制文本。 |
开发步骤
使用TextEngine进行文字绘制与显示时，需要使用@ohos.graphics.text模块的字体管理器和段落样式、段落生成器创建文本段落，最终在应用上显示文本。
本文以实现段落文字的创建与显示为例，给出具体的开发指导。
添加开发依赖
依赖文件
接下来介绍如何使用text接口进行文本绘制。
绘制文本
以下步骤描述了如何使用@ohos.graphics.text模块的接口创建段落对象以及显示段落文本。
1.  创建RenderNode子类。创建RenderNode子类MyRenderNode，并在其中定义绘图函数draw，下方第2步及第3步为draw函数的具体实现。RenderNode中包含树结构的操作，以及对绘制属性的操作。
2.  创建canvas并设置画笔和画刷样式。使用Pen接口创建一个画笔实例pen，并设置抗锯齿、颜色、线宽等属性，画笔用于形状边框线的绘制。使用Brush接口创建一个画刷实例brush，并设置填充颜色，画刷用于形状内部的填充。使用canvas中的attachPen和attachBrush接口将画笔画刷的实例设置到画布实例中。
3.  绘制文本。使用TextStyle接口创建一个文本样式实例myTextStyle，示例只设置了文本颜色，使用ParagraphStyle接口创建一个段落样式实例myParagraphStyle，并设置文本样式等属性，使用FontCollection接口创建一个字体管理器实例fontCollection，使用ParagraphBuilder的接口，以myParagraphStyle和fontCollection为参数创建一个段落生成器实例ParagraphGraphBuilder，并调用其接口使文本样式更新以及添加段落文本，在调用build()接口生成段落实例paragraph，最后调用paint接口在屏幕上显示。
4.  创建MyRenderNode对象。以上1到3步构建出了MyRenderNode类并在其中定义了绘图的主要函数，接下来创建一个MyRenderNode对象，并设置它的像素格式。
5.  创建NodeController子类。创建NodeController的子类MyNodeController，并在其中定义创建FrameNode的函数。NodeController定义了节点容器的控制器，控制着容器里在生命周期中的节点。FrameNode定义了节点的基本类型，并包含一个RenderNode。
6.  创建添加节点的接口。在第5步中创建的MyNodeController类中创建添加RenderNode的接口。
7.  创建删除节点的接口。在第5步中创建的MyNodeController类中创建删除RenderNode的接口。
8.  绘制图形和文字。创建MyNodeController实例并将其存入NodeContainer，添加button控件供用户点击，并调用已定义的接口。
9.  绘制与显示的效果图如下：
| 主页 | 绘制文字(不设置wordBreak) | 绘制文字(设置wordBreak) |
| --- | --- | --- |
|  |  |  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165918.47873658598362681030235917870529:50001231000000:2800:942B06E9AC12C1BB8C9378A5774DD8D03A49A8AD2965DC0D8EC3FA67F717D66E.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165918.43397396416324247658693683243064:50001231000000:2800:17374F37E00F5CF5BBC8F183BE58BF2428429EB2D6DD6EA86AAB9B7EF68646A0.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165918.48078788281870116223213591942191:50001231000000:2800:C117069462E8250C1FC541D3DF30761D9C321047FE6468A485EAD6DCF19B662D.jpg)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/native-image-guidelines-V14
爬取时间: 2025-04-29 19:38:27
来源: Huawei Developer
场景介绍
NativeImage是提供Surface关联OpenGL外部纹理的模块，表示图形队列的消费者端。开发者可以通过NativeImage接口接收和使用Buffer，并将Buffer关联输出到OpenGL外部纹理。
针对NativeImage，常见的开发场景如下：
接口说明
| 接口名 | 描述 |
| --- | --- |
| OH_NativeImage_Create (uint32_t textureId, uint32_t textureTarget) | 创建一个OH_NativeImage实例，该实例与OpenGL ES的纹理ID和纹理目标相关联。本接口需要与OH_NativeImage_Destroy接口配合使用，否则会存在内存泄露。 |
| OH_NativeImage_AcquireNativeWindow (OH_NativeImage *image) | 获取与OH_NativeImage相关联的OHNativeWindow指针，该OHNativeWindow在调用OH_NativeImage_Destroy时会将其释放，不需要调用OH_NativeWindow_DestroyNativeWindow释放，否则会出现访问已释放内存错误，可能会导致崩溃。 |
| OH_NativeImage_AttachContext (OH_NativeImage *image, uint32_t textureId) | 将OH_NativeImage实例附加到当前OpenGL ES上下文，且该OpenGL ES纹理会绑定到 GL_TEXTURE_EXTERNAL_OES，并通过OH_NativeImage进行更新。 |
| OH_NativeImage_DetachContext (OH_NativeImage *image) | 将OH_NativeImage实例从当前OpenGL ES上下文分离。 |
| OH_NativeImage_UpdateSurfaceImage (OH_NativeImage *image) | 通过OH_NativeImage获取最新帧更新相关联的OpenGL ES纹理。 |
| OH_NativeImage_GetTimestamp (OH_NativeImage *image) | 获取最近调用OH_NativeImage_UpdateSurfaceImage的纹理图像的相关时间戳。 |
| OH_NativeImage_GetTransformMatrix (OH_NativeImage *image, float matrix[16]) | 获取最近调用OH_NativeImage_UpdateSurfaceImage的纹理图像的变化矩阵。 |
| OH_NativeImage_Destroy (OH_NativeImage **image) | 销毁通过OH_NativeImage_Create创建的OH_NativeImage实例，销毁后该OH_NativeImage指针会被赋值为空。 |
详细的接口说明请参考native_image。
开发步骤
以下步骤描述了如何使用NativeImage提供的Native API接口，创建OH_NativeImage实例作为消费者端，将数据内容更新到OpenGL外部纹理上。
添加动态链接库
CMakeLists.txt中添加以下lib。
头文件
1.  初始化EGL环境。 这里提供一份初始化EGL环境的代码示例。XComponent模块的具体使用方法请参考XComponent开发指导。
2.  创建OH_NativeImage实例。
3.  获取对应的数据生产者端NativeWindow。
4.  设置NativeWindow的宽高。
5.  将生产的内容写入OHNativeWindowBuffer。 从NativeWindow中获取OHNativeWindowBuffer。 将生产的内容写入OHNativeWindowBuffer。 将OHNativeWindowBuffer提交到NativeWindow。 用完需要销毁NativeWindow。
6.  从NativeWindow中获取OHNativeWindowBuffer。
7.  将生产的内容写入OHNativeWindowBuffer。
8.  将OHNativeWindowBuffer提交到NativeWindow。
9.  用完需要销毁NativeWindow。
10.  更新内容到OpenGL纹理。
11.  解绑OpenGL纹理，绑定到新的外部纹理上。
12.  OH_NativeImage实例使用完需要销毁掉。
1.  从NativeWindow中获取OHNativeWindowBuffer。
2.  将生产的内容写入OHNativeWindowBuffer。
3.  将OHNativeWindowBuffer提交到NativeWindow。
4.  用完需要销毁NativeWindow。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/theme-font-c-V14
爬取时间: 2025-04-29 19:38:33
来源: Huawei Developer
场景介绍
主题字体，特指系统主题应用中能使用的字体，属于一种特殊的自定义字体。可以通过相关接口调用使能主题应用中的主题字体。
实现机制
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165918.60018668200728672444052216861509:50001231000000:2800:54E8766F6D20E499AD356414C31F3C810C90B19AC95ED0D96AB9BB370FF83640.jpg)
针对主题字的切换使用，应用方应确保订阅主题字变更事件，当接收字体变更事件后，由应用方主动调用页面刷新才能实现主题字的切换，否则主题字只能在重启应用后才生效；主题字的绘制需要使用OH_Drawing_GetFontCollectionGlobalInstance来获取全局字体集对象，仅该接口返回的对象拥有主题字体信息。
由OH_Drawing_CreateSharedFontCollection创建的字体集对象不包含主题字信息，无法用于绘制主题字。
接口说明
注册使用主题字体的常用接口如下表所示，详细接口说明请参考Drawing。
| 接口名 | 描述 |
| --- | --- |
| OH_Drawing_FontCollection* OH_Drawing_GetFontCollectionGlobalInstance(void) | 获取全局的字体集对象OH_Drawing_FontCollection。 |
| onConfigurationUpdate() | 系统配置更新时调用。 主题应用当前仅提供ArkTS接口发布变更事件，需要应用自行处理进行跨语言调用。 |
接口名
描述
OH_Drawing_FontCollection* OH_Drawing_GetFontCollectionGlobalInstance(void)
获取全局的字体集对象OH_Drawing_FontCollection。
onConfigurationUpdate()
系统配置更新时调用。
主题应用当前仅提供ArkTS接口发布变更事件，需要应用自行处理进行跨语言调用。
开发步骤
1.  newConfig变化时，会自动触发onConfigurationUpdate函数。应用可从发送的配置信息获取fontId，通过判断是否与应用本地保存的fontId一致来识别主题字的切换。若不一致则刷新本地fontId，并调用C++代码刷新排版结果。
2.  导入头文件。
3.  注册主题字体作用于字体管理集全局对象，故必须使用OH_Drawing_GetFontCollectionGlobalInstance获取全局字体集对象进行绘制。如若使用OH_Drawing_CreateSharedFontCollection或OH_Drawing_CreateFontCollection创建字体集对象，无法使用主题字体。OH_Drawing_GetFontCollectionGlobalInstance获取的全局字体集不允许释放，释放会造成字体绘制紊乱问题。
4.
5.
效果展示
以下展示了在系统主题应用中切换使用不同主题字体后，对应的文字渲染效果。
不同主题字体显示效果不同，此处仅示意。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165918.82740890150969137420489011425825:50001231000000:2800:6F88E6DA78EBA0073EB24298F9A901DC7E9931EFD598D321D3F30BA34DE4E010.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/native-vsync-guidelines-V14
爬取时间: 2025-04-29 19:38:41
来源: Huawei Developer
场景介绍
NativeVSync模块用来获取系统VSync信号，提供了OH_NativeVSync实例的创建、销毁以及设置VSync回调函数的能力，VSync信号到来时会调用已设置的VSync回调函数。
接口说明
| 接口名 | 描述 |
| --- | --- |
| OH_NativeVSync_Create (const char *name, unsigned int length) | 创建一个OH_NativeVSync实例，每次调用都会产生一个新的实例。本接口需要与OH_NativeVSync_Destroy接口配合使用，否则会存在内存泄露。 |
| OH_NativeVSync_Destroy (OH_NativeVSync *nativeVsync) | 销毁OH_NativeVSync实例。 |
| OH_NativeVSync_FrameCallback (long long timestamp, void *data) | 回调函数的形式，timestamp表示时间戳，data为回调函数入参。 |
| OH_NativeVSync_RequestFrame (OH_NativeVSync *nativeVsync, OH_NativeVSync_FrameCallback callback, void *data) | 请求下一次VSync信号，当信号到来时，调用回调函数callback。 |
详细的接口说明请参考native_vsync。
开发步骤
以下步骤描述了如何使用NativeVSync提供的Native API接口，创建和销毁OH_NativeVSync实例，以及如何设置VSync回调函数。
添加动态链接库
CMakeLists.txt中添加以下lib。
头文件
1.  首先需要准备一个VSync回调函数。
2.  创建OH_NativeVSync实例。
3.  通过OH_NativeVSync实例设置VSync回调函数。
4.  销毁OH_NativeVSync实例。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/native-buffer-guidelines-V14
爬取时间: 2025-04-29 19:38:46
来源: Huawei Developer
场景介绍
NativeBuffer是提供共享内存的模块。开发者可以通过NativeBuffer接口实现共享内存的申请、使用、属性查询、释放等操作。
针对NativeBuffer，常见的开发场景如下：
接口说明
| 接口名 | 描述 |
| --- | --- |
| OH_NativeBuffer_Alloc (const OH_NativeBuffer_Config *config) | 通过OH_NativeBuffer_Config创建OH_NativeBuffer实例，每次调用都会产生一个新的OH_NativeBuffer实例。本接口需要与OH_NativeBuffer_Unreference接口配合使用，否则会存在内存泄露。 |
| OH_NativeBuffer_Reference (OH_NativeBuffer *buffer) | 将OH_NativeBuffer对象的引用计数增加1。 |
| OH_NativeBuffer_Unreference (OH_NativeBuffer *buffer) | 将OH_NativeBuffer对象的引用计数减1，当引用计数为0的时候，该NativeBuffer对象会被析构掉。 |
| OH_NativeBuffer_GetConfig (OH_NativeBuffer *buffer, OH_NativeBuffer_Config *config) | 用于获取OH_NativeBuffer的属性。 |
| OH_NativeBuffer_Map (OH_NativeBuffer *buffer, void **virAddr) | 将OH_NativeBuffer对应的ION内存映射到进程空间。 |
| OH_NativeBuffer_Unmap (OH_NativeBuffer *buffer) | 将OH_NativeBuffer对应的ION内存从进程空间移除。 |
| OH_NativeBuffer_GetSeqNum (OH_NativeBuffer *buffer) | 获取OH_NativeBuffer的序列号。 |
详细的接口说明请参考native_buffer。
开发步骤
以下步骤描述了如何使用NativeBuffer提供的Native API接口，创建OH_NativeBuffer实例获取内存的属性信息，并把对应的ION内存映射到进程空间。
添加动态链接库
CMakeLists.txt中添加以下lib。
头文件
1.  创建OH_NativeBuffer实例。
2.  将OH_NativeBuffer对应的ION内存映射到进程空间。 应用如需要访问这块buffer的内存空间，需要通过OH_NativeBuffer_Map接口将buffer对应的ION内存映射到进程空间。
3.  获取内存的属性信息。
4.  销毁OH_NativeBuffer。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/native-window-guidelines-V14
爬取时间: 2025-04-29 19:38:54
来源: Huawei Developer
场景介绍
NativeWindow是本地平台化窗口，表示图形队列的生产者端。开发者可以通过NativeWindow接口进行申请和提交Buffer，配置Buffer属性信息。
针对NativeWindow，常见的开发场景如下：
接口说明
| 接口名 | 描述 |
| --- | --- |
| OH_NativeWindow_NativeWindowRequestBuffer (OHNativeWindow *window, OHNativeWindowBuffer **buffer, int *fenceFd) | 通过OHNativeWindow对象申请一块OHNativeWindowBuffer，用以内容生产。 |
| OH_NativeWindow_NativeWindowFlushBuffer (OHNativeWindow *window, OHNativeWindowBuffer *buffer, int fenceFd, Region region) | 通过OHNativeWindow将生产好内容的OHNativeWindowBuffer放回到Buffer队列中，用以内容消费。 |
| OH_NativeWindow_NativeWindowHandleOpt (OHNativeWindow *window, int code,...) | 设置/获取OHNativeWindow的属性，包括设置/获取宽高、内容格式等。 |
详细的接口说明请参考native_window。
开发步骤
以下步骤描述了如何使用NativeWindow提供的Native API接口，申请图形Buffer，并将生产图形内容写入图形Buffer后，最终提交Buffer到图形队列。
添加动态链接库
CMakeLists.txt中添加以下lib。
头文件
1.  获取OHNativeWindow实例。 可在OH_NativeXComponent_Callback提供的接口中获取OHNativeWindow，下面提供一份代码示例。XComponent模块的具体使用方法请参考XComponent开发指导。 在xxx.ets中添加一个XComponent组件。 在 native c++ 层获取 NativeXComponent。 定义 OH_NativeXComponent_Callback。 将 OH_NativeXComponent_Callback 注册给 NativeXComponent。
```typescript
XComponent({ id: 'xcomponentId', type: 'surface', libraryname: 'entry'})
.width(360)
.height(360)
```
2.  在xxx.ets中添加一个XComponent组件。
```typescript
XComponent({ id: 'xcomponentId', type: 'surface', libraryname: 'entry'})
.width(360)
.height(360)
```
3.  在 native c++ 层获取 NativeXComponent。
4.  定义 OH_NativeXComponent_Callback。
5.  将 OH_NativeXComponent_Callback 注册给 NativeXComponent。
6.  设置OHNativeWindowBuffer的属性。使用OH_NativeWindow_NativeWindowHandleOpt设置OHNativeWindowBuffer的属性。
7.  从图形队列申请OHNativeWindowBuffer。
8.  内存映射mmap。
9.  将生产的内容写入OHNativeWindowBuffer，在这之前需要等待releaseFenceFd可用（注意releaseFenceFd不等于-1才需要调用poll）。如果没有等待releaseFenceFd事件的数据可用（POLLIN），则可能造成花屏、裂屏、HEBC（High Efficiency Bandwidth Compression，高效带宽压缩） fault等问题。releaseFenceFd是消费者进程创建的一个文件句柄，代表消费者消费buffer完毕，buffer可读，生产者可以开始填充buffer内容。
10.  提交OHNativeWindowBuffer到图形队列。请注意OH_NativeWindow_NativeWindowFlushBuffer接口的acquireFenceFd不可以和OH_NativeWindow_NativeWindowRequestBuffer接口获取的releaseFenceFd相同，acquireFenceFd可传入默认值-1。acquireFenceFd是生产者需要传入的文件句柄，消费者获取到buffer后可根据生产者传入的acquireFenceFd决定何时去渲染并上屏buffer内容。
11.  取消内存映射munmap。
1.  在xxx.ets中添加一个XComponent组件。
```typescript
XComponent({ id: 'xcomponentId', type: 'surface', libraryname: 'entry'})
.width(360)
.height(360)
```
2.  在 native c++ 层获取 NativeXComponent。
3.  定义 OH_NativeXComponent_Callback。
4.  将 OH_NativeXComponent_Callback 注册给 NativeXComponent。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/native-image-guidelines-V14
爬取时间: 2025-04-29 19:38:59
来源: Huawei Developer
场景介绍
NativeImage是提供Surface关联OpenGL外部纹理的模块，表示图形队列的消费者端。开发者可以通过NativeImage接口接收和使用Buffer，并将Buffer关联输出到OpenGL外部纹理。
针对NativeImage，常见的开发场景如下：
接口说明
| 接口名 | 描述 |
| --- | --- |
| OH_NativeImage_Create (uint32_t textureId, uint32_t textureTarget) | 创建一个OH_NativeImage实例，该实例与OpenGL ES的纹理ID和纹理目标相关联。本接口需要与OH_NativeImage_Destroy接口配合使用，否则会存在内存泄露。 |
| OH_NativeImage_AcquireNativeWindow (OH_NativeImage *image) | 获取与OH_NativeImage相关联的OHNativeWindow指针，该OHNativeWindow在调用OH_NativeImage_Destroy时会将其释放，不需要调用OH_NativeWindow_DestroyNativeWindow释放，否则会出现访问已释放内存错误，可能会导致崩溃。 |
| OH_NativeImage_AttachContext (OH_NativeImage *image, uint32_t textureId) | 将OH_NativeImage实例附加到当前OpenGL ES上下文，且该OpenGL ES纹理会绑定到 GL_TEXTURE_EXTERNAL_OES，并通过OH_NativeImage进行更新。 |
| OH_NativeImage_DetachContext (OH_NativeImage *image) | 将OH_NativeImage实例从当前OpenGL ES上下文分离。 |
| OH_NativeImage_UpdateSurfaceImage (OH_NativeImage *image) | 通过OH_NativeImage获取最新帧更新相关联的OpenGL ES纹理。 |
| OH_NativeImage_GetTimestamp (OH_NativeImage *image) | 获取最近调用OH_NativeImage_UpdateSurfaceImage的纹理图像的相关时间戳。 |
| OH_NativeImage_GetTransformMatrix (OH_NativeImage *image, float matrix[16]) | 获取最近调用OH_NativeImage_UpdateSurfaceImage的纹理图像的变化矩阵。 |
| OH_NativeImage_Destroy (OH_NativeImage **image) | 销毁通过OH_NativeImage_Create创建的OH_NativeImage实例，销毁后该OH_NativeImage指针会被赋值为空。 |
详细的接口说明请参考native_image。
开发步骤
以下步骤描述了如何使用NativeImage提供的Native API接口，创建OH_NativeImage实例作为消费者端，将数据内容更新到OpenGL外部纹理上。
添加动态链接库
CMakeLists.txt中添加以下lib。
头文件
1.  初始化EGL环境。 这里提供一份初始化EGL环境的代码示例。XComponent模块的具体使用方法请参考XComponent开发指导。
2.  创建OH_NativeImage实例。
3.  获取对应的数据生产者端NativeWindow。
4.  设置NativeWindow的宽高。
5.  将生产的内容写入OHNativeWindowBuffer。 从NativeWindow中获取OHNativeWindowBuffer。 将生产的内容写入OHNativeWindowBuffer。 将OHNativeWindowBuffer提交到NativeWindow。 用完需要销毁NativeWindow。
6.  从NativeWindow中获取OHNativeWindowBuffer。
7.  将生产的内容写入OHNativeWindowBuffer。
8.  将OHNativeWindowBuffer提交到NativeWindow。
9.  用完需要销毁NativeWindow。
10.  更新内容到OpenGL纹理。
11.  解绑OpenGL纹理，绑定到新的外部纹理上。
12.  OH_NativeImage实例使用完需要销毁掉。
1.  从NativeWindow中获取OHNativeWindowBuffer。
2.  将生产的内容写入OHNativeWindowBuffer。
3.  将OHNativeWindowBuffer提交到NativeWindow。
4.  用完需要销毁NativeWindow。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphic-term-V14
爬取时间: 2025-04-29 19:39:09
来源: Huawei Developer
BlendMode
BlendMode，混合模式，定义当前内容和已有内容如何相互作用产生新的效果，不同的混合模式相互作用叠加的计算方式和效果也会对应有所不同。
字块
字块，是指使用相同字体的字形元素及其位置的集合。
着色器
着色器，Shader，是一种运行程序，主要用于显示图像渲染和处理。其能够控制或像素的处理方式，包括颜色计算、阴影效果等一系列视觉效果。可以针对绘制内容添加不同的着色器效果，从而实现丰富不同的视觉效果。
图像滤波
图像滤波，一种非常重要的图像处理技术，通过滤波操作，可以突出或去除图像中的一些元素成分。可以针对绘制效果添加不同的滤波器，从而实现不同的滤波效果。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/native-vsync-guidelines-V14
爬取时间: 2025-04-29 19:39:13
来源: Huawei Developer
场景介绍
NativeVSync模块用来获取系统VSync信号，提供了OH_NativeVSync实例的创建、销毁以及设置VSync回调函数的能力，VSync信号到来时会调用已设置的VSync回调函数。
接口说明
| 接口名 | 描述 |
| --- | --- |
| OH_NativeVSync_Create (const char *name, unsigned int length) | 创建一个OH_NativeVSync实例，每次调用都会产生一个新的实例。本接口需要与OH_NativeVSync_Destroy接口配合使用，否则会存在内存泄露。 |
| OH_NativeVSync_Destroy (OH_NativeVSync *nativeVsync) | 销毁OH_NativeVSync实例。 |
| OH_NativeVSync_FrameCallback (long long timestamp, void *data) | 回调函数的形式，timestamp表示时间戳，data为回调函数入参。 |
| OH_NativeVSync_RequestFrame (OH_NativeVSync *nativeVsync, OH_NativeVSync_FrameCallback callback, void *data) | 请求下一次VSync信号，当信号到来时，调用回调函数callback。 |
详细的接口说明请参考native_vsync。
开发步骤
以下步骤描述了如何使用NativeVSync提供的Native API接口，创建和销毁OH_NativeVSync实例，以及如何设置VSync回调函数。
添加动态链接库
CMakeLists.txt中添加以下lib。
头文件
1.  首先需要准备一个VSync回调函数。
2.  创建OH_NativeVSync实例。
3.  通过OH_NativeVSync实例设置VSync回调函数。
4.  销毁OH_NativeVSync实例。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics-3d-V14
爬取时间: 2025-04-29 19:39:22
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/native-window-guidelines-V14
爬取时间: 2025-04-29 19:39:26
来源: Huawei Developer
场景介绍
NativeWindow是本地平台化窗口，表示图形队列的生产者端。开发者可以通过NativeWindow接口进行申请和提交Buffer，配置Buffer属性信息。
针对NativeWindow，常见的开发场景如下：
接口说明
| 接口名 | 描述 |
| --- | --- |
| OH_NativeWindow_NativeWindowRequestBuffer (OHNativeWindow *window, OHNativeWindowBuffer **buffer, int *fenceFd) | 通过OHNativeWindow对象申请一块OHNativeWindowBuffer，用以内容生产。 |
| OH_NativeWindow_NativeWindowFlushBuffer (OHNativeWindow *window, OHNativeWindowBuffer *buffer, int fenceFd, Region region) | 通过OHNativeWindow将生产好内容的OHNativeWindowBuffer放回到Buffer队列中，用以内容消费。 |
| OH_NativeWindow_NativeWindowHandleOpt (OHNativeWindow *window, int code,...) | 设置/获取OHNativeWindow的属性，包括设置/获取宽高、内容格式等。 |
详细的接口说明请参考native_window。
开发步骤
以下步骤描述了如何使用NativeWindow提供的Native API接口，申请图形Buffer，并将生产图形内容写入图形Buffer后，最终提交Buffer到图形队列。
添加动态链接库
CMakeLists.txt中添加以下lib。
头文件
1.  获取OHNativeWindow实例。 可在OH_NativeXComponent_Callback提供的接口中获取OHNativeWindow，下面提供一份代码示例。XComponent模块的具体使用方法请参考XComponent开发指导。 在xxx.ets中添加一个XComponent组件。 在 native c++ 层获取 NativeXComponent。 定义 OH_NativeXComponent_Callback。 将 OH_NativeXComponent_Callback 注册给 NativeXComponent。
```typescript
XComponent({ id: 'xcomponentId', type: 'surface', libraryname: 'entry'})
.width(360)
.height(360)
```
2.  在xxx.ets中添加一个XComponent组件。
```typescript
XComponent({ id: 'xcomponentId', type: 'surface', libraryname: 'entry'})
.width(360)
.height(360)
```
3.  在 native c++ 层获取 NativeXComponent。
4.  定义 OH_NativeXComponent_Callback。
5.  将 OH_NativeXComponent_Callback 注册给 NativeXComponent。
6.  设置OHNativeWindowBuffer的属性。使用OH_NativeWindow_NativeWindowHandleOpt设置OHNativeWindowBuffer的属性。
7.  从图形队列申请OHNativeWindowBuffer。
8.  内存映射mmap。
9.  将生产的内容写入OHNativeWindowBuffer，在这之前需要等待releaseFenceFd可用（注意releaseFenceFd不等于-1才需要调用poll）。如果没有等待releaseFenceFd事件的数据可用（POLLIN），则可能造成花屏、裂屏、HEBC（High Efficiency Bandwidth Compression，高效带宽压缩） fault等问题。releaseFenceFd是消费者进程创建的一个文件句柄，代表消费者消费buffer完毕，buffer可读，生产者可以开始填充buffer内容。
10.  提交OHNativeWindowBuffer到图形队列。请注意OH_NativeWindow_NativeWindowFlushBuffer接口的acquireFenceFd不可以和OH_NativeWindow_NativeWindowRequestBuffer接口获取的releaseFenceFd相同，acquireFenceFd可传入默认值-1。acquireFenceFd是生产者需要传入的文件句柄，消费者获取到buffer后可根据生产者传入的acquireFenceFd决定何时去渲染并上屏buffer内容。
11.  取消内存映射munmap。
1.  在xxx.ets中添加一个XComponent组件。
```typescript
XComponent({ id: 'xcomponentId', type: 'surface', libraryname: 'entry'})
.width(360)
.height(360)
```
2.  在 native c++ 层获取 NativeXComponent。
3.  定义 OH_NativeXComponent_Callback。
4.  将 OH_NativeXComponent_Callback 注册给 NativeXComponent。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics3d-overview-V14
爬取时间: 2025-04-29 19:39:35
来源: Huawei Developer
ArkGraphics 3D （方舟3D图形）基于轻量级的3D引擎以及渲染管线为开发者提供基础3D场景绘制能力，供开发者便捷、高效地构建3D场景并完成渲染。
功能介绍
综上，ArkGraphics 3D提供基础的3D场景渲染能力，支撑开发者完成3D场景渲染以及逻辑控制开发工作。
具体接口的使用和参数说明，可见@ohos.graphics.scene (ArkGraphics 3D模块)。
框架原理
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165919.37844941142559602040099398678657:50001231000000:2800:5D3059FE92E2B4B0E5343FEB668BE810457799ED6644ECAADF7E6811D38CFDE1.png)
如上图 ArkGraphics 3D接口能力由图形后端、引擎层以及接口层三个关键部分共同组成。
约束限制
使用ArkGraphics 3D模块需要硬件设备支持OpenGL ES 3.2以上或者Vulkan 1.0以上的GPU驱动。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphic-term-V14
爬取时间: 2025-04-29 19:39:39
来源: Huawei Developer
BlendMode
BlendMode，混合模式，定义当前内容和已有内容如何相互作用产生新的效果，不同的混合模式相互作用叠加的计算方式和效果也会对应有所不同。
字块
字块，是指使用相同字体的字形元素及其位置的集合。
着色器
着色器，Shader，是一种运行程序，主要用于显示图像渲染和处理。其能够控制或像素的处理方式，包括颜色计算、阴影效果等一系列视觉效果。可以针对绘制内容添加不同的着色器效果，从而实现丰富不同的视觉效果。
图像滤波
图像滤波，一种非常重要的图像处理技术，通过滤波操作，可以突出或去除图像中的一些元素成分。可以针对绘制效果添加不同的滤波器，从而实现不同的滤波效果。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics3d-scene-V14
爬取时间: 2025-04-29 19:39:49
来源: Huawei Developer
一个3D场景通常由光源、相机、模型三个关键部分组成。
模型加载后，可以通过ArkUI的Component3D渲染组件呈现给用户，Component3D也可以对3D模型做自定义渲染。开发者也可以使用ArkTS API对相机和光源进行调节，获得合适的观察角度和光照效果。ArkTS API可通过napi调用AGP中由C++实现的相应能力。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165919.46309223082569534765616335864648:50001231000000:2800:D2F03E9476A7F32FC77B328EB9F6741F153941B7D34C35C75DF3998E1DC8A2F2.png)
模型的加载及呈现
模型的格式多种多样，目前ArkGraphics 3D仅支持glTF模型的加载，glTF是一种对于3D场景描述的格式，glTF作为一种开源3D场景格式在业界被广泛采用。关于glTF的介绍可以参照glTF-2.0。
一个glTF模型可以包含光源、相机、模型等3D场景关键要素，如果一个glTF模型中包含相机，使用ArkGraphics 3D提供的接口加载glTF就可以直接完成该相机视角下3D场景的渲染。如果不包含相机，也可以利用ArkGraphics 3D创建一个相机完成渲染。由于3D模型往往数据量很大，通常采用异步方式进行加载，加载成功后将返回一个scene对象，通过该对象可对整个3D场景进行编辑。
glTF模型可用Scene提供的load接口加载，示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function loadModel() : void {
// 加载模型
let scene: Promise<Scene> = Scene.load($rawfile("gltf/DamagedHelmet/glTF/DamagedHelmet.gltf"));
scene.then(async (result: Scene) => {});
}
```
模型加载成功后，可通过SceneResourceFactory实例创建相机、光源等，再对相机和光源的参数做调节，调整观察角度和光照效果。最后，将Scene实例和ModelType作为SceneOptions传给Component3D组件显示到屏幕。
模型显示完整的示例代码如下，需确保gltf文件内容和路径准确。
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
@Entry
@Component
struct Model {
scene: Scene | null = null;
@State sceneOpt: SceneOptions | null = null;
cam: Camera | null = null;
onPageShow(): void {
this.Init();
}
Init(): void {
if (this.scene == null) {
// 加载模型，将gltf文件放置到相关路径，加载时以实际路径为准
Scene.load($rawfile('gltf/DamagedHelmet/glTF/DamagedHelmet.gltf'))
.then(async (result: Scene) => {
this.scene = result;
let rf:SceneResourceFactory = this.scene.getResourceFactory();
// 创建相机
this.cam = await rf.createCamera({ "name": "Camera" });
// 设置合适的相机参数
this.cam.enabled = true;
this.cam.position.z = 5;
this.sceneOpt = { scene: this.scene, modelType: ModelType.SURFACE } as SceneOptions;
})
.catch((reason: string) => {
console.log(reason);
});
}
}
build() {
Row() {
Column() {
if (this.sceneOpt) {
// 通过Component3D呈现3D场景
Component3D(this.sceneOpt)
} else {
Text("loading ...")
}
}.width('100%')
}.height('60%')
}
}
```
相机的创建及管理
相机作为3D场景中的重要部分，决定了整个3D场景向2D图片的投影过程，相机的近远平面、Fov角等关键参数也会对整个3D渲染产生重要的影响。开发者可以通过对于相机参数的设置。控制这个渲染过程，得到开发者想要的渲染效果。
相机相关控制的示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createCameraPromise() : Promise<Camera> {
return new Promise(() => {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
let sceneFactory: SceneResourceFactory = result.getResourceFactory();
let sceneCameraParameter: SceneNodeParameters = { name: "camera1" };
// 创建相机
let camera: Promise<Camera> = sceneFactory.createCamera(sceneCameraParameter);
camera.then(async (cameraEntity: Camera) => {
// 使能相机节点
cameraEntity.enabled = true;
// 设置相机的位置
cameraEntity.position.z = 5;
// 设置相机Fov参数
cameraEntity.fov = 60 * Math.PI / 180;
// 可以参照此方式设置相机很多其他的参数
// ...
});
return camera;
});
});
}
```
光源的创建及管理
3D场景的光源是对于物理世界中光源的一种数据建模，模拟物理世界的光源对于3D场景中的物体产生影响。
光源具有很多的类型，比如平行光、锥形光。平行光即是用来模拟生活中的太阳光照，发出的光线处处平行且强度均匀。锥形光则像是我们使用的手电筒，以一个点向一个扇形区域发射光线，且发出的光线会随着距离而衰减。光源的颜色也会对场景中的物体最终的着色产生影响，光源颜色与物体颜色相互作用的计算与真实物理世界保持一致。ArkGraphics 3D提供了创建光源，修改光源各种参数的能力，支撑开发者通过对于光源属性的设置对于3D场景进行调整，得到期望的渲染效果。
光源相关控制的示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createLightPromise() : Promise<Light> {
return new Promise(() => {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
let sceneFactory: SceneResourceFactory = result.getResourceFactory();
let sceneLightParameter: SceneNodeParameters = { name: "light" };
// 创建平行光
let light: Promise<Light> = sceneFactory.createLight(sceneLightParameter, LightType.DIRECTIONAL);
light.then(async (lightEntity: Light) => {
// 设置平行光的颜色属性
lightEntity.color = { r: 0.8, g: 0.1, b: 0.2, a: 1.0 };
// 可以参照此方式设置光源很多其他的参数
// ...
});
return light;
});
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics-3d-V14
爬取时间: 2025-04-29 19:39:52
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics3d-resource-V14
爬取时间: 2025-04-29 19:40:02
来源: Huawei Developer
3D场景中资源类型主要包含以下几种：
材质的创建及使用
材质的关键属性包括名字和类型，以此为输入可以创建材质。示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createMaterialPromise() : Promise<Material> {
return new Promise(() => {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
let sceneFactory: SceneResourceFactory = result.getResourceFactory();
let sceneMaterialParameter: SceneResourceParameters = { name: "material" };
// 创建材质
let material: Promise<Material> = sceneFactory.createMaterial(sceneMaterialParameter, MaterialType.SHADER);
return material;
});
});
}
```
着色器资源的创建及使用
着色器主要用于控制GPU计算，给开发者提供自定义渲染的能力，提高了3D渲染控制的灵活性。着色器资源的创建需要着色器资源的名字以及着色器在文件沙箱中的路径。着色器资源主要的使用场景是替换材质的着色器属性，给材质自定义渲染算法，达到灵活控制渲染过程的目的，示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createShaderPromise() : Promise<Shader> {
return new Promise(() => {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
let sceneFactory: SceneResourceFactory = result.getResourceFactory();
// 创建SceneResourceParameters类型变量并以此创建shader
let sceneResourceParameter: SceneResourceParameters = { name: "shaderResource",
uri: $rawfile("shaders/custom_shader/custom_material_sample.shader") };
let shader: Promise<Shader> = sceneFactory.createShader(sceneResourceParameter);
shader.then(async (shaderEntity: Shader) => {
let sceneMaterialParameter: SceneResourceParameters = { name: "material" };
// 创建材质
let material: Promise<Material> = sceneFactory.createMaterial(sceneMaterialParameter, MaterialType.SHADER);
material.then(async (materialEntity: ShaderMaterial) => {
// 绑定材质与shader
materialEntity.colorShader = shaderEntity;
});
});
return shader;
});
});
}
```
图片资源的创建及使用
3D场景中的图片资源是指GPU可以直接使用的图片资源。创建图片资源的关键参数包括图片资源的名字以及图片资源的路径。将图片资源应用到材质中作为材质属性，是常见的图片资源使用方式之一，示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createImagePromise() : Promise<Image> {
return new Promise(() => {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
let sceneFactory: SceneResourceFactory = result.getResourceFactory();
let sceneImageParameter: SceneResourceParameters = { name: "image", uri: $rawfile("bricks.jpg") };
// 创建Image
let image: Promise<Image> = sceneFactory.createImage(sceneImageParameter);
image.then(async (imageEntity: Image) => {
let sceneMaterialParameter: SceneResourceParameters = { name: "material" };
// 创建材质
let material: Promise<Material> = sceneFactory.createMaterial(sceneMaterialParameter, MaterialType.SHADER);
material.then(async (materialEntity: ShaderMaterial) => {
// 利用创建的图片资源设置纹理属性
if (materialEntity && materialEntity.colorShader) {
materialEntity.colorShader.inputs["BASE_COLOR_Image"] = imageEntity;
}
});
});
return image;
});
});
}
```
环境资源的创建及使用
环境资源的创建需要指定名字以及图片或者glTF在文件沙箱中的路径，将环境资源设置到3D scene的environment属性，即可以将创建的环境资源设置为3D场景的背景环境。环境资源提供了diffuseFactor、specularFactor等的属性，支撑开发者对于环境资源属性进行控制。示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createEnvironmentPromise() : Promise<Environment> {
return new Promise(() => {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
let sceneFactory: SceneResourceFactory = result.getResourceFactory();
let sceneEnvironmentParameter: SceneResourceParameters = { name: "env", uri: $rawfile("bricks.ktx") };
// 创建Environment
let env: Promise<Environment> = sceneFactory.createEnvironment(sceneEnvironmentParameter);
env.then(async (envEntity: Environment) => {
// 设置env相关属性
envEntity.indirectDiffuseFactor.x = 1;
envEntity.indirectDiffuseFactor.y = 1;
envEntity.indirectDiffuseFactor.z = 1;
envEntity.indirectDiffuseFactor.w = 1;
});
return env;
});
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics3d-overview-V14
爬取时间: 2025-04-29 19:40:05
来源: Huawei Developer
ArkGraphics 3D （方舟3D图形）基于轻量级的3D引擎以及渲染管线为开发者提供基础3D场景绘制能力，供开发者便捷、高效地构建3D场景并完成渲染。
功能介绍
综上，ArkGraphics 3D提供基础的3D场景渲染能力，支撑开发者完成3D场景渲染以及逻辑控制开发工作。
具体接口的使用和参数说明，可见@ohos.graphics.scene (ArkGraphics 3D模块)。
框架原理
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165919.37844941142559602040099398678657:50001231000000:2800:5D3059FE92E2B4B0E5343FEB668BE810457799ED6644ECAADF7E6811D38CFDE1.png)
如上图 ArkGraphics 3D接口能力由图形后端、引擎层以及接口层三个关键部分共同组成。
约束限制
使用ArkGraphics 3D模块需要硬件设备支持OpenGL ES 3.2以上或者Vulkan 1.0以上的GPU驱动。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics3d-animation-V14
爬取时间: 2025-04-29 19:40:15
来源: Huawei Developer
动画是3D场景中重要的资源类型，用于控制场景中各种元素的运动。比如想要场景中的人物进行走路这个动作，每帧计算人物每一个关节的旋转角并进行设置是难以实现的。所以在完成类似的要求时，3D场景资源的制作者会将动画制作好，在模型文件中保存动画的关键帧数据以及关键帧间的插值器类型。ArkGraphics 3D提供播放并控制场景动画的能力，支持开发者灵活地控制动画的状态，达到预期的渲染效果。
动画资源的创建
动画资源是模型资源制作者在制作模型的过程中制作并保存到模型文件中的。ArkGraphics 3D提供从glTF模型资源中提取并播放动画的能力，进而使得开发者可以进行动画状态的控制。
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createAnimation() : void {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
if (result) {
// 获取动画资源
let anim: Animation = result.animations[0];
}
});
}
```
动画状态的控制
ArkGraphics 3D提供的动画状态控制操作主要包含如下几种：
示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function animationControl() : void {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
if (result) {
let anim: Animation = result.animations[0];
// 动画状态控制
anim.start();
anim.pause();
anim.stop();
anim.restart();
anim.finish();
}
});
}
```
动画回调的使用
动画回调指的是在动画执行到某些状态时执行的函数，用于帮助开发者以动画状态为基础做触发式的逻辑控制工作。ArkGraphics 3D提供给开发者如下回调：
示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function callBacks() : void {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
if (result) {
let anim: Animation = result.animations[0];
// 注册回调函数
anim.onFinished(()=>{
console.info("onFinished");
});
anim.onStarted(()=>{
console.info("onStarted");
});
}
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics3d-scene-V14
爬取时间: 2025-04-29 19:40:19
来源: Huawei Developer
一个3D场景通常由光源、相机、模型三个关键部分组成。
模型加载后，可以通过ArkUI的Component3D渲染组件呈现给用户，Component3D也可以对3D模型做自定义渲染。开发者也可以使用ArkTS API对相机和光源进行调节，获得合适的观察角度和光照效果。ArkTS API可通过napi调用AGP中由C++实现的相应能力。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165919.46309223082569534765616335864648:50001231000000:2800:D2F03E9476A7F32FC77B328EB9F6741F153941B7D34C35C75DF3998E1DC8A2F2.png)
模型的加载及呈现
模型的格式多种多样，目前ArkGraphics 3D仅支持glTF模型的加载，glTF是一种对于3D场景描述的格式，glTF作为一种开源3D场景格式在业界被广泛采用。关于glTF的介绍可以参照glTF-2.0。
一个glTF模型可以包含光源、相机、模型等3D场景关键要素，如果一个glTF模型中包含相机，使用ArkGraphics 3D提供的接口加载glTF就可以直接完成该相机视角下3D场景的渲染。如果不包含相机，也可以利用ArkGraphics 3D创建一个相机完成渲染。由于3D模型往往数据量很大，通常采用异步方式进行加载，加载成功后将返回一个scene对象，通过该对象可对整个3D场景进行编辑。
glTF模型可用Scene提供的load接口加载，示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function loadModel() : void {
// 加载模型
let scene: Promise<Scene> = Scene.load($rawfile("gltf/DamagedHelmet/glTF/DamagedHelmet.gltf"));
scene.then(async (result: Scene) => {});
}
```
模型加载成功后，可通过SceneResourceFactory实例创建相机、光源等，再对相机和光源的参数做调节，调整观察角度和光照效果。最后，将Scene实例和ModelType作为SceneOptions传给Component3D组件显示到屏幕。
模型显示完整的示例代码如下，需确保gltf文件内容和路径准确。
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
@Entry
@Component
struct Model {
scene: Scene | null = null;
@State sceneOpt: SceneOptions | null = null;
cam: Camera | null = null;
onPageShow(): void {
this.Init();
}
Init(): void {
if (this.scene == null) {
// 加载模型，将gltf文件放置到相关路径，加载时以实际路径为准
Scene.load($rawfile('gltf/DamagedHelmet/glTF/DamagedHelmet.gltf'))
.then(async (result: Scene) => {
this.scene = result;
let rf:SceneResourceFactory = this.scene.getResourceFactory();
// 创建相机
this.cam = await rf.createCamera({ "name": "Camera" });
// 设置合适的相机参数
this.cam.enabled = true;
this.cam.position.z = 5;
this.sceneOpt = { scene: this.scene, modelType: ModelType.SURFACE } as SceneOptions;
})
.catch((reason: string) => {
console.log(reason);
});
}
}
build() {
Row() {
Column() {
if (this.sceneOpt) {
// 通过Component3D呈现3D场景
Component3D(this.sceneOpt)
} else {
Text("loading ...")
}
}.width('100%')
}.height('60%')
}
}
```
相机的创建及管理
相机作为3D场景中的重要部分，决定了整个3D场景向2D图片的投影过程，相机的近远平面、Fov角等关键参数也会对整个3D渲染产生重要的影响。开发者可以通过对于相机参数的设置。控制这个渲染过程，得到开发者想要的渲染效果。
相机相关控制的示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createCameraPromise() : Promise<Camera> {
return new Promise(() => {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
let sceneFactory: SceneResourceFactory = result.getResourceFactory();
let sceneCameraParameter: SceneNodeParameters = { name: "camera1" };
// 创建相机
let camera: Promise<Camera> = sceneFactory.createCamera(sceneCameraParameter);
camera.then(async (cameraEntity: Camera) => {
// 使能相机节点
cameraEntity.enabled = true;
// 设置相机的位置
cameraEntity.position.z = 5;
// 设置相机Fov参数
cameraEntity.fov = 60 * Math.PI / 180;
// 可以参照此方式设置相机很多其他的参数
// ...
});
return camera;
});
});
}
```
光源的创建及管理
3D场景的光源是对于物理世界中光源的一种数据建模，模拟物理世界的光源对于3D场景中的物体产生影响。
光源具有很多的类型，比如平行光、锥形光。平行光即是用来模拟生活中的太阳光照，发出的光线处处平行且强度均匀。锥形光则像是我们使用的手电筒，以一个点向一个扇形区域发射光线，且发出的光线会随着距离而衰减。光源的颜色也会对场景中的物体最终的着色产生影响，光源颜色与物体颜色相互作用的计算与真实物理世界保持一致。ArkGraphics 3D提供了创建光源，修改光源各种参数的能力，支撑开发者通过对于光源属性的设置对于3D场景进行调整，得到期望的渲染效果。
光源相关控制的示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createLightPromise() : Promise<Light> {
return new Promise(() => {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
let sceneFactory: SceneResourceFactory = result.getResourceFactory();
let sceneLightParameter: SceneNodeParameters = { name: "light" };
// 创建平行光
let light: Promise<Light> = sceneFactory.createLight(sceneLightParameter, LightType.DIRECTIONAL);
light.then(async (lightEntity: Light) => {
// 设置平行光的颜色属性
lightEntity.color = { r: 0.8, g: 0.1, b: 0.2, a: 1.0 };
// 可以参照此方式设置光源很多其他的参数
// ...
});
return light;
});
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-kit-guide-V14
爬取时间: 2025-04-29 19:40:29
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics3d-resource-V14
爬取时间: 2025-04-29 19:40:32
来源: Huawei Developer
3D场景中资源类型主要包含以下几种：
材质的创建及使用
材质的关键属性包括名字和类型，以此为输入可以创建材质。示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createMaterialPromise() : Promise<Material> {
return new Promise(() => {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
let sceneFactory: SceneResourceFactory = result.getResourceFactory();
let sceneMaterialParameter: SceneResourceParameters = { name: "material" };
// 创建材质
let material: Promise<Material> = sceneFactory.createMaterial(sceneMaterialParameter, MaterialType.SHADER);
return material;
});
});
}
```
着色器资源的创建及使用
着色器主要用于控制GPU计算，给开发者提供自定义渲染的能力，提高了3D渲染控制的灵活性。着色器资源的创建需要着色器资源的名字以及着色器在文件沙箱中的路径。着色器资源主要的使用场景是替换材质的着色器属性，给材质自定义渲染算法，达到灵活控制渲染过程的目的，示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createShaderPromise() : Promise<Shader> {
return new Promise(() => {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
let sceneFactory: SceneResourceFactory = result.getResourceFactory();
// 创建SceneResourceParameters类型变量并以此创建shader
let sceneResourceParameter: SceneResourceParameters = { name: "shaderResource",
uri: $rawfile("shaders/custom_shader/custom_material_sample.shader") };
let shader: Promise<Shader> = sceneFactory.createShader(sceneResourceParameter);
shader.then(async (shaderEntity: Shader) => {
let sceneMaterialParameter: SceneResourceParameters = { name: "material" };
// 创建材质
let material: Promise<Material> = sceneFactory.createMaterial(sceneMaterialParameter, MaterialType.SHADER);
material.then(async (materialEntity: ShaderMaterial) => {
// 绑定材质与shader
materialEntity.colorShader = shaderEntity;
});
});
return shader;
});
});
}
```
图片资源的创建及使用
3D场景中的图片资源是指GPU可以直接使用的图片资源。创建图片资源的关键参数包括图片资源的名字以及图片资源的路径。将图片资源应用到材质中作为材质属性，是常见的图片资源使用方式之一，示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createImagePromise() : Promise<Image> {
return new Promise(() => {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
let sceneFactory: SceneResourceFactory = result.getResourceFactory();
let sceneImageParameter: SceneResourceParameters = { name: "image", uri: $rawfile("bricks.jpg") };
// 创建Image
let image: Promise<Image> = sceneFactory.createImage(sceneImageParameter);
image.then(async (imageEntity: Image) => {
let sceneMaterialParameter: SceneResourceParameters = { name: "material" };
// 创建材质
let material: Promise<Material> = sceneFactory.createMaterial(sceneMaterialParameter, MaterialType.SHADER);
material.then(async (materialEntity: ShaderMaterial) => {
// 利用创建的图片资源设置纹理属性
if (materialEntity && materialEntity.colorShader) {
materialEntity.colorShader.inputs["BASE_COLOR_Image"] = imageEntity;
}
});
});
return image;
});
});
}
```
环境资源的创建及使用
环境资源的创建需要指定名字以及图片或者glTF在文件沙箱中的路径，将环境资源设置到3D scene的environment属性，即可以将创建的环境资源设置为3D场景的背景环境。环境资源提供了diffuseFactor、specularFactor等的属性，支撑开发者对于环境资源属性进行控制。示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createEnvironmentPromise() : Promise<Environment> {
return new Promise(() => {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
let sceneFactory: SceneResourceFactory = result.getResourceFactory();
let sceneEnvironmentParameter: SceneResourceParameters = { name: "env", uri: $rawfile("bricks.ktx") };
// 创建Environment
let env: Promise<Environment> = sceneFactory.createEnvironment(sceneEnvironmentParameter);
env.then(async (envEntity: Environment) => {
// 设置env相关属性
envEntity.indirectDiffuseFactor.x = 1;
envEntity.indirectDiffuseFactor.y = 1;
envEntity.indirectDiffuseFactor.z = 1;
envEntity.indirectDiffuseFactor.w = 1;
});
return env;
});
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-introduction-V14
爬取时间: 2025-04-29 19:40:42
来源: Huawei Developer
Graphics Accelerate Kit（图形加速服务）作为软硬件协同的系统级图形加速解决方案，帮助游戏应用快速构建超帧、ABR（自适应稳态渲染）、OpenGTX（Open GPU Turbo X）等游戏渲染加速能力，解决游戏运行不流畅、卡顿掉帧、长时间运行造成发热发烫等痛点体验问题。
| 功能模块  | 描述  |
| --- | --- |
| 超帧  | 针对GPU重负载的高目标帧率游戏场景，超帧利用渲染管线中的时域和空域信息，通过软硬件结合的MEMC（运动估计、运动补偿）技术，在游戏原生真实渲染帧间高效插入预测帧。在最大程度保持原始渲染画质前提下，有效提升游戏帧率和运行流畅度，降低系统负载和功耗，延长手机的续航时间。  |
| ABR  | 针对GPU重负载游戏场景，通过感知游戏、设备状态，自适应决策分辨率缩放因子，并基于FrameBuffer（帧缓冲，下文简称Buffer）调整分辨率，帮助游戏应用实现更稳定的帧率、更低的功耗。  |
| OpenGTX  | 针对高帧率重负载游戏场景，LTPO（动态帧率/刷新率）等方案通过实时感知游戏渲染状态、游戏场景、设备状态等信息，自适应调整游戏的帧率、设备的SOC/DDR频率，在不影响用户游戏体验的前提下，有效降低系统负载和功耗。  |
功能模块
描述
超帧
针对GPU重负载的高目标帧率游戏场景，超帧利用渲染管线中的时域和空域信息，通过软硬件结合的MEMC（运动估计、运动补偿）技术，在游戏原生真实渲染帧间高效插入预测帧。在最大程度保持原始渲染画质前提下，有效提升游戏帧率和运行流畅度，降低系统负载和功耗，延长手机的续航时间。
ABR
针对GPU重负载游戏场景，通过感知游戏、设备状态，自适应决策分辨率缩放因子，并基于FrameBuffer（帧缓冲，下文简称Buffer）调整分辨率，帮助游戏应用实现更稳定的帧率、更低的功耗。
OpenGTX
针对高帧率重负载游戏场景，LTPO（动态帧率/刷新率）等方案通过实时感知游戏渲染状态、游戏场景、设备状态等信息，自适应调整游戏的帧率、设备的SOC/DDR频率，在不影响用户游戏体验的前提下，有效降低系统负载和功耗。
场景介绍
超帧
| 超帧模式  | 适用场景  |
| --- | --- |
| 内插模式  | 适用于对渲染画质和运行流畅度要求高的游戏，如角色扮演游戏、竞速类游戏等。  |
| 外插模式  | 适用于对响应时延和操作跟手性要求高的游戏，如动作类游戏、射击类游戏等。  |
超帧模式
适用场景
内插模式
适用于对渲染画质和运行流畅度要求高的游戏，如角色扮演游戏、竞速类游戏等。
外插模式
适用于对响应时延和操作跟手性要求高的游戏，如动作类游戏、射击类游戏等。
ABR
| ABR策略  | 适用场景  |
| --- | --- |
| 基于相机运动的感知策略  | 适用于竞速类游戏、角色扮演类游戏、射击类游戏等，在加速、奔跑、视角旋转等场景自适应调整Buffer分辨率，在用户对画质影响感知不明显的前提下，帮助游戏应用实现更稳定的帧率、更低的功耗。  |
ABR策略
适用场景
基于相机运动的感知策略
适用于竞速类游戏、角色扮演类游戏、射击类游戏等，在加速、奔跑、视角旋转等场景自适应调整Buffer分辨率，在用户对画质影响感知不明显的前提下，帮助游戏应用实现更稳定的帧率、更低的功耗。
OpenGTX
| LTPO模式  | 适用场景  |
| --- | --- |
| SCENE_MODE  | 根据场景设置不同的游戏帧率，如游戏场景120fps。  |
| TOUCH_MODE  | 根据触控频率设置游戏帧率。  |
| ADAPTIVE_MODE  | 根据场景、相机、触控等自适应控制游戏帧率，包含SCENE_MODE和TOUCH_MODE。  |
LTPO模式
适用场景
SCENE_MODE
根据场景设置不同的游戏帧率，如游戏场景120fps。
TOUCH_MODE
根据触控频率设置游戏帧率。
ADAPTIVE_MODE
根据场景、相机、触控等自适应控制游戏帧率，包含SCENE_MODE和TOUCH_MODE。
产品优势
-  游戏应用集成超帧、ABR后，在无画质损耗的基础上，可有效稳定或提升游戏运行帧率，减少卡顿和掉帧现象，使游戏运行更加稳定、流畅。集成OpenGTX后，通过感知游戏场景、设备状态等关键信息，动态调整游戏的帧率/刷新率以及设备的SOC/DDR频率，从而做到稳定帧率，保障游戏在终端设备上流畅运行。
-  游戏应用集成超帧、ABR后，在GPU重负载游戏场景，单帧功耗可降低10%及以上，可有效降低GPU负载和系统功耗，减轻手机发热现象，延长续航时间。集成OpenGTX后，通过对游戏的帧率控制以及设备的SOC频率控制，在满足用户游戏体验的前提下，最大限度的降低设备的性能开销，从而做到降低功耗减少发热，提升设备的续航时间。
约束与限制
超帧
-  运动估计模式 开发准备 场景约束 基础模式 - 适用于相机或场景中物体静止以及慢速运动的游戏场景。在高速运动目标场景及复杂粒子特效场景可能引入拖影和鬼影。 增强模式 需要开发者对绘制顶点的draw call进行标记。相比基础模式，增强模式利用三维场景中的顶点信息进行更精准的运动估计，超帧效果更优。 1、对于相机或物体慢速和快速运动场景均具有较好超帧效果，较“基础模式”能有效优化运动拖影现象。但在复杂粒子特效场景可能引入鬼影。 2、超帧增强模式仅支持OpenGL ES图形API平台，Vulkan平台暂不支持。
| 运动估计模式  | 开发准备  | 场景约束  |
| --- | --- | --- |
| 基础模式  | -  | 适用于相机或场景中物体静止以及慢速运动的游戏场景。在高速运动目标场景及复杂粒子特效场景可能引入拖影和鬼影。  |
| 增强模式  | 需要开发者对绘制顶点的draw call进行标记。相比基础模式，增强模式利用三维场景中的顶点信息进行更精准的运动估计，超帧效果更优。  | 1、对于相机或物体慢速和快速运动场景均具有较好超帧效果，较“基础模式”能有效优化运动拖影现象。但在复杂粒子特效场景可能引入鬼影。 2、超帧增强模式仅支持OpenGL ES图形API平台，Vulkan平台暂不支持。  |
ABR
OpenGTX

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkgraphics3d-animation-V14
爬取时间: 2025-04-29 19:40:45
来源: Huawei Developer
动画是3D场景中重要的资源类型，用于控制场景中各种元素的运动。比如想要场景中的人物进行走路这个动作，每帧计算人物每一个关节的旋转角并进行设置是难以实现的。所以在完成类似的要求时，3D场景资源的制作者会将动画制作好，在模型文件中保存动画的关键帧数据以及关键帧间的插值器类型。ArkGraphics 3D提供播放并控制场景动画的能力，支持开发者灵活地控制动画的状态，达到预期的渲染效果。
动画资源的创建
动画资源是模型资源制作者在制作模型的过程中制作并保存到模型文件中的。ArkGraphics 3D提供从glTF模型资源中提取并播放动画的能力，进而使得开发者可以进行动画状态的控制。
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function createAnimation() : void {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
if (result) {
// 获取动画资源
let anim: Animation = result.animations[0];
}
});
}
```
动画状态的控制
ArkGraphics 3D提供的动画状态控制操作主要包含如下几种：
示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function animationControl() : void {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
if (result) {
let anim: Animation = result.animations[0];
// 动画状态控制
anim.start();
anim.pause();
anim.stop();
anim.restart();
anim.finish();
}
});
}
```
动画回调的使用
动画回调指的是在动画执行到某些状态时执行的函数，用于帮助开发者以动画状态为基础做触发式的逻辑控制工作。ArkGraphics 3D提供给开发者如下回调：
示例代码如下：
```typescript
import { Image, Shader, MaterialType, Material, ShaderMaterial, Animation, Environment, Container, SceneNodeParameters,
LightType, Light, Camera, SceneResourceParameters, SceneResourceFactory, Scene, Node } from '@kit.ArkGraphics3D';
function callBacks() : void {
let scene: Promise<Scene> = Scene.load($rawfile("gltf/CubeWithFloor/glTF/AnimatedCube.gltf"));
scene.then(async (result: Scene) => {
if (result) {
let anim: Animation = result.animations[0];
// 注册回调函数
anim.onFinished(()=>{
console.info("onFinished");
});
anim.onStarted(()=>{
console.info("onStarted");
});
}
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-V14
爬取时间: 2025-04-29 19:40:57
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-kit-guide-V14
爬取时间: 2025-04-29 19:40:58
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-interpolation-V14
爬取时间: 2025-04-29 19:41:10
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-introduction-V14
爬取时间: 2025-04-29 19:41:12
来源: Huawei Developer
Graphics Accelerate Kit（图形加速服务）作为软硬件协同的系统级图形加速解决方案，帮助游戏应用快速构建超帧、ABR（自适应稳态渲染）、OpenGTX（Open GPU Turbo X）等游戏渲染加速能力，解决游戏运行不流畅、卡顿掉帧、长时间运行造成发热发烫等痛点体验问题。
| 功能模块  | 描述  |
| --- | --- |
| 超帧  | 针对GPU重负载的高目标帧率游戏场景，超帧利用渲染管线中的时域和空域信息，通过软硬件结合的MEMC（运动估计、运动补偿）技术，在游戏原生真实渲染帧间高效插入预测帧。在最大程度保持原始渲染画质前提下，有效提升游戏帧率和运行流畅度，降低系统负载和功耗，延长手机的续航时间。  |
| ABR  | 针对GPU重负载游戏场景，通过感知游戏、设备状态，自适应决策分辨率缩放因子，并基于FrameBuffer（帧缓冲，下文简称Buffer）调整分辨率，帮助游戏应用实现更稳定的帧率、更低的功耗。  |
| OpenGTX  | 针对高帧率重负载游戏场景，LTPO（动态帧率/刷新率）等方案通过实时感知游戏渲染状态、游戏场景、设备状态等信息，自适应调整游戏的帧率、设备的SOC/DDR频率，在不影响用户游戏体验的前提下，有效降低系统负载和功耗。  |
功能模块
描述
超帧
针对GPU重负载的高目标帧率游戏场景，超帧利用渲染管线中的时域和空域信息，通过软硬件结合的MEMC（运动估计、运动补偿）技术，在游戏原生真实渲染帧间高效插入预测帧。在最大程度保持原始渲染画质前提下，有效提升游戏帧率和运行流畅度，降低系统负载和功耗，延长手机的续航时间。
ABR
针对GPU重负载游戏场景，通过感知游戏、设备状态，自适应决策分辨率缩放因子，并基于FrameBuffer（帧缓冲，下文简称Buffer）调整分辨率，帮助游戏应用实现更稳定的帧率、更低的功耗。
OpenGTX
针对高帧率重负载游戏场景，LTPO（动态帧率/刷新率）等方案通过实时感知游戏渲染状态、游戏场景、设备状态等信息，自适应调整游戏的帧率、设备的SOC/DDR频率，在不影响用户游戏体验的前提下，有效降低系统负载和功耗。
场景介绍
超帧
| 超帧模式  | 适用场景  |
| --- | --- |
| 内插模式  | 适用于对渲染画质和运行流畅度要求高的游戏，如角色扮演游戏、竞速类游戏等。  |
| 外插模式  | 适用于对响应时延和操作跟手性要求高的游戏，如动作类游戏、射击类游戏等。  |
超帧模式
适用场景
内插模式
适用于对渲染画质和运行流畅度要求高的游戏，如角色扮演游戏、竞速类游戏等。
外插模式
适用于对响应时延和操作跟手性要求高的游戏，如动作类游戏、射击类游戏等。
ABR
| ABR策略  | 适用场景  |
| --- | --- |
| 基于相机运动的感知策略  | 适用于竞速类游戏、角色扮演类游戏、射击类游戏等，在加速、奔跑、视角旋转等场景自适应调整Buffer分辨率，在用户对画质影响感知不明显的前提下，帮助游戏应用实现更稳定的帧率、更低的功耗。  |
ABR策略
适用场景
基于相机运动的感知策略
适用于竞速类游戏、角色扮演类游戏、射击类游戏等，在加速、奔跑、视角旋转等场景自适应调整Buffer分辨率，在用户对画质影响感知不明显的前提下，帮助游戏应用实现更稳定的帧率、更低的功耗。
OpenGTX
| LTPO模式  | 适用场景  |
| --- | --- |
| SCENE_MODE  | 根据场景设置不同的游戏帧率，如游戏场景120fps。  |
| TOUCH_MODE  | 根据触控频率设置游戏帧率。  |
| ADAPTIVE_MODE  | 根据场景、相机、触控等自适应控制游戏帧率，包含SCENE_MODE和TOUCH_MODE。  |
LTPO模式
适用场景
SCENE_MODE
根据场景设置不同的游戏帧率，如游戏场景120fps。
TOUCH_MODE
根据触控频率设置游戏帧率。
ADAPTIVE_MODE
根据场景、相机、触控等自适应控制游戏帧率，包含SCENE_MODE和TOUCH_MODE。
产品优势
-  游戏应用集成超帧、ABR后，在无画质损耗的基础上，可有效稳定或提升游戏运行帧率，减少卡顿和掉帧现象，使游戏运行更加稳定、流畅。集成OpenGTX后，通过感知游戏场景、设备状态等关键信息，动态调整游戏的帧率/刷新率以及设备的SOC/DDR频率，从而做到稳定帧率，保障游戏在终端设备上流畅运行。
-  游戏应用集成超帧、ABR后，在GPU重负载游戏场景，单帧功耗可降低10%及以上，可有效降低GPU负载和系统功耗，减轻手机发热现象，延长续航时间。集成OpenGTX后，通过对游戏的帧率控制以及设备的SOC频率控制，在满足用户游戏体验的前提下，最大限度的降低设备的性能开销，从而做到降低功耗减少发热，提升设备的续航时间。
约束与限制
超帧
-  运动估计模式 开发准备 场景约束 基础模式 - 适用于相机或场景中物体静止以及慢速运动的游戏场景。在高速运动目标场景及复杂粒子特效场景可能引入拖影和鬼影。 增强模式 需要开发者对绘制顶点的draw call进行标记。相比基础模式，增强模式利用三维场景中的顶点信息进行更精准的运动估计，超帧效果更优。 1、对于相机或物体慢速和快速运动场景均具有较好超帧效果，较“基础模式”能有效优化运动拖影现象。但在复杂粒子特效场景可能引入鬼影。 2、超帧增强模式仅支持OpenGL ES图形API平台，Vulkan平台暂不支持。
| 运动估计模式  | 开发准备  | 场景约束  |
| --- | --- | --- |
| 基础模式  | -  | 适用于相机或场景中物体静止以及慢速运动的游戏场景。在高速运动目标场景及复杂粒子特效场景可能引入拖影和鬼影。  |
| 增强模式  | 需要开发者对绘制顶点的draw call进行标记。相比基础模式，增强模式利用三维场景中的顶点信息进行更精准的运动估计，超帧效果更优。  | 1、对于相机或物体慢速和快速运动场景均具有较好超帧效果，较“基础模式”能有效优化运动拖影现象。但在复杂粒子特效场景可能引入鬼影。 2、超帧增强模式仅支持OpenGL ES图形API平台，Vulkan平台暂不支持。  |
ABR
OpenGTX

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-interpolation-overview-V14
爬取时间: 2025-04-29 19:41:24
来源: Huawei Developer
超帧内插模式是利用相邻两个真实渲染帧进行超帧计算生成中间的预测帧，即利用第N-1帧和第N帧真实渲染帧预测第N-0.5帧预测帧，如下图所示。由于中间预测帧的像素点通常能在前后两帧中找到对应位置，因此内插模式的预测帧效果较外插模式更优。由于第N帧真实渲染帧需要等待第N-0.5帧预测帧生成并送显后才能最终送显，因此会新增1~2帧的响应时延。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165919.32973602539344579408958675919692:50001231000000:2800:FCFB9D132022B1CDC27922672D0F5243A26BE27638447F667621747864412C8C.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-V14
爬取时间: 2025-04-29 19:41:25
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-interpolation-gles-V14
爬取时间: 2025-04-29 19:41:37
来源: Huawei Developer
业务流程
基于OpenGL ES图形API平台，集成超帧内插模式的主要业务流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165919.55002521102799074487244112521921:50001231000000:2800:34902C179AAFA7DDC42C553AEAC83211F00BE532D4A77CF747C51E0E8EE60953.png)
开发步骤
本节阐述基于OpenGL ES图形API平台的超帧调用示例，详细代码请参考图形开发Sample（超帧GLES）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-interpolation-V14
爬取时间: 2025-04-29 19:41:38
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-interpolation-vulkan-V14
爬取时间: 2025-04-29 19:41:51
来源: Huawei Developer
业务流程
基于Vulkan图形API平台，集成超帧内插模式的主要业务流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165920.80281367104693487941691555807472:50001231000000:2800:99D95E33C81E3DC5C3E158BD14E364C5FD0E5F08D3F9F5044930D80A7E36C945.png)
开发步骤
本节阐述基于Vulkan图形API平台的超帧调用示例，详细代码请参考图形开发Sample（超帧Vulkan）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-extrapolation-V14
爬取时间: 2025-04-29 19:42:04
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-extrapolation-overview-V14
爬取时间: 2025-04-29 19:42:18
来源: Huawei Developer
超帧外插模式是利用相邻两个真实渲染帧进行超帧计算并生成未来一帧预测帧，即利用第N-1帧、第N帧真实帧预测第N+0.5帧预测帧，如下图所示。由于外插模式不改变渲染时间线和显示时间线的帧间顺序，因此不会导致响应时延的增加。但由于外插模式预测的是未来帧画面，当发生场景画面帧间差异大、相机或物体运动方向突变时，在预测帧的画面边缘和物体边缘容易出现拖影和模糊现象。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165921.42317609695427229283139001234266:50001231000000:2800:45B612F837109668208AE609E25FC33EFB4A46794C5599C47203D9AE1DCFE019.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-extrapolation-gles-V14
爬取时间: 2025-04-29 19:42:31
来源: Huawei Developer
业务流程
基于OpenGL ES图形API平台，集成超帧外插模式的主要业务流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165921.01015038885931307557741606961308:50001231000000:2800:CFDD74642EB9AC57A47FA7031EAE7A7D1D17546623D3975C55772AB26DE93C02.png)
开发步骤
外插模式需要标记模板缓冲的第8位，用于区分静态物体和动态物体。静态物体所占区域的模板值需标记为0xxx xxxx，动态物体所占区域的模板值需标记为1xxx xxxx，模板缓冲的低7位模板值开发者可自行设置。如果标记错误或漏标记，可能会造成超帧预测效果不准确，如运动物体边缘区域拖影等现象。
本节阐述基于OpenGL ES图形API平台的超帧调用示例，详细代码请参考图形开发Sample（超帧GLES）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-interpolation-overview-V14
爬取时间: 2025-04-29 19:42:32
来源: Huawei Developer
超帧内插模式是利用相邻两个真实渲染帧进行超帧计算生成中间的预测帧，即利用第N-1帧和第N帧真实渲染帧预测第N-0.5帧预测帧，如下图所示。由于中间预测帧的像素点通常能在前后两帧中找到对应位置，因此内插模式的预测帧效果较外插模式更优。由于第N帧真实渲染帧需要等待第N-0.5帧预测帧生成并送显后才能最终送显，因此会新增1~2帧的响应时延。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165919.32973602539344579408958675919692:50001231000000:2800:FCFB9D132022B1CDC27922672D0F5243A26BE27638447F667621747864412C8C.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-extrapolation-vulkan-V14
爬取时间: 2025-04-29 19:42:45
来源: Huawei Developer
业务流程
基于Vulkan图形API平台，集成超帧外插模式的主要业务流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165922.88648562719965534248613851589417:50001231000000:2800:CE40A86A535115A90742783AE367CB038F1D7606F10506EE12AE03D85F6BA7C8.png)
开发步骤
本节阐述基于Vulkan图形API平台的超帧调用示例，详细代码请参考图形开发Sample（超帧Vulkan）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-interpolation-gles-V14
爬取时间: 2025-04-29 19:42:45
来源: Huawei Developer
业务流程
基于OpenGL ES图形API平台，集成超帧内插模式的主要业务流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165919.55002521102799074487244112521921:50001231000000:2800:34902C179AAFA7DDC42C553AEAC83211F00BE532D4A77CF747C51E0E8EE60953.png)
开发步骤
本节阐述基于OpenGL ES图形API平台的超帧调用示例，详细代码请参考图形开发Sample（超帧GLES）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-mv-V14
爬取时间: 2025-04-29 19:42:59
来源: Huawei Developer
超帧提供两种运动估计模式供开发者选择：分别为基础模式和增强模式。其中增强模式需要对绘制顶点的Draw Call命令进行额外的标记，在相机和物体快速运动的游戏场景超帧效果较基础模式更优，能够有效改善拖影问题。本章主要介绍增强模式的运动估计原理及顶点标记方法。
Draw Call：指图形驱动库（OpenGL ES）中进行绘制的命令，例如glDrawElements、glDrawArrays、glDrawElementsInstanced等。
| 运动估计模式  | 描述  |
| --- | --- |
| 基础模式  | 利用历史帧颜色信息、深度信息及相机矩阵信息进行运动估计。  |
| 增强模式  | 利用历史帧中的几何顶点信息进行更精准的运动估计，绘制的预测帧质量更高。 但该模式需要开发者对绘制顶点的Draw Call命令进行额外的标记， 且仅支持Mate60、Mate60 Pro、Mate X5系列华为手机，在不支持的平台上会切换成默认模式。  |
运动估计模式
描述
基础模式
利用历史帧颜色信息、深度信息及相机矩阵信息进行运动估计。
增强模式
利用历史帧中的几何顶点信息进行更精准的运动估计，绘制的预测帧质量更高。 但该模式需要开发者对绘制顶点的Draw Call命令进行额外的标记， 且仅支持Mate60、Mate60 Pro、Mate X5系列华为手机，在不支持的平台上会切换成默认模式。
-  开发阶段，您需要使用系统的图形驱动库提供的OpenGL ES接口，在期望被标记的物体绘制前后添加上开始标记指令和结束标记指令。运行阶段，基于OpenGL ES的Transform Feedback（变换反馈）特性，被标记的所有Draw Call处理的顶点数据将被缓存，再通过顶点匹配、运动估计、屏幕空间投影等过程，得到高精度运动向量，最终绘制出预测帧。运行阶段流程如下图所示：
-  被标记的物体能在运动估计阶段得到更高精度的运动向量图（MV），但需要付出额外的性能代价，开发者需要在这之间做出平衡。我们建议只标记画面中相对场景运动的物体，因为它们的顶点数量较少，但运动预测却最为困难，这样的标记方式能以少量的性能代价换取较明显的超帧画质收益。 请在对深度图有贡献的Pass中标记相应的Draw Call。比如对于延迟管线，建议在gbuffer pass中标记；对于有pre depth的前向管线，建议在pre depth pass标记；对于无pre depth的前向管线，在base pass（forward pass）中进行标记。并且注意，不要在生成shadowmap pass中的动态物体Draw Call进行标记。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165922.35695617313416687533783641715297:50001231000000:2800:7A23427B3177D190E686F831099AA74BB3439674FFBF6C824FFCD0578AD8945A.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-abr-V14
爬取时间: 2025-04-29 19:43:13
来源: Huawei Developer
业务流程
基于相机运动感知策略的ABR主要业务流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165923.70081311722226925424995580763861:50001231000000:2800:6EB31F01ED9C7ED9F3FD1DDF17E835E9F15411D220C5D643BA3DD1A054161EF3.png)
开发步骤
本节阐述基于相机运动感知策略的ABR使用，从流程上分别阐述每个步骤的实现和调用，详细代码请参考图形开发Sample（ABR）。
设置项目配置项
在“src/main/module.json5”module层级中添加以下配置。
```json
"metadata": [
{
"name": "GraphicsAccelerateKit_ABR",
"value": "true"
}
]
```
头文件引用
编写CMakeLists.txt
ABR初始化
在应用创建Surface后会触发其事件回调函数Core::OnSurfaceCreated()，在该函数中完成ABR上下文实例创建、ABR属性配置和功能激活。其中ABR上下文实例负责管理ABR整个生命周期。
相机运动数据更新
在帧循环中，ABR根据获取的实时相机运动数据进行Buffer分辨率因子决策。
自适应渲染
在帧循环中，ABR将对所标记的Buffer进行自适应渲染处理。
销毁ABR实例
在Surface销毁时，会触发其事件回调函数Core::OnSurfaceDestroyed()，在该函数中完成ABR实例的销毁。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-extrapolation-overview-V14
爬取时间: 2025-04-29 19:43:26
来源: Huawei Developer
超帧外插模式是利用相邻两个真实渲染帧进行超帧计算并生成未来一帧预测帧，即利用第N-1帧、第N帧真实帧预测第N+0.5帧预测帧，如下图所示。由于外插模式不改变渲染时间线和显示时间线的帧间顺序，因此不会导致响应时延的增加。但由于外插模式预测的是未来帧画面，当发生场景画面帧间差异大、相机或物体运动方向突变时，在预测帧的画面边缘和物体边缘容易出现拖影和模糊现象。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165921.42317609695427229283139001234266:50001231000000:2800:45B612F837109668208AE609E25FC33EFB4A46794C5599C47203D9AE1DCFE019.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-opengtx-V14
爬取时间: 2025-04-29 19:43:27
来源: Huawei Developer
概述
OpenGTX是GPU Turbo X的开放式入口，根据游戏开发者主动提供的游戏过程中的关键信息，使能LTPO（动态帧率/刷新率）等游戏加速方案，助力游戏开发者打造高画质、高流畅、低功耗极致体验。LTPO通过动态感知游戏渲染状态、游戏场景、设备状态等关键信息，动态调整游戏的帧率/刷新率以及设备的SOC/DDR频率。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165923.94008742635852653286214566779424:50001231000000:2800:6865F6742AD55DD43FD763F1B4DDFFB7A207ECC620F5CC54F98C369281296053.png)
业务流程
LTPO的主要业务流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165923.91060327273519856090931502596068:50001231000000:2800:EBB27962B453DBE3EFAF8B2E27F3FCB3AD434A49D29C439194F48B869876ABA7.png)
开发步骤
本节介绍OpenGTX的开发接入，从流程上分别阐述每个步骤的实现和调用，详细代码请参考OpenGTX Sample。
设置项目配置项
在“src/main/module.json5”module层级中添加以下配置。
```json
"metadata": [
{
"name": "GraphicsAccelerateKit_LTPO",
"value": "true"
}
]
```
头文件引用
编写CMakeLists.txt
OpenGTX初始化
在surface创建后，会触发其事件回调函数Core::OnSurfaceCreated()，在该函数中完成OpenGTX上下文实例创建、OpenGTX属性配置和功能激活。其中OpenGTX上下文实例负责管理OpenGTX整个生命周期。
OpenGTX关键信息更新
销毁OpenGTX实例
在surface销毁时，会触发其事件回调函数Core::OnSurfaceDestroyed()，在该函数中完成OpenGTX实例的销毁。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-extrapolation-gles-V14
爬取时间: 2025-04-29 19:43:39
来源: Huawei Developer
业务流程
基于OpenGL ES图形API平台，集成超帧外插模式的主要业务流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165921.01015038885931307557741606961308:50001231000000:2800:CFDD74642EB9AC57A47FA7031EAE7A7D1D17546623D3975C55772AB26DE93C02.png)
开发步骤
外插模式需要标记模板缓冲的第8位，用于区分静态物体和动态物体。静态物体所占区域的模板值需标记为0xxx xxxx，动态物体所占区域的模板值需标记为1xxx xxxx，模板缓冲的低7位模板值开发者可自行设置。如果标记错误或漏标记，可能会造成超帧预测效果不准确，如运动物体边缘区域拖影等现象。
本节阐述基于OpenGL ES图形API平台的超帧调用示例，详细代码请参考图形开发Sample（超帧GLES）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-V14
爬取时间: 2025-04-29 19:43:40
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-extrapolation-vulkan-V14
爬取时间: 2025-04-29 19:43:52
来源: Huawei Developer
业务流程
基于Vulkan图形API平台，集成超帧外插模式的主要业务流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165922.88648562719965534248613851589417:50001231000000:2800:CE40A86A535115A90742783AE367CB038F1D7606F10506EE12AE03D85F6BA7C8.png)
开发步骤
本节阐述基于Vulkan图形API平台的超帧调用示例，详细代码请参考图形开发Sample（超帧Vulkan）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-1-V14
爬取时间: 2025-04-29 19:43:54
来源: Huawei Developer
目前超帧接口支持OpenGL ES和Vulkan图形API平台。ABR接口仅支持OpenGL ES图形API平台，暂不支持Vulkan平台。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-fg-mv-V14
爬取时间: 2025-04-29 19:44:06
来源: Huawei Developer
超帧提供两种运动估计模式供开发者选择：分别为基础模式和增强模式。其中增强模式需要对绘制顶点的Draw Call命令进行额外的标记，在相机和物体快速运动的游戏场景超帧效果较基础模式更优，能够有效改善拖影问题。本章主要介绍增强模式的运动估计原理及顶点标记方法。
Draw Call：指图形驱动库（OpenGL ES）中进行绘制的命令，例如glDrawElements、glDrawArrays、glDrawElementsInstanced等。
| 运动估计模式  | 描述  |
| --- | --- |
| 基础模式  | 利用历史帧颜色信息、深度信息及相机矩阵信息进行运动估计。  |
| 增强模式  | 利用历史帧中的几何顶点信息进行更精准的运动估计，绘制的预测帧质量更高。 但该模式需要开发者对绘制顶点的Draw Call命令进行额外的标记， 且仅支持Mate60、Mate60 Pro、Mate X5系列华为手机，在不支持的平台上会切换成默认模式。  |
运动估计模式
描述
基础模式
利用历史帧颜色信息、深度信息及相机矩阵信息进行运动估计。
增强模式
利用历史帧中的几何顶点信息进行更精准的运动估计，绘制的预测帧质量更高。 但该模式需要开发者对绘制顶点的Draw Call命令进行额外的标记， 且仅支持Mate60、Mate60 Pro、Mate X5系列华为手机，在不支持的平台上会切换成默认模式。
-  开发阶段，您需要使用系统的图形驱动库提供的OpenGL ES接口，在期望被标记的物体绘制前后添加上开始标记指令和结束标记指令。运行阶段，基于OpenGL ES的Transform Feedback（变换反馈）特性，被标记的所有Draw Call处理的顶点数据将被缓存，再通过顶点匹配、运动估计、屏幕空间投影等过程，得到高精度运动向量，最终绘制出预测帧。运行阶段流程如下图所示：
-  被标记的物体能在运动估计阶段得到更高精度的运动向量图（MV），但需要付出额外的性能代价，开发者需要在这之间做出平衡。我们建议只标记画面中相对场景运动的物体，因为它们的顶点数量较少，但运动预测却最为困难，这样的标记方式能以少量的性能代价换取较明显的超帧画质收益。 请在对深度图有贡献的Pass中标记相应的Draw Call。比如对于延迟管线，建议在gbuffer pass中标记；对于有pre depth的前向管线，建议在pre depth pass标记；对于无pre depth的前向管线，在base pass（forward pass）中进行标记。并且注意，不要在生成shadowmap pass中的动态物体Draw Call进行标记。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165922.35695617313416687533783641715297:50001231000000:2800:7A23427B3177D190E686F831099AA74BB3439674FFBF6C824FFCD0578AD8945A.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-6-V14
爬取时间: 2025-04-29 19:44:07
来源: Huawei Developer
Graphics Accelerate Kit支持的硬件设备类型包括：华为手机、华为平板设备。同时，您可以通过调用canIUse()接口并传入"SystemCapability.GraphicsGame.RenderAccelerate"进行设备类型适配查询。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-abr-V14
爬取时间: 2025-04-29 19:44:20
来源: Huawei Developer
业务流程
基于相机运动感知策略的ABR主要业务流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165923.70081311722226925424995580763861:50001231000000:2800:6EB31F01ED9C7ED9F3FD1DDF17E835E9F15411D220C5D643BA3DD1A054161EF3.png)
开发步骤
本节阐述基于相机运动感知策略的ABR使用，从流程上分别阐述每个步骤的实现和调用，详细代码请参考图形开发Sample（ABR）。
设置项目配置项
在“src/main/module.json5”module层级中添加以下配置。
```json
"metadata": [
{
"name": "GraphicsAccelerateKit_ABR",
"value": "true"
}
]
```
头文件引用
编写CMakeLists.txt
ABR初始化
在应用创建Surface后会触发其事件回调函数Core::OnSurfaceCreated()，在该函数中完成ABR上下文实例创建、ABR属性配置和功能激活。其中ABR上下文实例负责管理ABR整个生命周期。
相机运动数据更新
在帧循环中，ABR根据获取的实时相机运动数据进行Buffer分辨率因子决策。
自适应渲染
在帧循环中，ABR将对所标记的Buffer进行自适应渲染处理。
销毁ABR实例
在Surface销毁时，会触发其事件回调函数Core::OnSurfaceDestroyed()，在该函数中完成ABR实例的销毁。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-2-V14
爬取时间: 2025-04-29 19:44:21
来源: Huawei Developer
由于外插模式需要标记模板缓冲（Stencil Buffer）的第8位用于区分静态物体和动态物体，即静态物体模板值第8位标记成0，动态物体模板值第8位标记成1，模板缓冲的低7位模板值开发者可自行设置。如果标记错误或漏标记，可能会在动态物体边缘产生严重的拖影现象。
现象描述
Demo中运动角色出现头身分离等严重拖影现象。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165924.44827364340880475977507138426149:50001231000000:2800:F22AE25411365E24378979BB186699534C9393B9683A6913673F301E1D66C882.png)
原因分析
通过抓帧查看模板缓冲中的模板值，发现头发区域模板值为0，身体区域模板值为0x80。由于角色头、身均属于运动目标区域，应该将所有运动物体区域的模板值第8位标记为1。错误的头部区域模板值导致超帧效果出现头身分离的严重拖影现象。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165924.74074728059082791313949410606584:50001231000000:2800:EDB21ADCEB08733469C0DADBECE8EA795CDB7456681BC045A0672E02C1E23C12.png)
处理步骤
基于分析结论，造成头身分离拖影现象的主要原因是运动区域模板值未统一标记为1xxx xxxx。因此将运动角色头发和面部区域的模板值统一改为0x80，保持和身体模板值一致，头身分离的拖影现象消失，效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165924.54995398511236686424050129919273:50001231000000:2800:221EF309830EA2D1C4F974593C6D13F99194313E9665AEBA780F37E0A3786B75.png)
代码示例
检查动态物体材质Shader中的模板值是否设置正确，即静态物体模板值标记为0xxx xxxx，动态物体模板值标记为1xxx xxxx。
不同管线的Shader中需要配置模板值的Pass不同，如下：
-  在每个有DepthOnly或DepthNormals的Pass中，即出现Tags {"LightMode" = "DepthOnly" }或Tags {"LightMode" = "DepthNormals" }的Pass，配置模板值。
-  在每个有ForwardBase或ForwardAdd的Pass中，即出现Tags {"LightMode" = "ForwardBase" }或Tags {"LightMode" = "ForwardAdd" }的Pass，配置模板值。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-opengtx-V14
爬取时间: 2025-04-29 19:44:33
来源: Huawei Developer
概述
OpenGTX是GPU Turbo X的开放式入口，根据游戏开发者主动提供的游戏过程中的关键信息，使能LTPO（动态帧率/刷新率）等游戏加速方案，助力游戏开发者打造高画质、高流畅、低功耗极致体验。LTPO通过动态感知游戏渲染状态、游戏场景、设备状态等关键信息，动态调整游戏的帧率/刷新率以及设备的SOC/DDR频率。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165923.94008742635852653286214566779424:50001231000000:2800:6865F6742AD55DD43FD763F1B4DDFFB7A207ECC620F5CC54F98C369281296053.png)
业务流程
LTPO的主要业务流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165923.91060327273519856090931502596068:50001231000000:2800:EBB27962B453DBE3EFAF8B2E27F3FCB3AD434A49D29C439194F48B869876ABA7.png)
开发步骤
本节介绍OpenGTX的开发接入，从流程上分别阐述每个步骤的实现和调用，详细代码请参考OpenGTX Sample。
设置项目配置项
在“src/main/module.json5”module层级中添加以下配置。
```json
"metadata": [
{
"name": "GraphicsAccelerateKit_LTPO",
"value": "true"
}
]
```
头文件引用
编写CMakeLists.txt
OpenGTX初始化
在surface创建后，会触发其事件回调函数Core::OnSurfaceCreated()，在该函数中完成OpenGTX上下文实例创建、OpenGTX属性配置和功能激活。其中OpenGTX上下文实例负责管理OpenGTX整个生命周期。
OpenGTX关键信息更新
销毁OpenGTX实例
在surface销毁时，会触发其事件回调函数Core::OnSurfaceDestroyed()，在该函数中完成OpenGTX实例的销毁。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-3-V14
爬取时间: 2025-04-29 19:44:34
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-V14
爬取时间: 2025-04-29 19:44:47
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-4-V14
爬取时间: 2025-04-29 19:44:48
来源: Huawei Developer
现象描述
以团结引擎URP管线为例，ABR对DrawOpaqueObjects绑定的Buffer进行分辨率调整时会引起SSAO shadow效果异常。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165924.09417765424192010456788736922548:50001231000000:2800:B4167DCB8E3B1117840DEBF3194F534DE000322F42C763DB3F931B1F185AEA3D.png)
原因分析
通过上述URP管线可以看到，SSAO在渲染管线中是一个“前处理”，SSAO输出的图像会作为DrawOpaqueObjects的输入。当ABR对DrawOpaqueObjects绑定的Buffer进行自适应分辨率调整时，SSAO输出的图像为原始分辨率，而DrawOpaqueObjects绑定的Buffer使用低分辨率，分辨率不一致导致SSAO shadow效果异常。
处理步骤
针对该问题的解决方案，以下两种方案二选一即可。
-  在URP资产中勾选“After Opaque”：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165924.46025941141104417542861460029786:50001231000000:2800:4F02866E8145C195957C0A2F0E304ABB011D8D25B14E82C62F6251C35A5F904A.png)
-  SSAO的shader会根据scaledScreenParams参数进行计算，该变量与渲染分辨率相关，在集成ABR后，scaledScreenParams需要根据实时的ABR Buffer分辨率因子调整。 对于团结引擎，可在ScriptableRenderer.cs的SetPerCameraShaderVariables函数中根据Buffer分辨率因子设置scaledScreenParams参数。
对于同时支持渲染线程、RHI线程的游戏引擎，而且RHI线程延迟于渲染线程的场景，渲染线程通过HMS_ABR_GetScale接口获取的ABR Buffer分辨率因子无法解决上述问题。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-1-V14
爬取时间: 2025-04-29 19:44:59
来源: Huawei Developer
目前超帧接口支持OpenGL ES和Vulkan图形API平台。ABR接口仅支持OpenGL ES图形API平台，暂不支持Vulkan平台。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-5-V14
爬取时间: 2025-04-29 19:45:01
来源: Huawei Developer
现象描述
以团结引擎为例，游戏应用集成ABR，在游戏引擎中通过GetNativeTexturePtr获取Buffer关联的纹理，获取到的纹理内容为空。
原因分析
由于ABR对Buffer进行了自适应分辨率调整，并对ABR自适应缩放后的GLES纹理进行绘制，因而原始分辨率的GLES纹理中没有内容。
处理步骤
为解决此问题，需要通过HMS_ABR_GetScaledTexture_GLES接口获取到ABR自适应缩放后的GLES纹理索引。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-6-V14
爬取时间: 2025-04-29 19:45:13
来源: Huawei Developer
Graphics Accelerate Kit支持的硬件设备类型包括：华为手机、华为平板设备。同时，您可以通过调用canIUse()接口并传入"SystemCapability.GraphicsGame.RenderAccelerate"进行设备类型适配查询。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-guide-V14
爬取时间: 2025-04-29 19:45:15
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-2-V14
爬取时间: 2025-04-29 19:45:26
来源: Huawei Developer
由于外插模式需要标记模板缓冲（Stencil Buffer）的第8位用于区分静态物体和动态物体，即静态物体模板值第8位标记成0，动态物体模板值第8位标记成1，模板缓冲的低7位模板值开发者可自行设置。如果标记错误或漏标记，可能会在动态物体边缘产生严重的拖影现象。
现象描述
Demo中运动角色出现头身分离等严重拖影现象。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165924.44827364340880475977507138426149:50001231000000:2800:F22AE25411365E24378979BB186699534C9393B9683A6913673F301E1D66C882.png)
原因分析
通过抓帧查看模板缓冲中的模板值，发现头发区域模板值为0，身体区域模板值为0x80。由于角色头、身均属于运动目标区域，应该将所有运动物体区域的模板值第8位标记为1。错误的头部区域模板值导致超帧效果出现头身分离的严重拖影现象。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165924.74074728059082791313949410606584:50001231000000:2800:EDB21ADCEB08733469C0DADBECE8EA795CDB7456681BC045A0672E02C1E23C12.png)
处理步骤
基于分析结论，造成头身分离拖影现象的主要原因是运动区域模板值未统一标记为1xxx xxxx。因此将运动角色头发和面部区域的模板值统一改为0x80，保持和身体模板值一致，头身分离的拖影现象消失，效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165924.54995398511236686424050129919273:50001231000000:2800:221EF309830EA2D1C4F974593C6D13F99194313E9665AEBA780F37E0A3786B75.png)
代码示例
检查动态物体材质Shader中的模板值是否设置正确，即静态物体模板值标记为0xxx xxxx，动态物体模板值标记为1xxx xxxx。
不同管线的Shader中需要配置模板值的Pass不同，如下：
-  在每个有DepthOnly或DepthNormals的Pass中，即出现Tags {"LightMode" = "DepthOnly" }或Tags {"LightMode" = "DepthNormals" }的Pass，配置模板值。
-  在每个有ForwardBase或ForwardAdd的Pass中，即出现Tags {"LightMode" = "ForwardBase" }或Tags {"LightMode" = "ForwardAdd" }的Pass，配置模板值。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-introduction-V14
爬取时间: 2025-04-29 19:45:28
来源: Huawei Developer
XEngine Kit（GPU加速引擎服务）提供基于马良GPU的性能提升方案，包括GPU/AI超分能力、自适应VRS（Variable Rate Shading，可变速率着色）、Subpass Shading等，通过图形算法以及软硬件优化，让用户拥有更高性能、更低功耗的3D游戏/应用、AR/VR体验。
基本概念
在进行XEngine Kit开发前，开发者应了解以下基本概念：
场景介绍
优化细节画质，降低能耗
当GPU性能不足以支持渲染高分辨率场景时，为了提高用户体验，可以使用超分能力，将较低分辨率图像通过超分重建为高分辨率图像。相较于直接渲染高分辨率图像，使用超分能力能够降低GPU渲染负载，降低功耗。目前支持以下3种超分能力：
画质视觉无损，智能降低渲染开销
当GPU性能限制，不能持续为输出图像的每个像素提供相同质量级别的渲染结果时，可使用自适应VRS功能，其通过合理分配画面的计算资源，视觉无损降低渲染频次，使不同的渲染图像使用不同的渲染速率，能够有效提高渲染性能。
降低带宽开销，提升性能
对于TBDR（Tile-Based Deferred Rendering，基于瓦片的延迟渲染）和Forward+管线，Subpass Shading能力可以有效降低带宽开销，提升性能。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-3-V14
爬取时间: 2025-04-29 19:45:39
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-preparations-V14
爬取时间: 2025-04-29 19:45:41
来源: Huawei Developer
下载HUAWEI DevEco Studio，完成开发工具的安装，具体操作请参考安装DevEco Studio。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
软件要求
硬件要求
-  功能 支持设备类型 空域GPU超分 马良910 GPU及以上的华为手机、平板和2in1 空域AI超分 马良910 GPU及以上的华为手机 时域AI超分 马良920 GPU及以上的华为手机 自适应VRS 马良910 GPU及以上的华为手机、平板和2in1 Subpass Shading 马良GPU的华为手机、平板和2in1
| 功能  | 支持设备类型  |
| --- | --- |
| 空域GPU超分  | 马良910 GPU及以上的华为手机、平板和2in1  |
| 空域AI超分  | 马良910 GPU及以上的华为手机  |
| 时域AI超分  | 马良920 GPU及以上的华为手机  |
| 自适应VRS  | 马良910 GPU及以上的华为手机、平板和2in1  |
| Subpass Shading  | 马良GPU的华为手机、平板和2in1  |
-  功能 支持系统 空域GPU超分 支持HarmonyOS NEXT Developer  Beta1及以上 空域AI超分 支持HarmonyOS NEXT Developer  Beta1及以上 时域AI超分 支持HarmonyOS 5.0.0 Release及以上 自适应VRS 支持HarmonyOS NEXT Developer  Beta1及以上 Subpass Shading 支持HarmonyOS NEXT Developer  Beta1及以上
| 功能  | 支持系统  |
| --- | --- |
| 空域GPU超分  | 支持HarmonyOS NEXT Developer  Beta1及以上  |
| 空域AI超分  | 支持HarmonyOS NEXT Developer  Beta1及以上  |
| 时域AI超分  | 支持HarmonyOS 5.0.0 Release及以上  |
| 自适应VRS  | 支持HarmonyOS NEXT Developer  Beta1及以上  |
| Subpass Shading  | 支持HarmonyOS NEXT Developer  Beta1及以上  |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-4-V14
爬取时间: 2025-04-29 19:45:53
来源: Huawei Developer
现象描述
以团结引擎URP管线为例，ABR对DrawOpaqueObjects绑定的Buffer进行分辨率调整时会引起SSAO shadow效果异常。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165924.09417765424192010456788736922548:50001231000000:2800:B4167DCB8E3B1117840DEBF3194F534DE000322F42C763DB3F931B1F185AEA3D.png)
原因分析
通过上述URP管线可以看到，SSAO在渲染管线中是一个“前处理”，SSAO输出的图像会作为DrawOpaqueObjects的输入。当ABR对DrawOpaqueObjects绑定的Buffer进行自适应分辨率调整时，SSAO输出的图像为原始分辨率，而DrawOpaqueObjects绑定的Buffer使用低分辨率，分辨率不一致导致SSAO shadow效果异常。
处理步骤
针对该问题的解决方案，以下两种方案二选一即可。
-  在URP资产中勾选“After Opaque”：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314165924.46025941141104417542861460029786:50001231000000:2800:4F02866E8145C195957C0A2F0E304ABB011D8D25B14E82C62F6251C35A5F904A.png)
-  SSAO的shader会根据scaledScreenParams参数进行计算，该变量与渲染分辨率相关，在集成ABR后，scaledScreenParams需要根据实时的ABR Buffer分辨率因子调整。 对于团结引擎，可在ScriptableRenderer.cs的SetPerCameraShaderVariables函数中根据Buffer分辨率因子设置scaledScreenParams参数。
对于同时支持渲染线程、RHI线程的游戏引擎，而且RHI线程延迟于渲染线程的场景，渲染线程通过HMS_ABR_GetScale接口获取的ABR Buffer分辨率因子无法解决上述问题。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-gpu-spatial-upscaling-V14
爬取时间: 2025-04-29 19:45:55
来源: Huawei Developer
XEngine Kit提供空域GPU超分能力，其基于单帧输入图像，使用空间邻域信息实现超采样，开销较小同时收益可观，建议使用超分倍率为[1.2, 1.5]。
接口说明
以下接口为GLES和Vulkan空域GPU超分设置接口，如要使用更丰富的设置和查询接口，具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| const GLubyte * HMS_XEG_GetString (GLenum name) | XEngine GLES扩展特性查询接口。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_SpatialUpscaleParameter (GLenum pname, GLvoid *param) | 设置空域GPU超分输入参数。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_RenderSpatialUpscale (GLuint inputTexture) | 执行空域GPU超分渲染命令。 |
| VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, XEG_ExtensionProperties *pProperties) | XEngine Vulkan扩展特性查询接口。 |
| VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateSpatialUpscale (VkDevice device, const XEG_SpatialUpscaleCreateInfo *pXegSpatialUpscaleCreateInfo, XEG_SpatialUpscale *pXegSpatialUpscale) | 创建XEG_SpatialUpscale对象。 |
| VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdRenderSpatialUpscale (VkCommandBuffer commandBuffer, XEG_SpatialUpscale xegSpatialUpscale, XEG_SpatialUpscaleDescription *pXegSpatialUpscaleDescription) | 执行空域GPU超分渲染命令。 |
| VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroySpatialUpscale (XEG_SpatialUpscale xegSpatialUpscale) | 销毁XEG_SpatialUpscale对象。 |
接口名
描述
const GLubyte * HMS_XEG_GetString (GLenum name)
XEngine GLES扩展特性查询接口。
GL_APICALL void GL_APIENTRY HMS_XEG_SpatialUpscaleParameter (GLenum pname, GLvoid *param)
设置空域GPU超分输入参数。
GL_APICALL void GL_APIENTRY HMS_XEG_RenderSpatialUpscale (GLuint inputTexture)
执行空域GPU超分渲染命令。
VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, XEG_ExtensionProperties *pProperties)
XEngine Vulkan扩展特性查询接口。
VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateSpatialUpscale (VkDevice device, const XEG_SpatialUpscaleCreateInfo *pXegSpatialUpscaleCreateInfo, XEG_SpatialUpscale *pXegSpatialUpscale)
创建XEG_SpatialUpscale对象。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdRenderSpatialUpscale (VkCommandBuffer commandBuffer, XEG_SpatialUpscale xegSpatialUpscale, XEG_SpatialUpscaleDescription *pXegSpatialUpscaleDescription)
执行空域GPU超分渲染命令。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroySpatialUpscale (XEG_SpatialUpscale xegSpatialUpscale)
销毁XEG_SpatialUpscale对象。
开发步骤
本章以GLES/Vulkan图像API集成为例，说明XEngine集成操作过程。
配置项目
编译HAP时，Native层so编译需要依赖NDK中的libxengine.so。
-  按需引用XEngine的头文件，如使用GLES空域GPU超分。 按需引用XEngine的头文件，如使用Vulkan空域GPU超分。
-  按需引用XEngine的CMakeLists，如使用GLES空域GPU超分功能，CMakeLists.txt部分示例代码如下，完整示例代码请参见Demo（GPU加速引擎-GLES）。 按需引用XEngine的CMakeLists，如使用Vulkan空域GPU超分功能，CMakeLists.txt部分示例代码如下，完整示例代码请参见Demo（GPU加速引擎-Vulkan）。
集成XEngine空域GPU超分（GLES）
使用EGL和GLES图形API搭建图像渲染管线并集成空域GPU超分在Native层实现，渲染结果通过XComponent组件显示到屏幕。
本节阐述GLES图形API的空域GPU超分的使用，详细代码请参见Demo（GPU加速引擎-GLES）。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
1.
1.
1.  upscaleFBO是已创建完成的framebuffer，并绑定纹理，超分接口调用后绘制到纹理上。
集成XEngine空域GPU超分（Vulkan）
使用Vulkan图形API搭建图像渲染管线并集成空域GPU超分在Native层实现，渲染结果通过XComponent组件显示到屏幕。
本节阐述Vulkan图形API的空域GPU超分使用，详细代码请参见Demo（GPU加速引擎-Vulkan）。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
1.
1.
2.
1.
1.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/graphics-accelerate-faq-5-V14
爬取时间: 2025-04-29 19:46:06
来源: Huawei Developer
现象描述
以团结引擎为例，游戏应用集成ABR，在游戏引擎中通过GetNativeTexturePtr获取Buffer关联的纹理，获取到的纹理内容为空。
原因分析
由于ABR对Buffer进行了自适应分辨率调整，并对ABR自适应缩放后的GLES纹理进行绘制，因而原始分辨率的GLES纹理中没有内容。
处理步骤
为解决此问题，需要通过HMS_ABR_GetScaledTexture_GLES接口获取到ABR自适应缩放后的GLES纹理索引。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-ai-temporal-upscaling-V14
爬取时间: 2025-04-29 19:46:08
来源: Huawei Developer
XEngine Kit提供时域AI超分能力，利用相机的抖动获取不同位置的采样信息，融合时域实现超采样率和超分辨率功能，并利用神经网络达到抗锯齿效果，建议超分倍率为[1.25, 2.0]。
接口说明
以下接口为时域AI超分设置接口，如要使用更丰富的设置和查询接口，具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| KAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, XEG_ExtensionProperties * pProperties) | XEngine Vulkan扩展特性查询接口。 |
| VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateTemporalUpscale (VkDevice device, XEG_TemporalUpscaleCreateInfo * pTemporalUpscaleInfo, XEG_TemporalUpscale * pTemporalUpscale) | 创建XEG_TemporalUpscale对象。 |
| VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdRenderTemporalUpscale (VkCommandBuffer commandBuffer, XEG_TemporalUpscale temporalUpscale, XEG_TemporalUpscaleDescription * pDescription) | 执行时域AI超分渲染命令。 |
| VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroyTemporalUpscale (XEG_TemporalUpscale temporalUpscale) | 销毁XEG_TemporalUpscale对象。 |
接口名
描述
KAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, XEG_ExtensionProperties * pProperties)
XEngine Vulkan扩展特性查询接口。
VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateTemporalUpscale (VkDevice device, XEG_TemporalUpscaleCreateInfo * pTemporalUpscaleInfo, XEG_TemporalUpscale * pTemporalUpscale)
创建XEG_TemporalUpscale对象。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdRenderTemporalUpscale (VkCommandBuffer commandBuffer, XEG_TemporalUpscale temporalUpscale, XEG_TemporalUpscaleDescription * pDescription)
执行时域AI超分渲染命令。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroyTemporalUpscale (XEG_TemporalUpscale temporalUpscale)
销毁XEG_TemporalUpscale对象。
开发步骤
本章以Vulkan图像API集成为例，说明XEngine集成操作过程。
配置项目
编译HAP时，Native层so编译需要依赖NDK中的libxengine.so。
-  CMakeLists.txt部分示例代码如下，完整示例代码请参见Samplecode。
集成XEngine时域AI超分（Vulkan）
使用Vulkan图形API搭建图像渲染管线，并集成时域AI超分在Native层实现，渲染结果通过XComponent组件显示到屏幕。
本节阐述Vulkan图形API的时域AI超分使用，详细代码请参见Samplecode。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
1.
2.
3.
4.  其中，参数jitterX和jitterY分别为相机在X方向和Y方向的抖动，是一个类似Halton的低差异序列。
5.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-guide-V14
爬取时间: 2025-04-29 19:46:20
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-ai-spatial-upscaling-V14
爬取时间: 2025-04-29 19:46:22
来源: Huawei Developer
XEngine Kit提供空域AI超分能力，基于单帧图像使用AI推理生成滤波参数进行超采样，通过GPU、NPU协同工作，实现比空域GPU超分更好的画质，建议超分倍率在1.5倍以下时使用。
接口说明
以下接口为GLES空域AI超分设置接口，如要使用更丰富的设置和查询接口，具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| const GLubyte * HMS_XEG_GetString (GLenum name) | XEngine GLES扩展特性查询接口。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_NeuralUpscaleParameter (GLenum pname, GLvoid * param) | 设置空域AI超分输入参数。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_RenderNeuralUpscale (GLuint inputTexture) | 执行空域AI超分渲染命令。 |
接口名
描述
const GLubyte * HMS_XEG_GetString (GLenum name)
XEngine GLES扩展特性查询接口。
GL_APICALL void GL_APIENTRY HMS_XEG_NeuralUpscaleParameter (GLenum pname, GLvoid * param)
设置空域AI超分输入参数。
GL_APICALL void GL_APIENTRY HMS_XEG_RenderNeuralUpscale (GLuint inputTexture)
执行空域AI超分渲染命令。
开发步骤
本章以GLES图像API集成为例，说明XEngine集成操作过程。
配置项目
编译HAP时，Native层so编译需要依赖NDK中的libxengine.so。
集成XEngine空域AI超分（GLES）
Native层实现使用GLES和XEngine图形API搭建图像渲染管线并集成空域AI超分，渲染结果通过XComponent组件显示到屏幕。
本节阐述GLES图形API的空域AI超分的使用，详细代码请参见Demo（GPU加速引擎-GLES）。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
1.
2.
3.
4.
5.
6.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-introduction-V14
爬取时间: 2025-04-29 19:46:33
来源: Huawei Developer
XEngine Kit（GPU加速引擎服务）提供基于马良GPU的性能提升方案，包括GPU/AI超分能力、自适应VRS（Variable Rate Shading，可变速率着色）、Subpass Shading等，通过图形算法以及软硬件优化，让用户拥有更高性能、更低功耗的3D游戏/应用、AR/VR体验。
基本概念
在进行XEngine Kit开发前，开发者应了解以下基本概念：
场景介绍
优化细节画质，降低能耗
当GPU性能不足以支持渲染高分辨率场景时，为了提高用户体验，可以使用超分能力，将较低分辨率图像通过超分重建为高分辨率图像。相较于直接渲染高分辨率图像，使用超分能力能够降低GPU渲染负载，降低功耗。目前支持以下3种超分能力：
画质视觉无损，智能降低渲染开销
当GPU性能限制，不能持续为输出图像的每个像素提供相同质量级别的渲染结果时，可使用自适应VRS功能，其通过合理分配画面的计算资源，视觉无损降低渲染频次，使不同的渲染图像使用不同的渲染速率，能够有效提高渲染性能。
降低带宽开销，提升性能
对于TBDR（Tile-Based Deferred Rendering，基于瓦片的延迟渲染）和Forward+管线，Subpass Shading能力可以有效降低带宽开销，提升性能。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-adaptive-vrs-V14
爬取时间: 2025-04-29 19:46:35
来源: Huawei Developer
XEngine Kit提供自适应VRS功能，其通过合理分配画面的计算资源，视觉无损降低渲染频次，使不同的渲染图像使用不同的渲染速率，能够有效提高渲染性能。
接口说明
以下接口为自适应VRS设置接口，如要使用更丰富的设置和查询接口，具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| const GLubyte * HMS_XEG_GetString (GLenum name) | XEngine GLES扩展特性查询接口。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_AdaptiveVRSParameter (GLenum pname, GLvoid * param) | 设置自适应VRS的参数。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_DispatchAdaptiveVRS (GLfloat * reprojectionMatrix, GLuint inputColorImage, GLuint inputDepthImage, GLuint shadingRateImage) | 计算着色率图像。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_ApplyAdaptiveVRS (GLuint shadingRateImage) | 将着色率图像应用到渲染目标中。 |
| VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, XEG_ExtensionProperties * pProperties) | XEngine Vulkan扩展特性查询接口。 |
| VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateAdaptiveVRS (VkDevice device, XEG_AdaptiveVRSCreateInfo * pXegAdaptiveVRSCreateInfo, XEG_AdaptiveVRS * pXegAdaptiveVRS) | 创建XEG_AdaptiveVRS对象。 |
| VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdDispatchAdaptiveVRS (VkCommandBuffer cmdBuffer, XEG_AdaptiveVRS xegAdaptiveVRS, XEG_AdaptiveVRSDescription * pXegAdaptiveVRSDescription) | 执行计算自适应可变着色率命令。 |
| VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroyAdaptiveVRS (XEG_AdaptiveVRS xegAdaptiveVRS) | 销毁XEG_AdaptiveVRS对象。 |
接口名
描述
const GLubyte * HMS_XEG_GetString (GLenum name)
XEngine GLES扩展特性查询接口。
GL_APICALL void GL_APIENTRY HMS_XEG_AdaptiveVRSParameter (GLenum pname, GLvoid * param)
设置自适应VRS的参数。
GL_APICALL void GL_APIENTRY HMS_XEG_DispatchAdaptiveVRS (GLfloat * reprojectionMatrix, GLuint inputColorImage, GLuint inputDepthImage, GLuint shadingRateImage)
计算着色率图像。
GL_APICALL void GL_APIENTRY HMS_XEG_ApplyAdaptiveVRS (GLuint shadingRateImage)
将着色率图像应用到渲染目标中。
VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, XEG_ExtensionProperties * pProperties)
XEngine Vulkan扩展特性查询接口。
VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateAdaptiveVRS (VkDevice device, XEG_AdaptiveVRSCreateInfo * pXegAdaptiveVRSCreateInfo, XEG_AdaptiveVRS * pXegAdaptiveVRS)
创建XEG_AdaptiveVRS对象。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdDispatchAdaptiveVRS (VkCommandBuffer cmdBuffer, XEG_AdaptiveVRS xegAdaptiveVRS, XEG_AdaptiveVRSDescription * pXegAdaptiveVRSDescription)
执行计算自适应可变着色率命令。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroyAdaptiveVRS (XEG_AdaptiveVRS xegAdaptiveVRS)
销毁XEG_AdaptiveVRS对象。
开发步骤
本章以GLES/Vulkan图像API集成为例，说明XEngine集成操作过程。
配置项目
编译HAP时，Native层so编译需要依赖NDK中的libxengine.so。
-  按需引用XEngine的头文件，如使用GLES自适应VRS功能。 按需引用XEngine的头文件，如使用Vulkan自适应VRS功能。
-  按需引用XEngine的CMakeLists，如使用GLES自适应VRS功能，CMakeLists.txt部分示例代码如下，完整示例代码请参见Demo（GPU加速引擎-GLES）。 按需引用XEngine的CMakeLists，如使用Vulkan自适应VRS功能，CMakeLists.txt部分示例代码如下，完整示例代码请参见Demo（GPU加速引擎-Vulkan）。
集成自适应VRS功能（GLES）
自适应VRS功能GLES版本的着色率纹理创建和绑定由特性提供的接口实现。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
1.
1.
2.
1.
集成自适应VRS功能（Vulkan）
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
1.
2.
3.
1.
1.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-preparations-V14
爬取时间: 2025-04-29 19:46:46
来源: Huawei Developer
下载HUAWEI DevEco Studio，完成开发工具的安装，具体操作请参考安装DevEco Studio。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
软件要求
硬件要求
-  功能 支持设备类型 空域GPU超分 马良910 GPU及以上的华为手机、平板和2in1 空域AI超分 马良910 GPU及以上的华为手机 时域AI超分 马良920 GPU及以上的华为手机 自适应VRS 马良910 GPU及以上的华为手机、平板和2in1 Subpass Shading 马良GPU的华为手机、平板和2in1
| 功能  | 支持设备类型  |
| --- | --- |
| 空域GPU超分  | 马良910 GPU及以上的华为手机、平板和2in1  |
| 空域AI超分  | 马良910 GPU及以上的华为手机  |
| 时域AI超分  | 马良920 GPU及以上的华为手机  |
| 自适应VRS  | 马良910 GPU及以上的华为手机、平板和2in1  |
| Subpass Shading  | 马良GPU的华为手机、平板和2in1  |
-  功能 支持系统 空域GPU超分 支持HarmonyOS NEXT Developer  Beta1及以上 空域AI超分 支持HarmonyOS NEXT Developer  Beta1及以上 时域AI超分 支持HarmonyOS 5.0.0 Release及以上 自适应VRS 支持HarmonyOS NEXT Developer  Beta1及以上 Subpass Shading 支持HarmonyOS NEXT Developer  Beta1及以上
| 功能  | 支持系统  |
| --- | --- |
| 空域GPU超分  | 支持HarmonyOS NEXT Developer  Beta1及以上  |
| 空域AI超分  | 支持HarmonyOS NEXT Developer  Beta1及以上  |
| 时域AI超分  | 支持HarmonyOS 5.0.0 Release及以上  |
| 自适应VRS  | 支持HarmonyOS NEXT Developer  Beta1及以上  |
| Subpass Shading  | 支持HarmonyOS NEXT Developer  Beta1及以上  |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-subpass-shading-V14
爬取时间: 2025-04-29 19:46:49
来源: Huawei Developer
随着游戏场景的复杂化，越来越多的光照效果被应用到游戏场景中，随之也带来大量的光照计算以及带宽消耗。目前通过Tile-Based Deferred Rendering（TBDR）和Forward+等方法可以解决大量光照的渲染时间消耗，但是大量带宽的占用问题还是没有解决，Subpass Shading能力主要减少计算过程中的读写从而减少带宽的占用。
下图说明Subpass Shading节省渲染通道1和Compute Pass从Device memory上面的一次读写带宽。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250414094256.75016919488838617945000515234816:50001231000000:2800:0B69E006423CEC23757AFD7F243C4A2EB1DBCAFBCEA37196FD20AC549A08B5F4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250414094256.69531000432145039745710868701183:50001231000000:2800:37C9F6D8F72EF59FA3AC5C374EA3FEE6F41D15156B519DE16161CC097F5BA26A.png)
接口说明
通过Vulkan扩展接口VK_HUAWEI_subpass_shading提供Subpass Shading API，该扩展支持在Subpass中使用Compute Shader，并在Compute Shader中使用SubpassLoad从Tile buffer中直接读取数据，可用于降低DDR带宽，适用于TBDR和Forward+管线。
Subpass Shading能力具体使用请参见Demo（GPU加速引擎-Subpass Shading）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-gpu-spatial-upscaling-V14
爬取时间: 2025-04-29 19:46:59
来源: Huawei Developer
XEngine Kit提供空域GPU超分能力，其基于单帧输入图像，使用空间邻域信息实现超采样，开销较小同时收益可观，建议使用超分倍率为[1.2, 1.5]。
接口说明
以下接口为GLES和Vulkan空域GPU超分设置接口，如要使用更丰富的设置和查询接口，具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| const GLubyte * HMS_XEG_GetString (GLenum name) | XEngine GLES扩展特性查询接口。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_SpatialUpscaleParameter (GLenum pname, GLvoid *param) | 设置空域GPU超分输入参数。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_RenderSpatialUpscale (GLuint inputTexture) | 执行空域GPU超分渲染命令。 |
| VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, XEG_ExtensionProperties *pProperties) | XEngine Vulkan扩展特性查询接口。 |
| VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateSpatialUpscale (VkDevice device, const XEG_SpatialUpscaleCreateInfo *pXegSpatialUpscaleCreateInfo, XEG_SpatialUpscale *pXegSpatialUpscale) | 创建XEG_SpatialUpscale对象。 |
| VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdRenderSpatialUpscale (VkCommandBuffer commandBuffer, XEG_SpatialUpscale xegSpatialUpscale, XEG_SpatialUpscaleDescription *pXegSpatialUpscaleDescription) | 执行空域GPU超分渲染命令。 |
| VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroySpatialUpscale (XEG_SpatialUpscale xegSpatialUpscale) | 销毁XEG_SpatialUpscale对象。 |
接口名
描述
const GLubyte * HMS_XEG_GetString (GLenum name)
XEngine GLES扩展特性查询接口。
GL_APICALL void GL_APIENTRY HMS_XEG_SpatialUpscaleParameter (GLenum pname, GLvoid *param)
设置空域GPU超分输入参数。
GL_APICALL void GL_APIENTRY HMS_XEG_RenderSpatialUpscale (GLuint inputTexture)
执行空域GPU超分渲染命令。
VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, XEG_ExtensionProperties *pProperties)
XEngine Vulkan扩展特性查询接口。
VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateSpatialUpscale (VkDevice device, const XEG_SpatialUpscaleCreateInfo *pXegSpatialUpscaleCreateInfo, XEG_SpatialUpscale *pXegSpatialUpscale)
创建XEG_SpatialUpscale对象。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdRenderSpatialUpscale (VkCommandBuffer commandBuffer, XEG_SpatialUpscale xegSpatialUpscale, XEG_SpatialUpscaleDescription *pXegSpatialUpscaleDescription)
执行空域GPU超分渲染命令。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroySpatialUpscale (XEG_SpatialUpscale xegSpatialUpscale)
销毁XEG_SpatialUpscale对象。
开发步骤
本章以GLES/Vulkan图像API集成为例，说明XEngine集成操作过程。
配置项目
编译HAP时，Native层so编译需要依赖NDK中的libxengine.so。
-  按需引用XEngine的头文件，如使用GLES空域GPU超分。 按需引用XEngine的头文件，如使用Vulkan空域GPU超分。
-  按需引用XEngine的CMakeLists，如使用GLES空域GPU超分功能，CMakeLists.txt部分示例代码如下，完整示例代码请参见Demo（GPU加速引擎-GLES）。 按需引用XEngine的CMakeLists，如使用Vulkan空域GPU超分功能，CMakeLists.txt部分示例代码如下，完整示例代码请参见Demo（GPU加速引擎-Vulkan）。
集成XEngine空域GPU超分（GLES）
使用EGL和GLES图形API搭建图像渲染管线并集成空域GPU超分在Native层实现，渲染结果通过XComponent组件显示到屏幕。
本节阐述GLES图形API的空域GPU超分的使用，详细代码请参见Demo（GPU加速引擎-GLES）。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
1.
1.
1.  upscaleFBO是已创建完成的framebuffer，并绑定纹理，超分接口调用后绘制到纹理上。
集成XEngine空域GPU超分（Vulkan）
使用Vulkan图形API搭建图像渲染管线并集成空域GPU超分在Native层实现，渲染结果通过XComponent组件显示到屏幕。
本节阐述Vulkan图形API的空域GPU超分使用，详细代码请参见Demo（GPU加速引擎-Vulkan）。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
1.
1.
2.
1.
1.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-faq-V14
爬取时间: 2025-04-29 19:47:02
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-ai-temporal-upscaling-V14
爬取时间: 2025-04-29 19:47:12
来源: Huawei Developer
XEngine Kit提供时域AI超分能力，利用相机的抖动获取不同位置的采样信息，融合时域实现超采样率和超分辨率功能，并利用神经网络达到抗锯齿效果，建议超分倍率为[1.25, 2.0]。
接口说明
以下接口为时域AI超分设置接口，如要使用更丰富的设置和查询接口，具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| KAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, XEG_ExtensionProperties * pProperties) | XEngine Vulkan扩展特性查询接口。 |
| VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateTemporalUpscale (VkDevice device, XEG_TemporalUpscaleCreateInfo * pTemporalUpscaleInfo, XEG_TemporalUpscale * pTemporalUpscale) | 创建XEG_TemporalUpscale对象。 |
| VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdRenderTemporalUpscale (VkCommandBuffer commandBuffer, XEG_TemporalUpscale temporalUpscale, XEG_TemporalUpscaleDescription * pDescription) | 执行时域AI超分渲染命令。 |
| VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroyTemporalUpscale (XEG_TemporalUpscale temporalUpscale) | 销毁XEG_TemporalUpscale对象。 |
接口名
描述
KAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, XEG_ExtensionProperties * pProperties)
XEngine Vulkan扩展特性查询接口。
VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateTemporalUpscale (VkDevice device, XEG_TemporalUpscaleCreateInfo * pTemporalUpscaleInfo, XEG_TemporalUpscale * pTemporalUpscale)
创建XEG_TemporalUpscale对象。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdRenderTemporalUpscale (VkCommandBuffer commandBuffer, XEG_TemporalUpscale temporalUpscale, XEG_TemporalUpscaleDescription * pDescription)
执行时域AI超分渲染命令。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroyTemporalUpscale (XEG_TemporalUpscale temporalUpscale)
销毁XEG_TemporalUpscale对象。
开发步骤
本章以Vulkan图像API集成为例，说明XEngine集成操作过程。
配置项目
编译HAP时，Native层so编译需要依赖NDK中的libxengine.so。
-  CMakeLists.txt部分示例代码如下，完整示例代码请参见Samplecode。
集成XEngine时域AI超分（Vulkan）
使用Vulkan图形API搭建图像渲染管线，并集成时域AI超分在Native层实现，渲染结果通过XComponent组件显示到屏幕。
本节阐述Vulkan图形API的时域AI超分使用，详细代码请参见Samplecode。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
1.
2.
3.
4.  其中，参数jitterX和jitterY分别为相机在X方向和Y方向的抖动，是一个类似Halton的低差异序列。
5.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-faq-1-V14
爬取时间: 2025-04-29 19:47:15
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-ai-spatial-upscaling-V14
爬取时间: 2025-04-29 19:47:25
来源: Huawei Developer
XEngine Kit提供空域AI超分能力，基于单帧图像使用AI推理生成滤波参数进行超采样，通过GPU、NPU协同工作，实现比空域GPU超分更好的画质，建议超分倍率在1.5倍以下时使用。
接口说明
以下接口为GLES空域AI超分设置接口，如要使用更丰富的设置和查询接口，具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| const GLubyte * HMS_XEG_GetString (GLenum name) | XEngine GLES扩展特性查询接口。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_NeuralUpscaleParameter (GLenum pname, GLvoid * param) | 设置空域AI超分输入参数。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_RenderNeuralUpscale (GLuint inputTexture) | 执行空域AI超分渲染命令。 |
接口名
描述
const GLubyte * HMS_XEG_GetString (GLenum name)
XEngine GLES扩展特性查询接口。
GL_APICALL void GL_APIENTRY HMS_XEG_NeuralUpscaleParameter (GLenum pname, GLvoid * param)
设置空域AI超分输入参数。
GL_APICALL void GL_APIENTRY HMS_XEG_RenderNeuralUpscale (GLuint inputTexture)
执行空域AI超分渲染命令。
开发步骤
本章以GLES图像API集成为例，说明XEngine集成操作过程。
配置项目
编译HAP时，Native层so编译需要依赖NDK中的libxengine.so。
集成XEngine空域AI超分（GLES）
Native层实现使用GLES和XEngine图形API搭建图像渲染管线并集成空域AI超分，渲染结果通过XComponent组件显示到屏幕。
本节阐述GLES图形API的空域AI超分的使用，详细代码请参见Demo（GPU加速引擎-GLES）。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
1.
2.
3.
4.
5.
6.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-faq-2-V14
爬取时间: 2025-04-29 19:47:28
来源: Huawei Developer
可以同时使用，用户可根据实际应用选择超分和自适应VRS的使用顺序。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-adaptive-vrs-V14
爬取时间: 2025-04-29 19:47:39
来源: Huawei Developer
XEngine Kit提供自适应VRS功能，其通过合理分配画面的计算资源，视觉无损降低渲染频次，使不同的渲染图像使用不同的渲染速率，能够有效提高渲染性能。
接口说明
以下接口为自适应VRS设置接口，如要使用更丰富的设置和查询接口，具体API说明详见接口文档。
| 接口名 | 描述 |
| --- | --- |
| const GLubyte * HMS_XEG_GetString (GLenum name) | XEngine GLES扩展特性查询接口。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_AdaptiveVRSParameter (GLenum pname, GLvoid * param) | 设置自适应VRS的参数。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_DispatchAdaptiveVRS (GLfloat * reprojectionMatrix, GLuint inputColorImage, GLuint inputDepthImage, GLuint shadingRateImage) | 计算着色率图像。 |
| GL_APICALL void GL_APIENTRY HMS_XEG_ApplyAdaptiveVRS (GLuint shadingRateImage) | 将着色率图像应用到渲染目标中。 |
| VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, XEG_ExtensionProperties * pProperties) | XEngine Vulkan扩展特性查询接口。 |
| VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateAdaptiveVRS (VkDevice device, XEG_AdaptiveVRSCreateInfo * pXegAdaptiveVRSCreateInfo, XEG_AdaptiveVRS * pXegAdaptiveVRS) | 创建XEG_AdaptiveVRS对象。 |
| VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdDispatchAdaptiveVRS (VkCommandBuffer cmdBuffer, XEG_AdaptiveVRS xegAdaptiveVRS, XEG_AdaptiveVRSDescription * pXegAdaptiveVRSDescription) | 执行计算自适应可变着色率命令。 |
| VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroyAdaptiveVRS (XEG_AdaptiveVRS xegAdaptiveVRS) | 销毁XEG_AdaptiveVRS对象。 |
接口名
描述
const GLubyte * HMS_XEG_GetString (GLenum name)
XEngine GLES扩展特性查询接口。
GL_APICALL void GL_APIENTRY HMS_XEG_AdaptiveVRSParameter (GLenum pname, GLvoid * param)
设置自适应VRS的参数。
GL_APICALL void GL_APIENTRY HMS_XEG_DispatchAdaptiveVRS (GLfloat * reprojectionMatrix, GLuint inputColorImage, GLuint inputDepthImage, GLuint shadingRateImage)
计算着色率图像。
GL_APICALL void GL_APIENTRY HMS_XEG_ApplyAdaptiveVRS (GLuint shadingRateImage)
将着色率图像应用到渲染目标中。
VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, XEG_ExtensionProperties * pProperties)
XEngine Vulkan扩展特性查询接口。
VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateAdaptiveVRS (VkDevice device, XEG_AdaptiveVRSCreateInfo * pXegAdaptiveVRSCreateInfo, XEG_AdaptiveVRS * pXegAdaptiveVRS)
创建XEG_AdaptiveVRS对象。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdDispatchAdaptiveVRS (VkCommandBuffer cmdBuffer, XEG_AdaptiveVRS xegAdaptiveVRS, XEG_AdaptiveVRSDescription * pXegAdaptiveVRSDescription)
执行计算自适应可变着色率命令。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroyAdaptiveVRS (XEG_AdaptiveVRS xegAdaptiveVRS)
销毁XEG_AdaptiveVRS对象。
开发步骤
本章以GLES/Vulkan图像API集成为例，说明XEngine集成操作过程。
配置项目
编译HAP时，Native层so编译需要依赖NDK中的libxengine.so。
-  按需引用XEngine的头文件，如使用GLES自适应VRS功能。 按需引用XEngine的头文件，如使用Vulkan自适应VRS功能。
-  按需引用XEngine的CMakeLists，如使用GLES自适应VRS功能，CMakeLists.txt部分示例代码如下，完整示例代码请参见Demo（GPU加速引擎-GLES）。 按需引用XEngine的CMakeLists，如使用Vulkan自适应VRS功能，CMakeLists.txt部分示例代码如下，完整示例代码请参见Demo（GPU加速引擎-Vulkan）。
集成自适应VRS功能（GLES）
自适应VRS功能GLES版本的着色率纹理创建和绑定由特性提供的接口实现。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
1.
1.
2.
1.
集成自适应VRS功能（Vulkan）
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
1.
2.
3.
1.
1.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-faq-3-V14
爬取时间: 2025-04-29 19:47:41
来源: Huawei Developer
当不使用重投影矩阵时，可以不传深度附件。若使用重投影矩阵则必须传递深度附件，否则会导致着色率图计算错误。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-subpass-shading-V14
爬取时间: 2025-04-29 19:47:52
来源: Huawei Developer
随着游戏场景的复杂化，越来越多的光照效果被应用到游戏场景中，随之也带来大量的光照计算以及带宽消耗。目前通过Tile-Based Deferred Rendering（TBDR）和Forward+等方法可以解决大量光照的渲染时间消耗，但是大量带宽的占用问题还是没有解决，Subpass Shading能力主要减少计算过程中的读写从而减少带宽的占用。
下图说明Subpass Shading节省渲染通道1和Compute Pass从Device memory上面的一次读写带宽。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250414094256.75016919488838617945000515234816:50001231000000:2800:0B69E006423CEC23757AFD7F243C4A2EB1DBCAFBCEA37196FD20AC549A08B5F4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250414094256.69531000432145039745710868701183:50001231000000:2800:37C9F6D8F72EF59FA3AC5C374EA3FEE6F41D15156B519DE16161CC097F5BA26A.png)
接口说明
通过Vulkan扩展接口VK_HUAWEI_subpass_shading提供Subpass Shading API，该扩展支持在Subpass中使用Compute Shader，并在Compute Shader中使用SubpassLoad从Tile buffer中直接读取数据，可用于降低DDR带宽，适用于TBDR和Forward+管线。
Subpass Shading能力具体使用请参见Demo（GPU加速引擎-Subpass Shading）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-faq-4-V14
爬取时间: 2025-04-29 19:47:54
来源: Huawei Developer
输出不需要，仅输入需要通过OH_NativeBuffer创建。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-faq-V14
爬取时间: 2025-04-29 19:48:05
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-faq-1-V14
爬取时间: 2025-04-29 19:48:18
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-faq-2-V14
爬取时间: 2025-04-29 19:48:31
来源: Huawei Developer
可以同时使用，用户可根据实际应用选择超分和自适应VRS的使用顺序。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-faq-3-V14
爬取时间: 2025-04-29 19:48:44
来源: Huawei Developer
当不使用重投影矩阵时，可以不传深度附件。若使用重投影矩阵则必须传递深度附件，否则会导致着色率图计算错误。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/xengine-kit-faq-4-V14
爬取时间: 2025-04-29 19:48:57
来源: Huawei Developer
输出不需要，仅输入需要通过OH_NativeBuffer创建。


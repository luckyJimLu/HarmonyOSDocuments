# 合并文件
合并时间: 2025-05-01 09:23:35

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-develop-once-deploy-everywhere
爬取时间: 2025-05-01 08:29:44
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-technical-key-points
爬取时间: 2025-05-01 08:29:57
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-device-bp-practice
爬取时间: 2025-05-01 08:30:13
来源: Huawei Developer
背景
一次开发，多端部署旨在编写一套代码，一次开发上架，即可以将应用多端按需部署。随着HarmonyOS生态不断拓展，终端设备形态日益多样化，应用的页面布局如何在一套代码中适配不同屏幕尺寸、屏幕方向的设备类型，成为一大挑战。为了解决这一问题，系统侧提供了响应式布局供开发者学习与使用。响应式布局是一种设计模式，核心思想是页面能够根据不同窗口或屏幕尺寸自动调整布局，以提供更加舒适的界面和更好的用户体验。响应式布局页面的效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151230.87948263544659126923382926701454:50001231000000:2800:C661FB011A72E945A2421135423A0A6E340350582899FE527319C379161F420A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151230.48703949131143974178287926826689:50001231000000:2800:AF60304B01A60ED827CDA51240C39317F8419B787339633ACF14B95BBBD26651.png)
简单来讲，响应式布局是指页面内的元素可以根据窗口尺寸自动变化。响应式布局中最常使用的特征是窗口宽度，因此系统侧将窗口宽度划分为不同的范围（称为断点）。当窗口宽度从一个断点变化到另一个断点时，改变页面布局（如将页面内容从单列排布调整为双列排布甚至三列排布等）以获得更好的显示效果。
断点的设计原理
为了提升用户的全场景体验，需要考虑多设备体验的连续性。应用在页面布局设计上推荐遵循如下原则：
因此，HarmonyOS设计了横向和纵向断点分别代表窗口的不同特征，作为判断页面布局和交互体验的条件：
下文横向断点的使用章节将介绍如何使用横向断点实现原则一，纵向断点的使用章节将介绍如何结合横向和纵向断点实现原则二。
断点以应用窗口宽和高为切入点，将应用窗口在宽度以及窗口的宽高比这两个维度上分成了几个不同的区间（即不同的断点），在不同的区间下，UX设计师对页面进行响应式布局设计，开发者可根据HarmonyOS一多相关能力实现不同的页面布局效果。
断点的定义
横向断点以应用窗口宽度为判断条件，推荐按照不同的阈值分成5个区间：
| 断点名称  | 窗口宽度（vp）  |
| --- | --- |
| xs  | (0, 320）  |
| sm  | [320, 600)  |
| md  | [600, 840)  |
| lg  | [840, 1440)  |
| xl  | [1440, +∞)  |
断点名称
窗口宽度（vp）
xs
(0, 320）
sm
[320, 600)
md
[600, 840)
lg
[840, 1440)
xl
[1440, +∞)
纵向断点以应用窗口的高宽比为判断条件，推荐按照不同的阈值分成3个区间：
| 断点名称  | 高宽比  |
| --- | --- |
| sm  | (0, 0.8)  |
| md  | [0.8, 1.2)  |
| lg  | [1.2, +∞)  |
断点名称
高宽比
sm
(0, 0.8)
md
[0.8, 1.2)
lg
[1.2, +∞)
下图为HarmonyOS常用设备断点区间表：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151230.34986366072743039726629722343720:50001231000000:2800:0CA15980AB0769FE26E5036577896B9401F96C5212CA2943AA6364FC641B04B5.png)
一多的断点面向窗口而非面向设备类型，处于相同断点区间的窗口本质上形态相同，推荐展示相同的页面布局。因此同一设备上的不同窗口形态（例如全屏显示、分屏显示、自由窗口等），可能会落入不同的断点区间，展示不同断点对应的页面布局。
实现原理
```typescript
export default class EntryAbility extends UIAbility {
private uiContext?: UIContext;
private onWindowSizeChange: (windowSize: window.Size) => void = (windowSize: window.Size) => {
let widthBp: WidthBreakpoint = this.uiContext!.getWindowWidthBreakpoint();
AppStorage.setOrCreate('currentWidthBreakpoint', widthBp);
let heightBp: HeightBreakpoint = this.uiContext!.getWindowHeightBreakpoint();
AppStorage.setOrCreate('currentHeightBreakpoint', heightBp);
};
// ...
onWindowStageCreate(windowStage: window.WindowStage): void {
// Main window is created, set main page for this ability
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
windowStage.loadContent('pages/Index', (err) => {
if (err.code) {
hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
return;
}
hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
// The system interface depends on UIContext and needs to be invoked after the page is loaded. It needs to be written in the loadContent callback function.
windowStage.getMainWindow().then((data: window.Window) => {
this.uiContext = data.getUIContext();
let widthBp: WidthBreakpoint = this.uiContext.getWindowWidthBreakpoint();
let heightBp: HeightBreakpoint = this.uiContext.getWindowHeightBreakpoint();
AppStorage.setOrCreate('currentWidthBreakpoint', widthBp);
AppStorage.setOrCreate('currentHeightBreakpoint', heightBp);
data.on('windowSizeChange', this.onWindowSizeChange);
}).catch((err: BusinessError) => {
console.error(`Failed to obtain the main window. Cause code: ${err.code}, message: ${err.message}`);
});
});
}
// ...
}
```
```typescript
export default class EntryAbility extends UIAbility {
private windowUtil?: WindowUtil = WindowUtil.getInstance();
private onWindowSizeChange: (windowSize: window.Size) => void = (windowSize: window.Size) => {
this.windowUtil!.updateHeightBp();
this.windowUtil!.updateWidthBp();
// ...
};
// ...
onWindowStageCreate(windowStage: window.WindowStage): void {
// Main window is created, set main page for this ability
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
this.windowUtil?.setWindowStage(windowStage);
windowStage.getMainWindow((err: BusinessError, data: window.Window) => {
if (err.code) {
hilog.error(0x0000, 'testTag', 'Failed to get the main window. Cause: %{public}s', JSON.stringify(err) ?? '');
return;
}
this.windowUtil!.updateWidthBp();
this.windowUtil!.updateHeightBp();
// ...
data.on('windowSizeChange', this.onWindowSizeChange);
})
// ...
}
// ...
}
```
横向断点的使用
针对布局拉通（两个宽度相近的窗口，页面布局应相同），本章节将介绍实际开发中横向断点的使用。
实现一多应用时，首先根据不同设备类型对应的断点集合，规划多种设计方案。例如一款应用需要支持手机、大折叠屏（X系列）、平板，则需要考虑的三个横向断点分别是sm、md、lg，并设计这三个断点下不同的页面布局，然后根据设计方案进行一多开发。设计方案效果图如下：
| sm  | md  | lg  |
| --- | --- | --- |
|   |   |   |
sm
md
lg
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151231.38491465606291829074577477001440:50001231000000:2800:E686A2CF69205C3CED71667D6E4CF055697FDEA6FA7ED5FDE7B08F8388AD3155.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151231.63344052383453334971696793364857:50001231000000:2800:0983578453989936DD65A845E41DA2F1E4BBD55670E17603873A940DF5BD2C55.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151231.15664628159688097277468771764589:50001231000000:2800:5911590D90A0586D0349575B848947B93A7ADE3E62C7E5160D6AFA6344AADFF9.png)
下面首先介绍使用横向断点的技术要点，其次以该应用首页为例，对三种典型的响应式布局结合断点的场景详细介绍，包括挪移布局、重复布局和分栏布局。
技术要点
实际一多应用开发，可能不会涉及到全部的横向断点，开发者可根据应用的实际需求灵活选用并整理工具类，为响应式布局的属性赋值。例如：应用仅需适配手机、大折叠屏（X系列）和平板设备，可以设计为工具类BreakpointType覆盖三个横向断点下的成员变量。使用工具类实现具体的响应式布局。
以实际开发中设置不同断点下的字体大小为例，在sm、md、lg横向断点下字体大小分别为14fp、16fp、18fp，通过工具类BreakpointType为不同横向断点下的属性赋值。
如果sm、md断点下字体均为14fp，lg断点下字体为16fp，通过三元表达式结合横向断点为属性赋值。
挪移布局
挪移布局作为典型的响应式布局，能够调整组件的位置与展示方式，在上下布局与左右布局之间切换，通常应用于首页的顶部页签与搜索框。
实现原理
不同横向断点下，顶部页签和搜索框占用不同栅格列数，使用栅格布局实现在sm横向断点下分两行显示，在md和lg横向断点下单行显示。根据设计将栅格在sm、md和lg的横向断点上分别划分为4列、12列、12列。示意图如下：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
| 栅格布局图  |   |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151232.38583320710215834736013297013652:50001231000000:2800:7DE6601569AC6B286C317648B44C2EB22BE7F831A373D45DB1A0F3082C11010B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151232.10446185154536261310524859848349:50001231000000:2800:752825FAF1CE3ED65FDC3E1F73E76C8D47E40B6C89789FE227BF153A7E8F1D7F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151232.06924086448926670080246369671621:50001231000000:2800:B93722B0E2273D316C68BDD98E0CA2E26E03DD76710DBF6E30D2C52EF0781DCF.png)
栅格布局图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151232.78430188659009246031392854638829:50001231000000:2800:9E0421EE404AAB7429C6C0670A3015DAB82B431389F7732B5CCF2AB93569E825.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151232.40301751191004999181576566326399:50001231000000:2800:7BCE2E7FD6A205A767E1AA5CE5E3EC7CFE5152522A34CDECE126113584760689.png)
重复布局
重复布局泛指在一多中将相同属性的组件重复排布，通常用于在宽度不同的窗口中多行多列展示首页的内容元素。用户能够同时浏览更多内容，提高屏幕的利用率。
实现原理
ArkUI中常见的重复布局组件包含Swiper组件、Grid组件、List组件、WaterFlow组件等。本章节以应用首页中的布局为例，介绍Swiper组件、Grid组件如何分别与横向断点结合实现重复布局。
1.  首页展示Banner图的Swiper组件，又称运营横幅或轮播布局。在不同横向断点下，展示不同数量的图片。 sm md lg 显示导航点指示器，展示1张Banner图 隐藏导航点指示器，展示2张Banner图，后边距16vp 隐藏导航点指示器，展示3张Banner图，后边距32vp 通过BreakpointType工具类为Swiper组件的displayCount、indicator和nextMargin属性赋值，实现目标效果。
2.  又称网格布局或宫格布局。在不同横向断点下，宫格布局的排布不同。 sm md lg 展示两行四列，共8个元素 展示一行八列，共8个元素 展示一行八列，共8个元素 通过判断当前横向断点，为Grid组件的columnsTemplate属性赋值，实现目标效果。
| sm  | md  | lg  |
| --- | --- | --- |
| 显示导航点指示器，展示1张Banner图  | 隐藏导航点指示器，展示2张Banner图，后边距16vp  | 隐藏导航点指示器，展示3张Banner图，后边距32vp  |
|   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151232.31093619295828294216842279120779:50001231000000:2800:795F9D5BBA686DBFDAED843D8E25C2E293DDDD9C526CA976049B1B3454C538B0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151232.60832335268766393659687298399177:50001231000000:2800:B616672F2030D18D533E6D323F6E1EB0879E6437F05FC0F321A7B443FFE47EDC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151232.90165977691414834508007485431259:50001231000000:2800:EE1D59CF6018AE89B14F96B61FB392833C358E31AC63CCB8D1A944919733C3C7.png)
| sm  | md  | lg  |
| --- | --- | --- |
| 展示两行四列，共8个元素  | 展示一行八列，共8个元素  | 展示一行八列，共8个元素  |
|   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151232.96992587678953606443957887592341:50001231000000:2800:EC186DE5F66030C523CF5D775A0FD4B79D1CEA1676560FAB9B194EDF20F82708.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151232.59855672261611863615400842509362:50001231000000:2800:677D6A8BC1E465FEBDA8C9D9FF35C11D80A7E1D8E8557AA7758C369B87564DA6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151232.40474527752236098269220496005226:50001231000000:2800:0EC246555E99D8AAD55BDE5ED322C23BF3AF105FD1209F1683B12D7146490305.png)
分栏布局
分栏布局可分为二分栏和三分栏，通常用于md、lg横向断点下多栏展示更多内容、高效浏览。使用Navigation组件和SideBarContainer组件，并结合横向断点的方式，可实现目标效果，更多详情请参考一多分栏开发实践。
纵向断点的使用
针对小窗口下的特殊布局（高度相对宽度较小的窗口，呈现横向窗口或类方型窗口时，页面布局进行特殊设计），本章节将介绍实际开发中横向断点+纵向断点结合使用。
技术要点
系统推荐按照以下方式判断横向窗口或类方型窗口，并展示特殊的页面布局。
| 窗口类型  | 横向窗口  | 类方型窗口  |
| --- | --- | --- |
| 效果图  |   |   |
| 判断条件  | 纵向断点为sm 或 窗口高宽比小于0.8  | 纵向断点为md 或 窗口高宽比在[0.8, 1.2)之间  |
窗口类型
横向窗口
类方型窗口
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151232.11379966710270490514972360288194:50001231000000:2800:0ABAA88183F851002FED73EC0BB2BACB01F2907F8BCC7CF16A453926E745CDC9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151232.16875026192818269042848300313486:50001231000000:2800:E363CE1D74EE8D8CF0887E5DFB419ECC25E4950E4F00DE8246A070717EEC6BB4.png)
判断条件
纵向断点为sm 或 窗口高宽比小于0.8
纵向断点为md 或 窗口高宽比在[0.8, 1.2)之间
独特的小窗口布局
在类方型的小窗口中，为了追求用户独特的体验，通常设计为独特的小窗口布局。常见场景为手机上下1:1分屏，此时可通过横向断点为sm，纵向断点为md进行区分，示意图如下。更多详情和示例代码请参考手机上下分屏开发实践。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151233.80233790890135377634551509576219:50001231000000:2800:A9B99506A9AB57ADA00AD8679A150D1C29196736A1EB7C0E996E70E793944C25.png)
类方屏旋转方案
在手机上下1:1分屏等类方屏小窗口场景中，通常设计应用支持旋转，以满足不同的用户体验。
实现原理
```typescript
let currentHeightBreakpoint: string | undefined = AppStorage.get('currentHeightBreakpoint');
if (currentHeightBreakpoint === 'md') {
this.mainWindowClass?.setPreferredOrientation(window.Orientation.AUTO_ROTATION_RESTRICTED);
}
```
1.  通常应用设置旋转方案需要结合多种条件一起判断，详情可参考一多窗口适配开发实践。
其他特殊场景
除了独特的小窗口布局、类方屏旋转方案外，在开发过程存在部分特殊场景仅使用横向断点无法区分，也需要结合横向断点+纵向断点进行判断。
本章节以视频类应用全屏播放页举例，在手机横屏时要求不支持旋转，在大折叠屏（X系列）和平板竖屏时支持旋转，但它们的横向断点都在md范围，无法区分。因此需要使用横向断点和纵向断点的基础上进行区分，兼容多种设备下全屏播放的窗口旋转方案。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151233.81451629802722602724136319336479:50001231000000:2800:EA0BC16B35A545F723D7008A6EAAFD1EF6411D8C554A0373F9C519E1267FA2C2.jpg)
开发步骤
```typescript
export default class EntryAbility extends UIAbility {
private windowObj?: window.Window;
private windowUtil?: WindowUtil = WindowUtil.getInstance();
private onWindowSizeChange: (windowSize: window.Size) => void = (windowSize: window.Size) => {
this.windowUtil!.updateHeightBp();
this.windowUtil!.updateWidthBp();
AppStorage.setOrCreate('windowWidth', windowSize.width);
};
// ...
onWindowStageCreate(windowStage: window.WindowStage) {
// Main window is created, set main page for this ability
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
this.windowUtil!.setWindowStage(windowStage);
windowStage.getMainWindow().then((data: window.Window) => {
this.windowObj = data;
this.windowUtil!.updateWidthBp();
this.windowUtil!.updateHeightBp();
// ...
this.windowObj.on('windowSizeChange', this.onWindowSizeChange);
});
// ...
}
// ...
}
```
1.  手机效果图： 大折叠屏（X系列）半折态： 反例 从上述代码看到，在进入全屏页时，是通过isFoldable、deviceType 和getFoldStatus三个值共同去判断的，这种方式可读性和维护性都比较差，随着鸿蒙生态不断拓展，在不同设备上可能会出现各种异常情况。 正例 综上所述，整理代码如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151233.82902305288185325584028117608231:50001231000000:2800:1974EB5E707C19F149E1F684840571E57E5FC623EB1C7CDDB86447E4FD7C6811.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151233.44731500404150082323605656702898:50001231000000:2800:538C159E7AD09395D753F347F037181F04BE34200EDA90E276A327E7B0037A77.jpg)
通过纵向和横向断点替换掉之前的逻辑，开发者只需关注去维护一套方案即可。以上完成了“全屏播放”页多设备的兼容，实际开发中多设备兼容均可以替换成该方案去适配。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-columns
爬取时间: 2025-05-01 08:30:29
来源: Huawei Developer
概述
目前智能终端设备的种类繁多，不同类型的设备屏幕大小、用户使用习惯也存在不同，这给UI布局以及功能适配带来了很多挑战。以分栏布局为例，在手机、折叠屏以及平板下，最佳显示效果存在如下差异：
| sm  | md  | lg  |
| --- | --- | --- |
|   |   |   |
sm
md
lg
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151233.58374584709247544452630485257643:50001231000000:2800:7072F2FCE4084225BAF452EFC2E130006CC5BA3562D01D1526C50F5A6F76B28D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151234.96363201241599772882624904750584:50001231000000:2800:F97AB3DDD6505E31F1582C1531ECBBDE1B962DC879BB26B34BE78D37ACF159C0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151234.84530711089138303973080212490329:50001231000000:2800:EE5C1134EC45F915EE1ABABB905EF308A930637F0BB30A396371AB16E28B0795.png)
本文提供了一种“通过判断屏幕尺寸，选择合适的分栏布局”的方法，解决HarmonyOS的1+8多种形态设备的UI适配问题。通过该方法，开发者无需关注设备类型，即可达到多设备的自适应分栏布局效果，实现“一次开发，多端部署”。
开发者可以根据屏幕尺寸断点，灵活使用Navigation组件和SidebarContainer组件来实现不同的分栏效果。
分栏实现原理
单双栏：
单双栏通常是使用Navigation实现的，Navigation是路由容器组件，一般作为首页的根容器，包括单栏(Stack)、分栏(Split)和自适应(Auto)三种显示模式。自适应模式下，当页面宽度大于等于一定阈值时，Navigation组件采用分栏模式，反之采用单栏模式。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151234.15346306492907398392811806914161:50001231000000:2800:E8B3A2D1B01D4A650C272D27FCC691D92B0769AE1FC555B9709EF9845023C6AA.png)
开发者可以通过更改Navigation组件的mode值来实现单双栏的切换，如果断点为sm，则mode值为Stack。如果不为sm，则mode值为Split，即可实现单双栏的自适应切换。
三分栏：
Navigation组件实现了单双栏的效果。那么，在更大的屏幕宽度，要实现三分栏效果该如何实现呢？三分栏可以组合使用SideBarContainer与Navigation组件实现。SideBarContainer提供侧边栏可以显示和隐藏的侧边栏容器，通过子组件定义侧边栏和内容区，第一个子组件表示侧边栏，第二个子组件表示内容区。我们可以在内容区中加入Navigation组件，即可实现三分栏效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151234.25400790664424630476829609199345:50001231000000:2800:1A2F168EE977E1BAF17B26B94682168EA60C027B42B992056C403AC65618DC61.png)
我们可以通过更改SideBarContainer组件的showSideBar值来控制是否显示侧边栏。如果断点为lg，则showSideBar值为true，默认显示侧边栏，反之，则为false，不显示。
场景案例
典型场景
应用页面有层级关系，例如一级目录、二级目录、内容区，典型的场景比如日常使用的邮箱功能。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151234.51245932086285765768587820898633:50001231000000:2800:5A283E2388385145F4E37B0C4714220FB8246BDFCB21A322185D05FF6D6A3EB4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151234.60250853109388523747450322957126:50001231000000:2800:853640C1DB22B7E919BDAC9D92D9323B034CC8068749E9DFBDE8476B1469F0AE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151234.87968751886119197607718707680692:50001231000000:2800:4B10F90B125915BF803C73F91C59F0216C7C7B1E125B070F0666B9F991840D24.png)
邮箱是分为三个层级目录，第一层级为账户信息，第二层级为邮件列表（一个账户信息对应多条邮件信息），第三层级为邮件详情，是一个很典型的三分栏场景。根据内容的重要性，开发者通常在单栏显示邮件详情，双栏显示邮件列表、邮件详情，三栏显示账户、邮件列表、内容区。
对于邮箱页面的一多分栏变化，开发者可以抽象为
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151235.89157584356473259732232953992284:50001231000000:2800:3FA7A0A9E2F15B9FA99A26DE08458101EE3D5C87AC80158906F3F436B7E793A1.png)
示例代码
其他场景
大部分情况下，单栏展示的是Navigation的内容区，但是存在某些场景，内容区的优先级比导航区的优先级要低，比如日历日程功能，在单栏的情况下，展示的是日历（Navigation的导航区）。效果如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151235.60003392623242480018320242185891:50001231000000:2800:3C70CFEDDB2E333E45C87785BD1F2577C637DB286509BD427B3A329A22B14369.png)
日历日程分为三个层级，账户消息->日历->日程，开发者通常在单栏显示日历，双栏显示日历、日程，三栏显示账户信息、日历、日程。日历日程页面与邮箱页面的主要区别为，日历日程页面的单栏页面显示Navigation导航栏。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151235.24002600039411133989116025173216:50001231000000:2800:7B0E745219900D3B8E31BA62A443EF30B45387E0A34DCF7B87CCDFE7C4EE4EB4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151235.65763665100371555552956510610330:50001231000000:2800:9AF591C0E1C1DFF5652C8ACE1DA61D9BA1D0B3090A8E6E5850B674796B123C46.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151235.63407371272483325805982812394670:50001231000000:2800:710EF6EAD6E0C2EB84424047672F2C63BED46D439CCE43837067698CE5CC2A68.png)
示例代码
在Navigation的onNavigationModeChange属性中进行判断，当Navigation首次显示或者单双栏状态发生变化时。
还有一种SideBarContainer在页面右边的场景，比如大多数页面的智能客服场景。通过sidebarposition属性设置侧边栏右侧显示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151235.13236465437649958925189120888342:50001231000000:2800:FB746BC3A0D4D933BE23433FF368ABABD4E624F1FF7181D1BACA58D012358763.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-folded-hover
爬取时间: 2025-05-01 08:30:42
来源: Huawei Developer
概述
折叠屏上提供独特的手持操作体验“悬停态”，即用户可以将产品半折后立在桌面上，实现免手持的体验。悬停态场景适用于不需要频繁进行交互的任务，例如视频通话、播放视频、拍照、听歌等。折叠屏进入悬停态时，中间弯折的区域难以操作且显示内容会变形，因此建议页面内容进行折痕区避让适配。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151235.76829063582961206732255959707206:50001231000000:2800:351109E521E30DAE39D2EC859E640243E69AB379936EB084819B197D84CC46A0.png)
本文提供折叠屏悬停态的三种实现方式，并根据其特点给出各自的适用场景。
对于上面实现悬停态的三种方式，FolderStack组件使用简单，不需要开发者关注设备的状态，可自定义页面布局；FoldSplitContainer同样使用简单，但固定二分栏和三分栏布局限制了使用场景；自定义实现悬停态需要开发者自实现设备状态的监听和调整组件布局，支持自定义布局，并且由于自实现悬停态监听，可限制设备进入悬停态的场景（例如仅允许在横屏下半折叠设备才能进入悬停态）以及自定义窗口旋转策略，使用更加灵活。
|    | FoldStack  | FoldSplitContainer  | 自实现悬停态  |
| --- | --- | --- | --- |
| 展开态/折叠态是否支持自定义布局  | 支持  | 不支持，固定二分栏/三分栏  | 支持  |
| 是否支持由其他页面进入悬停态页面  | 支持  | 支持  | 支持  |
| 是否支持自定义设备状态进入悬停态页面  | 不支持  | 不支持  | 支持  |
| 是否支持自定义悬停态窗口旋转策略  | 不支持  | 不支持  | 支持  |
| 开发难度  | 简单  | 简单  | 难  |
FoldStack
FoldSplitContainer
自实现悬停态
展开态/折叠态是否支持自定义布局
支持
不支持，固定二分栏/三分栏
支持
是否支持由其他页面进入悬停态页面
支持
支持
支持
是否支持自定义设备状态进入悬停态页面
不支持
不支持
支持
是否支持自定义悬停态窗口旋转策略
不支持
不支持
支持
开发难度
简单
简单
难
本文以视频播放类应用的全屏播放页面为例，介绍FolderStack和自定义实现悬停态，以游戏界面为例介绍FoldSplitContainer实现悬停态。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151236.31785400463636361145122721734635:50001231000000:2800:8214142C602D31AECA483EA23423F304792D9A33A93B8BC816EA896A192CFEA8.png)
使用FolderStack组件实现悬停态
实现原理
FolderStack是系统提供的ArkTS组件，继承自层叠布局Stack组件。在Stack组件的基础上，FolderStack提供监控设备是否进入悬停态并进行重新布局的能力。
FolderStack通过upperItems字段来实现悬停态布局，当设备进入悬停态时，被upperItems字段修饰的组件会堆叠在上半屏，其他未被修饰的组件会堆叠在下半屏并且自动避让折叠屏折痕区。
FolderStack如果不撑满页面全屏，则只作为普通Stack使用。
开发步骤
FolderStack组件实现悬停态的代码使用FolderStack作为页面的父容器，同时将视频播放组件的ID注册到upperItem数组里，这样在悬停态时视频播放组件会自动调整到上半屏显示，而视频控制组件和顶部返回组件将在下半屏显示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151236.72929787397970050986399968465962:50001231000000:2800:0BCCD9D7F26EBA0B1CF8098BDD06985B9C562D605DFB205846EDFBB8DE84B5DF.png)
使用FoldSplitContainer组件实现悬停态
实现原理
FoldSplitContainer是系统提供的分栏类型的ArkTS组件，可以实现折叠屏二分栏、三分栏在展开态、悬停态以及折叠态的区域控制。其中二分栏是上下分栏，三分栏是在二分栏基础上加上侧边栏。
FoldSplitContainer的primary和secondary参数分别设置二分栏的上下区域的布局，extra参数设置三分栏中侧栏区域的布局；通过LayoutOptions参数设置各区域分栏的比例。当设备进入悬停态时，FoldSplitContainer会自动避让折叠屏折痕区。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151236.22626211274509478384362016065811:50001231000000:2800:300AC88F885D04F81F7281004125E45073429C40547661B1DEA6531A03817809.png)
开发步骤
使用FoldSplitContainer组件实现悬停态的代码结构是将上下屏的组件分别注册到primary和secondary参数的回调中，这样页面就呈现为上下分栏布局，并且会在悬停态自动避让折痕区域。这里二分栏结构就可以实现页面布局，因此没有实现extra参数对应的侧栏。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151236.67613305901067047322727635622970:50001231000000:2800:01E3E9760D08B368D7126F7AAC85538B671D08A78DB98719D5CF969566D8DFC3.png)
自定义实现悬停态
实现原理
自定义悬停态布局需要在折叠屏进入半折叠态时通过设置窗口横向显示、规避折痕避让区，调整页面内组件的尺寸和位置来实现，可分为监听悬停态和调整布局两部分。
在退出应用或者退出需要监听折叠态变化的页面时，需要调用display.off('foldStatusChange')接口取消监听，避免出现意想不到的问题。
开发步骤
自定义实现悬停态的视频播放页的UI结构与使用FolderStack组件的结构相同，只是将FolderStack替换为普通的Stack组件；主要是实现悬停态的监听和组件的重新布局。
1.  视频控制组件仍处于下半屏，无需调整。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151236.04622011415727450315374337309273:50001231000000:2800:19885927A140DD642A5A988E08F679B9112505A607AC8A2E4D47C99EC8D3DA41.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-interaction
爬取时间: 2025-05-01 08:30:57
来源: Huawei Developer
概述
在多设备应用的开发中，交互体验是衡量应用体验的关键指标之一。进行一多项目开发时，需要考虑不同输入设备的交互方式，例如触控屏、触控板、鼠标、键盘和遥控器等，本文将对不同输入设备对应常见的交互方式进行介绍。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151236.79841294806907261636385951850629:50001231000000:2800:24B57B6030EAE5B198FB4FFF73CF91569B1DB3ADC4EE49339D15943DE7BB91A5.jpg)
本文对于一多开发过程中涉及到的常见交互事件进行归纳总结，包含系统已提供默认实现的交互归一事件适配，以及需要开发者自行进行设计与代码实现的交互操作：焦点导航事件适配、键盘快捷键事件适配。
交互归一事件适配
对于不同类型的智能设备的基础输入，用户可能有不同的交互方式。例如，在手机、折叠屏、平板上通过触控屏交互，在PC/2in1设备上通过触控板、鼠标交互。
如果针对不同的交互方式单独进行适配，在增加开发工作量的同时，还会造成代码大量重复。为解决这一问题，系统统一了各种交互方式的API，实现了交互归一。
交互归一是一种适配多设备输入的交互响应框架，通过将不同设备的交互行为转化为同一个交互事件，保证组件在不同交互场景下的体验一致性。系统将基础的交互操作实现了交互归一，实现兼容多设备交互方式的界面级一多。开发者只需要调用所需的交互事件接口，无需为每个输入设备单独适配，从而大幅简化开发流程。
下文将以悬浮场景和缩放场景为例，介绍交互归一的代码实现方案。
-  当用户使用指向性设备 (鼠标、触摸板、 AR/VR 手柄等) 操作时，应用页面内所有支持交互的UI组件，都应适配光标悬浮效果，提供视觉反馈。 系统已提供默认的实现，组件设置通用属性hoverEffect即可实现。目前支持四种光标悬浮效果，请参考光标悬浮效果枚举值。 此外，组件可以通过通用事件onHover来实现自定义鼠标或手写笔的悬浮事件。
-  缩放场景绑定PinchGesture事件，当识别到捏合/张开手势、或Ctrl键+滚动滚轮时触发。需要在其回调函数中进行相关逻辑处理，实现缩放。 例如：在具体内容页面，如一张图片，在手机、折叠屏和平板设备上，手势捏合或张开时表现为图片缩小或放大；在PC/2in1设备上，Ctrl+滚轮向后滚动或向前滚动表现为图片缩小或放大。 类似地，在布局场景中，如网格，在手机、折叠屏和平板设备上，一般表现为布局的列数的增加或减少；在PC/2in1设备上，通过Ctrl+滚轮滚动表现为相同效果。 上述交互逻辑已由系统默认实现，开发者仅需实现事件触发时应用如何响应即可。其他场景下方案类似，绑定对应的事件实现。 以一多长视频为例，绑定PinchGesture事件后，在回调函数中判断手势事件的缩放比例，若比例 > 1，表示用户执行放大操作，网格展示列数增多；若比例 < 1，表示用户执行缩小操作，网格展示列数减少。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151237.79648414743614948073206871973734:50001231000000:2800:59EE98790AEC3EFD02107D9B0DC2E1DCC8E171CA35D464D5BB67CA83F6644752.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151237.02968612385834259034772437277328:50001231000000:2800:223BC242FAE2F42BC04CDFE7E2B7A0D1FFECC09F93F0C6992E55C0B9118D014D.gif)
焦点导航事件适配
当用户使用键盘、电视遥控器、车机摇杆/旋钮等非指向性输入设备与应用程序进行间接交互时，为保证交互体验，建议设置页面中可操作元素为可获焦状态，并为其配置获焦视觉效果。
-  部分组件默认可获焦，如Button、TextInput等基础组件和Column、Row等大部分的容器组件；若组件有获焦能力但默认不可获焦，如Text、Image等组件，可以设置通用属性focusable(true)使其可获焦。
更多焦点事件的能力和规范请参考焦点事件，自定义组件的走焦效果请参考焦点控制。
| 走焦常用属性  | 参数  | 描述  |
| --- | --- | --- |
| focusable  | boolean  | 设置当前组件是否可以获焦  |
| tabIndex  | number  | 自定义组件Tab键走焦顺序值  |
| defaultFocus  | boolean  | 设置当前组件是否为当前页面上的默认焦点  |
走焦常用属性
参数
描述
focusable
boolean
设置当前组件是否可以获焦
tabIndex
number
自定义组件Tab键走焦顺序值
defaultFocus
boolean
设置当前组件是否为当前页面上的默认焦点
```typescript
Swiper() {
LazyForEach(this.bannerDataSource, (item: Banner, index: number) => {
// ...
Image(item.getBannerImg().getImgSrc())
.objectFit(ImageFit.Fill)
.borderRadius(16)
.height('100%')
.width('100%')
.focusable(true)
.zIndex(1)
// ...
}, (item: Banner, index: number) => index + JSON.stringify(item))
}
.tabIndex(getTabIndex('Banner'))
```
键盘快捷键事件适配
当用户使用键盘与应用程序交互时，需要适配键盘快捷键，便于用户的操作。比如在PC/2in1设备上的游戏，需要提供快捷键功能，优化用户体验；在音视频应用中，需要支持快捷键对音视频快速操作。
以音视频播放场景为例，对键盘的适配有以下需求：
| 快捷键  | 功能  |
| --- | --- |
| Space  | 播放/暂停  |
| 左键/右键  | 长视频场景：后退10s/前进10s；短视频场景：应用自定义，如切换上一个/下一个视频  |
| 双击视频区域  | 进入沉浸式全屏视频播放  |
| ESC  | 退出沉浸式全屏视频播放  |
快捷键
功能
Space
播放/暂停
左键/右键
长视频场景：后退10s/前进10s；短视频场景：应用自定义，如切换上一个/下一个视频
双击视频区域
进入沉浸式全屏视频播放
ESC
退出沉浸式全屏视频播放
通用事件onKeyEvent支持响应按键事件。需要注意的是，若希望某组件响应onKeyEvent，需要其处于获焦状态。
通过条件判断onKeyEvent事件回调方法的参数KeyEvent中具体信息，如按键类型（按键按下/松开）、按键键码（用户按下的具体按键）等信息，实现对应的逻辑处理。
根据具体业务需要，在回调方法中，首先要判断触发事件的按键类型KeyType，否则事件会连续触发两次。例如，需要在按键松开时执行后续代码逻辑，则需要在进入回调方法时，判断按键类型为Down时结束回调方法，否则方法将在按键按下和松开时均执行。
全量的键鼠适配UX规范请参考设计指南。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-window
爬取时间: 2025-05-01 08:31:12
来源: Huawei Developer
概述
在一多开发过程中，开发者需要适配多种不同窗口类型（WindowType），且同一窗口类型在不同设备上会有不同的属性（尺寸大小、系统区域、是否沉浸、自由窗口有标题栏等），针对窗口类型及属性的差异所产生的问题，本文将提供相应说明以及解决方案指导。包含以下常见场景：
窗口尺寸变化更新断点
应用页面展示时，要求窗口宽度在一定范围内，页面展示相同的页面布局。基于该原则，将窗口宽度划分为不同的范围（即断点），当窗口宽度从一个断点变化到另一个断点时，改变页面布局（如将页面内容从单列排布调整为双列排布甚至三列排布等）以获得更好的显示效果。
在实际开发过程中，仅靠窗口宽度计算的横向断点，无法区分所有窗口场景，比如手机切换横屏和折叠屏展开窗口时宽度都在600-840vp，即横向断点均为“md”，但两者的页面布局不同。因此，需要引入纵向断点并监听横纵向断点变化，实现区分多设备场景以及窗口变化场景。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151237.41652471417195051792271099236407:50001231000000:2800:99F17653B64506BC11EC13A541B1523CA420F82D61074B519DA82C434B9F7592.png)
实现原理
横向断点使用窗口宽度计算，纵向断点使用窗口的宽高比计算，详细断点分类可以参考横纵向断点的设计原理。根据不同断点对应的UX设计，使用横向及纵向断点判断并展示不同的页面布局。
使用window (窗口)的用getWindowProperties()接口获取窗口创建时的宽高计算横纵向断点。并使用on('windowSizeChange')接口监听窗口尺寸变化，窗口更新时获取变更后的窗口尺寸，更新横纵向断点。
开发步骤
示例代码请参考：多设备断点开发实践。
窗口横竖屏旋转适配
在开发一多应用时，需要兼容多设备上的旋转策略。当前应用开发中通常使用以下两种方案控制旋转策略。伴随着鸿蒙生态拓展，这两种方案也带来一些问题。
方案一：依靠设备类型或设备状态判断是否支持旋转
采取当前方案会导致以下问题：
方案二：根据窗口宽高判断是否支持旋转
采取当前方案会导致以下问题：
实现原理
为解决以上方案的不足，根据当前鸿蒙生态设备的实际使用场景，建议旋转策略如下：
| 设备场景  | 是否需要支持横竖屏旋转  |
| --- | --- |
| 手机（直板机）  | 由应用决定是否需要支持，默认不支持  |
| 折叠屏-小折叠（Pocket系列）  | 内屏（正面大屏）：同直板机手机 外屏（背面小屏）：类方屏需要支持  |
| 折叠屏（X系列）  | 内屏（展开状态）：类方屏需要支持 外屏（折叠状态）：同直板机手机  |
| 三折叠（XT系列）  | F态（单屏显示）：同直板机手机 M态（双屏显示）：类方屏需要支持 G态（三屏显示）：需要支持  |
| 平板全场景  | 需要支持  |
| PC/2in1  | 系统不响应应用方向事件，无法支持  |
设备场景
是否需要支持横竖屏旋转
手机（直板机）
由应用决定是否需要支持，默认不支持
折叠屏-小折叠（Pocket系列）
内屏（正面大屏）：同直板机手机
外屏（背面小屏）：类方屏需要支持
折叠屏（X系列）
内屏（展开状态）：类方屏需要支持
外屏（折叠状态）：同直板机手机
三折叠（XT系列）
F态（单屏显示）：同直板机手机
M态（双屏显示）：类方屏需要支持
G态（三屏显示）：需要支持
平板全场景
需要支持
PC/2in1
系统不响应应用方向事件，无法支持
根据以上常用设备类型上的应用窗口属性，将一多横竖屏旋转适配方案整理为：
示例代码
针对一多横竖屏推荐的旋转方案，通用的适配方案参考如下代码。
```typescript
import { UIAbility } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { window } from '@kit.ArkUI';
import { BusinessError, deviceInfo } from '@kit.BasicServicesKit';
export default class EntryAbility extends UIAbility {
windowObj: window.Window | undefined = undefined;
private onWindowSizeChange: (data: window.Size) => void = (data: window.Size) => {
this.setDefaultOrientation();
}
// ...
setDefaultOrientation(): void {
const BREAKPOINT_MD = 600;
let windowRect: window.Rect = this.windowObj!.getWindowProperties().windowRect;
let windowWidthVp: number = px2vp(windowRect.width);
let windowHeightVp: number = px2vp(windowRect.height);
let aspectRatio: number = windowHeightVp / windowWidthVp;
if (Math.min(windowWidthVp, windowHeightVp) >= BREAKPOINT_MD || (aspectRatio < 1.2 && aspectRatio >= 0.8) || deviceInfo.deviceType === 'tablet') {
// Rotation supported.
this.windowObj?.setPreferredOrientation(window.Orientation.AUTO_ROTATION_RESTRICTED);
} else {
// Portrait display.
this.windowObj?.setPreferredOrientation(window.Orientation.PORTRAIT);
}
}
onWindowStageCreate(windowStage: window.WindowStage): void {
// Main window is created, set main page for this ability
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
windowStage.getMainWindow().then((windowObj) => {
this.windowObj = windowObj;
this.setDefaultOrientation();
this.windowObj.on('windowSizeChange', this.onWindowSizeChange);
}).catch((err: BusinessError) => {
hilog.error(0x0000, 'testTag', `Failed to obtain the main window. Cause code: ${err.code}, message: ${err.message}`);
});
windowStage.loadContent('pages/Index', (err) => {
if (err.code) {
hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
return;
}
hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
});
}
// ...
}
```
窗口沉浸式页面适配
应用开发过程中，窗口默认为非沉浸式，即页面无法拓展至顶部状态栏及底部导航栏等避让区。此时存在避让区与页面颜色不一致以及底部导航栏空间无法利用的问题，因此需要手动设置沉浸式。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151238.39123015816276207879522550696861:50001231000000:2800:F6D1E0B3F8DCA0FB9C17BFAA56FC6CF8DEA9F3F6D0DC27E67B546F7B7B7D0C08.png)
实现原理
窗口沉浸式页面通过应用页面延伸到状态栏和导航栏的方式实现。设置应用沉浸式布局后，为避免应用布局被顶部状态栏或底部导航栏遮挡，需要获取窗口规避区，在页面布局中进行避让。
使用setWindowLayoutFullScreen(true)方法设置窗口为全屏模式，页面布局会拓展到顶部状态栏及底部导航栏，此时部分布局会被遮挡。通过getWindowAvoidArea()接口以及on('avoidAreaChange')接口获取到系统避让区高度，据此在页面顶部及底部使用padding属性避让状态栏和导航栏。
开发步骤
```typescript
import { UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
export default class EntryAbility extends UIAbility {
// ...
private onAvoidAreaChange: (avoidArea: window.AvoidAreaOptions) => void = (avoidArea: window.AvoidAreaOptions) => {
if (avoidArea.type === window.AvoidAreaType.TYPE_SYSTEM) {
// Updates the height of the top status bar.
AppStorage.setOrCreate('topAvoidHeight', px2vp(avoidArea.area.topRect.height));
} else if (avoidArea.type === window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
// Updated the bottom navigation bar.
AppStorage.setOrCreate('bottomAvoidHeight', px2vp(avoidArea.area.bottomRect.height));
}
};
onWindowStageCreate(windowStage: window.WindowStage): void {
windowStage.getMainWindow((err, window: window.Window) => {
// ...
window.setWindowLayoutFullScreen(true);
let topAvoidHeight: window.AvoidArea = window.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);
AppStorage.setOrCreate('topAvoidHeight', px2vp(topAvoidHeight.topRect.height));
let bottomAvoidHeight: window.AvoidArea =
window.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR);
AppStorage.setOrCreate('bottomAvoidHeight', px2vp(bottomAvoidHeight.bottomRect.height));
});
window.on('avoidAreaChange', this.onAvoidAreaChange);
// ...
}
}
```
应用窗口化适配
在PC/2in1设备上，应用正常启动默认应该为自由窗口模式而非全屏。在应用适配PC/2in1设备过程中，实际存在应用启动默认全屏模式而非推荐的自由窗口，以及拖动自由窗口导致尺寸过小页面布局异常的问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151238.60467436152087117194426119788664:50001231000000:2800:095CB7EEB19F175EDC59A6FE03C5E6AB8279CFAF4F7F66B8C73FD6C5DFF672C2.png)
实现原理
-  PC/2in1设备启动默认全屏是因为应用在其他设备上为实现沉浸式使用setWindowLayoutFullScreen(true)接口设置全屏导致的。需要判断PC/2in1设备类型，仅在非PC/2in1设备时设置全屏。
-  自由窗口支持自由拖动改变大小，可以通过开发实际规格配置窗口的最小尺寸，保证页面的正常显示。
示例代码
PC/2in1设备上的完整代码工程可参考一多长视频。
应用窗口化标题栏沉浸式适配
在PC/2in1设备上，自由窗口默认包含支持移动、缩小、放大、关闭窗口的标题栏。开发者可通过设置应用窗口的标题栏不可见，将应用页面拓展至原标题栏区域，实现窗口沉浸式。效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151239.52473300888662651213841971945097:50001231000000:2800:AEAA00E88A7BAA71B809A86B72C74EA7EFDE601B78CD1231C812A556ABA64130.png)
实现原理
PC/2in1设备窗口标题栏包含应用图标，应用名称，以及三键（全屏/还原、最小化、关闭）。通过设置标题栏不可见，隐藏应用图标及应用名称保留三键区的方式实现窗口沉浸式。
使用setWindowDecorVisible(false)设置窗口标题栏不可见，此时应用页面拓展至标题栏区域。使用setWindowDecorHeight()接口设置导航栏高度，控制右上角三键区显示以及显示高度。
示例代码
在UIAbility的onWindowStageCreate生命周期回调中，判断PC/2in1设备类型，调用setWindowDecorVisible(false)接口设置标题栏不可见，调用setWindowDecorHeight()接口设置右上角三键区的高度。
```typescript
import { UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { deviceInfo } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
export default class EntryAbility extends UIAbility {
// ...
onWindowStageCreate(windowStage: window.WindowStage): void {
windowStage.loadContent('pages/Index', (err) => {
if (err.code) {
hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err));
return;
}
hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
});
// ...
windowStage.getMainWindow().then((data: window.Window) => {
let deviceTypeInfo: string = deviceInfo.deviceType;
if (deviceTypeInfo === '2in1') {
// Set the title bar of the 2in1 device to be invisible after the loadContent() call takes effect.
data.setWindowDecorVisible(false);
// When the title bar is invisible, set the height of the title bar and control the height of the three buttons (full screen/restore, maximize, and close) in the upper right corner.
data.setWindowDecorHeight(64);
}
})
// ...
}
}
```
PC/2in1上的完整代码工程请参考一多商务办公。
自由窗口的全屏沉浸式适配
在视频类应用适配PC/2in1设备时，需要实现视频播放页在自由窗口与全屏沉浸式切换功能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151239.13120573375088056379463032224996:50001231000000:2800:01A5D2AE7E3E69ECDF47A5EC1EFB70AFC68A72960DC968F3D88CD182FCDF3B48.png)
实现原理
通过调用窗口状态操作的接口，实现应用全屏沉浸式与自由窗口的切换。以长视频应用为例，视频播放界面，在PC/2in1设备上需要支持沉浸式体验，适配指导如下：
| 状态  | 用户操作  | 使用接口  |
| --- | --- | --- |
| 应用窗口化播放视频  | 执行以下操作后应进入沉浸式视频全屏播放： 鼠标双击视频区域用户点击视频全屏按钮  | maximize()：设置窗口最大化时的布局效果，接口默认传入参数为ENTER_IMMERSIVE实现最大化时进入沉浸式布局效果。  |
| 沉浸式全屏播放视频  | 执行以下操作后应退出全屏沉浸式回到窗口状态： 按下ESC键点击退出全屏按钮  | recover()：还原为浮动窗口，恢复为进入全屏前的大小和位置。  |
状态
用户操作
使用接口
应用窗口化播放视频
执行以下操作后应进入沉浸式视频全屏播放：
maximize()：设置窗口最大化时的布局效果，接口默认传入参数为ENTER_IMMERSIVE实现最大化时进入沉浸式布局效果。
沉浸式全屏播放视频
执行以下操作后应退出全屏沉浸式回到窗口状态：
recover()：还原为浮动窗口，恢复为进入全屏前的大小和位置。
开发步骤
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
import { window } from '@kit.ArkUI';
import { hilog } from '@kit.PerformanceAnalysisKit';
@Observed
export class WindowUtil {
private mainWindowClass?: window.Window;
// ...
maximize(): void {
if (this.mainWindowClass!.getWindowStatus() === window.WindowStatusType.FLOATING) {
this.mainWindowClass!.maximize()
.then(() => {
hilog.info(0x0000, 'testTag', '%{public}s', `Succeed in maximizing the window.`);
})
.catch((err: BusinessError) => {
hilog.error(0x0000, 'testTag', `Failed to maximize the window. Code: ${err.code}, message: ${err.message}`,
JSON.stringify(err) ?? '');
});
}
}
// ...
}
```
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
import { window } from '@kit.ArkUI';
import { hilog } from '@kit.PerformanceAnalysisKit';
@Observed
export class WindowUtil {
private mainWindowClass?: window.Window;
// ...
recover(): void {
if (this.mainWindowClass!.getWindowStatus() === window.WindowStatusType.FULL_SCREEN) {
this.mainWindowClass!.recover()
.then(() => {
hilog.info(0x0000, 'testTag', '%{public}s', `Succeed in recovering the window.`);
})
.catch((err: BusinessError) => {
hilog.error(0x0000, 'testTag', `Failed to recover the window. Code: ${err.code}, message: ${err.message}`,
JSON.stringify(err) ?? '');
});
}
}
// ...
}
```
PC/2in1上的完整代码工程请参考一多长视频。
常见问题
不同设备默认的窗口模式是什么
手机、折叠屏、平板上应用的默认窗口模式为全屏模式，windowStatusType为1。PC/2in1上应用自由窗口的窗口模式为自由悬浮形式窗口模式，windowStatusType为4，全屏后为全屏模式，windowStatusType为1。窗口模式见下表：
| 名称  | 值  | 说明  |
| --- | --- | --- |
| UNDEFINED  | 0  | 表示APP未定义窗口模式。  |
| FULL_SCREEN  | 1  | 表示APP全屏模式。  |
| MAXIMIZE  | 2  | 表示APP窗口最大化模式。  |
| MINIMIZE  | 3  | 表示APP窗口最小化模式。  |
| FLOATING SPLIT_SCREEN  | 4 5  | 表示APP自由悬浮形式窗口模式。 表示APP分屏模式。  |
名称
值
说明
UNDEFINED
0
表示APP未定义窗口模式。
FULL_SCREEN
1
表示APP全屏模式。
MAXIMIZE
2
表示APP窗口最大化模式。
MINIMIZE
3
表示APP窗口最小化模式。
FLOATING
SPLIT_SCREEN
4
5
表示APP自由悬浮形式窗口模式。
表示APP分屏模式。
参考窗口模式枚举

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-web-adaptation
爬取时间: 2025-05-01 08:31:27
来源: Huawei Developer
概述
本文主要介绍Web侧如何进行多设备适配，结合Web组件实现在不同设备上的定制体验。内容涵盖Web侧提供的多设备适配能力，如相对单位、媒体查询、监听窗口变化事件，并针对前端布局中常见的宫格布局、自定义弹窗、轮播布局介绍一多适配的实现思路与方案。
实现原理
相对单位
在Web开发中，经常需要控制元素尺寸、边距、大小等属性来调整页面效果，而在定义这些属性时都需要用到CSS提供的元素尺寸单位。在CSS中元素尺寸单位主要分为绝对单位和相对单位两大类。
| 单位  | 相对元素  | 使用场景  | 示例代码  |
| --- | --- | --- | --- |
| %  | 百分比单位，相对于包含块（通常是父元素）的尺寸。  | 常用于响应式设计中，使元素的大小相对于其父元素调整。  | 
.parent {  width: 400px;}.child {  width: 50%; /* 200px */}  |
| em  | 相对于当前元素的字体大小。如果当前元素的字体大小未设置，则相对于其父元素的字体大小。  | 用于文本大小和基于文本的间距，便于通过调整字体大小来改变布局。  | 
p {  font-size: 16px;}span {  font-size: 1.5em; /* 24px */}  |
| rem  | 相对于根元素（html元素）的字体大小。  | 与em类似，但更加一致，因为所有rem值都基于同一个根元素的大小，易于全局调整。  | 
html {  font-size: 16px;}p {  font-size: 1rem; /* 16px */}span {  font-size: 1.5rem; /* 24px */}  |
| vw/vh  | 相对于视窗（浏览器窗口）尺寸，vw相对于浏览器窗口宽度，vh相对于浏览器窗口高度。  | 元素尺寸完全基于视窗宽度，例如弹窗遮罩层。  | 
.overlay {  width: 100vw; /* equal to the width of the viewport */  height: 100vh; /* equal to the height of the viewport */}  |
单位
相对元素
使用场景
示例代码
%
百分比单位，相对于包含块（通常是父元素）的尺寸。
常用于响应式设计中，使元素的大小相对于其父元素调整。
em
相对于当前元素的字体大小。如果当前元素的字体大小未设置，则相对于其父元素的字体大小。
用于文本大小和基于文本的间距，便于通过调整字体大小来改变布局。
rem
相对于根元素（html元素）的字体大小。
与em类似，但更加一致，因为所有rem值都基于同一个根元素的大小，易于全局调整。
vw/vh
相对于视窗（浏览器窗口）尺寸，vw相对于浏览器窗口宽度，vh相对于浏览器窗口高度。
元素尺寸完全基于视窗宽度，例如弹窗遮罩层。
CSS侧设置的px单位会自动通过DPR(devicePixelRatio)进行换算，这使得设置的px单位与HarmonyOS侧的vp单位具有同等的视觉效果。该特性可以屏蔽设备物理像素差异，便于Web应用向HarmonyOS侧迁移。
媒体查询
媒体查询允许开发者根据设备的特性（如屏幕尺寸、分辨率、方向等）来应用不同的样式规则。这使得网页能够在不同设备和屏幕尺寸下都有良好的显示效果，提升用户体验。在Web页面适配HarmonyOS侧一多时，横纵向断点对应的尺寸范围与HarmonyOS侧推荐的断点划分范围保持一致。
在使用HarmonyOS侧纵向断点时，需要注意Web侧区分纵向断点时使用宽高比，HarmonyOS侧定义的纵向断点使用高宽比。
例如以下媒体查询代码，当视口宽度满足不小于840px时，应用了article的类样式的字体大小将变为20px。当视口宽度满足大于等于320px且小于600px，视口宽高比大于1/1.2且小于等于1/0.8时，符合手机上下分屏的小窗口，字体大小将变为14px。
场景一：修改字体大小
实现原理：利用CSS中的媒体查询@media能力，设置不同断点尺寸下的字体大小实现响应式布局，下文以常见的sm、md、lg为例进行适配。
由此可以实现在不同屏幕尺寸上，拥有不同的字体大小。
场景二：修改图片宽度
实现原理：通过CSS的媒体查询@media能力，设置不同断点下的图片宽度实现响应式布局，下文以常见的sm、md、lg为例进行适配。
由此可以实现在不同屏幕尺寸上，拥有不同的元素尺寸。
添加窗口事件
window对象提供了resize事件注册，该事件将在文档视图（窗口）调整大小时触发。当无法使用相对单位或媒体查询实现多设备体验时，可以考虑通过JavaScript去注册窗口变化的resize事件，然后通过window.innerHeight获取到变化后的窗口高度，通过window.innerWidth获取到变化后的窗口宽度，开发者可以根据获取到的窗口尺寸，结合CSS与HTML完成多设备体验适配。本章节以一个等比例修改字体大小的场景为例，根据窗口宽度，动态计算字体大小变化。
布局设计
宫格布局
CSS中提供了grid布局，与栅格布局类似，它将网页内容划分成一个一个的网格，通过任意组合不同的网格，从而做出各种各样的布局。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151239.59044919950543461244576376080734:50001231000000:2800:D9211F901A13AED7AFF64A235F798AEFFA740C6EDE8BD7FB7CA761D3854112D0.png)
关于宫格布局，有许多的概念，此处只介绍其中部分关键概念，更多概念开发者可自行查找CSS grid介绍。
使用宫格布局，需参考以下步骤：
例如希望宫格元素按照两行三列进行排列，列宽行高均为100px，行列间距固定为20px，代码如下所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151239.29046453959108804694523159884378:50001231000000:2800:D2C9CD2471C99B81FA65AFE2D232420C67844C289DC54D08BEAEBAC504A02793.png)
可以看到当元素个数较少的时候，还可以通过逐个书写（即grid-template-columns: 100px 100px 100px）的方式进行排列的指定，可是当元素数量较多，如一行有十列时，这种写法可读性就会变差，由此需要引入repeat()函数，该函数接收两个参数，第一个参数为重复的次数，第二个参数为要重复的值。例如刚刚的写法也可以写成grid-template-columns: repeat(3, 100px)的形式，效果是一样的。但是在有多列时，该函数能帮助简化书写。
宫格布局可以结合媒体查询来完成宫格布局在不同设备上的体验，通过设置不同尺寸范围的排列方式来实现不同屏幕尺寸的不同效果，例如希望实现以下宫格效果。
| 断点  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
断点
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151240.48107713780260116731686107624087:50001231000000:2800:07C27D9220FD7847487375CD06E0034E176DAB78D5E37727AF0522DFF9C29B7B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151240.21077875413541346077416007362167:50001231000000:2800:8DB0EA6A705C1FB8FA53D67281B86BBCB56FC66D80274148E498F9F4760BEA79.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151240.50802536411000922462789166523713:50001231000000:2800:5B2D0B7A6154EB0D15BF5BD3272A021EDB6C1236F617A1DB647F495BDA2AAAF6.png)
自定义弹窗
弹窗在用户交互中比较常见，在大尺寸设备上有更大的弹窗展示，可以避免弹窗内容过小，不易看清。实现上需要通过CSS的媒体查询@media能力，设置不同断点下的弹窗尺寸。如希望实现以下效果。
| 断点  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
断点
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151240.08488098116458018263745631820548:50001231000000:2800:E43922017B89C2ACC00AE777C2C8A304A60347704FA88A56A825CFD9A2C90DEF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151240.99406105800014399327793001531580:50001231000000:2800:9BE19E3CDAFCCDC56206F069C033DDF998B6D20599E7C41EC52FAAA0601AE9BE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151240.02168997315934093001225363847516:50001231000000:2800:0B5BB7BAB043850F0BA616FF0D1414DC0170CF386762BB42BE41258103EE4145.png)
需要注意的是，一般情况下不止需要对弹窗的尺寸进行响应式的适配，对于弹窗的内容也是需要进行响应式的适配，但是由于弹窗内容一般高度定制，难以提供出一个统一的方式去进行适配，此时需要开发者根据弹窗内容采用合适的适配方案自行适配。
轮播布局
轮播布局，也就是平常说的轮播图，提供了多张图片轮流播放的功能，虽然原生Web并未提供直接实现轮播图的组件，但是可以通过一些技巧或者直接复用三方组件库，实现轮播图的效果。轮播布局的一多适配关键点如下：
此处只提供如下常见的轮播图一多效果并进行实现。
| 断点  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
断点
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151241.95848437204531859361447743059923:50001231000000:2800:4068D9327AAE4C8B39F1CD672ABB7C7CB5E6F8AE38060C6734942DCFBA6B1E00.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151241.71121977762537146872652262704534:50001231000000:2800:2DF33BA03CCDE7004D75028C74D00FA89B1B70020E4B730A7818C26F4436F7C7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151241.24535706512514036480231889352645:50001231000000:2800:9B0692B37D4F028A18E09F88CF02F2807297AF34AF2B2B329CDC852798083698.png)
```typescript
const Banner = () => {
const banner = [
{id: "001", url: "assets/banner01.png"},
{id: "002", url: "assets/banner02.png"},
{id: "003", url: "assets/banner03.png"},
{id: "004", url: "assets/banner04.png"},
];
const [currentIndex, setCurrentIndex] = useState(1);
const [currentDot, setCurrentDot] = useState(0);
const [width, setWidth] = useState<number>(0);
const [singleOffset, setSingleOffset] = useState<number>(0);
const [initOffset, setInitOffset] = useState<number>(0);
const [gap, setGap] = useState(16);
const [animate, setAnimate] = useState("transform 0.5s ease");
const [dotVisible, setDotVisible] = useState(false);
const wrapperRef = useRef<HTMLDivElement>(null);
const totalItems = banner.length;
useEffect(() => {
const updateLayout = () => {
const winWidth = window.innerWidth;
if (winWidth < 600) {
setGap(0); // set the distance between elements under the sm breakpoint.
setWidth(winWidth - 32); // sets the element width under the sm breakpoint.
setSingleOffset(winWidth - 32);  // sets the single displacement under the sm breakpoint.
setInitOffset(0);  // sets the initial offset under the sm breakpoint.
setDotVisible(true);
} else if (winWidth < 840) {
setGap(12); // set the distance between elements under the md breakpoint.
setWidth((winWidth - 48 - gap) / 2); // sets the element width under the md breakpoint.
setSingleOffset(width + gap); // sets the single displacement under the md breakpoint.
setInitOffset(24); // sets the initial offset under the md breakpoint.
setDotVisible(false);
} else {
setGap(16); // set the distance between elements under the lg breakpoint.
setWidth((winWidth - 250 - gap) / 2); // sets the element width under the lg breakpoint.
setSingleOffset(width + gap);// sets the single displacement under the lg breakpoint.
setInitOffset(125); // sets the initial offset under the lg breakpoint.
setDotVisible(false);
}
};
updateLayout();
window.addEventListener("resize", updateLayout);
return () => window.removeEventListener("resize", updateLayout);
}, [gap, width]);
useEffect(() => {
const interval = setInterval(() => {
setCurrentIndex((prev) => prev + 1);
setCurrentDot(p => (p + 1) % banner.length);
}, 3000);
return () => clearInterval(interval);
});
useEffect(() => {
if (currentIndex === totalItems + 1) {
setTimeout(() => {
setAnimate("none");
setCurrentIndex(1);
setTimeout(() => {
setAnimate("transform 0.5s ease");
}, 50);
}, 550);
}
}, [currentIndex, totalItems]);
return (
<div className="banner-container">
<div
className="banner-wrapper"
ref={wrapperRef}
style={{
transform: `translateX(-${
currentIndex * singleOffset - initOffset
}px)`,
transition: animate,
gap: `${gap}px`,
}}
>
{[banner[banner.length - 1], ...banner, ...banner].map(
(item, index) => (
<div
style={{
width,
}}
key={`${item.id}-${index}`}
className="banner-item"
>
<img src={item.url} alt={`banner-${item.id}`}/>
</div>
)
)}
</div>
{dotVisible ? <div className="swiper-dot">
{
banner.map((item, index) => <div key={item.id}
className={`dot${currentDot === index ? ' dot-active' : ''}`}></div>)
}
</div> : <></>}
</div>
);
};
export default Banner;
```
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-navbar
爬取时间: 2025-05-01 08:31:40
来源: Huawei Developer
概述
PC/2in1设备上的商务办公、实用工具垂类应用开发中，常使用侧边分级导航展示多级目录。而在一多开发时，侧边分级导航并不一定适用于手机、平板等设备，若需要实现导航栏内的分级效果，比较复杂。本文提供分级导航栏的多端适配方案及指导，解决上述问题。
通常，开发者可以结合断点能力，在不同断点下呈现相应布局。考虑不同屏幕尺寸的布局美观性及规范性，采用以下布局方式：断点为sm、md时，一级导航栏位于底部，二级页签栏位于顶部；断点为lg时，一级导航栏位于左侧，二级页签位于顶部；断点为xl时，在侧边栏中展示分级导航。
当前系统的产品形态主要有手机、折叠屏、平板和PC/2in1四种，分别对应sm、md、lg和xl四个断点。
下文将围绕这几种产品形态展开，讲解不同断点下的分级导航栏实现原理及开发实践。
| 示意图  | sm  | md  | lg  | xl  |
| --- | --- | --- | --- | --- |
| 效果示意图  |   |   |   |   |
示意图
sm
md
lg
xl
效果示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151241.85130535722550754555413878395462:50001231000000:2800:AD68E32B72077800483E6070BE12265E5C8058A23E22B0B615FC288AFA233BAE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151241.86457798034204187179708976997589:50001231000000:2800:F3948CF235054B241CB384577651CDF5D9948AC41D197A74D784A93E1356DC0E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151241.84977272045003993170505075227572:50001231000000:2800:1E68B16E4DF495CC74A64DA6CC87BDEE8EC3C7496D662F0F34560549BCD12083.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151241.64401971130648903134447332743702:50001231000000:2800:A3BE0A067F9A96667C82D481FE4B95B91AD77B9D847FC7CAE2A18DDAB5FA48D4.png)
实现原理
开发一多分级导航栏时，需要实现4种断点下的一多效果：
使用Tabs+List实现sm、md、lg断点分级导航
场景描述
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果示意图  |   |   |   |
示意图
sm
md
lg
效果示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151241.44246586748355296743202185801971:50001231000000:2800:83A3A3EF71E39BEC73A90815BB75FB6547D4C0090B09D5E294682475CF6816B4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151241.27555577084509595610520595474426:50001231000000:2800:FAF266BFB61D58C50C4281734B95BBE3FFA1911E535F18D6B8DCCF9C67CD7391.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151242.87960206414467306409232030663309:50001231000000:2800:DC786ED303FA97CDD62C2FE9EFF021A6AF52FD6FED4A9FE24AC6B2C80FF848CA.png)
当断点为sm或md时，展示为底部导航和顶部页签；当断点为lg时，展示为左侧页签。
开发步骤
使用Tabs组件实现底部/左侧导航。在sm、md断点时，设置Tabs的barPosition为End，vertical为false；在lg断点时，设置Tabs的barPosition为Start，vertical为true。
使用List组件实现顶部页签，选中时渲染相应的页面内容。
1.  调用内容区域组件，传入所需参数，实现页面内容效果。
使用SideBarContainer实现xl断点分级导航
场景描述
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151242.75686264534002039810680318410364:50001231000000:2800:08ADCE8980C6C77DC84CC7D36B964E58F776855212ADD392057643D8E0CCB222.png)
当断点为xl时，展示为侧边分级导航，在侧边栏中显示所有目录结构，两级导航目录均支持切换。
开发步骤
使用SideBarContainer组件实现侧边栏效果。该组件需要传入两个子组件，分别表示侧边栏区域和内容区域。
常见问题
在PC/2in1设备上改变应用窗口大小，随着断点变化会呈现sm、md、lg的布局
问题现象
在PC/2in1设备上，应用以自由窗口的形态运行，若改变窗口大小，应用布局会随断点变化而变化，但其他断点的布局效果不适合PC/2in1设备的交互方式。
解决措施
应用应限制窗口的最小宽度。在“entry/src/main/module.json5”中，配置窗口的最小宽度为1440，可以确保应用窗口在PC/2in1设备上的布局始终为xl断点下的布局。
若添加了纵向断点，应补充限制窗口的最小高度。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-vertical-domain-case
爬取时间: 2025-05-01 08:31:54
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-video-app
爬取时间: 2025-05-01 08:32:14
来源: Huawei Developer
概述
本文从目前流行的垂类市场中，选择长视频行业应用作为典型案例详细介绍“一多”在实际开发中的应用。长视频应用的核心功能为沉浸式的视频播放和互动，主要包含首页推荐、视频搜索、视频详情、视频评论、全屏播放等。根据这些核心功能，本文选择首页、搜索页、视频详情页和全屏播放页作为典型页面进行开发，遵从多设备的“差异性”、“一致性”、“灵活性”和“兼容性”，能够让开发者快速高效地掌握“一多”能力并实现长视频应用的相关功能。
开发者在开发“一多”应用时，经常会遇到多端适配上的问题，本文选择了长视频应用部分痛难点问题，提供了推荐的解决方案，开发者在“一多”开发中遇到同类问题时可快速解决。
当前系统的产品形态主要有手机、折叠屏、平板和PC/2in1四种，下文的具体实践也将围绕这几种产品形态展开，同时将分别从UX设计、工程管理、页面开发和功能开发四个角度给出符合“一多”的参考样例，介绍“一多”长视频应用在开发过程中的最佳实践。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。下文将详细介绍它们在“一多”开发实践中如何使用。
UX设计
影音娱乐类的多设备响应式设计指南，点击访问。
工程管理
本章将介绍如何创建“一多”工程及划分目录结构。
创建工程
根据三层架构创建系统工程，先创建出最基本的项目工程，再在基本目录结构的基础上进行修改。
工程结构
开发者在创建“一多”的工程时，会遇到如何划分工程结构目录的问题。考虑到工程的复用性和可维护性，本文以长视频应用为例给出推荐的参考方案。
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计的逻辑设计。
长视频应用根据一多推荐的commons、features、products的“三层工程架构”划分目录。其中四个页面功能不同，互不依赖，根据页面划分为四个features（基础特性层）：首页-home、视频搜索页-search、视频详情页-videoDetail和全屏播放页-videoPlayer。公共常量、媒体播放工具以及窗口管理工具等需要被不同页面依赖引用的内容，划分为一个commons（公共能力层）：基础能力-base。其中features层不同页面的功能相对独立、互不影响，推荐创建HAR包；commons层存放公共能力类，被features层和products层依赖，推荐创建HAR包。
页面开发
本章介绍长视频应用中如何使用“一多”的布局能力，完成页面层级的一套页面、多端适配。同时介绍长视频应用中的交互开发和推荐的资源使用方式。
首页
长视频应用首页主要发挥推荐精选视频的作用，解决用户想要看视频的核心需求，所以首页内容都围绕这一功能设计。观察首页在PC/2in1上的UX设计图，可以进行如下设计（图中为包括可滑动区域的内容）：
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151242.52358158388042937045875984257983:50001231000000:2800:0ED9097ED8C0FAA4D8776F1FC23C3B63BE8243D25F6792BDDC39B3F3E15B088C.png)
长视频应用搜索页的8个基础区域介绍及实现方案如下表所示：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 底部/侧边页签  | 借助栅格布局监听断点变化改变位置。  |
| 2  | 顶部页签及搜索框  | 栅格布局监听断点变化实现折行显示，List组件实现延伸能力，layoutWeight实现拉伸能力。  |
| 3  | Banner图  | Swiper组件，指定displayCount属性实现延伸能力，设置aspectRatio属性实现缩放能力。  |
| 4  | 图标列表  | Swiper组件，指定displayCount属性实现自适应布局延伸能力，设置aspectRatio属性实现缩放能力。  |
| 5  | 推荐视频  | 网格容器，借助栅格组件能力监听断点变化改变列数，设置aspectRatio属性实现缩放能力。  |
| 6  | 新片发布  | 网格容器，借助栅格组件能力监听断点变化改变列数，设置aspectRatio属性实现缩放能力。  |
| 7  | 每日佳片  | 利用响应式布局的栅格布局，结合Stack组件和Grid组件，设置aspectRatio属性实现缩放能力。  |
| 8  | 往期回顾  | 响应式布局的栅格布局，设置aspectRatio属性实现缩放能力。  |
区域编号
简介
实现方案
1
底部/侧边页签
借助栅格布局监听断点变化改变位置。
2
顶部页签及搜索框
栅格布局监听断点变化实现折行显示，List组件实现延伸能力，layoutWeight实现拉伸能力。
3
Banner图
Swiper组件，指定displayCount属性实现延伸能力，设置aspectRatio属性实现缩放能力。
4
图标列表
Swiper组件，指定displayCount属性实现自适应布局延伸能力，设置aspectRatio属性实现缩放能力。
5
推荐视频
网格容器，借助栅格组件能力监听断点变化改变列数，设置aspectRatio属性实现缩放能力。
6
新片发布
网格容器，借助栅格组件能力监听断点变化改变列数，设置aspectRatio属性实现缩放能力。
7
每日佳片
利用响应式布局的栅格布局，结合Stack组件和Grid组件，设置aspectRatio属性实现缩放能力。
8
往期回顾
响应式布局的栅格布局，设置aspectRatio属性实现缩放能力。
在实际开发中，区域1为外层导航栏，区域2为内层导航栏，区域3-8为并列的首页内容，所以对应的开发顺序为区域1、区域2和区域3-8。另外，为了提升用户的使用体验，首页设计了额外的功能，包括首页社区页签的沉浸式设计，PC/2in1首页Banner图的排版创新，首页推荐视频区域长按预览，首页推荐视频区域的缩放。
-  底部/侧边页签区域，使用Tabs组件，设置在不同断点下的vertical属性，实现显示在首页的不同位置。在sm和md断点下，页签显示在底部，高度为56vp；在lg断点下页签显示在左侧，宽度为96vp，且页签居中显示。 示意图如下： 示意图 sm md lg 设计能力点 效果图
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151242.25684943142141263236508292479478:50001231000000:2800:A50719793504E779615DBCBC642DF67147C5337FE341223F88E8D5AB441739AE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151242.99629369835530969205156124455699:50001231000000:2800:7B569594A1B1189AB667E50D3F47BA267092F7F23992DA83C785BC46D3245988.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151242.15988618853624443611617834073130:50001231000000:2800:399E4C75ED2CB284538560823CEB97524E550E91AEE12063903BC0A1642BE8FB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151242.96909069169954399081354391069719:50001231000000:2800:B643AD0B5E99AB6785AAF5C9772C46492CF72D2CAF0A869DEEEE3DEF427E9738.png)
-  不同断点下，顶部页签和搜索框占用不同栅格列数，使用栅格布局实现在sm断点下分两行显示，在md和lg断点下单行显示。根据设计将栅格在sm、md和lg的断点上分别划分为4列、12列、12列。示意图如下： 示意图 sm md lg 效果图 栅格布局图 随着设备宽度变大，顶部页签间距变大、页面能够展示更多页签内容，使用List组件实现延伸能力；同时使用layoutWeight将增加的空间全部分配给搜索框，实现拉伸能力。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
| 栅格布局图  |   |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151242.19907607985194889106989451454970:50001231000000:2800:99725BF0B60741A83662B7CCD15F3EA6307F1D566262A2CA37AB59F4E3C34CE5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151242.48384105569716369708421158636241:50001231000000:2800:C29F7F789A5E6EABDD52A95B5A38B0DDFE2A0964CE565C15C43D0F86A3DD7F17.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151242.38318774951955339116164870855960:50001231000000:2800:77FB25C575A19D901198066981037517D9E197F54E7F3D6E29943488B842C3E3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151243.41752334978314788854941545532897:50001231000000:2800:D3733D08985A6E2F250C53D4ED2E65840E4064ACED5F1C0F9C400F0DB368AA68.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151243.76853566545307566148434155229522:50001231000000:2800:BCF7F6B2F5301F1827EC5BDBC57C73D9E790406B8D668E8DC84AFD99A5419836.png)
-  Banner图和图标列表区域，均使用Swiper组件，设置在不同断点下的displayCount属性来实现自适应布局的延伸能力，本章节以Banner图区域作为示例，图标列表的实现读者可以自行查看代码。Banner图区域中，Banner展示数量在sm断点下为1，并显示导航点指示器；在md和lg断点下Banner为2，且前后边距展示前后两张Banner图的部分内容。 在“一多”的应用中，经常会出现窗口大小改变如果组件随着窗口宽度变化只改变宽度、不改变高度，会导致图片变形，视觉上会给用户带来较差体验。为解决这一痛点，需要给Stack组件设置aspectRatio属性，Stack的高度会跟随宽度变化相应等比发生变化，Banner图大小变化且宽高比保持不变，实现自适应布局的缩放能力。 示意图如下： 示意图 sm md lg 设计能力点 效果图
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151243.98390430563322901877266507074467:50001231000000:2800:1F77283446E349E06DF1A2BA24F18FCAAED5CA923A4F752C019B324064E51B0B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151243.97611368762014110802105942554908:50001231000000:2800:A41BE01F8BD0E1C07E8BFDBB59B9D6B14802ECD467E2277D1CCC4F99987AE775.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151243.15813243847940845016219564323581:50001231000000:2800:7E796D6402264063AC0026983BD518357AB64E0FAFBB91EF129C4E5CE551617E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151243.08129248300653949983306181379198:50001231000000:2800:5F5357366FA86B6BE4A505149206EDBC02073CA4AABA74724DDC9DF8745622D6.png)
-  视频推荐和新片发布区域，均使用网格布局Grid组件，在不同断点下将父组件分为不同列数，来实现自适应布局的占比能力，本章节以推荐视频区域作为示例，新片发布区域的实现读者可以自行查看代码。 视频推荐区域中，网格布局在sm断点下分2列，md断点下分3列，lg断点下分4列。示意图如下： 示意图 sm md lg 设计能力点 效果图 为实现图片大小等比变化，需要给Stack组件设置aspectRatio属性，同Banner图区域，实现自适应布局的缩放能力。不同的是，因为Grid组件设置了rowsTemplate属性，子组件GridItem均分Grid组件的全部高度，所以Grid组件不能自适应为内容组件的高度，需要用getGridHeight方法先自行计算出Grid组件的高度，从而保证子组件中图片等比放大或缩小。在getGridHeight方法中，先根据窗口宽度和网格列数，计算出单张图片宽度；再根据图片宽度和宽高比计算出图片高度，并与标题和内容栏高度相加；最后乘网格行数得到Grid组件的总高度。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151243.32308821501510667710595920773243:50001231000000:2800:47617A4A9ABB9ED972362F6DF022E832C22AB8C6761F799F20687938CADCAC6E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151243.45071899077335215438113556317128:50001231000000:2800:904E4486AAC20DC1E3DA8CADB93F69F2E463797E9F369538240109863C394A5B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151243.08996278009867123583400014706788:50001231000000:2800:7FE10621C353F434063847967FEC04A21884542FFD66ACA367157C2A894175E8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151243.37570904985566602302194535941292:50001231000000:2800:B2A058D490E5AA4D81D5B56128A6F688D04C24590066E3BBAACED27BDE4CAF73.png)
-  每日佳片和往期回顾区域，均使用挪移布局实现“上下布局”与“左右布局”间的切换。本章节以每日佳片区域作为示例，往期回顾区域的实现读者可以自行查看代码。 每日佳片区域中，使用GirdRow组件和GridCol组件设置主图部分和子图部分在sm、md和lg断点下的栅格列数，使用BreakpointType设置不同断点下的高度。子图部分中，使用Grid网格布局，通过2行+2列的布局均分给4张子图。为实现图片大小等比变化，需要给Stack组件设置aspectRatio属性，同Banner图区域，实现自适应布局的缩放能力。Grid组件的高度计算，getDailyVideoHeight方法同推荐视频区域getGridHeight方法。 示意图如下： 示意图 sm md lg 效果图 栅格布局图
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
| 栅格布局图  |   |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151244.04197047914314561383293748634337:50001231000000:2800:88BD0C090AE24FAF706CB930AD298B93C382EA4CC6273A78D79AB4443D4BDF01.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151244.95574124970783314302675079152089:50001231000000:2800:FF1BFAF96F171948AC17E149D07B11FFBAEE58E0103D2BFFD18144A83D6F725C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151244.32087754635173228991300712371646:50001231000000:2800:AFC5CA9C74854A70CEDD931592D77431FA1C4EC4446FF9E2B2081371547887CC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151244.52838671807313295413283252947591:50001231000000:2800:B9C2DB37D2AFD7CFD8F5A6CDD95BBB7B3CE2344D3BFB1854599C0F70FC7EE542.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151244.43226323883848011013957234870893:50001231000000:2800:BEC3CFDCD3D654DC03B254A01703A3FEA453C2AB0B29DB8DB4C3C5A36801D678.png)
-  沉浸式的视频播放和互动作为视频类应用的核心，沉浸式首页的设计在长视频应用中必不可少。为了给用户带了沉浸感强的体验，沉浸式界面往往会发生特别的变化，在页面中使用大型、高分辨率的背景图片，从而创造具有视觉冲击力的效果，同时文字、图标、按钮和背景的颜色也相应的改变。为解决这一难题，可以在项目中分别为不同设备重构一套代码用于展示沉浸式的页面。 本章针对长视频应用的沉浸式首页的主要特点给出推荐的解决方案： 主要特点 解决方案 Banner图覆盖到侧边页签和顶部页签栏 将Banner图设置为backgroundImage，并使用Row组件显示文字占位，侧边/底部页签和顶部页签栏使用Tabs组件和Stack组件控制层级，并根据设计将背景色设置为透明。 背景色与Banner图底色保持统一色调 在backgroundImage处设置backgroundColor属性为统一色调的背景色。 下滑过程中顶部页签栏背景色更改为统一色调 在Scroll组件的onScroll方法中获取当前y轴滑动偏移量，根据固定偏移量修改顶部页签栏的backgroundColor属性为统一色调的背景色。 文字和图标颜色与背景色为对比色 相关文字和图标设置颜色时增加条件判断。 效果图如下： 示意图 sm md lg 效果图
| 主要特点  | 解决方案  |
| --- | --- |
| Banner图覆盖到侧边页签和顶部页签栏  | 将Banner图设置为backgroundImage，并使用Row组件显示文字占位，侧边/底部页签和顶部页签栏使用Tabs组件和Stack组件控制层级，并根据设计将背景色设置为透明。  |
| 背景色与Banner图底色保持统一色调  | 在backgroundImage处设置backgroundColor属性为统一色调的背景色。  |
| 下滑过程中顶部页签栏背景色更改为统一色调  | 在Scroll组件的onScroll方法中获取当前y轴滑动偏移量，根据固定偏移量修改顶部页签栏的backgroundColor属性为统一色调的背景色。  |
| 文字和图标颜色与背景色为对比色  | 相关文字和图标设置颜色时增加条件判断。  |
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151244.75737594242459224583815922556355:50001231000000:2800:E2EE90528B38ECEEDCC06DE5B7D6A4229492351C2876D7A3364012E5ACBB55BA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151244.44457872121317442107006563114196:50001231000000:2800:6E100B68C4B064EB67B47418B8E0FB86CD5D3AA0644F63C8F48CB8B04677A678.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151244.04871743766164155848905867437548:50001231000000:2800:641AF7164257C06DF15BAE71CEEB658EA1BBC5820FD3F2A005270B49E5901A16.png)
-  在lg断点下，切换顶部页签，能够查看Banner图的排版创新，增多展示内容，提高浏览效率。三列Banner图按4：4：3预设的比例排布，使用layoutWeight实现自适应布局的占比能力。 效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151244.04670896792681566113154197629774:50001231000000:2800:8105BAE1DF91A6636869ABACD33A19A4D83ACBE4E5F44DA9A0DA19C0A8C00FC4.png)
-  长按首页推荐视频区域的第一张图片，在图片的位置显示自定义弹窗组件播放视频，弹窗默认向上方展开。当图片上划至窗口顶部时，弹窗自适应向下方展开。长按手势事件用LongPressGesture方法实现。 因为Banner图区域使用了aspectRatio属性来控制图片的宽高比不变，所以不能手动计算视频推荐区域距离窗口顶部的高度，动态获取组件的高度也成为“一多”开发中经常遇到的难点。对这种问题，推荐使用组件标识的getInspectorByKey方法获取组件相对于应用窗口左上角的水平和垂直方向坐标，获取的位置属性单位为px，使用像素单位的px2vp方法转换单位为vp，从而确定自定义弹窗的偏移量offset。 效果图如下： 示意图 sm md lg 设计能力点 效果图
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151244.55785355850740666569758152250334:50001231000000:2800:DF6D3AA53146B4D2B6A76623D2BE55D4F11FCAB821EDC3D2B29F385595E9511F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.63576844193606341622153788980755:50001231000000:2800:55C18A77FF81FBB246B29BC6434478EBE793205E15EFD1D136CF2FC4FC4D5A30.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.56706927631453746826944624603813:50001231000000:2800:6F3EB448EEBBD9F4D2BB1238F345ACEBC299EA2458319447E029A978C108E318.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.25530089902620642137688719311134:50001231000000:2800:921C333150CC8CDBCDC77786626538CCAFA64C9333FFCF6200AB85A49258CA67.png)
-  在md和lg断点下，首页的推荐视频区域支持双指捏合放大与缩小。网格布局在md断点下默认3列显示，两指向中心捏合切换为4列显示，两指向外放大切换为3列显示；lg断点下，4列、5列显示同理。这一效果通过在PinchGesture双指触发捏合手势中动态修改网格布局的columnsTemplate属性实现。 效果图如下： md lg
| md  | lg  |
| --- | --- |
|     |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.86561773161062919704980121040692:50001231000000:2800:99D0B66A4174033AA8C7FD7422C7271126C0B5B0B4020FBA248D6C7684C3CD1B.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.57943834269911225426540986169737:50001231000000:2800:BA57CA71B8397BE2E13F4505716068A6BA722F5FBE0205F5A44A9FF899D86924.gif)
搜索页
长视频应用搜索页需要智能响应用户的特定输入并给出提示，并提供搜索发现内容。观察搜索页在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 搜索页 搜索输入页 搜索结果页
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 搜索页  |   |    |    |
| 搜索输入页  |    |    |    |
| 搜索结果页  |    |    |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.60880275580928093629735388270701:50001231000000:2800:04202935B3DBE051A51E1C64BBC4677991982CE1DE2846E827E50B4EB04C7045.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.74724696409547773925289086502566:50001231000000:2800:98D79E313A6FDDE8D60394B39A1C6AFBCD1BDB2F16C167EF6BEB58B315E67E8F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.75140527655049551627200318216851:50001231000000:2800:B7F3AA272EDAF9CDA0947CB794045254ABABBCBB689FC439DC03E69FB465966C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.42074975180486159554494387922511:50001231000000:2800:17DACA32F29001858BB573A70A3E52342484BF72456E255BB6B3D07E378BE88F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.33326363748845495374871514436555:50001231000000:2800:3D0ED10BDD7E6D6BFF8A5C823572053B3B5533558E52336BBCD0AE7FCB71ED86.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.54008369411966488021268767019421:50001231000000:2800:A6AAED9B820C8E5F88E488F5CBA3C4826F708356B67F07E0486D66C2C5FD9DB9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.75569617961133971512275840213371:50001231000000:2800:8FA6988B957E52A2FBF2FA5B9FC5D46A1352FA7595CC0CDD928A055B12EE96E9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.37640666022452058559171088233108:50001231000000:2800:448B41BE5AC17CA9D4E7F561049A5A3E655EF6D0FDF090046FA238F1842D5184.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.37963557230515645969824818787561:50001231000000:2800:CD877D9F127A7232E2AD5065088044BCA204A3532B1AB56F9760EF6873F12D38.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151245.81553584560337312499200967516006:50001231000000:2800:244BE6A364FD6729A5442A0EB1D2B8F37A345DE6829D446C7D5F2D62B1F2D6C3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151246.18071711184318509309649301259292:50001231000000:2800:C4CA0F6F85D8129D112B65968DD7DC5AECB9E5C23727D4A51BDB0BC73AFE9F7E.png)
长视频应用搜索页的5个基础区域介绍及实现方案如下表所示：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 搜索框  | layoutWeight实现拉伸能力，同首页搜索框。  |
| 2  | 搜索发现  | 标题栏的空白区域使用Blank实现拉伸能力，内容使用List组件的lanes属性，在不同断点下呈2、2、3列显示。  |
| 3  | 热搜  | 页签的间距随断点变化，热搜内容使用List组件的lanes属性，在不同断点下呈1、2、3列显示。  |
| 4  | “华”搜索智能提示  | 使用List组件的lanes属性，在不同断点下呈1、1、2列显示。  |
| 5  | 搜索结果  | 响应式布局的栅格布局，同首页每日佳片。  |
区域编号
简介
实现方案
1
搜索框
layoutWeight实现拉伸能力，同首页搜索框。
2
搜索发现
标题栏的空白区域使用Blank实现拉伸能力，内容使用List组件的lanes属性，在不同断点下呈2、2、3列显示。
3
热搜
页签的间距随断点变化，热搜内容使用List组件的lanes属性，在不同断点下呈1、2、3列显示。
4
“华”搜索智能提示
使用List组件的lanes属性，在不同断点下呈1、1、2列显示。
5
搜索结果
响应式布局的栅格布局，同首页每日佳片。
在实际开发中，区域1为导航栏，区域2和3，区域4，区域5为并列的搜索页内容，所以对应的开发顺序为区域1和区域2-5。
-  搜索发现、热搜和“华智能提示”区域，均使用List组件，设置在不同断点下的lanes属性来实现。本章节以搜索发现区域作为示例，热搜和“华”智能提示区域的实现读者可以自行查看代码。 示意图如下： 示意图 sm md lg 效果图 搜索发现区域中，标题栏中间的空白区域随父容器尺寸变化而伸缩，使用Blank组件实现自适应布局的拉伸能力；List组件的lanes属性在sm和md断点下为2，lg断点下为3，实现不同布局显示。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151246.75269979640990039017986816719099:50001231000000:2800:A6F6F8629F9E4F101CCB98A473D3FA73CFBAEC119D8161F949AC5D63B52ED4A0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151246.22178201037027750206438031938865:50001231000000:2800:4DB6E27875D94D8941F10AC1B33216BD619CB8DF4AB9FA4C87543E355D572FD4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151246.49164980895208967369211486532214:50001231000000:2800:0A8DAE9EDC9C66BADAE247F077D034508440D2992D650F59F5C5D3AC7FCC4C04.png)
视频详情页
长视频应用视频详情页提供视频播放、评论互动和提供视频相关信息的功能。观察视频详情页在不同设备上的UX设计图，可以进行如下设计（图中为包括可滑动区域的内容）：
-  示意图 sm md lg 效果图
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |    |    |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151246.68408152284982671745497625781978:50001231000000:2800:AC3ABCAD96162FC8D3E2EC85D38F3BBE11DA6C44FE5FCBFA1131FA4EFDABC59B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151246.06607331766741871275196357393271:50001231000000:2800:F7A6A2D6053A73C2DCDD6E8DBB86B299035D69AD68E85FD3ECF64008F4B09937.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151246.41687418720931204177570220597850:50001231000000:2800:864C721306BA526F0910DC5D2CB10F0EB6DF29ACBB15608485E892C972DFCA12.png)
长视频应用视频详情页的5个基础区域介绍及实现方案如下表所示：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 视频播放  | 使用视频播放AVPlayer和XComponent等相关组件，不详细介绍具体功能实现，读者可以自行查看代码。  |
| 2  | 相关列表  | 标题栏的空白区域使用Blank实现拉伸能力，视频列表通过List组件实现延伸能力，同搜索页搜索发现。  |
| 3  | 全部评论  | 在不同断点下修改评论区图片的宽高和aspectRatio属性实现自适应布局的缩放能力。  |
| 4  | 写评论  | layoutWeight实现自适应布局的拉伸能力，同首页搜索框。  |
| 5  | 视频简介  | 图标Row组件的justifyContent属性设置为FlexAlign.SpaceBetween实现均分能力，选集列表通过List组件实现延伸能力，周边视频使用layoutWeight实现拉伸能力。  |
区域编号
简介
实现方案
1
视频播放
使用视频播放AVPlayer和XComponent等相关组件，不详细介绍具体功能实现，读者可以自行查看代码。
2
相关列表
标题栏的空白区域使用Blank实现拉伸能力，视频列表通过List组件实现延伸能力，同搜索页搜索发现。
3
全部评论
在不同断点下修改评论区图片的宽高和aspectRatio属性实现自适应布局的缩放能力。
4
写评论
layoutWeight实现自适应布局的拉伸能力，同首页搜索框。
5
视频简介
图标Row组件的justifyContent属性设置为FlexAlign.SpaceBetween实现均分能力，选集列表通过List组件实现延伸能力，周边视频使用layoutWeight实现拉伸能力。
在实际开发中，sm和md断点下的设计中，区域1-3和区域4为并列的视频详情页内容，所以对应的开发顺序为区域4，区域1-3；lg断点下的设计中，区域1、2、5和区域3-4是并列的视频详情页内容，所以对应的开发顺序为区域3-4，区域1、2、5。另外，视频详情页设计了额外的功能：边看边评的交互逻辑。
-  根据ux设计，全部评论在sm、md断点下显示在视频下方，在lg断点下显示在右侧边栏，实现侧边悬浮面板，使用SideBarContainer组件+断点控制组件显示的位置，同时侧边栏宽度可通过拖拽变宽。全部评论中的图片，在sm、md断点下使用不同的宽高固定值；lg断点下，在SideBarContainer的onAreaChange方法中按侧边栏的宽度变化百分比改变图片宽高，配合图片的aspectRatio属性控制等比放大或缩小，实现自适应布局的缩放能力。 效果图如下： 示意图 sm md lg 设计能力点 效果图
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |    |    |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151246.97520411098329921220186758989587:50001231000000:2800:830C948063A42DA29B2EEE3CD8E4DE9378A3DD630B1A75B97A7B8D2E0E48C4D2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151246.61194789090672845459723244882637:50001231000000:2800:E914557FC98D7A11852D6F9789C3E41B3717EC1D4FA6D2F3FEDCADECD64AC65E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151247.29298396687040055084847089517409:50001231000000:2800:2F5B9AD662ED1935C9BB273695D33FE565DCAB274DBE2B01B092084A35A80BE7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151247.43804301654590116754563699151359:50001231000000:2800:D675EC5A1DF574B9497D5242E4A8F4AD8E110BA7994CFA2FF75F74B74583C8BE.png)
-  视频简介区域只在lg断点下显示，其中视频简介的图标设置Row组件的justifyContent属性为FlexAlign.SpaceBetween实现均分能力。选集列表使用List组件实现自适应布局的延伸能力，随容器组件尺寸变大，可以看到的集数相应增加，用户也可以通过手指滑动触发列表滑动，查看被隐藏的子节点。周边视频标题栏的空白区域随容器组件尺寸变化而伸缩，使用Blank实现自适应布局的拉伸能力。 效果图如下： 示意图 lg 效果图
| 示意图  | lg  |
| --- | --- |
| 效果图  |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151247.95093259551747508565173044926848:50001231000000:2800:F18A29949CCBD71431E72B165E99A8BBA809041F21F792BAB3B0ABB0311A14F4.png)
-  视频详情页中，不同断点下页面下滑效果不同。在sm和md断点下，下滑时先隐藏相关列表区域，完全隐藏后视频区域等比缩小，缩至最小时固定，改为下滑全部评论区域；上滑时先上滑全部评论区，再等比放大视频区域，最后显示相关列表区域。在lg断点下，下滑时等比缩小视频区域，最小时固定改为下滑全部评论区域；上滑时先上滑全部评论区，再等比放大视频区域。这一效果通过Scroll组件的onScrollFrameBegin回调方法中控制相关组件的高度和偏移量实现。当组件高度变化时，返回偏移量为0；当全部评论区滑动时，返回实际偏移量。 示意图如下： 示意图 sm md lg 设计能力点 效果图
-  在折叠屏展开态这种方形尺寸屏幕的设备上，点击“全屏播放”按钮，视频画面不旋转。在折叠屏展开态下，视频详情页进入全屏播放页不旋转，但是跟随系统传感器方向自动旋转，且受控制中心的旋转开关控制。使用window.setPreferredOrientation(window.Orientation.AUTO_ROTATION_RESTRICTED)设置。首页和视频详情页在其他设备上或折叠屏其他折叠态时竖屏显示，使用window.setPreferredOrientation(window.Orientation.PORTRAIT)设置。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |     |     |     |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151247.98506433876153002923955970868408:50001231000000:2800:4216D59ED65D2E46E8D81BD97F8CEC4EA22AA06186CDCA04D5CEAD9877EC710A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151247.46330529606189602221212111705647:50001231000000:2800:9AE66B1F8BC48540F24362A434F2F9A254D76CB1F404729AD03931412F7515FD.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151247.73401275345810887314016933573381:50001231000000:2800:1091167E7D4554824A468FE79B524C0FC6455ED7943195CDE6BD3914F58E781E.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151247.33976859983133851640812496464676:50001231000000:2800:B749A8A88EDFC882139CF5E70FB93B2F7C8182CD757A49FD57BB7E4B84A28D05.gif)
全屏播放页
长视频应用全屏播放页为用户带来沉浸式观看视频体验并支持选集。观察全屏播放页在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 全屏播放页 全屏播放选集页
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 全屏播放页  |    |    |    |
| 全屏播放选集页  |    |    |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151247.91203126278357404823219129066065:50001231000000:2800:64B5C9B6A7EA4B431CCA3B4A0A58EF5EFAA229D1109B84797CFFF1D47A4C4009.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151248.43580499792942040991964110740287:50001231000000:2800:356D9D47B4A510B8D8EC147007365AB1B1A946633D5041287233E9B88C55C4D1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151248.44512390753251533020682989502432:50001231000000:2800:6DF79BEC102B9FF2E24D55E1FBF49F17E13A477DAC53AD807656703FF3B87B2F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151248.28561741134709670826690759063203:50001231000000:2800:3EE90EE479CC8565DCFD58EE6476F36DD8A1FE9815452DDF63F7B1B2D2910AA8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151248.72951329230992965480989661950181:50001231000000:2800:EBF4579583AF1623857886038AE34F8F95BA70EBA69C76FBEF20E952196F1DC5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151248.24986053950756517548015888709284:50001231000000:2800:72AD0C6929E7500ADF51034974B53740EA6D8C9571F90D6B3534D2AC50B0FFAA.png)
长视频应用全屏播放页的3个基础区域介绍及实现方案如下表所示：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 全屏视频播放  | 使用window窗口管理窗口隐藏状态栏和导航栏，在sm断点下控制窗口横屏显示，在md、lg上不改变窗口显示方向。视频播放使用AVPlayer和XComponent等相关组件，不详细介绍具体功能实现，读者可以自行查看代码。  |
| 2  | 进度条及工具栏  | 进度条使用layoutWeight、工具栏的空白区域使用Blank实现自适应布局的拉伸能力，同首页搜索框。  |
| 3  | 选集列表  | 选集列表通过List组件实现延伸能力，同搜索页搜索发现。  |
区域编号
简介
实现方案
1
全屏视频播放
使用window窗口管理窗口隐藏状态栏和导航栏，在sm断点下控制窗口横屏显示，在md、lg上不改变窗口显示方向。视频播放使用AVPlayer和XComponent等相关组件，不详细介绍具体功能实现，读者可以自行查看代码。
2
进度条及工具栏
进度条使用layoutWeight、工具栏的空白区域使用Blank实现自适应布局的拉伸能力，同首页搜索框。
3
选集列表
选集列表通过List组件实现延伸能力，同搜索页搜索发现。
在实际开发中，区域1-2和区域3为并列的视频播放页内容，所以对应的开发顺序为区域1-2，区域3。另外，为了提升用户的使用体验，全屏播放页为折叠屏的半折叠态设计了视频悬停播放。
-  进入全屏播放页，使用setWindowSystemBarEnable()方法隐藏顶部导航栏和状态栏，并在手机和折叠屏折叠态下使用setMainWindowOrientation()方法设置窗口横屏播放。
-  在折叠屏上浏览视频详情页或全屏播放页时，折叠设备，将自动切换至悬停态的沉浸播放视频体验。折叠屏悬停适配通过window的setPreferredOrientation接口设置窗口横向显示，通过display的getCurrentFoldCreaseRegion接口获取折叠屏折痕区域的位置和大小，通过自定义方式实现悬停态页面。视频移到上半屏，中间为折叠屏避让区，其他可操作组件堆叠到下半屏。示意图如下： md
| md  |
| --- |
|   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151248.13062598803049147400725079731886:50001231000000:2800:68D9C14EB4D88D9E3C3BC5212DB691B11466045E5DD427E228750883250494A3.png)
交互开发
交互事件归一
不同类型的智能设备，系统已经针对不同的交互方式做了适配，实现了交互归一，因此开发者无需额外关注用户不同的交互方式。长视频应用包含的基础输入方式如下（以鼠标为例）：
| 事件  | 应用支持的鼠标交互  |
| --- | --- |
| 点击  | 在Tabs、TextInput等组件上点击左键。  |
| 长按  | 在首页首个推荐视频上长按左键预览视频。  |
| 拖拽  | 在视频详情页右侧边栏上按压左键并移动鼠标，改变侧边栏的宽度。  |
| 滚动/平移  | 在List和Scroll组件中上下滚动滚轮，实现。  |
| 缩放  | 在首页推荐视频区域中ctrl+滚动滚轮控制宫格布局的缩放。  |
事件
应用支持的鼠标交互
点击
在Tabs、TextInput等组件上点击左键。
长按
在首页首个推荐视频上长按左键预览视频。
拖拽
在视频详情页右侧边栏上按压左键并移动鼠标，改变侧边栏的宽度。
滚动/平移
在List和Scroll组件中上下滚动滚轮，实现。
缩放
在首页推荐视频区域中ctrl+滚动滚轮控制宫格布局的缩放。
键盘走焦
在PC/2in1设备的“华为发布会”的搜索结果页面，默认可获焦的组件遵循走焦规范。点击搜索框进入输入场景时，激活并获焦到输入框。按Tab键，焦点从搜索框向下移动到栅格布局时，默认获焦第一张卡片的播放按钮，再次按Tab键焦点此时可向右移动，到尽头后焦点向上移动至搜索框。同时方向上下键控制焦点在卡片间移动，方向左右键控制焦点在卡片内部和侧边页签间移动。
资源使用
本节以长视频应用为例，根据实际的资源使用情况，给出“一多”应用开发中推荐的资源使用方式。
在长视频应用中，多端页面显示的效果不同，使用的资源值随断点变化，推荐使用媒体查询获取资源值。借助媒体查询中监听断点的功能做简单的封装，创建BreakpointType类，通过getValue方法获取对应的资源值。在使用时，创建不同的资源文件传入BreakpointType代表sm、md和lg断点下的资源值，实现应用窗口大小变化时的不同效果。
功能开发
本示例的目标运行设备手机、折叠屏和PC/2in1运行的都是标准系统，其系统能力一致，所以无需考虑多设备上应用功能开发的差异。
总结
本文针对长视频应用沉浸式的核心场景，从UX设计、工程管理、页面开发和功能开发四个角度，结合“一多”各项具体的能力，给出了在开发中推荐的参考样例。同时对于开发者在长视频垂类应用的“一多”开发中经常遇到痛点难点问题，给出详细的解决方案，实现了同类别应用的最佳实践，帮助开发者快速适配多种类型的设备，减少了多端开发的工作量，高效构建应用。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-short-video-app
爬取时间: 2025-05-01 08:32:28
来源: Huawei Developer
概述
本文将介绍如何将“一次开发，多端部署”使用到短视频应用的实际开发过程中。短视频应用是现在较为流行的大众娱乐应用，主要用于发布和浏览个人拍摄的短视频作品，以及通过评论与其他用户进行互动。因此，本文用作示例的短视频应用包括浏览页、推荐页、评论页和个人作品页等典型页面，实现多种产品形态上的“一次开发，多端部署”，在保障基本用户体验的同时，根据不同产品形态特性，适配相应的浏览和交互功能。下文将以架构设计、UX设计和页面开发三个章节来介绍“一多”短视频应用在开发过程中的最佳实践。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。下文将详细介绍它们在“一多”开发实践中如何使用。
架构设计
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计。
UX设计
影音娱乐类的多设备响应式设计指南，点击访问。
页面开发
本章介绍短视频应用如何使用“一多”的布局能力，完成页面层级的一套页面、多端适配。下文将以短视频应用的典型页面为例，一一介绍具体实现方案，帮助开发者快速实现短视频应用的一多开发。
浏览页
浏览页是短视频应用最主要的功能页面，主要用于播放短视频。下图是浏览页在平板设备上的一个典型UX效果图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151248.06367325088635078240124357585316:50001231000000:2800:1ADEEE6F4EC09611CAC41151733610ADDA220607191EFC88FE374D8BD069F230.png)
页面可以分为两个部分，一个是用于切换页面的页签栏，在平板等大屏设备上以侧边栏的形式呈现，而在手机、折叠屏上以底部栏的形式呈现；另一个是视频播放部分，用于渲染视频播放和显示视频介绍等。其实现方案如下表所示：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 底部/侧边栏  | 借助栅格布局监听断点变化改变位置，参考一多开发实例（长视频）的页面开发章节。  |
| 2  | 视频区域  | 使用Stack容器组件实现Video组件和Text组件、Image组件的堆叠效果，其中Video组件使用.align(Alignment.Center)实现居中，参考一多开发实例（长视频）的页面开发章节。  |
区域编号
简介
实现方案
1
底部/侧边栏
借助栅格布局监听断点变化改变位置，参考一多开发实例（长视频）的页面开发章节。
2
视频区域
使用Stack容器组件实现Video组件和Text组件、Image组件的堆叠效果，其中Video组件使用.align(Alignment.Center)实现居中，参考一多开发实例（长视频）的页面开发章节。
浏览页最终在三种设备上的显示效果图如下：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151248.30968437237600790682124793413880:50001231000000:2800:A9E8FDAB5226695134898C6FBB4FDD6A6587B3B4CE54F58E0DBAA5E97F849A3F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151248.20120927077546716722199084344080:50001231000000:2800:E197B7949052158EE19A07E75B0E9642781A5242B0ADC7ABB678D27F91E83B11.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151248.33894927476058299658628602649929:50001231000000:2800:0058E0511DA8769EE1E9743A867BEF2C54AB6ABC8502E01E16AE60E196EEBE83.png)
推荐页
短视频应用的视频一般分为多个页签进行推送，除了推送用户关注博主的视频外，往往还有随机推荐、同城推荐等等。用于切换的页签栏一般位于视频上方，下图是推荐页在折叠屏设备上的一个典型UX效果图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151248.88941490902564843655265709562837:50001231000000:2800:71C8CCB3DBFC6E966099A979275293294885C0E1114D64035518EF13B407C094.png)
实现方案如下表所示：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部页签栏  | 使用Tabs组件，参考一多开发实例（长视频）的布局能力章节。  |
| 2  | 视频区域  | 参考本指南浏览页章节。  |
| 3  | 底部/侧边栏  | 参考本指南浏览页章节。  |
区域编号
简介
实现方案
1
顶部页签栏
使用Tabs组件，参考一多开发实例（长视频）的布局能力章节。
2
视频区域
参考本指南浏览页章节。
3
底部/侧边栏
参考本指南浏览页章节。
推荐页最终在三种设备上的显示效果图可参考上一节，此处不再赘述。
评论页
评论页是用户针对短视频发表意见、与视频博主以及其他用户进行互动的入口，下图是评论页在折叠屏设备上的一个典型UX效果图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151248.14739047440204366014433765272710:50001231000000:2800:B221C5F1A3E92FA0D88052EBAD9344CC671F8A6C692D9B46D5E5B8EAFFCD74BB.png)
评论页以组件的形式在浏览/推荐页上呈现，在手机等小屏设备上以半模态的形式展示，而在折叠屏、平板上以侧边栏的形式展示。其实现方案如下表所示：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 视频区域  | 参考本指南浏览页章节。  |
| 2  | 评论区域  | 在sm断点下使用bindsheet为组件绑定半模态页面，在md和lg断点下使用Row组件呈左右布局，参考一多开发实例（购物比价）的直播侧边面板页章节。  |
区域编号
简介
实现方案
1
视频区域
参考本指南浏览页章节。
2
评论区域
在sm断点下使用bindsheet为组件绑定半模态页面，在md和lg断点下使用Row组件呈左右布局，参考一多开发实例（购物比价）的直播侧边面板页章节。
评论页最终在三种设备上的显示效果图如下：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |    |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151249.56759081998064550801882731978067:50001231000000:2800:332FA2D60EB30398C52AF62F7E819EF6C577DEA348FCAFCAF9F8C6EB6726A22D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151249.41704399176881739631128543168028:50001231000000:2800:0CBB4385693809B81BD9F71546BCD029672AE4DF80685065FF16C064CF1060AD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151249.72723992457739404563919728003312:50001231000000:2800:C0645E272D094B9378FF141A48169DDAF395AC9E2600F86DFCACCB440BB633D9.png)
分享页
分享页支持用户将喜欢的视频通过不同渠道分享给朋友们，下图是分享页在手机设备上的一个典型UX效果图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151249.25249290618796628357394478375954:50001231000000:2800:CAB3B2B03B2C164F5A152296D2496412E73621633BE8EDB68D1106AF7A397647.png)
分享页同样以组件的形式在浏览/推荐页上呈现，在手机等小屏设备上以半模态的形式展示，而在折叠屏、平板上以自定义弹框的形式展示。其实现方案如下表所示：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 视频区域  | 参考本指南浏览页章节。  |
| 2  | 分享区域  | 使用分享服务接口实现，可参考此处。  |
区域编号
简介
实现方案
1
视频区域
参考本指南浏览页章节。
2
分享区域
使用分享服务接口实现，可参考此处。
分享页最终在三种设备上的显示效果图如下：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151249.86408634030326261307278478997386:50001231000000:2800:0847BC18082EE61CCDB0CD42D3E4807811E9557E167970A9B88963893A4F0E48.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151249.01696391196751498874026387435764:50001231000000:2800:795647D602B95A87B42B171A08F0E7B6DD518733E7112B6BC9CC62C1C914740C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151249.63443317360008778343920596263495:50001231000000:2800:7F10486B57E4D6D522803B0CEC8FAB666C53D9A7B9DFF94DBE14AE89A6592568.png)
个人作品页
个人作品页列举了该用户投稿的内容，下图是个人作品页在手机设备上的一个典型UX效果图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151249.25535881579593595492274579585942:50001231000000:2800:9896B82F9C6E419D90429FB82D6850E36DB2ECCD333DE4E0F28E1BFE5F84BBA1.png)
个人作品页在手机设备上使用Grid的折行能力实现作品列表的展示，而在折叠屏、平板上嵌入到侧边栏中展示。其实现方案如下表所示：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 个人简介  | 使用Image组件、Text组件和Button组件实现，参考一多开发实例（长视频）的布局能力章节。  |
| 2  | 作品区域  | 在sm断点下使用响应式布局的栅格布局，参考一多开发实例（长视频）的布局能力章节；在md和lg断点下使用Row组件呈左右布局，参考一多开发实例（购物比价）的直播侧边面板页章节。  |
区域编号
简介
实现方案
1
个人简介
使用Image组件、Text组件和Button组件实现，参考一多开发实例（长视频）的布局能力章节。
2
作品区域
在sm断点下使用响应式布局的栅格布局，参考一多开发实例（长视频）的布局能力章节；在md和lg断点下使用Row组件呈左右布局，参考一多开发实例（购物比价）的直播侧边面板页章节。
个人作品页最终在三种设备上的显示效果图如下：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151249.82304059058501477519001478398375:50001231000000:2800:5F6E728131FA2F63907D2BEE2B255735998749555AD3F3DD0CF40D76C1BDCDDC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151249.75081344131893110146555258723559:50001231000000:2800:C75602FA575122CD5BE8E714BA26768830BCFC875F3A36AABBA611A86E416886.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151249.99654263133289019432688885469130:50001231000000:2800:02877A2D053AA9AE13A0806055544226C4FD643C6D3AE4442682FECA48D5B166.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-communication-app
爬取时间: 2025-05-01 08:32:41
来源: Huawei Developer
概述
本文从目前流行的垂类市场中，选择即时通讯应用作为典型案例详细介绍"一多"在实际开发中的应用。一多即时通讯应用的核心功能为用户交互，主要包含对话聊天、通讯录，社交圈等交互功能。开发者在开发"一多"应用时，经常会遇见多端适配上的问题，本文选择了即时通讯应用的一个常见问题，提供了推荐的解决方案，开发者在"一多"开发中遇见同类问题时可以快速解决。
当前系统的产品形态主要有手机、折叠屏、平板和PC/2in1四种，下文的具体实践也将围绕这四种产品形态展开，同时将分别从UX设计、页面开发两个角度给出符合“一多”的参考样例，介绍“一多”即时通讯应用在开发过程中的最佳实践。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的"一多"能力。下文将详细介绍它们在“一多”开发实践中如何使用。
架构设计
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计。
UX设计
一多即时通讯应用包含聊天、通讯录，社交圈等交互功能，其中聊天页包含分栏布局设计，因此这里给出聊天页的业务逻辑。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151250.34282925703591743977218944021520:50001231000000:2800:0942908CCE2D4A3662420D0222E17295BA3ECBF58010BEC66E7BC3762A7FD9C9.png)
一多即时通讯场景包含以下设计能力：侧边导航、分栏布局。
页面开发
以聊天页为典型页面进行展开，聊天页中包含侧边导航与分栏布局的设计能力，本文着重介绍聊天页如何实现分栏布局。
布局能力
聊天页在不同断点下的UX效果如下，涉及的设计能力是侧边导航，分栏布局。侧边导航参考侧边导航，其中会有详细介绍。
在手机和折叠屏折叠状态设备上，受屏幕大小限制，不能实现分栏布局，需要通过点击或者其他方式跳转到另一个页面，但是在折叠屏展开状态、平板及2in1产品中屏幕尺寸足够大，可以分栏显示不同的内容，为了使操作更加便捷，在IM对话页中使用分栏布局实现对话功能。
示意图如下：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |    |
| 效果图  |     |    |    |
示意图
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151250.28185637728866667608021437647363:50001231000000:2800:CADF34E520820B9C5BA822472B74AE9879DAED214F34BEB555C317F743FB5C3F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151250.30497175890094298391197998207653:50001231000000:2800:B7E60DCE7CF5D8E53E2ACC064D8CE9D1E2E2A85EB30B25B8B673FD61C4A655E0.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151250.77765314125831809718357013899192:50001231000000:2800:D3C5FBD1C3D5821459B804451072D5C5C7C72C58382E35162D30C39CEA8C08B9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151250.47755735747132549344899747851954:50001231000000:2800:CE519CC51B9E0A01CA1AB28B3B8DA48ADF66BCFE84DDE688CB045A3793114ABF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151250.37385374635606914381380413478960:50001231000000:2800:68FEFDFEBE0DDDDFC4E54A1720047F570B95B057C11037544B7A22C4DD46997A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151250.78937891715717531144382099474430:50001231000000:2800:BCD852CC6E8A9359F98F80F2F9DDD315CFA75484CA4A8A7B118DC00EC2017334.png)
从上表中，可以发现在sm断点下呈现的是聊天列表页，当点击某一条聊天记录的时候跳转到聊天详情页面；在md和lg断点下则左侧呈现聊天列表页，右侧呈现聊天详情页。
在一次开发，多端部署场景下，Navigation组件能够自动适配窗口，在窗口较大的场景下自动切换分栏展示效果。因此本文中分栏布局使用Navigation组件实现。
各个设备布局图如下所示：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  | 参照上文表格  |
| 布局图  |   |   |   |
示意图
sm
md
lg
效果图
参照上文表格
布局图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151250.87805109751042183130646573211778:50001231000000:2800:43D58948442FD474E1C45BD8DB01A1104A3510CCC67D05F3F4237791D6597998.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151250.29765809461460175766888282546096:50001231000000:2800:E2326822843AFEFD8DC8C0587D7BB733022D82349E5050CB311C9533E52D6F9A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151250.83258696764790361050243666807792:50001231000000:2800:7F41E95D580023F26C139424DDD98DE8BE96F31003F278CC956EFE903B6A2E50.png)
此外需要注意Navigation的模式与宽度在不同设备下是有区分的，具体代码如下：
交互归一
不同类型的智能设备，系统已经针对不同的交互方式做了适配，实现了交互归一，因此开发者无需额外关注用户不同的交互方式。
本场景包含的交互归一方式如下（以触控屏为例）：
1、单指点击对应组件。
2、单指滑动List和Scroll组件。
3、走焦（参考一多开发实例（长视频））。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-community-app
爬取时间: 2025-05-01 08:32:56
来源: Huawei Developer
概述
本文选择社区评论行业应用作为典型案例介绍“一多”在实际开发中的应用。社区评论行业应用的核心功能为社区新闻浏览以及热搜榜单查看。根据这些核心功能，案例实现推荐热搜、热搜榜单、卡片详情、图片查看、输入评论等典型页面。文章主要介绍关键布局能力的功能及实现。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。下文将详细介绍它们在“一多”开发实践中如何使用。
架构设计
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考分层架构设计。
UX设计
社交通讯类的多设备响应式设计指南，点击访问。
本示例应用包含热点页、热搜榜单页、卡片详情页、图片查看页四个典型页面。其中主要介绍热点页及卡片详情页关键区域布局能力实现。以手机设备UX设计进行介绍。
热点页利用响应式布局中的栅格布局能力，结合WaterFlow容器，实现单列卡片变瀑布流卡片的一多布局能力。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151251.40198568267796266697788282920839:50001231000000:2800:1D4F0FC901865799AAE4E4632124AFBD2946E65447F79C5BA24A40BE2E680F0F.png)
卡片详情页利用响应式布局中的栅格布局，实现图文区域和评论区域的左右布局和上下布局，实现边看边评的图文阅读效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151251.59821751100108828889817838754292:50001231000000:2800:DEDBDD54F3BD396784FBDCC50BF1ECE198247C0E3102A6002A201CF02594EA85.png)
社区评论应用包含以下一多页面布局能力：侧边导航、列表重复布局、动态卡片、边看边评布局。侧边导航参考一多开发实例（长视频）。
页面开发
布局能力
本章节选取页面关键区域进行一多页面布局能力介绍。
热点页布局能力
热点页主要提供搜索、热搜展示、信息阅读等功能。使用布局能力为：列表重复布局、动态卡片。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151251.58871730536857898022942956118724:50001231000000:2800:0B844C90E72761CADB7C02268F6AA1ADED6E8D568CE177CFE6273CB38BA2E627.png)
竖向列表可以清晰明了地展示数据，在宽屏设备上为了展示更多的数据，设计了列表重复的布局。
在进行有序数据展示时，使用List容器进行数据排列。通过设置List组件的布局方向listDirection和lanes属性并结合断点，实现在不同断点下显示不同列数。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
示意图
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151251.72937931762582250517590606960510:50001231000000:2800:9C99A5B6AB450D88A554D1A6EBD555BB8905516DBF428C80A4CE4615F8B3539D.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151251.81108244676674307101528792997868:50001231000000:2800:400EA983287478C9E82F99984A469DDE94323BE5BEDCA13B5532FC597FA3E477.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151251.03079023790846246973219347811333:50001231000000:2800:EF05F79E4E61B1EF157B7EADED4334E0D4C33185BB23B64FE248EA60C5FFD3ED.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151251.28910649396201867027168862464645:50001231000000:2800:89A0126FCF6CB05EFEF0775AAA5979F1F198168E9DE82C0EB4E84B76378C1488.png)
```typescript
// features/hot/src/main/ets/view/HotColumnView.ets
@Component
export struct HotColumnView {
@StorageLink('currentBreakpoint') currentBreakpoint: string = Breakpoint.BREAKPOINT_SM;
// ...
@Builder
hotListBuilder() {
List() {
ForEach(HOST_LIST_ARRAY[this.tab_index], (item: HotItemInterface, index: number) => {
if (index < Common.HOT_COLUMN_MAX_COUNT * new BreakpointType(1, 2, 3).getValue(this.currentBreakpoint)) {
ListItem() {
HotListItemView({
item: item,
showDetail: true,
// ...
})
}
.width(new BreakpointType('100%', '50%', '33%').getValue(this.currentBreakpoint))
}
}, (item: HotItemInterface) => JSON.stringify(item))
}
.width('100%')
.height('334vp')
.lanes(Common.HOT_COLUMN_MAX_COUNT)
.listDirection(Axis.Horizontal)
}
build() {
Column() {
this.hotListBuilder()
// ...
}
// ...
}
}
```
信息卡片作为显示内容的主体，若使用竖向单列的布局方式，在宽屏设备上容易造成大量留白，影响视觉效果。此时通过在宽屏设备上展示两列的方式充实了页面内容，并通过瀑布流的布局紧密连接了卡片，提供了更紧凑的视觉效果。
动态卡片布局主要使用WaterFlow容器，在小屏设备手机、折叠屏与宽屏设备PC/2in1之间差异化显示。在手机及折叠屏上竖向单列展示，通过分割线进行卡片分隔。而在PC/2in1设备上，依赖断点控制WaterFlow容器显示2列。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
示意图
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151251.16314194707317220837879006655229:50001231000000:2800:093F874AA3DC3040BA16F9D035DECA221DC94B68853E2E3B90D1A9093A0E945A.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151251.63064557161602763657277026819102:50001231000000:2800:7C126ADF214A1BFEB9F7352357BE429C3F32BD7AF18DE7072251486131862CDA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151251.88866681036946225179074292304909:50001231000000:2800:005AC4E71C2111D6B13571540213BD55DECC594611F7AC87D88AD1C9623DD742.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151251.52586658548975880183533335605842:50001231000000:2800:B9194950C3F513F72F9A64AC26852AD9606AFD6A3E71412AA6C0B6C0FDC0C5A1.png)
卡片详情区域
卡片详情区域支持图文和评论在不同设备上显示上下或左右布局。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151252.12239289975922720876586721286107:50001231000000:2800:2600AE5C764962BB1D604BF777DD3E3AD9CD2616A2079F8A6C4B132E006F2948.png)
为了更好的进行图文内容及图片内容的展示，以及实现同时浏览评论的功能，在不同设备上进行了图文与评论左右或上下的布局设计。手机布局为上下布局。折叠屏支持内容区和评论区上下及左右布局切换。PC/2in1固定为左右布局。
边看边评能力主要使用栅格布局实现。在手机设备上图文区及评论区同时占满设备栅格，显示图文区在上评论区在下的效果。折叠屏上下布局实现方式同手机上实现一致。控制图文区占用栅格数为3/5，评论区栅格数为2/5，从而实现了图文与评论的左右布局。
PC/2in1设备上固定为左右布局。使用SideBarContainer容器设置评论区宽度。由于栅格布局与SideBarContainer容器无法兼容，使用断点分别控制两处实现的显示隐藏。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |    |
示意图
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151252.40232691640209087595863632545501:50001231000000:2800:15477F5915ACFE6F2B59D0C8180EB28F782F3A31D71E2C66EC242146CD2484DF.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151252.31354047039210563080796871363319:50001231000000:2800:6CA7A781F173EC63415D032A8AD88F0F371F4D02E7C3F07F29BD807B8CE177AA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151252.01741776687320464241471918879565:50001231000000:2800:775C863C4A01226564B04C900DAE6D2C36A0ECE85E7179D29B4F1B8FC5F0BFC1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151252.22357225791909253392817361757640:50001231000000:2800:36B1C071B3DDC406EE79E569BABBBBA7A2661A972CEA85A0B98F014FDE5413E2.png)
交互事件处理
鼠标事件
PC/2in1设备支持鼠标键盘，需要进行交互事件处理。触控点击评论区触发点击事件拉起弹窗进行评论输入。鼠标点击时触发鼠标事件，更改评论区显示状态为输入状态，取消对点击事件的处理。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151252.64649444303265154257997710854264:50001231000000:2800:963872578A338E34F71F70E02DB6AD17FAF62A731960CBEC331F677AC8B9BD74.png)
```typescript
// features/detail/src/main/ets/view/CommentBarView.ets
@Component
export struct CommentBarView {
// ...
build() {
Column() {
Row() {
if (!this.isMouseClick) {
Row() {
Text($r('app.string.detail_write_comment'))
// ...
}
// ...
// 判断鼠标左键点击事件
.onMouse((event: MouseEvent) => {
if (event.button === MouseButton.Left && event.action === MouseAction.Press) {
this.isMouseClick = true;
}
})
// 鼠标事件触发时，点击事件内容不执行
.onClick(() => {
if (!this.isMouseClick) {
AppStorage.setOrCreate('isShowInput', true);
}
})
// ...
}
else {
// 鼠标左键点击事件触发显示该区域
Row() {
TextArea({ placeholder: $r('app.string.detail_write_comment'), text: this.content })
// ...
Image(this.isDarkMode ? $r('app.media.ic_toolbar_send_white') : $r('app.media.ic_toolbar_sent'))
// ...
.onClick(() => {
this.isMouseClick = false;
})
}
// ...
}
}
// ...
}
// ...
}
// ...
}
```
文字缩放
详情页正文内容支持捏合手势缩放文字大小。文字区域添加双指捏合手势事件，使用缩放比例计算文字大小及文字行高，实现双指缩放文字的功能。缩放事件输入方式参考交互归一。
效果如图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151252.19048616730440907289137261008280:50001231000000:2800:2AEED979590F95A4AC5762FE1E2D57F02D1081B5A8D86C6E73728AAE8A199FA3.gif)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-financial-app
爬取时间: 2025-05-01 08:33:09
来源: Huawei Developer
概述
本文以银行理财应用作为典型案例详细介绍“一多”在实际开发中的应用。银行理财行业应用在大屏幕设备的使用过程中，不仅要保障用户在办理金融业务过程中的正常使用，底部/侧边页签也要尽可能提升屏幕的交互效率。具体功能主要包含首页推荐、产品专题、产品详情、产品对比、收益明细等。
下面的章节将分别从架构设计、UX设计、页面开发三个角度给出推荐的参考样例，介绍“一多”银行理财应用在开发过程中的最佳实践。
阅读本文前，开发者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。下文将详细介绍它们在“一多”开发实践中如何使用。
架构设计
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计的逻辑设计。
UX设计
金融理财类的多设备响应式设计指南，点击访问。
银行理财应用包含以下设计要点：弹窗、延伸布局、分栏、底部/侧边页签、列表重复布局。侧边导航侧边导航、列表重复布局在其他的“一多”案例中有详细的介绍，本案例以弹窗和延伸布局以及分栏为重点进行介绍。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151253.99361319139829682561140731484632:50001231000000:2800:EA641AE42FFF1FD018B304A1F9D7F1D4123D299D406F2FCB427B62CA188246B2.png)
弹窗使用自定义弹窗CustomDialog实现，首次打开应用时通过CustomDialogController类显示自定义弹窗。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151253.75979412324345983982226792659506:50001231000000:2800:3AC58F1537EDFC3FF352A66307BCF1C0D9C017EED277441A64B9024E3838D4D4.png)
产品专题页面中稳健增长信息使用list组件实现，通过在不同断点下设置不同的列数实现延伸布局，在大屏上显示更多信息，提升屏幕交互效率。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151253.29714002645376473598698040490772:50001231000000:2800:A2745C141DD05D2156CEAF44F84E74C214898D6F14ECC4E44B5569890F3B3653.png)
产品详情页面使用Navigation实现分栏效果，在手机上单栏显示内容，在PC/2in1等大屏设备分栏显示，左边为导航区右边为内容区，通过点击稳健增长下的内容控制右侧内容区信息展示。
页面开发
本章节选取页面关键区域进行“一多”页面布局能力介绍。
弹窗
弹窗使用自定义弹窗实现，在初始化弹窗时设置customStyle为true，则弹窗样式由开发者自定义，在sm、md、lg不同的断点设置固定的宽高值，使弹窗的大小在不同设备显示相差不大。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
示意图
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151253.42287127783907238090572069105508:50001231000000:2800:562C2EAF3120EA7B604977D3A76EFAD257FBB56C855E0B4796128660D2E422D4.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151253.53814560314612407321114458494168:50001231000000:2800:6A208D064BA939245FE7ABF5BB9A1D830BDA8B18F574E2F18B720811257A3127.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151253.16922666448230101392774465976698:50001231000000:2800:EADB886F4157EC27DA4E87321255F9639DBF17C70062859D5DEE5E5ECACF8B0F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151253.46714968891166509722546835770728:50001231000000:2800:4C3AC2222BA7A1FA4E43B02AC1F66BEF2B232DC74E5D84D3937EF7D43F3F99C2.png)
延伸布局
延伸布局使用List列表来实现，在不同断点条件下使用list加载不同的数量的数据，同时使用list的lanes属性设置显示的列数，在sm、md、lg下分别显示2列、3列、5列，使数据在不同的设备上显示合适的数量，提高屏幕交互效率。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
示意图
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151253.94366091258427923870999912221237:50001231000000:2800:921AFED5C95B6B3B567379A7B49E106708707200B37F78871625F80A6378D972.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151253.39027821312515955754439425678841:50001231000000:2800:A9AA4A34B5238C3804388174F3E759E09BF287C9ACA1C762E4C8BC19E51F9EA5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151253.82870826993028000865709170823141:50001231000000:2800:65C123F86984A60951712B8F376C39506933B2814A1E7360957A9FC598306637.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151253.23150508069498958439550012450747:50001231000000:2800:3E3C7BDF2E8E25B278D1971753758B3BE0F96DA89C381B3BC6C71EDB77BD9652.png)
分栏
分栏布局通过Navigation实现，在断点为lg时设置mode属性为NavigationMode.Split，实现分栏效果；在其他断点下设置mode属性为NavigationMode.Stack，显示单栏效果。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
示意图
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151253.12229939318897216513937815253896:50001231000000:2800:ADAF63693208414AC058D1AF2B4FFF2839F438431C1B656D7C29964CA7289299.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151253.57542363992380372406754568043765:50001231000000:2800:D725AC7ECEDCBBFB451B828B887912A2B6F9C16F97C1D4891526FCAEE839F2D4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151254.59479270738310357435607984723531:50001231000000:2800:151E06540668C0B36A67212EAC9930C988ADBA2723341CCBFDFD2F1820AD6EAA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151254.29859527820377538839481435780529:50001231000000:2800:8EF024ADBA6C0E86505F857D3B370F4AE9A6DD98FC82C32376845DC5734E68A2.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-shopping-price-comparison
爬取时间: 2025-05-01 08:33:23
来源: Huawei Developer
概述
本文从目前流行的垂类市场中，选择购物行业应用作为典型案例详细介绍“一多”在实际开发中的应用。购物行业应用的核心功能为浏览商品、商品比价和直播购等。根据这些核心功能，本文选择首页、商品分类页、商品详情页、商品支付页、咨询客服页、直播间页等作为典型页面进行开发，遵从多设备的“差异性”、“一致性”、“灵活性”和“兼容性”，能够让开发者快速高效地掌握“一多”能力并实现购物比价应用的相关功能。
购物类应用为了向用户展示更多的商品选择，对垂类内的核心功能进行了独特设计：
当前系统的产品形态主要有手机、折叠屏、平板和PC/2in1四种，下文的具体实践也将围绕这几种产品形态展开，同时将分别从UX设计、架构设计、页面开发三个角度给出符合“一多”的参考样例，介绍“一多”购物比价应用在开发过程中的最佳实践。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。下文将详细介绍它们在“一多”开发实践中如何使用。
UX设计
电商购物类的多设备响应式设计指南，点击访问。
架构设计
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计的逻辑设计。
页面开发
本章介绍购物比价应用中如何使用“一多”的布局能力，完成页面层级的一套页面、多端适配。下文将从不同页面展开，介绍每个页面区域使用到具体的布局能力，帮助开发者从0到1进行购物比价应用的开发。
首页
首页通常有入口图标和商品卡片等丰富的商品信息，帮助解决用户浏览及挑选商品的核心需求。观察首页在不同设备上的UX设计图，可以进行如下设计：
-  sm md lg 效果图 效果图
|    | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151254.21915581486948214167759192773112:50001231000000:2800:D638FB4C242528C2FE1909262013BCDFB3825FD00B9033296D4D11AE1E760FEC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151254.90488105351665363278182715951297:50001231000000:2800:19083C03190EFE1B6C49333E953DC7A8841950DC4B7EC327DDAE138BE1A5F566.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151254.51820826314387238019958608775183:50001231000000:2800:33AD90503AFFCCBF0560A9354BC11A115F3E8042356BFAFF89583381CBCB02F6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151254.45900477633936919345849435030675:50001231000000:2800:352DCC7A3D2428C911A2128346DBA415D8E1AB97E0B0739CCDB297F3ADC9E18D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151254.38872277086868125935611733781158:50001231000000:2800:DAC02EDB6389121ECF4367A6148F938796A7EB14A9D2DE32F9DEDBBE8FECFFE8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151254.84430667950710894146038290685442:50001231000000:2800:F21477F513E635FE72C06B0BD542E5CC2DFE69B5A36DA4F0C0DDC0A8EDE8B0AB.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 底部/侧边页签  | 借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。  |
| 2  | 顶部页签及搜索框  | 栅格布局监听断点变化实现折行显示，List组件实现延伸能力，layoutWeight实现拉伸能力，代码可参考一多开发实例（长视频）。  |
| 3  | 商品分类图标  | List组件实现延伸能力，代码可参考一多开发实例（长视频）。  |
| 4  | 商品卡片  | Swiper组件，指定displayCount属性实现占比能力，设置aspectRatio属性实现缩放能力，代码可参考一多开发实例（长视频）。  |
| 5  | 福利专区  | Row组件的justifyContent属性设置为FlexAlign.SpaceBetween实现均分能力，代码可参考一多开发实例（长视频）。  |
| 6  | 甄选推荐  | 响应式布局的栅格布局，设置aspectRatio属性实现缩放能力，代码可参考一多开发实例（长视频）。  |
| 7  | 限时秒杀  | 响应式布局的栅格布局，设置aspectRatio属性实现缩放能力，同甄选推荐。  |
区域编号
简介
实现方案
1
底部/侧边页签
借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。
2
顶部页签及搜索框
栅格布局监听断点变化实现折行显示，List组件实现延伸能力，layoutWeight实现拉伸能力，代码可参考一多开发实例（长视频）。
3
商品分类图标
List组件实现延伸能力，代码可参考一多开发实例（长视频）。
4
商品卡片
Swiper组件，指定displayCount属性实现占比能力，设置aspectRatio属性实现缩放能力，代码可参考一多开发实例（长视频）。
5
福利专区
Row组件的justifyContent属性设置为FlexAlign.SpaceBetween实现均分能力，代码可参考一多开发实例（长视频）。
6
甄选推荐
响应式布局的栅格布局，设置aspectRatio属性实现缩放能力，代码可参考一多开发实例（长视频）。
7
限时秒杀
响应式布局的栅格布局，设置aspectRatio属性实现缩放能力，同甄选推荐。
商品分类页
商品分类页主要用于快速查找目标商品。观察商品分类页在不同设备上的UX设计图，可以进行如下设计：
-  sm md lg 效果图
|    | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151254.39468888419488396745481822832344:50001231000000:2800:CEAB562E6D52FCBEE6F9154E61D446D7C5571C6EF540710B0B8AAB535955C413.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.36115053762037500381688222684202:50001231000000:2800:64EE57033AB956A07D8C5487BF8EB1ACC70DA670666DA1DA843BCD18EFC6FF2D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.75267882675787044823815249791709:50001231000000:2800:7EEFE67E2644D39DA352E5AE31A237D8E56081CE1FE9873B06A5EE4520B35E89.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部搜索框  | 在sm断点下占满行宽，在md、lg断点下设置justifyContent属性为End。  |
| 2  | 侧边导航  | Navigation组件实现，设置mode属性为Split分栏显示，使用navBarWidthRange约束不同断点下的固定导航栏宽度。  |
| 3  | 广告卡片  | Swiper组件设置displayCount在不同断点下为1、2、3，在md断点下设置nextMargin露出后边距，实现自适应布局的占比能力，代码可参考一多开发实例（长视频）。  |
| 4  | 商品小图  | 使用List组件+栅格布局实现每行显示固定个数的商品图，代码可参考一多开发实例（长视频）。  |
区域编号
简介
实现方案
1
顶部搜索框
在sm断点下占满行宽，在md、lg断点下设置justifyContent属性为End。
2
侧边导航
Navigation组件实现，设置mode属性为Split分栏显示，使用navBarWidthRange约束不同断点下的固定导航栏宽度。
3
广告卡片
Swiper组件设置displayCount在不同断点下为1、2、3，在md断点下设置nextMargin露出后边距，实现自适应布局的占比能力，代码可参考一多开发实例（长视频）。
4
商品小图
使用List组件+栅格布局实现每行显示固定个数的商品图，代码可参考一多开发实例（长视频）。
-  使用Navigation组件实现分栏显示，设置mode为NavigationMode.Split双栏显示，同时设置不同断点下导航栏的最小和最大宽度一致，约束固定的导航栏宽度。
购物袋页
购物袋页通常用于快速查看并支付待购买的商品，在大屏上采用右侧露出辅助信息确保页面的使用效率。观察购物袋页在不同设备上的UX设计图，可以进行如下设计：
-  sm md lg 效果图
|    | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.90723563876392595007778625136750:50001231000000:2800:7485466BADBC2357758318139C8D6A07757BAF57AFE73C1C4ED8FE0A40670025.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.24373273619295271103559141094576:50001231000000:2800:F222CF25607E6F5C9109B773C0812585764254B82985081B7340519BD9FE9CD1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.56516844004042228144678931010857:50001231000000:2800:5E7B43850DF3728A2611DD28EA87F11D2979971FF98E7C5AA500478BF496843D.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部标题栏  | 剩余空间全部分配给中间空白区，用Blank组件实现自适应布局拉伸能力，同首页顶部页签及搜索框。  |
| 2  | 购物袋商品  | List组件实现。  |
| 3  | 结算工具栏  | 剩余空间全部分配给中间空白区，用Blank组件实现自适应布局拉伸能力，同顶部标题栏。  |
| 4  | 优惠明细  | 购物袋主区域与优惠明细辅助区域在Row组件中呈左右布局，sm和md断点下只显示购物袋主区域、隐藏优惠明细区域，lg断点下全部显示，代码可参考一多开发实例（长视频）。  |
区域编号
简介
实现方案
1
顶部标题栏
剩余空间全部分配给中间空白区，用Blank组件实现自适应布局拉伸能力，同首页顶部页签及搜索框。
2
购物袋商品
List组件实现。
3
结算工具栏
剩余空间全部分配给中间空白区，用Blank组件实现自适应布局拉伸能力，同顶部标题栏。
4
优惠明细
购物袋主区域与优惠明细辅助区域在Row组件中呈左右布局，sm和md断点下只显示购物袋主区域、隐藏优惠明细区域，lg断点下全部显示，代码可参考一多开发实例（长视频）。
商品详情页
商品详情页展示商品大图及详细信息。观察商品详情页在不同设备上的UX设计图，可以进行如下设计：
-  sm md lg 效果图
|    | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.83814416756911312675894829556582:50001231000000:2800:F8AD950E5BDDEE36EA80B00220F8B1DAF4F52F479FF35A4D3A96A3112F48F3A6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.54259820117331109300964254670654:50001231000000:2800:1A16E292530955C29D653EA7D2EFEA4BA1F7E841A178BC108BF0C1B773AF493E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.15789472315911548427922945613841:50001231000000:2800:FC82ABB9080A58A12BE4DFA65C18E8D163356190B27BED909F830FEA0FC39420.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 商品大图  | Swiper组件，指定displayCount属性实现延伸能力，设置aspectRatio属性实现缩放能力，代码可参考一多开发实例（长视频）。  |
| 2  | 商品详细信息  | 商品大图区域与商品详细信息区域在sm和md断点下使用Column组件呈上下布局，在lg断点下使用Row组件呈左右布局，同商品详情侧边面板页。  |
| 3  | 购买工具栏  | 剩余空间按比例分配给加入购物袋与购买按钮，用layoutWeight属性实现自适应布局占比能力，同首页顶部页签及搜索框。  |
| 4  | 画中画  | 使用PiPWindow实现画中画功能，启动、停止小窗直播及控制视频播放。  |
区域编号
简介
实现方案
1
商品大图
Swiper组件，指定displayCount属性实现延伸能力，设置aspectRatio属性实现缩放能力，代码可参考一多开发实例（长视频）。
2
商品详细信息
商品大图区域与商品详细信息区域在sm和md断点下使用Column组件呈上下布局，在lg断点下使用Row组件呈左右布局，同商品详情侧边面板页。
3
购买工具栏
剩余空间按比例分配给加入购物袋与购买按钮，用layoutWeight属性实现自适应布局占比能力，同首页顶部页签及搜索框。
4
画中画
使用PiPWindow实现画中画功能，启动、停止小窗直播及控制视频播放。
商品详情页在大屏设备上提供分屏功能，满足同时查看两个商品的详细参数进行购物比价的诉求。分屏通过创建一个新的UIAbility，并设置窗口显示为分屏模式实现。分屏后左右屏幕的宽度为1：1，在折叠屏上的效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.09612121461737692982278141241277:50001231000000:2800:9CF197738D3197509815A66A8F9B8E59BCC3DED817BFBA0DA2317890C782CA41.png)
创建新的UIAbility，需要在phone目录下创建SecondAbility.ets，注册与EntryAbility相同的UIAbility生命周期回调。下一步需要在phone目录的module.json5配置文件，修改abilities属性注册SecondAbility，详情可参考源码。启动分屏时，调用UIAbilityContext的StartAbility接口，设置窗口模式为分屏并启动SecondAbility。关闭分屏时，调用UIAbilityContext的terminateSelf接口。
另外，为了增强在大设备上的浏览效率，用户点击全部评论，页面三分栏展示右侧的全部评价页面，使用SideBarContainer组件实现。
效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.93876162786099701055723071799578:50001231000000:2800:3E9DC9FA091D01EC3407DB6028D6756844BF659EDE7F843A7EFCF37129C70160.png)
-  使用@ohos.PiPWindow模块的create接口创建画中画控制器，使用startPiP接口启动画中画，启动后返回上一页。其中画中画播放的视频内容需要使用XComponent+AVPlayer组件实现，读者可以自行查看源码。 初始化画中画控制器时，分别注册画中画生命周期状态和直播控制事件的监听。 使用stopPiP接口关闭画中画。
商品详情侧边面板页
在查看商品详情时，经常会有咨询客服或查看购物车的诉求，可采用侧边面板显示客服对话等辅助信息，提升浏览效率，实现边看商品边聊天咨询等体验。
-  sm md lg 设计能力点 侧边面板-咨询客服 侧边面板-购物袋
|    | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |   |   |
| 侧边面板-咨询客服  |   |   |   |
| 侧边面板-购物袋  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.76854657871834982379879263821174:50001231000000:2800:1FE1EFE30D890BDE2B48D07A1B8900933D7961DDF5D8A35D5BC1DD5DD9E50D04.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.30705132179170345420265362802215:50001231000000:2800:8469DC07FA74304076B977AE0F5B770227E6B1B1EE8E9C1755C242D784199EBF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.23827805069673885340667467804568:50001231000000:2800:F3C7B42FF1D19ABB8729A136892B420D139EFFC2BBCB5203F8599BBDA60888E5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151255.74822707811299598839748365202510:50001231000000:2800:EAD4EC9E6F4C2A15E56E2BD5D189AB50853B08752A05D5EED866306369DE64EE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.05647448713559173839108029598223:50001231000000:2800:D458434B29048635D9827CB02EEAC959F9C3906990EC50C9C39B43380EDD8B03.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.24703112675717558903757044314141:50001231000000:2800:57CF08ACB523D7E0C5239DCF44DE0343F38BD4809D2664A5463609718E31311F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.51559617164336832106283055906851:50001231000000:2800:7760A651A53B5FA6AFF11065F23F890C2519A90540DC98824464DF6C5ACFD451.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.38720205678203202783775296045954:50001231000000:2800:92264F2716F9A21D0907EA007139E32B7EABCF4E85BE63E9308F6237A7B64DB4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.75425212322744066499828094449960:50001231000000:2800:1E11603A91F5BF144CD72BE33561CF67E1DA73788ACA797BB3829B254032A933.png)
商品支付页
|    | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |   |   |
| 效果图  |   |   |   |
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.28338306623689648324311619773580:50001231000000:2800:1F4FF685E1B3FD12C0492870FE0988C46863D06CCFCBD813615B2AB5E547B075.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.47422833818493172541377421789730:50001231000000:2800:F9AC25E48D38B3A289E37F84BD50784C39F4FE393A46B5D02AFB8474BE0F4B5F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.79456095195160028826401585615621:50001231000000:2800:EED267063488F8F5D47B23D787AECBE50F354FCDD9B8325D1B4EADF2C57A5484.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.74231603577225177650991738636490:50001231000000:2800:7B268E4ACD6AF6D761B3910D089BCC6B9DDEFAF9257B0E3CD6391B5C9A88C324.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.79364599156034687939119404543698:50001231000000:2800:588252EE0CA3A0CF8A27F77E1AE146A68E9D634FDE3CB37239608411587A0361.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.27785763937300209646263757411752:50001231000000:2800:683ED56300EDFE6C5D75078B14C4F9E127D42D0C5BA2F9DCA3A777AAA173A293.png)
商品支付页的浅层窗口，在sm断点下使用bindSheet为购买按钮绑定底部半模态页面，在md和lg断点下使用居中半模态自定义弹窗居中显示。
半模态页面使用@Builder注解构建，绑定到bindSheet事件。
自定义弹窗使用@CustomDialog注解构建，绑定到自定义弹窗控制器。
直播间页
|    | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |   |   |
| 效果图  |   |   |   |
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.05412981944004131206808752296025:50001231000000:2800:D93D3A9288CB8916056FD63E8A9A0F582A5A662960D0749CFDB711C15FF7C859.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.50712844598074390783434463260667:50001231000000:2800:A55DBD78F90A506CE21F827148BA752278082C7AE050F943187B19814106D4E5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151256.73070307223408974144733895913295:50001231000000:2800:B14C6461BE4E6A4723D239A4807655E85C881DB3ACFD50D18F452213C2B97137.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151257.69366838558864652787743871779216:50001231000000:2800:65A85AF5CF77411C58DB2AAC895DC68F344B2584447CFFE74729E7E1D8341BF2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151257.56942511392338608291646393247166:50001231000000:2800:09DA91C3F7EA9766AB717088779259831161C4E4D19825FAFA58570ECF0AD202.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151257.74450089013795989538602328299843:50001231000000:2800:E894C2476C796C74CF6BA7B94077641C108DB631861263B67961833747C08869.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 直播内容  | Stack组件控制子组件的显示层级，在sm断点下aspectRatio属性控制直播图片等比放大实现自适应能力的缩放能力，在md和lg断点下固定大小，同商品详情页商品大图。  |
| 2  | 直播弹幕及推荐商品  | 使用Flex组件+List组件，在sm和md断点下呈上下结构，显示在下方，在lg断点下呈左右结构，显示在两侧并尾部对齐。  |
| 3  | 发表弹幕  | TextInput组件设置layoutWeight实现自适应布局拉伸能力，同首页顶部页签及搜索框。  |
区域编号
简介
实现方案
1
直播内容
Stack组件控制子组件的显示层级，在sm断点下aspectRatio属性控制直播图片等比放大实现自适应能力的缩放能力，在md和lg断点下固定大小，同商品详情页商品大图。
2
直播弹幕及推荐商品
使用Flex组件+List组件，在sm和md断点下呈上下结构，显示在下方，在lg断点下呈左右结构，显示在两侧并尾部对齐。
3
发表弹幕
TextInput组件设置layoutWeight实现自适应布局拉伸能力，同首页顶部页签及搜索框。
-  Flex组件的direction和justifyContent属性控制子组件在容器主轴上的位置，sm和md断点下在容器底部，lg断点下在容器两侧。List组件控制列表的排列方向，sm和md断点下水平，lg断点下垂直。
直播侧边面板页
在看直播时，经常需要一边听商品讲解一边浏览商品信息，可利用侧边辅助面板查看商品详情、口袋宝贝或支付页面。直播侧边面板页在不同设备上的UX设计图如下：
|    | sm  | md  | lg  |
| --- | --- | --- | --- |
| 侧边面板-商品详情页  |    |   |   |
| 侧边面板-口袋宝贝页  |   |   |   |
| 侧边面板-支付页  |   |   |   |
sm
md
lg
侧边面板-商品详情页
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151257.62680207362585358645609702732092:50001231000000:2800:69E394A45738D0B0E3F84B471C8F0BD72891A571B57E6EADCC07D4911BA9416B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151257.60659361672744299228459467420864:50001231000000:2800:CC06A87450B8115723ADBA90D925589A1838575DA9A16897E0CC06C483E922D7.png)
侧边面板-口袋宝贝页
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151257.20106827896718079403301492665152:50001231000000:2800:A057F92D40659E334F913D0E2CEA68D1B07B0B07C90C28EAA4EB8B6394E8D691.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151257.25381214751627764443076929451005:50001231000000:2800:69A2E35E6BADE6C0D3BB3BA9AF547DCAF86D0B4E6888519DAEE9EFE41577A9E8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151257.34071686400797041366220378520224:50001231000000:2800:1C725637AD35BE803C12A6DA91496D792C611C983C5659B255C0B1EFDE99F2B8.png)
侧边面板-支付页
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151257.04985851904775960002353468564162:50001231000000:2800:E93688039037F48D4514D69E559A6163FBE4897E4CB73027938B0E2A4F8D8DBD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151257.24053718081047814304275799035151:50001231000000:2800:4C24D4A1761D91ECD3096FCF6FA33CCBFD4FE17C87750B82557DB202D45F46CF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151257.00567531491369508134637937259699:50001231000000:2800:0613CACE77EAD991EB6F171A9732ECFFC88FAA4F250714E4637C5285FBAA44D2.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-news-read
爬取时间: 2025-05-01 08:33:38
来源: Huawei Developer
概述
本文以新闻阅读应用作为典型案例详细介绍“一多”在实际开发中的应用。新闻阅读应用在大屏幕设备的使用过程中，不仅要保障用户在界面浏览中的正常使用，也要尽可能提升屏幕的交互效率。该实例主要界面包含首页推荐、热门新闻、新闻详情、刷新闻、精选发现等。
新闻阅读一多开发过程中涉及到的相关能力包括：
下面的章节将分别从UX设计、架构设计、页面开发三个角度给出推荐的参考样例，介绍“一多”新闻阅读应用在开发过程中的最佳实践。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。下文将详细介绍它们在“一多”开发实践中如何使用。
UX设计
新闻阅读类的多设备响应式设计指南，点击访问。
架构设计
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计的逻辑设计。
页面开发
本章介绍在新闻阅读应用中如何使用“一多”的布局能力，完成页面层级的一套页面、多端适配。下文将从不同页面展开，介绍每个页面区域使用到具体的布局能力，帮助开发者从零到一进行新闻阅读应用的开发。
首页推荐
新闻阅读应用首页主要发挥推荐精选新闻的作用，解决用户想要看新闻的核心需求，所以首页内容都围绕这一功能设计。观察首页在多设备上的UX设计图，可以进行如下设计：
|    | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151258.55734544799948960516298024064703:50001231000000:2800:E04478C63BD684E3B8F147D7A648F5B63B448A6BC476E835309D6B1452A0B179.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151258.13456506885732540265477508228944:50001231000000:2800:C9E3B03DA604527C2C34D67DFCF03D1029770D6A75FDC00B2EE23BE2B491EF7A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151258.05158266269957405620125506155477:50001231000000:2800:42AD94B1B815A8C41C7288396E394E137996002A3F69C68E92284D85EF24C216.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151258.98991720018504926076895785864748:50001231000000:2800:A05036F12A600A044F003DF254B68370BB249F3295D20425CA2DA00EF34DA1EF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151258.58654601702685310440167495190726:50001231000000:2800:84FE5F1D94814F996C0F074F974BB9803504695FAC1A21BDCC2C90A4419B1A0E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151258.49142849180903144926476218388336:50001231000000:2800:5E67DBD07F97D284B874D40E71F606AEB9A3AAB26CFB61CBBD29EA0F63E9609D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151258.45650367545114983351845356986347:50001231000000:2800:C100F304AE4BCBA2D369446191BCC6D3A502098485B27E3AA88FA25B5D1A35B1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151258.05058021966922744116060763534657:50001231000000:2800:4CF85C39AC68517AE139EEBB549AC1929A0EBB53AF1BFCFCF1099DAE97568D74.png)
实现方案如下表：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 底部/侧边页签  | 借助栅格布局监听断点变化改变位置。同一多开发实例（长视频）长视频底部/侧边页签。  |
| 2  | 顶部页签及搜索框  | 使用栅格布局监听断点变化实现折行显示，List组件实现延伸布局，layoutWeight实现拉伸能力。同一多开发实例（长视频）顶部页签及搜索框。  |
| 3  | 顶部文字要闻  | 使用List组件的lanes属性，在不同断点下呈1、2、3列显示 。同一多开发实例（长视频）搜索发现。  |
| 4  | 新闻大图卡片  | 使用Swiper组件，指定displayCount属性实现延伸布局，设置aspectRatio属性实现缩放能力。同一多开发实例（长视频）Banner图。  |
| 5  | 上文下图  | 采用重复布局，在手机、折叠屏上保持原有布局，在PC/2in1及更宽的设备上重复布局。  |
| 6  | 左文右图  | 采用重复布局，手机上的单列信息，在折叠屏和PC/2in1上重复布局。  |
| 7  | 竖向视频卡片  | 采用重复布局，手机上的左图右文卡片，在折叠屏和PC/2in1上显示更多列该卡片内容。同一多开发实例（社区评论）列表重复布局。  |
| 8  | 大视频类新闻  | 采用重复布局，手机上单列展示，在折叠屏和PC/2in1上重复布局。同一多开发实例（社区评论）列表重复布局。  |
| 9  | 横向滑动小视频  | 采用延伸布局，使得设备尺寸变宽时，更多的小视频卡片被展示到界面。同一多开发实例（长视频）视频详情页。  |
区域编号
简介
实现方案
1
底部/侧边页签
借助栅格布局监听断点变化改变位置。同一多开发实例（长视频）长视频底部/侧边页签。
2
顶部页签及搜索框
使用栅格布局监听断点变化实现折行显示，List组件实现延伸布局，layoutWeight实现拉伸能力。同一多开发实例（长视频）顶部页签及搜索框。
3
顶部文字要闻
使用List组件的lanes属性，在不同断点下呈1、2、3列显示 。同一多开发实例（长视频）搜索发现。
4
新闻大图卡片
使用Swiper组件，指定displayCount属性实现延伸布局，设置aspectRatio属性实现缩放能力。同一多开发实例（长视频）Banner图。
5
上文下图
采用重复布局，在手机、折叠屏上保持原有布局，在PC/2in1及更宽的设备上重复布局。
6
左文右图
采用重复布局，手机上的单列信息，在折叠屏和PC/2in1上重复布局。
7
竖向视频卡片
采用重复布局，手机上的左图右文卡片，在折叠屏和PC/2in1上显示更多列该卡片内容。同一多开发实例（社区评论）列表重复布局。
8
大视频类新闻
采用重复布局，手机上单列展示，在折叠屏和PC/2in1上重复布局。同一多开发实例（社区评论）列表重复布局。
9
横向滑动小视频
采用延伸布局，使得设备尺寸变宽时，更多的小视频卡片被展示到界面。同一多开发实例（长视频）视频详情页。
使用List组件，设置不同断点下的lanes属性来实现。在sm断点下设置为1，在md断点下设置为2，在lg断点下设置为3。实现不同屏幕尺寸显示更多列数。具体代码可参考：一多开发实例（长视频）搜索发现。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151258.18224976168621100659510486886088:50001231000000:2800:2A4605040CC1481F7B9A0C62A020157957E6920F92284AB5F3655AC915E9AAE8.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.28876068906577987158223477389099:50001231000000:2800:736E012758B77A635C4F47A20F5D812093F45D5E5DBFF0BA2B8E4C9A7C170633.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.73868301055979184812911807242086:50001231000000:2800:0AC5CABDF94E3BA4B912E90CC3E1DC8E7DD468953B9E7A8A9B67B7753777B471.jpg)
使用Swiper组件，设置在不同断点下的displayCount属性来实现自适应布局延伸布局，新闻大图卡片在sm断点下设置为1，在md断点下设置为2，在lg断点下设置为3。实现在不同屏幕尺寸显示更多内容。具体代码可参考：一多开发实例（长视频）Banner图。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.18960196472086992283138807721184:50001231000000:2800:38C2E8EB9B399A89AC44B970244A0044240E838D1BE096E81815DB5FC46990FE.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.74407464604656752930688109655945:50001231000000:2800:2702EEF02B7267D9D8C7BD072CF38A9DC7F149394F24451D294325B9A4568332.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.66294593800925633011471674222060:50001231000000:2800:DB0F04B8E70292334FD56AFAE6DDD13800BFA12D4C6BB00C5107A7EAE95C711F.jpg)
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
示意图
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.57838929324731089969379233140012:50001231000000:2800:1CBE2D88D84942129825AAD2E347F6A8194BC71FEF56C3FCD0BE16F1B18559DD.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.09855009154103840859857451910416:50001231000000:2800:CDC59434E00B2C1A597A169BDDDF938CBD17A2CC6675AB790F5E6FE45E42826A.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.05441450103184953094211116168424:50001231000000:2800:16D8F5263FB9EB20F8EA066C1597B1DA7CBB0C3742A6F4F22CE45BD1F2CB188C.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.47632814084143724823326804902496:50001231000000:2800:D25CD37952CB5E6437E645267F443A522D2956355CAEAD228B74C8A57021CCD5.jpg)
```typescript
// src/main/ets/pages/MediaNews.ets
build() {
Column() {
Header()
GridRow({
gutter: 20
}) {
ForEach(this.newsList, (news: News) => {
GridCol({
span: {
sm: 12, // 在sm断点下设置内容占用span为12
lg: 6 // 在lg断点下设置内容占用span为6
}
}) {
NewsWithThreeImages({ news })
}
}, (news: News) => news.getNewsID())
}
.onBreakpointChange((breakPoints: string) => {
// 根据断点情况返回渲染数据的条数
this.newsList = this.multiImageViewModel.getNewsListByBreakpoint(breakPoints);
})
.width('90%')
}
.width('100%')
.justifyContent(FlexAlign.Center)
}
```
使用栅格布局配合断点控制列数，在sm尺寸下设置GridCol的span属性为12，在md及以上尺寸设置GridCol的span属性为6，同时使用Text组件的visibility属性配合断点控制摘要部分显隐，在sm和md断点下设置摘要部分Text组件的visibility为Visibility.Hidden，在lg及以上断点设置为Visibility.Visible。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
示意图
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.62328776510072368058809730128386:50001231000000:2800:08BE9DD65424408E9501DCD87A267D8A6C6A66762E06896A73A930762BF440C2.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.64276857936262222070186356734975:50001231000000:2800:D83882148BDE9A2C1453EDC9CC93D65019D1A3E5B3037C54D593A9DB399F55DD.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.06921108160529236535083835493434:50001231000000:2800:390580EAF19EB30C56327B9FD9270ED6ACCFD8FDC8D8E76F416D92BAA2A92730.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.44481349160203093873323555558183:50001231000000:2800:AA0296DF84BE33EA2915DD43D1740671630CFDF0F2256EFD8493913896BB6209.jpg)
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
示意图
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.97541638396006655559032266838166:50001231000000:2800:C1EC2C5FAAB8BF2623A8ACD4241F067512D0CAD84C98E2952753714783C1B37F.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.83263712836941751152848987308610:50001231000000:2800:A51F440981495813EA16A20CE042A515DB9AE7A233AAF078CF6629384EE3468D.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151259.97582060082927337543108878086770:50001231000000:2800:3072CF5A34F88C0EB822D0D1FEFD36CC3496DB615438BF322B25C2B5E7419CF4.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.17981726166947339387783896164338:50001231000000:2800:CCF8FF92B535FC73315E1C7FA7B690B2483DD582323EAE11543A3DAE955ABB24.jpg)
使用栅格布局配合断点控制显示列数与数据源数量。在sm断点下设置GridCol的span属性为12，返回渲染数据源个数为1个，在md断点下设置span为6，渲染数据源为2个，在lg断点下设置span为4，渲染数据源为3个。具体代码可参考：一多开发实例（社区评论）列表重复布局。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
示意图
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.94472415890630092344433675877596:50001231000000:2800:23F0B986FB0CE90767C72321DD3BC320E0CE0F043A85781979A9922D37029BF9.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.48146409306948966669169453631873:50001231000000:2800:2D727C4C51549725006958E34C3F5E2DC20A8FC3AEA6E9FD48E887FFC18761FE.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.66497278489053414992839469222433:50001231000000:2800:94C40C84FD61C8C2FC9057781385EF1264D14BA1B68E945DA0D8606F37F39415.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.20980170179114614047155261670991:50001231000000:2800:DDD8413647B44019C94A7F83100400558F39F30319B7C2C9E1B4651F7B15BFBB.jpg)
使用Scroll与Row组件实现延伸布局，随着屏幕尺寸的增加，展示更多的小视频数量，延伸布局可参考：延伸布局，具体代码可参考：一多开发实例（长视频）视频详情页。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.58909135285305985675207587659296:50001231000000:2800:ACF8D5BCE16E92733C86DE4A71774D0636C76BFE0D3A3C7986A1F98FC068DD19.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.98352198958814554119694633927084:50001231000000:2800:6AF2D957FA9CCF4065CCE9A1653D405DD08AD4CEEF6960127B4A51B70E466194.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.58043444020626630984606742619183:50001231000000:2800:9D3A74376FCE13371A65FC993A8C0E405427EF16CEE1AAA29611D50DD9BCB0CE.jpg)
热门新闻
热门页提供热门新闻的不同设备浏览体验。观察新闻详情页在不同设备上的UX设计图，可以进行如下设计：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.68368892834192421359619382386729:50001231000000:2800:37A8EB8AC895F47D55BBC2161349932336035A82AE402AA884EE41A144075847.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.91359179635152244622487011189571:50001231000000:2800:0CEBBD5EC8208114F40CE5A3F8ACE22528F4393A60D564502F2C800F9E866275.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.99253421181629262850307036333821:50001231000000:2800:855DD24862B37F57BE380F9D8A17024313B00C1CF81A194032808F910C81ADA6.png)
实现方案如下表：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 底部/侧边页签  | 借助栅格布局监听断点变化改变位置。同一多开发实例（长视频）长视频底部/侧边页签。  |
| 2  | 顶部页签及搜索框  | 栅格布局监听断点变化实现折行显示，List组件实现延伸布局，layoutWeight实现拉伸能力。同一多开发实例（长视频）顶部页签及搜索框。  |
| 3  | 新闻列表  | 借助断点监听改变不同断点下的布局方式，在sm断点及sm以下使用List组件，在sm断点以上使用栅格布局。  |
区域编号
简介
实现方案
1
底部/侧边页签
借助栅格布局监听断点变化改变位置。同一多开发实例（长视频）长视频底部/侧边页签。
2
顶部页签及搜索框
栅格布局监听断点变化实现折行显示，List组件实现延伸布局，layoutWeight实现拉伸能力。同一多开发实例（长视频）顶部页签及搜索框。
3
新闻列表
借助断点监听改变不同断点下的布局方式，在sm断点及sm以下使用List组件，在sm断点以上使用栅格布局。
为了实现从列表到宫格的灵活切换，可以在sm及以下断点时利用List组件来展示内容，而在sm断点以上时采用栅格布局。当为栅格布局时，在md断点下设置GridRow的columns属性为2，在lg断点下设置columns属性为4。对于需要占有更大空间的组件内容，单独设置其GridCol的span属性使其占用更多的份数。
新闻详情
新闻详情页向用户提供详细的新闻信息。观察新闻详情页在不同设备上的UX设计图，可以进行如下设计：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
示意图
sm
md
lg
设计能力点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.50892109354792424700965404239496:50001231000000:2800:D3A8C4A7E84E81BA405784F2B2309DFF43A98D7B4CA5D24240A6C12F75F29679.png)
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.80356222022778936149705269328600:50001231000000:2800:668412F786C57199FAEEB07ADE8748ABBA8DEC2EFA2AC8D7E7E5688087C11816.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.57176091058359623703544074956123:50001231000000:2800:C2BAE152ADC69E06BE473115991A9B0CE3CEAD5AEBE22E5591161B352391F3D8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.24465102830740638051048101961963:50001231000000:2800:2A1F72B45A0A29852DE111DCAAA7C0BCAA994B42A0C9A6C0D54DA471A3148A6B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151300.82897510838749043392370988849679:50001231000000:2800:F5AC27344217BFAE78822B588B83FF406A20A12323E57B8110FBE2BA5733E5FE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151301.74955571604858344593339485295873:50001231000000:2800:97646874E5FB6F36E27E56E2462EC3FA93D6CD991EFDAA39625E57E4B7AEAE74.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151301.92587152468584723200826882520952:50001231000000:2800:0A087F00E7F7E1DDA58D20204457D966E32701207B68E97B83294E3B4064EFB6.png)
实现方案如下表所示：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部栏  | 使用自适应布局中的拉伸能力，可使用Blank组件实现屏幕宽度变化时，中间空白内容随设备尺寸变化。具体可参考：一多开发实例（长视频）搜索发现。  |
| 2  | 新闻标题及发布信息  | 使用占比能力保证多设备尺寸下的界面一致。具体可参考：一多开发实例（社区评论）边看边评。  |
| 3  | 新闻内容  | 使用占比能力保证多设备尺寸下的界面一致。具体可参考：一多开发实例（社区评论）边看边评。  |
| 4  | 评论区  | 采用挪移布局，当设备尺寸变宽时将新闻内容区域和评论区左右布局。具体可参考：一多开发实例（社区评论）边看边评。  |
| 5  | 底部工具栏  | 使用自适应布局中的均分能力，实现设备尺寸变化时图标尺寸不变，图标间距及左右边缘间距均等改变。具体可参考：一多开发实例（社区评论）动态卡片。  |
区域编号
简介
实现方案
1
顶部栏
使用自适应布局中的拉伸能力，可使用Blank组件实现屏幕宽度变化时，中间空白内容随设备尺寸变化。具体可参考：一多开发实例（长视频）搜索发现。
2
新闻标题及发布信息
使用占比能力保证多设备尺寸下的界面一致。具体可参考：一多开发实例（社区评论）边看边评。
3
新闻内容
使用占比能力保证多设备尺寸下的界面一致。具体可参考：一多开发实例（社区评论）边看边评。
4
评论区
采用挪移布局，当设备尺寸变宽时将新闻内容区域和评论区左右布局。具体可参考：一多开发实例（社区评论）边看边评。
5
底部工具栏
使用自适应布局中的均分能力，实现设备尺寸变化时图标尺寸不变，图标间距及左右边缘间距均等改变。具体可参考：一多开发实例（社区评论）动态卡片。
边看边评实现上可以利用栅格布局实现挪移布局，在sm断点下设置GridCol对应内容span为12，而在sm以上断点设置对应内容占用span为6，自动实现从新闻内容和评论区的上下布局切换到左右布局。具体可参考一多开发实例（社区评论）边看边评。
刷新闻
刷新闻界面向用户提供新闻流列表。观察该页面在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 效果图
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151301.14800276927415170955570990507390:50001231000000:2800:F86E5213A035C3BC3A53FB7CEED7C02ABAA9B3575A880620584C3CA652DABFBC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151301.12485551967597199026606047815956:50001231000000:2800:DB700F9D0D5DA48F774C225F702177BD0350002901F095BC48E18BEC2206CF50.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151301.31836002709271041892972872275040:50001231000000:2800:F319AAD1610BFD21873D3894307B6FDF398DDCF5722553614AFCB61A7AFADB86.png)
在刷新闻界面中，开发者可以使用WaterFlow容器，实现一列到多列的切换。在sm断点下依赖断点控制设置WaterFlow的columsTemplate属性为1，在md断点下设置columsTemplate为2，在lg断点下设置columsTemplate为3。具体实现开发者可以参考：一多开发实例（社区评论）动态卡片。
精选发现
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151301.85113115065580438896678429707506:50001231000000:2800:5F3BA2E52FB5924B428B504F319CE40F192C1E75AA1AAB7C9CB7C0F0B722DB54.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151301.89610614917679611187586821338359:50001231000000:2800:C1DA5F0077DB96ABA27633AAFFD10029A24611A7B39EDC0809D1DDC6E0200566.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151301.05354479490897376089843742162464:50001231000000:2800:D13FC9F5025F58DC31591B9CC3268CA3521ECC5C639BEF97B0D06F96A59AB87D.png)
精选发现界面使用瀑布流一列变多列，主要使用WaterFlow容器实现不同设备的差异化显示。在sm断点下一列显示，在md断点下依赖断点控制设置WaterFlow的columsTemplate为两列，在lg断点下设置columsTemplate为三列。具体实现开发者可以参考：一多开发实例（社区评论）动态卡片。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-picture-app
爬取时间: 2025-05-01 08:33:51
来源: Huawei Developer
概述
本文从目前流行的垂类市场中，选择图片美化应用作为典型案例详细介绍“一多”在实际开发中的应用。一多图片美化应用包含相册，大图预览，图片编辑功能。
本文重点内容如下：
当前系统的产品形态主要有手机、折叠屏、tablet和PC/2in1四种，本文分别从UX设计、页面开发两个角度给出符合“一多”的参考样例，介绍“一多”图片美化应用在开发过程中的最佳实践。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。
UX设计
本示例中的图片美化应用包含相册、大图预览、图片编辑页面。详细的UX设计可以参考拍摄美化类设计。
架构设计
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计。
页面开发
本章介绍图片美化应用中如何使用”一多”的布局能力，完成页面层级的一套代码、多端适配。同时介绍图片美化应用中的交互开发。
布局能力
本节由不同页面展开，介绍每个页面区域使用到的具体布局能力，帮助开发者从零到一进行图片美化应用的开发。
相册
相册页显示所有图片。观察相册页在折叠屏上的UX设计图，可以进行如下设计：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.96230663849118360623040188059116:50001231000000:2800:6F59AF97FA71B0800D39AF93DE966C8A82A462F151DB92A909661AB47C2003B6.png)
相册页的2个基础区域介绍及实现方案如下表所示：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部返回  | 使用自适应布局实现左侧返回图标及文字，右侧图标。  |
| 2  | 相册列表  | 使用网格实现相册列表。  |
区域编号
简介
实现方案
1
顶部返回
使用自适应布局实现左侧返回图标及文字，右侧图标。
2
相册列表
使用网格实现相册列表。
示意图如下：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |    |    |     |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.38947765771315095355950290550847:50001231000000:2800:954EECC8538236340E996CCD615A8F1D1E509A53DFB8E1C958F121826220C8D5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.34895363377823618638527625765835:50001231000000:2800:C21A7ED22143A97038CCD2F590464C986B847ABF94AD7F21C9C27AACE0754842.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.44764242369755679055278387101440:50001231000000:2800:892745B22DE1D62E08804E3317783A699C3B8389035457256E15B7F01DAA1543.png)
当组件区域宽度变化时，可以通过onAreaChangeAPI获取组件的相关信息，并调整相册列数。
```typescript
// features/albumView/src/main/ets/views/AlbumView.ets
// 列数计算公式
getGridColumn(value: Length): number {
return Math.floor(2 * ((parseInt(JSON.stringify(value)) / 360) - 1) + 4);
}
```
大图预览
大图预览显示一张图片。观察大图预览页在折叠屏上的UX设计图，可以进行如下设计：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.81261864235999920347921890005285:50001231000000:2800:132DD4F6E6493456DF4763BF3C35F08CA97839DC0E88B0A898B23252947B3ED7.png)
相册页的4个基础区域介绍及实现方案如下表所示：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部返回  | 使用自适应布局实现左侧返回图标及文字，右侧图标。  |
| 2  | 图片展示  | 使用Image组件展示图片。  |
| 3  | 相册滚动展示  | 使用列表实现相册滚动展示。  |
| 4  | 图片操作  | 使用自适应布局实现图标自适应摆放。  |
区域编号
简介
实现方案
1
顶部返回
使用自适应布局实现左侧返回图标及文字，右侧图标。
2
图片展示
使用Image组件展示图片。
3
相册滚动展示
使用列表实现相册滚动展示。
4
图片操作
使用自适应布局实现图标自适应摆放。
示意图如下：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |    |    |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.50251960263033378097206015433741:50001231000000:2800:C8F3A8F0632B490D6B58CB10E114502783582B59BC50769C0A450D5B993F3385.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.34444149215040585882111079707445:50001231000000:2800:020F0BA5409A085D7148EB7EAC65D03EF8D56AF7399C825824056AF4EA0504C8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.62446069534264498147913608334333:50001231000000:2800:1C4378AAF17DE49EB8FDDA4EADB9A3768C7DBE9E694282F876275E7C0999E40C.png)
图片编辑
在折叠屏中，可以切换图片区域与编辑操作区域的摆放位置。观察图片编辑页在折叠屏上的UX设计图，可以进行如下设计：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.12773801703812812289148159591896:50001231000000:2800:88F81ADB75809246684194C30C561F096E00D8FBCDFD04BD19F3551DBBEE7A71.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.24636008933986369208566974085913:50001231000000:2800:17E30F218DF93FE3D18978D1EB13B5F6395D270A88BAE23BFE224ADDDFF44769.png)
图片编辑的3个基础区域介绍及实现方案如下表所示：
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部返回  | 使用自适应布局实现左侧返回图标及文字，右侧图标。  |
| 2  | 图片展示  | 使用Image组件展示图片。  |
| 3  | 编辑操作栏  | 使用Flex组件实现编辑操作栏的自适应摆放。  |
区域编号
简介
实现方案
1
顶部返回
使用自适应布局实现左侧返回图标及文字，右侧图标。
2
图片展示
使用Image组件展示图片。
3
编辑操作栏
使用Flex组件实现编辑操作栏的自适应摆放。
示意图如下：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |    |      |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.81371954537903474879452890618393:50001231000000:2800:94B6F47123CD8A683EF586B5047850A14717879B2B5795E971137D051A26B916.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.63451458966814489954400903306192:50001231000000:2800:395A1257DB40CE246703711B6694D50B20A7A83C5703C1AE42468425650DF294.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.38599082112236864266980658677321:50001231000000:2800:82F8CC3580A8EFC7F6E9EEB8E842859D1AF99B72EBBFA3234BFA48C961D5C37E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151302.54903689394901833529957795502809:50001231000000:2800:42CDE24DC4EE02539587CC83DC45EC27D2146D48888C0A501EBE236B170877E0.png)
交互开发
对于不同类型的智能设备，用户可能有不同的交互方式，如通过触摸屏、鼠标、触控板等。如果针对不同的交互方式单独做适配，会增加开发工作量同时产生大量重复代码。为解决这一问题，我们统一了各种交互方式的API，即实现了交互归一。常见的交互有触屏事件、键鼠事件、焦点事件。图片美化涉及的交互主要涉及图片的缩放。
双指缩放
在触控屏与触控板上进行双指捏合或张开可以实现缩放功能。本文中有两处涉及双指缩放：
-  双指缩放使用PinchGestureAPI实现， 当触发双指缩放时，可以实时获取缩放比例参数，传入scaleAPI（控制组件缩放的API）即可调整图片的比例。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-ticket-class
爬取时间: 2025-05-01 08:34:05
来源: Huawei Developer
概述
本文从目前流行的垂类市场中，选择股票类应用作为典型案例，详细介绍“一多”在实际开发中的应用。主要包含首页、资讯、自选股、个股详情、行情等9个典型页面。
-  分栏布局：分栏布局通过Navigation实现，在断点为lg时设置mode属性为NavigationMode.Stack，实现单栏效果，在其他断点下设置mode属性为NavigationMode.Split，实现分栏效果。 宫格卡片的多股同列：用网格布局Grid组件，在不同断点下将父组件分为不同列数，来实现自适应布局的占比能力。
-  首页-股票页签：借助栅格布局监听断点变化，同时设置layoutWeight属性为1，实现居中对齐自适应拉伸。 股票PK详情-核心指标：使用Blank组件及设置固定宽度可实现数据各列的空白空间自适应拉伸，同时对不同列设置不同的alignItems，支持不同列设置不同对齐方式。 行情-股票双页签：借助栅格布局监听断点变化，改变List组件下子组件的间隔宽度，同时给List组件设置固定宽度，当List组件下的tab内容超过设定宽度时隐藏部分tab，延伸显示更多。
下面的章节将分别从UX设计、架构设计、页面开发三个角度给出推荐的参考样例，介绍“一多”股票类应用在开发过程中的最佳实践。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。下文将详细介绍它们在“一多”开发实践中如何使用。
UX设计
金融理财类的多设备响应式设计指南，点击访问。
架构设计
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计的逻辑设计。
页面开发
本章介绍股票类应用中如何使用”一多”的布局能力，完成页面层级的一套页面、多端适配。下文将从不同页面展开，介绍每个页面区域使用到具体的布局能力，帮助开发者从零到一进行股票类应用的开发。
首页
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 底部/侧边页签 借助栅格布局监听断点变化改变位置，设置在不同断点下Tabs组件的vertical属性，实现显示在页面的不同位置，代码可参考一多开发实例（长视频）。 2 标题 List组件实现延伸能力，layoutWeight实现拉伸能力，代码可参考一多开发实例（长视频）。 3 快捷入口 List组件实现延伸能力，代码可参考一多开发实例（长视频）。 4 Banner 使用Swiper组件，设置在不同断点下的displayCount属性来实现自适应布局的延伸能力，代码可参考一多开发实例（长视频）。 5 中间tab 借助栅格布局监听断点变化，同时设置layoutWeight属性为1，实现居中对齐自适应拉伸，示例代码为：股票页签。 6 指数 使用Swiper组件自适应增加个数，代码可参考一多开发实例（长视频）。 7 热门 通过Swiper组件的displayCount属性并结合断点，控制在不同断点下显示不同的列数，代码可参考一多开发实例（社区评论）。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151303.76701579226492045427556910309108:50001231000000:2800:F2E1AD0F7A295509BE49A9CDEE02BB9351CC4FB16EB990F6E8787100CEE9CEB8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151303.54469630095342250777813027983497:50001231000000:2800:031C6D0626C06EC19A14E9FADA950CE3C3991E9916C9CC912BF1FB525AAAF162.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151303.07362775337938587322187945541223:50001231000000:2800:CCC3A4609C78AA7DB1F52DD362116D3C0B9EEE2540A32BA019EA125F633D3B07.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151303.83480412624352234615506798081816:50001231000000:2800:618BBAE13899C452CF0BFC58087DF7DD671583DFD85045848187E2C0A95F2072.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 底部/侧边页签  | 借助栅格布局监听断点变化改变位置，设置在不同断点下Tabs组件的vertical属性，实现显示在页面的不同位置，代码可参考一多开发实例（长视频）。  |
| 2  | 标题  | List组件实现延伸能力，layoutWeight实现拉伸能力，代码可参考一多开发实例（长视频）。  |
| 3  | 快捷入口  | List组件实现延伸能力，代码可参考一多开发实例（长视频）。  |
| 4  | Banner  | 使用Swiper组件，设置在不同断点下的displayCount属性来实现自适应布局的延伸能力，代码可参考一多开发实例（长视频）。  |
| 5  | 中间tab  | 借助栅格布局监听断点变化，同时设置layoutWeight属性为1，实现居中对齐自适应拉伸，示例代码为：股票页签。  |
| 6  | 指数  | 使用Swiper组件自适应增加个数，代码可参考一多开发实例（长视频）。  |
| 7  | 热门  | 通过Swiper组件的displayCount属性并结合断点，控制在不同断点下显示不同的列数，代码可参考一多开发实例（社区评论）。  |
-  借助栅格布局监听断点变化，不同断点List组件子组件的间隔设置为不同值，同时设置layoutWeight属性为1，实现居中对齐自适应拉伸。
```typescript
// AdaptiveTabCenteringIndex.ets
import { ListDataConstants } from '../constants/ListDataConstants';
import { CommonConstants } from '../constants/CommonConstants';
import { BreakpointType } from '../utils/BreakpointType';
@Component
export struct AdaptiveTabCenteringIndex {
@StorageLink('breakPoint') breakPoint: string = CommonConstants.BREAK_POINT_SM;
@Consume('pageInfos') pageInfos: NavPathStack;
@State tabIndexSelected: number = 0;
build() {
NavDestination() {
Column() {
// ...
Column() {
Row() {
Column() {
List({
// 借助栅格布局监听断点变化，不同断点List子组件的间隔设置为不同值
space: new BreakpointType(CommonConstants.TAB_PADDING_SM, CommonConstants.TAB_PADDING_MD,
CommonConstants.TAB_PADDING_LG).getValue(this.breakPoint)
}) {
ForEach(ListDataConstants.RECOMMENDATION_TAB_LIST, (item: string, index: number) => {
ListItem() {
Column() {
Text(item)
// ...
}
}
// ...
}, (item: string, index: number) => index + JSON.stringify(item))
}
.scrollBar(BarState.Off)
.listDirection(Axis.Horizontal)
}
// ...
.layoutWeight(CommonConstants.COMMON_FAL_1)
}
// ...
}
// ...
}
}
.hideTitleBar(true)
}
}
```
资讯
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 底部/侧边页签 借助栅格布局监听断点变化改变位置，设置在不同断点下Tabs组件的vertical属性，实现显示在页面的不同位置，代码可参考一多开发实例（长视频）。 2 标题 文字和功能按钮中间增加Blank组件，实现拉伸能力。 3 中间Tab 借助栅格布局监听断点变化，不同断点占比不同，同时设置layoutWeight属性为1，实现居中对齐自适应拉伸，代码可参考：股票页签。 4 卡片 使用WaterFlow组件设置columnsTemplate属性实现单列变多列，可参考一多开发实例（社区评论）。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151303.91831652886239663012283138772537:50001231000000:2800:FC8556DE064C29D74D4A96F1C2D0F2AC634195E8F0EEC3E60448CC3476158D7B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151303.35333376363522670299859758491249:50001231000000:2800:187F557EC1B19F2B2A8F756FCD756575F45AC36143475ACF48B3C0066D1C0F2C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151303.98856332223618953449611596802937:50001231000000:2800:F08F8FF7EBB35978D297812A4D6AABD3E520AC4987361456591CE6D20660D150.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 底部/侧边页签  | 借助栅格布局监听断点变化改变位置，设置在不同断点下Tabs组件的vertical属性，实现显示在页面的不同位置，代码可参考一多开发实例（长视频）。  |
| 2  | 标题  | 文字和功能按钮中间增加Blank组件，实现拉伸能力。  |
| 3  | 中间Tab  | 借助栅格布局监听断点变化，不同断点占比不同，同时设置layoutWeight属性为1，实现居中对齐自适应拉伸，代码可参考：股票页签。  |
| 4  | 卡片  | 使用WaterFlow组件设置columnsTemplate属性实现单列变多列，可参考一多开发实例（社区评论）。  |
自选股
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 底部/侧边页签 借助栅格布局监听断点变化改变位置，设置在不同断点下Tabs组件的vertical属性，实现显示在页面的不同位置，代码可参考一多开发实例（长视频）。 2 标题 文字和功能按钮中间增加Blank组件，实现拉伸能力。 3 指数 最后一个组件固定，其他组件使用List组件实现延伸能力，随着设备宽度变大，页签间距变大、页面能够展示更多页签内容，代码可参考一多开发实例（长视频）。 4 股票列表 使用Blank组件及设置固定宽度可实现数据各列的空白空间自适应拉伸，同时对不同列设置不同的alignItems，支持不同列设置不同对齐方式，示例代码同核心指标。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151303.59363779369371019400981863413882:50001231000000:2800:238E96D0E6C64C5488572A36025763867D1A024F45645FCD556EB25648D36443.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151303.49314038131357247916691374265384:50001231000000:2800:6A57B12B1A252EB8B0E10E00A1997DCB98C727317815AD1256E9A4A863491B85.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151303.21914079781691461333088658275327:50001231000000:2800:74AF230033E0CA37BCAF717A3E864A9092168A71F3C04C5A46989AAE9717D451.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 底部/侧边页签  | 借助栅格布局监听断点变化改变位置，设置在不同断点下Tabs组件的vertical属性，实现显示在页面的不同位置，代码可参考一多开发实例（长视频）。  |
| 2  | 标题  | 文字和功能按钮中间增加Blank组件，实现拉伸能力。  |
| 3  | 指数  | 最后一个组件固定，其他组件使用List组件实现延伸能力，随着设备宽度变大，页签间距变大、页面能够展示更多页签内容，代码可参考一多开发实例（长视频）。  |
| 4  | 股票列表  | 使用Blank组件及设置固定宽度可实现数据各列的空白空间自适应拉伸，同时对不同列设置不同的alignItems，支持不同列设置不同对齐方式，示例代码同核心指标。  |
个股详情
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 交易操作行 使用List组件实现延伸能力，同时使用layoutWeight将增加的空间全部分配给”去交易”按钮，实现拉伸能力，代码可参考一多开发实例（长视频）。 2 标题 居中显示，其他操作两端对齐，空白空间使用Blank组件实现自适应布局拉伸能力。 3 行情列表数据 行情居左放大显示，通过Swiper组件的displayCount属性并结合断点，控制在不同断点下显示不同的列数，列表自适应两列变多列，代码可参考一多开发实例（社区评论）。 4 中间Tab 通过List组件实现自适应延伸，代码可参考一多开发实例（长视频）。 5 曲线图 使用layoutWeight属性实现拉伸能力，代码可参考一多开发实例（银行理财）。 6 讨论的Tab 通过List组件实现自适应延伸，代码可参考一多开发实例（长视频）。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151303.08207202669792358193555501356512:50001231000000:2800:B0B138BF1592AEE5952FE423DA9BC3A36E55F2B13C4DBD1A6CD729525ADF1ECD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151303.94824224773674000610286346643210:50001231000000:2800:CB74DAEFD2AD6FDEEB5C8FBD25826312D88CE95DABF49A87FE5396E4B60CD380.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151304.90832164029672302289522030679083:50001231000000:2800:CFEACAEB5139896AD9C74D4EBBBF425BB0C3DCFE06108DAA2A1018357E60839A.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 交易操作行  | 使用List组件实现延伸能力，同时使用layoutWeight将增加的空间全部分配给”去交易”按钮，实现拉伸能力，代码可参考一多开发实例（长视频）。  |
| 2  | 标题  | 居中显示，其他操作两端对齐，空白空间使用Blank组件实现自适应布局拉伸能力。  |
| 3  | 行情列表数据  | 行情居左放大显示，通过Swiper组件的displayCount属性并结合断点，控制在不同断点下显示不同的列数，列表自适应两列变多列，代码可参考一多开发实例（社区评论）。  |
| 4  | 中间Tab  | 通过List组件实现自适应延伸，代码可参考一多开发实例（长视频）。  |
| 5  | 曲线图  | 使用layoutWeight属性实现拉伸能力，代码可参考一多开发实例（银行理财）。  |
| 6  | 讨论的Tab  | 通过List组件实现自适应延伸，代码可参考一多开发实例（长视频）。  |
添加股票
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 标题 空白空间使用Blank组件实现自适应布局拉伸能力。 2 列表 第一列和后面两列两端对齐，中间增加Blank组件，实现自适应拉伸。 3 猜你想找 通过List组件实现自适应延伸，代码可参考一多开发实例（长视频）。 4 PK按钮 使用layoutWeight属性将剩余空间分配给开始PK按钮实现拉伸能力，代码可参考一多开发实例（长视频）。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151304.11617754539443519616220821081263:50001231000000:2800:DC9A8886755EE977B47ABE7BBAB28CC9354C1E3A589AC28D1C443EDC42ACBDCB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151304.34125110224505897642413623501546:50001231000000:2800:8A2BF1650FE3C7F693D2D1A7E7E79C168EA53953415C5E6550110E6C017FB58E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151304.67284270103357698211878345365810:50001231000000:2800:469B4626FA967B285C923160CA793F404EA61F8FBB2D5D9C85A692711A75DF23.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 标题  | 空白空间使用Blank组件实现自适应布局拉伸能力。  |
| 2  | 列表  | 第一列和后面两列两端对齐，中间增加Blank组件，实现自适应拉伸。  |
| 3  | 猜你想找  | 通过List组件实现自适应延伸，代码可参考一多开发实例（长视频）。  |
| 4  | PK按钮  | 使用layoutWeight属性将剩余空间分配给开始PK按钮实现拉伸能力，代码可参考一多开发实例（长视频）。  |
股票PK详情
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 标题 空白空间使用Blank组件实现自适应拉伸。 2 卡片 固定宽度，居左显示。 3 中间Tab 使用Blank组件实现自适应布局拉伸能力。 4 曲线图 使用layoutWeight属性实现拉伸能力，代码可参考一多开发实例（银行理财）。 5 时间维度 设置Flex布局的justifyContent属性为FlexAlign.SpaceBetween，实现自适应拉伸。 6 指标名称和核心指标 使用Blank组件及设置固定宽度可实现数据各列的空白空间自适应拉伸，同时对不同列设置不同的alignItems，支持不同列设置不同对齐方式，示例代码如：核心指标。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151304.25554891170439180787492790101284:50001231000000:2800:F59A618DB85F07E2F7717CB1196C4B50A137170912E856BCF2B284EB712DC55E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151304.19934988580636932104887621931733:50001231000000:2800:91F8FC7409BB902E1666D9B5194D7E46AD36ACE0A96D3D3726DB177D3828A1BC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151304.00986803997602975898959504622022:50001231000000:2800:19D09F67F1AF8FA95E03E2D11D0B881C0A2891E4699674D1B5B5A1B57DD53BF6.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 标题  | 空白空间使用Blank组件实现自适应拉伸。  |
| 2  | 卡片  | 固定宽度，居左显示。  |
| 3  | 中间Tab  | 使用Blank组件实现自适应布局拉伸能力。  |
| 4  | 曲线图  | 使用layoutWeight属性实现拉伸能力，代码可参考一多开发实例（银行理财）。  |
| 5  | 时间维度  | 设置Flex布局的justifyContent属性为FlexAlign.SpaceBetween，实现自适应拉伸。  |
| 6  | 指标名称和核心指标  | 使用Blank组件及设置固定宽度可实现数据各列的空白空间自适应拉伸，同时对不同列设置不同的alignItems，支持不同列设置不同对齐方式，示例代码如：核心指标。  |
-  使用Blank组件作为数据各列的空白空间，同时给各列数据及表格整体设置固定宽度，可实现数据各列的空白空间自适应拉伸。 对不同列设置不同的alignItems，支持不同列设置不同对齐方式。
```typescript
// TableAdaptiveExtensionIndex.ets
Row() {
Column() {
ForEach(ListDataConstants.INDICATOR_NAME_COLUMN, (item: string, index: number) => {
// ...
}, (item: string, index: number) => index + JSON.stringify(item))
}
.alignItems(HorizontalAlign.Start)
Blank()
Column() {
ForEach(ListDataConstants.STOCK_INDEX_DATA1, (item: string, index: number) => {
// ...
}, (item: string, index: number) => index + JSON.stringify(item))
}
.width($r('app.float.stock_data_width'))
.alignItems(HorizontalAlign.End)
Blank()
Column() {
ForEach(ListDataConstants.STOCK_INDEX_DATA2, (item: string, index: number) => {
// ...
}, (item: string, index: number) => index + JSON.stringify(item))
}
.width($r('app.float.stock_data_width'))
.alignItems(HorizontalAlign.End)
Blank()
Column() {
ForEach(ListDataConstants.STOCK_INDEX_DATA3, (item: string, index: number) => {
// ...
}, (item: string, index: number) => index + JSON.stringify(item))
}
.width($r('app.float.stock_data_width'))
.alignItems(HorizontalAlign.End)
}
.width(CommonConstants.FULL_WIDTH_PERCENT)
// ...
```
行情
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 底部/侧边页签 借助栅格布局监听断点变化改变位置，设置在不同断点下Tabs组件的vertical属性，实现显示在页面的不同位置，代码可参考一多开发实例（长视频）。 2 标题 使用Blank组件实现空白空间自适应拉伸。 3 双Tab 借助栅格布局监听断点变化，改变List组件下子组件的间隔宽度，同时给List组件设置固定宽度，当List组件下的tab内容超过设定宽度时隐藏部分tab，延伸显示更多，示例代码如：股票双页签。 4 卡片 使用Swiper组件，设置在不同断点下的displayCount属性来实现自适应布局的延伸能力（同首页Banner图），代码可参考一多开发实例（长视频）。 5 快捷入口 使用List组件实现自适应布局的延伸能力，随容器组件尺寸变大，可以看到的卡片入口相应增加，代码可参考一多开发实例（长视频）。 6 大盘分析和热门板块 使用挪移布局来实现“上下布局”与“左右布局”间的切换，代码可参考一多开发实例（长视频）。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151304.99932673054066347067259559448776:50001231000000:2800:86AE6E06D364925FF74DF73C147B70AC56A399AB6CF829D1FBE41413350B43C8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151304.67815024130209369367680890794005:50001231000000:2800:10C1860F895D5DC354357F893A30512FA3F2E753E89AA8FCE32C0D3B79FCBF28.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151304.42211478320495574119358252058110:50001231000000:2800:81322A9AD18F91F45F9B43EB6079D18528CDF02DAC3ECF8D0B6A57264193AAA8.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 底部/侧边页签  | 借助栅格布局监听断点变化改变位置，设置在不同断点下Tabs组件的vertical属性，实现显示在页面的不同位置，代码可参考一多开发实例（长视频）。  |
| 2  | 标题  | 使用Blank组件实现空白空间自适应拉伸。  |
| 3  | 双Tab  | 借助栅格布局监听断点变化，改变List组件下子组件的间隔宽度，同时给List组件设置固定宽度，当List组件下的tab内容超过设定宽度时隐藏部分tab，延伸显示更多，示例代码如：股票双页签。  |
| 4  | 卡片  | 使用Swiper组件，设置在不同断点下的displayCount属性来实现自适应布局的延伸能力（同首页Banner图），代码可参考一多开发实例（长视频）。  |
| 5  | 快捷入口  | 使用List组件实现自适应布局的延伸能力，随容器组件尺寸变大，可以看到的卡片入口相应增加，代码可参考一多开发实例（长视频）。  |
| 6  | 大盘分析和热门板块  | 使用挪移布局来实现“上下布局”与“左右布局”间的切换，代码可参考一多开发实例（长视频）。  |
-  借助栅格布局监听断点变化，改变List组件下子组件的间隔宽度，同时给List组件设置固定宽度，当List组件下的tab内容超过设定宽度时隐藏部分tab，延伸显示更多。
行情-选股
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 底部/侧边页签 借助栅格布局监听断点变化改变位置，设置在不同断点下Tabs组件的vertical属性，实现显示在页面的不同位置，代码可参考一多开发实例（长视频）。 2 标题 使用Blank组件实现空白空间自适应拉伸。 3 快捷入口 使用List组件实现自适应布局的延伸能力，随容器组件尺寸变大，可以看到的卡片入口相应增加，代码可参考一多开发实例（长视频）。 4 今日主力和特色榜单 使用挪移布局来实现“上下布局”与“左右布局”间的切换，代码可参考一多开发实例（长视频）。 5 价值关注 使用WaterFlow组件设置columnsTemplate属性实现单列变多列，可参考一多开发实例（社区评论）。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151304.54105490901488288974432676259490:50001231000000:2800:AF371A6A1619D6ECF74E2AC4A965009E94AA13714C9DFC15C2EA0F9858E47793.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151304.52966798892953955494381528046842:50001231000000:2800:76FAE153AE50AFD81981C9494F22BA0098C817CE23B9DEB4E1AB01D4D5282E39.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151305.82591804269503594508260417420084:50001231000000:2800:9C2FC50FC07A91374383ED289CA29BD7C33B8B1D2A2BF53A89496094AFA11D7E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151305.58119770082879191767298699054131:50001231000000:2800:2EAEAB5997A151E377C2FF8D3F0B6FA2818B3F6B716D39EA05EC5C973B77D8D0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151305.54816750853660971294462322875069:50001231000000:2800:6F11DB3755BC59F83BE416FB46F410919046F72FDC02279C810B28D2B9579AD7.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 底部/侧边页签  | 借助栅格布局监听断点变化改变位置，设置在不同断点下Tabs组件的vertical属性，实现显示在页面的不同位置，代码可参考一多开发实例（长视频）。  |
| 2  | 标题  | 使用Blank组件实现空白空间自适应拉伸。  |
| 3  | 快捷入口  | 使用List组件实现自适应布局的延伸能力，随容器组件尺寸变大，可以看到的卡片入口相应增加，代码可参考一多开发实例（长视频）。  |
| 4  | 今日主力和特色榜单  | 使用挪移布局来实现“上下布局”与“左右布局”间的切换，代码可参考一多开发实例（长视频）。  |
| 5  | 价值关注  | 使用WaterFlow组件设置columnsTemplate属性实现单列变多列，可参考一多开发实例（社区评论）。  |
多股同列
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 标题 居中显示，其他操作两端对齐，空白空间使用Blank组件实现自适应拉伸。 2 中间Tab 借助栅格布局监听断点变化，使用List组件改变tab间距，展示更多tab内容，实现延伸能力，代码可参考一多开发实例（长视频）。 3 卡片 用网格布局Grid组件，在不同断点下调整columnsTemplate属性将父组件分为不同列数，来实现自适应布局的占比能力，代码可参考一多开发实例（长视频）。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151305.33741520477692008072929712650749:50001231000000:2800:D76184AA3FBC44EA86F832D26188F58306858C17E8BFED0CDE87291B459804FF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151305.14529713267624689392301076229475:50001231000000:2800:708A7B147670E8E7996CF1A3C3983F01163947B9CFEE04645C60C129521D08F1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151305.37933004487710584092668103101320:50001231000000:2800:71BD370B61EDF00875450AB668CE891478DEB9D2B44E60D9DA9D6F724795D475.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 标题  | 居中显示，其他操作两端对齐，空白空间使用Blank组件实现自适应拉伸。  |
| 2  | 中间Tab  | 借助栅格布局监听断点变化，使用List组件改变tab间距，展示更多tab内容，实现延伸能力，代码可参考一多开发实例（长视频）。  |
| 3  | 卡片  | 用网格布局Grid组件，在不同断点下调整columnsTemplate属性将父组件分为不同列数，来实现自适应布局的占比能力，代码可参考一多开发实例（长视频）。  |
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-mobile-payment
爬取时间: 2025-05-01 08:34:24
来源: Huawei Developer
概述
本文从目前流行的垂类市场中，选择移动支付应用作为典型案例详细介绍“一多”在实际开发中的应用，同时提供该垂类应用在多设备上的界面设计与实现参考。本文选择移动支付首页作为典型页面进行开发，涉及的核心功能包括支付、收款、扫码等。
本文重点内容如下：
下面的章节将分别从UX设计、架构设计、页面开发三个角度给出推荐的参考样例，介绍“一多”移动支付应用在开发过程中的最佳实践。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。下文将详细介绍它们在“一多”开发实践中如何使用。
UX设计
移动支付类的多设备响应式设计指南，点击访问。
架构设计
HarmonyOS应用的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计的逻辑设计。
页面开发
本章介绍移动支付应用中如何使用“一多”的布局能力，完成页面层级的一套页面、多端适配。下文将从不同页面展开，介绍每个页面区域使用到具体的布局能力，帮助开发者从零到一进行移动支付应用的开发。
首页
移动应用首页主要涉及扫一扫、支付、收付款等能力。观察首页在多设备上的UX设计图，可以进行如下设计：
-  示意图 sm mg lg 效果图 区域编号 简介 实现方案 1 底部/侧边页签 借助栅格布局监听断点变化改变位置。同一多开发实例（长视频）顶部页签及搜索框。 2 城市及搜索框 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。 3 金刚区 使用栅格布局结合断点变化改变快捷功能的形态。 4 功能入口合集 采用重复布局，在更大尺寸设备上显示更多的功能入口。同一多开发实例（社区评论）列表重复布局。 5 服务卡片 采用重复布局，手机上的单列信息，在折叠屏和PC/2in1上重复布局。同一多开发实例（社区评论）列表重复布局。 6 财富精选 采用栅格布局，在更大尺寸设备上显示更多列数。
| 示意图  | sm  | mg  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151305.38378826530730769651120162158642:50001231000000:2800:586CC064BAC9075CC2DCA285EC183E16DF2BA9242BDD4DF274043B38AFB9280E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151305.63755536590963712659131755556847:50001231000000:2800:1050AF60755A9B9CC46EBA1B81A312CAFA079B404DBC07DA0E8D5521D59781FB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151305.21132415986657189715775141977008:50001231000000:2800:FB6C2EA357879ED188C67B7589C453A8DF38F81B4A54E58E82CF53AF385293BC.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 底部/侧边页签  | 借助栅格布局监听断点变化改变位置。同一多开发实例（长视频）顶部页签及搜索框。  |
| 2  | 城市及搜索框  | 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。  |
| 3  | 金刚区  | 使用栅格布局结合断点变化改变快捷功能的形态。  |
| 4  | 功能入口合集  | 采用重复布局，在更大尺寸设备上显示更多的功能入口。同一多开发实例（社区评论）列表重复布局。  |
| 5  | 服务卡片  | 采用重复布局，手机上的单列信息，在折叠屏和PC/2in1上重复布局。同一多开发实例（社区评论）列表重复布局。  |
| 6  | 财富精选  | 采用栅格布局，在更大尺寸设备上显示更多列数。  |
-  示意图 sm md lg 效果图
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.43934399987233403245116155307860:50001231000000:2800:1A4F073DA8F1630431898B6DDF36459A518B25C90980D7DE3F0DE0CD0FD37A90.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.34295010754148995344954363374964:50001231000000:2800:A901CCC2C6082162F7082C1096FED176002B1A5C8B85DE3AFA76F539EBDC51AB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.24203993319244818439706335435422:50001231000000:2800:C779E9408F9DC04A52F0F7477F4BFE26D4D2EA3537D4D0CE5BEF0C7C7DD42DE1.png)
-  示意图 sm md lg 设计能力点 效果图
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.52838935494428721973997252597193:50001231000000:2800:B9BEFCA63953416E20AD5E493FE62A3FA3E259AB699F80300E03C52C6CB1E3D3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.18743695293221837850322832028960:50001231000000:2800:BBA6184EA3C6751B68ACDA442A4A44B0052F9909174AC7EE65526B7006E10D11.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.43102854463697962841246147824936:50001231000000:2800:89F817D24343C917A2D477E3076142B24E7481F528472C2DF3BCD55B078F301D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.05852062889883457297721935216596:50001231000000:2800:D531343AA100FB26E32D094CFDF9DF08D05062DE09EB819C392546963E6F223E.png)
-  示意图 sm md lg 设计能力点 效果图
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 设计能力点  |   |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.37277412244342115144680592624792:50001231000000:2800:C4462700BA141F7DDDCF8CFC457A8F63E465110A9462F6B365C41E6C2113A9FE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.36636638923655658904335161007317:50001231000000:2800:BBD9FC7A1921622458C203A9185FFD185E8F9B060F2C0DB890C598491482EB75.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.52843821128056706570233576412220:50001231000000:2800:8E02B4E424B2A7BF51A1F625D5FF54DE4E9BDAC1327A70EA5DD373ABB00B2E35.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.47635670117608163512860895646564:50001231000000:2800:2C4B357DB6D3F6ED32E629FC5980490C25A704D23F8E49A76D0D7A54E47599B1.png)
-  使用栅格布局控制不同设备尺寸下显示列数，在sm断点下设置GridCol占用span为12，在md断点下设置GridCol的span属性为6，在lg断点下设置GridCol的span属性为3。 示意图 sm md lg 效果图
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.82816448922193633950775894789316:50001231000000:2800:44838A86AEA992D4EC2F264FA037DDE050CFE0A129CFD758C0E278E1D60F71DF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.68472331978885611272584231838352:50001231000000:2800:3AECA7841402A76201876CFE65D128D32922023FD87C0772A4CEDB18A07CB22D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.16079385171320723286404128006604:50001231000000:2800:7D9BF092534B0606E3FEEB08CCF806FBFD0039E2BFAE291B71742F3F4640D618.png)
-  收付款功能在手机设备上以单独的界面进行呈现，而在折叠屏及更大尺寸设备上以弹窗的方式进行呈现。UX设计图如下： 示意图 sm md lg 效果图 实现上需要根据当前设备的断点尺寸，来决定是使用路由跳转到收付款页，还是以弹窗的方式弹出收付款对话框，代码参考如下： 自定义收款码生成需要使用到Scan Kit中的码图生成能力，关键为使用createBarcode接口依照收款所需的关键信息生成对应的二维码。参考代码如下： 收付款界面开发时常见的问题如下： 二维码定时动态刷新。可以在组件展示或弹窗开启时，启动一个定时器并在回调中传入一个更新二维码的函数，定时地向服务端发起请求获取最新的二维码并对本地二维码进行更新，在组件销毁或弹窗关闭时需要销毁定时器。组件情况下解决二维码定时动态刷新可参考如下代码： 弹窗情况下解决二维码定时动态刷新可参考如下代码： 折叠屏在折叠态与展开态变化时，页面切换流畅。如果应用处在收付款界面，折叠屏从折叠态到展开态，如果不做特殊操作，应用将仍然处在收付款的界面，只是整体尺寸被拉大，同样的，在从展开态到折叠态如果已有弹窗，也会导致整个界面错乱。解决方式为在断点变化时，监听当前路由状态并且控制弹出框的显示与关闭。 应用窗口尺寸动态变化的时候防止二维码变形。解决方式为可以设置二维码的大小为固定百分比或者使用aspectRatio固定宽高比保证图片不变形。 点击createBarcode获取更多该接口使用指导。
-  示意图 sm md lg 效果图 扫一扫功能主要使用Scan Kit中的自定义界面扫码能力来自定义扫码的界面设计。具体实现可以参考：一多开发实例（移动支付）收付款功能。
-  示意图 sm md lg 效果图 第三方支付页面使用断点控制不同的付款展示方式，在sm断点下以单独付款界面展示，在md、lg断点下以弹窗的方式展示。具体实现可以参考一多开发实例（移动支付）收付款功能。
-  示意图 sm md lg 效果图 使用栅格布局，控制卡片在不同设备上的span占用，在sm断点下span占用为12，在md断点下span占用为6，在lg断点下span占用为4，使其分别在sm、md、lg断点下显示1、2、3列。具体实现可以参考：一多开发实例（长视频）推荐视频。
-  示意图 sm md lg 效果图 区域编号 简介 实现方案 1 顶部栏 顶部栏空白区域使用Blank组件实现拉伸能力。同一多开发实例（长视频）搜索发现。 2 卡片集合 使用栅格布局，在sm、md、lg设备尺寸下分别显示1、2、3列。同一多开发实例（长视频）搜索页。 3 功能入口 使用栅格布局实现重复布局，在sm设备上显示4列，在md设备上显示7列，在lg设备上显示9列。同一多开发实例（社区评论）列表重复布局。 4 银行卡优惠 使用栅格布局实现重复布局，在sm设备上显示1列，在md设备上显示2列，在lg设备上显示3列。同一多开发实例（社区评论）列表重复布局。
-  示意图 sm md lg 效果图 添加银行卡功能可以使用半模态转场，默认情况下在sm设备下可以自动从底部进行弹窗，在sm断点以上不包括sm断点以居中弹窗方式显示内容。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151306.88009498310157947729296423205435:50001231000000:2800:1618D333FB2C80EA8344632A2B00AF6A345B4D743AB7D19C5C8425A07C0B1681.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151307.17111867191180182936327171504785:50001231000000:2800:66F800A4124238D32D7CD05C203CC0DE8B1C59CC7C0B88E19E6F8F504DC748DE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151307.61293961138141265851557230901722:50001231000000:2800:5B0051C1BD8D127B9828490D07CB95DC94865A6A6500F8F1366397ED0D54A356.png)
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151307.69371189422120007194348908007723:50001231000000:2800:7067DDB9CC3FD396FA9E7C1743F95F559A50D81B546F794611A4B81BEF02166B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151307.06848972474241794520339439507161:50001231000000:2800:F9BC6637EA1BC11DEA51CD3E8E0EE0DE1D3487457231628107332EC2E478753F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151307.58101812871267917289705318979898:50001231000000:2800:47F6A90BD889900603A72D158E5CD80ED14BC73770D3F1E4D42B11B027517E8D.png)
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151307.21066094784653495479305467273235:50001231000000:2800:2296EF310CB4B67E39CC263B3E3E5EE58BCF9F8BE3803986A61405C8C50BA6BE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151307.56580671180564352853017644548653:50001231000000:2800:EA79BD7516C5D2D8E6F4F62E302CF1EDD2D9E359968729AB35F27CE53F8ED80E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151308.51497818210480142867221677020556:50001231000000:2800:A527D8DF03C1BC6BF600E7B8852C5BF421B83028E35BCFA1B051DE4209EF35B1.png)
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151308.51236453239063021999015958815293:50001231000000:2800:9A44DAC92A392A2F8872AA54176C99AF051F22F6A5C2B2E5F546B4A245044730.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151308.62923961907666197239046275558381:50001231000000:2800:2BC5A14582C052DAD667C18AE3D1F6DB3E94ABA43902B07DF247F8F85CE5A674.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151308.51043512661163972671155556945799:50001231000000:2800:7BE826E58919A13A6ADA0B8A35075C46B835D56900C4F959F460F4FA75FC633E.png)
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151308.76527097268459355213377426024747:50001231000000:2800:EA09248461C7AEAE8F969364A8C71D2F35B008885AD37033E3CA23EA672D1855.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151308.35925133381579226100604047452975:50001231000000:2800:565B7ECADF86747BF5855BC8A07E5B707BB3C66C9361D31CC8531B10F99ECDD8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151308.94310923454602881258442910726383:50001231000000:2800:6533BED2BB8919BA1EF5EEA6C090DCF9184FA0491411A4307D1DE220502EE523.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部栏  | 顶部栏空白区域使用Blank组件实现拉伸能力。同一多开发实例（长视频）搜索发现。  |
| 2  | 卡片集合  | 使用栅格布局，在sm、md、lg设备尺寸下分别显示1、2、3列。同一多开发实例（长视频）搜索页。  |
| 3  | 功能入口  | 使用栅格布局实现重复布局，在sm设备上显示4列，在md设备上显示7列，在lg设备上显示9列。同一多开发实例（社区评论）列表重复布局。  |
| 4  | 银行卡优惠  | 使用栅格布局实现重复布局，在sm设备上显示1列，在md设备上显示2列，在lg设备上显示3列。同一多开发实例（社区评论）列表重复布局。  |
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151309.82046995701075983103875108962251:50001231000000:2800:2B4D9658DEC3AFC032CA43E223A01E8CBA1170F9ACEC1E898909640A5EEC1940.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151309.50332902202239547039817084929211:50001231000000:2800:AB6D79C715CE6CC7FC42340150B99874BD020E03383E5FF759C93AC8CD0B91CA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151309.63145450767253246991202651152298:50001231000000:2800:170ADBAC0FEB1209858A3F11AB1F64D0EE0E6C69C0634089AACE4A8509A16F55.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-music-app-overview
爬取时间: 2025-05-01 08:34:37
来源: Huawei Developer
概述
本文将介绍如何将“一次开发，多端部署”应用到音乐播放器的实际开发过程中。音乐播放器是现在较为流行的大众娱乐应用，本文用作示例的音乐应用主要展示播放页在手机、折叠屏、平板和PC/2in1四种产品形态上的“一次开发，多端部署”，在保障基本用户体验的同时，根据不同产品形态特性，适配相应的浏览和交互功能。下文将以架构设计、UX设计和页面开发三个章节来介绍“一多”音乐播放器在开发过程中的最佳实践。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。下文将详细介绍它们在“一多”开发实践中如何使用。
架构设计
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计的逻辑设计。
UX设计
音乐应用以播放页为重点进行介绍。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151309.72399901580655467389191790430029:50001231000000:2800:3EAD95D6E44C6EFE848A69403DD55866C4D5C28D73D97FC5A9FE7A451586A060.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151309.57101314859803171556044535469758:50001231000000:2800:D95E8E00EBA7B5709CBD512F0821A6167AC0F6CCC2228DF49BE902604531DF98.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151309.78555802569743873604760121426082:50001231000000:2800:D453FCA4B3FC49EB52BCC1F79C5D47C6761F2D4FCA7A09E7B6649F0AC084F74C.png)
页面开发
本章介绍音乐应用如何使用“一多”的布局能力，完成页面层级的一套页面、多端适配。下文将以音乐播放器的播放页为例，一一介绍具体实现方案，帮助开发者快速实现音乐应用的“一多”开发。
播放页
播放页是音乐应用最主要的功能页面，主要用于播放音乐。播放页最终在三种设备上的显示效果图如下：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
示意图
sm
md
lg
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151309.91370421894460188938625584864035:50001231000000:2800:7D370747FD2A2AF2EF8F89181CF1B2C7BF39603B60189D9EDE4F7CCC89F2A8B0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151309.49614924692019074945557049652571:50001231000000:2800:F7ADAF60174B2C93DD0E926CC1B291469A982C84C0795B8E7FE4DEC72A3CC5B0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.54906947370372754116962408062453:50001231000000:2800:4978065411B0471CE6BE1395C6C06ED870D33EBE25B8382CA1276FAA2EEA9C74.png)
-  区域编号 简介 实现方案 1 标题区 Row组件的justifyContent属性设置为FlexAlign.SpaceBetween实现均分能力，代码可参考一多开发实例（长视频）。 2 专辑封面 Image组件设置aspectRatio属性为1使图片宽高相等。 3 歌曲信息 Column组件沿垂直方向布局展示两行文本。 4 播控区域 使用Slider组件实现进度条。 5 歌词区域 Canvas结合动画实现歌词滚动效果。 6 桌面歌词按钮 Image组件显示歌词图片。
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 标题区  | Row组件的justifyContent属性设置为FlexAlign.SpaceBetween实现均分能力，代码可参考一多开发实例（长视频）。  |
| 2  | 专辑封面  | Image组件设置aspectRatio属性为1使图片宽高相等。  |
| 3  | 歌曲信息  | Column组件沿垂直方向布局展示两行文本。  |
| 4  | 播控区域  | 使用Slider组件实现进度条。  |
| 5  | 歌词区域  | Canvas结合动画实现歌词滚动效果。  |
| 6  | 桌面歌词按钮  | Image组件显示歌词图片。  |
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-travel-accommodation
爬取时间: 2025-05-01 08:34:51
来源: Huawei Developer
概述
本文从目前流行的垂类市场中，选择旅行订票垂类作为典型案例详细介绍“一多”在实际开发中的应用。本文选择首页、时间选择页、查询车票页、填写购票信息页、提交订单页等11个典型页面进行开发，遵从多设备的“差异性”、“一致性”、“灵活性”和“兼容性”，能够让开发者快速高效地掌握“一多”能力并实现旅行订票应用的相关功能。
旅行订票应用对垂类内的核心功能进行了独特设计：
当前系统的产品形态主要有手机、折叠屏、平板和PC/2in1四种，下文的具体实践也将围绕这几种产品形态展开，同时将分别从UX设计、架构设计、页面开发三个角度给出符合“一多”的参考样例，介绍“一多”旅行订票应用在开发过程中的最佳实践。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。下文将详细介绍它们在“一多”开发实践中如何使用。
UX设计
旅游住宿类的多设备响应式设计指南，点击访问。
架构设计
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计的逻辑设计。
页面开发
本章介绍旅行订票应用中如何使用”一多”的布局能力，完成页面层级的一套代码、多端适配。下文将从不同页面展开，介绍每个页面区域使用到具体的布局能力，帮助开发者从零到一进行旅行订票应用的开发。
首页
旅行订票应用首页主要发挥提供买票窗口的作用，解决用户订票以及预约酒店需求，所以首页内容都围绕这一功能设计。
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 底部/侧边栏 借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。 2 顶部控件 Select组件和TextInput组件中间增加Blank组件，实现拉伸能力。 3 火车票选择 使用Tabs组件实现拉伸能力。 4 功能入口 使用Swiper组件，设置在不同断点下的displayCount属性来实现自适应布局的延伸能力，代码可参考一多开发实例（长视频）。 5 热门资讯 利用响应式布局的栅格布局，结合Stack组件和Grid组件，设置aspectRatio属性实现缩放能力,代码可参考一多开发实例（长视频）。 6 酒店预订 利用响应式布局的栅格布局，结合Stack组件和Grid组件，设置aspectRatio属性实现缩放能力。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |    |    |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.29543732846579390036100663478041:50001231000000:2800:4840F9AB609DC9454955348574BD5FAA5C77B097E0B63DDF9AD1E2F13C831664.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.71540418921841840749960783506887:50001231000000:2800:09225512F9185B3F9BDDF741D4275E8E5D2A28B5AEC70F2B94E0CB74697F3706.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.30857658314788007331076093165031:50001231000000:2800:19E3318415037811907ABDCBBF68C200DFBF0E63C2C6154E29CFC405781E3A27.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 底部/侧边栏  | 借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。  |
| 2  | 顶部控件  | Select组件和TextInput组件中间增加Blank组件，实现拉伸能力。  |
| 3  | 火车票选择  | 使用Tabs组件实现拉伸能力。  |
| 4  | 功能入口  | 使用Swiper组件，设置在不同断点下的displayCount属性来实现自适应布局的延伸能力，代码可参考一多开发实例（长视频）。  |
| 5  | 热门资讯  | 利用响应式布局的栅格布局，结合Stack组件和Grid组件，设置aspectRatio属性实现缩放能力,代码可参考一多开发实例（长视频）。  |
| 6  | 酒店预订  | 利用响应式布局的栅格布局，结合Stack组件和Grid组件，设置aspectRatio属性实现缩放能力。  |
时间选择页
旅行订票时间选择页主要发挥提供选择出行时间的作用，帮助用户快速定位自己的出行日期，进一步帮助用户筛选自己出行日期的车票。
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 顶部控件 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。 2 日期 List组件实现延伸能力，layoutWeight实现拉伸能力。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |    |    |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.85763724192686305036488233485466:50001231000000:2800:1E3FD8BF94EF39DDAD57346A12ADD46C4EFB3E8BBC64CC0FD781173EBD157700.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.79429910826905340968678117883874:50001231000000:2800:2E4B39094F0127E229638B7B76AAA1D847CB110A627848E9F15C11EC39397D08.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.61034771912032877303089619731919:50001231000000:2800:50A7CA67AACB40AA6B373F48CE646C2C6C9022DF65E139F676AB404492A5B253.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部控件  | 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。  |
| 2  | 日期  | List组件实现延伸能力，layoutWeight实现拉伸能力。  |
查询车票页
旅行订票查询车票页主要发挥筛选车票的作用，解决用户通过日期，始发站筛选车票，以及通过出发时间、价格、总时长进行对车票的排序需求。
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 顶部控件 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。 2 日期选择 List组件实现延伸能力，layoutWeight实现拉伸能力。 3 车票列表 List组件实现延伸能力，layoutWeight实现拉伸能力。 4 功能入口 List组件实现延伸能力
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |    |    |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.51876874161606304721408505458316:50001231000000:2800:5B5DA698BC4E6D9465F67FA9084C58A1239EC7672B0BAFE5E929CA9DFE51C4F0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.42263661680143406760755753711015:50001231000000:2800:ACBA695D2369C9D762993DDC9199E332B387FB8BBF5E21C960F01A2D8EE02F25.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.83732357490356206471403457589561:50001231000000:2800:4F7B0C75767E7BE8FFFAFCA235348F94602B728AFF5D65C4A4F87186827F7F49.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部控件  | 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。  |
| 2  | 日期选择  | List组件实现延伸能力，layoutWeight实现拉伸能力。  |
| 3  | 车票列表  | List组件实现延伸能力，layoutWeight实现拉伸能力。  |
| 4  | 功能入口  | List组件实现延伸能力  |
查询车票上滑
旅行订票查询车票上滑的动效主要方便用户在上滑时，将一些筛选信息隐藏，方便用户沉浸式浏览，获取更多信息。
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 顶部控件 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。 2 车票列表 List组件实现延伸能力，layoutWeight实现拉伸能力。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |    |    |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.59166842053191546832888541212347:50001231000000:2800:6EE8AF2BC8FC6A677B0ADD2D89F1EDAB615ED82370C36F189A23D6D90AFB071B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.85191325411549910730155820492048:50001231000000:2800:D819C3C964BDB14DAC0B847E765A94DD3E906A59668426C360D3D9E7F8B0019F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.01298312862406895287357149812700:50001231000000:2800:BFCA312E7B2D906BA769326FC56BF408129027E7FF3573EB9F231727FF3768B2.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部控件  | 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。  |
| 2  | 车票列表  | List组件实现延伸能力，layoutWeight实现拉伸能力。  |
填写购票信息页
旅行订票填写购票信息页主要提供订单确认，选择乘车人的功能，方便用户购票。
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 顶部控件 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。 2 日期栏 使用拉伸能力实现日期与按钮的拉伸自适应。 3 火车票信息 使用栅格断点能力，设置在不同断点下实现拉伸能力。 4 选择乘车人 使用拉伸能力实现选择乘车人卡片拉伸自适应。 5 协议条款 使用栅格断点能力，设置在不同断点下顶部控件实现挪移布局。代码可参考一多开发实例（长视频）。 6 提交按钮 使用栅格断点能力，设置在不同断点下顶部控件实现挪移布局。代码可参考一多开发实例（长视频）。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |    |    |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151310.71271315316576623536730572393952:50001231000000:2800:01E0A3F35FF1797CA0D62032C49CB43E311489A048A6EC5F66D8142E542A4B4E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.80467755522264927662763542092019:50001231000000:2800:D4FFF8CF39E49E08E0AA76CB4395A6FDF3922ACF12DD7F5247692123066DDF5D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.61388760477265264130105381276147:50001231000000:2800:B8B8A9231BF72E9F2EC91AF0F6B5F10945861B4CFE4D0E55E4964D9F5415EA76.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部控件  | 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。  |
| 2  | 日期栏  | 使用拉伸能力实现日期与按钮的拉伸自适应。  |
| 3  | 火车票信息  | 使用栅格断点能力，设置在不同断点下实现拉伸能力。  |
| 4  | 选择乘车人  | 使用拉伸能力实现选择乘车人卡片拉伸自适应。  |
| 5  | 协议条款  | 使用栅格断点能力，设置在不同断点下顶部控件实现挪移布局。代码可参考一多开发实例（长视频）。  |
| 6  | 提交按钮  | 使用栅格断点能力，设置在不同断点下顶部控件实现挪移布局。代码可参考一多开发实例（长视频）。  |
提交订单页
旅行订票提交订单页主要提供车票信息的展示以及乘车人信息的展示，方便用户确认车票订单信息的正确性。
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 顶部控件 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。 2 日期栏 使用拉伸能力实现日期与按钮的拉伸自适应。 3 车票信息及乘车人信息 使用拉伸能力实现模块内部的拉伸自适应。 4 协议条款 使用栅格断点能力，设置在不同断点下实现挪移布局。 5 提交按钮 使用栅格断点能力，设置在不同断点下实现挪移布局。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.79025985175321530743674325508688:50001231000000:2800:E0892BBB0735928B43ECA287C335436B6978D0ACF3720A7CF5B97352FA13A66A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.64153398671065719850266104756253:50001231000000:2800:1FAAC8A36D0E38464D5207279F78F5313503E200509D693B17CB0138C532AB52.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.59532214882670373450109442762849:50001231000000:2800:61D404DFF1304CD419E71D67041AF6B95F0906FEC7095D2D0C68B94065759579.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部控件  | 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。  |
| 2  | 日期栏  | 使用拉伸能力实现日期与按钮的拉伸自适应。  |
| 3  | 车票信息及乘车人信息  | 使用拉伸能力实现模块内部的拉伸自适应。  |
| 4  | 协议条款  | 使用栅格断点能力，设置在不同断点下实现挪移布局。  |
| 5  | 提交按钮  | 使用栅格断点能力，设置在不同断点下实现挪移布局。  |
订单信息页
旅行订票订单信息页面主要展示订单服务信息，以及车票卡片信息，方便用户查看订单。
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 顶部控件 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。 2 火车票订单信息 List组件实现延伸能力，layoutWeight实现拉伸能力。 3 订单信息卡片 Tabs组件实现延伸能力。 4 服务列表 Grid组件配合Swiper组件，实现延伸能力与均分能力。 5 底部/侧边导航 使用栅格断点能力，设置在不同断点下Tabs组件的BarPosition属性。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.55699094316739811082647412464505:50001231000000:2800:227834BA019F79522D4CFED0FD06365DAF35FB7B5779D9C8A9AE4B30F4A0E430.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.23648544074648896391061736725639:50001231000000:2800:9B992D7122C04C5BCB9D9505DB4CBCB161E8CAEE54019CBDC30EA5B6E3C6B6C3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.00821496182245449681062548718482:50001231000000:2800:DE6A056B593144AF9851BCEBDFF252A7ADCA60845FB34D298764372A81641E4B.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部控件  | 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。  |
| 2  | 火车票订单信息  | List组件实现延伸能力，layoutWeight实现拉伸能力。  |
| 3  | 订单信息卡片  | Tabs组件实现延伸能力。  |
| 4  | 服务列表  | Grid组件配合Swiper组件，实现延伸能力与均分能力。  |
| 5  | 底部/侧边导航  | 使用栅格断点能力，设置在不同断点下Tabs组件的BarPosition属性。  |
已支付订单信息页
旅行订票应用已支付订单信息页主要帮助用户查看已支付订单，确定订单信息。
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 顶部控件 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。 2 订单类型选择 Tabs组件实现延伸能力。 3 订单信息列表 List组件实现延伸能力，layoutWeight实现拉伸能力。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.81002076886230222121212604025002:50001231000000:2800:87B35A14AAEADA524650F3551709F5285D29F46766D17BDE1B71547C0217E3E2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.97802959374815446542587819923481:50001231000000:2800:3938A5D339FCEBA7CE7B2C401A195587C012D76C7A5E7A622E8DCF3F3E693F55.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.74919142799336572457414574639215:50001231000000:2800:59D4174DF26B667CE45E2145886A9F65EE25E2517A479218C0B7B886B00C3F5D.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部控件  | 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。  |
| 2  | 订单类型选择  | Tabs组件实现延伸能力。  |
| 3  | 订单信息列表  | List组件实现延伸能力，layoutWeight实现拉伸能力。  |
酒店首页
旅行订票酒店首页主要提供酒店服务的作用，解决用户预约酒店需求。
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 顶部控件 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。 2 卡片banner Swiper组件实现，设置displayCount属性为auto。 3 酒店推荐 List组件实现延伸能力，layoutWeight实现拉伸能力。 4 底部/侧边导航 使用栅格断点能力，设置在不同断点下Tabs组件的BarPosition属性。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.30087301599010323375871662583973:50001231000000:2800:3CC89F21F81692B4D11CDD98B85E038BAF424599BF1CB32B89045E603CF16526.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.15466103507010770936534179537196:50001231000000:2800:F395870672045BDDDD8A2967A329E099A054330BD0997C72FBB41D4EA252E656.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.82051256957172506804990190896386:50001231000000:2800:6734FADB6E06219FDDC7441CF53C5A7070269AAACA78A37DD32764F0DAA5BAD9.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部控件  | 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。  |
| 2  | 卡片banner  | Swiper组件实现，设置displayCount属性为auto。  |
| 3  | 酒店推荐  | List组件实现延伸能力，layoutWeight实现拉伸能力。  |
| 4  | 底部/侧边导航  | 使用栅格断点能力，设置在不同断点下Tabs组件的BarPosition属性。  |
酒店排行榜页面
旅行订票酒店排行榜页主要展示酒店的排名，方便用户选择酒店。
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 顶部控件 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。 2 酒店类型选择 Tabs组件实现延伸能力。 3 酒店排行 List组件实现延伸能力，layoutWeight实现拉伸能力。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |    |    |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.74119142353496649404063114675505:50001231000000:2800:CF32D301AEF13E365F99DE8C7EAB1CD9D5B151C75C3B77C55B21A57B9C0D195D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.33354712574459676252725397654121:50001231000000:2800:4A4EADEE975731D23393F09832C793D376F6FAE834216401889CC6B880CE65A2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151311.87317304839925185559143749125471:50001231000000:2800:C2C8BAE1A44A26D9074A2775AE6D8107701BA6E24CEECB2905CB71C368E5351A.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部控件  | 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。  |
| 2  | 酒店类型选择  | Tabs组件实现延伸能力。  |
| 3  | 酒店排行  | List组件实现延伸能力，layoutWeight实现拉伸能力。  |
酒店详情页
旅行订票酒店详情页提供酒店的详细内容，包括预览图以及房间类型、价格等信息，方便用户对酒店房间的选择与预订。
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 顶部控件 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。 2 酒店卡片 使用GridCol栅格子组件实现挪移布局。 3 订房优惠 使用拉伸能力实现文字与按钮的拉伸自适应。 4 房间详情 List组件实现延伸能力，layoutWeight实现拉伸能力。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |    |    |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151312.98394153807447194325180127476350:50001231000000:2800:BE8C8CC93831C300DB12D082C4ED3F5CB0F7A91AE1DE362EABD65C05CB0D5CA5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151312.56469727312068417494866599554762:50001231000000:2800:0EB6EF61E89F1AC293EF75D50E64D2E6CD10169D255C4A5779F08A72C427D8D5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151312.54418309088554014166024921004555:50001231000000:2800:5E986C79C0DB264BFC102A72A168F860A6B0B584B846EF641A5DD65FE44E6F30.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部控件  | 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。  |
| 2  | 酒店卡片  | 使用GridCol栅格子组件实现挪移布局。  |
| 3  | 订房优惠  | 使用拉伸能力实现文字与按钮的拉伸自适应。  |
| 4  | 房间详情  | List组件实现延伸能力，layoutWeight实现拉伸能力。  |
顶部banner会根据不同设备类型展示不同的效果，手机会支持顶部banner上滑，图片展开的动效。折叠屏支持Scroll组件展示小图，点击后更换大图展示的效果。平板支持Swiper滑动切换视图的效果。
手机的上滑展开，下滑收起，主要使用了Scroll组件的onReachStart属性和onWillScroll属性。
折叠屏的实现，用Scroll组件支持滚动，小图的点击效果会改变大图的内容，点击后会将索引值作为参数传递，修改大图。
平板则使用Swiper组件，完成滚动切换视图的功能。
低价日历页
旅行订票低价日历页主要提供预订房间的能力，方便用户定位低价时段。
-  示意图 sm md lg 效果图
-  区域编号 简介 实现方案 1 顶部控件 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。 2 日期 List组件实现延伸能力，layoutWeight实现拉伸能力。
-  根据栅格布局监听断点变化，根据断点不同实现不同的响应效果。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 效果图  |    |    |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151312.24053883560731325734221801499692:50001231000000:2800:219FF59281A155E69E4C96C4D3A28D9CFE2E0A28945F8C41766C152C442DED77.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151312.11922269951565326852332957320540:50001231000000:2800:2A7FB9FD9CA83E22C3BBC8EAC1D8726AB864815C26F334A17277CF801527ED6B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151312.79260274925044086891301852290236:50001231000000:2800:F33CDF5935469314EC625D6FF906EBFB65CD55071820EC9691949808471F00D7.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部控件  | 使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。  |
| 2  | 日期  | List组件实现延伸能力，layoutWeight实现拉伸能力。  |
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-travel-navigation
爬取时间: 2025-05-01 08:35:06
来源: Huawei Developer
概述
本文从目前流行的垂类市场中，选择地图行业应用作为典型案例详细介绍“一多”在实际开发中的应用。地图行业核心功能为定位、导航和打车等。根据这些核心功能，本文选择首页、路线规划页、服务卡片页、实况窗页等作为典型页面进行开发，遵从多设备的“差异性”、“一致性”、“灵活性”和“兼容性”，能够让开发者快速高效地掌握“一多”能力并实现地图导航应用的相关功能。
地图类应用为了提升用户的使用体验，对垂类内的核心功能进行了独特设计：
当前系统的产品形态主要有手机和折叠屏，下文的具体实践也将围绕这两种产品形态展开，同时将分别从UX设计、架构设计、页面开发三个角度给出符合“一多”的参考样例，介绍“一多”地图导航应用在开发过程中的最佳实践。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。下文将详细介绍它们在“一多”开发实践中如何使用。
UX设计
出行导航类的多设备响应式设计指南，点击访问。
架构设计
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计的逻辑设计。
页面开发
本章介绍地图导航应用中如何使用“一多”的布局能力，完成页面层级的一套页面、多端适配。下文将从不同页面展开，介绍每个页面区域使用到的具体的布局能力，帮助开发者从0到1进行地图导航应用的开发。
阅读本章节前，读者需熟悉地图服务简介，并参考应用开发准备及配置AppGallery Connect开通相关服务。下文将详细介绍地图导航在“一多”开发实践中的页面开发。
首页
首页通常在地图上展示当前位置信息，并且提供搜索地点、查看地点详情等功能入口，便于用户操作。观察首页在不同设备上的UX设计图，可以进行如下设计：
-  sm md 效果图
-  区域编号 简介 实现方案 1 地图 使用MapComponent组件实现地图的展示，默认占满窗口，并设置窗口的沉浸式。 2 面板 使用Stack组件，在地图上层嵌套Column组件实现面板，并借助栅格布局监听断点变化，设置在不同断点下面板的不同形态。在sm断点下面板底部展示，在md断点下悬浮展示。并通过绑定拖动手势实现在宽屏设备上的居左或居右变换。 3 拖动区域 通过绑定拖动手势实现面板高度变换，当前支持三个档位变换调节。 4 搜索框 使用TextInput组件实现搜索框效果，通过onSubmit事件实现搜索功能。 5 功能选择 使用Grid组件实现均分能力，并在面板高度切换时，展示不同行数的功能。 6 页签 Tabs组件实现延伸能力，代码可参考一多开发实例（长视频）。
|    | sm  | md  |
| --- | --- | --- |
| 效果图  |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151312.48509148972468533451871650733538:50001231000000:2800:FB74B0BA7746E0BE55A122769E0711CD76DFEE9CDE54C1C928311DD2CE6F0AFD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151312.80228454243005259387756215342646:50001231000000:2800:CC7246620481B43F5151D7D78237A4CEA80AFAD2D60EB764E8798B8CE31FB908.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 地图  | 使用MapComponent组件实现地图的展示，默认占满窗口，并设置窗口的沉浸式。  |
| 2  | 面板  | 使用Stack组件，在地图上层嵌套Column组件实现面板，并借助栅格布局监听断点变化，设置在不同断点下面板的不同形态。在sm断点下面板底部展示，在md断点下悬浮展示。并通过绑定拖动手势实现在宽屏设备上的居左或居右变换。  |
| 3  | 拖动区域  | 通过绑定拖动手势实现面板高度变换，当前支持三个档位变换调节。  |
| 4  | 搜索框  | 使用TextInput组件实现搜索框效果，通过onSubmit事件实现搜索功能。  |
| 5  | 功能选择  | 使用Grid组件实现均分能力，并在面板高度切换时，展示不同行数的功能。  |
| 6  | 页签  | Tabs组件实现延伸能力，代码可参考一多开发实例（长视频）。  |
地点详情页
地点详情页展示用户所选地点的详细信息，并提供导航及路线规划入口。观察地点详情页在不同设备上的UX设计图，可以进行如下设计：
-  sm md 效果图
-  区域编号 简介 实现方案 1 图片轮播区 Swiper实现图片轮播切换。 2 景点信息 List组件实现延伸能力。
|    | sm  | md  |
| --- | --- | --- |
| 效果图  |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151312.58505706853052764649289070481589:50001231000000:2800:AAE323030918AB163C3883B18AB4364500640DDE26CEFC2AA96DDEAB9BE6F914.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151313.79750567269911922494491613115366:50001231000000:2800:2850219AAF5876E770C3FFD6937222476AC53F1CC6713B44E8CB4AB83DB35526.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 图片轮播区  | Swiper实现图片轮播切换。  |
| 2  | 景点信息  | List组件实现延伸能力。  |
搜索结果页
搜索结果页展示根据用户的输入内容得到的附近相关地点列表。观察搜索结果页在不同设备上的UX设计图，可以进行如下设计：
-  sm md 搜索结果列表-中档位面板效果 搜索结果列表-高档位面板效果
-  区域编号 简介 实现方案 1 搜索框 搜索内容后右侧按钮转变为取消，代码可参考一多开发实例（长视频）。 2 搜索结果列表 面板处于中档位时采用Swiper实现延伸能力，高档位时采用List组件实现延伸能力。
|    | sm  | md  |
| --- | --- | --- |
| 搜索结果列表-中档位面板效果  |   |   |
| 搜索结果列表-高档位面板效果  |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151313.91156735029341660471482631763769:50001231000000:2800:0A3E0A5F188761C17B9026266A0CA65B7BE44C27B7E2562714CE279F3DC545C1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151313.23077500309948596183446469927748:50001231000000:2800:B481F1FCABEB16585270E670995C34A66A60BA5A7E4E14062C89F59E390F7E30.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151313.08958938460321337990186182183795:50001231000000:2800:0B55364C920C4EA6D6119FE711D6789D17BB688D5083173ABDB92F376417403C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151313.52672514045866154728216481053921:50001231000000:2800:67871EA30FECE2592B1C3E80EF31189D0E1467C216CB298014938729C5210B71.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 搜索框  | 搜索内容后右侧按钮转变为取消，代码可参考一多开发实例（长视频）。  |
| 2  | 搜索结果列表  | 面板处于中档位时采用Swiper实现延伸能力，高档位时采用List组件实现延伸能力。  |
路线规划页
路线规划页默认通过驾车路线规划最多三条路线，并展示相关信息。观察路线规划页在不同设备上的UX设计图，可以进行如下设计：
-  sm md 路线搜索效果 路径规划结果
-  区域编号 简介 实现方案 1 输入区域 通过判断当前面板高度更换按钮及输入区域布局，Row组件配合layoutWeight实现拉伸能力，代码可参考一多开发实例（长视频）。 2 方案页签 Tabs组件实现延伸能力，代码可参考一多开发实例（长视频）。 3 常去地点信息 Column组件实现延伸能力。 4 路线规划结果 List组件实现延伸能力，并在不同面板高度时设置List的不同方向。
|    | sm  | md  |
| --- | --- | --- |
| 路线搜索效果  |    |    |
| 路径规划结果  |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151314.38997879009406735994934898564667:50001231000000:2800:83FDCED9EA950645C7C2E1B861088A15544134BE7D130BC54626804CC60626F7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151314.41876698346199397619583369789345:50001231000000:2800:B2DB9EE7A90CE49A2297142428658A6042DC86DA8BE3715EBB7A4210D39EB700.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151314.33107186775681229493024634111432:50001231000000:2800:AD82A0BD8C8739CA1560BC9B3FD9564E99846C7565C64671ECDEA0AFC7733FAB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151314.68102653117991644797478033511360:50001231000000:2800:D77A07DAE3231D487F334FB959ED898F46665C275FE046B6DD1C87A866D6EB12.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 输入区域  | 通过判断当前面板高度更换按钮及输入区域布局，Row组件配合layoutWeight实现拉伸能力，代码可参考一多开发实例（长视频）。  |
| 2  | 方案页签  | Tabs组件实现延伸能力，代码可参考一多开发实例（长视频）。  |
| 3  | 常去地点信息  | Column组件实现延伸能力。  |
| 4  | 路线规划结果  | List组件实现延伸能力，并在不同面板高度时设置List的不同方向。  |
导航页
导航页提供实时导航能力，并展示路况信息及剩余路线信息。观察导航页在不同设备上的UX设计图，可以进行如下设计：
-  sm md 效果图
-  区域编号 简介 实现方案 1 当前路径信息 栅格布局监听断点变化实现挪移布局。 2 剩余路线信息 Row组件设置justifyContent属性为SpaceBetween实现自适应占满。
|    | sm  | md  |
| --- | --- | --- |
| 效果图  |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151314.53146160158947422235921038299950:50001231000000:2800:0CB06EB4461ACACDF8CBEF991443C9F09DA3765FBEE7627E47EEE3CBD303694C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151314.03638314450412993410738360019301:50001231000000:2800:4F96805BF439A137311CBF5B98A9DEF020F6F069C4EEFE75244E7F4167969B44.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 当前路径信息  | 栅格布局监听断点变化实现挪移布局。  |
| 2  | 剩余路线信息  | Row组件设置justifyContent属性为SpaceBetween实现自适应占满。  |
打车页
打车页展示当前可选择车辆类型及价格等信息，并提供打车能力。观察打车页在不同设备上的UX设计图，可以进行如下设计：
-  sm md 效果图
-  区域编号 简介 实现方案 1 车辆信息 List组件实现延伸能力。 2 打车 Row组件实现拉伸效果。
|    | sm  | md  |
| --- | --- | --- |
| 效果图  |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151315.21883647100610092975329172226926:50001231000000:2800:085118A10B7999D56107A5FEA45BA2F2647B4B1ECB95D98952EFCBA88841EAEA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151315.87700372436444275497935190636993:50001231000000:2800:827FD1CDA1583B20B6DF379F6BE6D625EFE27CE606041C3993575EF5619D065B.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 车辆信息  | List组件实现延伸能力。  |
| 2  | 打车  | Row组件实现拉伸效果。  |
服务卡片页
阅读本章节前，读者需熟悉ArkTS卡片相关模块以及ArkTS卡片开发指导。下面将详细介绍ArkTS卡片在“一多”开发中的实践。
服务卡片页采用静态卡片展示应用常用功能、地点及路况等信息。观察服务卡片页在不同设备上的UX设计图，可以进行如下设计：
-  sm md 效果图
-  区域编号 简介 实现方案 1 静态卡片 在多端均采用2*4的八宫格静态卡片。可参考指南在入口模块创建一个静态卡片，并配置相关参数。
|    | sm  | md  |
| --- | --- | --- |
| 效果图  |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151315.63686910627352753461698997280640:50001231000000:2800:4270B5DB3BD293F01AFB1E9EA5F4FDB44222C69E0ACB13DF4C06590C7109861E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151315.72737884513732355739564916910845:50001231000000:2800:759BA177882E7EF3D57C5F2600F142C176F1C586ED1BF525B8E1F1D9F88E2A51.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 静态卡片  | 在多端均采用2*4的八宫格静态卡片。可参考指南在入口模块创建一个静态卡片，并配置相关参数。  |
-  在入口模块创建静态卡片后，添加卡片显示内容，通过FormLink进行静态卡片内部和提供方应用间的交互。
实况窗页
阅读本章节前，读者需熟悉实况窗服务简介及实况窗支持对接的场景，并根据读者的开发场景开通相关权益。下面将详细介绍实况窗在“一多”开发中的实践。
实况窗页实现卡片及胶囊两种形态，分别展示在锁屏、通知中心及状态栏。观察实况窗页在不同设备上的UX设计图，可以进行如下设计：
-  通知中心 状态栏 实况胶囊 效果图
-  区域编号 简介 实现方案 1 卡片形态 实况窗默认支持多端效果，本应用实现效果为强调文本模板，实况窗拉起时展示在通知中心、和锁屏界面，点击实况胶囊后展示在状态栏。 2 胶囊形态 实况胶囊默认支持多端效果，本应用实现效果为文本胶囊。
|    | 通知中心  | 状态栏  | 实况胶囊  |
| --- | --- | --- | --- |
| 效果图  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151316.30178316287696975930382421913624:50001231000000:2800:D8375F982170142A0C24737E46B6D79570525B05A031C1920715AFDFEE7A4A8A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151316.16167203234759091022739887458448:50001231000000:2800:695FFF36BE3781693A69494C50466C1C8DEB7E17DDE07526AE627BA2AA14BAC3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151316.43567901448247560339512777052678:50001231000000:2800:9869C74EEA3E8E1153E9B88C6BD9181C379DD587E1BC51FD662F2F4E2FDA8FE7.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 卡片形态  | 实况窗默认支持多端效果，本应用实现效果为强调文本模板，实况窗拉起时展示在通知中心、和锁屏界面，点击实况胶囊后展示在状态栏。  |
| 2  | 胶囊形态  | 实况胶囊默认支持多端效果，本应用实现效果为文本胶囊。  |
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-convenient-life
爬取时间: 2025-05-01 08:35:42
来源: Huawei Developer
概述
本文从目前流行的垂类市场中，选择便捷生活类应用作为典型案例详细介绍“一多”在实际开发中的应用。一多便捷生活应用包含首页展示、商品展示、图文详情、视频浏览等功能。根据这些核心功能，本文选择美食列表页、店铺页、商品详情页、图文详情页、视频页等作为典型页面进行开发，遵从多设备的“差异性”、“一致性”、“灵活性”和“兼容性”，能够让开发者快速高效地掌握“一多”能力并实现便捷生活应用的相关功能。
便捷生活类应用为了向用户展示更多的商品选择，对垂类内的核心功能进行了独特设计：
当前系统的产品形态主要有手机、折叠屏、平板和PC/2in1四种，下文的具体实践也将围绕这几种产品形态展开，同时将分别从UX设计、架构设计、页面开发三个角度给出符合“一多”的参考样例，介绍“一多”便捷生活应用在开发过程中的最佳实践。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。下文将详细介绍它们在“一多”开发实践中如何使用。
UX设计
便捷生活类的多设备响应式设计指南，点击访问。
架构设计
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计的逻辑设计。
页面开发
本章介绍便捷生活应用中如何使用“一多”的布局能力，完成页面层级的一套页面、多端适配。下文将从不同页面展开，介绍每个页面区域使用到具体的布局能力，帮助开发者从0到1进行便捷生活应用的开发。
布局能力
本节由不同页面展开，介绍每个页面区域使用到的具体布局能力，帮助开发者从零到一进行便捷生活应用的开发。
首页
首页通常有入口图标和商品卡片等丰富的页面跳转入口和商品推荐信息，帮助解决用户浏览及挑选商品的核心需求。观察首页在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 首页 首页的5个基础区域介绍及实现方案如下表所示： 编号 简介 实现方案 1 顶部功能区 使用拉伸能力结合断点控制元素尺寸，在lg断点采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。 2 菜单列表 使用网格容器，借助栅格组件能力监听断点变化改变列数，设置aspectRatio属性实现缩放能力。同一多开发实例（长视频）推荐视频。 3 秒杀列表 List组件实现延伸能力，代码可参考一多开发实例（长视频）视频简介。 4 商品列表 使用WaterFlow容器，实现一列到多列的切换。在sm断点下依赖断点控制设置WaterFlow的columsTemplate属性为2，在md断点下设置columsTemplate为3，在lg断点下设置columsTemplate为4。具体实现开发者可以参考：一多开发实例（社区评论）动态卡片。 5 菜单导航栏 借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 首页  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151316.28786062557955592433378541223086:50001231000000:2800:2E8D7C63E913F63FB64EB5F83BDB0332D9A712C8042D3BAA067ADAE2AE2FE3B3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151316.96814351597413151180967669954190:50001231000000:2800:E1402520544CF4FC14D0DD95237D7228F05F2FC2F279D5FA53C1BF8D9B51B879.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151317.22635137690474101009895791583905:50001231000000:2800:03615E6CC7E3414A16123315F18EAD358FDB6EBD66097CA9F84D765F7CEC2E81.png)
| 编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部功能区  | 使用拉伸能力结合断点控制元素尺寸，在lg断点采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。  |
| 2  | 菜单列表  | 使用网格容器，借助栅格组件能力监听断点变化改变列数，设置aspectRatio属性实现缩放能力。同一多开发实例（长视频）推荐视频。  |
| 3  | 秒杀列表  | List组件实现延伸能力，代码可参考一多开发实例（长视频）视频简介。  |
| 4  | 商品列表  | 使用WaterFlow容器，实现一列到多列的切换。在sm断点下依赖断点控制设置WaterFlow的columsTemplate属性为2，在md断点下设置columsTemplate为3，在lg断点下设置columsTemplate为4。具体实现开发者可以参考：一多开发实例（社区评论）动态卡片。  |
| 5  | 菜单导航栏  | 借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。  |
美食列表
美食列表页显示推荐美食，在大屏上增多列数的布局以增加用户信息量获取。观察美食列表页在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 美食列表页 美食列表页的3个基础区域介绍及实现方案如下表所示： 编号 简介 实现方案 1 顶部功能区 使用拉伸能力结合断点控制元素尺寸，在lg断点采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。 2 菜单列表 List组件实现延伸能力，代码可参考一多开发实例（长视频）视频简介。 3 美食列表 响应式布局的栅格布局，设置aspectRatio属性实现缩放能力，代码可参考一多开发实例（长视频）。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 美食列表页  |   |   |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151317.78894000365189758739948197429894:50001231000000:2800:D6712C85061120B267895AF361987948A4CA5D6D3B965F7C13202EDFB598AF97.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151317.96093010687333029540853571057089:50001231000000:2800:57AA3B350C61900BA2207E42C23B76E529049E53BB4ED7D7EDB8135C87BDCAE7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151317.82183858334994170219488521536612:50001231000000:2800:6C4B73F34051C0E14EA586BE1F9B3A843A8B18B38C5FBB44DA8D128F57D4EB9B.png)
| 编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部功能区  | 使用拉伸能力结合断点控制元素尺寸，在lg断点采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。  |
| 2  | 菜单列表  | List组件实现延伸能力，代码可参考一多开发实例（长视频）视频简介。  |
| 3  | 美食列表  | 响应式布局的栅格布局，设置aspectRatio属性实现缩放能力，代码可参考一多开发实例（长视频）。  |
店铺页
店铺页展示店铺信息和其所售卖的所有商品，可以在侧边栏查看并且快速切换，用户也可以选择商品规格，在不同产品中弹窗以不同形态显示，贴合操作习惯。观察店铺页在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 店铺页 店铺页-侧边栏 店铺页-选规格 店铺页的4个基础区域介绍及实现方案如下表所示： 编号 简介 实现方案 1 店铺信息展示区 在父元素上使用Flex组件实现挪移布局和visibility属性实现样式切换。 2 菜单列表 使用Tabs组件嵌套Scroll组件实现顶部页签嵌套列表。 3 购物车 使用拉伸能力结合断点控制元素尺寸，在lg断点采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。 4 选规格弹窗 使用BindSheet属性和PopUp属性实现不同设备上的弹窗显示。
-  使用Flex属性的direction属性根据断点切换上下或者左右布局，使用visibility属性根据断点切换显隐。
-  使用Tabs嵌套Scroll组件实现菜单页签切换。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 店铺页  |   |   |   |
| 店铺页-侧边栏  |    |   |   |
| 店铺页-选规格  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151317.81864310216297857157768113164770:50001231000000:2800:B1BAFBA017C72E969D3EE57AC4E69CA78372500F283EE609D1B6A6E397BCB950.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151317.10553696062309302673922046724704:50001231000000:2800:43B9D2C9BAA6EE34991AFE7AF699C72D6F003E8757C185C598124322D60DAA21.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151318.00773107724757931304933396960808:50001231000000:2800:47339B2D8183796C90D4D41A5A6EB7527D76187BF5B4D3F4C60D79A7E66C58C1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151318.99447431727930746630508568585780:50001231000000:2800:56643ED727891650083BFAE5CA118C7313A4A110B3BEB6DA1A26AEF0E47574FE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151318.60715040723610286508459071479627:50001231000000:2800:CFF6E2D4208982D9516F72FEB7BDF53F11EBF6B3570383AA6FA802DA1D07FE9E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151318.25700422309739500108826856450862:50001231000000:2800:1001C878FB759D64342E83243306B564920126CBD8CBCC96A093F8476AB5DC6C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151319.34404182060036197123325263568876:50001231000000:2800:0FF86EEB4E0F06E19E345D52E8294C97D1E33F3F4DCB7D01394ED842E0581E58.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151319.57093386515147789842650354886098:50001231000000:2800:5EFC2E890A400A9CF33FEE27100111015F6DAA046B1FFEBA31C18E37970FAB93.png)
| 编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 店铺信息展示区  | 在父元素上使用Flex组件实现挪移布局和visibility属性实现样式切换。  |
| 2  | 菜单列表  | 使用Tabs组件嵌套Scroll组件实现顶部页签嵌套列表。  |
| 3  | 购物车  | 使用拉伸能力结合断点控制元素尺寸，在lg断点采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。  |
| 4  | 选规格弹窗  | 使用BindSheet属性和PopUp属性实现不同设备上的弹窗显示。  |
商品详情
商品详情页展示商品具体信息，加入了可以通过上下滑动查看完整商品缩略图的交互设计，商品全貌展现更加直观，也可以使用侧边栏查看商品，交互更加便捷。观察商品详情页在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 商品详情页 商品详情页-侧边栏 商品详情页的3个基础区域介绍及实现方案如下表所示： 编号 简介 实现方案 1 商品信息展示区 通过绑定onScrollFrameBegin监听滑动改变图片高度实现上下滑动查看完整缩略图的交互效果。 2 商品信息区 Column组件实现，内部使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。 3 购物车 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 商品详情页  |   |   |   |
| 商品详情页-侧边栏  |    |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151319.73006706465086768250945381942038:50001231000000:2800:E4A00E2938CF074E7A25FB6D8EE4DF3A12B351501453354609A3647160073A51.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151319.34802176526908541000922157195876:50001231000000:2800:3E3F7AD8D48882CB5E4FBA7DABFF28FA55B9E8230798709975866AEE5E9096F9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151319.25092539337146846676159457708889:50001231000000:2800:46B4C2A6FE8D31A7AF80C9AFA5FAE2B99FB3737139F212E44421BC20DEC6811A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151320.75478729522703237070446917748828:50001231000000:2800:D4EF923F4C7C995DB226E954AAD543C0FDCB1DD5461765658363EAAFC74F4086.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151320.10632005010609017214853494461902:50001231000000:2800:7D6F2E760A50154A867237086952C6376DB68B485F910A5C521A5D5F94CD7360.png)
| 编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 商品信息展示区  | 通过绑定onScrollFrameBegin监听滑动改变图片高度实现上下滑动查看完整缩略图的交互效果。  |
| 2  | 商品信息区  | Column组件实现，内部使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。  |
| 3  | 购物车  | 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。  |
微详情页
微详情页显示推荐的商品信息，在不同设备上以不同列数呈现，增加页面呈现的信息量。观察微详情页在折叠屏上的UX设计图，可以进行如下设计：
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 微详情页  |   |   |   |
示意图
sm
md
lg
微详情页
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151320.08537277971670972807053996958163:50001231000000:2800:F578D663BE4515C3B2D4BBDECB7F20715FE7EDE6C99899B2B03A508BC2881C05.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151320.79347317191861793647710953704735:50001231000000:2800:F396F61A5A2E3247C56081D5893406D25B306AD219046FEAA110DB15C090B089.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151320.01078790764808852327492962613833:50001231000000:2800:3659A8B42466ACC5EF39D82986D624AB820C708B834CDE82EDD447C2CFFCA1B9.png)
| 简介  | 实现方案  |
| --- | --- |
| 微详情页  | 使用WaterFlow容器，实现一列到多列的切换。在sm断点下依赖断点控制设置WaterFlow的columsTemplate属性为1，在md断点下设置columsTemplate为2，在lg断点下设置columsTemplate为3。具体实现开发者可以参考：一多开发实例（社区评论）动态卡片。  |
简介
实现方案
微详情页
使用WaterFlow容器，实现一列到多列的切换。在sm断点下依赖断点控制设置WaterFlow的columsTemplate属性为1，在md断点下设置columsTemplate为2，在lg断点下设置columsTemplate为3。具体实现开发者可以参考：一多开发实例（社区评论）动态卡片。
电影列表页
电影列表页展示推荐的电影信息，我们为lg规格的屏幕提供了三种设计范式，读者可自行选择参考。观察电影列表页页在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 电影列表页-范式1 电影列表页-范式2 电影列表页-范式3 电影列表页的3个基础区域介绍及实现方案如下表所示 编号 简介 实现方案 1 顶部功能区 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。 2 即将上映 List组件实现延伸能力，通过listDirection调整方向，延伸能力代码可参考一多开发实例（长视频）视频简介。 3 正在热映 使用WaterFlow容器，实现一列到多列的切换。在sm断点下依赖断点控制设置WaterFlow的columsTemplate属性为1，在md断点下设置columsTemplate为2，在lg断点下设置columsTemplate为3。具体实现开发者可以参考：一多开发实例（社区评论）动态卡片。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 电影列表页-范式1  |   |   |   |
| 电影列表页-范式2  |    |    |   |
| 电影列表页-范式3  |    |    |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151321.62691474308088842611446847496834:50001231000000:2800:FDFB1BD598437A89948D63BF8243E406B7ED7B8D03BB6A2DE754A58676B11F8D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151321.05115141938215331993739743459488:50001231000000:2800:6FDDA2DC3BB2ED10DD8A1B3C6E85AE8E6FDEE71794528A3789FDE26B2269C5A3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151321.79705991635389961378846453952697:50001231000000:2800:70CF7233D3EDD10AA406E6BD4728A30396DD996038A06BCCF0EBAD45D656B191.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151322.44180676236229878374857610285634:50001231000000:2800:9AD408F8088E68A5DDD0E7859FD3473DC6110ECC24AE7584C14027885A24111B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151322.91793549320578573719040806219528:50001231000000:2800:D9107DC5D1317824BA210495FE50A22A31ABD4D059D0F8FFF6D2E53291D77E9C.png)
| 编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部功能区  | 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。  |
| 2  | 即将上映  | List组件实现延伸能力，通过listDirection调整方向，延伸能力代码可参考一多开发实例（长视频）视频简介。  |
| 3  | 正在热映  | 使用WaterFlow容器，实现一列到多列的切换。在sm断点下依赖断点控制设置WaterFlow的columsTemplate属性为1，在md断点下设置columsTemplate为2，在lg断点下设置columsTemplate为3。具体实现开发者可以参考：一多开发实例（社区评论）动态卡片。  |
电影简介页
电影简介页展示电影的具体信息，在lg规格的屏幕上采用了左右布局，以充分利用空间。观察电影简介页在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 电影简介页 电影简介页的3个基础区域介绍及实现方案如下表所示 编号 简介 实现方案 1 顶部功能区 使用拉伸能力结合断点控制元素尺寸。同一多开发实例（长视频）搜索发现。 2 电影信息 利用响应式布局的栅格布局，使用Grid组件实现挪移布局，设置aspectRatio属性实现缩放能力。同一多开发实例（长视频）每日佳片 3 电影详情区 使用tabs嵌套column，不同模块标题使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现，内容使用List组件实现延伸能力，代码可参考一多开发实例（长视频）视频简介。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 电影简介页  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151322.70911327739352840403690638517361:50001231000000:2800:1E07A1CFE292DCCFF66D028F4CDF578B2C75B155F16A09F94A5B90AE30E188F8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151322.79676049020311523633643212561261:50001231000000:2800:1789474A4FC9C28B3D102057331CEFC828B02463E99BA9D8D0BAA98A26FDA405.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151322.16024658947219332920763752896110:50001231000000:2800:68409803C21924B9DD1AABE87207044AC618D0A5FFE4D7706396F7448D7D35F5.png)
| 编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部功能区  | 使用拉伸能力结合断点控制元素尺寸。同一多开发实例（长视频）搜索发现。  |
| 2  | 电影信息  | 利用响应式布局的栅格布局，使用Grid组件实现挪移布局，设置aspectRatio属性实现缩放能力。同一多开发实例（长视频）每日佳片  |
| 3  | 电影详情区  | 使用tabs嵌套column，不同模块标题使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现，内容使用List组件实现延伸能力，代码可参考一多开发实例（长视频）视频简介。  |
选影院页
选影院页展示影院列表以供用户选择，并提供电影海报预览方便切换。观察选影院页在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 选影院页-范式1 选影院页的3个基础区域介绍及实现方案如下表所示 编号 简介 实现方案 1 顶部功能区 使用拉伸能力结合断点控制元素尺寸。同一多开发实例（长视频）搜索发现。 2 电影海报 Swiper组件，指定displayCount属性实现占比能力，设置aspectRatio属性实现缩放能力，代码可参考一多开发实例（长视频）。 3 电影列表 使用Tabs组件+List组件，实现重复布局。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 选影院页-范式1  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151323.76313978131400303378732528975375:50001231000000:2800:21D5D533F423317B1BD3391E5EB99DBF579EAAD151FF976FB3D04A45C7A47B01.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151323.08696331169006324322568513406435:50001231000000:2800:3E00DA7F5C70F76E013668E57097566819A0D53EF8A1C8F103AA0FC37711CC6D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151323.70172411527561941453602539830103:50001231000000:2800:C07E1579DACB0862342BC721273444ED04947B86AD5349BB24E1CAA35430B706.png)
| 编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部功能区  | 使用拉伸能力结合断点控制元素尺寸。同一多开发实例（长视频）搜索发现。  |
| 2  | 电影海报  | Swiper组件，指定displayCount属性实现占比能力，设置aspectRatio属性实现缩放能力，代码可参考一多开发实例（长视频）。  |
| 3  | 电影列表  | 使用Tabs组件+List组件，实现重复布局。  |
首页-推荐页
首页-推荐页展示向用户推荐的图文简略信息，在不同设备上以不同列数呈现，增加信息量呈现，观察首页-推荐页在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 首页-推荐页 推荐页的3个基础区域介绍及实现方案如下表所示 编号 简介 实现方案 1 顶部功能区 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。 2 推荐展示区 使用WaterFlow容器，实现一列到多列的切换。在sm断点下依赖断点控制设置WaterFlow的columsTemplate属性为2，在md断点下设置columsTemplate为3，在lg断点下设置columsTemplate为4。具体实现开发者可以参考：一多开发实例（社区评论）动态卡片。 3 菜单导航栏 借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。 首页-关注页 首页-关注页展示用户的关注列表和以及其最新发布的图文信息，我们提供了三种范式，读者可自行选择参考。观察首页-关注页在不同设备上的UX设计图，可以进行如下设计： 示意图 sm md lg 首页-关注页-范式1 首页-关注页-范式2 首页-关注页-范式3 首页的4个基础区域介绍及实现方案如下表所示 编号 简介 实现方案 1 顶部功能区 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。 2 关注列表 List组件实现延伸能力，代码可参考一多开发实例（长视频）视频简介。 3 关注详情 使用List组件实现重复布局。 4 菜单导航栏 借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。
-  示意图 sm md lg 首页-关注页-范式1 首页-关注页-范式2 首页-关注页-范式3 首页的4个基础区域介绍及实现方案如下表所示 编号 简介 实现方案 1 顶部功能区 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。 2 关注列表 List组件实现延伸能力，代码可参考一多开发实例（长视频）视频简介。 3 关注详情 使用List组件实现重复布局。 4 菜单导航栏 借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 首页-推荐页  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151323.48876278570208918182327533927279:50001231000000:2800:EDF4A9A8B612E2594CCF096634E159232280EC3051700A23A7EE23A6949C8BB9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151323.84143617623978916405799880996828:50001231000000:2800:4208D887E374807554440F454E3A6E30583661ED6AD8AB943495F97E1B322726.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151323.52390076493855180779559464333533:50001231000000:2800:26EFFD36D5BA5994EAAA3BAAE32F0D4010B8D68B6647575609A5D4F6B9F08561.png)
| 编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部功能区  | 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。  |
| 2  | 推荐展示区  | 使用WaterFlow容器，实现一列到多列的切换。在sm断点下依赖断点控制设置WaterFlow的columsTemplate属性为2，在md断点下设置columsTemplate为3，在lg断点下设置columsTemplate为4。具体实现开发者可以参考：一多开发实例（社区评论）动态卡片。  |
| 3  | 菜单导航栏  | 借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。  |
-  示意图 sm md lg 首页-关注页-范式1 首页-关注页-范式2 首页-关注页-范式3 首页的4个基础区域介绍及实现方案如下表所示 编号 简介 实现方案 1 顶部功能区 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。 2 关注列表 List组件实现延伸能力，代码可参考一多开发实例（长视频）视频简介。 3 关注详情 使用List组件实现重复布局。 4 菜单导航栏 借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 首页-关注页-范式1  |   |    |   |
| 首页-关注页-范式2  |   |   |   |
| 首页-关注页-范式3  |   |   |    |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151324.45892233272286044193689660922063:50001231000000:2800:B02BB3D326D88885B66AFC936ED4D42A77CC65BFC752E0FF02ABCECB8D80A0EF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151324.00105917666837157046790808496321:50001231000000:2800:73C3B6775F401454F856B2DE6164472CA21E2F865586A5B20A6C5ECFE46C6D4A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151324.90051462631390856293674906309829:50001231000000:2800:958FAD2AE06A058F261A8A6B0A09B80982BC196954EC774B1DE0F0FC592E652D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151324.57768909225491047278004384816646:50001231000000:2800:06390256B2AE4BED9BACA441D869FA14F888AAC799D7FAA24AFF6EABD9E02898.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151325.28993510331519819898473075799099:50001231000000:2800:FFD2C3328DAEF50B49509F30C037C1D5B17000197BCF9585818277E24C28504E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151325.06489899757103101405822519974179:50001231000000:2800:0F66E29564C3239357F7CA0F6D86F3F52176BE2B490F6FBB2F8D772682BF18C0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151325.76333690627408813274573204683904:50001231000000:2800:E5600F0B8F52A6E38C760FE26DDBFBA8BBCE0D456D5A27EED7AE513BB29FD8DA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151325.47967912449324542145825401103586:50001231000000:2800:1754F4A1A5C950A77DA185289157B2001F3FA68297D57E94F242D26BE1B3D391.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151325.44429267269583938673654585443030:50001231000000:2800:2C5FE707236DC6023907BC27B7D3C5605520642A184B7F121500F42B6C561982.png)
| 编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部功能区  | 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。  |
| 2  | 关注列表  | List组件实现延伸能力，代码可参考一多开发实例（长视频）视频简介。  |
| 3  | 关注详情  | 使用List组件实现重复布局。  |
| 4  | 菜单导航栏  | 借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。  |
短视频详情页
短视频详情页进行视频播放，并相关提供功能按钮，提供边看视频边看评论的页面设计。观察短视频页在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 短视频详情页-范例1 短视频详情页-范例2 侧边栏-评论 短视频详情页-标签页信息栏 短视频详情页的4个基础区域介绍及实现方案如下表所示 编号 简介 实现方案 1 短视频展示区 使用Stack容器组件实现Video组件和Text组件、Image组件的堆叠效果，其中Video组件使用.align(Alignment.Center)实现居中，参考一多开发实例（长视频）的全屏播放页章节。 2 菜单导航栏 借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。 3 视频评论区 使用List组件实现重复布局，在sm规格使用bindSheet实现半模态，在md和lg规格下使用Row组件呈左右布局。 4 标签页信息栏 使用List组件实现重复布局。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 短视频详情页-范例1  |   |   |   |
| 短视频详情页-范例2  |   |   |   |
| 侧边栏-评论  |   |   |   |
| 短视频详情页-标签页信息栏  |    |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151326.76593975089242611448031412994627:50001231000000:2800:B8CBDB573397CB5CA544F4669275C065BEB795ED28FBF686C52008AA0F92EEDF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151326.02488975329206694344893887275976:50001231000000:2800:5F73BBFBB32B5CA19C788EAE8273AF37943A96572339828D6EA3AD53DC85163D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151326.76621430564657876805058546285538:50001231000000:2800:E24F10D5CFE01FC531C22AEB3B1294A617271007C1CCF9894C22BAA6552C1091.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151326.17804442718740527229911781629405:50001231000000:2800:2BBE5B203CDE22D1D8CBFC05D980E62F8522981633D2FFA58ABABFCCCF43030F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151326.79327935995066782478694085149095:50001231000000:2800:38FF02C883BEB6D12872F18E4DB8A6E4698F321E86A6414C64B7713196B8D69E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151327.56790959577794657292008886430603:50001231000000:2800:86C5D635D1DCA08528EFF21327087E5353B74095D6A1246955A4FE220963F33F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151327.39301250270602402142169318292139:50001231000000:2800:7B0282BFBCECEDA15EB11F22A7C8FFDB3D22298F6B5795C8ECC20BA00BE91B73.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151327.21808627489173571458605570849952:50001231000000:2800:29E7B9431BCBB07DB4E328FC907BFF571C48584F52FB58F1E63F78B49FB80E0F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151327.61901523971803069364395149962727:50001231000000:2800:845A32D1F08A792938A60239BB783323ECCCB45B750363E8EB3CAA9AFA7C7405.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151328.53375506427339126579362424897879:50001231000000:2800:865598EF1AE00BC4470B34974E002FF53F8C3A700EBEB84DFEFE718BC31EF9B1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151328.93505045789514116956560394753188:50001231000000:2800:4746D2AAADD9F0EEAACDD4FDB8AB8D10F8E25FF39DD33EAF96FC3CEC46445D1F.png)
| 编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 短视频展示区  | 使用Stack容器组件实现Video组件和Text组件、Image组件的堆叠效果，其中Video组件使用.align(Alignment.Center)实现居中，参考一多开发实例（长视频）的全屏播放页章节。  |
| 2  | 菜单导航栏  | 借助栅格布局监听断点变化改变位置，代码可参考一多开发实例（长视频）。  |
| 3  | 视频评论区  | 使用List组件实现重复布局，在sm规格使用bindSheet实现半模态，在md和lg规格下使用Row组件呈左右布局。  |
| 4  | 标签页信息栏  | 使用List组件实现重复布局。  |
直播页
直播页进行直播播放并展示用户评论，背景使用图片模糊带给用户更沉浸的观看体验。观察直播页在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 直播页 直播页的3个基础区域介绍及实现方案如下表所示 编号 简介 实现方案 1 直播区 使用Stack容器组件实现Video组件和Text组件、Image组件的堆叠效果，其中Video组件使用.align(Alignment.Center)实现居中，背景模糊效果参考下方代码。 2 评论区 使用List组件实现重复布局。 3 评论输入区域 使用TextInput组件实现。
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 直播页  |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151328.06948783737011113493574318334420:50001231000000:2800:A9F271F5BB305102F415264CC2312AA75310E2C89137E101DBA35860FAA64775.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151328.78833643566905724978054780591744:50001231000000:2800:7271A4900F593D23196CA39604463A2392A8C82138025E8B4B24CC590632C035.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151328.44917689337718611906475672739936:50001231000000:2800:A36B620C80DF0C385F8596D1AF3D4E3055CE05F2F3D8984081E3AF33BD50D58B.png)
| 编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 直播区  | 使用Stack容器组件实现Video组件和Text组件、Image组件的堆叠效果，其中Video组件使用.align(Alignment.Center)实现居中，背景模糊效果参考下方代码。  |
| 2  | 评论区  | 使用List组件实现重复布局。  |
| 3  | 评论输入区域  | 使用TextInput组件实现。  |
图文详情页
图文详情页展示商品具体信息。观察图文详情页在不同设备上的UX设计图，可以进行如下设计：
-  示意图 sm md lg 图文详情页 图文详情页-上图下文 侧边栏-商品详情 侧边栏-个人主页 图文详情页的7个基础区域介绍及实现方案如下表所示 编号 简介 实现方案 1 顶部功能区 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。 2 图片展示区 Swiper组件，设置aspectRatio属性实现缩放能力，代码可参考一多开发实例（长视频）。 3 文章详情 使用column组件展示文章详情。 4 底部功能区 使用拉伸能力结合断点控制元素尺寸。同一多开发实例（长视频）搜索发现。 5 评论区 使用TextInput组件实现。 6 商品详情 使用column组件，设置aspectRatio属性实现缩放能力。 7 个人主页 使用List组件实现重复布局。
-  范式一 范式二 范式三
-  点击缩放 双指滑动缩放 上滑沉浸式浏览
| 示意图  | sm  | md  | lg  |
| --- | --- | --- | --- |
| 图文详情页  |   |   |   |
| 图文详情页-上图下文  |    |   |    |
| 侧边栏-商品详情  |    |   |   |
| 侧边栏-个人主页  |    |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151329.54648480833921146911688812993545:50001231000000:2800:FB2E22D650C8F60AA01BC1A329AE92D1054A6084224E4A0B6BB6AE49B4270604.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151329.20301679779933438831517304832407:50001231000000:2800:20E38BBE357C1742EBB02FD59694D66C3191476096BC232185024001D0907C84.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151329.35497106026655356135214334484066:50001231000000:2800:4F5F3E9DFF6133D4BA625E81EE97BB792E002EA03E00D156D9E7D479701865C0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151329.35568399882933513996974599320258:50001231000000:2800:F2812C7296B734E80CFFEC8DA3A4F730B4A7A9C4FEDD1F978B648DD53FE87207.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151330.40620164073076245880532011721887:50001231000000:2800:37532576DDE007AC04F0843D77A949CB0C9E5B6CC0D10D8EAB151B9A2AE6A5E6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151330.20106252568050130212368391056219:50001231000000:2800:9FE54AAFF591F5631A9D5150DF297CFBC4E4A856BCDB1FCAA1FA90313E829FEE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151330.95559898706859277134988638679538:50001231000000:2800:87212D36A6F3DEDCA91C31A2ECBDE50069E17205FE0BDF3919C9EA1E077242F5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151330.69631623567203873849621498554964:50001231000000:2800:9C420DAB12818AF0C0DE0382A777D46F97595D13F040C369740D4487E339CEC7.png)
| 编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 顶部功能区  | 使用拉伸能力结合断点控制元素尺寸，同时采用Blank组件填充中间空白区域。同一多开发实例（长视频）搜索发现。  |
| 2  | 图片展示区  | Swiper组件，设置aspectRatio属性实现缩放能力，代码可参考一多开发实例（长视频）。  |
| 3  | 文章详情  | 使用column组件展示文章详情。  |
| 4  | 底部功能区  | 使用拉伸能力结合断点控制元素尺寸。同一多开发实例（长视频）搜索发现。  |
| 5  | 评论区  | 使用TextInput组件实现。  |
| 6  | 商品详情  | 使用column组件，设置aspectRatio属性实现缩放能力。  |
| 7  | 个人主页  | 使用List组件实现重复布局。  |
| 范式一  | 范式二  | 范式三  |
| --- | --- | --- |
|   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151331.13716638219653791585427352182330:50001231000000:2800:0298AFF16AFDBD94245C5AEA6AB90DDAB58AE2D2CA391B71BB775DC3504C7F8C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151331.62703908662537737338504649520627:50001231000000:2800:7B1D69919B10198C0655CCDEA8436CBC137E4641D01FB866FEECBF13E6779F7C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151331.61989194595154666007131176880248:50001231000000:2800:EDBAAC5C49DD1DF9A260C1C5EA4EC51C0788034A07010AEF90D9748A8F416CAE.png)
| 点击缩放  | 双指滑动缩放  | 上滑沉浸式浏览  |
| --- | --- | --- |
|   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151331.69442619471555242497316660466249:50001231000000:2800:437D26088AB254E0101E7DB2347DBCCC80A017A6789AFA89E62D32841BAD21AD.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151331.94334870232182822136601343102462:50001231000000:2800:61F163700C1729943315D817BF4EDA5DDF6C66195F822227DFAA31007D22BD77.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151331.18095940233961226407190525974739:50001231000000:2800:239DC677C42032E679EDDFF3EE443B3602D9DDDB0C99BFA27AFD0432B29FEA83.gif)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/multi-business-office
爬取时间: 2025-05-01 08:35:59
来源: Huawei Developer
概述
本文从目前流行的垂类市场中，选择商务办公类应用作为典型案例，详细介绍“一多”在实际开发中的应用。主要包含入口、备忘录、笔记汇总、笔记、日历等典型页面。
-  侧边栏显隐：监听断点变化，设置SideBarContainer组件的SideBarContainerType属性或改变showSideBar属性参数，实现侧边栏根据不同断点显示隐藏及显示类型的变化。 分栏布局：分栏布局通过Navigation实现，监听断点变化，根据不同断点或状态改变Navigation的mode属性，实现单双栏切换的效果。 宫格卡片：用网格布局Grid组件，在不同断点下将父组件分为不同列数，来实现自适应布局的占比能力。
-  入口-多实例：监听断点变化，设置List组件的listDirection属性在断点为sm时为Vertical纵向展示，其余断点为Horizontal横向展示，实现入口组件根据不同断点横纵排列不同的效果。使用startAbility实现点击子组件时拉起新实例的效果。 备忘录-侧边栏显隐：监听断点变化，设置SideBarContainer组件的SideBarContainerType属性或改变showSideBar属性参数，实现侧边栏根据不同断点显示隐藏及显示类型的变化。 日历-navigation的单双栏变化：监听断点变化，根据不同断点或状态改变Navigation的mode属性，实现单双栏效果切换的效果。
下面的章节将分别从UX设计、架构设计、页面开发三个角度给出推荐的参考样例，介绍“一多”商务办公类应用在开发过程中的最佳实践。
阅读本文前，读者需熟悉方舟开发框架（ArkUI框架）和页面开发的“一多”能力。下文将详细介绍它们在“一多”开发实践中如何使用。
UX设计
本示例中的商务办公应用包含入口、备忘录、笔记汇总、笔记、日历等页面。以平板端为例，应用的基本业务逻辑如下所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151332.37837543449895287399952226992041:50001231000000:2800:721DFC9D9D9C18A7A6679277D0CA31DC3F46EAD0EFF0728F0176A1213F13DBCC.png)
架构设计
HarmonyOS的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。更多详细请参考指南分层架构设计的逻辑设计。
页面开发
本章介绍商务办公类应用中如何使用”一多”的布局能力，完成页面层级的一套页面、多端适配。下文将从不同页面展开，介绍每个页面区域使用到具体的布局能力，帮助开发者从零到一进行商务办公类应用的开发。
入口
-  示意图 sm md lg PC/2in1 效果图
-  区域编号 简介 实现方案 1 标题 Text组件实现。 2 多实例入口 设置List组件的listDirection属性在断点为sm时为Vertical纵向展示，其余断点为Horizontal横向展示，同时点击子组件使用startAbility拉起新实例。
| 示意图  | sm  | md  | lg  | PC/2in1  |
| --- | --- | --- | --- | --- |
| 效果图  |   |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151333.37281176327192277250615068540848:50001231000000:2800:BAA64AE167A3B15FE89F0C5276718EEB82C0170ABA381E66998A38044CA4DB3B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151334.14155151437580692181948807989673:50001231000000:2800:F3269A4BDA14804F18A456251B63A39DBFD1FFF503C2AF4819771369CCC74003.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151334.55690419553444842913692562994469:50001231000000:2800:B012FDD63B993C3F0218010304F10C3D42BB1D0812FF9E730690DEA1064812DB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151334.88872799081831647777397352589231:50001231000000:2800:6493EBC42ED2C93D4C6B7DA1559B802E2496E06CC58627570B013F6B2D212A50.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 标题  | Text组件实现。  |
| 2  | 多实例入口  | 设置List组件的listDirection属性在断点为sm时为Vertical纵向展示，其余断点为Horizontal横向展示，同时点击子组件使用startAbility拉起新实例。  |
备忘录
-  示意图 sm md lg PC/2in1 效果图
-  区域编号 简介 实现方案 1 侧边栏 监听断点变化，设置SideBarContainer组件的SideBarContainerType属性在断点为lg时为Embed，其余断点为Overlay，实现侧边栏根据不同断点显示类型变化的效果，代码可参考侧边栏显示类型变化。 2 侧边栏显隐控件 监听断点变化，设置SideBarContainer组件的showSideBar属性，实现侧边栏根据不同断点显示隐藏的效果，代码可参考侧边栏显隐变化。 3 navigation导航页 通过Navigation路由栈NavPathStack，将NavDestination页面信息入栈，实现NavDestination页面的展示。 4 navigation内容页 NavDestination页面信息。 5 navigation内容页-控制按钮 给控制按钮添加onClick事件，通过自定义变量notesNavMode改变Navigation中mode属性的值，控制单双栏的变化，并通过自定义变量sideBarStatus改变SideBarContainer组件中showSideBar属性的值，控制侧边栏的显隐，实现内容页全屏展示或退出全屏的效果，代码可参考navigation内容页-控制按钮。 6 按钮组件 监听断点变化，不同断点展示的位置不同。
| 示意图  | sm  | md  | lg  | PC/2in1  |
| --- | --- | --- | --- | --- |
| 效果图  |   |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151334.47681584007480214543621587776129:50001231000000:2800:166D4BF50B93581E5E02E38510C28820B352E1B7D24BE10C2921B1505612D1C4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151334.29303557885001783404197801146037:50001231000000:2800:651368A876166936D4588B96C2F931AD4A5E8BD6C37B16F6CD8D760836DD4545.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151335.99838859167805456658189529244349:50001231000000:2800:9841BA733A11AC89C26181E2B9F1A59C4AD15ACA410AEA30A38C85CF2FF2BE2B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151335.36600603789216943015310674557288:50001231000000:2800:D01CB2196835C30FEAF4E27A6E2B264B6CC237F4E80E3A85AEFCF204A0870C8F.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 侧边栏  | 监听断点变化，设置SideBarContainer组件的SideBarContainerType属性在断点为lg时为Embed，其余断点为Overlay，实现侧边栏根据不同断点显示类型变化的效果，代码可参考侧边栏显示类型变化。  |
| 2  | 侧边栏显隐控件  | 监听断点变化，设置SideBarContainer组件的showSideBar属性，实现侧边栏根据不同断点显示隐藏的效果，代码可参考侧边栏显隐变化。  |
| 3  | navigation导航页  | 通过Navigation路由栈NavPathStack，将NavDestination页面信息入栈，实现NavDestination页面的展示。  |
| 4  | navigation内容页  | NavDestination页面信息。  |
| 5  | navigation内容页-控制按钮  | 给控制按钮添加onClick事件，通过自定义变量notesNavMode改变Navigation中mode属性的值，控制单双栏的变化，并通过自定义变量sideBarStatus改变SideBarContainer组件中showSideBar属性的值，控制侧边栏的显隐，实现内容页全屏展示或退出全屏的效果，代码可参考navigation内容页-控制按钮。  |
| 6  | 按钮组件  | 监听断点变化，不同断点展示的位置不同。  |
-  监听断点变化，同时设置SideBarContainer组件的SideBarContainerType属性在断点为lg时为Embed，其余断点为Overlay，实现侧边栏根据不同断点显示类型变化的效果。
-  监听断点变化，同时设置SideBarContainer组件的showSideBar属性，实现侧边栏根据不同断点显示隐藏的效果。
笔记汇总
-  示意图 sm md lg PC/2in1 效果图
-  区域编号 简介 实现方案 1 侧边栏 监听断点变化，设置SideBarContainer组件的SideBarContainerType属性在断点为lg时为Embed，其余断点为Overlay，实现侧边栏根据不同断点显示类型变化的效果。 2 侧边栏显隐控件 监听断点变化，设置SideBarContainer组件的showSideBar属性，实现侧边栏根据不同断点显示隐藏的效果。 3 标题栏 空白部分使用Blank组件填充，实现拉伸能力。PC/2in1设备需设置setWindowDecorVisible接口，隐藏标题栏后避让系统绘制的右上角三键区域。 4 笔记汇总 使用网格布局Grid组件，在不同断点下将父组件分为不同列数，来实现自适应布局的占比能力，可参考一多开发实例（长视频）
| 示意图  | sm  | md  | lg  | PC/2in1  |
| --- | --- | --- | --- | --- |
| 效果图  |   |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151335.34934002610307510113125824347600:50001231000000:2800:86D95E9E47173C26F824EC3594A4867EDD7A52AECA312BA940AD6A8A049D0137.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151335.00166399185281878978953188171775:50001231000000:2800:D6828FA6B57D151A05F9F482E3F350316C01B5B7BB05E5890BABAE77D21493AB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151336.52479789454263852246954335945006:50001231000000:2800:D774973230CB4EA011E999583EC750E826F0B65FCF21E186007F1DE0D55C5603.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151336.09299220685542956927766127059317:50001231000000:2800:CD817B74A7025D526950D36CD2E54A1C504E1A471D8F7A49F71C104E74F36529.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 侧边栏  | 监听断点变化，设置SideBarContainer组件的SideBarContainerType属性在断点为lg时为Embed，其余断点为Overlay，实现侧边栏根据不同断点显示类型变化的效果。  |
| 2  | 侧边栏显隐控件  | 监听断点变化，设置SideBarContainer组件的showSideBar属性，实现侧边栏根据不同断点显示隐藏的效果。  |
| 3  | 标题栏  | 空白部分使用Blank组件填充，实现拉伸能力。PC/2in1设备需设置setWindowDecorVisible接口，隐藏标题栏后避让系统绘制的右上角三键区域。  |
| 4  | 笔记汇总  | 使用网格布局Grid组件，在不同断点下将父组件分为不同列数，来实现自适应布局的占比能力，可参考一多开发实例（长视频）  |
笔记
-  示意图 sm md lg PC/2in1 效果图
-  区域编号 简介 实现方案 1 标题栏 点击加号，增加Tabs标签及TabContent，实现多实例的效果，空白部分使用Blank组件填充，实现拉伸能力。 2 编辑按钮 监听断点变化，改变List组件下子组件的间隔宽度，同时设置固定宽度，当List组件下的Tabs内容超过设定宽度时隐藏部分Tabs，延伸显示更多。 3 笔记内容 Tabs标签下的TabContent。
| 示意图  | sm  | md  | lg  | PC/2in1  |
| --- | --- | --- | --- | --- |
| 效果图  |   |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151336.32911047032154026448540941177773:50001231000000:2800:472F6DA00A8702BE07F1F228555AEFE15EE7A59773CC5B44020660C650811C74.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151336.20704148808078945951186649797522:50001231000000:2800:4F682EE15ABDA0CAB7FD41E6C6ECDFD83157A30B5F45C49E866F8B52BB695365.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151336.54801777684679643846980356988294:50001231000000:2800:F225CBADB016113940197615D765F78A6B27472CC5FAEFE1D581F6DEAAEB5735.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151337.11935472679916667295473645712330:50001231000000:2800:7EDDE4CFB7ED03170A258F09CD0B3EC9DFBE1525A2438D5BE7E847D432F17C05.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 标题栏  | 点击加号，增加Tabs标签及TabContent，实现多实例的效果，空白部分使用Blank组件填充，实现拉伸能力。  |
| 2  | 编辑按钮  | 监听断点变化，改变List组件下子组件的间隔宽度，同时设置固定宽度，当List组件下的Tabs内容超过设定宽度时隐藏部分Tabs，延伸显示更多。  |
| 3  | 笔记内容  | Tabs标签下的TabContent。  |
日历
-  示意图 sm md lg PC/2in1 效果图
-  区域编号 简介 实现方案 1 侧边栏 设置SideBarContainer组件的SideBarContainerType属性在断点为lg时为Embed，其余断点为Overlay，实现侧边栏根据不同断点显示类型变化的效果。 2 侧边栏显隐控件 设置SideBarContainer组件的showSideBar属性，实现侧边栏根据不同断点显示隐藏的效果。 3 标题栏 空白部分使用Blank组件填充，实现拉伸能力。PC/2in1设备需设置setWindowDecorVisible接口，隐藏标题栏后避让系统绘制的右上角三键区域。 4 navigation导航页 使用Grid组件设置columnsTemplate和rowsTemplate属性，实现五行七列的自适应布局。 通过Navigation路由栈NavPathStack，将NavDestination页面信息入栈，并监听断点变化，根据不同断点或状态改变Navigation的mode属性，实现单双栏切换及navigation内容页显隐的效果。 5 navigation内容页 NavDestination页面信息。 6 navigation控制按钮 给控制按钮添加onClick事件，用来改变Navigation的mode属性，实现单双栏切换及控制navigation内容页显隐的效果，代码可参考单双栏切换。
| 示意图  | sm  | md  | lg  | PC/2in1  |
| --- | --- | --- | --- | --- |
| 效果图  |   |   |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151337.22652301283166630978634529110724:50001231000000:2800:5A240AEFDAD6EB26B2005613711AE4E5FCE2D4008337BC5EFF5F3D2C6DC1CC04.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151337.93655524521348582934554757730640:50001231000000:2800:A78EE3D1FAF7B35A3C741718A188585CC3F506A12A9B978B4B5AE8287E747A19.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151337.01192961217753081131770231715937:50001231000000:2800:1BD6EDDE1D0A4C3D74337C9FA2DB4520CC3DADD7233CC3F3942C1ABED361D2F2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151338.65782211775986652408733655105040:50001231000000:2800:45DE33C0F773E48CFF4BE8C6A3481D2FBF1A727C1C1D6CE22A39C0080DA6D474.png)
| 区域编号  | 简介  | 实现方案  |
| --- | --- | --- |
| 1  | 侧边栏  | 设置SideBarContainer组件的SideBarContainerType属性在断点为lg时为Embed，其余断点为Overlay，实现侧边栏根据不同断点显示类型变化的效果。  |
| 2  | 侧边栏显隐控件  | 设置SideBarContainer组件的showSideBar属性，实现侧边栏根据不同断点显示隐藏的效果。  |
| 3  | 标题栏  | 空白部分使用Blank组件填充，实现拉伸能力。PC/2in1设备需设置setWindowDecorVisible接口，隐藏标题栏后避让系统绘制的右上角三键区域。  |
| 4  | navigation导航页  | 使用Grid组件设置columnsTemplate和rowsTemplate属性，实现五行七列的自适应布局。 通过Navigation路由栈NavPathStack，将NavDestination页面信息入栈，并监听断点变化，根据不同断点或状态改变Navigation的mode属性，实现单双栏切换及navigation内容页显隐的效果。  |
| 5  | navigation内容页  | NavDestination页面信息。  |
| 6  | navigation控制按钮  | 给控制按钮添加onClick事件，用来改变Navigation的mode属性，实现单双栏切换及控制navigation内容页显隐的效果，代码可参考单双栏切换。  |
-  监听断点的变化，通过控制按钮的点击事件，用来改变Navigation的mode属性的变化，实现单双栏切换及navigation内容页显隐的效果，同时监听navigationMode的变化，来控制页面是否跳转。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-free-flow
爬取时间: 2025-05-01 08:36:13
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-application-connection
爬取时间: 2025-05-01 08:36:25
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-application-connection-release
爬取时间: 2025-05-01 08:36:40
来源: Huawei Developer
概述
在办公，创作以及社区交友等类型的应用中，内容发布是用户互动与交流的核心环节，它允许用户创作并分享包含图片、文字等多媒体元素的信息，从而增强用户间的连接与互动。随着手机，平板，PC/2in1等多设备的普及，用户在不同设备间无缝切换和接续编辑内容的需求日益增强。本文介绍如何通过应用接续能力（在不同设备中快速切换）提升内容发布的便利性。
具体功能实现如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151338.88037858428804064605509618796181:50001231000000:2800:4BC0A5604FEB81562BE6128ED6EE341FEA2FA84CABD0BB5B8575776A8CAE37BD.gif)
约束与限制
需同时满足以下条件，才能使用该功能：
-  条件允许时，建议双端设备接入同一个局域网，可提升数据传输的速度。
实现原理
场景分析
在以上提到的内容发布的应用接续场景中，可以分为三个步骤：
场景核心在于应用接续的过程中如何传递数据。对于文字信息可使用分布式数据对象保存，对于图片可以拷贝到分布式文件目录下，使用分布式数据资产作为分布式数据对象的根属性保存。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151338.02806693283490695844260767797879:50001231000000:2800:F76F95ACD669BE4F93A056B044498CA46BA235C933F9EE051B55E557EEB465D9.png)
关键技术
将发起接续的设备称为源端设备（场景中的A设备），接收数据的设备称为对端设备（场景中的B设备），运作机制如图，接续过程底层依赖分布式框架和软总线，开发者不必关注只需要启用接续、保存数据和恢复数据，具体运作机制可参考：运作机制。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151338.56125463421876210736683268560471:50001231000000:2800:284816CECB6DDD34A261B1B1FBCC23C37D46CBA99111EA426632115C1E628977.png)
开发实现
启用应用接续能力
在module.json5文件的abilities中，将continuable标签配置为“true”，表示该UIAbility可被迁移。配置为false的UIAbility将被系统识别为无法迁移且该配置默认值为false。
基础数据&文件资产迁移
对于图片、文档等文件类数据，可以转化成ArrayBuffer类型，保存在分布式文件目录下。示例代码如下：
使用分布式数据对象，需要在源端onContinue()接口中进行数据保存。在源端UIAbility的onContinue()接口中创建分布式数据对象并保存数据，执行流程如下：
示例代码如下：
```typescript
// entry/src/main/ets/entryability/EntryAbility.ets
async onContinue(wantParam: Record<string, Object | undefined>): Promise<AbilityConstant.OnContinueResult> {
wantParam.imageUriArray = JSON.stringify(AppStorage.get<Array<PixelMap>>('imageUriArray'));
try {
// 生成数据对象组网id，激活分布式数据对象
let sessionId: string = distributedDataObject.genSessionId();
wantParam.distributedSessionId = sessionId;
let imageUriArray = AppStorage.get<Array<ImageInfo>>('imageUriArray');
let assets: commonType.Assets = [];
if (imageUriArray) {
for (let i = 0; i < imageUriArray.length; i++) {
let append = imageUriArray[i];
let attachment: commonType.Asset = this.getAssetInfo(append);
assets.push(attachment);
}
}
let contentInfo: ContentInfo = new ContentInfo(
AppStorage.get('mainTitle'),
AppStorage.get('textContent'),
AppStorage.get('imageUriArray'),
AppStorage.get('isShowLocalInfo'),
AppStorage.get('isAddLocalInfo'),
AppStorage.get('selectLocalInfo'),
assets
);
let source = contentInfo.flatAssets();
this.distributedObject = distributedDataObject.create(this.context, source);
this.distributedObject.setSessionId(sessionId);
await this.distributedObject.save(wantParam.targetDevice as string).catch((err: BusinessError) => {
hilog.info(0x0000, '[EntryAbility]', `Failed to save. Code: ${err.code}, message: ${err.message}`);
});
} catch (error) {
hilog.error(0x0000, '[EntryAbility]', 'distributedDataObject failed', `code ${(error as BusinessError).code}`);
}
return AbilityConstant.OnContinueResult.AGREE;
}
```
基础数据&文件资产恢复
在对端设备UIAbility的onCreate()/onNewWant()中调用restoreDistributedObject()方法，通过加入与源端一致的分布式数据对象组网进行数据恢复。
示例代码如下：
```typescript
// entry/src/main/ets/entryability/EntryAbility.ets
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
hilog.info(0x0000, '[EntryAbility]', 'Ability onCreate');
this.restoreDistributedObject(want, launchParam);
}
onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {
hilog.info(0x0000, '[EntryAbility]', 'Ability onNewWant');
this.restoreDistributedObject(want, launchParam);
}
/**
* 对端设备接收数据
* @param want
* @param launchParam
* @returns
*/
async restoreDistributedObject(want: Want, launchParam: AbilityConstant.LaunchParam): Promise<void> {
if (launchParam.launchReason !== AbilityConstant.LaunchReason.CONTINUATION) {
return;
}
let mailInfo: ContentInfo = new ContentInfo(undefined, undefined, [], undefined, undefined, undefined, undefined);
this.distributedObject = distributedDataObject.create(this.context, mailInfo);
// 添加数据变更监听
this.distributedObject.on('status',
(sessionId: string, networkId: string, status: 'online' | 'offline' | 'restored') => {
hilog.info(0x0000, '[EntryAbility]', `status changed, sessionId: ${sessionId}`);
hilog.info(0x0000, '[EntryAbility]', `status changed, status: ${status}`);
hilog.info(0x0000, '[EntryAbility]', `status changed, networkId: ${networkId}`);
if (status === 'restored') {
if (!this.distributedObject) {
return;
}
// 收到迁移恢复的状态时，可以从分布式数据对象中读取数据
AppStorage.setOrCreate('mainTitle', this.distributedObject['mainTitle']);
AppStorage.setOrCreate('textContent', this.distributedObject['textContent']);
AppStorage.setOrCreate('isShowLocalInfo', this.distributedObject['isShowLocalInfo']);
AppStorage.setOrCreate('isAddLocalInfo', this.distributedObject['isAddLocalInfo']);
AppStorage.setOrCreate('selectLocalInfo', this.distributedObject['selectLocalInfo']);
AppStorage.setOrCreate('attachments', this.distributedObject['attachments']);
let attachments = this.distributedObject['attachments'] as commonType.Assets;
hilog.info(0x0000, '[EntryAbility]', `attachments: ${JSON.stringify(this.distributedObject['attachments'])}`);
for (const attachment of attachments) {
this.fileCopy(attachment);
}
AppStorage.setOrCreate<Array<ImageInfo>>('imageUriArray', this.imageUriArray);
}
});
let sessionId: string = want.parameters?.distributedSessionId as string;
// 激活分布式数据对象
this.distributedObject.setSessionId(sessionId);
this.context.restoreWindowStage(new LocalStorage());
}
```
接续过来的图片，需要从分布式文件目录路径下读取所需的文件，经处理后，转化成需要的数据类型。示例代码如下：
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-application-continue-progess
爬取时间: 2025-05-01 08:36:53
来源: Huawei Developer
概述
在日常生活中，需要借助应用接续功能来处理设备切换的状况。本文针对长列表进度、媒体播放进度以及Web浏览进度这三个场景，实现了浏览进度接续问题的有效解决，为用户在实现无缝的设备切换与浏览体验延续提供了可靠的方案支撑，使得用户在设备切换时能够轻松接续之前的浏览进度，极大地提升了使用的便利性与连贯性，实现真正的无缝接续。
长列表进度接续：可以让用户从上次浏览的位置继续，无需重新从列表顶部开始滑动查找，精准定位到之前离开的条目附近，节省用户的时间和操作成本，提升在长列表内容浏览时的便利性和体验感。
媒体播放进度接续：能够从源设备暂停的位置继续播放视频，视频的播放进度、画面质量、音频设置等都保持一致，为用户提供不间断的观影体验，无论是在线视频平台的剧集、电影，还是本地存储的视频文件，都能实现流畅的接续播放。
Web浏览进度接续：能够迅速定位到源设备浏览的网页位置，保证用户的浏览连续性，避免重复查找信息的繁琐过程，提高信息获取的效率。
实现原理
接续过程底层依赖分布式框架和软总线，开发者只需要启用接续、保存数据和恢复数据，具体运作机制可参考：运作机制。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151339.11246955328605290395535872668703:50001231000000:2800:ADFD30E4632D7EC8048B7F66D5EC896E7EC3B7ACE612F910DABD192782C64A45.png)
开发流程
进度的接续实质上是要确保进度数据能够在不同设备之间实现精准的传递，并维持同步状态。在实际开发过程中，开发者往往会遇到各式各样复杂的进度接续需求，首要的任务便是深入剖析哪些是对进度起着关键控制作用的数据。在源端发起接续时，要保存数据；到对端接续时，则需准确恢复数据，以此保障进度的连贯性以及设备间数据的一致性。
本章节介绍使用分布式数据对象进行数据同步的方法，更多使用方法可见分布式数据对象跨设备数据同步，具体场景的实现见本文长列表进度接续、媒体播放进度接续和Web浏览进度接续。
1.  在module.json5文件的abilities中，将continuable标签配置为“true”，表示该UIAbility可被迁移。配置为false的UIAbility将被系统识别为无法迁移且该配置默认值为false。
2.  开发者可以将要迁移的数据通过键值对的方式保存在wantParam中。
```typescript
async onContinue(wantParam: Record<string, Object>): Promise<AbilityConstant.OnContinueResult> {
// 1.1 调用create()接口创建并得到一个分布式数据对象实例
// continueData是一个object，可以用来存储需要接续的数据
let continueIndex = AppStorage.get('continueIndex') as number;
let currentOffset = AppStorage.get('currentOffset') as number;
let continueData: ContinueData = new ContinueData(continueIndex, currentOffset);
let dataObject = distributedDataObject.create(this.context, continueData);
// 1.2 调用genSessionId()接口创建一个sessionId，调用setSessionId()接口设置同步的sessionId，并将这个sessionId放入wantParam
let sessionId = distributedDataObject.genSessionId();
console.log(`gen sessionId: ${sessionId}`);
dataObject.setSessionId(sessionId);
wantParam.distributedSessionId = sessionId;
// 1.3 从wantParam获取接收端设备networkId，使用这个networkId调用save接口保存数据到接收端
let deviceId = wantParam.targetDevice as string;
console.log(`get deviceId: ${deviceId}`);
dataObject.save(deviceId);
return AbilityConstant.OnContinueResult.AGREE;
}
```
3.  在onCreate()生命周期回调和onNewWant()生命周期回调中恢复数据。
```typescript
continueRestore(want: Want) {
if (!want.parameters || !want.parameters.distributedSessionId) {
console.error('missing sessionId');
return;
}
// 2.1 调用create()接口创建并得到一个分布式数据对象实例
let continueData: ContinueData = new ContinueData(undefined,undefined);
let dataObject = distributedDataObject.create(this.context, continueData);
// 2.2 注册恢复状态监听。收到状态为'restored'的回调通知时，表示接收端分布式数据对象已恢复发起端保存过来的数据（有资产数据时，对应的文件也迁移过来了）
dataObject.on('status', (sessionId: string, networkId: string, status: string) => {
if (status === 'restored') {
// 收到'restored'的状态通知表示已恢复发起端保存的数据
AppStorage.setOrCreate('continueIndex', dataObject['continueIndex']);
AppStorage.setOrCreate('currentOffset', dataObject['currentOffset']);
AppStorage.setOrCreate('continueEntry', true);
AppStorage.setOrCreate('setcurrentOffset', true);
}
});
// 2.3 从want.parameters中获取发起端放入的sessionId，调用setSessionId接口设置同步的sessionId
let sessionId = want.parameters.distributedSessionId as string;
dataObject.setSessionId(sessionId);
this.context.restoreWindowStage(new LocalStorage());
}
```
长列表进度接续
长列表通常用于存储大量信息，使用List、Grid、Scroll、WaterFlow进行封装，系统提供了分布式迁移标识用于这些组件恢复进度状态，在使用时可以轻松的调用，使用方法如下：
使用分布式迁移标识可以快速的实现接续。但该方法具有局限性，其支持场景和版本见分布式迁移标识API，如果想在开发中做更多自定义设置以提供更好的体验，可以参照如下步骤，完整工程参见示例代码。
媒体播放进度接续
媒体播放需要接续的内容主要包含媒体在播放列表中的集数、播放状态、进度，也可以接续其它播放设置加强用户体验，开发时请参考如下步骤，完整工程参见示例代码。
```typescript
this.avPlayer.on('timeUpdate', (time: number) => {
this.currentTime = time;
});
```
Web浏览进度接续
系统提供了Web组件以在应用程序中显示Web页面内容，当Web组件承载大量信息时，浏览进度的接续变得十分重要，接续的内容和长列表类似，均需要传递当前滚动位置，需要使用runJavaScript()接口获取和恢复。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-screen-linkage
爬取时间: 2025-05-01 08:37:06
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-drag-framework
爬取时间: 2025-05-01 08:37:23
来源: Huawei Developer
概述
拖拽操作是一种直观且高效的数据传输方式，它允许用户通过标准手势（包括用手指、鼠标或触控笔按住并移动）在应用程序之间及内部进行数据传输。
拖拽功能不仅操作便捷，还能与多种系统能力深度融合，拓展出更为广泛的应用场景。例如，跨设备拖拽让用户能在不同设备间无缝传输数据，跨窗口拖拽提升了多任务处理的灵活性。此外，基于拖拽操作还可以开发出更多创新性的应用场景，如AI智能识别、水印添加等，这些创新性的功能接入统称为“统一拖拽”。
本文将介绍几种典型拖拽场景及其具体实现方案，帮助开发者更好地理解和应用拖拽技术。
通过设置组件的拖拽响应，可以自定义拖出数据、拖入数据和拖拽背板图，实现如下场景：
将拖拽框架与系统的分屏能力、键鼠穿越能力、小艺及中转站结合，可以实现如下场景：
实现原理
拖拽流程可以分为三部分：发起拖拽、拖拽中和释放拖拽。其中，拖出方通过draggable()和onDragStart()等接口处理拖出数据，拖入方通过allowDrop()和onDrop()等接口处理拖入数据，拖拽数据使用UDMF统一数据对象UnifiedData进行封装。下面，将按照这三个部分依次介绍拖拽的基础实现。
| 发起拖拽  | 拖拽中  | 释放拖拽  |
| --- | --- | --- |
|   |   |   |
发起拖拽
拖拽中
释放拖拽
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151339.09488675800748966719021256478985:50001231000000:2800:CB0E7E29A5DAE3B3519A85DC5286A602D9207698C2552060FED6A48765812E7D.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151339.05581628856673213183979660359633:50001231000000:2800:028DA375988628BC0514DBC66162917EA7C30414BAB82C90E68FC73E0544D346.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151339.00737949700557157836197266816912:50001231000000:2800:90B0C68406627A167FF4171B1924BE09BD3DDDEAFB61C72E6DA6F50D1CD9E9CC.gif)
发起拖拽
可以在onDragStart()接口中自由地处理拖拽信息，例如为图片添加水印，详情见拖拽图像增加水印。
拖拽中
可以将拖拽背板图设置为自定义的图片或者文字，详情见自定义拖拽背板图。
释放拖拽
默认支持拖入能力的组件，如Search等，将目标拖入组件区域内会使用默认拖入响应。如果想自定义组件的拖入响应，需要将组件的allowDrop()属性设置为允许拖入的数据类型，并在其onDrop()接口中通过DragEvent的getData()接口获取拖入数据后，对数据内容进行相应处理。
可以在onDrop()中处理接收到的数据，例如将图片识别为文字以显示在只支持文字的组件上，详情见AI识别拖拽内容。
拖拽图像增加水印
在拖拽过程中，可以自定义拖出响应，为拖拽图像增加水印，以标识图像的相关信息。下面以在图像中增加拖拽时间水印为例，介绍实现原理。
实现原理
在拖出对象的onDragStart()接口中获取图像信息，调用系统绘制能力drawing在图像上绘制水印，通过DragEvent的setData()接口将水印图像设置为拖拽数据。
开发步骤
```typescript
// 获取拖拽时间
this.time = this.getTimeWatermark(systemDateTime.getTime(false));
let markPixelMap = this.addWaterMark(this.time, pixelMap);
// 绘制水印
addWaterMark(watermark: string, pixelMap: image.PixelMap) {
if (canIUse('SystemCapability.Graphics.Drawing')) {
watermark = this.context.resourceManager.getStringSync($r('app.string.drag_time')) + watermark;
let imageWidth = pixelMap.getImageInfoSync().size.width;
let imageHeight = pixelMap.getImageInfoSync().size.height;
let imageScale = imageWidth / display.getDefaultDisplaySync().width;
const canvas = new drawing.Canvas(pixelMap);
const pen = new drawing.Pen();
const brush = new drawing.Brush();
pen.setColor({
alpha: 102,
red: 255,
green: 255,
blue: 255
})
brush.setColor({
alpha: 102,
red: 255,
green: 255,
blue: 255
})
const font = new drawing.Font();
font.setSize(48 * imageScale);
let textWidth = font.measureText(watermark, drawing.TextEncoding.TEXT_ENCODING_UTF8);
const textBlob = drawing.TextBlob.makeFromString(watermark, font, drawing.TextEncoding.TEXT_ENCODING_UTF8);
canvas.attachBrush(brush);
canvas.attachPen(pen);
canvas.drawTextBlob(textBlob, imageWidth - 24 * imageScale - textWidth, imageHeight - 32 * imageScale);
canvas.detachBrush();
canvas.detachPen();
} else {
hilog.info(0x0000, TAG, 'watermark is not supported');
}
return pixelMap;
}
```
运行效果如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151339.70018725094057809766440021384922:50001231000000:2800:B06F611E47C7E053430642415B105F398B8632A008364AC23BF1E3042B11CE86.png)
自定义拖拽背板图
在拖拽过程中，可以自定义拖拽背板图，展示拖拽数据的相关信息。
实现原理
在拖出对象的onDragStart()接口中，回调自定义的PixelMap作为拖拽中的背板图。
开发步骤
1.  由于CustomBuilder需要离线渲染之后才能使用，存在一定的性能开销和时延，因此推荐开发者优先使用DragItemInfo中的PixelMap方式返回背板图。
```typescript
private getComponentSnapshot(): void {
this.getUIContext().getComponentSnapshot().createFromBuilder(() => {
this.pixelMapBuilder()
},
(error: Error, pixmap: image.PixelMap) => {
if (error) {
hilog.error(0x0000, TAG, JSON.stringify(error));
return;
}
this.pixelMap = pixmap;
})
}
```
运行效果如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151339.78558876227249893822923394354352:50001231000000:2800:4A8E9D6C313E68BEDDB3AEFDCFEEA4E12D086082166406FF4675CE72EF7621C1.gif)
AI识别拖拽内容
在拖拽过程中，可以自定义拖入响应，以识别拖拽内容并将其输出在释放区内。下面以通过AI识别拖拽图像中的文字为例，介绍实现原理。
实现原理
在拖入对象的onDrop()接口中，通过DragEvent的getData()接口获取拖拽数据后，调用系统文字识别能力textRecognition得到图像中的文字信息。
开发步骤
运行效果如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151339.96099558060385291337441814824085:50001231000000:2800:4B188442CFA6A1D46A8B41621724F35765A5E41E2C35373804BE99E779D6EAC1.gif)
分屏拖拽
将拖拽框架与系统的分屏能力结合，可以将数据从一个分屏页面拖拽到另一个分屏页面，实现跨应用拖拽或同应用跨页面拖拽。
使用说明
需要开启软件的分屏权限，并根据需求自定义拖拽响应。
运行效果如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151339.55134554501268011586521093247377:50001231000000:2800:26FF6135011E782AA12BF047F916CD892C84A9D9A15702179CE916D490905569.gif)
跨设备拖拽
将拖拽框架与系统的键鼠穿越能力结合，可以接入跨设备拖拽，实现在平板或PC/2in1类型的任意两台设备之间拖拽数据。
使用说明
需要满足跨设备拖拽开发指导中的使用限制条件，并根据需求自定义拖拽响应。
运行效果如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151339.42144235721890280628373412853397:50001231000000:2800:66EBB3A8FE6B22C5E8748874352CDA0F8522F4031551C087FE3D33C48DB7B440.gif)
拖入小艺和中转站
将数据拖入系统的中转站，可以实现跨应用数据拖拽和跨设备数据流转；将数据拖入小艺，可以利用系统的AI能力处理拖拽数据。
使用限制
应用本身预置的资源文件（即应用在安装前的HAP包中已经存在的资源文件）不支持拖入小艺和中转站。
运行效果如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151340.99526633350824496800673072816031:50001231000000:2800:C8EDB4499F35B63E8AAA988B5D5717367936F6D545680369F6B1DF39466437E4.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151340.43750810511539795858622460418845:50001231000000:2800:5968D76F825A61D587C642E29690C844E94FB02DA50ECDEAF52D8FB6384F6DF1.gif)
常见问题
在模拟器中无法实现AI识别拖拽内容
问题现象
将图像拖拽至释放区，无法识别图像中的文字并输出在释放区内。
解决措施
模拟器不支持textRecognition接口的调用，建议使用真机进行调试，详细请参见模拟器与真机的差异。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-industry-scenarios
爬取时间: 2025-05-01 08:37:36
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-news-reading
爬取时间: 2025-05-01 08:37:49
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-news_homepage
爬取时间: 2025-05-01 08:38:05
来源: Huawei Developer
概述
本场景解决方案主要面向于新闻类页面开发人员，指导开发者从零开始构建一个新闻类的首页面。主要包含地址选择、tabs和tabContent切换的动态图标和流畅动效、下拉刷新上拉加载、首页feed流等常见功能的实现及流畅体验。
整体场景介绍
主要介绍了用户操作应用的主要流程，展示了用户进入首页通过页签切换页面内容，上拉加载和下拉刷新页面，从首页地址进入地址选择页更换地址等功能效果。
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151340.28386479030998183911087507774999:50001231000000:2800:22984142F69349617DC5EEDB7D134FF9FF31A4C2CA14C272ACB7CF02E36009D0.png)
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151340.10514485076001486830486720070272:50001231000000:2800:CF483539F5A73941CC89883853A5B473418B8B2526A1A6B52172D3E49CE709C7.gif)
-  1. 获取地理位置的权限； 2. 点击位置信息，跳转地址页，可修改当前位置信息； 3. 点击顶部页签或者滑动切换页面，页签同步切换； 4. 点击底部页签切换页面，同步切换页签，触发页签切换的动画效果； 5. 下拉刷新页面信息； 6. 上拉加载页面信息； 7. 点击右下角按钮回弹至顶部。
场景说明
适用范围
本场景主要适用于新闻类的应用首页，使用原生组件及三方库组件完成新闻首页与功能的实现。
场景优势
本场景可以带给用户更加流畅和便捷的首页体验。具体优势如下：
场景分析
典型场景与实现方案
-  场景名称 描述 实现方案 导航栏切换动效流畅 点击页签或者滑动切换页面，页签同步切换 tab组件添加动画开始时触发事件 底部页签跳转精致流畅 底部页签切换具有动画效果 添加lottie动画 上拉加载下拉刷新 上拉加载更多的新闻内容，下拉刷新整个页面，均具有加载动效 pullToRefresh组件 首页feed流 首页展示流畅图文列表 使用LazyForEach对子组件进行渲染，实现懒加载功能 地址选择页 提供地址选择，定位，地址首字母定位及模糊查询功能 位置服务与AlphabetIndexer组件
| 场景名称  | 描述  | 实现方案  |
| --- | --- | --- |
| 导航栏切换动效流畅  | 点击页签或者滑动切换页面，页签同步切换  | tab组件添加动画开始时触发事件  |
| 底部页签跳转精致流畅  | 底部页签切换具有动画效果  | 添加lottie动画  |
| 上拉加载下拉刷新  | 上拉加载更多的新闻内容，下拉刷新整个页面，均具有加载动效  | pullToRefresh组件  |
| 首页feed流  | 首页展示流畅图文列表  | 使用LazyForEach对子组件进行渲染，实现懒加载功能  |
| 地址选择页  | 提供地址选择，定位，地址首字母定位及模糊查询功能  | 位置服务与AlphabetIndexer组件  |
场景实现
导航栏切换动效流畅
通过添加tab组件动效触发事件，实现页面内容切换与页签样式切换的同步触发效果。效果如图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151340.70015525099803584126508357178266:50001231000000:2800:BEAF0420F6B33735E63EB356BBBC319C449C813E7DCCCDCC5ED782A5B590DDE7.gif)
-  推荐使用onAnimationStart事件设置切换标签动效，使用onChange会导致页面切换后再触发动效导致效果延迟触发，使用onClick事件会与页面切换冲突。
底部页签跳转精致流畅
底部页签样式添加lottie动画使跳转精致流畅。效果如图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151340.70640639387560708686680556988131:50001231000000:2800:58912A202471E249CBCA3FFAED583F3ABFD4CD157199DCF1EBA58AE7E3C9B74B.gif)
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151340.67104379807131603019530624268198:50001231000000:2800:D76F6FF8CFCB7DEFDFAC4BF45FDC31D3095CCA4F38EEF70A8A71BBCEACF5E1A7.png)
-  Lottie是一个适用于OpenHarmony的动画库，它可以解析Adobe After Effects软件通过Bodymovin插件导出的json格式的动画，并在移动设备上进行本地渲染。支持动画的交互性，通过添加触摸事件与TabBar相结合可实现动态图标效果。 引入lottie三方库。 准备lottie动画资源，建议放置到Entry目录下的common文件夹下(放置本模块中，使用相对路径无法读取)。 导入lottie模块。 使用RenderingContext在Canvas组件上进行绘制，声明CanvasRenderingContext2D变量，RenderingContextSettings用来配置CanvasRenderingContext2D对象的参数表明canvas是否开启抗锯齿。 定义所需数据类型的接口，初始化变量，接口中需要包含资源路径信息和CanvasRenderingContext2D。 实现动画播放方法。 在TabBar样式中实现子组件Canvas。 在tab组件的onAnimationStart事件中调用播放方法。
上拉加载下拉刷新
通过三方库组件pullToRefresh实现下拉刷新页面，上拉加载更多数据效果。效果如图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151341.36703875865284083549625446899053:50001231000000:2800:7700571F41E3D7DB0202854773D4049DA624D4AB2158563674D62243BC3A0F41.gif)
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151341.42833557726913250599149615131712:50001231000000:2800:4485DA1109976E39F05D6A948A1470E0C2DC3F85B4E3B2E490EB04193EC4CDDE.png)
-  使用第三方库pullToRefresh组件，将列表组件、绑定的数据对象和scroller对象包含进去，并添加上滑与下拉方法。支持lazyForEach的数据作为数据源，使用的List组件需要设置edgeEffect属性为(EdgeEffect.None)。 引入三方库pullToRefresh。 准备数据源，本场景使用本地资源模拟效果，资源文件在resources/rawfile目录下，实际情况可替换为从网络获取。 将列表组件、绑定的数据对象和scroller对象包含进去，并添加上滑与下拉方法。
首页feed流
通过懒加载实现首页feed流快速渲染与流畅滑动。效果如图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151341.05042435264456942342869414217017:50001231000000:2800:5D46F26D5DA8C9CB5CB0EEF5D6BE2FC32B58988C419471418C339BA9B4DF2DB2.gif)
-  新闻应用列表数据往往会达到上万条，针对这类大量数据加载的长列表应用，使用懒加载解决一次性加载长列表数据耗时长、占用过多资源的问题，可以提升页面响应速度。 创建需要加载的数据源。 创建子组件。 使用LazyForEach对子组件进行渲染。
地址选择页
使用位置服务实现定位功能，AlphabetIndexer组件实现地址首字母定位导航条。效果如图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151341.30755420796495079867042991035996:50001231000000:2800:E684AA361807EEDDE69887DCA9FFF728B22C97EC15DF5392E9038DF8E0DBA474.gif)
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151341.02115846900510700014196707088905:50001231000000:2800:755CD66D85F0D283946C88E11FE69E068E4DFF852F3619E4CD3696394C49297A.png)
-  开启手机位置服务功能，使用位置服务提供GNSS定位、网络定位、逆地理编码的功能获取当前地理位置信息，通过AlphabetIndexer组件实现首字母快速定位城市的索引条导航。 申请权限，API9及之后的版本，需要申请ohos.permission.APPROXIMATELY_LOCATION或者同时申请ohos.permission.APPROXIMATELY_LOCATION和ohos.permission.LOCATION；无法单独申请ohos.permission.LOCATION。 申请用户安全权限。 导入位置服务。 获取地理位置信息，进行逆地理编码获取当前位置。 使用AlphabetIndexer组件实现导航条，通过AlphabetIndexer组件onSelect事件获取选中索引值，通过Scroller的scrollToIndex方法滑动到指定索引位置。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-audio-video
爬取时间: 2025-05-01 08:38:18
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-smooth-switching
爬取时间: 2025-05-01 08:38:33
来源: Huawei Developer
概述
在短视频应用中，用户在快速切换视频时，新视频起播容易出现时延过长的问题。针对该问题，本文提供了如下解决方案：
最终实现短视频快速切换起播时延达到≤230ms的性能体验目标。
如果开发者使用自研播放器引擎而非AVPlayer，也可以参考该解决方案思路实现优化。
效果展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151341.22291957559152812113130917930620:50001231000000:2800:EF8ECC70A13FB81B71411B02DA2C2773B124AE4030465B15D25A93A010F2A78A.gif)
场景说明
适用范围
适用于应用中在线短视频快速切换，容易出现快速切换播放起播慢体验不佳的场景。
场景体验指标
起播时延计时标准
1、以用户滑动屏幕后抬手，手指离屏时刻为起点，以视频第二帧画面显示时刻为终点（不是封面帧）。
2、转场动画时长建议设置300ms。
3、在动画开始时使用预先准备的播放器起播，起播时延控制在230ms内。
| 描述  | 应用内滑动视频，新视频起播时延应≤230ms。  |
| --- | --- |
| 类型  | 规则  |
| 适用设备  | 手机、折叠屏、平板  |
| 说明  | 无  |
描述
应用内滑动视频，新视频起播时延应≤230ms。
类型
规则
适用设备
手机、折叠屏、平板
说明
无
场景分析
典型场景及优化方案
典型场景描述
短视频：以小于5分钟的短视频为例进行说明
场景优化方案
AVPlayer：
1.  在线短视频预加载，冷启动时创建第一个播放器，播放当前视频时预加载下一个播放视频（预加载下一个视频的时候会使用户的流量消耗增加，需要开发者自行决策），绘制组件XComponent的Surface类型将视频流进行动态渲染、使用LazyForEach进行数据懒加载，设置cachedCount属性来指定缓存数量，同时搭配组件复用能力以达到高性能效果。
2.  在轮播过程中，对下一个视频提前进入AVPlayer的prepared状态。
3.  滑动过程中手指离开屏幕，此时滑动动效开始播放，在动效开始时就可以调用AVPlayer的play方法进行播放。
三方自研播放器：
1.  同上文AVPlayer的数据懒加载方案一致。
2.  在轮播过程中，对下一个视频提前初始化播放器所需内容（视频源下载、AudioRender初始化、解码器初始化等），并对视频提前预解析首帧画面。
3.  滑动过程中手指离开屏幕，此时滑动动效开始播放，在动效开始时就可以调用播放引擎进行播放。 为了保证用户的起播体验，在前几帧画面送显时应优先送显，而不是等AudioRender写入音频数据才送显，因为音频硬件时延比显示时延大。播放起始几帧建议不要做强音画同步，而是采用慢追帧策略进行同步，视频帧稍微增大送显间隔，直到完成音画同步。
场景实现
场景整体介绍
基于AVPlayer实现了在线流媒体的短视频流畅播放和控制功能。基于对应的播放器，使用滑块视图容器Swiper进行短视频滑动轮播切换、绘制组件XComponent的Surface类型将视频流进行动态渲染、懒加载，最终实现短视频快速切换，实现起播≤230ms，提供开发者解决此类问题的方案。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151341.36385331072089630724733196385359:50001231000000:2800:71401ED6A54B0856DE592D7CE2640DCD62E0111670C82AA6EA6C971901ECEBFD.png)
在线短视频快速切换
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151341.18761705439334409163976864876876:50001231000000:2800:CF8E3941C5C544244DA82BDF038A2A2B8B086C3BA332B1EB51B762A79AD5A6BB.png)
关键点
AVPlayer
AVPlayer可以将Audio/Video媒体资源（比如mp4/mp3/mkv/mpeg-ts等）转码为可供渲染的图像和可听见的音频模拟信号，并通过输出设备进行播放。
LazyForEach数据懒加载
LazyForEach懒加载可以通过设置cachedCount属性来指定缓存数量（目前设置为3），同时搭配组件复用能力以达到高性能效果。
SurfaceID每次都会创建，不共用SurfaceID，AVPlayer也会同时创建， 不共用AVPlayer，进而将提前加载好的视频（prepared阶段）放到缓存池中。
在通过Swiper切换时，会根据当前轮询滑动的窗口索引index到缓存池中找到对应的视频（prepared阶段），直接进行播放，从而能提高切换性能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151341.26444291999936958769883631669265:50001231000000:2800:D9508234C3F888418B816B80F5B3DA7DBACC83914CE3C33D2CDA1C28225EDEFA.png)
异步视频预加载
异步视频预加载：在Swiper轮播过程中，在播放当前视频时，提前加载好下一个视频，在缓存中同时存在多个播放器实例，根据视频当前的索引来确定使用缓存中的哪个播放器来播放，从而达到流畅切换的效果。
（1）本地播放一个短视频的耗时。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151341.09136322830009025551055578919633:50001231000000:2800:143365A4F7DE2A9A8E636850D1B9E9E78FCF9001726054200D82ADE211469970.png)
（2）播放视频A的时候，提前预加载视频B。在切换短视频时，可以马上开始播放已预加载完成的视频B，从而减少了切换时间，提高了切换性能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151341.17893160944033480368940991374824:50001231000000:2800:1E4E010960AA691383D1C98D1EB1183796CE095D221D2E24435B8AEE610A81D3.png)
视频播放预启动接力
为了进一步提升滑动播放体验，在动效开始时就开始播放，做到动效和播放并行进行：
（1）在收到AnimationStart回调时开始播放，而不是动效结束再播放；
（2）不要用默认的弹簧曲线（弹簧动效有560ms，视频窗口在400ms左右已经完全铺开了，最后150ms位移随时间变化较小），可以把curve改成Curve.Ease, duration改成300（视APP UX确定）；
视频播放预启动接力：类似于4*100接力赛，想要尽快完成接力赛，当第一个选手快到达终点时，第二个选手就提前起跑并且和第一个选手完美完成接力棒，从而减少整个接力赛过程中的时间。短视频切换也是如此，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151342.73957459497406195837087241699271:50001231000000:2800:80EFA2186219AD08A48DB7129D9D1728539827D29C944605E4D6A0BEEE09C4E9.png)
开发步骤
1.  在自定义组件VideoPlayView中设置XComponent组件用于视频流渲染，获取并设置SurfaceID用于设置显示画面。在onLoad时异步创建并初始化AVPlayer播放器使其提前进入prepared状态以实现视频的异步预加载。
2.  通过LazyForEach懒加载VideoPlayView自定义组件方式为保证每一个视频有单独的SurfaceID和AVPlayer（位于VideoPlayView自定义组件中）。 通过设置cachedCount属性，结合上一步在XComponent的onLoad中异步初始化AVPlayer，使视频提前进入prepared状态以实现视频的异步预加载。 视频切换时，在onAnimationStart阶段即更新当前窗口索引curIndex，开始播放下一个视频，从而实现视频播放预接力。 设置弹簧曲线为.curve(Curve.Ease)。
3.  在自定义组件VideoPlayView中通过@Watch装饰器监听Swiper轮播的this.curIndex值，在视频缓存流中跟this.index进行比较，从而判断视频流中哪个播放，其余的均暂停。
总结
本文介绍了数据懒加载、异步在线视频预加载以及在线视频播放预接力等优化方案，可以帮助开发者解决快速切换播放时延过长的问题。另外，开发者可以基于SwipePlayer库快速实现短视频流畅滑动的场景开发体验，可以更加聚焦实际场景业务的开发。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-travel-navigation
爬取时间: 2025-05-01 08:38:46
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-shared-bicycle
爬取时间: 2025-05-01 08:39:01
来源: Huawei Developer
概述
本场景解决方案主要面开通实涉及共享租赁、即时配送等场景的应用，以共享单车为案例，使用实况窗、地图导航、统一扫码等技术，为消费者的整个骑行流程带来更好的体验。
效果展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151342.32483986164475220863880260742823:50001231000000:2800:FDD58C31604A03214224C1471C913D25CDFF68F243BD0B70CB8B66CB4168358D.gif)
场景说明
场景整体介绍
当前用户想要完成骑行的整个流程，需要先找到应用，再找到功能入口，骑行完成后又需要再重复一遍步骤，对于用户来说操作多，流程繁琐。如果能从首页直接扫码直到解锁界面，换车也只需一步操作即可支付将大大提升用户体验。采用Scan Kit和实况窗实现以下流程：用户扫描共享单车的二维码后，进入解锁页面，点击解锁后，会拉起实况窗显示骑行状态，后续完成还车、支付等操作后，可以实时更新实况窗的状态。
场景优势
本场景结合提供的实况窗、地图导航、扫码等系统能力，可以带给用户更加便捷高效的体验。具体优势如下：
1、使用实况窗技术帮助用户聚焦正在进行的任务，方便快速查看和即时处理。支持在锁屏、通知中心等位置显示卡片，在状态栏显示胶囊形态，以及在状态栏点击胶囊后展开悬浮卡片，让用户一眼可见重点信息。多种显示方式能够将信息即时触达到用户，避免用户反复进出应用或服务的页面。
2、基于Map Kit实现个性化地图呈现、地图搜索和路线规划等功能，手势交互方面，提供了包括缩放、旋转、移动等流畅的交互体验。
场景分析
典型场景
| 编号  | 场景名称  | 描述  | 实现方案  |
| --- | --- | --- | --- |
| 1  | 扫码解锁  | 首页和共享单车页面均可扫码，扫码成功直达解锁页面。  | 基于ScanKit能够快速实现扫码能力  |
| 2  | 地图规划路径  | 选中目的地，展示规划好的最短路径  | 基于MapKit能够快速实现路径规划和路线绘制能力  |
| 3  | 实况窗展示骑行状态  | 骑行过程中，用户需要实时查看骑行状态  | 使用实况窗，在整个骑行过程中，即使手机处于锁屏状态下，用户也能一眼可见骑行状态，无需解锁并打开应用。  |
编号
场景名称
描述
实现方案
1
扫码解锁
首页和共享单车页面均可扫码，扫码成功直达解锁页面。
基于ScanKit能够快速实现扫码能力
2
地图规划路径
选中目的地，展示规划好的最短路径
基于MapKit能够快速实现路径规划和路线绘制能力
3
实况窗展示骑行状态
骑行过程中，用户需要实时查看骑行状态
使用实况窗，在整个骑行过程中，即使手机处于锁屏状态下，用户也能一眼可见骑行状态，无需解锁并打开应用。
场景实现
业务流程图
左图为当前骑行场景的流程图，右图是优化后的流程，与原流程对比省去寻找入口和后台应用的步骤，简化了用户的使用步骤，提升用户体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151342.03060723129738951615119261246696:50001231000000:2800:F6FFE8D42624DDD067BF6F3F95D4D38ADAAE0E9D269C0532BA310A543DAF70DA.png)
骑行状态图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151342.92835897534222587861276628476253:50001231000000:2800:436FAF52EA167270000AF94DE1CF899B8B01D0E77DC2CF48F6D25ED080E50E6F.png)
时序图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151342.41537159181350206994029756840085:50001231000000:2800:32A65072C40E428EE5ECCE467351FCEF4FB0D9DB8C89113AB643FEE41796F047.png)
扫码解锁
效果展示
在首页或者共享单车页面，点击扫码进入扫码界面，可以使用后置摄像头进行扫码，也可以点击图库选择二维码图片进行扫码。“扫码直达”相关的使用请参见“接入扫码直达服务”。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151342.03457546223604251635450257994522:50001231000000:2800:07D362940D1DA4E9A42C66AC4D8AEC93E9604B923C94321BD27BB4B2ED27CF04.gif)
时序图
主要业务流程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151342.99546607644590849526160434087811:50001231000000:2800:214552B10BB7D985A065E69DCA9ED4813B13DFA1605BE1EB473B3F72EE004198.png)
关键点说明
1、使用Scan Kit实现扫码能力，Scan Kit应用了多项计算机视觉技术和AI算法技术，不仅实现了远距离自动扫码，同时还针对多种复杂扫码场景（如暗光、污损、模糊、小角度、曲面码等）做了识别优化，提升扫码成功率与用户体验。
2、申请系统相机权限，在entry模块的module.json5文件的requestPermissions字段中增加ohos.permission.CAMERA权限。
3、支持多种识码类型，常用的是二维码，也支持条形码扫描。
关键代码片段
```typescript
import { scanBarcode, scanCore } from '@kit.ScanKit';
import { router } from '@kit.ArkUI';
import { CyclingConstants, CyclingStatus } from '../constants/CyclingConstants';
import { BusinessError } from '@kit.BasicServicesKit';
import Logger from './Logger';
export class ScanUtil {
public static scan(obj: Object): void {
let options: scanBarcode.ScanOptions = {
scanTypes: [scanCore.ScanType.ALL,scanCore.ScanType.ONE_D_CODE],
enableMultiMode: true,
enableAlbum: true
};
try {
scanBarcode.startScanForResult(getContext(obj), options).then((result: scanBarcode.ScanResult) => {
Logger.info('[BicycleSharing]', 'Promise scan result: %{public}s', JSON.stringify(result));
if (result.scanType === CyclingConstants.SCAN_TYPE) {
AppStorage.setOrCreate(CyclingConstants.CYCLING_STATUS, CyclingStatus.WAITING_UNLOCK);
router.pushUrl({ url: 'pages/ConfirmUnlock' });
}
}).catch((error: BusinessError) => {
Logger.error(0x0001, '[BicycleSharing]', 'Promise error: %{public}s', JSON.stringify(error));
});
} catch (error) {
Logger.error(0x0001, '[BicycleSharing]', 'failReason: %{public}s', JSON.stringify(error));
}
}
}
```
地图路径规划
效果展示
进入找车页面后，可以点击任意位置模拟自行车的所在地，地图将进行步行路线规划并增加标记点。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151342.79701616046857047429131411677229:50001231000000:2800:6BA35B0BD2B8025E31AE6FF9D602DCD486E1ECBEC00E729C939B543DEDFB2A65.gif)
时序图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151342.30351191371891820923217076926507:50001231000000:2800:E974C87D632FFC85824A0A153F738F548C4AE5C7D72F219267264B75DE96FFEF.png)
关键点说明
1、使用Map Kit实现地图能力，Map Kit可以帮助开发者实现个性化地图呈现、地图搜索和路线规划等功能，轻松完成地图构建工作。
2、参考文档配置AppGallery Connect指南去AppGallery Connect开通地图服务。注意要在工程中entry模块的module.json5文件中配置client_id。
3、启用“我的位置”之前，您需要确保您的应用可以获取用户定位。需要申请ohos.permission.LOCATION和ohos.permission.APPROXIMATELY_LOCATION权限。
关键代码片段
1、导入Map Kit
2、集成地图组件，初始化地图页面
3、向用户申请授予定位权限，启动“我的位置”功能
4、监听点击事件
5、启动步行路径规划
```typescript
public static async walkingRoutes(position: mapCommon.LatLng, myPosition?: mapCommon.LatLng) {
let params: navi.RouteParams = {
origins: [myPosition!],
destination: position,
language: 'zh_CN'
};
try {
const result = await navi.getWalkingRoutes(params);
Logger.info('naviDemo', 'getWalkingRoutes success result =' + JSON.stringify(result));
return result;
} catch (err) {
Logger.error('naviDemo', 'getWalkingRoutes fail err =' + JSON.stringify(err));
}
return undefined;
}
```
6、绘制路线
实况窗展示骑行状态
效果展示
点击解锁后，会拉起实况窗显示骑行状态，后续完成还车、支付等操作后，可以实时更新实况窗的状态。支持在锁屏、通知中心等位置显示卡片，在状态栏显示胶囊形态，以及在状态栏点击胶囊后展开悬浮卡片，让用户一眼可见骑行状态。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151342.85766663578079260182539148525809:50001231000000:2800:000CE73AED6DBEAB8F6158CACCE5ACBBED318EDB1157F3B99A777E6E2931E350.gif)
时序图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151342.73733855816451009542078606770120:50001231000000:2800:618C3CA2B73E95D42DD66AD52B65A2355A7DFA09E5AAB2352388EF15A29CE620.png)
关键点说明
1、使用Live View Kit实现实况窗服务，Live View Kit支持应用将订单或者服务的实时状态信息变化在设备的关键界面展示。
2、参考文档开通实况窗权益去AppGallery Connect开通实况窗服务。
3、此场景中只用了本地实况窗的能力，本地更新或结束实况窗依赖于您的应用进程，若业务需要，可以在本地创建实况窗后使用Push Kit远程更新或结束实况窗。
关键代码片段
1、导入Live View Kit
2、创建实况窗
3、更新和结束实况窗
4、开发用户自定义向沉浸态实况窗
5、在LiveViewDataBuilder中配置沉浸态实况窗参数
6、在module.json5中配置拓展的ability
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-social-communications
爬取时间: 2025-05-01 08:39:14
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-content-creation
爬取时间: 2025-05-01 08:39:30
来源: Huawei Developer
概述
本场景主要实现社交通讯类应用的图文内容编创流程，在该过程中接入自由流转、服务互动等HarmonyOS特性能力。
整体场景介绍
图文编创流程主要通过Photo Picker选取本地图片，然后对图片进行智能处理，同时也可使用自定义相机拍摄动图，最后进行文字编创时可进行自由流转接续编辑和跨端获取相册或者相机拍摄内容。
演示效果
运行效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151343.36929942094691924232482721171382:50001231000000:2800:4F6D8F1F5FBE91D98A5F165E10C488736FE854C07C43C88EB626C5D800E1A2C3.gif)
场景适用说明
适用范围
本场景适用于社交通讯类应用，在图文内容编辑过程中，接入HarmonyOS特性能力，本文给出了详细的技术实现方案，为开发者降低学习成本，提高接入速度。
场景优势
本场景的优势主要体现在功能方面，应用结合HarmonyOS提供的服务互通、鸿蒙智能、自由流转等能力，可以带给用户更加便捷高效的内容发布体验。具体优势如下：
（1）服务互通能力的加持，使多设备用户可以灵活地选择存储在不同设备上的媒体资源和使用不同设备的拍摄能力获取新的图像，免去了过往不同设备之间数据传输的流程，给用户提供了更便捷的体验。
（2）鸿蒙智能的使用，为用户提供了更加强大的编创能力支撑。用户可以从图上提取有效信息参与文字编辑，可以从候选图中提取目标去除背景进行二次创作，这些技术的使用为用户提供了更丰富的编创选择。
（3）自由流转的接入，可自由流转其他设备，且同步最新编辑状态至新设备，用户可以灵活选择合适设备，实现接续编辑。
场景分析
典型场景分析
| 子场景名称  | 描述  | 实现方案  |
| --- | --- | --- |
| 图片视图选择  | 发布首页资源文件类型选择  | 使用Photo Picker能力实现图片选择  |
| 相机拍摄  | 自定义相机页面，可拍摄和预览Moving Photo图片  | 使用Camera相机组件能力自定义相机  |
| 图片文字识别、抠取与HDR Vivid图片的展示  | 图片浏览页支持选定图片的目标抠取、复制图上文字信息获取，参与创作编辑，自动识别HDR模式并展示高亮  | 使用Image组件的智能识别能力，实现OCR文字识别与抠图  |
| 跨端相册选取  | 从其他设备的相册中选取图片，回传到本端设备  | 基于CollaborationService服务互通组件  |
| 编辑页流转接续  | 编创内容支持多设备之间的接续，可在不同设备上接续编辑  | 基于Ability的自由流转能力，使用ArkData数据管理和分布式文件管理实现本地创作内容的多设备之间接续编辑  |
子场景名称
描述
实现方案
图片视图选择
发布首页资源文件类型选择
使用Photo Picker能力实现图片选择
相机拍摄
自定义相机页面，可拍摄和预览Moving Photo图片
使用Camera相机组件能力自定义相机
图片文字识别、抠取与HDR Vivid图片的展示
图片浏览页支持选定图片的目标抠取、复制图上文字信息获取，参与创作编辑，自动识别HDR模式并展示高亮
使用Image组件的智能识别能力，实现OCR文字识别与抠图
跨端相册选取
从其他设备的相册中选取图片，回传到本端设备
基于CollaborationService服务互通组件
编辑页流转接续
编创内容支持多设备之间的接续，可在不同设备上接续编辑
基于Ability的自由流转能力，使用ArkData数据管理和分布式文件管理实现本地创作内容的多设备之间接续编辑
场景实现
Photo Picker的使用
子场景描述
用户在首页点击进入发布流程时，将直接跳转半模态窗口的Picker页面，同时该页面支持自定义，为开发者提供更多的选择。
关键点说明
使用系统Picker能力，可以免申请权限读写权限"READ_IMAGEVIDEO"和“WRITE_IMAGEVIDEO”，给开发者提供了极大的便利。
关键代码
首先在使用前，需要先创建PhotoViewPicker实例。
根据业务逻辑需要进行图片选择环节的属性设置，如设置可选择的媒体资源类型、资源数量上限。
OCR文字识别、智能抠图与HDR vivid的使用
子场景描述
选取图片之后，可以浏览这些图片，并长按物体实现抠图，也可识别图片中的文字，用于后续文本内容编辑使用，如果图片是HDR Vivid的拍摄模式，将展示其效果。
演示效果
长按识别文字与物体抠图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151343.44600889296478100928952793782143:50001231000000:2800:3C0F941C94789C91E1A80C29ADFED522991B668CF03C92B526F59B2691ADC542.gif)
关键点说明
（1）在Image组件设置enableAnalyzer属性，将实现文字识别和智能抠图，设置dynamicRangeMode属性，可展示HDR高亮，需配合image.DecodingOptions配置动态范围模式使用。
（2）文字识别：图片可文字识别时，通过点击图片内出现的识别按钮或者长按文字移动，会出现复制文本菜单与文字框选区域。
（3）智能抠图：长按图片中的物体，将出现抠图效果，菜单中可进行复制与分享。
关键代码
开启图片智能分析属性、和设置图像的动态模式。
设置图片解码选项，配合动态模式使用。
Moving Photo的拍摄与展示
子场景描述
在编辑图片页，增加一个自定义相机tab项，开发者可以根据自身需求，设置并拍摄更多模式的照片，用于内容展示。
关键点说明
（1）相机在初始化后，可设置Moving Photo属性开关，默认关闭，当前场景设置为开启，可点击live photo按钮进行切换。
（2）获取拍摄的最新图片，需要执行拍摄之后，延迟一段时间，才可获取到最新图片。
（3）Moving Photo图片预览需要使用MovingPhotoView视图，长按可播放。
（4） 申请对应权限，同意后才可初始化相机。
关键代码
申请对应权限。
相机设置Moving Photo属性。
```typescript
setEnableLivePhoto(isMovingPhoto: boolean) {
if (this.photoOutput?.isMovingPhotoSupported()) {
this.photoOutput?.enableMovingPhoto(isMovingPhoto);
}
}
```
引入Moving Photo相关库。
通过拍摄后获取的photoAccessHelper.PhotoAsset请求Moving Photo。
添加Moving Photo展示图。
本章节只介绍主干流程的关键代码，要实现自定义相机实际上还有很多配置，可详细关注封装模块CameraService文件，Moving Photo的使用可查看相关Api使用：动图照片。
服务互通组件的使用
演示效果
跨端相册获取新的图片
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151343.23375173630117117716096338937223:50001231000000:2800:616CEE0A6CA6EF0B969AF9AEADC13EAFB95750986A49670B77F0215DAD51917A.gif)
子场景描述
通过服务互通组件的能力，实现跨端相册访问、跨端相机拍照，从其他设备上获取新的图像内容，让设备之间的图像传输更加快捷与便利。
关键点说明
（1）服务互通组件，使用前提：需要连接网络，并且登录相同账号。
当前服务互通能力只能“重”设备调用“轻”设备，此处“重”和“轻”表示在重量与便携程度上给用户带来的主观感受，设备间可跨端调用关系如下说明：
（1）平板可调用手机，平板无法调用平板；
（2）手机无法调用平板，手机也无法调用手机；
关键代码
跨端拍照与跨端相册访问：
借助createCollaborationCameraMenuItems定义设备列表选择器，该组件需要在Menu组件内调用。用于显示组网内具有对应相机能力的设备列表。
使用CollaborationCameraStateDialog弹窗组件，用于提示对端相机拍摄状态。
该组件可在build()函数内直接调用，开发者需要实现其中的onState方法，当拍摄完成之后，将通过onState方法回传返回内容。
onstate方法有的回调函数有两个参数，分别是stateCode业务完成状态和buffer成功返回的数据。
```typescript
@Builder
setCollaborationDialog() {
CollaborationServiceStateDialog({
onState: (stateCode: number, bufferType: string, buffer: ArrayBuffer): void => this.doInsertPicture(stateCode,
bufferType, buffer)
});
}
doInsertPicture(stateCode: number, bufferType: string, buffer: ArrayBuffer): void {
if (stateCode !== 0) {
Logger.error(this.tag, `doInsertPicture stateCode: ${stateCode}}`);
return;
}
Logger.info(this.tag, `doInsertPicture bufferType: ${bufferType}}`);
if (bufferType === CommonConstants.BUFFER_TYPE) {
if (this.photoUriArr.length === CommonConstants.LIMIT_PICKER_NUM) {
promptAction.showToast({
message: $r('app.string.toast_picker_limit'),
duration: DataUtils.fromResToNumber($r('app.float.show_DELAY_TIME')),
});
return;
}
FileUtils.saveFile(getContext(this), buffer).then(async (uri: string) => {
let pixelMap = await FileUtils.createPixelMapFromUri(uri);
if (pixelMap === undefined) {
return;
}
this.selectedData.unshiftData(pixelMap);
FileUtils.copyToDistributedDir(getContext(this), uri);
FileUtils.unshiftFiles(uri);
this.photoUriArr.unshift(uri);
});
}
}
```
应用接续的实现
子场景描述
在图文编创场景中，使用Ability的自由流转能力，使得编辑内容可以流转到其他更方便的设备上进行接续编辑，这样方便用户，在不同设备上进行内容编辑。
演示效果
自由流转，接续编辑图文内容
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151343.42792100488686000990057768508270:50001231000000:2800:BE38C8D737D90B9A90D2CA374E590FF791C56CD0C221DECEFE3144BA41250A56.gif)
关键点说明
接续的使用条件
（1）两端设备登录同一华为账号；
（2）两端设备打开Wi-Fi和蓝牙开关，连接相同局域网，可提升数据传输的速度；
（3）应用接续只能在同应用（UIAbility）之间触发，双端设备都需要有该应用；
（4）在onContinue回调中使用wantParam传输的数据需要控制在100KB以下，大需数据的情况，要使用分布式数据对象或分布式文件系统。例如图片文件。
申请权限，需要在module.json5里的module对象的requestPermissions如下申请：
关键代码
这部分代码是写在EntryAbility中，不是在Page页中，与Page页中的数据交互，使用AppStorage可持续保存，双向绑定数据，当数据变化时改变视图。
接收端实现onCreate接口和onNewWant接口，onCreate接口：冷启动或多实例热启动时调用，onNewWant接口：单实例热启动。
```typescript
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
DataUtils.context = this.context;
if (launchParam.launchReason === AbilityConstant.LaunchReason.CONTINUATION) {
this.setWantData(want);
}
Logger.info(this.tag, '%{public}s', 'Ability onCreate');
}
onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {
if (launchParam.launchReason === AbilityConstant.LaunchReason.CONTINUATION) {
this.setWantData(want);
}
}
private setWantData(want: Want) {
if (want.parameters !== undefined) {
let title = want.parameters[CommonConstants.KEY_TITLE];
let description = want.parameters[CommonConstants.KEY_DESCRIPTION];
let filesName = want.parameters[CommonConstants.KEY_PICTURE_PATHS] as string;
AppStorage.setOrCreate(CommonConstants.KEY_TITLE, title);
AppStorage.setOrCreate(CommonConstants.KEY_DESCRIPTION, description);
let filesArr = filesName.split(this.splitSymbol);
if (filesArr === undefined) {
filesArr = [];
}
AppStorage.setOrCreate(CommonConstants.KEY_PICTURE_PATHS, filesArr);
} else {
Logger.warn(this.tag, 'want.parameters is undefined！');
}
this.context.restoreWindowStage(new LocalStorage());
}
```
受限于文件大小，图片的流转需要借助分布式文件系统，以下是文件的发生与接收方式：
发送侧：
```typescript
static sendCloudFile(context: Context, uriArr: string[]) {
uriArr.forEach((uri: string) => {
FileUtils.copyToDistributedDir(context, uri);
});
}
static copyToDistributedDir(context: Context, uri: string) {
try {
Logger.info(FileUtils.tag, 'copyToDistributedDir path = ' + uri);
let buf = new ArrayBuffer(CommonConstants.FILE_BUFFER_SIZE);
let readSize = 0;
let file = fileIo.openSync(uri, fileIo.OpenMode.READ_ONLY);
let readLen = fileIo.readSync(file.fd, buf, { offset: readSize });
let fileName = file.name;
let destinationDistribute = fileIo.openSync(`${context.distributedFilesDir}/${fileName}`,
fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
while (readLen > 0) {
readSize += readLen;
fileIo.writeSync(destinationDistribute.fd, buf);
readLen = fileIo.readSync(file.fd, buf, { offset: readSize });
}
Logger.info(FileUtils.tag, 'copyToDistributedDir destinationDistribute = ' + destinationDistribute.path);
fileIo.closeSync(file);
fileIo.closeSync(destinationDistribute);
} catch (err) {
Logger.error(FileUtils.tag, `copyToDistributedDir failed. Code: ${err.code}, message: ${err.message}`);
}
}
```
```typescript
private static copyToFilesDir(context: Context, nameArr: string[], state: number, callback: Function) {
if (state === nameArr.length) {
return;
}
let fileName = nameArr[state];
let filesDir: string = context.filesDir;
let distributedFilesDir: string = context.distributedFilesDir;
let srcUri: string = fileUri.getUriFromPath(distributedFilesDir + `/${fileName}`);
let destUri: string = fileUri.getUriFromPath(filesDir + `/${fileName}`);
let options: fs.CopyOptions = {
"progressListener": (progress: fs.Progress) => {
if (progress.processedSize === progress.totalSize) {
Logger.info(FileUtils.tag, 'copyToFilesDir success copied!');
FileUtils.handleNextCopy(context, nameArr, state, callback);
}
}
}
try {
fs.copy(srcUri, destUri, options).then(() => {
Logger.info(FileUtils.tag, 'copyToFilesDir success copying!');
}).catch((error: BusinessError) => {
let err: BusinessError = error as BusinessError;
Logger.error(FileUtils.tag, `copyToFilesDir failed to copy. Code: ${err.code}, message: ${err.message}`);
FileUtils.handleNextCopy(context, nameArr, state, callback);
});
} catch (err) {
Logger.error(FileUtils.tag, `copyToFilesDir failed to copy. Code: ${err.code}, message: ${err.message}`);
FileUtils.handleNextCopy(context, nameArr, state, callback);
}
}
```
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-device-scenario
爬取时间: 2025-05-01 08:39:43
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-cell-phone
爬取时间: 2025-05-01 08:39:56
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-foldable-guide
爬取时间: 2025-05-01 08:40:24
来源: Huawei Developer
概述
折叠屏产品
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151343.73076791978538430498401680851345:50001231000000:2800:662C80EDFD986CE0A70A99239FF8BA208BD845B16FDF553ED8843923267DDED8.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151344.35435903086910309999020270186113:50001231000000:2800:7EB11F0CE3A08AEA7348E5A06F713221AE8855BEF82EBBD62FDA367C07FD4AFD.jpg)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151345.12996115830175570236693871045937:50001231000000:2800:E025150CE3E45CAF156658CCCBF941E50FC1B57B6B9565899DC34B28B832C686.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151345.31785400748812930262843218252295:50001231000000:2800:0C8320DCB8B7ADE3C85430D139FFF30DB3F11271C5571DF9190F199994823BB0.png)
折叠状态
-  三折叠屏的更多折叠状态，请参考折叠状态枚举。
体验设计点
折叠屏相对于普通手机有一个明显的特点：可随时折叠展开、折叠展开会导致屏幕属性改变。
为了能够充分利用折叠屏的特点，提供良好的使用体验，折叠屏UX设计中需考虑如下体验诉求：
1.  屏幕可随时折叠展开，在体验上要保证用户体验的连续性，应用需要遵从屏幕显示的兼容和应用状态的连续。
2.  屏幕尺寸变大后，用户体验在某些方面有增值：
折叠屏UX体验标准
本标准从影响用户体验的各个维度定义了相应测试规范，规定了应用需达到的基础体验要求，用于引导应用的设计与开发，以保证应用良好的使用体验。
折叠屏需要遵循的UX体验标准包括：
开合连续性
| 简介  | 描述  |
| --- | --- |
| 标准描述  | 应用在设备折叠/展开后不应出现操作步骤增加，操作更复杂等体验下降的情况。例如：页面切换到其他页面、页面滚动位置发生偏移、输入内容丢失、图片模糊、播放进度变化等。  以大折叠为例，页面滚动位置不偏移的示例  |
| 测试方法  | 设备展开/折叠，观察开合转换过程和页面布局。  |
| 判定标准  | 设备开合过程流畅，不卡顿，界面布局正常，操作交互正常。  |
| 标准等级  | 必须  |
| 适用设备类型  | 折叠屏  |
| 需考虑的特殊事项  | 无  |
简介
描述
标准描述
应用在设备折叠/展开后不应出现操作步骤增加，操作更复杂等体验下降的情况。例如：页面切换到其他页面、页面滚动位置发生偏移、输入内容丢失、图片模糊、播放进度变化等。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151346.66353250208363124559169285144564:50001231000000:2800:DD5C597DBFB614AD86C4B8471B0B2B83CC0D96347D0F2D171DE2F7861B451816.png)
以大折叠为例，页面滚动位置不偏移的示例
测试方法
设备展开/折叠，观察开合转换过程和页面布局。
判定标准
设备开合过程流畅，不卡顿，界面布局正常，操作交互正常。
标准等级
必须
适用设备类型
折叠屏
需考虑的特殊事项
无
开合过程包含折叠状态和展开状态下的两种页面布局，通过显示窗口的属性（宽度和高宽比）决定开合过程前后的页面布局。系统侧设计了横向和纵向断点分别代表窗口宽度和窗口高宽比，页面布局的一多要求使用横向和纵向断点进行判断实现，更多详情请参考一多断点开发实践。
折叠屏页面布局的判断条件不推荐使用以下接口，否则可能带来不同屏幕尺寸折叠屏下的布局混乱问题。
除页面布局的判断不能使用deviceType/isFoldable/getFoldStatus/getFoldDisplayMode外，应用的其他逻辑可以使用display的开合能力来满足开合场景下不同需求。常见display API如下：
| API  | 说明  |
| --- | --- |
| display.isFoldable  | 检查设备是否可折叠  |
| display.getCurrentFoldCreaseRegion  | 在当前模式下获取折叠折痕区域  |
| display.getFoldStatus  | 获取可折叠设备的当前折叠状态  |
| display.getFoldDisplayMode  | 获取可折叠设备的显示模式  |
| display.on('foldStatusChange')  | 开启折叠设备折叠状态变化的监听  |
| display.off('foldStatusChange')  | 关闭折叠设备折叠状态变化的监听  |
| display.on('foldDisplayModeChange')  | 开启折叠设备屏幕显示模式变化的监听  |
| display.off('foldDisplayModeChange')  | 关闭折叠设备屏幕显示模式变化的监听  |
API
说明
display.isFoldable
检查设备是否可折叠
display.getCurrentFoldCreaseRegion
在当前模式下获取折叠折痕区域
display.getFoldStatus
获取可折叠设备的当前折叠状态
display.getFoldDisplayMode
获取可折叠设备的显示模式
display.on('foldStatusChange')
开启折叠设备折叠状态变化的监听
display.off('foldStatusChange')
关闭折叠设备折叠状态变化的监听
display.on('foldDisplayModeChange')
开启折叠设备屏幕显示模式变化的监听
display.off('foldDisplayModeChange')
关闭折叠设备屏幕显示模式变化的监听
需要注意的是，若需要获取折叠屏的状态变化后，屏幕的宽高等信息，需要使用display.on('foldDisplayModeChange')接口进行监听。如果使用display.on('foldStatusChange')监听，将出现因接口调用时序问题导致的获取宽高错误问题。示例代码如下：
开合流畅
| 简介  | 描述  |
| --- | --- |
| 标准描述  | 折叠屏折叠展开时，变化过程有连续动效，而不是硬切换。  |
| 测试方法  | 对折叠屏进行折叠展开操作，观察界面动效。  |
| 判定标准  | 在折叠屏折叠展开过程中，界面动效自然流畅，无卡顿等异常。  |
| 标准等级  | 推荐  |
| 适用设备类型  | 折叠屏  |
| 需考虑的特殊事项  | 无  |
简介
描述
标准描述
折叠屏折叠展开时，变化过程有连续动效，而不是硬切换。
测试方法
对折叠屏进行折叠展开操作，观察界面动效。
判定标准
在折叠屏折叠展开过程中，界面动效自然流畅，无卡顿等异常。
标准等级
推荐
适用设备类型
折叠屏
需考虑的特殊事项
无
悬停适配
| 简介  | 描述  |
| --- | --- |
| 标准描述  | 长视频、短视频、直播、通话、会议、拍摄类应用需针对折叠屏的悬停态进行单独适配。在界面布局设计时充分考虑悬停态下不同屏幕区域的可视角度及交互难易度。下半屏区域内可放置交互操作，上半屏区域内进行信息显示，呈现浏览型内容。交互型控件，例如弹出框、半模态，在下半屏显示；跟随上下文的控件，例如菜单，跟随触发元素所在侧的屏幕显示。   大折叠悬停态适配的示例   |
| 测试方法  | 在设备悬停态下，观察应用界面的信息显示和交互。  |
| 判定标准  | 应用能正常适配悬停态，在悬停态下半屏区域内可进行交互操作，上半屏区域内内容信息显示正常。  |
| 标准等级  | 涉及则必须  |
| 适用设备类型  | 折叠屏  |
| 需考虑的特殊事项  | 无  |
简介
描述
标准描述
长视频、短视频、直播、通话、会议、拍摄类应用需针对折叠屏的悬停态进行单独适配。在界面布局设计时充分考虑悬停态下不同屏幕区域的可视角度及交互难易度。下半屏区域内可放置交互操作，上半屏区域内进行信息显示，呈现浏览型内容。交互型控件，例如弹出框、半模态，在下半屏显示；跟随上下文的控件，例如菜单，跟随触发元素所在侧的屏幕显示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151347.66406251870972860571096268230299:50001231000000:2800:4D136DC3B07EFD6DE6767B9419D693515019EA9C4C82AC4FE1971C14D59CFA7F.png)
大折叠悬停态适配的示例
测试方法
在设备悬停态下，观察应用界面的信息显示和交互。
判定标准
应用能正常适配悬停态，在悬停态下半屏区域内可进行交互操作，上半屏区域内内容信息显示正常。
标准等级
涉及则必须
适用设备类型
折叠屏
需考虑的特殊事项
无
折痕避让
| 简介  | 描述  |
| --- | --- |
| 标准描述  | 悬停态时，中间弯折区域难以操作且显示内容会变形。长视频、短视频、直播、通话、会议、拍摄类应用需针对折痕区域进行避让适配。  大折叠折痕避让的示例   |
| 测试方法  | 在设备悬停态下，观察应用对折痕区域的适配。  |
| 判定标准  | 应用能进行折痕避让。  |
| 标准等级  | 涉及则必须  |
| 适用设备类型  | 折叠屏  |
| 需考虑的特殊事项  | 无  |
简介
描述
标准描述
悬停态时，中间弯折区域难以操作且显示内容会变形。长视频、短视频、直播、通话、会议、拍摄类应用需针对折痕区域进行避让适配。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151347.97450370299975003569003946213318:50001231000000:2800:00A21987B45C6611E5E12F14C187C9355C0E713313701049F4151EBD5AA67100.png)
大折叠折痕避让的示例
测试方法
在设备悬停态下，观察应用对折痕区域的适配。
判定标准
应用能进行折痕避让。
标准等级
涉及则必须
适用设备类型
折叠屏
需考虑的特殊事项
无
横竖屏适配
| 简介  | 描述  |
| --- | --- |
| 标准描述  | 应用支持在大折叠展开态、平板设备上的横竖屏切换显示。 屏幕比例接近 1:1 的设备，横竖屏布局需保持一致。  大折叠的横屏响应式布局适配示例  平板的横屏响应式布局适配示例  比例接近 1:1 的屏幕上横竖屏布局一致的示例   |
| 测试方法  | 设备旋转，观察横竖屏切换旋转过程和横竖屏的界面布局。  |
| 判定标准  | 适配横屏显示，横竖屏切换过程流畅，不卡顿；屏幕比例接近 1:1 时横竖屏布局正常且一致。  |
| 标准等级  | 必须  |
| 适用设备类型  | 折叠屏、平板、PC/2in1  |
| 需考虑的特殊事项  | 无  |
简介
描述
标准描述
应用支持在大折叠展开态、平板设备上的横竖屏切换显示。
屏幕比例接近 1:1 的设备，横竖屏布局需保持一致。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151347.59357126764925937488430565918498:50001231000000:2800:E0EAA546A4EF5F62FCCDBB78CC086480B7E1C8A4E72B46FBC90284DB673A2BC5.png)
大折叠的横屏响应式布局适配示例
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151348.01321907535644464867509949575828:50001231000000:2800:03F98C362345D25DA2F5593C4EACDDE29EA8118B88E3C577DD905C55EAC62FCE.png)
平板的横屏响应式布局适配示例
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151348.57066623279704735893381428193622:50001231000000:2800:6756A6DBB6FFBCE52F0C9680EDFD6E7ABE8BBE8380B2D3942B5542945B4E3340.png)
比例接近 1:1 的屏幕上横竖屏布局一致的示例
测试方法
设备旋转，观察横竖屏切换旋转过程和横竖屏的界面布局。
判定标准
适配横屏显示，横竖屏切换过程流畅，不卡顿；屏幕比例接近 1:1 时横竖屏布局正常且一致。
标准等级
必须
适用设备类型
折叠屏、平板、PC/2in1
需考虑的特殊事项
无
多窗适配
| 简介  | 描述  |
| --- | --- |
| 标准描述  | 应用适配竖向悬浮窗、左右分屏、上下分屏，且确保该形态下有较好的适配效果，能完成全流程交互。例如上下分屏时，不出现弹出框过大无法点击关闭按钮，导致交互中止等问题；不出现内容显示过大导致交互效率低浏览体验差等问题。 视频、游戏类应用需要适配横向悬浮窗。应用在平板设备上需适配支持窗口大小变化调整，确保应用内容显示无异常。  竖向悬浮窗、横向悬浮窗  左右分屏、上下分屏  |
| 测试方法  | 在设备上启动悬浮窗、分屏，观察是否能正常触发多窗，多窗的显示布局是否正常，应用是否正常运行。  |
| 判定标准  | 设备能正常启动悬浮窗、分屏，且悬浮窗和分屏内布局正常，不出现卡顿、闪退、闪屏、变形、错位等情况。  |
| 标准等级  | 必须  |
| 适用设备类型  | 折叠屏、平板、PC/2in1  |
| 需考虑的特殊事项  | 无  |
简介
描述
标准描述
1.  例如上下分屏时，不出现弹出框过大无法点击关闭按钮，导致交互中止等问题；不出现内容显示过大导致交互效率低浏览体验差等问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151348.92660744036665781545749938192087:50001231000000:2800:7AD84F711F9E52C90A694D3DB43CB3ABE59B707AB9A61E471BAE51AD03865910.png)
竖向悬浮窗、横向悬浮窗
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151349.07920590700255271399287759947438:50001231000000:2800:041FA6E5E19F6249AAD5E2ABFA5F55487385406890605F828A4E2FA37FB1E6BD.png)
左右分屏、上下分屏
测试方法
在设备上启动悬浮窗、分屏，观察是否能正常触发多窗，多窗的显示布局是否正常，应用是否正常运行。
判定标准
设备能正常启动悬浮窗、分屏，且悬浮窗和分屏内布局正常，不出现卡顿、闪退、闪屏、变形、错位等情况。
标准等级
必须
适用设备类型
折叠屏、平板、PC/2in1
需考虑的特殊事项
无
上下图文信息量适中
| 简介  | 描述  |
| --- | --- |
| 标准描述  | 上下图文结构中，建议信息流场景的图片左对齐，阅读场景的图片居中对齐。图片的物理尺寸：折叠屏上展开态图片的放大倍数建议不超过 1.2 倍；平板上比直板机放大不超过 1.5 倍。图片放大不超过 1.2/1.5 倍且满足控件高度占比要求 (推荐)。 图片放大倍数不超过 1.2/1.5 倍或满足控件高度占比要求 (必须)。 在平板、折叠屏展开态等宽屏设备上最好通过延伸布局、挪移布局等方式让图文进行合理布局，避免图片过高。上下图文控件高度占比要求如下：首页入口型的上下图文，不建议使用长图，宽图或方图的最大高度不要超过屏幕高度的 1/3。首页信息流结构的上下图文，图片最大高度不超过屏幕高度的 2/5;详情页内容型的上下图文，最大高度不要超过屏幕高度的 3/5。   大折叠展开/折叠，观察开合转换过程和页面   大折叠详情页上下图文示例  |
| 测试方法  | 在大尺寸屏幕 (折叠屏/平板) 设备上，观察和获取内容放大倍数和控件占比。  |
| 判定标准  | 内容放大倍数不超过 1.2，控件高度占比满足规范要求。  |
| 标准等级  | 必须  |
| 适用设备类型  | 折叠屏、平板、PC/2in1  |
| 需考虑的特殊事项  | 无  |
简介
描述
标准描述
1.  图片放大不超过 1.2/1.5 倍且满足控件高度占比要求 (推荐)。 图片放大倍数不超过 1.2/1.5 倍或满足控件高度占比要求 (必须)。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151349.38041113370735954160417033075715:50001231000000:2800:084383F9F8C438EAEFCA7D53DA98756D065FC5D6EB8BF2C1BBDDC3BD410270E7.png)
大折叠展开/折叠，观察开合转换过程和页面
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151349.26954522090981141486173579977164:50001231000000:2800:A91D00AB218272CD5808F1DCBADBCF1FC04E792A620DE4155CE85924C7B5B3F2.png)
大折叠详情页上下图文示例
测试方法
在大尺寸屏幕 (折叠屏/平板) 设备上，观察和获取内容放大倍数和控件占比。
判定标准
内容放大倍数不超过 1.2，控件高度占比满足规范要求。
标准等级
必须
适用设备类型
折叠屏、平板、PC/2in1
需考虑的特殊事项
无
折叠屏需要同时参考通用应用、大屏应用、折叠屏应用的UX体验标准。
折叠屏应用开发指导
随着终端设备形态日益多样化，应用设计需要考虑界面能否适配不同的屏幕尺寸、屏幕方向和设备类型。同时还需要保持多设备体验的连续性，改善多端独立的设计、尽可能降低开发者的工作量和维护成本。基于此 HarmonyOS 为设计师提供了面向多设备的设计指导，让设计师在进行多端设计时有一套科学的方法，最大程度减少设计的工作量，保障多端设计在一定程度的一致性。同时 HarmonyOS 也提供了对应的技术能力，帮助开发者快速地进行多端应用设计。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151350.53082132923569671369799633626667:50001231000000:2800:4348D527A31713B9E33257755E549B53BEA04DEAE8525F9D023A1D55C0FB047C.png)
本指导结合用户在多端设备上的历史交互习惯、各场景下的使用诉求等，进行了一些设计方法的总结，主要包括如下几个部分：
基本要求
折叠屏应用开发具有导航、横竖屏、挖孔、多窗、弹出框等基础要求。
导航适配
1.底部导航&侧边导航
通常手机和大折叠使用底部页签导航；平板及其他宽屏设备使用侧边页签或侧边栏导航。调用系统提供的控件可自动适配该导航规则。
查看更多底部导航&侧边导航的设计规范&开发指导，点击访问。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151351.89984279676828951468206973146118:50001231000000:2800:04B441EB7F528C9BE1F29918F523746119D26BC05253CE8E02C4DA0CFFA09C9A.png)
2.底部导航条适配
移动端设备应用内的底部页签、底部工具栏、底部文本，或底部悬浮按钮需要自动抬高避让底部导航条。应用内的可滚动内容，可直接显示在导航条下方，仅当滚动到内容的最底部时需要向上抬高避免被底部导航条遮挡。调用控件，可自动实现以上导航条的避让规格。
沉浸式页面，例如全屏播放视频、游戏、阅读等场景下，超过 2 秒自动隐藏底部导航条，从底部上滑或从顶部下滑可触发恢复显示底部导航条。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151351.85513644699142461924217354076758:50001231000000:2800:AB104BC0288EC71776802EDA80F686DAC82F4509B20C94CD2AD406E03C106A67.png)
横竖屏与挖孔适配
手机和大折叠折叠态的应用通常需要适配竖屏布局。仅部分特殊场景例如横屏游戏、长视频需要适配横屏布局。
大折叠展开态、平板上，应用需要同时适配横屏和竖屏布局。
当设备尺寸比例接近 1:1 时，建议横竖屏使用相同或相近的布局。
当设备尺寸比例差异大时，横竖屏可以使用不同的布局，从而提供更好的使用体验，例如横屏后自动分栏或横屏后自动露出右侧的辅助信息等。
横竖屏适配过程中，需要考虑核心内容或重要交互不要被挖孔区遮挡，如果被遮挡则进行局部内容等避让；可滚动内容或非核心信息无需专门避让挖孔区；要避免因为避让挖孔导致左右侧留白不一致。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151351.05655274107876355881908472735082:50001231000000:2800:57825FF92F65BBD540B464602794A6ECA097E89291CC77C3FBD0B2716CACFD7D.png)
1.横竖屏适配
实现方案
| 设备场景  | 是否需要支持横竖屏旋转  |
| --- | --- |
| 手机（直板机）  | 由应用决定是否需要支持，默认不支持  |
| 小折叠（Pocket系列）  | 内屏（展开状态）：同直板机手机  |
| 大折叠（Mate X系列）  | 内屏（展开状态）：类方屏需要支持 外屏（折叠状态）：同直板机手机  |
| 三折叠（Mate XT系列）  | F态（单屏显示）：同直板机手机 M态（双屏显示）：类方屏需要支持 G态（三屏显示）：需要支持  |
| 阔折叠（Pura X系列）  | 内屏（展开状态）：类方屏需要支持 外屏（折叠状态）：同直板机手机  |
设备场景
是否需要支持横竖屏旋转
手机（直板机）
由应用决定是否需要支持，默认不支持
小折叠（Pocket系列）
内屏（展开状态）：同直板机手机
大折叠（Mate X系列）
内屏（展开状态）：类方屏需要支持
外屏（折叠状态）：同直板机手机
三折叠（Mate XT系列）
F态（单屏显示）：同直板机手机
M态（双屏显示）：类方屏需要支持
G态（三屏显示）：需要支持
阔折叠（Pura X系列）
内屏（展开状态）：类方屏需要支持
外屏（折叠状态）：同直板机手机
实现横竖屏适配的代码请参考窗口横竖屏旋转适配。
多窗适配
在手机和折叠屏折叠态、展开态，应用需要适配竖向悬浮窗、上下分屏、左右分屏、分屏比例支持自由调节。仅部分特殊场景例如横屏游戏、长视频，需要适配横向悬浮窗。
平板及更宽的设备上 ，应用需要适配自由窗口（即可任意拖大、拖小、拖宽、拖窄），横屏时支持左右分屏，竖屏时支持上下分屏，且支持分屏比例的自由调节。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151351.03119456075818664627225649845588:50001231000000:2800:E942E0287E4268857E65C07B6A379A40A0EC81AB6476EBFA767CD7A1810A6FA1.png)
在多端设备上，长视频、直播、会议、通话等场景，需要支持画中画。查看更多多窗的适配设计规范，系统特性>多窗口交互。
多窗适配案例可以参考：智慧多窗。
弹出框适配
建议调用系统的弹出框控件，避免在宽屏设备上弹出框过宽或过高的问题。
若应用自定义弹出框尺寸，则建议在 8 栅格及以上的设备上，弹出框宽度为 480vp；宽屏设备上弹出框的物理高度不超过手机上的该弹出框高度的 1.5 倍。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151352.25609876576423670727865841719786:50001231000000:2800:5D96A24A855AF127087F10E5CBF4C6EA7588E0FC9B8FC5B40E70BAE89515CBDB.png)
键鼠适配
平板及更宽的设备上的应用需要进行基础的鼠标、键盘等适配。详情参考：人机交互。
页面布局
折叠屏应用的页面布局包括响应式布局与Web页面布局。
1.响应式布局
应用内的页签、搜索、入口图标、广告图、列表、卡片、图片、内容模块等可以灵活地通过形变、延伸布局、重复布局、挪移布局、宫格布局、瀑布流布局等进行宽屏设备上的响应式适配，以达到较好的信息量和舒适的浏览体验。
查看更多布局相关的设计规则，点击访问。
1.1子页签&搜索
手机和大折叠折叠态，搜索和子页签分两排显示。
大折叠展开态、平板及更宽的设备上，子页签和搜索可以同一排显示，搜索框根据子页签数量的多少而自适应调整长度。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151352.28082923130245887032394878148707:50001231000000:2800:4ED08DBCAEB7D84B4C47FB9F87D179DD4CA40C428BA1855CBA30E6A3F4A59633.png)
实现方案参考典型布局场景。
1.2入口图标
在多端设备上，建议 1 行显示的入口图标数量限制在一定范围内。例如在大折叠和平板竖屏上一排图标不超过 8 个，在平板横屏上一排图标不超过 13 个，要避免一排图标过多导致信息过密。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151352.22561917229969971085110357152649:50001231000000:2800:95482133D8CCCB9C09AF164E2372335E38AAD105D9F3A24679E449852B65B493.png)
实现方案参考典型布局场景。
1.3广告图
1.3.1卡片广告
在宽屏设备上建议使用延伸布局和形变进行卡片广告的响应式适配。
例如手机上一张广告卡片，在折叠屏可显示两张广告卡片，在平板显示三张广告卡片。同时基于各端的物理尺寸可进行广告卡片的自适应形变，在宽屏设备上广告卡片更长，在窄屏设备上广告卡片更高。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151353.37442535446147161420933062847728:50001231000000:2800:446DF7D58E10856618509542D983D7C39C31670DECC65869D9C4645F049AB61C.png)
实现方案参考典型布局场景。
1.3.2沉浸广告
音视频等应用，为提供更沉浸的影音娱乐体验，可使用沉浸广告图效果。
应用使用沉浸广告时，建议沉浸广告的背景和广告内容元素分为多个图层，且为宽屏设备提供更长的背景图，或通过智能裁剪为不同宽度的设备裁剪出合适高度的背景图。保持背景图横向铺满整个设备宽度，且要避免背景图过高。广告的图片、文本等内容元素在宽屏设备上使用响应式布局。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151353.79929590805984941024976113572937:50001231000000:2800:99E676F9063BCAEB138DB594D35C458E84BFFDCC90BE95F9F379BFC9610F4E4C.png)
金融理财、生活服务等类型的应用也经常使用沉浸广告图打造更好的营销氛围。需要考虑为多端提供一个适宜的沉浸广告高度，避免在宽屏设备上等比放大导致整个广告过高，导致首屏的信息量过少。
折叠屏和平板横屏时，建议沉浸广告图不超过 0.5 倍的屏幕高度，平板竖屏时建议沉浸广告图不超过 0.4 倍的屏幕高度。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151353.97453783904809694781921373642977:50001231000000:2800:D740392D5551E65CC9356DD7F38BB92770DAFC2D55C9EE2243250189DA8A4E17.png)
参考增值体验-沉浸广告。
1.4列表
1.4.1列表的重复布局
在宽屏设备上，为避免结构过于单调且信息量过少，可通过重复布局来改善页面的浏览舒适度和使用效率。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151353.91103670628689396536853328508128:50001231000000:2800:1D4362B005DA0C4A8577021E8DA4C344F09D5AC1D2FA46194141B658D3F22CB3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151353.31035243697085853216145174650226:50001231000000:2800:57FF6E20B85E160B905A650D8BABCC7535AAD56868AED2C9F16767A587B2BA65.png)
实现方案参考典型布局场景-重复布局。
1.4.2列表的挪移布局
列表结构中的大视频或单张大图片，在宽屏设备上也可以通过图文挪移布局来避免视频或图片显示过大。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151354.38849455463605758449229180170776:50001231000000:2800:4D4FDAC9E42C61125FA635B2DE357409CC6FA8D427E5FFEC979E1B95A1C67963.png)
实现方案参考典型布局场景-挪移布局。
1.4.3多列瀑布流
可以通过从单列瀑布流到多列瀑布流的布局变化，带来宽屏设备上更舒适的增值阅读体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151354.12034451380101060115143947554409:50001231000000:2800:08649A2EE06A2D9A7B50EF0AFF43E718969B7570E8FF14A46D7579FF715AB7D6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151354.26455632788826217455294498784682:50001231000000:2800:AABB5B7813847DBDBCE98F07B54389538FDBBC4B6AA24710E682CBDFF5AC58C7.png)
实现方案参考一多开发实例（社区评论）-单列卡片变瀑布流布局。
1.5卡片
手机上的单列的卡片，在宽屏设备上，通过分栏 + 瀑布流/宫格布局的方式进行显示适配，提升浏览效率且提供舒适布局。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151355.44406058842399624567116455016388:50001231000000:2800:AD307212EAE65A9144E570F80189CFA7ADEED1797DA7CB01F8EF3FF98B7657EC.png)
实现方案参考一多开发实例（社区评论）-动态卡片。
1.6详情大图
在宽屏设备上，页面内的大图可以通过延伸布局或挪移布局进行适配。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151355.74640651548395911555163487063173:50001231000000:2800:A0325ABB7C62D351C5B377DB7E5D8ED5907746A42B8AF3242D1E06AA0171DA2F.png)
实现方案参考典型布局场景-挪移布局。
1.7内容模块
同一个设备上，也可以根据多个模块的内容尺寸进行自适应的挪移布局。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151355.75982766133130917996765152049210:50001231000000:2800:605DA8C66CAF0D6BA344823939CF6C4A7B7DA9A607931D2AB40B2BE78C35768E.png)
实现方案参考典型布局场景-挪移布局。
2.Web页面布局
Web页面布局中讲述文字、图片、宫格元素、弹窗、广告、轮播图等的适配问题及实现方案。
2.1大折叠文字大小适配
展开态字体大小与折叠态一致。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151355.01667748337451435704830656073909:50001231000000:2800:F08D9BD5579CF070F667A0D2A08A7813259AC00C8CC1DDAEA2AF75628F32A9A3.png)
两种实现方案
参考代码
2.2大折叠展开态图片适配
图片放大导致显示信息减少。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151355.27147504258868952525407244794075:50001231000000:2800:4C9B211B130FCBD9374E34BE8B772C3A8F922B7BCEA44770D633488622BA709D.png)
图片大小与折叠态相似、单张图片的情景。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151355.26135307501586189542914096651324:50001231000000:2800:6CB377DC5B94BB31CA4378BAD55FA9538AF85053758D16515C0D3DF6FA60657A.png)
实现方案
通过 @media 样式，设置图片元素或其容器在大折叠展开态时的尺寸为原来的约1/2，即约为折叠态的1倍大小。
参考代码
2.3折叠屏展开态下图标元素自适应
图标元素放大，导致页面整体显示信息减少。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151356.65445884835847136417206982472170:50001231000000:2800:34046E4AE33992BA32D87D0DD77F677296F70D16404D9C4369CD4D2628F39E4C.png)
图标元素尺寸不变，页面整体显示信息不变或增加。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151356.59661870693258355320858224368551:50001231000000:2800:F51549E449A6A5606B65D931B227055BFD14128D13FF7B22E5528CE631850293.png)
实现方案
将重复元素的尺寸设定为绝对值、将重复元素容器的宽度设置为相对值。
参考代码
2.4大折叠展开态下宫格元素自适应
宫格元素放大，导致显示信息减少。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151356.90792919361421332734045072452333:50001231000000:2800:4FB21FB160AA31C51298C7DBD278E0E2DC36F859D31792FF1A079F23969A5C42.png)
宫格元素两列变三列，显示内容增多。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151356.15050622825883230333753848278346:50001231000000:2800:B1098D471B3467069FF86DDF41B8CF1E2E6A9A4E91FB5E1EE992CE057A9A1F87.png)
实现方案
通过 @media 属性，展开态下应用“元素宽高减小至原1/n”的样式，达到列数增加的效果；将容器宽度固定、高度设置为auto。
参考代码
2.5大折叠展开态下弹窗元素大小自适应
弹窗元素过大。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151356.79351811689256959156795515461945:50001231000000:2800:B8620E15A3F64C1F5C29A056853080F5828A0E7781A7D7733DBA986490F38F3F.png)
弹窗元素尺寸与折叠态一致。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151356.11348612550849805379567620401448:50001231000000:2800:7D9FB28F703A25C05A14271D57E1B14D6DA85C12EE3DBDE8233F12C6EC312638.png)
实现方案
通过 @media 样式，设置弹窗元素的容器在大折叠展开态时的相对尺寸为原来的1/2，即约为折叠态的1倍大小。
参考代码
2.6大折叠展开态下广告图大小自适应
广告图尺寸过大，导致一页显示内容过少。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151356.91202371676129712835581118875955:50001231000000:2800:0CDD089BE5278083828885ED9E5007B343A2C0AD5414727CA09C1B802B3C9E07.png)
广告图适当放大后，保留核心内容、裁剪非核心内容。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151356.96841912164788662725063954581848:50001231000000:2800:6762B0A7C588BBA2BDDC51502DC19B51D77D39557C0115A8433639D6B84F03BC.png)
实现方案
通过 @media属性和 overflow:hidden 会隐藏溢出部分的显示的特性，将广告图适当放大后，保留核心内容、裁剪非核心内容。因涉及内容裁剪，请开发者根据UX规范做具体设计。
参考代码
2.7大折叠展开态下横向轮播的运营类图片大小自适应
运营类图片尺寸过大，导致一页显示内容过少。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151356.72522386549676909038959499473480:50001231000000:2800:F669D652786F41F79AE7A69262DFF8BE50D26DD4798353CAFE8BC19F025FE536.png)
弹窗元素尺寸与折叠态一致。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151357.23375027387330483281615375869560:50001231000000:2800:3FB55DD78DE0D103011DDEA0CAEFF358B74EDFBEA1EF941474C825337601774A.png)
实现方案
使用@media属性将图片尺寸减小为原来的1/2、即与折叠态一致；将图片左移25%屏幕宽度的距离，使之居中显示；使用border-right等方法在两张图片之间加入间距。
建议对屏幕尺寸变化事件（"resize"事件）进行监听，在开合动作后重新设置位移，以保持内容显示连续性。
参考代码
常见问题
展开态使用0.5+1+0.5三张图布局时，首图和尾图两侧有留白。
实现方案
在图片列表前、后各补充一张图片，对留白部分进行填充；通过控制图片序号的循环范围，使填充图不显示在画面中央。
参考代码
修改上述代码中的JS部分：
折叠屏悬停
折叠屏悬停描述折叠屏中的折痕避让和悬停适配，下文以大折叠为例介绍折叠屏悬停的一些典型场景。折叠屏悬停态开发可参考折叠屏悬停态开发实践。
1.悬停适配与折痕避让
折叠屏产品具有独特的悬停态，即用户可以将产品半折后立在桌面上，实现免手持的体验。悬停态场景非常适合不需要频繁进行交互的任务，例如视频通话、播放视频、拍照、听歌等。
悬停态时，中间弯折区域难以操作且显示内容会变形，因此建议页面内容进行折痕区避让适配。建议上半屏内容由中线向上下进行避让，避让距离从getCurrentFoldCreaseRegionAPI获取。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151357.42093168523524164132937850759995:50001231000000:2800:938F73CCAD655D9B1A3AC37B82DDC4AE5311DC3DBF57EA69BEFC861812530B46.png)
悬停态若触发应用内的弹出框、半模态等操作型控件，建议交互型控件在下半屏显示；若触发跟随上下文的控件，例如菜单等，建议跟随触发元素的位置显示。控件高度需要根据悬停态的屏幕尺寸进行最大高度的适配。
查看更多悬停态价值场景&适配规范，点击访问。
折痕避让
实现方案
系统提供的FolderStack组件已经实现了折痕自动避让，如果需要实现自定义布局，需要获取折痕区域进行布局避让。获取折痕区域可以使用getCurrentFoldCreaseRegionAPI。
参考代码
```typescript
import display from '@ohos.display';
import { Callback } from '@ohos.base';
@Entry
@Component
export struct Crease {
@State status: string = "1"
// 启动就注册监听
aboutToAppear() {
let callback: Callback<display.FoldStatus> = (data: display.FoldStatus) => {
console.info('Listening enabled. Data: ' + JSON.stringify(data));
// 获取折叠折痕区域，left与top属性为矩形区域的左边界与上边界，width与height属性为矩形区域的宽高。
this.status = data.toString() + "  " + display.getCurrentFoldCreaseRegion().creaseRects[0].left + "  " + display.getCurrentFoldCreaseRegion().creaseRects[0].top
+ "  " + display.getCurrentFoldCreaseRegion().creaseRects[0].width + "  " + display.getCurrentFoldCreaseRegion().creaseRects[0].height;
};
try {
display.on('foldStatusChange', callback);
} catch (exception) {
console.error('Failed to register callback. Code: ' + JSON.stringify(exception));
}
}
build() {
Column() {
Text(this.status).height(50).width("100%").textAlign(TextAlign.Center).fontSize(25).backgroundColor(Color.Red)
}
.height("100%")
.width("100%")
.borderWidth(1)
.backgroundColor(Color.Pink)
.justifyContent(FlexAlign.Start)
}
}
```
悬停适配
实现方案
悬停适配推荐使用FolderStack组件，FolderStack继承于Stack(层叠布局)控件，具有折叠屏悬停能力，通过识别upperItems自动避让折叠屏折痕区后移到上半屏。
参考代码
实现方案
一多开发实例（长视频）
2.典型案例
悬停状态下，界面布局应自动调整。即将浏览型内容上移，在上半屏显示；将操作类控件元素下沉，在下半屏显示。提供更舒适和高效的使用体验。
视频
悬停时，上半屏显示视频画面，下半屏显示视频相关的操作按钮或周边信息。
| 悬停态沉浸式看长视频示例 图1 悬停态在视频详情页看长视频示例  |
| --- |
悬停态沉浸式看长视频示例
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151357.54126521726463629971006469072389:50001231000000:2800:EED4B5FEC0B73B0334865F39CA7085674C87EC6E31AAE1BD3DE531B1324E8F00.png)
参考示例
一多开发实例（长视频）
视频通话
悬停时，上半屏显示通话界面，下半屏显示通话相关的操作按钮。
| 图2 大折叠悬停态的多方通话示例  |
| --- |
| 图3 小折叠悬停态的双方通话示例  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151357.55492209352079916812369724010793:50001231000000:2800:07D75467370615646B8A5CEA4DE6F2383AEEB010ABB8A0670FE357E8A64BB1F7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151357.47825410601144248508778320485828:50001231000000:2800:F1CC4C0402E843E9793B99E09D229330E4D5F72A8F35EC87BCCFFAF445740CCB.png)
短视频
短视频悬停时，头像、评论、视频画面等显示的内容在上半屏展示，输入框等操作在下半屏显示。短视频类应用需要手势操作快速切换视频内容。建议下半屏支持横向滑动切换视频。
健身视频
悬停时，上半屏显示动作跟练视频内容、进度，下半屏显示播放及切换功能。
| 图4 大折叠悬停态看健身视频示例  |
| --- |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151357.45359098176945901845317950467231:50001231000000:2800:85425BA27BEA24A5CE7B4B8EA4EC2E23A17AD01AEB7D21F28C5F117BA3EE02B9.png)
拍摄
悬停时，上半屏显示取景画面，下半屏显示取景模式、拍摄参数控制按钮等操作类功能。
| 图5 大折叠悬停态拍摄示例  |
| --- |
| 图6 大折叠悬停态录制视频示例  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151357.97216560252910150370787668768134:50001231000000:2800:0A0E8C1EA9B3AB322C387528153AD554A63A6FE61AEE2A8944644F851FD43A79.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151358.71816126512811313214118834481212:50001231000000:2800:2DD0EFDF7347835F98062B5C26F9C3708E82EF9867CBEE04DAF0A248D9173585.png)
音频播放
悬停时，上半屏显示专辑封面或歌词、音乐MV，下半屏显示音频播控功能。
增值体验
增值体验中着重描述体验与交互：
1.高效体验
1.1分栏
8 栅格以上的设备可支持分栏，适用的设备包括手机横屏、折叠屏、平板及更宽的设备上等。
办公类、效率型、IM 社交类应用适用于分栏布局，例如系统应用中的邮件、日历、备忘录、文件管理、设置、短信、畅连、联系人等。金融类、电商购物类部分页面，也可以通过分栏提升宽屏上的使用效率。
分栏布局时，允许应用内通过点击“全屏”按钮，从分栏切换至临时全屏或点击“缩小”按钮，从临时全屏恢复分栏。
查看更多分栏相关的设计规范，点击访问。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151358.29241305080097666998149862597039:50001231000000:2800:CBC050685AAF9BB04B5C7C79A017CCEFCA90615B6AAFB036FCF71F1DA0CD4EA5.png)
实现方案
可使用Navigation组件实现分栏。Navigation组件是路由导航的根视图容器，一般作为Page页面的根容器使用，其内部默认包含了标题栏、内容区和工具栏，其中内容区默认首页显示导航内容（Navigation的子组件）或非首页显示（NavDestination的子组件），首页和非首页通过路由进行切换。
参考示例
一多开发实例（即时通讯）
参考代码
1.2应用内分屏
文档编辑、阅读、购物、IM 对话、通话等场景，通常需要进行多个内容对比或多个任务协同。
此类场景下，建议通过页面内的“分屏”按钮触发任务分屏。形成分屏后，“分屏”按钮自动切换为“全屏”按钮，点击“全屏”按钮，即退出另一侧的分屏任务，让当前焦点所在的任务回到全屏。
查看更多应用内分屏相关的设计规范，点击访问。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151358.99810559884096083031720679134369:50001231000000:2800:1559B2673A9A02770B3B7014DC301B56B0EEBB9FD5C080F3D36FF054AF14865C.png)
1.3缩放
瀑布流或宫格布局，建议支持通过双指缩放进行布局列数的调整，从而满足效率型和大图浏览型的不同用户诉求。
新闻详情、网页详情、笔记、文档等图文阅读类页面，建议支持通过双指缩放调整文字大小。
查看更多双指缩放的设计规范，点击访问。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151358.22380824657151302595995552405270:50001231000000:2800:9D8CCEA6A417701D550B38832D239980A6CB4AC4F4C97B70DE90DEDE3CAD2AF2.png)
实现方案
双指缩放属于交互归一的一种基础输入方式，交互归一后开发者就无需关注当前设备的输入方式，只需要在交互归一接口中做逻辑实现即可。双指缩放使用PinchGestureAPI实现。PinchGesture可用于触发捏合手势，触发捏合手势的最少手指为2指，最大为5指。
参考示例
一多开发示例（长视频）- 推荐视频区域的缩放
参考代码
双指缩放图片：
```typescript
@Entry
@Component
export struct PinchImage {
list: string[] = ['image1','image2','image3','image4','image5','image6']
@State GridColumn: string = '1fr 1fr 1fr'
@State GridRow: string = '1fr 1fr'
build() {
Column(){
Grid() {
ForEach(this.list, (item: string) => {
GridItem() {
Text(item)
}.backgroundColor(Color.Grey)
})
}
.columnsTemplate(this.GridColumn)
.rowsTemplate(this.GridRow)
.rowsGap(12)
.columnsGap(12)
}
// 触发双指缩放时，改变Grid的布局
.gesture(PinchGesture({fingers:2}).onActionUpdate((event:GestureEvent)=>{
if (event.scale>1) {
// 增加动画效果
animateTo({
duration: 500
}, () => {
// 双指缩放比例>1时，栅格Grid列数变为2列
this.GridColumn = '1fr 1fr';
})
}else {
animateTo({
duration: 500
}, () => {
// 双指缩放比例<=1时，栅格Grid列数变为3列
this.GridColumn = '1fr 1fr 1fr';
})
}
}))
}
}
```
2.沉浸体验
广告、浏览、观影方面的沉浸体验。
2.1沉浸广告
音视频等应用，为提供更沉浸的影音娱乐体验，或电商购物、金融理财、生活服务等应用为营造营销氛围感，可使用沉浸广告图效果。使用沉浸广告图时，广告图的背景和广告内容元素需要分层，并根据设备的屏幕宽度进行自适应布局。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151359.54259656146464228089281251765458:50001231000000:2800:438A2DD0A68ABE36C1987CDBF4D36683252D960E5103F2DF1788DCE55AB0A5AB.png)
实现方案
广告图的背景使用backgroundImageAPI实现，并使用Row组件显示广告内容文字占位。
参考示例
一多开发实例（长视频）-首页社区页签的沉浸式设计
2.2沉浸浏览
新闻阅读、社交资讯、生活服务、电商、办公等类型的内容，在详情页浏览内容时，可以通过上滑隐藏标题栏、工具栏，下滑或停留超过一定时长恢复显示标题栏、工具栏的方式，提供更沉浸的浏览体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151359.41845870237470675072592567157851:50001231000000:2800:172AC13F9C9631BDBA957262BF196B023E99F21B24E22C00E2DC26617C28EFE1.png)
实现方案
沉浸浏览使用到滚动事件，因此可以在滚动的开始与结束期间隐藏或者展示标题栏、工具栏。以顶部标题栏和底部工具栏的barHeight初始高度56vp为例，barOpacity初始透明度为1。调用Scroll、List和WaterFlow组件的onScrollFrameBegin接口，在滑动过程中，根据当前Y轴滑动的偏移量，逐渐减少标题栏和工具栏的高度和透明度，实现滑动过程隐藏的效果。调用onScrollStart接口，在滑动开始时重置当前Y轴的偏移量。调用onScrollStop接口，在手指离开屏幕且滑动停止时，2秒后使用动画将高度和透明度复原。
参考代码
2.3沉浸观影
全屏播放视频时，建议提供以下两种体验：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151359.01264194516194574251891928251876:50001231000000:2800:E49AEF2919387816891A108B09B26AAE013C5F08119CA0F9D7B58F1FC73DA2D1.png)
实现方案
1. 横向和纵向断点系统
当前断点系统只有横向断点320vp、600vp、840vp、1440vp四个阈值，只用横向断点无法区分直板机、大小折叠机、Pad、HiCar等各种屏幕尺寸，需要增加纵向断点能力。通过横向和纵向断点实现页面布局和各种设备形态解耦，解决多设备布局类问题。
横向断点枚举值：
| 窗口宽度  | 横向断点  |
| --- | --- |
| <320vp  | xs  |
| 320-600vp  | sm  |
| 600-840vp  | md  |
| 840-1440vp  | lg  |
| >1440vp  | xl  |
窗口宽度
横向断点
<320vp
xs
320-600vp
sm
600-840vp
md
840-1440vp
lg
>1440vp
xl
纵向断点根据屏幕Height/Width高宽比划分两个阈值：
| 高宽比  | 纵向断点  |
| --- | --- |
| <0.8  | sm  |
| 0.8-1.2  | md  |
| >1.2  | lg  |
高宽比
纵向断点
<0.8
sm
0.8-1.2
md
>1.2
lg
该断点系统使用举例：我们希望方屏设备都能支持视频全屏不旋转特性，则直接通过纵向断点为md作为判断条件，而大折叠也包含在该断点范围内，未来有新形态近似方屏设备都可以支持该特性，从而实现布局类特性和设备形态解耦。
参考代码
2. 视频全屏播放不旋转特性适配
根据上述断点系统方案，大折叠展开态落入纵向md的断点范围内。
以纵向断点为md作为判断条件，在屏幕尺寸为高宽比接近1:1的方屏时，调用window. setPreferredOrientation () 设置主窗口的显示方向属性为横竖屏旋转，从而实现视频详情页进入全屏播放页时全屏不旋转。
参考代码
```typescript
let heightBreakpoint: string = AppStorage.get('heightBreakpoint') as string;
if (heightBreakpoint === 'md') {
let promise = window.getLastWindow(getContext(this));
promise.then((mainWindow: window.Window) => {
mainWindow.setPreferredOrientation(window.Orientation.AUTO_ROTATION_RESTRICTED);
}).catch((err: BusinessError) => {
console.error(`Failed to obtain the top window. Cause code: ${err.code}, message: ${err.message}`);
});
}
```
参考示例
一多开发实例（长视频）-全屏播放页
3.轻交互
3.1浅层窗口
简单的新建、筛选、添加、浏览，或临时的支付、登录、设置等页面，可以通过浅层窗口避免在宽屏设备上大幅度的页面跳转带来的体验中断。应用可根据自身业务诉求考虑需要调用半模态控件的场景，并选择适合的半模态控件，从而达到浅层窗口的体验。可根据业务特性，采用以下三种浅层窗口样式中的一种。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151359.85145657130726870563440310063364:50001231000000:2800:E65802FF009F575340DC004FE9753593F913ED0ECC906885D8E1335722BCC738.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151400.86424930017209979752593670581890:50001231000000:2800:DAF43BAE065B331AE9E2031B4111F9A13FA93DA66480DA635E2676EB28C0E84E.png)
实现方案
手机端使用半模态转场实现。通过bindSheet属性为组件绑定半模态页面，在组件插入时可通过设置自定义或默认的内置高度确定半模态大小。
大折叠与PC/2in1端使用自定义弹窗实现。
3.2侧边面板
除浅层窗口外，在购物、浏览图片、浏览短视频、查看长视频等场景，可通过侧边面板实现边看边评、边看边买等便捷任务处理的轻交互体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151400.92445330697386861483304733045970:50001231000000:2800:F50AB5163F8BE502016115EE852EB4F99B331DBE0372D8876968D10BBC7D7D76.png)
实现方案
侧边面板可以使用Row组件嵌套两个Column实现。点击评论时控制子元素的宽度来实现侧边面板。
3.3长按预览
系统提供了长按预览的控件能力，接入控件后可以针对视频、附件等卡片实现长按预览播放、长按预览查看详情的体验，且可以在菜单中加入常用功能。
查看更多长按预览菜单的开发指导，点击访问。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151400.73471758731007889464147991730261:50001231000000:2800:3BC5942E6B0CCB0FB2226B3EA0F514F1DF9F74D868EBEE3454E04B143C9CC2C3.png)
实现方案
长按手势事件属于交互归一的一种基础输入方式。长按预览使用LongPressGestureAPI实现。LongPressGesture可用于触发长按手势事件。
参考示例
一多开发实例（长视频）-推荐视频区域长按预览
4.跟手交互
4.1跟手弹框
大折叠展开态和平板的屏幕尺寸较大，弹出框上的操作按钮不易触达。建议针对大折叠展开态、平板等大尺寸的设备，提供跟手的弹出框。
跟手弹出框需要满足以下条件：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151400.94425064421333526882812315018553:50001231000000:2800:43EAF081871FF03297FE9F4470FD82886B8F004C6A371DEE2EB7E95325624460.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151400.54299156023345938999682310563076:50001231000000:2800:49E71A654058950D63D02A6F129B4F6742862F2D768C905F5239D35EB233663B.jpg)
实现方案
跟手弹框参考气泡提示（Popup）组件。Popup属性可绑定在组件上显示气泡弹窗提示，使用bindPopupAPI给组件绑定popup弹窗。
参考代码
```typescript
@Entry
@Component
export struct PopupExample {
@State customPopup1: boolean = false
@State customPopup2: boolean = false
build() {
Row() {
Button("popup1")
.onClick(()=>{
this.customPopup1 = !this.customPopup1
})
// 给组件绑定Popup弹窗，靠近边缘对齐
.bindPopup(this.customPopup1, {
message: "this is a popup1",
popupColor: Color.Pink,
})
Blank()
Button("popup2")
.onClick(()=>{
this.customPopup2 = !this.customPopup2
})
// 给组件绑定Popup弹窗，靠近边缘对齐
.bindPopup(this.customPopup2, {
message: "this is a popup2",
popupColor: Color.Pink,
})
}
.width('100%')
.height('100%')
}
}
```
多设备典型应用案例参考
包括通用、大屏、折叠屏、PC/2in1应用的UX体验标准，详情参考：多设备典型应用案例参考。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-purax-guide
爬取时间: 2025-05-01 08:40:43
来源: Huawei Developer
概述
3月20日，华为正式发布了“阔折叠”设计的手机——Pura X，该机型采用上下折叠的方式，配有一块16:10比例的内屏和一块1:1比例的方形外屏，兼顾大屏沉浸体验与单手便捷操作。阔折叠屏Pura X的外屏，在日常使用中大幅提升了效率和交互体验，用户无需展开手机即可快速完成高频操作，例如：
为充分发挥1:1方形外屏的优势，应用需针对其特殊比例进行适配，优化页面布局与交互逻辑，确保用户在外屏上也能获得流畅、直观的操作体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151401.29010462356438515116244363535106:50001231000000:2800:5A63B15B5D462A0852F0AAAB8FA5659E846F7A2BFE2D634CCE9447CB975B0622.png)
|    | Pura X外屏  | Pura X内屏  |
| --- | --- | --- |
| 示意图  |   |   |
| 折叠状态  | FoldStatus.FOLD_STATUS_FOLDED  | FoldStatus.FOLD_STATUS_EXPANDED  |
| 断点区间  | 横向断点sm，纵向断点md  | 横向断点sm，纵向断点lg  |
Pura X外屏
Pura X内屏
示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151402.60370163323077570276438722868651:50001231000000:2800:AB7CCBFD62A82E70F6E9EE4069D2518502FA6491FC4AAA7EFDD6709E24318D23.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151402.87710367260712529596367146483246:50001231000000:2800:415B33F1152A362EBBEC3695446BDE67C023E91BC5CF5094FDCA8B0D7DDCC925.png)
折叠状态
FoldStatus.FOLD_STATUS_FOLDED
FoldStatus.FOLD_STATUS_EXPANDED
断点区间
横向断点sm，纵向断点md
横向断点sm，纵向断点lg
Pura X开合连续规则：
Pura X的内屏适配，请参考《折叠屏开发实践》和《一多断点开发实践》。
在Pura X的外屏，应用窗口的高度默认减小至约内屏高度的一半。下文将从布局设计的维度，针对Pura X外屏常见的五种开发场景，给出推荐的设计方案与开发指导。
小窗口下的典型布局：
增值体验：
布局设计
本章节将介绍Pura X外屏上推荐的设计方案，保证页面布局能够完整显示，避免出现截断、挤压、堆叠等现象，并充分利用屏幕空间，提供最佳的用户体验。
独特的小窗口布局
应用通常针对类方屏的小窗口页面会设计不同的布局，因此需要在代码中实现响应式布局。一多场景中所有的响应式布局都基于断点来开发，Pura X外屏场景的区分需要在项目中添加横纵断点。断点开发请参考一多断点开发实践。
实现原理
1.  以设置图片的高度为例，在Pura X外屏布局中高度为24vp，内屏时高度为48vp。使用横纵向断点判断，设置具体的属性值。
页面支持滑动
Pura X的外屏，窗口高度会减小至约内屏的1/2，可能导致内屏能够完整显示的内容在外屏上显示不全。推荐使用Scroll组件实现页面支持滑动。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151402.63526104530768371768977127428286:50001231000000:2800:6CAE19E3D775525A331AABBDF0E9FC90773D4F51E3EA1F86116959F5A242868A.gif)
实现原理
设置Scroll组件的scrollBar属性为BarState.Off，控制滚动条不显示。当窗口高度足够显示页面全部内容时，Scroll组件自动失效，页面不可滑动；当窗口高度不足以显示页面全部内容时，Scroll组件自动生效，页面可以滑动。
短视频播放页面
Pura X外屏展示短视频播放页面，要求背景图片（视频）进行等比例缩放，并进行上下沉浸，上方沉浸至顶部标题栏，下方沉浸至底部页签栏。侧边控件可滑动，完整显示页面内容。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151402.99564814551487875694200113926299:50001231000000:2800:D14EDAA2D55589F3265D8ED7D2138B29C20FE927D46D11EA6B0283DFEC6BE04B.gif)
实现原理
使用Stack组件控制页面内容显示层级，控制背景图片上下沉浸，且互相不影响交互事件。Z层级由下到上分别是背景图片（视频）区、底部页签区、短视频描述区、侧边控件区、顶部页签区。顶部和底部页签设置内边距padding为topAvoidHeight或bottomAvoidHeight避让系统规避区。侧边控件区使用Scroll组件自动控制滑动是否生效，使用Blank组件和displayPriority属性控制侧边控件区上下两侧的留白，容器高度足够时上下留白，容器高度不足时自动隐藏。
自定义弹窗适配小窗口
在Pura X外屏上，当窗口高度无法完整显示自定义弹窗时，可能出现弹窗内容截断，需要进行自定义弹窗适配小窗口。效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151402.37401071980687662079570297878228:50001231000000:2800:FA59BE993352C549BC013BCD57AFF2D0362364EC580D1E6EC7D5154C2CAB25C6.gif)
实现原理
使用constraintSize设置约束尺寸，自定义弹窗的最大高度不超过父组件高度的90%。同时最外层使用Scroll组件自动支持滚动。
滑动沉浸式浏览
在Pura X外屏的通用场景下，推荐上滑隐藏、下滑恢复显示。用户可以通过手指向上滑动屏幕临时隐藏掉标题栏、页签栏等界面元素，达到全屏浏览内容的效果，同时手指向下滑动屏幕时，标题栏和页签栏通过动画逐渐显示，从而可以更专注于应用展示的内容。效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151402.12856583474693117757803350633217:50001231000000:2800:6C52199888C9B82BF8FD0716079EFBEA48AF1001166E654BF0BE73B0D63F5B4A.gif)
实现原理
通过滚动时动态调整页面组件高度和透明度，达到视觉上逐渐显示和隐藏的效果。
开发步骤
1.
2.
3.
```typescript
export default class EntryAbility extends UIAbility {
private windowUtil?: WindowUtil = WindowUtil.getInstance();
private onAvoidAreaChange: (avoidArea: window.AvoidAreaOptions) => void = (avoidArea: window.AvoidAreaOptions) => {
if (avoidArea.type === window.AvoidAreaType.TYPE_SYSTEM) {
AppStorage.setOrCreate('topAvoidHeight', px2vp(avoidArea.area.topRect.height));
} else if (avoidArea.type === window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {
AppStorage.setOrCreate('bottomAvoidHeight', px2vp(avoidArea.area.bottomRect.height));
}
};
// ...
onWindowStageCreate(windowStage: window.WindowStage): void {
// Main window is created, set main page for this ability
hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
this.windowUtil?.setWindowStage(windowStage);
windowStage.getMainWindow((err: BusinessError, data: window.Window) => {
if (err.code) {
hilog.error(0x0000, 'testTag', 'Failed to get the main window. Cause: %{public}s', JSON.stringify(err) ?? '');
return;
}
this.windowUtil!.setFullScreen();
// ...
let topAvoidHeight: window.AvoidArea = data.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);
AppStorage.setOrCreate('topAvoidHeight', px2vp(topAvoidHeight.topRect.height));
let bottomAvoidHeight: window.AvoidArea = data.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR);
AppStorage.setOrCreate('bottomAvoidHeight', px2vp(bottomAvoidHeight.bottomRect.height));
data.on('avoidAreaChange', this.onAvoidAreaChange);
if (AppStorage.get('currentWidthBreakpoint') === 'sm' && (AppStorage.get('currentHeightBreakpoint') === 'md' ||
AppStorage.get('currentHeightBreakpoint') === 'sm')) {
// Set top bar height when the application is in small screen.
AppStorage.setOrCreate('topBarHeight', CommonConstants.UTIL_HEIGHTS[1] + px2vp(topAvoidHeight.topRect.height));
} else {
// Set top bar height when the application is in full screen.
AppStorage.setOrCreate('topBarHeight', CommonConstants.UTIL_HEIGHTS[2] + px2vp(topAvoidHeight.topRect.height));
}
})
// ...
}
// ...
}
```
4.
5.
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-tablet-pc
爬取时间: 2025-05-01 08:40:56
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-tablet-2in1-guide
爬取时间: 2025-05-01 08:41:09
来源: Huawei Developer
概述
平板和PC/2in1设备作为常用的移动端设备，在日常生活中发挥着重要作用，也是HarmonyOS 1+8设备全场景一体化体验中不可或缺的一环。为了在平板和PC/2in1设备上开发出体验更好的应用，建议先熟悉设备的独有特性。
设备特性主要包含以下几点：
根据平板和PC/2in1的独特属性，本文将从以下几个方面来介绍开发平板和PC/2in1应用过程中的常见问题，并提供推荐的解决方案或开发指导，以满足用户的最佳体验。
开发在平板或PC/2in1设备上运行的应用，需要在module.json5配置文件的module字段中，增加支持的deviceTypes工程配置。例如，适配平板设备需增设“tablet”，适配PC/2in1设备需增设“PC/2in1”。更多详情可参考deviceTypes标签。
布局设计
因为平板和PC/2in1拥有独特的大尺寸屏幕优势，开发其应用时推荐使用响应式布局实时响应窗口尺寸变化，确保以最佳的布局来展示内容。本章节针对平板和PC/2in1中常用的布局设计提供开发指导，更多的UX设计标准和规范，请参考大屏应用UX体验标准、典型分类应用响应式设计。一多场景中所有的响应式布局都基于断点来开发，需要在项目中添加断点。断点开发请参考多设备断点开发实践。
本章节从五个角度介绍平板和PC/2in1中常用的典型布局：
侧边导航栏
当应用窗口宽度 ≥ 840 vp，且窗口宽度 > 高度时，应用的底部导航栏推荐切换为侧边导航栏。
|  示意图 |  sm |  lg |
| --- | --- | --- |
|  效果示意图 |   |   |
示意图
sm
lg
效果示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151403.86152050099248592460770590683477:50001231000000:2800:C926FEBBC4BBECE80B3CE91CF9432D0810108507B4C5AC9A10C7CF23741E5CE6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151403.05604785135678202901707778559347:50001231000000:2800:7B11C5A629BEE2CCFD6A34E9918888F4E0D6F82951995FFC78FE4BEE16B7F1CB.png)
导航页签使用Tabs组件实现，其参数barPosition支持设置Tabs的位置，属性vertical支持设置页签是否为纵向。分别设置barPosition和vertical的值，可以将页签设置在父容器的左右侧、顶部或底部。
|  属性值 |  vertical = true |  vertical = false |
| --- | --- | --- |
|  barPosition = Start |  容器左侧 |  容器顶部 |
|  barPosition = End |  容器右侧 |  容器底部 |
属性值
vertical = true
vertical = false
barPosition = Start
容器左侧
容器顶部
barPosition = End
容器右侧
容器底部
开发过程中，设置不同断点下barPosition和vertical的值即可。
在多数场景下，窗口宽度 < 840vp，即窗口非lg断点时，页签位于页面底部，此时vertical = false，barPosition = End。
若窗口宽度 ≥ 840 vp，即窗口为lg断点时，页签位于页面左侧，此时vertical = true，barPosition = Start。
在部分平板设备上，应用处于竖屏状态时，宽度 > 840vp，仍推荐采用底部页签。所以需要增加判断条件：若窗口的宽度 < 高度，页签位于底部；否则位于左侧。
在EntryAbility.ets文件中，开启窗口尺寸变化订阅：
```typescript
private windowObj?: window.Window;
private onWindowSizeChange: (windowSize: window.Size) => void = (windowSize: window.Size) => {
AppStorage.setOrCreate('windowWidth', windowSize.width);
AppStorage.setOrCreate('windowHeight', windowSize.height);
};
// ...
onWindowStageCreate(windowStage: window.WindowStage) {
// ...
windowStage.getMainWindow().then((data: window.Window) => {
this.windowObj = data;
AppStorage.setOrCreate('windowWidth', data.getWindowProperties().windowRect.width);
AppStorage.setOrCreate('windowHeight', data.getWindowProperties().windowRect.height);
this.windowObj.on('windowSizeChange', this.onWindowSizeChange);
// ...
});
// ...
}
```
在页面文件中设置Tabs组件的位置：
详细实现案例请参考一多长视频。
重复布局
为了提高屏幕利用率，在大屏上展示更多的内容信息，使用以下容器组件时，可以根据断点展示更多列数实现重复布局。
-  示意图 sm lg 效果示意图 List组件提供lanes属性，支持设置布局列数或行数。通常，在lg断点下，需要通过该属性设置更多列数。 例如，在大屏设备上的列表项展示为3列，其他设备上展示为2列。 详细实现案例请参考一多长视频。
|  示意图 |  sm |  lg |
| --- | --- | --- |
|  效果示意图 |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151403.54174117807696718284951147697749:50001231000000:2800:A2C66E3DA6D9D72EE038D2D04F5704F9B23390890D2BD42BF56C08020B56EBC4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151403.00043992921671662951151811589086:50001231000000:2800:1886182BF49B77A5A136287C380B76954C696674D91421B346C7857AF75120C4.png)
-  示意图 sm lg 效果示意图 WaterFlow组件提供columnsTemplate属性，支持设置当前瀑布流组件布局的列的数量。 通常，相较于sm和md断点，瀑布流组件在lg断点下呈现更多列展示。例如，组件在lg断点下展示3列，其他断点下展示2列。 若希望其中某列占据大于均值的宽度，也可以通过该属性的传参进行配置。例如，传入参数为'1fr 1fr 2fr'，表示将父组件的宽度等分为4份，其中三列分别占据1份、1份、2份。 详细实现案例请参考一多社区评论。
|  示意图 |  sm |  lg |
| --- | --- | --- |
|  效果示意图 |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151403.32609132848852112278406595918193:50001231000000:2800:42E33275CFD1B841B6D0BF862D81883698FA0523DE1A1DA7368370C8CE7BABA6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151403.37258876949166923759899183252583:50001231000000:2800:C4B59B5847ECA14173D38912B1337EB31A05AF5198B92882BE1FBB57287A2B44.png)
-  示意图 sm lg 效果示意图 Swiper组件提供子组件滑动轮播显示的能力，可以用来实现轮播图片。 一般情况下，在lg断点时，应用的轮播图片需要展示多张，且左右两端展示前后两张图片的部分内容。 通过Swiper组件的displayCount属性，可以设置视窗内图片显示的个数；设置itemSpace属性，即可设置组件内子组件之间的间隙。 设置后边距（nextMargin）和前边距（prevMargin）的值，可以展示前后项的部分内容，在视觉上呈现延展的效果。 此外，在适配大屏设备时，若Swiper内组件因为窗口宽高的变化出现拉伸变形等问题，可以使用aspectRatio属性，指定组件宽高比，使组件自适应缩放，保证页面的正常显示。 详细实现案例请参考一多长视频。
|  示意图 |  sm |  lg |
| --- | --- | --- |
|  效果示意图 |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151403.07702982102487982183272262976225:50001231000000:2800:E6E1AFD6C2CFF0F8573375657EB419388F57DAC285FB8575B861DF637CFCF5AD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151403.31074395154478093887162068676247:50001231000000:2800:F73FBCF863277BF0511E6F567321909B1B4DB98F91D7079720E3B01AFE723CFE.png)
-  示意图 sm lg 效果示意图 网格布局通过Grid组件实现。在不同断点下，设置不同的列数（columnsTemplate）和行数（rowsTemplate），即可呈现网格的多端效果。 类似于瀑布流组件，网格同样支持设置某列/行占据父组件宽/高的比例。 与轮播图片相同，为了保证网格的内容正常显示，避免出现图片拉伸、内容变形等问题，可以给网格内组件设置属性aspectRatio，指定组件宽高比，实现组件的自适应缩放。 详细实现案例请参考一多长视频。
|  示意图 |  sm |  lg |
| --- | --- | --- |
|  效果示意图 |   |   |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151403.30229414800679125471088913606508:50001231000000:2800:A8305D8E17EB04DF0C939240360763BCA6B18DCD6BDEC7F966B4E50960EC9B4E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151404.74961950044703948281521536955007:50001231000000:2800:95C3D58D7F81A801694F76E053192C9DD7BC88E77D62ECEA7B32604BAD9619DA.png)
挪移布局
|  示意图 |  sm |  lg |
| --- | --- | --- |
|  效果示意图 |   |   |
示意图
sm
lg
效果示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151404.07612559667580638249377188620224:50001231000000:2800:4F9F2E7D60E17C86C5C06C2433D581AD66B6E7FCC9797EB4980E431099F1A882.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151404.15532412941887505755887953055393:50001231000000:2800:FCCB5032BB06400F42AB0FACDFD78520518DE057E9175C71D4D16136AB2B9074.png)
在一些特殊场景下，页面在sm断点下呈现上下布局，在lg断点下呈现左右布局。
此时需要借助栅格组件GridRow和GridCol，配置在不同断点下栅格子元素占据的列数。当一行中的列数超过栅格组件在该断点的总列数时，可以自动换行，实现挪移布局效果。
在开发中，应用根据具体设计，规划在不同断点下子元素占用的列数即可。
呈现效果：
|  示意图 |  sm |  lg |
| --- | --- | --- |
|  栅格布局示意图 |   |   |
示意图
sm
lg
栅格布局示意图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151404.60981718816181686016417016973864:50001231000000:2800:AF33671B8A74C778FD845EA9B7BB7A70775F8235665D1993605A3DF8F2234125.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151404.08520146211505659481613479330666:50001231000000:2800:C053CF17B386E9A56ACDAC2F6A045362C7D8E34BAD00A7ED3EEEFDBA9B82CC68.png)
详细实现案例请参考一多长视频。
侧边栏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151404.09195153610949079195412812053735:50001231000000:2800:C4A075E651EED9E281925CF4462A7703B78C1500A9CF4A53CC013331C1E2AD69.png)
在大屏设备上，可以使用SideBarContainer组件展示侧边栏，显示更多内容，便于用户操作。
该组件需要传入两个子组件，分别表示侧边栏区域和内容区域，对应上图中右侧深色区域和左侧浅色区域。
在lg断点下设置showSideBar为true，显示侧边栏；其他断点下根据应用需要进行配置即可。
设置属性sideBarPosition的值，控制侧边栏显示在容器左侧/右侧，默认位于左侧；示意图中设置其为SideBarPosition.End，表示侧边栏位于容器右侧。
通过属性sideBarWidth设置侧边栏宽度的初始值；侧边栏支持通过拖拽改变宽度，需要设置其最大宽度maxSideBarWidth和最小宽度minSideBarWidth，并在通用事件onAreaChange中实现侧边栏宽度变更时的逻辑处理。
详细实现案例请参考一多长视频。
分栏布局
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151404.98900780702700650040114974908868:50001231000000:2800:F8304A00BDD032177D410485663C318E9203CD855FE05DB9E0D21E454137DCF9.png)
应用在平板和PC/2in1设备上支持单双栏、三分栏布局，组合使用Navigation组件和SideBarContainer组件即可实现，更多请参考一多分栏开发实践。
窗口适配
由于用户的使用习惯不同，在使用平板时可能选择横向手持或竖向手持，所以平板上的应用需要支持横竖屏旋转；PC/2in1设备上的应用需要支持全屏或自由窗口、自定义窗口标题栏以及沉浸式体验，满足用户的多样化体验。
交互体验
平板和PC/2in1设备上的应用，需要考虑更多交互场景，适配触控屏和键鼠的交互方式。
常见交互事件包含以下4个方面：
特殊事项
相机适配
若应用中涉及相机功能，为了确保相机拉起后，图像方向角度正常且不会出现内容挤压等异常情况，在平板和PC/2in1进行适配时需要充分考虑以下场景：
-  功能 适配方案 拍照、录像 调用getSupportedCameras获取系统可用相机列表，若可用列表中包含后置相机，则优先使用后置相机；若不包含，则优先使用前置相机。 扫一扫 方案一：在PC/2in1设备上屏蔽扫一扫功能。 方案二：默认使用前置摄像头扫码。 使用PC/2in1设备的相机功能时，需要在设置-系统-开发人员选项菜单中关闭USB调试功能。请确认系统相机APP可以正常使用，再调试应用的相机功能。
|  功能 |  适配方案 |
| --- | --- |
|  拍照、录像 |  调用getSupportedCameras获取系统可用相机列表，若可用列表中包含后置相机，则优先使用后置相机；若不包含，则优先使用前置相机。 |
|  扫一扫 |  方案一：在PC/2in1设备上屏蔽扫一扫功能。 方案二：默认使用前置摄像头扫码。 |
开发时请严格按照规范适配，开发指导请参考相机服务。
兼容模式
若应用没有适配平板设备的计划，可以采用兼容模式，在平板上以小窗口的形式运行。
若采用此模式，需要按照以下步骤：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151404.66341395547264281732665791500455:50001231000000:2800:EFF07A30890E60342BCCD4F4383EB87E1E62749EE2004C08AADC01CCAE4540D1.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-wear
爬取时间: 2025-05-01 08:41:22
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-lite-wearable-guide
爬取时间: 2025-05-01 08:41:36
来源: Huawei Developer
概述
对于轻量级智能穿戴，应用可以通过HarmonyOS提供的接口实现传感器、UI交互等常规业务的开发。开发者可以根据轻量级智能穿戴的特点，打造针对轻量级智能穿戴的独特应用。当前支持产品有：HUAWEI WATCH GT系列、Watch D系列、Fit系列、Watch Ultimate系列。
本章节后续部分将以创建“Hello World”的轻量级智能穿戴应用为例，逐步讲解如何在应用中构建布局、绘制样式、添加组件、绑定事件、实现页面路由跳转等。
本文档适用于轻量级智能穿戴应用开发，针对智能穿戴请参考智能穿戴开发API参考。
体验应用
搭建环境和创建项目
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151405.41970416498678380415579061145096:50001231000000:2800:54E18C405FC4EFB25E5C0DA0F09FFEF452514541AB491CD9F26932B8EB79E38C.png)
工程目录介绍
HelloWorld工程目录如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151405.82532300973685773004519401128724:50001231000000:2800:5B7DE5D6D6BBD5EF439E0097003E21C060F1B6906245B55F9C4F6BAC0FD375A9.png)
pages/index/index.hml：此文件定义了index页面的布局，在index页面中用到的组件，以及这些组件的层级关系。以下示例代码包含了一个text组件，内容为“Hello World”。
pages/index/index.css：此文件定义了index页面的样式。以下示例代码定义了“container”和“title”的样式。
pages/index/index.js：此文件定义了index页面的业务逻辑，比如数据绑定，事件处理等。以下示例代码变量通过动态绑定的形式定义“title”字符串为“World”。
resources：此目录用于存放系统级资源配置文件，如应用图标等。
config.json：此文件是配置文件，主要定义了页面路由和应用信息，可根据DevEco Studio的工程和页面创建向导自动完成填充。
运行应用
使用预览器查看效果，请参考查看ArkTS/JS预览效果。
在Lite Wearable中运行应用/服务，依赖HarmonyOS NEXT版本以前的华为手机上的运动健康和应用调测助手APP辅助进行。
前提条件
-  因Lite Wearable设备无法与DevEco Studio进行连接，因此在对Lite Wearable应用/服务签名时，不能采用自动化签名方案，只能使用手动签名，然后再手动配置签名信息。
操作步骤
1.  如果Lite Wearable与华为手机未连接，请单击应用调测助手APP界面的连接设备按钮，手机会自动打开运动健康APP添加Lite Wearable。
构建布局
布局说明
本文以轻量级智能穿戴中的圆形表盘为例，把466px（px为逻辑像素，非物理像素）作为基准宽度。在构建页面布局时，需要对基本元素进行分析：
-  将页面中的元素分解之后再逐个对基本元素进行自上而下的实现，可以减少多层嵌套造成的视觉混乱，尽可能的避免出现逻辑混乱，还可以提高代码的可读性，方便对页面做后续的调整和增改。
实现应用页面
应用页面由组件声明（.hml）、css样式（.css）和script脚本（.js）三部分构成。组件声明在“pages/index/index.hml”文件中实现，使用<text>组件显示文字，并用一个容器组件来包裹<text>组件，这里以<div>为例进行说明。示例代码如下：
现在已经完成了一个简单应用开发的第一步，在后续章节中将继续介绍样式、事件的开发方法，不断优化和完善应用。
绘制样式
组件标签中类似“style="width:466px;height:466px;"”的语句即为样式设置语句，通过样式可以设置组件的显示大小、背景颜色、对齐方式等属性。本章节以<div>和<text>组件为例来介绍如何设置样式，样式主要有三种设置方式：行内样式、选择器样式和动态绑定样式，三种方式设置的样式效果一致。
行内样式
行内样式是将样式内容直接放到组件的style属性中，多个样式值则是通过分号间隔。以下示例代码通过行内样式对div和text组件设置了高度、宽度或其他属性。
选择器样式
使用行内样式存在以下缺点：
针对以上问题，我们可以采用选择器样式，将所有的样式代码写到pages/index/index.css文件中，然后通过class、id等方式和组件关联起来。以上节中的代码为例，修改后的代码如下：
动态绑定样式
在行内样式和选择器样式中，样式设置方式是静态的，即代码开发中设置的样式在程序运行的时候不能更改，这种方式限制了程序的显示效果。如果要在程序运行过程中动态地改变样式，需要用到动态绑定样式。动态绑定就是值和变量动态关联，随着值的变更而显示不同的效果。动态绑定的使用方式为“{{变量名}}”，其中变量名是js文件中data对象的属性值。目前动态绑定样式只支持绑定行内样式。
以下示例代码中，text的字体大小和data中的fontSize属性绑定，字体颜色和data中的fontColor属性绑定：
现在已经完成了字体大小和颜色的样式绑定，下一节交互事件将介绍如何通过按钮的点击事件实现动态改变字体的样式。
交互事件
每个组件都有一些通用事件和特有事件，开发者可在这些事件中实现应用的功能和逻辑。组件中添加事件的格式如下：
常见的组件事件如下表所示：
| 事件  | 描述  |
| --- | --- |
| click  | 组件被点击时触发，使用方法参见下面示例。  |
| longpress  | 组件被长按时触发，使用方法与click相同。  |
| swipe  | 组件上快速滑动时触发，使用方法参见应用退出章节。  |
事件
描述
click
组件被点击时触发，使用方法参见下面示例。
longpress
组件被长按时触发，使用方法与click相同。
swipe
组件上快速滑动时触发，使用方法参见应用退出章节。
以<input>组件的onclick事件为例，介绍事件的使用方法。首先，在index.hml文件中添加一个<input>组件，添加后的代码示例如下：
在以上代码中，页面里添加了一个<input>组件，包含了onclick事件及其处理函数。clickAction()是一个Javascript函数，点击按钮改变字体的大小和颜色。它的实现在pages/index/index.js文件中，示例代码如下：
页面路由
应用通常由多个页面组成，需要页面路由来实现页面间的跳转。页面路由router根据uri的地址来找到目标页面，实现跳转。下面以两个简单页面之间的跳转为例说明页面跳转的操作，具体实现步骤如下：
1.
2.
3.
4.
5.
6.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151405.04803857672841267020306899888919:50001231000000:2800:B015D55224BEA4CD1CFEE20A9F2D40869BD9E900389CA793DAED6262765FD703.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151405.84773360684204265244125961238471:50001231000000:2800:DA7567A9332BA5B37BCB059297F1E841D4621C19800E16811DD95D66A3A14FE8.png)
应用退出
应用退出除使用物理按键触发外，还可以通过组件的事件触发。本章节以右滑表盘退出为例，讲解实现应用退出的方式。
1.
2.
应用与页面的生命周期
轻量级智能穿戴应用的生命周期主要有两个：应用创建时会触发app.js文件中的的onCreate()，应用销毁时触发onDestroy()。
一个应用中可能会有多个页面，每个页面都包括onInit()、onReady()、onShow()、onHide()和onDestroy()，在页面初始化、准备、显示、隐藏和销毁时触发调用的事件：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151405.55084966563610498654318069014727:50001231000000:2800:7235394E5D933B56840131E0EFD9D54F588B435694B7E1E2D0ACD137CC6D8556.png)
当应用从页面A跳转到页面B时，首先调用页面A的onDestroy()函数。页面A销毁后，依次调用页面B的onInit()、onReady()、onShow()函数来初始化和显示页面B。
百分比使用
从API Version 5 开始支持。
绘制样式中的部分字段（width，height，margin，top，left）支持使用百分比设置，通过指定百分比，应用在运行时可以自动换算成真实像素值。百分比可以在一定程度上帮助应用进行显示自适应，在不同尺寸的屏幕上显示尽可能做到一致或合理的布局。本章节将介绍百分比在绘制样式中具体的使用。
1.
2.
3.
4.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151405.72107201933679801760974293411707:50001231000000:2800:6C39FF92BF4CCAD3AB4AF7E6D302737B22E8CCE6ACE4FBBED202AEE44A2DFBAC.png)
百分比计算会通过浮点数计算后保留整数部分。
方表适配
应用如果需要同时适配方形的轻量级智能穿戴设备，需要完成以下步骤。
1.
2.  应用上架时，应用市场会根据“distroFilter”属性对方形和圆形的轻量级智能穿戴进行分发。
安全接口的使用
轻量级智能穿戴设备应用开发的安全相关接口，包含通用密钥库系统、加解密算法库框架和锁屏管理。
轻量级智能穿戴设备目前不支持异步接口，所有异步接口会等待回调函数执行完成，再执行下一行代码。本章节所有异步接口可理解为同步接口。
@ohos.security.huks（通用密钥库系统）
通用密钥库系统提供的接口，包含常见的对称加密算法、常见的非对称加密算法、常见的消息认证码（MAC）算法和公共接口。
常见的对称加密算法如下表所示：
| 算法类型  | 算法  | 用法  | 分组模式  | 填充模式  | 密钥长度  |
| --- | --- | --- | --- | --- | --- |
| 对称算法  | AES  | 密钥生成、加密、解密  | CBC  | NoPadding  | 128/192/256  |
| ECB  | NoPadding  | 128/192/256  |
| GCM  | NoPadding  | 128/192/256  |
| DES  | 密钥生成、加密、解密  | CBC  | NoPadding  | 64  |
| ECB  | NoPadding  | 64  |
| 3DES  | 密钥生成、加密、解密  | CBC  | NoPadding  | 128/192  |
| ECB  | NoPadding  | 128/192  |
算法类型
算法
用法
分组模式
填充模式
密钥长度
对称算法
AES
密钥生成、加密、解密
CBC
NoPadding
128/192/256
ECB
NoPadding
128/192/256
GCM
NoPadding
128/192/256
DES
密钥生成、加密、解密
CBC
NoPadding
64
ECB
NoPadding
64
3DES
密钥生成、加密、解密
CBC
NoPadding
128/192
ECB
NoPadding
128/192
DES加密算法是一种对称加密算法，支持按照CBC/ECB 两种分组模式，填充模式为NoPadding，密钥长度为64位。下文以DES算法CBC分组模式为例，介绍在轻量级穿戴设备应用中实现密钥生成、加密和解密。
1.
2.
3.
常见的非对称加密算法如下表所示：
| 算法类型  | 算法  | 用法  | 分组模式  | 摘要模式  | 填充模式  | 密钥长度  | 标准  | 开闭源  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 非对称算法  | RSA  | 密钥生成、加密、解密  | ECB  |    | NoPadding  | [1024,2048]  | RFC  | 开源  |
| ECB  |    | PKCS#1 V1.5  | [1024,2048]  | RFC  | 开源  |
| ECB  | SHA256  | OAEP  | [1024,2048]  | RFC  | 开源  |
| 密钥生成、签名、验签  |    | SHA256  | PKCS#1 V1.5  | [1024,2048]  | RFC  | 开源  |
|    | SHA256  | PSS  | [1024,2048]  | RFC  | 开源  |
|    | SHA1  | ISO/IEC 9796-2  | [1024,2048]  | ISO-9796  | 闭源  |
算法类型
算法
用法
分组模式
摘要模式
填充模式
密钥长度
标准
开闭源
非对称算法
RSA
密钥生成、加密、解密
ECB
NoPadding
[1024,2048]
RFC
开源
ECB
PKCS#1 V1.5
[1024,2048]
RFC
开源
ECB
SHA256
OAEP
[1024,2048]
RFC
开源
密钥生成、签名、验签
SHA256
PKCS#1 V1.5
[1024,2048]
RFC
开源
SHA256
PSS
[1024,2048]
RFC
开源
SHA1
ISO/IEC 9796-2
[1024,2048]
ISO-9796
闭源
RSA加密算法是一种非对称加密算法，支持密钥对生成、加解密、签名和验签操作。RSA的填充模式通常为PKCS#1 V1.5或OAEP，密钥长度通常为1024位、2048位，密钥长度越长，安全性越高，但计算开销也越大。下文以RSA算法、填充模式PKCS#1 V1.5为例，介绍在轻量级穿戴设备应用中实现密钥对生成、加解密、签名和验签。
1.
2.
3.
常见的消息认证码（MAC）算法如下：
| 算法类型  | 算法  | 用途  | 分组模式  | 填充模式  | 密钥长度  | 标准  | 开闭源  | 摘要算法  | 加密算法  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 消息认证码（MAC）算法  | CMAC  | MAC  | CBC  | ISO/IEC-9797_1  | 128  | ISO-9797  | 闭源  |    | 3DES  |
| HMAC  | MAC  |    |    | 按照现有密钥规格  | RFC  | 开源  | SHA256  |    |
算法类型
算法
用途
分组模式
填充模式
密钥长度
标准
开闭源
摘要算法
加密算法
消息认证码（MAC）算法
CMAC
MAC
CBC
ISO/IEC-9797_1
128
ISO-9797
闭源
3DES
HMAC
MAC
按照现有密钥规格
RFC
开源
SHA256
HMAC是基于哈希函数的消息认证码算法，用于验证消息的完整性和真实性。下文将以HMAC为例，介绍消息认证码算法的使用。
1.
2.
公共接口包含导入密钥、导出密钥、查询密钥是否存在和删除密钥。
-  定义导入密钥的相关配置项，并调用huks.importKeyItem()方法导入密钥。
-  调用huks.isKeyItemExist()方法，检查指定别名（KEY_ALIAS）的密钥项是否存在于密钥管理系统中。
@ohos.security.cryptoFramework (加解密算法库框架)
加解密算法库框架包含消息摘要算法和安全随机数的生成。消息摘要算法是一种能将任意长度的输入消息，通过特定运算生成固定长度摘要的算法；安全随机数能够生成不可预测、均匀分布的随机数，确保系统的安全性和可靠性。
-  首先通过cryptoFramework.createMd()方法创建基于SHA256算法的摘要操作实例，将其赋值给handle；其次调用handle的updateSync()方法，将待摘要的消息转换为Uint8Array后传入，用于更新摘要操作实例中的数据；最后调用handle的digest方法，获取摘要计算的结果，并用handle的getMdLength()方法获取摘要的长度。 在同一应用内，开发者应该避免连续多次调用handle.digest()接口，否则会导致不必要的内存开销。
-  在同一应用内，开发者应该避免连续多次调用rand.generateRandomSync()接口，否则会导致不必要的内存开销。
@ohos.screenLock (锁屏管理)
锁屏管理服务向三方应用提供解锁屏幕、查询锁屏状态、查询当前锁屏是否安全的能力。
示例代码
轻量级智能穿戴开发实践同源工程

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-app-architecture-overview
爬取时间: 2025-05-01 08:41:50
来源: Huawei Developer
随着应用规模的扩大和业务需求的复杂化，代码的复杂度相应提升。因此，良好的应用架构设计变得尤为重要，架构设计的目的是让应用更易于维护、扩展和测试。
开发者在应用开发过程中，经常面临以下挑战：
为了解决这些问题，开发者需要关注以下几个方面的架构设计：
本文所介绍的HarmonyOS推荐的分层架构设计和模块化设计实例可参考"HMOS世界"

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-layered-architecture-design
爬取时间: 2025-05-01 08:42:03
来源: Huawei Developer
HarmonyOS应用的分层架构设计以一套代码工程为基础，旨在为华为的手机、PC/2in1等1+8全场景设备提供支持，实现了“一次开发，多端部署”的开发理念。
HarmonyOS应用的分层架构主要包括三个层次：产品定制层、基础特性层和公共能力层，为开发者构建了一个清晰、高效、可扩展的设计架构。
本文将从逻辑模型、开发模型和部署模型分别介绍应用分层架构设计规则。
逻辑模型
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151020.41665033149794500284643543270228:50001231000000:2800:E5DE6AD8511D744189E5AD794E3C198281E488CD152FAB230E3B47DBA425AD97.png)
-  产品定制层专注于满足不同设备或使用场景（如应用）的个性化需求，包括UI设计、资源和配置，以及针对特定场景的交互逻辑和功能特性。 产品定制层的功能模块独立运作，同时依赖基础特性层和公共能力层来实现具体功能。 作为应用的入口，产品定制层是用户直接互动的界面。为满足特定产品需求，产品定制层可灵活地调整和扩展，从而满足各种使用场景。
-  基础特性层位于公共能力层之上，用于存放基础特性集合，例如相对独立的功能UI和业务逻辑实现。该层的每个功能模块都具有高内聚、低耦合、可定制的特点，以支持产品的灵活部署。 基础特性层为上层的产品定制层提供稳健且丰富的基础功能支持，包括UI组件、基础服务等。同时依赖于下层的公共能力层为其提供通用功能和服务。 为了增强系统的可扩展性和维护性，基础特性层将功能进行模块化处理。例如，一个应用的底部导航栏中的每个选项都可能是一个独立的业务模块。
-  公共功能层用于存放公共基础能力，集中了例如公共UI组件、数据管理、外部交互以及工具库等的共享功能。应用可以共享和调用这些公共能力。 公共能力层为上层的基础特性层和产品定制层提供稳定可靠的功能支持，确保整个应用的稳定性和可维护性。 公共能力层包括但不限于以下组成：
开发模型
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151020.97279126131517574159130978175484:50001231000000:2800:BCE2BAB2E61F531DF37E600CECECDE42A69B53BCED4795219D95B9AF56712E52.png)
-  产品定制层的各个子目录会被编译成一个Entry类型的HAP，作为应用的主入口。该层主要针对跨多种设备，为各种设备形态集成相应的功能和特性。产品定制层被划分为多个功能模块，每个功能模块都针对特定的设备或使用场景设计，并根据具体的产品需求进行功能及交互的定制开发。
-  在基础特性层中，功能模块根据部署需求被分为两类。对于需要通过Ability承载的功能，可以设计为Feature类型的HAP，而对于不需要通过Ability承载的功能，根据是否需要实现按需加载，可以选择设计为HAR模块或者HSP模块，编译后对应HAR包或者HSP包。
-  公共能力层的各子目录将被编译成HAR包，而他们只能被产品定制层和基础特性层所依赖，不允许存在反向依赖。该层旨在提取模块化公共基础能力，为上层提供标准接口和协议，从而提高整体的复用率和开发效率。
部署模型
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151020.72168562076674191026210385012601:50001231000000:2800:66278E50FB189C653528DB6E838DBDE007CC4BA68E2647C8579C97DB065D9B9F.png)
应用程序（.app文件）在流水线或应用市场上被解包为n * Entry类型的HAP + n * Feature类型的HAP，根据设备类型和使用场景将应用部署到不同类型的设备上，实现多端的统一用户体验。
当Entry类型的HAP和Feature类型的HAP被分发并部署到相应的设备时，他们所依赖的HSP也会一同被分发并部署到相应的设备上。
在部署模型中，每个Entry类型的HAP代表了应用的入口点，而Feature类型的HAP则包含了应用的特定功能模块。允许应用能够以模块化的方式适配和部署，从而满足不同设备和场景的需求。
该部署模型不仅优化了应用的组织结构，也为保持应用在各种设备和场景中的一致性提供了支持。通过按照设备类型和使用场景来区分和部署不同的HAP，能确保无论在何种设备或场景中，用户都能获得统一且高质量的体验。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-modular-design
爬取时间: 2025-05-01 08:42:16
来源: Huawei Developer
模块化设计理念
在大型软件工程中，一般会伴随着多团队开发，而各个团队之间，都是弱耦合交互，团队交付的业务之间以一种契约化形式的接口，定义了业务之间的接口，以此来满足各个团队的业务独立发展，互不影响，实现快速迭代演进，这就需要业务模块化。模块化是现代软件工程的核心原则之一，它通过将大型的复杂系统拆解为更小、更容易管理和理解的部分——功能模块，来提高系统的可维护性和可拓展性。每个功能模块都是一个独立的单元，具有清晰定义的接口和职责，能够与其他模块交互以完成复杂的任务。
在HarmonyOS应用开发中，模块化不仅是一个设计原则，更是一种开发实践。它旨在将应用程序拆分为多个功能模块，每个功能模块负责特定的功能或特性。功能模块可以独立开发、编译和部署，也可以在不同的设备上灵活组合和调用。
应用程序包结构概念
在进行模块化设计时，需要考虑HarmonyOS的应用包结构选型，HarmonyOS的应用包结构是为了定义应用的组织方式，通过开发态、编译态、发布态阶段应用程序包的形态，了解到不同包类型对应的使用场景以及使用规则。详细请参见Stage模型应用程序包结构。
Ability应用组件设计
HarmonyOS应用的业务逻辑需要通过Ability组件承载，根据业务设备以及业务诉求不同，需要考虑Ability组件的选择以及设计。在多设备的背景下，应用的形态不一定是传统移动设备上的单任务单窗口形式，在一些场景下，多任务多窗口的形态可以让用户获得更好的用户体验，提升使用效率。
例如在手机设备上：
在大屏设备上，应用内的多个任务可以以多窗口的形式存在，用户可以并行操作应用的不同功能。
对于这种类似独立应用一样的任务，每个任务对应一个UIAbility组件实例，并且每个任务可以单独显示一个窗口，对用户而言，可以在同个应用不同任务间切换，就像是单独的应用一样，并且在大屏设备上可以独立地移动、调整大小、显示和隐藏应用窗口。所以在进行功能设计时，需要对应用本身是否支持多任务多窗口，结合起来考虑Ability组件的设计，这影响整体工程模块化的结构。
应用模块化选型
应用架构是给应用业务服务的，是从技术的角度思考业务如何实现的；而工程模块化模型，是基于技术架构对代码工程所做的模块化技术选型，需要考虑技术到代码工程上如何落地，只有代码工程模型的技术选型合理了，才能在包体积、性能、产品部署等取得一个最优的综合表现。
一般业务是分模块的，比如某购物软件，上面的业务就有主页导航、商品详情、购物车、支付、订单、个人信息等相关的模块；所以技术架构上，就会出现很多业务模块，模块之间是高内聚低耦合的，在代码工程上也就表现为模块（Module）。而在做代码工程模块化的技术选型上，因为Entry类型的HAP是工程默认存在的，且不能存在多个，所以主要考虑的就是几种模块类型：Feature类型的HAP模块，HAR模块和HSP模块。
在技术架构上的某个模块，做代码工程的选择时，是选择哪种模块类型，需要结合业务本身性质/模块的功能等因素综合考虑的。以基于应用常见的模块化模型，在实际的业务考虑中以下几种情况：
共享模块
对于大型软件，不同的业务以及基础能力会分为多个团队开发，多团队之间需要代码仓隔离；如果某个或者若干个HAR工程模块是由某个团队负责开发的，又想代码仓隔离，可以将这些HAR单独在独立的工程内开发，将工程编译产物通过公司私有的OHPM仓进行发布和集成，如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151020.74063964263167010806471556575931:50001231000000:2800:6E96BEEE0F39F8998C6FE8B2D699EE19A10C8F408DBECE3C3E68F8C7C7731573.png)
这部分可以发布到OHPM仓的模块，叫做共享模块，可以将公共能力共享给多个应用使用，如公司内部多个应用使用某个公共能力网络库；或者也可以将该公共能力封装成库贡献给社区，给其他应用集成使用，这样的话这个模块也只能是HAR模块。
按需加载模块
随着应用业务扩大，应用给用户提供的功能越来越多，但是并非所有的功能都是用户常用的，根据用户运营报告分析，对于某些用户月活比较低的特性，可以将该特性做成按需加载模块。用户首次从应用市场安装时，仅会下载不包含按需加载模块的内容，需要使用到对应功能时，由用户选择使用时下载安装对应的功能模块。
设计为按需加载模块有以下好处：
如果某个特性做成了按需加载模块，该模块可以设计为Feature类型的HAP或者HSP，HAP和HSP都可以实现按需加载，区别在于Feature类型的HAP可以包含Ability组件，结合前面的Ability应用组件设计以及业务是否需要按需加载，从整体上可以划分两个大的场景如下：
应用组件的设计，决定了模块化设计中是单HAP工程还是多HAP工程，在设计初期需要考虑应用的任务形态，来决定采用何种模块化结构。
多HAP/HSP引用相同HAR包的影响
在应用开发的过程中，可以使用HSP或HAR的共享包方式将同类的模块进行整合，用于实现多个模块或多个工程间共享ArkUI组件、资源等相关代码。
由于共享包的动态和静态差异，在多HAP/HSP引用相同HAR包的情况下，会存在HAR包中的单例失效，从而影响到应用冷启动的性能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151020.18643562862634013508404237777819:50001231000000:2800:92106D440C2A1BD9D92E5D255345A1C56D845DD8656BB872194E27D72D494B43.png)
如上图所示，工程内存在三个模块，HAP包为应用主入口模块，HSP为应用主界面显示模块，HAR_COMMON集成了所有通用工具类，其中funcResult为func方法的执行结果。
由于HAP和HSP模块同时引用HAR_COMMON模块时会破坏HAR的单例模式，所以HAP和HSP模块使用HAR_COMMON中的funcResult时，会导致func方法在两个模块加载时各执行一次，使得文件执行时间耗时增长。
如果仅从性能的角度考虑，可以使用以下方式进行修改，从而达到缩短冷启动阶段耗时的目的。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151021.01945740124606363754000596832992:50001231000000:2800:2EA68CD3BEA40E7B5FE83741429DC7078649CCB4F9C817D96868CA6227ABB62D.png)
1.  HAP包引用HAR_COMMON包中的功能。 HAP包引用HAR_COMMON包中的功能。
2.  HAP包引用HAR_COMMON包中的功能。
3.  HAP包引用HAR_COMMON包中的功能。
-  HAP包引用HAR_COMMON包中的功能。
-  HAP包引用HAR_COMMON包中的功能。
使用Launch模板，对优化前后启动性能进行对比分析。
分析阶段的起点为启动Ability（即H:void OHOS::AppExecFwk::MainThread::HandleLaunchAbility的开始点），阶段终点为应用第一次接到vsync（即H:ReceiveVsync dataCount:24Bytes now:timestamp expectedEnd:timestamp vsyncId:int的开始点）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151021.50327797858224167941086444525893:50001231000000:2800:30A39BDBE63D6960B3D5BD0D7E4CE97F9EA828379FE343E07AB44621BD8886E3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151021.04634734359063517183095818691703:50001231000000:2800:CF93E4EA7B0E07AB0686323D3B2B19345BE2D9E7C558B0E37152D90C55AA7843.png)
优化前后的对比数据如下：
| 方案  | 阶段时长(毫秒)  |
| --- | --- |
| （优化前）使用HSP包  | 3125  |
| （优化后）使用HAR代替HSP  | 853.9  |
方案
阶段时长(毫秒)
（优化前）使用HSP包
3125
（优化后）使用HAR代替HSP
853.9
上述示例为凸显出差异，func执行函数循环次数为100000000，开发者实际修改后收益需根据实际情况测试。
从测试数据可以看出，将HSP替换为HAR包后，应用启动的阶段耗时明显缩短。
单HAP工程
对于单窗口应用的APP工程而言，其仅包含一个Entry类型的HAP，那么划分的模块则是根据是否有按需加载的需求，来考虑采用HAR模块和HSP模块。
不包含按需加载模块
对于不需要按需加载且仅有一个Entry类型的HAP的App来讲，可以直接全部采用HAR进行开发设计。如下图所示：
这里说的仅有一个HAP指的是一种设备类型仅有一个HAP，而不是.app文件包里面仅有一个HAP。因为.app里面可以包含其他设备的HAP包，如手表、大屏，进行多设备分发。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151021.31351500467700550139834174055428:50001231000000:2800:26101F942717D6AA68FBCC87809A793EF74ABB249FCA5569FCE2E25C0687336C.png)
上图工程架构中，除了产品模块层中与设备相关的HAP外，其他的均为HAR，这些被依赖的HAR，最终都会被编译进HAP中。
设计成HAR包有如下好处：
包含按需加载模块
在单HAP工程内，如果要实现按需加载功能，那么对应的组件需要采用HSP作为按需加载组件模块。在这种情况下，由于HAR是静态共享库，多个HAP/HSP如果依赖于同一份HAR，则该HAR在应用内会被存在多份。而HSP是动态共享库，其安装和加载均会有一些性能损失（相比于HAR），所以过多的HSP可能会影响安装效率和App启动性能，需要考虑目前App占用空间（App Size）是否瓶颈以及对启动性能的敏感程度，根据业务实际情况，在App Size与特性启动性能之间做好平衡。
这里所提到的App Size指的是用户已经把按需加载模块安装之后，应用整体的大小。
App Size优先
对于App Size比较看重的，可以考虑将公共依赖的模块封装在一个HSP模块壳中，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151021.36735265290468230546938514008109:50001231000000:2800:AE1C6BE8AE7F63830F5A66E77F8965718512BE4532901EC9EA34A931387C5990.png)
hap_A依赖于独有的共享库har_A，同时需要依赖于har_C和har_D；而按需加载模块hsp_B依赖于独有的共享库har_B，同时需要依赖于har_C和har_D。
这里的共享库har_A、har_B、har_C、har_D不一定本地工程，有可能是从ohpm仓上依赖下载的。
因为har_C和har_D同时被hap_A和hsp_B工程所依赖，所以为了节省App Size，可以将其封装到名为“common_hsp”的Module中，对外暴露har_C和har_D的接口，将har_C和har_D打包到common_hsp中，最后让hap_A和hsp_B依赖于common_hsp工程。common_hsp工程是无实际意义的，它仅是一个“模块壳”，是为了最小化App Size而存在的。
性能优先
对于性能比较敏感的，则不需要再封装一个公共的HSP模块，直接依赖公共HAR包：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151021.30331006568419813899234303437467:50001231000000:2800:19BC7E124A6EA3A1572827A9FCB70FD505695EBED97083EE903E99F9F43744D8.png)
因为公共HSP包需要安装和加载，所以会有一些性能损耗。对于启动性能敏感型的应用，则将hap_A和hsp_B直接依赖于har_C和har_D。最终编译产物里面有2个，hap_A.hap和hsp_B.hsp，但是这两个编译产物里面均会包含har_C和har_D，App Size会比采用公共HSP模型大。
多HAP工程
对于同一个设备类型，如果要实现不同的独立功能模块，并且相对独立，以及具有单独的入口的功能特性，建议做成一个独立特性的HAP，按需下载安装。此时一个App包中，就会有多个HAP包，其中有且仅有一个Entry类型的HAP，其他的均是Feature类型的HAP。多HAP之间业务独立，但是可能会有业务能力共享，所以在进行模块化设计时，需要根据是否具有公共能力来进行选择。
包含公共能力模块
对于具备公共能力模块的工程，和上述HAP+HSP组合是类似的，需要考虑在App Size与启动性能之间做平衡。
性能优先
一般多HAP应用架构普适性采用以下模型，除了产品组件中存在HAP包之外，其余的均是HAR包，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151021.16486256328529102069115348307950:50001231000000:2800:85405807F23FA673BD6239C84E4C8FAE8C4AEB7EF166145E288E226CB635C85F.png)
从编译产物上看，多HAP之间是存在相同的HAR包的（如har_2、har_3、har_C、har_D、harE），这样App Size可能会比较大，对于App Size不是瓶颈点的应用，或者HAR包的大小比较小，对App Size的影响可控，可以采用这种模型，减少了动态加载的性能损耗。
App Size 优先
上述的重复HAR包，其本质的问题就是HAR包如何在HAP、HSP之间分布可以最小化App Size，减少HAR的重复编译打包，大的思路就是公共能力模块可以封装为公共HSP，最小化App Size，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151021.48935789421532577670472986777923:50001231000000:2800:76CEE453520017C2584552DDC0C7CD83051F127388D471E2FC37DCB5EA7239FA.png)
需要注意，在应用间共享的HAR包，原则上是不允许依赖HSP包，因为HSP包是专属于应用，和bundleName进行了绑定，一旦HAR包依赖于应用内HSP，该HAR包就丢失了共享性，无法再给其他应用共享。
如上图所示，有3个HAP包（一个entry和两个feature），将公共的HAR包封装到HSP工程中，如common_wrap_hsp和feature_wrap_hsp，这两个HSP从严格意义上讲，不能称之为模块，它们仅能称之为模块壳，是为合理放置模块在编译产物中的位置而存在的，本身不具备模块的意义，所以不能共享，仅能在App应用内使用，依赖于这些模块壳的模块也无法在应用间共享。
上述的模型中通过HSP将HAR包合理地分配到编译产物中，使每个HAR包在App编译产物中仅存在一份，从而达到App Size最小，而模块壳不能过多，否则可能会影响安装速度和启动性能。
这两种模型都是理想模型，更多的业务模型是两者的平衡态或者两种模型的组合体，比如某个共享库本身代码和资源比较少，占用的空间不大，例如打印日志模块，那么将该模块编译进所有的编译产物中，增大的App Size比较少，同时性能会相对好一些。
不包含公共能力模块
一般这种应用比较少，即使有的话也是一些小型应用，可以参考单HAP的场景。
总结
应用开发者需要根据自身技术架构选择适合的工程模块化模型，工程模块化模型也不是一成不变的，需要根据业务和技术架构的演进而演进。根据诉求在HAP、HAR和HSP三种类型中进行选择使用。
对于具备独立运行和安装的模块只能选择HAP包，并将其作为Feature类型的HAP存在于App中；对于不具备独立特性部分，用户使用频率较少的模块，将其做成HSP按需加载模块存在于App中。对于需要共享的模块，只能采用HAR包，将其通过OHPM仓共享给其他工程使用。而HAR是静态共享库，在多HAP或者按需加载场景下，在编译后可能会在物理上存在多份，所以需要合理采用公共HSP模块壳，使App Size最小化。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-app-concurrency-design
爬取时间: 2025-05-01 08:42:30
来源: Huawei Developer
概述
ArkTS是HarmonyOS APP的开发语言，它在保持TypeScript（简称TS）基本语法风格的基础上，一方面规范强化静态检查提升开发者代码的规范性；另一方面基于TypeScript增强了一些特性提升开发体验和执行效率，尤其是在并发能力上的提升。
本文档主要面向HarmonyOS APP的设计人员或开发人员，介绍应用在并行任务方案设计过程中，可能会遇到的典型场景以及对应的推荐设计方案，同时给出了方案的关键点及参考案例。
典型业务场景
根据当前HarmonyOS APP开发过程中遇到的实际并发业务场景，总结提炼出如下典型场景，可供更多APP参考，设计其并发业务方案。
| 场景编号  | 场景分类  | 场景名称  | 简述  |
| --- | --- | --- | --- |
| 1  | 并发能力选择  | 耗时任务并发执行  | 相对独立的耗时任务需要放到单独的子线程中执行，推荐TaskPool  |
| 2  | 常驻任务并发执行  | 常驻的耗时任务需要放到单独的子线程中执行，推荐Worker  |
| 3  | 共享内存并发业务  | 开发常见的共享内存并发业务，推荐使用TaskPool和Worker的API进行开发  |
| 4  | 长时任务并发执行  | 长时间运行的任务，不独占线程执行，推荐TaskPool长时任务  |
| 5  | 并发任务管理  | 多任务关联执行（串行顺序依赖）  | 有严格执行顺序的任务，不希望并发执行  |
| 6  | 多任务关联执行（树状依赖）  | 待执行的任务存在依赖关系，等待被依赖执行完再调度  |
| 7  | 多任务同步等待结果（任务组）  | 多个关联的任务需要等待全部结果返回后再进行后续操作  |
| 8  | 多任务优先级调度  | 不同任务设置不同的优先级  |
| 9  | 任务延时调度  | 任务不希望立即执行，希望延时一定时间后调度  |
| 10  | 线程间通信  | 同语言线程间通信（ArkTS内）  | 介绍ArkTS线程间的通信机制  |
| 11  | 跨语言多线程通信（C++与ArkTS）  | 介绍C++与ArkTS线程间的通信机制  |
| 12  | 线程间模块共享（单例模式）  | 介绍进程内单例场景的实现方式  |
| 13  | 线程间不可变数据共享  | 介绍不可变数据共享场景的实现方式  |
| 14  | 生产者与消费者模式  | 介绍生产者与消费者模式场景的实现方式  |
场景编号
场景分类
场景名称
简述
1
并发能力选择
耗时任务并发执行
相对独立的耗时任务需要放到单独的子线程中执行，推荐TaskPool
2
常驻任务并发执行
常驻的耗时任务需要放到单独的子线程中执行，推荐Worker
3
共享内存并发业务
开发常见的共享内存并发业务，推荐使用TaskPool和Worker的API进行开发
4
长时任务并发执行
长时间运行的任务，不独占线程执行，推荐TaskPool长时任务
5
并发任务管理
多任务关联执行（串行顺序依赖）
有严格执行顺序的任务，不希望并发执行
6
多任务关联执行（树状依赖）
待执行的任务存在依赖关系，等待被依赖执行完再调度
7
多任务同步等待结果（任务组）
多个关联的任务需要等待全部结果返回后再进行后续操作
8
多任务优先级调度
不同任务设置不同的优先级
9
任务延时调度
任务不希望立即执行，希望延时一定时间后调度
10
线程间通信
同语言线程间通信（ArkTS内）
介绍ArkTS线程间的通信机制
11
跨语言多线程通信（C++与ArkTS）
介绍C++与ArkTS线程间的通信机制
12
线程间模块共享（单例模式）
介绍进程内单例场景的实现方式
13
线程间不可变数据共享
介绍不可变数据共享场景的实现方式
14
生产者与消费者模式
介绍生产者与消费者模式场景的实现方式
并发能力整体架构
并发能力概述
并发能力框架如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151022.15902765484992620217946207963659:50001231000000:2800:68DB4BE1C07BC5E0476391AEAC09AD84E6C7F178A884C1BAD36FEDD9428C0980.png)
并发模型与业界模型的差异
共享内存并发模型
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151022.05207114614422528419461896431627:50001231000000:2800:779C13D764BFDAD6B00C44DBBC5DF4C1DDF4FC3C317C6A0FA16CB29A4154F248.jpg)
共享内存模型指的是采用线程和锁的并发模型，不同线程之间共享内存，通过锁来进行临界区保护。对于不同业务，如果包含I/O操作或者锁，为了业务不被阻塞，需要开启多个线程来执行不同的业务，线程情况如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151022.88760138111870945913573003701002:50001231000000:2800:DF049753EDA1D9C9EAC7DF39B209E7914ABB493F4E7796E7481A98BD37147033.jpg)
因此，应用上经常存在几百个线程，增加了调度开销和内存占用。
ArkTS并发模型
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151023.41441313148776027490145339880573:50001231000000:2800:23C6B409F208FE8D82E7D4C3472B6ABF2DB387F0B31B07EFE83EE2C29BDFFB8A.jpg)
ArkTS采用了内存隔离的线程模型，不同线程之间通过消息通信，线程内无锁化运行。对于不同业务，其内部的I/O操作会由系统分发到后台的I/O任务池，不阻塞ArkTS上层逻辑，线程情况如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151023.47382733978626775616033819739357:50001231000000:2800:8BE10B073B08E9E1796A17660EF20FE0497AE18740B60059FA32E36D5E7F05F4.jpg)
异步I/O不阻塞ArkTS线程，同时TaskPool及I/O线程池由系统管理，提升能效。
ArkTS语言支持了TaskPool和Worker的并发能力，接下来简单介绍TaskPool和Worker的功能。
TaskPool的运作机制可参考TaskPool简介，TaskPool提供了任务分发的入口，支持将任务分发到不同优先级的队列，TaskPool底层自动管理了一定数量的工作线程，会从队列获取任务执行。同时，工作线程会根据任务数量进行自动扩缩容，保证任务执行效率。TaskPool内部会根据任务量及当前线程数量，决定是否扩容或缩容，当任务较多时会扩容。线程的上限跟硬件核数相关，例如8核设备，线程数上限大概为7-15左右。
Worker的运作机制可参考Worker简介，空任务的Worker线程的内存占用大约2MB左右，因此需要控制线程的数量，避免内存过大。
ArkTS与传统共享内存并行化的差异
通过上述并发模型的对比，可以看出在ArkTS中的异步I/O操作，会分发到I/O任务池中，不阻塞ArkTS语言的执行。而Java需要大量线程进行阻塞I/O操作，导致线程数较多。
其次，ArkTS采用内存隔离的并发模型，不能跨线程共享对象，需要进行线程间数据通信。而Java可以直接访问不同线程的对象，但是需要使用锁进行数据的线程安全保护。
并发能力选择
概述
不同的业务场景用到的并发能力各不相同，此章节对常见的业务场景进行分类，并分别介绍各类业务场景的HarmonyOS APP开发方案设计。
耗时任务并发执行场景
-  在应用业务实现过程中，对于相对独立的耗时任务，如果放在主线程中执行会阻塞主线程的UI业务，出现卡顿丢帧等影响用户体验的问题。通常需要将这个独立的耗时任务放到单独的子线程中执行。典型的耗时任务有CPU密集型任务、I/O密集型任务以及同步任务。 常见业务场景 具体业务描述 场景类型 CPU密集型 I/O密集型 同步任务 图片/视频编解码 将图片或视频进行编解码再展示 √ √ × 压缩/解压缩 对本地压缩包进行解压操作，或者本地文件的压缩操作 √ √ × JSON解析 对JSON字符串的序列化和反序列化操作 √ × × 模型运算 对数据进行模型运算分析等 √ × × 网络下载 密集网络请求下载资源、图片、文件等 × √ × 数据库操作 将聊天记录、页面布局信息、音乐列表信息等保存到数据库，或者应用二次启动时，读取数据库展示相关信息 × √ × 上述业务场景均为独立的耗时任务，任务执行周期短，跟外部交互较少，只包含有限的输入和输出，分发到后台线程执行后再获取结果。这些类型的任务使用TaskPool可以简化开发工作量，避免管理复杂的生命周期，避免线程泛滥，开发者只需要将上述独立的任务放入TaskPool队列，再等待结果即可。
-  ArkTS提供了任务池（TaskPool）的并发能力，可以将独立的耗时任务分发到子线程中执行，满足上述业务场景并行化执行的诉求，开发者只需要如下三个步骤即可完成任务并发编程。实现方案介绍： 步骤一：将需要在子线程执行的任务封装成一个@Concurrent修饰的函数； 步骤二：通过TaskPool的任务执行接口将任务分发到子线程； 步骤三：异步执行结束后在宿主线程接收结果，进行后续处理。
-  由于TaskPool底层采用内存隔离的并发模型，对象的跨线程传输存在性能开销，需要控制线程间传递对象的大小及交互频率（200KB的典型耗时约1ms）。 由于执行时间较长的任务会占据任务池中的线程，导致其他任务没有空闲线程调度，因此对于一直占据任务线程执行超过3分钟的任务，系统会进行回收。 网络下载、文件访问等异步I/O操作系统会分发到I/O线程池，不受上面规则约束。 由于TaskPool任务会在子线程中执行，与宿主线程上下文环境存在差异，因此需要保证任务的独立性，内部实现只能依赖模块化导入或者参数传入。
-  由于TaskPool底层采用内存隔离的并发模型，对象的跨线程传输存在性能开销，需要控制线程间传递对象的大小及交互频率（200KB的典型耗时约1ms）。
-  由于执行时间较长的任务会占据任务池中的线程，导致其他任务没有空闲线程调度，因此对于一直占据任务线程执行超过3分钟的任务，系统会进行回收。 网络下载、文件访问等异步I/O操作系统会分发到I/O线程池，不受上面规则约束。
-  由于TaskPool任务会在子线程中执行，与宿主线程上下文环境存在差异，因此需要保证任务的独立性，内部实现只能依赖模块化导入或者参数传入。
```typescript
import { taskpool } from '@kit.ArkTS';
@Concurrent
async function foo(a: number, b: number) {
return a + b;
}
taskpool.execute(foo, 1, 2).then((ret: Object) => { // 结果处理
console.log('Return:' + ret);
})
```
-  业界均采用线程池方案，与TaskPool无特殊差异。
-  对于独立的耗时任务，不建议采用Worker来实现。
| 常见业务场景  | 具体业务描述  | 场景类型  |
| --- | --- | --- |
| CPU密集型  | I/O密集型  | 同步任务  |
| 图片/视频编解码  | 将图片或视频进行编解码再展示  | √  | √  | ×  |
| 压缩/解压缩  | 对本地压缩包进行解压操作，或者本地文件的压缩操作  | √  | √  | ×  |
| JSON解析  | 对JSON字符串的序列化和反序列化操作  | √  | ×  | ×  |
| 模型运算  | 对数据进行模型运算分析等  | √  | ×  | ×  |
| 网络下载  | 密集网络请求下载资源、图片、文件等  | ×  | √  | ×  |
| 数据库操作  | 将聊天记录、页面布局信息、音乐列表信息等保存到数据库，或者应用二次启动时，读取数据库展示相关信息  | ×  | √  | ×  |
1.  由于TaskPool底层采用内存隔离的并发模型，对象的跨线程传输存在性能开销，需要控制线程间传递对象的大小及交互频率（200KB的典型耗时约1ms）。
2.  由于执行时间较长的任务会占据任务池中的线程，导致其他任务没有空闲线程调度，因此对于一直占据任务线程执行超过3分钟的任务，系统会进行回收。 网络下载、文件访问等异步I/O操作系统会分发到I/O线程池，不受上面规则约束。
3.  由于TaskPool任务会在子线程中执行，与宿主线程上下文环境存在差异，因此需要保证任务的独立性，内部实现只能依赖模块化导入或者参数传入。
常驻任务并发执行场景
-  在应用业务实现过程中，对于一些长耗时（大于3min）且并发量不大的常驻任务场景，使用Worker在后台线程中运行这些耗时逻辑，避免阻塞主线程而导致出现丢帧卡顿等影响用户体验性的问题 。 常驻不是指可以在后台保活运行的任务，而是相比于短时任务，时间更长的任务，可能与主线程生命周期一致。 常见的业务场景如下所示： 常见业务场景 具体业务描述 场景类型 游戏中台场景 启动子线程作为游戏业务的主逻辑线程，UI线程只负责渲染 常驻任务 产线硬件压测 需要阻塞调用硬件能力，做老化测试，阻塞式 阻塞任务
-  ArkTS提供了Worker的并发能力，支持Worker线程与宿主线程之间进行通信，开发者需要主动创建或关闭Worker线程。实现方案介绍： 步骤一：创建Worker对象； 步骤二：在Worker线程中绑定Worker对象，并处理需要在子线程执行的逻辑； 步骤三：宿主线程可以与子线程双向通信，处理数据。
-  由于Worker一旦被创建不会主动被销毁，若不处于任务状态一直运行，在一定程度上会造成资源的浪费，需要及时关闭空闲的Worker。 onmessage：表示宿主线程接收到来自其创建的Worker通过子线程postMessage接口发送的消息时被调用的事件处理程序，处理程序在宿主线程中执行。 onerror：表示Worker在执行过程中发生异常被调用的事件处理程序，处理程序在宿主线程中执行。 onmessageerror：表示当Worker对象接收到一条无法被序列化的消息时被调用的事件处理程序，处理程序在宿主线程中执行。 onexit：表示Worker销毁时被调用的事件处理程序，处理程序在宿主线程中执行。
-  由于Worker一旦被创建不会主动被销毁，若不处于任务状态一直运行，在一定程度上会造成资源的浪费，需要及时关闭空闲的Worker。
-  onmessage：表示宿主线程接收到来自其创建的Worker通过子线程postMessage接口发送的消息时被调用的事件处理程序，处理程序在宿主线程中执行。 onerror：表示Worker在执行过程中发生异常被调用的事件处理程序，处理程序在宿主线程中执行。 onmessageerror：表示当Worker对象接收到一条无法被序列化的消息时被调用的事件处理程序，处理程序在宿主线程中执行。 onexit：表示Worker销毁时被调用的事件处理程序，处理程序在宿主线程中执行。
-  @ohos.worker (启动一个Worker)
-  与业界方案一致，均采用独立线程执行常驻任务。
-  常驻任务不推荐作为任务分发给TaskPool。
| 常见业务场景  | 具体业务描述  | 场景类型  |
| --- | --- | --- |
| 游戏中台场景  | 启动子线程作为游戏业务的主逻辑线程，UI线程只负责渲染  | 常驻任务  |
| 产线硬件压测  | 需要阻塞调用硬件能力，做老化测试，阻塞式  | 阻塞任务  |
1.  由于Worker一旦被创建不会主动被销毁，若不处于任务状态一直运行，在一定程度上会造成资源的浪费，需要及时关闭空闲的Worker。
2.  onmessage：表示宿主线程接收到来自其创建的Worker通过子线程postMessage接口发送的消息时被调用的事件处理程序，处理程序在宿主线程中执行。 onerror：表示Worker在执行过程中发生异常被调用的事件处理程序，处理程序在宿主线程中执行。 onmessageerror：表示当Worker对象接收到一条无法被序列化的消息时被调用的事件处理程序，处理程序在宿主线程中执行。 onexit：表示Worker销毁时被调用的事件处理程序，处理程序在宿主线程中执行。
传统共享内存并发业务
-  当前HarmonyOS APP开发过程中，绝大多数应用都是通过共享内存模型语言（接下来以Java对比）开发的原型应用迁移过来的。其中，并发多线程是差异较大的部分，开发者在应用初期调研阶段需要考虑并发的差异性，再设计应用的架构。
-  ArkTS语言的并发多线程开发，推荐使用TaskPool和Worker的API进行开发。 TaskPool偏向独立任务维度，该任务在线程中执行，无需关注线程的生命周期，为了线程池的调度效率，不建议执行常驻的任务。 Worker偏向线程的维度，支持长时间占据线程执行，需要主动管理线程生命周期。
-  应用开发时，若不进行频繁的I/O操作，不需要开启一个独占的线程进行。 在并发场景下，需要注意内存隔离线程模型的差异，子线程任务需要相对独立，减少与外部的数据交互，减少性能开销。 如果需要使用内存共享，当前可以通过Node-API到C++层进行共享，或者定义Sendable对象进行线程间数据共享。
-  对于Java上的并发，存在很多基于内存共享的跨线程对象访问及调用，HarmonyOS APP开发时需要注意内存隔离线程模型的差异。
-  控制并发任务的粒度，不推荐频繁跨线程交互。
长时任务并发执行场景
-  在应用业务实现过程中，对于需要长时间运行的独立耗时任务，如果放在主线程中执行会阻塞主线程的UI业务，出现卡顿丢帧等影响用户体验的问题。通常需要将这个独立的长时任务放到单独的子线程中执行。 典型的长时任务场景如下所示： 常见业务场景 具体业务描述 定期传感器数据采集 周期性采集一些传感器信息（例如位置信息、速度传感器等），应用运行阶段常驻运行。 Socket端口信息监听 长时间监听Socket数据，不定时需要响应处理。 上诉业务场景均为独立的长时任务，任务执行周期长，跟外部交互简单，分发到后台线程后，需要不定期响应，以获取结果。这些类型的任务使用TaskPool可以简化开发工作量，避免管理复杂的生命周期，避免线程泛滥，开发者只需要将上诉独立的长时任务放入TaskPool队列，再等待结果即可。
-  ArkTS提供了任务池（TaskPool）的并发能力，可以将长时任务分发到子线程中执行，满足上诉业务场景并行化执行的诉求，开发者只需要如下三个步骤即可完成任务并发编程。实现方案介绍： 步骤一：将需要在子线程执行的任务封装成一个@Concurrent修饰的函数； 步骤二：通过TaskPool的长时任务执行接口将任务分发到子线程； 步骤三：任务执行过程中，不定期接收数据，返回给宿主线程处理。
-  长时任务不同于阻塞任务，长周期运行，但是每次执行不会阻塞线程很久。因此不推荐将需要独占线程的任务封装成长时任务。
-  业界一般采用单独的线程池，HarmonyOS是可调度的任务。
-  对于非常驻的长时任务，不建议采用Worker来实现。 长时任务指的是长时间不间断运行的独立任务，例如监听某个事件，发起执行后不会再接收发起方的输入，虽然也可以使用worker（推荐常驻后台任务才使用worker），但是更推荐使用TaskPool，TaskPool更方便，资源消耗更低。TaskPool和Worker的实现特点对比。
| 常见业务场景  | 具体业务描述  |
| --- | --- |
| 定期传感器数据采集  | 周期性采集一些传感器信息（例如位置信息、速度传感器等），应用运行阶段常驻运行。  |
| Socket端口信息监听  | 长时间监听Socket数据，不定时需要响应处理。  |
并发任务管理
概述
目前已提供任务的不同执行方式，可以管理任务的执行顺序、优先级等，此章节对需要控制任务执行方式的场景进行分类，并分别介绍各类任务执行场景的HarmonyOS APP开发方案设计。
多任务关联执行（串行顺序依赖）
-  在应用业务实现过程中，可以使用串行队列机制，使多个任务按照一定的顺序依次执行，而不会出现并发或乱序的情况。一般情况下，串行队列可用于保证任务执行顺序与数据的一致性，避免多线程竞争和死锁问题，也可以简化多线程编程，适用于后置任务对前置任务存在依赖等场景。 常见的业务场景如下所示： 常见业务场景 具体业务描述 API执行队列 调用模块接口，存在执行顺序要求 渲染指令队列 操作DOM树、渲染等，有时序要求 启动时遍历程序包 启动遍历小程序包、清理包、资源加载等串行操作
-  ArkTS提供串行队列（SequenceRunner）能力，可以将多个任务加入到串行队列中，使加入队列的任务按顺序执行，也可以创建多组串行队列分组管理，以满足上述场景对串行执行的要求，开发者可通过以下步骤完成串行任务队列的创建与执行。实施方案介绍： 步骤一：创建需要串行执行的任务task_1 ~ task_n； 步骤二：创建串行队列runner； 步骤三：按照需要执行的顺序，依次将任务添加至runner内。
-  额外添加的任务依赖可能导致串行队列冲突，即使添加的依赖本身遵循串行队列顺序也会被拦截。 当串行队列任务中任务执行失败、或被cancel，后续任务依旧会被执行。
-  额外添加的任务依赖可能导致串行队列冲突，即使添加的依赖本身遵循串行队列顺序也会被拦截。
-  当串行队列任务中任务执行失败、或被cancel，后续任务依旧会被执行。
```typescript
import { taskpool } from '@kit.ArkTS';
@Concurrent
function additionDelay(delay: number): void {
let start: number = new Date().getTime();
while (new Date().getTime() - start < delay) {
continue;
}
}
@Concurrent
function waitForRunner(resString: string): string {
return resString;
}
async function seqRunner() {
let result: string = "";
let task1: taskpool.Task = new taskpool.Task(additionDelay, 300);
let task2: taskpool.Task = new taskpool.Task(additionDelay, 200);
let task3: taskpool.Task = new taskpool.Task(additionDelay, 100);
let task4: taskpool.Task = new taskpool.Task(waitForRunner, 50);
let runner: taskpool.SequenceRunner = new taskpool.SequenceRunner();
runner.execute(task1).then(() => {
result += 'a';
});
runner.execute(task2).then(() => {
result += 'b';
});
runner.execute(task3).then(() => {
result += 'c';
});
await runner.execute(task4);
console.info("seqrunner: result is " + result);
}
```
-  对于串行队列中某个任务执行失败后处理，业界尚无统一规范。 当前HarmonyOS APP开发中实现方式为继续后续任务的执行，若后续任务依赖上一个任务的结果输出，开发者需考虑任务失败场景的异常处理。
| 常见业务场景  | 具体业务描述  |
| --- | --- |
| API执行队列  | 调用模块接口，存在执行顺序要求  |
| 渲染指令队列  | 操作DOM树、渲染等，有时序要求  |
| 启动时遍历程序包  | 启动遍历小程序包、清理包、资源加载等串行操作  |
1.  额外添加的任务依赖可能导致串行队列冲突，即使添加的依赖本身遵循串行队列顺序也会被拦截。
2.  当串行队列任务中任务执行失败、或被cancel，后续任务依旧会被执行。
多任务关联执行（树状依赖）
-  任务依赖是一种用于管理并发任务执行顺序的管理机制。通过任务依赖，可以指定一个任务在另一个任务完成后才能执行，从而构建出复杂的任务执行流程。任务依赖可以帮助开发者控制任务之间的依赖关系，确保任务按照预期的顺序执行。在TaskPool中，任务依赖是通过使用addDependency和removeDependency实现的。 常见的业务场景如下所示： 常见业务场景 具体业务描述 场景类型 CPU密集型 I/O密集型 同步任务 图片解码 解析一张大图，将大图数据拆成n份并放到n个任务中执行，执行完后通过这n个任务都依赖的一个任务对结果进行处理并返回 √ √ × 数据库操作 A任务执行需要B任务执行结果。B任务执行完将结果更新到数据库，再执行依赖B的A任务，A任务从数据库中获取B任务结果 × √ × 网络下载 A任务下载数据，B任务对数据进行处理。B任务执行依赖A任务结果 × √ ×
-  TaskPool目前提供addDependency（增加对其他任务的依赖）和removeDependency（移除对其他任务的依赖）两个接口，开发者可以通过调用这两个接口对任务设置依赖关系。任务默认不存在依赖关系，即不依赖其他任务和其他任务不依赖当前任务。 TaskPool内部维护一个任务依赖关系列表，调用addDependency/removeDependency对该列表进行数据更新。任务执行时前查询该列表，若该任务依赖其他任务，则该任务等待这些任务全部执行结束再执行；若该任务被其他任务依赖，则该任务执行结束会将依赖它的这些任务加入到Taskpool等待执行的队列中。
```typescript
import { taskpool } from '@kit.ArkTS';
@Concurrent
function updateSAB(args: Uint32Array) {
if (args[0] == 0) {
args[0] = 100;
return 100;
} else if (args[0] == 100) {
args[0] = 200;
return 200;
} else if (args[0] == 200) {
args[0] = 300;
return 300;
}
return 0;
}
let sab = new SharedArrayBuffer(20);
let typedArray = new Uint32Array(sab);
let task1 = new taskpool.Task(updateSAB, typedArray);
let task2 = new taskpool.Task(updateSAB, typedArray);
let task3 = new taskpool.Task(updateSAB, typedArray);
task1.addDependency(task2);
task2.addDependency(task3);
taskpool.execute(task1).then((res: object) => {
console.info("taskpool:: execute task1 res: " + res);
})
taskpool.execute(task2).then((res: object) => {
console.info("taskpool:: execute task2 res: " + res);
})
taskpool.execute(task3).then((res: object) => {
console.info("taskpool:: execute task3 res: " + res);
})
```
-  业界实现的多数任务依赖机制，与TaskPool提供的任务依赖机制表现无明显差异。
| 常见业务场景  | 具体业务描述  | 场景类型  |
| --- | --- | --- |
| CPU密集型  | I/O密集型  | 同步任务  |
| 图片解码  | 解析一张大图，将大图数据拆成n份并放到n个任务中执行，执行完后通过这n个任务都依赖的一个任务对结果进行处理并返回  | √  | √  | ×  |
| 数据库操作  | A任务执行需要B任务执行结果。B任务执行完将结果更新到数据库，再执行依赖B的A任务，A任务从数据库中获取B任务结果  | ×  | √  | ×  |
| 网络下载  | A任务下载数据，B任务对数据进行处理。B任务执行依赖A任务结果  | ×  | √  | ×  |
多任务同步等待结果（任务组）
-  复数个任务并发执行，等所有任务执行完毕后统一返回一个完整结果，其中任意一个任务失败或取消会导致整个任务的结果失败。 常见业务场景 具体业务描述 场景类型 图片解析生成直方图 一张图片，为了并发加速，拆分成多个ArrayBuffer进行解析，在所有任务解析完成后统一返回结果将解析结果拼成一个完整的直方图进行渲染 CPU密集型
-  任务组能力目前通过TaskPool模块提供，以图片生成直方图为例进行介绍。 步骤一：定义并发函数（@Concurrent function），将承载图片数据的ArrayBuffer的解析逻辑封装在一个并发函数中； 步骤二：遍历ArrayBuffer，每个ArrayBuffer对应构造一个并发解析任务，将这些任务都添加到任务组中； 步骤三：通过TaskPool执行任务组，并在回调函数中执行直方图的拼接逻辑或异常处理逻辑。
| 常见业务场景  | 具体业务描述  | 场景类型  |
| --- | --- | --- |
| 图片解析生成直方图  | 一张图片，为了并发加速，拆分成多个ArrayBuffer进行解析，在所有任务解析完成后统一返回结果将解析结果拼成一个完整的直方图进行渲染  | CPU密集型  |
多任务优先级调度
-  优先级体现了任务对于应用当前业务场景的重要性。在并发场景下，系统和线程池的资源是有限的。在资源既定的情况下，系统会分配更多资源优先处理高优先级的任务，尽量保证此类任务的即时性，而低优先级的任务的调度则会相对滞后。TaskPool提供了多任务优先级调度机制，供开发者根据业务场景，合理设置优先级。 常见的业务场景如下所示： 常见业务场景 具体业务描述 场景类型 CPU密集型 I/O密集型 即时性 处理耗时的图片数据 拍摄输入或美化图片时会将图片数据放在TaskPool中处理，且需要在一定毫秒内将数据返回主线程渲染，为保证任务的即时性，影响用户体验，可以设置高优先级使任务被优先调度 √ × √ 日志落盘 将业务日志信息写到文件或数据库中，优先级较低 × √ ×
-  TaskPool提供了4种优先级属性: HIGH、MEDIUM、LOW、以及IDLE（高、中、低、后台）。 目前，仅有taskpool.Task支持优先级属性的设置（function类型不支持），默认优先级为MEDIUM。开发者可以通过taskpool.execute()接口在抛任务时显式指定优先级。 TaskPool底层对HIGH、MEDIUM、LOW任务的调度按照M:N:1进行，即每调用M个高优先级任务后会去调用1个中优先级任务。每调用N个中优先级任务后会去调用1个低优先级任务。通过配置比例关系，在保证高优先级任务优先执行的情况下，中优先级任务得到合理调度，低优先级任务不会饿死（目前M:N:1为5:5:1）。 优先级机制底层对接了QoS（quality-of-service），因此3种属性也对应着不同的线程优先级。高优先级的任务除了在TaskPool队列中会得到优先调度外，在CPU调度上也会获得更多的系统资源。 Priority的IDLE优先级是用来标记需要在后台运行的耗时任务（例如数据同步、备份。），它的优先级别是最低的。这种优先级标记的任务只会在所有线程都空闲的情况下触发执行，并且只会占用一个线程来执行。
-  业界大多提供了优先级机制，与TaskPool中的优先级无明显差异。
-  不推荐应用过多设置高优先级或者不合理的优先级。
| 常见业务场景  | 具体业务描述  | 场景类型  |
| --- | --- | --- |
| CPU密集型  | I/O密集型  | 即时性  |
| 处理耗时的图片数据  | 拍摄输入或美化图片时会将图片数据放在TaskPool中处理，且需要在一定毫秒内将数据返回主线程渲染，为保证任务的即时性，影响用户体验，可以设置高优先级使任务被优先调度  | √  | ×  | √  |
| 日志落盘  | 将业务日志信息写到文件或数据库中，优先级较低  | ×  | √  | ×  |
任务延时调度
-  在应用业务实现过程中，不是所有任务都需立刻执行，有些任务需延时一段时间后才需执行。 常见的业务场景如下所示： 常见业务场景 具体业务描述 缓存业务延时执行，不影响冷启动耗时 应用启动时，存在大量低优先级任务，例如二级界面的资源下载等，需要设置在3秒后执行，防止影响冷启动耗时
-  TaskPool提供了延时执行的能力，目前，只有taskpool.Task支持延时执行，开发者只需要如下三个步骤即可完成延时实现。实现方案介绍： 步骤一：创建Task对象； 步骤二：调用taskpool.executeDelayed实现延时执行，并在参数中依次填写延时时间：delayTime，执行任务：task，任务优先级（不填默认MEDIUM）：priority； 步骤三：接收延时任务返回的数据并作处理。
```typescript
import { taskpool } from '@kit.ArkTS';
@Concurrent
function concurrentTask(num: number): number {
console.log('这里添加需延时执行的任务');
return num;
}
// 创建任务
let task: taskpool.Task = new taskpool.Task(concurrentTask, 100);
// 延时执行task
taskpool.executeDelayed(3000, task, taskpool.Priority.HIGH).then((value: Object) => {
// 处理延时任务返回的结果
console.log("taskpool result: " + value);
});
```
-  业界大多提供了任务延时调度功能，与TaskPool中的任务延时调度无明显差异。
-  非必须场景不建议使用任务延时调度，防止延时结果处理时机不当。
| 常见业务场景  | 具体业务描述  |
| --- | --- |
| 缓存业务延时执行，不影响冷启动耗时  | 应用启动时，存在大量低优先级任务，例如二级界面的资源下载等，需要设置在3秒后执行，防止影响冷启动耗时  |
线程间通信
概述
线程间通信指的是并发多线程间存在的数据交换行为，目前已支持ArkTS、C++等开发语言，因此存在不同语言、不同线程的通信场景，接下来详细展开介绍。
同语言线程间通信（ArkTS内）
-  ArkTS线程指的是包含ArkTS运行环境的线程，包括主线程、TaskPool线程、Worker线程。它们之间可以通过不同的接口进行通信。 常见业务场景如下所示： 常见业务场景 具体业务描述 宿主JS线程<->TaskPool线程 通过使用TaskPool，分发任务到子线程。TaskPool子任务与其宿主线程之间需要通信的场景 宿主JS线程<->Worker线程 通过使用Worker，启动子线程，执行任务。Worker子线程与其宿主线程之间需要通信的场景 任意JS线程<->任意JS线程 除了上述两种线程外，其他任意两个JS线程需要通信的场景
-  跨线程交互场景 通信方式 通信优先级 宿主JS线程->TaskPool线程 参数传递后分发任务；过程中不支持正向通信 支持 TaskPool线程->宿主JS线程 结果返回；sendData触发宿主线程异步回调，底层为uv_async_send实现 不支持 宿主JS线程->Worker线程 采用postMessage&onmessage异步通信 不支持 Worker线程->宿主JS线程 异步方式：采用postMessage & onmessage异步通信 同步方式：支持Worker线程同步调用宿主线程注册的方法，并返回结果 不支持 任意JS线程<->任意JS线程 使用@ohos.emitter实现双向异步通信 支持
-  ArkTS线程推荐使用TaskPool及Worker的接口通信。
-  @ohos.worker (启动一个Worker) @ohos.taskpool（启动任务池） @ohos.events.emitter (Emitter)
-  线程通信采用消息循环的机制，与业界一致。
| 常见业务场景  | 具体业务描述  |
| --- | --- |
| 宿主JS线程<->TaskPool线程  | 通过使用TaskPool，分发任务到子线程。TaskPool子任务与其宿主线程之间需要通信的场景  |
| 宿主JS线程<->Worker线程  | 通过使用Worker，启动子线程，执行任务。Worker子线程与其宿主线程之间需要通信的场景  |
| 任意JS线程<->任意JS线程  | 除了上述两种线程外，其他任意两个JS线程需要通信的场景  |
| 跨线程交互场景  | 通信方式  | 通信优先级  |
| --- | --- | --- |
| 宿主JS线程->TaskPool线程  | 参数传递后分发任务；过程中不支持正向通信  | 支持  |
| TaskPool线程->宿主JS线程  | 结果返回；sendData触发宿主线程异步回调，底层为uv_async_send实现  | 不支持  |
| 宿主JS线程->Worker线程  | 采用postMessage&onmessage异步通信  | 不支持  |
| Worker线程->宿主JS线程  | 异步方式：采用postMessage & onmessage异步通信 同步方式：支持Worker线程同步调用宿主线程注册的方法，并返回结果  | 不支持  |
| 任意JS线程<->任意JS线程  | 使用@ohos.emitter实现双向异步通信  | 支持  |
跨语言多线程通信（C++与ArkTS）
-  ArkTS线程指的是包含ArkTS运行环境的线程，包括主线程、TaskPool线程和Worker线程。由于HarmonyOS支持通过Node-API开发C++业务，用户可以在C++层创建线程，因此C++线程存在与ArkTS线程通信的场景。 常见业务场景如下所示： 常见业务场景 具体业务描述 ArkTS线程（ArkTS）<->pthread线程 ArkTS线程的ArkTS部分与pthread线程的通信场景 ArkTS线程（C++）<->pthread线程 ArkTS线程的C++部分与pthread线程的通信场景 pthread线程<->pthread线程 C++线程间的通信场景
-  跨线程交互场景 通信方式 通信优先级 ArkTS线程（ArkTS）->pthread线程 不支持，需要转到C++ 不涉及 pthread线程->ArkTS线程（ArkTS） 采用napi_threadsafe_function通信 支持 pthread线程->ArkTS线程（C++） ArkTS线程（C++）-> pthread线程 开发者自定义行为 开发者自定义行为 pthread线程<->pthread线程
-  不建议为了同步调用，在C++层增加wait等机制，会导致卡死、掉帧等问题。
| 常见业务场景  | 具体业务描述  |
| --- | --- |
| ArkTS线程（ArkTS）<->pthread线程  | ArkTS线程的ArkTS部分与pthread线程的通信场景  |
| ArkTS线程（C++）<->pthread线程  | ArkTS线程的C++部分与pthread线程的通信场景  |
| pthread线程<->pthread线程  | C++线程间的通信场景  |
| 跨线程交互场景  | 通信方式  | 通信优先级  |
| --- | --- | --- |
| ArkTS线程（ArkTS）->pthread线程  | 不支持，需要转到C++  | 不涉及  |
| pthread线程->ArkTS线程（ArkTS）  | 采用napi_threadsafe_function通信  | 支持  |
| pthread线程->ArkTS线程（C++）  |
| ArkTS线程（C++）-> pthread线程  | 开发者自定义行为  | 开发者自定义行为  |
| pthread线程<->pthread线程  |
线程间模块共享（单例模式）
-  某些进程唯一的ArkTS实例初始化流程复杂，整体耗时长，放在主线程中对其进行初始化会造成应用启动耗时久和阻塞主线程的执行。将这些实例的初始化流程放在ArkTS子线程中进行初始化，初始化完成后主线程可以直接使用该实例。 常见的业务场景如下所示： 常见业务场景 具体业务描述 SDK初始化 在ArkTS子线程中调用API的Init初始化得到一个单例对象，完成后传给其他ArkTS线程使用
-  步骤一：采用C++单例模式封装，上层封装JS壳，子线程进行初始化； 步骤二：初始化完成通知主线程，主线程导入使用该单例对象。
-  模块定义好的导出对象，也就是使用者Import时获得的模块对象。 JS模块对象中的JS Function通过Node-API方法绑定至该模块的Native静态方法，调用时将调用Native静态方法来提供实际功能。 模块对象的成员对象（ExternalReference），由Native Class的GetCurrentInstance（标准单例实现）获得，进程内同模块都指向同一个Native单例。本设计对原有Native实现中已经提供线程安全的C++类的功能时使用，即该实例的Native成员方法也需进行同步保护。 该模块对象即使有其它JS成员，也类似于”局部变量”，即线程间并不共享。 Native静态方法提供对应模块的Native功能实现，通过napi_get_cb_info获取JS Binding Function的this对象，从而通过this获取绑定在JS模块对象上的Native Instance，再调用Native Instance对应的Native成员方法，即可完成对应功能实现。 同上，方法实现不可以进行全局变量的非线程安全操作。 一般模块对象在主线程退出时进行析构。 若精细化控制，可绑定finalizeCallback进行管理，线程对象回收时会在该线程调用析构方法。
-  模块定义好的导出对象，也就是使用者Import时获得的模块对象。 JS模块对象中的JS Function通过Node-API方法绑定至该模块的Native静态方法，调用时将调用Native静态方法来提供实际功能。
-  模块对象的成员对象（ExternalReference），由Native Class的GetCurrentInstance（标准单例实现）获得，进程内同模块都指向同一个Native单例。本设计对原有Native实现中已经提供线程安全的C++类的功能时使用，即该实例的Native成员方法也需进行同步保护。 该模块对象即使有其它JS成员，也类似于”局部变量”，即线程间并不共享。
-  Native静态方法提供对应模块的Native功能实现，通过napi_get_cb_info获取JS Binding Function的this对象，从而通过this获取绑定在JS模块对象上的Native Instance，再调用Native Instance对应的Native成员方法，即可完成对应功能实现。 同上，方法实现不可以进行全局变量的非线程安全操作。
-  一般模块对象在主线程退出时进行析构。 若精细化控制，可绑定finalizeCallback进行管理，线程对象回收时会在该线程调用析构方法。
-  步骤一：采用ArkTS对象，定义Sendable类的单例，封装成共享模块（进程内共享），子线程进行初始化； 步骤二：初始化完成通知主线程，主线程导入使用该单例对象。
-  Sendable类需要满足一定的约束，可参考@Sendable装饰器。
-  Java存在ClassLoader机制，所有类型是静态且唯一的，因此可以很方便的导入类，支持单例模式。而HarmonyOS APP开发时需要借助共享模块，保证类只加载一次，保证唯一性。
| 常见业务场景  | 具体业务描述  |
| --- | --- |
| SDK初始化  | 在ArkTS子线程中调用API的Init初始化得到一个单例对象，完成后传给其他ArkTS线程使用  |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151023.76324793057287410191489637129005:50001231000000:2800:7351A41BDE6AA4A4A823625A1527BDB6119CC967F42317F8C2BB0BF26AA95A3C.jpg)
1.  模块定义好的导出对象，也就是使用者Import时获得的模块对象。 JS模块对象中的JS Function通过Node-API方法绑定至该模块的Native静态方法，调用时将调用Native静态方法来提供实际功能。
2.  模块对象的成员对象（ExternalReference），由Native Class的GetCurrentInstance（标准单例实现）获得，进程内同模块都指向同一个Native单例。本设计对原有Native实现中已经提供线程安全的C++类的功能时使用，即该实例的Native成员方法也需进行同步保护。 该模块对象即使有其它JS成员，也类似于”局部变量”，即线程间并不共享。
3.  Native静态方法提供对应模块的Native功能实现，通过napi_get_cb_info获取JS Binding Function的this对象，从而通过this获取绑定在JS模块对象上的Native Instance，再调用Native Instance对应的Native成员方法，即可完成对应功能实现。 同上，方法实现不可以进行全局变量的非线程安全操作。
4.  一般模块对象在主线程退出时进行析构。 若精细化控制，可绑定finalizeCallback进行管理，线程对象回收时会在该线程调用析构方法。
线程间不可变数据共享
-  定义为Sendable类型的对象在发送到其他TS线程后可被多线程读写，开发者需要通过异步锁机制进行管理。需要一种能力保障对象的数据被多线程访问时准确，要么通过锁机制要么使对象变成只读对象。 常见的业务场景如下所示： 常见业务场景 具体业务描述 全局环境变量共享 应用启动时生成一些资源加载入口、配置参数、全局变量等不需要更新的变量，可通过冻结能力冻结后共享到多个ArkTS子线程 一次性产物不可变共享 业务阶段性产生的页面布局数据，这个数据是在工作线程生成的，传输并缓存在UI线程后不会修改，可能会多次作为UI渲染的输入使用
-  通过冻结API，使共享对象变成只读对象。实现方案介绍： 步骤一：业务逻辑定义、生成需要的Sendable对象； 步骤二：发送到其他ArkTS线程前通过Object.Freeze API冻结该对象； 步骤三：通过taskpool或worker的消息通信机制将该对象共享到其他ArkTS线程。
-  冻结后对象不可修改，如果修改会抛出ArkTS异常。
-  以全局环境变量共享为例：
```typescript
// xxx.ets
import { worker } from '@kit.ArkTS';
import { freezeObj } from './freezeObj';
@Sendable
export class GlobalConfig {
// 一些配置属性与方法
init() {
// 初始化相关逻辑
freezeObj(this) // 初始化完成后冻结当前对象
}
}
let globalConfig = new GlobalConfig();
globalConfig.init();
const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ets`', { name: 'Worker1' });
workerInstance.postMessage(globalConfig);
```
-  内存共享模型如Java/C++对象在不同线程间都是可见的，Sendable对象(共享)需要将对象引用发送到其他线程才可使用。
| 常见业务场景  | 具体业务描述  |
| --- | --- |
| 全局环境变量共享  | 应用启动时生成一些资源加载入口、配置参数、全局变量等不需要更新的变量，可通过冻结能力冻结后共享到多个ArkTS子线程  |
| 一次性产物不可变共享  | 业务阶段性产生的页面布局数据，这个数据是在工作线程生成的，传输并缓存在UI线程后不会修改，可能会多次作为UI渲染的输入使用  |
生产者与消费者模式
-  生产者与消费者模式表现为以下几个特征： 1. 有复数或单数个生产者并发地生产数据； 2. 有复数或单数个消费者并发地消费数据； 3. 存在一个数据缓存区，生产者生产出的数据存储在缓存区，消费者从缓存区中取数据，当缓存区满的时候要通知生产者停止生产，当缓存区为空时通知消费者休眠直到生产者添加数据。 常见的业务场景如下所示： 常见业务场景 具体业务描述 场景类型 阅读应用页面预加载 用户每次翻页或跳转后需要预加载复数张前后页，将前后页的加载请求缓存到一个加载队列中，将队列中的页面布局解析任务并发地执行 CPU密集型 + IO密集型 本地文件上传 用户在主线程一次上传单个或复数个文件，上传文件的请求被储存在一个上传队列中，并发地将队列中的文件上传到云端 CPU密集型+ IO密集型
-  以阅读应用场景为例： 步骤一：用户一次翻页产生复数个前后页预加载的请求； 步骤二：通过网络接口从云端下载复数页面的原始数据； 步骤三：通过taskpool并发地解析每一页的页面原始数据生成page对象，page对象描述了页面的布局信息和每个组成部分； 步骤四：taskpool执行的结果返回到UI线程的缓存队列中； 步骤五：缓存队列中的页面数据中临近用户当前页的page对象执行渲染任务。
-  1. 内存共享模型如Java/C++对象在不同线程间都是可见的，ArkTS是线程间内存隔离的内存模型对象在不同线程间使用需要序列化(拷贝)，Sendable对象(共享)需要将对象引用发送到其他线程才可使用。 2. Sendable对象存在较多约束，尽量只将必须共享的对象定义为Sendable对象，由普通的ArkTS对象持有Sendable对象并将整个流程串起来。
| 常见业务场景  | 具体业务描述  | 场景类型  |
| --- | --- | --- |
| 阅读应用页面预加载  | 用户每次翻页或跳转后需要预加载复数张前后页，将前后页的加载请求缓存到一个加载队列中，将队列中的页面布局解析任务并发地执行  | CPU密集型 + IO密集型  |
| 本地文件上传  | 用户在主线程一次上传单个或复数个文件，上传文件的请求被储存在一个上传队列中，并发地将队列中的文件上传到云端  | CPU密集型+ IO密集型  |
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-application-aspect-programming-design
爬取时间: 2025-05-01 08:42:43
来源: Huawei Developer
概述
切面编程（AOP）是一种通过预编译方式和运行期间动态代理实现程序功能的统一维护的技术。AOP的核心思想是将程序的关注点（concern）分离，通过在程序中插入代码来实现横切关注点（cross-cutting concerns），从而实现对业务逻辑的各个部分进行隔离，降低它们之间的耦合度，提高程序的可维护性和可重用性，同时提高了开发的效率。
在AOP中，开发者可以通过定义切面（aspect）来封装横切关注点，而不需要直接修改业务逻辑代码。这种方式要求在不修改源代码的前提下添加功能，常用于将业务代码和非业务代码剥离，比如参数校验、日志记录、性能统计等非业务代码，以达到更好的代码解耦效果。
HarmonyOS主要通过插桩机制来实现切面编程，并提供了Aspect类，包括addBefore、addAfter和replace接口。这些接口可以在运行时对类方法进行前置插桩、后置插桩以及替换实现，为开发者提供了更灵活的操作方式。在具体业务场景中，不同的需求可能需要不同的埋点功能和日志记录。通过调用addBefore、addAfter和replace接口，可以实现对类方法的各种功能增强和定制化需求：
下面，本文将介绍对应接口的基本原理，并针对以上业务场景，具体说明怎么利用运行时插桩的接口完成对类方法的埋点和加日志功能。
插桩原理介绍
addBefore、addAfter、replace接口的原理基于class的ECMAScript语义，即类的静态方法是类的属性，类的实例方法是类的原型对象(prototype)的属性。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151023.29913797687954412392467966278538:50001231000000:2800:6D247EF4F28AC5BC4AA5EF8C31FE96AC912EF965125453B4E79836766DC3EB94.png)
原理解析
类的实例会有一个属性__proto__(称为原型)，它是指向类的prototype的引用（如下图2所示）。实例在调用方法时，实际上会先通过__proto__找到类的prototype，再在prototype中找到这个方法，再执行调用逻辑。类的原型对象(prototype)被这个类的所有实例共享，这意味着修改类的原型对象里面存储的方法，会对这个类的所有实例产生效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151023.76262122249009389460809782603539:50001231000000:2800:BC76DC4D0463900448183A7F1D28220DB394B2A2488E5CA7567AB0B3B32F3DD1.png)
原型对象也有原型__proto__。类的继承就是通过原型来实现的。实例方法的调用实际上在运行时就是通过在原型串联的链上查找方法，找到方法再执行调用（如下图3所示）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151023.38194814755545101423024953646836:50001231000000:2800:9D6EE340C0FBD628EC8ED783733888F62F776879A659F2881914E10EDF3BF501.png)
插桩和替换的操作本质上就是将回调参数和原方法组合成一个新的函数，再用新的函数替换原方法（如下图4所示）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151023.04310656333534807540926111720044:50001231000000:2800:5366018F11DC626C621A5F3391C6038042B14B5F26CB847D52C92F29DAF3CE3D.png)
接口原理的伪代码示意
addBefore: 类方法前插桩
addAfter: 类方法后插桩
replace: 替换类方法
场景1：方法参数校验
业务开发团队没有关注参数的合法性，运维团队发现了这个问题，需要紧急修复。然而，让业务开发团队修改的流程较为繁琐，因此运维团队决定临时采取插桩的方式给方法加上参数合法性校验的逻辑。
举例来说，A团队开发了基础能力模块并将能力封装在class A中。在应用集成基础能力模块时，发现需要对class A的方法加入参数校验的逻辑，以应对可能的非法输入。因此，运维团队决定在临时修复过程中，通过插桩的方式临时添加参数合法性校验的逻辑，以确保系统的稳定性和安全性。
场景分析
在addBefore接口的回调参数中，可以访问原方法的参数，因此可以利用addBefore在方法前插入参数校验的逻辑。这是运行时行为，需要在addBefore执行后才会生效，因此通常在应用入口调用接口进行插桩。
代码实现
在class A中，封装其基础能力，此处为获取数组指定下标的元素，具体代码实现如下：
在主界面中集成基础能力，并校验参数类型、判断下标是否越界，具体代码实现如下：
```typescript
// index.ets
import {A} from './baseAbility';
import {util} from '@kit.ArkTS';
@Entry
@Component
struct Index {
build() {
// UI代码
…
}
}
util.Aspect.addBefore(A, 'getElementByIndex', false,
// 参数校验
(instance: A, arr: Object, idx: number) => {
if (!(arr instanceof Array)) {
throw Error('arg arr is expected to be an array');
}
if (!(Number.isInteger(idx) && idx >= 0)) {
throw Error('arg idx is expected to be a non-negative integer');
}
if (idx >= arr.length) {
throw Error('arg idx is expected to be smaller than arr.length');
}
});
// 原方法执行
let buffer : Array<number> = [1,2,3,5];
let that = new A();
that.getElementByIndex(buffer,-1);
that.getElementByIndex(buffer,5);
that.getElementByIndex(123 as Object as Array<number> ,5)
```
场景2：统计方法执行次数、时间
在性能分析或调试场景中，性能管控团队需要统计应用运行过程中调用某个方法的次数或执行时间，如果让业务开发团队临时修改源代码并重新打包，效率较低且业务团队不一定有足够的人力资源来配合这一过程。因此，他们需要临时插入一个插桩来查看相关信息。
场景分析
通过在方法前插入调用次数自增的逻辑，addBefore可以用于统计调用次数。对于执行时间的统计，我们可以利用addBefore记录开始时间，而用addAfter记录结束时间。
为了存储执行次数和执行时间，可以利用闭包变量或者其他能够覆盖每次执行的变量的生命周期。
代码实现
统计执行次数，具体代码实现如下：
```typescript
// somePackage.ets
export class Test {
foo(){}
}
// index.ets
import {Test} from './somePackage';
import {util} from '@kit.ArkTS';
@Entry
@Component
struct Index {
build() {
// UI代码
…
}
}
util.TextDecoder.toString();
// 调用次数自增
let countFoo = 0;
util.Aspect.addBefore(Test, 'foo', false, () => {
countFoo++;
});
// 调用并打印日志
new Test().foo();
console.log('countFoo = ', countFoo);
// [LOG]: "countFoo = ", 1
let a = new Test();
a.foo()
console.log('countFoo = ', countFoo);
// [LOG]: "countFoo = ", 2
function bar(a: Test) {
a.foo();
console.log('countFoo = ', countFoo);
new Test().foo();
console.log('countFoo = ', countFoo);
}
bar(a);
// [LOG]: "countFoo = ", 3
// [LOG]: "countFoo = ", 4
console.log('countFoo = ', countFoo);
// [LOG]: "countFoo = ", 4
```
统计执行时间，具体代码实现如下：
```typescript
// somePackage.ets
export class Test {
doSomething() { // 实例方法
// ...
}
static test() { // 静态方法
// ...
}
}
// index.ets
import {Test} from './somePackage'
import {util} from '@kit.ArkTS';
@Entry
@Component
struct Index {
build() {
// UI代码
…
}
}
// 插入执行前后打印时间, 将插入动作封装成一个接口
function addTimePrinter(targetClass: Object, methodName: string, isStatic: boolean) {
let t1 = 0;
let t2 = 0;
util.Aspect.addBefore(targetClass, methodName, isStatic, () => {
t1 = new Date().getTime();
});
util.Aspect.addAfter(targetClass, methodName, isStatic, () => {
t2 = new Date().getTime();
console.log("t2---t1 = " + (t2 - t1).toString());
});
}
// 给Test的doSomething实例方法添加打印执行时间的逻辑
addTimePrinter(Test, 'doSomething', false);
new Test().doSomething()
// 给Test的test静态方法添加打印执行时间的逻辑
addTimePrinter(Test, 'test', true);
Test.test()
```
不推荐用该方式来统计在多个线程执行的函数，否则可能造成方法次数变量或者执行时间变量的写冲突。
场景3：校验方法返回值
在应用中大量使用的三方库提供的方法，希望对方法返回值进行校验。
场景分析
在addAfter的回调参数中，第二个参数是原方法的返回值，可以在回调中对这个返回值进行校验。
addAfter的回调返回值会代替原方法的返回值，如果不希望修改返回值，记得在回调中返回原方法的返回值。
代码实现
对三方库方法返回的网址进行校验，校验不通过的抛出异常，具体实现代码如下：
```typescript
// someThirdParty.ets
export class WebHandler {
getWebAddrHttps(): string {
let ret = 'http';
// ...
return ret;
}
}
// index.ets
import {WebHandler} from './someThirdParty';
import {util} from '@kit.ArkTS';
@Entry
@Component
struct Index {
build() {
// UI代码
…
}
}
util.Aspect.addAfter(WebHandler, 'getWebAddrHttps', false, (instance: WebHandler, ret: string) => {
if (!ret.startsWith('https')) {
throw Error('Handler\'s method \'getWebAddrHttps\': return value does not start with \'https\'');
}
// 校验没问题，记得将原方法返回值返回
return ret;
});
new WebHandler().getWebAddrHttps();
```
场景4：在方法中校验成员变量
希望在方法执行时，检查成员变量是否正常，以确保数据的完整性和准确性。这样可以在方法执行过程中及时发现潜在的问题，并采取相应的处理措施。
场景分析
在addBefore的回调参数中，第一个参数是原方法的this对象，可以通过这个参数获取成员变量或调用成员方法。通过访问this对象，可以实现对成员变量的实时监测和校验。
代码实现
在getInfo方法中校验Person类的name和age属性是否正常，具体实现代码如下：
```typescript
// somePackage.ets
export class Person {
name: string;
age: number;
constructor(n: string, a: number) {
this.name = n;
this.age = a;
}
getInfo(): string {
return 'name: ' + this.name + ', ' + 'age: ' + this.age.toString();
}
}
// index.ets
import {Person} from './somePackage';
import {util} from '@kit.ArkTS';
@Entry
@Component
struct Index {
build() {
// UI代码
…
}
}
// 校验name成员和age成员
util.Aspect.addBefore(Person, 'getInfo', false, (instance: Person) => {
if (instance.name.length == 0) {
throw Error('empty name');
}
if (instance.age < 0) {
throw Error('invalid age');
}
});
new Person('c', -1).getInfo();
```
场景5：替换方法实现
在某些情况下需要对原方法进行替换，以确保应用程序的正常运行和性能优化。例如，方法的实现可能调用了禁用的接口，或者方法的性能表现不佳需要进行改进等情况。
场景分析
replace的第四个参数是回调函数，该回调函数会代替原方法的执行。回调函数的第一个参数是this对象，而从第二个参数开始依次是原方法的参数。因此，通过replace的回调参数，我们可以获取原方法的所有执行上下文。这意味着可以利用replace接口来替换方法的实现，从而实现对原方法执行过程的全面控制和定制。
代码实现
修改Test类的foo方法中的打印日志，具体实现代码如下：
```typescript
// somePackage
export class Test {
foo(arg: string) {
console.log(arg);
}
}
// index.ets
import {Test} from './somePackage';
import {util} from '@kit.ArkTS';
@Entry
@Component
struct Index {
build() {
// UI代码
…
}
}
new Test().foo('123');
// [LOG]: "123"
// 替换原方法
util.Aspect.replace(Test, 'foo', false, (instance: Test, arg: string) => {
console.log(arg + ' __replaced implementation');
});
new Test().foo('123');
// [LOG]: "123 __replaced implementation"
```
场景6：替换子类继承的方法实现
某个子类调用了父类方法，实际业务中需要修改子类的方法实现，但同时希望不影响父类，从而不影响其它继承这个父类的子类。
场景分析
利用replace接口以子类为targetClass参数，替换子类方法的实现。
这一操作的底层原理是基于JavaScript的原型链机制。通过replace接口，新函数会被放置到子类的原型上，这样当执行子类的方法时，原型链机制会首先在子类原型上查找新函数来执行，而不会执行父类的方法，也不会影响到父类的其他子类。
案例一：替换子类一方法实现
Base有两个子类Child1和Child2，两个子类都继承了foo方法。需要修改Child1的foo的实现，但不影响Base和Child2的foo方法。具体实现代码如下：
```typescript
// base.ets
export class Base {
foo() {
console.log('hello');
}
}
// child1
import {Base} from './base';
export class Child1 extends Base {}
// child2
import {Base} from './base';
export class Child2 extends Base {}
// index.ets
import {util} from '@kit.ArkTS';
import {Child1} from './child1';
import {Child2} from './child2';
import {Base} from './base';
@Entry
@Component
struct Index {
build() {
// UI代码
…
}
}
// 修改Child1的foo的实现
util.Aspect.replace(Child1, 'foo', false, () => {
console.log('changed Child1 foo');
});
new Base().foo();
// [LOG]: "hello"
new Child1().foo();
// [LOG]: "changed Child1 foo"
new Child2().foo();
// [LOG]: "hello"
```
案例二：获取实时位置信息
原Child继承Base的获取实时位置方法，但测试发现Child的getCurrentLocation方法在实际场景调用非常频繁，需要控制调用频率，采取的措施是想修改Child的getCurrentLocation方法的实现，通过将位置信息缓存起来，下次调用的时候如果距离上次调用时间少于一分钟，则直接返回缓存的位置；否则才允许调用位置接口。具体实现代码如下：
```typescript
// base.ets
import {geoLocationManager} from "@kit.LocationKit";
export class Base {
getCurrentLocation() {
return geoLocationManager.getCurrentLocation();
}
}
// child.ets
import {Base} from "./base";
export class Child extends Base {
// 继承父类的getCurrentLocation方法
}
// index.ets
import {Child} from './child';
import {util} from '@kit.ArkTS';
import {geoLocationManager} from "@kit.LocationKit";
@Entry
@Component
struct Index {
build() {
// UI代码
…
}
}
let cached_location: Object | undefined;
let time: number | undefined;
util.Aspect.replace(Child, 'getCurrentLocation', false, () => {
let newTime = new Date().getTime();
// 一分钟最多调用一次实时位置
if (!cached_location || !time || newTime - time > 60000) {
time = newTime;
cached_location = geoLocationManager.getCurrentLocation();
}
// 返回缓存的位置信息
return cached_location;
});
new Child().getCurrentLocation()
```
访问设备的位置信息，必须申请以下权限，并且获得用户授权：
具体方法可参考向用户申请授权。
场景7：拉起应用时获取目标包名信息
希望在应用跳转时能够感知到目标应用的包名，实现对目标应用的识别和监控，确保跳转操作的安全性和准确性。
场景分析
将这个问题用插桩的语言简化下，就是希望在EntryAbility的onCreate方法中对UIAbilityContext类的startAbility方法进行插桩，以获取Want参数的bundleName属性。由于UIAbilityContext是系统提供的类且没有导出，无法直接import，因此可以通过EntryAbility的context成员（该成员是从UIAbility继承而来）获取UIAbilityContext类对象，然后在onCreate方法中完成插桩操作。这样可以实现对目标方法的监控和定制，以满足特定需求。
代码实现
通过类实例的constructor属性获取类对象，具体实现代码如下：
附录：接口使用注意事项
1.  如果确实有需要调用原方法的场景，实现方法参考如下示例。
```typescript
@Component
struct Index {
foo(){}
build(){};
}
util.Aspect.replace(Index, 'foo', false, ...);
util.Aspect.replace(Index, 'build', false, ...);
```
```typescript
// 不推荐的用法示例：
// 'somePackage';
class Test {
foo(): string {
return 'hello';
}
}
util.Aspect.addAfter(Test, 'foo', false, () => {
console.log('execute foo');
});
// 正确的用法示例：
class Test {
foo(): string {
return 'hello';
}
}
util.Aspect.addAfter(Test, 'foo', false, (instance: Test, ret: string) => {
console.log('execute foo');
return ret;  // 返回原方法的返回值
});
```
1.  如果类方法的属性描述符的writable字段为false，比如冻结(freeze) 的场景， 则不能调用接口操作这个类方法。 方法的属性描述符的writable字段默认为true。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-application-track-practice
爬取时间: 2025-05-01 08:42:57
来源: Huawei Developer
概述
埋点是指将信息采集程序和原本的功能代码结合起来，针对特定用户行为收集、处理和发送一些信息，用来跟踪应用使用情况。包括访问数、访客数、停留时长、页面浏览数和跳出率。以下是几种常见业务场景：
埋点分类
按照用户行为不同，埋点可以分为点击埋点、曝光埋点以及页面埋点等。
方案介绍
接下来会从（1）组件动态绑定埋点数据；（2）点击埋点方案；（3）曝光埋点方案；（4）页面埋点方案四部分介绍。整体方案使用全局无感监听能力UIObserver和setOnVisibleAreaApproximateChange属性实现埋点功能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151024.28978445267508865989372018536477:50001231000000:2800:B5B805B16955FAF0EE6B38B081DD640CD8635EAFAD6E9E69FEF77DD9D8613F89.png)
绑定埋点数据
首先针对需要埋点的组件指定对应的ID值以及埋点数据。比如Button组件可以指定ID为“button-1”，并且通过customProperty自定义属性设置key和value，key为组件ID，value为埋点数据。为方便拿取，可以将埋点数据统一定义在DataResource中。
其中DataResource在本示例中是根据Page名、组件名以及索引进行封装，以Page名作为最外层key层，以组件名+索引为里层key值。value值（埋点数据）可以根据实际业务进行配置。
点击埋点
配置完埋点数据以及成功绑定组件后，可以在EntryAbility里统一注册点击事件监听，在事件回调中获取点击的触发节点。UIObserver一共提供了两种监听事件：
这两种方式均可以实现用户点击组件时触发回调。本示例中以willClick监听为例，下面介绍具体方案实现。
实现步骤
除了点击事件外，UIObserver还可以通过on('scrollEvent')监听组件滑动。在滑动开始与结束触发回调并得到滑动偏移量。以瀑布流为例，对WaterFlow和FlowItem设置组件ID。
接着在EntryAbility里统一注册scrollEvent的事件监听，在回调中获取ScrollEventInfo信息，包括id、uniqueId、scrollEvent以及offset。
scrollEvent监听事件中回调参数的id值只能精确到外层组件WaterFlow，无法精确到里层FlowItem。如果想要在滑动过程中获取各个Item组件的曝光比例，可以参考第三小节曝光埋点。
曝光埋点
曝光埋点需要监听页面中每个组件的出现与消失，比如用户在滑动瀑布流时某个Item出现的时长超过500ms则记为一次有效曝光。为避免在每一个页面注入冗长代码，建议使用自定义“埋点钩子”组件进行封装，以下是具体实现步骤。
实现步骤
1.  （1）调用TrackManager的addTrack将当前组件与TrackShadow对象绑定起来。 （2）通过setOnVisibleAreaApproximateChange监听埋点组件的可视区域的变化；其中ratio值可以自定义设置，比如本示例设置了0.0、0.5、1.0。 （3）根据当前组件获取它的父亲节点，并且判断父亲节点有无埋点钩子，如果没有，则继续往上追溯，直到parent节点为null；如果有，则在父节点的子组件集合中添加当前节点。 注意在aboutToDisappear生命周期中必须调用TrackManager里的removeTrack将当前的组件信息删除。
```typescript
// entry\src\main\ets\viewModel\TrackNode.ets
// onDidBuild Life Cycle.
onDidBuild(): void {
// Construct the virtual tree of the tracing point.
// The obtained node is the root node of the current page (row in the test case).
let uid = this.getUniqueId();
let node: FrameNode | null = this.getUIContext().getFrameNodeByUniqueId(uid);
hilog.info(0x0000, 'ApplicationTrack', '%{public}s', `Track onDidBuild node:${node?.getNodeType()}`);
if (node === null) {
return;
}
this.trackShadow.node = node;
this.trackShadow.id = node?.getId();
this.trackShadow.track = this.track;
TrackManager.get().addTrack(this.trackShadow.id, this.trackShadow);
// The setOnVisibleAreaApproximateChange monitors and records the visible area of the tracing point component.
node?.commonEvent.setOnVisibleAreaApproximateChange(
{ ratios: [0, 0.5, 1], expectedUpdateInterval: 500 },
(ratioInc: boolean, ratio: number) => {
const areaChangeCb = CallbackManager.getInstance().getAreaChangeCallback();
areaChangeCb(node, ratio);
this.trackShadow.visibleRatio = ratio;
hilog.info(0x0000, 'ApplicationTrack', '%{public}s', `ratioInc: ${ratioInc}`);
hilog.info(0x0000, 'ApplicationTrack', '%{public}s', `ratio: ${ratio}`);
});
let parent: FrameNode | null = node?.getParent();
hilog.info(0x0000, 'ApplicationTrack', '%{public}s', `Parent getId: ${parent?.getId()}`);
let attachTrackToParent: (parent: FrameNode | null) => boolean =
(parent: FrameNode | null) => {
while (parent !== null) {
let parentTrack = TrackManager.get().getTrackById(parent?.getId());
if (parentTrack !== undefined) {
parentTrack.childIds.add(this.trackShadow.id);
this.trackShadow.parentId = parentTrack.id;
return true;
}
parent = parent.getParent();
}
return false;
};
let attached = attachTrackToParent(parent);
if (!attached) {
node?.commonEvent.setOnAppear(() => {
let attached = attachTrackToParent(parent);
if (attached) {
hilog.info(0x0000, 'ApplicationTrack', '%{public}s', `Track lazy attached: ${this.trackShadow.id}`);
}
});
}
}
```
```typescript
// entry\src\main\ets\viewModel\TrackNode.ets
/**
* Tracing point data operation class
*/
export class TrackManager {
static instance: TrackManager;
private trackMap: Map<string, TrackShadow> = new Map();
private rootTrack: TrackShadow | null = null;
static get(): TrackManager {
if (TrackManager.instance !== undefined) {
return TrackManager.instance;
}
TrackManager.instance = new TrackManager();
return TrackManager.instance;
}
addTrack(id: string, track: TrackShadow): void {
if (this.trackMap.size === 0) {
this.rootTrack = track;
}
hilog.info(0x0000, 'ApplicationTrack', '%{public}s', `Track add id: ${id}`);
this.trackMap.set(id, track);
}
removeTrack(id: string): void {
let current = this.getTrackById(id);
if (current !== undefined) {
this.trackMap.delete(id);
let parent = this.getTrackById(current?.parentId);
parent?.childIds.delete(id);
}
}
getTrackById(id: string): TrackShadow | undefined {
return this.trackMap.get(id);
}
dump(): void {
this.rootTrack?.dump(0);
}
}
```
```typescript
// entry\src\main\ets\viewModel\TrackNode.ets
export class Track {
public areaPercent: number = 0;
public trackId: string = '';
constructor() {
}
id(newId: string): Track {
this.trackId = newId;
return this;
}
}
/**
* Tracing point data.
*/
export class TrackShadow {
public node: FrameNode | null = null;
public id: string = '';
public track: Track | null = null;
public childIds: Set<string> = new Set();
public parentId: string = '';
public visibleRect: common2D.Rect = {
left: 0,
top: 0,
right: 0,
bottom: 0
};
public visibleRatio: number = 0;
// Output the information about the tracing point tree through global dump.
dump(depth: number = 0): void {
hilog.info(0x0000, 'ApplicationTrack', '%{public}s', `Track Dp: ${depth}`);
hilog.info(0x0000, 'ApplicationTrack', '%{public}s', `AreaPer: ${this.track?.areaPercent}`);
hilog.info(0x0000, 'ApplicationTrack', '%{public}s', `VisibleRatio: ${this.visibleRatio}`);
this.childIds.forEach((value: string) => {
TrackManager.get().getTrackById(value)?.dump(depth + 1);
});
}
}
```
最后滚动瀑布流时，不仅可以监听每一个Item的曝光比，也可以向上追溯到根节点，统计根节点中每一个子组件的曝光比例。
页面埋点
页面埋点本示例中分为两类，一类是监听页面切换；另一类是采集页面加载性能。以下从Navigation和Router两种路由方案来讲解。
Navigation路由：
针对Navigation方案，UIObserver提供了navDestinationSwitch事件监听页面的切换，并且支持在回调中获取当前页面的切换信息。首先在EntryAbility中统一注册UIObserver的navDestinationSwitch事件监听。
回调函数中的info包括context、from、to以及operation，主要用于标识页面的来源和去向信息。
| 字段  | 类型  | 含义  |
| --- | --- | --- |
| context  | UIContext  | 页面上下文信息  |
| from  | NavDestinationInfo | NavBar  | 来源页  |
| to  | NavDestinationInfo | NavBar  | 去向页  |
| operation  | NavigationOperation  | 页面操作  |
字段
类型
含义
context
UIContext
页面上下文信息
from
NavDestinationInfo | NavBar
来源页
to
NavDestinationInfo | NavBar
去向页
operation
NavigationOperation
页面操作
此外还可以通过UIObserver的on("navDestinationUpdate")事件监听页面的显示与隐藏，回调传参中包含页面名称、状态信息以及页面的唯一标识ID。
Router路由：
针对Router路由方案，UIObserver提供了on('routerPageUpdate')监听事件，在页面切换过程中触发相应回调。
比如调用Router.pushUrl从A页面跳转到B页面时，该回调会被触发三次：第一次触发的页面名称为PageB，页面状态为ABOUT_TO_APPEAR即将显示；第二次触发的页面名称为PageA，页面状态为ON_PAGE_HIDE页面隐藏；第三次触发的页面名称为PageB，页面状态为ON_PAGE_SHOW页面显示。回调传参同样包含页面上下文、触发事件的页面名称等等。
| 字段名  | 类型  | 含义  |
| --- | --- | --- |
| context  | UIContext  | 页面上下文信息  |
| index  | number  | 触发页面在路由栈中的位置  |
| name  | String  | 触发页面名称  |
| path  | String  | 触发页面路径  |
| state  | RouterPageState  | 页面状态  |
| pageId  | String  | 页面唯一标识  |
字段名
类型
含义
context
UIContext
页面上下文信息
index
number
触发页面在路由栈中的位置
name
String
触发页面名称
path
String
触发页面路径
state
RouterPageState
页面状态
pageId
String
页面唯一标识
页面加载性能：
页面加载性能可以通过计算首帧绘制与绘制结束的时间差来判断。UIObserver同样提供了on("willDraw")事件和on("didLayout")事件，可以在首帧监听中记录初始时间，在完成绘制时记录结束时间。此事件监听需要在页面中注册，Navigation与Router路由相同，本示例以Navigation为例。在aboutToAppear注册on("willDraw")和on("didLayout")事件。
埋点数据上传
总结
本文主要从绑定埋点数据出发，介绍了三种埋点的开发实现：包括点击、曝光以及页面埋点。最后可以调用hiAppEvent的addWatcher添加订阅对象和onTrigger回调，在回调中实现数据报上传的逻辑。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-performance
爬取时间: 2025-05-01 08:43:10
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-performance-guide-reading
爬取时间: 2025-05-01 08:43:23
来源: Huawei Developer
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151125.95471644273942283308415568583930:50001231000000:2800:84117C42AED1DE0F3B12A4BE8E9E04E7C856283968FFDE0520BA2FBF3410ACF5.png)
性能调优贯穿于鸿蒙应用开发的整个生命周期中，开发前有性能最佳指南等赋能套件让你快速上手学习，开发过程中有性能工具开发套件覆盖应用开发各阶段，应用开发完成上架后有专业的性能测试工具检查测试应用性能指标。本文重点介绍应用开发过程中使用性能工具与性能优化文章定位分析性能问题流程，目前DevEco Studio主要集成了四种性能工具，在不同的开发阶段各有侧重，主要分为性能问题检测类工具和性能问题分析类工具。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151125.91209743021869951708481878642067:50001231000000:2800:FD808E9E129ACCA1F9606AF64D3110BED47B4149756C3F7E20182F5592979966.png)
性能工具集定位分析性能问题流程
体检工具和代码检查工具联动：针对共性问题触发代码白盒检查，通过性能规则精确发现开发者开发过程中引入的性能问题，并给出具体的修改建议和范式。
体检工具和调试&调优工具联动：部分不能通过具体规则拦截的性能问题，跳转到调试&调优工具进行分析，分析并行化、组件耗时、页面层次等具体问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151125.93553754705299763691271383914482:50001231000000:2800:85F83A0D7B82991982B99931954CAD6A98C178943F2B3D97B68895FFE91CAAB5.png)
解决应用性能问题的策略
构建以体检工具为主，调优工具为辅的性能工具集，通过应用体检发现问题并给出修复建议。
滑动卡顿丢帧和时延类问题
1.  应用体检工具的Benchmark体检套餐目前集成了通用性能检测项和最佳性能实践检测规则，对于性能规则能覆盖的滑动卡顿丢帧和时延类性能问题，这类问题的定位思路如下：
2.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151125.41747321244131899113237094541115:50001231000000:2800:4B6CFFB39B35FDE2EC3151EC392877B2DD041BC8464359A6D625A2966735DA5C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151125.90096964095698152442780122533874:50001231000000:2800:61E79412F84C8CCBC434B5DC5951A618DB6E25736C331E359A24AF165EC017CB.png)
对于性能规则不能覆盖的滑动卡顿丢帧和时延类性能问题，这类问题的定位思路如下：
内存类问题
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151126.99984995777162563029365016567366:50001231000000:2800:D2C99BB618B4DAC866358FBE73A5E613166BBF56826A0A0D82D0437B26647CE5.png)
对于应用的内存类问题定位思路如下：

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-smooth-application-design
爬取时间: 2025-05-01 08:43:38
来源: Huawei Developer
概述
在应用开发中，开发者应致力于确保用户在使用应用程序时能够体验无缝、自然和舒适的感觉。流畅的体验不仅能够提高用户的满意度，还能够增强用户对应用程序的好感度，并对应用程序的成功与否产生重要影响。
然而，感知流畅性不等同于系统性能。优秀的系统性能是保证用户感知流畅的必要条件，但好的系统性能不一定带来好的感知流畅性。系统性能、资源调度能力、图形渲染技术、硬件启动速度等指标必须通过界面反馈才能影响用户的感知，这意味着应用程序的界面设计、交互体验以及性能优化应当经过精心考量。例如，应用程序启动加载的流畅性，需要通过用户从点击动作到完全看到界面首页内容的体验评价来衡量，这其中包括用户感觉应用程序的首页是不是及时出现，画面的绘制过程是不是自然连贯等，这些因素都会综合影响用户的感知流畅性。
感知流畅性是人对加工信息难易程度的一种主观体验，它指手势触控、视觉感知、心理预期三者合一的综合体验。一方面是交互操作到响应开始的瞬时性，包括点击响应时延、滑动响应时延；另一方面是响应开始到加载完成过程中，动效和加载的同步以确保视觉感官的顺滑，包括最大连续丢帧率、动效时长。整体而言就是手势触控的完成时延和视觉感知的加载效果符合心理预期。一般而言，应用流畅体验的设计可以通过以下步骤实现：
通过这些设计流程，不仅可以提高用户对应用的满意度、促进用户的忠诚度，而且可以降低应用上线后出现的风险、提升用户好感、提高市场竞争力。接下来，本文将首先介绍用户感知的整体指标和测评方法，并分别针对流程中的交互流畅体验设计和视觉流畅体验设计介绍其设计原则和评价指标。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151126.12777771407035424173645442732809:50001231000000:2800:E1B4F6BCB3BD45828DF4379D5B6EFD3E4F00CEE9D2E37B3D2F7845A286D89939.png)
用户体验设计
用户体验设计是一种以用户为中心的设计方法，旨在满足用户需求并创造愉悦、高效、流畅和有意义的产品体验。这需要开发者深入了解用户需求和行为，以便为他们提供最佳的交互和视觉体验。
在交互体验设计方面，开发者需要关注用户界面的直观性、操作的便捷性以及系统的响应速度。而在视觉体验设计方面，开发者需要注重产品的外观设计、动画效果和色彩搭配，以创造出令人愉悦的视觉效果。
在移动终端应用开发中，完成时延是指用户操作移动终端时，从输入触控指令到界面完全刷新结束并达到可以阅读的稳定状态所用时间，包括响应时延、动效时长以及加载完成时延。完成时延在用户体验设计中扮演着关键的角色，直接影响用户对产品的满意度和使用体验。其中，响应时延是评测交互流畅体验的关键指标，将在《交互流畅体验设计》中展开详解。动效时长、加载完成时延是评测视觉流畅体验的关键，动效时长由三方应用根据实际场景设计，并由三方应用进行保障；加载完成时延将在《视觉流畅体验设计》中展开详解。
流畅评测指标
完成时延反映了用户对响应速度的整体感受，主要影响用户对触控交互及时性和愉悦性的体验评价。在一定时延水平以上，完成时延越短越好，当完成时延小于一定水平后，用户的流畅体验不再继续提升。具体的推荐指标如下表所示：
|  一级指标 |  二级指标 |  推荐指标 |
| --- | --- | --- |
|  完成时延  |  控件响应完成时延 |  t完成时延≤600ms |
|  控件出现完成时延 |
|  第三方应用启动完成时延 |  t完成时延≤1100ms |
|  第三方应用页面切换完成时延 |
|  应用内点击操作完成时延应 |  t完成时延≤900ms |
一级指标
二级指标
推荐指标
完成时延
控件响应完成时延
t完成时延≤600ms
控件出现完成时延
第三方应用启动完成时延
t完成时延≤1100ms
第三方应用页面切换完成时延
应用内点击操作完成时延应
t完成时延≤900ms
完成时延指标推荐测试的场景任务如下表所示：
|  一级指标 |  二级指标 |  启动方式 |  示例任务 |
| --- | --- | --- | --- |
|  完成时延 |  应用启动 |  冷启动 |  社交软件启动、支付软件启动等 |
|  页面切换 |  首次启动 |  消息列表进入对话详情 |
|  控件出现 |  首次启动 |  输入法键盘弹出 |
|  控件响应 |  首次启动 |  设置打开蓝牙 |
一级指标
二级指标
启动方式
示例任务
完成时延
应用启动
冷启动
社交软件启动、支付软件启动等
页面切换
首次启动
消息列表进入对话详情
控件出现
首次启动
输入法键盘弹出
控件响应
首次启动
设置打开蓝牙
表格中名词解释如下：
应用冷启动：应用启动时后台没有该应用的进程，系统通过重新创建一个新的进程分配给该应用的方式来启动。
根据完成时延进行评测后进行优化，优化的前后对比图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151126.00074163237854095240757567812504:50001231000000:2800:8291C84462E065E9DD926C9528A9D9A3145A52C14000A23DA0F540B5AFAD3499.gif)
交互流畅体验设计
交互体验设计是产品与用户之间沟通的桥梁，其目的在于创造出令人愉悦、高效的用户体验。流畅的交互体验可以让用户与产品之间的互动更加自然、无缝，从而提升用户的满意度和忠诚度。一个流畅的交互体验不仅能够减少用户的认知负担，提高用户的操作效率，还能增强用户对产品的信任感和使用愉悦感。因此，交互设计是提升产品竞争力和用户体验的重要一环。而要保证交互体验的流畅性，通常包含以下步骤：
设计原则
遵循设计规范和设计原则是交互界面设计的基础，它们能够帮助开发者构建出更加合理、易用和符合用户需求的交互界面。在交互体验设计过程中，需要遵守的设计原则有：
在实际的交互界面设计中，开发者需要综合考虑这些原则，并根据具体的产品特点和用户需求进行灵活运用。
触屏手势
触屏手势是指用户在触摸屏幕上进行的特定手势动作，用于与设备进行交互和操作。通常触屏手势分为基础手势和敲击。
流畅评测指标
响应时延是用户操作移动终端时，从输入触控指令到系统开始将输出信息反馈到触控屏上的时间。响应时延分为点击响应时延和滑动响应时延。
响应时延主要影响用户对触控交互及时性、控制感和愉悦性的体验评价。用户期望系统能够快速响应他们的操作，以获得即时的反馈。因此，响应时延不应高于用户可容忍的最长等待时间。研究表明，用户对于响应时延的感知是有一定的阈限的。在用户的延迟感觉阈限以上，响应时延越短，用户的流畅体验就会越好。然而，一旦响应时延接近或短于感觉阈限后，继续减小响应时延对流畅体验的收益就不再明显。因此，平衡响应时延和用户感知的阈限是非常重要的。
点击响应时延根据场景，具体可以划分为应用启动响应时延、页面切换响应时延和控件出现响应时延。滑动响应时延根据场景，具体可以划分为抛滑响应时延和拖滑响应时延。其感知流畅推荐指标如下表所示：
|  一级指标 |  二级指标 |  推荐指标 |
| --- | --- | --- |
|  点击响应时延 |  应用启动响应时延 |  t响应时间≤100ms |
|  页面切换响应时延 |
|  控件出现响应时延 |
|  滑动响应时延 |  抛滑响应时延 |  t响应时间≤80ms |
|  拖滑响应时延 |  t响应时间≤60ms |
一级指标
二级指标
推荐指标
点击响应时延
应用启动响应时延
t响应时间≤100ms
页面切换响应时延
控件出现响应时延
滑动响应时延
抛滑响应时延
t响应时间≤80ms
拖滑响应时延
t响应时间≤60ms
响应时延推荐测试的场景任务如表所示：
|  一级指标 |  二级指标 |  启动方式 |  示例任务 |
| --- | --- | --- | --- |
|  点击响应时延 |  应用启动响应时延 |  冷启动 |  三方应用启动 |
|  页面切换响应时延 |  首次启动 |  三方应用页面跳转 |
|  控件出现响应时延 |  首次启动 |  短信对话内输入法键盘弹出 |
|  滑动响应时延  |  抛滑 |  首次启动 |  列表上下抛滑 |
|  拖滑 |  首次启动 |  列表上下拖滑 |
一级指标
二级指标
启动方式
示例任务
点击响应时延
应用启动响应时延
冷启动
三方应用启动
页面切换响应时延
首次启动
三方应用页面跳转
控件出现响应时延
首次启动
短信对话内输入法键盘弹出
滑动响应时延
抛滑
首次启动
列表上下抛滑
拖滑
首次启动
列表上下拖滑
视觉流畅体验设计
视觉体验设计是指在产品设计过程中，着重关注用户在视觉上的感知和体验，以达到美观、舒适、流畅的设计目标。生动美观的应用一般包含整体风格的设计、色彩搭配、排版布局等流程，而保证应用流畅性的关键步骤是动效的设计。通过精心设计的动效，用户能够更直观地理解界面的变化和交互操作，从而提升用户对产品的满意度和使用体验。保证视觉体验的流畅性，通常包含以下步骤：
设计原则
动效可以让用户界面更加生动有趣，增加用户对产品的兴趣，从而提升用户体验。详细的设计原则请参考动效指南中《设计原则》章节。
动效
动效分为动画和效果属性，动画负责如何动，效果属性负责控件在哪显示以及显示的内容，效果属性简称属性，属性包括布局属性、背景属性和外观属性等。动画会逐帧驱动属性的变化，以此来产生一帧帧的动画效果。常见的动效有转场动效、属性动效等，发生转场特别是涉及到大面积UI的改变时，应注意前后两页的背景是否一致，避免因为背景一帧切换造成闪烁。如果一定要切换背景颜色，可以使用动画进行过渡。详细内容请参考通用设计指南中的《动效》章节。
若开发场景涉及多个动效时，实现过程中要注意各个动效之间的配合，避免由于动画开始时间、动画曲线等因素存在差异，导致动效异常。
流畅评测指标
设备界面感知流畅客观指标主要包括：
（1）加载完成时延
加载完成时延反应的是新页面出现后，元素控件出现过程的长短，主要影响用户对触控交互及时性、连续性和愉悦性的评价。较长的加载完成时延会降低用户体验，用户可能因为等待时间过长而感到不耐烦，甚至选择放弃使用应用。优化加载完成时延可以提高用户满意度，增加用户留存率。具体加载完成时延的感知流畅性如下表所示：
|  一级指标 |  二级指标 |  推荐指标 |
| --- | --- | --- |
|  加载完成时延 |  启动加载完成时延 |  t动效时长≤1100ms |
一级指标
二级指标
推荐指标
加载完成时延
启动加载完成时延
t动效时长≤1100ms
加载完成时延指标推荐测试的场景任务如下表所示：
|  一级指标 |  二级指标 |  启动方式 |  示例任务 |
| --- | --- | --- | --- |
|  加载完成时延 |  启动加载完成时延 |  冷启动 |  三方支付应用启动 |
一级指标
二级指标
启动方式
示例任务
加载完成时延
启动加载完成时延
冷启动
三方支付应用启动
（2）最大连续丢帧数
最大连续丢帧数反映的是用户感受到画面不连贯，卡顿的程度。最大连续丢帧数越接近于0，用户流畅性体验越好。最大连续丢帧数感知流畅性按下表进行评级：
|  一级指标 |  二级指标 |  推荐指标 |
| --- | --- | --- |
|  最大连续丢帧数 |  页面上下滑动最大连续丢帧数 |  0帧 |
一级指标
二级指标
推荐指标
最大连续丢帧数
页面上下滑动最大连续丢帧数
0帧
最大连续丢帧数推荐测试的场景任务如下表所示：
|  一级指标 |  二级指标 |  启动方式 |  示例任务 |
| --- | --- | --- | --- |
|  最大连续丢帧数 |  上下滑动 |  冷启动、高速滑动 |  三方应用首页滑动 |
一级指标
二级指标
启动方式
示例任务
最大连续丢帧数
上下滑动
冷启动、高速滑动
三方应用首页滑动
根据最大连续丢帧数评测指标进行优化，优化的前后对比图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151126.61133140619098191082999196455069:50001231000000:2800:9D10872BD38094AE09DB495D9A15D5127FB847D40CCB21B8005406E0A7F35B93.gif)
总结
流畅、直观的用户界面可以增强用户的参与感和愉悦感，提升用户对产品或服务的满意度和使用体验。本文重点从交互流畅体验和视觉流畅体验两个流程上描述了如何设计和实现流畅应用：
-  符合用户习惯意味着应用程序的交互设计应当符合用户的操作习惯，让用户能够快速上手并且不感到陌生。风格一致表示应用程序的整体风格和交互方式应当保持一致，不会出现突兀的界面风格转变或操作逻辑变化。而反馈清晰则意味着应用程序在用户进行操作后，能够清晰地给出反馈，告知用户操作的结果或当前状态，从而避免用户的疑惑和困惑。这些基础要求的满足可以让用户在使用应用程序时感到更加自然和舒适。
-  帧率稳定指的是应用程序在运行过程中能够保持稳定的帧率输出，避免出现卡顿和画面闪烁的情况，从而让用户感受到流畅的界面切换和动画效果。响应及时表示应用程序对用户的操作能够快速做出响应，让用户感到交互的即时性和高效性。而加载及时指应用能够快速地加载并显示所需的内容和功能，不会出现长时间的等待或卡顿现象，让用户感到流畅和自然，提升用户的参与感和愉悦感。这些基础要求的满足可以让用户感受到应用程序的高效性和流畅性。
这两部分基础要求共同确保了应用程序的感知流畅性，并通过完成时延这个指标直观展示了用户对产品的满意度和使用体验。
在应用体验设计的过程中，为了提升用户的感知流畅度，开发者需要在设计和优化移动应用程序时考虑完成时延的影响，通过优化代码、减少不必要的后台任务、使用高效的算法和数据结构等手段降低时延，提升用户的感知流畅度。此外，合理的系统架构和服务器性能也对减小响应时延起着关键作用。除了技术方面的优化，开发者还需要关注响应时延对用户体验的影响，可以通过设计直观的交互界面、合理的动画效果以及优化用户交互流程来降低用户感知的时延。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-performance-detection
爬取时间: 2025-05-01 08:43:51
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-optimization-tool-set
爬取时间: 2025-05-01 08:44:04
来源: Huawei Developer
简介
调优是指对应用程序进行优化和改进，以提高其运行速度、资源利用效率和响应时间的过程。通过对应用程序进行细致的调优，可以使应用程序更高效、更稳定。在当今数字化时代，随着应用程序变得越来越复杂和庞大，调优变得尤为重要。一个经过有效调优的应用程序不仅可以更高效地运行，还能提高应用的稳定性，提升程序的效率，减少资源的浪费，从而为用户带来更好的体验。因此，了解调优的方法和常用工具对于开发人员至关重要。
调优的过程通常包括现场复现、问题分析、确定解决方案和性能测试这几个关键步骤。现场复现是指在具体环境中复现问题，以便更好地分析和解决。问题分析阶段则是深入分析应用程序的性能瓶颈和问题根源，为后续优化提供指导。确定解决方案是根据问题分析的结果，制定具体的优化方案和措施。最后，性能测试是验证调优效果的关键步骤，通过对优化后的应用程序进行性能测试，评估改进效果。
为了有效进行调优工作，需要借助一些常用的工具。例如，性能分析工具DevEco Profiler可以监测应用的性能指标、录制Trace记录，开发者可以通过分析Trace数据，发现代码中的性能瓶颈，进而优化性能。
本文将介绍调优的方法、常用的工具，开发者可以更好地分析和解决应用程序中的性能问题，提升用户体验，实现应用程序的高效稳定运行。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151126.57050453818577477568949543950851:50001231000000:2800:D2B67CCA621A379C000DBD5AE2CECA2B8F30E66C99A95E1B4331BFBF5257F6E4.png)
性能调优贯穿于鸿蒙应用开发的整个生命周期中，开发前有性能最佳指南等赋能套件让你快速上手学习，开发过程中有性能工具开发套件覆盖应用开发各阶段，应用开发完成上架后有专业的性能测试工具检查测试应用性能指标。目前DevEco Studio主要集成了四种性能工具，在不同的开发阶段各有侧重，主要分为性能问题检测类工具和性能问题分析类工具。本文重点介绍使用性能问题检测类工具应用来检测应用性能问题。
静态扫描工具检测应用性能问题
Code Linter
介绍
静态检测工具，白盒检查代码性能问题。可配置开发者关注的性能规则，扫描结果支持跳转到代码，性能规则详情或者官网的最佳性能实践指导。
使用方法
在已打开的代码编辑器窗口单击右键点击Code Linter，或在工程管理窗口中鼠标选中单个或多个工程文件/目录，右键选择Code Linter > Full Linter执行代码全量检查。如图所示输入@performance，过滤性能检查结果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151126.18716262440781993843228422846494:50001231000000:2800:FC3B2476A79D857A9FA51248EE40C163DF338D94C1C9EB2FBAA0A4B6CB83D885.png)
详细使用指导见：
代码Code Linter检查
静态性能规则全集见：
性能规则@performance
注意点
动态运行工具检测应用性能问题
AppAnalyzer
介绍
应用体检工具Benchmark体检套餐集成动态性能规则检测项，助力检测应用性能瓶颈，快速修复性能问题。
使用方法
1.
2.
3.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151126.34480129441463118446424328181315:50001231000000:2800:653E38B94A654E1877059A28FB175E692D64457D4D0221C457F528DB28C38C3E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151126.93371263459728407313057342955814:50001231000000:2800:41993EDF65F96888948140BA46D5217A4109C42EEAEBEC4D5CAD1ABE08DAB8D9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151126.47187869973675507671780744721943:50001231000000:2800:FE21E02344F3B67A0209024804AA0CEF25A38CE81EC59326288D5EDD31B7AE8C.png)
详细使用指导见：
AppAnalyzer
应用体检工具集成性能规则见：
应用/服务体检规则
注意点
只有已经完成签名编译打包的模块才能被选中。
附录：工具检查规则项汇总表
静态检测工具
|  规则ID（@规则集/规则） |  针对的性能场景 |  级别 |  规则描述与参考优化方案链接 |
| --- | --- | --- | --- |
|  @performance/sparse-array-check |  通用性能场景-ArkTs编程规范 |  suggestion |  建议避免使用稀疏数组。 |
|  @performance/number-init-check |  通用性能场景-ArkTs编程规范 |  suggestion |  该规则将检查number是否正确使用。 |
|  @performance/typed-array-check |  通用性能场景-ArkTs编程规范 |  suggestion |  数值数组推荐使用TypedArray。 |
|  @performance/hp-arkui-image-async-load |  丢帧-通用丢帧 |  suggestion |  建议大图片使用异步加载。 |
|  @performance/hp-arkui-load-on-demand |  丢帧-滑动丢帧 |  warn |  建议使用按需加载。 |
|  @performance/hp-arkui-remove-container-without-property |  丢帧-通用丢帧 |  suggestion |  建议尽量减少视图嵌套层次。 |
|  @performance/hp-performance-no-closures |  通用性能场景-ArkTs编程规范 |  suggestion |  建议函数内部变量尽量使用参数传递。 |
|  @performance/hp-arkui-avoid-empty-callback |  通用性能场景-ArkUI编程规范 |  suggestion |  避免设置空的系统回调监听。 |
|  @performance/hp-arkui-no-state-var-access-in-loop |  丢帧-通用丢帧 |  warn |  避免在for、while等循环逻辑中频繁读取状态变量。 |
|  @performance/hp-arkui-use-local-var-to-replace-state-var |  丢帧-通用丢帧 |  warn |  建议使用临时变量替换状态变量。 |
|  @performance/hp-arkui-use-row-column-to-replace-flex |  丢帧-通用丢帧 |  suggestion |  建议使用Column/Row替代Flex。 |
|  @performance/hp-arkui-combine-same-arg-animateto |  丢帧-动效丢帧 |  warn |  建议动画参数相同时使用同一个animateTo。 |
|  @performance/hp-arkui-no-func-as-arg-for-reusable-component |  丢帧-滑动丢帧 |  warn |  避免使用函数作为复用的自定义组件创建时的入参。 |
|  @performance/hp-arkui-set-cache-count-for-lazyforeach-grid |  丢帧-滑动丢帧 |  suggestion |  建议在Grid下使用LazyForEach时设置合理的cacheCount。 |
|  @performance/hp-arkui-use-object-link-to-replace-prop |  丢帧-通用丢帧 |  warn |  建议使用@ObjectLink代替@Prop减少不必要的深拷贝。 |
|  @performance/hp-arkui-use-reusable-component |  丢帧-滑动丢帧 |  warn |  建议复杂组件的定义，尽量使用组件复用。 |
|  @performance/hp-arkui-use-scale-to-replace-attr-animateto |  丢帧-动效丢帧 |  warn |  建议组件布局改动时使用图形变换属性动画。 |
|  @performance/hp-arkui-use-word-break-to-replace-zero-width-space |  通用性能场景-ArkUI编程规范 |  suggestion |  建议使用word-break替换零宽空格(\u200b)。 |
|  @performance/hp-arkui-remove-redundant-nest-container |  丢帧-通用丢帧 |  suggestion |  避免冗余的嵌套。 |
|  @performance/high-frequency-log-check |  通用性能场景-高耗时函数处理 |  warn |  不建议在高频函数中使用Hilog。 |
|  @performance/hp-arkui-use-grid-layout-options |  丢帧-通用丢帧 |  warn |  建议在指定位置时使用GridLayoutOptions提升Grid性能。 |
|  @performance/hp-arkui-avoid-update-auto-state-var-in-aboutToReuse |  丢帧-通用丢帧 |  suggestion |  避免在aboutToReuse中对自动更新值的状态变量进行更新。 |
|  @performance/hp-arkui-replace-nested-reusable-component-by-builder |  丢帧-通用丢帧 |  warn |  建议使用@Builder替代嵌套的自定义组件。 |
|  @performance/hp-arkui-suggest-reuseid-for-if-else-reusable-component |  丢帧-滑动丢帧 |  warn |  建议使用reuseId标记不同结构的组件构成。 |
|  @performance/hp-arkui-use-onAnimationStart-for-swiper-preload |  丢帧-滑动丢帧 |  warn |  建议Swiper预加载机制搭配 OnAnimationStart 接口回调使用。 |
|  @performance/hp-arkui-no-stringify-in-lazyforeach-key-generator |  丢帧-滑动丢帧 |  warn |  在使用LazyForEach进行组件复用的key生成器函数里，不要使用stringify。 |
|  @performance/start-window-icon-check |  响应时延-冷启动响应时延 |  suggestion |  启动页图标分辨率建议不超过256 * 256。 |
|  @performance/waterflow-data-preload-check |  丢帧-滑动丢帧 |  suggestion |  建议对waterflow子组件进行数据预加载。 |
|  @performance/hp-arkui-use-attributeUpdater-control-refresh-scope |  丢帧-通用丢帧 |  suggestion |  建议使用attributeUpdater精准控制组件属性的刷新。 |
|  @performance/hp-arkui-use-id-in-get-resource-sync-api |  通用性能场景-高耗时函数处理 |  suggestion |  建议在使用API getColorSync和getStringSync时建议使用带id版本。 |
|  @performance/hp-arkui-use-transition-to-replace-animateto |  丢帧-动效丢帧 |  warn |  建议组件转场动画使用transition。 |
|  @performance/hp-arkui-remove-redundant-state-var |  丢帧-通用丢帧 |  suggestion |  建议移除不关联UI组件的状态变量设置。 |
|  @performance/hp-arkui-use-taskpool-for-web-request |  完成时延-应用内点击完成时延 |  warn |  建议网络资源的请求和返回使用taskpool线程池异步处理。 |
|  @performance/hp-arkui-remove-unchanged-state-var |  丢帧-通用丢帧 |  suggestion |  建议移除未改变的状态变量设置。 |
|  @performance/hp-arkts-no-use-any-export-current |  完成时延-冷启动完成时延 |  warn |  避免使用export * 导出当前module中定义的类型和数据。 |
|  @performance/hp-arkts-no-use-any-export-other |  完成时延-冷启动完成时延 |  warn |  避免使用export * 导出其他module中定义的类型和数据。 |
|  @performance/hp-arkui-suggest-cache-avplayer |  音视频播放-启播速度 |  warn |  建议缓存AVPlayer实例減少起播时延。 |
|  @performance/hp-arkui-suggest-use-effectkit-blur |  丢帧-通用丢帧 |  suggestion |  建议使用effectKit.createEffect实现模糊效果。 |
|  @performance/multiple-associations-state-var-check |  丢帧-通用丢帧 |  suggestion |  多个组件关联同一数据时，建议在组件中使用@Watch装饰器添加更新条件，避免不必要的组件更新。 |
|  @performance/foreach-args-check |  丢帧-滑动丢帧 |  warn |  建议在ForEach参数中设置keyGenerator。 |
|  @performance/constant-property-referencing-check-in-loops |  通用性能场景-ArkTs编程规范 |  suggestion |  在循环如需频繁访问某个常量，且该属性引用常量在循环中不会改变，建议提取到循环外部，减少属性访问的次数。 |
|  @performance/hp-arkui-reduce-pangesture-distance |  响应时延-应用内点击响应时延 |  suggestion |  建议设置合理的拖动距离。 |
规则ID（@规则集/规则）
针对的性能场景
级别
规则描述与参考优化方案链接
@performance/sparse-array-check
通用性能场景-ArkTs编程规范
suggestion
建议避免使用稀疏数组。
@performance/number-init-check
通用性能场景-ArkTs编程规范
suggestion
该规则将检查number是否正确使用。
@performance/typed-array-check
通用性能场景-ArkTs编程规范
suggestion
数值数组推荐使用TypedArray。
@performance/hp-arkui-image-async-load
丢帧-通用丢帧
suggestion
建议大图片使用异步加载。
@performance/hp-arkui-load-on-demand
丢帧-滑动丢帧
warn
建议使用按需加载。
@performance/hp-arkui-remove-container-without-property
丢帧-通用丢帧
suggestion
建议尽量减少视图嵌套层次。
@performance/hp-performance-no-closures
通用性能场景-ArkTs编程规范
suggestion
建议函数内部变量尽量使用参数传递。
@performance/hp-arkui-avoid-empty-callback
通用性能场景-ArkUI编程规范
suggestion
避免设置空的系统回调监听。
@performance/hp-arkui-no-state-var-access-in-loop
丢帧-通用丢帧
warn
避免在for、while等循环逻辑中频繁读取状态变量。
@performance/hp-arkui-use-local-var-to-replace-state-var
丢帧-通用丢帧
warn
建议使用临时变量替换状态变量。
@performance/hp-arkui-use-row-column-to-replace-flex
丢帧-通用丢帧
suggestion
建议使用Column/Row替代Flex。
@performance/hp-arkui-combine-same-arg-animateto
丢帧-动效丢帧
warn
建议动画参数相同时使用同一个animateTo。
@performance/hp-arkui-no-func-as-arg-for-reusable-component
丢帧-滑动丢帧
warn
避免使用函数作为复用的自定义组件创建时的入参。
@performance/hp-arkui-set-cache-count-for-lazyforeach-grid
丢帧-滑动丢帧
suggestion
建议在Grid下使用LazyForEach时设置合理的cacheCount。
@performance/hp-arkui-use-object-link-to-replace-prop
丢帧-通用丢帧
warn
建议使用@ObjectLink代替@Prop减少不必要的深拷贝。
@performance/hp-arkui-use-reusable-component
丢帧-滑动丢帧
warn
建议复杂组件的定义，尽量使用组件复用。
@performance/hp-arkui-use-scale-to-replace-attr-animateto
丢帧-动效丢帧
warn
建议组件布局改动时使用图形变换属性动画。
@performance/hp-arkui-use-word-break-to-replace-zero-width-space
通用性能场景-ArkUI编程规范
suggestion
建议使用word-break替换零宽空格(\u200b)。
@performance/hp-arkui-remove-redundant-nest-container
丢帧-通用丢帧
suggestion
避免冗余的嵌套。
@performance/high-frequency-log-check
通用性能场景-高耗时函数处理
warn
不建议在高频函数中使用Hilog。
@performance/hp-arkui-use-grid-layout-options
丢帧-通用丢帧
warn
建议在指定位置时使用GridLayoutOptions提升Grid性能。
@performance/hp-arkui-avoid-update-auto-state-var-in-aboutToReuse
丢帧-通用丢帧
suggestion
避免在aboutToReuse中对自动更新值的状态变量进行更新。
@performance/hp-arkui-replace-nested-reusable-component-by-builder
丢帧-通用丢帧
warn
建议使用@Builder替代嵌套的自定义组件。
@performance/hp-arkui-suggest-reuseid-for-if-else-reusable-component
丢帧-滑动丢帧
warn
建议使用reuseId标记不同结构的组件构成。
@performance/hp-arkui-use-onAnimationStart-for-swiper-preload
丢帧-滑动丢帧
warn
建议Swiper预加载机制搭配 OnAnimationStart 接口回调使用。
@performance/hp-arkui-no-stringify-in-lazyforeach-key-generator
丢帧-滑动丢帧
warn
在使用LazyForEach进行组件复用的key生成器函数里，不要使用stringify。
@performance/start-window-icon-check
响应时延-冷启动响应时延
suggestion
启动页图标分辨率建议不超过256 * 256。
@performance/waterflow-data-preload-check
丢帧-滑动丢帧
suggestion
建议对waterflow子组件进行数据预加载。
@performance/hp-arkui-use-attributeUpdater-control-refresh-scope
丢帧-通用丢帧
suggestion
建议使用attributeUpdater精准控制组件属性的刷新。
@performance/hp-arkui-use-id-in-get-resource-sync-api
通用性能场景-高耗时函数处理
suggestion
建议在使用API getColorSync和getStringSync时建议使用带id版本。
@performance/hp-arkui-use-transition-to-replace-animateto
丢帧-动效丢帧
warn
建议组件转场动画使用transition。
@performance/hp-arkui-remove-redundant-state-var
丢帧-通用丢帧
suggestion
建议移除不关联UI组件的状态变量设置。
@performance/hp-arkui-use-taskpool-for-web-request
完成时延-应用内点击完成时延
warn
建议网络资源的请求和返回使用taskpool线程池异步处理。
@performance/hp-arkui-remove-unchanged-state-var
丢帧-通用丢帧
suggestion
建议移除未改变的状态变量设置。
@performance/hp-arkts-no-use-any-export-current
完成时延-冷启动完成时延
warn
避免使用export * 导出当前module中定义的类型和数据。
@performance/hp-arkts-no-use-any-export-other
完成时延-冷启动完成时延
warn
避免使用export * 导出其他module中定义的类型和数据。
@performance/hp-arkui-suggest-cache-avplayer
音视频播放-启播速度
warn
建议缓存AVPlayer实例減少起播时延。
@performance/hp-arkui-suggest-use-effectkit-blur
丢帧-通用丢帧
suggestion
建议使用effectKit.createEffect实现模糊效果。
@performance/multiple-associations-state-var-check
丢帧-通用丢帧
suggestion
多个组件关联同一数据时，建议在组件中使用@Watch装饰器添加更新条件，避免不必要的组件更新。
@performance/foreach-args-check
丢帧-滑动丢帧
warn
建议在ForEach参数中设置keyGenerator。
@performance/constant-property-referencing-check-in-loops
通用性能场景-ArkTs编程规范
suggestion
在循环如需频繁访问某个常量，且该属性引用常量在循环中不会改变，建议提取到循环外部，减少属性访问的次数。
@performance/hp-arkui-reduce-pangesture-distance
响应时延-应用内点击响应时延
suggestion
建议设置合理的拖动距离。
动态运行工具规则请参阅应用/服务体检规则

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-optimization-tool-practice
爬取时间: 2025-05-01 08:44:17
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-optimization-overview
爬取时间: 2025-05-01 08:44:30
来源: Huawei Developer
概述
调优是指对应用程序进行优化和改进，以提高其运行速度、资源利用效率和响应时间的过程。通过对应用程序进行细致的调优，可以使应用程序更高效、更稳定。在当今数字化时代，随着应用程序变得越来越复杂和庞大，调优变得尤为重要。一个经过有效调优的应用程序不仅可以更高效地运行，还能提高应用的稳定性，提升程序的效率，减少资源的浪费，从而为用户带来更好的体验。因此，了解调优的方法和常用工具对于开发人员至关重要。
调优的过程通常包括现场复现、问题分析、确定解决方案和性能测试这几个关键步骤。现场复现是指在具体环境中复现问题，以便更好地分析和解决。问题分析阶段则是深入分析应用程序的性能瓶颈和问题根源，为后续优化提供指导。确定解决方案是根据问题分析的结果，制定具体的优化方案和措施。最后，性能测试是验证调优效果的关键步骤，通过对优化后的应用程序进行性能测试，评估改进效果。
为了有效进行调优工作，需要借助一些常用的工具。例如，性能分析工具DevEco Profiler可以监测应用的性能指标、录制Trace记录，开发者可以通过分析Trace数据，发现代码中的性能瓶颈，进而优化性能。另外，HiDumper命令行工具可以获取UI界面组件树的信息、内存、CPU等使用情况，从而帮助开发者定位问题并进行优化。
本文将介绍调优的方法、常用的工具，开发者可以更好地分析和解决应用程序中的性能问题，提升用户体验，实现应用程序的高效稳定运行。
在日常开发中，需要关注的指标有完成时延、点击响应时延、滑动响应时延等，具体需要关注的指标可以参考《性能体验设计》。
调优分析步骤
调优分析方法在应用程序优化过程中起着至关重要的作用。这些方法帮助开发人员识别问题、定位瓶颈，并最终改进系统性能。具体调优分析方法如下：
综上所述，调优分析是应用程序优化过程中不可或缺的步骤。通过现场复现、问题分析、确定解决方案和性能测试这些步骤，开发人员可以识别和解决应用性能问题，从而提升应用程序的效率和稳定性。
常见工具
DevEco Profiler
性能调优工具可以帮助开发者找出应用中的性能问题，DevEco Studio提供许多常用的性能调优工具，具体如下所示：
其他常见的性能调优工具，包括HiDumper、SmartPerf。
-  使用方法 详细使用指导见： 性能分析 注意点
ArkUI Inspector
介绍
开发者可以使用Inspector双向预览，在DevEco Studio上查看应用在真机上的组件布局，并通过查看多次操作后的界面状态，快速分析定位状态变量、组件嵌套层次、UI界面布局存在的问题等。
使用方法
详细使用指导见：
布局分析
Trace打点信息说明
HarmonyOS的DFX子系统提供了为应用框架以及系统底座核心模块的性能打点能力，每一处打点即是一个Trace，其上附带了记录执行时间、运行时格式化数据、进程或线程信息等。开发者可以使用DevEco Studio的Frame对Trace进行解析，并在其绘制的泳道图中识别关键渲染流程。
线程状态转化流程
在HarmonyOS中，Trace记录的线程状态主要分为运行中（Running）、可运行（Runnable）、休眠中（Sleep）、IO阻塞下不可中断的睡眠态（Uninterruptible Sleep - IO）、不可中断的睡眠态（Uninterruptible Sleep - non IO）。其状态转化图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151127.15973588215900625657077163397952:50001231000000:2800:4574028C8F6EAC7F5CBEA2764B5D3B44AF2093E1902C225FDCCCDB87ACA45492.png)
通过Trace点位信息识别线程状态
Trace 会用不同的颜色来标识不同的线程状态，在每个方法上面都会有对应的线程状态来标识目前线程所处的状态，通过查看线程状态可以分析出当前的性能瓶颈。
（1）运行中（Running）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151127.86163859629315527597989351502300:50001231000000:2800:705FDF00AA26BA49464AD53CA797BEF39343FBCE73CC512F1D9AECF8CDF40B1A.png)
运行中（Running）表示只有在该状态的线程才可能在CPU上运行。而同一时刻可能有多个线程处于可执行状态，这些线程的task_struct结构被放入对应CPU的可执行队列中（一个线程最多只能出现在一个CPU的可执行队列中）。调度器的任务就是从各个CPU的可执行队列中分别选择一个线程在该CPU上运行。
（2）可运行（Runnable）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151127.07818497914254875479337382490711:50001231000000:2800:2D303B82B0451625105C81FFE34C6A838719C29CF9D18DF761273A5BA8AD8D12.png)
可运行（Runnable）表示线程可以运行但当前没有安排，在等待CPU调度。Runnable状态的线程状态持续时间越长，则表示CPU的调度越忙，没有及时处理到这个任务。
（3）休眠中（Sleep）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151127.03246590645500996792833956916515:50001231000000:2800:9A74B97094F6E6310495B43499FBFA87A7F295A02C2788FF9FD5D1FEC3863BDB.png)
休眠中（Sleep）表示线程没有工作要做，可能是因为线程在互斥锁上被阻塞，也有可能是在等某些操作返回，一般是在等事件驱动。
（4）IO阻塞下不可中断的睡眠态（Uninterruptible Sleep - IO）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151127.28385839765485423817327863875994:50001231000000:2800:4ABF9015E4E4E3E6558D155564734B461ABA91F7DB726A037E6FD6086C48FD50.png)
IO阻塞下不可中断的睡眠态（Uninterruptible Sleep - IO）表示线程在I/O上被阻塞或等待磁盘操作完成。当系统处于低内存状态时，申请内存的时候可能会触发page fault，从而导致有大量的不可中断的睡眠态出现。在Linux系统的page cache链表中，有时会出现一些还没准备好的page(即还没把磁盘中的内容完全地读出来) ，而正好此时用户在访问这个page时就会出现page fault。
（5）不可中断的睡眠态（Uninterruptible Sleep - non IO）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151127.35717276715908871672511228540468:50001231000000:2800:CD95EA951E65071E99906EF581EC6BC1708167D78E409ECCFF282D61FFFF3427.png)
不可中断的睡眠态（Uninterruptible Sleep - non IO）表示线程在另一个内核操作（通常是内存管理）上被阻塞。一般是陷入了内核态，有些情况下是正常的，有些情况下是不正常的，需要按照具体的情况去分析。
渲染流程
在HarmonyOS中，图形系统采用了统一渲染的模式，遵循着一个典型的流水线模式，以90Hz刷新率为例，每个Vsync周期是11.1ms，整个过程如下图所示。如果是60Hz，每个Vsync的周期是16.7ms；如果是120Hz，则每个Vsync的周期是8.3ms。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151127.19261053697771920610828873771152:50001231000000:2800:A956FED0AF7B745C42492CABA04A2985631037B6D02FEBC3948EDE67451ABB02.png)
在整个渲染流程中，首先是由应用侧响应消费者的屏幕点击等输入事件，由应用侧处理完成后再提交给Render Service，由Render Service协调GPU等资源处理后，再将最终的图像统一送到屏幕上进行显示。
其中应用侧的渲染流程如下图所示，了解ArkUI的渲染流程有助于定位应用侧的卡顿问题出现在哪个环节：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151127.78347830091399154910646806466600:50001231000000:2800:655E9F66ACFD82072AE454C2FAB49B5B874DCAC0FE16CECDCC493A47F04CAA55.png)
在整个处理流程中，应用侧和Render Service侧都有可能出现卡顿导致最终用户观测到丢帧的可能，这两种情况分别为AppDeadlineMissed和RenderDeadlineMissed。一般而言，前者可能是应用逻辑处理代码不够高效导致的，后者可能是界面结构过于复杂或者GPU负载过大等原因导致的。这两个故障模型通过Frame模板都可以直观地看到。相应的故障模型如下面两幅图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151127.11535588319838766438825797942295:50001231000000:2800:E97002DCAC733A73A048C54983AA9E9B0A5B8D6E1CDCC7CD45951A2C29F8207E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151127.56685991893381801862940294595181:50001231000000:2800:E41FD57854D1CBB5FF40EFF075E645F9022CEF00AD314DD9354E133170CEBC73.png)
通过Trace识别关键渲染流程
一帧的渲染流程中的UI后端引擎的常用Trace的含义如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151127.17549531552487629512640112543746:50001231000000:2800:04A18BCB4C293F3352B6B88026C8BF69AA663A0784AD838F13D68A907B4559F9.png)
各部分介绍见下表：
| 序号  | Trace  | 参数说明  | 描述  |
| --- | --- | --- | --- |
| 1  | OnVsyncEvent now:%" PRIu64 "  | 当前时间戳--纳秒级  | 收到Vsync信号，渲染流程开始  |
| 2  | FlushVsync  |    | 刷新视图同步事件，包括记录帧信息、刷新任务、绘制渲染上下文、处理用户输入  |
| 3  | UITaskScheduler::FlushTask  |    | 刷新UI界面，包括布局、渲染和动画等  |
| 4  | FlushMessages  |    | 发送消息通知图形侧进行渲染  |
| 5  | FlushLayoutTask  |    | 执行布局任务  |
| 6  | FlushRenderTask %zu  | 当前页面上的需要渲染的节点的数量  | 总渲染任务执行  |
| 7  | Layout  |    | 节点布局  |
| 8  | FrameNode::RenderTask  |    | 单个渲染任务执行  |
| 9  | ListLayoutAlgorithm::MeasureListItem:%d  | 当前列表项索引  | 计算列表项的布局尺寸  |
序号
Trace
参数说明
描述
1
OnVsyncEvent now:%" PRIu64 "
当前时间戳--纳秒级
收到Vsync信号，渲染流程开始
2
FlushVsync
刷新视图同步事件，包括记录帧信息、刷新任务、绘制渲染上下文、处理用户输入
3
UITaskScheduler::FlushTask
刷新UI界面，包括布局、渲染和动画等
4
FlushMessages
发送消息通知图形侧进行渲染
5
FlushLayoutTask
执行布局任务
6
FlushRenderTask %zu
当前页面上的需要渲染的节点的数量
总渲染任务执行
7
Layout
节点布局
8
FrameNode::RenderTask
单个渲染任务执行
9
ListLayoutAlgorithm::MeasureListItem:%d
当前列表项索引
计算列表项的布局尺寸
图形图像子系统中的Render Service，是负责界面内容绘制的部件，处理由各个应用提交的统一渲染任务，将不同应用渲染的图层进行合并、送显。在收到每个Vsync周期信号时，首先处理应用提交的指令，包括应用渲染树节点的新增、删除、修改，然后进行动画计算和遮挡计算，以上是为了对统一渲染树进行更新。接下来开始对渲染树执行绘制，首先预处理每个节点，计算绝对位置和脏区信息，然后针对脏区进行绘制，优先使用硬件合成器进行绘制，当遇到无法合成绘制的，交由GPU执行重绘，绘制的所有结果都将存入屏幕缓冲区，最后将绘制结果提交送显、上屏展示。
Vsync信号刷新时的Trace泳道图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151127.30607879353054927615901184401229:50001231000000:2800:7E3F06050DC1BE59DC022BD6699468BB87BEB03FE5BEF42B11475E4CE13AD593.png)
各部分介绍如下表：
| 序号  | Trace  | 描述  |
| --- | --- | --- |
| 1  | RSMainThread::DoComposition  | 合成渲染树上各节点图层  |
| 2  | RSMainThread::ProcessCommand  | 处理client端指令  |
| 3  | Animate  | 动画处理  |
| 4  | ProcessDisplayRenderNode[x]  | 单个显示器画面的绘制流程  |
| 5  | Repaint  | 硬件合成器合成绘制  |
| 6  | RenderFrame  | GPU执行绘制  |
| 7  | SwapBuffers  | 刷新屏幕缓冲区  |
| 8  | Commit  | 绘制结果提交上屏  |
序号
Trace
描述
1
RSMainThread::DoComposition
合成渲染树上各节点图层
2
RSMainThread::ProcessCommand
处理client端指令
3
Animate
动画处理
4
ProcessDisplayRenderNode[x]
单个显示器画面的绘制流程
5
Repaint
硬件合成器合成绘制
6
RenderFrame
GPU执行绘制
7
SwapBuffers
刷新屏幕缓冲区
8
Commit
绘制结果提交上屏
通过Trace识别懒加载渲染流程
懒加载使用LazyForEach实现，LazyForEach从提供的数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。当LazyForEach在滚动容器中使用时，框架会根据滚动容器可视区域按需创建组件。当组件滑出可视区域外时，框架会进行组件销毁以降低内存占用。
下图是抓取的懒加载过程中一帧的Trace泳道图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151128.73255377204996724170167945267351:50001231000000:2800:0586593F82A86215B24B67DC7C1C45CB853FF59D7988FA573E5ACB957B670986.png)
| 序号  | Trace  | 参数说明  | 描述  |
| --- | --- | --- | --- |
| 1  | OnIdle, targettime:%" PRId64 "  | 时间戳，在这个时间之前完成该任务  | idle事件循环中检查是否有新的事件需要处理，如果有，则将任务调度器加入UI线程中并执行预测任务  |
| 2  | Builder:BuildLazyItem [%d]  | 需创建的项目索引  | 在需要时创建项，并进行缓存  |
| 3  | CustomNode:BuildRecycle %s  | JS视图名称  | 触发复用渲染  |
| 4  | ExecuteJS  |    | 执行JS代码  |
| 5  | List predict  |    | 添加预测布局任务  |
| 6  | Layout  |    | 当前帧节点布局  |
序号
Trace
参数说明
描述
1
OnIdle, targettime:%" PRId64 "
时间戳，在这个时间之前完成该任务
idle事件循环中检查是否有新的事件需要处理，如果有，则将任务调度器加入UI线程中并执行预测任务
2
Builder:BuildLazyItem [%d]
需创建的项目索引
在需要时创建项，并进行缓存
3
CustomNode:BuildRecycle %s
JS视图名称
触发复用渲染
4
ExecuteJS
执行JS代码
5
List predict
添加预测布局任务
6
Layout
当前帧节点布局
添加自定义Trace信息
开发者可以根据业务需求，使用HiTraceMeter进行自定义Trace打点跟踪，具体使用细节可参考《使用HiTraceMeter跟踪性能（ArkTS/JS）》和《使用HiTraceMeter跟踪性能（C/C++）》。
添加自定义Trace后，可在SmartPerf-Host调试工具上查看，自定义Trace将以独立泳道的形式呈现在对应打点的进程下。 下图两条泳道使用了startTrace和finishTrace方法，表示程序运行过程中，指定标签从调用startTrace到调用finishTrace的耗时统计。图中记录了CUSTOM_TRACE_TAG_1和CUSTOM_TRACE_TAG_2两个标签，先后呈现了2个标签的耗时统计。
自定义Trace示例：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151128.68563451671792296445749344926715:50001231000000:2800:AC82E5FA1167BFFDF25B2F0337C23583938D854B4E50C2D919F82CDD1F0DA3B8.png)
自定义状态值示例：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151128.19188298601306186517178706846857:50001231000000:2800:4CC4757AE12FBF374617C2F2042FC52662F95B3C51B5D54DBD8F62B58F75E54A.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-click-to-click-response-optimization
爬取时间: 2025-05-01 08:44:43
来源: Huawei Developer
响应优化概述
响应（Response）是指用户通过直接操作或间接触发请求后，应用程序执行运算处理请求，并更新界面状态的交互机制。
《应用性能体验建议》指出，应用或元服务内点击操作响应时延应<=100ms。为了保障应用操作响应及时，看护用户极致流畅体验，开发者需要分析从手势抬手到渲染上屏这段时间应用做了哪些耗时的操作，进而针对性地优化相关逻辑。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151128.15553652761226344157712665481798:50001231000000:2800:707FA41BA35C7A5F47887DEE7A8D93770F3C27C82AB7B05E8EF66CBEF9B190C1.png)
点击响应优化就是指通过分析响应阶段、优化应用性能、加快点击后页面的响应速度，使用户可以得到流畅的操作体验。开发者优化自己应用的点击响应速度，既满足产品功能的高性能要求，增强产品同质化竞争中的优势，又能不断提升用户满意度。
分析工具
影响点击响应性能的因素有很多，借助DevEco Studio集成的相关分析工具，可以收集大量的系统数据，自动执行重复任务，建立统一的优化标准和流程，减少个人差异和误操作的可能性，帮助开发人员更好地了解性能瓶颈和优化潜力。在分析优化的过程中，可能用到以下工具中的一个或多个。
AppAnalyzer
AppAnalyzer是DevEco Studio中提供的检测评分工具，用于测试并评价HarmonyOS应用或元服务的质量，能快速提供评估结果和改进建议。当前AppAnalyzer支持的测试类型包括兼容性、性能、UX测试和最佳实践等。其中点击操作响应是性能类型中的一项检测规则，开发者可以使用该工具检测响应性能。
使用AppAnalyzer检测点击响应
1.
2.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151128.40936517182599581703331368687907:50001231000000:2800:52CF8F90631F4DA1D9FBB7F71FBFCF83842E7EB0A93318129DDF87E2431A19EB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151128.03171968427981156345365547972433:50001231000000:2800:AF2ED2344D1D93F9690E856F1B4E0C8E0A150EB9926F006710912D8BAE61EC1C.png)
具体使用可参考《应用与服务体检》。
Profiler Frame
DevEco Profiler是DevEco Studio提供的场景化调优工具，其中Frame可以帮助开发者深度分析性能问题，通过录制应用运行过程中的关键数据，从而识别卡顿丢帧、耗时长等问题的原因所在。
使用Frame分析响应性能
1.
2.
3.  首帧响应时延 起点 终点 基线(ms) 输入阶段 mmi_service对应的service report(type为up) 应用DispatchTouchEvent的起点(type=1) 8 应用阶段 应用DispatchTouchEvent的起点(type=1) 页面首次发生变化帧对应的H:FlushMessage结束点 25 渲染阶段 对应的RS帧ProcessCommandUni起点 对应的RSHardwareThread::CommitAndReleaseLayers的结束点 20 其中，应用阶段（如下图中标记2与3之间的部分）是开发者需要关注优化的部分，一般来说，应用阶段耗时若超过25ms的基线，加上机器硬件的30ms左右耗时，整体的时延就可能超过100ms的标准，导致点击响应体验不佳，需要进一步定位性能问题。
4.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151128.85755664866597703633763096694962:50001231000000:2800:E4B5DDAADC2CC23383BCE5DDD9870E70AF6E6A83A4B0AE9118C1F61E65D15EC2.png)
|  首帧响应时延 |  起点 |  终点 |  基线(ms) |
| --- | --- | --- | --- |
|  输入阶段 |  mmi_service对应的service report(type为up) |  应用DispatchTouchEvent的起点(type=1) |  8 |
|  应用阶段 |  应用DispatchTouchEvent的起点(type=1) |  页面首次发生变化帧对应的H:FlushMessage结束点 |  25 |
|  渲染阶段 |  对应的RS帧ProcessCommandUni起点 |  对应的RSHardwareThread::CommitAndReleaseLayers的结束点 |  20 |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151128.23854317178927260333492774688890:50001231000000:2800:AF91899DF14ECAA88B1676B428054E074314C3DA2E49D52C96B1DA6637AA3F58.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151128.55375065793200796827156158954641:50001231000000:2800:E8B694380DEDE197AF6BE16F1EB4D9E6D2E22DDDA105271E3A1E488A6BB90B4E.png)
更多使用方法参考《Frame分析》。
ArkUI Inspector
ArkUI Inspector是DevEco Studio中提供用于检查UI的工具，开发者可以借助它预览真机或模拟器中的UI效果，快速定位布局层级问题，也可以观察组件属性、不同组件之间的关系等。
具体的使用场景和操作参考《布局分析》。
常见问题根因分析
UI优化
应用开发中的用户界面UI（User Interface）是用户与应用程序交互的关键部分。使用不同类型的布局，能在界面显示上达到预期效果。某些方式能将页面排布得更加美观，但也容易引入不合理的结构问题。如果UI界面中存在过度的布局计算、冗余的元素绘制，将会带来设备资源的大量开销，造成响应性能的衰退。
减少嵌套层级
布局的嵌套层次过深会导致在创建节点及进行布局时耗费更多时间。因此开发者在开发时，应避免冗余的嵌套，并尽量使用扁平化布局来优化嵌套层级。
具体内容见精简节点数和合理使用布局组件。
减少渲染时间
if/else条件渲染是ArkUI应用开发框架提供的渲染控制能力，可根据应用的不同状态，渲染对应分支下的UI描述。
具体内容见合理使用渲染控制语法。
用renderGroup缓存动效
页面响应时，可能大量使用属性动画和转场动画，当复杂度达到一定程度之后，就有可能出现卡顿的情况。renderGroup是组件通用方法，它代表了渲染绘制的一个组合。
具体原理是在首次绘制组件时，若组件被标记为启用renderGroup状态，将对组件及其子组件进行离屏绘制，将绘制结果合并保存到缓存中。此后当需要重新绘制相同组件时，就会优先使用缓存而不必重新绘制了，从而降低绘制负载，进而加快响应速度。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151128.49555884856550662028795006307186:50001231000000:2800:5F02F4C91C155D2EAB83A2D5648ADFCD4CE895D41AF6B89B4793DF1528B6F866.gif)
为了能使renderGroup功能生效，有以下限制条件：
LazyForEach懒加载
使用LazyForEach懒加载替换ForEach，避免像ForEach那样一次性初始化和加载所有元素，从而使首帧绘制时创建列表元素时间大大减少，提升响应性能表现。
相关原理及案例参考《优化长列表加载慢丢帧问题》。
动态import
动态import是一种模块加载机制，允许应用程序在运行时按照实际需求去加载相关模块。在某些条件满足时（比如用户交互时，或ABTest分支切换时）再加载特定模块，可以减少初始化import的加载时间和资源消耗，这将有助于提高应用程序的内存性能和响应速度。
与静态import不同，动态import仅在需要时才消耗CPU等资源；相比静态import在编译时就确定了引入的所有模块，动态import还有更佳的语法灵活性，借助这种灵活，能够实现代码和路由级别的粒度分割，优化模块层次的懒加载性能。
具体的使用场景和实现方案参考《动态import》。
并发优化
并发是指多个任务在同一个时间段内同时触发执行，具体逻辑中使用多线程异步执行，与之相对的概念是串行任务，按顺序同步执行。
应用中的并发优化就是在响应用户操作期间，尽可能地让主线程只执行UI绘制相关的任务，而将非UI的耗时任务分配给其他线程或者延迟处理。这样借助多线程的异步技术，充分利用多核处理器的能力，提高应用程序的并发处理能力，减少用户等待时间，保证用户界面的响应流畅性。
异步任务并发处理
二者原理和效果差异可参考《TaskPool和Worker的对比实践》。
使用组件异步加载特性
Image组件支持异步加载特性：当应用在页面上展示一批图片的时候，会先显示空白占位块，当图片在其他线程加载完毕后，再替换占位块。这样图片加载就可以不阻塞页面的显示，给用户带来良好的交互体验。
设置示例：
相应的，如果展示图片数目很少，或加载本地图片，耗时明显较少时，这时建议配置syncLoad属性为true，使图片同步加载，避免特定情况下图片加载出现的闪烁。
代码逻辑优化
代码逻辑的优劣对应用响应速度的影响是比较明显的，特别是点击切换后新页面中的aboutToAppear、onPageShow等生命周期回调，以及点击操作页面中的aboutToDisappear等，需要充分优化代码、减少冗余、避免耗时，提升执行效率。
基于平台SDK的开发框架下，对App生命周期的理解，可以帮助开发人员识别程序在不同阶段的行为，弄清楚不同形态转换时触发的接口性质、各函数被调用的频率，进而挖掘出代码优化的方向。
下图是页面及自定义组件的生命周期流程：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151128.31045811305976686155286369053910:50001231000000:2800:95E3A059F089310500F45C9079FE8F2455147913879FA91A5552D1A42EAE2F1A.png)
通常可以采用的逻辑优化方法有：
-  索引存取考虑使用array数组，hash查找考虑使用map，去重逻辑考虑使用set等； 有时开发者使用object变量作为容器去处理map的逻辑，可以考虑使用ArkTS提供的高性能容器类，直接使用HashMap； 遇到纯数值计算的场合，推荐使用TypedArray的数据结构，比如Int8Array、Int32Array、Float32Array、BigInt64Array等。
-  当某些运算结果会反复使用时，以空间换时间，提前缓存以便于下次调用。
-  new和delete可能会触发内存管理回收，占用CPU资源从而影响界面渲染的能力，需要根据情况调整其频次。尤其在循环代码中，频繁的new、delete更会带来恶化的性能表现，应该尽量将new/delete优化到循环外去处理。
-  将资源关闭和释放操作放在setTimeout函数中执行，使其延迟到系统相对空闲的时刻进行，可以避免在程序忙碌时段占用关键资源，提升整体性能及响应能力。具体的使用场景和实现方案参考《延迟执行资源释放操作》。
-  应用识别拖动手势事件时需要设置合理的拖动距离，设置不合理的拖动距离会导致滑动不跟手、响应时延慢等问题。针对此类问题可以通过设置distance大小来解决。具体的使用场景和实现方案参考《减小拖动识别距离》。
视觉感知优化
上述几节内容，是从减少时延绝对值的角度来提升响应体验，而视觉感知优化则是通过交互设计的优化，提升用户响应速度的感知。
从响应速度的反面角度来讲，应用的卡顿其实就是视觉上出现了不流畅的画面，引起了用户的注意，令其产生了一定的不适感。这也就意味着，在用户操作后，需要第一时间从视觉层面给与反馈响应，从而解决视觉动作带来的不适。
开发者可以在用户的交互动作开始时，从感知角度添加一些动画元素，比如单击效果、转场缩放、加载进度条、共享动画等，这些可以告诉用户目前状态发生了变化，APP在快速地运作着；而动画的背后是：数据的计算，布局的渲染，内容的加载等等，当新界面渲染显示完成，上述动画元素就可通过渐变消失、移出屏外等友好的方式退出视觉区域。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151128.55944493054016545651039389065796:50001231000000:2800:691B275E4D11F5A41FA9E24EB185937EF4E6B2F4CE297A0FA5309ABBFD6AB2F7.png)
使用这样连贯的感知元素，能提供一种视觉隐喻，将用户的注意力从上个页面平滑地过渡到下个页面；交互动画表现得友好、有趣和实用，则用户在响应侧的体验会更加舒适，从主观上也会认为应用性能好、反应速度快。
具体的使用场景和实现方案参考《转场动画场景案例》和《动画时延场景案例》。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-click-to-complete-delay-analysis
爬取时间: 2025-05-01 08:44:57
来源: Huawei Developer
完成时延优化概述
在移动终端应用开发中，完成时延是指用户操作移动终端时，从输入触控指令到界面完全刷新结束并达到可以阅读的稳定状态所用时间，点击完成时延依据页面转场类型可以分为页面内跳转和页面间跳转两种。完成时延在用户体验设计中扮演着关键的角色，直接影响用户对产品的满意度和使用体验。完成时延反映了用户对响应速度的整体感受，主要影响用户对触控交互及时性和愉悦性的体验评价。如图一所示，点击完成时延包含点击响应时延，关于响应时延阶段的优化分析，请参考《点击响应时延分析》。
在一定时延水平以上，完成时延越短越好，当完成时延小于一定水平后，用户的流畅体验不再继续提升，建议应用或元服务内点击操作完成时延≤900ms，更多体验建议，请参考指南《时延体检建议》。本文将介绍相关分析工具，点击完成时延问题定位流程以及常见问题根因分析。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151128.55745490651902374461497198768661:50001231000000:2800:4A32E98E3BCAC0D4B7C005744A39F1CE813352C38B12E1B2608578003A24FE30.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151129.62833542284022230232147303940746:50001231000000:2800:C18E2C9AF48A4CBB9D9975BF4BD77BABE6F4249BA92FBD5D5AB718635708FA06.png)
工具介绍
性能问题检测工具 AppAnalyzer
AppAnalyzer是DevEco Studio中提供的检测评分工具，用于测试并评价HarmonyOS应用或元服务的质量，能快速提供评估结果和改进建议，当前支持的测试类型包括兼容性、性能、UX测试和最佳实践等，其中点击完成时延是性能类型中的一项检测规则，开发者可以使用该工具检测响应性能。
具体使用可参考《AppAnalyzer》。
性能问题分析工具 DevEco Profiler
性能调优深入分析工具，支持冷启动、卡顿丢帧、状态变量、并行化、网络耗时、ArkWeb、内存优化等场景化调优能力。其中Frame分析可以帮助开发者深度分析性能问题，通过录制应用运行过程中的关键数据，从而识别卡顿丢帧、耗时长等问题的原因所在。
具体使用可参考《DevEco Profiler》。
性能问题分析工具 ArkUI Inspector
ArkUI Inspector是DevEco Studio中提供用于检查UI的工具，开发者可以借助它预览真机或模拟器中的UI效果，快速定位布局层级问题，也可以观察组件属性、不同组件之间的关系等。
具体使用可参考《ArkUI Inspector》。
问题定位流程
下图展示了定位点击完成时延高耗时的简易流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151129.34299169673553894881566387669862:50001231000000:2800:04BDBA674B846F3449983CA971825AC8A3B4D552F5AC45DF8E51F337DB5355D9.png)
如上图所示，分析点击完成时延问题一般需要以下几个步骤：
关键泳道简介
上述五个关键泳道可通过函数调用耗时、转场页面绘制耗时、转场动画时延三个角度进行分析，现依据这三个角度，对关键泳道展开介绍
-  ArkTS Callstack：提供了ArkTS侧的方法调用栈信息，对于分析ArkTS代码的执行实践和性能瓶颈非常关键； Callstack：提供了Native侧的方法调用栈信息，对于分析Native层面的性能问题非常关键；
-  Frame：提供了应用主线程的帧渲染信息，它可以帮助识别点击完成过程中哪些帧没有按时渲染，以及可能的原因； ArkUI Component：提供了ArkUI组件的创建、布局、渲染等过程的详细信息。可以帮助识别出哪些组件的创建或渲染过程耗时较长；
-  H:Animator：提供了动画执行过程中的详细信息，可以帮助识别点击完成过程中转场动画是否耗时较长 关键Trace说明如下 序号 泳道 Trace点 描述 1 应用线程 ReceiveVsync 接受Vsync信号 2 应用线程 OnvsyncEvent 收到Vsync信号，渲染流程开始 3 应用线程 FlushVsync 刷新视图同步事件，包括记录帧信息、刷新任务、绘制上下文、处理用户输入 4 应用线程 FlushDirtyNodeUpdate 标脏组件刷新。页面刷新渲染的时候要尽量减少刷新的组件数量。当状态变量改变后，会先对状态变量相关的组件进行标脏，然后对这些组件重新测量和布局，最后再进行渲染 5 应用线程 JSAnimation 显示动画，动画会影响组件加载完成时延 6 应用线程 FlushLayoutTask 执行布局任务。在此阶段会对组件做布局测算，如果层级较深或者组件较多会影响性能 7 应用线程 FlushMessages 发送消息通知图形侧进行渲染 8 应用线程 aboutToBeDeleted 自定义组件生命周期函数，组件析构时出现，在未使用复用机制时，FlushDirtyNodeUpdate和LazyForEach predict下会析构组件，导致刷新时组件重复创建 9 应用进程 SendCommands 应用UI提交到Render Service 10 ArkTS Callstack createHttp 创建网络请求 11 ArkTS Callstack request 发送网络请求 12 ArkTS Callstack parse 解析数据 13 ArkTS Callstack off 取消订阅
| 序号  | 泳道  | Trace点  | 描述  |
| --- | --- | --- | --- |
| 1  | 应用线程  | ReceiveVsync  | 接受Vsync信号  |
| 2  | 应用线程  | OnvsyncEvent  | 收到Vsync信号，渲染流程开始  |
| 3  | 应用线程  | FlushVsync  | 刷新视图同步事件，包括记录帧信息、刷新任务、绘制上下文、处理用户输入  |
| 4  | 应用线程  | FlushDirtyNodeUpdate  | 标脏组件刷新。页面刷新渲染的时候要尽量减少刷新的组件数量。当状态变量改变后，会先对状态变量相关的组件进行标脏，然后对这些组件重新测量和布局，最后再进行渲染  |
| 5  | 应用线程  | JSAnimation  | 显示动画，动画会影响组件加载完成时延  |
| 6  | 应用线程  | FlushLayoutTask  | 执行布局任务。在此阶段会对组件做布局测算，如果层级较深或者组件较多会影响性能  |
| 7  | 应用线程  | FlushMessages  | 发送消息通知图形侧进行渲染  |
| 8  | 应用线程  | aboutToBeDeleted  | 自定义组件生命周期函数，组件析构时出现，在未使用复用机制时，FlushDirtyNodeUpdate和LazyForEach predict下会析构组件，导致刷新时组件重复创建  |
| 9  | 应用进程  | SendCommands  | 应用UI提交到Render Service  |
| 10  | ArkTS Callstack  | createHttp  | 创建网络请求  |
| 11  | ArkTS Callstack  | request  | 发送网络请求  |
| 12  | ArkTS Callstack  | parse  | 解析数据  |
| 13  | ArkTS Callstack  | off  | 取消订阅  |
关键Trace分析
确定起止点
开发者可以通过录屏辅助测试，通过录屏分析工具来确定点击完成时延的起止点，进而判断是否存在需要优化的时延类问题。
DevEco Profiler工具分使用方式可以参考Frame分析。下面介绍如何使用DevEco Profiler工具确定点击完成时延Trace的起止点。
1.
2.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151129.39820754389946327374899020494999:50001231000000:2800:741E980F8539F4EE01079BAF1D336512995E47BB8088962506848938D103A02E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151129.16492535363345652410076303723480:50001231000000:2800:1344A1B897161FB610DA6310FACEC615622D1A0C4E06565D1D3D0F19402B6642.png)
ArkTS Callstack泳道分析ArkTS侧耗时函数
ArkTS Callstack子泳道ArkVM是需要优先查看耗时情况的泳道，可以看到ArkTS侧一些方法的耗时,优先分析耗时最长的调用栈（program除外，program代表程序执行进入纯Native代码阶段，该阶段无Ark TS代码执行，也无Ark TS调用Native或者Native调用Ark TS情况，需要切换到Callstack泳道看具体的调用栈信息，一般很难通过这里分析出有效的信息），逐级展开,可以看到具体耗时的文件。基于“HMOS世界”切换tab页场景，抓取Trace信息。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151129.84442859648459117278203801487702:50001231000000:2800:47D53EAF27F2741B611351537CC4E4EB4260CF4079ADE2A204BDFD85F156C684.png)
观察发现MainPage文件中匿名函数耗时350ms，展开该节点。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151129.75569284685780007643764968249642:50001231000000:2800:3F29E018BCD8E046D53C6CD4EC027E22A11E7FD19569476738CB76C26F0CC3D8.png)
展开节点后发现函数调用链中AudioPlayerService中getInstance函数调用耗时327ms，接下来定位源代码。
AudioPlayerService.ets相关代码如下
观察源代码发现AudioPlayerService调用getInstance创建单例对象耗费大量时间，随即又调用destroy方法销毁对象。优化方式如下：获取单例对象前，先判断单例对象是否被实例化，若没有实例化则直接跳过获取与销毁，避免实例对象的无效创建与销毁，参考如下代码。
优化后AudioPlayerService.ets代码如下：
Frame主线程泳道分析异常帧
查看 Frame 泳道里面的应用主线程子泳道，观察 app 侧帧数据。在这个泳道中，如果出现红色的帧通常表示该帧的渲染时间超过了预期，这可能是一个性能异常的指示。
如下图所示的第145帧
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151129.78250167376346475039848929333534:50001231000000:2800:776A99D3F7CC6E351CEBF62B1C922F2E74615760597E79A39F5C72FB2621AC11.png)
每帧的预期耗时（ms） = 1000ms / 帧率 。如上图，鼠标点击选中超长帧，可以看到该帧的预期耗时Expected Duration 为8ms 330μs，说明帧率是120，而实际耗时为92ms571μs，这远远超过了预期耗时，因此被识别为超长帧。超长帧的长时间渲染会直接影响用户体验，并可能导致整个点击完成时延不达标。
通过上图发现卡顿期间有长段的ExecuteJS，需要查看具体的调用栈，观察ArkTS Callstack泳道无异常，接下来查看Callstack泳道的函数栈。
关于首帧渲染的特别说明：页面跳转后，由于需要重新加载和渲染新的UI元素，首帧的渲染时间往往会较长，不一定能够达到应用目标帧率下的预期耗时。因此，在性能分析中，页面跳转后的首帧出现红色（即超过该场景下的合理预期时间）是比较常见的现象，不一定意味着存在严重的性能问题，但也需要关注其是否过长，以便进行必要的优化。
Callstack泳道分析Native侧耗时函数
Callstack泳道，该泳道显示Native函数调用泳道，也可以看到Native函数调用栈以及各函数的耗时情况，主要查看主线程子泳道以及有内容的WorkerThread子泳道。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151129.40473928818317888485991382868079:50001231000000:2800:5A864E5299E9B65DFBE0AF55FCE75F2B1A636207D6B81C45F15779C804BE6BA7.png)
滑动观察右侧权重占比最大的函数调用栈，定位到主要耗时是由于MainPage.ets文件下第203行代码引起。
ArkUI Component泳道分析组件绘制耗时
ArkUI Component泳道记录了自定义组件以及系统组件的绘制次数、耗时等信息，重点关注相对于其他组件耗时比较久的组件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151129.67874807466132882374067207209255:50001231000000:2800:32AD74882D05CA1F921C0D01BE768C7612412081B344D35D386CF739AD71D32A.png)
然后可以在详情Details中使用下图中被框选的按钮过滤目标组件，查看组件在刷新过程中不同阶段的耗时情况。结合函数调用栈与ArkUI Inspector工具定位目标组件绘制耗时过长的具体原因。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151130.16629729388130641223563381855704:50001231000000:2800:6CFE6D7DE82F836DCCE32605989ABF87EE98B0859AB56E3D42F8443BA4A661F3.png)
H:Animator泳道分析动画时长
如果点击页面切换的过程中有加载的loading动画,出于用户体验考虑，故意将动画的停止与网络请求的完成相关联。例如，为了向用户展示“加载中”的状态，直到数据加载完成。可以通过H:Animator 泳道，看出动画耗时。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151130.59544706647818979764081795729261:50001231000000:2800:F0F406182807159339633974CB16EE2EB16B1593029395864EA96934B4095243.png)
常见问题根因分析
网络请求耗时
在附带网络请求的页面跳转场景中，完成时延耗时长的绝大多数原因都是因为网络数据Http请求时间长。由于网络是从操作系统侧发起和控制的，且网络环境存在不可控性，所以我们很难在业务逻辑的代码中优化请求速度。因此尽可能的提前发起请求就尤为重要。通常可以从以下两个方面进行优化：
避免在异步函数中发起网络请求
由于ArkTS单线程EventLoop特性，其异步调用的执行时机会被延迟到同步逻辑后。那么如果我们将Http请求接口放到异步函数时，则可能会出现如下图所示情况网络请求被UI绘制阻塞，网络请求等待第一帧UI绘制结束才开始，如果页面首帧较复杂，则会导致该时长严重增加。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151130.58357319366171883663124296858388:50001231000000:2800:C87FBA56954C94E05AD99CB4C59AADD24F35F3977BCD6BE59FD25E86055A4B7C.png)
避免在页面子组件中发起网络请求
由于ArkUI组件的创建基于组件树结构，存在先后顺序。那么如果我们在页面的某一子组件中发起网络请求，则该请求需要等待其前面的组件创建完成才会发起，如果前面组件创建耗时较长，也会导致该请求被严重阻塞。
如下图情况，应用页面结构分为Header和Tabs两部分，如果将Tabs内容数据的Http请求放在Tabs组件中发起，由于Tabs组件在UI结构上依赖Header部分，则需要先创建Header，同时又因为Header内容的渲染也依赖网络请求，所以最终导致Tabs的数据请求严重延后。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151130.03364765740586674944462795176817:50001231000000:2800:010125882B8C0C57ACA599AB611A60ACBCA760B78E3C8007C60C9320D6B17AEF.png)
动画时延耗时
页面的转场动画是提升用户体验的重要环节。然而，当动画时延耗时较长时，它会对用户的点击完成时延产生显著影响。动画的完成时间直接关系到用户何时能够开始与应用进行交互。动画时延影响点击完成时延的根因主要为动画时长设置过长。
常见的页面转场动画时长参数有：
使用Tabs组件进行页面切换时，当不设置BottomTabBarStyle时默认animationDuration属性有300ms的动画时长，当该属性值设置过长时会导致完成时延变大。接下来将该属性值分别设置为100ms与1000ms来探究animationDuration属性对完成时延的影响。
实验一：设置animationDuration为100ms
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151130.89725648254898954699459070287533:50001231000000:2800:EC5DE51CAEA01C8AF3478BD9738C744BB3D36143E860F0B156D02EA159825242.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151130.53715372646932722646306382101065:50001231000000:2800:AFC2FD6BDB37EE3BB0B9ECD9ACF416256B6170992B03CC28DE2F4A3DB9916006.png)
| 设置animationDuration为100ms  | 设置animationDuration为1000ms  |
| --- | --- |
|   |   |
设置animationDuration为100ms
设置animationDuration为1000ms
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151130.44626552839523484763904370750970:50001231000000:2800:E72489CDA091C0A6D0ECF862D149B09E82AE18C37358C57B7116B0E06D77C09B.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151130.10869580681833072943153573925229:50001231000000:2800:CE4816F76572BBA933C44D3512307489DED50189BACB1E4D7312DD97D6958B91.gif)
| animationDuration属性值  | 完成时延  |
| --- | --- |
| 100ms  | 99ms39μs  |
| 1000ms  | 1s7ms693μs  |
animationDuration属性值
完成时延
100ms
99ms39μs
1000ms
1s7ms693μs
上述示例通过减少animationDuration属性的数值，减小了Tabs组件切换动画的完成时延。当不设置BottomTabBarStyle样式时，动画时长默认为300ms，开发者可根据实际业务场景需要适当降低该动画时长，提高应用性能。
UI组件优化
转场新页面的组件过于复杂、布局不合理以及资源全量加载等会影响页面首次加载时延，可以采取如下方法进行性能优化：

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-frame-practice
爬取时间: 2025-05-01 08:45:10
来源: Huawei Developer
丢帧问题原理
在了解如何定位应用丢帧问题之前，开发者需要简单了解HarmonyOS中图形渲染的流程，便于在遇到卡顿时可以分析卡顿可能出现的阶段和原因。
在HarmonyOS中，图形系统采用了统一渲染的模式，遵循着一个典型的流水线模式，以90Hz刷新率为例，每个Vsync周期是11.1ms，整个过程如下图所示。如果是60Hz，每个Vsync的周期是16.7ms；如果是120Hz，则每个Vsync的周期是8.3ms。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151130.08309945449200434481866011710056:50001231000000:2800:E825E4350BAA79BD92FCA7E524C2DB0E3E407EEF2B80132C9CBB2C3521172929.png)
在整个渲染流程中，首先是由应用侧响应消费者的屏幕点击等输入事件，由应用侧处理完成后再提交给Render Service，由Render Service协调GPU等资源处理后，再将最终的图像统一送到屏幕上进行显示。
其中应用侧的渲染流程如下图所示，了解ArkUI的渲染流程有助于我们定位应用侧的卡顿问题出现在哪个环节：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151131.43988608024042528620801713681271:50001231000000:2800:3420F9D371DD786E2AF3C395BBCF752DA2D30DAE9F6B7EE3A6D2CC4ECB6E7E25.png)
在整个处理流程中，应用侧和Render Service侧都有可能出现卡顿导致最终用户观测到丢帧的可能，我们分别将这两种情况命名为AppDeadlineMissed和RenderDeadlineMissed。一般而言，前者可能是应用逻辑处理代码不够高效导致的，后者可能是界面结构过于复杂或者GPU负载过大等原因导致的。这两个故障模型通过Frame模板都可以直观地看到。相应的故障模型如下面两幅图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151131.19116237915329431097602531952626:50001231000000:2800:9CDE7FE227BE0783973F2177D44C22F0DD8FD266D9E91E727D92A0F417F967CE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151131.72703219987466862544275547194956:50001231000000:2800:6866B52A7E143F17EBF75986B73336FA2F7D6659C7571072E3204A079CC1F310.png)
丢帧问题思路分析
补充了图像渲染流程的基本知识和丢帧的故障模型后，接下来我们介绍丢帧问题的分析思路，下图展示了解决丢帧问题的简要流程：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151131.15006010282425923514464963527987:50001231000000:2800:A3466F48E52CC3F4341DBA8E82603309A2A14DFB291E11096A35E1C400D5D830.png)
从上图可以看到处理丢帧问题一般需要以下四个步骤：
接下来本文将以“HMOS世界”应用的首页列表为例，介绍如何通过Frame分析、定位、解决卡顿问题的全过程。为了便于演示这个长列表的调优过程，这个列表初始加载了1000条数据。
我们在滑动列表的过程中，随着时间的推移，我们可以感觉到越来越卡顿，接下来我们将介绍如何分析并解决这个卡顿问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151131.46487774062644879345143600473837:50001231000000:2800:7582011BEE21B4BF2F9FFAFD2B9904228F638D400949CB0878A0AEA4E3675B62.png)
第1步：识别丢帧
使用AppAnalyzer检测性能问题
首先使用AppAnalyzer工具进行性能问题检测，AppAnalyzer是DevEco Studio中提供的检测评分工具，用于测试并评价HarmonyOS应用或元服务的质量，能快速提供评估结果和改进建议，当前支持的测试类型包括兼容性、性能、UX测试和最佳实践等。因为本文主要是介绍丢帧问题的分析，所以下面重点介绍了使用AppAnalyzer对列表滑动响应和滑动过程中的流畅性能检测，具体使用可参考《应用与服务体检》。
1.
2.
3.
4.
5.
6.  点击左侧的菜单栏对应的选项，可以查看异常的具体信息，这里以”Fast Detection Of Smoothness During Sliding”选项为例，应用滑动时的卡顿率应该小于5ms/s，但是示例中有多帧超时达到8.49ms，存在进一步优化的空间，关于应用滑动流畅的体验标准可以参考应用/服务体检规则。
7.
8.  点击左侧的菜单栏对应的选项，可以查看异常的具体信息，这里以”Fast Detection Of Smoothness During Sliding”选项为例，应用滑动时的卡顿率应该小于5ms/s，但是示例中有多帧超时达到8.49ms，存在进一步优化的空间，关于应用滑动流畅的体验标准可以参考应用/服务体检规则。
1.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151131.98211571705165971194313299783291:50001231000000:2800:C69855910B5D71A2155582ECB3A12B2D6C937D25F2177FF7FC28F4416598C6EF.png)
1.
2.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151131.14698107283236700773396194166763:50001231000000:2800:B095AEEB7AB03D24A1DD2075122731B747036871590D40F2A27D23D95F63E89C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151131.67924309092803572168662270951804:50001231000000:2800:15BF3E3953BAE197C88816709CF26D149598A3F420164236621D6C8763E4EC5C.png)
-
-  点击左侧的菜单栏对应的选项，可以查看异常的具体信息，这里以”Fast Detection Of Smoothness During Sliding”选项为例，应用滑动时的卡顿率应该小于5ms/s，但是示例中有多帧超时达到8.49ms，存在进一步优化的空间，关于应用滑动流畅的体验标准可以参考应用/服务体检规则。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151131.03225439651077819545810150935788:50001231000000:2800:79B2485FE47C0CFC4FDD89A929B6EDD9C98DA73C937004CED9BF48BF3CA747E3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151131.70150115209064506018598550033293:50001231000000:2800:201245A8B4CDACF61AAD64CF1AF6B1BF7176F74D6A9E307700D9B7986BDBCB06.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151131.68994684008374534631608512951727:50001231000000:2800:F855AB732DACF3093AA9EF0F32A792492C52623A0AEA0EDE5B1D15CBBF21D0C9.png)
录制Frame模板
发现卡顿丢帧问题后创建Frame模板录制，在录制期间复现卡顿丢帧场景，具体操作步骤请参见性能问题定位：深度录制。
录制完成后，在时间轴上拖动鼠标选定要查看的时间段，这里选择了一个2.5s的时间区段。选中Frame主泳道，查看下面的Statistics栏，可以发现应用在这个时间段内丢了16帧，丢帧率达到了7%。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151131.20785529357378162435148565660492:50001231000000:2800:C12B38406A9713536AF7D27E132AE3840DEB228025D212FBD10D58D59078AB3B.png)
认识卡顿帧
下面是使用Frame Profiler录制的一段Trace，在时间轴上拖动鼠标选定要查看的时间段，这里我们选择了一个2.5s的时间区段。选中Frame主泳道，查看下面的Statistics栏，可以发现应用在这个时间段内丢了16帧，丢帧率达到了7%。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151131.23693243141471453500899634641294:50001231000000:2800:944CBD2DF59073DDE99139030EB0D6EF981969D864EF8FFAB9615E0168C12048.png)
丢帧问题可能出现在Render Service侧，也有可能出现在App侧。上图中的丢帧主要出现在应用帧，针对这种丢帧现象我们继续分析，放大右侧的图表，选中超时的帧查看详细数据，期望时间为8.3ms（当前设备为120Hz），而实际处理时间为8.9ms。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151132.18688353793959339939902047418351:50001231000000:2800:62C6E8BB93BC7BB1A3507DFFA594F1783FEA36697747A9D23994F0AC32723724.png)
在“RS Frame”和“App Frame”标签的泳道中，正常完成渲染的帧显示为绿色，出现卡顿的帧显示为红色。其中期望结束时间点之前的部分为浅红色（两条白色竖线区间），超出期望结束时间的部分为深红色，异常帧显示为黄色。
发现问题后，接下来我们来分析这个丢帧问题。导致应用丢帧的原因非常多，可能是应用本身原因，可能是系统原因，也有可能是硬件层原因。不同卡顿原因在Trace中有不同表现，识别需要大量经验积累。
第2步：分析丢帧原因
丢帧问题分析过程，主要是结合App主进程和Render Service渲染进程Trace数据，先排查系统是否异常，再分析应用本身原因，开发者可以通过以下步骤来定位丢帧问题。
2.1 看线程状态和运行核，看是否被其他进程抢占资源，排除系统侧运行异常。
看线程状态
从下图可以看到，应用线程大部分时间处于Running状态，无特殊异常。运行在CPU10和CPU11上
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151132.76291385532687647868823153238716:50001231000000:2800:516FF87A8E8D1140611161C4D435708FD459DE1AF65ECDAAE90AD0D80BD18A86.png)
看运行频率
查看关键任务是否跑在了小核，以低频运行。从CPU Slice和Frequency泳道，如图8所示，可以看到丢帧处应用线程和前面正常帧类似，都主要运行在大核上（该设备0~3号CPU是小核，4~11号CPU为大核）。鼠标悬浮在Frequency泳道上，可以看到CPU运行频率。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151132.17718330218748444236143329043883:50001231000000:2800:349764BB7A92A89B10B2C1668554170AD6674CE136D97BEB08A87EA0874BC2D1.png)
通过上面的分析，可以看到应用线程正常运行在CPU大核上，且运行频率正常。到这里，这个示例可以排除系统异常。
如果应用线程运行出现以下问题，开发者可以进行在线提单反馈异常。
出于兼顾高性能、低功耗的需求，多核工程机常采用异构架构设计，根据CPU频率，区分大中小核等。
2.2找到Trace中每一帧耗时的部分，大致定位是App侧问题还是RS侧问题，并结合Trace标签，初步定位原因。
通过Frame泳道，我们可以快速发现丢帧的位置，并完成初步的定界：
前面示例中的丢帧主要出现在应用侧，针对这种丢帧现象我们继续分析，放大右侧的图表，选中超时的帧（220#帧）查看详细数据，期望时间为8.3ms（当前设备为120Hz），而实际处理时间为8.9ms。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151132.09294633083125093001238207967944:50001231000000:2800:116D884848D33EB29F2E27E9F13A9829EC3F5E42BB6DF70F6576931F7CBCA6AF.png)
接下来通过Trace再看看每一帧的具体耗时情况。这里有一个小技巧，我们可以点击泳道信息区的收藏按钮，将应用帧处理的泳道收藏置顶，可以有效防止上下文信息丢失。点击图标跳转到卡顿帧应用侧Trace详情，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151132.20771453392750563852955098221176:50001231000000:2800:876E31408CC56D279C99FDB02289784556E4D7074CA3CED8430B56BC9A48197D.png)
可以看到这几帧的卡顿可能都是BuildLazyItem方法耗时较长导致，可以大致推测，是列表懒加载时，Item绘制时间较长导致的。
同时在ArkUI Component泳道上，可以直观的看到，自定义组件ArticleView的绘制频率比较高且比较耗时，对于太过频繁的绘制组件，可能也是影响应用丢帧的原因。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151132.50840359320030770579565447776040:50001231000000:2800:CDCF82EB5E269706894CEF4FF0741113EC12A0758FC48A51ABCEE70BE0751E68.png)
需要注意的是在Frame模板中，要想查看ArkUI Component泳道需要在泳道录制前进行手动勾选，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151132.45285800457852722659861031874190:50001231000000:2800:44DC1019628EBA47787FF9C85EB00D19A44A7B8F89F436AB65EE5F34C8E6730D.png)
2.3查看ArkTS函数调用栈信息，排查应用代码。
可以结合Frame Profiler工具，选择ArkTS Callstack泳道查看热点函数，方便地跳回源码，定位具体是哪一个自定义组件绘制时间较长。如下图所示，可以看到自定义组件ArticleCardView的绘制频繁。下面以220#帧为例子，通过热点函数可以看到其中initialRenderView 和__lazyForEachItemGenFunction这两个方法比较耗时，占比分别达到52.7%和22.9%，其中绿色的”ArkTS”表示双击该行可以跳转到应用源码。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151132.52424303830074265604967368963870:50001231000000:2800:DC0EAB680759E6B8541892E3BEED42CD14D7F2222B332BC1F660464E07EA6DCC.png)
我们以initialRenderView函数的耗时为例进行分析，展开函数，可以看到主要是列表项ListItem的子组件ArticleCardView创建比较耗时。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151132.04083810330306765362830290800641:50001231000000:2800:B095876AE4031F093A4B3BFD4C61E5989080070508E6798432FBF3F6EEF61B75.png)
展开其中一个组件函数调用链进行详细分析，通过查看函数调用，可以猜测是由于使用了@Prop变量，@Prop装饰的变量会对父组件传入状态值进行深拷贝，如果@Prop装饰器装饰的变量为复杂Object、class或其类型数组时，会增加状态创建时间以及占用大量内存。双击跳转到源码，可以看到自定义组件ActionButtonView中确实使用了@Prop装饰器变量。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151132.09016368842051846612278226776741:50001231000000:2800:FD11F65FAFEB82544389161B49B34B0771B16E267B65B1FADB909BFC66ACFC50.png)
其它函数耗时的详细调用这里不一一列举。
第3步：选择优化方案
选择优化方案需要一些经验的积累，开发者可以参考一些性能优化的最佳实践，来选择相应的优化方法。
下面我们对丢帧问题进行优化，针对前面的一些分析结果，我们可以从两方面来入手解决卡顿问题：
优化后示例代码如下：
```typescript
@Component
struct DiscoverView {
// ...
build() {
List() {
LazyForEach(this.dataSource, (item: LearningResource) => {
ListItem() {
ArticleCardView()
// ...
.reuseId('article')
}
}, (item: LearningResource) => item.id)
}
}
}
// Add @Reusable Decorator Use Component Reuse
@Reusable
@Component
export struct ArticleCardView {
// ...
aboutToReuse(params: Record<string, Object>): void {
// ...
}
Row() {
ActionButtonBuilder()
ActionButtonBuilder()
ActionButtonBuilder()
}
build() {
// ...
}
}
// Build subcomponents using @Builder
@Builder
function ActionButtonBuilder() {
// ...
}
```
第4步：验证优化效果
最后，我们可以使用步骤一的方式，来验证优化后的结果。下面用Frame模板录制后发现，丢帧情况得到明显改善，列表快速滑动15.9s，丢帧率为0%，丢帧问题得到解决。如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151132.53419453921242813486836208369022:50001231000000:2800:BF32B7AA2A41CBF13D370B8D9CD362A330941954D77AF67DC0FD443172BC2297.png)
如果此时问题仍未解决，可以再重新分析Trace定位问题，然后选择优化方式。
常见丢帧问题
下面列举了一些常见的丢帧问题以及对应的Trace，以及给出了一些优化方案，便于开发者遇到类似的问题，访问识别和定位。
自定义动画丢帧问题
在播放动画或者生成动画时，画面产生停滞而导致帧率过低的现象，称为动画丢帧。
播放动画时，系统需要在一个刷新周期内完成动画变化曲线的计算，完成组件布局绘制等操作。建议使用系统提供的动画接口，只需设置曲线类型、终点位置、时长等信息，就能够满足常用的动画功能，减少UI主线程的负载。
下面使用了自定义动画，动画曲线计算过程很容易引起UI线程高负载，易导致丢帧。
```typescript
@Entry
@Component
struct AnimationDemo1 {
@State widthSize: number = 200;
@State heightSize: number = 100;
@State flag: boolean = true;
computeSize() {
let duration = 2000;
let period = 16;
let widthSizeEnd = 0;
let heightSizeEnd = 0;
if (this.flag) {
widthSizeEnd = 100;
heightSizeEnd = 50;
} else {
widthSizeEnd = 200;
heightSizeEnd = 100;
}
let doTimes = duration / period;
let deltaHeight = (heightSizeEnd - this.heightSize) / doTimes;
let deltaWeight = (widthSizeEnd - this.widthSize) / doTimes;
for (let i = 1; i <= doTimes; i++) {
let t = period * (i);
setTimeout(() => {
this.heightSize = this.heightSize + deltaHeight;
this.widthSize = this.widthSize + deltaWeight;
}, t);
}
this.flag = !this.flag;
}
build() {
Column() {
Button('click me')
.onClick(() => {
let delay = 500;
setTimeout(() => {
this.computeSize();
}, delay);
})
.width(this.widthSize)
.height(this.heightSize)
.backgroundColor(0x317aff)
}.width('100%')
.margin({ top: 5 })
}
}
```
使用Frame Profiler录制Trace，可以看到动画帧率只有63fps左右，而当前设备是支持的设备刷新率是120Hz。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151132.33071240669622562359105566310487:50001231000000:2800:70BD35C6A86B9F7433DE828A618007B53779DF871153197885C86BFA90C6E447.png)
建议开发者通过系统提供的属性动效API实现上述动效功能，使用属性动画或者显式动画，下面以属性动画实现上面的效果为例：
使用Frame Profiler录制优化后的Trace，可以看到动画帧率有了较大的提升，达到了116.9fps。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151133.75235333073883644232733290505372:50001231000000:2800:5207CB5895C9A9DCBD93D4D9975223B26977B42ADAFA86055F3E5F5B8658E2AF.png)
布局嵌套过深
视图的嵌套层次会影响应用的性能。在屏幕刷新率为120Hz的设备上，每8.3ms刷新一帧，如果视图的嵌套层次多，可能会导致没法在8.3ms内完成一次屏幕刷新，就会造成丢帧卡顿，影响用户体验。因此推荐开发者移除多余的嵌套层次，使用相对布局 (RelativeContainer)，缩短组件刷新耗时。
例如下面这个示例在列表中加载了2000条数据，同时子组件ChildComponent里面的布局嵌套了20层Stack组件。
使用Frame Profiler进行录制，这里我们直接看应用侧的Trace数据，具体分析步骤可以看前面的丢帧问题分析思路章节
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151133.71536850237318971101331643883803:50001231000000:2800:C1B35AAE4249438C62DBEC3A3FDD086479EAC52C56D16A88EEDF6C56A35CCA65.png)
结合卡顿帧对应时间段的Trace数据，可以定位到FlushLayoutTask耗时过长，它的作用是重新测量和布局所有的Item，其中Measure方法耗时比较久，因此卡顿原因可能是布局处理逻辑过于复杂或低效。
开发者可以使用ArkUI Inspector，在DevEco Studio上查看应用在真机上的UI显示效果。利用ArkUI Inspector工具，开发者可以快速定位布局问题或其他UI相关问题，效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151133.82775121667848142866237799338516:50001231000000:2800:919D9A0341D84B2F1AF463C2A66CA0AD43550ED49979F6805280EC67C0039D0B.png)
可以直观的看到Item的嵌套比较深，接下来我们可以减少不必要的嵌套来尝试解决丢帧问题，示例代码如下：
```typescript
@Reusable
@Component
struct ChildComponent {
@State item: string = '';
aboutToReuse(params: Record<string, Object>): void {
this.item = params.item as string;
}
build() {
Stack() {
Text(this.item)
.fontSize(50)
.margin({ left: 10, right: 10 })
}
}
}
```
再次使用Frame Profiler进行录制，可以看到丢帧问题已得到解决。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151133.07630998180594383216402359900181:50001231000000:2800:BC9E01D4E90C47904E4F83F4BB7352FD4463708F6A87D04C7979AF8576C8D99E.png)
主线程中执行冗余和耗时操作
应避免在主线程中执行冗余与易耗时操作，否则可能会阻塞UI渲染，引发界面卡顿或掉帧现象，特别是在高频回调中执行耗时操作。具体可以参考：主线程耗时操作优化指导。
丢帧问题优化建议
前面我们简单介绍了图形渲染的流程，了解到了图像渲染的两个关键步骤：首先由应用侧响应消费者的屏幕点击等输入事件并且生成当前的界面描述数据结构，然后交给Render Service进行绘制。在这两个步骤中分别会出现AppDeadlineMissed和RenderDeadlineMissed卡顿。前者可能是应用逻辑处理代码不够高效导致的，可以结合Trace数据和热点函数进行分析；后者可能是界面结构过于复杂或者GPU负载过大等原因导致的，可以使用布局检查器ArkUI Inspector工具和HiDumper命令行工具辅助分析定位。
针对一些常见的丢帧问题，下面列举了一些优化建议：

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-web-click-response-delay-analysis
爬取时间: 2025-05-01 08:45:24
来源: Huawei Developer
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151133.66477535259513377606121919857267:50001231000000:2800:70DF723E4DAA0A71A3355BD1F90AD988F1821B7F632698C740AEC82FD7A4B04F.gif)
问题定位流程
Web网页整体加载流程与关键Trace点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151133.82466405372771059317294957945323:50001231000000:2800:C0AE31165ADBE77BC09978745C84ECB7D070FFAF9467FB4AB8D9021A18E18EFD.png)
| Web网页加载流程拆解  | 关键Trace  |
| --- | --- |
| 点击事件  | 最后一个DispatchTouchEvent到组件初始化前  |
| Web组件初始化  | NWebImpl|CreateNWeb到导航流程前  |
| 导航流程  | NavigationControllorImpl::LoadURLWithParams到NavigationBodyLoader::OnStartLoadingResponseBody结束  |
| DOM&CSS解析  | CSSParserImpl::parseStyleSheet和ParseHTML解析，扣除HTMLDocumentParser::RunScriptsForPausedTreeBuilder  |
| JS编译+执行  | EvaluateScript 和 v8.callFunction  |
| 等待网络资源下载  | render主线程ThrottlingURLLoader::OnReceiveResponse前的空闲  |
| 点击响应结束点  | NotifyFrameSwapped，UnloadOldFrame/第一个SkiaOutputSurfaceImplOnGpu::SwapBuffers  |
| 绘制  | ThreadProxy::BeginMaiFrame扣除v8执行  |
| 光栅化&合成  | 从ProxyImpl::NotifyReadyToCommitOnImpl开始到SwapBuffers结束  |
| 完成时延结束  | 最后一个SkiaOutputSurfaceImplOnGpu::SwapBuffers  |
Web网页加载流程拆解
关键Trace
点击事件
最后一个DispatchTouchEvent到组件初始化前
Web组件初始化
NWebImpl|CreateNWeb到导航流程前
导航流程
NavigationControllorImpl::LoadURLWithParams到NavigationBodyLoader::OnStartLoadingResponseBody结束
DOM&CSS解析
CSSParserImpl::parseStyleSheet和ParseHTML解析，扣除HTMLDocumentParser::RunScriptsForPausedTreeBuilder
JS编译+执行
EvaluateScript 和 v8.callFunction
等待网络资源下载
render主线程ThrottlingURLLoader::OnReceiveResponse前的空闲
点击响应结束点
NotifyFrameSwapped，UnloadOldFrame/第一个SkiaOutputSurfaceImplOnGpu::SwapBuffers
绘制
ThreadProxy::BeginMaiFrame扣除v8执行
光栅化&合成
从ProxyImpl::NotifyReadyToCommitOnImpl开始到SwapBuffers结束
完成时延结束
最后一个SkiaOutputSurfaceImplOnGpu::SwapBuffers
使用Profiler工具抓取Trace
Profiler工具分析卡顿丢帧场景的使用方式可以参考Frame分析。响应时延类问题首先确认响应起止点，确定区域位置与大致操作。
1.
2.  可以发现，后续动画已经达到最大帧率，说明无响应是图中区域内。
3.
4.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151133.38437896878734768113239948492864:50001231000000:2800:AC3E426FB8AFE9E576446E67110195A48333B4ECE8CD752947C0BF5CCE250F21.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151133.40712815713871739004585875262202:50001231000000:2800:434273ECC1906BA42BAC245F96E28082C40526A2CA73C7C4C6077D7ACD039273.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151133.47769918810242516051855805394726:50001231000000:2800:AEAE1A019F28E46FC8BBA76DA9D011781C55B0FFF70567CBBCD821668E022690.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151133.29470483459132644841750648328251:50001231000000:2800:3E99DE455D509AA9F65270D4B313A073A8D902A55E1A1CAE9E25A3142BB6D1CA.png)
经过前面的分析，应用侧发现可能是Web侧产生了大量的计算，此时需要使用Devtools工具进一步分析。
使用Devtools进行分析
Devtools调试使用请参考此链接：使用Devtools工具调试前端页面。
抓取的DevTools泳道图如下图所示，本章节将可能发生的异常区域进行分析：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151133.30250917683284635044670960030622:50001231000000:2800:1A7B358A4A48A77135CD52FFCF619E700DDF61310A3E8495D3C791C2E20F3BD0.png)
由于此页面不涉及网络交互，所以还有部分区域如网络区域等没有标记，后面也会给出示例。
常见问题分析实例
H5页面点击切换场景下，此时Web组件已经初始化，点击事件为Web内部的Event，场景过程主要发生在下图的1234的区域。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151133.61720920195105573924356488835847:50001231000000:2800:5BFB9AE5CACF2365BE42F1C2C49C8A3CF2D7FDCEF089CD5CB88BBFAF68F08ED4.png)
当点击时会执行以下流程：
按照经验大部分响应慢是存在以下原因：
本文将从组件加载区域异常、网络区域异常、动画区域异常、空白区域异常分别进行介绍。
组件加载区域异常分析
对应下图中的区域2：可以记录此段内容的加载耗时。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151133.58990661881293825982939584385982:50001231000000:2800:D6F6C369A6BF3F9DB0BA27AD867536A478A1EC914FBC3EBA67DDCE6AEC8CDCE3.png)
此处异常点通常为：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151134.88502866657133707710083490115960:50001231000000:2800:967A44288D21D5D62BA939AFE60D135614B3FB6B07A794341A85389B808708A6.png)
源码耗时如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151134.89904949920292424358591965541652:50001231000000:2800:1F0A1F7B37CBF5435541CE850180079A4130EC04FEF9B20EE45D56A4DA0BCB48.png)
如图所示，源码处会显示具体方法的耗时，此时可以发现myFun1方法采用了递归，大幅增加了CPU的运算耗时，导致了响应延时。可以将递归方法myFun1优化为循环方法myFun2，时间复杂度从O(2^n)降低到O(n)，在该场景下能显著减少耗时（经测试myFun2实际耗时在us级别，无法使用DevTools工具统计，可以使用其他方法进行函数耗时统计分析）。
网络区域异常分析
网络耗时占比过高异常通常发生在响应阶段，表现为网络请求完成后执行JavaScript或任务时阻塞线程，导致整体耗时显著增加。对应下图中的区域2：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151134.05000964402537302758745377375434:50001231000000:2800:449F4E8C64F6B06135C2D0211AEA63664303CC928F2689E379561A20EF000305.png)
动画区域异常分析
对应于下图中的区域4，如果测试的响应时间的Trace起点到终点的时间相差很大，此时动画区域会有异常。常见的异常如动画中的页面背景色为透明，动画曲线为先慢后快导致动画弹出起点时，透明色视觉上没有变化。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151134.00435071299230474009546692981128:50001231000000:2800:E3FFCE1970B1CB8B373CB8861F24C2AE96FDB22136E89E5068CE570A711DE7FF.png)
空白区域异常分析
对应下图中的区域5：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151134.16268418592806442053566056378582:50001231000000:2800:5784C7409D5B4105D25C1B686BA7E3DA3C8C5E50E1BE31323D5259E8BD0EC3C0.png)
此处的异常点通常为：
发现代码中有await delayFun(500)这种定时器延迟函数，优化方法是移除冗余延迟函数。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151134.38579605012509005945068939738916:50001231000000:2800:5CD9E42D1DA076F9960F656B484606ACB63788135D0D4404FA92D2E7F9B992AA.png)
可以看出耗时明显减少，回归正常水平。
总结
通过以上步骤，使用录屏、Trace工具和Devtools分析，可以有效定位并解决Web页面内点击响应时延类问题。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-web-completion-delay-analysis
爬取时间: 2025-05-01 08:45:37
来源: Huawei Developer
概述
Web加载完成时延是从页面请求开始到页面视口内容加载完成的耗时，建议该时长控制在900ms以内，较低的加载完成时延能让用户感知到页面加载响应及时不卡顿。本文主要介绍了Web页面的加载流程及关键Trace点、性能分析工具、加载完成时延分析方法、并总结了常见导致加载完成时延过高的原因与解决方案。
Web加载流程
Web页面加载流程包括Web组件初始化，请求对应的网页资源后解析HTML与CSS文件、执行JS脚本构建出渲染树，同时网络进程会并行下载其他资源，然后系统会根据渲染树进行布局计算，确定每个元素在页面中的大小与位置，通过光栅化将几何信息转化为像素信息最后合成送显，对应泳道图如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151134.54881095390604215326430755224686:50001231000000:2800:0FD571CE1A752A8FC83813F72947352F446D4F9D7B2634228C3DC3FF782A6B5F.png)
| 编号  | Web网页加载流程拆解  | 关键Trace  |
| --- | --- | --- |
| ①  | 点击事件  | 最后一个DispatchTouchEvent到组件初始化前  |
| ②  | Web组件初始化  | H:NWebImpl | CreateNWeb到导航流程前  |
| ③  | 导航流程  | NavigationControllorImpl::LoadURLWithParams到NavigationBodyLoader::OnStartLoadingResponseBody结束  |
| ④  | DOM&CSSOM解析  | CSSParserImpl::parseStyleSheet和ParseHTML解析，扣除HTMLDocumentParser::RunScriptsForPausedTreeBuilder  |
| ⑤  | 等待网络资源下载  | Render主线程ThrottlingURLLoader::OnReceiveResponse前的空闲  |
| ⑥  | JS编译与执行  | EvaluateScript 和 v8.callFunction  |
| ⑦  | 绘制  | ThreadProxy::BeginMaiFrame扣除v8执行  |
| ⑧  | 光栅化&合成  | 从ProxyImpl::NotifyReadyToCommitOnImpl开始到SwapBuffers结束  |
| ⑨  | 点击响应结束点  | NotifyFrameSwapped，UnloadOldFrame/第一个SkiaOutputSurfaceImplOnGpu::SwapBuffers  |
| ⑩  | 完成时延结束  | 最后一个SkiaOutputSurfaceImplOnGpu::SwapBuffers  |
编号
Web网页加载流程拆解
关键Trace
①
点击事件
最后一个DispatchTouchEvent到组件初始化前
②
Web组件初始化
H:NWebImpl | CreateNWeb到导航流程前
③
导航流程
NavigationControllorImpl::LoadURLWithParams到NavigationBodyLoader::OnStartLoadingResponseBody结束
④
DOM&CSSOM解析
CSSParserImpl::parseStyleSheet和ParseHTML解析，扣除HTMLDocumentParser::RunScriptsForPausedTreeBuilder
⑤
等待网络资源下载
Render主线程ThrottlingURLLoader::OnReceiveResponse前的空闲
⑥
JS编译与执行
EvaluateScript 和 v8.callFunction
⑦
绘制
ThreadProxy::BeginMaiFrame扣除v8执行
⑧
光栅化&合成
从ProxyImpl::NotifyReadyToCommitOnImpl开始到SwapBuffers结束
⑨
点击响应结束点
NotifyFrameSwapped，UnloadOldFrame/第一个SkiaOutputSurfaceImplOnGpu::SwapBuffers
⑩
完成时延结束
最后一个SkiaOutputSurfaceImplOnGpu::SwapBuffers
Web加载性能分析工具
DevEco Profile
DevEco Profiler是DevEco Studio提供的场景化调优工具，开发者可通过该工具来确定Web加载完成时延的大小。DevEco Profile基础使用开发者可参考DevEco Profiler工具简介，具体如何确定Web加载完成时延请参见使用Profiler确认加载完成时延。
DevTools
DevTools是一个Web前端开发调试工具，提供了在电脑上调试移动设备前端页面的能力，关于DevTools调试工具使用开发者可参考：使用DevTools工具调试前端页面。
Web加载性能分析方法
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151134.62270009570423601251223681113809:50001231000000:2800:C4FE6E7D2129A176281B479CB0448B6CA1341D14C961139B4AA1752311EEBFC1.jpg)
使用Profiler确认加载完成时延
1.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151134.27431664169319118312685502231814:50001231000000:2800:4A9BCB2544EF341417F2251FBC774FC25C6D6CE216701C6CACCB7EFB18AEAA23.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151134.73074249068543743354948248596615:50001231000000:2800:E4BC8AE30B345161C6A2A4FF5149A9B220CCA94BAA71C612521EB5A6AD91D29E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151134.53381419774481231834627854835965:50001231000000:2800:E1D7B4AD960488CEF2DFA3F9C29C01CB165F8D71D35221BA1D10B4D34686D563.png)
使用DevTools分析耗时区域
开发者可通过DevTools中的Performance选项卡录制Trace，根据录制后Trace进行分析，分析流程如下。
1.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151134.50232576192083116653189442792225:50001231000000:2800:4A82AA1B6FD7447F68FDD8DCED2442F7E710A71D7807A8A8460C81AA202E9AF5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151135.36085990995485126015052187681406:50001231000000:2800:EFBADB3A0E89AC5E3646F0D084E0A6B5772A7B1DCF6CEE9F5F0930EEC481685B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151135.57189568843958727255421029788980:50001231000000:2800:BE0DECA7FC34CA58D1EEB40B86FE53AFC32E86C5B049EC15EE32D00D0E83FF0E.png)
各阶段异常根因分析及优化方法
以下按照Web加载流程进行区域划分，并梳理了常见问题产生的阶段与对应解决方案。
DOM&CSSOM解析（分析Main泳道）
常见问题
网络资源下载（分析NetWork泳道）
常见问题
1.
2.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151135.08785444731278620875913248241343:50001231000000:2800:A6969A71ECB8725460D03A6D524E2ECADA64CE8E2A7223C78060A3CC1A180DC0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151135.98259016854894058748622894684943:50001231000000:2800:68FECBE0C2BF967B3CA4C2A0DB4FFBB11209F54686CE7EC6008C34292C783857.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151135.47023588119160999984368722033953:50001231000000:2800:A7026A90E292AB7EC8DC3DF821903D3F026EAE1AD7C6B9974DC74C436A0146E9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151135.39120774894531445925937690256486:50001231000000:2800:37746BE5E151E5B010847C6F4D88DC9E256277458ABBFFBE38CD1BAD0F159A88.png)
JS编译与执行（分析Main泳道）
常见问题
1.
2.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151135.49991186416744859579132458013855:50001231000000:2800:33204066F290842F94A7336DC883BA6005DFA9AF7BC6C92E2CA72BA427731767.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151135.48468511869940391334201672989865:50001231000000:2800:8488AAEF201DAF484DE866B4BE1C74B446C9D090424A6AA4454AC4391DCD8DE5.png)
优化实践案例
案例一
问题描述
某应用详情页面加载完成时延高于900ms，实测加载完成时延2351ms。
问题Trace
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151135.23829864761920357095701214245980:50001231000000:2800:74DB7CD568D0C5C4525B3CD413A270BA1B537FEB9B6D1B8433052A69862FF6D9.png)
加载流程分析
图中标号为页面加载流程顺序，应用侧请求到网页地址后，进入网络资源下载（对应区域①的网络泳道），此时观察到网络泳道出现大量的资源文件请求，同时页面持续白屏（观察页面截图区域），可以得出应用侧存在初始页面资源加载时网络并发过多的问题，然后可以看到请求下来的资源在主线程上执行（区域①的主要泳道），执行过程中发出网络请求请求到区域②的接口，请求过程中publishDetailv2()接口耗时较长，请求结束后执行请求的回调函数（对应主要泳道的区域③），该回调中接着请求了一个网络请求（对应网络泳道的区域④），同样可以看到有一个长时请求getPublishDetailRecommendList()，请求执行完成后执行对应的回调函数（区域⑤的主要泳道）接着触发了大量的网络请求（区域⑥与区域⑧）。
根因分析
优化方案
案例二
问题描述
某应用优惠券详情页面使用Web组件加载，实测加载完成时延为1552ms，远高于900ms。
问题Trace特点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151135.25547180760157349226904143851074:50001231000000:2800:0CF21E042E19724405C1B0A98C8179E88117649DB9D4FA39DBFE25EE1CCE8F32.png)
加载流程分析
根据Trace图可以看到，页面开始加载后请求到一个接口以及一段JS脚本，该脚本引出了大量的网络请求以及任务回调执行。屏幕持续白屏（区域①到600多ms处）等待JavaScript脚本执行，执行完成后页面进入骨架屏（区域③），此阶段有多个长排队请求，同时可以看到请求到服务器后，服务器处理时长较长（浅灰色区域）。
根因分析
优化方案
总结
本文提供了Web页面加载时延分析与优化的方法，涵盖了Web页面加载流程、性能分析的工具与方法，并通过两个案例结合分析方法进行实操，帮助开发者掌握Web页面加载性能提升的方法。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-threads-serialization-timeout-analysis
爬取时间: 2025-05-01 08:45:50
来源: Huawei Developer
概述
当前开发者在应用开发过程中涉及到多线程并发场景时，会高频使用TaskPool/Worker并发能力，其中对象/方法在跨线程传递时均会涉及到其序列化和反序列化的过程。当对象本身较大且结构复杂时，序列化/反序列化的耗时就会增加，从而影响应用运行的整体性能。开发者在分析性能问题时，无法感知系统侧是否触发序列化或者反序列化，也无法确认其具体是否执行了耗时操作。
为了帮助开发者更好的识别其代码中潜在的涉及主线程序列化/反序列化的耗时点，以及推动开发者在跨线程传递对象时改用Sendable对象的方式，方舟调优和DevEco Studio联合开发并上线了应用主线程序列化/反序列化超时检测工具。该工具集成在DevEco Profiler中，并可在开发者进行应用调优录制时同步开启。开发者可以在录制结果中的Anomaly泳道内查看到主线程序列化/反序列化超时的Tag点和相关超时信息，并通过与ArkTS Callstack泳道中当前调用栈的时间对齐，定位到序列化/反序列化耗时较长的代码，然后通过Sendable改造或者通信数据改造的方式（例如文件buffer改为文件path+偏移）进行优化，提升应用性能。
工具介绍
DevEco Studio新增主线程序列化和反序列化检测能力，同时支持配置序列化/反序列化超时阈值。对于超过阈值的序列化和反序列化操作，在泳道中给出告警提示，并可以关联该时刻的调用栈信息，更好地帮助开发者定位性能问题。
功能说明
当前DevEco Profiler工具具备的序列化/反序列化检测包含三个子功能：
实现原理
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151135.36555851899456790096943587854244:50001231000000:2800:15B83BB90A11660DB762A1B7E3B29606159EB2E7F84690C0C308ED0C4A8CB776.png)
其中超时检测部分的使能和关闭是通过方舟Profiler提供的一组CDP协议来控制（默认处于关闭状态，在使用DevEco Profiler进行录制时开启）：
表1超时检测使能和关闭协议
| 协议名称  | 传入参数  | 协议说明  |
| --- | --- | --- |
| Profiler.enableSerializationTimeoutCheck  | threshold: int  | 开启超时检测工具，并设置超时阈值（单位ms）  |
| Profiler.disableSerializationTimeoutCheck  | /  | 关闭超时检测工具  |
协议名称
传入参数
协议说明
Profiler.enableSerializationTimeoutCheck
threshold: int
开启超时检测工具，并设置超时阈值（单位ms）
Profiler.disableSerializationTimeoutCheck
/
关闭超时检测工具
当开启超时检测工具协议被调用后，方舟Profiler会在录制时实时计算每次主线程调用序列化和反序列化接口进行序列化/反序列化操作的耗时，并将该耗时与设定的超时阈值(默认为8ms)进行比较。如果该耗时超过设定检测阈值，Profiler则会生成一条超时信息，其中包含下列字段：
表2超时信息所含字段
| 字段名  | 字段名称  | 字段说明  |
| --- | --- | --- |
| tid  | 线程id  | 线程id，指示当前超时的线程  |
| task  | 操作类型  | serialization/deserialization 标记当前操作为序列化或反序列化  |
| startTime  | 开始时间  | 标记当前操作的开始时间  |
| duration  | 持续时间  | 标记本次序列化/反序列化的实际耗时  |
字段名
字段名称
字段说明
tid
线程id
线程id，指示当前超时的线程
task
操作类型
serialization/deserialization
标记当前操作为序列化或反序列化
startTime
开始时间
标记当前操作的开始时间
duration
持续时间
标记本次序列化/反序列化的实际耗时
该超时信息生成后，Profiler会将该条信息通过设置Trace接口设置到Trace中，并标记Tag为Ark，至此，一条主线程序列化/反序列化超时的Trace信息就通过方舟Profiler成功生成并记录。
使用方法
序列化/反序列化性能检测
1.
2.
3.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151136.67647268720307505931165592299922:50001231000000:2800:4764037A977E58C9B0D816F4B226152D2AFEC1DA84732E819A0DC3C0E2D28B59.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151136.68287629327925108611449336041881:50001231000000:2800:A644A7CB6C0F443BB55373A53C7B0B252887AAF857162AFCCD24A3598DC22C39.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151136.21464991014818587463762160288840:50001231000000:2800:FDD7F338FDB95504D4365CA31826E12C345D1FA4E896EC93B6D35BA59E5B4183.png)
序列化/反序列化阈值配置
1.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151136.10935656658602308425923600612594:50001231000000:2800:469F753347B78B05DC8EDBE888360ACFE41597014429E8EA9FC03972411A7F17.png)
案例分析
在应用开发过程中，序列化/反序列化通常发生在跨并发实例传输较大数据的场景，由于在此场景下，序列化/反序列化的时间开销会随着传递的数据量线性的增长，所以在传输数据量大的情况下序列化/反序列化的时间开销较大。特别当序列化/反序列化发生在应用主线程时，会影响应用整体的运行性能和流畅程度。
Sendable对象通过引用传递的方式在不同的并发实例间传递，相比于序列化效率更高，可以更高效的进行跨实例的数据交互，解决跨并发实例传递大数据和跨并发实例传递含有成员方法的示例对象。下面以图书类应用将大量书本信息跨并发实例传递，存储进数据库的场景为例，介绍通过超时检测工具分析和定位序列化耗时点的过程，以及对该场景进行Sendable改造前后序列化耗时结果的分析对比。该案例主要由下列步骤组成：
通常情况下，单个图书信息会被定义成class Book，通过组装该实例填充数据，最后将包含所有Book实例的BookDBInfo对象通过taskpool传递给子线程。
通过序列化超时检测工具检测录制后，在Anomaly泳道可以看到这个场景下的序列化耗时超出默认阈值(8ms)，达到了260ms。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151136.04323751895594188638984659420617:50001231000000:2800:6C19BFC08F187011ED61AABDD2FDEE37482DF5232B78B8DBC1801A999444A6BA.png)
通过点击下方ArkTS Callstack泳道，选取这个序列化超时发生的时间段后，可以通过下方的Callstack信息定位到此时正在执行Index.ts文件中的prepareBooksInfo方法，由上方伪代码可知该方法内调用了taskpool.execute方法，向子线程中传递对象dbInfo，触发了主线程序列化过程。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151136.35720702141293720212628340631604:50001231000000:2800:D0BF7B7D1B20707785EB822D5A231A7EBE8D2D5A657EF99AE30DB9EAF932497C.png)
为了解决该场景的序列化超时问题，将上述示例中dbInfo相关的class进行Sendable改造，将单个书本信息的类型定义为Sendable类型，并改造内部成员属性类型为Sendable类型。
优化后再次通过序列化超时检测工具检测录制，发现该场景下序列化耗时已小于默认阈值(8ms)，在Anomaly泳道中已经没有对应超时的Trace点。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151136.43417592213825328179220448664814:50001231000000:2800:FE23BF34C9D7C97EFD1649EDE879CAC910BF533CDE950B305EB6FB800C900FA1.png)
表3序列化耗时对比
| 实现方案  | 耗时情况  |
| --- | --- |
| 未使用Sendable  | 260ms  |
| 使用Sendable方式优化后  | <8ms  |
实现方案
耗时情况
未使用Sendable
260ms
使用Sendable方式优化后
<8ms
对比分析使用工具获取到的优化前后序列化耗时可以看出，跨线程传输数据量较大时，使用Sendable引用传递方式可以有效减少序列化耗时，提升应用性能。
通过实践案例可以得出结论，使用序列化超时检测工具可以有效检测出应用主线程序列化/反序列化耗时较长的情况，帮助开发者定位序列化耗时点，并结合代码层面的改造，例如Sendable改造或者通信数据改造，解决应用跨线程序列化/反序列化耗时过久的性能问题。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-analyze-memory-problem
爬取时间: 2025-05-01 08:46:03
来源: Huawei Developer
随着时代的发展，应用越来越复杂，占用的内存也在不断膨胀，而内存作为系统的稀缺资源比较有限，因此，主动减少应用内存的占用对于整个系统至关重要。当应用程序占用过多内存时，系统可能会频繁进行内存回收和重新分配，导致应用程序的性能下降，甚至出现崩溃和卡顿的情况。通过减少应用内存的占用，可以有效提高应用的性能和响应速度，节省系统资源，让设备的运行效率更高，延长设备的续航时间。开发者应该在应用开发过程中注重内存管理，积极采取措施来减少内存占用，以优化应用程序的性能和用户体验。DevEco Profiler提供了基础内存分析：Allocation分析和内存泄露分析：Snapshot分析能力
HiDumper查看内存信息
开发者可以通过以下步骤，获取到当前应用的内存信息。
1.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151136.94795582488681609485458046167714:50001231000000:2800:E6862E48242B9428E782FD876C1AF5911CCD9D88C9A672C16A9245508DB499C5.png)
一般情况下，开发者只需要关注PSS （Proportional Set Size，实际使用物理内存）Total一列的数据，即示例应用实际使用的物理内存。如下图所示，应用总共占用了26279KB的内存，主要包括ark ts heap（ArkTS堆内存）的4712KB以及native heap的13164KB。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151136.34019806078322330870463371071023:50001231000000:2800:2466280B44D5D0F8293C119E43DBB54C09BA830C244B209597E81C98B9CFA751.png)
使用onMemoryLevel监听内存变化
onMemoryLevel是HarmonyOS提供监听系统内存变化的接口，开发者可以通过onMemoryLevel监听内存变化，从而调整应用的内存。onMemoryLevel回调包括三种方式，分别为AbilityStage、UIAbility、EnvironmentCallback。
MemoryLevel分为MEMORY_LEVEL_MODERATE、MEMORY_LEVEL_LOW和MEMORY_LEVEL_CRITICAL三种。其中，MEMORY_LEVEL_MODERATE代表当前系统内存压力适中，应用可以正常运行而不会受到太大影响，MEMORY_LEVEL_LOW代表当前系统的内存已经比较低了，应用应该释放不必要的内存资源，避免造成系统卡顿，MEMORY_LEVEL_CRITICAL代表当前所剩的系统内存非常紧张，应用应该尽可能释放更多的资源，以确保系统的稳定性和性能。开发人员应该根据不同的内存级别来采取相应的措施，如释放资源、优化内存使用等，以确保应用在不同内存状态下都能正常运行。MemoryLevel具体等级定义如下所示：
| 等级  | 值  | 说明  |
| --- | --- | --- |
| MEMORY_LEVEL_MODERATE  | 0  | 系统内存适中。系统可能会开始根据LRU缓存规则杀死进程。  |
| MEMORY_LEVEL_LOW  | 1  | 系统内存比较低。此时应该去释放掉一些不必要的资源以提升系统的性能。  |
| MEMORY_LEVEL_CRITICAL  | 2  | 系统内存很低。此时应当尽可能地去释放任何不必要的资源，因为系统可能会杀掉所有缓存中的进程，并且开始杀掉应当保持运行的进程，比如后台运行的服务。  |
等级
值
说明
MEMORY_LEVEL_MODERATE
0
系统内存适中。系统可能会开始根据LRU缓存规则杀死进程。
MEMORY_LEVEL_LOW
1
系统内存比较低。此时应该去释放掉一些不必要的资源以提升系统的性能。
MEMORY_LEVEL_CRITICAL
2
系统内存很低。此时应当尽可能地去释放任何不必要的资源，因为系统可能会杀掉所有缓存中的进程，并且开始杀掉应当保持运行的进程，比如后台运行的服务。
后台已冻结的应用，AbilityStage、UIAbility、EnvironmentCallback的onMemoryLevel都不可以进行回调。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-performance-optimization
爬取时间: 2025-05-01 08:46:17
来源: Huawei Developer
本章节整理了应用开发过程中常见的一些性能优化方案，配合相关参考示例，帮助开发者解决大部分性能问题。具体ArkUI性能优化文章合集可参阅开发高性能ArkUI。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-perceived-smoothness
爬取时间: 2025-05-01 08:46:30
来源: Huawei Developer
在应用开发中，动画可以为用户界面增添生动、流畅的交互效果，提升用户对应用的好感度。然而，滥用动画也会导致应用性能下降，消耗过多的系统资源，甚至影响用户体验。关于感知流畅度请参阅提升动画感知流畅度。
视觉感知优化
应用的卡顿其实就是视觉上出现了不流畅的画面，引起了用户的注意，令其产生了一定的不适感。这也就意味着，在用户操作后，需要第一时间从视觉层面给予反馈响应，从而解决视觉动作带来的不适。
开发者可以在用户的交互动作开始时，从感知角度添加一些动画元素，比如单击效果、转场缩放、加载进度条、共享动画等，这些可以告诉用户目前状态发生了变化，APP在快速地运作着；而动画的背后是：数据的计算，布局的渲染，内容的加载等等，当新界面渲染显示完成，上述动画元素就可通过渐变消失、移出屏外等友好的方式退出视觉区域。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151136.28406796253056829995072716553649:50001231000000:2800:202D715D7258B5125DE7093F879D124CD7147171504968099A9030DDBF96FDC1.png)
转场场景动效感知流畅
HarmonyOS系统为开发者提供了丰富的转场动效库，使开发者能够轻松实现各种转场动画效果。开发者可以根据具体需求，在应用的不同场景中应用这些转场动效，以提升用户体验和界面的吸引力。需要注意的是，为了最佳的用户体验，开发者应根据界面的功能和特点，合理选择转场动效，并遵循动效的使用准则，以确保转场动效在视觉和交互上的一致性。关于转场场景的方案选型请参阅转场场景设计。
转场动画分为基础转场和高级模板化转场，有如下几类：
合理动画时长使应用感知流畅
页面的转场动画是提升用户体验的重要环节。然而，当动画时延耗时较长时，它会对用户的点击完成时延产生显著影响。动画的完成时间直接关系到用户何时能够开始与应用进行交互。动画时延影响点击完成时延的根因主要为动画时长设置过长。
常见的页面转场动画时长参数有：
使用连贯动画使应用快速响应
通过多种不同的连贯动画，让应用使用者在操作过程中能够感受到应用的快速响应。
应用识别拖动手势事件时需要设置合理的拖动距离，设置不合理的拖动距离会导致滑动不跟手、响应时延慢等问题。针对此类问题可以通过设置distance大小来解决。具体案例可以参考减小拖动识别距离。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-control-rendering-range
爬取时间: 2025-05-01 08:46:43
来源: Huawei Developer
在应用开发实践中，我们可以通过控制UI的渲染范围，从而防止阻塞UI渲染，引发界面卡顿或掉帧现象。
合理控制元素显示与隐藏
控制元素显示与隐藏是一种常见的场景，使用Visibility.None、if条件判断等都能够实现该效果。其中if条件判断控制的是组件的创建、布局阶段，visibility属性控制的是元素在布局阶段是否参与布局渲染。使用时如果使用的方式不当，将引起性能上的问题。具体案例与实验数据请参阅合理控制元素显示与隐藏。
懒加载
懒加载LazyForEach是一种延迟加载的技术，它是在需要的时候才加载数据或资源，并在每次迭代过程中创建相应的组件，而不是一次性将所有内容都加载出来。通常应用于长列表优化、网格优化、瀑布流优化等数据量较大、子组件可重复使用的场景，当用户滚动页面到相应位置时，才会触发资源的加载，以减少组件的加载时间，提高应用性能，提升用户体验。
懒加载可以通过设置cachedCount来指定缓存数量，在设置cachedCount后，除屏幕内显示的Item组件外，还会预先将屏幕可视区外指定数量的数据缓存。具体的原理与优化案例请参阅缓存列表项。
组件复用
组件复用是优化用户界面性能，提升应用流畅度的一种重要手段，通过复用已存在的组件节点而非创建新的节点，从而确保UI线程的流畅性与响应速度。组件复用针对的是自定义组件，只要发生了相同自定义组件销毁和再创建的场景，都可以使用组件复用，例如长列表优化、瀑布流优化、Swiper组件优化等场景，会出现大量重复布局的创建，使用组件复用可以大幅度降低了因频繁创建与销毁组件带来的性能损耗。组件复用的基本原理请参阅组件复用最佳实践。组件复用基于不同的布局效果和复用的诉求，可以分为以下五种类型：
|  复用类型 |  描述 |  复用思路 |
| --- | --- | --- |
|  标准型 |  复用组件之间布局完全相同 |  标准复用 |
|  有限变化型 |  复用组件之间布局有所不同，但是类型有限 |  使用reuseId或者独立成不同自定义组件 |
|  组合型 |  复用组件之间布局有不同，情况非常多，但是拥有共同的子组件 |  将复用组件改为@Builder，让内部子组件相互之间复用 |
|  全局型 |  组件可在不同的父组件中复用，并且不适合使用@Builder |  使用BuilderNode自定义复用组件池，在整个应用中自由流转 |
|  嵌套型 |  复用组件的子组件的子组件存在差异 |  采用化归思想将嵌套问题转化为上面四种标准类型来解决 |
复用类型
描述
复用思路
标准型
复用组件之间布局完全相同
标准复用
有限变化型
复用组件之间布局有所不同，但是类型有限
使用reuseId或者独立成不同自定义组件
组合型
复用组件之间布局有不同，情况非常多，但是拥有共同的子组件
将复用组件改为@Builder，让内部子组件相互之间复用
全局型
组件可在不同的父组件中复用，并且不适合使用@Builder
使用BuilderNode自定义复用组件池，在整个应用中自由流转
嵌套型
复用组件的子组件的子组件存在差异
采用化归思想将嵌套问题转化为上面四种标准类型来解决
组件复用具体的场景与方法请参阅组件复用场景与方法详解。
分帧渲染
在应用开发中，页面内列表结构复杂，每个列表项包含的组件较多，就会导致嵌套层级较深，从而引起组件负载加重，绘制耗时增长。在这种情况下，转场或者列表滑动的时候列表项就会一次性加载大量的数据，此时可以采用分帧渲染，将本来一帧内加载的数据分成多帧加载，但是分帧渲染需要开发者计算每帧中加载多少数据，操作复杂，因此在必要的情况下才推荐使用。具体的原理与优化案例请参阅高负载场景下分帧渲染。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-reduce-layout-nodes
爬取时间: 2025-05-01 08:46:56
来源: Huawei Developer
在进行页面布局开发时，应该尽量减少布局节点，避免系统绘制更多的布局组件，达到优化渲染性能、减少内存占用的目的。具体提高渲染性能的优化原理请参阅ArkUI框架执行流程。
优先使用@Builder方法代替自定义组件
由于@Builder不涉及生命周期，在自定义组件大量嵌套的场景中，更加轻量级的@Builder在性能方面更加出色。因此，当自定义组件不涉及到状态变量和自定义生命周期时，可以优先使用@Builder替换自定义组件，提升性能。具体的原理与优化案例请参阅优先使用@Builder方法代替自定义组件。
合理使用布局容器组件
在进行UI布局时，子组件会根据父组件的布局算法得到相应的排列规则，然后按照规则进行子组件位置的摆放。不同的布局容器使用的布局算法对性能带来的影响不同。开发者应该根据场景选用合适的布局，除非必须，尽量减少使用性能差的布局组件。
复杂布局提供了场景化的能力，解决一种或者多种布局场景。但是在一些场景下，不恰当的使用这些高级组件，可能带来更多的性能消耗。具体的案例与实验数据请参阅选择合适的布局组件。
精简节点数
在进行UI布局时，在布局测算阶段下，额外的节点数将导致更多的计算过程，造成性能消耗。应该移除冗余节点来精简节点数，主要有如下几种优化方式：

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-pptimized-component-drawing
爬取时间: 2025-05-01 08:47:09
来源: Huawei Developer
应用启动后页面加载和渲染的性能与FrameNode树上的节点数量以及每个节点上的属性相关。因此，为缩短页面加载和布局渲染时长，在前端使用UI组件时可以考虑以下优化方案
避免在定义组件生命周期内执行高耗时操作
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151137.41526886513970807981230316031695:50001231000000:2800:677CD6E1CE2186D02B105FA6B9B7C15282DD18DBC227F6B3C18F021A9EAE0248.png)
自定义组件生命周期如上图所示，自定义组件创建完成之后，在build函数执行之前，将先执行aboutToAppear()生命周期回调函数。此时若在该函数中执行耗时操作，将阻塞UI渲染，增加UI主线程负担。因此，应尽量避免在自定义组件的生命周期内执行高耗时操作。具体原理可以参考页面和自定义组件生命周期。具体优化案例请参阅避免在自定义组件的生命周期内执行高耗时操作。
按需注册组件属性
在使用组件开发应用UI界面时，会为每个组件设置属性，进行UI样式、行为等逻辑处理。当应用中单个组件设置了大量属性且该组件在应用中被大量使用时，单个属性的设置对应用的整体性能会产生较大影响。具体优化案例请参阅按需注册组件属性。
减少布局计算
对于组件的宽高不需要自适应的情况下，建议在UI描述时给定组件的宽高数值，当其组件外部的容器尺寸发生变化时，例如拖拽缩放等场景下，如果组件本身的宽高是固定的，理论上来讲，该组件在布局阶段不会参与Measure阶段，其节点中保存了对应的大小信息，如果组件内容较多时，由于避免了其中组件整体的测算过程，性能会带来较大的提升。具体优化案例请参阅利用布局边界减少布局计算、给定List组件宽高。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-state-refresh
爬取时间: 2025-05-01 08:47:22
来源: Huawei Developer
在声明式UI编程范式中，UI是应用程序状态的函数，应用程序状态的修改会更新相应的UI界面。ArkUI采用了MVVM模式，其中ViewModel将数据与视图绑定在一起，更新数据的时候直接更新视图。如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151137.07165017675328332599511272985915:50001231000000:2800:BC0E42A9858AA5197E339A584D281592A80560B2978910EB950456B0DBD769E6.png)
ArkUI提供了一系列装饰器实现ViewModel的能力，如@Prop、@Link、@Provide、LocalStorage等。当自定义组件内变量被装饰器装饰时变为状态变量，状态变量的改变会引起UI的渲染刷新。
避免不必要的状态变量使用
最小化状态共享范围
减少不必要的参数层层传递
当共享状态的组件间层级相差较大时，会出现状态层层传递的现象。对于状态传递过程中途经的全部组件，都需要增加入参接收该状态再将状态传递给子组件，因此应减少不必要的参数层层传递并按照状态复杂度选择装饰器。
精细化拆分复杂状态
对于AppStorage的使用，由于其作用范围最广，开发者为了方便开发容易将各种状态存入其中以达到共享的目的，这通常会造成大量的性能损失。具体的精细化拆分复杂操作案例请参阅精细化拆分复杂状态。
集中化状态修改逻辑
当多个子组件修改状态的逻辑基本相同时，建议将状态的修改集中到单个函数中，以提升逻辑的可复用性、代码的可维护性和可测试性。具体的集中化状态修改逻辑案例请参阅集中化状态修改逻辑。
使用监听和订阅精准控制组件刷新
在多个组件依赖同一个数据源并根据数据源变化刷新组件的情况下，直接关联数据源会导致每次数据源改变都刷新所有组件。为精准控制组件刷新，可以采取以下策略：

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-animation-frame
爬取时间: 2025-05-01 08:47:35
来源: Huawei Developer
动画在应用开发中扮演着重要的角色，能够提升用户体验，传达信息，引导用户操作，提升应用品质和增加视觉吸引力。而动画的性能表现也至关重要，优化可以从属性更新和布局等几个方面考虑，尽可能减少冗余刷新。通过这些优化手段的单个使用或组合使用，可以对动画帧率、应用卡顿等方面带来优化，提升性能和用户体验：
使用系统提供的动画接口
一般而言，在HarmonyOS应用开发中，动画设计实现可以通过自定义动画或系统提供的动画接口两种方式来实现。系统提供的动画接口经过精心设计和优化，能够在不同设备上提供流畅的动画效果，最大程度地减少丢帧率和卡顿现象。
使用图形变换属性变化组件
通过使用图形变换属性变化组件，而不是直接修改组件的布局属性，可以减少不必要的布局计算和重绘操作，从而降低丢帧率，提升动画的流畅度和响应速度。
合理使用animateTo
使用renderGroup缓存动效
在单一页面上存在大量应用动效的组件时，可以使用renderGroup来解决卡顿问题，从而提升动画性能。首次绘制组件时，若组件被标记为启用renderGroup状态，将对组件和其子组件进行离屏绘制，将绘制结果进行缓存。此后当需要重新绘制组件时，就会优先使用缓存而不必重新绘制，从而降低绘制负载，优化渲染性能。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-concurrency-capability
爬取时间: 2025-05-01 08:47:49
来源: Huawei Developer
应用中的并发优化就是在响应用户操作期间，尽可能地让主线程只执行UI绘制相关的任务，而将非UI的耗时任务分配给其他线程或者延迟处理。这样借助多线程的异步技术，充分利用多核处理器的能力，提高应用程序的并发处理能力，减少用户等待时间，保证用户界面的响应流畅性。
使用多线程能力
自定义组件创建完成之后，在build函数执行之前，将先执行aboutToAppear()生命周期回调函数。此时若在该函数中执行耗时操作，将阻塞UI渲染，增加UI主线程负担。对于不需要等待结果的高耗时任务，可以使用多线程处理该任务，通过并发的方式避免主线程阻塞；也可以把耗时操作改为异步并发或延后处理，保证主线程优先处理组件绘制逻辑。ArkTS提供了TaskPool与Worker两种多线程并发方案，具体两种并发方案区别对比请参阅TaskPool和Worker的对比实践。
使用异步能力
Promise和async/await提供异步并发能力，是标准的JS异步语法。异步代码会被挂起并在之后继续执行，同一时间只有一段代码执行，适用于单次I/O任务的场景开发，例如一次网络请求、一次文件读写等操作。无需另外启动线程执行。可以把耗时操作的执行从同步执行改为异步或者延后执行，比如使用setTimeOut执行耗时操作实现应用冷启动优化。
多线程间通信
对象/方法在跨线程传递时均会涉及到其序列化和反序列化的过程。当对象本身较大且结构复杂时，序列化/反序列化的耗时就会增加，从而影响应用运行的整体性能。使用异步能力Sendable对象可以实现数据在多线程间的引用传递，具体使用场景请参阅Sendable使用场景与案例分析。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-preloading-resources
爬取时间: 2025-05-01 08:48:02
来源: Huawei Developer
网络请求优化
在附带网络请求的页面跳转场景中，完成时延耗时长的绝大多数原因都是因为网络数据Http请求时间长。由于网络是从操作系统侧发起和控制的，且网络环境存在不可控性，所以我们很难在业务逻辑的代码中优化请求速度。因此应尽可能的提前发起网络请求。
Web组件的预连接、预加载、预渲染
当遇到Web页面加载慢的场景，可以使用Web组件的预连接、预加载、预渲染能力，在应用空闲时间提前进行Web引擎初始化和页面加载，提升下一页面的启动和响应速度，具体原理与案例请参阅Web组件开发性能提升指导。
预下载优化Image白块
为了减少白块的出现，开发者可以采用预下载的方式，将网络图片通过应用沙箱的方式进行提前缓存，将图片下载解码提前到组件创建之前执行，当Image组件加载时从应用沙箱中获取缓存数据。非首次请求时会判断应用沙箱里是否存在资源，如存在直接从缓存里获取，不再重复下载，减少Image加载大的网络图片时白屏或白块出现时长较长的问题，提升用户体验。具体原理与案例请参阅Image白块解决问题指导。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-improve-running-efficiency
爬取时间: 2025-05-01 08:48:15
来源: Huawei Developer
在语法使用过程中，通过优化一些影响性能的代码片段，使代码以最优的方式执行提高运行效率。以下实践是在开发过程中逐步总结出来的一些高性能的写法和建议：
变量声明
属性访问
数值计算与数据结构
减少使用嵌套export */import *的方式

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-reduce-time-consuming
爬取时间: 2025-05-01 08:48:28
来源: Huawei Developer
在应用开发实践中，有效避免主线程执行冗余与易耗时操作是至关重要的策略。此举能有效降低主线程负载，提升UI的响应速度。
避免主线程冗余操作
在软件开发中，冗余操作指的是那些不必要、重复执行且对程序功能无实质性贡献的操作。这些操作不仅会浪费计算资源，还可能降低程序的运行效率，特别是在高频调用的场景下，其负面影响更为显著。下面列举一些release版本中常见的冗余操作：
具体案例与性能实验数据请参阅常见冗余操作。
避免高频回调执行耗时操作
高频回调接口通常是指在应用程序运行过程中会被频繁触发的事件或回调函数，以下常见高频回调场景中需要避免执行耗时操作:
避免使用耗时接口

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-delayed-trigger-operation
爬取时间: 2025-05-01 08:48:41
来源: Huawei Developer
延迟加载Lazy-Import与动态加载await import
随着应用功能持续增加，应用规模不断扩大，依赖的模块文件逐渐变多，应用冷启动加载模块的时间也越来越长。
两种延时加载方案的区别具体请参阅Lazy-Import与动态加载的区别。
延迟执行资源释放操作
将资源关闭和释放操作放在setTimeout函数中执行，使其延迟到系统相对空闲的时刻进行，可以避免在程序忙碌时段占用关键资源，提升整体性能及响应能力。例如相机正常使用后，延迟执行释放相机资源的相关操作。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-scenario-performance-optimization
爬取时间: 2025-05-01 08:48:54
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-web-develop-optimization
爬取时间: 2025-05-01 08:49:09
来源: Huawei Developer
概述
ArkWeb（方舟Web）是一个Web组件平台，旨在为应用程序提供展示Web页面内容的功能，并为开发者提供丰富的能力，包括页面加载、页面交互、页面调试等功能。在这个数字化时代，页面显示的速度直接体现了应用的流畅性，影响着用户对应用的印象和体验。快速加载并展示页面不仅可以吸引用户留在应用上，还能减少他们的等待时间和不耐烦情绪，从而提升用户的满意度。
Web页面的显示过程可以被分为多个阶段，包括DNS解析、建立连接、发送请求、接收响应、解析HTML、下载资源等步骤。在这个过程中，许多因素都会对页面显示速度产生影响，比如网络延迟、服务器响应时间、页面大小、资源压缩等。为了提升Web页面显示速度，开发者可以在Web页面加载、资源下载和页面渲染等方面进行优化，以提升性能和用户体验。
本文将介绍以下常见的优化方式。
ArkWeb（方舟Web）为开发者提供了优化页面显示速度的方法。通过采取这些优化方式，开发者可以改善应用程序的性能和用户体验，使用户能够更快速、更流畅地浏览Web页面，从而提升用户满意度和留存率。
Web页面加载性能优化指导
Web页面加载流程
Web页面加载流程包括网络连接、资源下载（包括等待网络资源下载）、DOM解析、JavaScript代码编译执行、渲染等。页面加载中，比较关键的节点有网络连接、资源下载和完整的页面渲染，本文将主要对以下关键节点的耗时进行优化。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151137.20236135855167731873495056176808:50001231000000:2800:8979BA5C9B4A2299F27DCCDA3BB7E388C87C9AD50FE3AD6267242A15AABE72C2.png)
由于所有的关键点都是建立在预处理的思路上，因此如果用户实际并未打开预处理的Web页面，将会造成额外的资源消耗。各优化方法具体的效果、代价和适用场景的对比如下表所示。
|  优化方法 |  效果（优化数据仅供参考） |  适配难度 |  影响 |  适用场景 |
| --- | --- | --- | --- | --- |
|  预启动Web渲染进程 |  消除拉起Web渲染进程的耗时，约140ms。 |  低 |  额外的内存、算力。 |  高概率被使用的Web页面。 |
|  预解析 |  消除用户真正启动的Web网页域名解析的耗时，约66ms。 |  低 |  可能存在提前解析了用户未启动的Web网页域名。 |  中高概率被使用的Web页面。 |
|  预连接 |  消除用户真正启动的Web网页域名解析、网络连接耗时，约80ms。 |  低 |  可能存在提前连接了用户未启动Web网页资源。 |  中高概率被使用的Web页面。 |
|  预下载 |  消除网络GET请求下载带来的耗时及阻塞DOM解析、JavaScript执行的耗时，约641ms。 |  低 |  额外的网络连接、下载、存储资源。 |  高概率被使用的Web页面。 |
|  预渲染 |  能实现页面“秒开”效果，将页面加载时延降到最低，约486ms。 |  中 |  额外的网络连接、下载、存储和渲染消耗。 |  超高概率被使用的Web页面。 |
|  预取POST |  消除网络POST请求下载带来的耗时及阻塞DOM解析、JavaScript执行的耗时，约313ms。 |  中 |  额外的网络连接、下载、存储资源。 |  高概率被使用的Web页面。 |
|  预编译JavaScript生成字节码缓存 |  消除JavaScript编译的耗时，优化数据根据JS资源大小而定，5.76Mb资源预编译时约有2915ms收益。 |  中 |  额外的存储资源。 |  加载HTTP/HTTPS协议JavaScript的Web页面，在第一及第二次优化加载性能。 |
|  资源拦截替换的JavaScript生成字节码缓存 |  消除JavaScript编译的耗时，优化数据根据JS资源大小而定，2.4Mb资源拦截替换时约有67ms收益。 |  高 |  额外的存储资源。 |  加载自定义协议JavaScript的Web页面，在第三次及之后的时机优化加载性能。 |
|  离线资源免拦截注入 |  消除资源加载到内存的耗时，优化数据根据资源大小而定，25Mb资源注入时约有1240ms收益。 |  中 |  额外的存储资源。 |  高概率被使用的资源。 |
|  资源拦截替换加速 |  节省了转换时间，同时对ArrayBuffer格式的数据传输方式进行了优化，优化数据根据资源大小而定，10Kb资源拦截替换时约有20ms收益。 |  低 |  - |  ArrayBuffer格式的数据传输。 |
优化方法
效果（优化数据仅供参考）
适配难度
影响
适用场景
预启动Web渲染进程
消除拉起Web渲染进程的耗时，约140ms。
低
额外的内存、算力。
高概率被使用的Web页面。
预解析
消除用户真正启动的Web网页域名解析的耗时，约66ms。
低
可能存在提前解析了用户未启动的Web网页域名。
中高概率被使用的Web页面。
预连接
消除用户真正启动的Web网页域名解析、网络连接耗时，约80ms。
低
可能存在提前连接了用户未启动Web网页资源。
中高概率被使用的Web页面。
预下载
消除网络GET请求下载带来的耗时及阻塞DOM解析、JavaScript执行的耗时，约641ms。
低
额外的网络连接、下载、存储资源。
高概率被使用的Web页面。
预渲染
能实现页面“秒开”效果，将页面加载时延降到最低，约486ms。
中
额外的网络连接、下载、存储和渲染消耗。
超高概率被使用的Web页面。
预取POST
消除网络POST请求下载带来的耗时及阻塞DOM解析、JavaScript执行的耗时，约313ms。
中
额外的网络连接、下载、存储资源。
高概率被使用的Web页面。
预编译JavaScript生成字节码缓存
消除JavaScript编译的耗时，优化数据根据JS资源大小而定，5.76Mb资源预编译时约有2915ms收益。
中
额外的存储资源。
加载HTTP/HTTPS协议JavaScript的Web页面，在第一及第二次优化加载性能。
资源拦截替换的JavaScript生成字节码缓存
消除JavaScript编译的耗时，优化数据根据JS资源大小而定，2.4Mb资源拦截替换时约有67ms收益。
高
额外的存储资源。
加载自定义协议JavaScript的Web页面，在第三次及之后的时机优化加载性能。
离线资源免拦截注入
消除资源加载到内存的耗时，优化数据根据资源大小而定，25Mb资源注入时约有1240ms收益。
中
额外的存储资源。
高概率被使用的资源。
资源拦截替换加速
节省了转换时间，同时对ArrayBuffer格式的数据传输方式进行了优化，优化数据根据资源大小而定，10Kb资源拦截替换时约有20ms收益。
低
-
ArrayBuffer格式的数据传输。
预启动Web渲染进程
原理介绍
预启动Web渲染进程方案适用于Web页面启动场景，本方案需要开发者额外创建一个新的ArkWeb组件，此时该组件并不会对用户显示，但是会提前拉起渲染进程。Web渲染进程在Web组件全部销毁前会一直存在，并于应用侧全局共用，节省了后续Web组件加载时用于启动Web渲染进程的耗时。
建议开发者在Web页面启动前执行预启动Web渲染进程方案，如应用冷启动阶段或者广告阶段，如果无法在冷启动期间进行Web渲染进程预启动，建议在空闲时间预启动Web渲染进程。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151137.13932560540221602496582723326500:50001231000000:2800:F5DAFE2C275658E74977C0496E271DA34BF7A3CD82E5708A459BAB0B6B3B0E57.png)
实践案例
【不推荐用法】
点击跳转下一页，直接加载Web页面
案例中涉及网络地址访问，需配置网络权限。
```typescript
// Index.ets
@Entry
@Component
struct Index {
pageInfos: NavPathStack = new NavPathStack()
build() {
Navigation(this.pageInfos) {
Column() {
Button('加载测试页面', { stateEffect: true, type: ButtonType.Capsule })
.width('80%')
.height(40)
.margin(20)
.onClick(() => {
// 将name指定的NavDestination页面信息入栈
this.pageInfos.pushPath({ name: 'pageOne' })
})
}
}.title('NavIndex')
}
}
// Second.ets
import { webview } from '@kit.ArkWeb'
@Builder
export function PageOneBuilder() {
Second()
}
@Component
export struct Second {
webviewController: webview.WebviewController = new webview.WebviewController();
aboutToAppear(): void {
// 输出Web页面开始加载时间
console.info(`load page start time: ${Date.now()}`);
}
build() {
NavDestination() {
Row() {
Column() {
// url请替换为真实地址
Web({ src: 'https://www.example.com', controller: this.webviewController })
.height('100%')
.width('100%')
.onPageEnd((event) => {
// 输出Web页面加载完成时间
console.info(`load page end time: ${Date.now()}`);
})
}
.width('100%')
}
.height('100%')
}
}
}
```
点击“加载测试页面”按钮，页面加载完成耗时1066ms，具体如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151137.55298851769050775505486027850070:50001231000000:2800:835E5835A04625BB498BF61F9423AB71494C3C3C1D432C99EDEBA5DA435B58E0.png)
【推荐用法】
在后台创建一个ArkWeb组件来预先启动用于渲染的Web渲染进程。
```typescript
// 创建NodeController
// common.ets
import { UIContext } from '@kit.ArkUI';
import { webview } from '@kit.ArkWeb';
import { NodeController, BuilderNode, Size, FrameNode } from '@kit.ArkUI';
// @Builder中为动态组件的具体组件内容
// Data为入参封装类
class Data {
url: string = 'https://www.example.com';
controller: WebviewController = new webview.WebviewController();
}
@Builder
function webBuilder(data: Data) {
Column() {
Web({ src: data.url, controller: data.controller })
.domStorageAccess(true)
.zoomAccess(true)
.fileAccess(true)
.mixedMode(MixedMode.All)
.width('100%')
.height('100%')
.onPageEnd((event) => {
// 输出Web页面加载完成时间
console.info(`load page end time: ${Date.now()}`);
})
}
}
let wrap = wrapBuilder<Data[]>(webBuilder);
// 用于控制和反馈对应的NodeContainer上的节点的行为，需要与NodeContainer一起使用
export class MyNodeController extends NodeController {
private rootnode: BuilderNode<Data[]> | null = null;
private root: FrameNode | null = null;
private rootWebviewController: webview.WebviewController | null = null;
// 必须要重写的方法，用于构建节点数、返回节点挂载在对应NodeContainer中
// 在对应NodeContainer创建的时候调用、或者通过rebuild方法调用刷新
makeNode(uiContext: UIContext): FrameNode | null {
console.info(' uicontext is undefined : ' + (uiContext === undefined));
if (this.rootnode != null) {
const parent = this.rootnode.getFrameNode()?.getParent();
if (parent) {
console.info(JSON.stringify(parent.getInspectorInfo()));
parent.removeChild(this.rootnode.getFrameNode());
this.root = null;
}
this.root = new FrameNode(uiContext);
this.root.appendChild(this.rootnode.getFrameNode());
// 返回FrameNode节点
return this.root;
}
// 返回null控制动态组件脱离绑定节点
return null;
}
// 当布局大小发生变化时进行回调
aboutToResize(size: Size) {
console.info('aboutToResize width : ' + size.width + ' height : ' + size.height);
}
// 当controller对应的NodeContainer在Appear的时候进行回调
aboutToAppear() {
console.info('aboutToAppear');
}
// 当controller对应的NodeContainer在Disappear的时候进行回调
aboutToDisappear() {
console.info('aboutToDisappear');
}
// 此函数为自定义函数，可作为初始化函数使用
// 通过UIContext初始化BuilderNode，再通过BuilderNode中的build接口初始化@Builder中的内容
initWeb(url: string, uiContext: UIContext, control: WebviewController) {
if (this.rootnode != null) {
return;
}
// 绑定预创建的WebviewController
this.rootWebviewController = control;
// 创建节点，需要uiContext
this.rootnode = new BuilderNode(uiContext);
// 创建动态Web组件
this.rootnode.build(wrap, { url: url, controller: control });
}
// 此函数为自定义函数，可作为初始化函数使用
loadUrl(url: string) {
if (this.rootWebviewController !== null) {
// 复用预创建组件，重新加载url
this.rootWebviewController.loadUrl(url);
}
}
}
// 创建Map保存所需要的NodeController
let NodeMap: Map<string, MyNodeController | undefined> = new Map();
// 创建Map保存所需要的WebViewController
let controllerMap: Map<string, WebviewController | undefined> = new Map();
// 初始化需要UIContext 需在Ability获取
export const createNWeb = (url: string, uiContext: UIContext) => {
// 创建NodeController
let baseNode = new MyNodeController();
let controller = new webview.WebviewController();
// 初始化自定义web组件
baseNode.initWeb(url, uiContext, controller);
controllerMap.set(url, controller);
NodeMap.set(url, baseNode);
};
// 自定义获取NodeController接口
export const getNWeb = (url: string): MyNodeController | undefined => {
// 加载新的Url时，建议复用预创建的Web组件
if (!NodeMap.get(url) && NodeMap.get('about://blank')) {
// 获取预创建的Web组件
let webNode = NodeMap.get('about://blank') as MyNodeController;
// 重新加载url
webNode.loadUrl(url);
return webNode;
}
return NodeMap.get(url);
};
```
1.  首页：
点击“加载测试页面”按钮，页面加载完成耗时927ms，具体如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151137.55027892323107179662130674547554:50001231000000:2800:C6C9B2B39F8D6F93637D9C4C90DBE988F28FC6762D87D8E354623A3EF01A505A.png)
开发者可以在后续页面操作中选择是否复用该ArkWeb组件。
总结
|  下一页加载方式 |  耗时(局限不同设备和场景，数据仅供参考) |  说明 |
| --- | --- | --- |
|  直接加载Web页面 |  1066ms |  在页面加载时才开始拉起渲染进程，增加加载时间 |
|  使用预启动Web渲染进程方案 |  927ms |  在闲时提前拉起渲染进程，优化了Web渲染进程启动时间 |
下一页加载方式
耗时(局限不同设备和场景，数据仅供参考)
说明
直接加载Web页面
1066ms
在页面加载时才开始拉起渲染进程，增加加载时间
使用预启动Web渲染进程方案
927ms
在闲时提前拉起渲染进程，优化了Web渲染进程启动时间
预解析和预连接优化
原理介绍
如下图所示，在应用启动和UIAbility的onCreate生命周期后，Web组件才能进行初始化和运行。在ArkWeb组件运行阶段，会经过onAppear、load、onPageBegin、onPageEnd步骤。预解析、预连接优化适用于Web页面启动和跳转场景，例如，应用启动时需要加载Web首页。当开发者已经创建一个ArkWeb组件的实例后，可以选择不同时机对当前ArkWeb组件设置URL并进行预解析、预连接：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151137.19263180048686119956972903519927:50001231000000:2800:39BC257E76849BDE0CF959540E23524FD8941DE72E45D576991ED28464BDC2CA.png)
在设置预连接进行优化时，需要注意：
实践案例
案例一：如果要提前对应用的首页进行操作，可以通过initializeBrowserEngine()来提前初始化ArkWeb组件的内核，然后在初始化内核后调用prepareForPageLoad()对即将要加载的页面进行预连接。在prepareForPageLoad中，指定第二个参数为true，代表要进行预连接，如果为false，该接口只会对网址进行DNS预解析。具体代码如下所示。
prepareForPageLoad预连接和预解析只和host相关，URL带参数的情况下也能进行预连接、预解析。
案例二：如果要提前对当前页面的Web页面进行连接，可以在Web组件的onAppear方法中对要加载的页面进行预连接，具体代码如下所示。
```typescript
import { webview } from '@kit.ArkWeb';
@Entry
@Component
struct WebComponent {
webviewController: webview.WebviewController = new webview.WebviewController();
build() {
Column() {
Button('loadData')
.onClick(() => {
if (this.webviewController.accessBackward()) {
this.webviewController.backward();
}
})
Web({ src: 'https://www.example.com/cn/', controller: this.webviewController})
.onAppear(() => {
// 指定第二个参数为true，代表要进行预连接，如果为false该接口只会对网址进行dns预解析
// 第三个参数为要预连接socket的个数。最多允许6个。
webview.WebviewController.prepareForPageLoad('https://www.example.com/cn/', true, 2);
})
}
}
}
```
案例三：当前页面完成显示后，要提前对下一个即将要显示的页进行连接，可以在onPageEnd ()中对即将要加载的页面进行预连接。
```typescript
import { webview } from '@kit.ArkWeb';
@Entry
@Component
struct WebComponent {
webviewController: webview.WebviewController = new webview.WebviewController();
build() {
Column() {
Web({ src: 'https://www.example.com/', controller: this.webviewController})
.onPageEnd(() => {
// 预连接https://www.example1.com/。
webview.WebviewController.prepareForPageLoad('https://www.example.com/', true, 120);
})
}
}
}
```
预下载优化
原理介绍
如下图所示，ArkWeb组件运行包含onAppear、load、onPageBegin、onPageEnd，开发者可以在onPageEnd设置下一步可能访问的URL，提前下载页面所需的资源。这种方式适用于Web页面启动和跳转场景，例如，在引导流程完成后，提前预下载需要跳转的页面。当开发者已经创建一个ArkWeb组件的实例后，可以在当前页面加载完成后，在当前ArkWeb组件设置URL并进行预下载。本方案能消除资源下载耗时以及资源下载引发的页面DOM解析，JS代码编译执行的阻塞耗时，预估收益可在数百毫秒(依赖当前网络环境)。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151138.63849953825677918762688288683272:50001231000000:2800:06860B0EF32DDAE507A6E722761064B371ABAD775FB086CCF4D57AF308D4364C.png)
实践案例
如下示例所示，在onPageEnd阶段，调用prefetchPage方法，即可提前下载页面所需的资源，包括主资源子资源，但不会执行网页JavaScript代码或呈现网页，以加快加载速度。
```typescript
import { webview } from '@kit.ArkWeb';
@Entry
@Component
struct WebComponent {
webviewController: webview.WebviewController = new webview.WebviewController();
build() {
Column() {
Web({ src: 'https://www.example.com/', controller: this.webviewController})
.onPageEnd(() => {
// 预加载https://www.iana.org/help/example-domains。
this.webviewController.prefetchPage('https://www.iana.org/help/example-domains');
})
}
}
}
```
prefetchPage会对下载的资源进行缓存，缓存的时效为5分钟。
预渲染优化
原理介绍
预渲染优化适用于Web页面启动和跳转场景，例如，进入首页后，跳转到其他子页。与预连接、预下载不同的是，预渲染需要开发者额外创建一个新的ArkWeb组件，并在后台对其进行预渲染，此时该组件并不会立刻挂载到组件树上，即不会对用户呈现(组件状态为Hidden和InActive)，开发者可以在后续使用中按需动态挂载。
具体原理如下图所示，首先需要定义一个自定义组件封装ArkWeb组件，该ArkWeb组件被离线创建，被包含在一个无状态的节点NodeContainer中，并与相应的NodeController绑定。该ArkWeb组件在后台完成预渲染后，在需要展示该ArkWeb组件时，再通过NodeController将其挂载到ViewTree的NodeContainer中，即通过NodeController绑定到对应的NodeContainer组件。预渲染通用实现的步骤如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151138.11918007424685362484089385579757:50001231000000:2800:74DE5ED9B7191BEBD523C6025666FDD686C7DA68599361EB2BF15C2B316AF54D.png)
预渲染相比于预下载、预连接方案，会消耗更多的内存、算力，仅建议针对高频页面使用，单应用后台创建的ArkWeb组件要求小于200个。
另外，为了方便实现Web组件预渲染，开发者可以引用三方库nodepool。nodepool提供了全局自定义组件复用的能力，能够更高效、更简单的实现Web组件预渲染。
实践案例
```typescript
// 创建NodeController
// common.ets
import { UIContext } from '@kit.ArkUI';
import { webview } from '@kit.ArkWeb';
import { NodeController, BuilderNode, Size, FrameNode }  from '@kit.ArkUI';
// @Builder中为动态组件的具体组件内容
// Data为入参封装类
class Data{
url: string = 'https://www.example.com';
controller: WebviewController = new webview.WebviewController();
}
@Builder
function WebBuilder(data:Data) {
Column() {
Web({ src: data.url, controller: data.controller })
.domStorageAccess(true)
.zoomAccess(true)
.fileAccess(true)
.mixedMode(MixedMode.All)
.width('100%')
.height('100%')
.onPageBegin(() => {
data.controller.onActive();
})
}
}
let wrap = wrapBuilder<Data[]>(WebBuilder);
// 用于控制和反馈对应的NodeContainer上的节点的行为，需要与NodeContainer一起使用
export class myNodeController extends NodeController {
private rootnode: BuilderNode<Data[]> | null = null;
private root: FrameNode | null = null;
// 必须要重写的方法，用于构建节点数、返回节点挂载在对应NodeContainer中
// 在对应NodeContainer创建的时候调用、或者通过rebuild方法调用刷新
makeNode(uiContext: UIContext): FrameNode | null {
console.log(' uicontext is undefined : '+ (uiContext === undefined));
if (this.rootnode != null) {
const parent = this.rootnode.getFrameNode()?.getParent();
if (parent) {
console.info(JSON.stringify(parent.getInspectorInfo()));
parent.removeChild(this.rootnode.getFrameNode());
this.root = null;
}
this.root = new FrameNode(uiContext);
this.root.appendChild(this.rootnode.getFrameNode());
// 返回FrameNode节点
return this.root;
}
// 返回null控制动态组件脱离绑定节点
return null;
}
// 当布局大小发生变化时进行回调
aboutToResize(size: Size) {
console.log('aboutToResize width : ' + size.width  +  ' height : ' + size.height )
}
// 当controller对应的NodeContainer在Appear的时候进行回调
aboutToAppear() {
console.log('aboutToAppear')
}
// 当controller对应的NodeContainer在Disappear的时候进行回调
aboutToDisappear() {
console.log('aboutToDisappear')
}
// 此函数为自定义函数，可作为初始化函数使用
// 通过UIContext初始化BuilderNode，再通过BuilderNode中的build接口初始化@Builder中的内容
initWeb(url:string, uiContext:UIContext, control:WebviewController) {
if(this.rootnode != null)
{
return;
}
// 创建节点，需要uiContext
this.rootnode = new BuilderNode(uiContext)
// 创建动态Web组件
this.rootnode.build(wrap, { url:url, controller:control })
}
}
// 创建Map保存所需要的NodeController
let NodeMap:Map<string, myNodeController | undefined> = new Map();
// 创建Map保存所需要的WebViewController
let controllerMap:Map<string, WebviewController | undefined> = new Map();
// 初始化需要UIContext 需在Ability获取
export const createNWeb = (url: string, uiContext: UIContext) => {
// 创建NodeController
let baseNode = new myNodeController();
let controller = new webview.WebviewController() ;
// 初始化自定义web组件
baseNode.initWeb(url, uiContext, controller);
controllerMap.set(url, controller)
NodeMap.set(url, baseNode);
}
// 自定义获取NodeController接口
export const getNWeb = (url : string) : myNodeController | undefined => {
return NodeMap.get(url);
}
```
```typescript
// 使用NodeController的Page页
// Index.ets
import {createNWeb, getNWeb} from './common';
@Entry
@Component
struct Index {
build() {
Row() {
Column() {
// NodeContainer用于与NodeController节点绑定，rebuild会触发makeNode
// Page页通过NodeContainer接口绑定NodeController，实现动态组件页面显示
NodeContainer(getNWeb('https://www.example.com'))
.height('90%')
.width('100%')
}
.width('100%')
}
.height('100%')
}
}
```
预取POST请求优化
原理介绍
预取POST请求适用于Web页面启动和跳转场景，当即将加载的Web页面中存在POST请求且POST请求耗时较长时，会导致页面加载时间增加，可以选择不同时机对POST请求进行预获取，消除等待POST请求数据下载完成的耗时，具体有以下两种场景可供参考：
实践案例
案例一：加载包含POST请求的首页。
预取POST属于异步行为，不会影响首页加载时间。
【不推荐用法】
当首页中包含POST请求，且POST请求耗时较长时，不推荐直接加载Web页面。
【推荐用法】
通过预取POST加载包含POST请求的首页，具体步骤如下：
1.
2.
3.
案例二：加载包含POST请求的下一页。
【不推荐用法】
当即将加载的Web页面中包含POST请求，且POST请求耗时较长时，不推荐直接加载Web页面。
```typescript
// xxx.ets
import { webview } from '@kit.ArkWeb';
@Entry
@Component
struct WebComponent {
webviewController: webview.WebviewController = new webview.WebviewController();
build() {
Column() {
// 在适当的时机加载业务用Web组件，本例以Button点击触发为例
Button('加载页面')
.onClick(() => {
// url请替换为真实地址
this.controller.loadUrl('https://www.example1.com/');
})
Web({ src: 'https://www.example.com/', controller: this.webviewController })
}
}
}
```
【推荐用法】
通过预取POST加载包含POST请求的下一个跳转页面。
1.
2.
预编译JavaScript生成字节码缓存（Code Cache）
原理介绍
预编译JavaScript生成字节码缓存适用于在页面加载之前提前将即将使用到的JavaScript文件编译成字节码并缓存到本地，在页面首次加载时节省编译时间。
开发者需要创建一个无需渲染的离线Web组件，用于进行预编译，在预编译结束后使用其他Web组件加载对应的业务网页。
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/js-code-cache-by-precompile-check规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
实践案例
案例一：在未使用预编译JavaScript前提下，启动加载Web页面
```typescript
import { webview } from '@kit.ArkWeb';
import { hiTraceMeter } from '@kit.PerformanceAnalysisKit';
@Entry
@Component
struct Index {
controller: webview.WebviewController = new webview.WebviewController();
build() {
Column() {
// 在适当的时机加载业务用Web组件，本例以Button点击触发为例
Button('加载页面')
.onClick(() => {
// 性能打点
hiTraceMeter.startTrace('unPrecompileJavaScript', 1);
// url请替换为真实地址
this.controller.loadUrl('https://www.example.com/b.html');
})
Web({ src: 'https://www.example.com/a.html', controller: this.controller })
.fileAccess(true)
.onPageBegin((event) => {
console.log(`load page begin: ${event?.url}`);
})
.onPageEnd((event) => {
// 性能打点
hiTraceMeter.finishTrace('unPrecompileJavaScript', 1);
console.log(`load page end: ${event?.url}`);
})
}
}
}
```
点击“加载页面”按钮，性能打点数据如下，getMessageData进程中的Duration为加载页面开始到结束的耗时：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151138.70488546955253362351860491538328:50001231000000:2800:5DC38E86B9A00BD6E058E2BF74148A45BD710808048A2A46D04515503594B8EA.png)
JavaScript的编译耗时受JavaScript文件大小和逻辑复杂度影响，此示例中测试结果为极限场景下，JavaScript文件大小约5.76Mb，共约5.3万行代码编译的耗时
案例二：使用预编译JavaScript生成字节码缓存，具体步骤如下：
1.
2.  点击“加载页面”按钮，性能打点数据如下，getMessageData进程中的Duration为加载页面开始到结束的耗时： 当需要更新本地已经生成的编译字节码时，修改cacheOptions参数中的responseHeaders中的E-Tag或Last-Modified响应头对应的值，再次调用接口即可。
```typescript
Web({ src: 'https://www.example.com/a.html', controller: this.controller })
.onControllerAttached(async () => {
// 读取配置，进行预编译
for (const config of this.configs) {
let content = await getContext().resourceManager.getRawFileContentSync(config.localPath);
try {
this.controller.precompileJavaScript(config.url, content, config.options)
.then((errCode: number) => {
console.log('precompile successfully!' );
}).catch((errCode: number) => {
console.error('precompile failed.' + errCode);
})
} catch (err) {
console.error('precompile failed!.' + err.code + err.message);
}
}
})
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151138.74875864413620457729938180715426:50001231000000:2800:3A48DE460299AA3BEB4DF785A32A1FC52810458035D759E9D37235F62F43CECF.png)
总结
|  页面加载方式 |  耗时(局限不同设备和场景，数据仅供参考) |  说明 |
| --- | --- | --- |
|  直接加载Web页面 |  3183ms |  在触发页面加载时才进行JavaScript编译，增加加载时间 |
|  预编译JavaScript生成字节码缓存 |  268ms |  加载页面前完成预编译JavaScript，节省了跳转页面首次加载的编译时间 |
页面加载方式
耗时(局限不同设备和场景，数据仅供参考)
说明
直接加载Web页面
3183ms
在触发页面加载时才进行JavaScript编译，增加加载时间
预编译JavaScript生成字节码缓存
268ms
加载页面前完成预编译JavaScript，节省了跳转页面首次加载的编译时间
资源拦截替换的JavaScript生成字节码缓存（Code Cache）
原理介绍
资源拦截替换的JavaScript生成字节码缓存适用于在页面加载时存在需要加载网络JavaScript文件并可以进行拦截替换的场景，支持其生成字节码缓存到本地，在页面非首次加载时节省编译时间。
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/js-code-cache-by-interception-check规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151138.19505652191648606389997490486258:50001231000000:2800:1117110779B2779CB3D90EBEA9016173396727FA2C32D42665BD3396D8388DAC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151138.60182792673548677247716933491085:50001231000000:2800:69B9FB5AB96CB030FAA651988EA4BC9A1C64EFCE029E06D7B9C91FB4E1E25587.png)
Web组件默认支持HTTP协议的JavaScript生成字节码缓存，也支持自定义协议的JavaScript生成字节码缓存，具体步骤如下：
ResponseData为JavaScript内容，ResponseDataID用于区分JavaScript内容是否发生变更。若JavaScript内容变更，ResponseDataID需要一起变更。
实践案例
案例一：拦截替换HTTP协议的JavaScript文件生成字节码缓存。
【不推荐用法】
不设置ResponseDataID，直接加载Web页面。
1.
2.
打开应用后关闭，重复两次后查看第三次页面加载耗时，性能打点数据如下，getMessageData进程中的Duration为页面加载开始到结束的耗时：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151138.39604563653239371390764159358618:50001231000000:2800:1964EE54F163C83F4AEDE727314CB40D5EB743EE54ABA31D3B264F84A72812B2.png)
【推荐用法】
在进行资源拦截替换时，请求头中设置ResponseData和ResponseDataID
打开应用后关闭，重复两次后查看第三次页面加载耗时，性能打点数据如下，getMessageData进程中的Duration为页面加载开始到结束的耗时：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151139.62571604779098857379906459255599:50001231000000:2800:1E34418E7EB41AFACBF83C5571CE8AE9739C92A56C8EAA45E3DADF2F1C674B0E.png)
案例二：调用ArkTS接口，实现自定义协议的JavaScript生成字节码缓存 webview.WebviewController.customizeSchemes(schemes: Array): void，具体步骤如下：
1.
2.  不得与Web内核内置协议相同。
3.  若JavaScript内容变更，ResponseDataID需要一起变更。
案例三：调用Native接口，实现自定义协议的JavaScript生成字节码缓存 int32_t OH_ArkWeb_RegisterCustomSchemes(const char * scheme, int32_t option)，通过网络拦截接口对Web组件发出的请求进行拦截，Demo工程构建请参考拦截Web组件发起的网络请求，具体步骤如下：
1.
2.
3.  性能打点数据如下，getMessageData进程中的Avg Wall Duration为两次加载页面开始到结束的平均耗时：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151139.98018186481345678208275232973751:50001231000000:2800:F9E55E91F2065BCCC10D30965B0B3C9985CD1AC20F98790086ED76CE0C3FDFC4.png)
总结（以拦截替换HTTP协议的JavaScript生成字节码缓存场景性能数据举例）
构造2.4Mb大小的JavaScript文件进行资源拦截替换，多次测试结果取平均耗时，具体数据如下：
|  资源拦截替换方式 |  耗时(局限不同设备和场景，数据仅供参考) |  说明 |
| --- | --- | --- |
|  资源拦截替换中不设置ResponseDataID |  1469.7ms |  每次页面加载时，都进行JavaScript资源编译缓存，增加加载时间 |
|  资源拦截替换中设置ResponseDataID |  1402.9ms |  在页面加载时，将字节码缓存至本地并设置ResponseDataID，防止后续继续进行重复资源的缓存操作，节省了页面非首次加载时间 |
资源拦截替换方式
耗时(局限不同设备和场景，数据仅供参考)
说明
资源拦截替换中不设置ResponseDataID
1469.7ms
每次页面加载时，都进行JavaScript资源编译缓存，增加加载时间
资源拦截替换中设置ResponseDataID
1402.9ms
在页面加载时，将字节码缓存至本地并设置ResponseDataID，防止后续继续进行重复资源的缓存操作，节省了页面非首次加载时间
离线资源免拦截注入
原理介绍
在页面加载之前，离线资源免拦截注入会将需要使用的图片、样式表和脚本资源注入到内存缓存中，节省页面首次加载时的网络请求时间。
实践案例
案例一：直接加载Web页面
```typescript
import { webview } from '@kit.ArkWeb';
import { hiTraceMeter } from '@kit.PerformanceAnalysisKit';
@Entry
@Component
struct Index {
controller: webview.WebviewController = new webview.WebviewController();
build() {
Column() {
// 在适当的时机加载业务用Web组件，本例以Button点击触发为例
Button('加载页面')
.onClick(() => {
// 性能打点
hiTraceMeter.startTrace('getMessageData', 1);
this.controller.loadUrl('https://www.example.com/b.html');
})
Web({ src: 'https://www.example.com/a.html', controller: this.controller })
.fileAccess(true)
.onPageEnd(() => {
// 性能打点
hiTraceMeter.finishTrace('getMessageData', 1);
})
}
}
}
```
性能打点数据如下，getMessageData进程中的Duration为加载页面开始到结束的耗时：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151139.31899777682718028525226473221562:50001231000000:2800:24B565B01063CB97E782B9796B9E3CE0209EEFA3B3821AAD9852DCF5DDAE6B52.png)
案例二：使用资源免拦截注入加载Web页面，请参考以下步骤：
1.
2.  性能打点数据如下，getMessageData进程中的Duration为加载页面开始到结束的耗时：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151139.04549150326118350859119814604107:50001231000000:2800:9C58A9B81954A6F7829A377EDA42108A9893D16D3AF20AD2CF5CFC8379D57974.png)
总结
|  页面加载方式 |  耗时(局限不同设备和场景，数据仅供参考) |  说明 |
| --- | --- | --- |
|  直接加载Web页面 |  1312ms |  在触发页面加载时才发起资源请求，增加页面加载时间 |
|  使用离线资源免拦截注入加载Web页面 |  74ms |  将资源预置在内存中，节省了网络请求时间 |
页面加载方式
耗时(局限不同设备和场景，数据仅供参考)
说明
直接加载Web页面
1312ms
在触发页面加载时才发起资源请求，增加页面加载时间
使用离线资源免拦截注入加载Web页面
74ms
将资源预置在内存中，节省了网络请求时间
资源拦截替换加速
原理介绍
资源拦截替换加速在原本的资源拦截替换接口基础上新增支持了ArrayBuffer格式的入参，开发者无需在应用侧进行ArrayBuffer到String格式的转换，可直接使用ArrayBuffer格式的数据进行拦截替换。
本方案与原本的资源拦截替换接口在使用上没有任何区别，开发者仅需在调用WebResourceResponse.setResponseData()接口时传入ArrayBuffer格式的数据即可。
实践案例
案例一：使用字符串格式的数据做拦截替换
资源替换耗时如图所示，getMessageData ... someFunction took后的时间页面加载资源的耗时：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151139.47325287270404824150442422387689:50001231000000:2800:140ED02E2BAB11AF9F88A27E991351E1D0F9E1972457FF7C99AC5861B3922B48.png)
案例二：使用ArrayBuffer格式的数据做拦截替换
资源替换耗时如图所示，getMessageData william someFunction took后的时间页面加载资源的耗时：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151139.27247423886582886911099784407859:50001231000000:2800:8494B4AC44AAA732CBB61D74F25BED9A55E360B9F5D6E95DFEC6EED291003B1E.png)
总结
|  页面加载方式 |  耗时(局限不同设备和场景，数据仅供参考) |  说明 |
| --- | --- | --- |
|  使用string格式的数据做拦截替换 |  34ms |  Web组件内部数据传输仍需要转换为ArrayBuffer，增加数据处理步骤，增加启动耗时 |
|  使用ArrayBuffer格式的数据做拦截替换 |  13ms |  接口直接支持ArrayBuffer格式，节省了转换时间，同时对ArrayBuffer格式的数据传输方式进行了优化，进一步减少耗时 |
页面加载方式
耗时(局限不同设备和场景，数据仅供参考)
说明
使用string格式的数据做拦截替换
34ms
Web组件内部数据传输仍需要转换为ArrayBuffer，增加数据处理步骤，增加启动耗时
使用ArrayBuffer格式的数据做拦截替换
13ms
接口直接支持ArrayBuffer格式，节省了转换时间，同时对ArrayBuffer格式的数据传输方式进行了优化，进一步减少耗时
JSBridge
JSBridge优化解决方案
适用场景
应用使用ArkTS、C++语言混合开发，或本身应用架构较贴近于小程序架构，自带C++侧环境， 推荐使用ArkWeb在Native侧提供的ArkWeb_ControllerAPI、ArkWeb_ComponentAPI实现JSBridge功能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151139.94480257729835334569534965942012:50001231000000:2800:4667E2BE8BB43C31547AD09743A655F56BEB827F8B8D0086AA9FAC2E6739E3BB.png)
上图为具有普适性的小程序一般架构，其中逻辑层需要应用自带JavaScript运行时，本身已存在C++环境，通过Native接口可直接在C++环境中完成与视图层（ArkWeb作为渲染器）的通信，无需再返回ArkTS环境调用JSBridge相关接口。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151139.09957826188561402019507148788198:50001231000000:2800:7F240F2A3643B8E862D92ACCD31907CD98DF84E0E6262FB75CA22F0E4F74CAB7.png)
Native JSBridge方案可以解决ArkTS环境的冗余切换，同时允许回调在非UI线程上报，避免造成UI阻塞。
实践案例
案例一：使用ArkTS接口实现JSBridge通信。
应用侧代码：
```typescript
import { webview } from '@kit.ArkWeb';
@Entry
@Component
struct WebComponent {
webviewController: webview.WebviewController = new webview.WebviewController();
aboutToAppear() {
// 配置Web开启调试模式
webview.WebviewController.setWebDebuggingAccess(true);
}
build() {
Column() {
Button('runJavaScript')
.onClick(() => {
console.info('现在时间是:' + new Date().getTime());
// 前端页面函数无参时，将param删除。
this.webviewController.runJavaScript('htmlTest(param)');
})
Button('runJavaScriptCodePassed')
.onClick(() => {
// 传递runJavaScript侧代码方法。
this.webviewController.runJavaScript(`function changeColor(){document.getElementById('text').style.color = 'red'}`);
})
Web({ src: $rawfile('index.html'), controller: this.webviewController })
}
}
}
```
前端页面代码：
点击runJavaScript按钮后触发h5页面htmlTest方法，使得页面内容变更为当前时间戳，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151139.71480545333103522993885470800983:50001231000000:2800:F18AE102A5ABF36503FC803D7BE7B6ECEA560E92B23CBFD21C86F6C1A5880CE7.png)
经过多轮测试，可以得出从点击ArkTS侧的Button到触发H5侧的runJSRetStr方法，耗时约7ms~9ms。
案例二：使用NDK接口实现JSBridge通信。
应用侧代码：
```typescript
import testNapi from 'libentry.so';
import { webview } from '@kit.ArkWeb';
class testObj {
constructor() {
}
test(): string {
console.log('ArkUI Web Component');
return "ArkUI Web Component";
}
toString(): void {
console.log('Web Component toString');
}
}
@Entry
@Component
struct Index {
webTag: string = 'ArkWeb1';
controller: webview.WebviewController = new webview.WebviewController(this.webTag);
@State testObjtest: testObj = new testObj();
aboutToAppear() {
console.info("aboutToAppear");
//初始化web ndk
testNapi.nativeWebInit(this.webTag);
}
build() {
Column() {
Row() {
Button('runJS hello')
.fontSize(12)
.onClick(() => {
console.log('start:---->'+new Date().getTime());
testNapi.runJavaScript(this.webTag, "runJSRetStr(\"" + "hello" + "\")");
})
}.height('20%')
Row() {
Web({ src: $rawfile('runJS.html'), controller: this.controller })
.javaScriptAccess(true)
.fileAccess(true)
.onControllerAttached(() => {
console.error("ndk onControllerAttached webId: " + this.controller.getWebId());
})
}.height('80%')
}
}
}
```
hello.cpp作为应用C++侧业务逻辑代码：
Native侧业务代码entry/src/main/cpp/jsbridge_object.h、entry/src/main/cpp/jsbridge_object.cpp详见应用侧与前端页面的相互调用(C/C++)。
runJS.html作为应用前端页面：
点击runJS hello按钮后触发h5页面runJSRetStr方法，使得页面内容变更为当前时间戳。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151139.16382365947967027684221214461252:50001231000000:2800:D0AEC61E80B489AC2BD514DADD4E388367A47353EBCE6854AFD539A0062718DA.png)
经过多轮测试，可以得出从点击ArkTS侧的Button到触发H5侧的runJSRetStr方法，耗时约2ms~6ms。
总结
|  通信方式 |  耗时(局限不同设备和场景，数据仅供参考) |  说明 |
| --- | --- | --- |
|  ArkWeb实现与前端页面通信 |  7ms~9ms |  ArkTS环境冗余切换,耗时较长 |
|  ArkWeb、c++实现与前端页面通信 |  2ms~6ms |  避免ArkTS环境冗余切换，耗时短 |
通信方式
耗时(局限不同设备和场景，数据仅供参考)
说明
ArkWeb实现与前端页面通信
7ms~9ms
ArkTS环境冗余切换,耗时较长
ArkWeb、c++实现与前端页面通信
2ms~6ms
避免ArkTS环境冗余切换，耗时短
JSBridge优化方案适用于ArkWeb应用侧与前端网页通信场景，开发者可根据应用架构选择合适的业务通信机制：
开发者需根据当前业务区分是否存在C++侧环境（较为显著标志点为当前应用是否使用了Node API技术进行开发，若是则该应用具备C++侧环境）。 具备C++侧环境的应用开发，可使用ArkWeb提供的NDK侧JSBridge接口。 不具备C++侧环境的应用开发，可使用ArkWeb侧JSBridge接口。
异步JSBridge调用
原理介绍
异步JSBridge调用适用于H5侧调用ArkTS侧或C++侧注册的JSBridge函数场景下，将用户指定的JSBridge接口的调用抛出后，不等待执行结果， 以避免在ArkUI主线程负载重时JSBridge同步调用可能导致Web线程等待IPC时间过长，从而造成阻塞的问题。
实践案例
案例一：使用ArkTS接口实现JSBridge通信，具体步骤如下：
1.
```typescript
import { webview } from '@kit.ArkWeb';
// 定义ETS侧对象及函数
class TestObj {
constructor() {}
test(testStr:string): string {
let start = Date.now();
// 模拟耗时操作
for(let i = 0; i < 500000; i++) {}
let end = Date.now();
console.log('objName.test start: ' + start);
return 'objName.test Sync function took ' + (end - start) + 'ms';
}
asyncTestBool(testBol:boolean): Promise<string> {
return new Promise((resolve, reject) => {
let start = Date.now();
// 模拟耗时操作（异步）
setTimeout(() => {
for(let i = 0; i < 500000; i++) {}
let end = Date.now();
console.log('objAsyncName.asyncTestBool start: ' + start);
resolve('objName.asyncTestBool Async function took ' + (end - start) + 'ms');
}, 0); // 使用0毫秒延迟来模拟立即开始的异步操作
});
}
}
class WebObj {
constructor() {}
webTest(): string {
let start = Date.now();
// 模拟耗时操作
for(let i = 0; i < 500000; i++) {}
let end = Date.now();
console.log('objTestName.webTest start: ' + start);
return 'objTestName.webTest Sync function took ' + (end - start) + 'ms';
}
webString(): string {
let start = Date.now();
// 模拟耗时操作
for(let i = 0; i < 500000; i++) {}
let end = Date.now();
console.log('objTestName.webString start: ' + start);
return 'objTestName.webString Sync function took ' + (end - start) + 'ms';
}
}
class AsyncObj {
constructor() {
}
asyncTest(): Promise<string> {
return new Promise((resolve, reject) => {
let start = Date.now();
// 模拟耗时操作（异步）
setTimeout(() => {
for (let i = 0; i < 500000; i++) {
}
let end = Date.now();
console.log('objAsyncName.asyncTest start: ' + start);
resolve('objAsyncName.asyncTest Async function took ' + (end - start) + 'ms');
}, 0); // 使用0毫秒延迟来模拟立即开始的异步操作
});
}
asyncString(testStr:string): Promise<string> {
return new Promise((resolve, reject) => {
let start = Date.now();
// 模拟耗时操作（异步）
setTimeout(() => {
for (let i = 0; i < 500000; i++) {
}
let end = Date.now();
console.log('objAsyncName.asyncString start: ' + start);
resolve('objAsyncName.asyncString Async function took ' + (end - start) + 'ms');
}, 0); // 使用0毫秒延迟来模拟立即开始的异步操作
});
}
}
@Entry
@Component
struct Index {
controller: webview.WebviewController = new webview.WebviewController();
@State testObjtest: TestObj = new TestObj();
@State webTestObj: WebObj = new WebObj();
@State asyncTestObj: AsyncObj = new AsyncObj();
build() {
Column() {
Button('refresh')
.onClick(()=>{
try{
this.controller.refresh();
} catch (error) {
console.error(`ErrorCode:${(error as BusinessError).code},Message:${(error as BusinessError).message}`);
}
})
Button('Register JavaScript To Window')
.onClick(()=>{
try {
//只注册同步函数
this.controller.registerJavaScriptProxy(this.webTestObj,"objTestName",["webTest","webString"]);
} catch (error) {
console.error(`ErrorCode:${(error as BusinessError).code},Message:${(error as BusinessError).message}`);
}
})
Web({src: $rawfile('index.html'),controller: this.controller}).javaScriptAccess(true)
}
}
}
```
2.
案例二：使用registerJavaScriptProxy或javaScriptProxy注册异步函数或异步同步共存，H5侧调用JSBridge函数与不推荐用法一致。
总结
数据运行结果如下：
|  注册方法类型 |  耗时(局限不同设备和场景，数据仅供参考) |  说明 |
| --- | --- | --- |
|  同步方法 |  1398ms，2707ms，2705ms |  同步函数调用会阻塞JavaScript线程 |
|  异步方法 |  2ms，2ms，4ms |  异步函数调用不阻塞JavaScript线程 |
注册方法类型
耗时(局限不同设备和场景，数据仅供参考)
说明
同步方法
1398ms，2707ms，2705ms
同步函数调用会阻塞JavaScript线程
异步方法
2ms，2ms，4ms
异步函数调用不阻塞JavaScript线程
通过运行数据可看到async的异步方法不需要等待结果，所以在JavaScript单线程任务队列中不会长时间占用，而同步方法需要等待ArkTS侧主线程同步执行后返回结果。
JSBridge接口在注册时，即会根据注册调用的接口决定其调用方式（同步/异步）。开发者需根据当前业务区分， 是否将其注册为异步函数。
附NDK接口实现JSBridge通信(C++侧注册异步函数):
同层渲染
同层渲染是一种优化技术，用于提高Web页面的渲染性能。同层渲染会将位于同一个图层的元素一起渲染，以减少重绘和重排的次数，从而提高页面的渲染效率。关于同层渲染的内容，可以参考使用同层渲染在Web组件上渲染原生组件。
总结
本文深入探讨了Web页面加载的原理和优化方法，为开发者提供了重要的指导和思路。在当今互联网时代，用户对网页加载速度和体验要求越来越高，因此页面加载优化成为开发者必须重视的一环。通过理解Web页面加载的原理，开发者可以更好地处理页面加载与优化的相关问题，提升应用的整体质量。
文中提供了预连接、预下载、预渲染、预取POST、预编译等多种常见的优化方法，指导开发者优化Web页面的加载速度。这些方法可以有效提高应用流畅度、提升用户体验。但是，这几种方法都是基于预处理的方式进行优化的，所以存在一定的优化代价。
在实际的开发场景中，开发者应该根据实际的情况进行权衡利弊，决定对应的方案与策略。此外，还提供了JSBridge与资源加速的优化方案，帮助开发者进一步提高Web加载性能。除了以上提到的优化方法，开发者还可以通过其他方式进一步优化页面加载速度。例如，压缩资源可以减小文件大小，减少加载时间；减少HTTP请求可以减少网络延迟，加快页面加载速度，提升用户体验。
综上所述，Web页面加载优化对于提升用户体验、提高网站性能、增加页面浏览量和提高转化率具有重要意义。开发者应该重视页面加载优化，不断探索和实践各种优化方法，以提升用户体验，实现商业目标。通过文章介绍的几种优化方法，开发者可以改善页面加载速度，提升用户体验，增加页面浏览量，提高应用的活跃度和用户粘性。只有不断优化页面加载速度，才能更好地满足用户需求，提升应用价值。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-application-cold-start-optimization
爬取时间: 2025-05-01 08:49:23
来源: Huawei Developer
概述
应用启动时延是影响用户体验的关键要素，是指从用户点击桌面应用图标、通知或其他入口启动应用，到应用界面内容成功加载并显示在屏幕上的时间间隔。如果这段时间耗时比较长，肯定会影响用户的体验。
应用启动可以分为冷启动和热启动，当应用启动时，后台没有该应用的进程，这时系统会重新创建应用的进程， 这种启动方式就叫做冷启动；而热启动是当应用程序已经在后台运行，用户再次打开应用程序时，应用程序仍然在内存中，可以直接从内存中加载并继续之前的状态，而不需要重新初始化和加载资源。
当应用冷启动时延大于1100ms时，可以认为是应用启动缓慢，体验标准可以参考应用流畅体验设计。
本文将介绍以下内容，来帮助开发者提升应用的冷启动速度，避免卡顿感：
应用冷启动流程
在优化应用冷启动体验前，需要先了解应用冷启动的流程和几个重要的生命周期。应用冷启动的过程大致可分成以下5个阶段：应用进程创建&初始化、Application&Ability初始化、Ability/AbilityStage生命周期、加载绘制首页、网络数据二次刷新，如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151140.34848578118680114712235228845452:50001231000000:2800:C68ADB6786F059953D996475260E19C0378D635A35958D77E13369E85BF1AC5E.png)
可见如果想要提升应用冷启动速度，需要缩短以上几个阶段的耗时。
识别启动缓慢问题
如果开发者需要分析启动过程的耗时瓶颈，优化应用或服务的冷启动速度，可使用Profiler提供的Launch场景分析能力，录制启动过程中的关键数据进行分析，从而识别出导致启动缓慢的原因所在。Profiler Launch可以拆解应用冷启动过程，抓取不同阶段的耗时数据，帮助开发者快速分析冷启动过程的耗时瓶颈，Launch的具体使用可以参考冷启动分析：Launch分析。
下面录制了一段Launch任务，具体操作步骤请参见性能问题定位：深度录制。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151140.43315136577842756798187109490728:50001231000000:2800:FB69E4B460F6DD723F80E8CA15551516174856168BBE965E13B87167AB1BFF54.png)
从上图可以看到Launch将应用的冷启动过程拆解为以下几个阶段：
阶段1对应图1中的第1阶段，阶段2对应图1中的第2阶段，阶段3和4对应图1中的第3阶段，阶段5和6对应图1中的第4阶段，阶段7对应图1中的第5阶段。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151140.81936348191792725773306792266473:50001231000000:2800:416380CBD4B2F4727C65A134F5E6943603392A80040B026496229B9616DF1A87.png)
冷启动缓慢示例分析
运行如下示例代码，开发者可以明显的感知应用启动比较缓慢。接下来开发者通过这个示例，结合Launch来分析应用冷启动缓慢问题。
```typescript
const LARGE_NUMBER = 200000000;
const DELAYED_TIME = 1000;
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
aboutToAppear(): void {
console.log('aboutToAppear');
this.computeTask();
}
computeTask(): void {
let count = 0;
while (count < LARGE_NUMBER) {
count++;
}
}
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
.width('100%')
}
.height('100%')
}
}
```
首先是创建Launch分析录制，可以看到整个的启动时间比较长，其中UI Ability OnForeground这个阶段占据应用冷启动过程的大部分时间，耗时达到了4.1s，所以开发者需要重点分析这个阶段的耗时。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151140.94721569340567358433530717680281:50001231000000:2800:870E666BE8FA0858806A3F7F18E3B51B6C28A86C6AAB369D4026DF63D0BF31E3.png)
针对应用冷启动问题的性能分析，有以下两种方式可以选择，一种是分析主线程的Trace数据，另一种则是分析采样得到的函数热点。
分析主线程的Trace数据
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151140.42430602067672020206096293228841:50001231000000:2800:9F6E31BC8F741284A897701ECF0F3DBAC5D56309C329A5368B24C5919766FC8A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151140.44115758554065177590186376474525:50001231000000:2800:CDA2ACA1575D5F0737FB09F324C18239917D52DD1F99C82E5E60BB4FBB717367.png)
可以看到在UI Ability OnForeground阶段的耗时基本是由aboutToAppear造成的，再看aboutToAppear中的代码逻辑，可以推断是由于计算任务computeTask耗时造成的。
分析采样得到的函数热点
开发者也可以分析采样得到的函数热点直观的显示应用冷启动过程中具体函数的耗时，如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151140.45042119825559191690713776788900:50001231000000:2800:8D715D917E3AD523BEA928883899651BAF0BE9D22532C25F362BD70A89595A58.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151140.03493466147916912508464225354600:50001231000000:2800:0BE016CCDB2E8F532135D401168318961D5481FDD075754DA207B0EFD477F86C.png)
冷启动速度优化
通过前面的分析，冷启动缓慢是由于在aboutToAppear执行了耗时计算任务，开发者可以将该computeTask以异步延时的方式处理，优化后的代码如下：
```typescript
const LARGE_NUMBER = 100000000;
const DELAYED_TIME = 1000;
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
aboutToAppear(): void {
console.log('aboutToAppear');
this.computeTaskAsync();
}
...
computeTask(): void {
let count = 0;
while (count < LARGE_NUMBER) {
count++;
}
}
// 运算任务异步处理
private computeTaskAsync(): void {
setTimeout(() => { // 这里使用setTimeout来实现异步延迟运行
this.computeTask();
}, DELAYED_TIME);
}
}
```
然后重新编译运行程序以及录制Launch，可以看到优化后UI Ability OnForeground阶段耗时大幅度缩短，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151140.70899951215819377481940068680757:50001231000000:2800:424DE09B543DB324A23D2D3BE051D0D65216D133A3FD1908419160010A9EB55E.png)
查看首帧卡顿
为了识别首帧是否卡顿，可以先在Launch的Frame泳道进行查看。应用的首帧渲染提交在First Frame - App Phase阶段，APP侧下面的这一帧表示应用渲染的首帧，如下图所示，此处首帧为36号帧：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151140.55438917533774765870356953140563:50001231000000:2800:E002CFA45FA55FC909C30BC92D3EEBF91E6379B37C362BB9F626D0D709F44DC7.png)
如上所示36号帧被标记为了红色，表示首帧出现了卡顿。鼠标左键36号帧，可以看到它的期望提交渲染时间为左边白色竖线区域所示，这里出现了比较严重的延时。发现问题后，开发者可以参考前面讲到的示例进行问题定位和优化。
提升应用冷启动速度
本文将通过公共类优化的方法，包括非冷启动必须的服务或模块延迟加载、减少主线程非UI耗时操作和网络请求提前发送，以及结合应用启动的几个阶段分别介绍提升应用冷启动速度的相关方法。
非冷启动必须的服务或模块延迟加载
应用在启动前加载过多不必要启动项，同时这些启动项在主线程串行执行，该阶段耗时接近450ms。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151140.67930402366058357839825535927673:50001231000000:2800:B0A9A65FB5EEA9917D8C294D8CA7C3A5690BA3E1C631A430876A0C39C0558FAF.png)
应用冷启动过程中，加载自身不必要的串行启动项，会导致冷启动耗时增加。建议延后加载或者并行处理，具体可以参考延迟加载Lazy-Import使用指导。
减少主线程非UI耗时操作
在应用启动流程中，主要聚焦在执行UI相关操作中，为了更快的显示首页内容，不建议在主线程中执行非UI相关的耗时操作，建议通过异步任务进行延迟处理或放到其他子线程中执行，线程并发方案详细请参见TaskPool和Worker的对比实践。
在冷启动过程中如果存在图片下载、网络请求前置数据、数据反序列化等非UI操作开发者可以根据实际情况移至子线程中进行，详细请参见应用并发设计。
网络请求提前发送
当前大多数应用的首页内容需从网络获取，发送网络请求的时机显得尤为重要。应用发送网络请求后等待网络数据的返回，网络请求的这段时间应用可以继续执行启动流程，直到网络数据返回后进行解析，反序列化之后就可以加载首页数据，因此网络请求的发起时机越早，整个冷启动的完成时延阶段越短。
可将网络请求及网络请求前的初始化流程放置在AbilityStage/UIAbility的onCreate()生命周期中，在AbilityStage/UIAbility中仅执行网络相关预处理，等待网络请求发送后可继续执行首页数据准备、UI相关操作。在服务端处理流程相同的情况下，应用可以更早的拿到网络数据并行展示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151140.54308026665477543299722701868402:50001231000000:2800:E66C18A09AFB5A3E56B7BDFEDED52F0B3DC2B3576B8D5747091DF509DC91A0C3.png)
将网络请求提前至AbilityStage/UIAbility生命的onCreate()生命周期回调函数中，可以将首刷或二刷的时间提前，减少用户等待时间。此处为了体现性能收益，将网络请求放到了更早的AbilityStage的onCreate()生命周期回调中。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151140.37600329838433252717274860913229:50001231000000:2800:4AD50250A6B62DA8EEBB4CF936C2D084A972600D190F96314344560ACEFF247C.png)
```typescript
// entry/src/main/ets/pages/Index.ets
import { httpRequest } from '../utils/NetRequest';
import { number } from '../utils/Calculator';
AppStorage.link('netData');
PersistentStorage.persistProp('netData', undefined);
@Entry
@Component
struct Index {
@State message: string = 'Hello World' + number; // 为了体现性能收益，引用耗时函数的执行结果number
@StorageLink('netData') netData: PixelMap | undefined = undefined;
build(){
Row(){
Image(this.netData)
.objectFit(ImageFit.Contain)
.width('50%')
.height('50%')
}
.onAppear(() => {
// 发送网络请求
httpRequest();
})
}
}
// entry/src/main/ets/utils/NetRequest.ets
import { hiTraceMeter } from '@kit.PerformanceAnalysisKit';
import { http } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { image } from '@kit.ImageKit';
// 通过http的request方法从网络下载图片资源
export function httpRequest() {
hiTraceMeter.startTrace('Http Request', 1);
http.createHttp()
// 实际开发需要将"https://www.example1.com/POST?e=f&g=h"替换成为真实要访问的网站地址
.request('https://www.example1.com/POST?e=f&g=h',
(error: BusinessError, data: http.HttpResponse) => {
if (error) {
// 下载失败时不执行后续逻辑
return;
}
// 处理网络请求返回的数据
transcodePixelMap(data);
}
)
}
// 使用createPixelMap将ArrayBuffer类型的图片装换为PixelMap类型
function transcodePixelMap(data: http.HttpResponse) {
if (http.ResponseCode.OK === data.responseCode) {
const imageData: ArrayBuffer = data.result as ArrayBuffer;
// 通过ArrayBuffer创建图片源实例
const imageSource: image.ImageSource = image.createImageSource(imageData);
const options: image.InitializationOptions = {
'alphaType': 0, // 透明度
'editable': false, // 是否可编辑
'pixelFormat': 3, // 像素格式
'scaleMode': 1, // 缩略值
'size': { height: 100, width: 100 }
}; // 创建图片大小
// 通过属性创建PixelMap
imageSource.createPixelMap(options).then((pixelMap: PixelMap) => {
AppStorage.set('netData', pixelMap);
hiTraceMeter.finishTrace('Http Request', 1);
});
}
}
// entry/src/main/ets/utils/Calculator.ets
const LARGE_NUMBER = 100000000;
function computeTask(): number {
let count = 0;
while (count < LARGE_NUMBER) {
count++;
}
return count;
}
export let number = computeTask();
```
【优化后】
```typescript
// MyAbilityStage.ets
import { AbilityStage, Want } from '@kit.AbilityKit';
import { httpRequest } from '../utils/NetRequest';
export default class MyAbilityStage extends AbilityStage {
onCreate(): void {
// 发送网络请求
httpRequest();
}
onAcceptWant(want: Want): string {
// 仅specified模式下触发
return 'MyAbilityStage';
}
}
```
```typescript
// Index.ets
import { number } from '../utils/Calculator';
AppStorage.link('netData');
PersistentStorage.persistProp('netData', undefined);
@Entry
@Component
struct Index {
@State message: string = 'Hello World' + number; // 为了体现性能收益，引用耗时函数的执行结果number
@StorageLink('netData') netData: PixelMap | undefined = undefined;
build() {
Row() {
Image(this.netData)
.objectFit(ImageFit.Contain)
.width('50%')
.height('50%')
}
.onDisAppear(() => {
AppStorage.set('netData', undefined);
})
.height('100%')
.width('100%')
}
}
```
使用Launch分析，对优化前后启动性能进行对比分析。分析阶段的起点为启动Ability（即H:void OHOS::AppExecFwk::MainThread::HandleLaunchAbility的开始点），阶段终点为应用接收到网络数据返回后的首帧刷新（即H:ReceiveVsync dataCount:24Bytes now:timestamp expectedEnd:timestamp vsyncId:int的开始点）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151141.87089301495270509591713413674978:50001231000000:2800:0A4D1850C626BC64F3F5D757AB9FD2674D63FE313EB57AEFA5C80311E1056D4D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151141.25364488662012107845552812916159:50001231000000:2800:E0A2D671F7C5977C85248D72461DB39ED5F6B71B252C75EFD06F7B817E8AB10F.png)
对比数据如下：
|  方案 |  阶段时长(毫秒) |
| --- | --- |
|  优化网络请求时机前 |  1700 |
|  优化网络请求时机后 |  885.3 |
方案
阶段时长(毫秒)
优化网络请求时机前
1700
优化网络请求时机后
885.3
因此，可以通过提前网络请求的方式减少应用冷启动耗时。
缩短应用进程创建&初始化阶段耗时
应用进程创建&初始化阶段主要是系统完成应用进程的创建以及初始化的过程，包含了启动页图标(startWindowIcon)的解码。使用合适分辨率的图标是影响体验的关键，建议使用不超过256*256分辨率的图片作为启动页面图标，以减少图片解码带来的时延。
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/start-window-icon-check规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
设置合适分辨率的startWindowIcon
如果启动页图标分辨率过大，解码耗时会影响应用的启动速度，建议启动页图标分辨率不超过256像素*256像素，如下所示：
下面使用Launch分析，对使用优化前的启动页图标（4096像素*4096像素）及使用优化后的启动页图标（144像素*144像素）的启动性能进行对比分析。分析阶段的起点Process Creating，阶段终点为First Frame - Render Phase，优化前后的启动耗时如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151141.88644175609835744635080045867981:50001231000000:2800:C13304583F1AA9EC23586B3C73FD15774820D0DE3EA41E8EFB5DAED5B768E36E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151141.63599020503877588234409368247450:50001231000000:2800:C896B6EDE076AE88B941351A870D35D4BB100A6CB2A43482816D4385F49EC329.png)
可见优化后应用启动时长缩短了37.2ms，故设置合适分辨率的startWindowIcon对缩短应用进程创建&初始化阶段耗时是有效的。
缩短Application&Ability初始化阶段耗时
Application&Ability初始化阶主要包含资源加载、虚拟机创建、Application&Ability相关对象的创建与初始化、依赖模块的加载等。
主要耗时点在资源加载阶段，分为以下几个步骤。
本章节将针对这三个阶段可能存在的优化手段进行详细展开说明。
减少import的模块
应用代码执行前，应用程序必须找到并加载import的模块，应用程序加载的每个额外的第三方框架或者模块都会增加启动时间，耗时长短取决于加载的第三方框架或者模块的数量和大小。推荐开发者尽可能使用系统提供的模块，按需加载，来缩短应用程序的启动耗时。
下面使用Launch分析，对优化import的模块前（模块数量15个）及优化import的模块后（移除不必要的模块剩余5个）的启动性能进行对比分析。分析的trace点为H:SourceTextModule::Evaluate，优化前后的启动耗时如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151141.12778461883850123915216366432282:50001231000000:2800:89F8E86218FE3BA51B8A0C5AC89E74B3364EAD85DC99FCFE39309C8AD277BC4B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151141.69938561312985230826100525682238:50001231000000:2800:680CE317E4AAC9D13B7E3640EBB12CF0695F626B6CD2514D0B589ACAA72289A5.png)
对比数据如下：
|  方案 |  阶段时长(微秒) |
| --- | --- |
|  减少import的模块前 |  6239.5 |
|  减少import的模块后 |  119.7 |
方案
阶段时长(微秒)
减少import的模块前
6239.5
减少import的模块后
119.7
可见减少不必要的模块import，可以缩短应用冷启动时间。此外，如果某些必要的模块导入比较耗时的话，可以采取动态导入的方式，具体可以参考动态加载。
减少使用嵌套export */import *的方式
-  应用冷启动过程中，会在HandleLaunchAbility中执行冷启动相关.ets文件，所有被主页面import的.ets文件均会被执行，包括数据结构、变量、全局函数的初始化等。首页需要用到的变量及函数等可能来源于其他.ets文件，通过export的形式提供给首页使用。详细请参见减少使用嵌套export *的方式全量导出。 使用Launch分析，对优化前（嵌套8层export *）及优化后（不存在嵌套export *，从目标文件中直接import）的启动性能进行对比分析。分析阶段的起点为开始加载abc文件（即H:JSPandaFileExecutor::ExecuteFromAbcFile），阶段终点为abc文件加载完成。 对比数据如下： 方案 阶段时长(微秒) （优化前）存在8层嵌套export * 492.6 （优化后）不存在嵌套export *，从目标文件中直接import 388.7 可见阶段时长已缩短。因此减少多层文件的嵌套导出export *可以提升应用冷启动速度。
-  应用程序加载过程中，需要使用不同模块中的变量或函数，通常开发者会将相同类型的变量或函数放在同一个工具类文件中，使用时通过import的方式引入对应的模块，当工具类中存在较多暴露函数或变量时，推荐按需引用使用到的变量代替import *的方式，可以减少该阶段中.ets文件执行耗时，即减少文件中所有export变量的初始化过程。详细请参见减少import *的方式全量引用。 对优化前（使用import * as nm全量引用2000条数据）和优化后（使用import { One }按需引用）的启动性能进行对比分析。分析阶段的起点为H:void OHOS::AppExecFwk::MainThread::HandleLaunchAbility(const std::shared_ptr<AbilityLocalRecord> &)的开始点，阶段终点为H:void OHOS::AppExecFwk::MainThread::HandleLaunchAbility(const std::shared_ptr<AbilityLocalRecord> &)的结束点。 优化前后的对比数据如下： 方案 阶段时长(毫秒) （优化前）使用import * as nm全量引用 16.7 （优化后）使用import { One }按需引用 7.1 可见阶段时长已缩短。因此使用按需引用的方式，可以缩短应用冷启动完成时延。 此优化方案仅可将冷启动阶段耗时缩短，但是可能导致其他场景耗时增长，即变量初始化过程从冷启动阶段分摊至其它使用阶段，例：当二级页面使用到Numbers.ets中Two变量，此方案会使二级页面跳转过程对比优化前耗时更长。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151141.08737198342171027663622721659541:50001231000000:2800:53DE6E83CB24722314601111A3851F324F919483D159C128D2B6615C8082E906.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151141.16736143232949180749474069675506:50001231000000:2800:CC13D96CA8AB234EB65F7BCC94ECF3E6A08BB5DB7CC39E833CE245FE0A894556.png)
|  方案 |  阶段时长(微秒) |
| --- | --- |
|  （优化前）存在8层嵌套export * |  492.6 |
|  （优化后）不存在嵌套export *，从目标文件中直接import |  388.7 |
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151141.76937286464222219809459131603318:50001231000000:2800:0A17220F16182F810B4D8C2DA7320CC3AFAD75E91F08D33AEDBB05CF081C706B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151141.87310283452767320443755836663678:50001231000000:2800:F96722B4F81152F239458F3F7CA2339441AD855062DC3177A6D8D23F4845F5F4.png)
|  方案 |  阶段时长(毫秒) |
| --- | --- |
|  （优化前）使用import * as nm全量引用 |  16.7 |
|  （优化后）使用import { One }按需引用 |  7.1 |
合理拆分导出文件，减少冗余文件执行
应用程序加载模块后，需要执行应用侧的.ets文件，对其进行初始化，并执行全局初始化变量、函数。可以将文件分为两类，一类为冷启动强相关文件（如首页展示界面及组件相关文件），一类为非冷启动强相关文件（如跳转后二级页面），在冷启动过程中仅执行冷启动强相关文件，来缩短应用的启动耗时。
【场景示例】
应用存在两个页面，首页Index和二级页面SecondPage。首页展示为HAR包中MainPage.ets文件的Text组件，该文件中不包含耗时操作。点击首页中的Text组件时，会跳转至二级页面。二级页面引用了HAR包中的SubPage.ets文件，该文件存在全局函数的耗时操作，会在模块加载时执行。
HAR包中的导出文件Index.ets同时导出了MainPage.ets和SubPage.ets两个文件。当首页直接使用 “import { MainPage } from 'library/Index'” 的方式进行导入时，会导致应用在冷启动过程中执行非冷启动强相关文件SubPage.ets，增加了冷启动耗时。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151141.45116250299657810027187956562311:50001231000000:2800:C7B053172529951E60DFC3C7D3D3DF55E61C3919BAD0F00B3EBE2E60DE3B8956.png)
以下为示例代码：
```typescript
// entry/src/main/ets/pages/Index.ets
import { MainPage } from 'library/Index'; // 不推荐用法：直接导入了与冷启动非强相关文件SubPage.ets
export struct Index{
@Provide pathStack: NavPathStack = new NavPathStack();
build() {
Navigation(this.pathStack) {
Row() {
// 引用HAR的自定义组件
MainPage()
}
}
}
}
// library/src/main/ets/components/mainpage/MainPage.ets
@Component
export struct MainPage {
@Consume pathStack: NavPathStack;
@State message: string = 'HAR MainPage';
build() {
Row() {
Text(this.message)
.fontSize(32)
.fontWeight(FontWeight.Bold)
}.onClick(() => {
this.pathStack.pushPath({ name: 'SecondPage' });
})
}
}
// entry/src/main/ets/pages/SecondPage.ets
import { SubPage } from 'library/Index';
@Builder
export function SecondPageBuilder() {
SecondPage()
}
@Entry
@Component
struct SecondPage {
pathStack: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Row() {
// 引用HAR的自定义组件
SubPage()
}
.height('100%')
}
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack;
})
}
}
// library/src/main/ets/components/mainpage/SubPage.ets
// SubPage中的全局耗时函数
const LARGE_NUMBER = 10000000;
function computeTask(): number {
let count = 0;
while (count < LARGE_NUMBER) {
count++;
}
return count;
}
let count = computeTask();
// ...
// library/Index.ets
export { MainPage } from './src/main/ets/components/mainpage/MainPage'; // 冷启动强相关文件
export { SubPage } from './src/main/ets/components/mainpage/SubPage'; // 非冷启动强相关文件
```
【优化方案一】
将HAR包的导出文件Index.ets进行拆分，IndexAppStart.ets文件仅导出首页相关文件，即MainPage.ets。IndexOthers.ets文件导出非首页相关文件，即SubPage.ets。
优点：使用此种方案优化后可以将冷启阶段（加载首页文件）与非冷启阶段（加载非首页文件）需要执行的.ets文件进行完全拆分，类比其他需优化的场景也可以使用本方案进行拆分。
缺点：需保证拆分后IndexAppStart.ets中的导出文件不存在对于IndexOthers.ets中的导出文件的引用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151141.38651003640193106141912977989626:50001231000000:2800:D0A6F843DB3C27CB0173E9D1A900230E50C11FB7D6AB316726B6CE45A39A2651.png)
示例代码如下：
```typescript
// Index.ets
import { MainPage } from 'library/IndexAppStart';
@Entry
@Component
struct Index {
@Provide pathStack: NavPathStack = new NavPathStack();
build() {
Navigation(this.pathStack) {
Row() {
// 引用HAR的自定义组件
MainPage()
}
}
.height('100%')
.width('100%')
}
}
```
```typescript
// SecondPage.ets
import { SubPage } from 'library/IndexOthers';
@Builder
export function SecondPageBuilder() {
SecondPage()
}
@Entry
@Component
struct SecondPage {
pathStack: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Row() {
// 引用HAR的自定义组件
SubPage()
}
.height('100%')
}
.onReady((context: NavDestinationContext) => {
this.pathStack = context.pathStack;
})
}
}
```
【优化方案二】
在首页的Index.ets文件中导入MainPage.ets时使用全路径展开。
优点：不需要新增文件来汇总导出所有冷启阶段文件。
缺点：引用时需要对所有冷启阶段文件进行路径展开，增加开发和维护成本。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151141.18104444547170744005298258300493:50001231000000:2800:1FF7376A20158DF474873487BAD9E9FD66B34D5A171CE859E5F6F8B7B29EBFB9.png)
示例代码如下：
```typescript
// Index.ets
import { MainPage } from 'library/src/main/ets/components/mainpage/MainPage';
@Entry
@Component
struct Index {
@Provide pathStack: NavPathStack = new NavPathStack();
build() {
Navigation(this.pathStack) {
Row() {
// 引用HAR的自定义组件
MainPage()
}
}
.height('100%')
.width('100%')
}
}
```
1. 上述两种优化方案默认MainPage中不存在对于SubPage中的import。
2. 当存在MainPage对于SubPage的直接import时，需要使用动态import方法来进行优化。
3. 开发者可自行根据优化方案的优缺点权衡选择合适的优化方案。
下面使用Launch分析对优化前后启动性能进行对比分析。阶段起点为UI Ability Launching的开始点，阶段终点为应用首帧即First Frame - App Phase的开始点。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.23063836108674161559809389511110:50001231000000:2800:27F9D911BCB45B06A28EA3BD765858CF248BFF975C369F3F0408A2B554BCAC95.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.85944133623175658540495339520517:50001231000000:2800:D252DB072C03C910F4CCA2D6FE3D6B2171F44B719AB9C7EF092B37F6855771E5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.77346921722164182478411000273452:50001231000000:2800:ED591F8A7318B4EBEAB0F474803C8A185105E783DA125DEB9784C952128E2642.png)
优化前后的对比数据如下：
|  方案 |  阶段时长(毫秒) |
| --- | --- |
|  优化前 |  140.1 |
|  优化方案一（拆分HAR导出文件） |  62.9 |
|  优化方案二（导入冷启动文件时全路径展开） |  61.3 |
方案
阶段时长(毫秒)
优化前
140.1
优化方案一（拆分HAR导出文件）
62.9
优化方案二（导入冷启动文件时全路径展开）
61.3
可见阶段时长已缩短，因此可以通过拆分HAR包导出的Index.ets文件或导入冷启动文件时路径全展开的方案，减少应用冷启动中.ets文件执行耗时，从而提升应用冷启动速度。
减少多个HAP/HSP对相同HAR的引用
在应用开发的过程中，可以使用HSP或HAR的共享包方式将同类的模块进行整合，可以实现多个模块或多个工程间共享ArkUI组件、资源等相关代码。同时需要注意避免多个HAP/HSP对相同HAR的引用，详细请参见多HAP/HSP引用相同HAR包的影响。
优化加载HSP时间过长
对于单窗口应用的APP工程而言，其仅包含一个Entry类型的HAP，那么划分的模块如果没有按需加载的需求，则建议业务组件和公共组件采用HAR的打包方式，最终构建应用HAP包时，这些被依赖的HAR，最终都会被编译进HAP包中。HSP是采用动态加载，在启动过程中，会将依赖的HSP加载进来，增加额外的IO与运行耗时。单HAP场景下，模块推荐使用多HAR，不推荐使用HSP。
以下为示例代码：
下面使用Launch分析，HAP+20个HSP混合打包及将20个HSP包设计成HAR包的启动性能进行对比分析。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.51577192959111037036298985328071:50001231000000:2800:5A9585BAF2054787EC7F054871068A040A4A4214A74A3A2BFACBCA2DA8AF3D6F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.64335601147636997314207392033612:50001231000000:2800:69B439AAFB9BE810D66D037C2ADF12EE101E11745CABD651C377D667BBD420C1.png)
对比数据如下：
|  方案 |  阶段时长(微秒) |
| --- | --- |
|  HAP+20个HSP混合打包 |  34643.7 |
|  将20个HSP包设计成HAR包 |  36.4 |
方案
阶段时长(微秒)
HAP+20个HSP混合打包
34643.7
将20个HSP包设计成HAR包
36.4
因此，在单HAP场景下，如果要使用多模块的话，推荐使用多HAR，不推荐使用HSP。
缩短AbilityStage生命周期阶段耗时
AbilityStage生命周期阶段主要是在AbilityStage的启动生命周期，执行相应的生命周期回调。
避免在AbilityStage生命周期回调接口进行耗时操作
在应用启动流程中，系统会执行AbilityStage的生命周期回调函数。因此，不建议在这些回调函数中执行耗时过长的操作，比如onCreate，耗时操作建议通过异步任务延迟处理或者放到其他线程执行，线程并发方案可以参考：TaskPool和Worker的对比实践。在这些生命周期回调里，推荐开发者只做必要的操作，关于AbilityStage可以参考：AbilityStage组件容器，以下为示例代码：
下面使用Launch分析，对优化前同步执行耗时操作及优化后异步执行耗时操作的启动性能进行对比分析。分析阶段的起点Process Creating，阶段终点为First Frame - Render Phase，优化前后的启动耗时如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.61848101770389555462838592469982:50001231000000:2800:3FE673055B9AC95554BC3F3F3B97FF01395CDA065CCBC01B77E5A41565AED9B1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.55975159589310526512707865403625:50001231000000:2800:7F454DA50C11438A60CC02DEBEACFB8BEF2308A897C7823261F9A2536E40F170.png)
可见使用异步后，应用冷启动时间速度有了较大的提升，耗时从2.2s减少到了220.9ms。
缩短Ability生命周期阶段耗时
Ability生命周期阶段主要是在Ability的启动生命周期，执行相应的生命周期回调。
避免在Ability生命周期回调接口进行耗时操作
在应用启动流程中，系统会执行Ability的生命周期回调函数。因此，不建议在这些回调函数中执行耗时过长的操作，耗时操作建议通过异步任务延迟处理或者放到其他线程执行，线程并发方案可以参考：TaskPool和Worker的对比实践。
在这些生命周期回调里，推荐开发者只做必要的操作，下面以UIAbility为例进行说明。比如在生命周期回调函数onCreate、onWindowStageCreate、onForeground等中执行耗时操作都会导致启动缓慢问题，关于UIAbility组件生命周期的详细说明，参见UIAbility组件生命周期。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.64652328067099366101460984286700:50001231000000:2800:1959B736E12A82BBED85A0833FD81E99966056634AFC7B32F9728857CF775A1C.png)
下面示例代码在UIAbility的回调函数onCreate中分别执行了同步和异步操作：
```typescript
const LARGE_NUMBER = 100000000;
const DELAYED_TIME = 1000;
export default class EntryAbility extends UIAbility {
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
// 耗时操作
// this.computeTask();
this.computeTaskAsync(); // 异步任务
}
onWindowStageCreate(windowStage: window.WindowStage): void {
windowStage.loadContent('pages/Index', (err, data) => {
if (err.code) {
logger.error('Failed to load the content. Cause: ' + JSON.stringify(err) ?? '');
return;
}
logger.info('Succeeded in loading the content. Data: ' + JSON.stringify(data) ?? '');
});
// 耗时操作
// this.computeTask();
// this.computeTaskAsync(); // 异步任务
}
onForeground(): void {
// 耗时操作
// this.computeTask();
// this.computeTaskAsync(); // 异步任务
}
private computeTask(): void {
let count = 0;
while (count < LARGE_NUMBER) {
count++;
}
}
private computeTaskAsync(): void {
setTimeout(() => { // 这里使用setTimeout来实现异步延迟运行
this.computeTask();
}, DELAYED_TIME);
}
}
```
下面使用Launch分析，对优化前同步执行耗时操作及优化后异步执行耗时操作的启动性能进行对比分析。分析阶段的起点Process Creating，阶段终点为First Frame - Render Phase，优化前后的启动耗时如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.67277166612391760229481337746588:50001231000000:2800:C54217FA1F0097667A7729CF87C32EF0B311FC7ECF6296B501760F18B4375B01.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.29946903577269909116922765780445:50001231000000:2800:EAF60FB0FCD2093DF30B2285FE1FB37ABDFD1258E979863D3F8D480EBB32BB21.png)
可见使用延时异步后，应用冷启动时间速度有了较大的提升，耗时从2.1s减少到了220ms。
缩短加载绘制首页阶段耗时
首页加载绘制阶段主要包含加载首页内容、测量布局、刷新组件并绘制。同样注意页面生命周期的处理函数，不要进行耗时操作，同时，应优先创建首页需要显示的组件，使用if分支语句，隐藏不需要显示的组件，减少创建过程的耗时。耗时操作建议通过异步任务延迟处理或者放到其他线程执行，线程并发方案可以参考：TaskPool和Worker的对比实践。
自定义组件生命周期回调接口里避免耗时操作
自定义组件的生命周期变更会调用相应的回调函数，aboutToAppear函数会在创建自定义组件实例后，页面绘制之前执行，而onPageShow则是在页面进入前台的时候显示，因此避免在这两个回调函数中执行该耗时操作，不阻塞页面绘制。关于自定义组件生命周期的详细说明，参见页面和自定义组件生命周期。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.76387836946787749989293450375260:50001231000000:2800:A5BE28C4EE7A22EBB701598781F0DB01677ABEB18AC4A7D02E1A95BEC76CF6DB.png)
以下为示例代码在Page的回调函数aboutToAppear中分别执行了同步和异步操作：
```typescript
const LARGE_NUMBER = 100000000;
const DELAYED_TIME = 1000;
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
aboutToAppear(): void {
// 耗时操作
// this.computeTask();
this.computeTaskAsync(); // 异步任务
}
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
.width('100%')
}
.height('100%')
}
private computeTask(): void {
let count = 0;
while (count < LARGE_NUMBER) {
count++;
}
}
// 运算任务异步处理
private computeTaskAsync(): void {
setTimeout(() => { // 这里使用setTimeout来实现异步延迟运行
this.computeTask();
}, DELAYED_TIME);
}
}
```
下面使用Launch分析，对优化前同步执行耗时操作及优化后异步执行耗时操作的启动性能进行对比分析。分析阶段的起点Process Creating，阶段终点为First Frame - Render Phase。
优化前后的启动耗时如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.71093864997006424623980145908478:50001231000000:2800:C3A85C40AAF83E6F7090E8BB4D60CA8F48BAB73AA4D564A865481D1389A42DA0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.80508524827615700625501176954593:50001231000000:2800:4ED6542A757FEDDDC369AD2690BDAA18AA964732FAAE6E37D752A333E878DF93.png)
可见使用异步后，应用冷启动时间速度有了较大的提升，耗时从2.4s减少到了238.3ms。
使用本地存储首页数据
在应用启动流程中，大部分应用的首页数据信息需要等待网络请求返回的数据解析结果，因此可以将首页数据通过数据库、Preferences、文件、AppStorage等方式进行本地存储，再次冷启动时优先展示已存储数据，网络请求后再次刷新首页数据。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151142.98868075975229939653855859234762:50001231000000:2800:6BF5700105BBF0D96A78615D270D9EBDB6F1AAB2CB5B5F9E68E48A209D92C9BD.png)
使用本地存储优先展示，可以减少首帧展示完成时延，减少用户可见白屏或白块时间，提升用户的冷启动体验。
应用需根据自身对于数据的时效性要求，来决定是否使用本地存储数据。例如时效性要求为一天时，一天前保存的数据就不适合进行展示，需从网络获取新数据进行展示，并更新本地存储数据。
【场景示例】
应用首页需展示一张从网站获取的图片信息，在aboutToAppear()中发起网络请求，待数据返回解析后展示在首页上。之后将图片信息存储至本地应用沙箱内，再次冷启动时首先从沙箱内获取图片信息，若存在即可解析并展示，在网络请求返回时再次更新图片信息。
以下为关键示例代码：
下面对优化前后启动性能进行对比分析。分析阶段的起点为启动Ability（即H:void OHOS::AppExecFwk::MainThread::HandleLaunchAbility的开始点），阶段终点为应用首次解析Pixelmap（即H:Napi execute, name:CreatePixelMap, traceid:0x0）后的第一个vsync（即H:ReceiveVsync dataCount:24Bytes now:timestamp expectedEnd:timestamp vsyncId:int的开始点）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151143.79615338282508503805522541682680:50001231000000:2800:0D49575E822703C3F8B185FE50F7074D5C23EBD0A9DF9FBF42E326029B5A1B4A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151143.77532459150572977546425578716753:50001231000000:2800:29CF4E71B6F54ACC8E23E8288230A3FD9AC5622A25EFC4A01BCC17ECB8062F53.png)
对比数据如下：
|  方案 |  阶段时长(毫秒) |
| --- | --- |
|  （优化前）未使用本地存储 |  641.8 |
|  （优化后）使用本地存储 |  68.9 |
方案
阶段时长(毫秒)
（优化前）未使用本地存储
641.8
（优化后）使用本地存储
68.9
可以看到在使用本地存储后，应用冷启动时从Ability启动到图片显示的阶段耗时明显减少。
针对应用冷启动过程中网络请求耗时久的场景，目前提供了一个三方库供开发者使用，优化方式是首页内容复用，先用本地缓存的数据，三方库链接：首页数据缓存。首页数据缓存来加速应用冷启动的使用可以参考：首页数据缓存加速冷启动。
优化首页显示速度
用户感知的启动是从点击应用入口到首页数据显示在屏幕上的过程，也可以看作是响应用户点击事件的一个过程，开发者可以通过UI优化、并发优化、代码逻辑优化、IPC通信优化等方法来提升首页的响应速度，具体可以参考：点击响应优化。
总结
本文主要介绍了应用冷启动的流程、如何识别和分析冷启动缓慢问题，同时介绍了针对应用冷启动流程各阶段，一些注意事项和优化方法
希望通过本文的学习，开发者可以了解和识别应用启动耗时的问题，有助于开发者提升应用冷启动速度，提升用户体验。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-best-practices-long-list
爬取时间: 2025-05-01 08:49:40
来源: Huawei Developer
概述
列表是应用开发中最常见的一类开发场景，它可以将杂乱的信息整理成有规律、易于理解和操作的形式，便于用户查找和获取所需要的信息。应用程序中常见的列表场景有新闻列表、购物车列表、各类排行榜等。随着信息数据的累积，特别是一些新闻应用、购物应用、聊天应用，列表数据往往会达到上万条，针对这类大量数据加载的长列表应用，如何对长列表的性能进行优化是非常重要的。一个正确、高性能的长列表应用能明显降低列表渲染时间、提升页面的滑动帧率、降低应用内存占用，大幅提升用户体验。
针对长列表加载这一场景，本文将介绍如下5种优化手段，通过这些优化手段的单个使用或组合使用，可以对列表渲染时间、页面滑动帧率、应用内存占用等方面带来优化，提升性能和用户体验：
下文将以“HMOS世界”中首屏的长列表加载为例，通过5个测试来验证列表优化前后性能的收益，以证明这些优化手段的可行性。综合考虑业界共识指标和实际用户使用体验，测试将对比分析如下几个关键指标，这些关键指标的测量方法可以参考《帧率和丢帧分析实践》：
测试表明，使用LazyForEach懒加载这项技术后，相比ForEach这种加载方式，在列表数据量较小（100条内）且数据一次性全量加载不是性能瓶颈时，两者各项性能指标差异不大。但当列表数据较长特别是达到10000条数据量后，ForEach的各项性能指标会有“指数级别”的显著劣化，滑动会出现明显的卡顿，甚至会出现应用crash等现象；而LazyForEach因为采用了懒加载、缓存列表项、组件复用等技术后，能明显减少首屏完全显示所用时间，降低应用的独占内存，提高页面滑动帧率，带来更好的性能。其对比效果如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151143.79251514999402194031916282500982:50001231000000:2800:79663548BD6EEC767EA4ED480E3878832CC3F1E1EF5D5B6A5FE47C38A0514891.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151143.44828327365180500786193379774701:50001231000000:2800:8C497B138956CDD9FD35DC5974DA0DC2716B1E1B4577F48288719606E9296A53.gif)
懒加载
原理介绍
HarmonyOS应用框架为容器类组件的数据加载和渲染提供了2种方式：
-  通过循环渲染（ForEach）从数组中获取数据，并为每个数据项创建相应的组件，可减少代码复杂度。
```typescript
ForEach(
arr: any[],
itemGenerator: (item: any, index?: number) => void,
keyGenerator?: (item: any, index?: number) => string
)
```
-  通过数据懒加载（LazyForEach）从提供的数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。
ForEach
ForEach循环渲染的过程如下：
其数据加载、组件树挂载、页面渲染的示意图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151143.78691418724885785644814114007491:50001231000000:2800:9BCE1A5FD58FE7E5CB598F9D3B998460A81DAD1599DD5C6956820BD02CE7ED09.png)
如果列表数据较少，数据一次性全量加载不是性能瓶颈时，可以直接使用ForEach；但是当数据量大、组件结构复杂的情况下ForEach会出现性能瓶颈。这是因为要一次性加载所有的列表数据，创建所有组件节点并完成组件树的构建，在数据量大时会非常耗时，从而导致页面启动时间过长。另外，屏幕可视区外的组件虽然不会显示在屏幕上，但是仍然会占用内存。在系统处于高负载的情况下，更容易出现性能问题，极限情况下甚至会导致应用异常退出。
为了解决上述可能出现的问题，HarmonyOS应用框架进一步提供了懒加载方式 。
LazyForEach
LazyForEach懒加载的原理和渲染过程如下：
其数据加载、组件树挂载、页面渲染的示意图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151143.03671262128704215337596157350900:50001231000000:2800:D88649EF4526A32CF89C6AA859B3395AAE4212E017590A308FA71A92515C5588.png)
LazyForEach实现了按需加载，针对列表数据量大、列表组件复杂的场景，减少了页面首次启动时一次性加载数据的时间消耗，减少了内存峰值。不过在长列表滑动的过程中，因为需要根据用户的滑动行为不断地加载新的内容，这需要进行额外的数据请求和处理，会增加滑动时的计算量，从而对性能产生一定的影响。然而，合理使用LazyForEach的按需加载能力，通过在滑动停止或达到某个阈值时才进行加载，可以减少不必要的计算和请求，从而提高性能，给用户带来更好的体验。总之，在实现按需加载的场景中，需要综合考虑性能和用户体验的平衡，合理地优化加载逻辑和渲染方式，以提升整体的性能表现。
使用场景和规则
使用场景
上文了解到ForEach是从列表数据源一次性加载全量数据，且一次性并全部挂载在组件树上；LazyForEach是按需加载部分数据，只构建出一棵短小的组件树。针对数据加载和组件树构建这两个显著差异，可以对ForEach/LazyForEach做出如下选型判断：
| 渲染接口  | 选型原则  |
| --- | --- |
| ForEach  | 列表数据较少，数据一次性全量加载不是性能瓶颈时。ForEach相对LazyForEach，代码简单很多。  |
| LazyForEach  | 列表数据较长，一次性加载所有的列表数据创建、渲染页面产生性能瓶颈时。  |
渲染接口
选型原则
ForEach
列表数据较少，数据一次性全量加载不是性能瓶颈时。ForEach相对LazyForEach，代码简单很多。
LazyForEach
列表数据较长，一次性加载所有的列表数据创建、渲染页面产生性能瓶颈时。
使用规则
详细的使用规则可以参考ForEach的使用建议和LazyForEach的使用限制。
场景案例
为了对比List组件在不同数据量下使用ForEach和LazyForEach的性能差异，可以对相关代码进行了改造，先用ForEach对列表进行循环，再用LazyForEach对列表进行改造，得到如下两段关键代码：
LazyForEach的数据源首先需要开发者实现IDataSource接口，具体实现可参考“HMOS世界”中的相关代码（DiscoverView.ets）。
性能分析
针对长列表这一场景，在本地模拟了10、100、1000、10000条数据，分别使用ForEach、LazyForEach，来测试关闭和开启懒加载情况下的完全显示所用时间、列表挂载时间、独占内存，并分析了其滑动过程中的丢帧率。其中，列表挂载时间是指创建组件和组件挂载数据的总时长。最终，使用DevEco Studio的Profiler工具检测下述指标，得到的数据如下所示：
| ForEach对比指标  | 10条数据  | 100条数据  | 1000条数据  | 10000条数据  |
| --- | --- | --- | --- | --- |
| 完全显示所用时间  | 1s 741ms  | 1s 786ms  | 1s 942ms  | 5s 841ms  |
| 列表挂载时间  | 87ms  | 88ms  | 135ms  | 3s 291ms  |
| 独占内存（滑动完成后）  | 38.2MB  | 48.7MB  | 83.7MB  | 560.1MB  |
| 丢帧率  | 0.0%  | 3.8%  | 4.5%  | 58.2%  |
ForEach对比指标
10条数据
100条数据
1000条数据
10000条数据
完全显示所用时间
1s 741ms
1s 786ms
1s 942ms
5s 841ms
列表挂载时间
87ms
88ms
135ms
3s 291ms
独占内存（滑动完成后）
38.2MB
48.7MB
83.7MB
560.1MB
丢帧率
0.0%
3.8%
4.5%
58.2%
| LazyForEach对比指标  | 10条数据  | 100条数据  | 1000条数据  | 10000条数据  |
| --- | --- | --- | --- | --- |
| 完全显示所用时间  | 1s 544ms  | 1s 486ms  | 1s 652ms  | 1s 707ms  |
| 列表挂载时间  | 88ms  | 89ms  | 94ms  | 97ms  |
| 独占内存（滑动完成后）  | 38.1MB  | 44.6MB  | 46.3MB  | 82.9MB  |
| 丢帧率  | 0.0%  | 2.3%  | 3.6%  | 6.6%  |
LazyForEach对比指标
10条数据
100条数据
1000条数据
10000条数据
完全显示所用时间
1s 544ms
1s 486ms
1s 652ms
1s 707ms
列表挂载时间
88ms
89ms
94ms
97ms
独占内存（滑动完成后）
38.1MB
44.6MB
46.3MB
82.9MB
丢帧率
0.0%
2.3%
3.6%
6.6%
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151143.24208906617755334744029004563558:50001231000000:2800:E06D327DBC816DF1A44E140F4DE8B96799C12B830C8843E8A08B20C2F4E2D7F2.png)
从测试数据可以看出：
1.  以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。
缓存列表项
原理介绍
建议开发者优先使用Code Linter扫描工具进行代码检查，重点关注@performance/hp-arkui-set-cache-count-for-lazyforeach-grid规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。
从上文了解到，在进行列表加载时需要尽量避免一次性加载全部列表数据项，即推荐按需加载列表数据，但实际上这个“需”是有讲究的。例如本例中，页面一次可以显示6条数据，如果不提前缓存部分数据，当下滑到列表最底端时，再快速下滑，可能会引起“滑动白块”的现象。这是因为上一次只请求了屏幕上的6条数据，如果滑动速度过快，则会导致数据来不及加载而出现白块。在追求极致性能的同时，应该避免这样糟糕的用户体验。
LazyForEach懒加载可以通过设置cachedCount来指定缓存数量，在设置cachedCount后，除屏幕内显示的ListItem组件外，还会预先将屏幕可视区外指定数量的列表项数据缓存。这样当一个屏幕数据加载完成后，再次向下滑动时，会先加载上一次请求的数据，加载完成后，再加载本次请求的数据。LazyForEach添加了cachedCount缓存列表项后，其渲染过程如下：
其数据加载、组件树挂载、页面渲染的示意图如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151144.07649454654070915568828978872544:50001231000000:2800:2A6B3CDDBF1B4AAFB350707379F2FBD5A6E15BC2073D6BCDE09325F37CF91DA0.png)
使用场景和规则
使用场景
缓存列表项适合加载列表项数据请求比较耗时的场景。比如，滑动列表中含有短视频、高清图片等数据量比较大的资源，可以通过预先从网络加载并缓存相关数据，缩短渲染前的准备时间，提升列表响应速度。
使用规则
使用限制为：缓存列表项仅在使用LazyForEach懒加载时有效，ForEach循环渲染会一次性加载全量数据，故无法也不需要设置缓存列表项。
场景案例
在LazyForEach上添加缓存列表项后的关键代码如下所示：
性能分析
本文案例中的长列表一屏可以加载6条数据，为了测试不同缓存数量对丢帧率的影响，将cachedCount的值分别设为1、2、3、6、12、18、30个。基于示例程序，测试了不同缓存数量对帧率的影响情况，不设置缓存数量时（默认cachedCount=1），丢帧率为6.6%，当逐渐增加缓存数量时，丢帧率降低。当设置当前屏幕展示数量的一半，即缓存3个列表项时，丢帧率最低为3.7%。再增加缓存数量，丢帧率不再有显著的下降，增加缓存数量太多时，甚至会影响丢帧率。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151144.08943323643180762144724020709497:50001231000000:2800:C5CB2508389C1149DCBD4CEF86FC93CFA9EA7E3AB7739C2B00E76B89FB555669.png)
一般而言，缓存的cachedCount=n/2（n为一屏显示的列表数）的时候，效果较好。在实际开发中也要根据实际场景合理去设置缓存数量，例如列表项中需要显示网络数据，而网络数据加载较慢，为了提升列表信息的浏览效率和浏览体验，可以适当的多设置一些缓存数量（cachedCount大于n/2）；如果列表中需要加载一些大图或者视频等，这些数据占用的内存较大，为了减少内存占用，需要适当减少缓存数量的设置（cachedCount小于n/2）。因此，在实际场景中，需要不断尝试验证，设置适当的缓存数量，来达到体验和内存的平衡。
测试数据仅限于示例程序，不同的应用程序设置的最佳缓存数量不一致，需要针对应用程序测试得出最佳缓存数量。
动态预加载
原理介绍
从上文了解到LazyForEach懒加载可以通过设置cachedCount来指定缓存数量，解决当下滑到列表最底端时，再快速下滑，可能会引起“滑动白块”的现象。如若用户使用大量在线数据，实际上在弱网以及快速滑动的场景下依旧会在滑动过程中出现白块，如果将cachedCount设置比较大，滑动过程中可能不会出现白块，但是首屏加载时间过长。在追求极致性能的同时，应该避免这样糟糕的用户体验。
HarmonyOS提供了内容预取的能力Prefetcher，支持应用动态自适应网络状态，通过提前下载一些图片或资源，确保相关资源在需要时能立即显示，以尽可能减少白块出现的概率。
LazyForEach懒加载可以通过使用Prefetcher来预取和预渲染数据。在使用Prefetcher后，除屏幕内显示的ListItem组件外，还会预先将屏幕可视区外的部分列表项数据进行预渲染和预取。这样当列表向下滑动时，会先显示预渲染组件，屏幕可视区外会动态调整预取范围。预取逻辑在Prefetcher的BasicPrefetcher类中实现，BasicPrefetcher支持预取和预渲染（图像解码、添加到组件树等）过程分离、自适应调整预获取范围、优先加载可视区域、以及取消不必要任务（快速滚动列表的场景下，智能取消不必要任务），其渲染过程如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151144.03364502616309011298499984433118:50001231000000:2800:51241B4CE3643C66149ABA1539803426CE94D8AB4727ECAF647CD6FD33A381C3.png)
使用场景
动态预加载适合加载列表项数据请求比较耗时的场景。比如，滑动列表中含有图片等数据量比较大的资源，在LazyForEach的数据源中使用IDataSourcePrefetching的prefetch提前从网络加载并缓存相关数据，BasicPrefetcher则是在滚动体验和CPU节省方面有明显的提升。从这几个方面来提升应用的响应速度。
场景案例
实现DataSourcePrefetchingRCP类，继承IDataSourcePrefetching接口，并实现prefetch和cancel方法，如下代码所示
```typescript
import { SongInfoItem } from '../model/LearningResource';
import { HashMap } from '@kit.ArkTS';
import { fileIo } from '@kit.CoreFileKit';
import { IDataSourcePrefetching } from '@kit.ArkUI';
import { rcp } from '@kit.RemoteCommunicationKit';
let PREFETCH_ENABLED: boolean = false;
const CANCEL_CODE: number = 1007900992;
const IMADE_UNAVAILABLE = $r('app.media.startIcon');
export default class DataSourcePrefetching implements IDataSourcePrefetching {
private dataArray: Array<SongInfoItem>;
private listeners: DataChangeListener[] = [];
private readonly requestsInFlight: HashMap<number, rcp.Request> = new HashMap();
private readonly session: rcp.Session = rcp.createSession();
private readonly cachePath = getContext().getApplicationContext().cacheDir;
constructor(dataArray: Array<SongInfoItem>) {
this.dataArray = dataArray;
}
async prefetch(index: number): Promise<void> {
PREFETCH_ENABLED = true;
if (this.requestsInFlight.hasKey(index)) {
throw new Error('Already being prefetched')
}
const item = this.dataArray[index];
if (item.cachedImage) {
return;
}
// 数据请求
const request = new rcp.Request(item.albumUrl, 'GET');
// 缓存网络请求对象，便于在需要取消请求的时候进行处理
this.requestsInFlight.set(index, request);
try {
// 发送http请求获得响应
const response = await this.session.fetch(request);
if (response.statusCode !== 200 || !response.body) {
throw new Error('Bad response');
}
// 将加载的数据信息存储到缓存文件中
item.cachedImage = await this.cache(item.songId, response.body);
// 删除指定元素
this.requestsInFlight.remove(index);
} catch (err) {
if (err.code !== CANCEL_CODE) {
item.cachedImage = IMADE_UNAVAILABLE;
// 移除有异常的网络请求任务
this.requestsInFlight.remove(index);
}
throw err as Error;
}
}
cancel(index: number) {
if (this.requestsInFlight.hasKey(index)) {
// 返回MAP对象指定元素
const request = this.requestsInFlight.get(index);
// 取消数据请求
this.session.cancel(request);
// 移除被取消的网络请求对象
this.requestsInFlight.remove(index);
}
}
// ...
}
```
在应用列表界面，首先创建DataSourcePrefetchingRCP、BasicPrefetcher对象，然后在List的onScrollIndex回调中调用BasicPrefetcher的visibleAreaChanged方法，传入List的可见区域起始坐标。至此完成代码的优化。
```typescript
import { SongInfoItem } from '../model/LearningResource';
import DataSourcePrefetching from '../model/ArticleListData';
import { ObservedArray } from '../utils/ObservedArray';
import { ReusableArticleCardView } from '../components/ReusableArticleCardView';
import Constants from '../constants/Constants';
import PageViewModel from '../components/PageViewModel';
import { BasicPrefetcher } from '@kit.ArkUI';
@Entry
@Component
export struct LazyForEachListPage {
@State collectedIds: ObservedArray<string> = ['1', '2', '3', '4', '5', '6'];
@State likedIds: ObservedArray<string> = ['1', '2', '3', '4', '5', '6'];
@State isListReachEnd: boolean = false;
// 创建DataSourcePrefetching对象，具备任务预取、取消能力的数据源
private readonly dataSource = new DataSourcePrefetching(PageViewModel.getItems());
// 创建BasicPrefetcher对象，默认的动态预取算法实现
private readonly prefetcher = new BasicPrefetcher(this.dataSource);
build() {
Column() {
Header()
List({ space: Constants.SPACE_16 }) {
LazyForEach(this.dataSource, (item: SongInfoItem) => {
ListItem() {
ReusableArticleCardView({ articleItem: item })
}
.reuseId('article')
})
}
.cachedCount(5)
.onScrollIndex((start: number, end: number) => {
// 列表滚动触发visibleAreaChanged，实时更新预取范围，触发调用prefetch、cancel接口
this.prefetcher.visibleAreaChanged(start, end)
})
.width(Constants.FULL_SCREEN)
.height(Constants.FULL_SCREEN)
.padding({ left: 10, right: 10 })
.layoutWeight(1)
}
.backgroundColor($r('app.color.text_background'))
}
}
```
性能分析
本文案例中的长列表一屏可以加载6条数据，为了测试动态预加载方案与设置不同的cachedCount对应用性能的影响。来测试快速滑动场景下出现的白块数量、CPU开销占比以及首屏加载时长。如下对比场景设置数据cachedCount=5、cachedCount=40。最终，使用DevEco Studio的Profiler工具检测下述指标，得到的数据如下所示：
1.场景滑动对比
| cachedCount=5  | cachedCount=40  | 动态预加载  |
| --- | --- | --- |
|   |   |   |
cachedCount=5
cachedCount=40
动态预加载
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151144.72286919307150730751808506732490:50001231000000:2800:2AF47AD510501A23166990DD7958C100809D37DD6459C46C0D39A45614FF5285.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151144.49322673994135746319167638016414:50001231000000:2800:713C9108F0170438B88AE0E091A8E8D6100BC1C97092DDA661EC4FEABD048923.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151144.47441163564009834581779234291388:50001231000000:2800:DBF0801A88FC7C5BCF7DB793296F1C33FB31D1E3901DC8F1436AA8A28234660A.gif)
| 数据设置  | 首屏加载  | 滑动过程滑块数量  |
| --- | --- | --- |
| cachedCount=5  | 首屏加载快  | 滑动过程中白块很多  |
| cachedCount=40  | 首屏加载慢  | 滑动过程中没有白块或很少  |
| 动态预加载  | 首屏加载快  | 滑动过程中没有白块或很少  |
数据设置
首屏加载
滑动过程滑块数量
cachedCount=5
首屏加载快
滑动过程中白块很多
cachedCount=40
首屏加载慢
滑动过程中没有白块或很少
动态预加载
首屏加载快
滑动过程中没有白块或很少
2. CPU开销对比
利用Profiler工具分析得到相关trace图，追踪流程为应用侧的APP_LIST_FLING（列表从开始滚动到结束）的整个过程，从而观察应用的CPU占比。（注：不同设备特性和具体应用场景的多样性，所获得的性能数据存在差异，提供的数值仅供参考）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151144.41711720642216232705258384428441:50001231000000:2800:9DF467872BFAD754048D33169B4F78ADFFB91D06A2CB66EA0AEC8176DE59D79A.png)
cachedCount=5 CPU占比为3.96%
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151144.20380907774828687424205952362833:50001231000000:2800:68282B5CE628BA1761F37AB0F1EA602E0C0A59666E972A4FBDFBA7AD80A98607.png)
cachedCount=40 CPU占比为5.04%
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151144.64409485764872498848552841047908:50001231000000:2800:02F53D818C3FD0F3FFF28BEB95DD2FA70CE3CFBFA77BCCB92E592AC96BC3F413.png)
动态预加载CPU占比为4.12%
| 数据设置  | CPU占比  |
| --- | --- |
| cachedCount=5  | 3.96%  |
| cachedCount=40  | 5.04%  |
| 动态预加载  | 4.12%  |
数据设置
CPU占比
cachedCount=5
3.96%
cachedCount=40
5.04%
动态预加载
4.12%
3. 首屏加载时长对比
利用Profiler工具分析得到相关trace图，追踪流程从Create Process（应用进程创建阶段）标签开始，到首屏全部图片加载完毕结束，从而观察应用的首屏加载时长。（注：不同设备特性和具体应用场景的多样性，所获得的性能数据存在差异，提供的数值仅供参考）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151145.70350224554781435885246206439367:50001231000000:2800:E0CDCBF278E7A990CB45593D73A13A63F68F452221739742945D0FEC04609858.png)
cachedCount=5 首屏加载时长为530.4ms
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151145.98232155449306786002146669011837:50001231000000:2800:CE17A9479D686F3152398379EA87D04255A94781C9427652233F5E4D545F6C09.png)
cachedCount=40 首屏加载时长为1.8s
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151145.99809147323305128609976440987465:50001231000000:2800:F94B0D7783B7F3061E8F44363461DAE017D003CA0E9312A8FED57D67B435C901.png)
动态预加载首屏加载时长为545.5ms
| 数据设置  | 首屏加载时长  |
| --- | --- |
| cachedCount=5  | 530.4ms  |
| cachedCount=40  | 1.8s  |
| 动态预加载  | 545.5ms  |
数据设置
首屏加载时长
cachedCount=5
530.4ms
cachedCount=40
1.8s
动态预加载
545.5ms
从实验数据可以看出：
1）当cachedCount=5时，首屏加载时间短，滑动过程中出现大量白块，滑动时CPU占比较小。
2）当cachedCount=40时，首屏加载时间过长，滑动过程中并未出现白块，滑动时CPU占比较大。
3）当在cachedCount=5时的基础上设置动态预加载时，首屏加载时间短，滑动过程中并未出现白块，滑动时CPU占比较小。
因此当用户使用LazyForEach在线加载含有图片等数据量比较大的资源时，可以考虑使用动态预加载来预防弱网以及快速滑动场景中出现的白块问题。
测试数据仅限于示例程序，不同设备特性和具体应用场景的多样性，所获得的性能数据存在差异，提供的数值仅供参考。
组件复用
原理介绍
HarmonyOS应用框架提供了组件复用能力，可复用组件从组件树上移除时，会进入到一个回收缓存区。后续创建新组件节点时，会复用缓存区中的节点，节约组件重新创建的时间。尤其在列表等场景下，其自定义子组件具有相同的组件布局结构，列表更新时仅有状态变量等数据差异。通过组件复用可以提高列表页面的加载速度和响应速度。
组件复用机制如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151145.65278318262542442251987705129521:50001231000000:2800:9D4E3B1D374CC917760BF3B1559C064FF44506C5F1D58FE0CEC970BD3F2AC175.png)
组件复用生效的条件是：
名词介绍：
使用场景和规则
使用场景
若业务实现中存在以下场景，并成为UI线程的帧率瓶颈，推荐使用组件复用：
以上场景中，为了避免UI线程的帧率瓶颈问题，推荐使用组件复用来提高应用的性能和用户体验。组件复用可以避免不必要的视图创建和销毁，减少布局计算和绘制操作，从而提高界面的流畅度和响应速度。
使用规则
组件复用的使用规则如下：
组件复用可以节省创建时间和复用组件树结构，提高应用性能。开发者需要注意处理自定义组件的创建和更新流程，以及限制复用范围和特定触发场景，才能实现组件复用的效果。
场景案例
下面的代码片段是在缓存列表项的基础上增加的组件复用的相关代码，组件复用需要首先在复用的组件上添加@Reusable注解，然后实现aboutToReuse方法，关键代码如下：
```typescript
@Component
@Reusable
export struct ReusableArticleCardView {
@Prop articleItem: LearningResource = new LearningResource();
@Prop isCollected: boolean = false;
@Prop isLiked: boolean = false;
onCollected?: () => void;
onLiked?: () => void;
aboutToReuse(params: Record<string, Object>): void {
this.onCollected = params.onCollected as () => void;
this.onLiked = params.onLiked as () => void;
}
build() {
// ...
}
}
```
无需对@Prop修饰的变量进行赋值，因为这些变量是由父组件传递给子组件的。如果在子组件中重新赋值这些变量，会导致重用的组件的内容重新触发状态刷新，从而降低组件的复用性能。相反，只需要在aboutToReuse方法中对onCollected和onLiked这两个函数进行重新赋值即可。
最后，还需要去设置可复用组件的reuseId，关键代码如下所示：
需要注意的是复用组件中有@Builder自定义构建函数时，状态变量推荐使用按引用传递。@Builder装饰的函数默认按值传递，当传递的参数为状态变量时，状态变量的改变不会引起@Builder方法内的UI刷新。
性能分析
组件未复用时
上文已经将ForEach改造为了LazyForEach，并且添加了缓存项（cachedCount=3），当匀速滑动这个列表时，每隔若干帧时会稳定的丢帧，且会规律、重复的出现这个问题，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151146.94506502359643010519868891071198:50001231000000:2800:267678692877F50E802ADE2609B9645009E90E29B715CF9EB26C639AF2EC8A8E.png)
从图中可以看见，泳道中红色和绿色间隔出现，其中红色区域表示丢帧，绿色表示正常，对红色丢帧区域进行耗时分析：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151146.16373162170102167750504221729565:50001231000000:2800:F77FE9117D3C4E837C3FBA083BB8C294F424DFC56DF6789030D30C0A66A4FC01.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151146.38266378619127098393006562387758:50001231000000:2800:F5F443F31353D5E8206D93DD970232C8A41B53030F9446E61B517B44BEBC492F.png)
图中红色区域出现了丢帧，这是因为缓存区中的最上面的一个ListItem渲染到页面上时，会执行BuildLazyItem操作，此部分会耗时10.277ms，导致本帧总体耗时达到了13.430ms，超过了11.1ms而丢帧。
组件复用后
将代码进行改造，对复用组件ArticleCardView添加@Reusable注解，启用组件复用的相关代码后，以相同均匀速度滑动这个列表，得到的应用帧率检测情况如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151146.39485447338110398612036653994431:50001231000000:2800:B643164DBC136B18D9981E800639F7E2180AAE80B56BCD96C30B9A74B654F856.png)
上图中列表快速滑动了15.8s，泳道中全是绿色表示无丢帧出现，丢帧率为0%。对其中某一帧放大分析，得到如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151146.48454424877490538914472740345266:50001231000000:2800:93DE68FA140998618718A4531B2618623E07B45EC3262FE4920C03078B9452BA.png)
此部分的BuildLazyItem只耗时0.749ms，远远低于之前未进行复用的10.277ms，对复用前后的耗时进行分析，得到的数据如下表所示：
| 组件复用  | 组件复用前  | 组件复用后  |
| --- | --- | --- |
| 丢帧率  | 3.7%  | 0%  |
| BuildLazyItem耗时  | 10.277ms  | 0.749ms  |
| BuildRecycle耗时  | 不涉及  | 0.221ms  |
| 总耗时  | 13.430ms  | 7.310ms  |
组件复用
组件复用前
组件复用后
丢帧率
3.7%
0%
BuildLazyItem耗时
10.277ms
0.749ms
BuildRecycle耗时
不涉及
0.221ms
总耗时
13.430ms
7.310ms
可以发现之前的丢帧情况得到明显缓解，从图19可以看出，列表滑动时（15.8s的区间段内）都是绿色，丢帧率为0%，不会出现图16中“有规律、且重复”的红色丢帧情况。这是因为，List列表开启了组件复用，不会执行BuildLazyItem这个耗时操作（耗时10.277ms），后续创建新组件节点时，会直接复用缓存区中的节点（耗时0.97ms），这样就大幅节约了组件重新创建的时间。
以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。
布局优化
原理介绍
列表不同于其他布局，包含了大量重复循环的ListItem，所以对每一个ListItem的布局优化格外重要。错误的布局方式可能会导致组件树和嵌套层数过多，在创建和布局绘制阶段产生较大的性能开销，导致界面卡顿。合理使用布局，减少嵌套层数，能提高布局效率。
针对“HMOS世界” 中首屏的长列表，可以对ListItem进行布局优化，把线性布局修改为相对布局，就可以将最大嵌套层级从5层降低到2层。当进行列表循环渲染的时候，特别是当数据量大时，就能对页面性能产生一定的优化。当然这个例子还过于简单，优化空间是有限的；但是当列表元素较为复杂时，通过减少布局嵌套层级，减少过度绘制可以产生较大的性能收益。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151146.00003017705239625839334293194988:50001231000000:2800:B964A4CB25BCA3523487281B8023F3400BCBD226012D8B3378B87ABC4E49E2B8.png)
场景案例
为了对比布局嵌套层级对List列表滑动性能的影响，对相关代码进行了改造，原始代码是线性布局，最大嵌套层级为5层；通过相对布局对代码进行优化，使得其最大嵌套层级为2层；同时，刻意将布局进行过度嵌套，使得其最大嵌套层级为25层。案例的示例代码如下所示：
性能分析
本文案例中刻意将布局进行嵌套，分析正常情况和过度嵌套情况下应用独占内存、页面滑动帧率、丢帧率的情况对比，开发者可以使用DevEco Studio中ArkUI Inspector查看页面的嵌套层级，如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151146.76366399582457372393669205534012:50001231000000:2800:211839E8CC7D708DDC58E42F0EFFC59D153652357841CA5D7B5A2C69F52514C9.png)
快速滑动10000条数据后，得到了布局嵌套层级对列表性能影响对比，如下所示：
| 布局  | 相对布局（2层）  | 线性布局（5层）  | 额外嵌套的线性布局（25层）  |
| --- | --- | --- | --- |
| 独占内存  | 78.4MB  | 80.1MB  | 153.7MB  |
| 丢帧率  | 0%  | 0%  | 2.3%  |
布局
相对布局（2层）
线性布局（5层）
额外嵌套的线性布局（25层）
独占内存
78.4MB
80.1MB
153.7MB
丢帧率
0%
0%
2.3%
可以看出，因为布局过度嵌套会导致应用内存增加，且会影响应用的帧率导致丢帧增加，所以开发者在写列表这类循环组件的代码时，需要特别考虑对其布局进行优化。一般而言布局的最大嵌套层级控制在5-8层左右即可，过度的优化布局会导致代码开发难度加大，代码不易于阅读理解，增加后续的维护成本，不利于多设备的适配，且也不会带来特别显著的性能提升。
总结与回顾
针对长列表这一场景，在本地模拟了10、100、1000、10000条数据，分别使用ForEach、LazyForEach，测试关闭和开启懒加载的完全显示所用时间、丢帧率、应用独占内存等各项指标。测试表明，使用LazyForEach懒加载这项技术后，相比ForEach这种加载方式，在列表数据量较小（100条内）且数据一次性全量加载不是性能瓶颈时，两者各项性能指标差异不大。但当列表数据较长特别是达到10000条数据量后，ForEach的上述4项性能指标会有“指数级别”的显著劣化，滑动会出现明显的卡顿，甚至会出现应用crash等现象；而LazyForEach因为采用了懒加载技术能明显减少首屏完全显示所用时间，降低应用的独占内存，提高页面滑动帧率，带来更好的性能。在10000条数据量下，其各项对比指标数据如下所示：
| 性能指标  | ForEach  | LazyForEach  | 缓存列表项  | 组件复用后  | 布局优化后  |
| --- | --- | --- | --- | --- | --- |
| 完全显示所用时间  | 5s 841ms  | 1s 707ms  | 1s 658ms  | 1s 564ms  | 1s 339ms  |
| 丢帧率  | 58.2%  | 6.6%  | 3.7%  | 0.0%  | 0.0%  |
| 独占内存  | 560.1MB  | 82.9MB  | 81.7MB  | 80.1MB  | 78.4MB  |
性能指标
ForEach
LazyForEach
缓存列表项
组件复用后
布局优化后
完全显示所用时间
5s 841ms
1s 707ms
1s 658ms
1s 564ms
1s 339ms
丢帧率
58.2%
6.6%
3.7%
0.0%
0.0%
独占内存
560.1MB
82.9MB
81.7MB
80.1MB
78.4MB
另外测试还表明，在使用LazyForEach时，合理添加缓存列表项，能带来列表滑动帧率的提升（提升2.9%），减少“滑动白块”的出现；使用组件复用这项技术后，因省去了组件频繁创建这一耗时操作，故能明显减少“有规律、且重复”的丢帧现象，提高列表页面的加载速度和响应速度，丢帧率会降低3.7%。测试还证明了对页面进行布局优化在大数据量下能对页面性能产生一定的优化。
需要指出的是，ForEach、LazyForEach、缓存列表项、组件复用、布局优化是在本地模拟的10000条数据，是在同等情况下，采用控制变量的方法对ForEach和LazyForEach进行压力测试而得出的数据结论。动态预加载则是模拟在弱网以及快速滑动的状态下加载数据测试而得出的数据结论。当利用网络数据来探讨LazyForEach代码如何进行网络数据的加载和优化时，可以使用动态预加载，使用动态预加载这项技术后，因将预取和预渲染分离且在滑动过程中实时更新列表项、预取数据和预渲染数据，故能在弱网和快速滑动场景中明显减少滑动过程中出现的白块现象。
以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-waterflow-performance-optimization
爬取时间: 2025-05-01 08:49:54
来源: Huawei Developer
概述
瀑布流是应用开发中相当常见的开发场景。它通过容器自身的布局规则，将元素项目自上而下排列，在整体界面的呈现上，多列参差不齐、不停加载的形式使其内容看着像瀑布一样从上而下倾泻。借助其特点，瀑布流通常被用于展示图片资讯、购物商品、直播视频等多种形式的数据。当瀑布流上下滑动时，由于无限加载的特性，其能展示的数目非常多；大小不一的子元素，也带来了测量绘制的性能消耗。
针对瀑布流这种场景进行性能优化，可以在加快渲染速度、提升滑动帧率、降低内存占用等方面，增强应用的运行效率，进而提升用户的操作体验。
下面分别介绍优化瀑布流性能的主要方法。
懒加载
先看一下组件示例代码中瀑布流的基本用法：
```typescript
build() {
Column({ space: 2 }) {
WaterFlow() {
LazyForEach(this.datasource, (item: number) => {
FlowItem() {
Column() {
Text("N" + item).fontSize(12).height('16')
Image('res/waterFlowTest (' + item % 5 + ').jpg')
.objectFit(ImageFit.Fill)
.width('100%')
.layoutWeight(1)
}
}
.width('100%')
.height(this.itemHeightArray[item])
.backgroundColor(this.colors[item % 5])
}, (item: string) => item)
}
.columnsTemplate("1fr 1fr")
.columnsGap(10)
.rowsGap(5)
.backgroundColor(0xFAEEE0)
.width('100%')
.height('80%')
}
}
```
示例代码已经使用了LazyForEach进行数据懒加载，WaterFlow布局时会根据可视区域按需创建FlowItem组件，并在FlowItem滑出可视区域外时销毁以降低内存占用。
瀑布流的开发，也属于长列表加载的一种场景，其LazyForEach懒加载原理及性能分析可参考：《长列表加载性能优化-懒加载》
缓存数据项
LazyForEach懒加载可以通过设置cachedCount来指定缓存数量，在设置cachedCount后，除屏幕内显示的Item组件外，还会预先将屏幕可视区外指定数量的数据缓存。这样当一个屏幕数据加载完成后，再次向下滑动时，会先加载上一次请求的数据，加载完成后，再加载本次请求的数据。
详细原理及性能分析参考：《长列表加载性能优化-缓存列表项》
组件复用
在滑动场景中，由于FlowItem及其子组件的频繁创建与销毁，建议将FlowItem中的组件封装为自定义组件，并使用@Reusable装饰器进行修饰，以增强组件的复用能力，从而减少ArkUI框架内部重复创建和销毁节点的开销。
另外，@Reusable装饰器实现的组件复用是限定在父组件内的，如果需要支持全局范围的组件复用，可使用全局组件复用池三方库。
组件复用详细原理及性能分析参考：《长列表加载性能优化-组件复用》
全局组件复用池三方库：nodepool
无限滑动
实际开发过程中，瀑布流布局里的数据一般不会一次性加载完全部数据，而是每次加载一定量的数据。这样的话，就需要在应用滑动时加载数据。同时，如果在滑动过程中就加载了新的数据，那么配合懒加载与缓存列表项的话，缓存中的数据在未使用完就能得到补充，因此用户滑动中就不会感觉到数据加载，从而实现无限滑动的效果（具体效果参见实践总结章节）。同时，由于提前加载了数据，因此不会在某一时刻存在大量组件需要创建渲染的情况，减少了因同一时间创建大量组件而导致丢帧的情况。
对应场景下，需通过在一些事件中加载数据的方式来实现无限滑动。例如：瀑布流触底方法（onReachEnd）、瀑布流组件滑动index变化事件（onScrollIndex）。
相关流程如下：
瀑布流组件加载流程图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151147.02073991786507211658174170538775:50001231000000:2800:1E056DE0F63FA306DCA3B963432B507621197410C19BE5DD93A1B1BC6A029770.png)
代码中使用的是onScrollIndex加载数据，示例如下：
固定宽高
与长列表不同的，瀑布流布局中各个卡片的高度是不同的，这就对瀑布流布局绘制提出了新的挑战。瀑布流的卡片高度是由瀑布流卡片自适应瀑布流的宽度得到的，因此卡片的高度无法直接指定。这就会使卡片渲染以后得到的高度与占位符的高度不一致，从而造成卡片的闪烁效果。
固定宽高后，就可以在UI描述时指定组件的宽高数值。如果组件本身的宽高是固定的，理论上来讲，该组件在布局阶段不会参与measure阶段，其节点中保存了对应的大小信息，当瀑布流内容较多时，由于避免了组件整体的测算过程，性能会带来一定的提升。
另外，由于Image组件默认异步加载，提前设定FlowItem的高度，可以避免图片加载成功后高度变化触发的瀑布流布局刷新。
详细内容请参考：利用布局边界减少布局计算
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151147.86051833030072479273520015094417:50001231000000:2800:C4CF40957003824C1E99F749C7E7211E31D702521ECE54972864B99CA71E90F7.png)
如上图所示，两列瀑布流卡片的宽度 = （屏幕宽度 - 2 * 组件外边距（margin） - 瀑布流组件内边距（gap））/ 2。
瀑布流卡片中图片的高度imageHeight = 图片原始高度 / 图片原始宽度 * 瀑布流卡片宽度。
瀑布流卡片中描述性的高度titleHeight根据标题长度不同需设置不同的高度，其计算逻辑如下代码所示：
瀑布流卡片的高度 = imageHeight + titleHeight。
实践总结
本文以一个瀑布流案例，使用上述提到的部分优化手段，实现了页面的流畅滑动。本案例页面包含SearchBar + Swiper + WaterFlow + 底部导航栏等功能，顶部功能区由Swiper嵌套Grid组件实现，瀑布流使用WaterFlow组件实现，FlowItem组件内容由图文卡片、视频卡片、直播卡片构成，每个列表项中标题文本和用户信息结构是相同的，对相同UI结构进行了复用，避免了无用的层级嵌套。
整体效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151147.11948102484984483099469133558714:50001231000000:2800:D16C2479AD2081B668CE74F20AF6B309DB2154FE46A0755D379E35D068AEB487.png)
下表为通过网络请求500条数据加载渲染，测试获得的数据（数据测试方式采用技术从左向右累加测试的）：
|  性能指标 |  ForEach |  LazyForEach |  缓存数据项 |  组件复用 |  固定宽高 |
| --- | --- | --- | --- | --- | --- |
|  首次渲染时间 |  1346ms |  756ms |  752ms |  760ms |  761ms |
|  丢帧率 |  2.20% |  1.00% |  0.50% |  0.2% |  0.00% |
|  独占内存 |  485M |  122M |  136.6M |  106.8M |  103.3M |
性能指标
ForEach
LazyForEach
缓存数据项
组件复用
固定宽高
首次渲染时间
1346ms
756ms
752ms
760ms
761ms
丢帧率
2.20%
1.00%
0.50%
0.2%
0.00%
独占内存
485M
122M
136.6M
106.8M
103.3M
从测试结果可以看出，使用LazyForEach懒加载后，相关指标已经得到大幅度提高，尤其是内存和首次渲染时间。其他优化方式可以进一步减少滑动过程的中丢帧率，优化交互体验。缓存数据项，因为缓存加载的数据未在首屏展示，所以对首次渲染时间有影响，但是因为需要加载多余的数据，所以内存会比没使用缓存数据项的多。因为UI组件的复用，所以内存比没有使用组件复用少很多。
最后，对于瀑布流性能优化方式，整体与长列表优化类似，都可以使用懒加载、缓存列表项、动态预加载、组件复用、布局优化等方式优化性能。固定宽高作为瀑布流特有的优化性能手段能够进一步提升瀑布流的性能，同时可以避免新加载元素瞬间刷新带来的"闪烁"问题。在滑动过程中加载数据，可以避免同一时间创建大量组件而导致丢帧的情况。相应技术总结见下表：
|  技术名称 |  适用场景 |  参考文章 |
| --- | --- | --- |
|  懒加载 |  使适用于瀑布流需要一次性加载并渲染大量数据而造成性能瓶颈问题的场景。 |  长列表加载性能优化、 使用懒加载优化性能、 数据懒加载 |
|  缓存列表项 |  适用于加载列表项数据请求比较耗时的场景。比如，瀑布流列表中含有短视频、高清图片等数据量比较大的资源。 |  长列表加载性能优化 |
|  组件复用 |  适用于瀑布流中存在大量结构相同的组件频繁创建与销毁的场景而造成性能瓶颈问题的场景。 |  组件复用最佳实践 |
|  固定宽高 |  适用于瀑布流页面组件高度不一的场景。 |  利用布局边界减少布局计算 |
|  布局优化 |  错误的布局方式可能会导致组件树和嵌套层数过多，在创建和布局绘制阶段产生较大的性能开销，所以可以通过布局优化提升性能。 |  合理使用布局 |
|  状态管理 |  在ArkUI的开发过程中，如果没有选择合适的装饰器或合理的控制状态更新范围，会导致非必要的UI视图刷新，造成性能浪费。 |  状态管理最佳实践 |
技术名称
适用场景
参考文章
懒加载
使适用于瀑布流需要一次性加载并渲染大量数据而造成性能瓶颈问题的场景。
长列表加载性能优化、
使用懒加载优化性能、
数据懒加载
缓存列表项
适用于加载列表项数据请求比较耗时的场景。比如，瀑布流列表中含有短视频、高清图片等数据量比较大的资源。
长列表加载性能优化
组件复用
适用于瀑布流中存在大量结构相同的组件频繁创建与销毁的场景而造成性能瓶颈问题的场景。
组件复用最佳实践
固定宽高
适用于瀑布流页面组件高度不一的场景。
利用布局边界减少布局计算
布局优化
错误的布局方式可能会导致组件树和嵌套层数过多，在创建和布局绘制阶段产生较大的性能开销，所以可以通过布局优化提升性能。
合理使用布局
状态管理
在ArkUI的开发过程中，如果没有选择合适的装饰器或合理的控制状态更新范围，会导致非必要的UI视图刷新，造成性能浪费。
状态管理最佳实践
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-improve_grid_performance
爬取时间: 2025-05-01 08:50:07
来源: Huawei Developer
概述
在实现如下图所示可滚动布局效果时，可能会通过columnStart/columnEnd对GridItem设置其占有行列数，实现不规则的布局效果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151147.90095581691550841951257467602738:50001231000000:2800:D21838153ADF587B9E3C8DBADC764918F8B7CDB7C297CEFA0A69D40CB0A0E1E3.png)
如果遇到如下的使用场景，使用columnStart/columnEnd可能会造成性能问题：
Grid中存在大量GridItem，当使用columnStart/columnEnd、rowStart/rowEnd设置GridItem大小，该场景下耗时过长时，应该考虑使用GridLayoutOptions提升性能。使用columnStart/columnEnd、rowStart/rowEnd布局，在scrollToIndex滑动指定Index时，Grid会遍历GridItem去查找位置。而使用GridLayoutOptions布局，在scrollToIndex滑动指定Index时，则是通过计算方式去查找位置，查找GridItem位置效率更高。对此，可以通过GridLayoutOptions布局选项，配合rowsTemplate、columnsTemplate仅设置其中一个的Grid使用，替代通过columnStart/columnEnd控制GridItem占用多列的情况
案例说明
场景示例
下面介绍Grid中使用scrollToIndex滑动到指定位置的场景为例。在案例中采用了columnStart/columnEnd设置了不规则的宫格布局的反例，以及与GridLayoutOption的正例进行对比，示例代码如下：
反例：使用columnStart，columnEnd设置GridItem大小。
```typescript
// 导入性能打点模块
import hiTraceMeter from '@ohos.hiTraceMeter';
@Component
struct TextItem {
@State item: string = "";
build() {
Text(this.item)
.fontSize(16)
.backgroundColor(0xF9CF93)
.width('100%')
.height(80)
.textAlign(TextAlign.Center)
}
aboutToAppear() {
// 结束打点任务
hiTraceMeter.finishTrace("useColumnStartColumnEnd", 1);
}
}
class MyDataSource implements IDataSource {
private dataArray: string[] = [];
public pushData(data: string): void {
this.dataArray.push(data);
}
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
registerDataChangeListener(listener: DataChangeListener): void {
}
unregisterDataChangeListener(listener: DataChangeListener): void {
}
}
@Entry
@Component
struct GridExample {
private datasource: MyDataSource = new MyDataSource();
scroller: Scroller = new Scroller();
aboutToAppear() {
for (let i = 1; i <= 2000; i++) {
this.datasource.pushData(i + '');
}
}
build() {
Column({ space: 5 }) {
Text('使用columnStart,columnEnd设置GridItem大小').fontColor(0xCCCCCC).fontSize(9).width('90%')
Grid(this.scroller) {
LazyForEach(this.datasource, (item: string, index: number) => {
if ((index % 4) === 0) {
GridItem() {
TextItem({ item: item })
}
.columnStart(0).columnEnd(2)
} else {
GridItem() {
TextItem({ item: item })
}
}
}, (item: string) => item)
}
.columnsTemplate('1fr 1fr 1fr')
.columnsGap(10)
.rowsGap(10)
.width('90%')
.height('40%')
Button("scrollToIndex:1900").onClick(() => {
// 开始打点任务
hiTraceMeter.startTrace("useColumnStartColumnEnd", 1);
this.scroller.scrollToIndex(1900);
})
}.width('100%')
.margin({ top: 5 })
}
}
```
正例：使用GridLayoutOptions设置GridItem大小，布局效果和反例保持一致。
```typescript
// 导入性能打点模块
import hiTraceMeter from '@ohos.hiTraceMeter';
@Component
struct TextItem {
@State item: string = "";
build() {
Text(this.item)
.fontSize(16)
.backgroundColor(0xF9CF93)
.width('100%')
.height(80)
.textAlign(TextAlign.Center)
}
aboutToAppear() {
// 结束打点任务
hiTraceMeter.finishTrace("useGridLayoutOptions", 1);
}
}
class MyDataSource implements IDataSource {
private dataArray: string[] = [];
public pushData(data: string): void {
this.dataArray.push(data);
}
public totalCount(): number {
return this.dataArray.length;
}
public getData(index: number): string {
return this.dataArray[index];
}
registerDataChangeListener(listener: DataChangeListener): void {
}
unregisterDataChangeListener(listener: DataChangeListener): void {
}
}
@Component
export struct GridExample2 {
private datasource: MyDataSource = new MyDataSource();
scroller: Scroller = new Scroller();
private irregularData: number[] = [];
layoutOptions: GridLayoutOptions = {
regularSize: [1, 1],
irregularIndexes: this.irregularData,
};
aboutToAppear() {
for (let i = 1; i <= 2000; i++) {
this.datasource.pushData(i + '');
if ((i - 1) % 4 === 0) {
this.irregularData.push(i - 1);
}
}
}
build() {
Column({ space: 5 }) {
Text('使用GridLayoutOptions设置GridItem大小').fontColor(0xCCCCCC).fontSize(9).width('90%')
Grid(this.scroller, this.layoutOptions) {
LazyForEach(this.datasource, (item: string, index: number) => {
GridItem() {
TextItem({ item: item })
}
}, (item: string) => item)
}
.columnsTemplate('1fr 1fr 1fr')
.columnsGap(10)
.rowsGap(10)
.width('90%')
.height('40%')
Button("scrollToIndex:1900").onClick(() => {
// 开始打点任务
hiTraceMeter.startTrace("useGridLayoutOptions", 1);
this.scroller.scrollToIndex(1900);
})
}.width('100%')
.margin({ top: 5 })
}
}
```
分析步骤
正反例采用相同的操作步骤，收集跳转过程中的性能参数，并进行对比：
1.
2.
3.
4.  打点事件说明：当Grid查找到指定GridItem位置，准备渲染GridItem节点前，会进入GridItem自定义组件的生命周期回调aboutToAppear，在aboutToAppear里使用finishTrace停止性能打点跟踪。通过性能打点方式，使用startTrace标记调用scrollToIndex作为开始打点的位置，使用finishTrace标记查找到指定位置后准备渲染首个GridItem节点作为结束打点位置，来对比正反例场景下的耗时数据。关于本例中使用性能打点的介绍，请参考性能打点
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151148.10393267674064235300072015442012:50001231000000:2800:A40AE8B5A7C55BA7DA41519D4531C3772B27149EA4AC7DB3BAAEF66ADF77803E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151148.27266514281627716035290310014717:50001231000000:2800:5D097D8F0BA537C87A014602596DB4C2948AF2DBA73516464D53D182EC890474.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151148.13372042289307287263696466221636:50001231000000:2800:0D5F56F7FC13E2B14CFA65B6607BFB65F66C61AE5F6B85B42CA6A70E38100FAB.png)
结果对比
如图所示，使用columnStart，columnEnd设置GridItem大小的布局方式，从自定义打点标签“H:useColumnStartColumnEndGrid”上可以看出从调用scrollToIndex到查找到指定Index准备构建GridItem节点耗时447ms。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151148.01938193899182588746498311781973:50001231000000:2800:EBA33FDAEA9ABD681E5AFE6A29A74AA4B0E7A22061525497259F76929B87BADE.png)
如图3所示，使用GridLayoutOptions设置GridItem大小的布局方式，从自定义打点标签“H:useGridLayoutOption”上可以看出从调用scrollToIndex到查找到指定Index准备构建GridItem节点耗时12ms。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151148.84727475451250775498942242305721:50001231000000:2800:C0045687BBE08D89ED8608A57290A112884932443902D1AEDB4E717CCC936F4F.png)
从详细的trace进行分析可以发现，在“H:useColumnStartColumnEndGrid”打点标签时间段中存在大量的“H:Builder:BuildLazyItem”标签，可以发现Grid在查找指定的Index：1900是依次遍历Index来查找的。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151148.75114508248686014048574803232457:50001231000000:2800:99656F5C924E474DD19CE38CE2A45594FF9724553989EAA9A008D57CE21ECCA3.png)
而使用GridLayoutOption的示例中，在“H:useGridLayoutOptions”打点标签时间段中只存在一个“H:Builder:BuildLazyItem”标签，可以发现Grid在查找指定Index：1900是直接一次查找到指定Index的。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151148.53898748991934741757740630768537:50001231000000:2800:8C70FDFA99618A5363FF6AF48B80C1952696552F89F0567391C37D5E1FFDA1E6.png)
通过上述分析可以发现，在相同布局情况下，使用columnStart，columnEnd设置GridItem大小的方式，Grid在使用scrollToIndex查找指定Index时，会依次遍历GridItem节点，查找过程耗时较长。而使用GridLayoutOptions设置GridItem大小的方式，是直接一次性计算找到指定Index，查找过程耗时较短。所以使用GridLayoutOptions设置GridItem大小的方式，能够有效减少Grid加载时间，提升应用性能。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-swiper_high_performance_development_guide
爬取时间: 2025-05-01 08:50:21
来源: Huawei Developer
概述
在应用开发中，Swiper组件常用于翻页场景，比如：桌面、图库等应用。Swiper组件滑动切换页面时，基于按需加载原则通常会在下一个页面将要显示时才对该页面进行加载和布局绘制。针对复杂页面场景，该过程可能会持续较长时间，导致滑动过程中出现卡顿，对滑动体验造成负面影响，甚至成为整个应用的性能瓶颈。
本文主要介绍Swiper性能优化的相关方法。
懒加载
原理介绍
懒加载LazyForEach从提供的数据源按需迭代数据，并在每次迭代过程中创建相应的组件，Swiper采用LazyForEach进行数据懒加载，在布局时会根据可视区域按需创建Swiper子组件，并在Swiper子组件滑出可视区域外时销毁以降低内存占用。Swiper组件的开发，属于滑动容器加载的一种场景，其LazyForEach懒加载原理可参考：《长列表加载性能优化-懒加载》。
场景案例
为了体现Swiper使用ForEach与LazyForEach加载的性能差距，本地模拟答题场景进行测试分析。
Swiper子组件核心代码如下：
```typescript
// src/main/ets/pages/LazyForeachSwiper.ets
@Reusable
@Component
struct QuestionSwiperItem {
@State itemData: Question | null = null;
aboutToReuse(params: Record<string, Object>): void {
this.itemData = params.itemData as Question;
}
build() {
Column() {
Text(this.itemData?.title)
// ...
Image(this.itemData?.image)
// ...
Column({ space: 16 }) { // Question answers
// ...
}
.width('100%')
.alignItems(HorizontalAlign.Start)
}
// ...
}
}
```
Swiper主页面核心代码如下
```typescript
aboutToAppear(): void {
for (let i = 0; i < 1000; i++) {
this.list.push(i);
this.data.addData(i, i);
}
}
build() {
Column() {
Swiper(this.swiperController) {
ForEach(this.list, (item: number, index: number) => {
SwiperItem({ myIndex: index })
.width('100%')
.height("100%")
}, (item: string) => item)
}
// ...
}
.width('100%')
.margin({ top: 5 })
}
```
| 加载方式  | 完全显示所用时间  | 丢帧率  | 独占内存  |
| --- | --- | --- | --- |
| ForEach  | 951ms  | 8.5%  | 200MB  |
| LazyForEach  | 280.6ms  | 0.0%  | 25.18MB  |
加载方式
完全显示所用时间
丢帧率
独占内存
ForEach
951ms
8.5%
200MB
LazyForEach
280.6ms
0.0%
25.18MB
由实验数据可知，当Swiper的子组件数量比较大时，采用懒加载可以带来较好的帧率提升，并且有效减低内存占用。
缓存数据项
原理介绍
LazyForEach懒加载可以通过设置cachedCount来指定缓存数量，详细原理参考：《长列表加载性能优化-缓存列表项》。
使用场景
如果开发者的应用场景属于加载较为耗时的场景时，尤其是下列场景，推荐使用。
场景案例
案例模拟Swiper的子组件包含大量图像资源，采用下列前置条件：
Swiper子组件核心代码如下
```typescript
@Component
struct SwiperItem {
private data: number[] = [];
private myIndex: number = 0;
// 构造数据
private imgURL: string[] = Constant.imgURL;
aboutToAppear(): void {
for (let i = 0; i < 50; i++) {
this.data.push(i);
}
}
build() {
Column() {
List({ space: 20 }) {
ForEach(this.data, (index: number) => {
ListItem() {
Image(this.imgURL[this.myIndex * 50 + index])
.objectFit(ImageFit.Contain)
.width("100%")
.height("100%")
}
.aspectRatio(1)
.border({ width: 2, color: Color.Green })
}, (index: number) => index.toString());
}
// ...
}
// ...
}
}
```
Swiper主页面核心代码如下
```typescript
private dataSrc: NumberDataSource = new NumberDataSource();
aboutToAppear(): void {
for (let i = 0; i < 20; i++) {
this.dataSrc.addData(i, i);
}
}
build() {
Column({ space: 5 }) {
Swiper() {
LazyForEach(this.dataSrc, (item: number, index: number) => {
SwiperItem({
myIndex: index
});
}, (item: number) => item.toString());
}
.cachedCount(1)
.autoPlay(true)
.interval(1000)
.duration(100)
// ...
}.width('100%')
.margin({ top: 5 })
}
```
为测试不同缓存数量对性能的影响，将cachedCount的值分别设为1、2、4、8。基于案例程序，测试不同缓存数量对帧率以及内存占用的影响情况。
| 缓存数量  | 1  | 2  | 4  | 8  |
| --- | --- | --- | --- | --- |
| 丢帧率  | 3.0%  | 3.3%  | 3.1%  | 3.0%  |
| 独占内存  | 64.36MB  | 117.39MB  | 214.32MB  | 377.38MB  |
缓存数量
1
2
4
8
丢帧率
3.0%
3.3%
3.1%
3.0%
独占内存
64.36MB
117.39MB
214.32MB
377.38MB
根据测试结果可知，随着cachedCount的增大，应用的内存占用呈线性增长，但帧率没有得到明显提升。
在连续滑动场景中，一屏显示一个Swiper子组件时，通常将cachedCount值设置为1或2即可。
缓存数量仅供参考，不同的应用程序设置的最佳缓存数量不一致，需要针对应用程序测试得出最佳缓存数量。
提前加载数据
在抛滑场景时，Swiper组件有个onAnimationStart回调接口，切换动画开始时触发该回调。此时，切换动画的逻辑将在渲染线程中执行，从而使处于空闲状态的主线程能够充分利用这段时间来加载子组件所需资源。例如图像，网络资源等，减少后续在cachedCount范围内节点的预加载时间。跟手滑动阶段不会触发onAnimationStart回调，只有在离手后做切换动画（也就是抛滑阶段）才会触发。
场景案例
Swiper子组件：在子组件首次构建(生命周期执行到aboutToAppear)时，先判断Swiper数据中图片资源是否已经存在，若不存则先下载图片资源，再构建节点。
打点事件说明，当SwiperItem发生预加载时，会先进入自定义组件生命周期回调aboutToAppear，在aboutToAppear回调中使用startTrace开启打点跟踪，随后会进入build渲染组件，build函数执行完成后进入onDidBuild回调，在该回调中使用finishTrace停止打点追踪。分别使用“noPreLoadData”，“preLoadData”标签统计两种场景下的SwiperItem预加载耗时，关于本例中使用性能打点的介绍，请参考性能打点。
Swiper主页面
```typescript
Swiper() {
LazyForEach(this.swiperDataSource, (item: SwiperData) => {
PreloadSwiperItem({ swiperData: item })
}, (item: SwiperData) => item.index.toString())
}
.cachedCount(1)
// ...
.onAnimationStart((index: number, targetIndex: number) => {
if (targetIndex < this.swiperDataSource.totalCount() - 2) {
let swiperData = this.swiperDataSource.getData(targetIndex + 2);
if (swiperData.pixelMap) {
return;
} else {
// Simulation data download
ImageUtils.getPixelMap(IMAGE_URL, (pixelMap: PixelMap) => {
swiperData.pixelMap = pixelMap;
});
}
}
})
```
性能分析：
如图1所示，不使用onAnimationStart回调提前加载数据，通过自定义打点标签“H:noPreLoadData”，可以看出SwiperItem节点的构建耗时50ms左右。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151148.08222594667048816543209712383431:50001231000000:2800:A4AAB1866FC0F66440B7CF67B156F51C5238914FF1100A0C5D4D5F6AF06B039C.png)
如图2所示，采用onAnimationStart回调提前加载数据，通过自定义打点标签“H:preLoadData”，可以看出SwiperItem节点的构建耗时2ms左右。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151148.52101407495613125485480213312218:50001231000000:2800:8B0ECEEB8754DE809031EA7CC891E58F764A3002CE6264157193A4B33FCADB9F.png)
观察“H:noPreLoadData”时间段的详细trace图，可以发现预加载构建SwiperItem时，aboutToAppear生命周期回调加载图片资源占用了48ms左右。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151148.86212524800710288414756330135536:50001231000000:2800:21D56C0C0B7305F667C1C5E744790D997CAFCCB912C8269EB0B16CFFDF244E95.png)
通过上述分析可以发现，使用onAnimationStart回调接口提前加载后续范围内子组件所需资源，可以减小后续cachedCount范围内子组件节点的加载耗时。
组件复用
考虑到Swiper翻页场景存在其子组件的频繁创建和销毁，可以将子组件封装成自定义组件，并使用@Reusable装饰器修饰，使其具备组件复用能力，减少ArkUI框架内部反复创建销毁节点的开销。
详细原理及性能分析参考：《长列表加载性能优化-组件复用》。
总结
本文主要介绍了Swiper针对在复杂页面场景下，一些注意事项和性能优化方法。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-application-latency-optimization-cases
爬取时间: 2025-05-01 08:50:36
来源: Huawei Developer
应用时延概述
在移动终端应用开发中，完成时延是指用户操作移动终端时，从输入触控指令到界面完全刷新结束并达到可以阅读的稳定状态所用时间，点击时延依据页面转场类型可以分为页面内跳转和页面间跳转两种。完成时延在用户体验设计中扮演着关键的角色，直接影响用户对产品的满意度和使用体验。完成时延反映了用户对响应速度的整体感受，主要影响用户对触控交互及时性和愉悦性的体验评价。关于响应时延阶段的分析，请参考《点击响应时延分析》。关于完成时延阶段的分析，请参考《点击完成时延分析》。
在一定时延水平以上，时延越短越好，当时延小于一定水平后，用户的流畅体验不再继续提升。建议应用或元服务内点击操作响应时延应≤100ms，应用或元服务内点击操作完成时延≤900ms，更多体验建议，请参考指南《时延体检建议》。本文将给出时延问题常见优化方案。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.48210207935134777341388182161315:50001231000000:2800:02746FB4C7A78E584C5FA706762FF46CF953DD9C5E5418D8577C2EEC32A3FF93.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.25787205311497879934671816000512:50001231000000:2800:24440408FCE31908FC5A9F72EB700A69670674797D5ECA9E1C2A320C90D9A2CE.png)
常见时延问题优化方案
UI优化
本节的示例是一个应用开发中常见的留言箱列表。
从设计图稿中可看出，列表视图中每一个子项都包含了头像、消息红点、昵称、最新信息、时间等元素。
应用进入到该页面时，将根据每条消息的元素数据，呈现出不同的样式内容。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.08317218289452049335653057459174:50001231000000:2800:17E9BAC4EB5FC3594B677B66A6FDCE5B459CF51843964A1CED8E6E7043AEF47A.png)
分解其中的关系结构，单个子项界面的构成元素主要有6个，元素排列以线性风格为主，可能使用到的组件有Image，Badge，Text等。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.51341681843070143654445503269568:50001231000000:2800:F58A029ED9A17953CD03C850167FC6D2E68E721120EC2D0943305EDCC20C297D.png)
具体实现
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.42043593918679204395761641687096:50001231000000:2800:160E3003D69EFD7FF313744D4076A803DE2E333DBA78195EB9FA1CCB111F202C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.44989573790656373903062730651300:50001231000000:2800:DF409F6D48F6B13B47C48061BE16209E9E7EBE6BE20165B8D6AE981D373FAA64.png)
统计分析
在不同布局下，相同界面效果所需要的组件数目和嵌套数目是完全不同的，对本案例场景下的留言箱进行拆分可以得到以下数目对比：
|    | 组件数目  | 嵌套数目  |
| --- | --- | --- |
| Flex实现方式  | 15  | 6  |
| 相对布局实现方式  | 9  | 3  |
组件数目
嵌套数目
Flex实现方式
15
6
相对布局实现方式
9
3
分别使用相同数目的数据测试，通过记录从上一页面点击启动到留言箱列表渲染为止的响应时延，得到其对比结果，如下表：
|    | 256条数据  | 512条数据  | 1024条数据  |
| --- | --- | --- | --- |
| Flex实现方式  | 308ms  | 570ms  | 1096ms  |
| 相对布局实现方式  | 249ms  | 499ms  | 986ms  |
| 优化百分比  | 19.2%  | 12.5%  | 10.0%  |
256条数据
512条数据
1024条数据
Flex实现方式
308ms
570ms
1096ms
相对布局实现方式
249ms
499ms
986ms
优化百分比
19.2%
12.5%
10.0%
从最后统计的数据来看：
在更为复杂的实际开发场景中，简化布局结构、精简相关元素（包括绘制的子元素及其父容器），决定了响应速度在UI层面的潜在提升空间。
并发优化
该示例是一个添加地址的功能，当点击“选择“按钮后，应用响应切换到选择城市地区的目标页。在切换过程中，要将全国城市数据加载，根据首字符排序，然后刷新到新页面列表中。
在实际场景中，开发者可能直接用同步串行的方式实现这一功能：点击按钮后，初始化页面，将数据加载到内存中，然后渲染出整个界面视图。
当目标页选择范围到”市”这一行政级别，数据量大约1000条，新页面响应速度理想，直观上没有异样；
如果功能需求调整，当目标页选择范围到”区”这一级别，数据量达到2000，页面响应速度尚可接受；
如果功能进一步调整，当目标页选择范围到”乡镇/街道”这一级别时，数据量突破4000，页面响应出现明显延迟。
因为地区数据的加载和排序，这两个过程都需要消耗一定的性能计算，在这种情况下，可以使用并发机制来优化。
代码实现
在目标页面的aboutToAppear中，使用TaskPool启动子线程加载城市数据，实现并发操作：
```typescript
@Concurrent
function computeTask(): string[] {
let array: string[] = []
// AppConstant.CITYS 为需要加载的数据
for (let t of AppConstant.CITYS) {
array.push(t.trim())
}
let collator = new Intl.Collator("zh-CN", { localeMatcher: "lookup", usage: "sort" });
array.sort((a, b) => collator.compare(a, b))
return array;
}
@Entry
@Component
struct CityList {
isAsync: boolean = (router.getParams() as Record<string, boolean>)['isAsync'];
// 界面数据
@State citys: string[] = []
private listScroller: Scroller = new Scroller();
aboutToAppear() {
this.computeTaskAsync(); // 调用异步运算函数
}
// 异步线程
computeTaskAsync() {
let task: taskpool.Task = new taskpool.Task(computeTask);
taskpool.execute(task).then((res) => {
this.citys = res as string[]
})
}
// ...
}
```
统计分析
使用Profiler Time工具，分别测试不同数量级别下的响应时长，得到结果如下：
|    | 500条数据  | 1000条数据  | 2000条数据  | 4000条数据  |
| --- | --- | --- | --- | --- |
| 串行  | 49ms  | 94ms  | 296ms  | 780ms  |
| 并发  | 48ms  | 86ms  | 140ms  | 172ms  |
500条数据
1000条数据
2000条数据
4000条数据
串行
49ms
94ms
296ms
780ms
并发
48ms
86ms
140ms
172ms
可以看出，在该场景下，如果数据量不大（小于1000），串行加载的用户体验也可以保持良好，但随着城市数据量的递增，当超过1000条时，响应时长增大加快，体验开始显著恶化，从手指抬起到页面转场进入列表页的第一帧画面，会明显出现视觉可见的响应迟滞。
这时采用并发异步加载的优势体现出来，在实践中，UI主线程可以第一时间拉起目标列表页面，同时触发异步加载及排序的逻辑线程，待结果返回后再刷新到列表中，提升整体的响应速度。
减少调用数据库API次数
本节示例是一个记账工具应用，其基于关系型数据库管理相关账目。
在查询用户数据时，会依次读取account表中每一行的数据，其中每一列column的值，需要借助getColumnIndex("列名")得到column索引，然后再取得对应值 。
修改前代码：
从代码可知，for循环内调用getColumnIndex，总的调用次数会随着数据行数count的增大而增大。数据表结构固定的情况下，索引不会变化 ，可以将调用提前以减少总的调用次数，优化指令耗时。
修改后代码：
统计分析
使用Profiler Time工具，分别测试不同数量下的响应时长，得到结果如下：
|    | 50条数据  | 500条数据  | 5000条数据  |
| --- | --- | --- | --- |
| 修改前  | 72ms  | 97ms  | 157ms  |
| 修改后  | 72ms  | 92ms  | 110ms  |
50条数据
500条数据
5000条数据
修改前
72ms
97ms
157ms
修改后
72ms
92ms
110ms
由此可以看出，在数据库使用时，要关注相关API调用的潜在频率：
数据条目在初期量级不大时，API调用行对应用响应影响甚微；伴随着使用时间的增长，数据量级大到一定程度，这种潜在可能的高频调用，会直接影响程序的性能表现。
延迟执行资源释放操作
该场景是相机正常使用后，执行释放相机资源的相关操作。通过“停止拍摄进程 > 暂停并释放相机会话 > 关闭和释放预览及拍照的输入输出对象 > 清空相机管理对象”的过程，确保应用程序在不再使用相机时能够有效管理并回收所有相机资源。但是直接调用的release方法中captureSession、cameraInput、previewOutput、cameraOutput都用了await,使相机关闭和释放顺序执行可能会导致应用程序的响应性下降，造成用户界面卡顿。
下列代码将资源释放操作放在相机页面隐藏时触发的函数：
```typescript
let cameraOutput: camera.PreviewOutput;
let cameraInput: camera.CameraInput;
let captureSession: camera.PhotoSession;
let previewOutput: camera.PhotoOutput;
// 相机页面每次隐藏时触发一次
onPageHide() {
this.releaseCamera();
}
// 释放资源
public async releaseCamera() {
try {
// 拍照模式会话类暂停
await captureSession?.stop();
// 拍照模式会话类释放
await captureSession?.release();
// 拍照输入对象类关闭
await cameraInput?.close();
// 预览输出对象类释放
await previewOutput?.release();
// 拍照输出对象类释放
await cameraOutput?.release();
} catch (e) {
hilog.error(0x00, 'release input output error:', JSON.stringify(e));
}
}
```
修改后，启动setTimeout异步延迟操作，在200ms后调用release释放关闭相机。其通过“停止拍摄进程 > 并发执行：（暂停并释放相机会话 > 关闭和释放预览及拍照的输入输出对象 > 清空相机管理对象）”的过程，确保应用程序在不再使用相机时能够有效管理并回收所有相机资源。移除await关键字应用于相机资源释放操作，允许异步并发执行，显著减少了主线程阻塞，从而提升了应用性能和响应速度。
```typescript
let cameraOutput: camera.PreviewOutput;
let cameraInput: camera.CameraInput;
let captureSession: camera.PhotoSession;
let previewOutput: camera.PhotoOutput;
// 相机页面每次隐藏时触发一次
onPageHide() {
setTimeout(this.releaseCamera, 200);
}
// 释放资源
public async releaseCamera() {
try {
// 拍照模式会话类暂停
await captureSession?.stop();
// 拍照模式会话类释放
await captureSession?.release();
// 拍照输入对象类关闭
await cameraInput?.close();
// 预览输出对象类释放
await previewOutput?.release();
// 拍照输出对象类释放
await cameraOutput?.release();
} catch (e) {
hilog.error(0x00, 'release input output error:', JSON.stringify(e));
}
}
```
性能比对
| 操作逻辑  | trace图识别耗时  | 备注  |
| --- | --- | --- |
| 直接关闭与释放（修改前）  | 457.5ms  | 在onPageHide中直接执行相机关闭与释放操作  |
| 延时关闭与释放（修改后）  | 85.6ms  | 在onPageHide中使用setTimeout延迟200ms后执行关闭与释放操作  |
操作逻辑
trace图识别耗时
备注
直接关闭与释放（修改前）
457.5ms
在onPageHide中直接执行相机关闭与释放操作
延时关闭与释放（修改后）
85.6ms
在onPageHide中使用setTimeout延迟200ms后执行关闭与释放操作
两组数据表明，合理运用延时策略能显著提升函数执行效率，是优化相机资源管理与关闭操作性能的有效手段，对提升整体用户体验具有重要价值。
减小拖动识别距离
该场景是对一个组件添加手势事件。优化前，指定触发拖动手势事件的最小拖动距离为100vp，代码如下：
利用Profiler工具分析得到trace图，其中主要关注两个trace tag分别是DispatchTouchEvent代表点击事件和PanGesture代表响应，追踪流程从应用侧的DispatchTouchEvent（type=0，标识手指接触屏幕）标签开始，到PanGesture（事件响应）的变化，该过程耗时145.1ms。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.31368912680784464415074253601053:50001231000000:2800:A76896B583871C933170EA998E02792E52E7822A8B702A7BF865F11CDAB1CE55.png)
日志主要关注从应用接收TouchDown事件到pan识别耗时，该过程耗时127ms。（注：日志信息和trace图非同一时间获取，所获得的性能数据存在差异，提供的数值仅供参考。）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.45280460178626815487922371129672:50001231000000:2800:D1D6ACAE126900EAA2FCDF868F0C78920C81E4757B028D90CA60D57845392FD5.png)
针对该组件，其拖动手势识别距离可以调整到更合适的数值，这里优化后，指定触发拖动手势事件的最小拖动距离为4vp，修改如下：
同样采用Profiler工具分析trace图，得到对应耗时38.4ms
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.36717442745939441145250166608136:50001231000000:2800:F307C090C53A554453E1A83A8D118A294387B63264678D5B6D42BB3D2DBEADA1.png)
对应日志过程耗时42ms。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.19287609572701748419360580044690:50001231000000:2800:5EAD254271C0762EBB99971646DAE33A61F7555E5C6E85928707E2E591A94F16.png)
性能比对
| 拖动距离设置  | trace图识别耗时  | 日志识别耗时  | 备注  |
| --- | --- | --- | --- |
| 最小拖动距离100vp（修改前）  | 145.1ms  | 127ms  | 最小拖动距离过大会导致滑动脱手、响应时延慢等问题导致性能劣化  |
| 最小拖动距离4vp（修改后）  | 38.4ms  | 42ms  | 设置合理的拖动距离优化性能  |
拖动距离设置
trace图识别耗时
日志识别耗时
备注
最小拖动距离100vp（修改前）
145.1ms
127ms
最小拖动距离过大会导致滑动脱手、响应时延慢等问题导致性能劣化
最小拖动距离4vp（修改后）
38.4ms
42ms
设置合理的拖动距离优化性能
两组数据表明，合理减小拖动距离能显著提升执行效率，是优化响应时延的有效手段，对提升整体用户体验具有重要价值。（注：本案例通过设置较大和较小拖动距离进行数据对比得出相关结论。设置过小的distance容易出现误触等问题，开发者可根据具体应用场景进行设置。
转场动画场景案例
下面列举的示例通过多种不同的连贯动画，让应用使用者在操作过程中能够感受到程序的快速响应。
该示例场景：从留言箱的列表项点击后，执行响应切换进入个人页。在这一过程中，使用了三个动画组成其完整过程：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.17462579029837150482571197193980:50001231000000:2800:EE8B783991F58A3510DD9C871C47CC6AAB5304CF77F7095CA00BB662D18DC100.png)
具体实现
用router+sharedTransition+animateTo的组合实现，具体操作思路如下：
关键代码
转场动画设置：
列表页中共享元素动画设置：
个人页中共享元素动画设置：
骨架图实现：
动画时延场景案例
页面的转场动画是提升用户体验的重要环节。然而，当动画时延耗时较长时，它会对用户的点击完成时延产生显著影响。动画的完成时间直接关系到用户何时能够开始与应用进行交互。动画时延影响点击完成时延的根因主要为动画时长设置过长。
常见的页面转场动画时长参数有：
使用Tabs组件进行页面切换时，当不设置BottomTabBarStyle时默认animationDuration属性有300ms的动画时长，当该属性值设置过长时会导致完成时延变大。接下来将该属性值分别设置为100ms与1000ms来探究animationDuration属性对完成时延的影响。
实验一：设置animationDuration为100ms
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.87078574032332886584720871317716:50001231000000:2800:1185050054EF99461B6C44C0008366402EC9D85AD9B30E4E9EF17B282EC01EED.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.36251781349177673973726207945303:50001231000000:2800:96BC30C5AEB464A4E5E091F7A3B6F085D8E4775C106F75893F602C5ACA42BFD6.png)
| 设置animationDuration为100ms  | 设置animationDuration为1000ms  |
| --- | --- |
|   |   |
设置animationDuration为100ms
设置animationDuration为1000ms
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151149.28971845390578535228706348461697:50001231000000:2800:1A0DDD5CA871A0122B1172E772B5CB4A1056686044B8067CAFB6A9B2849D9A55.gif)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151150.39282219023239745632787835825677:50001231000000:2800:E7F2BF8775637008643B4A5F334EA8DEF503DFA7C99B7F74155517887A62F9C7.gif)
| animationDuration属性值  | 完成时延  |
| --- | --- |
| 100ms  | 99ms39μs  |
| 1000ms  | 1s7ms693μs  |
animationDuration属性值
完成时延
100ms
99ms39μs
1000ms
1s7ms693μs
上述示例通过减少animationDuration属性的数值，减小了Tabs组件切换动画的完成时延。当不设置BottomTabBarStyle样式时，动画时长默认为300ms，开发者可根据实际业务场景需要适当降低该动画时长，提高应用性能。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-decrease_pakage_size
爬取时间: 2025-05-01 08:50:49
来源: Huawei Developer
概述
减小应用包大小是提升应用下载和安装体验的重要方式。通过压缩、精简或者复用应用中的代码或资源，可以有效降低应用包体积大小，减少空间占用，从而达到提升应用下载和安装速度的目的。在了解如何优化包大小之前，需要先了解HarmonyOS应用的应用程序包结构。在进行应用程序包大小优化分析时，可以使用扫描工具扫描分析App包，根据输出的检测报告，采取相应措施优化应用。
可以参考以下方法减小应用包大小：
使用扫描工具分析App大小
扫描工具可用于分析检测应用包，根据不同的参数设定，扫描指定路径的App、HAP、HSP包内容并输出检测结果报告，为开发者优化包结构或排查问题提供数据支撑。
根据扫描结果按照如下方式优化应用：
2、较大文件
3、特定类型文件
so文件，通过配置so库压缩选项来实现压缩打包。
减小应用包大小的方法
配置so压缩选项
当前DevEco Studio默认打包应用时不压缩so库文件，配置so压缩选项后，DevEco Studio会将so库文件以压缩形式打包到包中，从而减小应用包大小。
配置方法
修改应用模块配置文件module.json5中的compressNativeLibs字段，将值配置为true，重新编译、打包应用。
so压缩效果
以DevEco Studio中C++默认库文件为例，压缩前后的文件大小对比如下：
| 文件名  | 原始大小  | 压缩后大小  | 压缩率  |
| --- | --- | --- | --- |
| armeabi-v7a/libc++_shared.so  | 1108k  | 386k  | 34%  |
文件名
原始大小
压缩后大小
压缩率
armeabi-v7a/libc++_shared.so
1108k
386k
34%
解决依赖减少依赖包重复编译
对于ohpm 1.5.0之前的版本，如果hap依赖了不同版本的har（如下图中V1版本的harC和V2版本的harC），在打包hap时，默认会把V1和V2两个版本的harC都打包到包中。开发者可以使用ohpm的override机制，指定只打包一份。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151150.54002437585080105221046997662822:50001231000000:2800:3C8A102C8C1C0879EAF6E47237613465211069FCA16574040FCA217D56AF735B.png)
如果使用的是ohpm 1.4.0 版本，可以使用override机制，开发者可以在项目级别的 oh-package.json5 （即项目根目录下的 oh-package.json5）文件中添加 overrides 配置，将依赖树中的依赖替换为另一个版本。替换的版本既可以是一个具体的版本号，也可以是本地存在的HAR包或源码目录。
注意：
overrides 必须配置在项目级别的 oh-package.json5 中，配置在模块级别的 oh-package.json5 中将不会生效。
例如，始终希望安装 foo 的 1.0.0 版本，可以在项目级的 oh-package.json5 中增加如下配置：
若本地存在 foo 的源码或者HAR包，想确保 foo 始终使用本地的版本，可以在项目级的 oh-package.json5 中这样配置：
对于1.5.0 版本之后的ohpm，可以通过开启resolve_conflict，自动解决依赖冲突，依赖冲突的处理策略为：当您的项目同时依赖了某个三方库的不同版本时，ohpm将选择其中的最高版本进行安装。
按需分发
对于应用中用户不常用的功能，可以考虑通过按需分发的方式，将下载时机交由用户选择，使用时从应用市场获取安装，减少用户初次下载的包大小。
多包场景下使用HSP共享代码和资源
当前系统提供了两种共享包，HAR静态共享包和HSP动态共享包。HAR与HSP都是为了实现代码和资源的共享，都可以包含代码、C++库、资源和配置文件，最大的不同之处在于：HAR中的代码和资源跟随使用方编译，如果有多个使用方，它们的编译产物中会存在多份相同拷贝；而HSP中的代码和资源可以独立编译，在运行时进程中代码和资源也只会存在一份。
在多包场景下，如果应用的多个HAP或HSP包使用HAR包实现代码和资源的共享，那么打包后的每个HAP或HSP包中都会存在一份共享HAR包的拷贝，导致App包中存在冗余代码和资源。如下图示例，应用模块HAP1和HAP2/HSP1都引用了HAR2和HAR3，打包后，App包中HAR2和HAR3存在多份重复拷贝，体积较大。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151150.74384822544410042789710760318487:50001231000000:2800:01A7C7E92020BC4CDC47B42E4D32D0E9DDEC68D25CCD38D11D95D9F428416350.png)
这种场景下，推荐开发者使用HSP代替HAR实现代码和资源共享。如下图示例，使用HSP2对原应用进行升级改造，打包后，APP包中HAR2和HAR3只存在一份拷贝，HAR2、HAR3总大小大于HSP时，可以减小应用包大小。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151150.62237884738716592890087095599852:50001231000000:2800:B3D91B7AB6180F16CBAF1D73FB92C904153356D382426AD191522D73C97308ED.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-memory-optimization
爬取时间: 2025-05-01 08:51:02
来源: Huawei Developer
概述
用户功能的不断增强，应用越来越复杂，占用的内存也在不断膨胀，而内存作为系统的稀缺资源比较有限，当应用程序占用过多内存时，系统可能会频繁进行内存回收和重新分配，导致应用程序的性能下降，甚至出现崩溃和卡顿的情况。因此，主动减少应用内存的占用对于整个系统至关重要。通过减少应用内存的占用，可以有效提高应用的性能和响应速度，节省系统资源，让设备的运行效率更高，延长设备的续航时间。开发者应该在应用开发过程中注重内存管理，积极采取措施来减少内存占用，以优化应用程序的性能和用户体验。
HarmonyOS提供了一些内存管理的工具和接口，帮助开发者有效地管理内存资源：
本文将从这五个方面来介绍如何优化应用内存占用问题。
使用onMemoryLevel监听内存变化
onMemoryLevel是HarmonyOS提供监听系统内存变化的接口，开发者可以通过onMemoryLevel监听内存变化，从而调整应用的内存。onMemoryLevel回调包括三种方式，分别为AbilityStage、UIAbility、EnvironmentCallback。
MemoryLevel分为MEMORY_LEVEL_MODERATE、MEMORY_LEVEL_LOW和MEMORY_LEVEL_CRITICAL三种。其中，MEMORY_LEVEL_MODERATE代表当前系统内存压力适中，应用可以正常运行而不会受到太大影响，MEMORY_LEVEL_LOW代表当前系统的内存已经比较低了，应用应该释放不必要的内存资源，避免造成系统卡顿，MEMORY_LEVEL_CRITICAL代表当前所剩的系统内存非常紧张，应用应该尽可能释放更多的资源，以确保系统的稳定性和性能。开发人员应该根据不同的内存级别来采取相应的措施，如释放资源、优化内存使用等，以确保应用在不同内存状态下都能正常运行。MemoryLevel具体等级定义如下所示：
| 等级  | 值  | 说明  |
| --- | --- | --- |
| MEMORY_LEVEL_MODERATE  | 0  | 系统内存适中。系统可能会开始根据LRU缓存规则杀死进程。  |
| MEMORY_LEVEL_LOW  | 1  | 系统内存比较低。此时应该去释放掉一些不必要的资源以提升系统的性能。  |
| MEMORY_LEVEL_CRITICAL  | 2  | 系统内存很低。此时应当尽可能地去释放任何不必要的资源，因为系统可能会杀掉所有缓存中的进程，并且开始杀掉应当保持运行的进程，比如后台运行的服务。  |
等级
值
说明
MEMORY_LEVEL_MODERATE
0
系统内存适中。系统可能会开始根据LRU缓存规则杀死进程。
MEMORY_LEVEL_LOW
1
系统内存比较低。此时应该去释放掉一些不必要的资源以提升系统的性能。
MEMORY_LEVEL_CRITICAL
2
系统内存很低。此时应当尽可能地去释放任何不必要的资源，因为系统可能会杀掉所有缓存中的进程，并且开始杀掉应当保持运行的进程，比如后台运行的服务。
后台已冻结的应用，AbilityStage、UIAbility、EnvironmentCallback的onMemoryLevel都不可以进行回调。
使用LRUCache优化ArkTS内存
LRU（Least Recently Used， 最近最少使用）是一种常见的算法，其核心思想是基于时间局部性原理，即如果一个数据在最近被访问过，那么它在未来被访问的概率也会比较高。
LRUCache是ArkTS中常用的工具函数，是基于LRU实现的缓存工具，常用于缓存一些频繁访问的数据，例如常用的图片、网络请求的结果等。LRUCache通过维护一个缓存空间来存储数据，当缓存空间不足时，会根据LRU算法将最近最少使用的数据替换掉，以保证缓存空间的有效利用。因此，LRUCache会根据数据的访问顺序来进行数据替换，优先淘汰最久未被访问的数据。
原理介绍
LRUCache通过LinkedHashMap来实现LRU的，LinkedHashMap继承于HashMap，HashMap用于快速查找数据，LinkedHashMap双向链表用于记录数据的顺序关系。所以，对于get、put、remove等操作，LinkedHashMap除了包含HashMap的功能，还需要实现调整Entry顺序链表的工作。其数据结构如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151150.67732600183453305838962788520818:50001231000000:2800:09C34BD6C0CC82B639119C091248F0C40507BD31B5BB0325880CDA7AE2A68A37.png)
LruCache中将LinkedHashMap的顺序设置为LRU顺序，链表头部的对象为近期最少用到的对象。常用的方法及其说明如下所示：
参考案例
缓存工具类可以被设计成一个工具类，其中包含LRUCache单例以及一些操作LRUCache的方法，如添加数据、获取数据、删除数据等。通过创建一个静态方法来获取LRUCache实例，并在内部进行实例化，可以保证全局只有一个LRUCache对象。通过缓存工具类，各组件之间可以方便地共享缓存数据，避免重复创建缓存实例和数据冗余。这样不仅可以提高系统的性能和效率，还可以减少内存占用和提升数据访问速度。
```typescript
import { util } from '@kit.ArkTS';
export class LRUCacheUtil {
private static instance: LRUCacheUtil;
private lruCache: util.LRUCache<string, Object>;
private constructor() {
this.lruCache = new util.LRUCache(64);
}
// 获取LRUCacheUtil的单例
public static getInstance(): LRUCacheUtil {
if (!LRUCacheUtil.instance) {
LRUCacheUtil.instance = new LRUCacheUtil();
}
return LRUCacheUtil.instance;
}
// 判断lruCache缓存是否为空
public isEmpty(): boolean {
return this.lruCache.isEmpty();
}
// 获取lruCache的容量
public getCapacity(): number {
return this.lruCache.getCapacity();
}
// 重新设置lruCache的容量
public updateCapacity(newCapacity: number) {
this.lruCache.updateCapacity(newCapacity);
}
// 添加缓存到lruCache中
public putCache(key: string, value: Object) {
this.lruCache.put(key, value);
}
// 删除key对应的缓存
public remove(key: string) {
this.lruCache.remove(key);
}
// 获取key对应的缓存
public getCache(key: string): Object | undefined {
return this.lruCache.get(key);
}
// 判断是否包含key对应的缓存
public contains(key: string): boolean {
return this.lruCache.contains(key);
}
// 清除缓存数据，并重置lruCache的大小
public clearCache() {
this.lruCache.clear();
this.lruCache.updateCapacity(64);
}
}
```
在对应的组件中设置缓存，示例代码如下所示：
```typescript
import { LRUCacheUtil } from '../utils/LRUCacheUtil';
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
aboutToAppear(): void {
let lruCache = LRUCacheUtil.getInstance();
// 添加一个<key, value>到lrucache
lruCache.putCache('nation',10);
// 再添加一个<key, value>到lrucache
lruCache.putCache('menu',8);
// 通过key查询value
let result0 = lruCache.getCache('2') as number;
console.log('result0:' + result0);
// 从当前缓冲区中删除指定的键及其关联的值
let result1 = lruCache.remove('2');
console.log('result1:' + result1);
// 检查当前缓冲区是否包含指定的对象
let result2 = lruCache.contains('1');
console.log('result2:' + result2);
// 设置新的容量大小
let result4 = lruCache.updateCapacity(110);
console.log('result4:' + result4);
}
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
}
.width('100%')
}
.height('100%')
}
}
```
同时，可以通过onMemoryLevel监听内存的变化，进而设置对应清理缓存的机制，示例代码如下所示：
使用生命周期管理优化ArkTS内存
组件的生命周期，指的是组件自身的一些可自执行的方法，这些方法会在特殊的时间点或遇到一些特殊页面行为时被自动触发而执行。
原理介绍
在开发过程中，开发人员可以通过管理对象的生命周期来释放资源、销毁对象、优化ArkTS内存。
aboutToDisappear中销毁订阅事件
aboutToDisappear函数会在组件析构销毁之前执行。如下案例所示，在使用完网络管理的网络连接模块后，取消订阅默认网络状态变化的通知。
使用purgeable优化C++内存
Purgeable Memory是HarmonyOS中native层常用的内存管理机制，可用于图像处理的Bitmap、流媒体应用的一次性数据、图片等。应用可以使用Purgeable Memory存放其内部的缓存数据，并由系统根据淘汰策略统一管理全部的purgeable内存。当系统内存不足时，系统可以通过丢弃purgeable内存快速回收内存资源，以释放更多的内存资源给其他应用程序使用，实现全局高效的缓存数据管理。这种机制可以帮助系统更有效地管理内存，提高系统的稳定性和流畅性。
在使用Purgeable内存时，开发者可以调用接口释放Purgeable内存，但需要注意在适当的时机释放Purgeable内存，以确保内存资源能够得到有效管理，避免内存占用过高导致的性能问题和内存泄漏的情况。通过合理使用Purgeable内存，开发者可以更好地管理应用程序的内存，提高用户体验。
原理介绍
Purgeable内存访问流程图如下图所示，在访问Purgeable内存时，首先需要判断当前Purgeable内存的数据是否已经被回收，如果Purgeable内存已经被回收了，那么需要先重建数据再使用。在访问Purgeable内存的数据时，Purgeable内存对应的引用计数refcnt加1，在访问Purgeable结束后，其引用计数refcnt会减1，当引用计数为0的时候，该Purgeable内存可以被系统回收。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151150.05469025554178608753858013062066:50001231000000:2800:5FE48770F34DB84253E3CBFB21A9A5E04D8AA348E7F4227057633F4BD8F032D1.png)
Purgeable内存回收流程图如下所示，当引用计数为0时，丢弃掉Purgeable内存中的数据，并标识Purgeable内存已回收。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151150.18572342232333593999478417130778:50001231000000:2800:B32594E60597C3921FD7DF2FFB8254ED3A03E8FC7F5C227332EC4CAAA29AC242.png)
参考案例
在CMakeLists.txt文件中引入Purgeable对应的动态链接库libpurgeable_memory_ndk.z.so，具体如下所示：
引入purgeable_memory头文件，并声明创建PurgeableMemory对象需要使用的ModifyFunc函数，调用OH_PurgeableMemory_Create创建PurgeableMemory对象。
在读取PurgeableMemory对象的内容时，需要调用OH_PurgeableMemory_BeginRead，读取结束时，需要调用OH_PurgeableMemory_EndRead。其中，OH_PurgeableMemory_GetContent可以获取PurgeableMemory对象的内存数据。
在修改PurgeableMemory对象的内容时，需要调用OH_PurgeableMemory_BeginWrite，读取结束时，需要调用OH_PurgeableMemory_EndWrite。其中，OH_PurgeableMemory_AppendModify可以更新PurgeableMemory对象重建规则。
使用合理尺寸的图片优化应用内存
原理介绍
应用在定义界面时，对于使用不同类型的组件，需要绘制不同的内容。图片组件主要用来加载和显示图片，而组件本身也需要占用内存。ArkTS目前采用引用计数的机制来管理内存。引用计数是一种简单而高效的内存管理方式，它通过记录每个对象被引用的次数来确定何时释放对象。需要注意的是，如果组件没有正确释放，即使其他地方不再使用该组件，对应的引用链接上的资源也不会被释放，可能会导致内存泄漏问题。
一张全屏的图片，不同分辨率的内存占用大小如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151150.68708538458748892390300238720741:50001231000000:2800:A30C62C93DA47FB4C5A3432A8C9C4EF1B9817AE8AC712DDEADE6A7CD6D3E2EB5.png)
由上图可以看出，对于一些页面多、图片多、效果多的资源密集型应用，内存很容易达到较高水平。当应用的内存占用超过系统设定的阈值（如4G，其中4G只是示例，不同系统的阈值不同）时，系统可能会认为应用存在严重的内存问题，并可能会强制杀死该应用进程，以保证设备系统的稳定性和性能。为了避免应用被系统杀死，开发者可以考虑以下两点：
本章节主要指导开发者通过合理设置图片源文件大小，合理使用内存资源，减少图片所占应用内存。
避免加载超过显示尺寸的图片
如上代码示例中，使用500*500尺寸大小的Image组件加载一张尺寸为4032*3024的RGBA格式图片时（每个像素占用4个字节），图片申请了约46.5M的内存。这是因为图片的原始尺寸较大，加载到Image组件中时需要将其缩放到500*500的尺寸，这个过程会占用一定的内存空间。
可使用公式计算出来纹理图片内存大小 = imageWidth x imageHeight x format（4032*3024 * 4 = 48771072 bytes ≈ 46.5M）。
但是实际上，组件只需要500*500的尺寸。也就是说，实际需要的内存 = 500*500*4 ≈ 1M。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151150.99981019578228281470558694312452:50001231000000:2800:A1AA152192AC89798F29EFA4E364FC124066BE83235155DB106CB17CC96220E1.png)
因此当一张图片比控件显示的区域要大，最终会被裁剪或者缩放。大量的裁剪和缩放不仅导致视图效果变差，还会浪费内存，引起严重的功耗问题。为了最大程度地节省内存，开发者可以手动调整源文件的尺寸大小，使其与组件的大小保持一致。这样可以避免不必要的内存浪费，并提高应用程序的性能和效率。开发者可以使用图像处理工具来调整图像的尺寸大小，从而进一步节省内存空间。
其他方法
在日常开发中，常见的其他减少内存方式有如下几种：

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-file-upload-and-download-performance
爬取时间: 2025-05-01 08:51:16
来源: Huawei Developer
概述
在开发应用时，客户端与服务器之间数据交换的效率取决于文件传输的性能。一个数据交换性能较低的应用会导致其在加载过程中耗费较长时间，在很多的场景造成页面卡顿，极大的影响了用户体验。相反，一个数据交换高效的应用，则会让应用变得更加流畅。
本文将介绍两种常见的上传下载传输和网络请求的关键技术：数据压缩和断点续传，可减少宽带占用，提高传输效率，从而达到提升数据交换性能。
上传下载接口
目前系统内提供给文件上传下载可用的模块有http模块和request模块。http模块提供基础的HTTP数据请求能力，功能较为基础，本文不做介绍。request模块主要给应用提供上传下载文件、后台传输代理的基础能力。它具备任务管理系统的默认并发功能，可简化下载功能的实现和管理，提升数据传输的安全性，整合通知机制，新增任务状态与进度查询功能，具有灵活性、高效性、可扩展性、可靠性、一致性和安全性的优势。
具体来说，request模块包括以下功能：
下载任务的状态迁移流程
使用request模块执行下载的任务，具有四种运行状态：初始任务、就绪任务、挂起任务、待网任务。可以通过create创建任务，start开始任务，pause挂起任务，resume恢复任务，remove移除任务，stop停止任务，任务结果有final-failed任务失败，final-completed下载完成，recoverable-failed重试失败，并支持查询任务状态，具体流程如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151150.97514952327833533877799813390662:50001231000000:2800:0FF54C8B4CD2DE574348DD85A057E1DBF95F05BB700CF0E6CCB43295F8B6180A.png)
常见场景和解决方案
场景1：低带宽网络上传琐碎文件场景
在网络连接较差，低带宽的网络环境中，HTTP连接的建立耗时可能会大幅提升。这时候进行数据压缩可以加快页面加载速度，并减少HTTP请求数量和移动数据流量。
场景2：处理大量资源的场景
如应用商店、网盘应用等，这类应用通常拥有大体积的文件资源。当用户从暂停或者断网中重新恢复时，如果从头开始上传下载则会额外耗费大量的时间。此时可以采用断点续传方法进行上传下载。
数据压缩
数据压缩是指在应用中对数据进行压缩，以减少存储空间和数据传输量、节省带宽，提高加载速度。数据压缩通常在网络传输和存储方面发挥着重要作用，特别是在处理大量数据或需要频繁传输数据的场景下。
在应用开发中，常见的数据压缩技术分类如下：
以批量上传照片（分辨率为480*640，24位，平均大小50~120KB）为例，在设备上测试的结果如下表所示：
| 上传照片数量  | 优化前耗时（ms）  | 优化后耗时（ms）  |
| --- | --- | --- |
| 10  | 470  | 526  |
| 20  | 1124  | 1091  |
| ...  | ...  | ...  |
| 50  | 2379  | 2138  |
| 80  | 3950  | 3258  |
| ...  | ...  | ...  |
| 100  | 5276  | 3906  |
上传照片数量
优化前耗时（ms）
优化后耗时（ms）
10
470
526
20
1124
1091
...
...
...
50
2379
2138
80
3950
3258
...
...
...
100
5276
3906
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151150.89125909664343876026564717407357:50001231000000:2800:20584F5BE63141D13858CEE84BD16C90EAE4B9EAA3F75284B7F9E450CC7F77D8.png)
由于上传耗时受到网络状态影响，偏差较大，结果取的几次测量结果的最小值。但是仍然可以从数据中看出，优化前的耗时基本为线性增长，压缩优化后的耗时在上传文件数量较低时并不明显，还会因为多余的压缩处理影响耗时。不过随着上传的照片数量增多，优化后的耗时和优化之前的耗时差距越来越明显，优化效果越好。
数据压缩的相关示例代码如下：
```typescript
class ZipUpload {
// 创建任务前存放的uri
private waitList: Array<string> = [];
// 需要上传的文件uri
private fileUris: Array<string> = [];
...
}
```
断点续传
断点续传功能的实现，不管是应用端还是服务器端都需要用到合理的技术来互相协同。在实际开发中，开发者无需亲自实现断点续传功能，只需对SDK进行合理配置。
在应用端需要用到的技术和API：
在服务器端需要用到的技术：
通过结合应用端和服务器端的相关技术，可以共同实现高效且可靠的文件断点续传功能，提供更好的用户体验并确保数据传输的稳定性。
本文基于上传和下载中的后台上传场景，给出了部分断点续传的示例代码，具体可以参考该工程。
文件上传
对于大文件断点续传上传，本文采用request（上传下载）模块中的request.agent任务托管接口，可以自动实现暂停继续重试等操作，无需手动将文件分片和记录上传分片信息。流程图如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151151.77953147855345906281105128293037:50001231000000:2800:39429724D1ACAA2710C50D268A38A0322127636F7C9B050D51C1BB63615205B9.png)
文件下载
对于大文件断点续传下载，也可以直接调用request.agent接口，该接口的断点续传是基于HTTP协议Header里的Range字段实现的，在任务暂停重启的时候，会自动设置Header中的Range字段，无需进行额外的配置。
Range简介
HTTP协议里面的Range字段，官方名称为范围请求，它允许服务器只发送 HTTP 消息的一部分到客户端，可以用来请求部分数据而不是整个资源。
Range的格式通常是Range: <unit>=<start>-<end>，其中<unit>表示范围所采用的单位，通常是字节（bytes），<start> 和 <end> 表示请求的起始字节和结束字节的位置。
Range语法如下：
服务器收到请求后，正确处理请求会回复206 Partial Content，未正常处理则会回复其他响应码。下表是服务器回复的常见响应码：
| 服务器响应码  | 常见的原因  |
| --- | --- |
| 206 Partial Content  | 服务器收到正常Range请求的响应码，返回部分内容的响应。  |
| 416 Range Not Satisfiable  | 所请求的范围不合法，表示服务器错误。  |
| 200 OK  | 服务器忽略了 Range 首部，返回整个文件。  |
服务器响应码
常见的原因
206 Partial Content
服务器收到正常Range请求的响应码，返回部分内容的响应。
416 Range Not Satisfiable
所请求的范围不合法，表示服务器错误。
200 OK
服务器忽略了 Range 首部，返回整个文件。
断点续传下载示例代码如下：
多文件下载监听
文件下载监听是指在单文件下载的功能基础上，同时进行多个文件下载进度和状态的监听管理。实际开发中，需要使用request上传下载模块实现，包括监听每个文件下载任务的进度，任务是否暂停，下载是否完成等状态情况。相关规格说明参考request.agent.create。
以具体场景为例，下图是常见的多文件下载列表：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151151.14051117787320284490007129416903:50001231000000:2800:8FF35FF4C5BBE2A288F475E718C3C90E4B9EC1B0043E7A5C1A7B68C0DB50BBDA.png)
进入页面后，点击“全部开始”，启动所有文件的下载任务。点击“全部暂停”，暂停所有文件下载任务。再次点击“全部开始”,可重新启动未完成的下载任务。下载完成的文件会保存在应用缓存路径下。如果出现下载失败，一般是网络不稳定，点击“全部开始”可重新下载。
实现思路
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-texture-compression-improve-performance
爬取时间: 2025-05-01 08:51:29
来源: Huawei Developer
概述
在开发应用时，当开发者预置图片资源超过一定数量或者大小，由于图片资源的格式需要通过CPU解压缩为纹理格式才能直接被GPU读取，这就增加了CPU的处理时间，可能会引起图片完成时延增长。并且CPU解压缩生成的图片资源会占用较多的内存空间，给内存造成更大的压力，可能会引起卡顿掉帧。此时可以借助纹理压缩技术，将预置图片在构建过程中进行转码和压缩，节省CPU的处理过程，减少占用内存，提升应用性能。
需要注意纹理压缩会在编译构建时提前处理预置图片，可能会提高编译时长并造成包体膨胀的问题。因此如果资源图片占比较大，导致对包体积影响过于显著，则可以对图片资源进行筛选，从而降低纹理压缩的开销影响。
实现原理
预置图片在不设置纹理压缩的情况下，图片首先要经过CPU的解码生成PixelMap，并上传给GPU生成纹理进行渲染。解码和上传均比较耗时，开发者可以使用纹理压缩技术将CPU解码和纹理生成的过程提前到编译构建的过程当中，从而减少CPU处理图片的耗时。纹理压缩首先需要在编译文件配置相关属性，然后在构建态时根据相关配置找到对应的预置图片进行纹理转换生成纹理码流，之后进行超压缩编码生成超压缩码流。编译完成进入运行态后进行超压缩解码生成纹理码流，GPU将读取纹理码流后进行渲染显示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151151.69746017655118036924716574972828:50001231000000:2800:E61AAB17009ECEED637D9B9AC96C3A7EFF3A82F6BEDB88EF525177872DA994CE.png)
纹理压缩是在编译构建中对预置图片进行处理的，首先需要在编辑器的编译文件中配置纹理压缩的相关参数，hvigor根据配置的参数读取将要纹理压缩的文件资源，然后hvigor构造restool命令开始解析并生成资源文件列表，之后根据文件列表来遍历资源文件，将待转换文件进行转码生成纹理格式的文件，已经转换的资源文件不会再打包到构建产物中，最后将纹理文件和未转换的文件一起构建生成资源产物。
编译构建资源文件开启纹理压缩时序图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151151.70041548377999163344827710174906:50001231000000:2800:0EF97B333B8C211CC124C23DFD606FA50A3657AC797844464BC658D89FA5B4C8.jpg)
场景案例
由于图片格式不能直接被GPU渲染，需要等待CPU解码后上传GPU，需要一定耗时，当一定数量的预置图片在一个页面同时进行渲染时，可能会造成图片的完成时延过大。以如下场景为例，设计一个Tab栏切换的示例，当向右滑动切换到tab2的页面时，新页面中通过横列布局加载40张.png格式和40张.jpg格式的预置图片，对比开启和关闭纹理压缩两种情况下，图片完成时延显著不同。未开启纹理超压缩切换过程的效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151151.37269875732431227006781429505545:50001231000000:2800:33F3024146ACBFEDD37EBF31C6CDE0C4815601D5CD83DDB56C283AB8B698F227.gif)
在不使用纹理压缩的情况下，当向右滑动切换到tab2的页面时，由于新页面有较多的预置图片需要加载时，会造成一部分图片的完成时延过大，显示会有白块的情况出现。
工程配置
使用纹理压缩首先需要进行一些基础配置，从而选择要将哪些预置图片进行纹理超压缩。可以在工程级或模块级build-profile.json5配置文件中添加纹理压缩的配置项。纹理超压缩的配置项是在compression对象中添加media和filters两个属性值的内容：
media： 在media中enable属性是控制是否对media图片启用纹理压缩。默认的属性值为false，默认不启用，需要开启纹理压缩时将其属性值改为true。
filters： 在filters属性中可以配置三个属性对象，分别是method、files和exclude。
基本编译配置项的类型及说明可参考compression。纹理压缩配置的示例代码如下：
配置项注意点：
按大小匹配是一维数组，因此按大小匹配[0-1k，1k-2k]与按大小匹配[0-2k]的取值范围是相同的。
按分辨率匹配时，匹配分辨率的宽高值是二维数组，下图左侧代表分辨率小于2048*2048的所有图片，右侧代表分辨率小于1024*1024的图片和分辨率大于1024*1024且小于2048*2048的图片。两个写法看似相同，但其取值范围并不一样。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151151.39969751546946252622407244857108:50001231000000:2800:17032CC20B484AEAF387101E5A26752F1474E56A88C5D26605072AABD134AFE4.png)
编译执行
在配置完相关的参数后，执行项目进行编译构建。在编译过程中，hvigor会根据配置的参数获取需要转换的预置图片，通过转码部件纹理压缩后进行打包。使用纹理压缩后进行Tab栏切换的效果图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151151.51225471422511679644156782045376:50001231000000:2800:BE678018D59134442C2DAE48897A54A438B6D3F8E71FA986178C2989C2494158.gif)
通过效果图可以看出，使用纹理压缩的情况下，向右滑动切换tab2的页面后图片直接出来显示，不会出现图片显示延迟的状况，没有出现显示白块的情况。
收益和开销
使用纹理压缩进行预置图片资源转换时，要注意覆盖的资源文件的多少，要考虑在获取更大收益的同时减少其开销造成的影响。因此纹理超压缩的性能提升要从收益和开销两部分进行分析：
收益
纹理压缩的主要收益是在编译过程中将预置图片转换为纹理格式，能直接被GPU读取进行渲染，降低了CPU和DDR的负载，能更快的加载图片。在Tab栏切换示例中将预置图片分别以原图（.png）、纹理超压缩（.sut）和自适应可变纹理压缩（.astc）三种方式为例，测试图片的读取耗时如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151151.24899045157271001917080151799310:50001231000000:2800:4B8ED0E2853AFCB3153E0C4356B9EEE5622617AAEDF16C69DC96CE57BD2593E9.png)
统计以上H:CreateImagePixelMap的耗时得到下表：
| 文件  | 耗时  | 收益  |
| --- | --- | --- |
| 原图（.png）  | 62.103ms  | -  |
| 纹理超压缩（.sut）  | 15.309ms  | 4.13倍  |
| 自适应可变纹理压缩（.astc）  | 38.239ms  | 1.63倍  |
文件
耗时
收益
原图（.png）
62.103ms
-
纹理超压缩（.sut）
15.309ms
4.13倍
自适应可变纹理压缩（.astc）
38.239ms
1.63倍
通过上表可以看到，使用原图（.png）格式的图片加载耗时是纹理格式的加载耗时4倍左右，纹理超压缩和自适应可变纹理压缩两种图片加载耗时2倍左右。在开启纹理超压缩或自适应可变纹理压缩的情况下可以有效地提高应用中预置图片的加载速度。
在对比完加载图片的耗时后，使用Tab栏切换示例做内存大小的测试，查看使用纹理压缩前后的内存占用情况，得到相关数据如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151151.33786123842580069968806707253391:50001231000000:2800:9775267162BD7BEA1D8BD866248CE65C838DCD7295F89B95EC8696549F5620A9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151151.31003084461534109463969677727832:50001231000000:2800:859F83491E6DAAA3EB5690C47C75FA497CF2454B6195E93D9D516DCE78C86313.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151151.24881354518242572181306891269079:50001231000000:2800:FE0D46CBE7226DABD99E2493E6D441F7DB53ABA73B86193424F74875626FFADF.png)
统计纹理压缩开启前后的内存占用大小数据如下表：
| 是否开启纹理压缩  | 内存占用大小  |
| --- | --- |
| 开启（.sut）  | 165015KB  |
| 开启（.astc）  | 167723KB  |
| 关闭  | 598965KB  |
是否开启纹理压缩
内存占用大小
开启（.sut）
165015KB
开启（.astc）
167723KB
关闭
598965KB
通过表中数据可以知道，开启纹理压缩后内存的占用从598965KB下降到了165015KB~167723KB，图片加载占用内存的大小降低。
开销
使用纹理压缩时，由于在编译过程中进行预置图片的转换，因此会增加编译的时长。并且在将预置图片转为纹理格式时，根据预置图片的格式的不同，转换后的大小也不相同，会让包体膨胀或收缩。
编译时间长的问题是因为在编译过程中增加了纹理压缩的过程，可以各准备87张png/webp/jpg预置图片分别以全量编译、修改按分辨率过滤参数和增加1~100张图片三种情况进行编译打包，对比三种情况下纹理压缩打开和关闭的编译时长，得到相关数据如下表所示：
| 测试用例  | 纹理压缩关  | 纹理压缩开  | 增加耗时说明  |
| --- | --- | --- | --- |
| 全量编译  | 19s 74ms  | 1min 16s  | 遍历资源文件+纹理压缩+搬移资源文件  |
| 修改按分辨率过滤参数  | -  | 16s 487ms  | 遍历资源文件+搬移资源文件  |
| 增加1~100张图片  | 10s 177ms~10s 283ms  | 16s 491ms~16s 673ms  | 遍历资源文件  |
测试用例
纹理压缩关
纹理压缩开
增加耗时说明
全量编译
19s 74ms
1min 16s
遍历资源文件+纹理压缩+搬移资源文件
修改按分辨率过滤参数
-
16s 487ms
遍历资源文件+搬移资源文件
增加1~100张图片
10s 177ms~10s 283ms
16s 491ms~16s 673ms
遍历资源文件
从上表可以看出开启纹理压缩后全量编译耗时较大，但是按分辨率过滤预置图片后再次纹理压缩，能够有效减少编译时长。
在对比完编译时长的问题后，对若干个示例应用进行侧量，其中.jpg和.webp格式图片的膨胀率为2~3倍左右。 具体开启纹理超压缩后体积的膨胀率得到相关数据如下表所示：
| 图片格式  | 纹理压缩相比原图膨胀率  |
| --- | --- |
| .jpg  | 3.05  |
| .png  | 0.92  |
| .webp  | 2.50  |
图片格式
纹理压缩相比原图膨胀率
.jpg
3.05
.png
0.92
.webp
2.50
具体工程应用会因为实际工程内资源大小、格式、分辨率和数量等因素的不同产生不同的包体膨胀率，以上数据仅供开发者参考。
可以看到.png格式的图片纹理压缩后，没有膨胀，但是.jpg格式和.webp格式的图片包体积膨胀较大。因此结合编译时长和打包体积综合来看，为了使用纹理超压缩获得更好的性能，在对包体积敏感的场景下，可以采用对.png格式图片全转；对.jpg、.webp格式的图片挑选其中被高频使用或者对关键帧有关键影响的部分图片进行转换的策略。
总结
在开发应用时，如果在应用中预置一定数量的图片，开发者可以考虑使用纹理压缩的方法来转换并压缩图片资源，提升应用性能。开发者可以在项目的工程级或模块级build-profile.json5配置文件中添加纹理压缩的配置项，编译构建时将设置的图片资源转化并压缩，生成资源包。这些转化后的图片资源可以被GPU直接使用，省略了CPU的处理过程，提高图片的显示速度，减少内存的占用，从而实现内存的提升。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-screen-flicker-solution
爬取时间: 2025-05-01 08:51:46
来源: Huawei Developer
概述
在开发调试过程中，有时会遇到应用出现非预期的闪动，这些闪动现象统称为闪屏问题。这些闪屏问题触发原因不同，表现形式不同，但都会对应用的体验性和流畅度产生影响。
本文将概述如下几种常见的闪屏场景，对其成因进行深入分析，并提供针对性解决方案，以帮助开发者有效地应对这些问题。
常见问题
动画过程中，应用连续点击场景下的闪屏问题
问题现象
在经过连续点击后，图标大小会出现不正常的放大缩小，产生闪屏问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151151.37012395832011300249621760086260:50001231000000:2800:D758F2B6FB88CCC8A4EB12E2C1B9FA28AD65D7FF18340E116289E3002D0686C6.gif)
可能原因
应用在动画结束回调中，修改了属性的值。在图标连续放大缩小过程中，既有动画连续地改变属性的值，又有结束回调直接改变属性的值，造成过程中的值异常，效果不符合预期。一般在所有动画结束后可恢复正常，但会有跳变。
解决措施
运行效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151152.64527145058033698482191657741063:50001231000000:2800:9E2EAE208423E717097637AF9303D5371144B3533D15B56A03F37CE2BEC9F525.gif)
动画过程中，Tabs页签切换场景下的闪屏问题
问题现象
滑动Tabs组件时，上方标签不能同步更新，在下方内容完全切换后才会闪动跳转，产生闪屏问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151152.24277525716793609952395635081558:50001231000000:2800:48CDA6E7EFC5E99A9335EF8FD285FBE15BFF6E369FE7F22948FEEB053ACE50B5.gif)
可能原因
在Tabs左右翻页动画的结束回调中，刷新了选中页面的index值。造成当页面左右转场动画结束时，页签栏中index对应页签的样式（字体大小、下划线等）立刻发生改变，导致产生闪屏。
解决措施
在左右跟手翻页过程中，通过TabsAnimationEvent事件获取手指滑动距离，改变下划线在前后两个子页签之间的位置。在离手触发翻页动画时，一并触发下划线动画，保证下划线与页面左右转场动画同步进行。
TabsAnimationEvent方法如下所示。
运行效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151152.76286906843178182978623265418829:50001231000000:2800:4086B5069636DCF307D31CB2CA71ED87C332B47A953A5FD9B9EFE1401EB9CBD3.gif)
刷新过程中，ForEach键值生成函数未设置导致的闪屏问题
问题现象
下拉刷新时，应用产生卡顿，出现闪屏问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151152.02000830410801387584325862954129:50001231000000:2800:B5B14E718E9E449658B47483F87B359441EBBA50CC8A6C9E41799F2FC552B652.gif)
可能原因
ForEach提供了一个名为keyGenerator的参数，这是一个函数，开发者可以通过它自定义键值的生成规则。如果开发者没有定义keyGenerator函数，则ArkUI框架会使用默认的键值生成函数，即(item: Object, index: number) => { return index + '__' + JSON.stringify(item); }。可参考键值生成规则。
在使用ForEach的过程中，若对于键值生成规则的理解不够充分，可能会出现错误的使用方式。错误使用一方面会导致功能层面问题，例如渲染结果非预期，另一方面会导致性能层面问题，例如渲染性能降低。
解决措施
在ForEach第三个参数中定义自定义键值的生成规则，即(item: NewsData, index?: number) => item.id，这样可以在渲染时降低重复组件的渲染开销，从而消除闪屏问题。可参考ForEach组件使用建议。
运行效果如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151152.19306544919635134832856984682499:50001231000000:2800:46E1F026867E9F1BCE51DF1DF05329A7822C60AB54FC4963FF089011AD86E867.gif)
总结
当出现应用闪屏相关问题时，首先定位可能出现的原因，分别测试是否为当前原因导致。定位到问题后尝试使用对应解决方案，从而消除对应问题现象。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-power-consumption
爬取时间: 2025-05-01 08:52:00
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-power-consumption-experience
爬取时间: 2025-05-01 08:52:13
来源: Huawei Developer
应用功耗体验建议
应用功耗体验是用户在使用应用程序时的重要考量因素之一。因为手机等移动设备具有便携、移动的属性，其续航时间的长短直接影响用户对移动设备的体验和满意度。移动设备的续航时间越长，用户就可以更长时间地使用设备，无需频繁充电，在户外或旅行场景下提供便利。为了提升应用的功耗热体验、规范应用全生命周期软硬件资源合理使用，应用在开发阶段和测试阶段可以参考以下体验建议。
主要包括如下两种场景：
本标准适用于应用和元服务的低功耗设计、开发及检测。
应用功耗体验设计
应用功耗体验是指用户在使用应用时对应用所消耗电量（即功耗）的感受和反馈。高功耗不仅会导致设备发热、续航时间缩短，还可能引发用户的电量焦虑，从而影响用户体验、降低用户的使用意愿。因此如何在应用运行期间保持低功耗是应用开发过程中无法避免的话题。
低功耗是指设备在运行各种任务时，通过采用一系列技术和策略来降低设备的能耗，从而延长电池寿命和设备使用时间。根据用户的感知情况不同，任务主要分为用户可见的前台任务与用户不可见的后台任务。
-  前台任务指那些直接与用户进行交互的任务，它们通常会在用户界面中显示，并实时响应用户的操作。这些任务通常具有以下几个特点：
-  后台任务是指那些不需要与用户直接交互，或者仅在用户不可见的情况下运行的任务。这些任务通常具有以下几个特点：
为了保障用户良好的功耗体验，开发者需要合理设计和管理应用的前台和后台任务来保障应用低功耗运行。
前台任务低功耗设计
前台任务功耗是指应用在用户可见并与其交互时的功耗。在这种情况下，应用需要处理大量的用户界面（UI）更新、事件处理、计算任务以及网络请求等。这些操作都会消耗大量的CPU、内存、网络以及屏幕等资源，从而导致较高的功耗。
本节主要针对前台场景下的帧率、前台绘制渲染以及前台资源使用三个方向提供低功耗设计。
帧率
帧率相关的详细低功耗体验设计可参考：基于LTPO的低功耗设计。
LTPO指自适应刷新率技术。通过按需自适应调整显示刷新率，实现最优的性能和功耗体验。应用通过适配LTPO可以精细化场景帧率控制，降低场景负载，减少偶发卡顿，降低场景功耗。
可变帧率能力支持开发者自定义应用业务的帧率，其常见的使用场景：
前台绘制渲染
前台绘制渲染相关的详细低功耗体验设计可参考：省电和深色模式下低功耗设计与高效利用HWC的低功耗设计。
HarmonyOS默认提供了电源模式的特性，主要分为以下三类：正常模式、性能模式以及省电模式。当设备电量较低时，系统可以切换至省电模式，以减少设备的能耗并延长电池的使用时间。通过与系统省电模式的配合，应用程序可以更加智能地调整自身的功耗策略，以适应设备电量较低的情况，从而延长设备的续航时间，提供更加稳定和持久的使用体验。
深色模式使用更少的像素点和背光，因此能够减少能量的消耗。其次，深色模式在OLED屏幕上可以关闭像素点，这一特性进一步减少了能耗。
HarmonyOS系统基于的芯片平台除了通用的CPU/GPU计算单元外，还提供了Hardware Composer（下文简称HWC）专用硬件辅助系统进行图形渲染送显，相对于通用计算单元，在图层叠加场景具有更高的处理效率和更低的能耗。作为专用硬件单元，HWC需要满足一定条件才能充分发挥其硬件能力，降低系统CPU/GPU开销，减少发热和卡顿现象的出现。
前台资源使用
前台资源相关的详细低功耗体验设计可参考：合理使用前台资源。
应用前台使用系统资源不当，可能会造成设备耗电快、发热等现象。通过前台资源使用的相关低功耗规则，可以帮助开发者降低设备耗电速度，保障用户功耗热基础体验。
目前主要提供了音乐播放、导航定位、静态场景、视频场景以及网络资源等前台资源使用的低功耗规则与建议。
后台任务低功耗设计
后台任务功耗是指应用在用户不可见且未与其交互时的功耗。与前台任务相比，后台任务通常不需要处理大量的UI更新和事件，因此功耗相对较低。然而，后台任务仍然需要执行一些必要的操作，如数据同步、状态更新等，这些操作也会消耗一定的资源。
本节主要针对后台场景下的任务、硬件以及软件资源使用三个方向提供低功耗设计。
后台任务
后台任务相关的详细低功耗体验设计可参考：合理使用后台任务。
应用退至后台后，如果继续活动，可能会造成设备耗电快、用户界面卡顿等现象。为了降低设备耗电速度、保障用户使用流畅度，系统会对退至后台的应用进行管控，包括进程挂起和进程终止。为了保障后台音乐播放、日历提醒等功能的正常使用，系统提供了规范内受约束的后台任务，扩展应用在后台运行时间。
后台硬件资源
后台硬件资源相关的详细低功耗体验设计可参考：合理使用后台硬件资源。
后台硬件资源通常指的是支持后台运行和服务所需的物理设备及其相关组件。后台硬件资源是确保后台系统稳定运行和高效性能的基础。通过合理配置、优化和管理这些资源，可以满足后台系统的各种需求，提升系统的整体性能和稳定性、降低设备整体功耗。
目前主要提供了CPU、蓝牙、网络、音频、GPS、传感器等后台硬件资源使用的规范与建议。
后台软件资源
后台软件资源相关的详细低功耗体验设计可参考：合理使用后台软件资源。
后台软件资源是指那些支持后台操作和服务的软件系统，这些资源在确保后台系统的正常运行、数据处理、业务逻辑实现以及与前端的交互等方面发挥着至关重要的作用。合理使用这些资源可以提高系统整体的性能、降低设备整体功耗。
目前主要提供了上传下载、音频播放、定位导航以及系统资源等后台软件资源使用的规范与建议。
应用功耗关键指标
综合考虑业界共识指标和实际用户使用体验，将主要对比屏幕显示耗电量、CPU耗电量、GPU耗电量以及最终总耗电量，关键指标详情如下所示：
通过对应用功耗关键指标的检测与分析，可以帮助开发者降低应用运行时的总功耗、提高用户体验感。详细的应用功耗检测与分析方法可参考：应用功耗检测与分析。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-power-consumption-analysis
爬取时间: 2025-05-01 08:52:26
来源: Huawei Developer
概述
应用功耗体验是指用户在使用应用时对应用所消耗电量（即功耗）的感受和反馈。高功耗不仅会导致设备发热、续航时间缩短，还可能引发用户的电量焦虑，从而影响用户体验、降低用户的使用意愿。综合业界的共识与实际用户的体验而言，应用功耗关键指标通常包括显示耗电量、CPU耗电量、GPU耗电量以及最终的总耗电量等。本文主要围绕功耗体验指标的CPU耗电量进行检测与分析，帮助开发者降低应用运行时的总耗电量。
应用功耗检测
应用功耗检测是指对移动应用在运行过程中的能量消耗进行测试和评估的过程。通过功耗检测，开发者可以了解应用的能耗情况，并进行优化，减少能源损耗、提高设备续航、提升用户体验。
应用功耗检测有以下几种方案：
详细的检测方法如下：
基于设备实时帧率检测
1.  启用开发者选项：在设备上查看设置 > 系统中的开发者选项是否存在，如果不存在，可在设置 > 设备名称中，连续七次单击“版本号”，直到提示“开启开发者选项”，点击确认开启后输入PIN码（如果已设置PIN），设备将自动重启，等待设备完成重启即可。 打开开发者模式中的"显示刷新频率"开关。具体操作：设置中搜索"开发者" -> "显示刷新频率"。 开关开启后共显示如图所示两个数字： 通过帧率开关，可以对当前场景是否可能存在动画空跑问题有一个基础的概念，若当前页面实际静置或仅有一个低帧率动画刷新，那么右侧刷新帧率高于预期时，可以视作当前场景存在空跑问题。
2.  打开开发者模式中的"显示重绘刷新区域"（俗称“脏区”）开关。具体操作：设置中搜索"开发者" -> "显示重绘刷新区域"。开关开启后，红色或蓝色的框线将会在屏幕上标注出当前屏幕正在刷新的位置与面积，同时框线的左上角有四位数字，表明当前脏区所处的坐标。脏区大小直接决定了每帧的绘制负载，开发者可以通过当前页面的脏区大小和变化情况，判断当前页面是否存在空跑问题。 一般情况下帧率开关与脏区开关需要交替分析来定位脏区。不建议同时开启帧率开关与脏区开关，脏区的变化也会视作屏幕的刷新，帧率的数字变化也是脏区的一部分，两者同时开启可能会互相影响，导致显示的帧率高于实际页面帧率。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151152.72159175799059210191945599338394:50001231000000:2800:ADECB0B1E44299D4E8AFE3068B4DE5F525187192CDA87310A7A68AE7A97A86C7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151152.82801317763498591050468042991819:50001231000000:2800:F2F4F6AF079AC37DAE18FB6210D64FF423DCD87C38E4EC7BF8F03C7F105044FF.png)
基于Profiler工具检测
设置开发者选项：
1.  启用开发者选项：在设备上查看设置 > 系统中的开发者选项是否存在，如果不存在，可在设置 > 设备名称中，连续七次单击“版本号”，直到提示“开启开发者选项”，点击确认开启后输入PIN码（如果已设置PIN），设备将自动重启，等待设备完成重启即可。
Profiler工具查看功耗：
DevEco Profiler是DevEco Studio内置集成的场景化的性能分析工具。它提供了实时监控（Realtime Monitor）能力，可以全方位地进行设备资源监测，可以帮助开发者识别功耗故障。通过性能工具，开发者可以及时了解应用或元服务的CPU、内存、图形等资源的使用情况，高效定界问题所在，快速定位问题代码，提高解决问题的效率。
使用Profiler工具查看功耗的步骤如下：
1.
2.  使用Profiler实时监控能力观察设备温度变化，以及各器件的功耗数据，确定发热场景和功耗来源。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151153.81460053406300541338020570896009:50001231000000:2800:46741D4F6A16C7F58A0A67F256683AE34FB9A905B0FF09DB2A919F1BE307EFF5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151153.23710416687647929942073959353617:50001231000000:2800:4BCB062B251DBBCC876C44E089EC096B8681F49B8F306F2560E5E2D0F6241A24.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151153.76798793939103666313319970225730:50001231000000:2800:4BD8D20D9BD7B77D74C00D26EDFB5BC4EE95374DB189C3D492678D3F4AFAA8AB.png)
基于HismartPerf工具检测
通过HiSmartPerf-Device工具可以在手机设备上简单、快捷地采集FPS、功耗、温度、负载等基础性能数据，并生成测试报告，可以帮助开发者快速了解应用的性能情况。
1.  点击下载地址下载Device版本工具并进行安装。
2.  在手机端点击桌面SmartPerf应用图标打开HiSmartPerf-Device工具，设置好采集要求之后，即可开始进行性能数据采集。详细的性能数据采集流程可参考：采集性能数据。
基于电源设备检测
指通过使用第三方精密仪器（如程控电源等）来测试设备的整体耗电量。这种方法可以获取比较准确的电量数据，但测试成本较高，且无法直接针对单个应用进行功耗评估。测量方法可参考：程控电源。
问题分析流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151153.52065225909931495823011816111686:50001231000000:2800:6CDD16E89AFB23A0B846662F5A5E134937335DE7E1EB653E2EADE2B80E72F601.jpg)
在进行功耗相关问题定位时，首先需要关闭USB充电模式，使用Profiler实时监控观察温度以及功耗变化，明确问题的具体场景以及功耗来源；然后开启Frame录制，通过Trace进行CPU频点与负载分析。此时可能会遇到以下三种情况：
-  需要通过Allocation和Snapshot模板来分析内存使用情况。
-  需要通过Trace泳道分析是否存在冗余绘制及组件未复用等情况，主要是结合应用主进程、render_service、RSUniRenderThre以及RSHardwareThrea这些管线里面的帧率、帧长、未送显情况进行详细分析。
-  需要借助Callstack泳道分析函数栈，排查应用的业务逻辑是否存在异常，是否频繁执行了长耗时任务，或者进入异常业务逻辑导致了无限循环。
针对以上情况进行详细的分析定位，确认根因后进行修复，然后观察功耗以及发热情况是否满足性能要求，如果不能满足，则重复进行分析定位。
Trace分析CPU负载
案例一：应用侧某线程负载过高
问题背景：某应用使用过程中，边刷视频边查看评论或推荐时，手机发烫严重，关闭应用后逐渐恢复正常。
分析详情：
1.  选择CPU Core泳道，通过下方详情区可以看出应用进程占比时长较高。 查看CPU频点情况，通过查看Frequency泳道发现CPU核的频点都很高，CPU调度非常频繁。 Frequency子泳道：表示CPU频率，鼠标悬浮在Frequency泳道上，可以看到CPU的运行频率。 当所有CPU核频点都较高时，选择CPU Core泳道，查看CPU负载来源。通过详情区，可以看到CPU负载主要来源于应用侧的子线程（线程号55523）。
2.  本案例中，CPU负载主要来源于应用侧的子线程（线程号55523）。需要借助Callstack泳道分析该线程执行的任务，结合函数栈排查业务逻辑是否存在异常。大多情况下都是由于该线程频繁执行长耗时任务或者无限循环逻辑导致的。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151153.66180743597057667133339502136837:50001231000000:2800:C622D9EA9E2D2EE56B8D7F84D193A6C905D6014DFBE2C45994F694FE0D7EE8CF.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151153.33935295461019511914775837178186:50001231000000:2800:A08E44D1B2D96C0BBDE60A9395126051A45E3817F8425FC3D23CB5255AF4C3BA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151153.30306169554425366595246811784850:50001231000000:2800:D5F44EC476DA38E56F5E69897C3D9B1688B95FC4CAFB9E019DB02DBD4E50BABF.png)
案例二：GC线程负载过高
问题背景：某应用使用期间，屏幕发烫严重，壳温高达40摄氏度；结束应用后，温度自行恢复正常。
分析详情：
1.  选择CPU Core泳道，通过下方详情区可以看出，应用进程占比时长较高。不同应用的应用进程名称不同，一般与应用包名一致。 查看CPU频点情况，通过查看Frequency泳道的CPU频率可以看出CPU部分核上频点很高，基本保持在最高频状态运行。即下图中的CPU10、CPU11，其对应的Frequency子泳道基本被填满。 当部分核频点较高时，选择CPU频点比较高的核对应的Slice子泳道，查看CPU负载来源。即CPU10与CPU11对应的Slice子泳道，通过详情区可以看到CPU负载主要来源于应用进程的OS_GC_Thread线程。
2.  本案例中，CPU负载主要来源于应用进程的OS_GC_Thread线程。针对GC线程负载高的情况，需要借助Allocation和Snapshot模板具体分析内存使用情况。详细分析方法参考：Allocation分析和Snapshot分析。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151153.24617523912782008535084022879761:50001231000000:2800:1A37EC1D2D36352AD4CD0914A7DB50D229372CAB0DE863FAF51DBE6FBF875991.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151153.88851247820470535901687767354004:50001231000000:2800:16002BC35F5599C954DEBD75D2AF7CF2E369198F2539B7B177167795202F1182.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151153.78742496415690981987154395288904:50001231000000:2800:F439DE031D6B0B55007A5C5430379D11A6501DA7F1E505D2A09443487A9F4C5A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151153.57337769059608035769311457055195:50001231000000:2800:1FE269D7D0049DA47F5A9C3FEFF8C379D746231E19601D9914C8DA5BA7643A0F.png)
案例三：UI主线程负载过高
问题背景：在某应用上进入直播页面进行观看，功耗超100mA，手机温度持续升高。
分析详情：
1.  选择CPU Core泳道，通过下方详情区可以看出，应用进程占比时长较高。 查看CPU频点情况，通过查看Frequency泳道发现CPU部分核（CPU10、CPU11）的频点很高，且每个CPU核调度都非常频繁。 选择CPU Core泳道，查看CPU负载来源。通过详情区，可以看到CPU负载主要来源于应用UI主线程（线程号43436，与应用进程号一致为主线程）。
2.  本案例中，CPU负载主要来源于应用UI主线程。需要分析UI主线程的Trace泳道判断是否存在冗余绘制及组件未复用等情况。 找到UI主线程对应的Trace泳道（可以根据应用包名或上一步中的线程号查找）。选择对应的线程泳道，可以看到详情区包含了线程运行状态，选择Thread States，可以看出Running状态占比非常高。 查看Slice List，检查是否存在冗余绘制及组件未复用等情况。选择Slice List，发现id为-1的Image一直在执行绘制任务，Occurrences达到了4万多次。然后借助ArkUI Inspector工具进行排查确认组件是否存在冗余绘制情况。关于ArkUI Inspector的使用可参考：布局分析。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151154.18406617114720097692118524258670:50001231000000:2800:F9D75422DA41C26CAED42640AC07805815904D6AF83CB19439353291C0CD95DA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151154.35572791018172101392632161754010:50001231000000:2800:AE6FD16589FCDED495696DE5F9CA149AEBFC54FD7389E8470354D1F0CF551AC4.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151154.67550264214470888433471776280408:50001231000000:2800:5617EFF0B2A534D0223448269E6CAC8126ABBFE2426E0BA583137A1E6DAC1808.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151154.65850534965345790995309742856791:50001231000000:2800:459E74AF30B56CAA6886AB9C4173E67FCF151F8369AF00944FF7A45223495F7C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151154.14634460423632189008957422110945:50001231000000:2800:93E4C84AD35347E009E84BC89E61903B1F112FF3E08737E7370D0A6820808DB0.png)
常见根因与解决方案
LTPO低功耗
LTPO指自适应刷新率技术。通过按需自适应调整显示刷新率，实现最优的性能和功耗体验。应用通过适配LTPO可以精细化场景帧率控制，降低场景负载，减少偶发卡顿，降低场景功耗。
具体内容见基于LTPO的低功耗设计。
省电和深色模式
具体内容见省电和深色模式下低功耗设计。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-low-power-consumption-of-foreground-tasks
爬取时间: 2025-05-01 08:52:39
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-low-power-design-in-dark-mode
爬取时间: 2025-05-01 08:52:54
来源: Huawei Developer
概述
低功耗是指设备在运行各种任务时，通过采用一系列技术和策略来降低设备的能耗，从而延长电池寿命和设备使用时间。因为手机等移动设备具有便携、移动的属性，其续航时间的长短直接影响用户对该品牌手机的体验和满意度。移动设备的续航时间越长，用户就可以更长时间地使用设备，无需频繁充电，在户外或旅行场景下提供便利。一般而言，为了提供更长的续航时间，可以采取了多种技术和方法来降低功耗、优化电池管理，如优化软件算法、优化屏幕亮度和显示等。其中，省电模式和深色模式是手机功耗优化中常用的优化手段：
为了有效去测量手机运行时的功耗，DevEco Profiler提供实时监控（Realtime Monitor）能力，可帮助开发者实时监控设备资源（如CPU、内存、FPS、GPU、Energy等）使用情况，其中Energy以3s为周期进行刷新，体现统计周期内总功耗以及各耗能部件（包括CPU、Display、GPU、Location、Other）的功耗占用情况。综合考虑业界共识指标和实际用户使用体验，实验将主要对比屏幕显示耗电量、CPU耗电量、GPU耗电量以及最终总耗电量，关键指标如下所示：
本文将以 “HMOS世界”APP 为例，通过设置省电模式和深色模式来验证不同场景下对手机功耗的影响，观察手机的电量消耗变化情况。同时本文还探讨了主动降低应用亮度、停止冗余动画两项降低功耗的措施，测试不同条件下的电量消耗情况。实验结果表明：
通过设置省电模式、深色模式、调节屏幕亮度调节、停止冗余动画，最终测量的总耗电量对比如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151154.45152940218254293089207194797843:50001231000000:2800:20EEF1D84F788B06FC890DA952EDB866C60FC108161E7E87D8AF7FDD8092EFEA.png)
功耗测量工具
DevEco Profiler
DevEco Profiler应用调优工具（以下简称为Profiler）内置集成在DevEco Studio内，提供场景化的调优体验，不仅方便开发者及时了解应用或服务的CPU、内存、图形等资源的使用情况，还提供了高效的问题定位能力，帮助开发者快速定位到问题所在代码。使用Profiler测试应用程序功耗的方法如下所示：
Profiler耗电量示意图如下所示，详细信息及使用可参考实时监控。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151154.89906380279913002458322765604219:50001231000000:2800:FA9B8F231EBA0F0CAC1305B78C1B3CCDCA16DD7AAE6A6D617B8B5DFE0840C6C0.png)
程控电源
程控电源是一种可以进行电压、电流、功率、电阻等参数控制的电源设备，它可以根据用户设定的参数来输出相应的电压和电流，从而满足不同的测试需求。程控电源可以通过编程控制来模拟不同的负载条件，从而测试应用程序在不同负载下的功耗表现。通过这种方式，开发人员可以更好地了解应用程序的能耗特性，从而针对性地进行优化。
使用程控电源测试应用程序功耗的方法如下所示：
省电模式
原理介绍
HarmonyOS默认提供了电源模式的特性，主要分为以下三类：
-  切换了电源模式后，随之更改的配置项有：
在电源管理方面，HarmonyOS采用了自动切换配置，通过更改不同的配置项来实现不同的电源模式。例如，在正常模式下，系统会自动调节屏幕旋转，以保证用户在横屏和竖屏模式下都能够获得最佳的视觉效果；而在省电模式下，系统会关闭这一功能，以降低屏幕旋转带来的能耗。
场景案例
当设备电量较低时，系统可以切换至省电模式，以减少设备的能耗并延长电池的使用时间。通过与系统省电模式的配合，应用程序可以更加智能地调整自身的功耗策略，以适应设备电量较低的情况，从而延长设备的续航时间，提供更加稳定和持久的使用体验。
一般而言，获取当前设备的电源模式可以通过以下步骤实现：
在省电模式下，获取当前系统的电源模式的代码如下所示：
功耗分析
同一界面下滑动列表项，分别对比正常模式和省电模式来测试关闭和开启省电模式情况下的总耗电量和CPU模块、GPU模块、显示模块的耗电量。最终，使用DevEco Studio的Profiler工具测量得到的数据如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151154.97890607825325448711529831789678:50001231000000:2800:FA7A107786AE15D42E94EECEC5928EC4553525B997FE847CD369C44ADEEDFA7A.png)
从测试数据可以看出：
这一结果表明省电模式的使用对设备的节能有着显著的效果，通过降低亮度、开启自动调节亮度等方式，省电模式降低了显示模块的能耗，从而达到了降低总体能耗的目的。
深色模式
原理介绍
通过启用深色模式，可以进一步实现能耗的降低。首先，深色模式使用更少的像素点和背光，因此能够减少能量的消耗。其次，深色模式在OLED屏幕上可以关闭像素点，这一特性进一步减少了能耗。在实际开发过程中，应用需要根据当前设备状态来适配深色模式，开发者可以通过设置分层参数数据实现：
场景案例
在应用省电模式后，继续在“我的“界面下设计为深色模式可以在显示模块获得更大的收益，一般而言应用深色模式可以通过以下步骤实现：
1.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151154.39511849460741528024410341907465:50001231000000:2800:2617C4BE92700FCCA4D93C52E832DC5DC503755657F2618F5188F9A802E71F62.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151154.44090878732606100343262582469475:50001231000000:2800:11FE7EB7820AF1815790830BA74135F8FBB74B4AE529230B96EAA941D0BCF20C.png)
功耗分析
同一界面下，分别对比测试关闭和开启深色模式情况下的总耗电量和CPU模块、GPU模块、Display模块的耗电量。最终，使用DevEco Studio的Profiler工具检测得到的数据如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151154.77172572251068009589775203188575:50001231000000:2800:E10DFCF786A10D4D8B2C48B4B5F335E560E943E64F19F547924E0FE14E408182.png)
根据测试数据分析，我们可以得出以下结论：
这一结果表明深色模式的使用对设备的整体能耗具有积极的影响，可以有效降低设备的能耗水平。深色模式通过减少需要点亮的像素点数量，从而有效降低了显示模块的功耗。
其他优化措施
优化措施介绍
在省电模式和深色模式下，根据不同的应用场景，通常还有以下常用的优化方式：
通过采取以上常用的优化方式，可以在省电模式和深色模式下进一步降低设备的能耗，延长电池的使用时间，提升用户体验。同时，结合测试数据的结果，可以更加明确地了解不同优化方式对设备能耗的影响，从而更好地指导实际的优化工作。
场景案例
在设计和开发应用时，需要考虑不同的使用场景需要不同的优化措施来降低功耗。例如，在运行视频应用程序时，可以采用降低亮度、调整刷新率和关闭不必要的背光等措施来降低功耗。而在运行音频应用程序时，则可以采用关闭不必要的传感器、减少CPU负载等措施来降低功耗。结合场景按需选择优化措施是非常重要的，可以帮助设备在不同的使用场景下提供最佳的性能和用户体验，并最大限度地降低功耗。
主动降低应用亮度总共分为以下几步：
在HMOS世界App的案例中，点赞、收藏的动画在省电和深色模式下会消耗更多的资源，可以主动关闭这些冗余动效，关闭的过程主要分以下几步：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151155.39013825644993776245627599255558:50001231000000:2800:9A3A6C0BC7BB36D1F773D5C5965D24ED6CEE5DB1741D94A69E044D4C6D12F466.gif)
在省电模式下停止点赞、收藏动画，具体代码实现如下：
功耗分析
同一界面下，在设置了省电模式和深色模式的前提下，测试主动减少应用亮度前后、去掉冗余动画前后的CPU模块、GPU模块、显示模块的耗电量和总耗电量。最终，使用DevEco Studio的Profiler工具检测得到的数据如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151155.51361404525476735736559536852174:50001231000000:2800:241774C190CA63B7B5777D5D0B52DBFEAB3A5581FC754DA3161DE68D53265EAA.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151155.70326159696076264540773186399628:50001231000000:2800:49E0107C46A92740DF8B635180FF9C0616DB809A603925EB67C3A2A10D787F22.png)
从测试数据可以看出：
总结
针对”HMOS世界”的功耗优化这一场景，分别使用省电模式和深色模式对其优化，再增加其他可选的推荐优化项，测试其在对应的GPU模块和显示模块的耗电量。测试表明，相比较正常模式，当开启省电模式和深色模式后，功耗下降明显，而针对应用需求，主动降低应用亮度、去掉冗余动画等方式后，功耗在对应模块持续下降。其各项对比指标数据如下所示：
| 性能指标  | 开启省电模式  | 开启深色模式  | 主动降低应用亮度  |
| --- | --- | --- | --- |
| 显示耗电量下降率  | 13.2%  | 21.9%  | 15.4%  |
| 总耗电量下降率  | 12.0%  | 12.5%  | 12.4%  |
性能指标
开启省电模式
开启深色模式
主动降低应用亮度
显示耗电量下降率
13.2%
21.9%
15.4%
总耗电量下降率
12.0%
12.5%
12.4%
|    | GPU耗电量下降率  | 总耗电量下降率  |
| --- | --- | --- |
| 去掉冗余动画  | 17.7%  | 3.3%  |
GPU耗电量下降率
总耗电量下降率
去掉冗余动画
17.7%
3.3%
通过以上数据，可以清楚地看到采用省电模式和深色模式可以有效地减少设备的能耗。
在应用开发中，开发者可以采用一些技术手段来降低应用的功耗为用户提供更加节能高效的应用体验，满足用户对于续航能力的需求。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-ltpo-description
爬取时间: 2025-05-01 08:53:07
来源: Huawei Developer
概述
LTPO技术简介
LTPO的全称是“ Low Temperature Polycrystalline Oxide”，翻译成中文是“低温多晶氧化物”。这是OLED屏背板的一种驱动技术。通过将OLED驱动电路中漏电相关的TFT换成IGZO TFT，降低显示功耗。LTPO屏给产品带来1~120Hz自适应刷新率的能力。使应用在需要高刷新率的场景可使用高刷新率提升流畅性，在视频、静止等场景又可使用低刷新率降低显示功耗，提升续航。习惯上，用“LTPO”指代自适应刷新率技术。
特性介绍
LTPO指自适应刷新率技术。通过按需自适应调整显示刷新率，实现最优的性能和功耗体验。
应用适配LTPO的好处：精细化场景帧率控制，降低场景负载，减少偶发卡顿，降低场景功耗。
场景策略建议
做到控件级帧率控制，降低系统因突发性负载增加带来的卡顿体验，同时在对高刷新率有要求的场景，主动适配确保流畅性体验。
不建议锁定最高帧率运行
不建议将ExpectedFrameRateRange中的expected、min、max都设置为120，否则会干扰系统的可变帧率机制运行，产生不必要的负载，进而影响到整机的性能和功耗。
主要原因有以下三点：
策略建议
| 类型  | 类型描述  | 帧率建议（案例）  |
| --- | --- | --- |
| 高帧率场景  | 基本全屏的非持续动效   | 应用启动，退出，窗口转场动效，拖动窗口移动动效：90~120Hz  |
| 中等帧率场景  | 变化区域大的持续型动效，非全屏的手势动效与转场动效  | 视频内弹幕，小说自动翻页动效：60Hz QQ首页左滑某一行消息动效:60Hz 微信右上角点击“+”号弹出应用内子窗口动效:60~120Hz 抖音内滑动切换视频，图库滑动切换图片动效：60Hz  |
| 低帧率场景  | 小区域动效，微动效  | 小视频右下角转盘动效：15~30Hz 页面刷新加载转圈动效:20~30Hz 滑动列表右侧拖动条消失动效:15~30Hz 复杂微动效，根据实际效果调整帧率  |
| 跟随源帧率场景  | 插画动效，固定源帧率动效  | 帧率跟随内容源，不建议长时间保持高帧率 购物应用首页图标帧动效 聊天表情包动效 导航主界面  |
类型
类型描述
帧率建议（案例）
高帧率场景
基本全屏的非持续动效
应用启动，退出，窗口转场动效，拖动窗口移动动效：90~120Hz
中等帧率场景
变化区域大的持续型动效，非全屏的手势动效与转场动效
视频内弹幕，小说自动翻页动效：60Hz
QQ首页左滑某一行消息动效:60Hz
微信右上角点击“+”号弹出应用内子窗口动效:60~120Hz
抖音内滑动切换视频，图库滑动切换图片动效：60Hz
低帧率场景
小区域动效，微动效
小视频右下角转盘动效：15~30Hz
页面刷新加载转圈动效:20~30Hz
滑动列表右侧拖动条消失动效:15~30Hz
复杂微动效，根据实际效果调整帧率
跟随源帧率场景
插画动效，固定源帧率动效
帧率跟随内容源，不建议长时间保持高帧率
购物应用首页图标帧动效
聊天表情包动效
导航主界面
功耗测试工具
显示手机实时刷新率
打开开发者模式中的"显示刷新频率"开关。具体操作：设置中搜索"开发者" ->  "显示刷新频率"。具体可参考《基于设备实时帧率检测》。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151155.41981727728245188321984749903227:50001231000000:2800:CEE7AAA1E082DF6ED888EB67E411515A446403E1A37BDF748C9A2EE12F9CEFC3.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151155.95419257061960946680843715847774:50001231000000:2800:16C6FF2E78E8188D87AC9166F3DE595E0E00704B67E5D1AF9DE4B89B463AEF73.png)
profiler工具测试手机功耗
1. 启动程序，并部署安装到真实手机上。
2. 打开工具profiler，并按图示选择需要监控的设备、app、进程。未启动app会出现设备、app等选项为空的情况，此时不能进行profiler性能分析。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151155.96742090600272518177070201557234:50001231000000:2800:B06ABC07171868AE8B5139D8ED73AEE15A6265DFC51545934D5DC7F0E151619D.png)
（图中的黄色折线展示了整机的电量消耗，该折线的斜率为正时代表设备在耗电，斜率为负时代表设备在充电。）
3. 点击会话区“Realtime Monitor”页签上的启动按钮来即时控制实时监控界面的录制状态。
4. 将鼠标悬浮于所关心的泳道数据上时，界面上会出现当前时间点的时间标线以及含有当前时间点上泳道详细数据的Tooltips。更进一步，当您将鼠标悬浮于时间轴之上时，实时监控页面内的所有泳道均会以Tooltips展示出该时刻的数据。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151155.28716283438459557477984422372103:50001231000000:2800:3B3522E9CA1D7B676C54C643779ADABB08756B2FE1C5026A47986A853CBE1C1D.png)
本文采用的测试方式是让应用跑30s，以3s为一个节点，取设备从6s运行到21s5个节点的平均功耗。因为此时设备已平稳运行，功耗也趋于平稳，不再跳动。
使用场景
场景说明
在具备LTPO屏幕的设备上，基于显示内容的可变帧率能力，可以达到性能体验和功耗间的平衡。HarmonyOS支持可变帧率能力，开发者通过使用可变帧率接口，进行相关业务开发，可以享受可变帧率特性带来的功耗收益。
可变帧率能力支持开发者自定义应用业务的帧率，其常见的使用场景：
基于以上使用场景，结合众多实际开发案例，本文选取两个有代表性的案例展开介绍。
开发者设置的期望帧率值不能代表最终实际效果，会受限于系统能力和屏幕刷新率。
基于LTPO实现循环动画
针对一些无限循环的动画效果，如转盘动画，需要尤为注意设置动画的可变帧率，如果长时间保持高帧率可能导致手机发热等现象发生。
效果展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151155.92190831254551404538175287328783:50001231000000:2800:110EDF2444DAC6AE26D9044E7B46915CC9F8C0355DDA87C92BC76EB852BC3A5A.png)
功耗对比
使用DisplaySync去实现转盘动画，通过主动设置可变帧率，可以获取功耗的差异。
功耗测试方法参考章节2。
打开手机屏幕刷新率设置，可以看到刷新率变化；根据Profile工具，可以看到功耗变化如下所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151155.72531302988236368271819440886539:50001231000000:2800:7CAB998C296D8920BA3F1A8E7021884AC7BFC97A2E1ADABA6FD5EBAA76A2852E.png)
从图中可以发现，当屏幕刷新率降低时，功耗会随之降低。
传入可变帧率（ExpectedFrameRateRange）时被屏幕感知，充分利用好屏幕的LTPO技术达到降低功耗的目的，屏幕的帧率没有时刻保持在最高帧率上刷新，所以功耗较低。
实现说明
首先需要导入模块
然后定义和构建DisplaySync对象
定义图片组件并添加旋转方法
通过DisplaySync实例设置帧率和注册订阅函数。
全部代码实现如下
上述代码中，给DisplaySync设置一个可变帧率ExpectedFrameRateRange 可以让系统参考调整屏幕刷新率，若要取消设置可变帧率，可注释如下代码：
不建议将ExpectedFrameRateRange中的expected、min、max都设置为120，否则会干扰系统的可变帧率机制运行，产生不必要的负载，进而影响到整机的性能和功耗。
如setExpectedFrameRateRange({ expected:120, min:120, max:120})。
基于LTPO实现滑动条
效果展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151156.99157993311444851320332006629684:50001231000000:2800:61459B6838E24926D6CDDF6A34E17E5149AC53193DFE0F92516BC4FD5FD702EE.png)
功耗对比
使用animateTo实现转盘动画，通过主动设置可变帧率，可以获取功耗的差异。
功耗测试方法参考章节2。
开启手机帧率设置，我们可以看到帧率变化；根据Profile工具，可以看到功耗变化如下所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151156.97037210011983480462045023173301:50001231000000:2800:A9433F7013F3AB4EC1B730187188186F4A40ECA2757A7667C64DD0375DDF532C.png)
从图中可以发现，当屏幕刷新率降低时，功耗会随之降低。
传入可变帧率（ExpectedFrameRateRange）时被屏幕感知，充分利用好屏幕的LTPO技术达到降低功耗的目的，屏幕的帧率没有时刻保持在最高帧率上刷新，所以功耗较低。
代码实现
在滑动条里添加onVisibleAreaChange事件，在其回调函数里使滑块的当前值加到100。
总结
综上所述，使用LTPO技术可以控制各个动效的刷新率，从而降低屏幕刷新率，进而控制功耗，为用户带来更加持久的续航时间和更高品质的使用体验。因此在开发业务时推荐使用可变帧率接口，可以享受可变帧率特性带来的功耗收益。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-utilize-hwc-efficiently
爬取时间: 2025-05-01 08:53:20
来源: Huawei Developer
概述
在应用开发中，开发者可以自由组合ArkUI定义控件、视频、图片、Web网页以及第三方渲染框架生成内容，以满足应用UI界面的需求。同时，HarmonyOS系统基于的芯片平台除了通用的CPU/GPU计算单元外，还提供了Hardware Composer（下文简称HWC）专用硬件辅助系统进行图形渲染送显，相对于通用计算单元，在图层叠加场景具有更高的处理效率和更低的能耗。作为专用硬件单元，HWC需要满足一定条件才能充分发挥其硬件能力，降低系统CPU/GPU开销，减少发热和卡顿现象的出现。
因此，在开发类似Web界面、视频播放等多图层叠加场景时，如果其中存在自渲染图层，可以通过以下两种方式调整视效设计，扩大HWC的生效范围：
开发者可以根据实际业务适当调整界面视效设计，使系统能够充分发挥HWC的能效优势，降低对应操作场景的功耗，提升操作流畅性。
高阶视效控件是指具有模糊等高阶视效的控件。其中高阶视效是一类视效的统称，该类视效在原理上需要对背景进行采样、取色等操作，如模糊算法需要对背景内容进行采样，反色需要先对背景区域内内容进行颜色的计算等。
实现原理
系统接收到应用的UI界面元素由两类组成，一类是直接使用ArkUI提供的现有接口定义的控件，如按钮、进度条、导航栏等，可以称为UI控件。另外一类是应用直接传递已经渲染好的内容，包括视频、图片、Web网页或调用自有或者三方渲染框架已经渲染好的内容（下文统一归类为应用自渲染内容）。
1.  该内容将由系统根据组件定义及布局进行绘制，用户应用程序不感知具体的绘制过程。
2.  这类内容在应用进程内进行解码或者调用GPU渲染，再作为整体传递给系统渲染服务进程。
对于以上两类界面元素，系统在进行处理时的策略有所不同，会结合界面视效的要求综合调用GPU或者HWC进行处理，以达到系统能效最优。
图形渲染系统工作流程
下图简要介绍了图形渲染系统当前从应用界面内容至最终屏幕显示的工作流程。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151156.45386964960902627879624750059022:50001231000000:2800:6F2E9D1CF4D7EFBAAA8B0FA30400B73FC434FA9BD84D7DDD6DB73B4766867269.png)
图形渲染送显策略
当前系统的整体渲染送显策略简要描述如下：
RS进程会将ArkUI控件统一绘制至UI图层，其UI内容来源于应用定义的ArkUI控件和桌面进程传递的内容（如状态栏、系统导航等）。再基于UI图层和应用自渲染内容的Z序关系，优先使用HWC的图层叠加能力进行后续的送显处理。
在该过程中，UI控件的视效与自渲染图层的Z序关系都将影响HWC的使用。如自渲染图层上方的UI控件使用了模糊等高阶视效，而模糊算法的采样需要实时读取背景自渲染图层的内容，在进行图层叠加时还需要进行额外处理。在这种情况下，无法使能HWC，RS只能采用GPU进行图层间的叠加。
如何高效使能HWC
这里结合HWC的特点以及当前系统的渲染送显策略给出如下两点建议，以提升HWC的生效范围，降低应用操作期间可能产生的发热及卡顿概率。
-  如果UI控件采用模糊等高阶视效，且与自渲染图层区域产生交叠，那么RS在进行该类UI控件绘制时，按照视效算法，需要读取自渲染图层的内容后才能正确的绘制出对应的UI控件。相对于无模糊等高阶视效情况下，会需要额外的内容读取动作，此时会直接使用GPU载入对应自渲染图层并进行渲染动作。 如上过程，相对于直接使用HWC叠加，会带来额外的CPU/GPU/DDR 开销，造成使用场景的功耗抬升及性能损失。因此建议开发者合理评估UI界面的视效需要，通过UI控件去除模糊等高阶视效或者移动控件位置等方式，避免出现非必要高阶视效控件与自渲染图层交叠的场景。 上述优化建议仅从功耗优化角度出发，需要调整界面的视效设计，开发者可根据需要自行选择。 注：典型高阶视效动作列表 视效类型 ArkUI接口 背景模糊 .blur()；.backdropBlur() 提亮 .backgroundBrightness() 灰阶 .grayscale() 阴影取色 .shadow() 压暗提亮 .lightUpEffect() 前景模糊 .foregroundEffect()
-  这里存在以下两种情况： 此时建议开发者评估自渲染图层设定透明度的必要性，如果全透明建议及时下树。或者评估UI控件位于自渲染图层下方的必要性，如一定需要，建议该控件同样使用自渲染形式实现。 对此建议评估是否需要多个自渲染图层交叠以及位于底部的自渲染图层圆角是否可以去除。 典型场景：
-  此时建议开发者评估自渲染图层设定透明度的必要性，如果全透明建议及时下树。或者评估UI控件位于自渲染图层下方的必要性，如一定需要，建议该控件同样使用自渲染形式实现。
-  对此建议评估是否需要多个自渲染图层交叠以及位于底部的自渲染图层圆角是否可以去除。
| 视效类型  | ArkUI接口  |
| --- | --- |
| 背景模糊  | .blur()；.backdropBlur()  |
| 提亮  | .backgroundBrightness()  |
| 灰阶  | .grayscale()  |
| 阴影取色  | .shadow()  |
| 压暗提亮  | .lightUpEffect()  |
| 前景模糊  | .foregroundEffect()  |
1.  此时建议开发者评估自渲染图层设定透明度的必要性，如果全透明建议及时下树。或者评估UI控件位于自渲染图层下方的必要性，如一定需要，建议该控件同样使用自渲染形式实现。
2.  对此建议评估是否需要多个自渲染图层交叠以及位于底部的自渲染图层圆角是否可以去除。
场景案例
场景一：在视频区域上方合理使用模糊控件
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151156.41172479177287640757901358290122:50001231000000:2800:204E0E0F0615A4AC2EBADB74BEA8EAE1985299D88A1F2EF630444587E9F0C976.png)
如上图，视频区域左上角的返回按钮控件带有模糊效果，需要进行视频图层的采样动作，无法使用HWC叠加能力。对此可以通过控件去除模糊效果或者移动控件至非视频相交区域来完成对HWC的使能。
此处采用去除控件的模糊效果的方式使能HWC，优化场景功耗。相应对比代码如下：
视频上方叠加带有模糊效果的Image组件
视频上方Image组件去除模糊效果
去除模糊后的效果图如下所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151156.16102408046802215776776615301773:50001231000000:2800:988FA371C8291B428F4CA1B6F58BAB7B3A80BA259B8CB49C6B3DCAF5C3ECE2B6.png)
功耗对比
同一界面下，测试视频区域上方控件去除模糊效果前后的CPU模块、GPU模块的功耗，以及设备总功耗。测试方式为视频播放30s，以3s为一个节点，取设备从6s运行到21s5个节点的平均功耗。最终，使用DevEco Studio的Profiler工具检测得到的数据如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151156.53354855626803047239179124378092:50001231000000:2800:2A6FEBE0B4677CFB96D92F5933514713F26DD1C87A699ADD555DF74E044CE303.png)
从测试数据可以看出：
测试数据表明，在视频播放场景下，去除视频区域上方控件的模糊效果使能HWC可以大幅度减少GPU模块和CPU模块的功耗，同时对降低设备总体功耗也都有显著效果。
场景二：在Web类界面上方合理使用模糊控件
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151156.61907798793257908524645040002564:50001231000000:2800:7ED9CB59D5B0E201C65E4F9A0AD21067AE63D90EACEB07666457C211A3E03132.png)
在该场景下，底部TabBar区域使用模糊，且背景区域使用Web类组件或者Native Xcomponent组件导入自渲染内容，同样导致UI图层与自渲染内容无法使用HWC叠加。对此开发者可以通过去除TabBar区域的模糊视效或者裁剪组件区域避免Web内容与模糊控件相交两种方式进行修改，以达到使用HWC降低功耗的目的。
此处通过去除控件的模糊效果使能HWC，优化场景功耗。相应对比代码如下：
Web组件上方TabBar控件模糊
Web组件上方TabBar控件去除模糊效果
去除模糊后的效果图如下所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151156.57790868225925720507440443674178:50001231000000:2800:28AA63D6E00A96031666E995915F0529038B36195F3333C9B9AE700A21BCA42B.png)
功耗对比
同一界面下，测试Web组件上方控件去除模糊效果前后的CPU模块、GPU模块的功耗，以及设备总功耗。测试方式为同样频率滑动界面30s，以3s为一个节点，取设备从6s运行到21s5个节点的平均功耗。最终，使用DevEco Studio的Profiler工具检测得到的数据如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151156.89890988719118581837387259564456:50001231000000:2800:3119B5B207F54EE80AACAB7BCE09719228BAEDFCC897C20BEA8CF762FA23F39A.png)
从测试数据可以看出：
测试数据表明，在Web场景下，去除Web上方控件的模糊效果使能HWC可以大幅度减少GPU模块的功耗，同时对降低CPU模块功耗和设备总体功耗也都有显著效果。
场景三：避免UI控件上方自渲染图层设置透明度
效果图
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151156.02595743139241220596076315373142:50001231000000:2800:D6DD7437B6ACD12C20D7253884D0EC65770218F15C157B4248FED5DA5706B890.png)
该场景UI控件上方的视频图层设置有一定透明度，可以一定程度上透视底部UI控件，此时需要使用GPU进行额外的透明度处理，无法使用HWC叠加。对此建议开发者评估视频图层设置透明度的必要性，是否可以调整视频图层为不透明。如果必须设置透明度，也可以通过调整UI控件位置至视频图层上方或者使用自绘制方式实现UI控件来使能HWC。
此处通过调整视频图层为不透明来使能HWC，达到优化功耗的目标。相应对比代码如下：
视频图层设置透明度
视频图层不透明
设置视频不透明后的效果图如下所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151156.01251514856761668246471289359083:50001231000000:2800:B069872542FBB9ED7C95D5551F2485598396A226630DA9CCF239177C3D54462D.png)
功耗对比
同一界面下，测试视频图层设置不透明前后的CPU模块、GPU模块的功耗，以及设备总功耗。测试方式为视频播放30s，以3s为一个节点，取设备从6s运行到21s5个节点的平均功耗。最终，使用DevEco Studio的Profiler工具检测得到的数据如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151156.33708956644327805506183702971230:50001231000000:2800:14896C156EC3E92B938051EF2E1E1D8FBBEE9E030619A546B2AC2B7D94BA14D1.png)
从测试数据可以看出：
测试数据表明，在视频位于UI控件上方进行播放时，视频设置不透明使能HWC可以大幅度减少GPU模块和CPU模块的功耗，对降低设备总体功耗也都有一定效果。
总结
本文基于HarmonyOS系统中所涉及的硬件特点以及基本原理，给出了如何更多使用HWC以减少应用使用期间发热及卡顿的方案，并通过常见的Web界面、视频播放等场景的示例给出具体的案例实施及效果。开发者可以应用本文中的优化建议，综合考虑视效、功耗及性能间的诉求来提升应用使用期间的综合体验。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-properly-use-foreground-resources
爬取时间: 2025-05-01 08:53:33
来源: Huawei Developer
应用前台使用系统资源不当，可能会造成设备耗电快、发热等现象。本文提供了前台资源使用的相关规则和建议，可以帮助开发者降低设备耗电速度、保障用户功耗热基础体验。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-music-playback-scenarios
爬取时间: 2025-05-01 08:53:47
来源: Huawei Developer
规则
开发步骤
音乐应用后台播放时，仅需设置资源的时长、播放状态（暂停、播放）、播放位置、倍速即可，播控中心会使用这些信息进行进度的展示，无需频繁更新进度条导致binder负载冗余。
调测验证
执行效果示意如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151157.18550895425569903489063274702720:50001231000000:2800:349F4EEC0428305A2DB421A6E478BB6AB5ADEEF2DB9A0AC89365E0F0B017BBD1.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-navigation-scenarios
爬取时间: 2025-05-01 08:54:00
来源: Huawei Developer
规则
开发步骤
调测验证
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151157.91342539221667663834060530974159:50001231000000:2800:243DA04DB8E6BED7850815517B7F24ED3F39A53A2DDAE0FFCA7F52E03443D9F0.png)
结果对比
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151157.83255734999813749410561638370671:50001231000000:2800:9D3ABA8B8DC53DDA6321CC1EE7CC3EBAA187255E5522DD053E51F68909858B71.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151157.62323337888681502894175140862336:50001231000000:2800:9E8B8D510DC1E8586DBBFDC52751F3A40A6D329329A50CFC989EC8AD950EABD0.png)
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151157.61727761939394239403157985681125:50001231000000:2800:881AFD671A08F577FC45EF67870A7EC9A9231BBF3A0C5D14DCE2EE0D97002EE5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151157.89205808180027897597631696856060:50001231000000:2800:AED1A1D98BD1B68914119B92E14BD2465682884539898137D15E2B2E86B2F4C6.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-static-scenarios
爬取时间: 2025-05-01 08:54:13
来源: Huawei Developer
规则
界面完全静止，无音频输出、资源下载的场景下，三方应用要停止频繁请求显示、sensor等等无关资源，不随着vsync信号每帧周期性运行（导致冗余动画等）、不持续请求sensor等相关资源，三方应用进程的CPU负载率应该低于10%（单核负载）。
开发步骤
静置场景下三方应用进程不随着vsync信号每帧周期性运行，通过下述“案例分析”说明。
静置场景下未使用资源及时释放，以sensor为例：
1.  注册监听，通过on()接口，实现对传感器的持续监听，传感器上报周期interval设置为200000000纳秒（最小采样周期为5000000纳秒，支持的最大采样周期是200000000纳秒）。
案例分析
-
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151157.25438030117936957365852529310137:50001231000000:2800:04A41E6B542CB2D42A73D55278F99C311D0728887D8495639C7EAD9D8E43CE0D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151157.16346841515270457832271865542669:50001231000000:2800:29741DD0C6BB671F693F1D76B775988A22CB5DBA7A7B5A1FE8183699F7E5B787.png)
调测验证
-
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151157.47797941313894800171451882856329:50001231000000:2800:A558DAC493B8429AA16189307E8FE36CB38FF01D524D0598070B27FECBA0962F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151157.41397428601051441144964989367268:50001231000000:2800:32BF1B6EF6D8EC678CD3B1D3E31E11A6C6088015A99A5F061D57DB83268A61C7.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-video-codec
爬取时间: 2025-05-01 08:54:26
来源: Huawei Developer
规则
开发步骤
调用OH_AVCodec相关接口实现使用视频硬件编解码器处理视频。
调测验证
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151157.97922588290389025073354048517963:50001231000000:2800:D45402CD32DF3B164594471269989D6F1EFBB2C6092495C385534A76A3E42628.png)
-  通过systrace确认硬解码相关进程av_codec_service的负载，如下图av_codec_service进程，业务频繁唤醒且有实际的函数在运行，说明视频处于硬解码状态。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151157.65636869385213206208801331126958:50001231000000:2800:96A2EC9125157A9075472C24E0792E0FFE9E6E398C8691DF282AB7D88BCDA77D.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-video-barrage
爬取时间: 2025-05-01 08:54:40
来源: Huawei Developer
规则
开发步骤
使用EGL/OpenGLES进行渲染，就是硬件加速，使用GPU绘制。OpenGLES的接口使用方式见Native XComponent的使用指导，以下是EGL/OpenGLES 使用范例。
调测验证
抓取视频弹幕播放的systrace，三方应用调用RenderService进程进行弹幕绘制（非三方自绘制弹幕）时，调用“H:RSDisplayRenderNodeDrawable Flush”函数表示执行基于GPU硬件加速的渲染方案。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151158.25030460931929793034101089716234:50001231000000:2800:BDBF998FDE68D66BBE0AFA88D4E100DFBBE71B96EC2A2FAB67917713C57FA1A2.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-video-rom
爬取时间: 2025-05-01 08:54:53
来源: Huawei Developer
建议
视频小视频在线播放，建议不要将片源全部下载到ROM里。下载到ROM的功耗相比只加载到DDR中，功耗增量在100mA以上。因此视频、小视频在线播放，不要将片源全部下载到ROM里。
开发步骤
推荐使用异步接口fileIo.write()写文件到ROM，函数的返回值number为实际写入的数据长度（单位字节）。统计返回值的累计值，这个累计值是应用一段时间内写到ROM里的文件总大小。因此，确保视频、小视频在线播放时，文件下载的速率<20MB/min。
```typescript
let filePath = pathDir + "/test.txt";
let file = fileIo.openSync(filePath, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
let str: string = "hello, world";
// 使用异步方式往ROM里写文件
fileIo.write(file.fd, str).then((writeLen: number) => {
console.info("write data to file succeed and size is:" + writeLen);
}).catch((err: BusinessError) => {
console.error("write data to file failed with error message: " + err.message + ", error code: " + err.code);
}).finally(() => {
fileIo.closeSync(file);
});
```
调测验证
通过查看storage_info节点的信息，如下所示host total write是整机下载文件的总大小（单位是100MB），建议文件下载的总速率<20MB/min。以视频播放10分钟为例，测试前后的host total write节点差值≤2，符合要求。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151158.62303933714841881819707879191240:50001231000000:2800:86A0FAC68EA5DF06BE5518EF760DE54D426B96E290459DE723F788404B987778.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-video-layer
爬取时间: 2025-05-01 08:55:06
来源: Huawei Developer
建议
开发步骤
应用使用XComponent组件时，有Surface和Texture两种模式。Surface模式会由一个XComponent组件创建一个独立的Surface图层。根据不同的播放场景，XComponent组件的使用数量也有所不同。在视频/小视频场景中，无弹幕全屏视频播放时，要求一个界面内的Surface模式的XComponent组件数量≤2；而在弹幕全屏视频播放时，由于弹幕功能需要额外Surface图层渲染弹幕内容，该限制放宽至一个界面内的Surface模式的XComponent组件数量≤3。
调测验证
图层抓取命令为hdc shell hidumper -s 10 -a allInfo。图层的信息如下，可通过查看LayerInfo中的Surface个数得出图层个数。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151158.21927435244594576321901647494558:50001231000000:2800:4DD7C2EEF8AFE1ADB2810D7151DAF29ADBB1F562681111A700AA6328ABE57A1F.png)
上图所示为一个没有弹幕的视频场景，共有4个图层，其中系统的图层2个，三方应用图层2个，符合三方应用图层个数要求。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-video-wifi
爬取时间: 2025-05-01 08:55:19
来源: Huawei Developer
建议
视频场景数据缓存下载方式：建议按聚合方式下载（如每20s下载一次，每次下载3~5s），避免小流量持续下载导致Wi-Fi功耗高。
开发步骤
调用系统的setHandoverCb接口，实现聚合方式缓存视频，具体的接口调用方法如下：
调测验证
相同大小的文件下载有按照聚合方式下载和小流量持续下载这2种方式。数据包和时间的关系如下：
1.
2.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151158.62594737113674645988005294720118:50001231000000:2800:4178DD44350E030BD859FD986103111065F8C9DE1DEEDF4905B97A6DE7B516C7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151158.77924106017870424805565462187939:50001231000000:2800:A6A0446C4518DF8F440B067135CB21455ED846AE56B1C30163D2DC03A79C36E9.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-network-resources
爬取时间: 2025-05-01 08:55:33
来源: Huawei Developer
建议
应用资源预缓存时，建议不要提前下载过多的资源，导致SOC功耗和Wi-Fi功耗劣化。以小视频场景播放为例，如果提前加载前后的视频片源个数过多会导致功耗高。
开发步骤
提前下载视频资源的接口有prefetch等接口，比如网页加载资源使用的示例如下：
小视频场景也有类似prefetch加载当前片源后续几个片源的接口，推荐小视频预加载的片源个数小于等于5个，避免功耗的浪费。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/low-power-consumption-suggestions
爬取时间: 2025-05-01 08:55:47
来源: Huawei Developer
建议
应用在调用动画、动效以及依赖Vsync机制进行刷新的组件时，需保证使用的组件，在页面进行隐藏、跳转或动画位于屏幕外部时，停止刷帧请求，规避由此带来的空跑现象。
空跑问题往往是由于开发者未合理地对组件的生命周期与启停控制进行恰当的管理，以动图组件为例，如果动图进入不可见状态但该组件本身缺乏回调机制或回调后未能成功控制其停止，那么该动图可能会伴随着用户在该软件全场景下的空跑，带来严重的功耗异常和发热问题。
自检手段
开发者可通过DevEco Studio中的Profiler搭配Arkui Insepector，来判断当前场景是否存在空刷问题，步骤如下：
1.
2.  如下图所示，使用DevEco Studio的Arkui Inspector功能，选取对应的设备和应用，并在左侧的Component Tree中搜索38，将会在主面板中显示该id为38的Canvas组件，表明当前帧被吊起是由于此处的Canvas以7Hz（130ms）的频率进行空刷。后续，开发者可以参考组件位置、代码实现方式、内部状态变量传递、Log等方式，进一步定位该动画空跑的问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151158.06430165025516986965439195492424:50001231000000:2800:2C1698DA1A4B8E0D4D1802802E8B67E1EB9EE87BB1EC12A8FE9DBC139964D776.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151158.90179667676762743914136708263471:50001231000000:2800:701D96071A07D91B7F1BDA6E3516E0A2163105F7EDE0FD7AA83D2B9D1EA7268D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151158.76907699040862871545082299076931:50001231000000:2800:C11CDD6F4FD7FB9957FD31FDD560590CC1167E62D652EECD80977E01B652B541.png)
开发参考
|    | 监听法：监听容器状态，传递关键变量  | 可见法：通过组件可见性计算，判断显示/隐藏时机  |
| --- | --- | --- |
| 原理简介  | 通过监听一些有明显特征的容器组件的一些相关事件，触发回调并修改状态变量或动画控制器，例如： Navigation容器下onHidden()/onShown()，tab的onChange()Refresh的onStateChange() 当触发这些回调时，通过修改状态变量的方式，控制容器内动图、动效组件的播放/停止。  | 组件的显示状态决定了它是否出现在屏幕上，是否需要进行刷新与绘制。可以通过绑定回调接口（如onVisibleAreaChange()或setOnVisibleAreaApproximateChange()），让其在显示/隐藏时回调，开发者可以在回调中实现对动图或动效组件的播放/停止控制。   |
| 开发优势  | 稳定可靠，能够对特定页面的动画动效根据具体的用户行为进行管控，同时接口回调不需要额外的计算负载，对性能十分友好。  | 该接口可以与组件一起封装使用，易于开发、维护。 组件结构正常深度情况下，算法负载不影响性能。  |
| 不适用场景  | 当场景内所有的动画、动效规格可能发生变化的情况下，例如动画框架与业务开发分离，同一页面下可能存在不同类型、不同数量的动画时，变量的传递变得难以定位，不推荐用该方法。  | 该接口依赖可见性算法，当组件并非被一个来自其父组件的组件遮挡时，会存在无法使能的场景： 被兄弟节点盖住不通知Stack堆叠不通知，z序被遮挡不通知 在此类情况下，当动画在可视区域上显示/隐藏时，回调不会触发。  |
监听法：监听容器状态，传递关键变量
可见法：通过组件可见性计算，判断显示/隐藏时机
原理简介
通过监听一些有明显特征的容器组件的一些相关事件，触发回调并修改状态变量或动画控制器，例如：
当触发这些回调时，通过修改状态变量的方式，控制容器内动图、动效组件的播放/停止。
组件的显示状态决定了它是否出现在屏幕上，是否需要进行刷新与绘制。可以通过绑定回调接口（如onVisibleAreaChange()或setOnVisibleAreaApproximateChange()），让其在显示/隐藏时回调，开发者可以在回调中实现对动图或动效组件的播放/停止控制。
开发优势
稳定可靠，能够对特定页面的动画动效根据具体的用户行为进行管控，同时接口回调不需要额外的计算负载，对性能十分友好。
该接口可以与组件一起封装使用，易于开发、维护。
组件结构正常深度情况下，算法负载不影响性能。
不适用场景
当场景内所有的动画、动效规格可能发生变化的情况下，例如动画框架与业务开发分离，同一页面下可能存在不同类型、不同数量的动画时，变量的传递变得难以定位，不推荐用该方法。
该接口依赖可见性算法，当组件并非被一个来自其父组件的组件遮挡时，会存在无法使能的场景：
在此类情况下，当动画在可视区域上显示/隐藏时，回调不会触发。
需额外留意的是，当前系统为了便利开发者，对一些常用的动图，内置了可见性接口防止其空跑，如lottie库版本在2.0.14及以上、apng库版本在1.1.2及以上。若开发者并未对此类三方动画库的播放控制进行封装、修改，可直接通过更新库来避免不可见时的空跑问题。若有对此类三方动画库的播放控制进行封装、修改，则建议按照本文提到的方法进行修改。下面展示监听法与可见法的经典示例：
方法1-监听法：下方展示了一个列表组件下拉刷新时，管理刷新动画的不可见现象的场景。有一个用Canvas实现的apng组件，置于Refresh组件中，默认处于隐藏状态。留意到Refresh组件有多种状态可以监听，故添加onStateChange()方法，监听RefreshStatus值。当Refresh组件处于收起状态时，对应RefreshStatus中的0和4，此时控制apngcontroller停止播放动画，而当RefreshStatus处于拉起、回弹等状态时，对应RefreshStatus的1、2和3，此时播放该动画。
```typescript
// VisibleComponent/entry/src/main/ets/pages/Index.ets
import { apng, ApngController } from '@ohos/apng';
import { hilog } from '@kit.PerformanceAnalysisKit';
@Entry
@Component
struct RefreshExample {
@State isRefreshing: boolean = false;
@State isRunning: boolean = false;
@State arr: string[] = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
controller: ApngController = new ApngController();
@Builder
customRefreshComponent() {
Stack() {
Row() {
Column() {
apng({
src: $r('app.media.stack'),
controller: this.controller
})
.margin({ top: 40 })
}
}
.alignItems(VerticalAlign.Center)
}
.align(Alignment.Center)
.clip(true)
.constraintSize({ minHeight: 32 })
.width('100%')
}
build() {
Column() {
Refresh({ refreshing: $$this.isRefreshing, builder: this.customRefreshComponent() }) {
Scroll() {
Column() {
ImageAnimatorTest()
ForEach(this.arr, (item: string) => {
ListItem() {
Text('' + item)
.height(80)
.fontSize(16)
.textAlign(TextAlign.Center)
.fontColor(0xF1F3F5)
}
}, (item: string) => item)
}
}
.scrollBar(BarState.Off)
}
.backgroundColor(0xF1F3F5)
.pullToRefresh(true)
.refreshOffset(64)
.expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
// Use onStateChange and apngcontroller to control play and stop
.onStateChange((refreshStatus: RefreshStatus) => {
if (refreshStatus >= 1 && refreshStatus < 4) {
this.controller.play();
} else {
this.controller.stop();
}
hilog.info(0x0000, 'testTag', 'Refresh onStatueChange state is ' + refreshStatus);
})
.onRefreshing(() => {
setTimeout(() => {
this.isRefreshing = false;
}, 2000)
hilog.info(0x0000, 'testTag', 'onRefreshing test')
})
}
}
}
```
方法2-可见法：下方展示了用一个ImageAnimator实现的动画组件，通过duration设置多个Pixelmap循环播放的案例，例如，当这个组件被放置在一个Scroll容器时，为了应对该组件可能会划出屏幕而导致的不可见空跑的问题，可以通过可见性接口的办法监听组件移出屏幕的事件，从而修改动画播放状态，以达到控制空跑的目的。下方给出了几种可供开发者参考的实现方式来接入可见性接口，接入的位置和方法有所不同，开发者选择一种即可：
```typescript
// VisibleComponent/entry/src/main/ets/pages/Index.ets
@Component
struct ImageAnimatorTest {
private uid: number = -1;
private index: number = 0;
@State running: boolean = false;
@State animState: AnimationStatus = AnimationStatus.Initial;
// Method 1: use aboutToAppear to register a setOnVisibleAreaApproximateChange
aboutToAppear(): void {
this.uid = this.getUniqueId();
hilog.info(0x0000, 'testTag', `getUniqueId in ImageAnimatorTest aboutAppear is ${this.uid}`);
let node = this.getUIContext().getFrameNodeByUniqueId(this.uid);
node?.commonEvent.setOnVisibleAreaApproximateChange(
{ ratios: [0], expectedUpdateInterval: 500 },
(isVisible, currentRatio) => {
hilog.info(0x0000, 'testTag',
`Method aboutToAppear: setOnVisibleAreaApproximateChange isVisible:${isVisible}, currentRatio:${currentRatio}`);
this.running = isVisible;
})
}
build() {
Column() {
ImageAnimator()
.images([
{ src: $r('app.media.background') },
{ src: $r('app.media.foreground') }
])
.id(`ImageAnimator${this.index}}`)
.width('100%')
.height('30%')
.duration(3000)
.fillMode(FillMode.None)
.iterations(-1)
.state(this.running ? AnimationStatus.Running :
AnimationStatus.Paused)// Method 2: Directly use onVisibleAreaChange
.onVisibleAreaChange([0.0, 1.0], (isVisible: boolean, currentRatio: number) => {
hilog.info(0x0000, 'testTag',
`Method Direct: onVisibleAreaChange isVisible:${isVisible}, currentRatio:${currentRatio}`);
if (isVisible && currentRatio >= 1.0) {
this.running = true;
}
if (!isVisible && currentRatio <= 0.0) {
this.running = false;
}
})// Method 3: use onAppear to register a setOnVisibleAreaApproximateChange
.onAppear(() => {
let node = this.getUIContext().getFrameNodeById(`ImageAnimator${this.index}`);
node?.commonEvent.setOnVisibleAreaApproximateChange(
{ ratios: [0], expectedUpdateInterval: 500 },
(isVisible, currentRatio) => {
this.running = isVisible;
hilog.info(0x0000, 'testTag',
`Method onAppear: setOnVisibleAreaApproximateChange isVisible:${isVisible}, currentRatio:${currentRatio}`);
}
)
})
}
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-low-power-consumption-of-background-tasks
爬取时间: 2025-05-01 08:56:00
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-use-of-background-tasks
爬取时间: 2025-05-01 08:56:13
来源: Huawei Developer
应用退至后台后，如果继续活动，可能会造成设备耗电快、用户界面卡顿等现象。为了降低设备耗电速度、保障用户使用流畅度，系统会对退至后台的应用进行管控，包括进程挂起和进程终止。为了保障后台音乐播放、日历提醒等功能的正常使用，系统提供了规范内受约束的后台任务，扩展应用在后台运行时间。
合理的选择和使用后台任务对于优化用户体验，减少性能消耗非常重要。以下表格对比总结了各类后台任务的概念、适用场景以及任务执行过程中的应用状态。
| 任务类型  | 概念  | 应用退至后台状态  | 适用场景  |
| --- | --- | --- | --- |
| 无后台  | 不执行任何任务，直接退到后台。  | 一小段时间后应用挂起（几秒内）。  | 通用。  |
| 短时任务  | 实时性要求高、耗时不长的任务。  | 在单次配额内，应用不会被挂起直到取消任务。单次配额超时不取消，应用进程会被终止。  | 小文件下载、缓存、信息发送等时效性高、需要临时占用资源执行的任务。  |
| 长时任务  | 长时间运行在后台、用户可感知的任务。  | 应用不会被挂起直到取消任务，任务结束不取消应用进程会被终止。  | 数据传输、音频播放、录音、定位导航、蓝牙、WLAN 相关、多设备互联、音视频通话、计算任务。  |
| 延迟任务  | 实时性要求不高、可延迟执行的任务，满足条件后放入执行队列，系统会根据内存、功耗等统一调度。  | 应用退到后台时挂起，满足任务设定条件时由系统统一调度拉起应用，创建 Extension 进程执行任务。单次回调最长运行 2 分钟，如果超时不取消，系统会终止对应的 Extension 进程。  | 软件更新、信息收集、数据处理等。  |
| 代理提醒  | 系统代理应用做出相应提醒。  | 应用挂起或进程终止，满足条件后系统会代理应用做相应的提醒。  | 闹钟、倒计时、日历。  |
任务类型
概念
应用退至后台状态
适用场景
无后台
不执行任何任务，直接退到后台。
一小段时间后应用挂起（几秒内）。
通用。
短时任务
实时性要求高、耗时不长的任务。
在单次配额内，应用不会被挂起直到取消任务。单次配额超时不取消，应用进程会被终止。
小文件下载、缓存、信息发送等时效性高、需要临时占用资源执行的任务。
长时任务
长时间运行在后台、用户可感知的任务。
应用不会被挂起直到取消任务，任务结束不取消应用进程会被终止。
数据传输、音频播放、录音、定位导航、蓝牙、WLAN 相关、多设备互联、音视频通话、计算任务。
延迟任务
实时性要求不高、可延迟执行的任务，满足条件后放入执行队列，系统会根据内存、功耗等统一调度。
应用退到后台时挂起，满足任务设定条件时由系统统一调度拉起应用，创建 Extension 进程执行任务。单次回调最长运行 2 分钟，如果超时不取消，系统会终止对应的 Extension 进程。
软件更新、信息收集、数据处理等。
代理提醒
系统代理应用做出相应提醒。
应用挂起或进程终止，满足条件后系统会代理应用做相应的提醒。
闹钟、倒计时、日历。
具体任务的使用场景、约束和开发步骤可以参考后台任务开发服务。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-back-task-implement
爬取时间: 2025-05-01 08:56:26
来源: Huawei Developer
概述
为有效降低设备耗电量、确保用户体验的流畅性，系统会对后台应用进行管控，包括进程挂起与进程终止。当应用处于音乐播放、地图导航等场景时，用户把应用退至后台、锁屏或切换应用等操作，应用将自动转入后台运行。为确保应用在后台期间功能仍能正常使用，系统提供了符合规范的后台任务机制。本篇文章介绍应用切后台各类常见的问题场景及对应解决方案，并通过分析应用短暂切换前后台和后台长时间运行两大应用场景的开发实践案例，指导开发者如何有效使用后台任务处理冻结场景，从而确保应用在前后台之间能够流畅切换。
应用后台规格建议
当前系统会对切换至后台的应用所使用的资源进行严格管控，具体措施包括进程挂起和进程终止。若此时没有进行后台处理，可能会导致应用程序的功能出现异常。具体的限制条件与建议可以查看官网指南和最佳实践文档。
实现原理
后台任务类型
标准系统支持规范内受约束的后台任务，包括短时任务、长时任务、延迟任务、代理提醒和能效资源。开发者可以根据如下介绍，选择合适的后台任务，以满足应用退至后台后继续运行的需求。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151158.85236411947974211969827278180422:50001231000000:2800:D24DC750588BB60B53DCFBC1B32C1FB3212B6E0F806DC4D6B162FCFF9906D812.png)
以下表格对比总结了各类后台任务的概念、适用场景以及任务执行过程中的应用状态。
| 适用场景  | 概念  | 常见问题  | 应用退至后台状态  | 任务类型  |
| --- | --- | --- | --- | --- |
| 不执行任何任务的后台场景。  | 不执行任何任务，直接退到后台。  | -  | 一小段时间后应用挂起（几秒内）。  | 无后台  |
| 小文件下载、缓存、信息发送等时效性高、需要临时占用资源执行的任务。  | 实时性要求高、耗时不长的任务。  | 应用短暂切换前后台，进程被挂起。  | 在单次配额内，应用不会被挂起直到取消任务。单次配额超时不取消，应用进程会被终止。  | 短时任务  |
| 数据传输、音频播放、录音、定位导航、蓝牙、WLAN 相关、多设备互联、音视频通话、计算任务。  | 长时间运行在后台、用户可感知的任务。  | 应用后台长时间运行中断。  | 应用不会被挂起直到取消任务，任务结束不取消应用进程会被终止。  | 长时任务  |
| 软件更新、信息收集、数据处理等。  | 实时性要求不高、可延迟执行的任务，满足条件后放入执行队列，系统会根据内存、功耗等统一调度。  | -  | 应用退到后台时挂起，满足任务设定条件时由系统统一调度拉起应用，创建 Extension 进程执行任务。单次回调最长运行 2 分钟，如果超时不取消，系统会终止对应的 Extension 进程。  | 延迟任务  |
| 闹钟、倒计时、日历。  | 系统代理应用做出相应提醒。  | -  | 应用挂起或进程终止，满足条件后系统会代理应用做相应的提醒。  | 代理提醒  |
适用场景
概念
常见问题
应用退至后台状态
任务类型
不执行任何任务的后台场景。
不执行任何任务，直接退到后台。
-
一小段时间后应用挂起（几秒内）。
无后台
小文件下载、缓存、信息发送等时效性高、需要临时占用资源执行的任务。
实时性要求高、耗时不长的任务。
应用短暂切换前后台，进程被挂起。
在单次配额内，应用不会被挂起直到取消任务。单次配额超时不取消，应用进程会被终止。
短时任务
数据传输、音频播放、录音、定位导航、蓝牙、WLAN 相关、多设备互联、音视频通话、计算任务。
长时间运行在后台、用户可感知的任务。
应用后台长时间运行中断。
应用不会被挂起直到取消任务，任务结束不取消应用进程会被终止。
长时任务
软件更新、信息收集、数据处理等。
实时性要求不高、可延迟执行的任务，满足条件后放入执行队列，系统会根据内存、功耗等统一调度。
-
应用退到后台时挂起，满足任务设定条件时由系统统一调度拉起应用，创建 Extension 进程执行任务。单次回调最长运行 2 分钟，如果超时不取消，系统会终止对应的 Extension 进程。
延迟任务
闹钟、倒计时、日历。
系统代理应用做出相应提醒。
-
应用挂起或进程终止，满足条件后系统会代理应用做相应的提醒。
代理提醒
场景示例
应用短暂切换前后台，避免进程挂起
应用在进行小文件下载、缓存、信息发送等业务场景时，若将应用短暂退至后台导致应用进程被挂起，切回前台有可能造成应用异常的状态。此时可以申请短时任务作为此问题的解决方案。下面的示例使用ApplicationContext订阅应用前后台切换的回调，来实现应用切后台时申请短时任务，解决短暂切换前后台导致的应用发送消息异常。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151158.24402648719340380007179069164620:50001231000000:2800:0F9BED99532503D028949E969882A1D310252FD062C7BBAE962A08E60C92F288.png)
```typescript
// BackTaskImplement/entry/src/main/ets/utils/SuspendTaskUtils.ets
/**
* Obtains the remaining time of a specified short-term task.
* @param id  ID of the short-term task to be queried.
*/
async getRemainingDelayTime(id: number): Promise<number> {
let delayTime: number = -1;
await backgroundTaskManager.getRemainingDelayTime(id).then((res: number) => {
delayTime = res;
hilog.info(0x0000, TAG, 'Operation getRemainingDelayTime succeeded. Data: ' + JSON.stringify(res));
}).catch((err: BusinessError) => {
hilog.error(0x0000, TAG, 'Operation getRemainingDelayTime failed. Cause: ' + err.code);
});
return delayTime;
}
```
```typescript
// BackTaskImplement/entry/src/main/ets/utils/SuspendTaskUtils.ets
/**
* Cancel a short-term task
* @param id ID of a short-term task to be canceled.
*/
cancelSuspendDelay(id: number): boolean {
try {
backgroundTaskManager.cancelSuspendDelay(id);
hilog.info(0x0000, TAG, 'cancelSuspendDelay succeeded.');
} catch (err) {
hilog.error(0x0000, TAG, `cancelSuspendDelay failed. Cause: ${JSON.stringify(err)}`);
return false;
}
return true;
}
```
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151158.43356604486887505586323846460447:50001231000000:2800:C565FAC2285C34557E81F24FDF6107B3A5A02FD1EFCE05995D89F0BFABA5DF1A.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151159.80912829507845369459467703739049:50001231000000:2800:C1EE47AEF3BE9D69E4ACE98980D2180DC3BB93BEDEFA95D4CCE293A600BD7824.png)
应用后台长时间运行不中断
当应用涉及数据传输、音频播放、录音操作、定位导航、蓝牙及WLAN相关应用、多设备互联、音视频通话、复杂计算任务等多种场景时，需要应用在后台长时间运行。为了确保应用在此情况下正常使用，可申请后台长时任务来实现此需求。以下示例使用长时任务来管理应用的定位服务，实现应用长时间在后台状态时，应用能获取设备持续位置定位信息的功能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151159.38878423407533676824754512754212:50001231000000:2800:16A4A93DB10A49ECAD1C2E1023496A1B9045FFF79AEBFFCD408541F17156B0BF.png)
实现效果
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151159.79184517568766167154640583463567:50001231000000:2800:F1D593F152F5D7C017AC08D395E34019F20520E3D87E27461EEF74A3641F2801.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151159.77873786096439715684338443087705:50001231000000:2800:48F3A21F95AB25D424C0E8A18F6E33A15231E98921FFB173C5D1CC1C91990AFD.png)
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-use-of-background-hardware-resources
爬取时间: 2025-05-01 08:56:39
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-controlling-background-process-cpu
爬取时间: 2025-05-01 08:56:52
来源: Huawei Developer
CPU使用率是指进程在CPU上的运行时间与总时间的百分比，即CPU使用率 = 运行时间/总时间。单核CPU使用率最大为100%，多核CPU的使用率为核数*100%（比如8核CPU使用率最大为800%）。
进程的任务会被系统调度到多个CPU核上，进程在所有核上运行的时间总和除以总时间即为该进程的CPU使用率。例如1秒内进程在所有核上运行的总时间为1.1秒，则该进程的CPU使用率为110%。
约束
长时任务后台进程CPU使用率约束：后台进程持续10分钟单核CPU使用率不得高于80%。
短时任务后台进程CPU使用率约束：后台进程任务期间单核CPU使用率不得高于80%。
调测验证
1.
2.
3.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151159.23551569294488805042680030021247:50001231000000:2800:5308001F8C41C5AE295EC7D66E88F9896BEF3EAB78661DE7B9C32F07F17925CE.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151159.22829693915126389880934224134393:50001231000000:2800:54469475E40078E807356A91EC6F01DD55673141536BF6DBDE52A7350B1387FC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151159.34237585682298200672129188333146:50001231000000:2800:9627905AE928291A49D30ABA69BDF788C28FA8AF405CB963486517806953EFA3.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-reasonable-bluetooth-use
爬取时间: 2025-05-01 08:57:06
来源: Huawei Developer
无长时任务的应用退到后台不允许进行蓝牙扫描。
约束
应用如果不主动停止发起的扫描，系统会在应用退到后台时强制停止扫描，回到前台后恢复扫描。
示例
有关蓝牙相关接口的使用，详情可以参考广播与扫描开发指导。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-reasonable-network-use
爬取时间: 2025-05-01 08:57:19
来源: Huawei Developer
无长时任务的应用退到后台主动断开socket连接，包含TCP和UDP连接。
约束
应用如果不主动断开socket连接，系统会强制断开TCP连接，应用在前台后需要主动重新创建连接。
示例
HTTP数据请求
有关HTTP数据请求相关接口的使用，详情可以参考HTTP数据请求。
Socket连接
有关网络Socket相关接口的使用，详情可以参考Socket连接。
WebSocket连接
```typescript
import { UIAbility } from '@kit.AbilityKit';
import { webSocket } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
export default class EntryAbility extends UIAbility {
//按业务所需创建websocket
ws = webSocket.createWebSocket();
onForeground(): void {
//在前台时通过websocket发送数据
this.ws.on('open', (err: BusinessError, value: Object) => {
console.log("onopen,status:" + JSON.stringify(value));
//当收到on('open')事件时，可以通过send()方法与服务器进行通信
this.ws.send("Hello,server!", (err: BusinessError, value: boolean) => {
if (!err) {
console.log("Messagesentsuccessfully");
} else {
console.log("Failedtosendthemessage.Err:" + JSON.stringify(err));
}
});
});
}
onBackground(): void {
//退后台关闭websocket
this.ws.close((err: BusinessError) => {});
}
}
```
有关网络WebSocket相关接口的使用，详情可以参考WebSocket连接。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-reasonable-audio-use
爬取时间: 2025-05-01 08:57:32
来源: Huawei Developer
无长时任务的应用退到后台禁止使用麦克风或扬声器。
约束
NA
示例
播音场景（audioRenderer）
播音场景（AVPlayer）
播音场景（OpenSL ES）
播音场景（OHAudio）
播音场景（SoundPool）
有关音频播放开发相关接口的使用，详情可以参考音频播放。
录音场景
有关音频录制开发相关接口的使用，详情可以参考音频录制。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-reasonable-gps-use
爬取时间: 2025-05-01 08:57:45
来源: Huawei Developer
无长时任务的应用退后台禁止使用定位服务。
约束
未申请长时任务的应用退到后台后，应用未停止定位请求，系统会强制停止应用的定位请求。
示例

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-reasonable-sensor-use
爬取时间: 2025-05-01 08:57:58
来源: Huawei Developer
应用退后台禁止使用传感器资源。
约束
应用退后台禁止使用传感器资源。
示例
有关传感器开发相关接口的使用，详情可以参考传感器开发指导。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-use-of-background-software-resources
爬取时间: 2025-05-01 08:58:12
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-reasonable-request-use
爬取时间: 2025-05-01 08:58:25
来源: Huawei Developer
应用需要上传下载时，应使用系统上传下载服务，不要申请长时任务。
约束
NA
示例
上传
下载
有关上传下载相关接口的使用，详情可以参考应用文件上传下载。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-reasonable-audio-playback-use
爬取时间: 2025-05-01 08:58:38
来源: Huawei Developer
申请音频播放长时任务的应用退到后台后，禁止不进行操作或者写入静音数据等恶意行为。
约束
系统检测到应用后台以上行为时，会对应用进行挂起或者清理。
示例
```typescript
import { fileIo as fs } from '@kit.CoreFileKit';
let context = getContext(this);
async function read() {
const bufferSize: number = await audioRenderer.getBufferSize();
let path = context.filesDir; //文件所在路径
const filePath = path + '/voice_call_data.wav'; //禁止该文件为无声播放的文件
let file: fs.File = fs.openSync(filePath, fs.OpenMode.READ_ONLY); //打开文件
let buf = new ArrayBuffer(bufferSize);
let readsize: number = await fs.read(file.fd, buf); //读取文件内容
let writeSize: number = await audioRenderer.write(buf); //播放文件内容
}
```
有关AudioRenderer开发相关接口的使用，详情可以参考使用AudioRenderer开发音频播放功能。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-reasonable-position-navigation-use
爬取时间: 2025-05-01 08:58:52
来源: Huawei Developer
在使用定位导航服务时，申请长时任务的应用应设置正确的应用场景。
约束
NA
示例
新闻类应用可以使用被动定位：
方式1：
方式2：
有关定位服务开发相关接口的使用，详情可以参考Location Kit开发指南。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-reasonable-system-use
爬取时间: 2025-05-01 08:59:05
来源: Huawei Developer
无长时任务的应用退后台后，应将对应的资源释放，不要直接或者间接持阻止系统休眠的锁。
约束
接口runningLock.create的type参数BACKGROUND类型已经废弃，不建议使用，如果确实需要使用，退到后台需要主动释放锁。
示例
应用直接持锁
有关RunningLock开发相关接口的使用，详情可以参考RunningLock锁。
系统帮助应用持锁
使用音频资源时，系统会帮助应用持锁，如果不释放音频资源，会导致系统持锁不释放，因此应用在后台要主动释放音频资源。
可参考合理使用音频资源。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-privacy-security
爬取时间: 2025-05-01 08:59:18
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-app-privacy-protection
爬取时间: 2025-05-01 08:59:31
来源: Huawei Developer
概述
随着移动终端及其相关业务（如移动支付、终端云等）的普及，用户隐私保护的重要性愈发突出。隐私保护是尊重个人权利、增加用户信任、确保个人信息安全的重要措施，也是法律法规的要求。个人信息的泄露和滥用可能导致不良后果，如个人诈骗、身份盗用、恶意广告等。
隐私是用户的基本权利，HarmonyOS非常重视用户的隐私。通过隐私保护措施，可以降低个人信息遭到滥用的风险，保护用户的财产和利益。实施良好的隐私保护措施不仅有助于建立良好的用户关系，还有助于保护用户和企业的利益。
为了更好的进行应用隐私保护，开发者首先需要了解以下基本信息：
隐私保护的原则
应用开发者在产品设计阶段就需要考虑用户隐私的保护，提高应用的安全性。HarmonyOS应用开发需要遵从隐私保护规则，在应用上架应用市场时，应用市场会根据规则进行校验，如不满足条件则无法上架。我们应遵循一套以控制力、透明度和数据最小化为核心的隐私保护的设计原则：
1.  应用采集个人数据时，应清晰、明确地告知用户，并确保告知用户的个人信息将被如何使用。
2.  应用个人数据收集应与数据处理目的相关，且是适当、必要的。开发者应尽可能对个人数据进行匿名或化名，降低对数据主体的风险。仅可收集和处理与特定目的相关且必需的个人数据，不能进行与特定目的不相关的进一步处理。
3.  对个人数据处理必须要征得用户的同意，用户对其个人数据要有充分的控制权。
4.  从技术上保证数据处理活动的安全性，包括个人数据的加密存储、安全传输等安全机制，系统应默认开启或采取安全保护措施。
5.  应用开发的数据优先在本地进行处理，对于本地无法处理的数据上传云服务时要满足最小化的原则，不能默认选择上传云服务。
6.  如果应用是针对未成年人设计的，或者应用通过收集的用户年龄数据识别出用户是未成年人，开发者应该结合目标市场国家的相关法律，专门分析未成年人个人数据保护的问题。收集未成年人数据前需要征得监护人的同意。
隐私保护常用方法
下面我们列举了应用隐私保护的一些常用方法。
1.  应用采集个人数据时，应清晰、明确地告知用户，并确保告知用户的个人信息将被如何使用。例如在应用启动的时候，可以使用隐私声明弹窗来说明敏感数据的使用和收集，获得用户同意后才能获取用户数据。
2.  应用本身不是强位置关联应用（如导航、运动健康等）优先推荐使用模糊定位。
3.  过多的存储访问权限可能会导致用户隐私数据的泄露，应该减少使用存储权限，仅请求访问应用程序所需的数据，可以用Picker来减少对用户存储数据的访问权限。
4.  申请敏感权限的时候要满足权限最小化的要求，只申请获取必需的信息或资源所需要的权限，减少权限滥用和敏感数据泄露问题。
5.  从技术上保证数据处理活动的安全性，包括个人数据的加密存储、安全传输等安全机制，应默认开启或采取安全保护措施。 存储敏感数据应该进行加密处理，具体可以参考《应用数据安全》。
隐私保护最佳实践
下面我们再来介绍一些隐私保护的最佳实践，开发者可以参考这些实践来解决应用的隐私保护问题。
使用隐私声明获取用户同意
当用户安装或使用某个应用程序时，应用程序可能会请求访问用户的敏感权限，例如相机、麦克风、通讯录、位置等。通过弹出隐私声明弹窗，应用程序需要事先向用户说明授权的目的和使用方式，以便用户能够全面了解自己的个人数据将如何被应用程序使用。
隐私声明弹窗的作用有几个方面：
总而言之，隐私声明弹窗在HarmonyOS中的目的是保护用户隐私权益并增强用户对个人数据的控制。它提供了透明度和选择权，使用户能够全面了解应用程序的权限要求，并自主决定是否授权。
例如在“HMOS世界”中使用了隐私声明的弹窗，具体实现可以参考代码SafePage.ets。应用首次启动后，会弹出该弹窗，当应用获得用户授权同意后，应用才能开始正常使用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151159.52277812048628185998621719470936:50001231000000:2800:3FB07ADAA80B8EC0DB0D4828D1C7B51CE3F776CCE22C1FD8D24414F7CFE94AA1.png)
减少应用的位置信息访问权限
位置信息是用户的敏感信息之一，过多的位置信息暴露可能会对用户产生一些负面影响。因此，限制应用的位置信息访问权限是保护个人隐私的一个重要方面。
只有当你的应用程序对位置信息的访问是至关重要的，才应该申请位置权限，否则应避免请求该权限，以保护用户的隐私和数据安全；当您需要申请位置权限时，应提供详细的说明和合理的解释，让用户清楚地了解为什么应用需要访问他们的位置信息。
您可以根据场景需要使用模糊定位来减少应用的位置信息访问权限。
使用模糊定位获取位置信息
对于大多数与位置相关的场景，仅请求粗略位置信息的访问权限即可满足要求。例如，天气应用可以基于用户所处的城市或地区提供准确的天气预报，而无需知道用户的具体经纬度，这里我们可以使用模糊位置。HarmonyOS在API9以后，提供模糊位置信息的能力，会为应用提供精确到5公里内的用户位置估算值，这种精度对应用的许多功能而言应已足够。
| target API level  | 申请位置权限  | 申请结果  | 位置的精确度  |
| --- | --- | --- | --- |
| 小于9  | ohos.permission.LOCATION  | 成功  | 获取到精准位置，精准度在米级别。  |
| 大于等于9  | ohos.permission.LOCATION  | 失败  | 无法获取位置。  |
| 大于等于9  | ohos.permission.APPROXIMATELY_LOCATION  | 成功  | 获取到模糊位置，精确度为5公里。  |
| 大于等于9  | 同时申请ohos.permission.APPROXIMATELY_LOCATION和ohos.permission.LOCATION  | 成功  | 获取到精准位置，精准度在米级别。  |
target API level
申请位置权限
申请结果
位置的精确度
小于9
ohos.permission.LOCATION
成功
获取到精准位置，精准度在米级别。
大于等于9
ohos.permission.LOCATION
失败
无法获取位置。
大于等于9
ohos.permission.APPROXIMATELY_LOCATION
成功
获取到模糊位置，精确度为5公里。
大于等于9
同时申请ohos.permission.APPROXIMATELY_LOCATION和ohos.permission.LOCATION
成功
获取到精准位置，精准度在米级别。
在API9以后，当应用同时申请ohos.permission.APPROXIMATELY_LOCATION和ohos.permission.LOCATION权限时，可以获取到用户精准位置，精准度在米级别；应用仅申请 ohos.permission.APPROXIMATELY_LOCATION：权限弹框仅显示模糊位置权限，用户如授权，则授权APPROXIMATELY_LOCATION模糊权限，应用获取模糊位置。这两种情况下的权限申请弹框如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151159.16785677405425517453485650147402:50001231000000:2800:5E39B373F301DED929BAEE0F9D3DC7C987B688334385D223A38F10C8F5B33044.png)
接下来介绍如何实现模糊位置申请：
权限的申请具体可以参考：向用户申请授权。
减少使用存储权限
一般应用获取“存储”权限后，就能读取到手机内部存储上所有的文件，包含所有的照片，这就产生了隐私风险：它就可以在用户毫无感知的情况下，分析用户的文件和图片，将隐私“偷走“。
但是，用户通常不希望授予应用对其所有照片和视频的访问权限，因此，HarmonyOS在API9以后引入了Picker选择器，在保证用户正常的数据访问述求的同时，最小化减少应用的数据泄露。避免全量数据的授权，降低授权的颗粒度，例如用户在发送图片时，只想让应用访问到用户想要发送的。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151200.95459337908795446211482890971335:50001231000000:2800:C072EDA2E84F9A98EAFEFADEDEDF1EB6126E1E52BC50F1922A79402BC0469985.png)
示例代码如下：
动态申请敏感权限
敏感权限涉及访问个人数据（如：照片、通讯录、日历、本机号码、短信等）和操作敏感能力（如：相机、麦克风等）的权限，所以对于敏感权限的申请需要特别注意。
例如商品扫码的功能，我们需要首先在module.json5配置文件中声明相机权限，在reason字段中说明相机权限的使用用途。
然后在扫码组件的点击事件中添加相机权限的动态申请。
```typescript
let atManager = abilityAccessCtrl.createAtManager();
atManager.requestPermissionsFromUser(getContext(this), ['ohos.permission.CAMERA'])
.then((data) => {
let grantStatus: Array<number> = data.authResults;
if (grantStatus.length > 0 && grantStatus[0] === 0) {
// The user is authorized to continue to access the target operation
Logger.info('request permissions granted');
// ...
} else {
// The user rejects the authorization
Logger.info('request permissions denied');
// ...
}
})
```
总结与回顾
本文主要介绍了隐私保护的重要性、列举了隐私保护的一些常见做法，并详细介绍了隐私保护的几个最佳实践：
请注意，这些只是一些常见的HarmonyOS隐私最佳实践，具体实施策略可能因应用的特定需求和法律法规要求而有所变化。你应该根据你的应用类型和用户定位，结合适用的隐私法规进行更全面和具体的隐私保护措施。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-app-data-security
爬取时间: 2025-05-01 08:59:45
来源: Huawei Developer
概述
应用的安全性是一个应用能否成功的关键。
HarmonyOS提供了系统安全、DevEco Studio/工具安全以及应用安全生态等三个层面的安全能力。
下面我们讨论应用安全生态层面的敏感数据存储和用户隐私保护的实践。
风险等级划分
HarmonyOS安全能力是以分级安全为架构思想的基础安全底座，面向业务场景构建HarmonyOS安全的应用生态。其中的分级分为两个维度：一是设备的安全等级划分，二是数据的安全等级划分。
设备等级划分
根据设备安全能力，比如是否有TEE、是否有安全存储芯片等，将设备安全等级分为SL1、SL2、SL3、SL4、SL5五个等级。例如，智能穿戴通常为低安全的SL1设备，手机、平板通常为高安全的设备。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151200.83383328394948306977686930800444:50001231000000:2800:6EDB5104ABBA40AEE038DEB64C6987D5008FD2AAD137A3931ED627B258F397DE.png)
设备从SL1到SL5分级，在完整性保护、加密及数据保护、权限及访问控制、可信执行环境和漏洞防利用这几个维度对应的安全能力要求逐渐提高。
数据等级划分
敏感数据分类可帮助应用开发者根据数据的敏感性、价值以及数据泄露时的潜在影响来识别和分类数据。开发者需要了解不同类型的数据及其使用方式，并对数据进行分类，针对分类制定适当的安全措施和控制措施来保护数据并确保遵守相关法规和标准。下表举例说明了个人数据的分类：
| 个人数据分类  | 数据分级  | 举例  |
| --- | --- | --- |
| 个人/敏感数据  | 关键资产数据  | 严重  | 口令、认证TOKEN、密保问题答案等  |
| 个人种族数据  | 种族血统  |
| 权威社会识别标识  | 高  | 身份证号码、军官证、社会/保险保障号码（社会号码）、驾照、护照号码、签证授权编号  |
| 负向名誉数据  | 犯罪记录（刑事、民事犯罪和诉讼记录），入狱记录、纪律处分  |
| 健康数据  | 健康数据（身高、体重、体脂、血压、血糖、心率等）、医疗记录、性生活  |
| 家居控制数据  | 家居控制、HICar反向控制、手机投屏后反向控制等  |
| 年龄生辰数据  | 中  | 年龄，出生日期  |
| 虚拟网络身份标识  | 华为帐号、宽带帐号、其他网络帐号（电话号码、邮箱）  |
| 一般社会识别标识  | 姓名  |
| 个人多媒体数据  | 照片、视频、录音、文字、日历日程、备忘录文本等  |
| 一般注册信息  | 低  | 昵称、头像、性别、国籍、出生地、教育程度、专业背景等  |
| 正向名誉数据  | 专业成就  |
| 非个人数据  | 匿名化数据  | 公开  | 匿名化处理后的个人数据  |
| 非个人数据  | 系统、设备信息中公开发布的数据，如：TCB模块的版本信息、完整性度量值、访问控制策略数据的完整性度量值、策略数据本身等  |
个人数据分类
数据分级
举例
个人/敏感数据
关键资产数据
严重
口令、认证TOKEN、密保问题答案等
个人种族数据
种族血统
权威社会识别标识
高
身份证号码、军官证、社会/保险保障号码（社会号码）、驾照、护照号码、签证授权编号
负向名誉数据
犯罪记录（刑事、民事犯罪和诉讼记录），入狱记录、纪律处分
健康数据
健康数据（身高、体重、体脂、血压、血糖、心率等）、医疗记录、性生活
家居控制数据
家居控制、HICar反向控制、手机投屏后反向控制等
年龄生辰数据
中
年龄，出生日期
虚拟网络身份标识
华为帐号、宽带帐号、其他网络帐号（电话号码、邮箱）
一般社会识别标识
姓名
个人多媒体数据
照片、视频、录音、文字、日历日程、备忘录文本等
一般注册信息
低
昵称、头像、性别、国籍、出生地、教育程度、专业背景等
正向名誉数据
专业成就
非个人数据
匿名化数据
公开
匿名化处理后的个人数据
非个人数据
系统、设备信息中公开发布的数据，如：TCB模块的版本信息、完整性度量值、访问控制策略数据的完整性度量值、策略数据本身等
除了基于内容对数据分类，开发者还需遵守相关的法律法规，如通用数据保护条例（GDPR）和个人信息保护法等，以保护用户的隐私权和数据安全。下图是基于法律法规的数据分类图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151200.82975991809553720290099709158415:50001231000000:2800:56574B237346DC8FB50F9D23EC43F5A4AAC34D2DE1DD9DB11C33F16B217570B2.png)
按照数据分类分级规范要求，可将数据分为S1、S2、S3、S4四个安全等级。
| 风险等级  | 风险标准  | 定义  | 样例  |
| --- | --- | --- | --- |
| 严重  | S4  | 业界法律法规定义的特殊数据类型，涉及个人的最私密领域的信息或一旦泄露、篡改、破坏、销毁可能会给个人或组织造成重大的不利影响的数据。  | 政治观点、宗教和哲学信仰、工会成员资格、基因数据、生物信息、健康和性生活状况，性取向等或设备认证鉴权、个人信用卡等财物信息等。  |
| 高  | S3  | 数据的泄露、篡改、破坏、销毁可能会给个人或组织导致严峻的不利影响  | 个人实时精确定位信息、运动轨迹等。  |
| 中  | S2  | 数据的泄露、篡改、破坏、销毁可能会给个人或组织导致严重的不利影响  | 个人的详细通信地址、姓名昵称等。  |
| 低  | S1  | 数据的泄露、篡改、破坏、销毁可能会给个人或组织导致有限的不利影响  | 性别、国籍、用户申请记录等。  |
风险等级
风险标准
定义
样例
严重
S4
业界法律法规定义的特殊数据类型，涉及个人的最私密领域的信息或一旦泄露、篡改、破坏、销毁可能会给个人或组织造成重大的不利影响的数据。
政治观点、宗教和哲学信仰、工会成员资格、基因数据、生物信息、健康和性生活状况，性取向等或设备认证鉴权、个人信用卡等财物信息等。
高
S3
数据的泄露、篡改、破坏、销毁可能会给个人或组织导致严峻的不利影响
个人实时精确定位信息、运动轨迹等。
中
S2
数据的泄露、篡改、破坏、销毁可能会给个人或组织导致严重的不利影响
个人的详细通信地址、姓名昵称等。
低
S1
数据的泄露、篡改、破坏、销毁可能会给个人或组织导致有限的不利影响
性别、国籍、用户申请记录等。
数据安全标签和设备安全等级越高，加密措施和访问控制措施越严格，数据安全性越高。
数据跨设备同步时，数据管理基于数据安全标签和设备安全等级进行访问控制。规则为，在本设备的数据安全标签不高于对端设备的设备安全等级时，数据才能从本设备同步到对端设备，否则不能同步。具体访问控制矩阵如下：
| 设备安全级别  | 可同步的数据安全标签  |
| --- | --- |
| SL1  | S1  |
| SL2  | S1~S2  |
| SL3  | S1~S3  |
| SL4  | S1~S4  |
| SL5  | S1~S4  |
设备安全级别
可同步的数据安全标签
SL1
S1
SL2
S1~S2
SL3
S1~S3
SL4
S1~S4
SL5
S1~S4
例如，手表通常为低安全的SL1设备。若创建数据安全标签为S1的数据库，则此数据库数据可以在这些设备间同步；若创建的数据库标签为S2~S4，则不能在这些设备间同步。
分级数据加密
分级数据保护
不同的文件路径具备不同的属性和特征。分级数据使用应用沙箱作为保护机制，避免数据受到恶意路径穿越访问。在应用文件目录中，根据不同的文件加密类型，区分了不同的目录。
-  应用如无特殊需要，应将数据存放在el2加密目录下，以尽可能保证数据安全。但是对于某些场景，一些应用文件需要在用户解锁前就可被访问，例如时钟、闹铃、壁纸等，此时应用需要将这些文件存放到设备级加密区（el1）。切换应用文件加密类型目录的方法请参见获取和修改加密分区。
应用文件目录的详细介绍请参考应用文件目录。
分级数据文件路径使用应用通用文件路径，获取路径代码如下：
如果需要获取el1的路径，则需要修改AreaMode，代码如下：
应用如无特殊需要，应将数据存放在el2加密目录下。
系统的文件级加密提供了4种加密类型实现文件保护，应用可以根据自己的需求，把文件保存到相应的数据目录。下表是各个分级加密区所对应的策略：
| 分级加密  | 策略  |
| --- | --- |
| el4  | 用户锁定设备后不久（一般为 10 秒钟），解密的数据保护类密钥会被从内存丢弃，此类的所有数据都无法访问，除非用户再次输入密码或使用指纹或面容解锁设备。  |
| el3  | 用户锁定设备后，如果文件已经被打开，则文件始终可以被继续访问，一旦文件关闭（锁屏），文件将不能被再次访问，除非用户再次输入密码或使用指纹或面容解锁设备  |
| el2  | 用户开机后首次解锁设备后，即可对文件进行访问。这是未分配给数据保护类的所有第三方应用数据的默认数据保护类  |
| el1  | 设备在直接启动模式下和用户解锁设备后均可对文件进行访问  |
分级加密
策略
el4
用户锁定设备后不久（一般为 10 秒钟），解密的数据保护类密钥会被从内存丢弃，此类的所有数据都无法访问，除非用户再次输入密码或使用指纹或面容解锁设备。
el3
用户锁定设备后，如果文件已经被打开，则文件始终可以被继续访问，一旦文件关闭（锁屏），文件将不能被再次访问，除非用户再次输入密码或使用指纹或面容解锁设备
el2
用户开机后首次解锁设备后，即可对文件进行访问。这是未分配给数据保护类的所有第三方应用数据的默认数据保护类
el1
设备在直接启动模式下和用户解锁设备后均可对文件进行访问
数据加密算法
通用密钥库系统（OpenHarmony Universal KeyStore，简称HUKS），向业务提供了平台级的密钥管理能力，包括密钥的生成、导入、销毁、证明、协商、派生、加密/解密、签名/验签及访问控制等功能。HUKS是系统的底座安全能力，业务无需自己实现复杂的密码学算法、密钥访问控制模型，即可安全、便捷地使用HUKS提供的密钥全生命周期管理能力，进而保证业务敏感数据的安全性。
使用数据加密算法实现数据加密请参考通用加密库。
数据安全案例
健康数据是日常生活中常见的敏感数据，并且在HarmonyOS设备中广泛存在，如手机，手表等。下面介绍体检报表的存储和保护的案例。
场景设计
根据数据分类规则，体检数据被归类为高风险级别的数据。因此，在程序设计过程中，除了采用分级数据加密的保护措施外，还需要进行二次加密以加强数据的安全性。具体而言，可以先对数据进行一次加密，然后再使用分级数据加密的方法对加密后的数据进行处理。这样做的目的是为了提高数据的保密性和完整性，有效地防止潜在的数据泄露和非法访问。通过这样多层次的加密措施，体检数据将更加安全可靠地存储和传输。
程序的场景主要由三个页面构成，分别为体检列表页、数据录入页和数据详情页，页面如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151200.79300599028822127990201605115413:50001231000000:2800:563A16858D9938279E08A5F04AD6C2A922D431137812AB27B379ABAC7655E85A.png)
场景开发
在实际开发中，数据的加密与解密经常是同时存在的，本场景中也是一样，由两个子场景组成，数据录入和数据详情。下面分别介绍这两个子场景的具体实现方式：
代码实现
参考分级数据保护中代码获取到数据路径后按正常的文件读写即可，以下是文件读写的代码：
```typescript
function writeFile(filePath: string, data: string) {
let file = fileIo.openSync(filePath, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
let writeLen = fileIo.writeSync(file.fd, data);
hilog.info(0x0000, 'AppDataSecurity', 'The length of str is: ' + writeLen);
fileIo.closeSync(file);
}
function readFile(filePath: string): object {
let file = fileIo.openSync(filePath, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
let arrayBuffer = new ArrayBuffer(1024);
class Option {
public offset: number = 0;
public length: number = 0;
}
let option = new Option();
option.length = arrayBuffer.byteLength;
let readLen = fileIo.readSync(file.fd, arrayBuffer, option);
let buf = buffer.from(arrayBuffer, 0, readLen);
hilog.info(0x0000, 'AppDataSecurity', `The length of of file: ${readLen}`);
fileIo.closeSync(file);
return [readLen, buf.toString()]
}
```
在使用huks之前要先配置加密算法的规格,本案例中选择的加解密算法规格为密钥长度为128的AES算法。在使用加解密算法计算前要先生成算法key，以下是算法配置和生成算法key代码：
在生成算法key的配置函数中需要指出算法类型HUKS_ALG_AES，算法key的大小以及密钥用途：
加密函数配置的算法规格需要跟生成算法key的配置保持一致。
HUKS_TAG_PADDING填充模式有三种不同填充模式。
HUKS_TAG_BLOCK_MODE有7种分组模式，对于CBC、CTR、OFB、CFB模式，仅使用HUKS_TAG_IV（密钥初始化的向量）加解密参数；对于GCM、CCM需要设置HUKS_TAG_NONCE（密钥加解密的字段）、HUKS_TAG_ASSOCIATED_DATA（附加身份验证数据的Tag ）。并且需要配置HUKS_TAG_IV密钥初始化向量选项。
解密函数配置的算法规格需要跟加密算法的配置保持一致，不同点是需要设置密钥用途为解密。
完成上述配置后，调用生成算法key函数。
生成算法key后即可进行加解密，在加解密中采用同样的步骤，先获取相应的配置，然后调用initSession和finishSession实现加解密操作。
在体检报表中有敏感数据，因此需要在对数据进行二次加密再进行分级加密，解密得过程顺序与加密相反，先读取分级加密的数据，再进行解密。在涉及的敏感的数据密级不同的时候，可以对不同的字符按密级分别封装序列化，避免在数据流动的时候可能把高密级的数据流动到低密级的设备中，造成数据泄露。
这里为了方便日志打印输出，对加密后的数据进行base64转码，在应用开发中此步骤可以省略。
总结与回顾
随着信息技术的不断发展，数据的价值和重要性日益凸显，因此保护数据安全已成为应用开发中的重要课题。数据安全保护需要综合考虑分析评估和设计开发两个阶段的工作：
本文中，针对体检报表中的数据将其进行安全等级划分后，根据定义的等级采取了对应的加密。
在实际应用开发中，开发者要重视数据安全工作，不断完善数据安全保护措施，为用户的数据安全和隐私保护提供更加可靠的保障。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-harmony-application-security
爬取时间: 2025-05-01 08:59:59
来源: Huawei Developer
通用组件安全
建议不涉及对外交互业务的应用组件的exported属性设置为false
只在应用程序内部使用的应用组件必须设置为不可见，以防受到其他应用程序的调用。
不对外交互的应用组件应该明确设置该应用组件的exported属性值为false（若未设置exported属性默认为false，建议显式设置防止遗漏和错误配置）。否则，可能会对外暴露内部接口，若被恶意应用利用，则可能会造成应用组件的信息泄露、功能异常、应用拒绝服务等问题。
当应用组件的exported属性设置为false时，使用DevEco Studio在启动调试或运行应用/服务时，或通过命令行拉起会出现安装HAP错误，提示“error: failed to start ability. error: ability visible false deny request”错误信息，出现该信息是由于系统安全权限不允许拉起exported属性设置为false的应用/服务，因此建议开发者在调试阶段exported属性设置为true，在正式上架发布的时候再设置exported属性为false。
错误示例：
PrivacyAbility是一个不期望对外交互的组件，但是设置exported属性为true，导致任何应用都可以访问该组件。
正确示例：
对外交互的应用组件应设置合理的访问权限
应用程序的应用组件不只是在应用程序内部使用，很多情况下需要与外部进行交互。以下情况表明应用组件是对外交互的：
程序内应用组件一旦允许对外交互，数据存在跨信任边界进行交互，若被恶意应用程序利用，可能会导致Ability信息泄露、功能异常、应用拒绝服务等问题；因此，应用程序对外交互的应用组件使用permissions属性来设置访问权限。
常见敏感功能、对外提供的Ability利用风险，建议涉及这些情况的组件设置权限进行保护：
1）未经用户操作确认就可执行关键操作，例如：发送短信、拨打电话、拍照、录音、录屏、截屏、定位等
2）导致个人数据、敏感数据泄露的关键操作，例如：读取短信、读取联系人、读取设备标识符等
3）导致权限提升，例如：可以进行原本system权限才能进行的操作
例外情况：必须对外提供且无利用风险的应用组件，可以不设置权限。
错误示例：
可以看出，任意外部应用都可以访问此ContactDataAbility，恶意应用程序可能利用该组件获取联系人数据。
正确示例：
建议隐式启动应用组件时避免携带个人数据
隐式want是通过action条件匹配的方式来筛选组件，凡是满足条件的应用组件都有被启动的可能。如果携带个人数据，则恶意应用有可能劫持携带的个人数据。应用程序如果要携带个人数据，需要显式指定目标应用组件（bundle名、ability名）或者将个人数据匿名化。示例中的context的获取方式请参见获取UIAbility的上下文信息。
错误示例:
通过示例代码中的action："ability.want.test"可以隐式启动组件，如果恶意应用也声明了该action，隐式调用时会出现一个列表让用户选择，如果用户进入了恶意应用，则恶意应用可以获取传递的敏感信息。
正确示例:
这里显式指定了需要拉起的应用组件的bundleName和abilityName，只会拉起指定的目标组件。
避免涉及口令输入的应用界面可以被截屏或录屏
口令输入界面主要涉及账号密码输入框及输入法弹出框，在用户输入口令时，应避免截屏或录屏操作。否则，一旦恶意软件骗取用户信任获得授权，窃取到用户操作的账号和密码，即可在其他设备中登录，造成用户隐私泄露。
实施指导：
在需要保护的Page页面调用setWindowPrivacyMode禁止截屏/录屏。
注意：此接口需要申请ohos.permission.PRIVACY_WINDOW权限。
正确示例:
在口令输入、转账支付页面中设置隐私属性，防止截屏/录屏：
```typescript
import { router, window } from '@kit.ArkUI';
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
onPageShow(): void {
window.getLastWindow(getContext(this)).then((windowStage: window.Window) => {
windowStage.setWindowPrivacyMode(true);
});
}
onPageHide(): void {
window.getLastWindow(getContext(this)).then((windowStage: window.Window) => {
windowStage.setWindowPrivacyMode(false);
});
}
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
Button('click to start Succ Page')
.onClick(async () => {
router.pushUrl({ url: 'pages/loginSuccPage' })
})
}
.width('100%')
}
.height('100%')
}
}
```
公共事件安全
避免使用携带个人数据未设置权限的动态公共事件
不同应用程序间可以使用公共事件进行进程间通信，如果公共事件发送权限设置不当，且携带个人数据，任意应用就可以读取该个人数据，造成用户数据泄露。
对于携带个人数据的公共事件，需要设置公共事件发送权限或者将个人数据加密。
错误示例:
发送了一个带个人数据（示例中假设是联系人数据）的公共事件，但是没有设置接收方接受此公共事件所需要的权限。
通过subscriberPermissions字段设置了接收公共事件的权限，这样，发布者要求订阅者必须具有“ohos.permission.READ_CONTACTS”权限，才能接收该携带联系人数据的公共事件。
建议对涉及敏感功能的公共事件进行访问权限控制
每个应用都支持订阅自定义的公共事件，并在接收到公共事件后执行一定的功能。应用在订阅公共事件后，通过publisherPermission设置订阅公共事件接收的权限。如果订阅的是自定义的公共事件且未设置权限，任意应用可以发送同名的自定义的公共事件，从而可能导致接收公共事件的应用拒绝服务甚至敏感功能泄露。
对于涉及敏感数据/操作的公共事件：订阅方需要设置权限且权限等级足够高。
错误示例:
常见敏感功能、对外提供的公共事件利用风险，建议涉及这些情况的公共事件设置权限进行保护：
1）未经用户操作确认就可执行关键操作，例如：发送短信、拨打电话、拍照、录音、录屏 、截屏、定位等
2）导致个人数据、敏感数据泄露的关键操作，例如：读取短信、读取联系人、读取设备标识符等
3）导致权限提升，例如：可以进行原本system权限才能进行的操作
例外情况：必须对外提供且无利用风险的应用公共事件，可以不设置权限。
WebView安全
避免加载不安全的URL或页面
Web组件或WebController均可以加载URL或页面。如果加载的URL或页面可被攻击者控制，则可加载恶意JS代码，使得恶意代码可以调用ArkTS开放的敏感JS接口，获取用户个人数据，或者对应用进行攻击等。
因此，需要在加载URL之前，通过Web组件的onLoadIntercept方法拦截到要加载的URL，准确获取URL各个字段值，并校验获取的值是否在业务预置的白名单内。
正确示例：
```typescript
import { uri } from '@kit.ArkTS';
import { webview } from '@kit.ArkWeb';
// 校验函数
function checkUrl(str: string): boolean {
let tmpUri = new uri.URI(str);
let res = tmpUri.normalize(); // 注意，需要先对tmpUri进行normalize，否则会绕过安全校验
console.info("res.scheme:" + res.scheme) // 协议
console.info("res.host:" + res.host) // 域名
console.info("res.port:" + res.port) // 端口
console.info("res.path:" + res.path) // 路径
console.info("res.ssp:" + res.ssp)
// 获取到scheme、host、port、path等参数值后，根据业务实际进行安全校验
// 此处省略部分，根据业务需要进行校验
if ("校验成功") {
return true;
}
return false
}
@Entry
@Component
struct WebComponent {
controller: webview.WebviewController = new webview.WebviewController();
build() {
Column() {
Button("loadUrl")
.onClick(() => {
this.controller.loadUrl('www.huawei.com')
})
.margin({ top: 50 })
Web({ src: 'www.huawei.com', controller: this.controller })
.onLoadIntercept((event) => {
console.info('onLoadIntercept:' + event.data.toString())
let tempUrl = event.data.toString()
return checkUrl(tempUrl) // 返回true表示阻止此次加载，否则允许此次加载
})
}
}
}
```
例外：如果应用本身是提供URL加载能力的，譬如浏览器等，可以例外。但是要注意，如果应用也提供了敏感的JS接口，要注意防范可能的被恶意调用的风险。
避免加载不可信的JavaScript脚本
WebController提供了runJavaScript和runJavaScriptExt函数用于异步执行JavaScript脚本，并通过回调方式返回脚本执行的结果。
```typescript
import { webview } from '@kit.ArkWeb';
import { BusinessError } from '@kit.BasicServicesKit';
@Entry
@Component
struct WebComponent {
controller: webview.WebviewController = new webview.WebviewController();
build() {
Column() {
Web({ src: $rawfile('index.html'), controller: this.controller })
.javaScriptAccess(true)
.onPageEnd(e => {
this.controller.runJavaScript('test()')
.then((result) => {
console.log('result: ' + result);
})
.catch((error: BusinessError) => {
console.error(`ErrorCode: ${error.code},  Message: ${error.message}`);
})
if (e) {
console.info('url: ', e.url);
}
})
}
}
}
```
加载的index.html如下：
如果加载的脚本内容不可信，则可加载恶意JavaScript代码，造成XSS。如果Web组件注册了敏感JavaScript接口，还会导致JavaScript接口被恶意调用，影响应用安全性。
因此，若待加载的JavaScript脚本外部可控，则需要在加载前进行白名单校验。
```typescript
import { webview } from '@kit.ArkWeb';
import { BusinessError } from '@kit.BasicServicesKit';
@Entry
@Component
struct WebComponent {
controller: webview.WebviewController = new webview.WebviewController();
build() {
Column() {
Web({ src: $rawfile('index.html'), controller: this.controller })
.javaScriptAccess(true)
.onPageEnd(e => {
let whiteMethods = ["test()", "test1()"]
let jsMethod: string = "alert(`xss`)" // 外部可控字段
// 白名单校验
if (whiteMethods.indexOf(jsMethod) === -1) {
console.error("input method not in whiteList")
return
}
this.controller.runJavaScript(jsMethod)
.then((result) => {
console.log('result: ' + result);
})
.catch((error: BusinessError) => {
console.error(`ErrorCode: ${error.code},  Message: ${error.message}`);
})
if (e) {
console.info('url: ', e.url);
}
})
}
}
}
```
错误示例：
```typescript
import { webview } from '@kit.ArkWeb';
import { BusinessError } from '@kit.BasicServicesKit';
@Entry
@Component
struct WebComponent {
controller: webview.WebviewController = new webview.WebviewController();
build() {
Column() {
Web({ src: $rawfile('index.html'), controller: this.controller })
.javaScriptAccess(true)
.onPageEnd(e => {
let jsMethod: string = "alert(`xss`)" // 外部可控字段
this.controller.runJavaScript(jsMethod)
.then((result) => {
console.log('result: ' + result);
})
.catch((error: BusinessError) => {
console.error(`ErrorCode: ${error.code},  Message: ${error.message}`);
})
if (e) {
console.info('url: ', e.url);
}
})
}
}
}
```
避免将mixedMode属性配置成All
mixedMode设置是否允许加载超文本传输协议（HTTP）和超文本传输安全协议（HTTPS）混合内容，默认不允许加载HTTP和HTTPS混合内容。支持三种模式，其中All是允许混合内容加载，存在中间人攻击的风险，默认不允许配置成All。
错误示例：
应该去掉此配置项，或者选择MixedMode.None模式。
例外：对于提供特定业务的应用可以例外，譬如浏览器。
避免在SSL校验出错时继续加载页面
onSslErrorEventReceive回调函数用于通知用户加载资源时发生SSL错误。
当Web组件通过SSL协议进行网络请求时，底层Web组件校验服务端返回的证书或者协议等错误时，默认情况下要cancel请求，否则存在中间人攻击风险。
```typescript
import { webview } from '@kit.ArkWeb';
@Entry
@Component
struct WebComponent {
controller: webview.WebviewController = new webview.WebviewController()
build() {
Column() {
Web({ src: 'www.example.com', controller: this.controller })
.onSslErrorEventReceive((event) => {
console.info('ssl check failed,error is : ' + event.error.toString())
event.handler.handleCancel();
})
}
}
}
```
错误示例：
```typescript
import { webview } from '@kit.ArkWeb';
@Entry
@Component
struct WebComponent {
controller: webview.WebviewController = new webview.WebviewController()
build() {
Column() {
Web({ src: 'www.example.com', controller: this.controller })
.onSslErrorEventReceive((event) => {
event.handler.handleConfirm();
})
}
}
}
```
如果在SSL校验出错时，直接调用handleConfirm函数，则页面会忽略SSL错误继续加载，会导致中间人攻击等风险。
例外：对于浏览器等用于加载URL的应用可以例外，但是也需要在页面显式告知用户待加载页面存在安全风险。
避免在用户同意前返回位置信息
geolocationAccess开关用于配置是否开启地理位置权限，默认开启。onGeolocationShow回调函数用于通知用户收到地理位置信息获取请求。H5页面请求获取地理位置信息时，Web组件通过上述两个API进行配置。
无使用场景时，需要显式禁用geolocationAccess。存在使用场景时，需要在onGeolocationShow回调内先弹框提示用户，并经过用户确认和同意才可以返回位置信息，否则存在隐私泄露风险。
```typescript
import { webview } from '@kit.ArkWeb';
@Entry
@Component
struct WebComponent {
controller: webview.WebviewController = new webview.WebviewController()
build() {
Column() {
Web({ src: 'www.example.com', controller: this.controller })
.geolocationAccess(true)
.onGeolocationShow((event) => {
if (event === undefined) {
return
}
AlertDialog.show({
title: 'title',
message: 'text',
confirm: {
value: 'onConfirm',
action: () => {
event.geolocation.invoke(event.origin, true, true);
}
},
cancel: () => {
event.geolocation.invoke(event.origin, false, true);
}
})
})
}
}
}
```
错误示例：
```typescript
import { webview } from '@kit.ArkWeb';
@Entry
@Component
struct WebComponent {
controller: webview.WebviewController = new webview.WebviewController()
build() {
Column() {
Web({ src: 'www.example.com', controller: this.controller })
.geolocationAccess(true)
.onGeolocationShow((event) => {
if (event === undefined) {
return
}
event.geolocation.invoke(event.origin, true, true);
})
}
}
}
```
在有位置权限的使用场景时，不能直接返回位置信息。需要明示给用户且用户同意后，方可返回。
避免注册返回含有全局认证凭据的JavaScriptProxy
在HarmonyOS中，可以使用Web组件加载H5等页面。同时Web组件可以通过JavaScriptProxy方法或者通过WebController的registerJavaScriptProxy方法向H5提供JS接口，供H5访问。
如果提供的JS接口返回了敏感信息或有敏感操作，被恶意调用，则存在安全风险。尤其是提供的JS接口返回了用于认证用户身份的全局认证凭据ServiceToken（下述简称ST）或者AccessToken（下述简称AT），由于是全局认证凭据，攻击者拿到此全局ST或AT，可以冒充用户恶意调用此应用在云端的所有接口，使攻击影响扩大化。因此需禁止Web组件提供获取全局认证凭据ST或AT的JavaScriptProxy。
错误示例：
H5攻击界面：
如上所示，提供了获取全局认证凭据的ST接口供H5调用，如果H5存在漏洞，攻击者拿到此ST即可仿冒用户访问用户的云服务上的个人数据，进行恶意操作等。
为了降低用户的全局认证凭据ST或AT丢失带来的安全风险，推荐两种修改方法如下：
第一种方法：在加载URL页面前，校验当前页面的URL是否在白名单内，仅允许白名单内的URL调用。要同时校验协议、域名、PATH等，白名单范围控制的越小越安全。
校验方法可使用如下API格式化相关URL，跟预置的数据进行比较。
1. 使用URI库进行URL格式化，准确获取URL各个字段值，并校验获取的值是否在业务预置的白名单内
```typescript
// Index.ets
import { uri } from '@kit.ArkTS';
import { webview } from '@kit.ArkWeb';
// 校验函数
function checkUrl(surl: string): boolean {
let tmpUri: uri.URI = new uri.URI(surl);
let res = tmpUri.normalize(); // 注意，需要先对tmpUri进行normalize，否则会绕过安全校验
console.info("res.scheme:" + res.scheme) // 协议
console.info("res.host:" + res.host) // 域名
console.info("res.port:" + res.port) // 端口
console.info("res.path:" + res.path) // 路径
console.info("res.ssp:" + res.ssp)
// 获取到scheme、host、port、path等参数值后，根据业务实际进行安全校验
// 此处省略部分，根据业务需要进行校验
if ("校验成功") {
return true;
}
return false
}
@Entry
@Component
struct Index {
controller: webview.WebviewController = new webview.WebviewController()
build() {
Column() {
Row() {
Button('registerJavaScriptProxy').onClick(() => {
this.controller.registerJavaScriptProxy(
{
getServiceToken: () => {
return "DLFJSLDFJALGJLDFJSDDFISLDF323LSDJFLS212DLSFJOEV";
}
},
"objName",
["getServiceToken"],
);
this.controller.refresh()
})
}
Web({ src: $rawfile('H5CallETS.html'), controller: this.controller })
.javaScriptProxy({
object: {
getServiceToken: () => {
return "DLFJSLDFJALGJLDFJSDDFISLDF323LSDJFLS212DLSFJOEV";
}
},
name: "objName",
methodList: ["getServiceToken"],
controller: this.controller
})
.onLoadIntercept((event) => {
console.info('onLoadIntercept:' + event.data.toString())
let tempUrl = event.data.toString()
return checkUrl(tempUrl); // 返回true表示阻止此次加载，否则允许此次加载
})
}
}
}
```
```typescript
// Index.ets
import { url } from '@kit.ArkTS';
import { webview } from '@kit.ArkWeb';
// 校验函数
function checkUrl(surl: string): boolean {
let tmpUrl = url.URL.parseURL(surl);
console.info("res.scheme:" + tmpUrl.protocol) // 协议
console.info("res.host:" + tmpUrl.host) // 域名
console.info("res.port:" + tmpUrl.port) // 端口
console.info("res.path:" + tmpUrl.pathname) // 资源路径
console.info("res.ssp:" + tmpUrl.hostname) // 域名
// 获取到scheme、host、port、path等参数值后，根据业务实际进行安全校验
// 此处省略部分，根据业务需要进行校验
if ("校验成功") {
return true;
}
return false
}
@Entry
@Component
struct Index {
controller: webview.WebviewController = new webview.WebviewController()
build() {
Column() {
Row() {
Button('registerJavaScriptProxy').onClick(() => {
this.controller.registerJavaScriptProxy(
{
getServiceToken: () => {
return "DLFJSLDFJALGJLDFJSDDFISLDF323LSDJFLS212DLSFJOEV";
}
},
"objName",
["getServiceToken"]
);
this.controller.refresh()
})
}
Web({ src: $rawfile('H5CallETS.html'), controller: this.controller })
.javaScriptAccess(true)
.javaScriptProxy({
object: {
getServiceToken: () => {
return "DLFJSLDFJALGJLDFJSDDFISLDF323LSDJFLS212DLSFJOEV";
}
},
name: "objName",
methodList: ["getServiceToken"],
controller: this.controller
})
.onLoadIntercept((event) => {
console.info('wzz:onLoadIntercept:' + event.data.toString())
let tempUrl = event.data.toString()
return checkUrl(tempUrl); // 返回true表示阻止此次加载，否则允许此次加载
})
}
}
}
```
第二种方法：针对H5页面申请一个新的H5Token，并严格限定此H5Token可以调用的云服务业务接口在最小范围内。
数据传递安全
建议对跨信任边界传入的Want进行合法性判断
攻击者向指定应用Ability发送空的Want或携带恶意数据，如果应用接收该Want，却没有进行合法性判断，可能会导致应用业务逻辑被篡改，数据泄露、财产损失等问题。因此，应对外部传入的Want内容进行合法性判断。
常见的对Want的判断：
应用获取外部不可信Want的方式有很多种，例如：
在不同场景下获取Want的方式如下：
数据存储安全
避免直接使用不可信数据来拼接SQL语句
SQL注入是指对用户输入数据的合法性没有判断或过滤不严，攻击者可以传入特定内容将应用事先定义好的语句变成含义完全不同的SQL语句，导致信息泄露或者数据篡改。
任何外部的输入包括用户的输入都是不安全的，需要对外部输入的数据进行过滤处理。
HarmonyOS系统提供的关系型数据库是一款基于SQLite组件的数据库，可以直接运行用户输入的SQL语句。如果不可信的数据会被用于拼接SQL语句，就存在SQL注入的风险。应该使用参数化查询的方式或者对不可信内容做过滤。
HarmonyOS上querySql、executeSql会被用于拼接SQL语句的执行。
示例中的context的获取方式请参见获取UIAbility的上下文信息。
如果直接使用用户输入作为查询的参数，恶意用户可以输入类似 1' OR 'a' = 'a 的字符串，使sql语句拼接变成select *from book where name='1' OR 'a' = 'a'，从而导致SQL注入攻击。因此禁止直接使用外部输入作为查询字符串的一部分，或者在拼接SQL语句之前，对外部输入进行字符输入校验。
避免将个人数据存放到剪贴板中
剪贴板是指操作系统提供的一个暂存数据，并且提供共享的一个模块，也称为数据中转站。剪贴板在后台起作用，存放在内存里。
如果把个人数据放入剪贴板中是不安全的，因为任意程序都可以访问剪贴板中的内容。
将内容存放入剪贴板的方法有SystemPasteboard类中的setPasteData方法。
例外：如果是用户自己主动以剪切板作为中转，拷贝数据，则不受此规则约束。
避免使用未校验的外部数据拼接文件路径
HarmonyOS系统对文件存储进行了沙箱隔离，内部存储的文件只有应用程序有权限读取，且只能读取本应用内部存储目录；而对外部共享存储进行读取，则需要添加读取权限
在对文件进行读、写、下载、删除等操作时，如果使用了外部输入来拼接文件路径，攻击者可以注入../等恶意字符进行跨目录攻击，可导致数据泄露、应用拒绝服务等安全问题。因此在拼接路径之前，需要校验不可信数据是否包含了恶意的攻击字符。
```typescript
// fileName来自外部
function readFile(fileName: string) {
let filePath = "/data/storage/";
if (fileName.indexOf("..") === -1) { // 防拼接校验
let fileAllPath: string = filePath + fileName
// 业务处理
} else {
console.info("be attacked")
return
}
}
```
配置安全
建议正确设置发布版本应用调试属性
"debug"属性是为了方便开发人员对应用进行调试，但对于正式发布版本，如果应用设置为可调试模式，方便了攻击者对应用进行更深入的分析调试，不利于对应用的保护，因此要求正式版本须设置为不可调试模式。
对"debug"的设置需要在app.json5文件中进行配置。其中"debug"属性缺省值为false。
错误示例：
正确示例：
建议发布的软件包进行代码混淆
鸿蒙应用软件包（HAP、HAR、HSP）等可被反编译。配置代码混淆，给攻击者软件代码的分析设置障碍，可以增加其分析成本。
正确示例，开启属性混淆例子：
在应用源码工程obfuscation-rules.txt文件中，按照应用业务的需求配置和开启混淆规则。
建议应用使用的依赖库处于最新状态
大多数应用使用外部三方依赖库和系统SDK依赖来完成特定的任务。通过及时更新应用的依赖项，可以提高应用的安全性。
在发布您的应用前，建议检查所有库、SDK 和其他依赖项都处于最新状态：
应用签名安全
避免正式版本应用使用debug调试签名
HarmonyOS应用打包时，可以选择debug和release模式。Debug的应用是为了方便开发人员对应用进行调试。但在正式发布版本，如果应用设置为可调试模式，方便了攻击者对应用进行更深入的分析调试，不利于对应用的保护，因此要求正式版本上发布的应用禁止使用debug签名。
注意：目前DevEco Studio默认编译hap应用均为debug模式应用，不可直接用于版本商用
建议应用需保证签名完整性
应用签名是保障应用完整性的重要手段，因为要根据版本对应用进行资源裁剪、字节调整等原因，可能会在签名后再对应用进行修改，修改后未重新签名直接预装到手机上，类似行为会破坏应用签名完整性。
禁止应用破坏签名后上架或者直接预装到版本中。
建议应用在申请应用证书时不使用个人信息
应用签名必须要申请签名证书，申请证书时必须输入开发者信息、公司信息等，该证书是应用的身份标识和认证凭据。申请的证书在签名时会嵌入到应用包，成为应用包数据结构的一部分，而开发者可以通过公开的API或者读取应用包数据结构读取到应用证书信息。
如果开发者在证书信息中填入自己的姓名、工号等个人信息，会造成一定程度的信息泄露，也容易被质疑。证书信息应填写公司、团队名称，而非个人信息。
建议应用软件应包含的签名信息需要真实有效
预置应用软件应包含签名信息，且签名信息真实有效，对于非开源鸿蒙官方应用，不得采用开源鸿蒙公开证书，也不能使用明显与该产品无关的签名信息如Demo等；应用开发者，公司和部门每一项需保证真实有效，不能为网址、乱码等无效信息，签名证书中宜正确标识开发者身份主体信息，如企业名称、组织、省市和国家等信息，不得含有跟主体无关的信息。
错误示例：
正确示例：

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-app-asset-protection-design
爬取时间: 2025-05-01 09:00:12
来源: Huawei Developer
概述
本文档主要面向HarmonyOS应用的设计人员，介绍应用在资产保护方案设计过程中，可能会遇到的典型场景以及对应的推荐设计方案，同时给出了方案的关键点及参考案例。
典型业务场景
HarmonyOS应用的典型应用资产主要包括代码资产、用户数据资产、安全密钥资产、数据库资产等，其中数据库资产主要在服务器侧，由应用自行对其进行保护。根据不同的资产类型当前HarmonyOS系统均提供相应的机制进行保护。
根据当前APP开发过程中遇到的实际资产保护业务场景，总结提炼出如下典型场景，可供更多APP参考，设计其资产保护业务方案：
| 场景编号  | 资产保护场景  | 简述  |
| --- | --- | --- |
| 1  | 保护应用代码  | 保护应用代码主要是为了防止恶意攻击者对应用程序进行反向工程和盗用。如果应用程序的代码没有得到保护，攻击者可以轻松地获取应用程序的源代码，并对其进行修改、复制或分发。这可能会导致应用程序的知识产权被侵犯，或者应用程序被用于恶意目的，例如盗取用户的个人信息或者进行其他违法活动。  |
| 2  | 保护用户数据  | 用户数据包括用户的个人信息、账户信息、交易记录、位置信息等等。如果这些数据没有得到保护，攻击者可以轻松地获取这些数据，并对其进行恶意使用，例如盗取用户的身份信息、银行账户信息等等。并且对用户数据的保护也是目前监管要求的重点，对用户数据保护不当还会影响应用甚至HarmonyOS系统的用户口碑受到影响。  |
| 3  | 保护应用密钥  | 密钥是用于加密和解密数据的关键，如果密钥泄露，攻击者可以轻松地获取加密数据的明文，从而导致数据泄露和安全问题。  |
场景编号
资产保护场景
简述
1
保护应用代码
保护应用代码主要是为了防止恶意攻击者对应用程序进行反向工程和盗用。如果应用程序的代码没有得到保护，攻击者可以轻松地获取应用程序的源代码，并对其进行修改、复制或分发。这可能会导致应用程序的知识产权被侵犯，或者应用程序被用于恶意目的，例如盗取用户的个人信息或者进行其他违法活动。
2
保护用户数据
用户数据包括用户的个人信息、账户信息、交易记录、位置信息等等。如果这些数据没有得到保护，攻击者可以轻松地获取这些数据，并对其进行恶意使用，例如盗取用户的身份信息、银行账户信息等等。并且对用户数据的保护也是目前监管要求的重点，对用户数据保护不当还会影响应用甚至HarmonyOS系统的用户口碑受到影响。
3
保护应用密钥
密钥是用于加密和解密数据的关键，如果密钥泄露，攻击者可以轻松地获取加密数据的明文，从而导致数据泄露和安全问题。
HarmonyOS安全能力整体架构
HarmonyOS安全能力概述
HarmonyOS安全能力全景图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151200.42934261540882187523276859610958:50001231000000:2800:229112BAAE81BCD95B31B8F0A61339260B79C049D2A95DE37FEAD897A02CD0AD.png)
系统安全：
系统安全基于硬件构建安全可信根，通过多种访问控制、漏洞防利用、系统完整性保护、网络安全保护技术，从底层构建HarmonyOS系统安全底座。保障HarmonyOS系统安全运行基础，为HarmonyOS应用安全保护提供可靠基石。
应用安全生态：
HarmonyOS系统在系统安全底座之上，对HarmonyOS应用资产保护各种场景均提供对应安全保护能力。通过使用系统提供的安全能力，HarmonyOS应用可以对应用全生命周期内的应用资产进行保护。
HarmonyOS应用：
HarmonyOS应用作为自身应用资产的责任方，需要按需使用HarmonyOS系统提供的安全能力，并按照本文推荐的资产保护设计对自身资产进行保护。
HarmonyOS资产保护关键技术介绍
代码混淆
移动应用的代码安全非常重要，为了保护应用开发者的代码，避免应用被恶意逆向分析，提高攻击者分析代码的难度，DevEco Studio中默认提供了代码混淆能力，混淆后的JS、TS、ArkTS代码，不容易被逆向后读懂，混淆功能支持对名称进行混淆，包括对类、方法等做混淆处理。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151200.84154385517958996232246291147620:50001231000000:2800:9CF08541CF4B3F0A0419913DE27E0DAB28F6DF3E30EEA8E902E8CB7E870EFDCB.png)
代码混淆方案是基于源码混淆，将源码转为抽象语法树（AST），在AST上进行作用域分析和符号分析，混淆名称和属性，移除开发期间的日志打印代码，合并语句，压缩代码体积，在保证运行时性能无变化的前提下，有效保护HarmonyOS开发者核心知识产权免受恶意逆向分析。具体混淆效果如下例。
混淆前：
混淆后：
应用加密
为了保护应用代码安全，保护开发者的核心资产，HarmonyOS系统提供了端到端的应用代码保护机制，该机制以系统安全为基础，构建内核级应用生命周期内的代码安全保护能力。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151200.35888159099756863279252112901227:50001231000000:2800:03180A3E50F0C6E1737DC6305CB287A8831540D7E5ED196A481BD8A17047F874.png)
开发者向应用市场提交上架申请，再经过应用市场审核后，应用市场会对上架应用做代码加密，应用在设备上安装时，安装文件落盘后仍是处于加密状态，有效的保护应用程序；当应用程序启动时，通过内核加载的应用文件是加密状态，因此这些文件会在内核中按页解密执行。应用加密采用标准AES加密算法，有效提高应用程序的安全性。
应用包签名
开发者对应用安装包签名后，上架应用市场。应用市场会对上架应用进行上架检测和质量审核，对于满足上架要求的应用，应用市场会对应用安装包进行重签名；只有经过重签名的上架应用，才允许在设备上安装。
HarmonyOS系统对所有安装的应用都需要进行签名校验，确保应用来源可信和应用完整性；应用安装包签名校验发生在应用安装时，如果签名校验失败，则禁止应用安装。
HarmonyOS系统使用根CA对应用安装包进行签名校验，应用安装包的签名证书都需要从根CA开始采用证书链的方式签署。
对于调试应用的安装，HarmonyOS系统在校验安装包签名基础上，还需要严格匹配应用调试Profile中的设备ID与当前设备ID的匹配，如果不匹配的话禁止安装。
对于发布应用的安装，HarmonyOS系统仅允许经过应用市场审核通过后，由应用市场重签名过的安装包进行安装。
关键资产存储
关键资产存储（Asset Store）提供了关键敏感的隐私数据的本地加密存储，应用可以将用户高安全敏感的关键资产短数据（如用户的APP账号密码，银行卡号等）在本地加密存储，加密这些数据的密钥存储在安全的隔离区，只有合法的应用才能访问并解密这些数据。具体的架构如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151201.21506000991934160923419053497421:50001231000000:2800:E001C897439528D9E829177CD6F4F85637CFAB6903F1453924DA1C7DCD20D245.png)
除此之外，关键资产存储还支持以下安全措施：
密钥管理
HarmonyOS系统通用密钥库系统（英文全称：HarmonyOS Universal KeyStore，以下简称HUKS）是HarmonyOS系统提供的系统级的密钥管理系统服务，提供密钥的全生命周期管理能力，包括密钥生成、密钥存储、密钥使用、密钥销毁等功能，以及对存储在HUKS中的密钥提供合法性证明。HUKS基于系统安全能力，为业务提供密钥全生命周期的安全管理，业务无需自己实现，利用HUKS的系统能力，就能确保业务密钥的安全。
HUKS的核心安全设计包括以下几点。
密钥不出安全环境：HUKS的核心特点是密钥全生命周期明文不出HUKS Core，在有硬件条件的设备上，如有TEE（Trusted Execution Environment)或安全芯片的设备，HUKS Core运行在硬件安全环境中。能确保即使REE（Rich Execution Environment）环境被攻破，密钥明文也不会泄露。
系统级安全加密存储：基于设备根密钥加密业务密钥，在有条件的设备上，叠加用户口令加密保护密钥。
严格的访问控制：只有合法的业务才有权访问密钥，同时支持用户身份认证访问控制以支持业务的高安敏感场景下安全访问密钥的诉求。
密钥的合法性证明：可为业务提供硬件厂商级别的密钥的合法性证明，证明密钥没有被篡改，并确实存在于有硬件保护的HUKS Core中，以及拥有正确的密钥属性。
此外，密钥会话是HUKS中承载密钥使用的基础，它的主要作用是初始化密钥信息、缓存业务数据等。对数据的密码学运算和对密钥密文的加解密都是在HUKS Core中进行，以此保证密钥明文和运算过程的安全。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151201.04716957922531050602219441817787:50001231000000:2800:A2FE7B17399A98D72F245D052F82CED779223A9C4BD5662A063116EDD8CC123E.png)
应用资产保护设计
概述
不同的资产保护场景用到的HarmonyOS系统安全能力各不相同，此章节按照常见的资产保护场景的HarmonyOS安全保护方案设计。
保护应用代码场景
场景描述
在HarmonyOS应用业务实现过程中，应用代码对于开发者而言永远都是最重要的资产之一。应用代码是应用的核心，如果保护不当可能造成严重的知识产权损失以及面临严重的安全攻击威胁。
在HarmonyOS开发场景下，应用的代码分为C/C++等实现的代码，以及JS、TS、ArkTS实现的代码两类，最终的编译产物主要为.so文件和.abc文件。其中.so文件由于反编译难度较大，代码逆向困难，应用可按需决定是否做进一步保护。由于ArkTS本身为解释性语言，编译后的.abc文件为字节码，反编译难度较小，容易被逆向分析出核心代码，所以建议根据业务情况做一定的保护。
HarmonyOS开发实现方案介绍
HarmonyOS系统整体代码资产保护策略：
（1）开发阶段默认基础混淆，并支持对接三方商用混淆工具；
（2）上架阶段对应用进行加密；
（3）设备侧运行时对应用进行解密。
其中代码混淆和应用加密方案的介绍在”代码混淆”和”应用加密”章节。
业务实现中的关键点
DevEco Studio默认开启基础代码混淆
为保护代码资产，编译器默认开启代码混淆功能，默认对代码中的参数名和局部变量名进行混淆。建议没有特殊情况保持混淆开启，如果存在不需要代码混淆的场景，可以通过在模块级的build-profile.json5配置文件中关闭代码混淆功能。
官方提供的自定义混淆选项
DevEco Studio除了基础混淆能力，还提供一些更高阶的混淆能力，开发者可以通过以下操作配置高阶混淆规则：
1、打开Stage模型的ArkTS工程。
2、打开模块级build-profile.json5文件，在obfuscation字段下配置混淆规则
3、其中files为配置混淆规则文件路径，高级混淆能力通过将混淆规则写入混淆规则文件实现
在混淆规则文件中，开发者可以写混淆选项和保留选项，具体的混淆选项参考混淆配置，使用第三方安全加固厂商加固请参考使用第三方加固
HarmonyOS提供应用加密机制
开发者向应用市场提交上架申请、选择加密并通过审核后，应用市场会对所有上架的应用做代码加密，具体加密的对象为应用包中的.abc文件，并在应用运行加载进内存时，在系统内核进行解密。目标是保护应用程序二进制代码安全，保护开发者知识产权，并避免应用脱离设备后仍能运行。
应用加密主要通过以下3个关键能力实现：
代码加密能力：基于abc文件的加密，同时兼容快速补丁修复，代码签名机制；
基于动态加载按页解密能力：提升解密效率，在内核中按应用加载文件的内存页进行解密；
秘钥分发：通过平台账号的访问控制，基于设备TEE的设备认证的秘钥分发；
整套方案作为HarmonyOS系统应用安全基础能力完全由应用市场、HarmonyOS内核、终端设备实现，不需要开发者做任何配置和开发。
三方提供的应用安全加固保护
HarmonyOS在系统提供的应用代码保护机制之外，同时也兼容三方提供的安全加固保护机制，在应用代码资产保护述求较高的场景下，建议在开启系统保护机制情况下，同时使能三方的加固保护，增强代码资产保护的纵深防御能力。部分三方安全厂商已支持HarmonyOS系统，具体方法请参考使用第三方加固。
案例参考
应用代码保护均为系统应用安全基本能力，不同垂类的应用对于应用安全加固的要求和实现可能有些许不同，以对安全性要求最高的金融类应用为例，可以参考如下HarmonyOS应用的实际保护案例：
| 混淆  | 基础混淆  | 使用HarmonyOS官方Arkguard默认配置  |
| --- | --- | --- |
| 增强混淆  | 三方提供，建议安全要求高的场景选择开启，提高应用代码资产保护纵深防御能力  |
| 加密（应用市场）  | 代码加密  | 默认支持，需要上架时选择开启  |
| 加壳  | 加壳  | 禁止  |
| 其他加固  | 防调试  | 在HarmonyOS系统的基础上，三方提供增强  |
| 防篡改  | 在HarmonyOS系统的基础上，三方提供增强  |
混淆
基础混淆
使用HarmonyOS官方Arkguard默认配置
增强混淆
三方提供，建议安全要求高的场景选择开启，提高应用代码资产保护纵深防御能力
加密（应用市场）
代码加密
默认支持，需要上架时选择开启
加壳
加壳
禁止
其他加固
防调试
在HarmonyOS系统的基础上，三方提供增强
防篡改
在HarmonyOS系统的基础上，三方提供增强
与业界方案特殊差异说明
由于平台的应用安全机制和生态情况的区别，对应的应用加固方案有一定的区别，具体的区别对比如下：
| 操作系统  | 应用自保护策略  |
| --- | --- |
| HarmonyOS  | 应用加密（推荐） + 基础混淆 + 高级混淆（三方提供商业源码级别的混淆工具，安全要求高的场景推荐，但需要满足上架审核要求）  |
| 其他  | 加壳（主）/应用加密（主）+ 普通混淆/高级混淆（商业源码级别的混淆工具，但需要满足上架审核要求）  |
操作系统
应用自保护策略
HarmonyOS
应用加密（推荐） + 基础混淆 + 高级混淆（三方提供商业源码级别的混淆工具，安全要求高的场景推荐，但需要满足上架审核要求）
其他
加壳（主）/应用加密（主）+ 普通混淆/高级混淆（商业源码级别的混淆工具，但需要满足上架审核要求）
保护用户数据
场景描述
大部分应用在用户使用过程中都会产生用户数据，这些数据包括用户输入的一些个人信息，例如姓名、地址、电话号码、电子邮件地址等；也包括用户使用过程产生的行为数据，例如使用时长、功能使用次数等。这些数据由于监管要求和用户隐私要求，需要根据数据的类型进行相应的保护。本设计文档主要将用户数据分为普通用户数据和敏感个人数据两类，分别给出HarmonyOS开发过程中相应的保护能力和方案。应用可以根据《个人信息保护法》或其他的数据分类方法对数据进行分类。
HarmonyOS开发实现方案介绍
普通用户数据在HarmonyOS系统中，通过每个应用独立的应用沙箱进行隔离，在应用沙箱保护机制下，应用无法获知除自身应用文件目录之外的其他应用或用户的数据目录位置及存在。同时，所有应用的目录可见范围均经过权限隔离，只有自身和部分系统进程才有权限访问，其他未授权的三方应用均无法访问。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151201.37549464037976549603362788117823:50001231000000:2800:49573CDBE79AB78A2DE1E1C899BCB1F414307306AE5991EEBD8380BBD476CD35.png)
除此之外，对于一些更加敏感的用户数据，如用户口令、身份证号、银行卡号等，HarmonyOS系统还提供关键资产存储服务，关键资产的安全存储，依赖底层的TEE可信执行环境。具体来说，关键资产的加/解密操作以及访问控制校验，都在安全环境中完成，即使系统被攻破，也能保证用户敏感数据不发生泄露。详细方案可以参考关键资产存储开发服务
业务实现中的关键点
应用沙箱隔离及应用文件路径
应用沙箱限制了应用可见的数据的最小范围。在“应用沙箱目录”中，应用仅能看到自己的应用文件以及少量的系统文件（应用运行必需的少量系统文件）。因此，本应用的文件也不为其他应用可见，从而保护了应用文件的安全。
开发指导可以参考应用沙箱目录
关键资产存储服务使用
HarmonyOS系统提供关键资产存储开发服务（Asset Store Kit）给应用开发者使用，提供了用户短敏感数据的安全存储及管理能力。
开发指导及相关案例可参考Asset Store Kit（关键资产存储服务）
与业界方案特殊差异说明
与业界方案无特殊差异，应用开发者可以参考业界的类似方案来设计使用本能力。
保护应用密钥
场景描述
在HarmonyOS中用于加密和解密数据的密钥是其非常重要且需要保护的资产之一。密钥的主要使用场景包括：
开发指导及相关案例可参考密钥管理服务
与业界方案特殊差异说明
本方案核心层运行在硬件安全环境，除此之外与业界方案无特殊差异。
参考
HarmonyOS应用安全技术白皮书

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-app-code-ob
爬取时间: 2025-05-01 09:00:25
来源: Huawei Developer
概述
代码混淆是一种软件安全技术，旨在增加代码的复杂性和模糊性，从而增加攻击者分析和理解代码的难度。代码混淆有以下几个方面的作用：
针对工程源码的混淆可以提高工程被破解攻击的难度，缩短代码的类和成员的名称，减小应用的大小。
混淆开启
从DevEco Studio版本：4.0 Beta1开始hvigor插件提供代码混淆功能。混淆开启条件如下：
enable默认为false，默认不开启代码混淆功能。
满足上述开启混淆条件后，选择目标模块点击Build -> Make Module选项开始编译。
如果你的工程或者模块是Static Library，那么该工程或模块是一个HAR。
构建HAR时有以下三种方式：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151201.64189052748624263893350988110674:50001231000000:2800:03D76E427C79056A7A33A7C17785E6FA0802A1BC2928A1D189E13F02B0D5829D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151201.13393895231059974802315334239799:50001231000000:2800:3E1AB7B3D256EB3F6E0F0020AB263B5A93C61CC2F907DBA8AA0D16246A2FCC8C.png)
混淆配置能力
编译选项
若按照上述编译流程开启代码混淆，在 DevEco Studio5.0.3.600版本之前，默认是仅混淆参数名和局部变量名。但在 DevEco Studio5.0.3.600版本及之后，混淆规则配置文件obfuscation-rules.txt默认开启了四项推荐的混淆选项：-enable-property-obfuscation、-enable-toplevel-obfuscation、-enable-filename-obfuscation和-enable-export-obfuscation，开发者可以根据需要进一步修改混淆配置。
混淆配置
在工程的每个模块下都能找到 build-profile.json5 文件，如下图所示，可以在该文件中配置当前模块是否开启混淆以及开启混淆时按照哪个混淆配置文件进行混淆。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151201.52218807947425325539051087472245:50001231000000:2800:BC38E1B01EB6E8EBBE2B031C4D72F8F6763407E01D10E18AD056B9900C4F5FDB.png)
新建工程时，每个模块下都有obfuscation-rules.txt文件，混淆开启时会加载obfuscation-rules.txt中的配置，完成指定的混淆功能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151201.54659568615813558254847671128579:50001231000000:2800:86AECDA86844650EA06FC6F7DC38CE3F973FF2F2FAD220053D0E9538F4F42464.png)
上图中，obfuscation-rules.txt中添加了-enable-property-obfuscation、-enable-toplevel-obfuscation开关，这代表打开了属性混淆和顶层作用域名称混淆。
DevEco Studio混淆现有选项及功能描述如下：
|    | 混淆自定义选项名称  | 功能简述  |
| --- | --- | --- |
| 混淆选项  | -disable-obfuscation  | 关闭混淆  |
| -enable-property-obfuscation  | 属性混淆  |
| -enable-toplevel-obfuscation  | 顶层作用域名称混淆  |
| -enable-filename-obfuscation  | 文件名混淆  |
| -enable-export-obfuscation  | export导出名称与属性混淆  |
| -compact  | 代码压缩  |
| -remove-log  | 删除console.*方法  |
| -print-namecache filepath  | 指定路径输出namecache.json文件及内容  |
| -apply-namecache filepath  | 复用指定的名称缓存文件  |
| -remove-comments  | 删除注释  |
| 保留选项  | -keep-property-name  | 保留属性名  |
| -keep-global-name  | 保留顶层作用域和导出元素的名称  |
| -keep-file-name  | 保留指定的文件/文件夹的名称  |
| -keep-dts  | 读取指定.d.ts文件中的名称作为白名单  |
| -keep-comments  | 保留编译生成的声明文件中class, function, namespace, enum, struct, interface, module, type及属性上方的JsDoc注释  |
| -keep  | 保留指定相对路径中的所有名称（例如变量名、类名、属性名等）  |
| 通配符  | 名称类和路径类的保留选项支持通配符  |
混淆自定义选项名称
功能简述
混淆选项
-disable-obfuscation
关闭混淆
-enable-property-obfuscation
属性混淆
-enable-toplevel-obfuscation
顶层作用域名称混淆
-enable-filename-obfuscation
文件名混淆
-enable-export-obfuscation
export导出名称与属性混淆
-compact
代码压缩
-remove-log
删除console.*方法
-print-namecache filepath
指定路径输出namecache.json文件及内容
-apply-namecache filepath
复用指定的名称缓存文件
-remove-comments
删除注释
保留选项
-keep-property-name
保留属性名
-keep-global-name
保留顶层作用域和导出元素的名称
-keep-file-name
保留指定的文件/文件夹的名称
-keep-dts
读取指定.d.ts文件中的名称作为白名单
-keep-comments
保留编译生成的声明文件中class, function, namespace, enum, struct, interface, module, type及属性上方的JsDoc注释
-keep
保留指定相对路径中的所有名称（例如变量名、类名、属性名等）
通配符
名称类和路径类的保留选项支持通配符
混淆选项具体的使用方法和样例代码可以参考代码混淆。
混淆优化建议
开发人员混淆工程，查看缓存文件或者SDK中文件发现大量源码名称未混淆，原因有两类：
混淆规则合并策略
编译工程中的某个模块时，其最终所应用的混淆规则是来自以下三个地方文件中配置的混淆规则的合并:
HAR模块的build-profile.json5中consumerFiles配置了共享混淆配置文件，该文件生效条件：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151201.51305107796248472388620896795025:50001231000000:2800:44E303016591272826E288F3D999A180AFC7CCFD7643F8FF5A5763FEF5E04BE5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151201.25173834349822590830450692545334:50001231000000:2800:FABA0B45E674A7848227CB6A0B24D640B9DA2B6C31A2677A10DC2D8448C908B9.png)
合并规则（以下面四个选项为例，其它选项合并规则与其一致）：
查看混淆结果
开发人员可以在编译模块下的build目录中找到编译及混淆生成的缓存文件，以及混淆的名称映射表及系统API白名单文件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151201.74624077740513262398696092488274:50001231000000:2800:BAFAEB335CC54D72A5C1EC2353BFECF466B0E13E0CB789125672033C92961A40.png)
调试
经过混淆工具处理后的代码名称会发生更改，这可能会使运行时crash堆栈日志难以理解，因为堆栈与源代码不完全一致。如果未保留调试信息，就可能会出现因行号及名称更改无法定位问题的情况。此外，开启-enable-property-obfuscation、-enable-toplevel-obfuscation等选项，代码混淆可能会引发运行时crash或者是功能性错误，需要开发人员还原报错堆栈来排查定位哪些名称与属性需要配置白名单来保障功能正常。
函数调用栈还原
经过混淆的应用程序中代码名称会发生更改，因此报错栈与源码不完全一致，crash时打印的报错栈会难以理解，如何处理请参考报错栈还原。
反混淆工具hstack
hstack需要将Node.js配置到环境变量中，详细使用说明请参考hstack。
常见报错案例
请参考常见报错案例
使用第三方加固
在HarmonyOS提供的代码混淆能力之外，开发者还可以使用第三方安全厂商提供的高级混淆和加固能力。一些安全加固厂商，已经启动HarmonyOS开发，开发者可以按需使用此类安全厂商提供的服务。这一部分由开发者与三方安全厂商自行沟通合作方式和范围，本文不做详细说明。具体的官方与三方代码混淆能力的关系如下：
| 特性  | 特性描述  | HarmonyOS  | 三方  |
| --- | --- | --- | --- |
| 名称混淆  | 混淆类、字段、属性、方法和文件名。  | √  | √  |
| 控制混淆  | 混淆方法内的控制流以防御自动或手动代码分析，包括虚假控制流和控制流扁平化。  | ×  | √  |
| 指令替换  | 通过将简单的算术和逻辑表达式转换为难以分析的代码来保护专有公式。  | ×  | √  |
| 数据混淆  | 加密敏感字符串，以防止通过尝试搜索的黑客攻击，也用来加密类、 asset 文件、资源文件和 Native 库  | ×  | √  |
| 代码虚拟化  | 转换方法实现为随机生成虚拟机的指令序列  | ×  | √  |
| 调用隐藏  | 为访问敏感的 APIs 添加反射，比如用于签名校验和密码操作的标准APIs  | ×  | √  |
| 移除日志代码  | 移除 logging 、调试和测试代码，以阻止任何利用此信息的企图  | ×  | √  |
特性
特性描述
HarmonyOS
三方
名称混淆
混淆类、字段、属性、方法和文件名。
√
√
控制混淆
混淆方法内的控制流以防御自动或手动代码分析，包括虚假控制流和控制流扁平化。
×
√
指令替换
通过将简单的算术和逻辑表达式转换为难以分析的代码来保护专有公式。
×
√
数据混淆
加密敏感字符串，以防止通过尝试搜索的黑客攻击，也用来加密类、 asset 文件、资源文件和 Native 库
×
√
代码虚拟化
转换方法实现为随机生成虚拟机的指令序列
×
√
调用隐藏
为访问敏感的 APIs 添加反射，比如用于签名校验和密码操作的标准APIs
×
√
移除日志代码
移除 logging 、调试和测试代码，以阻止任何利用此信息的企图
×
√
需要注意的是，由于HarmonyOS代码签名、应用加密等安全机制的限制，以及应用市场上架审核纯净安全的要求，三方加固厂商提供的安全加固内容需要满足以下四点要求：
1、不允许隐藏敏感系统API调用，需要让审核人员清晰的看到应用特性；
2、不允许混淆非自研的SDK，SDK应该由SDK厂商自行进行混淆保护，如果非自研SDK被混淆会影响应用市场审核相关SDK的指纹信息；
3、通过三方安全加固的应用，需要保证被加固的应用程序不能含有恶意行为，避免对生态造成影响，此条要求作为约束性条款，不遵循可能导致应用被下架；
4、不允许使用三方虚拟机，HarmonyOS系统通过代码签名等机制限制动态加载代码，此方法可能让应用无法正常运行。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-permission-application
爬取时间: 2025-05-01 09:00:39
来源: Huawei Developer
概述
在HarmonyOS开发中，应用访问如相机、麦克风、位置、图库等系统资源或系统能力时，需通过系统Picker、安全控件、授权使用等方式来访问，以确保用户隐私安全。在申请权限授权过程中需严格遵循HarmonyOS应用安全体验要求，同时符合UX体验设计，以提供合理且用户友好的交互体验。本文将从以下五个方面，介绍应用申请权限时的注意事项：
优先使用系统Picker或者安全控件
系统通过提供系统Picker和安全控件两种方式，使得应用能够便捷地访问系统资源。这两种方法均依赖于系统的独立进程来实现，当应用拉起系统Picker或展示安全控件时，必须依赖用户的主动操作来获取资源或结果。这一流程避免了应用额外申请权限，同时，由于用户的积极参与，进一步增强了用户隐私和安全的保护。
系统Picker
系统Picker是拉起系统资源的一种方式，由于系统Picker已经获取了对应权限的预授权，开发者使用系统Picker时，无需再次申请权限也可临时受限访问对应的资源。
使用系统Picker组件拉起系统应用的场景主要有：联系人Picker（Contacts Picker），地图Picker，相机Picker（Camera Picker），扫码Picker，卡证识别Picker，文档扫描Picker，文件Picker，音频Picker和照片Picker（PhotoViewPicker）等，详细可参考拉起系统应用。
安全控件
安全控件是系统提供的一组系统实现的ArkUI组件，应用集成这类组件就可以实现在用户点击后自动授权，而无需弹窗授权。它们可以作为一种“特殊的按钮”融入应用页面，实现用户点击即许可的设计思路。
目前系统提供两类安全控件：粘贴控件（PasteButton）、保存控件（SaveButton）。
使用场景示例
以下列举了两个优先使用系统Picker或者安全控件的场景：
权限申请时机
为了应用能够发挥其完整功能，可能需要访问系统的特定资源，而这些资源的访问通常需要获得相应的权限许可。在应用进行权限申请时，选择合适的权限申请时机是提升用户体验和保护用户隐私安全的关键。主要可分为两点：
按需请求权限
尊重用户选择，避免强制请求
-
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151201.66926760920617896960728451892121:50001231000000:2800:FB36060ABB0F472CC37BE210E5A4B09B61FAC91FF4B7168F827E4928805B0F84.png)
明确声明原因
在请求应用权限时，增强用户信任并减少权限拒绝风险的关键在于，通过对话框或提示信息，向用户清晰说明为何需要此权限，或向用户解释所请求权限的相关数据将如何被使用，即明确声明原因。
在应用开发过程中，首先需要在module.json5配置文件的requestPermissions标签中声明权限。其中权限使用理由必须按照规范来填写，具体规范可参考官方声明权限中权限使用理由的文案内容规范章节。
在填写权限声明原因时，为了增强用户的理解度、提升信任感、降低权限拒绝率，并优化整体用户体验，应遵循以下原则与规范：
以下是一些正反例来说明如何按照规范填写权限声明原因了，详细内容可参考指南reason字段的内容写作规范及建议。
正例
-  权限：位置信息 权限声明原因：“为了向您展示您的当前位置信息，且该信息仅用于本应用的展示，并严格保密。” 解释：此示例清晰地说明了应用为何需要位置信息（展示您的当前位置信息），并承诺了信息的使用范围及用途（仅用于本应用的展示），确保了信息的保密性，符合规范且易于用户理解。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151202.35092638152815680471011087551895:50001231000000:2800:C40F33555126C1695F8B0A4E2D8BA44567A55976F4B8BEC197B88C66DEC136E3.png)
-  权限：相机 规范填写示例：“我们需要访问您的相机权限，用于拍摄照片、录制视频以及进行人脸识别等功能。” 解释：此示例明确指出了相机权限的用途（拍摄照片、录制视频、人脸识别），并强调了这些功能对提升应用体验的重要性，符合规范。
反例
-  权限：位置信息 不规范填写示例：“我们需要您的位置信息。” 解释：此示例虽然简短，但并未明确说明位置信息的具体用途，用户可能不清楚为何需要此权限，缺乏明确性与透明度，不符合规范。
-  权限：相机 不规范填写示例：“为了应用功能，请允许访问相机。” 解释：此示例同样过于笼统，没有具体说明相机权限将用于哪些功能，用户难以判断权限请求的合理性，也不符合规范。
向用户申请授权
对于user_grant类型权限在配置文件声明权限后还需要向用户请求授权，经过用户允许后才能获得权限，在这一过程中要注意符合UX体验设计，给用户带来良好的体验，避免出现二次弹框或者让用户到设置中打开权限等不好的体验。
当用户触发需要使用权限的场景时，首先需要判断当前是否已经授权，如果已经授权，则可以直接访问目标操作，否则需要向用户申请授权。调用requestPermissionsFromUser()方法可以向用户申请授权，通过判断返回结果authResults字段为0则表示用户已经授权，则可以继续访问目标操作，authResults字段为-1则表示用户没有授权，这时需要判断返回结果的dialogShownResults，当结果为true表示有弹框表明已经向用户展示请求授权的弹窗但是用户拒绝了授权，那应用需要在页面内合适的位置添加提示语引导用户开启权限或者退出该场景，dialogShownResults结果为false表示当前应用没有被授权且没有向用户展示请求授权的弹框，那应用可以调用requestPermissionOnSetting()方法直接拉起权限设置弹框，引导用户授予权限。
requestPermissionOnSetting()方法在调用前需要先调用requestPermissionsFromUser()方法。
若用户点击了“本次使用允许”，则下次申请权限应该调用requestPermissionsFromUser()方法，而不能直接调用requestPermissionOnSetting()方法。
系统弹框一般有三种操作，如下图所示。
1.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151202.51071037539967707754768032724191:50001231000000:2800:470F3D2E27522C5377184DD02EDAA795A1961C446E1CAF5608A06B487A402EB6.png)
具体流程图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151202.44099771120704865595032916870020:50001231000000:2800:222E1A166B2048E96D0D4F20EBDFF2CF5B2FA3F12C268A395E99F44EC6F7CA01.jpg)
示例代码
判断当前应用是否已经被授权。
```typescript
// 验证应用程序是否已被授予权限
checkPermissionGrant(): void {
let hasPermission = false;
let tokenId: number = 0;
try {
let bundleInfo: bundleManager.BundleInfo =
bundleManager.getBundleInfoForSelfSync(bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION);
let appInfo: bundleManager.ApplicationInfo = bundleInfo.appInfo;
tokenId = appInfo.accessTokenId;
} catch (error) {
const err: BusinessError = error as BusinessError;
hilog.error(0x0000, 'Index',
`Failed to get bundle info for self. Code is ${err.code}, message is ${err.message}`);
}
try {
let atManager = abilityAccessCtrl.createAtManager();
let approximatelyLocation = atManager.checkAccessTokenSync(tokenId, 'ohos.permission.APPROXIMATELY_LOCATION');
let location = atManager.checkAccessTokenSync(tokenId, 'ohos.permission.LOCATION');
hasPermission = approximatelyLocation === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED &&
location === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED;
} catch (error) {
const err: BusinessError = error as BusinessError;
hilog.error(0x0000, 'Index', `Failed to check access token. Code is ${err.code}, message is ${err.message}`);
}
if (hasPermission) {
this.isLocationToggle();
} else {
this.requestPermissions();
}
}
```
向用户申请授权。
引导用户授权。
功能被禁用处理方式
用户可以在系统设置中，打开超级隐私模式或者关闭相机、麦克风、位置的全局开关，此时，即使应用已经被授权相关权限，也不能完成访问目标的操作。应用需要检测到这种状态，并通过适当的方式（如拉起全局开关的弹窗或一段描述性文字引导用户开启全局开关等）来提醒用户并辅助开启对应的全局开关。所以需要在调用接口前判断全局开关是否被关闭，如果全局开关被关闭，则需要调用requestGlobalSwitch()方法来打开它，之后才能继续调用所需的接口，具体流程图如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151202.27606333321035012717221953051567:50001231000000:2800:14FA6F62D16EE80865892E25F08A06CDA05F2F5DDACC13764C386D0BAD08EAD9.jpg)
以下为判断各全局开关是否打开的方法：
位置：isLocationEnabled判断位置服务是否已经使能，返回true表示位置信息开关已开启，false表示位置信息开关已关闭；
相机：isCameraMuted查询相机当前的禁用状态（禁用/未禁用），返回true表示相机被禁用，false表示相机未被禁用；
麦克风：isMicrophoneMute查询麦克风当前静音状态，返回true为静音，false为非静音。
示例代码
以位置权限为例，功能被禁用的处理方式代码如下：
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-network-ca-security
爬取时间: 2025-05-01 09:00:52
来源: Huawei Developer
概述
应用与服务器之间通过网络传输数据，需要确保数据在传输过程中的安全，保护传输数据的机密性和完整性，防止敏感数据被窃取和篡改是很重要的。推荐使用传输层安全协议（TLS）来保护网络传输数据的安全。
当应用通过HTTPS访问云侧服务器时，如果应用信任了用户安装的CA证书，则用户可以通过网络代理工具（如Fiddler、Charles）对HTTPS消息进行中间人攻击（如查看、篡改请求和响应消息），可能会导致应用或云侧服务器产生安全风险，因此在通过HTTPS访问云侧服务器时应该配置CA证书进行合法性校验。
本文通过介绍应用如何配置CA证书进行合法性校验来避免对应用或云侧服务器产生安全风险。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151203.51015290357754690535855581010767:50001231000000:2800:54BFBF343F14A168705F0B5094DE99706A951723265D3D076C639B10D92B9E2A.png)
配置CA证书对服务器进行合法性校验
当应用通过TLS协议连接服务器时，服务器会提供证书链来证明其身份，应用需要使用可信的CA（证书颁发机构）证书对服务器证书链进行合法性校验。
服务器一般会根据场景使用不同类型CA颁发的证书链：
系统提供了3种CA证书的管理方式：
开发者应该结合应用的业务场景，在不影响业务功能的情况下，合理设置可信CA证书的范围：
网络连接安全配置
配置信任系统预置的CA证书
系统Network Kit和Remote Communication Kit的HTTPS连接默认信任系统预置的CA证书和用户安装的CA证书，可配置不信任用户安装的CA证书提升安全性。
如果应用使用三方库进行网络连接，则需要手工设置系统预置的CA证书路径：/etc/security/certificates。
示例
使用三方库curl进行HTTPS连接，通过下面代码设置信任的CA证书路径：
配置不信任用户安装的CA证书
Network Kit和Remote Communication Kit配置不信任用户安装的CA证书：在src/main/resources/base/profile/network_config.json配置文件中进行配置。
配置信任应用管理的CA证书
如果应用服务器使用企业内部自建的CA证书，则应用可以在Hap包中预置自建的CA证书，并配置信任这些CA证书。
-  Network Kit也支持在发起HTTPS请求的代码中指定信任的CA证书路径： Remote Communication Kit也支持在代码中指定信任的CA证书路径：
系统Network Kit和Remote Communication Kit在进行上面的配置后，HTTPS连接仍然信任系统预置的CA证书和用户安装的CA证书，可配置不信任用户安装的CA证书提升安全性。
配置信任用户安装的CA证书
用户安装的CA证书可信度较低，除以下场景外，建议应用不信任用户安装的CA证书：
1.  注意：在商用发布的应用版本中应该不信任用户安装的CA证书。
配置SSL Pinning证书锁定
一般情况下应用默认信任系统预置的CA证书，如果有预置的CA颁发了不可信证书，则应用将面临攻击的风险，对网络安全比较高的应用（如金融支付、银行类应用），可以通过配置SSL Pinning证书锁定的方式只信任指定服务器证书的公钥。
配置SSL Pinning：支持两种配置方式，对应用访问的服务器域名比较固定的情况建议采用静态SSL Pinning方式配置，否则需要采用动态SSL Pinning配置。
SSL Pinning要求应用云侧服务器证书的公钥不能变化，如有变化需要修改应用内配置的证书公钥，否则应用的网络连接会失败，因此建议SSL Pinning配置始终包含至少一个备用公钥。
同时，应用可以设置SSL Pinning的到期时间，在该时间之后不再锁定证书。这有助于在服务器证书公钥变化时，防止还未更新的应用出现连接性问题。但是设置SSL Pinning的到期时间可能会使攻击者绕过证书锁定。
请开发者对安全风险（如：应用在应用层做了敏感信息的加密或签名，则安全风险较低）和SSL Pinning的限制约束进行充分的评估和决策是否配置。
1.  具体可参考配置指导的“预置锁定证书PIN”章节。
2.  具体可参考配置指导的“certificatePinning”参数说明。 具体可参考配置指导的“certificatePinning”参数说明。
3.  具体可参考配置指导的“certificatePinning”参数说明。
4.  具体可参考配置指导的“certificatePinning”参数说明。
-  具体可参考配置指导的“certificatePinning”参数说明。
-  具体可参考配置指导的“certificatePinning”参数说明。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-cross-platform-compatibility
爬取时间: 2025-05-01 09:01:06
来源: Huawei Developer
概述
为确保数据安全，在数据传输过程中对数据进行加解密操作至关重要。而实现加密和解密操作在不同环境下的一致性和互操作性，即确保跨平台数据的兼容性，也极为关键。这一目标的实现会受到以下两个方面的影响：
本文从数据编码格式差异以及加解密算法使用差异两个方面来深入分析加解密失败的可能原因，并提供相应的解决方案，避免造成跨平台加解密的失败，助力开发者在HarmonyOS平台上高效、准确地完成加解密任务，实现跨平台数据的兼容性。
加解密开发步骤
加解密通常遵循以下流程：
1.  根据所选的加密算法，初始化相应的加密引擎。可以通过设置加密模式（如CBC、ECB等）、填充方式等参数，来满足特定的安全需求。
数据编码格式差异
鉴于加解密往往会跨平台操作，例如服务端加密的数据需要在移动设备上解密，而HarmonyOS平台的加解密API要求密钥和待处理的数据必须为Uint8Array格式。为此，需要将Uint8Array字节数据与其他编码格式数据相转换，确保编码格式的一致性。
以下列举三种数据格式之间的转换方法：
-  建议采用UTF-8编码。UTF-8编码是一种广泛支持的字符编码，能够表示大多数语言的字符，且在不同平台间具有很好的兼容性。
-  如果服务端将数据加密后使用Base64编码，那么在HarmonyOS侧接收数据后，需要先进行Base64解码，将字符串转换为Uint8Array类型的字节流，再进行解密操作。 反之，如果需要将数据从HarmonyOS侧发送到服务端，也需要先将数据加密后的字节流进行Base64编码，将数据转换为字符串后再进行传输。
加解密算法使用差异
不同平台都会支持相同的算法，但不同平台的加解密算法可能在使用时有所不同，这些差异可能会导致加解密无法正常的跨平台使用。
HarmonyOS平台与其他平台在加解密过程中存在以下使用上的差异：
SM2加解密
SM2，是一种基于椭圆曲线的公钥密码算法。
下面主要介绍并解决在HarmonyOS平台和其他平台交互使用SM2加解密开发中遇到的问题：密钥格式问题、密文数据格式问题。
-  SM2加解密中，其他平台与HarmonyOS平台的密钥格式不符，其中HarmonyOS平台支持ASN.1序列化后的数据（公钥91字节，私钥51字节），而很多开发者使用的其他平台密钥数据是未序列化过的原始裸数据（公钥64字节，私钥32字节），不能直接使用，需要转换为ASN.1格式的数据。下面以其他平台生成的十六进制密钥为例，介绍如何转换为HarmonyOS平台可用的SM2密钥。 其他平台生成的公钥都是04开头的130位字符串，对应的格式为04+x+y，x和y的长度是一致的，私钥则是不带04的128位字符串。 将对应的16进制参数放入对应的位置，可通过密钥参数生成SM2公钥。 同理，可通过密钥参数生成SM2私钥。
-  SM2 是一种国产非对称加密算法。它的密文格式通常由三部分组成： C1：椭圆曲线点，长度为 65 字节。它是密文的一部分，用于解密过程中的计算； C2：实际的加密数据，长度根据加密的数据长度而定； C3：哈希值，长度为 32 字节。用于验证密文的完整性。 目前SM2密文数据的参数组合顺序有两种标准，老标准C1C2C3，新标准C1C3C2。 HarmonyOS平台采用的密文格式可能与其他平台格式不一样，当前HarmonyOS平台支持的SM2密文格式为国密标准的ASN.1格式，其中各参数组合顺序为C1C3C2，具体参数含义请参考转换SM2密文格式。 对于其他平台加密的C1C2C3顺序的密文，在HarmonyOS平台解密的时候，需要先序列化生成ASN.1格式的密文。 同理，HarmonyOS平台生成的C1C3C2顺序的ASN.1格式密文在其他平台使用时，需要先解码为C1C3C2的裸密文。
AES加解密
AES（Advanced Encryption Standard），最常见的对称加密算法。
下面主要介绍并解决在HarmonyOS平台和其他平台交互使用AES加解密开发中遇到的问题：密钥长度使用问题、指定分组模式后偏移量参数设置问题。
-  在AES加解密算法中，密钥长度是固定的。 HarmonyOS平台初始化加解密引擎时，需要明确指定算法规格以及对应的密钥长度，它可以是128位（对应的字符串参数为AES128）、192位（对应的字符串参数为AES192）或256位（对应的字符串参数为AES256）。同时，AES密钥的字节长度与位数之间有固定的对应关系：16字节对应128位，24字节对应192位，32字节对应256位，所以也可以通过密钥的位数来推断出其字节长度。 以指南使用AES对称密钥（GCM模式）加解密(ArkTS)为例，使用 'AES128|GCM|PKCS7'初始化加解密算法实例，那么加解密时对应的密钥应为128位也就是16个字符，所以在生成密钥时传入的字符为new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159])。 通过字符串获取密钥位数 在使用HarmonyOS的加解密API时，需要明确指定算法规格以及对应的密钥长度。这个参数必须与传入的密钥相匹配。给定的密钥字符串通常以字节序列或十六进制字符串等形式表示，不能直接从中得知其位数信息。 因此，当给定一个表示AES密钥的字符串，需要确定其密钥长度（以位数表示）时，可以按照以下步骤进行：
-  由于AES为分组加密算法，分组长度为128位。在实际应用中，最后一组明文可能不足128位（16字节），此时可以通过不同的填充模式进行数据填充。 以GCM模式和CBC模式为例，指定字符串参数分别为'AES128|GCM|PKCS7'和'AES128|CBC|PKCS7'，偏移量分别为16字节和12字节。 分组模式 所需参数 备注 ECB 没有偏移量等参数。 - CBC、CTR、OFB、CFB iv长度为16字节。 - GCM 加解密参数iv，长度为1~16字节，常用为12字节。 加解密参数add，长度为0~INT_MAX字节，常用为16字节。 加解密参数authTag，长度为16字节。 在GCM模式下，需要从加密后的数据中取出末尾16字节，作为解密时初始化的认证信息。
| 分组模式  | 所需参数  | 备注  |
| --- | --- | --- |
| ECB  | 没有偏移量等参数。  | -  |
| CBC、CTR、OFB、CFB  | iv长度为16字节。  | -  |
| GCM  | 加解密参数iv，长度为1~16字节，常用为12字节。 加解密参数add，长度为0~INT_MAX字节，常用为16字节。 加解密参数authTag，长度为16字节。  | 在GCM模式下，需要从加密后的数据中取出末尾16字节，作为解密时初始化的认证信息。  |
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-recommended-use-of-device-id
爬取时间: 2025-05-01 09:01:19
来源: Huawei Developer
概述
设备标识是一种用于唯一标识设备的代码或符号，类似于身份证在现实生活中的作用。在移动应用开发中，设备标识有着至关重要的作用，它是准确识别设备的关键，可以用于分析用户行为、推送信息和提供个性化服务等功能场景。出于用户隐私和安全考虑，在开发过程中，需要遵守相关的隐私政策和法规，确保用户数据的安全和合规性，建议选用用户可重置的设备标识，HarmonyOS提供了三种可重置的设备标识：
开发者在选择设备标识时，可以通过特性、重置规则、是否需要用户同意授权这三个方面去进行对比，具体如下：
| 设备标识  | 特性  | 重置规则  | 是否需要用户同意授权  |
| --- | --- | --- | --- |
| ODID  | 同一设备上运行的同一个开发者的应用，ODID相同。同一个设备上不同开发者的应用，ODID不同。不同设备上同一个开发者的应用，ODID不同。不同设备上不同开发者的应用，ODID不同。  | 手机恢复出厂设置。同一设备上同一个开发者的应用全部卸载后重新安装时。  | 否  |
| OAID  | OAID是设备级标识符，同一台设备上不同的App获取到的OAID值一样。OAID的获取受应用的“跨应用关联访问权限”开关影响：当应用的“跨应用关联访问权限”开关开启时，该应用可获取到非全0的有效OAID；当应用的“跨应用关联访问权限”开关关闭时，该应用仅能获取到全0的OAID。同一台设备上首个应用开启应用“跨应用关联访问权限”开关时，会首次生成OAID。  | 用户恢复手机出厂设置。用户操作重置OAID：打开系统设置–隐私和安全–跨应用关联页面，把所有应用的跟踪权限关了，再任意打开一个，即可触发OAID的重置。  | 是（调用getOAID接口需要申请ohos.permission.APP_TRACKING_CONSENT权限，并获取用户授权（默认开启权限））  |
| AAID  | 匿名化、无隐私风险：AAID和已有的任何标识符都不关联，并且每个应用只能访问自己的AAID。同一个设备上，同一个开发者的多个应用，AAID取值不同。同一个设备上，不同开发者的应用，AAID取值不同。不同设备上，同一个开发者的应用，AAID取值不同。不同设备上，不同开发者的应用，AAID取值不同。  | 应用卸载重装。应用调用删除AAID接口。用户恢复出厂设置。用户清除应用数据。  | 否  |
设备标识
特性
重置规则
是否需要用户同意授权
ODID
否
OAID
是（调用getOAID接口需要申请ohos.permission.APP_TRACKING_CONSENT权限，并获取用户授权（默认开启权限））
AAID
否
设备标识应用场景推荐
下面列举了一些使用设备标识的常见场景，开发者可以基于场景选择合适的设备标识。
安全与防欺诈
场景简介
推荐方案
在用户账号首次登录时，可以将账号与ODID或者AAID绑定，作为一个额外的验证确保设备与特定设备的关联性。当账号再次登录时，系统可以快速识别账号登录是否在同一设备，从而快速确定用户的身份和设备的合法性，具体如下：
另外，可以使用应用设备状态监测标识设备，根据Device Security服务器返回的使用状态，判断应用是否在该设备上首次安装，或在该设备上用户是否已获取了优惠券等，以支撑业务进行新用户营销活动。
数据分析与营销
场景简介
广告服务平台在广告展示过程中，需要记录对应的设备上用户与广告的交互行为。例如，广告的曝光时间（即广告在设备屏幕上显示的时长）、用户是否点击了广告、用户在广告落地页的停留时间等。
推荐方案
可以通过OAID将采集到的设备和用户行为数据进行关联。对于具有特定 OAID 的设备，可以分析出该设备用户的广告偏好。例如，如果一个OAID对应的设备用户经常点击游戏类广告，且在游戏广告落地页有较高的转化率（如下载游戏或进行游戏内付费），那么就可以将该 OAID 标记为对游戏广告感兴趣的用户。广告服务平台可以依据用户的广告偏好选择合适的时间和方式进行营销推广，提高营销效果和转化率。HarmonyOS也提供广告服务，应用可以在接入广告服务时传入OAID为用户更精准的推送广告。
跨应用数据整合
场景简介
数据整合是把在不同数据源的数据收集、整理，转换后加载到一个新的数据源，为开发者提供统一数据视图的数据集成方式。对于同一开发者旗下的多个应用，需要了解用户在不同应用中的行为习惯和偏好。
推荐方案
由于同一设备上运行的同一个开发者的应用，ODID相同，可以推荐使用ODID来进行跨应用的数据追踪，进行针对性的优化和改进。
总结
本文介绍了ODID、OAID、AAID三种设备标识的特性和重置规则，然后针对不同的场景和设备标识使用需求，分析并推荐了合适的解决方案。
通过对本篇文章的阅读，希望能帮助您解决常见的一些设备标识使用问题。
示例代码

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability
爬取时间: 2025-05-01 09:01:32
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-overview
爬取时间: 2025-05-01 09:01:45
来源: Huawei Developer
应用稳定性是影响用户体验的重要因素之一，常见的稳定性问题包括：崩溃、应用Freeze、内存泄漏、内存越界等。HarmonyOS系统提供了完善的稳定性治理框架，围绕着稳定性治理活动，系统提供了丰富的工具，工具涵盖范围包括开发、调试、应用上线以及线上运维等完整生命阶段。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151203.94286747768912734421086252021530:50001231000000:2800:CC7E9C75A80FDE91340B4AA50AD11C087BA18350F0776963713120EAFA4C8E86.png)
具体用于稳定性治理活动的工具有日志、应用事件、调用链跟踪、故障管理、观测信息剖析等。HarmonyOS生态厂家可以通过工具之一的应用事件获取相应的故障信息，进一步可以基于应用事件构造在线运维系统APM（Application Performance Management）。在开发阶段，开发者可以通过DevEco Studio调试调优工具进行快速的稳定性问题定界定位。在应用上线后，开发者可以基于APM系统进行故障分析与处理、指标度量、应用质量分析等各项运维活动，提升应用稳定性。
以下稳定性最佳实践，结合HarmonyOS生态实践要求，按照故障稳定性检测、稳定性分析、稳定性优化、稳定性运维等内容，介绍HarmonyOS生态稳定性治理的完整方案。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151203.33170625503691473812034747141149:50001231000000:2800:6FD02E8EE0EEAC38638C9588D62AD160243F984928466C87F17E0879278A454D.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-detection
爬取时间: 2025-05-01 09:01:58
来源: Huawei Developer
稳定性检测分为运行态检测，应用体检和稳定性测试三个部分：运行态检测列出了多种检测工具，帮助开发者定位程序运行中可能出现的内存问题与线程问题；应用体检工具则用于对应用和元服务进行本地测试体检，并给出体检报告、分析指导以及修改建议，帮助开发者提升应用质量；稳定性测试部分列举的DevEco Testing工具，为开发者提供了应用稳定性基础检测能力，帮助开发者有效识别应用故障。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-runtime-detection
爬取时间: 2025-05-01 09:02:11
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-ram-detection
爬取时间: 2025-05-01 09:02:24
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-asan-detection
爬取时间: 2025-05-01 09:02:38
来源: Huawei Developer
为追求C/C++的高性能，编译器和OS（Windows/Linux/Mac）运行框架不会对内存操作进行安全检测。针对该场景，DevEco Studio集成ASan（Address-Sanitizer）为开发者提供面向C/C++的地址越界检测能力，并通过FaultLog展示错误的堆栈详情及导致错误的代码行。常见的Asan异常检测类型有：heap-buffer-overflow、stack-buffer-overflow/underflow、heap-use-after-free和double-free等，详情请参考ASan异常检测类型部分。
原理概述
Asan工具主要由插桩模块和动态运行库模块构成。
插桩模块主要使能为：
动态运行库主要使能为：
总结：Asan工具在编译时对代码进行插桩，在运行时关注相关内存的shadow memory值，从而判断是否有内存错误的产生。
使用约束
配置参数
ASAN_OPTIONS：在运行时配置ASan的行为，包括设置检测级别、输出格式、内存错误报告的详细程度等。常用参数请查看表1。
ASAN_OPTIONS支持在app.json5中配置，也支持在Run/Debug Configurations中配置。app.json5的优先级较高，即两种方式都配置后，以app.json5中的配置为准。
在app.json5中配置环境变量
打开AppScope > app.json5文件，添加配置示例如下。
配置Asan参数时，建议带上以下各项，并设置成默认值，然后按需进行修改。
在Run/Debug Configurations中配置环境变量
在Run/Debug Configurations中配置环境变量
具体请查看配置环境变量。
表1 常用参数
| 参数  | 默认值  | 是否必填  | 含义  |
| --- | --- | --- | --- |
| log_exe_name  | true  | 是  | 不可修改。指定内存错误日志中是否包含执行文件的名称。  |
| log_path  | /dev/asanlog/asan.log  | 否  | ROM版本小于NEXT.0.0.68时必填，值不可修改；NEXT.0.0.68及以上版本不再需要该参数。  |
| abort_on_error  | 0  | 是  | 指定在打印错误报告后调用abort()或_exit()。 false(1)：打印错误报后使用_exit()结束进程true(0)：打印错误报后使用abort()结束进程  |
| strip_path_prefix  | -  | 否  | 内存错误日志的文件路径中去除所配置的前缀。 如：/data/storage/el1  |
| detect_stack_use_after_return  | 0  | 否  | 指定是否检查访问指向已被释放的栈空间。 true(1)：检查。false(0)：不检查。  |
| halt_on_error  | 0  | 否  | 检测内存错误后是否继续运行。 0表示继续运行。1表示结束运行。  |
| malloc_context_size  | -  | 否  | 内存错误发生时，显示的调用栈层数。  |
| suppressions  | ""  | 否  | 屏蔽文件名。  |
| handle_segv  | -  | 否  | 检查段错误。  |
| handle_sigill  | -  | 否  | 检查SIGILL信号。  |
| quarantine_size_mb  | 256  | 否  | 指定检测访问指向已被释放的栈空间错误的隔离区大小。  |
参数
默认值
是否必填
含义
log_exe_name
true
是
不可修改。指定内存错误日志中是否包含执行文件的名称。
log_path
/dev/asanlog/asan.log
否
ROM版本小于NEXT.0.0.68时必填，值不可修改；NEXT.0.0.68及以上版本不再需要该参数。
abort_on_error
0
是
指定在打印错误报告后调用abort()或_exit()。
strip_path_prefix
-
否
内存错误日志的文件路径中去除所配置的前缀。
如：/data/storage/el1
detect_stack_use_after_return
0
否
指定是否检查访问指向已被释放的栈空间。
halt_on_error
0
否
检测内存错误后是否继续运行。
malloc_context_size
-
否
内存错误发生时，显示的调用栈层数。
suppressions
""
否
屏蔽文件名。
handle_segv
-
否
检查段错误。
handle_sigill
-
否
检查SIGILL信号。
quarantine_size_mb
256
否
指定检测访问指向已被释放的栈空间错误的隔离区大小。
更多可配置参数请参见asan_flags。
Asan使能
可通过以下两种方式使能ASan。每种方式分为DevEco Studio场景和流水线场景。
方式一
DevEco Studio场景
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151203.88152129136942373656567360692629:50001231000000:2800:50A15DA759901F5614F8EEC3D2920AC86A686DE1FDC829CC7CBBEFADD31E3910.png)
如果有引用本地library，需在library模块的build-profile.json5文件中，配置arguments字段值为“-DOHOS_ENABLE_ASAN=ON”，表示以ASan模式编译so文件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151203.83435826941907850681068304325768:50001231000000:2800:F509B65EB0CFFF810508B359ACAAC220F526837A0E874215ABCDA7579CDA3B25.png)
流水线场景
在hvigorw命令后加上ohos-debug-asan=true的选项，执行hvigorw命令，更多options参考hvigorw文档
同上，如果有引用本地library，需在library模块的build-profile.json5文件中，配置arguments字段值为“-DOHOS_ENABLE_ASAN=ON”，表示以ASan模式编译so文件。
方式二
DevEco Studio场景
1. 修改工程目录下AppScope/app.json5，添加ASan配置开关
```json
"asanEnabled": true
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151203.83387912826662910433106365047280:50001231000000:2800:AB93D0031CEF00078BDD2FE836CEE201BC4BE69F6B0E982F093C29A8D9C87B6F.png)
2. 设置模块级构建ASan插桩。
在需要使能ASan的模块中，通过添加构建参数开启ASan检测插桩，在对应模块的模块级build-profile.json5中添加命令参数：
```json
"asanEnabled": true
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151203.02859615110030251224422545278269:50001231000000:2800:B618CBB8377FAC46CDC14B278FBFD401D2D67C48F945F0FDC9B34C5EAD5A3C84.png)
该参数未配置不会报错，但是除包含malloc和free函数等少数内存错误外，出现其他需要插桩检测的内存错误时，ASan无法检测到错误。
流水线场景
在AppScope/app.json5和模块build-profile.json5配置对应asan项后，可直接执行hvigorw命令，更多options参考hvigorw文档
如果按方式一勾选以后，配置app.json5中的为false，Asan仍生效
运行ASan
1. 运行或调试当前应用。
2. 当程序出现内存错误时，弹出ASan log信息，点击信息中的链接即可跳转至引起内存错误的代码处（非release版本）。release版本本地无工程代码，可以使用AnalyzeStackTrace功能，提供要解析堆栈的so，解析结果为源码地址。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151204.24752455240539197459408914434747:50001231000000:2800:0E46B461824D42059DD837589EC9909A08BAD90A57C0A354D22FF92F080AE2E4.png)
ASan异常检测类型
当前提供案例在debug应用中可产生ASan，release应用因为在编译构建期间会进行代码优化，不一定会产生异常。
对于release版本，本地无工程代码，可以使用AnalyzeStackTrace功能，提供要解析堆栈的so，解析结果为源码地址。
| 常见Asan检测异常码  | 说明  | 可能的Crash信号  |
| --- | --- | --- |
| heap-buffer-overflow  | 超出堆上分配的缓冲区范围  | SIGSEGV（段错误）、SIGABRT（异常终止）、SIGILL（非法指令）、SIGFPE（浮点异常）、SIGTRAP（陷阱）  |
| stack-buffer-overflow/underflow  | 超出栈上分配的缓冲区范围  | SIGSEGV（段错误）、SIGABRT（异常终止）、SIGILL（非法指令）、SIGFPE（浮点异常）、SIGTRAP（陷阱）  |
| heap-use-after-free  | 使用了释放后的堆内存  | SIGSEGV（段错误）、SIGABRT（异常终止）  |
| stack-use-after-scope  | 栈变量在作用域外被使用  | SIGSEGV（段错误）、SIGABRT（异常终止）  |
| attempt-free-nonallocated-memory  | 尝试释放了非堆对象（non-heap object）或未分配内存  | SIGSEGV（段错误）、SIGABRT（异常终止）  |
| double-free  | 重复释放内存  | SIGSEGV（段错误）、SIGABRT（异常终止）  |
常见Asan检测异常码
说明
可能的Crash信号
heap-buffer-overflow
超出堆上分配的缓冲区范围
SIGSEGV（段错误）、SIGABRT（异常终止）、SIGILL（非法指令）、SIGFPE（浮点异常）、SIGTRAP（陷阱）
stack-buffer-overflow/underflow
超出栈上分配的缓冲区范围
SIGSEGV（段错误）、SIGABRT（异常终止）、SIGILL（非法指令）、SIGFPE（浮点异常）、SIGTRAP（陷阱）
heap-use-after-free
使用了释放后的堆内存
SIGSEGV（段错误）、SIGABRT（异常终止）
stack-use-after-scope
栈变量在作用域外被使用
SIGSEGV（段错误）、SIGABRT（异常终止）
attempt-free-nonallocated-memory
尝试释放了非堆对象（non-heap object）或未分配内存
SIGSEGV（段错误）、SIGABRT（异常终止）
double-free
重复释放内存
SIGSEGV（段错误）、SIGABRT（异常终止）
heap-buffer-overflow
背景
访问堆内存越界（上下界）
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启ASan检测后，触发demo中的函数，应用闪退报ASan，包含字段：AddressSanitizer:heap-buffer-overflow
定位思路
如果有工程代码，直接开启ASan检测，debug模式运行后复现该错误，可以触发ASan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
注意数组的长度，不要访问越界
推荐建议
已知大小的数组注意访问不要越界，访问已知大小数组前先判断访问位置是否落在边界外
stack-buffer-overflow
背景
访问越栈内存上界
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启ASan检测后，触发demo中的函数，应用闪退报ASan，包含字段：AddressSanitizer:stack-buffer-overflow
定位思路
如果有工程代码，直接开启ASan检测，debug模式运行后复现该错误，可以触发ASan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
访问索引不应大于上界。
推荐建议
访问索引不应大于上界。
stack-buffer-underflow
背景
访问越栈内存下界
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启ASan检测后，触发demo中的函数，应用闪退报ASan，包含字段：AddressSanitizer:stack-buffer-underflow
定位思路
如果有工程代码，直接开启ASan检测，debug模式运行后复现该错误，可以触发ASan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
访问索引不应小于下界。
推荐建议
访问索引不应小于下界。
heap-use-after-free
背景
当指针指向的内存被释放后，仍然通过该指针访问已经被释放的内存，就会触发heap-use-after-free。
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启ASan检测后，触发demo中的函数，应用闪退报ASan，显示reason为AddressSanitizer:heap-use-after-free
定位思路
如果有工程代码，直接开启ASan检测，debug模式运行后复现该错误，可以触发ASan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
已经释放的指针不要再使用，将指针设置为NULL/nullptr。
推荐建议
使用智能指针，或实现一个free()函数的替代版本或者 delete析构器来保证指针的重置。
stack-use-after-scope
背景
栈变量在作用域之外被使用。
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启ASan检测后，触发demo中的函数，应用闪退报ASan，包含字段：AddressSanitizer:stack-use-after-scope
定位思路
如果有工程代码，直接开启ASan检测，debug模式运行后复现该错误，可以触发ASan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
在作用域内使用该变量。
推荐建议
注意变量的作用域。
attempt-free-nonallocated-memory
背景
尝试释放了非堆对象（non-heap object）或未分配内存。
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启ASan检测后，触发demo中的函数，应用闪退报ASan，包含字段：
AddressSanitizer: attempting free on address which was not malloc()-ed
定位思路
如果有工程代码，直接开启ASan检测，debug模式运行后复现该错误，可以触发ASan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
不要对非堆对象或未分配的内存使用free()函数。
推荐建议
不要对非堆对象或未分配的内存使用free()函数。
double-free
背景
重复释放内存
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启ASan检测后，触发demo中的函数，应用闪退报ASan，包含字段：AddressSanitizer: attempting double-free
定位思路
如果有工程代码，直接开启ASan检测，debug模式运行后复现该错误，可以触发ASan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
已经释放一次的指针，不要再重复释放。
推荐建议
变量定义声明时初始化为NULL，释放内存后也应立即将变量重置为NULL，这样每次释放之前都可以通过判断变量是否为NULL来判断是否可以释放。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-hwasan-detection
爬取时间: 2025-05-01 09:02:51
来源: Huawei Developer
原理概述
HWASan是Hardware-Assisted Address Sanitizer的简称，它是Clang LLVM提供的一套内存错误检测系统，用来检测C/C++中常见的内存访问错误，相比之前的Asan（Address  Sanitizer），它在性能、内存上有不小提升，依赖于编译器的Address Tagging特性，该特性允许应用程序自定义数据存储到虚拟地址的最高8位，当CPU操作该虚拟地址时会自动忽略它。HWASan工具检测地址越界问题的原理如下，
注意，当分配的对象小于16字节时，多余的内存不会再分配给其它对象，此时shadow memory中保存的是对象所占内存的实际字节数，而tag值则保存在16字节的最后一个字节里面。
常见的HWASan异常检测类型有stack-buffer-overflow/underflow，stack-use-after-return，heap-buffer-overflow等，详见HWasan异常检测类型。
功能介绍
HWASan能检测到ASan所能检测到的同一系列错误：
和ASan相比，HWASan具有以下优点：
使用约束
配置HWASan
可通过方式一和方式二使能HWAsan，每种方式分为DevEco Studio场景和流水线场景。
方式一
DevEco Studio场景
点击Run > Edit Configurations >Diagnostics，勾选Hardware-Assisted Address Sanitizer开启检测。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151204.02007125400263945513866026707563:50001231000000:2800:24C817D10259E628BD65D3A79EC47EA38B67993E5CB2FA02712FDF0E050173F7.png)
流水线场景
1.
```json
"hwasanEnabled": true
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151204.72833228645317980488220270351583:50001231000000:2800:F1B7D4A1E5184DBB655F418FB3B48AD7853B014444A52E49EAE317F0A70D1221.png)
方式二
DevEco Studio场景
```json
"hwasanEnabled": true
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151204.78643507811425712096411338444125:50001231000000:2800:A70DBCAE6E47F281076847E5A13A5C5BE692847F8A685F58676A62779AB95E14.png)
2. 在需要使能HWASan的模块中，通过添加构建参数开启HWASan检测插桩，在对应模块的模块级build-profile.json5中添加命令参数：
```json
"arguments": "-DOHOS_ENABLE_HWASAN=ON"
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151204.29068241267255800380356560807874:50001231000000:2800:CD447D659485658CE9C9054D42CAC4434246EBABF2BA015B7A69F72C7F41F5BE.png)
流水线场景
在AppScope/app.json5和模块build-profile.json5配置对应HWASan项后，可直接执行hvigorw命令，更多options参考hvigorw文档
如果按方式一勾选以后，配置app.json5中的为false，HWASan仍生效
运行HWASan
2. 当程序出现内存错误时，弹出HWASan log信息，点击信息中的链接即可跳转至引起内存错误的代码处。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151204.66688171444033061866679839095130:50001231000000:2800:DB226C98681CB65C0C871BD8CB52E1D3BB9E9D80575862A2A2CC85E09E2705B3.png)
HWasan异常检测类型
stack tag-mismatch
背景
"stack tag-mismatch"在HWASan中指的是栈内存标签不匹配错误。这种错误通常发生在访问栈内存时，指针携带的标签与栈内存中存储的标签不一致，触发其异常检测码字的异常类型有：stack-buffer-overflow/underflow、stack-use-after-return。
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启ASan检测后，触发demo中的函数，应用闪退报HWASAN，包含字段：
HWAddressSanitizer: tag-mismatch on address
Cause: stack tag-mismatch
定位思路
如果有工程代码，直接开启HWAsan检测，debug模式运行后复现该错误，可以触发WAsan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
stack-buffer-overflow/underflow：访问索引要落在给定的范围内
stack-use-after-return：在作用域内使用局部变量
推荐建议
stack-buffer-overflow/underflow：访问索引不要超过给定的上界/下界
stack-use-after-return:  如果需要在函数返回后继续使用某些数据，考虑将它们存储在静态或全局变量中
heap-buffer-overflow
背景
访问堆内存越界（上下界），触发其异常检测码字的异常类型有：heap-buffer-overflow、heap-buffer-underflow
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启HWASan检测后，触发demo中的函数，应用闪退报HWASan，包含字段：
HWAddressSanitizer: tag-mismatch
Cause: heap-buffer-overflow
定位思路
如果有工程代码，直接开启HWASan检测，debug模式运行后复现该错误，可以触发HWASan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
注意数组长度，不能越界
heap-buffer-overflow: 数组访问位置不要越上界
heap-buffer-underflow: 访问数组位置不要越下界
推荐建议
已知大小的数组注意访问不要越界，访问已知大小数组前先判断访问位置是否落在边界外
Use-after-free
背景
触发其异常检测码字的异常类型有：heap-use-after-free、double-free
heap-use-after-free: 当指针指向的内存被释放后，仍然通过该指针访问已经被释放的内存，就会触发heap-use-after-free
double-free: 重复释放内存
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启HWAsan检测后，触发demo中的函数，应用闪退报HWAsan，包含字段：
HWAddressSanitizer: tag-mismatch
Cause: use-after-free
定位思路
如果有工程代码，直接开启ASan检测，debug模式运行后复现该错误，可以触发ASan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
heap-use-after-free: 已经释放的指针不要再使用，将指针设置为NULL/nullptr。
double-free:已经释放一次的指针，不要再重复释放。
推荐建议
heap-use-after-free: 使用智能指针，或实现一个free()函数的替代版本或者 delete析构器来保证指针的重置。
double-free: 变量定义声明时初始化为NULL，释放内存后也应立即将变量重置为NULL，这样每次释放之前都可以通过判断变量是否为NULL来判断是否可以释放。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-gwpasan-detection
爬取时间: 2025-05-01 09:03:04
来源: Huawei Developer
当前在系统上定位内存的一些非法行为的时候，可以开启Asan版本来定位此类问题，但鉴于Asan开启会对性能和内存有很大的影响，所以Asan的能力不能部署到正式生产环境中，GWP-Asan可以帮助开发者在性能影响很小的情况下检查到部分内存使用的非法行为，正是因为性能影响较小，GWP-Asan会被部署到正式环境中，避免了正式环境中出现内存问题时再去使用Asan版本做二次复现。
原理概述
GWP-Asan 具有一种内存分配器功能，可帮助查找释放后使用和堆缓冲区溢出 bug，启用后，GWP-Asan 会拦截随机选择的堆分配子集，并将其放入特殊区域，以便捕获难以检测到的堆内存损坏错误。只要用户足够多，即使在低采样率的情况下，也可以发现常规测试未能发现的堆内存安全错误。常见的GWP-Asan异常检测类型有：double free，user_after_free，invalid free left等，详见GWPAsan异常检测类型部分。
使用约束
ASan、TSan、UBSan、HWASan、GWP-Asan不能同时开启，五个只能开启其中一个。
GWP-Asan使能
在app.json5中
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151204.82671399772694895692311681585205:50001231000000:2800:7516213D41FB7935E009889132DD7F463F26705AC2E8A35CB5E4A8B9ACF145FF.png)
Gwp-Asan异常检测类型
下面给出异常检测码和相关faultlog
double free
```shell
*** GWP-ASan detected a memory error ***
Double Free at 0x7f9c31efe0 (a 20-byte allocation) by thread 11725 here:
#0 0x7f9c548958 (/lib/ld-musl-aarch64.so.1+0x1ea958)
#1 0x7f9c548730 (/lib/ld-musl-aarch64.so.1+0x1ea730)
#2 0x7f9c4810f4 (/lib/ld-musl-aarch64.so.1+0x1230f4)
#3 0x7f9c4018d8 (/lib/ld-musl-aarch64.so.1+0xa38d8)
#4 0x7f9c547944 (/lib/ld-musl-aarch64.so.1+0x1e9944)
#5 0x7f9c418c64 (/lib/ld-musl-aarch64.so.1+0xbac64)
#6 0x555dab4f24 (/data/local/tmp/double_free+0x1f24)
#7 0x7f9c4c1668 (/lib/ld-musl-aarch64.so.1+0x163668)
#8 0x555dab4c14 (/data/local/tmp/double_free+0x1c14)
0x7f9c31efe0 was deallocated by thread 11725 here:
#0 0x7f9c5480f8 (/lib/ld-musl-aarch64.so.1+0x1ea0f8)
#1 0x7f9c54799c (/lib/ld-musl-aarch64.so.1+0x1e999c)
#2 0x7f9c418c64 (/lib/ld-musl-aarch64.so.1+0xbac64)
#3 0x555dab4f1c (/data/local/tmp/double_free+0x1f1c)
#4 0x7f9c4c1668 (/lib/ld-musl-aarch64.so.1+0x163668)
#5 0x555dab4c14 (/data/local/tmp/double_free+0x1c14)
0x7f9c31efe0 was allocated by thread 11725 here:
#0 0x7f9c5480f8 (/lib/ld-musl-aarch64.so.1+0x1ea0f8)
#1 0x7f9c547780 (/lib/ld-musl-aarch64.so.1+0x1e9780)
#2 0x7f9c41882c (/lib/ld-musl-aarch64.so.1+0xba82c)
#3 0x555dab4f10 (/data/local/tmp/double_free+0x1f10)
#4 0x7f9c4c1668 (/lib/ld-musl-aarch64.so.1+0x163668)
#5 0x555dab4c14 (/data/local/tmp/double_free+0x1c14)
*** End GWP-ASan report ***
```
use_after_free
```shell
*** GWP-ASan detected a memory error ***
Use After Free at 0x7fa2ab6000 (0 bytes into a 10-byte allocation at 0x7fa2ab6000) by thread 3594 here:
#0 0x7fa4781f18 (/lib/ld-musl-aarch64.so.1+0x1e9f18)
#1 0x7fa4781cf0 (/lib/ld-musl-aarch64.so.1+0x1e9cf0)
#2 0x7fa46ba6bc (/lib/ld-musl-aarch64.so.1+0x1226bc)
#3 0x7fa463b298 (/lib/ld-musl-aarch64.so.1+0xa3298)
#4 0x5562e886ac (/data/local/tmp/gwp_asan_use_after_free_test+0x16ac)
#5 0x7fa46fac28 (/lib/ld-musl-aarch64.so.1+0x162c28)
#6 0x5562e88654 (/data/local/tmp/gwp_asan_use_after_free_test+0x1654)
0x7fa2ab6000 was deallocated by thread 3594 here:
#0 0x7fa47816b8 (/lib/ld-musl-aarch64.so.1+0x1e96b8)
#1 0x7fa4780f5c (/lib/ld-musl-aarch64.so.1+0x1e8f5c)
#2 0x7fa46522cc (/lib/ld-musl-aarch64.so.1+0xba2cc)
#3 0x5562e886ac (/data/local/tmp/gwp_asan_use_after_free_test+0x16ac)
#4 0x7fa46fac28 (/lib/ld-musl-aarch64.so.1+0x162c28)
#5 0x5562e88654 (/data/local/tmp/gwp_asan_use_after_free_test+0x1654)
0x7fa2ab6000 was allocated by thread 3594 here:
#0 0x7fa47816b8 (/lib/ld-musl-aarch64.so.1+0x1e96b8)
#1 0x7fa4780d40 (/lib/ld-musl-aarch64.so.1+0x1e8d40)
#2 0x7fa4652010 (/lib/ld-musl-aarch64.so.1+0xba010)
#3 0x5562e886a4 (/data/local/tmp/gwp_asan_use_after_free_test+0x16a4)
#4 0x7fa46fac28 (/lib/ld-musl-aarch64.so.1+0x162c28)
#5 0x5562e88654 (/data/local/tmp/gwp_asan_use_after_free_test+0x1654)
*** End GWP-ASan report ***
```
invalid free left
```shell
*** GWP-ASan detected a memory error ***
Invalid (Wild) Free at 0x7f8551ffff (1 byte to the left of a 1-byte allocation at 0x7f85520000) by thread 11708 here:
#0 0x7f856746b8 (/lib/ld-musl-aarch64.so.1+0x1286b8)
#1 0x7f85674268 (/lib/ld-musl-aarch64.so.1+0x128268)
#2 0x7f856cfbc0 (/lib/ld-musl-aarch64.so.1+0x183bc0)
#3 0x7f855ea1b4 (/lib/ld-musl-aarch64.so.1+0x9e1b4)
#4 0x7f8567349c (/lib/ld-musl-aarch64.so.1+0x12749c)
#5 0x556c5c67a8 (/data/local/tmp/gwp_asan_invalid_free_left_test+0x17a8)
#6 0x7f855ecd74 (/lib/ld-musl-aarch64.so.1+0xa0d74)
#7 0x556c5c6754 (/data/local/tmp/gwp_asan_invalid_free_left_test+0x1754)
0x7f8551ffff was allocated by thread 11708 here:
#0 0x7f85673f20 (/lib/ld-musl-aarch64.so.1+0x127f20)
#1 0x7f85673298 (/lib/ld-musl-aarch64.so.1+0x127298)
#2 0x7f856891b4 (/lib/ld-musl-aarch64.so.1+0x13d1b4)
#3 0x556c5c67a0 (/data/local/tmp/gwp_asan_invalid_free_left_test+0x17a0)
#4 0x7f855ecd74 (/lib/ld-musl-aarch64.so.1+0xa0d74)
#5 0x556c5c6754 (/data/local/tmp/gwp_asan_invalid_free_left_test+0x1754)
*** End GWP-ASan report ***
```
invalid free right
```shell
*** GWP-ASan detected a memory error ***
Invalid (Wild) Free at 0x7fa4e96ff1 (1 byte to the right of a 1-byte allocation at 0x7fa4e96ff0) by thread 11852 here:
#0 0x7fa4fec6b8 (/lib/ld-musl-aarch64.so.1+0x1286b8)
#1 0x7fa4fec268 (/lib/ld-musl-aarch64.so.1+0x128268)
#2 0x7fa5047bc0 (/lib/ld-musl-aarch64.so.1+0x183bc0)
#3 0x7fa4f621b4 (/lib/ld-musl-aarch64.so.1+0x9e1b4)
#4 0x7fa4feb49c (/lib/ld-musl-aarch64.so.1+0x12749c)
#5 0x55625737a8 (/data/local/tmp/gwp_asan_invalid_free_right_test+0x17a8)
#6 0x7fa4f64d74 (/lib/ld-musl-aarch64.so.1+0xa0d74)
#7 0x5562573754 (/data/local/tmp/gwp_asan_invalid_free_right_test+0x1754)
0x7fa4e96ff1 was allocated by thread 11852 here:
#0 0x7fa4febf20 (/lib/ld-musl-aarch64.so.1+0x127f20)
#1 0x7fa4feb298 (/lib/ld-musl-aarch64.so.1+0x127298)
#2 0x7fa50011b4 (/lib/ld-musl-aarch64.so.1+0x13d1b4)
#3 0x55625737a0 (/data/local/tmp/gwp_asan_invalid_free_right_test+0x17a0)
#4 0x7fa4f64d74 (/lib/ld-musl-aarch64.so.1+0xa0d74)
#5 0x5562573754 (/data/local/tmp/gwp_asan_invalid_free_right_test+0x1754)
*** End GWP-ASan report ***
```
Buffer Underflow
```shell
*** GWP-ASan detected a memory error ***
Buffer Underflow at 0x7f8db1aff1 (4063 bytes to the left of a 48-byte allocation at 0x7f8db1bfd0) by thread 12086 here:
#0 0x7f8dc716b8 (/lib/ld-musl-aarch64.so.1+0x1286b8)
#1 0x7f8dc71268 (/lib/ld-musl-aarch64.so.1+0x128268)
#2 0x7f8dcccbc0 (/lib/ld-musl-aarch64.so.1+0x183bc0)
#3 0x7f8dbe71b4 (/lib/ld-musl-aarch64.so.1+0x9e1b4)
#4 0x55801287f8 (/data/local/tmp/gwp_asan_buffer_overflow_test+0x17f8)
#5 0x7f8dbe9d74 (/lib/ld-musl-aarch64.so.1+0xa0d74)
#6 0x558012879c (/data/local/tmp/gwp_asan_buffer_overflow_test+0x179c)
0x7f8db1aff1 was allocated by thread 12086 here:
#0 0x7f8dc70f20 (/lib/ld-musl-aarch64.so.1+0x127f20)
#1 0x7f8dc70298 (/lib/ld-musl-aarch64.so.1+0x127298)
#2 0x7f8dc861b4 (/lib/ld-musl-aarch64.so.1+0x13d1b4)
#3 0x7f8d4ef4fc (/system/lib64/libc++.so+0xaf4fc)
#4 0x7f8da76818 (/system/lib64/chipset-pub-sdk/libhilog.so+0x36818)
#5 0x7f8da76af8 (/system/lib64/chipset-pub-sdk/libhilog.so+0x36af8)
#6 0x7f8da6f228 (/system/lib64/chipset-pub-sdk/libhilog.so+0x2f228)
#7 0x7f8dbd4d18 (/lib/ld-musl-aarch64.so.1+0x8bd18)
#8 0x7f8dbd8cc4 (/lib/ld-musl-aarch64.so.1+0x8fcc4)
#9 0x7f8dd00370 (/lib/ld-musl-aarch64.so.1+0x1b7370)
#10 0x7f8dbd4d18 (/lib/ld-musl-aarch64.so.1+0x8bd18)
#11 0x7f8dbd4b28 (/lib/ld-musl-aarch64.so.1+0x8bb28)
#12 0x7f8dbe9d58 (/lib/ld-musl-aarch64.so.1+0xa0d58)
#13 0x558012879c (/data/local/tmp/gwp_asan_buffer_overflow_test+0x179c)
*** End GWP-ASan report ***
```

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-memory-leak-detection
爬取时间: 2025-05-01 09:03:18
来源: Huawei Developer
使用Snapshot检测内存泄漏
查看快照详情
1. 创建Snapshot场景调优分析任务，操作方法可参考性能问题定位：深度录制。
2. 设置Snapshot泳道。
单击任务左上角的进行泳道的新增和删除，再次单击此按钮可关闭设置并生效。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151204.50715998781926786113933937614709:50001231000000:2800:49A00133762EED62203E538C55F175F7C526B87211F1F41CFA44E7CB822B7058.png)
3. 开始录制后可观察Memory泳道的内存使用情况，在需要定位的时刻单击任务左上角的启动一次快照。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151204.68475616453148782724993103905878:50001231000000:2800:DBFA79F9A6F74B6D27031285C5C11DF215B7FB1B5A4314B7CA1452541E9D7528.png)
“ArkTS Snapshot”泳道的紫色区块表示一次快照完成。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151204.80793417369186930209282936756071:50001231000000:2800:B79B7D600360274F62A900DD351EB14428F1D1791C12294CEE314D98C124EFCC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151205.00403609031585133899062499660649:50001231000000:2800:F4A41ED61609F3689C74448606C317716FD0FD99FEB0D9C79CD60D48BF1D8453.png)
在“Statistics”页签中显示当前快照的详细信息：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151205.17954122695148580731372470658942:50001231000000:2800:ACF00808250EFD137E81D283E13E4D8B46B1BE3E7628D520B65A19B04B425D83.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151205.90135512694209066256609188055565:50001231000000:2800:C5A6101360DBA4CCD141F16F8C837FC3ECC829240DCF02C463B5E329AFEE535B.png)
节点属性与引用链
在“Snapshot”的“Statistics”页签和“Comparison”页签中，所有实例对象节点展开后会显示"<fields>"以及"<references>"，这两项节点分别代表该实例对象的属性以及该实例对象的引用链信息。
在“Snapshot”的More区域则展示“Fields”和“References”两个页签，分别代表Detail区域所选择对象的属性以及引用链信息，方便快捷查看所选中对象的属性等详细信息，而不需要跳转至对应对象。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151205.61523205590426152762345977057332:50001231000000:2800:D7AF12FAEB4753C136B299FCB1A582542A56F91EA0B113136A6DBFD66C6C9487.png)
节点跳转
在“Snapshot”的“Comparison”页签中，查看内存对象、对象属性及其引用链时，若要查看某一对象的详细信息，可以单击该对象所在行行尾的跳转图标跳转至该对象所在的“Statistics”页签并定位至该对象所在的位置，以查看该对象的详细信息。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151205.39002160975399102324628346368103:50001231000000:2800:D4FC9435EEB5E97FEFAA0F612D5AE4D2104B3FFA69C08EFCA3A01FF247704350.png)
历史节点前进/后退
当在“Comparison”和“Statistics”之间进行节点跳转后，单击详情区域左下角的左右箭头可以前进或者后退至下一个或上一个历史节点，以便快速在多个历史节点之间跳转查看。当箭头为激活状态时，表示前进/后退功能可用，当箭头为灰色状态时则代表无法使用该功能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151205.69181044159941485461958755900196:50001231000000:2800:8224021AA0DD454C950A3A735C2E2157E26FA4A25C97523D8C9BA42AEEF6D829.png)
比较快照差异
在“Snapshot”的“Comparison”页签中，以当前选择的快照为base，下拉框选择的快照为Target，即可得到两次快照信息的比较结果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151205.67898070196898691897360652256724:50001231000000:2800:EF67F6A5584FA0BFD6D47018027CE5EEF8217D215FF598B642A9CD29AC4AC95F.png)
在“Snapshot”的“Comparison”页签中，可进行两次快照的差异比较，比较内容包括新增数、删除数、个数增量、分配大小、释放大小、大小增量等等。通过不断对比，可快速分析和定位内存问题的具体位置。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151205.44230891861779135620258742778591:50001231000000:2800:D48E12E133C7D38C705CDA4F3579BD88F197782695A25687D7578282A22050F7.png)
Heap Snapshot离线导入
DevEco Profiler提供Heap Snapshot离线导入能力，可导入一个或多个.heapsnapshot文件。
您可以在DevEco Profiler主界面的“Create Session”区域中，单击“Open File”，导入.heapsnapshot文件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151205.45752168653719447237525569838171:50001231000000:2800:EC70A8724BC809ABAE543EE75E7A54C7EFC97BC24EBB669BC170008A2B70441F.png)
可以导入与heapsnapshot文件匹配的.jsleaklist文件，展示jsleakwatcher监控采集到的内存泄漏对象。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151205.88486724928354070189091053102968:50001231000000:2800:394D864854E23E37FA8C6A15570658F6A89D681F375EFB0793C730CBC58E9862.png)
ArkTS内存泄漏分析
分析步骤
分析内存泄漏问题步骤如下：
录制Snapshot模板数据
1. 连接好设备后启动应用，点击应用选择框(下图中①处)选择需要录制的应用，选择Snapshot模板(下图中②处)，点击Create Session或双击Snapshot图标即可创建一个Snapshot的录制模板。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151205.93385381627922145152712775593731:50001231000000:2800:26AC6AA34A4E10AEB4E58828EAE559024CD4A0978D43918A093502166FA9A9EE.png)
2. 创建好模板后，点击三角按钮即开始录制。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151205.66089054085756091923424345270157:50001231000000:2800:195A4CF73A23281D34C8B7455772061620948D8F2B9A59FEBAB4C60CCC7DEE5E.png)
3. 待右侧泳道全部显示recording后则表明正在录制中，此时点击下图中方块按钮或者左侧暂停按钮都可结束录制。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151205.67184713118574579236968196680110:50001231000000:2800:1E8D816E2810D30E86D83976241150DA00635DFF9A51787B843587E2D42333FB.png)
4. 拍摄快照：开始录制后，待右侧泳道全部显示recording后点击图中①处拍摄按钮，待②处显示出紫色条块表示快照拍摄完成。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.52330321631584645661637926638631:50001231000000:2800:38600AEF26E8E3D1185778AAA214524D000A3AC6FB664A36087783B51ACC3545.png)
5. 录制完成后可点击下图①处按钮将录制文件导出，而点击下图②处的按钮即可导入之前录制好的导出件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.26405397748417200799072986081365:50001231000000:2800:5A1516D0354EE81D954205B3286ED5880496ED062A11B8A04CB7F645AF30F063.png)
分析Snapshot数据
常见虚拟机内存对象介绍
JSObject
JSObject展开后为内部的各个属性如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.14744286875531071485632987717195:50001231000000:2800:601A1774125CA5C63A01CBB15CD5027BD3656F31FF5A3107EBD27C31F0E509BE.png)
以下通过具体代码来介绍下实例化对象、声明对象、构造函数间的关系：
```typescript
class People {
old: number
name: string
constructor(old: number, name: string) {
this.old = old;
this.name = name;
}
printOld() {
console.log("old = ", this.old);
}
printName() {
console.log("name = ", this.name);
}
};
let p = new People(20, "Tom");
```
采集到的snapshot数据如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.22035807433641776169602710248462:50001231000000:2800:C44CD67652B9DA6F9902A3BD1DFBD57D1617E729D14DD44F8F5E7C4DBE183EEE.png)
92729对象对应的是People，其主要声明了对象的属性和方法。
实例化对象的_proto_属性指向声明时的对象，声明对象里则会有constructor()构造函数。当实例化多个对象时，实例化对象会有多个，但是声明对象和构造函数只有一个。
JSFunction
目前所有JSFunction都在(closure)标签中，展开即可看到所有JSFunction：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.10151897499646135862963607532940:50001231000000:2800:087F1B47B5FEB6F0ED1C4771DE0E19279A3ACC3B12E98C2F0FD377096A30FAEC.png)
每个函数展开后为函数内的各个属性：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.62308037729000257274627569558429:50001231000000:2800:B236B8DA756429F1F227947B188086C2CC28C73F29ED5EBD4467C8E013E107E0.png)
其中HomeObject表示父类对象，即该方法属于哪个对象；_proto_表示原型对象；LexicalEnv表示该函数的闭包上下文；name是内置属性访问器，可获取函数名；FunctionExtraInfo表示额外信息，比如一些napi接口会在这里记录函数地址；ProtoOrHClass表示原型或者隐藏类。
如果函数显示为anonymous()，则表示为匿名函数；如果函数显示为JSFunction()，则表示该函数可能为框架层函数，创建函数的时候未设置函数名。对于这两种函数名不可见的情况，可以通过查看其引用来间接确认其名称：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.04263459106062971998850050704468:50001231000000:2800:1B52D202045A778B37B4B8E798ABA715B1129EA84CB5BA99B4CC44F4EDF7746A.png)
LexicalEnv
闭包变量上下文；闭包是一个链状结构，如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.91025027991186372291272268969283:50001231000000:2800:BC4A6CDA77B681E8109DE39636EFF535D0C25A79EDCC26ECFD3F9B925090F462.png)
733这个节点本身是一个闭包数组，其中0号元素是调用者（或者再往上的调用者，以此类推）的闭包；1号元素存储的是调试信息；2号及以后的元素存储的就是闭包传递的变量，上例传递了一个变量。
InternalAccessor
内置属性访问器，会有getter和setter方法，通过getter、setter可以获取、设置该属性。
分析方法
查看对象名称
对于声明对象，可以通过constructor属性来确定对象名称。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.97089604846368782183517386347952:50001231000000:2800:8B5F0B09B0B13D727101DE66EEDE6CB7DA7B6839670B567753EF6A2FEDA53802.png)
对于实例化对象，一般没有constructor，则需要展开_proto_属性后查找constructor；
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.59469619669027533431136577764801:50001231000000:2800:0B9450F77FF7463312A448E026C038282A38AD4C304D169B8F13872C58544209.png)
若对象里有一些标志性属性，可以通过在代码里搜索属性名称来找到具体是哪个对象。
如果对象间有继承关系，则可以继续展开_proto_：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.69228339066150037837107799916760:50001231000000:2800:8701779ED9F56E71649E3F750FDE241B9B798972BEE9EA2CA4186F6A29BD1F1A.png)
如上图则表明Man对象继承自People对象。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-base-memory-detection
爬取时间: 2025-05-01 09:03:31
来源: Huawei Developer
内存分析及优化
应用在开发过程中，可能会因为API使用错误、变量未及时释放、异常频繁创建/释放内存等情况引发各种内存问题。
DevEco Profiler提供了基础的内存场景分析Allocation，您可以使用Allocation来分析应用或元服务在运行时的内存分配及使用情况，识别和定位内存泄漏、内存抖动以及内存溢出等问题，对应用或元服务的内存使用进行优化。
在设备连接完成后，可按照如下方法查看内存分析结果：
1.请参考模块级build-profile.json5文件，增加strip字段并赋值为false（false值表示附带调试和符号信息，待发布上线版本建议恢复为true）。采集函数栈解析符号需要附带符号表信息，无符号表信息可能采集不到函数名称，因此请录制模板前按照下图进行配置。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.41891771751768186070043623178618:50001231000000:2800:CB214467EEC66BA329BFCA50FEA26C7857CCAABFA45E702840758011D6B7CC4A.png)
2. 创建Allocation分析任务并录制相关数据，操作方法可参考性能问题定位：深度录制，或在会话区选择Open File，导入历史数据。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.91574049600815837585057231951557:50001231000000:2800:7F0D17A1B75810F3AFAE43184DAA16979E51376DFCD5432E7051B86E5D7794AF.png)
Allocation分析任务支持在录制前单击指定要录制的泳道：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.79343036318546641575288768961002:50001231000000:2800:14A9958C6B867896DA6F44F351D687393FF88CAA32C615F0FF82C224F842DC6D.png)
PSS：进程独占内存和按比例分配共享库占用内存之和。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.77379545077045154482425900482539:50001231000000:2800:CCAF7F9651E9E9F4672BCA31F610D7F36FF189A4E9FD1459C7ECEB9511587F29.png)
RSS：进程独占内存和相关共享库占用内存之和。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151206.02811741679670448776331388068829:50001231000000:2800:99D703F1A607180997E2F31D5007D06DC2850A6220FF864AC13014941B14CE3A.png)
USS：进程独占内存。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151207.79768049218532744248766257802769:50001231000000:2800:1D9AA245014795FF87A07981BEE36D86D1133FAAF2AC8D1595F497E954510070.png)
默认只显示PSS的统计图，如需要查看USS或RSS，需要在Memory泳道的右上角点选相关数据类型。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151207.29319295941880047338590785205228:50001231000000:2800:177EF37C9D6F2F7A12F45397891D25854CF842FCFACE4D70967F46662007B2C8.png)
展开Memory泳道，子泳道展示的是按照内存类型将进程PSS值拆分开的各个维度的内存信息，类型包含ArkTS Heap/Native Heap/GL/Graph/Guard/AnonPage Other/FilePage Other/Dev/Stack/.hap/.so/.ttf。默认展示其中的五个子泳道，如要显示其他子泳道，可以点击主泳道的options标签并勾选其他泳道来查看。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151207.12540798035576546723910856917639:50001231000000:2800:A1B1CB89198368752A473F79522D1C7B199CC46C1F3CE358E9A88B462DAF5426.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151207.59266524045873256873950826217458:50001231000000:2800:6C4BB4F115F98E83E558A09D93EDDDE7A664E5750687CA729B494D2EB0702F1A.png)
由于较大的性能开销可能导致卡顿/卡死问题，当前版本仅支持分开录制ArkTS Allocation和Native Allocation两条泳道。
单击工具控制栏中的按钮，可以设置是否为统计模式、统计间隔、最小跟踪内存、回栈模式、JS回栈、JS回栈深度和Native回栈深度。默认采用统计模式，统计间隔只在统计模式下才需要设置，可设置范围为1s~3600s，默认为10s，默认最小跟踪内存为1024Bytes。FP回栈模式下需要设置JS回栈深度和Native回栈深度，DWARF回栈模式下仅需要设置回栈深度。默认Native回栈深度为10层，JS回栈深度可配置范围为0-128，默认10层。设置完成后，在录制期间小于此大小的内存分配将被忽略，最大回栈深度将达到设置的值。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151207.12796441171000371074572910918472:50001231000000:2800:1989CF30BBBFEF909B7F1FB5E81418B2DF801094B923EF88197B02D73D65C480.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151207.98400323966594431879946979447121:50001231000000:2800:3B20AF1FEFC60F0B538F8D8AB3F86EDEA5E26B6E4A1867EFAC223EA6453CEE59.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151207.97384666808401525444668806695249:50001231000000:2800:BD7B8942E8BB769ECCE81112B4277E1D862D3AA71109B8C96C37E4EB73E680CC.png)
3. 在目标泳道上长按鼠标左键并拖拽，框选要展示分析的时间段。
Details区域中显示此时间段内指定类型的内存分析统计信息：
Memory泳道：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151207.92982162678717052573640112269314:50001231000000:2800:57649FB735F777DEB70EB2ED3007B2D1F3FEBDC890CD213F9453EAD40CE9AFEE.png)
Graph字段统计方式为：计算/proc/process_dmabuf_info节点下该进程使用的内存大小。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151207.77821916894847607174636140369137:50001231000000:2800:AA14D7CD9E621385ECB7BDCA053D86D2BBCB682C914021CF7DD124531C458CAF.png)
“Details”区域中带标识的对象，表示其可以通过窗口访问。每个时段内已释放的内存大小在柱子上置灰，未释放的内存保持绿色。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151207.13250024372180692659150758222704:50001231000000:2800:83B224F1BFCA789A9E38F180744230C31DE68433FA9D2CBBB893DFED343BCC09.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151207.74114430221471913059822866217148:50001231000000:2800:16AD6C89984DE183FFA3890F1ACD1776CB43213E4348CF59A29E6F5BD7F913FD.png)
Native Allocation泳道：框选子泳道后显示具体的内存分配，包括静态统计数据、分配栈等。
-  点击任意对象上的跳转按钮，可跳转至此类对象的详细占用/分配信息。当前统计模式下不支持跳转。
统计模式（Statistics Mode）下不存在Allocations List信息。
选择任一对象，右侧会展示与该对象相关的所有库和调用者
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.72620147031022855522917456065877:50001231000000:2800:5E3742E39DA94301BEDFA8EC8E79EDEC1058D1BCD9AEEAF5E78CE1C679321902.png)
4.（可选）根据分析结果，双击可能存在问题的调用栈，跳转至相关代码。开发者可根据实际需要进行优化。
当前版本仅支持Debug应用跳转到用户侧Native代码。
分析数据筛选
Allocation分析过程中提供多种数据筛选方式，方便开发者缩小分析范围，更精确地定位问题所在。
通过内存状态筛选
在Allocation分析过程中，对“Native Allocation”泳道的内存状态信息进行过滤，便于开发者定位内存问题。
在“Native Allocation”泳道的“Detail”区域左下方的下拉框中，可以选择过滤内存状态：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.77520246156376742068108403801596:50001231000000:2800:D7A8D883322DD0E3DF596D50840ECAED163819D3CFE1212D86E734BE2CCC46CC.png)
通过统计方式筛选
在“Native Allocation”泳道的“Statistics”页签中，可以打开“Native Size”选择统计方式以过滤统计数据：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.47925977673305509228496565209604:50001231000000:2800:A56005BB305C152B1DAD8196BE07A7334A2F5C7136774206192C7A70E21A6B06.png)
通过so库名筛选
在“Native Allocation”泳道的“Allocations List”页签中，可以单击“Click to choose”选择要筛选的so库以过滤出与目标so库相关的数据：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.93922916279148800680052053028392:50001231000000:2800:EC66A6704B83F31A81888554D2362EF8C3660D83ECA38AD65522BC495928E345.png)
通过搜索筛选
在Native Allocation泳道的页签中， 根据界面提示信息输入需要搜索的项目，可定位到相关内容位置，使用搜索框的<、>按键可依次显示搜索结果的详细内容。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.85758353798453928328564549860966:50001231000000:2800:E7D92534AC1CD541580C0AE2CACAAC90005C2CCBEC867F25AFCC1A8204AC930B.png)
筛选内存分配堆栈
在Native Allocation泳道的Call Trees页签中，可以通过底部的“Call Trees”和“Constraints”选择框来过筛选和过滤内存分配栈。
Call Trees选择框包含两种过滤条件：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.35395540824819254760850051668366:50001231000000:2800:10C658CE1CDBB7E68FE2D4B8D028547F52FA4B6963887C0B9CC1803C2B84C706.png)
Constraints选择框也包含了两种过滤条件：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.46184194403246963746556336169570:50001231000000:2800:4F2023D9B762817496002B44AB80F148D88759DFAB68A893B600C4565EFB448C.png)
在Call Trees页签的More区域，单击“Heaviest Stack”旁的隐藏按钮可以单独控制是否显示More区域最大内存分配栈中的系统堆栈。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.61130308128772986570585768174875:50001231000000:2800:58CE79760369D6960841687128530A13FC0E6C58D5CAC8F68C0D545D8476BB95.png)
在Call Trees页签，可以通过底部的“Flame Chart”切换到火焰图视图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.94648576640854431088729058846375:50001231000000:2800:3812A56E00EC4696FF3C73D6D0BD65C9B7BDB7D738E3C2DD3E573717132F0C2E.png)
分析启动内存
应用/元服务在启动过程中对内存资源的占用情况，是开发者较为关心的问题。DevEco Profiler的Allocation分析任务，提供了启动内存分析能力，协助开发者优化启动过程的内存占用。
具体操作方法为：在任务列表中单击Allocation任务后的按钮
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.81101650392866466043581503676619:50001231000000:2800:1FCB3979639F16D6FB518780A7E8787B7EC70D7238E3AF3F1FF22902E5E96B6E.png)
在分析结束后，呈现出的数据类型以及相应的处理方法，与非启动过程的分析相同。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-thread-detection
爬取时间: 2025-05-01 09:03:44
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-tsan-detection
爬取时间: 2025-05-01 09:03:57
来源: Huawei Developer
原理概述
TSan（ThreadSanitizer）是一个检测数据竞争的工具。它包含一个编译器插桩模块和一个运行时库。TSan开启后，会使性能降低5到15倍，同时使内存占用率提高5到10倍。
Tsan使能分为两个阶段，Tsan Instrumentation阶段完成对用户代码的插装，Tsan Runtime阶段负责对竞争情况做判断，然后输出对应的报告。
功能介绍
应用场景
TSan能够检测出如下问题：
常见TSan异常检测类型有data race，heap-use-after-free，signal handler spoils errno等，详见Tsan异常检测类型部分。
错误报告
当 TSan 检测到错误时，它会生成详细的报告，包括：
使用约束
使能Tsan
可通过以下两种方式使能TSan。每种方式分为DevEco Studio场景和流水线场景。
方式一
DevEco Studio场景
1. 点击Run > Edit Configurations >Diagnostics，勾选Thread Sanitizer。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.69431645700131111129834352883845:50001231000000:2800:09C62AC42EAD32806EC59E60F8A66C72D99289B0E17B7B166924A9989779080E.png)
2. 如果有引用本地library，需在library模块的build-profile.json5文件中，配置arguments字段值为“-DOHOS_ENABLE_TSAN=ON”，表示以TSan模式编译so文件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.85664309864976778979535877399395:50001231000000:2800:1DA4CA05CEE38BB57EB13FE41A0AAC05CB383AFA5CB683E321E5FBD71938DB06.png)
流水线场景
在hvigorw命令后加上ohos-debug-tsan=true的选项，执行hvigorw命令，更多options参考hvigorw文档
同上，如果有引用本地library，需在library模块的build-profile.json5文件中，配置arguments字段值为“-DOHOS_ENABLE_TSAN=ON”，表示以TSAN模式编译so文件。
方式二
DevEco Studio场景
1. 修改工程目录下AppScope/app.json5，添加TSan配置开关。
```json
"tsanEnabled": true
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.60273849088854047176669971926977:50001231000000:2800:444E6013A8775CFFB910BE9284773BD5185B77E7E8947B5CEC9F3CC254384A55.png)
2. 设置模块级构建TSan插桩。
在需要使能TSan的模块中，通过添加构建参数开启TSan检测插桩，在对应模块的模块级build-profile.json5中添加命令参数：
```json
"arguments": "-DOHOS_ENABLE_TSAN=ON"
```
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151208.66419904605156129161142184204991:50001231000000:2800:F431E71FAF9102E1BAF7ACF2C5312C42A48C362B17E12B421C45ADBF16C52F5D.png)
流水线场景
在hvigorw命令后加上ohos-debug-tsan=true的选项，执行hvigorw命令，更多options参考hvigorw文档
同上，如果有引用本地library，需在library模块的build-profile.json5文件中，配置arguments字段值为“-DOHOS_ENABLE_TSAN=ON”，表示以TSAN模式编译so文件。
Tsan异常检测类型
Data race
背景
多个线程在没有正确加锁的情况下，同时访问同一块数据，并且至少有一个线程是写操作，对数据的读取和修改产生了竞争，从而导致各种不可预计的问题
错误代码实例
影响
对数据的读取和修改产生了竞争，从而导致各种不可预计的问题
开启Tsan检测后，触发demo中的函数，应用闪退报Tsan，包含字段：ThreadSanitizer: data race
定位思路
如果有工程代码，直接开启Tsan检测，debug模式运行后复现该错误，可以触发Tsan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
加锁或者其它线程同步的方法
推荐建议
多线程访问同一内存时，需要注意线程同步机制，必要时加锁
data race on vptr
背景
一个线程在删除某个对象(obj)、一个线程在调用虚函数(obj->vcall)
错误代码实例
影响
线程行为发生冲突，程序崩溃
开启Tsan检测后，触发demo中的函数，应用闪退报Tsan，包含字段：ThreadSanitizer: data race on vptr (ctor/dtor vs virtual call)
定位思路
如果有工程代码，直接开启Tsan检测，debug模式运行后复现该错误，可以触发Tsan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
设置合适的线程同步机制，如锁
推荐建议
确保设置合适的线程同步机制，来保证线程执行逻辑先后的准确性
Use After Free
heap-use-after-free
背景
使用了释放的内存（多线程层面）
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启Tsan检测后，触发demo中的函数，应用闪退报Tsan，包含字段：ThreadSanitizer: heap-use-after-free
定位思路
如果有工程代码，直接开启Tsan检测，debug模式运行后复现该错误，可以触发Tsan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
已释放的内存不要使用，释放的内存需要标记，方便其它线程判断
推荐建议
使用合理的线程同步机制
Signal Check
signal handler spoils errno
背景
信号处理函数中修改了errno变量
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启Tsan检测后，触发demo中的函数，应用闪退报Tsan，包含字段：ThreadSanitizer: signal handler spoils errno
定位思路
如果有工程代码，直接开启Tsan检测，debug模式运行后复现该错误，可以触发Tsan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
不要在信号处理函数中修改error变量
推荐建议
将MyHandler中的error赋值语句去掉
signal-unsafe call inside of a signal
背景
信号处理函数中调用了非信号安全的函数（比如malloc）
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启Tsan检测后，触发demo中的函数，应用闪退报Tsan，包含字段：ThreadSanitizer: signal-unsafe call inside of a signal
定位思路
如果有工程代码，直接开启Tsan检测，debug模式运行后复现该错误，可以触发Tsan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
将信号处理函数中的malloc去掉，在其外部预先分配内存。
推荐建议
建议信号处理程序之外预先分配内存，或者尽可能避免在信号处理程序中进行内存分配和复杂的操作。如果需要在程序中替换malloc，可以考虑使用__malloc_hook或者宏定义等方法
Mutex Check
unlock of an unlocked mutex (or by a wrong thread)
背景
解锁一个已经解锁/自己不拥有的锁
错误代码实例
影响
导致程序存在安全漏洞，并有崩溃风险。
开启Tsan检测后，触发demo中的函数，应用闪退报Tsan，包含字段：ThreadSanitizer: unlock of an unlocked mutex (or by a wrong thread)
定位思路
如果有工程代码，直接开启Tsan检测，debug模式运行后复现该错误，可以触发Tsan，直接点击堆栈中的超链接定位到代码行，能看到错误代码的位置。
修改方法
先使用try_lock()接口获取锁，再使用unlock()接口解锁
推荐建议
尽量不要释放自己线程未持有的锁

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-ark-runtime-detection
爬取时间: 2025-05-01 09:04:12
来源: Huawei Developer
方舟多线程检测
在JS运行时环境中，多线程的安全问题是一个重要的考虑因素。由于JavaScript本身是单线程的，对JS对象的任何操作都必须在创建该JS线程的原始线程上进行。如果违反了这一规则，就会导致多线程安全问题。以下是关于如何判断和处理这些问题的一些详细说明。
原理介绍
-  JavaScript是单线程执行的语言，这意味着它一次只能在一个线程上执行代码。任何JavaScript对象都只能在创建它们的线程上进行操作。
-  N-API接口直接涉及到JavaScript对象的操作。绝大多数N-API接口（约95%）只能在创建这些对象的JavaScript线程上调用。
-  多线程检测机制会检测当前线程和正在使用的JS虚拟机环境（vm/env）中的JS线程ID是否一致。如果不一致，就表明虚拟机环境被跨线程使用，存在多线程安全问题。
常见多线程安全问题
-  非JavaScript线程尝试调用N-API接口，可能会导致未定义的行为或崩溃。
-  一个线程尝试使用另一个线程创建的env（JavaScript环境），这也会导致多线程安全问题。
如何判断是否发生了多线程安全问题
如果在运行时遇到以下致命错误信息，这意味着已经发生了多线程安全问题：
其中，thread:3096 表示创建并拥有这个JavaScript环境的线程ID。currentThread:3550 表示当前正在尝试操作这个JavaScript环境的线程ID。
当前线程号为3550，而使用的JavaScript线程是由3096线程创建的，这表明虚拟机环境（vm/env）被跨线程使用，从而导致了多线程安全问题。
使用约束
方舟多线程检测通过命令行参数开启，点击桌面图标无效。
使能方舟多线程检测
可通过以下两种方式使能方舟多线程检测。
点击Run > Edit Configurations >Diagnostics，勾选Multi Thread Check。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151209.78155953849438907163075702244240:50001231000000:2800:8BB521DA5471227A33FE2738594F0C339465B505BB291F9AD05559D86ADC752D.png)
通过命令行开启。
启用方舟多线程检测
方舟异常检测码
若fatal信息为Fatal: ecma_vm cannot run in multi-thread! thread:1804 currentThread:2057，则发生了多线程安全问题，意为：当前线程号为2057，而使用的js thread是1804创建出来的，跨线程使用VM
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151209.35277975566654469173766240448794:50001231000000:2800:50C87676159759C5D25F9AFE1746F3A217B5B540555B59370671549CAD47B76B.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-ark-exception-detection
爬取时间: 2025-05-01 09:04:25
来源: Huawei Developer
概述
在进行ArkTS项目开发中可能存在需要加载native模块的场景，开启方舟native模块加载异常信息增强功能后，可以丰富ArkTS项目中因加载native模块导致的报错信息，以便更准确地进行native问题定位。
使能方舟native模块加载异常信息增强
可以通过以下两种方式使能方舟native模块加载异常信息增强
点击Run > Edit Configurations >Diagnostics，勾选Enhanced Error Info。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151209.43768626389630447371097185387464:50001231000000:2800:14935B5E31C05023A7D157D4D6187C6B1B9DF7283708844DCB7A9400B905A6CF.png)
通过命令行开启。
启用方舟native模块加载异常信息增强
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151209.79172347548814583711432879281412:50001231000000:2800:EF8D0E5610A675BC8493A5AC232494A9D912FBA2C9C41132B53461621A295B45.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-analyzer
爬取时间: 2025-05-01 09:04:38
来源: Huawei Developer
功能介绍
应用与元服务体检工具（AppAnalyzer）用于对应用和元服务进行本地测试体检，并给出体检报告、分析指导以及修改建议，帮助开发者提升应用质量。在体检过程中，工具会收集应用的trace信息、代码栈、内存快照以及应用页面的截屏，并保存在本地工程目录.appanalyzer下，帮助开发者快速进行问题分析定位。
开发者可以通过DevEco Studio连接本地设备，自主遍历HarmonyOS应用或元服务的功能，快速进行自测试，查看测试结果及评分。当前支持的测试类型包括兼容性、性能、UX测试和最佳实践等，具体评分标准请参见评分方法及规则。
使用约束
HarmonyOS应用测试
2. 在AppAnalyzer页面Module选择框选择HarmonyOS应用/元服务工程模块。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151209.53216227721442235895365679628942:50001231000000:2800:5FE72DB4DC30715DAE3F9EA159A05997B9AF913FE1355AD8E99EA454822E9169.png)
3. 根据应用的类别选择Category。
如果模块的类型（application/service）有修改，再次使用应用与元服务体检功能时，请点击Module取消勾选后再重新勾选模块。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151209.22369730580914854371429010587501:50001231000000:2800:D7581B1CA60C5614B28328A046B9AFBD4E91C44C27F53C4B0CF59FA618E8C7FF.png)
4. 选择一个体检规则集，不同的规则集包含的检测规则如下，规则详情请参考应用/元服务体检规则，然后在AppAnalyzer页面底部单击Start开始测试。在测试过程中，请保持连接的设备为解锁亮屏状态。
请勿在测试完成前点击结束，如果提前结束测试会导致测试结果不准确。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151209.53178900254892972006974973158967:50001231000000:2800:ED974DC5E7C7FB3A91F5D232592E11233AFB58E5DF5ADCDD53F327F7A2DCBEA6.png)
5. 如果选择最佳实践或快速性能检测的部分规则，在体检结束后需要根据提示手动遍历HarmonyOS应用/元服务的功能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151209.86146380954584047033761990213776:50001231000000:2800:A06199FF7360D71436665AC64566D2AD90DCF7320B655860ECBAA6D4C05ACF07.png)
以性能Benchmark规则集为例，自动检测和手动遍历完成后点击Stop停止测试任务，查看测试结果如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151209.83662799862500657202592404675597:50001231000000:2800:638DF6196062B71616040DE99CC56AC4542F1FDC0C7F7EE1D6318270C0514BFC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151209.96057491437077741095522697268165:50001231000000:2800:1A6F2E9FF4ED8F4999421B85B73B9C8648EA9D11EE6799747D886F67C57C04A4.png)
查看历史报告
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151209.62634066480368959761500350228835:50001231000000:2800:19AF25E03B9EC8C987353A471D20996B1AC971C8E9CBC733C5C2D304CA92ABEC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151209.86451159321612179947859708804694:50001231000000:2800:FBECFED1DE2342E2C4D7669313D6D45747EE6FB9BA53DBEFBC2C979ACFD8E0C5.png)
评分方法及规则
应用与元服务体检当前支持兼容性、性能、UX测试和最佳实践等测试类型检测。AppAnalyzer会根据体检结果计算出最后评分，满分为100分。评分的计算公式为：
评分 = Sum(检测通过的体检项权重）/Sum(体检项权重）*100
各体检项检测规则及权重如下表所示，更详细的信息请参考应用/元服务体检规则：
| 体检类别  | 检测规则  | 应用或元服务规则  | 权重  |
| --- | --- | --- | --- |
| 规格约束  | Entry hap检测  | 应用，元服务  | 5  |
| 包名和版本号一致性  | 应用，元服务  | 4  |
| SDK版本检测  | 应用，元服务  | 3  |
| ReqPermissions权限  | 应用，元服务  | 4  |
| 设备类型  | 应用，元服务  | 5  |
| 应用/元服务必须有图标  | 应用，元服务  | 5  |
| 应用要支持64位so文件  | 应用  | 4  |
| 元服务内所有包总和大小不超过10MB  | 元服务  | 2  |
| 元服务单个包文件大小不超过2MB  | 元服务  | 2  |
| 元服务免安装属性  | 元服务  | 4  |
| 元服务预加载对应模块类型不能为entry  | 元服务  | 4  |
| 应用非免安装属性  | 应用  | 2  |
| 卡片metadata元信息  | 应用，元服务  | 3  |
| 卡片supportDimensions字段  | 应用，元服务  | 3  |
| 卡片defaultDimension字段  | 应用，元服务  | 3  |
| 卡片isDefault字段  | 应用，元服务  | 3  |
| 卡片updateEnabled字段  | 应用，元服务  | 3  |
| 卡片description字段  | 应用，元服务  | 4  |
| 兼容性  | 应用支持在当前OS版本/设备类型安装  | 应用，元服务  | 5  |
| 应用支持在当前OS版本/设备类型启动  | 应用，元服务  | 5  |
| 应用支持在当前OS版本/设备类型卸载  | 应用，元服务  | 4  |
| 应用在当前OS版本/设备类型运行稳定  | 应用，元服务  | 3  |
| 性能  | 应用内点击操作响应快  | 应用  | 3  |
| 应用内点击操作完成快  | 应用  | 3  |
| 应用内滑动操作响应快  | 应用  | 3  |
| 应用内滑动过程流程  | 应用  | 3  |
| 应用内转场操作流畅  | 应用  | 3  |
| 应用动态内存峰值占用  | 应用  | 3  |
| 应用前台场景内存峰值占用  | 应用  | 3  |
| 应用后台CPU占用峰值  | 应用  | 3  |
| 图形渲染服务处理节点数小于500  | 应用  | 1  |
| 快速性能检测（仅性能benchmark规则集包含）        | 页面内点击操作完成时延快速检测  | 应用  | 3  |
| 页面内滑动过程流畅性快速检测  | 应用  | 3  |
| 页面转场操作流畅性快速检测  | 应用  | 3  |
| 页面内节点数超过500过多快速检测  | 应用  | 1  |
| 页面内白块检测  | 应用  | 1  |
| 页面内点击操作响应时延快速检测  | 应用  | 3  |
| 页面内滑动响应时延快速检测  | 应用  | 3  |
| 避免页面内UI容器组件超出屏幕过多  | 应用  | 1  |
| 应用冷启动完成时延检测  | 应用  | 3  |
| 避免序列化反序列化耗时长  | 应用  | 3  |
| 功耗  | 后台进程CPU负载约束（长时任务）  | 应用  | 1  |
| 后台进程CPU负载约束（短时任务）  | 应用  | 1  |
| 合理使用蓝牙资源  | 应用  | 1  |
| 合理使用麦克风或者扬声器  | 应用  | 1  |
| 合理使用GPS资源  | 应用  | 1  |
| 合理使用sensor资源  | 应用  | 1  |
| 后台合理使用系统资源  | 应用  | 1  |
| 稳定性  | 应用崩溃检测  | 应用，元服务  | 2  |
| 应用卡死检测  | 应用，元服务  | 4  |
| 内存泄漏检测  | 应用，元服务  | 4  |
| 安全与隐私  | 申请权限字段规范  | 应用，元服务  | 2  |
| 应用Ability可见性设置  | 应用，元服务  | 2  |
| 应用Ability权限设置  | 应用，元服务  | 2  |
| DataShareExtensionAbility组件权限  | 应用，元服务  | 2  |
| 权限申请最小化原则  | 应用，元服务  | 2  |
| 公共事件接收器权限访问控制  | 应用，元服务  | 2  |
| 应用签名完整性  | 应用，元服务  | 2  |
| 应用签名信息  | 应用，元服务  | 2  |
| UX测试        | 基础信息  | 元服务  | 2  |
| 服务卡片定时刷新  | 元服务  | 1  |
| 卡片背景圆角  | 元服务  | 1  |
| 卡片最小字体  | 元服务  | 1  |
| 卡片内容圆角  | 元服务  | 1  |
| 卡片热区大小  | 元服务  | 1  |
| 最佳实践    | 避免过大的组件树节点数目  | 应用，元服务  | 2  |
| 避免执行脚本的耗时过长  | 应用，元服务  | 2  |
| 避免渲染界面的耗时过长  | 应用，元服务  | 2  |
| ForEach性能  | 应用，元服务  | 2  |
| 单帧属性数量更新内容限制  | 应用，元服务  | 2  |
| 单帧脏组件数量限制  | 应用，元服务  | 2  |
| web组件初始化耗时检测  | 应用，元服务  | 2  |
| web执行js耗时检测  | 应用，元服务  | 2  |
| UI线程IO执行耗时长未并行化检测  | 应用，元服务  | 2  |
| UI线程耗时操作检测  | 应用，元服务  | 2  |
| web主资源下载耗时检测  | 应用，元服务  | 2  |
| web子资源下载耗时检测  | 应用，元服务  | 2  |
| 短视频起播时延检测  | 应用  | 2  |
| 相机拍照完成时延检测  | 应用  | 2  |
体检类别
检测规则
应用或元服务规则
权重
规格约束
Entry hap检测
应用，元服务
5
包名和版本号一致性
应用，元服务
4
SDK版本检测
应用，元服务
3
ReqPermissions权限
应用，元服务
4
设备类型
应用，元服务
5
应用/元服务必须有图标
应用，元服务
5
应用要支持64位so文件
应用
4
元服务内所有包总和大小不超过10MB
元服务
2
元服务单个包文件大小不超过2MB
元服务
2
元服务免安装属性
元服务
4
元服务预加载对应模块类型不能为entry
元服务
4
应用非免安装属性
应用
2
卡片metadata元信息
应用，元服务
3
卡片supportDimensions字段
应用，元服务
3
卡片defaultDimension字段
应用，元服务
3
卡片isDefault字段
应用，元服务
3
卡片updateEnabled字段
应用，元服务
3
卡片description字段
应用，元服务
4
兼容性
应用支持在当前OS版本/设备类型安装
应用，元服务
5
应用支持在当前OS版本/设备类型启动
应用，元服务
5
应用支持在当前OS版本/设备类型卸载
应用，元服务
4
应用在当前OS版本/设备类型运行稳定
应用，元服务
3
性能
应用内点击操作响应快
应用
3
应用内点击操作完成快
应用
3
应用内滑动操作响应快
应用
3
应用内滑动过程流程
应用
3
应用内转场操作流畅
应用
3
应用动态内存峰值占用
应用
3
应用前台场景内存峰值占用
应用
3
应用后台CPU占用峰值
应用
3
图形渲染服务处理节点数小于500
应用
1
快速性能检测（仅性能benchmark规则集包含）
页面内点击操作完成时延快速检测
应用
3
页面内滑动过程流畅性快速检测
应用
3
页面转场操作流畅性快速检测
应用
3
页面内节点数超过500过多快速检测
应用
1
页面内白块检测
应用
1
页面内点击操作响应时延快速检测
应用
3
页面内滑动响应时延快速检测
应用
3
避免页面内UI容器组件超出屏幕过多
应用
1
应用冷启动完成时延检测
应用
3
避免序列化反序列化耗时长
应用
3
功耗
后台进程CPU负载约束（长时任务）
应用
1
后台进程CPU负载约束（短时任务）
应用
1
合理使用蓝牙资源
应用
1
合理使用麦克风或者扬声器
应用
1
合理使用GPS资源
应用
1
合理使用sensor资源
应用
1
后台合理使用系统资源
应用
1
稳定性
应用崩溃检测
应用，元服务
2
应用卡死检测
应用，元服务
4
内存泄漏检测
应用，元服务
4
安全与隐私
申请权限字段规范
应用，元服务
2
应用Ability可见性设置
应用，元服务
2
应用Ability权限设置
应用，元服务
2
DataShareExtensionAbility组件权限
应用，元服务
2
权限申请最小化原则
应用，元服务
2
公共事件接收器权限访问控制
应用，元服务
2
应用签名完整性
应用，元服务
2
应用签名信息
应用，元服务
2
UX测试
基础信息
元服务
2
服务卡片定时刷新
元服务
1
卡片背景圆角
元服务
1
卡片最小字体
元服务
1
卡片内容圆角
元服务
1
卡片热区大小
元服务
1
最佳实践
避免过大的组件树节点数目
应用，元服务
2
避免执行脚本的耗时过长
应用，元服务
2
避免渲染界面的耗时过长
应用，元服务
2
ForEach性能
应用，元服务
2
单帧属性数量更新内容限制
应用，元服务
2
单帧脏组件数量限制
应用，元服务
2
web组件初始化耗时检测
应用，元服务
2
web执行js耗时检测
应用，元服务
2
UI线程IO执行耗时长未并行化检测
应用，元服务
2
UI线程耗时操作检测
应用，元服务
2
web主资源下载耗时检测
应用，元服务
2
web子资源下载耗时检测
应用，元服务
2
短视频起播时延检测
应用
2
相机拍照完成时延检测
应用
2

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-testing
爬取时间: 2025-05-01 09:04:51
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-deveco-testing
爬取时间: 2025-05-01 09:05:05
来源: Huawei Developer
本文介绍DevEco Testing为HarmonyOS NEXT应用开发者提供的稳定性测试服务，包括稳定性基础质量测试及应用探索测试。稳定性基础质量测试基于HarmonyOS NEXT稳定性测试建议，提供了应用稳定性基础检测能力，帮助用户快速上手稳定性测试；应用探索测试提供了基于专家经验的智能遍历手段，驱动测试高效执行，构建应用专属测试模型，帮助用户有效识别应用故障。
稳定性基础质量测试
DevEco Testing为HarmonyOS NEXT应用开发者提供应用基础质量测试服务。提供多维度的应用检测方法，快速评估应用基础质量。结合HarmonyOS NEXT应用专项测试质量建议，提供测试报告及优化建议，助您高效提升应用质量。
注：当前被测设备系统版本需为HarmonyOS NEXT Developer Beta 1(3.0.0.25)及以上。
| 测试服务  | 简介  |
| --- | --- |
| 功能体验基础质量测试  | 对应用与OS兼容、应用与设备兼容、应用升级兼容、功能体验相关等进行评估  |
| 稳定性基础质量测试  | 检测应用长时间运行故障率（崩溃、冻屏等）、长时间运行内存资源异常情况  |
| 性能基础质量测试  | 对应用启动、应用内滑动及点击、应用资源占用等场景进行性能评估  |
| UX基础质量测试  | 验证应用在基础体验、系统特性适配、控件布局等方面是否合理  |
| 功耗基础质量测试  | 检测应用在后台运行时是否出现系统资源占用的异常情况  |
测试服务
简介
功能体验基础质量测试
对应用与OS兼容、应用与设备兼容、应用升级兼容、功能体验相关等进行评估
稳定性基础质量测试
检测应用长时间运行故障率（崩溃、冻屏等）、长时间运行内存资源异常情况
性能基础质量测试
对应用启动、应用内滑动及点击、应用资源占用等场景进行性能评估
UX基础质量测试
验证应用在基础体验、系统特性适配、控件布局等方面是否合理
功耗基础质量测试
检测应用在后台运行时是否出现系统资源占用的异常情况
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151210.59877557450508306745636514948731:50001231000000:2800:93AD0C1CC9A7BA80D61A0A99480A663AD829B7B14BC15DC8E493B119DC2B761A.png)
性能基础质量测试
性能基础质量测试：性能基础质量测试服务通过模拟用户的操作行为，对应用进行长时间、高操作频率的页面遍历，收集遍历过程中的性能数据，提供专业、可靠的测试报告，辅助开发者评估和优化应用的性能质量。
创建任务
进入DevEco Testing客户端，左侧菜单栏选择“应用基础质量测试”，选择“性能基础质量测试”，点击服务卡片，即进入任务创建界面。按需配置任务参数，点击创建任务即开始测试。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151210.12309533719183122519463332597079:50001231000000:2800:7C5CF6E3D4A88F186E297DFD0462171F191B70B208DFFE4FF1CACD41F9389605.png)
在执行测试前，需检查以下状态，以保证任务的有效性：
1、手动对应用进行必要的预置操作，包括权限授予、用户协议确认、账号登录等等，以保障自动化遍历可顺利进行
2、确保手机性能状态正常，包括网络连接通畅、非高温、非低电量（推荐>80%），以及其他可能对性能表现产生影响的变量
3、不要设置各类锁屏密码，确保自动化能完成上滑解锁
4、应用图标在桌面可见，不要藏起来（自动化会翻页查找，但不会打开文件夹）进入服务卡片后，选择要测试的应用，点击创建任务即可开始，任务过程无需人工干预测试执行
任务创建后即进入测试执行页面，测试过程中，在测试页面可以看到测试进度、用例列表、及执行日志。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151210.69851633632724283311743186324333:50001231000000:2800:C54A11E4DFB94A3F8F6C111A3D394B3194C369DCD33AB9961F1E5569324F7CC4.png)
测试过程中，在测试页面可以看到测试当前进度、用例列表、执行日志。测试执行时，设备会进行应用页面的跳转，请勿触碰正在执行测试过程中的设备。
应用支持情况说明：
查看报告
测试完成后，自动生成测试报告。性能基础质量测试报告如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151210.89047549983575826236226199092925:50001231000000:2800:35178B9B23AA1E378B38822759798DF221B155668176ED5C0B0AAF16C1E870EB.png)
报告包含任务信息、总览、测试结论、指标项、测试步骤详情。指标项卡片包含三类状态：绿色为达标，红色为不达标，灰色为该指标项未检测。
*达标判定：85分位值超过推荐值小于10%以内算达标。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151210.66109755277544301554533254585970:50001231000000:2800:D5A8B086BE751AA3728F0CCE71D36589F1AED711A62D08A96625E83527B406EB.png)
可通过点击指标卡片的详细数据中的数字跳转到步骤详情，即可查看本次遍历过程中该场景的详细数据及截图。点击“查看”可获取到本次测试过程中的日志、trace等辅助分析文件，帮助开发者进一步分析优化异常场景性能表现。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151210.55932588898335836107191817288902:50001231000000:2800:98AB17A660711D9F21B02B40E7292D0CE96ECBE9C671A59A385EB9F34DA40347.png)
定位信息查看
Ⅰ. perfdata文件查看
点击定位信息列的查看，会跳转到对应的perfdata文件。可使用DevEco Studio 5.0.3.300及以上版本中的场景化调优工具DevEco Profiler打开及查看该文件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151210.79744337138884299167131520151428:50001231000000:2800:55A1709503850A44A8B081296C54D72750D99C6BCEE27259338C36863E75192F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151210.05427182516878999167776468687270:50001231000000:2800:D64B99C066E1CE3C7F9003DAA54151A4F9BD3312B014D1CBCC6EA3FC628E1F85.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151210.94195035437971510146751624403378:50001231000000:2800:B19DCE4A6ACB4B91722F81848FB030BB4BF3C530D534633AABE5BC3DEC556CB2.png)
此外perfdata可使用压缩软件查看并打开，可解压出trace文件，trace文件可使用smartperf网站查看，网站地址：https://www.smartperf.host/
Ⅱ.hilog查看
点击导出报告，会打开报告导出目录（task/taskId/export），该目录往上返一层进入父目录，则到了任务数据根目录（task/taskId）
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151210.28256069667939656315835584873104:50001231000000:2800:933CC1B2DF18D3CCEB9945979F27C207BF36404AFD215BD587014A46E2F6E408.png)
*更多性能测试项详细hilog路径，请前往DevEco Testing客户端-应用基础质量测试-性能基础质量测试-任务创建页-测试指南中查询。
检测规则
*更多检测规则详情，请前往DevEco Testing客户端-应用基础质量测试-性能基础质量测试-任务创建页-测试指南中查询。
*更多应用性能优化建议及问题定位，请查阅：应用性能体验建议及最佳实践-性能。
常见问题
Q1：报告中为什么会出现未执行检测？
A1：如遇到以下几种场景，将会出现未执行检测项。
场景1：在应用测试过程中，不满足测试用例执行条件，将不执行相关测试场景。例如，应用页面仅一屏，不支持滑动，则本次遍历中，滑动相关指标将无数据；某些指标检测动效场景，如果遍历中未遇到动效场景，则XX流畅相关指标将无数据。
场景2：由于通过查找桌面应用图标名查找应用，被测应用需放置在桌面上，请勿放在文件夹中，否则将出现批量未检测项。
场景3：使用webview类应用进行测试，将出现测试数据不准确及批量出现未执行检测项。
场景4：偶现应用解析异常，导致批量出现未检测项，该场景请重新执行任务即可恢复。
场景5：应用内操作测试目前主要支持ArkUI控件类应用（含ReactNative框架开发应用），WebView页面遍历系统版本需为HarmonyOS NEXT Beta1及以上版本。
场景6：不支持Flutter应用，以及其他三方自研的自定义控件识别。
Q2：执行过程中，设备断连重连后，任务能否继续执行？
A2：如果发生设备断连情况测试会终止，并生成测试报告，由于测试执行不充分，会导致生成的报告数据不完整，请保证设备在测试的过程中正常连接。
功能体验基础质量测试
功能体验基础质量测试：根据应用功能体验建议，检测应用在当前系统、设备及升级场景下运行是否存在兼容性问题。
创建任务
进入DevEco Testing客户端，在左侧菜单栏选择“功能体验基础质量测试”，点击“功能体验基础质量测试”服务卡片，即进入任务创建界面。按需配置任务参数，点击创建任务即开始测试。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151210.13611679414504900308987164096473:50001231000000:2800:4F32B04334356758E376D8F205D3E8655EAC0899CD94E90D49ABD89D1967AD24.png)
测试执行
任务创建后即进入测试执行页面，测试过程中，在测试页面可以看到测试进度、检测规则、实时投屏及执行日志。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151210.35365774342642233430095557486537:50001231000000:2800:255DA040AFB2B6D396C7E27B50374B2CD61003EC04E855D96EDABDBCA016BF0D.png)
查看报告
测试完成后，自动生成测试报告。任务结束后，自动生成测试报告。功能体验基础质量测试报告如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151211.69533648673512976514707739917329:50001231000000:2800:DA38F9B63D1F37E64FE86B0C2950489DE9D812AD934409C968DF1C9F082A9BD7.png)
报告包含任务信息、执行结果、问题统计、检测规则。支持查看当前应用信息、任务执行时长，及详细的环境参数（配置信息及环境信息），支持导出 html 的报告文件。测试概览中，可查看执行结果、问题统计及检测规则。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151211.90185732279082995983981316291166:50001231000000:2800:C9037DD9E17EE92CFD84FCCEA6DA5339AED8A2A7B784198CF833FE9D6FF32190.png)
对于检测不通过及检测异常的规则项，点击查看详情即可异常问题详情，包含检测项概览、测试截图、问题列表。对于异常问题，可根据测试截图、问题描述及发生时间，结合 hilog 日志，进一步定位分析。
检测规则
*更多检测规则详情，请前往DevEco Testing客户端-应用基础质量测试-功能体验基础质量测试-任务创建页-测试指南中查询。*更多应用功能体验优化建议及问题定位，请查阅：应用基础功能和兼容性体验建议
常见问题
Q1：测试报告中，为什么会出现测试项检测异常？
A1：可能是系统版本配套原因，请选手机系统为HarmonyOS NEXT Developer Beta 1(3.0.0.25)及以上版本进行测试。其他类型设备及系统测试报告中或出现检测异常。
设备断连会影响测试结果，可能出现检测异常及待检测项，请确保测试过程中设备正常连接。
Q2：测试报告中，为什么会批量出现待检测项？
A2：偶现由于测试任务内部异常导致任务终止，请查看【测试报告-执行日志】，若应用信息为空，请再次创建任务执行测试。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151211.87742116367182527506386420562864:50001231000000:2800:6100D9F86CF44F33647EA232E6F7E2850F79E18405B84582FB25C71F866A0050.png)
该问题为应用信息暂未解析完创建任务导致，再次创建任务时，请等待右侧应用信息加载完成后再创建，即可解决该问题。
稳定性基础质量测试
稳定性基础质量测试：根据应用稳定性建议，检测应用运行过程中是否存在应用崩溃、资源过载、内存泄漏等异常情况。
创建任务
进入DevEco Testing客户端，在左侧菜单栏选择“稳定性基础质量测试”，点击“稳定性基础质量测试”服务卡片，即进入任务创建界面。按需配置任务参数，点击创建任务即开始测试。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151211.01925658890797377739837098350169:50001231000000:2800:9B8C03DB594B185669C061149B19F71F0CEEC191F60C065698DF620AA39DE4F4.png)
测试执行
创建任务后，将会跳转到执行页，进入测试环境初始化阶段。测试过程中，在测试页面可以看到测试进度、实时投屏、检测规则及执行日志。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151211.16886273029273034825817871995948:50001231000000:2800:2988EFFA8DFA16CD2F506213C0E860523AD0D5BB675443FFEEAFC176F556A9D2.png)
查看报告
测试完成后，自动生成测试报告。稳定性基础质量测试报告如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151211.18154714683573330082803131087508:50001231000000:2800:20AED72C88B589EE99A91CDF8A82CC5115EFB0A2507C05A8642004B8ED982119.png)
报告包含任务信息、执行结果、问题统计、检测规则。支持查看当前应用信息、任务执行时长，及详细的环境参数（配置信息及环境信息），支持导出 html 的报告文件。测试概览中，可查看执行结果、问题统计及检测规则。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151211.92363200113353510899503185713834:50001231000000:2800:452FE362DA7B4FA6660A02E319A325708E624CBEF8D389C46793582B7E1DB2C7.png)
对于检测不通过及检测异常的规则项，点击查看详情即可查看异常问题详情，包含检测项概览、测试截图、问题列表。对于异常问题，可根据测试截图、问题描述及发生时间，结合 hilog 日志，进一步定位分析。
检测规则
*更多检测规则详情，请前往DevEco Testing客户端-应用基础质量测试-稳定性基础质量测试-任务创建页-测试指南中查询。
*更多应用稳定性体验优化建议及问题定位，请查阅：应用稳定性体验建议及CppCrash故障定位指导
常见问题
Q1：测试报告中，为什么会出现测试项检测异常？
A1：可能是系统版本配套原因，请选手机系统为HarmonyOS NEXT Developer Beta 1(3.0.0.25)及以上版本进行测试。其他类型设备及系统测试报告中或出现检测异常。
设备断连会影响测试结果，可能出现检测异常及待检测项，请确保测试过程中设备正常连接。
Q2：测试报告中，为什么会批量出现待检测项？
A2：偶现由于测试任务内部异常导致任务终止，请查看【测试报告-执行日志】，若应用信息为空，请再次创建任务执行测试。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151211.53478168639835686849076811867765:50001231000000:2800:5D4C114CCCE58069D6AA50DB5DB88F1E2C41443ECF66B56466005A59B2D5FDBB.png)
该问题为应用信息暂未解析完创建任务导致，再次创建任务时，请等待右侧应用信息加载完成后再创建，即可解决该问题。
UX基础质量测试
UX基础质量测试：根据应用UX建议，验证应用在基础体验、系统特性适配、控件布局等方面是否合理。
创建任务
进入DevEco Testing客户端，在左侧菜单栏选择“稳定性基础质量测试”，点击“UX基础质量测试”服务卡片，即进入任务创建界面。按需配置任务参数，点击创建任务即开始测试。
模型选择：无或已有应用测试模型。应用测试模型生成可参考应用探索测试服务
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151211.53650904120929078357421492632196:50001231000000:2800:09F8DFFB7B90F40C2F750056B5B2D4FEF6C5BC0DA70925E5C10558B7A2D7FBA7.png)
如选择应用遍历模型进行UX测试时，遍历过程将参照已有遍历模型的页面节点进行遍历，可有效缩短UX遍历时间。遍历模型及节点可参考查看应用探索测试对应任务遍历地图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151211.13627370999895717158141266871677:50001231000000:2800:9B7E217B13819A06604E27422B1843B4CCD28316802A6E5E4AD8E99102A60EA8.png)
测试执行
创建任务后，将会跳转到执行页，进入测试环境初始化阶段。测试过程中，将针对模型中的已有界面进行UX检测。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151211.37062053925501044909908409900164:50001231000000:2800:596F65A56F2C79807796AEC36686C15F54D563D8FC530A742B6EF95C87CDB5BC.png)
在测试页面可以看到测试进度、实时投屏、检测结果统计、检测规则及执行日志，可实时查看不通过页面问题详情：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151211.08169474598921731290237845389512:50001231000000:2800:0BE941CE67508DD5B847334599F7331ECFF1B0B23B8C83D980859696B35BD8D5.png)
查看报告
测试完成后，自动生成测试报告。UX基础质量测试报告如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151211.37059355298228430818015911178092:50001231000000:2800:D2A0E110AA3C48F4382F48741F4C4D93F68AB01C731DEA026E3C419BA10E5817.png)
报告包含任务信息、执行结果、检测规则。支持查看当前应用信息、任务执行时长，及详细的环境参数（配置信息及环境信息），支持导出 html 的报告文件。测试概览中，可查看执行结果、结果统计及检测规则。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151212.10282220864167873750681123267950:50001231000000:2800:5C97F64589A6F708B50E76C20D22CA2F47C5208B28FB7608646B58A60CA60C62.png)
对于检测不通过及检测异常的规则项，点击查看详情即可查看异常问题详情，包含检测项概览、测试截图、问题列表。对于异常问题，可根据测试截图、问题描述，针对性优化异常问题。
检测规则
*更多检测规则详情，请前往DevEco Testing客户端-应用基础质量测试-UX基础质量测试-任务创建页-测试指南中查询。
*更多应用UX优化建议及问题定位，请查阅：应用UX体验建议
常见问题
Q1：测试报告中，为什么会出现不涉及检测项？
A1：布局合理美观相关检测项为折叠屏机型专属测试项，直板机测试过程中，不涉及此类检测项的测试。
设备断连会影响测试结果，可能出现检测异常及待检测项，请确保测试过程中设备正常连接。
Q2：测试报告中，所有检测项均异常，异常原因提示“the ux script reports an error”，该如何处理？
A2：若出现该场景，请前往DevEco Testing客户端-设置-问题反馈，或通过华为开发者联盟-在线提单，提交该场景信息（测试服务名称+异常任务信息+问题描述+问题截图），以便于研发团队进一步分析。
注意：客户端提交反馈需打开日志上传开关，华为开发者联盟提单请附上工具日志。
Windows日志路径：C:\Users\用户名\AppData\Local\DevEco Testing\common\modules\launcher\logs
Mac日志路径：/Users/用户名/Library/Application Support/DevEco Testing/common/modules/launcher/logs
Q3：实际情况与测试结果有偏差，该如何处理？
A3：部分检测项可能存在少量视觉检测误差，测试结果请忽略，后续将持续降低检测误差。如误差较大，请通过设置-问题反馈，提交问题说明与截图，便于DevEco Testing后续进一步优化。
Q4：测试报告中，为什么会批量出现待检测项？
A4：偶现由于测试任务内部异常导致任务终止，请查看【测试报告-执行日志】，若应用信息为空，请再次创建任务执行测试。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151212.30094284050578158424342521448399:50001231000000:2800:8658DF23B8CAFD74AA6F247BCA6C16FE7D4BAC6430C718B9DF34282365178A70.png)
该问题为应用信息暂未解析完创建任务导致，再次创建任务时，请等待右侧应用信息加载完成后再创建，即可解决该问题。
功能基础质量测试
功耗基础质量测试：根据应用功耗建议，检测应用在后台运行时是否出现系统资源占用的异常情况。
创建任务
进入DevEco Testing客户端，在左侧菜单栏选择“功耗基础质量测试”，点击“功耗基础质量测试”服务卡片，即进入任务创建界面。按需配置任务参数，点击创建任务即开始测试。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151212.47850387099658667621349210266672:50001231000000:2800:9F62EEDF5D66EBBFFBDDC7CB4ABA58452EA2B8B06080170C29DDC9DEE222F236.png)
测试执行
创建任务后，将会跳转到执行页，进入测试环境初始化阶段。测试过程中，在测试页面可以看到测试进度、实时投屏、检测规则及执行日志。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151212.59775096809801263870355780305431:50001231000000:2800:580B9B1873ACBFD1AD5417BAE1EC934332048D83F4A8BDEBB51922390F46140D.png)
查看报告
测试完成后，自动生成测试报告。功耗基础质量测试报告如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151212.25509707764228759678499207181456:50001231000000:2800:303057CA20AE8ECA71A80998F898DC759097EC2171D0EF7D557BC21336332A04.png)
报告包含任务信息、执行结果、问题统计、检测规则。支持查看当前应用信息、任务执行时长，及详细的环境参数（配置信息及环境信息），支持导出 html 的报告文件。测试概览中，可查看执行结果、问题统计及检测规则。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151212.30565209917261065863112119538826:50001231000000:2800:DD9163FCFDB02F177DE88F87B16C01CC2A148FAC129B41C11898B6FE2351F67D.png)
对于检测不通过及检测异常的规则项，点击查看详情即可查看异常问题详情，包含检测项概览、测试截图、问题列表。对于异常问题，可根据测试截图、问题描述及发生时间，结合 hilog 日志，进一步定位分析。
检测规则
*更多检测规则详情，请前往DevEco Testing客户端-应用基础质量测试-功耗基础质量测试-任务创建页-测试指南中查询。
*更多应用功耗优化建议及问题定位，请查阅：应用功耗体验建议及最佳实践-功耗
常见问题
Q1：测试报告中，为什么会出现检测异常及不涉及检测项？
A1：可能是系统版本配套原因，请选手机系统为HarmonyOS NEXT Developer Beta 1(3.0.0.25)及以上版本进行测试。其他类型设备及系统测试报告中或出现检测异常。
设备断连会影响测试结果，可能出现检测异常及待检测项，请确保测试过程中设备正常连接。
Q2：测试报告中，为什么会批量出现待检测项？
A2：偶现由于测试任务内部异常导致任务终止，请查看【测试报告-执行日志】，若应用信息为空，请再次创建任务执行测试。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151212.18731405044461276200290019750790:50001231000000:2800:913848F783D6BCA908934BD66118163E1C184F6C5AC89969AD91CF69D4D59DD4.png)
该问题为应用信息暂未解析完创建任务导致，再次创建任务时，请等待右侧应用信息加载完成后再创建，即可解决该问题。
应用探索测试
应用探索测试：针对应用稳定性测试，DevEco Testing提供基于专家经验的智能遍历手段，借助智能AI实现场景智能感知及控件语义分析，驱动测试高效执行。支持自定义测试模型，构建应用特征图谱，结合应用模型持续训练，推动遍历执行持续优化，帮助用户识别应用故障问题及定位问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151212.23683275984250465532308327237786:50001231000000:2800:F48DFF079731E3E52B68D6D7534A08A3DC02CD5CC26ACB57AB865849B8B514F6.png)
创建任务
进入DevEco Testing客户端，在左侧菜单栏选择“稳定性测试”，点击“应用探索测试”服务卡片，即进入任务创建界面。按需配置任务参数，点击创建任务即开始测试。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151212.16759123262226171745113341112252:50001231000000:2800:5BC4E6821CE23EE92678A44AD7D57034F76D378EBA3C7CC00FCBDA76E739577E.png)
模型选择：初次创建任务时，默认为无模型；后续创建任务，将自动生成遍历模型，可选择已有模型，辅助提升遍历效率。
截屏时间：截屏时间按需选择，截屏间隔越短，路径地图中的截图数量相对越多。
归档包名：每次任务结束后，将基于本次测试过程生成遍历测试模型，将自动存储至本地数据路径下的testGraph\exploreTest文件夹中，可供后续应用探索测试及UX基础质量测试高级配置场景下使用。
*可前往DevEco Testing客户端-设置-基本设置中修改数据路径。
测试执行
任务创建后即进入测试执行页面，测试过程中，在测试页面可以看到测试进度、遍历路径地图、设备镜像、及语义分析过程。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151212.37874383844384037827758152244432:50001231000000:2800:4779579D4913DACCB21AF7D89A51A67EE11EFE18C8DA336F345554C95E4902FA.png)
以上图购物类应用为例，测试过程中，会对应用界面上的控件进行实时的语义分析，推断出每个控件代表的具体含义（分类、订单、添加、支付），结合对场景的智能感知，识别出当前正在对购物场景进行测试，据此生成对应的测试意图，如浏览商品、购物车结算等，驱动测试高效执行。
语义分析：智能AI将自动为界面控件排序，测试过程将参照顺序执行。测试执行中支持用户暂停或启动语义分析，语义分析暂停时，任务会继续执行，直至任务时间结束。
测试报告
任务结束后，应用探索测试报告如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151212.44070966001331984963051407830954:50001231000000:2800:2187A833671FC1780ECDA2F8FE762D3F3672B7D9E991B7D2E1E2FAF85B29B30E.png)
测试报告支持查看任务信息、报告概览、遍历地图及问题列表。问题列表将分类展示测试过程中出现的问题信息，支持查看问题对应故障的概要信息及定位日志。
*更多故障日志分析，请前往DevEco Testing客户端-应用稳定性测试-应用探索测试-任务创建页-测试指南中查询。
*更多应用稳定性体验优化建议及问题定位，请查阅：应用稳定性体验建议及CppCrash故障定位指导
常见问题：
Q1：测试过程中，为什么测试页面截图会出现为页面切换状态？
A1：在遍历操作过程中，对页面的滑动操作与截图操作并不是完全同步的，测试截图时，存在小概率会截取页面正在切换的过程，该场景为正常情况，不影响应用探索测试整体功能。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151212.84600618308501476135043169569381:50001231000000:2800:F53DDA9DA28AB5B7CB78CC9E62CA5A0EFEDEAD452B3D09924F9F6C1D195ECF2A.png)
Q2：测试过程中，控件语义识别中的“XXX的项”、“XXX的列”应如何理解？
A2：当前应用页面元素被分解为菜单、频道、列表等元素，当AI模型识别到相似的元素，会自动归一为测试等价类，对于同一个列表里的多个元素，则都会被视为同一类项。
Q3：设备断连后重连设备，投屏页面为什么不刷新？
A3：设备断连后重连设备，投屏或会停留在断连前的页面，不跟随设备页面切换而更新。该问题不影响本次测试继续执行，将在后续版本中修复。
Q4：遍历路径地图中，为什么会出现截图相同的节点？
A4：当前节点的判断根据页面layout确定，系统会根据各个页面的layout生成唯一节点。部分节点看起来截图相同，实际上它们的layout信息不同。
Q5：语义分析的过程中，为什么会对空白区域（看不到有按钮或文字）进行红框标记？
A5：系统会根据当前页面的layout信息对控件进行标记，控件分为可见控件及不可见控件，空白区域内或存在不可见的控件，为测试正常执行过程。
Q6：查看应用探索测试报告时，报告加载卡顿的原因是什么？
A6：由于探索测试执行时间比较长，会产生大量的报告数据，当报告节点过多时，或出现报告资源加载卡顿，可关闭客户端重启尝试恢复。
Q7：应用中嵌入了 Web窗口，能进行应用探索测试吗？
A7：当前已支持Web类应用测试。当前页面遍历层级限制为8层，若测试场景页面层级大于8，将无法进一步遍历。
Q8：应用为什么无法进行应用探索测试？
A8：若发现应用界面控件无法点击，请使用DevEco Testing 实用工具-UIViewer打开该应用界面，逐层点击该页面控件树排查：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151213.89709802209597901053052717457089:50001231000000:2800:C10A7F063A482DB5E5C37975CE7F91F12DC4930A51F406EB6C8BB6FEB9054747.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151213.29532464709738006178858022266160:50001231000000:2800:35759A6EE5F5E793630F19DD08F299F5ABC1760761BA111EBB6A6BF597669100.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-analysis
爬取时间: 2025-05-01 09:05:18
来源: Huawei Developer
稳定性分析将稳定性划分为地址越界、资源泄漏、应用无响应和应用崩溃四大类。对于每一类，最佳实践提供了该类型常见问题的排查方法，为分析实际问题提供思路；同时，针对每一类提供了相应的案例分析，对排查方法和思路进行实例化，引导开发者运用相应的排查方法和相关工具定位解决稳定性问题。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-fault-log
爬取时间: 2025-05-01 09:05:33
来源: Huawei Developer
本章节列举了常见的稳定性故障类型及相关faultlog规格实例

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-fault-type
爬取时间: 2025-05-01 09:05:46
来源: Huawei Developer
应用崩溃
CppCrash
应用崩溃指的是C/C++运行时崩溃，CppCrash进程崩溃检测基于操作系统信号机制，目前支持对以下崩溃信号的处理：
| 信号值(signo)  | 信号  | 解释  | 触发原因  |
| --- | --- | --- | --- |
| 4  | SIGILL  | 非法指令。  | 进程执行了非法、格式错误、未知或特权指令。  |
| 5  | SIGTRAP  | 断点或陷阱异常。  | 异常或trap指令发生。  |
| 6  | SIGABRT  | 进程终止。  | 进程异常终止，通常为进程自身调用标准函数库的abort()函数。  |
| 7  | SIGBUS  | 非法内存访问。  | 进程访问了对齐或者不存在的物理地址。  |
| 8  | SIGFPE  | 浮点异常。  | 进程执行了错误的算术运算，如除数为0、浮点溢出、整数溢出等。  |
| 11  | SIGSEGV  | 无效内存访问。  | 进程访问了无效内存引用。  |
| 16  | SIGSTKFLT  | 栈错误。  | 处理器执行了错误的栈操作，如栈空时弹出、栈满时压入。  |
| 31  | SIGSYS  | 错误的系统调用。  | 系统调用时使用了错误或非法参数。  |
信号值(signo)
信号
解释
触发原因
4
SIGILL
非法指令。
进程执行了非法、格式错误、未知或特权指令。
5
SIGTRAP
断点或陷阱异常。
异常或trap指令发生。
6
SIGABRT
进程终止。
进程异常终止，通常为进程自身调用标准函数库的abort()函数。
7
SIGBUS
非法内存访问。
进程访问了对齐或者不存在的物理地址。
8
SIGFPE
浮点异常。
进程执行了错误的算术运算，如除数为0、浮点溢出、整数溢出等。
11
SIGSEGV
无效内存访问。
进程访问了无效内存引用。
16
SIGSTKFLT
栈错误。
处理器执行了错误的栈操作，如栈空时弹出、栈满时压入。
31
SIGSYS
错误的系统调用。
系统调用时使用了错误或非法参数。
以上部分故障信号，根据具体的场景还有二级分类(code)： SIGILL是一个在Unix和类Unix操作系统中的信号，它表示非法指令异常。SIGILL信号通常由以下几种类型的问题场景引起：
| 二级分类  | 信号字符串  | 解释  | 触发原因  |
| --- | --- | --- | --- |
| 1  | ILL_ILLOPC  | 非法操作码异常  | 这种异常通常发生在执行不被CPU支持的指令时，或者在尝试执行特权指令时。  |
| 2  | ILL_ILLOPN  | 非法操作数异常  | 这种异常通常发生在指令使用了不正确的操作数，或者是操作数的类型不正确时。  |
| 3  | ILL_ILLADR  | 非法地址异常  | 这种异常通常发生在程序尝试访问无效的内存地址时，或者是在尝试执行未对齐的内存访问时。  |
| 4  | ILL_ILLTRP  | 非法陷阱异常  | 这种异常通常发生在程序尝试执行一个非法的陷阱指令时，或者是在尝试执行一个未定义的操作时。  |
| 5  | ILL_PRVOPC  | 特权操作码异常  | 这种异常通常发生在普通用户尝试执行特权指令时。  |
| 6  | ILL_PRVREG  | 特权寄存器异常  | 这种异常通常发生在普通用户尝试访问特权寄存器时。  |
| 7  | ILL_COPROC  | 协处理器异常  | 这种异常通常发生在程序尝试使用未定义的协处理器指令时。  |
| 8  | ILL_BADSTK  | 无效的堆栈异常  | 这种异常通常发生在程序尝试在无效的堆栈地址上执行操作时，或者是在堆栈溢出时。  |
二级分类
信号字符串
解释
触发原因
1
ILL_ILLOPC
非法操作码异常
这种异常通常发生在执行不被CPU支持的指令时，或者在尝试执行特权指令时。
2
ILL_ILLOPN
非法操作数异常
这种异常通常发生在指令使用了不正确的操作数，或者是操作数的类型不正确时。
3
ILL_ILLADR
非法地址异常
这种异常通常发生在程序尝试访问无效的内存地址时，或者是在尝试执行未对齐的内存访问时。
4
ILL_ILLTRP
非法陷阱异常
这种异常通常发生在程序尝试执行一个非法的陷阱指令时，或者是在尝试执行一个未定义的操作时。
5
ILL_PRVOPC
特权操作码异常
这种异常通常发生在普通用户尝试执行特权指令时。
6
ILL_PRVREG
特权寄存器异常
这种异常通常发生在普通用户尝试访问特权寄存器时。
7
ILL_COPROC
协处理器异常
这种异常通常发生在程序尝试使用未定义的协处理器指令时。
8
ILL_BADSTK
无效的堆栈异常
这种异常通常发生在程序尝试在无效的堆栈地址上执行操作时，或者是在堆栈溢出时。
SIGTRAP信号通常用于调试和跟踪程序的执行。下面是上面列出的四种SIGTRAP信号类别的问题场景介绍：
| 二级分类  | 信号字符串  | 解释  | 触发原因  |
| --- | --- | --- | --- |
| 1  | TRAP_BRKPT  | 软件断点  | 这个信号是由软件断点引起的，当程序执行到设置的断点时会触发该信号。软件断点通常用于调试程序，可以在程序的关键位置设置断点，以便在调试时暂停程序的执行并检查变量值等信息。  |
| 2  | TRAP_TRACE  | 单步调试  | 这个信号是由单步执行引起的，当程序执行单个指令时会触发该信号。单步执行通常用于调试程序，可以逐步执行程序并检查每个指令的执行结果。  |
| 3  | TRAP_BRANCH  | 分支跟踪  | 这个信号是由分支指令引起的，当程序执行分支指令时会触发该信号。分支指令通常用于控制程序的执行流程，例如if语句和循环语句等。  |
| 4  | TRAP_HWBKPT  | 硬件断点  | 这个信号是由硬件断点引起的，当程序执行到设置的硬件断点时会触发该信号。硬件断点通常用于调试程序，可以在程序的关键位置设置断点，以便在调试时暂停程序的执行并检查变量值等信息。与软件断点不同的是，硬件断点是由CPU硬件实现的，因此可以在程序执行过程中实时检测断点是否被触发。  |
二级分类
信号字符串
解释
触发原因
1
TRAP_BRKPT
软件断点
这个信号是由软件断点引起的，当程序执行到设置的断点时会触发该信号。软件断点通常用于调试程序，可以在程序的关键位置设置断点，以便在调试时暂停程序的执行并检查变量值等信息。
2
TRAP_TRACE
单步调试
这个信号是由单步执行引起的，当程序执行单个指令时会触发该信号。单步执行通常用于调试程序，可以逐步执行程序并检查每个指令的执行结果。
3
TRAP_BRANCH
分支跟踪
这个信号是由分支指令引起的，当程序执行分支指令时会触发该信号。分支指令通常用于控制程序的执行流程，例如if语句和循环语句等。
4
TRAP_HWBKPT
硬件断点
这个信号是由硬件断点引起的，当程序执行到设置的硬件断点时会触发该信号。硬件断点通常用于调试程序，可以在程序的关键位置设置断点，以便在调试时暂停程序的执行并检查变量值等信息。与软件断点不同的是，硬件断点是由CPU硬件实现的，因此可以在程序执行过程中实时检测断点是否被触发。
SIGBUS是一种由操作系统向进程发送的信号，通常表示内存访问错误。其中，不同的信号类别表示不同的错误场景：
| 二级分类  | 信号字符串  | 解释  | 触发原因  |
| --- | --- | --- | --- |
| 1  | BUS_ADRALN  | 内存地址对齐错误  | 这种错误通常发生在尝试访问未对齐的内存地址时，例如尝试访问一个4字节整数的非偶数地址。  |
| 2  | BUS_ADRERR  | 非法内存地址错误  | 这种错误通常发生在尝试访问不属于进程地址空间的内存地址时，例如尝试访问一个空指针。  |
| 3  | BUS_OBJERR  | 对象访问错误  | 这种错误通常发生在尝试访问一个已经被删除或未初始化的对象时。  |
| 4  | BUS_MCEERR_AR  | 硬件内存校验错误  | 发生在访问内存时检测到校验和错误。  |
| 5  | BUS_MCEERR_AO  | 硬件内存校验错误  | 发生在访问内存时检测到地址和校验和错误。  |
二级分类
信号字符串
解释
触发原因
1
BUS_ADRALN
内存地址对齐错误
这种错误通常发生在尝试访问未对齐的内存地址时，例如尝试访问一个4字节整数的非偶数地址。
2
BUS_ADRERR
非法内存地址错误
这种错误通常发生在尝试访问不属于进程地址空间的内存地址时，例如尝试访问一个空指针。
3
BUS_OBJERR
对象访问错误
这种错误通常发生在尝试访问一个已经被删除或未初始化的对象时。
4
BUS_MCEERR_AR
硬件内存校验错误
发生在访问内存时检测到校验和错误。
5
BUS_MCEERR_AO
硬件内存校验错误
发生在访问内存时检测到地址和校验和错误。
SIGFPE是一个信号，它表示浮点异常或算术异常。下面是这些SIGFPE信号类别的问题场景：
| 二级分类  | 信号字符串  | 解释  | 触发原因  |
| --- | --- | --- | --- |
| 1  | FPE_INTDIV  | 整数除法错误  | 这个信号表示整数除法中的除数为零的情况。当一个程序尝试进行整数除法，但除数为零时，会发出这个信号。  |
| 2  | FPE_INTOVF  | 整数溢出错误  | 这个信号表示整数除法中的除数为负数的情况。当一个程序尝试进行整数除法，但除数为负数时，会发出这个信号。  |
| 3  | FPE_FLTDIV  | 浮点除法错误  | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。  |
| 4  | FPE_FLTOVF  | 浮点溢出错误  | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。  |
| 5  | FPE_FLTUND  | 浮点下溢错误  | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。  |
| 6  | FPE_FLTRES  | 浮点结果未定义错误  | 这个信号表示浮点数除法中的除数为正数的情况。当一个程序尝试进行浮点数除法，但除数为正数时，会发出这个信号。  |
| 7  | FPE_FLTINV  | 无效浮点操作错误  | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。  |
| 8  | FPE_FLTSUB  | 浮点陷阱错误  | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。  |
二级分类
信号字符串
解释
触发原因
1
FPE_INTDIV
整数除法错误
这个信号表示整数除法中的除数为零的情况。当一个程序尝试进行整数除法，但除数为零时，会发出这个信号。
2
FPE_INTOVF
整数溢出错误
这个信号表示整数除法中的除数为负数的情况。当一个程序尝试进行整数除法，但除数为负数时，会发出这个信号。
3
FPE_FLTDIV
浮点除法错误
这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。
4
FPE_FLTOVF
浮点溢出错误
这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。
5
FPE_FLTUND
浮点下溢错误
这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。
6
FPE_FLTRES
浮点结果未定义错误
这个信号表示浮点数除法中的除数为正数的情况。当一个程序尝试进行浮点数除法，但除数为正数时，会发出这个信号。
7
FPE_FLTINV
无效浮点操作错误
这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。
8
FPE_FLTSUB
浮点陷阱错误
这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。
SIGSEGV是一种信号，它表示进程试图访问一个不属于它的内存地址，或者试图访问一个已被操作系统标记为不可访问的内存地址。SIGSEGV信号通常是由以下两种情况引起的：
| 二级分类  | 信号字符串  | 解释  | 触发原因  |
| --- | --- | --- | --- |
| 1  | SEGV_MAPERR  | 不存在的内存地址  | 进程试图访问一个不存在的内存地址，或者试图访问一个没有映射到进程地址空间的内存地址。这种情况通常是由于程序中的指针错误或内存泄漏引起的。  |
| 2  | SEGV_ACCERR  | 不可访问的内存地址  | 进程试图访问一个已被操作系统标记为不可访问的内存地址，例如只读内存或没有执行权限的内存。这种情况通常是由于程序中的缓冲区溢出或者试图修改只读内存等错误引起的。  |
二级分类
信号字符串
解释
触发原因
1
SEGV_MAPERR
不存在的内存地址
进程试图访问一个不存在的内存地址，或者试图访问一个没有映射到进程地址空间的内存地址。这种情况通常是由于程序中的指针错误或内存泄漏引起的。
2
SEGV_ACCERR
不可访问的内存地址
进程试图访问一个已被操作系统标记为不可访问的内存地址，例如只读内存或没有执行权限的内存。这种情况通常是由于程序中的缓冲区溢出或者试图修改只读内存等错误引起的。
二级分类(code)除了以上根据信号值(signo)维度分类，还可以根据信号产生的原因维度分类。其中根据信号值(signo)维度分类是每个信号值(signo)特有的，根据信号产生的原因维度分类是所有信号值(signo)共有的，当前已有信号产生原因分类的code值如下：
| 二级分类  | 信号字符串  | 解释  | 触发原因  |
| --- | --- | --- | --- |
| 0  | SI_USER  | 用户空间信号  | 该信号是由用户空间的进程发送给另一个进程的，通常是通过 kill() 系统调用发送的。例如，当用户在终端中按下Ctrl+C时，会发送一个SIGINT信号给前台进程组中的所有进程。  |
| 0x80  | SI_KERNEL  | 内核信号  | 该信号是由内核发送给进程的，通常是由内核检测到某些错误或异常情况时发出的。例如，当进程访问无效的内存地址或者执行非法指令时，内核会发送一个SIGSEGV信号给进程。  |
| -1  | SI_QUEUE  | sigqueue()函数信号  | 该信号是由sigqueue()系统调用发送的，可以携带一个附加的整数值和一个指针。通常用于进程间高级通信，例如传递数据或者通知进程某个事件已经发生。  |
| -2  | SI_TIMER  | 定时器信号  | 该信号是由定时器发送的，通常用于定时任务或者周期性任务的执行。例如，当一个定时器到期时，内核会向进程发送一个SIGALRM信号。  |
| -3  | SI_MESGQ  | 消息队列信号  | 该信号是由消息队列发送的，通常用于进程间通信。例如，当一个进程向一个消息队列发送消息时，内核会向接收进程发送一个SIGIO信号。  |
| -4  | SI_ASYNCIO  | 异步I/O信号  | 该信号是由异步I/O操作发送的，通常用于非阻塞I/O操作。例如，当一个文件描述符上的I/O操作完成时，内核会向进程发送一个SIGIO信号。  |
| -5  | SI_SIGIO  | 同步I/O信号  | 该信号是由异步I/O操作发送的，通常用于非阻塞I/O操作。例如，当一个文件描述符上的I/O操作完成时，内核会向进程发送一个SIGIO信号。  |
| -6  | SI_TKILL  | tkill()函数信号  | 该信号是由tkill()系统调用发送的，与kill()系统调用类似，但是可以指定发送信号的线程ID。通常用于多线程程序中，向指定线程发送信号。  |
二级分类
信号字符串
解释
触发原因
0
SI_USER
用户空间信号
该信号是由用户空间的进程发送给另一个进程的，通常是通过 kill() 系统调用发送的。例如，当用户在终端中按下Ctrl+C时，会发送一个SIGINT信号给前台进程组中的所有进程。
0x80
SI_KERNEL
内核信号
该信号是由内核发送给进程的，通常是由内核检测到某些错误或异常情况时发出的。例如，当进程访问无效的内存地址或者执行非法指令时，内核会发送一个SIGSEGV信号给进程。
-1
SI_QUEUE
sigqueue()函数信号
该信号是由sigqueue()系统调用发送的，可以携带一个附加的整数值和一个指针。通常用于进程间高级通信，例如传递数据或者通知进程某个事件已经发生。
-2
SI_TIMER
定时器信号
该信号是由定时器发送的，通常用于定时任务或者周期性任务的执行。例如，当一个定时器到期时，内核会向进程发送一个SIGALRM信号。
-3
SI_MESGQ
消息队列信号
该信号是由消息队列发送的，通常用于进程间通信。例如，当一个进程向一个消息队列发送消息时，内核会向接收进程发送一个SIGIO信号。
-4
SI_ASYNCIO
异步I/O信号
该信号是由异步I/O操作发送的，通常用于非阻塞I/O操作。例如，当一个文件描述符上的I/O操作完成时，内核会向进程发送一个SIGIO信号。
-5
SI_SIGIO
同步I/O信号
该信号是由异步I/O操作发送的，通常用于非阻塞I/O操作。例如，当一个文件描述符上的I/O操作完成时，内核会向进程发送一个SIGIO信号。
-6
SI_TKILL
tkill()函数信号
该信号是由tkill()系统调用发送的，与kill()系统调用类似，但是可以指定发送信号的线程ID。通常用于多线程程序中，向指定线程发送信号。
JS Crash
处理的JS异常导致应用意外退出时，表现为应用崩溃。
JS Crash异常根据不同的异常场景，在 Reason 字段进行了分类，分为Error、TypeError、SyntaxError、RangeError等错误类型。
应用无响应
用户在使用应用时会出现点击没反应、应用无响应等情况，其超过一定时间限制后即被定义为应用无响应(appfreeze)。系统提供了检测应用无响应的机制，并生成appfreeze日志供应用开发分析。
目前应用无响应检测从以下维度检测:
| 故障类型  | 说明  | 故障检测时长  |
| --- | --- | --- |
| THREAD_BLOCK_6S  | 应用主线程卡死超时  | 前台应用：6s 后台应用：3s * 5 + 6s = 21s  |
| APP_INPUT_BLOCK  | 用户输入响应超时  | 5s  |
| LIFECYCLE_TIMEOUT  | UIAbility生命周期切换超时  | Load：10s Foreground：5sBackground：3s Terminate：10s  |
故障类型
说明
故障检测时长
THREAD_BLOCK_6S
应用主线程卡死超时
前台应用：6s
后台应用：3s * 5 + 6s = 21s
APP_INPUT_BLOCK
用户输入响应超时
5s
LIFECYCLE_TIMEOUT
UIAbility生命周期切换超时
Load：10s
Foreground：5sBackground：3s
Terminate：10s
*注：THREAD_BLOCK_6S、LIFECYCLE_TIMEOUT 存在半生命周期检测(THREAD_BLOCK_3S、LIFECYCLE_HALF_TIMEOUT)，其检测时长为相应的一半；以下称之为warning事件和block事件。
资源泄漏
资源泄漏是指句柄/线程/内存等资源超过系统设定上限，部分资源甚至失去了管控能力，此时系统可能出现卡死/重启等异常情况。LeakDetector模块提供资源泄漏检测、判决、维测日志抓取、日志上报的能力，为开发者提供详细的维测日志以辅助故障定位。
| 泄漏类型  | 检测机制  |
| --- | --- |
| 句柄泄漏（FD_LEAK）  | 60s一次遍历进程，获取进程fd句柄总数，超过阈值（5000个）时抓取详细句柄信息，同步上报泄漏  |
| 线程泄漏（THREAD_LEAK）  | 60s一次遍历进程，获取进程的总线程数，超过阈值（700个）时抓取详细线程名信息，同步上报泄漏  |
| 内存泄漏（MEMORY_LEAK）  | js泄漏（JS_LEAK）  | 虚拟机内部进行插桩，当heap使用量超过85% 或者 触发OOM时会抓取heapdump，同步上报该故障  |
| native内存泄漏（PSS_MEMORY）  | 以应用进程平均动态峰值内存作为基线，60s一次轮询监控，当动态内存峰值超过基线值2倍，判定泄漏，同时触发管控。  |
| ashmem/ion/gpu等内存泄漏 （KERNEL_MEMORY）  | 基于ashmem/ion/gpu的基线值，超过基线值时会判定泄漏，同步抓取维测信息  |
泄漏类型
检测机制
句柄泄漏（FD_LEAK）
60s一次遍历进程，获取进程fd句柄总数，超过阈值（5000个）时抓取详细句柄信息，同步上报泄漏
线程泄漏（THREAD_LEAK）
60s一次遍历进程，获取进程的总线程数，超过阈值（700个）时抓取详细线程名信息，同步上报泄漏
内存泄漏（MEMORY_LEAK）
js泄漏（JS_LEAK）
虚拟机内部进行插桩，当heap使用量超过85% 或者 触发OOM时会抓取heapdump，同步上报该故障
native内存泄漏（PSS_MEMORY）
以应用进程平均动态峰值内存作为基线，60s一次轮询监控，当动态内存峰值超过基线值2倍，判定泄漏，同时触发管控。
ashmem/ion/gpu等内存泄漏 （KERNEL_MEMORY）
基于ashmem/ion/gpu的基线值，超过基线值时会判定泄漏，同步抓取维测信息
以上使用的基线都是默认设置，如果生态在开发过程中需要自行设定基线，可以参考生态通过API接口设置基线文档使用。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-log-specs
爬取时间: 2025-05-01 09:06:00
来源: Huawei Developer
应用崩溃
CppCrash
通过Shell获取的/data/log/faultlog/temp获取到的日志内容格式如下：
日志格式 - 栈溢出故障场景 该场景会在日志中打印出提示信息，表明故障很有可能是因为栈溢出导致。核心日志如下：
日志格式 - 栈覆盖故障场景 在栈覆盖场景下，由于栈上内存被踩，无法成功回溯栈帧，该场景会在日志中打印出提示信息，说明回栈失败并尝试从线程栈里解析获取不可靠的调用栈，尽可能提供开发者信息以分析问题。核心日志如下：
日志格式 - 异步线程场景故障 （目前支持ARM64架构，且在调试应用（HAP_DEBUGGABLE）下开启） 当异步线程发生崩溃后，把提交该异步任务的线程的栈也打印出来，帮助定位由于异步任务提交者造成的崩溃问题。崩溃线程的调用栈和其提交线程的调用栈用SubmitterStacktrace分割开。核心日志如下：
JsCrash
JsCrash日志结构及含义如下：
应用无响应
公共头部信息
该部分提供所有故障类型通用的基本信息
示例:
关键字段说明：
| 字段名  | 描述  | 备注  |
| --- | --- | --- |
| Device info  | 产品信息  |    |
| Build info  | 版本信息  |    |
| Fingerprint  | 故障特征  |    |
| Module name  | 故障模块名  |    |
| Version  | 故障模块版本信息  |    |
| PreInstalled  | 故障模块是否为预装应用  |    |
| Foreground  | 故障模块当前是否位于前台  |    |
| Pid  | 故障模块进程号  |    |
| Uid  | 故障模块唯一标识  |    |
| Reason  | 故障原因  | 故障类型  |
| DisplayPowerInfo  | 设备亮灭屏状态  |    |
字段名
描述
备注
Device info
产品信息
Build info
版本信息
Fingerprint
故障特征
Module name
故障模块名
Version
故障模块版本信息
PreInstalled
故障模块是否为预装应用
Foreground
故障模块当前是否位于前台
Pid
故障模块进程号
Uid
故障模块唯一标识
Reason
故障原因
故障类型
DisplayPowerInfo
设备亮灭屏状态
日志拼接信息
该部分表示拼接日志的起始。
示例：
关键字段说明：
| 字段名  | 描述  | 备注  |
| --- | --- | --- |
| STRINGID  | 故障类型  |    |
| TIMESTAMP  | block事件上报到DFX系统的时间  |    |
| PACKAGE_NAME  | 故障模块包名  |    |
| PROCESS_NAME  | 故障模块进程名  | 超过15字符会被截取，service 取前侧，应用取后侧  |
字段名
描述
备注
STRINGID
故障类型
TIMESTAMP
block事件上报到DFX系统的时间
PACKAGE_NAME
故障模块包名
PROCESS_NAME
故障模块进程名
超过15字符会被截取，service 取前侧，应用取后侧
由于 THREAD_BLOCK、LIFECYCLE_TIMEOUT 存在半周期检测，其故障日志由两份半周期检测生成的故障日志拼接而成，其中前半周期检测日志位于故障日志的前侧
单故障事件信息
该部分表示独立事件完整的故障打包信息。
其形成以事件为单位，例如 THREAD_BLOCK 有 THREAD_BLOCK_3S、THREAD_BLOCK_6S 两个事件，即会生成两份单故障事件日志
示例：
关键字段说明：
| 字段名  | 描述  | 备注  |
| --- | --- | --- |
| start time  | 故障日志信息开始收集时间  |    |
| EVENTNAME  | 故障类型  |    |
| TIMESTAMP  | 故障事件上报到DFX系统的时间  |    |
| PID  | 故障模块进程号  |    |
| UID  | 故障模块进程唯一标识  |    |
| TID  | 故障模块卡死线程号  |    |
| PACKAGE_NAME  | 故障模块包名  |    |
| PROCESS_NAME  | 故障模块进程名  |    |
| eventLog_action  | 故障信息采集动作集合  |    |
| eventLog_interval  | 故障连续上报频次限流  |    |
| MSG  | 故障信息  | 主要为 Eventhandler dump 信息  |
| STACK  | 故障模块进程卡死时堆栈信息  |    |
| PeerBinderCatcher  | 进程间IPC通信信息  |    |
| MemoryCatcher  | 整机Memory信息  |    |
| catcher cmd: hidumper --cpuusage  | 整机CPU信息  |    |
| catcher cmd: hilog -z 1000 -P  | 进程最近输出的1000条流水信息  |    |
| ...  |    | 不同日志有不同的信息采集内容  |
| Catcher log total time is  | 信息采集耗时  |    |
字段名
描述
备注
start time
故障日志信息开始收集时间
EVENTNAME
故障类型
TIMESTAMP
故障事件上报到DFX系统的时间
PID
故障模块进程号
UID
故障模块进程唯一标识
TID
故障模块卡死线程号
PACKAGE_NAME
故障模块包名
PROCESS_NAME
故障模块进程名
eventLog_action
故障信息采集动作集合
eventLog_interval
故障连续上报频次限流
MSG
故障信息
主要为 Eventhandler dump 信息
STACK
故障模块进程卡死时堆栈信息
PeerBinderCatcher
进程间IPC通信信息
MemoryCatcher
整机Memory信息
catcher cmd: hidumper --cpuusage
整机CPU信息
catcher cmd: hilog -z 1000 -P
进程最近输出的1000条流水信息
...
不同日志有不同的信息采集内容
Catcher log total time is
信息采集耗时
MSG示例：
组成结构：
| 字段名  | 描述  | 备注  |
| --- | --- | --- |
| Fault time  | 故障上报时间  | 此处最接近真实故障上报点  |
| reason  | THREAD_BLOCK_6S：App main thread is not response! APP_INPUT_BLOCK：User input does not respond! LIFECYCLE_TIMEOUT：ability:<abilityName> <LifeCycle> timeout.  | 主线程无响应 用户输入无响应 ability名称和异常的生命周期  |
| mainHandler dump is  | 应用主线程的EventHandler dump信息  |    |
字段名
描述
备注
Fault time
故障上报时间
此处最接近真实故障上报点
reason
THREAD_BLOCK_6S：App main thread is not response!
APP_INPUT_BLOCK：User input does not respond!
LIFECYCLE_TIMEOUT：ability:<abilityName> <LifeCycle> timeout.
主线程无响应
用户输入无响应
ability名称和异常的生命周期
mainHandler dump is
应用主线程的EventHandler dump信息
EventHandler的dump信息组成结构：
| 字段名  | 描述  | 备注  |
| --- | --- | --- |
| EventHandler dump begin curTime  | 获取dump信息时间  |    |
| Event runner  | Eventhandler对应的线程名和线程号  |    |
| Current Running  | 当前正在执行的完整任务信息  |    |
| History event queue information  | 历史执行任务信息  | 此处为循环列表，最大记录32个 从 completeTime time 为空来判断末尾端  |
| VIP priority event queue information  | VIP级任务队列信息  | 用户输入事件位于此队列，高优先级响应  |
| Immediate priority event queue information  | 立即执行任务队列信息  |    |
| High priority event queue information  | 高优先级任务队列信息  | watchdog任务位于此队列  |
| Low priority event queue information  | 低优先级任务队列信息  |    |
| Idle priority event queue information  | 挂起任务队列信息  |    |
字段名
描述
备注
EventHandler dump begin curTime
获取dump信息时间
Event runner
Eventhandler对应的线程名和线程号
Current Running
当前正在执行的完整任务信息
History event queue information
历史执行任务信息
此处为循环列表，最大记录32个
从 completeTime time 为空来判断末尾端
VIP priority event queue information
VIP级任务队列信息
用户输入事件位于此队列，高优先级响应
Immediate priority event queue information
立即执行任务队列信息
High priority event queue information
高优先级任务队列信息
watchdog任务位于此队列
Low priority event queue information
低优先级任务队列信息
Idle priority event queue information
挂起任务队列信息
任务组成部分：
| 字段名  | 描述  | 备注  |
| --- | --- | --- |
| send thread  | 提交任务线程号  |    |
| send time  | 提交任务时间  |    |
| handle time  | 预期执行时间  |    |
| trigger time  | 开始执行时间  |    |
| completeTime time  | 任务完成时间  | 正在执行的任务此字段为空  |
| priority  | 任务优先级  |    |
| caller  | 任务提交方法  |    |
| task name  | 任务名称  |    |
字段名
描述
备注
send thread
提交任务线程号
send time
提交任务时间
handle time
预期执行时间
trigger time
开始执行时间
completeTime time
任务完成时间
正在执行的任务此字段为空
priority
任务优先级
caller
任务提交方法
task name
任务名称
STACK示例：
通过搜索pid对应的数字找到应用栈信息。以下堆栈示例表明窗口通过IPC向系统发送事件时，停留在IPC通信阶段。
```shell
Timestamp:2017-08-0817:06:53.000
Pid:1561
Uid:20010039
Process name:com.ohos.huawei.myapplication
Tid:1561,Name:i.myapplication
# 00 pc 0017888c /system/lib/libark_jsruntime.so
# 01 pc 00025779 /system/lib/platformsdk/libipc_core.z.so(OHOS:BinderConnector:WriteBinder(unsigned Long,void*)+56)
# 02 pc 000265a5 /system/lib/platformsdk/libipc_core.z.so(OHOS:BinderInvoker:TransactWithDriver(bool)+216)
# 03 pc 0002666f /system/lib/platformsdk/libipc_core.z.so(OHOS:BinderInvoker:StartWorkLoop()+18)
# 04 pc 000270a9 /system/lib/platformsdk/libipc_core.z.so(OHOS:BinderInvoker:JoinThread(bool)+32)
# 05 pc 00023783 /system/lib/platformsdk/libipc_core.z.so(OHOS:IPCWorkThread:ThreadHandler(void*)+290)
# 06 pc 00e1c6f7 /system/lib/libace.z.so
# 07 pc 0091bbdd /system/lib/libace.z.so
# 08 pc 0092fd9d /system/lib/libace.z.so
# 09 pc 0092fa5f /system/lib/libace.z.so
# 10 pc 0092cd6b /system/lib/libace.z.so
# 11 pc 009326a9 /system/lib/libace.z.so
# 12 pc 0093054b /system/lib/libace.z.so
# 13 pc 009324f3 /system/lib/libace.z.so
# 14 pc 003989e1 /system/lib/libace.z.so
# 15 pc 0045dd4b /system/lib/libace.z.so
# 16 pc 00d24fef /system/lib/libace.z.so
# 17 pc 0041e6e9 /system/lib/libace.z.so
# 18 pc 0000b4d9 /system/lib/platformsdk/libeventhandler.z.so(OHOS:AppExecFwk:EventHandler:DistributeEvent(std::__h:unique_ptr<0 # 19 pc 00012829 /system/lib/platformsdk/libeventhandler.z.so
# 20 pc 00011841 /system/lib/platformsdk/libeventhandler.z.so(OHOS:AppExecFwk:EventRunner:Run()+64)
# 21 pc 00054a8b /system/lib/libappkit_native.z.so(OHOS:AppExecFwk:MainThread:Start()+278)
# 22 pc 00011503 /system/bin/appspawn
# 23 pc 0001141f /system/bin/appspawn
# 24 pc 0000ee97 /system/bin/appspawn
...
```
PeerBinderCatcher示例：
PeerBinderCatcher 组成结构：
| 字段名  | 描述  | 备注  |
| --- | --- | --- |
| BinderCatcher  | 整机Binder通信信息  |    |
| PeerBinder Stacktrace  | 对端堆栈信息  | 解析Binder，链式通信中进程栈抓取  |
字段名
描述
备注
BinderCatcher
整机Binder通信信息
PeerBinder Stacktrace
对端堆栈信息
解析Binder，链式通信中进程栈抓取
BinderCatcher：
通过搜索pid对应的数字找到当前进程与哪个进程在通信，同步的通信等待的时长。
示例表明当前1561进程向685进程请求通信，等待超过10s没有得到响应。
关键字段说明：
| 字段名  | 描述  | 备注  |
| --- | --- | --- |
| fromPid  | 客户端进程号  |    |
| fromTid  | 客户端线程号  |    |
| toPid  | 服务端进程号  |    |
| toTid  | 服务端线程号  |    |
| wait  | IPC通信等待时长  |    |
| request  | 当前IPC请求数  |    |
| started  | 应用已启动IPC线程数  |    |
| max  | 应用最大IPC线程数  |    |
| ready  | 应用当前可用IPC线程数  |    |
| free_async_space  | 应用 IPC buffer 剩余空间  |    |
字段名
描述
备注
fromPid
客户端进程号
fromTid
客户端线程号
toPid
服务端进程号
toTid
服务端线程号
wait
IPC通信等待时长
request
当前IPC请求数
started
应用已启动IPC线程数
max
应用最大IPC线程数
ready
应用当前可用IPC线程数
free_async_space
应用 IPC buffer 剩余空间
PeerBinder Stacktrace：
示例表明对端卡死进程685的堆栈信息。
cpuusage信息示例：
整机CPU信息。
memory信息示例：
整机memory信息。
资源泄漏
句柄泄漏规格
故障日志文件名：[pid]_fd_leak.txt（方式一） 或 RESOURCE_OVERLIMIT_[TIMESTAMP]_[PID].log（方式三）
日志头部信息
| 字段  | 说明  |
| --- | --- |
| time  | 故障发生时间  |
| pid  | 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息  |
| process  | 应用进程包名  |
| leaked fd nums  | 判定泄漏时获取的句柄数量 （快照）  |
字段
说明
time
故障发生时间
pid
发生故障进程的pid，可以用于在流水日志中搜索相关进程信息
process
应用进程包名
leaked fd nums
判定泄漏时获取的句柄数量 （快照）
句柄类型详细信息
Leaked fd Top 10：按照句柄名聚类，获取泄漏句柄中最多的类型，第一列为泄漏数量，第二列为泄漏类型，如下即ashmem类型的句柄存在1337个。
Dir Type Top 10：针对文件句柄类型，会单独根据文件路径聚类。如下，根据“Leaked fd Top 10”无法看出具体泄漏的类型，但是通过“Dir Type Top 10”能确定是"/data/storage/el2/database/rdb"路径下的文件句柄泄漏，且能大概感知是db泄漏。
特殊类型句柄维测信息
如果Leaked fd Top 10的 TOP句柄信息属于ashmem/socket/pipe/sync_file/dmabuf 这五类特殊类型，且该类型的句柄个数超过1000个，日志中会增加整机详细的维测信息，具体如下：
ashmem类型句柄
ashmem（即共享内存），如下，由于TOP 1的句柄类型为ashmem，此时抓取了整机ashmem内存的详细信息，里面每一行都是一个单独的ashmem块，具体转ashmem定位方法。
| 字段  | 说明  |
| --- | --- |
| Process_name  | 持有该ashmem内存块的应用进程包名  |
| Process_ID  | 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息  |
| Fd  | 该进程持有的句柄  |
| Applicant_Pid  | 申请该ashmem内存块的进程pid，可根据识别这个ashmem的来源  |
| Ashmem_name  | 共享内存的名字，由用户态通过ioctl设置，用来判断存储的资源类型，指向不同的领域  |
| Size  | 单个ashmem块的大小（单位：B）  |
字段
说明
Process_name
持有该ashmem内存块的应用进程包名
Process_ID
发生故障进程的pid，可以用于在流水日志中搜索相关进程信息
Fd
该进程持有的句柄
Applicant_Pid
申请该ashmem内存块的进程pid，可根据识别这个ashmem的来源
Ashmem_name
共享内存的名字，由用户态通过ioctl设置，用来判断存储的资源类型，指向不同的领域
Size
单个ashmem块的大小（单位：B）
socket类型句柄
socket通信，如下，由于TOP 1的句柄类型为socket，此时抓取了整机socket内存的详细信息。
| 字段  | 说明  |
| --- | --- |
| ProcessName  | 持有该socket内存块的应用进程包名  |
| ProcessID  | 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息  |
| Fd  | 该进程持有的句柄  |
| inode  | 文件系统对象信息  |
| PeerTid  | 对端tid（对于有连接的socket，无连接为0）  |
字段
说明
ProcessName
持有该socket内存块的应用进程包名
ProcessID
发生故障进程的pid，可以用于在流水日志中搜索相关进程信息
Fd
该进程持有的句柄
inode
文件系统对象信息
PeerTid
对端tid（对于有连接的socket，无连接为0）
pipe类型句柄
pipe通信，如下，由于TOP 1的句柄类型为pipe，此时以fd维度抓取了整机pipe内存的详细信息。
| 字段  | 说明  |
| --- | --- |
| ProcessName  | 持有该pipe内存块的应用进程包名  |
| ProcessID  | 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息  |
| Fd  | 该进程持有的句柄  |
| PipeName  | 管道名  |
| inode  | 文件系统对象信息  |
| MaxUsage  | 最大使用量  |
| NumAccounted  | 累计大小量  |
| RingSize  | RingBuf大小  |
字段
说明
ProcessName
持有该pipe内存块的应用进程包名
ProcessID
发生故障进程的pid，可以用于在流水日志中搜索相关进程信息
Fd
该进程持有的句柄
PipeName
管道名
inode
文件系统对象信息
MaxUsage
最大使用量
NumAccounted
累计大小量
RingSize
RingBuf大小
sync_file类型句柄
显存，如下，由于TOP 1的句柄类型为sync_file，此时以fd维度抓取了整机sync_file的详细信息。
| 字段  | 说明  |
| --- | --- |
| ProcessName  | 持有该sync_file内存块的应用进程包名  |
| ProcessID  | 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息  |
| Fd  | 该进程持有的句柄  |
| FenceName  | sync_file名字  |
| inode  | 文件系统对象信息  |
| FenceNum  | fence个数  |
| TimelineName  | fence的Timeline名字  |
| DriverName  | 驱动名字  |
| Status  | fence的状态  |
| Timestamp  | fence的时间戳  |
字段
说明
ProcessName
持有该sync_file内存块的应用进程包名
ProcessID
发生故障进程的pid，可以用于在流水日志中搜索相关进程信息
Fd
该进程持有的句柄
FenceName
sync_file名字
inode
文件系统对象信息
FenceNum
fence个数
TimelineName
fence的Timeline名字
DriverName
驱动名字
Status
fence的状态
Timestamp
fence的时间戳
dmabuf类型句柄
dmabuf，如下，由于TOP 1的句柄类型为dmabuf，此时以fd维度抓取了整机dmabuf的详细信息，magic相同表示指向同一块buffer。
| 字段  | 说明  |
| --- | --- |
| Process name  | 持有该ion内存块的应用进程包名  |
| Process ID  | 发生故障进程的pid，可以用于在流水日志中搜索相关进程信息  |
| Fd  | 该进程持有的句柄  |
| size  | buffer内存大小（单位：B）  |
| magic  | buffer唯一标识  |
| buf->pid  | 申请者的pid  |
| buf->task_comm  | 申请buffer的进程名  |
字段
说明
Process name
持有该ion内存块的应用进程包名
Process ID
发生故障进程的pid，可以用于在流水日志中搜索相关进程信息
Fd
该进程持有的句柄
size
buffer内存大小（单位：B）
magic
buffer唯一标识
buf->pid
申请者的pid
buf->task_comm
申请buffer的进程名
句柄栈信息
当判定句柄泄漏后，会hook 该进程的pipe/open等系统调用10分钟，抓取调用栈，并基于相同调用栈聚类。如下每一行都是一个调用栈，调用顺序为从右到左，其中num后面的数字表示这个调用栈总共有多少个，bt后面为具体调用栈。
具体栈信息可通过addr2line解析到对应的函数。
1、这里统计的是10分钟内全量申请句柄的调用栈，并没有将已经close的去掉
2、栈信息只有在log版本直接存在，nolog版本若未开“开发者模式”，则不抓取栈信息，如果发现不存在栈信息，可以打开开发者模式抓取。
线程泄漏日志规格
故障日志文件名：[pid]_thread_leak.txt （方式一） 或 RESOURCE_OVERLIMIT_[TIMESTAMP]_[PID].log（方式三）
日志头部信息
| 字段  | 说明  |
| --- | --- |
| time  | 检测到线程泄漏的时间  |
| pid  | 发生故障进程的pid，用于在流水中查询相关进程信息  |
| vss  | 单个进程全部可访问的地址空间，其大小可能包括还尚未在内存中驻留的部分  |
| rss  | 单个进程实际占用的内存大小，包括该进程所使用共享库全部内存大小。  |
| process  | 发生故障的应用包名  |
| summary  | 判定泄漏时进程线程总数  |
字段
说明
time
检测到线程泄漏的时间
pid
发生故障进程的pid，用于在流水中查询相关进程信息
vss
单个进程全部可访问的地址空间，其大小可能包括还尚未在内存中驻留的部分
rss
单个进程实际占用的内存大小，包括该进程所使用共享库全部内存大小。
process
发生故障的应用包名
summary
判定泄漏时进程线程总数
线程类泄漏详细信息
Top 10 Thread Name：按照线程名聚类，获取泄漏最多的线程，第一列为泄漏数量，第二列为线程名称（若创建线程时未指定线程名，则表现出是线程名和进程名相同）。
线程启动信息：可根据线程启动时间推测。
| 字段  | 说明  |
| --- | --- |
| tid  | 检测到泄漏时未释放线程的线程号  |
| thread_name  | 未释放的线程名  |
| start_time(jiffies)  | 线程创建时间  |
字段
说明
tid
检测到泄漏时未释放线程的线程号
thread_name
未释放的线程名
start_time(jiffies)
线程创建时间
线程快照：抓取判定泄漏时线程的调用栈，可由此看下线程做的任务推测线程未退出的原因（如：__pthread_cond_timedwait表示线程正在等待唤醒）。
内存泄漏日志规格
js内存泄漏
故障日志文件名：memleak-js-[process_name]-[pid]-[tid]-[timestamp].rawheap（方式一） 或 RESOURCE_OVERLIMIT_[TIMESTAMP]_[PID].log（方式三）
该文件记录了对象的详细信息，可通过DevEco Studio打开展示，详情可见snapshot解析。
native内存泄漏
故障日志文件名：泄漏日志获取中方式一和方式三文件名不同，方式三为RESOURCE_OVERLIMIT_[TIMESTAMP]_[PID].log，根据内容区分，方式一如下所示：
| 字段  | 说明  |
| --- | --- |
| threshold  | 系统设定的该进程基线（也可由应用自身通过setAppResourceLimit接口设置）  |
| PssMemory  | 记录了realtime时刻采集的PSS值，用于和threshold比较  |
字段
说明
threshold
系统设定的该进程基线（也可由应用自身通过setAppResourceLimit接口设置）
PssMemory
记录了realtime时刻采集的PSS值，用于和threshold比较
| 字段  | 说明  |
| --- | --- |
| threshold  | 系统设定的该进程基线（也可由应用自身通过setAppResourceLimit接口设置）  |
| PssMemory  | 记录了realtime时刻采集的PSS值，用于和threshold比较  |
| LOGGER_MEMCHECK_MEMINFO  | 下方记录了整机meminfo内存信息，如MemTotal、MemFree等  |
| LOGGER_MEMCHECK_SMAPS_INFO  | 下方记录了该进程的smaps汇总信息  |
| LOGGER_MEMCHECK_DETIAL_INFO  | 下方记录了该进程的jemalloc快照详细信息  |
字段
说明
threshold
系统设定的该进程基线（也可由应用自身通过setAppResourceLimit接口设置）
PssMemory
记录了realtime时刻采集的PSS值，用于和threshold比较
LOGGER_MEMCHECK_MEMINFO
下方记录了整机meminfo内存信息，如MemTotal、MemFree等
LOGGER_MEMCHECK_SMAPS_INFO
下方记录了该进程的smaps汇总信息
LOGGER_MEMCHECK_DETIAL_INFO
下方记录了该进程的jemalloc快照详细信息
栈信息日志文件：memleak-native-[process_name]-[pid]-[timestamp].txt，该文件需要通过DevEco Studio的profiler工具打开进行进一步查看和分析，详见资源泄漏问题排查方法。
ashmem/gpu/ion内存泄漏
| 字段  | 说明  |
| --- | --- |
| memoryName  | 内核内存类型（ashmem/gpu/ion）  |
| softThreshold  | 设定的软门限（超过8个采样周期，即30+分钟超过软门限后判定泄漏）  |
| hardThreshold  | 设定的硬门限（单次超过硬门限后判定泄漏）  |
| topMemory  | 检测到的内核内存峰值  |
| time(s)  | 采样kernel内存的时间  |
| kernelMemory(KB)  | 抓取的内核内存峰值  |
| realtime  | 抓取该内存峰值的时间点  |
字段
说明
memoryName
内核内存类型（ashmem/gpu/ion）
softThreshold
设定的软门限（超过8个采样周期，即30+分钟超过软门限后判定泄漏）
hardThreshold
设定的硬门限（单次超过硬门限后判定泄漏）
topMemory
检测到的内核内存峰值
time(s)
采样kernel内存的时间
kernelMemory(KB)
抓取的内核内存峰值
realtime
抓取该内存峰值的时间点
检测到ashmem/gpu/ion内存泄漏时，会抓取整机ashmem/gpu/ion内存信息，ashmem/ion与句柄泄漏ashmem/dmabuf日志规格相同，参考ashmem/dmabuf类型句柄，gpu内存规格信息如下：
gpu内存：
一个ctx为一个进程，根据used summary识别哪个进程占用最大进行分析；然后进一步分析channel(按照单个对象大小排序)确定是否存在泄漏；
如下4 / 160 表示有4个对象，总大小160B，即单个对象大小40B

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-address-illegal
爬取时间: 2025-05-01 09:06:13
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-address-illegal-way
爬取时间: 2025-05-01 09:06:26
来源: Huawei Developer
概念
地址越界问题是指访问了不合法的地址，导致程序运行出现异常，通常表现为应用崩溃（crash），其故障原因为释放后使用（use after free）、重复释放（double-free）、栈溢出（stack-overflow）、堆溢出（heap-overflow）等。由于应用崩溃crash日志信息有限且非崩溃第一现场，地址越界问题定位较为困难，一般依赖Asan、HWAsan、GWP-Asan等检测工具以获取更多内存操作信息。从API13开始推荐使用HWAsan检测工具进行地址越界问题的分析。
本文主要介绍地址越界问题检测能力、地址越界问题定位分析思路。
检测能力
目前HarmonyOS提供了Asan、HWAsan、GWP-Asan等检测工具，支撑应用解决地址越界问题，相关介绍、检测问题类型均在《使用Asan检测内存错误》、《使用Gwp-Asan检测内存错误》已有讲解，不再赘述。
分析定位思路
地址越界问题的定位流程
地址越界问题在应用的故障现象通常为崩溃闪退（crash），即没有显式的故障特征可以直接认为是地址越界问题。那么对于应用崩溃闪退的问题，具体流程如下，
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151213.65374925590060110407051256649797:50001231000000:2800:79EA7453C92A8DB6057E47A7E9305374F71BCB5C2B95FE06F500391628CF4BFE.png)
第一步，定界：是否为地址越界问题，其定界策略（经验）: 问题多次低概率持续发生、崩溃栈顶无规律、同一个崩溃栈顶源码无规律，可初步确认地址越界问题；
第二步，高概率场景分析：配合流水日志、崩溃栈（报错原因）、应用处理逻辑，分析应用使用检测工具的测试场景，触发地址越界问题；
第三步，测试复现：应用开启对应地址越界问题检测工具（HWAsan），使用DevEco Testing进行稳定性测试；
第四步，定位解决：对于稳定性测试出来的地址越界问题，基于问题日志，分析问题根因并解决。
第五步，进一步稳定性测试：检测出地址越界问题产生的日志，与地址越界导致的应用崩溃日志，二者表现不一致（见下图），因此在问题解决后，需要再一次进行稳定性测试（如果关联性分析能够确认，可省略）；第四、五步骤循环直至问题收敛；
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151213.48258949940995280760043929124290:50001231000000:2800:0DA02E45D0E33159975BABB75D22C36BB640298091F1F2106DA18DE9C30A4553.png)
地址越界问题类型
常见地址问题类型可参见地址越界事件介绍-type属性
地址越界问题的日志分析
对于地址越界问题的日志分析，由于日志落盘与cppcrash日志相似，具体参考CppCrash问题排查方法，详细的步骤为：
1）获取HWAsan检测工具，检测到的地址越界问题日志；
2）获取符号表，定位行号（use栈、free栈）；
3）结合应用代码逻辑分析代码的内存操作；
以地址越界问题类型栈缓存区溢出（stack-buffer-overflow）为例，该类型是指程序读、写的栈内存超出预期范围，程序运行异常、崩溃，具体影响如下
1）对于越界读的场景时，读取到无效数据并且使用时，程序运行出现异常；
2）对于越界写的场景时，出现对有效数据的覆盖，甚至覆盖支撑问题定位的信息（例如，栈帧信息）；
地址越界问题类型的示例代码如下，
开启HWAsan检测，上报的地址越界问题日志如下，
对应的日志结构如下，
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151213.38005730586468039569574491313783:50001231000000:2800:402F9E866F7C3E37DFC77E2ECA819B4F5BA47DE26E3669FADF1F90300536E13C.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-address-illegal-case
爬取时间: 2025-05-01 09:06:40
来源: Huawei Developer
问题案例
案例一：stack-tag-mismatch（栈溢出）问题
启用HWAsan检测工具后，日志中上报地址越界问题的原因：Reason:HWASAN:stack-tag-mismatch，属于栈溢出的问题。如果检测so库，需要在so对应的源码模块中配置启用HWAsan工具。
【分析过程】
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151213.25546984310779630157183780964264:50001231000000:2800:26201970D9660A895345C00180324B9BE1B0DF69615E04A7461D3455CBD8723D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151213.61417391689003903625184812757396:50001231000000:2800:9B5A0201DDB7888C867D54F098796D8DD20EDC1E7D07AEB21FFA40C095E6071E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151213.21598666496553532459316189513239:50001231000000:2800:B2841E39CAD798E6645C7502946253AEAF86F6944BB5F6CB55B1BF92D359772F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.72493376690954518664649060508027:50001231000000:2800:2FBA5C5FF64AD2C7E1EA215B8AD5B4BC1C9A9D52A2A6C80C27B606D9B9079C6B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.43906081010769408370007544660311:50001231000000:2800:F447A84AF9DAF920F7C890E02B21B6FDEF222E1104CB421E9C6EE2E13DEF9D38.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.98467176782425542820816511424072:50001231000000:2800:98E0CE2405671607C66264AE53733DB2F82545962A470B05299E9572F7D5CAFA.png)
nfc_nci_IoctlInOutData_t *pInpOutData = (nfc_nci_IoctlInOutData_t *)pData;  怀疑，强转成长度不匹配的结构体指针后赋值，可能访问到错误内存地址。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.75829602690612287103231512937519:50001231000000:2800:1406E74F133D115EC337198D5CC35F2E2802DA9976489E3C475737EED03DDBBD.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.16074087429023979323210019665489:50001231000000:2800:75C604AA2555EBC4A675607142971D73DA006E0DE030BE3E7F8D915E574EE0B4.png)
【修改方案】
对于status赋值操作的行为去除；
案例二：heap-use-after-free问题
【问题日志】
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.87995354862863684427055281098034:50001231000000:2800:BAB9A9FBA2041E7F75409456A0738E08438025457B01504BE6420F0F34419E6A.png)
【分析过程】
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.94958419590617335424254582060933:50001231000000:2800:0E8F3869783873A5DDC276653A9ED4753B51FA5D59C0EF40DBF76CD2BD3F99CF.png)
-  在disable中，会将p_hal对象删除；
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.05637818793568029828106949451892:50001231000000:2800:1B7C3089E66B52CC1CECE979F575B02F43895394A84CBD7F326CC39CF3F5A65B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.06142553712598204038791724298614:50001231000000:2800:8BBFD479A958076F0507A3D2C2C0600170B377368E02018D34D5FD0A1712C0A9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.76066948818006539868304055230616:50001231000000:2800:D7AB7BF6BEA1932DFD5FE7B573229D3ECA5F205190D9C336EA7362CAD39C969C.png)
在finalize中，主动将adaption对象删除；那么在30s的disable过程中，出现读越界
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.97067116208510208265914197709819:50001231000000:2800:CF66789AFF89BF0748187188E0CFE298EC9CB8EC464BDA27613204BD88388E2C.png)
【修改方案】
修改超时时间为30s；

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-resource-leak
爬取时间: 2025-05-01 09:06:53
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-resource-leak-way
爬取时间: 2025-05-01 09:07:06
来源: Huawei Developer
资源泄漏是指句柄/线程/内存等资源超过系统设定上限，部分资源甚至失去了管控能力，此时系统可能出现卡死/重启等异常情况。LeakDetector模块提供资源泄漏检测、判决、维测日志抓取、日志上报的能力，为开发者提供详细的维测日志以辅助故障定位。
本文将分别介绍资源泄漏检测能力、泄漏问题定位分析思路。
日志获取
泄漏日志获取
资源泄漏日志由LeakDetector模块进行管理，可通过以下方式获取：
方式一：通过DevEco Testing进行稳定性测试获取日志
DevEco Testing工具会收集设备/data/log/resource_leak/路径下的资源泄漏故障日志，根据进程名、故障和时间分类显示。
注意：系统自动抓的调用栈（memleak-native-[process_name]-[pid]-[timestamp].txt）无法直接在DevEco Studio打开，需要修改后缀名为.nas，然后用最新版本的DevEco Studio打开。
| 泄漏类型  | 日志文件  |
| --- | --- |
| 句柄泄漏（FD_LEAK）  | [pid]_fd_leak.txt  |
| 线程泄漏（THREAD_LEAK）  | [pid]_thread_leak.txt  |
| 内存泄漏（MEMORY_LEAK）  | js泄漏（JS_LEAK）  | memleak-js-[process_name]-[pid]-[tid]-[timestamp].rawheap  |
| native内存泄漏（PSS_MEMORY）  | memleak-native-[process_name]-[pid]-sample.txt memleak-native-[process_name]-[pid]-smaps.txt memleak-native-[process_name]-[pid]-[timestamp].txt  |
| ashmem/ion/gpu等内存泄漏 （KERNEL_MEMORY）  | memleak-kernel-[module]-0-sample.txt memleak-kernel-[module]-0-[timestamp].txt  |
泄漏类型
日志文件
句柄泄漏（FD_LEAK）
[pid]_fd_leak.txt
线程泄漏（THREAD_LEAK）
[pid]_thread_leak.txt
内存泄漏（MEMORY_LEAK）
js泄漏（JS_LEAK）
memleak-js-[process_name]-[pid]-[tid]-[timestamp].rawheap
native内存泄漏（PSS_MEMORY）
memleak-native-[process_name]-[pid]-sample.txt
memleak-native-[process_name]-[pid]-smaps.txt
memleak-native-[process_name]-[pid]-[timestamp].txt
ashmem/ion/gpu等内存泄漏 （KERNEL_MEMORY）
memleak-kernel-[module]-0-sample.txt
memleak-kernel-[module]-0-[timestamp].txt
方式二：通过DevEco Studio主动采集日志
DevEco Studio的profiler模块提供Allocation（获取native调用栈profiler）和Snapshot（获取JS层heapdump）两种采集方式：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.42952013283575289026266773929843:50001231000000:2800:1C994FFB79233E453A5C4DBF094DAEA43CF027224F323BDBD949ACC26F5CC518.png)
方式三：通过hiAppEvent接口订阅
hiAppEvent对外提供了故障订阅接口，可以订阅各类故障打点，详见HiAppEvent介绍，其中资源泄漏的订阅方式详见资源泄漏事件订阅方式介绍。
资源泄漏故障日志存于/data/storage/el2/log/resourcelimit/路径，日志名统一为RESOURCE_OVERLIMIT_[TIMESTAMP]_[PID].log，可根据日志内容区分文件类型。
对获取的日志进行分析详见日志规格。
使用profiler解析内存泄漏日志
检测到泄漏后抓取的15min 进程内存trace，可将日志如下图通过Open File加载到 DevEco Studio profiler解析。
注意：系统自动抓的调用栈（memleak-native-[process_name]-[pid]-[timestamp].txt）无法直接在DevEco Studio打开，需要修改后缀名为.nas。在不同操作系统中，修改文件后缀名（文件扩展名）的方式存在差异，具体请参考相应操作系统的操作指导。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.73302195727553729071998385509067:50001231000000:2800:04CC1BF6978FFFC4D4BF25D1C002AFB70E3F4B0123255A59900C8BA52E4AA4CE.png)
All Heap：框选后展示抓取内存的15分钟内的内存情况，记录了hook malloc等系统调用的堆栈。
Native日志是以so+偏移的形式展示调用栈（每一行表示一次内存分配行为调用栈），需要结合符号表进一步分析。点击Call Trees可以看到抓取进程的调用栈，筛选“Created & Existing”，根据没有释放的内存占比排序，展开可查看详细进程调用信息，优先排查内存占用较高的堆栈。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151214.00305175335862591256863233248194:50001231000000:2800:7B25B295FFC34DF64F93E55155CD50A0E42AB631F82A779365FE77B481CC3E77.png)
部分栈单看Existing可能感觉泄漏不大，但是这只是抓取的15分钟内的堆栈信息和内存申请，进程泄漏是以几十甚至百小时为单位的，长时间的泄漏造成上报时的泄漏大小。
All Anonymous VM：框选后记录了当前hook mmap系统调用的堆栈信息。
同样选择Created & Existing，表示在hook抓取内存申请未释放的。长度越长代表在剩余内存中占用越多，优先排查。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151215.08955268283023688387752598388561:50001231000000:2800:51CD2F8981DD042809061E016D6D919ABD42AC84ECA8668B1FF3378BA0420593.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-resource-leak-case
爬取时间: 2025-05-01 09:07:19
来源: Huawei Developer
句柄泄漏
句柄泄漏分析方法
经典错误示例和推荐建议
经典fd泄漏示例代码：
修改方法
增加句柄释放逻辑。
推荐建议
申请了句柄都要进行释放，尤其注意异常分支提前return的场景。
句柄泄漏分析案例
案例一：
某应用上报句柄泄漏，/data/storage/el1/bundle/entry.hap句柄个数 5000+，推测entry.hap泄漏。
分析：
1.包管理接口问题，open hap未释放句柄，但这个问题只报在应用进程内，且只有XXX应用单应用上，其他未复现，暂时排除；
2.应用自身问题，不断open 这个文件句柄未释放，传递给三方能力开发者（确认为该问题）。
案例二：
某service上报句柄泄漏，/system/lib占用的so句柄个数超过5000+
1.  dlopen获取的句柄的位置如下，fd存在saProfile，需要进一步查看saProfile的释放时机。 搜索saProfile的释放位置，发现只有在ParseUtil对象析构时才会释放fd资源。 找到调用者的位置，发现定义了一个类内的私有变量，而这个类的对象一直没析构，导致profileParser_一直没析构，从而导致fd资源一直未释放。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151215.43764056230052232821313671248533:50001231000000:2800:6017DCE853496361A84CCD18ACB1D473A7EC8E39F1D5172CC959812ACC235C3E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151215.66148540719215638380571991060858:50001231000000:2800:C7CF6B0FA9ADC1C9CAAB158E4B37413C6C5879B01956E5D2CD3A39B265F05F51.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151215.71858520113685242004103269781325:50001231000000:2800:41CE264D33BB2C5282BC747A50CA46E7082C406B2D0A2F301C47E7F1CDE60310.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151215.94356154012753344176806088583891:50001231000000:2800:A9509C4F4800BA9201FEE62F4A30672548F037601339A1782A3C313FBE747DE3.png)
线程泄漏
线程泄漏分析方法
推荐建议
线程泄漏分析案例
案例1：
某应用network和Network File Thread 线程泄漏，运维态泄漏检测机制抓取的日志如下
1.  故障日志发现network和Network File Thread线程皆占用309个，流水日志发现一直在断网重连。
2.  查看代码发现每个httpclient都会创建单独线程，流水日志中追踪该申请和释放日志。
3.  发现业务需要主动调用releaseHttpClient才能释放线程，领域未感知。
4.
5.  导入@ohos.net.http使用url请求能力的应用，一定要释放线程：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151215.91632910190545931008079431492676:50001231000000:2800:6109E9E7E9B2DB6D6C5E9E43FDB566D1187C52C55062A1A5F9B83D1986909BE9.png)
案例2：
某应用总线程数超700，上报线程泄漏。
1.
2.  查看线程快照发现栈顶都是__pthread_cond_timedwait，线程都处于等待唤醒，但是线程数较多，优先排查线程创建的地方，往下发现全部归属于libijkplayer.so 内部（开发者so）的线程池，怀疑线程池过大造成。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151215.23459990268539519118123055307455:50001231000000:2800:75A010748DC66FBA1CE069B43595E34C8EF11EACA8A55258E9C19401720C8811.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151215.85707258472724033787080848424971:50001231000000:2800:BE25D4683120B4B5238100E2340BE1761771DAA005353FD04776D2A498F3EC53.png)
内存泄漏
JS泄漏
JS泄漏分析方法
应用侧声明的class、struct、enum，以及通过new创建的实例对象、build中声明的组件、lambda表达式创建的匿名函数，对应在ArkTS虚拟机中都会创建对应的内存对象，虚拟机会自动在内存对象的属性中引用依赖上下文的闭包环境，从而产生隐式的一些引用关系，比较容易产生内存泄漏。
使用Snapshot能力可抓取两次heapdump，通过比较两次heapdump的对象delta进行分析：
Summary功能可以用来查看全量内存信息，Comparison可以用来进行两份内存快照对比。
如下：
1.  1)  找到应用自己的包名的对象 2）查看reference分组的每个对象 3）展开这个对象，找到对象的成员，看每个成员的distance，找到其中最小的， 4）重复4，直到找到distance为的1的为止，这个就是GC Root根节点 5）如果跟是应用自己的对象，那么应用排查，否则找华为arkUI团队 每次抓snapshot会触发1次GC，snapshot文件中展示的对象都是经过GC后因GC根可达无法释放的对象。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151215.15069574071784776456594570430572:50001231000000:2800:1A588244B6493BDD434A050047A305D218FA36971F69A605400A4EC3FB4BC498.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151215.72981820353304162321091530325587:50001231000000:2800:1F337E6D8AEBE9E1F6FA01FB004EF068C4306167A0AB83A31010ED8B7464ABAC.png)
如果自动上报的只有1份heapdump，需要根据实际应用逻辑，按照Retained Size排序，看是否当前对象个数超过业务逻辑预期（比如X1000、X10000个对象的，明显是存在异常的），如果超过就根据该对象的引用关系查找泄漏点。
如下案例，存在26个Note JSObject对象，与实际业务不符合，需要进一步查其引用关系判断是否泄漏：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151215.88497456534630680214533718274757:50001231000000:2800:786CF3E4F0CF9909A6902D193336CE9ABFD64595926ADA95D48328DEF1B24BFD.png)
某应用AppIconCalendar对象大量泄漏触发虚拟机OOM，打开heapdump，按照RetainedSize排序后发现AppIconCalendarEvent.ts18对象存在307.54MB，该对象及其引用的内存占用81%内存。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151215.39825679533764709688345746271223:50001231000000:2800:90AB478A40B92B02C09BD235C87D50C6AD70FEDCF250C5A70CF374841B0DBA24.png)
结合代码分析：这两个定时器没有停止逻辑导致组件对象一直未析构
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.63548689406271863434987673392797:50001231000000:2800:552D4439FE992B7744EAFCE9491422A731CC55B106D1974F12BE591612834B57.png)
推荐建议：使用定时器组件销毁时一定要调用clearTimeout和clearInterval，否则对象无法析构
Native泄漏
经典错误代码示例：
修改方法：
如上在堆内存生命周期结束和异常分支返回前增加内存释放。
推荐建议：
严格注意以下场景：
第一步：分析采样日志
某应用 PSS泄漏，内存一直增长，峰值内存TopPssMemory为1.3GB左右，且内存一直增长
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.27670728371350294313363823848039:50001231000000:2800:D7A709CC2592319CD5BF3AAA9187E87B87F09C389B8C0798E997C9B531CE37DA.png)
第二步：分析smaps
native泄漏有多种泄漏类型，具体可根据表格定位分析是哪一块泄漏，其中总PSS内存即sample文件的采样内存（可用最后一个）。
| 泄漏类型  | 判定方法  | 定位方法  |
| --- | --- | --- |
| 虚拟机对象泄漏  | 搜索ArkTS，PSS和SWAP PSS列的值加起来，如果超过总PSS内存的50%，则说明是虚拟机对象内存过大  | 同JS泄漏 heapdump分析方法  |
| 堆内存泄漏  | 搜索jemalloc，PSS和SWAP PSS列的值加起来，如果超过总PSS内存的50%，则说明是堆内存过大  | 基于nmd和profiler分析 堆内存泄漏有两种可能： 1、调用ARKUI的接口或者开发者的so，直接malloc申请的堆内存过大 2、虚拟机对象持有堆内存引用，对象泄漏导致native内存过大  |
| ashmem泄漏  | 搜索/dev/ashmem，如果超过总PSS内存的50%，则说明是ashmem内存过大  | 同ashmem泄漏分析方法 1、开发者使用image组件、pixmap组件可能未释放 2、开发者直接通过系统调用申请  |
| anon类型较大  | 单个anon类型占用内存较大  | 怀疑mmap内存未释放，直接排查profiler栈，框选 All Anonymous VM，筛选Created & Existing，排查内存占用最多的部分  |
泄漏类型
判定方法
定位方法
虚拟机对象泄漏
搜索ArkTS，PSS和SWAP PSS列的值加起来，如果超过总PSS内存的50%，则说明是虚拟机对象内存过大
同JS泄漏 heapdump分析方法
堆内存泄漏
搜索jemalloc，PSS和SWAP PSS列的值加起来，如果超过总PSS内存的50%，则说明是堆内存过大
基于nmd和profiler分析
堆内存泄漏有两种可能：
1、调用ARKUI的接口或者开发者的so，直接malloc申请的堆内存过大
2、虚拟机对象持有堆内存引用，对象泄漏导致native内存过大
ashmem泄漏
搜索/dev/ashmem，如果超过总PSS内存的50%，则说明是ashmem内存过大
同ashmem泄漏分析方法
1、开发者使用image组件、pixmap组件可能未释放
2、开发者直接通过系统调用申请
anon类型较大
单个anon类型占用内存较大
怀疑mmap内存未释放，直接排查profiler栈，框选 All Anonymous VM，筛选Created & Existing，排查内存占用最多的部分
本例当前应用 jemalloc大小 1GB左右，怀疑堆内存泄漏。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.48566900671199735022314320831910:50001231000000:2800:E46A22CFD60FAE3303A3E1776BAD39F312E017073C488EF69984C194F5DE68D0.png)
基于nmd（堆内存快照，判定泄漏时，堆内存布局的快照）和profiler分析：
nmd看堆内存总共1.3GB左右：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.05661184487040904595054123492771:50001231000000:2800:EA5FAAD7FD19C60FB151416B1A4D982253A7703FF6259E87905530D09ADB5FA1.png)
看native malloc detail信息，有没有哪一块特别大，如果有，假设size为a（如64），就去调用栈中搜索size为a的内存申请，重点分析这行调用栈，极可能是泄漏点。
native malloc detail记录抓取进程native日志时内存的快照信息，主要关注其size和allocated两列：
Size：用户申请的内存经过对齐后的大小，jemalloc对齐size的分割是按照一个特定算法算的，8字节是最小单位，从第二个size开始，最小step是16，一个size到它的两倍size之间有4个分档。用户态传入的申请大小会向下对齐到离它最近的size中。
Allocated：这个size申请的总内存。
size向下取整，要看一下所有size的块里面哪个比较大。
如下图：
1.  因此优先怀疑这两个内存块。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.84236843575772572065932743520335:50001231000000:2800:7CC383E0E342CD54539401675C278F5778634A4801BA9A2CE04324FFDFBAAF79.png)
第三步：分析profiler
框选All Heap，解析profiler，选择Created & Existing
搜索80字节的（转化为16进制），排查该堆栈：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.06882530122951196531927079272421:50001231000000:2800:4F8977F69FC7046CA070B95FA490D7D0E71815201CE9F728413C42B19B41CF61.png)
搜索128字节的，排查该堆栈
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.52862210206077976522217957256020:50001231000000:2800:0E277C733A41FF68145081FED982CE33585DFD8945FB10083515B505283BB21A.png)
将堆栈反馈给三方能力的开发者。
ashmem/ion/gpu泄漏分析方法与案例
图片共享内存一般有以下几种命名方式：
这些内存都是由图片编解码框架提供的编解码工具申请的，申请代码如下：
解码框架本身没有问题，一旦完成解码，ashmem的所有权会转移给C++的PixelMap对象，如果是ashmem泄漏，基本上可以断定是C++层的PixelMap泄漏。
开发者首先排查是否存在如下可能：
开发者的应用使用了 Node-API 在native层创建并使用decode()解码获取PixelMap，但是可能存在申请未释放、把PixelMap缓存到应用生命周期的容器类中、引用计数多加等可能。
如果应用根本就没有使用 Node-API 实现C++代码，那么排查是否使用JS层的PixelMap，可能存在JS对象泄漏或者缓存太多导致PixelMap大量占用，可使用DevEco Studio 抓两次snapshot看一下对象的增量分析。
【推荐】pixmap使用的ashmem内存，应用自定义绑定pixmap名字，当出现ashmem泄漏，快速根据ashmem块的名字锁定哪张图片存在问题，反推至对应的问题组件，具体方法可看自定义pixmap name章节。
案例分析：
问题现象
smaps中存在数量较多的图片文件路径为名称的内存块
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.49736089541424234101463014753632:50001231000000:2800:3ECECE98E259BC3B52BE4D658EB32FEB60D6AB50E6707D045266E76D1E3E4ADE.png)
分析业务
从jsheap中可以看到，js侧ForEach数据源未发生泄漏，可以暂时排除应用业务逻辑的问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.54838619974245723195328734530895:50001231000000:2800:ECC347605B0B27C41F7D3105432D79A4D7C0020033D81BE796FC905BB6C6FA48.png)
分析代码后发现以下两处怀疑点：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.95159708179503593792935366532432:50001231000000:2800:0C0640387BFAE087666E826310F2C48830787A852A0B2A92F64C075C9534DC52.png)
1、sceneSessionManager.getSessionSnapshot接口内部native实现是否可能存在泄漏
2、getImageInfo中实现引用了文件句柄，导致泄漏
通过注释代码后，可以定位到泄漏点在getImageInfo内部image.createImageSource，属于工具范围存在句柄泄漏
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.40891228083576386339104397938453:50001231000000:2800:600A4292D764B64CBB5786A2D58D2E050EB41C8AC760E0DA711290C609DEB648.png)
推荐建议（问题总结）：
应用侧对于不用的PixelMap要及时释放引用，每个未释放的PixelMap都会在底层产生一条/dev/ashmem/XXXX RawData 的共享内存占用。
1.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.17020115311452337760563685435171:50001231000000:2800:8686386C5C28AB8BB397680968240E90BC43F32FD1F53DEB57237D65B677D74C.png)
目前因为采用了统一渲染机制，大部分ION内存都是在Render_service进程分配使用的，如果发现应用使用ION超标了，那么按照历史经验，高概率怀疑是PixelMap C++对象泄漏。
开发者首先排查是否存在如下可能：
step1：开发者的应用使用了 Node-API 在native层创建并使用decode()解码获取PixelMap，但是可能存在申请未释放、把PixelMap缓存到应用生命周期的容器类中、引用计数多加等可能；
step2：如果应用根本就没有使用 Node-API 实现C++代码，那么排查是否使用JS层的PixelMap，可能存在JS对象泄漏或者缓存太多导致PixelMap大量占用，可使用DevEco Studio 抓两次snapshot看一下对象的增量分析；
step3:  【推荐】pixmap使用的ION内存，应用自定义绑定pixmap名字，当出现ION泄漏，快速根据ION的buffer名锁定哪张图片存在问题，反推至对应的问题组件，具体方法可看自定义pixmap name章节。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.94561416076751859360837177913350:50001231000000:2800:8CD500890EA0900AEBF3DAE6631F51FF1ED02521F95467BEBB3736567F0DBF44.png)
如果上述两种情况都不存在，那么很有可能ArkUI组件内部实现存在PixelMap泄漏。
自定义pixmap name
从历史经验看，ION和ashmem的泄漏只要是由于pixmap使用异常，为了提升定位效率，华为侧提供了一个API接口，应用/service自己设定ashmem和ION的name，与pixmap绑定，出现ION和ashmem泄漏后会打印name，直接判断是哪张图片泄漏，反推至对应的问题组件。
提供的API接口使用方法可参考：
JS层API  ：setMemoryNameSync
NATIVE层API：OH_PixelmapNative_SetMemoryName
建议Name按照 窗口+组件+图片序号自定义，如果出现批量组件图片内存未释放，可快速定位
修改方法示例：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.65868846156172720583734818775995:50001231000000:2800:FDECA9E21B3F7084B99D2CA9CA5A070D16B77DC44C7CE5C389FBAB5DD062686F.png)
ashmem日志结果示例展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151216.81172169661822717948756352777639:50001231000000:2800:C17C85057FD1D1B06FE250B25E4E9024A04779CC85829F61E6A0FB777E680AE1.png)
ion日志结果示例展示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151217.70688861618091284818852720511190:50001231000000:2800:1B09BB1C48A26D2C3B62DD83E801785FB1C9A29EF0B27AFD2643FEE8FFA89095.png)
案例：
如下scb自定义了pixmap name
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151217.49682783526869355299095009977083:50001231000000:2800:BB740A1286D4F78DBE5ABC9CAD26363E444ED0AB2D7AB4D291D9A757D9724B23.png)
根因分析：
目前应用的ashmem主要还是用在统一渲染场景下，应用和RenderService服务进程间共享图片数据，所以如果ashmem出现Ext RawData或者PixelMap等关键字，基本可以断定是PixelMap对象泄漏。这时候建议调用前面的PixelMap的打标签API给图片打上特殊含义的标签。本案例就是PixelMap泄漏后打标签后的显示结果，通过这个维测很快定位到哪个图片泄漏且找到根因。
-  某应用发生gpu泄漏。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151217.54028868572088295770837993181660:50001231000000:2800:55CE299A2897722B500D8CEDBDC5E87273E413F5EB48C25CADE1DCFD2CE91BED.png)
根因分析：
可以看到该应用 Allocate和Used的内存达到了2.9G，其中gles image占大头：
channel 24上有132个image总大小为1362493440，平均每个image大小为10321920（10M）
channel 26上有33个image总大小为1544159232，平均每个image大小为46792704（46M）
目前此类问题分析还有难度，一般是结合RenderService进程里打印出的skia维测日志来分析，最后分析根因是：应用releaseDocument时未清理egl缓存导致泄漏。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151217.70617446578111745823156267677632:50001231000000:2800:041B0B502961B5792ABEDA6945A5FEF60B6D34052B116DFE00E09F5CC580118F.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-freeze
爬取时间: 2025-05-01 09:07:32
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-freeze-way
爬取时间: 2025-05-01 09:07:46
来源: Huawei Developer
用户在使用应用时会出现点击没反应、应用无响应等情况，其超过一定时间限制后即被定义为应用无响应(appfreeze)。系统提供了检测应用无响应的机制，并生成appfreeze日志供应用开发分析。
本文仅适用于Stage模型使用。且在根据本文分析日志前，需要开发者对JS在系统中运行情况、C++程序堆栈信息有相关基础知识，并对应用相关的子系统有一定了解。
应用无响应检测原理
THREAD_BLOCK_6S应用主线程卡死
该故障出现表示当前应用主线程有卡死或者执行任务过多的情况，影响任务执行的流畅度和体验。
该事件的检测原理是：应用的watchdog线程定期向主线程插入判活检测，并在自己线程插入超时上报机制。当判活检测超过3s没有被执行，会上报THREAD_BLOCK_3S警告事件；超过6s依然没有被执行，会上报THREAD_BLOCK_6S主线程卡死事件。两个事件匹配生成THREAD_BLOCK的应用无响应日志。
检测原理如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151217.97680636613729392551679677572498:50001231000000:2800:82DDAC5A46B35F8B7B47392F5D9DB141CE89278480AFA1658D99046FA732CB6B.png)
APP_INPUT_BLOCK用户输入响应超时
该故障是指用户的点击事件超过一定时间限制未得到响应，严重影响当前用户体验。
该事件的检测原理是：用户点击应用的按钮时，输入系统会向应用侧发送点击事件，但超时未收到应用侧的响应反馈回执，则上报该故障。
检测原理如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151217.92377413896606118297648393595514:50001231000000:2800:C41892F048AC8DD67428737315B3E58C28703ADE35AC0A3DE753BFDC55F9AF83.png)
LIFECYCLE_TIMEOUT生命周期切换超时
生命周期切换超时是指UIAbility生命周期切换超时。
该故障出现在生命周期切换的过程中，影响当前应用内Ability的切换。
该事件的检测原理是：通过获取不同生命周期切换的过程，在生命周期切换开始的位置向watchdog线程插入超时任务，在生命周期切换完成之后移除超时任务，固定时间内未成功移除将上报故障。
生命周期切换超时由LIFECYCLE_HALF_TIMEOUT和LIFECYCLE_TIMEOUT两个事件组合而成。LIFECYCLE_HALF_TIMEOUT作为LIFECYCLE_TIMEOUT的警告事件，抓取binder等信息。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151217.86680563489285823769407800280771:50001231000000:2800:5AE6F7F9B497FD06E1A6C64CD52C6A332C3FCBD5E776BE780FB37CA06A515A4B.png)
检测的生命周期与开发者可感知的UIAbility生命周期类似，存在微小区别：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151217.74461144099007532495190956141087:50001231000000:2800:44560FC3E6DA977A5592163154471A5290629F729C6F4E1A6FD7B6B0F541152E.png)
应用无响应日志解析
分析应用无响应日志需要了解应用无响应(appfreeze)日志结构及各部分含义，详见日志规格。
应用无响应自恢复
当应用发生以下故障时，为了保证可恢复，会杀死应用。
| 故障类型  | 说明  |
| --- | --- |
| THREAD_BLOCK_6S  | 应用主线程卡死超时  |
| APP_INPUT_BLOCK  | 用户输入响应超时  |
| LIFECYCLE_TIMEOUT  | Ability生命周期切换超时  |
故障类型
说明
THREAD_BLOCK_6S
应用主线程卡死超时
APP_INPUT_BLOCK
用户输入响应超时
LIFECYCLE_TIMEOUT
Ability生命周期切换超时
定位步骤与思路
获取日志
应用无响应日志是一种故障日志，与Native进程崩溃、JS应用崩溃、系统进程异常等都由FaultLog模块管理，可通过以下方式获取日志：
方式一：通过DevEco Studio获取日志
DevEco Studio会收集设备的故障日志并归档到FaultLog下。具体可参考FaultLog。
方式二：通过hiappevent获取
hiappevent对外提供订阅系统卡死事件，可以查询卡死事件信息，详见订阅系统事件（卡死事件）。
方式三：通过shell获取日志
应用无响应日志是以appfreeze-开头，生成在设备“/data/log/faultlog/faultlogger/”路径下。该日志文件名格式为“appfreeze-应用包名-应用UID-秒级时间”。
查看基本信息
1、进程号
故障日志中搜索 "Pid" 可获得。
根据进程号可以查找对应进程的栈信息、在流水日志中过滤出对应进程的日志输出等。
2、故障类型
故障日志中搜索 "Reason" 可获得。
根据故障类型可以参考对应类型的检测原理和故障检测时长。
3、故障上报时间点
故障日志中搜索  "Fault time" 可获得。
请注意日志中多处 "TIMESTAMP" 字段的含义，代表着故障形成过程中中间重要节点的时间，正常场景下与故障上报时间点接近，但是特殊的，当故障形成时由于种种系统原因导致阻塞，可能存在一定的时间误差。
而 "Fault time" 字段最接近故障上报时间点。
4、前后台信息
故障日志中搜索 "Foreground" 可获得。
该字段表示应用发生故障时所处前后台状态。
值得注意的是，APP_INPUT_BLOCK 用户输入响应超时，事件能够分发到应用上，可想而知应用必为前台状态。
5、故障检测时长
该信息可从故障类型和前后台信息推理得出。
对于 THREAD_BLOCK_6S 事件，当应用处于前台时，检测时长为 6s；当应用处在后台时，由于不直接与用户交互，其对主线程阻塞判断有所放宽，其故障检测时长为 21s。
对于 LIFECYCLE_TIMEOUT 事件，可以从 MSG 的 reason 部分获取是哪种生命周期超时，参照表格获取其对应的故障检测时长。
6、故障检测时间区间
该信息可从故障上报时间点和故障检测时长推理得出。通过故障时间点往前推故障检测时长可得到故障发生的具体时间。
区间为：【故障上报时间点 - 故障检测时长，故障上报时间点】
查看eventHandler信息
1、dump begin curTime & Current Running
当前任务已运行时长 = dump begin curTime - trigger time，如示例中当前任务运行达到 27s
若时间差 > 故障检测时长，表示当前正在运行的任务即是导致应用卡死的任务，需排查该任务运行情况。
若时间差较小，表示当前任务仅是检测时间区间内主线程运行的任务之一，主要耗时不一定是本任务，需排查近期运行的任务中耗时较长者。该情形多为线程繁忙导致的watchdog无法调度执行。
2、History event queue information
可以从历史任务队列中寻找故障发生时间区间内较为耗时的任务。其中 completeTime time 为空的任务即是当前任务。
任务运行耗时 = completeTime time - trigger time
筛选出耗时较高的任务，排查其运行情况。
3、VIP priority event queue information
用户输入事件传递链中的任务都属于高优先级任务，为保障第一时间响应用户。
4、 High priority event queue information
watchdog 任务位于此优先级队列中，观察可发现其是每隔 3s 发送一次。
对比warning/block事件，观察 watchdog任务在队列中的移动情况。
warning：
block:
以上示例中可发现block队列相比于warning队列更长了，而对应的第一个任务没有发生变化，可能存在两种情况：
- 当前正在运行的任务卡死阻塞，导致其他任务一直未被调度执行。
- 更高优先级队列中任务堆积，导致位于较低优先级队列中的watchdog任务未被调度执行。
查看stack信息
应用无响应所对应的故障类型，其检测主要都是应用主线程。
应用主线程存在以下几种情况：
1、warning/block栈一致，卡锁
堆栈显示等锁卡死，通过反编译获取对应代码行，排查其他线程栈和代码上下文锁的使用解决故障。
2、warning/block栈一致，卡在IPC请求
通过IPC栈帧下面的业务栈帧，识别应用是通过什么接口进行IPC请求，识别对端是什么进程。需要结合 binder 调用链，确定对端阻塞没有返回的原因。
3、warning/block栈一致，卡在某业务栈帧
warning/block栈均为：
```shell
Tid:14727, Name:xxx
# 00 pc 00000000001c4c60 /system/lib/ld-musl-aarch64.so.1(pread+72)(b168f10a179cf6050a309242262e6a17)
# 01 pc 0000000000049154 /system/lib64/platformsdk/libsqlite.z.so(unixRead+180)(48485aa23da681fc87d8dc0b4be3e34c)
# 02 pc 0000000000053e98 /system/lib64/platformsdk/libsqlite.z.so(readDbPage+116)(48485aa23da681fc87d8dc0b4be3e34c)
# 03 pc 0000000000053d48 /system/lib64/platformsdk/libsqlite.z.so(getPageNormal+864)(48485aa23da681fc87d8dc0b4be3e34c)
# 04 pc 00000000000757a0 /system/lib64/platformsdk/libsqlite.z.so(getAndInitPage+216)(48485aa23da681fc87d8dc0b4be3e34c)
# 05 pc 0000000000077658 /system/lib64/platformsdk/libsqlite.z.so(moveToLeftmost+164)(48485aa23da681fc87d8dc0b4be3e34c)
# 06 pc 000000000006aa34 /system/lib64/platformsdk/libsqlite.z.so(sqlite3VdbeExec+34532)(48485aa23da681fc87d8dc0b4be3e34c)
# 07 pc 000000000002e424 /system/lib64/platformsdk/libsqlite.z.so(sqlite3_step+644)(48485aa23da681fc87d8dc0b4be3e34c)
# 08 pc 00000000000b1a70 /system/lib64/platformsdk/libnative_rdb.z.so(FillSharedBlockOpt+408)(5e8443def4695e8c791e5f847035ad9f)
# 09 pc 0000000000082a94 /system/lib64/platformsdk/libnative_rdb.z.so(OHOS::NativeRdb::SqliteStatement::FillBlockInfo(OHOS::NativeRdb::SharedBlockInfo*) const+76)(5e8443def4695e8c791e5f847035ad9f)
# 10 pc 00000000000b4214 /system/lib64/platformsdk/libnative_rdb.z.so(OHOS::NativeRdb::SqliteSharedResultSet::ExecuteForSharedBlock(OHOS::AppDataFwk::SharedBlock*, int, int, bool)+236)(5e8443def4695e8c791e5f847035ad9f)
```
结合 trace 进一步确认，排查是否为应用调用的单一函数内部逻辑执行超时，例如：某函数内执行复杂计算。
4、瞬时栈，warning/error 栈不一致
表示两个时刻是在线程的运行过程中抓取的栈信息，此时进程未卡死，属于线程繁忙场景。
warning栈：
block栈：
warning/block栈可能存在相似性，需结合trace和hilog判断应用具体运行场景，针对场景进行优化。
5、eventhandler栈
此堆栈表示当前线程eventhandler在等待任务提交，说明此时线程不繁忙。
查看binder信息
binder信息抓取时机：存在半周期检测的故障类型是在warning事件产生后获取，其他则在block事件后获取。
1、获取binder调用链
以上示例为参考：从故障进程的主线程出发，存在 35854:35854 -> 52462:52462 -> 1386:0 的调用链关系。
结合对端进程堆栈信息排查对端阻塞原因。
2、线程号为0
表示该应用 IPC FULL，即应用的ipc线程都在使用中，没有空闲线程分配来完成本次请求，导致阻塞。例如上面示例中的 1386 进程
可以看到此时 1386 进程处于 ready 态的线程为 0，验证了上述说法。 此情况说明该进程的其他ipc线程可能全部被阻塞了，需要分析排查为什么其他ipc线程不释放。常见场景为：某一ipc线程持锁阻塞，导致其他所有线程等锁卡死。
另一种情况为 free_async_space 消耗殆尽，导致新的ipc线程没有足够的 buffer 空间完成请求。值得说明的是，同步和异步请求都会消耗该值，常见场景为：某短时间段内大批量异步请求。
3、waitTime过小
waitTime 表示的是本次ipc通信时长，如果该值远小于故障检测时长，我们有理由确定本次ipc请求并不是卡死的根本原因。
一种典型场景是：应用侧主线程在短时间内多次ipc请求，总请求时长过长导致故障。
排查方向：
- 单次请求是否在预期时长内(例如：规格在20ms的请求接口异常情形下达到1s)，排查该接口性能不达预期的原因。
- 应用侧频繁调用场景是否合理。
4、无调用关系，而栈却为ipc栈
确定是否为瞬时栈，即warning/block栈是否一致，可能场景是：warning为ipc栈，block栈为其他瞬时栈，表明抓取binder时ipc请求已经结束，本次ipc请求耗时并不长。
需要提到的是：binder信息并不是在发生故障时刻实时获取的，有一定的延迟性；对于存在半周期检测的故障类型来说，binder抓取比较准确，绝大多数都可以在故障时间段内完成采集；而其他故障类型在上报存在延迟的情况下可能抓取到非现场binder。
当然，结合 trace 分析更能直观查看binder耗时情况。
结合hilog信息
DFX 相关打印：
1、故障上报时间点
搜索关键词 "Start NotifyAppFault" 确定流水中故障上报时间点
2、后台检测（5次后上报）
搜索关键词 "In Background, thread may be blocked in, do not report this time" ，判断故障检测时长是否达到 21s
3、抓栈（signal: 35）
搜索关键词 "DfxFaultLogger: Receive dump request"  获取故障抓栈时间点，结合故障上报时间点判断抓栈时机是否准确
4、记录查杀原因
搜索关键词 "hisysevent write result=0, send event [FRAMEWORK,PROCESS_KILL]" 获取故障查杀原因，结合 AppRecovery
5、应用退出
搜索关键词 "is going to exit due to APP_FREEZE" 获取应用退出时间点
一种可能的场景：应用退出时还未完成抓栈，该情况下无法获取到栈信息
一般分析步骤：
1、确定故障上报时间点
2、推断故障检测区间
3、判断该时间区间内应用主线程运行状态：
- 应用主线程日志完全无打应输出：卡死在最后日志打印的接口调用处
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151217.15570343510529371857555440251675:50001231000000:2800:DAD270BCC2E5838F6B32650863E42BC00764AA8044A1D65336731B24CAFE733D.png)
...
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151217.92176692206328618088766717843900:50001231000000:2800:98F61257877C24F6605B5C02E18AF7EA243134AC41C8488AA7C81CDC2FD8AE80.png)
例如示例：APP_INPUT_BLOCK 类型在 07:24:08.167 上报，应用主线程在 07:24:01.581 后就没有打印了，可排查是否为 FormManagerService: [form_mgr_proxy.cpp(GetFormsInfoByApp:1128)] 中的逻辑超时
- 应用疯狂打印输出日志：分析对应输出表示的场景及其合理性
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151217.73455469957089157606960228991724:50001231000000:2800:03999A7AD71F12B7894A1F3B42D5410168D78BF3E9890136A1FE5AFCA5D0D391.png)
例如示例：进程在被杀死前在大量输出，对应的 ImageEffect 领域需排查此日志是否正常，是否陷入死循环或频繁调用场景
结合trace信息
1、进程频繁执行密集任务超时；
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151217.33434602441410184570575660953957:50001231000000:2800:41C0D2D3879AF2445F75AAC283E60D4BFDBCABF4C1E409B07355B4342BA269B9.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151217.31927067091857828905999793243804:50001231000000:2800:6210141C3C7D05ADC8B2C5A95245145ADF87837A2226FA1C4B04E51E708005EC.png)
示例为：PreviewArea::updateShotComponent（更新组件） -> ohos.animator （执行动画）-> 密集的动画执行过程达 9.2s；
线程繁忙地循环执行某业务，分析每一小段业务：
- 不符合业务场景（此处不应该频繁调用），分析业务代码，为何会循环执行；
- 符合业务场景，分析每一小段业务是否耗时超过预期，性能为何不满足设计规格；
2、进程执行某一任务超时
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151218.64454867445335754152695631646844:50001231000000:2800:FE380DE67BE48D4A2E3EF919839B10E4C8E660B6AA6688607379B03A1CEFB3B1.png)
示例为：OHOS::AppExecFwk::FormMgrAdapter::GetFormsInfoByApp 接口执行时长达到 8s
3、进程多段任务累积超时
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151218.45933320783229215605583658307748:50001231000000:2800:D5F3D66246982BDC0C192F469D80DABC74D916AE4AF9952AFAFC99F6AB6AA74A.png)
示例中：三段任务累积到达6s超时，判断场景为屏幕旋转后页面动画超时

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-freeze-case
爬取时间: 2025-05-01 09:08:00
来源: Huawei Developer
THREAD_BLOCK 类典型案例——未正确使用锁
背景
xxxservice 上报 THREAD_BLOCK_6S 的 appfreeze 问题
错误代码案例
第4行加锁，第6行函数返回失败后，第6行直接返回未解锁，导致其他线程一直等锁
影响
后台应用卡死，用户无感知，但是相关功能不可用
定位思路
提取故障日志关键类别信息
从 Foreground 值可看出该应用为后台应用，可推断出当真正的 3s 事件上报上来时，后台应用已卡 18s 前
THREAD_BLOCK_3S 上报的时间为 08:24:29:612；
THREAD_BLOCK_6S 上报的时间为 08:24:32:638；相隔 3s 符合预期
3s 上报时会去抓取此时的 EventHandler 信息，时间为 08:24:29.413，符合预期
上报的原因为：App main thread is not response! 主线程无响应
当前正在运行的任务开始时间为 08:24:01.514
watchdog 任务位于高优先级队列（High priority event queue），如下图可发现：每隔 3s 就会抛一个任务到主线程去，符合预期；
THREAD_BLOCK_3S、THREAD_BLOCK_6S 的队列一致，6s 较 3s 多了一个 event
最早的一个 event send time 为 08:24:11.388，与 3s 上报上来的时间 08:24:29:612 刚好差 18s，符合预期；
以上可总结：应用主线程从 08:24:01.514 开始运行本次任务，第一次 3s 检测开始时间为 08:24:11.388，真正开始卡住的时间在 08:24:11 左右；
查看主线程栈：从 xxx_request_client.so -> libsamgr_proxy.z.so -> libipc_core.z.so(OHOS::BinderConnector::WriteBinder)
可知：此时主线程发起了一个 ipc 请求，对端进程未返回导致卡死，如下堆栈所示。
查看 binderCatcher：此时 43675 的主线程正在与 979 进程通信，抓 binder 时已经卡了 27s
查看 979 进程主线程栈：xxxserver 在等待锁释放。该问题即为典型的锁使用不当，导致的等锁卡死。
反编译即可确定对应卡锁代码行，结合上下文检测锁的使用
修改方法
修改为：
结合上下文，合理调整锁的使用
推荐建议（问题总结）
多线程交互时需要格外注意时序、死锁问题
APP_INPUT_BLOCK 类典型案例——组件全量刷新
背景
用户在切换主题时突然卡死，有 sceneboard 的 appfreeze 问题上报
该问题为线程繁忙导致卡死
错误代码实例
对于组件的刷新复用，是通过组件的 key 值来控制的，当页面更新时，若组件的 key 不变，会复用之前的组件；若 key 值变化，会更新组件及其子组件。
该函数用户生成桌面组件的 key，关联有 themeStyle，当用户在桌面连续切换主题时，导致组件反复全量刷新，导致卡死。
```typescript
private getForeachKey(item: xxx): string {
...
return `${item.xxx2}${item.xxx2}...${item.themeStyle}`;
}
```
影响
用户在合一桌面切换主题时页面高概率卡死，点击无响应，而后闪退到锁屏界面。
严重影响用户使用体验。
定位思路
提取故障关键信息
APP_INPUT_BLOCK 是事件上报的时间为 14:40:59:440
上报的原因是：User input does not respond! 用户输入事件没有响应
可以看到当前是在主线程上(Thread ID == Pid)，正在运行的任务从 14:40:53.499 开始运行，直到 Fault time 14:40:58 都还没有运行完
用户输入事件需要第一时间响应，所以同 watchdog 一样都在 High priority event queue；
可以看到此时已经有 200+ 的 input event 在队列中阻塞住没有处理了；
从逻辑来看，input event 触发应用主线程任务开始执行，但是 6s 还没有执行完，没有反馈，导致 ANR 超时；
因此我们只需要关心 input 触发了应用执行什么任务，该任务为什么会执行超时即可。
主线程栈：此时运行时状态，栈顶的 ark_jsruntime GetCurrentThreadId 也不是持锁阻塞或耗时很长函数，抓到的栈为瞬时栈，没有参考意义；
接下来排查流水日志：
首先找到上报 APP_INPUT_BLOCK 的时间点，大概在 13:40:59.448 左右，且从这里我们可以看到在事件上报完后，dfx 将卡死的 scb 杀掉。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151218.35661907075166487956733257950956:50001231000000:2800:AC32C184D1F9285522E2838A67EE8B0A685F87239D9D50B33237B3A42F412467.png)
往前推 6s 左右，可以看到在 14:40:53.498 左右，有一个点击事件发给了 scb。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151218.63342688793799932070608605804439:50001231000000:2800:B9A2DCCCD31460A13B8224D3C4565033564F29B14806DBCB8595D65CA38604EF.png)
在这之间的 6s 存在大量的 scb 日志，判断是在做更新渲染
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151218.28304211525374096872705636044647:50001231000000:2800:2F7CCB5F07B70A67B600C35B624C8C74B12FFD160C9C78D80D1A28ED9414ED9B.png)
看下对应时间点的 trace：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151218.82808159250817731468018396066356:50001231000000:2800:AB0BCECA4B5447C8A2CD2942978F3C6FAFA17CAA6EE0752BD28EB26CCEEF962B.png)
发现 scb 主线程被占满，确实很繁忙。选择耗时较长的任务，是 CustomNodeUpdate SwiperPage，后续就需要排查为啥这个组件里一直在做刷新。
根据对应领域排查后发现：swiperPage上把 themeStyle 加入到了 key 里面，key 变了就会走控件新建流程
即当用户切换主题或者切换图标风格时，会造成桌面上控件的全量新建，导致主线程繁忙，导致输入事件未响应
修改方法
仅当切换桌面组件风格时，才触发桌面组件的刷新，缩小刷新范围。
推荐建议（问题总结）
用户点击触发页面更新时，需要合理控制页面刷新的范围，考虑大量组件、频繁刷新等场景
LIFECYCLE_TIMEOUT 类典型案例——加载云图
背景
用户在打开云笔记时应用卡死后闪退
错误代码实例
循环中同步获取云图
影响
应用拉起、切前台等过程中卡死并闪退
定位思路
以 notepad LIFECYCLE_TIMEOUT 为例，提取故障关键信息：
查看 MSG 信息：foreground timeout，对应时长为 5s
LIFECYCLE_HALF_TIMEOUT 上报时间为 10:04:57:538；
LIFECYCLE_TIMEOUT 上报时间为 10:04:59:965；相隔 2.5s 左右，符合预期；
任务开始的时间为 10:04:54.798，离 LIFECYCLE_HALF_TIMEOUT 相隔 2.5s 左右，符合预期；
看对应的堆栈信息：libfs.z.so -> libdatashare_consumer.z.so -> libipc_core.z.so
通过 binder 可以看出在与 5235 进程通信，时长大于 2.5s，符合预期。
5235 为媒体库进程，该堆栈无有效信息
以上可以得到信息：应用通过文件系统 Open::Sync 同步通过 uri 加载文件，调用到 datashare 请求媒体库文件数据
查看对应时间点的流水信息：进程调用 datashare 加载云图后卡死，与堆栈信息吻合；
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151218.60968285852155425031692625780994:50001231000000:2800:024FABF80C401EC4462E9C085AE387B699A980281471FB88878B077CE6E12F48.png)
查看具体代码：
在循环中同步加载 fileUri ，这种明显是不合理的，当弱网或者同时加载大量数据的条件下，极易出现卡死情况，应用侧需要整改。
修改方法
同步加载改为异步加载，并用标志位来标识是否加载完，用户界面展示加载中效果。
修改为：
推荐建议（问题总结）
1、请求云侧数据需要验证充分，有网、弱网、无网场景下
2、不要在应用生命周期函数中做耗时操作

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-freeze-ark-runtime
爬取时间: 2025-05-01 09:08:13
来源: Huawei Developer
概述
本文旨在指导HarmonyOS应用开发者如何定位定界栈顶在方舟运行时（libark_jsruntime.so、libace_napi.z.so）的应用无响应freeze问题。
关于freeze问题的基本检测原理可先阅读应用无响应问题排查方法。
定位思路
定位freeze问题常用“三板斧”可归纳为：看freeze栈、看trace、看日志。
一板斧：看freeze栈
目前应用无响应检测会从以下维度检测，HarmonyOS应用开发者了解其原理对定位和分析freeze问题非常有帮助。
| 问题故障类型  | 说明  |
| --- | --- |
| THREAD_BLOCK_6S  | 应用主线程卡死超时  |
| APP_INPUT_BLOCK  | 用户输入响应超时  |
| LIFECYCLE_TIMEOUT  | Ability生命周期切换超时  |
问题故障类型
说明
THREAD_BLOCK_6S
应用主线程卡死超时
APP_INPUT_BLOCK
用户输入响应超时
LIFECYCLE_TIMEOUT
Ability生命周期切换超时
其中THREAD_BLOCK_6S（应用主线程卡死超时）最终表现在libark_jsruntime.so栈顶的freeze问题比较多。
出现该类问题表示当前应用主线程有卡死或者执行任务过多的情况，影响任务执行的流畅度和体验。
该事件的检测原理是：应用的watchdog线程定期向主线程插入判活检测，并在自己线程插入超时上报机制。当判活检测超过3s没有被执行，会上报THREAD_BLOCK_3S警告事件；超过6s依然没有被执行，会上报THREAD_BLOCK_6S主线程卡死事件。两个事件匹配生成THREAD_BLOCK的应用无响应日志。问题发生时会生成FREEZE堆栈，包括warning栈（3s）与error栈（6s）。
通过分析freeze堆栈可得到如下信息：
二板斧：看trace
通过freeze的栈只能看到3S和6S的瞬时栈(有的freeze甚至只有6S的瞬时栈)，如果想要知道应用freeze前的6S时间内整个应用进程的状态，则需要看trace。查看freeze前的trace，可以重点关注以下信息：
三板斧：看日志
有时会遇到通过freeze栈和trace仍无法定界的情况(如对应时间点trace丢失或者trace中看不到在执行什么代码逻辑)，这个时候就需要借助freeze前的日志信息做进一步定位。查看freeze前的日志，重点关注以下信息：
问题分类
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151218.99982880476177530196385336029771:50001231000000:2800:C76D2B1F5617B7FBE692CF4AF23025C163379D4EF500EE19EA4C00ADA2CD9840.png)
总结栈顶在方舟的appfreeze问题根因以及每种问题的典型特征，归纳如下：
应用问题
调度问题
因为线程优先级低，调度不到CPU资源，应用进程一直处于runnable状态，最终导致appfreeze，问题典型特征如下：
系统库问题
IO问题
读写问题导致的D状态问题，典型特征如下：
典型案例分析
应用问题案例分析
案例一：3S和6S调用的应用JS代码相同
下面是某应用一个appfreeze问题3S和6S的调用栈，栈顶都是JSStableArray::IndexOfBigInt，这是一个Builtins接口，流程中没有加锁，因此排除死锁的问题。可以看到，除去jsruntime的栈顶，3S和6S执行的应用代码行都是同一行:LeakXXXModel.ts:440:1，怀疑应用有循环调用导致的线程繁忙问题，经确认，根因为对应应用代码中有个很大的for循环执行耗时长，代码优化后得以解决。
3S栈：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151218.74090863457898562979915224624931:50001231000000:2800:59E03AA01783439E5A66D77E58C1809BB13326F89C4E6420CA9C6CFA1246531A.png)
6S栈：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151218.17079451013845576129336488885250:50001231000000:2800:12BA47A06CF3DB84A408F2A082406EF5DAADE1ED91E172E657D3C06245F5A9F3.png)
解决方案：下面是应用findXXXList接口的伪代码示例，该接口的功能是返回[start,end]区间中缺失消息组成的列表，当indexList很大时，循环遍历查找将非常耗时，可能造成应用appfreeze。伙伴侧的规避方案是设置一个定时器做超时检测，当for循环代码执行超时后则直接跳出循环，避免发生appfreeze。
```typescript
public async findXXXList(indexList, start, end) {
let needBreak = false;
setTimeout(() => {
needBreak = true;
}, 100); // 定时器
while (start <= end) {
// do some thing
start++；
if (needBreak) {
break; // 超时退出
}
}
}
```
案例二：应用主线程频繁调用某个应用接口
该案例主线程的trace如下，从trace可以看出，应用在频繁调用某个接口。打开其中一小段发现是在频繁调用反序列化接口，每段反序列化的时间1us以上。反序列化接口在应用跨线程传输数据时调用，如调用Work的PostMessage接口或TaskPool的execute接口。由此可确认，该freeze问题发生的根因是应用频繁跨线程传输数据导致。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.75121654546779636346205924195670:50001231000000:2800:8162ACF3D45D525FA895F2906094966A22352B9AFC07FF1438FBC1227BB8E8BC.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.76597296267664268878735455532236:50001231000000:2800:544BDD0AE3403C5AA93ADBD691A6676DE710E2469F41C21A213F206F29B40C2B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.79774991012940644682483056043832:50001231000000:2800:1F7C16320B5DBBD8D3665E099763BAA968BD90C963DEF06490095A65236ADED8.png)
解决方案：减少同一时间段频繁跨线程传输数据的操作。
案例三：应用主线程调用某个耗时长接口
该案例Appfreeze堆栈栈顶在执行正则操作，从trace中可以看出，主线程一直在执行正则匹配导致超时freeze。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.79377199315034540066926658093064:50001231000000:2800:E204E8FA2BDF43F445EEDC2723E33366A4758A3C74C5D42BC87ED8A2172DE74F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.02995309981822978657588651910114:50001231000000:2800:9652BDD1750162FAD98E154AA3A10566740558E1FBEE96055DFD04CDAB2A0489.png)
解决方案：（1）优化正则匹配的逻辑，避免超长字符串的正则匹配；（2）将耗时操作放到taskpool线程执行，不阻塞主线程。
案例四：freeze前关键应用日志打印
下面是一个服务类进程的appfreeze问题，该问题通过freeze栈和trace均无法完成问题定界，最终通过日志才分析出问题根因。
结合 trace 分析：trace中显示的是GC的循环调用，但每次GC在running中的占比并不高，也符合GC调用的规律，因此确认不是GC的问题。可能是未插桩的running状态导致未响应，无法进一步定位问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.19155043869525587591827496078016:50001231000000:2800:9923FB93E5F43A2B857047059BF1344DF1759D743EF12502A9D351342F1D608E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.49851703182712553478726727707692:50001231000000:2800:46AB7263B70AD405F4356AC8544F2B55209C66B9C8B5BF5D702F953CE3CA03B3.png)
此时结合 hilog 日志分析，hilog 搜索崩溃线程28040，崩溃时间点在06:44:16，卡了6s。推测大概是在06:44:10附近出现问题。
进一步观察hilog 日志发现，应用一直在调用融合搜索FusionSearch，和应用对齐后，确认问题是应用循环调用FusionSearch接口导致。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.34203265878549813371554053776395:50001231000000:2800:D58F50FD2AEA950584F6849F459CB595BFD1B652C296B9D3EC6F053156D894C7.png)
案例五：应用内存泄漏导致频繁GC
该案例的trace如下，可以看到主线程一直在触发GC，几乎沾满了整个线程。在应用内存正常时(远小于应用js内存上限)，每次GC后都会根据存活对象大小适当提升GC的阈值，从而防止频繁的GC触发。而当应用发生内存泄漏时，应用占用的js内存可能一直处于OOM的边缘，GC阈值调整的空间则非常有限(GC阈值不能超过js内存上限)，可能就会出现频繁GC的现象。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.57743029000355867113144171111163:50001231000000:2800:3B886259564241C845E66882AEA43EBB3185377E557239B1C351F96A48C4D9E1.png)
为了进一步验证上述猜想，结合GC日志做进一步分析。从日志可以看出，应用分配的ArrayBuffer内存已经达到1.4G，且GC仍无法释放，再加上NativeBindingSize，总的内存大小已经接近3G。根据虚拟机的GC内存触发策略，当Native内存超过2G后，每次分配都会尝试去触发GC。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.37679520021100655501300582747516:50001231000000:2800:FABF5C1B71BEEE059BD72FF4FAB65AF4C2450C87947C7179A071E46195D2B669.png)
解决方案：通过上面分析，该问题实际就由freeze问题转换成了内存泄漏问题。应用内存泄漏一般可以分为两种：一种是js内存泄漏，另一种是Native内存泄漏。对于js内存泄漏，可以同HeapSnapshot工具生成内存快照，辅助问题定位，参考文档内存泄露分析：Snapshot分析。对于Native内存泄漏，DevEco Profiler提供了基础的内存场景分析Allocation，参考文档基础内存分析：Allocation分析。
案例六：应用内存泄漏触发OOM Dump
该问题的典型Freeze栈如下，其中有一个js线程(主线程或taskpool、worker线程)触发了OOM的dump，堆栈显示调用DumpHeapSnapshotBeforeOOM接口。该问题发生的原因是某个js线程的虚拟机内存超过了设定的上限(主线程448MB，worker、taskpool线程768MB)，这种一般是应用内存泄漏导致，解决方案同案例五。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.65879700303943224337236863100101:50001231000000:2800:F935F004BD067F1A3AC5C3089D9659CB66CD7EB4C6000A0D1212402D179E1364.png)
案例七：高优先级任务过多
原理：
在每个freeze文件中都会有任务队列的dump信息；高级别优先级别的任务会抢占低级别优先级任务的队列资源，以保证高优先级任务能够尽早被执行；
THREAD_BLOCK_6S的检测机制为watchdog向主线程队列中每隔3s抛一个watchdog的任务(Timer)，这些任务必须要在被抛出的3s内被主线程执行到；
因为watchdog的任务是高优先级任务(High Priority Event)，所以如果任务队列中VIP Priority Event + Immediate Priority Event + High Priority Event的任务总量过多，就会容易发生watchdog定时任务无法及时被执行，从而导致出现appfreeze；
特征：
一般来说，这三者的任务数总量相加超过400，应用就有发生freeze的风险，需要应用侧进行整改，减少高优先级任务数量
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.14180838720091549058397277659341:50001231000000:2800:ABEEB608DBFEBC8364FDA8469602A2C3CBA3287E3D7F86C35CFE9ABE18CFCFCF.png)
High Priority Event的数量过多
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.49560739509179984626273807391017:50001231000000:2800:D428AD3A400E16C4CDEE7EFBE7CFE2623758C9FB95F0EA0B5350456E2F1122A1.png)
Immediate Priority Event的数量过多。
案例八：加密应用
原理：主线程等解密的秘钥一直等不到，导致长时间sleep后卡死。
特征：这类问题只通过栈就可以确定，00 帧到 20 帧基本完全一致，01、02 帧反编译后是 IsValidScriptBuffer 和 RunScriptBuffer
解决方案：一般由加密应用 hdc install 安装方式引起，从应用市场重新安装即可解决
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.79837791141509972663675682280728:50001231000000:2800:9A1C119E81DFDAB558130CD12E1F788A743DAC35E295367A02D1A5F49484A540.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151219.73611768804858742177379721179055:50001231000000:2800:2871735DDAE2A66E18E973A7151DADA09B60FAC9D7D823AC2F30319F2D1EE1D3.png)
后续观察kernel stack，发现代码逻辑进入内核的代码，且等锁。
调度问题案例分析
案例九：整机CPU负载高导致后台应用GC线程调度不到资源
调度问题的典型特征是trace中freeze前有大段的runnable状态。下图是hiviewx应用appfreeze问题的trace，从trace中可以看出，问题发生前应用的所有线程都处于调度不到的状态，而此时主线程正好在触发方舟虚拟机的GC，因此freeze栈顶会挂在方舟的GC里。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.21188323163767846481897610126308:50001231000000:2800:43CA106478537D7B4A4615D2DFDC188F52023EC7C8460802D714C9B65C926ED1.png)
进一步分析日志，发现此时整机CPU负载达到60%以上，而hiviewx为后台应用，且GC线程本身优先级较低，在高负载场景下，无法调度到CPU资源，导致执行超时。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.64133614533431932802232732183534:50001231000000:2800:E647C8B5A23854D5CDAAB4A61DB5F67FCE7D0F3B92F0A799C619BEB9EA6CE3EC.png)
解决方案：该问题GC触发的原因是虚拟机判断进程处于空闲场景触发的IdleGC，对于CPU高负载场景，可以选择不触发IdleGC。判定空闲场景通知做GC任务前，先获取当前的cpu使用率，高于50%的cpu使用率就放弃当次任务通知。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.07914937047606944055347969176119:50001231000000:2800:6623428AF7E11FD158FB6606382AAE4EA42332AC0F6E16A5522E542496E18EC2.png)
系统库问题案例分析
案例十：除去jsruntime的栈顶后，freeze栈3S和6S执行的系统库代码相同
问题背景：
Beta用户使用网页在线表格编辑突然卡死，表格点击没反应。
定位过程：
根据问题单发现，beta用户只提供了appfreeze和hilog，没有日志，最好的分析方法是看trace，但崩溃点trace缺失，只能结合appfreeze和hilog分析。
3S栈：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.48983096201288134385730835841030:50001231000000:2800:5D1F57A26EF156F1665B487DC1C8104B15C3E875C73E32BF67981B090FA17D52.png)
6S栈：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.96694943063892286683762899661857:50001231000000:2800:D260C18F84E8A62933AFBB6A0DFACE9A51B346BDD309C607C688AA2A2B19B932.png)
从3s和6s栈可以看出，栈顶都是在libark_jsruntime.so但栈顶不同。由于无法提供trace，只能根据堆栈和日志分析。
通过继续查看堆栈可以发现libark_jsruntime.so下面的调用栈3S和6S是相同的，然后跳过libark_jsruntime.so，发现下面在调arkui的深拷贝(getDeepCopyOfObjectRecursive);
然后我们再看对应时间点得日志，可以看到在appfreeze之前的一段时间一直在做GC操作，这说明是应用一直在执行JS逻辑，再结合崩溃栈看，应用是在做一个很大的对象的深拷贝，导致耗时产生了appfreeze。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.97156371815413115027150010938773:50001231000000:2800:FC8BEFC571E775051D09540C4F315E90101FF1EAECD87615991D2990B1DF9683.png)
分析出结论后，需找ArkUI和应用确认，ArkUI那边的结论与分析结果相同，推断应用应该是用@prop修饰了一个很大的对象，导致深拷贝时耗时；
然后找应用确认，应用确认是使用了@prop修饰了大对象，根据arkui的建议进行整改。
解决方案：用@prop修饰子组件时，当父组件刷新时子组件对象会进行深拷贝，当子组件很复杂时可能导致拷贝超时，应用排查后改用@ObjectLink修饰，避免深拷贝的开销。
案例十一：系统库死锁导致freeze冻屏
问题背景：
华为视频应用发生freeze，3S和6S栈显示主线程一直在wait。
3S栈
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.99658199990973566755304125232573:50001231000000:2800:214F1386997AC1B13069F54D974EFF1F1341937905239E588E4EACE30DD8464D.png)
6S栈
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.86570302477835900633047691150716:50001231000000:2800:06AAD9B5FDAE0D5B8610293091B0784C3595C31619B5181BA15194289E023DE3.png)
定位过程：
主线程3S和6S栈相同且一直显示在wait，这种问题一般发生在主线程需要等待其他线程唤醒，而其他线程发生死锁，导致主线程一直wait不到，最终产生冻屏。因此，我们首先需要确认主线程在等什么线程唤醒，然后再去看对应线程是否存在死锁问题。对于该问题场景，主线程是在UpdateState，说明有其他线程发起了SuspendAll任务去触发SharedGC，而SharedGC又需要等所有线程都走到Suspend状态，初步怀疑是有其他work/taskpool线程发生死锁，导致无法走到Suspend状态。查看堆栈中其他线程的状态，发现18544线程持锁发起了SuspendAll(AllocateWithExpand接口中持有了allocateLock_)，而18545线程调用TryAllocate接口又会等allocateLock_锁，从而导致死锁。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.60506848366169720481538709258846:50001231000000:2800:93B747039F7F60FEB178AF2BBAD7EF79FA2F22A8F3EF1027A3EFA6E5A5C295C5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.52967449294670670240006346169419:50001231000000:2800:E2B5AFBFDF5AD286E27F20E0FE5D8F2BCD04046CCAA37645E56E91442E4DE0AC.png)
解决方案：开发者在写多线程代码时，一定要管理好锁的状态，防止不同线程间发生死锁。对于上述案例，修改方案是不要在持锁状态下发起SuspendAll，修改如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.35902881872193937889246058776824:50001231000000:2800:B8DF034CCCA47AC2390DC9A7FA7220563BC7D6AE74CE197A65ED00C54760F3C4.png)
IO问题案例分析
案例十二：读写交替场景频繁写入影响读的性能
问题背景：应用启动时发生freeze卡死，瞬时栈:
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.58715369748809190505542808497688:50001231000000:2800:0C85E4EFAA9485C6D6479250FA43FD9F3E2CFD6FB8CE1C928D36F5F03A0B02AB.png)
定位过程：
瞬时栈相关调用为vm加载abc接口。
通过trace信息看到主线程主要耗时在IO操作：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.76477525368750924462710823972831:50001231000000:2800:B308A01622625313FF586F0EE22176D87C6842976C5A22F802F558E3B26CB047.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.20226335314414465450870930123827:50001231000000:2800:BE5DAF4A56ED8AEE160D03ABCADAE20F9FEF944463B44C792FCAFBBB34AA0F1F.png)
分析方法
lO行为判断不要完全通过trace上的显示io/non-io，要通过唤醒关系来判断，如果Uninterruptible sleep的后面一个runnable，trace上显示是udk-irq线程唤醒，则是IO行为。trace上显示fsverity、fsignature、hmfs_txn，都会与IO行为相关，只是在IO行为上叠加了校验等行为，IO行为分析方向：
当前版本已经切换较多文件系统，涉及到IO的线程可能比之前更多，但是唤醒关系上最终都会收敛到udk-irq线程
可以看出问题场景IO整体性能差，写入量较大，导致器件频繁gc，降低了器件的IO带宽。同时是读写交替的场景，写入会影响读取的性能，导致部分读IO性能下降。
经过分析问题读写场景，后台有BMS进行安装，安装过程中需拷贝三次hap，IO量大，导致读IO性能下降，产生freeze。
解决方案：在原本的应用安装流程中，会经历三次hap包的拷贝，导致IO写入量很大，包管理子系统最终的优化方案是优化最后一次hap包拷贝的耗时，将copy该成rename。
安装流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151220.65202561298165458620989399357906:50001231000000:2800:5296D188553AC209D0F461E246F41ACC5916F67E55FC2B93B47F86CFB2D5996E.png)
1.应用市场线程从网络下载应用hap包，先保存在tmp文件中，共2.6G。
2.下载完毕后将tmp文件rename为entry.hap，此步无IO。
3.应用市场线程调用BMS的StreamInstall接口，将hap包写入el1的stream_install文件夹中（正常从应用市场目录拷贝到bms的目录），共2.6G。
4.foundation的BMS线程将hap从stream_install复制到security_stream_install中（因为安全问题，步骤3的fd返回给应用市场客户端会有被纂改的风险，额外拷贝一次安全目录），共2.6G。
5.installs线程从hap包中解压名种so文件，共300M。
6.installs线程从security_stream_install文件夹将entry.hap复制到应用沙箱中，共2.6G。
7.安装完成后先后删除el1两文件夹中的hap、应用市场沙箱中的hap。
小结
对于Freeze冻屏问题，需要结合freeze栈、trace、log三方面信息进行准备定位定界。我们需要提取出典型问题特征，根据这些特征初步定位是应用自身问题、系统库问题、调度问题还是IO问题，再进一步判断是代码逻辑复杂、接口调用频繁还是死锁等问题，最后针对问题根因确认解决方案。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-crash
爬取时间: 2025-05-01 09:08:26
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-crash-cpp
爬取时间: 2025-05-01 09:08:39
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-crash-cpp-way
爬取时间: 2025-05-01 09:08:53
来源: Huawei Developer
进程崩溃指C/C++运行时崩溃。FaultLogger模块提供进程崩溃故障检测、日志采集、日志存储、日志上报的能力，为开发者提供详细的维测日志以辅助故障定位。
本文将分别介绍进程崩溃检测能力、崩溃问题定位分析思路。在使用本指导分析处理崩溃日志前，需要开发者了解C/C++程序堆栈信息的基础知识。
问题定位步骤与思路
崩溃日志获取
进程崩溃日志是一种故障日志，与应用无响应日志、JS应用崩溃等都由FaultLogger模块进行管理，可通过以下方式获取：
-  DevEco Studio会收集设备/data/log/faultlog/faultlogger/路径下的进程崩溃故障日志到FaultLog下，根据进程名和故障和时间分类显示。获取日志的方法参见：DevEco Studio使用指南-FaultLog。
-  hiAppEvent 提供了故障订阅接口，可以订阅各类故障打点，详见HiAppEvent介绍。
-
-
-
1.
2.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151221.43364789274811032288666760027855:50001231000000:2800:3D2E2EA9179CA7F3A1D5944E4F1B52D453FC5DAA55ADF3EB283D5E77E3BFF666.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151221.29374782189373380049825074172461:50001231000000:2800:1778087325B4AB77353A96E6EC8515A0F90D905EF8FAE7A519903E9B1AD39CC2.png)
目前主要支持的崩溃异常信号类型参见故障类型，对获取的日志进行分析详见日志规格。
基于崩溃栈定位行号
方式一：DevEco Studio 开发者环境下，支持调用栈直接跳转到对应行号
在应用开发场景，对于应用自身的动态库，生成的cppcrash堆栈可直接跳转到代码行处，支持Native栈帧和JS栈帧，无需开发者自行进行解行号操作。对于部分未能解析跳转到对应行号的栈帧，可参考方式二解析。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151221.33431148311697842489314531444739:50001231000000:2800:C6F3C07B9024124524C2103B5C535DB95C86CD16F7937860F0B7EBF7CC35ABC4.png)
方式二：通过SDK llvm-addr2line 工具定位行号
1.  **说明：**对于系统动态库符号表，随版本进行归档。
2.  基于SDK llvm-addr2line解析行号如下所示： llvm-addr2line 逐行解析的命令为：llvm-addr2line.exe -fCpie libutils.z.so 偏移量，偏移量可以多个一起解：llvm-addr2line.exe -fCpie libxxx.so 0x1bc868 0x1be28c xxx。使用llvm-addr2line后，如果得出的行号看起来不是很正确，可以考虑对 地址进行微调(如减1)，或者考虑关闭一些编译优化。
方式三：通过 DevEco Studio hstack 工具解析堆栈信息
hstack是DevEco Studio为开发人员提供的用于将release应用混淆后的crash堆栈还原为源码对应堆栈的工具，支持Windows、Mac、Linux三个平台。参考hstack使用指南
结合业务检视代码
根据基于崩溃栈定位行号章节中介绍的三种方式获取到栈顶对应的行号后，回到代码中，检视上下文。如下图所示，hello.cpp中的48行是一个空指针解引用的代码问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151221.78667631804768624696884569298648:50001231000000:2800:96A065947C7C6260BCEDAA59BFB793571E08538DBE4811159E135787C565481F.png)
本场景是一个故障构造的应用，实际的场景往往不会这么简单，需要结合实际业务进行分析。
反汇编（可选）
一般而言，如果是比较明确的问题，反编译定位到代码行就能够定位；较少数的情况，比如定位到某一行里面调用的方法有多个参数，参数又涉及到结构体等，就需要借助反汇编来进一步分析。
CppCrash 常见问题分类与原因
-  多线程操作集合，std库的集合为非线程安全，如果多线程添加删除，容易出现SIGSEGV类崩溃，如果使用 llvm-addr2line 后的代码行与集合相关，可以考虑这个原因。 不匹配的对象生命周期，比如使用裸指针（不含有封装、自动内存管理等特性的指针）保存sptr类型以及shared_ptr类型，会导致内存泄漏和悬空指针问题。裸指针是指不含有封装、自动内存管理等特性的指针。它只是一个指向内存地址的简单指针，没有对指针指向的内存进行保护或管理。裸指针可以直接访问指向的内存，但也容易出现内存泄漏、空指针引用等问题。因此，在使用裸指针时需要特别小心，避免出现潜在的安全问题；推荐使用智能指针来管理内存。
-  多线程操作集合，std库的集合为非线程安全，如果多线程添加删除，容易出现SIGSEGV类崩溃，如果使用 llvm-addr2line 后的代码行与集合相关，可以考虑这个原因。
-  不匹配的对象生命周期，比如使用裸指针（不含有封装、自动内存管理等特性的指针）保存sptr类型以及shared_ptr类型，会导致内存泄漏和悬空指针问题。裸指针是指不含有封装、自动内存管理等特性的指针。它只是一个指向内存地址的简单指针，没有对指针指向的内存进行保护或管理。裸指针可以直接访问指向的内存，但也容易出现内存泄漏、空指针引用等问题。因此，在使用裸指针时需要特别小心，避免出现潜在的安全问题；推荐使用智能指针来管理内存。
-  创建一个 RecursiveClass 对象时，它的构造函数被调用。销毁这个对象时，它的析构函数被调用。在析构函数中，创建了一个新的RecursiveClass对象，这会导致递归调用，直到栈溢出。递归调用导致了无限的函数调用，最终导致栈空间耗尽，程序崩溃。
-  多线程操作集合，std库的集合为非线程安全，如果多线程添加删除，容易出现SIGSEGV类崩溃，如果使用 llvm-addr2line 后的代码行与集合相关，可以考虑这个原因。
-  不匹配的对象生命周期，比如使用裸指针（不含有封装、自动内存管理等特性的指针）保存sptr类型以及shared_ptr类型，会导致内存泄漏和悬空指针问题。裸指针是指不含有封装、自动内存管理等特性的指针。它只是一个指向内存地址的简单指针，没有对指针指向的内存进行保护或管理。裸指针可以直接访问指向的内存，但也容易出现内存泄漏、空指针引用等问题。因此，在使用裸指针时需要特别小心，避免出现潜在的安全问题；推荐使用智能指针来管理内存。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-crash-cpp-case
爬取时间: 2025-05-01 09:09:06
来源: Huawei Developer
本文从信号分类、问题场景分类和维测工具分类三个维度来对CppCrash典型问题进行分析和归纳。 信号分类，侧重对常见崩溃信号覆盖介绍，各类信号提供一个典型案例。 问题场景分类，侧重归纳目前高频问题背后的通用场景，各类场景提供一个典型案例。 维测工具分类，侧重总结各类维测工具如果使用类分析相应的问题，各类工具提供一个典型案例。
从信号维度分析问题
类型一：SIGSEGV类崩溃问题
SIGSEGV信号伴随着程序发生段错误（Segmentation Fault）故障，其故障场景为当程序试图访问不被允许访问的内存区域（比如，尝试写一块属于操作系统的内存），或以错误的类型访问内存区域（比如，尝试写一块只读内存）。概括有如下几点：
-  SIGSEGV是在访问内存时发生的错误，它属于内存管理的范畴。
-  SIGSEGV是一个用户态的概念，是操作系统在用户态程序错误访问内存时所做出的处理。
-  当用户态程序访问（访问表示读、写或执行）不允许访问的内存时，产生SIGSEGV。
-  当用户态程序以错误的方式访问允许访问的内存时，产生SIGSEGV。
SIGSEGV在很多时候是由于指针越界引起的，但并不是所有的指针越界都会引发SIGSEGV。如果不解引用越界指针，是不会引起SIGSEGV崩溃的。而且即使解引用了一个越界的指针，也不一定会引起SIGSEGV。SIGSEGV涉及到操作系统、C库、编译器、链接器各方面的内容，以如下具体的例子来说明。
1.  这是最常见的一个例子。此例中，"hello world" 作为一个常量字符串，在编译后会被放在 .rodata 节（GCC），最后链接生成目标程序时 .rodata 节会被合并到 text segment 与代码段放在一起，故其所处内存区域是只读的。这就是错误的访问类型引起的 SIGSEGV(SEGV_ACCERR) 崩溃。
2.  样例代码如下： 在这个例子中，我们访问了一个属于内核的地址。当然很少会有人这样写程序，但程序可能在不经意的情况下做出这样的行为，产生SIGSEGV(SEGV_MAPERR)@0xffffffcfc42ae6f4的崩溃。本例中的CppCrash故障日志（仅展示核心日志内容）如下：
3.  在实际情况中，此例中的空指针可能指向用户态地址空间，但其所指向的页面实际不存在，便是最常见的空指针解引用的场景，这类场景CppCrash日志会识别出来，并在Reason字段打印推断信息 Reason:Signal:SIGSEGV(SEGV_MAPERR)@000000000000000000 probably caused by NULL pointer dereference，如下图所示：
4.  重复释放内存的场景，系统会抛出 SIGSEGV(SI_TKILL) 类故障提示为非法的内存操作，如下图所示： 以上是 SIGSEGV 类崩溃比较常见的原因，除此之外还有栈溢出内存访问、堆溢出内存访问、访问全局区野指针、函数跳转到一个非法的地址上执行，以及非法的系统调用参数等一些场景都有可能触发 SIGSEGV 。SIGSEGV和操作系统栈分配回收、编译器有着密切的联系。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151221.03904191788833384556404187004115:50001231000000:2800:65CABA1050C155B570A5307B302DE9B9C7EDE42B8371D7E8BF4FFA5BAC68168F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151221.41448766545569254138997663534356:50001231000000:2800:AAAC51E30EE137BE4509230EB8E22845BB7072B30C9B8E6CEBDB743D2DF2A36B.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151221.06696857554030177948776937219217:50001231000000:2800:BC98569E02B1688169F44256AB8FFEA5528D9710DC16BD50E274E3BDBCF9C716.png)
类型二：SIGABRT类崩溃问题
SIGABRT信号被发送到进程，告诉进程中止。既可以进程自己调用C标准库的abort()函数，信号通常由进程本身发起，也可以跟其他信号一样从外部发送给进程。
1.  该场景是主动调用 abort() 函数构造，对应的场景是各基础库可能会存在一些安全校验，对于识别为会导致进程无法安全运行性的场景，会主动 abort。对应如下场景如下图所示，会将进程退出前的最后一条fatal级别日志打印到崩溃日志中。
2.  除了调用 abort() 函数外，C++中的另一个异常处理机制还包括 assert() 函数，其他的还有 exit() 函数，异常捕获机制（try-catch）、exception类等。assert用于校验当前函数执行流程中的一些数据，校验失败进程会主动 abort。对应的故障场景如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151221.83975916446999720595827821280151:50001231000000:2800:8746DF45528C1A3E4EEE6C86FFABEA3B4D863686B12D801B777F5EB42457109D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151221.70204120627530477522394464269141:50001231000000:2800:04A054FEACCC13BB1482DE674722FBBB4595F521F178CE217C8145146F32F756.png)
从场景维度分析问题
类型一：内存访问类崩溃问题
问题背景 每次崩溃地址0x7f82764b70都在libace_napi_ark.z.so的可读可执行段上。崩溃原因是需要对地址进行写操作，而对应的maps段只有可读、可执行权限没有写权限，当进程试图访问不被允许访问的内存区域时，进程发生内存访问类崩溃。
崩溃调用栈如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151221.38605246903592919545046601989990:50001231000000:2800:52041D0FFE3F2E410353CFA609CD9FD929BE9D2815CC338D26CAD2CE7831462B.png)
定位思路 每次地址出错都很有规律，但node地址不应该落在libace_napi_ark.z.so，从此类问题的现象来看，很有可能是地址越界问题。地址越界问题可使用ASAN工具排查问题。于是后续使用ASAN版本进行压测复现，也找到了稳定必现的场景。ASAN版本检测出来的问题也和上面崩溃栈反映的问题一致。堆栈报的是heap-use-after-free，实际上是对同一个address进行重复释放，只是在重复释放那次操作时，使用该地址去访问了其对象成员，进而报出了UAF问题。 ASAN核心日志如下：
根据堆栈继续分析， JsiWeak析构或重置的时候会触发其成员(类型为JsiObject/JsiValue/JsiFunction)父类JsiType中CopyableGlobal被释放，如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.78397745351806568518294342730942:50001231000000:2800:4730ACDFF9150CE70FB626CB5D049D4129A2A9692569D44839ADF7965B150839.png)
运行时在GC过程中IterateWeakEcmaGlobalStorage，会对无callback的WeakNode调用DisposeGlobalHandle操作，也对其进行释放，如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.40762307495916809062493450975422:50001231000000:2800:796BA2ED86734957FEF72301AF797BEB37E62E1CB123A72861E5CDCF73379F97.png)
因此，对于同一个WeakNode，可能会存在两个入口释放。如果是GC过程中IterateWeakEcmaGlobalStorage先释放，因为无callback回调通知到JsiWeak进行清理，JsiWeak那边仍保存一个对已释放的WeakNode引用，即CopyableGlobal；当前面讲的WeakNode所在的NodeList被整体释放，归还给操作系统后，JsiWeak处保留的CopyableGlobal再释放，就会存在double-free问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.49410881985621677402215557455069:50001231000000:2800:9CB3209F3D99D0EE9C3B785A63542FD3DA8F54FEEB7BBC8D99661F967ADAADD1.png)
修改方法 JsiWeak调用SetWeakCallback，传入callback，在GC过程中IterateWeakEcmaGlobalStorage释放WeakNode时，通知JsiWeak对其保存的CopyableGlobal进行重置，确保同一个地址不被double-free。
建议与总结 使用内存时应考虑是否存在重复释放或者未释放的可能，另外定位内存访问类崩溃问题（一般是SIGSEGV类型问题）时，如果根据崩溃栈分析问题无头绪时，应优先考虑跑ASAN版本复现问题。
类型二：多线程类问题
问题背景 napi_env释放后仍被使用。
问题场景 napi接口的env传入非法，崩溃栈直接挂在NativeEngineInterface::ClearLastError()中，根据日志打印env地址定位，发现是env被释放后仍然被使用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.93910326302396154741805757400806:50001231000000:2800:AD0EB41F72A24A69928B10FE61C243D437FF31A42A82DD09D71AA4794C09DE03.png)
核心崩溃栈如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.22362065120629296831429391249011:50001231000000:2800:138A0A5BB2D8420578F5D30FFE0254261C27A0C5786AF794BF23D9A4AD63E21A.png)
修改方法 一个线程的创建的env，不要传给另一个线程使用。
建议与总结 对于多线程类问题可以打开方舟多线程检测功能，能够更加方便定位问题，见工具类方舟多线程检测章节。
注：napi接口中的env，是引擎创建时候的arkNativeEngine。
类型三：生命周期类问题
问题背景 开发者在写native代码创建napi_value时，需要配合napi_handle_scope一起使用。napi_handle_scope的作用是管理napi_value的生命周期，napi_value只能在napi_handle_scope的作用域范围内进行使用，离开napi_handle_scope作用域范围后，napi_value及它所持有的js对象的生命周期不再得到保护，一旦引用计数为0，就会被GC回收掉，此时再去使用napi_value就会访问已释放的内存，产生问题。
问题场景 napi_value其实是个裸指针（结构体指针），其作用是持有js对象，用于保持js对象的生命周期，保证js对象不被GC当成垃圾对象回收。napi_handle_scope用来管理napi_value，离开napi_handle_scope作用域之后，napi_value由GC回收，napi_value不再持有js对象（不再保护js对象生命周期）。
定位思路 根据崩溃栈反编译找到出现问题的napi接口的上层接口，在上层接口内找到出问题的napi_value，检查napi_value的使用范围是否超出了napi_handle_scope的作用域范围。
案例 napi_value超出NAPI框架的scope，如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.47068431113356138690250830054621:50001231000000:2800:22CAE577525A679BD49F03BC0206447740FFC57E834146AADE45FC44DD84A52B.png)
js侧通过Add接口添加数据，native侧以napi_value保存到vector，js侧通过get接口获取添加的数据，native侧将保存的napi_value以数组形式返回回去，然后js侧读取数据的属性。出现报错：Can not get Prototype on non ECMA Object。跨napi的native_value未使用napi_ref保存，导致native_value失效。 注：NAPI框架的scope即napi_handle_scope，napi开发者可以通过napi_handle_scope来管理napi_value的生命周期。框架层的scope嵌入在js call native的端到端流程中，即进入开发者自己写的native方法前open scope，native方法结束后close scope。
类型四：指针类问题
问题背景 智能指针使用之前未判空，造成进程运行时发生空指针解引用崩溃问题。
问题影响 进程发生崩溃，影响进程的稳定运行，非预期退出。
定位思路
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.34298017727478938111129696985275:50001231000000:2800:B1B12FF76AB0953DF638D04CA122E6EC4A0CF292B66DA5AD770D69268BEEE7D3.png)
空指针类型崩溃可以从故障原因得到提示信息。通过llvm-addr2line解行号发现业务代码中在使用智能指针之前未对智能指针判空，对空地址进行访问导致崩溃产生。
修复方法 对所有使用该指针的地方进行保护性判空。
建议与总结 指针在使用之前应该要进行判空处理，防止访问空指针造成进程崩溃退出。
配合工具分析问题
工具一：ASAN
ASAN使用指南
工具二：方舟多线程检测
基本原理 js是单线程的，操作js对象只允许发生在创建该js线程上，否则将会有多线程安全问题（主线程创建的js对象只能在主线程上操作，worker创建的js对象只能在worker线程上操作）。napi接口会直接涉及到对象的操作，因此绝大部分（95%）的napi接口只允许在js线程上使用。多线程检测机制检测的是：当前线程和使用的vm/env中的js thread id是否一致，若不一致，则表明vm/env被跨线程使用，存在多线程安全问题。
常见问题有：
使用方法
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.96804754059480961453591170752979:50001231000000:2800:14E118B910C9183D0E2DBEE9463501F4D1D8172426B2C92F608362F52D6F7AF6.png)
DevEco勾选Multi Thread Check选项即可开启方舟多线程检测功能。
使用场景 如果crash日志的堆栈难以分析，出现概率也相对比较高，对于此类问题，应该考虑开启多线程检测。 开启多线程检测之后，如果cpp_crash日志中fatal信息为Fatal: ecma_vm cannot run in multi-thread! thread:3096 currentThread:3550，则发生了多线程安全问题，意思是当前线程号为3550，而使用的js thread却是3096线程创建出来的，跨线程使用vm。
案例 打开后重新触发崩溃，如果是多线程问题，会显示fatal 信息，参考如下:
该信息意思是当前线程号为17585，而使用的 js thread 却是17688 线程创建出来的，跨线程使用 vm。vm 就是 js thread 的 napi_env__* ，运行线程代码的环境，一个线程使用一个 vm。 崩溃日志核心部分如下所示：
多线程问题分析步骤： i. 检查 libace_napi.z.so 下面的第一个栈帧，上图为xxxxx.so，判断是否把 17688 线程的 napi_env 传给了 17585 线程； ii. 如果 libace_napi.z.so 下面的栈帧没有明显的 napi_env 参数传递，需要检查是否以结构体成员变量的方式传递；
工具三：objdump
使用方法 objdump二进制是系统侧工具，开发者需要具备HarmonyOS编译环境，项目代码在gitee上可获取，命令如下：
工具在工程目录下prebuilts/clang/ohos/linux-x86_64/llvm/bin/llvm-objdump，命令如下：
使用场景 有些情况下，通过addr2line只能看出代码某一行有问题，无法确认具体是哪个变量异常，此时可以通过objdump反汇编并结合cppcrash寄存器内容，进一步确认具体崩溃原因。
案例 日志内容如下：
首先先用addr2line查看出错的行，如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.03370397703907357908788440809002:50001231000000:2800:3129C0C5D21983E2E58003455FF743F24F0D80CA5E0BD68DBB736FA7C1B66F31.png)
能看出的信息是判断IsYongSpace的时候访问到了空指针挂了，能够大概猜测出来是Region是空指针。 继续使用objdump反汇编，搜索出错地址4492d4 , 对应的汇编指令如下。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.56785375083228861665982244903422:50001231000000:2800:B3E29570B8A3A15BD41B55BEF1CCD915B1DE17303D3318C1AB98842BDE62FC38.png)
查看x20寄存器，发现为0x000000000000000，x20从上面可以看出是基于x2做位运算(清除掉后18位，典型的Region::ObjectAddressToRange操作)。这样分析之后，就清楚了，x2为MarkObject函数的第二个参数object，x20为变量objectRegion，如下：
上面ldrb w8, [x20]对应 packedData_.flags_.spaceFlag_ 是因为，packedData_是region的第一个域，flags_是packedData_的第一个域，spaceFlag_是flags_的第一个域，所以直接取objectRegion地址对应的第一个字节。 查看汇编代码需要熟悉常见的汇编指令，以及传参规则，例如对于c++非inline的成员函数r0一般保存的是this指针。另外，由于编译器优化，源码和汇编代码对应关系可能不是很直观，我们可以根据代码中的一些特征值(常量)，较快地找到对应关系。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-crash-js
爬取时间: 2025-05-01 09:09:19
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-crash-js-way
爬取时间: 2025-05-01 09:09:33
来源: Huawei Developer
当未处理的JS异常导致应用意外退出时，应用会在抛出未处理的异常时崩溃并且会生成对应的JS Crash崩溃日志文件。开发者可通过错误日志查看引起崩溃的代码位置及分析应用崩溃的原因。
本文将分别介绍JS Crash异常捕获场景，JS Crash故障分析思路。
JsCrash日志分析
JsCrash日志包含异常原因及异常堆栈等定位关键信息，以下是进程崩溃日志信息中对应字段解释。
JS Crash多为应用问题，开发者可通过崩溃文件中的 Error message 和 StackTrace 来定位问题。
JS Crash异常捕获场景
JS Crash异常根据不同的异常场景，在 Reason 字段进行了分类，分为Error、TypeError、SyntaxError、RangeError等错误类型。
问题定位思路
获取日志
进程崩溃日志是一种故障日志，与应用无响应日志、JS应用崩溃等都由FaultLogger模块管理，可通过以下方式获取：
-  DevEco Studio会收集设备“/data/log/faultlog/faultlogger/”路径下的进程崩溃故障日志并归档在FaultLog下，获取日志的方法可参考DevEco Studio使用指南-FaultLog。
-  faultlogger对外提供了故障查询接口，可以查询各种故障信息，详见@ohos.faultLogger (故障日志获取)。
-  hiAppEvent 对外提供了故障订阅接口，可以订阅各类故障信息，详见HiAppEvent (应用事件打点)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.25082065854259840907590906672945:50001231000000:2800:221F830A17C0305B7390BC44BE23583B5C9F2AAF4B3D407344BE91B5209CA859.png)
根因分析
JS Crash问题分析一般根据上述异常的场景，结合错误信息、调用栈定位到源码，可得出基本的分析结论。对于调用栈的分析有以下几种情况。
StackTrace 场景分类
JS Crash故障日志中，StackTrace 字段存放的是 JS Crash 异常的调用栈信息，StackTrace 的显示分为以下几种场景。
```shell
Device info:xxx
Build info:xxx-xxx x.x.x.xxx(xxxx)
Fingerprint:89f2b64b24d642b0fc64e3a7cf68ca39fecaa580ff5736bb9d6706ea4cdf2c93
Module name:com.xxx.xxx
Version:1.0.0
VersionCode:1000000
PreInstalled:No
Foreground:No
Pid:14325
Uid:20020145
Reason:ReferenceError
Error name:ReferenceError
Error message:Cannot find module 'com.xxx.xxx/entry/EntryAbility' , which is application Entry Point
Stacktrace:
SourceMap is not initialized yet
#01 pc 000000000028ba3b /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#02 pc 00000000001452ff /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#03 pC 0000000000144c9f /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#04 pc 00000000001c617b /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#05 pc 00000000004c3cb7 /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#06 pc 00000000004c045f /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#07 pc 000000000038034f /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#08 pc 00000000004b2d9b /system/libó4/platformsdk/libark_jsruntime.so(bf6ea8e474ac3e417991f101e062fa90)
#09 pc 0000000000037e7f /system/libó4/platformsdk/libace_napi.z.so(10ceafd39b5354314d2fe3059b8f9e4f)
#10 pc 00000000000484cf /system/lib64/platformsdk/libruntime.z.so(3f6305a3843fae1de148a06eec4bd014) <- 异常抛出位置
#11 pc 000000000004fce7 /system/libó4/platformsdk/libruntime.z.so(3f6305a3843fae1de148a06eec4bd014)
#12 pc 000000000004e9fb /system/libó4/platformsdk/libruntime.z.so(3f6305a3843fae1de148a06eec4bd014)
#13 pc 000000000004eb7b /system/libó4/platformsdk/libruntime.z.so(3f6305a3843fae1de148a06eec4bd014)
#14 pc 000000000004f5c7 /system/libó4/platformsdk/libruntime.z.so(3f6305a3843fae1de148a06eec4bd014)
#15 pc 00000000000303cf /system/lib64/platformsdk/libuiabilitykit_native.z.so(3203F4CCe84a43b519d0a731dfOdb1a3)
```
调用栈分析
调用栈分析会有如下两种情况：
-  如果FaultLog的堆栈信息中的链接或偏移地址指向的是当前工程中的某行代码，该段信息将被转换为超链接形式，在DevEco Studio中点击后跳转至对应代码行。
-  如出现Cannot get Source Map info, dump raw stack信息代表js栈转换ets行列号失败，在DevEco Studio中点击链接会跳转到不正确的代码位置或不存在的代码行位置。可参考：应用堆栈解析。
异常定位信息增强工具说明
案例一：模块化相关异常
可使用DevEco Studio集成工具，选择以接收更详细的错误信息。此功能仅适用于从ArkTS调用C++代码时发生的错误。 勾选红框选项，如下样例所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.00425375055460782728133233762668:50001231000000:2800:B34C04A7D3BC84C33AEFA3944D0DF36801409F305D5F91EDB965FE815535E402.png)
需要删除镜像中/system/lib64/module/libhidebug.z.so中的文件，代码如下样例所示。
未勾选Enhanced Error Info
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.16845043222874751282082661257891:50001231000000:2800:FBF69A489CE3AB7E797C96A5BCF648CC2BBB0EA53611031A43E77E049F35C280.png)
勾选Enhanced Error Info
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.95741093897792321974851081929600:50001231000000:2800:22D8E876B86765C6F607F10B2736010C37F5D278204D3B1F0E24FF5279E534C7.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-crash-js-case
爬取时间: 2025-05-01 09:09:46
来源: Huawei Developer
本文将基于现在开发者所遇到的高频的两类JS Crash故障进行案例介绍，包含 TypeError 和 Error 类。
TypeError类案例分析
TypeError类问题在实际应用开发调试运行过程中是最常见的JS Crash类型，其表示为变量不是预期类型，在代码层面则为对变量的使用未进行事先的校验，在错误日志中报错多表现为如下：
案例一：更新跟手动效相关属性时偶现JS Crash
1.  通过日志信息可以确定为Type Error类问题，由异常信息得知是在读取needRenderTranslate对象时报错，该对象对undefined。最后可以通过异常代码调用栈，获取错误产生位置。 Cannot get SourceMap info, dump raw stack 信息表示该应用为release包安装，JS栈转换eTS行列号失败，可考虑使用应用堆栈解析来解析行号。
2.  对于这类问题，需要我们在编码阶段充分考虑对象访问的安全性，确保必要的判空处理。同时很多场景单纯的判空可能只能是规避问题，还需要结合业务看看是否是原始对象构造或赋值的逻辑存在问题。
Error 类案例分析
Error 类问题一般是开发者或JS库主动抛出来的JS异常。
这类问题目前有两种场景：
案例一：如何主动抛出一个自定义的JS异常来终止程序
开发者自主抛出JS异常，可通过如下代码实现：
通过上述开发过程基于 DevEco Studio FaultLog工具收集到的故障日志，可以基于JS异常栈直接定位到抛异常的位置。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151222.04258737805111130516795854998143:50001231000000:2800:A532140DF3C805EC43C8F0A33895C09A2B93F2C001FCE1695B2A66731AC1A19D.png)
遇到这类问题的解决思路，仍旧是通过故障日志定位到具体的代码行，检视上下文来分析问题即可。
案例二：因未处理三方接口抛出的JS异常导致的JS Crash问题
1.  通过日志信息可以确定为 Error 类问题，为代码主动抛出的异常。最后可以通过异常代码调用栈，获取错误产生位置。 Cannot get SourceMap info, dump raw stack 信息表示该应用为release包安装，JS栈转换eTS行列号失败，可考虑使用应用堆栈解析来解析行号。
2.  对于这类问题，我们可以考虑在编码阶段灵活的运用 JS 异常机制，来识别各类异常场景；同时对于使用可能会抛异常的接口，也需要考虑是否需要捕获该异常，避免影响应用主体业务。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-opt
爬取时间: 2025-05-01 09:09:59
来源: Huawei Developer
良好的编码习惯以及有效的日志维测方案，能够提升系统的健壮性和问题定位效率。本章汇总了ArkTS、Node-API开发规范，挑选了部分影响应用程序稳定性的编码规范，同时还汇总了hilog日志打印规范，建议开发者按照规范来进行编码以及日志打印。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard
爬取时间: 2025-05-01 09:10:12
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-ndk-arkts
爬取时间: 2025-05-01 09:10:25
来源: Huawei Developer
ArkTS会通过引用编译好的so来使用native侧方法。为避免不规范的引用导致运行时异常，增加不必要的故障排查成本，开发者可根据本文标准进行引用。
NDK工程创建步骤及目录结构可参考：创建NDK工程。
import本模块的so
配置依赖：
模块根目录 > oh-package.json5。
依赖文件中的so名称要与CMakests.txt文件中的模块名称一致。
模块根目录 > src > main > cpp > CMakeLists.txt
引用native方法：
引用依赖的so，名称要与oh-package.json5中的一致。
```typescript
import { hilog } from '@kit.PerformanceAnalysisKit';
// import依赖的so
import testNapi from 'libentry.so';
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
// 调用native方法
hilog.info(0x0000, 'testTag', 'Test NAPI 2 + 3 = %{public}d', testNapi.add(2, 3));
})
}
.width('100%')
}
.height('100%')
}
}
```
调用的方法名称要和.d.ts中导出的方法名一致。
模块根目录 > src > main > cpp > types > libentry > index.d.ts
```typescript
export const add: (a: number, b: number) => number;
```
import其它模块的so
公共的so可以在har/hsp中编写，供其它模块调用。
引用方模块
本地依赖：
模块根目录 > oh-package.json5
远程依赖：
```typescript
import { hilog } from '@kit.PerformanceAnalysisKit';
// 引用依赖模块中的napi
import { testNapi } from 'library';
@Entry
@Component
struct Index {
@State message: string = 'Hello World';
build() {
Row() {
Column() {
Text(this.message)
.fontSize(50)
.fontWeight(FontWeight.Bold)
.onClick(() => {
// 调用napi中的方法
hilog.info(0x0000, 'testTag', 'Test NAPI 2 + 3 = %{public}d', testNapi.add(1, 2));
})
}
.width('100%')
}
.height('100%')
}
}
```
导出方模块
通过统一出口将napi导出
模块根目录 > index.ets

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-node
爬取时间: 2025-05-01 09:10:39
来源: Huawei Developer
获取JS传入参数及其数量
【规则】当传入napi_get_cb_info的argv不为nullptr时，argv的长度必须大于等于传入argc声明的大小。
当argv不为nullptr时，napi_get_cb_info会根据argc声明的数量将JS实际传入的参数写入argv。如果argc小于等于实际JS传入参数的数量，该接口仅会将声明的argc数量的参数写入argv；而当argc大于实际参数数量时，该接口会在argv的尾部填充undefined。
错误示例
正确示例
生命周期管理
【规则】合理使用napi_open_handle_scope和napi_close_handle_scope管理napi_value的生命周期，做到生命周期最小化，避免发生内存泄漏问题。
每个napi_value属于特定的HandleScope，HandleScope通过napi_open_handle_scope和napi_close_handle_scope来建立和关闭，HandleScope关闭后，所属的napi_value就会自动释放。
正确示例：
上下文敏感
【规则】多引擎实例场景下，禁止通过Node-API跨引擎实例访问JS对象。
引擎实例是一个独立运行环境，JS对象创建访问等操作必须在同一个引擎实例中进行。若在不同引擎实例中操作同一个对象，可能会引发程序崩溃。引擎实例在接口中体现为napi_env。
错误示例：
所有的JS对象都隶属于具体的某一napi_env，不可将env1的对象，设置到env2中的对象中。在env2中一旦访问到env1的对象，程序可能会发生崩溃。
异常处理
【建议】Node-API接口调用发生异常需要及时处理，不能遗漏异常到后续逻辑，否则程序可能发生不可预期行为。
正确示例：
如上示例中，步骤1或者步骤2出现异常时，步骤3都不会正常进行。只有当方法的返回值是napi_ok时，才能保持继续正常运行；否则后续流程可能会出现不可预期的行为。
异步任务
【规则】当使用uv_queue_work方法将任务抛到JS线程上面执行的时候，对JS线程的回调方法，一般情况下需要加上napi_handle_scope来管理回调方法创建的napi_value的生命周期。
使用uv_queue_work方法，不会走Node-API框架，此时需要开发者自己合理使用napi_handle_scope来管理napi_value的生命周期。
正确示例：
对象绑定
【规则】使用napi_wrap接口，如果最后一个参数result传递不为nullptr，需要开发者在合适的时机调用napi_remove_wrap函数主动删除创建的napi_ref。
napi_wrap接口定义如下：
当最后一个参数result不为空时，框架会创建一个napi_ref对象，指向js_object。此时开发者需要自己管理js_object的生命周期，即需要在合适的时机调用napi_remove_wrap删除napi_ref，这样GC才能正常释放js_object，从而触发绑定C++对象native_object的析构函数finalize_cb。
一般情况下，根据业务情况最后一个参数result可以直接传递为nullptr。
正确示例：
高性能数组
【建议】存储值类型数据时，使用ArrayBuffer代替JSArray来提高应用性能。
使用JSArray作为容器储存数据，支持几乎所有的JS数据类型。
使用napi_set_element方法对JSArray存储值类型数据（如int32）时，同样会涉及到与运行时的交互，造成不必要的开销。
ArrayBuffer进行增改是直接对缓冲区进行更改，具有远优于使用napi_set_element操作JSArray的性能表现。
因此此种场景下，更推荐使用napi_create_arraybuffer接口创建的ArrayBuffer对象。
示例：
napi_create_arraybuffer等同于JS代码中的new ArrayBuffer(size)，其生成的对象不可直接在TS/JS中进行读取，需要将其包装为TyppedArray或DataView后方可进行读写。
基准性能测试结果如下：
以下数据为千次循环写入累计数据，为更好的体现出差异，已对设备核心频率进行限制。
| 容器类型  | Benchmark数据（us）  |
| --- | --- |
| JSArray  | 1566.174  |
| ArrayBuffer  | 3.609  |
容器类型
Benchmark数据（us）
JSArray
1566.174
ArrayBuffer
3.609
数据转换
【建议】尽可能的减少数据转换次数，避免不必要的复制。
模块注册与模块命名
【规则】
nm_register_func对应的函数需要加上修饰符static，防止与其他so里的符号冲突。
模块注册的入口，即使用__attribute__((constructor))修饰函数的函数名需要确保与其他模块不同。
模块实现中.nm_modname字段需要与模块名完全匹配，区分大小写。
错误示例
以下代码为模块名为nativerender时的错误示例
正确示例：
以下代码为模块名为nativerender时的正确示例
正确的使用napi_create_external系列接口创建的JS Object
【规则】napi_create_external系列接口创建出来的JS对象仅允许在当前线程传递和使用，跨线程传递（如使用worker的post_message）将会导致应用crash。若需跨线程传递绑定有Native对象的JS对象，请使用napi_coerce_to_native_binding_object接口绑定JS对象和Native对象。
错误示例
防止重复释放获取的buffer
【规则】使用napi_get_arraybuffer_info等接口，参数data资源开发者不允许释放，data的生命周期受引擎管理。
这里以napi_get_arraybuffer_info为例，该接口定义如下：
data获取的是ArrayBuffer的Buffer头指针，开发者只可以在范围内读写该Buffer区域，不可以进行释放操作。该段内存由引擎内部的ArrayBuffer Allocator管理，随JS对象ArrayBuffer的生命周期释放。
错误示例：
| Node-API中受当前规则约束的接口有：  |
| --- |
| napi_create_arraybuffer  |
| napi_create_sendable_arraybuffer  |
| napi_get_arraybuffer_info  |
| napi_create_buffer  |
| napi_get_buffer_info  |
| napi_get_typedarray_info  |
| napi_get_dataview_info  |
Node-API中受当前规则约束的接口有：
napi_create_arraybuffer
napi_create_sendable_arraybuffer
napi_get_arraybuffer_info
napi_create_buffer
napi_get_buffer_info
napi_get_typedarray_info
napi_get_dataview_info
其他
【建议】合理使用napi_object_freeze和napi_object_seal来控制对象以及对象属性的可变性。
napi_object_freeze等同于Object.freeze语义，freeze后对象的所有属性都不可能以任何方式被修改；napi_object_seal等同于Object.seal语义，对象不可增删属性。两者的主要区别是，freeze不能改属性的值，seal还可以改属性的值。
开发者使用以上语义时，需确保约束条件是自己需要的，一旦违背以上语义严格模式下就会抛出Error（默认严格模式）。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-cpp
爬取时间: 2025-05-01 09:10:52
来源: Huawei Developer
基础要求
变量
【规则】指针变量、表示资源描述符的变量、BOOL变量声明必须赋予初值
【规则】指向资源句柄或者描述符的变量，在资源释放后立即赋予新值
【规则】类成员变量必须在构造函数中赋予初值
【规则】不对指针变量进行sizeof操作
【建议】尽量使用const
【建议】全局变量的访问如果涉及多个线程需要考虑多线程竞争条件问题
【建议】同一个函数内，局部变量所占用的空间不要过大
函数
【规则】数组作为函数参数时，必须同时将其长度作为函数的参数
【规则】不对内容进行修改的指针型参数，定义为const
【建议】谨慎使用不可重入函数
【建议】字符串或指针作为函数参数时，请检查参数是否为NULL
循环
【规则】循环必须有退出条件
类
【规则】如果构造函数中分配了需要手动释放的资源，则必须有析构函数
【规则】构造函数内不能做任何可能失败的操作
【规则】严禁在构造函数中创建线程
【规则】严禁出现delete this操作
【建议】尽量避免定义public成员
字符串/数组操作
【规则】确保有足够的存储空间
【规则】对字符串进行存储操作，确保字符串有'\0'结束符
【规则】外部数据作为数组索引时必须确保其在数组大小范围内
【规则】外部数据作为复制内存操作函数的长度时，需要校验其合法性
【规则】调用格式化函数时，禁止format参数由外部可控
【规则】调用格式化函数时，format中参数的类型与个数必须与实际参数类型一致
整数
【规则】整数之间运算时必须严格检查，确保不会出现溢出、反转、除0
【规则】整型表达式比较或赋值为一种更大类型，必须先用这种更大类型对它进行求值
【规则】禁止对有符号整数进行位操作运算
【规则】禁止整数与指针间互相转化
【规则】循环次数如果受外部数据控制，需要校验其合法性
【规则】禁止对指针进行逻辑或位运算
内存
【规则】内存申请前，必须对申请内存大小进行合法性校验
【规则】内存分配后必须判断是否成功
【规则】禁止引用未初始化的内存
【规则】内存释放之后立即赋予新值

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-libuv
爬取时间: 2025-05-01 09:11:06
来源: Huawei Developer
前言
libuv是一个优秀的异步I/O库，开发者使用libuv的功能且不出问题，需要花费一定时间研究。在HarmonyOS上，稳定性问题中与libuv相关的故障点，经定位发现，通常由于使用方调用错误导致。一方面说明libuv是稳定的开源库，另一方面证明依照规范正确调用libuv的意义。
本文主要从以下几方面展开，以帮助开发者更加正确地使用libuv相关接口，并在出错时能够排查代码找到问题点：
libuv使用细则
在本章节中，主要从libuv中的Requests和Handles这两个重要概念来阐述具体的使用规范，确保开发者可以正确使用libuv的相关接口，避免应用出现与libuv相关的稳定性问题。至于libuv原理，这里不再赘述，感兴趣的开发者可以参考libuv开发指南。
libuv中Requests使用规范
在libuv开发指南中对Request有过说明，它表示一个暂短的请求，是不会被事件循环长期持有的。一旦请求任务执行完毕，就意味该请求在事件循环上的使命结束，如果想要继续下一次请求，需要再次调用相关接口。在libuv官方文档中，Request主要有如下几种类型：
但是经过异步线程池的只有下面几种：
其中在HarmonyOS中使用最多的就是uv_work_t，这个多用于自定义的异步任务请求，与之配套的接口是uv_queue_work，定义如下：
loop表示请求所在的事件循环，work_cb表示执行在异步线程池的异步任务，after_work_cb表示在事件循环上处理异步任务的执行结果的回调。在HarmonyOS上，uv_queue_work的整个处理过程如下：
了解了uv_queue_work的执行原理后，开发者可以按照下面几种情况使用该接口。
异步任务执行一次即删除
伪代码写法1：
伪代码写法2：
上述代码都遵循了一个基本的约束：对于uv_queue_work的调用方式，只要保证释放内存的操作在after_work_cb中做即可。开发者最好不要自己管理异步任务相关的生命周期，因为谁也不清楚这个任务在什么时间内会做完。对于其它执行在线程池的异步请求，上述结论依旧成立。
多次请求任务共用一个结构体
针对这种场景，如果开发者预期的异步任务是执行完上一次异步请求后，继续使用同一个结构体做同样的请求任务。可以采用下面类似的代码：
这样可以避免频繁申请释放对象来降低开销。
如果开发者无法确保创建的对象与libuv Requests对象之间的生命周期是否需要保持一致的情况下，最好的办法是开发者自定义的对象与Requests对象分开创建，然后将自定义对象放在Requests对象中的data字段。这样可以保证两者互不影响，开发者自定义的对象生命周期管理出现问题的情况下，并不会影响到系统库的正常执行。即便出现了崩溃问题，崩溃栈也会体现在具体的业务逻辑上，而不是系统库上导致问题无法定位。
libuv中Handles使用规范
在libuv开发指南中对Handle有过说明，它表示一个持久的请求，它们可以被事件循环长期持有。如果开发者不主动调用uv_close函数，创建的任何Handle都会持久的保存在事件循环上，影响事件循环的正常退出。在官方文档中，Handle主要有如下几种类型：
但是HarmonyOS中常见的Handles，主要有以下几个：
对于uv_loop_t的使用，一般不会出现严重的问题，开发者在使用时，只需要在事件循环退出时，正确的释放事件循环里面的资源即可，避免事件循环无法退出导致资源泄露的问题。如果开发者创建的事件循环并不清楚上层业务是如何使用这个事件循环的，可以在退出的时候调用uv_walk遍历事件循环上的Handles，在回调里面调用uv_close将Handles从事件循环上摘除，然后执行uv_run将异步任务执行完毕即可。这样可以保证事件循环的正常退出，前提是这个过程，没有其他业务抛任务到事件循环上。具体可参考libuv中的事件循环。
对于libuv中的Handles的使用，开发者只需要做到在不使用它们的时候调用uv_close，且必须在事件循环所在的线程调用，否则就会出现多线程数据竞争的问题。如果开发者想在多线程操作Handles，可以参考libuv开发指南的“libuv timer使用规范“章节。
特别地，这里要注意uv_close的使用，它并不是同步将handle从事件循环上摘除的。说明uv_close的运行逻辑之前，开发者首先要了解几个知识背景：
-  以摘除uv_async_t为例，uv_close运行逻辑如下：
1.  因此，开发者需要注意的是：避免在调用uv_close后到事件循环执行在uv__run_closing_handles期间内，释放Handle句柄。
与libuv相关的Crash案例
本章将讲述一些应用调用uv接口导致的一些Crash案例。
案例一、某应用使用uv_close错误
问题描述：应用native侧调用libuv接口时使用不当导致偶现崩溃，栈体现在libuv上。崩溃栈如下：
原因分析：通过反编译解栈，得到如下调用链：
uv_run->uv__run_closing_handles->uv__finish_close->uv__queue_remove
uv__queue_remove表示将某结点从事件循环队列上摘除。现在崩溃在这个函数上面，又是空指针解引用。这种情况下，开发者只需要参考ASan检测这篇文档，开启ASan后复现，即可将具体崩溃栈获取到。通过解栈定位到具体代码行。在本例中，出错代码如下：
尽管上述写法是个好习惯，将内存的操作放在析构函数里执行。但是开发者并未真正理解uv_close的调用时序。当uv_async_t作为一个普通的成员变量放在NapiTaskRunner里的时候，意味着asyncHandle的生命周期是与NapiTaskRunner保持一致的。当走到析构函数的时候，调用uv_close将该句柄从事件循环上摘除，但是根据前文讲述的，uv_close是个异步的操作，调用后并不能完成整个摘除过程。正是这个疏忽，导致析构函数走完之后，asyncHandle也随之释放。当事件循环再去操作这个结点的时候，发生崩溃。
崩溃原因如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151223.49243888210910793147656102414614:50001231000000:2800:046DE7735288052996CAF50C20CD153903C81B9752DA5353291280B77BEB3F97.png)
解决方法：
如果开发者必须要将asyncHandle放在自定义的对象中，可以将该句柄作为一个指针放在NapiTaskRunner中，在构造函数中new出来，在析构函数中调用uv_close。这样NapiTaskRunner和asyncHandle可以做到互不影响。
案例二、异步任务执行过程中崩溃
异步任务执行过程的崩溃，分三种场景分析：
场景一
问题描述：某应用，在主线程执行after_work_cb之前，函数地址被破坏，产生崩溃，部分调用栈如下：
问题分析：
根据上面的崩溃栈，可以看到第0帧为Not mapped，这表明after_work_cb的地址为ddde2ddf82f7dddd，该地址已经不是一个正常的PC地址，且该地址的ddd和末尾的ddd表示这块内存是被释放过的。因此，很快就能判定这是由于UAF(use after free)导致的崩溃。对于这种问题，开发者可以根据崩溃栈的寄存器信息从里面找到一些现场信息，但是异步任务的崩溃往往离问题现场已经相去甚远了。所以，HarmonyOS还给开发者提供了另一个强大的工具，就是ASan检测，用它复现问题，可以轻松的找到问题现场。下面是通过工具抓到的现场：
初次分配的调用栈：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151223.88618339837502522652854197171227:50001231000000:2800:A0E5EE9CBBBA91456B66A5626E056A3DB4CE8E4CC9A4A81E598C3F19F66C0B37.png)
第一次释放的调用栈：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151223.14680978500207950393467085026103:50001231000000:2800:7D15D30EA9ABEA5A4A2465AC3B08DF34381E1A4538EF8D9CC03D23A437E31EA7.png)
经过相关开发者的反编译定位到现场，代码如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151223.06866223319037099691018320320504:50001231000000:2800:1567EE26D01A71D4FEE9DCF43F01B253680C01D715C7A27CC1C320E02C846E55.png)
问题结论：调用uv_work_t相关的函数时，内存的释放动作一定要放在after_work_cb里面。如果开发者没法控制好自定义对象的生命周期，就可以通过uv_work_t和自定义对象分开的方式，将uv_work_t的释放放在after_work_cb里，自定义对象的内存由开发者自行管理。
场景二
问题描述：某应用，异步任务生命周期管理问题导致崩溃在uv__queue_done期间，崩溃栈如下：
问题分析：
像这种问题都是由于开发者对uv_work_t对象的生命周期管理不当导致的崩溃，但如何溯源实际上一直是一个难题。此案例提供了一种特殊的方法进行溯源，就是通过crash文件中的寄存器信息来推测问题现场。
首先，经过反编译，可以看到具体的代码行和汇编指令，如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151223.86001520602959144415137917679284:50001231000000:2800:A45C18E1C269FD3B01F5B122195581CE156791AC876848EE5E72D35067E4F406.png)
上图红框中的汇编指令含义：
112fc：表示将x8寄存器的值加上十进制的32作为地址，然后将该地址的内容取出来放在w9寄存器中。（其实w9就是x9，一个是32位，一个是64位）w9 = [x8+32]
112f8：将x0寄存器的值减去十进制的24作为地址，将该地址的内容放在x8寄存器里头。x8 = [x0 - 24]。 []表示取内容
再来解释一下上述两个寄存器存放的是什么内容。这里有个基本的知识，在C++函数中，x0寄存器往往对应着函数的第一个形参。所以x0寄存器放的就是形参w的地址。然后根据112f8这条指令，可以知道从x0对应的地址向前偏移24个字节就是x8寄存器的内容。x8表示的内容可由下面的结构体推测出来：
由上面的内存布局，可以断定x8放的实际上就是loop的地址。现在报错在x8寄存器上，实际就验证了上述的结论，这就是一个异步任务的UAF问题。
接下来就是寻找问题现场了。通过上面的uv_work_s的结构体，可以看出该结构体与uv__queue_done的第一个参数w的关系：uv_work_s包含了w，同时也包含了里面最重要的信息after_work_cb的函数指针。
after_work_cb是开发者传入的函数指针，这个函数地址往往是在开发者编写的代码文件中，最终被编到一个动态库（so）里面。这里又引入一个知识点，HarmonyOS上的crash文件都会包含当前应用进程里面映射的so的地址范围，也就是说，开发者是可以通过函数指针的地址在crash文件中找到具体映射在哪个so文件中，通过起始地址来找到具体代码行。因此，看一下x0寄存器是否还保留着after_work_cb的信息。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151223.64347464282735416814251644581315:50001231000000:2800:DBA05F278F0CB9BAA271A8B1508C7DA5A110143F88CC71C6D8BD407E58A4FCE3.png)
幸运的是，x0上面确实能找到after_work_cb的地址，因此只需要根据这个地址来确定它被包含在哪个so的地址范围，并使用该地址减去so的起始地址就可以得到它在so中的偏移地址，通过反编译即可找到具体的代码行。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151223.31905598229839209745347491413314:50001231000000:2800:B4EF2C8C5B18C335097DAE0C40B26F17CCEDEDE0FA1BF0E2452F880A52805714.png)
具体的代码：
上述代码之所以出错，是由于开发者对于uv_cancel这个函数不熟悉导致。对于uv_cancel函数，它的运行逻辑如下：
1.  也就是说，uv_cancel实际上不会真的将异步任务取消，而不去执行开发者抛过来的after_work_cb回调。它会继续往下执行，如果开发者想调用uv_cancel同时又不在回调里判断status是否等于UV_ECANCELED。那代码将不会按照开发者设想执行，假设做不好清理工作，double free或者UAF就会随之而来。
问题结论：异步任务对象内存的释放动作要确保在after_work_cb中做。
场景三
问题描述：某应用调用异步任务，在异步线程池中执行work_cb之前发生崩溃，崩溃栈如下：
问题分析：
由于该问题场景复现极其困难，只能依赖大数据复现，因此工具的作用并不大。最终只能排查代码，将前文伪代码写法2的代码全部分离，采用自定义对象与uv对象独立创建的形式，修改完毕后，该问题不再复现。修改如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151223.50123942393145526513564572404389:50001231000000:2800:1E8E04EC311E47C2DC2A15ECC815338A38E6304D57FD7ED237DEADA44B84E594.png)
问题结论：参考场景一，如果开发者在不确定自定义创建的对象与uv异步任务对象的生命周期管理是否同步的情况下，可以将两者分离开来，独立管理。
与libuv相关的Freeze案例
libuv作为框架提供给开发者一些异步IO的能力，它本身不会造成死锁。如果freeze栈体现的是libuv相关接口在栈顶，都是开发者在主线程（UI线程）调用了libuv一些阻塞式的接口导致。这种情况下，就需要开发者尽量避免在主线程调用libuv的阻塞接口，比如文件的同步读取。另外，开发者使用libuv接口不当也会造成卡死在事件循环框架上，这个后面会介绍到。
案例一、主线程调用uv阻塞接口
问题描述：某应用在主线程调用文件模块的同步接口，该TS接口底层使用uv底层能力。导致在sendfile的时候，阻塞主线程产生freeze。
问题结论：
开发者在使用文件同步接口时，避免在主线程上调用。可以在worker线程或是taskpool上调用。
案例二、pdf必现卡死在事件循环
问题描述：应用在taskpool场景下调用了其他SDK中的so的接口，导致必现卡死在libuv上。
```shell
Tid:61139, Name:example.pdftest
#00 pc 0000000000018044 /system/lib64/platformsdk/libuv.so(uv async_io+360)(fe4a9f2630458fa5b8b7b0e4dacc5f9a)
#01 pc 0000000000017720 /system/lib64/platformsdk/libuv.so(uv_io_poll+1268)(fe4a9f2630458fa5b8b7b0e4dacc5f9a)
#02 pc 0000000000018540 /system/lib64/platformsdk/libuv.so(uv_run+376)(fe4a9f2630458fa5b8b7b0e4dacc5f9a)
#03 pc 00000000000768b4 /system/lib64/platformsdk/libruntime.z.so(OHOS::AbilityRuntime::OHOSLoopHandler:OnTriggered()+148)(09902ebffe1260cecd7be3e24ad58df5)
#04 pc 00000000000195b8 /system/lib64/chipset-pub-sdk/libeventhandler.z.so(96fe4d4a21391569c237423eae1d16df)
#05 pc 0000000000015324 /system/lib64/chipset-pub-sdk/libeventhandler.z.so(OHOS::AppExecFwk::EventHandler:DistributeEvent(std: h:unique ptrOHOS::AppExecFwk:In
#06 pc 0000000000023f78 /system/lib64/chipset-pub-sdk/libeventhandler.z.so(OHOS::AppExecFwk:(anonymous namespace):EventRunnerImpl:ExecuteEventHandler(std:: hu
#07 pc 0000000000023850 /system/lib64/chipset-pub-sdk/libeventhandler.z.so(OHOS::AppExecFwk::(anonymous namespace)::EventRunnerImpl:Run()+872)(96fe4d4a2139156S
#08 pc 0000000000026628/system/lib64/chipset-pub-sdk/libeventhandler.z.so(OHOS::AppExecFwk::EventRunner:Run()+284)(96fe4d4a21391569c237423eae1d16df)
#09 pc 00000000000a5bb4 /system/lib64/platformsdk/libappkit_native.z.so(OHOS::AppExecFwk:MainThread::Start()+764)(b926a67fe9460965838f4a20dbd3a020)
#10 pc 0000000000004880 /system/lib64/appspawn/appspawn/libappspawn_ace.z.so(RunChildProcessor(AppSpawnContent*, AppSpawnClient*)+216)(1f4858241fab18c5ee268
#11 pc 0000000000008788 /system/bin/appspawn(AppSpawnChild+404)(3d1b41c7794e59721bc566882e35a530)
#12 pc 00000000000084c8 /system/bin/appspawn(AppSpawnProcessMsg+636)(3d1b41c7794e59721bc566882e35a530)
#13 pc 000000000000f974 /system/bin/appspawn(ProcessSpawnReqMsg+228)(3d1b41c7794e59721bc566882e35a530)
#14 pc 000000000000f224 /system/bin/appspawn(OnReceiveRequest+172)(3d1b41c7794e59721bc566882e35a530)
#15 pc 0000000000017c9c /system/lib64/chipset-pub-sdk/libbegetutil.z.so(HandleRecvMsg_+260)(6725d8c1610eb726305c093a8f27148c)
#16 pc 00000000000177bc /system/lib64/chipset-pub-sdk/libbegetutil.z.so(HandleStreamEvent_+168)(6725d8c1610eb726305c093a8f27148c)
#17 pc 0000000000014ee0/system/lib64/chipset-pub-sdk/libbegetutil.z.so(ProcessEvent+108)(6725d8c1610eb726305c093a8f27148c)
#18 pc 0000000000014aa0/system/lib64/chipset-pub-sdk/libbegetutil.z.so(RunLoop_+356)(6725d8c1610eb726305c093a8f27148c)
#19 pc 000000000000d3bc /system/bin/appspawn(AppSpawnRun+136)(3d1b41c7794e59721bc566882e35a530)
#20 pc 000000000000ad20 /system/bin/appspawn(main+708)(3d1b41c7794e59721bc566882e35a530)
#21 pc 000000000009eac0 /system/lib/ld-musl-aarch64.so.1(libc start main stage2+64)(82429be6ea2851745621f83dce721120)
```
问题分析：
首先经过反编译，看一下卡死在哪一行：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151223.59348970731405744191726184530386:50001231000000:2800:0464D0BFC17701AACF6F20A316E8161A03D93FE6958F4CB2FE6F125628984C6E.png)
这段代码的逻辑是取loop上的队列依次遍历，然后判断一下内部的pending有没有更改。如果更改则往下执行传入的回调函数。
Freeze发生在这个循环里，一直处于死循环。造成这种现象的原因，主要有两种。
针对第一种情况，可能性不大。最后经过加日志验证，也确实不是这个原因导致的。对于第二种情况，经过GDB的调试，模拟出卡死时链表的操作过程：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151223.52528258046295717273116116929010:50001231000000:2800:A913E788DC5261B95AABC09FAB362928533B459A639BEA885BBBB84B89C08F75.png)
该图表示，在卡死发生的时候，遍历loop上的async_handles队列会把之前取出来的结点再次挂在当前队列上导致死循环。造成这种现象的原因，推断是由于同一个句柄初始化在两个事件循环上导致的两个链表互相交融。为了验证这个推断，再次加日志复现，日志如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.05836061195023666424676281022452:50001231000000:2800:90C8C0CBD6616C8498A12F252EC7CC33F0EE47D4216400A15DF046251BCBC449.png)
该日志确实证明了同一个句柄初始化在了两个loop上，一个是主线程的loop，另一个是taskpool下面的TaskWorker线程。
接下来查看该SDK下的so代码，代码如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.57223503011475468215629644925575:50001231000000:2800:44A5A6ED137B39C17F6F60DF210BB34F60C6413FEF7116C85BB6EC23EFB7DA92.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.84760762378902705972582754778122:50001231000000:2800:A2E5D152CA7ECFD2BB3F018F366852FEC8B149626BEB9DF3A6A42BFE449D3B73.png)
该代码保存了一个普通的uv_async_t对象，存放在一个静态对象中，但并未对其做call_once处理，导致应用代码每次import这个组件的时候，都会进行初始化，才造成了同一个句柄初始化在不同的事件循环上。
问题结论：开发者对于单例的处理应该做call_once处理，同一个句柄初始化在不同的loop上会导致事件循环的死循环。如果在主线程上，则会出现Freeze。另外，提示一点，一个句柄初始化在一个loop上两次，会导致之前初始化的结点丢失，进而引发功能失效的问题。如果开发者遇到了创建了多个napi_threadsafe_function或是uv_async_t，在触发这些句柄的时候，回调并没有执行，可以往这个结论上面推断。
double close问题导致的libuv的crash
double close详解
问题描述：libuv作为一个异步I/O的事件调度框架，核心逻辑主要使用文件描述符（fd）驱动的方式进行。因此，其内部代码在调用fd相关的系统调用后，如果检测到errno不符合预期就会将程序终止。在HarmonyOS上，事件循环也延续了这一做法。但是，HarmonyOS上的libuv在终止之前，会获取更多的信息。下面是fd异常时的崩溃栈：
当前上面的崩溃栈只是libuv异常终止的其中一处，其余的栈与上述崩溃栈类似，都有LastFatalMessage信息，且第0、1帧都是musl库raise和abort，第2帧为libuv的代码。其中LastFatalMessage字段的含义是指，操作的是哪个fd，返回的errno是多少，这个fd属于哪个事件循环（一个ArkTS线程对应一个事件循环，开发者自己创建的uv_loop_t也是一个事件循环）。
问题分析：
针对上述的崩溃栈，errno为9，表示该问题为double close问题。当然如果errno不为9，如果是22，其实也是double close问题。double close的模型为：
三个模块A，B，C，接下来按照顺序执行。
经过大量的试验，double close可能造成的影响主要有三种：
排查方法：
案例一、某应用退出账号，重新启动闪退（偶现）
问题描述：应用存在double close导致偶现crash，复现场景为退出账号，点击应用，出现crash。栈顶与文章第一幅图的崩溃栈一致，都集中在worker线程或者与taskpool相关的线程（TaskManager线程，TaskWorker线程）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.19149061888805996090259882294023:50001231000000:2800:1628CC5A58B580FC300741B0B22A20453D6CCFF4F33C541C809DBEBED7986BA7.png)
问题分析：
排查应用方代码，代码如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.35059185429932877627375923214361:50001231000000:2800:6888D7169141E9B4E21613AD60B11BD989798679FA2F3615ED7576914D2E14EB.png)
其中rawFileDescriptor是资源管理子系统通过rawFilePath获取的文件描述符的管理对象。
注释的地方为第一次close，使用文件管理子系统的close接口。第二次close是通过rawFilePath文件路径，传入到资源管理子系统的closeRawFd接口中进行关闭操作。这两次close正好对应了用插件抓出来的两次调用栈。
解决方法：
按照上图中的代码注释，将多余的close操作进行删除即可。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-api
爬取时间: 2025-05-01 09:11:20
来源: Huawei Developer
视效API
静态图片，建议使用 EffectKit 异步模糊；AdaptiveColor 使用问题
【问题描述】
内外部多个应用在使用取色模糊时 AdaptiveColor 参数选择了 AVERAGE 方式，导致出现帧率不达标问题。此参数已经标注在非 DEFAULT 方式下会产生耗时。典型 trace 如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.62595028900358978096586186464367:50001231000000:2800:3045C5A0F2A4AF2A3E55B714DE5291FC757EDD32194164AE1CB296DA3AB4B16C.png)
【使用错误影响】
应用单帧耗时长，影响应用刷新帧率，导致动画卡顿等现象。
【使用建议】
使用 AdaptiveColor.DEFAULT 方式取色，或者参考EffectKit 的 ColorPicker方式进行异步取色。
【文档链接】
AdaptiveColor.DEFAULT：不使用取色模糊。使用默认的颜色作为蒙版颜色。采用非DEFAULT方式较耗时。
EffectKit 的 ColorPicker：取色类，用于从一张图像数据中获取它的主要颜色。
媒体平台API
播控
1、回调泄漏问题
【问题描述】
应用在使用.on('xxx')注册回调后，使用匿名函数传入.off('xxx')去除回调。匿名函数传入的回调会被认为是新的回调函数，使得无法移除之前注册的回调，回调会越来越多。监听注册使用的回调callback需要保证合理释放，避免使用匿名函数无法管控生命周期。
【使用错误影响】
应用卡死
【使用建议】
如需删除对应回调，请定义回调方法后再传参
【文档链接】
媒体会话管理on('playbackStateChange')
媒体会话管理off('playbackStateChange')
【典型案例】
【最佳实践】
2、打印日志过多问题
【问题描述】
日志打印过多，超过60M日志
【使用建议】
尽可能减少频繁调用setAVPlaybackState、SetAVMetadata的场景
【文档链接】
媒体会话管理setAVPlaybackState
媒体会话管理setAVMetadata
3、投播时正确进行资源播放
【问题描述】
使用AVCastController进行资源播放，非同步调用接口，需要在callback回调里面去start
【使用错误影响】
无法投播播放
【使用建议】
使用AVCastController进行资源播放，非同步调用接口，需要在callback回调里面去start
【文档链接】
投播组件开发指导
【典型案例】
【最佳实践】
4、正确设置播放状态和进度
【问题描述】
应用播放、暂停时需要设置播放状态或暂停状态，及当前播放或暂停时的进度。
【使用错误影响】
播放状态显示异常，进度回弹、进度显示错误等
【使用建议】
在应用播放状态、播放进度、倍速发生变化时，使用setAVPlaybackState接口更新AVPlaybackState。
【文档链接】
基础播控
【典型案例】
【最佳实践】
相机
1、回调on('xxx')接口中，禁止添加（调用on）或者移除（调用off）回调操作
【问题描述】
框架侧的回调实现是进行了加锁操作的。在框架侧触发回调给应用的时候，应用如果在此时移除回调或者添加回调，会导致应用死锁线程卡死。
【使用错误影响】
应用卡死
【使用建议】
如果需要对回调做其他增减操作，需要在另外的线程中执行或者在其他业务流程中进行。
【文档链接】
相机管理on('error')
相机管理on('cameraStatus')
文档中所有的on接口，不仅仅只是上面两个示例。
【典型案例】
当 cameraStatus 回调触发后，代码跑到off处发生卡死。
2、CameraSession中，addInput接口的入参必须是一个已经调用了open的CameraInput。
【问题描述】
CameraInput open之后，会获得对应设备的一些信息，如果这些信息没拿到，该CameraInput添加到Session中会发生错误抛出异常。
【使用错误影响】
应用调用接口发生错误
【使用建议】
CameraInput open成功之后再往CameraSession中添加。
【文档链接】
相机管理CameraInput
相机管理Session
【典型案例】
代码跑到addInput处发生异常抛出。
【最佳实践】
3、CameraSession中，addOutput前需要先addInput。
【问题描述】
如果Session中没有Input信息，则addOutput会发生错误抛出异常。
【使用错误影响】
应用调用接口发生错误
【使用建议】
Session添加Input之后再添加Output
【文档链接】
相机管理CameraInput
Output包括 PreviewOutput、PhotoOutput、VideoOutput、MetadataOutput。
相机管理CameraOutput
相机管理Session
【典型案例】
代码跑到addOutput处发生异常抛出。
【最佳实践】
4、Session增减Input和Output的接口调用流程必须在beginConfig和commitConfig接口调用之间。
【问题描述】
如果Session中没有调用beginConfig，则addInput和addOutput会发生错误抛出异常。如果Session没有调用commitConfig，则无法继续调用后续的start接口。
【使用错误影响】
应用调用接口发生错误
【使用建议】
Session调用beginConfig接口之后再添加Input和Output，最后记得调用commitConfig。
【文档链接】
相机管理CameraInput
Output包括 PreviewOutput、PhotoOutput、VideoOutput、MetadataOutput。
相机管理CameraOutput
相机管理Session
相机管理beginConfig
相机管理commitConfig
【典型案例】
代码跑到addInput处发生异常抛出。
【最佳实践】
5、Session的release，Input的close等返回Promise的操作如果在异步函数内调用，请确保调用了await保证时序正常。
【问题描述】
开发者把异步函数当作同步函数调用，将导致不可预料的时序问题。
【使用错误影响】
应用异常。
【使用建议】
在异步函数中调用返回Promise的异步函数，加await保证时序正常。
【文档链接】
相机管理release
相机管理close
【典型案例】
【最佳实践】
音频
1、多次调用裸指针的Release触发UAF(use after free)。
【问题描述】
应用在使用OHAudioRenderer/OHAudioCapturer等OHAudio相关接口时，需要把相关对象的裸指针传递给音频。当应用调用了对象的release方法时，框架侧会把对象delete掉，此时应用如果再次传递裸指针调用方法，音频接收到指针后，只能对指针进行判空，不能对指针的有效性进行判断，出现UAF问题。
【使用错误影响】
出现地址越界相关的Crash问题，造成客户端进程闪退。
【使用建议】
在使用OHAudio的过程中，如果调用了Release方法，不要再传递失效的野指针。
【文档链接】
使用OHAudio开发音频录制功能(C/C++)
使用OHAudio开发音频播放功能(C/C++)
2、使用OHAudio的应用只注册部分回调，野指针crash
【问题描述】
根据C语言的特性，结构体里面的指针都是随机数据，必须要把所有的指针初始化了才能使用（可以使用正常值或nullptr来初始化）；音频提供了OH_AudioRenderer_Callbacks_Struct，OH_AudioCapturer_Callbacks_Struct相关的结构体，结构体中是指针类型的方法。当应用把Struct注册给音频时，如果没有初始化Struct的所有元素（只初始化了部分），音频再给应用发送回调的时候，因为无法判断指针是否合法，会出现异常。
【使用错误影响】
在框架回调应用的时候，如果需要回调的方法是用户未赋值的方法，会造成客户端进程闪退。
【使用建议】
为了避免不可预期的行为，在设置音频回调函数时，请确认OH_AudioRenderer_Callbacks、OH_AudioCapturer_Callbacks的每一个回调都被自定义的回调方法或空指针初始化。
【文档链接】
使用OHAudio开发音频录制功能(C/C++)
使用OHAudio开发音频播放功能(C/C++)
3、OnWriteData回调排查
【问题描述】
开发者使用OHAudio的接口时，使用了 OH_AudioStreamBuilder_SetRendererCallback 设置了 OH_AudioRenderer_OnWriteData 写数据的回调函数，但是由于网络或者解码性能等原因，应用无法在系统索要音频数据时，将索要的数据块填充完，而是只写入了部分数据。例如，在系统向应用索要10ms数据，应用只提供了6ms数据，然后在系统拿到了这段数据块后，仍按照10ms数据播放，对于应用未写入的4ms数据，实际是不可控的，表现出播放卡顿，杂音。
【使用错误影响】
播放卡顿，杂音。
【使用建议】
【注意事项】
【文档链接】
使用OHAudio开发音频播放功能(C/C++)
4、防止offload流卡顿自排查
【问题描述】
offload功能说明
【使用建议】
典型案例（应用自查）
Q1. 【息屏异常停流】APP在CPU休眠时，感知自己解码阻塞或认为系统很长时间没请求数据，进行停流操作。
A1. 使用offload的通路的应用，需要申请长时任务；应用需要感知休眠时正常情况，无需停流；
Q2. 【息屏异常停流】APP在CPU唤醒后的一段时间内，由于各种原因，没有及时提供至少一帧数据。
A2. APP需进行解码等操作的性能优化，保证CPU唤醒时能及时提供数据；
Q3. 【息屏卡顿杂音】APP在数据不足一帧时写入，导致卡顿杂音
A3：
Q4. 【没播完切歌】APP在一段数据写完后，切歌进入下一首，此时数据并没有播放完毕；
A4. 通过框架接口OH_AudioRenderer_GetTimeStamp()获取框架侧播放的数据数量，来判断播放进度；注意控制调用频率不要过高(建议200ms左右一次)，否则会影响系统性能。注意当OH_AudioRenderer_Flush()后，播放的数据数量会重置0。
PS: 针对案例3&4 应用可以添加维测：统计自己实际写入的数据数量p1，通过框架接口OH_AudioRenderer_GetTimeStamp()获取框架侧播放的数据数量p2。符合预期的场景：
不符合预期的场景：
视频
AVImageGenerator或AVMetadataExtractor功能失效问题
【问题描述】
设置同一个FD给AVImageGenerator和AVMetadataExtractor实例，导致AVImageGenerator或者AVMetadataExtractor功能失效。
【使用错误影响】
功能失效
【使用建议】
即使是沙箱路径下的同一个文件，也建议Open两次，获取不同的Fd传递给AVImageGenerator和AVMetadataExtractor对象，否则这两个对象对同一个Fd做操作，会导致从Fd中读取的数据异常，导致功能失效。
【文档链接】
AVImageGenerator
将资源句柄（fd）传递给 AVImageGenerator 实例之后，请不要通过该资源句柄做其他读写操作，包括但不限于将同一个资源句柄传递给多个 AVPlayer / AVMetadataExtractor / AVImageGenerator / AVTranscoder。同一时间通过同一个资源句柄读写文件时存在竞争关系，将导致视频缩略图数据获取异常。
【最佳实践】
```typescript
async fetchFrame() {
await this.fetchMeta()
if (canIUse("SystemCapability.Multimedia.Media.AVImageGenerator")) {
this.pixelMap = new Array
let avImageGenerator: media.AVImageGenerator = await media.createAVImageGenerator()
// raw fd
avImageGenerator.fdSrc = fs.openSync(this.rootPath + this.testFilename)
for (let i = 0; i < 6; i++) {
console.info(`time real ${this.diffTime[i]}`)
let pixelMap = await avImageGenerator.fetchFrameByTime(this.diffTime[i], this.seekOption, {width: this.pixelMapWidth, height: this.pixelMapHeight, colorFormat: this.colorFormat})
this.pixelMap.push(pixelMap)
if (i == 0) {
this.pixelLcd = pixelMap
let rate = pixelMap.getImageInfoSync().size.height / pixelMap.getImageInfoSync().size.width
this.lcdHeight = display.getDefaultDisplaySync().width / 2 / display.getDefaultDisplaySync().densityPixels * rate
}
let imageInfo: image.ImageInfo = pixelMap.getImageInfoSync()
console.info(`colorFormat ${imageInfo.pixelFormat} width ${imageInfo.size.width} height ${imageInfo.size.height} isHdr ${imageInfo.isHdr}`)
}
}
}
async fetchMeta() {
if (canIUse("SystemCapability.Multimedia.Media.AVMetadataExtractor")) {
console.info(`typeof ${typeof media.createAVMetadataExtractor()}`)
let avMetadataExtractor: media.AVMetadataExtractor = await media.createAVMetadataExtractor()
let context = getContext(this) as common.UIAbilityContext
// 通过UIAbilityContext获取沙箱地址filesDir（以Stage模型为例）
let fd: number = fs.openSync(this.rootPath + this.testFilename).fd;
let fileSize: number = fs.statSync(this.rootPath + this.testFilename).size;
let dataSrc: media.AVDataSrcDescriptor = {
fileSize: fileSize,
callback: (buffer, len, pos) => {
if (buffer == undefined || len == undefined || pos == undefined) {
console.error(`dataSrc callback param invalid`)
return -1
}
let options: ReadOptions = {
offset: pos,
length: len
}
let num = fs.readSync(fd, buffer, options)
console.info('readAt end, num: ' + num)
if (num > 0 && fileSize >= pos) {
return num;
}
return -1;
}
}
avMetadataExtractor.dataSrc = dataSrc
let metadata: media.AVMetadata
try {
metadata = await avMetadataExtractor.fetchMetadata()
} catch (error) {
console.info('error code ' + error.code)
return
}
console.info(`metadata ${JSON.stringify(metadata)}`)
if (metadata.duration) {
console.info(`fetchMetadata success duration ${metadata.duration}`)
let duration = parseInt(metadata.duration) * 1000
let pick = duration / 5
this.diffTime[0] = 0
this.diffTime[5] = duration
let time = pick
for (let i = 1; i < 5; i++) {
this.diffTime[i] = time
time += pick
}
}
if (metadata.videoHeight && metadata.videoWidth) {
let rate = Number(metadata.videoHeight) / Number(metadata.videoWidth)
if (metadata.videoOrientation && Number(metadata.videoOrientation) % 180) {
rate = 1 / rate;
}
this.videoHeight = display.getDefaultDisplaySync().width / 6 / display.getDefaultDisplaySync().densityPixels * rate
}
await avMetadataExtractor.release()
}
}
```
ArkUI相关API
1、Inspector接口在业务代码里使用
【问题描述】
应用在使用Inspector相关接口进行组件信息的查询时错误的行为，该接口在设计时只是用作调试，性能较差，在业务代码调用该接口，容易引起appfreeze，导致应用闪退。
【使用错误影响】
应用闪退。
【使用建议】
不要使用Inspector做信息查询。
【文档链接】
getFilteredInspectorTree
getFilteredInspectorTreeById
组织标识
getInspectorInfo
2、OH_NativeXComponent_RegisterCallback接口传参
【问题描述】
应用在使用OH_NativeXComponent_RegisterCallback接口传的回调函数必须保证在OnSurfaceDestroyed回调之前是有效的，该回调是XComponent生命周期结束后给应用的通知，一定会调用。如果提前释放该回调会导致uaf问题。
【使用错误影响】
应用闪退
【使用建议】
【文档链接】
OH_NativeXComponent_RegisterCallback
3、@ohos.measure和@ohos.font不推荐在UIAbility的生命周期中调用
【问题描述】
应用在UIAbility的生命周期中调用@ohos.measure和@ohos.font不能达到预期效果。下面的代码是在EntryAbility.ets中的onCreate回调函数中使用@ohos.measure和@ohos.font接口
【使用错误影响】
运行上述代码，会发现编译通过，但运行时width不能打印出有效结果，且注册的font也不生效。
【使用建议】
1、本模块功能依赖UI的执行上下文，不可在UI上下文不明确的地方使用。建议使用this.getUIContext().getMeasureUtils().measureText()和this.getUIContext().getFont().registerFont()调用。
【文档链接】
@ohos.font (注册自定义字体)
@ohos.measure (文本计算)
4、CustomdialogController禁止在方法中动态赋值
【问题描述】
应用在方法中动态声明与赋值
【使用错误影响】
如果重复执行方法，会导致已打开的弹窗无法关闭。并且无异常日志显示。
【使用建议】
在@component下定义与初始化
【文档链接】
自定义弹窗 (CustomDialog)
5、CheckboxGroup在懒加载、list与web场景下需要手动控制状况变量
【问题描述】
CheckboxGroup在懒加载、list与web场景下需要手动控制状况变量。
【使用错误影响】
使用checkboxGroup依赖系统控制checkbox会造成部分checkbox不受checkboxGroup统一管理的情况。
【使用建议】
CheckboxGroup在懒加载、list与web场景下需要手动控制状况变量。
【文档链接】
CheckboxGroup
【典型案例】
6、UIExtensionComponent send&sendSync 能力有效周期注意点
【问题描述】
UIExtensionComponent用于承载跨进程ui，其中提供send&sendSync用于使用方往提供方发送信息；send&sendSync需要提供方进程起来并且建立连接之后使用才生效，在提供方断联或者出问题（可通过UIExtensionComponent onError&onRelease&onTerminated等）之后失效。
【使用错误影响】
send&sendSync 失效。
【使用建议】
监听UIExtensionProxy on('asyncReceiverRegister') & on('syncReceiverRegister') 状态，在这回调之后使用；
监听UIExtensionComponent onError&onRelease&onTerminated状态，在这之后无法使用。
【典型案例】
7、button在使用多态配置按压效果和hover效果需先关闭自身按压和hover效果
【问题描述】
button在使用多态配置按压效果和hover效果需先关闭自身按压和hover效果
【使用错误影响】
button按压或hover会闪烁或者样式异常。
【使用建议】
关闭自身按压和hover效果，stateEffect(false)与hoverEffect(false)。
【文档链接】
多态样式
Button
【典型案例】
【最佳实践】
8、Image组件接口使用不规范
【问题描述】
应用在使用image组件申请pixmap或直接使用OH_pixmap接口时，如果不设置编解码size，单张图片可能申请大几百MB，甚至超过1GB内存，多张图片申请后，可能受系统限制，导致应用闪退。
【使用错误影响】
应用闪退
【使用建议】
使用Image组件时，建议通过autoSize或sourceSize降低编解码分辨率
9、GetRectangleById接口可能存在组件不存在场景
【问题描述】
该接口使用的inspector的内部接口。可能存在指定Id的组件不存在的场景，此时没有异常返回值，入参ComponentInfo会使用全0的默认值。
【使用错误影响】
应用错误使用位置信息，导致异常。
【使用建议】
判断是否入参ComponentInfo为全0的默认值。
【文档链接】
getRectangleById
【典型案例】
桌面返回时查找位置异常，导致返回动效，返回桌面异常
【最佳实践】
10、getInspectorByKey接口可能存在组件不存在场景，返回的是空字符串而不是空json对象
【问题描述】
getInspectorByKey接口可能存在组件不存在场景，返回的是空字符串而不是空json对象
【使用错误影响】
应用错误使用json判断空字符串，导致应用异常常。
【使用建议】
对该接口应进行空字符串判断。
【文档链接】
getInspectorByKey
11、不推荐在aboutToAppear、aboutToDisappear中调用动画
【问题描述】
【使用建议】
不要在aboutToAppear、aboutToDisappear生命周期回调中调用以下动画接口（animateTo、animateToImmediately、keyframeAnimateTo）
【文档链接】
显式动画 (animateTo)
【典型案例】
12、使用if/else来做数据保护时，不建议在动画闭包里操作数据，否则会crash
【问题描述】
在动画当中改变if/else分支，而这个if/else是用来做数据保护的，继续使用该分支会导致访问数据异常，然后造成crash。
【使用错误影响】
应用会产生jscrash
【使用建议】
详见“最佳实践”示例代码
【文档链接】
动效场景下if分支切换保护失效
【典型案例】
【最佳实践】
方式1：给数据继续加判空的保护，即在使用data时再加一层判空，即"Text(this.data1?.str)"。
```typescript
class MyData {
str: string;
constructor(str: string) {
this.str = str;
}
}
@Entry
@Component
struct Index {
@State data1: MyData|undefined = new MyData("branch 0");
@State data2: MyData|undefined = new MyData("branch 1");
build() {
Column() {
if (this.data1) {
// 如果在动画中增加/删除，会给Text增加默认转场
// 对于删除时，增加默认透明度转场后，会延长组件的生命周期，Text组件没有真正删除，而是等转场动画做完后才删除
// 在使用数据时再加一层判空保护，如果data1存在才去使用data1当中的str
Text(this.data1?.str)
.id("1")
} else if (this.data2) {
// 如果在动画中增加/删除，会给Text增加默认转场
// 在使用数据时再加一层判空保护
Text(this.data2?.str)
.id("2")
}
Button("play with animation")
.onClick(() => {
animateTo({}, ()=>{
// 在animateTo中修改if条件，在动画当中，会给if下的第一层组件默认转场
if (this.data1) {
this.data1 = undefined;
this.data2 = new MyData("branch 1");
} else {
this.data1 = new MyData("branch 0");
this.data2 = undefined;
}
})
})
}.width("100%")
.padding(10)
}
}
```
方式2：给if/else下直接要被删除的组件显示的添加transition(TransitionEffect.IDENTITY)属性，避免系统添加默认转场。
```typescript
class MyData {
str: string;
constructor(str: string) {
this.str = str;
}
}
@Entry
@Component
struct Index {
@State data1: MyData|undefined = new MyData("branch 0");
@State data2: MyData|undefined = new MyData("branch 1");
build() {
Column() {
if (this.data1) {
// 在IfElse的根组件显示指定空的转场效果，避免默认转场动画
Text(this.data1.str)
.transition(TransitionEffect.IDENTITY)
.id("1")
} else if (this.data2) {
// 在IfElse的根组件显示指定空的转场效果，避免默认转场动画
Text(this.data2.str)
.transition(TransitionEffect.IDENTITY)
.id("2")
}
Button("play with animation")
.onClick(() => {
animateTo({}, ()=>{
// 在animateTo中修改if条件，在动画当中，会给if下的第一层组件默认转场
// 但由于已经显示指定转场了就不会再添加默认转场
if (this.data1) {
this.data1 = undefined;
this.data2 = new MyData("branch 1");
} else {
this.data1 = new MyData("branch 0");
this.data2 = undefined;
}
})
})
}.width("100%")
.padding(10)
}
}
```
13、滚动类组件当scroller控制器未绑定容器组件或者容器组件被异常释放时，currentOffset的返回值为空
【问题描述】
当scroller控制器未绑定容器组件或者容器组件被异常释放时，currentOffset的返回值为空
【使用错误影响】
currentOffset的返回值为空，导致应用异常。
【使用建议】
使用该接口应进行判空，this.scroller.currentOffset()?.yOffset。
【文档链接】
currentOffset
IPC相关API
1、使用IPC&RPC通信时，调用writeString使用不规范
【问题描述】
业务在使用writeString时有些特殊字符无法通过ipc进行传输，报检查参数错误check param error。
【使用错误影响】
调用IPC接口失败。
【使用建议】
【文档链接】
writeString
2、使用IPC&RPC通信时，MessageSequence使用不规范
【问题描述】
业务像MessageSequence类里大量写数据，导致调用具体的write方法时调用失败，具体错误日志为：No enough capacity to write
【使用错误影响】
调用IPC接口失败
【使用建议】
1、使用MessageSequence对象传递数据，写的总数据量不超过200KB;
2、遇到大数据量传输的话，同设备调用可以使用writeRawDataBuffer和writeAshmem，跨设备调用使用writeRawDataBuffer
【文档链接】
MessageSequence
3、rpc.MessageParcel 或rpc.MessageSequence 使用不规范
【问题描述】
业务TS应用客户端使用 rpc.MessageParcel.create() 或rpc.MessageSequence.create() 创建的 data 和 reply 没有调用其reclaim接口，导致资源得不到释放。
【使用错误影响】
内存泄露、FD泄露、binder内存不足通信失败。
【使用建议】
客户端发消息结束后需调用data 和 reply 的 reclaim接口。
【文档链接】
MessageSequence
【最佳实践】
达到parcel的上限200KB后，使用RawData传输大数据量
4、使用共享内存Ashmem类时，读写数据失败
【问题描述】
创建Ashmem对象后，写数据正常读数据失败
【使用错误影响】
无法接受对端传递的数据
调用IPC接口失败
【使用建议】
1、在使用Ashmem去写数据时，先调用mapReadWriteAshmem方法，创建可读写的共享文件的映射，之后在调用writeDataToAshmem方法写对应的数据
2、从Ashmem中去读取数据时，需要先调用mapReadWriteAshmem方法，创建可读写的共享文件的映射，之后调用readDataFromAshmem方法读对应的数据
【文档链接】
Ashmem
mapReadWriteAshmem
writeDataToAshmem
readDataFromAshmem
5、使用Ashmem对像传递数据，Ashmem的内存未释放
【问题描述】
业务使用了Ashmem去存储数据，读取完之后调用了closeAshmem方法，想释放之前开辟的共享内存，但是好像没有生效
【使用错误影响】
内存无法释放
【使用建议】
释放之前开辟的共享内存，第一步先调用unmapAshmem方法，删除前面创建出来的Ashmem对象的地址映射，第二步才是调用closeAshmem方法，关闭这个Ashmem对象
【文档链接】
Ashmem
writeDataToAshmem
readDataFromAshmem
MessageSequence类中的读写方法：
writeAshmem
readAshmem
6、调用新接口传递ArrayBuffer数据时，读取数据对应不上
【问题描述】
上层业务使用writeArrayBuffer和readArrayBuffer方法传递ArrayBuffer数据传递ArrayBuffer数据时，读取数据对应不上
【使用错误影响】
写入的数据和读取的数据有差异
【使用建议】
1、读写的第一个参数一定是ArrayBuffer类型，不能传具体的TypedArray，例如：Int16Array
2、读写第二个参数是具体的typedArray类型枚举值，读和写的TypeCode值需要是对应的
【文档链接】
writeArrayBuffer
readArrayBuffer
【典型案例】
具体创建的typedArray跟写时传递的类型枚举值TypeCode不匹配，报错read data from message sequence failed
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.37534539949261260954205991854882:50001231000000:2800:93F26E697622FA345BFD178B815C037CA94EEC252AC82CFEBF069B574AE73AA6.png)
字节不匹配，写入失败
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.28936806918379492470094043764400:50001231000000:2800:96CCF136CA9EB50A94A5F555042530D097C155FA310E2C435EE547C125F5AE48.png)
7、onRemoteRequest函数报错，返回错误码4
【问题描述】
客户端发送信息给服务端，服务端在处理的时候报错 打印错误日志OnJsRemoteRequest failed, ret:4 time:xxxxx
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.59656797782212334962740633617549:50001231000000:2800:681120C166EB8093923239A80635975D8D627F081C3CC8F90620FB34E60D0D1B.png)
【使用错误影响】
服务端在处理接受的消息后，客户端无法拿到其回传的信息
【使用建议】
1、业务在onRemoteRequeston或RemoteMessageRequest函数中，合理返回true或者false
2、当上层业务返回false时，IPC内部会认为此次通信是失败的，会直接赋值为4，结束此次通信
8、使用IPC进行通信时，业务data和reply释放时机不对
【问题描述】
使用IPC进行通信时，业务data和reply释放时机不对，业务在调用readInt方法时调用失败
【使用错误影响】
方法调用失败，无法拿到业务回传的信息
【使用建议】
合理使用reclaim，确保业务不会在用创建的data和reply对象时，在调用reclaim方法
【文档链接】
reclaim
【最佳实践】
sendMessageRequest(code: number, data: MessageSequence, reply: MessageSequence, options: MessageOption): Promise<RequestResult>
使用上面的方法时，在promise的.finally回调中释放已经不用的对象，确保promise的.then或者.catch回调中的逻辑一定先于释放对象这个操作
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.98174792122115494724118219866172:50001231000000:2800:1578F7AE1B1BF4B44D98ECD6B8174C06AE61CEA42D241FB73965B1BE2BC0E277.png)
sendMessageRequest(code: number, data: MessageSequence, reply: MessageSequence, options: MessageOption, callback: AsyncCallback<RequestResult>): void
使用上面这个方法时，一定是AsyncCallback回调中拿到业务数据后在进行释放
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.73111721761889466100904651774830:50001231000000:2800:9E287D47D4E3C59A1B77214F7E027EBFA6576EE63769727305B99C03316BE51C.png)
图形API
1、OH_NativeWindow_DestroyNativeWindow()使用问题
【问题描述】
由于对于OH_NativeImage_AcquireNativeWindow()  OH_NativeWindow_DestroyNativeWindow()等接口理解不到位导致重复释放。
【使用错误影响】
地址越界问题
【使用建议】
调用OH_NativeImage_Destroy时不需要调用OH_NativeWindow_DestroyNativeWindow()释放。
【文档链接】
OH_NativeImage
2、OH_NativeWindow相关接口野指针crash问题
【问题描述】
通过native层接口调用的crash问题
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.10837035763097534380202351969274:50001231000000:2800:6878D37A4F96D699D72CCF7903BE06B92F54CFBDFDAD063AD0D527A712584635.png)
【使用错误影响】
【使用建议】
【文档链接】
NativeWindow
3、OH_NativeWindow相关接口空指针crash问题
【问题描述】
crash的栈顶在libsurface.z.so中
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.25842745635976758886623140285618:50001231000000:2800:899FC1474AB721357D3FD3E6ECB12691A6E79D4BEA11DACC0EE3004E539DD6C1.png)
【使用错误影响】
1、挂在GetBufferHandleFromNative接口中的访问sfbuffer，此时sfbuffer为空指针，原因是因为另外一个线程并发将sfbuffer置空，导致crash；
2、另外一个线程触发了nativewindow的析构流程，在析构流程中会将buffer进行unreference，随后会触发buffer的析构，最后将sfbuffer置空。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.35044700742117628047220590368986:50001231000000:2800:F456B0D12387C67919B3ED3E7A8DAB53E996A310AFC19437D1ADF0B825A62CB0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151224.23949002699900643214885941930228:50001231000000:2800:DDC67481DCF9287C6AF0C7403332182A46E39AE05F717F884F643611514450C7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.80205407236444045648764284575873:50001231000000:2800:22679AB3BE87BA801DBFFC5E0098E34D23CAC2FD490E7AF5493BACE5D8AC5131.png)
【使用建议】
通过调用栈往下找，找到真正使用nativewindow的so，例如上面的调用栈就找libweb_engine.so
【文档链接】
NativeWindow
方舟运行时API
1、【use after free】napi_async_work使用不规范
【问题描述】
napi_async_work使用不规范，对相关接口理解不深导致的UAF问题，涉及接口主要包括napi_create_async_work、napi_queue_async_work\napi_queue_async_work_with_qos、napi_delete_async_work
【使用错误影响】
crash在系统栈，问题溯源困难。
【使用建议】
将napi_delete_async_work的工作放在napi_create_async_work中的第五个参数中的回调函数里面做。可以保证在异步任务执行期间上层开发者的内存问题不会报在系统栈导致问题无法定位。
【典型案例】
打开某应用闪退
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.96437604087335300786075438659969:50001231000000:2800:4D1F65D4A7EF84AE35BBB832B4FE112A492112E7E1D8861890C8DAD8418F2FED.png)
此栈多为native开发者使用napi_async_work变量，对其生命周期管理不当导致UAF问题，难点在于都是系统栈无法追踪到具体调用方。但是该问题是必现的，因此用memtracker压测出崩溃栈如下
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.99303535019528356209067116917142:50001231000000:2800:033F3F425E5B937C850E82DD634F09237595A1E99E3B4E7675F9A533A8B3C6CA.png)
根据上面崩溃栈，发现是liblargelanguagemodel.z.so申请和释放的内存，看一下他们的代码
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.57759099557353180485914265963435:50001231000000:2800:B7F446571118B29AAC1513FEB7A39BAC5FB21698180AF48EC8180D91EF5CA2D2.png)
开发者使用了智能指针管理AsyncWorkData这块内存，在将任务插入到异步任务队列后就reset走到了析构函数里调用napi_delete_async_work。导致异步任务整个流程还没走完，内存就被释放，产生了UAF问题
将napi_delete_async_work的工作放在napi_create_async_work中的第五个参数中的回调函数里面做。可以保证在异步任务执行期间上层开发者的内存问题不会报在系统栈导致问题无法定位。
2、【double free】开发者手动释放ArrayBuffer内存导致double free
【问题描述】
开发者通过napi_get_arraybuffer_info接口获取ArrayBuffer的data指针，然后直接手动free这个内存导致应用崩溃，ArrayBuffer的内存由虚拟机GC统一管理，禁止开发者手动释放。
napi_create_arraybuffer/napi_create_sendable_arraybuffer/napi_get_arraybuffer_info/napi_create_buffer/napi_get_buffer_info/napi_get_typedarray_info/napi_get_dataview_info等接口同理
【使用错误影响】
应用闪退
【使用建议】
禁止开发者手动释放ArrayBuffer内存
【文档链接】
防止重复释放获取的buffer
【典型案例】
某应用安装起来后，搁置一段时间，会被强制杀死进程退出，崩溃栈如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.82236950911231763045819096391345:50001231000000:2800:38BBA71366D75A9132F002FCB877DAD662302FE954DD646411F815ADC2D4C097.png)
【案例分析】
安装MemTracker地址越界检测工具后，发现问题发生的根因是开发者自己释放了通过虚拟机创建的ArrayBuffer的内存，然后虚拟机GC后再次去释放导致的double free。对于ArrayBuffer内存，无需开发者手动释放，而是统一交给虚拟机来管理，如果开发者尝试手动去释放这块内存，则可能导致double free问题。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.64765895276240892106175830949187:50001231000000:2800:18A848E9778BB73D779CE534C66912E98D8C48CB2AFE15D24E22879B30E0E39F.png)
【最佳实践】
不允许开发者主动释放虚拟机所管理的arraybuffer指针。
3、【memory leak】开发者使用uv_queue_work方法将任务抛到js线程上面执行的时候，对js线程的回调方法未加handle scope
【问题描述】
开发者使用uv_queue_work方法将任务抛到js线程上面执行的时候，在js回调里面创建了js对象，但是未使用api_handle_scope来管理回调方法创建的napi_value的生命周期，导致内存泄漏。
【使用错误影响】
内存泄漏
【使用建议】
当使用uv_queue_work方法将任务抛到js线程上面执行的时候，对js线程的回调方法，一般情况下需要加上napi_handle_scope来管理回调方法创建的napi_value的生命周期。
【文档链接】
异步任务
【最佳实践】
4、【multi-thread】开发者使用napi接口时，跨线程使用napi_env或napi_value引发多线程安全问题
【问题描述】
绝大多数的napi接口，在调用时，存在线程安全的要求，即：
1. napi接口只能在js线程上使用。
2. 使用napi接口的线程，需要与napi_env所对应的js线程保持一致。
3. 使用napi接口的线程，需要与创建资源类型（napi_value/napi_ref等）的js线程保持一致。
若开发者有以下任一一种使用方式，则存在多线程安全问题：
1. 开发者在非js线程使用napi接口。
2. 开发者在js线程使用napi接口，但不在napi_env所对应的js线程上。
3. 开发者使用napi接口，但不在napi_value/napi_ref所创建的js线程上。
注意到以上指的是“绝大多数napi接口”，有部分napi接口是例外，并无以上约束。涉及接口有：
1. napi_call_threadsafe_function/napi_call_threadsafe_function_with_priority/napi_acquire_threadsafe_function/napi_release_threadsafe_function/napi_get_threadsafe_function_context/napi_ref_threadsafe_function/napi_unref_threadsafe_function -- napi的线程安全函数
2. napi_get_uv_event_loop -- 获取env上的loop，不涉及上述限制
3. napi_get_node_version
【使用错误影响】
应用闪退
【使用建议】
请遵循上述线程安全的要求，并且在开发过程中，打开多线程检测开关，可第一现场拦截多线程安全问题。
【典型案例】
【最佳实践】
打开多线程检测开关后，即可拦截到第一现场。
可通过命令，整机打开多线程检测开关。
也可直接在ide中勾选多线程检测选项。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.57629986307233642158133340394354:50001231000000:2800:67B0E5A5603C6D98DBD56BBD122A47C00D117E8A59184CCC0CCF14A1020E159A.png)
5、【multi-thread】跨线程使用napi_add_env_cleanup_hook导致多线程安全问题
【问题描述】
同理接口有napi_remove_env_cleanup_hook。此系列接口并非线程安全，只允许在napi_env所对应的js线程上使用，多线程使用会存在多线程安全问题导致崩溃。
【使用错误影响】
应用闪退
【使用建议】
只允许在napi_env所对应的js线程调用napi_add_env_cleanup_hook/napi_remove_env_cleanup_hook，禁止跨线程调用。
【典型案例】
【最佳实践】
开发者可在开发过程中打开多线程安全检测开关，若存在napi_add_env_cleanup_hook/napi_remove_env_cleanup_hook的multi-thread问题，在hilog中会打印出第一现场的调用栈。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.17385101253684828779762081340450:50001231000000:2800:C446D2038AA3EEFB827046DD4FCDC3603F20E0EAF3545DF877955D5D58DE241C.png)
6、开发者使用napi_add_env_cleanup_hook时，键值重复导致注册失败
【问题描述】
同理接口有napi_remove_env_cleanup_hook。开发者使用napi_add_env_cleanup_hook向env上注册回调时，该接口第三个入参args是作为map的key值，当开发者重复注册同一个args的回调时，后续注册动作将会失败，仅第一次注册才会成功。注册失败可能会引起后续业务上的功能/崩溃问题。
【使用错误影响】
功能问题/应用闪退。
【使用建议】
避免对同一个args值注册不同的回调，需要在一次回调内把所需动作都做完。
【典型案例】
使用env作为参数调用AddCleanHook注册有可能会失败。如果失败了,就调不到回调去清理map里的reference,这个env的指针后面可能会复用,就导致拿到了一个已经被释放的napi_ref。
修改方案：使用唯一的key
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.01740440321757460434977730242203:50001231000000:2800:EBEB65103AA00FA99C64D7BC4317160DECD564D4F559B527B3C7D83166C7F01B.png)
【最佳实践】
打开多线程检测开关后，hilog中将打印出注册失败的backtrace
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.90232809854602928036448555658633:50001231000000:2800:536DBADB6FB050946C2D740C0C10DC5D9945AB3144D98F1FDB17506C06A1EA98.png)
7、【use after free】合理运用napi_handle_scope，避免超napi_value生命周期导致崩溃
【问题描述】
napi_value受scope管控，出scope后napi_value将失效，出scope后再使用napi_value会产生未定义行为。
【使用错误影响】
应用闪退/应用行为异常
【使用建议】
可选方案（任选其一）：
1. 使用napi_escapable_handle_scope，将napi_value逃逸出当前scope，交由上层scope管理
2. 使用napi_ref创建强应用，主动管理js对象生命周期，但注意需要开发者主动调用napi_delete_reference以释放强引用。
【典型案例】
案例一：napi_value超开发者自己声明的scope范围
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.66763206586906407952274971069753:50001231000000:2800:FA38F72DDCE68CBA4A597A1599A1FFED66433573498C9B7CC2087F61548F516D.png)
创建时是个obj，但是出scope后再使用，变成了string，行为异常。
案例二：napi_value超napi框架的scope范围
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.58188512287388259092359446789331:50001231000000:2800:FED66B9C599D9ABDDCAF36AAD8FE02B2959C80BDB824BD1B75AA197C760625B4.png)
原因分析：
跨napi的native_value未使用napi_ref保存，出napi调用框架的scope后，native_value失效。
注：NAPI框架的scope即napi_handle_scope，napi开发者可以通过napi_handle_scope来管理napi_value的生命周期。框架层的scope嵌入在js call native的端到端流程中，即：进入开发者自己写的native方法前open scope，native方法结束后close scope。
【最佳实践】
1. 针对案例1，使用napi_escapable_handle_scope，并在close之前提前escape。
以上代码，结果符合预期
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.77120976382976745972388746489946:50001231000000:2800:9C1BE20039F3B0617BFE6C0E659E75FA3B58A73E1CD4D59527A799C5C45AAAF4.png)
2. 针对案例2，使用napi_ref保存强引用。
8、【use after free】开发者保存env指针，env释放后开发者继续使用，产生UAF导致崩溃
【问题描述】
开发者提前保存napi_env指针，当js线程退出后，napi_env所指向的地址被释放，但开发者并未感知，后续再使用旧的napi_env调用napi接口时，发生崩溃。
【使用错误影响】
应用闪退
【使用建议】
【典型案例】
根据日志打印env地址定位，发现是env被释放后仍然被使用
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.54729297660312248482539047308456:50001231000000:2800:508177D8245CE5D2FEAA403CD0F0B843594B2474DE24120CE434D4635523A8E6.png)
9、【use after free】开发者使用napi_get_reference_value时，napi_ref已被释放，导致UAF问题
【问题描述】
开发者使用napi_get_reference_value时，napi_ref已被释放，导致UAF问题
【使用错误影响】
应用闪退
【使用建议】
若创建的napi_ref为强应用，则开发者需要主动管理napi_ref的生命周期，避免在napi_delete_reference之后还在使用的情况
【典型案例】
napi_ref被释放后使用
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151225.58600990385557200739410534503142:50001231000000:2800:18A5829436529223DF296D2AA0B775BD199936903F917BBAADE2587EB5CC6886.png)
10、【buffer overflow】napi_get_value_string_utf8时，buffer长度不足导致越界问题
【问题描述】
同理接口有napi_get_cb_info/napi_get_string_value_xxx，此类接口有个共同特点：需要开发者传入buffer与对应的buffer长度。若开发者传入的buffer size超过实际的buffer size时，就会发生越界问题。
【使用错误影响】
应用闪退
【使用建议】
1. 开发者需保证buffer容量充足，不会越界
2. 对于napi_get_value_string_xxx系列接口，buffer长度可传入NAPI_AUTO_LENGTH，接口内部会自动计算buffer长度。
【典型案例】
argc长度超过argv实际长度，导致越界
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151226.87319743409881621594650189613905:50001231000000:2800:F4F055019D24230514EC461A904230725DE245C1603C65795FC47A894FF55D79.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-ide-static-detection
爬取时间: 2025-05-01 09:11:34
来源: Huawei Developer
使用Clang-Tidy检测
自定义配置
DevEco Studio集成了开源的Clang-Tidy。
1. 开发者可以在Setting -> Editor -> Inspections 页面，选择 CPP -> clang-tidy 的配置页进行 Clang-Tidy Checks 配置，如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151226.04313480153825576422793020862175:50001231000000:2800:29D5991B2BAFC77BDEDED2719181EEC8C6E700B5B73EF68705CBE85711F385E6.png)
2. 开发者可以在Setting -> Languages & Frameworks -> C/C++ 中进行 Clang-Tidy Checks 配置，勾选 “Use clang-tidy via clangd to enable the following checks”，然后配置规则，如下图所示
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151226.10838270124559970989582669650496:50001231000000:2800:5A0894C2CF641D9C878318B03FD8CCB6FE6EF21B10F223CF7F6397CB4E190189.png)
配置参考文档：
https://clang.llvm.org/extra/clang-tidy/#using-clang-tidy
DevEco Studio默认检查规则
1. 需触发按钮 Code -> Inspect Code -> Analyze
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151226.42047816038412169261084754448435:50001231000000:2800:BA0AEB3AAC57B314CA0933E17F2D3BA91CAE74476752F48D24500669FBBE7513.png)
2. 实时触发的规则如下
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151226.18739358724931549738791230911627:50001231000000:2800:CD8CF40FE8322765153292726505CF6089696512B927D531E13BB2F9D1CEB4C9.png)
DevEco Studio默认检查规则检查示例
1. Inspect Code 手动检查，示例中不符合检查规则“clang-analyzer-huawei-InfiniteLoopChecker”
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151226.16666508954830939836615398099460:50001231000000:2800:76E3AC6FDFF9A1C81B103E9F4238818D0DCCA255DC4499D334C0834002C4A706.png)
2. 实时检查，示例中不符合检查规则“misc-unused-local-variable”
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151226.44551187933994744497111951899601:50001231000000:2800:607B9972B11A0A72E8D7A44A95DCB39CD362E4780324B1806F54114437BC419D.png)
默认配置检查内容
| 默认配置类型  | 检测问题  |
| --- | --- |
| clang-analyzer-unix.MismatchedDeallocator  | 用于检测不匹配的内存释放问题。例如，如果使用malloc分配了内存，却错误地使用了delete或free来释放  |
| clang-analyzer-huawei.InfiniteRecursiveChecker  | 用于检测可能导致无限递归的问题。无限递归可能会导致栈溢出等问题  |
| clang-analyzer-huawei.InfiniteGotoChecker  | 用于检测可能导致无限循环的goto语句。无限循环可能会导致程序卡死或资源耗尽  |
| clang-analyzer-huawei.InfiniteLoopChecker  | 用于检测可能导致无限循环的循环结构。无限循环可能会导致程序卡死或资源耗尽  |
| clang-analyzer-core.StackAddressEscape  | 用于检测栈内存地址逃逸的问题。栈内存地址逃逸可能会导致安全问题，例如缓冲区溢出攻击  |
| clang-analyzer-core.ArrayBoundV2  | 用于检测数组越界的问题。数组越界可能会导致未定义行为，包括程序崩溃或数据损坏  |
| misc-missing-switch-cases  | 确保 switch 语句覆盖所有枚举值，并且包含 default 分支  |
| misc-napi-module-name  | 用于检查 Node.js N-API 模块的命名是否符合规范。  |
| misc-replace-if-else-with-ternary-operator  | 用于建议将简单的 if-else 语句替换为三元运算符（ternary operator），以提高代码的简洁性。  |
| misc-unused-local-variable  | 用于检测并报告代码中未使用的局部变量。未使用的局部变量可能会导致代码冗余，并且可能会混淆代码的可读性。  |
| misc-unused-parameters  | 用于检测并报告函数中未使用的参数。未使用的局部变量可能会导致代码冗余，并且可能会混淆代码的可读性。  |
| modernize-use-auto  | 用于建议在适当的情况下使用 auto 关键字来简化代码。使用 auto 可以减少重复的类型声明，使代码更加简洁和易读。  |
| readability-system-capabilities  | 用于检测代码中对系统功能或库的使用是否符合最佳实践。这个规则通常会检查代码是否正确使用了系统提供的功能，以及是否有更好的替代方案。  |
默认配置类型
检测问题
clang-analyzer-unix.MismatchedDeallocator
用于检测不匹配的内存释放问题。例如，如果使用malloc分配了内存，却错误地使用了delete或free来释放
clang-analyzer-huawei.InfiniteRecursiveChecker
用于检测可能导致无限递归的问题。无限递归可能会导致栈溢出等问题
clang-analyzer-huawei.InfiniteGotoChecker
用于检测可能导致无限循环的goto语句。无限循环可能会导致程序卡死或资源耗尽
clang-analyzer-huawei.InfiniteLoopChecker
用于检测可能导致无限循环的循环结构。无限循环可能会导致程序卡死或资源耗尽
clang-analyzer-core.StackAddressEscape
用于检测栈内存地址逃逸的问题。栈内存地址逃逸可能会导致安全问题，例如缓冲区溢出攻击
clang-analyzer-core.ArrayBoundV2
用于检测数组越界的问题。数组越界可能会导致未定义行为，包括程序崩溃或数据损坏
misc-missing-switch-cases
确保 switch 语句覆盖所有枚举值，并且包含 default 分支
misc-napi-module-name
用于检查 Node.js N-API 模块的命名是否符合规范。
misc-replace-if-else-with-ternary-operator
用于建议将简单的 if-else 语句替换为三元运算符（ternary operator），以提高代码的简洁性。
misc-unused-local-variable
用于检测并报告代码中未使用的局部变量。未使用的局部变量可能会导致代码冗余，并且可能会混淆代码的可读性。
misc-unused-parameters
用于检测并报告函数中未使用的参数。未使用的局部变量可能会导致代码冗余，并且可能会混淆代码的可读性。
modernize-use-auto
用于建议在适当的情况下使用 auto 关键字来简化代码。使用 auto 可以减少重复的类型声明，使代码更加简洁和易读。
readability-system-capabilities
用于检测代码中对系统功能或库的使用是否符合最佳实践。这个规则通常会检查代码是否正确使用了系统提供的功能，以及是否有更好的替代方案。
使用CodeLinter检测
Code Linter代码检查
Code Linter针对ArkTS/TS代码进行最佳实践/编程规范方面的检查。检查规则支持配置，配置方式请参考配置代码检查规则。
开发者可根据扫描结果中告警提示手工修复代码缺陷，或者执行一键式自动修复，在代码开发阶段，确保代码质量。
检查方法：
在已打开的代码编辑器窗口单击右键点击Code Linter，或在工程管理窗口中鼠标选中单个或多个工程文件/目录，右键选择Code Linter > Full Linter执行代码全量检查。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151226.42831393629042322710379623595067:50001231000000:2800:A9C237A435B235CBFC7031C5B43B4301AD0211793CDC5F09F06124E64E98AB9A.png)
如只需对Git工程中增量文件（包含新增/修改/重命名）进行检查，可在commit界面右下角点击齿轮图标，选择Incremental Linter执行增量检查。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151226.54439538469226360824222180436590:50001231000000:2800:E55A15FC7C78629B4A03FDD87DF3EB2109C6009F7BCAAE826EC81C8649681923.png)
配置代码检查规则
在工程根目录下创建code-linter.json5配置文件，可对于代码检查的范围及对应生效的检查规则进行配置，其中files和ignore配置项共同确定了代码检查范围，ruleSet和rules配置项共同确定了生效的规则范围。具体配置项功能如下：
files：配置待检查的文件名单，如未指定目录，将检查当前被选中的文件或文件夹中所有的.ets文件。
ignore：配置无需检查的文件目录，其指定的目录或文件需使用相对路径格式，相对于code-linter.json5所在工程根目录，例如：build/**/*。
ruleSet：配置检查使用的规则集，规则集支持一次导入多条规则。规则详情请参见Code Linter代码检查规则。目前支持的规则集包括：
rules：可以基于ruleSet配置的规则集，新增额外规则项，或修改ruleSet中规则默认配置，例如：将规则集中某条规则告警级别由warn改为error。
overrides：针对工程根目录下部分特定目录或文件，可配置定制化检查的规则。
查看/处理代码检查结果
扫描完成后，在底部工具面板查看检查结果。勾选Defects中不同告警等级，可分别查看对应告警级别的信息。双击某条告警结果，可以跳转到对应代码缺陷位置；选中告警结果时，可以在右侧Defect Description窗口查看告警对应的规则详细说明，其中包含正向和反向示例，并根据其中的建议修改代码；搜索规则时，可设定是否全词匹配和大小写敏感。
单击图标，查看可修复的代码规则，点击代码修复图标，可以一键式批量修复告警，并刷新检查结果。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151226.85403539275638344112730448419440:50001231000000:2800:6F0AECD823E024C82CA8B63DC19DC15CDE3A79BD819A321773A185C385D14322.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151226.93552705988047807494484149854590:50001231000000:2800:BB57F10193F88CCF116AC36F37504047E13F8633726C6824E80CE31144B49363.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151226.51437572030304565575340415430046:50001231000000:2800:1E625F1BC43719DA81129908DFCF2882670310B2F5BE193EE162B1121FC2E142.png)
屏蔽告警信息：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151227.18145529033871431737540431379676:50001231000000:2800:490A9D86986EF76958BBEF414DCF5D626D6879864A2BC34CEF156B6DFE6877B4.png)
如需恢复忽略的报错信息，可以直接删除该行上方的注释，重新执行Code Linter检查。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151227.79577594624504817053634712546938:50001231000000:2800:4EC2D7A452D87AD880010A7D7DD0B4FD4A6598E98A8F51690C76402EFD387533.png)
导出检查结果：点击工具面板左侧导出按钮，即可导出检查结果到excel文件，包含告警所在行，告警明细，告警级别等信息。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151227.03949606149436042016471081091438:50001231000000:2800:63011726D1CC2EB7734DE48A151D9EDAC390EFF9C3BC8FCF4866D9114A67AA8D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151227.81194962543046176775420501562964:50001231000000:2800:1450BF5403BF17ECAADA8B268606BD99B1F51E103B06F1210F17255DCB86A8D4.png)
实践说明
以@typescript-eslint/no-restricted-syntax（使用某类语法时，codelinter告警）、@typescript-eslint/naming-convention（命名风格校验）和@hw-stylistic/file-naming-convention（检查代码文件的命名风格）三个规则为例，介绍codelinter配置文件的使用方法。
示例1：调用类Foo下bar方法时，Code Linter告警
在配置文件中定义规则
在ArkTS工程中，pages/Index.ets文件下增加以下用例：
在工程根目录下新建code-linter.json5文件（文件名不可修改），新增以下配置：
如需在code-linter.json5文件中配置其他字段，请参见配置代码检查规则。
执行代码检查
对pages/Index.ets文件执行代码检查，检查结果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151227.81161277740802809892150404537758:50001231000000:2800:E9E4751550E4AE60D2EC2B26A2AB7E8CF9CC95F5CCE5BE2B5131317532A4F0C2.png)
示例2：对类名Foo的命名风格校验
在配置文件中定义规则
在ArkTS工程中，pages/Index.ets文件下增加以下用例：
在工程根目录下新建code-linter.json5文件，新增以下配置：
| 字段名称  | 参数说明  | 是否必选  | 类型  | 支持配置的参数  |
| --- | --- | --- | --- | --- |
| selector  | 配置要检查的语法  | 是  | 字符串、字符串数组  | variable：变量function：函数parameter：参数parameterProperty：参数属性accessor：get/set方法enumMember：枚举成员classMethod：类方法structMethod：自定义组件中的方法objectLiteralMethod：对象方法typeMethod：接口方法classProperty：类属性structProperty：自定义组件中的属性objectLiteralProperty：对象属性typeProperty：接口属性class：类struct：自定义组件interface：接口typeAlias：类型别名enum：枚举typeParameter：泛型参数default：包含以上所有的类型variableLike：包含variable，function，parametermemberLike：包含classProperty，structProperty，objectLiteralProperty，typeProperty，parameterProperty ，enumMember，classMethod，objectLiteralMethod，typeMethod，accessortypeLike：包含class，struct，interface，typeAlias，enum，typeParametermethod：包含classMethod，structMethod，objectLiteralMethod，typeMethodproperty：包含classProperty，objectLiteralProperty，typeProperty  |
| format  | 配置期望的命名风格  | 是  | 字符串数组  | camelCase：小驼峰命名风格，比如getName，getID（支持连续大写字母），不支持下划线strictCamelCase：严格小驼峰命名风格，除了不支持连续大写字母（getID），其他的和camelCase相同PascalCase：大驼峰命名风格，比如Foo，CC，除了要求第一个字母大写，其他的和camelCase相同StrictPascalCase：大驼峰命名风格，除了不支持连续大写字母（CC），其他的和PascalCase相同snake_case：小写字母+下划线+小写字母的命名风格，比如a_a，不支持_a，a_a_UPPER_CASE：大写字母+下划线+大写字母的命名风格，比如A_A，不支持_A，A_A_  |
| custom  | 配置用户自定义的命名风格  | 否  | 对象  | regex：属性必选，配置具体的正则match：属性必选，配置为true表示正则未命中时报错，配置为false表示正则命中时报错  |
| leadingUnderscore/trailingUnderscore  | 配置是否允许以下划线开头/以下划线结尾的命名风格  | 否  | 字符串  | allow：允许以一个下划线开头/结尾的命名风格，比如_nameallowDouble：允许以两个下划线开头/结尾的命名风格，比如__nameallowSingleOrDouble：允许以一个或者两个下划线开头/结尾的命名风格（allow+allowDouble）forbid：禁止以下划线开头/结尾的命名风格，比如_name，__namerequire：必须是以下划线开头/结尾的命名风格，比如_name，__namerequireDouble：必须是以两个下划线开头/结尾的命名风格，比如__name  |
| prefix/suffix  | 配置固定前缀/后缀的命名风格。如果前缀/后缀未匹配则报错  | 否  | 字符串数组  | 用户自定义前缀/后缀  |
| filter  | 过滤特定的命名风格，检查或者不检查正则命中的命名  | 否  | 对象  | 配置格式与custom相似 match：设置为true表示只检查正则命中的名字，设置为false表示不检查正则命中的名字 regex：设置过滤的正则 说明 支持直接配置一个字符串，这个字符串配置的是regex，此时match相当于配置的是true。  |
| modifiers  | 匹配修饰符，只有包含特定修饰符的命名才会检查  | 否  | 字符串数组  | abstract：匹配abstract关键字override：匹配override关键字private：匹配private关键字protected：匹配protected关键字static：匹配static关键字async：匹配async关键字const：匹配const关键字destructured：匹配解构语法exported：匹配export关键字global：匹配全局声明#private：匹配私有符号#public：匹配public级别的访问修饰符requiresQuotes：匹配字符串类型的命名，并且 字符串中包含特殊字符unused：匹配未使用的声明  |
| types  | 匹配类型，只有特定类型的名字才会检查  | 否  | 字符串数组  | array：数组类型boolean：布尔类型function：函数类型number：数字类型string：字符串类型  |
字段名称
参数说明
是否必选
类型
支持配置的参数
selector
配置要检查的语法
是
字符串、字符串数组
format
配置期望的命名风格
是
字符串数组
custom
配置用户自定义的命名风格
否
对象
leadingUnderscore/trailingUnderscore
配置是否允许以下划线开头/以下划线结尾的命名风格
否
字符串
prefix/suffix
配置固定前缀/后缀的命名风格。如果前缀/后缀未匹配则报错
否
字符串数组
用户自定义前缀/后缀
filter
过滤特定的命名风格，检查或者不检查正则命中的命名
否
对象
配置格式与custom相似
match：设置为true表示只检查正则命中的名字，设置为false表示不检查正则命中的名字
regex：设置过滤的正则
说明
支持直接配置一个字符串，这个字符串配置的是regex，此时match相当于配置的是true。
modifiers
匹配修饰符，只有包含特定修饰符的命名才会检查
否
字符串数组
types
匹配类型，只有特定类型的名字才会检查
否
字符串数组
以上配置的参数有校验优先级：filter > types > modifiers > validate leading underscore > validate trailing underscore > validate prefix > validate suffix > validate custom > validate format。
执行代码检查
对pages/Index.ets文件执行代码检查，检查结果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151227.08464451582784410922887653605325:50001231000000:2800:C1DE4FC6E8C15C001E3B1C67CC91DC9F378B7D92F8B41F38DBA85C2DB0AC0899.png)
示例3：检查代码文件的命名风格
在配置文件中定义规则
在ArkTS工程中，pages目录下新建test.ets文件；
在工程根目录下新建code-linter.json5文件，新增以下配置：
如果selector属性不配置，默认检查代码文件和资源文件的命名风格。
执行代码检查
对pages/test.ets文件执行代码检查，检查结果如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151227.40751477230359316853520674147637:50001231000000:2800:442F5EBD0CA4F2E8E3A613AFC53976BBC03C06DF9721B13EEDA19805DCA56C48.png)

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-log-standard
爬取时间: 2025-05-01 09:11:47
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-log-standard-hilog
爬取时间: 2025-05-01 09:12:00
来源: Huawei Developer
简介
公共流水日志指通过系统日志打印接口（HiLog）统一输出到日志服务的日志。日志用来记录用户操作、程序运行状态等，是一个系统的重要组成部分。然而由于日志不是核心功能，日志质量常常不被开发人员所重视，特别是如果日志打印使用不正确，对应用性能稳定性等方面，可能会产生一定负面影响。每个领域在打印日志的时候都应该尽可能的合理，避免将其他领域的日志冲掉。
日志级别
【规则】根据实际情况正确的使用日志打印等级。
说明： 日志级别要符合日志内容的实际级别，可参考LogLevel，日志级别说明如下。
FATAL：重大致命异常，表明程序或功能即将崩溃，故障无法恢复。
ERROR：程序或功能发生了错误，该错误会影响功能的正常运行或用户的正常使用，可以恢复但恢复代价较高，如重置数据等。
WARN：发生了较为严重的非预期情况，但是对用户影响不大，程序可以自动恢复或通过简单的操作就可以恢复的问题。
INFO：用来记录业务关键流程节点，可以还原业务的主要运行过程；用来记录非正常情况信息，但这些情况都是可以预期的（如无网络信号、登录失败等）。这些日志都应该由该业务内处于支配地位的模块来记录，避免在多个被调用的模块或低级函数中重复记录。
DEBUG：比INFO级别更详细的流程记录，通过该级别的日志可以更详细地分析业务流程和定位分析问题。DEBUG级别的日志在正式发布版本中默认不会被打印，只有在调试版本或打开调试开关的情况下才会打印。
日志内容
【规则】日志打印内容使用英文描述，单词拼写无误，符合语法规范，准确表述日志的含义。
说明： 日志内容应该简明扼要地描述发生的事情，阅读日志的人可以通过日志直接知道表述的含义，尽量不要通过产生日志的代码才能知道；符合语法语义的日志打印也有利于后续日志分析工具对日志进行自动化解析。
如：“1234” 除了开发自己没人知道代表什么意义;“Error happened” 哪里发生了什么错误，错误的原因值等都没有打印出来，这样不利于问题的定位分析。
【规则】日志中禁止打印隐私信息。
说明： 硬件序列号、个人账号、密码、身份等隐私信息禁止在日志中打印。隐私信息的范围遵从国家和地区的政策要求。
【规则】日志中禁止打印其它与业务无关的信息。
说明： 禁止打印如issue单号、需求单号、公司部门名称、开发人员的姓名、工号、名字缩写、个人心情、当天的天气等任何与业务代码无关的信息。
【规则】日志中禁止打印重复信息。
说明： 禁止在不同的地方打印内容完全一样的日志，在问题定位时无法准确找到代码位置。
【规则】禁止在日志打印语句中调用业务接口函数。
说明： 日志打印不应该对业务的正常流程产生任何影响，定位问题走读代码时通常要忽略日志代码对业务逻辑的影响。
【规则】禁止将开发调试过程中使用的日志打印提交到代码仓中。
说明： 为了定位问题可能会在代码中的每一步增加一行日志打印，或将各种变量内容打印出来（可能含用户隐私）, 这些代码在提交到代码仓之前必须删除。
【建议】日志打印长度不要过长，尽可能使日志记录显示在一行以内。
说明： 一行的长度通常是指在100个字符左右，尽量不要打印超过160个字符以上的日志。
打印时机
【规则】高频代码的正常流程中禁止打印日志。
说明： 如被高频调用的接口函数、大数据量处理的循环中、高频的软硬件中断处理中、协议数据流处理中、多媒体音视频流处理中、显示屏幕刷新处理中等等，这些地方基本都是只要系统不休眠就会一直运行的代码，这些代码正常处理逻辑禁止打印日志，但可在错误分支中打印日志。开发调试过程中在这里增加的日志在提交代码时必须清除掉或使用开关关闭。
【规则】可能重复发生的日志需要进行频率限制。
说明： 当事实证明某些日志记录可能会发生多次时，最好实施一种频率限制机制，防止出现具有相同（或非常相似）信息的大量重复日志副本。
【规则】在基本不可能发生的点必须要打印日志。
说明： 根据墨菲定律，只要有可能发生的事就一定会发生，一旦发生就是疑难杂症。
【建议】日志字符串应在日志打印时再生成。
说明： 日志字符串越迟生成越好，最好是在日志打印那一刻才生成，这样当日志被关闭时也就不会生成这个字符串，从而最大程度地减少系统的开销。
日志形式
【规则】事件记录的日志使用who do what 主谓宾的形式打印。
【规则】状态变化的日志打印使用state_name:s1->s2, reason:msg的形式打印。
【规则】参数值的日志打印使用name1=value1, name2=value2…的形式打印。
【规则】代码运行成功的日志使用xxx successful的形式打印。
【规则】代码运行失败的日志使用xxx failed, please xxx的形式打印，且需包含可能的解决方案。
如："Connect to server failed, please check network configuration"。
常见模式日志打印要求
流程类日志
【建议】日志中应当记录业务的关键流程节点，包括业务的开始点，关键条件分支节点，错误处理点，业务结束点等。
数据库类日志
【建议】日志中应当记录对数据库的各种操作及其相关信息。
说明： 数据库的常规操作包括：增、删、改、查。操作的发起者、操作类型、操作成功还是失败也要在日志中记录；但操作及返回结果中的内容通常不应记录以防止泄露用户隐私；查询结果的数量可以打印。
【建议】对于性能敏感型业务的数据库操作日志需记录操作消耗的时间。
说明： 数据库操作涉及I/O读写，对于性能敏感性业务，数据库操作通常会是性能的关键节点，记录时间可以作为性能调优的参考依据。
【建议】日志中应当记录数据库的JOB相关信息。
说明： JOB的名称，执行内容，启动时间，结束时间，执行结果应当在日志中记录。
文件类日志
【建议】日志中应当记录对文件的各种操作及其相关信息。
说明： 文件的常规操作包括：创建、打开、读取、写入、关闭、删除、获取属性。操作的发起者、操作类型、操作结果需要记录日志；但文件内容不可记录以防止泄露用户隐私或暴露系统安全漏洞，系统文件名可以打印，用户文件名不可以打印；文件句柄值可以打印。
【建议】批量文件操作只打印一条日志而不是打印多条日志。
说明： 如批量删除大量文件，不要每删除一个文件就打印一条日志，只要记录删除的文件数即可，如果文件所在目录是系统创建，还要打印目录名称。
关键对象/对象池日志
关键对象/对象池可能是一个类或者一个结构体，也可能是一个队列或堆栈的数据结构，也可能是一个简单的原始类型变量，它处于系统的关键地位，系统的调度控制、状态记录、信息流转等动作都依赖它。
【建议】日志中应当记录关键对象的操作过程，操作结果，状态变化。
说明： 对象的操作包括：创建、加载、卸载、释放等。对关键对象的操作需记录操作主体，操作类型，操作结果；状态类的对象需记录状态变化的前后值。
线程日志
【建议】日志中需记录线程的各种操作及相关信息。
说明： 线程的操作包括：创建、启动、暂停、终止。日志中需记录操作线程的操作类型、操作结果、线程号、线程名称（重要线程一定要设置线程名）。
【建议】线程陷入死循环或死锁等错误时要记录日志。
说明： 对于有等锁处理、异步处理、循环处理等逻辑的线程，在线程发生死锁或死循环时要有检测机制，并在错误发生时打印日志。
【建议】消息处理型的线程需要打印消息处理相关的日志。
说明： 包括消息名称、消息处理结果、消息处理时长；对于高频消息，只需要打印消息处理结果错误时的日志即可。
并发控制日志
并发控制的对象可能是锁、临界区、信号量等。
【建议】日志中需记录并发控制对象的操作及其相关信息。
说明： 并发控制的操作包括：创建、占用、释放、等待等。日志中需记录操作的类型、操作对象的名称、操作的结果、操作的位置等信息。
共享内存日志
共享内存是软件系统中常用的进程间通信方法，它常用于模块间共享数据或传递数据。共享内存所存放的数据可以是配置数据、数据库数据等。
【建议】日志中需记录对共享内存的操作及相关信息。
说明： 对共享内存的操作包括：创建、删除、数据设置、数据查询、销毁等。日志中需记录对共享内存操作的操作者、操作类型、操作结果。
接口交互日志
接口包括系统的内外部接口，内部接口指系统内部子系统、子模块之间的接口。形式可能包括模块间消息发送、IPC接口、RPC接口等。
【建议】日志需记录接口交互相关的信息。
说明： 接口交互相关的信息包括：接口的调用者、消息内容（不能涉及用户隐私）、处理结果、返回值（不能涉及用户隐私）。
状态机日志
【建议】日志需记录状态机的操作及状态转换信息。
说明： 状态机的操作包括：创建、开始、状态转换、结束、销毁等。状态机通常受外部条件激励（如消息、资源等）变换状态，状态机的状态变化前后的名称、导致变化的外部激励条件等信息也应该被记录。
其它操作系统资源
这里说的主要操作系统资源指socket、定时器等未在前面小节已提及的资源（如文件、线程等）。
【建议】日志中需要记录socket连接建立的过程和结果、连接维持的情况、连接断开的情况及原因。
【建议】日志中需要记录定时器启动、复位、销毁、超时处理过程。
【建议】使用其它类似操作系统中提供的资源也应参照遵循上述类似的日志记录原则。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-operate
爬取时间: 2025-05-01 09:12:13
来源: Huawei Developer
APM（Application Performance Management）是一种用于监测和管理应用程序性能的解决方案。它通过收集、分析、报告应用程序的性能数据，帮助开发、运维团队快速定位和解决应用程序问题，提高应用程序的可靠性和性能。HarmonyOS提供了完善的HiAppEvent机制帮助开发者上报稳定性、性能等应用事件，开发伙伴可用其建立自身的APM系统。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-operate-apm
爬取时间: 2025-05-01 09:12:26
来源: Huawei Developer
APM作为应用性能管理平台可线上监控应用质量。系统提供采集质量数据的能力，开发者可以收集这类数据构建APM平台。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151227.26576351951882593181211702255276:50001231000000:2800:60BA5DD45068465C665C971F4158A0D054DE7A6F12F787D60C5DEA1B48C0D694.png)
本文主要介绍如何通过HiAppEvent订阅接口采集系统事件。其中，系统事件是指应用运行期间，应用进程发生的性能、功耗、稳定性等故障，HiAppEvent会将这些故障通过事件返回给开发者。
HiAppEvent系统事件订阅能力
当前HiAppEvent支持以下系统事件的订阅：
| 事件名称  | 事件描述  | 运行时信息  | external_log日志目录  | 日志目录空间大小（M）  |
| --- | --- | --- | --- | --- |
| APP_CRASH  | 崩溃  | 前后台、混合栈、hilog等  | /data/storage/el2/log/hiappevent  | 5  |
| APP_FREEZE  | 卡死  | 线程栈、主线程任务队列等  |
| ADDRESS_SANITIZER  | 地址越界  | 地址越界类型、异常栈等  |
| CPU_USAGE_HIGH  | CPU高负载  | 前后台、CPU使用率等  |
| RESOURCE_OVERLIMIT  | 资源泄漏  | 应用、系统内存大小等  | /data/storage/el2/log/resourcelimit  | 2*1024  |
| MAIN_THREAD_JANK  | 主线程超时  | 主线程任务耗时、采样栈等  | /data/storage/el2/log/watchdog  | 10  |
| APP_LAUNCH  | 启动耗时  | 冷热启动、桌面点击时间等  | NA  |    |
| SCROLL_JANK  | 滑动丢帧  | 滑动耗时、丢帧数等  | NA  |    |
| BATTERY_USAGE  | 24H功耗  | 使用时长、器件耗电大小等  | NA  |    |
事件名称
事件描述
运行时信息
external_log日志目录
日志目录空间大小（M）
APP_CRASH
崩溃
前后台、混合栈、hilog等
/data/storage/el2/log/hiappevent
5
APP_FREEZE
卡死
线程栈、主线程任务队列等
ADDRESS_SANITIZER
地址越界
地址越界类型、异常栈等
CPU_USAGE_HIGH
CPU高负载
前后台、CPU使用率等
RESOURCE_OVERLIMIT
资源泄漏
应用、系统内存大小等
/data/storage/el2/log/resourcelimit
2*1024
MAIN_THREAD_JANK
主线程超时
主线程任务耗时、采样栈等
/data/storage/el2/log/watchdog
10
APP_LAUNCH
启动耗时
冷热启动、桌面点击时间等
NA
SCROLL_JANK
滑动丢帧
滑动耗时、丢帧数等
NA
BATTERY_USAGE
24H功耗
使用时长、器件耗电大小等
NA
external_log返回的路径是沙箱目录，非真实物理路径，应用有权限访问自己的沙箱目录，参考应用沙箱目录。external_log日志空间受限，应用处理完日志文件后请及时删除。
系统事件订阅机制
应用调用HiAppEvent接口订阅系统事件，并生成一个共享目录。当应用进程发生故障，DFX系统抓取相关信息生成事件和日志，分享到应用共享目录。HiAppEvent监听到有事件发生回调给应用。
原理如下图：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151227.39046763350653115932683399542755:50001231000000:2800:374F5FFA17894D6431C799AD291E75A51D05A8E3DDE4BA5A3F1ED1C4BD22D839.png)
发生崩溃、卡死和地址越界故障时，应用会退出，所以需要在应用下次启动时才能获取到相应系统事件。
系统事件通用信息
HiAppEvent将事件信息统一归纳到AppEventInfo中，AppEventInfo结构可参考AppEventInfo。其中params参数对象在不同系统事件中定义各不相同，可参考每种系统事件介绍，例如崩溃参考崩溃事件介绍。
事件参数关键字段说明如下：
| 名称  | 说明  |
| --- | --- |
| bundle_name  | 应用名称。  |
| bundle_version  | 应用版本。  |
| external_log  | 日志文件，字符串数组，事件会返回一个或多个日志文件。仅部分事件包含external_log属性。  |
| log_over_limit  | 日志空间是否已满。true表示空间已满，会导致新的事件日志写入失败；false表示空间未满。  |
| …  |    |
名称
说明
bundle_name
应用名称。
bundle_version
应用版本。
external_log
日志文件，字符串数组，事件会返回一个或多个日志文件。仅部分事件包含external_log属性。
log_over_limit
日志空间是否已满。true表示空间已满，会导致新的事件日志写入失败；false表示空间未满。
…
log_over_limit属性用于判断external_log日志文件所在目录空间是否达到上限，log_over_limit值为true表示空间已满，事件包含的日志文件写入失败，需要清理历史日志文件。
external_log类型是字符串数组，以返回一个崩溃事件的日志文件为例：
external_log=["/data/storage/el2/log/hiappevent/APP_CRASH_unix时间戳_xxxx.log"]
HiAppEvent系统事件订阅方法
订阅接口使用方法
HiAppEvent提供addWatcher接口可以订阅系统事件，支持三种订阅方式。ArkTS接口参考hiAppEvent.addWatcher，C/C++接口参考OH_HiAppEvent_AddWatcher()。
方式一：通过订阅数据持有者holder，主动获取系统事件
以订阅崩溃事件为例，ArkTS接口示例代码如下：
主动获取系统事件，由于系统事件可能未生成或者日志信息未抓取完成，可能查询为空，可以尝试多次调用查询接口。
方式二：实现onTrigger回调，结合triggerCondition使用，满足回调条件触发回调
以订阅崩溃事件为例，ArkTS接口示例代码如下：
方式三：实现onReceive回调，监听到系统事件生成后实时回调
以订阅崩溃事件为例，ArkTS接口示例代码如下：
参数扩展接口使用方法
HiAppEvent提供setEventParam()接口可以在系统事件中添加自定义参数，当前支持在崩溃和卡死事件中增加自定义参数。ArkTS接口参考hiAppEvent.setEventParam。
使用接口完成参数键值对赋值。以在订阅崩溃事件中添加自定义参数为例，ArkTS接口示例代码如下：
```typescript
import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';
import { BusinessError } from '@kit.BasicServicesKit';
let params: Record<string, hiAppEvent.ParamType> = {
"test_data": 100,
};
/* 添加崩溃事件的自定义参数 */
hiAppEvent.setEventParam(params, hiAppEvent.domain.OS, hiAppEvent.event.APP_CRASH).then(() => {
hilog.info(0x0000, 'testTag', `HiAppEvent success to set event param`);
}).catch((err: BusinessError) => {
hilog.error(0x0000, 'testTag', `HiAppEvent code: ${err.code}, message: ${err.message}`);
});
```
HiAppEvent系统事件订阅方案设计
以崩溃采集为例，可参考如下设计：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151228.50088447732609067166836378218375:50001231000000:2800:5D4274B7D18FCEEF609EC78461FC3D1D1FAC03A2AB8A09C61A83FBBED5D76821.png)
1、APM代码早于业务代码。
2、应用启动阶段注册ErrorManager，可以捕获JS异常，发生JsError崩溃时进程不会退出。参考如何使用ErrorManager捕获异常。
3、在ErrorManager回调中执行takeNext接口获取JsError崩溃事件。
4、应用发生Cpp Crash异常退出，下次启动获取NativeCrash崩溃事件。
5、获取的崩溃信息可以持久化存储，上传后再删除，避免上传失败导致数据丢失。
6、日志管理，external_log日志处理后（比如上传后）及时清理。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-operate-event
爬取时间: 2025-05-01 09:12:39
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-cppcrash-guidance
爬取时间: 2025-05-01 09:12:53
来源: Huawei Developer
概述
CppCrash是C/C++运行时崩溃，包括空指针异常、数组越界异常、栈溢出异常等。HarmonyOS系统针对这一类故障，基于系统级DFX能力，能够进行检测并生成故障日志，生成在/data/log/faultlog/faultlogger系统目录下，在DevEco Studio中的FaultLog工具栏也能进行汇总显示。
CppCrash故障日志
日志格式和日志获取
CppCrash日志格式可参考《日志格式》。CppCrash故障根据报错场景可以分为运行态CppCrash故障和开发态CppCrash故障。
在开发态下，DevEco Studio会收集CppCrash、App Freeze、JS Crash、System Freeze、ASan的崩溃日志到FaultLog下，开发者可以通过FaultLog的CppCrash日志、ASAN日志定位问题的具体原因。此外，开发者可以自行获取/data/log/faultlog/faultlogger下的日志再进行分析。
在运行态下，开发者需要提前开通崩溃服务，收集运行状态下的CppCrash，具体步骤如下所示：
crash信号分类
进程崩溃基于Linux信号机制，目前主要支持对以下崩溃异常信号的处理：
| 信号值  | 信号  | 解释  | 触发原因  |
| --- | --- | --- | --- |
| 4  | SIGILL  | 非法指令  | 执行了非法指令、格式错误、未知或特权指令，通常是因为可执行文件本身出现错误，或者试图执行数据段，堆栈溢出时也有可能产生这个信号。  |
| 5  | SIGTRAP  | 断点或陷阱异常  | 由断点指令或其它trap指令产生。  |
| 6  | SIGABRT  | abort发出的信号  | 调用abort函数生成的信号。  |
| 7  | SIGBUS  | 非法内存访问  | 非法地址，包括内存地址对齐（alignment）出错。比如访问一个四个字长的整数，但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的（如访问不属于自己存储空间或只读存储空间）。  |
| 8  | SIGFPE  | 浮点异常  | 在发生致命的算术运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术的错误。  |
| 11  | SIGSEGV  | 无效内存访问  | 试图访问未分配给自己的内存，或试图往没有写权限的内存地址写数据。  |
| 16  | SIGSTKFLT  | 栈溢出  | 堆栈溢出。  |
| 31  | SIGSYS  | 系统调用异常  | 非法的系统调用（Seccomp 限制）  |
信号值
信号
解释
触发原因
4
SIGILL
非法指令
执行了非法指令、格式错误、未知或特权指令，通常是因为可执行文件本身出现错误，或者试图执行数据段，堆栈溢出时也有可能产生这个信号。
5
SIGTRAP
断点或陷阱异常
由断点指令或其它trap指令产生。
6
SIGABRT
abort发出的信号
调用abort函数生成的信号。
7
SIGBUS
非法内存访问
非法地址，包括内存地址对齐（alignment）出错。比如访问一个四个字长的整数，但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的（如访问不属于自己存储空间或只读存储空间）。
8
SIGFPE
浮点异常
在发生致命的算术运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术的错误。
11
SIGSEGV
无效内存访问
试图访问未分配给自己的内存，或试图往没有写权限的内存地址写数据。
16
SIGSTKFLT
栈溢出
堆栈溢出。
31
SIGSYS
系统调用异常
非法的系统调用（Seccomp 限制）
CppCrash故障定位
辅助工具介绍
（1）反编译addr2line
Linux下addr2line命令用于将程序指令地址转换为所对应的函数名、以及函数所在的源文件名和行号。在问题定位时，可以使用llvm-addr2line.exe来替换addr2line，其对应的路径在"SDK安装路径\版本路径\base\native\llvm\bin"下，使用时可以参考以下命令。其中，libentry.so是报错的动态链接库，0000000000001c14是报错的内存地址。
| 参数  | 功能描述  |
| --- | --- |
| -C  | 去除名称修饰  |
| -f  | 在反汇编结果中显示函数名  |
| -a  | 显示内存地址  |
| -i  | 解开内联函数  |
| -e  | 指定待还原的so的路径  |
参数
功能描述
-C
去除名称修饰
-f
在反汇编结果中显示函数名
-a
显示内存地址
-i
解开内联函数
-e
指定待还原的so的路径
（2）反汇编objdump
objdump可以用来显示二进制文件的信息，它可以进行反汇编用于观察内存异常。在问题定位时，可以使用llvm-objdump.exe来替换objdump，其对应的路径在"SDK安装路径\版本路径\base\native\llvm\bin"下，使用时可以参考以下命令。其中，libentry.so是需要反汇编的动态链接库，text.txt用于存储反汇编的代码。
| 选项  | 功能说明  |
| --- | --- |
| -C  | 将低级符号名称解码（解映射）为用户级名称。除了删除系统预置的任何初始下划线外，这还使C++函数名可读。不同的编译器有不同的篡改样式。可选的 demangling 样式参数可用于为编译器选择适当的 demangling style 。  |
| -d  | 显示 objfile 中机器指令的汇编助记符。此选项仅反汇编那些预期包含指令的部分。  |
| -D  | 像 -d 一样，但反汇编所有部分的内容，而不仅仅是那些预期包含指令的部分。  |
| -F  | 在反汇编 sections 时，无论何时显示符号，都要显示要转储的数据区域的文件偏移量。如果跳过了零，那么当反汇编恢复时，告诉用户跳过了多少个零，以及反汇编恢复位置的文件偏移量。转储节时，显示转储开始位置的文件偏移量。0000000000000665 <funcb> (File Offset: 0x665):so共享库的某个反汇编函数入口000000000040052d <main> (File Offset: 0x52d): 可执行文件的某个反汇编函数入口  |
| -l  | 用于显示目标代码或重定位文件名和源行号标记（使用调试信息）  |
| -S  | 如果可能的话（有调试信息），显示混合了反汇编的源代码。  |
选项
功能说明
-C
将低级符号名称解码（解映射）为用户级名称。除了删除系统预置的任何初始下划线外，这还使C++函数名可读。不同的编译器有不同的篡改样式。可选的 demangling 样式参数可用于为编译器选择适当的 demangling style 。
-d
显示 objfile 中机器指令的汇编助记符。此选项仅反汇编那些预期包含指令的部分。
-D
像 -d 一样，但反汇编所有部分的内容，而不仅仅是那些预期包含指令的部分。
-F
在反汇编 sections 时，无论何时显示符号，都要显示要转储的数据区域的文件偏移量。如果跳过了零，那么当反汇编恢复时，告诉用户跳过了多少个零，以及反汇编恢复位置的文件偏移量。转储节时，显示转储开始位置的文件偏移量。0000000000000665 <funcb> (File Offset: 0x665):so共享库的某个反汇编函数入口000000000040052d <main> (File Offset: 0x52d): 可执行文件的某个反汇编函数入口
-l
用于显示目标代码或重定位文件名和源行号标记（使用调试信息）
-S
如果可能的话（有调试信息），显示混合了反汇编的源代码。
（3）ASan
ASan（Address-Sanitizer）是内存检测的工具，用于发现内存飞踩第一现场，DevEco Studio已集成ASan为开发者提供面向C/C++的地址越界检测能力。ASan可以解决一些踩内存导致的异常crash的补充手段，对于一些明显不可能crash的场景可以尝试开启ASan。详情可参考参考《ASan检测》。
CppCrash故障定位方法
CppCrash常用故障定位分为本地环境定位和系统环境定位，其主要的定位思路类似，详细的定位方法如下所示：
（1）找出问题必现条件，复现问题场景；
（2）先开多线程检测配置，排查多线程安全问题；
先打开多线程检测配置，确认问题是否属于多线程安全问题，若打开多线程检测配置之后还是报当前错误栈，则进行下一步排查。打开开关的hdc指令为：
persist.ark.properties的默认值为0x105c（即关闭状态）。
（3）根据信号和错误码初步推断crash原因。如下图所示，错误原因为SIGSEGV(SEGV_ACCERR)，说明是xmlparser崩溃相关原因。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151228.98587474050989869477399815568375:50001231000000:2800:7E710CE4A740F3E63B94F5469394D4C16A3E801A05DB6FF389D54DE45330A8CE.png)
（4）根据堆栈信息找出报错的栈顶函数。
如下图所示，在开发态发生CppCrash时，在本地环境的DevEco Studio中，Native栈帧和JS栈帧可以通过蓝色链接直接跳转到对应的代码行。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151228.03945443420089393657214695113850:50001231000000:2800:82B81751C637DE5EE729FABCDDBF63354E5E5A54EB7BDA170632CF963EF7D69C.png)
在运行态下，开发者可以找到报错的日志，根据对应的报错日志使用llvm_addr2line解析出栈帧的对应的代码行号。案例如下所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151228.28144414794246164802830223609375:50001231000000:2800:852B64050DAEEA205BBBFDB7CF8CFD5C8A052127EB15BBDDD787154684C8609D.png)
使用addr2line后，如果得出的行号看起来不是很正确，可以考虑对地址进行微调(如减1)，或者考虑关闭一些编译优化，已知使用LTO（Link Time Optimization）的二进制可能无法正确获得行号。
（5）若无法定位出具体原因，可以使用llvm-objdump反汇编代码，再进一步进行分析。
分析反汇编可参考以下步骤：
（6）如果有理论上不应该发生堆栈报错，可以考虑开启ASan，再根据ASan定位分析具体原因。
如下所示，发生crash后，根据ASan故障日志定位错误代码。
常见问题
应用开发时，发生CppCrash的常见场景有非法参数、多线程安全、napi_value生命周期、空指针等。常见的CppCrash的场景、原因汇总如下表所示。
| 常见场景  | 常见信号及错误码  | 定位思路  | 崩溃原因  |
| --- | --- | --- | --- |
| 非法参数  | SIGSEGV(SEGV_MAPERR)@0X00402109F85E8090（内存地址为极大的非正常地址）  | 如果有cppcrash栈直接崩溃在libace_napi.z.so/libark_jsruntime.so/libace_napi_ark.z.so，并且libace_napi.z.so的栈帧位置较浅。这种问题往往需要napi模块的上层使用者优先去排查。可以参考案例传入的napi_env的虚函数表指针为大地址、传入的napi_value异常、传入的NativeValue*为空指针。  | 传入的napi_env的虚函数表指针为大地址  |
| SIGSEGV(SEGV_MAPERR)@0X000000000000001c（内存地址为较小的地址）  | 可能原因为传入的napi_value异常  |
| SIGSEGV(SEGV_MAPERR)@0X0000000000000008  | 传入的NativeValue*为空指针  |
| SIGSEGV(SEGV_MAPERR)@0X0000000000000012  | 传入的napi_defer为undefined  |
| SIGSEGV(SEGV_MAPERR)@0X0000000000000022  | 返回的ArrayBufferRef为undefined  |
| 多线程安全  | SIGSEGV(SEGV_MAPERR)@0X0000000000000028  | 崩溃栈从上往下看，略过libark_jsruntime.so/libace_napi.z.so/libace_napi_ark.z.so，看是从哪个上层模块的so调用过来的，该上层模块就存在多线程安全问题。  | napi_env释放后仍被使用  |
| SIGSEGV(SEGV_MAPERR)@0X0000000000001f98  | static变量  |
| napi_value生存期  | SIGSEGV(SEGV_MAPERR)@0X000000000000002a（报错为：Can not get Prototype on non ECMA Object）  | 根据崩溃栈反编译找到出现问题的napi接口的上层接口，在上层接口内找到出问题的napi_value，检查napi_value的使用范围是否超出了napi_handle_scope的作用域范围。  | napi_value超出NAPI框架的scope  |
| xmlparser崩溃  | SIGSEGV(SEGV_ACCERR)@0x0000007f8e71d000  | 如果崩溃在libxml.z.so，需要检查xml解析的代码  | xmlparser崩溃  |
| native层调用iconv函数崩溃  | SIGSEGV(SEGV_MAPERR)@0x000000808566e685  | 查看日志中是否有iconv关键字确定报错类型，并根据报错日志定位到错误代码  | native层调用iconv函数crash  |
常见场景
常见信号及错误码
定位思路
崩溃原因
非法参数
SIGSEGV(SEGV_MAPERR)@0X00402109F85E8090（内存地址为极大的非正常地址）
如果有cppcrash栈直接崩溃在libace_napi.z.so/libark_jsruntime.so/libace_napi_ark.z.so，并且libace_napi.z.so的栈帧位置较浅。这种问题往往需要napi模块的上层使用者优先去排查。可以参考案例传入的napi_env的虚函数表指针为大地址、传入的napi_value异常、传入的NativeValue*为空指针。
传入的napi_env的虚函数表指针为大地址
SIGSEGV(SEGV_MAPERR)@0X000000000000001c（内存地址为较小的地址）
可能原因为传入的napi_value异常
SIGSEGV(SEGV_MAPERR)@0X0000000000000008
传入的NativeValue*为空指针
SIGSEGV(SEGV_MAPERR)@0X0000000000000012
传入的napi_defer为undefined
SIGSEGV(SEGV_MAPERR)@0X0000000000000022
返回的ArrayBufferRef为undefined
多线程安全
SIGSEGV(SEGV_MAPERR)@0X0000000000000028
崩溃栈从上往下看，略过libark_jsruntime.so/libace_napi.z.so/libace_napi_ark.z.so，看是从哪个上层模块的so调用过来的，该上层模块就存在多线程安全问题。
napi_env释放后仍被使用
SIGSEGV(SEGV_MAPERR)@0X0000000000001f98
static变量
napi_value生存期
SIGSEGV(SEGV_MAPERR)@0X000000000000002a（报错为：Can not get Prototype on non ECMA Object）
根据崩溃栈反编译找到出现问题的napi接口的上层接口，在上层接口内找到出问题的napi_value，检查napi_value的使用范围是否超出了napi_handle_scope的作用域范围。
napi_value超出NAPI框架的scope
xmlparser崩溃
SIGSEGV(SEGV_ACCERR)@0x0000007f8e71d000
如果崩溃在libxml.z.so，需要检查xml解析的代码
xmlparser崩溃
native层调用iconv函数崩溃
SIGSEGV(SEGV_MAPERR)@0x000000808566e685
查看日志中是否有iconv关键字确定报错类型，并根据报错日志定位到错误代码
native层调用iconv函数crash
非法参数是CppCrash的常见场景之一。在napi接口中，所需参数一般有两种，一种是napi_env，一种是napi_value，实际上，这两种入参都是裸指针（非智能指针），napi接口中会对他们进行空指针拦截，然而，无法拦截其他的野指针（仅声明但未做初始化，且不为空的指针）。因此，如果有cppcrash栈直接崩溃在libace_napi.z.so/libark_jsruntime.so/libace_napi_ark.z.so，并且libace_napi.z.so的栈帧位置较浅。此类问题一般都是napi模块的上层模块在调用napi接口时传参有问题导致，这种问题往往需要napi模块的上层使用者优先去排查。
在多线程检测机制中，会判断当前线程的thread id与被使用的vm/env中的thread id是否一致，若不一致，则表明vm/env被跨线程使用，可能引发多线程安全问题，被拦截日志拦截（Fatal:ecma_vm cannot run in multi-thread!）。在定位多线程的崩溃时，需要从上往下看崩溃栈，略过libark_jsruntime.so/libace_napi.z.so/libace_napi_ark.z.so，看是从哪个上层模块的so调用过来的，该上层模块就存在多线程安全问题。
开发者在书写native代码创建napi_value时，需要配合napi_handle_scope一起使用。napi_handle_scope的作用是管理napi_value的生命周期，napi_value只能在napi_handle_scope的作用域范围内进行使用，离开napi_handle_scope作用域范围后，napi_value及它所持有的js对象的生命周期不再得到保护，一旦引用计数为0，就会被GC回收掉，此时再去使用napi_value就会访问已释放的内存，产生问题。 在产生napi_value生存期问题时，需要根据崩溃栈反编译找到出现问题的napi接口的上层接口，在上层接口内找到出问题的napi_value，检查napi_value的使用范围是否超出了napi_handle_scope的作用域范围。
libuv非法释放
问题描述
在测试hap包时，ASan出现以下报错：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151228.79541975675432305002771467329119:50001231000000:2800:8D74BE1C35AD25AE1417E8DF636AB6E3A0E3FA9B1D04FAD7DDF7B5B257E9DDA2.png)
定位分析
从堆栈中可知，应用在调用libuv.so之后直接报踩内存错误，报错地址为0x21304。
根据动态链接库libuv.so和报错内存地址0x21304，执行命令addr2line.exe -fie libuv.so 0x21304进行反编译，得到以下信息。
根据反编译信息可知，报错发生在uv_timer_init函数中。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151228.44033866845388156898123441577793:50001231000000:2800:709AAC0751CB19B5B8EC8E30EAA0535751B79D01E69F81596EBA977E1E9B42DD.png)
当前，报错定位到源码 uv__handle_init(loop, (uv_handle_t*)handle, UV_TIMER)，需要确认这个方法在调用中哪个地址被踩了，所以需要对0x21304进行反汇编；
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151228.07731582539886421423507542869606:50001231000000:2800:9A9EED9B01FD95413C0154B51525A1B3ADA93CFA985BA35DECAE9DD42710F7DE.png)
在汇编代码中，发现0x21304是由X23寄存器赋值给X0，继续追踪X23寄存器。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151228.75091067830432111198846950940388:50001231000000:2800:7D2CA099F755E86E24C44A890A8CA3377DEBFBE6E942D710CAF1E95CE7E991FA.png)
X23寄存器是 X19寄存器加上立即数 0x28。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151228.63994044308222778532687396549215:50001231000000:2800:EFC009E5BCD1EEBFD2548D4E1EAA4BBC717CCA269CE6FE3C4E5DC8120C0F9185.png)
X19寄存器是X1寄存器赋值，而X1寄存器则对应int uv_timer_init(uv_loop_t* loop, uv_timer_t* handle)的第2个入参 handle（一般而言X0寄存器对应方法的第一个参数，依次下去）。
再返回到代码中进行下一步分析，首先分析uv_timer_t* handle的结构体，其代码如下：
通过计算uv_timer_s的偏移，第40字节偏移应该是指向 handle_queue[1]处，接着分析uv_handle_init函数如下，可以看到该函数除了初始化之外，还有一个将handle放到loop->handle_queue的操作。
通过代码流程分析，在uv_handle_init中确实有handle->handle_queue操作的动作，就是这个QUEUE_INSERT_TAIL; 现在故障现场已经找到了，但是不知道这里是如何被踩的。
继续检查QUEUE_INSERT_TAIL，通过加日志测试可知参数 h 为无效指针（已经被释放），但是在这里又被使用到了，所以导致 uaf 问题。一路回溯上去就确认是 uv__handle_init(loop, (uv_handle_t*)handle, UV_TIMER) 中的第二个参数 handle 的问题。
最后检查代码确认，在 unschedule 函数中的 else 分支内，ptrRef 被提前 delete 掉了；此处应跟 if 分支里面的实现一样，采用libuv异步方式释放内存，用 uv_close 的形式交给 libuv 自己去管控 handle 的生命周期。
传入的napi_env的虚函数表指针为大地址
问题描述
如果有cppcrash栈直接崩溃在libace_napi.z.so/libark_jsruntime.so/libace_napi_ark.z.so，并且libace_napi.z.so的栈帧位置较浅。此类问题一般都是napi模块的上层模块在调用napi接口时传参有问题导致，这种问题往往需要napi模块的上层使用者优先去排查。 案例崩溃栈如下所示：
定位分析
在崩溃栈中，可以发现崩溃地址是一个极大的非正常地址。使用addr2line工具反编译解析代码行后看到，崩溃在46行，也就是尝试调用env里面的CreateUndefined方法挂掉了，而且是还没调用进去就挂了，CreateUndefined是engine上的虚方法，调用这个函数分为三步，一是从engine类上取出虚表，二是从虚表中拿出函数指针，三是跳转。第一步会对env解一次引用，拿出虚表指针，第二步会对虚表指针偏移后解引用，拿出函数指针。对于本案例来说，出问题的可能会出现在第一、二步，现在就要排查到底是env是个大地址，还是虚表是个大地址。
如果是第三步出了问题，报的崩溃栈是not mapped pc错误
接下来我们看寄存器信息，x0是第一个入参，也就是env，我们可以看到，env落在libuv.so里面，这明显有问题，也就是libesharehm.so传入的env这个裸指针已经非法。从这个非法地址中取出第一个域（虚表）是一个大地址b9402109f85e8008，然后从这个虚表中偏移一定位数之后解引用，尝试取函数指针，b9402109f85e8008解引用导致崩溃，报SEGV_MAPERR错误。崩溃栈顶为@0x00402109f85e8090 （dfx将高位两0抹除）。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151228.06980572729993958418261088017586:50001231000000:2800:6F12B17972D6174C59C204CCC2F8B508B07F482EF4478681A33EC03D02DB2A03.png)
对于本案例，有两个上层的排查建议：
传入的napi_value异常
问题描述
此类问题基本都是参数传的有问题，其崩溃栈如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151228.71331600177684969608523969764286:50001231000000:2800:2179E3C4AF8FE0E8713493991257D07909A6A2433CF7D5DD9FB7E5AE43A51C12.png)
定位分析
首先，使用addr2line工具反编译找到出现问题的接口及行号。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151229.88466114156551081083475828284676:50001231000000:2800:4672214D7D1B1078BC307931DAE2F598257DFB119AC0F17C8D17F2DA4F9EF84F.png)
从崩溃原因 SIGSEGV(SEGV_MAPERR)@0x000000000000001c ，大致可以推断出 napi_typeof 的第二个参数 value 有问题。但是是其本身的值有问题，还是其指向的内存有问题，需要用objdump工具反汇编并结合寄存器的值进一步分析。
从cppcrash文件Registers可以看出value本身即 x1 的值000000558473f264 看起来没什么问题（不确定地址是否是8字节对齐的地址，这里暂且假设地址是正常的），所以我们继续分析其指向的内存。
出现问题的汇编代码是 ldr x8 [x8, #24] , x8 是 x1 值所指向的内容，其值为0x4 ，很明显 x8 加上立即数 #24 就是崩溃的地址 0x1c 。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151229.48583398558461134938455132532588:50001231000000:2800:A76E2AE1E2980714C542EF1FC2A04C28C2C9F31D789359E2E70CF1BF407411D3.png)
另外，x8的值从Memory near registers也可以看出来，000000558473f264地址对应的值为0x4。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151229.48886623680017524236867542967711:50001231000000:2800:92792905211C4ED9F31AB25D1DBDD7C40A0EA64BBDCE63569DC5FA9A9309AFA0.png)
回到出现问题的行号，可以看出是在调用TypeOf函数，它是一个虚函数，因此x8就是虚函数表地址，24就是虚函数TypeOf在虚函数表中的偏移量。正常情况下，ldr x8 [x8, #24]执行完后，x8就是TypeOf函数地址，紧接着再执行blr x8就完成了TypeOf函数调用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151229.03570867621727263406658419532800:50001231000000:2800:0BF1FEE6190E92B4A86BADB2A41FD2D46C7C8334B07A3C9681DCF3A17ABE235E.png)
通常这类问题有两个原因：
传入的NativeValue*为空指针
问题描述
调用用SetProperty发生崩溃，堆栈如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151229.64807788940842311724369989403565:50001231000000:2800:1EFA8B53CADA9236EAF3C2DAC6B0304D0D756DF2968591C27E04136CF1C13DA9.png)
定位分析
通过addr2line工具，得知崩溃时的调用代码如下。
但这里看不出具体原因，所以继续使用objdump反汇编看一下具体的汇编指令。
从堆栈上看，最后崩溃在 2bc0c 上，反汇编结果对应的指令如下：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151229.73988849515716876591192139656439:50001231000000:2800:5D37C6C57E3C099B8A54ED214E1371F5CB71F0E9D1EB745971DE315065378A8D.png)
上面的指令ldr x1, [x19, #8]，其中x19为参数value(x19最近一次是通过x2赋值的，x2就是第二个参数value，x0为this，x1为第一个参数name)，结合上面Registers可以看出，x19寄存器的值为0x0，加上了偏移8，也就是取地址0x8的内容。
到此，可以得出初步结论SetProperty的时候，传入的第二个参数value为nullptr。 另外一方面从日志也可以看出，创建JsResourceManager也发生了异常。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151229.96769275177028893196276296852949:50001231000000:2800:F7F03475DDB417A4FD9A16A09440D1E3E820B75DF5970EC4920CFE5C3E7AC178.png)
NativeValue到Global涉及了多层的转换， NativeValue* 指向的内容和Global是一样的，所以通过Global拿address等同于通过NativeValue*去取其第一个成员的值。因为NativeValue析构函数为virtual，所以取成员需要加上虚表偏移#8 。
因此，问题根因已找到：CreateJsResourceManager返回了nullptr。
返回的ArrayBufferRef为undefined
问题描述
此类问题崩溃栈如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151229.98402164524731084586952556085872:50001231000000:2800:6939BA9C6D890C3EC0898BDB6A3BC529CF8AE59750F77FE0235E894A561127EE.png)
定位分析
造成上述现象的原因是因为this为undefined，undefined在运行时中的编码是0x02，0x22是undefined去取 ArrayBufferData 这个域导致的崩溃。
因此需要往上分析：
从构造函数可以看出，JSArrayBuffer为undefined说明value_为undefined。
此时有两种情况：
排查建议：
传入的argv与argc大小不一致
问题描述
napi_get_cb_info接口的入参包括argv和argc。argv表示存放一定数量的napi_value的数组，argc表示数组argv的长度。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151229.50659739440519068128715738462593:50001231000000:2800:3E1AD98642CF29CC5FAC6D2C472659A3416440AB6BBBBE8EAAA6D835652E7ECA.png)
在使用napi_get_cb_info接口时，应注意argc的值需要与argv的有效长度保持一致：
定位分析
传入的argc，等于argv的实际长度，但大于argv的有效长度（例如声明了argv[2]，但只对argv[0]和argv[1]进行了初始化，这种情况下，argv实际长度为3，有效长度为2）：
这种情况下，不能通过argv[i] != nullptr作为条件去判断元素是否有效，而应该通过napi_typeof去检查argv[i]的类型是否为napi_undefined去判断元素是否有效。在一些代码中，会先对argc参数个数进行检查，再对argv[i]参数类型进行检查，最后又检查argv[i]是否为nullptr，此时的判空逻辑是多余的，可以去除。以下列举多余判空的例子：
TaskPool & Worker多线程问题
问题描述
部分应用在使用TaskPool或Worker时出现了多线程问题，主要的原因是底层使用了std::map<napi_env, napi_ref>等形式，直接或间接通过env地址作为key来存取napi_ref。
定位分析
排查步骤如下所示：
napi_value超出NAPI框架的scope
问题描述
js侧通过Add接口添加数据，native侧以napi_value保存到vector。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151229.14304216137824047097884218454444:50001231000000:2800:C1E8B0B17B6A43AD3D7665F4547EDE67A116EECCEF272ECB2254809C587DB637.png)
js侧通过get接口获取添加的数据，native侧将保存的napi_value以数组形式返回回去，然后js侧读取数据的属性。
出现报错：Can not get Prototype on non ECMA Object。
定位分析
报错的主要原因是跨napi的native_value未使用napi_ref保存，导致native_value失效。
NAPI框架的scope即napi_handle_scope，napi开发者可以通过napi_handle_scope来管理napi_value的生命周期。
框架层的scope嵌入在js call native的端到端流程中，即：进入开发者自己写的native方法前open scope，native方法结束后close scope。
通过使能asan定位heap-use-after-free问题
问题描述
开启Address Sanitizer后获取到的asan故障日志如下：
定位分析
根据错误日志定位分析，发现错误发生在如下代码：
直接获取appName并将其转换为C风格的字符串会存在一个问题。因为appName.c_str()返回的是一个临时字符串的指针。这个临时字符串在表达式结束后就会被销毁。这就以为着config.bundleName可能会指向一个已经被销毁的字符串，这将导致未定义的行为。
修改错误代码如下所示，这种方式中，首先获取了appName的一个副本，然后将其转换为C风格的字符串。在这种情况下，appName的生命周期会持续到当前的代码块结束。因此，config.bundleName指向的字符串在当前代码块内是有效的。
锁范围不足导致的Crash问题
问题描述
设备开关机压测时，崩溃在libcesfwk_core.z.so，崩溃栈如下：
定位分析
根据Reason可知为野指针，根据 #01 定位到具体的代码行有：
对应的代码如下所示：
Remote的代码如下所示：
继续查找remoteObject_的来源，可以知道CommonEventProxy有如下继承关系：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250430151229.82206577653645921330446804448535:50001231000000:2800:BF6EE92D1F39687C98ED5DA3FC67DCEB1C1FB59806681D61E2886194D61D3472.png)
IRemoteObject 有如下构造函数：
CommonEventProxy 有如下构造函数：
继续查看CommonEventProxy，CommonEventProxy 的构造函数在文件 common_event.cpp 中：
可以看到在如下代码中，构造了CommonEvent 实例，但是isProxyValid_并不在锁保护的范围内，可能锁所保护的代码段会重入，从而导致崩溃。锁实际上需要保护的是commonEventProxy_和isProxyValid_，但实际上只保护了commonEventProxy_，存在重入的可能，因此使用锁的时候，需要明确具体到底需要保护的是什么数据。这里将isProxyvalid_加入到锁保护的范围内即可解决问题。

URL: https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-crash-monitor-practice
爬取时间: 2025-05-01 09:13:07
来源: Huawei Developer
概述
崩溃（Crash）指的是应用程序在运行过程中突然停止运行或出现错误导致程序无法正常继续执行。
崩溃率作为衡量应用质量的重要指标之一，监测崩溃点，解决崩溃问题，对维护应用的稳定性有着诸多方面的意义：
针对应用崩溃事件的监测，推荐以下两种方式：
1.  HiAppEvent应用事件，提供开发者记录故障、行为、安全、统计等事件，应用可以使用HiAppEvent系统能力来实现埋点采集数据。 如果开发者需要对Crash数据进行定制化的处理，可以通过HiAppEvent自行收集数据后，上传到指定的服务器中。
2.  通过崩溃服务订阅崩溃提醒，当应用发生崩溃事件时及时得到通知，并利用该服务提供的详细信息进行分析处理，可以帮助开发者查找问题根因，快速修复，提升应用质量和用户体验。
在监听采集Crash崩溃问题上，两种方式有以下相似和差异点：
|    | 相似点  | 差异点  |
| --- | --- | --- |
| HiAppEvent  | 事件打点机制，可以订阅多种事件，包括崩溃； 属于系统自带API；  | 结构化数据，可收集上传到指定服务器； 自行对数据进行分析处理操作  |
| AGC崩溃服务  | 实时监控服务，可以订阅崩溃提醒； 无需集成SDK；  | 数据透明传输，基于AGC一站式服务； 无需代码开发，查看可视化数据报告  |
相似点
差异点
HiAppEvent
事件打点机制，可以订阅多种事件，包括崩溃；
属于系统自带API；
结构化数据，可收集上传到指定服务器；
自行对数据进行分析处理操作
AGC崩溃服务
实时监控服务，可以订阅崩溃提醒；
无需集成SDK；
数据透明传输，基于AGC一站式服务；
无需代码开发，查看可视化数据报告
在语言层面，二者都支持ArkTS和C/C++的运行时崩溃监测，针对C/C++的崩溃故障问题，可参考《CppCrash故障定位指导》。
HiAppEvent订阅崩溃事件
HiAppEvent简介
HiAppEvent是在系统层面为应用开发者提供的一种事件打点机制，帮助应用记录在运行过程中发生的故障信息、统计信息、安全信息、用户行为信息，支撑开发者分析应用的运行情况。以便进一步统计分析访问数、日常用户活跃数量、用户操作习惯以及其他影响用户使用产品的关键因素。
HiAppEvent的接口设计，是由系统决定回调的时机。在回调执行时，开发者可以获取到已订阅事件的结构化数据。
场景与事件选型
应用在运行态，通常需要关注以下质量问题：
目前HiAppEvent在这些问题上都具备相应的事件记录能力，更多事件选型参考应用事件打点API文档。通过订阅相关事件，可以获取相应日志，进行问题定位分析。
本文以崩溃故障的场景为重点，具体是指在应用发生APP_CRASH 、APP_FREEZE 后监听相应的崩溃信息进行处理。
注意，使用HiAppEvent进行崩溃的监听，在应用崩溃之后，用户通过再次进入应用，进行崩溃信息的处理。
详细步骤
HiAppEvent订阅崩溃事件的开发流程可分别参考订阅崩溃事件（ArkTS）开发步骤与订阅系统崩溃事件（C++）开发步骤。
使用AGC崩溃服务
AGC简介
AppGallery Connect（简称AGC），致力于为应用的创意、开发、分发、运营、经营各环节提供一站式服务，构建全场景智慧化的应用生态体验。AGC深度整合多项优质服务，可以大幅降低应用开发与运维难度，提高版本质量，开放分发和运营服务，帮助开发者获得用户并实现收入的规模增长。
其中，在应用质量方面，AGC崩溃服务它能帮助开发者快速发现、定位、解决应用崩溃（又称闪退）问题，其使用简便，无需开发任何代码即可实现可视化数据报告的实时查看。
详细步骤
AGC崩溃服务的开发使用流程如下：
创建项目与应用
开通崩溃服务
测试崩溃服务
配置完成后，需要测试崩溃服务是否正常运行，可以手动制造一个崩溃，然后在AGC上查看上报情况。
1.
分析崩溃问题
目前运行在HarmonyOS ROM版本≥3.0.0.25的ArkTS应用无需集成SDK，只需要创建应用、开通服务即可使用。


# 合并文件
合并时间: 2025-04-28 06:38:36

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/system-security-V14
爬取时间: 2025-04-28 01:18:29
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/access-control-V14
爬取时间: 2025-04-28 01:18:44
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/access-token-overview-V14
爬取时间: 2025-04-28 01:18:58
来源: Huawei Developer
默认情况下，应用只能访问有限的系统资源。但某些情况下，应用存在扩展功能的诉求，需要访问额外的系统数据（包括用户个人数据）和功能，系统也必须以明确的方式对外提供接口来共享其数据或功能。
系统通过访问控制的机制，来避免数据或功能被不当或恶意使用。当前访问控制的机制涉及多方面，包括应用沙箱、应用权限、系统控件等方案。
应用沙箱
系统上运行的应用程序均部署在受保护的沙箱中，通过沙箱的安全隔离机制，可以限制应用程序的不当行为（如应用间非法访问数据、篡改设备等）。每个程序都拥有唯一的ID（TokenID），系统基于此ID识别与限制应用的访问行为。
应用沙箱限定了只有目标受众才能访问应用内的数据，并限定了应用可访问的数据范围，具体请参考应用沙箱目录。
应用权限
系统根据应用的APL等级设置进程域和数据域标签，并通过访问控制机制限制应用可访问的数据范围，从而实现在机制上消减应用数据泄露的风险。
不同APL等级的应用能够申请的权限等级不同，且不同的系统资源（如：通讯录等）或系统能力（如：访问摄像头、麦克风等）受不同的应用权限保护。通过严格的分层权限保护，有效抵御恶意攻击，确保系统安全可靠。
应用权限管控的详细介绍，请参考应用权限管控概述。
安全访问机制
HarmonyOS推出安全访问机制，改变应用获取隐私数据的方式，让用户从管理“权限”到管理“数据”，按需授予系统数据。举例而言，当用户想要更换社交平台头像时，应用将无法再获取整个图库的访问权限，用户选择哪张照片，应用就得到哪张照片，将用户的隐私数据与应用之间受控隔离，全面守护用户隐私。
具体来说，安全访问机制主要由系统Picker、安全控件两种系统机制来实现，在特定的场景中，应用无需向用户申请权限也可临时访问受限资源，实现精准化权限管控，更好地保护用户隐私。
-  系统Picker 由系统独立进程实现，在应用拉起Picker，并由用户操作Picker后，应用可以获取Picker返回的资源或结果。举例说明，当应用需要读取用户图片时，可通过使用照片Picker，在用户选择所需要的图片资源后，直接返回该图片资源，而不需要授予应用读取图片文件的权限。
-  安全控件 由系统提供UI控件，应用在界面内集成对应控件，用户点击后，应用将获得临时授权，从而执行相关操作。举例说明，当应用需要分享当前位置时，可使用位置控件，用户点击后，将会在本次前台期间获得精准定位的授权，可以调用位置服务获取精准定位。当发生灭屏、应用切后台、应用退出等任一情况时，临时授权结束。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/app-permission-mgmt-V14
爬取时间: 2025-04-28 01:19:12
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/app-permission-mgmt-overview-V14
爬取时间: 2025-04-28 01:19:26
来源: Huawei Developer
简介
系统提供了一种允许应用访问系统资源（如：通讯录等）和系统能力（如：访问摄像头、麦克风等）的通用权限访问方式，来保护系统数据（包括用户个人数据）或功能，避免它们被不当或恶意使用。
应用权限保护的对象可以分为数据和功能：
-  数据包括个人数据（如照片、通讯录、日历、位置等）、设备数据（如设备标识、相机、麦克风等）。
-  功能包括设备功能（如访问摄像头/麦克风、打电话、联网等）、应用功能（如弹出悬浮窗、创建快捷方式等）。
权限使用的基本原则
合理的使用场景有助于应用权限申请和使用。开发应用时权限申请需要满足如下原则：
-  应用（包括应用引用的三方库）所需权限必须在应用的配置文件中严格按照权限开发指导逐个声明。参考声明权限。
-  权限申请满足最小化原则，禁止申请非必要的、已废弃的权限。应用申请过多权限，会引起用户对应用安全性的担忧以及使用体验变差，从而也会影响到应用的安装率和留存率。
-  应用申请敏感权限时，必须填写权限使用理由字段，敏感权限通常是指与用户隐私密切相关的权限，包括地理位置、相机、麦克风、日历、健身运动、身体传感器、音乐、文件、图片视频等权限。参考向用户申请授权。
-  应用敏感权限须在对应业务功能执行前动态申请，满足隐私最小化要求。
-  用户拒绝授予某个权限后，应用与此权限无关的其他业务功能应允许正常使用。
授权方式
根据授权方式的不同，权限类型可分为system_grant（系统授权）和user_grant（用户授权）。
system_grant（系统授权）
system_grant指的是系统授权类型，在该类型的权限许可下，应用被允许访问的数据不会涉及到用户或设备的敏感信息，应用被允许执行的操作对系统或者其他应用产生的影响可控。
如果在应用中申请了system_grant权限，那么系统会在用户安装应用时，自动把相应权限授予给应用。
user_grant（用户授权）
user_grant指的是用户授权类型，在该类型的权限许可下，应用被允许访问的数据将会涉及到用户或设备的敏感信息，应用被允许执行的操作可能对系统或者其他应用产生严重的影响。
该类型权限不仅需要在安装包中申请权限，还需要在应用动态运行时，通过发送弹窗的方式请求用户授权。在用户手动允许授权后，应用才会真正获取相应权限，从而成功访问操作目标对象。
例如，在应用权限列表中，麦克风和摄像头对应的权限都是属于用户授权权限，列表中给出了详细的权限使用理由。应用需要在应用商店的详情页面，向用户展示所申请的user_grant权限列表。
权限组和子权限
为了尽可能减少系统弹出的权限弹窗数量，优化交互体验，系统将逻辑紧密相关的user_grant权限组合在一起，形成多个权限组。
当应用请求权限时，同一个权限组的权限将会在一个弹窗内一起请求用户授权。权限组中的某个权限，称之为该权限组的子权限。
权限组和权限的归属关系并不是固定不变的，一个权限所属的权限组有可能发生变化。当前系统支持权限组请查阅应用权限组列表。
权限机制中的基本概念
-  TokenID 系统采用TokenID（Token identity）作为应用的唯一标识。权限管理服务通过应用的TokenID来管理应用的AT（Access Token）信息，包括应用身份标识APP ID、子用户ID、应用分身索引信息、应用APL、应用权限授权状态等。在资源使用时，系统将通过TokenID作为唯一身份标识映射获取对应应用的权限授权状态信息，并依此进行鉴权，从而管控应用的资源访问行为。 值得注意的是，系统支持多用户特性和应用分身特性，同一个应用在不同的子用户下和不同的应用分身下会有各自的AT，这些AT的TokenID也是不同的。
-  APL等级 为了防止应用过度索取和滥用权限，系统基于APL（Ability Privilege Level，元能力权限等级）等级，配置了不同的权限开放范围。 元能力权限等级APL指的是应用的权限申请优先级的定义，不同APL等级的应用能够申请的权限等级不同。
-  应用APL等级 应用的等级可以分为以下三个等级，等级依次提高。 该等级的应用服务提供操作系统核心能力。 应用APL等级不允许配置为system_core。
-  权限APL等级 根据权限对于不同等级应用有不同的开放范围，权限类型对应分为以下三个等级，等级依次提高。 允许应用访问超出默认规则外的普通系统资源，如配置Wi-Fi信息、调用相机拍摄等。 这些系统资源的开放（包括数据和功能）对用户隐私以及其他应用带来的风险低。 允许应用访问操作系统基础服务（系统提供或者预置的基础功能）相关的资源，如系统设置、身份认证等。 这些系统资源的开放对用户隐私以及其他应用带来的风险较高。 - APL等级为system_basic及以上的应用。 - 部分权限对normal级别的应用受限开放，这部分权限在本指导中描述为“受限开放权限”。 - APL等级为system_core的应用。 - 仅对系统应用开放。
-  访问控制列表（ACL） 如上所述，权限APL等级和应用APL等级是一一对应的。原则上，拥有低APL等级的应用默认无法申请更高等级的权限。访问控制列表ACL（Access Control List）提供了解决低等级应用访问高等级权限问题的特殊渠道。 系统权限均定义了“ACL使能”字段，当该权限的ACL使能为TRUE，应用可以使用ACL方式跨级别申请该权限。具体单个权限的定义，可参考受限开放权限。 场景举例：如开发者正在开发APL等级为normal的A应用，由于功能场景需要，A应用需要申请等级为system_basic的P权限。在P权限的ACL使能为TRUE的情况下，A应用可以通过ACL方式跨级申请权限P。
| APL级别 | 说明 |
| --- | --- |
| normal | 默认情况下，应用的APL等级都为normal等级。 |
| system_basic | 该等级的应用服务提供系统基础服务。 |
| system_core | 该等级的应用服务提供操作系统核心能力。 应用APL等级不允许配置为system_core。  |
| APL级别 | 说明 | 开放范围 |
| --- | --- | --- |
| normal | 允许应用访问超出默认规则外的普通系统资源，如配置Wi-Fi信息、调用相机拍摄等。 这些系统资源的开放（包括数据和功能）对用户隐私以及其他应用带来的风险低。  | APL等级为normal及以上的应用。 |
| system_basic | 允许应用访问操作系统基础服务（系统提供或者预置的基础功能）相关的资源，如系统设置、身份认证等。 这些系统资源的开放对用户隐私以及其他应用带来的风险较高。  | - APL等级为system_basic及以上的应用。 - 部分权限对normal级别的应用受限开放，这部分权限在本指导中描述为“受限开放权限”。  |
| system_core | 涉及开放操作系统核心资源的访问操作。这部分系统资源是系统最核心的底层服务，如果遭受破坏，操作系统将无法正常运行。 | - APL等级为system_core的应用。 - 仅对系统应用开放。  |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/request-app-permissions-V14
爬取时间: 2025-04-28 01:19:39
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/determine-application-mode-V14
爬取时间: 2025-04-28 01:19:53
来源: Huawei Developer
应用在访问数据或者执行操作时，需要评估该行为是否需要应用具备相关的权限。如果确认需要目标权限，则需要在应用安装包中申请目标权限。
每一个权限的权限等级、授权方式不同，申请权限的方式也不同，开发者在申请权限前，需要先根据以下流程判断应用能否申请目标权限。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170426.86845878619058672232862884373627:50001231000000:2800:8A8184108184FBB128E3B3C4CAC9F9115D687DA2C9559B3ACE269C68B9C1AC89.png)
上图的数字标注，请参考以下说明：
-  标注1：应用APL等级与权限等级的匹配关系请参考APL等级说明。
-  标注2：权限的授权方式分为user_grant（用户授权）和system_grant（系统授权），具体请参考授权方式说明。
-  标注3：应用可以通过ACL（访问控制列表）方式申请高级别的权限，具体请参考申请使用受限权限。
应用可根据目标权限的开放范围、授权方式，参考以下操作路径申请对应权限。
应用申请权限的方式
| 权限类型 | 授权方式 | 操作路径 |
| --- | --- | --- |
| 开放权限（系统授权） | system_grant | 声明权限 > 访问接口 |
| 开放权限（用户授权） | user_grant | 声明权限 > 向用户申请授权 > 访问接口 |
| 受限开放权限 | system_grant | 申请使用受限权限 > 声明权限 > 访问接口 |
| 受限开放权限 | user_grant | 申请使用受限权限 > 声明权限 > 向用户申请授权 > 访问接口 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/declare-permissions-V14
爬取时间: 2025-04-28 01:20:08
来源: Huawei Developer
应用在申请权限时，需要在项目的配置文件中，逐个声明需要的权限，否则应用将无法获取授权。
在配置文件中声明权限
应用需要在module.json5配置文件的requestPermissions标签中声明权限。
| 属性 | 含义 | 数据类型 | 取值范围 |
| --- | --- | --- | --- |
| name | 需要使用的权限名称。 | 字符串 | 必填，需为系统已定义的权限，取值范围请参考应用权限列表。 |
| reason | 申请权限的原因。 | 字符串 | 可选填写，该字段用于应用上架校验，当申请的权限为user_grant权限时必填，并且需要进行多语种适配。 使用string类资源引用。格式为$string: ***。 可参考权限使用理由的文案内容规范。  |
| usedScene | 权限使用的场景，该字段用于应用上架校验。包括abilities和when两个子项。 - abilities：使用权限的UIAbility或者ExtensionAbility组件的名称。 - when：调用时机。  | 对象 | usedScene必填。 - abilities：可选填写，可以配置为多个UIAbility或者ExtensionAbility名称的字符串数组。 - when：可选填写，但如果配置此字段，只能填入固定值inuse（使用时）、always（始终），不能为空。 当申请的权限为user_grant权限时建议填写。  |
可选填写，该字段用于应用上架校验，当申请的权限为user_grant权限时必填，并且需要进行多语种适配。
使用string类资源引用。格式为$string: ***。
可参考权限使用理由的文案内容规范。
权限使用的场景，该字段用于应用上架校验。包括abilities和when两个子项。
- abilities：使用权限的UIAbility或者ExtensionAbility组件的名称。
- when：调用时机。
usedScene必填。
- abilities：可选填写，可以配置为多个UIAbility或者ExtensionAbility名称的字符串数组。
- when：可选填写，但如果配置此字段，只能填入固定值inuse（使用时）、always（始终），不能为空。
当申请的权限为user_grant权限时建议填写。
已在子模块中申请的权限，无需在主项目重复添加，权限将在整个应用生效。
声明样例
以下"ohos.permission.PERMISSION1"、"ohos.permission.PERMISSION2"仅为样例示意，不存在该权限。请开发者根据实际需要，参照上表要求填写对应属性。
```json
{
"module" : {
// ...
"requestPermissions":[
{
"name" : "ohos.permission.PERMISSION1",
"reason": "$string:reason",
"usedScene": {
"abilities": [
"FormAbility"
],
"when":"inuse"
}
},
{
"name" : "ohos.permission.PERMISSION2",
"reason": "$string:reason",
"usedScene": {
"abilities": [
"FormAbility"
],
"when":"always"
}
}
]
}
}
```
权限使用理由的文案内容规范
当申请的权限为user_grant权限时，字段reason（申请权限的原因）必填。开发者需要在应用配置文件中，配置每一个需要使用的权限。
但在实际向用户弹窗申请授权时，user_grant权限将会以权限组的形式向用户申请。当前支持的权限组请查看应用权限组列表。
reason字段的内容写作规范及建议
1.  字串应为直白、具体、易理解的完整短句， 用于向用户说明应用使用敏感权限的理由。句子避免使用被动语态，并以句号结尾。 建议句式：用于做某事。 样例：以申请相机权限的reason字符串为例。 正例：用于视频通话。 反例：使用相机。
2.  建议句式：用于做某事。
3.  样例：以申请相机权限的reason字符串为例。 正例：用于视频通话。 反例：使用相机。
4.  用途描述的字串建议小于72个字符（即36个中文字符，UI界面显示大约为两行）。不能超过256个字符，以保证多语言适配的体验。
5.  字串不能为空白字符串，即不能不填，也不能只填空格符。
6.  如果应用申请的权限用于多个场景，需要确保字串的完整性，让用户了解应用使用此权限的所有场景；多个HAP包内如果申请同一个权限，各个权限Reason字段需要保持场景的完整性和一致性。 样例： 应用中有2个HAP包，均需申请使用相机权限，其中HAP1提供功能场景为视频通话、HAP2提供功能场景为视频直播。 正例：HAP1和HAP2中，相机权限的使用理由都填写为“用于视频通话、视频直播功能。” 反例1：HAP1和HAP2中，相机权限的使用理由字段未保持完全一致。如HAP1中填写为“用于视频通话功能。”，HAP2中填写为“用于视频直播功能。” 反例2：HAP1和HAP2中，相机权限的使用理由字段保持完全一致，但是描述不全面，如HAP1和HAP2中，相机权限的使用理由都填写为“用于视频通话功能。”。
-  建议句式：用于做某事。
-  样例：以申请相机权限的reason字符串为例。 正例：用于视频通话。 反例：使用相机。
权限使用理由展示方式
权限使用理由有两个展示途径：授权弹窗界面和“设置（Settings）”界面。“设置”的具体路径：设置-隐私-权限管理-某应用某权限详情。
1.  如果是申请“电话、信息、日历、通讯录、通话记录”这五个权限组中的权限，根据工信部要求，将展示具体子权限的内容与用途。 句式：包括子权限A和子权限B，用于某事。 样例：用于获取通话状态和移动网络信息，用于安全运营和统计计费服务。
2.  如果是申请其他权限组中的权限，系统将使用权限组内当前被申请的第一个子权限的使用理由，作为该权限组的使用理由进行展示。组内的排序，固定按照权限管理内排列的权限组数组顺序。 举例说明：权限组A = {权限A, 权限B, 权限C}；申请传入的权限是{权限C, 权限B}，界面将展示权限B的权限使用理由。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/request-user-authorization-V14
爬取时间: 2025-04-28 01:20:22
来源: Huawei Developer
当应用需要访问用户的隐私信息或使用系统能力时，例如获取位置信息、访问日历、使用相机拍摄照片或录制视频等，应该向用户请求授权，这部分权限是user_grant权限。
当应用申请user_grant权限时，需要完成以下步骤：
1.  在配置文件中，声明应用需要请求的权限。
2.  将应用中需要申请权限的目标对象与对应目标权限进行关联，让用户明确地知道，哪些操作需要用户向应用授予指定的权限。 以上两步请参考章节声明权限完成。
3.  运行应用时，在用户触发访问操作目标对象时应该调用接口，精准触发动态授权弹框。该接口的内部会检查当前用户是否已经授权应用所需的权限，如果当前用户尚未授予应用所需的权限，该接口会拉起动态授权弹框，向用户请求授权。
4.  检查用户的授权结果，确认用户已授权才可以进行下一步操作。
本章节会介绍如何完成步骤3和4。
约束与限制
-  每次执行需要目标权限的操作时，应用都必须检查自己是否已经具有该权限。 如需检查用户是否已向您的应用授予特定权限，可以使用checkAccessToken()函数，此方法会返回PERMISSION_GRANTED或PERMISSION_DENIED。具体示例可参考下文。
-  每次访问受目标权限保护的接口之前，都需要使用requestPermissionsFromUser()接口请求相应的权限。 用户可能在动态授予权限后通过系统设置来取消应用的权限，因此不能将之前授予的授权状态持久化。
-  user_grant权限授权要基于用户可知可控的原则，需要应用在运行时主动调用系统动态申请权限的接口，系统弹框由用户授权，用户结合应用运行场景的上下文，识别出应用申请相应敏感权限的合理性，从而做出正确的选择。
-  系统不鼓励频繁弹窗打扰用户，如果用户拒绝授权，将无法再次拉起弹窗，需要应用引导用户在系统应用“设置”的界面中手动授予权限。
-  系统权限弹窗不可被遮挡。 系统权限弹窗不可被其他组件/控件遮挡，弹窗信息需要完整展示，以便用户识别并完成授权动作。 如果系统权限弹窗与其他组件/控件同时同位置展示，系统权限弹窗将默认覆盖其他组件/控件。
开发步骤
以申请使用位置权限为例进行说明。
效果展示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170426.08729133564056547386869349051863:50001231000000:2800:5D84E666FDE406FC99038F2E20EB7052A7742262EF79332089707B23AB2B2442.png)
1.  申请ohos.permission.LOCATION、ohos.permission.APPROXIMATELY_LOCATION权限，配置方式请参见声明权限。
2.  校验当前是否已经授权。 在进行权限申请之前，需要先检查当前应用程序是否已经被授予权限。可以通过调用checkAccessToken()方法来校验当前是否已经授权。如果已经授权，则可以直接访问目标操作，否则需要进行下一步操作，即向用户申请授权。
```typescript
import { abilityAccessCtrl, bundleManager, Permissions } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
async function checkPermissionGrant(permission: Permissions): Promise<abilityAccessCtrl.GrantStatus> {
let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();
let grantStatus: abilityAccessCtrl.GrantStatus = abilityAccessCtrl.GrantStatus.PERMISSION_DENIED;
// 获取应用程序的accessTokenID
let tokenId: number = 0;
try {
let bundleInfo: bundleManager.BundleInfo = await bundleManager.getBundleInfoForSelf(bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION);
let appInfo: bundleManager.ApplicationInfo = bundleInfo.appInfo;
tokenId = appInfo.accessTokenId;
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to get bundle info for self. Code is ${err.code}, message is ${err.message}`);
}
// 校验应用是否被授予权限
try {
grantStatus = await atManager.checkAccessToken(tokenId, permission);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to check access token. Code is ${err.code}, message is ${err.message}`);
}
return grantStatus;
}
async function checkPermissions(): Promise<void> {
let grantStatus1: boolean = await checkPermissionGrant('ohos.permission.LOCATION') === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED;// 获取精确定位权限状态
let grantStatus2: boolean = await checkPermissionGrant('ohos.permission.APPROXIMATELY_LOCATION') === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED;// 获取模糊定位权限状态
// 精确定位权限只能跟模糊定位权限一起申请，或者已经有模糊定位权限才能申请精确定位权限
if (grantStatus2 && !grantStatus1) {
// 申请精确定位权限
} else if (!grantStatus1 && !grantStatus2) {
// 申请模糊定位权限与精确定位权限或单独申请模糊定位权限
} else {
// 已经授权，可以继续访问目标操作
}
}
```
3.  动态向用户申请授权。 动态向用户申请权限是指在应用程序运行时向用户请求授权的过程。可以通过调用requestPermissionsFromUser()方法来实现。该方法接收一个权限列表参数，例如位置、日历、相机、麦克风等。用户可以选择授予权限或者拒绝授权。 可以在UIAbility的onWindowStageCreate()回调中调用requestPermissionsFromUser()方法来动态申请权限，也可以根据业务需要在UI中向用户申请授权。 应用在onWindowStageCreate()回调中申请授权时，需要等待异步接口loadContent()/setUIContent()执行结束后或在loadContent()/setUIContent()回调中调用requestPermissionsFromUser()，否则在Content加载完成前，requestPermissionsFromUser会调用失败。 应用在UIExtensionAbility申请授权时，需要在onWindowStageCreate函数执行结束后或在onWindowStageCreate函数回调中调用requestPermissionsFromUser()，否则在ability加载完成前，requestPermissionsFromUser会调用失败。 在UIAbility中向用户申请授权。 在UI中向用户申请授权。
```typescript
// 使用UIExtensionAbility：将import { UIAbility } from '@kit.AbilityKit' 替换为import { UIExtensionAbility } from '@kit.AbilityKit';
import { abilityAccessCtrl, common, Permissions, UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
const permissions: Array<Permissions> = ['ohos.permission.LOCATION','ohos.permission.APPROXIMATELY_LOCATION'];
// 使用UIExtensionAbility：将common.UIAbilityContext 替换为common.UIExtensionContext
function reqPermissionsFromUser(permissions: Array<Permissions>, context: common.UIAbilityContext): void {
let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();
// requestPermissionsFromUser会判断权限的授权状态来决定是否唤起弹窗
atManager.requestPermissionsFromUser(context, permissions).then((data) => {
let grantStatus: Array<number> = data.authResults;
let length: number = grantStatus.length;
for (let i = 0; i < length; i++) {
if (grantStatus[i] === 0) {
// 用户授权，可以继续访问目标操作
} else {
// 用户拒绝授权，提示用户必须授权才能访问当前页面的功能，并引导用户到系统设置中打开相应的权限
return;
}
}
// 授权成功
}).catch((err: BusinessError) => {
console.error(`Failed to request permissions from user. Code is ${err.code}, message is ${err.message}`);
})
}
// 使用UIExtensionAbility：将 UIAbility 替换为UIExtensionAbility
export default class EntryAbility extends UIAbility {
onWindowStageCreate(windowStage: window.WindowStage): void {
// ...
windowStage.loadContent('pages/Index', (err, data) => {
reqPermissionsFromUser(permissions, this.context);
// ...
});
}
// ...
}
```
4.  在UIAbility中向用户申请授权。
```typescript
// 使用UIExtensionAbility：将import { UIAbility } from '@kit.AbilityKit' 替换为import { UIExtensionAbility } from '@kit.AbilityKit';
import { abilityAccessCtrl, common, Permissions, UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
const permissions: Array<Permissions> = ['ohos.permission.LOCATION','ohos.permission.APPROXIMATELY_LOCATION'];
// 使用UIExtensionAbility：将common.UIAbilityContext 替换为common.UIExtensionContext
function reqPermissionsFromUser(permissions: Array<Permissions>, context: common.UIAbilityContext): void {
let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();
// requestPermissionsFromUser会判断权限的授权状态来决定是否唤起弹窗
atManager.requestPermissionsFromUser(context, permissions).then((data) => {
let grantStatus: Array<number> = data.authResults;
let length: number = grantStatus.length;
for (let i = 0; i < length; i++) {
if (grantStatus[i] === 0) {
// 用户授权，可以继续访问目标操作
} else {
// 用户拒绝授权，提示用户必须授权才能访问当前页面的功能，并引导用户到系统设置中打开相应的权限
return;
}
}
// 授权成功
}).catch((err: BusinessError) => {
console.error(`Failed to request permissions from user. Code is ${err.code}, message is ${err.message}`);
})
}
// 使用UIExtensionAbility：将 UIAbility 替换为UIExtensionAbility
export default class EntryAbility extends UIAbility {
onWindowStageCreate(windowStage: window.WindowStage): void {
// ...
windowStage.loadContent('pages/Index', (err, data) => {
reqPermissionsFromUser(permissions, this.context);
// ...
});
}
// ...
}
```
5.  在UI中向用户申请授权。
```typescript
import { abilityAccessCtrl, common, Permissions } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
const permissions: Array<Permissions> = ['ohos.permission.LOCATION','ohos.permission.APPROXIMATELY_LOCATION'];
// 使用UIExtensionAbility：将common.UIAbilityContext 替换为common.UIExtensionContext
function reqPermissionsFromUser(permissions: Array<Permissions>, context: common.UIAbilityContext): void {
let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();
// requestPermissionsFromUser会判断权限的授权状态来决定是否唤起弹窗
atManager.requestPermissionsFromUser(context, permissions).then((data) => {
let grantStatus: Array<number> = data.authResults;
let length: number = grantStatus.length;
for (let i = 0; i < length; i++) {
if (grantStatus[i] === 0) {
// 用户授权，可以继续访问目标操作
} else {
// 用户拒绝授权，提示用户必须授权才能访问当前页面的功能，并引导用户到系统设置中打开相应的权限
return;
}
}
// 授权成功
}).catch((err: BusinessError) => {
console.error(`Failed to request permissions from user. Code is ${err.code}, message is ${err.message}`);
})
}
@Entry
@Component
struct Index {
aboutToAppear() {
// 使用UIExtensionAbility：将common.UIAbilityContext 替换为common.UIExtensionContext
const context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
reqPermissionsFromUser(permissions, context);
}
build() {
// ...
}
}
```
6.  处理授权结果。 调用requestPermissionsFromUser()方法后，应用程序将等待用户授权的结果。如果用户授权，则可以继续访问目标操作。如果用户拒绝授权，则需要提示用户必须授权才能访问当前页面的功能，并引导用户到系统应用“设置”中打开相应的权限。 路径：设置 > 隐私 > 权限管理 > 应用 > 目标应用
-  在UIAbility中向用户申请授权。
```typescript
// 使用UIExtensionAbility：将import { UIAbility } from '@kit.AbilityKit' 替换为import { UIExtensionAbility } from '@kit.AbilityKit';
import { abilityAccessCtrl, common, Permissions, UIAbility } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
const permissions: Array<Permissions> = ['ohos.permission.LOCATION','ohos.permission.APPROXIMATELY_LOCATION'];
// 使用UIExtensionAbility：将common.UIAbilityContext 替换为common.UIExtensionContext
function reqPermissionsFromUser(permissions: Array<Permissions>, context: common.UIAbilityContext): void {
let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();
// requestPermissionsFromUser会判断权限的授权状态来决定是否唤起弹窗
atManager.requestPermissionsFromUser(context, permissions).then((data) => {
let grantStatus: Array<number> = data.authResults;
let length: number = grantStatus.length;
for (let i = 0; i < length; i++) {
if (grantStatus[i] === 0) {
// 用户授权，可以继续访问目标操作
} else {
// 用户拒绝授权，提示用户必须授权才能访问当前页面的功能，并引导用户到系统设置中打开相应的权限
return;
}
}
// 授权成功
}).catch((err: BusinessError) => {
console.error(`Failed to request permissions from user. Code is ${err.code}, message is ${err.message}`);
})
}
// 使用UIExtensionAbility：将 UIAbility 替换为UIExtensionAbility
export default class EntryAbility extends UIAbility {
onWindowStageCreate(windowStage: window.WindowStage): void {
// ...
windowStage.loadContent('pages/Index', (err, data) => {
reqPermissionsFromUser(permissions, this.context);
// ...
});
}
// ...
}
```
-  在UI中向用户申请授权。
```typescript
import { abilityAccessCtrl, common, Permissions } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
const permissions: Array<Permissions> = ['ohos.permission.LOCATION','ohos.permission.APPROXIMATELY_LOCATION'];
// 使用UIExtensionAbility：将common.UIAbilityContext 替换为common.UIExtensionContext
function reqPermissionsFromUser(permissions: Array<Permissions>, context: common.UIAbilityContext): void {
let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();
// requestPermissionsFromUser会判断权限的授权状态来决定是否唤起弹窗
atManager.requestPermissionsFromUser(context, permissions).then((data) => {
let grantStatus: Array<number> = data.authResults;
let length: number = grantStatus.length;
for (let i = 0; i < length; i++) {
if (grantStatus[i] === 0) {
// 用户授权，可以继续访问目标操作
} else {
// 用户拒绝授权，提示用户必须授权才能访问当前页面的功能，并引导用户到系统设置中打开相应的权限
return;
}
}
// 授权成功
}).catch((err: BusinessError) => {
console.error(`Failed to request permissions from user. Code is ${err.code}, message is ${err.message}`);
})
}
@Entry
@Component
struct Index {
aboutToAppear() {
// 使用UIExtensionAbility：将common.UIAbilityContext 替换为common.UIExtensionContext
const context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
reqPermissionsFromUser(permissions, context);
}
build() {
// ...
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/request-user-authorization-second-V14
爬取时间: 2025-04-28 01:20:37
来源: Huawei Developer
当应用通过requestPermissionsFromUser()拉起弹框请求用户授权时，用户拒绝授权。应用将无法再次通过requestPermissionsFromUser拉起弹框，需要用户在系统应用“设置”的界面中，手动授予权限。
在“设置”应用中的路径：
应用也可以通过调用requestPermissionOnSetting()，直接拉起权限设置弹框，引导用户授予权限。
效果展示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170427.24313849915222645925079161520871:50001231000000:2800:E9AF0A6BEBCDD16FC0777C1C1A3B753911F9BB75782518BF056250FEB4145B56.png)
以下示例代码以再次拉起弹窗申请ohos.permission.APPROXIMATELY_LOCATION权限为例。
```typescript
import { abilityAccessCtrl, Context, common } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();
let context: Context = getContext(this) as common.UIAbilityContext;
atManager.requestPermissionOnSetting(context, ['ohos.permission.APPROXIMATELY_LOCATION']).then((data: Array<abilityAccessCtrl.GrantStatus>) => {
console.info('data:' + JSON.stringify(data));
}).catch((err: BusinessError) => {
console.error('data:' + JSON.stringify(err));
});
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/one-time-authorization-V14
爬取时间: 2025-04-28 01:20:51
来源: Huawei Developer
基于授权最小化的原则，防止应用获取和滥用用户数据，针对部分应用敏感权限，在弹窗向用户申请授权时，新增“允许本次使用”的授权选项。
开发者在开发应用时，无需额外配置，仍然调用requestPermissionsFromUser()向用户申请授权，系统会根据该能力支持的权限，弹出对应的弹窗。
授权弹窗如下图所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170427.93261638692046520241156895287759:50001231000000:2800:4621CCB327392DE4D89451E40FEE7CEE6A35C00E6FAFED23F44756C348C8FC1B.png)
同时，用户可以在“设置”中修改授权。修改路径：设置 > 隐私 > 权限管理 > 应用 > 目标应用 > 位置信息
支持范围
当前仅支持下列权限，当应用向用户申请下列权限时，弹窗将会出现“允许本次使用”的授权选项，设置中修改权限将会出现“每次询问”授权选项。
使用限制
-  当用户点击了“允许本次使用”按钮，将会对应用授予临时的权限。 当应用切换至前台、应用展开卡片且处于当前屏幕可见即卡片可见或者设置后台长时任务的时候(当前仅支持定位导航长时任务)，应用的临时权限会一直保持。 其他情况下启动计时器，十秒之后，取消临时权限，想要再次获取，需要重新授予。 当应用切了后台，开始十秒计时，如果在计时期间，应用处于卡片可见下或者设置了后台长时任务，计时停止。 直到卡片不可见或者长时任务结束，再次开启十秒计时，计时结束之后，取消临时授权。 如下图样例所示，小艺建议处于卡片可见状态：
-  当应用切换至前台、应用展开卡片且处于当前屏幕可见即卡片可见或者设置后台长时任务的时候(当前仅支持定位导航长时任务)，应用的临时权限会一直保持。 其他情况下启动计时器，十秒之后，取消临时权限，想要再次获取，需要重新授予。
-  当应用切了后台，开始十秒计时，如果在计时期间，应用处于卡片可见下或者设置了后台长时任务，计时停止。 直到卡片不可见或者长时任务结束，再次开启十秒计时，计时结束之后，取消临时授权。 如下图样例所示，小艺建议处于卡片可见状态：
-  当用户在权限设置中选择了“每次询问”按钮，将会对应用授予模糊位置与位置临时权限，取消临时授权同上。
-  当应用切换至前台、应用展开卡片且处于当前屏幕可见即卡片可见或者设置后台长时任务的时候(当前仅支持定位导航长时任务)，应用的临时权限会一直保持。 其他情况下启动计时器，十秒之后，取消临时权限，想要再次获取，需要重新授予。
-  当应用切了后台，开始十秒计时，如果在计时期间，应用处于卡片可见下或者设置了后台长时任务，计时停止。 直到卡片不可见或者长时任务结束，再次开启十秒计时，计时结束之后，取消临时授权。 如下图样例所示，小艺建议处于卡片可见状态：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170427.26014383528115666867227430415539:50001231000000:2800:2444359C897E8C0815ED3C3BCBD1A23720128AC2BCC536EFDBAB9F947A240E0B.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/declare-permissions-in-acl-V14
爬取时间: 2025-04-28 01:21:05
来源: Huawei Developer
受限开放的权限通常是不允许三方应用申请的。如果有特殊场景需要使用，请提供相关申请材料到应用市场（AppGallery Connect，简称为AGC）申请相应权限证书。
在申请前，请审视是否符合受限权限的使用场景。为避免应用的上架申请被驳回，开发者应优先使用Picker/控件等替代方案，仅少量符合特殊场景的应用被允许申请受限权限。
每个受限权限的介绍、可用场景及其建议方案请参考受限开放权限列表。
在应用上架时，应用市场（AGC）将根据应用的使用场景审核是否可以使用对应的受限权限。如检测到应用软件包涉及获取受限权限，应用开发者需为每个受限权限项填写相应的权限说明，并上传视频说明使用场景，详情请见发布HarmonyOS应用。
如果应用未申请相应的权限证书，却试图在配置文件中声明此类权限，将会导致应用安装失败。
申请步骤
在AGC侧申请Profile文件
申请的Profile文件，将用于后续的应用签名信息配置。
应用因特殊场景要求使用受限开放权限，请务必在申请发布Profile“添加Profile页面”时，申请使用相应权限，否则应用将在审核时被驳回。受限开放权限可申请的特殊场景请参考受限开放权限列表。
申请Profile的步骤请参考：申请发布Profile
在代码工程中申请权限
在AGC侧完成上述配置后，开发者还需要根据实际情况在工程中声明权限。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/app-permissions-V14
爬取时间: 2025-04-28 01:21:19
来源: Huawei Developer
根据权限的开放范围和授权方式不同，申请对应权限的的方式也不同。
系统当前存在以下权限列表，开发者可根据实际需求进行检索，并确定对应权限的申请方式。
-  开放权限（系统授权） 所有应用可申请。应用申请了此类权限后，系统将在用户安装应用时，自动把相应权限授予给应用。
-  开放权限（用户授权） 所有应用可申请。应用申请了此类权限后，还需要在应用动态运行时，通过发送弹窗的方式请求用户授权。
-  企业类应用可用权限 仅面向企业普通应用、MDM应用开放。分发类型（app-distribution-type）为enterprise_normal（企业普通应用）、enterprise_mdm（MDM应用）的应用可申请。应用在申请时，需确认其授权方式，按照合适的方式申请。
-  MDM应用可用权限 仅MDM应用可申请。应用在申请时，需确认其授权方式，按照合适的方式申请。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/permissions-for-all-V14
爬取时间: 2025-04-28 01:21:32
来源: Huawei Developer
此列表内所有权限均为系统授权（system_grant）的开放权限，面向所有应用开放。
应用申请了system_grant权限后，系统将在用户安装应用时，自动把相应权限授予给应用。
申请方式
以下权限的授权方式均为system_grant，申请方式请参考声明权限。
ohos.permission.USE_BLUETOOTH
允许应用查看蓝牙的配置。
权限级别：normal
授权方式：system_grant
起始版本：8
ohos.permission.GET_BUNDLE_INFO
允许查询应用的基本信息。
权限级别：normal
授权方式：system_grant
起始版本：7
ohos.permission.PREPARE_APP_TERMINATE
允许应用关闭前执行自定义的预关闭动作。
权限级别：normal
授权方式：system_grant
起始版本：10
ohos.permission.PRINT
允许应用获取打印框架的能力。
权限级别：normal
授权方式：system_grant
起始版本：10
ohos.permission.DISCOVER_BLUETOOTH
允许应用配置本地蓝牙，查找远端设备且与之配对连接。
权限级别：normal
授权方式：system_grant
起始版本：8
ohos.permission.ACCELEROMETER
允许应用读取加速度传感器的数据。
权限级别：normal
授权方式：system_grant
起始版本：7
ohos.permission.ACCESS_BIOMETRIC
允许应用使用生物特征识别能力进行身份认证。
权限级别：normal
授权方式：system_grant
起始版本：6
ohos.permission.ACCESS_NOTIFICATION_POLICY
在本设备上允许应用访问通知策略。
仅当控制铃声从静音到非静音时，需要申请该权限。
权限级别：normal
授权方式：system_grant
起始版本：7
ohos.permission.GET_NETWORK_INFO
允许应用获取数据网络信息。
权限级别：normal
授权方式：system_grant
起始版本：8
ohos.permission.GET_WIFI_INFO
允许应用获取Wi-Fi信息。
权限级别：normal
授权方式：system_grant
起始版本：8
ohos.permission.GYROSCOPE
允许应用读取陀螺仪传感器的数据。
权限级别：normal
授权方式：system_grant
起始版本：7
ohos.permission.INTERNET
允许使用Internet网络。
权限级别：normal
授权方式：system_grant
起始版本：9
ohos.permission.KEEP_BACKGROUND_RUNNING
允许Service Ability在后台持续运行。
权限级别：normal
授权方式：system_grant
起始版本：8
ohos.permission.NFC_CARD_EMULATION
允许应用实现卡模拟功能。
权限级别：normal
授权方式：system_grant
起始版本：8
ohos.permission.NFC_TAG
允许应用读写Tag卡片。
权限级别：normal
授权方式：system_grant
起始版本：7
ohos.permission.PRIVACY_WINDOW
允许应用将窗口设置为隐私窗口，禁止截屏录屏。
权限级别：API version 9-10为system_basic；从API version 11开始为normal。
授权方式：system_grant
起始版本：9
ohos.permission.PUBLISH_AGENT_REMINDER
允许该应用使用后台代理提醒。
权限级别：normal
授权方式：system_grant
起始版本：7
ohos.permission.SET_WIFI_INFO
允许应用配置Wi-Fi设备。
权限级别：normal
授权方式：system_grant
起始版本：8
ohos.permission.VIBRATE
允许应用控制马达振动。
权限级别：normal
授权方式：system_grant
起始版本：7
ohos.permission.CLEAN_BACKGROUND_PROCESSES
允许应用根据包名清理相关后台进程。
权限级别：normal
授权方式：system_grant
起始版本：7
ohos.permission.COMMONEVENT_STICKY
允许应用发布粘性公共事件。
权限级别：normal
授权方式：system_grant
起始版本：7
ohos.permission.MODIFY_AUDIO_SETTINGS
允许应用修改音频设置。
权限级别：normal
授权方式：system_grant
起始版本：8
ohos.permission.RUNNING_LOCK
允许应用获取运行锁，保证应用在后台的持续运行。
权限级别：normal
授权方式：system_grant
起始版本：7
ohos.permission.SET_WALLPAPER
允许应用设置壁纸。
权限级别：normal
授权方式：system_grant
起始版本：7
ohos.permission.ACCESS_CERT_MANAGER
允许应用进行查询证书及私有凭据等操作。
权限级别：normal
授权方式：system_grant
起始版本：9
ohos.permission.hsdr.HSDR_ACCESS
允许应用访问安全检测与响应框架。
权限级别：normal
授权方式：system_grant
起始版本：10
ohos.permission.RUN_DYN_CODE
允许系统方舟运行时引擎在受限模式下执行动态下发的方舟字节码。
该权限相关的API均为系统API，仅部分特定系统应用可申请该权限。
权限级别：normal
授权方式：system_grant
起始版本：11
ohos.permission.READ_CLOUD_SYNC_CONFIG
允许接入云空间的应用查询应用云同步相关配置信息。
权限级别：normal
授权方式：system_grant
起始版本：11
ohos.permission.STORE_PERSISTENT_DATA
允许应用存储持久化的数据，该数据直到设备恢复出厂设置或重装系统才会被清除。
权限级别: normal
授权方式：system_grant
起始版本: 11
ohos.permission.ACCESS_EXTENSIONAL_DEVICE_DRIVER
允许应用使用外接设备增强功能。
权限级别: normal
授权方式：system_grant
起始版本：11
ohos.permission.READ_ACCOUNT_LOGIN_STATE
允许应用读取用户账号的登录状态。
权限级别：normal
授权方式：system_grant
起始版本：12
ohos.permission.ACCESS_SERVICE_NAVIGATION_INFO
允许应用访问导航信息服务。
权限级别：normal
授权方式：system_grant
起始版本：12
ohos.permission.PROTECT_SCREEN_LOCK_DATA
允许应用在锁屏后保护本应用敏感数据不被访问。
应用获取此权限后，系统将给用户新建一个高安全级别el5的目录。应用可以在此目录下存放数据，这部分数据在锁屏后无法被访问。
权限级别：normal
授权方式：system_grant
起始版本：12
ohos.permission.FILE_ACCESS_PERSIST
允许应用支持持久化访问文件Uri。
该权限级别发生变更，为保证兼容性，在当前版本请继续采用受限权限申请方式申请使用该权限。
权限级别：API version 11为system_basic; 从API version 12开始为normal。
授权方式：system_grant
起始版本：11
ohos.permission.ACCESS_CAR_DISTRIBUTED_ENGINE
允许应用访问出行分布式业务引擎。
权限级别：normal
授权方式：system_grant
起始版本：12
ohos.permission.WINDOW_TOPMOST
允许应用将窗口设置为应用置顶窗口。
权限级别：normal
授权方式：system_grant
起始版本：13

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/permissions-for-all-user-V14
爬取时间: 2025-04-28 01:21:46
来源: Huawei Developer
此列表内所有权限均为用户授权（user_grant）的开放权限，面向所有应用开放。
该类型权限不仅需要在安装包中申请权限，还需要在应用动态运行时，通过发送弹窗的方式请求用户授权。在用户手动允许授权后，应用才会真正获取相应权限，从而成功访问操作目标对象。
申请方式
以下权限的授权方式均为user_grant（用户授权），申请方式请参考声明权限>向用户申请授权。
ohos.permission.ACCESS_BLUETOOTH
允许应用接入蓝牙并使用蓝牙能力，例如配对、连接外围设备等。
权限级别：normal
授权方式：user_grant
起始版本：10
ohos.permission.MEDIA_LOCATION
允许应用访问用户媒体文件中的地理位置信息。
权限级别：normal
授权方式：user_grant
起始版本：7
ohos.permission.APP_TRACKING_CONSENT
允许应用读取开放匿名设备标识符。
权限级别：normal
授权方式：user_grant
起始版本：9
ohos.permission.ACTIVITY_MOTION
允许应用读取用户的运动状态。
权限级别：normal
授权方式：user_grant
起始版本：7
ohos.permission.CAMERA
允许应用使用相机。
权限级别：normal
授权方式：user_grant
起始版本：9
ohos.permission.DISTRIBUTED_DATASYNC
允许不同设备间的数据交换。
权限级别：normal
授权方式：user_grant
起始版本：7
ohos.permission.LOCATION_IN_BACKGROUND
允许应用在后台运行时获取设备位置信息。
由于安全隐私要求，应用不能通过弹窗的形式被授予后台位置权限，应用如果需要使用后台位置权限，需要引导用户到设置界面手动授予。
申请流程：
1.  在“module.json5”配置文件中声明权限。 由于在申请后台权限前，必须先申请前台位置权限，因此开发者在配置时，应同时配置后台位置权限ohos.permission.LOCATION_IN_BACKGROUND和前台位置权限。前台位置权限的申请有两种允许情况：
2.  应用需通过弹窗向用户申请对应的前台位置权限。
3.  当用户点击弹窗授予前台位置权限后，应用应通过弹窗、提示窗等形式告知用户前往设置界面授予后台位置权限。
4.  用户在设置界面中的选择“始终允许”应用访问位置信息权限，完成手动授予。 设置路径：
权限级别：normal
授权方式：user_grant
起始版本：7
ohos.permission.LOCATION
允许应用获取设备位置信息。
申请条件：需要与模糊位置权限ohos.permission.APPROXIMATELY_LOCATION一起，才可申请此权限。
权限级别：normal
授权方式：user_grant
起始版本：7
ohos.permission.APPROXIMATELY_LOCATION
允许应用获取设备模糊位置信息。
权限级别：normal
授权方式：user_grant
起始版本：9
ohos.permission.MICROPHONE
允许应用使用麦克风。
权限级别：normal
授权方式：user_grant
起始版本：8
ohos.permission.READ_CALENDAR
允许应用读取日历信息。
权限级别：normal
授权方式：user_grant
起始版本：8
ohos.permission.WRITE_CALENDAR
允许应用添加、移除或更改日历活动。
权限级别：normal
授权方式：user_grant
起始版本：8
ohos.permission.READ_HEALTH_DATA
允许应用读取用户的健康数据。
权限级别：normal
授权方式：user_grant
起始版本：7
ohos.permission.ACCESS_NEARLINK
允许应用接入星闪并使用星闪能力，例如配对、连接外围设备等。
权限级别：normal
授权方式：user_grant
起始版本：12
ohos.permission.READ_WRITE_DOWNLOAD_DIRECTORY
允许应用访问公共目录下Download目录及子目录。
当前仅2in1设备应用可申请此权限。
该权限级别发生变更，为保证兼容性，在当前版本请继续采用受限权限申请方式申请使用该权限。
权限级别：API version 11为system_basic; 从API version 12开始为normal。
授权方式：user_grant
起始版本：11
ohos.permission.READ_WRITE_DOCUMENTS_DIRECTORY
允许应用访问公共目录下的Documents目录及子目录。
当前仅2in1设备应用可申请此权限。
该权限级别发生变更，为保证兼容性，在当前版本请继续采用受限权限申请方式申请使用该权限。
权限级别：API version 11为system_basic; 从API version 12开始为normal。
授权方式：user_grant
起始版本：11
ohos.permission.READ_MEDIA
允许应用读取用户外部存储中的媒体文件信息。
权限级别：normal
授权方式：user_grant
起始版本：7
废弃版本：12
替代方案：
请参考文件权限组废弃替代方案。
ohos.permission.WRITE_MEDIA
允许应用读写用户外部存储中的媒体文件信息。
权限级别：normal
授权方式：user_grant
起始版本：7
废弃版本：12
替代方案：
请参考文件权限组废弃替代方案。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/restricted-permissions-V14
爬取时间: 2025-04-28 01:22:00
来源: Huawei Developer
申请方式
当前仅少量符合特殊场景的应用可在通过审批后，使用受限权限，其申请方式请参考：申请使用受限权限。
如果应用涉及获取受限权限，在应用发布上架时，应用市场（AGC）将根据应用的使用场景审核是否可以使用对应的受限权限。如不符合，应用的上架申请将被驳回，审核方式请见发布HarmonyOS应用。
权限列表
ohos.permission.READ_AUDIO
允许读取用户公共目录的音频文件。
可申请此权限的特殊场景与功能：应用需要克隆、备份或同步音频类文件。
其他场景下的使用方案：使用“AudioPicker”访问用户音频文件，使用方式请参考：选择用户文件（FilePicker）。
授权方式：用户授权（user_grant）
起始版本：9
ohos.permission.WRITE_AUDIO
允许修改用户公共目录的音频文件。
可申请此权限的特殊场景与功能：应用需要克隆、备份或同步音频类文件。
其他场景下的使用方案：使用“AudioPicker”保存用户音频文件，使用方式请参考：保存用户文件（FilePicker）。
授权方式：用户授权（user_grant）
起始版本：9
ohos.permission.READ_IMAGEVIDEO
允许读取用户公共目录的图片或视频文件。
可申请此权限的特殊场景与功能：应用需要克隆、备份或同步图片/视频类文件。
其他场景下的使用方案：使用“PhotoViewPicker”访问用户图片或视频，使用方式请参考：使用Picker选择媒体库资源。
授权方式：用户授权（user_grant）
起始版本：9
ohos.permission.WRITE_IMAGEVIDEO
允许修改用户公共目录的图片或视频文件。
可申请此权限的特殊场景与功能：应用需要克隆、备份或同步图片/视频类文件。
其他场景下的使用方案：使用“保存控件”保存用户图片或视频，使用方式请参考：保存控件或拉起保存确认弹窗。
授权方式：用户授权（user_grant）
起始版本：9
ohos.permission.SHORT_TERM_WRITE_IMAGEVIDEO
允许应用保存图片、视频到用户公共目录。
应用获取此权限后，最长可获得30分钟的短时授权，来保存图片/视频。如果超过30分钟，将再次弹窗，需要用户再次确认。
可申请此权限的特殊场景与功能：
其他场景下的使用方案：使用“保存控件”保存用户图片或视频，使用方式请参考：保存控件或拉起保存确认弹窗。
授权方式：用户授权（user_grant）
起始版本：12
ohos.permission.READ_WRITE_DESKTOP_DIRECTORY
允许应用访问公共目录下Desktop目录及子目录。
可申请此权限的特殊场景与功能：当前仅2in1设备应用可申请此权限。
授权方式：用户授权（user_grant）
起始版本：11
ohos.permission.READ_CONTACTS
允许应用读取联系人数据。
可申请此权限的特殊场景与功能：应用需要克隆、备份或同步联系人信息。
其他场景下的使用方案：使用“联系人Picker”访问联系人数据，使用方式请参考：选择联系人。
授权方式：用户授权（user_grant）
起始版本：8
ohos.permission.WRITE_CONTACTS
允许应用添加、移除或更改联系人数据。
可申请此权限的特殊场景与功能：应用需要克隆、备份或同步联系人信息。
其他场景下的使用方案：除以上特殊场景外，应用不能修改联系人数据，应引导用户到“联系人”应用中修改联系人数据。
授权方式：用户授权（user_grant）
起始版本：8
ohos.permission.SYSTEM_FLOAT_WINDOW
允许应用使用全局悬浮窗的能力。
可申请此权限的特殊场景与功能：
应用基于悬浮窗提供的窗口界面，必须向用户提供退出窗口的方式。
其他场景下的使用方案：在其他设备或场景下，使用“画中画”功能，使用方式请参考：画中画开发指导。
授权方式：系统授权（system_grant）
起始版本：8
ohos.permission.READ_PASTEBOARD
允许应用读取剪贴板。
可申请此权限的特殊场景与功能：
其他场景下的使用方案：使用“粘贴控件”读取剪贴板数据，使用方式请参考：粘贴控件。
授权方式：用户授权（user_grant）
起始版本：11
ohos.permission.ACCESS_DDK_USB
允许扩展外设驱动访问USB DDK接口开发USB总线扩展外设驱动。
可申请此权限的特殊场景与功能：
除上述场景外，应用不需要使用此权限保护的系统能力，不涉及申请此权限。
授权方式：系统授权（system_grant）
起始版本：11
ohos.permission.ACCESS_DDK_HID
允许扩展外设驱动访问HID DDK接口开发HID类扩展外设驱动。
可申请此权限的特殊场景与功能：
除上述场景外，应用不需要使用此权限保护的系统能力，不涉及申请此权限。
授权方式：系统授权（system_grant）
起始版本：11
ohos.permission.INPUT_MONITORING
允许应用监听输入事件。
可申请此权限的特殊场景与功能：
应用需要录屏，且录屏过程中有显示键盘按键事件，或是显示鼠标指针效果/触摸效果的功能；应用需要共享桌面。
除上述场景外，应用不能申请此权限。
授权方式：系统授权（system_grant）
起始版本：12
ohos.permission.INTERCEPT_INPUT_EVENT
允许应用拦截输入事件。
可申请此权限的特殊场景与功能：
除上述场景外，应用不能申请此权限。
授权方式：系统授权（system_grant）
起始版本：12
ohos.permission.FILE_ACCESS_PERSIST
允许应用支持持久化访问文件Uri。
授权方式：系统授权（system_grant）
起始版本：11
变更信息：在API 11，权限等级为system_basic；从API 12开始，权限等级变更为normal，向普通应用开放。
该权限级别发生变更，但在当前版本请继续采用受限权限申请方式申请使用该权限。
ohos.permission.MANAGE_PASTEBOARD_APP_SHARE_OPTION
允许应用管理本应用剪贴板数据的可粘贴范围。
即本应用剪贴板数据可否粘贴到其他应用。
可申请此权限的特殊场景与功能：针对部分企业类应用开放，当应用需要自行设置或移除剪贴板数据的可粘贴范围时可申请。
除上述场景外，应用不能申请此权限。
授权方式：系统授权（system_grant）
起始版本：14
ohos.permission.MANAGE_UDMF_APP_SHARE_OPTION
允许应用设置或移除其使用UDMF支持的数据分享范围。
可申请此权限的特殊场景与功能：针对部分企业类应用开放，当应用需要自行设置或移除其使用UDMF支持的数据分享范围时可申请。
除上述场景外，应用不能申请此权限。
授权方式：系统授权（system_grant）
起始版本：14

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/permissions-for-enterprise-apps-V14
爬取时间: 2025-04-28 01:22:14
来源: Huawei Developer
以下权限面向企业类应用开放，企业类应用包括企业普通应用和MDM（Mobile Device Management）设备管理应用。
企业类应用的分发类型分别为enterprise_normal（企业普通应用）和enterprise_mdm（MDM应用），开发者可在Profile文件中查询字段app-distribution-type。
企业类应用可参考声明权限，申请以下权限。
ohos.permission.SET_FILE_GUARD_POLICY
允许应用下发文件管控策略。
权限级别：system_basic
授权方式：system_grant
起始版本：10
变更信息：API 10-14时，其权限级别为system_core，仅面向MDM应用开放；从API 14开始，权限级别变更为system_basic，开发范围变更为企业普通应用。
ohos.permission.FILE_GUARD_MANAGER
允许应用进行公共目录扫描及设置文件扩展属性。
权限级别：system_basic
授权方式：system_grant
起始版本：10
变更信息：API 10-14时，其权限级别为system_core，仅面向MDM应用开放；从API 14开始，权限级别变更为system_basic，开发范围变更为企业普通应用。
ohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS
允许应用跨系统本地账号交互。
权限级别：system_basic
授权方式：system_grant
起始版本：7
变更信息：API 7-13该权限仅向系统应用开放；从API 14开始，开放范围变更为企业普通应用。
ohos.permission.GET_RUNNING_INFO
允许应用获取运行态信息。
权限级别：system_basic
授权方式：system_grant
起始版本：7
变更信息：API 7-13该权限仅向系统应用开放；从API 14开始，开放范围从系统应用变更为企业普通应用。
ohos.permission.RUNNING_STATE_OBSERVER
允许应用监听应用状态。
权限级别：system_basic
授权方式：system_grant
起始版本：7
变更信息：API 7-13该权限仅向系统应用开放；从API 14开始，开放范围从系统应用变更为企业普通应用。
ohos.permission.GET_BUNDLE_INFO_PRIVILEGED
允许查询应用的基本信息和其他敏感信息。
权限级别：system_basic
授权方式：system_grant
起始版本：7
变更信息：API 7-13该权限仅向系统应用开放；从API 14开始，开放范围从系统应用变更为企业普通应用。
ohos.permission.GET_DOMAIN_ACCOUNTS
允许应用查询域账号信息。
权限级别：system_basic
授权方式：system_grant
起始版本：10
变更信息：API 10-13该权限仅向系统应用开放；从API 14开始，开放范围变更为企业普通应用。
ohos.permission.QUERY_AUDIT_EVENT
允许应用查询安全审计事件。
权限级别：system_basic
授权方式：system_grant
起始版本：12
变更信息：API 12-13该权限仅面向MDM应用开放；从API 14开始，开放范围变更为企业普通应用。
ohos.permission.KILL_APP_PROCESSES
允许系统应用杀掉其他应用。
权限级别：system_basic
授权方式：system_grant
起始版本：12
变更信息：API 7-13该权限仅向系统应用开放；从API 14开始，开放范围从系统应用变更为企业普通应用。
ohos.permission.SET_TELEPHONY_ESIM_STATE_OPEN
允许系统应用和运营商应用设置eSIM昵称和激活eSIM。
权限级别：system_basic
授权方式：system_grant
起始版本：14
变更信息：从API 14开始，权限级别变更为system_basic，开发范围从所有应用变更为企业普通应用。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/permissions-for-mdm-apps-V14
爬取时间: 2025-04-28 01:22:28
来源: Huawei Developer
以下权限仅对MDM（Mobile Device Management）设备管理应用开放。MDM应用的详细介绍，请参考MDM Kit简介。
ohos.permission.ENTERPRISE_GET_DEVICE_INFO
允许应用激活设备管理应用。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_GET_NETWORK_INFO
允许设备管理应用查询网络信息。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_INSTALL_BUNDLE
允许设备管理应用安装和卸载包。
权限级别：system_core
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_MANAGE_SET_APP_RUNNING_POLICY
允许设备管理应用设置应用运行管理策略。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_RESET_DEVICE
允许设备管理应用恢复设备出厂设置。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_SET_ACCOUNT_POLICY
允许设备管理应用设置账户管理策略。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_SET_BUNDLE_INSTALL_POLICY
允许设备管理应用设置包安装管理策略。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_SET_DATETIME
允许设备管理应用设置系统时间。
权限级别：system_basic
授权方式：system_grant
起始版本：9
ohos.permission.ENTERPRISE_SET_NETWORK
允许设备管理应用设置网络信息。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_SET_WIFI
允许设备管理应用设置和查询WiFi信息。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_SUBSCRIBE_MANAGED_EVENT
允许设备管理应用订阅管理事件。
权限级别：system_basic
授权方式：system_grant
起始版本：9
ohos.permission.ENTERPRISE_RESTRICT_POLICY
允许设备管理员下发和获取限制类策略。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_SET_SCREENOFF_TIME
允许设备管理员设置系统休眠时间。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_MANAGE_USB
允许设备管理员管理USB。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_MANAGE_NETWORK
允许设备管理员管理网络。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_MANAGE_CERTIFICATE
允许设备管理员管理证书。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_GET_SETTINGS
允许设备管理员查询“设置”应用数据。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.INSTALL_ENTERPRISE_MDM_BUNDLE
允许在企业设备上安装企业MDM应用包。
权限级别：system_core
授权方式：system_grant
起始版本：10
ohos.permission.INSTALL_SELF_BUNDLE
允许企业MDM应用在企业设备上自升级。
权限级别：system_core
授权方式：system_grant
起始版本：10
ohos.permission.ENTERPRISE_SET_BROWSER_POLICY
允许设备设置/取消浏览器策略。
权限级别：system_basic
授权方式：system_grant
起始版本：10
ohos.permission.SET_ENTERPRISE_INFO
允许设备管理应用设置企业信息。
权限级别：system_basic
授权方式：system_grant
起始版本：9
ohos.permission.ENTERPRISE_MANAGE_SECURITY
允许设备设置安全管理策略。
权限级别：system_basic
授权方式：system_grant
起始版本：11
ohos.permission.ENTERPRISE_MANAGE_BLUETOOTH
允许设备管理应用设置和查询蓝牙信息。
权限级别：system_basic
授权方式：system_grant
起始版本：11
ohos.permission.ENTERPRISE_MANAGE_SYSTEM
允许设备管理系统的设置参数。
权限级别：system_basic
授权方式：system_grant
起始版本：11
ohos.permission.ENTERPRISE_MANAGE_WIFI
允许设备管理应用设置和查询WIFI信息。
权限级别：system_basic
授权方式：system_grant
起始版本：11
ohos.permission.ENTERPRISE_MANAGE_RESTRICTIONS
允许设备管理应用管理限制策略。
权限级别：system_basic
授权方式：system_grant
起始版本：11
ohos.permission.ENTERPRISE_MANAGE_APPLICATION
允许设备管理应用管理应用策略。
权限级别：system_basic
授权方式：system_grant
起始版本：11
ohos.permission.ENTERPRISE_MANAGE_LOCATION
允许设备管理应用设置和查询位置信息。
权限级别：system_basic
授权方式：system_grant
起始版本：11
ohos.permission.ENTERPRISE_REBOOT
允许设备管理应用进行关机重启操作。
权限级别：system_basic
授权方式：system_grant
起始版本：11
ohos.permission.ENTERPRISE_LOCK_DEVICE
允许设备管理应用锁定设备。
权限级别：system_basic
授权方式：system_grant
起始版本：11
ohos.permission.ENTERPRISE_MANAGE_SETTINGS
允许设备管理应用管理设置。
权限级别：system_basic
授权方式：system_grant
起始版本：11
ohos.permission.ENTERPRISE_OPERATE_DEVICE
允许设备管理应用操作设备。
权限级别：system_basic
授权方式：system_grant
起始版本：12
ohos.permission.ENTERPRISE_ADMIN_MANAGE
允许设备管理应用管理设备管理器。
权限级别：system_basic
授权方式：system_grant
起始版本：12
ohos.permission.ENTERPRISE_RECOVERY_KEY
允许应用管理企业级恢复密钥。
权限级别：system_core
授权方式：system_grant
起始版本：13
ohos.permission.ENTERPRISE_MANAGE_DELEGATED_POLICY
允许设备管理应用委托其他应用设置设备管控策略。
权限级别：system_basic
授权方式：system_grant
起始版本：14

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/use-picker-V14
爬取时间: 2025-04-28 01:22:41
来源: Huawei Developer
应用拉起系统Picker组件（文件选择器、照片选择器、联系人选择器等），由用户在Picker上选择对应的文件、照片、联系人等资源，应用即可获取到Picker的返回结果。
系统Picker由系统独立进程实现。
由于系统Picker已经获取了对应权限的预授权，开发者使用系统Picker时，无需再次申请权限也可临时受限访问对应的资源。例如，当应用需要读取用户图片时，可通过使用照片Picker，在用户选择所需要的图片资源后，直接返回该图片资源，而不需要授予应用读取图片文件的权限。
当前，系统Picker作为拉起系统资源的一种方式，整合至“拉起系统应用”中，开发者可从“拉起系统应用”获取所有拉起系统资源的方式。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/app-permission-group-list-V14
爬取时间: 2025-04-28 01:22:55
来源: Huawei Developer
使用须知
-  在申请目标权限前，建议开发者先阅读应用权限管控概述-权限组和子权限，了解相关概念，再合理申请对应的权限组。
-  当应用请求权限时，同一个权限组的权限将会在一个弹窗内一起请求用户授权，用户同意授权后，权限组内权限将被统一授权。地理位置、通讯录、通话记录、电话、信息、日历权限组除外。 以位置信息和相机权限组举例说明：
-  当前系统支持的权限组如下所示，各子权限的含义请查阅应用权限列表。
位置
-  ohos.permission.LOCATION_IN_BACKGROUND
-  ohos.permission.LOCATION
-  ohos.permission.APPROXIMATELY_LOCATION
相机
麦克风
通讯录
-  ohos.permission.READ_CONTACTS
-  ohos.permission.WRITE_CONTACTS
日历
-  ohos.permission.READ_CALENDAR
-  ohos.permission.WRITE_CALENDAR
运动数据
由于2in1设备无相关传感器，此权限不支持在2in1设备上申请。
身体传感器
仅穿戴设备可申请。
图片和视频
-  ohos.permission.WRITE_IMAGEVIDEO
-  ohos.permission.READ_IMAGEVIDEO
-  ohos.permission.MEDIA_LOCATION
音乐和音频
-  ohos.permission.WRITE_AUDIO
-  ohos.permission.READ_AUDIO
跨应用关联
设备发现和连接
从API version 13开始，原有的“蓝牙”、“星闪”、“多设备协同”权限组不再使用，相关权限将通过“设备发现和连接”权限组统一授权和操作。
剪切板
文件夹
仅2in1设备可申请。
-  ohos.permission.READ_WRITE_DOWNLOAD_DIRECTORY
-  ohos.permission.READ_WRITE_DOCUMENTS_DIRECTORY
文件(deprecated)
从API version 12开始，该权限组及其子权限废弃。
-  ohos.permission.READ_MEDIA
-  ohos.permission.WRITE_MEDIA
废弃替代方案：
-  读写媒体库图片或视频：
-  读取媒体库音频文件： 申请受限权限ohos.permission.READ_AUDIO或ohos.permission.WRITE_AUDIO读写媒体库的音频文件。
-  读取文件管理器中的文件： 无需申请权限，通过文件Picker读写文件管理器中的文件。参考：选择用户文件、保存用户文件。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/security-components-V14
爬取时间: 2025-04-28 01:23:09
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/security-component-overview-V14
爬取时间: 2025-04-28 01:23:23
来源: Huawei Developer
安全控件是系统提供的一组系统实现的ArkUI组件，其中保存控件和位置控件，在用户首次使用时，会弹出通知弹窗，在用户点击允许后自动授权，后续使用无需弹窗授权；粘贴控件在用户点击后自动授权，无需弹窗授权。它们可以作为一种“特殊的按钮”融入应用页面，实现用户点击即许可的设计思路。
相较于动态申请权限的方式，安全控件可基于场景化授权，简化开发者和用户的操作，主要优点有：
1.  用户可掌握授权时机，授权范围最小化。
2.  授权场景可匹配用户真实意图。
3.  减少弹窗打扰。
4.  开发者不必向应用市场申请权限，简化操作。
安全控件坚持仅采集实现业务功能所必须的个人数据，以服务于用户的需求，帮助开发透明、可选、可控的隐私合规应用。
安全控件列表
目前系统提供三类安全控件：
-  粘贴控件（PasteButton） 该控件对应剪贴板读取特权。应用集成粘贴控件后，用户点击该控件，应用读取剪贴板数据时不会弹窗提示。 建议使用场景：粘贴控件可以用于任何应用需要读取剪贴板的场景，避免弹窗提示对用户造成干扰。
-  保存控件（SaveButton） 该控件对应媒体库写入特权。应用集成保存控件后，用户点击该控件，应用会获取10秒内访问媒体库特权接口的授权。 建议使用场景：保存控件可以用于任何应用需要保存文件到媒体库的场景（保存图片、保存视频等）。与Picker需要拉起系统应用再由用户选择具体路径保存的方式不同，保存控件将直接保存到指定媒体库路径，操作更快捷。
-  位置控件（LocationButton） 该控件对应精准定位特权。应用集成位置控件后，用户点击该控件，无论应用是否申请过或者被授予精准定位权限，都会在本次前台期间获得精准定位的授权，可以调用位置服务获取精准定位。 建议使用场景：应用不是强位置关联应用（如导航、运动健康等），仅在部分前台场景需要使用位置信息（如定位城市、打卡、分享位置等）。如果需要长时间使用或是在后台使用位置信息，建议申请位置权限。
运作机制
整体方案由安全控件UI组件、安全控件管理服务、安全控件增强组成：
-  UI组件：实现了固定文字图标的样式，便于用户识别，同时提供了相对丰富的定制化能力，便于开发者定制。
-  控件管理服务：提供控件注册管理能力、控件临时授权机制、管理授权生效周期，确保应用后台、锁屏下无法注册使用安全控件。
-  安全增强：安全控件实现相关安全防护能力，例如地址随机化、挑战值检查、回调UI框架复核控件信息、调用者地址检查、组件防覆盖、真实点击事件校验等机制，防止应用开发者通过混淆、隐藏、篡改、仿冒等方式滥用授权机制，泄露用户隐私。
开发者调用接口时，运作流程如图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170428.11923877479024427386903674051509:50001231000000:2800:F5E75FEB1D956D26A6AE6882D3C0679B1917BA2412A80A2CDEC1B25BC67571A4.png)
1.  应用开发者在ETS文件中集成安全控件，通过JS引擎解析后，在ArkUI框架中生成具体的控件。
2.  安全控件注册控件信息到安全控件管理服务，安全控件管理服务检查控件信息的合法性。
3.  用户点击事件分发到安全控件。
4.  安全控件将点击事件上报到安全控件管理服务。
5.  安全控件管理服务根据控件种类对应不同权限，调用权限管理服务进行临时授权。
6.  授权成功后，安全控件回调OnClick通知应用层授权成功。
7.  应用调用相应的特权操作，如获取地理位置、读取剪贴板信息、媒体库中创建文件等。 不同类型的安全控件，对于权限的使用方式不同、授权的有效期也不同，详情请查阅具体安全控件的开发指导。
8.  对应的服务会调用权限管理服务或安全控件管理服务，获取授权结果，返回鉴权结果。
约束与限制
安全控件因其自动授权的特性，为了保障用户的隐私不被恶意应用获取，针对安全控件作了很多的限制。应用开发者需保证安全控件在应用界面上清晰可见、用户能明确识别，防止因覆盖、混淆等因素导致授权失败。
当因控件样式不合法导致授权失败的情况发生时，请开发者检查设备错误日志，过滤关键字"SecurityComponentCheckFail"可以获取具体原因。
请开发者关注过滤条件下，所有级别的日志。
可能会导致授权失败的问题（包括但不限于）：
-  字体、图标尺寸过小。
-  安全控件整体尺寸过大。
-  字体、图标、背景按钮的颜色透明度过高。
-  字体或图标与背景按钮颜色过于相似。
-  安全控件超出屏幕、超出窗口等，导致显示不全。
-  安全控件被其他组件或窗口遮挡。
-  安全控件的父组件有类似变形模糊等可能导致安全控件显示不完整的属性。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/pastebutton-V14
爬取时间: 2025-04-28 01:23:36
来源: Huawei Developer
粘贴控件是一种特殊的系统安全控件，它允许应用在用户的授权下无提示地读取剪贴板数据。
在应用集成粘贴控件后，用户点击该控件，应用读取剪贴板数据时不会弹窗提示。可以用于任何应用需要读取剪贴板的场景，避免弹窗提示对用户造成干扰。
例如，用户在应用外（如短信）复制了验证码，要在应用内粘贴验证码。用户原来在进入应用后，还需要长按输入框、在弹出的选项中点击粘贴，才能完成输入。而使用粘贴控件，用户只需进入应用后直接点击粘贴按钮，即可一步到位。
粘贴控件效果如图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170428.38355766301548659785193214606660:50001231000000:2800:14794CE61E21AA365D31930F160DD475A90AB906E91EAB8B78E3E1ACFBE53C79.gif)
约束与限制
-  临时授权会持续到灭屏、应用切后台、应用退出情况发生。
-  应用在授权期间没有调用次数限制。
-  为了保障用户的隐私不被恶意应用获取，应用需确保安全控件是可见的且用户能够识别的。开发者需要合理的配置控件的尺寸、颜色等属性，避免视觉混淆的情况，如果发生因控件的样式不合法导致授权失败的情况，请检查设备错误日志。
开发步骤
以简化用户填写验证码为例，参考以下步骤，实现效果：点击控件获取临时授权，粘贴内容到文本框，效果图请见上文。
1.  导入剪贴板依赖。
```typescript
import { pasteboard } from '@kit.BasicServicesKit';
```
2.  添加输入框和粘贴控件。 粘贴控件是由图标、文本、背景组成的类似Button的按钮，其中图标、文本两者至少有其一，背景必选。图标和文本不支持自定义，仅支持在已有的选项中选择。 应用申明安全控件的接口时，分为传参和不传参两种，不传参默认创建图标+文字+背景的按钮，传参根据传入的参数创建，不包含没有配置的元素。 当前示例使用默认参数。具体请参见PasteButton控件。此外，所有安全控件都继承安全控件通用属性，可用于定制样式。
```typescript
import { pasteboard, BusinessError } from '@kit.BasicServicesKit';
@Entry
@Component
struct Index {
@State message: string = '';
build() {
Row() {
Column({ space: 10 }) {
TextInput({ placeholder: '请输入验证码', text: this.message })
PasteButton()
.padding({top: 12, bottom: 12, left: 24, right: 24})
.onClick((event: ClickEvent, result: PasteButtonOnClickResult) => {
if (PasteButtonOnClickResult.SUCCESS === result) {
pasteboard.getSystemPasteboard().getData((err: BusinessError, pasteData: pasteboard.PasteData) => {
if (err) {
console.error(`Failed to get paste data. Code is ${err.code}, message is ${err.message}`);
return;
}
// 剪贴板内容为 '123456'
this.message = pasteData.getPrimaryText();
});
}
})
}
.width('100%')
}
.height('100%')
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/savebutton-V14
爬取时间: 2025-04-28 01:23:50
来源: Huawei Developer
保存控件是一种特殊的安全控件，它允许用户通过点击按钮临时获取存储权限，而无需通过权限弹框进行授权确认。
集成保存控件后，当用户点击该控件时，应用会获得10秒内访问媒体库特权接口的授权。这适用于任何需要将文件保存到媒体库的应用场景，例如保存图片或视频等。
与需要触发系统应用并由用户选择具体保存路径的Picker不同，保存控件可以直接保存到指定的媒体库路径，使得操作更为便捷。
保存控件效果如图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170429.28908706919546669773930048015828:50001231000000:2800:BBCC2A3044ED360EAD5CE59219D43A36E08E51B9474785202C65036DFAD96DFA.png)
约束与限制
-  当用户首次点击应用中的保存控件，系统将弹窗请求用户授权。如果用户点击“取消”，弹窗消失，应用无授权，用户再次点击保存控件时，将会重新弹窗；如果用户点击“允许”，弹窗消失，应用将被授予临时保存权限，此后点击该应用的保存控件将不会弹窗。
-  应用在onClick()触发回调到调用媒体库特权接口的时间间隔不能大于10秒。
-  用户点击一次控件，仅获取一次授权调用。
-  为了保障用户的隐私不被恶意应用获取，应用需确保安全控件是可见的且用户能够识别的。开发者需要合理的配置控件的尺寸、颜色等属性，避免视觉混淆的情况，如果发生因控件的样式不合法导致授权失败的情况，请检查设备错误日志。
开发步骤
以保存对话中图片为例，应用仅需要在前台期间，短暂使用保存图片的特性，不需要长时间使用。此时，可以直接使用安全控件中的保存控件，免去权限申请和权限请求等环节，获得临时授权，保存对应图片。
1.  导入文件和媒体库依赖。
```typescript
import { photoAccessHelper } from '@kit.MediaLibraryKit';
import { fileIo } from '@kit.CoreFileKit';
```
2.  设置图片资源，并添加保存控件。 保存控件是一种类似于按钮的安全控件，由图标、文本和背景组成。其中，图标和文本至少需要有一个，背景是必选的。图标和文本不能自定义，只能从已有的选项中选择。在声明安全控件的接口时，有传参和不传参两种方式。不传参将默认创建一个包含图标、文字和背景的按钮，传参则根据参数创建，不包含未配置的元素。 当前示例使用默认参数。具体请参见SaveButton控件。此外，所有安全控件都继承安全控件通用属性，可用于定制样式。 图片保存到媒体库的详细介绍可参考保存媒体库资源。
```typescript
import { photoAccessHelper } from '@kit.MediaLibraryKit';
import { fileIo } from '@kit.CoreFileKit';
import { common } from '@kit.AbilityKit';
import { promptAction } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
async function savePhotoToGallery(context: common.UIAbilityContext) {
let helper = photoAccessHelper.getPhotoAccessHelper(context);
try {
// onClick触发后10秒内通过createAsset接口创建图片文件，10秒后createAsset权限收回。
let uri = await helper.createAsset(photoAccessHelper.PhotoType.IMAGE, 'jpg');
// 使用uri打开文件，可以持续写入内容，写入过程不受时间限制
let file = await fileIo.open(uri, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
// $r('app.media.startIcon')需要替换为开发者所需的图像资源文件
context.resourceManager.getMediaContent($r('app.media.startIcon').id, 0)
.then(async value => {
let media = value.buffer;
// 写到媒体库文件中
await fileIo.write(file.fd, media);
await fileIo.close(file.fd);
promptAction.showToast({ message: '已保存至相册！' });
});
}
catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to save photo. Code is ${err.code}, message is ${err.message}`);
}
}
@Entry
@Component
struct Index {
build() {
Row() {
Column({ space: 10 }) {
// $r('app.media.startIcon')需要替换为开发者所需的图像资源文件
Image($r('app.media.startIcon'))
.height(400)
.width('100%')
SaveButton()
.padding({top: 12, bottom: 12, left: 24, right: 24})
.onClick(async (event: ClickEvent, result: SaveButtonOnClickResult) => {
if (result === SaveButtonOnClickResult.SUCCESS) {
const context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
// 免去权限申请和权限请求等环节，获得临时授权，保存对应图片
savePhotoToGallery(context);
} else {
promptAction.showToast({ message: '设置权限失败！' })
}
})
}
.width('100%')
}
.height('100%')
.backgroundColor(0xF1F3F5)
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/locationbutton-V14
爬取时间: 2025-04-28 01:24:04
来源: Huawei Developer
位置控件使用直观且易懂的通用标识，让用户明确地知道这是一个获取位置信息的按钮。这满足了授权场景需要匹配用户真实意图的需求。只有当用户主观愿意，并且明确了解使用场景后点击位置控件，应用才会获得临时的授权，获取位置信息并完成相应的服务功能。
一旦应用集成了位置控件，用户点击该控件后，无论应用是否已经申请过或被授予精准定位权限，都会在本次前台期间获得精准定位的授权，可以调用位置服务获取精准定位。
对于不是强位置关联应用（例如导航、运动健康等）的应用，只在部分前台场景需要使用位置信息（例如定位城市、打卡、分享位置等）。如果需要长时间使用或是在后台使用位置信息，建议申请位置权限。
位置控件效果如图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170429.31969367556379629027001920787787:50001231000000:2800:DA9F72DF0884BCCF3140E8A883EB6BE26081E0FB28309FC069771D7A55C72F00.png)
约束与限制
-  当用户首次点击应用中的位置控件，系统将弹窗请求用户授权。如果用户点击“取消”，弹窗消失，应用无授权，用户再次点击位置控件时，将会重新弹窗；如果用户点击“允许”，弹窗消失，应用将被授予临时位置权限，此后点击该应用的位置控件将不会弹窗。
-  精准定位的临时授权会持续到灭屏、应用切后台、应用退出等任一情况发生，然后恢复到临时授权之前的授权状态（授予/未授予/未申请）。
-  应用在授权期间没有调用次数限制。
-  为了保障用户的隐私不被恶意应用获取，应用需确保安全控件是可见的且用户能够识别的。开发者需要合理的配置控件的尺寸、颜色等属性，避免视觉混淆的情况，如果发生因控件的样式不合法导致授权失败的情况，请检查设备错误日志。
开发步骤
以在聊天界面发送实时定位信息为例。在当前场景下，应用仅需要在前台期间，短暂地访问当前位置，不需要长时间使用。此时，可以直接使用安全控件中的位置控件，免去权限申请和权限请求等环节，获得临时授权，满足权限最小化，提升用户的隐私体验。
参考以下步骤，实现效果：点击控件“当前位置”获取临时精准定位授权，获取授权后，弹窗提示具体位置信息，效果图请见上文。
1.  引入位置服务依赖。
```typescript
import { geoLocationManager } from '@kit.LocationKit';
```
2.  添加位置控件和获取当前位置信息。 安全控件是由图标、文本、背景组成的类似Button的按钮，其中图标、文本两者至少有其一，背景是必选的。图标和文本不支持自定义，仅支持在已有的选项中选择。应用申明安全控件的接口时，分为传参和不传参两种，不传参默认创建图标+文字+背景的按钮，传参根据传入的参数创建，不包含没有配置的元素。 当前示例使用默认参数，具体请参见LocationButton控件。此外，所有安全控件都继承安全控件通用属性，可用于定制样式。 在LocationButton的onClick()回调中通过调用geoLocationManager模块提供的方法获取当前位置信息。
```typescript
import { geoLocationManager } from '@kit.LocationKit';
import { promptAction } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
// 获取当前位置信息
function getCurrentLocationInfo() {
const requestInfo: geoLocationManager.LocationRequest = {
'priority': geoLocationManager.LocationRequestPriority.FIRST_FIX,
'scenario': geoLocationManager.LocationRequestScenario.UNSET,
'timeInterval': 1,
'distanceInterval': 0,
'maxAccuracy': 0
};
try {
geoLocationManager.getCurrentLocation(requestInfo)
.then((location: geoLocationManager.Location) => {
promptAction.showToast({ message: JSON.stringify(location) });
})
.catch((err: BusinessError) => {
console.error(`Failed to get current location. Code is ${err.code}, message is ${err.message}`);
});
} catch (err) {
console.error(`Failed to get current location. Code is ${err.code}, message is ${err.message}`);
}
}
@Entry
@Component
struct Index {
build() {
Row() {
Column({ space: 10 }) {
LocationButton({
icon: LocationIconStyle.LINES,
text: LocationDescription.CURRENT_LOCATION,
buttonType: ButtonType.Normal
})
.padding({top: 12, bottom: 12, left: 24, right: 24})
.onClick((event: ClickEvent, result: LocationButtonOnClickResult) => {
if (result === LocationButtonOnClickResult.SUCCESS) {
// 免去权限申请和权限请求等环节，获得临时授权，获取位置信息授权
getCurrentLocationInfo();
} else {
promptAction.showToast({ message: '获取位置信息失败！' })
}
})
}
.width('100%')
}
.height('100%')
.backgroundColor(0xF1F3F5)
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/code-protect-V14
爬取时间: 2025-04-28 01:24:17
来源: Huawei Developer
能力简介
为了保护应用代码安全，保护开发者的核心资产，HarmonyOS提供了端到端的应用代码保护机制，该机制以系统安全为基础，构建内核级应用生命周期内的代码安全保护能力。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170429.77548816757243907844035748230657:50001231000000:2800:A152338635DA2EB97F38C5C73E73761D231357FA634133EBBCF3883E5DA6387F.png)
开发者向应用市场提交上架申请，上传应用包后可选择是否加密。
选择加密的应用，在经过应用市场审核后，应用市场会对上架应用做代码加密。应用在设备上安装时，安装文件落盘后仍是处于加密状态，有效的保护应用程序；当应用程序启动时按需解密。
应用加密采用标准AES加密算法，解密后的明文只存在于内存中，不会存储到设备，形成端到端的加密方案，有效地提高应用程序的安全性。
系统级应用加密具有如下优点：
加密影响
加密对应用的性能影响与被加密的代码文件大小成正相关，应用的.abc文件越大对应用冷启动时延的影响越大。
加密效果
加密对象为应用内编译后的代码文件，覆盖.abc文件，加密前的代码文件可被反编译，加密后的代码文件安全性会有很大地提升，提高逆向分析的难度。
由于应用加密使用的密钥不会在应用包中出现，因此，即使加密后的应用包被获取，攻击者仅能获取到代码的密文。
使用步骤
应用加密特性在应用上架时加密，应用运行时按需解密。安全增强的同时，确保开发者、消费者无感的安全体验，避免应用开发者适配工作，保障用户无感的纯净安全体验。
应用加密在不同阶段中的步骤如下：
-  操作步骤可参考：发布HarmonyOS应用-选取待发布的软件包。
常见问题
-  A1：应用加密特性可以有效提高应用代码文件逆向分析的难度，但应用代码防逆向是一个持续攻防对抗的过程，如对代码文件保护有更高的要求，需要结合其他安全加固措施，进一步提高逆向分析应用的难度。比如使能混淆能力、使能三方安全加固能力等。
-  A2：使能混淆能力、使能三方安全加固能力等，请参考应用资产保护设计-保护应用代码场景。
-  A3：加密后的应用在程序启动和运行过程中可能会小幅度增加性能开销；加密后的应用相比于不加密的应用体积更大，可能会小幅度增加下载和安装时间。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/passwordvault-V14
爬取时间: 2025-04-28 01:24:31
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/passwordvault-overview-V14
爬取时间: 2025-04-28 01:24:44
来源: Huawei Developer
功能简介
密码保险箱作为HarmonyOS系统安全功能，为用户提供了便捷的免密登录体验。
用户在应用或浏览器进行注册/登录操作时，可一键完成自动生成强密码、自动保存、自动填充，无需记住或手动输入繁琐的密码，由系统实现统一的安全管理密码能力。
用户查看密码或使用密码进行自动填充，都需要经过身份认证，通过输入锁屏密码或验证指纹/人脸，确保只有用户本人才能访问密码。
使用场景
面向用户，可分为三大场景：
用户在注册/登录场景产生的密码数据，均可以在密码保险箱管理界面进行查看。进入密码保险箱管理界面的步骤：“设置 > 隐私和安全 > 密码保险箱”，用户验证锁屏密码/指纹/人脸后，可以查看已保存的所有账号密码数据。
架构介绍
如下图所示，密码保险箱基于关键资产存储能力，保存并保护用户的账号密码。
根据用户操作自动识别使用账号密码的场景（如登录、注册、修改密码），基于识别的场景，提供对应的免密登录服务。
在填充过程中，依托统一用户认证能力，若用户指定需要使用某条账号密码进行填充时，会进行用户身份信息认证（人脸/指纹或锁屏密码），用于保证正确的人访问了正确的数据。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250328150005.89549241465559630271883197343320:50001231000000:2800:34C48F86DD010C44B5B31F72B55293B98C57CF4041CBF9E4C68266B07B2A844B.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/passwordvault-apps-V14
爬取时间: 2025-04-28 01:24:58
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/passwordvault-quick-adaptation-V14
爬取时间: 2025-04-28 01:25:12
来源: Huawei Developer
密码自动填充服务依托ArkUITextInput 组件为开发者提供的一系列登录场景相关控件，密码保险箱帮助开发者快速集成自动填充等功能，仅需在界面上使用ArkUI标准控件，开发者即可通过密码保险箱的便捷登录，让用户快速上手应用功能。
约束与限制
| InputType名称  | 描述  | 使用场景  |
| --- | --- | --- |
| USER_NAME  | 用户名输入模式。  | 用于登录、注册等场景的用户名输入。  |
| Password  | 密码输入模式。支持输入数字、字母、下划线、空格、特殊字符。 密码显示小眼睛图标并且默认会将文字变成圆点。  | 用于登录、注册等场景的密码输入。  |
| NUMBER_PASSWORD  | 数字密码输入模式。仅支持输入数字。 密码显示小眼睛图标并且默认会将文字变成圆点。  | 用于登录、注册等场景的密码输入。  |
| NEW_PASSWORD  | 新密码输入模式。  | 用于注册、修改密码等场景的新密码输入。  |
InputType名称
描述
使用场景
USER_NAME
用户名输入模式。
用于登录、注册等场景的用户名输入。
Password
密码输入模式。支持输入数字、字母、下划线、空格、特殊字符。
密码显示小眼睛图标并且默认会将文字变成圆点。
用于登录、注册等场景的密码输入。
NUMBER_PASSWORD
数字密码输入模式。仅支持输入数字。
密码显示小眼睛图标并且默认会将文字变成圆点。
用于登录、注册等场景的密码输入。
NEW_PASSWORD
新密码输入模式。
用于注册、修改密码等场景的新密码输入。
本文档中类型描述为Password的类型，均可用NUMBER_PASSWORD类型替代。
快速适配指导
当应用具备账号密码登录的场景时，只需要将充当用户名的TextInput输入框的type属性设置为InputType.USER_NAME，将密码TextInput输入框的type属性设置为InputType.Password，即可使用密码保险箱的填充和保存功能。
在应用的账号密码注册页除设置用户名输入框外，将新密码TextInput输入框的type属性设置为InputType.NEW_PASSWORD，即可使用强密码填充功能。如果应用对密码强度有特殊要求，根据为应用添加自动生成高强度密码的建议适配即可。
代码示例：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/passwordvault-autosave-V14
爬取时间: 2025-04-28 01:25:26
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/passwordvault-save-acc-password-V14
爬取时间: 2025-04-28 01:25:39
来源: Huawei Developer
密码保险箱在应用的登录、注册、修改密码等场景具备自动保存用户名和密码的能力。
保存后的用户名和密码可以在下次登录、修改密码时中自动填充到界面上的对应输入框，用户可以在密码保险箱内对已保存的用户名和密码进行查看，修改，添加备注，删除。
应用界面触发账号密码自动保存时，若密码保险箱中不存在同应用下的相同账号，则弹出账号密码保存提示框，用户点击“保存密码”按钮，即可将本次使用的账号和密码保存至密码保险箱。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170430.51584134142449747293900692376988:50001231000000:2800:FED9464F3D439BF2BB8FBF0F5BAE9BA0CDB48EEA63552C915DA7B6A90D8D333D.png)
应用触发账号登录或注册时，均可触发保存功能，下面分别介绍两种布局的标准适配场景。
触发条件及注意事项：
1.  用户名输入框应设置type属性为InputType.USER_NAME。 密码输入框应设置type属性为InputType.Password或InputType.NEW_PASSWORD。 其中，InputType.Password表示普通密码输入框，适用于登录界面的密码和修改密码界面的旧密码， InputType.NEW_PASSWORD表示新密码输入框，适用于注册界面和修改密码界面的新密码。
账号密码登录
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170430.52912997121257630596520601214002:50001231000000:2800:3A9B96BEA8711F1B007A0737FE1092A30A1E556005A9991A028642AE99898707.png)
示例代码如下：
```typescript
@Entry
@Component
struct LoginExample {
pathInfos: NavPathStack = new NavPathStack();
@State ReserveAccount: string = '';
@State ReservePassword: string = '';
@Builder
PageMap(name: string) {
if (name === 'home_page') {
HomePage()
}
}
build() {
Navigation(this.pathInfos) {
Column({ space: 16 }) {
Text("账户登录").commonTitleStyles()
TextInput({ placeholder: '用户名' })
.commonInputStyles()
.type(InputType.USER_NAME) // 账号框使用USER_NAME属性
.onChange((value: string) => {
this.ReserveAccount = value;
})
TextInput({ placeholder: '密码' })
.showPasswordIcon(true)
.commonInputStyles()
.type(InputType.Password) // 密码框使用Password属性
.onChange((value: string) => {
this.ReservePassword = value;
})
Button('登录')
.width('100%')
.enabled((this.ReserveAccount !== '') && (this.ReservePassword !== ''))
.onClick(() => {
this.pathInfos.pushPathByName('home_page', null)
})
}
.padding(16)
}
.navDestination(this.PageMap)
.height('100%')
.width('100%')
}
}
@Component
struct HomePage {
pathInfos: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Text("Home Page").commonTitleStyles()
}.width('100%').height('100%')
}.title("Home Page")
.onReady((context: NavDestinationContext) => {
this.pathInfos = context.pathStack;
})
}
}
@Extend(Text)
function commonTitleStyles() {
.fontSize(24)
.fontColor('#000000')
.fontWeight(FontWeight.Medium)
.margin({ top: 24, bottom: 16 })
}
@Extend(TextInput)
function commonInputStyles() {
.placeholderColor(0x182431)
.width('100%')
.opacity(0.6)
.placeholderFont({ size: 16, weight: FontWeight.Regular })
.margin({ top: 16 })
}
@Extend(Button)
function commonButtonStyles() {
.width('100%')
.height(40)
.borderRadius(20)
.margin({ top: 24 })
}
```
账号密码注册
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170430.59650473636630968452728413590812:50001231000000:2800:B3F58D08B8CBCBC4256522973BCCF2243F715FDF191B8286946128CF905F9142.png)
示例代码如下：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/passwordvault-update-acc-password-V14
爬取时间: 2025-04-28 01:25:53
来源: Huawei Developer
应用界面触发账号密码自动保存时，若密码保险箱中已存在同应用下与本次使用账号相同的账号，则弹出密码更新提示框，用户点击更新按钮，即可更新密码保险箱内对应账号的密码。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250414094252.73573599094356124000557123547629:50001231000000:2800:42DD3EC4D82E9BAB49906C2748B1B72BE17C64EEB0891D6B64889B2B57014448.png)
应用触发修改密码或使用已经保存过的账号手动登录时，均会触发密码更新功能。
登录的布局介绍请参考账号密码登录，以下仅介绍修改账号密码的标准适配场景。
触发条件及注意事项同账号密码保存功能。
修改账号密码
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250414094252.62722097622605485605155778306391:50001231000000:2800:436E257A4D5890ED77EC0387AC5F06C11739D73ADD764496F4F99118C7AFF190.png)
示例代码如下：
```typescript
@Entry
@Component
struct RegisterExample {
pathInfos: NavPathStack = new NavPathStack();
@State ReserveAccount: string = '';
@State ReservePassword: string = '';
@State enAbleAutoFill: boolean = true;
onBackPress() {
// 当非成功登录、返回等页面跳转时将enAbleAutoFill设置为false，密码保险箱不使能
this.enAbleAutoFill = false;
return false;
}
@Builder
PageMap(name: string) {
if (name === 'register_result_page') {
RegisterResultPage()
}
}
build() {
Navigation(this.pathInfos) {
Column() {
Text("修改密码")
.commonTitleStyles()
TextInput({ placeholder: '用户名' })
.commonInputStyles()
.type(InputType.USER_NAME) // 账号框使用USER_NAME属性
.onChange((value: string) => {
this.ReserveAccount = value;
})
TextInput({ placeholder: '密码' })
.showPasswordIcon(true)
.commonInputStyles()
.type(InputType.Password)
.onChange((value: string) => {
this.ReservePassword = value;
})
TextInput({ placeholder: '新密码' })
.showPasswordIcon(true)
.commonInputStyles()
.type(InputType.NEW_PASSWORD) // 密码框使用 new Password 属性,可以触发生成强密码
.enableAutoFill(this.enAbleAutoFill)
.passwordRules('begin:[upper],special:[yes],len:[maxlen:32,minlen:12]')
.onChange((value: string) => {
this.ReservePassword = value;
})
Button('页面跳转')
.commonButtonStyles()
.enabled((this.ReserveAccount !== '') && (this.ReservePassword !== ''))
.onClick(() => {
this.pathInfos.pushPathByName('register_result_page', null)
})
Button('页面跳转(跳转前关闭autofill）')
.commonButtonStyles()
.enabled((this.ReserveAccount !== '') && (this.ReservePassword !== ''))
.onClick(() => {
this.enAbleAutoFill = false;
this.pathInfos.pushPathByName('register_result_page', null)
})
}
}
.navDestination(this.PageMap)
.height('100%')
.width('100%')
}
}
@Component
struct RegisterResultPage {
pathInfos: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Text("Result Page").commonTitleStyles()
}.width('100%').height('100%')
}.title("Result Page")
.onReady((context: NavDestinationContext) => {
this.pathInfos = context.pathStack;
})
}
}
@Extend(Text)
function commonTitleStyles() {
.fontSize(24)
.fontColor('#000000')
.fontWeight(FontWeight.Medium)
.margin({ top: 24, bottom: 16 })
}
@Extend(TextInput)
function commonInputStyles() {
.placeholderColor(0x182431)
.width('100%')
.opacity(0.6)
.placeholderFont({ size: 16, weight: FontWeight.Regular })
.margin({ top: 16 })
}
@Extend(Button)
function commonButtonStyles() {
.width('100%')
.height(40)
.borderRadius(20)
.margin({ top: 24 })
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/passwordvault-autofill-V14
爬取时间: 2025-04-28 01:26:47
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/passwordvault-autofill-acc-password-V14
爬取时间: 2025-04-28 01:27:01
来源: Huawei Developer
密码保险箱可以在登录或修改密码时，自动填充已保存的用户名和密码。
触发条件及注意事项：
-  具体类型请参考输入框类型说明。
登录
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250414094252.62587952848479164915990099102755:50001231000000:2800:54246AAB8DCCAE2D1EEAC087037686B088996C9B12A300782E9F289CD5E118D6.png)
示例代码如下：
```typescript
@Entry
@Component
struct LoginExample {
pathInfos: NavPathStack = new NavPathStack();
@State ReserveAccount: string = '';
@State ReservePassword: string = '';
@Builder
PageMap(name: string) {
if (name === 'home_page') {
HomePage()
}
}
build() {
Navigation(this.pathInfos) {
Column() {
Text("账户登录")
.commonTitleStyles()
TextInput({ placeholder: '用户名' })
.commonInputStyles()
.type(InputType.USER_NAME)// 账号框使用USER_NAME属性
.onChange((value: string) => {
this.ReserveAccount = value;
})
TextInput({ placeholder: '密码' })
.showPasswordIcon(true)
.commonInputStyles()
.type(InputType.Password)// 密码框使用Password属性
.onChange((value: string) => {
this.ReservePassword = value;
})
Button('登录')
.commonButtonStyles()
.enabled((this.ReserveAccount !== '') && (this.ReservePassword !== ''))
.onClick(() => {
this.pathInfos.pushPathByName('home_page', null)
})
}
}
.navDestination(this.PageMap)
.height('100%')
.width('100%')
}
}
@Component
struct HomePage {
pathInfos: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Text("Home Page").commonTitleStyles()
}.width('100%').height('100%')
}.title("Home Page")
.onReady((context: NavDestinationContext) => {
this.pathInfos = context.pathStack;
})
}
}
@Extend(Text)
function commonTitleStyles() {
.fontSize(24)
.fontColor('#000000')
.fontWeight(FontWeight.Medium)
.margin({ top: 24, bottom: 16 })
}
@Extend(TextInput)
function commonInputStyles() {
.placeholderColor(0x182431)
.width('100%')
.opacity(0.6)
.placeholderFont({ size: 16, weight: FontWeight.Regular })
.margin({ top: 16 })
}
@Extend(Button)
function commonButtonStyles() {
.width('100%')
.height(40)
.borderRadius(20)
.margin({ top: 24 })
}
```
修改密码
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250414094252.13260329641797801223419211568175:50001231000000:2800:6CFB50ADBFED4550C45840E036B43DDF41F0BEA9277E7C977776EF7A9F383843.png)
示例代码如下：
```typescript
@Entry
@Component
struct RegisterExample {
pathInfos: NavPathStack = new NavPathStack();
@State ReserveAccount: string = '';
@State ReservePassword: string = '';
@State enAbleAutoFill: boolean = true;
onBackPress() {
// 当非成功登录、返回等页面跳转时将enAbleAutoFill设置为false，密码保险箱不使能
this.enAbleAutoFill = false;
return false;
}
@Builder
PageMap(name: string) {
if (name === 'register_result_page') {
RegisterResultPage()
}
}
build() {
Navigation(this.pathInfos) {
Column() {
Text("修改密码")
.commonTitleStyles()
TextInput({ placeholder: '用户名' })
.commonInputStyles()
.type(InputType.USER_NAME) // 账号框使用USER_NAME属性
.onChange((value: string) => {
this.ReserveAccount = value;
})
TextInput({ placeholder: '密码' })
.showPasswordIcon(true)
.commonInputStyles()
.type(InputType.Password)
.onChange((value: string) => {
this.ReservePassword = value;
})
TextInput({ placeholder: '新密码' })
.showPasswordIcon(true)
.commonInputStyles()
.type(InputType.NEW_PASSWORD) // 密码框使用 new Password 属性,可以触发生成强密码
.enableAutoFill(this.enAbleAutoFill)
.passwordRules('begin:[upper],special:[yes],len:[maxlen:32,minlen:12]')
.onChange((value: string) => {
this.ReservePassword = value;
})
Button('页面跳转')
.commonButtonStyles()
.enabled((this.ReserveAccount !== '') && (this.ReservePassword !== ''))
.onClick(() => {
this.pathInfos.pushPathByName('register_result_page', null)
})
Button('页面跳转(跳转前关闭autofill）')
.commonButtonStyles()
.enabled((this.ReserveAccount !== '') && (this.ReservePassword !== ''))
.onClick(() => {
this.enAbleAutoFill = false;
this.pathInfos.pushPathByName('register_result_page', null)
})
}
}
.navDestination(this.PageMap)
.height('100%')
.width('100%')
}
}
@Component
struct RegisterResultPage {
pathInfos: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Text("Result Page").commonTitleStyles()
}.width('100%').height('100%')
}.title("Result Page")
.onReady((context: NavDestinationContext) => {
this.pathInfos = context.pathStack;
})
}
}
@Extend(Text)
function commonTitleStyles() {
.fontSize(24)
.fontColor('#000000')
.fontWeight(FontWeight.Medium)
.margin({ top: 24, bottom: 16 })
}
@Extend(TextInput)
function commonInputStyles() {
.placeholderColor(0x182431)
.width('100%')
.opacity(0.6)
.placeholderFont({ size: 16, weight: FontWeight.Regular })
.margin({ top: 16 })
}
@Extend(Button)
function commonButtonStyles() {
.width('100%')
.height(40)
.borderRadius(20)
.margin({ top: 24 })
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/passwordvault-autofill-strong-password-V14
爬取时间: 2025-04-28 01:27:15
来源: Huawei Developer
密码保险箱可以在用户需要输入一个新密码时，自动生成一个高强度的密码。用户选择使用生成的强密码时可以将这个密码填充到新密码输入框。
触发条件及注意事项：
-  具体类型请参考输入框类型说明。
注册
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250414094252.40353052922392598191971195051082:50001231000000:2800:D1A3F6FF3F44D7354414FAC17E7F7BEC50BBEA4CA4059256F02B2B9FB9042BA4.png)
示例代码如下：
修改密码
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250414094252.79801236247546145349806396094527:50001231000000:2800:CEA83DEBDFCD22B42C330A03B8B29128A9C3915701CB41025FF4064E40BA40BA.png)
示例代码如下：
```typescript
@Component
struct RegisterExample {
pathInfos: NavPathStack = new NavPathStack();
@State ReserveAccount: string = '';
@State ReservePassword: string = '';
@State enAbleAutoFill: boolean = true;
onBackPress() {
// 当非成功登录、返回等页面跳转时将enAbleAutoFill设置为false，密码保险箱不使能
this.enAbleAutoFill = false;
return false;
}
@Builder
PageMap(name: string) {
if (name === 'register_result_page') {
RegisterResultPage()
}
}
build() {
Navigation(this.pathInfos) {
Column() {
Text("修改密码")
.commonTitleStyles()
TextInput({ placeholder: '用户名' })
.commonInputStyles()
.type(InputType.USER_NAME) // 账号框使用USER_NAME属性
.onChange((value: string) => {
this.ReserveAccount = value;
})
TextInput({ placeholder: '密码' })
.showPasswordIcon(true)
.commonInputStyles()
.type(InputType.Password)
.onChange((value: string) => {
this.ReservePassword = value;
})
TextInput({ placeholder: '新密码' })
.showPasswordIcon(true)
.commonInputStyles()
.type(InputType.NEW_PASSWORD) // 密码框使用 new Password 属性,可以触发生成强密码
.enableAutoFill(this.enAbleAutoFill)
.passwordRules('begin:[upper],special:[yes],len:[maxlen:32,minlen:12]')
.onChange((value: string) => {
this.ReservePassword = value;
})
Button('页面跳转')
.commonButtonStyles()
.enabled((this.ReserveAccount !== '') && (this.ReservePassword !== ''))
.onClick(() => {
this.pathInfos.pushPathByName('register_result_page', null)
})
Button('页面跳转(跳转前关闭autofill）')
.commonButtonStyles()
.enabled((this.ReserveAccount !== '') && (this.ReservePassword !== ''))
.onClick(() => {
this.enAbleAutoFill = false;
this.pathInfos.pushPathByName('register_result_page', null)
})
}
}
.navDestination(this.PageMap)
.height('100%')
.width('100%')
}
}
@Component
struct RegisterResultPage {
pathInfos: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Text("Result Page").commonTitleStyles()
}.width('100%').height('100%')
}.title("Result Page")
.onReady((context: NavDestinationContext) => {
this.pathInfos = context.pathStack;
})
}
}
@Extend(Text)
function commonTitleStyles() {
.fontSize(24)
.fontColor('#000000')
.fontWeight(FontWeight.Medium)
.margin({ top: 24, bottom: 16 })
}
@Extend(TextInput)
function commonInputStyles() {
.placeholderColor(0x182431)
.width('100%')
.opacity(0.6)
.placeholderFont({ size: 16, weight: FontWeight.Regular })
.margin({ top: 16 })
}
@Extend(Button)
function commonButtonStyles() {
.width('100%')
.height(40)
.borderRadius(20)
.margin({ top: 24 })
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/passwordvault-custom-strong-password-rules-V14
爬取时间: 2025-04-28 01:27:28
来源: Huawei Developer
在本文档中介绍的强密码特指，在密码保险箱强密码填充场景中，推荐用户使用的较强密码。强密码中一定包含大写字母、小写字母、数字三种字符。且强密码的复杂度高，破解难度大。
当开发者没有指定密码规则，或是开发者指定的规则书写错误、不符合规范时，密码保险箱会根据默认的规则生成符合开发者指定条件的强密码。开发者可以在允许的范围内指定强密码的规格，详见开发者可自定义的强密码规则。
默认强密码规则
当开发者没有指定规则，或是指定的密码规则不符合规范时，将按照以下默认规则生成强密码。
开发者可自定义的强密码规则
开发者可以设置新密码输入框的passwordRules属性来指定强密码规则。
强密码中一定包含大写字母、小写字母、数字三种字符。开发者可以按照以下指导对强密码规格做一些限定。
强密码规则包含3个属性：
3个属性可以任意选择，书写时顺序不做限制，属性之间以英文“，”进行分隔，每个属性只能出现一次。
各属性段请严格参照介绍进行书写，否则将导致指定规则不生效。
-  表示生成的强密码首位的字符类型，可选的值如下表所示。可以缺省，但不能填入其他值，填入其他值按照缺省规则处理。 取值 说明 upper 以大写字母开头。 lower 以小写字母开头。 digit 以数字开头。 不填 不填时，将以任意字母或数字0-9开头。 格式举例：
-  表示生成的强密码是否可以包含特殊字符。需要包含特殊字符时，请将该字段设置为"yes"；如不需要，不填写"special"字段。 当设置为"yes"时，生成的强密码中将包含至少一个特殊字符，特殊字符不会出现在强密码的首位。 强密码中可能出现的特殊字符包括：!@#$%^&* 格式举例：
-  表示生成的强密码长度。密码保险箱允许设定的强密码长度最小12位，最大32位。 强密码长度属性提供三个关键字用于描述长度。 关键字 说明 fixedlen 固定长度 minlen 最小长度 maxlen 最大长度 开发者可以根据以下方式指定强密码长度。如果开发者指定的密码长度数值不在有效范围[12, 32]内，将视为非法指定，系统将使用默认长度16位替代。
| 取值  | 说明  |
| --- | --- |
| upper  | 以大写字母开头。  |
| lower  | 以小写字母开头。  |
| digit  | 以数字开头。  |
| 不填  | 不填时，将以任意字母或数字0-9开头。  |
| 关键字  | 说明  |
| --- | --- |
| fixedlen  | 固定长度  |
| minlen  | 最小长度  |
| maxlen  | 最大长度  |
自定义规则样例说明
正确的规则样例如下：
| 强密码规则样例  | 规则释义  |
| --- | --- |
| begin:[upper],special:[yes],len:[maxlen:32,minlen:12]  | 以大写字母开头，包含大小写字母、数字、特殊字符，长度为12-32之间（包含12和32）的随机数值。  |
| begin:[lower],special:[yes],len:[maxlen:14]  | 以小写字母开头，包含大小写字母、数字、特殊字符，长度为14-32之间（包含14和32）的随机数值。  |
| begin:[digit],special:[yes],len:[fixedlen:15]  | 以数字开头，包含大小写字母、数字、特殊字符，长度为15。  |
| begin:[upper]  | 以大写字母开头，包含大小写字母、数字，长度为16。  |
| special:[yes]  | 以任意字母或数字开头，包含大小写字母、数字、特殊字符，长度为16。  |
| len:[fixedlen:15]  | 以任意字母或数字开头，包含大小写字母、数字，长度为15。  |
| begin:[upper],special:[yes]  | 以大写字母开头，包含大小写字母、数字、特殊字符,长度为16。  |
| begin:[lower],len:[maxlen:25,minlen:12]  | 以小写字母开头，包含大小写字母、数字，长度为12-25之间（包含12和25）的随机数值。  |
| special:[yes],len:[fixedlen:15]  | 以任意字母或数字开头，包含大小写字母、数字、特殊字符，长度为15。  |
强密码规则样例
规则释义
begin:[upper],special:[yes],len:[maxlen:32,minlen:12]
以大写字母开头，包含大小写字母、数字、特殊字符，长度为12-32之间（包含12和32）的随机数值。
begin:[lower],special:[yes],len:[maxlen:14]
以小写字母开头，包含大小写字母、数字、特殊字符，长度为14-32之间（包含14和32）的随机数值。
begin:[digit],special:[yes],len:[fixedlen:15]
以数字开头，包含大小写字母、数字、特殊字符，长度为15。
begin:[upper]
以大写字母开头，包含大小写字母、数字，长度为16。
special:[yes]
以任意字母或数字开头，包含大小写字母、数字、特殊字符，长度为16。
len:[fixedlen:15]
以任意字母或数字开头，包含大小写字母、数字，长度为15。
begin:[upper],special:[yes]
以大写字母开头，包含大小写字母、数字、特殊字符,长度为16。
begin:[lower],len:[maxlen:25,minlen:12]
以小写字母开头，包含大小写字母、数字，长度为12-25之间（包含12和25）的随机数值。
special:[yes],len:[fixedlen:15]
以任意字母或数字开头，包含大小写字母、数字、特殊字符，长度为15。
错误的规则用例如下：
| 强密码规则错误用例  | 错误原因  |
| --- | --- |
| begin:[uppper]  | begin属性的取值upper拼写错误。  |
| began:[upper]  | begin属性拼写错误。  |
| len:[15]  | len属性语法错误，未使用三种长度关键词。  |
| len:[fixedlen:15,maxlen:18]  | len属性语法错误，fixedlen与maxlen不可混用。  |
| len:[maxlen:15,minlen:18]  | len属性参数值错误，maxlen的取值不能小于minlen。  |
强密码规则错误用例
错误原因
begin:[uppper]
begin属性的取值upper拼写错误。
began:[upper]
begin属性拼写错误。
len:[15]
len属性语法错误，未使用三种长度关键词。
len:[fixedlen:15,maxlen:18]
len属性语法错误，fixedlen与maxlen不可混用。
len:[maxlen:15,minlen:18]
len属性参数值错误，maxlen的取值不能小于minlen。
示例

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/passwordvault-adaptation-in-custom-layout-V14
爬取时间: 2025-04-28 01:27:42
来源: Huawei Developer
登录
应用在设置“登录”页面时，需要“用户名/账号名”、“密码”在同一个界面，具体可参照账号密码保存-登录、账号密码填充-登录中的介绍。
注册
应用在设置“注册”页面时，需要“用户名/账号名”、“新密码”在同一个界面，具体可参照账号密码保存-注册、强密码填充-注册中的介绍。
修改密码
应用在设置“修改密码”页面时，需要“用户名/账号名”、“旧密码”、“新密码”在同一个界面，具体可参照账号密码更新-修改账号密码、账号密码填充-修改密码中的介绍。
登录、注册失败
当应用成功登录、成功注册后将账号密码保存至密码保险箱。但当应用没有成功登录或是没有成功注册时，通过页面路由（router）跳转返回，建议应用将enableAutofill属性为false，避免保存错误信息。
示例代码如下：
```typescript
@Entry
@Component
struct LoginExample {
pathInfos: NavPathStack = new NavPathStack();
@State ReserveAccount: string = '';
@State ReservePassword: string = '';
// 保存填充功能初始值：true
@State enAbleAutoFill: boolean = true;
onBackPress() {
// 当非成功登录、返回等页面跳转时将enAbleAutoFill设置为false，密码保险箱不使能
this.enAbleAutoFill = false;
return false;
}
@Builder
PageMap(name: string) {
if (name === 'home_page') {
HomePage()
}
}
build() {
Navigation(this.pathInfos) {
Column({ space: 16 }) {
Text("账户登录")
.commonTitleStyles()
TextInput({ placeholder: '账号' })
.commonInputStyles()
.type(InputType.USER_NAME)// 账号框使用USER_NAME属性
.enableAutoFill(this.enAbleAutoFill)// 保存填充功能属性
.onChange((value: string) => {
this.ReserveAccount = value;
})
TextInput({ placeholder: '密码' })
.commonInputStyles()
.showPasswordIcon(true)
.type(InputType.Password)// 密码框使用Password属性
.enableAutoFill(this.enAbleAutoFill)// 保存填充功能属性
.onChange((value: string) => {
this.ReservePassword = value;
})
Button('登录', { type: ButtonType.Capsule, stateEffect: false })
.borderRadius(20)
.width('100%')
.height(40)
.enabled((this.ReserveAccount !== '') && (this.ReservePassword !== ''))
.onClick(() => {
// 成功登录时页面跳转将enAbleAutoFill设置为true，密码保险箱使能
this.enAbleAutoFill = true;
this.pathInfos.pushPathByName('home_page', null)
})
}
.padding(16)
}
.navDestination(this.PageMap)
.height('100%')
.width('100%')
}
}
@Component
struct HomePage {
pathInfos: NavPathStack = new NavPathStack();
build() {
NavDestination() {
Column() {
Text("Home Page").commonTitleStyles()
}.width('100%').height('100%')
}.title("Home Page")
.onReady((context: NavDestinationContext) => {
this.pathInfos = context.pathStack;
})
}
}
@Extend(Text)
function commonTitleStyles() {
.fontSize(24)
.fontColor('#000000')
.fontWeight(FontWeight.Medium)
.margin({ top: 18 })
}
@Extend(TextInput)
function commonInputStyles() {
.placeholderColor(0x182431)
.width('100%')
.opacity(0.6)
.placeholderFont({ size: 16, weight: FontWeight.Regular })
}
```
将导致功能受限的布局
除了上述介绍中的典型场景外，以下界面布局使用密码保险箱功能受限：
| 实现场景  | 布局情况  | 账号密码填充  | 强密码填充  | 自动保存  |
| --- | --- | --- | --- | --- |
| 登录  | 用户名、密码不在同一界面  | 不支持  | 不支持  | 不支持  |
| 验证码登录  | 不支持  | 不支持  | 不支持  |
| 注册  | 用户名、密码不在同一界面  | 不支持  | 不支持  | 不支持  |
| 修改密码  | 界面只有用户名、新密码  | 不支持  | 支持  | 支持  |
| 界面只有旧密码、新密码  | 不支持  | 不支持  | 不支持  |
| 界面只有新密码  | 不支持  | 不支持  | 不支持  |
实现场景
布局情况
账号密码填充
强密码填充
自动保存
登录
用户名、密码不在同一界面
不支持
不支持
不支持
验证码登录
不支持
不支持
不支持
注册
用户名、密码不在同一界面
不支持
不支持
不支持
修改密码
界面只有用户名、新密码
不支持
支持
支持
界面只有旧密码、新密码
不支持
不支持
不支持
界面只有新密码
不支持
不支持
不支持

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/passwordvault-special-scenarios-V14
爬取时间: 2025-04-28 01:27:56
来源: Huawei Developer
考虑到实际场景的多样性，除了上述接入示例中的场景外，密码保险箱针对部分场景的非标准场景进行了适配，可支持使用邮箱、手机号作为用户名登录、注册的场景。
当页面上存在一个Password/NEW_PASSWORD类型输入框，且页面上同时存在USER_NAME、Email、PhoneNumber类型输入框中的一种时，会正常触发密码保险箱保存和填充的能力。
当页面上仅有两个TextInput输入框，且其中一个为Password/NEW_PASSWORD类型，另外一个为非密码类型时，也会正常触发密码保险箱逻辑。具体类型请参考输入框类型说明。
密码保险箱当前支持的所有场景：
-  输入框类型 密码保险箱的表现 InputType.USER_NAME / InputType.Email / InputType.PhoneNumber输入框 + InputType.Password输入框 非密码类型输入框 + InputType.Password输入框 InputType.USER_NAME / InputType.Email / InputType.PhoneNumber输入框 + InputType.NEW_PASSWORD输入框 非密码类型输入框 + InputType.NEW_PASSWORD输入框
-  输入框类型 密码保险箱的表现 含InputType.USER_NAME / InputType.Email / InputType.PhoneNumber其中一种或多种 + 含InputType.Password输入框 含InputType.USER_NAME / InputType.Email / InputType.PhoneNumber其中一种或多种  + 含InputType.NEW_PASSWORD输入框 含InputType.USER_NAME / InputType.Email / InputType.PhoneNumber其中一种或多种 + 含InputType.Password输入框 +  含InputType.NEW_PASSWORD输入框
| 输入框类型  | 密码保险箱的表现  |
| --- | --- |
| InputType.USER_NAME / InputType.Email / InputType.PhoneNumber输入框 + InputType.Password输入框  | 点击其中一个输入框，触发账号密码填充提示。页面跳转时，自动弹出账号密码保存提示框。  |
| 非密码类型输入框 + InputType.Password输入框  | 点击其中一个输入框，触发账号密码填充提示。页面跳转时，自动弹出账号密码保存提示框。  |
| InputType.USER_NAME / InputType.Email / InputType.PhoneNumber输入框 + InputType.NEW_PASSWORD输入框  | 点击新密码输入框（InputType.NEW_PASSWORD），触发强密码填充。页面跳转时，如果直接使用生成的强密码，将静默保存到密码保险箱；如果使用自定义密码，即未使用或修改了生成的强密码，将弹出账号密码保存提示框。  |
| 非密码类型输入框 + InputType.NEW_PASSWORD输入框  | 点击新密码输入框（InputType.NEW_PASSWORD），触发强密码填充。页面跳转时，如果直接使用生成的强密码，将静默保存到密码保险箱；如果使用自定义密码，即未使用或修改了生成的强密码，将弹出账号密码保存提示框。  |
| 输入框类型  | 密码保险箱的表现  |
| --- | --- |
| 含InputType.USER_NAME / InputType.Email / InputType.PhoneNumber其中一种或多种 + 含InputType.Password输入框  | 点击其中一个输入框，触发账号密码填充提示。页面跳转时，自动弹出账号密码保存提示框。保存账号密码时，优先保存USER_NAME输入框的内容作为账户名。  |
| 含InputType.USER_NAME / InputType.Email / InputType.PhoneNumber其中一种或多种  + 含InputType.NEW_PASSWORD输入框  | 点击新密码输入框（InputType.NEW_PASSWORD），触发强密码填充。页面跳转时，如果直接使用生成的强密码，将静默保存到密码保险箱；如果使用自定义密码，即未使用或修改了生成的强密码，将弹出账号密码保存提示框。保存账号密码时，优先保存USER_NAME输入框的内容作为账户名。  |
| 含InputType.USER_NAME / InputType.Email / InputType.PhoneNumber其中一种或多种 + 含InputType.Password输入框 +  含InputType.NEW_PASSWORD输入框  | 点击其中一个输入框，触发账号密码填充提示。点击新密码输入框（InputType.NEW_PASSWORD），触发强密码填充。页面跳转时，如果直接使用生成的强密码，将静默保存到密码保险箱；如果使用自定义密码，即未使用或修改了生成的强密码，将弹出账号密码保存提示框。保存账号密码时，优先保存USER_NAME输入框的内容作为账户名。  |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/arkweb-access-password-safe-V14
爬取时间: 2025-04-28 01:28:10
来源: Huawei Developer
网页中的登录表单，登录成功后，用户可将用户名和密码保存到鸿蒙系统密码保险箱中。再次打开该网页时，密码保险箱可以提供用户名、密码的自动填充。
手机使用场景
以下以https://developer.huawei.com/网站为例：
1.
2.
3.
4.
5.  点击用户名可触发在网页中填入用户名、密码；点击钥匙图标，进入选择账号的界面。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170431.01538648360905666400432894723031:50001231000000:2800:CB87EBDC854E0EAFE4D4E71F2CF34A96673547B118278A106E0BEE665EFC02F1.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170431.27166677015976900413343062863457:50001231000000:2800:01BA7122AC9431F140092BB3F109D86ED73634F37B00D376E44DF17871648ABB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170431.70393660892838280353907471782351:50001231000000:2800:C56954F04C4B94A23071F0B15AEEA73CE54FF49249ED90354E151FDF0B8D65B2.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170431.92460920541266615824381931111594:50001231000000:2800:34517C065E588622DA158A09EF9807288D3C06D7CCAD2C74A51C3D4E4D01873E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170431.79296998933590942337513236414860:50001231000000:2800:9E69291641A90BB00036FF0E99A191873C3AF8F57E8629FEAA08096707BD799D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170431.59278181759698604565391398472910:50001231000000:2800:606296E03CDFFD36CF406EE8829B095DDE743863DE7DA369C27433A5E694667C.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170431.73885136099676250728774730706028:50001231000000:2800:471CD115EE98A39E5FB59BF359CB5BEC6A24FFE031BB6F88BF0E56D2FEAACEB7.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170431.64784929165638406779581917014441:50001231000000:2800:A1FF969D050D02C619B104F579E19EA5E6F0261F289D190EAB9FF6027D3A096F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170431.38303125526277978738755041188076:50001231000000:2800:6279A7929867B09AA59D78EEFF623374E324FD306DE92C885E3C65C07825FDA6.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170431.57553931273200373490789687828456:50001231000000:2800:CB45CA7214EE3D893E302776560424E3C573612A131BDA39CD29EC8ADFAB8CBF.png)
2in1使用场景
以下以https://developer.huawei.com/网站为例：
1.
2.
3.
4.
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170431.83853888025737401375231071240616:50001231000000:2800:9C72ECE0D17E9BCBBAC132DBC87D7A1C175B21CC35FCC362149E1F00465A581D.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170431.49294741641234617879248149981386:50001231000000:2800:8A8BB81F292F541DED5D608D63C2829C050531A485DA81BC5FF1C90241D6A8BB.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170431.75944190206202373724727218598561:50001231000000:2800:1C84EEAFC850427A4EB3024A78142E1C1E79512DF6436EDEEFA476DFF36DAE5E.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170432.33525015177865299689687505624731:50001231000000:2800:FCAEDED18B55054E7EBE8C6A1FEEF8C3CB87B113A5552C064B24EFDCB1F936DD.png)
网页密码保存规格
1、ArkWeb依赖密码表单提交成功后，触发页面跳转到其他页面，才能触发密码保存。
2、Native应用通过ArkWeb实现H5登入，登录成功后请勿立即销毁ArkWeb实例，将无法提示密码保存。
网页密码表单规格
ArkWeb使用Chromium智能算法，自动识别网页中的用户名、密码元素。算法对用户名、密码表单的设计，有一定的约束。
推荐的密码登录表单
【案例1】：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170432.10075826060886818351083121252198:50001231000000:2800:94EBF9CFD02E65E6C3A88962F1C30F5410FBE847CA8C9615CD0134BB2D1B0E41.png)
【案例2】：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170432.81705193502972456849377698995257:50001231000000:2800:E57611B63272C2B9928D514BDFB786005923CF824B0FFECE6A2BF0F754250971.png)
不支持自动填充的密码登录表单类型

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/password-shared-apps-web-pages-V14
爬取时间: 2025-04-28 01:28:24
来源: Huawei Developer
简介
密码保险箱支持在应用和网页中保存和填充账号密码，为了提供更好的密码管理体验，提供了应用和网页共用账号数据的能力。
当接入本能力后，触发填充能力将优先推荐当前应用/网页的保存的账号，如当前应用/网页没有保存的账号时，则会推荐相关联网页/应用的账号。
同时，选择密码时也会将关联网站/应用的密码展示为推荐密码。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170432.94899130041017345210257733164838:50001231000000:2800:9D08140F4EB5112446548F44FA3967E656D53383074912887CFBD67285BB73FD.png)
适用场景
当应用和网页均存在账号密码登录场景，且已经接入密码保险箱能力的情况下，期望其中一方保存密码之后，能够直接在另一方进行使用时，可以通过本能力进行实现。
接入方式
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170432.34871151858882701618332473303081:50001231000000:2800:B1F4218A38A9CEF2F7505942409EA8E063C9BCF0DB3B891A67D49E3FA78D59CD.png)
应用及网页接入App Linking后绑定关联关系，密码保险箱将基于这个关系完成识别。
完成如下配置，即可实现共用密码的能力：
1.  接入参考：应用接入密码保险箱、网页接入密码保险箱
2.  接入需完成三步：在AGC控制台开通App Linking服务>在开发者网站上关联应用>配置网址域名

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-store-kit-V14
爬取时间: 2025-04-28 01:28:37
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-store-kit-overview-V14
爬取时间: 2025-04-28 01:28:51
来源: Huawei Developer
Asset Store Kit（关键资产存储开发套件）包含了关键资产存储服务（ASSET）开放的接口能力集合，提供了用户短敏感数据的安全存储及管理能力。其中，短敏感数据可以是密码类（账号/密码）、Token类（应用凭据）、其他关键明文（如银行卡号）等长度较短的用户敏感数据。
基本概念
关键资产的安全存储，依赖底层的通用密钥库系统。具体来说，关键资产的加/解密操作以及访问控制校验，都由通用密钥库系统在安全环境（如可信执行环境）中完成，即使系统被攻破，也能保证用户敏感数据不发生泄露。
其中，关键资产的加/解密使用AES256-GCM算法，关键资产的访问控制分为以下几类：
-  基于属主的访问控制：所有的关键资产都受属主访问控制保护，业务无需设置。
-  基于锁屏状态的访问控制：分为以下三种保护等级（安全性依次递增），业务可根据实际情况设置任意一种，若不设置，则默认保护等级为“首次解锁后可访问”。
-  基于锁屏密码设置状态的访问控制：该访问控制默认不开启，业务可根据实际情况决定是否开启。
-  基于用户认证的访问控制：该访问控制默认不开启，业务可根据实际情况决定是否开启。
约束与限制
-  基于别名的访问 关键资产以密文的形式存储在ASSET数据库中，以业务身份 + 别名作为唯一索引。故业务需要保证每条关键资产的别名唯一。
-  批量查询关键资产 批量查询出的关键资产需要通过IPC通道传输给业务，受IPC缓冲区大小限制，建议对查询超过40条关键资产时，进行分批查询，且每次查询数量不超过40条。
-  业务自定义数据存储 ASSET为业务预留了12个关键资产自定义属性，名称以"DATA_LABEL"开头。对于超过12个自定义属性的情况，业务可以将多段数据按照一定的格式（如JSON）拼接到同一个ASSET属性中。 ASSET对部分属性会进行完整性保护，这部分属性名称以"DATA_LABEL_CRITICAL"开头，写入后不支持更新。
-  关键资产删除时机
与相关Kit的关系
关键资产存储服务仅提供短敏感数据（不超过1KB）的安全存储能力，如业务希望对超长的数据提供保护时，请考虑使用通用密钥库系统或加解密算法库框架保护您的数据。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-scenarios-V14
爬取时间: 2025-04-28 01:29:05
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-scenario1-V14
爬取时间: 2025-04-28 01:29:18
来源: Huawei Developer
密码类数据可以是密码、登录令牌、信用卡号等用户敏感数据。
场景描述
用户在应用/浏览器中登录账号时，可以选择“记住密码”（如图）。针对此种场景，应用/浏览器可以将用户密码存储在ASSET中，由ASSET保证用户密码的安全性。
用户再次打开登录界面时，应用/浏览器可以从ASSET中查询用户密码，并将其自动填充到密码输入框，用户只需点击“登录”按钮即可完成账号登录，极大地提升了用户体验。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170432.90333288185509474372027889340255:50001231000000:2800:26D0D1B2566C2AB42D7B62EED61C79AC082112DE0D4E69F16E71C94623BDAF7B.png)
关键流程
业务调用ASSET保护密码类数据（后文统称为“关键资产”），可以参照以下流程进行开发。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170432.56679393190698616830157152456989:50001231000000:2800:C80C4E864FE8B7769ACBCDE1BA9E1D9369C86D17B91239A7635776AE2031195D.png)
1.  业务查询符合条件的关键资产属性，根据查询成功/失败，判断关键资产是否存在。 开发步骤参考查询关键资产(ArkTS)/查询关键资产(C/C++)，代码示例参考查询单条关键资产属性(ArkTS)/查询单条关键资产属性(C/C++)。
2.  如果关键资产不存在，业务可选择：
3.  如果关键资产存在，业务可选择：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-scenario2-V14
爬取时间: 2025-04-28 01:29:32
来源: Huawei Developer
密码类数据可以是密码、登录令牌、信用卡号等用户敏感数据。
场景描述
用户在金融/银行类应用中查看银行卡号时，需要核实用户身份为持卡人本人。针对此种场景，应用可以将银行卡号存储到ASSET中，同时设置访问银行卡号需要用户身份认证。
用户查看银行卡号时，应用请求用户进行身份认证（比如通过验证锁屏密码或生物特征），身份校验通过后，应用查询并向用户展示银行卡号，极大地提升了用户安全体验。
关键流程
业务调用ASSET保护需要用户认证的关键资产，可以参照以下流程进行开发。
由于统一用户认证（UserIAM）只提供ArkTS接口，故本场景只支持使用ArkTS语言开发。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170433.18075217110589928720738934456748:50001231000000:2800:CF510F1CE3BC808768D7A8BC4423FFA9E624C4C1AD0761F6C06F83C3B5D41081.png)
1.  业务查询符合条件的关键资产属性，根据查询成功/失败，判断关键资产是否存在。 开发步骤参考查询关键资产，代码示例参考查询单条关键资产属性。
2.  如果关键资产不存在，业务可选择：
3.  如果关键资产存在，业务可选择：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-arkts-V14
爬取时间: 2025-04-28 01:29:46
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-js-add-V14
爬取时间: 2025-04-28 01:29:59
来源: Huawei Developer
接口介绍
可通过API文档查看新增关键资产的异步接口add(attributes: AssetMap)、同步接口addSync(attributes: AssetMap)的详细介绍。
在新增关键资产时，关键资产属性的内容（AssetMap）参数如下表所示：
下表中名称包含“DATA_LABEL”的关键资产属性，用于存储业务自定义信息，其内容不会被加密，请勿存放个人数据。
| 属性名称（Tag） | 属性内容（Value） | 是否必选 | 说明 |
| --- | --- | --- | --- |
| SECRET | 类型为Uint8Array，长度为1-1024字节。 | 必选 | 关键资产明文。 |
| ALIAS | 类型为Uint8Array，长度为1-256字节。 | 必选 | 关键资产别名，每条关键资产的唯一索引。 |
| ACCESSIBILITY | 类型为number，取值范围详见Accessibility。 | 可选 | 基于锁屏状态的访问控制。 |
| REQUIRE_PASSWORD_SET | 类型为bool。 | 可选 | 是否仅在设置了锁屏密码的情况下，可访问关键资产。 |
| AUTH_TYPE | 类型为number，取值范围详见AuthType。 | 可选 | 访问关键资产所需的用户认证类型。 |
| SYNC_TYPE | 类型为number，取值范围详见SyncType。 | 可选 | 关键资产支持的同步类型。 |
| IS_PERSISTENT | 类型为bool。 | 可选 | 在应用卸载时是否需要保留关键资产。 注意： 设置此属性时，需申请权限ohos.permission.STORE_PERSISTENT_DATA。 |
| DATA_LABEL_CRITICAL_1 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_2 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_3 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_4 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_1 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_2 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_3 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_4 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_LOCAL_112+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_212+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_312+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_412+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| CONFLICT_RESOLUTION | 类型为number，取值范围详见ConflictResolution。 | 可选 | 新增关键资产时的冲突（如：别名相同）处理策略。 |
| REQUIRE_ATTR_ENCRYPTED14+ | 类型为bool。 | 可选 | 是否加密业务自定义附属信息，默认不需要加密。 |
在应用卸载时是否需要保留关键资产。
注意：设置此属性时，需申请权限ohos.permission.STORE_PERSISTENT_DATA。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
约束和限制
-  基于别名的访问 关键资产以密文的形式存储在ASSET数据库中，以业务身份 + 别名作为唯一索引。故业务需要保证每条关键资产的别名唯一。
-  业务自定义数据存储 ASSET为业务预留了12个关键资产自定义属性，名称以"DATA_LABEL"开头。对于超过12个自定义属性的情况，业务可以将多段数据按照一定的格式（如JSON）拼接到同一个ASSET属性中。 ASSET对部分属性会进行完整性保护，这部分属性名称以"DATA_LABEL_CRITICAL"开头，写入后不支持更新。
代码示例
本模块提供了异步和同步两套接口，以下为异步接口的使用示例，同步接口详见API文档。
新增一条密码是demo_pwd，别名是demo_alias，附属信息是demo_label的数据，该数据在用户首次解锁设备后可被访问。
```typescript
import { asset } from '@kit.AssetStoreKit';
import { util } from '@kit.ArkTS';
import { BusinessError } from '@kit.BasicServicesKit';
function stringToArray(str: string): Uint8Array {
let textEncoder = new util.TextEncoder();
return textEncoder.encodeInto(str);
}
let attr: asset.AssetMap = new Map();
attr.set(asset.Tag.SECRET, stringToArray('demo_pwd'));
attr.set(asset.Tag.ALIAS, stringToArray('demo_alias'));
attr.set(asset.Tag.ACCESSIBILITY, asset.Accessibility.DEVICE_FIRST_UNLOCKED);
attr.set(asset.Tag.DATA_LABEL_NORMAL_1, stringToArray('demo_label'));
try {
asset.add(attr).then(() => {
console.info(`Asset added successfully.`);
}).catch((err: BusinessError) => {
console.error(`Failed to add Asset. Code is ${err.code}, message is ${err.message}`);
})
} catch (error) {
let err = error as BusinessError;
console.error(`Failed to add Asset. Code is ${err.code}, message is ${err.message}`);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-js-remove-V14
爬取时间: 2025-04-28 01:30:13
来源: Huawei Developer
接口介绍
可通过API文档查询删除关键资产的异步接口remove(query: AssetMap)、同步接口removeSync(query: AssetMap)的详细介绍。
在删除关键资产时，关键资产属性的内容（AssetMap）参数如下表所示：
下表中名称包含“DATA_LABEL”的关键资产属性，用于存储业务自定义信息，其内容不会被加密，请勿存放个人数据。
| 属性名称（Tag） | 属性内容（Value） | 是否必选 | 说明 |
| --- | --- | --- | --- |
| ALIAS | 类型为Uint8Array，长度为1-256字节。 | 可选 | 关键资产别名，每条关键资产的唯一索引。 |
| ACCESSIBILITY | 类型为number，取值范围详见Accessibility。 | 可选 | 基于锁屏状态的访问控制。 |
| REQUIRE_PASSWORD_SET | 类型为bool。 | 可选 | 是否仅在设置了锁屏密码的情况下，可访问关键资产。 |
| AUTH_TYPE | 类型为number，取值范围详见AuthType。 | 可选 | 访问关键资产所需的用户认证类型。 |
| SYNC_TYPE | 类型为number，取值范围详见SyncType。 | 可选 | 关键资产支持的同步类型。 |
| IS_PERSISTENT | 类型为bool。 | 可选 | 在应用卸载时是否需要保留关键资产。 |
| DATA_LABEL_CRITICAL_1 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_2 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_3 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_4 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_1 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_2 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_3 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_4 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_LOCAL_112+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_212+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_312+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_412+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| REQUIRE_ATTR_ENCRYPTED14+ | 类型为bool。 | 可选 | 是否删除业务自定义附属信息被加密的数据，默认删除业务附属信息不加密的数据。 |
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
代码示例
本模块提供了异步和同步两套接口，以下为异步接口的使用示例，同步接口详见API文档。
删除一条别名是demo_alias的关键资产。
```typescript
import { asset } from '@kit.AssetStoreKit';
import { util } from '@kit.ArkTS';
import { BusinessError } from '@kit.BasicServicesKit';
function stringToArray(str: string): Uint8Array {
let textEncoder = new util.TextEncoder();
return textEncoder.encodeInto(str);
}
let query: asset.AssetMap = new Map();
query.set(asset.Tag.ALIAS, stringToArray('demo_alias')); // 此处指定别名删除单条数据，也可不指定别名删除多条数据
try {
asset.remove(query).then(() => {
console.info(`Asset removed successfully.`);
}).catch((err: BusinessError) => {
console.error(`Failed to remove Asset. Code is ${err.code}, message is ${err.message}`);
});
} catch (error) {
let err = error as BusinessError;
console.error(`Failed to remove Asset. Code is ${err.code}, message is ${err.message}`);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-js-update-V14
爬取时间: 2025-04-28 01:30:27
来源: Huawei Developer
接口介绍
可通过API文档查看更新关键资产的异步接口update(query: AssetMap, attributesToUpdate: AssetMap)、同步接口updateSync(query: AssetMap, attributesToUpdate: AssetMap)的详细介绍。
在更新关键资产时，关键资产属性的内容（AssetMap）参数如下表所示：
下表中名称包含“DATA_LABEL”的关键资产属性，用于存储业务自定义信息，其内容不会被加密，请勿存放个人数据。
-  query的参数列表： 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。
-  attributesToUpdate的参数列表： 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。
| 属性名称（Tag） | 属性内容（Value） | 是否必选 | 说明 |
| --- | --- | --- | --- |
| ALIAS | 类型为Uint8Array，长度为1-256字节。 | 必选 | 关键资产别名，每条关键资产的唯一索引。 |
| ACCESSIBILITY | 类型为number，取值范围详见Accessibility。 | 可选 | 基于锁屏状态的访问控制。 |
| REQUIRE_PASSWORD_SET | 类型为bool。 | 可选 | 是否仅在设置了锁屏密码的情况下，可访问关键资产。 |
| AUTH_TYPE | 类型为number，取值范围详见AuthType。 | 可选 | 访问关键资产所需的用户认证类型。 |
| SYNC_TYPE | 类型为number，取值范围详见SyncType。 | 可选 | 关键资产支持的同步类型。 |
| IS_PERSISTENT | 类型为bool。 | 可选 | 在应用卸载时是否需要保留关键资产。 |
| DATA_LABEL_CRITICAL_1 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_2 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_3 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_4 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_1 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_2 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_3 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_4 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_LOCAL_112+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_212+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_312+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_412+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| 属性名称（Tag） | 属性内容（Value） | 是否必选 | 说明 |
| --- | --- | --- | --- |
| SECRET | 类型为Uint8Array，长度为1-1024字节。 | 可选 | 关键资产明文。 |
| DATA_LABEL_NORMAL_1 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_2 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_3 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_4 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_LOCAL_112+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_212+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_312+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_412+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| REQUIRE_ATTR_ENCRYPTED14+ | 类型为bool。 | 可选 | 是否更新业务自定义附属信息被加密的数据，默认更新业务附属信息不加密的数据。 |
代码示例
本模块提供了异步和同步两套接口，以下为异步接口的使用示例，同步接口详见API文档。
更新别名是demo_alias的关键资产，将关键资产明文更新为demo_pwd_new，附属属性更新成demo_label_new。
```typescript
import { asset } from '@kit.AssetStoreKit';
import { util } from '@kit.ArkTS';
import { BusinessError } from '@kit.BasicServicesKit';
function stringToArray(str: string): Uint8Array {
let textEncoder = new util.TextEncoder();
return textEncoder.encodeInto(str);
}
let query: asset.AssetMap = new Map();
query.set(asset.Tag.ALIAS, stringToArray('demo_alias'));
let attrsToUpdate: asset.AssetMap = new Map();
attrsToUpdate.set(asset.Tag.SECRET, stringToArray('demo_pwd_new'));
attrsToUpdate.set(asset.Tag.DATA_LABEL_NORMAL_1, stringToArray('demo_label_new'));
try {
asset.update(query, attrsToUpdate).then(() => {
console.info(`Asset updated successfully.`);
}).catch((err: BusinessError) => {
console.error(`Failed to update Asset. Code is ${err.code}, message is ${err.message}`);
});
} catch (error) {
let err = error as BusinessError;
console.error(`Failed to update Asset. Code is ${err.code}, message is ${err.message}`);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-js-query-V14
爬取时间: 2025-04-28 01:30:41
来源: Huawei Developer
接口介绍
可通过API文档查询新增关键资产的异步接口query(query: AssetMap)、同步接口querySync(query: AssetMap)的详细介绍。
在查询关键资产时，关键资产属性的内容（AssetMap）参数如下表所示：
下表中名称包含“DATA_LABEL”的关键资产属性，用于存储业务自定义信息，其内容不会被加密，请勿存放个人数据。
| 属性名称（Tag） | 属性内容（Value） | 是否必选 | 说明 |
| --- | --- | --- | --- |
| ALIAS | 类型为Uint8Array，长度为1-256字节。 | 可选 | 关键资产别名，每条关键资产的唯一索引。 |
| ACCESSIBILITY | 类型为number，取值范围详见Accessibility。 | 可选 | 基于锁屏状态的访问控制。 |
| REQUIRE_PASSWORD_SET | 类型为bool。 | 可选 | 是否仅在设置了锁屏密码的情况下，可访问关键资产。 |
| AUTH_TYPE | 类型为number，取值范围详见AuthType。 | 可选 | 访问关键资产所需的用户认证类型。 |
| SYNC_TYPE | 类型为number，取值范围详见SyncType。 | 可选 | 关键资产支持的同步类型。 |
| IS_PERSISTENT | 类型为bool。 | 可选 | 在应用卸载时是否需要保留关键资产。 |
| DATA_LABEL_CRITICAL_1 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_2 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_3 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_4 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_1 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_2 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_3 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_4 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_LOCAL_112+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_212+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_312+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_412+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| RETURN_TYPE | 类型为number，取值范围详见ReturnType。 | 可选 | 关键资产查询返回的结果类型。 |
| RETURN_LIMIT | 类型为number。 | 可选 | 关键资产查询返回的结果数量。 |
| RETURN_OFFSET | 类型为number，取值范围：1-65536。 | 可选 | 关键资产查询返回的结果偏移量。 说明： 用于分批查询场景，指定从第几个开始返回。 |
| RETURN_ORDERED_BY | 类型为number，取值范围：asset.Tag.DATA_LABEL_xxx。 | 可选 | 关键资产查询返回的结果排序依据，仅支持按照附属信息排序。 说明： 默认按照关键资产新增的顺序返回。 |
| REQUIRE_ATTR_ENCRYPTED14+ | 类型为bool。 | 可选 | 是否查询业务自定义附属信息被加密的数据，默认查询业务附属信息不加密的数据。 |
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产查询返回的结果偏移量。
说明：用于分批查询场景，指定从第几个开始返回。
关键资产查询返回的结果排序依据，仅支持按照附属信息排序。
说明：默认按照关键资产新增的顺序返回。
约束和限制
批量查询出的关键资产需要通过IPC通道传输给业务，受IPC缓冲区大小限制，建议对查询超过40条关键资产时，进行分批查询，且每次查询数量不超过40条。
代码示例
本模块提供了异步和同步两套接口，以下为异步接口的使用示例，同步接口详见API文档。
查询单条关键资产明文
查询别名是demo_alias的关键资产明文。
```typescript
import { asset } from '@kit.AssetStoreKit';
import { util } from '@kit.ArkTS';
import { BusinessError } from '@kit.BasicServicesKit';
function stringToArray(str: string): Uint8Array {
let textEncoder = new util.TextEncoder();
return textEncoder.encodeInto(str);
}
function arrayToString(arr: Uint8Array): string {
let textDecoder = util.TextDecoder.create("utf-8", { ignoreBOM: true });
let str = textDecoder.decodeToString(arr, { stream: false })
return str;
}
let query: asset.AssetMap = new Map();
query.set(asset.Tag.ALIAS, stringToArray('demo_alias')); // 指定了关键资产别名，最多查询到一条满足条件的关键资产
query.set(asset.Tag.RETURN_TYPE, asset.ReturnType.ALL);  // 此处表示需要返回关键资产的所有信息，即属性+明文
try {
asset.query(query).then((res: Array<asset.AssetMap>) => {
for (let i = 0; i < res.length; i++) {
// parse the secret.
let secret: Uint8Array = res[i].get(asset.Tag.SECRET) as Uint8Array;
// parse uint8array to string
let secretStr: string = arrayToString(secret);
}
}).catch ((err: BusinessError) => {
console.error(`Failed to query Asset. Code is ${err.code}, message is ${err.message}`);
});
} catch (error) {
let err = error as BusinessError;
console.error(`Failed to query Asset. Code is ${err.code}, message is ${err.message}`);
}
```
查询单条关键资产属性
查询别名是demo_alias的关键资产属性。
```typescript
import { asset } from '@kit.AssetStoreKit';
import { util } from '@kit.ArkTS';
import { BusinessError } from '@kit.BasicServicesKit';
function stringToArray(str: string): Uint8Array {
let textEncoder = new util.TextEncoder();
return textEncoder.encodeInto(str);
}
let query: asset.AssetMap = new Map();
query.set(asset.Tag.ALIAS, stringToArray('demo_alias'));       // 指定了关键资产别名，最多查询到一条满足条件的关键资产
query.set(asset.Tag.RETURN_TYPE, asset.ReturnType.ATTRIBUTES); // 此处表示仅返回关键资产属性，不包含关键资产明文
try {
asset.query(query).then((res: Array<asset.AssetMap>) => {
for (let i = 0; i < res.length; i++) {
// parse the attribute.
let accessibility: number = res[i].get(asset.Tag.ACCESSIBILITY) as number;
}
}).catch ((err: BusinessError) => {
console.error(`Failed to query Asset. Code is ${err.code}, message is ${err.message}`);
});
} catch (error) {
let err = error as BusinessError;
console.error(`Failed to query Asset. Code is ${err.code}, message is ${err.message}`);
}
```
批量查询关键资产属性
批量查询标签1是demo_label的关键资产属性，从第5条满足条件的结果开始返回，一共返回10条，且返回结果以DATA_LABEL_NORMAL_1属性内容排序。
```typescript
import { asset } from '@kit.AssetStoreKit';
import { util } from '@kit.ArkTS';
import { BusinessError } from '@kit.BasicServicesKit';
function stringToArray(str: string): Uint8Array {
let textEncoder = new util.TextEncoder();
return textEncoder.encodeInto(str);
}
let query: asset.AssetMap = new Map();
query.set(asset.Tag.RETURN_TYPE, asset.ReturnType.ATTRIBUTES); // 此处表示仅返回关键资产属性，不包含关键资产明文
query.set(asset.Tag.DATA_LABEL_NORMAL_1, stringToArray('demo_label'));
query.set(asset.Tag.RETURN_OFFSET, 5); // 此处表示查询结果的偏移量，即从满足条件的第5条关键资产开始返回
query.set(asset.Tag.RETURN_LIMIT, 10); // 此处表示查询10条满足条件的关键资产
query.set(asset.Tag.RETURN_ORDERED_BY, asset.Tag.DATA_LABEL_NORMAL_1); // 此处查询结果以DATA_LABEL_NORMAL_1属性内容排序
try {
asset.query(query).then((res: Array<asset.AssetMap>) => {
for (let i = 0; i < res.length; i++) {
// parse the attribute.
let accessibility: number = res[i].get(asset.Tag.ACCESSIBILITY) as number;
}
}).catch ((err: BusinessError) => {
console.error(`Failed to query Asset. Code is ${err.code}, message is ${err.message}`);
});
} catch (error) {
let err = error as BusinessError;
console.error(`Failed to query Asset. Code is ${err.code}, message is ${err.message}`);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-js-query-auth-V14
爬取时间: 2025-04-28 01:30:54
来源: Huawei Developer
接口介绍
可通过API文档查看此功能的相关接口：
| 异步接口 | 同步接口 | 说明 |
| --- | --- | --- |
| preQuery(query: AssetMap) | preQuerySync(query: AssetMap) | 查询预处理。 |
| query(query: AssetMap) | querySync(query: AssetMap) | 查询关键资产。 |
| postQuery(handle: AssetMap) | postQuerySync(handle: AssetMap) | 查询后置处理。 |
在查询需要用户认证的关键资产时，关键资产属性的内容（AssetMap）参数如下表所示：
下表中名称包含“DATA_LABEL”的关键资产属性，用于存储业务自定义信息，其内容不会被加密，请勿存放个人数据。
-  preQuery参数列表 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。
-  query参数列表 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。
-  postQuery参数列表
| 属性名称（Tag） | 属性内容（Value） | 是否必选 | 说明 |
| --- | --- | --- | --- |
| ALIAS | 类型为Uint8Array，长度为1-256字节。 | 可选 | 关键资产别名，每条关键资产的唯一索引。 |
| ACCESSIBILITY | 类型为number，取值范围详见Accessibility。 | 可选 | 基于锁屏状态的访问控制。 |
| REQUIRE_PASSWORD_SET | 类型为bool。 | 可选 | 是否仅在设置了锁屏密码的情况下，可访问关键资产。 |
| AUTH_TYPE | 类型为number，取值范围详见AuthType。 | 可选 | 访问关键资产所需的用户认证类型。 |
| AUTH_VALIDITY_PERIOD | 类型为number，取值范围：1-600，单位为秒。 | 可选 | 用户认证的有效期。 |
| SYNC_TYPE | 类型为number，取值范围详见SyncType。 | 可选 | 关键资产支持的同步类型。 |
| IS_PERSISTENT | 类型为bool。 | 可选 | 在应用卸载时是否需要保留关键资产。 |
| DATA_LABEL_CRITICAL_1 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_2 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_3 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_4 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_1 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_2 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_3 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_4 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_LOCAL_112+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_212+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_312+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_412+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| REQUIRE_ATTR_ENCRYPTED14+ | 类型为bool。 | 可选 | 是否查询业务自定义附属信息被加密的数据，默认查询业务附属信息不加密的数据。 |
| 属性名称（Tag） | 属性内容（Value） | 是否必选 | 说明 |
| --- | --- | --- | --- |
| ALIAS | 类型为Uint8Array，长度为1-256字节。 | 必选 | 关键资产别名，每条关键资产的唯一索引。 |
| AUTH_CHALLENGE | 类型为Uint8Array，长度为32字节。 | 必选 | 用户认证的挑战值。 |
| AUTH_TOKEN | 类型为Uint8Array，长度为148字节。 | 必选 | 用户认证通过的授权令牌。 |
| RETURN_TYPE | 类型为number，asset.ReturnType.ALL。 | 必选 | 关键资产查询返回的结果类型。 |
| ACCESSIBILITY | 类型为number，取值范围详见Accessibility。 | 可选 | 基于锁屏状态的访问控制。 |
| REQUIRE_PASSWORD_SET | 类型为bool。 | 可选 | 是否仅在设置了锁屏密码的情况下，可访问关键资产。 |
| AUTH_TYPE | 类型为number，取值范围详见AuthType。 | 可选 | 访问关键资产所需的用户认证类型。 |
| SYNC_TYPE | 类型为number，取值范围详见SyncType。 | 可选 | 关键资产支持的同步类型。 |
| IS_PERSISTENT | 类型为bool。 | 可选 | 在应用卸载时是否需要保留关键资产。 |
| DATA_LABEL_CRITICAL_1 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_2 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_3 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_CRITICAL_4 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_1 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_2 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_3 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_4 | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| DATA_LABEL_NORMAL_LOCAL_112+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_212+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_312+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| DATA_LABEL_NORMAL_LOCAL_412+ | 类型为Uint8Array，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| REQUIRE_ATTR_ENCRYPTED14+ | 类型为bool。 | 可选 | 是否查询业务自定义附属信息被加密的数据，默认查询业务附属信息不加密的数据。 |
| 属性名称（Tag） | 属性内容（Value） | 是否必选 | 说明 |
| --- | --- | --- | --- |
| AUTH_CHALLENGE | 类型为Uint8Array，长度为32字节。 | 必选 | 用户认证的挑战值。 |
代码示例
本模块提供了异步和同步两套接口，以下为异步接口的使用示例，同步接口详见API文档。
查询别名是demo_alias且需要用户认证的关键资产。
```typescript
import { asset } from '@kit.AssetStoreKit';
import { util } from '@kit.ArkTS';
import userAuth from '@ohos.userIAM.userAuth';
import { BusinessError } from '@kit.BasicServicesKit';
function stringToArray(str: string): Uint8Array {
let textEncoder = new util.TextEncoder();
return textEncoder.encodeInto(str);
}
function arrayToString(arr: Uint8Array): string {
let textDecoder = util.TextDecoder.create("utf-8", { ignoreBOM: true });
let str = textDecoder.decodeToString(arr, { stream: false })
return str;
}
async function userAuthenticate(challenge: Uint8Array): Promise<Uint8Array> {
return new Promise((resolve, reject) => {
const authParam: userAuth.AuthParam = {
challenge: challenge,
authType: [userAuth.UserAuthType.PIN],
authTrustLevel: userAuth.AuthTrustLevel.ATL1,
};
const widgetParam: userAuth.WidgetParam = { title: '请输入锁屏密码' };
try {
let userAuthInstance = userAuth.getUserAuthInstance(authParam, widgetParam);
userAuthInstance.on('result', {
onResult(result) {
if (result.result == userAuth.UserAuthResultCode.SUCCESS) {
console.info(`User identity authentication succeeded.`);
resolve(result.token);
} else {
console.error(`User identity authentication failed.`);
reject();
}
}
});
userAuthInstance.start();
} catch (error) {
let err = error as BusinessError;
console.error(`User identity authentication failed. Code is ${err.code}, message is ${err.message}`);
reject();
}
})
}
function preQueryAsset(): Promise<Uint8Array> {
return new Promise((resolve, reject) => {
try {
let query: asset.AssetMap = new Map();
query.set(asset.Tag.ALIAS, stringToArray('demo_alias'));
asset.preQuery(query).then((challenge: Uint8Array) => {
resolve(challenge);
}).catch(() => {
reject();
})
} catch (error) {
let err = error as BusinessError;
console.error(`Failed to pre-query Asset. Code is ${err.code}, message is ${err.message}`);
reject();
}
});
}
async function postQueryAsset(challenge: Uint8Array) {
let handle: asset.AssetMap = new Map();
handle.set(asset.Tag.AUTH_CHALLENGE, challenge);
try {
await asset.postQuery(handle);
console.info(`Succeeded in post-querying Asset.`);
} catch (error) {
let err = error as BusinessError;
console.error(`Failed to post-query Asset. Code is ${err.code}, message is ${err.message}`);
}
}
async function queryAsset() {
// step1. 调用asset.preQuery获取挑战值
preQueryAsset().then(async (challenge: Uint8Array) => {
try {
// step2. 传入挑战值，拉起用户认证框
let authToken: Uint8Array = await userAuthenticate(challenge);
// step3 用户认证通过后，传入挑战值和授权令牌，查询关键资产明文
let query: asset.AssetMap = new Map();
query.set(asset.Tag.ALIAS, stringToArray('demo_alias'));
query.set(asset.Tag.RETURN_TYPE, asset.ReturnType.ALL);
query.set(asset.Tag.AUTH_CHALLENGE, challenge);
query.set(asset.Tag.AUTH_TOKEN, authToken);
let res: Array<asset.AssetMap> = await asset.query(query);
for (let i = 0; i < res.length; i++) {
// parse the secret.
let secret: Uint8Array = res[i].get(asset.Tag.SECRET) as Uint8Array;
// parse uint8array to string
let secretStr: string = arrayToString(secret);
}
// step4. 关键资产明文查询成功后，需要调用asset.postQuery进行查询的后置处理。
postQueryAsset(challenge);
} catch (error) {
// step5. preQuery成功，后续操作失败，也需要调用asset.postQuery进行查询的后置处理。
postQueryAsset(challenge);
}
}).catch ((err: BusinessError) => {
console.error(`Failed to pre-query Asset. Code is ${err.code}, message is ${err.message}`);
})
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-native-V14
爬取时间: 2025-04-28 01:31:08
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-native-add-V14
爬取时间: 2025-04-28 01:31:21
来源: Huawei Developer
接口介绍
可通过API文档查看新增关键资产的接口OH_Asset_Add的详细介绍。
在新增关键资产时，关键资产属性的内容参数如下表所示：
下表中名称包含“ASSET_TAG_DATA_LABEL”的关键资产属性，用于存储业务自定义信息，其内容不会被加密，请勿存放个人数据。
| 属性名称（Asset_Tag） | 属性内容（Asset_Value） | 是否必选 | 说明 |
| --- | --- | --- | --- |
| ASSET_TAG_SECRET | 类型为uint8[]，长度为1-1024字节。 | 必选 | 关键资产明文。 |
| ASSET_TAG_ALIAS | 类型为uint8[]，长度为1-256字节。 | 必选 | 关键资产别名，每条关键资产的唯一索引。 |
| ASSET_TAG_ACCESSIBILITY | 类型为uint32_t，取值范围详见Asset_Accessibility。 | 可选 | 基于锁屏状态的访问控制。 |
| ASSET_TAG_REQUIRE_PASSWORD_SET | 类型为bool。 | 可选 | 是否仅在设置了锁屏密码的情况下，可访问关键资产。 |
| ASSET_TAG_AUTH_TYPE | 类型为uint32_t，取值范围详见Asset_AuthType。 | 可选 | 访问关键资产所需的用户认证类型。 |
| ASSET_TAG_SYNC_TYPE | 类型为uint32_t，取值范围详见Asset_SyncType。 | 可选 | 关键资产支持的同步类型。 |
| ASSET_TAG_IS_PERSISTENT | 类型为bool。 | 可选 | 在应用卸载时是否需要保留关键资产。 注意： 设置此属性时，需申请权限ohos.permission.STORE_PERSISTENT_DATA。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_1 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_2 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_3 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_4 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_1 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_2 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_3 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_4 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_112+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_212+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_312+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_412+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_CONFLICT_RESOLUTION | 类型为uint32_t，取值范围详见Asset_ConflictResolution。 | 可选 | 新增关键资产时的冲突（如：别名相同）处理策略。 |
| ASSET_TAG_REQUIRE_ATTR_ENCRYPTED14+ | 类型为bool。 | 可选 | 是否加密业务自定义附属信息，默认不需要加密。 |
在应用卸载时是否需要保留关键资产。
注意：设置此属性时，需申请权限ohos.permission.STORE_PERSISTENT_DATA。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
约束和限制
-  基于别名的访问 关键资产以密文的形式存储在ASSET数据库中，以业务身份 + 别名作为唯一索引。故业务需要保证每条关键资产的别名唯一。
-  业务自定义数据存储 ASSET为业务预留了12个关键资产自定义属性，名称以"ASSET_TAG_DATA_LABEL"开头。对于超过12个自定义属性的情况，业务可以将多段数据按照一定的格式（如JSON）拼接到同一个ASSET属性中。 ASSET对部分属性会进行完整性保护，这部分属性名称以"ASSET_TAG_DATA_LABEL_CRITICAL"开头，且写入后不支持更新。
代码示例
新增一条密码是demo_pwd，别名是demo_alias，附属信息是demo_label的数据，该数据在用户首次解锁设备后可被访问。
1.  在CMake脚本中链接相关动态库
2.  参考如下示例代码，进行业务功能开发

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-native-remove-V14
爬取时间: 2025-04-28 01:31:35
来源: Huawei Developer
接口介绍
可通过API文档查看删除关键资产的接口OH_Asset_Remove的详细介绍。
在删除关键资产时，关键资产属性的内容参数如下表所示：
下表中名称包含“ASSET_TAG_DATA_LABEL”的关键资产属性，用于存储业务自定义信息，其内容不会被加密，请勿存放个人数据。
| 属性名称（Asset_Tag） | 属性内容（Asset_Value） | 是否必选 | 说明 |
| --- | --- | --- | --- |
| ASSET_TAG_ALIAS | 类型为uint8[]，长度为1-256字节。 | 可选 | 关键资产别名，每条关键资产的唯一索引。 |
| ASSET_TAG_ACCESSIBILITY | 类型为uint32_t，取值范围详见Asset_Accessibility。 | 可选 | 基于锁屏状态的访问控制。 |
| ASSET_TAG_REQUIRE_PASSWORD_SET | 类型为bool。 | 可选 | 是否仅在设置了锁屏密码的情况下，可访问关键资产。 |
| ASSET_TAG_AUTH_TYPE | 类型为uint32_t，取值范围详见Asset_AuthType。 | 可选 | 访问关键资产所需的用户认证类型。 |
| ASSET_TAG_SYNC_TYPE | 类型为uint32_t，取值范围详见Asset_SyncType。 | 可选 | 关键资产支持的同步类型。 |
| ASSET_TAG_IS_PERSISTENT | 类型为bool。 | 可选 | 在应用卸载时是否需要保留关键资产。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_1 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_2 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_3 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_4 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_1 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_2 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_3 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_4 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_112+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_212+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_312+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_412+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_REQUIRE_ATTR_ENCRYPTED14+ | 类型为bool。 | 可选 | 是否删除业务自定义附属信息被加密的数据，默认删除业务附属信息不加密的数据。 |
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
代码示例
删除别名是demo_alias的关键资产。
1.  在CMake脚本中链接相关动态库
2.  参考如下示例代码，进行业务功能开发

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-native-update-V14
爬取时间: 2025-04-28 01:31:49
来源: Huawei Developer
接口介绍
可通过API文档查看更新关键资产的接口OH_Asset_Update的详细介绍。
在更新关键资产时，关键资产属性的内容参数如下表所示：
下表中名称包含“ASSET_TAG_DATA_LABEL”的关键资产属性，用于存储业务自定义信息，其内容不会被加密，请勿存放个人数据。
-  query的参数列表： 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且有完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。
-  attributesToUpdate的参数列表： 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。 关键资产附属信息，内容由业务自定义且无完整性保护。 说明：API12前长度为1-512字节。
| 属性名称（Asset_Tag） | 属性内容（Asset_Value） | 是否必选 | 说明 |
| --- | --- | --- | --- |
| ASSET_TAG_ALIAS | 类型为uint8[]，长度为1-256字节。 | 必选 | 关键资产别名，每条关键资产的唯一索引。 |
| ASSET_TAG_ACCESSIBILITY | 类型为uint32_t，取值范围详见Asset_Accessibility。 | 可选 | 基于锁屏状态的访问控制。 |
| ASSET_TAG_REQUIRE_PASSWORD_SET | 类型为bool。 | 可选 | 是否仅在设置了锁屏密码的情况下，可访问关键资产。 |
| ASSET_TAG_AUTH_TYPE | 类型为uint32_t，取值范围详见Asset_AuthType。 | 可选 | 访问关键资产所需的用户认证类型。 |
| ASSET_TAG_SYNC_TYPE | 类型为uint32_t，取值范围详见Asset_SyncType。 | 可选 | 关键资产支持的同步类型。 |
| ASSET_TAG_IS_PERSISTENT | 类型为bool。 | 可选 | 在应用卸载时是否需要保留关键资产。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_1 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_2 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_3 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_4 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_1 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_2 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_3 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_4 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_112+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_212+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_312+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_412+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| 属性名称（Asset_Tag） | 属性内容（Asset_Value） | 是否必选 | 说明 |
| --- | --- | --- | --- |
| ASSET_TAG_SECRET | 类型为uint8[]，长度为1-1024字节。 | 可选 | 关键资产明文。 |
| ASSET_TAG_DATA_LABEL_NORMAL_1 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_2 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_3 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_4 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_112+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_212+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_312+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_412+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_REQUIRE_ATTR_ENCRYPTED14+ | 类型为bool。 | 可选 | 是否更新业务自定义附属信息被加密的数据，默认更新业务附属信息不加密的数据。 |
代码示例
更新别名是demo_alias的关键资产，将关键资产明文更新为demo_pwd_new，附属信息更新成demo_label_new。
1.  在CMake脚本中链接相关动态库
2.  参考如下示例代码，进行业务功能开发

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/asset-native-query-V14
爬取时间: 2025-04-28 01:32:03
来源: Huawei Developer
接口介绍
可通过API文档查看查询关键资产的接口OH_Asset_Query
的详细介绍。
在查询关键资产时，关键资产属性的内容参数如下表所示：
下表中名称包含“ASSET_TAG_DATA_LABEL”的关键资产属性，用于存储业务自定义信息，其内容不会被加密，请勿存放个人数据。
| 属性名称（Asset_Tag） | 属性内容（Asset_Value） | 是否必选 | 说明 |
| --- | --- | --- | --- |
| ASSET_TAG_ALIAS | 类型为uint8[]，长度为1-256字节。 | 可选 | 关键资产别名，每条关键资产的唯一索引。 |
| ASSET_TAG_ACCESSIBILITY | 类型为uint32_t，取值范围详见Asset_Accessibility。 | 可选 | 基于锁屏状态的访问控制。 |
| ASSET_TAG_REQUIRE_PASSWORD_SET | 类型为bool。 | 可选 | 是否仅在设置了锁屏密码的情况下，可访问关键资产。 |
| ASSET_TAG_AUTH_TYPE | 类型为uint32_t，取值范围详见Asset_AuthType。 | 可选 | 访问关键资产所需的用户认证类型。 |
| ASSET_TAG_SYNC_TYPE | 类型为uint32_t，取值范围详见Asset_SyncType。 | 可选 | 关键资产支持的同步类型。 |
| ASSET_TAG_IS_PERSISTENT | 类型为bool。 | 可选 | 在应用卸载时是否需要保留关键资产。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_1 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_2 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_3 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_CRITICAL_4 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_1 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_2 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_3 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_4 | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_112+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_212+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_312+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_DATA_LABEL_NORMAL_LOCAL_412+ | 类型为uint8[]，长度为1-2048字节。 | 可选 | 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。 |
| ASSET_TAG_RETURN_TYPE | 类型为uint32_t，取值范围详见Asset_ReturnType。 | 可选 | 关键资产查询返回的结果类型。 |
| ASSET_TAG_RETURN_LIMIT | 类型为uint32_t。 | 可选 | 关键资产查询返回的结果数量。 |
| ASSET_TAG_RETURN_OFFSET | 类型为uint32_t，取值范围：1-65536。 | 可选 | 关键资产查询返回的结果偏移量。 说明： 用于分批查询场景，指定从第几个开始返回。 |
| ASSET_TAG_RETURN_ORDERED_BY | 类型为uint32_t，取值范围：ASSET_TAG_DATA_LABEL_xxx。 | 可选 | 关键资产查询返回的结果排序依据，仅支持按照附属信息排序。 说明： 默认按照关键资产新增的顺序返回。 |
| ASSET_TAG_REQUIRE_ATTR_ENCRYPTED14+ | 类型为bool。 | 可选 | 是否查询业务自定义附属信息被加密的数据，默认查询业务附属信息不加密的数据。 |
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且有完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产附属信息，内容由业务自定义且无完整性保护。
说明：API12前长度为1-512字节。
关键资产查询返回的结果偏移量。
说明：用于分批查询场景，指定从第几个开始返回。
关键资产查询返回的结果排序依据，仅支持按照附属信息排序。
说明：默认按照关键资产新增的顺序返回。
约束和限制
批量查询出的关键资产需要通过IPC通道传输给业务，受IPC缓冲区大小限制，建议对查询超过40条关键资产时，进行分批查询，且每次查询数量不超过40条。
代码示例
查询单条关键资产明文
查询别名是demo_alias的关键资产明文。
1.  在CMake脚本中链接相关动态库
2.  参考如下示例代码，进行业务功能开发
查询单条关键资产属性
查询别名是demo_alias的关键资产属性。
1.  在CMake脚本中链接相关动态库
2.  参考如下示例代码，进行业务功能开发
批量查询关键资产属性
批量查询附属信息是demo_label的关键资产属性，从第5条满足条件的结果开始返回，一共返回10条，且返回结果以DATA_LABEL_NORMAL_1属性内容排序。
1.  在CMake脚本中链接相关动态库
2.  参考如下示例代码，进行业务功能开发

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-architecture-kit-V14
爬取时间: 2025-04-28 01:32:56
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-architecture-kit-intro-V14
爬取时间: 2025-04-28 01:33:10
来源: Huawei Developer
Crypto Architecture Kit屏蔽了第三方密码学算法库实现差异的算法框架，提供加解密、签名验签、消息验证码、哈希、安全随机数、密钥派生等相关功能。
开发者可以通过调用加解密算法框架服务，忽略底层不同三方算法库的差异，实现迅捷开发。
约束与限制
-  Crypto Architecture Kit不支持多线程并发操作。
-  Crypto Architecture Kit当前只支持OpenSSL。
-  Crypto Architecture Kit提供大部分常用算法，部分算法和规格并不适用于对安全要求高的场景，如MD5等。请开发者根据实际需求选择合适的算法。
能力范围
加解密算法库为开发者提供了以下相关功能，并提供了对应的算法规格说明和开发指导，请开发者参照开发。
-  密钥生成和转换
-  加解密
-  签名验签
-  密钥协商
-  消息摘要计算
-  消息认证码计算
-  安全随机数生成
-  密钥派生
基本概念
在开发具体的功能前，开发者需要了解以下基本概念。
-  对称密钥 加解密双方使用同一个密钥对完成数据加密、解密的操作。即数据发送方使用某个加密密钥对明文进行特殊加密算法处理后，使其变成复杂的加密密文发送出去，接收方需使用同一个密钥及相同算法的逆算法解密，才能得到原来的可读明文。
-  非对称密钥 非对称密钥使用公钥和私钥两个密钥来进行算法操作，公钥对外公开，私钥对外保密。 对于加解密操作，一般使用公钥对明文加密形成密文，持有私钥的人即可解密密文。 对于签名验签操作，使用私钥对明文进行签名，公钥持有者可以通过公钥对签名数据做验签，验证数据是否被篡改。
与相关Kit的关系
加解密算法库框架仅提供密钥的密码学操作，不提供密钥管理功能。因此，使用算法库时，需要应用自己来保管密钥，适用于临时会话密钥等仅在内存中使用的场景，或者应用自己实现密钥安全存储的场景。
如果业务需要由系统提供密钥管理功能（密钥存储等），请使用Universal Keystore Kit（密钥管理服务）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-generation-conversion-V14
爬取时间: 2025-04-28 01:33:24
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-generation-conversion-overview-V14
爬取时间: 2025-04-28 01:33:38
来源: Huawei Developer
在以下场景中，经常需要使用密钥生成操作：
1.  随机生成算法库密钥对象。该对象可用于后续的加解密等操作。
2.  根据指定数据生成算法库密钥对象（也就是将外部或存储的二进制数据转换为算法库的密钥对象）。该对象可用于后续的加解密等操作。
3.  根据密钥参数生成指定的算法库密钥对象。该对象可用于后续的加解密等操作。
4.  获取算法库密钥对象的二进制数据，用于存储或传输。
5.  对于非对称密钥，获取密钥对象的参数属性，用于存储或运输。
其中，密钥对象Key包括对称密钥SymKey和非对称密钥（公钥PubKey和私钥PriKey），其中公钥和私钥组成密钥对KeyPair。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-generation-conversion-spec-V14
爬取时间: 2025-04-28 01:33:51
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sym-key-generation-conversion-spec-V14
爬取时间: 2025-04-28 01:34:05
来源: Huawei Developer
当前章节将说明系统目前支持的算法及其对应的规格。
开发者可以通过字符串参数承载密钥规格，来生成对应的密钥。对于每种算法支持的字符串参数，将会在具体的每个算法规格中介绍。
AES
AES（Advanced Encryption Standard），最常见的对称加密算法。
基本特点：
-  分组密码算法，分组长度为128位。
-  密钥长度为128位、192位或256位。
-  与3DES相比，安全性更高，处理速度更快。
当前支持以字符串参数生成AES密钥，具体的“字符串参数”由“对称密钥算法”和“密钥长度”拼接而成，用于在创建对称密钥生成器时，指定密钥规格。
| 对称密钥算法 | 密钥长度（bit） | 字符串参数 | API版本 |
| --- | --- | --- | --- |
| AES | 128 | AES128 | 9+ |
| AES | 192 | AES192 | 9+ |
| AES | 256 | AES256 | 9+ |
3DES
3DES（Triple Data Encryption Algorithm），也称为3DESede或TripleDES。
基本特点：
-  使用3个64位的密钥对数据库进行三次加密，相当于对每个数据块执行三次DES（Data Encryption Standard）加密算法。
-  与DES相比，3DES的密钥长度更长，安全性更高，但处理速度不如DES。
当前支持以字符串参数生成3DES密钥，具体的“字符串参数”由“对称密钥算法”和“密钥长度”拼接而成，用于在创建对称密钥生成器时，指定密钥规格。
| 对称密钥算法 | 密钥长度（bit） | 字符串参数 | API版本 |
| --- | --- | --- | --- |
| 3DES | 192 | 3DES192 | 9+ |
SM4
SM4，即SM4分组密码算法。
基本特点：
-  分组密码算法，分组长度为128位。
-  密钥长度为128位。可通过扩展密钥增加密钥长度。
-  加密算法与密钥扩展算法都采用32轮非线性迭代结构，数据解密和数据加密的算法结构相同，只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。
当前支持以字符串参数生成SM4密钥，具体的“字符串参数”由“对称密钥算法”和“密钥长度”使用连接符“_”拼接而成，用于在创建对称密钥生成器时，指定密钥规格。
| 对称密钥算法 | 密钥长度（bit） | 字符串参数 | API版本 |
| --- | --- | --- | --- |
| SM4 | 128 | SM4_128 | 10+ |
HMAC
HMAC（Hash-based message authentication code），是一种基于哈希的消息认证码算法，运算时需要输入对称密钥。
基本特点：
HMAC使用的对称密钥可以是任何长度。
-  如果密钥的长度大于HMAC分组长度，则将密钥进行单向散列的结果作为新的密钥。
-  如果密钥的长度小于HMAC分组长度，则将末尾填充0作为新的密钥，即最终的的密钥长度与HMAC分组长度保持一致。
-  密钥长度推荐采用摘要算法的输出长度。
当前支持以字符串参数生成HMAC使用的对称密钥：
-  当HMAC使用的密钥长度与摘要算法的输出长度一致时，具体的“字符串参数”由“消息认证码算法”和“摘要算法”使用连接符“|”拼接而成，用于在创建对称密钥生成器时，指定密钥规格。
-  当HMAC使用的密钥长度不在上述摘要算法输出长度的范围内，可以通过字符串参数“HMAC”创建对称密钥生成器，并根据HMAC使用的密钥的二进制数据生成密钥。
| 消息认证码算法 | 摘要算法 | 密钥长度（bit） | 字符串参数 | API版本 |
| --- | --- | --- | --- | --- |
| HMAC | SHA1 | 160 | HMAC|SHA1 | 11+ |
| HMAC | SHA224 | 224 | HMAC|SHA224 | 11+ |
| HMAC | SHA256 | 256 | HMAC|SHA256 | 11+ |
| HMAC | SHA384 | 384 | HMAC|SHA384 | 11+ |
| HMAC | SHA512 | 512 | HMAC|SHA512 | 11+ |
| HMAC | SM3 | 256 | HMAC|SM3 | 11+ |
| HMAC | - | [1, 32768] | HMAC | 11+ |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-asym-key-generation-conversion-spec-V14
爬取时间: 2025-04-28 01:34:19
来源: Huawei Developer
当前章节将说明系统目前支持的算法及其对应的规格。密钥生成有两种指定规格的方式，分别是：
-  字符串参数：以字符串的形式描述开发者需要生成的密钥规格。
-  密钥参数：使用密钥的详细密码学信息，构造密钥对象。
对于每种算法采用哪种方式，将会在具体的每个算法规格中介绍。
RSA
RSA（Rivest–Shamir–Adleman），当前支持使用字符串参数和密钥参数两种方式生成RSA密钥。
使用字符串参数生成
以字符串参数生成RSA密钥，具体的“字符串参数”由“RSA密钥类型”和“素数个数”使用符号“|”拼接而成，用于在创建非对称密钥生成器时，指定密钥规格。
生成RSA非对称密钥时，默认素数为2，PRIMES_2参数可省略。
| RSA密钥类型 | 素数个数 | 字符串参数 | API版本 |
| --- | --- | --- | --- |
| RSA512 | 2 | RSA512|PRIMES_2 | 9+ |
| RSA768 | 2 | RSA768|PRIMES_2 | 9+ |
| RSA1024 | 2 | RSA1024|PRIMES_2 | 9+ |
| RSA1024 | 3 | RSA1024|PRIMES_3 | 9+ |
| RSA2048 | 2 | RSA2048|PRIMES_2 | 9+ |
| RSA2048 | 3 | RSA2048|PRIMES_3 | 9+ |
| RSA3072 | 2 | RSA3072|PRIMES_2 | 9+ |
| RSA3072 | 3 | RSA3072|PRIMES_3 | 9+ |
| RSA4096 | 2 | RSA4096|PRIMES_2 | 9+ |
| RSA4096 | 3 | RSA4096|PRIMES_3 | 9+ |
| RSA4096 | 4 | RSA4096|PRIMES_4 | 9+ |
| RSA8192 | 2 | RSA8192|PRIMES_2 | 9+ |
| RSA8192 | 3 | RSA8192|PRIMES_3 | 9+ |
| RSA8192 | 4 | RSA8192|PRIMES_4 | 9+ |
| RSA8192 | 5 | RSA8192|PRIMES_5 | 9+ |
使用同步接口生成RSA2048、RSA3072、RSA4096、RSA8192非对称密钥会导致耗时增加。
由于系统对主线程有时间限制，耗时较长会导致失败，建议开发者在生成位数较大的密钥时，使用对应的异步接口，或是使用多线程并发能力进行开发。
创建的RSA非对称密钥生成器，如果用于随机生成密钥，则生成的RSA密钥的规格与创建密钥生成器时参数中指定的密钥规格一致；如果用于密钥转换，则生成的RSA密钥的规格与密钥转换时参数中指定的密钥数据的密钥规格一致。
使用密钥参数生成
从API版本10开始支持，使用密钥参数生成RSA密钥。
RSA密钥参数，涉及三个整数，包括：
-  n：模数（Modulus），是私钥和公钥的公共参数。
-  sk：私钥指数（privateExponent），公式中常写作d。
-  pk：公钥指数（publicExponent），公式中常写作e。
当创建非对称密钥生成器时，对于指定公/私钥参数生成RSA密钥的支持情况如表所示：
-  √：表示需要指定这一列中的具体属性，来构成密钥参数。
-  ×：表示这一列中的具体属性对应某种密钥参数，但是当前不支持通过该密钥参数生成密钥。
|  | 公共参数 | 公钥参数 | 私钥参数 | 公私钥对参数 |
| --- | --- | --- | --- | --- |
| n | × | √ | × | √ |
| pk | N/A | √ | N/A | √ |
| sk | N/A | N/A | × | √ |
由上表可知：
-  RSA不支持通过指定公共参数（n）来随机生成密钥。
-  RSA不支持通过指定私钥参数（n, sk）来生成私钥。
ECC
ECC（Elliptic Curve Cryptography），是一种基于椭圆曲线数学的公钥密码算法。
椭圆曲线算法可以看作是定义在特殊集合下数的运算，当前算法库支持的ECC密钥均为Fp域的椭圆曲线，p为素数，Fp域也称素数域。
当前支持使用字符串参数和密钥参数两种方式生成ECC密钥，且支持通过曲线名生成公共密钥参数。
使用字符串参数生成
以字符串参数生成ECC密钥，具体的“字符串参数”由“非对称密钥算法”和“密钥长度”拼接而成，用于在创建非对称密钥生成器时，指定密钥规格。
| 非对称密钥算法 | 密钥长度（bit） | 曲线名 | 字符串参数 | API版本 |
| --- | --- | --- | --- | --- |
| ECC | 224 | NID_secp224r1 | ECC224 | 9+ |
| ECC | 256 | NID_X9_62_prime256v1 | ECC256 | 9+ |
| ECC | 384 | NID_secp384r1 | ECC384 | 9+ |
| ECC | 521 | NID_secp521r1 | ECC521 | 9+ |
| ECC | 160 | NID_brainpoolP160r1 | ECC_BrainPoolP160r1 | 11+ |
| ECC | 160 | NID_brainpoolP160t1 | ECC_BrainPoolP160t1 | 11+ |
| ECC | 192 | NID_brainpoolP192r1 | ECC_BrainPoolP192r1 | 11+ |
| ECC | 192 | NID_brainpoolP192t1 | ECC_BrainPoolP192t1 | 11+ |
| ECC | 224 | NID_brainpoolP224r1 | ECC_BrainPoolP224r1 | 11+ |
| ECC | 224 | NID_brainpoolP224t1 | ECC_BrainPoolP224t1 | 11+ |
| ECC | 256 | NID_brainpoolP256r1 | ECC_BrainPoolP256r1 | 11+ |
| ECC | 256 | NID_brainpoolP256t1 | ECC_BrainPoolP256t1 | 11+ |
| ECC | 320 | NID_brainpoolP320r1 | ECC_BrainPoolP320r1 | 11+ |
| ECC | 320 | NID_brainpoolP320t1 | ECC_BrainPoolP320t1 | 11+ |
| ECC | 384 | NID_brainpoolP384r1 | ECC_BrainPoolP384r1 | 11+ |
| ECC | 384 | NID_brainpoolP384t1 | ECC_BrainPoolP384t1 | 11+ |
| ECC | 512 | NID_brainpoolP512r1 | ECC_BrainPoolP512r1 | 11+ |
| ECC | 512 | NID_brainpoolP512t1 | ECC_BrainPoolP512t1 | 11+ |
| ECC | 256 | NID_secp256k1 | ECC_Secp256k1 | 14+ |
创建的ECC非对称密钥生成器，如果用于随机生成密钥，则生成的ECC密钥的规格与创建密钥生成器时参数中指定的密钥规格一致；如果用于密钥转换，则生成的ECC密钥的规格与密钥转换时参数中指定的密钥数据的密钥规格一致。
使用密钥参数生成
从API版本10开始支持，使用密钥参数生成ECC密钥。
Fp域下的ECC密钥参数，包括：
-  p：素数，用于确定Fp。
-  a, b：确定椭圆曲线的方程。
-  g：椭圆曲线的一个基点(base point)，可由gx，gy表示。
-  n：基点g的阶(order)。
-  h：余因子(cofactor)。
-  sk：私钥，是一个随机整数，小于n。
-  pk：公钥，是椭圆曲线上的一个点， pk = sk * g。
当创建非对称密钥生成器时，对于指定公/私钥参数生成ECC密钥的支持情况如表所示：
|  | 公共参数 | 公钥参数 | 私钥参数 | 公私钥对参数 |
| --- | --- | --- | --- | --- |
| fieldType | √ | √ | √ | √ |
| p | √ | √ | √ | √ |
| a | √ | √ | √ | √ |
| b | √ | √ | √ | √ |
| g | √ | √ | √ | √ |
| n | √ | √ | √ | √ |
| h | √ | √ | √ | √ |
| pk | N/A | √ | N/A | √ |
| sk | N/A | N/A | √ | √ |
-  当前ECC只支持Fp域，因此fieldType固定为"Fp"。fieldType和p构成了属性field，当前field只支持ECFieldFp。
-  g和pk为ECC曲线上的点，属于Point类型，需要指定具体X，Y坐标。
使用曲线名生成密钥参数
从API版本11开始支持，使用曲线名来生成ECC公共密钥参数。
-  曲线名为要求输入的字符串参数，支持的曲线名请参考ECC密钥字符串参数表中的“曲线名”一列。
-  生成的公共密钥参数可以直接随机生成公私钥，也可用于构造公、私以及公私钥对密钥参数。
DSA
DSA（Digital Signature Algorithm），是一种基于模算数和整数有限域离散对数难题的一种公钥密码算法，常用于数字签名和验签，不能用于加解密。
当前支持使用字符串参数和密钥参数两种方式生成DSA密钥。
约束与限制
使用同步接口生成DSA2048、DSA3072非对称密钥或者明文长度超过2048会导致耗时增加。
由于系统对主线程有时间限制，耗时较长会导致失败，建议开发者在生成位数较大的密钥时，使用对应的异步接口，或是使用多线程并发能力进行开发。
使用字符串参数生成
以字符串参数生成DSA密钥，具体的“字符串参数”由“非对称密钥算法”和“密钥长度”拼接而成，用于在创建非对称密钥生成器时，指定密钥规格。
| 非对称密钥算法 | 密钥长度（bit） | 字符串参数 | API版本 |
| --- | --- | --- | --- |
| DSA | 1024 | DSA1024 | 10+ |
| DSA | 2048 | DSA2048 | 10+ |
| DSA | 3072 | DSA3072 | 10+ |
使用同步接口生成DSA2048、DSA3072非对称密钥或者明文长度超过2048会导致耗时增加。
由于系统对主线程有时间限制，耗时较长会导致失败，建议开发者在生成位数较大的密钥时，使用对应的异步接口，或是使用多线程并发能力进行开发。
创建的DSA非对称密钥生成器，如果用于随机生成密钥，则生成的DSA密钥的规格与创建密钥生成器时参数中指定的密钥规格一致；如果用于密钥转换，则生成的DSA密钥的规格与密钥转换时参数中指定的密钥数据的密钥规格一致。
使用密钥参数生成
从API版本10开始支持，使用密钥参数生成DSA密钥。
DSA密钥参数，包括：
-  p：一个素模数，比特长度为64的整数倍。
-  q：p-1的素因子，长度与p的长度有关。
-  g：g = (h ^ ((p - 1) / q)) mod p，h为满足1 < h < p -1的任意整数。
-  sk：私钥，为随机生成的整数，满足0 < sk < q。
-  pk：公钥，pk = (g ^ sk) mod p。
当创建非对称密钥生成器时，对于指定公/私钥参数生成DSA密钥的支持情况如表所示：
-  √：表示需要指定这一列中的具体属性，来构成密钥参数。
-  ×：表示这一列中的具体属性对应某种密钥参数，但是当前不支持通过该密钥参数生成密钥。
|  | 公共参数 | 公钥参数 | 私钥参数 | 公私钥对参数 |
| --- | --- | --- | --- | --- |
| p | √ | √ | × | √ |
| q | √ | √ | × | √ |
| g | √ | √ | × | √ |
| pk | N/A | √ | N/A | √ |
| sk | N/A | N/A | × | √ |
-  DSA不支持通过指定私钥参数（p, q, g, sk）来生成私钥。
-  当使用公共参数（p, q, g）来生成DSA密钥对时，DSA密钥长度至少需要1024位。
SM2
SM2，是一种基于椭圆曲线的公钥密码算法。采用的Fp域上的椭圆曲线。
当前支持使用字符串参数和密钥参数两种方式生成SM2密钥，且支持通过曲线名生成公共密钥参数。
使用字符串参数生成
当前支持以字符串参数生成SM2密钥，具体的“字符串参数”由“非对称密钥算法”和“密钥长度”使用符号“_”拼接而成，用于在创建非对称密钥生成器时，指定密钥规格。
| 非对称密钥算法 | 密钥长度（bit） | 曲线名 | 字符串参数 | API版本 |
| --- | --- | --- | --- | --- |
| SM2 | 256 | NID_sm2 | SM2_256 | 10+ |
使用密钥参数生成
从API版本11开始支持，使用密钥参数生成SM2密钥。
Fp域下的SM2密钥参数，包括：
-  p：素数，用于确定Fp。
-  a, b：确定椭圆曲线的方程。
-  g：椭圆曲线的一个基点(base point)，可由gx，gy表示。
-  n：基点g的阶(order)。
-  h：余因子(cofactor)。
-  sk：私钥，是一个随机整数，小于n。
-  pk：公钥，是椭圆曲线上的一个点， pk = sk * g。
当创建非对称密钥生成器时，对于指定公/私钥参数生成SM2密钥的支持情况如表所示：
|  | 公共参数 | 公钥参数 | 私钥参数 | 公私钥对参数 |
| --- | --- | --- | --- | --- |
| fieldType | √ | √ | √ | √ |
| p | √ | √ | √ | √ |
| a | √ | √ | √ | √ |
| b | √ | √ | √ | √ |
| g | √ | √ | √ | √ |
| n | √ | √ | √ | √ |
| h | √ | √ | √ | √ |
| pk | N/A | √ | N/A | √ |
| sk | N/A | N/A | √ | √ |
-  当前SM2只支持Fp域，因此fieldType固定为"Fp"。fieldType和p构成了属性field，当前field只支持ECFieldFp。
-  g和pk为SM2曲线上的点，属于Point类型，需要指定具体X，Y坐标。
使用曲线名生成密钥参数
从API版本11开始支持，使用曲线名来生成SM2公共密钥参数。
-  曲线名为要求输入的字符串参数，支持的曲线名为"NID_sm2"。
-  生成的公共密钥参数可以直接随机生成公私钥，也可用于构造公、私以及公私钥对密钥参数。
Ed25519
Ed25519算法是一个基于 EdDSA 算法的数字签名算法，密钥长度为256位，使用 Edwards 曲线来实现，不能用于加解密，一般用于数字签名和验签。
当前支持使用字符串参数和密钥参数两种方式生成Ed25519密钥。
使用字符串参数生成
以字符串参数生成Ed25519密钥，用于在创建非对称密钥生成器时，指定密钥规格。
| 非对称密钥算法 | 字符串参数 | API版本 |
| --- | --- | --- |
| Ed25519 | Ed25519 | 11+ |
使用密钥参数生成
从API版本11开始支持，使用密钥参数生成Ed25519密钥。
Ed22519密钥参数，包括：
-  sk：私钥，一个 32 字节的随机值。
-  pk：公钥，一个 32 字节的值，从私钥派生而来。
当创建非对称密钥生成器时，对于指定公/私钥参数生成Ed25519密钥的支持情况如表所示：
|  | 公钥参数 | 私钥参数 | 公私钥对参数 |
| --- | --- | --- | --- |
| pk | √ | N/A | √ |
| sk | N/A | √ | √ |
Ed25519密钥参数没有公共参数，不支持通过公共参数生成密钥。
X25519
X25519算法是一种 Diffie-Hellman 密钥交换算法，用于密钥协商。
当前支持使用字符串参数和密钥参数两种方式生成X25519密钥。
使用字符串参数生成
以字符串参数生成X25519密钥，用于在创建非对称密钥生成器时，指定密钥规格。
| 非对称密钥算法 | 字符串参数 | API版本 |
| --- | --- | --- |
| X25519 | X25519 | 11+ |
使用密钥参数生成
从API版本11开始支持，使用密钥参数生成X25519密钥。
X22519密钥参数，包括：
-  sk：私钥，一个 32 字节的随机值。
-  pk：公钥，一个 32 字节的值，从私钥派生而来。
当创建非对称密钥生成器时，对于指定公/私钥参数生成X25519密钥的支持情况如表所示：
|  | 公钥参数 | 私钥参数 | 公私钥对参数 |
| --- | --- | --- | --- |
| pk | √ | N/A | √ |
| sk | N/A | √ | √ |
X25519没有公共密钥参数，不支持通过公共参数生成密钥。
DH
DH（Diffie–Hellman key exchange），是一种密钥协商算法，只涉及公钥的交换，它可以提供前向安全性，即使在通信渠道被监听的情况下，也不会暴露双方的私钥。
当前支持使用字符串参数和密钥参数两种方式生成DH密钥，且支持根据素数长度和私钥长度生成公共密钥参数。
使用字符串参数生成
以字符串参数生成DH密钥，具体的“字符串参数”由“非对称密钥算法”和“知名安全素数群参数”使用符号“_”拼接而成，用于在创建非对称密钥生成器时，指定密钥规格。
| 非对称密钥算法 | 知名安全素数群参数 | 密钥长度（bit） | 字符串参数 | API版本 |
| --- | --- | --- | --- | --- |
| DH | modp1536 | 1536 | DH_modp1536 | 11+ |
| DH | modp2048 | 2048 | DH_modp2048 | 11+ |
| DH | modp3072 | 3072 | DH_modp3072 | 11+ |
| DH | modp4096 | 4096 | DH_modp4096 | 11+ |
| DH | modp6144 | 6144 | DH_modp6144 | 11+ |
| DH | modp8192 | 8192 | DH_modp8192 | 11+ |
| DH | ffdhe2048 | 2048 | DH_ffdhe2048 | 11+ |
| DH | ffdhe3072 | 3072 | DH_ffdhe3072 | 11+ |
| DH | ffdhe4096 | 4096 | DH_ffdhe4096 | 11+ |
| DH | ffdhe6144 | 6144 | DH_ffdhe6144 | 11+ |
| DH | ffdhe8192 | 8192 | DH_ffdhe8192 | 11+ |
创建的DH非对称密钥生成器，如果用于随机生成密钥，则生成的DH密钥的规格与创建密钥生成器时参数中指定的密钥规格一致；如果用于密钥转换，则生成的DH密钥的规格与密钥转换时参数中指定的密钥数据的密钥规格一致。
使用密钥参数生成
从API版本11开始支持，使用密钥参数生成DH密钥。
DH密钥参数，包括：
-  p：一个足够大的素数，用作有限域的模数。它被所有通信双方共享。
-  g：g是DH算法的生成元，是素数p的原根。它被所有通信双方共享。
-  l：length，表示私钥长度，以bit为单位。当l为0时，代表不指定私钥长度。
-  sk：私钥，一个随机生成的私钥值。
-  pk：公钥，通过使用公共参数（p 和 g）和私钥进行计算得到。
当创建非对称密钥生成器时，对于指定公/私钥参数生成DH密钥的支持情况如表所示：
|  | 公共参数 | 公钥参数 | 私钥参数 | 公私钥对参数 |
| --- | --- | --- | --- | --- |
| p | √ | √ | √ | √ |
| g | √ | √ | √ | √ |
| l | √ | √ | √ | √ |
| pk | N/A | √ | N/A | √ |
| sk | N/A | N/A | √ | √ |
使用素数长度和私钥长度生成公共密钥参数
从API版本11开始支持，使用素数长度和私钥长度生成DH公共密钥参数。
如果素数长度与安全素数组素数长度一致，则选用对应的知名安全素数群，对应关系如表所示：
| 素数长度（bit） | 知名安全素数群 |
| --- | --- |
| 2048 | ffdhe2048 |
| 3072 | ffdhe3072 |
| 4096 | ffdhe4096 |
| 6144 | ffdhe6144 |
| 8192 | ffdhe8192 |
-  素数p的比特长度必须大于等于512，小于等于10000。
-  私钥长度l为可选参数，默认为0，l值的设置范围需大于2*(96+(素数P位数-1)/1024*16)。
-  生成的公共密钥参数可以直接随机生成公私钥，也可用于构造公、私以及公私钥对密钥参数。
-  生成非知名群的密钥参数较为耗时，建议优先选用知名安全素数群。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-generation-conversion-dev-V14
爬取时间: 2025-04-28 01:34:33
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-generate-sym-key-randomly-V14
爬取时间: 2025-04-28 01:34:46
来源: Huawei Developer
以AES和SM4为例，随机生成对称密钥（SymKey），并获得二进制数据。
对称密钥对象可用于后续加解密操作，二进制数据可用于存储或运输。
随机生成AES密钥
对应的算法规格请查看对称密钥生成和转换规格：AES。
1.  调用cryptoFramework.createSymKeyGenerator，指定字符串参数'AES256'，创建密钥算法为AES、密钥长度为256位的对称密钥生成器（SymKeyGenerator）。
2.  调用SymKeyGenerator.generateSymKey，随机生成对称密钥对象（SymKey）。
3.  调用SymKey.getEncoded，获取密钥对象的二进制数据。
-  以使用Promise方式随机生成AES密钥为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function testGenerateAesKey() {
// 创建SymKeyGenerator实例
let symKeyGenerator = cryptoFramework.createSymKeyGenerator('AES256');
// 使用密钥生成器随机生成对称密钥
let promiseSymKey = symKeyGenerator.generateSymKey();
promiseSymKey.then(key => {
// 获取对称密钥的二进制数据，输出256位密钥。长度为32字节
let encodedKey = key.getEncoded();
console.info('key hex:' + encodedKey.data);
});
}
```
-  同步方法（调用方法generateSymKeySync）：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function testSyncGenerateAesKey() {
// 创建SymKeyGenerator实例
let symKeyGenerator = cryptoFramework.createSymKeyGenerator('AES256');
// 使用密钥生成器随机生成对称密钥
let promiseSymKey = symKeyGenerator.generateSymKeySync();
// 获取对称密钥的二进制数据，输出256位密钥。长度为32字节
let encodedKey = promiseSymKey.getEncoded();
console.info('key hex:' + encodedKey.data);
}
```
随机生成SM4密钥
对应的算法规格请查看对称密钥生成和转换规格：SM4。
1.  调用cryptoFramework.createSymKeyGenerator，指定字符串参数'SM4_128'，创建密钥算法为SM4、密钥长度为128位的对称密钥生成器（SymKeyGenerator）。 如果开发者需要使用其他算法，请注意修改此处入参的字符串参数。
2.  调用SymKeyGenerator.generateSymKey，随机生成对称密钥对象（SymKey）。
3.  调用SymKey.getEncoded，获取密钥对象的二进制数据。
-  以使用Promise方式随机生成SM4密钥为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function testGenerateSM4Key() {
// 创建SymKeyGenerator实例
let symKeyGenerator = cryptoFramework.createSymKeyGenerator('SM4_128');
// 使用密钥生成器随机生成对称密钥
let promiseSymKey = symKeyGenerator.generateSymKey();
promiseSymKey.then(key => {
// 获取对称密钥的二进制数据，输出128位字节流。长度为16字节
let encodedKey = key.getEncoded();
console.info('key hex:' + encodedKey.data);
});
}
```
-  同步方法（调用方法generateSymKeySync）：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function testSyncGenerateSm4Key() {
// 创建SymKeyGenerator实例
let symKeyGenerator = cryptoFramework.createSymKeyGenerator('SM4_128');
// 使用密钥生成器随机生成对称密钥
let promiseSymKey = symKeyGenerator.generateSymKeySync();
// 获取对称密钥的二进制数据，输出128位字节流。长度为16字节
let encodedKey = promiseSymKey.getEncoded();
console.info('key hex:' + encodedKey.data);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-generate-sym-key-randomly-ndk-V14
爬取时间: 2025-04-28 01:35:00
来源: Huawei Developer
以AES和SM4为例，随机生成对称密钥（OH_CryptoSymKey）。
对称密钥对象可用于后续加解密操作，二进制数据可用于存储或运输。
在CMake脚本中链接相关动态库
随机生成AES密钥
对应的算法规格请查看对称密钥生成和转换规格：AES。
1.  调用OH_CryptoSymKeyGenerator_Create，指定字符串参数'AES256'，创建密钥算法为AES、密钥长度为256位的对称密钥生成器（OH_CryptoSymKeyGenerator）。
2.  调用OH_CryptoSymKeyGenerator_Generate，随机生成对称密钥对象（OH_CryptoSymKey）。
3.  调用OH_CryptoSymKey_GetKeyData，获取密钥对象的二进制数据。
随机生成SM4密钥
对应的算法规格请查看对称密钥生成和转换规格：SM4。
1.  调用OH_CryptoSymKeyGenerator_Create，指定字符串参数'SM4_128'，创建密钥算法为SM4、密钥长度为128位的对称密钥生成器（OH_CryptoSymKeyGenerator）。
2.  调用OH_CryptoSymKeyGenerator_Generate，随机生成对称密钥对象（OH_CryptoSymKey）。
3.  调用OH_CryptoSymKey_GetKeyData，获取密钥对象的二进制数据。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-convert-binary-data-to-sym-key-V14
爬取时间: 2025-04-28 01:35:14
来源: Huawei Developer
以3DES和HMAC为例，根据指定的对称密钥二进制数据，生成密钥（SymKey），即将外部或存储的二进制数据转换为算法库的密钥对象，该对象可用于后续的加解密等操作。
指定二进制数据转换3DES密钥
对应的算法规格请查看对称密钥生成和转换规格：3DES。
1.  获取3DES二进制密钥数据，封装成DataBlob对象。
2.  调用cryptoFramework.createSymKeyGenerator，指定字符串参数'3DES192'，创建密钥算法为3DES、密钥长度为192位的对称密钥生成器（SymKeyGenerator）。
3.  调用SymKeyGenerator.convertKey，根据指定的对称密钥二进制数据，生成对称密钥对象（SymKey）。
4.  调用SymKey.getEncoded，获取密钥对象的二进制数据。
-  以使用callback方式生成3DES密钥为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { BusinessError } from '@kit.BasicServicesKit';
function genKeyMaterialBlob(): cryptoFramework.DataBlob {
let arr = [
0xba, 0x3d, 0xc2, 0x71, 0x21, 0x1e, 0x30, 0x56,
0xad, 0x47, 0xfc, 0x5a, 0x46, 0x39, 0xee, 0x7c,
0xba, 0x3b, 0xc2, 0x71, 0xab, 0xa0, 0x30, 0x72]; // 密钥长度为192位，即24字节。
let keyMaterial = new Uint8Array(arr);
return { data: keyMaterial };
}
function testConvertSymKey() {
// 创建SymKeyGenerator实例
let symKeyGenerator = cryptoFramework.createSymKeyGenerator('3DES192');
// 根据指定的数据生成对称密钥
let keyMaterialBlob = genKeyMaterialBlob();
try {
symKeyGenerator.convertKey(keyMaterialBlob, (error, key) => {
if (error) { // 如果业务逻辑执行失败，则callback的第一个参数返回错误信息，即异步抛出异常
let e: BusinessError = error as BusinessError;
console.error(`convertKey error, ${e.code}, ${e.message}`);
return;
}
console.info('key algName：' + key.algName);
console.info('key format：' + key.format);
let encodedKey = key.getEncoded(); // 获取对称密钥的二进制数据，并以字节数组形式输出。长度为24字节
console.info('key getEncoded hex: ' + encodedKey.data);
})
} catch (error) { // 参数检查发现错误立即抛出异常
let e: BusinessError = error as BusinessError;
console.error(`convertKey failed, ${e.code}, ${e.message}`);
}
}
```
-  同步方法（调用方法convertKeySync）：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function genKeyMaterialBlob(): cryptoFramework.DataBlob {
let arr = [
0xba, 0x3d, 0xc2, 0x71, 0x21, 0x1e, 0x30, 0x56,
0xad, 0x47, 0xfc, 0x5a, 0x46, 0x39, 0xee, 0x7c,
0xba, 0x3b, 0xc2, 0x71, 0xab, 0xa0, 0x30, 0x72]; // 密钥长度为192位，即24字节。
let keyMaterial = new Uint8Array(arr);
return { data: keyMaterial };
}
function testConvertSymKey() {
// 创建SymKeyGenerator实例
let symKeyGenerator = cryptoFramework.createSymKeyGenerator('3DES192');
// 根据指定的数据生成对称密钥
let keyMaterialBlob = genKeyMaterialBlob();
let key = symKeyGenerator.convertKeySync(keyMaterialBlob);
let encodedKey = key.getEncoded(); // 获取对称密钥的二进制数据，并以字节数组形式输出。长度为24字节
console.info('key getEncoded hex' + encodedKey.data);
}
```
指定二进制数据转换HMAC密钥
对应的算法规格请查看对称密钥生成和转换规格：HMAC。
1.  获取HMAC二进制密钥，封装成DataBlob对象。
2.  调用cryptoFramework.createSymKeyGenerator，指定字符串参数'HMAC'，创建密钥算法为HMAC、密钥长度为[1, 32768]位的对称密钥生成器（SymKeyGenerator）。
3.  调用SymKeyGenerator.convertKey，根据指定的对称密钥二进制数据，生成对称密钥对象（SymKey）。
4.  调用SymKey.getEncoded，获取密钥对象的二进制数据。
-  以使用await方式生成HMAC密钥为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
async function testConvertHmacKey() {
// 对称密钥长度为64字节，512比特
let keyMessage = '12345678abcdefgh12345678abcdefgh12345678abcdefgh12345678abcdefgh';
let keyBlob: cryptoFramework.DataBlob = {
data : new Uint8Array(buffer.from(keyMessage, 'utf-8').buffer)
}
let symKeyGenerator = cryptoFramework.createSymKeyGenerator('HMAC');
let key = await symKeyGenerator.convertKey(keyBlob);
let encodedKey = key.getEncoded();
console.info('key encoded data：' + encodedKey.data);
}
```
-  同步方法（调用方法convertKeySync）：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function testConvertKeySync() {
// 对称密钥长度为64字节，512比特
let keyMessage = '12345678abcdefgh12345678abcdefgh12345678abcdefgh12345678abcdefgh';
let keyBlob: cryptoFramework.DataBlob = {
data : new Uint8Array(buffer.from(keyMessage, 'utf-8').buffer)
}
let symKeyGenerator = cryptoFramework.createSymKeyGenerator('HMAC');
let key = symKeyGenerator.convertKeySync(keyBlob);
let encodedKey = key.getEncoded();
console.info('key encoded data：' + encodedKey.data);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-generate-asym-key-pair-randomly-V14
爬取时间: 2025-04-28 01:36:40
来源: Huawei Developer
以RSA和SM2为例，随机生成非对称密钥对（KeyPair），并获得二进制数据。
非对称密钥对可用于后续加解密等操作，二进制数据可用于存储或运输。
随机生成RSA密钥对
对应的算法规格请查看非对称密钥生成和转换规格：RSA。
1.  调用cryptoFramework.createAsyKeyGenerator，指定字符串参数'RSA1024|PRIMES_2'，创建RSA密钥类型为RSA1024、素数个数为2的非对称密钥生成器（AsyKeyGenerator）。
2.  调用AsyKeyGenerator.generateKeyPair，随机生成非对称密钥对象（KeyPair）。 KeyPair对象中包括公钥PubKey、私钥PriKey。
3.  调用PubKey.getEncoded和PriKey.getEncoded，分别获取密钥对象的二进制数据。
-  以使用Promise方式随机生成RSA密钥对为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function generateAsyKey() {
// 创建一个AsyKeyGenerator实例
let rsaGenerator = cryptoFramework.createAsyKeyGenerator('RSA1024|PRIMES_2');
// 使用密钥生成器随机生成非对称密钥对
let keyGenPromise = rsaGenerator.generateKeyPair();
keyGenPromise.then(keyPair => {
let pubKey = keyPair.pubKey;
let priKey = keyPair.priKey;
// 获取非对称密钥对的二进制数据
let pkBlob = pubKey.getEncoded();
let skBlob = priKey.getEncoded();
console.info('pk bin data' + pkBlob.data);
console.info('sk bin data' + skBlob.data);
});
}
```
-  同步返回结果（调用方法generateKeyPairSync）：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function generateAsyKeySync() {
// 创建一个AsyKeyGenerator实例
let rsaGenerator = cryptoFramework.createAsyKeyGenerator('RSA1024|PRIMES_2');
// 使用密钥生成器随机生成非对称密钥对
try {
let keyPair = rsaGenerator.generateKeyPairSync();
if (keyPair !== null) {
let pubKey = keyPair.pubKey;
let priKey = keyPair.priKey;
// 获取非对称密钥对的二进制数据
let pkBlob = pubKey.getEncoded();
let skBlob = priKey.getEncoded();
console.info('pk bin data' + pkBlob.data);
console.info('sk bin data' + skBlob.data);
} else {
console.error("[Sync]: get key pair result fail!");
}
} catch (e) {
console.error(`get key pair failed, ${e.code}, ${e.message}`);
}
}
```
随机生成SM2密钥对
对应的算法规格请查看非对称密钥生成和转换规格：SM2。
1.  调用cryptoFramework.createAsyKeyGenerator，指定字符串参数'SM2_256'，创建密钥算法为SM2、密钥长度为256位的非对称密钥生成器（AsyKeyGenerator）。
2.  调用AsyKeyGenerator.generateKeyPair，随机生成非对称密钥对象（KeyPair）。 KeyPair对象中包括公钥PubKey、私钥PriKey。
3.  调用PubKey.getEncoded和PriKey.getEncoded，分别获取密钥对象的二进制数据。
-  以使用Promise方式随机生成SM2密钥对为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function generateSM2Key() {
// 创建一个AsyKeyGenerator实例
let sm2Generator = cryptoFramework.createAsyKeyGenerator('SM2_256');
// 使用密钥生成器随机生成非对称密钥对
let keyGenPromise = sm2Generator.generateKeyPair();
keyGenPromise.then(keyPair => {
let pubKey = keyPair.pubKey;
let priKey = keyPair.priKey;
// 获取非对称密钥对的二进制数据
let pkBlob = pubKey.getEncoded();
let skBlob = priKey.getEncoded();
console.info('pk bin data' + pkBlob.data);
console.info('sk bin data' + skBlob.data);
});
}
```
-  同步返回结果（调用方法generateKeyPairSync）：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function generateSM2KeySync() {
// 创建一个AsyKeyGenerator实例
let rsaGenerator = cryptoFramework.createAsyKeyGenerator('SM2_256');
// 使用密钥生成器随机生成非对称密钥对
try {
let keyPair = rsaGenerator.generateKeyPairSync();
if (keyPair !== null) {
let pubKey = keyPair.pubKey;
let priKey = keyPair.priKey;
// 获取非对称密钥对的二进制数据
let pkBlob = pubKey.getEncoded();
let skBlob = priKey.getEncoded();
console.info('pk bin data' + pkBlob.data);
console.info('sk bin data' + skBlob.data);
} else {
console.error("[Sync]: get key pair result fail!");
}
} catch (e) {
console.error(`get key pair failed, ${e.code}, ${e.message}`);
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-generate-asym-key-pair-randomly-ndk-V14
爬取时间: 2025-04-28 01:36:55
来源: Huawei Developer
以RSA和SM2为例，随机生成非对称密钥对（OH_CryptoKeyPair），并获得二进制数据。
非对称密钥对可用于后续加解密等操作，二进制数据可用于存储或运输。
在CMake脚本中链接相关动态库
随机生成RSA密钥对
对应的算法规格请查看非对称密钥生成和转换规格：RSA。
1.  调用OH_CryptoAsymKeyGenerator_Create，指定字符串参数'RSA1024|PRIMES_2'，创建RSA密钥类型为RSA1024、素数个数为2的非对称密钥生成器（OH_CryptoAsymKeyGenerator）。
2.  调用OH_CryptoAsymKeyGenerator_Generate，随机生成非对称密钥对象（OH_CryptoKeyPair）。
3.  调用OH_CryptoPubKey_Encode获取公钥密钥对象的二进制数据。
随机生成SM2密钥对
对应的算法规格请查看非对称密钥生成和转换规格：SM2。
1.  调用OH_CryptoAsymKeyGenerator_Create，指定字符串参数'SM2_256'，创建密钥算法为SM2、密钥长度为256位的非对称密钥生成器（OH_CryptoAsymKeyGenerator）。
2.  调用OH_CryptoAsymKeyGenerator_Generate，随机生成非对称密钥对象（OH_CryptoKeyPair）。
3.  调用OH_CryptoPubKey_Encode获取公钥密钥对象的二进制数据。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-convert-binary-data-to-asym-key-pair-V14
爬取时间: 2025-04-28 01:37:09
来源: Huawei Developer
以RSA、ECC、SM2为例，根据指定的对称密钥二进制数据，生成非对称密钥对（KeyPair），即将外部或存储的二进制数据转换为算法库的密钥对象，该对象可用于后续的加解密等操作。
针对非对称密钥的convertKey操作：
-  公钥需满足：ASN.1语法、X.509规范、DER编码格式。
-  私钥需满足：ASN.1语法、PKCS#8规范、DER编码格式。
指定二进制数据转换RSA密钥对
对应的算法规格请查看非对称密钥生成和转换规格：RSA。
1.  获取RSA公钥或私钥二进制数据，封装成DataBlob对象。 公钥和私钥可只传入其中一个，此处示例以传入公钥为例。
2.  调用cryptoFramework.createAsyKeyGenerator，指定字符串参数'RSA1024'，创建RSA密钥类型为RSA1024、素数个数为2的非对称密钥生成器（AsyKeyGenerator）。 生成RSA非对称密钥时，默认素数为2，此处省略了参数PRIMES_2。
3.  调用AsyKeyGenerator.convertKey，传入二进制密钥数据，生成非对称密钥对象（KeyPair）。
-  以使用callback方式生成RSA密钥对为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function convertAsyKey() {
let rsaGenerator = cryptoFramework.createAsyKeyGenerator('RSA1024');
let pkVal = new Uint8Array([48, 129, 159, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0, 3, 129, 141, 0, 48, 129, 137, 2, 129, 129, 0, 174, 203, 113, 83, 113, 3, 143, 213, 194, 79, 91, 9, 51, 142, 87, 45, 97, 65, 136, 24, 166, 35, 5, 179, 42, 47, 212, 79, 111, 74, 134, 120, 73, 67, 21, 19, 235, 80, 46, 152, 209, 133, 232, 87, 192, 140, 18, 206, 27, 106, 106, 169, 106, 46, 135, 111, 118, 32, 129, 27, 89, 255, 183, 116, 247, 38, 12, 7, 238, 77, 151, 167, 6, 102, 153, 126, 66, 28, 253, 253, 216, 64, 20, 138, 117, 72, 15, 216, 178, 37, 208, 179, 63, 204, 39, 94, 244, 170, 48, 190, 21, 11, 73, 169, 156, 104, 193, 3, 17, 100, 28, 60, 50, 92, 235, 218, 57, 73, 119, 19, 101, 164, 192, 161, 197, 106, 105, 73, 2, 3, 1, 0, 1]);
let pkBlob: cryptoFramework.DataBlob = { data: pkVal };
rsaGenerator.convertKey(pkBlob, null, (err, keyPair) => {
if (err) {
console.error(`convertKey failed, ${err.code}, ${err.message}`);
return;
}
console.info('convertKey success');
});
}
```
-  同步返回结果（调用方法convertKeySync）：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function convertAsyKeySync() {
let rsaGenerator = cryptoFramework.createAsyKeyGenerator('RSA1024');
let pkVal = new Uint8Array([48, 129, 159, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0, 3, 129, 141, 0, 48, 129, 137, 2, 129, 129, 0, 174, 203, 113, 83, 113, 3, 143, 213, 194, 79, 91, 9, 51, 142, 87, 45, 97, 65, 136, 24, 166, 35, 5, 179, 42, 47, 212, 79, 111, 74, 134, 120, 73, 67, 21, 19, 235, 80, 46, 152, 209, 133, 232, 87, 192, 140, 18, 206, 27, 106, 106, 169, 106, 46, 135, 111, 118, 32, 129, 27, 89, 255, 183, 116, 247, 38, 12, 7, 238, 77, 151, 167, 6, 102, 153, 126, 66, 28, 253, 253, 216, 64, 20, 138, 117, 72, 15, 216, 178, 37, 208, 179, 63, 204, 39, 94, 244, 170, 48, 190, 21, 11, 73, 169, 156, 104, 193, 3, 17, 100, 28, 60, 50, 92, 235, 218, 57, 73, 119, 19, 101, 164, 192, 161, 197, 106, 105, 73, 2, 3, 1, 0, 1]);
let pkBlob: cryptoFramework.DataBlob = { data: pkVal };
try {
let keyPair = rsaGenerator.convertKeySync(pkBlob, null);
if (keyPair !== null) {
console.info('convertKeySync success');
}
} catch (e) {
console.error(`get key pair failed, ${e.code}, ${e.message}`);
}
}
```
指定二进制数据转换ECC密钥对
对应的算法规格请查看非对称密钥生成和转换规格：ECC。
1.  获取ECC公钥或私钥二进制数据，封装成DataBlob对象。 公钥和私钥可只传入其中一个，此处示例以传入公钥、私钥为例。
2.  调用cryptoFramework.createAsyKeyGenerator，指定字符串参数'ECC256'，创建密钥算法为ECC、密钥长度为256位的非对称密钥生成器（AsyKeyGenerator）。
3.  调用AsyKeyGenerator.convertKey，传入公钥二进制和私钥二进制，生成非对称密钥对象（KeyPair）。
-  以使用callback方式生成ECC密钥对为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function convertEccAsyKey() {
let pubKeyArray = new Uint8Array([48, 89, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7, 3, 66, 0, 4, 83, 96, 142, 9, 86, 214, 126, 106, 247, 233, 92, 125, 4, 128, 138, 105, 246, 162, 215, 71, 81, 58, 202, 121, 26, 105, 211, 55, 130, 45, 236, 143, 55, 16, 248, 75, 167, 160, 167, 106, 2, 152, 243, 44, 68, 66, 0, 167, 99, 92, 235, 215, 159, 239, 28, 106, 124, 171, 34, 145, 124, 174, 57, 92]);
let priKeyArray = new Uint8Array([48, 49, 2, 1, 1, 4, 32, 115, 56, 137, 35, 207, 0, 60, 191, 90, 61, 136, 105, 210, 16, 27, 4, 171, 57, 10, 61, 123, 40, 189, 28, 34, 207, 236, 22, 45, 223, 10, 189, 160, 10, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
let pubKeyBlob: cryptoFramework.DataBlob = { data: pubKeyArray };
let priKeyBlob: cryptoFramework.DataBlob = { data: priKeyArray };
let generator = cryptoFramework.createAsyKeyGenerator('ECC256');
generator.convertKey(pubKeyBlob, priKeyBlob, (error, data) => {
if (error) {
console.error(`convertKey failed, ${error.code}, ${error.message}`);
return;
}
console.info('convertKey success');
});
}
```
-  同步返回结果（调用方法convertKeySync）：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function convertECCAsyKeySync() {
let pubKeyArray = new Uint8Array([48, 89, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7, 3, 66, 0, 4, 83, 96, 142, 9, 86, 214, 126, 106, 247, 233, 92, 125, 4, 128, 138, 105, 246, 162, 215, 71, 81, 58, 202, 121, 26, 105, 211, 55, 130, 45, 236, 143, 55, 16, 248, 75, 167, 160, 167, 106, 2, 152, 243, 44, 68, 66, 0, 167, 99, 92, 235, 215, 159, 239, 28, 106, 124, 171, 34, 145, 124, 174, 57, 92]);
let priKeyArray = new Uint8Array([48, 49, 2, 1, 1, 4, 32, 115, 56, 137, 35, 207, 0, 60, 191, 90, 61, 136, 105, 210, 16, 27, 4, 171, 57, 10, 61, 123, 40, 189, 28, 34, 207, 236, 22, 45, 223, 10, 189, 160, 10, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
let pubKeyBlob: cryptoFramework.DataBlob = { data: pubKeyArray };
let priKeyBlob: cryptoFramework.DataBlob = { data: priKeyArray };
let generator = cryptoFramework.createAsyKeyGenerator('ECC256');
try {
let keyPair = generator.convertKeySync(pubKeyBlob, priKeyBlob);
if (keyPair !== null) {
console.info('convertKeySync success');
}
} catch (e) {
console.error(`get key pair failed, ${e.code}, ${e.message}`);
}
}
```
指定PKCS8二进制数据转换ECC私钥
对应的算法规格请查看非对称密钥生成和转换规格：ECC。
获取ECC公钥或私钥二进制数据，封装成DataBlob对象再转为ECC密钥格式。示例如下：
1.  调用cryptoFramework.createAsyKeyGenerator，指定字符串参数'ECC256'，创建密钥算法为ECC、密钥长度为256位的非对称密钥生成器（AsyKeyGenerator）。
2.  调用PubKey.getEncoded获取公钥数据字节流，调用PriKey.getEncodeDer并设置参数为'PKCS8'，获取私钥数据的字节流。由此分别获取密钥对象的二进制数据。
3.  调用AsyKeyGenerator.convertKey，将上述生成的二进制密钥数据转为非对称密钥对象（KeyPair）。
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
async function main() {
// 创建一个AsyKeyGenerator实例
let eccGenerator = cryptoFramework.createAsyKeyGenerator('ECC256');
// 使用密钥生成器随机生成非对称密钥对
let keyGenPromise = eccGenerator.generateKeyPair();
keyGenPromise.then(keyPair => {
let pubKey = keyPair.pubKey;
let priKey = keyPair.priKey;
// 获取非对称密钥对ECC的二进制数据
let pubBlob = pubKey.getEncoded();
let skBlob = priKey.getEncodedDer('PKCS8');
let generator = cryptoFramework.createAsyKeyGenerator('ECC256');
generator.convertKey(pubBlob, skBlob, (error, data) => {
if (error) {
console.error(`convertKey failed, ${error.code}, ${error.message}`);
return;
}
console.info('convertKey success');
});
});
}
```
指定二进制数据转换SM2密钥对
对应的算法规格请查看非对称密钥生成和转换规格：SM2。
1.  获取SM2公钥或私钥二进制数据，封装成DataBlob对象。 公钥和私钥可只传入其中一个，此处示例以传入公钥、私钥为例。
2.  调用cryptoFramework.createAsyKeyGenerator，指定字符串参数'SM2_256'，创建密钥算法为SM2、密钥长度为256位的非对称密钥生成器（AsyKeyGenerator）。
3.  调用AsyKeyGenerator.convertKey，传入公钥二进制和私钥二进制，生成非对称密钥对象（KeyPair）。
-  以使用callback方式生成SM2密钥对为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function convertSM2AsyKey() {
let pubKeyArray = new Uint8Array([48, 89, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 129, 28, 207, 85, 1, 130, 45, 3, 66, 0, 4, 90, 3, 58, 157, 190, 248, 76, 7, 132, 200, 151, 208, 112, 230, 96, 140, 90, 238, 211, 155, 128, 109, 248, 40, 83, 214, 78, 42, 104, 106, 55, 148, 249, 35, 61, 32, 221, 135, 143, 100, 45, 97, 194, 176, 52, 73, 136, 174, 40, 70, 70, 34, 103, 103, 161, 99, 27, 187, 13, 187, 109, 244, 13, 7]);
let priKeyArray = new Uint8Array([48, 49, 2, 1, 1, 4, 32, 54, 41, 239, 240, 63, 188, 134, 113, 31, 102, 149, 203, 245, 89, 15, 15, 47, 202, 170, 60, 38, 154, 28, 169, 189, 100, 251, 76, 112, 223, 156, 159, 160, 10, 6, 8, 42, 129, 28, 207, 85, 1, 130, 45]);
let pubKeyBlob: cryptoFramework.DataBlob = { data: pubKeyArray };
let priKeyBlob: cryptoFramework.DataBlob = { data: priKeyArray };
let generator = cryptoFramework.createAsyKeyGenerator('SM2_256');
generator.convertKey(pubKeyBlob, priKeyBlob, (error, data) => {
if (error) {
console.error(`convertKey failed, ${error.code}, ${error.message}`);
return;
}
console.info('convertKey success');
});
}
```
-  同步返回结果（调用方法convertKeySync）：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function convertSM2AsyKeySync() {
let pubKeyArray = new Uint8Array([48, 89, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 129, 28, 207, 85, 1, 130, 45, 3, 66, 0, 4, 90, 3, 58, 157, 190, 248, 76, 7, 132, 200, 151, 208, 112, 230, 96, 140, 90, 238, 211, 155, 128, 109, 248, 40, 83, 214, 78, 42, 104, 106, 55, 148, 249, 35, 61, 32, 221, 135, 143, 100, 45, 97, 194, 176, 52, 73, 136, 174, 40, 70, 70, 34, 103, 103, 161, 99, 27, 187, 13, 187, 109, 244, 13, 7]);
let priKeyArray = new Uint8Array([48, 49, 2, 1, 1, 4, 32, 54, 41, 239, 240, 63, 188, 134, 113, 31, 102, 149, 203, 245, 89, 15, 15, 47, 202, 170, 60, 38, 154, 28, 169, 189, 100, 251, 76, 112, 223, 156, 159, 160, 10, 6, 8, 42, 129, 28, 207, 85, 1, 130, 45]);
let pubKeyBlob: cryptoFramework.DataBlob = { data: pubKeyArray };
let priKeyBlob: cryptoFramework.DataBlob = { data: priKeyArray };
let generator = cryptoFramework.createAsyKeyGenerator('SM2_256');
try {
let keyPair = generator.convertKeySync(pubKeyBlob, priKeyBlob);
if (keyPair !== null) {
console.info('convertKeySync success');
}
} catch (e) {
console.error(`get key pair failed, ${e.code}, ${e.message}`);
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-convert-binary-data-to-asym-key-pair-ndk-V14
爬取时间: 2025-04-28 01:38:02
来源: Huawei Developer
以RSA、ECC、SM2为例，根据指定的对称密钥二进制数据，生成非对称密钥对（OH_CryptoKeyPair），即将外部或存储的二进制数据转换为算法库的密钥对象，该对象可用于后续的加解密等操作。
针对非对称密钥的convertKey操作：
-  公钥需满足：ASN.1语法、X.509规范、DER编码格式。
-  私钥需满足：ASN.1语法、PKCS#8规范、DER编码格式。
在CMake脚本中链接相关动态库
指定二进制数据转换RSA密钥对
对应的算法规格请查看非对称密钥生成和转换规格：RSA。
1.  获取RSA公钥或私钥二进制数据，封装成Crypto_DataBlob。 公钥和私钥可只传入其中一个，此处示例以传入公钥为例。
2.  调用OH_CryptoAsymKeyGenerator_Create，指定字符串参数'RSA1024'，创建RSA密钥类型为RSA1024、素数个数为2的非对称密钥生成器（OH_CryptoAsymKeyGenerator）。 生成RSA非对称密钥时，默认素数为2，此处省略了参数PRIMES_2。
3.  调用OH_CryptoAsymKeyGenerator_Convert，传入二进制密钥数据，生成非对称密钥对象（OH_CryptoKeyPair）。
指定二进制数据转换ECC密钥对
对应的算法规格请查看非对称密钥生成和转换规格：ECC。
1.  获取ECC公钥或私钥二进制数据，封装成Crypto_DataBlob。 公钥和私钥可只传入其中一个，此处示例以传入公钥、私钥为例。
2.  调用OH_CryptoAsymKeyGenerator_Create，指定字符串参数'ECC256'，创建密钥算法为ECC、密钥长度为256位的非对称密钥生成器（OH_CryptoAsymKeyGenerator）。
3.  调用OH_CryptoAsymKeyGenerator_Convert，传入公钥二进制和私钥二进制，生成非对称密钥对象（OH_CryptoKeyPair）。
指定二进制数据转换SM2密钥对
对应的算法规格请查看非对称密钥生成和转换规格：SM2。
1.  获取SM2公钥或私钥二进制数据，封装成Crypto_DataBlob。 公钥和私钥可只传入其中一个，此处示例以传入公钥、私钥为例。
2.  调用OH_CryptoAsymKeyGenerator_Create，指定字符串参数'SM2_256'，创建密钥算法为SM2、密钥长度为256位的非对称密钥生成器（OH_CryptoAsymKeyGenerator）。
3.  调用OH_CryptoAsymKeyGenerator_Convert，传入公钥二进制和私钥二进制，生成非对称密钥对象（OH_CryptoKeyPair）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-generate-asym-key-pair-from-key-spec-V14
爬取时间: 2025-04-28 01:38:16
来源: Huawei Developer
以RSA、ECC、SM2为例，根据指定的密钥参数，生成非对称密钥对（KeyPair），并获取密钥参数属性。
该对象可用于后续的加解密等操作。获取的密钥参数属性可用于存储或运输。
指定密钥参数生成RSA公钥
对应的算法规格请查看非对称密钥生成和转换规格：RSA。
1.  构造RSACommonParamsSpec对象，用于指定RSA算法中公私钥包含的公共参数（n）。 RSACommonParamsSpec是AsyKeySpec的子类。需要通过参数algName指定算法'RSA'；指定密钥参数类型AsyKeySpecType.COMMON_PARAMS_SPEC，表示是公私钥中包含的公共参数。 使用密钥参数生成密钥时，用到的bigint类型需要以大端模式输入，且必须为正数。
2.  创建RSAPubKeySpec对象，用于指定RSA算法中公钥包含的参数（n, pk）。 RSAPubKeySpec是AsyKeySpec的子类。通过参数algName指定算法'RSA'；指定密钥参数类型AsyKeySpecType.PUBLIC_KEY_SPEC，表示是公钥中包含的参数。
3.  调用cryptoFramework.createAsyKeyGeneratorBySpec，将RSAPubKeySpec对象传入，创建非对称密钥生成器（AsyKeyGeneratorBySpec）。
4.  调用AsyKeyGeneratorBySpec.generatePubKey，获得指定的公钥（PubKey）。
5.  调用PubKey.getAsyKeySpec，获取模数n和公钥pk（即公钥指数e）。
-  以使用callback方式根据密钥参数生成RSA公钥为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
// RSA公钥密钥参数生成函数
function genRsaPubKeySpec(nIn: bigint, eIn: bigint): cryptoFramework.RSAPubKeySpec {
let rsaCommSpec: cryptoFramework.RSACommonParamsSpec = {
n: nIn,
algName: 'RSA',
specType: cryptoFramework.AsyKeySpecType.COMMON_PARAMS_SPEC
};
let rsaPubKeySpec: cryptoFramework.RSAPubKeySpec = {
params: rsaCommSpec,
pk: eIn,
algName: 'RSA',
specType: cryptoFramework.AsyKeySpecType.PUBLIC_KEY_SPEC
};
return rsaPubKeySpec;
}
// 根据密钥参数构造RSA公钥规范对象
function genRsa2048PubKeySpec() {
let nIn = BigInt('0x9260d0750ae117eee55c3f3deaba74917521a262ee76007cdf8a56755ad73a1598a1408410a01434c3f5bc54a88b57fa19fc4328daea0750a4c44e88cff3b2382621b80f670464433e4336e6d003e8cd65bff211da144b88291c2259a00a72b711c116ef7686e8fee34e4d933c868187bdc26f7be071493c86f7a5941c3510806ad67b0f94d88f5cf5c02a092821d8626e8932b65c5bd8c92049c210932b7afa7ac59c0e886ae5c1edb00d8ce2c57633db26bd6639bff73cee82be9275c402b4cf2a4388da8cf8c64eefe1c5a0f5ab8057c39fa5c0589c3e253f0960332300f94bea44877b588e1edbde97cf2360727a09b775262d7ee552b3319b9266f05a25');
let eIn = BigInt('0x010001');
return genRsaPubKeySpec(nIn, eIn);
}
// 将RSA公钥规格与预期值进行比较
function compareRsaPubKeyBySpec(rsaKeySpec: cryptoFramework.RSAPubKeySpec, n: bigint | string | number, e: bigint | string | number) {
if (typeof n === 'string' || typeof e === 'string') {
console.error('type is string');
return false;
}
if (typeof n === 'number' || typeof e === 'number') {
console.error('type is number');
return false;
}
if (rsaKeySpec.params.n !== n) {
return false;
}
if (rsaKeySpec.pk !== e) {
return false;
}
return true;
}
// 根据RSA公钥规格生成RSA公钥，获取密钥规格，并与预期值进行比较
function rsaUsePubKeySpecGetCallback() {
let rsaPubKeySpec = genRsa2048PubKeySpec();
let rsaGeneratorSpec = cryptoFramework.createAsyKeyGeneratorBySpec(rsaPubKeySpec);
rsaGeneratorSpec.generatePubKey((error, key) => {
if (error) {
console.error('generate pubKey error' + 'error code: ' + error.code + 'error message' + error.message);
}
let pubKey = key;
let nBN = pubKey.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.RSA_N_BN);
let eBN = pubKey.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.RSA_PK_BN);
if (compareRsaPubKeyBySpec(rsaPubKeySpec, nBN, eBN) !== true) {
console.error('error pub key big number');
} else {
console.info('n, e in the pubKey are same as the spec.');
}
});
}
```
-  同步返回结果（调用方法generatePubKeySync）：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
// RSA公钥密钥参数生成函数
function genRsaPubKeySpec(nIn: bigint, eIn: bigint): cryptoFramework.RSAPubKeySpec {
let rsaCommSpec: cryptoFramework.RSACommonParamsSpec = {
n: nIn,
algName: 'RSA',
specType: cryptoFramework.AsyKeySpecType.COMMON_PARAMS_SPEC
};
let rsaPubKeySpec: cryptoFramework.RSAPubKeySpec = {
params: rsaCommSpec,
pk: eIn,
algName: 'RSA',
specType: cryptoFramework.AsyKeySpecType.PUBLIC_KEY_SPEC
};
return rsaPubKeySpec;
}
// 根据密钥参数构造RSA公钥规范对象
function genRsa2048PubKeySpec() {
let nIn = BigInt('0x9260d0750ae117eee55c3f3deaba74917521a262ee76007cdf8a56755ad73a1598a1408410a01434c3f5bc54a88b57fa19fc4328daea0750a4c44e88cff3b2382621b80f670464433e4336e6d003e8cd65bff211da144b88291c2259a00a72b711c116ef7686e8fee34e4d933c868187bdc26f7be071493c86f7a5941c3510806ad67b0f94d88f5cf5c02a092821d8626e8932b65c5bd8c92049c210932b7afa7ac59c0e886ae5c1edb00d8ce2c57633db26bd6639bff73cee82be9275c402b4cf2a4388da8cf8c64eefe1c5a0f5ab8057c39fa5c0589c3e253f0960332300f94bea44877b588e1edbde97cf2360727a09b775262d7ee552b3319b9266f05a25');
let eIn = BigInt('0x010001');
return genRsaPubKeySpec(nIn, eIn);
}
// 将RSA公钥规格与预期值进行比较
function compareRsaPubKeyBySpec(rsaKeySpec: cryptoFramework.RSAPubKeySpec, n: bigint | string | number, e: bigint | string | number) {
if (typeof n === 'string' || typeof e === 'string') {
console.error('type is string');
return false;
}
if (typeof n === 'number' || typeof e === 'number') {
console.error('type is number');
return false;
}
if (rsaKeySpec.params.n !== n) {
return false;
}
if (rsaKeySpec.pk !== e) {
return false;
}
return true;
}
// 根据RSA公钥规格生成RSA公钥，获取密钥规格，并与预期值进行比较
function rsaUsePubKeySpecGetSync() {
let rsaPubKeySpec = genRsa2048PubKeySpec();
let rsaGeneratorSpec = cryptoFramework.createAsyKeyGeneratorBySpec(rsaPubKeySpec);
try {
let pubKey = rsaGeneratorSpec.generatePubKeySync();
if (pubKey !== null) {
let nBN = pubKey.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.RSA_N_BN);
let eBN = pubKey.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.RSA_PK_BN);
if (compareRsaPubKeyBySpec(rsaPubKeySpec, nBN, eBN) !== true) {
console.error('error pub key big number');
} else {
console.info('n, e in the pubKey are same as the spec.');
}
} else {
console.error('get pub key result fail!');
}
} catch (e) {
console.error(`get pub key result fail, ${e.code}, ${e.message}`);
}
}
```
指定密钥参数生成ECC密钥对
对应的算法规格请查看非对称密钥生成和转换规格：ECC。
1.  构造ECCCommonParamsSpec对象，用于指定ECC算法中公私钥包含的公共参数。 ECCCommonParamsSpec是AsyKeySpec的子类。需要通过参数algName指定算法'ECC'；指定密钥参数类型AsyKeySpecType.COMMON_PARAMS_SPEC，表示是公私钥中包含的公共参数。 使用密钥参数生成密钥时，用到的bigint类型需要以大端模式输入，且必须为正数。
2.  调用cryptoFramework.createAsyKeyGeneratorBySpec，将ECCCommonParamsSpec对象传入，创建非对称密钥生成器（AsyKeyGeneratorBySpec）。
3.  调用AsyKeyGeneratorBySpec.generateKeyPair，得到随机生成的密钥对（KeyPair）。
4.  分别传入密钥对中的私钥和公钥，调用PriKey.getAsyKeySpec和PubKey.getAsyKeySpec，获取ECC算法中私钥和公钥的各种密钥参数。
-  以使用Promise方式根据密钥参数生成ECC密钥为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { BusinessError } from '@kit.BasicServicesKit';
// 打印bigint信息
function showBigIntInfo(bnName: string, bnValue: bigint | string | number) {
if (typeof bnValue === 'string') {
console.error('type is string');
return;
}
if (typeof bnValue === 'number') {
console.error('type is number');
return;
}
console.info(bnName + ':');
console.info('. Decimal: ' + bnValue.toString());
console.info('. Hexadecimal: ' + bnValue.toString(16));
console.info('. Length (bits): ' + bnValue.toString(2).length);
}
// 根据关键规范构造EccCommonSpec结构体。EccCommonSpec结构体定义了ECC私钥和公钥的公共参数
function genEccCommonSpec(): cryptoFramework.ECCCommonParamsSpec {
let fieldFp: cryptoFramework.ECFieldFp = {
fieldType: 'Fp',
p: BigInt('0xffffffffffffffffffffffffffffffff000000000000000000000001')
}
let G: cryptoFramework.Point = {
x: BigInt('0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21'),
y: BigInt('0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34')
}
let eccCommonSpec: cryptoFramework.ECCCommonParamsSpec = {
algName: 'ECC',
specType: cryptoFramework.AsyKeySpecType.COMMON_PARAMS_SPEC,
field: fieldFp,
a: BigInt('0xfffffffffffffffffffffffffffffffefffffffffffffffffffffffe'),
b: BigInt('0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4'),
g: G,
n: BigInt('0xffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d'),
h: 1
}
return eccCommonSpec;
}
// 打印ECC密钥规格
function showEccSpecDetailInfo(key: cryptoFramework.PubKey | cryptoFramework.PriKey, keyType: string) {
console.info('show detail of ' + keyType + ':');
try {
let p = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_FP_P_BN);
showBigIntInfo('--- p', p); // length is 224, hex : ffffffffffffffffffffffffffffffff000000000000000000000001
let a = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_A_BN);
showBigIntInfo('--- a', a); // length is 224, hex : fffffffffffffffffffffffffffffffefffffffffffffffffffffffe
let b = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_B_BN);
showBigIntInfo('--- b', b); // length is 224, hex : b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4
let gX = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_G_X_BN);
showBigIntInfo('--- gX', gX); // length is 224, hex : b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21
let gY = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_G_Y_BN);
showBigIntInfo('--- gY', gY); // length is 224, hex : bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34
let n = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_N_BN);
showBigIntInfo('--- n', n); // length is 224, hex : ffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d
let h = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_H_NUM);
console.warn('--- h: ' + h); // key h: 1
let fieldType = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_FIELD_TYPE_STR);
console.warn('--- field type: ' + fieldType); // key field type: Fp
let fieldSize = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_FIELD_SIZE_NUM);
console.warn('--- field size: ' + fieldSize); // key field size: 224
let curveName = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_CURVE_NAME_STR);
console.warn('--- curve name: ' + curveName); // key curve name: NID_secp224r1
if (keyType === 'priKey') {
let sk = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_SK_BN);
showBigIntInfo('--- sk', sk);
} else if (keyType === 'pubKey') {
let pkX = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_PK_X_BN);
showBigIntInfo('--- pkX', pkX);
let pkY = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_PK_Y_BN);
showBigIntInfo('--- pkY', pkY);
}
} catch (error) {
console.error('getAsyKeySpec error');
let e: BusinessError = error as BusinessError;
console.error(`getAsyKeySpec failed, ${e.code}, ${e.message}`);
}
}
// 根据EccCommonSpec实例生成ECC密钥对，获取密钥规格
function testEccUseCommKeySpecGet() {
try {
let commKeySpec = genEccCommonSpec(); // 使用参数属性，构造ECC公私钥公共密钥参数对象
let generatorBySpec = cryptoFramework.createAsyKeyGeneratorBySpec(commKeySpec); // 使用密钥参数对象创建生成器
let keyPairPromise = generatorBySpec.generateKeyPair(); // Generate an ECC key pair.
keyPairPromise.then(keyPair => { // 使用生成器创建ECC密钥对
showEccSpecDetailInfo(keyPair.priKey, 'priKey'); // 对私钥获取相关密钥参数属性
showEccSpecDetailInfo(keyPair.pubKey, 'pubKey'); // 对公钥获取相关密钥参数属性
}).catch((error: BusinessError) => {
// 逻辑错误等异步异常在此捕获
console.error('generateComm error');
console.error('error code: ' + error.code + ', message is: ' + error.message);
})
} catch (error) {
// 参数错误等同步异常在此捕获
console.error('testEccUseCommSpec error');
let e: BusinessError = error as BusinessError;
console.error(`ecc comm spec failed, ${e.code}, ${e.message}`);
}
}
```
-  同步返回结果（调用方法generateKeyPairSync）：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function showBigIntInfo(bnName: string, bnValue: bigint | string | number) {
if (typeof bnValue === 'string') {
console.error('type is string');
return;
}
if (typeof bnValue === 'number') {
console.error('type is number');
return;
}
console.info(bnName + ':');
console.info('. Decimal: ' + bnValue.toString());
console.info('. Hexadecimal: ' + bnValue.toString(16));
console.info('. Length (bits): ' + bnValue.toString(2).length);
}
// 根据关键规范构造EccCommonSpec结构体。EccCommonSpec结构体定义了ECC私钥和公钥的公共参数
function genEccCommonSpec(): cryptoFramework.ECCCommonParamsSpec {
let fieldFp: cryptoFramework.ECFieldFp = {
fieldType: 'Fp',
p: BigInt('0xffffffffffffffffffffffffffffffff000000000000000000000001')
}
let G: cryptoFramework.Point = {
x: BigInt('0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21'),
y: BigInt('0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34')
}
let eccCommonSpec: cryptoFramework.ECCCommonParamsSpec = {
algName: 'ECC',
specType: cryptoFramework.AsyKeySpecType.COMMON_PARAMS_SPEC,
field: fieldFp,
a: BigInt('0xfffffffffffffffffffffffffffffffefffffffffffffffffffffffe'),
b: BigInt('0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4'),
g: G,
n: BigInt('0xffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d'),
h: 1
}
return eccCommonSpec;
}
// 打印ECC密钥规格
function showEccSpecDetailInfo(key: cryptoFramework.PubKey | cryptoFramework.PriKey, keyType: string) {
console.info('show detail of ' + keyType + ':');
try {
let p = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_FP_P_BN);
showBigIntInfo('--- p', p); // length is 224, hex : ffffffffffffffffffffffffffffffff000000000000000000000001
let a = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_A_BN);
showBigIntInfo('--- a', a); // length is 224, hex : fffffffffffffffffffffffffffffffefffffffffffffffffffffffe
let b = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_B_BN);
showBigIntInfo('--- b', b); // length is 224, hex : b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4
let gX = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_G_X_BN);
showBigIntInfo('--- gX', gX); // length is 224, hex : b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21
let gY = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_G_Y_BN);
showBigIntInfo('--- gY', gY); // length is 224, hex : bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34
let n = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_N_BN);
showBigIntInfo('--- n', n); // length is 224, hex : ffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d
let h = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_H_NUM);
console.warn('--- h: ' + h); // key h: 1
let fieldType = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_FIELD_TYPE_STR);
console.warn('--- field type: ' + fieldType); // key field type: Fp
let fieldSize = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_FIELD_SIZE_NUM);
console.warn('--- field size: ' + fieldSize); // key field size: 224
let curveName = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_CURVE_NAME_STR);
console.warn('--- curve name: ' + curveName); // key curve name: NID_secp224r1
if (keyType === 'priKey') {
let sk = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_SK_BN);
showBigIntInfo('--- sk', sk);
} else if (keyType === 'pubKey') {
let pkX = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_PK_X_BN);
showBigIntInfo('--- pkX', pkX);
let pkY = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_PK_Y_BN);
showBigIntInfo('--- pkY', pkY);
}
} catch (e) {
console.error(`getAsyKeySpec failed, ${e.code}, ${e.message}`);
}
}
// 根据EccCommonSpec实例生成ECC密钥对，获取密钥规格
function testEccUseCommKeySpecGetSync() {
try {
let commKeySpec = genEccCommonSpec(); // 使用参数属性，构造ECC公私钥公共密钥参数对象
let generatorBySpec = cryptoFramework.createAsyKeyGeneratorBySpec(commKeySpec); // 使用密钥参数对象创建生成器
let keyPair = generatorBySpec.generateKeyPairSync(); // Generate an ECC key pair.
if (keyPair !== null) {
showEccSpecDetailInfo(keyPair.priKey, 'priKey'); // 对私钥获取相关密钥参数属性
showEccSpecDetailInfo(keyPair.pubKey, 'pubKey'); // 对公钥获取相关密钥参数属性
} else {
console.error('get key pair result fail!');
}
} catch (e) {
// 逻辑错误等异常在此捕获
console.error(`get key pair result fail, ${e.code}, ${e.message}`);
}
}
```
根据椭圆曲线名生成SM2密钥对
对应的算法规格请查看非对称密钥生成和转换规格：SM2。
1.  构造ECCCommonParamsSpec对象，用于指定非对称公共密钥参数。根据genECCCommonParamsSpec接口传入相应的NID字符串名称生成相应的非对称公共密钥参数。 使用密钥参数生成密钥时，用到的bigint类型需要以大端模式输入，且必须为正数。
2.  创建ECCKeyPairSpec对象，并且algName设置为SM2，用于指定SM2算法中密钥对包含的参数。
3.  调用cryptoFramework.createAsyKeyGeneratorBySpec，将ECCKeyPairSpec对象传入，创建非对称密钥生成器。
4.  调用AsyKeyGeneratorBySpec.generateKeyPair，得到各项数据与密钥参数一致的密钥对（KeyPair）。
5.  调用PriKey.getAsyKeySpec，获取SM2算法中椭圆曲线参数。
-  以使用Promise方式根据椭圆曲线名生成SM2密钥为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function genSM2KeyPairSpec() {
let sm2CommonParamsSpec = cryptoFramework.ECCKeyUtil.genECCCommonParamsSpec('NID_sm2');
let sm2KeyPairSpec: cryptoFramework.ECCKeyPairSpec = {
algName: "SM2",
specType: cryptoFramework.AsyKeySpecType.KEY_PAIR_SPEC,
params: sm2CommonParamsSpec,
sk: BigInt('0x6330B599ECD23ABDC74B9A5B7B5E00E553005F72743101C5FAB83AEB579B7074'),
pk: {
x: BigInt('0x67F3B850BDC0BA5D3A29D8A0883C4B17612AB84F87F18E28F77D824A115C02C4'),
y: BigInt('0xD48966CE754BBBEDD6501A1385E1B205C186E926ADED44287145E8897D4B2071')
},
};
return sm2KeyPairSpec;
}
async function sm2Test() {
let sm2KeyPairSpec = genSM2KeyPairSpec();
let generatorBySpec = cryptoFramework.createAsyKeyGeneratorBySpec(sm2KeyPairSpec);
let keyPair = await generatorBySpec.generateKeyPair();
let sm2CurveName = keyPair.priKey.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_CURVE_NAME_STR);
console.info('ECC_CURVE_NAME_STR: ' + sm2CurveName); // NID_sm2
}
```
-  同步返回结果（调用方法generateKeyPairSync）：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function genSM2KeyPairSpec() {
let sm2CommonParamsSpec = cryptoFramework.ECCKeyUtil.genECCCommonParamsSpec('NID_sm2');
let sm2KeyPairSpec: cryptoFramework.ECCKeyPairSpec = {
algName: "SM2",
specType: cryptoFramework.AsyKeySpecType.KEY_PAIR_SPEC,
params: sm2CommonParamsSpec,
sk: BigInt('0x6330B599ECD23ABDC74B9A5B7B5E00E553005F72743101C5FAB83AEB579B7074'),
pk: {
x: BigInt('0x67F3B850BDC0BA5D3A29D8A0883C4B17612AB84F87F18E28F77D824A115C02C4'),
y: BigInt('0xD48966CE754BBBEDD6501A1385E1B205C186E926ADED44287145E8897D4B2071')
},
};
return sm2KeyPairSpec;
}
function sm2TestSync() {
let sm2KeyPairSpec = genSM2KeyPairSpec();
let generatorBySpec = cryptoFramework.createAsyKeyGeneratorBySpec(sm2KeyPairSpec);
try {
let keyPair = generatorBySpec.generateKeyPairSync();
if (keyPair !== null) {
let sm2CurveName = keyPair.priKey.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_CURVE_NAME_STR);
console.info('ECC_CURVE_NAME_STR: ' + sm2CurveName); // NID_sm2
} else {
console.error('get key pair result fail!');
}
} catch (e) {
console.error(`get key pair result fail, ${e.code}, ${e.message}`);
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/ypto-convert-compressed-or-uncompressed-ecc-pubkey-V14
爬取时间: 2025-04-28 01:38:30
来源: Huawei Developer
可通过指定ECC公钥数据，生成公钥对象（PubKey）；也可从公钥对象（PubKey）中，获取ECC公钥数据。
当前仅支持ECC算法中，满足X509规范的压缩/非压缩格式的公钥数据。此处的公钥数据应当是完整的X509公钥，对于只使用点数据的情况，请参考使用ECC压缩/非压缩点格式转换。
ECC的算法规格请查看非对称密钥生成和转换规格：ECC。
通过传入字符串参数format，可指定需要获取的ECC公钥数据格式。如果需要获取满足X509规范的压缩格式数据，则指定format为："X509|COMPRESSED"；需要获取非压缩格式，则指定format为："X509|UNCOMPRESSED"。
指定非压缩公钥数据转换为压缩公钥数据
1.  指定Uint8Array类型的ECC非压缩公钥数据，封装成DataBlob对象。 公钥和私钥可只传入其中一个，此处示例以传入非压缩公钥为例。
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
async function eccPubUncompressedToCompressed() {
let pkData = new Uint8Array([48, 90, 48, 20, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 9, 43, 36, 3, 3, 2, 8, 1, 1, 7, 3, 66, 0, 4, 143, 39, 57, 249, 145, 50, 63, 222, 35, 70, 178, 121, 202, 154, 21, 146, 129, 75, 76, 63, 8, 195, 157, 111, 40, 217, 215, 148, 120, 224, 205, 82, 83, 92, 185, 21, 211, 184, 5, 19, 114, 33, 86, 85, 228, 123, 242, 206, 200, 98, 178, 184, 130, 35, 232, 45, 5, 202, 189, 11, 46, 163, 156, 152]);
let pubKeyBlob: cryptoFramework.DataBlob = { data: pkData };
let generator = cryptoFramework.createAsyKeyGenerator('ECC_BrainPoolP256r1');
let keyPair = await generator.convertKey(pubKeyBlob, null);
let returnBlob = keyPair.pubKey.getEncodedDer('X509|COMPRESSED');
console.info('returnBlob data：' + returnBlob.data);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/-convert-compressed-or-uncompressed-ecc-pubkey-ndk-V14
爬取时间: 2025-04-28 01:38:43
来源: Huawei Developer
可通过指定ECC公钥数据，生成公钥对象（PubKey）；也可从公钥对象中，获取ECC公钥数据。
当前仅支持ECC算法中，满足X509规范的压缩/非压缩格式的公钥数据。此处的公钥数据应当是完整的X509公钥，对于只使用点数据的情况，请参考使用ECC压缩/非压缩点格式转换。
ECC的算法规格请查看非对称密钥生成和转换规格：ECC。
通过传入字符串参数，可指定需要获取的ECC公钥数据格式。如果需要获取满足X509规范的压缩格式数据，则指定参数为："X509|COMPRESSED"；需要获取非压缩格式，则指定参数为："X509|UNCOMPRESSED"。
指定非压缩公钥数据转换为压缩公钥数据
1.  指定uint8_t类型的ECC非压缩公钥数据，封装成Crypto_DataBlob。 公钥和私钥可只传入其中一个，此处示例以传入非压缩公钥为例。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/rypto-convert-compressed-or-uncompressed-ecc-point-V14
爬取时间: 2025-04-28 01:38:57
来源: Huawei Developer
支持将压缩/非压缩的点数据，转换为Point对象，用于密钥对象生成；也支持将Point对象转换为压缩/非压缩的点数据。
ECC的算法规格请查看非对称密钥生成和转换规格：ECC。
通过传入字符串参数format，可指定需要获取的点数据格式。如果需要获取压缩格式，则指定format为："COMPRESSED"；需要获取非压缩格式，则指定format为："UNCOMPRESSED"。
指定非压缩点数据转换为压缩点数据
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function eccPointUncompressedToCompressed() {
let pkData = new Uint8Array([4, 143, 39, 57, 249, 145, 50, 63, 222, 35, 70, 178, 121, 202, 154, 21, 146, 129, 75, 76, 63, 8, 195, 157, 111, 40, 217, 215, 148, 120, 224, 205, 82, 83, 92, 185, 21, 211, 184, 5, 19, 114, 33, 86, 85, 228, 123, 242, 206, 200, 98, 178, 184, 130, 35, 232, 45, 5, 202, 189, 11, 46, 163, 156, 152]);
let returnPoint = cryptoFramework.ECCKeyUtil.convertPoint('NID_brainpoolP256r1', pkData);
console.info('convertPoint success');
let returnData = cryptoFramework.ECCKeyUtil.getEncodedPoint('NID_brainpoolP256r1', returnPoint, 'COMPRESSED');
console.info('returnData: ' + returnData); // (因为y为偶数，所以压缩点数据的前缀是02)returnData: 2,143,39,57,249,145,50,63,222,35,70,178,121,202,154,21,146,129,75,76,63,8,195,157,111,40,217,215,148,120,224,205,82
}
```
指定压缩点数据获取密钥对象
1.  构造ECCPubKeySpec对象，用于指定ECC算法中公钥包含的参数。ECCPubKeySpec是AsyKeySpec的子类。需要通过参数algName指定算法'ECC'； 指定密钥参数类型AsyKeySpecType.PUBLIC_KEY_SPEC，参数pk指定为得到的point对象。
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
async function eccPointCompressedToPoint() {
let pkData = new Uint8Array([2, 143, 39, 57, 249, 145, 50, 63, 222, 35, 70, 178, 121, 202, 154, 21, 146, 129, 75, 76, 63, 8, 195, 157, 111, 40, 217, 215, 148, 120, 224, 205, 82]);
let returnPoint = cryptoFramework.ECCKeyUtil.convertPoint('NID_brainpoolP256r1', pkData);
console.info('convertPoint success');
let eccCommonParamsSpec = cryptoFramework.ECCKeyUtil.genECCCommonParamsSpec('NID_brainpoolP256r1');
let eccPubKeySpec: cryptoFramework.ECCPubKeySpec = {
algName: "ECC",
specType: cryptoFramework.AsyKeySpecType.PUBLIC_KEY_SPEC,
params: eccCommonParamsSpec,
pk: returnPoint
};
let generatorBySpec = cryptoFramework.createAsyKeyGeneratorBySpec(eccPubKeySpec);
let pubKey = await generatorBySpec.generatePubKey();
let returnData = cryptoFramework.ECCKeyUtil.getEncodedPoint('NID_brainpoolP256r1', returnPoint, 'UNCOMPRESSED');
console.info('returnData: ' + returnData); // 4,143,39,57,249,145,50,63,222,35,70,178,121,202,154,21,146,129,75,76,63,8,195,157,111,40,217,215,148,120,224,205,82,83,92,185,21,211,184,5,19,114,33,86,85,228,123,242,206,200,98,178,184,130,35,232,45,5,202,189,11,46,163,156,152
let eccPkX = pubKey.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_PK_X_BN);
console.info('returnPoint x data: ' + returnPoint.x); // 64750044510792891439269945828433327517677381559622384455951527515863444933970
console.info('ECC_PK_X_BN：' + eccPkX); // 64750044510792891439269945828433327517677381559622384455951527515863444933970
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-convert-string-data-to-asym-key-pair-V14
爬取时间: 2025-04-28 01:39:11
来源: Huawei Developer
以RSA为例，根据指定的非对称密钥字符串数据，生成非对称密钥对（KeyPair）。
针对非对称密钥的convertPemKey操作：
-  公钥需满足：X.509规范、PKCS#1规范、PEM编码格式。
-  私钥需满足：PKCS#8规范、PKCS#1规范、PEM编码格式。
-  当前只支持RSA非对称密钥的转换。
指定PEM格式字符串数据转换RSA密钥对
对应的算法规格请查看非对称密钥生成和转换规格：RSA。
1.  调用cryptoFramework.createAsyKeyGenerator，指定字符串参数'RSA1024'，创建RSA密钥类型为RSA1024、素数个数为2的非对称密钥生成器（AsyKeyGenerator）。 生成RSA非对称密钥时，默认素数为2，此处省略了参数PRIMES_2。
2.  调用AsyKeyGenerator.convertPemKey，传入二进制密钥数据，生成非对称密钥对象（KeyPair）。
3.  调用AsyKeyGenerator.getEncodedPem，将非对称密钥对象中的公钥转换成pkcs1或x509格式，私钥转换成pkcs1或pkcs8格式。
-  以使用Promise方式生成RSA密钥对为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
let priKeyPkcs1Str1024: string  =
"-----BEGIN RSA PRIVATE KEY-----\n"
+ "MIICXQIBAAKBgQCwIN3mr21+N96ToxnVnaS+xyK9cNRAHiHGgrbjHw6RAj3V+l+W\n"
+ "Y68IhIe3DudVlzE9oMjeOQwkMkq//HCxNlIlFR6O6pa0mrXSwPRE7YKG97CeKk2g\n"
+ "YOS8YEh8toAvm7xKbiLkXuuMlxrjP2j/mb5iI/UASFSPZiQ/IyxDr0AQaQIDAQAB\n"
+ "AoGAEvBFzBNa+7J4PXnRQlYEK/tvsd0bBZX33ceacMubHl6WVZbphltLq+fMTBPP\n"
+ "LjXmtpC+aJ7Lvmyl+wTi/TsxE9vxW5JnbuRT48rnZ/Xwq0eozDeEeIBRrpsr7Rvr\n"
+ "7ctrgzr4m4yMHq9aDgpxj8IR7oHkfwnmWr0wM3FuiVlj650CQQDineeNZ1hUTkj4\n"
+ "D3O+iCi3mxEVEeJrpqrmSFolRMb+iozrIRKuJlgcOs+Gqi2fHfOTTL7LkpYe8SVg\n"
+ "e3JxUdVLAkEAxvcZXk+byMFoetrnlcMR13VHUpoVeoV9qkv6CAWLlbMdgf7uKmgp\n"
+ "a1Yp3QPDNQQqkPvrqtfR19JWZ4uy1qREmwJALTU3BjyBoH/liqb6fh4HkWk75Som\n"
+ "MzeSjFIOubSYxhq5tgZpBZjcpvUMhV7Zrw54kwASZ+YcUJvmyvKViAm9NQJBAKF7\n"
+ "DyXSKrem8Ws0m1ybM7HQx5As6l3EVhePDmDQT1eyRbKp+xaD74nkJpnwYdB3jyyY\n"
+ "qc7A1tj5J5NmeEFolR0CQQCn76Xp8HCjGgLHw9vg7YyIL28y/XyfFyaZAzzK+Yia\n"
+ "akNwQ6NeGtXSsuGCcyyfpacHp9xy8qXQNKSkw03/5vDO\n"
+ "-----END RSA PRIVATE KEY-----\n";
let publicPkcs1Str1024: string  =
"-----BEGIN RSA PUBLIC KEY-----\n"
+ "MIGJAoGBALAg3eavbX433pOjGdWdpL7HIr1w1EAeIcaCtuMfDpECPdX6X5ZjrwiE\n"
+ "h7cO51WXMT2gyN45DCQySr/8cLE2UiUVHo7qlrSatdLA9ETtgob3sJ4qTaBg5Lxg\n"
+ "SHy2gC+bvEpuIuRe64yXGuM/aP+ZvmIj9QBIVI9mJD8jLEOvQBBpAgMBAAE=\n"
+ "-----END RSA PUBLIC KEY-----\n";
async function TestPkcs1ToPkcs8ByPromise() {
let asyKeyGenerator = cryptoFramework.createAsyKeyGenerator('RSA1024');
let keyPair = await asyKeyGenerator.convertPemKey(publicPkcs1Str1024, priKeyPkcs1Str1024);
let priPemKey = keyPair.priKey;
let pubPemKey = keyPair.pubKey;
let priString = priPemKey.getEncodedPem('PKCS8');
let pubString = pubPemKey.getEncodedPem('X509');
console.info("[promise]TestPkcs1ToPkcs8ByPromise priString output is " + priString);
console.info("[promise]TestPkcs1ToPkcs8ByPromise pubString output is " + pubString);
}
```
-  同步返回结果（调用方法convertPemKeySync）：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
let priKeyPkcs1Str1024: string  =
"-----BEGIN RSA PRIVATE KEY-----\n"
+ "MIICXQIBAAKBgQCwIN3mr21+N96ToxnVnaS+xyK9cNRAHiHGgrbjHw6RAj3V+l+W\n"
+ "Y68IhIe3DudVlzE9oMjeOQwkMkq//HCxNlIlFR6O6pa0mrXSwPRE7YKG97CeKk2g\n"
+ "YOS8YEh8toAvm7xKbiLkXuuMlxrjP2j/mb5iI/UASFSPZiQ/IyxDr0AQaQIDAQAB\n"
+ "AoGAEvBFzBNa+7J4PXnRQlYEK/tvsd0bBZX33ceacMubHl6WVZbphltLq+fMTBPP\n"
+ "LjXmtpC+aJ7Lvmyl+wTi/TsxE9vxW5JnbuRT48rnZ/Xwq0eozDeEeIBRrpsr7Rvr\n"
+ "7ctrgzr4m4yMHq9aDgpxj8IR7oHkfwnmWr0wM3FuiVlj650CQQDineeNZ1hUTkj4\n"
+ "D3O+iCi3mxEVEeJrpqrmSFolRMb+iozrIRKuJlgcOs+Gqi2fHfOTTL7LkpYe8SVg\n"
+ "e3JxUdVLAkEAxvcZXk+byMFoetrnlcMR13VHUpoVeoV9qkv6CAWLlbMdgf7uKmgp\n"
+ "a1Yp3QPDNQQqkPvrqtfR19JWZ4uy1qREmwJALTU3BjyBoH/liqb6fh4HkWk75Som\n"
+ "MzeSjFIOubSYxhq5tgZpBZjcpvUMhV7Zrw54kwASZ+YcUJvmyvKViAm9NQJBAKF7\n"
+ "DyXSKrem8Ws0m1ybM7HQx5As6l3EVhePDmDQT1eyRbKp+xaD74nkJpnwYdB3jyyY\n"
+ "qc7A1tj5J5NmeEFolR0CQQCn76Xp8HCjGgLHw9vg7YyIL28y/XyfFyaZAzzK+Yia\n"
+ "akNwQ6NeGtXSsuGCcyyfpacHp9xy8qXQNKSkw03/5vDO\n"
+ "-----END RSA PRIVATE KEY-----\n";
let publicPkcs1Str1024: string  =
"-----BEGIN RSA PUBLIC KEY-----\n"
+ "MIGJAoGBALAg3eavbX433pOjGdWdpL7HIr1w1EAeIcaCtuMfDpECPdX6X5ZjrwiE\n"
+ "h7cO51WXMT2gyN45DCQySr/8cLE2UiUVHo7qlrSatdLA9ETtgob3sJ4qTaBg5Lxg\n"
+ "SHy2gC+bvEpuIuRe64yXGuM/aP+ZvmIj9QBIVI9mJD8jLEOvQBBpAgMBAAE=\n"
+ "-----END RSA PUBLIC KEY-----\n";
function TestPkcs1ToPkcs8BySync() {
let asyKeyGenerator = cryptoFramework.createAsyKeyGenerator('RSA1024');
try {
let keyPairData = asyKeyGenerator.convertPemKeySync(publicPkcs1Str1024, priKeyPkcs1Str1024);
if (keyPairData !== null) {
console.info('[Sync]: convert pem key pair success');
} else {
console.error("[Sync]: convert pem key pair result fail!");
}
let priPemKey = keyPairData.priKey;
let pubPemKey = keyPairData.pubKey;
let priString = priPemKey.getEncodedPem('PKCS8');
let pubString = pubPemKey.getEncodedPem('X509');
console.info("[Sync]TestPkcs1ToPkcs8BySync priString output is " + priString);
console.info("[Sync]TestPkcs1ToPkcs8BySync pubString output is " + pubString);
} catch (e) {
console.error(`Sync error, ${e.code}, ${e.message}`);
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-convert-string-data-to-asym-key-pair-ndk-V14
爬取时间: 2025-04-28 01:39:24
来源: Huawei Developer
以RSA为例，根据指定的非对称密钥字符串数据，生成非对称密钥对（OH_CryptoKeyPair）。
针对非对称密钥的convertPemKey操作：
-  公钥需满足：X.509规范、PKCS#1规范、PEM编码格式。
-  私钥需满足：PKCS#8规范、PKCS#1规范、PEM编码格式。
-  当前只支持RSA非对称密钥的转换。
在CMake脚本中链接相关动态库
指定PEM格式字符串数据转换RSA密钥对
对应的算法规格请查看非对称密钥生成和转换规格：RSA。
1.  调用OH_CryptoAsymKeyGenerator_Create，指定字符串参数'RSA1024'，创建RSA密钥类型为RSA1024、素数个数为2的非对称密钥生成器（OH_CryptoAsymKeyGenerator）。 生成RSA非对称密钥时，默认素数为2，此处省略了参数PRIMES_2。
2.  调用OH_CryptoAsymKeyGenerator_Convert，传入二进制密钥数据，生成非对称密钥对象（OH_CryptoKeyPair）。
3.  调用OH_CryptoPubKey_Encode，将非对称密钥对象中的公钥转换成pkcs1或x509格式。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-encryption-decryption-V14
爬取时间: 2025-04-28 01:39:38
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-encryption-decryption-overview-V14
爬取时间: 2025-04-28 01:39:51
来源: Huawei Developer
在数据存储或传输场景中，可以使用加解密操作用于保证数据的机密性，防止敏感数据泄露。
使用加解密操作中，典型的场景有：
1.  使用对称密钥的加解密操作。
2.  使用非对称密钥的加解密操作。
3.  使用RSA（PKCS1_OAEP填充模式）时，获取、设置CipherSpecItem参数。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-encrypt-decrypt-spec-V14
爬取时间: 2025-04-28 01:40:05
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sym-encrypt-decrypt-spec-V14
爬取时间: 2025-04-28 01:40:18
来源: Huawei Developer
当前章节将说明系统目前支持的算法及其对应的规格。
对于每种算法采用支持的加密模式，将会在具体的每个算法规格中介绍。
AES
算法库当前提供了AES加解密常用的7种加密模式：ECB、CBC、OFB、CFB、CTR、GCM和CCM。不同的加密模式适用的加解密参数不同，具体请参考ParamsSpec。
由于AES为分组加密算法，分组长度为128位。在实际应用中，最后一组明文可能不足128位（16字节），此时可以通过不同的填充模式进行数据填充。
由于需要填充至分组大小，所以实际算法库中的PKCS5和PKCS7都是以分组大小作为填充长度的，即AES加密填充至16字节。
ECB、CBC加密模式，明文长度不是128位整数倍，必须使用填充方法补足。
CCM加密模式，必须指定附加验证数据aad且其长度必须大于等于1字节且小于等于2048字节。
当前支持以字符串参数完成AES加解密，具体的“字符串参数”由“对称密钥类型（加解密算法+密钥长度）”、“分组模式”和“填充模式”使用符号“|”拼接而成，用于在创建对称加解密实例时，指定算法规格。
-  如表所示，各取值范围（即[]中的内容）中，只能选取一项完成字符串拼接。 举例说明： 当需要分组模式为ECB、密钥长度为128bit、填充模式为PKCS7的AES密钥，其字符串参数为"AES128|ECB|PKCS7"。 当需要分组模式为CFB、密钥长度为256bit、填充模式为NoPadding的AES密钥，其字符串参数为"AES256|CFB|NoPadding"。
-  当需要分组模式为ECB、密钥长度为128bit、填充模式为PKCS7的AES密钥，其字符串参数为"AES128|ECB|PKCS7"。
-  当需要分组模式为CFB、密钥长度为256bit、填充模式为NoPadding的AES密钥，其字符串参数为"AES256|CFB|NoPadding"。
-  从API版本10开始，支持对称加解密不带密钥长度的规格。加解密参数输入密钥类型时，支持不带长度，加解密运算取决于实际输入的密钥长度。 举例说明，当需要分组模式为CFB、不带密钥长度、填充模式为NoPadding的AES密钥，其字符串参数为"AES|CFB|NoPadding"。
-  当需要分组模式为ECB、密钥长度为128bit、填充模式为PKCS7的AES密钥，其字符串参数为"AES128|ECB|PKCS7"。
-  当需要分组模式为CFB、密钥长度为256bit、填充模式为NoPadding的AES密钥，其字符串参数为"AES256|CFB|NoPadding"。
| 分组模式 | 密钥长度（bit） | 填充模式 | API版本 |
| --- | --- | --- | --- |
| ECB | [128|192|256] | [NoPadding|PKCS5|PKCS7] | 9+ |
| CBC | [128|192|256] | [NoPadding|PKCS5|PKCS7] | 9+ |
| CTR | [128|192|256] | [NoPadding|PKCS5|PKCS7] | 9+ |
| OFB | [128|192|256] | [NoPadding|PKCS5|PKCS7] | 9+ |
| CFB | [128|192|256] | [NoPadding|PKCS5|PKCS7] | 9+ |
| GCM | [128|192|256] | [NoPadding|PKCS5|PKCS7] | 9+ |
| CCM | [128|192|256] | [NoPadding|PKCS5|PKCS7] | 9+ |
3DES
3DES算法的加解密过程分别是对明文/密文数据进行三次DES加密或解密，得到相应的密文或明文。
算法库当前提供了3DES加解密常用的4种加密模式：ECB、CBC、OFB和CFB。不同的加密模式适用的加解密参数不同，具体请参考ParamsSpec。
由于DES为分组加密算法，分组长度为64位。在实际应用中，最后一组明文可能不足64位（8字节），此时可以通过不同的填充模式进行数据填充。
由于需要填充至分组大小，所以实际算法库中的PKCS5和PKCS7都是以分组大小作为填充长度的，即3DES加密填充至8字节。
ECB、CBC加密模式，明文长度不是64位整数倍，必须使用填充方法补足。
当前支持以字符串参数完成3DES加解密，具体的“字符串参数”由“对称密钥类型（加解密算法+密钥长度）”、“分组模式”和“填充模式”使用符号“|”拼接而成，用于在创建对称加解密实例时，指定算法规格。
-  如表所示，各取值范围（即[]中的内容）中，只能选取一项完成字符串拼接。 举例说明： 当需要分组模式为ECB、密钥长度为192bit、填充模式为PKCS7的3DES密钥，其字符串参数为"3DES192|ECB|PKCS7"。 当需要分组模式为OFB、密钥长度为192bit、填充模式为NoPadding的3DES密钥，其字符串参数为"3DES192|OFB|NoPadding"。
-  当需要分组模式为ECB、密钥长度为192bit、填充模式为PKCS7的3DES密钥，其字符串参数为"3DES192|ECB|PKCS7"。
-  当需要分组模式为OFB、密钥长度为192bit、填充模式为NoPadding的3DES密钥，其字符串参数为"3DES192|OFB|NoPadding"。
-  从API版本10开始，支持对称加解密不带密钥长度的规格。加解密参数输入密钥类型时，支持不带长度，加解密运算取决于实际输入的密钥长度。 举例说明，当需要分组模式为CFB、不带密钥长度、填充模式为NoPadding的3DES密钥，其字符串参数为"3DES|CFB|NoPadding"。
-  当需要分组模式为ECB、密钥长度为192bit、填充模式为PKCS7的3DES密钥，其字符串参数为"3DES192|ECB|PKCS7"。
-  当需要分组模式为OFB、密钥长度为192bit、填充模式为NoPadding的3DES密钥，其字符串参数为"3DES192|OFB|NoPadding"。
| 分组模式 | 密钥长度（bit） | 填充模式 | API版本 |
| --- | --- | --- | --- |
| ECB | 192 | [NoPadding|PKCS5|PKCS7] | 9+ |
| CBC | 192 | [NoPadding|PKCS5|PKCS7] | 9+ |
| OFB | 192 | [NoPadding|PKCS5|PKCS7] | 9+ |
| CFB | 192 | [NoPadding|PKCS5|PKCS7] | 9+ |
SM4
算法库当前提供了SM4加解密常用的7种加密模式：ECB、CBC、CTR、OFB、CFB、CFB128和GCM。不同的加密模式适用的加解密参数不同，具体请参考ParamsSpec。
由于SM4为分组加密算法，分组长度为128位。在实际应用中，最后一组明文可能不足128位（16字节），此时可以通过不同的填充模式进行数据填充。
由于需要填充至分组大小，所以实际算法库中的PKCS5和PKCS7都是以分组大小作为填充长度的，即SM4加密填充至16字节。
ECB、CBC加密模式，明文长度不是128位整数倍，必须使用填充方法补足。
当前支持以字符串参数完成SM4加解密，具体的“字符串参数”由“对称密钥类型（加解密算法+密钥长度）”、“分组模式”和“填充模式”使用符号“|”拼接而成，用于在创建对称加解密实例时，指定算法规格。
-  如表所示，各取值范围（即[]中的内容）中，只能选取一项完成字符串拼接。SM4算法和密钥长度中间采用符号“_”拼接。 举例说明： 当需要分组模式为ECB、密钥长度为128bit、填充模式为PKCS7的SM4密钥，其字符串参数为"SM4_128|ECB|PKCS7"。 当需要分组模式为CFB、密钥长度为128bit、填充模式为NoPadding的SM4密钥，其字符串参数为"SM4_128|CFB|NoPadding"。 当需要分组模式为GCM、密钥长度为128bit、填充模式为NoPadding的SM4密钥，其字符串参数为"SM4_128|GCM|NoPadding"。
-  当需要分组模式为ECB、密钥长度为128bit、填充模式为PKCS7的SM4密钥，其字符串参数为"SM4_128|ECB|PKCS7"。
-  当需要分组模式为CFB、密钥长度为128bit、填充模式为NoPadding的SM4密钥，其字符串参数为"SM4_128|CFB|NoPadding"。
-  当需要分组模式为GCM、密钥长度为128bit、填充模式为NoPadding的SM4密钥，其字符串参数为"SM4_128|GCM|NoPadding"。
-  当需要分组模式为ECB、密钥长度为128bit、填充模式为PKCS7的SM4密钥，其字符串参数为"SM4_128|ECB|PKCS7"。
-  当需要分组模式为CFB、密钥长度为128bit、填充模式为NoPadding的SM4密钥，其字符串参数为"SM4_128|CFB|NoPadding"。
-  当需要分组模式为GCM、密钥长度为128bit、填充模式为NoPadding的SM4密钥，其字符串参数为"SM4_128|GCM|NoPadding"。
| 分组模式 | 密钥长度（bit） | 填充模式 | API版本 |
| --- | --- | --- | --- |
| ECB | 128 | [NoPadding|PKCS5|PKCS7] | 10+ |
| CBC | 128 | [NoPadding|PKCS5|PKCS7] | 10+ |
| CTR | 128 | [NoPadding|PKCS5|PKCS7] | 10+ |
| OFB | 128 | [NoPadding|PKCS5|PKCS7] | 10+ |
| CFB | 128 | [NoPadding|PKCS5|PKCS7] | 10+ |
| CFB128 | 128 | [NoPadding|PKCS5|PKCS7] | 10+ |
| GCM | 128 | [NoPadding|PKCS5|PKCS7] | 12+ |
填充模式
分组加密算法有固定的分组长度，在实际应用中，最后一组明文的数据量可能无法达到固定的长度要求，此时可以通过不同的填充模式进行数据填充。填充模式有：
-  NoPadding：不带填充。输入数据需要与分组长度匹配。
-  PKCS5：填充字符由一个字节序列组成，而且每个字节填充的值与要填充的字节序列长度相同。且PKCS5为8字节填充，即需将数据填充为八位字节的倍数。
-  PKCS7：填充方法和PKCS5一致。但PKCS7的可以在1-255字节之间任意填充，PKCS5固定为8字节。
对于CFB、OFB、CTR、GCM、CCM这类将分组密码转化为流模式实现的模式，不需要填充，因此无论是否指定填充模式，都会按照NoPadding实现。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-asym-encrypt-decrypt-spec-V14
爬取时间: 2025-04-28 01:40:32
来源: Huawei Developer
当前章节将说明系统目前支持的算法及其对应的规格。
对于每种算法采用支持的加密模式，将会在具体的每个算法规格中介绍。
RSA
RSA为非对称加密算法，加密长度需要在固定长度进行，在实际应用中，数据量可能无法达到固定的长度要求，此时可以通过不同的填充模式进行数据填充。
算法库目前提供了RSA加解密常用的三种模式有：
-  NoPadding：不带填充，输入的数据必须与RSA密钥字节长度一样长；输出数据长度与RSA密钥字节长度一样长。
-  PKCS1：即RFC3447规范中的RSAES-PKCS1-V1_5模式，对应OpenSSL中的RSA_PKCS1_PADDING。 在进行RSA运算时需要将源数据D转化为Encryption block（EB），加密时，输入的数据最大长度 <= RSA密钥字节长度 - 11；输出数据长度与RSA密钥字节长度一样长。
-  PKCS1_OAEP：即RFC3447规范中的RSAES-OAEP模式，对应OpenSSL中的RSA_PKCS1_OAEP_PADDING。 此模式需要设置两个摘要（md和mgf1_md），加密时，输入的数据必须小于RSA密钥字节长度 - 2 *md摘要字节长度- 2；输出数据长度与RSA密钥字节长度一样长。 此模式还可额外设置pSource字节流来定义OAEP填充的编码输入，并且可以获取PKCS1_OAEP的相关参数（如表所示）。
-  以RSA2048|SHA256举例说明输入数据长度与算法之间的关系。
| PKCS1_OAEP的相关参数 | 说明 |
| --- | --- |
| md | 摘要算法。 |
| mgf | 掩码生成算法，目前仅支持MGF1。 |
| mgf1_md | MGF1算法中使用的摘要算法。 |
| pSource | 字节流，用于编码输入。 |
| 填充模式 | 输入数据的最大字节长度 | 输出数据的最大字节长度 |
| --- | --- | --- |
| NoPadding | 256(RSA密钥字节长度) | 256 |
| PKCS1 | 245(RSA密钥字节长度 - 11) | 256 |
| PKCS1_OAEP | 190(RSA密钥字节长度 - 2 * md摘要字节长度 - 2) | 256 |
使用同步接口生成RSA2048、RSA3072、RSA4096、RSA8192非对称密钥或者明文长度超过2048会导致耗时增加。
由于系统对主线程有时间限制，耗时较长会导致失败，建议开发者在生成位数较大的密钥时，使用对应的异步接口，或是使用多线程并发能力进行开发。
填充模式为NoPadding
以字符串参数完成RSA加解密，具体的“字符串参数”由“非对称密钥类型”和“填充模式 NoPadding”使用符号“|”拼接而成，用于在创建非对称加解密实例时，指定算法规格。
| 非对称密钥类型 | 字符串参数 | API版本 |
| --- | --- | --- |
| RSA512 | RSA512|NoPadding | 9+ |
| RSA768 | RSA768|NoPadding | 9+ |
| RSA1024 | RSA1024|NoPadding | 9+ |
| RSA2048 | RSA2048|NoPadding | 9+ |
| RSA3072 | RSA3072|NoPadding | 9+ |
| RSA4096 | RSA4096|NoPadding | 9+ |
| RSA8192 | RSA8192|NoPadding | 9+ |
| RSA | RSA|NoPadding | 10+ |
如表中最后一行所示，为了兼容由密钥参数生成的密钥，RSA加解密参数输入密钥类型时支持不带长度，加解密运算取决于实际输入的密钥长度。
填充模式为PKCS1
以字符串参数完成RSA加解密，具体的“字符串参数”由“非对称密钥类型”和“填充模式 PKCS1”使用符号“|”拼接而成，用于在创建非对称加解密实例时，指定算法规格。
| 非对称密钥类型 | 字符串参数 | API版本 |
| --- | --- | --- |
| RSA512 | RSA512|PKCS1 | 9+ |
| RSA768 | RSA768|PKCS1 | 9+ |
| RSA1024 | RSA1024|PKCS1 | 9+ |
| RSA2048 | RSA2048|PKCS1 | 9+ |
| RSA3072 | RSA3072|PKCS1 | 9+ |
| RSA4096 | RSA4096|PKCS1 | 9+ |
| RSA8192 | RSA8192|PKCS1 | 9+ |
| RSA | RSA|PKCS1 | 10+ |
如表中最后一行所示，为了兼容由密钥参数生成的密钥，RSA加解密参数输入密钥类型时支持不带长度，加解密运算取决于实际输入的密钥长度。
填充模式为PKCS1_OAEP
以字符串参数完成RSA加解密，具体的“字符串参数”由“非对称密钥类型”、“填充模式 PKCS1_OAEP”、摘要、掩码摘要，使用符号“|”拼接而成，用于在创建非对称加解密实例时，指定算法规格。
如表所示，各取值范围（即[]中的内容）中，只能选取一项完成字符串拼接。
举例说明，当需要非对称密钥类型为RSA2048、填充模式为PKCS1_OAEP、摘要算法为SHA256、掩码摘要为MGF1_SHA256的RSA密钥，其字符串参数为"RSA2048|PKCS1_OAEP|SHA256|MGF1_SHA256"。
输入的数据必须小于RSA密钥字节长度 - md摘要长度 - mgf1_md摘要长度 - 2。比如，当RSA密钥为512位时，不支持SHA512。
| 非对称密钥类型 | 填充模式 | 摘要 | 掩码摘要 | API版本 |
| --- | --- | --- | --- | --- |
| RSA512 | PKCS1_OAEP | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256] | 9+ |
| RSA512 | PKCS1_OAEP | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256] | 9+ |
| RSA512 | PKCS1_OAEP | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256] | 9+ |
| RSA768 | PKCS1_OAEP | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA768 | PKCS1_OAEP | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA768 | PKCS1_OAEP | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA768 | PKCS1_OAEP | SHA256 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384] | 9+ |
| RSA1024 | PKCS1_OAEP | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA1024 | PKCS1_OAEP | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA1024 | PKCS1_OAEP | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA1024 | PKCS1_OAEP | SHA256 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA1024 | PKCS1_OAEP | SHA384 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA2048 | PKCS1_OAEP | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA2048 | PKCS1_OAEP | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA2048 | PKCS1_OAEP | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA2048 | PKCS1_OAEP | SHA256 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA2048 | PKCS1_OAEP | SHA384 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA2048 | PKCS1_OAEP | SHA512 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA3072 | PKCS1_OAEP | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA3072 | PKCS1_OAEP | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA3072 | PKCS1_OAEP | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA3072 | PKCS1_OAEP | SHA256 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA3072 | PKCS1_OAEP | SHA384 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA3072 | PKCS1_OAEP | SHA512 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA4096 | PKCS1_OAEP | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA4096 | PKCS1_OAEP | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA4096 | PKCS1_OAEP | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA4096 | PKCS1_OAEP | SHA256 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA4096 | PKCS1_OAEP | SHA384 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA4096 | PKCS1_OAEP | SHA512 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA8192 | PKCS1_OAEP | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA8192 | PKCS1_OAEP | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA8192 | PKCS1_OAEP | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA8192 | PKCS1_OAEP | SHA256 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA8192 | PKCS1_OAEP | SHA384 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA8192 | PKCS1_OAEP | SHA512 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA | PKCS1_OAEP | 符合长度要求的摘要算法 | MGF1_符合长度要求的摘要算法 | 10+ |
如表中最后一行所示，为了兼容由密钥参数生成的密钥，RSA加解密参数输入密钥类型时支持不带长度，加解密运算取决于实际输入的密钥长度。
获取/设置OAEP填充模式的参数
从API版本10开始支持RSA使用PKCS1_OAEP填充模式时，获取、设置相关参数，“√”表示支持对获取或设置该参数。
| OAEP参数 | 枚举值 | 获取 | 设置 |
| --- | --- | --- | --- |
| md | OAEP_MD_NAME_STR | √ | - |
| mgf | OAEP_MGF_NAME_STR | √ | - |
| mgf1_md | OAEP_MGF1_MD_STR | √ | - |
| pSource | OAEP_MGF1_PSRC_UINT8ARR | √ | √ |
SM2
SM2为非对称加密算法，加密长度需要在固定长度进行。算法库目前支持以GM/T 0009-2012定义的格式加密或解密数据。
SM2非对称加密的结果由C1,C2,C3三部分组成。其中C1是根据生成的随机数计算出的椭圆曲线点，C2是密文数据，C3是通过指定摘要算法计算的值。
当前支持以字符串参数完成SM2加解密，具体的“字符串参数”由“非对称密钥类型（加解密算法+密钥长度）”、“摘要算法”使用符号“|”拼接而成，用于在创建对称加解密实例时，指定算法规格。
如表所示，各取值范围（即[]中的内容）中，只能选取一项完成字符串拼接。SM2算法和密钥长度中间采用符号“_”拼接。
举例说明，当密钥长度为256bit、摘要算法为MD5的SM2密钥，其字符串参数为"SM2_256|MD5"。
| 非对称密钥类型 | 摘要算法 | API版本 |
| --- | --- | --- |
| SM2_256 | [MD5|SHA1|SHA224|SHA256|SHA384|SHA512|SM3] | 10+ |
| SM2 | [MD5|SHA1|SHA224|SHA256|SHA384|SHA512|SM3] | 10+ |
如表中最后一行所示，为了兼容由密钥参数生成的密钥，SM2加解密参数输入密钥类型时支持不带长度，加解密运算取决于实际输入的密钥长度。
获取SM2摘要算法参数
从API版本11开始支持SM2获取摘要算法参数，“√”表示支持对获取或设置该参数。
| SM2加解密参数 | 枚举值 | 获取 | 设置 |
| --- | --- | --- | --- |
| md | SM2_MD_NAME_STR | √ | - |
转换SM2密文格式
从API版本12开始，支持SM2格式转换。当前支持的SM2密文格式为国密标准的ASN.1格式，其中各参数组合顺序为C1C3C2。
开发者可指定SM2密文的参数，将其转换成符合国密标准的ASN.1格式密文。反之，也可以从国密标准的ASN.1格式密文中提取具体的SM2密文参数，便于开发者自行组合成其他格式的SM2密文。
SM2密文参数，包括：
-  xCoordinate：x分量，即C1_X。
-  yCoordinate：y分量，即C1_Y。xCoordinate和yCoordinate可以转换成C1。
-  cipherTextData：密文，即C2。
-  hashData：杂凑值，即C3。
当前支持以字符串参数指定SM2密文格式转换的模式，如下表所示：
| SM2密文格式转换模式 | 基于参数生成SM2密文 | 从SM2密文中获取参数 |
| --- | --- | --- |
| C1C3C2 | √ | √ |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-encrypt-decrypt-by-segment-V14
爬取时间: 2025-04-28 01:40:45
来源: Huawei Developer
在加解密的过程中，算法库没有对单次或累计的传入数据量设置大小限制，但在传入的数据量较大时（如数据量大于2M），建议开发者将数据分段，完成分段加解密，提高效率。
对称加解密
对称密钥的分段加解密，通过调用Cipher.update实现。
开发者可自定义单次传入的数据量（示例中的updateLength），多次调用update传入数据。
当前单次支持传入的最大长度为INT_MAX（Uint8Array类型的最大长度）。
开发者应当对每次update和doFinal的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文/明文。
开发示例：使用AES对称密钥（GCM模式）分段加解密
开发示例：使用SM4对称密钥（GCM模式）分段加解密
非对称加解密
非对称加解密，不支持update操作，仅需要调用Cipher.init和Cipher.doFinal完成加解密。
非对称密钥的分段加密是指当明文大于单次加密支持的数据长度时（具体长度请查非对称密钥加解密算法规格），需要将待加密数据分为合适长度的数据段，并对每个数据段执行加密操作，即创建Cipher，然后调用Cipher.init和Cipher.doFinal接口。
严格意义上说，是数据的拆分加解密，此时单次传入的数据量长度与密钥规格的长度相关。
开发者应当对每次doFinal的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文/明文。
开发示例：使用RSA非对称密钥分段加解密
常见问题
-  分段加解密中，每次更新的数据量，与加密模式是否有关？ 每次更新的数据量，由开发者自定义，与加密模式无关。 不同的加密模式，仅对加解密参数产生影响，不同的加密模式使用的加解密参数不同，具体请参考ParamsSpec。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-encrypt-decrypt-dev-V14
爬取时间: 2025-04-28 01:40:59
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-aes-sym-encrypt-decrypt-gcm-V14
爬取时间: 2025-04-28 01:41:13
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：AES。
加密
1.  调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.generateSymKey，生成密钥算法为AES、密钥长度为128位的对称密钥（SymKey）。 如何生成AES对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：AES和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'AES128|GCM|PKCS7'，创建对称密钥类型为AES128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成加密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（SymKey）和GCM模式对应的加密参数（GcmParamsSpec），初始化加密Cipher实例。
4.  调用Cipher.update，更新数据（明文）。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
5.  调用Cipher.doFinal，获取加密后的数据。
6.  读取GcmParamsSpec.authTag作为解密的认证信息。 在GCM模式下，算法库当前只支持16字节的authTag，作为解密时初始化的认证信息。示例中authTag恰好为16字节。
解密
1.  调用cryptoFramework.createCipher，指定字符串参数'AES128|GCM|PKCS7'，创建对称密钥类型为AES128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（SymKey）和GCM模式对应的解密参数（GcmParamsSpec），初始化解密Cipher实例。
3.  调用Cipher.update，更新数据（密文）。
4.  调用Cipher.doFinal，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function generateRandom(len: number) {
let rand = cryptoFramework.createRandom();
let generateRandSync = rand.generateRandomSync(len);
return generateRandSync;
}
function genGcmParamsSpec() {
let ivBlob = generateRandom(12);
let arr = [1, 2, 3, 4, 5, 6, 7, 8]; // 8 bytes
let dataAad = new Uint8Array(arr); //将arr数组转换为Uint8Array类型
let aadBlob: cryptoFramework.DataBlob = { data: dataAad }; //创建DataBlob对象
arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 16 bytes
let dataTag = new Uint8Array(arr); //将arr数组转换为Uint8Array类型
let tagBlob: cryptoFramework.DataBlob = {
data: dataTag
};
// GCM的authTag在加密时从doFinal结果中获取，在解密时填入init函数的params参数中
let gcmParamsSpec: cryptoFramework.GcmParamsSpec = {
iv: ivBlob,
aad: aadBlob,
authTag: tagBlob,
algName: "GcmParamsSpec"
};
return gcmParamsSpec;
}
let gcmParams = genGcmParamsSpec();
// 加密消息
async function encryptMessagePromise(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('AES128|GCM|PKCS7');
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, gcmParams);
let encryptUpdate = await cipher.update(plainText);
// gcm模式加密doFinal时传入空，获得tag数据，并更新至gcmParams对象中。
gcmParams.authTag = await cipher.doFinal(null);
return encryptUpdate;
}
// 解密消息
async function decryptMessagePromise(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('AES128|GCM|PKCS7');
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, gcmParams);
let decryptUpdate = await decoder.update(cipherText);
// gcm模式解密doFinal时传入空，验证init时传入的tag数据，如果验证失败会抛出异常。
let decryptData = await decoder.doFinal(null);
if (decryptData === null) {
console.info('GCM decrypt success, decryptData is null');
}
return decryptUpdate;
}
async function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('AES128');
let symKey = await aesGenerator.convertKey(symKeyBlob);
console.info('convertKey success');
return symKey;
}
async function main() {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]); //创建Uint8Array对象
let symKey = await genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) }; //创建DataBlob对象
let encryptText = await encryptMessagePromise(symKey, plainText);
let decryptText = await decryptMessagePromise(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function generateRandom(len: number) {
let rand = cryptoFramework.createRandom();
let generateRandSync = rand.generateRandomSync(len);
return generateRandSync;
}
function genGcmParamsSpec() {
let ivBlob = generateRandom(12);
let arr = [1, 2, 3, 4, 5, 6, 7, 8]; // 8 bytes
let dataAad = new Uint8Array(arr); //将arr数组转换为Uint8Array类型
let aadBlob: cryptoFramework.DataBlob = { data: dataAad }; //创建DataBlob对象
arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 16 bytes
let dataTag = new Uint8Array(arr); //将arr数组转换为Uint8Array类型
let tagBlob: cryptoFramework.DataBlob = {
data: dataTag
};
// GCM的authTag在加密时从doFinal结果中获取，在解密时填入init函数的params参数中
let gcmParamsSpec: cryptoFramework.GcmParamsSpec = {
iv: ivBlob,
aad: aadBlob,
authTag: tagBlob,
algName: "GcmParamsSpec"
};
return gcmParamsSpec;
}
let gcmParams = genGcmParamsSpec();
// 加密消息
function encryptMessage(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('AES128|GCM|PKCS7');
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, gcmParams);
let encryptUpdate = cipher.updateSync(plainText);
// gcm模式加密doFinal时传入空，获得tag数据，并更新至gcmParams对象中。
gcmParams.authTag = cipher.doFinalSync(null);
return encryptUpdate;
}
// 解密消息
function decryptMessage(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('AES128|GCM|PKCS7');
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, gcmParams);
let decryptUpdate = decoder.updateSync(cipherText);
// gcm模式解密doFinal时传入空，验证init时传入的tag数据，如果验证失败会抛出异常。
let decryptData = decoder.doFinalSync(null);
if (decryptData === null) {
console.info('GCM decrypt success, decryptData is null');
}
return decryptUpdate;
}
function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('AES128');
let symKey = aesGenerator.convertKeySync(symKeyBlob);
console.info('convertKeySync success');
return symKey;
}
function main() {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]); //创建Uint8Array对象
let symKey = genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) }; //创建DataBlob对象
let encryptText = encryptMessage(symKey, plainText);
let decryptText = decryptMessage(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-aes-sym-encrypt-decrypt-gcm-ndk-V14
爬取时间: 2025-04-28 01:41:26
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：AES。
在CMake脚本中链接相关动态库
开发步骤
创建对象
调用OH_CryptoSymKeyGenerator_Create、OH_CryptoSymKeyGenerator_Generate，生成密钥算法为AES、密钥长度为128位的对称密钥（OH_CryptoSymKey）。
如何生成AES对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：AES和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
加密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'AES128|GCM|PKCS7'，创建对称密钥类型为AES128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成加密操作。
2.  调用OH_CryptoSymCipherParams_Create创建参数对象，调用OH_CryptoSymCipherParams_SetParam设置对应的加密参数。
3.  调用OH_CryptoSymCipher_Init，设置模式为加密（CRYPTO_ENCRYPT_MODE），指定加密密钥（OH_CryptoSymKey）和GCM模式对应的加密参数（OH_CryptoSymCipherParams），初始化加密Cipher实例。
4.  调用OH_CryptoSymCipher_Update，更新数据（明文）。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
5.  调用OH_CryptoSymCipher_Final，获取加密后的数据。 在GCM模式下，final会返回authTag，作为解密时初始化的认证信息，需要保存。 在GCM模式下，算法库当前只支持16字节的authTag，作为解密时初始化的认证信息。示例中authTag恰好为16字节。
6.  在GCM模式下，final会返回authTag，作为解密时初始化的认证信息，需要保存。 在GCM模式下，算法库当前只支持16字节的authTag，作为解密时初始化的认证信息。示例中authTag恰好为16字节。
-  在GCM模式下，final会返回authTag，作为解密时初始化的认证信息，需要保存。 在GCM模式下，算法库当前只支持16字节的authTag，作为解密时初始化的认证信息。示例中authTag恰好为16字节。
解密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'AES128|GCM|PKCS7'，创建对称密钥类型为AES128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  使用OH_CryptoSymCipherParams_SetParam设置authTag，作为解密的认证信息。
3.  调用OH_CryptoSymCipher_Init，设置模式为解密（CRYPTO_DECRYPT_MODE），指定解密密钥（OH_CryptoSymKey）和GCM模式对应的解密参数（OH_CryptoSymCipherParams），初始化解密Cipher实例。
4.  调用OH_CryptoSymCipher_Update，更新数据（密文）。
5.  调用OH_CryptoSymCipher_Final，获取解密后的数据。
销毁对象
调用OH_CryptoSymKeyGenerator_Destroy、OH_CryptoSymCipher_Destroy、OH_CryptoSymCipherParams_Destroy销毁各对象。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-aes-sym-encrypt-decrypt-ccm-V14
爬取时间: 2025-04-28 01:41:40
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：AES。
加密
1.  调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.generateSymKey，生成密钥算法为AES、密钥长度为128位的对称密钥（SymKey）。 如何生成AES对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：AES和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'AES128|CCM'，创建对称密钥类型为AES128、分组模式为CCM的Cipher实例，用于完成加密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（SymKey）和CCM模式对应的加密参数（CcmParamsSpec），初始化加密Cipher实例。
4.  调用Cipher.update，更新数据（明文）。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。 CCM模式不支持分段加解密。
5.  调用Cipher.doFinal，获取加密后的数据。
6.  读取CcmParamsSpec.authTag作为解密的认证信息。 在CCM模式下，算法库当前只支持12字节的authTag，作为解密时初始化的认证信息。示例中authTag恰好为12字节。
解密
1.  调用cryptoFramework.createCipher，指定字符串参数'AES128|CCM'，创建对称密钥类型为AES128、分组模式为CCM的Cipher实例，用于完成解密操作。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（SymKey）和CCM模式对应的解密参数（CcmParamsSpec），初始化解密Cipher实例。
3.  调用Cipher.doFinal，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function genCcmParamsSpec() {
let rand: cryptoFramework.Random = cryptoFramework.createRandom();
let ivBlob: cryptoFramework.DataBlob = rand.generateRandomSync(7);
let aadBlob: cryptoFramework.DataBlob = rand.generateRandomSync(8);
let arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 12 bytes
let dataTag = new Uint8Array(arr);
let tagBlob: cryptoFramework.DataBlob = {
data: dataTag
};
// CCM的authTag在加密时从doFinal结果中获取，在解密时填入init函数的params参数中
let ccmParamsSpec: cryptoFramework.CcmParamsSpec = {
iv: ivBlob,
aad: aadBlob,
authTag: tagBlob,
algName: "CcmParamsSpec"
};
return ccmParamsSpec;
}
let ccmParams = genCcmParamsSpec();
// 加密消息
async function encryptMessagePromise(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('AES128|CCM');
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, ccmParams);
let encryptUpdate = await cipher.update(plainText);
// ccm模式加密doFinal时传入空，获得tag数据，并更新至ccmParams对象中。
ccmParams.authTag = await cipher.doFinal(null);
return encryptUpdate;
}
// 解密消息
async function decryptMessagePromise(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('AES128|CCM');
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, ccmParams);
let decryptUpdate = await decoder.doFinal(cipherText);
return decryptUpdate;
}
async function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('AES128');
let symKey = await aesGenerator.convertKey(symKeyBlob);
console.info('convertKey success');
return symKey;
}
async function main() {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]);
let symKey = await genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = await encryptMessagePromise(symKey, plainText);
let decryptText = await decryptMessagePromise(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function genCcmParamsSpec() {
let rand: cryptoFramework.Random = cryptoFramework.createRandom();
let ivBlob: cryptoFramework.DataBlob = rand.generateRandomSync(7);
let aadBlob: cryptoFramework.DataBlob = rand.generateRandomSync(8);
let arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 12 bytes
let dataTag = new Uint8Array(arr);
let tagBlob: cryptoFramework.DataBlob = {
data: dataTag
};
// CCM的authTag在加密时从doFinal结果中获取，在解密时填入init函数的params参数中
let ccmParamsSpec: cryptoFramework.CcmParamsSpec = {
iv: ivBlob,
aad: aadBlob,
authTag: tagBlob,
algName: "CcmParamsSpec"
};
return ccmParamsSpec;
}
let ccmParams = genCcmParamsSpec();
// 加密消息
function encryptMessage(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('AES128|CCM');
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, ccmParams);
let encryptUpdate = cipher.updateSync(plainText);
// ccm模式加密doFinal时传入空，获得tag数据，并更新至ccmParams对象中。
ccmParams.authTag = cipher.doFinalSync(null);
return encryptUpdate;
}
// 解密消息
function decryptMessage(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('AES128|CCM');
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, ccmParams);
let decryptUpdate = decoder.doFinalSync(cipherText);
return decryptUpdate;
}
function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('AES128');
let symKey = aesGenerator.convertKeySync(symKeyBlob);
console.info('convertKeySync success');
return symKey;
}
function main() {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]);
let symKey = genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = encryptMessage(symKey, plainText);
let decryptText = decryptMessage(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-aes-sym-encrypt-decrypt-ccm-ndk-V14
爬取时间: 2025-04-28 01:41:54
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：AES。
在CMake脚本中链接相关动态库
开发步骤
创建对象
调用OH_CryptoSymKeyGenerator_Create、OH_CryptoSymKeyGenerator_Generate，生成密钥算法为AES、密钥长度为128位的对称密钥（OH_CryptoSymKey）。
如何生成AES对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：AES和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
加密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'AES128|CCM'，创建对称密钥类型为AES128、分组模式为CCM的Cipher实例，用于完成加密操作。
2.  调用OH_CryptoSymCipherParams_Create创建参数对象，调用OH_CryptoSymCipherParams_SetParam设置对应的加密参数。
3.  调用OH_CryptoSymCipher_Init，设置模式为加密（CRYPTO_ENCRYPT_MODE），指定加密密钥（OH_CryptoSymKey）和CCM模式对应的加密参数（OH_CryptoSymCipherParams），初始化加密Cipher实例。
4.  调用OH_CryptoSymCipher_Update，更新数据（明文）。 当前单次update长度没有限制，开发者可以根据明文长度判断单次调用update输入的数据长度。 CCM模式不支持分段加解密。
5.  调用OH_CryptoSymCipher_Final，获取加密后的数据。 在CCM模式下，final会设置authTag，作为解密时初始化的认证信息，需要保存。
6.  在CCM模式下，final会设置authTag，作为解密时初始化的认证信息，需要保存。
7.  使用OH_CryptoSymCipherParams_Create创建Params，使用OH_CryptoSymCipherParams_SetParam设置authTag，作为解密的认证信息。 在CCM模式下，算法库当前只支持12字节的authTag，作为解密时初始化的认证信息。示例中authTag恰好为12字节。
-  在CCM模式下，final会设置authTag，作为解密时初始化的认证信息，需要保存。
解密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'AES128|CCM'，创建对称密钥类型为AES128、分组模式为CCM的Cipher实例，用于完成解密操作。
2.  解密需要使用OH_CryptoSymCipherParams_SetParam设置authTag，作为解密时初始化的认证信息。
3.  调用OH_CryptoSymCipher_Init，设置模式为解密（CRYPTO_DECRYPT_MODE），指定解密密钥（OH_CryptoSymKey）和CCM模式对应的解密参数（OH_CryptoSymCipherParams），初始化解密Cipher实例。
4.  调用OH_CryptoSymCipher_Update，更新数据（密文）。 当前单次update长度没有限制，开发者可以根据明文长度判断单次调用update输入的数据长度。 CCM模式不支持分段加解密。
5.  调用OH_CryptoSymCipher_Final，获取解密后的数据。
销毁对象
调用OH_CryptoSymKeyGenerator_Destroy、OH_CryptoSymCipher_Destroy、OH_CryptoSymKey_Destroy、OH_Crypto_FreeDataBlob释放申请的内存，销毁对称密钥、Cipher实例和Params。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-aes-sym-encrypt-decrypt-cbc-V14
爬取时间: 2025-04-28 01:42:08
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：AES。
加密
1.  调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.generateSymKey，生成密钥算法为AES、密钥长度为128位的对称密钥（SymKey）。 如何生成AES对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：AES和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'AES128|CBC|PKCS7'，创建对称密钥类型为AES128、分组模式为CBC、填充模式为PKCS7的Cipher实例，用于完成加密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（SymKey）和CBC模式对应的加密参数（IvParamsSpec），初始化加密Cipher实例。
4.  加密内容较短时，可以不调用update，直接调用Cipher.doFinal，获取加密后的数据。
解密
1.  调用cryptoFramework.createCipher，指定字符串参数'AES128|CBC|PKCS7'，创建对称密钥类型为AES128、分组模式为CBC、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（SymKey）和CBC模式对应的解密参数（IvParamsSpec），初始化解密Cipher实例。
3.  解密内容较短时，可以不调用update，直接调用Cipher.doFinal，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function generateRandom(len: number) {
let rand = cryptoFramework.createRandom();
let generateRandSync = rand.generateRandomSync(len);
return generateRandSync;
}
function genIvParamsSpec() {
let ivBlob = generateRandom(16);
let ivParamsSpec: cryptoFramework.IvParamsSpec = {
algName: "IvParamsSpec",
iv: ivBlob
};
return ivParamsSpec;
}
let iv = genIvParamsSpec();
// 加密消息
async function encryptMessagePromise(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('AES128|CBC|PKCS7');
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, iv);
let cipherData = await cipher.doFinal(plainText);
return cipherData;
}
// 解密消息
async function decryptMessagePromise(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('AES128|CBC|PKCS7');
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, iv);
let decryptData = await decoder.doFinal(cipherText);
return decryptData;
}
async function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('AES128');
let symKey = await aesGenerator.convertKey(symKeyBlob);
console.info('convertKey success');
return symKey;
}
async function aesCBC() {
try {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]);
let symKey = await genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = await encryptMessagePromise(symKey, plainText);
let decryptText = await decryptMessagePromise(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
} catch (error) {
console.error(`AES CBC “${error}“, error code: ${error.code}`);
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function generateRandom(len: number) {
let rand = cryptoFramework.createRandom();
let generateRandSync = rand.generateRandomSync(len);
return generateRandSync;
}
function genIvParamsSpec() {
let ivBlob = generateRandom(16);
let ivParamsSpec: cryptoFramework.IvParamsSpec = {
algName: "IvParamsSpec",
iv: ivBlob
};
return ivParamsSpec;
}
let iv = genIvParamsSpec();
// 加密消息
function encryptMessage(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('AES128|CBC|PKCS7');
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, iv);
let cipherData = cipher.doFinalSync(plainText);
return cipherData;
}
// 解密消息
function decryptMessage(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('AES128|CBC|PKCS7');
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, iv);
let decryptData = decoder.doFinalSync(cipherText);
return decryptData;
}
function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('AES128');
let symKey = aesGenerator.convertKeySync(symKeyBlob);
console.info('convertKeySync success');
return symKey;
}
function main() {
try {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]);
let symKey = genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = encryptMessage(symKey, plainText);
let decryptText = decryptMessage(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
} catch (error) {
console.error(`AES CBC “${error}“, error code: ${error.code}`);
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-aes-sym-encrypt-decrypt-cbc-ndk-V14
爬取时间: 2025-04-28 01:42:21
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：AES。
在CMake脚本中链接相关动态库
开发步骤
创建对象
调用OH_CryptoSymKeyGenerator_Create、OH_CryptoSymKeyGenerator_Generate，生成密钥算法为AES、密钥长度为128位的对称密钥（OH_CryptoSymKey）。
如何生成AES对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：AES和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
加密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'AES128|CBC|PKCS7'，创建对称密钥类型为AES128、分组模式为CBC、填充模式为PKCS7的Cipher实例，用于完成加密操作。
2.  调用OH_CryptoSymCipherParams_Create创建参数对象，调用OH_CryptoSymCipherParams_SetParam设置对应的加密参数。
3.  调用OH_CryptoSymCipher_Init，设置模式为加密（CRYPTO_ENCRYPT_MODE），指定加密密钥（OH_CryptoSymKey）和CBC模式对应的加密参数（OH_CryptoSymCipherParams），初始化加密Cipher实例。
4.  加密内容较短时，可以不调用OH_CryptoSymCipher_Update，直接调用OH_CryptoSymCipher_Final，获取加密后的数据。
解密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'AES128|CBC|PKCS7'，创建对称密钥类型为AES128、分组模式为CBC、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用OH_CryptoSymCipher_Init，设置模式为解密（CRYPTO_DECRYPT_MODE），指定解密密钥（OH_CryptoSymKey）和CBC模式对应的解密参数（OH_CryptoSymCipherParams），初始化解密Cipher实例。
3.  解密内容较短时，可以不调用OH_CryptoSymCipher_Update，直接调用OH_CryptoSymCipher_Final，获取解密后的数据。
销毁对象
调用OH_CryptoSymKeyGenerator_Destroy、OH_CryptoSymCipher_Destroy、OH_CryptoSymKey_Destroy、OH_Crypto_FreeDataBlob释放申请的内存，销毁对象。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-aes-sym-encrypt-decrypt-ecb-V14
爬取时间: 2025-04-28 01:42:35
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：AES。
加密
1.  调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.generateSymKey，生成密钥算法为AES、密钥长度为128位的对称密钥（SymKey）。 如何生成AES对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：AES和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'AES128|ECB|PKCS7'，创建对称密钥类型为AES128、分组模式为ECB、填充模式为PKCS7的Cipher实例，用于完成加密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（SymKey），ECB模式Params为空，初始化加密Cipher实例。
4.  加密内容较短时，可以不调用update，直接调用Cipher.doFinal，获取加密后的数据。
解密
1.  调用cryptoFramework.createCipher，指定字符串参数'AES128|ECB|PKCS7'，创建对称密钥类型为AES128、分组模式为ECB、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（SymKey），ECB模式Params为空，初始化解密Cipher实例。
3.  解密内容较短时，可以不调用update，直接调用Cipher.doFinal，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 加密消息
async function encryptMessagePromise(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('AES128|ECB|PKCS7');
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, null); // ECB模式params为null。
let cipherData = await cipher.doFinal(plainText);
return cipherData;
}
// 解密消息
async function decryptMessagePromise(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('AES128|ECB|PKCS7');
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, null); // ECB模式params为null。
let decryptData = await decoder.doFinal(cipherText);
return decryptData;
}
async function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('AES128');
let symKey = await aesGenerator.convertKey(symKeyBlob);
console.info('convertKey success');
return symKey;
}
async function aesECB() {
try {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]);
let symKey = await genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = await encryptMessagePromise(symKey, plainText);
let decryptText = await decryptMessagePromise(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
} catch (error) {
console.error(`AES ECB “${error}“, error code: ${error.code}`);
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 加密消息
function encryptMessage(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('AES128|ECB|PKCS7');
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, null); // ECB模式params为null。
let cipherData = cipher.doFinalSync(plainText);
return cipherData;
}
// 解密消息
function decryptMessage(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('AES128|ECB|PKCS7');
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, null); // ECB模式params为null。
let decryptData = decoder.doFinalSync(cipherText);
return decryptData;
}
function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('AES128');
let symKey = aesGenerator.convertKeySync(symKeyBlob);
console.info('convertKeySync success');
return symKey;
}
function main() {
try {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]);
let symKey = genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = encryptMessage(symKey, plainText);
let decryptText = decryptMessage(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
} catch (error) {
console.error(`AES ECB “${error}“, error code: ${error.code}`);
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-aes-sym-encrypt-decrypt-ecb-ndk-V14
爬取时间: 2025-04-28 01:42:49
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：AES。
在CMake脚本中链接相关动态库
开发步骤
创建对象
调用OH_CryptoSymKeyGenerator_Create、OH_CryptoSymKeyGenerator_Generate，生成密钥算法为AES、密钥长度为128位的对称密钥（OH_CryptoSymKey）。
如何生成AES对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：AES和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
加密
1.调用OH_CryptoSymCipher_Create，指定字符串参数'AES128|ECB|PKCS7'，创建对称密钥类型为AES128、分组模式为ECB、填充模式为PKCS7的Cipher实例，用于完成加解密操作。
1.  调用OH_CryptoSymCipher_Init，设置模式为加密（CRYPTO_ENCRYPT_MODE），指定加密密钥（OH_CryptoSymKey），初始化加密Cipher实例。
2.  加密内容较短时，可以不调用OH_CryptoSymCipher_Update，直接调用OH_CryptoSymCipher_Final，获取加密后的数据。
解密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'AES128|ECB|PKCS7'，创建对称密钥类型为AES128、分组模式为ECB、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用OH_CryptoSymCipher_Init，设置模式为解密（CRYPTO_DECRYPT_MODE），指定解密密钥（OH_CryptoSymKey）,初始化解密Cipher实例。
3.  解密内容较短时，可以不调用OH_CryptoSymCipher_Update，直接调用OH_CryptoSymCipher_Final，获取解密后的数据。
销毁对象
调用OH_CryptoSymKeyGenerator_Destroy、OH_CryptoSymCipher_Destroy销毁各对象。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-aes-sym-encrypt-decrypt-gcm-by-segment-V14
爬取时间: 2025-04-28 01:43:02
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：AES。
加密
1.  调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.generateSymKey，生成密钥算法为AES、密钥长度为128位的对称密钥（SymKey）。 如何生成AES对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：AES和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'AES128|GCM|PKCS7'，创建对称密钥类型为AES128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成加密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（SymKey）和GCM模式对应的加密参数（GcmParamsSpec），初始化加密Cipher实例。
4.  将一次传入数据量设置为20字节，多次调用Cipher.update，更新数据（明文）。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。 建议开发者对每次update的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文。因为在不同的规格下，update的结果可能会受到不同影响。 1）比如ECB和CBC模式，始终以分组作为基本单位来加密，并输出本次update产生的加密分组结果。即当本次update操作凑满一个分组就输出密文，没有凑满则此次update输出null，将未加密的数据与下次输入的数据拼接凑分组再输出。等到最后doFinal的时候，将未加密的数据，根据指定的填充模式进行填充，在输出剩余加密结果。解密过程中的update同理。 2）对于流加密模式（比如CTR和OFB模式），通常密文长度和明文长度相等。
5.  当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
6.  建议开发者对每次update的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文。因为在不同的规格下，update的结果可能会受到不同影响。 1）比如ECB和CBC模式，始终以分组作为基本单位来加密，并输出本次update产生的加密分组结果。即当本次update操作凑满一个分组就输出密文，没有凑满则此次update输出null，将未加密的数据与下次输入的数据拼接凑分组再输出。等到最后doFinal的时候，将未加密的数据，根据指定的填充模式进行填充，在输出剩余加密结果。解密过程中的update同理。 2）对于流加密模式（比如CTR和OFB模式），通常密文长度和明文长度相等。
7.  调用Cipher.doFinal，获取加密后的数据。
8.  读取GcmParamsSpec.authTag作为解密的认证信息。 在GCM模式下，算法库当前只支持16字节的authTag，作为解密时初始化的认证信息。示例中authTag恰好为16字节。
-  当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
-  建议开发者对每次update的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文。因为在不同的规格下，update的结果可能会受到不同影响。 1）比如ECB和CBC模式，始终以分组作为基本单位来加密，并输出本次update产生的加密分组结果。即当本次update操作凑满一个分组就输出密文，没有凑满则此次update输出null，将未加密的数据与下次输入的数据拼接凑分组再输出。等到最后doFinal的时候，将未加密的数据，根据指定的填充模式进行填充，在输出剩余加密结果。解密过程中的update同理。 2）对于流加密模式（比如CTR和OFB模式），通常密文长度和明文长度相等。
解密
1.  调用cryptoFramework.createCipher，指定字符串参数'AES128|GCM|PKCS7'，创建对称密钥类型为AES128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（SymKey）和GCM模式对应的解密参数（GcmParamsSpec），初始化解密Cipher实例。
3.  将一次传入数据量设置为20字节，多次调用Cipher.update，更新数据（密文）。
4.  调用Cipher.doFinal，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function generateRandom(len: number) {
let rand = cryptoFramework.createRandom();
let generateRandSync = rand.generateRandomSync(len);
return generateRandSync;
}
function genGcmParamsSpec() {
let ivBlob = generateRandom(12);
let arr = [1, 2, 3, 4, 5, 6, 7, 8]; // 8 bytes
let dataAad = new Uint8Array(arr);
let aadBlob: cryptoFramework.DataBlob = { data: dataAad };
arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 16 bytes
let dataTag = new Uint8Array(arr);
let tagBlob: cryptoFramework.DataBlob = {
data: dataTag
}; // The GCM authTag is obtained by doFinal() in encryption and passed in params of init() in decryption.
let gcmParamsSpec: cryptoFramework.GcmParamsSpec = {
iv: ivBlob,
aad: aadBlob,
authTag: tagBlob,
algName: "GcmParamsSpec"
};
return gcmParamsSpec;
}
let gcmParams = genGcmParamsSpec();
// 分段加密消息
async function encryptMessageUpdateBySegment(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('AES128|GCM|PKCS7');
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, gcmParams);
let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求
let cipherText = new Uint8Array();
for (let i = 0; i < plainText.data.length; i += updateLength) {
let updateMessage = plainText.data.subarray(i, i + updateLength);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 分段update
let updateOutput = await cipher.update(updateMessageBlob);
// 把update的结果拼接起来，得到密文（有些情况下还需拼接doFinal的结果，这取决于分组模式
// 和填充模式，本例中GCM模式的doFinal结果只包含authTag而不含密文，所以不需要拼接）
let mergeText = new Uint8Array(cipherText.length + updateOutput.data.length);
mergeText.set(cipherText);
mergeText.set(updateOutput.data, cipherText.length);
cipherText = mergeText;
}
gcmParams.authTag = await cipher.doFinal(null);
let cipherBlob: cryptoFramework.DataBlob = { data: cipherText };
return cipherBlob;
}
// 分段解密消息
async function decryptMessagePromise(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('AES128|GCM|PKCS7');
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, gcmParams);
let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求
let decryptText = new Uint8Array();
for (let i = 0; i < cipherText.data.length; i += updateLength) {
let updateMessage = cipherText.data.subarray(i, i + updateLength);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 分段update
let updateOutput = await decoder.update(updateMessageBlob);
// 把update的结果拼接起来，得到明文
let mergeText = new Uint8Array(decryptText.length + updateOutput.data.length);
mergeText.set(decryptText);
mergeText.set(updateOutput.data, decryptText.length);
decryptText = mergeText;
}
let decryptData = await decoder.doFinal(null);
if (decryptData === null) {
console.info('GCM decrypt success, decryptData is null');
}
let decryptBlob: cryptoFramework.DataBlob = { data: decryptText };
return decryptBlob;
}
async function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('AES128');
let symKey = await aesGenerator.convertKey(symKeyBlob);
console.info('convertKey success');
return symKey;
}
async function aes() {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]);
let symKey = await genSymKeyByData(keyData);
let message = "aaaaa.....bbbbb.....ccccc.....ddddd.....eee"; // 假设信息总共43字节，根据utf-8解码后，也是43字节
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = await encryptMessageUpdateBySegment(symKey, plainText);
let decryptText = await decryptMessagePromise(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function generateRandom(len: number) {
let rand = cryptoFramework.createRandom();
let generateRandSync = rand.generateRandomSync(len);
return generateRandSync;
}
function genGcmParamsSpec() {
let ivBlob = generateRandom(12);
let arr = [1, 2, 3, 4, 5, 6, 7, 8]; // 8 bytes
let dataAad = new Uint8Array(arr);
let aadBlob: cryptoFramework.DataBlob = { data: dataAad };
arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 16 bytes
let dataTag = new Uint8Array(arr);
let tagBlob: cryptoFramework.DataBlob = {
data: dataTag
}; // The GCM authTag is obtained by doFinal() in encryption and passed in params of init() in decryption.
let gcmParamsSpec: cryptoFramework.GcmParamsSpec = {
iv: ivBlob,
aad: aadBlob,
authTag: tagBlob,
algName: "GcmParamsSpec"
};
return gcmParamsSpec;
}
let gcmParams = genGcmParamsSpec();
// 分段加密消息
function encryptMessageUpdateBySegment(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('AES128|GCM|PKCS7');
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, gcmParams);
let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求
let cipherText = new Uint8Array();
for (let i = 0; i < plainText.data.length; i += updateLength) {
let updateMessage = plainText.data.subarray(i, i + updateLength);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 分段update
let updateOutput = cipher.updateSync(updateMessageBlob);
// 把update的结果拼接起来，得到密文（有些情况下还需拼接doFinal的结果，这取决于分组模式
// 和填充模式，本例中GCM模式的doFinal结果只包含authTag而不含密文，所以不需要拼接）
let mergeText = new Uint8Array(cipherText.length + updateOutput.data.length);
mergeText.set(cipherText);
mergeText.set(updateOutput.data, cipherText.length);
cipherText = mergeText;
}
gcmParams.authTag = cipher.doFinalSync(null);
let cipherBlob: cryptoFramework.DataBlob = { data: cipherText };
return cipherBlob;
}
// 分段解密消息
function decryptMessage(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('AES128|GCM|PKCS7');
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, gcmParams);
let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求
let decryptText = new Uint8Array();
for (let i = 0; i < cipherText.data.length; i += updateLength) {
let updateMessage = cipherText.data.subarray(i, i + updateLength);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 分段update
let updateOutput = decoder.updateSync(updateMessageBlob);
// 把update的结果拼接起来，得到明文
let mergeText = new Uint8Array(decryptText.length + updateOutput.data.length);
mergeText.set(decryptText);
mergeText.set(updateOutput.data, decryptText.length);
decryptText = mergeText;
}
let decryptData = decoder.doFinalSync(null);
if (decryptData === null) {
console.info('GCM decrypt success, decryptData is null');
}
let decryptBlob: cryptoFramework.DataBlob = { data: decryptText };
return decryptBlob;
}
function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('AES128');
let symKey = aesGenerator.convertKeySync(symKeyBlob);
console.info('convertKeySync success');
return symKey;
}
function main() {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]);
let symKey = genSymKeyByData(keyData);
let message = "aaaaa.....bbbbb.....ccccc.....ddddd.....eee"; // 假设信息总共43字节，根据utf-8解码后，也是43字节
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = encryptMessageUpdateBySegment(symKey, plainText);
let decryptText = decryptMessage(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-aes-sym-encrypt-decrypt-gcm-by-segment-ndk-V14
爬取时间: 2025-04-28 01:43:16
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：AES。
在CMake脚本中链接相关动态库
开发步骤
创建对象
调用OH_CryptoSymKeyGenerator_Create、OH_CryptoSymKeyGenerator_Generate，生成密钥算法为AES、密钥长度为128位的对称密钥（OH_CryptoSymKey）。
如何生成AES对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：AES和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
加密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'AES128|GCM|PKCS7'，创建对称密钥类型为AES128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成加密操作。
2.  调用OH_CryptoSymCipherParams_Create创建参数对象，调用OH_CryptoSymCipherParams_SetParam设置对应的加密参数。
3.  调用OH_CryptoSymCipher_Init，设置模式为加密（CRYPTO_ENCRYPT_MODE），指定加密密钥（OH_CryptoSymKey）和GCM模式对应的加密参数（OH_CryptoSymCipherParams），初始化加密Cipher实例。
4.  将一次传入数据量设置为20字节，多次调用OH_CryptoSymCipher_Update，更新数据（明文）。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。 建议开发者对每次update的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文。因为在不同的规格下，update的结果可能会受到不同影响。 1）比如ECB和CBC模式，始终以分组作为基本单位来加密，并输出本次update产生的加密分组结果。即当本次update操作凑满一个分组就输出密文，没有凑满则此次update输出null，将未加密的数据与下次输入的数据拼接凑分组再输出。等到最后doFinal的时候，将未加密的数据，根据指定的填充模式进行填充，再输出剩余加密结果。解密过程中的update同理。 2）对于流加密模式（比如CTR和OFB模式），通常密文长度和明文长度相等。
5.  当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
6.  建议开发者对每次update的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文。因为在不同的规格下，update的结果可能会受到不同影响。 1）比如ECB和CBC模式，始终以分组作为基本单位来加密，并输出本次update产生的加密分组结果。即当本次update操作凑满一个分组就输出密文，没有凑满则此次update输出null，将未加密的数据与下次输入的数据拼接凑分组再输出。等到最后doFinal的时候，将未加密的数据，根据指定的填充模式进行填充，再输出剩余加密结果。解密过程中的update同理。 2）对于流加密模式（比如CTR和OFB模式），通常密文长度和明文长度相等。
7.  调用OH_CryptoSymCipher_Final，获取加密后的数据。 在GCM模式下，final会返回authTag，作为解密时初始化的认证信息，需要保存。 在GCM模式下，算法库当前只支持16字节的authTag，作为解密时初始化的认证信息。示例中authTag恰好为16字节。
8.  在GCM模式下，final会返回authTag，作为解密时初始化的认证信息，需要保存。 在GCM模式下，算法库当前只支持16字节的authTag，作为解密时初始化的认证信息。示例中authTag恰好为16字节。
-  当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
-  建议开发者对每次update的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文。因为在不同的规格下，update的结果可能会受到不同影响。 1）比如ECB和CBC模式，始终以分组作为基本单位来加密，并输出本次update产生的加密分组结果。即当本次update操作凑满一个分组就输出密文，没有凑满则此次update输出null，将未加密的数据与下次输入的数据拼接凑分组再输出。等到最后doFinal的时候，将未加密的数据，根据指定的填充模式进行填充，再输出剩余加密结果。解密过程中的update同理。 2）对于流加密模式（比如CTR和OFB模式），通常密文长度和明文长度相等。
-  在GCM模式下，final会返回authTag，作为解密时初始化的认证信息，需要保存。 在GCM模式下，算法库当前只支持16字节的authTag，作为解密时初始化的认证信息。示例中authTag恰好为16字节。
解密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'AES128|GCM|PKCS7'，创建对称密钥类型为AES128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用OH_CryptoSymCipherParams_SetParam设置authTag作为解密的认证信息。 在GCM模式下，需要从加密后的数据中取出末尾16字节，作为解密时初始化的认证信息。示例中authTag恰好为16字节。
3.  调用OH_CryptoSymCipher_Init，设置模式为解密（CRYPTO_DECRYPT_MODE），指定解密密钥（OH_CryptoSymKey）和GCM模式对应的解密参数（OH_CryptoSymCipherParams），初始化解密Cipher实例。
4.  将一次传入数据量设置为20字节，多次调用OH_CryptoSymCipher_Update，更新数据（密文）。
5.  调用OH_CryptoSymCipher_Final，获取解密后的数据。
销毁对象
调用OH_CryptoSymKeyGenerator_Destroy、OH_CryptoSymCipher_Destroy、OH_CryptoSymCipherParams_Destroy销毁各对象。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-3des-sym-encrypt-decrypt-ecb-V14
爬取时间: 2025-04-28 01:43:30
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：3DES。
加密
1.  调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.convertKey，生成密钥算法为3DES、密钥长度为192位的对称密钥（SymKey）。 如何生成3DES对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：3DES和指定二进制数据转换对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'3DES192|ECB|PKCS7'，创建对称密钥类型为3DES192、分组模式为ECB、填充模式为PKCS7的Cipher实例，用于完成加密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（SymKey），初始化加密Cipher实例。 ECB模式无加密参数，直接传入null。
4.  调用Cipher.update，更新数据（明文）。
5.  调用Cipher.doFinal，获取加密后的数据。
解密
1.  调用cryptoFramework.createCipher，指定字符串参数'3DES192|ECB|PKCS7'，创建对称密钥类型为3DES192、分组模式为ECB、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（SymKey）初始化解密Cipher实例。ECB模式无加密参数，直接传入null。
3.  调用Cipher.update，更新数据（密文）。
4.  调用Cipher.doFinal，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 加密消息
async function encryptMessagePromise(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('3DES192|ECB|PKCS7');
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, null);
let encryptData = await cipher.doFinal(plainText);
return encryptData;
}
// 解密消息
async function decryptMessagePromise(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('3DES192|ECB|PKCS7');
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, null);
let decryptData = await decoder.doFinal(cipherText);
return decryptData;
}
async function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let symGenerator = cryptoFramework.createSymKeyGenerator('3DES192');
let symKey = await symGenerator.convertKey(symKeyBlob);
console.info('convertKey success');
return symKey;
}
async function main() {
let keyData = new Uint8Array([238, 249, 61, 55, 128, 220, 183, 224, 139, 253, 248, 239, 239, 41, 71, 25, 235, 206, 230, 162, 249, 27, 234, 114]);
let symKey = await genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = await encryptMessagePromise(symKey, plainText);
let decryptText = await decryptMessagePromise(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 加密消息
function encryptMessage(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('3DES192|ECB|PKCS7');
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, null);
let encryptData = cipher.doFinalSync(plainText);
return encryptData;
}
// 解密消息
function decryptMessage(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('3DES192|ECB|PKCS7');
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, null);
let decryptData = decoder.doFinalSync(cipherText);
return decryptData;
}
function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let symGenerator = cryptoFramework.createSymKeyGenerator('3DES192');
let symKey = symGenerator.convertKeySync(symKeyBlob);
console.info('convertKeySync success');
return symKey;
}
function main() {
let keyData = new Uint8Array([238, 249, 61, 55, 128, 220, 183, 224, 139, 253, 248, 239, 239, 41, 71, 25, 235, 206, 230, 162, 249, 27, 234, 114]);
let symKey = genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = encryptMessage(symKey, plainText);
let decryptText = decryptMessage(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-3des-sym-encrypt-decrypt-ecb-ndk-V14
爬取时间: 2025-04-28 01:43:43
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：3DES。
在CMake脚本中链接相关动态库
开发步骤
创建对象
调用OH_CryptoSymKeyGenerator_Create、OH_CryptoSymKeyGenerator_Generate，生成密钥算法为3DES、密钥长度为192位的对称密钥（OH_CryptoSymKey）。
如何生成3DES对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：3DES和指定二进制数据转换对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
加密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'3DES192|ECB|PKCS7'，创建对称密钥类型为3DES192、分组模式为ECB、填充模式为PKCS7的Cipher实例，用于完成加密操作。
2.  调用OH_CryptoSymCipher_Init，设置模式为加密（CRYPTO_ENCRYPT_MODE），指定加密密钥（OH_CryptoSymKey），初始化加密Cipher实例。 ECB模式无加密参数，params直接传入null。
3.  调用OH_CryptoSymCipher_Update，更新数据（明文）。
4.  调用OH_CryptoSymCipher_Final，获取加密后的数据。
解密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'3DES192|ECB|PKCS7'，创建对称密钥类型为3DES192、分组模式为ECB、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用OH_CryptoSymCipher_Init，设置模式为解密（CRYPTO_DECRYPT_MODE），指定解密密钥（OH_CryptoSymKey）初始化解密Cipher实例。ECB模式无加密参数，直接传入null。
3.  调用OH_CryptoSymCipher_Update，更新数据（密文）。
4.  调用OH_CryptoSymCipher_Final，获取解密后的数据。
销毁对象
调用OH_CryptoSymKeyGenerator_Destroy、OH_CryptoSymCipher_Destroy、OH_CryptoSymKey_Destroy、OH_Crypto_FreeDataBlob释放申请的内存，销毁对象。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sm4-sym-encrypt-decrypt-ecb-V14
爬取时间: 2025-04-28 01:43:57
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：SM4。
加密
1.  调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.generateSymKey，生成密钥算法为SM4、密钥长度为128位的对称密钥（SymKey）。 如何生成SM4对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：SM4和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'SM4_128|ECB|PKCS7'，创建对称密钥类型为SM4_128、分组模式为ECB、填充模式为PKCS7的Cipher实例，用于完成加密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（SymKey），初始化加密Cipher实例。 ECB模式无加密参数，直接传入null。
4.  调用Cipher.update，更新数据（明文）。
5.  调用Cipher.doFinal，获取加密后的数据。
解密
1.  调用cryptoFramework.createCipher，指定字符串参数'SM4_128|ECB|PKCS7'，创建对称密钥类型为SM4_128、分组模式为ECB、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（SymKey）初始化解密Cipher实例。ECB模式无加密参数，直接传入null。
3.  调用Cipher.update，更新数据（密文）。
4.  调用Cipher.doFinal，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 加密消息
async function encryptMessagePromise(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('SM4_128|ECB|PKCS7');
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, null);
let encryptData = await cipher.doFinal(plainText);
return encryptData;
}
// 解密消息
async function decryptMessagePromise(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('SM4_128|ECB|PKCS7');
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, null);
let decryptData = await decoder.doFinal(cipherText);
return decryptData;
}
async function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let symGenerator = cryptoFramework.createSymKeyGenerator('SM4_128');
let symKey = await symGenerator.convertKey(symKeyBlob);
console.info('convertKey success');
return symKey;
}
async function main() {
let keyData = new Uint8Array([7, 154, 52, 176, 4, 236, 150, 43, 237, 9, 145, 166, 141, 174, 224, 131]);
let symKey = await genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = await encryptMessagePromise(symKey, plainText);
let decryptText = await decryptMessagePromise(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 加密消息
function encryptMessage(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('SM4_128|ECB|PKCS7');
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, null);
let encryptData = cipher.doFinalSync(plainText);
return encryptData;
}
// 解密消息
function decryptMessage(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('SM4_128|ECB|PKCS7');
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, null);
let decryptData = decoder.doFinalSync(cipherText);
return decryptData;
}
function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let symGenerator = cryptoFramework.createSymKeyGenerator('SM4_128');
let symKey = symGenerator.convertKeySync(symKeyBlob);
console.info('convertKeySync success');
return symKey;
}
function main() {
let keyData = new Uint8Array([7, 154, 52, 176, 4, 236, 150, 43, 237, 9, 145, 166, 141, 174, 224, 131]);
let symKey = genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = encryptMessage(symKey, plainText);
let decryptText = decryptMessage(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sm4-sym-encrypt-decrypt-ecb-ndk-V14
爬取时间: 2025-04-28 01:44:11
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：SM4。
在CMake脚本中链接相关动态库
加密
1.  调用OH_CryptoSymKeyGenerator_Create、OH_CryptoSymKeyGenerator_Generate，生成密钥算法为SM4、密钥长度为128位的对称密钥（OH_CryptoSymKey）。 如何生成SM4对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：SM4和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用OH_CryptoSymCipher_Create，指定字符串参数'SM4_128|ECB|PKCS7'，创建对称密钥类型为SM4_128、分组模式为ECB、填充模式为PKCS7的Cipher实例，用于完成加密操作。
3.  调用OH_CryptoSymCipher_Init，设置模式为加密（CRYPTO_ENCRYPT_MODE），指定加密密钥（OH_CryptoSymKey），初始化加密Cipher实例。 ECB模式无加密参数，直接传入null。
4.  调用OH_CryptoSymCipher_Update，更新数据（明文）。
5.  调用OH_CryptoSymCipher_Final，获取加密后的数据。
6.  调用OH_CryptoSymKeyGenerator_Destroy、OH_CryptoSymCipher_Destroy、OH_CryptoSymCipherParams_Destroy销毁各对象。
解密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'SM4_128|ECB|PKCS7'，创建对称密钥类型为SM4_128、分组模式为ECB、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用OH_CryptoSymCipher_Init，设置模式为解密（CRYPTO_DECRYPT_MODE），指定解密密钥（OH_CryptoSymKey）初始化解密Cipher实例。ECB模式无加密参数，直接传入null。
3.  调用OH_CryptoSymCipher_Update，更新数据（密文）。
4.  调用OH_CryptoSymCipher_Final，获取解密后的数据。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sm4-sym-encrypt-decrypt-cbc-V14
爬取时间: 2025-04-28 01:44:24
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：SM4。
加密
1.  调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.generateSymKey，生成密钥算法为SM4、密钥长度为128位的对称密钥（SymKey）。 如何生成SM4对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：SM4和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'SM4_128|CBC|PKCS7'，创建对称密钥类型为SM4_128、分组模式为CBC、填充模式为PKCS7的Cipher实例，用于完成加密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（SymKey）和CBC模式对应的加密参数（IvParamsSpec），初始化加密Cipher实例。
4.  调用Cipher.update，更新数据（明文）。
5.  调用Cipher.doFinal，获取加密后的数据。
解密
1.  调用cryptoFramework.createCipher，指定字符串参数'SM4_128|CBC|PKCS7'，创建对称密钥类型为SM4_128、分组模式为CBC、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（SymKey）和CBC模式对应的解密参数（IvParamsSpec），初始化解密Cipher实例。
3.  调用Cipher.update，更新数据（密文）。
4.  调用Cipher.doFinal，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function generateRandom(len: number) {
let rand = cryptoFramework.createRandom();
let generateRandSync = rand.generateRandomSync(len);
return generateRandSync;
}
function genIvParamsSpec() {
let ivBlob = generateRandom(16); // 16 bytes
let ivParamsSpec: cryptoFramework.IvParamsSpec = {
algName: "IvParamsSpec",
iv: ivBlob
};
return ivParamsSpec;
}
let iv = genIvParamsSpec();
// 加密消息
async function encryptMessagePromise(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('SM4_128|CBC|PKCS7');
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, iv);
let encryptData = await cipher.doFinal(plainText);
return encryptData;
}
// 解密消息
async function decryptMessagePromise(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('SM4_128|CBC|PKCS7');
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, iv);
let decryptData = await decoder.doFinal(cipherText);
return decryptData;
}
async function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let symGenerator = cryptoFramework.createSymKeyGenerator('SM4_128');
let symKey = await symGenerator.convertKey(symKeyBlob);
console.info('convertKey success');
return symKey;
}
async function main() {
try {
let keyData = new Uint8Array([7, 154, 52, 176, 4, 236, 150, 43, 237, 9, 145, 166, 141, 174, 224, 131]);
let symKey = await genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = await encryptMessagePromise(symKey, plainText);
let decryptText = await decryptMessagePromise(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
} catch (error) {
console.error(`SM4 “${error}“, error code: ${error.code}`);
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function generateRandom(len: number) {
let rand = cryptoFramework.createRandom();
let generateRandSync = rand.generateRandomSync(len);
return generateRandSync;
}
function genIvParamsSpec() {
let ivBlob = generateRandom(16); // 16 bytes
let ivParamsSpec: cryptoFramework.IvParamsSpec = {
algName: "IvParamsSpec",
iv: ivBlob
};
return ivParamsSpec;
}
let iv = genIvParamsSpec();
// 加密消息
function encryptMessage(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('SM4_128|CBC|PKCS7');
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, iv);
let encryptData = cipher.doFinalSync(plainText);
return encryptData;
}
// 解密消息
function decryptMessage(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('SM4_128|CBC|PKCS7');
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, iv);
let decryptData = decoder.doFinalSync(cipherText);
return decryptData;
}
function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let symGenerator = cryptoFramework.createSymKeyGenerator('SM4_128');
let symKey = symGenerator.convertKeySync(symKeyBlob);
console.info('convertKeySync success');
return symKey;
}
function main() {
try {
let keyData = new Uint8Array([7, 154, 52, 176, 4, 236, 150, 43, 237, 9, 145, 166, 141, 174, 224, 131]);
let symKey = genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = encryptMessage(symKey, plainText);
let decryptText = decryptMessage(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
} catch (error) {
console.error(`SM4 “${error}“, error code: ${error.code}`);
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sm4-sym-encrypt-decrypt-cbc-ndk-V14
爬取时间: 2025-04-28 01:44:38
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：SM4。
在CMake脚本中链接相关动态库
加密
1.  调用OH_CryptoSymKeyGenerator_Create、OH_CryptoSymKeyGenerator_Generate，生成密钥算法为SM4、密钥长度为128位的对称密钥（OH_CryptoSymKey）。 如何生成SM4对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：SM4和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用OH_CryptoSymCipher_Create，指定字符串参数'SM4_128|CBC|PKCS7'，创建对称密钥类型为SM4_128、分组模式为CBC、填充模式为PKCS7的Cipher实例，用于完成加密操作。
3.  调用OH_CryptoSymCipherParams_Create创建参数对象，调用OH_CryptoSymCipherParams_SetParam设置对应的加密参数。
4.  调用OH_CryptoSymCipher_Init，设置模式为加密（CRYPTO_ENCRYPT_MODE），指定加密密钥（OH_CryptoSymKey）和CBC模式对应的加密参数（OH_CryptoSymCipherParams），初始化加密Cipher实例。
5.  调用OH_CryptoSymCipher_Update，更新数据（明文）。
6.  调用OH_CryptoSymCipher_Final，获取加密后的数据。
7.  调用OH_CryptoSymKeyGenerator_Destroy、OH_CryptoSymCipher_Destroy、OH_CryptoSymCipherParams_Destroy销毁各对象。
解密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'SM4_128|CBC|PKCS7'，创建对称密钥类型为SM4_128、分组模式为CBC、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用OH_CryptoSymCipher_Init，设置模式为解密（CRYPTO_DECRYPT_MODE），指定解密密钥（OH_CryptoSymKey）和CBC模式对应的解密参数（OH_CryptoSymCipherParams），初始化解密Cipher实例。
3.  调用OH_CryptoSymCipher_Update，更新数据（密文）。
4.  调用OH_CryptoSymCipher_Final，获取解密后的数据。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sm4-sym-encrypt-decrypt-gcm-V14
爬取时间: 2025-04-28 01:44:51
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：SM4。
加密
1.  调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.generateSymKey，生成密钥算法为SM4、密钥长度为128位的对称密钥（SymKey）。 如何生成SM4对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：SM4和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'SM4_128|GCM|PKCS7'，创建对称密钥类型为SM4_128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成加密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（SymKey）和GCM模式对应的加密参数（GcmParamsSpec），初始化加密Cipher实例。
4.  调用Cipher.update，更新数据（明文）。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
5.  调用Cipher.doFinal，获取加密后的数据。
6.  读取GcmParamsSpec.authTag作为解密的认证信息。 在GCM模式下，需要从加密后的数据中取出末尾16字节，作为解密时初始化的认证信息。示例中authTag恰好为16字节。
解密
1.  调用cryptoFramework.createCipher，指定字符串参数'SM4_128|GCM|PKCS7'，创建对称密钥类型为SM4_128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（SymKey）和GCM模式对应的解密参数（GcmParamsSpec），初始化解密Cipher实例。
3.  调用Cipher.update，更新数据（密文）。
4.  调用Cipher.doFinal，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function generateRandom(len: number) {
let rand = cryptoFramework.createRandom();
let generateRandSync = rand.generateRandomSync(len);
return generateRandSync;
}
function genGcmParamsSpec() {
let ivBlob = generateRandom(12); // 12 bytes
let arr = [1, 2, 3, 4, 5, 6, 7, 8]; // 8 bytes
let dataAad = new Uint8Array(arr);
let aadBlob: cryptoFramework.DataBlob = { data: dataAad };
arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 16 bytes
let dataTag = new Uint8Array(arr);
let tagBlob: cryptoFramework.DataBlob = {
data: dataTag
};
// GCM的authTag在加密时从doFinal结果中获取，在解密时填入init函数的params参数中
let gcmParamsSpec: cryptoFramework.GcmParamsSpec = {
iv: ivBlob,
aad: aadBlob,
authTag: tagBlob,
algName: "GcmParamsSpec"
};
return gcmParamsSpec;
}
let gcmParams = genGcmParamsSpec();
// 加密消息
async function encryptMessagePromise(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('SM4_128|GCM|PKCS7');
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, gcmParams);
let encryptUpdate = await cipher.update(plainText);
// gcm模式加密doFinal时传入空，获得tag数据，并更新至gcmParams对象中。
gcmParams.authTag = await cipher.doFinal(null);
return encryptUpdate;
}
// 解密消息
async function decryptMessagePromise(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('SM4_128|GCM|PKCS7');
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, gcmParams);
let decryptUpdate = await decoder.update(cipherText);
// gcm模式解密doFinal时传入空，验证init时传入的tag数据，如果验证失败会抛出异常。
let decryptData = await decoder.doFinal(null);
if (decryptData === null) {
console.info('GCM decrypt success, decryptData is null');
}
return decryptUpdate;
}
async function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let sm4Generator = cryptoFramework.createSymKeyGenerator('SM4_128');
let symKey = await sm4Generator.convertKey(symKeyBlob);
console.info('convertKey success');
return symKey;
}
async function main() {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]);
let symKey = await genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = await encryptMessagePromise(symKey, plainText);
let decryptText = await decryptMessagePromise(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function generateRandom(len: number) {
let rand = cryptoFramework.createRandom();
let generateRandSync = rand.generateRandomSync(len);
return generateRandSync;
}
function genGcmParamsSpec() {
let ivBlob = generateRandom(12); // 12 bytes
let arr = [1, 2, 3, 4, 5, 6, 7, 8]; // 8 bytes
let dataAad = new Uint8Array(arr);
let aadBlob: cryptoFramework.DataBlob = { data: dataAad };
arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 16 bytes
let dataTag = new Uint8Array(arr);
let tagBlob: cryptoFramework.DataBlob = {
data: dataTag
};
// GCM的authTag在加密时从doFinal结果中获取，在解密时填入init函数的params参数中
let gcmParamsSpec: cryptoFramework.GcmParamsSpec = {
iv: ivBlob,
aad: aadBlob,
authTag: tagBlob,
algName: "GcmParamsSpec"
};
return gcmParamsSpec;
}
let gcmParams = genGcmParamsSpec();
// 加密消息
function encryptMessage(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('SM4_128|GCM|PKCS7');
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, gcmParams);
let encryptUpdate = cipher.updateSync(plainText);
// gcm模式加密doFinal时传入空，获得tag数据，并更新至gcmParams对象中。
gcmParams.authTag = cipher.doFinalSync(null);
return encryptUpdate;
}
// 解密消息
function decryptMessage(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('SM4_128|GCM|PKCS7');
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, gcmParams);
let decryptUpdate = decoder.updateSync(cipherText);
// gcm模式解密doFinal时传入空，验证init时传入的tag数据，如果验证失败会抛出异常。
let decryptData = decoder.doFinalSync(null);
if (decryptData === null) {
console.info('GCM decrypt success, decryptData is null');
}
return decryptUpdate;
}
function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let sm4Generator = cryptoFramework.createSymKeyGenerator('SM4_128');
let symKey = sm4Generator.convertKeySync(symKeyBlob);
console.info('convertKeySync success');
return symKey;
}
function main() {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]);
let symKey = genSymKeyByData(keyData);
let message = "This is a test";
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = encryptMessage(symKey, plainText);
let decryptText = decryptMessage(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sm4-sym-encrypt-decrypt-gcm-ndk-V14
爬取时间: 2025-04-28 01:45:05
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：SM4。
在CMake脚本中链接相关动态库
加密
1.  调用OH_CryptoSymKeyGenerator_Create、OH_CryptoSymKeyGenerator_Generate，生成密钥算法为SM4、密钥长度为128位的对称密钥（OH_CryptoSymKey）。 如何生成SM4对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：SM4和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用OH_CryptoSymCipher_Create，指定字符串参数'SM4_128|GCM|PKCS7'，创建对称密钥类型为SM4_128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成加密操作。
3.  调用OH_CryptoSymCipherParams_Create创建参数对象，调用OH_CryptoSymCipherParams_SetParam设置对应的加密参数。
4.  调用OH_CryptoSymCipher_Init，设置模式为加密（CRYPTO_ENCRYPT_MODE），指定加密密钥（OH_CryptoSymKey）和GCM模式对应的加密参数（OH_CryptoSymCipherParams），初始化加密Cipher实例。
5.  调用OH_CryptoSymCipher_Update，更新数据（明文）。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
6.  调用OH_CryptoSymCipher_Final，获取加密后的数据。
7.  使用OH_CryptoSymCipherParams_Create创建Params，使用OH_CryptoSymCipherParams_SetParam设置authTag，作为解密的认证信息。在GCM模式下，需要从加密后的数据中取出末尾16字节，作为解密时初始化的认证信息。示例中authTag恰好为16字节。
8.  调用OH_CryptoSymKeyGenerator_Destroy、OH_CryptoSymCipher_Destroy、OH_CryptoSymCipherParams_Destroy销毁各对象。
解密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'SM4_128|GCM|PKCS7'，创建对称密钥类型为SM4_128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用OH_CryptoSymCipher_Init，设置模式为解密（CRYPTO_DECRYPT_MODE），指定解密密钥（OH_CryptoSymKey）和GCM模式对应的解密参数（OH_CryptoSymCipherParams），初始化解密Cipher实例。
3.  调用OH_CryptoSymCipher_Update，更新数据（密文）。
4.  调用OH_CryptoSymCipher_Final，获取解密后的数据。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sm4-sym-encrypt-decrypt-gcm-by-segment-V14
爬取时间: 2025-04-28 01:45:19
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：SM4。
加密
1.  调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.generateSymKey，生成密钥算法为SM4、密钥长度为128位的对称密钥（SymKey）。 如何生成SM4对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：SM4和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'SM4_128|GCM|PKCS7'，创建对称密钥类型为SM4_128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成加密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（SymKey）和GCM模式对应的加密参数（GcmParamsSpec），初始化加密Cipher实例。
4.  将一次传入数据量设置为20字节，多次调用Cipher.update，更新数据（明文）。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。 建议开发者对每次update的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文。因为在不同的规格下，update的结果可能会受到不同影响。 1）比如ECB和CBC模式，始终以分组作为基本单位来加密，并输出本次update产生的加密分组结果。即当本次update操作凑满一个分组就输出密文，没有凑满则此次update输出null，将未加密的数据与下次输入的数据拼接凑分组再输出。等到最后doFinal的时候，将未加密的数据，根据指定的填充模式进行填充，在输出剩余加密结果。解密过程中的update同理。 2）对于流加密模式（比如CTR和OFB模式），通常密文长度和明文长度相等。
5.  当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
6.  建议开发者对每次update的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文。因为在不同的规格下，update的结果可能会受到不同影响。 1）比如ECB和CBC模式，始终以分组作为基本单位来加密，并输出本次update产生的加密分组结果。即当本次update操作凑满一个分组就输出密文，没有凑满则此次update输出null，将未加密的数据与下次输入的数据拼接凑分组再输出。等到最后doFinal的时候，将未加密的数据，根据指定的填充模式进行填充，在输出剩余加密结果。解密过程中的update同理。 2）对于流加密模式（比如CTR和OFB模式），通常密文长度和明文长度相等。
7.  调用Cipher.doFinal，获取加密后的数据。
8.  读取GcmParamsSpec.authTag作为解密的认证信息。 在GCM模式下，需要从加密后的数据中取出末尾16字节，作为解密时初始化的认证信息。示例中authTag恰好为16字节。
-  当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
-  建议开发者对每次update的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文。因为在不同的规格下，update的结果可能会受到不同影响。 1）比如ECB和CBC模式，始终以分组作为基本单位来加密，并输出本次update产生的加密分组结果。即当本次update操作凑满一个分组就输出密文，没有凑满则此次update输出null，将未加密的数据与下次输入的数据拼接凑分组再输出。等到最后doFinal的时候，将未加密的数据，根据指定的填充模式进行填充，在输出剩余加密结果。解密过程中的update同理。 2）对于流加密模式（比如CTR和OFB模式），通常密文长度和明文长度相等。
解密
1.  调用cryptoFramework.createCipher，指定字符串参数'SM4_128|GCM|PKCS7'，创建对称密钥类型为SM4_128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（SymKey）和GCM模式对应的解密参数（GcmParamsSpec），初始化解密Cipher实例。
3.  将一次传入数据量设置为20字节，多次调用Cipher.update，更新数据（密文）。
4.  调用Cipher.doFinal，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function generateRandom(len: number) {
let rand = cryptoFramework.createRandom();
let generateRandSync = rand.generateRandomSync(len);
return generateRandSync;
}
function genGcmParamsSpec() {
let ivBlob = generateRandom(12);
let arr = [1, 2, 3, 4, 5, 6, 7, 8]; // 8 bytes
let dataAad = new Uint8Array(arr);
let aadBlob: cryptoFramework.DataBlob = { data: dataAad };
arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 16 bytes
let dataTag = new Uint8Array(arr);
let tagBlob: cryptoFramework.DataBlob = {
data: dataTag
}; // The GCM authTag is obtained by doFinal() in encryption and passed in params of init() in decryption.
let gcmParamsSpec: cryptoFramework.GcmParamsSpec = {
iv: ivBlob,
aad: aadBlob,
authTag: tagBlob,
algName: "GcmParamsSpec"
};
return gcmParamsSpec;
}
let gcmParams = genGcmParamsSpec();
// 分段加密消息
async function encryptMessageUpdateBySegment(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('SM4_128|GCM|PKCS7');
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, gcmParams);
let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求
let cipherText = new Uint8Array();
for (let i = 0; i < plainText.data.length; i += updateLength) {
let updateMessage = plainText.data.subarray(i, i + updateLength);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 分段update
let updateOutput = await cipher.update(updateMessageBlob);
// 把update的结果拼接起来，得到密文（有些情况下还需拼接doFinal的结果，这取决于分组模式
// 和填充模式，本例中GCM模式的doFinal结果只包含authTag而不含密文，所以不需要拼接）
let mergeText = new Uint8Array(cipherText.length + updateOutput.data.length);
mergeText.set(cipherText);
mergeText.set(updateOutput.data, cipherText.length);
cipherText = mergeText;
}
gcmParams.authTag = await cipher.doFinal(null);
let cipherBlob: cryptoFramework.DataBlob = { data: cipherText };
return cipherBlob;
}
// 分段解密消息
async function decryptMessagePromise(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('SM4_128|GCM|PKCS7');
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, gcmParams);
let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求
let decryptText = new Uint8Array();
for (let i = 0; i < cipherText.data.length; i += updateLength) {
let updateMessage = cipherText.data.subarray(i, i + updateLength);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 分段update
let updateOutput = await decoder.update(updateMessageBlob);
// 把update的结果拼接起来，得到明文
let mergeText = new Uint8Array(decryptText.length + updateOutput.data.length);
mergeText.set(decryptText);
mergeText.set(updateOutput.data, decryptText.length);
decryptText = mergeText;
}
let decryptData = await decoder.doFinal(null);
if (decryptData === null) {
console.info('GCM decrypt success, decryptData is null');
}
let decryptBlob: cryptoFramework.DataBlob = { data: decryptText };
return decryptBlob;
}
async function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let sm4Generator = cryptoFramework.createSymKeyGenerator('SM4_128');
let symKey = await sm4Generator.convertKey(symKeyBlob);
console.info('convertKey success');
return symKey;
}
async function sm4() {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]);
let symKey = await genSymKeyByData(keyData);
let message = "aaaaa.....bbbbb.....ccccc.....ddddd.....eee"; // 假设信息总共43字节，根据utf-8解码后，也是43字节
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = await encryptMessageUpdateBySegment(symKey, plainText);
let decryptText = await decryptMessagePromise(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function generateRandom(len: number) {
let rand = cryptoFramework.createRandom();
let generateRandSync = rand.generateRandomSync(len);
return generateRandSync;
}
function genGcmParamsSpec() {
let ivBlob = generateRandom(12); // 12 bytes
let arr = [1, 2, 3, 4, 5, 6, 7, 8]; // 8 bytes
let dataAad = new Uint8Array(arr);
let aadBlob: cryptoFramework.DataBlob = { data: dataAad };
arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 16 bytes
let dataTag = new Uint8Array(arr);
let tagBlob: cryptoFramework.DataBlob = {
data: dataTag
}; // The GCM authTag is obtained by doFinal() in encryption and passed in params of init() in decryption.
let gcmParamsSpec: cryptoFramework.GcmParamsSpec = {
iv: ivBlob,
aad: aadBlob,
authTag: tagBlob,
algName: "GcmParamsSpec"
};
return gcmParamsSpec;
}
let gcmParams = genGcmParamsSpec();
// 分段加密消息
function encryptMessageUpdateBySegment(symKey: cryptoFramework.SymKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('SM4_128|GCM|PKCS7');
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, symKey, gcmParams);
let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求
let cipherText = new Uint8Array();
for (let i = 0; i < plainText.data.length; i += updateLength) {
let updateMessage = plainText.data.subarray(i, i + updateLength);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 分段update
let updateOutput = cipher.updateSync(updateMessageBlob);
// 把update的结果拼接起来，得到密文（有些情况下还需拼接doFinal的结果，这取决于分组模式
// 和填充模式，本例中GCM模式的doFinal结果只包含authTag而不含密文，所以不需要拼接）
let mergeText = new Uint8Array(cipherText.length + updateOutput.data.length);
mergeText.set(cipherText);
mergeText.set(updateOutput.data, cipherText.length);
cipherText = mergeText;
}
gcmParams.authTag = cipher.doFinalSync(null);
let cipherBlob: cryptoFramework.DataBlob = { data: cipherText };
return cipherBlob;
}
// 分段解密消息
function decryptMessage(symKey: cryptoFramework.SymKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('SM4_128|GCM|PKCS7');
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, symKey, gcmParams);
let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求
let decryptText = new Uint8Array();
for (let i = 0; i < cipherText.data.length; i += updateLength) {
let updateMessage = cipherText.data.subarray(i, i + updateLength);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 分段update
let updateOutput = decoder.updateSync(updateMessageBlob);
// 把update的结果拼接起来，得到明文
let mergeText = new Uint8Array(decryptText.length + updateOutput.data.length);
mergeText.set(decryptText);
mergeText.set(updateOutput.data, decryptText.length);
decryptText = mergeText;
}
let decryptData = decoder.doFinalSync(null);
if (decryptData === null) {
console.info('GCM decrypt success, decryptData is null');
}
let decryptBlob: cryptoFramework.DataBlob = { data: decryptText };
return decryptBlob;
}
function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let sm4Generator = cryptoFramework.createSymKeyGenerator('SM4_128');
let symKey = sm4Generator.convertKeySync(symKeyBlob);
console.info('convertKeySync success');
return symKey;
}
function main() {
let keyData = new Uint8Array([83, 217, 231, 76, 28, 113, 23, 219, 250, 71, 209, 210, 205, 97, 32, 159]);
let symKey = genSymKeyByData(keyData);
let message = "aaaaa.....bbbbb.....ccccc.....ddddd.....eee"; // 假设信息总共43字节，根据utf-8解码后，也是43字节
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = encryptMessageUpdateBySegment(symKey, plainText);
let decryptText = decryptMessage(symKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sm4-sym-encrypt-decrypt-gcm-by-segment-ndk-V14
爬取时间: 2025-04-28 01:45:32
来源: Huawei Developer
对应的算法规格请查看对称密钥加解密算法规格：SM4。
在CMake脚本中链接相关动态库
加密
1.  调用OH_CryptoSymKeyGenerator_Create、OH_CryptoSymKeyGenerator_Generate，生成密钥算法为SM4、密钥长度为128位的对称密钥（OH_CryptoSymKey）。 如何生成SM4对称密钥，开发者可参考下文示例，并结合对称密钥生成和转换规格：SM4和随机生成对称密钥理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用OH_CryptoSymCipher_Create，指定字符串参数'SM4_128|GCM|PKCS7'，创建对称密钥类型为SM4_128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成加密操作。
3.  调用OH_CryptoSymCipherParams_Create创建参数对象，调用OH_CryptoSymCipherParams_SetParam设置对应的加密参数。
4.  调用OH_CryptoSymCipher_Init，设置模式为加密（CRYPTO_ENCRYPT_MODE），指定加密密钥（OH_CryptoSymKey）和GCM模式对应的加密参数（OH_CryptoSymCipherParams），初始化加密Cipher实例。
5.  将一次传入数据量设置为20字节，多次调用OH_CryptoSymCipher_Update，更新数据（明文）。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。 建议开发者对每次update的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文。因为在不同的规格下，update的结果可能会受到不同影响。 1）比如ECB和CBC模式，始终以分组作为基本单位来加密，并输出本次update产生的加密分组结果。即当本次update操作凑满一个分组就输出密文，没有凑满则此次update输出null，将未加密的数据与下次输入的数据拼接凑分组再输出。等到最后doFinal的时候，将未加密的数据，根据指定的填充模式进行填充，在输出剩余加密结果。解密过程中的update同理。 2）对于流加密模式（比如CTR和OFB模式），通常密文长度和明文长度相等。
6.  当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
7.  建议开发者对每次update的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文。因为在不同的规格下，update的结果可能会受到不同影响。 1）比如ECB和CBC模式，始终以分组作为基本单位来加密，并输出本次update产生的加密分组结果。即当本次update操作凑满一个分组就输出密文，没有凑满则此次update输出null，将未加密的数据与下次输入的数据拼接凑分组再输出。等到最后doFinal的时候，将未加密的数据，根据指定的填充模式进行填充，在输出剩余加密结果。解密过程中的update同理。 2）对于流加密模式（比如CTR和OFB模式），通常密文长度和明文长度相等。
8.  调用OH_CryptoSymCipher_Final，获取加密后的数据。
9.  使用OH_CryptoSymCipherParams_Create创建Params，使用OH_CryptoSymCipherParams_SetParam设置authTag，作为解密的认证信息。 在GCM模式下，需要从加密后的数据中取出末尾16字节，作为解密时初始化的认证信息。示例中authTag恰好为16字节。
10.  调用OH_CryptoSymKeyGenerator_Destroy、OH_CryptoSymCipher_Destroy、OH_CryptoSymCipherParams_Destroy销毁各对象。
-  当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
-  建议开发者对每次update的结果都判断是否为null，并在结果不为null时取出其中的数据进行拼接，形成完整的密文。因为在不同的规格下，update的结果可能会受到不同影响。 1）比如ECB和CBC模式，始终以分组作为基本单位来加密，并输出本次update产生的加密分组结果。即当本次update操作凑满一个分组就输出密文，没有凑满则此次update输出null，将未加密的数据与下次输入的数据拼接凑分组再输出。等到最后doFinal的时候，将未加密的数据，根据指定的填充模式进行填充，在输出剩余加密结果。解密过程中的update同理。 2）对于流加密模式（比如CTR和OFB模式），通常密文长度和明文长度相等。
解密
1.  调用OH_CryptoSymCipher_Create，指定字符串参数'SM4_128|GCM|PKCS7'，创建对称密钥类型为SM4_128、分组模式为GCM、填充模式为PKCS7的Cipher实例，用于完成解密操作。
2.  调用OH_CryptoSymCipher_Init，设置模式为解密（CRYPTO_DECRYPT_MODE），指定解密密钥（OH_CryptoSymKey）和GCM模式对应的解密参数（OH_CryptoSymCipherParams），初始化解密Cipher实例。
3.  将一次传入数据量设置为20字节，多次调用OH_CryptoSymCipher_Update，更新数据（密文）。
4.  调用OH_CryptoSymCipher_Final，获取解密后的数据。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-rsa-asym-encrypt-decrypt-pkcs1-V14
爬取时间: 2025-04-28 01:46:26
来源: Huawei Developer
对应的算法规格请查看非对称密钥加解密算法规格：RSA。
加密
1.  调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair，生成RSA密钥类型为RSA1024、素数个数为2的非对称密钥对（KeyPair）。KeyPair对象中包括公钥PubKey、私钥PriKey。 如何生成RSA非对称密钥对，开发者可参考下文示例，并结合非对称密钥生成和转换规格：RSA和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'RSA1024|PKCS1'，创建非对称密钥类型为RSA1024、填充模式为PKCS1的Cipher实例，用于完成加解密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（KeyPair.PubKey），初始化加密Cipher实例。 非对称密钥无加密参数，直接传入null。
4.  调用Cipher.doFinal，传入明文，获取加密后的数据。
解密
1.  由于RSA算法的Cipher实例不支持重复init操作，需要调用cryptoFramework.createCipher，重新生成Cipher实例。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（KeyPair.PriKey）初始化解密Cipher实例。PKCS1模式无加密参数，直接传入null。
3.  调用Cipher.doFinal，传入密文，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 加密消息
async function encryptMessagePromise(publicKey: cryptoFramework.PubKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('RSA1024|PKCS1');
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, publicKey, null);
let encryptData = await cipher.doFinal(plainText);
return encryptData;
}
// 解密消息
async function decryptMessagePromise(privateKey: cryptoFramework.PriKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('RSA1024|PKCS1');
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, privateKey, null);
let decryptData = await decoder.doFinal(cipherText);
return decryptData;
}
// 生成RSA密钥对
async function genKeyPairByData(pubKeyData: Uint8Array, priKeyData: Uint8Array) {
let pubKeyBlob: cryptoFramework.DataBlob = { data: pubKeyData };
let priKeyBlob: cryptoFramework.DataBlob = { data: priKeyData };
let rsaGenerator = cryptoFramework.createAsyKeyGenerator('RSA1024');
let keyPair = await rsaGenerator.convertKey(pubKeyBlob, priKeyBlob);
console.info('convertKey success');
return keyPair;
}
async function main() {
let pkData = new Uint8Array([48, 129, 159, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0, 3, 129, 141, 0, 48, 129, 137, 2, 129, 129, 0, 197, 64, 10, 198, 14, 110, 65, 92, 206, 35, 28, 123, 153, 24, 134, 255, 145, 74, 42, 173, 40, 215, 146, 58, 143, 46, 10, 195, 154, 160, 69, 196, 220, 152, 179, 44, 111, 200, 84, 78, 215, 73, 210, 181, 12, 29, 70, 68, 36, 135, 153, 89, 230, 202, 130, 212, 111, 243, 234, 92, 131, 62, 145, 50, 73, 48, 104, 245, 46, 70, 45, 157, 147, 143, 140, 162, 156, 216, 220, 49, 121, 142, 194, 33, 223, 201, 0, 16, 163, 210, 240, 118, 92, 147, 121, 220, 17, 114, 24, 52, 125, 135, 176, 88, 21, 83, 86, 17, 156, 88, 250, 48, 79, 86, 128, 248, 105, 208, 133, 140, 13, 153, 164, 191, 136, 164, 44, 53, 2, 3, 1, 0, 1]);
let skData = new Uint8Array([48, 130, 2, 119, 2, 1, 0, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0, 4, 130, 2, 97, 48, 130, 2, 93, 2, 1, 0, 2, 129, 129, 0, 197, 64, 10, 198, 14, 110, 65, 92, 206, 35, 28, 123, 153, 24, 134, 255, 145, 74, 42, 173, 40, 215, 146, 58, 143, 46, 10, 195, 154, 160, 69, 196, 220, 152, 179, 44, 111, 200, 84, 78, 215, 73, 210, 181, 12, 29, 70, 68, 36, 135, 153, 89, 230, 202, 130, 212, 111, 243, 234, 92, 131, 62, 145, 50, 73, 48, 104, 245, 46, 70, 45, 157, 147, 143, 140, 162, 156, 216, 220, 49, 121, 142, 194, 33, 223, 201, 0, 16, 163, 210, 240, 118, 92, 147, 121, 220, 17, 114, 24, 52, 125, 135, 176, 88, 21, 83, 86, 17, 156, 88, 250, 48, 79, 86, 128, 248, 105, 208, 133, 140, 13, 153, 164, 191, 136, 164, 44, 53, 2, 3, 1, 0, 1, 2, 129, 128, 70, 75, 184, 139, 53, 1, 94, 17, 240, 244, 218, 101, 193, 253, 215, 190, 164, 204, 197, 192, 200, 89, 107, 39, 171, 119, 65, 38, 204, 168, 105, 180, 234, 217, 16, 161, 185, 132, 175, 103, 25, 154, 153, 153, 36, 36, 26, 178, 150, 66, 45, 8, 185, 19, 90, 228, 210, 177, 30, 200, 177, 141, 78, 184, 248, 59, 113, 154, 145, 73, 160, 24, 73, 157, 86, 207, 186, 32, 95, 200, 106, 252, 107, 69, 170, 193, 216, 196, 181, 142, 74, 203, 15, 18, 89, 228, 152, 19, 239, 21, 233, 98, 121, 214, 57, 187, 111, 239, 223, 248, 199, 70, 223, 108, 108, 113, 234, 144, 155, 95, 246, 144, 244, 122, 39, 55, 127, 81, 2, 65, 0, 246, 96, 188, 0, 0, 104, 221, 105, 139, 144, 63, 175, 209, 87, 179, 162, 88, 192, 99, 82, 125, 53, 54, 48, 70, 245, 239, 37, 15, 242, 247, 84, 115, 187, 196, 95, 156, 40, 165, 60, 64, 102, 13, 229, 243, 2, 149, 0, 232, 226, 221, 192, 95, 11, 12, 208, 5, 181, 98, 62, 210, 190, 141, 235, 2, 65, 0, 204, 244, 34, 10, 105, 80, 76, 116, 163, 35, 231, 168, 187, 206, 189, 101, 215, 103, 80, 115, 86, 11, 34, 127, 203, 114, 84, 188, 121, 174, 169, 31, 142, 2, 182, 27, 140, 225, 157, 227, 71, 98, 15, 203, 187, 213, 5, 190, 20, 121, 8, 30, 193, 100, 232, 101, 141, 8, 124, 20, 29, 78, 6, 95, 2, 65, 0, 204, 43, 225, 224, 6, 118, 224, 117, 100, 200, 199, 94, 70, 23, 109, 175, 173, 232, 208, 230, 61, 8, 105, 189, 156, 48, 150, 91, 154, 89, 248, 136, 173, 215, 254, 166, 84, 220, 130, 1, 234, 68, 40, 100, 84, 251, 224, 202, 254, 51, 115, 28, 198, 38, 124, 25, 175, 129, 94, 199, 61, 17, 216, 189, 2, 64, 72, 230, 129, 129, 48, 138, 134, 87, 106, 123, 231, 247, 165, 173, 216, 194, 115, 198, 228, 223, 209, 120, 46, 114, 68, 92, 75, 117, 170, 214, 140, 131, 147, 208, 181, 19, 193, 157, 178, 186, 87, 246, 178, 101, 166, 79, 20, 54, 211, 51, 101, 199, 2, 197, 48, 192, 134, 84, 193, 69, 170, 82, 201, 131, 2, 65, 0, 213, 165, 55, 166, 131, 210, 195, 56, 250, 147, 195, 61, 205, 208, 189, 185, 40, 52, 50, 119, 137, 23, 246, 46, 220, 108, 52, 23, 152, 154, 94, 32, 144, 195, 184, 249, 21, 168, 12, 57, 222, 18, 60, 117, 81, 157, 72, 30, 155, 190, 165, 242, 228, 139, 240, 184, 145, 170, 103, 210, 160, 161, 135, 13]);
let keyPair = await genKeyPairByData(pkData, skData);
let pubKey = keyPair.pubKey;
let priKey = keyPair.priKey;
let message = 'This is a test';
// 把字符串按utf-8解码为Uint8Array
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = await encryptMessagePromise(pubKey, plainText);
let decryptText = await decryptMessagePromise(priKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
// 把Uint8Array按utf-8编码为字符串
let messageDecrypted = buffer.from(decryptText.data).toString('utf-8');
console.info('decrypted result string:' + messageDecrypted);
} else {
console.error('decrypt failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 加密消息
function encryptMessage(publicKey: cryptoFramework.PubKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('RSA1024|PKCS1');
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, publicKey, null);
let encryptData = cipher.doFinalSync(plainText);
return encryptData;
}
// 解密消息
function decryptMessage(privateKey: cryptoFramework.PriKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('RSA1024|PKCS1');
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, privateKey, null);
let decryptData = decoder.doFinalSync(cipherText);
return decryptData;
}
// 生成RSA密钥对
function genKeyPairByData(pubKeyData: Uint8Array, priKeyData: Uint8Array) {
let pubKeyBlob: cryptoFramework.DataBlob = { data: pubKeyData };
let priKeyBlob: cryptoFramework.DataBlob = { data: priKeyData };
let rsaGenerator = cryptoFramework.createAsyKeyGenerator('RSA1024');
let keyPair = rsaGenerator.convertKeySync(pubKeyBlob, priKeyBlob);
console.info('convertKeySync success');
return keyPair;
}
function main() {
let pkData = new Uint8Array([48, 129, 159, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0, 3, 129, 141, 0, 48, 129, 137, 2, 129, 129, 0, 197, 64, 10, 198, 14, 110, 65, 92, 206, 35, 28, 123, 153, 24, 134, 255, 145, 74, 42, 173, 40, 215, 146, 58, 143, 46, 10, 195, 154, 160, 69, 196, 220, 152, 179, 44, 111, 200, 84, 78, 215, 73, 210, 181, 12, 29, 70, 68, 36, 135, 153, 89, 230, 202, 130, 212, 111, 243, 234, 92, 131, 62, 145, 50, 73, 48, 104, 245, 46, 70, 45, 157, 147, 143, 140, 162, 156, 216, 220, 49, 121, 142, 194, 33, 223, 201, 0, 16, 163, 210, 240, 118, 92, 147, 121, 220, 17, 114, 24, 52, 125, 135, 176, 88, 21, 83, 86, 17, 156, 88, 250, 48, 79, 86, 128, 248, 105, 208, 133, 140, 13, 153, 164, 191, 136, 164, 44, 53, 2, 3, 1, 0, 1]);
let skData = new Uint8Array([48, 130, 2, 119, 2, 1, 0, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0, 4, 130, 2, 97, 48, 130, 2, 93, 2, 1, 0, 2, 129, 129, 0, 197, 64, 10, 198, 14, 110, 65, 92, 206, 35, 28, 123, 153, 24, 134, 255, 145, 74, 42, 173, 40, 215, 146, 58, 143, 46, 10, 195, 154, 160, 69, 196, 220, 152, 179, 44, 111, 200, 84, 78, 215, 73, 210, 181, 12, 29, 70, 68, 36, 135, 153, 89, 230, 202, 130, 212, 111, 243, 234, 92, 131, 62, 145, 50, 73, 48, 104, 245, 46, 70, 45, 157, 147, 143, 140, 162, 156, 216, 220, 49, 121, 142, 194, 33, 223, 201, 0, 16, 163, 210, 240, 118, 92, 147, 121, 220, 17, 114, 24, 52, 125, 135, 176, 88, 21, 83, 86, 17, 156, 88, 250, 48, 79, 86, 128, 248, 105, 208, 133, 140, 13, 153, 164, 191, 136, 164, 44, 53, 2, 3, 1, 0, 1, 2, 129, 128, 70, 75, 184, 139, 53, 1, 94, 17, 240, 244, 218, 101, 193, 253, 215, 190, 164, 204, 197, 192, 200, 89, 107, 39, 171, 119, 65, 38, 204, 168, 105, 180, 234, 217, 16, 161, 185, 132, 175, 103, 25, 154, 153, 153, 36, 36, 26, 178, 150, 66, 45, 8, 185, 19, 90, 228, 210, 177, 30, 200, 177, 141, 78, 184, 248, 59, 113, 154, 145, 73, 160, 24, 73, 157, 86, 207, 186, 32, 95, 200, 106, 252, 107, 69, 170, 193, 216, 196, 181, 142, 74, 203, 15, 18, 89, 228, 152, 19, 239, 21, 233, 98, 121, 214, 57, 187, 111, 239, 223, 248, 199, 70, 223, 108, 108, 113, 234, 144, 155, 95, 246, 144, 244, 122, 39, 55, 127, 81, 2, 65, 0, 246, 96, 188, 0, 0, 104, 221, 105, 139, 144, 63, 175, 209, 87, 179, 162, 88, 192, 99, 82, 125, 53, 54, 48, 70, 245, 239, 37, 15, 242, 247, 84, 115, 187, 196, 95, 156, 40, 165, 60, 64, 102, 13, 229, 243, 2, 149, 0, 232, 226, 221, 192, 95, 11, 12, 208, 5, 181, 98, 62, 210, 190, 141, 235, 2, 65, 0, 204, 244, 34, 10, 105, 80, 76, 116, 163, 35, 231, 168, 187, 206, 189, 101, 215, 103, 80, 115, 86, 11, 34, 127, 203, 114, 84, 188, 121, 174, 169, 31, 142, 2, 182, 27, 140, 225, 157, 227, 71, 98, 15, 203, 187, 213, 5, 190, 20, 121, 8, 30, 193, 100, 232, 101, 141, 8, 124, 20, 29, 78, 6, 95, 2, 65, 0, 204, 43, 225, 224, 6, 118, 224, 117, 100, 200, 199, 94, 70, 23, 109, 175, 173, 232, 208, 230, 61, 8, 105, 189, 156, 48, 150, 91, 154, 89, 248, 136, 173, 215, 254, 166, 84, 220, 130, 1, 234, 68, 40, 100, 84, 251, 224, 202, 254, 51, 115, 28, 198, 38, 124, 25, 175, 129, 94, 199, 61, 17, 216, 189, 2, 64, 72, 230, 129, 129, 48, 138, 134, 87, 106, 123, 231, 247, 165, 173, 216, 194, 115, 198, 228, 223, 209, 120, 46, 114, 68, 92, 75, 117, 170, 214, 140, 131, 147, 208, 181, 19, 193, 157, 178, 186, 87, 246, 178, 101, 166, 79, 20, 54, 211, 51, 101, 199, 2, 197, 48, 192, 134, 84, 193, 69, 170, 82, 201, 131, 2, 65, 0, 213, 165, 55, 166, 131, 210, 195, 56, 250, 147, 195, 61, 205, 208, 189, 185, 40, 52, 50, 119, 137, 23, 246, 46, 220, 108, 52, 23, 152, 154, 94, 32, 144, 195, 184, 249, 21, 168, 12, 57, 222, 18, 60, 117, 81, 157, 72, 30, 155, 190, 165, 242, 228, 139, 240, 184, 145, 170, 103, 210, 160, 161, 135, 13]);
let keyPair = genKeyPairByData(pkData, skData);
let pubKey = keyPair.pubKey;
let priKey = keyPair.priKey;
let message = 'This is a test';
// 把字符串按utf-8解码为Uint8Array
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = encryptMessage(pubKey, plainText);
let decryptText = decryptMessage(priKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
// 把Uint8Array按utf-8编码为字符串
let messageDecrypted = buffer.from(decryptText.data).toString('utf-8');
console.info('decrypted result string:' + messageDecrypted);
} else {
console.error('decrypt failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-rsa-asym-encrypt-decrypt-by-segment-V14
爬取时间: 2025-04-28 01:46:40
来源: Huawei Developer
对应的算法规格请查看非对称密钥加解密算法规格：RSA。
加密
1.  调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair，生成RSA密钥类型为RSA1024、素数个数为2（不填默认）的非对称密钥对（KeyPair）。KeyPair对象中包括公钥PubKey、私钥PriKey。 如何生成RSA非对称密钥对，开发者可参考下文示例，并结合非对称密钥生成和转换规格：RSA和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'RSA1024|PKCS1'，创建非对称密钥类型为RSA1024、填充模式为PKCS1的Cipher实例，用于完成加解密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（KeyPair.PubKey），初始化加密Cipher实例。
4.  多次调用Cipher.doFinal，传入明文，获取加密后的数据。 doFinal输出结果可能为null，在访问具体数据前，需要先判断结果是否为null，避免产生异常。 此处将明文按64个字节一组拆分，多次加密。使用1024位密钥，每次将生成128字节密文。
解密
1.  由于RSA算法的Cipher实例不支持重复init操作，需要调用cryptoFramework.createCipher，重新生成Cipher实例。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（KeyPair.PriKey）初始化解密Cipher实例。PKCS1模式无加密参数，直接传入null。
3.  多次调用Cipher.doFinal，传入密文，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 分段加密消息
async function rsaEncryptBySegment(pubKey: cryptoFramework.PubKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('RSA1024|PKCS1');
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, pubKey, null);
let plainTextSplitLen = 64;
let cipherText = new Uint8Array();
for (let i = 0; i < plainText.data.length; i += plainTextSplitLen ) {
let updateMessage = plainText.data.subarray(i, i + plainTextSplitLen );
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 将原文按64字符进行拆分，循环调用doFinal进行加密，使用1024bit密钥时，每次加密生成128字节长度的密文
let updateOutput = await cipher.doFinal(updateMessageBlob);
let mergeText = new Uint8Array(cipherText.length + updateOutput.data.length);
mergeText.set(cipherText);
mergeText.set(updateOutput.data, cipherText.length);
cipherText = mergeText;
}
let cipherBlob: cryptoFramework.DataBlob = { data: cipherText };
return cipherBlob;
}
// 分段解密消息
async function rsaDecryptBySegment(priKey: cryptoFramework.PriKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('RSA1024|PKCS1');
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, priKey, null);
let cipherTextSplitLen = 128; // RSA密钥每次加密生成的密文字节长度计算方式：密钥位数/8
let decryptText = new Uint8Array();
for (let i = 0; i < cipherText.data.length; i += cipherTextSplitLen) {
let updateMessage = cipherText.data.subarray(i, i + cipherTextSplitLen);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 将密文按128字节进行拆分解密，得到原文后进行拼接
let updateOutput = await decoder.doFinal(updateMessageBlob);
let mergeText = new Uint8Array(decryptText.length + updateOutput.data.length);
mergeText.set(decryptText);
mergeText.set(updateOutput.data, decryptText.length);
decryptText = mergeText;
}
let decryptBlob: cryptoFramework.DataBlob = { data: decryptText };
return decryptBlob;
}
async function rsaEncryptLongMessage() {
let message = "This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!";
let asyKeyGenerator = cryptoFramework.createAsyKeyGenerator("RSA1024"); // 创建非对称密钥生成器对象
let keyPair = await asyKeyGenerator.generateKeyPair(); // 随机生成RSA密钥
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = await rsaEncryptBySegment(keyPair.pubKey, plainText);
let decryptText = await rsaDecryptBySegment(keyPair.priKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 分段加密消息
function rsaEncryptBySegment(pubKey: cryptoFramework.PubKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('RSA1024|PKCS1');
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, pubKey, null);
let plainTextSplitLen = 64;
let cipherText = new Uint8Array();
for (let i = 0; i < plainText.data.length; i += plainTextSplitLen ) {
let updateMessage = plainText.data.subarray(i, i + plainTextSplitLen );
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 将原文按64字符进行拆分，循环调用doFinal进行加密，使用1024bit密钥时，每次加密生成128字节长度的密文
let updateOutput = cipher.doFinalSync(updateMessageBlob);
let mergeText = new Uint8Array(cipherText.length + updateOutput.data.length);
mergeText.set(cipherText);
mergeText.set(updateOutput.data, cipherText.length);
cipherText = mergeText;
}
let cipherBlob: cryptoFramework.DataBlob = { data: cipherText };
return cipherBlob;
}
// 分段解密消息
function rsaDecryptBySegment(priKey: cryptoFramework.PriKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('RSA1024|PKCS1');
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, priKey, null);
let cipherTextSplitLen = 128; // RSA密钥每次加密生成的密文字节长度计算方式：密钥位数/8
let decryptText = new Uint8Array();
for (let i = 0; i < cipherText.data.length; i += cipherTextSplitLen) {
let updateMessage = cipherText.data.subarray(i, i + cipherTextSplitLen);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 将密文按128字节进行拆分解密，得到原文后进行拼接
let updateOutput = decoder.doFinalSync(updateMessageBlob);
let mergeText = new Uint8Array(decryptText.length + updateOutput.data.length);
mergeText.set(decryptText);
mergeText.set(updateOutput.data, decryptText.length);
decryptText = mergeText;
}
let decryptBlob: cryptoFramework.DataBlob = { data: decryptText };
return decryptBlob;
}
function main() {
let message = "This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!";
let asyKeyGenerator = cryptoFramework.createAsyKeyGenerator("RSA1024"); // 创建非对称密钥生成器对象
let keyPair = asyKeyGenerator.generateKeyPairSync(); // 随机生成RSA密钥
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = rsaEncryptBySegment(keyPair.pubKey, plainText);
let decryptText = rsaDecryptBySegment(keyPair.priKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));
} else {
console.error('decrypt failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-rsa-asym-encrypt-decrypt-pkcs1_oaep-V14
爬取时间: 2025-04-28 01:46:54
来源: Huawei Developer
对应的算法规格请查看非对称密钥加解密算法规格：RSA。
加密
1.  调用cryptoFramework.createAsyKeyGeneratorBySpec、AsyKeyGeneratorBySpec.generateKeyPair，指定密钥参数，生成RSA非对称密钥对（KeyPair）。 如何生成RSA非对称密钥对，开发者可参考下文示例，并结合非对称密钥生成和转换规格：RSA和指定密钥参数生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'RSA2048|PKCS1_OAEP|SHA256|MGF1_SHA1'，创建非对称密钥类型为RSA2048、填充模式为PKCS1_OAEP、摘要算法为SHA256、掩码摘要为MGF1_SHA1的RSA密钥的Cipher实例，用于完成加解密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（KeyPair.PubKey），初始化加密Cipher实例。 非对称密钥无加密参数，直接传入null。
4.  在调用Cipher.doFinal前，调用Cipher.setCipherSpec设置PKCS1_OAEP填充参数pSource。调用Cipher.getCipherSpec可获得OAEP相关参数。
5.  调用Cipher.doFinal，传入明文，获取加密后的数据。
解密
1.  由于RSA算法的Cipher实例不支持重复init操作，需要调用cryptoFramework.createCipher，重新生成Cipher实例。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（KeyPair.PriKey）初始化解密Cipher实例。PKCS1模式无加密参数，直接传入null。
3.  在调用Cipher.doFinal前，调用Cipher.setCipherSpec设置PKCS1_OAEP填充参数pSource，此处需要和加密时设置的保持一致。调用Cipher.getCipherSpec可获得OAEP相关参数。
4.  调用Cipher.doFinal，传入密文，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 根据密钥参数属性构造RSA非对称密钥对密钥参数
function genRsaKeyPairSpec(nIn: bigint, eIn: bigint, dIn: bigint) {
let rsaCommSpec: cryptoFramework.RSACommonParamsSpec = {
n: nIn,
algName: "RSA",
specType: cryptoFramework.AsyKeySpecType.COMMON_PARAMS_SPEC
};
let rsaKeyPairSpec: cryptoFramework.RSAKeyPairSpec = {
params: rsaCommSpec,
sk: dIn,
pk: eIn,
algName: "RSA",
specType: cryptoFramework.AsyKeySpecType.KEY_PAIR_SPEC
};
return rsaKeyPairSpec;
}
// 生成RSA2048密钥对参数
function genRsa2048KeyPairSpec(): cryptoFramework.RSAKeyPairSpec {
let nIn = BigInt("0x9260d0750ae117eee55c3f3deaba74917521a262ee76007cdf8a56755ad73a1598a1408410a01434c3f5bc54a88b57fa19fc4328daea0750a4c44e88cff3b2382621b80f670464433e4336e6d003e8cd65bff211da144b88291c2259a00a72b711c116ef7686e8fee34e4d933c868187bdc26f7be071493c86f7a5941c3510806ad67b0f94d88f5cf5c02a092821d8626e8932b65c5bd8c92049c210932b7afa7ac59c0e886ae5c1edb00d8ce2c57633db26bd6639bff73cee82be9275c402b4cf2a4388da8cf8c64eefe1c5a0f5ab8057c39fa5c0589c3e253f0960332300f94bea44877b588e1edbde97cf2360727a09b775262d7ee552b3319b9266f05a25");
let eIn = BigInt("0x010001");
let dIn = BigInt("0x6a7df2ca63ead4dda191d614b6b385e0d9056a3d6d5cfe07db1daabee022db08212d97613d3328e0267c9dd23d787abde2afcb306aeb7dfce69246cc73f5c87fdf06030179a2114b767db1f083ff841c025d7dc00cd82435b9a90f695369e94df23d2ce458bc3b3283ad8bba2b8fa1ba62e2dce9accff3799aae7c840016f3ba8e0048c0b6cc4339af7161003a5beb864a0164b2c1c9237b64bc87556994351b27506c33d4bcdfce0f9c491a7d6b0628c7c852be4f0a9c3132b2ed3a2c8881e9aab07e20e17deb074691be677776a78b5c502e05d9bdde72126b3738695e2dd1a0a98a14247c65d8a7ee79432a092cb0721a12df798e44f7cfce0c498147a9b1");
return genRsaKeyPairSpec(nIn, eIn, dIn);
}
async function rsaUseSpecDecryptOAEPPromise() {
let plan = "This is a test";
// 获得RSA密钥对密钥参数对象
let rsaKeyPairSpec = genRsa2048KeyPairSpec();
// 根据RSA密钥对参数生成RSA密钥对
let rsaGeneratorSpec = cryptoFramework.createAsyKeyGeneratorBySpec(rsaKeyPairSpec);
let cipher = cryptoFramework.createCipher("RSA2048|PKCS1_OAEP|SHA256|MGF1_SHA1");
let decoder = cryptoFramework.createCipher("RSA2048|PKCS1_OAEP|SHA256|MGF1_SHA1");
// RSA加解密PKCS1-OAEP模式填充字节流P
let pSource = new Uint8Array([1, 2, 3, 4]); // 此处为示例，可以是任意值，由开发者自行决定
let input: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(plan, 'utf-8').buffer) };
// 生成密钥对
let keyPair = await rsaGeneratorSpec.generateKeyPair();
// 进行加密操作初始化
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, keyPair.pubKey, null);
// get和set操作可以放在Cipher对象init之后，此处对cipher进行set和get操作
cipher.setCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF1_PSRC_UINT8ARR, pSource);
let retP = cipher.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF1_PSRC_UINT8ARR);
// 比较get出来的P字节流与set进去的P字节流是否一致
if (retP.toString() !== pSource.toString()) {
console.error("error init pSource" + retP);
} else {
console.info("pSource changed ==" + retP);
}
// 进行OAEP其他参数的get操作
let md = cipher.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MD_NAME_STR);
console.info("md == " + md);
let mgf = cipher.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF_NAME_STR);
console.info("mgf == " + mgf);
let mgf1Md = cipher.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF1_MD_STR);
console.info("mgf1Md == " + mgf1Md);
let cipherDataBlob = await cipher.doFinal(input);
// get和set操作可以放在Cipher对象init之前，且与init之后等价，此处对decoder进行set和get操作
decoder.setCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF1_PSRC_UINT8ARR, pSource);
retP = decoder.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF1_PSRC_UINT8ARR);
// 比较get出来的P字节流与set进去的P字节流是否一致
if (retP.toString() !== pSource.toString()) {
console.error("error init pSource" + retP);
} else {
console.info("pSource changed ==" + retP);
}
// 进行OAEP其他参数的get操作
md = decoder.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MD_NAME_STR);
console.info("md == " + md);
mgf = decoder.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF_NAME_STR);
console.info("mgf == " + mgf);
mgf1Md = decoder.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF1_MD_STR);
console.info("mgf1Md == " + mgf1Md);
// 初始化解密操作
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, keyPair.priKey, null);
let decodeData = await decoder.doFinal(cipherDataBlob);
// 解密成功
if (decodeData.data.toString() === input.data.toString()) {
console.info("oaep decrypt success");
} else {
console.error("oaep decrypt fail");
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 根据密钥参数属性构造RSA非对称密钥对密钥参数
function genRsaKeyPairSpec(nIn: bigint, eIn: bigint, dIn: bigint) {
let rsaCommSpec: cryptoFramework.RSACommonParamsSpec = {
n: nIn,
algName: "RSA",
specType: cryptoFramework.AsyKeySpecType.COMMON_PARAMS_SPEC
};
let rsaKeyPairSpec: cryptoFramework.RSAKeyPairSpec = {
params: rsaCommSpec,
sk: dIn,
pk: eIn,
algName: "RSA",
specType: cryptoFramework.AsyKeySpecType.KEY_PAIR_SPEC
};
return rsaKeyPairSpec;
}
// 生成RSA2048密钥对参数
function genRsa2048KeyPairSpec(): cryptoFramework.RSAKeyPairSpec {
let nIn = BigInt("0x9260d0750ae117eee55c3f3deaba74917521a262ee76007cdf8a56755ad73a1598a1408410a01434c3f5bc54a88b57fa19fc4328daea0750a4c44e88cff3b2382621b80f670464433e4336e6d003e8cd65bff211da144b88291c2259a00a72b711c116ef7686e8fee34e4d933c868187bdc26f7be071493c86f7a5941c3510806ad67b0f94d88f5cf5c02a092821d8626e8932b65c5bd8c92049c210932b7afa7ac59c0e886ae5c1edb00d8ce2c57633db26bd6639bff73cee82be9275c402b4cf2a4388da8cf8c64eefe1c5a0f5ab8057c39fa5c0589c3e253f0960332300f94bea44877b588e1edbde97cf2360727a09b775262d7ee552b3319b9266f05a25");
let eIn = BigInt("0x010001");
let dIn = BigInt("0x6a7df2ca63ead4dda191d614b6b385e0d9056a3d6d5cfe07db1daabee022db08212d97613d3328e0267c9dd23d787abde2afcb306aeb7dfce69246cc73f5c87fdf06030179a2114b767db1f083ff841c025d7dc00cd82435b9a90f695369e94df23d2ce458bc3b3283ad8bba2b8fa1ba62e2dce9accff3799aae7c840016f3ba8e0048c0b6cc4339af7161003a5beb864a0164b2c1c9237b64bc87556994351b27506c33d4bcdfce0f9c491a7d6b0628c7c852be4f0a9c3132b2ed3a2c8881e9aab07e20e17deb074691be677776a78b5c502e05d9bdde72126b3738695e2dd1a0a98a14247c65d8a7ee79432a092cb0721a12df798e44f7cfce0c498147a9b1");
return genRsaKeyPairSpec(nIn, eIn, dIn);
}
function main() {
let plan = "This is a test";
// 获得RSA密钥对密钥参数对象
let rsaKeyPairSpec = genRsa2048KeyPairSpec();
// 根据RSA密钥对参数生成RSA密钥对
let rsaGeneratorSpec = cryptoFramework.createAsyKeyGeneratorBySpec(rsaKeyPairSpec);
let cipher = cryptoFramework.createCipher("RSA2048|PKCS1_OAEP|SHA256|MGF1_SHA1");
let decoder = cryptoFramework.createCipher("RSA2048|PKCS1_OAEP|SHA256|MGF1_SHA1");
// RSA加解密PKCS1-OAEP模式填充字节流P
let pSource = new Uint8Array([1, 2, 3, 4]); // 此处为示例，可以是任意值，由开发者自行决定
let input: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(plan, 'utf-8').buffer) };
// 生成密钥对
let keyPair = rsaGeneratorSpec.generateKeyPairSync();
// 进行加密操作初始化
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, keyPair.pubKey, null);
// get和set操作可以放在Cipher对象init之后，此处对cipher进行set和get操作
cipher.setCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF1_PSRC_UINT8ARR, pSource);
let retP = cipher.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF1_PSRC_UINT8ARR);
// 比较get出来的P字节流与set进去的P字节流是否一致
if (retP.toString() !== pSource.toString()) {
console.error("error init pSource" + retP);
} else {
console.info("pSource changed ==" + retP);
}
// 进行OAEP其他参数的get操作
let md = cipher.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MD_NAME_STR);
console.info("md == " + md);
let mgf = cipher.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF_NAME_STR);
console.info("mgf == " + mgf);
let mgf1Md = cipher.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF1_MD_STR);
console.info("mgf1Md == " + mgf1Md);
let cipherDataBlob = cipher.doFinalSync(input);
// get和set操作可以放在Cipher对象init之前，且与init之后等价，此处对decoder进行set和get操作
decoder.setCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF1_PSRC_UINT8ARR, pSource);
retP = decoder.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF1_PSRC_UINT8ARR);
// 比较get出来的P字节流与set进去的P字节流是否一致
if (retP.toString() !== pSource.toString()) {
console.error("error init pSource" + retP);
} else {
console.info("pSource changed ==" + retP);
}
// 进行OAEP其他参数的get操作
md = decoder.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MD_NAME_STR);
console.info("md == " + md);
mgf = decoder.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF_NAME_STR);
console.info("mgf == " + mgf);
mgf1Md = decoder.getCipherSpec(cryptoFramework.CipherSpecItem.OAEP_MGF1_MD_STR);
console.info("mgf1Md == " + mgf1Md);
// 初始化解密操作
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, keyPair.priKey, null);
let decodeData = decoder.doFinalSync(cipherDataBlob);
// 解密成功
if (decodeData.data.toString() === input.data.toString()) {
console.info("oaep decrypt success");
} else {
console.error("oaep decrypt fail");
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sm2-asym-encrypt-decrypt-V14
爬取时间: 2025-04-28 01:47:08
来源: Huawei Developer
对应的算法规格请查看非对称密钥加解密算法规格：SM2。
加密
1.  调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair，生成RSA密钥类型为SM2_256的非对称密钥对（KeyPair）。KeyPair对象中包括公钥PubKey、私钥PriKey。 如何生成SM2非对称密钥对，开发者可参考下文示例，并结合非对称密钥生成和转换规格：SM2和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createCipher，指定字符串参数'SM2_256|SM3'，创建非对称密钥类型为SM2_256、摘要算法为SM3的Cipher实例，用于完成加解密操作。
3.  调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（KeyPair.PubKey），初始化加密Cipher实例。 非对称密钥无加密参数，直接传入null。
4.  调用Cipher.doFinal，传入明文，获取加密后的数据。
解密
1.  由于SM2算法的Cipher实例不支持重复init操作，需要调用cryptoFramework.createCipher，重新生成Cipher实例。
2.  调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（KeyPair.PriKey）初始化解密Cipher实例。SM2无加密参数，直接传入null。
3.  调用Cipher.doFinal，传入密文，获取解密后的数据。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 加密消息
async function encryptMessagePromise(publicKey: cryptoFramework.PubKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('SM2_256|SM3');
await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, publicKey, null);
let encryptData = await cipher.doFinal(plainText);
return encryptData;
}
// 解密消息
async function decryptMessagePromise(privateKey: cryptoFramework.PriKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('SM2_256|SM3');
await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, privateKey, null);
let decryptData = await decoder.doFinal(cipherText);
return decryptData;
}
// 生成SM2密钥对
async function genKeyPairByData(pubKeyData: Uint8Array, priKeyData: Uint8Array) {
let pubKeyBlob: cryptoFramework.DataBlob = { data: pubKeyData };
let priKeyBlob: cryptoFramework.DataBlob = { data: priKeyData };
let sm2Generator = cryptoFramework.createAsyKeyGenerator('SM2_256');
let keyPair = await sm2Generator.convertKey(pubKeyBlob, priKeyBlob);
console.info('convertKey success');
return keyPair;
}
async function main() {
let pkData = new Uint8Array([48, 89, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 129, 28, 207, 85, 1, 130, 45, 3, 66, 0, 4, 90, 3, 58, 157, 190, 248, 76, 7, 132, 200, 151, 208, 112, 230, 96, 140, 90, 238, 211, 155, 128, 109, 248, 40, 83, 214, 78, 42, 104, 106, 55, 148, 249, 35, 61, 32, 221, 135, 143, 100, 45, 97, 194, 176, 52, 73, 136, 174, 40, 70, 70, 34, 103, 103, 161, 99, 27, 187, 13, 187, 109, 244, 13, 7]);
let skData = new Uint8Array([48, 49, 2, 1, 1, 4, 32, 54, 41, 239, 240, 63, 188, 134, 113, 31, 102, 149, 203, 245, 89, 15, 15, 47, 202, 170, 60, 38, 154, 28, 169, 189, 100, 251, 76, 112, 223, 156, 159, 160, 10, 6, 8, 42, 129, 28, 207, 85, 1, 130, 45]);
let keyPair = await genKeyPairByData(pkData, skData);
let pubKey = keyPair.pubKey;
let priKey = keyPair.priKey;
let message = 'This is a test';
// 把字符串按utf-8解码为Uint8Array
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = await encryptMessagePromise(pubKey, plainText);
let decryptText = await decryptMessagePromise(priKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
// 把Uint8Array按utf-8编码为字符串
let messageDecrypted = buffer.from(decryptText.data).toString('utf-8');
console.info('decrypted result string:' + messageDecrypted);
} else {
console.error('decrypt failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 加密消息
function encryptMessage(publicKey: cryptoFramework.PubKey, plainText: cryptoFramework.DataBlob) {
let cipher = cryptoFramework.createCipher('SM2_256|SM3');
cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, publicKey, null);
let encryptData = cipher.doFinalSync(plainText);
return encryptData;
}
// 解密消息
function decryptMessage(privateKey: cryptoFramework.PriKey, cipherText: cryptoFramework.DataBlob) {
let decoder = cryptoFramework.createCipher('SM2_256|SM3');
decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, privateKey, null);
let decryptData = decoder.doFinalSync(cipherText);
return decryptData;
}
// 生成SM2密钥对
function genKeyPairByData(pubKeyData: Uint8Array, priKeyData: Uint8Array) {
let pubKeyBlob: cryptoFramework.DataBlob = { data: pubKeyData };
let priKeyBlob: cryptoFramework.DataBlob = { data: priKeyData };
let sm2Generator = cryptoFramework.createAsyKeyGenerator('SM2_256');
let keyPair = sm2Generator.convertKeySync(pubKeyBlob, priKeyBlob);
console.info('convertKeySync success');
return keyPair;
}
function main() {
let pkData = new Uint8Array([48, 89, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 129, 28, 207, 85, 1, 130, 45, 3, 66, 0, 4, 90, 3, 58, 157, 190, 248, 76, 7, 132, 200, 151, 208, 112, 230, 96, 140, 90, 238, 211, 155, 128, 109, 248, 40, 83, 214, 78, 42, 104, 106, 55, 148, 249, 35, 61, 32, 221, 135, 143, 100, 45, 97, 194, 176, 52, 73, 136, 174, 40, 70, 70, 34, 103, 103, 161, 99, 27, 187, 13, 187, 109, 244, 13, 7]);
let skData = new Uint8Array([48, 49, 2, 1, 1, 4, 32, 54, 41, 239, 240, 63, 188, 134, 113, 31, 102, 149, 203, 245, 89, 15, 15, 47, 202, 170, 60, 38, 154, 28, 169, 189, 100, 251, 76, 112, 223, 156, 159, 160, 10, 6, 8, 42, 129, 28, 207, 85, 1, 130, 45]);
let keyPair = genKeyPairByData(pkData, skData);
let pubKey = keyPair.pubKey;
let priKey = keyPair.priKey;
let message = 'This is a test';
// 把字符串按utf-8解码为Uint8Array
let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };
let encryptText = encryptMessage(pubKey, plainText);
let decryptText = decryptMessage(priKey, encryptText);
if (plainText.data.toString() === decryptText.data.toString()) {
console.info('decrypt ok');
// 把Uint8Array按utf-8编码为字符串
let messageDecrypted = buffer.from(decryptText.data).toString('utf-8');
console.info('decrypted result string:' + messageDecrypted);
} else {
console.error('decrypt failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sm2-ciphertext-conversion-V14
爬取时间: 2025-04-28 01:47:21
来源: Huawei Developer
当前支持的SM2密文格式为国密标准的ASN.1格式，其中各参数组合顺序为C1C3C2，具体参数含义请参考转换SM2密文格式。
开发者可指定SM2密文的参数，将其转换成符合国密标准的ASN.1格式密文。反之，也可以从国密标准的ASN.1格式密文中取出具体的SM2密文参数，便于开发者自行组合成其他格式的SM2密文。
指定密文参数，生成标准ASN.1密文
1.  构造SM2CipherTextSpec对象，用于指定SM2密文参数。如果开发者使用的不是国密标准的ASN.1格式密文，需自行提取所需要的参数。
2.  调用genCipherTextBySpec，将SM2CipherTextSpec对象传入，生成符合国密标准的ASN.1格式的SM2密文。
3.  生成的密文可直接使用cryptoFramework进行SM2解密。
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function testGenCipherTextBySpec() {
let spec : cryptoFramework.SM2CipherTextSpec = {
xCoordinate: BigInt('20625015362595980457695435345498579729138244358573902431560627260141789922999'),
yCoordinate: BigInt('48563164792857017065725892921053777369510340820930241057309844352421738767712'),
cipherTextData: new Uint8Array([100, 227, 78, 195, 249, 179, 43, 70, 242, 69, 169, 10, 65, 123]),
hashData: new Uint8Array([87, 167, 167, 247, 88, 146, 203, 234, 83, 126, 117, 129, 52, 142, 82, 54, 152, 226, 201, 111, 143, 115, 169, 125, 128, 42, 157, 31, 114, 198, 109, 244]),
}
// 此处的data可直接使用cryptoFramework进行SM2解密
let data = cryptoFramework.SM2CryptoUtil.genCipherTextBySpec(spec, 'C1C3C2');
console.info('genCipherTextBySpec success');
}
```
从标准ASN.1密文中，获取密文参数
1.  准备符合国密标准的ASN.1格式的SM2密文。
2.  调用getCipherTextSpec，从标准密文中，获取具体的SM2密文参数。
3.  根据业务需要，自行拼接SM2密文参数，形成其他格式的SM2密文。
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function testGetCipherTextSpec() {
let cipherTextArray = new Uint8Array([48, 118, 2, 32, 45, 153, 88, 82, 104, 221, 226, 43, 174, 21, 122, 248, 5, 232, 105, 41, 92, 95, 102, 224, 216, 149, 85, 236, 110, 6, 64, 188, 149, 70, 70, 183, 2, 32, 107, 93, 198, 247, 119, 18, 40, 110, 90, 156, 193, 158, 205, 113, 170, 128, 146, 109, 75, 17, 181, 109, 110, 91, 149, 5, 110, 233, 209, 78, 229, 96, 4, 32, 87, 167, 167, 247, 88, 146, 203, 234, 83, 126, 117, 129, 52, 142, 82, 54, 152, 226, 201, 111, 143, 115, 169, 125, 128, 42, 157, 31, 114, 198, 109, 244, 4, 14, 100, 227, 78, 195, 249, 179, 43, 70, 242, 69, 169, 10, 65, 123]);
let cipherText : cryptoFramework.DataBlob = {data : cipherTextArray};
let spec : cryptoFramework.SM2CipherTextSpec = cryptoFramework.SM2CryptoUtil.getCipherTextSpec(cipherText, 'C1C3C2');
console.info('getCipherTextSpec success');
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sign-sig-verify-V14
爬取时间: 2025-04-28 01:47:35
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sign-sig-verify-overview-V14
爬取时间: 2025-04-28 01:47:48
来源: Huawei Developer
当需要判断接收的数据是否被篡改、数据是否为指定对象发送的数据时，可以使用签名验签操作。
接下来将说明系统目前支持的算法及其对应的规格。
当前使用C/C++的方式开发只支持验签，不支持签名。
RSA
算法库框架目前提供了两种RSA签名验签的填充模式：
-  PKCS1：即RFC3447规范中的RSAES-PKCS1-V1_5模式，对应OpenSSL中的RSA_PKCS1_PADDING。 使用该模式时需要设置摘要（md），摘要算法输出的长度需要小于RSA密钥长度。例如RSA2048的密钥字节长度为256。
-  PSS： 即RFC3447规范中的RSASSA-PSS模式，对应OpenSSL中的RSA_PKCS1_PSS_PADDING。 使用该模式时需要设置两个摘要（md和mgf1_md），且md和mgf1_md长度之和需要小于RSA的密钥长度。例如RSA2048的密钥字节长度为256。 此模式还可额外设置盐长度saltLen，并用于获取PSS的相关参数。（单位：字节）
| PSS的相关参数 | 说明 |
| --- | --- |
| md | 摘要算法。 |
| mgf | 掩码生成算法，目前仅支持MGF1。 |
| mgf1_md | MGF1算法中使用的摘要算法。 |
| saltLen | 盐长度。（单位：字节） |
| trailer_field | 用于编码操作的整数，只支持为1。 |
使用同步接口生成RSA2048、RSA3072、RSA4096、RSA8192非对称密钥或者明文长度超过2048会导致耗时增加。
由于系统对主线程有时间限制，耗时较长会导致失败，建议开发者在生成位数较大的密钥时，使用对应的异步接口，或是使用多线程并发能力进行开发。
填充模式为PKCS1
以字符串参数完成RSA签名验签，具体的“字符串参数”由“非对称密钥类型”、“填充模式 PKCS1”和“摘要”使用符号“|”拼接而成，用于在创建非对称签名验签实例时，指定非对称签名验签算法规格。
如表所示，各取值范围（即[]中的内容）中，只能选取一项完成字符串拼接。举例说明，当需要非对称密钥类型为RSA512、填充模式为PKCS1、摘要算法为MD5的密钥时，其字符串参数为"RSA512|PKCS1|MD5"。
RSA签名验签时，摘要算法输出的长度，需要小于RSA的密钥长度。如RSA密钥为512位时，不支持SHA512。
| 非对称密钥类型 | 填充模式 | 摘要算法 | API版本 |
| --- | --- | --- | --- |
| RSA512 | PKCS1 | [MD5|SHA1|SHA224|SHA256] | 9+ |
| RSA768 | PKCS1 | [MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | 9+ |
| RSA1024 | PKCS1 | [MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | 9+ |
| RSA2048 | PKCS1 | [MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | 9+ |
| RSA3072 | PKCS1 | [MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | 9+ |
| RSA4096 | PKCS1 | [MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | 9+ |
| RSA8192 | PKCS1 | [MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | 9+ |
| RSA | PKCS1 | 符合长度要求的摘要算法 | 10+ |
如表中最后一行所示，为了兼容由密钥参数生成的密钥，RSA签名验签参数输入密钥类型时支持不带长度，签名验签运算取决于实际输入的密钥长度。
填充模式为PSS
以字符串参数完成RSA签名验签，具体的“字符串参数”由“非对称密钥类型”、“填充模式 PSS”、“摘要”和“掩码摘要”使用符号“|”拼接而成，用于在创建非对称签名验签实例时，指定非对称签名验签算法规格。
如表所示，各取值范围（即[]中的内容）中，只能选取一项完成字符串拼接。举例说明，当需要非对称密钥类型为RSA2048、填充模式为PSS、摘要算法为SHA256、掩码摘要为MGF1_SHA256的密钥时，其字符串参数为"RSA2048|PSS|SHA256|MGF1_SHA256"。
RSA签名验签时，对于PSS模式，md和mgf1_md长度之和需要小于RSA的密钥长度。如RSA密钥为512位时，无法支持md和mgf1_md同时为SHA256。
| 非对称密钥类型 | 填充模式 | 摘要 | 掩码摘要 | API版本 |
| --- | --- | --- | --- | --- |
| RSA512 | PSS | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256] | 9+ |
| RSA512 | PSS | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256] | 9+ |
| RSA512 | PSS | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256] | 9+ |
| RSA512 | PSS | SHA256 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224] | 9+ |
| RSA768 | PSS | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA768 | PSS | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA768 | PSS | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA768 | PSS | SHA256 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384] | 9+ |
| RSA768 | PSS | SHA384 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256] | 9+ |
| RSA768 | PSS | SHA512 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224] | 9+ |
| RSA1024 | PSS | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA1024 | PSS | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA1024 | PSS | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA1024 | PSS | SHA256 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA1024 | PSS | SHA384 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA1024 | PSS | SHA512 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384] | 9+ |
| RSA2048 | PSS | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA2048 | PSS | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA2048 | PSS | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA2048 | PSS | SHA256 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA2048 | PSS | SHA384 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA2048 | PSS | SHA512 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA3072 | PSS | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA3072 | PSS | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA3072 | PSS | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA3072 | PSS | SHA256 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA3072 | PSS | SHA384 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA3072 | PSS | SHA512 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA4096 | PSS | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA4096 | PSS | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA4096 | PSS | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA4096 | PSS | SHA256 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA4096 | PSS | SHA384 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA4096 | PSS | SHA512 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA8192 | PSS | MD5 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA8192 | PSS | SHA1 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA8192 | PSS | SHA224 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA8192 | PSS | SHA256 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA8192 | PSS | SHA384 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA8192 | PSS | SHA512 | [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512] | 9+ |
| RSA | PSS | 符合长度要求的摘要算法 | MGF1_符合长度要求的摘要算法 | 10+ |
如表中最后一行所示，为了兼容由密钥参数生成的密钥，RSA签名验签参数输入密钥类型时支持不带长度，签名验签运算取决于实际输入的密钥长度。
获取/设置PSS填充模式的参数
当前支持RSA使用PSS填充模式时，获取、设置相关参数，“√”表示支持对获取或设置该参数。
| PSS参数 | 枚举值 | 获取 | 设置 |
| --- | --- | --- | --- |
| md | PSS_MD_NAME_STR | √ | - |
| mgf | PSS_MGF_NAME_STR | √ | - |
| mgf1_md | PSS_MGF1_MD_STR | √ | - |
| saltLen | PSS_SALT_LEN_NUM | √ | √ |
| trailer_field | PSS_TRAILER_FIELD_NUM | √ | - |
签名模式为OnlySign
算法库框架目前提供了RSA签名不做摘要仅签名功能。
以字符串参数完成RSA签名，具体的“字符串参数”由“非对称密钥类型”、“填充模式”、“摘要”和“签名模式”使用符号“|”拼接而成，用于在创建非对称签名实例时，指定非对称签名算法规格。
如表所示，各取值范围（即[]中的内容）中，只能选取一项完成字符串拼接。举例说明，当需要非对称密钥类型为RSA2048、填充模式为PKCS1、摘要算法为SHA256、签名模式为OnlySign的密钥时，其字符串参数为"RSA2048|PKCS1|SHA256|OnlySign"。
RSA仅签名时，对待签名数据有长度要求：
| 非对称密钥类型 | 填充模式 | 摘要算法 | 签名模式 | API版本 |
| --- | --- | --- | --- | --- |
| RSA512 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256] | OnlySign | 12+ |
| RSA768 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | OnlySign | 12+ |
| RSA1024 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | OnlySign | 12+ |
| RSA2048 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | OnlySign | 12+ |
| RSA3072 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | OnlySign | 12+ |
| RSA4096 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | OnlySign | 12+ |
| RSA8192 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | OnlySign | 12+ |
| [RSA512|RSA768|RSA1024|RSA2048|RSA3072|RSA4096|RSA8192|RSA] | NoPadding | NoHash | OnlySign | 12+ |
| RSA | PKCS1 | 符合长度要求的摘要算法 | OnlySign | 12+ |
如表中最后一行所示，为了兼容由密钥参数生成的密钥，RSA签名参数输入密钥类型时支持不带长度，签名运算取决于实际输入的密钥长度。
验签模式为Recover
算法库框架目前提供了RSA签名恢复原始数据功能。
以字符串参数完成RSA签名恢复，具体的“字符串参数”由“非对称密钥类型”、“填充模式”、“摘要”和“验签模式”使用符号“|”拼接而成，用于在创建非对称验签实例时，指定非对称验签算法规格。
如表所示，各取值范围（即[]中的内容）中，只能选取一项完成字符串拼接。举例说明，当需要非对称密钥类型为RSA2048、填充模式为PKCS1、摘要算法为SHA256、验签模式为Recover的密钥时，其字符串参数为"RSA2048|PKCS1|SHA256|Recover"。
| 非对称密钥类型 | 填充模式 | 摘要算法 | 签名模式 | API版本 |
| --- | --- | --- | --- | --- |
| RSA512 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256] | Recover | 12+ |
| RSA768 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | Recover | 12+ |
| RSA1024 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | Recover | 12+ |
| RSA2048 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | Recover | 12+ |
| RSA3072 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | Recover | 12+ |
| RSA4096 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | Recover | 12+ |
| RSA8192 | PKCS1 | [NoHash|MD5|SHA1|SHA224|SHA256|SHA384|SHA512] | Recover | 12+ |
| [RSA512|RSA768|RSA1024|RSA2048|RSA3072|RSA4096|RSA8192|RSA] | NoPadding | NoHash | Recover | 12+ |
| RSA | PKCS1 | 符合长度要求的摘要算法 | Recover | 12+ |
如表中最后一行所示，为了兼容由密钥参数生成的密钥，RSA签名恢复参数输入密钥类型时支持不带长度，签名恢复运算取决于实际输入的密钥长度。
ECDSA
ECDSA（Elliptic Curve Digital Signature Algorithm，椭圆曲线数字签名算法）是基于椭圆曲线密码（ECC）的数字签名算法（DSA）。相比DLP（Discrete logarithm Problem，普通的离散对数问题）和IFP（integer factorization problem，大数分解问题），椭圆曲线密码的单位比特强度要高于其他公钥体制。
算法库框架提供了多种椭圆曲线及摘要算法组合的ECDSA签名验签能力。
以字符串参数完成ECDSA签名验签，具体的“字符串参数”由“非对称密钥类型”和“摘要”使用符号“|”拼接而成，用于在创建非对称签名验签实例时，指定非对称签名验签算法规格。
如表所示，各取值范围（即[]中的内容）中，只能选取一项完成字符串拼接。举例说明，当需要非对称密钥类型为ECC224、摘要算法为SHA256的密钥时，其字符串参数为"ECC224|SHA256"。
| 非对称密钥类型 | 摘要 | API版本 |
| --- | --- | --- |
| ECC224 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 9+ |
| ECC256 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 9+ |
| ECC384 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 9+ |
| ECC521 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 9+ |
| ECC_BrainPoolP160r1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_BrainPoolP160t1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_BrainPoolP192r1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_BrainPoolP192t1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_BrainPoolP224r1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_BrainPoolP224t1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_BrainPoolP256r1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_BrainPoolP256t1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_BrainPoolP320r1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_BrainPoolP320t1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_BrainPoolP384r1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_BrainPoolP384t1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_BrainPoolP512r1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_BrainPoolP512t1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 11+ |
| ECC_Secp256k1 | [SHA1|SHA224|SHA256|SHA384|SHA512] | 14+ |
| ECC | [SHA1|SHA224|SHA256|SHA384|SHA512] | 10+ |
如表中最后一行所示，为了兼容由密钥参数生成的密钥，ECDSA签名验签参数输入密钥类型时支持不指定长度和曲线，签名验签运算取决于实际输入的密钥。
DSA
DSA（Digital Signature Algorithm，数字签名算法）的安全性基于整数有限域离散对数问题的困难性，具有较好的兼容性和适用性。
以字符串参数完成DSA签名验签，具体的“字符串参数”由“非对称密钥类型”和“摘要”使用符号“|”拼接而成，用于在创建非对称签名验签实例时，指定非对称签名验签算法规格。
如表所示，各取值范围（即[]中的内容）中，只能选取一项完成字符串拼接。举例说明，当需要非对称密钥类型为DSA1024、摘要算法为SHA256的密钥时，其字符串参数为"DSA1024|SHA256"。
| 非对称密钥类型 | 摘要 | API版本 |
| --- | --- | --- |
| DSA1024 | [NoHash|SHA1|SHA224|SHA256|SHA384|SHA512] | 10+ |
| DSA2048 | [NoHash|SHA1|SHA224|SHA256|SHA384|SHA512] | 10+ |
| DSA3072 | [NoHash|SHA1|SHA224|SHA256|SHA384|SHA512] | 10+ |
| DSA | [NoHash|SHA1|SHA224|SHA256|SHA384|SHA512] | 10+ |
如表中最后一行所示，为了兼容由密钥参数生成的密钥，DSA签名验签参数输入密钥类型时支持不带长度，签名验签运算取决于实际输入的密钥长度。
当使用DSA算法并设置摘要算法为NoHash时，则不支持分段签名或分段验签。
SM2
SM2数字签名算法，是基于椭圆曲线的签名验签算法。
以字符串参数完成SM2签名验签，具体的“字符串参数”由“非对称密钥类型”和“摘要”使用符号“|”拼接而成，用于在创建非对称签名验签实例时，指定非对称签名验签算法规格。
当前SM2签名只支持SM3摘要。
| 非对称密钥类型 | 摘要 | 字符串参数 | API版本 |
| --- | --- | --- | --- |
| SM2_256 | SM3 | SM2_256|SM3 | 10+ |
| SM2 | SM3 | SM2|SM3 | 10+ |
如表中最后一行所示，为了兼容由密钥参数生成的密钥，SM2签名验签参数输入密钥类型时支持不带长度，签名验签运算取决于实际输入的密钥长度。
Ed25519
Ed25519是基于椭圆曲线的签名验签算法。
以字符串参数完成Ed25519签名验签，用于在创建非对称签名验签实例时，指定非对称签名验签算法规格。
| 非对称密钥类型 | 字符串参数 | API版本 |
| --- | --- | --- |
| Ed25519 | Ed25519 | 11+ |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sign-sig-verify-dev-V14
爬取时间: 2025-04-28 01:48:02
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-rsa-sign-sig-verify-pkcs1-V14
爬取时间: 2025-04-28 01:48:15
来源: Huawei Developer
对应的算法规格请查看签名验签算法规格：RSA。
签名
1.  调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair，生成密钥算法为RSA、密钥长度为1024位、素数个数为2的非对称密钥对象（KeyPair），包括公钥（PubKey）和私钥（PriKey）。 如何生成RSA非对称密钥，开发者可参考下文示例，并结合非对称密钥生成和转换规格：RSA和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createSign，指定字符串参数'RSA1024|PKCS1|SHA256'，创建非对称密钥类型为RSA1024、填充模式为PKCS1、摘要算法为SHA256的Sign实例，用于完成签名操作。
3.  调用Sign.init，使用私钥（PriKey）初始化Sign实例。
4.  调用Sign.update，传入待签名的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
5.  调用Sign.sign，生成数据签名。
验签
1.  调用cryptoFramework.createVerify，指定字符串参数'RSA1024|PKCS1|SHA256'，与签名的Sign实例保持一致。创建Verify实例，用于完成验签操作。
2.  调用Verify.init，使用公钥（PubKey）初始化Verify实例。
3.  调用Verify.update，传入待验证的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
4.  调用Verify.verify，对数据进行验签。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 完整的明文被拆分为input1和input2
let input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan1", 'utf-8').buffer) };
let input2: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan2", 'utf-8').buffer) };
async function signMessagePromise(priKey: cryptoFramework.PriKey) {
let signAlg = "RSA1024|PKCS1|SHA256";
let signer = cryptoFramework.createSign(signAlg);
await signer.init(priKey);
await signer.update(input1); // 如果明文较短，可以直接调用sign接口一次性传入
let signData = await signer.sign(input2);
return signData;
}
async function verifyMessagePromise(signMessageBlob: cryptoFramework.DataBlob, pubKey: cryptoFramework.PubKey) {
let verifyAlg = "RSA1024|PKCS1|SHA256";
let verifier = cryptoFramework.createVerify(verifyAlg);
await verifier.init(pubKey);
await verifier.update(input1); // 如果明文较短，可以直接调用verify接口一次性传入
let res = await verifier.verify(input2, signMessageBlob);
console.info("verify result is " + res);
return res;
}
async function main() {
let keyGenAlg = "RSA1024";
let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);
let keyPair = await generator.generateKeyPair();
let signData = await signMessagePromise(keyPair.priKey);
let verifyResult = await verifyMessagePromise(signData, keyPair.pubKey);
if (verifyResult === true) {
console.info('verify success');
} else {
console.error('verify failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 完整的明文被拆分为input1和input2
let input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan1", 'utf-8').buffer) };
let input2: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan2", 'utf-8').buffer) };
function signMessagePromise(priKey: cryptoFramework.PriKey) {
let signAlg = "RSA1024|PKCS1|SHA256";
let signer = cryptoFramework.createSign(signAlg);
signer.initSync(priKey);
signer.updateSync(input1); // 如果明文较短，可以直接调用sign接口一次性传入
let signData = signer.signSync(input2);
return signData;
}
function verifyMessagePromise(signMessageBlob: cryptoFramework.DataBlob, pubKey: cryptoFramework.PubKey) {
let verifyAlg = "RSA1024|PKCS1|SHA256";
let verifier = cryptoFramework.createVerify(verifyAlg);
verifier.initSync(pubKey);
verifier.updateSync(input1); // 如果明文较短，可以直接调用verify接口一次性传入
let res = verifier.verifySync(input2, signMessageBlob);
console.info("verify result is " + res);
return res;
}
function main() {
let keyGenAlg = "RSA1024";
let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);
let keyPair = generator.generateKeyPairSync();
let signData = signMessagePromise(keyPair.priKey);
let verifyResult = verifyMessagePromise(signData, keyPair.pubKey);
if (verifyResult === true) {
console.info('verify success');
} else {
console.error('verify failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-rsa-sign-sig-verify-pkcs1-ndk-V14
爬取时间: 2025-04-28 01:48:29
来源: Huawei Developer
对应的算法规格请查看验签算法规格：RSA。
在CMake脚本中链接相关动态库
开发步骤
1.  调用OH_CryptoVerify_Create，指定字符串参数'RSA1024|PKCS1|SHA256'，与签名的Sign实例保持一致。创建Verify实例，用于完成验签操作。
2.  调用OH_CryptoVerify_Init，使用公钥（OH_CryptoPubKey）初始化Verify实例。
3.  调用OH_CryptoVerify_Update，传入待验证的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update，如果数据量较小，可以直接调用OH_CryptoVerify_Final接口一次性传入。
4.  调用OH_CryptoVerify_Final，对数据进行验签。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-rsa-sign-sig-verify-recover-pkcs1-V14
爬取时间: 2025-04-28 01:48:42
来源: Huawei Developer
对应的算法规格请查看签名验签算法规格：RSA。
签名
1.  调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair，生成密钥算法为RSA、密钥长度为1024位、素数个数为2的非对称密钥对象（KeyPair），包括公钥（PubKey）和私钥（PriKey）。 如何生成RSA非对称密钥，开发者可参考下文示例，并结合非对称密钥生成和转换规格：RSA和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createSign，指定字符串参数'RSA1024|PKCS1|SHA256|SignOnly'，创建非对称密钥类型为RSA1024、填充模式为PKCS1、摘要算法为SHA256的Sign实例，用于完成仅签名操作。
3.  调用Sign.init，使用私钥（PriKey）初始化Sign实例。
4.  调用Sign.sign，生成数据签名。
验签
1.  调用cryptoFramework.createVerify，指定字符串参数'RSA1024|PKCS1|SHA256|Recover'，与签名的Sign实例保持一致。创建Verify实例，用于完成验签操作。
2.  调用Verify.init，使用公钥（PubKey）初始化Verify实例。
3.  调用Verify.recover，对数据进行签名恢复。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 完整的明文被拆分为input1和input2
let input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan1", 'utf-8').buffer) };
async function signMessagePromise(priKey: cryptoFramework.PriKey) {
let signAlg = "RSA1024|PKCS1|NoHash|OnlySign";
let signer = cryptoFramework.createSign(signAlg);
await signer.init(priKey);
let signData = await signer.sign(input1);
return signData;
}
async function verifyMessagePromise(signMessageBlob: cryptoFramework.DataBlob, pubKey: cryptoFramework.PubKey) {
let verifyAlg = "RSA1024|PKCS1|NoHash|Recover";
let verifier = cryptoFramework.createVerify(verifyAlg);
await verifier.init(pubKey);
let rawSignData = await verifier.recover(signMessageBlob);
return rawSignData;
}
async function main() {
let keyGenAlg = "RSA1024";
let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);
let keyPair = await generator.generateKeyPair();
let signData = await signMessagePromise(keyPair.priKey);
let rawSignData = await verifyMessagePromise(signData, keyPair.pubKey);
if (rawSignData !== null) {
console.info('recover result: ' + rawSignData.data);
} else {
console.error("get verify recover result fail!");
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 完整的明文被拆分为input1和input2
let input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan1", 'utf-8').buffer) };
function signMessagePromise(priKey: cryptoFramework.PriKey) {
let signAlg = "RSA1024|PKCS1|NoHash|OnlySign";
let signer = cryptoFramework.createSign(signAlg);
signer.initSync(priKey);
let signData = signer.signSync(input1);
return signData;
}
function verifyMessagePromise(signMessageBlob: cryptoFramework.DataBlob, pubKey: cryptoFramework.PubKey) {
let verifyAlg = "RSA1024|PKCS1|NoHash|Recover";
let verifier = cryptoFramework.createVerify(verifyAlg);
verifier.initSync(pubKey);
let rawSignData = verifier.recoverSync(signMessageBlob);
return rawSignData;
}
function main() {
let keyGenAlg = "RSA1024";
let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);
let keyPair = generator.generateKeyPairSync();
let signData = signMessagePromise(keyPair.priKey);
let rawSignData = verifyMessagePromise(signData, keyPair.pubKey);
if (rawSignData !== null) {
console.info('recover result: ' + rawSignData.data);
} else {
console.error("get verify recover result fail!");
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-rsa-sign-sig-verify-recover-pkcs1-ndk-V14
爬取时间: 2025-04-28 01:48:56
来源: Huawei Developer
对应的算法规格请查看验签算法规格：RSA。
在CMake脚本中链接相关动态库
开发步骤
1.  调用OH_CryptoVerify_Create，指定字符串参数'RSA1024|PKCS1|SHA256|Recover'，与签名的Sign实例保持一致。创建Verify实例，用于完成验签操作。
2.  调用OH_CryptoVerify_Init，使用公钥（OH_CryptoPubKey）初始化Verify实例。
3.  调用OH_CryptoVerify_Recover，对数据进行签名恢复。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-rsa-sign-sig-verify-pkcs1-by-segment-V14
爬取时间: 2025-04-28 01:49:09
来源: Huawei Developer
对应的算法规格请查看签名验签算法规格：RSA。
签名
1.  调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair，生成密钥算法为RSA、密钥长度为1024位、素数个数为2的非对称密钥对象（KeyPair），包括公钥（PubKey）和私钥（PriKey）。 如何生成RSA非对称密钥，开发者可参考下文示例，并结合非对称密钥生成和转换规格：RSA和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createSign，指定字符串参数'RSA1024|PKCS1|SHA256'，创建非对称密钥类型为RSA1024、填充模式为PKCS1、摘要算法为SHA256的Sign实例，用于完成签名操作。
3.  调用Sign.init，使用私钥（PriKey）初始化Sign实例。
4.  将一次传入数据量设置为64字节，多次调用Sign.update，传入待签名的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
5.  调用Sign.sign，生成数据签名。
验签
1.  调用cryptoFramework.createVerify，指定字符串参数'RSA1024|PKCS1|SHA256'，与签名的Sign实例保持一致。创建Verify实例，用于完成验签操作。
2.  调用Verify.init，使用公钥（PubKey）初始化Verify实例。
3.  调用Verify.update，传入待验证的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
4.  调用Verify.verify，对数据进行验签。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
async function signMessageBySegment(priKey: cryptoFramework.PriKey, plainText: Uint8Array) {
let signAlg = "RSA1024|PKCS1|SHA256";
let signer = cryptoFramework.createSign(signAlg);
await signer.init(priKey);
let textSplitLen = 64; // 自定义的数据拆分长度，此处取64
for (let i = 0; i < plainText.length; i += textSplitLen) {
let updateMessage = plainText.subarray(i, i + textSplitLen);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 分段update
await signer.update(updateMessageBlob);
}
// 已通过分段传入所有明文，故此处sign传入null
let signData = await signer.sign(null);
return signData;
}
async function verifyMessagBySegment(pubKey: cryptoFramework.PubKey, plainText: Uint8Array, signMessageBlob: cryptoFramework.DataBlob) {
let verifyAlg = "RSA1024|PKCS1|SHA256";
let verifier = cryptoFramework.createVerify(verifyAlg);
await verifier.init(pubKey);
let textSplitLen = 64; // 自定义的数据拆分长度，此处取64
for (let i = 0; i < plainText.length; i += textSplitLen) {
let updateMessage = plainText.subarray(i, i + textSplitLen);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 分段update
await verifier.update(updateMessageBlob);
}
// 已通过分段传入所有明文，故此处verify第一个参数传入null
let res = await verifier.verify(null, signMessageBlob);
console.info("verify result is " + res);
return res;
}
async function rsaSignatureBySegment() {
let message = "This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!";
let keyGenAlg = "RSA1024";
let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);
let keyPair = await generator.generateKeyPair();
let messageData = new Uint8Array(buffer.from(message, 'utf-8').buffer);
let signData = await signMessageBySegment(keyPair.priKey, messageData);
let verifyResult = await verifyMessagBySegment(keyPair.pubKey, messageData, signData);
if (verifyResult === true) {
console.info('verify success');
} else {
console.error('verify failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function signMessageBySegment(priKey: cryptoFramework.PriKey, plainText: Uint8Array) {
let signAlg = "RSA1024|PKCS1|SHA256";
let signer = cryptoFramework.createSign(signAlg);
signer.initSync(priKey);
let textSplitLen = 64; // 自定义的数据拆分长度，此处取64
for (let i = 0; i < plainText.length; i += textSplitLen) {
let updateMessage = plainText.subarray(i, i + textSplitLen);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 分段update
signer.updateSync(updateMessageBlob);
}
// 已通过分段传入所有明文，故此处sign传入null
let signData = signer.signSync(null);
return signData;
}
function verifyMessagBySegment(pubKey: cryptoFramework.PubKey, plainText: Uint8Array, signMessageBlob: cryptoFramework.DataBlob) {
let verifyAlg = "RSA1024|PKCS1|SHA256";
let verifier = cryptoFramework.createVerify(verifyAlg);
verifier.initSync(pubKey);
let textSplitLen = 64; // 自定义的数据拆分长度，此处取64
for (let i = 0; i < plainText.length; i += textSplitLen) {
let updateMessage = plainText.subarray(i, i + textSplitLen);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
// 分段update
verifier.updateSync(updateMessageBlob);
}
// 已通过分段传入所有明文，故此处verify第一个参数传入null
let res = verifier.verifySync(null, signMessageBlob);
console.info("verify result is " + res);
return res;
}
function rsaSignatureBySegment() {
let message = "This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +
"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!";
let keyGenAlg = "RSA1024";
let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);
let keyPair = generator.generateKeyPairSync();
let messageData = new Uint8Array(buffer.from(message, 'utf-8').buffer);
let signData = signMessageBySegment(keyPair.priKey, messageData);
let verifyResult = verifyMessagBySegment(keyPair.pubKey, messageData, signData);
if (verifyResult === true) {
console.info('verify success');
} else {
console.error('verify failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-rsa-sign-sig-verify-pkcs1-by-segment-ndk-V14
爬取时间: 2025-04-28 01:49:23
来源: Huawei Developer
对应的算法规格请查看验签算法规格：RSA。
在CMake脚本中链接相关动态库
开发步骤
1.  调用OH_CryptoVerify_Create，指定字符串参数'RSA1024|PKCS1|SHA256'，与签名的Sign实例保持一致。创建Verify实例，用于完成验签操作。
2.  调用OH_CryptoVerify_Init，使用公钥（OH_CryptoPubKey）初始化Verify实例。
3.  调用OH_CryptoVerify_Update，传入待验证的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update，如果数据量较小，可以直接调用OH_CryptoVerify_Final接口一次性传入。
4.  调用OH_CryptoVerify_Final，对数据进行验签。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-rsa-sign-sig-verify-pss-V14
爬取时间: 2025-04-28 01:49:37
来源: Huawei Developer
对应的算法规格请查看签名验签算法规格：RSA。
签名
1.  调用cryptoFramework.createAsyKeyGeneratorBySpec、AsyKeyGeneratorBySpec.generateKeyPair，指定密钥参数，生成RSA非对称密钥对（KeyPair）。 如何生成RSA非对称密钥，开发者可参考下文示例，并结合非对称密钥生成和转换规格：RSA和指定密钥参数生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createSign，指定字符串参数'RSA|PSS|SHA256|MGF1_SHA256'，创建非对称密钥类型为不带长度的RSA、填充模式为PSS、摘要算法为SHA256、掩码算法为MGF1_SHA256的Sign实例，用于完成签名操作。
3.  调用Sign.init，使用私钥（PriKey）初始化Sign实例。
4.  调用Sign.setSignSpec，设置签名参数。此处设置盐值的长度（SignSpecItem.PSS_SALT_LEN_NUM）为32字节。在验签时将校验此数据。
5.  调用Sign.getSignSpec，获取其他签名参数。
6.  调用Sign.update，传入待签名的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
7.  调用Sign.sign，生成数据签名。
验签
1.  调用cryptoFramework.createVerify，指定字符串参数'RSA2048|PSS|SHA256|MGF1_SHA256'，创建非对称密钥类型为RSA2048、填充模式为PSS、摘要算法为SHA256、掩码算法为MGF1_SHA256的Verify实例，用于完成验签操作。
2.  调用Verify.setVerifySpec，设置签名参数。需要与签名时设置的保持一致。
3.  调用Verify.init，使用公钥（PubKey）初始化Verify实例。
4.  调用Verify.update，传入待验证的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
5.  调用Verify.verify，对数据进行验签。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 根据密钥参数属性构造RSA非对称密钥对密钥参数
function genRsaKeyPairSpec(nIn: bigint, eIn: bigint, dIn: bigint) {
let rsaCommSpec: cryptoFramework.RSACommonParamsSpec = {
n: nIn,
algName: "RSA",
specType: cryptoFramework.AsyKeySpecType.COMMON_PARAMS_SPEC
};
let rsaKeyPairSpec: cryptoFramework.RSAKeyPairSpec = {
params: rsaCommSpec,
sk: dIn,
pk: eIn,
algName: "RSA",
specType: cryptoFramework.AsyKeySpecType.KEY_PAIR_SPEC
};
return rsaKeyPairSpec;
}
// 生成RSA2048密钥对参数
function genRsa2048KeyPairSpec(): cryptoFramework.RSAKeyPairSpec {
let nIn = BigInt("0x9260d0750ae117eee55c3f3deaba74917521a262ee76007cdf8a56755ad73a1598a1408410a01434c3f5bc54a88b57fa19fc4328daea0750a4c44e88cff3b2382621b80f670464433e4336e6d003e8cd65bff211da144b88291c2259a00a72b711c116ef7686e8fee34e4d933c868187bdc26f7be071493c86f7a5941c3510806ad67b0f94d88f5cf5c02a092821d8626e8932b65c5bd8c92049c210932b7afa7ac59c0e886ae5c1edb00d8ce2c57633db26bd6639bff73cee82be9275c402b4cf2a4388da8cf8c64eefe1c5a0f5ab8057c39fa5c0589c3e253f0960332300f94bea44877b588e1edbde97cf2360727a09b775262d7ee552b3319b9266f05a25");
let eIn = BigInt("0x010001");
let dIn = BigInt("0x6a7df2ca63ead4dda191d614b6b385e0d9056a3d6d5cfe07db1daabee022db08212d97613d3328e0267c9dd23d787abde2afcb306aeb7dfce69246cc73f5c87fdf06030179a2114b767db1f083ff841c025d7dc00cd82435b9a90f695369e94df23d2ce458bc3b3283ad8bba2b8fa1ba62e2dce9accff3799aae7c840016f3ba8e0048c0b6cc4339af7161003a5beb864a0164b2c1c9237b64bc87556994351b27506c33d4bcdfce0f9c491a7d6b0628c7c852be4f0a9c3132b2ed3a2c8881e9aab07e20e17deb074691be677776a78b5c502e05d9bdde72126b3738695e2dd1a0a98a14247c65d8a7ee79432a092cb0721a12df798e44f7cfce0c498147a9b1");
return genRsaKeyPairSpec(nIn, eIn, dIn);
}
async function verifyMessagePSS() {
// 完整的明文被拆分为input1和input2
let plan1 = "This is Sign test plan1";
let plan2 = "This is Sign test plan2";
let input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(plan1, 'utf-8').buffer) };
let input2: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(plan2, 'utf-8').buffer) };
// 获得RSA密钥对密钥参数对象
let rsaKeyPairSpec = genRsa2048KeyPairSpec();
// 构造RSA密钥对生成器
let rsaGeneratorSpec = cryptoFramework.createAsyKeyGeneratorBySpec(rsaKeyPairSpec);
// sign和verfiy均支持RSA密钥带长度/不带长度的写法
let signer = cryptoFramework.createSign("RSA|PSS|SHA256|MGF1_SHA256");
let verifyer = cryptoFramework.createVerify("RSA2048|PSS|SHA256|MGF1_SHA256");
let keyPair = await rsaGeneratorSpec.generateKeyPair();
await signer.init(keyPair.priKey);
// 在签名初始化后，对PSS参数进行set和get操作
let setN = 32;
signer.setSignSpec(cryptoFramework.SignSpecItem.PSS_SALT_LEN_NUM, setN);
let saltLen = signer.getSignSpec(cryptoFramework.SignSpecItem.PSS_SALT_LEN_NUM);
console.info("SaltLen == " + saltLen);
let tf = signer.getSignSpec(cryptoFramework.SignSpecItem.PSS_TRAILER_FIELD_NUM);
console.info("trailer field == " + tf);
let md = signer.getSignSpec(cryptoFramework.SignSpecItem.PSS_MD_NAME_STR);
console.info("md == " + md);
let mgf = signer.getSignSpec(cryptoFramework.SignSpecItem.PSS_MGF_NAME_STR);
console.info("mgf == " + mgf);
let mgf1Md = signer.getSignSpec(cryptoFramework.SignSpecItem.PSS_MGF1_MD_STR);
console.info("mgf1Md == " + mgf1Md);
await signer.update(input1);
let signMessageBlob = await signer.sign(input2);
// 在验签初始化前，对PSS参数进行set和get操作
verifyer.setVerifySpec(cryptoFramework.SignSpecItem.PSS_SALT_LEN_NUM, setN);
saltLen = verifyer.getVerifySpec(cryptoFramework.SignSpecItem.PSS_SALT_LEN_NUM);
console.info("SaltLen == " + saltLen);
tf = verifyer.getVerifySpec(cryptoFramework.SignSpecItem.PSS_TRAILER_FIELD_NUM);
console.info("trailer field == " + tf);
md = verifyer.getVerifySpec(cryptoFramework.SignSpecItem.PSS_MD_NAME_STR);
console.info("md == " + md);
mgf = verifyer.getVerifySpec(cryptoFramework.SignSpecItem.PSS_MGF_NAME_STR);
console.info("mgf == " + mgf);
mgf1Md = verifyer.getVerifySpec(cryptoFramework.SignSpecItem.PSS_MGF1_MD_STR);
await verifyer.init(keyPair.pubKey);
await verifyer.update(input1);
let verifyResult = await verifyer.verify(input2, signMessageBlob);
if (verifyResult === true) {
console.info('verify success');
} else {
console.error('verify failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 根据密钥参数属性构造RSA非对称密钥对密钥参数
function genRsaKeyPairSpec(nIn: bigint, eIn: bigint, dIn: bigint) {
let rsaCommSpec: cryptoFramework.RSACommonParamsSpec = {
n: nIn,
algName: "RSA",
specType: cryptoFramework.AsyKeySpecType.COMMON_PARAMS_SPEC
};
let rsaKeyPairSpec: cryptoFramework.RSAKeyPairSpec = {
params: rsaCommSpec,
sk: dIn,
pk: eIn,
algName: "RSA",
specType: cryptoFramework.AsyKeySpecType.KEY_PAIR_SPEC
};
return rsaKeyPairSpec;
}
// 生成RSA2048密钥对参数
function genRsa2048KeyPairSpec(): cryptoFramework.RSAKeyPairSpec {
let nIn = BigInt("0x9260d0750ae117eee55c3f3deaba74917521a262ee76007cdf8a56755ad73a1598a1408410a01434c3f5bc54a88b57fa19fc4328daea0750a4c44e88cff3b2382621b80f670464433e4336e6d003e8cd65bff211da144b88291c2259a00a72b711c116ef7686e8fee34e4d933c868187bdc26f7be071493c86f7a5941c3510806ad67b0f94d88f5cf5c02a092821d8626e8932b65c5bd8c92049c210932b7afa7ac59c0e886ae5c1edb00d8ce2c57633db26bd6639bff73cee82be9275c402b4cf2a4388da8cf8c64eefe1c5a0f5ab8057c39fa5c0589c3e253f0960332300f94bea44877b588e1edbde97cf2360727a09b775262d7ee552b3319b9266f05a25");
let eIn = BigInt("0x010001");
let dIn = BigInt("0x6a7df2ca63ead4dda191d614b6b385e0d9056a3d6d5cfe07db1daabee022db08212d97613d3328e0267c9dd23d787abde2afcb306aeb7dfce69246cc73f5c87fdf06030179a2114b767db1f083ff841c025d7dc00cd82435b9a90f695369e94df23d2ce458bc3b3283ad8bba2b8fa1ba62e2dce9accff3799aae7c840016f3ba8e0048c0b6cc4339af7161003a5beb864a0164b2c1c9237b64bc87556994351b27506c33d4bcdfce0f9c491a7d6b0628c7c852be4f0a9c3132b2ed3a2c8881e9aab07e20e17deb074691be677776a78b5c502e05d9bdde72126b3738695e2dd1a0a98a14247c65d8a7ee79432a092cb0721a12df798e44f7cfce0c498147a9b1");
return genRsaKeyPairSpec(nIn, eIn, dIn);
}
function verifyMessagePSS() {
// 完整的明文被拆分为input1和input2
let plan1 = "This is Sign test plan1";
let plan2 = "This is Sign test plan2";
let input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(plan1, 'utf-8').buffer) };
let input2: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(plan2, 'utf-8').buffer) };
// 获得RSA密钥对密钥参数对象
let rsaKeyPairSpec = genRsa2048KeyPairSpec();
// 构造RSA密钥对生成器
let rsaGeneratorSpec = cryptoFramework.createAsyKeyGeneratorBySpec(rsaKeyPairSpec);
// sign和verfiy均支持RSA密钥带长度/不带长度的写法
let signer = cryptoFramework.createSign("RSA|PSS|SHA256|MGF1_SHA256");
let verifyer = cryptoFramework.createVerify("RSA2048|PSS|SHA256|MGF1_SHA256");
let keyPair = rsaGeneratorSpec.generateKeyPairSync();
signer.initSync(keyPair.priKey);
// 在签名初始化后，对PSS参数进行set和get操作
let setN = 32;
signer.setSignSpec(cryptoFramework.SignSpecItem.PSS_SALT_LEN_NUM, setN);
let saltLen = signer.getSignSpec(cryptoFramework.SignSpecItem.PSS_SALT_LEN_NUM);
console.info("SaltLen == " + saltLen);
let tf = signer.getSignSpec(cryptoFramework.SignSpecItem.PSS_TRAILER_FIELD_NUM);
console.info("trailer field == " + tf);
let md = signer.getSignSpec(cryptoFramework.SignSpecItem.PSS_MD_NAME_STR);
console.info("md == " + md);
let mgf = signer.getSignSpec(cryptoFramework.SignSpecItem.PSS_MGF_NAME_STR);
console.info("mgf == " + mgf);
let mgf1Md = signer.getSignSpec(cryptoFramework.SignSpecItem.PSS_MGF1_MD_STR);
console.info("mgf1Md == " + mgf1Md);
signer.updateSync(input1);
let signMessageBlob = signer.signSync(input2);
// 在验签初始化前，对PSS参数进行set和get操作
verifyer.setVerifySpec(cryptoFramework.SignSpecItem.PSS_SALT_LEN_NUM, setN);
saltLen = verifyer.getVerifySpec(cryptoFramework.SignSpecItem.PSS_SALT_LEN_NUM);
console.info("SaltLen == " + saltLen);
tf = verifyer.getVerifySpec(cryptoFramework.SignSpecItem.PSS_TRAILER_FIELD_NUM);
console.info("trailer field == " + tf);
md = verifyer.getVerifySpec(cryptoFramework.SignSpecItem.PSS_MD_NAME_STR);
console.info("md == " + md);
mgf = verifyer.getVerifySpec(cryptoFramework.SignSpecItem.PSS_MGF_NAME_STR);
console.info("mgf == " + mgf);
mgf1Md = verifyer.getVerifySpec(cryptoFramework.SignSpecItem.PSS_MGF1_MD_STR);
verifyer.initSync(keyPair.pubKey);
verifyer.updateSync(input1);
let verifyResult = verifyer.verifySync(input2, signMessageBlob);
if (verifyResult === true) {
console.info('verify success');
} else {
console.error('verify failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-rsa-sign-sig-verify-pss-ndk-V14
爬取时间: 2025-04-28 01:49:51
来源: Huawei Developer
对应的算法规格请查看验签算法规格：RSA。
在CMake脚本中链接相关动态库
开发步骤
1.  调用OH_CryptoVerify_Create，指定字符串参数'RSA2048|PSS|SHA256|MGF1_SHA256'，创建非对称密钥类型为RSA2048、填充模式为PSS、摘要算法为SHA256、掩码算法为MGF1_SHA256的Verify实例，用于完成验签操作。
2.  调用OH_CryptoVerify_SetParam，设置签名参数。需要与签名时设置的保持一致。
3.  调用OH_CryptoVerify_Init，使用公钥（OH_CryptoPubKey）初始化Verify实例。
4.  调用OH_CryptoVerify_Update，传入待验证的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update，如果数据量较小，可以直接调用OH_CryptoVerify_Final接口一次性传入。
5.  调用OH_CryptoVerify_Final，对数据进行验签。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-ecdsa-sign-sig-verify-V14
爬取时间: 2025-04-28 01:50:04
来源: Huawei Developer
对应的算法规格请查看签名验签算法规格：ECDSA。
签名
1.  调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair，生成非对称密钥算法为ECC、密钥长度为256的密钥对（KeyPair）。 如何生成ECC非对称密钥，开发者可参考下文示例，并结合非对称密钥生成和转换规格：ECC和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createSign，指定字符串参数'ECC256|SHA256'，创建非对称密钥类型为ECC256、摘要算法为SHA256的Sign实例，用于完成签名操作。
3.  调用Sign.init，使用私钥（PriKey）初始化Sign实例。
4.  调用Sign.update，传入待签名的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
5.  调用Sign.sign，生成数据签名。
验签
1.  调用cryptoFramework.createVerify，指定字符串参数'ECC256|SHA256'，创建非对称密钥类型为ECC256、摘要算法为SHA256的Verify实例，用于完成验签操作。
2.  调用Verify.init，使用公钥（PubKey）初始化Verify实例。
3.  调用Verify.update，传入待验证的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
4.  调用Verify.verify，对数据进行验签。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 完整的明文被拆分为input1和input2
let input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan1", 'utf-8').buffer) };
let input2: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan2", 'utf-8').buffer) };
async function signMessagePromise(priKey: cryptoFramework.PriKey) {
let signAlg = "ECC256|SHA256";
let signer = cryptoFramework.createSign(signAlg);
await signer.init(priKey);
await signer.update(input1); // 如果明文较短，可以直接调用sign接口一次性传入
let signData = await signer.sign(input2);
return signData;
}
async function verifyMessagePromise(signMessageBlob: cryptoFramework.DataBlob, pubKey: cryptoFramework.PubKey) {
let verifyAlg = "ECC256|SHA256";
let verifier = cryptoFramework.createVerify(verifyAlg);
await verifier.init(pubKey);
await verifier.update(input1); // 如果明文较短，可以直接调用verify接口一次性传入
let res = await verifier.verify(input2, signMessageBlob);
console.info("verify result is " + res);
return res;
}
async function main() {
let keyGenAlg = "ECC256";
let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);
let keyPair = await generator.generateKeyPair();
let signData = await signMessagePromise(keyPair.priKey);
let verifyResult = await verifyMessagePromise(signData, keyPair.pubKey);
if (verifyResult === true) {
console.info('verify success');
} else {
console.error('verify failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 完整的明文被拆分为input1和input2
let input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan1", 'utf-8').buffer) };
let input2: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan2", 'utf-8').buffer) };
function signMessagePromise(priKey: cryptoFramework.PriKey) {
let signAlg = "ECC256|SHA256";
let signer = cryptoFramework.createSign(signAlg);
signer.initSync(priKey);
signer.updateSync(input1); // 如果明文较短，可以直接调用sign接口一次性传入
let signData = signer.signSync(input2);
return signData;
}
function verifyMessagePromise(signMessageBlob: cryptoFramework.DataBlob, pubKey: cryptoFramework.PubKey) {
let verifyAlg = "ECC256|SHA256";
let verifier = cryptoFramework.createVerify(verifyAlg);
verifier.initSync(pubKey);
verifier.updateSync(input1); // 如果明文较短，可以直接调用verify接口一次性传入
let res = verifier.verifySync(input2, signMessageBlob);
console.info("verify result is " + res);
return res;
}
function main() {
let keyGenAlg = "ECC256";
let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);
let keyPair = generator.generateKeyPairSync();
let signData = signMessagePromise(keyPair.priKey);
let verifyResult = verifyMessagePromise(signData, keyPair.pubKey);
if (verifyResult === true) {
console.info('verify success');
} else {
console.error('verify failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-ecdsa-sign-sig-verify-ndk-V14
爬取时间: 2025-04-28 01:50:18
来源: Huawei Developer
对应的算法规格请查看签名验签算法规格：ECDSA。
在CMake脚本中链接相关动态库
开发步骤
1.  调用OH_CryptoVerify_Create，指定字符串参数'ECC256|SHA256'，创建非对称密钥类型为ECC256、摘要算法为SHA256的Verify实例，用于完成验签操作。
2.  调用OH_CryptoVerify_Init，使用公钥（OH_CryptoPubKey）初始化Verify实例。
3.  调用OH_CryptoVerify_Update，传入待验证的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update，如果数据量较小，可以直接调用OH_CryptoVerify_Final接口一次性传入。
4.  调用OH_CryptoVerify_Final，对数据进行验签。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sm2-sign-sig-verify-pkcs1-V14
爬取时间: 2025-04-28 01:50:31
来源: Huawei Developer
对应的算法规格请查看签名验签算法规格：SM2。
签名
1.  调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair，生成非对称密钥算法为SM2、密钥长度为256的密钥对（KeyPair）。 如何生成SM2非对称密钥，开发者可参考下文示例，并结合非对称密钥生成和转换规格：SM2和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createSign，指定字符串参数'SM2_256|SM3'，创建非对称密钥类型为SM2_256、摘要算法为SM3的Sign实例，用于完成签名操作。
3.  调用Sign.init，使用私钥（PriKey）初始化Sign实例。
4.  调用Sign.update，传入待签名的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
5.  调用Sign.sign，生成数据签名。
验签
1.  调用cryptoFramework.createVerify，指定字符串参数'SM2_256|SM3'，创建非对称密钥类型为SM2_256、摘要算法为SM3的Verify实例，用于完成验签操作。
2.  调用Verify.init，使用公钥（PubKey）初始化Verify实例。
3.  调用Verify.update，传入待验证的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。
4.  调用Verify.verify，对数据进行验签。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 完整的明文被拆分为input1和input2
let input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan1", 'utf-8').buffer) };
let input2: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan2", 'utf-8').buffer) };
async function signMessagePromise(priKey: cryptoFramework.PriKey) {
let signAlg = "SM2_256|SM3";
let signer = cryptoFramework.createSign(signAlg);
await signer.init(priKey);
await signer.update(input1); // 如果明文较短，可以直接调用sign接口一次性传入
let signData = await signer.sign(input2);
return signData;
}
async function verifyMessagePromise(signMessageBlob: cryptoFramework.DataBlob, pubKey: cryptoFramework.PubKey) {
let verifyAlg = "SM2_256|SM3";
let verifier = cryptoFramework.createVerify(verifyAlg);
await verifier.init(pubKey);
await verifier.update(input1); // 如果明文较短，可以直接调用verify接口一次性传入
let res = await verifier.verify(input2, signMessageBlob);
console.info("verify result is " + res);
return res;
}
async function main() {
let keyGenAlg = "SM2_256";
let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);
let keyPair = await generator.generateKeyPair();
let signData = await signMessagePromise(keyPair.priKey);
let verifyResult = await verifyMessagePromise(signData, keyPair.pubKey);
if (verifyResult === true) {
console.info('verify success');
} else {
console.error('verify failed');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
// 完整的明文被拆分为input1和input2
let input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan1", 'utf-8').buffer) };
let input2: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from("This is Sign test plan2", 'utf-8').buffer) };
function signMessagePromise(priKey: cryptoFramework.PriKey) {
let signAlg = "SM2_256|SM3";
let signer = cryptoFramework.createSign(signAlg);
signer.initSync(priKey);
signer.updateSync(input1); // 如果明文较短，可以直接调用sign接口一次性传入
let signData = signer.signSync(input2);
return signData;
}
function verifyMessagePromise(signMessageBlob: cryptoFramework.DataBlob, pubKey: cryptoFramework.PubKey) {
let verifyAlg = "SM2_256|SM3";
let verifier = cryptoFramework.createVerify(verifyAlg);
verifier.initSync(pubKey);
verifier.updateSync(input1); // 如果明文较短，可以直接调用verify接口一次性传入
let res = verifier.verifySync(input2, signMessageBlob);
console.info("verify result is " + res);
return res;
}
function main() {
let keyGenAlg = "SM2_256";
let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);
let keyPair = generator.generateKeyPairSync();
let signData = signMessagePromise(keyPair.priKey);
let verifyResult = verifyMessagePromise(signData, keyPair.pubKey);
if (verifyResult === true) {
console.info('verify success');
} else {
console.error('verify failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-sm2-sign-sig-verify-pkcs1-ndk-V14
爬取时间: 2025-04-28 01:50:45
来源: Huawei Developer
对应的算法规格请查看验签算法规格：SM2。
在CMake脚本中链接相关动态库
开发步骤
1.  调用OH_CryptoVerify_Create，指定字符串参数'SM2_256|SM3'，创建非对称密钥类型为SM2_256、摘要算法为SM3的Verify实例，用于完成验签操作。
2.  调用OH_CryptoVerify_Init，使用公钥（OH_CryptoPubKey）初始化Verify实例。
3.  调用OH_CryptoVerify_Update，传入待验证的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update，如果数据量较小，可以直接调用OH_CryptoVerify_Final接口一次性传入。
4.  调用OH_CryptoVerify_Final，对数据进行验签。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-agreement-V14
爬取时间: 2025-04-28 01:50:58
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-agreement-overview-V14
爬取时间: 2025-04-28 01:51:13
来源: Huawei Developer
在非安全通道环境中，需要不共享任何秘密的情况下，协商出一个安全的共享密钥，可以使用密钥协商算法。
接下来将说明系统目前支持的算法及其对应的规格。
ECDH
ECDH（Elliptic Curve Diffie–Hellman key exchange），算法库框架提供了多种椭圆曲线的ECDH能力。
当创建密钥协商时，需要使用表中“字符串参数”一列，指定密钥协商算法规格。
| 非对称密钥算法 | 字符串参数 | API版本 |
| --- | --- | --- |
| ECC | ECC224 | 9+ |
| ECC | ECC256 | 9+ |
| ECC | ECC384 | 9+ |
| ECC | ECC521 | 9+ |
| ECC | ECC_BrainPoolP160r1 | 11+ |
| ECC | ECC_BrainPoolP160t1 | 11+ |
| ECC | ECC_BrainPoolP192r1 | 11+ |
| ECC | ECC_BrainPoolP192t1 | 11+ |
| ECC | ECC_BrainPoolP224r1 | 11+ |
| ECC | ECC_BrainPoolP224t1 | 11+ |
| ECC | ECC_BrainPoolP256r1 | 11+ |
| ECC | ECC_BrainPoolP256t1 | 11+ |
| ECC | ECC_BrainPoolP320r1 | 11+ |
| ECC | ECC_BrainPoolP320t1 | 11+ |
| ECC | ECC_BrainPoolP384r1 | 11+ |
| ECC | ECC_BrainPoolP384t1 | 11+ |
| ECC | ECC_BrainPoolP512r1 | 11+ |
| ECC | ECC_BrainPoolP512t1 | 11+ |
| ECC | ECC_Secp256k1 | 14+ |
| ECC | ECC | 10+ |
如表中最后一行所示，为了兼容由密钥参数生成的密钥，ECDH密钥协商参数输入密钥类型时支持不指定长度和曲线，密钥协商运算取决于实际输入的密钥。
X25519
算法库框架提供了X25519密钥协商的能力。
当创建密钥协商时，需要使用表中“字符串参数”一列，指定密钥协商算法规格。
| 非对称密钥算法 | 字符串参数 | API版本 |
| --- | --- | --- |
| X25519 | X25519 | 11+ |
DH
DH（Diffie–Hellman key exchange），算法库框架提供了DH密钥协商的能力。
当创建密钥协商时，需要使用表中“字符串参数”一列，指定密钥协商算法规格。
| 非对称密钥算法 | 字符串参数 | API版本 |
| --- | --- | --- |
| DH | DH_modp1536 | 11+ |
| DH | DH_modp2048 | 11+ |
| DH | DH_modp3072 | 11+ |
| DH | DH_modp4096 | 11+ |
| DH | DH_modp6144 | 11+ |
| DH | DH_modp8192 | 11+ |
| DH | DH_ffdhe2048 | 11+ |
| DH | DH_ffdhe3072 | 11+ |
| DH | DH_ffdhe4096 | 11+ |
| DH | DH_ffdhe6144 | 11+ |
| DH | DH_ffdhe8192 | 11+ |
| DH | DH | 11+ |
如表中最后一行所示，为了兼容由密钥参数生成的密钥，DH密钥协商参数输入密钥类型时支持不指定知名安全素数群，密钥协商运算取决于实际输入的密钥，且这种情况支持非知名组密钥协商。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-agreement-dev-V14
爬取时间: 2025-04-28 01:51:26
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-agreement-using-ecdh-V14
爬取时间: 2025-04-28 01:51:40
来源: Huawei Developer
对应的算法规格请查看密钥协商算法规格：ECDH。
开发步骤
1.  调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair、AsyKeyGenerator.convertKey生成密钥算法为ECC、密钥长度为256位的非对称密钥（KeyPair）。 如何生成ECC非对称密钥，开发者可参考下文示例，并结合非对称密钥生成和转换规格：ECC和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createKeyAgreement，指定字符串参数'ECC256'，创建密钥算法为ECC、密钥长度为256位的密钥协议生成器（KeyAgreement）。
3.  调用KeyAgreement.generateSecret，基于传入的私钥（KeyPair.priKey）与公钥（KeyPair.pubKey）进行密钥协商，返回共享秘钥。
-  以使用await方式，完成密钥协商为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
async function ecdhAwait() {
// 假设此公私钥对数据为外部传入
let pubKeyArray = new Uint8Array([48, 89, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7, 3, 66, 0, 4, 83, 96, 142, 9, 86, 214, 126, 106, 247, 233, 92, 125, 4, 128, 138, 105, 246, 162, 215, 71, 81, 58, 202, 121, 26, 105, 211, 55, 130, 45, 236, 143, 55, 16, 248, 75, 167, 160, 167, 106, 2, 152, 243, 44, 68, 66, 0, 167, 99, 92, 235, 215, 159, 239, 28, 106, 124, 171, 34, 145, 124, 174, 57, 92]);
let priKeyArray = new Uint8Array([48, 49, 2, 1, 1, 4, 32, 115, 56, 137, 35, 207, 0, 60, 191, 90, 61, 136, 105, 210, 16, 27, 4, 171, 57, 10, 61, 123, 40, 189, 28, 34, 207, 236, 22, 45, 223, 10, 189, 160, 10, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
let eccGen = cryptoFramework.createAsyKeyGenerator('ECC256');
// 外部传入的公私钥对A
let keyPairA = await eccGen.convertKey({ data: pubKeyArray }, { data: priKeyArray });
// 内部生成的公私钥对B
let keyPairB = await eccGen.generateKeyPair();
let eccKeyAgreement = cryptoFramework.createKeyAgreement('ECC256');
// 使用A的公钥和B的私钥进行密钥协商
let secret1 = await eccKeyAgreement.generateSecret(keyPairB.priKey, keyPairA.pubKey);
// 使用A的私钥和B的公钥进行密钥协商
let secret2 = await eccKeyAgreement.generateSecret(keyPairA.priKey, keyPairB.pubKey);
// 两种协商的结果应当一致
if (secret1.data.toString() === secret2.data.toString()) {
console.info('ecdh success');
console.info('ecdh output is ' + secret1.data);
} else {
console.error('ecdh result is not equal');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function ecdhAwait() {
// 假设此公私钥对数据为外部传入
let pubKeyArray = new Uint8Array([48, 89, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7, 3, 66, 0, 4, 83, 96, 142, 9, 86, 214, 126, 106, 247, 233, 92, 125, 4, 128, 138, 105, 246, 162, 215, 71, 81, 58, 202, 121, 26, 105, 211, 55, 130, 45, 236, 143, 55, 16, 248, 75, 167, 160, 167, 106, 2, 152, 243, 44, 68, 66, 0, 167, 99, 92, 235, 215, 159, 239, 28, 106, 124, 171, 34, 145, 124, 174, 57, 92]);
let priKeyArray = new Uint8Array([48, 49, 2, 1, 1, 4, 32, 115, 56, 137, 35, 207, 0, 60, 191, 90, 61, 136, 105, 210, 16, 27, 4, 171, 57, 10, 61, 123, 40, 189, 28, 34, 207, 236, 22, 45, 223, 10, 189, 160, 10, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
let eccGen = cryptoFramework.createAsyKeyGenerator('ECC256');
// 外部传入的公私钥对A
let keyPairA = eccGen.convertKeySync({ data: pubKeyArray }, { data: priKeyArray });
// 内部生成的公私钥对B
let keyPairB = eccGen.generateKeyPairSync();
let eccKeyAgreement = cryptoFramework.createKeyAgreement('ECC256');
// 使用A的公钥和B的私钥进行密钥协商
let secret1 = eccKeyAgreement.generateSecretSync(keyPairB.priKey, keyPairA.pubKey);
// 使用A的私钥和B的公钥进行密钥协商
let secret2 = eccKeyAgreement.generateSecretSync(keyPairA.priKey, keyPairB.pubKey);
// 两种协商的结果应当一致
if (secret1.data.toString() === secret2.data.toString()) {
console.info('ecdh success');
console.info('ecdh output is ' + secret1.data);
} else {
console.error('ecdh result is not equal');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-agreement-using-x25519-V14
爬取时间: 2025-04-28 01:51:53
来源: Huawei Developer
对应的算法规格请查看密钥协商算法规格：X25519。
开发步骤
1.  调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair、AsyKeyGenerator.convertKey生成密钥算法为X25519的非对称密钥（KeyPair）。 如何生成X25519非对称密钥，开发者可参考下文示例，并结合非对称密钥生成和转换规格：X25519和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createKeyAgreement，指定字符串参数'X25519'，创建密钥算法为X25519的密钥协议生成器（KeyAgreement）。
3.  调用KeyAgreement.generateSecret，基于传入的私钥（KeyPair.priKey）与公钥（KeyPair.pubKey）进行密钥协商，返回共享秘钥。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
async function x25519Await() {
// 假设此公私钥对数据为外部传入
let pubKeyArray = new Uint8Array([48, 42, 48, 5, 6, 3, 43, 101, 110, 3, 33, 0, 36, 98, 216, 106, 74, 99, 179, 203, 81, 145, 147, 101, 139, 57, 74, 225, 119, 196, 207, 0, 50, 232, 93, 147, 188, 21, 225, 228, 54, 251, 230, 52]);
let priKeyArray = new Uint8Array([48, 46, 2, 1, 0, 48, 5, 6, 3, 43, 101, 110, 4, 34, 4, 32, 112, 65, 156, 73, 65, 89, 183, 39, 119, 229, 110, 12, 192, 237, 186, 153, 21, 122, 28, 176, 248, 108, 22, 242, 239, 179, 106, 175, 85, 65, 214, 90]);
let keyGen = cryptoFramework.createAsyKeyGenerator('X25519');
// 外部传入的公私钥对A
let keyPairA = await keyGen.convertKey({ data: pubKeyArray }, { data: priKeyArray });
// 内部生成的公私钥对B
let keyPairB = await keyGen.generateKeyPair();
let keyAgreement = cryptoFramework.createKeyAgreement('X25519');
// 使用A的公钥和B的私钥进行密钥协商
let secret1 = await keyAgreement.generateSecret(keyPairB.priKey, keyPairA.pubKey);
// 使用A的私钥和B的公钥进行密钥协商
let secret2 = await keyAgreement.generateSecret(keyPairA.priKey, keyPairB.pubKey);
// 两种协商的结果应当一致
if (secret1.data.toString() === secret2.data.toString()) {
console.info('x25519 success');
console.info('x25519 output is ' + secret1.data);
} else {
console.error('x25519 result is not equal');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function x25519AgreementSync() {
// 假设此公私钥对数据为外部传入
let pubKeyArray = new Uint8Array([48, 42, 48, 5, 6, 3, 43, 101, 110, 3, 33, 0, 36, 98, 216, 106, 74, 99, 179, 203, 81, 145, 147, 101, 139, 57, 74, 225, 119, 196, 207, 0, 50, 232, 93, 147, 188, 21, 225, 228, 54, 251, 230, 52]);
let priKeyArray = new Uint8Array([48, 46, 2, 1, 0, 48, 5, 6, 3, 43, 101, 110, 4, 34, 4, 32, 112, 65, 156, 73, 65, 89, 183, 39, 119, 229, 110, 12, 192, 237, 186, 153, 21, 122, 28, 176, 248, 108, 22, 242, 239, 179, 106, 175, 85, 65, 214, 90]);
let keyGen = cryptoFramework.createAsyKeyGenerator('X25519');
// 外部传入的公私钥对A
let keyPairA = keyGen.convertKeySync({ data: pubKeyArray }, { data: priKeyArray });
// 内部生成的公私钥对B
let keyPairB = keyGen.generateKeyPairSync();
let keyAgreement = cryptoFramework.createKeyAgreement('X25519');
// 使用A的公钥和B的私钥进行密钥协商
let secret1 = keyAgreement.generateSecretSync(keyPairB.priKey, keyPairA.pubKey);
// 使用A的私钥和B的公钥进行密钥协商
let secret2 = keyAgreement.generateSecretSync(keyPairA.priKey, keyPairB.pubKey);
// 两种协商的结果应当一致
if (secret1.data.toString() === secret2.data.toString()) {
console.info('x25519 success');
console.info('x25519 output is ' + secret1.data);
} else {
console.error('x25519 result is not equal');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-agreement-using-dh-V14
爬取时间: 2025-04-28 01:52:07
来源: Huawei Developer
对应的算法规格请查看密钥协商算法规格：DH。
开发步骤
1.  调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair生成密钥算法为DH、采用知名安全素数群modp1536的非对称密钥（KeyPair）。 如何生成DH非对称密钥，开发者可参考下文示例，并结合非对称密钥生成和转换规格：DH和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。
2.  调用cryptoFramework.createKeyAgreement，指定字符串参数'DH_modp1536'，创建密钥算法为DH、采用知名安全素数群modp1536的密钥协议生成器（KeyAgreement）。
3.  调用KeyAgreement.generateSecret，基于传入的私钥（KeyPair.priKey）与公钥（KeyPair.pubKey）进行密钥协商，返回共享秘密。
-  异步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
async function dhAwait() {
let keyGen = cryptoFramework.createAsyKeyGenerator('DH_modp1536');
// 随机生成公私钥对A
let keyPairA = await keyGen.generateKeyPair();
// 随机生成规格一致的公私钥对B
let keyPairB = await keyGen.generateKeyPair();
let keyAgreement = cryptoFramework.createKeyAgreement('DH_modp1536');
// 使用A的公钥和B的私钥进行密钥协商
let secret1 = await keyAgreement.generateSecret(keyPairB.priKey, keyPairA.pubKey);
// 使用A的私钥和B的公钥进行密钥协商
let secret2 = await keyAgreement.generateSecret(keyPairA.priKey, keyPairB.pubKey);
// 两种协商的结果应当一致
if (secret1.data.toString() === secret2.data.toString()) {
console.info('DH success');
console.info('DH output is ' + secret1.data);
} else {
console.error('DH result is not equal');
}
}
```
-  同步方法示例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
function dhAgreementSync() {
let keyGen = cryptoFramework.createAsyKeyGenerator('DH_modp1536');
// 随机生成公私钥对A
let keyPairA = keyGen.generateKeyPairSync();
// 随机生成规格一致的公私钥对B
let keyPairB = keyGen.generateKeyPairSync();
let keyAgreement = cryptoFramework.createKeyAgreement('DH_modp1536');
// 使用A的公钥和B的私钥进行密钥协商
let secret1 = keyAgreement.generateSecretSync(keyPairB.priKey, keyPairA.pubKey);
// 使用A的私钥和B的公钥进行密钥协商
let secret2 = keyAgreement.generateSecretSync(keyPairA.priKey, keyPairB.pubKey);
// 两种协商的结果应当一致
if (secret1.data.toString() === secret2.data.toString()) {
console.info('DH success');
console.info('DH output is ' + secret1.data);
} else {
console.error('DH result is not equal');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-generate-message-V14
爬取时间: 2025-04-28 01:53:00
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-generate-message-digest-overview-V14
爬取时间: 2025-04-28 01:53:14
来源: Huawei Developer
消息摘要算法是一种能将任意长度的输入消息，通过特定运算生成固定长度摘要的算法。消息摘要算法也被称为哈希算法或单向散列算法。
在摘要算法相同时，生成的摘要值主要有下列特点：
-  当输入消息相同时，生成摘要序列相同。
-  当输入消息的长度不一致时，生成摘要序列长度固定（摘要长度由算法决定）。例如SHA256会生成256位，即32字节。
支持的算法与规格
当创建MD消息摘要时，需要使用表中“支持种类”一列，指定MD消息摘要算法规格。
| 摘要算法 | 支持种类 | 字节长度 | API版本 |
| --- | --- | --- | --- |
| HASH | SHA1 | 20 | 9+ |
| HASH | SHA224 | 28 | 9+ |
| HASH | SHA256 | 32 | 9+ |
| HASH | SHA384 | 48 | 9+ |
| HASH | SHA512 | 64 | 9+ |
| HASH | MD5 | 16 | 9+ |
| HASH | SM3 | 32 | 10+ |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-generate-message-digest-dev-V14
爬取时间: 2025-04-28 01:53:27
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-generate-message-digest-V14
爬取时间: 2025-04-28 01:53:41
来源: Huawei Developer
对应的算法规格请查看消息摘要计算算法规格。
从API version 12开始，轻量级智能穿戴设备支持消息摘要的计算与操作。
开发步骤
在调用update接口传入数据时，可以一次性传入所有数据，也可以把数据人工分段，然后分段update。对于同一段数据而言，计算结果没有差异。对于数据量较大的数据，开发者可以根据实际需求选择是否分段传入。
下面分别提供两种方式的示例代码。
摘要算法（一次性传入）
1.  调用cryptoFramework.createMd，指定摘要算法SHA256，生成摘要实例（Md）。
2.  调用Md.update，传入自定义消息，进行摘要更新计算。单次update长度没有限制。
3.  调用Md.digest，获取摘要计算结果。
4.  调用Md.getMdLength，获取摘要计算长度，单位为字节。
-  以使用await方式单次传入数据，获取摘要计算结果为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
async function doMd() {
let mdAlgName = 'SHA256'; // 摘要算法名
let message = 'mdTestMessage'; // 待摘要的数据
let md = cryptoFramework.createMd(mdAlgName);
// 数据量较少时，可以只做一次update，将数据全部传入，接口未对入参长度做限制
await md.update({ data: new Uint8Array(buffer.from(message, 'utf-8').buffer) });
let mdResult = await md.digest();
console.info('Md result:' + mdResult.data);
let mdLen = md.getMdLength();
console.info("md len: " + mdLen);
}
```
-  以使用同步方式单次传入数据，获取摘要计算结果为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function doMdBySync() {
let mdAlgName = 'SHA256'; // 摘要算法名
let message = 'mdTestMessage'; // 待摘要的数据
let md = cryptoFramework.createMd(mdAlgName);
// 数据量较少时，可以只做一次update，将数据全部传入，接口未对入参长度做限制
md.updateSync({ data: new Uint8Array(buffer.from(message, 'utf-8').buffer) });
let mdResult = md.digestSync();
console.info('[Sync]:Md result:' + mdResult.data);
let mdLen = md.getMdLength();
console.info("md len: " + mdLen);
}
```
分段摘要算法
1.  调用cryptoFramework.createMd，指定摘要算法SHA256，生成摘要实例（Md）。
2.  传入自定义消息，将一次传入数据量设置为20字节，多次调用Md.update，进行摘要更新计算。
3.  调用Md.digest，获取摘要计算结果。
4.  调用Md.getMdLength，获取摘要计算长度，单位为字节。
-  以使用await方式分段传入数据，获取摘要计算结果为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
async function doLoopMd() {
let mdAlgName = "SHA256"; // 摘要算法名
let md = cryptoFramework.createMd(mdAlgName);
// 假设信息总共43字节，根据utf-8解码后，也是43字节
let messageText = "aaaaa.....bbbbb.....ccccc.....ddddd.....eee";
let messageData = new Uint8Array(buffer.from(messageText, 'utf-8').buffer);
let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求
for (let i = 0; i < messageData.length; i += updateLength) {
let updateMessage = messageData.subarray(i, i + updateLength);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
await md.update(updateMessageBlob);
}
let mdOutput = await md.digest();
console.info("md result: " + mdOutput.data);
let mdLen = md.getMdLength();
console.info("md len: " + mdLen);
}
```
-  以使用同步方式分段传入数据，获取摘要计算结果为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function doLoopMdBySync() {
let mdAlgName = "SHA256"; // 摘要算法名
let md = cryptoFramework.createMd(mdAlgName);
// 假设信息总共43字节，根据utf-8解码后，也是43字节
let messageText = "aaaaa.....bbbbb.....ccccc.....ddddd.....eee";
let messageData = new Uint8Array(buffer.from(messageText, 'utf-8').buffer);
let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求
for (let i = 0; i < messageData.length; i += updateLength) {
let updateMessage = messageData.subarray(i, i + updateLength);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
md.updateSync(updateMessageBlob);
}
let mdOutput = md.digestSync();
console.info("[Sync]:md result: " + mdOutput.data);
let mdLen = md.getMdLength();
console.info("md len: " + mdLen);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-generate-message-digest-ndk-V14
爬取时间: 2025-04-28 01:53:55
来源: Huawei Developer
对应的算法规格请查看消息摘要计算算法规格。
在CMake脚本中链接相关动态库
开发步骤
在调用update接口传入数据时，可以一次性传入所有数据，也可以把数据人工分段，然后分段update。对于同一段数据而言，计算结果没有差异。对于数据量较大的数据，开发者可以根据实际需求选择是否分段传入。
下面分别提供两种方式的示例代码。
摘要算法（一次性传入）
1.  调用OH_CryptoDigest_Create，指定摘要算法SHA256，生成摘要实例（OH_CryptoDigest）。
2.  调用OH_CryptoDigest_Update，传入自定义消息，进行摘要更新计算。单次update长度没有限制。
3.  调用OH_CryptoDigest_Final，获取摘要计算结果。
4.  调用OH_CryptoDigest_GetLength，获取摘要计算长度，单位为字节。
5.  调用OH_DigestCrypto_Destroy，销毁摘要实例（OH_CryptoDigest）。
分段摘要算法
1.  调用OH_CryptoDigest_Create，指定摘要算法SHA256，生成摘要实例（OH_CryptoDigest）。
2.  传入自定义消息，将一次传入数据量设置为20字节，多次调用OH_CryptoDigest_Update，进行摘要更新计算。
3.  调用OH_CryptoDigest_Final，获取摘要计算结果。
4.  调用OH_CryptoDigest_GetLength，获取摘要计算长度，单位为字节。
5.  调用OH_DigestCrypto_Destroy，销毁摘要实例（OH_CryptoDigest）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-compute-mac-V14
爬取时间: 2025-04-28 01:54:08
来源: Huawei Developer
MAC（Message Authentication Code，消息认证码）可以对消息进行完整性校验，通过使用双方共享的密钥，识别出信息伪装篡改等行为。
HMAC（Hash-based Message Authentication Code）是一种基于哈希的消息认证码算法。
HMAC通过指定摘要算法，以通信双方共享密钥与消息作为输入，生成消息认证码用于检验传递报文的完整性。HMAC在消息摘要算法的基础上增加了密钥的输入，确保了信息的正确性。生成的消息认证码为固定长度。
支持的算法与规格
当创建HMAC消息认证码时，需要使用表中“支持种类”一列，指定HMAC消息认证码算法规格。
| 摘要算法 | 支持种类 | API版本 |
| --- | --- | --- |
| HASH | SHA1 | 9+ |
| HASH | SHA224 | 9+ |
| HASH | SHA256 | 9+ |
| HASH | SHA384 | 9+ |
| HASH | SHA512 | 9+ |
| HASH | SM3 | 10+ |
| HASH | MD5 | 12+ |
开发步骤
在调用update接口传入数据时，可以一次性传入所有数据，也可以把数据人工分段，然后分段update。对于同一段数据而言，是否分段，计算结果没有差异。对于数据量较大的数据，开发者可以根据实际需求选择是否分段传入。
下面分别提供两种方式的示例代码。
HMAC（一次性传入）
1.  调用cryptoFramework.createMac，指定摘要算法SHA256，生成消息认证码实例（Mac）。
2.  调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.convertKey，生成密钥算法为HMAC的对称密钥（SymKey）。 生成对称密钥的详细开发指导，请参考指定二进制数据生成对称密钥。
3.  调用Mac.init，指定共享对称密钥（SymKey），初始化Mac对象。
4.  调用Mac.update，传入自定义消息，进行消息认证码计算。单次update长度没有限制。
5.  调用Mac.doFinal，获取Mac计算结果。
6.  调用Mac.getMacLength，获取Mac消息认证码的长度，单位为字节。
-  以使用await方式一次性传入数据，获取消息认证码计算结果为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
async function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('HMAC');
let symKey = await aesGenerator.convertKey(symKeyBlob);
console.info('convertKey success');
return symKey;
}
async function doHmac() {
// 把字符串按utf-8解码为Uint8Array，使用固定的128位的密钥，即16字节
let keyData = new Uint8Array(buffer.from("12345678abcdefgh", 'utf-8').buffer);
let key = await genSymKeyByData(keyData);
let macAlgName = 'SHA256'; // 摘要算法名
let message = 'hmacTestMessgae'; // 待进行HMAC的数据
let mac = cryptoFramework.createMac(macAlgName);
await mac.init(key);
// 数据量较少时，可以只做一次update，将数据全部传入，接口未对入参长度做限制
await mac.update({ data: new Uint8Array(buffer.from(message, 'utf-8').buffer) });
let macResult = await mac.doFinal();
console.info('HMAC result:' + macResult.data);
let macLen = mac.getMacLength();
console.info('HMAC len:' + macLen);
}
```
-  以使用同步方式一次性传入数据，获取消息认证码计算结果为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('HMAC');
let symKey =  aesGenerator.convertKeySync(symKeyBlob);
console.info('[Sync]convertKey success');
return symKey;
}
function doHmacBySync() {
// 把字符串按utf-8解码为Uint8Array，使用固定的128位的密钥，即16字节
let keyData = new Uint8Array(buffer.from("12345678abcdefgh", 'utf-8').buffer);
let key = genSymKeyByData(keyData);
let macAlgName = 'SHA256'; // 摘要算法名
let message = 'hmacTestMessgae'; // 待进行HMAC的数据
let mac = cryptoFramework.createMac(macAlgName);
mac.initSync(key);
// 数据量较少时，可以只做一次update，将数据全部传入，接口未对入参长度做限制
mac.updateSync({ data: new Uint8Array(buffer.from(message, 'utf-8').buffer) });
let macResult = mac.doFinalSync();
console.info('[Sync]HMAC result:' + macResult.data);
let macLen = mac.getMacLength();
console.info('HMAC len:' + macLen);
}
```
分段HMAC
1.  调用cryptoFramework.createMac，指定摘要算法SHA256，生成消息认证码实例（Mac）。
2.  调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.convertKey，生成密钥算法为HMAC的对称密钥（SymKey）。 生成对称密钥的详细开发指导，请参考指定二进制数据生成对称密钥。
3.  调用Mac.init，指定共享对称密钥（SymKey），初始化Mac对象。
4.  传入自定义消息，将一次传入数据量设置为20字节，多次调用Mac.update，进行消息认证码计算。
5.  调用Mac.doFinal，获取Mac计算结果。
6.  调用Mac.getMacLength，获取Mac消息认证码的长度，单位为字节。
-  以使用await方式分段传入数据，获取消息认证码计算结果为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
async function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('HMAC');
let symKey = await aesGenerator.convertKey(symKeyBlob);
console.info('convertKey success');
return symKey;
}
async function doLoopHmac() {
// 把字符串按utf-8解码为Uint8Array，使用固定的128位的密钥，即16字节
let keyData = new Uint8Array(buffer.from("12345678abcdefgh", 'utf-8').buffer);
let key = await genSymKeyByData(keyData);
let macAlgName = "SHA256"; // 摘要算法名
let mac = cryptoFramework.createMac(macAlgName);
// 假设信息总共43字节，根据utf-8解码后，也是43字节
let messageText = "aaaaa.....bbbbb.....ccccc.....ddddd.....eee";
let messageData = new Uint8Array(buffer.from(messageText, 'utf-8').buffer);
let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求
await mac.init(key);
for (let i = 0; i < messageData.length; i += updateLength) {
let updateMessage = messageData.subarray(i, i + updateLength);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
await mac.update(updateMessageBlob);
}
let macOutput = await mac.doFinal();
console.info("HMAC result: " + macOutput.data);
let macLen = mac.getMacLength();
console.info('HMAC len:' + macLen);
}
```
-  以使用同步方式分段传入数据，获取消息认证码计算结果为例：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
function genSymKeyByData(symKeyData: Uint8Array) {
let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };
let aesGenerator = cryptoFramework.createSymKeyGenerator('HMAC');
let symKey = aesGenerator.convertKeySync(symKeyBlob);
console.info('[Sync]convertKey success');
return symKey;
}
function doLoopHmacBySync() {
// 把字符串按utf-8解码为Uint8Array，使用固定的128位的密钥，即16字节
let keyData = new Uint8Array(buffer.from("12345678abcdefgh", 'utf-8').buffer);
let key = genSymKeyByData(keyData);
let macAlgName = "SHA256"; // 摘要算法名
let mac = cryptoFramework.createMac(macAlgName);
// 假设信息总共43字节，根据utf-8解码后，也是43字节
let messageText = "aaaaa.....bbbbb.....ccccc.....ddddd.....eee";
let messageData = new Uint8Array(buffer.from(messageText, 'utf-8').buffer);
let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求
mac.initSync(key);
for (let i = 0; i < messageData.length; i += updateLength) {
let updateMessage = messageData.subarray(i, i + updateLength);
let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };
mac.updateSync(updateMessageBlob);
}
let macOutput = mac.doFinalSync();
console.info("[Sync]HMAC result: " + macOutput.data);
let macLen = mac.getMacLength();
console.info('HMAC len:' + macLen);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-generate-random-number-V14
爬取时间: 2025-04-28 01:54:22
来源: Huawei Developer
从API version 12开始，轻量级智能穿戴设备支持获取随机数相关操作。
随机数主要用于临时会话密钥生成和非对称加密算法密钥生成等场景。在加解密场景中，安全随机数生成器需要具备随机性，不可预测性，与不可重现性。当前系统生成的随机数满足密码学安全伪随机性要求。
开发者可以调用接口，完成以下功能：
-  生成指定长度的安全随机数，并将其用于生成对应的密钥。
-  指定随机种子，生成一系列的随机序列。
在开发前，开发者应该先对加解密基础知识有一定了解，并熟知以下随机数相关的基本概念：
-  内部状态 代表随机数生成器内存中的数值，当内部状态相同时，随机数生成器会生成固定的随机数序列。
-  随机种子 一个用来对伪随机数的内部状态进行初始化的数据，随机数生成器通过种子来生成一系列的随机序列。 当前OpenSSL实现方式，随机数生成器内部状态是不断变化的，即使设置相同的种子，生成的随机数序列也不会相同。
支持的算法与规格
随机数生成算法使用OpenSSL的RAND_priv_bytes接口生成安全随机数。
| 算法 | 长度（Byte） |
| --- | --- |
| CTR_DRBG | [1, INT_MAX] |
开发步骤
1.  调用cryptoFramework.createRandom，生成随机数实例。
2.  (可选)设置DataBlob数据，调用Random.setSeed，为随机数生成池设置种子。
3.  设置指定字节长度，调用Random.generateRandom或Random.generateRandomSync，生成安全随机数。 指定字节长度范围为1~INT_MAX。
-  通过await返回异步结果：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
async function doRand() {
let rand = cryptoFramework.createRandom();
let seed = new Uint8Array([1, 2, 3]);
rand.setSeed({ data: seed });
let len = 12;
let randOutput = await rand.generateRandom(len);
console.info('rand output:' + randOutput.data);
}
```
-  同步返回结果：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { BusinessError } from '@kit.BasicServicesKit';
function doRandBySync() {
let rand = cryptoFramework.createRandom();
let len = 24; // Generate a 24-byte random number.
try {
let randData = rand.generateRandomSync(len);
if (randData !== null) {
console.info("[Sync]: rand result: " + randData.data);
} else {
console.error("[Sync]: get rand result fail!");
}
} catch (error) {
let e: BusinessError = error as BusinessError;
console.error(`do rand failed, ${e.code}, ${e.message}`);
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-derivation-V14
爬取时间: 2025-04-28 01:54:35
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-derivation-overview-V14
爬取时间: 2025-04-28 01:54:49
来源: Huawei Developer
密钥派生函数（key derivation function）是指使用伪随机函数从秘密值中导出一个或多个密钥。密钥派生函数可用于将密钥扩展到更长的密钥或获得所需格式的密钥。
PBKDF2算法
PBKDF（Password-Based Key Derivation Function）是具有可变计算成本的密钥派生函数，PBKDF2是PKCS系列的标准之一。
PBKDF2是将伪随机函数PRF（Pseudo-Random Function，例如基于散列的HMAC），输入密码明文和盐值，重复多次运算来进行密钥派生。
当前支持以字符串参数进行密钥派生，具体的“字符串参数”由“密钥派生函数”和“HMAC函数摘要算法”使用符号“|”拼接而成，用于在创建密钥派生函数生成器时，指定算法规格。
| 密钥派生算法 | HMAC函数摘要算法 | 字符串参数 | API版本 |
| --- | --- | --- | --- |
| PBKDF2 | SHA1 | PBKDF2|SHA1 | 11+ |
| PBKDF2 | SHA224 | PBKDF2|SHA224 | 11+ |
| PBKDF2 | SHA256 | PBKDF2|SHA256 | 11+ |
| PBKDF2 | SHA384 | PBKDF2|SHA384 | 11+ |
| PBKDF2 | SHA512 | PBKDF2|SHA512 | 11+ |
| PBKDF2 | SM3 | PBKDF2|SM3 | 11+ |
HKDF算法
HKDF（HMAC-based Extract-and-Expand Key Derivation Function，是基于HMAC）消息身份验证代码的简单密钥派生，输入原始的密钥材料和盐值来提取和输入原始的密钥材料和拓展信息来扩展。它是一种密钥派生函数，用于从较短的输入密钥中派生出更长的输出密钥。
HKDF包含三个模式，提取（EXTRACT_ONLY）、拓展（EXPAND_ONLY）、提取和拓展（EXTRACT_AND_EXPAND）
当前支持以字符串参数进行密钥派生，具体的“字符串参数”由“密钥派生函数”、“HMAC函数摘要算法”和“模式”使用符号“|”拼接而成，用于在创建密钥派生函数生成器时，指定算法规格。
| 密钥派生算法 | HMAC函数摘要算法 | 模式 | 字符串参数 | API版本 |
| --- | --- | --- | --- | --- |
| HKDF | SHA1 | [EXPAND_ONLY|EXTRACT_ONLY|EXTRACT_AND_EXPAND] | HKDF|SHA1 | 12+ |
| HKDF | SHA224 | [EXPAND_ONLY|EXTRACT_ONLY|EXTRACT_AND_EXPAND] | HKDF|SHA224 | 12+ |
| HKDF | SHA256 | [EXPAND_ONLY|EXTRACT_ONLY|EXTRACT_AND_EXPAND] | HKDF|SHA256 | 12+ |
| HKDF | SHA384 | [EXPAND_ONLY|EXTRACT_ONLY|EXTRACT_AND_EXPAND] | HKDF|SHA384 | 12+ |
| HKDF | SHA512 | [EXPAND_ONLY|EXTRACT_ONLY|EXTRACT_AND_EXPAND] | HKDF|SHA512 | 12+ |
| HKDF | SM3 | [EXPAND_ONLY|EXTRACT_ONLY|EXTRACT_AND_EXPAND] | HKDF|SM3 | 12+ |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-derivation-using-pbkdf2-V14
爬取时间: 2025-04-28 01:55:03
来源: Huawei Developer
对应的算法规格请查看密钥派生算法规格：PBKDF2。
开发步骤
1.  构造PBKDF2Spec对象，作为密钥派生参数进行密钥派生。 PBKDF2Spec是KdfSpec的子类，需要指定： password：用于生成派生密钥的原始密码。 如果使用string类型，需要直接传入用于密钥派生的数据，而不是HexString、base64等字符串类型。同时需要确保该字符串为utf-8编码，否则派生结果会有差异。
2.  password：用于生成派生密钥的原始密码。 如果使用string类型，需要直接传入用于密钥派生的数据，而不是HexString、base64等字符串类型。同时需要确保该字符串为utf-8编码，否则派生结果会有差异。
3.  调用cryptoFramework.createKdf，指定字符串参数'PBKDF2|SHA256'，创建密钥派生算法为PBKDF2、HMAC函数摘要算法为SHA256的密钥派生函数对象（Kdf）。
4.  输入PBKDF2Spec对象，调用Kdf.generateSecret进行密钥派生。 Kdf.generateSecret的多种调用形式如表所示。
-  password：用于生成派生密钥的原始密码。 如果使用string类型，需要直接传入用于密钥派生的数据，而不是HexString、base64等字符串类型。同时需要确保该字符串为utf-8编码，否则派生结果会有差异。
| 接口名 | 返回方式 |
| --- | --- |
| generateSecret(params: KdfSpec, callback: AsyncCallback<DataBlob>): void | callback异步生成 |
| generateSecret(params: KdfSpec): Promise<DataBlob> | Promise异步生成 |
| generateSecretSync(params: KdfSpec): DataBlob | 同步生成 |
-  通过await返回结果：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
async function kdfAwait() {
let spec: cryptoFramework.PBKDF2Spec = {
algName: 'PBKDF2',
password: '123456',
salt: new Uint8Array(16),
iterations: 10000,
keySize: 32
};
let kdf = cryptoFramework.createKdf('PBKDF2|SHA256');
let secret = await kdf.generateSecret(spec);
console.info("key derivation output is " + secret.data);
}
```
-  通过Promise返回结果：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { BusinessError } from '@kit.BasicServicesKit';
function kdfPromise() {
let spec: cryptoFramework.PBKDF2Spec = {
algName: 'PBKDF2',
password: '123456',
salt: new Uint8Array(16),
iterations: 10000,
keySize: 32
};
let kdf = cryptoFramework.createKdf('PBKDF2|SHA256');
let kdfPromise = kdf.generateSecret(spec);
kdfPromise.then((secret) => {
console.info("key derivation output is " + secret.data);
}).catch((error: BusinessError) => {
console.error("key derivation error.");
});
}
```
-  通过同步方式返回结果：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { BusinessError } from '@kit.BasicServicesKit';
function kdfSync() {
let spec: cryptoFramework.PBKDF2Spec = {
algName: 'PBKDF2',
password: '123456',
salt: new Uint8Array(16),
iterations: 10000,
keySize: 32
};
let kdf = cryptoFramework.createKdf('PBKDF2|SHA256');
let secret = kdf.generateSecretSync(spec);
console.info("[Sync]key derivation output is " + secret.data);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-key-derivation-using-hkdf-V14
爬取时间: 2025-04-28 01:55:16
来源: Huawei Developer
对应算法规格请查看密钥派生算法规格：HKDF。
开发步骤
1.  构造HKDFSpec对象，作为密钥派生参数进行密钥派生。 HKDFSpec是KdfSpec的子类，需要指定： key：原始密钥材料。 如果使用string类型，需要直接传入用于密钥派生的数据，而不是HexString、base64等字符串类型。同时需要确保该字符串为utf-8编码，否则派生结果会有差异。
2.  key：原始密钥材料。 如果使用string类型，需要直接传入用于密钥派生的数据，而不是HexString、base64等字符串类型。同时需要确保该字符串为utf-8编码，否则派生结果会有差异。
3.  调用cryptoFramework.createKdf，指定字符串参数'HKDF|SHA256|EXTRACT_AND_EXPAND'，创建密钥派生算法为HKDF、HMAC函数摘要算法为SHA256、模式为提取和拓展的密钥派生函数对象（Kdf）。
4.  输入HKDFSpec对象，调用Kdf.generateSecret进行密钥派生。 Kdf.generateSecret的多种调用形式如表所示。
-  key：原始密钥材料。 如果使用string类型，需要直接传入用于密钥派生的数据，而不是HexString、base64等字符串类型。同时需要确保该字符串为utf-8编码，否则派生结果会有差异。
| 接口名 | 返回方式 |
| --- | --- |
| generateSecret(params: KdfSpec, callback: AsyncCallback<DataBlob>): void | callback异步生成 |
| generateSecret(params: KdfSpec): Promise<DataBlob> | Promise异步生成 |
| generateSecretSync(params: KdfSpec): DataBlob | 同步生成 |
-  通过await返回结果：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { buffer } from '@kit.ArkTS';
async function kdfAwait() {
let keyData = new Uint8Array(buffer.from("012345678901234567890123456789", "utf-8").buffer);
let saltData = new Uint8Array(buffer.from("0123456789", "utf-8").buffer);
let infoData = new Uint8Array(buffer.from("infostring", "utf-8").buffer);
let spec: cryptoFramework.HKDFSpec = {
algName: 'HKDF',
key: keyData,
salt: saltData,
info: infoData,
keySize: 32
};
let kdf = cryptoFramework.createKdf('HKDF|SHA256|EXTRACT_AND_EXPAND');
let secret = await kdf.generateSecret(spec);
console.info("key derivation output is " + secret.data);
}
```
-  通过Promise返回结果：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { buffer } from '@kit.ArkTS';
function kdfPromise() {
let keyData = new Uint8Array(buffer.from("012345678901234567890123456789", "utf-8").buffer);
let saltData = new Uint8Array(buffer.from("0123456789", "utf-8").buffer);
let infoData = new Uint8Array(buffer.from("infostring", "utf-8").buffer);
let spec: cryptoFramework.HKDFSpec = {
algName: 'HKDF',
key: keyData,
salt: saltData,
info: infoData,
keySize: 32
};
let kdf = cryptoFramework.createKdf('HKDF|SHA256|EXTRACT_AND_EXPAND');
let kdfPromise = kdf.generateSecret(spec);
kdfPromise.then((secret) => {
console.info("key derivation output is " + secret.data);
}).catch((error: BusinessError) => {
console.error("key derivation error.");
});
}
```
-  通过同步方式返回结果：
```typescript
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { buffer } from '@kit.ArkTS';
function kdfSync() {
let keyData = new Uint8Array(buffer.from("012345678901234567890123456789", "utf-8").buffer);
let saltData = new Uint8Array(buffer.from("0123456789", "utf-8").buffer);
let infoData = new Uint8Array(buffer.from("infostring", "utf-8").buffer);
let spec: cryptoFramework.HKDFSpec = {
algName: 'HKDF',
key: keyData,
salt: saltData,
info: infoData,
keySize: 32
};
let kdf = cryptoFramework.createKdf('HKDF|SHA256|EXTRACT_AND_EXPAND');
let secret = kdf.generateSecretSync(spec);
console.info("[Sync]key derivation output is " + secret.data);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/crypto-development-practice-V14
爬取时间: 2025-04-28 01:55:30
来源: Huawei Developer
开发者可以参考以下开发实践，学习相关场景开发，在HarmonyOS平台上更高效、准确地开发加解密的功能。
加解密跨平台数据兼容性开发实践
为确保数据安全，在数据传输过程中对数据进行加解密操作至关重要。为确保跨平台数据兼容，实现加密和解密操作在不同环境下的一致性和互操作性，同样极为关键。加解密跨平台数据兼容性开发实践将从以下两方面讲解如何适配差异：
-  鉴于加解密往往会跨平台操作，例如服务端加密的数据需要在移动设备上解密，而HarmonyOS平台的加解密API要求密钥和待处理的数据必须为Uint8Array格式。为此，需要将Uint8Array字节数据与其他编码格式数据相转换，确保编码格式的一致性。 当前开发实践将提供多种数据格式之间的转换方法。
-  不同平台都会支持相同的算法，但不同平台的加解密算法可能在使用时有所不同，这些差异可能会导致加解密无法正常的跨平台使用。 当前开发实践将以SM2、AES为例，讲解HarmonyOS平台与其他平台在加解密过程中的差异。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/data-protection-kit-V14
爬取时间: 2025-04-28 01:55:43
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dlp-V14
爬取时间: 2025-04-28 01:55:56
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dlp-overview-V14
爬取时间: 2025-04-28 01:56:10
来源: Huawei Developer
数据防泄漏服务（Data Loss Prevention，简称为DLP），是系统提供的系统级的数据防泄漏解决方案，提供文件权限管理、加密存储、授权访问等能力，数据所有者可以基于账号认证对机密文件进行权限配置，允许拥有只读、编辑、拥有者权限，随后机密文件会通过密文存储，在支持DLP机制的设备上可以通过端云协调进行认证授权，获取对数据的访问和修改的能力。
DLP是系统级别的，应用开发者只需要做少量的适配甚至无需适配，即可获得完整的数据防泄漏保护。
DLP整体解决方案有3个主要部件构成。
-  DLP权限管理部件： 权限管理底层服务，负责沙箱应用创建、凭据管理交互。
-  DLP管理应用部件： 负责实现权限在本地的设置、检验和拦截功能；是最终实现用户可感知的受控分享功能的关键载体。
-  云端对接模块：（该模块当前需要开发者自行搭建） 负责将DLP文件的证书，发往云端完成基于账号的鉴权，证书生成及解密功能。
运作流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170440.87244431599874069639752240171489:50001231000000:2800:BF1F2D1B87465AE4F17E5D6B5E4790FB0E1F1FE8F37197A631D3BA29C3ACC3C7.png)
DLP文件生成
DLP文件发送
DLP文件打开

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dlp-guidelines-V14
爬取时间: 2025-04-28 01:56:23
来源: Huawei Developer
DLP是系统提供的系统级的数据防泄漏解决方案，提供一种称为DLP的文件格式。后缀格式为“原始文件名（包含原始文件后缀）.dlp”，例如“test.docx.dlp”，文件由授权凭证和原始文件密文组成。
通过端云协同认证（需要联网）来获取文件的访问授权，授权类型包含只读、编辑、文件拥有者三种。
应用需要访问DLP文件时，系统会自动安装应用的DLP沙箱分身应用，相当于完全独立的应用，数据和配置会继承原应用，但相互之间并不共享。分身应用在运行时会处于DLP沙箱环境中，访问外部的权限会被限制，以防止数据的泄漏。每当打开一个新的DLP文件会生成一个应用沙箱分身，沙箱应用之间也是相互隔离的，当应用关闭后应用分身会自动卸载，沙箱期间产生的临时数据也会丢弃。
正常情况下，应用不会感知到沙箱的存在，访问的也是解密后的明文，和访问普通文件没有区别，但由于DLP沙箱会限制其访问外部的权限（例如网络、剪切板、截屏、录屏、蓝牙等）。为了更好的用户体验，需要应用进行适配，例如文件只读的情况下，不应显示“保存”按钮，不应主动联网等。
沙箱限制
当应用进入DLP沙箱状态时，可以申请的权限将受到限制，根据DLP文件授权类型不同，限制也不相同，如下表：
| 权限名  | 说明  | 授权类型：只读  | 授权类型：编辑/文件拥有者  |
| --- | --- | --- | --- |
| ohos.permission.USE_BLUETOOTH  | 允许应用使用蓝牙。  | 禁止  | 禁止  |
| ohos.permission.INTERNET  | 允许应用访问网络。  | 禁止  | 禁止  |
| ohos.permission.DISTRIBUTED_DATASYNC  | 允许应用与远程设备交换用户数据（如图片、音乐、视频、及应用数据等）。  | 禁止  | 禁止  |
| ohos.permission.WRITE_MEDIA  | 应用读写用户媒体文件，如视频、音频、图片等，需要申请此权限。  | 禁止  | 允许  |
| ohos.permission.NFC_TAG  | 允许应用使用NFC。  | 禁止  | 允许  |
权限名
说明
授权类型：只读
授权类型：编辑/文件拥有者
ohos.permission.USE_BLUETOOTH
允许应用使用蓝牙。
禁止
禁止
ohos.permission.INTERNET
允许应用访问网络。
禁止
禁止
ohos.permission.DISTRIBUTED_DATASYNC
允许应用与远程设备交换用户数据（如图片、音乐、视频、及应用数据等）。
禁止
禁止
ohos.permission.WRITE_MEDIA
应用读写用户媒体文件，如视频、音频、图片等，需要申请此权限。
禁止
允许
ohos.permission.NFC_TAG
允许应用使用NFC。
禁止
允许
接口说明
| 接口名  | 描述  |
| --- | --- |
| isDLPFile(fd: number): Promise<boolean> isDLPFile(fd: number, callback: AsyncCallback<boolean>): void  | 判断是否是dlp文件。  |
| getDLPPermissionInfo(): Promise<DLPPermissionInfo> getDLPPermissionInfo(callback: AsyncCallback<DLPPermissionInfo>): void  | 获取当前沙箱应用的权限类型。  |
| getOriginalFileName(fileName: string): string  | 获取dlp文件原始文件名。  |
| getDLPSuffix(): string  | 获取dlp文件dlp后缀名。  |
| on(type: 'openDLPFile', listener: Callback<AccessedDLPFileInfo>): void  | 注册dlp文件打开事件监听，用于原始应用获取dlp文件打开事件。  |
| off(type: 'openDLPFile', listener?: Callback<AccessedDLPFileInfo>): void  | 取消dlp文件打开事件监听。  |
| isInSandbox(): Promise<boolean> isInSandbox(callback: AsyncCallback<boolean>): void  | 判断当前是否是dlp沙箱应用。  |
| getDLPSupportedFileTypes(): Promise<Array<string>> getDLPSupportedFileTypes(callback: AsyncCallback<Array<string>>): void  | 获取当前系统支持添加权限保护的文件格式类型。  |
| setRetentionState(docUris: Array<string>): Promise<void> setRetentionState(docUris: Array<string>, callback: AsyncCallback<void>): void  | 设置dlp分身应用保留状态。  |
| cancelRetentionState(docUris: Array<string>): Promise<void> cancelRetentionState(docUris: Array<string>, callback: AsyncCallback<void>): void  | 取消dlp分享应用保留状态。  |
| getRetentionSandboxList(bundleName?: string): Promise<Array<RetentionSandboxInfo>> getRetentionSandboxList(bundleName: string, callback: AsyncCallback<Array<RetentionSandboxInfo>>): void getRetentionSandboxList(callback: AsyncCallback<Array<RetentionSandboxInfo>>): void  | 获取当前保留沙箱列表。  |
| getDLPFileAccessRecords(): Promise<Array<AccessedDLPFileInfo>> getDLPFileAccessRecords(callback: AsyncCallback<Array<AccessedDLPFileInfo>>): void  | 获取dlp文件访问记录。  |
| setSandboxAppConfig(configInfo: string): Promise<void>  | 设置沙箱应用配置信息。  |
| getSandboxAppConfig(): Promise<string>  | 查询沙箱应用配置信息。  |
| cleanSandboxAppConfig(): Promise<void>  | 清理沙箱应用配置信息。  |
| startDLPManagerForResult(context: common.UIAbilityContext, want: Want): Promise<DLPManagerResult>  | 在当前UIAbility界面以无边框形式打开DLP权限管理应用（只支持Stage模型）。  |
接口名
描述
isDLPFile(fd: number): Promise<boolean>
isDLPFile(fd: number, callback: AsyncCallback<boolean>): void
判断是否是dlp文件。
getDLPPermissionInfo(): Promise<DLPPermissionInfo>
getDLPPermissionInfo(callback: AsyncCallback<DLPPermissionInfo>): void
获取当前沙箱应用的权限类型。
getOriginalFileName(fileName: string): string
获取dlp文件原始文件名。
getDLPSuffix(): string
获取dlp文件dlp后缀名。
on(type: 'openDLPFile', listener: Callback<AccessedDLPFileInfo>): void
注册dlp文件打开事件监听，用于原始应用获取dlp文件打开事件。
off(type: 'openDLPFile', listener?: Callback<AccessedDLPFileInfo>): void
取消dlp文件打开事件监听。
isInSandbox(): Promise<boolean>
isInSandbox(callback: AsyncCallback<boolean>): void
判断当前是否是dlp沙箱应用。
getDLPSupportedFileTypes(): Promise<Array<string>>
getDLPSupportedFileTypes(callback: AsyncCallback<Array<string>>): void
获取当前系统支持添加权限保护的文件格式类型。
setRetentionState(docUris: Array<string>): Promise<void>
setRetentionState(docUris: Array<string>, callback: AsyncCallback<void>): void
设置dlp分身应用保留状态。
cancelRetentionState(docUris: Array<string>): Promise<void>
cancelRetentionState(docUris: Array<string>, callback: AsyncCallback<void>): void
取消dlp分享应用保留状态。
getRetentionSandboxList(bundleName?: string): Promise<Array<RetentionSandboxInfo>>
getRetentionSandboxList(bundleName: string, callback: AsyncCallback<Array<RetentionSandboxInfo>>): void
getRetentionSandboxList(callback: AsyncCallback<Array<RetentionSandboxInfo>>): void
获取当前保留沙箱列表。
getDLPFileAccessRecords(): Promise<Array<AccessedDLPFileInfo>>
getDLPFileAccessRecords(callback: AsyncCallback<Array<AccessedDLPFileInfo>>): void
获取dlp文件访问记录。
setSandboxAppConfig(configInfo: string): Promise<void>
设置沙箱应用配置信息。
getSandboxAppConfig(): Promise<string>
查询沙箱应用配置信息。
cleanSandboxAppConfig(): Promise<void>
清理沙箱应用配置信息。
startDLPManagerForResult(context: common.UIAbilityContext, want: Want): Promise<DLPManagerResult>
在当前UIAbility界面以无边框形式打开DLP权限管理应用（只支持Stage模型）。
开发步骤
DLP作为HarmonyOS系统级数据防泄漏方案，可以让应用在零适配或低代码适配的情况下接入DLP能力，打开DLP文件。
当用户使用默认应用或指定应用打开DLP文件时，DLP框架将会完成：
实现DLP沙箱分身在无感加解密流程下访问DLP文件解密后的内容。
当三方应用接入DLP（支持打开DLP文件）时，为了更优的体验，可从以下方面完成适配。
预置操作
应用接入DLP能力，支持被安装为DLP沙箱分身应用，打开DLP文件，需要具备以下条件：
```typescript
".doc", ".docm", ".docx", ".dot", ".dotm", ".dotx", ".odp", ".odt", ".pdf", ".pot", ".potm", ".potx", ".ppa",
".ppam", ".pps", ".ppsm", ".ppsx", ".ppt", ".pptm", ".pptx", ".rtf", ".txt", ".wps", ".xla", ".xlam", ".xls",
".xlsb", ".xlsm", ".xlsx", ".xlt", ".xltm", ".xltx", ".xlw", ".xml", ".xps"
```
-  使用的设备需要具备域账号环境。
导入模块
引入dlpPermission模块。
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
```
应用支持打开DLP文件绑定的FUSE文件
一般情况下，应用如果支持打开预置操作中指定文件类型的文件，没有对传入的Want做特定限制的情况下，不需要适配即可打开FUSE文件。
打开DLP文件时，应用被安装为DLP沙箱分身应用（后续简称为分身），分身会收到want请求，分身可以对其中一些字段进行解析：
```typescript
import Want from '@ohos.app.ability.Want';
interface DLPUriObj {
name: string
};
interface DLPWriteable {
name:boolean
};
interface DLPNameObj {
dateModified: string,
displayName: string,
relativePath: string,
};
interface DLPLinkNameObj {
name: string
};
function getParams(want: Want) {
// 接收打开DLP文件传过来的参数
let dlpFuseUri: string = want.uri? want.uri : '';  // FUSE文件的uri, 存放解密后的明文
let dlpFuseWriteable: boolean = (want.parameters?.linkFileWriteable as DLPWriteable).name; // 对FUSE文件是否有写权限
let dlpUri: string = (want.parameters?.dlpUri as DLPUriObj).name; // DLP文件的uri
let dlpName: string = (want.parameters?.fileAsset as DLPNameObj).displayName; // DLP文件的文件名
let dlpFuseName: string = (want.parameters?.linkFileName as DLPLinkNameObj).name; // FUSE文件的文件名
}
```
分身可以通过把want.uri打开为fd，获取FUSE文件的内容：
```typescript
import fileIo from '@ohos.fileio';
import fs from '@ohos.file.fs';
import util from '@ohos.util';
function readFileContent(dlpFuseUri:string): string {
let content: string = '';
let file: fs.File;
try {
file = fs.openSync(dlpFuseUri, fs.OpenMode.READ_ONLY); // 打开FUSE文件获取fd
this.commonFd = file.fd;
} catch (err) {
console.error('openSync failed. ' + err);
return content;
}
try {
let buffer = new ArrayBuffer(4096);
let readOut = fs.readSync(this.commonFd, buffer, { // 读取文件内容
offset: 0
});
content = bufferToString(buffer); // 文件内容转换成string类型
} catch (err) {
console.error('readSync failed. ' + err);
}
fileIo.closeSync(this.commonFd); // 关闭文件
return content;
}
function bufferToString(buffer: ArrayBuffer): string {
let textDecoder = new util.TextDecoder('utf-8', {
ignoreBOM: true
});
let resultPut = textDecoder.decodeWithStream(new Uint8Array(buffer), {
stream: true
});
return resultPut;
}
```
如果有FUSE文件的读写权限，也可以更新FUSE文件内容：
```typescript
import fs from '@ohos.file.fs';
function writeFileContent(dlpFuseUri: string, content: string): void {
let file: fs.File = fs.openSync(dlpFuseUri, fs.OpenMode.READ_WRITE); // 以读写权限打开FUSE文件获取fd
let writeLen: number = fs.writeSync(file.fd, content);  // 把内容写回FUSE文件中
fs.closeSync(file); // 关闭文件
}
```
应用根据DLP文件的权限对界面进行适配
DLP沙箱分身中可以调用getDLPPermissionInfo方法查询当前系统登陆的域账号用户对本DLP文件的用户权限和操作权限，不同用户权限可以对应不同的对文档的操作权限。
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
dlpPermission.getDLPPermissionInfo().then((data: dlpPermission.DLPPermissionInfo)=> {
let userAccess: dlpPermission.DLPPermissionInfo.DLPFileAccess = data.dlpFileAccess; // 用户对本DLP文件的用户权限
let isEditable: number = data.flags & dlpPermission.DLPPermissionInfo.ACTION_EDIT; // 用户对本DLP文件的操作权限
}).catch((err: BusinessError) => {
console.error('getDLPPermissionInfo: ' + JSON.stringify(err));
});
```
getDLPPermissionInfo返回的data为DLPPermissionInfo类型，其中dlpFileAccess表示用户权限，flags表示操作权限的按位组合的结果。可以根据返回的flags字段对照ActionFlagType判断DLP沙箱分身是否具有对应的操作权限，可以用于界面按钮置灰操作等。
应用与DLP沙箱分身数据共享
DLP沙箱分身是普通应用的分身，所有数据都是全新的，如果二者之间有些数据需要实现共享，可以通过DLP框架提供的应用与DLP沙箱分身数据共享机制实现。一种典型的使用场景是原应用与DLP沙箱分身之间共用是否已经弹出过隐私声明弹框的配置信息。
一般包括下面四种读写配置信息前后顺序组合：
约束与限制
具体步骤
1.  把需要保存的配置信息转成string类型，调用setSandboxAppConfig接口设置配置信息。 普通应用和DLP沙箱分身都可以调用该接口，但DLP沙箱分身必须在读取DLP文件内容之前才允许调用。
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
async function setSandboxAppConfig() {
try {
await dlpPermission.setSandboxAppConfig('configInfo'); // 设置配置信息
} catch (err) {
console.error('setSandboxAppConfig error, ', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
}
```
2.  调用cleanSandboxAppConfig接口清理该应用的所有配置信息。 该接口只允许普通应用中调用。
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
async function cleanSandboxAppConfig() {
try {
await dlpPermission.cleanSandboxAppConfig(); // 清理配置信息
} catch (err) {
console.error('cleanSandboxAppConfig error, ', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
}
```
3.  调用getSandboxAppConfig查询该应用的所有配置信息。 普通应用和DLP沙箱分身都可以调用。
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
async function getSandboxAppConfig() {
try {
let res:string = await dlpPermission.getSandboxAppConfig(); // 查询配置信息
} catch (err) {
console.error('getSandboxAppConfig error, ', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
}
```
应用支持更新最近打开记录
当应用有最近打开记录场景时，可以使用DLP框架提供的接口适配最近打开记录。可从以下场景适配：
-  仅有DLP沙箱分身有打开DLP文件场景：普通应用启动时，可以通过接口获取到历史通过本应用的DLP沙箱分身打开的DLP文件。
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
async function getDLPFileAccessRecords() {
try {
let res:Array<dlpPermission.AccessedDLPFileInfo> = await dlpPermission.getDLPFileAccessRecords(); // 获取DLP访问列表
console.info('res', JSON.stringify(res))
} catch (err) {
console.error('error', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
}
```
-  DLP沙箱分身有打开DLP文件场景：普通应用可以订阅本应用的DLP沙箱分身打开DLP文件的事件。
```typescript
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
export default class TestAbility extends UIAbility {
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
this.subscribe();
}
onDestroy(): void {
this.unSubscribe();
}
event(info: dlpPermission.AccessedDLPFileInfo) {
console.info('openDlpFile event', info.uri, info.lastOpenTime)
}
unSubscribe() {
try {
dlpPermission.off('openDLPFile', this.event); // 取消订阅
} catch (err) {
console.error('error', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
}
subscribe() {
try {
dlpPermission.on('openDLPFile', this.event); // 订阅
} catch (err) {
console.error('error', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
}
}
```
应用内支持打开选定的DLP文件
应用可以支持从最近打开列表、文件选择器中选择DLP文件，打开DLP文件的场景，按如下流程适配：
1.  设置Want参数，指定action为"ohos.want.action.viewData"，bundleName、abilityName分别为选择打开DLP文件的应用的bundleName、abilityName，uri为需要打开的DLP文件的uri，在parameters中设置fileName的name值为DLP文件的文件名。
2.  获取UIAbilityContext的context。
3.  调用context的startAbility方法传入want参数，打开dlp文件。
```typescript
import { Want } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import common from '@ohos.app.ability.common';
function openDlpFile(dlpUri: string, fileName: string) {
let want: Want = {
"action": "ohos.want.action.viewData",
"bundleName": "com.example.example_bundle_name",
"abilityName": "exampleAbility",
"uri": dlpUri,
"parameters": {
"fileName": {
"name": fileName
}
}
}
let context = getContext() as common.UIAbilityContext; // 获取当前UIAbilityContext
try {
console.log('openDLPFile:' + JSON.stringify(want));
console.log('openDLPFile: delegator:' + JSON.stringify(context));
context.startAbility(want);
} catch (err) {
console.error('openDLPFile startAbility failed', (err as BusinessError).code, (err as BusinessError).message);
return;
}
}
```
应用内支持对DLP文件权限设置
应用内可以集成权限设置按钮，当已打开一个普通文件后，点击权限设置按钮，拉起DLP管理应用的模态设置权限页面，生成DLP文件。也可以在DLP沙箱分身中查看当前正在打开的DLP文件的操作权限。
-  以无边框形式打开DLP权限管理应用。 此方法只能在UIAbility上下文中调用，只支持Stage模式。 want参数中uri的值为普通文件uri，parameters.displayName为文件名，这两个值为必传参数。 调用dlpPermission.startDLPManagerForResult拉起DLP管理应用的设置权限页面，输入相关的域账号信息，点击保存，在拉起的filepicker中选择DLP文件的保存路径，保存DLP文件。 调用以下代码：
```typescript
import { common, Want } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { dlpPermission } from '@kit.DataLossPreventionKit';
try {
let fileUri: string = "file://docs/storage/Users/currentUser/test.txt";
let fileName: string = "test.txt";
let context = getContext() as common.UIAbilityContext; // 获取当前UIAbilityContext
let want: Want = {
'uri': fileUri,
'parameters': {
'displayName': fileName
}
}; // 请求参数
dlpPermission.startDLPManagerForResult(context, want).then((res: dlpPermission.DLPManagerResult) => {
console.info('startDLPManagerForResult res.resultCode:' + res.resultCode);
console.info('startDLPManagerForResult res.want:' + JSON.stringify(res.want));
}); // 拉起DLP权限管理应用 设置权限
} catch (err) {
console.error('startDLPManagerForResult error:' + (err as BusinessError).code + (err as BusinessError).message);
}
```
-  此方法只能在UIAbility上下文中调用，只支持Stage模式。
-  want参数中uri的值为普通文件uri，parameters.displayName为文件名，这两个值为必传参数。
-  调用dlpPermission.startDLPManagerForResult拉起DLP管理应用的设置权限页面，输入相关的域账号信息，点击保存，在拉起的filepicker中选择DLP文件的保存路径，保存DLP文件。
```typescript
import { common, Want } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { dlpPermission } from '@kit.DataLossPreventionKit';
try {
let fileUri: string = "file://docs/storage/Users/currentUser/test.txt.dlp";// DLP文件的uri
let fileName: string = "test.txt.dlp";
let context = getContext() as common.UIAbilityContext; // 获取当前UIAbilityContext
let want: Want = {
'uri': fileUri,
'parameters': {
'displayName': fileName
}
}; // 请求参数
dlpPermission.startDLPManagerForResult(context, want).then((res: dlpPermission.DLPManagerResult) => {
console.info('startDLPManagerForResult res.resultCode:' + res.resultCode);
console.info('startDLPManagerForResult res.want:' + JSON.stringify(res.want));
}); // 拉起DLP权限管理应用 设置权限
} catch (err) {
console.error('startDLPManagerForResult error:' + (err as BusinessError).code + (err as BusinessError).message);
}
```
```typescript
import { common, Want } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { dlpPermission } from '@kit.DataLossPreventionKit';
try {
let fileUri: string = "file://docs/storage/Users/currentUser/test.txt.dlp";// DLP文件的uri
let fileName: string = "test.txt.dlp";
let context = getContext() as common.UIAbilityContext; // 获取当前UIAbilityContext
let want: Want = {
'uri': fileUri,
'parameters': {
'displayName': fileName
}
}; // 请求参数
dlpPermission.startDLPManagerForResult(context, want).then((res: dlpPermission.DLPManagerResult) => {
console.info('startDLPManagerForResult res.resultCode:' + res.resultCode);
console.info('startDLPManagerForResult res.want:' + JSON.stringify(res.want));
}); // 拉起DLP权限管理应用 设置权限
} catch (err) {
console.error('startDLPManagerForResult error:' + (err as BusinessError).code + (err as BusinessError).message);
}
```
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
dlpPermission.getDLPPermissionInfo().then((data:dlpPermission.DLPPermissionInfo)=> {
console.log('getDLPPermissionInfo, result: ' + JSON.stringify(data));
}).catch((err: BusinessError) => {
console.error('getDLPPermissionInfo: ' + JSON.stringify(err));
});
```
-  此方法只能在UIAbility上下文中调用，只支持Stage模式。
-  want参数中uri的值为普通文件uri，parameters.displayName为文件名，这两个值为必传参数。
-  调用dlpPermission.startDLPManagerForResult拉起DLP管理应用的设置权限页面，输入相关的域账号信息，点击保存，在拉起的filepicker中选择DLP文件的保存路径，保存DLP文件。
```typescript
import { common, Want } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { dlpPermission } from '@kit.DataLossPreventionKit';
try {
let fileUri: string = "file://docs/storage/Users/currentUser/test.txt.dlp";// DLP文件的uri
let fileName: string = "test.txt.dlp";
let context = getContext() as common.UIAbilityContext; // 获取当前UIAbilityContext
let want: Want = {
'uri': fileUri,
'parameters': {
'displayName': fileName
}
}; // 请求参数
dlpPermission.startDLPManagerForResult(context, want).then((res: dlpPermission.DLPManagerResult) => {
console.info('startDLPManagerForResult res.resultCode:' + res.resultCode);
console.info('startDLPManagerForResult res.want:' + JSON.stringify(res.want));
}); // 拉起DLP权限管理应用 设置权限
} catch (err) {
console.error('startDLPManagerForResult error:' + (err as BusinessError).code + (err as BusinessError).message);
}
```
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
dlpPermission.getDLPPermissionInfo().then((data:dlpPermission.DLPPermissionInfo)=> {
console.log('getDLPPermissionInfo, result: ' + JSON.stringify(data));
}).catch((err: BusinessError) => {
console.error('getDLPPermissionInfo: ' + JSON.stringify(err));
});
```
其他DLP能力增强
-  传入文件的fd查询对应文件是否是DLP文件，是DLP文件则按文档指导打开该文件。
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { fileIo } from '@kit.CoreFileKit';
import { BusinessError } from '@kit.BasicServicesKit';
let uri = "file://docs/storage/Users/currentUser/Desktop/test.txt.dlp";
let file = fileIo.openSync(uri);
try {
let res: boolean = dlpPermission.isDLPFile(file.fd); // 是否加密DLP文件
console.info('res', res);
} catch (err) {
console.error('error', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
fileIo.closeSync(file);
```
-  在应用中调用isInSandbox接口判断当前是否是DLP沙箱分身，如果是DLP沙箱分身则可以结合调用接口查询权限的结果进行对应功能按钮的置灰或屏蔽。比如：如果只有只读权限，则编辑保存入口可以置灰，如果是只读或者编辑权限，则修改权限入口可以置灰。
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
dlpPermission.isInSandbox().then((data: boolean)=> {
console.log('isInSandbox, result: ' + JSON.stringify(data));
}).catch((err: BusinessError) => {
console.error('isInSandbox: ' + JSON.stringify(err));
});
```
-  DLP沙箱分身关闭后会进行沙箱卸载，如果不希望DLP沙箱分身关闭时卸载该沙箱可以在沙箱中调用设置保留沙箱接口，只有当再次调用取消保留沙箱接口并关闭DLP沙箱分身才会触发沙箱的卸载。
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
async function setRetentionSandboxList() {
let docUris: Array<string>=["file://docs/storage/Users/currentUser/Desktop/test.txt.dlp"]
try {
await dlpPermission.setRetentionState(docUris); // 设置沙箱保留
} catch (err) {
console.error('error', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
}
```
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
async function setRetentionSandboxList() {
let docUris: Array<string>=["file://docs/storage/Users/currentUser/Desktop/test.txt.dlp"]
try {
await dlpPermission.setRetentionState(docUris); // 设置沙箱保留
} catch (err) {
console.error('error', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
}
```
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
async function setRetentionSandboxList() {
let docUris: Array<string>=["file://docs/storage/Users/currentUser/Desktop/test.txt.dlp"]
try {
await dlpPermission.cancelRetentionState(docUris); // 取消保留沙箱
} catch (err) {
console.error('error', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
}
```
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
async function getRetentionSandboxList() {
try {
let res:Array<dlpPermission.RetentionSandboxInfo> = await dlpPermission.getRetentionSandboxList(); // 获取保留沙箱记录
console.info('res', JSON.stringify(res))
} catch (err) {
console.error('error', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
}
```
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
async function setRetentionSandboxList() {
let docUris: Array<string>=["file://docs/storage/Users/currentUser/Desktop/test.txt.dlp"]
try {
await dlpPermission.setRetentionState(docUris); // 设置沙箱保留
} catch (err) {
console.error('error', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
}
```
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
async function setRetentionSandboxList() {
let docUris: Array<string>=["file://docs/storage/Users/currentUser/Desktop/test.txt.dlp"]
try {
await dlpPermission.cancelRetentionState(docUris); // 取消保留沙箱
} catch (err) {
console.error('error', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
}
```
```typescript
import { dlpPermission } from '@kit.DataProtectionKit';
import { BusinessError } from '@kit.BasicServicesKit';
async function getRetentionSandboxList() {
try {
let res:Array<dlpPermission.RetentionSandboxInfo> = await dlpPermission.getRetentionSandboxList(); // 获取保留沙箱记录
console.info('res', JSON.stringify(res))
} catch (err) {
console.error('error', (err as BusinessError).code, (err as BusinessError).message); // 失败报错
}
}
```
典型问题自排查
应用可以打开正常文件，无法打开FUSE文件

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/device-certificate-kit-V14
爬取时间: 2025-04-28 01:56:37
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/device-certificate-kit-intro-V14
爬取时间: 2025-04-28 01:56:51
来源: Huawei Developer
Device Certificate Kit（设备证书服务）面向应用开发者，提供了证书算法库和证书管理的能力。
证书算法库
证书算法库提供接口用于解析和验证数字证书。
证书算法库向应用提供证书、证书扩展域段、证书吊销列表的解析及校验能力，以及证书链的校验能力。
通过调用证书算法库框架接口，开发者可以忽略底层不同三方算法库的差异，实现迅捷开发。
常见使用场景
应用对接收的服务端证书或用户输入的证书进行解析，获取证书基本字段或扩展字段用于显示或校验，并使用CA证书链和CRL校验证书的合法性。
框架原理
系统提供证书算法库框架，开发者只需要调用API接口层即可实现证书的操作，通过证书算法库框架，可忽视不同三方算法库的差异。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170441.86368263141315363004167490730990:50001231000000:2800:740B54A7651E38DB0C419ED1A301027DB1D3CA279CB34FF7E2871945529DD5F8.png)
与相关Kit的关系
证书算法库的功能使用时，涉及公钥的生成和获取，这部分依赖Crypto Architecture Kit加解密算法框架服务的能力。
证书管理
证书管理主要提供系统级的证书管理能力，通过证书管理模块可以确保证书在传输和存储过程中的安全性，防止未经授权的访问和使用。
当前提供了应用私有凭据的安装、获取、使用及卸载能力。
通过证书管理能力，可以实现证书全生命周期（安装、存储、使用和销毁）的管理和安全使用。
常见使用场景
安装应用私有凭据，获取应用私有凭据，并使用应用私有凭据进行签名、验签，最后删除应用私有凭据。
与相关Kit的关系
证书管理的功能使用时，涉及凭据的安装和使用，这部分依赖Universal Keystore Kit密钥管理服务的能力。
约束与限制
Device Certificate Kit不具备生成或签发证书及证书吊销列表的能力。生成或签发证书及证书吊销列表的能力一般由证书颁发机构（CA）来完成，不由单个应用签发。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/certificate-framework-V14
爬取时间: 2025-04-28 01:57:04
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/certificate-framework-overview-V14
爬取时间: 2025-04-28 01:57:18
来源: Huawei Developer
证书算法库框架是一个屏蔽了第三方算法库实现差异的证书算法框架，向应用提供证书、证书扩展域段、证书吊销列表的创建、解析及校验能力，此外还提供了证书链的校验能力。
开发者可以通过调用证书算法库框架接口，忽略底层不同三方算法库的差异，实现迅捷开发。
本框架具备处理已有证书及证书吊销列表数据后处理的能力，并不具备生成或签发证书及证书吊销列表的能力，签发证书及证书吊销列表的能力一般由证书颁发机构（CA）来完成，不由单个应用签发。
基本概念
证书算法库框架提供X509证书的解析、序列化、X509证书签名验证、X509证书吊销列表、证书链校验器等相关的功能。
在开发具体的功能前，开发者需要先了解证书领域的一些基本概念。包括但不限于：
数字证书、数字证书标准X.509（本指导中的"X509"均代指的是X.509）、证书链、TBS（To Be Signed）、CRL（Certificate Revoked List）。
证书规格
证书相关规格说明如下所示。
证书链校验不包含对时间有效性的校验
由于端侧系统时间不可信，证书链校验不包含对证书有效时间的校验。如果需要检查证书的时间有效性，可使用X509证书的checkValidityWithDate()方法进行检查。
证书格式
目前仅支持DER与PEM格式的证书。
X509证书的基本结构
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170441.99425024416974884424348546779548:50001231000000:2800:7207B355C5E14F33C79199D292690BA9594D61F280DDF1CE450B60C734877DCC.png)
样例证书文件：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170441.96466288992182762813161710924374:50001231000000:2800:5A4B8A8B79DC1E6DC029E073BD7E353EEE9D950CA7E854420B0B417D2D5EA9C5.png)
X509证书吊销列表（CRL）基本结构
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170441.27648137196037010659564678766669:50001231000000:2800:6905E52B3A3DA0140D51F556D3223DEDC297A92A8CA1ED4CB82E574005ED5902.png)
样例CRL文件：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170441.62000630550683697479510980199688:50001231000000:2800:E16B8583EDD0511C853815DF84E661028D8BA3556418F3EBC9A003C3DC1E1AEE.png)
约束与限制
依赖加解密算法库框架的基础算法能力的部分，算法库框架不支持多线程并发操作，详情请参考加解密算法框架。
开发总览
证书算法库框架为开发者提供了以下相关功能的开发指导，请开发者参照开发。在开发前，请先查阅证书规格。
证书算法库框架主要提供了以下类，开发者可以查阅对应API参考，了解以下接口：
| 名称 | 类 | 功能 |
| --- | --- | --- |
| X509证书 | X509Cert | 提供X509证书的解析、序列化、X509证书签名验证、证书相关的信息查询等功能 |
| 证书扩展域段 | CertExtension | 提供X509证书中扩展域段的获取，如是否CA，CRL分发点等字段 |
| X509证书吊销列表 | X509CRL | 提供X509证书吊销列表的解析、序列化、信息查询等功能 |
| 证书链校验器 | CertChainValidator | 提供证书链校验（不包括证书有效期的校验）、证书链算法名称查询的功能 |
| 证书和证书吊销列表集合 | CertCRLCollection | 提供证书和证书吊销列表集合的查询功能 |
| X509证书链 | X509CertChain | 提供证书链校验、证书列表获取的功能 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/create-parse-verify-cert-object-V14
爬取时间: 2025-04-28 01:57:31
来源: Huawei Developer
以校验证书有效性为例，完成证书对象的创建、解析和校验。
开发步骤
1.  导入证书算法库框架模块。
```typescript
import { cert } from '@kit.DeviceCertificateKit';
```
2.  基于已有的X509证书数据，调用cert.createX509Cert创建证书对象。
3.  解析证书的字段信息。 此处以获取证书版本、证书序列号为例，更多字段信息获取接口请查看API参考文档。
4.  调用X509Cert.getPublicKey获取证书中的公钥，并调用X509Cert.verify校验签名。 示例为自验签场景，因此获取的是本证书中的公钥。应用须结合自身场景获取用于验签的公钥。
5.  调用X509Cert.checkValidityWithDate校验证书有效期。 入参date用于确认此日期是否在X509证书有效期内。
```typescript
import { cert } from '@kit.DeviceCertificateKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { util } from '@kit.ArkTS';
// 此处仅为示例的证书二进制数据，需根据业务的不同对证书数据进行赋值
let certData = '-----BEGIN CERTIFICATE-----\n' +
'MIIBLzCB1QIUO/QDVJwZLIpeJyPjyTvE43xvE5cwCgYIKoZIzj0EAwIwGjEYMBYG\n' +
'A1UEAwwPRXhhbXBsZSBSb290IENBMB4XDTIzMDkwNDExMjAxOVoXDTI2MDUzMDEx\n' +
'MjAxOVowGjEYMBYGA1UEAwwPRXhhbXBsZSBSb290IENBMFkwEwYHKoZIzj0CAQYI\n' +
'KoZIzj0DAQcDQgAEHjG74yMIueO7z3T+dyuEIrhxTg2fqgeNB3SGfsIXlsiUfLTa\n' +
'tUsU0i/sePnrKglj2H8Abbx9PK0tsW/VgqwDIDAKBggqhkjOPQQDAgNJADBGAiEA\n' +
'0ce/fvA4tckNZeB865aOApKXKlBjiRlaiuq5mEEqvNACIQDPD9WyC21MXqPBuRUf\n' +
'BetUokslUfjT6+s/X4ByaxycAA==\n' +
'-----END CERTIFICATE-----\n';
// 证书示例
function certSample(): void {
let textEncoder = new util.TextEncoder();
let encodingBlob: cert.EncodingBlob = {
// 将证书数据从string类型转换成Unit8Array
data: textEncoder.encodeInto(certData),
// 证书格式，仅支持PEM和DER。在此示例中，证书为PEM格式
encodingFormat: cert.EncodingFormat.FORMAT_PEM
};
// 创建X509Cert实例
cert.createX509Cert(encodingBlob, (err, x509Cert) => {
if (err != null) {
// 创建X509Cert实例失败
console.error(`createX509Cert failed, errCode:${err.code}, errMsg:${err.message}`);
return;
}
// X509Cert实例创建成功
console.log('createX509Cert success');
// 获取证书版本
let version = x509Cert.getVersion();
let serial = x509Cert.getCertSerialNumber();
console.log(`X509 version: ${version} , X509 serial:${serial}`);
// 使用上级证书对象的getPublicKey()方法或本（自签名）证书对象获取公钥对象
try {
let pubKey = x509Cert.getPublicKey();
// 验证证书签名
x509Cert.verify(pubKey, (err, data) => {
if (err == null) {
// 签名验证成功
console.log('verify success');
} else {
// 签名验证失败
console.error(`verify failed, errCode: ${err.code} , errMsg:${err.message}`);
}
});
} catch (error) {
let e: BusinessError = error as BusinessError;
console.error(`getPublicKey failed, errCode: ${e.code} , errMsg:${e.message}`);
}
// 用一个字符串代表时间
let date = '20230930000001Z';
// 验证证书的有效期
try {
x509Cert.checkValidityWithDate(date);
} catch (error) {
let e: BusinessError = error as BusinessError;
console.error(`checkValidityWithDate failed, errCode: ${e.code}, errMsg:${e.message}`);
}
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/create-parse-verify-certextension-object-V14
爬取时间: 2025-04-28 01:57:45
来源: Huawei Developer
以获取证书指定OID域段，并判断是否为CA证书为例，完成证书扩展信息对象的创建、解析和校验。
开发步骤
1.  导入证书算法库框架模块。
```typescript
import { cert } from '@kit.DeviceCertificateKit';
```
2.  解析证书扩展域段数据，调用cert.createCertExtension创建证书扩展域段对象。
3.  调用CertExtension.getEntry获取指定OID证书扩展域段信息。 比如，证书扩展域段对象标识符列表，根据对象标识符获取具体数据等。
4.  调用CertExtension.checkCA判断证书是否为CA证书。
```typescript
import { cert } from '@kit.DeviceCertificateKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { util } from '@kit.ArkTS';
// 证书扩展数据，以下只是一个示例。需要根据具体业务来赋值
let extData = new Uint8Array([
0x30, 0x40, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D,
0x13, 0x01, 0x01, 0xFF, 0x04, 0x05, 0x30, 0x03,
0x01, 0x01, 0xFF, 0x30, 0x0E, 0x06, 0x03, 0x55,
0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03,
0x02, 0x01, 0xC6, 0x30, 0x1D, 0x06, 0x03, 0x55,
0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0xE0, 0x8C,
0x9B, 0xDB, 0x25, 0x49, 0xB3, 0xF1, 0x7C, 0x86,
0xD6, 0xB2, 0x42, 0x87, 0x0B, 0xD0, 0x6B, 0xA0,
0xD9, 0xE4
]);
// 证书扩展示例
function certExtensionSample(): void {
let textEncoder = new util.TextEncoder();
let encodingBlob: cert.EncodingBlob = {
data: extData,
// 证书扩展格式，目前仅支持DER格式
encodingFormat: cert.EncodingFormat.FORMAT_DER
};
// 创建一个证书扩展实例
cert.createCertExtension(encodingBlob, (err, certExtension) => {
if (err != null) {
// 证书扩展实例创建失败
console.error(`createCertExtension failed, errCode:${err.code}, errMsg:${err.message} `);
return;
}
// 证书扩展实例创建成功
console.log('createCertExtension success');
try {
// 根据OID获取证书扩展信息
let oidData = '2.5.29.14';
let oid: cert.DataBlob = {
data: textEncoder.encodeInto(oidData),
}
let entry = certExtension.getEntry(cert.ExtensionEntryType.EXTENSION_ENTRY_TYPE_ENTRY, oid);
// 检查证书是否为CA证书
let pathLen = certExtension.checkCA();
console.log('test cert extension success');
} catch (err) {
let e: BusinessError = err as BusinessError;
console.error(`operation failed, message:${e.message} ,code:${e.code} `);
}
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/create-parse-verify-crl-object-V14
爬取时间: 2025-04-28 01:57:59
来源: Huawei Developer
以校验证书是否已吊销为例，完成证书吊销列表对象的创建、解析和校验。若证书已被吊销，将打印被吊销日期。
开发步骤
1.  导入证书算法库框架模块和加解密算法库模块。
```typescript
import { cert } from '@kit.DeviceCertificateKit';
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
```
2.  基于已有的CRL数据，调用cert.createX509CRL创建X509证书吊销列表的对象。
3.  解析证书吊销列表信息。 此处以获取证书吊销列表版本、证书吊销列表类型为例，更多字段信息获取接口请查看API参考文档。
4.  基于已有公钥信息，创建PublicKey公钥对象。 具体可参考加解密算法库框架-指定二进制数据生成非对称密钥对。
5.  调用X509CRL.verify校验签名合法性。
6.  基于已有的X509证书数据，调用cert.createX509Cert创建证书对象。
7.  调用X509CRL.isRevoked判断X509证书是否已被吊销。
8.  调用X509CRL.getRevokedCert获取被吊销证书对象。
9.  调用X509CRLEntry.getRevocationDate获取被吊销日期。
```typescript
import { cert } from '@kit.DeviceCertificateKit';
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { util } from '@kit.ArkTS';
// CRL数据，以下只是一个示例，需要根据具体业务来赋值
let crlData = '-----BEGIN X509 CRL-----\n' +
'MIIByzCBtAIBATANBgkqhkiG9w0BAQsFADBXMQswCQYDVQQGEwJDTjEPMA0GA1UE\n' +
'CAwG6ZmV6KW/MQ8wDQYDVQQHDAbopb/lrokxDzANBgNVBAoMBua1i+ivlTEVMBMG\n' +
'A1UEAwwM5Lit5paH5rWL6K+VFw0yNTAyMjAwNjEzMTZaFw0yNTAzMjIwNjEzMTZa\n' +
'MBkwFwIGAXKnJjrAFw0yNTAyMjAwNjEzMDNaoA4wDDAKBgNVHRQEAwIBADANBgkq\n' +
'hkiG9w0BAQsFAAOCAQEAt9AZ/B5FQiXnKKBGocKmM5QKeky/3etcI+cAVyD0zfjI\n' +
'r1UrL1aF+49LdZps3zQRqm4RQmo9CwL+KsMZiIMSeWF5Q6LW7BQa08hx5PtdjoOu\n' +
'1IWVKAwR5IigpaOwMKRTq1xJ372EiUkDD83AsxEkQoQW0bBvFklGrzglSACeKST+\n' +
'Pn6ywwFyYj34cfRuz3ueqwHRmN/mGzQdet7Ns8JBGWutDzfJsAiPC/TIaafTOocO\n' +
'CHo81Q2rMcqAJj5uXyc1Gq8KfOEqsxo/oDwReghjwrUedJ+9l/cQBr0F8HPV4H8W\n' +
'49sYMpseywjp9lxjWt/2nrx1z2yMaivGrVhoFasZvQ==\n' +
'-----END X509 CRL-----\n'
let certData = '-----BEGIN CERTIFICATE-----\n' +
'MIIDgTCCAmmgAwIBAgIGAXKnJjrAMA0GCSqGSIb3DQEBCwUAMFcxCzAJBgNVBAYT\n' +
'AkNOMQ8wDQYDVQQIDAbpmZXopb8xDzANBgNVBAcMBuilv+WuiTEPMA0GA1UECgwG\n' +
'5rWL6K+VMRUwEwYDVQQDDAzkuK3mlofmtYvor5UwHhcNMjUwMjIwMDYwOTUyWhcN\n' +
'MzUwMjE4MDYwOTUyWjBXMQswCQYDVQQGEwJDTjEPMA0GA1UECAwG6ZmV6KW/MQ8w\n' +
'DQYDVQQHDAbopb/lrokxDzANBgNVBAoMBua1i+ivlTEVMBMGA1UEAwwM5Lit5paH\n' +
'5rWL6K+VMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2DQpPYN7cJjQ\n' +
'LWLlkP5dD8J/g1xx97t2bFciUOru14IBm9EeX6qkohDSl6kQHwfVSqTfcqdIn9We\n' +
'73FiitfDjHc9xxbvBKbCYicCzS/eNl0W9q14FiEB8M9vz4dpKK00KZBcGc1QK2m+\n' +
'/N6zw4Tw4wXZ97v6/M+bhY5X0b3qEJlgQNyz7dD0wF7SCuzLL9zbr403KktHMG5Y\n' +
'MzyOBaGOaMuVQFlXMV/E5OWfqbM7n0Pu/cGj+AfkkziWxB+5WFCRP6Pw64LJGo+e\n' +
'uZHgHp07kk6+a2YNnFMcdTsOIWBSpCvC3I612NjpBirn2bFRWqTD++YAuvJQagmM\n' +
'+VhIjXD48wIDAQABo1MwUTAdBgNVHQ4EFgQUIN7ulBn89L5HXh9m9JM7rpkvlXUw\n' +
'HwYDVR0jBBgwFoAUIN7ulBn89L5HXh9m9JM7rpkvlXUwDwYDVR0TAQH/BAUwAwEB\n' +
'/zANBgkqhkiG9w0BAQsFAAOCAQEAxWNa3LSOR3QOJ+wE1Y/q5zzEPWmWR5OMrRJK\n' +
'juBHhYbzsg3r74fBO3Hw8XggEpHr6SOI1rBpZhciA8D9E8RnM1aJLY53rpBDY5OV\n' +
'wxTFzrjdwIknt13t6ILfGeLye5OAF0S8VPdfDqP9NddNNr/WFKpd3tKoBlG0ObMa\n' +
'LaQvOqObz0MJrjKsyI680nJjFLjLZ6+lEDSg4rsGU+bxEkONerStAPNcN2x9z7O6\n' +
'YJOvhiLjWvr8VRjlMZYVmT9gqCImoo+7JaHbu8jz9mjRxD6fo9I1OvCLNFyFw2sV\n' +
'iYID9UEbT6IWv/kKBdr7Te9+SY6AWxUxO8Hd7HdPKDOCrGrU9A==\n' +
'-----END CERTIFICATE-----\n';
let pubKeyData = new Uint8Array([
0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
0x00, 0xd8, 0x34, 0x29, 0x3d, 0x83, 0x7b, 0x70, 0x98, 0xd0, 0x2d, 0x62, 0xe5, 0x90, 0xfe, 0x5d,
0x0f, 0xc2, 0x7f, 0x83, 0x5c, 0x71, 0xf7, 0xbb, 0x76, 0x6c, 0x57, 0x22, 0x50, 0xea, 0xee, 0xd7,
0x82, 0x01, 0x9b, 0xd1, 0x1e, 0x5f, 0xaa, 0xa4, 0xa2, 0x10, 0xd2, 0x97, 0xa9, 0x10, 0x1f, 0x07,
0xd5, 0x4a, 0xa4, 0xdf, 0x72, 0xa7, 0x48, 0x9f, 0xd5, 0x9e, 0xef, 0x71, 0x62, 0x8a, 0xd7, 0xc3,
0x8c, 0x77, 0x3d, 0xc7, 0x16, 0xef, 0x04, 0xa6, 0xc2, 0x62, 0x27, 0x02, 0xcd, 0x2f, 0xde, 0x36,
0x5d, 0x16, 0xf6, 0xad, 0x78, 0x16, 0x21, 0x01, 0xf0, 0xcf, 0x6f, 0xcf, 0x87, 0x69, 0x28, 0xad,
0x34, 0x29, 0x90, 0x5c, 0x19, 0xcd, 0x50, 0x2b, 0x69, 0xbe, 0xfc, 0xde, 0xb3, 0xc3, 0x84, 0xf0,
0xe3, 0x05, 0xd9, 0xf7, 0xbb, 0xfa, 0xfc, 0xcf, 0x9b, 0x85, 0x8e, 0x57, 0xd1, 0xbd, 0xea, 0x10,
0x99, 0x60, 0x40, 0xdc, 0xb3, 0xed, 0xd0, 0xf4, 0xc0, 0x5e, 0xd2, 0x0a, 0xec, 0xcb, 0x2f, 0xdc,
0xdb, 0xaf, 0x8d, 0x37, 0x2a, 0x4b, 0x47, 0x30, 0x6e, 0x58, 0x33, 0x3c, 0x8e, 0x05, 0xa1, 0x8e,
0x68, 0xcb, 0x95, 0x40, 0x59, 0x57, 0x31, 0x5f, 0xc4, 0xe4, 0xe5, 0x9f, 0xa9, 0xb3, 0x3b, 0x9f,
0x43, 0xee, 0xfd, 0xc1, 0xa3, 0xf8, 0x07, 0xe4, 0x93, 0x38, 0x96, 0xc4, 0x1f, 0xb9, 0x58, 0x50,
0x91, 0x3f, 0xa3, 0xf0, 0xeb, 0x82, 0xc9, 0x1a, 0x8f, 0x9e, 0xb9, 0x91, 0xe0, 0x1e, 0x9d, 0x3b,
0x92, 0x4e, 0xbe, 0x6b, 0x66, 0x0d, 0x9c, 0x53, 0x1c, 0x75, 0x3b, 0x0e, 0x21, 0x60, 0x52, 0xa4,
0x2b, 0xc2, 0xdc, 0x8e, 0xb5, 0xd8, 0xd8, 0xe9, 0x06, 0x2a, 0xe7, 0xd9, 0xb1, 0x51, 0x5a, 0xa4,
0xc3, 0xfb, 0xe6, 0x00, 0xba, 0xf2, 0x50, 0x6a, 0x09, 0x8c, 0xf9, 0x58, 0x48, 0x8d, 0x70, 0xf8,
0xf3, 0x02, 0x03, 0x01, 0x00, 0x01
]);
// CRL示例
function crlSample(): void {
let textEncoder = new util.TextEncoder();
let encodingBlob: cert.EncodingBlob = {
// 将CRL数据从string转为Unit8Array
data: textEncoder.encodeInto(crlData),
// CRL格式，仅支持PEM和DER格式。在这个例子中，CRL用的是PEM格式
encodingFormat: cert.EncodingFormat.FORMAT_PEM
};
// 创建X509CRL实例
cert.createX509CRL(encodingBlob, (err, x509Crl) => {
if (err != null) {
// 创建X509CRL实例失败
console.error(`createX509Crl failed, errCode: ${err.code}, errMsg:${err.message} `);
return;
}
// 创建X509CRL实例成功
console.log('createX509CRL success');
// 获取CRL的版本
let version = x509Crl.getVersion();
let revokedType = x509Crl.getType();
console.log(`X509 CRL version: ${version}, type :${revokedType}`);
// 公钥的二进制数据需要传入@ohos.security.cryptoFramework的convertKey()方法去获取公钥对象
try {
let keyGenerator = cryptoFramework.createAsyKeyGenerator('RSA1024|PRIMES_3');
console.log('createAsyKeyGenerator success');
let pubEncodingBlob: cryptoFramework.DataBlob = {
data: pubKeyData,
};
keyGenerator.convertKey(pubEncodingBlob, null, (e, keyPair) => {
if (e == null) {
console.log('convert key success');
x509Crl.verify(keyPair.pubKey, (err, data) => {
if (err == null) {
// 签名验证成功
console.log('verify success');
} else {
// 签名验证失败
console.error(`verify failed, errCode: ${err.code}, errMsg: ${err.message}`);
}
});
} else {
console.error(`convert key failed, message: ${e.message}, code: ${e.code} `);
}
})
} catch (error) {
let e: BusinessError = error as BusinessError;
console.error(`get pubKey failed, errCode: ${e.code}, errMsg: ${e.message}` );
}
// 使用certFramework的createX509Cert()方法创建一个X509Cert实例
let certBlob: cert.EncodingBlob = {
data: textEncoder.encodeInto(certData),
encodingFormat: cert.EncodingFormat.FORMAT_PEM
};
let revokedFlag = true;
let serial:bigint = BigInt('0');
cert.createX509Cert(certBlob, (err, cert) => {
serial = cert.getCertSerialNumber();
if (err == null) {
try {
// 检查证书是否被吊销
revokedFlag = x509Crl.isRevoked(cert);
console.log(`revokedFlag is: ${revokedFlag}`);
if (!revokedFlag) {
console.log('the given cert is not revoked.');
return;
}
// 根据序列号来获取被吊销的证书
try {
let crlEntry = x509Crl.getRevokedCert(serial);
console.log('get getRevokedCert success');
let serialNumber = crlEntry.getSerialNumber();
console.log(`crlEntry serialNumber is: ${serialNumber}`);
// 获取被吊销证书的吊销日期
let date = crlEntry.getRevocationDate();
console.log(`revocation date is: ${date}`);
} catch (error) {
let e: BusinessError = error as BusinessError;
console.error(`getRevokedCert failed, errCode: ${e.code}, errMsg: ${e.message}`);
}
} catch (error) {
let e: BusinessError = error as BusinessError;
console.error(`isRevoked failed, errCode: ${e.code}, errMsg:${e.message}`);
}
} else {
console.error(`create x509 cert failed, errCode: ${err.code}, errMsg: ${err.message}`);
}
})
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/create-trustanchor-from-p12-V14
爬取时间: 2025-04-28 01:58:13
来源: Huawei Developer
证书链校验时从p12文件构造TrustAnchor对象数组。
开发步骤
1.  导入证书算法库框架模块。
2.  基于现有的p12文件数据，调用cert.createTrustAnchorsWithKeyStore创建TrustAnchor数组对象，并返回结果。
```typescript
import { cert } from '@kit.DeviceCertificateKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { util } from '@kit.ArkTS';
let p12Data = new Uint8Array([0x30, 0x82, 0x07, 0x5C, 0x02, 0x01, 0x03, 0x30, 0x82, 0x07, 0x12, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01, 0xA0, 0x82, 0x07, 0x03, 0x04, 0x82, 0x06, 0xFF, 0x30, 0x82, 0x06, 0xFB, 0x30, 0x82, 0x05, 0xB2, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x06, 0xA0, 0x82, 0x05, 0xA3, 0x30, 0x82, 0x05, 0x9F, 0x02, 0x01, 0x00, 0x30, 0x82, 0x05, 0x98, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01, 0x30, 0x57, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x05, 0x0D, 0x30, 0x4A, 0x30, 0x29, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x05, 0x0C, 0x30, 0x1C, 0x04, 0x08, 0xA9, 0x1C, 0x1B, 0x19, 0x36, 0xDE, 0xD4, 0x20, 0x02, 0x02, 0x08, 0x00, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x09, 0x05, 0x00, 0x30, 0x1D, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x01, 0x2A, 0x04, 0x10, 0x7D, 0xE5, 0x23, 0x96, 0x18, 0x8B, 0xF4, 0xBC, 0x9F, 0x4E, 0xE8, 0xE9, 0xAA, 0x52, 0x18, 0x39, 0x80, 0x82, 0x05, 0x30, 0x02, 0x2D, 0x59, 0xA9, 0x96, 0x5A, 0xFE, 0x20, 0x18, 0xB2, 0x25, 0xEA, 0xFC, 0x86, 0x0F, 0xA8, 0x3C, 0x2B, 0x26, 0x2F, 0x44, 0x6E, 0xF3, 0x15, 0xB7, 0x94, 0xE4, 0x43, 0xEE, 0xE6, 0xC3, 0xBB, 0x3C, 0x9E, 0x60, 0x08, 0xF8, 0x15, 0x61, 0x44, 0xD0, 0xEA, 0xD5, 0x6D, 0x1A, 0x3B, 0x9F, 0x4E, 0x2A, 0x1E, 0xBB, 0xB9, 0x4E, 0x15, 0x43, 0xB8, 0x68, 0xDB, 0x1A, 0x4E, 0x41, 0xBA, 0x29, 0x8E, 0x75, 0xEB, 0x12, 0xC1, 0xF0, 0x4B, 0x0D, 0x13, 0xB2, 0xC2, 0x48, 0x6F, 0xC4, 0xC4, 0x82, 0xF2, 0x26, 0xD4, 0x3D, 0x1F, 0x42, 0x7D, 0x67, 0xB0, 0x37, 0x55, 0x9E, 0xD9, 0x46, 0x99, 0x98, 0xB4, 0xE7, 0x4B, 0x07, 0x08, 0x3F, 0xD3, 0x96, 0x9A, 0xC5, 0xDA, 0x37, 0x74, 0x08, 0x5D, 0x3B, 0x06, 0x8A, 0x16, 0x6D, 0x81, 0x63, 0x01, 0x83, 0x94, 0xDA, 0x1B, 0x0E, 0x04, 0xCE, 0x18, 0xF0, 0x51, 0x22, 0xD8, 0x2D, 0xF1, 0x69, 0x0C, 0xCB, 0xC9, 0x51, 0x17, 0x07, 0x1F, 0x2B, 0xCF, 0x74, 0x26, 0xD7, 0x73, 0xB3, 0x2D, 0xF2, 0x82, 0xF0, 0x38, 0x5B, 0x8A, 0x8F, 0xCD, 0x84, 0x69, 0x40, 0x59, 0xCE, 0xB3, 0x39, 0xFE, 0xF6, 0xB7, 0x24, 0x89, 0x34, 0xFF, 0xF4, 0x40, 0x50, 0x06, 0x4D, 0xC6, 0x13, 0x82, 0xAF, 0x7F, 0x84, 0xB1, 0x67, 0x3C, 0x89, 0xBB, 0x5D, 0x32, 0xC3, 0xA6, 0xF1, 0x7D, 0xF5, 0x72, 0x68, 0x75, 0xCE, 0x69, 0xAB, 0x6C, 0x32, 0xDA, 0x16, 0x3B, 0xC4, 0xCA, 0x47, 0x45, 0xE9, 0x59, 0x1E, 0xB1, 0x70, 0xDA, 0x8A, 0x00, 0x69, 0x80, 0x40, 0xCA, 0x60, 0xE6, 0x07, 0x16, 0xF0, 0xA2, 0xF9, 0x12, 0x7D, 0x09, 0x43, 0x66, 0x46, 0x78, 0x35, 0xA6, 0x94, 0x35, 0x60, 0x82, 0xFC, 0xB8, 0x5E, 0x39, 0xE7, 0xA1, 0x22, 0xAD, 0xCC, 0x6F, 0x5E, 0xCE, 0x01, 0x6B, 0xA1, 0xDD, 0xE5, 0xDD, 0x79, 0x9B, 0xA1, 0x28, 0xC4, 0x03, 0x84, 0x8D, 0x6C, 0x07, 0xD4, 0xFE, 0x57, 0xFB, 0x89, 0x3F, 0x43, 0x44, 0x69, 0xF1, 0x9E, 0x53, 0x6C, 0x11, 0x11, 0x96, 0x79, 0xE4, 0xB8, 0x3B, 0x49, 0x2E, 0xF6, 0x3B, 0xC5, 0x6C, 0x76, 0x21, 0x22, 0x15, 0x85, 0x77, 0x8A, 0xDD, 0xD2, 0x43, 0x85, 0x73, 0x39, 0x77, 0x9F, 0xFA, 0x8F, 0xCF, 0xCB, 0xEA, 0x62, 0xBD, 0x5C, 0x66, 0x45, 0xCD, 0xB0, 0xCA, 0x42, 0xCC, 0xB9, 0xCF, 0xE3, 0x84, 0x63, 0x9F, 0x63, 0xCE, 0x49, 0xE9, 0x74, 0x26, 0xCC, 0x26, 0x78, 0xCE, 0x9F, 0x4E, 0x38, 0xA2, 0x9C, 0xEB, 0x75, 0xC5, 0x33, 0x6B, 0x00, 0x83, 0x85, 0xA3, 0x0F, 0xE7, 0xE1, 0x11, 0xA6, 0x48, 0xDC, 0xEF, 0x0C, 0x05, 0xB3, 0xDE, 0x94, 0xB9, 0x69, 0xCB, 0x27, 0x09, 0xAB, 0x27, 0xD8, 0x06, 0xED, 0x25, 0xBC, 0xA6, 0x2E, 0xB7, 0xF9, 0x2E, 0xAD, 0x84, 0x1D, 0xDD, 0x73, 0xD8, 0xC0, 0x46, 0x8A, 0xFE, 0x9A, 0xDF, 0x07, 0xE1, 0x33, 0xE2, 0x1C, 0x37, 0x6A, 0x8E, 0xA2, 0x91, 0x0B, 0xD7, 0x76, 0xEF, 0x3C, 0x87, 0x4A, 0x53, 0x84, 0xFA, 0xFA, 0xC5, 0x71, 0x76, 0xC0, 0x75, 0x70, 0x67, 0x67, 0x71, 0x9D, 0x8B, 0x81, 0x6F, 0x68, 0xC5, 0xB1, 0xFC, 0xA3, 0x59, 0xB5, 0xD0, 0x03, 0x56, 0xE7, 0x89, 0x03, 0xD7, 0x99, 0xDE, 0x66, 0x33, 0xFA, 0x53, 0x50, 0x5F, 0xB4, 0x9D, 0xB3, 0x90, 0x8F, 0x57, 0x20, 0xF0, 0x8B, 0xDB, 0x73, 0xCA, 0xA4, 0x71, 0x61, 0x67, 0x6A, 0x6D, 0xA5, 0xCA, 0x88, 0xD4, 0xCC, 0x82, 0x34, 0xC9, 0x3E, 0x10, 0x10, 0x57, 0xD1, 0x08, 0x96, 0x80, 0x09, 0xA8, 0xBB, 0x6F, 0x53, 0x8F, 0xFD, 0x87, 0xCF, 0x73, 0xFC, 0xE1, 0x3A, 0x92, 0x2E, 0x78, 0x66, 0xFB, 0x86, 0x5D, 0x62, 0xE0, 0xC4, 0x58, 0x55, 0x3F, 0xA4, 0xEA, 0xA1, 0xBE, 0x5B, 0x5E, 0x8E, 0x46, 0x50, 0x5E, 0x7C, 0x01, 0xD6, 0x63, 0xAA, 0x6F, 0xD5, 0xFD, 0xAF, 0xC5, 0x1D, 0xB3, 0x90, 0x9C, 0xD8, 0x5F, 0x8D, 0xF2, 0x81, 0xEB, 0xBF, 0xA1, 0xDE, 0xB7, 0x9D, 0xCD, 0x24, 0x82, 0x06, 0x0B, 0x63, 0xE6, 0xBF, 0x57, 0x51, 0xF0, 0xB6, 0xE9, 0x7F, 0xAA, 0x7B, 0x10, 0xBD, 0xCD, 0x85, 0x41, 0xE0, 0xD7, 0xF1, 0x53, 0xB7, 0xF8, 0x46, 0x91, 0x9E, 0x8D, 0x4B, 0xCB, 0x28, 0x35, 0x40, 0x37, 0x1E, 0x83, 0x64, 0x6A, 0x70, 0x01, 0x9D, 0xBF, 0xF1, 0x0E, 0xB6, 0x2E, 0x7A, 0xB7, 0x8F, 0x0F, 0x8C, 0x69, 0xD6, 0xF2, 0xD1, 0xF6, 0x1E, 0xCD, 0x08, 0xA8, 0xD4, 0x1B, 0xCB, 0x38, 0xEA, 0x26, 0x37, 0x5C, 0x60, 0x3A, 0x38, 0x5B, 0x12, 0x1D, 0x00, 0x7B, 0xEC, 0xCE, 0xFB, 0x89, 0x23, 0x8A, 0x11, 0xE1, 0x1B, 0xDE, 0x54, 0x91, 0x6A, 0x26, 0x22, 0xD0, 0x1C, 0x2E, 0xBA, 0xD0, 0x92, 0x87, 0xDA, 0xF0, 0x93, 0xBB, 0x3A, 0x2C, 0x52, 0xFB, 0xB2, 0xA9, 0xA8, 0x92, 0x19, 0xE3, 0x19, 0xDC, 0xB0, 0x0E, 0xC5, 0xE7, 0x9D, 0xFB, 0xF9, 0xA3, 0x23, 0x32, 0xD0, 0x4E, 0x2C, 0x05, 0x2D, 0x76, 0xDB, 0x93, 0x53, 0x5B, 0x0E, 0x2A, 0xA3, 0xDD, 0x5F, 0xD3, 0x1A, 0x3B, 0x1E, 0x1F, 0x26, 0x88, 0x43, 0xAD, 0x10, 0x1F, 0xA9, 0xC4, 0xF9, 0x1F, 0xCD, 0xA5, 0xD2, 0xDC, 0x24, 0x95, 0x1D, 0xE7, 0x57, 0xE1, 0x02, 0x0A, 0x20, 0xEA, 0x6A, 0x78, 0x4E, 0x96, 0xE2, 0xE5, 0x6D, 0x6F, 0xFD, 0x81, 0x7B, 0x61, 0x85, 0xA3, 0x3D, 0xC5, 0x7B, 0xEF, 0xAE, 0x58, 0xA2, 0xDB, 0x91, 0x73, 0xDB, 0x47, 0x8E, 0xD1, 0x7D, 0xD7, 0x8F, 0x56, 0x06, 0x28, 0x8C, 0x78, 0x73, 0x02, 0x65, 0xB0, 0x16, 0x4B, 0xE6, 0xA3, 0xD7, 0x06, 0x7C, 0xEA, 0x7D, 0xE2, 0xAE, 0xBB, 0xE5, 0xD2, 0xEB, 0xF0, 0x91, 0x71, 0x7C, 0xBC, 0xA6, 0x1A, 0xE8, 0x9F, 0xD3, 0xA9, 0x3C, 0x5D, 0x60, 0xCF, 0x59, 0x26, 0x46, 0x45, 0xF2, 0x7F, 0x85, 0x6B, 0xE7, 0xC2, 0x58, 0x52, 0x90, 0x12, 0x07, 0xBA, 0xE6, 0xB8, 0xE5, 0xD7, 0x24, 0x93, 0xD5, 0x6E, 0xB1, 0x74, 0x6C, 0xAA, 0xA0, 0x60, 0xBF, 0xF3, 0x32, 0x41, 0x0B, 0xA2, 0x01, 0x84, 0x0D, 0x83, 0xE4, 0x43, 0xD1, 0xBA, 0xC1, 0x92, 0x84, 0x26, 0xF8, 0xF2, 0x77, 0x20, 0x1B, 0xF2, 0x8F, 0x00, 0x69, 0x18, 0x2F, 0x6C, 0xA8, 0x58, 0xB5, 0x5D, 0xFA, 0x27, 0xD2, 0x38, 0xD2, 0x49, 0x6E, 0xDF, 0x55, 0x79, 0xAF, 0x1C, 0x44, 0xDA, 0x5A, 0xD7, 0x44, 0x53, 0x50, 0x8B, 0x77, 0x70, 0x4D, 0x91, 0xEC, 0x07, 0xA5, 0x64, 0x21, 0x3C, 0x31, 0x09, 0x68, 0x65, 0xB4, 0xFA, 0xBE, 0x23, 0xF9, 0xDF, 0x77, 0x46, 0xA2, 0x9A, 0x5D, 0xE3, 0xBE, 0x1E, 0xE3, 0x84, 0xEF, 0xAE, 0x7D, 0xF8, 0x1C, 0x54, 0xE8, 0x4E, 0xAE, 0xB5, 0xBB, 0xD6, 0xC3, 0x8D, 0x56, 0x79, 0xE8, 0x7C, 0x43, 0xDC, 0xF3, 0xB3, 0x7A, 0x30, 0x22, 0x09, 0xBC, 0x10, 0xD6, 0x84, 0xC4, 0x0F, 0x4C, 0x0B, 0xA2, 0xD1, 0xCB, 0xCD, 0x1F, 0x50, 0x3D, 0xF7, 0x23, 0x45, 0x55, 0x18, 0x21, 0x3D, 0x64, 0x05, 0x2E, 0x52, 0x3A, 0x73, 0xFD, 0xF2, 0xA9, 0xCA, 0x3F, 0xF6, 0x7F, 0x87, 0xE8, 0x56, 0x9B, 0x68, 0x6B, 0x20, 0xB0, 0x1D, 0x83, 0x04, 0x2F, 0x59, 0xFD, 0x84, 0x57, 0x7D, 0x82, 0x97, 0x96, 0xE8, 0xFB, 0xDF, 0x71, 0x8C, 0x26, 0x47, 0x85, 0xA5, 0xBE, 0xFB, 0xF5, 0x05, 0x4C, 0xD3, 0x3D, 0x73, 0xF4, 0xA5, 0xF1, 0xA3, 0x99, 0x98, 0x1B, 0x84, 0x8B, 0xB3, 0x53, 0xCE, 0x4D, 0xEA, 0x5A, 0x48, 0xD2, 0xB9, 0x7E, 0xB6, 0xEB, 0x9B, 0x94, 0x6F, 0xDD, 0x44, 0x80, 0x89, 0xD2, 0x78, 0x6D, 0xB9, 0xDA, 0x8B, 0x83, 0x49, 0xE0, 0x4D, 0x49, 0xDF, 0x6B, 0xFF, 0xF7, 0x04, 0x00, 0x32, 0xAA, 0x1D, 0x4F, 0x8D, 0x4B, 0xDE, 0xB8, 0x0D, 0xC6, 0x54, 0x1C, 0xB2, 0xCD, 0x60, 0x29, 0x72, 0x0A, 0x7E, 0xE7, 0xEB, 0x7A, 0xF6, 0x5B, 0x04, 0x3F, 0x5B, 0x93, 0x12, 0x0D, 0xD5, 0xFF, 0x7A, 0x41, 0x44, 0x0B, 0x37, 0x12, 0x82, 0x3D, 0xDD, 0x1E, 0x59, 0xB9, 0xBE, 0x0F, 0x9E, 0xD6, 0xD0, 0x68, 0x69, 0x74, 0xF9, 0xB1, 0x21, 0xA3, 0x70, 0x4F, 0xDA, 0xF8, 0x9F, 0xB9, 0x49, 0x3F, 0xC6, 0xB2, 0x69, 0xC8, 0xD8, 0x60, 0xF1, 0x6A, 0x52, 0x07, 0xFA, 0x42, 0xFD, 0xA9, 0x06, 0xCF, 0x97, 0x4A, 0x0E, 0xC5, 0xFC, 0x63, 0x27, 0x54, 0xC8, 0xBE, 0x8B, 0x4F, 0xB6, 0x42, 0xBC, 0xA2, 0xCC, 0x70, 0x4A, 0x6B, 0x24, 0x5B, 0x68, 0x28, 0x47, 0xFA, 0x6B, 0x89, 0x28, 0x07, 0x5D, 0xE0, 0x2C, 0x4A, 0xD9, 0x22, 0xE3, 0xB3, 0x2F, 0xAA, 0xC2, 0xA0, 0x7C, 0x0F, 0x92, 0xC5, 0xDD, 0xB6, 0x23, 0x8F, 0x73, 0x73, 0x0F, 0xD7, 0x73, 0x71, 0x2F, 0x0A, 0x78, 0xE8, 0x5B, 0xDB, 0xC2, 0xE0, 0xDB, 0xC9, 0x3E, 0xC3, 0x72, 0x9C, 0x14, 0xD7, 0xD1, 0x28, 0xFD, 0xF4, 0xEE, 0xBC, 0x0E, 0x13, 0x37, 0xCA, 0x85, 0x9F, 0xB9, 0xA2, 0x0E, 0xF6, 0xE7, 0x49, 0xD1, 0xD0, 0x11, 0x76, 0x53, 0xA3, 0x73, 0x95, 0x2A, 0x23, 0xC8, 0x0E, 0x97, 0x83, 0x07, 0x64, 0xB2, 0x51, 0xB7, 0xC8, 0x51, 0x9F, 0xA4, 0x3E, 0x7B, 0xA4, 0x18, 0x6D, 0x99, 0xF0, 0x6E, 0xC3, 0x97, 0xAE, 0xF4, 0xB7, 0x66, 0x37, 0xFA, 0x65, 0xFC, 0x5E, 0xE2, 0x57, 0xFA, 0x8B, 0x4C, 0x86, 0x10, 0xB4, 0x5C, 0xA4, 0xD2, 0x60, 0x83, 0x69, 0x1E, 0xFF, 0x36, 0x9B, 0xF9, 0x84, 0xFB, 0xB8, 0x83, 0x64, 0xF1, 0x41, 0xA5, 0x25, 0x56, 0x21, 0xBA, 0x13, 0x98, 0x0C, 0x3B, 0x04, 0xAA, 0x6C, 0x9A, 0xD4, 0xE3, 0x13, 0x15, 0x54, 0x05, 0x4C, 0x5C, 0xE1, 0x7A, 0x31, 0x5E, 0x90, 0xCF, 0x48, 0x4E, 0x83, 0xD7, 0x7F, 0xED, 0x93, 0x22, 0xAB, 0x67, 0xE7, 0x76, 0x32, 0x64, 0xBA, 0x5A, 0x21, 0x3E, 0x30, 0x82, 0x01, 0x41, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01, 0xA0, 0x82, 0x01, 0x32, 0x04, 0x82, 0x01, 0x2E, 0x30, 0x82, 0x01, 0x2A, 0x30, 0x82, 0x01, 0x26, 0x06, 0x0B, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x0C, 0x0A, 0x01, 0x02, 0xA0, 0x81, 0xEF, 0x30, 0x81, 0xEC, 0x30, 0x57, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x05, 0x0D, 0x30, 0x4A, 0x30, 0x29, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x05, 0x0C, 0x30, 0x1C, 0x04, 0x08, 0xED, 0x3E, 0xED, 0x07, 0x5C, 0x1F, 0x71, 0xAD, 0x02, 0x02, 0x08, 0x00, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x09, 0x05, 0x00, 0x30, 0x1D, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x01, 0x2A, 0x04, 0x10, 0xA7, 0x49, 0xA4, 0x6E, 0x00, 0x19, 0x75, 0x59, 0x75, 0x59, 0xBA, 0x4B, 0xC7, 0x24, 0x88, 0x34, 0x04, 0x81, 0x90, 0xCA, 0x23, 0x82, 0xAA, 0x16, 0x57, 0x99, 0xFA, 0x94, 0x9F, 0xAE, 0x32, 0x5C, 0x5B, 0xE7, 0x01, 0xD0, 0xED, 0xA7, 0x58, 0x57, 0x52, 0xBF, 0x57, 0x13, 0xD4, 0x15, 0xB0, 0x06, 0xF5, 0x38, 0xCC, 0x64, 0x23, 0x09, 0xD5, 0x8C, 0x0D, 0x64, 0x31, 0xFA, 0x74, 0xAA, 0x96, 0x7E, 0x9B, 0x16, 0xCA, 0x21, 0xFD, 0xC0, 0x54, 0x91, 0x40, 0x7F, 0xB3, 0xF2, 0xA3, 0xEC, 0xA1, 0x4A, 0x07, 0xF0, 0x87, 0x22, 0xDB, 0x8A, 0x49, 0x89, 0xF7, 0xF2, 0x6A, 0xFC, 0x8D, 0x03, 0x6E, 0x32, 0x4F, 0xD0, 0xD8, 0x93, 0x92, 0xA5, 0xF1, 0x41, 0xBD, 0xEA, 0xE1, 0x38, 0xA9, 0xD8, 0x9D, 0xAB, 0xB4, 0x8E, 0x4A, 0x40, 0x0E, 0xC7, 0xE3, 0xE9, 0xBF, 0x0E, 0xBA, 0x8D, 0xAA, 0x3E, 0x93, 0x53, 0x88, 0xEE, 0x0A, 0x2C, 0x71, 0xF1, 0x61, 0x44, 0xA5, 0xAD, 0xED, 0x3E, 0xAB, 0x32, 0x9A, 0x32, 0x85, 0x08, 0xF5, 0x8B, 0xCC, 0x15, 0x35, 0xEE, 0xFA, 0x17, 0x27, 0x97, 0x8D, 0xD9, 0x1C, 0x5E, 0x74, 0x9D, 0x7B, 0x31, 0x25, 0x30, 0x23, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x15, 0x31, 0x16, 0x04, 0x14, 0x5F, 0x8E, 0xAB, 0x9C, 0x5F, 0xE2, 0x3B, 0xB1, 0x5C, 0x1A, 0x36, 0x1D, 0x7D, 0xCB, 0x90, 0x45, 0x20, 0x3C, 0x3B, 0xAC, 0x30, 0x41, 0x30, 0x31, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20, 0x93, 0x25, 0xC4, 0x3E, 0x2A, 0x6D, 0x4C, 0x30, 0x87, 0x0F, 0xE3, 0x5A, 0x95, 0xB0, 0xF2, 0x6C, 0xBA, 0x07, 0x89, 0x7D, 0xFB, 0xCF, 0xCF, 0x1D, 0x54, 0xA3, 0x36, 0x24, 0x7B, 0x30, 0x97, 0xB5, 0x04, 0x08, 0xE7, 0x96, 0x59, 0xCC, 0x42, 0x9F, 0xEF, 0xFC, 0x02, 0x02, 0x08, 0x00]);
try {
cert.createTrustAnchorsWithKeyStore(p12Data, '123456').then((data) => {
console.log('createTrustAnchorsWithKeyStore sucess, the num of result is :' + JSON.stringify(data.length))
}).catch((err: BusinessError) => {
console.error('createTrustAnchorsWithKeyStore failed, error :' + JSON.stringify(err))
})
} catch(error) {
console.error('createTrustAnchorsWithKeyStore failed, error :' + JSON.stringify(error))
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/create-verify-cerchainvalidator-object-V14
爬取时间: 2025-04-28 01:58:26
来源: Huawei Developer
证书链是由一组证书组成的证书集合，以图中样例证书文件为例，即可放在一个证书链中。
样例中可以看到GlobalSign自签名了证书，GlobalSign也签发了GlobalSign RSA OV SSL CA 2018的证书，GlobalSign RSA OV SSL CA 2018又签发了第三级证书。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170441.37591130327238187253954951277072:50001231000000:2800:8F83DAA19973E5E3D105D7999EA485C8348519F87F8EA5F572970A331C5D8BAD.png)
开发者可以参考示例将已有的多个证书构建出证书链数据。
开发步骤
1.  导入证书算法库框架模块。
```typescript
import { cert } from '@kit.DeviceCertificateKit';
```
2.  cert.createCertChainValidator创建证书链校验器对象。
3.  基于已有的证书数据，创建证书链数据对象CertChainData。 证书算法库框架提供了证书链校验器对象可用于校验证书链，以验证信任链根源，但待校验的证书链数据对象应符合如下的数据结构定义。
4.  调用CertChainValidator.validate校验证书链数据。
| 名称 | 类型 | 可读 | 可写 | 说明 |
| --- | --- | --- | --- | --- |
| data | Uint8Array | 是 | 是 | 证书数据，按照长度(2字节)-数据的形式传入。如08ABCDEFGH07ABCDEFG：第一本证书，前2个字节表示证书的长度为8字节，后面附加8字节的证书数据；第2本证书前2个字节表示证书的长度为7字节，后面附加7字节的证书数据。 |
| count | number | 是 | 是 | 传入的数据中，包含的证书数量。 |
| encodingFormat | EncodingFormat | 是 | 是 | 指明证书编码格式。 |
```typescript
import { cert } from '@kit.DeviceCertificateKit';
import { util } from '@kit.ArkTS';
// CA数据，这只是一个示例，需要根据具体业务来赋值
let caCertData = '-----BEGIN CERTIFICATE-----\n' +
'MIIDgTCCAmmgAwIBAgIGAXKnJjrAMA0GCSqGSIb3DQEBCwUAMFcxCzAJBgNVBAYT\n' +
'AkNOMQ8wDQYDVQQIDAbpmZXopb8xDzANBgNVBAcMBuilv+WuiTEPMA0GA1UECgwG\n' +
'5rWL6K+VMRUwEwYDVQQDDAzkuK3mlofmtYvor5UwHhcNMjUwMjIwMDI1NjMxWhcN\n' +
'MzUwMjE4MDI1NjMxWjBXMQswCQYDVQQGEwJDTjEPMA0GA1UECAwG6ZmV6KW/MQ8w\n' +
'DQYDVQQHDAbopb/lrokxDzANBgNVBAoMBua1i+ivlTEVMBMGA1UEAwwM5Lit5paH\n' +
'5rWL6K+VMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyY30ubE33Zmc\n' +
'BBM4OIpD1UuDVKynC4xNBK4v79vnlc4ElmRZD4RjkS612DtpaUzt/yHMZXmJTdqg\n' +
'2jq7UG4sQc0G3uNGIXdUpRZpnUYGVftuZMxHaNOb+IgDkZzaO3Dk33piOpH/X/Ke\n' +
'OosCbm7eBL+y+wRhUsLSCEasEsIvW3edHuYLrfz3MzwY/9AmnwqDGdRJ5rPayODD\n' +
'HH0yw9JuRkdMacN8omVX8jBfJeI8KafcQW8MJz+Y0qyQyiZ6A81AQSVfT+6Sk2U3\n' +
'UqeSTmtdIL1u29HfYLwYGHey+1Ro2wxqnMsFKIdKu2dDMDQZx61pER/dFtPYFlS7\n' +
'/uh3mi9HUQIDAQABo1MwUTAdBgNVHQ4EFgQUGDykmR825RPNFIEQaFzUqkr+CIow\n' +
'HwYDVR0jBBgwFoAUGDykmR825RPNFIEQaFzUqkr+CIowDwYDVR0TAQH/BAUwAwEB\n' +
'/zANBgkqhkiG9w0BAQsFAAOCAQEAXjlmYKjBz1ajWywZNlN+LVRXNx7bS4TYtOc2\n' +
'ME4N1ls6yjWSLtBe4DdkBqZ2HwrVW4dg5xZdAS/T0v/rRiGbX6iUFRV9WCTdtLZB\n' +
'HKNh7vU39F7mgTaaWXQK/+6NeLKMzwJENRRaESI/sXeKE6irfJgYuq3NH8GGFd+w\n' +
'HnvVBHRb6WSlY2s5Li7t6lj40UbwOljnqzRQvBeX57rOnzJgVKND3oY9pex/05Oe\n' +
'96x+qc2iqZbu54A6NYCTj/65EEKoj5rYxPXMV4FegV42ouaLJJoS+cEEY7w+ixcl\n' +
'04TjtjEdhTZiJCmI0RK50H2SWC0t9qkFewM3CCWTHY5ygPtMGA==\n' +
'-----END CERTIFICATE-----\n';
// 二级CA证书数据，这只是一个示例，需要根据具体业务来赋值
let secondCaCertData = '-----BEGIN CERTIFICATE-----\n' +
'MIIDgTCCAmmgAwIBAgIGAXKnJjrBMA0GCSqGSIb3DQEBCwUAMFcxCzAJBgNVBAYT\n' +
'AkNOMQ8wDQYDVQQIDAbpmZXopb8xDzANBgNVBAcMBuilv+WuiTEPMA0GA1UECgwG\n' +
'5rWL6K+VMRUwEwYDVQQDDAzkuK3mlofmtYvor5UwHhcNMjUwMjIwMDI1NjU3WhcN\n' +
'MzUwMjE4MDI1NjU3WjBXMQswCQYDVQQGEwJDTjEPMA0GA1UECAwG6ZmV6KW/MQ8w\n' +
'DQYDVQQHDAbopb/lrokxDzANBgNVBAoMBua1i+ivlTEVMBMGA1UEAwwM5Lit5paH\n' +
'5rWL6K+VMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxSL5L7fwMaRF\n' +
'RiT1l7kpzaAqZe33/3lgexoMfGiIFarIhYyYJsmOJKes2uLSnPeqEtscrXmFQiIG\n' +
'0srmwrriGgo3oxDp4/5i1FhCf3FqZUwD/RJhtVmkHT0HoYl4cpt/dJSF/e5vxt/J\n' +
'2Z1eRIQOj9DzyqET6+ONQmfVOyzEH6xlpXHZLvykSZ7ytPp25LxULPWjTmpDOPRq\n' +
'vkSMaH4H3mPw/Z9r0MVKP7DgAZMl2yVudHp785AMTVD0L9zWGHf3sek25ek5nv2r\n' +
'SlB21MTBpvd8GC/iGns4V3Bvf75WAMgpGghAkRRyADeqt5Hw+x9BIb9FcfE+h6n+\n' +
'6EF6FPa8GQIDAQABo1MwUTAdBgNVHQ4EFgQUjt2Crk/j6W8WCdHWyz4H+Q2/3PYw\n' +
'HwYDVR0jBBgwFoAUGDykmR825RPNFIEQaFzUqkr+CIowDwYDVR0TAQH/BAUwAwEB\n' +
'/zANBgkqhkiG9w0BAQsFAAOCAQEAksPHMuVF9e2GMVlaSe1Ao9D1KrJvKNaFZPCI\n' +
'lQe2CDsX+Qu7sQj4SML5vvWFLtcAp6ZovqUyEM0PtZWVSjPCRTMJ3ofBPwnXvQ2N\n' +
'7J7NCDA227MQabXeN3jMhkcAzlpdO5poTnobPF4xRqb39jM7otnNJsujvzdDab2l\n' +
'LiP4eU5TrEaF2lwidBWJX0VoLrRpqzQhiWXGMpCBBugP5U+bFs20wezJBG19WYyc\n' +
'2xKKfvyIcxrpmvjLZl8HddS7Ot1CKXyc8U9QZBGAlPwOXu8juppcEtjJyl36EnvF\n' +
'YAcwrXOAtCiNpX3UnLUbG8GtpOOWQWCt+x1gKmA6V0jbqQmqcw==\n' +
'-----END CERTIFICATE-----\n';
// 证书链校验器示例。在这个示例中，验证了一个二级证书链
function certChainValidatorSample(): void {
let textEncoder = new util.TextEncoder();
// 证书链校验器算法。目前仅支持PKIX
let algorithm = 'PKIX';
// 创建一个证书链校验器实例
let validator = cert.createCertChainValidator(algorithm);
// CA证书数据
let uint8ArrayOfCaCertData = textEncoder.encodeInto(caCertData);
// CA证书数据的长度
let uint8ArrayOfCaCertDataLen = new Uint8Array(new Uint16Array([uint8ArrayOfCaCertData.byteLength]).buffer);
// 二级CA证书数据
let uint8ArrayOf2ndCaCertData =  textEncoder.encodeInto(secondCaCertData);
// 二级CA证书数据的长度
let uint8ArrayOf2ndCaCertDataLen = new Uint8Array(new Uint16Array([uint8ArrayOf2ndCaCertData.byteLength]).buffer);
// 证书链二进制数据：二级CA证书数据长度+二级CA证书数据+CA证书数据长度+CA证书数据（L-V格式）
let encodingData = new Uint8Array(uint8ArrayOf2ndCaCertDataLen.length + uint8ArrayOf2ndCaCertData.length +
uint8ArrayOfCaCertDataLen.length + uint8ArrayOfCaCertData.length);
for (let i = 0; i < uint8ArrayOf2ndCaCertDataLen.length; i++) {
encodingData[i] = uint8ArrayOf2ndCaCertDataLen[i];
}
for (let i = 0; i < uint8ArrayOf2ndCaCertData.length; i++) {
encodingData[uint8ArrayOf2ndCaCertDataLen.length + i] = uint8ArrayOf2ndCaCertData[i];
}
for (let i = 0; i < uint8ArrayOfCaCertDataLen.length; i++) {
encodingData[uint8ArrayOf2ndCaCertDataLen.length + uint8ArrayOf2ndCaCertData.length + i] = uint8ArrayOfCaCertDataLen[i];
}
for (let i = 0; i < uint8ArrayOfCaCertData.length; i++) {
encodingData[uint8ArrayOf2ndCaCertDataLen.length + uint8ArrayOf2ndCaCertData.length +
uint8ArrayOfCaCertDataLen.length + i] = uint8ArrayOfCaCertData[i];
}
let certChainData: cert.CertChainData = {
// Uint8Array类型：L-V格式（证书数据长度-证书数据）
data: encodingData,
// 证书的数量。本例中为2
count: 2,
// 证书格式。仅支持 PEM 和 DER。在此示例中，证书为 PEM 格式
encodingFormat: cert.EncodingFormat.FORMAT_PEM
};
// 验证证书链
validator.validate(certChainData, (err, data) => {
if (err != null) {
// 校验失败
console.error(`validate failed, errCode: ${err.code}, errMsg: ${err.message}`);
} else {
// 校验成功
console.log('validate success');
}
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/create-get-cert-crl-object-V14
爬取时间: 2025-04-28 01:58:40
来源: Huawei Developer
从输入的证书集合和证书吊销列表集合中选择满足条件的证书或者证书吊销列表。
开发步骤
1.  导入证书算法库框架模块。
```typescript
import { cert } from '@kit.DeviceCertificateKit';
```
2.  基于已有的证书数据，调用cert.createX509Cert创建X509证书的对象。
3.  基于已有的CRL数据，调用cert.createX509CRL创建X509证书吊销列表的对象。
4.  调用cert.createCertCRLCollection创建CertCRLCollection的对象，并返回相应的结果。
5.  调用CertCRLCollection.selectCerts查找所有与X509CertMatchParameters匹配的证书对象数组，并返回结果。
6.  调用CertCRLCollection.selectCRLs查找所有与X509CRLMatchParameters匹配的证书吊销列表数组，并返回结果。
```typescript
import { cert } from '@kit.DeviceCertificateKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { util } from '@kit.ArkTS';
async function createX509CRL(): Promise<cert.X509CRL> {
let crlData = '-----BEGIN X509 CRL-----\n' +
'MIHzMF4CAQMwDQYJKoZIhvcNAQEEBQAwFTETMBEGA1UEAxMKQ1JMIGlzc3VlchcN\n' +
'MTcwODA3MTExOTU1WhcNMzIxMjE0MDA1MzIwWjAVMBMCAgPoFw0zMjEyMTQwMDUz\n' +
'MjBaMA0GCSqGSIb3DQEBBAUAA4GBACEPHhlaCTWA42ykeaOyR0SGQIHIOUR3gcDH\n' +
'J1LaNwiL+gDxI9rMQmlhsUGJmPIPdRs9uYyI+f854lsWYisD2PUEpn3DbEvzwYeQ\n' +
'5SqQoPDoM+YfZZa23hoTLsu52toXobP74sf/9K501p/+8hm4ROMLBoRT86GQKY6g\n' +
'eavsH0Q3\n' +
'-----END X509 CRL-----\n';
// 证书吊销列表二进制数据，需业务自行赋值
let textEncoder = new util.TextEncoder();
let encodingBlob: cert.EncodingBlob = {
data: textEncoder.encodeInto(crlData),
// 根据encodingData的格式进行赋值，支持FORMAT_PEM和FORMAT_DER
encodingFormat: cert.EncodingFormat.FORMAT_PEM
};
let x509CRL: cert.X509CRL = {} as cert.X509CRL;
try {
x509CRL = await cert.createX509CRL(encodingBlob);
} catch (err) {
let e: BusinessError = err as BusinessError;
console.error(`createX509CRL failed, errCode: ${e.code}, errMsg: ${e.message}`);
}
return x509CRL;
}
async function createX509Cert(): Promise<cert.X509Cert> {
let certData = '-----BEGIN CERTIFICATE-----\n' +
'MIIBHTCBwwICA+gwCgYIKoZIzj0EAwIwGjEYMBYGA1UEAwwPRXhhbXBsZSBSb290\n' +
'IENBMB4XDTIzMDkwNTAyNDgyMloXDTI2MDUzMTAyNDgyMlowGjEYMBYGA1UEAwwP\n' +
'RXhhbXBsZSBSb290IENBMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEHjG74yMI\n' +
'ueO7z3T+dyuEIrhxTg2fqgeNB3SGfsIXlsiUfLTatUsU0i/sePnrKglj2H8Abbx9\n' +
'PK0tsW/VgqwDIDAKBggqhkjOPQQDAgNJADBGAiEApVZno/Z7WyDc/muRN1y57uaY\n' +
'Mjrgnvp/AMdE8qmFiDwCIQCrIYdHVO1awaPgcdALZY+uLQi6mEs/oMJLUcmaag3E\n' +
'Qw==\n' +
'-----END CERTIFICATE-----\n';
let textEncoder = new util.TextEncoder();
let encodingBlob: cert.EncodingBlob = {
data: textEncoder.encodeInto(certData),
// 根据encodingData的格式进行赋值，支持FORMAT_PEM和FORMAT_DER
encodingFormat: cert.EncodingFormat.FORMAT_PEM
};
let x509Cert: cert.X509Cert = {} as cert.X509Cert;
try {
x509Cert = await cert.createX509Cert(encodingBlob);
} catch (err) {
let e: BusinessError = err as BusinessError;
console.error(`createX509Cert failed, errCode: ${e.code}, errMsg: ${e.message}`);
}
return x509Cert;
}
async function sample() {
const x509Cert = await createX509Cert();
const x509CRL = await createX509CRL();
let collection: cert.CertCRLCollection = {} as cert.CertCRLCollection;
try {
collection = cert.createCertCRLCollection([x509Cert], [x509CRL]);
console.log('createCertCRLCollection success');
} catch (err) {
console.error('createCertCRLCollection failed');
}
const certParam: cert.X509CertMatchParameters = {
validDate: '231128000000Z'
}
try {
let certs: cert.X509Cert[] = await collection.selectCerts(certParam);
} catch (err) {
console.error('selectCerts failed');
}
const crlParam: cert.X509CRLMatchParameters = {
x509Cert: x509Cert
}
try {
let crls: cert.X509CRL[] = await collection.selectCRLs(crlParam);
console.error('selectCRLs success');
} catch (err) {
console.error('selectCRLs failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/create-verify-certchain-object-V14
爬取时间: 2025-04-28 01:58:54
来源: Huawei Developer
以校验证书链为例，完成证书链对象的创建，获取证书链中的证书列表以及使用信任锚对证书链进行校验。
开发步骤
1.  导入证书算法库框架模块。
```typescript
import { cert } from '@kit.DeviceCertificateKit';
```
2.  基于已有的证书数据，调用cert.createX509CertChain创建X509证书链对象，并返回结果。
3.  调用x509CertChain.getCertList获取证书链中的X509证书列表。
4.  调用x509CertChain.validate使用校验参数校验证书链并返回结果。
```typescript
import { cert } from '@kit.DeviceCertificateKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { util } from '@kit.ArkTS';
let certChainData = "-----BEGIN CERTIFICATE-----\n" +
"MIID6jCCAtKgAwIBAgIIIM2q/TmRoLcwDQYJKoZIhvcNAQELBQAwWjELMAkGA1UE\n" +
"BhMCRU4xEDAOBgNVBAgTB0VuZ2xhbmQxDzANBgNVBAcTBkxvbmRvbjEMMAoGA1UE\n" +
"ChMDdHMyMQwwCgYDVQQLEwN0czIxDDAKBgNVBAMTA3RzMjAeFw0yMzEyMDUwNzM5\n" +
"MDBaFw0yNDEwMzEyMzU5MDBaMGExCzAJBgNVBAYTAkNOMRAwDgYDVQQIEwdKaWFu\n" +
"Z3N1MRAwDgYDVQQHEwdOYW5qaW5nMQwwCgYDVQQKEwN0czMxDDAKBgNVBAsTA3Rz\n" +
"MzESMBAGA1UEAxMJMTI3LjAuMC4xMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n" +
"CgKCAQEAtt+2QxUevbolYLp51QGcUpageI4fwGLIqv4fj4aoVnHFOOBqVOVpfCLR\n" +
"p26LFV/F8ebwPyo8YEBKSwXzMD1573rMSbaH9BalscH5lZYAbetXoio6YRvzlcmc\n" +
"rVvLBNMeVnxY86xHpo0MTNyP7W024rZsxWO98xFQVdoiaBC+7+midlisx2Y+7u0j\n" +
"zT9GjeUP6JLdLFUZJKUPSTK3jVzw9v1eZQZKYoNfU6vFMd6ndtwW6qEnwpzmmX/U\n" +
"T+p5ThAMH593zszlz330nTSXBjIsGkyvOz9gSB0Z0LAuJj06XUNhGL5xKJYKbdI3\n" +
"8MFQFJKvRHfgTAvVsvAvpBUM2DuBKwIDAQABo4GsMIGpMAkGA1UdEwQCMAAwHQYD\n" +
"VR0OBBYEFDfsHTMZwoA6eaDFlBUyDpka+sYtMAsGA1UdDwQEAwID+DAnBgNVHSUE\n" +
"IDAeBggrBgEFBQcDAQYIKwYBBQUHAwIGCCsGAQUFBwMEMBQGA1UdEQQNMAuCCTEy\n" +
"Ny4wLjAuMTARBglghkgBhvhCAQEEBAMCBkAwHgYJYIZIAYb4QgENBBEWD3hjYSBj\n" +
"ZXJ0aWZpY2F0ZTANBgkqhkiG9w0BAQsFAAOCAQEAp5vTvXrt8ZpgRJVtzv9ss0lJ\n" +
"izp1fJf+ft5cDXrs7TSD5oHrSW2vk/ZieIMhexU4LFwhs4OE7jK6pgI48Dseqxx7\n" +
"B/KktxhVMJUmVXd9Ayjp6f+BtZlIk0cArPuoXToXjsV8caTGBXHRdzxpAk/w9syc\n" +
"GYrbH9TrdNMuTizOb+k268oKXUageZNxHmd7YvOXkcNgrd29jzwXKDYYiUa1DISz\n" +
"DnYaJOgPt0B/5izhoWNK7GhJDy9KEuLURcTSWFysbbnljwO9INPT9MmlS83PdAgN\n" +
"iS8VXF4pce1W9U5jH7d7k0JDVSXybebe1iPFphsZpYM/NE+jap+mPy1nTCbf9g==\n" +
"-----END CERTIFICATE-----\n" +
"-----BEGIN CERTIFICATE-----\n" +
"MIIC0zCCAoWgAwIBAgIIXpLoPpQVWnkwBQYDK2VwMFoxCzAJBgNVBAYTAkVOMRAw\n" +
"DgYDVQQIEwdFbmdsYW5kMQ8wDQYDVQQHEwZMb25kb24xDDAKBgNVBAoTA3RzMTEM\n" +
"MAoGA1UECxMDdHMxMQwwCgYDVQQDEwN0czEwHhcNMjMxMjA1MDczNzAwWhcNMjQw\n" +
"OTAxMjM1OTAwWjBaMQswCQYDVQQGEwJFTjEQMA4GA1UECBMHRW5nbGFuZDEPMA0G\n" +
"A1UEBxMGTG9uZG9uMQwwCgYDVQQKEwN0czIxDDAKBgNVBAsTA3RzMjEMMAoGA1UE\n" +
"AxMDdHMyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtt+2QxUevbol\n" +
"YLp51QGcUpageI4fwGLIqv4fj4aoVnHFOOBqVOVpfCLRp26LFV/F8ebwPyo8YEBK\n" +
"SwXzMD1573rMSbaH9BalscH5lZYAbetXoio6YRvzlcmcrVvLBNMeVnxY86xHpo0M\n" +
"TNyP7W024rZsxWO98xFQVdoiaBC+7+midlisx2Y+7u0jzT9GjeUP6JLdLFUZJKUP\n" +
"STK3jVzw9v1eZQZKYoNfU6vFMd6ndtwW6qEnwpzmmX/UT+p5ThAMH593zszlz330\n" +
"nTSXBjIsGkyvOz9gSB0Z0LAuJj06XUNhGL5xKJYKbdI38MFQFJKvRHfgTAvVsvAv\n" +
"pBUM2DuBKwIDAQABo28wbTAMBgNVHRMEBTADAQH/MB0GA1UdDgQWBBQ37B0zGcKA\n" +
"OnmgxZQVMg6ZGvrGLTALBgNVHQ8EBAMCAQYwEQYJYIZIAYb4QgEBBAQDAgAHMB4G\n" +
"CWCGSAGG+EIBDQQRFg94Y2EgY2VydGlmaWNhdGUwBQYDK2VwA0EAuasLBe55YgvF\n" +
"b4wmHeohylc9r8cFGS1LNQ5UcSn3sGqMYf6ehnef16NLuCW6upHCs8Sui4iAMvsP\n" +
"uKPWR9dKBA==\n" +
"-----END CERTIFICATE-----\n" +
"-----BEGIN CERTIFICATE-----\n"  +
"MIIB3zCCAZGgAwIBAgIIWQvOEDl+ya4wBQYDK2VwMFoxCzAJBgNVBAYTAkVOMRAw\n" +
"DgYDVQQIEwdFbmdsYW5kMQ8wDQYDVQQHEwZMb25kb24xDDAKBgNVBAoTA3RzMTEM\n" +
"MAoGA1UECxMDdHMxMQwwCgYDVQQDEwN0czEwHhcNMjMxMjA1MDAwMDAwWhcNMjQx\n" +
"MjA0MjM1OTU5WjBaMQswCQYDVQQGEwJFTjEQMA4GA1UECBMHRW5nbGFuZDEPMA0G\n" +
"A1UEBxMGTG9uZG9uMQwwCgYDVQQKEwN0czExDDAKBgNVBAsTA3RzMTEMMAoGA1UE\n" +
"AxMDdHMxMCowBQYDK2VwAyEAuxadj1ww0LqPN24zr28jcSOlSWAe0QdLyRF+ZgG6\n" +
"klKjdTBzMBIGA1UdEwEB/wQIMAYBAf8CARQwHQYDVR0OBBYEFNSgpoQvfxR8A1Y4\n" +
"St8NjOHkRpm4MAsGA1UdDwQEAwIBBjARBglghkgBhvhCAQEEBAMCAAcwHgYJYIZI\n" +
"AYb4QgENBBEWD3hjYSBjZXJ0aWZpY2F0ZTAFBgMrZXADQQAblBgoa72X/K13WOvc\n" +
"KW0fqBgFKvLy85hWD6Ufi61k4ProQiZzMK+0+y9jReKelPx/zRdCCgSbQroAR2mV\n" +
"xjoE\n" +
"-----END CERTIFICATE-----\n";
async function sample() {
let textEncoder = new util.TextEncoder();
// 证书链二进制数据，需业务自行赋值
const encodingBlob: cert.EncodingBlob = {
data: textEncoder.encodeInto(certChainData),
// 根据encodingData的格式进行赋值，支持FORMAT_PEM、FORMAT_DER和FORMAT_PKCS7
encodingFormat: cert.EncodingFormat.FORMAT_PEM
};
let x509CertChain: cert.X509CertChain = {} as cert.X509CertChain;
try {
x509CertChain = await cert.createX509CertChain(encodingBlob);
} catch (err) {
let e: BusinessError = err as BusinessError;
console.error(`createX509CertChain failed, errCode: ${e.code}, errMsg: ${e.message}`);
}
try {
let certList = x509CertChain.getCertList();
} catch (err) {
let e: BusinessError = err as BusinessError;
console.error(`X509CertChain getCertList failed, errCode: ${e.code}, errMsg: ${e.message}`);
}
// 证书链校验数据，需业务自行赋值
const param: cert.CertChainValidationParameters = {
date: '20231212080000Z',
trustAnchors: [{
CAPubKey: new Uint8Array([0x30, 0x2a, 0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70, 0x03, 0x21, 0x00, 0xbb, 0x16,0x9d, 0x8f, 0x5c, 0x30, 0xd0, 0xba, 0x8f, 0x37, 0x6e, 0x33, 0xaf, 0x6f, 0x23, 0x71, 0x23, 0xa5, 0x49, 0x60,0x1e, 0xd1, 0x07, 0x4b, 0xc9, 0x11, 0x7e, 0x66, 0x01, 0xba, 0x92, 0x52]),
CASubject: new Uint8Array([0x30, 0x5a, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x45,0x4e, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x07, 0x45, 0x6e, 0x67, 0x6c, 0x61, 0x6e,0x64, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x06, 0x4c, 0x6f, 0x6e, 0x64, 0x6f, 0x6e,0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x03, 0x74, 0x73, 0x31, 0x31, 0x0c, 0x30, 0x0a,0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x03, 0x74, 0x73, 0x31, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04,0x03, 0x13, 0x03, 0x74, 0x73, 0x31]),
}]
};
try {
const validationRes = await x509CertChain.validate(param);
console.log('X509CertChain validate success');
} catch (err) {
console.error('X509CertChain validate failed');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/certmanager-V14
爬取时间: 2025-04-28 01:59:07
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/certmanager-overview-V14
爬取时间: 2025-04-28 01:59:21
来源: Huawei Developer
证书管理主要提供系统级的证书管理能力，实现证书全生命周期（安装、存储、使用和销毁）的管理和安全使用。
证书管理基本概念
证书生命周期管理概述
实现业务证书和CA证书的安装、存储、使用和销毁管理，保证证书安全使用。
约束与限制
证书管理目前仅支持业务证书的使用，并仅支持RSA及ECC算法类型的私有凭据安装及使用。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/certmanager-guidelines-V14
爬取时间: 2025-04-28 01:59:34
来源: Huawei Developer
本开发指导需使用API version 11及以上版本SDK。
场景说明
1.  典型场景： 安装应用证书和私有凭据。 获取应用证书和私有凭据。 使用应用证书和私有凭据对数据进行签名、验签。 卸载指定的应用证书和私有凭据。
2.  安装应用证书和私有凭据。
3.  获取应用证书和私有凭据。
4.  使用应用证书和私有凭据对数据进行签名、验签。
5.  卸载指定的应用证书和私有凭据。
6.  支持安装的私有凭据算法类型&签名验签支持的参数组合。 证书管理安装凭据及使用凭据中的密钥进行签名、验签，依赖通用密钥库（HUKS）能力，证书管理支持的算法为其子集，当前仅支持RSA及ECC算法类型的私有凭据安装及使用。签名、验签支持的参数组合，详见HUKS声明的签名/验签介绍及算法规格中RSA及ECC的描述。
-  安装应用证书和私有凭据。
-  获取应用证书和私有凭据。
-  使用应用证书和私有凭据对数据进行签名、验签。
-  卸载指定的应用证书和私有凭据。
接口说明
详细接口说明可参考API参考。
以上场景涉及的常用接口如下表所示：
| 实例名 | 接口名 | 描述 |
| --- | --- | --- |
| certificateManager | installPrivateCertificate(keystore: Uint8Array, keystorePwd: string, certAlias: string, callback: AsyncCallback<CMResult>) : void | 使用callback方式安装应用私有凭据 |
| certificateManager | installPrivateCertificate(keystore: Uint8Array, keystorePwd: string, certAlias: string) : Promise<CMResult> | 使用promise方式安装应用私有凭据 |
| certificateManager | getPrivateCertificate(keyUri: string, callback: AsyncCallback<CMResult>) : void | 使用callback方式获取应用私有凭据 |
| certificateManager | getPrivateCertificate(keyUri: string) : Promise<CMResult> | 使用promise方式获取应用私有凭据 |
| certificateManager | uninstallPrivateCertificate(keyUri: string, callback: AsyncCallback<void>) : void | 使用callback方式卸载应用私有凭据 |
| certificateManager | uninstallPrivateCertificate(keyUri: string) : Promise<void> | 使用promise方式卸载应用私有凭据 |
| certificateManager | init(authUri: string, spec: CMSignatureSpec, callback: AsyncCallback<CMHandle>) : void | 使用callback方式进行签名验签的初始化操作 |
| certificateManager | init(authUri: string, spec: CMSignatureSpec) : Promise<CMHandle> | 使用promise方式进行签名验签的初始化操作 |
| certificateManager | update(handle: Uint8Array, data: Uint8Array, callback: AsyncCallback<void>) : void | 使用callback方式对待签名、验签的数据进行更新操作 |
| certificateManager | update(handle: Uint8Array, data: Uint8Array) : Promise<void> | 使用promise方式对待签名、验签的数据进行更新操作 |
| certificateManager | finish(handle: Uint8Array, callback: AsyncCallback<CMResult>) : void | 使用callback方式完成数据的签名操作 |
| certificateManager | finish(handle: Uint8Array, signature: Uint8Array, callback: AsyncCallback<CMResult>) : void | 使用callback方式完成数据的签名操作 |
| certificateManager | finish(handle: Uint8Array, signature?: Uint8Array) : Promise<CMResult> | 使用promise方式完成数据的签名、验签操作 |
| certificateManager | abort(handle: Uint8Array, callback: AsyncCallback<void>) : void | 使用callback方式中止签名、验证操作 |
| certificateManager | abort(handle: Uint8Array) : Promise<void> | 使用promise方式中止签名、验证操作 |
开发步骤
1.  申请权限。调用证书管理相关接口，需要在module.json5文件的requestPermissions对象中配置ohos.permission.ACCESS_CERT_MANAGER权限。更多配置信息请参考Stage模型应用程序包结构。
2.  导入相关模块。
```typescript
import { certificateManager } from '@kit.DeviceCertificateKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
3.  安装应用私有凭据，获取应用私有凭据，并使用应用私有凭据进行签名、验签，最后删除应用私有凭据。
```typescript
async function certificateManagerSample() {
/* 安装的凭据数据需要业务赋值，本例数据非凭据数据 */
let keystore: Uint8Array = new Uint8Array([
0x30, 0x82, 0x04, 0x6a, 0x02, 0x01,
]);
/* 安装凭据对应的密码，业务赋值 */
let keystorePwd: string = '123456';
let appKeyUri: string = '';
try {
/* 安装私有凭据 */
const res: certificateManager.CMResult = await certificateManager.installPrivateCertificate(keystore, keystorePwd, "testPriCredential");
appKeyUri = (res.uri != undefined) ? res.uri : '';
} catch (err) {
let e: BusinessError = err as BusinessError;
console.error(`Failed to install private certificate. Code: ${e.code}, message: ${e.message}`);
}
try {
/* srcData为待签名、验签的数据，业务自行赋值 */
let srcData: Uint8Array = new Uint8Array([
0x86, 0xf7, 0x0d, 0x01, 0x07, 0x01,
]);
/* 构造签名的属性参数 */
const signSpec: certificateManager.CMSignatureSpec = {
purpose: certificateManager.CmKeyPurpose.CM_KEY_PURPOSE_SIGN,
padding: certificateManager.CmKeyPadding.CM_PADDING_PSS,
digest: certificateManager.CmKeyDigest.CM_DIGEST_SHA256
};
/* 签名 */
const signHandle: certificateManager.CMHandle = await certificateManager.init(appKeyUri, signSpec);
await certificateManager.update(signHandle.handle, srcData);
const signResult: certificateManager.CMResult = await certificateManager.finish(signHandle.handle);
/* 构造验签的的属性参数 */
const verifySpec: certificateManager.CMSignatureSpec = {
purpose: certificateManager.CmKeyPurpose.CM_KEY_PURPOSE_VERIFY,
padding: certificateManager.CmKeyPadding.CM_PADDING_PSS,
digest: certificateManager.CmKeyDigest.CM_DIGEST_SHA256
};
/* 验签 */
const verifyHandle: certificateManager.CMHandle = await certificateManager.init(appKeyUri, verifySpec);
await certificateManager.update(verifyHandle.handle, srcData);
const verifyResult = await certificateManager.finish(verifyHandle.handle, signResult.outData);
console.info('Succeeded in signing and verifying.');
} catch (err) {
let e: BusinessError = err as BusinessError;
console.error(`Failed to sign or verify. Code: ${e.code}, message: ${e.message}`);
}
try {
/* 卸载私有凭据 */
await certificateManager.uninstallPrivateCertificate(appKeyUri);
} catch (err) {
let e: BusinessError = err as BusinessError;
console.error(`Failed to uninstall private certificate. Code: ${e.code}, message: ${e.message}`);
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/certmanagerdialog-guidelines-V14
爬取时间: 2025-04-28 01:59:48
来源: Huawei Developer
本开发指导需使用API version 13及以上版本SDK。
证书管理对话框，可用于拉起证书管理页面并管理证书，如安装、存储、使用、销毁证书。
接口说明
详细接口说明可参考API参考。
以上场景涉及的常用接口如下表所示：
| 实例名 | 接口名 | 描述 |
| --- | --- | --- |
| certificateManagerDialog | openCertificateManagerDialog(context: common.Context, pageType: CertificateDialogPageType): Promise<void> | 拉起证书管理对话框，显示相应的页面，使用Promise方式异步返回结果 |
开发步骤
1.  申请ohos.permission.ACCESS_CERT_MANAGER权限。可参考申请应用权限-声明权限。
2.  导入相关模块。
```typescript
import { certificateManagerDialog } from '@kit.DeviceCertificateKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { common } from '@kit.AbilityKit';
```
3.  拉起证书管理界面。
```typescript
async function certificateManagerDialogSample() {
/* context为应用的上下文信息，由调用方自行获取，此处仅为示例 */
let context: common.Context = getContext(this);
/* pageType为页面类型，此处赋值PAGE_MAIN，即拉起证书管理主界面 */
let pageType: certificateManagerDialog.CertificateDialogPageType = certificateManagerDialog.CertificateDialogPageType.PAGE_MAIN;
try {
certificateManagerDialog.openCertificateManagerDialog(context, pageType).then(() => {
console.info('Succeeded in opening certificate manager dialog.');
}).catch((err: BusinessError) => {
console.error(`Failed to open certificate manager dialog. Code: ${err.code}, message: ${err.message}`);
})
} catch (error) {
console.error(`Failed to open certificate manager dialog. Code: ${error.code}, message: ${error.message}`);
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/device-attestation-V14
爬取时间: 2025-04-28 02:00:01
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/device-attestation-intro-V14
爬取时间: 2025-04-28 02:00:15
来源: Huawei Developer
设备真实性证明能力，提供了设备真实性证明和应用身份证明的能力，采用标准的X509证书格式，基于密码算法、证书链实现校验业务请求是否来自真实设备和合法应用，帮助开发者识别黑灰产的攻击行为。
亮点/特征
使用场景
设备真实性证明能力主要可以抵御以下攻击场景：
具体潜在的使用场景包括但不限于：
与相关Kit的关系
设备真实性证明由设备证书Kit（Device Certificate Kit）提供基于设备证书的安全证明能力，开放接口通过密钥管理服务Kit（Universal Keystore Kit）进行开放。
约束与限制
服务配额
| 接口  | 配额  | 配额说明  |
| --- | --- | --- |
| 匿名密钥证明接口  | 50万次/天/应用 且 35次/秒/应用  | 默认情况下，每个应用每天最多可以调用50万次的匿名密钥证明接口（anonAttestKeyItem / OH_Huks_AnonAttestKeyItem）且瞬时流量每秒不超过35次请求。如果您的应用需要修改服务配额，请通过在线提单申请修改配额。  |
接口
配额
配额说明
匿名密钥证明接口
50万次/天/应用
且 35次/秒/应用
默认情况下，每个应用每天最多可以调用50万次的匿名密钥证明接口（anonAttestKeyItem/OH_Huks_AnonAttestKeyItem）且瞬时流量每秒不超过35次请求。如果您的应用需要修改服务配额，请通过在线提单申请修改配额。
框架原理
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170442.17510740877851338966439405858627:50001231000000:2800:160042B4DBEA1C72BB48325AD5D45FE37F622FEC6AC07313B909C2FB5BE1D9E9.png)
设备真实性证明能力提供了设备真实性证明和应用身份证明的能力，该能力基于硬件级的设备证书进行认证。
如图所示，过程大致为：
交互流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170442.88877445272038659894165998106162:50001231000000:2800:C0FBD605723D2EFBE99BBF081218282498891CA75BA07FBD63464D3E7D92B316.png)
设备真实性证明的开发流程可以划分为2个子流程：
1.  设备证明服务器可能会限制来自特定应用的认证流量，以避免在太多应用同时进行调用时出现过载，从而导致应用处理失败，因此请勿在每次业务请求时都对应用公钥进行证明。 当设备真实性证明能力由于流量过载或其他原因不可用时，应用需要考虑异常处理方案，避免出现应用基本功能不可用。
密钥证明和保存流程
1.  创建应用公私钥对：创建一个用于证明设备真实性和应用身份的非对称算法密钥对（包含应用公钥和应用私钥），比如RSA、EC算法的密钥对。
2.  无论校验是否通过，均需要删除服务器缓存的挑战值Challenge。
校验业务请求的流程
无论校验是否通过，均需要删除服务器缓存的挑战值Challenge。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/device-attestation-guidelines-V14
爬取时间: 2025-04-28 02:00:29
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/device-attestation-apps-V14
爬取时间: 2025-04-28 02:00:42
来源: Huawei Developer
接口说明
接口能力由Universal Keystore Kit提供，涉及的功能指导请参考：
查询应用公私钥对是否存在
查询用于设备真实性证明的应用公私钥对是否存在，如果应用公私钥对已存在，则不需要重复创建应用公私钥对。
样例代码：
创建应用公私钥对
创建一个用于证明设备真实性和应用身份的非对称算法密钥对，称为应用公私钥对（包含应用公钥和应用私钥），比如RSA、EC算法的密钥对。通过Universal Keystore Kit场景的密钥对基于硬件的安全环境进行生成和安全存储。
安全建议：对于有用户登录的应用场景，为了提高安全性，建议为终端设备中登录的每个用户生成不同的密钥对，并在应用服务器绑定用户与应用公钥之间的关系。
样例代码：
对应用公钥进行证明
应用调用Universal Keystore Kit接口对生成的应用公钥和调用的应用身份进行证明，Universal Keystore Kit会使用基于硬件的设备证书对应用公钥进行证明，证明公钥来自真实的设备。
Universal Keystore Kit返回密钥证明证书链，证书链采用X509标准格式。
安全建议：为了在发送密钥证明证书链给应用服务器时能够防重放攻击，建议应用先从应用服务器获取一次性的挑战值Challenge。应用服务器采用安全随机数生成挑战值Challenge，并缓存到服务器中。
样例代码：
使用应用私钥对业务请求进行签名
在密钥证明流程处理成功后，应用在进行一些安全敏感的端云业务时，可以使用已证明的密钥对业务请求进行安全保护。
应用可以调用Universal Keystore Kit接口使用应用私钥对业务请求数据（如HTTP请求的Body）进行签名，然后把签名数据添加到请求消息中（如HTTP的Header字段）。为了方便应用服务器查找应用公钥用于验签，可以在业务请求中携带应用公钥的密钥ID（如：通过对应用公钥计算Hash）。
安全建议：为了在发送业务请求时能够防重放攻击，建议应用先从应用服务器获取一次性的挑战值Challenge。应用服务器采用安全随机数生成挑战值Challenge，并缓存到服务器中。
样例代码：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/device-attestation-servers-V14
爬取时间: 2025-04-28 02:00:56
来源: Huawei Developer
对密钥证明证书链进行校验
密钥证明证书链采用X509标准格式，证书链（证书数组）中的第一本证书为密钥证明证书，最后一本证书为根CA证书，中间的为子CA证书。
应用服务器对密钥证明证书链的校验处理过程：
1.  请勿在应用服务器中使用子CA证书对密钥证明证书链进行校验，子CA证书可能会因为有效期结束、证书被吊销等发生变化。
2.  其中应用公钥直接从密钥证明证书的subjectPublicKeyInfo字段获取； 其他字段从密钥证明证书的扩展域段（Extensions）中获取，扩展域段的OID为1.3.6.1.4.1.2011.2.376.1.3（密钥证明扩展域段）。
密钥证明证书格式说明：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170443.65821602181866265629468663211735:50001231000000:2800:9E2ACB3A1D7B433116D8B6F710E200CDB4AEF87251CF154951230732A2CE9F1F.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170443.38592988142105982991702999561273:50001231000000:2800:8A1DF0F1D79356B5DF5C85194FED6C99B475029F91920ABEC8B1D3C4EAD777E5.png)
密钥证明扩展域段为Asn.1 DER标准编码格式，数据结构定义如下：
AttestationClaim类型取值说明：
| 序号  | type（OID）取值  | value的数据类型  | securityLevel  | Claim说明  |
| --- | --- | --- | --- | --- |
| 1  | 1.3.6.1.4.1.2011.2.376.2.1.4  | OCT_STR  | 保留字段，暂不使用  | 应用输入的挑战字Challenge  |
| 2  | 1.3.6.1.4.1.2011.2.376.2.1.3  | ApplicationIDType  | 保留字段，暂不使用  | 应用ID。  |
| 3  | 1.3.6.1.4.1.2011.2.376.2.2.2.6  | OCT_STR  | 保留字段，暂不使用  | 密钥管理部件ID。取值固定为：0x28c4fb4944afec11b9090242ac120002  |
序号
type（OID）取值
value的数据类型
securityLevel
Claim说明
1
1.3.6.1.4.1.2011.2.376.2.1.4
OCT_STR
保留字段，暂不使用
应用输入的挑战字Challenge
2
1.3.6.1.4.1.2011.2.376.2.1.3
ApplicationIDType
保留字段，暂不使用
应用ID。
3
1.3.6.1.4.1.2011.2.376.2.2.2.6
OCT_STR
保留字段，暂不使用
密钥管理部件ID。取值固定为：0x28c4fb4944afec11b9090242ac120002
ApplicationIDType类型取值说明：
| type（OID）取值  | value取值说明  |
| --- | --- |
| 1.3.6.1.4.1.2011.2.376.2.1.3.1  | HarmonyOS Hap应用ID，包含bundleName和签名证书公钥的hash。 value为json字符串，样例如下： { "appId":"com.example.attesthcts_BDmjsOezxRmguzlYRVhQavW22Eswi5sX61wOAysWPOGS8TZ5tY1u1A9EcvarzyrfOEj5zT8BCGkfFkVjn0m5wzo=", "bundleName":"com.example.attesthcts" }  |
| 1.3.6.1.4.1.2011.2.376.2.1.3.2  | 系统服务（Service Ability）的ID，样例： {processName: "huawei_share"}  |
type（OID）取值
value取值说明
1.3.6.1.4.1.2011.2.376.2.1.3.1
HarmonyOS Hap应用ID，包含bundleName和签名证书公钥的hash。
value为json字符串，样例如下：
{
"appId":"com.example.attesthcts_BDmjsOezxRmguzlYRVhQavW22Eswi5sX61wOAysWPOGS8TZ5tY1u1A9EcvarzyrfOEj5zT8BCGkfFkVjn0m5wzo=",
"bundleName":"com.example.attesthcts"
}
1.3.6.1.4.1.2011.2.376.2.1.3.2
系统服务（Service Ability）的ID，样例：
{processName: "huawei_share"}
样例代码：
保存应用公钥到数据库
应用服务器对密钥证明证书链校验通过后，把密钥证明证书中的应用公钥保存到服务器的数据库中（“对密钥证明证书链进行校验”的样例代码中已包含公钥保存的示例代码），以便对后续的业务请求进行验证。在保存应用公钥前应确保公钥的唯一性，系统中不应该存在多个相同的公钥。
安全建议：对于有用户登录的应用场景，为了提高安全性，建议为终端设备中登录的每个用户生成不同的密钥对，并在应用服务器绑定用户与应用公钥之间的关系
实现提示：对业务请求进行验签时需要先查找到应用公钥，建议对应用公钥计算密钥ID（如：对应用公钥计算Hash）并存储密钥ID与应用公钥的关系，通过密钥ID来查找应用公钥。
使用应用公钥对业务请求进行验签
应用服务器首先校验挑战值Challenge，然后根据应用公钥的密钥ID到数据库查找应用公钥。
安全建议：对于有用户登录且应用公钥绑定用户ID的应用场景，应该根据应用公钥的密钥ID+当前登录的用户ID查找应用公钥。
应用服务器再使用应用公钥对请求中的签名进行验签。
样例代码：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/device-attestation-practice-V14
爬取时间: 2025-04-28 02:01:09
来源: Huawei Developer
本文档以密钥绑定登录用户的应用场景为例说明应用集成密钥证明和敏感业务请求校验的设计方案。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170443.08239585529404629538053826745840:50001231000000:2800:CF97911456398ACFAE0F24C426DA6E420C6B3C900F4E2EBCAA3C024849BB4D11.png)
以下样例中的步骤解释均以密钥绑定登录用户的应用场景为例。
不绑定登录用户场景的实现样例类似，主要的差异点：
密钥证明和保存流程
一个登录用户只进行一次密钥证明和保存的流程，触发时机为用户登录成功。
1.  如果应用公私钥对已存在，则说明用户在本设备曾经登录过，本流程结束；否则进入步骤2。
2.  创建应用公私钥对：创建一个用于证明设备真实性和应用身份的非对称算法密钥对（包含应用公钥和应用私钥），比如RSA、EC算法的密钥对。
3.  用户ID，Challenge值，业务流程（如“密钥证明和保存流程”）
4.  （1）请求消息包含：用户ID、密钥ID、密钥证明证书链。 （2）其中密钥ID通过应用公钥计算hash得到，如：密钥ID=base64（Sha256（应用公钥）），应用公钥可以通过Universal Keystore Kit的密钥导出接口获取。
5.  （1）先参考样例代码完成证书链合法性校验，并解析出应用公钥、挑战值Challenge、应用身份信息、密钥管理部件ID。 （2）根据请求消息中的用户ID、Challenge到服务器缓存查找是否存在相关的记录，且业务流程为“密钥证明和保存流程”，并删除缓存的Challenge记录。 （3）校验应用身份信息是否与预期的应用一致，包括应用包名和应用签名密钥。 （4）校验密钥管理部件ID是否取值为0x28c4fb4944afec11b9090242ac120002（代表Universal Keystore Kit）
6.  数据库记录包含如下字段：用户ID、密钥ID、应用公钥
校验业务请求流程
触发时机为应用处理安全相关的业务（如抢购、领优惠券）。
1.  用户ID，Challenge值，业务流程（如“密钥使用流程”）
2.  需要对“Challenge+业务请求数据”进行签名。
3.  （1）请求消息包含：用户ID、应用公钥的密钥ID、Challenge、签名数据。 （2）其中密钥ID通过应用公钥计算hash得到，同上。
4.  （1）根据请求消息中的用户ID、Challenge到服务器缓存查找是否存在相关的记录，且业务流程为“密钥使用流程”，并删除缓存的Challenge记录。 （2）再根据用户ID、密钥ID到数据库查询应用公钥。
5.  应用按照流程图的1.3~1.8流程进行密钥证明和保存处理，处理成功后再重试2.1~2.6的业务流程。 应用可能会基于服务器数据库容量的考虑，会删除长时间不使用的应用公钥记录，此时会触发步骤7。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/device-security-kit-guide-V14
爬取时间: 2025-04-28 02:01:23
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-introduction-V14
爬取时间: 2025-04-28 02:01:36
来源: Huawei Developer
Device Security Kit（设备安全服务）提供应用设备状态检测（DeviceVerify）、安全检测（SafetyDetect）、可信应用服务（TrustedAppService）、业务风险检测（BusinessRiskIntelligentDetection）和安全审计（SecurityAudit），可以保护应用程序免受安全威胁和保证应用的数据安全。
场景介绍
基本概念
功能使用限制
只支持中国境内（不包含中国香港、中国澳门、中国台湾）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-quota-V14
爬取时间: 2025-04-28 02:01:50
来源: Huawei Developer
| 功能  | 配额说明  |
| --- | --- |
| 应用设备状态检测（DeviceVerify）  | API限额：默认情况下，每个应用每天最多可以调用10万次的DeviceVerify Rest接口请求。 如果应用需要修改服务配额，请通过在线提单申请修改配额。 问题分类：选择HarmonyOS NEXT/系统/Device Security Kit。问题描述：填写申请原因、申请应用、配额大小以及使用场景。 我们会在5个工作日内回复申请结果，请留意电话和邮箱消息。  |
| 安全检测（SafetyDetect）  | 系统完整性检测API：每个应用在每个设备上每天最多可以调用1万次、每分钟最多调用5次。URL检测API：每个应用在每个设备上每天最多可以调用1万次。  |
| 业务风险检测（BusinessRiskIntelligentDetection）  | 每个应用在每个设备上每天最多可以调用10次接口。  |
功能
配额说明
应用设备状态检测（DeviceVerify）
API限额：默认情况下，每个应用每天最多可以调用10万次的DeviceVerify Rest接口请求。
如果应用需要修改服务配额，请通过在线提单申请修改配额。
我们会在5个工作日内回复申请结果，请留意电话和邮箱消息。
安全检测（SafetyDetect）
业务风险检测（BusinessRiskIntelligentDetection）
每个应用在每个设备上每天最多可以调用10次接口。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-prepare-V14
爬取时间: 2025-04-28 02:02:03
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-deviceverify-activateservice-V14
爬取时间: 2025-04-28 02:02:17
来源: Huawei Developer
在开通Device Security服务前，请先参考“应用开发准备”完成基本准备工作，再继续进行以下开发活动。
Device Security包括应用设备状态检测、安全检测、可信应用服务、业务风险检测能力，开发者请根据实际使用场景，选择开启某个或者多个能力开关。
1.
2.
3.  开通“可信应用服务”需要先申请进入允许清单，请将Developer ID、公司名称、应用名称、申请使用的服务和使用该服务的场景，发送到agconnect@huawei.com。AGC运营将审核相关材料，通过后将为您配置受限开放服务使用的名单，审核周期为1-3个工作日，请耐心等待。 目前“业务风险检测服务-涉诈剧本检测”仅限受邀开发者开放。
4.  开通“可信应用服务”需要先申请进入允许清单，请将Developer ID、公司名称、应用名称、申请使用的服务和使用该服务的场景，发送到agconnect@huawei.com。AGC运营将审核相关材料，通过后将为您配置受限开放服务使用的名单，审核周期为1-3个工作日，请耐心等待。
5.  目前“业务风险检测服务-涉诈剧本检测”仅限受邀开发者开放。
6.  在开通服务后，需要重新申请Profile（.p7b）文件。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170444.57779499821067693259964490245970:50001231000000:2800:ABB25AE091252CA2D4A1A1BF23818C7A25159B89638881A4A48B0D28A11CCBD5.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170444.13184470252133126903533203638589:50001231000000:2800:FF5720FF30BE032C7EC3C17370ECD66310824314277F2AA2AE063DCC0AC45308.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170444.13024203051916676891064131638945:50001231000000:2800:4539AB31C0609D5580CA8400DC3E2A1D1EEDF7E75421154C21830F865D1040A0.png)
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170444.87247833720969388669433820269458:50001231000000:2800:2BB713D182BAEF29B8F2F8B8FB92DE5B79DF4E836B79FD0822173D2C3791B62F.png)
-  开通“可信应用服务”需要先申请进入允许清单，请将Developer ID、公司名称、应用名称、申请使用的服务和使用该服务的场景，发送到agconnect@huawei.com。AGC运营将审核相关材料，通过后将为您配置受限开放服务使用的名单，审核周期为1-3个工作日，请耐心等待。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170444.48870867565944679760589738949680:50001231000000:2800:9248F9E96F09A945F6D51EB1970B11423658A412DAF45C3E9216BF4CB3C0DF5C.png)
-  目前“业务风险检测服务-涉诈剧本检测”仅限受邀开发者开放。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170444.65764012087813969614875113081926:50001231000000:2800:F0DE43AEC990DC11CB113C846B355CF691A33E21E5FF0383E873C9B51CFFAFF0.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-deviceverify-token-V14
爬取时间: 2025-04-28 02:02:30
来源: Huawei Developer
只有使用应用设备状态检测服务时才需要配置此章节。
概述
服务账号（Service Account）是一种可实现服务器与服务器之间接口鉴权的账号，在华为开发者联盟的API Console上创建服务账号，您可根据返回的公私钥在业务应用中生成鉴权令牌，调用支持此类鉴权的华为公开API。
服务账号令牌为JWT（JSON Web Token）格式字符串，JWT数据格式包括三个部分：
这三个部分通过“.”进行连接，其中Signature为通过SHA256withRSA算法对Header与Payload拼接的字符串签名生成的字符串。
示例
```json
eyJra*****JjNjBjMXXX.
eyJhd*****JodHRXXX.
BRNss*****7az5oU7-Zp5g9X2WJVXXX
```
更多JWT的相关知识请参见Introduction to JSON Web Tokens。
开发步骤
1.  开发者需要在华为开发者联盟的API Console上创建并下载服务账号的密钥文件，相关创建步骤请参见API Console操作指南-服务账号密钥。 您在开发者联盟需要申请开发者级的服务账号凭证。 您申请后的服务账号密钥样例文件形式可参考：
```json
{
"project_id": "*****",
"key_id": "*****",
"private_key": "-----BEGIN PRIVATE KEY-----\nMIIJQgIBADANBgkqhkiG9w0BAQEFAASCCSwwggkoAgEAAoICAQCKw6kJKtCh7qmMvp1u1dI27z2TKZrPOzHbQaXO/Eez0AWZ2EN+ouF496R3pfo7fQXC1XOT/YTbVC4DNZwWSMA54fu3/AOCY9Zzyi46OK*****==\n-----END PRIVATE KEY-----\n",
"sub_account": "*****",
"auth_uri": "https://oauth-login.cloud.huawei.com/oauth2/v3/authorize",
"token_uri": "https://oauth-login.cloud.huawei.com/oauth2/v3/token",
"auth_provider_cert_uri": "https://oauth-login.cloud.huawei.com/oauth2/v3/certs",
"client_cert_uri": "https://oauth-login.cloud.huawei.com/oauth2/v3/x509?client_id=*****"
}
```
2.  根据服务账号密钥文件中的key_id字段拼接以下JSON体，对JSON体进行BASE64编码。 字段名 描述 kid 服务账号密钥文件中key_id字段。 typ 数据类型，固定为：JWT。 alg 算法类型，固定为：PS256。
```json
{
"kid": "*****",
"typ": "JWT",
"alg": "PS256"
}
```
3.  根据服务账号密钥文件中的sub_account字段拼接以下JSON体，对JSON体进行BASE64编码。 字段名 描述 iss 服务账号密钥文件中sub_account字段，标识数据生成者。 aud 固定为：https://oauth-login.cloud.huawei.com/oauth2/v3/token。 iat JWT签发UTC时间戳，为自UTC时间1970年1月1日00:00:00的秒数（应用服务器时间需要校准为标准时间）。 exp JWT到期UTC时间戳，建议比“iat”晚3600秒。
```json
{
"aud": "https://oauth-login.cloud.huawei.com/oauth2/v3/token",
"iss": "*****",
"exp": 1581410664,
"iat": 1581407064
}
```
4.  将完成BASE64编码后的Header字符串与Payload字符串，通过“.”进行连接，并在开发者的应用中，通过服务账号密钥文件中的private_key（华为不进行存储，请您妥善保管），使用SHA256withRSA/PSS算法对拼接的字符串签名，最后将Header，Payload以及字符串签名通过“.”进行连接，即可得到Token数据。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170444.00547578374855709680733861427527:50001231000000:2800:E41D7BD511D78692F9AC0F1365E199817DAC6CEE425EBFFB33B74007FE85F827.png)
| 字段名  | 描述  |
| --- | --- |
| kid  | 服务账号密钥文件中key_id字段。  |
| typ  | 数据类型，固定为：JWT。  |
| alg  | 算法类型，固定为：PS256。  |
| 字段名  | 描述  |
| --- | --- |
| iss  | 服务账号密钥文件中sub_account字段，标识数据生成者。  |
| aud  | 固定为：https://oauth-login.cloud.huawei.com/oauth2/v3/token。  |
| iat  | JWT签发UTC时间戳，为自UTC时间1970年1月1日00:00:00的秒数（应用服务器时间需要校准为标准时间）。  |
| exp  | JWT到期UTC时间戳，建议比“iat”晚3600秒。  |
示例代码
为了方便您生成服务账号鉴权令牌，我们提供了Java语言的示例代码，请按照说明替换参数运行。
如果您使用其他开发语言，请选择对应的JWT开源组件进行开发。
执行main()函数即可。
推荐的java版本为java8，maven依赖如下：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-deviceverify-develop-V14
爬取时间: 2025-04-28 02:02:44
来源: Huawei Developer
场景介绍
应用通过调用Device Security Kit的getDeviceToken接口获取到DeviceToken，应用的服务器使用DeviceToken到Device Security服务器查询和管理应用在该设备的使用状态。
应用可以根据Device Security服务器返回的使用状态，判断应用是否在该设备上首次安装，或在该设备上用户是否已获取了优惠券等，以支撑业务进行新用户营销活动。
约束与限制
应用设备状态检测（DeviceVerify）能力不支持模拟器。
业务流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170444.81647884709934961896267023045164:50001231000000:2800:1217D9EA6302826C629AF8B0EF57B9B1AC3A4602BB5188A7F6BF6FE4B681B89B.png)
流程说明：
接口说明
以下是DeviceVerify相关接口，包括ArkTS API和REST API。
| 接口名 | 描述 |
| --- | --- |
| getDeviceToken(): Promise<string> | 获取本设备的DeviceToken |
| checkDeviceToken | 验证deviceToken |
| getDeviceStatus | 查询设备标记状态 |
| setDeviceStatus | 更新设备标记状态 |
| delDeviceStatus | 删除设备标记状态 |
接口名
描述
getDeviceToken(): Promise<string>
获取本设备的DeviceToken
checkDeviceToken
验证deviceToken
getDeviceStatus
查询设备标记状态
setDeviceStatus
更新设备标记状态
delDeviceStatus
删除设备标记状态
当getDeviceToken接口由于网络不稳定或其他原因无法获取到DeviceToken时，应用需要考虑异常处理方案，避免出现应用依赖DeviceToken的基本功能不可用。例如应用重新调用getDeviceToken接口或采用其他风控因子进行判断。
开发步骤
客户端开发
请确保已打开“应用设备状态检测”开关并申请调试Profile。
```typescript
import { deviceCertificate } from '@kit.DeviceSecurityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
```
1.  deviceToken由Device Security Kit加密生成，每次调用生成Token均不一样，有效期1小时。
```typescript
const TAG = "DeviceCertificateJsTest";
// 请求deviceToken，并处理结果
try {
deviceCertificate.getDeviceToken().then((token) => {
hilog.info(0x0000, TAG, 'Succeeded in executing getDeviceToken');
// 开发者处理deviceToken
}).catch((err: BusinessError) => {
hilog.error(0x0000, TAG, 'getDeviceToken failed!  %{public}d %{public}s', err.code, err.message);
});
} catch(err) {
let error: BusinessError = err as BusinessError;
hilog.error(0x0000, TAG, 'getDeviceToken failed!  %{public}d %{public}s', error.code, error.message);
}
```
服务端开发

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-safetydetect-develop-V14
爬取时间: 2025-04-28 02:02:58
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-sysintegrity-check-V14
爬取时间: 2025-04-28 02:03:11
来源: Huawei Developer
场景介绍
应用通过调用Device Security Kit的checkSysIntegrity接口获取系统完整性检测结果，用于判断设备环境是否安全，比如是否被越狱、被模拟等。
应用可以根据检测结果评估如何进行业务操作。
约束与限制
业务流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170445.01478083924510736913601358797938:50001231000000:2800:74AEDD487B1230395D6B8B5812B67C45EC4E3A907B97A8FA712659F477F12E1E.png)
流程说明：
1.开发者应用获取nonce。
在调用checkSysIntegrity接口时，您必须传入一个随机生成的nonce值。在检测结果中会包含这个nonce值，您可以通过校验这个nonce值来确定返回结果能够对应您的请求，并且没有被重放攻击。
2.开发者应用调用checkSysIntegrity接口，发起系统完整性检测请求。
Device Security Kit收到请求后，首先采集系统完整性检测数据，然后将检测数据与nonce一起发送到Device Security服务器做检测，最后通过checkSysIntegrity接口的返回值将检测结果传递给开发者应用。
3.当开发者应用发起业务请求时，在您的应用服务器中验证系统完整性检测结果。
当系统完整性检测结果为false时，您可以根据自身功能对安全的要求决定是否提醒用户。
接口说明
以下是系统完整性检测相关接口，包括ArkTS API，更多接口及使用方法请参见API参考。
| 接口名 | 描述 |
| --- | --- |
| checkSysIntegrity(req: SysIntegrityRequest): Promise<SysIntegrityResponse>; | 检测系统完整性 |
接口名
描述
checkSysIntegrity(req: SysIntegrityRequest): Promise<SysIntegrityResponse>;
检测系统完整性
开发步骤
请确保已打开“安全检测服务”开关并申请Profile。
1.
```typescript
import { safetyDetect } from '@kit.DeviceSecurityKit';
import { BusinessError } from '@ohos.base';
import { hilog } from '@kit.PerformanceAnalysisKit';
```
2.
```typescript
const TAG = "SafetyDetectJsTest";
// 请求系统完整性检测，并处理结果
let req : safetyDetect.SysIntegrityRequest = {
nonce : 'imEe1PCRcjGkBCAhOCh6ImADztOZ8ygxlWRs' // 从服务器生成的随机的nonce值
};
try {
hilog.info(0x0000, TAG, 'CheckSysIntegrity begin.');
const data: safetyDetect.SysIntegrityResponse = await safetyDetect.checkSysIntegrity(req);
hilog.info(0x0000, TAG, 'Succeeded in checkSysIntegrity: %{public}s', data.result);
} catch (err) {
let e: BusinessError = err as BusinessError;
hilog.error(0x0000, TAG, 'CheckSysIntegrity failed: %{public}d %{public}s', e.code, e.message);
}
```
3.  系统完整性检测结果是一个格式为JSON WEB Signature（JWS）的字符串。包括三个部分： 这三个部分使用Base64URL编码后通过“.”进行连接。其中Signature为通过Header中指定的算法对Header与Payload拼接的字符串签名生成的字符串。 示例 更多JWS的相关知识请参见JSON Web Signature。 JWS的Header字段如下： "alg"：签名算法名称，ES256表示使用ECDSA进行签名。 "x5c"：Device Security服务器对JWS签名的证书链，包含3级证书。其中，x5c[0]为给JWS签名的证书，x5c[1]为华为设备二级CA，x5c[2]为华为设备ROOT CA。 JWS的Payload字段如下： nonce：调用checkSysIntegrity接口时传入的nonce字符串。 timestamp：服务器生成的时间戳。 hapBundleName：您应用的包名。 hapCertificateSha256：您应用的签名证书SHA256摘要。 basicIntegrity：系统完整性检测的结果，true表示检测结果完整，false表示存在风险。 appId：您应用的appid。 detail：可选字段，当basicIntegrity结果为false时，该字段将提供存在风险的原因，App开发者可以根据不同风险做出不同的决策，详情如下： 验证检测结果的步骤如下： 我们提供了系统完整性检测结果签名验证的java示例代码，仅供应用服务器参考。
```json
eyAgICAiYW**.**.*Jxse
eyAgICAiYW**.**.*JodHxx
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-urlthreat-check-V14
爬取时间: 2025-04-28 02:03:25
来源: Huawei Developer
场景介绍
应用通过调用Device Security Kit的checkUrlThreat接口检测URL是否为恶意的，并且根据检测结果来提示或拦截该URL。
典型场景：用户访问网址时，判断用户访问的URL是否为恶意网址，对于恶意网址，提示或拦截用户的访问风险。
约束与限制
业务流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170445.82231907603524462691527968839410:50001231000000:2800:602D524AB31AF0D2B0F443543D6F9B3089060C218BF5450D945833EA63936C47.png)
流程说明：
1.  Device Security kit将请求发送到华为服务器检测URL风险，并将检测结果返回给您的应用（NORMAL、PHISHING、MALWARE、OTHERS）。
接口说明
以下是URL检测相关接口，包括ArkTS API，更多接口及使用方法请参见API参考。
| 接口名 | 描述 |
| --- | --- |
| checkUrlThreat(req: UrlCheckRequest): Promise<UrlCheckResponse> | 检测URL风险 |
接口名
描述
checkUrlThreat(req: UrlCheckRequest): Promise<UrlCheckResponse>
检测URL风险
开发步骤
请确保已打开“安全检测服务”开关并申请Profile。
1.
```typescript
import { safetyDetect } from '@kit.DeviceSecurityKit';
import { BusinessError} from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
```
2.
```typescript
const TAG = "SafetyDetectJsTest";
// 请求URL检测，并处理结果
let req : safetyDetect.UrlCheckRequest = {
urls : ['https://test1.com']
};
try {
hilog.info(0x0000, TAG, 'CheckUrlThreat begin.');
const data: safetyDetect.UrlCheckResponse = await safetyDetect.checkUrlThreat(req);
hilog.info(0x0000, TAG, 'Succeeded in checkUrlThreat: %{public}s %{public}d', data.results[0].url, data.results[0].threat);
} catch (err) {
let e: BusinessError = err as BusinessError;
hilog.error(0x0000, TAG, 'CheckUrlThreat failed: %{public}d %{public}s', e.code, e.message);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-taas-dev-V14
爬取时间: 2025-04-28 02:03:39
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-taas-securecamera-V14
爬取时间: 2025-04-28 02:03:52
来源: Huawei Developer
场景介绍
在安全摄像头场景中，通过创建证明密钥、打开证明会话的方式，对安全摄像头捕捉到的图像数据进行签名，确保图像数据的真实性和完整性。
约束与限制
目前支持的机型如下：
HUAWEI Mate 60 Pro、HUAWEI Mate 60 Pro+、HUAWEI Mate 60 RS
HUAWEI Mate 70 Pro、HUAWEI Mate 70 Pro+、HUAWEI Mate 70 RS
业务流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170445.87172802903094229567091290061299:50001231000000:2800:30F29E5BAE5A8B665B2141DC3B6C22AF83AF827D8B39FD68FBA39EBCBD2C94E6.jpg)
接口说明
接口及使用方法请参见API参考。
| 接口名 | 描述 |
| --- | --- |
| createAttestKey(options: AttestOptions): Promise<void> | 创建证明密钥。 |
| initializeAttestContext(userData: string, options: AttestOptions): Promise<AttestReturnResult> | 初始化证明会话。 |
| finalizeAttestContext(options: AttestOptions): Promise<void> | 结束证明会话。 |
| destroyAttestKey(): Promise<void> | 销毁证明密钥。 |
接口名
描述
createAttestKey(options: AttestOptions): Promise<void>
创建证明密钥。
initializeAttestContext(userData: string, options: AttestOptions): Promise<AttestReturnResult>
初始化证明会话。
finalizeAttestContext(options: AttestOptions): Promise<void>
结束证明会话。
destroyAttestKey(): Promise<void>
销毁证明密钥。
开发步骤
1.
```typescript
import { camera } from '@kit.CameraKit';
import { trustedAppService } from '@kit.DeviceSecurityKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.  开发者需要完成：
3.
```typescript
// 创建证明密钥的参数
const createProperties: Array<trustedAppService.AttestParam> = [
{
tag: trustedAppService.AttestTag.ATTEST_TAG_ALGORITHM,
value: trustedAppService.AttestKeyAlg.ATTEST_ALG_ECC
},
{
tag: trustedAppService.AttestTag.ATTEST_TAG_KEY_SIZE,
value: trustedAppService.AttestKeySize.ATTEST_ECC_KEY_SIZE_256
}
];
const createOptions: trustedAppService.AttestOptions = {
properties: createProperties
};
// 初始化证明会话的参数
const userData = "trusted_app_service_demo"; // 示例值，实际值请自行生成，长度在16到128字符之间
const deviceId = 7483679320805398131; // 示例值，实际值请通过Camera Kit获取
const initProperties: Array<trustedAppService.AttestParam> = [
{
tag: trustedAppService.AttestTag.ATTEST_TAG_DEVICE_TYPE,
value: trustedAppService.AttestType.ATTEST_TYPE_CAMERA
},
{
tag: trustedAppService.AttestTag.ATTEST_TAG_DEVICE_ID,
value: BigInt(deviceId)
}
];
const initOptions: trustedAppService.AttestOptions = {
properties: initProperties
};
// 创建证明密钥并打开证明会话
let certChainList: Array<string>;
try {
await trustedAppService.createAttestKey(createOptions);
const result = await trustedAppService.initializeAttestContext(userData, initOptions);
certChainList = result.certChains;
} catch (err) {
const error = err as BusinessError;
console.error(`Failed to initialize attest context, message:${error.message}, code:${error.code}`);
}
```
4.  如果需要销毁证明密钥，请在结束证明会话后，调用destroyAttestKey接口。由于安全摄像头和安全地理位置共用同一个证明密钥，销毁前需要保证安全地理位置功能未在使用该证明密钥。
```typescript
// 结束证明会话的参数
const finalProperties: Array<trustedAppService.AttestParam> = [
{
tag: trustedAppService.AttestTag.ATTEST_TAG_DEVICE_TYPE,
value: trustedAppService.AttestType.ATTEST_TYPE_CAMERA
}
];
const finalOptions: trustedAppService.AttestOptions = {
properties: finalProperties,
};
// 结束证明会话
try {
await trustedAppService.finalizeAttestContext(finalOptions);
} catch (err) {
const error = err as BusinessError;
console.error(`Failed to finalize attest context, message:${error.message}, code:${error.code}`);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-taas-securelocation-V14
爬取时间: 2025-04-28 02:04:06
来源: Huawei Developer
场景介绍
在安全地理位置场景中，通过创建证明密钥、打开证明会话的方式，对从GPS硬件或网络位置获取到的地理位置信息进行签名，确保地理位置信息的真实性和完整性。
约束与限制
目前支持的机型如下：
HUAWEI Mate 60、HUAWEI Mate 60 Pro、HUAWEI Mate 60 Pro+、HUAWEI Mate 60 RS
HUAWEI Mate 70、HUAWEI Mate 70 Pro、HUAWEI Mate 70 Pro+、HUAWEI Mate 70 RS
HUAWEI MatePad Pro 13.2 2025
业务流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170446.19601353020959459827036609523423:50001231000000:2800:3253DCDD6CD84B440155D21866FE5BC285B234A811231E04B9EFA8894601B199.jpg)
应用获取安全地理位置的优先级策略有两种，分别是精度优先和速度优先。如果选择精度优先策略，可信应用服务会优先返回GPS的结果，GPS获取超时后返回网络地理位置；而如果选择速度优先策略，可信应用服务会返回从二者中最先获取到的结果。
接口说明
接口及使用方法请参见API参考。
| 接口名 | 描述 |
| --- | --- |
| createAttestKey(options: AttestOptions): Promise<void> | 创建证明密钥。 |
| initializeAttestContext(userData: string, options: AttestOptions): Promise<AttestReturnResult> | 初始化证明会话。 |
| finalizeAttestContext(options: AttestOptions): Promise<void> | 结束证明会话。 |
| destroyAttestKey(): Promise<void> | 销毁证明密钥。 |
| getCurrentSecureLocation(timeout: number, priority: LocatingPriority): Promise<SecureLocation> | 获取安全地理位置信息。 |
接口名
描述
createAttestKey(options: AttestOptions): Promise<void>
创建证明密钥。
initializeAttestContext(userData: string, options: AttestOptions): Promise<AttestReturnResult>
初始化证明会话。
finalizeAttestContext(options: AttestOptions): Promise<void>
结束证明会话。
destroyAttestKey(): Promise<void>
销毁证明密钥。
getCurrentSecureLocation(timeout: number, priority: LocatingPriority): Promise<SecureLocation>
获取安全地理位置信息。
开发步骤
1.
```typescript
import { trustedAppService } from '@kit.DeviceSecurityKit';
import { BusinessError } from '@kit.BasicServicesKit';
```
2.  使用安全地理位置服务时，需要保证系统时间与网络时间同步。
```typescript
// 创建证明密钥的参数
const createProperties: Array<trustedAppService.AttestParam> = [
{
tag: trustedAppService.AttestTag.ATTEST_TAG_ALGORITHM,
value: trustedAppService.AttestKeyAlg.ATTEST_ALG_ECC
},
{
tag: trustedAppService.AttestTag.ATTEST_TAG_KEY_SIZE,
value: trustedAppService.AttestKeySize.ATTEST_ECC_KEY_SIZE_256
}
];
const createOptions: trustedAppService.AttestOptions = {
properties: createProperties
};
// 初始化证明会话的参数
const userData = "trusted_app_service_demo" // 示例值，实际值请自行生成，长度在16到128字符之间
const initProperties: Array<trustedAppService.AttestParam> = [
{
tag: trustedAppService.AttestTag.ATTEST_TAG_DEVICE_TYPE,
value: trustedAppService.AttestType.ATTEST_TYPE_LOCATION
},
{
tag: trustedAppService.AttestTag.ATTEST_TAG_DEVICE_ID,
value: BigInt(0) // 此参数在安全地理位置场景下不生效
}
];
const initOptions: trustedAppService.AttestOptions = {
properties: initProperties
};
// 创建证明密钥并打开证明会话
let certChainList: Array<string>;
try {
await trustedAppService.createAttestKey(createOptions);
const result = await trustedAppService.initializeAttestContext(userData, initOptions);
certChainList = result.certChains;
} catch (err) {
const error = err as BusinessError;
console.error(`Failed to initialize attest context, message:${error.message}, code:${error.code}`);
}
```
3.
```typescript
const timeout = 5000; // 获取安全地理位置的超时时间，单位为毫秒
const priority = trustedAppService.LocatingPriority.PRIORITY_ACCURACY; // 采用精度优先策略
let secureLocation: trustedAppService.SecureLocation;
// 获取当前安全地理位置信息
try {
secureLocation = await trustedAppService.getCurrentSecureLocation(timeout, priority);
} catch (err) {
const error = err as BusinessError;
console.error(`Failed to get current secure location, message:${error.message}, code:${error.code}`);
}
```
4.  如果需要销毁证明密钥，请在结束证明会话后，调用destroyAttestKey接口。
```typescript
// 结束证明会话的参数
const finalProperties: Array<trustedAppService.AttestParam> = [
{
tag: trustedAppService.AttestTag.ATTEST_TAG_DEVICE_TYPE,
value: trustedAppService.AttestType.ATTEST_TYPE_LOCATION
}
];
const finalOptions: trustedAppService.AttestOptions = {
properties: finalProperties,
};
// 结束证明会话
try {
await trustedAppService.finalizeAttestContext(finalOptions);
} catch (err) {
const error = err as BusinessError;
console.error(`Failed to finalize attest context, message:${error.message}, code:${error.code}`);
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-taas-verify-V14
爬取时间: 2025-04-28 02:04:20
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-taas-verifycertchain-V14
爬取时间: 2025-04-28 02:04:33
来源: Huawei Developer
为防止第三方伪造数据，端侧和云侧在对数据进行验签之前，必须先验证匿名证书链的正确性。端侧对匿名证书链的校验处理接口，请参考“证书链校验器对象的创建和校验”。云侧对匿名证书链的校验处理接口，请参考“设备真实性证明”的服务器端开发章节。
初始化证明会话时返回的匿名证书链包含三级证书，验证步骤如下：
1.  请勿在应用服务器中使用子CA证书对密钥证明证书链进行校验，子CA证书可能会因为有效期结束、证书被吊销等发生变化。
2.
3.  “应用AppID”指的是HarmonyOS应用的ID，包含bundleName和签名证书公钥的哈希值。 获取应用AppID方法请参考“bundleManager 模块”。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-taas-verifysignature-V14
爬取时间: 2025-04-28 02:04:48
来源: Huawei Developer
如果需要在端侧校验安全图像数据或安全地理位置数据签名的有效性，可以使用Crypto Architecture Kit，使用方法请参考开发指南中“使用ECDSA密钥对签名验签”章节。
推荐应用开发者在服务器端完成安全图像或安全地理位置的签名验证，请参考“Device Certificate Kit 设备真实性证明服务器端开发”。
获取签名数据
安全摄像头图像数据
安全图像数据的结构如下所示：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170447.32226372721427446960275969391842:50001231000000:2800:9DC2D9CDBC815F14F3D5CD309C7298A152C1F45974FD71D6EF230C1B7DD994F8.png)
其中用户数据和图像数据为被签名的原始数据，图像数据长度固定为460800字节，签名数据是Base64编码的签名结果，使用者需要解析出这些数据用来验证安全图像数据签名。参考代码如下：
```typescript
import { util } from '@kit.ArkTS';
// 获取被签名的原始数据
const secureImageBuffer = new ArrayBuffer(461844); // 实际使用时请替换为Camera Kit获取到的安全图像buffer
const view = new DataView(secureImageBuffer);
const imageBufferLength = 460800; // 安全图像buffer长度固定为460800
const userDataLength = view.getUint32(0, true); // 获取用户数据长度
const originData = secureImageBuffer.slice(4, 4 + userDataLength + imageBufferLength);
// 获取签名结果
const maxSignatureBufferLength = 512;
const signatureBuffer = secureImageBuffer.slice(4 + userDataLength + imageBufferLength,
4 + userDataLength + imageBufferLength + maxSignatureBufferLength);
const signatureString = String.fromCharCode(...new Uint8Array(signatureBuffer).filter(code => code !== 0));
const base64Helper = new util.Base64Helper();
const signatureData = base64Helper.decodeSync(signatureString);
```
安全地理位置数据
安全地理位置数据的结构请参考SecureLocation。
对安全地理位置数据验签时，需要将返回的结构体中的数据拼接成字符串形式，格式要求如下：
签名数据是Base64编码后的签名结果。获取签名和签名原始数据的参考代码（不含异常处理逻辑，由开发者根据业务场景实现）如下：
```typescript
import { trustedAppService } from '@kit.DeviceSecurityKit';
import { util } from '@kit.ArkTS';
// 以下均为示例值，仅用于展示如何获取原始签名数据和签名结果
const location: trustedAppService.Location = {
latitude: 40.053903635898685,
longitude: 116.17356591910897,
altitude: 0,
accuracy: 11.160304069519043,
timestamp: 1722151680187
};
const userData = "trusted_app_service_userdata";
const secureLocation: trustedAppService.SecureLocation = {
originalLocation: location,
userData: userData,
signature: "MEQCIEAcJHgaU8aAoMqD1wgoxiXR5I4jmwVG6ncgSKkW4uBHAiBnfv96T+gt1ef83kNZ+U0gBLsq9byuBLP1RBx30hByuQ=="
};
// 获取原始数据
const originString = secureLocation.originalLocation.latitude.toFixed(15) + ',' +
secureLocation.originalLocation.longitude.toFixed(15) + ',' +
secureLocation.originalLocation.altitude.toFixed(15) + ',' +
secureLocation.originalLocation.accuracy.toFixed(6) + ',' +
secureLocation.originalLocation.timestamp + ',' + secureLocation.userData.toString();
const textEncoder = new util.TextEncoder();
const originData = textEncoder.encodeInto(originString);
// 获取签名结果
const base64Helper = new util.Base64Helper();
const signatureData = base64Helper.decodeSync(secureLocation.signature.toString());
```
验证签名
在安全摄像头场景和安全地理位置场景中，由于使用的是相同的证明密钥，因此签名验证的流程是一致的。结合“安全摄像头场景”和“安全地理位置场景”中获取到的原始数据和签名结果，验证签名的参考代码（不含异常处理逻辑，由开发者根据业务场景实现）如下：
1.
```typescript
import { cert } from '@kit.DeviceCertificateKit';
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { util } from '@kit.ArkTS';
import { trustedAppService } from '@kit.DeviceSecurityKit';
// 以安全摄像头场景为例，忽略异常情况处理
const userData = "trusted_app_service_demo";
const deviceId = 7483679320805398131;
const initProperties: Array<trustedAppService.AttestParam> = [
{
tag: trustedAppService.AttestTag.ATTEST_TAG_DEVICE_TYPE,
value: trustedAppService.AttestType.ATTEST_TYPE_CAMERA
},
{
tag: trustedAppService.AttestTag.ATTEST_TAG_DEVICE_ID,
value: BigInt(deviceId)
}
];
const initOptions: trustedAppService.AttestOptions = {
properties: initProperties
};
const returnResult = await trustedAppService.initializeAttestContext(userData, initOptions);
// 解析匿名证书链数据，获取三级证书
const certChain = returnResult.certChains;
const certList = certChain[0].split('-----BEGIN CERTIFICATE-----');
const thirdCert = '-----BEGIN CERTIFICATE-----' + certList[1];
// 获取公钥
const textEncoder = new util.TextEncoder();
const encodingBlob: cert.EncodingBlob = {
data: textEncoder.encodeInto(thirdCert),
encodingFormat: cert.EncodingFormat.FORMAT_PEM
};
const x509Cert = await cert.createX509Cert(encodingBlob);
const asyKeyGenerator = cryptoFramework.createAsyKeyGenerator('ECC256');
const keyPair = asyKeyGenerator.convertKeySync(x509Cert.getPublicKey().getEncoded(), null);
const pubKey = keyPair.pubKey; // 证书中的公钥需要转换成cryptoFramework能够接收的格式
```
2.
```typescript
const verifier = cryptoFramework.createVerify('ECC256|SHA256');
verifier.initSync(pubKey);
```
3.
```typescript
const originData = ...; // 请使用获取到的安全图像原始数据
const signatureData = ...; // 请使用获取到的签名结果
const inputData: cryptoFramework.DataBlob = {
data: new Uint8Array(originData)
};
const signature: cryptoFramework.DataBlob = {
data: new Uint8Array(signatureData)
};
// 验证签名结果
const result = verifier.verifySync(inputData, signature);
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-securityaudit-V14
爬取时间: 2025-04-28 02:05:01
来源: Huawei Developer
场景介绍
提供统一的安全审计数据订阅与取消订阅接口，应用可以获取设备上的安全审计数据（如下表），以支撑审计相关业务。
| 审计事件ID | 说明 |
| --- | --- |
| 0x027000000 | 剪切板复制粘贴事件 |
| 0x810800800 | 账号登录登出事件 |
| 0x007000000 | 窗口截屏录屏投屏事件 |
| 0x00F000000 | USB插拔事件 |
| 0x02E000000 | 打印机事件 |
| 0x01C000007 | 文件事件 |
| 0x01C000008 | 进程创建退出事件 |
| 0x01C000009 | 网络事件 |
| 0x01C00000A | KIA文件拦截事件 |
| 0x02D000000 | 相机事件 |
| 0x010000000 | 应用事件 |
| 0x014000000 | 鼠标事件 |
| 0x014000001 | 键盘事件 |
| 0x011000000 | edm事件 |
| 0x012003000 | 证书操作事件 |
| 0x01C00000B | KIA文件新增事件 |
| 0x01C00000C | KIA文件变种事件 |
审计事件ID
说明
0x027000000
剪切板复制粘贴事件
0x810800800
账号登录登出事件
0x007000000
窗口截屏录屏投屏事件
0x00F000000
USB插拔事件
0x02E000000
打印机事件
0x01C000007
文件事件
0x01C000008
进程创建退出事件
0x01C000009
网络事件
0x01C00000A
KIA文件拦截事件
0x02D000000
相机事件
0x010000000
应用事件
0x014000000
鼠标事件
0x014000001
键盘事件
0x011000000
edm事件
0x012003000
证书操作事件
0x01C00000B
KIA文件新增事件
0x01C00000C
KIA文件变种事件
约束与限制
当前能力仅支持2in1设备。
业务流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170447.20993034992052630945281402038124:50001231000000:2800:C26BF1D8EE2E79FC2C576C2E73F2939D3FAA9E0993401C47F623B0D3CD049590.png)
流程说明：
接口说明
以下是安全审计数据订阅与取消订阅接口，更多接口及使用方法请参见API参考。
| 接口名 | 描述 |
| --- | --- |
| unction on(type: 'auditEventOccur', auditEventInfo: AuditEventInfo, callback: Callback<AuditEvent>): void; | 订阅安全审计数据 |
| function off(type: 'auditEventOccur', auditEventInfo: AuditEventInfo, callback?: Callback<AuditEvent>): void; | 取消订阅安全审计数据 |
接口名
描述
unction on(type: 'auditEventOccur', auditEventInfo: AuditEventInfo, callback: Callback<AuditEvent>): void;
订阅安全审计数据
function off(type: 'auditEventOccur', auditEventInfo: AuditEventInfo, callback?: Callback<AuditEvent>): void;
取消订阅安全审计数据
开发步骤
1.
```typescript
import { securityAudit } from '@kit.DeviceSecurityKit';
import { BusinessError} from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
```
2.
```typescript
const TAG = "SecurityAuditJsTest";
const callback = (event: securityAudit.AuditEvent) => {
hilog.info(0x0000, TAG, '%{public}s', 'Security_SecurityAudit_JsApi_Func eventId= ' + event.eventId);
hilog.info(0x0000, TAG, '%{public}s', 'Security_SecurityAudit_JsApi_Func version= ' + event.version);
hilog.info(0x0000, TAG, '%{public}s', 'Security_SecurityAudit_JsApi_Func content= ' + event.content);
hilog.info(0x0000, TAG, '%{public}s', 'Security_SecurityAudit_JsApi_Func timestamp= ' + event.timestamp);
hilog.info(0x0000, TAG, '%{public}s', 'Security_SecurityAudit_JsApi_Func userId= ' + event.userId);
hilog.info(0x0000, TAG, '%{public}s', 'Security_SecurityAudit_JsApi_Func deviceId= ' + event.deviceId);
};
let auditEventInfo: securityAudit.AuditEventInfo = {
eventId: 0x810800800
};
try {
hilog.info(0x0000, TAG, 'on begin.');
securityAudit.on('auditEventOccur', auditEventInfo, callback);
hilog.info(0x0000, TAG, 'Succeeded in on.');
} catch (err) {
let e: BusinessError = err as BusinessError;
hilog.error(0x0000, TAG, 'on failed: %{public}d %{public}s', e.code, e.message);
}
```
3.

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-brid-develop-V14
爬取时间: 2025-04-28 02:05:15
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-fraudriskdetection-V14
爬取时间: 2025-04-28 02:05:29
来源: Huawei Developer
场景介绍
金融支付类应用在用户转账、支付前，通过调用Device Security kit的detectFraudRisk接口，检测用户是否受到欺诈威胁。该接口返回一个风险分，以及涉诈行为的线索，例如，接收到涉诈引导信息、设备有被操控风险等，应用可以根据风险分及线索，进行有效提示或拦截。
约束与限制
每个应用在每个设备上每天最多可以调用10次接口。
业务流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170447.57728054042345662061024199165275:50001231000000:2800:0A0312C9EFAC14289E909BC311EA6F620FD821B67ED47BAECC2AEA53ED836FE5.png)
流程说明：
1.  在调用detectFraudRisk接口时，开发者必须传入一个随机生成的nonce值。在检测结果中会包含这个nonce值，您可以通过校验这个nonce值来确定返回结果能够对应您的请求，并且没有被重放攻击。
2.  Device Security Kit收到请求后，首先采集当前设备涉诈风险线索数据，然后将线索数据与nonce一起发送到Device Security服务器做检测，最后通过detectFraudRisk接口的返回值将检测结果传递给开发者应用。
接口说明
以下是涉诈剧本检测相关接口，包括ArkTS API，更多接口及使用方法请参见API参考。
| 接口名 | 描述 |
| --- | --- |
| detectFraudRisk(params: FraudDetectionRequest): Promise<string> | 涉诈剧本检测。 |
接口名
描述
detectFraudRisk(params:FraudDetectionRequest): Promise<string>
涉诈剧本检测。
开发步骤
1.
```typescript
import { businessRiskIntelligentDetection } from '@kit.DeviceSecurityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
```
2.
```typescript
const TAG = "BusinessRiskIntelligentDetectionJsTest";
let params = {
nonce: xxxxxxx, // 将nonce的值修改为服务器生成的随机值.
algorithm: businessRiskIntelligentDetection.SigningAlgorithm.ES256
} as businessRiskIntelligentDetection.FraudDetectionRequest;
try {
hilog.info(0x0000, TAG, 'Detect fraud risk begin.');
businessRiskIntelligentDetection.detectFraudRisk(params).then((result: string) => {
hilog.info(0x0000, TAG, 'Detect fraud risk success: %{public}s', result);
}).catch((error: Error) => {
let e: BusinessError = error as BusinessError;
hilog.error(0x0000, TAG, 'Detect fraud risk failed: %{public}d %{public}s', e.code, e.message);
});
} catch (error) {
let e: BusinessError = error as BusinessError;
hilog.error(0x0000, TAG, 'Detect fraud risk failed: %{public}d %{public}s', e.code, e.message);
}
```
3.  涉诈剧本检测接口响应结果格式为JSON WEB签名（JWS）。验证检测结果的步骤如下
```json
{
"timestampMs": 9xxxxxxxxx,
"nonce": "Rxxxxxxxxx",
"appId": "xxxxxxxxx",
"version": 1,
"riskScore": 90,
"tags": [
"phishing",
"malware",
"interdiction",
"control"
]
}
```
```json
{
"timestampMs": 9xxxxxxxxx,
"nonce": "Rxxxxxxxxx",
"appId": "xxxxxxxxx",
"version": 1,
"riskScore": 90,
"tags": [
"phishing",
"malware",
"interdiction",
"control"
]
}
```
```json
{
"timestampMs": 9xxxxxxxxx,
"nonce": "Rxxxxxxxxx",
"appId": "xxxxxxxxx",
"version": 1,
"riskScore": 90,
"tags": [
"phishing",
"malware",
"interdiction",
"control"
]
}
```
具体字段解释请参见说明。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-securitymode-V14
爬取时间: 2025-04-28 02:05:42
来源: Huawei Developer
场景介绍
Device Security Kit提供了系统安全模式的查询能力。通过调用Device Security Kit的接口，可以判断设备当前的安全模式（包含普通模式、坚盾守护模式），应用可根据设备当前的安全模式提供差异化的服务。
-  坚盾守护模式下，操作系统禁止应用申请获取匿名内存可执行权限（ohos.permission.kernel.ALLOW_WRITEABLE_CODE_MEMORY）。 应用应当根据系统安全模式进行自主适配，停用即时编译（JIT，Just-in-time compilation）功能或切换为解释执行。
开发步骤
1.
2.
3.
若应用使用到ArkWeb组件，需进一步参考说明，进行Web特性的兼容性评估。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/devicesecurity-personal-data-V14
爬取时间: 2025-04-28 02:05:56
来源: Huawei Developer
最后修改时间：2024/05/20
此文档针对华为作为最终用户数据处理者，开发者作为最终用户数据控制者的数据处理进行说明，包括：
华为处理的个人数据清单
| 个人数据清单 | 使用目的 | 存留期 |
| --- | --- | --- |
| 设备标识符 | 设备标识符，基于该标识符记录设备的应用使用状态信息。 | DeviceVerify服务器的数据存储时间不超过2年，超期信息自动删除。 |
| 应用使用信息 | 记录用户在该设备使用应用的状态（如是否领取优惠券）。 |
个人数据清单
使用目的
存留期
设备标识符
设备标识符，基于该标识符记录设备的应用使用状态信息。
DeviceVerify服务器的数据存储时间不超过2年，超期信息自动删除。
应用使用信息
记录用户在该设备使用应用的状态（如是否领取优惠券）。
指导开发者如何帮助最终用户实现对数据的控制
-

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/data-guard-kit-guide-V14
爬取时间: 2025-04-28 02:06:09
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dataguard-introduction-V14
爬取时间: 2025-04-28 02:06:23
来源: Huawei Developer
Enterprise Data Guard Kit（企业数据保护服务）为企业安全管控类MDM应用提供统一企业关键信息资产（KIA）文件的识别和外发管控能力，是HarmonyOS系统上原生的敏感数据安全管控能力，支撑企业构建完整的数据防泄漏解决方案，实现企业数据资产可知、可控、可追溯。
场景介绍
约束与限制
| 文件路径  | 说明  |
| --- | --- |
| /data/service/el2/  | 文件路径与物理路径对应的关系及不同加密分区的差异，请参考应用沙箱路径和真实物理路径的对应关系和获取和修改加密分区。  |
| /data/app/el1/bundle/public/  |
| /mnt/hmdfs/  |
| /data/app/el1/  |
| /data/app/el2/  |
| /data/app/el3/  |
| /data/app/el4/  |
| /data/app/el5/  |
文件路径
说明
/data/service/el2/
文件路径与物理路径对应的关系及不同加密分区的差异，请参考应用沙箱路径和真实物理路径的对应关系和获取和修改加密分区。
/data/app/el1/bundle/public/
/mnt/hmdfs/
/data/app/el1/
/data/app/el2/
/data/app/el3/
/data/app/el4/
/data/app/el5/
| 文件路径  | 说明  |
| --- | --- |
| /data/service/el2/<userId>/hmdfs/account/files/  | 对应用户的个人数据目录。  |
文件路径
说明
/data/service/el2/<userId>/hmdfs/account/files/
对应用户的个人数据目录。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dataguard-preparations-V14
爬取时间: 2025-04-28 02:06:36
来源: Huawei Developer
环境准备
申请资质
在开发应用前，需要在AppGallery Connect中配置项目和应用信息。包括：
申明接口所需权限
在申请权限前，请保证符合权限使用的基本原则。然后在工程Module对应的module.json5配置文件中"requestPermissions"标签下声明要使用的接口所需的权限。例如：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dataguard-start-task-V14
爬取时间: 2025-04-28 02:06:50
来源: Huawei Developer
场景介绍
Enterprise Data Guard Kit为应用提供对公共路径文件扫描的能力，获取目标路径下的文件列表。
接口说明
详细接口说明可参考接口文档。
| 接口名 | 描述 |
| --- | --- |
| startFileScanTask(type: CommonDirScanType, callback: ScanFileCallback, batchNum?: number): void | 通过Callback的方式，扫描公共目录并返回结果。 |
| startFileScanTask(path: string, callback: ScanFileCallback, batchNum?: number): void | 通过Callback的方式，扫描指定目录并返回结果。 |
接口名
描述
startFileScanTask(type:CommonDirScanType, callback:ScanFileCallback, batchNum?: number): void
通过Callback的方式，扫描公共目录并返回结果。
startFileScanTask(path: string, callback:ScanFileCallback, batchNum?: number): void
通过Callback的方式，扫描指定目录并返回结果。
开发步骤
```typescript
function startFileScanTaskUnderCommonDir() {
let guard: fileGuard.FileGuard = new fileGuard.FileGuard();
let onReceiveFileList: (files: string[]) => void = (files: Array<string>) => {
files.forEach((value: string, index: number) => {
console.info(`Succeeded in getting file: ${value}.`);
})
};
let onCompleteScanTask: (count: number) => void = (count: number) => {
console.info(`Succeeded in getting count: ${count}.`);
};
let scanFileCallback: fileGuard.ScanFileCallback = {
onReceiveFileList: onReceiveFileList,
onTaskCompleted: onCompleteScanTask
};
guard.startFileScanTask(fileGuard.CommonDirScanType.MEDIA_ONLY, scanFileCallback);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dataguard-openfile-V14
爬取时间: 2025-04-28 02:07:03
来源: Huawei Developer
场景介绍
普通应用无法直接访问公共路径下的文件，Enterprise Data Guard Kit为应用提供相关接口以获取文件描述符（fd）。
接口说明
详细接口说明可参考接口文档。
| 接口名 | 描述 |
| --- | --- |
| openFile(path: string, callback: AsyncCallback<number>): void | 使用Callback方式获取指定目录文件fd。 |
| openFile(path: string): Promise<number> | 使用Promise方式获取指定目录文件fd。 |
接口名
描述
openFile(path: string, callback: AsyncCallback<number>): void
使用Callback方式获取指定目录文件fd。
openFile(path: string): Promise<number>
使用Promise方式获取指定目录文件fd。
开发步骤
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
function openFileCallback() {
let guard: fileGuard.FileGuard = new fileGuard.FileGuard();
let path: string = '/data/service/el2/test/test.txt';
guard.openFile(path, (err: BusinessError, fd: number) => {
if (err) {
console.error(`Failed to open file. Code: ${err.code}, message: ${err.message}.`);
return;
}
console.info(`Succeeded in opening file. path: ${path}, fd: ${fd}.`);
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dataguard-set-tags-V14
爬取时间: 2025-04-28 02:07:17
来源: Huawei Developer
场景介绍
Enterprise Data Guard Kit为应用提供对文件设置属性标签的能力，方便应用对管控文件进行标识、分类。
接口说明
详细接口说明可参考接口文档。
| 接口名 | 描述 |
| --- | --- |
| setFileTag(path: string, level: SecurityLevel, tag: string, callback: AsyncCallback<void>): void | 使用Callback方式设置文件属性标签。 |
| setFileTag(path: string, level: SecurityLevel, tag: string): Promise<void> | 使用Promise方式设置文件属性标签。 |
接口名
描述
setFileTag(path: string, level:SecurityLevel, tag: string, callback: AsyncCallback<void>): void
使用Callback方式设置文件属性标签。
setFileTag(path: string, level:SecurityLevel, tag: string): Promise<void>
使用Promise方式设置文件属性标签。
开发步骤
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
function setFileTagCallback() {
let guard: fileGuard.FileGuard = new fileGuard.FileGuard();
let path: string = '/data/service/el2/test/test.txt';
let tag: string = 'test';
guard.setFileTag(path, fileGuard.SecurityLevel.EXTERNAL, tag, (err: BusinessError) => {
if (err) {
console.error(`Failed to set file tag. Code: ${err.code}, message: ${err.message}.`);
return;
}
console.info(`Succeeded in setting file tag.`);
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dataguard-query-tags-V14
爬取时间: 2025-04-28 02:07:30
来源: Huawei Developer
场景介绍
Enterprise Data Guard Kit为应用提供获取文件属性标签的能力，内核管控模块根据管控策略和文件属性标签对文件实行管控。
接口说明
详细接口说明可参考接口文档。
| 接口名 | 描述 |
| --- | --- |
| queryFileTag(path: string, callback: AsyncCallback<FileTagInfo>): void | 使用Callback方式获取文件属性标签。 |
| queryFileTag(path: string): Promise<FileTagInfo> | 使用Promise方式获取文件属性标签。 |
接口名
描述
queryFileTag(path: string, callback: AsyncCallback<FileTagInfo>): void
使用Callback方式获取文件属性标签。
queryFileTag(path: string): Promise<FileTagInfo>
使用Promise方式获取文件属性标签。
开发步骤
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
function queryFileTagCallback() {
let guard: fileGuard.FileGuard = new fileGuard.FileGuard();
let path: string = '/data/service/el2/test/test.txt';
guard.queryFileTag(path, (err: BusinessError, data: fileGuard.FileTagInfo) => {
if (err) {
console.error(`Failed to query file tag. Code: ${err.code}, message: ${err.message}.`);
return;
}
console.info(`Succeeded in querying file tag.`);
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dataguard-get-file-url-V14
爬取时间: 2025-04-28 02:07:44
来源: Huawei Developer
场景介绍
Enterprise Data Guard Kit为应用提供获取文件URI的能力。
接口说明
详细接口说明可参考接口文档。
| 接口名 | 描述 |
| --- | --- |
| getFileUri(path: string, callback: AsyncCallback<FilePathInfo>): void | 使用Callback方式获取文件URI。 |
| getFileUri(path: string): Promise<FilePathInfo> | 使用Promise方式获取文件URI。 |
接口名
描述
getFileUri(path: string, callback: AsyncCallback<FilePathInfo>): void
使用Callback方式获取文件URI。
getFileUri(path: string): Promise<FilePathInfo>
使用Promise方式获取文件URI。
开发步骤
```typescript
import { fileGuard } from '@kit.EnterpriseDataGuardKit';
```
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
function getFileUriCallback() {
let guard: fileGuard.FileGuard = new fileGuard.FileGuard();
let path: string = '/data/service/el2/100/hmdfs/account/files/test/test.txt';
guard.getFileUri(path, (err: BusinessError, data: fileGuard.FilePathInfo) => {
if (err) {
console.error(`Failed to get file uri. Code: ${err.code}, message: ${err.message}.`);
} else {
console.info(`Succeeded in getting file uri.`);
}
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dataguard-delete-file-V14
爬取时间: 2025-04-28 02:07:58
来源: Huawei Developer
场景介绍
Enterprise Data Guard Kit为应用提供对公共路径文件删除的能力。
接口说明
详细接口说明可参考接口文档。
| 接口名 | 描述 |
| --- | --- |
| deleteFile(path: string, callback: AsyncCallback<void>): void | 使用Callback方式删除扫描范围内的文件。 |
| deleteFile(path: string): Promise<void> | 使用Promise方式删除扫描范围内的文件。 |
接口名
描述
deleteFile(path: string, callback: AsyncCallback<void>): void
使用Callback方式删除扫描范围内的文件。
deleteFile(path: string): Promise<void>
使用Promise方式删除扫描范围内的文件。
开发步骤
```typescript
import { fileGuard } from '@kit.EnterpriseDataGuardKit';
```
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
function deleteFileCallback() {
let guard: fileGuard.FileGuard = new fileGuard.FileGuard();
let path: string = '/data/service/el2/100/hmdfs/account/files/Docs/Documents/test.txt';
guard.deleteFile(path, (err: BusinessError) => {
if (err) {
console.error(`Failed to delete file. Code: ${err.code}, message: ${err.message}.`);
} else {
console.info(`Succeeded in deleting file.`);
}
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dataguard-update-policy-V14
爬取时间: 2025-04-28 02:08:11
来源: Huawei Developer
场景介绍
Enterprise Data Guard Kit为应用提供下发管控策略的能力，相关策略会被分发到内核各管控模块中执行。
接口说明
详细接口说明可参考接口文档。
| 接口名 | 描述 |
| --- | --- |
| updatePolicy(policy: string, callback: AsyncCallback<void>): void | 使用Callback方式更新安全管控策略。 |
| updatePolicy(policy: string): Promise<void> | 使用Promise方式更新安全管控策略。 |
接口名
描述
updatePolicy(policy: string, callback: AsyncCallback<void>): void
使用Callback方式更新安全管控策略。
updatePolicy(policy: string): Promise<void>
使用Promise方式更新安全管控策略。
开发步骤
```typescript
import { fileGuard } from '@kit.EnterpriseDataGuardKit';
```
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
function updatePolicyCallback() {
let guard: fileGuard.FileGuard = new fileGuard.FileGuard();
let policy: string = '{' +
'"net_intercept_toggle":0,' +
'"boundary":["10.10.0.0-10.10.255.255.255","0.0.0.0-1.1.1.1"],' +
'"netsegment_trustlist":["10.10.0.0-10.10.255.255.255"],' +
'"netsegment_blocklist":["0.0.0.0-1.1.1.1"],' +
'"default_policy":0' +
'}';
guard.updatePolicy(policy, (err: BusinessError) => {
if (err) {
console.error(`Failed to update policy. Code: ${err.code}, message: ${err.message}.`);
} else {
console.info(`Succeeded in updating policy.`);
}
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dataguard-kia-file-list-V14
爬取时间: 2025-04-28 02:08:25
来源: Huawei Developer
场景介绍
Enterprise Data Guard Kit为应用提供设置KIA文件列表的能力，内核管控模块根据管控策略对KIA文件列表中的文件实行管控。
接口说明
详细接口说明可参考接口文档。
| 接口名 | 描述 |
| --- | --- |
| setKiaFilelist(filelist: string, callback: AsyncCallback<void>): void | 使用Callback方式设置KIA文件列表。 |
| setKiaFilelist(filelist: string): Promise<void> | 使用Promise方式设置KIA文件列表。 |
接口名
描述
setKiaFilelist(filelist: string, callback: AsyncCallback<void>): void
使用Callback方式设置KIA文件列表。
setKiaFilelist(filelist: string): Promise<void>
使用Promise方式设置KIA文件列表。
开发步骤
```typescript
import { fileGuard } from '@kit.EnterpriseDataGuardKit';
```
```typescript
import { BusinessError } from '@kit.BasicServicesKit';
function setKiaFilelistCallback() {
let guard: fileGuard.FileGuard = new fileGuard.FileGuard();
let fileListStr: string = '{' +
'"kia_filelist":' +
'["' +
'/data/service/el2/100/hmdfs/account/files/Documents/Desktop/aaa.docx",' +
'"/data/service/el2/100/hmdfs/account/files/Documents/Desktop/bbb.docx"' +
']' +
'}';
guard.setKiaFilelist(fileListStr, (err: BusinessError) => {
if (err) {
console.error(`Failed to set the list of KIA file. Code: ${err.code}, message: ${err.message}.`);
} else {
console.info(`Succeeded in setting the list of KIA file.`);
}
});
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dataguard-faq-V14
爬取时间: 2025-04-28 02:08:39
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/dataguard-faq-1-V14
爬取时间: 2025-04-28 02:08:52
来源: Huawei Developer
问题现象
ide编译不通过，报错：install failed due to grant request permissions failed
解决措施

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/online-authentication-kit-guide-V14
爬取时间: 2025-04-28 02:09:05
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/onlineauthentication-introduction-V14
爬取时间: 2025-04-28 02:09:19
来源: Huawei Developer
Online Authentication Kit（在线认证服务）遵循FIDO（Fast Identity Online）、IIFAA（互联网可信认证联盟）和SOTER标准免密认证规范，提供免密身份认证的移动端能力。用户应用接入FIDO、IIFAA或SOTER服务器后，可以使用相应的移动端能力，用生物特征（指纹/3D人脸）代替密码，实现免密登录、免密支付等业务场景。
FIDO
FIDO是一种国际主流的免密认证标准，几乎所有的设备厂商都支持FIDO免密认证协议，同时众多生态APP厂商也广泛使用依赖该能力，包括中国工商银行，中国银行，农业银行，交通银行等各大行，以及众多证券，金融APP。
请参考sample_-FIDOclientdemo（见网站链接免责声明）。
IIFAA
IIFAA互联网可信认证联盟，是2015年由中国信通院、蚂蚁集团、阿里巴巴、华为、中兴、三星联合发起的可信认证生态联盟。联盟致力于推动可信认证技术发展及行业应用，引领行业制定技术规范。其中本地免密技术规范，用于支持免密登陆，免密支付等业务场景。
请参考sample-IFAAclientdemo（见网站链接免责声明）。
SOTER
SOTER提供一套生物认证平台和标准，使得业务可以采用设备上的传感器（如人脸传感器/指纹传感器）进行安全、高效的免密登录、免密支付等操作，当前已广泛应用于微信小程序/公众号、指纹支付等业务场景。
请参考samplecode_-SOTERclientdemo（见网站链接免责声明）。
场景介绍
支持IIFAA和FIDO免密身份认证的如下场景：
注：IFAA在本文中指HarmonyOS系统免密认证模块，IIFAA在本文中指联盟及相关技术规范。
功能使用限制
Online Authentication Kit提供的FIDO、IFAA、SOTER能力有以下使用限制：

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/onlineauthentication-preparation-V14
爬取时间: 2025-04-28 02:09:33
来源: Huawei Developer
FIDO开发准备
开发者的业务需要接入符合FIDO UAF标准的协议，并部署符合FIDO UAF标准协议的FIDO服务端。
FIDO网址:https://fidoalliance.org/（见网站链接免责声明）
IFAA开发准备
开发者的业务接入IIFAA联盟，并接入IIFAA中心服务器。
IIFAA网址：https://www.iifaa.org.cn/technical#paper（见网站链接免责声明）
SOTER开发准备
开发者的业务接入SOTER服务器。
SOTER github：https://github.com/Tencent/soter（见网站链接免责声明）

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/onlineauthentication-fido-V14
爬取时间: 2025-04-28 02:09:47
来源: Huawei Developer
场景介绍
基本概念
在开发FIDO免密身份认证功能前，开发者应了解以下基本概念：
-  FIDO（Fast Identity Online）是一套身份认证框架协议，它由FIDO联盟推出并持续维护。FIDO规范定义了一套在线身份认证的技术架构。
-  UAF（Universal Authentication Framework）意为通用身份认证框架，目的是通过生物识别（如指纹识别）和加密技术方式，为用户提供无密码的身份认证体验。
相关权限
约束与限制
业务流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170449.56156241044218423903129727397899:50001231000000:2800:518E41824A8A317D0A51FD2547F10031AFAFE2794E8A6EE146E196C2EEEA6429.png)
接口说明
业务进行FIDO免密身份认证功能的开通、使用和关闭。
| 接口名 | 描述 |
| --- | --- |
| discover(context: common.Context): Promise<DiscoveryData> | 发现设备的认证能力，返回当前设备软件支持的认证器数据 |
| checkPolicy(context: common.Context, uafRequest: UAFMessage): Promise<void> | 检测用户策略的开启状态 |
| processUAFOperation(context: common.Context, uafRequest: UAFMessage, channelBindings?: ChannelBinding): Promise<UAFMessage> | 用户UAF操作接口，处理UAF协议消息 |
| notifyUAFResult(context: common.Context, uafResponse: UAFMessage): Promise<void> | 开通结果通知接口 |
接口名
描述
discover(context: common.Context): Promise<DiscoveryData>
发现设备的认证能力，返回当前设备软件支持的认证器数据
checkPolicy(context: common.Context, uafRequest:UAFMessage): Promise<void>
检测用户策略的开启状态
processUAFOperation(context: common.Context, uafRequest: UAFMessage, channelBindings?: ChannelBinding): Promise<UAFMessage>
用户UAF操作接口，处理UAF协议消息
notifyUAFResult(context: common.Context, uafResponse:UAFMessage): Promise<void>
开通结果通知接口
开发步骤
```typescript
import { fido } from '@kit.OnlineAuthenticationKit';
import { BusinessError } from '@ohos.base';
```
```typescript
// 使用this.uiContext需要获取页面UIAbility的Context，一个页面获取一次即可
// 方法：uiContext:common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
try {
// 调用discover方法初始化认证器信息
let discoverData = await fido.discover(this.uiContext);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call discover. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
```
```typescript
// 使用this.uiContext需要获取页面UIAbility的Context，一个页面获取一次即可
// 方法：uiContext:common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
try {
// 调用discover方法初始化认证器信息
let discoverData = await fido.discover(this.uiContext);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call discover. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
```
```typescript
// uafMessage为FIDO服务端获取的策略检查报文
let uafAuthMessage: fido.UAFMessage = {
/*
策略检查报文格式: [{"header":{"upv":{"major":1,"minor":0},"op":"Auth","appID":"","serverData":"test server data"},"challenge":"test challenge","policy":{"accepted":[[{"aaid":["001B#1001"],"keyIDs":["test keyIDs"],"authenticationAlgorithms":[1]}]]}}]
*/
uafProtocolMessage: uafMessage, // 从服务端获取的检查策略报文
additionalData: "" // 附加信息（可选）
};
let isRegistered: boolean = true;
try {
// 检查是否已经开启FIDO认证
await fido.checkPolicy(this.uiContext, uafAuthMessage);
} catch (error) {
isRegistered = false;
const err: BusinessError = error as BusinessError;
console.error(`Failed to call checkPolicy. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断状态，进行相应处理
}
if (isRegistered) {
console.info("has registered, no need to register again.");
// 已注册，业务根据需要执行后续流程
}
```
```typescript
// regMessage为从FIDO服务端获取的注册报文
let uafRegMessage: fido.UAFMessage = {
/*
注册报文格式: [{"header":{"upv":{"major":1,"minor":0},"op":"Reg","appID":"","serverData":"test server data"},"challenge":"test challenge","username":"test user name","policy":{"accepted":[[{"aaid":["001B#1001"],"attachmentHint":1,"authenticationAlgorithms":[1],"authenticatorVersion":1}]]}}]
*/
uafProtocolMessage: regMessage, // 从服务端获取的注册报文
additionalData: "" // 附加信息（可选）
};
// 传连接通道参数（可选）
let channelBinding: fido.ChannelBinding = {};
try {
// 调用processUAFOperation接口进行FIDO注册
let messageResp = await fido.processUAFOperation(this.uiContext, uafRegMessage, channelBinding);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call processUAFOperation. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
```
```typescript
// notifyMessage为从FIDO服务端获取的注册结果报文
let notifyMessage:string = "";
let notifyUafMessage: fido.UAFMessage = {
/*
响应报文格式: {"authenticatorsSucceeded":[{"description":"Attention completed successfully.","aaid":"001B#1001","keyID":"test keyID"}]}
*/
uafProtocolMessage: notifyMessage, // 从服务端获取的注册结果报文
additionalData: "" // 附加信息（可选）
};
```
```typescript
try {
// 调用notifyUAFResult进行注册结果通知
fido.notifyUAFResult(this.uiContext, notifyUafMessage).then(notify => {
console.info("Succeeded in doing notifyUAFResult.");
})
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call notifyUAFResult. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
```
```typescript
// 获取当前界面的context
try {
// 调用discover方法初始化认证器信息
let discoverData = await fido.discover(this.uiContext);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call discover. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
```
```typescript
// 获取当前界面的context
try {
// 调用discover方法初始化认证器信息
let discoverData = await fido.discover(this.uiContext);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call discover. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
```
```typescript
// uafMessage为从FIDO服务器获取的策略检查报文
let uafAuthMessage: fido.UAFMessage = {
/*
策略检查报文格式: [{"header":{"upv":{"major":1,"minor":0},"op":"Auth","appID":"","serverData":"test server data"},"challenge":"test challenge","policy":{"accepted":[[{"aaid":["001B#1001"],"keyIDs":["test keyIDs"],"authenticationAlgorithms":[1]}]]}}]
*/
uafProtocolMessage: uafMessage, // 从服务端获取的检查策略报文
additionalData: "" // 附加信息（可选）
};
let isRegistered: boolean = true;
try {
// 检查是否已经开启FIDO认证
await fido.checkPolicy(this.uiContext, uafAuthMessage);
} catch (error) {
isRegistered = false;
const err: BusinessError = error as BusinessError;
console.error(`Failed to call checkPolicy. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断状态，进行相应处理
}
if (isRegistered) {
console.info("has registered, no need to register again.");
// 已注册，业务根据需要执行后续流程
}
```
```typescript
// regMessage为从FIDO服务器获取的认证报文
let uafRegMessage: fido.UAFMessage = {
/*
认证报文格式: [{"header":{"upv":{"major":1,"minor":0},"op":"Auth","appID":"","serverData":"test server data"},"challenge":"test challenge","policy":{"accepted":[[{"aaid":["001B#1001"],"keyIDs":["test keyIDs"],"authenticationAlgorithms":[1]}]]}}]
*/
uafProtocolMessage: regMessage, // 从服务端获取的认证报文
additionalData: "" // 附加信息（可选）
};
// 传连接通道参数（可选）
let channelBinding: fido.ChannelBinding = {};
try {
// 调用processUAFOperation接口进行FIDO认证
let messageResp = await fido.processUAFOperation(this.uiContext, uafRegMessage, channelBinding);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call processUAFOperation. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
//发送认证响应报文至FIDO服务端进行验证并返回认证结果
```
```typescript
try {
// 调用discover方法初始化认证器信息
let discoverData = await fido.discover(this.uiContext);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call discover. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
```
```typescript
try {
// 调用discover方法初始化认证器信息
let discoverData = await fido.discover(this.uiContext);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call discover. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
```
```typescript
// deregMessage为从FIDO服务器获取的注销报文
let uafRegMessage: fido.UAFMessage = {
/*
注销报文格式:  [{"header":{"upv":{"major":1,"minor":0},"op":"Dereg","appID":""},"authenticators":[{"aaid":"001B#1001","keyID":"test keyID"}]}]
*/
uafProtocolMessage: deregMessage, // 从服务端获取的注销报文
additionalData: "" // 附加信息（可选）
};
// 传连接通道参数（可选）
let channelBinding: fido.ChannelBinding = {};
try {
// 调用processUAFOperation接口进行FIDO注销
let messageResp = await fido.processUAFOperation(this.uiContext, uafRegMessage, channelBinding);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call processUAFOperation. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
//发送认证响应报文至FIDO服务端进行验证并返回认证结果
```
```typescript
// 使用this.uiContext需要获取页面UIAbility的Context，一个页面获取一次即可
// 方法：uiContext:common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
try {
// 调用discover方法初始化认证器信息
let discoverData = await fido.discover(this.uiContext);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call discover. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
```
```typescript
// uafMessage为FIDO服务端获取的策略检查报文
let uafAuthMessage: fido.UAFMessage = {
/*
策略检查报文格式: [{"header":{"upv":{"major":1,"minor":0},"op":"Auth","appID":"","serverData":"test server data"},"challenge":"test challenge","policy":{"accepted":[[{"aaid":["001B#1001"],"keyIDs":["test keyIDs"],"authenticationAlgorithms":[1]}]]}}]
*/
uafProtocolMessage: uafMessage, // 从服务端获取的检查策略报文
additionalData: "" // 附加信息（可选）
};
let isRegistered: boolean = true;
try {
// 检查是否已经开启FIDO认证
await fido.checkPolicy(this.uiContext, uafAuthMessage);
} catch (error) {
isRegistered = false;
const err: BusinessError = error as BusinessError;
console.error(`Failed to call checkPolicy. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断状态，进行相应处理
}
if (isRegistered) {
console.info("has registered, no need to register again.");
// 已注册，业务根据需要执行后续流程
}
```
```typescript
// regMessage为从FIDO服务端获取的注册报文
let uafRegMessage: fido.UAFMessage = {
/*
注册报文格式: [{"header":{"upv":{"major":1,"minor":0},"op":"Reg","appID":"","serverData":"test server data"},"challenge":"test challenge","username":"test user name","policy":{"accepted":[[{"aaid":["001B#1001"],"attachmentHint":1,"authenticationAlgorithms":[1],"authenticatorVersion":1}]]}}]
*/
uafProtocolMessage: regMessage, // 从服务端获取的注册报文
additionalData: "" // 附加信息（可选）
};
// 传连接通道参数（可选）
let channelBinding: fido.ChannelBinding = {};
try {
// 调用processUAFOperation接口进行FIDO注册
let messageResp = await fido.processUAFOperation(this.uiContext, uafRegMessage, channelBinding);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call processUAFOperation. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
```
```typescript
// notifyMessage为从FIDO服务端获取的注册结果报文
let notifyMessage:string = "";
let notifyUafMessage: fido.UAFMessage = {
/*
响应报文格式: {"authenticatorsSucceeded":[{"description":"Attention completed successfully.","aaid":"001B#1001","keyID":"test keyID"}]}
*/
uafProtocolMessage: notifyMessage, // 从服务端获取的注册结果报文
additionalData: "" // 附加信息（可选）
};
```
```typescript
try {
// 调用notifyUAFResult进行注册结果通知
fido.notifyUAFResult(this.uiContext, notifyUafMessage).then(notify => {
console.info("Succeeded in doing notifyUAFResult.");
})
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call notifyUAFResult. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
```
```typescript
// 获取当前界面的context
try {
// 调用discover方法初始化认证器信息
let discoverData = await fido.discover(this.uiContext);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call discover. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
```
```typescript
// uafMessage为从FIDO服务器获取的策略检查报文
let uafAuthMessage: fido.UAFMessage = {
/*
策略检查报文格式: [{"header":{"upv":{"major":1,"minor":0},"op":"Auth","appID":"","serverData":"test server data"},"challenge":"test challenge","policy":{"accepted":[[{"aaid":["001B#1001"],"keyIDs":["test keyIDs"],"authenticationAlgorithms":[1]}]]}}]
*/
uafProtocolMessage: uafMessage, // 从服务端获取的检查策略报文
additionalData: "" // 附加信息（可选）
};
let isRegistered: boolean = true;
try {
// 检查是否已经开启FIDO认证
await fido.checkPolicy(this.uiContext, uafAuthMessage);
} catch (error) {
isRegistered = false;
const err: BusinessError = error as BusinessError;
console.error(`Failed to call checkPolicy. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断状态，进行相应处理
}
if (isRegistered) {
console.info("has registered, no need to register again.");
// 已注册，业务根据需要执行后续流程
}
```
```typescript
// regMessage为从FIDO服务器获取的认证报文
let uafRegMessage: fido.UAFMessage = {
/*
认证报文格式: [{"header":{"upv":{"major":1,"minor":0},"op":"Auth","appID":"","serverData":"test server data"},"challenge":"test challenge","policy":{"accepted":[[{"aaid":["001B#1001"],"keyIDs":["test keyIDs"],"authenticationAlgorithms":[1]}]]}}]
*/
uafProtocolMessage: regMessage, // 从服务端获取的认证报文
additionalData: "" // 附加信息（可选）
};
// 传连接通道参数（可选）
let channelBinding: fido.ChannelBinding = {};
try {
// 调用processUAFOperation接口进行FIDO认证
let messageResp = await fido.processUAFOperation(this.uiContext, uafRegMessage, channelBinding);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call processUAFOperation. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
//发送认证响应报文至FIDO服务端进行验证并返回认证结果
```
```typescript
try {
// 调用discover方法初始化认证器信息
let discoverData = await fido.discover(this.uiContext);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call discover. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
```
```typescript
// deregMessage为从FIDO服务器获取的注销报文
let uafRegMessage: fido.UAFMessage = {
/*
注销报文格式:  [{"header":{"upv":{"major":1,"minor":0},"op":"Dereg","appID":""},"authenticators":[{"aaid":"001B#1001","keyID":"test keyID"}]}]
*/
uafProtocolMessage: deregMessage, // 从服务端获取的注销报文
additionalData: "" // 附加信息（可选）
};
// 传连接通道参数（可选）
let channelBinding: fido.ChannelBinding = {};
try {
// 调用processUAFOperation接口进行FIDO注销
let messageResp = await fido.processUAFOperation(this.uiContext, uafRegMessage, channelBinding);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call processUAFOperation. Code is ${err.code}, message is ${err.message}`);
// 业务根据错误码判断异常类型，进行相应处理
}
//发送认证响应报文至FIDO服务端进行验证并返回认证结果
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/onlineauthentication-ifaa-V14
爬取时间: 2025-04-28 02:10:00
来源: Huawei Developer
场景介绍
基本概念
互联网金融身份认证联盟IIFAA（IIFAA），全称为International Internet Finance Authentication Alliance，是一个生物识别框架，它由IIFAA联盟推出并持续维护。
相关权限
约束与限制
业务流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170450.85577220707360076405825608045570:50001231000000:2800:A908B2E80720F35CA92FCFABF6246BC1DB9B1DAA7235B0B82F63C5F20E3B853B.png)
接口说明
| 接口名 | 描述 |
| --- | --- |
| register(registerData: Uint8Array): Promise<Uint8Array> | 开通指定用户的指定生物信息类型（指纹/3D人脸）的IFAA免密身份认证能力。 |
| auth(authToken: Uint8Array, authData: Uint8Array): Promise<Uint8Array> | 使用指定用户的生物信息类型进行IFAA免密身份认证。 |
| deregisterSync(deregisterData: Uint8Array): void | 注销指定用户指定生物信息类型（指纹/3D人脸）的IFAA免密身份认证能力。 |
| getAnonymousIdSync(userToken: Uint8Array): Uint8Array | 获取移动端设备标识ID。 |
接口名
描述
register(registerData: Uint8Array): Promise<Uint8Array>
开通指定用户的指定生物信息类型（指纹/3D人脸）的IFAA免密身份认证能力。
auth(authToken: Uint8Array, authData: Uint8Array): Promise<Uint8Array>
使用指定用户的生物信息类型进行IFAA免密身份认证。
deregisterSync(deregisterData: Uint8Array): void
注销指定用户指定生物信息类型（指纹/3D人脸）的IFAA免密身份认证能力。
getAnonymousIdSync(userToken: Uint8Array): Uint8Array
获取移动端设备标识ID。
开发步骤
1.
```typescript
import { ifaa } from '@kit.OnlineAuthenticationKit';
import { BusinessError } from '@kit.BasicServicesKit';
// 开发者根据IIFAA协议构造TLV入参，转换为Uint8Array, 再使用ifaa.getAnonymousIdSync接口。此处new Uint8Array([0])需要替换为开发者定义的用户标识。
let arg = new Uint8Array([0]);
let getAnonIdResult: Uint8Array = ifaa.getAnonymousIdSync(arg);
// 开发者需要使用getAnonIdResult服务端获取签名后的开通数据
// 开发者将开通数据（IIFAA协议的TLV格式）转换为Uint8Array, 再使用ifaa.register接口。此处new Uint8Array([0])需要替换为有效数据。
let TLV_Register_fp = new Uint8Array([0]);
let registerPromise: Promise<Uint8Array> = ifaa.register(TLV_Register_fp);
registerPromise.then(registerResult => {
console.info("Succeeded in doing register.");
// 开通成功，开发者获取ifaa.register结果并处理。
}).catch((err: BusinessError) =>{
console.error(`Failed to call register. Code: ${err.code}, message: ${err.message}`);
// 开通失败，开发者获取ifaa.register错误并处理。
});
```
2.
```typescript
import { ifaa } from '@kit.OnlineAuthenticationKit';
import { userAuth } from '@kit.UserAuthenticationKit';
import { BusinessError } from '@kit.BasicServicesKit';
// 开发者根据IIFAA协议构造TLV入参，转换为Uint8Array, 再使用ifaa.getAnonymousIdSync接口。arg需要替换开发者自定义数据。
let arg = new Uint8Array([0]);
let getAnonIdResult: Uint8Array = ifaa.getAnonymousIdSync(arg);
// 开发者需要使用getAnonIdResult在服务端获取签名后的认证数据
// 获取此次免密支付的challenge
let ifaaChallenge: Uint8Array = ifaa.preAuthSync();
let authParam: userAuth.AuthParam = {
challenge: ifaaChallenge,
authType: [userAuth.UserAuthType.FINGERPRINT],
authTrustLevel: userAuth.AuthTrustLevel.ATL4,
};
// 使用preAuthResult请求身份认证
let userAuthInstance = userAuth.getUserAuthInstance(authParam,  {title: ' '});
userAuthInstance.on('result', {
async onResult (result) {
let authToken = result.token;
try {
// 生物特征认证成功后，调用IFAA认证
console.info("IFAA auth start");
// 开发者将认证数据（IIFAA协议的TLV格式）转换为Uint8Array, 再使用ifaa.authSync接口。此处new Uint8Array([0])需要替换为有效数据。
let TLV_Auth_fp = new Uint8Array([0]);
// 开发者根据业务需求选择同步/异步接口
let authResult: Uint8Array = ifaa.authSync(authToken, TLV_Auth_fp);
console.info("authSyn authResult" + authResult);
// 开发者处理authResult
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`Failed to call auth. Code is ${err.code}, message is ${err.message}`);
}
}
});
userAuthInstance.start();
```
3.
```typescript
import { ifaa } from '@kit.OnlineAuthenticationKit'
// 开发者根据IIFAA协议构造TLV入参，转换为Uint8Array, 再使用ifaa.getAnonymousIdSync接口。此处new Uint8Array([0])需要替换为开发者定义的用户标识。
let arg = new Uint8Array([0]);
let getAnonIdResult: Uint8Array = ifaa.getAnonymousIdSync(arg);
// 开发者需要使用getAnonymousId的结果在服务端获取签名后的注销数据
// 开发者将注销数据（IIFAA协议的TLV格式）转换为Uint8Array, 再使用ifaa.deregisterSync接口。此处new Uint8Array([0])需要替换为有效数据。
let TLV_deregister_fp = new Uint8Array([0]);
ifaa.deregisterSync(TLV_deregister_fp);
```
常见问题
现象描述：开通IFAA免密身份认证失败。
可能原因：移动端设备没有联网。
处理步骤：移动端设备连接WIFI或热点，再次尝试。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/onlineauthentication-soter-V14
爬取时间: 2025-04-28 02:10:14
来源: Huawei Developer
场景介绍
用户可以利用生物特征来代替传统的密码验证，实现免密身份认证。
基本概念
SOTER旨在提供一套生物认证平台和标准，使得业务可以采用设备上的传感器（如人脸传感器/指纹传感器）进行安全、高效的免密登录、免密支付等操作，当前已广泛应用于微信小程序/公众号、指纹支付等业务场景。
相关权限
约束与限制
业务流程
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170451.80371722667799315311531291537438:50001231000000:2800:AF5968459D75B5C7DE2D2949307C09016C27D2840257056A9AEF17878E7CF784.png)
接口说明
| 接口名 | 描述 |
| --- | --- |
| generateAppSecureKey(keyType: KeyType): Promise<Uint8Array> | 生成应用密钥 |
| generateAuthKey(keyAlias: string, keyType: KeyType): Promise<SignedResult> | 生成认证密钥 |
| generateChallengeSync(keyAlias: string): Uint8Array | 生成Challenge |
| signWithAuthKeySync(keyAlias: string, authToken: Uint8Array, info: string): SignedResult | 使用认证密钥对业务数据签名 |
| deleteAuthKey(keyAlias: string): Promise<void> | 删除认证密钥 |
接口名
描述
generateAppSecureKey(keyType:KeyType): Promise<Uint8Array>
生成应用密钥
generateAuthKey(keyAlias: string, keyType:KeyType): Promise<SignedResult>
生成认证密钥
generateChallengeSync(keyAlias: string): Uint8Array
生成Challenge
signWithAuthKeySync(keyAlias: string, authToken: Uint8Array, info: string):SignedResult
使用认证密钥对业务数据签名
deleteAuthKey(keyAlias: string): Promise<void>
删除认证密钥
开发步骤
1.
2.
3.
```typescript
let keyType: soter.KeyType = soter.KeyType.ECC_P256; // 加密类型，只支持ECC_P256
let keyAlias: string = 'keyAlias'; // 开发者自定义密钥别名
let info: string = 'Message to be signed.'; //info需要服务端下发，服务端下发完成签名后需要重新上传到服务端
// 获取此次免密支付的challenge
let soterChallenge: Uint8Array = soter.generateChallengeSync(keyAlias);
let authParam: userAuth.AuthParam = {
challenge: soterChallenge,
authType: [userAuth.UserAuthType.FINGERPRINT],
authTrustLevel: userAuth.AuthTrustLevel.ATL4,
};
// 使用preAuthResult请求身份认证
let userAuthInstance = userAuth.getUserAuthInstance(authParam,  {title: ' '});
// 未获取到authToken则会返回错误码1。
userAuthInstance.on('result', {
async onResult (result) {
let authToken = result.token;
try {
// 生物特征认证成功后，调用soter认证
console.info('soter auth start');
// 使用soter.signWithAuthKeySync接口为待认证数据签名。开发者根据业务需求选择同步/异步接口。
let authResult: soter.SignedResult = soter.signWithAuthKeySync(keyAlias, authToken, info);
console.info('Succeeded in doing authSyn authResult');
// 开发者处理authResult
} catch (err) {
console.error(`Failed to signWithAuthKeySync. Code: ${err.code}, message: ${err.message}`);
}
}
});
userAuthInstance.start();
```
4.
```typescript
// 删除AuthKey
soter.deleteAuthKey(keyAlias);
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/onlineauthentication-website-disclaimer-V14
爬取时间: 2025-04-28 02:10:28
来源: Huawei Developer
本网站可能含有其他独立第三方网站的链接，该类链接仅为方便本网站的访问者而提供。华为不对链接网站的内容、服务、信息等提供任何明示和暗示的保证，此类链接也不视为华为对链接网站的推荐或授权。您需自行独立判断您与链接网站的互动行为，华为对此不承担任何责任。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-kit-V14
爬取时间: 2025-04-28 02:10:41
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-overview-V14
爬取时间: 2025-04-28 02:10:55
来源: Huawei Developer
Universal Keystore Kit（密钥管理服务，下述简称为HUKS）向业务/应用提供各类密钥的统一安全操作能力，包括密钥管理（密钥生成/销毁、密钥导入、密钥证明、密钥协商、密钥派生）及密钥使用（加密/解密、签名/验签、访问控制）等功能。
HUKS管理的密钥可以由业务/应用导入或调用HUKS的接口生成。同时，HUKS提供了密钥访问控制能力，确保存储在HUKS中的密钥被合法正确的访问。
整体架构
如图所示，HUKS模块可以分为如下三大部分：
-  SDK：提供密钥管理的接口供开发者调用，开发者可以根据实际业务，选择ArkTS或C API。
-  HUKS服务层：实现密钥会话管理及存储管理。
-  HUKS核心层：承载HUKS的核心功能，包括密钥的密码学运算、明文密钥的加解密、密钥访问控制等。 对于具备安全环境（如TEE、安全芯片）的系统/设备，HUKS核心层必须运行在安全环境内。由于安全环境依赖硬件支持，在开源仓中仅为模拟实现，需OEM厂商适配。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170452.33820886202440478197782661806467:50001231000000:2800:8B36471278B25156F1D01ED807242837E8B8C2D3D80CACF36AACDDE39FEF1B17.png)
核心功能
HUKS为开发者提供了密钥全生命周期的管理能力，其核心功能按照密钥生命周期划分如下：
密钥生成
| 功能 | 说明 |
| --- | --- |
| 密钥生成 | 随机生成密钥，且在密钥的全生命周期内，其明文仅在安全环境中进行访问操作，不会将明文传递出安全环境。 |
| 密钥导入 | 业务可以将外部生成的密钥导入到HUKS进行管理。 |
密钥使用
| 功能 | 说明 |
| --- | --- |
| 加密/解密 | 使用密钥将数据加密为攻击者无法理解的密文，或使用密钥将数据解密为业务可用的明文。 |
| 签名/验签 | 用于认证消息内容以及消息发送者身份的真实性。 |
| 密钥协商 | 两个或多个实体通过协商，共同建立会话密钥。 |
| 密钥派生 | 从一个现有密钥派生出一个或多个新密钥。 |
| 访问控制 | 确保存储在HUKS中的密钥，不会被越权访问。 |
密钥删除
| 功能 | 说明 |
| --- | --- |
| 密钥删除 | 安全地删除存储在HUKS中的密钥数据。 |
密钥证明
| 功能 | 说明 |
| --- | --- |
| 密钥证明 | 为存储在HUKS中的非对称密钥对中的公钥签发证书，从而证明密钥的合法性（如密钥在安全环境中生成）。 |
与相关Kit的关系
基于用户身份认证的密钥访问控制，依赖于User Authentication Kit（用户身份认证）。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-concepts-V14
爬取时间: 2025-04-28 02:11:08
来源: Huawei Developer
在使用通用密钥库完成应用开发前，开发者需要了解以下相关概念，以下概念将贯穿整个开发过程。
可信执行环境（TEE）
可信执行环境（Trusted Execution Environment），简称TEE，是存在于智能手机、平板，或任意移动设备主处理器中的一个安全区域，确保各种敏感数据在一个可信环境中被存储、处理和受到保护。TEE为授权安全软件，也称为“可信应用”提供一个安全的执行环境，通过实施保护、保密性、完整性和数据访问权限确保端到端的安全。
密钥材料格式
针对不同密码算法的密钥对、公钥、私钥，HUKS为其密钥材料定义了一套格式，该格式在密钥导入、导出等场景使用。
密钥对材料格式
密钥对材料 = 密钥对材料Header + 密钥对材料原文
以RSA密钥为例，应用需要申请一个Uint8Array，按照RSA密钥对材料内存排布格式，将各个变量赋值到对应的位置。
下图为RSA密钥材料内存结构为例，其他算法格式见样例下方表格。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170452.16001813408773913582149842583749:50001231000000:2800:E5320EBF5E67F2116D38B1B988722B54DF69F451B6EDCC786A4B34B0041422EC.png)
其中，密钥算法的值取自枚举类HuksKeyAlg。
-  RSA密钥对材料格式：
-  ECC密钥对材料格式：
-  DSA密钥对材料格式：
-  DH密钥对材料格式：
-  Curve25519密钥对材料格式：
| 密钥算法 | 密钥大小 | 模数n长度Ln | 公钥指数e长度Le | 私钥指数d长度Ld | n | e | d |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 4字节 | 4字节 | 4字节 | 4字节 | 4字节 | Ln字节 | Le字节 | Ld字节 |
| 密钥算法 | 密钥大小 | 坐标x长度Lx | 坐标y长度Ly | 坐标z长度Lz | x | y | z |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 4字节 | 4字节 | 4字节 | 4字节 | 4字节 | Lx字节 | Ly字节 | Lz字节 |
| 密钥算法 | 密钥大小 | 私钥x长度Lx | 公钥y长度Ly | 素数p长度Lp | 素因子q长度Lq | g长度Lg | x | y | p | q | g |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 4字节 | 4字节 | 4字节 | 4字节 | 4字节 | 4字节 | 4字节 | Lx字节 | Ly字节 | Lp字节 | Lq字节 | Lg字节 |
| 密钥算法 | 密钥大小 | 公钥pk长度Lpk | 私钥sk长度Lsk | 保留字段 | pk | sk |
| --- | --- | --- | --- | --- | --- | --- |
| 4字节 | 4字节 | 4字节 | 4字节 | 4字节 | Lpk字节 | Lsk字节 |
| 密钥算法 | 密钥大小 | 公钥pk长度Lpk | 私钥sk长度Lsk | 保留字段 | pk | sk |
| --- | --- | --- | --- | --- | --- | --- |
| 4字节 | 4字节 | 4字节 | 4字节 | 4字节 | Lpk字节 | Lsk字节 |
公钥材料格式
在公钥导出/导入时，密钥材料采用标准的X.509规范的DER格式封装。
如下是一个DER编码的ECC公钥：
私钥材料格式
复用密钥对的材料格式，私钥材料的封装是把密钥对材料Header中的公钥部分的长度字段置0，同时密钥对材料原文部分拼接私钥材料即可。
私钥材料 = 密钥对材料Header + 私钥材料原文
以RSA私钥材料为例：
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170452.65368627499906325938828448695626:50001231000000:2800:79AC3FCE54EBE01BE1042E72220AADEECC6415AE4D60AE0225785693ABE8C25B.png)

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-generation-import-V14
爬取时间: 2025-04-28 02:11:22
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-generation-V14
爬取时间: 2025-04-28 02:11:35
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-generation-overview-V14
爬取时间: 2025-04-28 02:11:49
来源: Huawei Developer
当业务需要使用HUKS生成随机密钥，并由HUKS进行安全保存时，可以调用HUKS的接口生成密钥。
密钥别名中禁止包含个人数据等敏感信息。
-  随机生成：指HUKS在生成密钥时，利用密码学安全的伪随机数，提高密钥的随机性、不可预测性以及不可重现性，确保生成的密钥难以被推测。
-  安全保存：指通过HUKS生成的密钥，除了非对称密钥中的公钥外，密钥的全生命周期（从生成到销毁）均只能由HUKS在安全存储区使用，且生成的密钥文件不能被除HUKS以外的任何业务直接访问。即使是生成密钥的业务，后续也只能通过HUKS提供的接口执行密钥操作，从而获取操作结果。
-  密钥用途：一个密钥只能有一类用途，例如：无法通过同一个密钥进行加解密和签名验签。另外，生成密钥时指定的用途要与使用时的方式一致，否则会导致异常。
支持的算法
以下为密钥生成支持的规格说明。
标准设备规格
| 算法 | 支持的密钥长度 | API级别 |
| --- | --- | --- |
| AES | 128、192、256 | 8+ |
| RSA | 2048、3072、4096 | 8+ |
| HMAC | 8-1024（含），必须是8的倍数 | 8+ |
| ECC | 256、384、521 | 8+ |
| ED25519 | 256 | 8+ |
| X25519 | 256 | 8+ |
| DH | 2048 | 8+ |
| SM2 | 256 | 9+ |
| SM4 | 128 | 9+ |
DH算法采用FFDHE知名安全素数群。
轻量级设备规格
| 算法 | 支持的密钥长度 | API级别 |
| --- | --- | --- |
| AES | 128、192、256 | 8+ |
| DES | 64 | 12+ |
| 3DES | 128、192 | 12+ |
| RSA | 1024-2048（含），必须是8的倍数 | 12+ |
| HMAC | 8-1024（含），必须是8的倍数 | 12+ |
| CMAC | 128 算法仅支持3DES | 12+ |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-generation-dev-V14
爬取时间: 2025-04-28 02:12:02
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-generation-arkts-V14
爬取时间: 2025-04-28 02:12:16
来源: Huawei Developer
以生成DH密钥为例，生成随机密钥。具体的场景介绍及支持的算法规格，请参考密钥生成支持的算法。
密钥别名中禁止包含个人数据等敏感信息。
开发步骤
1.  指定待生成的密钥别名keyAlias。
2.  初始化密钥属性集。通过HuksParam封装密钥属性，搭配Array组成密钥属性集，并赋值给HuksOptions中的properties字段。 密钥属性集中必须包含HuksKeyAlg、HuksKeySize、HuksKeyPurpose属性，即必传TAG，HUKS_TAG_ALGORITHM、HUKS_TAG_PURPOSE、HUKS_TAG_KEY_SIZE。注：一个密钥只能有一类PURPOSE，并且，生成密钥时指定的用途要与使用时的方式一致，否则会导致异常，请参考密钥用途。
3.  调用huks.generateKeyItem，传入密钥别名和密钥属性集，生成密钥。
如果业务再次使用相同别名调用HUKS生成密钥，HUKS将生成新密钥并直接覆盖历史的密钥文件。
```typescript
/* 以下以生成DH密钥为例 */
import { huks } from '@kit.UniversalKeystoreKit';
/* 1.确定密钥别名 */
let keyAlias = 'dh_key';
/* 2.初始化密钥属性集 */
let properties1: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_DH
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_AGREE
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_DH_KEY_SIZE_2048
}
];
let huksOptions: huks.HuksOptions = {
properties: properties1,
inData: new Uint8Array(new Array())
}
/* 3.生成密钥 */
function generateKeyItem(keyAlias: string, huksOptions: huks.HuksOptions) {
return new Promise<void>((resolve, reject) => {
try {
huks.generateKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throw (error as Error);
}
});
}
async function publicGenKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise generateKeyItem`);
try {
await generateKeyItem(keyAlias, huksOptions)
.then((data) => {
console.info(`promise: generateKeyItem success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
console.error(`promise: generateKeyItem failed, ${JSON.stringify(error)}`);
});
} catch (error) {
console.error(`promise: generateKeyItem input arg invalid, ` + JSON.stringify(error));
}
}
async function TestGenKey() {
await publicGenKeyFunc(keyAlias, huksOptions);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-generation-ndk-V14
爬取时间: 2025-04-28 02:12:30
来源: Huawei Developer
以生成ECC密钥为例，生成随机密钥。具体的场景介绍及支持的算法规格，请参考密钥生成支持的算法。
密钥别名中禁止包含个人数据等敏感信息。
在CMake脚本中链接相关动态库
开发步骤
1.  指定待生成的密钥别名keyAlias。
2.  初始化密钥属性集。通过OH_Huks_InitParamSet、OH_Huks_AddParams、OH_Huks_BuildParamSet构造密钥属性集paramSet。 密钥属性集中必须包含OH_Huks_KeyAlg、OH_Huks_KeySize、OH_Huks_KeyPurpose属性。注：一个密钥只能有一类PURPOSE，并且，生成密钥时指定的用途要与使用时的方式一致，否则会导致异常，请参考密钥用途。
3.  调用OH_Huks_GenerateKeyItem，传入密钥别名和密钥属性集，生成密钥。
如果业务再次使用相同别名调用HUKS生成密钥，HUKS将生成新密钥并直接覆盖历史的密钥文件。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-import-V14
爬取时间: 2025-04-28 02:13:24
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-import-overview-V14
爬取时间: 2025-04-28 02:14:17
来源: Huawei Developer
如果业务在HUKS外部生成密钥（比如应用间协商生成、服务器端生成），业务可以将密钥导入到HUKS中由HUKS进行管理。密钥一旦导入到HUKS中，在密钥的生命周期内，其明文仅在安全环境中进行访问操作，不会传递出安全环境，保证任何人都无法获取到密钥的明文。
密钥导入的方式包含明文导入和加密导入两种方式。
明文导入
该方式直接将密钥明文导入HUKS，在导入过程中密钥明文会暴露在非安全环境中，一般适用于轻量级设备或低安业务。
-  推荐使用该方式导入的密钥类型：非对称密钥的公钥
-  不推荐使用该方式导入的密钥类型：对称密钥、非对称密钥对 轻量级设备只支持明文导入，不支持加密导入。
加密导入
该方式支持业务与HUKS建立端到端的加密传输通道，将密钥安全加密导入到HUKS中，确保导入传入过程中密钥不被泄露，适用于高安敏感业务。相较于明文导入，加密导入步骤更多，密钥材料更复杂。
下图为加密导入密钥开发时序图。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170453.26258018060631272856631564880545:50001231000000:2800:E5E684E49EEA9ED806FBA23BB13EB9F0A46D3277BD9A8EBC3DD197248D3AAC8B.png)
根据开发流程，在导入加密密钥过程中，需要依次调用HUKS的能力包括：
导出密钥接口返回的公钥明文材料是按照X.509格式封装，导入加密密钥接口中的密钥材料需满足LengthData-Data的格式封装，形如：[(Lengthpart1Datapart1)……(LengthpartnDatapartn)]。
加密导入密钥材料格式
| 内容 | 长度 |
| --- | --- |
| 业务公钥长度LCaller_Pk | 4字节 |
| 业务公钥Caller_Pk | LCaller_Pk字节 |
| Shared_Key加密参数AAD2长度LAAD2 | 4字节 |
| Shared_Key加密参数AAD2 | LAAD2字节 |
| Shared_Key加密参数Nonce2长度LNonce2 | 4字节 |
| Shared_Key加密参数Nonce2 | LNonce2字节 |
| Shared_Key加密参数TAG2长度LTAG2 | 4字节 |
| Shared_Key加密参数TAG2 | LTAG2字节 |
| Caller_Kek密文长度LCaller_Kek_enc | 4字节 |
| Caller_Kek密文Caller_Kek_enc | LCaller_Kek_enc字节 |
| Caller_Kek加密参数AAD3长度LAAD3 | 4字节 |
| Caller_Kek加密参数AAD3 | LAAD3字节 |
| Caller_Kek加密参数Nonce3长度LNonce3 | 4字节 |
| Caller_Kek加密参数Nonce3 | LNonce3字节 |
| Caller_Kek加密参数TAG3长度LTAG3 | 4字节 |
| Caller_Kek加密参数TAG3 | LTAG3字节 |
| 密钥明文材料长度的长度LTo_Import_Key_size | 4字节 |
| 密钥明文材料长度To_Import_Key_size | LTo_Import_Key_size字节 |
| To_Import_Key密文长度LTo_Import_Key_enc | 4字节 |
| To_Import_Key密文To_Import_Key_enc | LTo_Import_Key_enc字节 |
支持的算法
以下为密钥导入支持的规格说明。
标准设备规格
| 算法 | 支持的密钥长度 | API级别 |
| --- | --- | --- |
| AES | 128、192、256 | 8+ |
| RSA | 2048、3072、4096 | 8+ |
| HMAC | 8-1024（含），必须是8的倍数 | 8+ |
| ECC | 256、384、521 | 8+ |
| ED25519 | 256 | 8+ |
| X25519 | 256 | 8+ |
| DH | 2048 | 8+ |
| SM2 | 256 | 9+ |
| SM4 | 128 | 9+ |
轻量级设备规格
| 算法 | 支持的密钥长度 | API级别 |
| --- | --- | --- |
| AES | 128、192、256 | 12+ |
| DES | 64 | 12+ |
| 3DES | 128、192 | 12+ |
| RSA | 1024-2048（含），必须是8的倍数 | 12+ |
| HMAC | 8-1024（含），必须是8的倍数 | 12+ |
| CMAC | 128 | 12+ |
导入密钥格式
HUKS支持导入密钥类型众多，各种不同类型对应的密钥格式不尽相同。下表归纳了HUKS导入密钥所支持的密钥类型及对应的密钥材料格式。
| 密钥类型 | 算法 | 导入格式 |
| --- | --- | --- |
| 对称密钥 | - | 密钥字节数据 |
| 非对称密钥-密钥对 | - | 密钥对材料格式 |
| 非对称密钥-公钥 | ED25519、X25519 | 参考X25519密钥公钥导入 |
| 非对称密钥-公钥 | RSA、ECC、ECDH、DSA、DH、SM2 | X.509规范的DER格式 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-import-dev-V14
爬取时间: 2025-04-28 02:14:31
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-import-key-in-plaintext-arkts-V14
爬取时间: 2025-04-28 02:14:45
来源: Huawei Developer
分别以导入AES256与RSA2048密钥为例，具体的场景介绍及支持的算法规格，请参考密钥导入的支持的算法。
开发步骤
1.  指定密钥别名keyAlias。 密钥别名的最大长度为128字节。
2.  封装密钥属性集和密钥材料。
3.  调用huks.importKeyItem，传入密钥别名和密钥属性集，即可导入密钥。 HuksParam和HuksOptions的含义参考：HuksParam和HuksOptions
导入AES256密钥
```typescript
/* 以下以导入AES256密钥的Callback操作使用为例 */
import { huks } from '@kit.UniversalKeystoreKit'
/* 密钥材料 */
let plainTextSize32 = new Uint8Array([
0xfb, 0x8b, 0x9f, 0x12, 0xa0, 0x83, 0x19, 0xbe, 0x6a, 0x6f, 0x63, 0x2a, 0x7c, 0x86, 0xba, 0xca,
0x64, 0x0b, 0x88, 0x96, 0xe2, 0xfa, 0x77, 0xbc, 0x71, 0xe3, 0x0f, 0x0f, 0x9e, 0x3c, 0xe5, 0xf9
]);
/* 1.确定密钥别名 */
let keyAlias = 'AES256Alias_sample';
/* 2.封装密钥属性集和密钥材料 */
let properties: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
},
]
let options: huks.HuksOptions = {
properties: properties,
inData: plainTextSize32
};
/* 3.明文导入密钥 */
try {
huks.importKeyItem(keyAlias, options, (error, data) => {
if (error) {
console.error(`callback: importKeyItem failed` + JSON.stringify(error));
} else {
console.info(`callback: importKeyItem success`);
}
});
} catch (error) {
console.error(`callback: importKeyItem input arg invalid` + JSON.stringify(error));
}
```
导入RSA2048密钥对
```typescript
/* 以下以导入RSA2048密钥的Callback操作使用为例 */
import { huks } from '@kit.UniversalKeystoreKit'
let rsa2048KeyPairMaterial = new Uint8Array([
0x01, 0x00, 0x00, 0x00, // 密钥算法(小端表示)huks.HuksKeyAlg.HUKS_ALG_RSA = 1
0x00, 0x08, 0x00, 0x00, // 密钥大小（比特）：2048
0x00, 0x01, 0x00, 0x00, // 模数n长度（字节）：256
0x03, 0x00, 0x00, 0x00, // 公钥指数e长度（字节）：3
0x00, 0x01, 0x00, 0x00, // 私钥指数d长度（字节）：256
// 模数n
0xc5, 0x35, 0x62, 0x48, 0xc4, 0x92, 0x87, 0x73, 0x0d, 0x42, 0x96, 0xfc, 0x7b, 0x11, 0x05, 0x06,
0x0f, 0x8d, 0x66, 0xc1, 0x0e, 0xad, 0x37, 0x44, 0x92, 0x95, 0x2f, 0x6a, 0x55, 0xba, 0xec, 0x1d,
0x54, 0x62, 0x0a, 0x4b, 0xd3, 0xc7, 0x05, 0xe4, 0x07, 0x40, 0xd9, 0xb7, 0xc2, 0x12, 0xcb, 0x9a,
0x90, 0xad, 0xe3, 0x24, 0xe8, 0x5e, 0xa6, 0xf8, 0xd0, 0x6e, 0xbc, 0xd1, 0x69, 0x7f, 0x6b, 0xe4,
0x2b, 0x4e, 0x1a, 0x65, 0xbb, 0x73, 0x88, 0x6b, 0x7c, 0xaf, 0x7e, 0xd0, 0x47, 0x26, 0xeb, 0xa5,
0xbe, 0xd6, 0xe8, 0xee, 0x9c, 0xa5, 0x66, 0xa5, 0xc9, 0xd3, 0x25, 0x13, 0xc4, 0x0e, 0x6c, 0xab,
0x50, 0xb6, 0x50, 0xc9, 0xce, 0x8f, 0x0a, 0x0b, 0xc6, 0x28, 0x69, 0xe9, 0x83, 0x69, 0xde, 0x42,
0x56, 0x79, 0x7f, 0xde, 0x86, 0x24, 0xca, 0xfc, 0xaa, 0xc0, 0xf3, 0xf3, 0x7f, 0x92, 0x8e, 0x8a,
0x12, 0x52, 0xfe, 0x50, 0xb1, 0x5e, 0x8c, 0x01, 0xce, 0xfc, 0x7e, 0xf2, 0x4f, 0x5f, 0x03, 0xfe,
0xa7, 0xcd, 0xa1, 0xfc, 0x94, 0x52, 0x00, 0x8b, 0x9b, 0x7f, 0x09, 0xab, 0xa8, 0xa4, 0xf5, 0xb4,
0xa5, 0xaa, 0xfc, 0x72, 0xeb, 0x17, 0x40, 0xa9, 0xee, 0xbe, 0x8f, 0xc2, 0xd1, 0x80, 0xc2, 0x0d,
0x44, 0xa9, 0x59, 0x44, 0x59, 0x81, 0x3b, 0x5d, 0x4a, 0xde, 0xfb, 0xae, 0x24, 0xfc, 0xa3, 0xd9,
0xbc, 0x57, 0x55, 0xc2, 0x26, 0xbc, 0x19, 0xa7, 0x9a, 0xc5, 0x59, 0xa3, 0xee, 0x5a, 0xef, 0x41,
0x80, 0x7d, 0xf8, 0x5e, 0xc1, 0x1d, 0x32, 0x38, 0x41, 0x5b, 0xb6, 0x92, 0xb8, 0xb7, 0x03, 0x0d,
0x3e, 0x59, 0x0f, 0x1c, 0xb3, 0xe1, 0x2a, 0x95, 0x1a, 0x3b, 0x50, 0x4f, 0xc4, 0x1d, 0xcf, 0x73,
0x7c, 0x14, 0xca, 0xe3, 0x0b, 0xa7, 0xc7, 0x1a, 0x41, 0x4a, 0xee, 0xbe, 0x1f, 0x43, 0xdd, 0xf9,
// 公钥指数e
0x01, 0x00, 0x01,
// 私钥指数d
0x88, 0x4b, 0x82, 0xe7, 0xe3, 0xe3, 0x99, 0x75, 0x6c, 0x9e, 0xaf, 0x17, 0x44, 0x3e, 0xd9, 0x07,
0xfd, 0x4b, 0xae, 0xce, 0x92, 0xc4, 0x28, 0x44, 0x5e, 0x42, 0x79, 0x08, 0xb6, 0xc3, 0x7f, 0x58,
0x2d, 0xef, 0xac, 0x4a, 0x07, 0xcd, 0xaf, 0x46, 0x8f, 0xb4, 0xc4, 0x43, 0xf9, 0xff, 0x5f, 0x74,
0x2d, 0xb5, 0xe0, 0x1c, 0xab, 0xf4, 0x6e, 0xd5, 0xdb, 0xc8, 0x0c, 0xfb, 0x76, 0x3c, 0x38, 0x66,
0xf3, 0x7f, 0x01, 0x43, 0x7a, 0x30, 0x39, 0x02, 0x80, 0xa4, 0x11, 0xb3, 0x04, 0xd9, 0xe3, 0x57,
0x23, 0xf4, 0x07, 0xfc, 0x91, 0x8a, 0xc6, 0xcc, 0xa2, 0x16, 0x29, 0xb3, 0xe5, 0x76, 0x4a, 0xa8,
0x84, 0x19, 0xdc, 0xef, 0xfc, 0xb0, 0x63, 0x33, 0x0b, 0xfa, 0xf6, 0x68, 0x0b, 0x08, 0xea, 0x31,
0x52, 0xee, 0x99, 0xef, 0x43, 0x2a, 0xbe, 0x97, 0xad, 0xb3, 0xb9, 0x66, 0x7a, 0xae, 0xe1, 0x8f,
0x57, 0x86, 0xe5, 0xfe, 0x14, 0x3c, 0x81, 0xd0, 0x64, 0xf8, 0x86, 0x1a, 0x0b, 0x40, 0x58, 0xc9,
0x33, 0x49, 0xb8, 0x99, 0xc6, 0x2e, 0x94, 0x70, 0xee, 0x09, 0x88, 0xe1, 0x5c, 0x4e, 0x6c, 0x22,
0x72, 0xa7, 0x2a, 0x21, 0xdd, 0xd7, 0x1d, 0xfc, 0x63, 0x15, 0x0b, 0xde, 0x06, 0x9c, 0xf3, 0x28,
0xf3, 0xac, 0x4a, 0xa8, 0xb5, 0x50, 0xca, 0x9b, 0xcc, 0x0a, 0x04, 0xfe, 0x3f, 0x98, 0x68, 0x81,
0xac, 0x24, 0x53, 0xea, 0x1f, 0x1c, 0x6e, 0x5e, 0xca, 0xe8, 0x31, 0x0d, 0x08, 0x12, 0xf3, 0x26,
0xf8, 0x5e, 0xeb, 0x10, 0x27, 0xae, 0xaa, 0xc3, 0xad, 0x6c, 0xc1, 0x89, 0xdb, 0x7d, 0x5a, 0x12,
0x55, 0xad, 0x11, 0x19, 0xa1, 0xa9, 0x8f, 0x0b, 0x6d, 0x78, 0x8d, 0x1c, 0xdf, 0xe5, 0x63, 0x82,
0x0b, 0x7d, 0x23, 0x04, 0xb4, 0x75, 0x8c, 0xed, 0x77, 0xfc, 0x1a, 0x85, 0x29, 0x11, 0xe0, 0x61,
]);
/* 1.确定密钥别名 */
let keyAlias = 'RSA_sample';
/* 2.封装密钥属性集和密钥材料 */
let properties: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_RSA
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_RSA_KEY_SIZE_2048
},
{
// 此 tag表示密钥导入后的用途，导入后将不可更改
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
},
{
// 此 tag表示需导入的密钥类型
tag: huks.HuksTag.HUKS_TAG_IMPORT_KEY_TYPE,
// 此 value表示导入密钥对，若改为HUKS_KEY_TYPE_PUBLIC_KEY时表示仅导入公钥
value: huks.HuksImportKeyType.HUKS_KEY_TYPE_KEY_PAIR
},
]
let options: huks.HuksOptions = {
properties: properties,
inData: rsa2048KeyPairMaterial
};
/* 3.明文导入密钥 */
try {
huks.importKeyItem(keyAlias, options, (error, data) => {
if (error) {
console.error(`callback: importKeyItem failed` + error);
} else {
console.info(`callback: importKeyItem success`);
}
});
} catch (error) {
console.error(`callback: importKeyItem input arg invalid` + error);
}
```
导入X25519密钥公钥
```typescript
/* 以下以导入X25519密钥的Callback操作使用为例 */
import { huks } from '@kit.UniversalKeystoreKit'
// X25519的公钥数据。X25519 密钥对中的私钥和公钥都是 32 字节（256 位），关于算法原理请自行参考相关密钥学资料。
let x25519KeyPubMaterial = new Uint8Array([
0x30, 0x2A, 0x30, 0x05, 0x06, 0x03, 0x2B, 0x65, 0x6E, 0x03, 0x21, 0x00, 0xD2, 0x36, 0x9E, 0xCF,
0xF0, 0x61, 0x5B, 0x73, 0xCE, 0x4F, 0xF0, 0x40, 0x2B, 0x89, 0x18, 0x3E, 0x06, 0x33, 0x60, 0xC6
]);
/* 1.确定密钥别名 */
let keyAlias = 'X25519_Pub_import_sample';
/* 2.封装密钥属性集和密钥材料 */
let properties: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_X25519
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_CURVE25519_KEY_SIZE_256
},
{
// 此 tag表示密钥导入后的用途，导入后将不可更改
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_VERIFY
},
{
// 此 tag表示需导入的密钥类型
tag: huks.HuksTag.HUKS_TAG_IMPORT_KEY_TYPE,
// 此 value表示导入密钥的公钥，若改为HUKS_KEY_TYPE_KEY_PAIR时表示导入密钥对
value: huks.HuksImportKeyType.HUKS_KEY_TYPE_PUBLIC_KEY
},
]
let options: huks.HuksOptions = {
properties: properties,
inData: x25519KeyPubMaterial
};
/* 3.明文导入密钥 */
try {
huks.importKeyItem(keyAlias, options, (error, data) => {
if (error) {
console.error(`callback: importKeyItem failed` + error);
} else {
console.info(`callback: importKeyItem success`);
}
});
} catch (error) {
console.error(`callback: importKeyItem input arg invalid` + error);
}
```
调测验证
调用huks.isKeyItemExist验证密钥是否存在，如密钥存在即表示密钥导入成功。
```typescript
import { huks } from '@kit.UniversalKeystoreKit';
let keyAlias = 'AES256Alias_sample';
let isKeyExist = false;
let keyProperties: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES
}
]
let huksOptions: huks.HuksOptions = {
properties: keyProperties, // 非空填充
inData: new Uint8Array(new Array()) // 非空填充
}
try {
huks.isKeyItemExist(keyAlias, huksOptions, (error, data) => {
if (error) {
console.error(`callback: isKeyItemExist failed, ` + JSON.stringify(error));
} else {
if (data !== null && data.valueOf() !== null) {
isKeyExist = data.valueOf();
console.info(`callback: isKeyItemExist success, isKeyExist = ${isKeyExist}`);
}
}
});
} catch (error) {
console.error(`callback: isKeyItemExist input arg invalid, ` + JSON.stringify(error));
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-import-key-in-plaintext-ndk-V14
爬取时间: 2025-04-28 02:14:58
来源: Huawei Developer
以明文导入ECC密钥为例。具体的场景介绍及支持的算法规格，请参考密钥导入的支持的算法。
在CMake脚本中链接相关动态库
开发步骤
1.  指定密钥别名keyAlias。 密钥别名的最大长度为128字节。
2.  封装密钥属性集和密钥材料。通过OH_Huks_InitParamSet、OH_Huks_AddParams、OH_Huks_BuildParamSet构造密钥属性集paramSet。
3.  调用OH_Huks_ImportKeyItem，传入密钥别名和密钥属性集，导入密钥。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-import-wrapped-key-arkts-V14
爬取时间: 2025-04-28 02:15:12
来源: Huawei Developer
以加密导入ECDH密钥对为例，涉及业务侧加密密钥的密钥生成、协商等操作不在本示例中体现。
具体的场景介绍及支持的算法规格，请参考密钥导入的支持的算法。
开发步骤
1.  设备A（导入设备）将待导入密钥转换成HUKS密钥材料格式To_Import_Key（仅针对非对称密钥，若待导入密钥是对称密钥则可省略此步骤）。
2.  设备B（被导入设备）生成一个加密导入用途的、用于协商的非对称密钥对Wrapping_Key（公钥Wrapping_Pk，私钥Wrapping_Sk），其密钥用途设置为unwrap，导出Wrapping_Key的公钥材料Wrapping_Pk并保存。
3.  设备A使用和设备B同样的算法，生成一个加密导入用途的、用于协商的非对称密钥对Caller_Key（公钥Caller_Pk，私钥Caller_Sk），导出Caller_Key的公钥材料Caller_Pk并保存。
4.  设备A生成一个对称密钥Caller_Kek，该密钥后续将用于加密To_Import_Key。
5.  设备A基于Caller_Key的私钥Caller_Sk和设备B Wrapping_Key的公钥Wrapping_Pk，协商出Shared_Key。
6.  设备A使用Caller_Kek加密To_Import_Key，生成To_Import_Key_Enc。
7.  设备A使用Shared_Key加密Caller_Kek，生成Caller_Kek_Enc。
8.  设备A封装Caller_Pk、Caller_Kek_Enc、To_Import_Key_Enc等加密导入的密钥材料并发送给设备B，加密导入密钥材料格式见加密导入密钥材料格式。
9.  设备B导入封装的加密密钥材料。
10.  设备A、B删除用于加密导入的密钥。
```typescript
import { huks } from '@kit.UniversalKeystoreKit';
let IV = '0000000000000000';
let AAD = "abababababababab";
let NONCE = "hahahahahaha";
let TAG_SIZE = 16;
let FILED_LENGTH = 4;
let importedAes192PlainKey = "The aes192 key to import";
let callerAes256Kek = "The is kek to encrypt aes192 key";
let callerKeyAlias = "test_caller_key_ecdh_aes192";
let callerKekAliasAes256 = "test_caller_kek_ecdh_aes256";
let callerAgreeKeyAliasAes256 = "test_caller_agree_key_ecdh_aes256";
let importedKeyAliasAes192 = "test_import_key_ecdh_aes192";
let huksPubKey: Uint8Array;
let callerSelfPublicKey: Uint8Array;
let outSharedKey: Uint8Array;
let outPlainKeyEncData: Uint8Array;
let outKekEncData: Uint8Array;
let outKekEncTag: Uint8Array;
let outAgreeKeyEncTag: Uint8Array;
let mask = [0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000];
function subUint8ArrayOf(arrayBuf: Uint8Array, start: number, end: number) {
let arr: number[] = [];
for (let i = start; i < end && i < arrayBuf.length; ++i) {
arr.push(arrayBuf[i]);
}
return new Uint8Array(arr);
}
function stringToUint8Array(str: string) {
let arr: number[] = [];
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
function assignLength(length: number, arrayBuf: Uint8Array, startIndex: number) {
let index = startIndex;
for (let i = 0; i < 4; i++) {
arrayBuf[index++] = (length & mask[i]) >> (i * 8);
}
return 4;
}
function assignData(data: Uint8Array, arrayBuf: Uint8Array, startIndex: number) {
let index = startIndex;
for (let i = 0; i < data.length; i++) {
arrayBuf[index++] = data[i];
}
return data.length;
}
let genWrappingKeyParams: huks.HuksOptions = {
properties: new Array<huks.HuksParam>(
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_ECC
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_UNWRAP
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_CURVE25519_KEY_SIZE_256
},
{
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE
}
)
}
let genCallerEcdhParams: huks.HuksOptions = {
properties: new Array<huks.HuksParam>(
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_ECC
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_AGREE
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_CURVE25519_KEY_SIZE_256
}
)
}
let importParamsCallerKek: huks.HuksOptions = {
properties: new Array<huks.HuksParam>(
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256
},
{
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE
},
{
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_GCM
},
{
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_NONE
},
{
tag: huks.HuksTag.HUKS_TAG_IV,
value: stringToUint8Array(IV)
}
),
inData: stringToUint8Array(callerAes256Kek)
}
let importParamsAgreeKey: huks.HuksOptions = {
properties: new Array<huks.HuksParam>(
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256
},
{
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE
},
{
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_GCM
},
{
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_NONE
},
{
tag: huks.HuksTag.HUKS_TAG_IV,
value: stringToUint8Array(IV)
}
),
}
let callerAgreeParams: huks.HuksOptions = {
properties: new Array<huks.HuksParam>(
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_ECDH
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_AGREE
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_CURVE25519_KEY_SIZE_256
}
)
}
let encryptKeyCommonParams: huks.HuksOptions = {
properties: new Array<huks.HuksParam>(
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256
},
{
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE
},
{
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_GCM
},
{
tag: huks.HuksTag.HUKS_TAG_NONCE,
value: stringToUint8Array(NONCE)
},
{
tag: huks.HuksTag.HUKS_TAG_ASSOCIATED_DATA,
value: stringToUint8Array(AAD)
}
),
}
let importWrappedAes192Params: huks.HuksOptions = {
properties: new Array<huks.HuksParam>(
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |
huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_192
},
{
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE
},
{
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_CBC
},
{
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_NONE
},
{
tag: huks.HuksTag.HUKS_TAG_UNWRAP_ALGORITHM_SUITE,
value: huks.HuksUnwrapSuite.HUKS_UNWRAP_SUITE_ECDH_AES_256_GCM_NOPADDING
},
{
tag: huks.HuksTag.HUKS_TAG_IV,
value: stringToUint8Array(IV)
}
)
}
async function publicGenerateItemFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise generateKeyItem`);
try {
await huks.generateKeyItem(keyAlias, huksOptions)
.then(data => {
console.info(`promise: generateKeyItem success, data = ${JSON.stringify(data)}`);
})
.catch((err: Error) => {
console.error(`promise: generateKeyItem failed, ${JSON.stringify(err)}`);
})
} catch (err) {
console.error(`promise: generateKeyItem invalid, ${JSON.stringify(err)}`);
}
}
async function publicImportKeyItemFunc(keyAlias: string, HuksOptions: huks.HuksOptions) {
console.info(`enter promise importKeyItem`);
try {
await huks.importKeyItem(keyAlias, HuksOptions)
.then(data => {
console.info(`promise: importKeyItem success, data = ${JSON.stringify(data)}`);
}).catch((err: Error) => {
console.error(`promise: importKeyItem failed, ${JSON.stringify(err)}`);
})
} catch (err) {
console.error(`promise: importKeyItem input arg invalid, ${JSON.stringify(err)}`);
}
}
async function publicDeleteKeyItemFunc(KeyAlias: string, HuksOptions: huks.HuksOptions) {
console.info(`enter promise deleteKeyItem`);
try {
await huks.deleteKeyItem(KeyAlias, HuksOptions)
.then(data => {
console.info(`promise: deleteKeyItem key success, data = ${JSON.stringify(data)}`);
})
.catch((err: Error) => {
console.error(`promise: deleteKeyItem failed, ${JSON.stringify(err)}`);
})
} catch (err) {
console.error(`promise: deleteKeyItem input arg invalid, ${JSON.stringify(err)}`);
}
}
function importWrappedKeyItem(keyAlias: string, wrappingKeyAlias: string, huksOptions: huks.HuksOptions) {
return new Promise<void>((resolve, reject) => {
try {
huks.importWrappedKeyItem(keyAlias, wrappingKeyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
}
});
}
async function publicImportWrappedKeyFunc(keyAlias: string, wrappingKeyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise importWrappedKeyItem`);
for (let i = 0; i < huksOptions.inData!.length; i++) {
console.error(`${i}: ${huksOptions.inData![i]}`);
}
try {
await importWrappedKeyItem(keyAlias, wrappingKeyAlias, huksOptions)
.then((data) => {
console.info(`promise: importWrappedKeyItem success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
console.error(`promise: importWrappedKeyItem failed, ${JSON.stringify(error)}`);
});
} catch (error) {
console.error(`promise: importWrappedKeyItem input arg invalid, ${JSON.stringify(error)}`);
}
}
async function publicImportWrappedKeyPromise(keyAlias: string, wrappingKeyAlias: string,
huksOptions: huks.HuksOptions) {
console.info(`enter promise importWrappedKeyItem`);
try {
await huks.importWrappedKeyItem(keyAlias, wrappingKeyAlias, huksOptions)
.then((data) => {
console.info(`promise: importWrappedKeyItem success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
console.error(`promise: importWrappedKeyItem failed, ${JSON.stringify(error)}`);
});
} catch (error) {
console.error(`promise: importWrappedKeyItem input arg invalid, ${JSON.stringify(error)}`);
}
}
async function publicInitFunc(srcKeyAlias: string, HuksOptions: huks.HuksOptions) {
let handle: number = 0;
console.info(`enter promise doInit`);
try {
await huks.initSession(srcKeyAlias, HuksOptions)
.then((data) => {
console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);
handle = data.handle;
})
.catch((error: Error) => {
console.error(`promise: doInit key failed, ${JSON.stringify(error)}`);
});
} catch (error) {
console.error(`promise: doInit input arg invalid, ${JSON.stringify(error)}`);
}
return handle;
}
async function publicUpdateSessionFunction(handle: number, HuksOptions: huks.HuksOptions) {
const maxUpdateSize = 64;
const inData = HuksOptions.inData!;
const lastInDataPosition = inData.length - 1;
let inDataSegSize = maxUpdateSize;
let inDataSegPosition = 0;
let isFinished = false;
let outData: number[] = [];
while (inDataSegPosition <= lastInDataPosition) {
if (inDataSegPosition + maxUpdateSize > lastInDataPosition) {
isFinished = true;
inDataSegSize = lastInDataPosition - inDataSegPosition + 1;
console.info(`enter promise doUpdate`);
break;
}
HuksOptions.inData = new Uint8Array(
Array.from(inData).slice(inDataSegPosition, inDataSegPosition + inDataSegSize)
);
console.info(`enter promise doUpdate`);
try {
await huks.updateSession(handle, HuksOptions)
.then((data) => {
console.info(`promise: doUpdate success, data = ${JSON.stringify(data)}`);
outData = outData.concat(Array.from(data.outData!));
})
.catch((error: Error) => {
console.error(`promise: doUpdate failed, ${JSON.stringify(error)}`);
});
} catch (error) {
console.error(`promise: doUpdate input arg invalid, ${JSON.stringify(error)}`);
}
if ((!isFinished) && (inDataSegPosition + maxUpdateSize > lastInDataPosition)) {
console.error(`update size invalid isFinished = ${isFinished}`);
console.error(`inDataSegPosition = ${inDataSegPosition}`);
console.error(`lastInDataPosition = ${lastInDataPosition}`);
return;
}
inDataSegPosition += maxUpdateSize;
}
return outData;
}
async function publicFinishSession(handle: number, HuksOptions: huks.HuksOptions, inData: number[]) {
let outData: number[] = [];
console.info(`enter promise doFinish`);
try {
await huks.finishSession(handle, HuksOptions)
.then((data) => {
console.info(`promise: doFinish success, data = ${JSON.stringify(data)}`);
outData = inData.concat(Array.from(data.outData!));
})
.catch((error: Error) => {
console.error(`promise: doFinish key failed, ${JSON.stringify(error)}`);
});
} catch (error) {
console.error(`promise: doFinish input arg invalid, ${JSON.stringify(error)}`);
}
return new Uint8Array(outData);
}
async function cipherFunction(keyAlias: string, HuksOptions: huks.HuksOptions) {
let handle = await publicInitFunc(keyAlias, HuksOptions);
let tmpData = await publicUpdateSessionFunction(handle, HuksOptions);
let outData = await publicFinishSession(handle, HuksOptions, tmpData!);
return outData;
}
async function agreeFunction(keyAlias: string, HuksOptions: huks.HuksOptions, huksPublicKey: Uint8Array) {
let handle = await publicInitFunc(keyAlias, HuksOptions);
let outSharedKey: Uint8Array = new Uint8Array;
HuksOptions.inData = huksPublicKey;
console.info(`enter promise doUpdate`);
try {
await huks.updateSession(handle, HuksOptions)
.then((data) => {
console.error(`promise: doUpdate success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
console.error(`promise: doUpdate failed, ${JSON.stringify(error)}`);
});
} catch (error) {
console.error(`promise: doUpdate input arg invalid, ${JSON.stringify(error)}`);
}
console.info(`enter promise doInit`);
try {
await huks.finishSession(handle, HuksOptions)
.then((data) => {
console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);
outSharedKey = data.outData as Uint8Array;
})
.catch((error: Error) => {
console.error(`promise: doInit key failed, ${JSON.stringify(error)}`);
});
} catch (error) {
console.error(`promise: doInit input arg invalid, ${JSON.stringify(error)}`);
}
return outSharedKey;
}
async function ImportKekAndAgreeSharedSecret(callerKekAlias: string, importKekParams: huks.HuksOptions,
callerKeyAlias: string, huksPublicKey: Uint8Array, agreeParams: huks.HuksOptions) {
await publicImportKeyItemFunc(callerKekAlias, importKekParams);
outSharedKey = await agreeFunction(callerKeyAlias, agreeParams, huksPublicKey);
importParamsAgreeKey.inData = outSharedKey;
await publicImportKeyItemFunc(callerAgreeKeyAliasAes256, importParamsAgreeKey);
}
async function generateAndExportPublicKey(keyAlias: string, HuksOptions: huks.HuksOptions, caller: Boolean) {
await publicGenerateItemFunc(keyAlias, HuksOptions);
try {
await huks.exportKeyItem(keyAlias, HuksOptions)
.then((data) => {
console.info(`promise: exportKeyItem success, data = ${JSON.stringify(data)}`);
if (caller) {
callerSelfPublicKey = data.outData as Uint8Array;
} else {
huksPubKey = data.outData as Uint8Array;
}
})
.catch((error: Error) => {
console.error(`promise: exportKeyItem failed, ${JSON.stringify(error)}`);
});
} catch (error) {
console.error(`promise: generate pubKey failed, ${JSON.stringify(error)}`);
}
}
async function EncryptImportedPlainKeyAndKek(keyAlias: string) {
encryptKeyCommonParams.inData = stringToUint8Array(keyAlias)
let plainKeyEncData = await cipherFunction(callerKekAliasAes256, encryptKeyCommonParams);
outKekEncTag = subUint8ArrayOf(plainKeyEncData, plainKeyEncData.length - TAG_SIZE, plainKeyEncData.length)
outPlainKeyEncData = subUint8ArrayOf(plainKeyEncData, 0, plainKeyEncData.length - TAG_SIZE)
encryptKeyCommonParams.inData = stringToUint8Array(callerAes256Kek)
let kekEncData = await cipherFunction(callerAgreeKeyAliasAes256, encryptKeyCommonParams)
outAgreeKeyEncTag = subUint8ArrayOf(kekEncData, kekEncData.length - TAG_SIZE, kekEncData.length)
outKekEncData = subUint8ArrayOf(kekEncData, 0, kekEncData.length - TAG_SIZE)
}
async function BuildWrappedDataAndImportWrappedKey(plainKey: string) {
let plainKeySizeBuff = new Uint8Array(4);
assignLength(plainKey.length, plainKeySizeBuff, 0);
let wrappedData = new Uint8Array(
FILED_LENGTH + huksPubKey.length +
FILED_LENGTH + AAD.length +
FILED_LENGTH + NONCE.length +
FILED_LENGTH + TAG_SIZE +
FILED_LENGTH + outKekEncData.length +
FILED_LENGTH + AAD.length +
FILED_LENGTH + NONCE.length +
FILED_LENGTH + TAG_SIZE +
FILED_LENGTH + plainKeySizeBuff.length +
FILED_LENGTH + outPlainKeyEncData.length
);
let index = 0;
let AADUint8Array = stringToUint8Array(AAD);
let NonceArray = stringToUint8Array(NONCE);
index += assignLength(callerSelfPublicKey.length, wrappedData, index); // 4
index += assignData(callerSelfPublicKey, wrappedData, index); // 91
index += assignLength(AADUint8Array.length, wrappedData, index); // 4
index += assignData(AADUint8Array, wrappedData, index); // 16
index += assignLength(NonceArray.length, wrappedData, index); // 4
index += assignData(NonceArray, wrappedData, index); // 12
index += assignLength(outAgreeKeyEncTag.length, wrappedData, index); // 4
index += assignData(outAgreeKeyEncTag, wrappedData, index); // 16
index += assignLength(outKekEncData.length, wrappedData, index); // 4
index += assignData(outKekEncData, wrappedData, index); // 32
index += assignLength(AADUint8Array.length, wrappedData, index); // 4
index += assignData(AADUint8Array, wrappedData, index); // 16
index += assignLength(NonceArray.length, wrappedData, index); // 4
index += assignData(NonceArray, wrappedData, index); // 12
index += assignLength(outKekEncTag.length, wrappedData, index); // 4
index += assignData(outKekEncTag, wrappedData, index); // 16
index += assignLength(plainKeySizeBuff.length, wrappedData, index); // 4
index += assignData(plainKeySizeBuff, wrappedData, index); // 4
index += assignLength(outPlainKeyEncData.length, wrappedData, index); // 4
index += assignData(outPlainKeyEncData, wrappedData, index); // 24
return wrappedData;
}
/* 模拟加密导入密钥场景，设备A为远端设备（导入设备），设备B为本端设备（被导入设备） */
async function ImportWrappedKey() {
/**
* 1.设备A将待导入密钥转换成HUKS密钥材料格式To_Import_Key（仅针对非对称密钥，若待导入密钥是对称密钥则可省略此步骤），
*   本示例使用importedAes256PlainKey（对称密钥）作为模拟
*/
/* 2.设备B生成一个加密导入用途的、用于协商的非对称密钥对Wrapping_Key（公钥Wrapping_Pk，私钥Wrapping_Sk），其密钥用途设置为unwrap，导出Wrapping_Key公钥Wrapping_Pk存放在变量huksPubKey中 */
const srcKeyAliasWrap = 'HUKS_Basic_Capability_Import_0200';
await generateAndExportPublicKey(srcKeyAliasWrap, genWrappingKeyParams, false);
/* 3.设备A使用和设备B同样的算法，生成一个加密导入用途的、用于协商的非对称密钥对Caller_Key（公钥Caller_Pk，私钥Caller_Sk），导出Caller_Key公钥Caller_Pk存放在变量callerSelfPublicKey中 */
await generateAndExportPublicKey(callerKeyAlias, genCallerEcdhParams, true);
/**
* 4.设备A生成一个对称密钥Caller_Kek，该密钥后续将用于加密To_Import_Key
* 5.设备A基于Caller_Key的私钥Caller_Sk和Wrapping_Key的公钥Wrapping_Pk，协商出Shared_Key
*/
await ImportKekAndAgreeSharedSecret(callerKekAliasAes256, importParamsCallerKek, callerKeyAlias, huksPubKey,
callerAgreeParams);
/**
* 6.设备A使用Caller_Kek加密To_Import_Key，生成To_Import_Key_Enc
* 7.设备A使用Shared_Key加密Caller_Kek，生成Caller_Kek_Enc
*/
await EncryptImportedPlainKeyAndKek(importedAes192PlainKey);
/* 8.设备A封装Caller_Pk、To_Import_Key_Enc、Caller_Kek_Enc等加密导入的材料并发送给设备B。本示例作为变量存放在callerSelfPublicKey，PlainKeyEncData，KekEncData */
let wrappedData = await BuildWrappedDataAndImportWrappedKey(importedAes192PlainKey);
importWrappedAes192Params.inData = wrappedData;
/* 9.设备B导入封装的加密密钥材料 */
await publicImportWrappedKeyFunc(importedKeyAliasAes192, srcKeyAliasWrap, importWrappedAes192Params);
/* 10.设备A、B删除用于加密导入的密钥 */
await publicDeleteKeyItemFunc(srcKeyAliasWrap, genWrappingKeyParams);
await publicDeleteKeyItemFunc(callerKeyAlias, genCallerEcdhParams);
await publicDeleteKeyItemFunc(importedKeyAliasAes192, importWrappedAes192Params);
await publicDeleteKeyItemFunc(callerKekAliasAes256, callerAgreeParams);
}
```
调测验证
调用huks.isKeyItemExist验证密钥是否存在，如密钥存在即表示密钥导入成功。
```typescript
import { huks } from '@kit.UniversalKeystoreKit';
/*
* 确定密钥别名和封装密钥属性参数集
*/
let keyAlias = 'test_import_key_ecdh_aes192';
let isKeyExist: Boolean;
let keyProperties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES,
}];
let huksOptions: huks.HuksOptions = {
properties: keyProperties, // 非空填充
inData: new Uint8Array(new Array()) // 非空填充
}
try {
huks.isKeyItemExist(keyAlias, huksOptions, (error, data) => {
if (error) {
console.error(`callback: isKeyItemExist failed, ${JSON.stringify(error)}`);
} else {
if (data !== null && data.valueOf() !== null) {
isKeyExist = data.valueOf();
console.info(`callback: isKeyItemExist success, isKeyExist = ${isKeyExist}`);
}
}
});
} catch (error) {
console.error(`callback: isKeyItemExist input arg invalid, ${JSON.stringify(error)}`);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-import-wrapped-key-ndk-V14
爬取时间: 2025-04-28 02:15:26
来源: Huawei Developer
以加密导入ECDH密钥对为例，涉及业务侧加密密钥的密钥生成、协商等操作不在本示例中体现。
具体的场景介绍及支持的算法规格，请参考密钥导入的支持的算法。
在CMake脚本中链接相关动态库
开发步骤
下文中wrap指加密，unwrap指解密
1.  设备A（导入设备）将待导入密钥转换成HUKS密钥材料格式To_Import_Key（仅针对非对称密钥，若待导入密钥是对称密钥则可省略此步骤）。
2.  设备B（被导入设备）生成一个加密导入用途的、用于协商的非对称密钥对Wrapping_Key（公钥Wrapping_Pk，私钥Wrapping_Sk），其密钥用途设置为unwrap，导出Wrapping_Key的公钥材料Wrapping_Pk并保存。
3.  设备A使用和设备B同样的算法，生成一个加密导入用途的、用于协商的非对称密钥对Caller_Key（公钥Caller_Pk，私钥Caller_Sk），导出Caller_Key的公钥材料Caller_Pk并保存。
4.  设备A生成一个对称密钥Caller_Kek，该密钥后续将用于加密To_Import_Key。
5.  设备A基于Caller_Key的私钥Caller_Sk和设备B Wrapping_Key的公钥Wrapping_Pk，协商出Shared_Key。
6.  设备A使用Caller_Kek加密To_Import_Key，生成To_Import_Key_Enc。
7.  设备A使用Shared_Key加密Caller_Kek，生成Caller_Kek_Enc。
8.  设备A封装Caller_Pk、Caller_Kek_Enc、To_Import_Key_Enc等加密导入的密钥材料并发送给设备B，加密导入密钥材料格式见加密导入密钥材料格式。
9.  设备B导入封装的加密密钥材料。
10.  设备A、B删除用于加密导入的密钥。
调测验证
调用OH_Huks_IsKeyItemExist验证密钥是否存在，如密钥存在即表示密钥导入成功。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-use-V14
爬取时间: 2025-04-28 02:15:39
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-use-overview-V14
爬取时间: 2025-04-28 02:15:53
来源: Huawei Developer
为了实现对数据机密性、完整性等保护，可使用生成/导入的密钥，对数据进行密钥操作，比如：
-  加密解密。
-  签名验签。
-  密钥协商。
-  密钥派生。
本章节提供了以上常用密钥操作的示例，这部分示例均没有设置二次身份访问控制，如设置了密钥访问控制请参考密钥访问控制用法。
通用开发流程
HUKS基于密钥会话来操作数据，使用密钥时基于以下流程：
1.  （必选）初始化密钥会话huks.initSession()。 传入密钥别名和密钥操作参数，初始化一个密钥会话并获取会话句柄。其中密钥操作参数中必须包含对应密码算法所必须的参数，包括密码算法、密钥大小、密钥目的、工作模式、填充模式、散列模式、IV、Nonce、AAD等。
2.  （可选）分段操作数据huks.updateSession()。 当使用的数据过大（超过100K）或是部分密码算法有要求时，需要对数据进行分段操作。否则可跳过此步骤。
3.  （必选）结束密钥会话huks.finishSession()。 操作最后一段数据并结束密钥会话。
以上任一阶段中发生错误或不需要此次密钥操作数据，均需要取消会话huks.abortSession()，终止密钥的使用。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-encryption-decryption-V14
爬取时间: 2025-04-28 02:16:06
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-encryption-decryption-overview-V14
爬取时间: 2025-04-28 02:16:20
来源: Huawei Developer
在HUKS中已经有密钥，需要对一段数据加密或是解密，均可以使用HUKS完成加密/解密操作。
支持的算法
以下为密钥加密/解密支持的规格说明。
标准设备规格
| 算法/分组模式/填充模式 | 备注 | API级别 |
| --- | --- | --- |
| AES/CBC/NoPadding AES/CBC/PKCS7 AES/CTR/NoPadding  | IV参数必选；CBC模式下，若填充模式选择为NoPadding，因为该模式下要求明文数据必须按照固定长度的块进行加密，如果输入的数据长度不是16的倍数，就需要业务方自行填充，以满足块长度的要求。 | 8+ |
| AES/GCM/NoPadding | 加密：Nonce参数必选 解密：Nonce、TAG参数必选  | 8+ |
| RSA/ECB/NoPadding RSA/ECB/PKCS1_V1_5 RSA/ECB/OAEP  | OAEP填充模式支持的摘要算法：SHA256/SHA384/SHA512 | 8+ |
| SM4/CTR/NoPadding SM4/CBC/NoPadding SM4/CFB/NoPadding  | IV 参数必选 | 12+ |
| SM4/OFB/NoPadding | Nonce 参数必选 | 12+ |
| SM2/-/NoPadding | 摘要算法SM3 | 11+ |
AES/CBC/NoPadding
AES/CBC/PKCS7
AES/CTR/NoPadding
加密：Nonce参数必选
解密：Nonce、TAG参数必选
RSA/ECB/NoPadding
RSA/ECB/PKCS1_V1_5
RSA/ECB/OAEP
SM4/CTR/NoPadding
SM4/CBC/NoPadding
SM4/CFB/NoPadding
轻量级设备规格
| 算法/分组模式/填充模式 | 备注 | API级别 |
| --- | --- | --- |
| AES/GCM/NoPadding | 加密：Nonce参数必选 解密：Nonce、TAG参数必选  | 8+ |
| AES/CBC/NoPadding AES/CTR/NoPadding  | IV参数必选 | 11+ |
| DES/ECB/NoPadding | - | 12+ |
| DES/CBC/NoPadding | IV参数必选 | 12+ |
| 3DES/ECB/NoPadding | - | 12+ |
| 3DES/CBC/NoPadding | IV参数必选 | 12+ |
| RSA/ECB/NoPadding | - | 12+ |
| RSA/ECB/PKCS1_V1_5 | - | 12+ |
| RSA/ECB/OAEP | 摘要算法SHA256 | 12+ |
加密：Nonce参数必选
解密：Nonce、TAG参数必选
AES/CBC/NoPadding
AES/CTR/NoPadding

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-encryption-decryption-dev-V14
爬取时间: 2025-04-28 02:16:33
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-encryption-decryption-arkts-V14
爬取时间: 2025-04-28 02:16:47
来源: Huawei Developer
以AES 128、RSA 2048和SM2为例，完成加解密。具体的场景介绍及支持的算法规格，请参考密钥生成支持的算法。
开发步骤
生成密钥
1.  指定密钥别名。
2.  初始化密钥属性集。
3.  调用generateKeyItem生成密钥，具体请参考密钥生成。
除此之外，开发者也可以参考密钥导入，导入已有的密钥。
加密
1.  获取密钥别名。
2.  获取待加密的数据。
3.  获取加密算法参数配置。 文档中提供多个示例，当使用不同算法时，请注意配置对应参数。 详细规格请参考加密/解密介绍及算法规格。
4.  调用initSession初始化密钥会话，并获取会话的句柄handle。
5.  调用finishSession结束密钥会话，获取加密后的密文。
解密
1.  获取密钥别名。
2.  获取待解密的密文。
3.  获取解密算法参数配置。 文档中提供多个示例，当使用不同算法时，请注意配置对应参数。 详细规格请参考加密/解密介绍及算法规格。
4.  调用initSession初始化密钥会话，并获取会话的句柄handle。
5.  调用finishSession结束密钥会话，获取解密后的数据。
删除密钥
当密钥废弃不用时，需要调用deleteKeyItem删除密钥，具体请参考密钥删除。
开发案例
AES/CBC/PKCS7
```typescript
/*
* 以下以AES/CBC/PKCS7的Promise操作使用为例
*/
import { huks } from '@kit.UniversalKeystoreKit';
let aesKeyAlias = 'test_aesKeyAlias';
let handle: number;
let plainText = '123456';
let IV = '001122334455';
let cipherData: Uint8Array;
function StringToUint8Array(str: String) {
let arr: number[] = new Array();
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
function Uint8ArrayToString(fileData: Uint8Array) {
let dataString = '';
for (let i = 0; i < fileData.length; i++) {
dataString += String.fromCharCode(fileData[i]);
}
return dataString;
}
function GetAesGenerateProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |
huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
}];
return properties;
}
function GetAesEncryptProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_PKCS7
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_CBC
}, {
tag: huks.HuksTag.HUKS_TAG_IV,
value: StringToUint8Array(IV)
}];
return properties;
}
function GetAesDecryptProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_PKCS7
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_CBC
}, {
tag: huks.HuksTag.HUKS_TAG_IV,
value: StringToUint8Array(IV)
}];
return properties;
}
async function GenerateAesKey() {
/*
* 模拟生成密钥场景
* 1. 确定密钥别名
*/
/*
* 2. 获取生成密钥算法参数配置
*/
let genProperties = GetAesGenerateProperties();
let options: huks.HuksOptions = {
properties: genProperties
}
/*
* 3. 调用generateKeyItem
*/
await huks.generateKeyItem(aesKeyAlias, options)
.then((data) => {
console.info(`promise: generate AES Key success, data = ${JSON.stringify(data)}`);
}).catch((error: Error) => {
console.error(`promise: generate AES Key failed, ${JSON.stringify(error)}`);
})
}
async function EncryptData() {
/*
* 模拟加密场景
* 1. 获取密钥别名
*/
/*
* 2. 获取待加密的数据
*/
/*
* 3. 获取加密算法参数配置
*/
let encryptProperties = GetAesEncryptProperties();
let options: huks.HuksOptions = {
properties: encryptProperties,
inData: StringToUint8Array(plainText)
}
/*
* 4. 调用initSession获取handle
*/
await huks.initSession(aesKeyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((error: Error) => {
console.error(`promise: init EncryptData failed, ${JSON.stringify(error)}`);
})
/*
* 5. 调用finishSession获取加密后的密文
*/
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: encrypt data success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
cipherData = data.outData as Uint8Array;
}).catch((error: Error) => {
console.error(`promise: encrypt data failed, ${JSON.stringify(error)}`);
})
}
async function DecryptData() {
/*
* 模拟解密场景
* 1. 获取密钥别名
*/
/*
* 2. 获取待解密的密文
*/
/*
* 3. 获取解密算法参数配置
*/
let decryptOptions = GetAesDecryptProperties()
let options: huks.HuksOptions = {
properties: decryptOptions,
inData: cipherData
}
/*
* 4. 调用initSession获取handle
*/
await huks.initSession(aesKeyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((error: Error) => {
console.error(`promise: init DecryptData failed, ${JSON.stringify(error)}`);
})
/*
* 5. 调用finishSession获取解密后的数据
*/
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: decrypt data success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
}).catch((error: Error) => {
console.error(`promise: decrypt data failed, ${JSON.stringify(error)}`);
})
}
async function DeleteKey() {
/*
* 模拟删除密钥场景
* 1. 获取密钥别名
*/
let emptyOptions: huks.HuksOptions = {
properties: []
}
/*
* 2. 调用deleteKeyItem删除密钥
*/
await huks.deleteKeyItem(aesKeyAlias, emptyOptions)
.then((data) => {
console.info(`promise: delete data success`);
}).catch((error: Error) => {
console.error(`promise: delete data failed, ${JSON.stringify(error)}`);
})
}
```
AES/GCM/NoPadding
```typescript
/*
* 以下以AES/GCM/NoPadding的Promise操作使用为例
*/
import { huks } from '@kit.UniversalKeystoreKit';
let aesKeyAlias = 'test_aesKeyAlias';
let handle: number;
let plainText = '123456';
let cipherData: Uint8Array;
let AAD = '1234567890123456';
let NONCE = '001122334455';
function StringToUint8Array(str: String) {
let arr: number[] = new Array();
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
function Uint8ArrayToString(fileData: Uint8Array) {
let dataString = '';
for (let i = 0; i < fileData.length; i++) {
dataString += String.fromCharCode(fileData[i]);
}
return dataString;
}
function GetAesGenerateProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |
huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
}];
return properties;
}
function GetAesGcmEncryptProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_GCM
}, {
tag: huks.HuksTag.HUKS_TAG_NONCE,
value: StringToUint8Array(NONCE)
}, {
tag: huks.HuksTag.HUKS_TAG_ASSOCIATED_DATA,
value: StringToUint8Array(AAD)
}];
return properties;
}
function GetAesGcmDecryptProperties(cipherData:Uint8Array) {
let properties: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_GCM
}, {
tag: huks.HuksTag.HUKS_TAG_NONCE,
value: StringToUint8Array(NONCE)
}, {
tag: huks.HuksTag.HUKS_TAG_ASSOCIATED_DATA,
value: StringToUint8Array(AAD)
}, {
tag: huks.HuksTag.HUKS_TAG_AE_TAG,
value: cipherData.slice(cipherData.length-16)
}];
return properties;
}
async function GenerateAesKey() {
/*
* 模拟生成密钥场景
* 1. 确定密钥别名
*/
/*
* 2. 获取生成密钥算法参数配置
*/
let genProperties = GetAesGenerateProperties();
let options: huks.HuksOptions = {
properties: genProperties
}
/*
* 3. 调用generateKeyItem
*/
await huks.generateKeyItem(aesKeyAlias, options)
.then((data) => {
console.info(`promise: generate AES Key success, data = ${JSON.stringify(data)}`);
}).catch((error: Error) => {
console.error(`promise: generate AES Key failed, ${JSON.stringify(error)}`);
})
}
async function EncryptData() {
/*
* 模拟加密场景
* 1. 获取密钥别名
*/
/*
* 2. 获取待加密的数据
*/
/*
* 3. 获取加密算法参数配置
*/
let encryptProperties = GetAesGcmEncryptProperties();
let options: huks.HuksOptions = {
properties: encryptProperties,
inData: StringToUint8Array(plainText)
}
/*
* 4. 调用initSession获取handle
*/
await huks.initSession(aesKeyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((error: Error) => {
console.error(`promise: init EncryptDataGcm failed, ${JSON.stringify(error)}`);
})
/*
* 5. 调用finishSession获取加密后的密文
*/
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: encrypt data success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
cipherData = data.outData as Uint8Array;
}).catch((error: Error) => {
console.error(`promise: encrypt data failed, ${JSON.stringify(error)}`);
})
}
async function DecryptData() {
/*
* 模拟解密场景
* 1. 获取密钥别名
*/
/*
* 2. 获取待解密的密文
*/
/*
* 3. 获取解密算法参数配置
*/
let decryptOptions = GetAesGcmDecryptProperties(cipherData)
let options: huks.HuksOptions = {
properties: decryptOptions,
inData: cipherData.slice(0, cipherData.length-16)
}
/*
* 4. 调用initSession获取handle
*/
await huks.initSession(aesKeyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((error: Error) => {
console.error(`promise: init DecryptDataGcm failed, ${JSON.stringify(error)}`);
})
/*
* 5. 调用finishSession获取解密后的数据
*/
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: decrypt data success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
}).catch((error: Error) => {
console.error(`promise: decrypt data failed, ${JSON.stringify(error)}`);
})
}
async function DeleteKey() {
/*
* 模拟删除密钥场景
* 1. 获取密钥别名
*/
let emptyOptions: huks.HuksOptions = {
properties: []
}
/*
* 2. 调用deleteKeyItem删除密钥
*/
await huks.deleteKeyItem(aesKeyAlias, emptyOptions)
.then((data) => {
console.info(`promise: delete data success`);
}).catch((error: Error) => {
console.error(`promise: delete data failed, ${JSON.stringify(error)}`);
})
}
```
RSA/ECB/PKCS1_V1_5
```typescript
/*
* 以下以RSA/ECB/PKCS1_V1_5模式的Promise操作使用为例
*/
import { huks } from '@kit.UniversalKeystoreKit';
let rsaKeyAlias = 'test_rsaKeyAlias';
let handle: number;
let plainText = '123456';
let cipherData: Uint8Array;
function StringToUint8Array(str: String) {
let arr: number[] = new Array();
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
function Uint8ArrayToString(fileData: Uint8Array) {
let dataString = '';
for (let i = 0; i < fileData.length; i++) {
dataString += String.fromCharCode(fileData[i]);
}
return dataString;
}
function GetRsaGenerateProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_RSA
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_RSA_KEY_SIZE_2048
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |
huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
}];
return properties;
}
function GetRsaEncryptProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_RSA
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_RSA_KEY_SIZE_2048
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_PKCS1_V1_5
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_ECB
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_NONE
}];
return properties;
}
function GetRsaDecryptProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_RSA
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_RSA_KEY_SIZE_2048
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_PKCS1_V1_5
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_ECB
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_NONE
}];
return properties;
}
async function GenerateRsaKey() {
/*
* 模拟生成密钥场景
* 1. 确定密钥别名
*/
/*
* 2. 获取生成密钥算法参数配置
*/
let genProperties = GetRsaGenerateProperties();
let options: huks.HuksOptions = {
properties: genProperties
}
/*
* 3. 调用generateKeyItem
*/
await huks.generateKeyItem(rsaKeyAlias, options)
.then((data) => {
console.info(`promise: generate RSA Key success, data = ${JSON.stringify(data)}`);
}).catch((error: Error) => {
console.error(`promise: generate RSA Key failed, ${JSON.stringify(error)}`);
})
}
async function EncryptData() {
/*
* 模拟加密场景
* 1. 获取密钥别名
*/
/*
* 2. 获取待加密的数据
*/
/*
* 3. 获取加密算法参数配置
*/
let encryptProperties = GetRsaEncryptProperties();
let options: huks.HuksOptions = {
properties: encryptProperties,
inData: StringToUint8Array(plainText)
}
/*
* 4. 调用initSession获取handle
*/
await huks.initSession(rsaKeyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((error: Error) => {
console.error(`promise: init EncryptDataRsa failed, ${JSON.stringify(error)}`);
})
/*
* 5. 调用finishSession获取加密后的密文
*/
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: encrypt data success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
cipherData = data.outData as Uint8Array;
}).catch((error: Error) => {
console.error(`promise: encrypt data failed, ${JSON.stringify(error)}`);
})
}
async function DecryptData() {
/*
* 模拟解密场景
* 1. 获取密钥别名
*/
/*
* 2. 获取待解密的密文
*/
/*
* 3. 获取解密算法参数配置
*/
let decryptOptions = GetRsaDecryptProperties()
let options: huks.HuksOptions = {
properties: decryptOptions,
inData: cipherData
}
/*
* 4. 调用initSession获取handle
*/
await huks.initSession(rsaKeyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((error: Error) => {
console.error(`promise: init DecryptDataRsa failed, ${JSON.stringify(error)}`);
})
/*
* 5. 调用finishSession获取解密后的数据
*/
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: decrypt data success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
}).catch((error: Error) => {
console.error(`promise: decrypt data failed, ${JSON.stringify(error)}`);
})
}
async function DeleteKey() {
/*
* 模拟删除密钥场景
* 1. 获取密钥别名
*/
let emptyOptions: huks.HuksOptions = {
properties: []
}
/*
* 2. 调用deleteKeyItem删除密钥
*/
await huks.deleteKeyItem(rsaKeyAlias, emptyOptions)
.then((data) => {
console.info(`promise: delete data success`);
}).catch((error: Error) => {
console.error(`promise: delete data failed, ${JSON.stringify(error)}`);
})
}
```
RSA/ECB/OAEP/SHA256
```typescript
/*
* 以下以RSA/ECB/OAEP/SHA256模式的Promise操作使用为例
*/
import { huks } from '@kit.UniversalKeystoreKit';
let rsaKeyAlias = 'test_rsaKeyAlias';
let handle: number;
let plainText = '123456';
let cipherData: Uint8Array;
function StringToUint8Array(str: String) {
let arr: number[] = new Array();
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
function Uint8ArrayToString(fileData: Uint8Array) {
let dataString = '';
for (let i = 0; i < fileData.length; i++) {
dataString += String.fromCharCode(fileData[i]);
}
return dataString;
}
function GetRsaGenerateProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_RSA
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_RSA_KEY_SIZE_2048
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |
huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
}];
return properties;
}
function GetRsaEncryptProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_RSA
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_RSA_KEY_SIZE_2048
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_OAEP
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_ECB
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256
}];
return properties;
}
function GetRsaDecryptProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_RSA
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_RSA_KEY_SIZE_2048
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_OAEP
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_ECB
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256
}];
return properties;
}
async function GenerateRsaKey() {
/*
* 模拟生成密钥场景
* 1. 确定密钥别名
*/
/*
* 2. 获取生成密钥算法参数配置
*/
let genProperties = GetRsaGenerateProperties();
let options: huks.HuksOptions = {
properties: genProperties
}
/*
* 3. 调用generateKeyItem
*/
await huks.generateKeyItem(rsaKeyAlias, options)
.then((data) => {
console.info(`promise: generate RSA Key success, data = ${JSON.stringify(data)}`);
}).catch((error: Error) => {
console.error(`promise: generate RSA Key failed, ${JSON.stringify(error)}`);
})
}
async function EncryptData() {
/*
* 模拟加密场景
* 1. 获取密钥别名
*/
/*
* 2. 获取待加密的数据
*/
/*
* 3. 获取加密算法参数配置
*/
let encryptProperties = GetRsaEncryptProperties();
let options: huks.HuksOptions = {
properties: encryptProperties,
inData: StringToUint8Array(plainText)
}
/*
* 4. 调用initSession获取handle
*/
await huks.initSession(rsaKeyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((error: Error) => {
console.error(`promise: init EncryptDataRsa failed, ${JSON.stringify(error)}`);
})
/*
* 5. 调用finishSession获取加密后的密文
*/
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: encrypt data success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
cipherData = data.outData as Uint8Array;
}).catch((error: Error) => {
console.error(`promise: encrypt data failed, ${JSON.stringify(error)}`);
})
}
async function DecryptData() {
/*
* 模拟解密场景
* 1. 获取密钥别名
*/
/*
* 2. 获取待解密的密文
*/
/*
* 3. 获取解密算法参数配置
*/
let decryptOptions = GetRsaDecryptProperties()
let options: huks.HuksOptions = {
properties: decryptOptions,
inData: cipherData
}
/*
* 4. 调用initSession获取handle
*/
await huks.initSession(rsaKeyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((error: Error) => {
console.error(`promise: init DecryptDataRsa failed, ${JSON.stringify(error)}`);
})
/*
* 5. 调用finishSession获取解密后的数据
*/
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: decrypt data success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
}).catch((error: Error) => {
console.error(`promise: decrypt data failed, ${JSON.stringify(error)}`);
})
}
async function DeleteKey() {
/*
* 模拟删除密钥场景
* 1. 获取密钥别名
*/
let emptyOptions: huks.HuksOptions = {
properties: []
}
/*
* 2. 调用deleteKeyItem删除密钥
*/
await huks.deleteKeyItem(rsaKeyAlias, emptyOptions)
.then((data) => {
console.info(`promise: delete data success`);
}).catch((error: Error) => {
console.error(`promise: delete data failed, ${JSON.stringify(error)}`);
})
}
```
SM2
```typescript
/*
* 以下以SM2模式的Promise操作使用为例
*/
import { huks } from '@kit.UniversalKeystoreKit';
let sm2KeyAlias = 'test_sm2KeyAlias';
let handle: number;
let plainText = '123456';
let cipherData: Uint8Array;
function StringToUint8Array(str: String) {
let arr: number[] = new Array();
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
function Uint8ArrayToString(fileData: Uint8Array) {
let dataString = '';
for (let i = 0; i < fileData.length; i++) {
dataString += String.fromCharCode(fileData[i]);
}
return dataString;
}
function GetSm2GenerateProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_SM2
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_SM2_KEY_SIZE_256
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |
huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
}];
return properties;
}
function GetSm2EncryptProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_SM2
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_SM2_KEY_SIZE_256
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SM3
}];
return properties;
}
function GetSm2DecryptProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_SM2
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_SM2_KEY_SIZE_256
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SM3
}];
return properties;
}
async function GenerateSm2Key() {
/*
* 模拟生成密钥场景
* 1. 确定密钥别名
*/
/*
* 2. 获取生成密钥算法参数配置
*/
let genProperties = GetSm2GenerateProperties();
let options: huks.HuksOptions = {
properties: genProperties
}
/*
* 3. 调用generateKeyItem
*/
await huks.generateKeyItem(sm2KeyAlias, options)
.then((data) => {
console.info(`promise: generate SM2 Key success, data = ${JSON.stringify(data)}`);
}).catch((error: Error) => {
console.error(`promise: generate SM2 Key failed, ${JSON.stringify(error)}`);
})
}
async function EncryptDataSm2() {
/*
* 模拟加密场景
* 1. 获取密钥别名
*/
/*
* 2. 获取待加密的数据
*/
/*
* 3. 获取加密算法参数配置
*/
let encryptProperties = GetSm2EncryptProperties();
let options: huks.HuksOptions = {
properties: encryptProperties,
inData: StringToUint8Array(plainText)
}
/*
* 4. 调用initSession获取handle
*/
await huks.initSession(sm2KeyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((error: Error) => {
console.error(`promise: init EncryptDataSm2 failed, ${JSON.stringify(error)}`);
})
/*
* 5. 调用finishSession获取加密后的密文
*/
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: encrypt data success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
cipherData = data.outData as Uint8Array;
}).catch((error: Error) => {
console.error(`promise: encrypt data failed, ${JSON.stringify(error)}`);
})
}
async function DecryptDataSm2() {
/*
* 模拟解密场景
* 1. 获取密钥别名
*/
/*
* 2. 获取待解密的密文
*/
/*
* 3. 获取解密算法参数配置
*/
let decryptOptions = GetSm2DecryptProperties()
let options: huks.HuksOptions = {
properties: decryptOptions,
inData: cipherData
}
/*
* 4. 调用initSession获取handle
*/
await huks.initSession(sm2KeyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((error: Error) => {
console.error(`promise: init DecryptDataSm2 failed, ${JSON.stringify(error)}`);
})
/*
* 5. 调用finishSession获取解密后的数据
*/
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: decrypt data success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
}).catch((error: Error) => {
console.error(`promise: decrypt data failed, ${JSON.stringify(error)}`);
})
}
async function DeleteKey() {
/*
* 模拟删除密钥场景
* 1. 获取密钥别名
*/
let emptyOptions: huks.HuksOptions = {
properties: []
}
/*
* 2. 调用deleteKeyItem删除密钥
*/
await huks.deleteKeyItem(sm2KeyAlias, emptyOptions)
.then((data) => {
console.info(`promise: delete data success`);
}).catch((error: Error) => {
console.error(`promise: delete data failed, ${JSON.stringify(error)}`);
})
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-encryption-decryption-ndk-V14
爬取时间: 2025-04-28 02:17:01
来源: Huawei Developer
以AES 256密钥为例，完成加解密。具体的场景介绍及支持的算法规格，请参考密钥生成支持的算法。
在CMake脚本中链接相关动态库
开发步骤
生成密钥
1.  指定密钥别名。
2.  初始化密钥属性集。
3.  调用OH_Huks_GenerateKeyItem生成密钥，具体请参考密钥生成。
除此之外，开发者也可以参考密钥导入，导入已有的密钥。
加密
1.  获取密钥别名。
2.  获取待加密的数据。
3.  调用OH_Huks_InitParamSet指定算法参数配置。 在下方示例中，使用算法AES进行加密时，必须要选择其对应分组模式以及填充模式，用例中选取的分组模式为CBC、填充模式为PKCS7，此时必须要填参数IV。
4.  调用OH_Huks_InitSession初始化密钥会话，并获取会话的句柄handle。
5.  调用OH_Huks_FinishSession结束密钥会话，获取加密后的密文。
解密
1.  获取密钥别名。
2.  获取待解密的密文。
3.  调用OH_Huks_InitParamSet指定算法参数配置。 在下方示例中，使用算法AES进行解密时，必须要选择其对应分组模式以及填充模式，用例中选取的分组模式为CBC、填充模式为PKCS7，此时必须要填参数IV。
4.  调用OH_Huks_InitSession初始化密钥会话，并获取会话的句柄handle。
5.  调用OH_Huks_FinishSession结束密钥会话，获取解密后的数据。
删除密钥
当密钥废弃不用时，需要调用OH_Huks_DeleteKeyItem删除密钥，具体请参考密钥删除。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-signing-signature-verification-V14
爬取时间: 2025-04-28 02:17:14
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-signing-signature-verification-overview-V14
爬取时间: 2025-04-28 02:17:28
来源: Huawei Developer
为实现数据完整性保护和防抵赖，可使用生成/导入的密钥，对数据进行签名验签操作。
支持的算法
以下为密钥签名/验签支持的规格说明。
标准设备规格
| 算法/摘要算法/填充模式 | 备注 | API级别 |
| --- | --- | --- |
| RSA/SHA256/PKCS1_V1_5 RSA/SHA384/PKCS1_V1_5 RSA/SHA512/PKCS1_V1_5 RSA/SHA256/PSS RSA/SHA384/PSS RSA/SHA512/PSS | 对于PSS模式，salt长度支持设置为摘要长度和最大长度（最大长度=密钥长度-摘要长度-2），对应枚举值详见HuksRsaPssSaltLenType。 | 8+ |
| RSA/NoDigest/PKCS1_V1_5 | NoDigest需要指定TAG HuksKeyDigest.HUKS_DIGEST_NONE。由业务对明文做哈希，再将哈希后的数据传入，哈希后的数据长度必须满足RSA签名验签支持的摘要算法规格。 | 9+ |
| ECC/SHA256 ECC/SHA384 ECC/SHA512 | ECC算法支持的椭圆曲线函数包括：P-256、P-384、P-521 | 8+ |
| ED25519/NoDigest | NoDigest需要指定TAG HuksKeyDigest.HUKS_DIGEST_NONE。 | 8+ |
| SM2/SM3 | - | 9+ |
RSA/SHA256/PKCS1_V1_5
RSA/SHA384/PKCS1_V1_5
RSA/SHA512/PKCS1_V1_5
RSA/SHA256/PSS
RSA/SHA384/PSS
RSA/SHA512/PSS
ECC/SHA256
ECC/SHA384
ECC/SHA512
轻设备设备规格
| 算法/摘要算法/填充模式 | 备注 | API级别 |
| --- | --- | --- |
| RSA/SHA256/PKCS1_V1_5 | - | 12+ |
| RSA/SHA256/PSS | - | 12+ |
| RSA/SHA1/ISO_IEC_9796_2 | 数据最小长度=密钥长度-21字节 | 12+ |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-signing-signature-verification-dev-V14
爬取时间: 2025-04-28 02:17:42
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-signing-signature-verification-arkts-V14
爬取时间: 2025-04-28 02:17:56
来源: Huawei Developer
当前指导共提供四种示例，供开发者参考完成签名、验签开发：
具体的场景介绍及支持的算法规格，请参考签名/验签支持的算法。
开发步骤
生成密钥
1.  指定密钥别名。
2.  初始化密钥属性集。
3.  调用generateKeyItem生成密钥，具体请参考密钥生成。
除此之外，开发者也可以参考密钥导入，导入已有的密钥。
签名
1.  获取密钥别名。
2.  指定待签名的明文数据。
3.  获取属性参数HuksOptions，包括两个字段properties和inData。 inData传入明文数据，properties传入算法参数配置。
4.  调用initSession初始化密钥会话，并获取会话的句柄handle。
5.  调用finishSession结束密钥会话，获取签名signature。
验签
1.  获取密钥别名。
2.  获取待验证的签名signature。
3.  获取属性参数HuksOptions，包括两个字段properties和inData。 inData传入签名signature，properties传入算法参数配置。
4.  调用initSession初始化密钥会话，并获取会话的句柄handle。
5.  调用updateSession更新密钥会话。
6.  调用finishSession结束密钥会话，验证签名。
删除密钥
当密钥废弃不用时，需要调用deleteKeyItem删除密钥，具体请参考密钥删除。
开发案例
ECC256/SHA256
```typescript
/*
* 密钥算法为ECC256、摘要算法为SHA256
*/
import { huks } from '@kit.UniversalKeystoreKit';
let keyAlias = 'test_eccKeyAlias';
let handle: number;
let plaintext = '123456';
let signature: Uint8Array;
function StringToUint8Array(str: String) {
let arr: number[] = new Array();
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
function Uint8ArrayToString(fileData: Uint8Array) {
let dataString = '';
for (let i = 0; i < fileData.length; i++) {
dataString += String.fromCharCode(fileData[i]);
}
return dataString;
}
function GetEccGenerateProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_ECC
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_SIGN |
huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_VERIFY
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256
}];
return properties;
}
function GetEccSignProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_ECC
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_SIGN
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256
}];
return properties;
}
function GetEccVerifyProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_ECC
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_VERIFY
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256
}];
return properties;
}
async function GenerateEccKey(keyAlias: string) {
let genProperties = GetEccGenerateProperties();
let options: huks.HuksOptions = {
properties: genProperties
}
await huks.generateKeyItem(keyAlias, options)
.then((data) => {
console.info(`promise: generate ECC Key success, data = ${JSON.stringify(data)}`);
}).catch((err: Error) => {
console.error(`promise: generate ECC Key failed, error: ` + JSON.stringify(err));
})
}
async function Sign(keyAlias: string, plaintext: string) {
let signProperties = GetEccSignProperties();
let options: huks.HuksOptions = {
properties: signProperties,
inData: StringToUint8Array(plaintext)
}
await huks.initSession(keyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((err: Error) => {
console.error(`promise: init sign failed, error: ` + JSON.stringify(err));
})
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: sign success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
signature = data.outData as Uint8Array;
}).catch((err: Error) => {
console.error(`promise: sign failed, error: ` + JSON.stringify(err));
})
}
async function Verify(keyAlias: string, plaintext: string, signature: Uint8Array) {
let verifyProperties = GetEccVerifyProperties()
let options: huks.HuksOptions = {
properties: verifyProperties,
inData: StringToUint8Array(plaintext)
}
await huks.initSession(keyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((err: Error) => {
console.error(`promise: init verify failed, error: ` + JSON.stringify(err));
})
await huks.updateSession(handle, options)
.then((data) => {
console.info(`promise: update verify success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
}).catch((err: Error) => {
console.error(`promise: update verify failed, error: ` + JSON.stringify(err));
})
options.inData = signature;
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: verify success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
}).catch((err: Error) => {
console.error(`promise: verify failed, error: ` + JSON.stringify(err));
})
}
async function DeleteEccKey(keyAlias: string) {
let emptyOptions: huks.HuksOptions = {
properties: []
}
await huks.deleteKeyItem(keyAlias, emptyOptions)
.then((data) => {
console.info(`promise: delete data success`);
}).catch((err: Error) => {
console.error(`promise: delete data failed`);
})
}
async function testSignVerify() {
await GenerateEccKey(keyAlias);
await Sign(keyAlias, plaintext);
await Verify(keyAlias, plaintext, signature);
await DeleteEccKey(keyAlias);
}
```
SM2/SM3
```typescript
/*
* 密钥算法为SM2、摘要算法为SM3
*/
import { huks } from '@kit.UniversalKeystoreKit';
let keyAlias = 'test_sm2KeyAlias';
let handle: number;
let plaintext = '123456';
let signature: Uint8Array;
function StringToUint8Array(str: String) {
let arr: number[] = new Array();
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
function Uint8ArrayToString(fileData: Uint8Array) {
let dataString = '';
for (let i = 0; i < fileData.length; i++) {
dataString += String.fromCharCode(fileData[i]);
}
return dataString;
}
function GetSm2GenerateProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_SM2
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_SIGN |
huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_VERIFY
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SM3
}];
return properties;
}
function GetSm2SignProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_SM2
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_SIGN
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SM3
}];
return properties;
}
function GetSm2VerifyProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_SM2
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_VERIFY
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SM3
}];
return properties;
}
async function GenerateSm2Key(keyAlias: string) {
let genProperties = GetSm2GenerateProperties();
let options: huks.HuksOptions = {
properties: genProperties
}
await huks.generateKeyItem(keyAlias, options)
.then((data) => {
console.info(`promise: generate Sm2 Key success, data = ${JSON.stringify(data)}`);
}).catch((err: Error) => {
console.error(`promise: generate Sm2 Key failed, error: ` + JSON.stringify(err));
})
}
async function Sign(keyAlias: string, plaintext: string) {
let signProperties = GetSm2SignProperties();
let options: huks.HuksOptions = {
properties: signProperties,
inData: StringToUint8Array(plaintext)
}
await huks.initSession(keyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((err: Error) => {
console.error(`promise: init sign failed, error: ` + JSON.stringify(err));
})
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: sign success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
signature = data.outData as Uint8Array;
}).catch((err: Error) => {
console.error(`promise: sign failed, error: ` + JSON.stringify(err));
})
}
async function Verify(keyAlias: string, plaintext: string, signature: Uint8Array) {
let verifyProperties = GetSm2VerifyProperties()
let options: huks.HuksOptions = {
properties: verifyProperties,
inData: StringToUint8Array(plaintext)
}
await huks.initSession(keyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((err: Error) => {
console.error(`promise: init verify failed, error: ` + JSON.stringify(err));
})
await huks.updateSession(handle, options)
.then((data) => {
console.info(`promise: update verify success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
}).catch((err: Error) => {
console.error(`promise: update verify failed, error: ` + JSON.stringify(err));
})
options.inData = signature;
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: verify success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
}).catch((err: Error) => {
console.error(`promise: verify failed, error: ` + JSON.stringify(err));
})
}
async function DeleteSm2Key(keyAlias: string) {
let emptyOptions: huks.HuksOptions = {
properties: []
}
await huks.deleteKeyItem(keyAlias, emptyOptions)
.then((data) => {
console.info(`promise: delete data success`);
}).catch((err: Error) => {
console.error(`promise: delete data failed`);
})
}
export async function testSignVerify() {
await GenerateSm2Key(keyAlias);
await Sign(keyAlias, plaintext);
await Verify(keyAlias, plaintext, signature);
await DeleteSm2Key(keyAlias);
}
```
RSA/SHA256/PSS
```typescript
/*
* 密钥算法为RSA，摘要算法为SHA256，填充模式为PSS
*/
import { huks } from '@kit.UniversalKeystoreKit';
let keyAlias = 'test_rsaKeyAlias';
let handle: number;
let plaintext = '123456';
let signature: Uint8Array;
function StringToUint8Array(str: string) {
let arr: number[] = [];
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
function Uint8ArrayToString(fileData: Uint8Array) {
let dataString = '';
for (let i = 0; i < fileData.length; i++) {
dataString += String.fromCharCode(fileData[i]);
}
return dataString;
}
function GetRsaGenerateProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_RSA
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_RSA_KEY_SIZE_2048
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_SIGN |
huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_VERIFY
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_PSS
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256
}];
return properties;
}
function GetRsaSignProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_RSA
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_PSS
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_SIGN
}];
return properties;
}
function GetRsaVerifyProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_RSA
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_PSS
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_VERIFY
}];
return properties;
}
async function GenerateRsaKey(keyAlias: string) {
let genProperties = GetRsaGenerateProperties();
let options: huks.HuksOptions = {
properties: genProperties
};
await huks.generateKeyItem(keyAlias, options)
.then((data) => {
console.info(`promise: generate RSA Key success, data = ${JSON.stringify(data)}`);
}).catch((err: Error) => {
console.error(`promise: generate RSA Key failed, error: ` + JSON.stringify(err));
});
}
async function Sign(keyAlias: string, plaintext: string) {
let signProperties = GetRsaSignProperties();
let options: huks.HuksOptions = {
properties: signProperties,
inData: StringToUint8Array(plaintext)
}
await huks.initSession(keyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((err: Error) => {
console.error(`promise: init sign failed, error: ` + JSON.stringify(err));
return;
});
if (handle !== undefined) {
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: sign success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
signature = data.outData as Uint8Array;
}).catch((err: Error) => {
console.error(`promise: sign failed, error: ` + JSON.stringify(err));
});
}
}
async function Verify(keyAlias: string, plaintext: string, signature: Uint8Array) {
let verifyProperties = GetRsaVerifyProperties();
let options: huks.HuksOptions = {
properties: verifyProperties,
inData: StringToUint8Array(plaintext)
}
await huks.initSession(keyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((err: Error) => {
console.error(`promise: init verify failed, error: ` + JSON.stringify(err));
return;
});
if (handle !== undefined) {
await huks.updateSession(handle, options)
.then((data) => {
console.info(`promise: update verify success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
}).catch((err: Error) => {
console.error(`promise: update verify failed, error: ` + JSON.stringify(err));
});
options.inData = signature;
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: verify success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
}).catch((err: Error) => {
console.error(`promise: verify failed, error: ` + JSON.stringify(err));
});
}
}
async function DeleteRsaKey(keyAlias: string) {
let emptyOptions: huks.HuksOptions = {
properties: []
}
await huks.deleteKeyItem(keyAlias, emptyOptions)
.then((data) => {
console.info(`promise: delete data success`);
}).catch((err: Error) => {
console.error(`promise: delete data failed`);
});
}
export async function testSignVerify() {
await GenerateRsaKey(keyAlias);
await Sign(keyAlias, plaintext);
await Verify(keyAlias, plaintext, signature);
await DeleteRsaKey(keyAlias);
}
```
RSA/SHA256/PKCS1_V1_5
```typescript
/*
* 密钥算法为RSA，摘要算法为SHA256，填充模式为PKCS1_V1_5
*/
import { huks } from '@kit.UniversalKeystoreKit';
let keyAlias = 'test_rsaKeyAlias';
let handle: number;
let plaintext = '123456';
let signature: Uint8Array;
function StringToUint8Array(str: String) {
let arr: number[] = new Array();
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
function Uint8ArrayToString(fileData: Uint8Array) {
let dataString = '';
for (let i = 0; i < fileData.length; i++) {
dataString += String.fromCharCode(fileData[i]);
}
return dataString;
}
function GetRsaGenerateProperties() {
let properties: Array<huks.HuksParam> = [
{ tag: huks.HuksTag.HUKS_TAG_ALGORITHM, value: huks.HuksKeyAlg.HUKS_ALG_RSA },
{ tag: huks.HuksTag.HUKS_TAG_KEY_SIZE, value: huks.HuksKeySize.HUKS_RSA_KEY_SIZE_2048 },
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_SIGN | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_VERIFY
},
{ tag: huks.HuksTag.HUKS_TAG_PADDING, value: huks.HuksKeyPadding.HUKS_PADDING_PKCS1_V1_5 },
{ tag: huks.HuksTag.HUKS_TAG_DIGEST, value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256 }
];
return properties;
}
function GetRsaSignProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_RSA
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_RSA_KEY_SIZE_2048
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_SIGN
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_PKCS1_V1_5
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256
}];
return properties;
}
function GetRsaVerifyProperties() {
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_RSA
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_RSA_KEY_SIZE_2048
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_VERIFY
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_PKCS1_V1_5
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256
}];
return properties;
}
async function GenerateRsaKey(keyAlias: string) {
let genProperties = GetRsaGenerateProperties();
let options: huks.HuksOptions = {
properties: genProperties
}
await huks.generateKeyItem(keyAlias, options)
.then((data) => {
console.info(`promise: generate RSA Key success, data = ${JSON.stringify(data)}`);
}).catch((err: Error) => {
console.error(`promise: generate RSA Key failed, error: ` + JSON.stringify(err));
})
}
async function Sign(keyAlias: string, plaintext: string) {
let signProperties = GetRsaSignProperties();
let options: huks.HuksOptions = {
properties: signProperties,
inData: StringToUint8Array(plaintext)
}
await huks.initSession(keyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((err: Error) => {
console.error(`promise: init sign failed, error: ` + JSON.stringify(err));
})
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: sign success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
signature = data.outData as Uint8Array;
}).catch((err: Error) => {
console.error(`promise: sign failed, error: ` + JSON.stringify(err));
})
}
async function Verify(keyAlias: string, plaintext: string, signature: Uint8Array) {
let verifyProperties = GetRsaVerifyProperties()
let options: huks.HuksOptions = {
properties: verifyProperties,
inData: StringToUint8Array(plaintext)
}
await huks.initSession(keyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((err: Error) => {
console.error(`promise: init verify failed, error: ` + JSON.stringify(err));
})
await huks.updateSession(handle, options)
.then((data) => {
console.info(`promise: update verify success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
}).catch((err: Error) => {
console.error(`promise: update verify failed, error: ` + JSON.stringify(err));
})
options.inData = signature;
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: verify success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
}).catch((err: Error) => {
console.error(`promise: verify failed, error: ` + JSON.stringify(err));
})
}
async function DeleteRsaKey(keyAlias: string) {
let emptyOptions: huks.HuksOptions = {
properties: []
}
await huks.deleteKeyItem(keyAlias, emptyOptions)
.then((data) => {
console.info(`promise: delete data success`);
}).catch((err: Error) => {
console.error(`promise: delete data failed`);
})
}
export async function testSignVerify() {
await GenerateRsaKey(keyAlias);
await Sign(keyAlias, plaintext);
await Verify(keyAlias, plaintext, signature);
await DeleteRsaKey(keyAlias);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-signing-signature-verification-ndk-V14
爬取时间: 2025-04-28 02:18:09
来源: Huawei Developer
以密钥算法为RSA2048、摘要算法为SHA384、填充模式为PSS的密钥为例，完成签名、验签。具体的场景介绍及支持的算法规格，请参考签名/验签支持的算法。
在CMake脚本中链接相关动态库
开发步骤
生成密钥
1.  指定密钥别名。
2.  初始化密钥属性集。
3.  调用OH_Huks_GenerateKeyItem生成密钥，具体请参考密钥生成。
除此之外，开发者也可以参考密钥导入，导入已有的密钥。
签名
1.  获取密钥别名。
2.  指定待签名的明文数据。
3.  调用OH_Huks_InitParamSet指定算法参数配置。
4.  调用OH_Huks_InitSession初始化密钥会话，并获取会话的句柄handle。
5.  调用OH_Huks_FinishSession结束密钥会话，获取签名signature。
验签
1.  获取密钥别名。
2.  获取待验证的签名signature。
3.  指定算法参数配置。
4.  调用OH_Huks_InitSession初始化密钥会话，并获取会话的句柄handle。
5.  调用OH_Huks_UpdateSession更新密钥会话。
6.  调用OH_Huks_FinishSession结束密钥会话，验证签名。
删除密钥
当密钥废弃不用时，需要调用OH_Huks_DeleteKeyItem删除密钥，具体请参考密钥删除。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-agreement-V14
爬取时间: 2025-04-28 02:18:23
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-agreement-overview-V14
爬取时间: 2025-04-28 02:18:37
来源: Huawei Developer
为了避免恶意第三方获取到保密信息，密钥本身是不可以直接在设备间传输的。一般情况下，会采取密钥协商的方式，安全地在双方（或多方）间共享密钥。密钥协商只会传输密钥的公钥部分，私钥仍存留在设备内，以保护数据的安全性和机密性。
两台设备间进行密钥协商，双方各准备一个非对称密钥，并互换非对称密钥的公钥，以对端公钥与己端私钥协商出一个密钥，该密钥在两台设备相同。
轻量级设备不支持密钥协商功能。
支持的算法
以下为密钥协商支持的规格说明。
| 算法 | 备注 | API级别 |
| --- | --- | --- |
| ECDH | 协商密钥类型为ECC类型密钥 | 8+ |
| DH | - | 8+ |
| X25519 | - | 8+ |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-agreement-dev-V14
爬取时间: 2025-04-28 02:18:50
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-agreement-arkts-V14
爬取时间: 2025-04-28 02:19:44
来源: Huawei Developer
以协商密钥类型为X25519，并密钥仅在HUKS内使用为例，完成密钥协商。具体的场景介绍及支持的算法规格，请参考密钥生成支持的算法。
开发步骤
生成密钥
设备A、设备B各自生成一个非对称密钥，具体请参考密钥生成或密钥导入。
密钥生成时，可指定参数HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识基于该密钥协商出的密钥是否由HUKS管理。
-  当TAG设置为HUKS_STORAGE_ONLY_USED_IN_HUKS时，表示基于该密钥协商出的密钥，由HUKS管理，可保证协商密钥全生命周期不出安全环境。
-  当TAG设置为HUKS_STORAGE_KEY_EXPORT_ALLOWED时，表示基于该密钥协商出的密钥，返回给调用方管理，由业务自行保证密钥安全。
-  若业务未设置TAG的具体值，表示基于该密钥协商出的密钥，可由HUKS管理，也可返回给调用方管理，业务可在后续协商时再选择使用何种方式保护密钥。
导出密钥
设备A、B导出非对称密钥对的公钥材料，具体请参考密钥导出。
密钥协商
设备A、B分别基于本端私钥和对端设备的公钥，协商出共享密钥。
密钥协商时，可指定参数HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识协商得到的密钥是否由HUKS管理。
| 生成 | 协商 | 规格 |
| --- | --- | --- |
| HUKS_STORAGE_ONLY_USED_IN_HUKS | HUKS_STORAGE_ONLY_USED_IN_HUKS | 密钥由HUKS管理 |
| HUKS_STORAGE_KEY_EXPORT_ALLOWED | HUKS_STORAGE_KEY_EXPORT_ALLOWED | 密钥返回给调用方管理 |
| 未指定TAG具体值 | HUKS_STORAGE_ONLY_USED_IN_HUKS | 密钥由HUKS管理 |
| 未指定TAG具体值 | HUKS_STORAGE_KEY_EXPORT_ALLOWED | 密钥返回给调用方管理 |
| 未指定TAG具体值 | 未指定TAG具体值 | 密钥返回给调用方管理 |
注：协商时指定的TAG值，不可与生成时指定的TAG值冲突。表格中仅列举有效的指定方式。
删除密钥
当密钥废弃不用时，设备A、B均需要删除密钥，具体请参考密钥删除。
下面分别以X25519 与 DH密钥为例，进行协商。
-  X25519非对称密钥协商用例
```typescript
/*
*以下以X25519密钥的Promise操作使用为例
*/
import { huks } from '@kit.UniversalKeystoreKit';
/*
* 确定密钥别名和封装密钥属性参数集
*/
let srcKeyAliasFirst = "AgreeX25519KeyFirstAlias";
let srcKeyAliasSecond = "AgreeX25519KeySecondAlias";
let agreeX25519InData = 'AgreeX25519TestIndata';
let finishOutData: Uint8Array;
let handle: number;
let exportKey: Uint8Array;
let exportKeyFirst: Uint8Array;
let exportKeySecond: Uint8Array;
/* 集成生成密钥参数集 */
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_X25519,
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_AGREE,
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_CURVE25519_KEY_SIZE_256,
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_NONE,
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE,
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_CBC,
}, {
tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,
value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,
}];
let HuksOptions: huks.HuksOptions = {
properties: properties,
inData: new Uint8Array(new Array())
}
/* 集成第一个协商参数集 */
const finishProperties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,
value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,
}, {
tag: huks.HuksTag.HUKS_TAG_IS_KEY_ALIAS,
value: true
}, {
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES,
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256,
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value:
huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |
huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT,
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_NONE,
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE,
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_ECB,
}];
let finishOptionsFirst: huks.HuksOptions = {
properties: [
...finishProperties, {
tag: huks.HuksTag.HUKS_TAG_KEY_ALIAS,
value: StringToUint8Array(srcKeyAliasFirst + 'final'),
}],
inData: StringToUint8Array(agreeX25519InData)
}
/* 集成第二个协商参数集 */
let finishOptionsSecond: huks.HuksOptions = {
properties: [
...finishProperties, {
tag: huks.HuksTag.HUKS_TAG_KEY_ALIAS,
value: StringToUint8Array(srcKeyAliasSecond + 'final'),
}],
inData: StringToUint8Array(agreeX25519InData)
}
function StringToUint8Array(str: string) {
let arr: number[] = new Array();
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
class throwObject {
isThrow: boolean = false
}
/* 生成密钥 */
function generateKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<void>((resolve, reject) => {
try {
huks.generateKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
/* 调用generateKeyItem生成密钥 */
async function publicGenKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise generateKeyItem`);
let throwObject: throwObject = { isThrow: false };
try {
await generateKeyItem(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: generateKeyItem success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: generateKeyItem failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: generateKeyItem input arg invalid, ${JSON.stringify(error)}`);
}
}
/*初始化密钥会话接口，并获取一个句柄（必选）和挑战值（可选）*/
function initSession(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<huks.HuksSessionHandle>((resolve, reject) => {
try {
huks.initSession(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
/*调用initSession获取handle*/
async function publicInitFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise doInit`);
let throwObject: throwObject = { isThrow: false };
try {
await initSession(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);
handle = data.handle;
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doInit failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: doInit input arg invalid, ${JSON.stringify(error)}`);
}
}
/* 分段添加密钥操作的数据并进行相应的密钥操作，输出处理数据 */
function updateSession(handle: number, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<huks.HuksReturnResult>((resolve, reject) => {
try {
huks.updateSession(handle, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
/* 调用updateSession进行协商操作 */
async function publicUpdateFunc(handle: number, huksOptions: huks.HuksOptions) {
console.info(`enter promise doUpdate`);
let throwObject: throwObject = { isThrow: false };
try {
await updateSession(handle, huksOptions, throwObject)
.then((data) => {
console.info(`promise: doUpdate success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doUpdate failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: doUpdate input arg invalid, ${JSON.stringify(error)}`);
}
}
/* 结束密钥会话并进行相应的密钥操作，输出处理数据 */
function finishSession(handle: number, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<huks.HuksReturnResult>((resolve, reject) => {
try {
huks.finishSession(handle, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
/* 调用finishSession结束操作 */
async function publicFinishFunc(handle: number, huksOptions: huks.HuksOptions) {
console.info(`enter promise doFinish`);
let throwObject: throwObject = { isThrow: false };
try {
await finishSession(handle, huksOptions, throwObject)
.then((data) => {
finishOutData = data.outData as Uint8Array;
console.info(`promise: doFinish success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doFinish failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: doFinish input arg invalid, ${JSON.stringify(error)}`);
}
}
/* 导出密钥 */
function exportKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<huks.HuksReturnResult>((resolve, reject) => {
try {
huks.exportKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
/* 调用exportKeyItem导出公钥操作 */
async function publicExportKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise export`);
let throwObject: throwObject = { isThrow: false };
try {
await exportKeyItem(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: exportKeyItem success, data = ${JSON.stringify(data)}`);
exportKey = data.outData as Uint8Array;
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: exportKeyItem failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: exportKeyItem input arg invalid, ${JSON.stringify(error)}`);
}
}
/* 删除密钥操作 */
function deleteKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<void>((resolve, reject) => {
try {
huks.deleteKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
/* 调用deleteKeyItem删除密钥操作 */
async function publicDeleteKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise deleteKeyItem`);
let throwObject: throwObject = { isThrow: false };
try {
await deleteKeyItem(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: deleteKeyItem key success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: deleteKeyItem failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: deleteKeyItem input arg invalid, ${JSON.stringify(error)}`);
}
}
async function testAgree() {
/* 1.确定密钥别名并集成并集成要参数集 A设备：srcKeyAliasFirst  B设备：srcKeyAliasSecond*/
/* 2.设备A生成密钥 */
await publicGenKeyFunc(srcKeyAliasFirst, HuksOptions);
/* 3.设备B生成密钥 */
await publicGenKeyFunc(srcKeyAliasSecond, HuksOptions);
/* 4.设备A、B导出非对称密钥的公钥 */
await publicExportKeyFunc(srcKeyAliasFirst, HuksOptions);
exportKeyFirst = exportKey;
await publicExportKeyFunc(srcKeyAliasSecond, HuksOptions);
exportKeySecond = exportKey;
/* 5.对第一个密钥进行协商（三段式）*/
await publicInitFunc(srcKeyAliasFirst, HuksOptions);
HuksOptions.inData = exportKeySecond;
await publicUpdateFunc(handle, HuksOptions);
await publicFinishFunc(handle, finishOptionsFirst);
/* 5.对第二个密钥进行协商（三段式） */
await publicInitFunc(srcKeyAliasSecond, HuksOptions);
HuksOptions.inData = exportKeyFirst;
await publicUpdateFunc(handle, HuksOptions);
await publicFinishFunc(handle, finishOptionsSecond);
/* 6.设备A、B删除密钥 */
await publicDeleteKeyFunc(srcKeyAliasFirst, HuksOptions);
await publicDeleteKeyFunc(srcKeyAliasSecond, HuksOptions);
}
```
-  DH密钥协商用例
```typescript
/*
*以下以 DH密钥的Promise操作使用为例
*/
import { huks } from '@kit.UniversalKeystoreKit'
function StringToUint8Array(str: string) {
let arr: number[] = []
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i))
}
return new Uint8Array(arr)
}
function Uint8ArrayToBigInt(arr: Uint8Array): bigint {
let i = 0
const byteMax: bigint = BigInt('0x100')
let result: bigint = BigInt('0')
while (i < arr.length) {
result = result * byteMax
result = result + BigInt(arr[i])
i += 1
}
return result
}
const dhAgree: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_DH,
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_AGREE,
}]
const dh2048Agree: Array<huks.HuksParam> = [
...dhAgree, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_DH_KEY_SIZE_2048,
}]
const dhGenOptions: huks.HuksOptions = {
properties: dh2048Agree,
inData: new Uint8Array([])
}
const emptyOptions: huks.HuksOptions = {
properties: [],
inData: new Uint8Array([])
}
async function HuksDhAgreeExportKey(keyAlias: string,
peerPubKey: huks.HuksReturnResult): Promise<huks.HuksReturnResult> {
const initHandle = await huks.initSession(keyAlias, dhGenOptions)
const dhAgreeUpdateBobPubKey: huks.HuksOptions = {
properties: [
...dh2048Agree, {
tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,
value: huks.HuksKeyStorageType.HUKS_STORAGE_KEY_EXPORT_ALLOWED,
}],
inData: peerPubKey.outData
}
await huks.updateSession(initHandle.handle, dhAgreeUpdateBobPubKey)
return await huks.finishSession(initHandle.handle, emptyOptions)
}
async function HuksDhAgreeExportTest(
aliasA: string, aliasB: string,
pubKeyA: huks.HuksReturnResult, pubKeyB: huks.HuksReturnResult) {
const agreedKeyFromAlice = await HuksDhAgreeExportKey(aliasA, pubKeyB)
console.info(`ok! agreedKeyFromAlice export is 0x${Uint8ArrayToBigInt(agreedKeyFromAlice.outData).toString(16)}`)
const agreedKeyFromBob = await HuksDhAgreeExportKey(aliasB, pubKeyA)
console.info(`ok! agreedKeyFromBob export is 0x${Uint8ArrayToBigInt(agreedKeyFromBob.outData).toString(16)}`)
}
async function HuksDhAgreeInHuks(keyAlias: string, peerPubKey: huks.HuksReturnResult,
aliasAgreedKey: string): Promise<huks.HuksReturnResult> {
const onlyUsedInHuks: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_KEY_STORAGE_FLAG,
value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,
}, {
tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,
value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,
}]
const dhAgreeInit: huks.HuksOptions = {
properties: [
...dhAgree,
{ tag: huks.HuksTag.HUKS_TAG_KEY_SIZE, value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256, },
...onlyUsedInHuks],
inData: new Uint8Array([])
}
const dhAgreeFinishParams: Array<huks.HuksParam> = [
...onlyUsedInHuks,
{ tag: huks.HuksTag.HUKS_TAG_IS_KEY_ALIAS, value: true },
{ tag: huks.HuksTag.HUKS_TAG_ALGORITHM, value: huks.HuksKeyAlg.HUKS_ALG_AES },
{ tag: huks.HuksTag.HUKS_TAG_KEY_SIZE, value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256 },
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
}]
const handle = await huks.initSession(keyAlias, dhAgreeInit)
const dhAgreeUpdatePubKey: huks.HuksOptions = {
properties: [...dhAgree, ...onlyUsedInHuks],
inData: peerPubKey.outData
}
await huks.updateSession(handle.handle, dhAgreeUpdatePubKey)
const dhAgreeAliceFinnish: huks.HuksOptions = {
properties: [...dhAgreeFinishParams, {
tag: huks.HuksTag.HUKS_TAG_KEY_ALIAS, value: StringToUint8Array(aliasAgreedKey)
}], inData: new Uint8Array([])
}
return await huks.finishSession(handle.handle, dhAgreeAliceFinnish)
}
async function HuksDhAgreeInHuksTest(
aliasA: string, aliasB: string,
pubKeyA: huks.HuksReturnResult, pubKeyB: huks.HuksReturnResult,
aliasAgreedKeyFromA: string, aliasAgreedKeyFromB: string) {
const finishAliceResult = await HuksDhAgreeInHuks(aliasA, pubKeyB, aliasAgreedKeyFromA)
console.info(`ok! finishAliceResult in huks is 0x${Uint8ArrayToBigInt(finishAliceResult.outData).toString(16)}`)
const aliceAgreedExist = await huks.isKeyItemExist(aliasAgreedKeyFromA, emptyOptions)
console.info(`ok! aliceAgreedExist in huks is ${aliceAgreedExist}`)
const finishBobResult = await HuksDhAgreeInHuks(aliasB, pubKeyA, aliasAgreedKeyFromB)
console.info(`ok! finishBobResult in huks is 0x${Uint8ArrayToBigInt(finishBobResult.outData).toString(16)}`)
const bobAgreedExist = await huks.isKeyItemExist(aliasAgreedKeyFromB, emptyOptions)
console.info(`ok! bobAgreedExist in huks is ${bobAgreedExist}`)
await huks.deleteKeyItem(aliasAgreedKeyFromA, emptyOptions)
await huks.deleteKeyItem(aliasAgreedKeyFromB, emptyOptions)
}
export default async function HuksDhAgreeTest() {
const aliasAlice = 'alice'
const aliasBob = 'bob'
/* 调用generateKeyItem生成别名为alice与bob的两个密钥 */
await huks.generateKeyItem(aliasAlice, dhGenOptions)
await huks.generateKeyItem(aliasBob, dhGenOptions)
/* 导出非对称密钥alice与bob的的公钥 */
const pubKeyAlice = await huks.exportKeyItem(aliasAlice, emptyOptions)
const pubKeyBob = await huks.exportKeyItem(aliasBob, emptyOptions)
/* 开始协商，协商生成的密钥返回给业务管理 */
await HuksDhAgreeExportTest(aliasAlice, aliasBob, pubKeyAlice, pubKeyBob)
/* 开始协商，协商生成的密钥由HUKS管理 */
await HuksDhAgreeInHuksTest(aliasAlice, aliasBob, pubKeyAlice, pubKeyBob, 'agreedKeyFromAlice', 'agreedKeyFromBob')
await huks.deleteKeyItem(aliasAlice, emptyOptions)
await huks.deleteKeyItem(aliasBob, emptyOptions)
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-agreement-ndk-V14
爬取时间: 2025-04-28 02:19:57
来源: Huawei Developer
以协商密钥类型为ECDH，并密钥仅在HUKS内使用为例，完成密钥协商。具体的场景介绍及支持的算法规格，请参考密钥生成支持的算法。
在CMake脚本中链接相关动态库
开发步骤
生成密钥
设备A、设备B各自生成一个非对称密钥，具体请参考密钥生成或密钥导入。
密钥生成时，可指定参数，OH_HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识此步骤生成的密钥是否由HUKS管理。
导出密钥
设备A、B导出非对称密钥对的公钥材料，具体请参考密钥导出。
密钥协商
设备A、B分别基于本端私钥和对端设备的公钥，协商出共享密钥。
密钥协商时，可指定参数OH_HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识协商得到的密钥是否由HUKS管理。
-  当TAG设置为OH_HUKS_STORAGE_ONLY_USED_IN_HUKS时，表示基于该密钥协商出的密钥，由HUKS管理，可保证协商密钥全生命周期不出安全环境。
-  当TAG设置为OH_HUKS_STORAGE_KEY_EXPORT_ALLOWED时，表示基于该密钥协商出的密钥，返回给调用方管理，由业务自行保证密钥安全。
-  若业务未设置TAG的具体值，表示基于该密钥协商出的密钥，既可由HUKS管理，也可返回给调用方管理，业务可在后续协商时再选择使用何种方式保护密钥。
| 生成 | 协商 | 规格 |
| --- | --- | --- |
| OH_HUKS_STORAGE_ONLY_USED_IN_HUKS | OH_HUKS_STORAGE_ONLY_USED_IN_HUKS | 密钥由HUKS管理 |
| OH_HUKS_STORAGE_KEY_EXPORT_ALLOWED | OH_HUKS_STORAGE_KEY_EXPORT_ALLOWED | 密钥返回给调用方管理 |
| 未指定TAG具体值 | OH_HUKS_STORAGE_ONLY_USED_IN_HUKS | 密钥由HUKS管理 |
| 未指定TAG具体值 | OH_HUKS_STORAGE_KEY_EXPORT_ALLOWED | 密钥返回给调用方管理 |
| 未指定TAG具体值 | 未指定TAG具体值 | 密钥返回给调用方管理 |
注：协商时指定的TAG值，不可与生成时指定的TAG值冲突。表格中仅列举有效的指定方式。
删除密钥
当密钥废弃不用时，设备A、B均需要删除密钥，具体请参考密钥删除。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-derivation-V14
爬取时间: 2025-04-28 02:20:15
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-derivation-overview-V14
爬取时间: 2025-04-28 02:20:28
来源: Huawei Developer
在密码学中，密钥派生函数（Key derivation function，KDF）使用伪随机函数从诸如主密码或密码的秘密值中派生出一个或多个密钥。
支持的算法
以下为密钥派生支持的规格说明。
派生密钥是业务基于三段式得到密钥会话结果，业务可决定派生密钥是否由HUKS管理（即密钥不出TEE）亦或是业务独立管理。
PBKDF2/HKDF仅支持HUKS托管密钥的派生，不支持直接基于非HUKS托管的密钥进行派生，如：用户的口令。密钥托管参考密钥导入。
| 算法/摘要 | 派生密钥的算法/长度 | 派生结果密钥可用算法/长度 | API级别 |
| --- | --- | --- | --- |
| HKDF/SHA256 | AES/192-256 | AES/128/192/256 HMAC/8-1024 SM4/128  | 8+ |
| HKDF/SHA384 | AES/256 | AES/128/192/256 HMAC/8-1024 SM4/128  | 8+ |
| HKDF/SHA512 | AES/256 | AES/128/192/256 HMAC/8-1024 SM4/128  | 8+ |
| PBKDF2/SHA256 | AES/192-256 | AES/128/192/256 HMAC/8-1024 SM4/128  | 8+ |
| PBKDF2/SHA384 | AES/256 | AES/128/192/256 HMAC/8-1024 SM4/128  | 8+ |
| PBKDF2/SHA512 | AES/256 | AES/128/192/256 HMAC/8-1024 SM4/128  | 8+ |
| HMAC/SHA256 | AES/192-256 | AES/256 HMAC/256  | 12+ |
| HMAC/SHA384 | AES/256 | HMAC/384 | 12+ |
| HMAC/SHA512 | AES/256 | HMAC/512 | 12+ |
| HKDF/SHA256 | X25519/256 | X25519/256 | 12+ |
| HKDF/SHA384 | X25519/256 | X25519/256 | 12+ |
| HKDF/SHA512 | X25519/256 | X25519/256 | 12+ |
AES/128/192/256
HMAC/8-1024
SM4/128
AES/128/192/256
HMAC/8-1024
SM4/128
AES/128/192/256
HMAC/8-1024
SM4/128
AES/128/192/256
HMAC/8-1024
SM4/128
AES/128/192/256
HMAC/8-1024
SM4/128
AES/128/192/256
HMAC/8-1024
SM4/128
AES/256
HMAC/256

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-derivation-dev-V14
爬取时间: 2025-04-28 02:20:42
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-derivation-arkts-V14
爬取时间: 2025-04-28 02:20:56
来源: Huawei Developer
以HKDF256密钥为例，完成密钥派生。具体的场景介绍及支持的算法规格，请参考密钥生成支持的算法。
开发步骤
生成密钥
1.  指定密钥别名。
2.  初始化密钥属性集，可指定参数HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识基于该密钥派生出的密钥是否由HUKS管理。 当TAG设置为HUKS_STORAGE_ONLY_USED_IN_HUKS时，表示基于该密钥派生出的密钥，由HUKS管理，可保证派生密钥全生命周期不出安全环境。 当TAG设置为HUKS_STORAGE_KEY_EXPORT_ALLOWED时，表示基于该密钥派生出的密钥，返回给调用方管理，由业务自行保证密钥安全。 若业务未设置TAG的具体值，表示基于该密钥派生出的密钥，即可由HUKS管理，也可返回给调用方管理，业务可在后续派生时再选择使用何种方式保护密钥。
3.  当TAG设置为HUKS_STORAGE_ONLY_USED_IN_HUKS时，表示基于该密钥派生出的密钥，由HUKS管理，可保证派生密钥全生命周期不出安全环境。
4.  当TAG设置为HUKS_STORAGE_KEY_EXPORT_ALLOWED时，表示基于该密钥派生出的密钥，返回给调用方管理，由业务自行保证密钥安全。
5.  若业务未设置TAG的具体值，表示基于该密钥派生出的密钥，即可由HUKS管理，也可返回给调用方管理，业务可在后续派生时再选择使用何种方式保护密钥。
6.  调用generateKeyItem生成密钥，具体请参考密钥生成。
-  当TAG设置为HUKS_STORAGE_ONLY_USED_IN_HUKS时，表示基于该密钥派生出的密钥，由HUKS管理，可保证派生密钥全生命周期不出安全环境。
-  当TAG设置为HUKS_STORAGE_KEY_EXPORT_ALLOWED时，表示基于该密钥派生出的密钥，返回给调用方管理，由业务自行保证密钥安全。
-  若业务未设置TAG的具体值，表示基于该密钥派生出的密钥，即可由HUKS管理，也可返回给调用方管理，业务可在后续派生时再选择使用何种方式保护密钥。
除此之外，开发者也可以参考密钥导入，导入已有的密钥。
密钥派生
1.  获取密钥别名，指定对应的属性参数HuksOptions。 可指定参数HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识派生得到的密钥是否由HUKS管理。 注：派生时指定的TAG值，不可与生成时指定的TAG值冲突。表格中仅列举有效的指定方式。
2.  调用initSession初始化密钥会话，并获取会话的句柄handle。
3.  调用updateSession更新密钥会话。
4.  调用finishSession结束密钥会话，完成派生。
| 生成 | 派生 | 规格 |
| --- | --- | --- |
| HUKS_STORAGE_ONLY_USED_IN_HUKS | HUKS_STORAGE_ONLY_USED_IN_HUKS | 密钥由HUKS管理 |
| HUKS_STORAGE_KEY_EXPORT_ALLOWED | HUKS_STORAGE_KEY_EXPORT_ALLOWED | 密钥返回给调用方管理 |
| 未指定TAG具体值 | HUKS_STORAGE_ONLY_USED_IN_HUKS | 密钥由HUKS管理 |
| 未指定TAG具体值 | HUKS_STORAGE_KEY_EXPORT_ALLOWED | 密钥返回给调用方管理 |
| 未指定TAG具体值 | 未指定TAG具体值 | 密钥返回给调用方管理 |
删除密钥
当密钥废弃不用时，需要调用deleteKeyItem删除密钥，具体请参考密钥删除。
开发案例
HKDF
```typescript
/*
* 以下以HKDF密钥的Promise操作使用为例
*/
import { huks } from '@kit.UniversalKeystoreKit';
/*
* 确定密钥别名和封装密钥属性参数集
*/
let srcKeyAlias = "hkdf_Key";
let deriveHkdfInData = "deriveHkdfTestIndata";
let handle: number;
let finishOutData: Uint8Array;
let HuksKeyDeriveKeySize = 32;
/* 集成生成密钥参数集 */
let properties: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES,
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DERIVE,
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256,
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128,
}, {
tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,
value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,
}];
let huksOptions: huks.HuksOptions = {
properties: properties,
inData: new Uint8Array(new Array())
}
/* 集成init时密钥参数集 */
let initProperties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_HKDF,
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DERIVE,
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256,
}, {
tag: huks.HuksTag.HUKS_TAG_DERIVE_KEY_SIZE,
value: HuksKeyDeriveKeySize,
}];
let initOptions: huks.HuksOptions = {
properties: initProperties,
inData: new Uint8Array(new Array())
}
/* 集成finish时密钥参数集 */
let finishProperties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,
value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,
}, {
tag: huks.HuksTag.HUKS_TAG_IS_KEY_ALIAS,
value: true,
}, {
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES,
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256,
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value:
huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |
huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT,
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_NONE,
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_ALIAS,
value: StringToUint8Array(srcKeyAlias),
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE,
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_ECB,
}];
let finishOptions: huks.HuksOptions = {
properties: finishProperties,
inData: new Uint8Array(new Array())
}
function StringToUint8Array(str: String) {
let arr: number[] = new Array();
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
class throwObject {
isThrow = false;
}
function generateKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<void>((resolve, reject) => {
try {
huks.generateKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicGenKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise generateKeyItem`);
let throwObject: throwObject = { isThrow: false };
try {
await generateKeyItem(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: generateKeyItem success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: generateKeyItem failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: generateKeyItem input arg invalid, ${JSON.stringify(error)}`);
}
}
function initSession(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<huks.HuksSessionHandle>((resolve, reject) => {
try {
huks.initSession(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicInitFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise doInit`);
let throwObject: throwObject = { isThrow: false };
try {
await initSession(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);
handle = data.handle;
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doInit failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: doInit input arg invalid, ${JSON.stringify(error)}`);
}
}
function updateSession(handle: number, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<huks.HuksOptions>((resolve, reject) => {
try {
huks.updateSession(handle, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicUpdateFunc(handle: number, huksOptions: huks.HuksOptions) {
console.info(`enter promise doUpdate`);
let throwObject: throwObject = { isThrow: false };
try {
await updateSession(handle, huksOptions, throwObject)
.then((data) => {
console.info(`promise: doUpdate success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doUpdate failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: doUpdate input arg invalid, ${JSON.stringify(error)}`);
}
}
function finishSession(handle: number, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<huks.HuksReturnResult>((resolve, reject) => {
try {
huks.finishSession(handle, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicFinishFunc(handle: number, huksOptions: huks.HuksOptions) {
console.info(`enter promise doFinish`);
let throwObject: throwObject = { isThrow: false };
try {
await finishSession(handle, huksOptions, throwObject)
.then((data) => {
finishOutData = data.outData as Uint8Array;
console.info(`promise: doFinish success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doFinish failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: doFinish input arg invalid, ${JSON.stringify(error)}`);
}
}
function deleteKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<void>((resolve, reject) => {
try {
huks.deleteKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicDeleteKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise deleteKeyItem`);
let throwObject: throwObject = { isThrow: false };
try {
await deleteKeyItem(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: deleteKeyItem key success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: deleteKeyItem failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: deleteKeyItem input arg invalid, ${JSON.stringify(error)}`);
}
}
async function testDerive() {
/* 生成密钥 */
await publicGenKeyFunc(srcKeyAlias, huksOptions);
/* 进行派生操作 */
await publicInitFunc(srcKeyAlias, initOptions);
initOptions.inData = StringToUint8Array(deriveHkdfInData);
await publicUpdateFunc(handle, initOptions);
await publicFinishFunc(handle, finishOptions);
await publicDeleteKeyFunc(srcKeyAlias, huksOptions);
}
```
PBKDF2
```typescript
/*
* 以下以PBKDF2密钥的Promise操作使用为例
*/
import { huks } from '@kit.UniversalKeystoreKit';
/*
* 确定密钥别名和封装密钥属性参数集
*/
let srcKeyAlias = "pbkdf2_Key";
let salt = "mySalt";
let iterationCount = 10000;
let derivedKeySize = 32;
let handle: number;
let finishOutData: Uint8Array;
/* 集成生成密钥参数集 */
let properties: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES,
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DERIVE,
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256,
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128,
}, {
tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,
value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,
}
];
let huksOptions: huks.HuksOptions = {
properties: properties,
inData: new Uint8Array(new Array())
}
/* 集成init时密钥参数集 */
let initProperties: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_PBKDF2,
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DERIVE,
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256,
}, {
tag: huks.HuksTag.HUKS_TAG_DERIVE_KEY_SIZE,
value: derivedKeySize,
}, {
tag: huks.HuksTag.HUKS_TAG_ITERATION,
value: iterationCount,
}, {
tag: huks.HuksTag.HUKS_TAG_SALT,
value: StringToUint8Array(salt),
}
];
let initOptions: huks.HuksOptions = {
properties: initProperties,
inData: new Uint8Array(new Array())
}
/* 集成finish时密钥参数集 */
let finishProperties: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,
value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,
}, {
tag: huks.HuksTag.HUKS_TAG_IS_KEY_ALIAS,
value: true,
}, {
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_AES,
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256,
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT,
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_NONE,
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_ALIAS,
value: StringToUint8Array(srcKeyAlias),
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE,
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_ECB,
}
];
let finishOptions: huks.HuksOptions = {
properties: finishProperties,
inData: new Uint8Array(new Array())
}
function StringToUint8Array(str: String) {
let arr: number[] = new Array();
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
class throwObject {
isThrow = false;
}
function generateKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<void>((resolve, reject) => {
try {
huks.generateKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicGenKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise generateKeyItem`);
let throwObject: throwObject = { isThrow: false };
try {
await generateKeyItem(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: generateKeyItem success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: generateKeyItem failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: generateKeyItem input arg invalid, ${JSON.stringify(error)}`);
}
}
function initSession(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<huks.HuksSessionHandle>((resolve, reject) => {
try {
huks.initSession(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicInitFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise doInit`);
let throwObject: throwObject = { isThrow: false };
try {
await initSession(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);
handle = data.handle;
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doInit failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: doInit input arg invalid, ${JSON.stringify(error)}`);
}
}
function updateSession(handle: number, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<huks.HuksOptions>((resolve, reject) => {
try {
huks.updateSession(handle, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicUpdateFunc(handle: number, huksOptions: huks.HuksOptions) {
console.info(`enter promise doUpdate`);
let throwObject: throwObject = { isThrow: false };
try {
await updateSession(handle, huksOptions, throwObject)
.then((data) => {
console.info(`promise: doUpdate success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doUpdate failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: doUpdate input arg invalid, ${JSON.stringify(error)}`);
}
}
function finishSession(handle: number, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<huks.HuksReturnResult>((resolve, reject) => {
try {
huks.finishSession(handle, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicFinishFunc(handle: number, huksOptions: huks.HuksOptions) {
console.info(`enter promise doFinish`);
let throwObject: throwObject = { isThrow: false };
try {
await finishSession(handle, huksOptions, throwObject)
.then((data) => {
finishOutData = data.outData as Uint8Array;
console.info(`promise: doFinish success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doFinish failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: doFinish input arg invalid, ${JSON.stringify(error)}`);
}
}
function deleteKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<void>((resolve, reject) => {
try {
huks.deleteKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicDeleteKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise deleteKeyItem`);
let throwObject: throwObject = { isThrow: false };
try {
await deleteKeyItem(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: deleteKeyItem key success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: deleteKeyItem failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: deleteKeyItem input arg invalid, ${JSON.stringify(error)}`);
}
}
async function testDerive() {
/* 生成密钥 */
await publicGenKeyFunc(srcKeyAlias, huksOptions);
/* 进行派生操作 */
await publicInitFunc(srcKeyAlias, initOptions);
await publicUpdateFunc(handle, initOptions);
await publicFinishFunc(handle, finishOptions);
await publicDeleteKeyFunc(srcKeyAlias, huksOptions);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-derivation-ndk-V14
爬取时间: 2025-04-28 02:21:09
来源: Huawei Developer
以HKDF256密钥为例，完成密钥派生。具体的场景介绍及支持的算法规格，请参考密钥生成支持的算法。
在CMake脚本中链接相关动态库
开发步骤
生成密钥
1.  指定密钥别名。
2.  初始化密钥属性集，可指定参数，OH_HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识基于该密钥派生出的密钥是否由HUKS管理。 当TAG设置为OH_HUKS_STORAGE_ONLY_USED_IN_HUKS时，表示基于该密钥派生出的密钥，由HUKS管理，可保证派生密钥全生命周期不出安全环境。 当TAG设置为OH_HUKS_STORAGE_KEY_EXPORT_ALLOWED时，表示基于该密钥派生出的密钥，返回给调用方管理，由业务自行保证密钥安全。 若业务未设置TAG的具体值，表示基于该密钥派生出的密钥，即可由HUKS管理，也可返回给调用方管理，业务可在后续派生时再选择使用何种方式保护密钥。
3.  当TAG设置为OH_HUKS_STORAGE_ONLY_USED_IN_HUKS时，表示基于该密钥派生出的密钥，由HUKS管理，可保证派生密钥全生命周期不出安全环境。
4.  当TAG设置为OH_HUKS_STORAGE_KEY_EXPORT_ALLOWED时，表示基于该密钥派生出的密钥，返回给调用方管理，由业务自行保证密钥安全。
5.  若业务未设置TAG的具体值，表示基于该密钥派生出的密钥，即可由HUKS管理，也可返回给调用方管理，业务可在后续派生时再选择使用何种方式保护密钥。
6.  调用OH_Huks_GenerateKeyItem生成密钥，具体请参考密钥生成。
-  当TAG设置为OH_HUKS_STORAGE_ONLY_USED_IN_HUKS时，表示基于该密钥派生出的密钥，由HUKS管理，可保证派生密钥全生命周期不出安全环境。
-  当TAG设置为OH_HUKS_STORAGE_KEY_EXPORT_ALLOWED时，表示基于该密钥派生出的密钥，返回给调用方管理，由业务自行保证密钥安全。
-  若业务未设置TAG的具体值，表示基于该密钥派生出的密钥，即可由HUKS管理，也可返回给调用方管理，业务可在后续派生时再选择使用何种方式保护密钥。
除此之外，开发者也可以参考密钥导入，导入已有的密钥。
密钥派生
1.  获取密钥别名，指定对应的属性参数HuksOptions。 可指定参数OH_HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识派生得到的密钥是否由HUKS管理。 注：派生时指定的TAG值，不可与生成时指定的TAG值冲突。表格中仅列举有效的指定方式。
2.  调用OH_Huks_InitSession初始化密钥会话，并获取会话的句柄handle。
3.  调用OH_Huks_UpdateSession更新密钥会话。
4.  调用OH_Huks_FinishSession结束密钥会话，完成派生。
| 生成 | 派生 | 规格 |
| --- | --- | --- |
| OH_HUKS_STORAGE_ONLY_USED_IN_HUKS | OH_HUKS_STORAGE_ONLY_USED_IN_HUKS | 密钥由HUKS管理 |
| OH_HUKS_STORAGE_KEY_EXPORT_ALLOWED | OH_HUKS_STORAGE_KEY_EXPORT_ALLOWED | 密钥返回给调用方管理 |
| 未指定TAG具体值 | OH_HUKS_STORAGE_ONLY_USED_IN_HUKS | 密钥由HUKS管理 |
| 未指定TAG具体值 | OH_HUKS_STORAGE_KEY_EXPORT_ALLOWED | 密钥返回给调用方管理 |
| 未指定TAG具体值 | 未指定TAG具体值 | 密钥返回给调用方管理 |
删除密钥
当密钥废弃不用时，需要调用OH_Huks_DeleteKeyItem删除密钥，具体请参考密钥删除。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-identity-authentication-V14
爬取时间: 2025-04-28 02:21:23
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-identity-authentication-overview-V14
爬取时间: 2025-04-28 02:21:37
来源: Huawei Developer
HUKS提供了完备的密钥访问控制能力，以保证存储在HUKS中的密钥被合法正确地访问：
-  业务只能访问属于自己的密钥，即只能访问通过HUKS生成或导入的密钥。
-  支持密钥的用户身份认证访问控制，对于高安全级别、保护敏感数据的业务密钥，需要在使用密钥的时候，再次要求用户即时的验证锁屏密码或生物特征，验证通过后，才能使用业务密钥。
-  支持严格限制密钥的使用用途，如支持只允许AES密钥进行加密解密，只允许RSA密钥进行签名验签。 轻量级设备不支持用户身份认证访问控制功能。
使用场景及开发流程
整个用户身份认证访问控制，涉及多个环节，介绍如下。
用户身份认证
生成/导入密钥时，可以指定密钥必须经过用户身份认证后才能使用。应用可以指定用于解锁设备锁屏的凭据（锁屏密码、指纹、人脸）的子集进行身份认证，详情请参考用户身份认证和授权访问类型详细规格。
生成/导入密钥后，即使应用进程被攻击也不会导致未经用户授权的密钥访问，一般用于高敏感且高级别安全保护的场景，比如免密登录、免密支付、自动填充密码保护等。
设置授权访问类型
除用户身份认证外，应用还需将密钥的授权访问类型（即失效条件）设置为以下三种类型之一：
-  清除锁屏密码后，密钥永久失效。 在生成/导入密钥后，一旦清除锁屏密码，此类密钥将永久失效。修改密码不会导致失效情况发生。 前提条件：当前用户已经设置了锁屏密码。 适用场景：保护与用户强相关的数据、锁屏密码授权访问某部分功能。
-  用户录入新生物特征后，该特征下密钥永久失效。 在生成/导入密钥后，一旦录入新的生物特征，该特征下此类密钥将永久失效。仅删除生物特征不会导致失效情况发生。 这表示该授权访问类型下，仅录入同类型的新生物特征会无法使用此类密钥，而其它身份认证方式（其它生物特征、锁屏密码）仍可正常使用此类密钥。需要注意的是，如果清除锁屏密码，该授权访问类型的密钥也将永久失效。 前提条件：当前用户至少录入了一个生物特征（如指纹）。 使用场景：免密登录，免密支付等。
-  用户密钥总是有效。 使用此模式生成的密钥将永久有效，除非用户主动删除。 这表示无论用户如何清除、更改锁屏密码和生物特征，只要用户身份认证成功，此类密钥总是可用。 密钥生成时将绑定前台用户id，使用此模式生成的密钥时，仅对前台用户id进行校验。
支持挑战值校验
此外，为了保证密钥使用时用户认证结果的有效性（不可重放），HUKS支持挑战值校验。
在身份认证前，需要从HUKS获取挑战值传给用户身份认证方法，然后在密钥操作时校验认证令牌的挑战值。
二次认证密钥访问控制
除此之外，二次认证密钥访问控制还包含以下三种方式：
-  根据AuthToken进行访问控制 用户身份认证访问控制流程如上图所示。 其中，AT KEY（对称密钥）由HUKS TA每次启动时根据设备的安全根密钥重新派生而成。且UserIAM 与HUKS 的交互位于TEE环境内。
-  允许一次认证多次授权 密钥管理支持一次认证多次授权，允许多个密钥的访问控制授权通过一次认证完成。 适用场景：如手机克隆，希望一次性导出数据，只需要校验一次锁屏密码。 使用方式：HUKS 每次生成的Challenge为8字节，而传入UserIAM中的Challenge可扩展为32字节，因而支持一次授权4个密钥的访问。业务调用HUKS为每个密钥生成8字节的Challenge，而后将多个Challenge拼接为一个Challenge传入UserIAM进行认证。
-  支持基于timestamp的访问控制 对于某些特殊场景，如高性能场景，支持基于timestamp的免Challenge实现。在生成密钥时设置超时时间，业务使用时直接请求UserIAM发起认证，而后将包含了timestamp的AuthToken传给HUKS，HUKS校验AuthToken后，对比当前时间与timestamp差值是否大于超时时间，从而判断密钥是否允许使用。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170455.97075892854080039656908683975853:50001231000000:2800:64E7CB2EC36A756385EB9DE13A1B223E50AC720D8DD66A4E6071C991209AF975.png)
用户身份认证和授权访问类型详细规格
为方便查阅，在表格中将使用对应的简写指代具体的用户认证类型，其对应关系如下：
安全访问控制类型简写为：
| 用户身份认证 | 授权访问类型 | 说明 |
| --- | --- | --- |
| PIN | INVALID_CLEAR_PASSWORD | 当前仅支持锁屏密码进行身份认证，清除锁屏密码后，密钥永久失效 |
| FACE | INVALID_CLEAR_PASSWORD | 当前仅支持人脸进行身份认证，清除锁屏密码后，密钥永久失效 |
| FINGERPRINT | INVALID_CLEAR_PASSWORD | 当前仅支持指纹进行身份认证，清除锁屏密码后，密钥永久失效 |
| PIN | FACE | INVALID_CLEAR_PASSWORD | 当前支持锁屏密码或人脸任一凭据进行身份认证，清除锁屏密码后，密钥永久失效 |
| PIN | FINGERPRINT | INVALID_CLEAR_PASSWORD | 当前支持锁屏密码或指纹任一凭据进行身份认证，清除锁屏密码后，密钥永久失效 |
| PIN | FACE | FINGERPRINT | INVALID_CLEAR_PASSWORD | 当前支持锁屏密码、人脸或指纹任一凭据进行身份认证，清除锁屏密码后，密钥永久失效 |
| FACE | INVALID_NEW_BIO_ENROLL | 当前仅支持人脸进行身份认证，录入新的人脸后，密钥永久失效 |
| FINGERPRINT | INVALID_NEW_BIO_ENROLL | 当前仅支持指纹进行身份认证，录入新的指纹后，密钥永久失效 |
| PIN | FACE | INVALID_NEW_BIO_ENROLL | 当前支持锁屏密码或人脸任一凭据进行身份认证，录入新的人脸后，用户通过人脸凭据无法使用密钥，通过锁屏密码仍可正常使用密钥；清除锁屏密码后，密钥永久失效 |
| PIN | FINGERPRINT | INVALID_NEW_BIO_ENROLL | 当前支持锁屏密码或指纹任一凭据进行身份认证，录入新的指纹后，用户通过指纹凭据无法使用密钥，通过锁屏密码仍可正常使用密钥；清除锁屏密码后，密钥永久失效 |
| FACE | FINGERPRINT | INVALID_NEW_BIO_ENROLL | 当前支持人脸或指纹任一凭据进行身份认证，录入新的生物特征后，用户通过该生物特征凭据无法使用密钥，其它凭据不受影响仍可正常使用密钥 |
| PIN | FACE | FINGERPRINT | INVALID_NEW_BIO_ENROLL | 当前支持锁屏密码、人脸或指纹任一凭据进行身份认证，录入新的生物特征后，用户通过该生物特征凭据无法使用密钥，其它凭据不受影响仍可正常使用密钥；清除锁屏密码后，密钥永久失效 |
| PIN | ALWAYS_VALID | 当前仅支持锁屏密码进行身份认证，密钥永久有效 |
| FACE | ALWAYS_VALID | 当前仅支持人脸进行身份认证，密钥永久有效 |
| FINGERPRINT | ALWAYS_VALID | 当前仅支持指纹进行身份认证，密钥永久有效 |
| PIN | FACE | ALWAYS_VALID | 当前支持锁屏密码或人脸进行身份认证，密钥永久有效 |
| PIN | FINGERPRINT | ALWAYS_VALID | 当前支持锁屏密码或指纹进行身份认证，密钥永久有效 |
| FACE | FINGERPRINT | ALWAYS_VALID | 当前支持人脸或指纹进行身份认证，密钥永久有效 |
| PIN | FACE | FINGERPRINT | ALWAYS_VALID | 当前支持锁屏密码、人脸或指纹进行身份认证，密钥永久有效 |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-identity-authentication-dev-V14
爬取时间: 2025-04-28 02:21:50
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-user-identity-authentication-V14
爬取时间: 2025-04-28 02:22:04
来源: Huawei Developer
场景介绍及相关概念说明请参考用户身份认证访问控制简介。
开发步骤
1.  生成密钥，指定指纹访问控制类型及相关属性。 生成或导入密钥时，在密钥属性集中需指定三个参数：用户认证类型HuksUserAuthType、授权访问类型HuksAuthAccessType、挑战值类型HuksChallengeType。
```typescript
import { huks } from '@kit.UniversalKeystoreKit';
/*
* 确定密钥别名和封装密钥属性参数集
*/
let keyAlias = 'test_sm4_key_alias';
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_SM4
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_SM4_KEY_SIZE_128,
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_CBC,
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE,
},
// 指定密钥身份认证的类型：指纹
{
tag: huks.HuksTag.HUKS_TAG_USER_AUTH_TYPE,
value: huks.HuksUserAuthType.HUKS_USER_AUTH_TYPE_FINGERPRINT
},
// 指定密钥安全授权的类型（失效类型）：新录入生物特征（指纹）后无效
{
tag: huks.HuksTag.HUKS_TAG_KEY_AUTH_ACCESS_TYPE,
value: huks.HuksAuthAccessType.HUKS_AUTH_ACCESS_INVALID_NEW_BIO_ENROLL
},
// 指定挑战值的类型：默认类型
{
tag: huks.HuksTag.HUKS_TAG_CHALLENGE_TYPE,
value: huks.HuksChallengeType.HUKS_CHALLENGE_TYPE_NORMAL
}];
let huksOptions: huks.HuksOptions = {
properties: properties,
inData: new Uint8Array(new Array())
}
/*
* 生成密钥
*/
class throwObject {
isThrow: boolean = false
}
function generateKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<void>((resolve, reject) => {
try {
huks.generateKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicGenKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise generateKeyItem`);
let throwObject: throwObject = { isThrow: false };
try {
await generateKeyItem(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: generateKeyItem success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: generateKeyItem failed, ` + JSON.stringify(error));
}
});
} catch (error) {
console.error(`promise: generateKeyItem input arg invalid, ` + JSON.stringify(error));
}
}
async function TestGenKeyForFingerprintAccessControl() {
await publicGenKeyFunc(keyAlias, huksOptions);
}
```
```typescript
import { huks } from '@kit.UniversalKeystoreKit';
import { userAuth } from '@kit.UserAuthenticationKit';
/*
* 确定密钥别名和封装密钥属性参数集
*/
let IV = '1234567890123456';
let srcKeyAlias = 'test_sm4_key_alias';
let handle: number;
let challenge: Uint8Array;
let fingerAuthToken: Uint8Array;
let authType = userAuth.UserAuthType.FINGERPRINT;
let authTrustLevel = userAuth.AuthTrustLevel.ATL1;
/* 集成生成密钥参数集 & 加密参数集 */
let properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_SM4,
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT,
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_SM4_KEY_SIZE_128,
}, {
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_CBC,
}, {
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE,
}, {
tag: huks.HuksTag.HUKS_TAG_IV,
value: StringToUint8Array(IV),
}];
function StringToUint8Array(str: string) {
let arr: number[] = [];
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
let huksOptions: huks.HuksOptions = {
properties: properties,
inData: new Uint8Array(new Array())
}
class throwObject {
isThrow: boolean = false
}
function initSession(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<huks.HuksSessionHandle>((resolve, reject) => {
try {
huks.initSession(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
/* 初始化HUKS中的会话，获取挑战值 */
async function publicInitFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise doInit`);
let throwObject: throwObject = { isThrow: false };
try {
await initSession(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);
handle = data.handle;
challenge = data.challenge as Uint8Array;
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doInit failed, ` + JSON.stringify(error));
}
});
} catch (error) {
console.error(`promise: doInit input arg invalid, ` + JSON.stringify(error));
}
}
/* 调用UserIAM拉起指纹认证，触发HUKS的访问控制流程 */
function userIAMAuthFinger(huksChallenge: Uint8Array) {
// 获取认证对象
let authTypeList: userAuth.UserAuthType[] = [authType];
const authParam: userAuth.AuthParam = {
challenge: huksChallenge,
authType: authTypeList,
authTrustLevel: userAuth.AuthTrustLevel.ATL1
};
const widgetParam: userAuth.WidgetParam = {
title: '请输入密码',
};
let auth: userAuth.UserAuthInstance;
try {
auth = userAuth.getUserAuthInstance(authParam, widgetParam);
console.info("get auth instance success");
} catch (error) {
console.error("get auth instance failed" + JSON.stringify(error));
return;
}
// 订阅认证结果
try {
auth.on("result", {
onResult(result) {
console.info("[HUKS] -> [IAM]  userAuthInstance callback result = " + JSON.stringify(result));
fingerAuthToken = result.token;
}
});
console.log("subscribe authentication event success");
} catch (error) {
console.error("subscribe authentication event failed, " + JSON.stringify(error));
}
// 开始认证
try {
auth.start();
console.info("authV9 start auth success");
} catch (error) {
console.error("authV9 start auth failed, error = " + JSON.stringify(error));
}
}
async function testInitAndAuthFinger() {
/* 初始化密钥会话获取挑战值 */
await publicInitFunc(srcKeyAlias, huksOptions);
/* 调用userIAM进行身份认证 */
userIAMAuthFinger(challenge);
}
```
```typescript
/*
* 以下以SM4 128密钥为例
*/
import { huks } from '@kit.UniversalKeystoreKit';
/*
* 确定封装密钥属性参数集
*/
let IV = '1234567890123456';
let cipherInData = 'Hks_SM4_Cipher_Test_101010101010101010110_string';
let handle: number;
let fingerAuthToken: Uint8Array;
let finishOutData: Uint8Array;
class throwObject {
isThrow: boolean = false;
}
/* 集成生成密钥参数集 & 加密参数集 */
class propertyEncryptType {
tag: huks.HuksTag = huks.HuksTag.HUKS_TAG_ALGORITHM;
value: huks.HuksKeyAlg | huks.HuksKeyPurpose | huks.HuksKeySize | huks.HuksKeyPadding | huks.HuksCipherMode
| Uint8Array = huks.HuksKeyAlg.HUKS_ALG_SM4;
}
let propertiesEncrypt: propertyEncryptType[] = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_SM4,
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT,
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_SM4_KEY_SIZE_128,
},
{
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE,
},
{
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_CBC,
},
{
tag: huks.HuksTag.HUKS_TAG_IV,
value: StringToUint8Array(IV),
}
]
let encryptOptions: huks.HuksOptions = {
properties: propertiesEncrypt,
inData: new Uint8Array(new Array())
}
function StringToUint8Array(str: string) {
let arr: number[] = [];
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
function updateSession(handle: number, huksOptions: huks.HuksOptions, token: Uint8Array, throwObject: throwObject) {
return new Promise<huks.HuksReturnResult>((resolve, reject) => {
try {
huks.updateSession(handle, huksOptions, token, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicUpdateFunc(handle: number, token: Uint8Array, huksOptions: huks.HuksOptions) {
console.info(`enter promise doUpdate`);
let throwObject: throwObject = { isThrow: false };
try {
await updateSession(handle, huksOptions, token, throwObject)
.then((data) => {
console.info(`promise: doUpdate success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doUpdate failed, ` + JSON.stringify(error));
}
});
} catch (error) {
console.error(`promise: doUpdate input arg invalid, ` + JSON.stringify(error));
}
}
function finishSession(handle: number, huksOptions: huks.HuksOptions, token: Uint8Array, throwObject: throwObject) {
return new Promise<huks.HuksReturnResult>((resolve, reject) => {
try {
huks.finishSession(handle, huksOptions, token, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicFinishFunc(handle: number, token: Uint8Array, huksOptions: huks.HuksOptions) {
console.info(`enter promise doFinish`);
let throwObject: throwObject = { isThrow: false };
try {
await finishSession(handle, huksOptions, token, throwObject)
.then((data) => {
finishOutData = data.outData as Uint8Array;
console.info(`promise: doFinish success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doFinish failed, ` + JSON.stringify(error));
}
});
} catch (error) {
console.error(`promise: doFinish input arg invalid, ` + JSON.stringify(error));
}
}
async function testSm4Cipher() {
encryptOptions.inData = StringToUint8Array(cipherInData);
/* 传入认证令牌 */
await publicUpdateFunc(handle, fingerAuthToken, encryptOptions);
/* 传入认证令牌 */
await publicFinishFunc(handle, fingerAuthToken, encryptOptions);
if (finishOutData === StringToUint8Array(cipherInData)) {
console.info('test finish encrypt error ');
} else {
console.info('test finish encrypt success');
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-refined-user-identity-authentication-V14
爬取时间: 2025-04-28 02:22:17
来源: Huawei Developer
细粒度用户身份认证访问控制是基于已有用户身份认证访问控制的扩展，提供了基于生物特征和锁屏密码二次身份认证的细粒度访问控制能力，允许设置密钥在加密、解密、签名、验签、密钥协商、密钥派生的单个或多个场景时是否需要进行身份验证。
比如，业务需要使用HUKS密钥加密保存账号密码信息等数据，要求在加密的时候不进行指纹等身份认证，解密的时候需要进行指纹等身份认证，这是就需要依赖HUKS提供细粒度的二次身份认证访问控制机制。
使用该功能仅需在密钥生成阶段，通过额外指定用于细粒度用户身份认证访问控制的HuksTag：HUKS_TAG_KEY_AUTH_PURPOSE，来指定在某种算法用途的情况下需要使用用户身份认证访问控制能力。
对于对称加解密场景，仅AES/CBC、AES/GCM、SM4/CBC模式支持细粒度访问控制。
开发步骤
1.  生成密钥，指定指纹类型的访问控制及相关属性，指定HUKS_TAG_KEY_AUTH_PURPOSE值。
```typescript
import { huks } from "@kit.UniversalKeystoreKit";
/*
* 确定密钥别名和封装密钥属性参数集
*/
let keyAlias = 'test_sm4_key_alias';
class throwObject {
isThrow: boolean = false;
}
let properties: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_SM4,
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT,
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_SM4_KEY_SIZE_128,
},
{
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_CBC,
},
{
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE,
},
{
tag: huks.HuksTag.HUKS_TAG_USER_AUTH_TYPE,
value: huks.HuksUserAuthType.HUKS_USER_AUTH_TYPE_FINGERPRINT
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_AUTH_ACCESS_TYPE,
value: huks.HuksAuthAccessType.HUKS_AUTH_ACCESS_INVALID_NEW_BIO_ENROLL
},
{
tag: huks.HuksTag.HUKS_TAG_CHALLENGE_TYPE,
value: huks.HuksChallengeType.HUKS_CHALLENGE_TYPE_NORMAL
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_AUTH_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
}
];
let huksOptions: huks.HuksOptions = {
properties: properties,
inData: new Uint8Array(new Array())
}
/*
* 生成密钥
*/
async function generateKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<void>((resolve, reject) => {
try {
huks.generateKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicGenKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise generateKeyItem`);
let throwObject: throwObject = { isThrow: false };
try {
await generateKeyItem(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: generateKeyItem success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: generateKeyItem failed` + JSON.stringify(error));
}
});
} catch (error) {
console.error(`promise: generateKeyItem input arg invalid` + JSON.stringify(error));
}
}
async function TestGenKeyForFingerprintAccessControl() {
await publicGenKeyFunc(keyAlias, huksOptions);
}
```
2.  使用密钥，加密时不需要用户身份认证访问控制。
```typescript
import { huks } from "@kit.UniversalKeystoreKit";
class HuksProperties {
tag: huks.HuksTag = huks.HuksTag.HUKS_TAG_ALGORITHM;
value: huks.HuksKeyAlg | huks.HuksKeySize | huks.HuksKeyPurpose | huks.HuksKeyPadding | huks.HuksCipherMode
| Uint8Array = huks.HuksKeyAlg.HUKS_ALG_ECC;
}
/*
* 确定密钥别名和封装密钥属性参数集
*/
let keyAlias = 'test_sm4_key_alias';
let cipherInData = 'Hks_SM4_Cipher_Test_101010101010101010110_string'; // 明文数据
let IV = '1234567890123456';
let handle = 0;
let cipherText: Uint8Array; // 加密后的密文数据
function StringToUint8Array(str: string) {
let arr: number[] = [];
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
/* 集成生成密钥参数集 & 加密参数集 */
let propertiesEncrypt: HuksProperties[] = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_SM4,
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT,
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_SM4_KEY_SIZE_128,
},
{
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE,
},
{
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_CBC,
},
{
tag: huks.HuksTag.HUKS_TAG_IV,
value: StringToUint8Array(IV),
}
];
let encryptOptions: huks.HuksOptions = {
properties: propertiesEncrypt,
inData: new Uint8Array(new Array())
}
class throwObject1 {
isThrow: boolean = false;
}
function initSession(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject1) {
return new Promise<huks.HuksSessionHandle>((resolve, reject) => {
try {
huks.initSession(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicInitFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise doInit`);
let throwObject: throwObject1 = { isThrow: false };
try {
await initSession(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);
handle = data.handle as number;
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doInit failed` + JSON.stringify(error));
}
});
} catch (error) {
console.error(`promise: doInit input arg invalid` + JSON.stringify(error));
}
}
function finishSession(handle: number, huksOptions: huks.HuksOptions, throwObject: throwObject1) {
return new Promise<huks.HuksReturnResult>((resolve, reject) => {
try {
huks.finishSession(handle, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicFinishFunc(handle: number, huksOptions: huks.HuksOptions) {
console.info(`enter promise doFinish`);
let throwObject: throwObject1 = { isThrow: false };
try {
await finishSession(handle, huksOptions, throwObject)
.then((data) => {
cipherText = data.outData as Uint8Array;
console.info(`promise: doFinish success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doFinish failed` + JSON.stringify(error));
}
});
} catch (error) {
console.error(`promise: doFinish input arg invalid` + JSON.stringify(error));
}
}
async function testSm4Cipher() {
/* 初始化密钥会话获取挑战值 */
await publicInitFunc(keyAlias, encryptOptions);
/* 加密 */
encryptOptions.inData = StringToUint8Array(cipherInData);
await publicFinishFunc(handle, encryptOptions);
}
```
3.  使用密钥，解密时需要进行用户身份认证访问控制。
```typescript
import { huks } from "@kit.UniversalKeystoreKit";
import { userAuth } from '@kit.UserAuthenticationKit';
import { BusinessError } from "@kit.BasicServicesKit"
let keyAlias = 'test_sm4_key_alias';
let IV = '1234567890123456';
let handle = 0;
let cipherText: Uint8Array; // 密文数据
/*
* 确定封装密钥属性参数集
*/
let finishOutData: Uint8Array; // 解密后的明文数据
let fingerAuthToken: Uint8Array;
let challenge: Uint8Array;
let authType = userAuth.UserAuthType.FINGERPRINT;
let authTrustLevel = userAuth.AuthTrustLevel.ATL1;
class throwObject {
isThrow: boolean = false;
}
function StringToUint8Array(str: string) {
let arr: number[] = [];
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
/* 集成生成密钥参数集 & 加密参数集 */
class propertyDecryptType {
tag: huks.HuksTag = huks.HuksTag.HUKS_TAG_ALGORITHM
value: huks.HuksKeyAlg | huks.HuksKeyPurpose | huks.HuksKeySize | huks.HuksKeyPadding | huks.HuksCipherMode
| Uint8Array = huks.HuksKeyAlg.HUKS_ALG_SM4
}
let propertiesDecrypt: propertyDecryptType[] = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_SM4,
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT,
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_SM4_KEY_SIZE_128,
},
{
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_NONE,
},
{
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_CBC,
},
{
tag: huks.HuksTag.HUKS_TAG_IV,
value: StringToUint8Array(IV),
}
]
let decryptOptions: huks.HuksOptions = {
properties: propertiesDecrypt,
inData: new Uint8Array(new Array())
}
function initSession(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<huks.HuksSessionHandle>((resolve, reject) => {
try {
huks.initSession(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicInitFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise doInit`);
let throwObject: throwObject = { isThrow: false };
try {
await initSession(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);
handle = data.handle;
challenge = data.challenge as Uint8Array;
})
.catch((error: BusinessError) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doInit failed` + JSON.stringify(error));
}
});
} catch (error) {
console.error(`promise: doInit input arg invalid` + JSON.stringify(error));
}
}
function userIAMAuthFinger(huksChallenge: Uint8Array) {
// 获取认证对象
let authTypeList: userAuth.UserAuthType[] = [authType];
const authParam: userAuth.AuthParam = {
challenge: huksChallenge,
authType: authTypeList,
authTrustLevel: userAuth.AuthTrustLevel.ATL1
};
const widgetParam: userAuth.WidgetParam = {
title: '请输入密码',
};
let auth: userAuth.UserAuthInstance;
try {
auth = userAuth.getUserAuthInstance(authParam, widgetParam);
console.info("get auth instance success");
} catch (error) {
console.error("get auth instance failed" + JSON.stringify(error));
return;
}
// 订阅认证结果
try {
auth.on("result", {
onResult(result) {
console.info("[HUKS] -> [IAM]  userAuthInstance callback result = " + JSON.stringify(result));
fingerAuthToken = result.token;
}
});
console.info("subscribe authentication event success");
} catch (error) {
console.error("subscribe authentication event failed " + JSON.stringify(error));
}
// 开始认证
try {
auth.start();
console.info("authV9 start auth success");
} catch (error) {
console.error("authV9 start auth failed, error = " + JSON.stringify(error));
}
}
function finishSession(handle: number, huksOptions: huks.HuksOptions, token: Uint8Array, throwObject: throwObject) {
return new Promise<huks.HuksReturnResult>((resolve, reject) => {
try {
huks.finishSession(handle, huksOptions, token, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicFinishFunc(handle: number, token: Uint8Array, huksOptions: huks.HuksOptions) {
console.info(`enter promise doFinish`);
let throwObject: throwObject = { isThrow: false };
try {
await finishSession(handle, huksOptions, token, throwObject)
.then((data) => {
finishOutData = data.outData as Uint8Array;
console.info(`promise: doFinish success, data = ${JSON.stringify(data)}`);
})
.catch((error: BusinessError) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: doFinish failed` + JSON.stringify(error));
}
});
} catch (error) {
console.error(`promise: doFinish input arg invalid` + JSON.stringify(error));
}
}
async function testSm4CipherInit() {
/* 初始化密钥会话获取挑战值 */
await publicInitFunc(keyAlias, decryptOptions);
/* 调用userIAM进行身份认证 */
userIAMAuthFinger(challenge);
}
async function testSm4CipherFinish() {
/* 认证成功后进行解密, 需要传入Auth获取到的authToken值 */
decryptOptions.inData = cipherText;
await publicFinishFunc(handle, fingerAuthToken, decryptOptions);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-hmac-V14
爬取时间: 2025-04-28 02:22:32
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-hmac-overview-V14
爬取时间: 2025-04-28 02:22:46
来源: Huawei Developer
MAC（Message Authentication Code）提供了一种在不可靠介质上检验传输或存储信息完整性的方法，HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code），是一种基于Hash函数和密钥进行消息认证的方法。HMAC可以与任何加密哈希函数（例如MD5、SHA-1等）结合使用，HUKS支持了HMAC结合主流的摘要算法进行使用。
支持的算法
以下为HMAC支持的规格说明。
| 摘要算法 | 支持的密钥长度 | API级别 |
| --- | --- | --- |
| SHA256 | 192 - 1024 | 8+ |
| SHA384、SHA512 | 256 - 1024 | 8+ |
| SM3 | 8 - 4096 | 8+ |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-hmac-dev-V14
爬取时间: 2025-04-28 02:23:00
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-hmac-arkts-V14
爬取时间: 2025-04-28 02:23:13
来源: Huawei Developer
HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）。具体的场景介绍及支持的算法规格，请参考HMAC介绍与算法规格。
开发步骤
生成密钥
1.  指定密钥别名。
2.  初始化密钥属性集。
3.  调用generateKeyItem生成密钥，HMAC支持的规格请参考密钥生成。
除此之外，开发者也可以参考密钥导入的规格介绍，导入已有的密钥。
执行HMAC
1.  获取密钥别名。
2.  获取待运算的数据。
3.  调用initSession初始化密钥会话，并获取会话的句柄handle。
4.  调用finishSession结束密钥会话，获取哈希后的数据。
```typescript
/*
* 以下以HMAC密钥的Promise操作使用为例
*/
import { huks } from '@kit.UniversalKeystoreKit';
let HmackeyAlias = 'test_HMAC';
let handle: number;
let plainText = '123456';
let hashData: Uint8Array;
function StringToUint8Array(str: String) {
let arr: number[] = new Array();
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
function Uint8ArrayToString(fileData: Uint8Array) {
let dataString = '';
for (let i = 0; i < fileData.length; i++) {
dataString += String.fromCharCode(fileData[i]);
}
return dataString;
}
function GetHMACProperties() {
const properties: Array<huks.HuksParam> = [{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_HMAC
}, {
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256
}, {
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_MAC
}, {
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA384,
}];
return properties;
}
async function GenerateHMACKey() {
/*
* 模拟生成密钥场景
* 1. 确定密钥别名
*/
/*
* 2. 获取生成密钥算法参数配置
*/
let genProperties = GetHMACProperties();
let options: huks.HuksOptions = {
properties: genProperties
}
/*
* 3. 调用generateKeyItem
*/
await huks.generateKeyItem(HmackeyAlias, options)
.then((data) => {
console.info(`promise: generate HMAC Key success`);
}).catch((error: Error) => {
console.error(`promise: generate HMAC Key failed, ${JSON.stringify(error)}`);
})
}
async function HMACData() {
/*
* 模拟HMAC场景
* 1. 获取密钥别名
*/
/*
* 2. 获取待哈希的数据
*/
/*
* 3. 获取HMAC算法参数配置
*/
let hmacProperties = GetHMACProperties();
let options: huks.HuksOptions = {
properties: hmacProperties,
inData: StringToUint8Array(plainText)
}
/*
* 4. 调用initSession获取handle
*/
await huks.initSession(HmackeyAlias, options)
.then((data) => {
handle = data.handle;
}).catch((error: Error) => {
console.error(`promise: init EncryptData failed, ${JSON.stringify(error)}`);
})
/*
* 5. 调用finishSession获取HMAC的结果
*/
await huks.finishSession(handle, options)
.then((data) => {
console.info(`promise: HMAC data success, data is ` + Uint8ArrayToString(data.outData as Uint8Array));
hashData = data.outData as Uint8Array;
}).catch((error: Error) => {
console.error(`promise: HMAC data failed, ${JSON.stringify(error)}`);
})
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-hmac-ndk-V14
爬取时间: 2025-04-28 02:23:27
来源: Huawei Developer
HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）。具体的场景介绍及支持的算法规格，请参考HMAC介绍与算法规格。
在CMake脚本中链接相关动态库
开发步骤
生成密钥
1.  指定密钥别名。
2.  初始化密钥属性集。
3.  调用OH_Huks_GenerateKeyItem生成密钥，HMAC支持的规格请参考密钥生成。
除此之外，开发者也可以参考密钥导入的规格介绍，导入已有的密钥。
执行HMAC
1.  获取密钥别名。
2.  获取待运算的数据。
3.  调用OH_Huks_InitParamSet指定算法参数配置。
4.  调用OH_Huks_InitSession初始化密钥会话，并获取会话的句柄handle。
5.  调用OH_Huks_FinishSession结束密钥会话，获取哈希后的数据。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-delete-key-V14
爬取时间: 2025-04-28 02:23:40
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-delete-key-arkts-V14
爬取时间: 2025-04-28 02:23:54
来源: Huawei Developer
为保证数据安全性，当不需要使用该密钥时，应该删除密钥。
开发步骤
以删除HKDF256密钥为例。
1.  确定密钥别名keyAlias，密钥别名最大长度为128字节。
2.  初始化密钥属性集。用于删除时指定密钥的属性TAG，当删除单个时，TAG字段可传空。
3.  调用接口deleteKeyItem，删除密钥。
```typescript
/*
* 以下以HKDF256密钥的Promise操作使用为例
*/
import { huks } from '@kit.UniversalKeystoreKit';
/* 1.确定密钥别名 */
let keyAlias = "test_Key";
/* 2.构造空对象 */
let huksOptions: huks.HuksOptions = {
properties: []
}
class throwObject {
isThrow = false;
}
function deleteKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<void>((resolve, reject) => {
try {
huks.deleteKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
/* 3.删除密钥*/
async function publicDeleteKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise deleteKeyItem`);
let throwObject: throwObject = { isThrow: false };
try {
await deleteKeyItem(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: deleteKeyItem key success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: deleteKeyItem failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: deleteKeyItem input arg invalid, ${JSON.stringify(error)}`);
}
}
async function testDerive() {
await publicDeleteKeyFunc(keyAlias, huksOptions);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-delete-key-ndk-V14
爬取时间: 2025-04-28 02:24:07
来源: Huawei Developer
为保证数据安全性，当不需要使用该密钥时，应该删除密钥。
在CMake脚本中链接相关动态库
开发步骤
以删除HKDF256密钥为例。
1.  确定密钥别名keyAlias，密钥别名最大长度为128字节。paramSet为预留参数传空即可。
2.  调用接口OH_Huks_DeleteKeyItem，删除密钥。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-attestation-V14
爬取时间: 2025-04-28 02:24:21
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-attestation-overview-V14
爬取时间: 2025-04-28 02:24:35
来源: Huawei Developer
HUKS为密钥提供合法性证明能力，主要应用于非对称密钥的公钥的证明。
基于PKI证书链技术，HUKS可以为存储在HUKS中的非对称密钥对的公钥签发证书，证明其公钥的合法性。业务可以通过系统提供的根CA证书，逐级验证HUKS签发的密钥证明证书，来确保证书中的公钥以及对应的私钥，确实来自合法的硬件设备，且存储管理在HUKS中。同时，输出的密钥证书中包含密钥属主信息，格式如下：
| 密钥属主 | 格式 | 说明 |
| --- | --- | --- |
| HAP应用 | {appId:"xxx", bundleName:"xxx"} | bundleName为应用包名 |
| 系统服务 | {processName:"xxx", APL:"system_basic | system_core"} | APL为系统服务等级 |
密钥来源及对应OID字段的值如下表：
| 密钥来源 | OID字段对应的值 |
| --- | --- |
| 导入 | 1 |
| 生成 | 其他值 |
密钥证明过程如下：
1.  业务将指定密钥别名和需要证明的密钥属性的标签传入HUKS。
2.  调用HUKS为应用生成一个依次由根CA证书、设备CA证书、设备证书、密钥证书组成的X.509证书链。
3.  将证书链传输至受信任的服务器，并在服务器上解析和验证证书链的有效性和单个证书是否吊销。
当前提供了匿名密钥证明的方式，不会泄露设备信息，没有权限管理。面向所有应用开放。为了保护用户设备信息，三方应用开发者只能使用匿名密钥证明。
支持的算法
以下为密钥证明支持的规格说明。
| 算法 | 备注 | API级别 |
| --- | --- | --- |
| RSA | 支持Padding为PSS与PKCS1_V1_5的密钥 | 11+ |
| ECC | - | 11+ |
| SM2 | - | 11+ |

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-attestation-dev-V14
爬取时间: 2025-04-28 02:25:28
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-anon-attestation-arkts-V14
爬取时间: 2025-04-28 02:25:42
来源: Huawei Developer
在使用本功能时，需确保网络通畅。
开发步骤
1.  确定密钥别名keyAlias，密钥别名最大长度为128字节。
2.  初始化参数集。 HuksOptions中的properties字段中的参数必须包含HUKS_TAG_ATTESTATION_CHALLENGE属性,可选参数包含HUKS_TAG_ATTESTATION_ID_VERSION_INFO，HUKS_TAG_ATTESTATION_ID_ALIAS属性。
3.  生成非对称密钥，具体请参考密钥生成。
4.  将密钥别名与参数集作为参数传入huks.anonAttestKeyItem方法中，即可证明密钥。
```typescript
/*
* 以下以anonAttestKey的Promise接口操作验证为例
*/
import { huks } from '@kit.UniversalKeystoreKit';
/* 1.确定密钥别名 */
let keyAliasString = "key anon attest";
let aliasString = keyAliasString;
let aliasUint8 = StringToUint8Array(keyAliasString);
let securityLevel = StringToUint8Array('sec_level');
let challenge = StringToUint8Array('challenge_data');
let versionInfo = StringToUint8Array('version_info');
let anonAttestCertChain: Array<string>;
class throwObject {
isThrow: boolean = false;
}
/* 封装生成时的密钥参数集 */
let genKeyProperties: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
value: huks.HuksKeyAlg.HUKS_ALG_RSA
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
value: huks.HuksKeySize.HUKS_RSA_KEY_SIZE_2048
},
{
tag: huks.HuksTag.HUKS_TAG_PURPOSE,
value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_VERIFY
},
{
tag: huks.HuksTag.HUKS_TAG_DIGEST,
value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256
},
{
tag: huks.HuksTag.HUKS_TAG_PADDING,
value: huks.HuksKeyPadding.HUKS_PADDING_PSS
},
{
tag: huks.HuksTag.HUKS_TAG_KEY_GENERATE_TYPE,
value: huks.HuksKeyGenerateType.HUKS_KEY_GENERATE_TYPE_DEFAULT
},
{
tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
value: huks.HuksCipherMode.HUKS_MODE_ECB
}
]
let genOptions: huks.HuksOptions = {
properties: genKeyProperties
};
/* 2.封装证明密钥的参数集 */
let anonAttestKeyProperties: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_ATTESTATION_ID_SEC_LEVEL_INFO,
value: securityLevel
},
{
tag: huks.HuksTag.HUKS_TAG_ATTESTATION_CHALLENGE,
value: challenge
},
{
tag: huks.HuksTag.HUKS_TAG_ATTESTATION_ID_VERSION_INFO,
value: versionInfo
},
{
tag: huks.HuksTag.HUKS_TAG_ATTESTATION_ID_ALIAS,
value: aliasUint8
}
]
let huksOptions: huks.HuksOptions = {
properties: anonAttestKeyProperties
};
function StringToUint8Array(str: string) {
let arr: number[] = [];
for (let i = 0, j = str.length; i < j; ++i) {
arr.push(str.charCodeAt(i));
}
return new Uint8Array(arr);
}
function generateKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<void>((resolve, reject) => {
try {
huks.generateKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
/* 3.生成密钥 */
async function publicGenKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise generateKeyItem`);
let throwObject: throwObject = { isThrow: false };
try {
await generateKeyItem(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: generateKeyItem success, data = ${JSON.stringify(data)}`);
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: generateKeyItem failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: generateKeyItem input arg invalid, ${JSON.stringify(error)}`);
}
}
/* 4.证明密钥 */
function anonAttestKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {
return new Promise<huks.HuksReturnResult>((resolve, reject) => {
try {
huks.anonAttestKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
reject(error);
} else {
resolve(data);
}
});
} catch (error) {
throwObject.isThrow = true;
throw (error as Error);
}
});
}
async function publicAnonAttestKey(keyAlias: string, huksOptions: huks.HuksOptions) {
console.info(`enter promise anonAttestKeyItem`);
let throwObject: throwObject = { isThrow: false };
try {
await anonAttestKeyItem(keyAlias, huksOptions, throwObject)
.then((data) => {
console.info(`promise: anonAttestKeyItem success, data = ${JSON.stringify(data)}`);
if (data !== null && data.certChains !== null) {
anonAttestCertChain = data.certChains as string[];
}
})
.catch((error: Error) => {
if (throwObject.isThrow) {
throw (error as Error);
} else {
console.error(`promise: anonAttestKeyItem failed, ${JSON.stringify(error)}`);
}
});
} catch (error) {
console.error(`promise: anonAttestKeyItem input arg invalid, ${JSON.stringify(error)}`);
}
}
async function AnonAttestKeyTest() {
await publicGenKeyFunc(aliasString, genOptions);
await publicAnonAttestKey(aliasString, huksOptions);
console.info('anon attest certChain data: ' + anonAttestCertChain)
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-key-anon-attestation-ndk-V14
爬取时间: 2025-04-28 02:25:55
来源: Huawei Developer
在使用本功能时，需确保网络通畅。
在CMake脚本中链接相关动态库
开发步骤
1.  确定密钥别名keyAlias，密钥别名最大长度为128字节。
2.  初始化参数集：通过OH_Huks_InitParamSet、OH_Huks_AddParams、OH_Huks_BuildParamSet构造参数集paramSet，参数集中必须包含OH_Huks_KeyAlg，OH_Huks_KeySize，OH_Huks_KeyPurpose属性。
3.  将密钥别名与参数集作为参数传入OH_Huks_AnonAttestKeyItem方法中，即可证明密钥。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-other-operations-V14
爬取时间: 2025-04-28 02:26:09
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-check-key-V14
爬取时间: 2025-04-28 02:26:23
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-check-key-arkts-V14
爬取时间: 2025-04-28 02:26:36
来源: Huawei Developer
HUKS提供了接口供应用查询指定密钥是否存在。
开发步骤
1.  指定密钥别名keyAlias，密钥别名最大长度为128字节。
2.  初始化密钥属性集。用于查询时指定密钥的属性TAG，当查询单个密钥时，TAG字段可传空。
3.  调用接口hasKeyItem，查询密钥是否存在。
```typescript
import { huks } from '@kit.UniversalKeystoreKit';
/* 1.确定密钥别名 */
let keyAlias = 'test_key';
let isKeyExist: Boolean;
/* 2.构造空对象 */
let huksOptions: huks.HuksOptions = {
properties: []
}
try {
/* 3.判断密钥是否存在 */
huks.hasKeyItem(keyAlias, huksOptions, (error, data) => {
if (error) {
console.error(`callback: hasKeyItem failed, ` + JSON.stringify(error));
} else {
if (data !== null && data.valueOf() !== null) {
isKeyExist = data.valueOf();
console.info(`callback: hasKeyItem success, isKeyExist = ${isKeyExist}`);
}
}
});
} catch (error) {
console.error(`callback: hasKeyItem input arg invalid, ` + JSON.stringify(error));
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-check-key-ndk-V14
爬取时间: 2025-04-28 02:26:50
来源: Huawei Developer
HUKS提供了接口供应用查询指定密钥是否存在。
在CMake脚本中链接相关动态库
开发步骤
1.  构造对应参数。
2.  调用接口OH_Huks_IsKeyItemExist，查询密钥是否存在。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-obtain-key-properties-V14
爬取时间: 2025-04-28 02:27:03
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-obtain-key-properties-arkts-V14
爬取时间: 2025-04-28 02:27:17
来源: Huawei Developer
HUKS提供了接口供业务获取指定密钥的相关属性。在获取指定密钥属性前，需要确保已在HUKS中生成或导入持久化存储的密钥。
轻量级设备不支持获取密钥属性功能。
开发步骤
1.  指定待查询的密钥别名keyAlias，密钥别名最大长度为128字节。
2.  调用接口getKeyItemProperties，传入参数keyAlias和options。 options为预留参数，当前可传入空。
3.  返回值为HuksReturnResult类型对象，获取的属性集在properties字段中。
```typescript
import { huks } from '@kit.UniversalKeystoreKit';
/* 1. 设置密钥别名 */
let keyAlias = 'keyAlias';
/* option对象传空 */
let emptyOptions: huks.HuksOptions = {
properties: []
};
try {
/* 2. 获取密钥属性 */
huks.getKeyItemProperties(keyAlias, emptyOptions, (error, data) => {
if (error) {
console.error(`callback: getKeyItemProperties failed, ` + JSON.stringify(error));
} else {
console.info(`callback: getKeyItemProperties success, data = ${JSON.stringify(data)}`);
}
});
} catch (error) {
console.error(`callback: getKeyItemProperties input arg invalid, ` + JSON.stringify(error));
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-obtain-key-properties-ndk-V14
爬取时间: 2025-04-28 02:27:31
来源: Huawei Developer
HUKS提供了接口供业务获取指定密钥的相关属性。在获取指定密钥属性前，需要确保已在HUKS中生成或导入持久化存储的密钥。
轻量级设备不支持获取密钥属性功能。
在CMake脚本中链接相关动态库
开发步骤
1.  构造对应参数。
2.  调用接口OH_Huks_GetKeyItemParamSet，传入上述参数。
3.  返回值为成功码/错误码，获取成功后，从参数集中读取需要的参数。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-export-key-V14
爬取时间: 2025-04-28 02:27:44
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-export-key-arkts-V14
爬取时间: 2025-04-28 02:27:58
来源: Huawei Developer
业务需要获取持久化存储的非对称密钥的公钥时使用，当前支持ECC/RSA/ED25519/X25519/SM2的公钥导出。
轻量级设备仅支持RSA公钥导出。
开发步骤
1.  指定密钥别名keyAlias，密钥别名最大长度为128字节。
2.  调用接口exportKeyItem，传入参数keyAlias和options。 options为预留参数，当前可传入空。
3.  返回值为HuksReturnResult类型对象，获取的公钥明文在outData字段中，以标准的X.509规范的DER格式封装，具体请参考公钥材料格式。
```typescript
import { huks } from '@kit.UniversalKeystoreKit';
/* 1. 设置密钥别名 */
let keyAlias = 'keyAlias';
/* option对象传空 */
let emptyOptions: huks.HuksOptions = {
properties: []
};
try {
/* 2. 导出密钥 */
huks.exportKeyItem(keyAlias, emptyOptions, (error, data) => {
if (error) {
console.error(`callback: exportKeyItem failed, ` + error);
} else {
console.info(`callback: exportKeyItem success, data = ${JSON.stringify(data)}`);
}
});
} catch (error) {
console.error(`callback: exportKeyItem input arg invalid, ` + JSON.stringify(error));
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-export-key-ndk-V14
爬取时间: 2025-04-28 02:28:12
来源: Huawei Developer
业务需要获取持久化存储的非对称密钥的公钥时使用，当前支持ECC/RSA/ED25519/X25519/SM2的公钥导出。
轻量级设备仅支持RSA公钥导出。
在CMake脚本中链接相关动态库
开发步骤
1.  构造对应参数。
2.  调用接口OH_Huks_GetKeyItemParamSet，传入上述参数。
3.  返回值为成功码/错误码，导出公钥以标准的X.509规范的DER格式封装在参数key中，具体请参考公钥材料格式。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-list-aliases-V14
爬取时间: 2025-04-28 02:28:25
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-list-aliases-arkts-V14
爬取时间: 2025-04-28 02:28:39
来源: Huawei Developer
HUKS提供了接口供应用查询密钥别名集。
轻量级设备不支持查询密钥别名集功能。
开发步骤
1.  初始化密钥属性集。用于查询指定密钥别名集TAG，TAG仅支持HUKS_TAG_AUTH_STORAGE_LEVEL。
2.  调用接口listAliases，查密钥别名集。
```typescript
/*
* 以下查询密钥别名集Promise操作使用为例
*/
import { huks } from '@kit.UniversalKeystoreKit'
async function testListAliases() {
/* 1.初始化密钥属性集 */
let queryProperties: Array<huks.HuksParam> = [
{
tag: huks.HuksTag.HUKS_TAG_AUTH_STORAGE_LEVEL,
value: huks.HuksAuthStorageLevel.HUKS_AUTH_STORAGE_LEVEL_DE
}
];
let queryOptions: huks.HuksOptions = {
properties: queryProperties
};
try {
/* 2.查询密钥别名集 */
let result: huks.HuksListAliasesReturnResult = await huks.listAliases(queryOptions);
console.info(`promise: listAliases success`);
} catch (error) {
console.error(`promise: listAliases fail`);
}
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/huks-list-aliases-ndk-V14
爬取时间: 2025-04-28 02:28:53
来源: Huawei Developer
HUKS提供了接口供应用查询密钥别名集。
轻量级设备不支持查询密钥别名集功能。
在CMake脚本中链接相关动态库
开发步骤
1.  初始化密钥属性集。用于查询指定密钥别名集TAG，TAG仅支持OH_HUKS_TAG_AUTH_STORAGE_LEVEL。
2.  调用接口OH_Huks_ListAliases，查询密钥别名集。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/user-authentication-kit-V14
爬取时间: 2025-04-28 02:29:06
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/user-authentication-overview-V14
爬取时间: 2025-04-28 02:29:20
来源: Huawei Developer
User Authentication Kit（用户认证服务）提供了基于用户在设备本地注册的锁屏口令、人脸和指纹来认证用户身份的能力。
提供了系统级用户身份认证功能，并提供了多设备统一的、集多种认证方式（人脸、指纹、口令）于一体的系统级用户身份认证控件。
用户向应用/系统服务请求访问某些个人数据或执行某些敏感操作时，应用/系统服务将调用系统用户身份认证控件对用户身份进行认证，认证通过后，才响应用户对于数据或敏感操作的执行请求。
用户身份认证可用于各种鉴权场景，如应用内账号登录、支付认证等。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170457.52570503717651923352303930421126:50001231000000:2800:A15F6AED39F24F45CCB27C927113237544535A7415499F800A69AD54417FDE48.png)
亮点/特征
-  归一化认证接口 屏蔽不同认证因子的差异，调用锁屏口令、人脸、指纹认证的接口归一。 同一套接口提供人脸、指纹、锁屏密码的组合认证方式。 同一套接口提供人脸认证、指纹认证和业务自定义认证的组合。
-  支持感知认证可信等级差异 支持调用者指定期望的认证可信等级，避免将低安认证能力应用在高风险操作的用户鉴权场景，例如将防伪能力不够的2D人脸认证用于支付场景。
-  支持业务自定义认证方式 支持带导航键的认证界面，用户点击导航键可切换业务自定义认证界面。
-  支持短时间内复用设备解锁认证结果 支持认证方式无关的解锁认证结果复用，采用该认证方式，只要在解锁后调用者指定的时间范围内（最长5min），可不用重复认证用户直接返回认证通过结果。 支持认证方式匹配的解锁认证结果复用，采用该认证方式，不仅需要处于调用者指定的解锁后时间范围内，还需要解锁使用的认证方式与调用者指定的一致，才能复用解锁认证结果，返回认证通过。
-  提供系统级用户身份认证界面 支持调用者自定义认证界面的标题和导航键文字。 身份认证控件会根据设备屏幕状态自适应调整窗口显示模式。
-  支持感知注册凭据的变化 业务开通时，从认证成功结果中获取用户凭据的状态，或者直接查询用户凭据的状态，将注册的凭据状态存储起来。当调用者需要感知用户凭据变化时，需要从当前认证成功结果获取凭据的状态，或者查询当前凭据的状态，通过对比差异感知凭据状态的变化。
运作机制
统一用户认证框架架构如下图所示。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170457.89379368571899540437862270347019:50001231000000:2800:29BD53287BA27022DD2D34A2137E35B45EAF492F549A57194C9B06443AFAF40B.png)
用户认证框架主要包括四个部分：
1.  统一用户认证API：提供归一化的系统用户身份认证能力调用接口。屏蔽认证差异，便于开发者调用系统能力认证用户身份。
2.  统一用户认证框架：包括框架层的SA和驱动，负责调度系统上的各种身份认证能力和用户认证控件，来完成业务通过统一用户认证API发起的用户认证请求。
3.  统一用户认证控件：实现了各种认证方式的用户身份认证交互界面，确保一致的用户身份认证体验，供统一身份认证框架调用。
4.  各种认证能力：包括口令认证、人脸认证和指纹认证，分别实现了基于锁屏口令、人脸和指纹认证用户身份的能力，供统一用户认证框架调度。
用户身份认证通过后，统一用户认证框架会在设备可信执行环境中签发用户身份认证通过证明，简称AuthToken。
从图的左侧，可以看到应用使用用户身份认证功能完成用户鉴权的过程：当应用需要调用通用密钥库服务中需用户授权才能访问的密钥时，应用可以将获取到的AuthToken随密钥调用请求一同提供给通用密钥库服务，作为密钥二次访问控制的用户鉴权证明。通用密钥库服务在可信执行环境中校验了AuthToken的合法性和有效性后，便会响应业务请求，执行对应的密钥操作。
AuthToken数据结构
明文段
| 名称  | 内容  | 类型  | 说明  |
| --- | --- | --- | --- |
| version  | token版本号  | uint32_t  | 当前为2.0。  |
| challenge  | 认证随机挑战  | uint8_t[32]  | 需要校验认证结果的业务方生成的一次性随机挑战。  |
| time  | 认证通过时戳  | uint64_t  | 认证通过时戳。  |
| authTrustLevel  | 认证可信等级  | uint32_t  | 见认证可信等级划分原则。  |
| authType  | 认证类型  | uint32_t  | 认证通过采用的认证类型，包括人脸、指纹、口令（特指锁屏密码认证）。  |
| authMode  | 操作类型  | uint32_t  | 操作类型：识别/认证。  |
| securityLevel  | token签发环境安全等级  | uint32_t  | token签发环境安全等级。  |
名称
内容
类型
说明
version
token版本号
uint32_t
当前为2.0。
challenge
认证随机挑战
uint8_t[32]
需要校验认证结果的业务方生成的一次性随机挑战。
time
认证通过时戳
uint64_t
认证通过时戳。
authTrustLevel
认证可信等级
uint32_t
见认证可信等级划分原则。
authType
认证类型
uint32_t
认证通过采用的认证类型，包括人脸、指纹、口令（特指锁屏密码认证）。
authMode
操作类型
uint32_t
操作类型：识别/认证。
securityLevel
token签发环境安全等级
uint32_t
token签发环境安全等级。
密文段
| 名称  | 内容  | 类型  | 说明  |
| --- | --- | --- | --- |
| userId  | 用户ID  | int32_t  | 系统在创建用户时给用户分配的ID。  |
| secureUid  | 安全用户ID  | uint64_t  | 用户注册系统口令时为用户随机分配的ID，在用户删除口令时删除，变更口令时该ID不变。  |
| enrolledId  | 凭据注册ID  | uint64_t  | 用户每录入一个凭据，该用户的该类型凭据的enrolledId便会更换一个随机值，删除凭据时该ID不变。  |
| credentialId  | 匹配上的凭据ID  | uint64_t  | 随机分配给用户注册的人脸、指纹等凭据的ID。  |
名称
内容
类型
说明
userId
用户ID
int32_t
系统在创建用户时给用户分配的ID。
secureUid
安全用户ID
uint64_t
用户注册系统口令时为用户随机分配的ID，在用户删除口令时删除，变更口令时该ID不变。
enrolledId
凭据注册ID
uint64_t
用户每录入一个凭据，该用户的该类型凭据的enrolledId便会更换一个随机值，删除凭据时该ID不变。
credentialId
匹配上的凭据ID
uint64_t
随机分配给用户注册的人脸、指纹等凭据的ID。
标签段
| 名称  | 内容  | 类型  | 说明  |
| --- | --- | --- | --- |
| tag  | 密文段的TAG  | uint8_t[16]  | 密文字段采用AES-GCM加密生成的TAG。  |
| iv  | 密文段加密使用的IV  | uint8_t[12]  | 密文字段采用AES-GCM加密采用的随机IV。  |
| sign  | token的完整性保护签名  | uint8_t[32]  | 用于整个AuthToken的完整性保护。  |
名称
内容
类型
说明
tag
密文段的TAG
uint8_t[16]
密文字段采用AES-GCM加密生成的TAG。
iv
密文段加密使用的IV
uint8_t[12]
密文字段采用AES-GCM加密采用的随机IV。
sign
token的完整性保护签名
uint8_t[32]
用于整个AuthToken的完整性保护。
认证可信等级划分原则
系统采用三种指标来衡量认证可信等级（AuthTrustLevel），具体认证可信等级如下表所示。
-  FRR（False Rejection Rate）：将合法用户当做非法用户拒绝的概率。
-  FAR（False Acceptance Rate）：将非法用户当做合法用户接受的概率，又称为误闯率。
-  SAR（Spoof Acceptance Rate）：接受一个基于合法生物特征复制的、非活体的样本概率。
FAR越低，FRR越高，认证的安全性越高，但使用便捷性越差。
| 认证可信等级  | 认证能力指标  | 说明&举例  | 典型应用场景  |
| --- | --- | --- | --- |
| ATL4  | FRR=10%时，FAR≤0.0001%，SAR≤3%  | 能高精度地识别用户个体，有很强的活体检测能力，如采用了安全键盘的6位及以上PIN码认证和有特殊安全增强的指纹与3D人脸认证。  | 小额支付  |
| ATL3  | FRR=10%时，FAR≤0.002%，SAR≤7%  | 能精确识别用户个体，有较强的活体检测能力，如有特殊安全增强的2D人脸认证。  | 设备解锁  |
| ATL2  | FRR=10%时，FAR≤0.002%，7%<SAR≤20%  | 能精确识别用户个体，有一定的活体检测能力，如使用普通相机采集图像的2D人脸认证。  | 维持设备解锁状态  |
| ATL1  | FRR=10%时，FAR≤1%，7%<SAR≤20%  | 能识别用户个体，有一定的活体检测能力，如声纹认证。  | 业务风控、精准推荐、个性化服务  |
认证可信等级
认证能力指标
说明&举例
典型应用场景
ATL4
FRR=10%时，FAR≤0.0001%，SAR≤3%
能高精度地识别用户个体，有很强的活体检测能力，如采用了安全键盘的6位及以上PIN码认证和有特殊安全增强的指纹与3D人脸认证。
小额支付
ATL3
FRR=10%时，FAR≤0.002%，SAR≤7%
能精确识别用户个体，有较强的活体检测能力，如有特殊安全增强的2D人脸认证。
设备解锁
ATL2
FRR=10%时，FAR≤0.002%，7%<SAR≤20%
能精确识别用户个体，有一定的活体检测能力，如使用普通相机采集图像的2D人脸认证。
维持设备解锁状态
ATL1
FRR=10%时，FAR≤1%，7%<SAR≤20%
能识别用户个体，有一定的活体检测能力，如声纹认证。
业务风控、精准推荐、个性化服务
约束与限制
三方应用调用系统本地身份认证能力，必须使用系统自带的身份认证控件。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/user-authentication-dev-V14
爬取时间: 2025-04-28 02:29:33
来源: Huawei Developer

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/prerequisites-V14
爬取时间: 2025-04-28 02:29:47
来源: Huawei Developer
应用在开发用户身份认证功能时，需要先了解以下流程，并根据实际需求参考对应指导开发。
-  查询设备支持的用户身份认证能力。
-  发起身份认证请求，获取身份认证结果。
-  校验和使用认证结果：请参考通用密钥库二次认证密钥访问控制。
-  （可选）认证过程中取消认证。
-  （可选）切换自定义认证。
申请权限
在开发具备用户身份认证的应用前，需要先申请权限ohos.permission.ACCESS_BIOMETRIC，应用才能使用生物特征识别能力（如人脸、指纹）进行身份认证。
该权限授权方式为system_grant（系统授权），开发者只需要在module.json5配置文件的requestPermissions标签中声明权限，即可获取系统授权。具体声明指导请参考申请应用权限-声明权限。

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/obtain-supported-authentication-capabilities-V14
爬取时间: 2025-04-28 02:30:00
来源: Huawei Developer
不同的设备对于认证能力（人脸、指纹、口令）的支持性各有差异，开发者在发起认证前应当先查询当前设备支持的用户认证能力。
接口说明
具体参数、返回值、错误码等描述，请参考对应的API文档。
| 接口名称 | 功能描述 |
| --- | --- |
| getAvailableStatus(authType : UserAuthType, authTrustLevel : AuthTrustLevel): void | 根据指定的认证类型、认证等级，检测当前设备是否支持相应的认证能力。 |
开发步骤
1.  申请权限：ohos.permission.ACCESS_BIOMETRIC。
2.  指定认证类型（UserAuthType）和认证等级（AuthTrustLevel），调用getAvailableStatus接口查询当前的设备是否支持相应的认证能力。 认证可信等级的详细介绍请参见认证可信等级划分原则。
以查询设备是否支持认证可信等级≥ATL1的人脸认证功能为例：
```typescript
import { BusinessError } from  '@kit.BasicServicesKit';
import { userAuth } from '@kit.UserAuthenticationKit';
// 查询认证能力是否支持
try {
userAuth.getAvailableStatus(userAuth.UserAuthType.FACE, userAuth.AuthTrustLevel.ATL1);
console.info('current auth trust level is supported');
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`current auth trust level is not supported. Code is ${err?.code}, message is ${err?.message}`);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/start-authentication-V14
爬取时间: 2025-04-28 02:30:14
来源: Huawei Developer
应用发起身份认证请求，获取身份认证结果，从而访问受保护的系统/服务/应用的功能和数据（包括用户个人数据）。
接口说明
具体参数、返回值、错误码等描述，请参考对应的API文档。
| 接口名称 | 功能描述 |
| --- | --- |
| getUserAuthInstance(authParam: AuthParam, widgetParam: WidgetParam): UserAuthInstance | 获取UserAuthInstance对象，用于执行用户身份认证，并支持使用统一用户身份认证控件。 |
| on(type: 'result', callback: IAuthCallback): void | 订阅用户身份认证结果。 |
| off(type: 'result', callback?: IAuthCallback): void | 取消订阅用户身份认证结果。 |
| start(): void | 执行用户认证。 |
接口名称
功能描述
getUserAuthInstance(authParam: AuthParam, widgetParam: WidgetParam): UserAuthInstance
获取UserAuthInstance对象，用于执行用户身份认证，并支持使用统一用户身份认证控件。
on(type: 'result', callback: IAuthCallback): void
订阅用户身份认证结果。
off(type: 'result', callback?: IAuthCallback): void
取消订阅用户身份认证结果。
start(): void
执行用户认证。
用户身份认证控件介绍
系统提供了统一的用户认证控件供应用调用，使用用户认证控件的优势：
-  统一用户认证服务将通过该控件完成信息的识别和认证，再将认证结果返回给应用，整体过程安全可控，可以更好地保护用户的生物特征信息。
-  统一固定的UI组件样式，便于用户识别。
认证控件的样式如图所示，通过WidgetParam配置对应参数。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170458.72928248861493064946981018187232:50001231000000:2800:0F5195C91AAC3CDD41CA29A83585F78D7D94AC2333D92FBE62FAD5CF1DF904B1.png)
-  标注1：用户认证界面的标题（WidgetParam.title），最大长度为500字符。应用可在此配置符合场景的字符串。
-  标注2：导航按键上显示的文本（WidgetParam.navigationButtonText），最大长度为60字符。仅在单指纹、单人脸场景下支持配置。 当生物认证失败后，将出现该按钮，点击后从生物认证切换到应用自定义认证。
当前支持使用认证控件的认证类型包括：
-  锁屏密码认证
-  人脸认证
-  指纹认证
-  人脸+锁屏密码认证
-  指纹+锁屏密码认证
-  人脸+指纹+锁屏密码认证
当前仅在单指纹、单人脸场景下支持配置导航按键上显示的文本（WidgetParam.navigationButtonText）。
开发步骤
1.  申请权限：ohos.permission.ACCESS_BIOMETRIC。
2.  指定用户认证相关参数AuthParam（包括挑战值、认证类型UserAuthType列表和认证等级AuthTrustLevel）、配置认证控件界面WidgetParam，调用getUserAuthInstance获取认证对象。
3.  调用UserAuthInstance.on接口订阅认证结果。
4.  调用UserAuthInstance.start接口发起认证，通过IAuthCallback回调返回认证结果UserAuthResult。 当认证成功时返回认证通过类型（UserAuthType）和令牌信息（AuthToken）。
示例1：
发起用户认证，采用认证可信等级≥ATL3的人脸+锁屏密码认证，获取认证结果：
```typescript
// API version 10
import { BusinessError } from '@kit.BasicServicesKit';
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { userAuth } from '@kit.UserAuthenticationKit';
try {
const rand = cryptoFramework.createRandom();
const len: number = 16; // Generate a 16-byte random number.
const randData: Uint8Array = rand?.generateRandomSync(len)?.data;
// 设置认证参数
const authParam: userAuth.AuthParam = {
challenge: randData,
authType: [userAuth.UserAuthType.PIN, userAuth.UserAuthType.FACE],
authTrustLevel: userAuth.AuthTrustLevel.ATL3,
};
// 配置认证界面
const widgetParam: userAuth.WidgetParam = {
title: '请进行身份认证',
};
// 获取认证对象
const userAuthInstance = userAuth.getUserAuthInstance(authParam, widgetParam);
console.info('get userAuth instance success');
// 订阅认证结果
userAuthInstance.on('result', {
onResult(result) {
console.info(`userAuthInstance callback result: ${JSON.stringify(result)}`);
// 可在认证结束或其他业务需要场景，取消订阅认证结果
userAuthInstance.off('result');
}
});
console.info('auth on success');
userAuthInstance.start();
console.info('auth start success');
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`auth catch error. Code is ${err?.code}, message is ${err?.message}`);
}
```
示例2：
发起用户认证，采用认证可信等级≥ATL3的人脸 + 认证类型相关 + 复用设备解锁最大有效时长认证，获取认证结果：
```typescript
// API version 10
import { BusinessError } from  '@kit.BasicServicesKit';
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { userAuth } from '@kit.UserAuthenticationKit';
// 设置认证参数
let reuseUnlockResult: userAuth.ReuseUnlockResult = {
reuseMode: userAuth.ReuseMode.AUTH_TYPE_RELEVANT,
reuseDuration: userAuth.MAX_ALLOWABLE_REUSE_DURATION,
}
try {
const rand = cryptoFramework.createRandom();
const len: number = 16;
const randData: Uint8Array = rand?.generateRandomSync(len)?.data;
const authParam: userAuth.AuthParam = {
challenge: randData,
authType: [userAuth.UserAuthType.FACE],
authTrustLevel: userAuth.AuthTrustLevel.ATL3,
reuseUnlockResult: reuseUnlockResult,
};
// 配置认证界面
const widgetParam: userAuth.WidgetParam = {
title: '请进行身份认证',
};
// 获取认证对象
const userAuthInstance = userAuth.getUserAuthInstance(authParam, widgetParam);
console.info('get userAuth instance success');
// 订阅认证结果
userAuthInstance.on('result', {
onResult(result) {
console.info(`userAuthInstance callback result: ${JSON.stringify(result)}`);
// 可在认证结束或其他业务需要场景，取消订阅认证结果
userAuthInstance.off('result');
}
});
console.info('auth on success');
userAuthInstance.start();
console.info('auth start success');
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`auth catch error. Code is ${err?.code}, message is ${err?.message}`);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/cancel-authentication-V14
爬取时间: 2025-04-28 02:30:27
来源: Huawei Developer
统一用户认证框架提供了cancel接口，当应用在认证过程中，需要取消认证时可调用该接口。
接口说明
具体参数、返回值、错误码等描述，请参考对应的API文档。
此处仅展示了取消认证操作的接口，在取消认证前，需要先发起认证，发起认证的接口列表、详细说明可参考发起认证章节和API文档。
| 接口名称 | 功能描述 |
| --- | --- |
| cancel(): void | 取消本次认证操作。 |
开发步骤
1.  申请权限：ohos.permission.ACCESS_BIOMETRIC。
2.  指定用户认证相关参数AuthParam（包括挑战值、认证类型UserAuthType列表和认证等级AuthTrustLevel），获取认证对象UserAuthInstance，并调用UserAuthInstance.start发起认证。 此步骤详细说明可参考发起认证。
3.  通过使用已经成功发起认证的UserAuthInstance对象调用UserAuthInstance.cancel接口取消本次认证。
示例代码为发起认证可信等级≥ATL3的人脸+锁屏密码认证后，取消认证请求：
```typescript
import { BusinessError } from  '@kit.BasicServicesKit';
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { userAuth } from '@kit.UserAuthenticationKit';
try {
const rand = cryptoFramework.createRandom();
const len: number = 16;
const randData: Uint8Array = rand?.generateRandomSync(len)?.data;
// 设置认证参数
const authParam: userAuth.AuthParam = {
challenge: randData,
authType: [userAuth.UserAuthType.PIN, userAuth.UserAuthType.FACE],
authTrustLevel: userAuth.AuthTrustLevel.ATL3,
};
// 配置认证界面
const widgetParam: userAuth.WidgetParam = {
title: '请进行身份认证',
};
// 获取认证对象
const userAuthInstance = userAuth.getUserAuthInstance(authParam, widgetParam);
console.info('get userAuth instance success');
// 开始认证
userAuthInstance.start();
console.info('auth start success');
// 取消认证
userAuthInstance.cancel();
console.info('auth cancel success');
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`auth catch error. Code is ${err?.code}, message is ${err?.message}`);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/apply-custom-authentication-V14
爬取时间: 2025-04-28 02:30:41
来源: Huawei Developer
统一用户认证框架提供了切换业务自定义认证机制。如果设备厂商自定义了其他认证能力对接到统一用户认证框架，应用开发者可以切换到自定义认证的方式。
例如，在支付场景中，如果厂商自定义了支付密码认证的方式，当调用系统人脸或指纹认证失败后，用户可以选择切换支付密码认证。
支付密码认证不属于系统认证能力，因此业务在发起认证时需要传入导航键的显式信息，如“使用支付密码”，这样用户看到的认证界面便会包含一个“使用支付密码”的按钮。
当用户点击该按钮，发起认证的业务应用便会收到统一用户认证框架返回的一个特殊认证结果，提示业务系统认证结束，需要拉起业务自定义的认证界面。这样，用户在点击“使用支付密码”按钮后，便会看到系统认证控件消失，显示出业务自定义的支付密码认证界面。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170458.52493458824409590046961880888239:50001231000000:2800:2809C7E2AFDA14AEEFCA06E4E881884F18FB0F13B60BD65A42083F75D35E88D4.png)
如图，框选区域为WidgetParam.navigationButtonText字段显示，开发者可配置此字段，引导用户从生物认证切换到应用自定义业务密码认证。
锁屏密码认证与业务自定义认证只能二选一，不能同时存在。
| 认证类型  | 支持切换业务自定义认证方式  |
| --- | --- |
| 锁屏密码认证  | ×  |
| 人脸认证  | √  |
| 指纹认证  | √  |
| 人脸+锁屏密码认证  | ×  |
| 指纹+锁屏密码认证  | ×  |
| 人脸+指纹+锁屏密码认证  | ×  |
认证类型
支持切换业务自定义认证方式
锁屏密码认证
×
人脸认证
√
指纹认证
√
人脸+锁屏密码认证
×
指纹+锁屏密码认证
×
人脸+指纹+锁屏密码认证
×
开发示例
针对需要切换自定义认证方式的场景，发起认证请求的方式请参考发起认证，但在传入的widgetParam需包含字段navigationButtonText。
当前示例仅展示如何配置界面、选择切换到自定义认证界面，具体拉起的页面及对应页面的实现，请开发者自行实现，代码插入位置可参考注释提示。
```typescript
import { BusinessError } from  '@kit.BasicServicesKit';
import { cryptoFramework } from '@kit.CryptoArchitectureKit';
import { userAuth } from '@kit.UserAuthenticationKit';
try {
const rand = cryptoFramework.createRandom();
const len: number = 16;
const randData: Uint8Array = rand?.generateRandomSync(len)?.data;
const authParam: userAuth.AuthParam = {
challenge: randData,
authType: [userAuth.UserAuthType.FACE],
authTrustLevel: userAuth.AuthTrustLevel.ATL3,
};
// 配置认证界面需设置navigationButtonText
const widgetParam: userAuth.WidgetParam = {
title: '请验证身份',
navigationButtonText: '使用密码',
};
// 获取认证对象
const userAuthInstance = userAuth.getUserAuthInstance(authParam, widgetParam);
console.log('get userAuth instance success');
// 订阅认证结果
userAuthInstance.on('result', {
onResult(result) {
// 若收到ResultCode值为12500000，代表操作成功
console.log('userAuthInstance callback result = ' + JSON.stringify(result));
// 若收到ResultCode值为12500011,说明用户点击了导航按钮想切换自定义认证方式
if (result.result == 12500011) {
//请开发者自行完成拉起自定义认证界面的实现
}
}
});
console.log('auth on success');
userAuthInstance.start();
console.log('auth start success');
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`auth catch error. Code is ${err?.code}, message is ${err?.message}`);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/obtain-enrolled-state-capabilities-V14
爬取时间: 2025-04-28 02:30:55
来源: Huawei Developer
调用者需感知用户注册凭据（人脸、指纹、口令）的变化，可以通过该接口查询当前用户注册凭据的状态。
接口说明
具体参数、返回值、错误码等描述，请参考对应的API文档。
| 接口名称 | 功能描述 |
| --- | --- |
| getEnrolledState(authType : UserAuthType): EnrolledState | 根据指定的认证类型，查询用户注册凭据的状态，用于感知注册凭据变化。 |
开发步骤
1.  申请权限：ohos.permission.ACCESS_BIOMETRIC。
2.  指定认证类型（UserAuthType），调用getEnrolledState接口查询用户注册凭据的状态。
以查询用户人脸注册凭据的状态为例：
```typescript
import { BusinessError } from  '@kit.BasicServicesKit';
import { userAuth } from '@kit.UserAuthenticationKit';
try {
let enrolledState = userAuth.getEnrolledState(userAuth.UserAuthType.FACE);
console.info(`get current enrolled state success, enrolledState: ${JSON.stringify(enrolledState)}`);
} catch (error) {
const err: BusinessError = error as BusinessError;
console.error(`get current enrolled state failed, Code is ${err?.code}, message is ${err?.message}`);
}
```

URL: https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V14/user-auth-icon-V14
爬取时间: 2025-04-28 02:31:08
来源: Huawei Developer
主要用于提供应用界面上展示的人脸、指纹认证图标，具体功能如下：
当前支持使用认证控件的认证类型包括：
以指纹认证为例，控件使用效果如图所示。应用集成嵌入式用户身份认证控件后，用户点击左图中的指纹图标（即嵌入式用户身份认证控件），系统将会拉起右图中系统身份认证控件完成身份认证功能，开发者无需通过接口发起身份认证请求，使得身份认证的流程更为简单、便捷。
![Image](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170458.70957213451920091641722822999587:50001231000000:2800:CF0B564B62F126EF8F5B889D962509495FA523B9D5EFB4710E9635CD712A1DC6.png)
示例
具体参数、使用方式等信息，请参考对应的API文档。

